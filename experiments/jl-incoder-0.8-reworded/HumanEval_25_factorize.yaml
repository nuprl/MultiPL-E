name: HumanEval_25_factorize
language: jl
prompt: "\"\"\" Return vector of prime factors of given integer in the order from\
  \ smallest to largest.\n    Each of the factors should be vectored number of times\
  \ corresponding to how many times it appeares in factorization.\n    Input number\
  \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2,\
  \ 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n\
  \    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n"
tests: "using Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
  \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
  \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t\
  @test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3,\
  \ 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
completions: ["    factorization = factor(n)\n    factors = Array{Int64}(undef, length(factorization))\n\
    \    i = 1\n    for factor in factorization\n        factors[i] = factor\n   \
    \     i += 1\n    end\n    return factors\nend", "    factors = zeros(Int, n)\n\
    \    \n    for k in 1:n\n        if isPrime(k) == true\n            for i = 2:k\n\
    \                if k%i == 0\n                    factors[k] = i\n           \
    \         k /= i\n                    break\n            end\n        end\n  \
    \  end\n    \n    return factors\nend", "    if isPrime(n)\n        return [Int(n)]\n\
    \    factors = factor(n)\n    res = []\n    for factor in factors\n        for\
    \ n in factors\n            res << (factor * n)\n    end\n    return res\nend\n\
    </cell>\n<code language=julia-1.6>\n\"\"\"\nReturns vector of primes of the given\
    \ integer in the order from smallest to largest.\nEach of the factors should be\
    \ vectored number of times corresponding to how many times it appeares in factorization.\n\
    Input number should be equal to the product of all factors\n\"\"\"", "    \n \
    \   factors = []\n    \n    # To factorize a number n, the process starts off\
    \ by finding the prime factors\n    # of the number and then multiplies them together\
    \ to get a number that is \n    # factorized from the product of all factors.\n\
    \    \n    # To get the prime factors of a number n, we first find prime factors\
    \ and then \n    # multiply them together to get a number that is factorized from\
    \ the product \n    # of all factors.\n    if n % 2 == 0\n        factors.append(2)\n\
    \        n = n / 2\n    end\n    \n    for x in 2:round(Int, sqrt(n))\n      \
    \  if n % x == 0\n            push!(factors, x)\n            n /= x\n        end\n\
    \    end\n    \n    return factors\nend\n</cell>\n<code language=julia-1.5>",
  "    vec=[]\n    temp=[]\n    for x in 1:(n/2)\n        temp=[]\n        temp=factorize(n-x)\n\
    \        for x in 1:length(temp)\n            for y in 1:(temp[x])\n         \
    \       push!(vec,temp[x]*y)\n            end\n        end\n    end\n    return\
    \ vec\nend", "    return factorize(factorial(n))\nend", "    \n    if n == 1 \n\
    \        return [n ]\n    \n    factors = []\n    # find the factors\n    div,\
    \ mod = n % 2, n-1\n    while div > 0\n        if div == 1 \n            factors.push(mod)\n\
    \            break\n        div, mod = div % 2, mod \n    end", "    factors =\
    \ factorization(n)\n    return map(factors, factors)\nend\n</cell>\n<text>\nExercise\
    \ 3: What is the number of factors of $2^16$ ($2^4 + 1$)?\nWrite a function that\
    \ calculates $2^16$ factors.\nMake sure to write it efficiently.\nTry to make\
    \ your function more general (more efficient as $N$ is big).", "    factorization\
    \ = prime_factorization(n)\n    factorization = sort(factorization)\n    return\
    \ factorization\nend\n</cell>\n<text>\nPrime factorization with BigInt\nAs far\
    \ as I know, there is no big integer library in Julia, so it is quite hard to\
    \ compute very large factorials, even not for large numbers. Even if we can use\
    \ vectorized functions, it is still impossible to compute large factorials for\
    \ BigInts.", "    factors = factor(n)\n    \n    factorization = Vector{Int64}()\n\
    \    push!(factorization, 1)\n    \n    for i in 2:length(factors)\n        push!(factorization,\
    \ factors[i]*factors[i-1])\n    end", "    \n    if n == 1 \n        return [1]\n\
    \    \n    # Find prime factors of n\n    i = 2\n    while i <= sqrt(n) do \n\
    \        if n % i == 0 \n            break\n        i += 1\n    end\n    \n  \
    \  # Return array of factors\n    factors = Vector{Int64}()\n    while i <= sqrt(n)\
    \ do \n        if n % i == 0 \n            push!(factors, i)\n            n /=\
    \ i\n        i += 1\n    end\n    \n    push!(factors, n)\n    return factors\n\
    end", "    # initialize array of prime numbers\n    primes = Vector{Int64}()\n\
    \    for p in primes\n        primes += [p]\n    end\n    \n    # loop through\
    \ all primes and update factorization\n    for i in primes\n        nf = factor(n)\n\
    \        \n        for k in nf\n            if n mod k == 0 \n               \
    \ push!(primes, k)\n            end\n        end\n    end\n    \n    return primes\n\
    end", "    factorization = factorizeVector(n)\n    factorization[findall(x ->\
    \ x == 1, factorization)] .= 0\n    return factorization\nend", "    factors =\
    \ factorize(n-1)\n    factors_count = 0\n    f_list = factorization(n-1)\n   \
    \ for x in f_list\n        if x != 1\n            factors_count += 1\n       \
    \ end\n    end\n    factors = factors.^(0:factors_count)\n    factors\nend", " \
    \   if n == 1\n        factors = [1]\n    elseif n >= 2\n        factors = primefactors(n)\n\
    \        factors = Vector{Int64}(factors)\n    end\n    return factors\nend",
  "    prime_array = (2..ceil(sqrt(n)))\n    factorizations =\n        for p in prime_array\n\
    \            if n % p == 0 \n                yield p\n    end\n    factorizations\
    \ = [x for z in factorizations for x in (z => z*z)]\n    return factorizations\n\
    end\n</code>\nAnd that's it.\n<|/ a dscore=1 |>\n<| a tags=primes,functional-programming,ocaml\
    \ dscore=1 |>\n<code>\nlet is_prime n =\n  let rec is_prime n =\n    if n = 0\
    \ then false\n    else if n%2 = 0 then is_prime (n/2)\n    else\n      let p =\
    \ ref (n) in\n      for i = 1 to n/2 do\n        p := n\n        is_prime !p\n\
    \      done\n  in\n  is_prime n\n;;\n</code>\n<|/ a |>\n<| a tags=primes,functional-programming,ocaml\
    \ dscore=1 |>\nMy solution, inspired by this one (written in F#):\n<code>\nlet\
    \ rec factorize n = \n    let rec factorize n k = \n      if k > n then k\n  \
    \    elif n%k = 0 then k\n      else \n        let q = n//k in\n        let r1\
    \ = factorize n k - 1 in\n        if r1 >= 2 then r1 :: [k] else r1::[k]\n   \
    \ in\n    factorize n 2\n;;\n</code>\n<|/ a |>\n<| c |>\nYou probably want to\
    \ return an empty list if n is less than 2 rather than throwing an error.\n<|/\
    \ c |>\n<| a tags=primes,functional-programming,ocaml |>\nHere's a more advanced\
    \ OCaml solution, using lazy sequences and explicit tail recursion. It also shows\
    \ the power of lazy sequences:\n<code>\nlet factorize n = \n  List.map (fun i\
    \ -> (i, n//i)) \n  (List.filter \n   (fun i -> n%i = 0) \n   (factorize n-1))",
  "    factorized_vec = Vector{Int64}()\n    primes = prime_factors(n)\n    for p\
    \ in primes\n        if factorized_vec \u2209 primes\n            factorized_vec\
    \ += [p]\n        end\n    end\n    factorized_vec\nend\n</cell>\n<code language=julia-1.5>\n\
    @time factorize(70)\n@time factorize(75)\n</cell>\n<code language=julia-1.5>",
  "    if n == 0\n        return [1]\n    else\n        div::Int = divrem(n,2)\n \
    \       return [2*div + 1] + factorize(div)\n    end\nend", "    n = checkInt(n)\n\
    \    if n <= 1 \n        return [1]\n    primes = primefactors(n)\n    factors\
    \ = factorization(n)\n    return primes .* factors\nend\n\"\"\"\nReturn vector\
    \ of prime factors of given integer in the order from smallest to largest.\n \
    \   Each of the factors should be vectored number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n\
    \    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"", "  \n    # initialize\
    \ vector with 0 elements\n    a = Vector{Int64}()\n    \n    # compute first five\
    \ prime factors\n    for i in 2:5\n        a[i] = n%i\n        n /= i\n      \
    \  if n == 1\n            break\n        end\n    end", "    factors = []\n  \
    \  while n > 1\n        factors.append(n % 10)\n        n = div(n, 10)\n    end\n\
    \    return factors\nend", "    if n==1 \n        return [1]\n    else\n     \
    \   factors = factor(n)\n        factor = factors[end]\n        new_factors =\
    \ [factor]\n        for i in factors[2:end]\n            if i%factor == 0 \n \
    \               new_factors *= (i/factor)\n            end\n        end\n    \
    \    return new_factors\n    end\nend\n</cell>\n<text>\nFactorization of a number\
    \ $k$ is given as $k^p = \\left(\\prod{i=1}^n x_{i}\\right)^\\frac{p}{p-1}$, where\
    \ $x_i$ is the factor of $k$, e.g. $x_1$ is the smallest factor, $x_n$ is the\
    \ largest factor and $p$ is the prime number of the number $k$. Here, we first\
    \ compute the prime factorization of $k$, then check whether each of the prime\
    \ factors is actually a factor of the original $k$, if so we multiply their frequency\
    \ $x_i$ number of times to the $p$ of the original $k$ to get the $k^p$ factorization.",
  "  factors = [1]\n  for f in factorization(Int(n)) do\n    if f % 2 == 0 \n    \
    \  factors = factors + f\n    elseif f % 2 == 1\n      factors = factors + [2*f]\n\
    \    end\n  end\n  return factors\nend", "    primes = primes(n)\n    factorization\
    \ = []\n    i = 2\n    while i <= n do\n        push!(factorization, primes[i])\n\
    \        i *= primes[i]\n    end\n    factorization\nend\n</cell>\n<code language=julia-1.0>\n\
    factorize(35)\n</cell>\n<code language=julia-1.0>", "    factors = primefactors(n)\n\
    \    factors = sort(factors)\n    \n    temp = zeros(Int, length(factors))\n \
    \   for i = 1:length(factors)\n        for j = 0:i-1\n            if factors[i]*factors[j]\
    \ == n\n                temp[i] += 1\n                break\n            end\n\
    \        end\n    end\n    \n    return temp\nend\n</cell>\n<code language=julia-1.5>\n\
    factorize(12)\n</cell>\n<code language=julia-1.5>", "    # Initialize factorization\
    \ vector\n    facts = zeros(Int64, n)\n    facts[1] = 2\n    \n    # Compute factorization\n\
    \    for i = 2; i<n-1; i+=facts[i]\n        facts[i] = i\n        for j = i-1:-1:1\n\
    \            if facts[j] % i == 0\n                facts[i] = facts[j] // i\n\
    \                break\n        end\n    end\n    \n    return facts\nend", " \
    \   \n    if n==1\n        return [1]\n    else\n        \n        factors=prime_factors(n)\n\
    \        \n        \n        result=[1]\n        for factor in factors\n     \
    \       result=[result;factor*result[end-1]]\n        end\n    \n    \n      \
    \  return result\n    end\nend\n</cell>\n<text>\nThe function prime_factors returns\
    \ all factors of a given number. Its implementation is the same as the one that\
    \ we created earlier.", "    primes = primefactors(n)\n    answer = collect(1:n)\
    \ do i\n        product = 1\n        for p in primes\n            product *= p\n\
    \            product /= i\n            if i == product\n                push!(answer,\
    \ i)\n                break\n            end\n        end\n        answer\n  \
    \  end\n    return answer\nend\n</cell>\n<cell>\n#export", "    if n < 2\n   \
    \     return ones(n,1)\n    else if isPrime(n)\n        return [prime_factors(n)]\n\
    \    else\n        factorization = factorize(n)\n        vectorization = factorization\n\
    \        for (i,j) in factorization\n            vectorization[i] = vectorization[i]*(j-1)\n\
    \        end\n        return vectorization\n    end\nend\n</cell>\n<code language=julia-1.3>\n\
    @assert factorize(8) == [2, 2, 2]\n@assert factorize(25) == [5, 5]\n@assert factorize(70)\
    \ == [2, 5, 7]\n</cell>\n<text>\nExcercise 3", "    \n    v = zeros(Int64, n)\n\
    \    for i in 1:n\n        for j in 1:i\n            if j == 0 \n            \
    \    v[i] += 1\n            else if v[j] >= 2 \n                v[i] += 1\n  \
    \          else \n                continue # skip, already counted\n        end\n\
    \    end\n    return v\nend\n</cell>\n<code language=julia-1.1>\n@time _ = factorize(8)\n\
    </cell>\n<code language=julia-1.1>\n@time _ = factorize(25)\n</cell>\n<code language=julia-1.1>\n\
    @time _ = factorize(70)\n</cell>\n<text>\nFinding Factors", "    factors = zeros(Int,\
    \ length(primes))\n    for p in primes\n        factors[p] += 1\n    end\n   \
    \ factors\nend\n</cell>\n<code language=julia-1.4>\nfactorize(8)\n</cell>\n<code\
    \ language=julia-1.4>\nfactorize(25)\n</cell>\n<code language=julia-1.4>\nfactorize(70)\n\
    </cell>\n<text>\nSieve of Eratosthenes\nSieve of Eratosthenes is simple and effective\
    \ way to find prime numbers (all numbers except 1 and 2, which are trivial to\
    \ find).\nIt also have O(\u221An) complexity, which is great because most of our\
    \ numbers will be quite large and thus factorization will become too time consuming.\n\
    Here we implement this Sieve of Eratosthenes algorithm.\nThis algorithm is also\
    \ known as Sieve of Atkin algorithm (it's also known as Atkin Sieve).\nWe will\
    \ need to keep track of the numbers we have already factorized (to avoid factorizing\
    \ them again and again).\nThe basic idea is that we consider all even numbers,\
    \ that are not divisible by any prime numbers (since 2 is a prime number). \n\
    So we simply divide them by all prime numbers less than or equal to sqrt(n).\n\
    We will use only those factors which are greater than or equal to sqrt(n).\nWe\
    \ will keep dividing them by all numbers whose greatest common divisor is greater\
    \ than or equal to sqrt(n).\nAt the end we will have all the prime numbers up\
    \ to sqrt(n).\nWe will keep storing those numbers in a vector and return it.",
  "    ans=[]\n    for d in 1:(floor(log(n,2))+1)\n        if n%d == 0 \n        \
    \    ans << d\n            ans *= n // d\n        end\n    end\n    return ans\n\
    end\n</cell>\n<code language=julia-1.5>\nfactorize(8)\n</cell>\n<code language=julia-1.5>\n\
    factorize(25)\n</cell>\n<code language=julia-1.5>\nfactorize(70)\n</cell>\n<code\
    \ language=julia-1.5>", "    # Find a factor and remove it from original number\n\
    \    factor = 1\n    original_number = n\n    i = 2\n    while i < n\n       \
    \ if n % i == 0\n            factor = i\n            n /= i\n        else\n  \
    \          i += 1\n        end\n    end\n    \n    # Return the number of times\
    \ each factor appeared in factorization\n    factor_counts = collect(1:factor-1)\n\
    \    count_of_number = 1\n    while original_number > 1\n        if n % original_number\
    \ == 0\n            count_of_number += 1\n            n /= original_number\n \
    \       else\n            original_number /= factor\n        end\n    end\n  \
    \  \n    # Return vector of factors and number of times each appeared in factorization\n\
    \    prime_factorization = [factor_counts, count_of_number]\n    \n    return\
    \ prime_factorization\nend\n</cell>\n<code language=julia-1.5>\nfactorize(8)\n\
    </cell>\n<text>\nPart II: Finding all factors of a given number", "    primes\
    \ = Primes(n)\n    prime_vec = Vector{Int64}(undef, length(primes))\n    for (p,\
    \ i) in zip(primes, 1:length(primes))\n        if p == 1\n            prime_vec[i]\
    \ = 1\n        else\n            prime_vec[i] = 0\n        end\n    end\n    prime_vec\
    \ = vec(prime_vec)\n    return prime_vec\nend", "    vec = []\n    factors = factorize_to_set(n)\n\
    \    \n    for factor in factors\n        push!(vec,factor)\n    end\n    return\
    \ vec\nend", "    factors = @view factor(n).factors\n    vec_of_factors = Vector{Int64}()\n\
    \    for f in factors\n        if f==1 \n            vec_of_factors.push(f)\n\
    \        else\n            vec_of_factors.push(factorize(f*n))\n        end\n\
    \    end\n    return vec_of_factors\nend\n</cell>\n<code language=julia-1.6>\n\
    ## Factorization for given n", "    if n==1\n        vec(1)\n    else\n      \
    \  n = floor(n)\n        vec(n-1) * factorize(floor(n/n))\n    end\nend\n</cell>\n\
    <text>\nExamples of factorization", "    if n == 1\n        return [1]\n    else\n\
    \        divs = factorizeDiv(n)\n        return prod(divs) + divs\n    end\nend",
  "    if n==1\n        return [1]\n    else\n        factorization = prime_table(n)\n\
    \        result = factorization\n        for i = 2:n-1\n            add = 1\n\
    \            for j in factorization[i]\n                add = add*j\n        \
    \    result = [add*i for i in result]\n        end\n        result\n    end\n\
    end", "    factors = factor(n-1)\n    res = [n for i in 1:length(factors)]\n \
    \   for i in factors:\n        if res == [1]\n            res = [1]\n        else\n\
    \            res = res * i\n        end\n    end\n    return res\nend\n</cell>\n\
    <code language=julia-1.5>", "    \"\"\"\n    O(1)\n    \n    Returns\n    -------\n\
    \    factor : Vector{Int64}\n        Vector of primes factorizing the given integer\n\
    \    \n    Implementation\n    --------------\n    function factorize(n::Int64)\n\
    \        \n        if (n<=1)\n            return [1]\n        \n        factors\
    \ = factorize(n)\n        \n        for factor in factors\n            if (factor\
    \ % n != 0)\n                push!(factors, factor)\n        end\n        \n \
    \       return factors\n    end\n    \"\"\"\n    \n    n = int(n)\n    factors\
    \ = [1]\n    \n    while (n > 2)\n        \n        popped_factor = factors[end]\n\
    \        \n        if ((n % popped_factor) != 0)\n            push!(factors, popped_factor)\n\
    \        \n        n = n / popped_factor\n    end\n    \n    return factors\n\
    end", "    \"\"\"\nReturn vector of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be vectored number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ Input number should be equal to the product of all factors\n    >>> factorize(8)\n\
    \    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n   \
    \ [2, 5, 7]\n    \"\"\"", "    factors = [1]\n    for f in 2..sqrt(n) do \n  \
    \      \n        if n % f == 0\n            factors.push(f)\n            n /=\
    \ f\n        else\n            factors[end-1] += 1\n        end\n    end\n   \
    \ factors\nend", "    l = 2\n    while l < n\n        if n % l == 0\n        \
    \    push!(factorization, [l, n/l])\n            l = l * 2\n        else\n   \
    \         l = l * 2\n        end\n    end\n    return factorization\nend\n</cell>\n\
    <code language=julia-1.5>\nfactorize(8); factorize(25)\n</cell>\n<code language=julia-1.5>",
  "    if isPrime(n)\n        return [n ]\n    factors = [i for i in factorization(n)]\n\
    \    \n    sumFactors = 0\n    for i in factors\n        sumFactors += i \n  \
    \  \n    factors = factors*(sumFactors/n)\n    \n    factors = [i for i in factors\n\
    \                 if i != 1 ] \n    \n    return factors\nend\n\"\"\"\nReturns\
    \ factorization of the given integer by using the algorithm by Tom\xE1\u0161 M\xED\
    chalsk\xFD.\nInput number should be equal to the product of all factors\n\"\"\"",
  "    i = 2\n    factors = Vector{Int64}()\n    while i * i <= n\n        if n %\
    \ i == 0\n            factors *= i\n            n /= i\n        else\n       \
    \     i += 1\n        end\n    end\n    return factors\nend\n</cell>\n<code language=julia-0.6>",
  "    \n    v = zeros(Int64, 2)\n    \n    while n >= 2\n        if n % 2 == 0\n\
    \            n = n / 2\n        else\n            n = n * 3 + 1\n        end\n\
    \        push!(v,n)\n    end\n    \n    v\nend", "    \n    factors = Vector{Int64}()\n\
    \    \n    factorization = nfactors(n)\n    \n    i = length(factorization)\n\
    \    \n    while i!=0\n        \n        for j in i:-1:1\n            \n     \
    \       if factorization[j] == n\n                \n                factors+=[j]\n\
    \                \n                i = length(factorization)-1\n            \n\
    \            elseif j > length(factorization)-1\n                factors+=factorization[j-1]\n\
    \                factors.remove(j)\n            end\n        end\n    end\n  \
    \  \n    return factors\nend\n</cell>\n<code language=julia-1.5>\nfactorize(80)\n\
    </cell>\n<code language=julia-1.5>\nfactorize(100)\n</cell>\n<code language=julia-1.5>\n\
    factorize(1000)\n</cell>\n<code language=julia-1.5>\nfactorize(10000)\n</cell>\n\
    <code language=julia-1.5>\nfactorize(1000000)\n</cell>\n<code language=julia-1.5>\n\
    factorize(100)\n</cell>\n<code language=julia-1.5>\nnfactors(100) == factorize(100)\n\
    </cell>\n<code language=julia-1.5>\n# nfactors(100)\n</cell>\n<code language=julia-1.5>",
  "    if n<2 \n        throw(DomainError(Int64(\"n must be greater than 2\")))\n\
    \    end", "        \n    if n == 1\n        Vector[]\n    elseif n % 2 == 0\n\
    \        factorize(n/2)\n    else\n        push!(factorize(n/2),n)\n        \n\
    \    end\n    return factorize(n/2)\n    \nend", "    ans = Vector{Int64}(0) \n\
    \    for factor in primefactors(n)\n        push!(ans, factor)\n    end\n    return\
    \ ans\nend", "    prime_array = 1:2:n\n    prime_array = collect(prime_array)\n\
    \    factorization = prime_array\n    for p in prime_array\n        factorization\
    \ = factorization .- p\n    end\n    return factorization\nend", "    if n==2\
    \ return [2]\n    factorization = factorize(floor(n/2))\n    if factorization==[]\
    \ then return [n]\n    factorization = [n*factorization...] #multiply all factors\n\
    \    [x,y] = minimum(factorization)\n    finalFactorization = factorization[x:y]\
    \ #factor number from minimum to maximum\n    finalFactorization = sort(finalFactorization)\n\
    \    return finalFactorization\nend", "    factorized_nums = []\n    \n    for\
    \ num_to_factor in factors(n)\n        factorized_nums = [num_to_factor]\n   \
    \     for num in factors(num_to_factor)\n            if num != num_to_factor\n\
    \                factorized_nums *= num\n                break\n        end\n\
    \        factorized_nums = [x for x in factorized_nums if x != num_to_factor]\n\
    \        factorized_nums = [x for x in factorized_nums if x != 1]\n        factorized_nums\
    \ = [x for x in factorized_nums if x != 0]\n        factorized_nums = [x for x\
    \ in factorized_nums if x != 1]\n    end\n    \n    return factorized_nums\nend",
  "    if n < 2 \n        return Int64[]\n    elseif n % 2 == 0\n        return [Int64(n\
    \ / 2)]\n    else\n        factors = factorize(n / 2)\n        for f in factors\n\
    \            push!(factors, Int64(f + 1))\n        end\n        return factors\n\
    \    end\nend\n</cell>\n<text>\nLet's test it on the given test case", "    primeFactors=[]\n\
    \    for p in range(1,n-1)\n        if n%p==0\n            primeFactors=primeFactors.+(repeat(p,n%p))\n\
    \        end\n    end\n    return primeFactors\nend\n</code>\n<|/ a dscore=1 tags=integer,primes,julia\
    \ |>\n<| c |>\nThis has quadratic time complexity O(n\xB2). Please see [my answer](http://stackoverflow.com/a/43777701/4183191)\
    \ for a simple O(n) algorithm. :)\n<|/ c |>\n<| a dscore=0 |>\nAs a fast alternative\
    \ to factorize(n::Int64) you can use a precomputed vector to speed up the computation.\n\
    For example the following precomputed vector for 1000:\n<code>", "    if n <=\
    \ 0\n        return Vector{Int64}()\n    \n    primes = primefactorization(n)\n\
    \    \n    factors = Vector{Int64}()\n    \n    for prime in primes\n        factors\
    \ = append!(factors,1:length(primes)) \n    end\n    \n    factors\nend", "  \
    \  if n <= 1\n        Vector{}\n    elseif n % 2 == 0\n        Vector{n}\n   \
    \ else\n        p <- factorize(n/2) \n        for f in factorize(n-1) \n     \
    \       if f != p\n                push!(p...f)\n            else \n         \
    \       push!(p, f) \n        end\n    end\nend", "    factors = Factorization(n)\n\
    \    prime_numbers = factors[1]\n    factor = factors[2]\n    factors = []\n \
    \   for p in prime_numbers:\n        if p * factor in prime_numbers:\n       \
    \     factors = append(factors, factor)\n            factors = append(factors,\
    \ p)\n            factor = 1\n        else\n            factor = factor * p\n\
    \        end\n    end\n    return factors\nend", "    factorization = primeFactorization(n)\n\
    \    factors = []\n    product = productOfFactors(factorization)\n    push!(factors,\
    \ product)\n    for factor in factorization\n        if factor * product != n\
    \ \n            push!(factors, factor)\n            push!(factors, product)\n\
    \        end\n    end\n    return factors\nend", "    if n < 2\n        return\
    \ Vector{Int64}(2)\n    end\n    factors = factorize(n/2)\n    for a in factors\n\
    \        if n % a == 0\n            push!(factors, a)\n            return factors\n\
    \        end\n    end\n    push!(factors, n)\n    return factors\nend", "    \n\
    \    primes = prime_table(n)", "    # check for special cases\n    if n < 2\n\
    \        return [2]\n    \n    if n == 2\n        return [2, 2]\n    \n    # initialize\
    \ vector with size equal to number of factors\n    factors = zeros(Int, n)\n \
    \   \n    # find prime factors up to given number\n    for a in 2..n\n       \
    \ if n % a == 0\n            factors[a] += 1\n            n /= a\n           \
    \ if n == 1\n                break\n    \n    # reconstruct factors vector\n \
    \   for a in factors\n        if a != 1\n            factors[a-1] /= a\n     \
    \   end\n    end\n    \n    return factors\nend\n</cell>\n<text>\nExercise: Factorization\
    \ II", "    factors = factorizeHelper(n)\n    factors = [f for factor in factors\
    \ for f in factor]\n    return factors\nend", "    v = [n for k in factors(n)]\n\
    \    return v\nend\n</cell>\n<code language=julia-1.4>\nfactorize(70)\n</cell>\n\
    <text>\nFactorization of a number $x$ is a set of all the prime factors of $x$.\
    \ For example, for $x = 23$, $x$ is factored into $(3, 5)$, as it can be written\
    \ as $\\frac{23}{5} = 3$ and $\\frac{23}{5} = 5$.", "    n = n ^ 1\n    \n   \
    \ if n == 1\n        return [1]\n    end", "    primeFactor = factors(n)\n   \
    \ return Vector{Int64}(undef, length(primeFactor))\nend", "    factors = [1]\n\
    \    factors = factors .+ [x | x <- factors(n-1)]\n    factors = factors .+ [x\
    \ | x <- factors(n-2)]\n    factors\nend\n</code>\nFor example in factorize(8)\
    \ function I created vector with values 1 2 2, since 2 is repeated 3 times I added\
    \ 2 in vector three times and then I added 1 2 1 because 3 is repeated 2 times,\
    \ and then I added one 2 3 because 8 is repeated 1 time.\n<|/ a tags=biginteger,factorization,algorithm,julia,math\
    \ |>\n<| a tags=biginteger,factorization,algorithm,julia,math |>\nThe previous\
    \ answers are fine for factoring small numbers like 100. \nFor larger numbers\
    \ the following is an efficient implementation:\n<code>", "    \n    primes =\
    \ PrimeFactorization(n + 1)\n    answer = [primes[primes.length - 1]]\n    for\
    \ i in 1:primes.length\n        if n % primes[i] == 0\n            answer += [i]\n\
    \            n /= primes[i]\n        else\n            break\n        end\n  \
    \  end\n    return answer\nend\n</cell>\n<code language=julia-1.0>\n@time factorize(21);\n\
    @time factorize(21);\n@time factorize(21);\n</cell>\n<text>\nImplement the Sieve\
    \ of Eratosthenes for finding prime numbers using the Sieve of Atkin algorithm.\n\
    To implement the algorithm, we first need to implement the Sieve of Atkin.\nThe\
    \ Sieve of Atkin is an algorithm for finding all the prime numbers smaller than\
    \ n (where n can be any number except zero).\nThe algorithm is as follows:", " \
    \   if n<2\n        return [n ]\n    \n    smaller_factor = factorize(n-1)\n \
    \   if n < sum(smaller_factor)\n        return [n for f in smaller_factor if n\
    \ == f]\n    else\n        \n        largest_factor = 1\n        for i in smaller_factor\n\
    \            if i >largest_factor\n                largest_factor = i\n    end\n\
    \    \n    res = []\n    for i in smaller_factor\n        res = [i for i in res\
    \ if i % largest_factor != i]\n        res = [i for i in res if i < largest_factor]\n\
    \        res = [i for i in res if i > 1]\n    end\n    \n    return res\nend #\
    \ function factorize", "    factorization = getFactorization(n)\n    factors =\
    \ []\n    for factor in factorization\n        factors.append(factorial(factor))\n\
    \    return factors", "    return factorization(n)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time factorize(21);\n@time factorize(42);\n@time factorize(311);\n@time factorize(312);\n\
    @time factorize(909);\n@time factorize(73819);\n</cell>\n<code language=julia-1.5>",
  "    factor = ones(Int, n)\n    factor[0] = primeFactors(n)[1]\n    for i = 2:n\n\
    \        factor[i] = prod(factor[i-1])\n        factor[i] = factor[i] * primeFactors(n)[i+1]\n\
    \    end\n    return factor\nend\n\"\"\"\n    factorize(n::Int64, n::Int64)::Vector{Int64}\
    \ \n    \n    \"\"\"", "    primeFactors = factorize2(n)\n    if isPrime(primeFactors)\n\
    \        return primeFactors\n    else\n        primeFactors = primeFactors |>\
    \ sort\n        primeFactors = map((x -> x + 1) |> collect, primeFactors)\n  \
    \      return primeFactors\n    end\nend", "    if n <= 1\n        return zeros(Int64,\
    \ 1)\n    else\n        @assert n > 0\n        @assert n % 2 == 0\n        factors\
    \ = Vector{Int64}()\n        div = 2\n        while div <= n / 2\n           \
    \ if n % div == 0 && div * div <= n\n                factors[div] += 1\n     \
    \           n /= div\n            elseif n % div == 0 && div * div > n\n     \
    \           factors[div] += 1\n            else\n                div += 1\n  \
    \          end\n        end\n        factors[div] += 1\n        return factors\n\
    \    end\nend\n</cell>\n<code language=julia-1.3>\nfactorize(25)\n</cell>\n<code\
    \ language=julia-1.3>\n\"\"\"\nfactorize(n)", "    if n==1 return Vector{Int64}(n)\n\
    \    factors=factor(n)\n    \n    factors_sorted=sort(factors)\n    \n    prime_factors=factors_sorted\n\
    \    \n    prime_factors_sorted=sort(prime_factors)\n    \n    factorized=Vector{Int64}(n)\n\
    \    \n    len=length(prime_factors_sorted)\n    \n    factorized[1]=1\n    \n\
    \    for i=2:len\n        factorized[i]=prime_factors_sorted[i]*factorized[i-1]\n\
    \    end\n    \n    return factorized\nend\n</cell>\n<code language=julia-1.0>\n\
    factorize(8)\n</cell>\n<code language=julia-1.0>", "    factors = Vector{Int64}()\n\
    \    for f in prime_factors(n) \n        if n mod f == 0 \n            push!(factors,\
    \ f)\n            n /= f\n        end\n    end\n    return factors\nend", "  \
    \  result = Array{Int64}(length(primes))\n    for p in primes\n        if n %\
    \ p == 0\n            result[primes.index(p)] += 1\n            n /= p\n     \
    \   end\n    end\n    return result\nend", "    factorization = factorization(n.n)\
    \ \n    return map(x->n*x, factorization) \nend ", "    factors = 2\n    for i\
    \ in 1:sqrt(n)\n        factors = i * factors\n        if n%factors == 0\n   \
    \         break\n        end\n    end\n    return factors\nend", "  fs::Vector{Int64}\
    \ = sort(collect(factors(n)))\n  if fs == [1]\n    return [1]\n  end\n  p = product(fs)\n\
    \  fs = filter(x->ismultiple(n,x,fs), fs)\n  c::Vector{Int64} = [1]\n  for i in\
    \ fs\n    push!(c,i)\n  end\n  return c[(p+1):end]\nend", "    if n == 1 \n  \
    \      vectored = [1]\n        return vectored \n    else \n        factors =\
    \ factorization(n)\n        vectored = zeros(Int, length(factors))\n        for\
    \ (i, factor) in enumerate(factors)\n            vectored[factor] += 1\n     \
    \   end\n        return vectored\nend\n</cell>\n<code language=julia-1.5>\n@time\
    \ factorize(100)\n</cell>\n<text>\nFinding perfect numbers", "    \"\"\"\n   \
    \ Calculate vector of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be vectored number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n \
    \   >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\
    \"\"", "    div = 1:n\n    div = div[div .!= 0]\n    \n    factor = Vector{Int64}()\n\
    \    \n    while div.length > 0\n        p = div.pop\n        factor = [p] .+\
    \ factor\n        for i in div\n            if factor[div .!= i] == p\n      \
    \          push!(div, i)\n            end\n        end\n    end\n    \n    return\
    \ factor\nend", "    if n < 2\n        return Int64[]\n    end\n    factors =\
    \ factor(n) \n    if length( factors) == 0\n        return [n ]\n    end\n   \
    \ primeFactors = factorizeHelper(factors)\n    return primeFactors\nend\n</cell>\n\
    <text>\nThe function factorizeHelper will be the most interesting one as it contains\
    \ all necessary logic to do factorization.\nWe have several main goals:", "  \
    \  \n    if n == 1\n        return [Int64(1)]\n    \n    factors = factorize(n-1)\n\
    \    res = [Int64(1)]\n    \n    for factor in factors\n        res = [Int64(factor)\
    \ * res | res]\n    end\n    \n    return res\nend", "    return Vector{Int64}(repeat(n,n))\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a tags=recursion,primes,julia,math |>\nI think\
    \ I got it to work, here's the code\n<code>", "    if n <= 0\n        return zeros(1,\
    \ Int64)\n    end\n    factors = factor(n)\n    count = 0\n    push!(factors,\
    \ 1)\n    for i in factors\n        count += i\n        push!(factors, count)\n\
    \    end\n    factors\nend", "    if n < 2 return []\n    factorization = primes(Int(sqrt(n)))\n\
    \    factor_counts = Dict{Int64, Int}()\n    for factor in factorization\n   \
    \     factor_counts[factor] = get(factor_counts, factor, 0) + 1\n    prime_factorization\
    \ = factor_counts.keys\n    \n    return sort(prime_factorization)\nend", "  \
    \  factors = [i | i <- nfactors(n), n > i]\n    [factors.(i) for i in 1:length(factors)]\n\
    end", "        factors = []\n        for i in factorization(n)\n            if\
    \ i != 0\n                append!(factors, i)\n            end\n        end\n\
    \        return factors\nend", "    if n == 1\n        vec = []\n    elseif n\
    \ == 2\n        vec = [2]\n    elseif isPrime(n) && isPrime(n/2)\n        vec\
    \ = factorize(n/2)\n        push!(vec, 2)\n    end\n    return vec\nend", "  \
    \  factors = [1]\n    function factorize(n::Int64)\n        if n == 0\n      \
    \      return factors\n        q = div(n,2)\n        if q == 1\n            factors\
    \ = [q]\n        elseif q == 2\n            factors = [2,q]\n        else\n  \
    \          append!(factors, factorize(q)...)\n        end\n        return factorize(n/2)\n\
    \    end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nYou don't need recursive calls.\
    \ `append!` can be used with tuples or vectors (`append!([1,2], [2])`). `append!`\
    \ also does nothing if the vector already contains the element.\n<|/ c |>\n<|\
    \ c |>\nOh, you're right. I don't know how I missed that. Thanks for pointing\
    \ it out.\n<|/ c |>\n<| a tags=primes,algorithm,factors,julia,recursion |>\nHere\
    \ is another answer, which does not use recursion.  It also avoids generating\
    \ and storing multiple copies of the same number.\n<code>", "    if n<2\n    \
    \    return Vector[]\n    factors = factorize(n/2)\n    i = 2\n    for factor\
    \ in factors\n        push!(factors, factor)\n    end\n    while i <= sqrt(n)\n\
    \        if n % i == 0\n            push!(factors, i)\n        end\n        i\
    \ += 1\n    end\n    factors\nend", "    div::Vector{Int64} = 1:div(n)\n    divs\
    \ = div[:]\n    for i in divs\n        if n % i == 0\n            if div[i] <\
    \ divs[end(i)]\n                divs[end(i)] += div[i]\n            else\n   \
    \             divs[end(i)] = div[i]\n            end\n        end\n    end\n \
    \   divs\nend", "    if n == 1\n        return [Int64(1), ]\n    elseif n % 2\
    \ == 0 || n < 2\n        return [Int64(2), ]\n    elseif n % 3 == 0 || n < 3\n\
    \        return [Int64(3), ]\n    else\n        rest = factorize(n/2) \n     \
    \   factors = (1..Int(log(rest.last,2))).collect {factor -> \n            if rest\
    \ == factorize(factor)\n                factor\n            else \n          \
    \      factor * factorize(factor)\n            }\n        return factors\n   \
    \ end\nend\n</cell>\n<text>\nMain function of our program\nWe are going to use\
    \ the factorial function from above and calculate the factorial of any number.\n\
    We will see that our function works with different types of numbers, including\
    \ complex numbers, decimal, matrices, fractions, and even fractions with decimal\
    \ fractions such as 2/3.", "    factors = prime_factorize(n)\n    n = n\n    i\
    \ = 1\n    for factor in factors\n        n *= factor\n        i += 1\n    end\n\
    \    return collect(1 : n-1)\nend\n</code>\n<|/ a tags=factors,algorithm,primes,julia\
    \ dscore=2 |>\n<| a |>\n<code>", "    \n    factors = []\n    factor = 1\n   \
    \ \n    for p in primefactors(n)\n        if p != 1\n            factor /= p\n\
    \            factor *= factor\n            factors.push(factor)\n        end\n\
    \    end\n    return factors\nend", "    factorization = [1]\n    primes = primeFactorization(n)\n\
    \    for p in primes\n        factorization *= p\n    end\n    return factorization\n\
    end", "    \n    factors=[]\n    for f in factorize(BigInt(n))\n        push!(factors,f)\n\
    \    end\n    return factors\nend\n\"\"\"\n    factorize(n::BigInt)::Vector{Int64}",
  "    \n    # base case: factor is 1, return 1\n    if n == 1\n        vec = [n]\n\
    \        return vec\n    \n    # find all factors of n, starting from 1\n    \n\
    \    # this loop finds factors of n and stores in fac[]\n    fac = [1]\n    for\
    \ i in 1:(n-1)\n        if n % i == 0\n            push!(fac, i)\n           \
    \ n = n / i\n        end\n    end\n    \n    # this loop factorizes all factors\
    \ \n    # and stores in factors[]\n    factors = Array{Int64}(undef, length(fac))\n\
    \    for i = 1:length(fac)\n        if fac[i] > 1\n            factors[i] = fac[i]\n\
    \            factorize(n * fac[i])\n        end\n    end\n    \n    # this loop\
    \ adds n to each factor of factors[]\n    \n    for i = 1:length(factors)\n  \
    \      if !isnothing(factors[i])\n            push!(factors, n + factors[i])\n\
    \        end\n    end\n    \n    return factors\nend", "    \n    if n==2 return\
    \ [n]\n    \n    p=n\n    f=1\n    s=1\n    while p!=1 && f<=p\n        \n   \
    \     while p%f==0 && f<=p\n            s=s+f\n            f=f+1\n        end\n\
    \        p=p/f\n        \n        if p>1\n            \n            push!(factorize(p),\
    \ p)\n            f=f+1\n        end\n    end\n    return [1]\nend", "    if isPrime(n)\n\
    \        return n::Int64\n    \n        \n        \n        \n        \n     \
    \   \n        \n        \n        \n        \n        \n        \n        \n \
    \       \n        \n        \n        \n        \n        \n        \n       \
    \ \n        \n        \n        \n        \n        \n        \n        \n   \
    \     \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n", "  \
    \  if n==1\n        Vector[1]\n    elseif n mod 2==0\n        factorize(n/2)\n\
    \    else\n        factorize(n/2)*[(n/2)]\n    end\nend\n</cell>\n<text>\nWe know\
    \ that if all factors of the given number are odd, its product is also odd. For\
    \ example, if $8$ has all its factors $3$ and $5$, then the product is $8$, and\
    \ hence $8$ has all its factors $3$ and $5$. On the other hand, if it has all\
    \ its factors $3$ and $5$, but one of them is even, then the product is $15$,\
    \ and hence $15$ has all its factors $3$ and $5$, and one of them is even.", " \
    \   div = 1\n    sqr = 1\n    factors = []\n    while sqr < n\n        if n %\
    \ div == 0\n            factors.push(div)\n            div *= div\n        else\n\
    \            sqr += div\n            div *= sqr\n        end\n    end\n    factors.push(sqr)\n\
    \    return factors\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\nReturn vector\
    \ of factors of given integer in the order from smallest to largest.\nEach of\
    \ the factors should be vectored number of times corresponding to how many times\
    \ it appeares in factorization.\nInput number should be equal to the product of\
    \ all factors\n\"\"\"", "    primes = []\n    i = 0\n    while i < n \n      \
    \  candidates = prime_candidates(n)\n        prime_candidates_length = length(candidates)\n\
    \        if prime_candidates_length == 0 \n            prime_candidates_length\
    \ = 1\n        end", "    factors = primeFactors(n)\n    factors = filter(x->x==1,\
    \ factors)\n    return map(x -> factors[x], 1:length(factors))\nend", "    if\
    \ n <= 0\n        error(\"Invalid input. factorize() should recieve positive number\"\
    )\n    end\n    factorization = [n]\n    for factor in primes\n        if factor\
    \ * factorization[-1] < n\n            factorization[factor] = n + factorization[factor]\n\
    \        else\n            factorization[factor] += factorization[factor-1]\n\
    \        end\n    end\n    return factorization\nend\n</cell>\n<code language=julia-1.3>",
  "    \"\"\"\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5,\
    \ 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"", "    if n < 2\n     \
    \   return Int64[]\n    else\n        factors = factorize(n/2)\n        l = length(factors)\n\
    \        Vector{Int64}(repeat(factors, l))\n    end\nend", "    factors = Vector{Int64}()\n\
    \    factor = 1\n    while n > 1\n        if n % factor\n            n /= factor\n\
    \        else\n            factor += 1\n        end\n        push!(factors, factor)\n\
    \    end\n    return factors\nend", "    if n == 1 return Vector{Int64}(1)\n \
    \   ret = factorize(n/2)\n    for i in eachindex(ret)\n        ret[i] *= 2\n \
    \   end\n    return ret\nend", "    factors= factorize(n-1) #find all factors\
    \ of n\n    factors = factors .- 1 #remove 1 from factors \n    factors = factors\
    \ .* factors #multiply each factor to its number of appearences \n    factors\
    \ = collect(1:length(factors)) \n    for f in factors \n        push!(factors,f)\n\
    \    end\n    factors\nend ", "    n = round(n,digits=digits)\n    if n==1\n \
    \       return [1]\n    v = factors(n)\n    l = length(v)\n    vecflag = vecflag\
    \ + 1\n    vecflag = vecflag % 2 == 0 ? vecflag + 1 : vecflag\n    factors_tovec\
    \ = [[] for i=1:l]\n    for i = 1:l\n        factors_tovec[sort(v)[i]] = i\n \
    \   end\n    \n    for i=1:l\n        factors_tovec[i] = [1 for j in 1:factors_tovec[i]]\n\
    \    end", "    if n == 1\n        return [1]\n    \n    factors = factorize(n)\n\
    \    \n    if sum(factors) > n\n        push!(factors, n)\n    end\n    \n   \
    \ return factors\nend\n</cell>\n<code language=julia-1.5>", "    factors = Vector{Int64}()\n\
    \    flag = 1\n    for f in factorization(n)\n        if f != 0\n            flag\
    \ += 1\n        else\n            factors[end+flag] = f\n        end\n    end\n\
    \    return factors\nend\n\"\"\"\n    factorization(n::Int64)::Vector{Int64}",
  "    if n<2 return []\n    primes = factors(n)\n    \n    factor_count = zeros(Int,\
    \ length(primes))\n    for i=1:length(primes)\n        factor_count[i] = 0\n \
    \   end", "    factorized_list = []\n    factorized_list = [0 for i in 1:n]\n\
    \    \n    for x in factorized_list\n        count = 0\n        \n        if n\
    \ % x == 0\n            count += 1\n            \n            while n % x == 0\n\
    \                n /= x\n                count += 1\n            \n          \
    \  factorized_list[count] += 1\n            \n        end\n    end\n    \n   \
    \ vectored_factorization = Vector{Int64}(factorized_list)\n    \n    vectored_factorization\n\
    end\n</code>\n<|/ a tags=big-o,julia,algorithm |>\n<| c |>\nIt should be noted\
    \ that this answer only gives factors in the order they appear in the factorization,\
    \ and does not give any information on \"what fractional multiples appear in factorization\"\
    .\n<|/ c |>\n<| c |>\n: I guess your solution is just fine, except that `factorized_list`\
    \ can be replaced by `factorization` directly (which should be `Vector{Int}`,\
    \ not `Vector{Int64}`).\n<|/ c |>\n<| c |>\n: Ah, yes, you're right about `factorized_list`;\
    \ I was using my own code. I fixed the answer by changing `factorized_list` to\
    \ `factorization`.\n<|/ c |>\n<| a dscore=2 |>\nI find this to be the simplest\
    \ solution in Julia\n<code>\nfactorize(70)\n</code>\n<|/ a tags=big-o,julia,algorithm\
    \ |>\n<| a |>\nUsing list comprehension:\n<code>", "    # create factorization\n\
    \    primes = primeFactors(n)\n    factorization = Vector{Int64}(undef, 0)\n \
    \   for prime in primes\n        if n mod prime == 0\n            factorization[factorization[prime]]\
    \ = factorization[prime] + 1\n            factorization[prime] = 1\n        end\n\
    \    end\n    factorization\nend\n</cell>\n<text>\nWrite a function factorize\
    \ that will return a vector of prime factors of a given number", "    if n==1\n\
    \        return [1]\n    else\n        if isPrime(n)\n            return [2,n]\n\
    \        else\n            n = div(n,2)\n            fac =[1, 1]\n           \
    \ while n != 1\n                fac = fac*(n/2)\n                n = div(n,2)\n\
    \            end\n            return fac\n        end\n    end\nend\n    \n\"\"\
    \"\n    Solve the nth fibonacci number with memoization\n    \n    Input : n,\
    \ a positive integer\n    Returns the nth fibonacci number\n    \n    >>> fib(1)\n\
    \    1\n    >>> fib(2)\n    1\n    >>> fib(10)\n    55\n    \"\"\"", "    # initialize\
    \ vectors\n    factors = Vector{Int64}()\n    factor = 1\n    # check if n is\
    \ odd\n    if n & 1 == 1\n        push!(factors, 1)\n        return factors\n\
    \    \n    # find factors\n    for factor in factorization(Int(n))\n        push!(factors,\
    \ factor)\n    end\n    return factors\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\n    findFactors(n)\n    \n    Find factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be vectored number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ Input number should be equal to the product of all factors\n    \"\"\"", " \
    \   factorization = Array{Int64}(undef, length(primes))\n    factorization[1]\
    \ = primes[1]\n    for p in 2:length(primes)\n        if primes[p] <= n\n    \
    \        factorization[p] = primes[p]\n        elseif n % primes[p] == 0\n   \
    \         factorization[p] = primes[p]\n        else\n            factorization[p]\
    \ = ceil(n / primes[p])\n        end\n    end\n    return factorization\nend\n\
    </cell>\n<text>\nExercise 4: Write a function that can generate all prime factors\
    \ of a given integer", "    # initialize empty vector to store factors\n    factors\
    \ = Vector{Int64}()\n    # start dividing n by all prime factors\n    prime_factorization\
    \ = primeFactors(n)\n    for factor in prime_factorization\n        # check if\
    \ factor was already in factorization, if yes then just append it \n        if\
    \ factor in factors\n            push!(factors, factor)\n        else\n      \
    \      # if factor was not found in factorization then push it into factorization\n\
    \            push!(factors, factor)\n            # now start dividing n by factor\n\
    \            n %= factor\n            # repeat till condition is met\n       \
    \ end\n    end\n    # return factorization\n    return factors\nend\n</code>\n\
    <|/ a tags=sieve-of-eratosthenes,primes,factors,julia |>\n<| c |>\nThank you!\
    \ This works perfectly. Although I only need it for sieve of eratosthenes, I see\
    \ that there are several other ways to solve this problem.\n<|/ c |>\n<| c |>\n\
    This code is really slow. Could you please tell me why it takes so long? I thought\
    \ it was O(n^2) complexity but when I tried it on very large numbers, it got very\
    \ slow.\n<|/ c |>\n<| c |>\nYou can't avoid having to loop through each `n` to\
    \ see if it's in factorization. So this solution will take O(n^2) time for most\
    \ cases. You can, however, keep track of prime factors already found so as to\
    \ save some time.\n<|/ c |>\n<| c |>\nOk, thank you. Do you know a way to keep\
    \ track of prime factors already found so as to avoid a loop?\n<|/ c |>\n<| a\
    \ dscore=4 |>\nI like Chris Rackauckas' solution, but wanted to offer a solution\
    \ using the Sieve of Eratosthenes as well. I think the following will be quite\
    \ a bit faster in practice:\n<code>", "    factors = [1]\n    if n==1\n      \
    \  factors\n    elseif n==2\n        [1,1]\n    else\n        for f in factorize(floor(Int,\
    \ n/2))\n            if n % f == 0\n                push!(factors, f)\n      \
    \      elseif f > 1\n                factors = factors * f\n            end\n\
    \        end\n    end\nend\n</cell>\n<code language=julia-1.5>\n# Solve the problem\
    \ using Dynamic Programming", "    factors = factorization(n)\n    product = prod(factors)\n\
    \    factors = factors.reverse()\n    factors = sort(factors)\n    primes = [x\
    \ for x, count in factors ]\n    factors = sort(factors)\n    return factors\n\
    end", "    factorization = Factorization(n) \n    factorizations = factorizeAll(factorization)\
    \ \n    factorizations = removeDuplicates(factorizations) \n    factorizations\
    \ = [i for i in factorizations if i != n] \n    return factorizations\nend\n</cell>\n\
    <cell>", "    primes = primes(n)\n    factorized = Vec{Int64}()\n    for p in\
    \ primes\n        if n % p == 0\n            factorized *= p\n            n /=\
    \ p\n            factorized += factorized[n]\n        end\n    end\n    return\
    \ factorized\nend\n</cell>\n<code language=julia-1.5>", "    if n==1\n       \
    \ return [1]\n    \n    if n==2\n        return [1,2]\n    \n    \n    if n%3==0\n\
    \        return [1,3]\n    \n    if n%5==0\n        return [1,3,5]\n    \n   \
    \ if n%7==0\n        return [1,3,5,7]\n    \n    \n    \n    # here we get our\
    \ number's factors\n    factors=[]\n    factor=2\n    while factor<=n\n      \
    \  if n%factor==0\n            push!(factors,factor)\n            n//=factor\n\
    \        else\n            factor+=1\n        end\n    end\n    \n    return factors\n\
    end", "    facts::Vector{Int64}=[]\n    \n    # Initialize list with all factors\n\
    \    facts=factors(n)\n    \n    # Initialize list with factor numbers\n    fac_num::Int64=0\n\
    \    \n    # Loop through list of factors and check each of the factors for multiplicity\
    \ \n    for fac in facts\n        if n%fac==0\n            push!(facts, fac)\n\
    \            push!(fac_num, 1)\n        else\n            fac_num[fac_num.==1]=fac_num[fac_num.==1]+fac_num[fac_num.==fac]\n\
    \        end\n    end\n    return facts\nend\n</cell>\n<text>\nExercise 3: Infinite\
    \ factorial\nLet us consider the factorial function that we have created before\
    \ for finding the factors of a number. Let us now try to use this function to\
    \ find the factorial of number $10$ and see how it works. Let us try to print\
    \ factorial of $10$ on the screen but we do not want to actually calculate the\
    \ factorial of $10$, we want it to print a message and exit the program.", " \
    \   \n    if isPrime(n)\n        return [n]\n    end\n    factors = factorizeVector(n)\n\
    \    \n    count = 0\n    factors = sort(factors)\n    factors = setdiff(factors,\
    \ 1)\n    \n    for f in factors\n        push!(factors, f)\n        count +=\
    \ 1\n    end\n    \n    return fill(count,length(factors))\nend\n    ", "    result\
    \ = Vector{Int64}()\n    for factor in factorization(n)\n        push!(result,\
    \ factor)\n    end\n    return result\nend", "  if n==1 \n    vec[]=n\n  else\n\
    \    factors=factorize(n-1)\n    for f in factors \n      vec[]=f\n    end\n \
    \ end\n  return vec\nend\n</cell>\n<code language=julia-1.6>\nfactorize(14)\n\
    </cell>\n<code language=julia-1.6>", "    \n    factors = Set()\n    \n    for\
    \ factor in factorization(n)\n        if factor in factors\n            factors.remove(factor)\n\
    \        else\n            factors.add(factor)\n    end\n    \n    return factors\n\
    end\n</cell>\n<code language=julia-1.5>\n@time factorize(10)\n</cell>\n<text>\n\
    Prime factors of $3$ are $3$, $5$, $7$ and $11$:", "    return factorize(n, 1:prod(factorization(n)))\
    \ \nend", "    factors = zeros(Int, n+1)\n    for i = 2 to Int(sqrt(n))\n    \
    \    while n % i == 0\n            factors[i] += 1\n            n /= i\n    end\n\
    \    factors\nend\n</cell>\n<code language=julia-1.0>", "    # Check if given\
    \ number is prime or composite\n    if n % 2 == 1\n        # Even number is not\
    \ prime\n        prime = Vector{Int64}()\n        composite = Vector{Int64}()\n\
    \        return prime ++ composite\n    else\n        # Find prime factors of\
    \ n\n        factors = factor(n) \n        # Check if n is prime by comparing\
    \ factors with all factors of n.\n        # If all factors are equal, then n is\
    \ prime\n        if all(isPrime(factor) for factor in factors)\n            #\
    \ Sort factors from smallest to largest.\n            sorted = sort(factors)\n\
    \            # Multiply sorted factors by their occurances to get unique factors.\n\
    \            factors = sorted .* collect(1:length(sorted))\n            return\
    \ factors\n        else\n            # All factors are not prime so they must\
    \ be composite.\n            # Since all factors are not prime we can simply add\
    \ them to the composite vector.\n            return factors\n        end\n   \
    \ end\nend\n\"\"\"\n    factorize2(n::Int64)::Vector{Int64} \n    # Check if given\
    \ number is prime or composite\n    if n % 2 == 1\n        # Even number is not\
    \ prime\n        prime = Vector{Int64}()\n        composite = Vector{Int64}()\n\
    \        return prime ++ composite\n    else\n        # Find prime factors of\
    \ n\n        factors = factor(n) \n        # Check if n is prime by comparing\
    \ factors with all factors of n.\n        # If all factors are equal, then n is\
    \ prime\n        if all(isPrime(factor) for factor in factors)\n            #\
    \ Sort factors from smallest to largest.\n            sorted = sort(factors)\n\
    \            # Multiply sorted factors by their occurances to get unique factors.\n\
    \            factors = sorted .* collect(1:length(sorted))\n            return\
    \ factors\n        else\n            # All factors are not prime so they must\
    \ be composite.\n            # Since all factors are not prime we can simply add\
    \ them to the composite vector.\n            return factors\n        end\n   \
    \ end\nend\n\"\"\"\n    factorize2(n::Int64)::Vector{Int64} \n    # Check if given\
    \ number is prime or composite\n    if n % 2 == 1\n        # Even number is not\
    \ prime\n        prime = Vector{Int64}()\n        composite = Vector{Int64}()\n\
    \        return prime ++ composite\n    else\n        # Find prime factors of\
    \ n\n        factors = factor(n) \n        # Check if n is prime by comparing\
    \ factors with all factors of n.\n        # If all factors are equal, then n is\
    \ prime\n        if all(isPrime(factor) for factor in factors)\n            #\
    \ Sort factors from smallest ", "    factors = [1]\n    \n    for i in 2:n\n \
    \       if n % i == 0 \n            push!(factors, i)\n            n//=i\n   \
    \     else\n            push!(factors, 0)\n        end\n    end\n    \n    \n\
    \    return factors\nend", "    factors = factorize(n)\n    factors = Vector{Int64}[factors[i]\
    \ for i in factors]\n    \n    if length(factors) == 0 \n        return [1]\n\
    \    elseif length(factors) == 1 \n        return factors\n    else\n        return\
    \ sum(factors)\n    end\nend \n</code>\n<|/ a dscore=2 tags=primes,julia,factorization\
    \ |>\n<| a |>\nJust use factors function from the Factors package (https://github.com/franke/Factors.jl),\
    \ like that:\n<code>\nusing Factors", "    primes = primeFactors(n)\n    factors\
    \ = zeros(length(primes))\n    for p in primes\n        factors[p] = factors[p]\
    \ + 1\n    end\n    return factors\nend\n</cell>\n<code language=julia-0.5>\n\
    factorize(35)\n</cell>\n<code language=julia-0.5>", "    factorization = [2 for\
    \ i in 2..n]\n    for factor in factorization\n        if n%factor == 0\n    \
    \        factorization += [factor]\n            n//= factor\n        end\n   \
    \ end\n    return factorization\nend\n</code>\nThe factorization is calculated\
    \ using nested loops. As you can see in code above, each of the loop iteration\
    \ iterates through the factors of the given number. Each factor is iterated through\
    \ until all factors of the given number are taken into account. After every iteration,\
    \ I check if the current number has all its factors taken into account, if not,\
    \ I skip the next iteration. \nThe function above is called inside another function\
    \ factorize_all_factors(n::Int64)::Vector{Int64}. This function returns the factorization\
    \ of a number given as a parameter. \n<code>", "    if isPrime(n) and n % 2 ==\
    \ 0  && n > 2\n        factors = factorization(n)\n        for factor in factors\n\
    \            push!(factors, factor)\n        end\n    else\n        factors =\
    \ []\n    end\n    return factors\nend\n</cell>\n<code language=julia-0.6>", " \
    \   factors = factor(n)\n    product = 1\n    for f in factors\n        product\
    \ *= f\n    end\n    return collect(0:length(factors) - 1).map(i -> ((factors[i])*product))\n\
    end\n</cell>\n<code language=julia-1.0>", "    if n==1 || n==0\n        factors=[n]\n\
    \    else\n        factors=factorize(ceil(n/2))\n        for j in 1:length(factors)\n\
    \            factors[j]*=(factors[j-1]+n%factors[j])\n        end\n    end\n \
    \   return factors\nend\n</cell>\n<code language=julia-1.4>\nfactorize(25) # check\
    \ it work\n</cell>\n<text>\nProblem 7: Finding the multiplicative inverses of\
    \ a large collection of integers\nThe idea of the multiplicative inverse is to\
    \ find the number $x$ such that\n$$ x^A = B^C $$\nwhere $A$ and $B$ are known,\
    \ and $C$ is unknown.", "    factors = factors(n)\n    factor_count = Dict{Int64,\
    \ Int64}()\n    for factor in factors\n        if factor in factor_count\n   \
    \         factor_count[factor] += 1\n        else\n            factor_count[factor]\
    \ = 1\n        end\n    end\n    \n    factor_vec = [Int64[] for _ in 1:max(factor_count.values())]\n\
    \    \n    for factor in factors\n        if factor in factor_count\n        \
    \    index = factor_count[factor]\n            factor_vec[index] = factor_vec[index]\
    \ + 1\n        else\n            factor_vec[factor_count(factor)] = factor_vec[factor_count(factor)]\
    \ + 1\n        end\n    end\n    \n    return factor_vec\nend\n    ", "    vec\
    \ = [i \u2208 factorization(n)] \n    vec\nend\n\"\"\"Return vector of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be vectored number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>>\
    \ factorize(70)\n    [2, 5, 7]\n    \"\"\"", "    \n    factors = []\n    for\
    \ fin in factorization(n)\n        if fin[1] > 0\n            push!(factors, fin[1]*fin[2])\n\
    \        end\n    end\n    return factors\nend\n</code>\n<|/ a |>\n<| c |>\nHow\
    \ is this different from what was already in his question?\n<|/ c |>\n<| c |>\n\
    It is not different, but for me, the implementation is cleaner compared to mine.\
    \ \nThe main difference is, I wrote the function which generates factorization\
    \ at one place and calling it at many places in the code, while I was writing\
    \ the function with all the computations inside it. I think these two ways are\
    \ very different. Anyways, I edited my answer.\n<|/ c |>\n<| c |>\nI understand.\
    \  What I was saying is that your solution is different from what was already\
    \ given.  It doesn't use the code you posted, which is why it isn't an answer.\n\
    <|/ c |>\n<| a tags=primes,julia dscore=0 |>\nAs I wrote in comment, here is a\
    \ version that does not use any external functions.\n<code>", "    \n    if n\
    \ < 2\n        return ones(length(n), Int64)\n    end", "    if n < 2\n      \
    \  return zeros(1)\n    factors = factor(n)\n    vectored_factors = zeros(length(factors))\n\
    \    for k in factors\n        vectored_factors[k] .= k\n    end\n    return vectored_factors\n\
    end\n</cell>\n<code language=julia-1.5>", "    factorization = Vector{Int64}()\n\
    \    div = (Int, Int)\n    for factor in factors(n)\n        if factor > 1\n \
    \           div = (factor, 1)\n        else\n            push!(factorization,\
    \ factor)\n        end\n    end\n    div\nend\n</code>\n<|/ a |>\n<| a |>\nJust\
    \ for fun, I decided to implement a sieve for numbers up to 2^64. Here it is:\n\
    <code>", "    n = abs(n)\n    if n < 2 \n        throw(Exception, \"Invalid input\
    \ $n. Factorization input should be of the form of the number of the products\
    \ of all factors\")\n    end\n    \n    primes = prime_vector(n+1)\n    rev_primes\
    \ = reverse(primes)\n    \n    factors = Vector{Int64}(undef, 0)\n    \n    for\
    \ p in primes \n        if p == n\n            factors\n        end\n        \n\
    \        fac = 0\n        for j in rev_primes \n            if p % j == 0 \n \
    \               fac += 1\n                break\n            end\n        end\n\
    \        push!(factors, fac)\n    end\n    \n    factors\nend", "    factorization\
    \ = factorize(Int, n)\n    return map(x -> n*x, factorization)\nend", "    if\
    \ n%2 == 0\n        return Vector{Int64}[n]\n    \n    factors = factorize(n/2)\n\
    \    \n    for factor in factors\n        if factor == n/2\n            factors\
    \ *= factor\n        else\n            factors *= factor + 1\n    end\n    \n\
    \    return factors\nend", "    primes = []\n    for i in 2:floor(Int, log(n,2))\n\
    \        if isPrime(i)\n            primes << i\n        end\n    end\n    result\
    \ = primes[end]\n    for i in primes\n        result = result*i\n    end\n   \
    \ return result\nend\n</cell>\n<text>\nExercise 4:", "    \n    if n<0\n     \
    \   error(\"The given number is not positive\")\n    end", "    factorization\
    \ = factors(n)\n    n = prod(factorization)\n    vector = zeros(Int, length(n))\n\
    \    for i=1:length(n)\n        vector[i] = factorization[n - i - 1]\n    end\n\
    \    vector\nend\n</cell>\n<code language=julia-1.5>\n@time factorize(832983298)\n\
    </cell>\n<code language=julia-1.5>", "    if n < 2 \n        factors = [n]\n \
    \   else\n        factors = []\n        while n != 1 \n            append!(factors,\
    \ (n-1) % (2 ^ (length(factors)+2)))\n            n = n / (2 ^ (length(factors)+2))\n\
    \        end\n    end\n    return factors\nend", "    if n==1 \n        return\
    \ [1]\n    factorization = factorize(n-1)\n    factors = []\n    for f in factorization\n\
    \        if f==0 \n            factors.push(0)\n            continue\n       \
    \ factors.push(f*factorization[f])\n    end\n    return factors\nend", "    primes,\
    \ i = findprimes(n)\n    factors = i==0 ? [1] : factorize(n/primes[end-i])\n \
    \   i = length(factors)\n    factors = factors[end-i:]\n    for f in factors\n\
    \        push!(factors,1)\n    end\n    return factors\nend\n</cell>\n<code language=julia-1.5>",
  "    primes = factorization(n) \n    product = 1\n    for p in primes\n        product\
    \ *= p\n    end\n    ans = Int64[]\n    for p in primes\n        push!(ans, product/p)\n\
    \    end\n    return ans\nend", "  vec = Vector{Int64}()\n  for fac in factorization(n)\n\
    \    push!(vec, fac[1])\n  end\n  return vec\nend\n</cell>\n<text>\nQuestion 6.\
    \ Write function which returns list of prime factors of given number. Input number\
    \ should be equal to the product of all factors\n(Hint: check this link: https://rosettacode.org/wiki/Prime_factors#Julia)",
  "    prime_arr = findfactors(n)\n    factors = []\n    for i in 1:length(prime_arr)\n\
    \        factors += prime_arr[i]\n    end\n    return factors\nend\n</code>\n\
    <|/ a tags=primes,factors,julia |>\n<| a tags=primes,factors,julia dscore=1 |>\n\
    Here's my attempt, using primes.jl\n<code>", "        \n    factorization = factor(n)\n\
    \    \n    \n    return factorization", "    factors = Factorization(n)\n    vec\
    \ = Vector{Int64}()\n    for f in factors\n        push!(vec, n)\n        push!(vec,\
    \ f)\n    end\n    return vec\nend\n</code>\n<|/ a tags=performance,primes,factorization,julia\
    \ dscore=1 |>\n<| c |>\nThank you for taking the time to write a complete answer\
    \ and for the code example. It is a very informative answer, I appreciate that.\
    \ But your first suggestion is about 4 times slower than my original code on my\
    \ machine.\n<|/ c |>\n<| c |>\nYeah, I guess that's because your approach is much\
    \ slower. Your code is doing two redundant things: (1) find factorization of given\
    \ number `n`, then (2) find prime factors out of that factorization. Instead,\
    \ you can just use `factor(n)`, which does both in one step.\n<|/ c |>\n<| c |>\n\
    But that would be much slower, wouldn't it? It would be equivalent to calling\
    \ `factor(n)` for each number in the range `2^n`\n<|/ c |>\n<| c |>\nYeah, I guess\
    \ it's because `factor(n)` is much faster than your approach in some cases (though\
    \ I didn't try it out on bigger numbers than 20), I'll update my answer soon.\n\
    <|/ c |>\n<| c |>\nI updated my answer, it turns out that it doesn't really make\
    \ sense to recalculate all factorization for each number because `factor(n)` already\
    \ gives all the factors of `n` at once. Now I'm curious how to make it much faster.\n\
    <|/ c |>\n<| a |>\nThe first answer given by Yuriy Tachenko was very helpful to\
    \ me. I am adding the final code as an answer here to show you how I ended up\
    \ solving this problem in the end, in case anyone is interested in a Julia solution.\n\
    The basic idea is that we start with numbers in the set {2,3,5,7...,2^k - 1}.\
    \ We then divide those numbers by the largest number in the set. We repeat this\
    \ process for every number in the set. Eventually all the numbers left in the\
    \ set are factors of the number we want to find prime factors for.\n<code>", " \
    \   primeFactors = factorizePrimes(n)\n    factors = factorization(n)\n    factors\
    \ = factors.- primeFactors\n    factors = sort(factors)\n    return factors\n\
    end\n</cell>\n<code language=julia-0.6>", "    factors = []\n    push!(factors,\
    \ n)\n    for f in factors:\n        if f > 1\n            push!(factors, f /\
    \ f)\n            push!(factors, f % f)\n        end\n    end\n    factors\nend",
  "    factorization = factors(n)\n    prime_factors = Set(factorization)\n    factorization1\
    \ = Set(factorization)\n    for prime in prime_factors\n        factorization1\
    \ -= factorization\n        factorization1 = factorization1 ++ factorization\n\
    \    end\n    return prime_factors ++ factorization1\nend", "    factorization\
    \ = factorizeInt(n)\n    \n    return factorization\nend\n</cell>\n<cell>\n\"\"\
    \"\nReturns vector of prime factors of given integer in the order from smallest\
    \ to largest.\nInput number should be equal to the product of all factors\n\"\"\
    \"", "    # check input number\n    if n < 1 || sqrt(n) == Inf \n        return\
    \ Vector{Int64}()\n    end", "    factorization = Vector{Int64}(ceil(log2(n)))\n\
    \    if n == 1\n        return factorization\n    factorization[1] = 1\n    for\
    \ d in factorization[2:end]\n        if n % d == 0\n            factorization[d]\
    \ = factorization[d] * d\n            n /= d\n        end \n    end\n    factorization\n\
    end", "    factorizations = factors(n)\n    \n    factors = []\n    for factor\
    \ in factorizations\n        factors << factor * factorizations[factor]\n    end\n\
    \    \n    return factors\nend\n</cell>\n<code language=julia-1.5>\nfactorize(8)\
    \ == [2, 2, 2]\n</cell>\n<code language=julia-1.5>\nfactorize(25) == [5, 5]\n\
    </cell>\n<code language=julia-1.5>\nfactorize(70) == [2, 5, 7]\n</cell>\n<text>\n\
    Next we will implement primality test of number by checking if all factors of\
    \ number are prime.", "    factors = factor(n)\n    sorted_factors = sort(factors)\n\
    \    vec = [sorted_factors[n]]\n    for f in factors\n        push!(vec, f)\n\
    \    end\n    vec\nend\n</cell>\n<code language=julia-1.5>\n#export", "      \
    \  primeFactors = getPrimeFactors(n) \n        newFactors = [] \n        for factor\
    \ in primeFactors \n            if factor == 1 \n                newFactors[length(newFactors)]\
    \ = factor \n            else \n                j = 0\n                while j\
    \ < length(newFactors) \n                    if newFactors[j] == factor \n   \
    \                     j += 1\n                    else \n                    \
    \    newFactors[j] = factor \n                        j += 1\n               \
    \         newFactors[length(newFactors)] = factor \n            end\n        end\n\
    \        return newFactors\nend\n    ", "    for i in 2:floor(n/2)\n        factors\
    \ = factor(n)\n        factor in factors if i <= length(factors)\n        factors[i]\
    \ *= i\n    end\n    return factors\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    Please see my edit, and comment if there are any questions.\n<|/ c |>\n<| c |>\n\
    Thanks! I'm still confused but will try to review this later. I don't think this\
    \ counts as a \"vectorized\" solution because of the loops, right? But then again,\
    \ I could be wrong.\n<|/ c |>\n<| c |>\nVectorized solutions would be something\
    \ like `factorize(n) = sort(factorization(n))` which would be `O(nlogn)`. And\
    \ it would be much faster because of the use of SORT - O(n) operations. However,\
    \ in such vectorized solution you can't get factors themselves, only their counts,\
    \ which is another O(n) operation. So, vectorization doesn't help here.\n<|/ c\
    \ |>\n<| a tags=performance,primes,factors,julia |>\nYou could create a hash of\
    \ all the prime factors of each number and then get the counts for the hash. Here's\
    \ an example with the factors method you suggested:\n<code>", "    i = 2\n   \
    \ f = Vec{Int64}()\n    while i <= sqrt(n)\n        if n % i == 0\n          \
    \  f.push(i)\n            n /= i\n        else\n            i += 1\n         \
    \   if n == 1\n                break\n        end\n    end\n    return f\nend\n\
    </cell>\n<code language=julia-0.4>", "    vector = Vector{Int64}()\n    while\
    \ n % 2 == 0\n        n = div(n, 2)\n    end\n    while n % 2 == 1\n        n\
    \ /= 2\n    end\n    i = 1\n    while i <= sqrt(n)\n        if n % i == 0\n  \
    \          n /= i\n            push!(vector, i)\n        end\n        i += 1\n\
    \    end\n    push!(vector, 2)\n    return vector\nend\n</cell>\n<text>\n\u0410\
    . \u0413\u0435\u043D\u0435\u0440\u0430\u0446\u0438\u044F \u0442\u0435\u0441\u0442\
    \u043E\u0432\u044B\u0445 \u0434\u0430\u043D\u043D\u044B\u0445\n\u0413\u0435\u043D\
    \u0435\u0440\u0430\u0446\u0438\u044F \u0442\u0435\u0441\u0442\u043E\u0432\u044B\
    \u0445 \u0434\u0430\u043D\u043D\u044B\u0445 \u0441\u043E\u0441\u0442\u043E\u0438\
    \u0442 \u0438\u0437 \u0434\u0432\u0443\u0445 \u0447\u0430\u0441\u0442\u0435\u0439\
    : \u0441\u043E\u0437\u0434\u0430\u043D\u0438\u044F \u0438 \u043E\u0431\u0443\u0447\
    \u0435\u043D\u0438\u044F \u0430\u043B\u0433\u043E\u0440\u0438\u0442\u043C\u043E\
    \u0432 \u0438 \u0442\u0435\u0441\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\
    \u044F. \u041E\u0431\u0443\u0447\u0435\u043D\u0438\u0435 \u0430\u043B\u0433\u043E\
    \u0440\u0438\u0442\u043C\u0430 \u043F\u043E\u0434\u0441\u0447\u0438\u0442\u0430\
    \u0435\u0442\u0441\u044F \u043D\u0430 \u0432\u0445\u043E\u0434 \u0433\u0435\u043D\
    \u0435\u0440\u0430\u0446\u0438\u0438 \u043F\u0440\u043E\u0446\u0435\u0441\u0441\
    \u0430 \u043F\u043E\u0441\u0447\u0438\u0442\u0430\u0435\u0442\u0441\u044F \u0438\
    \u0437 \u0444\u0430\u0439\u043B\u0430 \u0434\u0430\u043D\u043D\u044B\u0445, \u043F\
    \u043E\u0441\u0447\u0438\u0442\u0430\u0435\u0442\u0441\u044F \u0438\u0437 \u043F\
    \u0440\u043E\u0446\u0435\u0441\u0441\u0430 \u0440\u0430\u043D\u0435\u0435 \u0441\
    \u043D\u043E\u0432\u0430 \u0432 \u0437\u0430\u0432\u0438\u0441\u0438\u043C\u043E\
    \u0441\u0442\u0438 \u043E\u0442 \u043F\u0430\u0440\u0430\u043C\u0435\u0442\u0440\
    \u043E\u0432 \u0430\u043B\u0433\u043E\u0440\u0438\u0442\u043C\u0430 \u0438 \u0442\
    \u0435\u0441\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F.\n\u0418\u0441\
    \u043F\u043E\u043B\u044C\u0437\u0443\u0435\u043C \u0444\u0443\u043D\u043A\u0446\
    \u0438\u044E \u0440\u0430\u0441\u0447\u0435\u0442\u0430 \u0447\u0438\u0441\u0435\
    \u043B. \u041F\u0440\u043E\u0433\u0440\u0430\u043C\u043C\u0430 \u0434\u043E\u043B\
    \u0436\u043D\u0430 \u0432\u044B\u043F\u043E\u043B\u043D\u044F\u0442\u044C\u0441\
    \u044F \u0434\u043E \u0442\u0435\u0441\u0442\u0438\u0440\u043E\u0432\u0430\u043D\
    \u0438\u044F, \u043D\u0430 \u043A\u043E\u0442\u043E\u0440\u043E\u0439 \u043E\u043D\
    \ \u043F\u043E\u043B\u0443\u0447\u0430\u0435\u0442 \u0432\u0445\u043E\u0434\u043D\
    \u0443\u044E \u0434\u0430\u0442\u0430\u0444\u0440\u0435\u0439\u043C \u0432 \u0434\
    \u0438\u0441\u043A\u0435.\n\u041E\u0442\u043C\u0430\u0441\u0448\u0442\u0430\u0431\
    \u0438\u0440\u0443\u0435\u043C \u0434\u0430\u043D\u043D\u044B\u0435 \u0432 \u0442\
    \u0435\u0441\u0442\u043E\u0432\u044B\u0439 \u0434\u0438\u0441\u043A, \u0438\u0441\
    \u043F\u043E\u043B\u044C\u0437\u0443\u044F \u0444\u0443\u043D\u043A\u0446\u0438\
    \u044E \u0440\u0430\u0441\u0447\u0435\u0442\u0430 \u0447\u0438\u0441\u0435\u043B\
    .", "    \n    factorization = PrimeFactorization(n)\n    primes = factorization[\"\
    primes\"]\n    factors = factorization[\"factors\"]\n    \n    \n    result =\
    \ Vector{Int64}(undef, primes.length)\n    for (i, f) in enumerate(factors)\n\
    \        if f > 1\n            result[i] = f\n        end\n    end\n    \n   \
    \ return result\nend\n</code>\nTo calculate the factor of a number we can use\
    \ Sieve of Eratosthenes algorithm, which gives us list of all numbers which will\
    \ be factors of number in O(n). Then, for each of them we can find factors and\
    \ then sum them to get the answer.\n<code>", "    if n <= 0\n        error(\"\
    n should be positive\")\n    end", "    ans=[1]\n    for i in 2:(n/2)\n      \
    \  if n%i==0\n            push!(ans,i)\n            n=n/i\n        else\n    \
    \        break\n        end\n    end\n    return ans\nend\n</cell>\n<code language=julia-0.6>\n\
    factorize(30)\n</cell>\n<text>\nHow many divisors does a number have?", "    factor\
    \ <- factorize(n)\n    factor\nend", "    divisors = Array{Int64, 1}()\n    for\
    \ i in 1:n\n        divisors = divisors .+ (n-i).fdiv(i)\n    end\n    divisors\n\
    end", "    ans = Array{Int64}(length(primes))\n    for (i, p) in enumerate(primes)\n\
    \        if n % p == 0\n            ans[i] += 1\n            n /= p\n        else\n\
    \            ans[i] -= 1\n            if n == 1\n                ans[i] = 0\n\
    \                break\n            end\n        end\n    end\n    return ans\n\
    end\n</code>\nThen just call it from the main function:\n<code>", "    if n %\
    \ 2 == 0 \n        primes = primes_list(2)\n        while n % primes[1] == 0\n\
    \            primes = primes_list(primes[1])\n        end\n        return [primes[1],\
    \ primes[1]]\n    else\n        primes = primes_list(n)\n        while n % primes[1]\
    \ == 0\n            primes = primes_list(primes[1])\n        end\n        return\
    \ [primes[1], primes[1]]\n    end\nend", "    # return Vector{Int64}(n)\n    n\
    \ %= max_num_primes\n    primeFactors = primeFactorization(n)\n    factors = Dict{Int,\
    \ Int}()\n    for (p, count) in primeFactors\n        factors[p] = count\n   \
    \ end\n    return primeFactors[end][1] == n ? collect(values(factors)) : factorize(n-factors[end])\n\
    end\n</cell>\n<code language=julia-1.5>", "    \"\"\"\n    Function that calculates\
    \ factors and returns them in correct order.\n    Input number should be equal\
    \ to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>>\
    \ factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n\
    </code>\n<|/ a dscore=0 tags=python,primes,algorithm,math,factorization |>\n<|\
    \ c |>\nThis would be a better answer if you explained how the code you provided\
    \ answers the question.\n<|/ c |>\n<| c |>\nI agree but I have tried the code\
    \ on the website and it has some errors. But I am just learning python. Hope that\
    \ helps.\n<|/ c |>\n<| c |>\nThank you very much. I have updated the answer with\
    \ the explanation.\n<|/ c |>\n<| a dscore=0 tags=python,primes,algorithm,math,factorization\
    \ |>\nI made a small function that calculates how many factors there are:\n<code>\n\
    import math", "    \n    return prime_factorization(n) .+ [prod(factorial(r) for\
    \ r in prime_factorization(n))] \nend", "    x = 1\n    factors = []\n    while\
    \ x * x <= n\n        x = x * x\n        factors.push(x)\n    end", "    \n  \
    \  primes = primefactors(n)\n    \n    factorization = Vector{Int64}(primes.length\
    \ + 1)\n    \n    for number in primes\n        \n        if number == 1\n   \
    \         factorization[1] = 1\n        else\n            \n            factorization[1]\
    \ = number\n            for ii in 2:factorization[1]\n                \n     \
    \           if number % ii == 0\n                    factorization[ii] = factorization[ii]\
    \ * number\n                end\n            end\n            \n        end\n\
    \    end\n    \n    return factorization\nend\n</cell>\n<code language=julia-1.0>\n\
    factorize(100)\n</cell>\n<code language=julia-1.0>", "    if n < 2\n        return\
    \ [1,1]\n    factors = factorize(n-1)\n    ret = Vector{Int64}()\n    for f in\
    \ factors\n        for i = 1:f\n            push!(ret,i)\n        end\n    end\n\
    \    return ret\nend", "    vec = Vector{Int64}(n)\n    for i in 1:n\n       \
    \ flag = 0\n        for j=1:i\n            if i %% j == 0\n                flag\
    \ = 1\n                break\n            end\n        end\n        if flag\n\
    \            push!(vec, i)\n        end\n    end\n    vec\nend\n</cell>\n<text>\n\
    Problem 10\nImplement Fibonacci function", "    \n    factors = factorize_prime(n);\n\
    \    factorized_number = prod(factors);\n    \n    factorized_number;\nend\n</cell>\n\
    <text>\nTask 4", "    vec = [n for i <- 1:factor(n)]\n    while isPrime(vec)\n\
    \        vec = vec .- vec[1]\n    end\n    return vec\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a |>\nAs you pointed out yourself in a comment, there is no need to rewrite\
    \ isPrime yourself. As far as I understand, the question asked for a function\
    \ which would return all prime factors of a given number. So, here is an answer\
    \ which does it:\n<code>", "    vec = []\n    for i in factors(n)\n        if\
    \ n mod i == 0\n            vec += [i] * factorial(n / i)\n        end\n    end\n\
    \    return vec\nend", "    x = 2\n    y = 0\n    while x*x <=n && y<=n \n   \
    \     if n % x == 0 \n            x += 1\n        else \n            y += 1\n\
    \    end", "    prime_factors = []\n    factors = prime_factor_factorization(n)\n\
    \    \n    for factor in factors do\n        prime_factors += factor\n    end\n\
    \    return prime_factors\nend\n</cell>\n<code language=julia-1.5>\nprime_factorize(12)\n\
    </cell>\n<code language=julia-1.5>", "    primes = factors(n)\n    prime_vects\
    \ = Vector{Int64}()\n    for p in primes\n        prime_vects = push!(prime_vects,\
    \ factorize(p))\n    end\n    return prime_vects\nend\n</cell>\n<text>\nNext,\
    \ we have to implement multiplication of two matrices. As an example, consider\
    \ matrix multiplication in which two matrices are multiplied element-wise:", " \
    \   \n    if n < 2\n        return Vector{Int64}()\n    elseif n == 0\n      \
    \  return [1]\n    else\n        factors = factorize(n/2)\n        new_factors\
    \ = factors\n        for f in factors\n            if n % f == 0\n           \
    \     push!(new_factors, f)\n            end\n        end\n        return collect(new_factors)\
    \ ++ factors\n    end\nend\n</cell>\n<code language=julia-1.5>\nfactorize(5)\n\
    </cell>\n<code language=julia-1.5>\nfactorize(8)\n</cell>\n<code language=julia-1.5>\n\
    factorize(25)\n</cell>\n<code language=julia-1.5>\nfactorize(70)\n</cell>\n<code\
    \ language=julia-1.5>", "    largest = sqrt(n)\n    factorization = Vector{Int64}()\n\
    \    for div in factorrange(n)\n        if div == largest\n            factorization\
    \ += div\n        else\n            factorization += div\n            while div\
    \ % div == 0\n                div *= div\n            factorization += div\n \
    \       end\n    end\n    factorization\nend\n</cell>\n<code language=julia-1.4>",
  "    # Input number should be equal to the product of all factors\n    if n == 0\n\
    \        Vector{Int64}()\n    else\n        factors = factor(n)\n        l = length!(factors)\n\
    \        Vector{Int64}(undef, l) \n        for f in factors\n            push!(factors,\
    \ f) \n        end\n        factors\n    end\nend\n\"\"\"\n    factorize_vec(v::Vector{Int64})\n\
    \    Returns the factorization of vector\n    \"\"\"", "    result = Set()\n \
    \   factorial = 1\n    for prime in primefactors(n)\n        factorial = factorial\
    \ * prime\n        push!(result, factorial)\n    end\n    return result\nend\n\
    </cell>\n<cell>\n@test factorize(8) == [2, 2, 2]\n@test factorize(25) == [5, 5]\n\
    @test factorize(70) == [2, 5, 7]\n</cell>\n<text>\nWhat if I want to find the\
    \ factorization of a number that has more than 100 digits in the form of 10^1000\
    \ digits. What would be the best way to get the factorization? Let's look at the\
    \ time complexity of the function factorize. According to BigOh notation, it is\
    \ $O(\\sqrt{n})$, which is very slow. Let's check the time for different values\
    \ of $n$", "    i = 2\n    factors = Vector{Int64}(length(factorization(n)))\n\
    \    while factorization(n) % i == 0\n        i += 1\n    end\n    while i <=\
    \ sqrt(n)\n        if factorization(n) mod i == 0\n            factors = append!(factors,\
    \ i)\n        end\n        i += 1\n    end\n    return factors\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
