name: HumanEval_1_separate_paren_groups
language: jl
prompt: "\"\"\" Input to this function is a string containing multiple groups of nested\
  \ parentheses. Your goal is to\n    separate those group into separate strings and\
  \ return the vector of those.\n    Separate groups are balanced (each open brace\
  \ is properly closed) and not nested within each other\n    Ignore any spaces in\
  \ the input string.\n    >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n   \
  \ [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
  (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
  ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
  , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\
  \t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
completions: ["    groups = split(paren_string, \" \")\n    groups = filter(x -> !contains(\"\
    ()\", x), groups)\n    groups = filter(x -> !contains(\"{}\", x), groups)\n  \
    \  return groups[:]\nend", "    paren_string = paren_string.replace(\" \", \"\"\
    )\n    return paren_string.split(')')\nend", "    paren_string = strip(paren_string)\n\
    \    paren_string = paren_string.split(' ')\n    paren_string = filter(s -> length(s)\
    \ >= 1, paren_string)\n    paren_string = filter(s -> s != \"\", paren_string)\n\
    \    paren_string = paren_string.map(s -> strip(s))\n    return paren_string\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThank you, I have been struggling with this for\
    \ a while.\n<|/ c |>\n<| a dscore=2 tags=functional-programming,julia,string |>\n\
    I wrote a solution that utilizes the built-in string splitting and string filtering\
    \ functions. It works on the basis of a function that splits a string into a vector\
    \ of words, and then filters the vector to remove empty strings from the array.\
    \ Then, it recursively calls a function on each of the elements in the split array.\
    \ The resulting array is then appended onto the empty array that holds the strings\
    \ that haven't been filtered.\n<code>", "    paren_string = paren_string.replace(\"\
    \ \", \"\")\n    paren_string = paren_string.replace(\"\\n\", \"\")\n    paren_string\
    \ = paren_string.replace(\"\\r\", \"\")\n    paren_string = paren_string.split(\"\
    \")\n    paren_string = paren_string.filter(x -> x != \")\")\n    paren_string\
    \ = paren_string.filter(x -> x != \"(\")\n    paren_string = paren_string.filter(x\
    \ -> x != \")\")\n    paren_string = paren_string.filter(x -> x != \"(\")\n  \
    \  paren_string = paren_string.filter(x -> x != \"((\")\n    paren_string = paren_string.filter(x\
    \ -> x != \"((\")\n    paren_string = paren_string.filter(x -> x != \")(\")\n\
    \    paren_string = paren_string.filter(x -> x != \"((\")\n    paren_string =\
    \ paren_string.filter(x -> x != \"(((\")\n    paren_string = paren_string.filter(x\
    \ -> x != \"((\")\n    paren_string = paren_string.filter(x -> x != \"()\")\n\
    \    paren_string = paren_string.filter(x -> x != \"()()\")\n    paren_string\
    \ = paren_string.filter(x -> x != \"(()\")\n    paren_string = paren_string.filter(x\
    \ -> x != \"()()\")\n    paren_string = paren_string.filter(x -> x != \"()()()\"\
    )\n    paren_string = paren_string.filter(x -> x != \"(()()\")\n    paren_string\
    \ = paren_string.filter(x -> x != \"(()()()\")\n    paren_string = paren_string.filter(x\
    \ -> x != \"((()\")\n    paren_string = paren_string.filter(x -> x != \"(()()\"\
    )\n    paren_string = paren_string.filter(x -> x != \"(()()()\")\n    paren_string\
    \ = paren_string.filter(x -> x != \"(()()()\")\n    paren_string = paren_string.filter(x\
    \ -> x != \"(()()()()\")\n    paren_string = paren_string.filter(x -> x != \"\
    ((()()\")\n    paren_string = paren_string.filter(x -> x != \"(()()()\")\n   \
    \ paren_string = paren_string.filter(x -> x != \"(()()()()\")\n    paren_string\
    \ = paren_string.filter(x -> x != \"((()()()\")\n    paren_string = paren_string.filter(x\
    \ -> x != \"(()()()()\")\n    paren_string = paren_string.filter(x -> x != \"\
    (()()()()\")\n    paren_string", "    paren_string = strip(paren_string)\n   \
    \ open_braces = findall(paren_string, r\"\\(+\")\n    closed_braces = findall(paren_string,\
    \ r\"\\)\")\n    open_braces = Set(open_braces)\n    closed_braces = Set(closed_braces)\n\
    \    closed_parens = intersect(open_braces, closed_braces)\n    open_parens =\
    \ intersect(closed_braces, open_braces)\n    \n    sub_str = findall(regex_sub(\"\
    \\(.+?\\)\", r\"\\1\", paren_string), r\"\\(\")\n    sub_str = Set(sub_str)\n\
    \    \n    return map(x -> unescape(x), \n        filter(x -> x != \"\", \n  \
    \          union(open_braces, closed_braces, open_parens, closed_parens, sub_str)))\n\
    end", "    paren_string = paren_string.strip\n    paren_string = paren_string.split(\"\
    ()\")\n    paren_string = filter((x -> !(x ==  \"\"))(paren_string))\n    return\
    \ paren_string\nend", "    #split the string into groups\n    #ignore white spaces\
    \ in group\n    paren_string = strip(paren_string)\n    group_arr = regexpi(paren_string,\
    \ '\\\\{(.*?)\\\\}')\n    group_arr = filter(x -> !isempty(x), group_arr) #remove\
    \ empty groups\n    group_arr = map(x -> unquote(x), group_arr) #remove unquote\
    \ group elements\n    group_arr = filter(x -> isa(x, String), group_arr) #filter\
    \ any empty string groups\n    group_arr = map(x -> remove_brackets(x), group_arr)\
    \ #remove brackets\n    group_arr = map(x -> remove_repeat_parens(x), group_arr)\
    \ #remove repeats\n    group_arr = map(x -> remove_repeat_whitespace(x), group_arr)\
    \ #remove repeats\n    group_arr = map(x -> remove_whitespace(x), group_arr) #remove\
    \ whitespace\n    group_arr = filter(x -> !isempty(x), group_arr) #remove empty\
    \ groups\n    return group_arr\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=0\
    \ |>\nJust in case someone is looking for an answer that works both with parentheses\
    \ and brackets, this worked for me.\n<code>", "    braces=Vector{String}(undef,0)\n\
    \    current_string=\"\"\n    open_paren_count=0\n    for c in paren_string\n\
    \        if c==\"(\"\n            open_paren_count+=1\n            current_string+=c\n\
    \        elseif c==\")\"\n            open_paren_count-=1\n            if open_paren_count==0\n\
    \                push!(braces,current_string)\n                current_string=\"\
    \"\n            else\n                current_string+=c\n            end\n   \
    \     else\n            current_string+=c\n        end\n    end\n    push!(braces,current_string)\n\
    \    return braces\nend\n</cell>\n<text>\nNow let's see what we have", "    paren_string\
    \ = paren_string.strip() # remove all spaces from parentheses\n    paren_strings\
    \ = split(paren_string, \")\") # split into groups of parentheses\n    paren_strings\
    \ = filter(elem -> elem != \"\", paren_strings) # remove empty strings\n    paren_strings\
    \ = map(string -> split(string, \"(\"), paren_strings) # split each group into\
    \ separate strings\n    paren_strings = map(string -> string.strip(), paren_strings)\
    \ # remove whitespace from each group\n    paren_strings = map(string -> string.strip(),\
    \ paren_strings) # remove whitespace from each group\n    paren_strings = filter(elem\
    \ -> elem != \"()\", paren_strings) # remove any empty strings except for groups\
    \ of parentheses\n    return paren_strings\nend\n</cell>\n<text>\nSolution", " \
    \   return paren_string.split(')')\nend\n</cell>\n<code language=julia-1.3>\n\
    separate_paren_groups(\"( ) (( )) (( )( ))\")\n</cell>\n<code language=julia-1.3>\n\
    separate_paren_groups(\"( ) ())\")\n</cell>\n<text>\nExercise: Write a function\
    \ to remove whitespace from both ends of a string\n    Example Input: \"(hello\
    \ world)\"\n    Example Output: \"helloworld\"\n    \n    Do not use replace or\
    \ strip!", "    paren_string = paren_string.split(' ')\n    paren_string = paren_string.filter(x\
    \ -> x != ')')\n    paren_string = paren_string.filter(x -> x != '(')\n    paren_string\
    \ = paren_string.filter(x -> x != '{')\n    paren_string = paren_string.filter(x\
    \ -> x != '[')\n    paren_string = paren_string.filter(x -> x != '<')\n    paren_string\
    \ = paren_string.filter(x -> x != '>')\n    paren_string = paren_string.filter(x\
    \ -> x != '!')\n    paren_string = paren_string.filter(x -> x != '?') \n    paren_string\
    \ = paren_string.filter(x -> x != '#')\n    paren_string = paren_string.filter(x\
    \ -> x != '%')\n    paren_string = paren_string.filter(x -> x != '&')\n    paren_string\
    \ = paren_string.filter(x -> x != '*')\n    paren_string = paren_string.filter(x\
    \ -> x != '|')\n    paren_string = paren_string.filter(x -> x != '^')\n    paren_string\
    \ = paren_string.filter(x -> x != '$') \n    paren_string = paren_string.filter(x\
    \ -> x != '\\\"')\n    paren_string = paren_string.filter(x -> x != '\\'')\n \
    \   paren_string = paren_string.filter(x -> x != '<=') \n    paren_string = paren_string.filter(x\
    \ -> x != '<')\n    paren_string = paren_string.filter(x -> x != '>')\n    paren_string\
    \ = paren_string.filter(x -> x != '=')\n    paren_string = paren_string.filter(x\
    \ -> x != '?')\n    paren_string = paren_string.filter(x -> x != '!')\n    paren_string\
    \ = paren_string.filter(x -> x != '|')\n    paren_string = paren_string.filter(x\
    \ -> x != '#')\n    paren_string = paren_string.filter(x -> x != '%')\n    paren_string\
    \ = paren_string.filter(x -> x != '&')\n    paren_string = paren_string.filter(x\
    \ -> x != '=')\n    paren_string = paren_string.filter(x -> x != '*')\n    paren_string\
    \ = paren_string.filter(x -> x != '$')\n    paren_string = paren_string.filter(x\
    \ -> x != '\\\"')\n    paren_string = paren_string.filter(x -> x != '\\'')\n \
    \   paren_string = paren_string.filter(x -> x != '<') \n    paren_string = paren_string.filter(x\
    \ -> x != '>')\n", "    paren_string = strip(paren_string)\n    paren_string =\
    \ replace(paren_string,\"\\\"\",\"\")\n    paren_string = replace(paren_string,\"\
    \\\\n\",\"\")\n    paren_string = replace(paren_string,\" \",\"\")\n    paren_string\
    \ = replace(paren_string,\";\",\"\")\n    paren_string = replace(paren_string,\"\
    \\n\",\"\")\n    paren_string = replace(paren_string,\"(\",\"\")\n    paren_string\
    \ = replace(paren_string,\")\",\"\")\n    paren_string = replace(paren_string,\"\
    [\",\"\")\n    paren_string = replace(paren_string,\"]\",\"\")\n    paren_string\
    \ = replace(paren_string,\"{\",\"\")\n    paren_string = replace(paren_string,\"\
    }\",\"\")\n    paren_string = replace(paren_string,\":\",\"\")\n    paren_string\
    \ = replace(paren_string,\",\",\"\")\n    paren_string = replace(paren_string,\"\
    ;\",\"\")\n    paren_string = replace(paren_string,\"=\",\"\")\n    paren_string\
    \ = replace(paren_string,\"+\",\"\")\n    paren_string = replace(paren_string,\"\
    -\",\"\")\n    paren_string = replace(paren_string,\".\",\"\")\n    paren_string\
    \ = replace(paren_string,\"/\",\"\")\n    paren_string = replace(paren_string,\"\
    )(\",\"\")\n    paren_string = replace(paren_string,\")(\",\"\")\n    paren_string\
    \ = replace(paren_string,\")(\",\"\")\n    paren_string = replace(paren_string,\"\
    )(\",\"\")\n    paren_string = replace(paren_string,\")(\",\"\")\n    paren_string\
    \ = replace(paren_string,\")(\",\"\")\n    paren_string = replace(paren_string,\"\
    )(\",\"\")\n    paren_string = replace(paren_string,\")(\",\"\")\n    paren_string\
    \ = replace(paren_string,\")(\",\"\")\n    paren_string = replace(paren_string,\"\
    )(\",\"\")\n    paren_string = replace(paren_string,\")(\",\"\")\n    paren_string\
    \ = replace(paren_string,\")(\",\"\")\n    paren_string = replace(paren_string,\"\
    )(\",\"\")\n    paren_string = replace(paren_string,\")(\",\"\")\n    paren_string\
    \ = replace(paren_string,\")(\",\"\")\n    paren_string = replace(paren_string,\"\
    )(\",\"\")\n    paren_string = replace(paren_string,\")(\",\"\")\n    paren_string\
    \ = replace(paren_string,\")(\",\"\")\n    paren_string = replace(paren_string,\"\
    )(\",\"\")\n    paren_string = replace(paren_string,\")(\",\"\")\n    paren_string\
    \ = replace(paren_string,\")(\",\"\")\n    paren_string = replace(", "    paren_string\
    \ = paren_string.strip\n    paren_groups = Vector{String}()\n    i = 0\n    while\
    \ i < length(paren_string)\n        while i < length(paren_string) && paren_string[i]\
    \ == \")\"\n            paren_groups[i] = paren_string[i + 1 : i] + paren_string[i]\n\
    \            i += 2\n        end\n        i += 1\n    end\n    return paren_groups\n\
    end\n</cell>\n<code language=julia-0.6>\nseparate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n</cell>\n<code language=julia-0.6>\nseparate_paren_groups(\"(( ))\
    \ (( ))\")\n</cell>\n<text>\nExercise 2: Write a function that parses a string\
    \ into numbers. Your function should ignore all non-numeric characters and\n \
    \   keep track of any non-numeric characters. For example, if the string is \"\
    123, 456, 789\", your function should return [123; 456; 789]\n    >>> parse_number_string(\"\
    123 456 789\")\n    [123; 456; 789]\n    >>> parse_number_string(\"123 456 789.0\
    \ abc def\")\n    [123, 456, 789.0, \"abc\"; \"def\"]\n    \"\"\"", "  paren_string\
    \ = replace(paren_string, \"\\\\{\", \"{{\")\n  paren_string = replace(paren_string,\
    \ \"\\\\}\", \"}}\")\n  paren_string = replace(paren_string, \"\\\\)\", \"}}}\"\
    )\n  paren_string = replace(paren_string, \"\\\\)\", \"}}}\")\n  paren_string\
    \ = replace(paren_string, \"\\\\)\", \"}}}\")\n  paren_string = replace(paren_string,\
    \ \"\\\\)\", \"}}}\")\n  paren_string = replace(paren_string, \"\\\\)\", \"}}}\"\
    )\n  paren_string = replace(paren_string, \"\\\\)\", \"}}}\")\n  paren_string\
    \ = replace(paren_string, \"\\\\)\", \"}}}\")\n  paren_string = replace(paren_string,\
    \ \"\\\\)\", \"}}}\")\n  paren_string = replace(paren_string, \"\\\\)\", \"}}}\"\
    )\n  paren_string = replace(paren_string, \"\\\\)\", \"}}}\")\n  paren_string\
    \ = replace(paren_string, \"\\\\)\", \"}}}\")\n  paren_string = replace(paren_string,\
    \ \"\\\\)\", \"}}}\")\n  paren_string = replace(paren_string, \"\\\\)\", \"}}}\"\
    )\n  paren_string = replace(paren_string, \"\\\\)\", \"}}}\")\n  paren_string\
    \ = replace(paren_string, \"\\\\)\", \"}}}\")\n  paren_string = replace(paren_string,\
    \ \"\\\\)\", \"}}}\")\n  paren_string = replace(paren_string, \"\\\\)\", \"}}}\"\
    )\n  paren_string = replace(paren_string, \"\\\\)\", \"}}}\")\n  paren_string\
    \ = replace(paren_string, \"\\\\)\", \"}}}\")\n  paren_string = replace(paren_string,\
    \ \"\\\\)\", \"}}}\")\n  paren_string = replace(paren_string, \"\\\\)\", \"}}}\"\
    )\n  paren_string = replace(paren_string, \"\\\\)\", \"}}}\")\n  paren_string\
    \ = replace(paren_string, \"\\\\)\", \"}}}\")\n  paren_string = replace(paren_string,\
    \ \"\\\\)\", \"}}}\")\n  paren_string = replace(paren_string, \"\\\\)\", \"}}}\"\
    )\n  paren_string = replace(paren_string, \"\\\\)\", \"}}}\")\n  paren_string\
    \ = replace(paren_string, \"\\\\)\", \"}}}\")\n  paren_string = replace(paren_string,\
    \ \"\\\\)\", \"}}}\")\n  paren_string = replace(paren_string, \"\\\\)\", \"}}}\"\
    )\n  paren_string = replace(paren_string, \"\\\\)\", \"}}}\")\n  paren_string\
    \ = replace(paren_string, \"\\\\)\", \"}}}\")\n  paren_string = replace(paren_string,\
    \ \"\\\\)\", \"}}}\")\n  paren_string = replace(paren_string, \"\\\\)\", \"}}}\"\
    )\n  paren_string = replace(paren_string, \"\\\\)\", \"}}}\")\n  paren_string\
    \ = replace(paren_string, \"", "    stack = Vector{String}()\n    \n    for char\
    \ in paren_string\n        if char == '('\n            push!(stack, char)\n  \
    \      elseif char == ')'\n            if isempty(stack)\n                push!(stack,\
    \ char)\n            elseif length(stack) == 0\n                push!(stack, char)\n\
    \            elseif pop!(stack) == ')'\n                push!(stack, char)\n \
    \           else\n                push!(stack, char)\n            end\n      \
    \  end\n    end\n    \n    return stack\nend\n</cell>\n<code language=julia-1.6>\n\
    separate_paren_groups(\"( ) (( )) (( )( ))\")\n</cell>\n<text>\nTask 3. Write\
    \ a function that prints the number of parentheses in the input string. If there\
    \ are even number of parentheses, print this string \"even\".\n    Otherwise print\
    \ this string \"odd\".", "\"\"\"\n## Solution\n```julia\nseparate_paren_groups(paren_string)\n\
    ```\n\"\"\"\nseparate_paren_groups(paren_string) = split(paren_string, \"\\(\\\
    )\")\n</cell>\n<code language=julia-1.0>", "    split_in_paren(paren_string)\n\
    end\n</code>\n<|/ a |>\n<| a dscore=2 |>\nTo do this with regex:\n<code>\nstring\
    \ = \"(foo) (bar)\"\nsplits = findall(string, \"[(](.+)[)]\")\n</code>\nThis gives\n\
    <code>\n[\"(foo)\", \"(bar)\"]\n</code>\n<|/ a tags=haskell,string,functional-programming,parsing\
    \ |>\n<| c |>\nThis is wrong: `[\"(foo)\", \"(bar)\"]` does not contain `()`s.\n\
    <|/ c |>\n<| c |>\nIt works with your example string and mine, that's what I'm\
    \ using. Where did you get the idea that it doesn't work with `(foo) (bar)`? I'm\
    \ new to Haskell, and I'm not familiar with all the Haskell libraries out there\
    \ so I'm not sure why it wouldn't work.\n<|/ c |>\n<| c |>\nI see your point now,\
    \ I got my example wrong. I think I meant `[ \"(foo)\", \"(bar)\" ] ~= [\"foo\"\
    , \"bar\"]`.  Of course that doesn't work. Sorry for the confusion.\n<|/ c |>\n\
    <| a |>\nA simple but quite versatile solution is the following:\n<code>\nstringSplit\
    \ :: String -> [String]\nstringSplit s = split (== \"(\") s\n</code>\nThe function\
    \ splits the string by looking for a pattern in the left side of the string. The\
    \ pattern consists of two consecutive parentheses. We are looking for \"(\", so\
    \ the function works if you only have parentheses in the left side of the string.\
    \ It also works if you have parentheses in the right side of the string, as long\
    \ as they are properly closed by another parenthese. \n<code>\nstringSplit = split\n\
    </code>\nBut we do not need to specify it as the default case. Thus stringSplit\
    \ can handle any string, not only parentheses.\n<code>\nstringSplit \"(foo) (bar)\"\
    \n</code>\nreturns:\n<code>\n[\"foo\",\"bar\"]\n</code>\n<|/ a tags=haskell,string,functional-programming,parsing\
    \ dscore=2 |>\n<| a |>\nI used this solution with some help from previous answers:\n\
    <code>\nimport Data.List\nimport Data.Maybe", "    paren_string = paren_string.replace(\"\
    \\n\", \"\").replace(\"  \", \" \")\n    paren_string = paren_string.split(\"\
    \ \") # Split on all white space characters\n    paren_string = paren_string.filter(x\
    \ -> x != \"\") # Remove empty strings\n    paren_string = paren_string.filter(x\
    \ -> !(x == \"(\")) # Remove all open parens\n    paren_string = paren_string.filter(x\
    \ -> !(x == \")\")) # Remove all close parens\n    paren_string = paren_string.filter(x\
    \ -> x != \"\") # Remove all empty strings\n    return paren_string\nend", " \
    \   #remove spaces\n    paren_string = replace(paren_string, \" \", \"\") \n \
    \   # remove parentheses from parenthesis string\n    paren_string = replace(paren_string,\
    \ \"(\", \"\") \n    paren_string = replace(paren_string, \")\", \"\") \n    #\
    \ remove spaces from parenthesis string\n    paren_string = replace(paren_string,\
    \ \" \", \"\") \n    # remove spaces between groups\n    paren_string = replace(paren_string,\
    \ \" \", \"\") \n    # remove parenthesis between groups\n    paren_string = replace(paren_string,\
    \ \"(\", \"\") \n    paren_string = replace(paren_string, \")\", \"\") \n    #\
    \ split string into separate groups\n    group_split = split(paren_string, \"\
    )\")\n    return group_split\nend", "    open_parens = []\n    closed_parens =\
    \ []\n    open_braces = 0\n    open_braces_count = 0\n    for c in paren_string\n\
    \        if c == \"(\"\n            open_braces += 1\n            open_braces_count\
    \ += 1\n        elseif c == \")\"\n            closed_parens.append(open_braces)\n\
    \            open_braces -= 1\n            open_braces_count -= 1\n        elseif\
    \ c == \" \"\n            continue\n        elseif open_braces == 0\n        \
    \    open_parens.append(c)\n    end\n    if open_braces_count > 0\n        error(\"\
    unclosed braces found\")\n    end\n    if closed_parens == 0\n        error(\"\
    unclosed parentheses found\")\n    end\n    open_parens\nend\n</cell>\n<code language=julia-1.4>\n\
    separate_paren_groups(\"( ) (( )) (( )( ))\")\n</cell>\n<text>\nExercise 1: Write\
    \ a function that takes in a string containing parenthetical statements and returns\
    \ a vector containing the groups. For example,", "    paren_string = replace(paren_string,\
    \ \" \", \"\") \n    paren_string = replace(paren_string, \" \", \"\") \n    return\
    \ paren_string.split(r\")\")\nend\n</cell>\n<code language=julia-1.6>", "    paren_string\
    \ = paren_string.trim()\n    groups = paren_string.match(r\"\\(+|\\)+|\\)+|\\\
    (+\\)\")\n    if groups.isnothing\n        error(\"Cannot find balanced groups\
    \ in your string\")\n    else\n        return groups.captures\n    end\nend\n\
    </cell>\n<cell>\nseparate_paren_groups(\"( ) (( )) (( )( ))\")\n</cell>\n<text>\n\
    Task 3. Make function which returns a boolean if string has exactly two open/closed\
    \ parenthesis\nReturn true for \"(()\", \"()()\", \"(())\", \"(()())\", \"(()()())\"\
    \ and false for \"(())\", \"()()(\", \"(()())()\", \"(()()()()\", \"(())()\",\
    \ \"(())(())\", \"()(()())\", \"(())()()\", \"((()))\", \"(()())())\", \"()(())()\"",
  "    \"\"\"\n    Separate parentheses in input string. \n    Separate groups are\
    \ balanced (each open brace is properly closed) and not nested within each other\n\
    \    Ignore any spaces in the input string.\n    Do not call this function directly.\n\
    \    >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\"\
    , \"(()())\"]\n    \"\"\"\n    # your code here", "    paren_string = paren_string.strip()\n\
    \    paren_string = paren_string.strip(\"()\")\n    paren_string = paren_string.replace(\"\
    \ \", \"\")\n    paren_string = paren_string.split(\"(\")\n    paren_string =\
    \ paren_string.last\n    paren_string = paren_string.split(\")\")\n    paren_string\
    \ = paren_string.first\n    paren_string = paren_string.collect{|x| x.strip(\"\
    )\").strip(\"(\")}.uniq\n    return paren_string\nend\n</cell>\n<text>\nTask 1.\
    \ Tokenizing and Parsing Input\nWrite a function called tokenize that takes in\
    \ an input string and returns a vector of tokens.\nThe function should ignore\
    \ all spaces in the input.", "    paren_string = replace(paren_string, \" \",\
    \ \"\")\n    paren_string = replace(paren_string, \"(\", \"(\")\n    paren_string\
    \ = replace(paren_string, \")\", \")\")\n    paren_string = replace(paren_string,\
    \ \"[\", \"(\")\n    paren_string = replace(paren_string, \"]\", \")\")\n    paren_string\
    \ = replace(paren_string, \"{\", \"(\")\n    paren_string = replace(paren_string,\
    \ \"}\", \"(\")\n    paren_string = replace(paren_string, \"'\", \"\"\"\")\n \
    \   paren_string = replace(paren_string, \",\", \"\")\n    return paren_string.split(\"\
    )\")\nend\n</cell>\n<code language=julia-1.5>\nseparate_paren_groups(\"( ) ((\
    \ )) (( )( ))\")\n</cell>\n<code language=julia-1.5>", "    paren_string = paren_string.trim()\n\
    \    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.",
  "    paren_strings = split(paren_string, \" \") # Split by the space character into\
    \ an array of strings\n    paren_strings = removeall(paren_strings, \" \") # Remove\
    \ all elements of the string array that contain a space character\n    paren_strings\
    \ = removeall(paren_strings, \"(\") # Remove all elements of the string array\
    \ that contain the open character (\n    paren_strings = removeall(paren_strings,\
    \ \")\") # Remove all elements of the string array that contain the close character)\n\
    \    return paren_strings\nend", "    paren_string = paren_string.replace(\" \"\
    , \"\")\n    return paren_string.split(r\"\\(\")\nend", "    paren_string = paren_string.split(\"\
    \") # create an array of characters\n    paren_string = filter(x -> isopenparen(x)\
    \ or iscloseparen(x), paren_string) # filter out empty characters\n    \n    #\
    \ create a vector of strings and populate it\n    paren_string = paren_string.map(x\
    \ -> string(x)) # convert back to string\n    paren_string = paren_string.map(x\
    \ -> paren_string[x+1:end-1]) # skip the open paren\n    paren_string = paren_string.map(x\
    \ -> paren_string[x-1:end-1]) # skip the close paren\n    return paren_string\n\
    end\n</cell>\n<code language=julia-1.5>\nseparate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n</cell>\n<code language=julia-1.5>\nusing Random\n</cell>\n<code language=julia-1.5>",
  "    paren_string = paren_string.trim() // remove whitespace\n    paren_stack =\
    \ Stack{String}()\n    paren_count = 0", "    paren_string = strip(paren_string)\n\
    \    stack = Vector{String}()\n    brackets = 0\n    for c in paren_string\n \
    \       if c == '('\n            push!(stack, '(')\n            brackets += 1\n\
    \        elseif c == ')'\n            pop!(stack)\n            if brackets ==\
    \ 0\n                push!(stack, c)\n            else\n                brackets\
    \ -= 1\n            end\n        else\n            if brackets == 0\n        \
    \        push!(stack, c) \n            else\n                brackets -= 1\n \
    \           end\n        end\n    end\n    return stack\nend\n</cell>\n<code language=julia-1.3>\n\
    separate_paren_groups(\"( ) (( )) (( )( ))\")\n</cell>\n<text>\nPart 2: Parsing\
    \ and processing data\nNow that you have an idea of how we will use the function\
    \ you wrote to separate the parenthesis\ngroups, lets look at the parsing process\
    \ and how we might go about it. We will implement a parser", "  stack = Vector{String}()\n\
    \  groups = Vector{String}()\n  open_braces = 0\n  for group in split(paren_string,\
    \ \" \\t\")\n    if group == \"\"\n      continue\n    open_braces += find_open_braces(group)\n\
    \    if open_braces <= 0\n      push!(groups, group)\n    else\n      push!(stack,\
    \ rev(group))\n    end\n  end\n  return groups\nend", "    paren_string = remove_brackets(paren_string)\n\
    \    paren_string = replace(paren_string, \"(\", \"\")\n    paren_string = replace(paren_string,\
    \ \")\", \"\")\n    paren_string = replace(paren_string, \"{\", \"\")\n    paren_string\
    \ = replace(paren_string, \"}\", \"\")\n    paren_string = replace(paren_string,\
    \ \" \", \"\")\n    paren_string = replace(paren_string, \",\", \"\")\n    paren_string\
    \ = replace(paren_string, \".\", \"\")\n    paren_string = replace(paren_string,\
    \ \"[\", \"\")\n    paren_string = replace(paren_string, \"]\", \"\")\n    paren_string\
    \ = replace(paren_string, \"{\", \"\")\n    paren_string = replace(paren_string,\
    \ \"}\", \"\")\n    paren_string = replace(paren_string, \"[\", \"\")\n    paren_string\
    \ = replace(paren_string, \"]\", \"\")\n    paren_string = replace(paren_string,\
    \ \"(\", \"\")\n    paren_string = replace(paren_string, \")\", \"\")\n    paren_string\
    \ = replace(paren_string, \"{\", \"\")\n    paren_string = replace(paren_string,\
    \ \"}\", \"\")\n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string\
    \ = replace(paren_string, \",\", \"\")\n    paren_string = replace(paren_string,\
    \ \".\", \"\")\n    paren_string = replace(paren_string, \"[\", \"\")\n    paren_string\
    \ = replace(paren_string, \"]\", \"\")\n    paren_string = replace(paren_string,\
    \ \"{\", \"\")\n    paren_string = replace(paren_string, \"}\", \"\")\n    paren_string\
    \ = replace(paren_string, \"[\", \"\")\n    paren_string = replace(paren_string,\
    \ \"]\", \"\")\n    return paren_string\nend\n</cell>\n<text>\nTask 6. Write a\
    \ function which takes a string as input, and outputs a boolean indicating whether\n\
    \    the string is palindrome or not.", "        paren_string = paren_string.replace(\"\
    \ \", \"\")\n        paren_string = paren_string.replace(\"\\n\", \"\")\n    \
    \    paren_string = paren_string.replace(\"\\t\", \"\")\n        paren_string\
    \ = paren_string.replace(\"(\", \"\")\n        paren_string = paren_string.replace(\"\
    )\", \"\")\n        paren_string = paren_string.replace(\"{\", \"\")\n       \
    \ paren_string = paren_string.replace(\"}\", \"\")\n        return paren_string.split(')')\n\
    end", "    paren_tokens = paren_string.split(r\"(\\(|\\))+\") \n    paren_tokens[2]\
    \ # ignore the first paren group (all parens within parens group are separate)\n\
    end\n</code>\n<|/ a tags=string,julia |>\n<| a |>\nAnother variation on solution\
    \ with comprehension:\n<code>\nstr = \"(( ( ) ) ( ) ( ))\"\nstrs = [i for i in\
    \ str if typeof(i)==String]\n</code>\n<|/ a tags=string,julia dscore=2 |>\n<|\
    \ a |>\nHere is another option (inspired by another answer):\n<code>\nstrs = [\"\
    (( ( ) ) ( ) ( ))\", \"((( ()( ) () )))\", \"(( ()( )()( )) ())\"]", "    # Complete\
    \ this function\n    return []\n    # Separate_paren_groups(\"( ) (( )) (( )(\
    \ ))\")\nend", "    \"\"\"\n    Complete the function so that the return value\
    \ is the vector of parentheses separated strings.\n    >>> separate_paren_groups(\"\
    ( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\n    paren_string\
    \ = paren_string.strip() # remove any extra spaces in front of parens\n    paren_string\
    \ = paren_string.strip(\"()\")  # remove any spaces inside parens\n    paren_string\
    \ = paren_string.strip(\"[]\")  # remove any spaces inside parens\n    paren_string\
    \ = paren_string.strip(\"{}\")  # remove any spaces inside parens\n    paren_string\
    \ = paren_string.strip(\"{}[]\") # remove any spaces inside parens\n    paren_string\
    \ = paren_string.strip(\"{}[]()\") # remove any spaces inside parens\n    paren_string\
    \ = paren_string.strip(\"{}[]()()\") # remove any spaces inside parens\n    paren_string\
    \ = paren_string.strip(\"{}[]()()()\") # remove any spaces inside parens\n   \
    \ paren_string = paren_string.strip(\"{}[]()()()()\") # remove any spaces inside\
    \ parens\n    paren_string = paren_string.strip(\"{}[]()()()()[]\") # remove any\
    \ spaces inside parens\n    paren_string = paren_string.strip(\"{}[]()()()(){}\"\
    ) # remove any spaces inside parens\n    paren_string = paren_string.strip(\"\
    {}[]()()()(){}[]\") # remove any spaces inside parens\n    paren_string = paren_string.strip(\"\
    {}[]()()()(){}[]()\") # remove any spaces inside parens\n    paren_string = paren_string.strip(\"\
    {}[]()()()(){}[]()()\") # remove any spaces inside parens\n    paren_string =\
    \ paren_string.strip(\"{}[]()()()(){}[]()()()\") # remove any spaces inside parens\n\
    \    paren_string = paren_string.strip(\"{}[]()()()(){}[]()()()[]\") # remove\
    \ any spaces inside parens\n    paren_string = paren_string.strip(\"{}[]()()()(){}[]()()(){}[]\"\
    ) # remove any spaces inside parens\n    paren_string = paren_string.strip(\"\
    {}[]()()()(){}[]()()(){}[]()\") # remove any spaces inside parens\n    paren_string\
    \ = paren_string.strip(\"", "    stack = Vector{String}()\n    for s in paren_string\n\
    \        if s==\"(\" || s==\")\" || s==\"[\" || s==\"]\" || s==\"{\" || s=\"}\"\
    \n            stack = append(stack,s)\n        elseif isalpha(s) || isempty(s)\n\
    \            stack = append(stack,\"\")\n        end\n    end\n    return stack\n\
    end", "        \n    # initialize the new vector to hold our groups\n    group_vec\
    \ = Vector{String}()", "    paren_strings = paren_string.splitall(\"(\")\n   \
    \ separated_strings = Vector{String}()\n    for string in paren_strings\n    \
    \    parens_closed = false\n        for paren in string\n            if paren\
    \ == \")\"\n                if parens_closed\n                    separated_strings.append(string)\n\
    \                else\n                    parens_closed = true\n            \
    \    end\n            else\n                if parens_closed\n               \
    \     parens_closed = false\n                else\n                    parens_closed\
    \ = true\n                end\n            end\n        end\n    end\n    return\
    \ separated_strings\nend\n</cell>\n<code language=julia-1.4>\nseparate_paren_groups(\"\
    ( ) (( )) (( )( ))\")\n</cell>\n<text>\nProblem 3: Count Number of Parentheses\n\
    Write a function that counts the number of parentheses in a given string.\n>>>\
    \ count_parens(\"(()()\")\n2\n>>> count_parens(\"(())\")\n1\n>>> count_parens(\"\
    (( )) (( ))\")\n3\n</text>\n<code language=julia-1.4>", "    paren_string = replace(paren_string,\
    \ \" \", \"\")\n    paren_string = replace(paren_string, \"\\n\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\\t\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\\r\", \"\")\n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string\
    \ = replace(paren_string, \"((\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\\n\", \"\")\n    paren_string = replace(paren_string, \"\\t\", \"\")\n  \
    \  paren_string = replace(paren_string, \"\\r\", \"\")", "    return paren_string.split('(\
    \ )')\nend", "    \"\"\" Your code goes here! \"\"\"\n    \nend", "    \"\"\"\
    \ This function receives a string containing multiple groups of nested parentheses.\
    \ Your goal is to \n    separate those group into separate strings and return\
    \ the vector of those.\n    Separate groups are balanced (each open brace is properly\
    \ closed) and not nested within each other\n    Ignore any spaces in the input\
    \ string.\n    \"\"\"\n    function separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n        paren_string_split = split(paren_string, \"()\")\n        paren_string_split\
    \ = [paren_string_split[i] for i in range(len(paren_string_split)) if paren_string_split[i]!=\"\
    ()\"]\n        paren_string_split = [paren_string_split[i] for i in range(len(paren_string_split))\
    \ if paren_string_split[i]!=\"(\"]\n        paren_string_split = [paren_string_split[i]\
    \ for i in range(len(paren_string_split)) if paren_string_split[i]!=\" \"]\n \
    \       return paren_string_split\n    end\nend", "    stack = []\n    paren_string\
    \ = replace(paren_string, \" \", \"\") |> trim\n    for i in paren_string\n  \
    \      opening = paren_string.starts_with(i)\n        if opening\n           \
    \ stack.append(i)\n        else\n            if paren_string.ends_with(i)\n  \
    \              stack.pop\n                stack.append(i)\n            else\n\
    \                push!(stack, i)\n    paren_string = paren_string.strip\n    return\
    \ stack\nend \"\"\"", "    paren_string = paren_string.replace(\"\\n\", \"\")\n\
    \    group_regex = Regex(\"^\\\\({1,}.*\\\\){1,}.*$\")\n    matches = findall(group_regex,\
    \ paren_string)\n    return matches\nend\n</cell>\n<code language=julia-1.5>\n\
    # test your code\nseparate_paren_groups(\"( ) (( )) (( )( ))\")\n</cell>\n<text>\n\
    Optional challenge\nWrite a function to convert a vector of strings to a matrix\
    \ with columns being those strings. For example:", "    paren_string = paren_string.strip\n\
    \    return paren_string.split(r\"\\s\")\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\n    A function that takes a string and finds all the words that are not\
    \ capitalized\n\"\"\"", "        separated = []\n        paren_open = []\n   \
    \     paren_close = []\n        string_split = split(paren_string, ' ')\n    \
    \    for s in string_split\n            paren_open = findall(paren_open, s =>\
    \ s == \")\")\n            paren_close = findall(paren_close, s => s == \")\"\
    )\n            if length(paren_open) == length(paren_close)\n                if\
    \ length(paren_open) == 0\n                    push!(separated, s)\n         \
    \           paren_open = []\n                    paren_close = []\n          \
    \      elseif length(paren_open) != 0\n                    push!(paren_close,\
    \ pop!(paren_close))\n                end\n            elseif length(paren_open)\
    \ == length(paren_close)\n                if length(paren_open) != length(paren_close)\n\
    \                    push!(paren_open, pop!(paren_open))\n                end\n\
    \                push!(separated, s)\n            end\n        end\n        return\
    \ separated\n    end\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThanks for sharing\
    \ this function! I took your function and modified it a little bit. Instead of\
    \ using regex to find and remove parenthesis, I used the function you suggested.\n\
    <|/ c |>\n<| c |>\nI modified your function to return an array of strings by passing\
    \ it a vector of strings. I then passed that vector to the function you suggest\
    \ in my other answer.\n<|/ c |>\n<| c |>\nI tried to run your function separately.\
    \ It worked for the most part, but there is an edge case where the parenthesis\
    \ get stuck in an infinite loop. For example, if I have two groups with parentheses\
    \ in them, the first group gets stuck in an infinite loop. The second group goes\
    \ through just fine.\n<|/ c |>\n<| c |>\nThanks for pointing that out. I've edited\
    \ my answer to fix that edge case.\n<|/ c |>\n<| a tags=string,julia,parentheses,arrays\
    \ |>\nHere's my solution. It's a little slower than the above solutions because\
    \ it uses a mutable vector (String[]). Depending on your requirements, you might\
    \ want to consider using the \"unsafe\" function split to avoid a mutable vector\
    \ altogether:\n<code>", "    stack = Vector{String}()\n    for paren in paren_string\n\
    \        if paren == \"(\"\n            push!(stack, \"(\")\n        else if paren\
    \ == \")\"\n            if isempty(stack)\n                throw(ArgumentError(\"\
    Mismatched parentheses at $paren_string\"))\n            else\n              \
    \  pop!(stack)\n            end\n        elseif paren == \" \"\n            throw(ArgumentError(\"\
    No space allowed in parentheses at $paren_string\"))\n        elseif paren ==\
    \ \"\\n\"\n            throw(ArgumentError(\"No new line allowed in parentheses\
    \ at $paren_string\"))\n        end\n    end\n    return stack\nend", "    paren_string\
    \ = split(paren_string, \" \")\n    paren_string = filter(elem -> elem != \"\"\
    , paren_string)\n    paren_string = filter(elem -> elem !~ \" \", paren_string)\n\
    \    paren_string = filter(elem -> elem !~ \"\", paren_string)\n    paren_string\
    \ = map(elem -> split(elem, \"(\"), paren_string)\n    paren_string = map(elem\
    \ -> map(elem -> split(elem, \"(\"), elem), paren_string)\n    paren_string =\
    \ map(elem -> map(elem -> split(elem, \")\"), elem), paren_string)\n    paren_string\
    \ = map(elem -> map(elem -> split(elem, \"))\"), elem), paren_string)\n    return\
    \ paren_string\n</code>\nThe function above is a very compact form of what it\
    \ does.\nYou will notice that when calling this function you pass it a string,\
    \ so that the function knows how to split that string into groups of characters.\
    \ If you want to pass a string, you can just pass that string as the first argument,\
    \ but I prefer to explicitly call it like this because I am not too fond of having\
    \ to type the function call twice.\nThe function returns this output:\n<code>\n\
    [\"()\", \"(())\", \"(()())\"]\n</code>\n<|/ a dscore=3 tags=string,julia |>\n\
    <| c |>\nJust wanted to add that `map(f,xs)` is equivalent to `collect(Iterators.filter(x->f(x),xs))`\n\
    <|/ c |>\n<| c |>\nI always forget that there is a built-in function that does\
    \ this type of thing. Thanks for the tip! I updated my answer accordingly\n<|/\
    \ c |>\n<| a dscore=2 |>\nHere's another one-liner that may help you:\n<code>\n\
    [x for s in split(s, \"()\") for x in split(s, \"()\")[1:end-1]]\n</code>\nIt\
    \ splits each string into substrings and then resplits them back into strings.\n\
    <|/ a tags=string,julia |>\n<| a dscore=2 |>\n<code>\n[x for s in split(s,\"()\"\
    ) for x in split(s,\"()\")[1:end-1]]\n</code>\n<|/ a tags=string,julia |>\n<|\
    \ a tags=string,julia |>\nUsing regular expressions you can do this:\n<code>\n\
    s = \"( ) (( )) (( )( ))\"\n[g for s in split(s, \"()\") for g in split(s, \"\
    ()\")[1:end-1]]\n</code>\n<|/ a dscore=1 |>\n<| c |>\nCan you add an explanation\
    \ with your answer?\n<|/ c |>\n<| c |>\nSure, but ", "    paren_string = paren_string.strip()\
    \ # remove white space from start and end\n    paren_string = paren_string[end-1::end]\
    \ # trim off last closing paren \n    paren_string = paren_string.split(r\"\\\
    )\") # split on closing paren\n    paren_string = paren_string[begin-1::end] #\
    \ trim off first opening paren\n    paren_string = paren_string[end+1:end+1] #\
    \ trim off last closing paren\n    paren_string = paren_string.map(x => x.strip)\
    \ # remove white space\n    return paren_string\nend\n</code>\n<|/ a |>\n<| a\
    \ dscore=0 |>\nMy solution (for those who need it) is as follows:\n<code>", " \
    \   \"\"\"\n    Separate each group of nested parentheses into separate strings\
    \ and return the vector of those strings.\n    Ignore any spaces in the input\
    \ string.\n    \"\"\"", "    paren_groups = Vector{String}()\n    push!(paren_groups,\
    \ \"\")\n    \n    for i in 1:length(paren_string)\n        open_brace_position\
    \ = get_open_brace_position(paren_string, i)\n        if open_brace_position ==\
    \ -1\n            push!(paren_groups, \"\")\n        else\n            push!(paren_groups,\
    \ paren_string[open_brace_position+1 : i])\n        end\n    end\n    \n    paren_groups\n\
    end\n</cell>\n<cell>\nseparate_paren_groups(\"( ) (( )) (( )( ))\")\n</cell>\n\
    <text>\nProblem 6", "    paren_string = replace(paren_string, \" \", \"\")\n \
    \   paren_string = replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \"()()\", \"\")\n    paren_string = replace(paren_string, \"(())\", \"\")\n\
    \    paren_string = replace(paren_string, \"(((()))\", \"\")\n    paren_string\
    \ = replace(paren_string, \")()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(())\", \"\")\n    paren_string = replace(paren_string, \"()(())\", \"\"\
    )\n    paren_string = replace(paren_string, \")(()())\", \"\")\n    paren_string\
    \ = replace(paren_string, \"(()()())\", \"\")\n    paren_string = replace(paren_string,\
    \ \"()(()())\", \"\")\n    paren_string = replace(paren_string, \"((())())\",\
    \ \"\")\n    paren_string = replace(paren_string, \"((())(())\", \"\")\n    paren_string\
    \ = replace(paren_string, \"(()()())()\", \"\")\n    paren_string = replace(paren_string,\
    \ \"(()())()()\", \"\")\n    paren_string = replace(paren_string, \"(())(())\"\
    , \"\")\n    paren_string = replace(paren_string, \"(())(()())\", \"\")\n    paren_string\
    \ = replace(paren_string, \"((()())())\", \"\")\n    paren_string = replace(paren_string,\
    \ \"((()())(())\", \"\")\n    paren_string = replace(paren_string, \"(())()()\"\
    , \"\")\n    paren_string = replace(paren_string, \"(())()()()\", \"\")\n    paren_string\
    \ = replace(paren_string, \"(((()())())\", \"\")\n    paren_string = replace(paren_string,\
    \ \"(((()())(()))\", \"\")\n    paren_string = replace(paren_string, \"((()()())())\"\
    , \"\")\n    paren_string = replace(paren_string, \"((()()())(()))\", \"\")\n\
    \    paren_string = replace(paren_string, \"(())()()()\", \"\")\n    paren_string\
    \ = replace(paren_string, \"(())()()()()\", \"\")\n    paren_string = replace(paren_string,\
    \ \"((())()()())\", \"\")\n    paren_string = replace(paren_string, \"((())()()(()))\"\
    , \"\")\n    paren_string = replace(paren_string, \"(()()()())\", \"\")\n    paren_string\
    \ = replace(paren_string, \"(()()()()\", \"\")\n    paren_string = replace(paren_string,\
    \ \"()()()()\", \"\")\n    paren_string = replace(paren_string, \"()()()()()\"\
    , \"\")\n    paren_string = replace(paren_string, \"()()()()()()\", \"\")\n  \
    \  paren_string = replace(paren_string, \"()()()()()()()\", \"\")\n    paren_string\
    \ = replace(paren_string, \"()()()()()()()()\", \"\")\n", "\"\"\"\n    >>> separate_paren_groups(\"\
    (()())\")\n    [\"()()\"]\n    >>> separate_paren_groups(\"((()))\")\n    [\"\
    ()()\"]\n    >>> separate_paren_groups(\"(((((())))(())))\")\n    [\"(()())\"\
    ]\n    >>> separate_paren_groups(\"((((((((((()))))))))))\")\n    [\"((())())\"\
    ]\n    >>> separate_paren_groups(\"(()()())\")\n    [\"()()()\"]\n    >>> separate_paren_groups(\"\
    (()())(())()\")\n    [\"()\", \"()()()\"]\n    >>> separate_paren_groups(\"((()())(()())\"\
    )\n    [\"()\", \"()()()\"]\n    >>> separate_paren_groups(\"((((())))((()))((())))\"\
    )\n    [\"()()\", \"()()()()\", \"()()()()()\"]\n\"\"\"\nend", "    paren_string\
    \ = paren_string.replace(\" \", \"\")\n    \n    paren_groups = Array{String}(undef,\
    \ 0)", "\"\"\"\n    Separate input into separate groups of nested parentheses\n\
    \    Input string can be any valid string containing multiple groups of nested\
    \ parentheses\n    Output vector should have the same length as the input string\n\
    \    Ignore any spaces in the input string\n    >>> separate_paren_groups(\"(\
    \ ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"", "    paren_string_split::Vector{String}\
    \ = split(paren_string, \" \")\n    open_paren_string::Vector{String} = paren_string_split[1\
    \ .. end-1]\n    closed_paren_string::Vector{String} = paren_string_split[end+1::end]\n\
    \    for string in open_paren_string\n        if string(1) == \")\"\n        \
    \    string = string[2:end]\n        end\n    end\n    for string in closed_paren_string\n\
    \        if string(1) == \")\"\n            string = string[1:end-1]\n       \
    \ end\n    end\n    return open_paren_string ++ closed_paren_string\nend\n</cell>\n\
    <code language=julia-1.5>", "    paren_string = paren_string.trim()\n    if paren_string\
    \ == \"\"\n        return String[]\n    else\n        open_paren_counter = 0\n\
    \        string_stack = Vector{String}()\n        string_stack_ind = 1\n     \
    \   while true\n            paren_char = paren_string[string_stack_ind - 1]\n\
    \            if paren_char == \")\"\n                if open_paren_counter > 0\
    \ \n                    string_stack[string_stack_ind] = paren_char\n        \
    \            string_stack_ind += 1\n                    open_paren_counter -=\
    \ 1\n                else\n                    string_stack_ind += 1\n       \
    \     elseif paren_char == \"(\"\n                if open_paren_counter == 0\n\
    \                    string_stack_ind += 1\n                    string_stack[string_stack_ind]\
    \ = paren_char\n                else\n                    open_paren_counter +=\
    \ 1\n            else\n                string_stack[string_stack_ind] = paren_char\n\
    \                open_paren_counter = open_paren_counter % 2\n            end\n\
    \            if paren_char == \")\"\n                if open_paren_counter ==\
    \ 0\n                    string_stack_ind += 1\n                    string_stack[string_stack_ind]\
    \ = paren_char\n                else\n                    open_paren_counter +=\
    \ 1\n                end\n            else\n                open_paren_counter\
    \ = open_paren_counter % 2\n            end\n            if string_stack_ind >=\
    \ length(paren_string)\n                break\n            end\n        end\n\
    \        string_stack = string_stack[1:string_stack_ind]\n        return string_stack\n\
    \    end\nend", "    paren_string = replace(paren_string, \" \", \"\")\n    paren_string\
    \ = replace(paren_string, \"( \", \"(\")\n    paren_string = replace(paren_string,\
    \ \" )\", \")\")\n    paren_string = replace(paren_string, \"( \", \" (\")\n \
    \   paren_string = replace(paren_string, \" ) \", \" )\")\n    return paren_string\n\
    end", "    paren_split = splitByString(paren_string, \"()\")\n    paren_split\n\
    end\n</cell>\n<code language=julia-1.5>\nseparate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n</cell>\n<text>\nExercise 5: Write a function that takes a string\
    \ containing multiple nested parentheses and returns a list of strings where each\
    \ string is one group of nested parentheses.", "    paren_string = replace(paren_string,\
    \ \" \", \"\") # remove spaces so we don't split on them later\n    paren_string\
    \ = paren_string.split(\"(\")\n    paren_string = filter(x -> x != \"\", paren_string)\n\
    \    paren_string = filter(x -> x != \"(\", paren_string)\n    paren_string =\
    \ filter(x -> x != \")\", paren_string)\n    paren_string = map(x -> \"{\" + x\
    \ + \"}\", paren_string)\n    paren_string = join(paren_string, \"\")\n    paren_string\
    \ = replace(paren_string, \"}\", \"\") # remove brackets so we don't split on\
    \ them later\n    paren_string = split(paren_string, \")\") # split on closing\
    \ bracket\n    paren_string = map(x -> x + \"}\", paren_string) # add brackets\
    \ back on at the end\n    paren_string = join(paren_string, \"\")\n    paren_string\
    \ = replace(paren_string, \"{\", \"\") # remove brackets so we don't split on\
    \ them later\n    paren_string = split(paren_string, \"(\") # split on opening\
    \ bracket\n    paren_string = map(x -> x + \"(\", paren_string) # add brackets\
    \ back on at the beginning\n    paren_string = join(paren_string, \"\")\n    paren_string\
    \ = replace(paren_string, \")\", \"\") # remove brackets so we don't split on\
    \ them later\n    paren_string = split(paren_string, \" \") # split on spaces\n\
    \    paren_string = map(x -> x.replace(\")\", \"\").replace(\"(\", \"\").replace(\"\
    {\", \"\").replace(\"}\", \"\"), paren_string) # remove brackets so we don't split\
    \ on them later\n    paren_string = join(paren_string, \"\")\n    paren_string\
    \ = replace(paren_string, \"{\", \"\") # remove brackets so we don't split on\
    \ them later\n    paren_string = split(paren_string, \"(\") # split on opening\
    \ bracket\n    paren_string = map(x -> x + \"(\", paren_string) # add brackets\
    \ back on at the beginning\n    paren_string = join(paren_string, \"\")\n    paren_string\
    \ = replace(paren_string, \")\", \"\") # remove brackets so we don't split on\
    \ them later\n    paren_string = split(paren_string, \" \") # split on spaces\n\
    \    paren_string = map(x -> x.replace(\")\", \"\").replace(\"(\", \"\").replace(\"\
    {\", \"\").replace(\"}\", \"\"), paren_string) # remove brackets so we don't split\
    \ on them later\n    paren_string = join(paren_string, \"\")\n    paren_string\
    \ = replace(paren_string, \"}\", \"\") # remove brackets so we don't split on\
    \ them later\n    paren_string = split(paren_string, \")\") # split on closing\
    \ bracket\n    paren_string = map(x -> ", "    \n    stack = []\n    paren_string\
    \ = \"(\" + paren_string\n    for c in paren_string\n        if c == \"(\" \n\
    \            push!(stack, c)\n        elseif c == \"(\" \n            pop!(stack)\n\
    \            paren_string = substring(paren_string, start+1, end-1)\n        \
    \    paren_string = paren_string + \"()\"\n        elseif c == \")\" \n      \
    \      push!(stack, \"(\" + paren_string)\n        elseif c == \")\" \n      \
    \      pop!(stack)\n            paren_string = substring(paren_string, start+1,\
    \ end-1)\n            paren_string = paren_string + \")\"\n        end\n    end\n\
    \    paren_string = substring(paren_string, start+1, end)\n    return paren_string\n\
    end\n</cell>\n<code language=julia-1.5>\nseparate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n</cell>\n<text>\nThe second function below splits the input string\
    \ into its individual characters within a vector of characters:", "    string_rep=paren_string\n\
    \    paren_groups=[]\n    open_brace_index=0\n    closed_brace_count=0\n    open_brace_in_string=False\n\
    \    for paren in string_rep\n        if paren==' ' \n            closed_brace_count+=1\n\
    \        else\n            if paren=='('\n                open_brace_in_string=True\n\
    \            elseif paren==')'\n                if open_brace_in_string\n    \
    \                open_brace_in_string=False\n                    closed_brace_count-=1\n\
    \                else\n                    if open_brace_index == 0\n        \
    \                paren_groups[open_brace_index]=paren\n                      \
    \  open_brace_index+=1\n                    else\n                        if closed_brace_count<0\n\
    \                            paren_groups[open_brace_index]=paren\n          \
    \                  open_brace_index+=1\n                        else\n       \
    \                     paren_groups[open_brace_index-closed_brace_count]=paren\n\
    \                            closed_brace_count-=1\n                         \
    \   open_brace_index-=1\n        end\n    end\n    return paren_groups\nend\n\
    </cell>\n<code language=julia-1.5>\n# Test the separate_paren_groups function\n\
    separate_paren_groups(\"( ) (( )) (( )( ))\")\n</cell>\n<text>\n5.2.3 Extract\
    \ all words", "    paren_string = paren_string.gsub(\" \", \"\")\n    paren_array\
    \ = paren_string.split(\"\")\n    paren_array = [paren_array]\n    \n    paren_groups\
    \ = []\n    paren_group = []\n    \n    for paren_elem in paren_array\n      \
    \  if paren_elem == \"(\" \n            if paren_group == []\n               \
    \ paren_group = [paren_elem]\n            else\n                paren_group =\
    \ [paren_group]\n                paren_group = [paren_group, paren_elem]\n   \
    \             paren_groups.push(paren_group)\n            end\n        elseif\
    \ paren_elem == \")\" \n            if paren_group == []\n                throw(string(\"\
    Expecting parenthesis \", paren_elem, \" at \", string(paren_array)))\n      \
    \      else\n                paren_groups.push(paren_group)\n                paren_group\
    \ = []\n            end\n        elseif paren_elem == \")\"\n            if paren_group\
    \ != []\n                paren_groups.push(paren_group)\n                paren_group\
    \ = []\n            end\n        elseif paren_elem == \"\"\n            paren_groups.push(paren_group)\n\
    \            paren_group = []\n        else\n            paren_group = [paren_group,\
    \ paren_elem]\n        end\n    end\n    \n    paren_groups.push(paren_group)\n\
    \    return paren_groups\nend\n</cell>\n<text>\nThe function above is called inside\
    \ the function parenthesize() below. This function parses a string representing\
    \ a parenthesis tree, to build a new parenthesis tree with its nodes labeled according\
    \ to the parenthesis groups in the original string (see function parenthesize()\
    \ above).", "    paren_string = paren_string.trim()\n    \n    paren_groups =\
    \ Vector{String}()\n    cur_open_paren = open_paren_stack.last\n    cur_closed_paren\
    \ = open_paren_stack.length\n    \n    for cur_char in paren_string\n        if\
    \ cur_char == '(' \n            push!(paren_groups, cur_open_paren)\n        \
    \    cur_open_paren += 1\n        else if cur_char == ')'\n            if cur_closed_paren\
    \ == cur_open_paren\n                push!(paren_groups, paren_groups[cur_open_paren])\n\
    \                cur_open_paren -= 1\n            else\n                push!(paren_groups,\
    \ cur_closed_paren)\n                cur_closed_paren -= 1\n            end\n\
    \        else\n            push!(paren_groups, cur_char)\n        end\n    end\n\
    \    return paren_groups\nend\n</cell>\n<text>\nTask 3: Find a way to remove \"\
    (\" and \")\" from the vector of strings. For example, given the vector of strings\
    \ below:", "    paren_string = replace(paren_string, \" \", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"(\")\n    paren_string = replace(paren_string,\
    \ \"()(\", \"(\")\n    paren_string = replace(paren_string, \"((\", \"(\")\n \
    \   paren_string = replace(paren_string, \"()(\", \"(\")\n    paren_string = replace(paren_string,\
    \ \")((\", \"(\")\n    paren_string = replace(paren_string, \")())\", \"()\")\n\
    \    paren_string = replace(paren_string, \")()(\", \"(\")\n    paren_string =\
    \ replace(paren_string, \")((\", \"(\")\n    paren_string = replace(paren_string,\
    \ \"()(\", \"(\")\n    paren_string = replace(paren_string, \"((\", \"(\")\n \
    \   paren_string = replace(paren_string, \"()(\", \"(\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"(\")\n    paren_string = replace(paren_string, \")()(\", \"(\")\n\
    \    paren_string = replace(paren_string, \")((\", \"(\")\n    paren_string =\
    \ replace(paren_string, \")()(\", \"(\")\n    paren_string = replace(paren_string,\
    \ \")((\", \"(\")\n    paren_string = replace(paren_string, \")()(\", \"(\")\n\
    \    paren_string = replace(paren_string, \")((\", \"(\")\n    paren_string =\
    \ replace(paren_string, \")()(\", \"(\")\n    paren_string = replace(paren_string,\
    \ \")((\", \"(\")\n    paren_string = replace(paren_string, \")()(\", \"(\")\n\
    \    paren_string = replace(paren_string, \")((\", \"(\")\n    paren_string =\
    \ replace(paren_string, \")()(\", \"(\")\n    paren_string = replace(paren_string,\
    \ \")((\", \"(\")\n    paren_string = replace(paren_string, \")()(\", \"(\")\n\
    \    paren_string = replace(paren_string, \")((\", \"(\")\n    paren_string =\
    \ replace(paren_string, \")()(\", \"(\")\n    paren_string = replace(paren_string,\
    \ \")((\", \"(\")\n    paren_string = replace(paren_string, \")()(\", \"(\")\n\
    \    paren_string = replace(paren_string, \")((\", \"(\")\n    paren_string =\
    \ replace(paren_string, \")()(\", \"(\")\n    paren_string = replace(paren_string,\
    \ \")((\", \"(\")\n    paren_string = replace(paren_string, \")()(\", \"(\")\n\
    \    paren_string = replace(paren_string, \")((\", \"(\")\n", "    stack = Vector{String}()\n\
    \    parens = Vector{String}()\n    openings = Vector{String}()\n    closings\
    \ = Vector{String}()\n    for c in paren_string\n        if c == \")\"\n     \
    \       if length(openings) == 0\n                push!(stack,parens)\n      \
    \          parens = parens[:]\n            else\n                push!(stack,closings)\n\
    \                closings = closings[:]\n            end\n        elseif c ==\
    \ \"(\"\n            if length(parens) == 0\n                push!(stack,parens)\n\
    \                parens = parens[:]\n            else\n                push!(stack,openings)\n\
    \                openings = openings[:]\n            end\n        else\n     \
    \       push!(parens,c)\n        end\n    end\n    if length(stack) == 0\n   \
    \     push!(parens,paren_string)\n    end\n    stack\nend", "    paren_string\
    \ = paren_string.strip() # Remove leading/trailing spaces\n    paren_string =\
    \ paren_string.strip(\"( )\")\n    paren_string = paren_string.gsub(\"( )+\",\
    \ \"(\") # Handle double nested parens\n    paren_string = paren_string.gsub(\"\
    ( {2,})\", \"(\") # Handle uneven nested parens\n    paren_string = paren_string.gsub(\"\
    ( )+\", \"(\") # Handle double nested parens\n    paren_string = paren_string.gsub(\"\
    ( {2,})\", \"(\") # Handle uneven nested parens\n    return paren_string.split(\"\
    ( )\")\nend", "    \"\"\"\n    Your goal is to separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    \"\"\"\n    paren_string = strip(paren_string)\n\
    \    paren_string = replace!(paren_string,\"[\",\"\")\n    paren_string = replace!(paren_string,\"\
    )\",\"\")\n    paren_string = replace!(paren_string,\" \",\"\")\n    paren_string\
    \ = replace!(paren_string,\"\\\"\",\"\")\n    paren_string = replace(paren_string,\"\
    ,\",\"\")\n    return paren_string.split(')')\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\n    separate_paren_groups(paren_string::String)::Vector{String}", "  paren_string\
    \ = strip(paren_string)\n  paren_string = replace!(paren_string, \"\\t\", \"\"\
    ) # trim all tabs\n  paren_string = replace!(paren_string, \"\\n\", \"\") # trim\
    \ all newlines\n  paren_string = replace!(paren_string, \" \", \"\") # trim all\
    \ spaces\n  paren_string = replace(paren_string, \",\", \" ,\") # replace , with\
    \ ,", "    paren_stack = Vector{String}()\n    for c in paren_string\n       \
    \ if c == \"(\"\n            paren_stack = paren_stack |> push(c)\n        elseif\
    \ c == \"(\"\n            paren_stack = paren_stack |> push(c)\n        elseif\
    \ c == \")\"\n            if !isEmpty(paren_stack)\n                pop!(paren_stack)\n\
    \            else\n                error(\"unmatched close paren group\")\n  \
    \          end\n        elseif c == \")\"\n            if !isEmpty(paren_stack)\n\
    \                pop!(paren_stack)\n            else\n                error(\"\
    unmatched close paren group\")\n            end\n        else\n            paren_stack\
    \ = paren_stack |> push(c)\n        end\n    end\n    return paren_stack\nend\n\
    </cell>\n<text>\nExercise: Write a function split_paren_group that does the same\
    \ thing as the previous function, but uses only a single paren group. For example,\
    \ the following paren string\n    ( ( ) ) ( ( )) ( ( ) ) ()\nshould be split into\
    \ three groups ( ( ( )) ( ( ) ) ( ( ) ) ), but your function should only return\
    \ one group at a time, meaning the output should be a vector of length 3 containing\
    \ the strings ( ( ( )) ( ( ) ) ( ( ) ) ).", "    paren_strings = Vector{String}()\n\
    \    while true \n        open_brace_pos = find_paren_open_brace(paren_string)\n\
    \        if open_brace_pos==-1 \n            paren_strings = [paren_strings]\n\
    \            break\n        else\n            paren_string = paren_string[1:open_brace_pos]\n\
    \        end\n    end\n    paren_strings\nend", "    stack = Vector{String}()\n\
    \    for paren in paren_string:\n        if paren == ')'\n            pop!(stack)\n\
    \        elseif paren == '('\n            push!(stack, paren)\n        else\n\
    \            push!(stack, paren)\n        end\n    end\n    return stack\nend\n\
    </cell>\n<text>\nPractice Time!\nThe code below will take your raw input string\
    \ and convert it to the appropriate vector by separating each group of parentheses.",
  "    stack::Vector{String} = Vector{String}()\n    for i in paren_string:\n    \
    \    if i == '('\n            push!(stack, i)\n        else if i == ')'\n    \
    \        pop!(stack)\n        else if !isempty(stack)\n            if isequal(stack[end-2],\
    \ ')')\n                stack = copy(stack[1:end-1])\n                push!(stack,\
    \ i)\n            elseif isequal(stack[end-2], ')')\n                push!(stack,\
    \ i)\n                push!(stack, stack[end-1]) \n            else\n        \
    \        push!(stack, i)\n            end\n        end\n    end\n    return stack\n\
    end", "    paren_string = paren_string.strip\n    paren_string = paren_string.strip(\"\
    ()\")\n    paren_string = paren_string.strip(\")\")\n    paren_string = paren_string.strip(\"\
    {}\")\n    paren_string = paren_string.strip(\"[]\")\n    paren_string = paren_string.strip(\"\
    {}\")\n    paren_string = paren_string.strip(\"()\")\n    paren_string = paren_string.strip(\"\
    )\")\n    paren_string = paren_string.strip(\"[]\")\n    paren_string = paren_string.strip(\"\
    {}\")\n    paren_string = paren_string.strip(\"()\")\n    paren_string = paren_string.strip(\"\
    )\")\n    paren_string = paren_string.strip(\"[]\")\n    paren_string = paren_string.strip(\"\
    {}\")\n    paren_string = paren_string.strip(\"()\")\n    paren_string = paren_string.strip(\"\
    )\")\n    paren_string = paren_string.strip(\"[]\")\n    paren_string = paren_string.strip(\"\
    {}\")\n    paren_string = paren_string.strip(\"()\")\n    paren_string = paren_string.strip(\"\
    )\")\n    paren_string = paren_string.strip(\"[]\")\n    paren_string = paren_string.strip(\"\
    {}\")\n    paren_string = paren_string.strip(\"()\")\n    paren_string = paren_string.strip(\"\
    )\")\n    paren_string = paren_string.strip(\"[]\")\n    paren_string = paren_string.strip(\"\
    {}\")\n    paren_string = paren_string.strip(\"()\")\n    paren_string = paren_string.strip(\"\
    )\")\n    paren_string = paren_string.strip(\"[]\")\n    paren_string = paren_string.strip(\"\
    {}\")\n    paren_string = paren_string.strip(\"()\")\n    paren_string = paren_string.strip(\"\
    )\")\n    paren_string = paren_string.strip(\"[]\")\n    paren_string = paren_string.strip(\"\
    {}\")\n    paren_string = paren_string.strip(\"()\")\n    paren_string = paren_string.strip(\"\
    )\")\n    paren_string = paren_string.strip(\"[]\")\n    paren_string = paren_string.strip(\"\
    {}\")\n    paren_string = paren_string.strip(\"()\")\n    paren_string = paren_string.strip(\"\
    )\")\n    paren_string = paren_string.strip(\"[]\")\n    paren_string = paren_string.strip(\"\
    {}\")\n    paren_string = paren_string.strip(\"()\")\n    paren_string = paren_string.strip(\"",
  "    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren", "    paren_groups = paren_string.scan(paren_chars)\n\
    \    paren_groups = paren_groups[2:end]\n    paren_groups = paren_groups[!, :]\n\
    \    return paren_groups\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nBased\
    \ on's answer\n<code>\nlet paren_groups = paren_string.scan(paren_chars)\n   \
    \ .filter(it -> it == \"(\")\n    .filter(it -> it != \")\")\n    .filter(it ->\
    \ it != \")(\")\n    .filter(it -> it != \")(\")\n    .filter(it -> it != \")(\"\
    )\n    .filter(it -> it != \")(\")\n    .filter(it -> it != \")(\")\n    .filter(it\
    \ -> it != \")(\")\n    .filter(it -> it != \")(\")\n    .filter(it -> it != \"\
    )(\")\n    .filter(it -> it != \")(\")\n    .filter(it -> it != \")(\")\n    .filter(it\
    \ -> it != \")(\")\n    .filter(it -> it != \")(\")\n    .filter(it -> it != \"\
    )(\")\n    .filter(it -> it != \")(\")\n    .filter(it -> it != \")(\")\n    .filter(it\
    \ -> it != \")(\")\n    .filter(it -> it != \")(\")\n    .filter(it -> it != \"\
    )(\")\n    .filter(it -> it != \")(\")\n    .filter(it -> it != \")(\")\n    .filter(it\
    \ -> it != \")(\")\n    .filter(it -> it != \")(\")\n    .filter(it -> it != \"\
    )(\")\n    .filter(it -> it != \")(\")\n    .filter(it -> it != \")(\")\n    .filter(it\
    \ -> it != \")(\")\n    .filter(it -> it != \")(\")\n    .filter(it -> it != \"\
    )(\")\n    .filter(it -> it != \")(\")\n    .filter(it -> it != \")(\")\n    .filter(it\
    \ -> it != \")(\")\n    .filter(it -> it != \")(\")\n    .filter(it -> it != \"\
    )(\")\n    .filter(it -> it != \")(\")\n    .filter(it -> it != \")(\")\n    .filter(it\
    \ -> it != \")(\")\n    .filter(it -> it != \")(\")\n    .filter(it -> it != \"\
    )(\")\n    .filter(it -> it != \")(\")\n    .filter(it -> it != \")(\")\n    .filter(it\
    \ -> it != \")(\"", "    paren_string = paren_string.strip()\n    paren_string\
    \ = paren_string.strip(\")\")\n    paren_string = paren_string.strip(\"(\")\n\
    \    paren_string = paren_string.strip(\"{\")\n    paren_string = paren_string.strip(\"\
    }\")\n    paren_string = paren_string.strip(\";\")\n    paren_string = paren_string.strip(\"\
    ,\")\n    paren_string = paren_string.strip(\":\")\n    paren_string = paren_string.strip(\"\
    \\n\")\n    paren_string = paren_string.strip(\"\\r\")\n    paren_string = paren_string.strip(\"\
    \\t\")\n    paren_string = paren_string.strip(\"\\f\")\n    paren_string = paren_string.strip(\"\
    \\a\")", "    paren_string = paren_string.trim()\n    bracket_stack = Vector{String}()\n\
    \    \n    for char in paren_string\n        if char == '('\n            push!(bracket_stack,\
    \ char)\n        elseif char == ')'\n            if length(bracket_stack) > 0\n\
    \                pop!(bracket_stack)\n            else\n                throw(ArgumentError(\"\
    Unbalanced parenthesis: $paren_string\"))\n            end\n        elseif char\
    \ == ' '\n            continue\n        else\n            push!(bracket_stack,\
    \ char)\n        end\n    end\n    return bracket_stack\nend\n</cell>\n<code language=julia-1.5>\n\
    separate_paren_groups(\"( ) (( )) (( )( ))\")\n</cell>\n<code language=julia-1.5>",
  "    paren_string_vec = paren_string.split()\n    paren_groups = []\n    curr_group\
    \ = []\n    paren_open = 0\n    for paren_char in paren_string_vec\n        if\
    \ paren_char == '('\n            paren_open += 1\n        else if paren_char ==\
    \ ')'\n            paren_open -= 1\n            if paren_open == 0\n         \
    \       paren_groups.append(curr_group)\n                curr_group = []\n   \
    \     else\n            curr_group.append(paren_char)\n    return paren_groups\n\
    \"\"\"\n### 3. Write a function `is_balanced()` that tests whether the given string\
    \ satisfies our custom rules.\n    \n    Write a function that takes one string\
    \ as a parameter and\n    returns a boolean indicating whether the string satisfies\
    \ our custom rules\n    (balanced strings and parentheses matching).\n    >>>\
    \ is_balanced(\"()()()\")\n    True\n    >>> is_balanced(\"((())\")\n    True\n\
    \    >>> is_balanced(\"(())(())\")\n    True\n    >>> is_balanced(\"()(()())\"\
    )\n    True\n    >>> is_balanced(\"()()\")\n    False\n    >>> is_balanced(\"\
    (()())\")\n    False\n    >>> is_balanced(\"()\")\n    False\n    >>> is_balanced(\"\
    )\")\n    False\n    >>> is_balanced(\"((()))\")\n    False\n    \"\"\"", '    #
    Fill this in', "    paren_string = replace(paren_string, \" \", \"\");\n    paren_string\
    \ = paren_string.replace(\"(\", \"\");\n    paren_string = paren_string.replace(\"\
    )\", \"\");\n    paren_string = paren_string.replace(\"{\", \"\");\n    paren_string\
    \ = paren_string.replace(\"}\", \"\");\n    paren_string = paren_string.replace(\"\
    [\", \"\");\n    paren_string = paren_string.replace(\"]\", \"\");\n    paren_string\
    \ = paren_string.replace(\"{\", \"\");\n    paren_string = paren_string.replace(\"\
    }\", \"\");\n    paren_string = paren_string.replace(\"[\", \"\");\n    paren_string\
    \ = paren_string.replace(\"]\", \"\");\n    paren_string = paren_string.replace(\"\
    (\", \"\");\n    paren_string = paren_string.replace(\")\", \"\");\n    return\
    \ paren_string\nend", "    paren_string = paren_string.strip(\"()\")\n    paren_stack\
    \ = []\n    paren_groups = []\n    stack_size = 0", "    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren", "    paren_string = replace(paren_string, \" \", \"\") \n    stack::Vector{String}\
    \ \n    stack = Vector{String}()\n    paren_count = 0\n    paren_index = 0\n \
    \   paren_groups = Vector{String}()\n    \n    open_braces = findall(r\"[\\(\\\
    []\", paren_string)\n    close_braces = findall(r\"[\\)\\]]\", paren_string)",
  "    paren_string = remove_spaces(paren_string)\n    return paren_string.split(\"\
    \ (?=\\\\()\")\nend", "    group_str = paren_string\n    paren_groups = []\n \
    \   paren_start = 0\n    paren_end = 0\n    while !isempty(group_str) && paren_start\
    \ < length(group_str)\n        paren_end = find(group_str, \"(\", paren_start)\n\
    \        if paren_end != paren_start\n            paren_groups[paren_start+1:paren_end]\
    \ = group_str[paren_start+1 : paren_end]\n            group_str = group_str[paren_end\
    \ + 1 :]\n        end\n        paren_start = paren_end\n    end\n    paren_groups[paren_start+1:end]\
    \ = group_str[paren_start+1:end]\n    return paren_groups\nend \"\"\"\n    \n\"\
    \"\" Return a string consisting of the strings in parenthesis concatenated, separated\
    \ by spaces. \n    >>> concat_paren_groups(\"()()()\")\n    \"()()()\"\n    \"\
    \"\"", "    paren_string = paren_string.strip(\"( )\")\n    paren_string = paren_string.gsub(\"\
    ( )\",\"\")\n    paren_string = paren_string.gsub(\")\",\"\")\n    paren_string\
    \ = paren_string.gsub(\"(\",\"\\\"\")\n    paren_string = paren_string.gsub(\"\
    )\",\"\")\n    paren_string = paren_string.gsub(\",\",\"\")\n    paren_string\
    \ = paren_string.gsub(\"\\\"\",\"\")\n    paren_string = paren_string.gsub(\"\
    ;\",\"\")\n    paren_string = paren_string.gsub(\"\\\\\",\"\")\n    paren_string\
    \ = paren_string.gsub(\":\",\"\")\n    paren_string = paren_string.gsub(\"!\"\
    ,\"\")\n    paren_string = paren_string.gsub(\"?\",\"\")\n    paren_string = paren_string.gsub(\"\
    !\",\"\")\n    paren_string = paren_string.gsub(\")\",\"\")\n    paren_string\
    \ = paren_string.gsub(\"(\",\"\\\"\")\n    paren_string = paren_string.gsub(\"\
    =\",\"\")\n    paren_string = paren_string.gsub(\",\",\"\")\n    paren_string\
    \ = paren_string.gsub(\"\\\\\",\"\")\n    paren_string = paren_string.gsub(\"\
    (\",\"\")\n    paren_string = paren_string.gsub(\")\",\"\")\n    paren_string\
    \ = paren_string.gsub(\"\\n\",\"\")\n    paren_string = paren_string.gsub(\"\\\
    r\",\"\")\n    paren_string = paren_string.gsub(\"\\t\",\"\")\n    paren_string\
    \ = paren_string.gsub(\"\\\"\",\"\")\n    paren_string = paren_string.gsub(\"\
    ;\",\"\")\n    paren_string = paren_string.gsub(\"\\\\\",\"\")\n    paren_string\
    \ = paren_string.gsub(\":\",\"\")\n    paren_string = paren_string.gsub(\"!\"\
    ,\"\")\n    paren_string = paren_string.gsub(\"?\",\"\")\n    paren_string = paren_string.gsub(\"\
    !\",\"\")\n    paren_string = paren_string.gsub(\")\",\"\")\n    paren_string\
    \ = paren_string.gsub(\"(\",\"\\\"\")\n    paren_string = paren_string.gsub(\"\
    =\",\"\")\n    paren_string = paren_string.gsub(\",\",\"\")\n    paren_string\
    \ = paren_string.gsub(\"\\\\\",\"\")\n    paren_string = paren_string.gsub(\"\
    (\",\"\")\n    paren_string = paren_string.gsub(\")\",\"\")\n    paren_string\
    \ = paren_string.gsub(\"\\n\",\"\")\n    paren_string = paren_string.gsub(\"\\\
    r\",\"\")\n    paren_string = paren_string.gsub(\"\\t\",\"\")\n    paren_string\
    \ = paren_string.gsub(\"\\\"\",", "    if length(paren_string) == 0 then \n  \
    \      Vector{String}()\n    elseif paren_string[0] == '(' && paren_string[end]\
    \ == '('\n        separate_paren_groups(paren_string[end+1])\n    elseif paren_string[0]\
    \ == '(' && paren_string[end] == '['\n        separate_paren_groups(paren_string[end+1])\n\
    \    elseif paren_string[0] == '[' && paren_string[end] == ']'\n        separate_paren_groups(paren_string[end+1])\n\
    \    elseif paren_string[0] == '[' && paren_string[end] == '{'\n        separate_paren_groups(paren_string[end+1])\n\
    \    else\n        paren_string.split(' ')\n    end\nend\n</code>\n<|/ a tags=string,julia\
    \ dscore=2 |>\n<| a |>\nThis is my version with regex and Strings instead of Vectors\
    \ because I'm too lazy to convert back and forth. Maybe someone finds something\
    \ more elegant.\n<code>", "    paren_string = paren_string.trim() # Trim off whitespace\n\
    \    paren_string = paren_string.strip(\"( )\")  # Remove leading and trailing\
    \ parens\n    return paren_string.split(\" (?=[()]*(?:\\1)*$)\") # Split the parens\
    \ into separate groups", "    paren_string = paren_string.replace(\" \", \"\"\
    )\n    paren_string = paren_string.replace(\"\\n\", \"\")\n    paren_string =\
    \ paren_string.replace(\"\\t\", \"\")\n    paren_string = paren_string.replace(\"\
    (\", \"\")\n    paren_string = paren_string.replace(\")\", \"\")\n    paren_string\
    \ = paren_string.split(\")\")\n    paren_string = paren_string[1]\n    paren_string\
    \ = paren_string.split(\"(\")\n    paren_string = paren_string[1]\n    paren_string\
    \ = paren_string.split(\"[\")\n    paren_string = paren_string[1]\n    paren_string\
    \ = paren_string.split(\"{\")\n    paren_string = paren_string[1]\n    return\
    \ paren_string\nend", "    paren_string_split = split(paren_string, \" \") # Split\
    \ into an array of strings based on whitespace\n    paren_group_array = [\"\"\
    ]\n    for paren_split in paren_string_split # Go through each of the strings\
    \ in paren_string_split\n        for ii in paren_split # Go through each char\n\
    \            if paren_split[paren_split.size - 1] == \")\" # If the last char\
    \ in the string is a right paren then we're at the end of the group\n        \
    \        paren_group_array.append(paren_group_array[-1]) # Append the group onto\
    \ the array of groups\n            else # Otherwise, if we aren't at the end of\
    \ the group\n                paren_group_array.append(paren_split[ii]) # Append\
    \ the current char to the group\n            end\n        end\n    end\n    return\
    \ paren_group_array\nend\n</cell>\n<code language=julia-1.5>\n# Test your function\n\
    separate_paren_groups(\"( ) (( )) (( )( ))\")\n</cell>\n<text>\nExpected Output:",
  "    paren_string_split = split(paren_string, \" \")\n    paren_string_split = [i\
    \ for i in paren_string_split if i != \"(\" and i != \")\"]\n    return paren_string_split\n\
    </code>\n<|/ a dscore=2 tags=string,julia |>\n<| a |>\nA variation of's answer\
    \ that doesn't require a recursive definition and uses isoperator() for character\
    \ matching:\n<code>", "    paren_string = paren_string.strip()\n    paren_string\
    \ = replace(paren_string, \" \\(.*\\) \", \"\")\n    paren_string = replace(paren_string,\
    \ \"\\(.*\\) \", \"\")\n    paren_string = replace(paren_string, \"\\(.*\\)\"\
    , \"\")\n    paren_string = replace(paren_string, \" \\(.*\\)\", \"\")\n    paren_string\
    \ = replace(paren_string, \" \\(.*\\) \", \"\")\n    paren_string = replace(paren_string,\
    \ \"\\(.*\\)\", \"\")\n    paren_string = replace(paren_string, \" \", \"\")\n\
    \    paren_string = replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \" \", \"\")\n    paren_string = replace(paren_string, \"(\", \"\")\n    paren_string\
    \ = replace(paren_string, \"[\", \"\")\n    paren_string = replace(paren_string,\
    \ \"]\", \"\")\n    paren_string = replace(paren_string, \"{\", \"\")\n    paren_string\
    \ = replace(paren_string, \"}\", \"\")\n    paren_string = replace(paren_string,\
    \ \"{\", \"\")\n    paren_string = replace(paren_string, \"[\", \"\")\n    paren_string\
    \ = replace(paren_string, \"]\", \"\")\n    paren_string = replace(paren_string,\
    \ \"}\", \"\")\n    paren_string = replace(paren_string, \"\", \".\")\n    paren_string\
    \ = replace(paren_string, \":\", \":\")\n    paren_string = replace(paren_string,\
    \ \" \", \"\")\n    paren_string = replace(paren_string, \".\", \"\")\n    paren_string\
    \ = replace(paren_string, \";\", \"\")\n    paren_string = replace(paren_string,\
    \ \"?\", \"\")\n    paren_string = replace(paren_string, \"!\", \"\")\n    paren_string\
    \ = replace(paren_string, \",\", \"\")\n    paren_string = replace(paren_string,\
    \ \"|\", \"\")\n    paren_string = replace(paren_string, \"&\", \"\")\n    paren_string\
    \ = replace(paren_string, \"+\", \"\")\n    paren_string = replace(paren_string,\
    \ \"-\", \"\")\n    paren_string = replace(paren_string, \"\\(\", \"(\")\n   \
    \ paren_string = replace(paren_string, \"\\)\", \")\")\n    paren_string = replace(paren_string,\
    \ \"\\*\", \"*\")\n    paren_string = replace(paren_string, \"\\|\", \"|\")\n\
    \    paren_string = replace(paren_string, \"\\&\", \"&\")\n    paren_string =\
    \ replace(paren_string, \"\\?\", \"?\")\n    paren_string = replace(paren_string,\
    \ \"\\!\", \"!\")\n    paren_string = replace(paren_string, \"\\:\", \":\")\n\
    \    paren_string = replace(paren_string, \"\\)\", \"(\")\n    paren_string =\
    \ replace(paren_string, \"\\(\", \"(\")\n    paren_string = replace(paren_string,\
    \ \"\\)\", \")\")", '    paren_string = normalizeString(paren_string)', "    paren_string\
    \ = strip(paren_string)\n    if paren_string==\"()\" or paren_string==\"(()\"\
    )\n        return paren_string\n    paren_string = replaceall(paren_string, \"\
    ( {2,}\", \"((\")\n    paren_string = replaceall(paren_string, \") }\", \"))\"\
    )\n    paren_string = strip(paren_string)\n    if paren_string==\"()\" or paren_string==\"\
    (()\"\n        return paren_string\n    paren_string = replaceall(paren_string,\
    \ \"( {2,}\", \"((\")\n    paren_string = replaceall(paren_string, \") }\", \"\
    ))\")\n    paren_string = strip(paren_string)\n    if paren_string==\"()\" or\
    \ paren_string==\"(()\"\n        return paren_string\n    paren_string = replaceall(paren_string,\
    \ \"( {2,}\", \"((\")\n    paren_string = replaceall(paren_string, \") }\", \"\
    ))\")\n    paren_string = strip(paren_string)\n    if paren_string==\"()\" or\
    \ paren_string==\"(()\"\n        return paren_string\n    paren_string = replaceall(paren_string,\
    \ \"( {2,}\", \"((\")\n    paren_string = replaceall(paren_string, \") }\", \"\
    ))\")\n    paren_string = strip(paren_string)\n    return paren_string\nend\n\
    </code>\nThe above function can then be used in your function like this:\n<code>",
  "    #Create an empty vector to store the return values\n    separated_strings =\
    \ Vector{String}()\n    open_braces_encountered = Vector{String}()", "\"\"\"\n\
    Input to this function is a string containing multiple groups of nested parentheses.\
    \ Your goal is to\n    separate those group into separate strings and return the\
    \ vector of those.\n    Separate groups are balanced (each open brace is properly\
    \ closed) and not nested within each other\n    Ignore any spaces in the input\
    \ string.\n\"\"\"\n    return split(paren_string, \"( )\")", "    \"\"\"\n   \
    \ Separate groups of nested parentheses into separate strings and return the vector\
    \ of those.\n    Separate groups are balanced (each open brace is properly closed)\
    \ and not nested within each other\n    Ignore any spaces in the input string.\n\
    \    \"\"\"\n    paren_string = paren_string.replace(\" \", \"\")\n    paren_string\
    \ = paren_string.replace(\"\\n\", \"\")\n    paren_string = paren_string.replace(\"\
    \\t\", \"\")\n    paren_string = paren_string.replace(\"(\", \"\")\n    paren_string\
    \ = paren_string.replace(\")\", \"\")\n    paren_string = paren_string.replace(\"\
    {\", \"\")\n    paren_string = paren_string.replace(\"}\", \"\")\n    paren_string\
    \ = paren_string.replace(\",\", \"\")\n    paren_string = paren_string.replace(\"\
    ;\", \"\")\n    paren_string = paren_string.replace(\"\\\\\", \"\")\n    paren_string\
    \ = paren_string.replace(\">\", \"\")\n    paren_string = paren_string.replace(\"\
    <\", \"\")\n    paren_string = paren_string.replace(\"^\", \"\")\n    paren_string\
    \ = paren_string.replace(\"'\", \"\")\n    paren_string = paren_string.replace(\"\
    !\", \"\")\n    paren_string = paren_string.replace(\"*\", \"\")\n    paren_string\
    \ = paren_string.replace(\"?\", \"\")\n    paren_string = paren_string.replace(\"\
    .\", \"\")\n    paren_string = paren_string.replace(\"*\", \"\")\n    paren_string\
    \ = paren_string.replace(\"+\", \"\")\n    paren_string = paren_string.replace(\"\
    -\", \"\")\n    paren_string = paren_string.replace(\"=\", \"\")\n    paren_string\
    \ = paren_string.replace(\"<\", \"\")\n    paren_string = paren_string.replace(\"\
    >\", \"\")\n    paren_string = paren_string.replace(\"!\", \"\")\n    paren_string\
    \ = paren_string.replace(\"'\", \"\")\n    paren_string = paren_string.replace(\"\
    \\\\\", \"\")\n    paren_string = paren_string.replace(\"~\", \"\")\n    paren_string\
    \ = paren_string.replace(\"|\", \"\")\n    paren_string = paren_string.replace(\"\
    $\", \"\")\n    paren_string = paren_string.replace(\"[\", \"\")\n    paren_string\
    \ = paren_string.replace(\"]\", \"\")\n    paren_string = paren_string.replace(\"\
    ?\", \"\")\n    paren_string = paren_string.replace(\"<\", \"\")\n    paren_string\
    \ = paren_string.replace(\">\", \"\")\n    paren_string = paren_string.replace(\"\
    _\", \"\")\n    paren_string = paren_string.replace(\"!\", \"\")\n    paren_string\
    \ = paren_string.replace(\"&\", \"\")\n    paren_string = paren_string.replace(\"\
    *\", \"\")\n    paren_string = paren_string.replace(\"+\", \"\")\n    paren_string\
    \ = paren_string.replace(\"?\", \"\")\n    paren_string = paren_string.replace(\"\
    .\", \"\")\n    paren_string = paren_string.replace(\":\", \"\")\n    paren_string\
    \ = paren_string.replace(\"=\", \"\")\n    paren_string = paren_string.replace(\"\
    ;\", \"\")\n    paren_string = paren_string.replace(\"{\", \"\")\n    ", "   \
    \ if length(paren_string) == 0 then return Vector{String}() end\n    \n    paren_string\
    \ = split(paren_string, \" \")\n    \n    paren_string = map(x -> join(paren_string,\
    \ x), paren_string)\n    \n    paren_string = join(paren_string, \" \")\n    \n\
    \    paren_string = replace(paren_string, r\"\\s\", \" \")\n    \n    return paren_string\n\
    end\n</cell>\n<text>\nThis implementation does not consider escaped parentheses.\
    \ For example, \"()\" is not considered a nested group.", "    stack = Vector{String}(undef,0)\n\
    \    paren_string_splits = split(paren_string,\" \") #remove whitespace from split",
  "    return paren_string.scan(paren_pattern)\nend\n</cell>\n<text>\nTest out your\
    \ code by seeing what happens to your string when it's passed through the function.\
    \ Do you get the output you expect?", "    \n    if paren_string == \"\" \n  \
    \      return Vector{String}()", "    separate_groups = Vector{String}()\n   \
    \ parens = Vector{String}()\n    \n    current_parens = Vector{String}()\n   \
    \ \n    for (index, paren) in enumerate(paren_string)\n        if paren == \"\
    (\"\n            current_parens = parens\n            parens = Vector{String}()\n\
    \        else\n            parens = parens ++ current_parens\n        end\n  \
    \  end\n    separate_groups = parens\n    return separate_groups\nend", "    open_parens,\
    \ closed_parens = paren_string.split(\" \"), \"\"\n    paren_vec = [paren_string]\n\
    \    \n    for i in open_parens\n        if i == \")\"\n            paren_vec[end]\
    \ = paren_vec[end - 1]\n            paren_vec[end - 1] = \"\"\n        else \n\
    \            paren_vec[end] = paren_vec[end - 1]\n        end\n    end\n    paren_vec\n\
    end\n</cell>\n<code language=julia-1.5>\nseparate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n</cell>\n<text>\nExercise: Write a function that splits a string into\
    \ words. If the input string contains punctuation, \n    then assume that it is\
    \ part of a single word.", "    paren_string = paren_string.strip\n    stack =\
    \ Vector{String}()\n    current_paren = 0\n    pos = 0\n    while pos < length(paren_string)\n\
    \        if paren_string[pos] == '('\n            current_paren += 1\n       \
    \ elseif paren_string[pos] == ')'\n            current_paren -= 1\n          \
    \  stack[current_paren] = paren_string[pos]\n        elseif current_paren == 0\n\
    \            stack[current_paren] = paren_string[pos]\n        end\n        pos\
    \ = pos + 1\n    end\n    stack\nend\n</code>\nThe function returns a vector containing\
    \ the separate strings (with or without parenthesis) of any nested groups of parentheses.\
    \ I tested it with the following test case:\n<code>\nseparate_paren_groups(\"\
    ( ) (( )) (( )( ))\")\n</code>\nand it returned the following vector:\n<code>\n\
    [\"()\", \"(())\", \"(()())\"]\n</code>\n<|/ a tags=string,julia dscore=2 |>\n\
    <| a |>\nUsing regular expressions:\n<code>", "    if paren_string.length() ==\
    \ 0\n        return Vector{String}() \n    \n    paren_string = paren_string.replace(\"\
    (\",\"\").replace(\")\",\"\").replace(\"{\",\"\").replace(\"}\",\"\")", "    stack::Vector{String}\
    \ = []\n    paren_stack::Vector{String} = []\n    for ch in paren_string\n   \
    \     if ch == '('\n            push!(paren_stack, ch)\n            push!(stack,\
    \ \"\")\n        else if ch == ')'\n            if isempty(stack)\n          \
    \      throw(UnbalancedParensException())\n            elseif pop!(stack) == \"\
    \"\n                pop!(paren_stack)\n            elseif isempty(paren_stack)\n\
    \                throw(UnbalancedParensException())\n            else if pop!(paren_stack)\
    \ == \"\"\n                throw(UnbalancedParensException())\n            else\n\
    \                push!(paren_stack, pop!(stack))\n                push!(stack,\
    \ \"\")\n            end\n        else\n            push!(stack, ch)\n       \
    \ end\n    end\n    paren_string = join(paren_stack, \"\", \"\")\n    return paren_string\n\
    end", "    paren_string = replace(paren_string, \"  \", \" \")\n    paren_string\
    \ = replace(paren_string, \"( \", \"(\")\n    paren_string = replace(paren_string,\
    \ \" ) \", \")\")\n    paren_string = replace(paren_string, \" ) \", \")\")\n\
    \    paren_string = replace(paren_string, \"( \", \"(\")\n    paren_string = replace(paren_string,\
    \ \")( \", \"(\")\n    paren_string = replace(paren_string, \")( \", \")(\")\n\
    \    paren_string = replace(paren_string, \"( \", \")(\")\n    paren_string =\
    \ replace(paren_string, \"( \", \"(\")\n    paren_string = replace(paren_string,\
    \ \"( \", \"(\")\n    paren_string = replace(paren_string, \"( \", \"(\")\n  \
    \  paren_string = replace(paren_string, \"( \", \"(\")\n    paren_string = replace(paren_string,\
    \ \"( \", \"(\")\n    paren_string = replace(paren_string, \"( \", \"(\")\n  \
    \  paren_string = replace(paren_string, \"( \", \"(\")\n    paren_string = replace(paren_string,\
    \ \"( \", \"(\")\n    paren_string = replace(paren_string, \"( \", \"(\")\n  \
    \  paren_string = replace(paren_string, \"( \", \"(\")\n    paren_string = replace(paren_string,\
    \ \"( \", \"(\")\n    paren_string = replace(paren_string, \"( \", \"(\")\n  \
    \  paren_string = replace(paren_string, \"( \", \"(\")\n    paren_string = replace(paren_string,\
    \ \"( \", \"(\")\n    paren_string = replace(paren_string, \"( \", \"(\")\n  \
    \  paren_string = replace(paren_string, \"( \", \"(\")\n    paren_string = replace(paren_string,\
    \ \"( \", \"(\")\n    paren_string = replace(paren_string, \"( \", \"(\")\n  \
    \  paren_string = replace(paren_string, \"( \", \"(\")\n    paren_string = replace(paren_string,\
    \ \"( \", \"(\")\n    paren_string = replace(paren_string, \"( \", \"(\")\n  \
    \  paren_string = replace(paren_string, \"( \", \"(\")\n    paren_string = replace(paren_string,\
    \ \"( \", \"(\")\n    paren_string = replace(paren_string, \"( \", \"(\")\n  \
    \  paren_string = replace(paren_string, \"( \", \"(\")\n    paren_string = replace(paren_string,\
    \ \"( \", \"(\")\n    paren_string = replace(paren_string, \"( \", \"(\")\n  \
    \  paren_string = replace(paren_string, \"( \", \"(\")\n    paren_string = replace(paren_string,\
    \ \"( \", \"(\")\n    paren_string = replace(paren_string, \"( \", \"(\")\n  \
    \  paren_string = replace(paren_string, \"( \", \"(\")\n", "    strings = split(paren_string,\"\
    \ \");\n    vec_of_strings = Vector{String}()\n    \n    for string in strings\n\
    \        push!(vec_of_strings, string)\n    end", "    \"\"\"\n    A function\
    \ designed to separate groups of nested parenthesis and return a vector of those\
    \ groups. The input\n    to this function is a string containing multiple groups\
    \ of nested parentheses. Your goal is to separate those\n    group into separate\
    \ strings and return the vector of those. Separate groups are balanced (each open\
    \ brace\n    is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    \"\"\"\n    paren_string = paren_string.replace(\"\
    \ \", \"\") \n    paren_chars = Vector{Char}()\n    paren_open = paren_closed\
    \ = false\n    paren_groups = Vector{String}()", "    # Implement your function\
    \ here\nend\n</cell>\n<text>\nSection 3\nWrite a function to parse a mathematical\
    \ expression given as a String and returns an appropriate expression for the given\
    \ expression type. If the expression type is not supported return \"Not supported\
    \ type\" or the equivalent in any string representation.", "    paren_string ==\
    \ \"\" ?\n        Vector{String}([]) :\n        paren_string.split(r\"\\(\\)\"\
    )\nend\n</cell>\n<text>\nAs a bonus, here's a function that takes care of removing\
    \ unwanted punctuation from the input. Given a string, this function returns a\
    \ string where any occurrences of punctuation are removed. You may have noticed\
    \ that the string \"don't\" has been changed to \"don\".", "    stack = Vector{String}()\n\
    \    paren_groups = Vector{String}()\n    \n    push!(stack, paren_string)\n \
    \   \n    while length(stack) > 0\n        paren_string = stack[end]\n       \
    \ if isempty(paren_string) then return paren_groups; end\n        \n        #\
    \ Find all opening parens \n        if paren_string[1] == \" \" then continue\n\
    \        if paren_string[1] == \"(\" then push!(stack, paren_string[2:end]); continue\n\
    \        if paren_string[1] == \"(\" then paren_groups = paren_groups + [paren_string[1:end]];\n\
    \        \n        # Find all closing parens\n        if paren_string[end] ==\
    \ \"(\" then push!(stack, paren_string[1:end-1]); continue\n        if paren_string[end]\
    \ == \"(\" then paren_groups = paren_groups + [paren_string[1:end-1]];\n     \
    \   \n        # Find all unbalanced parens\n        if paren_string[end] == \"\
    )\" && (paren_string[end - 1] == \" \" || paren_string[end - 1] == \"(\" ||\n\
    \           paren_string[end - 1] == \")\") then continue\n        if paren_string[end]\
    \ == \"(\" && paren_string[end - 1] == \")\" then paren_groups = paren_groups\
    \ + [paren_string[1:end]];\n        \n        # Remove stacked parens and repeat\
    \ search with new stack\n        pop!(stack)\n    end\n    return paren_groups\n\
    end\n</cell>\n<code language=julia-1.5>\n# tests\nseparate_paren_groups(\"( )\
    \ (( )) (( )( ))\")\nseparate_paren_groups(\"( ( ) ( ) )\")\nseparate_paren_groups(\"\
    (((()))))\")\nseparate_paren_groups(\"(()((()(()\")))\nseparate_paren_groups(\"\
    ()()(())(()\")\n</cell>\n<text>\nGroup Strings II\nYou will now implement a function\
    \ that will take a vector of strings and return a vector of strings where all\
    \ parenthesized expressions are replaced by the strings enclosed by parentheses.\
    \ The strings within the vector should be separated by spaces.", "    # Split\
    \ the string and put it in a vector \n    # of Strings\n    string_array = split(paren_string,\
    \ \" \") \n    string_array = string_array[findall(x->length(x)>0,string_array)]\n\
    \    # Split each String in the string_array into a vector\n    array_of_strings\
    \ = string_array.map(split)\n    # Return an array of groups of Strings\n    return\
    \ array_of_strings\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\nInput to\
    \ this function is a string containing multiple groups of nested parentheses.\
    \ Your goal is to\n    separate those group into separate strings and return the\
    \ vector of those.\n    Separate groups are balanced (each open brace is properly\
    \ closed) and not nested within each other\n    Ignore any spaces in the input\
    \ string.\n    >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\"\
    , \"(())\", \"(()())\"]\n    \"\"\"", "    #input is a string, we need to convert\
    \ it to a vector of strings\n    #split the string into its parts, starting from\
    \ index 1 to avoid the opening parens\n    #split the string into groups of balanced\
    \ parens with an opening brace and closing brace\n    #append the groups to a\
    \ list\n    #convert the list to a vector", "    # Your code here\nend", "   \
    \ paren_string = paren_string.strip\n    if paren_string == \"\"\n        return\
    \ Vector{String}()\n    end", "    return paren_string.split(\" \").map(x => paren_group(x)).filter(x\
    \ => !isempty(x))\nend", "    #import Base.unsafe_wrap\n    #import Base.Base.unsafe_wrap\n\
    \    #import Base.unsafe_convert\n    #import Base.convert\n    paren_groups =\
    \ unsafe_wrap(::Type{Array{String,1}},\n        Base.unsafe_convert(::Type{Array{String,1}},paren_string)\n\
    \    )\n    paren_groups = convert(::Type{Array{String,1}},paren_groups)\n   \
    \ return paren_groups\nend\n</cell>\n<text>\nExercise 1\nWrite a function that\
    \ takes one parameter: string and returns a vector with all the unique words in\
    \ the string\nwithout spaces or punctuation\nTest your function on the string\
    \ \"Hello! World!\"", "    paren_string = strip(paren_string) \n    if length(paren_string)\
    \ == 0 \n        throw(ArgumentError(\"The string passed is empty.\"))\n    end\n\
    \    brackets = findall(paren_string, \"[]\")\n    open_curly_brackets = findall(regexp(\"\
    ([{]?)\", paren_string), :all)\n    close_curly_brackets = findall(regexp(\"([}])?\"\
    , paren_string), :all)\n    open_paren_brackets = findall(regexp(\"([(]?)\", paren_string),\
    \ :all)\n    close_paren_brackets = findall(regexp(\"([)]?\", paren_string), :all)",
  "    paren_string=strip(paren_string)\n    paren_string=strip(paren_string,\" \"\
    )\n    groups = split(paren_string, \" \")\n    if paren_string.length == 0 ||\
    \ paren_string==\" \"\n        return Vector{String}()\n    end\n    \n    \n\
    \    if paren_string[0]==\"(\" && paren_string[paren_string.length-1]==\")\"\n\
    \        \n        left_parens = separate_paren_groups(paren_string[1:(paren_string.length-1)])\n\
    \        right_parens = separate_paren_groups(paren_string[(paren_string.length+1):end])\n\
    \    end\n    \n    \n    return left_parens + groups + right_parens\nend\n</cell>\n\
    <code language=julia-1.5>\n#=\nSeparate parentheses groups into strings and return\
    \ them as a vector\n=#", "    sep_str = \"\"\n    paren_count = 0\n    for c in\
    \ paren_string\n        if c == \" \" && paren_count == 0 \n            sep_str\
    \ += c\n        elseif c == \"(\" \n            paren_count += 1\n        elseif\
    \ c == \")\"\n            paren_count -= 1\n            if paren_count <= 0 \n\
    \                sep_str += c\n            end\n        end\n    end\n    if paren_count\
    \ > 0\n        push!(sep_str, \")\")\n    end\n    sep_str\nend\n</code>\n<|/\
    \ a tags=julia,nested-loops,for-loop |>\n<| c |>\nI like how you solved this with\
    \ minimal lines of code (and I like that it also works with non-nested groups).\n\
    <|/ c |>\n<| a dscore=4 tags=julia,nested-loops,for-loop |>\nHere's an efficient\
    \ way that works with nested groups too:\n<code>", "    stack = Vector{String}()\n\
    \    paren_string = paren_string.strip() # Remove leading and trailing whitespace\n\
    \    for char in paren_string\n        if char == '('\n            push!(stack,\
    \ char)\n        elseif char == ')'\n            if isempty(stack)\n         \
    \       push!(stack, '()')\n            else\n                stack.pop\n    \
    \        end\n        elseif char == ' '\n            continue\n        else\n\
    \            error(\"Input string contains invalid character\")\n        end\n\
    \    end\n    return stack\nend\n</cell>\n<code language=julia-1.6>\n@assert separate_paren_groups(\"\
    ( ( ) ( ) ) \")\n@assert separate_paren_groups(\"( ) ( ) ( )\" )\n@assert separate_paren_groups(\"\
    ( ) ( ) ( )\")\n@assert separate_paren_groups(\"( ) ( ) ( )()\")\n@assert separate_paren_groups(\"\
    ( ) ( ) ( )()( )( )( )\")\n@assert separate_paren_groups(\"( ) ( ) ( )()( )( )(\
    \ )( )( )( )\")\n@assert separate_paren_groups(\"( ) ( ) ( )()( )( )( )( )( )(\
    \ )( )( )( )\")\n@assert separate_paren_groups(\"( ) ( ) ( )()( )( )( )( )( )(\
    \ )( )( )( )( )( )( )( )( )\")\n@assert separate_paren_groups(\"( ) ( ) ( )()(\
    \ )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )(\
    \ )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )(\
    \ )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )(\
    \ )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )", "    strings = split(paren_string,\
    \ \"( *\\\\( *)\")\n    paren_strings = []\n    for s in strings\n        push!(paren_strings,\
    \ s)\n    end\n    return paren_strings", "    if paren_string=='' return [] \n\
    \    stack = Vector{String}()\n    paren_groups = []\n    paren_strings = paren_string.split('\
    \ ') \n    for paren_string in paren_strings \n        push!(stack, paren_string)\n\
    \        while length(stack)>0 \n            paren_string = pop!(stack)\n    \
    \        push!(stack, paren_string)\n            if paren_string=='{' \n     \
    \           paren_groups[end] = paren_string\n                paren_groups[end+1]\
    \ = ''\n            elseif paren_string=='(' \n                push!(stack, paren_string)\n\
    \            elseif paren_string==')' \n                if length(stack)>0 \n\
    \                    paren_string = pop!(stack)\n                end\n       \
    \         push!(stack, paren_string)\n            end\n        end\n    end\n\
    \    return paren_groups \nend\n</code>\n<|/ a |>\n<| c |>\nThank you very much\
    \ for this great answer - it worked for me! However, I noticed that I had an extra\
    \ parenthesis (') at the end that I did not notice and fixed it by adding the\
    \ following to the end of the code: ```paren_groups[end+1] = '' ```\n<|/ c |>\n\
    <| a |>\nHere is a more general solution:\n<code>", "    # Initialize an empty\
    \ vector of Strings\n    bracket_groups = Vector{String}()\n    brackets = 0\n\
    \    bracket_count = 0\n    parens = 0\n    for character in paren_string\n  \
    \      # Keep track of what brackets have yet to be closed\n        if character\
    \ == \"(\"\n            parens += 1\n        else\n            parens -= 1\n \
    \           # Keep track of what brackets are currently open\n            if parens\
    \ == 0\n                bracket_count += 1\n                bracket_groups <<\
    \ (bracket_count > 0 ? \"(\" : \")\")\n            else\n                # Close\
    \ the open bracket if it is closed correctly\n                if bracket_count\
    \ == 1\n                    bracket_count -= 1\n                    brackets -=\
    \ 1\n                    if brackets == 0\n                        bracket_groups\
    \ << (bracket_count > 0 ? \")\" : \")\")\n                    else\n         \
    \               bracket_groups << \")\"\n                end\n            end\n\
    \        end\n    end\n    return bracket_groups\nend", "    stack::Vector{Vector{String}}\
    \ = Stack()\n    paren_string_without_spaces = remove_spaces(paren_string)\n \
    \   paren_string_without_spaces = remove_paren(paren_string_without_spaces)\n\
    \    push!(stack, paren_string_without_spaces)\n    until length(stack) == 0 do\n\
    \        cur_string =  pop!(stack)\n        push!(stack, remove_spaces(cur_string))\n\
    \        push!(stack, remove_paren(cur_string))\n    end\n    return_vec = Vector{String}(stack)\n\
    \    return return_vec\nend", "    paren_string = paren_string.replace(\" \",\
    \ \"\")\n    paren_string = paren_string.replace(\" \", \"\")\n    paren_string\
    \ = paren_string.replace(\"(\", \"\\\\(\")\n    paren_string = paren_string.replace(\"\
    )\", \"\\\\)\")\n    paren_string = paren_string.replace(\",\", \"\\\\,\")\n \
    \   paren_string = paren_string.replace(\"{\", \"\\\\{\")\n    paren_string =\
    \ paren_string.replace(\"}\", \"\\\\}\")\n    paren_string = paren_string.replace(\"\
    [\", \"\\\\[\")\n    paren_string = paren_string.replace(\"]\", \"\\\\]\")\n \
    \   paren_string = paren_string.replace(\"{\", \"\\\\{\")\n    paren_string =\
    \ paren_string.replace(\"}\", \"\\\\}\")\n    paren_string = paren_string.replace(\"\
    :\", \"\\\\:\")\n    paren_string = paren_string.replace(\">\", \"\\\\>\")\n \
    \   paren_string = paren_string.replace(\"<\", \"\\\\<\")\n    paren_string =\
    \ paren_string.replace(\"=\", \"\\\\=\")\n    paren_string = paren_string.replace(\"\
    ~\", \"\\\\~\")\n    paren_string = paren_string.replace(\"&\", \"\\\\&\")\n \
    \   paren_string = paren_string.replace(\"#\", \"\\\\#\")\n    paren_string =\
    \ paren_string.replace(\"@\", \"\\\\@\")\n    paren_string = paren_string.replace(\"\
    |\", \"\\\\|\")\n    paren_string = paren_string.replace(\"~\", \"\\\\~\")\n \
    \   paren_string = paren_string.replace(\"!\", \"\\\\!\")\n    paren_string =\
    \ paren_string.replace(\"?\", \"\\\\?\")\n    paren_string = paren_string.replace(\"\
    *\", \"\\\\*\")\n    paren_string = paren_string.replace(\"-\", \"\\\\-\")\n \
    \   paren_string = paren_string.replace(\"_\", \"\\\\_\")\n    paren_string =\
    \ paren_string.replace(\"%\", \"\\\\%\")\n    paren_string = paren_string.replace(\"\
    $\", \"\\\\$\")\n    paren_string = paren_string.replace(\"@\", \"\\\\@\")\n \
    \   paren_string = paren_string.replace(\"{\", \"\\\\{\")\n    paren_string =\
    \ paren_string.replace(\"}\", \"\\\\}\")\n    paren_string = paren_string.replace(\"\
    [\", \"\\\\[\")\n    paren_string = paren_string.replace(\"]\", \"\\\\]\")\n \
    \   paren_string = paren_string.replace(\"+\", \"\\\\+\")\n    paren_string =\
    \ paren_string.replace(\"=\", \"\\\\=\")\n    paren_string = paren_string.replace(\"\
    ^\", \"\\\\^\")\n    paren_string = paren_string.replace(\"~\", \"\\\\~\")\n \
    \   paren_string = paren_string.replace(\"|\", \"\\\\|\")\n    paren_string =\
    \ paren_string.replace(\"\\\\\", \"\\\\\\\\\")\n    paren_string = paren_string.replace(\"\
    \\\"\", \"\\\\\\\"\")\n    paren_string = paren_string.replace(\"\\n\", \"\\\\\
    n\")\n    paren_string = paren_string", "  paren_string = paren_string.trim()\n\
    \  paren_string = paren_string.strip(paren_string)\n  paren_string = paren_string.strip(\"\
    )\")\n  paren_string = paren_string.strip(\")\")\n  paren_string = paren_string.strip(\"\
    )\")\n  paren_string = paren_string.strip(\")\")\n  paren_string = paren_string.strip(\"\
    )\")\n  paren_string = paren_string.strip(\")\")\n  paren_string = paren_string.strip(\"\
    )\")\n  paren_string = paren_string.strip(\")\")\n  paren_string = paren_string.strip(\"\
    )\")\n  paren_string = paren_string.strip(\")\")\n  paren_string = paren_string.strip(\"\
    )\")\n  paren_string = paren_string.strip(\")\")\n  paren_string = paren_string.strip(\"\
    )\")\n  paren_string = paren_string.strip(\")\")\n  paren_string = paren_string.strip(\"\
    )\")\n  paren_string = paren_string.strip(\")\")\n  paren_string = paren_string.strip(\"\
    )\")\n  paren_string = paren_string.strip(\")\")\n  paren_string = paren_string.strip(\"\
    )\")\n  paren_string = paren_string.strip(\")\")\n  paren_string = paren_string.strip(\"\
    )\")\n  paren_string = paren_string.strip(\")\")\n  paren_string = paren_string.strip(\"\
    )\")\n  paren_string = paren_string.strip(\")\")\n  paren_string = paren_string.strip(\"\
    )\")\n  paren_string = paren_string.strip(\")\")\n  paren_string = paren_string.strip(\"\
    )\")\n  paren_string = paren_string.strip(\")\")\n  paren_string = paren_string.strip(\"\
    )\")\n  paren_string = paren_string.strip(\")\")\n  paren_string = paren_string.strip(\"\
    )\")\n  paren_string = paren_string.strip(\")\")\n  paren_string = paren_string.strip(\"\
    )\")\n  paren_string = paren_string.strip(\")\")\n  paren_string = paren_string.strip(\"\
    )\")\n  paren_string = paren_string.strip(\")\")\n  paren_string = paren_string.strip(\"\
    )\")\n  paren_string = paren_string.strip(\")\")\n  paren_string = paren_string.strip(\"\
    )\")\n  paren_string = paren_string.strip(\")\")\n  paren_string = paren_string.strip(\"\
    )\")\n  paren_string = paren_string.strip(\")\")\n  paren_string = paren_string.strip(\"\
    )\")\n  paren_string = paren_string.strip(\")\")\n  paren_string = paren", " \
    \   paren_string = paren_string.replace(\" \", \"\")\n    paren_string = paren_string.replace(\"\
    \\n\", \"\")\n    paren_string = paren_string.replace(\"\\r\", \"\")\n    paren_string\
    \ = paren_string.split(\"(\")\n    paren_string = paren_string[end-1:end]\n  \
    \  return paren_string\nend\n</cell>\n<code language=julia-0.5>", "    paren_groups\
    \ = paren_string.split(')')\n    parent_groups = Vector{String}()\n    for paren_group\
    \ in paren_groups\n        parent_group = paren_group.replace(' ', '')\n     \
    \   parent_groups .= parent_group\n    end\n    return parent_groups\nend", " \
    \   s = paren_string.split(\" \");\n    for i = 1:length(s)\n        if s[i] ==\
    \ \"(\" || s[i] == \")\"\n            push!(s, \"\")\n        elseif s[i] ~= \"\
    (\" && s[i] != \")\" && s[i] ~= \" \"\n            push!(s, \"(\" + s[i])\n  \
    \      end\n    end\n    return s\nend\n</cell>\n<code language=julia-1.5>\nseparate_paren_groups(\"\
    ( ) (( )) (( )( ))\")\n</cell>\n<code language=julia-1.5>", "    stack = Vector{String}()\n\
    \    paren_string.split(\" \").filter(n -> !isWhitespace(n)).foreach(n -> \n \
    \       if n != \")\"\n            if n !~ r\"^[)\\]\\}]+$\"\n               \
    \ push!(stack, paren_string.split(n))\n            else\n                if !stack[end-1]\
    \ == \")\"\n                    push!(stack, paren_string.split(n))\n        \
    \        else\n                    if stack[end-1] == \")\"\n                \
    \        push!(stack, paren_string.split(n))\n                    else\n     \
    \                   push!(stack, paren_string.split(n))\n                end\n\
    \            end\n        else\n            if !stack[end-1] == \")\"\n      \
    \          push!(stack, paren_string.split(n))\n            else\n           \
    \     if stack[end-1] == \")\"\n                    push!(stack, paren_string.split(n))\n\
    \                else\n                    push!(stack, paren_string.split(n))\n\
    \                end\n            end\n        end\n    )\n    return stack\n\
    end\n</cell>\n<text>\nThe solution code below will run a test on the function\
    \ you wrote and will report any errors.", "    \n    paren_groups = Vector{String}()\n\
    \    paren_string.split(\"\\\\(\\\\)\")\n    paren_string.split(\"\\\\(\\\\)\\\
    \\(\\\\)\") \n    paren_string.split(\"\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\\
    )\") \n    paren_string.split(\"\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\
    \\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\\
    (\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\
    \\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\\
    )\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\
    \\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\\
    (\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\
    \\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\\
    )\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\
    \\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\\
    (\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\
    \\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\\
    )\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\
    \\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\\
    (\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\
    \\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\\
    )\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\
    \\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\\
    (\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\
    \\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)", "    paren_string\
    \ = replace(paren_string, \"( )\", \" (\") \n    paren_string = replace(paren_string,\
    \ \"( )\", \" ()\") \n    paren_string = replace(paren_string, \"(  )(  \", \"\
    (())\") \n    paren_string = replace(paren_string, \"(  )(  \", \"(()())\") \n\
    \    paren_string = replace(paren_string, \"(  )(  \", \"(()()())\") \n    paren_string\
    \ = replace(paren_string, \"(  )(  \", \"(()()()\") \n    paren_string = replace(paren_string,\
    \ \"(  )(  \", \"(()()()()\") \n    paren_string = replace(paren_string, \"( \
    \ )(  \", \"(()()()()()\") \n    paren_string = replace(paren_string, \"(  )(\
    \  \", \"(()()()()()()\") \n    paren_string = replace(paren_string, \"(  )( \
    \ \", \"(()()()()()()()\") \n    paren_string = replace(paren_string, \"(  )(\
    \  \", \"(()()()()()()()\") \n    paren_string = replace(paren_string, \"(  )(\
    \  \", \"(()()()()()()()()\") \n    paren_string = replace(paren_string, \"( \
    \ )(  \", \"(()()()()()()()()()\") \n    paren_string = replace(paren_string,\
    \ \"(  )(  \", \"(()()()()()()()()()()\") \n    paren_string = replace(paren_string,\
    \ \"(  )(  \", \"(()()()()()()()()()()\") \n    paren_string = replace(paren_string,\
    \ \"(  )(  \", \"(()()()()()()()()()()()\") \n    paren_string = replace(paren_string,\
    \ \"(  )(  \", \"(()()()()()()()()()()()()\") \n    paren_string = replace(paren_string,\
    \ \"(  )(  \", \"(()()()()()()()()()()()()()\") \n    paren_string = replace(paren_string,\
    \ \"(  )(  \", \"(()()()()()()()()()()()()()\") \n    paren_string = replace(paren_string,\
    \ \"(  )(  \", \"(()()()()()()()()()()()()()\") \n    paren_string = replace(paren_string,\
    \ \"(  )(  \", \"(()()()()()()()()()()()()()()\") \n    paren_string = replace(paren_string,\
    \ \"(  )(  \", \"(()()()()()()()()()()()()()", "\"\"\"\n    Separate parenthesis\
    \ strings into separate string vectors and return a vector of those strings.\n\
    \    Separate groups are balanced (each open brace is properly closed) and do\
    \ not nest within each other\n    Ignore any spaces in the input string.\n   \
    \ >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"\
    (()())\"]\n\"\"\"\nend\n</cell>\n<code language=julia-1.0>\nseparate_paren_groups(\"\
    ( ) (( )) (( )( ))\")\n</cell>\n<text>\nPart 2: Finding Nested Parenthesis", " \
    \   paren_groups::Vector{String} = []\n    paren_string.replace(\" \", \"\") |>\
    \ StringTools.str_replace |> s -> \n        if s ~= \"\" then \n            paren_groups.push(s)\n\
    \            for paren_group in paren_groups[2:] do \n                paren_group.replace(\"\
    \ \", \"\") |> StringTools.str_replace |> s -> \n                    if s ~= \"\
    \" then \n                        paren_groups.push(s)\n                    end\n\
    \                end\n            end\n        end\n    end |> ignore\n    paren_groups\n\
    end\n</cell>\n<text>\n10.1 Task", "\"\"\"\n    Separates strings containing multiple\
    \ groups of nested parentheses into separate strings.\n    >>> separate_paren_groups(\"\
    ( ) ( )\")\n    [\"()\", \"()\"]\n    \"\"\"", "    \"\"\"\n    Separate parenthesized\
    \ strings into individual strings\n    \"\"\"\n    paren_string = paren_string.replace(\"\
    (\", \"\\((\")\n    paren_string = paren_string.replace(\")\", \"\\)\")\n    paren_string\
    \ = paren_string.replace(\"{\", \"\\{\")\n    paren_string = paren_string.replace(\"\
    }\", \"\\}\")\n    paren_string = paren_string.replace(\"<\", \"\\<\")\n    paren_string\
    \ = paren_string.replace(\">\", \"\\>\")", "    paren_string = replace(paren_string,\
    \ \" \", \"\")\n    paren_string = replace(paren_string, \"(\", \"\")\n    paren_string\
    \ = replace(paren_string, \")\", \"\")\n    return paren_string.split('()')\n\
    end", "    if paren_string == \"\" \n        return [] \n    opening_char = \"\
    {\"\n    closing_char = \"}\"\n    paren_stack = Vector{String}()\n    char_stack\
    \ = Vector{String}()\n    for i in paren_string\n        if i == opening_char\
    \ || i == closing_char \n            char_stack = []\n        elseif i == \")\"\
    \n            if char_stack == [] \n                paren_stack = []\n       \
    \     else \n                paren_stack = paren_stack[end-1] + char_stack[end]\n\
    \                char_stack = []\n        elseif i == \"(\" || i == \"[\"\n  \
    \          push!(paren_stack, i) \n        else\n            push!(char_stack,\
    \ i) \n        end\n    end\n    return paren_stack\nend\n</cell>\n<code language=julia-1.5>\n\
    separate_paren_groups(\"( ) (( )) (( )( ))\")\n</cell>\n<code language=julia-1.5>\n\
    # Input: a single string\n# Output: a vector containing all the words inside the\
    \ string\n# Note: empty strings \"\" and strings consisting of only whitespaces\
    \ are ignored", "    stack = [paren_string]\n    result = Vector{String}()\n \
    \   while !isempty(stack)\n        string_at_top = pop!(stack)\n        open_paren_positions\
    \ = findall(r\">\", string_at_top)\n        if open_paren_positions == []\n  \
    \          result = [string_at_top]\n        else\n            close_paren_positions\
    \ = findall(r\"<\", string_at_top)\n            for open_paren_position in open_paren_positions\n\
    \                if open_paren_position in close_paren_positions\n           \
    \         continue\n                paren_string = string_at_top[open_paren_position\
    \ : close_paren_positions[1] + 1]\n                if paren_string == \"()\"\n\
    \                    result = [paren_string]\n                    push!(stack,\
    \ paren_string)\n                else\n                    push!(stack, paren_string[1:close_paren_positions[1]\
    \ - 1])\n                end\n            end\n        end\n    end\n    return\
    \ result\nend\n</code>\n<|/ a |>\n<| a |>\nUsing regexp to capture groups and\
    \ iterating over them would probably be more efficient and simpler. \n<code>\n\
    import Base.Iterators\nimport Base.Iterators: Pairs\nimport Base.Iterators: Cartesian\n\
    import Base.Iterators: Flatten", "    \"\"\"\n    This function will take in a\
    \ string containing multiple groups of nested parentheses and separate them into\
    \ separate strings\n    Return a vector of those strings\n    Separate groups\
    \ are balanced (each open brace is properly closed) and not nested within each\
    \ other\n    Ignore any spaces in the input string.\n    \"\"\"", "</code>\n<|/\
    \ a |>\n<| c |>\nAh, I see. But what if you don't know how big the vector needs\
    \ to be in advance?\n<|/ c |>\n<| c |>\nThe last example shows the correct way\
    \ to use `fill` and `take`. It is a function that takes the initial size of an\
    \ array and returns a function that can return an array of the appropriate size\
    \ by calling `fill` with that size then calling `take` with the appropriate index.\n\
    <|/ c |>\n<| a |>\nUsing your example, this code will do what you want:\n<code>\n\
    let paren_string = \"( ( 1 )( 2 ) )\"\nlet res = String[]() // An empty vector\n\
    for i in paren_string.split(' ') do \n  push!(res, regexpr(i, r\"\\(.*\\)\"))\n\
    end\n</code>\n<|/ a dscore=0 tags=string,regex,julia |>\n<| a tags=string,regex,julia\
    \ |>\nHere's another way of doing it with regular expressions.\n<code>\njulia>\
    \ s = \"( ( 1 )( 2 ) )\"\n\"( ( 1 )( 2 ) )\"", "    paren_string.split(r\"\\)\"\
    )\nend", "    return split!(paren_string, r\"(?<=\\()|(?<=\\))\")\nend", "   \
    \ stack = [paren_string]\n    strings = Vector{String}()\n    while !isempty(stack)\n\
    \        str = pop!(stack)\n        if str == '('\n            push!(stack, ')')\n\
    \        elseif str == ')'\n            str = pop!(stack)\n            if str\
    \ == '('\n                push!(stack, ')')\n            else\n              \
    \  push!(stack, str)\n            end\n        else\n            push!(stack,\
    \ str)\n        end\n    end\n    strings\nend\n</cell>\n<code language=julia-1.0>",
  "    stack = Vector{String}()\n    paren_count = 0\n    paren_start_idx = 0\n  \
    \  current_string = paren_string\n    while(true)\n        if current_string ==\
    \ \"\"\n            push!(stack, (paren_start_idx, paren_count, current_string))\n\
    \            return stack\n        end\n        \n        if current_string==\"\
    )\"\n            if !is_balanced(stack, paren_count, paren_start_idx, paren_start_idx+length(current_string)-1)\n\
    \                push!(stack, (paren_start_idx, paren_count, current_string))\n\
    \                return stack\n            end\n            paren_count -= 1\n\
    \            current_string = stack[paren_count][2]\n            paren_start_idx\
    \ += length(current_string) + 1\n        else\n            if !is_balanced(stack,\
    \ paren_count, paren_start_idx, paren_start_idx+1)\n                push!(stack,\
    \ (paren_start_idx, paren_count, current_string))\n                return stack\n\
    \            end\n            paren_count += 1\n            current_string = stack[paren_count][1]\n\
    \            paren_start_idx += length(current_string) + 1\n        end\n    end\n\
    end", "    paren_string = paren_string.replace(\" \", \"\")\n    paren_string\
    \ = paren_string.replace(\" \", \"\")\n    paren_string = paren_string.replace(\"\
    ( )\", \"\")\n    paren_string = paren_string.replace(\"( )\", \"\")\n    paren_string\
    \ = paren_string.replace(\"( )\", \"\")\n    paren_string = paren_string.replace(\"\
    ((\", \"(\")\n    paren_string = paren_string.replace(\"((\", \"(\")\n    paren_string\
    \ = paren_string.replace(\"((\", \"(\")\n    paren_string = paren_string.replace(\"\
    ((\", \"(\")\n    paren_string = paren_string.replace(\"((\", \"(\")\n    paren_string\
    \ = paren_string.replace(\"()\", \"\")\n    paren_string = paren_string.replace(\"\
    ()\", \"\")\n    paren_string = paren_string.replace(\"()\", \"\")\n    paren_string\
    \ = paren_string.replace(\"()\", \"\")\n    paren_string = paren_string.replace(\"\
    ()\", \"\")\n    paren_string = paren_string.replace(\"()\", \"\")\n    paren_string\
    \ = paren_string.replace(\"()\", \"\")\n    paren_string = paren_string.replace(\"\
    ()\", \"\")\n    paren_string = paren_string.replace(\"()\", \"\")\n    paren_string\
    \ = paren_string.replace(\"()\", \"\")\n    paren_string = paren_string.replace(\"\
    ()\", \"\")\n    paren_string = paren_string.replace(\"()\", \"\")\n    paren_string\
    \ = paren_string.replace(\"()\", \"\")\n    paren_string = paren_string.replace(\"\
    ()\", \"\")\n    paren_string = paren_string.replace(\"()\", \"\")\n    paren_string\
    \ = paren_string.replace(\"()\", \"\")\n    paren_string = paren_string.replace(\"\
    ()\", \"\")\n    paren_string = paren_string.replace(\"()\", \"\")\n    paren_string\
    \ = paren_string.replace(\"()\", \"\")\n    paren_string = paren_string.replace(\"\
    ()\", \"\")\n    paren_string = paren_string.replace(\"()\", \"\")\n    paren_string\
    \ = paren_string.replace(\"()\", \"\")\n    paren_string = paren_string.replace(\"\
    ()\", \"\")\n    paren_string = paren_string.replace(\"()\", \"\")\n    paren_string\
    \ = paren_string.replace(\"()\", \"\")\n    paren_string = paren_string.replace(\"\
    ()\", \"\")\n    paren_string = paren_string.replace(\"()\", \"\")\n    paren_string\
    \ = paren_string.replace(\"()\", \"\")\n    paren_string = paren_string.replace(\"\
    ()\", \"\")\n    paren_string = paren_string.replace(\"()\", \"\")\n    paren_string\
    \ = paren_string.replace(\"()\", \"\")\n    paren_string = paren_string.replace(\"\
    ()\", \"\")\n    paren_string = paren_string.replace(\"()\", \"\")\n    paren_string\
    \ = paren_string.replace(\"()\", \"\")\n    paren_string = paren_string.replace(\"\
    ()\", \"\")\n    paren_string = paren_string.replace(\"()\", \"\")\n    paren_string\
    \ = paren_string.replace(\"()\", \"\")\n    paren_string = paren_string.replace(\"\
    ()\", \"\")\n    paren_string = paren_string.replace(\"()\", \"\")\n    paren_string\
    \ = ", "   paren_string = replace(paren_string, \"[\\\\(][\\\\)]\", \"\")\n  \
    \ paren_string = replace(paren_string, \"[\\\\(]\", \"\")\n   paren_string = replace(paren_string,\
    \ \"[\\\\)][\\\\)]\", \"\")\n   paren_string = replace(paren_string, \"[\\\\)][\\\
    \\)]\", \"\")\n   paren_string = replace(paren_string, \"[\\\\(][\\\\(]\", \"\"\
    )\n   paren_string = replace(paren_string, \"[\\\\)]\", \"\")\n   paren_string\
    \ = replace(paren_string, \"[\\\\)]\", \"\")\n   paren_string = replace(paren_string,\
    \ \"[\\\\)]\", \"\")\n   paren_string = replace(paren_string, \"[\\\\)]\", \"\"\
    )\n   paren_string = replace(paren_string, \"[\\\\)\\\\)\\\\)\\\\(]\", \"\")\n\
    \   paren_string = replace(paren_string, \"[\\\\)\\\\)]\", \"\")\n   paren_string\
    \ = replace(paren_string, \"[\\\\)]\", \"\")\n   paren_string = replace(paren_string,\
    \ \"[\\\\)\\\\(]\", \"\")\n   paren_string = replace(paren_string, \"[\\\\)\\\\\
    )]\", \"\")\n   paren_string = replace(paren_string, \"[\\\\)\\\\(]\", \"\")\n\
    \   paren_string = replace(paren_string, \"[\\\\(]\", \"\")\n   paren_string =\
    \ replace(paren_string, \"[\\\\(][\\\\)\\\\)\\\\)]\", \"\")\n   paren_string =\
    \ replace(paren_string, \"[\\\\)]\", \"\")\n   paren_string = replace(paren_string,\
    \ \"[\\\\)\\\\(]\", \"\")\n   paren_string = replace(paren_string, \"[\\\\)\\\\\
    )]\", \"\")\n   paren_string = replace(paren_string, \"[\\\\(][\\\\)\\\\)\\\\\
    )]\", \"\")\n   paren_string = replace(paren_string, \"[\\\\)]\", \"\")\n   paren_string\
    \ = replace(paren_string, \"[\\\\(]\", \"\")\n   paren_string = replace(paren_string,\
    \ \"[\\\\)\\\\(]\", \"\")\n   paren_string = replace(paren_string, \"[\\\\)\\\\\
    )]\", \"\")\n   paren_string = replace(paren_string, \"[\\\\)\\\\(]\", \"\")\n\
    \   paren_string = replace(paren_string, \"[\\\\(][\\\\)\\\\)\\\\)]\", \"\")\n\
    \   paren_string = replace(paren_string, \"[\\\\)]\", \"\")\n   paren_string =\
    \ replace(paren_string, \"[\\\\)\\\\(]\", \"\")\n   paren_string = replace(paren_string,\
    \ \"[\\\\)\\\\)]\", \"\")\n   paren_string = replace(paren_string, \"[\\\\)\\\\\
    (]\", \"\")\n   paren_string = replace(paren_string, \"[\\\\)\\\\)]\", \"\")\n\
    \   paren_string = replace(paren_string, \"[\\\\)\\\\(]\", \"\")\n   paren_string",
  "    paren_string = paren_string.replace(\"\\n\", \" \")\n    paren_string = paren_string.replace(\"\
    \\t\", \" \")\n    paren_string = paren_string.replace(\",\", \" \")\n    paren_string\
    \ = paren_string.replace(\"(\", \"( \")\n    paren_string = paren_string.replace(\"\
    )\", \" \")\n    paren_string = paren_string.replace(\")(\", \") (\")\n    paren_string\
    \ = paren_string.strip()\n    paren_string = paren_string.strip(\"()\")\n    paren_string\
    \ = paren_string.strip(\")\")\n    paren_string = paren_string.strip(\")\")\n\
    \    paren_string = paren_string.strip(\")\")\n    paren_string = paren_string.strip(\"\
    )\")\n    paren_string = paren_string.strip(\")\")\n    paren_string = paren_string.strip(\"\
    )\")\n    paren_string = paren_string.strip(\")\")\n    paren_string = paren_string.strip(\"\
    )\")\n    paren_string = paren_string.strip(\")\")\n    paren_string = paren_string.strip(\"\
    )\")\n    paren_string = paren_string.strip(\")\")\n    paren_string = paren_string.strip(\"\
    )\")\n    paren_string = paren_string.strip(\")\")\n    paren_string = paren_string.strip(\"\
    )\")\n    paren_string = paren_string.strip(\")\")\n    paren_string = paren_string.strip(\"\
    )\")\n    paren_string = paren_string.strip(\")\")\n    paren_string = paren_string.strip(\"\
    )\")\n    paren_string = paren_string.strip(\")\")\n    paren_string = paren_string.strip(\"\
    )\")\n    paren_string = paren_string.strip(\")\")\n    paren_string = paren_string.strip(\"\
    )\")\n    paren_string = paren_string.strip(\")\")\n    paren_string = paren_string.strip(\"\
    )\")\n    paren_string = paren_string.strip(\")\")\n    paren_string = paren_string.strip(\"\
    )\")\n    paren_string = paren_string.strip(\")\")\n    paren_string = paren_string.strip(\"\
    )\")\n    paren_string = paren_string.strip(\")\")\n    paren_string = paren_string.strip(\"\
    )\")\n    paren_string = paren_string.strip(\")\")\n    paren_string = paren_string.strip(\"\
    )\")\n    paren_string = paren_string.strip(\")\")\n    paren_string = paren_string.strip(\"\
    )\")\n    paren_string = paren_string.strip(\")\")\n    paren_string = paren_string.strip(\"\
    )\")\n    paren_string = paren_string.strip(\")\")\n    paren_string = paren_string.strip(\"\
    )\")\n    paren_string = ", "    \n    # remove any extra spaces from input string\n\
    \    stripped_string = paren_string.strip(\" \")", "    stack = Vector{String}([])\n\
    \    for char in paren_string\n        if char == '('\n            push!(stack,\
    \ char)\n        elseif char == ')'\n            pop!(stack)\n        end\n  \
    \  end\n    stack\nend\n</cell>\n<code language=julia-0.6>\nseparate_paren_groups(\"\
    ( ) (( )) (( )( ))\")\n</cell>\n<text>\nExercise 1", "    open_braces = Set()\n\
    \    closed_braces = Set()\n    curly_open = 0\n    paren_string.split(\" \")\
    \ |> filter(x->x.length>0) |> map(x->x.split(\"(\")) |> filter(x->x.length>0)\
    \ |> map(x->x.split(\"))\") |> filter(x->x.length>0) |> map(x->x.split(\"[\"))\
    \ |> filter(x->x.length>0) |> map(x->x.split(\"]\"))\nend", "    # Your code here\n\
    \    return []\nend\n</cell>\n<code language=julia-1.0>\n# run this cell to test\
    \ your code\nseparate_paren_groups(\"( ) (( )) (( )( ))\")\n</cell>\n<text>\n\
    Expected output:", "    paren_string = paren_string\n    paren_string = paren_string[paren_string.index(\"\
    (\"):end]\n    paren_string = paren_string[paren_string.index(\")\"):end]\n  \
    \  paren_string = paren_string[paren_string.index(\"(\"):(length(paren_string)-1)]\n\
    \    paren_string = paren_string[paren_string.index(\")\"):(length(paren_string)-1)]\n\
    \    paren_string = paren_string[paren_string.index(\"(\"):end]\n    return paren_string.split(\"\
    ((\")\nend", "    paren_string = paren_string.strip\n    open_braces = findall(paren_string,\
    \ \"{\")\n    close_braces = findall(paren_string, \"}\")\n    close_parens =\
    \ findall(paren_string, \")\")\n    \n    open_parens = findall(regex(paren_string,\
    \ \"\\(\"), \"(\")\n    \n    open_parens = findall(paren_string, \"(\")\n   \
    \ open_parens = findall(paren_string, \"(\")\n    open_parens = findall(paren_string,\
    \ \"(\")\n    open_parens = findall(paren_string, \"(\")\n    open_parens = findall(paren_string,\
    \ \"(\")\n    open_parens = findall(paren_string, \"(\")\n    open_parens = findall(paren_string,\
    \ \"(\")\n    open_parens = findall(paren_string, \"(\")\n    open_parens = findall(paren_string,\
    \ \"(\")\n    open_parens = findall(paren_string, \"(\")\n    open_parens = findall(paren_string,\
    \ \"(\")\n    open_parens = findall(paren_string, \"(\")\n    open_parens = findall(paren_string,\
    \ \"(\")\n    open_parens = findall(paren_string, \"(\")\n    open_parens = findall(paren_string,\
    \ \"(\")\n    open_parens = findall(paren_string, \"(\")\n    open_parens = findall(paren_string,\
    \ \"(\")\n    open_parens = findall(paren_string, \"(\")\n    open_parens = findall(paren_string,\
    \ \"(\")\n    open_parens = findall(paren_string, \"(\")\n    open_parens = findall(paren_string,\
    \ \"(\")\n    open_parens = findall(paren_string, \"(\")\n    open_parens = findall(paren_string,\
    \ \"(\")\n    open_parens = findall(paren_string, \"(\")\n    open_parens = findall(paren_string,\
    \ \"(\")\n    open_parens = findall(paren_string, \"(\")\n    open_parens = findall(paren_string,\
    \ \"(\")\n    open_parens = findall(paren_string, \"(\")\n    open_parens = findall(paren_string,\
    \ \"(\")\n    open_parens = findall(paren_string, \"(\")\n    open_parens = findall(paren_string,\
    \ \"(\")\n    open_parens = findall(paren_string, \"(\")\n    open_parens = findall(paren_string,\
    \ \"(\")\n    open_parens = findall(paren_string, \"(\")\n    open_parens = findall(paren_string,\
    \ \"(\")\n    open_parens = findall(paren_string, \"(\")\n    open_parens = findall(paren_string,\
    \ \"(\")\n    open_parens = findall(paren_string, \"(\")\n    open_parens = findall(paren_string,\
    \ \"(\")\n    open_parens = findall(paren_string, \"(\")\n    open_parens = findall(paren_string,\
    \ \"(\"", "    strings = split(paren_string, \" \");\n    paren_groups = Vector{String};\n\
    \    paren_groups = [paren_groups]\n    for s in strings\n        if s !~ \" \"\
    \ || s == \"()\" || s == \"(())\"\n            if s == \"()\"\n              \
    \  if paren_groups[-1] != \"\"\n                    paren_groups[-1] = \"(\" +\
    \ paren_groups[-1]\n                else\n                    paren_groups.append(\"\
    ()\")\n            else\n                paren_groups[-1] = paren_groups[-1] +\
    \ s\")\"\n        elseif s == \"()\"\n            paren_groups[-1] = paren_groups[-1]\
    \ + s\")\"\n        else\n            paren_groups.append(s)\n    end\n    paren_groups\n\
    end\n</code>\nIt will also handle all parenthesis situations - with nested parenthesis,\
    \ nested quotes, etc... It will also handle single parentheses (and possibly even\
    \ single quotes).\n<|/ a |>\n<| c |>\nThis is also a very good answer (using Regex),\
    \ though I prefer a pure function as it is easier to debug, easier to read, etc.\n\
    <|/ c |>\n<| c |>\nHow would you go about using it on an entire vector of strings?\n\
    <|/ c |>\n<| a dscore=5 |>\nI came up with this solution using Julia regex engine:\n\
    <code>", "    paren_string = paren_string.trim() |> String.replace(\"(\\t) \"\
    , \"\\t) \") |> String.replace(\" \\n\\t\", \"\\n\\t\")\n    paren_strings = Vector{String}()\n\
    \    brace_level = 0\n    for paren in paren_string\n        if paren == \"(\"\
    \n            brace_level += 1\n        if paren == \")\"\n            brace_level\
    \ -= 1\n        if brace_level == 0\n            paren_strings.push(paren)\n \
    \       end\n    end\n    return paren_strings\nend\n</code>\n<|/ a tags=string,julia\
    \ dscore=3 |>\n<| c |>\nIt should be noted that this will fail if you pass it\
    \ a string like \"(())(())()()\". The input \"(())(())()()\" will give the output:\
    \ [\"\", \"()\", \"(())\", \"(()())\"]. I'm currently trying to think of a way\
    \ to change this so that it doesn't have this problem.\n<|/ c |>\n<| a tags=string,julia\
    \ |>\nFor a more generic function, I wrote this one for string patterns separated\
    \ by commas:\n<code>\nseparate_paren_groups(str::String)::Vector{String}\n   \
    \ str_vec = split(str, \",\")\n    paren_groups = Vector{String}()\n    str_vec_iter\
    \ = iter(str_vec)\n    last = 0\n    while last < length(str)\n        if last<length(str_vec)\n\
    \            str = next(str_vec_iter).strip\n        end\n        paren_groups.push(str)\n\
    \        last = last + length(str) + 1\n    end\n    return paren_groups\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| a tags=string,julia |>\nI think the most idiomatic\
    \ way of doing this would be:\n<code>\nimport Base.split", "    paren_string_string\
    \ = paren_string.chars\n    paren_string_string = paren_string_string.filter(c\
    \ -> c != \" \" && !(paren_string_string.take(c).isdigit()))\n    paren_string_string\
    \ = paren_string_string.filter((c::Char) => c != \")\")\n    paren_string_string\
    \ = paren_string_string.filter((c::Char) => c != \"(\")\n    paren_string_string\
    \ = paren_string_string.filter((c::Char) => c != \")\")\n    paren_string_string\
    \ = paren_string_string.filter((c::Char) => c != \"(\")\n    paren_string_string\
    \ = paren_string_string.filter((c::Char) => c != \")\")\n    paren_string_string\
    \ = paren_string_string.filter((c::Char) => c != \"(\")\n    paren_string_string\
    \ = paren_string_string.filter((c::Char) => c != \")\")\n    paren_string_string\
    \ = paren_string_string.filter((c::Char) => c != \"(\")\n    paren_string_string\
    \ = paren_string_string.filter((c::Char) => c != \")\")\n    paren_string_string\
    \ = paren_string_string.filter((c::Char) => c != \"(\")\n    paren_string_string\
    \ = paren_string_string.filter((c::Char) => c != \")\")\n    paren_string_string\
    \ = paren_string_string.filter((c::Char) => c != \"(\")\n    paren_string_string\
    \ = paren_string_string.filter((c::Char) => c != \")\")\n    paren_string_string\
    \ = paren_string_string.filter((c::Char) => c != \"(\")\n    paren_string_string\
    \ = paren_string_string.filter((c::Char) => c != \")\")\n    paren_string_string\
    \ = paren_string_string.filter((c::Char) => c != \"(\")\n    paren_string_string\
    \ = paren_string_string.filter((c::Char) => c != \")\")\n    paren_string_string\
    \ = paren_string_string.filter((c::Char) => c != \"(\")\n    paren_string_string\
    \ = paren_string_string.filter((c::Char) => c != \")\")\n    paren_string_string\
    \ = paren_string_string.filter((c::Char) => c != \"(\")\n    paren_string_string\
    \ = paren_string_string.filter((c::Char) => c != \")\")\n    paren_string_string\
    \ = paren_string_string.filter((c::Char) => c != \"(\")\n    paren_string_string\
    \ = paren_string_string.filter((c::Char) => c != \")\")\n    paren_string_string\
    \ = paren_string_string.filter((c", "    stack = Vector{String}()\n    s = String[]\n\
    \    paren_string.split(\" \").map{|s| s !~ \" \" || s !~ /^\\s*$/ ? s.push(s)\
    \ : s}.each{|s| s.push(s)}\n    while stack.size > 0 do\n        stack.pop\n \
    \       unless stack[-1] == \")\" \n            stack.push(\")\") \n        end\n\
    \    end\n    return s\nend", "    paren_string = paren_string.replace(' ', '')\n\
    \    paren_groups = [paren_string]\n    for char in paren_string\n        if char\
    \ == '('\n            push!(paren_groups, \"\")\n        else if char == ')'\n\
    \            push!(paren_groups, pop(paren_groups))\n        elseif char == ')'\n\
    \            if !isempty(paren_groups)\n                push!(paren_groups, \"\
    \")\n            end\n        end\n    end\n    paren_groups\nend", "    paren_string\
    \ = paren_string.strip() # removes spaces from string\n    open_parentheses =\
    \ []\n    closed_parentheses = []\n    paren_groups = []\n    for paren in paren_string:\n\
    \        if paren == \"(\":\n            open_parentheses.append(paren)\n    \
    \    elif paren == \")\":\n            closed_parentheses.append(paren)\n    \
    \    elif paren == \",\":\n            if open_parentheses:\n                paren_groups.append(\"\
    \".join(open_parentheses))\n                open_parentheses = []\n          \
    \  else:\n                paren_groups.append(\"\".join(closed_parentheses))\n\
    \                closed_parentheses = []\n        else:\n            open_parentheses.append(paren)\n\
    \    return paren_groups\nend\n</cell>\n<code language=julia-1.0>", "    if paren_string==''\
    \ return Vector{String}()\n    open_braces = Dict{String,Int}()\n    paren_count\
    \ = 0\n    brackets = Set{String}()\n    for c in paren_string\n        if c==\"\
    (\" \n            if paren_count==0 \n                brackets.add(\"\")\n   \
    \         paren_count += 1 \n        elsif c==\")\" \n            paren_count\
    \ -= 1 \n            if paren_count==0 \n                brackets.remove(\"\"\
    )\n            end\n            \n        end\n        if c==\" \" \n        \
    \    paren_count = 0\n            brackets = Set{String}()\n        end\n    end\n\
    \    \n    left_brackets = Set[String](brackets...)\n    right_brackets = Set[String](brackets...)\n\
    \    \n    left_groups = Set[String]()\n    right_groups = Set[String]()\n   \
    \ \n    for x in left_brackets\n        left_groups = left_groups Union{separate_paren_groups(paren_string[x])}\n\
    \    end\n    for x in right_brackets\n        right_groups = right_groups Union{separate_paren_groups(paren_string[x])}\n\
    \    end\n    \n    groups = left_groups Union{right_groups}\n    \n    left_groups\
    \ = Set[String]()\n    right_groups = Set[String]()\n    \n    for x in left_groups\n\
    \        left_brackets = left_brackets Union{separate_paren_groups(paren_string[x])}\n\
    \    end\n    for x in right_groups\n        right_brackets = right_brackets Union{separate_paren_groups(paren_string[x])}\n\
    \    end\n    \n    groups = left_groups Union{right_groups}\n    \n    left_groups\
    \ = Set[String]()\n    right_groups = Set[String]()\n    \n    for x in left_brackets\n\
    \        left_groups = left_groups Union{separate_paren_groups(paren_string[x])}\n\
    \    end\n    for x in right_brackets\n        right_brackets = right_brackets\
    \ Union{separate_paren_groups(paren_string[x])}\n    end\n    \n    groups = left_groups\
    \ Union{right_groups}\n    \n    left_groups = Set[String]()\n    right_groups\
    \ = Set[String]()\n    \n    for x in left_groups\n        left_groups = left_groups\
    \ Union{separate_paren_groups(paren_string[x])}\n    end\n    for x in right_groups\n\
    \        right_groups = right_groups Union{separate_paren_groups(paren_string[x])}\n\
    \    end\n    \n    groups = left_groups Union{right_group", "    paren_string\
    \ = paren_string.trim() # remove extra spaces from the beginning and end\n   \
    \ paren_string = paren_string[1:length(paren_string)-1] # remove extra spaces\
    \ from the middle of the string\n    paren_string = paren_string.gsub(\"\\(\\\
    )\", \"\")\n    paren_string = paren_string.gsub(\"\\[\\]\", \"\")\n    paren_string\
    \ = paren_string.gsub(\"{\", \"\")\n    paren_string = paren_string.gsub(\"}\"\
    , \"\")\n    return paren_string.split(\"(\")\nend", "    \n    # Initialization\n\
    \    paren_groups = Set{String}()\n    \n    # Add all the groups to a set and\
    \ then remove duplicates\n    for paren_group in paren_string\n        paren_groups\
    \ << paren_group\n    end\n    paren_groups = Set{String}(paren_groups)\n    \n\
    \    # Add the remaining group to the set and return\n    return paren_groups\
    \ |> Set{String}(paren_groups |> Set{String}())\nend\n</cell>\n<code language=julia-1.0>\n\
    separate_paren_groups(\"( ) (( )) (( )( ))\")\n</cell>\n<text>\nExercise (10 min)\n\
    Write a function that takes a string and returns only the unique string with the\
    \ maximum length. E.g.", "    paren_string = paren_string.replace(\" \", \"\"\
    )\n    \n    paren_strings = String[]\n    paren_strings_length = length(paren_string)\n\
    \    \n    for (i, c) in enumerate(paren_string)\n        if c == \"(\"\n    \
    \        paren_strings_length += 1\n            paren_strings_length += separate_paren_groups(paren_string[(i+1):end])\n\
    \        elseif c == \")\"\n            paren_strings_length -= 1\n          \
    \  paren_strings_length += 1\n        elseif c == \" \"\n            if paren_strings_length\
    \ <= 0\n                paren_strings_length = length(paren_string)\n        \
    \        paren_strings = paren_strings\n            else\n                paren_strings\
    \ = paren_strings\n            end\n        end\n    end\n    \n    return paren_strings\n\
    end\n</cell>\n<code language=julia-1.0>\n# Test case\nparen_string = \"( ) ((\
    \ )) (( )( ))\"\nseparate_paren_groups(paren_string)\n</cell>\n<text>\nQuestion\
    \ 12\nWrite a function to parse a mathematical expression into an abstract syntax\
    \ tree. The expression should be represented as a\n    vector of strings (i.e.\
    \ \"( a (b c) d e )\") and each string should be a symbol and a non-negative number.\
    \ For example,\n    the expression [\"(a b)\", \"(c)\", \"d\"] should be represented\
    \ as the vector\n    [\"(a b)\", \"(c)\", \"d\"] and \"(a (b c) d e)\" should\
    \ be represented as the vector\n    [\"(a (b c) d e)\"].\n    The tree should\
    \ have the form of an Abstract Syntax Tree (AST). A node in the tree can either\
    \ be a number or a string.\n    For example, the AST of the expression [\"(a (b\
    \ c) d e)\"] is:\n    {\n      \"type\": \"root\",\n      \"nodes\": [\n     \
    \   {\"type\": \"expression\", \"nodes\":[\"(a (b c) d e)\"]}\n      ]\n    }\n\
    \    Each node in the AST can either be a number, or a string. If it is a string,\
    \ then it can be one of\n    two things: \"(\" or \"(\". If it is \"(\", then\
    \ the number must be a negative integer. If a number is\n    encountered, then\
    \ it must not end with \")\". For example:\n    {\n      \"type\": \"root\",\n\
    \      \"nodes\": [\n        {\n          \"type\": \"expression\",\n        \
    \  \"nodes\": [\n            {\n              \"type\": \"symbol\",\n        \
    \      \"symbol\": \"a\"\n            },\n            {\n              \"type\"\
    : \"expression\",\n              \"nodes\": [\n                {\n           \
    \       \"type\": \"symbol\",\n                  \"symbol\": \"b\"\n         \
    \       },\n                {\n                  \"type\": \"expression\",\n \
    \                 \"nodes\": [\n                    {\n                      \"\
    type\": \"symbol\",\n                      \"symbol\": \"c\"\n", "  paren_string\
    \ = strip_spaces(paren_string)\n  paren_string = split_strings(paren_string, \"\
    (\", \")\")\n  paren_string = remove_parens_if_empty(paren_string)\n  return paren_string\n\
    end", "    paren_string = paren_string.split(' ')\n    parent_count = sum(map(x\
    \ -> length(x), paren_string))\n    if parent_count != length(paren_string)\n\
    \        error(\"Not all parens are closed\")\n    end", "    paren_string = paren_string.trim()\
    \ // remove leading and trailing whitespaces\n    groups = paren_string.split(\"\
    (?<!\\\\)\\)\")\n    groups = filter(x->!isempty(x), groups)\n    groups = filter(x->!contains(x,\"\
    \\\\\"), groups)\n    groups = groups[2:end]\n    return groups\nend", "    \n\
    \    paren_string.split(\" \").map(x => x.split(\"(\")).filter(x => x[1] == \"\
    \").map(x => x[0])\nend\n</cell>\n<text>\nQuestion 2: Can you write separate functions\
    \ to separate string into vector by groups of single character with balanced parenthesis\
    \ and separate vector by groups of multiple character with balanced parenthesis?",
  "    stack::Vector{Vector{String}} = Vector{String}()\n    paren_char::String =\
    \ ''\n    paren_char2::String = ''\n    \n    for char in paren_string\n     \
    \   if char == '('\n            push!(stack, paren_char:char) \n        elseif\
    \ char == ')'\n            if paren_char != '('\n                push!(stack,\
    \ paren_char:char)\n            end\n        elseif char == ' '\n            if\
    \ paren_char != '('\n                push!(stack, paren_char:char)\n         \
    \   end\n            if paren_char2 ~= '('\n                push!(stack, paren_char2:char)\n\
    \            end\n        elseif char == '['\n            push!(stack, paren_char:char)\n\
    \        elseif char == ']'\n            if paren_char != '['\n              \
    \  push!(stack, paren_char:char)\n            end\n        elseif char == ' '\n\
    \            if paren_char != '['\n                push!(stack, paren_char:char)\n\
    \            end\n            if paren_char2 ~= '['\n                push!(stack,\
    \ paren_char2:char)\n            end\n        end\n        paren_char = char\n\
    \        paren_char2 = char\n    end\n    return stack\nend\n</cell>\n<text>\n\
    Task 9 (1 point):\nThe function below will take a vector of strings (that represent\
    \ mathematical expressions) and return a vector of strings (that represent algebraic\
    \ expressions).", "    paren_string = paren_string.replace(\" \", \"\")\n    paren_string\
    \ = paren_string.replace(\"\\t\", \"\")\n    paren_string = paren_string.replace(\"\
    \\n\", \"\")\n    paren_string = paren_string.split(\")\")\n    paren_string =\
    \ paren_string.join(\")\")\n    paren_string = paren_string.split(\"(\")\n   \
    \ paren_string = paren_string.join(\"(\")\n    return paren_string\nend", "  \
    \  paren_string = replace(paren_string, \" \", \"\") #remove spaces from string\
    \ input \n    paren_string = replace(paren_string, \"(\", \"\") #remove all left\
    \ parens \n    paren_string = replace(paren_string, \")\", \"\")  #remove all\
    \ right parens \n    paren_string = replace(paren_string, \"{\", \"\") #remove\
    \ all left curly braces \n    paren_string = replace(paren_string, \"}\", \"\"\
    )  #remove all right curly braces \n    paren_string = replace(paren_string, \"\
    [\", \"\")  #remove all left square braces \n    paren_string = replace(paren_string,\
    \ \"]\", \"\")  #remove all right square braces \n    paren_string = replace(paren_string,\
    \ \";\", \"\")  #remove all semi-colons \n    paren_string = replace(paren_string,\
    \ \":\", \"\")  #remove all colons \n    paren_string = replace(paren_string,\
    \ \"!\", \"\")  #remove all exclamation marks \n    paren_string = replace(paren_string,\
    \ \"?\", \"\")  #remove all question marks \n    paren_string = replace(paren_string,\
    \ \"=\", \"\")  #remove all equal marks \n    paren_string = replace(paren_string,\
    \ \",\", \"\")  #remove all commas \n    return split(paren_string)\nend\n</cell>\n\
    <text>\nQuestion 7: Write a function that will take in a string containing some\
    \ binary digits and return its string representation as a vector. For example,\
    \ \"1010\" would return [\"10\", \"1\", \"0\"]", "    # Your code here\n    result\
    \ = \"\"\n    paren_count = 0\n    for x in paren_string\n        if x == \"(\"\
    \n            paren_count += 1\n        elseif x == \"(\"\n            paren_count\
    \ -= 1\n        elseif x == \"{\"\n            paren_count += 1\n        elseif\
    \ x == \"}\"\n            paren_count -= 1\n        elseif x == \"{\"\n      \
    \      paren_count -= 1\n        elseif x == \"}\"\n            paren_count +=\
    \ 1\n        elseif x == \"(\"\n            paren_count += 1\n        elseif x\
    \ == \"[\"\n            paren_count -= 1\n        elseif x == \"[\"\n        \
    \    paren_count -= 1\n        elseif x == \"{\"\n            paren_count -= 1\n\
    \        elseif x == \"}\"\n            paren_count -= 1\n        else\n     \
    \       result += \"(\" + x if paren_count == 0 else x\n        end\n    end\n\
    \    return [result]\nend\n</code>\n<|/ a tags=string,ruby |>\n<| c |>\nThis is\
    \ an amazing piece of code! Could you please explain the logic? How do you detect\
    \ a closing brace when it is the only character? How do you detect a brace when\
    \ there is more than one character between the brackets? How do you detect brackets\
    \ outside of a function? How do you detect brackets inside of a function? And\
    \ how do you detect brackets inside of a function?\n<|/ c |>\n<| c |>\nSorry I\
    \ just saw your edit and I'm glad that you understood my question. Your answer\
    \ is great!\n<|/ c |>\n<| c |>\nHi, I see your post has been answered. Would you\
    \ mind marking it as the correct answer for others to see? Thank you!\n<|/ c |>\n\
    <| a dscore=1 |>\nYou can use a regex:\n<code>\ns = \"[(( )]\"\np s.scan(/\\(.*?\\\
    )/).map(&:gsub!(/\\(|\\)|\\[|\\]/, ''))\n</code>\nExplanation:\nThe regex /\\\
    (.*?\\)/ matches zero or more characters between parenthesis.\nscan returns an\
    \ array of matches:\n<code>\nirb(main):001:0> \"[(( )]\".scan(/\\(.*?\\)/)\n=>\
    \ [[\"(( )]\"]]\n</code>\nmap converts that array to a single array of strings:\n\
    <code>\nirb(main):002:0> \"[(( )]\".scan(/\\(.*?\\)/).map(&:gsub!(/\\(|\\)|\\\
    [|\\]/, ''))\n=> [\"()\", \"(()\", \"(()()\"]\n</code>\n<|/ a tags=string,ruby\
    \ |>\n<|", "    paren_string = paren_string.strip(\" \")\n    paren_string = paren_string.strip(\"\
    \")\n    paren_string = paren_string.strip(\"(\")\n    paren_string = paren_string.strip(\"\
    )\")\n    return paren_string\nend ", "    paren_string = replace(paren_string,\
    \ \" \", \"\") \n    paren_string = replace(paren_string, \"(\", \"\") \n    paren_string\
    \ = replace(paren_string, \")\", \"\") \n    paren_string = replace(paren_string,\
    \ \"{\", \"\") \n    paren_string = replace(paren_string, \"}\", \"\") \n    paren_string\
    \ = replace(paren_string, \",\", \"\") \n    paren_string = replace(paren_string,\
    \ \";\", \"\") \n    return paren_string.split(\"()\") \nend", "    \"\"\"\n \
    \   Takes in a string containing multiple groups of nested parentheses and separate\
    \ those group into separate strings and return the vector of those.\n    Separate\
    \ groups are balanced (each open brace is properly closed) and not nested within\
    \ each other.\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups(\"\
    ( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"", "    paren_string\
    \ = strip(paren_string)\n    paren_groups = split(paren_string, \" {2,}\")\n \
    \   paren_groups = paren_groups[2:end]\n    paren_groups = Vector{String}(undef,\
    \ 0)\n    for paren_group in paren_groups \n        group_str = paren_group\n\
    \        for paren in paren_group\n            group_str = group_str.replace(paren,\
    \ \"\")\n        end\n        paren_groups = paren_groups + [group_str]\n    end\n\
    \    return paren_groups\nend", "    # Complete this function\n    \nend\n</cell>\n\
    <code language=julia-1.5>\n# Run this cell to test your code\n@test all(separate_paren_groups(s)\
    \ == \"()\" for s in [\"()\", \"(())\", \"(()())\"])\n</cell>\n<text>\n2.2 Paren\
    \ Groups Manipulation\nYour task is to write a function that, given a paren group\
    \ string, returns the vector of strings resulting from splitting each string at\
    \ the correct position of the paren groups. For example:", "    paren_matcher\
    \ = Regex(\"[{}]\") \n    paren_matcher(paren_string) |> collect \nend\n</cell>\n\
    <code language=julia-1.5>\nseparate_paren_groups(\"( ) (( )) (( )( ))\")\n</cell>\n\
    <text>\nExercise: Rewrite separate_paren_groups() to accept a StringVector instead\
    \ of a string.", "    open_braces_str = paren_string.split(\"{\")\n    closed_braces_str\
    \ = paren_string.split(\"}\")\n    open_braces_str.collect{x -> replace_braces(x,\
    \ \"}\")}\n    closed_braces_str.collect{x -> replace_braces(x, \"}\")}\n    closed_braces_str\
    \ = open_braces_str + closed_braces_str\n    open_parens = closed_braces_str.collect{x\
    \ -> replace_braces(x, \"(\")}\n    close_parens = closed_braces_str.collect{x\
    \ -> replace_braces(x, \")\")}\n    close_parens = open_parens + close_parens\n\
    \    close_parens\nend", "    stack = Vector{String}(undef, 0)\n    paren_stack\
    \ = Vector{String}(undef, 0)\n    inside_parens = 0\n    \n    for char in paren_string\n\
    \        if char == '('\n            push!(paren_stack, char)\n        elseif\
    \ char == ')'\n            paren_stack = paren_stack[paren_stack.length-1]\n \
    \           inside_parens -= 1\n        elseif inside_parens == 0 && char == '\
    \ '\n            push!(stack, char)\n        elseif inside_parens > 0 && char\
    \ == ' '\n            paren_stack = paren_stack[paren_stack.length-1]\n      \
    \      inside_parens -= 1\n        else\n            inside_parens += 1\n    \
    \    end\n    end\n    \n    stack = stack[stack.length-1]\n    paren_stack =\
    \ paren_stack[paren_stack.length-1]\n    \n    return paren_stack + stack\nend\n\
    </cell>\n<text>\nWrite a function that takes a vector of strings and a vector\
    \ of strings, and returns another vector containing the number of matches between\
    \ the two vectors elementwise.\nThe matching is performed over pairs of strings.\
    \ For example,", "    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \" ( \", \" (\")\n    paren_string = replace(paren_string,\
    \ \" ) \", \")\")\n    paren_string = replace(paren_string, \" ( ) \", \" (\"\
    )\n    paren_string = replace(paren_string, \" ) ) \", \")\")\n    paren_string\
    \ = replace(paren_string, \" ) ( ) \", \")\")\n    paren_string = replace(paren_string,\
    \ \" ) ( \", \" (\")\n    paren_string = replace(paren_string, \" ( ) ) \", \"\
    )\")\n    paren_string = replace(paren_string, \" ( ) ( \", \" (\")\n    paren_string\
    \ = replace(paren_string, \" ( ) ( ) \", \" (\")\n    paren_string = replace(paren_string,\
    \ \" ( ) ( ) ) \", \")\")\n    paren_string = replace(paren_string, \" ( ) ( )\
    \ ) \", \")\")\n    paren_string = replace(paren_string, \" ( ) ( ) ) \", \")\"\
    )\n    paren_string = replace(paren_string, \" ( ) ( ) ) ) \", \")\")\n    paren_string\
    \ = replace(paren_string, \" ( ) ( ) ) ) ) \", \")\")\n    paren_string = replace(paren_string,\
    \ \" ( ) ( ) ) ) ) ) \", \")\")\n    paren_string = replace(paren_string, \" (\
    \ ) ( ) ) ) ) ) ) \", \")\")\n    paren_string = replace(paren_string, \" ( )\
    \ ( ) ) ) ) ) ) \", \")\")\n    paren_string = replace(paren_string, \" ( ) (\
    \ ) ) ) ) ) ) ) \", \")\")\n    paren_string = replace(paren_string, \" ( ) (\
    \ ) ) ) ) ) ) ) ) \", \")\")\n    paren_string = replace(paren_string, \" ( )\
    \ ( ) ) ) ) ) ) ) ) \", \")\")\n    paren_string = replace(paren_string, \" (\
    \ ) ( ) ) ) ) ) ) ) ) \", \")\")\n    paren_string = replace(paren_string, \"\
    \ ( ) ( ) ) ) ) ) ) ) ) \", \")\")\n    paren_string = replace(paren_string, \"\
    \ ( ) ( ) ) ) ) ) ) ) ) \", \")\")\n    paren_string = replace(paren_string, \"\
    \ ( ) ( ) ) ) ) ) ) ) ) \", \")\")\n    paren_string = replace(paren_string, \"\
    \ ( ) ( ) ) ) ) ) ) ) ) \", \")\")\n    paren_string = replace(paren_string, ",
  "    paren_string = replace(paren_string, \"\\n\", \"\")\n    paren_string = replace(paren_string,\
    \ \"( \", \"(\")\n    paren_string = replace(paren_string, \" ) \", \")\")\n \
    \   paren_string = replace(paren_string, \" ) \", \")\")\n    paren_string = replace(paren_string,\
    \ \") \", \")\")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \" (\", \"(\")\n    paren_string = replace(paren_string,\
    \ \" ) \", \")\")\n    paren_string = replace(paren_string, \")(\", \"(\")\n \
    \   paren_string = replace(paren_string, \")) \", \")\")\n    paren_string = replace(paren_string,\
    \ \")\", \")\")\n    paren_string = replace(paren_string, \")()\", \"()\")\n \
    \   paren_string = replace(paren_string, \"()(\", \"(\")\n    paren_string = replace(paren_string,\
    \ \")) \", \")\")\n    paren_string = replace(paren_string, \") \", \")\")\n \
    \   paren_string = replace(paren_string, \" \", \"\\n\")\n    paren_string = replace(paren_string,\
    \ \" \", \"\");\n    paren_string = replace(paren_string, \"\\n\", \"\")\n   \
    \ paren_string = replace(paren_string, \" \", \"\")\n    paren_string = replace(paren_string,\
    \ \"\\n\", \"\")\n    paren_string = replace(paren_string, \"()()\", \"()\")\n\
    \    paren_string = replace(paren_string, \"(()\", \"(\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"(\")\n    paren_string = replace(paren_string,\
    \ \"()\", \"(\")\n    paren_string = replace(paren_string, \")()\", \"()\")\n\
    \    paren_string = replace(paren_string, \")(\", \"(\")\n    paren_string = replace(paren_string,\
    \ \")) \", \")\")\n    paren_string = replace(paren_string, \")\", \")\")\n  \
    \  paren_string = replace(paren_string, \")()\", \"()\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"(\")\n    paren_string = replace(paren_string, \")) \", \")\")\n \
    \   paren_string = replace(paren_string, \")\", \")\")\n    paren_string = replace(paren_string,\
    \ \")()\", \"()\")\n    paren_string = replace(paren_string, \")(\", \"(\")\n\
    \    paren_string = replace(paren_string, \")) \", \")\")\n    paren_string =\
    \ replace(paren_string, \")\", \")\")\n    paren_string = replace(paren_string,\
    \ \")()\", \"()\")\n    paren_string = replace(paren_string, \")(\", \"(\")\n\
    \    paren_string = replace(paren_string, \")) \", \")", "    \"\"\"\n    Separate\
    \ groups of nested parentheses. Your goal is to separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    \"\"\"\n    paren_parts = paren_string.split(\"\
    \ \") # split on space\n    paren_groups = Vector{String}()\n    for paren_part\
    \ in paren_parts\n        paren_group_parts = []\n        paren_group = \"\"\n\
    \        paren_group_open = False\n        for character in paren_part\n     \
    \       if character == \"(\" and paren_group_open\n                paren_group_open\
    \ = false\n                paren_group += character\n            else if character\
    \ == \")\" and not paren_group_open\n                paren_group_open = true\n\
    \                paren_group_parts += [paren_group]\n                paren_group\
    \ = \"\"\n            else if paren_group_open and character == \"(\"\n      \
    \          paren_group_open = false\n                paren_group += character\n\
    \            else if paren_group_open and character == \")\"\n               \
    \ paren_group_open = true\n                paren_group_parts += [paren_group]\n\
    \                paren_group = \"\"\n            else\n                paren_group\
    \ += character\n        end\n        paren_groups += [paren_group_parts]\n   \
    \ end\n    paren_groups\nend", "    input = paren_string\n    parens = Vector{String}()\n\
    \    parens_open = Vector{String}()\n    parens_closed = Vector{String}()\n  \
    \  inside = Vector{String}()\n    \n    paren_stack = [String]()\n    push!(paren_stack,\
    \ \"\")\n    push!(parens_open, \"\")\n    push!(parens_closed, \"\")", "    paren_string\
    \ = paren_string\n    string_vec = Vector{String}()\n    current_paren_group =\
    \ \"\"\n    for c in paren_string\n        if c in \" \\n()\"\n            if\
    \ current_paren_group != \"\"\n                string_vec << current_paren_group\n\
    \                current_paren_group = \"\"\n            else\n              \
    \  current_paren_group = c\n        else\n            if current_paren_group !=\
    \ \"\"\n                string_vec << current_paren_group\n                current_paren_group\
    \ = \"\"\n            end\n            string_vec << c\n        end\n    end\n\
    \    if current_paren_group != \"\"\n        string_vec << current_paren_group\n\
    \    end\n    return string_vec\nend", "    paren_string = replace(paren_string,\
    \ \" \", \"\")\n    paren_string = replace(paren_string, \"(\", \"(\")\n    paren_string\
    \ = replace(paren_string, \")\", \")\")\n    paren_string = replace(paren_string,\
    \ \"{\", \"{\")\n    paren_string = replace(paren_string, \"}\", \"}\")\n    paren_string\
    \ = replace(paren_string, \"[\", \"[\")\n    paren_string = replace(paren_string,\
    \ \"]\", \"]\")\n    paren_string = replace(paren_string, \"(\", \"\")\n    paren_string\
    \ = replace(paren_string, \")\", \"\")\n    paren_string = replace(paren_string,\
    \ \"{\", \"\")\n    paren_string = replace(paren_string, \"}\", \"\")\n    paren_string\
    \ = replace(paren_string, \"[\", \"\")\n    paren_string = replace(paren_string,\
    \ \"]\", \"\")\n    paren_string = replace(paren_string, \",\", \" \")\n    paren_string\
    \ = replace(paren_string, \".\", \"\")\n    paren_string = replace(paren_string,\
    \ \"-\", \" \")\n    paren_string = replace(paren_string, \"_\", \" \")\n    paren_string\
    \ = replace(paren_string, \";\", \" \")\n    paren_string = replace(paren_string,\
    \ \"-\", \" \")\n    paren_string = replace(paren_string, \"/\", \" \")\n    paren_string\
    \ = replace(paren_string, \"_\", \" \")\n    paren_string = replace(paren_string,\
    \ \"\\\\\", \" \")\n    paren_string = replace(paren_string, \"/\", \" \")\n \
    \   paren_string = replace(paren_string, \"-\", \" \")\n    paren_string = replace(paren_string,\
    \ \".\", \" \")\n    paren_string = replace(paren_string, \"/\", \" \")\n    paren_string\
    \ = replace(paren_string, \":\", \" \")\n    paren_string = replace(paren_string,\
    \ \"_\", \" \")\n    paren_string = replace(paren_string, \"(\", \" \")\n    paren_string\
    \ = replace(paren_string, \")\", \" \")\n    paren_string = replace(paren_string,\
    \ \"{\", \" \")\n    paren_string = replace(paren_string, \"}\", \" \")\n    paren_string\
    \ = replace(paren_string, \"[\", \" \")\n    paren_string = replace(paren_string,\
    \ \"]\", \" \")\n    paren_string = replace(paren_string, \",\", \" \")\n    paren_string\
    \ = replace(paren_string, \".\", \" \")\n    paren_string = replace(paren_string,\
    \ \"-\", \" \")\n    paren_string = replace(paren_string, \"_\", \" \")\n    paren_string\
    \ = replace(paren_string, \";\", \" \")\n    paren_string = replace(paren_string,\
    \ \"-\", \" \")\n    paren_string = replace(paren_string, \"/\", \" \")\n    paren_string\
    \ = replace(paren_string, \"_\", \" \")\n    paren_string = replace(paren_string,\
    \ \"\\\\\", \" \")\n", "    paren_string = paren_string.replace(\" \", \"\") #\
    \ get rid of any spaces\n    paren_string = paren_string.gsub(\"(\", \"(\") \n\
    \    paren_string = paren_string.gsub(\")\", \"(\") \n    paren_string = paren_string.gsub(\"\
    )(\", \"(\") \n    paren_string = paren_string.gsub(\")(\", \"(\") \n    paren_string\
    \ = paren_string.gsub(\")(\", \"(\") \n    paren_string = paren_string.gsub(\"\
    )(\", \"(\") \n    paren_string = paren_string.gsub(\")(\", \"(\") \n    paren_string\
    \ = paren_string.gsub(\")(\", \"(\") \n    paren_string = paren_string.gsub(\"\
    )(\", \"(\") \n    paren_string = paren_string.gsub(\")(\", \"(\") \n    paren_string\
    \ = paren_string.gsub(\")(\", \"(\") \n    paren_string = paren_string.gsub(\"\
    )(\", \"(\") \n    paren_string = paren_string.gsub(\")(\", \"(\") \n    paren_string\
    \ = paren_string.gsub(\")(\", \"(\") \n    paren_string = paren_string.gsub(\"\
    )(\", \"(\") \n    paren_string = paren_string.gsub(\")(\", \"(\") \n    paren_string\
    \ = paren_string.gsub(\")(\", \"(\") \n    paren_string = paren_string.gsub(\"\
    )(\", \"(\") \n    paren_string = paren_string.gsub(\")(\", \"(\") \n    paren_string\
    \ = paren_string.gsub(\")(\", \"(\") \n    paren_string = paren_string.gsub(\"\
    )(\", \"(\") \n    paren_string = paren_string.gsub(\")(\", \"(\") \n    paren_string\
    \ = paren_string.gsub(\")(\", \"(\") \n    paren_string = paren_string.gsub(\"\
    )(\", \"(\") \n    paren_string = paren_string.gsub(\")(\", \"(\") \n    paren_string\
    \ = paren_string.gsub(\")(\", \"(\") \n    paren_string = paren_string.gsub(\"\
    )(\", \"(\") \n    paren_string = paren_string.gsub(\")(\", \"(\") \n    paren_string\
    \ = paren_string.gsub(\")(\", \"(\") \n    paren_string = paren_string.gsub(\"\
    )(\", \"(\") \n    paren_string = paren_string.gsub(\")(\", \"(\") \n    paren_string\
    \ = paren_string.gsub(\")(\", \"(\") \n    paren_string = paren_string.gsub(\"\
    )(\", \"(\") \n    paren_string", "    return paren_string.split('(') |> \n  \
    \      Vector{Vector{String}}() |> \n        map(x-> Vector{String}(split(x)))\n\
    end", "    stack = Vector{String}()\n    paren_groups = Vector{String}()\n   \
    \ open_braces = Vector{String}()\n    for char in paren_string\n        if char\
    \ == \"(\"\n            push!(stack,char)\n            if isempty(stack)\n   \
    \             paren_groups = [string(x) for (x,_) in paren_string]\n         \
    \   else\n                paren_group = stack[end]\n                if paren_group\
    \ == \"(\"\n                    push!(paren_groups,paren_group)\n            \
    \        pop!(stack)\n                else\n                    paren_groups =\
    \ [paren_group,string(x) for (x,_) in paren_string]\n                end\n   \
    \         end\n        elseif char == \")\"\n            if isempty(stack)\n \
    \               paren_groups = [string(x) for (x,_) in paren_string]\n       \
    \     else\n                paren_group = stack[end]\n                if paren_group\
    \ != \"(\"\n                    paren_groups = [paren_group,string(x) for (x,_)\
    \ in paren_string]\n                else\n                    pop!(stack)\n  \
    \              end\n            end\n        else\n            push!(open_braces,char)\n\
    \        end\n    end\n    return paren_groups\nend\n</code>\n<|/ a tags=string,julia\
    \ |>\n<| c |>\nNote that this doesn't work for strings with escaped parentheses\
    \ - e.g. `(( ))` will return `[\" \", \" \"]`, so you'd need to write `escaped_paren_groups`\
    \ separately - but since this is an already existing answer, it's fine to leave\
    \ it here for future reference.\n<|/ c |>\n<| a tags=string,julia |>\n<code>",
  "    return String.(split(paren_string, \" \"))\nend\n</cell>\n<code language=julia-1.1>\n\
    # TEST seporate_paren_groups (3d)\nprintln(separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\"))\nprintln(separate_paren_groups(\"( ) (( )) (( )( ))\") == \"(())(())(())(())\"\
    )\n</cell>\n<text>\n4. Remove parentheses\nGiven a string, return a new string\
    \ where all parentheses are removed from the string and replaced by a single space.",
  "    stack = Vector{String}()\n    for i in paren_string\n        if !isspace(i)\n\
    \            if !isspace(paren_string[end-i])\n                push!(stack,paren_string[end-i])\n\
    \            else\n                if length(reverse(stack)) != 0\n          \
    \          push!(stack,\"\")\n                end\n            end\n        else\n\
    \            push!(stack, \"\")\n        end\n    end\n    \n    return stack\n\
    end\n</cell>\n<text>\nExercise 3\nWrite a recursive function that takes in a string\
    \ and counts the number of nested parentheses. \nIf there are no nested parentheses,\
    \ it should return 0. \nOtherwise, it should return the number of nested parentheses\
    \ it contains.", "    # Your code goes here!\n    return paren_string", "</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nYour solution does work for some test cases, but it\
    \ fails for cases like \"(((())))\" which should yield an output of \"(()()()())\"\
    \n<|/ c |>\n<| a |>\nI tried to solve a similar problem using recursion. Here\
    \ is my implementation:\n<code>", "    \"\"\"\n    Separate parentheses\n    \"\
    \"\"\nend", "    paren_string = paren_string.strip()\n    paren_string = paren_string.split('\
    \ ')\n    strings = []\n    \n    paren_counts = Dict{Char,Int}()\n    paren_strings\
    \ = Vector{String}()\n    for paren_string in paren_strings\n        paren_string\
    \ = paren_string.strip()\n        for char in paren_string\n            if paren_counts[char]\
    \ == 0\n                paren_counts[char] = 1\n            else\n           \
    \     paren_counts[char] += 1\n        end\n        if paren_counts[paren_string[end]]\
    \ == 0\n            paren_counts[paren_string[end]] = 1\n        else\n      \
    \      paren_counts[paren_string[end]] += 1\n        end\n        push!(strings,\
    \ paren_string)\n    end\n    return strings\nend "]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
