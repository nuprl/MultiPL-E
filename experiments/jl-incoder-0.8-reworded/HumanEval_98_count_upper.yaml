name: HumanEval_98_count_upper
language: jl
prompt: "\"\"\"\n    Given a string s, count the number of uppercase vowels in even\
  \ indices.\n    \n    For example:\n    >>> count_upper(\"aBCdEf\")\n    1\n   \
  \ >>> count_upper(\"abcdefg\")\n    0\n    >>> count_upper(\"dBBE\")\n    0\n  \
  \  \"\"\"\nfunction count_upper(s::String)::Int64 \n"
tests: "using Test\n\n@testset begin\n\ncandidate = count_upper;\n\t@test(candidate(\"\
  aBCdEf\") == 1)\n\t@test(candidate(\"abcdefg\") == 0)\n\t@test(candidate(\"dBBE\"\
  ) == 0)\n\t@test(candidate(\"B\") == 0)\n\t@test(candidate(\"U\") == 1)\n\t@test(candidate(\"\
  \") == 0)\n\t@test(candidate(\"EEEE\") == 2)\nend\n"
completions: ["    # Write your code in Julia 1.0\n    \n    return 0\nend count_upper\n\
    </cell>\n<cell>\n# Run this cell to test your function above.\n@test count_upper(\"\
    aBCdEf\") == 1\n@test count_upper(\"abcdefg\") == 0 \n@test count_upper(\"dBBE\"\
    ) == 0 \n</cell>\n<text>\n2.4. Vectorize a function\nIn the previous question\
    \ we saw that writing a function that sums the elements of a vector is easy. But\
    \ can you vectorize it instead? Write a function vect_sum that is vectorized over\
    \ one vector and returns its sum. For example, vect_sum([1, 2, 4, 3]) should return\
    \ 10.", "    count = 0\n    for ch in s\n        if ch == 'a'\n            count\
    \ += 0\n        else if ch == 'A'\n            count += 1\n        else if ch\
    \ == 'e'\n            count += 0\n        else if ch == 'E'\n            count\
    \ += 1\n        else if ch == 'i'\n            count += 0\n        else if ch\
    \ == 'I'\n            count += 1\n        else if ch == 'o'\n            count\
    \ += 0\n        else if ch == 'O'\n            count += 1\n        else if ch\
    \ == 'u'\n            count += 0\n        else if ch == 'U'\n            count\
    \ += 1\n        else\n            count += 0\n    return count", "    if s.is_empty\n\
    \        0\n    else\n        s.head == s.head * 2 ||\n        count_upper(s.tail)\
    \ + s.head == count_upper(s.tail) + s.head\nend\n</cell>\n<code language=julia-0.3>",
  "    # write your code in here\n    \n    count_upper = Int64(0)\n    for c in s:\n\
    \        if (c == \"a\" or c == \"e\" or c == \"i\" or c == \"o\" or c == \"u\"\
    ):\n            count_upper += Int64(1)\n    return count_upper\nend\n</cell>\n\
    <code language=julia-1.5>\n@time count_upper(\"aBCdEf\")\n</cell>\n<text>\nWrite\
    \ a function count_lower that takes a string as an argument and returns the number\
    \ of lowercase letters.\nFor example, \n    count_lower(\"aBCdEfG\") -> 2\n  \
    \  count_lower(\"abcdefG\") -> 0\n    count_lower(\"dBBE\") -> 1\n\"\"\"", " \
    \   count <- 0\n    for x in s\n        if x is \"a\"\n            count <- count+1\n\
    \        if x is \"e\"\n            count <- count+1\n        if x is \"i\"\n\
    \            count <- count+1\n        if x is \"o\"\n            count <- count+1\n\
    \        if x is \"u\"\n            count <- count+1\n    end\n    return count\n\
    end\n</cell>\n<code language=julia-0.6>\ncount_upper(\"aBCdEf\")\n</cell>\n<text>\n\
    Practice Problems", "    match s \n        | \"A\" => 1\n        | \"B\" => 1\n\
    \        | \"C\" => 1\n        | \"D\" => 1\n        | \"E\" => 1\n        | \"\
    F\" => 1\n        | \"G\" => 1\n        | (x::Char) -> if isUpper(x) && x <> 'A'\
    \ && x <> 'B' && x <> 'C' && x <> 'D' && x <> 'E' && x <> 'F' && x <> 'G' \n \
    \                           then count_upper(succ(x))\n                      \
    \      else 0\n    end\nend\n</cell>\n<cell>\n@testset \"Counting uppercase vowels\"\
    \ begin\n    @test count_upper(\"aBCdEf\") == 1\n    @test count_upper(\"abcdefg\"\
    ) == 0\n    @test count_upper(\"dBBE\") == 0\nend\n</cell>\n<text>\nAnd now a\
    \ function that counts the number of uppercase vowels in odd indices.", "    =\
    \ length(s)*sum((s[i] >= 'A' and s[i] <= 'Z')? 1 : 0 for i in [0,1,-1]) \nend",
  "    if count(s, 0, length(s)) % 2 == 0 \n        then count(s, 0, length(s)) \n\
    \        else 0\n    else 0\nend\n</cell>\n<code language=julia-1.4>\ncount_upper(\"\
    aBCdEf\")\n</cell>\n<text>\nWrite a function that checks whether a string contains\
    \ only alphanumeric characters.", "    |=1\n    for i in 2 to s.length()\n   \
    \     case(s[i..i-1]) in\n            case(\"AEIOUaeiou\")\n                |+\n\
    \                count_upper(s[i..i-1])\n            case(\"AEIOUaeiou\")\n  \
    \              |+\n                count_upper(s[i..i-1])\n            case(\"\
    AEIOUaeiou\")\n                |+\n                count_upper(s[i..i-1])\n  \
    \          case(\"AEIOUaeiou\")\n                |+\n                count_upper(s[i..i-1])\n\
    \            case(\"AEIOUaeiou\")\n                |+\n                count_upper(s[i..i-1])\n\
    \            case(\"AEIOUaeiou\")\n                |+\n                count_upper(s[i..i-1])\n\
    \            case(\"AEIOUaeiou\")\n                |+\n                count_upper(s[i..i-1])\n\
    \            case(\"AEIOUaeiou\")\n                |+\n                count_upper(s[i..i-1])\n\
    \            case(\"AEIOUaeiou\")\n                |+\n                count_upper(s[i..i-1])\n\
    \            case(\"AEIOUaeiou\")\n                |+\n                count_upper(s[i..i-1])\n\
    \            case(\"AEIOUaeiou\")\n                |+\n                count_upper(s[i..i-1])\n\
    \            case(\"AEIOUaeiou\")\n                |+\n                count_upper(s[i..i-1])\n\
    \            case(\"AEIOUaeiou\")\n                |+\n                count_upper(s[i..i-1])\n\
    \            case(\"AEIOUaeiou\")\n                |+\n                count_upper(s[i..i-1])\n\
    \            case(\"AEIOUaeiou\")\n                |+\n                count_upper(s[i..i-1])\n\
    \            case(\"AEIOUaeiou\")\n                |+\n                count_upper(s[i..i-1])\n\
    \            case(\"AEIOUaeiou\")\n                |+\n                count_upper(s[i..i-1])\n\
    \            case(\"AEIOUaeiou\")\n                |+\n                count_upper(s[i..i-1])\n\
    \            case(\"AEIOUaeiou\")\n                |+\n                count_upper(s[i..i-1])\n\
    \            case(\"AEIOUaeiou\")\n                |+\n                count_upper(s[i..i-1])\n\
    \            case(\"AEIOUaeiou\")\n                |+\n                count_upper(s[i..i-1])\n\
    \            case(\"AEIOUaeiou\")\n", "    if length(s) <= 0 \n        0 \n  \
    \  else if substring(s, 1, 2) == \"AEIOUaeiou\" \n        1 \n    else\n     \
    \   0 \nend\n</cell>\n<text>\nExercise:\nWrite a function that counts the number\
    \ of uppercase vowels in a given string. Test it on the following inputs:", " \
    \   \n    if null s then \n        return 0 \n    else if length(s)%2 == 1 then\
    \ \n        return 0 \n    else if substring(s, 2, 2)==\"A\" or substring(s, 2,\
    \ 2)==\"a\" then \n        return 1 \n    else if substring(s, 2, 2)==\"B\" or\
    \ substring(s, 2, 2)==\"b\" then \n        return 1 \n    else if substring(s,\
    \ 2, 2)==\"C\" or substring(s, 2, 2)==\"c\" then \n        return 1 \n    else\
    \ if substring(s, 2, 2)==\"D\" or substring(s, 2, 2)==\"d\" then \n        return\
    \ 1 \n    else if substring(s, 2, 2)==\"E\" or substring(s, 2, 2)==\"e\" then\
    \ \n        return 1 \n    else if substring(s, 2, 2)==\"F\" or substring(s, 2,\
    \ 2)==\"f\" then \n        return 1 \n    else if substring(s, 2, 2)==\"G\" or\
    \ substring(s, 2, 2)==\"g\" then \n        return 1 \n    else if substring(s,\
    \ 2, 2)==\"H\" or substring(s, 2, 2)==\"h\" then \n        return 1 \n    else\
    \ if substring(s, 2, 2)==\"I\" or substring(s, 2, 2)==\"i\" then \n        return\
    \ 1 \n    else if substring(s, 2, 2)==\"J\" or substring(s, 2, 2)==\"j\" then\
    \ \n        return 1 \n    else if substring(s, 2, 2)==\"K\" or substring(s, 2,\
    \ 2)==\"k\" then \n        return 1 \n    else if substring(s, 2, 2)==\"L\" or\
    \ substring(s, 2, 2)==\"l\" then \n        return 1 \n    else if substring(s,\
    \ 2, 2)==\"M\" or substring(s, 2, 2)==\"m\" then \n        return 1 \n    else\
    \ if substring(s, 2, 2)==\"N\" or substring(s, 2, 2)==\"n\" then \n        return\
    \ 1 \n    else if substring(s, 2, 2)==\"O\" or substring(s, 2, 2)==\"o\" then\
    \ \n        return 1 \n    else if substring(s, 2, 2)==\"P\" or substring(s, 2,\
    \ 2)==\"p\" then \n        return 1 \n    else if substring(s, 2, 2)==\"Q\" or\
    \ substring(s, 2, 2)==\"q\" then \n        return 1 \n    else if substring(s,\
    \ 2, 2)==\"R\" or substring(s, 2, 2)==\"r\" then \n        return 1 \n    else\
    \ if substring(s, 2, 2)==\"S\" or substring(s, 2, 2)==\"s\" then \n        return\
    \ 1 \n    else if substring(s, 2, 2)==\"T\" or substring(s, 2, 2)==\"t\" then\
    \ \n        return 1 \n    else if substring(s, 2, 2)==\"U\" or substring(s, 2,\
    \ 2)==\"u\" then \n        return 1 \n    else if substring(s, 2, 2)==\"V\" or\
    \ substring(s, 2, 2)==\"v\" then \n        return 1 \n    else if substring(s,\
    \ 2, ", "    let\n        upper_counts = Counter([\n            if i % 2 == 0\
    \ then\n                c in \"AEIOUaeiou\"\n            else\n              \
    \  false\n            end\n            for (i, c) in enumerate(s)\n        ])\n\
    \    return sum(1 for k in upper_counts if upper_counts[k])\nend\n</cell>\n<code\
    \ language=julia-1.6>\n# tests\n@test count_upper(\"aBCdEf\") == 1\n@test count_upper(\"\
    abcdefg\") == 0 \n@test count_upper(\"dBBE\") == 0 \n</cell>\n<text>\nThe function\
    \ count_lower counts the number of lowercase vowels:", "    if length(s)==0\n\
    \        0\n    else if length(s)==1\n        if head(s,1)==\"A\" or head(s,1)==\"\
    a\" or head(s,1)==\"O\" or head(s,1)==\"o\"\n            1\n        else\n   \
    \         0\n    else\n        count_upper(tail(s,1))\nend", "    if length(s)%2==0\
    \ \n    then \n        let n = length(s)/2\n        count_upper(s[0..n-1])\n \
    \   else \n        return 0\nend\n</cell>\n<code language=julia-0.6>\n\"\"\"\n\
    \    count_lower(s)\n    Count number of lower case vowels in string s.\n    \n\
    \    For example:\n    >>> count_lower(\"aBCdEf\")\n    3\n    >>> count_lower(\"\
    abcdefg\")\n    3\n    >>> count_lower(\"dBBE\")\n    0\n    \"\"\"", "    result\
    \ <- 0\n    for i <- 0 to length(s) do\n        if s[i] >= 'A' and s[i] <= 'Z'\
    \ then\n            result <- result + 1\n    return result\nend", "    if is_str(s)\
    \ && s.length>0\n        if is_str(s[0]) && is_str(s[1]) && is_str(s[2]) && is_str(s[3])\n\
    \            if is_str(s[4]) && is_str(s[5]) && is_str(s[6]) && is_str(s[7])\n\
    \                if is_str(s[8]) && is_str(s[9]) && is_str(s[10]) && is_str(s[11])\n\
    \                    if is_str(s[12]) && is_str(s[13]) && is_str(s[14]) && is_str(s[15])\n\
    \                        if is_str(s[16]) && is_str(s[17]) && is_str(s[18]) &&\
    \ is_str(s[19])\n                            if is_str(s[20]) && is_str(s[21])\
    \ && is_str(s[22]) && is_str(s[23])\n                                if is_str(s[24])\
    \ && is_str(s[25]) && is_str(s[26]) && is_str(s[27])\n                       \
    \             return count_upper(s[28])\n                                end\n\
    \                            end\n                        end\n              \
    \      end\n                end\n            end\n        end\n    end\nend\n\
    </code>\n<|/ a tags=julia,string |>\n<| a dscore=2 |>\nHere's a solution that\
    \ uses string slicing (similar to R's answer, but in julia):\n<code>", "    if\
    \ is_empty(s),\n        return 0\n    \n    let mut cnt = 0\n    for i in 0..length(s)\
    \ {\n        if s[i] == char.upper(s[i]) {\n            cnt += 1\n        }\n\
    \        if i % 2 == 0 && cnt > 0 {\n            return cnt\n        }\n    }\n\
    \    \n    return cnt\nend", "    | s.length == 0 = error(\"Cannot count uppercase\
    \ letters of empty string\")\n    | s.length == 1 = 1\n    | s ~~ \"[AEIOUaeiou]\"\
    \ &&\n       even(i) && count_upper(substring(s,i+1)) \n    = count_upper(substring(s,i+1))\n\
    \    | s ~~ \"[AEIOUaeiou]\" &&\n       odd(i) && count_upper(substring(s,i+1))\
    \ \n    = count_upper(substring(s,i+1))\n    | s ~~ \"[^AEIOUaeiou]\" &&\n   \
    \    even(i) && count_upper(substring(s,i+1)) \n    = count_upper(substring(s,i+1))\n\
    \    | s ~~ \"[^AEIOUaeiou]\" &&\n       odd(i) && count_upper(substring(s,i+1))\
    \ \n    = count_upper(substring(s,i+1))\n    | s ~~ \"[AEIOUaeiouAEIOUaeiou]\"\
    \ &&\n       even(i) && count_upper(substring(s,i+2)) \n    = count_upper(substring(s,i+2))\n\
    \    | s ~~ \"[AEIOUaeiouAEIOUaeiou]\" &&\n       odd(i) && count_upper(substring(s,i+2))\
    \ \n    = count_upper(substring(s,i+2))\n    | otherwise = count_upper(substring(s,1,length(s)-1))\n\
    end\n</cell>\n<text>\ncount_lower\nGiven a string s, count the number of lowercase\
    \ vowels in even indices.", "    if s.length < 2 \n        then 0\n    else if\
    \ s[0] == \"A\" && s[1] == \"a\" && s[2] == \"a\"\n        then 1\n    elif s[0]\
    \ == \"a\" && s[1] == \"b\" && s[2] == \"c\"\n        then 1\n    elif s[0] ==\
    \ \"b\" && s[1] == \"c\" && s[2] == \"d\"\n        then 1\n    elif s[0] == \"\
    c\" && s[1] == \"d\" && s[2] == \"e\"\n        then 1\n    elif s[0] == \"d\"\
    \ && s[1] == \"e\" && s[2] == \"f\"\n        then 1\n    else if s[0] == \"e\"\
    \ && s[1] == \"f\" && s[2] == \"g\"\n        then 1\n    else 0\nend\n</cell>\n\
    <code language=julia-0.6>\nusing Test\n@test count_upper(\"aBCdEf\") == 1\n@test\
    \ count_upper(\"abcdefg\") == 0\n@test count_upper(\"dBBE\") == 0\n</cell>\n<text>\n\
    Exercise 1\nWrite a function count_even, which takes a string s as an argument\
    \ and returns an integer\nindicating how many characters in s, when counted with\
    \ count_upper, have an even index.", "    # Complete this function\n    return\
    \ 0\nend\n</cell>\n<code language=julia-0.6>\n## Test it out\n</cell>\n<code language=julia-0.6>\n\
    @assert count_upper(\"aBCdEf\") == 1\n@assert count_upper(\"abcdefg\") == 0\n\
    @assert count_upper(\"dBBE\") == 0 \n</cell>\n<text>\n2.3\_Examine Julia's built-in\
    \ types and their constructors.", "    count = 0\n    for i in eachindex(s)\n\
    \        if s[i] == \"A\" ||\n           s[i] == \"E\" ||\n           s[i] ==\
    \ \"I\" ||\n           s[i] == \"O\" ||\n           s[i] == \"U\"\n        then\n\
    \            count += 1\n    end\n    return count", "    if all(letter in \"\
    aA\" for letter in s) \n        return (letter == \"A\") * count_upper(s[1..end])\
    \ \n    else \n        count_upper(s[0..end-1])\nend\n</cell>\n<code language=julia-1.3>\n\
    #hide\n\"\"\"\n    Given a string s, count the number of uppercase vowels in even\
    \ indices.\n    \n    For example:\n    >>> count_upper(\"aBCdEf\")\n    1\n \
    \   >>> count_upper(\"abcdefg\")\n    0\n    >>> count_upper(\"dBBE\")\n    0\n\
    \    \"\"\"", "    if is_lowercase(s);\n    else 0;\n    let mut cnt = 0;\n  \
    \  for i in 0..length(s);\n    do cnt += if is_uppercase(s[i .. i +2]);\n    return\
    \ cnt;\nend count_upper;\n</cell>\n<text>\nPart B", "    \n    if is_empty(s)\n\
    \        return 0\n    \n    let vowels = \"aeiou\"\n    let vowel_position =\
    \ vowels.findIndex{|v| v == s[0,1]}\n    if vowel_position == -1\n        return\
    \ 0\n    else\n        if vowel_position % 2 == 0\n            return 1\n    \
    \    else\n            return 0\n    end\nend\n</cell>\n<text>\nSolution\nFill\
    \ out your solution below:", "    if s == \"\" then 0 else count_upper(substring(s,\
    \ 2)) + count_upper(substring(s, 4))\nend\n</cell>\n<text>\nExercise 10 (bonus\
    \ points: write the implementation in the functional programming style!)", " \
    \   if s == \"\"\n        return 0 \n    let counts = Vector{Int}()\n    for i\
    \ in eachindex(s)\n        if isupper(s[i])\n            counts[i - 1] += 1\n\
    \    return counts[end-2]\nend", "  | (s.length>0) -> count_upper_aux(s,0) \n\
    \  | (s.length==0) -> (0)\nend", "    cnt_upper = 0\n    for ch in s\n       \
    \ if ch == 'A'\n            cnt_upper += 1\n        elif ch == 'B'\n         \
    \   cnt_upper += 1\n        elif ch == 'C'\n            cnt_upper += 1\n     \
    \   elif ch == 'D'\n            cnt_upper += 1\n        elif ch == 'E'\n     \
    \       cnt_upper += 1\n        elif ch == 'F'\n            cnt_upper += 1\n \
    \       elif ch == 'G'\n            cnt_upper += 1\n        else\n           \
    \ cnt_upper\n    end\n    cnt_upper\nend\n</cell>\n<code language=julia-1.0>\n\
    #=\nExample input \"abcdefg\"\n=#\n</cell>\n<code language=julia-1.0>\n#=\nExample\
    \ output \"1\"\n=#\n</cell>\n<code language=julia-1.0>\n#=\nExample input \"AbCdEf\"\
    \n=#\n</cell>\n<code language=julia-1.0>\n#=\nExample output \"1\"\n=#\n</cell>\n\
    <code language=julia-1.0>\n#=\nExample input \"dBBE\"\n=#\n</cell>\n<code language=julia-1.0>\n\
    #=\nExample output \"0\"\n=#\n</cell>\n<code language=julia-1.0>\n#=\nExample\
    \ input \"dBBE\"\n=#\n</cell>\n<code language=julia-1.0>\n#=\nExample output \"\
    1\"\n=#\n</cell>\n<code language=julia-1.0>\n#=\nExample input \"aaaBBBccc\"\n\
    =#\n</cell>\n<code language=julia-1.0>\n#=\nExample output \"3\"\n=#\n</cell>\n\
    <code language=julia-1.0>\n#=\nExample input \"aaaBBBccc\"\n=#\n</cell>\n<code\
    \ language=julia-1.0>\n#=\nExample output \"3\"\n=#\n</cell>\n<code language=julia-1.0>\n\
    #=\nExample input \"aaaBBBccc\"\n=#\n</cell>\n<code language=julia-1.0>\n#=\n\
    Example output \"3\"\n=#\n</cell>\n<code language=julia-1.0>\n#=\nExample input\
    \ \"aBBBccc\"\n=#\n</cell>\n<code language=julia-1.0>\n#=\nExample output \"4\"\
    \n=#\n</cell>\n<code language=julia-1.0>\n#=\nExample input \"aBBBccc\"\n=#\n\
    </cell>\n<code language=julia-1.0>\n#=\nExample ", "    count = 0\n    for c in\
    \ s:\n        if c == c.upper():\n            if c.upper() in \"AEIOUYaeiou\"\
    :\n                count += 1\n    return count\n\"\"\"\n    Given a string s,\
    \ count the number of uppercase vowels in odd indices.\n    \n    For example:\n\
    \    >>> count_upper_odd(\"dBCaEf\")\n    1\n    >>> count_upper_odd(\"abcdefg\"\
    )\n    0\n    >>> count_upper_odd(\"dBBE\")\n    0\n    \"\"\"", "    if null\
    \ s then 0 \n    else if even (head s) then 1 + count_upper (tail s) \n    else\
    \ count_upper (tail s) \n    end\nend\n</cell>\n<code language=julia-0.5>\ncount_upper(\"\
    aBCdEf\")\n</cell>\n<code language=julia-0.5>\ncount_upper(\"abcdefg\")\n</cell>\n\
    <code language=julia-0.5>\ncount_upper(\"dBBE\")\n</cell>\n<text>\nExercise 3\n\
    Write a function to reverse a string in place.  It should work on a vector of\
    \ strings or a single string (and will error on strings that have odd length).\
    \  For example, string(\"abc\") should give us \"cba\".", "    if length(s)==0\
    \ then \n        0\n    elseif length(s)==1 then \n        if upper(head(s)) then\
    \ 1\n        else 0\n    elseif upper(head(s)) and count_upper(tail(s)) then \n\
    \        1 + count_upper(tail(s))\n    else\n        count_upper(tail(s))\nend\n\
    \"\"\"\n    Given a string s, count the number of lowercase vowels in even indices.\n\
    \    \n    For example:\n    >>> count_lower(\"aBCdEf\")\n    1\n    >>> count_lower(\"\
    abcdefg\")\n    0\n    >>> count_lower(\"dBBE\")\n    0\n    \"\"\"", "    count=0\n\
    \    idx=0\n    for c in s \n        if c==\"a\"\n            count+=1\n     \
    \   else if c==\"e\"\n            count+=1\n        else if c==\"d\"\n       \
    \     count+=1\n        else if c==\"b\"\n            count+=1\n        else if\
    \ c==\"f\"\n            count+=1\n        else if c==\"g\"\n            count+=1\n\
    \        else if c==\"h\"\n            count+=1\n        else if c==\"j\"\n  \
    \          count+=1\n        else if c==\"k\"\n            count+=1\n        else\
    \ if c==\"l\"\n            count+=1\n        else if c==\"m\"\n            count+=1\n\
    \        else if c==\"n\"\n            count+=1\n        else if c==\"p\"\n  \
    \          count+=1\n        else if c==\"q\"\n            count+=1\n        else\
    \ if c==\"r\"\n            count+=1\n        else if c==\"s\"\n            count+=1\n\
    \        else if c==\"t\"\n            count+=1\n        else if c==\"v\"\n  \
    \          count+=1\n        else if c==\"x\"\n            count+=1\n        else\
    \ if c==\"y\"\n            count+=1\n        else if c==\"z\"\n            count+=1\n\
    \        else if c==\"A\"\n            count+=1\n        else if c==\"E\"\n  \
    \          count+=1\n        else if c==\"D\"\n            count+=1\n        else\
    \ if c==\"B\"\n            count+=1\n        else if c==\"F\"\n            count+=1\n\
    \        else if c==\"G\"\n            count+=1\n        else if c==\"H\"\n  \
    \          count+=1\n        else if c==\"J\"\n            count+=1\n        else\
    \ if c==\"K\"\n            count+=1\n        else if c==\"L\"\n            count+=1\n\
    \        else if c==\"M\"\n            count+=1\n        else if c==\"N\"\n  \
    \          count+=1\n        else if c==\"P\"\n            count+=1\n        else\
    \ if c==\"Q\"\n            count+=1\n        else if c==\"R\"\n            count+=1\n\
    \        else if c==\"S\"\n            count+=1\n        else if c==\"T\"\n  \
    \          count+=1\n        else if c==\"V\"\n            count+=1\n        else\
    \ if c==\"X\"\n            count+=1\n        else if c==\"Y\"\n            count+=1\n\
    \        else if c==\"Z\"\n            count+=1\n    return count\n\"\"\"\n  \
    \  Given a string s, count the number of lowercase vowels in even indices.\n \
    \   \n    For example:\n    >>> count_lower(\"aBCdEf\")\n    0\n    >>> count_lower(\"\
    abcdefg\")\n    1\n    >>> count_lower(\"", "    if length(s)==0 \n        0\n\
    \    else \n        if isupper(s[1]) \n            count_upper(s[2:])\n      \
    \  else \n            count_upper(s[2:end-1])\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\n    count_lower(s::String)::Int64", "    if is_string(s) && length(s)\
    \ >= 4\n        if is_lower(s)\n            count_upper_even(s)\n        else\n\
    \            count_upper_odd(s)\n        end\n    else\n        error(\"not a\
    \ valid string\")\n    end\nend\n</cell>\n<text>\ncount_uppercase", "    s = 0\n\
    \    for i in reverse(s) {\n        if i =! A && i =! E && i =! I && i =! O &&\
    \ i =! U\n            s += 1\n    }\n    return s\nend", "    count = 0\n    forall(i,\
    \ s[i] == 'A' || s[i] == 'a' | s[i] == 'B' || s[i] == 'b' | s[i] == 'C' || s[i]\
    \ == 'c' | s[i] == 'D' || s[i] == 'd' | s[i] == 'E' || s[i] == 'e' | s[i] == 'F'\
    \ || s[i] == 'f' | s[i] == 'G' || s[i] == 'g')\n        count = count + 1\n  \
    \  return count\nend", "    | s == '' = 0\n    | even <- 0 = 1\n    | even < even\
    \ = count_upper(s[2::Int64])\n    | even > even = count_upper(s[2::Int64]+s[::Int64])\n\
    \    | otherwise =\n        if isupper(s[0])\n            then count_upper(s[2::Int64]+s[::Int64])\n\
    \            else 0\n        end\n\"\"\"\n    Given a string s, count the number\
    \ of letters in even indices.\n    \n    For example:\n    >>> count_letters(\"\
    aBCdEf\")\n    1\n    >>> count_letters(\"abcdefg\")\n    2\n    >>> count_letters(\"\
    dBBE\")\n    0\n    \"\"\"", "    if is_upper(s)\n        count_upper_recursive(s,\
    \ 0)\n    else \n        count_upper_recursive(s[1..], 0)\n    end\nend", "  \
    \  # count the number of uppercase vowels in even indices\n    count = 0\n   \
    \ for i in s.char_indices()\n        if i[1] % 2 == 0\n            count += 1\n\
    \    return count", "\"\"\"\n    Count the number of uppercase vowels in a string\n\
    \"\"\"\n    if iseven(s:sub(1,end)):\n        return count_upper(s:sub(2,end))\
    \ +count_upper(s:sub(3,end))\n    if s.end==length(s)\n        return count_upper(s:sub(1,end))\n\
    \    return 0\nend\n</cell>\n<code language=julia-1.3>", "    if length(s)==0\
    \ \n        0 \n    elseif length(s)==1 \n        if isupper(s[0])\n         \
    \   1 \n        else\n            0 \n    elseif isupper(s[1])\n        count_upper(s[2:end])\n\
    \    else\n        count_upper(s[2:end-1]) + count_upper(s[1:end])\nend\n</cell>\n\
    <text>\nPutting it all together\nThe following function takes a string and returns\
    \ the number of uppercase vowels in even indices.", "    | s == \"aa\" => 1\n\
    \    | s == \"bb\" => 1\n    | s == \"cc\" => 1\n    | s == \"dd\" => 1\n    |\
    \ s == \"ee\" => 1\n    | s == \"ff\" => 1\n    | s == \"gg\" => 1\n    | s ==\
    \ \"hh\" => 1\n    | s == \"ii\" => 1\n    | s == \"jj\" => 1\n    | s == \"kk\"\
    \ => 1\n    | s == \"ll\" => 1\n    | s == \"mm\" => 1\n    | s == \"nn\" => 1\n\
    \    | s == \"oo\" => 1\n    | s == \"pp\" => 1\n    | s == \"qq\" => 1\n    |\
    \ s == \"rr\" => 1\n    | s == \"ss\" => 1\n    | s == \"tt\" => 1\n    | s ==\
    \ \"uu\" => 1\n    | s == \"vv\" => 1\n    | s == \"ww\" => 1\n    | s == \"xx\"\
    \ => 1\n    | s == \"yy\" => 1\n    | s == \"zz\" => 1\n    | s == \"aa\" => 1\n\
    \    | s == \"bb\" => 1\n    | s == \"cc\" => 1\n    | s == \"dd\" => 1\n    |\
    \ s == \"ee\" => 1\n    | s == \"ff\" => 1\n    | s == \"gg\" => 1\n    | s ==\
    \ \"hh\" => 1\n    | s == \"ii\" => 1\n    | s == \"jj\" => 1\n    | s == \"kk\"\
    \ => 1\n    | s == \"ll\" => 1\n    | s == \"mm\" => 1\n    | s == \"nn\" => 1\n\
    \    | s == \"oo\" => 1\n    | s == \"pp\" => 1\n    | s == \"qq\" => 1\n    |\
    \ s == \"rr\" => 1\n    | s == \"ss\" => 1\n    | s == \"tt\" => 1\n    | s ==\
    \ \"uu\" => 1\n    | s == \"vv\" => 1\n    | s == \"ww\" => 1\n    | s == \"xx\"\
    \ => 1\n    | s == \"yy\" => 1\n    | s == \"zz\" => 1\n    | s == \"aa\" => 1\n\
    \    | s == \"bb\" => 1\n    | s == \"cc\" => 1\n    | s == \"dd\" => 1\n    |\
    \ s == \"ee\" => 1\n    | s == \"ff\" => 1\n    | s == \"gg\" => 1\n    | s ==\
    \ \"hh\" => 1\n    | s == \"ii\" => 1\n    | s == \"jj\" => 1\n    | s == \"kk\"\
    \ => 1\n    | s == \"ll\" => 1\n", "| s = 0\n| for i in s\n|   if i mod 2 =! 0\n\
    |     s += 1\n|   end\n| end\n</code>\n<|/ a dscore=2 |>\n<| a tags=string,performance,count,haskell\
    \ |>\n<code>\nimport Data.List.Split (split)\nimport Data.List.Split (splitOn)",
  "    if s.is_empty\n        0\n    else if length(s) mod 2\n        count_upper(s[1..-1])\
    \ +\n        count_upper(s[0..-2]) + \n        count_upper(s[-1..-1])\n    else\n\
    \        count_upper(s[1..-1]) +\n        count_upper(s[0..-2])\n    end\nend\n\
    </code>\n<|/ a dscore=3 tags=string,julia |>\n<| a |>\nHere's an alternative solution\
    \ which uses a single for loop. The only difference is that it is able to handle\
    \ empty strings (empty arrays []) properly.\n<code>", "    count_upper <- 0\n\
    \    for c in s \n        if isupper(c) && c mod 2 == 0 \n            count_upper\
    \ <- count_upper + 1\n    return count_upper\nend\n</cell>\n<code language=julia-0.5>\n\
    count_upper(\"aBCdEf\")\n</cell>\n<code language=julia-0.5>\ncount_upper(\"abcdefg\"\
    )\n</cell>\n<code language=julia-0.5>\ncount_upper(\"dBBE\")\n</cell>\n<text>\n\
    Exercise 5 - count_vowels\nWrite a function that takes a string and returns the\
    \ number of vowels in it.", "    if s == \"\"\n        return 0\n    \n    let\
    \ n = 0\n    let i = 0\n    for j in 0 .. s.length - 1\n        if char_is_upper(s.[j])\
    \ && s.[i] >= 'A' && s.[i] <= 'Z'\n            && char_is_upper(s.[j+1])\n   \
    \         then n = n + 1\n            i = i + 1\n    return n\nend\n</cell>\n\
    <code language=julia-0.6>\ncount_upper(\"aBCdEf\")\n</cell>\n<text>\nExercise\
    \ 5\nGiven the string ss, replace each substring with the substring \"a\" followed\
    \ by the index of this letter in the alphabet.", "    if is_empty(s) then return\
    \ 0\n    else if s[0] == 'a' && s[1] == 'b' then return 2\n    else if s[0] ==\
    \ 'A' && s[1] == 'B' then return 2\n    else if s[0] == 'A' && s[1] == 'C' then\
    \ return 3\n    else if s[0] == 'a' && s[1] == 'C' then return 3\n    else if\
    \ s[0] == 'd' && s[1] == 'B' then return 2\n    else if s[0] == 'D' && s[1] ==\
    \ 'B' then return 2\n    else if s[0] == 'D' && s[1] == 'E' then return 3\n  \
    \  else if s[0] == 'd' && s[1] == 'E' then return 3\n    else if s[0] == 'f' &&\
    \ s[1] == 'B' then return 2\n    else if s[0] == 'F' && s[1] == 'B' then return\
    \ 2\n    else if s[0] == 'F' && s[1] == 'E' then return 3\n    else if s[0] ==\
    \ 'f' && s[1] == 'E' then return 3\n    else return 0\nend\n</cell>\n<text>\n\
    Exercise\nImplement the function count_all_uppercase below.", "\"\"\"\n    Given\
    \ a string s, count the number of uppercase vowels in even indices.\n    \n  \
    \  For example:\n    >>> count_upper(\"aBCdEf\")\n    1\n    >>> count_upper(\"\
    abcdefg\")\n    0\n    >>> count_upper(\"dBBE\")\n    0\n    \"\"\"", "    count_upper\
    \ := 0\n    for i in 2 to length(s) do\n        if is_uppercase(substr_lower(s,i,i))\n\
    \            then count_upper := count_upper + 1\n        end\n    end\n    return\
    \ count_upper\nend\n</cell>\n<cell>", "</code>\n(which has nothing to do with\
    \ the code above).\n<|/ a dscore=2 tags=recursion,string,haskell,pattern-matching,algorithm\
    \ |>\n<| a tags=recursion,string,haskell,pattern-matching,algorithm dscore=1 |>\n\
    You can use list comprehension to filter out the vowels and then use length to\
    \ get the amount of items in the filtered list\n<code>\nvowels = [\"a\", \"e\"\
    , \"i\", \"o\", \"u\"]\ninput = [\"a\", \"BC\", \"def\"]", "    r \u2190 0\n \
    \   for ch in s do\n        if ch == 'A' ||\n           ch == 'E' ||\n       \
    \    ch == 'I' ||\n           ch == 'O' ||\n           ch == 'U' then\n      \
    \      r \u2190 r + 1\n        end\n    end\n    return r\nend\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that takes a string and returns the first occurrence\
    \ of 'A' or 'a' in the string. If there is no occurrence of this character, return\
    \ \"\".", "        match s:substr_len(0,2) with\n            \"a\" => 1\n    \
    \        \"A\" => 1\n            \"b\" => 1\n            \"B\" => 1\n        \
    \    \"c\" => 1\n            \"C\" => 1\n            \"d\" => 1\n            \"\
    D\" => 1\n            \"e\" => 1\n            \"E\" => 1\n            \"f\" =>\
    \ 1\n            \"F\" => 1\n            \"g\" => 1\n            \"G\" => 1\n\
    \            _ => 0\n        end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\
    \"\n    count_upper(s::String)", "</code>\nSolution\n<code>\nlet count_upper(s::String)::Int64\
    \ = \n  sum(1 for c in s if c in \"AEIOUaeiou\")\n</code>\nor\n<code>\nlet count_upper(s::String)::Int64\
    \ = \n  sum(1 for c in s if c.is_uppercase())\n</code>\n<|/ a |>\n<| a tags=julia\
    \ |>\nHere is a version that works with unicode characters (in addition to ASCII)\n\
    <code>", "        \n    for c in s do\n        if c == 'A' || c == 'E' || c ==\
    \ 'I' || c == 'O' || c == 'U' then\n            return 1\n        elseif c ==\
    \ 'B' then\n            return 0\n        end\n    end\n    return 0\nend\n</cell>\n\
    <code language=julia-1.6>\n\"\"\"\n    Given a string s, count the number of lowercase\
    \ vowels in even indices.\n    \n    For example:\n    >>> count_lower(\"aBCdEf\"\
    )\n    1\n    >>> count_lower(\"abcdefg\")\n    0\n    >>> count_lower(\"dBBE\"\
    )\n    1\n    \"\"\"", "    count_upper_helper(s,\"\",0,0)\nend\n    ", "    s\
    \ = toupper(s).trim()\n    even_idx = 0\n    even_chars = Vector{Char}[s]\n  \
    \  for i in even_chars\n        if isupper(i)\n            even_idx += 1\n   \
    \     end\n    end\n    \n    return even_idx\nend\n</cell>\n<code language=julia-1.6>\n\
    \"\"\"\n    Given a string s, count the number of uppercase vowels in odd indices.\n\
    \    \n    For example:\n    >>> count_upper(\"aBCdEf\")\n    2\n    >>> count_upper(\"\
    abcdefg\")\n    0\n    >>> count_upper(\"dBBE\")\n    0\n    \"\"\"", "    \n\
    \    result <- 0\n    for i <- 1:length(s) \n        if mod(i, 2)==0 then \n \
    \           if s[i]=='a' || s[i]=='e' || s[i]=='i' || s[i]=='o' || s[i]=='u' then\
    \ \n                result <- result + 1\n        end\n    end\n    return result\n\
    end\n</cell>\n<code language=julia-1.5>\n@time count_upper(\"aBCdEf\")\n</cell>\n\
    <code language=julia-1.5>\n@time count_upper(\"abcdefg\")\n</cell>\n<text>\nPractice\
    \ 1\nWrite a function that counts the number of characters that are divisible\
    \ by 3.", "    if s.length==0\n        0\n    else if s.length==1\n        0\n\
    \    else if s[0]==s[1]\n        0\n    else\n        count_upper(substring(s,1,s.length))\
    \ + count_upper(substring(s,2,s.length))\nend\n</cell>\n<text>\nExercise\nWrite\
    \ a function that returns a list that contains the number of occurrences of every\
    \ word in the given string words. Your function should return a list with as many\
    \ elements as there are words in the given string and whose elements are the corresponding\
    \ counts.", "    if (s.length==0)\n        0\n    else if (s.length==1)\n    \
    \    if (s[0]>='A' && s[0]<='Z')\n            1\n        else\n            0\n\
    \    else\n        count_upper(substring(s,0,1)) + count_upper(substring(s,1))\n\
    end function count_upper", "    \n    \"\"\"\n    This function should return\
    \ the count of uppercase vowels in odd indices\n    in s.\n    \n    For example:\n\
    \    >>> count_upper(\"aBCdEf\")\n    1\n    >>> count_upper(\"abcdefg\")\n  \
    \  0\n    >>> count_upper(\"dBBE\")\n    0\n    \"\"\"\n    \n    vowels = \"\
    aeiou\"\n    count = 0\n    for i in s:\n        if i in vowels:\n           \
    \ count = count + 1\n        elif i in \"AEIOU\":\n            count = count -\
    \ 1\n    return count\n</cell>\n<text>\nExercise 12: count_vowels\nComplete the\
    \ function count_vowels below to return the count of vowels\nin s. Your function\
    \ should return the number of vowels in s.\nTest your function on a few examples:",
  "    \"\"\"\n    >>> count_upper(\"aBCdEf\")\n    1\n    >>> count_upper(\"abcdefg\"\
    )\n    0\n    >>> count_upper(\"dBBE\")\n    0\n    \"\"\"\n    return s.isupper()\
    \ \\\n           .filter(str.isalpha) \\\n           .filter(str.isdigit) \\\n\
    \           .filter(str.islower()) \\\n           .filter(str.isupper()).length",
  "    if (s.length == 0) \n        return 0 \n    if (s.length % 2 == 0) \n     \
    \   return 0 \n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"] \n    let\
    \ mut cnt = 0 \n    for x in s \n        let i = index x vowels \n        if i\
    \ >= 0 && i != s.length \n            && (i % 2 == 0 || x == vowels[i])\n    \
    \        && x != vowels[i / 2] \n        then cnt += 1 \n    return cnt ", " \
    \   s = lowercase(s);\n    s = filter( (c:Char)=>c=='A' || c=='E' || c=='I' ||\
    \ c=='O' || c=='U' , s);\n    filter( (c:Char)=>c == 'A' || c=='E' || c=='I' ||\
    \ c=='O' || c=='U' || c=='a' || c=='e' || c=='i' || c=='o' || c=='u' , s);\n \
    \   count( (c:Char)=>c == 'A' || c=='E' || c=='I' || c=='O' || c=='U' || c=='a'\
    \ || c=='e' || c=='i' || c=='o' || c=='u' , s)\nend\n</cell>\n<code language=julia-1.6>",
  "    \n    # Write your code here.\n    if length(s) == 0 then 0 else if length(s)\
    \ == 1 then 1 else count_upper(substring(s,2,end)) end\nend", "    if length(s)==0\n\
    \    else if substring(s,0,1)==\"a\"\n        then count_upper(substring(s,2))\n\
    \        else 0\n    end\nend", "    if length(s)==0 \n        return 0 \n   \
    \ else \n        i <- 1 \n        while i < length(s) \n            if s[i]>='a'\
    \ && s[i]<='z' \n                then return 1 \n            else \n         \
    \       i <- i + 1 \n        return 0 ", "    if all(is_upper(charAt(i)) for i\
    \ in 2..length(s)) \n        then \n            count_upper(substring(s, 2, length(s)-1))\n\
    \        else \n            0\n    end\nend\n</cell>\n<code language=julia-1.3>\n\
    @time count_upper(\"aBCdEf\")\n@time count_upper(\"abcdefg\")\n@time count_upper(\"\
    dBBE\")\n</cell>\n<text>\nCount total number of uppercase vowels in s.", "   \
    \ cdef long long i\n    if s is None:\n        return 0\n    for i in range(len(s)):\n\
    \        if s[i] == \"A\" or s[i] == \"E\" or s[i] == \"I\" or s[i] == \"O\" or\
    \ s[i] == \"U\":\n            if i % 2 == 1:\n                return 1\n    return\
    \ 0\n</code>\nThis gives the following results:\n<code>\njulia> count_upper(\"\
    aBCdEf\")\n1", "    \n    if length(s) == 0 \n        0\n    elseif length(s)\
    \ mod 2 == 0\n        length(s)/2\n    else\n        sum(is_upper(s[start:start+length(s)])\n\
    \        for start in 0:length(s)-1)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    count_upper(\"aBCdEf\")\n</cell>\n<code language=julia-1.5>\ncount_upper(\"abcdefg\"\
    )\n</cell>\n<code language=julia-1.5>\ncount_upper(\"dBBE\")\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\n    Given a string s, count the number of uppercase vowels in odd indices.\n\
    \    \n    For example:\n    >>> count_upper(\"aBCdEf\")\n    2\n    >>> count_upper(\"\
    abcdefg\")\n    3\n    >>> count_upper(\"dBBE\")\n    1\n    \"\"\"", "    count\
    \ = 0\n    for i in 0..(length(s)-2):\n        if s[i]==s[i+1] && s[i+1]==s[i+2]\
    \ && s[i+2] == s[i+3]\n        count += 4\n        i += 4\n    return count\n\
    end \n</cell>\n<code language=julia-1.5>\ncount_upper(\"aBCdEf\")\n</cell>\n<text>\n\
    count_lower", "    even_indices = map (\\(i) -> mod(i, 2)==0, collect(eachindex(s))\
    \ )\n    counts = count_even_indices(s, even_indices)\n    return counts\nend\
    \ \n</cell>\n<text>\ncounts_odd_indices", "   \n    count_upper = 0\n    for i\
    \ in (1 to length(s)-1)\n        if s[i - 1] == 'a' || s[i - 1] == 'e' || s[i\
    \ - 1] == 'i' || s[i - 1] == 'o' || s[i - 1] == 'u'\n            count_upper +=\
    \ 1\n    return count_upper", "    count = 0\n    for i in 0:length(s)\n     \
    \   if isupper(s[i]) and i%2 == 0\n            count += 1\n        end\n    end\n\
    \    return count\nend", "    count = 0\n    for c in s\n        if isuppercase(c)\n\
    \            count += 1\n    end\n    \n    return count\nend", "\"\"\"\n    Given\
    \ a string s, count the number of uppercase vowels in even indices.\n    \n  \
    \  For example:\n    >>> count_upper(\"aBCdEf\")\n    1\n    >>> count_upper(\"\
    abcdefg\")\n    0\n    >>> count_upper(\"dBBE\")\n    0\n\"\"\"", "\"\"\"\n  \
    \  Given a string s, count the number of uppercase vowels in even indices.\n \
    \   \n    For example:\n    >>> count_upper(\"aBCdEf\")\n    1\n    >>> count_upper(\"\
    abcdefg\")\n    0\n    >>> count_upper(\"dBBE\")\n    0\n    \"\"\"", "    for\
    \ i in (0..s.length-1)\n        if s[i].toUpper() == 'A' || s[i].toUpper() ==\
    \ 'E'\n            return 1\n    else 0\nend", "    cdef int count = 0\n    for\
    \ i in range(0, len(s)):\n        if s[i] == 'A' or s[i] == 'a':\n           \
    \ count += 1\n        else:\n            pass\n    return count", "    if s ==\
    \ \"\"\n    else if is_vowel(s[0], 1)\n        then count_upper(s[1..])\n    \
    \    else 0\n    else count_upper(s[1..])\n    end\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\nThere are a number of ways to approach this, but I like\
    \ using pattern matching, here's an example:\n<code>\nconst a = \"a\"\nconst b\
    \ = \"b\"\nconst c = \"c\"\nconst d = \"d\"\nconst e = \"e\"\nconst f = \"f\"\n\
    const g = \"g\"\nconst h = \"h\"\nconst i = \"i\"\nconst j = \"j\"\nconst k =\
    \ \"k\"\nconst l = \"l\"\nconst m = \"m\"\nconst n = \"n\"\nconst o = \"o\"\n\
    const p = \"p\"\nconst q = \"q\"\nconst r = \"r\"\nconst s = \"s\"\nconst t =\
    \ \"t\"\nconst u = \"u\"\nconst v = \"v\"\nconst w = \"w\"\nconst x = \"x\"\n\
    const y = \"y\"\nconst z = \"z\"", "\"\"\"\n    Given a string s, count the number\
    \ of uppercase vowels in even indices.\n    \n    For example:\n    >>> count_upper(\"\
    aBCdEf\")\n    1\n    >>> count_upper(\"abcdefg\")\n    0\n    >>> count_upper(\"\
    dBBE\")\n    0\n    \"\"\"", "    | s == \"\" = 0\n    | count_upper(subseq(s,\
    \ 0, 2)) + count_upper(subseq(s, 3, length(s)))\nend\n</cell>\n<code language=julia-0.4>\n\
    \"\"\"\n    count_upper(s::String)", "    if len(s) == 0\n        0\n    else\n\
    \        if isupper(s[0]) \n            if isupper(s[1]) \n                if\
    \ isupper(s[2])\n                    1\n                else \n              \
    \      0\n            else \n                if isupper(s[2])\n              \
    \      0\n                else \n                    0\n        else \n      \
    \      if isupper(s[2])\n                0\n            else \n              \
    \  if isupper(s[1])\n                    0\n                else \n          \
    \          0\n    \nend\n</cell>\n<code language=julia-0.6>\n@time count_upper(\"\
    aBCdEf\")\n@time count_upper(\"abcdefg\")\n@time count_upper(\"dBBE\")\n</cell>\n\
    <text>\nProblem 5\nLet's see if we can do this in Julia by writing a function\
    \ that counts the number of uppercase letters.", "  | (\n      count_upper_helper(s,\
    \ 1, true, 0)\n      |.(x => x == 0)\n      |.length\n  )\nend", "    \n    count=0\n\
    \    for x in 0 .. length(s)-2\n        if s(x)=='a'||s(x)=='e'||s(x)=='i'||s(x)=='o'||s(x)=='u'\n\
    \            count+=1 \n        end\n    end\n    return count\nend", '    return
    (count_chars(s)%2)==0', "  if s.length <= 1 \n    return 0\n  else if s[2] !=\
    \ 'E' \n    return 1\n  else if s[1] == 'E' \n    return 0\n  else if s[2] !=\
    \ 'e' \n    return 1\n  else if s[1] == 'e' \n    return 0\n  else if s[2] !=\
    \ 'i' \n    return 1\n  else if s[1] == 'i' \n    return 0\n  else if s[2] !=\
    \ 'O' \n    return 1\n  else if s[1] == 'O' \n    return 0\n  else if s[2] !=\
    \ 'o' \n    return 1\n  else if s[1] == 'o' \n    return 0\n  else if s[2] !=\
    \ 'U' \n    return 1\n  else if s[1] == 'U' \n    return 0\n  else if s[2] !=\
    \ 'u' \n    return 1\n  else if s[1] == 'u' \n    return 0\n  else if s[2] !=\
    \ 'a' \n    return 1\n  else if s[1] == 'a' \n    return 0\n  else \n    count_upper(s[2..-1])\
    \ + count_upper(s[1..-1])\nend\n\"\"\"\n    Given a string s, count the number\
    \ of uppercase vowels in odd indices.\n    \n    For example:\n    >>> count_upper(\"\
    aBCdEf\")\n    1\n    >>> count_upper(\"abcdefg\")\n    0\n    >>> count_upper(\"\
    dBBE\")\n    0\n    \"\"\"", "    if length(s) == 0 || any(sub(\"[AEIOUaeiou]\"\
    ,\"\",s)) then 0 else 1\nend\n</cell>\n<text>\nExercise\nWrite a function called\
    \ count_consonants which takes a string as input and returns the number of consonants\
    \ in that string.", "    # Your code here\nend\n</cell>\n<code language=julia-1.4>\n\
    # Example 4: Write a function count_vowels(string) that returns the number of\
    \ vowels\n# in the string. \n\"\"\"\n    Given a string s, count the number of\
    \ vowels in even\n    indices.\n    \n    For example:\n    >>> count_vowels(\"\
    aBCdEf\")\n    3\n    >>> count_vowels(\"abcdefg\")\n    0\n    >>> count_vowels(\"\
    dBBE\")\n    0\n\"\"\"", "\"\"\"\n    Compute the number of uppercase vowels in\
    \ even indices.\n    \n    You may need to use another function such as has_uppercase\
    \ to check if a char satisfies the condition:\n    \n    >>> has_uppercase(\"\
    aBc\")\n    False\n    >>> has_uppercase(\"aBcDeF\")\n    True\n    \"\"\"", " \
    \   \"\"\"\n    Given a string, return the number of uppercase vowels in even\
    \ indices.\n    \n    For example:\n    >>> count_upper(\"aBCdEf\")\n    1\n \
    \   >>> count_upper(\"abcdefg\")\n    0\n    >>> count_upper(\"dBBE\")\n    0\n\
    \    \"\"\"\nend function count_upper\n</cell>\n<cell>\nassert count_upper(\"\
    aBCdEf\") == 1\nassert count_upper(\"abcdefg\") == 0\nassert count_upper(\"dBBE\"\
    ) == 0 \n</cell>\n<text>\nQuestion 1.14 (10 points)\nWrite a function count_vowels(s)\
    \ that returns the number of vowels in s\nwhere vowels are defined as a, e, i,\
    \ o, and u.", "    | 0 == s = s.upper\n    | 0 <= s && s <= 26 && 0 == count_upper(s[0..1])\
    \ =\n    | 1 <= s && s <= 26 && 1 == count_upper(s[1..2])\n    | 2 <= s && s <=\
    \ 26 && 2 == count_upper(s[2..3])\n    | 3 <= s && s <= 26 && 3 == count_upper(s[3..4])\n\
    \    | 4 <= s && s <= 26 && 4 == count_upper(s[4..5])\n    | 5 <= s && s <= 26\
    \ && 5 == count_upper(s[5..6])\n    | 6 <= s && s <= 26 && 6 == count_upper(s[6..7])\n\
    \    | 7 <= s && s <= 26 && 7 == count_upper(s[7..8])\n    | 8 <= s && s <= 26\
    \ && 8 == count_upper(s[8..9])\n    | 9 <= s && s <= 26 && 9 == count_upper(s[9..10])\n\
    \    | 10 <= s && s <= 26 && 10 == count_upper(s[10..11])\n    | 11 <= s && s\
    \ <= 26 && 11 == count_upper(s[11..12])\n    | 12 <= s && s <= 26 && 12 == count_upper(s[12..13])\n\
    \    | 13 <= s && s <= 26 && 13 == count_upper(s[13..14])\n    | 14 <= s && s\
    \ <= 26 && 14 == count_upper(s[14..15])\n    | 15 <= s && s <= 26 && 15 == count_upper(s[15..16])\n\
    \    | 16 <= s && s <= 26 && 16 == count_upper(s[16..17])\n    | 17 <= s && s\
    \ <= 26 && 17 == count_upper(s[17..18])\n    | 18 <= s && s <= 26 && 18 == count_upper(s[18..19])\n\
    \    | 19 <= s && s <= 26 && 19 == count_upper(s[19..20])\n    | 20 <= s && s\
    \ <= 26 && 20 == count_upper(s[20..21])\n    | 21 <= s && s <= 26 && 21 == count_upper(s[21..22])\n\
    \    | 22 <= s && s <= 26 && 22 == count_upper(s[22..23])\n    | 23 <= s && s\
    \ <= 26 && 23 == count_upper(s[23..24])\n    | 24 <= s && s <= 26 && 24 == count_upper(s[24..25])\n\
    \    | 25 <= s && s <= 26 && 25 == count_upper(s[25..26])\n    | 26 <= s && s\
    \ <= 26 && 26 == count_upper(s[26..27])\n    | 27 <= s && s <= 26", "\tcount :=\
    \ 0\n    for c in s\n        if isupper(c)\n            if c <> lower(c)\n   \
    \             count += 1\n        end\n    end\n    return count\nend", "    if\
    \ len(s)==0 then return 0 \n    let mut i := 0\n    while i < length(s) do\n \
    \       if s[i] != ' ' then\n            if s[i] == 'A' || s[i] == 'a' then\n\
    \                i+= 2 \n            else if s[i] == 'B' || s[i] == 'b' then\n\
    \                i+= 2\n            else if s[i] == 'C' || s[i] == 'c' then\n\
    \                i+= 2\n            else if s[i] == 'D' || s[i] == 'd' then\n\
    \                i+= 2\n            else if s[i] == 'E' || s[i] == 'e' then\n\
    \                i+= 2\n            else if s[i] == 'F' || s[i] == 'f' then\n\
    \                i+= 2\n            else if s[i] == 'G' || s[i] == 'g' then\n\
    \                i+= 2\n            else if s[i] == 'H' || s[i] == 'h' then\n\
    \                i+= 2\n            else if s[i] == 'I' || s[i] == 'i' then\n\
    \                i+= 2\n            else if s[i] == 'J' || s[i] == 'j' then\n\
    \                i+= 2\n            else if s[i] == 'K' || s[i] == 'k' then\n\
    \                i+= 2\n            else if s[i] == 'L' || s[i] == 'l' then\n\
    \                i+= 2\n            else if s[i] == 'M' || s[i] == 'm' then\n\
    \                i+= 2\n            else if s[i] == 'N' || s[i] == 'n' then\n\
    \                i+= 2\n            else if s[i] == 'O' || s[i] == 'o' then\n\
    \                i+= 2\n            else if s[i] == 'P' || s[i] == 'p' then\n\
    \                i+= 2\n            else if s[i] == 'Q' || s[i] == 'q' then\n\
    \                i+= 2\n            else if s[i] == 'R' || s[i] == 'r' then\n\
    \                i+= 2\n            else if s[i] == 'S' || s[i] == 's' then\n\
    \                i+= 2\n            else if s[i] == 'T' || s[i] == 't' then\n\
    \                i+= 2\n            else if s[i] == 'U' || s[i] == 'u' then\n\
    \                i+= 2\n            else if s[i] == 'V' || s[i] == 'v' then\n\
    \                i+= 2\n            else if s[i] == 'W' || s[i] == 'w' then\n\
    \                i+= 2\n            else if s[i] == 'X' || s[i] == 'x' then\n\
    \                i+= 2\n            else if s[i] == 'Y' || s[i] == 'y' then\n\
    \                i+= 2\n            else if s[i] == 'Z' || s[i] == 'z' then\n\
    \                i+= 2\n            else if s[i] == 'a' || s[i] == 'A' then\n\
    \                i+= 2 \n            else if s[i] == 'b' || s[i] == 'B' then\n\
    \                i+= 2\n            else if s[i] == 'c' || s[i] == 'C' then\n\
    \                i+= 2\n            else if s[i] == 'd' || s[i] == 'D' then\n\
    \                i+= 2\n            else if s[i] == 'e' || ", "    if all(x <='z'\
    \ for x in s) \n        then return 0 \n        else return sum(s[i] <='Z' for\
    \ x in subranges(s))\n    end\n    \n\"\"\"\n    Given a string s, count the number\
    \ of uppercase vowels in odd indices.\n    \n    For example:\n    >>> count_upper(\"\
    aBCdEf\")\n    1\n    >>> count_upper(\"abcdefg\")\n    1\n    >>> count_upper(\"\
    dBBE\")\n    1\n    \"\"\"", "\tlet mut count=0\n\tfor i in 0..s.len()-1 do \n\
    \t\tif s[i]=='A' || s[i]=='E' || s[i]=='I' || s[i]=='O' || s[i]=='U' then\n\t\t\
    \tcount+=1 \n\t\telse\n\t\t\tcontinue \n\t\tend \n\tend \n\treturn count\nend ",
  "    count_upper = 0\n    for character in s\n        if character in \"AEIOUaeiou\"\
    \n            count_upper += 1\n            \n            if count_upper % 2 ==\
    \ 0\n                return count_upper\n            end\n        end\n    end\n\
    \    return count_upper\nend", "    counter := 0\n    for i in 2 to length(s)-1\
    \ \n        if s[i] == 'e' and s[i-1] == 'E' and s[i-2] == 'e' \n            then\
    \ counter += 1 \n    else \n        counter += 0 \n    return counter \nend ",
  "    if length s mod 2 > 1 then \n        return 0\n    else \n        count_upper(s[2:])\n\
    \        count_upper(s[2:end-1])\n        count_upper(s[2:end-2])\n        count_upper(s[2:end-3])\n\
    \        count_upper(s[2:end-4])\n        count_upper(s[2:end-5])\n        count_upper(s[2:end-6])\n\
    \        count_upper(s[2:end-7])\n        count_upper(s[2:end-8])\n        count_upper(s[2:end-9])\n\
    \        count_upper(s[2:end-10])\n        count_upper(s[2:end-11])\n        count_upper(s[2:end-12])\n\
    \        count_upper(s[2:end-13])\n        count_upper(s[2:end-14])\n        count_upper(s[2:end-15])\n\
    \        count_upper(s[2:end-16])\n        count_upper(s[2:end-17])\n        count_upper(s[2:end-18])\n\
    \        count_upper(s[2:end-19])\n        count_upper(s[2:end-20])\n        count_upper(s[2:end-21])\n\
    \        count_upper(s[2:end-22])\n        count_upper(s[2:end-23])\n        count_upper(s[2:end-24])\n\
    \        count_upper(s[2:end-25])\n        count_upper(s[2:end-26])\n        count_upper(s[2:end-27])\n\
    \        count_upper(s[2:end-28])\n        count_upper(s[2:end-29])\n        count_upper(s[2:end-32])\n\
    \        count_upper(s[2:end-33])\n        count_upper(s[2:end-34])\n        count_upper(s[2:end-35])\n\
    \        count_upper(s[2:end-36])\n        count_upper(s[2:end-37])\n        count_upper(s[2:end-38])\n\
    \        count_upper(s[2:end-39])\n        count_upper(s[2:end-40])\n        count_upper(s[2:end-41])\n\
    \        count_upper(s[2:end-42])\n        count_upper(s[2:end-43])\n        count_upper(s[2:end-44])\n\
    \        count_upper(s[2:end-45])\n        count_upper(s[2:end-46])\n        count_upper(s[2:end-47])\n\
    \        count_upper(s[2:end-48])\n        count_upper(s[2:end-49])\n        count_upper(s[2:end-50])\n\
    \        count_upper(s[2:end-51])\n        ", "  | (find_first_index(s, is_upper)...)\
    \ / length(s)\nend", "    |(\n    for ii in 0..(length(s)-2)::Int64 in\n     \
    \   if s[ii:(ii+2)] == ('A'..'Z')::Char\n            count += 1\n        end \n\
    \    end \n    )\n    |1\nend \n</cell>\n<code language=julia-1.5>\n\"\"\"\n \
    \   count_up_down(\"aBCdEf\")\n    1\n    >>> count_up_down(\"abcdefg\")\n   \
    \ 0\n    >>> count_up_down(\"dBBE\")\n    0\n    \"\"\"", "    return s.filter(char\
    \ => char == \"a\"\n                      || char == \"e\"\n                 \
    \     || char == \"i\"\n                      || char == \"o\"\n             \
    \         || char == \"u\").length\nend", "    vowels = Set[\"a\"..\"z\"]\n  \
    \  count_vowels = 0\n    for i in 2..length(s) do\n        if islower(s(i)) and\
    \ vowels.include(s(i))\n            count_vowels += 1\n        end\n    end\n\
    \    count_vowels\nend\n</cell>\n<cell>\n# Write your Julia code here:", "   \
    \ count = 0\n    for c in string.ascii_uppercase\n        if s.contains(c) then\n\
    \            count += 1\n        end\n    end\n    return count\nend", "|\n  \
    \  s = s.toUpper\n    if s.length == 0 then 0 else 0\n    |> length\n    |> getSlice\
    \ (0,s.len) \n    |> collect((0,))\n    |> length\n    |> reduce((acc,(x,i)->\n\
    \      if i % 2 == 0 then (acc + 1) \n      else acc\n    ))\n    |> getSlice\
    \ (0,s.len) \n    |> collect((0,))\n    |> length\n    |> reduce((acc,(x,i)->\n\
    \      if i % 2 == 0 then (acc + 1)\n      else acc\n    ))\n    |> getSlice (0,s.len)\n\
    \    |> collect((0,))\n    |> length\n    |> reduce((acc,(x,i)->\n      if i %\
    \ 2 == 0 then (acc + 1)\n      else acc\n    ))\n    |> getSlice (0,s.len) \n\
    \    |> collect((0,))\n    |> length\n    |> reduce((acc,(x,i)->\n      if i %\
    \ 2 == 0 then (acc + 1)\n      else acc\n    ))\n    |> getSlice (0,s.len) \n\
    \    |> collect((0,))\n    |> length\n    |> reduce((acc,(x,i)->\n      if i %\
    \ 2 == 0 then (acc + 1)\n      else acc\n    ))\n    |> getSlice (0,s.len) \n\
    \    |> collect((0,))\n    |> length\n    |> reduce((acc,(x,i)->\n      if i %\
    \ 2 == 0 then (acc + 1)\n      else acc\n    ))\n    |> getSlice (0,s.len) \n\
    \    |> collect((0,))\n    |> length\n    |> reduce((acc,(x,i)->\n      if i %\
    \ 2 == 0 then (acc + 1)\n      else acc\n    ))\n    |> getSlice (0,s.len) \n\
    \    |> collect((0,))\n    |> length\n    |> reduce((acc,(x,i)->\n      if i %\
    \ 2 == 0 then (acc + 1)\n      else acc\n    ))\n    |> getSlice (0,s.len) \n\
    \    |> collect((0,))\n    |> length\n    |> reduce((acc,(x,i)->\n      if i %\
    \ 2 == 0 then (acc + 1)\n      else acc\n    ))\n    |> getSlice (0,s.len) \n\
    \    |> collect((0,))\n    |> length\n    |> ", "    if length(s) <= 0 \n    then\
    \ 0 \n    else if substr(s, 1, 1) == \".\"\n    then 0 \n    else if substr(s,\
    \ 1, 2) == \".\"\n    then 0 \n    else if substr(s, 2, 2) == \".\"\n    then\
    \ 0 \n    else if substr(s, 2, 2) == \".\"\n    then 0 \n    else if substr(s,\
    \ 2, 2) == \".\"\n    then 0 \n    else if substr(s, 3, 2) == \".\"\n    then\
    \ 0 \n    else if substr(s, 3, 2) == \".\"\n    then 0 \n    else if substr(s,\
    \ 3, 2) == \".\"\n    then 0 \n    else if substr(s, 4, 2) == \".\"\n    then\
    \ 0 \n    else if substr(s, 4, 2) == \".\"\n    then 0 \n    else if substr(s,\
    \ 4, 2) == \".\"\n    then 0 \n    else if substr(s, 4, 2) == \".\"\n    then\
    \ 0 \n    else if substr(s, 4, 2) == \".\"\n    then 0 \n    else if substr(s,\
    \ 4, 2) == \".\"\n    then 0 \n    else if substr(s, 5, 2) == \".\"\n    then\
    \ 0 \n    else if substr(s, 5, 2) == \".\"\n    then 0 \n    else if substr(s,\
    \ 5, 2) == \".\"\n    then 0 \n    else if substr(s, 5, 2) == \".\"\n    then\
    \ 0 \n    else if substr(s, 5, 2) == \".\"\n    then 0 \n    else if substr(s,\
    \ 5, 2) == \".\"\n    then 0 \n    else if substr(s, 5, 2) == \".\"\n    then\
    \ 0 \n    else if substr(s, 5, 2) == \".\"\n    then 0 \n    else if substr(s,\
    \ 5, 2) == \".\"\n    then 0 \n    else if substr(s, 5, 2) == \".\"\n    then\
    \ 0 \n    else if substr(s, 5, 2) == \".\"\n    then 0 \n    else if substr(s,\
    \ 5, 2) == \".\"\n    then 0 \n    else if substr(s, 5, 2) == \".\"\n    then\
    \ 0 \n    else if substr(s, 5, 2) == \".\"\n    then 0 \n    else if substr(s,\
    \ 5, 2) == \".\"\n    then 0 \n    else if substr(s, 5, 2) == \".\"\n    then\
    \ 0 \n    else if substr(s, 5, 2) == \".\"\n    then 0 \n    else if substr(s,\
    \ 5, 2) == \".\"\n    then 0 \n    else if substr(s, 5, 2) == \".\"\n    then\
    \ 0 \n    else if substr(s, 5, 2) == ", "    if length(s) < 2\n    then 0\n  \
    \  else if even(iseven(toupper(head(s)))) \n    then count_upper(tail(s)) + 1\n\
    \    else count_upper(tail(s))\nend\n</cell>\n<code language=julia-1.5>\ncount_upper(\"\
    aBCdEf\")\n</cell>\n<code language=julia-1.5>\ncount_upper(\"abcdefg\")\n</cell>\n\
    <code language=julia-1.5>\ncount_upper(\"dBBE\")\n</cell>\n<text>\ncount_vowels(s)",
  "    let count::Int64 = 0\n    let (indx,_) = String.splitloc(s,\"_\")\n    if indx\
    \ < 2 || indx > length(s) then return 0\n    let mut v = Char.uppercase(s[indx-1])\n\
    \    for c in s[indx-2:indx] do \n        if c != '_' then \n            v = Char.uppercase(v)\
    \ + Char.uppercase(c)\n        else \n            v = Char.uppercase(v)\n    return\
    \ 1 + count\nend\n</cell>\n<code language=julia-1.6>", "    if s.length == 0 \n\
    \        0\n    else\n        count_upper_aux(s.init,1,s.length)\nend", "    if\
    \ s.length < 2 \n        return 0 \n    else \n        count_upper helper s 0\
    \ \n        function helper s(s,i,c) \n            switch c \n               \
    \ case 1 \n                case 2 \n                case 3 \n                case\
    \ 4 \n                case 5 \n                case 6 \n                case 7\
    \ \n                case 8 \n                case 9 \n                case 10\
    \ \n                    return 0 \n                default \n                \
    \    count_upper helper s i (c + 1) \n            end \n        end \n    end\
    \ \nend ", "    count = 0\n    for i in (0..n-1)\n        if (s[i] >= 'A' && s[i]\
    \ <= 'Z') || (s[i] >= 'a' && s[i] <= 'z')\n            count += 1 \n        end\n\
    \    end\n    return count\nend\n</cell>\n<code language=julia-1.5>", "    \n\
    \    return (count((substr.(s,2,2),\"A\") + substr.(s,4,2)) end", "    if length(s)<2\n\
    \        0\n    else\n        match(s, r\"(.*?)(..)(..)\")[2,2] % 2\n    end\n\
    end\n</cell>\n<text>\nExercise: Can you translate the above functions to Julia?",
  "    s = lowercase(s)\n    let n = zero(Int64)\n    for v in [a,b,c,d,e,f,g] where\
    \ v==z\n        let c = isupper(index(v,s))\n        if c\n            n += c\n\
    \    return n\nend\n</cell>\n<text>\nQuestion 7: Write a function that returns\
    \ the number of occurrences of a substring within a string. For example, substring\
    \ \"ab\" in the string \"ababa\" has a count of two.", "    if length(s)%2 ==\
    \ 0 \n        then count_upper(substrings(s,2,2))\n        else count_upper(substrings(s,0,2))\n\
    \    end\nend\n</cell>\n<code language=julia-0.5>", "</code>\n<code>\ncount_upper(\"\
    aBCdEf\")\ncount_upper(\"abcdefg\")\ncount_upper(\"dBBE\")\ncount_upper(\"aaaB\"\
    )\ncount_upper(\"aBbbcde\")\ncount_upper(\"aBbde\")\ncount_upper(\"abbbcc\")\n\
    count_upper(\"aaaabbbcc\")\ncount_upper(\"aaaabbbccc\")\ncount_upper(\"aaa\")\n\
    count_upper(\"aBbb\")\ncount_upper(\"aBbb\")\ncount_upper(\"AaaBbb\")\ncount_upper(\"\
    aBbb\")\ncount_upper(\"aBB\")\ncount_upper(\"aBB\")\ncount_upper(\"aBBb\")\ncount_upper(\"\
    aBBbB\")\ncount_upper(\"aBBBB\")\ncount_upper(\"aBBBB\")\ncount_upper(\"aaBBB\"\
    )\ncount_upper(\"aaBBB\")\ncount_upper(\"aBBB\")\ncount_upper(\"aBBBB\")\ncount_upper(\"\
    aBBBB\")\ncount_upper(\"aBBB\")\ncount_upper(\"aBBBB\")\ncount_upper(\"aBBB\"\
    )\ncount_upper(\"aBBBB\")\ncount_upper(\"aBBB\")\ncount_upper(\"aBBBB\")\ncount_upper(\"\
    aBBB\")\ncount_upper(\"aBBBB\")\ncount_upper(\"aBBB\")\ncount_upper(\"aBBBB\"\
    )\ncount_upper(\"aBBB\")\ncount_upper(\"aBBBB\")\ncount_upper(\"aBBB\")\ncount_upper(\"\
    aBBBB\")\ncount_upper(\"aBBB\")\ncount_upper(\"aBBBB\")\ncount_upper(\"aBBB\"\
    )\ncount_upper(\"aBBBB\")\ncount_upper(\"aBBB\")\ncount_upper(\"aBBBB\")\ncount_upper(\"\
    aBBB\")\ncount_upper(\"aBBBB\")\ncount_upper(\"aBBB\")\ncount_upper(\"aBBBB\"\
    )\ncount_upper(\"aBBB\")\ncount_upper(\"aBBBB\")\ncount_upper(\"aBBB\")\ncount_upper(\"\
    aBBBB\")\ncount_upper(\"aBBB\")\ncount_upper(\"aBBBB\")\ncount_upper(\"aBBB\"\
    )\ncount_upper(\"aBBBB\")\ncount_upper(\"aBBB\")\ncount_upper(\"aBBBB\")\ncount_upper(\"\
    aBBB\")\ncount_upper(\"aBBBB\")\ncount_upper(\"aBBB\")\ncount_upper(\"aBBBB\"\
    )\ncount_", "    = match (s :: String) with\n        | \"a\" :: a :: _ -> 1\n\
    \        | \"b\" :: b :: _ -> 1\n        | \"c\" :: c :: _ -> 1\n        | \"\
    d\" :: d :: _ -> 1\n        | \"e\" :: e :: _ -> 1\n        | \"f\" :: f :: _\
    \ -> 1\n        | \"g\" :: g :: _ -> 1\n        | \"a\" :: _ -> 0\n        | \"\
    b\" :: _ -> 0\n        | \"c\" :: _ -> 0\n        | \"d\" :: _ -> 0\n        |\
    \ \"e\" :: _ -> 0\n        | \"f\" :: _ -> 0\n        | \"g\" :: _ -> 0\n    \
    \    | \"a\" :: _ -> 0\n        | \"b\" :: _ -> 0\n        | \"c\" :: _ -> 0\n\
    \        | \"d\" :: _ -> 0\n        | \"e\" :: _ -> 0\n        | \"f\" :: _ ->\
    \ 0\n        | \"g\" :: _ -> 0\n        | \"a\" :: _ -> 0\n        | \"b\" ::\
    \ _ -> 0\n        | \"c\" :: _ -> 0\n        | \"d\" :: _ -> 0\n        | \"e\"\
    \ :: _ -> 0\n        | \"f\" :: _ -> 0\n        | \"g\" :: _ -> 0\n        | \"\
    a\" :: _ -> 0\n        | \"b\" :: _ -> 0\n        | \"c\" :: _ -> 0\n        |\
    \ \"d\" :: _ -> 0\n        | \"e\" :: _ -> 0\n        | \"f\" :: _ -> 0\n    \
    \    | \"g\" :: _ -> 0\n        | \"a\" :: _ -> 0\n        | \"b\" :: _ -> 0\n\
    \        | \"c\" :: _ -> 0\n        | \"d\" :: _ -> 0\n        | \"e\" :: _ ->\
    \ 0\n        | \"f\" :: _ -> 0\n        | \"g\" :: _ -> 0\n        | \"a\" ::\
    \ _ -> 0\n        | \"b\" :: _ -> 0\n        | \"c\" :: _ -> 0\n        | \"d\"\
    \ :: _ -> 0\n        | \"e\" :: _ -> 0\n        | \"f\" :: _ -> 0\n        | \"\
    g\" :: _ -> 0\n        | \"a\" :: _ -> 0\n        | \"b\" :: _ -> 0\n        |\
    \ \"c\" :: _ -> 0\n        | \"d\" :: _ -> 0\n        | \"e\" :: _ -> 0\n    \
    \    | \"f", "    \n    \"\"\" Counts the number of uppercase vowels in even indices.\n\
    \    \n    This function takes string s as input, and returns the number of uppercase\
    \ \n    vowels in even indices. \n    \n    The input string may contain spaces\
    \ or punctuation marks.\n    \n    The returned integer is rounded up to the nearest\
    \ integer.\n    \n    For example, given the string \"aBCdEf\" the function returns\
    \ 1 because there is \n    one uppercase vowel in even indices.\n    \n    Since\
    \ the function is guaranteed to return a positive integer, it may return \n  \
    \  the wrong answer when the number of uppercase vowels is exactly one in \n \
    \   the input string.\n    \n    For example, given the string \"dBBE\" the function\
    \ returns 0 because there is \n    no uppercase vowels in even indices.\n    \"\
    \"\"\n    \n    \"\"\"\n    Define a function that takes string s as input and\
    \ returns the number of \n    uppercase vowels in even indices.\n    \"\"\"\n\
    \    return sum(1 for c in s if c .== \"A\") ", "    |=1\n    local n=0\n    for\
    \ c in s:\n        if c.upper():isalpha() and c.isupper():\n            n+=1\n\
    \    return n\n\"\"\"\nCount number of lowercase vowels in even indices in a string\
    \ s.\nIf the string s is null, return null.", "    match s.head with\n       \
    \ | 'a' | 'A' -> 1\n        | 'b' | 'B' -> 1\n        | 'c' | 'C' -> 1\n     \
    \   | 'd' | 'D' -> 1\n        | 'e' | 'E' -> 1\n        | 'f' | 'F' -> 1\n   \
    \     | 'g' | 'G' -> 1\n        | 'h' | 'H' -> 1\n        | 'i' | 'I' -> 1\n \
    \       | 'j' | 'J' -> 1\n        | 'k' | 'K' -> 1\n        | 'l' | 'L' -> 1\n\
    \        | 'm' | 'M' -> 1\n        | 'n' | 'N' -> 1\n        | 'o' | 'O' -> 1\n\
    \        | 'p' | 'P' -> 1\n        | 'q' | 'Q' -> 1\n        | 'r' | 'R' -> 1\n\
    \        | 's' | 'S' -> 1\n        | 't' | 'T' -> 1\n        | 'u' | 'U' -> 1\n\
    \        | 'v' | 'V' -> 1\n        | 'w' | 'W' -> 1\n        | 'x' | 'X' -> 1\n\
    \        | 'y' | 'Y' -> 1\n        | 'z' | 'Z' -> 1\n        | _ -> 0\n    end\n\
    end\n</cell>\n<text>\nPractice Problem 3.17\nWrite a function, count_even, that\
    \ counts the number of even indices in a string. For example, count_even(\"aBCdEf\"\
    ) should return 3.", "    # write your code here\n    return count_uppercase(s,0)\n\
    end\n</cell>\n<code language=julia-1.5>\n# Run this cell to test your code\ncount_upper(\"\
    aBCdEf\")\n</cell>\n<text>\n(2b) The first two functions count_lowercase and count_uppercase\
    \ implement the same algorithm, except that they count only the lowercase letters.\
    \ Implement them and test your code using your example strings and your function.",
  "    # implement your function here\n    let a = \"A\"\n    let d = \"D\"\n    let\
    \ e = \"E\"\n    let f = \"F\"\n    let g = \"G\"\n    let h = \"H\"\n    let\
    \ i = \"I\"\n    let j = \"J\"\n    let k = \"K\"\n    let l = \"L\"\n    let\
    \ m = \"M\"\n    let n = \"N\"\n    let o = \"O\"\n    let p = \"P\"\n    let\
    \ q = \"Q\"\n    let r = \"R\"\n    let s = \"S\"\n    let t = \"T\"\n    let\
    \ u = \"U\"\n    let v = \"V\"\n    let w = \"W\"\n    let x = \"X\"\n    let\
    \ y = \"Y\"\n    let z = \"Z\"\n    let A = \"a\"\n    let B = \"b\"\n    let\
    \ C = \"c\"\n    let D = \"d\"\n    let E = \"e\"\n    let F = \"f\"\n    let\
    \ G = \"g\"\n    let H = \"h\"\n    let I = \"i\"\n    let J = \"j\"\n    let\
    \ K = \"k\"\n    let L = \"l\"\n    let M = \"m\"\n    let N = \"n\"\n    let\
    \ O = \"o\"\n    let P = \"p\"\n    let Q = \"q\"\n    let R = \"r\"\n    let\
    \ S = \"s\"\n    let T = \"t\"\n    let U = \"u\"\n    let V = \"v\"\n    let\
    \ W = \"w\"\n    let X = \"x\"\n    let Y = \"y\"\n    let Z = \"z\"\n    let\
    \ ae = \"ae\"\n    let af = \"af\"\n    let ag = \"ag\"\n    let ah = \"ah\"\n\
    \    let ai = \"ai\"\n    let aj = \"aj\"\n    let ak = \"ak\"\n    let al = \"\
    al\"\n    let am = \"am\"\n    let an = \"an\"\n    let ao = \"ao\"\n    let ap\
    \ = \"ap\"\n    let aq = \"aq\"\n    let ar = \"ar\"\n    let as = \"as\"\n  \
    \  let at = \"at\"\n    let au = \"au\"\n    let av = \"av\"\n    let aw = \"\
    aw\"\n    let ax = \"ax\"\n    let ay = \"ay\"\n    let az = \"az\"\n    let ba\
    \ = \"ba\"\n    let bb = \"bb\"\n    let bc = \"bc\"\n    let bd = \"bd\"\n  \
    \  let be = \"be\"\n    let bf = \"bf\"\n    let bg = \"bg\"\n    let bh = \"\
    bh\"\n    let bi = \"bi\"\n    let bj = \"bj\"\n    let bk = \"bk\"\n    let bl\
    \ = \"bl\"\n    let bm = \"bm\"\n    let bn = \"bn\"\n    let bo = \"", "    if\
    \ s == \"\" then return 0\n    let mutable n = 0\n    for (i, ch) in enumerate((s).chars)\
    \ \n        if ch in \"AEIOUaeiou\" then \n            if i % 2 == 0 then n +=\
    \ 1\n    else \n        n += 0\n    return n", "</code>\n<code>\n# Excercise 3.",
  "    if is_empty(s), return 0\n    \n    let mutable count = 0\n    \n    for i\
    \ in 0..<length(s) do\n        if is_upper(s[i])\n            count += 1\n   \
    \         if i%2 == 0 then\n                count += count_upper(s[1..i])\n  \
    \          end\n        end\n    end\n    \n    return count\nend\n</cell>\n<code\
    \ language=julia-1.0>\n@test count_upper(\"aBCdEf\") == 1\n@test count_upper(\"\
    abcdefg\") == 0\n@test count_upper(\"dBBE\") == 0\n</cell>\n<text>\nExercise\n\
    Write a function that takes a string (a sequence of characters) and returns the\
    \ number of times any substring appears in that string. For example, the string\
    \ \"abcdef\" contains the substring \"a\" exactly twice, so your function should\
    \ return 2. For your first substring (\"a\"), you should ignore the characters\
    \ that appear before it. For your second substring (\"b\"), you should ignore\
    \ the characters that appear after it, and so on.", "</code>\nThe function count_upper()\
    \ only receives a String, so it cannot handle Strings of different lengths.  You\
    \ could add an assertion in there, for example\n<code>\n    check $s == \"\" ||\
    \ (length($s) == 2)\n</code>\nwhich would then make your function work with strings\
    \ of length 1, 2 or 3.\nThis does not affect your final answer, so I'll leave\
    \ it alone.\n<|/ a dscore=1 |>\n<| c |>\nThanks for your help on this.  I have\
    \ made the changes you suggested (See edited question), but still cannot get this\
    \ to work\n<|/ c |>\n<| c |>\nYour code is still not complete.  There are still\
    \ many pieces you need to finish, and I'm not going to do your homework for you.\
    \  So I'll offer a few pointers, though.  First, look up the `fold` function.\
    \  It allows you to do something like\n`foldl(==0, [], strings)`\nto find the\
    \ number of occurrences of each letter in each string.  Then you can use `sum`\
    \ to sum the occurrences of each letter.  Finally, to count the number of uppercase\
    \ letters, you can do something like\n`sum(map(==C, foldl(==0, [], uppers)))`.\
    \  You can then call `sum` on your final result.\n<|/ c |>\n<| a dscore=1 |>\n\
    The solution is much simpler. Just use regular expressions.\n<code>\nusing Pkg;\n\
    using RegexpEngines;\nusing Statistics;", "    ans <- 0\n    s !in \"aAbBcCdDeEfFgGhHijJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ\"\
    \n    for i in s.chars \n        if i.upcase == \"A\" then ans+=1\n    return\
    \ ans\nend\n</cell>\n<code language=julia-0.6>\ncount_upper(\"aBCdEf\")\n</cell>\n\
    <text>\nExercise 18\nImplement the function count_digits, which counts the number\
    \ of digits in an integer n, where n may be an arbitrarily large integer. Digits\
    \ are those in base 10; there are 16 of them.\nFor example,\ncount_digits(2147483648)\
    \ should return the number 6.", "    ans = zero(0)\n    \n    for i in [x | x\
    \ <- take(length(s), (mod x 2 = 0)), x /= 2] \n        if s[i] == 'A' || s[i]\
    \ == 'a' \n            ans += 1\n    return ans\nend", "    if is_uppercase(s)\n\
    \        if length(s) in 2\n            get_index(s, 2) == 4 || get_index(s, 2)\
    \ == 6 || get_index(s, 2) == 8\n        else\n            get_index(s, 2) == 4\
    \ || get_index(s, 2) == 6\n        end\n    else\n        0\n    end\nend\n\"\"\
    \"\n    Given a string s, count the number of uppercase vowels in odd indices.\n\
    \    \n    For example:\n    >>> count_upper(\"aBCdEf\")\n    2\n    >>> count_upper(\"\
    abcdefg\")\n    1\n    >>> count_upper(\"dBBE\")\n    1\n    \"\"\"", "    cnt\
    \ = 0\n    for c in s\n        if c in [\"A\",\"a\",\"B\",\"b\",\"C\",\"c\",\"\
    D\",\"d\",\"E\",\"e\",\"F\",\"f\",\"G\",\"g\",\"H\",\"h\",\"I\",\"i\",\"J\",\"\
    j\",\"K\",\"k\",\"L\",\"l\",\"M\",\"m\",\"N\",\"n\",\"O\",\"o\",\"P\",\"p\",\"\
    Q\",\"q\",\"R\",\"r\",\"S\",\"s\",\"T\",\"t\",\"U\",\"u\",\"V\",\"v\",\"W\",\"\
    w\",\"X\",\"x\",\"Y\",\"y\",\"Z\",\"z\"]\n            cnt += 1\n            cnt\
    \ += if(c == 'A') else 0\n            cnt += if(c == 'a') else 0\n           \
    \ cnt += if(c == 'B') else 0\n            cnt += if(c == 'b') else 0\n       \
    \     cnt += if(c == 'C') else 0\n            cnt += if(c == 'c') else 0\n   \
    \         cnt += if(c == 'D') else 0\n            cnt += if(c == 'd') else 0\n\
    \            cnt += if(c == 'E') else 0\n            cnt += if(c == 'e') else\
    \ 0\n            cnt += if(c == 'F') else 0\n            cnt += if(c == 'f') else\
    \ 0\n            cnt += if(c == 'G') else 0\n            cnt += if(c == 'g') else\
    \ 0\n            cnt += if(c == 'H') else 0\n            cnt += if(c == 'h') else\
    \ 0\n            cnt += if(c == 'I') else 0\n            cnt += if(c == 'i') else\
    \ 0\n            cnt += if(c == 'J') else 0\n            cnt += if(c == 'j') else\
    \ 0\n            cnt += if(c == 'K') else 0\n            cnt += if(c == 'k') else\
    \ 0\n            cnt += if(c == 'L') else 0\n            cnt += if(c == 'l') else\
    \ 0\n            cnt += if(c == 'M') else 0\n            cnt += if(c == 'm') else\
    \ 0\n            cnt += if(c == 'N') else 0\n            cnt += if(c == 'n') else\
    \ 0\n            cnt += if(c == 'O') else 0\n            cnt += if(c == 'o') else\
    \ 0\n            cnt += if(c == 'P') else 0\n            cnt += if(c == 'p') else\
    \ 0\n            cnt += if(c == 'Q') else 0\n            cnt += if(c == 'q') else\
    \ 0\n            cnt += if(c == 'R') else 0\n            cnt += if(c == 'r", " \
    \   count = 0\n    for c in s\n        if ('A' <= c && c <= 'Z') || ('a' <= c\
    \ && c <= 'z')\n            count += 1 if ('A' <= c && c <= 'Z') else 0\n    return\
    \ count\n</code>\nYou can write this in three ways:\n<code>", "    count = 0\n\
    \    for c in s\n        if c in \"aeiouAEIOU\"\n            count = count+1\n\
    \    return count", "    if s.len() < 1 \n        error(\"input string is empty\"\
    )\n    \n    let num_vowels = 0 \n    for i in 0..s.len()-1 \n        match s[i]\
    \ \n            | 'a' .. 'z' -> num_vowels += 1\n            | _ -> num_vowels\
    \ += 0 \n    return num_vowels \n    ", '    # Write your solution here', "  \
    \  n <- 0\n    for c in s do\n        if isUpper(c) then n <- n + 1 \n       \
    \ else\n            n <- n + 1\n    end\n    return n\nend", "\tconst upper=\"\
    AEIOUYaeiouy\"\n\tconst numUpper=length(upper)\n\tlet numVowels=0\n\tfor c in\
    \ s\n\t\tif c \u2209 upper\n\t\t\tnumVowels++\n\t\telse\n\t\t\tbreak\n\treturn\
    \ numVowels\nend\n</cell>\n<code language=julia-0.5>\n# test count_upper\ns =\
    \ \"\"\"\n    Given a string s, count the number of uppercase vowels in even indices.\n\
    \    \n    For example:\n    >>> count_upper(\"aBCdEf\")\n    1\n    >>> count_upper(\"\
    abcdefg\")\n    0\n    >>> count_upper(\"dBBE\")\n    0\n    \"\"\"\ntest(s,count_upper)\n\
    </cell>\n<text>\nExercise\nThe function count_lower should count the number of\
    \ lowercase letters.\nImplement the function in the cell below:", "    if is_empty(s)\
    \ || length(s)==0 \n        return 0 \n    end\n    \n    n \u2190 0\n    c \u2190\
    \ s[0]\n    for i in s\n        if is_lower(c) \n            if is_vowel(c) \n\
    \                n \u2190 n + 1\n            else\n                return 0\n\
    \        end\n        c \u2190 next_char(c)\n    end\n    return n\nend\n</cell>\n\
    <text>\nExercise 11\nThe vowels in string \"hello\" are: e, o, and u.", "    result\
    \ <- 0\n    for i \u2208 0 .. length(s) - 1 do\n        if is_upper(s[i]) && is_upper(s[i+1])\
    \ then\n            result <- result + 1\n        elseif s[i] == \"a\" && is_upper(s[i+1])\
    \ then\n            result <- result + 1\n        elseif s[i] == \"d\" && is_upper(s[i+1])\
    \ then\n            result <- result + 1\n        else\n            result <-\
    \ 0\n    end\n    return result\nend\n</cell>\n<code language=julia-1.5>\n# TEST\
    \ count_upper (1095)\n# Uncomment the following line when submitting your notebook\n\
    # include(\"test_count_upper.jl\")\n</cell>\n<text>\nQuestion 3.2\nWrite a function\
    \ to count the number of uppercase vowels separately in all indices (starting\
    \ from 0 in the string).", "    ans = 0 \n    for c in s \n        ans += (c >=\
    \ 'A') and (c <= 'Z')\n    end\n    return ans \nend", "    if length(s) <= 1\n\
    \        0\n    else if uppercase(s[2, 3])\n        1\n    else count_upper(substring(1,\
    \ s))\nend\n</cell>\n<code language=julia-0.6>\ncount_upper(\"aBCdEf\")\n</cell>\n\
    <code language=julia-0.6>\ncount_upper(\"abcdefg\")\n</cell>\n<code language=julia-0.6>\n\
    count_upper(\"dBBE\")\n</cell>\n<text>\nQuestion 8: Count number of uppercase\
    \ vowels in odd indices in a string.", "    if length(s) % 2 == 0 \n        return\
    \ count_upper_helper(s, 0)\n    else\n        count_upper(substring(s, 1, length(s)\
    \ - 1))\n    end\nend\n</cell>\n<code language=julia-0.6>\ncount_upper(\"aBCdEf\"\
    )\n</cell>\n<code language=julia-0.6>\ncount_upper(\"abcdefg\")\n</cell>\n<code\
    \ language=julia-0.6>\ncount_upper(\"dBBE\")\n</cell>\n<text>\nProblem 9\nThe\
    \ Sign language is not comprised of letters but rather words. \nYour task is to\
    \ determine whether a given word is a Sign language word or not.", "    if (s.length==0)\
    \ || (s.length==1)\n        return 0 \n    if (s[0]=='a' && s[1]=='a' && s[2]=='a')\
    \ || (s[0]=='A' && s[1]=='A' && s[2]=='A')\n        return 1\n    if s[0]=='a'\
    \ && s[1]=='A' && s[2]=='A'\n        return 2\n    if s[0]=='a' && s[1]=='A' &&\
    \ s[2]=='a'\n        return 3\n    if s[0]=='A' && s[1]=='a' && s[2]=='a'\n  \
    \      return 4\n    if s[0]=='A' && s[1]=='A' && s[2]=='A'\n        return 5\n\
    \    if s[0]=='a' && s[1]=='A' && s[2]=='a'\n        return 6\n    if s[0]=='A'\
    \ && s[1]=='a' && s[2]=='A'\n        return 7\n    if s[0]=='a' && s[1]=='A' &&\
    \ s[2]=='a'\n        return 8\n    if s[0]=='a' && s[1]=='a' && s[2]=='A'\n  \
    \      return 9\n    if s[0]=='A' && s[1]=='A' && s[2]=='A'\n        return 10\n\
    \    if s[0]=='a' && s[1]=='a' && s[2]=='a'\n        return 11\n    if s[0]=='A'\
    \ && s[1]=='A' && s[2]=='A'\n        return 12\n    if s[0]=='a' && s[1]=='a'\
    \ && s[2]=='a'\n        return 13\n    if s[0]=='A' && s[1]=='a' && s[2]=='A'\n\
    \        return 14\n    if s[0]=='a' && s[1]=='A' && s[2]=='a'\n        return\
    \ 15\n    if s[0]=='A' && s[1]=='A' && s[2]=='A'\n        return 16\n    if s[0]=='a'\
    \ && s[1]=='a' && s[2]=='a'\n        return 17\n    if s[0]=='A' && s[1]=='A'\
    \ && s[2]=='A'\n        return 18\n    if s[0]=='a' && s[1]=='a' && s[2]=='a'\n\
    \        return 19\n    if s[0]=='A' && s[1]=='A' && s[2]=='A'\n        return\
    \ 20\n    if s[0]=='a' && s[1]=='A' && s[2]=='a'\n        return 21\n    if s[0]=='A'\
    \ && s[1]=='a' && s[2]=='A'\n        return 22\n    if s[0]=='a' && s[1]=='A'\
    \ && s[2]=='a'\n        return 23\n    if s[0]=='a' && s[1]=='a' && s[2]=='a'\n\
    \        return 24\n    if s[0]=='A' && s[1]=='A' && s[2]=='A'\n        return\
    \ 25\n    if s[0]=='a' && s[1]=='A' && s[2]=='a'\n        return 26\n    if s[0]=='A'\
    \ && s[1]=='a' && s[2]=='A'\n        return 27\n    if s[0]=='a' && s[1]=='a'\
    \ && s[2]=='a'\n        return 28\n    if s[0]=='A' && s[1]=='A' && s[2]=='A'\n\
    \        return 29\n    if s[0]=='a' && s[1]=='A' && ", "    if len(s) <= 0 then\
    \ 0 \n    elseif is_uppercase(s[0]) then 1 else 0 \n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    if is_empty(s) then return 0\n    else if is_digit(charAt(s,\
    \ 0)) then return 1\n    else if is_upper(charAt(s, 0)) && charAt(s, 1) in 'AEIOU'\
    \ then return count_upper(s[2:])\n    else return count_upper(s[1..])\n    end\n\
    end\n</cell>\n<code language=julia-0.5>\n\"\"\"\n    Given a string s, count the\
    \ number of uppercase vowels in odd indices.\n    \n    For example:\n    >>>\
    \ count_upper(\"aBCdEf\")\n    3\n    >>> count_upper(\"abcdefg\")\n    0\n  \
    \  >>> count_upper(\"dBBE\")\n    1\n    \"\"\"", "    s = lowercase(s)\n    even\
    \ = filter(x->x%2==0, index(s)) \n    return sum(map(uppercase, even))\nend\n\
    </cell>\n<code language=julia-0.4>", "    | count_upper(s, 0, 1) = 0\n    | count_upper(s,\
    \ 1, 0) = 0\n    | count_upper(s, 0, 2) = 0\n    | count_upper(s, 1, 2) = 0\n\
    \    | count_upper(s, 0, 3) = 0\n    | count_upper(s, 1, 3) = 0\n    | count_upper(s,\
    \ 0, 4) = 0\n    | count_upper(s, 1, 4) = 0\n    | count_upper(s, 0, 5) = 0\n\
    \    | count_upper(s, 1, 5) = 0\n    | count_upper(s, 0, 6) = 0\n    | count_upper(s,\
    \ 1, 6) = 0\n    | count_upper(s, 0, 7) = 0\n    | count_upper(s, 1, 7) = 0\n\
    \    | count_upper(s, 0, 8) = 0\n    | count_upper(s, 1, 8) = 0\n    | count_upper(s,\
    \ 0, 9) = 0\n    | count_upper(s, 1, 9) = 0\n    | count_upper(s, 0, 10) = 0\n\
    \    | count_upper(s, 1, 10) = 0\n    | count_upper(s, 0, 11) = 0\n    | count_upper(s,\
    \ 1, 11) = 0\n    | count_upper(s, 0, 12) = 0\n    | count_upper(s, 1, 12) = 0\n\
    \    | count_upper(s, 0, 13) = 0\n    | count_upper(s, 1, 13) = 0\n    | count_upper(s,\
    \ 0, 14) = 0\n    | count_upper(s, 1, 14) = 0\n    | count_upper(s, 0, 15) = 0\n\
    \    | count_upper(s, 1, 15) = 0\n    | count_upper(s, 0, 16) = 0\n    | count_upper(s,\
    \ 1, 16) = 0\n    | count_upper(s, 0, 17) = 0\n    | count_upper(s, 1, 17) = 0\n\
    \    | count_upper(s, 0, 18) = 0\n    | count_upper(s, 1, 18) = 0\n    | count_upper(s,\
    \ 0, 19) = 0\n    | count_upper(s, 1, 19) = 0\n    | count_upper(s, 0, 20) = 0\n\
    \    | count_upper(s, 1, 20) = 0\n    | count_upper(s, 0, 21) = 0\n    | count_upper(s,\
    \ 1, 21) = 0\n    | count_upper(s, 0, 22) = 0\n    | count_upper(s, 1, 22) = 0\n\
    \    | count_upper(s, 0, 23) = 0\n    | count_upper(s, 1, 23) = 0\n    | count_upper(s,\
    \ 0, 24) = 0\n    | count_upper(s, 1, 24) = 0\n    | count_upper(s, 0, 25) = 0\n\
    \    | count_upper(s, 1, 25) = 0\n    | count_upper(s, 0, 26) = 0\n    | count_upper(s,\
    \ 1, 26) = 0\n    | count_upper(s, 0, 27) = 0\n    | count_upper(s, 1, 27) = 0\n\
    \    | count_upper(s, 0, 28) = 0\n    | count_upper(s, 1, 28) = 0\n    | count_upper(s,\
    \ 0, 29) = 0\n    | count_upper(s, 1, 29) = 0\n    | count_upper(s, 0, 30) = 0\n\
    \    | count_upper(s, 1, 30) = 0\n    | count_upper(s, 0, 31) = 0\n    | count_upper(s,\
    \ 1, 31) = 0\n    | count_upper", "    i = 0\n    while i < length(s) do\n   \
    \     j = i+1\n        while j < length(s) do\n            if s[i] == s[j] then\n\
    \                return 1\n            end\n            j += 1\n        end\n\
    \        i += 1\n    end\n    return 0\nend\n</cell>\n<code language=julia-1.3>",
  "    | s | \"\" -> 0\n    | _ when s !~ /^[aeiouAEIOU]+$/ -> 0\n    | _ -> 1 + count_upper(s[1..])\n\
    end\n</cell>\n<code language=julia-1.5>\ncount_upper(\"aBCdEf\")\n</cell>\n<text>\n\
    5.2 Exercise - Replace Characters", "    if s == \"\" then 1 else 0 \n    | map((=='A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'))\
    \ \n    | fold(+, 0)\n    end\n</cell>\n<cell>\n@test count_upper(\"\"\"abcdefg\"\
    \"\") == 1\n@test count_upper(\"\"\"aBCdEf\"\"\") == 1\n@test count_upper(\"\"\
    \"dBBE\"\"\") == 0\n</cell>\n<text>\nExercise\nGiven the string \"foobar\", write\
    \ a function called count_vowels() that returns the number of vowels. Write it\
    \ so that it works for any given string.", "    if is_empty(s) then 1 else 0\n\
    \    for c in s do if c in uppercases then count_upper(c ++ \"B\") else 0\nend",
  "    count_upper_aux(0,s,0)\nend", "    cdef int i, n_u = 0\n    cdef str u = uc_alphabet\n\
    \    cdef size_t n = (s.length - 1) // 3\n    cdef size_t k = (s.length - 1) %\
    \ 3\n    for i in range(n):\n        if s[i] == u[k]:\n            n_u += 1\n\
    \        k += 1\n        if k == 2: k = 0\n    return n_u\n</code>\n<|/ a tags=performance,cython,string,python\
    \ |>\n<| c |>\nThanks! My mistake, it's supposed to be `cdef str u = uc_alphabet`\n\
    <|/ c |>\n<| c |>\nAlso you should be using unicode strings, not ASCII strings.\n\
    <|/ c |>\n<| c |>\nThanks for the tips, I wasn't aware that the code assumes ASCII\
    \ strings.\n<|/ c |>\n<| c |>\nIt would be nice if you could write your answer\
    \ as a proper Cython code, because at the moment I cannot read Cython and I really\
    \ don't understand the code. Thank you!\n<|/ c |>\n<| a dscore=2 tags=performance,cython,string,python\
    \ |>\nThis isn't the most efficient solution in terms of time and space complexity\
    \ but it's also the simplest.\n<code>\ndef count_upper(s):\n    total = 0\n  \
    \  for i in xrange(len(s)):\n        if s[i].isupper():\n            total +=\
    \ 1\n    return total\n</code>\n<|/ a |>\n<| c |>\nThanks for the answer, I forgot\
    \ about the .isupper() method :)\n<|/ c |>\n<| c |>\nThis is very unnecessarily\
    \ inefficient -- `for letter in s` already does `letter.islower()`. Plus, you\
    \ should be using `enumerate` to get the indices and values.\n<|/ c |>\n<| c |>\n\
    This is just plain terrible. `for i in range(len(s))` is almost always a bad idea.\n\
    <|/ c |>\n<| c |>\nYeah I agree. Having said that, the most efficient solution\
    \ would be to replace my `for` loop with yours and use Cython to replace the loop\
    \ with `for letter in s:` and avoid the explicit indexing altogether.\n<|/ c |>\n\
    <| c |>\nIt's not just \"almost always a bad idea\", it's *always* a bad idea.\
    \ `for i in range(len(s))` is idiomatic in Python and should be used.\n<|/ c |>\n\
    <| a tags=performance,cython,string,python |>\nIn python, strings have a method\
    \ called .upper() which will return a new string in which the case of each character\
    \ is changed to uppercase.\nIn order to do this, one might use something like\n\
    <code>\ndef count_upper", "    if is_uppercase(s[0..2]) then return 1 else 0\n\
    \    if is_uppercase(s[0..3]) then return 1 else 0\n    if is_uppercase(s[0..5])\
    \ then return 1 else 0\n    if is_uppercase(s[0..6]) then return 1 else 0\n  \
    \  if is_uppercase(s[0..7]) then return 1 else 0\n    if is_uppercase(s[0..8])\
    \ then return 1 else 0\n    if is_uppercase(s[0..10]) then return 1 else 0\n \
    \   if is_uppercase(s[0..11]) then return 1 else 0\n    if is_uppercase(s[0..12])\
    \ then return 1 else 0\n    if is_uppercase(s[0..13]) then return 1 else 0\n \
    \   if is_uppercase(s[0..14]) then return 1 else 0\n    if is_uppercase(s[0..15])\
    \ then return 1 else 0\n    if is_uppercase(s[0..16]) then return 1 else 0\n \
    \   if is_uppercase(s[0..17]) then return 1 else 0\n    if is_uppercase(s[0..18])\
    \ then return 1 else 0\n    if is_uppercase(s[0..19]) then return 1 else 0\n \
    \   if is_uppercase(s[0..20]) then return 1 else 0\n    if is_uppercase(s[0..21])\
    \ then return 1 else 0\n    if is_uppercase(s[0..22]) then return 1 else 0\n \
    \   if is_uppercase(s[0..23]) then return 1 else 0\n    if is_uppercase(s[0..24])\
    \ then return 1 else 0\n    if is_uppercase(s[0..25]) then return 1 else 0\n \
    \   if is_uppercase(s[0..26]) then return 1 else 0\n    if is_uppercase(s[0..27])\
    \ then return 1 else 0\n    if is_uppercase(s[0..28]) then return 1 else 0\n \
    \   if is_uppercase(s[0..29]) then return 1 else 0\n    if is_uppercase(s[0..30])\
    \ then return 1 else 0\n    if is_uppercase(s[0..31]) then return 1 else 0\n \
    \   if is_uppercase(s[0..32]) then return 1 else 0\n    if is_uppercase(s[0..33])\
    \ then return 1 else 0\n    if is_uppercase(s[0..34]) then return 1 else 0\n \
    \   if is_uppercase(s[0..35]) then return 1 else 0\n    if is_uppercase(s[0..36])\
    \ then return 1 else 0\n    if is_uppercase(s[0..37]) then return 1 else 0\n \
    \   if is_uppercase(s[0..38]) then return 1 else 0\n    if is_uppercase(s[0..39])\
    \ then return 1 else 0\n    if is_uppercase(s[0..40]) then return 1 else 0\n \
    \   if is_uppercase(s[0..41]) then return 1 else 0\n    if is_uppercase(s[0..42])\
    \ then return 1 else 0\n    if is_uppercase(s[", "    count = 0\n    for c in\
    \ s do\n        if is_uppercase(c) then\n            count += 1\n        else\
    \ if is_vowel(c) then\n            count -= 1\n        end\n    end\n    return\
    \ count\nend\n</cell>\n<code language=julia-0.5>\n# Pkg.add(\"Regexp\")\n</cell>\n\
    <code language=julia-0.5>", "    count_uppers = sum(isupper(ch) for ch in s)\n\
    \    count_upper_even = count_uppers % 2 == 0\n    return count_upper_even", " \
    \   r <- 0\n    for c in s\n        if isupper(c)\n            if c > 'Z' \n \
    \               r <- r + 1\n            else\n                r <- r\n    end\n\
    \    return r\nend\n</cell>\n<code language=julia-0.6>\n@time count_upper(\"aBCdEf\"\
    )\n</cell>\n<text>\nExercise 1\nWhat does the following expression return?", " \
    \   count=0\n    for idx in 0..(length(s)-1)\n        if s[idx] >=65 && s[idx]\
    \ <=90\n            count+=1\n        end\n    end\n    return count\nend\n</cell>\n\
    <code language=julia-1.6>\ncount_upper(\"aBCdEf\")\n</cell>\n<code language=julia-1.6>\n\
    count_upper(\"abcdefg\")\n</cell>\n<code language=julia-1.6>\ncount_upper(\"dBBE\"\
    )\n</cell>\n<text>\nExercise: Count all vowels\nWrite a function count_vowels(s::String)\
    \ that returns the number of vowels in s in an Int64.", "    | count_upper _ =\
    \ 1 \n    | count_upper (c:Char)::Int64 = count_upper (c .succ if c >= 'a' &&\
    \ c <= 'z' else c) \n    | count_upper (c:Char)::Int64 = count_upper (c .pred\
    \ if c >= 'a' && c <= 'z' else c) \n    | count_upper (c:Char)::Int64 = count_upper\
    \ (c .pred if c >= 'a' && c <= 'z' || c .succ if c >= 'A' && c <= 'Z' else c)\
    \ \n    | count_upper (c:Char)::Int64 = count_upper (c .pred if c >= 'A' && c\
    \ <= 'Z' || c .succ if c >= 'a' && c <= 'z' else c) \n    | count_upper (c:Char)::Int64\
    \ = count_upper (c .pred if c >= 'a' && c <= 'z' || c .succ if c >= 'A' && c <=\
    \ 'Z' else c) \n    | otherwise = count_upper _\n    ", "    cdef int result =\
    \ 0\n    cdef char current_char\n    cdef int idx\n    for idx in range(0, len(s)):\n\
    \        current_char = s[idx]\n        if current_char == 'a' or current_char\
    \ == 'e' or current_char == 'i' \\\n            or current_char == 'o' or current_char\
    \ == 'u':\n            result += 1\n    return result", "    if is_zero(length(s))\n\
    \        return 0\n    if is_zero(length(s[2:end-1]))\n        return length(s)-1\n\
    \    if is_zero(length(s[2:end-1][2:end-1]))\n        return length(s)-2\n   \
    \ else \n        if is_zero(length(s[2:end-1][2:end-1][2:end-1]))\n          \
    \  return length(s)-3\n        else \n            return length(s)-2\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"\n    Given a string s, count the number of uppercase\
    \ vowels in odd indices.\n    \n    For example:\n    >>> count_upper(\"aBCdEf\"\
    )\n    1\n    >>> count_upper(\"abcdefg\")\n    0\n    >>> count_upper(\"dBBE\"\
    )\n    0\n\"\"\"", "    count = 0\n    for c in s\n        if c.isUpper\n    \
    \        count += 1\n            \n    return count", "    count = 0\n    for\
    \ (i,c) in enumerates(s):\n        if ((i %% 2) == 0) && is_upper_case(c):\n \
    \           count += 1\n        end\n    end\n    return count\nend\n</cell>\n\
    <code language=julia-0.5>\ncount_upper(\"aBCdEf\")\n</cell>\n<code language=julia-0.5>\n\
    count_upper(\"abcdefg\")\n</cell>\n<code language=julia-0.5>\ncount_upper(\"dBBE\"\
    )\n</cell>\n<text>\nExercise: Change the definition of count_lower from above\
    \ so that it returns 1 for \"ABCDEFG\", 0 otherwise.", "    | s == '' -> 0\n \
    \   | is_upper(charAt(0,1)) && charAt(1,2) == 'B' -> 1\n    | is_upper(charAt(0,1))\
    \ && charAt(1,2) == 'E' -> 1\n    | is_upper(charAt(0,2)) && charAt(1,2) == 'B'\
    \ -> 1\n    | is_upper(charAt(0,2)) && charAt(1,2) == 'E' -> 1\n    | is_upper(charAt(0,3))\
    \ && charAt(1,2) == 'B' -> 1\n    | is_upper(charAt(0,3)) && charAt(1,2) == 'E'\
    \ -> 1\n    | is_upper(charAt(0,4)) && charAt(1,2) == 'B' -> 1\n    | is_upper(charAt(0,4))\
    \ && charAt(1,2) == 'E' -> 1\n    | is_upper(charAt(0,5)) && charAt(1,2) == 'B'\
    \ -> 1\n    | is_upper(charAt(0,5)) && charAt(1,2) == 'E' -> 1\n    | is_upper(charAt(0,6))\
    \ && charAt(1,2) == 'B' -> 1\n    | is_upper(charAt(0,6)) && charAt(1,2) == 'E'\
    \ -> 1\n    | is_upper(charAt(0,7)) && charAt(1,2) == 'B' -> 1\n    | is_upper(charAt(0,7))\
    \ && charAt(1,2) == 'E' -> 1\n    | is_upper(charAt(0,8)) && charAt(1,2) == 'B'\
    \ -> 1\n    | is_upper(charAt(0,8)) && charAt(1,2) == 'E' -> 1\n    | is_upper(charAt(0,9))\
    \ && charAt(1,2) == 'B' -> 1\n    | is_upper(charAt(0,9)) && charAt(1,2) == 'E'\
    \ -> 1\n    | is_upper(charAt(0,10)) && charAt(1,2) == 'B' -> 1\n    | is_upper(charAt(0,10))\
    \ && charAt(1,2) == 'E' -> 1\n    | is_upper(charAt(0,11)) && charAt(1,2) == 'B'\
    \ -> 1\n    | is_upper(charAt(0,11)) && charAt(1,2) == 'E' -> 1\n    | is_upper(charAt(0,12))\
    \ && charAt(1,2) == 'B' -> 1\n    | is_upper(charAt(0,12)) && charAt(1,2) == 'E'\
    \ -> 1\n    | is_upper(charAt(0,13)) && charAt(1,2) == 'B' -> 1\n    | is_upper(charAt(0,13))\
    \ && charAt(1,2) == 'E' -> 1\n    | is_upper(charAt(0,14)) && charAt(1,2) == 'B'\
    \ -> 1\n    | is_upper(charAt(0,14)) && charAt(1,2) == 'E' -> 1\n    | is_upper(charAt(0,",
  "  | (length s) == 0 => 0\n  | otherwise => sum (map fst $ filter (\\(c, i) -> c\
    \ == 'a' && i `mod` 2 == 0) $ zip [1 .. length s - 1] s)\n</code>\n<|/ a |>\n\
    <| c |>\nI appreciate all the different ways this could be solved.  It would be\
    \ nice if this were covered in some general way, though.  It would be interesting\
    \ to see how the other solutions compare in terms of asymptotic performance.\n\
    <|/ c |>\n<| c |>\nThank you for this, I am just looking at this now. What are\
    \ the | and otherwise?\n<|/ c |>\n<| c |>\n`|` is the conditional operator, and\
    \ `otherwise` is the default return value if the conditional fails. I updated\
    \ my answer to show how to use them.\n<|/ c |>\n<| c |>\nThis should be the accepted\
    \ answer. Being a one-liner is good enough.\n<|/ c |>\n<| a |>\nHere's a solution\
    \ with an O(n) average time complexity, while still being O(n) space complexity:\n\
    <code>\nlet count_upper cs = sum $ map count $ filter (\\(c,i) -> c == 'a' &&\
    \ i `mod` 2 == 0) $ zip cs [0..]\n</code>\n<|/ a tags=haskell dscore=4 |>\n<|\
    \ c |>\nYes I agree, this is more readable. But I like to see such answers first\
    \ :-)\n<|/ c |>\n<| a dscore=4 |>\nHere are some answers for people who like lambdas:\n\
    <code>\ncount_upper :: String -> Int\ncount_upper str = sum (map count $ filter\
    \ (\\(c,i) -> c == 'a' && i `mod` 2 == 0) $ zip str [0..])\n</code>\n<|/ a tags=haskell\
    \ |>\n<| a dscore=4 |>\nSince Haskell is lazy, here's a fun solution using lazy\
    \ folds:\n<code>\ncount_upper s = foldl (\\_ _ -> return 1) (return 0)\n    (filter\
    \ isUpper . zip s [0..]) (s ++ repeat 0)\n</code>\nIt's not pretty, but it has\
    \ the virtue of not having to import anything. Another benefit is that it doesn't\
    \ require an import of Data.Char.\n<|/ a tags=haskell |>\n<| c |>\nYou can shorten\
    \ the foldl by replacing it with foldl'\n<|/ c |>\n<| a |>\n<code>\nlet count_upper\
    \ s = sum (map count $ ", "    let count = s.count{char c | 'A' <= c && c <= 'Z'\
    \ || 'a' <= c && c <= 'z' == true}\n    return count\nend\n</cell>\n<code language=julia-1.4>\n\
    \"\"\"\n    The count_letter function counts how many times a letter is in a string.\
    \ \n    \n    The function has one parameter that specifies the string. \n   \
    \ \n    The function returns a tuple (count_letter, letter).\n\"\"\"", "\"\"\"\
    \n    Count the number of uppercase vowels in even indices of the string. \n\"\
    \"\"\n    count := 0\n    pos := 0\n    for i in 0..(length(s) - 1):\n       \
    \ if s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' \n\
    \            || (s[i] == 'A' && s[i+1] == 'E' && s[i+2] == 'I' && s[i+3] == 'O'\
    \ && \n            s[i+4] == 'U')\n            count += 1\n        else \n   \
    \         pos := i + 1\n    return count\n\"\"\"\n    Count the number of uppercase\
    \ vowels in even indices of the string.\n\"\"\"", "  count_upper=0\n  for c in\
    \ s\n    if c is 'a' || c is 'e' || c is 'i' || c is 'o' || c is 'u'\n      count_upper=count_upper+1\n\
    \    end\n  end\n  return count_upper\nend\n</cell>\n<code language=julia-1.3>",
  "    count = 0\n    for ch in s:\n        if ch >= 'A' and ch <= 'Z': count += 1\n\
    \    return count\n\"\"\"\n    countvowels(s) = countvowels_new(s)\n    \n   \
    \ Returns a count of the number of vowels ('A', 'E', or 'I') in s.\n    \n   \
    \ Parameters \n    ------------------\n    s \u2208 String : any string\n    \n\
    \    Returns\n    ------------------\n    Int : number of vowels in s\n    \n\
    \    Raise an exception If s contains anything other than letters A-Z and 'A'-'Z',\
    \ or if s contains no vowels.\n    \"\"\"", "    sum(map(chr, map(ord, s))) |>\
    \ Int64\nend", "    for i in 1 .. length(s)\n        if s[i] == 'a' || s[i] ==\
    \ 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' then \n            count +=\
    \ 1\n        \n    return count\n\"\"\"\n    \n    \n# Define a function that\
    \ returns the number of lowercase vowels in a string.\n\"\"\"\n    Given a string\
    \ s, count the number of lowercase vowels in even indices.\n    \n    For example:\n\
    \    >>> count_lower(\"aBCdEf\")\n    2\n    >>> count_lower(\"abcdefg\")\n  \
    \  0\n    >>> count_lower(\"dBBE\")\n    0\n    \"\"\"", "    \"\"\"\n    Count\
    \ number of uppercase vowels\n    \"\"\"\n    if s.length == 0 then 0 else \n\
    \      if substring(s, 0, 2) in [\"A\",\"E\",\"I\",\"O\",\"U\"] then 1 else 0\
    \ end\n</code>\nAnd finally, your count_upper_list function can look like this\
    \ :\n<code>", "    r <- 0\n    for c in s\n        if isupper(c) && c % 2 == 0\n\
    \            r <- r + 1\n    r\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\
    \n    Given a list of strings, return a dictionary mapping each string to its\n\
    \    number of occurrences, sorted from most to least frequent. \n    \n    For\
    \ example:\n    >>> count_letters([\"a\", \"b\", \"b\", \"a\", \"c\", \"c\", \"\
    c\"])\n    {\"a\": 2, \"b\": 2, \"c\": 3}\n    >>> count_letters([\"d\"])\n  \
    \  {}\n    >>> count_letters([])\n    {}\n    \"\"\"", "    if s == \"\" then\
    \ 0 else count_upper_aux(s[1..], 0)\nend ", "    count := 0\n    for c in s\n\
    \        if isupper(c)\n            if count % 2 == 0\n                count +=\
    \ 1\n            else\n                count = 0\n        else\n            count\
    \ = 0\n    end\n    return count\nend\n</cell>\n<code language=julia-1.2>\n\"\"\
    \"\n    count_upper_case(s::String)", "    \"\"\"\n    Returns the number of uppercase\
    \ vowels in even indices.\n    \n    For example:\n    >>> count_upper(\"aBCdEf\"\
    )\n    1\n    >>> count_upper(\"abcdefg\")\n    0\n    >>> count_upper(\"dBBE\"\
    )\n    0\n    \"\"\"", "    count = 0\n    match s[1:] {\n        \"\" => 0,\n\
    \        _ when s[i] >= 'A' && s[i] <= 'Z' => 1,\n        _ => count = 0,\n  \
    \  }\n    if count % 2 == 0 && s.length >= 3 { \n        count += count_upper(s[2..])\
    \ + count_upper(s[3..])\n    }\n    count\nend", "    if s.length == 0\n     \
    \   return -1\n    let mut result = 0\n    for i in 0..length-1\n        result\
    \ += (s[i] == 'A')\n        if s[i] == 'E'\n        result += 1\n    return result\n\
    </code>\n<|/ a tags=string,algorithm,search,pattern-matching,haskell |>\n<| c\
    \ |>\nThis looks like a good starting point, however, I am concerned with the\
    \ impact on performance and memory usage of lists and maps. In the full program,\
    \ I may have a lot of strings, and I may have to check for a lot of patterns at\
    \ once, which could become an issue if I were to iterate over each string over\
    \ and over again. Is this a viable option?\n<|/ c |>\n<| c |>\nIf performance\
    \ is your concern, you should benchmark the solutions proposed here. If they do\
    \ not meet your performance requirements, you can implement your own solution\
    \ on top of them. My initial thought was to implement a binary tree; but after\
    \ rereading the original question, I realized that it is not clear how many patterns\
    \ you are looking for. Perhaps a tree could work well if your patterns are relatively\
    \ well constrained.\n<|/ c |>\n<| c |>\nI agree that benchmarking would help me.\
    \ I have a number of patterns that need to be checked, each pattern has a certain\
    \ weight, and I may have to check a lot of them. How would I go about constructing\
    \ a tree from a list of patterns? Also a map is a better structure than a list\
    \ in this case I believe?\n<|/ c |>\n<| c |>\nA map or dictionary is better than\
    \ a tree for the situation you described. Tree is a good structure when each node\
    \ has exactly two children. Since your patterns are not restricted to a tree structure,\
    \ I don't think it is appropriate to use it. However, you can look into [Binary\
    \ Trees](https://en.wikipedia.org/wiki/Binary_tree). Since your patterns are all\
    \ binary strings, I suggest you look into [BST](https://en.wikipedia.org/wiki/Binary_search_tree).\
    \ As for constructing patterns, you should be able to easily find a way around\
    \ the problem I am describing by considering patterns as binary trees.\n<|/ c\
    \ |>\n<| c |>\nI see, thanks for your help! I will look into these. I will also\
    \ look into the BST, and get back with more questions later!\n<|/ c |>\n<| a tags=string,algorithm,search,pattern-matching,haskell\
    \ |>\nYou don't say how you plan to match strings, but I'm assuming you want to\
    \ use a dictionary or equivalently a hash map.\nIf so, then something like the\
    \ following should work:\n<code>\nimport qualified Data.HashMap.Strict as HM",
  "    count = 0\n    for c in s\n        if isupper(c) && isupper(c[2])\n       \
    \     count+=1\n    end\n    return count", "    \n    \"\"\"\n    Count the number\
    \ of uppercase vowels in an alphabetically sorted list of strings.\n    \n   \
    \ The vowels include 'a', 'e', 'i', 'o', and 'u'.\n    \"\"\"", "    if length(s)==0\
    \ \n        return 0 \n    else \n        return count(upper(s,2),0,length(s)-1)\
    \ \n    end \nend ", "    count_upper(0)\nend", "    \n    count_upper = Int64(0)\n\
    \    for i in 2..length(s) do\n        if s[i] == 'a' || s[i] == 'e' || s[i] ==\
    \ 'i'\n         || s[i] == 'o' || s[i] == 'u' then\n            count_upper +=\
    \ 1\n        end\n    end\n    return count_upper\nend\n</cell>\n<code language=julia-1.6>\n\
    count_upper(\"dBBE\")\n</cell>\n<text>\nExercise 3", "    \n    count = 0\n  \
    \  \n    for i in s.codepoints\n        if isuppercase(i) then count += 1\n  \
    \  end", "    | length s < 2 = 0\n    | otherwise = if substring(s, 1, 1) `elem`\
    \ ['A'..'Z'] then 1 else 0\n</code>\nThe string substring function extracts the\
    \ character at a given index\n<code>", "    | s == \"a\" || s == \"A\" || s ==\
    \ \"e\" || s == \"E\" || s == \"i\" || s == \"I\" || s == \"o\" || s == \"O\"\
    \ || s == \"u\" || s == \"U\" \n        = 1 \n    | s == \"d\" || s == \"D\" ||\
    \ s == \"b\" || s == \"B\" \n        = 0\n    | s == \"c\" || s == \"C\" || s\
    \ == \"f\" || s == \"F\" || s == \"g\" || s == \"G\" \n        = 0\n    | otherwise\
    \ = 0\n</code>\n<|/ a dscore=3 tags=haskell,functional-programming |>\n<| c |>\n\
    Nice job! You can drop the parens, since the `if` expression already has parens.\n\
    <|/ c |>\n<| c |>\nYou don't need parens around the `if`.  That is how you write\
    \ the `||` operator in Haskell.  You might also want to look at how `||` is defined\
    \ in base (which `if ... then ... else ...` is just like in any other language).\n\
    <|/ c |>\n<| c |>\nI don't think `if` has precedence over `|`.\n<|/ c |>\n<| c\
    \ |>\n`if ... then ... else ...` can be written as `case ... of ...`.\n<|/ c |>\n\
    <| c |>\nWhat is wrong with using `x | x == c = 0 | otherwise = 1`?\n<|/ c |>\n\
    <| a tags=haskell,functional-programming |>\nYou mean something like this?\n<code>\n\
    count_upper :: String -> Int\ncount_upper s = sum [ x | x <- s, x `elem` ['a','e','i','o','u','A','E','I','O','U','D','B']\
    \ ]\n</code>\nThe sum [x | x <- s, x `elem` ['a','e','i','o','u','A','E','I','O','U','D','B']]\
    \ checks if the string has any uppercase letters. Then the sum function sums all\
    \ numbers that are true in the list.\n<|/ a dscore=3 |>\n<| c |>\n`elem` doesn't\
    \ work for non-ASCII characters so this fails for `aA`, for example.\n<|/ c |>\n\
    <| c |>\nIt doesn\u2019t work. `['a','e','i','o','u','A','E','I','O','U','D','B']`\
    \ is `[97,102,110,112,114,116,97,103,100,104,11", "    count_upper::Int64 = 0\n\
    \    for (i, c) in enumerate(s) {\n        if isupper(c) && c!=' ' && i>0 {\n\
    \            if c > 'a' && c < 'z' {\n                count_upper += 1\n     \
    \       }\n        }\n    }\n    return count_upper\nend\n</cell>\n<code language=julia-1.5>\n\
    @time count_upper(mystring);\n</cell>\n<text>\nAnd now let's make it fast!", " \
    \   count = 0\n    for i in [0..len(s)-1] \n        if s[i] == 'B' || s[i] ==\
    \ 'b' || s[i] == 'D' || s[i] == 'd' || s[i] == 'E' || s[i] == 'e' || s[i] == 'F'\
    \ || s[i] == 'f' \n            count+=1, \n        elseif s[i] == 'G' || s[i]\
    \ == 'g' \n            count+=1 \n    end\n    return count\nend", "    if is_empty(s):\n\
    \        return 0\n    count_a = 0\n    count_b = 0\n    count_c = 0\n    count_d\
    \ = 0\n    count_e = 0\n    count_f = 0\n    count_g = 0\n    count_h = 0\n  \
    \  count_i = 0\n    count_j = 0\n    count_k = 0\n    count_l = 0\n    count_m\
    \ = 0\n    count_n = 0\n    count_o = 0\n    count_p = 0\n    count_q = 0\n  \
    \  count_r = 0\n    count_s = 0\n    count_t = 0\n    count_u = 0\n    count_v\
    \ = 0\n    count_w = 0\n    count_x = 0\n    count_y = 0\n    count_z = 0", " \
    \   count := 0\n    for e in s.chars() do\n        if isupper(e) then\n      \
    \      if count(e) == 0 then\n                count := 1\n            else\n \
    \               count := count + 1\n        end\n    end\n    return count\nend",
  "    if s.length == 0 \n        0\n    else\n        1 + sum(s[i] >= 'A' && s[i]\
    \ <= 'Z' for i in 2..s.length)\nend\n</cell>\n<text>\nA. Vowel Strings", "   \
    \ if is_empty(s) then 0 else count_upper(suffix(s,1)) + count_upper(prefix(s,1))\n\
    end", "    | s.length <= 1 => 0\n    | is_anagram(s, s[:1]*2)  => count_upper(s[1:])\n\
    \    | is_anagram(s, s[1:]) => count_upper(s[:1]) + count_upper(s[1:])\n    |\
    \ otherwise           => count_upper(s[1:]) \n    where\n        is_anagram(s,t)\
    \ =\n            let ts = split(t) in\n            length(intersect(s, ts)) >=\
    \ 2 and\n            length(intersect(ts, s)) >= 2 and\n            all(elem ==\
    \ ts[i .. i-1] | i in [0..i-1] | elem == ts[i])\n\"\"\"\n    Given a string s,\
    \ count the number of uppercase vowels in odd indices.\n    \n    For example:\n\
    \    >>> count_upper(\"aBCdEf\")\n    1\n    >>> count_upper(\"abcdefg\")\n  \
    \  0\n    >>> count_upper(\"dBBE\")\n    0\n    \"\"\"", "    if (length s <=\
    \ 1) \n        return 0\n    let s = tostring(s)\n    len = length(s)\n    for\
    \ i in 2 to len\n        local char = s[i]\n        if char == \"a\"\n       \
    \     then return 1\n        else if char == \"e\"\n            then return 1\n\
    \        else if char == \"i\"\n            then return 1\n        else if char\
    \ == \"o\"\n            then return 1\n        else if char == \"u\"\n       \
    \     then return 1\n        else return 0\n    end\nend\n</cell>\n<code language=julia-0.6>",
  "    # Complete this function by filling in the line below.\n    return 0\nend\n\
    </cell>\n<code language=julia-1.4>", "  if length(s) <= 0 \n    throw(ArgumentError(\"\
    String length must be positive\"))\n  else if length(s) mod 2 != 0 \n    throw(ArgumentError(\"\
    String length must be even\"))\n  else if s(0) == \"a\" \n    return 1\n  else\
    \ if s(0) == \"b\" \n    return 0\n  else if s(0) == \"c\" \n    return 0\n  else\
    \ if s(0) == \"d\" \n    return 1\n  else if s(0) == \"e\" \n    return 0\n  else\
    \ if s(0) == \"f\" \n    return 0\n  else if s(0) == \"g\" \n    return 1\n  else\
    \ if s(0) == \"h\" \n    return 0\n  else if s(0) == \"i\" \n    return 0\n  else\
    \ if s(0) == \"j\" \n    return 0\n  else if s(0) == \"k\" \n    return 0\n  else\
    \ if s(0) == \"l\" \n    return 0\n  else if s(0) == \"m\" \n    return 0\n  else\
    \ if s(0) == \"n\" \n    return 0\n  else if s(0) == \"o\" \n    return 0\n  else\
    \ if s(0) == \"p\" \n    return 0\n  else if s(0) == \"q\" \n    return 0\n  else\
    \ if s(0) == \"r\" \n    return 0\n  else if s(0) == \"s\" \n    return 0\n  else\
    \ if s(0) == \"t\" \n    return 0\n  else if s(0) == \"u\" \n    return 0\n  else\
    \ if s(0) == \"v\" \n    return 0\n  else if s(0) == \"w\" \n    return 0\n  else\
    \ if s(0) == \"x\" \n    return 0\n  else if s(0) == \"y\" \n    return 0\n  else\
    \ if s(0) == \"z\" \n    return 0\n  else if s(0) == \"A\" \n    return 1\n  else\
    \ if s(0) == \"B\" \n    return 0\n  else if s(0) == \"C\" \n    return 0\n  else\
    \ if s(0) == \"D\" \n    return 1\n  else if s(0) == \"E\" \n    return 0\n  else\
    \ if s(0) == \"F\" \n    return 0\n  else if s(0) == \"G\" \n    return 1\n  else\
    \ if s(0) == \"H\" \n    return 0\n  else if s(0) == \"I\" \n    return 0\n  else\
    \ if s(0) == \"J\" \n    return 0\n  else if s(0) == \"K\" \n    return 0\n  else\
    \ if s(0) == \"L\" \n    return 0\n  else if s(0) == \"M\" \n    return 0\n  else\
    \ if s(0) == \"N", "    if length(s) == 0 then 0 else 0 \n    else if starts_with_c(s,\"\
    a\") \n        then count_upper(substring(s,1,2)) + count_upper(substring(s,2,2))\n\
    \        else if starts_with_c(s,\"b\") \n            then count_upper(substring(s,1,2))\
    \ + count_upper(substring(s,2,2))\n            else if starts_with_c(s,\"c\")\n\
    \                then count_upper(substring(s,1,2)) + count_upper(substring(s,2,2))\n\
    \                else if starts_with_c(s,\"d\")\n                    then count_upper(substring(s,1,2))\
    \ + count_upper(substring(s,2,2))\n                    else if starts_with_c(s,\"\
    e\")\n                        then count_upper(substring(s,1,2)) + count_upper(substring(s,2,2))\n\
    \                        else if starts_with_c(s,\"f\")\n                    \
    \        then count_upper(substring(s,1,2)) + count_upper(substring(s,2,2))\n\
    \                            else if starts_with_c(s,\"g\")\n                \
    \                then count_upper(substring(s,1,2)) + count_upper(substring(s,2,2))\n\
    \                                else 0\n    end\nend\n</cell>\n<cell>\n@test\
    \ count_upper(\"aBCdEf\") == 2\n</cell>\n<cell>\n@test count_upper(\"abcdefg\"\
    ) == 0\n</cell>\n<cell>\n@test count_upper(\"dBBE\") == 3\n</cell>\n<text>\nProblem\
    \ 2\nGiven two strings s1 and s2, return True if s2 is an anagram of s1. If s2\
    \ is not an anagram of s1, return False.", "  | len(s) = 0 \n  | len(s) <= 0 =\
    \ -1\n  | otherwise = if 0 == count_vowels(s, 1)\n                    then 0\n\
    \                    else if count_vowels(s, 0) == 2\n                       \
    \   then count_vowels(s, 1)\n                          else -1\n</code>\n<|/ a\
    \ dscore=1 tags=haskell,string,recursion |>\n<| c |>\nOh yeah. Thanks a lot. I\
    \ was stuck on this for quite some time.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n\
    count_vowels :: String -> Int\ncount_vowels [] = 0\ncount_vowels (x:xs) | isVowel\
    \ x = 1 + count_vowels xs\n                    | otherwise = count_vowels xs",
  "    |[Int64] =\n    let n = 0\n    |for ch in s do \n    |if ch in 'aeiou' then\
    \ \n    |n += 1\n    |end\n    |n\n    |\n\"\"\"\n    Given a string s, count\
    \ the number of uppercase vowels in odd indices.\n    \n    For example:\n   \
    \ >>> count_upper(\"aBCdEf\")\n    2\n    >>> count_upper(\"abcdefg\")\n    0\n\
    \    >>> count_upper(\"dBBE\")\n    0\n    \"\"\"", "    if s == \"\"\n      \
    \  return 0;\n    else if all(islower(c) for c in s) && count(c,'A')%2==0\n  \
    \      return count(s,'A');\n    else\n        return 0;\n    end\nend\n</cell>\n\
    <code language=julia-1.6>", "        \n    # Your code goes here\n    return 1\n\
    end \n</cell>\n<text>\nCount the number of vowels in even indices of s.\nFor example,\
    \ count_even(\"aBCdEf\") = 1, but count_even(\"aBcDfE\") = 0.", " \n    #\n  \
    \  # Write your solution here.\n    #\n    return\nend function count_upper"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
