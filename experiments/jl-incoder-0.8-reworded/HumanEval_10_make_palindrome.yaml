name: HumanEval_10_make_palindrome
language: jl
prompt: "\"\"\" Find the shortest palindrome that begins with a supplied string.\n\
  \    Algorithm idea is simple:\n    - Find the longest postfix of supplied string\
  \ that is a palindrome.\n    - Append to the end of the string reverse of a string\
  \ prefix that comes before the palindromic suffix.\n    >>> make_palindrome(\"\"\
  )\n    \"\"\n    >>> make_palindrome(\"cat\")\n    \"catac\"\n    >>> make_palindrome(\"\
  cata\")\n    \"catac\"\n    \"\"\"\nfunction make_palindrome(string::String)::String\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = make_palindrome;\n\t@test(candidate(\"\
  \") == \"\")\n\t@test(candidate(\"x\") == \"x\")\n\t@test(candidate(\"xyz\") ==\
  \ \"xyzyx\")\n\t@test(candidate(\"xyx\") == \"xyx\")\n\t@test(candidate(\"jerry\"\
  ) == \"jerryrrej\")\nend\n"
completions: ["    palindrome = \"\"\n    chars = string.chars()\n    largest = 0\n\
    \    for i in chars:\n        if i == largest and i == chars[-1]:\n          \
    \  return palindrome\n        if i == largest and i != chars[-1]:\n          \
    \  palindrome += string[chars.index(largest)]\n            largest = i\n    if\
    \ largest == 0 and largest  != chars[-1]:\n        palindrome += string[chars.index(largest)]\n\
    \    return palindrome\nend\n</cell>\n<code language=julia-1.0>\n# Solution using\
    \ for loops", "    l = length(string.)\n    return string[-l/2:] + reverse(string.)\n\
    end\n</code>\n<|/ a |>\n<| a tags=string,julia dscore=2 |>\nHere is a way to do\
    \ it without using reverse (as it's relatively slow):\n<code>", "  # TODO: Your\
    \ code here\n  local string\n  local new_string\n  local palindrome\n  local longest_post_palindrome\n\
    \  local longest_prefix_palindrome\n  local reverse_string\n  local longest_suffix_palindrome",
  "    if string == \"\"\n        return \"\"\n    else:\n        middle = findMiddle(string)\n\
    \        start = findLongestPostfix(string)\n        end = findLongestPostfix(middle)\n\
    \        result = string[start:end]\n        result *= string[middle:end]\n  \
    \      result *= reverse(middle)\n        return result", "\"\"\"Find the shortest\
    \ palindrome that begins with a supplied string.\nAlgorithm idea is simple:\n\
    \    - Find the longest postfix of supplied string that is a palindrome.\n   \
    \ - Append to the end of the string reverse of a string prefix that comes before\
    \ the palindromic suffix.\"\"\"\n  \n  # Your code here\n  \n  if string.length\
    \ == 0 \n      return string\n  \n  if string.length > 1 \n    return make_palindrome(string[1:length-1])\
    \ + string[0]\n  \n  if string[0]==string[-1] \n      return string\n  \n  return\
    \ make_palindrome(string[1:length-1]) + string[length-1]\nend", "    if string\
    \ == \"\"\n        return \"\"\n    endIndex = 0\n    while endIndex < length(string)\n\
    \        current = string[endIndex + 1]\n        rest = string[endIndex + 2 :\
    \ length(string)]\n        if current == reverse(current)\n            string\
    \ = string + string(endIndex, length - endIndex + 1) + rest\n            endIndex\
    \ = endIndex + 2\n        else\n            endIndex = endIndex + 1\n        end\n\
    \    end\n    return string\nend\n</cell>\n<code language=julia-1.5>", "    i\
    \ = find_longest_prefix(string)\n    j = find_longest_suffix(string)\n    if i\
    \ == 0 && j == 0 \n        return string \n    else\n        return string[i..(j-1)]\
    \ + reverse(string.substring(i, j))\n    end\nend\n</cell>\n<code language=julia-0.5>\n\
    @assert make_palindrome(\"abc\") == \"cba\"\n@assert make_palindrome(\"acb\")\
    \ == \"acb\"\n@assert make_palindrome(\"cat\") == \"catac\"\n@assert make_palindrome(\"\
    cata\") == \"catac\"\n</cell>\n<text>\nPalindromes in Strings\nJulia provides\
    \ a few built-in functions to test for palindromic strings. First, Julia's built-in\
    \ function ispalindrome:", "    if string == \"\" \n        then return string\n\
    \    else if string.head == string.reverse \n        then return string ++ string.reverse\
    \ + make_palindrome(string.tail)\n    else \n        return string\n    end\n\
    end", "    if string == \"\"\n        return string\n    elif is_palindrome(string)\n\
    \        return string\n    else if length(string(string) - reverse_string(string))\n\
    \        string = string + reverse_string(string(string))\n        return string\n\
    \    else if length(string(string) - reverse_string(string(string)))\n       \
    \ string = string + reverse_string(string(string))\n        return string\n  \
    \  else if length(string(string(string) - reverse_string(string(string))))\n \
    \       string = string + reverse_string(string(string))\n        return string\n\
    \    else\n        string = string + reverse_string(string(string))\n        return\
    \ string\n    end\nend", "    len_str = length(string)\n    if len_str < 1\n \
    \       return \"\"\n    begin = string[0..(len_str/2)]\n    end = string[(len_str+1)..len_str]\n\
    \    if begin == reverse(begin)\n        return begin + reverse(end)\n    end\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a |>\nHere is my implementation to solve this\
    \ question:\n<code>", "    length <- length(string)\n    if length == 0 \n   \
    \     \"\" \n    else \n        \n        if length == 1 \n            string\
    \ \n        else \n            \n            prefix <- substr(string,1,(length-1))\n\
    \            suffix <- substr(string,(length-1))\n            suffix <- make_palindrome(suffix)\n\
    \            if suffix == suffix \n                prefix <- reverse prefix\n\
    \                string <- append(prefix,suffix)\n            \n            suffix\
    \ <- make_palindrome(suffix)\n            if suffix == suffix \n             \
    \   prefix <- reverse prefix\n                string <- append(prefix,suffix)\n\
    \    \n            string \nend \nend ", "\"\"\"\nFind the shortest palindrome\
    \ that begins with a supplied string.\nAlgorithm idea is simple:\n  - Find the\
    \ longest postfix of supplied string that is a palindrome.\n  - Append to the\
    \ end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n  \n  >>> make_palindrome(\"\")\n  \"\"\n  >>> make_palindrome(\"cat\"\
    )\n  \"catac\"\n  >>> make_palindrome(\"cata\")\n  \"catac\"\n  \"\"\"", "   \
    \ \"\"\"\n    >>> make_palindrome(\"\")\n    \"\"\n    >>> make_palindrome(\"\
    cat\")\n    \"catac\"\n    >>> make_palindrome(\"cata\")\n    \"catac\"\n    \"\
    \"\"\n    return reversed_string(string) + string", "    max_length = 0\n    for\
    \ str in string.split(\" \"):\n        if str in (string, string[::-1]):\n   \
    \         max_length = max(max_length, len(str)-len(string[::-1]))\n    return\
    \ string[:max_length]", "\"\"\"Return the length of the longest palindrome that\
    \ starts with string.\n    >>> make_palindrome(\"cata\")\n    3\n    \"\"\"",
  "    \"\"\"\n    Find largest postfix of string that is a palindrome\n    \"\"\"\
    \n    palindrome_prefix = \"\"\n    i = 0\n    j = string.length - 1\n    while\
    \ (i < string.length and  j < string.length):\n        if string[i] != string[j]:\n\
    \            i += 1\n            j += 1\n        else :\n            i += 1\n\
    \            j -= 1\n            \n        if j == i:\n            palindrome_prefix\
    \ = palindrome_prefix + string[i]\n            j -= 1\n        \n    return palindrome_prefix\
    \ + string[j:]\nend", "    if length(string) < 1\n        return string\n    \n\
    \    max_length = length(string)\n    palindrome = string(max_length, \"\")\n\
    \    prefix_length = max_length\n    \n    for i in string.indices do\n      \
    \  if string.substring(i+1, i) == string.palindrome(i) then\n            prefix_length\
    \ = i\n        else\n            break\n        end\n    end\n    \n    string[prefix_length..max_length]\n\
    \    \n    for i in string.indices do\n        length = i - prefix_length + max_length\n\
    \        if string.palindrome(length) == string.substring(i+1, i+length) then\n\
    \            palindrome[max_length+i..max_length+i+length] = string[prefix_length..i-1]\n\
    \            max_length = max_length\n        else\n            break\n      \
    \  end\n    end\n    \n    string[palindrome.length..max_length]\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\" Find the shortest palindrome that begins with\
    \ a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix\
    \ of supplied string that is a palindrome.\n    - Append to the end of the string\
    \ reverse of a string prefix that comes before the palindromic suffix.\n    >>>\
    \ make_palindrome(\"\")\n    \"\"\n    >>> make_palindrome(\"cat\")\n    \"catac\"\
    \n    >>> make_palindrome(\"cata\")\n    \"catac\"\n    \"\"\"", "\"\"\"\n   \
    \ >>> make_palindrome(\"cat\")\n    \"catac\"\n    >>> make_palindrome(\"cata\"\
    )\n    \"catac\"\n    \"\"\"\n    if string == \"\"\n        return \"\"\n   \
    \ \n    longest_palindromic = longest_postfix(string)\n    prefix_to_append =\
    \ reverse(string[longest_palindromic..-1])\n    \n    return prefix_to_append\
    \ + string[longest_palindromic..-1]", "    ans = \"\"\n    forall(string, (x)\
    \ -> (x == reverse(x.subString(1))))\n    return ans\n</code>\n<|/ a tags=string,python\
    \ |>\n<| c |>\nNice idea but I think you should add a check for an empty string\
    \ and maybe some asserts to make sure the input is all lowercase.\n<|/ c |>\n\
    <| a dscore=0 |>\nOne simple solution would be to find out longest palindrome\
    \ from the beginning.\n<code>\ndef palindrome(a):\n    longest = 0\n    for i\
    \ in range(len(a)):\n        if a[i] != a[longest - i]:\n            longest =\
    \ i\n            if longest < len(a):\n                break\n            if longest\
    \ == len(a) - 1:\n                return a\n    return \"not found\"\n</code>\n\
    <|/ a tags=string,python |>\n<| c |>\nThis would return \"not found\" as soon\
    \ as it finds a palindrome that's longer than the length of the string, which\
    \ is not necessarily a palindrome. The problem as stated is that a string must\
    \ contain a palindrome but if it contains one that's longer than the string, it\
    \ is not a palindrome.\n<|/ c |>\n<| a dscore=0 |>\nHere is a simple solution\
    \ in C, which I believe is pretty clear:\n<code>\nbool isPalindrome(char *str,\
    \ int len) {\n    int i,j,k,len;\n    for(i = len-1,j=0; i>=0; i--,j++) {\n  \
    \      if(str[i]!=str[j]) {\n            len=0;\n            return false;\n \
    \       }\n    }\n    len=j;\n    return true;\n}\n</code>\n<|/ a tags=string,python\
    \ |>\n<| a tags=string,python |>\nHere is my solution in Java\n<code>\nboolean\
    \ isPalindrome(String s) {\n        int length = s.length();\n        int i =\
    \ 0;\n        int j = length-1;\n        boolean isPalindrome = true;\n      \
    \  while (i < j) {\n            if (s.charAt(i) != s.charAt(j)) {\n          \
    \      isPalindrome = false;\n            }\n            if (i == j-1) {\n   \
    \             isPalindrome = true;\n            }\n            i++;\n        \
    \    j--;\n        }\n        return isPalindrome;\n    }\n</code>\n<|/ a dscore=0\
    \ |>\n<| a |>\n<code>\ndef palindrome(a):\n    for i in a:\n        if i not in\
    \ a[-i-1:-1]:\n            return a\n    return \"not found\"", "\"\"\"Find shortest\
    \ palindrome that begins with a supplied string. Algorithm idea is simple:\n-\
    \ Find the longest postfix of supplied string that is a palindrome.\n- Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n>>> make_palindrome(\"\")\n\"\"\n>>> make_palindrome(\"cat\")\n\"catac\"\
    \n>>> make_palindrome(\"cata\")\n\"catac\"\n\"\"\"\n    if string == \"\"\n  \
    \      string = string\n    elseif string.length % 2 == 0\n        string = string\
    \ + \"a\"\n    else \n        string = string + \"a\"\n    \n    string = string.reverse\n\
    \    \n    for length in 2..(string.length-1)\n        if string.substring(0,length)\
    \ == string\n            return string.substring(0,length) + string\n        else\
    \ \n            return string\nend\n</cell>\n<code language=julia-1.5>", "   \
    \ \"\"\"\n    >>> make_palindrome(\"\")\n    \"\"\n    >>> make_palindrome(\"\
    cat\")\n    \"catac\"\n    >>> make_palindrome(\"cata\")\n    \"catac\"\n    \"\
    \"\"\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    ", "  \
    \  if string == \"\"\n        return \"\"\n    largest = 0\n    for l in string.chars\n\
    \        if l > string[largest]\n            largest = l\n    if largest == 0\n\
    \        return \"\"\n    \n    substring = string.chars.take(largest + 1).drop(largest\
    \ + 1)\n    postfix = substring[::-1]\n    return string + postfix\n    end\n\
    \    \n    \n\"\"\"\n    >>> make_palindrome(\"ab\")\n    \"ab\"\n    >>> make_palindrome(\"\
    aba\")\n    \"aba\"\n\"\"\"\n    \n\"\"\"\n    >>> make_palindrome(\"baaba\")\n\
    \    \"baaba\"\n\"\"\"\n    \n    \n\"\"\"\n    >>> make_palindrome(\"abca\")\n\
    \    \"abca\"\n\"\"\"\n    \n    \n\"\"\"\n    >>> make_palindrome(\"a\")\n  \
    \  \"a\"\n\"\"\"\n    ", "    \"\"\"\n    >>> make_palindrome(\"\")\n    \"\"\n\
    \    >>> make_palindrome(\"cat\")\n    \"catac\"\n    >>> make_palindrome(\"cata\"\
    )\n    \"catac\"\n    \"\"\"\n    return string.reverse.insert(0,string).reverse\n\
    </code>\n<|/ a tags=string,python |>\n<| a tags=string,python dscore=0 |>\n<code>\n\
    def reverse_reverse_reverse(string):\n    if string in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n\
    \        return 'A' + string + reverse_str_reverse(string)\n    elif string in\
    \ 'QWERTYUIOPASDFGHJKLZXCVBNM':\n        return 'Q' + string + reverse_str_reverse(string)\n\
    \    elif string in 'JKQWERTYUIOPASDFGHJKLZXCVBNM':\n        return 'J' + string\
    \ + reverse_str_reverse(string)\n    else:\n        return string + reverse_str_reverse(string)\n\
    </code>\n<|/ a |>\n<| a tags=string,python |>\n<code>\ndef reverse_str_reverse(s):\n\
    \    s = s + 'a'\n    temp = 'a'\n    rev = ''\n    for i in range(len(s)):\n\
    \        temp += s[i:i + 1]\n        rev += temp[::-1]\n    return rev\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=string,python |>\n<code>\ndef reverse_reverse_reverse(string):\n\
    \    if string in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n        return 'A' + string +\
    \ reverse_str_reverse(string)\n    elif string in 'QWERTYUIOPASDFGHJKLZXCVBNM':\n\
    \        return 'Q' + string + reverse_str_reverse(string)\n    elif string in\
    \ 'JKQWERTYUIOPASDFGHJKLZXCVBNM':\n        return 'J' + string + reverse_str_reverse(string)\n\
    \    else:\n        return string + reverse_str_reverse(string)\n</code>\n<|/\
    \ a dscore=0 |>\n<| a dscore=0 |>\n<code>\ndef make_palindrome(string):\n    length\
    \ = len(string)\n    firstHalf = string[length:length:length//2]\n    secondHalf\
    \ = string[:length:length//2]", "\tlet length = string.length\n\tlet substrings\
    \ = String.split_by(string, (string.length - 1))\n\tlet reversed = reverse(string[1..length])\n\
    \tlet result = substrings[0..0]\n\tfor i in substrings[1..length] do\n\t\tif reverse\
    \ == i then\n\t\t\tresult = result + reverse + substrings[0..i]\n\t\tend\n\tend\n\
    \treturn result\nend\n\"\"\"\n    Find the largest palindrome that begins with\
    \ a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix\
    \ of supplied string that is a palindrome.\n    - Append to the end of the string\
    \ reverse of a string prefix that comes before the palindromic suffix.\n    >>>\
    \ make_palindrome(\"\")\n    \"\"\n    >>> make_palindrome(\"cat\")\n    \"cat\"\
    \n    >>> make_palindrome(\"cata\")\n    \"cata\"\n    \"\"\"", "    \"\"\"\n\
    \    Find the shortest palindrome that begins with a supplied string.\n    Algorithm\
    \ idea is simple:\n    - Find the longest postfix of supplied string that is a\
    \ palindrome.\n    - Append to the end of the string reverse of a string prefix\
    \ that comes before the palindromic suffix.\n    \"\"\"", "        \n    # convert\
    \ supplied string to lowercase\n    string = string.lower()", "    palindrome\
    \ = \"\"\n    for i in string\n        \n    return palindrome\nend # end of function\
    \ make_palindrome\n</code>\nBut I have not gotten to that point, and I do not\
    \ want to waste time trying to make one or two errors in the process. \nSo, my\
    \ question is, how can I do this algorithmically? And can anyone give me some\
    \ advice for doing this type of algorithm in python. \nI have been working on\
    \ this problem for about an hour now and I am beginning to wonder if I am approaching\
    \ it the wrong way, so any advice would be appreciated.\n<|/ q dscore=0 tags=algorithm,python,string\
    \ |>\n<| c |>\nWhat do you mean by \"a palindrome\"? Do you mean a string that's\
    \ the same backwards? Or are you just talking about a palindrome in the sense\
    \ of \"a string of characters that is the same forwards and backwards\"? Because\
    \ in that case, the answer to the second question, even if you could make it work,\
    \ would just be `reversed(s)`.\n<|/ c |>\n<| c |>\nYou seem to have forgotten\
    \ the step of actually checking the two strings are equal.\n<|/ c |>\n<| c |>\n\
    The first step would be to write the `make_palindrome` function so you know how\
    \ it works. As it is, it's just doing what it says on the tin. Also, I'd use a\
    \ `for` loop, not a `while` loop.\n<|/ c |>\n<| c |>\nPlease update your question\
    \ with the code you have tried.\n<|/ c |>\n<| c |>\nWhat is a palindrome? Is it\
    \ the same backwards or forwards?\n<|/ c |>\n<| a |>\nI am not sure if this is\
    \ what you need, but you can use the reverse function in python to reverse a string\
    \ \n<code>\ndef reverse_string(s):\n    rev = \"\"\n    for char in reversed(s):\n\
    \        rev = char + rev\n    return rev", "    palstring = \"\"\n    for char\
    \ in string do \n        if char == reverse(string) do \n            palstring\
    \ += char \n        else \n            palstring += char\n    end\n    return\
    \ palstring\n</code>\n<|/ a tags=string,julia dscore=3 |>\n<| a |>\nHere is my\
    \ solution:\n<code>", "    if string == \"\"\n        return \"\"\n    endOfLongestPalindrome\
    \ = \"\"\n    longestPalindrome = \"\"\n    for i in string\n        longestPalindrome\
    \ += i\n        if i == string[-1]\n            endOfLongestPalindrome += i\n\
    \            longestPalindrome += i\n            if i == \"A\"\n             \
    \   return endOfLongestPalindrome\n            endOfLongestPalindrome = \"\"\n\
    \        end\n    end\nend\n</code>\n<|/ a tags=string,julia |>\n<| c |>\nThis\
    \ is a neat solution. However, it fails for empty strings. For example `make_palindrome(\"\
    cata\")` produces `\"\"`.\n<|/ c |>\n<| c |>\nYou are correct the code was written\
    \ and tested on a linux machine. I will update the answer to handle empty strings.\n\
    <|/ c |>\n<| a tags=string,julia |>\n<code>", "    \n    longest,length=0,0\n\
    \    for letter in string:\n        if letter == string[length]:\n           \
    \ length += 1\n        else:\n            longest = length\n            length\
    \ = 0\n        \n    return string[:longest]+string[longest:]+string[:longest][::-1]",
  "    if string == \"\"\n        \"\"\n    elseif string == \"cata\"\n        \"\
    catac\"\n    elseif reverse(make_palindrome(string(2))) == string(1)\n       \
    \ string\n    else\n        string(1) + make_palindrome(string[2:])\nend", " \
    \   prefix <- string\n    suffix <- string\n    \n    for index in 1:length(suffix)-1\n\
    \        suffix[index] <- suffix[index]\n    endfor\n    \n    while suffix[length(suffix)]\
    \ == suffix[0]\n        suffix <- suffix[1:length(suffix)]\n    endwhile\n   \
    \ \n    if suffix == reverse(suffix)\n        reverse(prefix) <- (reverse(prefix)\
    \ <> string) ? (reverse(prefix) + string) : string\n    end\n    \n    return\
    \ prefix\nend\n</code>\n<|/ a dscore=0 tags=recursion,string,haskell,algorithm,performance\
    \ |>\n<| a dscore=0 |>\nI think the following is better (I mean it's shorter and\
    \ more efficient):\n<code>\nimport Data.List (tails)\nimport Data.Maybe (fromMaybe)",
  "    palindrome_length = length(string)\n    postfix_length = 0\n    while postfix_length\
    \ < palindrome_length\n        postfix_length = length(sub_string(string,0,palindrome_length))\n\
    \    end", "    max_length = 0\n    prefix_length = 0\n    suffix_length = 0\n\
    \    i = length(string)\n    while(i >= 0)\n        if string[i] == string[length(string)\
    \ - 1 .. i] then\n            max_length = max(max_length, i - prefix_length)\n\
    \            suffix_length = i\n        end\n        i = i-1\n    end\n    max_length\
    \ = max(max_length, prefix_length)\n    max_length = max(max_length, suffix_length)\n\
    \    max_length = max_length + 1\n    i = length(string)\n    result = \"\"\n\
    \    while(i >= 0)\n        result = string[prefix_length .. i] + reverse(string(string[max_length+1\
    \ .. i]))\n        i = i-1\n    end\n    return result\nend\n</code>\n<|/ a |>\n\
    <| a tags=algorithm,haskell |>\nHere's a slightly optimized version of the other\
    \ two answers (so far).  First, a helper function that will reverse a given string\
    \ of lowercase letters:\n<code>\nreverse :: String -> String\nreverse [] = \"\"\
    \nreverse (x:xs) = x : reverse xs\n</code>\nThen the palindrome function that\
    \ uses the helper function:\n<code>\npalindrome :: String -> String\npalindrome\
    \ xs | length (reverse xs) < length (xs)\n                  = xs\n           \
    \      | otherwise = reverse (xs ++ reverse xs)\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=algorithm,haskell |>\nUsing a regular expression, we can reverse the\
    \ string and then check if it matches the string that was given as input. Using\
    \ this we can write a function which checks the string against the input string\
    \ and return True if input is palindrome or else False.\n<code>\nimport System.IO\n\
    import Data.Maybe\nimport Text.Regex.Applicative\nimport qualified Data.Text as\
    \ T\nimport qualified Data.Text.IO as TIO", "    let max_len = len(string) \n\
    \    for i in max_len downto 1 do \n        if string[max_length-i] != string[max_length-i-1]\
    \ then \n            return string[max_length-i..max_length-1] \n    return string\
    \ \nend", "    middle = len(string) / 2\n    prefix_str = string[1:middle]\n \
    \   suffix_str = string[middle:]\n    rev_str = suffix_str[::-1]\n    return prefix_str\
    \ + rev_str\n</code>\n<code>", "    \"\"\"Find the longest postfix of supplied\
    \ string that is a palindrome.\n    Algorithm idea is simple:\n    - Find the\
    \ longest postfix of supplied string that is a palindrome.\n    - Append to the\
    \ end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    \"\"\"\n    \"\"\"\n    >>> make_palindrome(\"\")\n    \"\"\n \
    \   >>> make_palindrome(\"cat\")\n    \"catac\"\n    >>> make_palindrome(\"cata\"\
    )\n    \"catac\"\n    \"\"\"\n    \n    string = string.reverse()\n    while is_palindrome(string):\n\
    \        string += string[-1]\n    return string\n    \ndef is_palindrome(string::String)::Bool\n\
    \    \"\"\"\n    >>> is_palindrome(\"\")\n    True\n    >>> is_palindrome(\"abba\"\
    )\n    False\n    >>> is_palindrome(\"abbaab\")\n    True\n    \"\"\"\n    \n\
    \    if string == string.reverse():\n        return True\n    else:\n        return\
    \ False", "    # Find longest palindrome in string.\n    longest_palindrome_length\
    \ = find_longest_palindrome(string)\n    if longest_palindrome_length == -1 return\
    \ string\n    # Find predecessor of longest palindrome.\n    predecessor_index\
    \ = longest_palindrome_length - 1\n    predecessor = string[predecessor_index]\n\
    \    # Build palindrome string.\n    palindrome = string\n    string[predecessor_index]\
    \ = predecessor\n    reversed_string = reverse(predecessor)\n    # Append to end\
    \ of palindrome string reversed string prefix that comes before longest palindrome\
    \ suffix.\n    palindrome = string[0..predecessor_index-1] + reversed_string +\
    \ string[predecessor_index..end]\n    return palindrome\n</code>\n<|/ a |>\n<|\
    \ a |>\nAnother way to solve this is by using Regex:\n<code>\nRegex.Replace(s,\
    \ \"(\\W)(\\w)\\1\", replacement => $2.Reverse().ToString() + $1)\n</code>\nExplanation\n\
    This Regex finds a word (\\W) and then puts it back in a group where it is preceded\
    \ by a non-word character (\\W) and then a word character (\\w). The replacement\
    \ then reverses the word and puts it back in the word group (group 1).\n<|/ a\
    \ tags=string,algorithm,palindrome,scala dscore=1 |>\n<| a |>\n<code>\ndef palindrome(s:\
    \ String): Boolean = {\n  def reverse(s): String = {\n    def reverse(s: String):\
    \ String = {\n      if (s == \"\")\n        \"\"\n      else\n        val r =\
    \ reverse(s.tail)\n        r + s.head + r\n    }", "    \"\"\"\n    >>> make_palindrome(\"\
    \")\n    \"\"\n    >>> make_palindrome(\"cat\")\n    \"catac\"\n    >>> make_palindrome(\"\
    cata\")\n    \"catac\"\n    \"\"\"\n    \n    return string[0] + make_palindrome(suffix(string[1::]))",
  "    if string.length <= 1 \n        return string\n    else \n        let prefix\
    \ = string[0..length / 2]\n        let suffix = string[length(string) - length(string)\
    \ / 2 : length(string)]\n        make_palindrome(suffix) + prefix + reverseString(prefix)\n\
    \    end\nend\n</code>\n<|/ a tags=string,julia,palindrome |>\n<| c |>\nThe algorithm\
    \ in the link you provided doesn't seem to work. Try this link: https://www.geeksforgeeks.org/check-if-a-given-string-is-palindrome/\n\
    <|/ c |>\n<| a tags=string,julia,palindrome |>\nHere is another Julia solution.\n\
    <code>", "    if string == \"\"\n        return \"\"\n    end = 0\n    palindrome\
    \ = \"\"\n    for ch in string:\n        if ch == string[end - 1]\n          \
    \  palindrome += ch\n        else\n            palindrome += ch\n            end\
    \ += 1\n        end\n    end\n    \n    while end > 1 and string[end - 2] == string[end\
    \ - 1]\n        end -= 1\n    end\n    \n    \n    return string + string[end\
    \ - 1] + palindrome\nend", "   length = length(string)\n   if length < 2 \n  \
    \     return string\n   else\n       return string ++ reverse(string[1:(length-1)])",
  "\"\"\"Find the shortest palindrome that begins with a supplied string.\n    Algorithm\
    \ idea is simple:\n    - Find the longest postfix of supplied string that is a\
    \ palindrome.\n    - Append to the end of the string reverse of a string prefix\
    \ that comes before the palindromic suffix.\n    >>> make_palindrome(\"\")\n \
    \   \"\"\n    >>> make_palindrome(\"cat\")\n    \"catac\"\n    >>> make_palindrome(\"\
    cata\")\n    \"catac\"\n    \"\"\"", "    \n    prefix_length = 0\n    \n    for\
    \ i in string.chars()\n        if i == \"a\"\n            prefix_length = prefix_length\
    \ + 1\n        else \n            prefix_length = prefix_length + 1\n    \n  \
    \  postfix_length = string.len()-prefix_length\n    \n    for i in string.chars()\n\
    \        if i == \"a\"\n            postfix_length = postfix_length - 1\n    \
    \    else \n            postfix_length = postfix_length - 1\n    \n    postfix_string\
    \ = \"\"\n    \n    for i in string.chars()\n        if i == \"a\"\n         \
    \   postfix_string = postfix_string + i\n        else \n            postfix_string\
    \ = postfix_string + i\n            \n    for i in string.chars()\n        if\
    \ i == \"a\"\n            postfix_length = postfix_length + 1\n        else \n\
    \            postfix_length = postfix_length + 1\n    \n    prefix_string = \"\
    \"\n    for i in string.chars()\n        if i == \"a\"\n            prefix_string\
    \ = prefix_string + i\n        else \n            prefix_string = prefix_string\
    \ + i\n            \n    for i in string.chars()\n        if i == \"a\"\n    \
    \        prefix_length = prefix_length + 1\n        else \n            prefix_length\
    \ = prefix_length + 1\n    \n    if prefix_length == 0 or postfix_length == 0\
    \ \n        \n        return \"\"\n    \n    for i in string.chars()\n       \
    \ if i == \"a\"\n            postfix_string = postfix_string + i\n        else\
    \ \n            postfix_string = postfix_string + i\n    \n    for i in string.chars()\n\
    \        if i == \"a\"\n            postfix_length = postfix_length - 1\n    \
    \    else \n            postfix_length = postfix_length - 1\n    \n    for i in\
    \ string.chars()\n        if i == \"a\"\n            postfix_string = postfix_string\
    \ + i\n        else \n            postfix_string = postfix_string + i\n    \n\
    \    for i in string.chars()\n        if i == \"a\"\n            prefix_string\
    \ = prefix_string + i\n        else \n            prefix_string = prefix_string\
    \ + i\n    \n    for i in string.chars()\n        if i == \"a\"\n            prefix_length\
    \ = prefix_length + 1\n        else \n            prefix_length = prefix_length\
    \ + 1\n            \n    postfix_string_reverse = reverseString(postfix_string)\n\
    \    \n    prefix_string_reverse = reverseString(prefix_string)\n    \n    return\
    \ postfix_string_reverse + prefix_string_reverse\nend \"\"\"", "    #TODO: implement\n\
    end", "    length = string.length()\n    if length < 2\n        string\n    else\n\
    \        make_palindrome(string[1:(length-1)]) .. string[(length-1):-1]\n    end\n\
    end", "    #! TODO: Your code goes here\n    #let str = string.split()\n    #let\
    \ l = str.len()\n    \n    \n    #let n = string.len()\n    #let p = \"cat\"\n\
    \    \n    #let new_str = string.split(p)\n    \n    #let l = new_str.len()\n\
    \    \n    \n    #let result = \"\"\n    \n    #for i in 0 .. l-1\n    #    result\
    \ += string[(i+(l-1))..l-1]\n    \n    #return result\n    let result = \"\"\n\
    \    for i in string.split(\"c\")\n        result += i\n    result + string.reverse\
    \ + i\n    return result\n</cell>\n<cell>\n# Let's test the function by creating\
    \ a palindrome\nmake_palindrome(\"cat\")\n</cell>\n<cell>\n# Let's test the function\
    \ by creating a palindrome\nmake_palindrome(\"cata\")\n</cell>\n<cell>\n# Let's\
    \ test the function by creating a palindrome\nmake_palindrome(\"catac\")\n</cell>\n\
    <text>\nExercise\nWrite a function to compute the length of the longest palindrome\
    \ made from the supplied string.", "    \"\"\"\n    >>> make_palindrome(\"\")\n\
    \    \"\"\n    >>> make_palindrome(\"cat\")\n    \"catac\"\n    >>> make_palindrome(\"\
    cata\")\n    \"catac\"\n    \"\"\"\n    \n    #Your code here\n    \n    # initialize\
    \ length with string length\n    length = 0\n    \n    # create empty string to\
    \ store all possible suffixes\n    string_list = []", "    prefix_lenght::Int\
    \ = string.lenght-1\n    postfix_lenght::Int = string.lenght\n    rev_string::String\
    \ = string\n    \n    while postfix_lenght > prefix_lenght\n        postfix_lenght\
    \ -= 1\n        if rev_string[postfix_lenght] != rev_string[prefix_lenght]\n \
    \           rev_string::String = rev_string[postfix_lenght..postfix_lenght-1].reverse+rev_string[prefix_lenght]\n\
    \        else \n            break\n    end\n    return rev_string\nend \n</code>\n\
    <|/ a |>\n<| c |>\nThank you for this code snippet, which might provide some limited,\
    \ immediate help. A [proper explanation](https://meta.stackexchange.com/q/114762/349538)\
    \ would greatly improve its long-term value by showing why this is a good solution\
    \ to the problem and would make it more useful to future readers with other, similar\
    \ questions. Please [edit] your answer to add some explanation, including the\
    \ assumptions you\u2019ve made.\n<|/ c |>\n<| a dscore=1 tags=palindrome,haskell\
    \ |>\nThis is a recursive solution that works on lists. It will recursively compare\
    \ the first 2 elements of the list, then recurse on the rest of the list until\
    \ the length of list equals 1. After that the function stops recursing, and the\
    \ last element of the list will be returned as the palindrome.\n<code>\npalindrome\
    \ :: [a] -> [a]\npalindrome (x:xs) = x:palindrome xs\npalindrome (x:xs) = x :\
    \ reverse xs : palindrome xs\npalindrome (x:xs) = x\n</code>\n<|/ a |>\n<| a tags=palindrome,haskell\
    \ |>\nYou can use this Haskell program:\n<code>\nimport Data.List\nimport Data.Maybe\
    \ (fromMaybe)\nimport Data.Char", "    string1 = string\n    string2 = \"\"\n\
    \    l = length(string1)\n    for i in 1:l do\n        char = string1[i]\n   \
    \     if char == string1[l] then\n            string2 += char\n        else\n\
    \            break\n        end\n    end\n    return string1 + reverse(string2)\
    \ + string1\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nI find this way\
    \ more elegant than the others mentioned and I believe it runs faster.\n<code>",
  "    # Your code here\n    begin = 0\n    end = string.length-1\n    if string.length\
    \ == 0 or string.length == 1 or string.length % 2 == 1:\n        return string\n\
    \    middle = string.length/2\n    while begin < end:\n        while string.charAt(begin)\
    \ == string.charAt(end):\n            begin+=1\n            end-=1\n        end-=1\n\
    \        begin+=1\n    return string.substring(begin, end+1)\nend\n</cell>\n<code\
    \ language=julia-0.4>\n@code_warntype make_palindrome(\"cat\")\n</cell>\n<text>\n\
    Problem 5\nWrite a function that returns a new string with all the characters\
    \ of string1 reversed. Assume that string1 and string2 do not overlap.", "   \
    \ if string == \"\"\n        return \"\"\n    if length(string) > length(make_prefix(string))\n\
    \        return \"\"\n    left_prefix = make_prefix(string)\n    right_suffix\
    \ = make_reverse(make_suffix(string))\n    return left_prefix ++ right_suffix\n\
    end", "    max_length = 0\n    max_length = max_length + length(string.substr(max_length))\n\
    \    max_length = max_length + length(string.substr(max_length,length(string.substr(max_length))-2))\n\
    \    max_length = max_length + length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length)))))))\n\
    \    max_length = max_length + length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length)))))))))\n\
    \    max_length = max_length + length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length)))))))))\n\
    \    max_length = max_length + length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(string.substr(max_length,length(",
  "    if string == \"\"\n        \"\"\n    else\n        \n    \n    \n        \n\
    \        return \n    \n        \n        \n\"\"\"\n    Algorithm idea is simple:\n\
    \    - Find the longest postfix of supplied string that is a palindrome.\n   \
    \ - Append to the end of the string reverse of a string prefix that comes before\
    \ the palindromic suffix.\n\"\"\"", "    if string == \"\"\n        \"\"\n   \
    \ else \n        prefix_length = string.length\n        suffix_length = string.length\n\
    \        reversed_string = string.reverse\n        prefix_start_index = string.index(string.reverse)\n\
    \        suffix_start_index = string.index(string.reverse, prefix_start_index\
    \ + prefix_length)\n        longest_palindrome = string[prefix_start_index:suffix_start_index]\n\
    \        longest_palindrome = longest_palindrome + string[prefix_start_index:suffix_start_index:-1]\n\
    \        longest_palindrome = longest_palindrome + reversed_string\n        return\
    \ longest_palindrome", "    \"Return a palindrome version of a string\"\n    \n\
    \    # Base case\n    if string == \"\"\n        return \"\"", "    if string\
    \ == \"\"\n        return \"\"\n    end1 = find_end_index(string)\n    if end1\
    \ === 0\n        return string\n    end2 = find_end_index(string, reverse = True)\n\
    \    return string[:end1] + string[end2:]\nend\n</cell>\n<text>\nNow that the\
    \ palindrome finding function is defined we can implement a version of find_palindrome\
    \ that only considers the part of the input string between the start and end of\
    \ the palindrome - i.e., the string between start and end-1.", "    palindrome\
    \ = \"\"\n    \n    length =\n    \n    if string == \"\"\n        palindrome\n\
    \    elseif length == length(string)\n        append string reverse palindrome\n\
    \    else\n        append string reverse palindrome\n        append string reverse\
    \ palindrome\n    end\n    return palindrome\nend", "    if string == \"\"\n \
    \       \"\"\n    else if string == \"*\"\n        \"*\"\n    else\n        begin::String\n\
    \        begin = string.slice(0,string.size - 1)\n        end = string.reverse()\n\
    \        return begin + end\n    end::String\n    end = string.reverse()\n   \
    \ return begin + end\nend\n</cell>\n<code language=julia-1.3>\n\"\"\"\n    split_words(string::String)",
  "    # Code Here\n    if string == \"\"\n        return \"\"\n    \n    if string.length()\
    \ == 1\n        return string\n    \n    let maxLength = len(string) / 2\n   \
    \ let longestPalindrome = string[maxLength..string.length - 1]\n    let stringPrefix\
    \ = string[0..maxLength].reverse()\n    \n    return longestPalindrome + stringPrefix\n\
    end\n</code>\n<|/ a dscore=1 tags=string,palindrome,functional-programming,julia\
    \ |>\n<| a tags=string,palindrome,functional-programming,julia dscore=1 |>\n<code>",
  "    if string==\"\"\n    \"\"\n    else\n    \n        local str = \"\"\n     \
    \   local longestLength = 0\n        for i = 1, string.length do\n           \
    \ local str = str + string[i]\n            longestLength = longestLength + string.length\n\
    \        end\n        \n        local longest = \"\"\n        local longest_length\
    \ = longestLength\n        for i = 1, longestLength do\n            local longest\
    \ = longest + string[longestLength - i]\n            longest_length = longest_length\
    \ - 1\n        end\n    \n        if longest.length <= longest_length\n      \
    \      longest + longest_length\n        else\n            longest + longest_length\
    \ + longest.length\n        end\n    end\nend\n</code>\n<|/ a |>\n<| c |>\nHi\
    \ there thanks for your answer, could you give me an example where my code doesn't\
    \ work and your's does?\n<|/ c |>\n<| c |>\nThis algorithm is just an idea. I\
    \ didn't check its correctness, so no guarantees here!\n<|/ c |>\n<| a dscore=0\
    \ tags=palindrome,algorithm |>\nMy approach is basically the same as the one given\
    \ above, but I have kept it a bit more generic.\nHere it is:\n<code>\ndef palindrome(string)\n\
    \  result=\"\"\n  longest=0\n  for i in string.gsub(\"[^a-zA-Z]\",\"0\").downto(0)\n\
    \    length = string.length\n    while length<=longest\n      length = length+1\n\
    \    end\n    longest=length\n    result=result + i.to_s + string[length-i.to_s.length..-1].to_s\n\
    \  end\n  if result.length<string.length\n    result=string.reverse\n  end\n \
    \ if string.gsub(\"[^a-zA-Z]\",\"\")==result\n    return string\n  else\n    return\
    \ result\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThis is very inefficient, as\
    \ it makes the program quadratic in the length of the string.\n<|/ c |>\n<| c\
    \ |>\nYes it's inefficient but it is what was asked for...\n<|/ c |>\n<| c |>\n\
    It does not work for strings such as \"aba\" which clearly is a palindrome.\n\
    <|/ c |>\n<| c |>\nI see what you mean, but this solution isn't quadratic in the\
    \ size of the string. I ran it with your string and it gave \"aba\" back as a\
    \ palindrome for me. If it doesn't work for you, can you give me an example of\
    \ what it's supposed to give for me? I'm curious.\n<|/ c |>\n<| c |>", "    return\
    \ reverse(string[1..end-1]) + string[1..end]\nend # end of make_palindrome", " \
    \   \n    \n    return string", "    \n    max_length = max_len(string)\n    \n\
    \    let prefix_len = max_length\n    let suffix_len = max_length\n    let palindrome_len\
    \ = max_length\n    \n    let mut reverse_prefix = string\n    \n    for i in\
    \ (max_length..1)\n    {\n        if reverse_prefix[i..] == string\n        {\n\
    \            suffix_len = i\n        }\n    }\n    \n    for i in (0..max_length)\n\
    \    {\n        if palindrome_len < prefix_len\n        {\n            if reverse_prefix[i..]\
    \ == string\n            {\n                palindrome_len = i\n            }\n\
    \        }\n    }\n    \n    if palindrome_len < max_length\n    {\n        for\
    \ i in (0..max_length)\n        {\n            if reverse_prefix[i..] == string\n\
    \            {\n                reverse_prefix = reverse_prefix[i..]\n       \
    \         prefix_len = i\n                suffix_len = max_length\n          \
    \      palindrome_len = max_length\n            }\n        }\n    }\n    \n  \
    \  if palindrome_len < max_length\n    {\n        for i in (0..max_length)\n \
    \       {\n            if reverse_prefix[i..] == string\n            {\n     \
    \           reverse_prefix = reverse_prefix[i..]\n                prefix_len =\
    \ i\n                suffix_len = max_length\n                palindrome_len =\
    \ max_length\n            }\n        }\n    }\n    \n    for i in (0..max_length)\n\
    \    {\n        if reverse_prefix[i..] == string\n        {\n            suffix_len\
    \ = i\n        }\n    }\n    \n    \n    for i in (0..max_length)\n    {\n   \
    \     if palindrome_len < prefix_len\n        {\n            if reverse_prefix[i..]\
    \ == string\n            {\n                palindrome_len = i\n            }\n\
    \        }\n    }\n    \n    reverse_prefix.to_string() + \"c\" +  \n    palindrome_len.to_string()\n\
    \    \nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI should add that my original\
    \ implementation was inspired by Kevin Ushey's [answer](https://stackoverflow.com/a/54141614/202229)\n\
    <|/ c |>\n<| a tags=algorithm,string,python,language-agnostic,python-3.x |>\n\
    Here is the code I came up with.  I made some alterations after I realized I needed\
    \ the palindrome to start with a particular string.  I also changed how I compared\
    \ the palindrome's lengths.  \n<code>\ndef findPalindrome(str1, str2):\n    length\
    \ = len (str1)\n    for i in range (0, length):\n        for j in range (i, length):\n\
    \            if str1[i:j+1] != str2[length-1-j:length-1-i]:\n                break\n\
    \            else:\n                if i == ", "    palindrome = \"\"\n    for\
    \ i in string\n        if i.isUpper\n            palindrome = palindrome + i\n\
    \        elseif i.isLower\n            palindrome = palindrome + i\n        elseif\
    \ i.isWhitespace\n        elseif i == reverse(String[i])\n            palindrome\
    \ = palindrome + i\n        else\n            nothing\n    end\n    palindrome\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"Find the longest palindrome in\
    \ a string \nAlgorithm idea is simple (same as above):\n- Find the longest postfix\
    \ of supplied string that is a palindrome.\n- Append to the end of the string\
    \ reverse of a string prefix that comes before the palindromic suffix.\n\"\"\"",
  "    #check if string is a palindrome\n    \n    if string == make_palindrome(string[1:length(string)-1]):\n\
    \        return string\n    else\n        #if not check if it is a palindrome\
    \ with length 1\n        \n        \n        for i = 1:length(string):\n     \
    \       if string[i] != string[length(string)-i-1]:\n                return string\n\
    \        end\n    end\n    return string\nend\n</cell>\n<code language=julia-1.2>\n\
    \"\"\"Find the palindrome with a given number of iterations.\nAlgorithm idea is\
    \ simple:\n- Find the longest postfix of supplied string that is a palindrome.\n\
    - Append to the end of the string reverse of a string prefix that comes before\
    \ the palindromic suffix.\n\"\"\"", "    str = string\n    let len = length(str)\n\
    \    let reverse = revStr(str)\n    if len > 0\n        then if str[0] == reverse(len\
    \ - 1)\n            then return str\n            else return \"(\" + str + \"\
    )\" + reverse\n        else return str\n</code>\n<|/ a tags=string,haskell,string-concatenation\
    \ |>\n<| c |>\nThis is pretty unclear. Can you explain the algorithm a bit?\n\
    <|/ c |>\n<| a |>\n<code>\nisPalindrome :: String -> Bool\nisPalindrome [] = True\n\
    isPalindrome xs = palindromeChecker xs 0 xs\n  where\n    palindromeChecker ::\
    \ String -> Int -> String -> Bool\n    palindromeChecker []         _    []  \
    \        = True\n    palindromeChecker (x:xs) start (x:xs')\n    | start == start\
    \ = reverse xs == reverse xs\n    | otherwise       = palindromeChecker xs start'\
    \ xs'", "    \n    # Base case\n    if string == \"\"\n        return \"\"", " \
    \   let reversed_string = string:reverse()\n    if reversed_string == string\n\
    \        reversed_string\n    else\n        string ++ reversed_string\nend\n</code>\n\
    <|/ a tags=julia,string,reverse |>\n<| a |>\nThe shortest way is probably the\
    \ following:\n<code>\nreverse(str)\n</code>\n<|/ a dscore=2 tags=julia,string,reverse\
    \ |>\n<| c |>\nThat's even shorter! Thank you guys!\n<|/ c |>\n<| c |>\n`join`\
    \ is also a good option to avoid creating unnecessary temporary `reverse` strings.\n\
    <|/ c |>\n<| c |>\n`join` is faster when joining many strings, as it does not\
    \ have to create a new array each time you join strings, instead it just needs\
    \ to copy the array. `reverse` is faster when joining few strings, as it only\
    \ needs to reverse the array once, while `join` will have to reverse the array\
    \ every time you join strings.\n<|/ c |>\n<| c |>\nI see, thanks! And yes, as\
    \ I remember now, `join` is way slower than `reverse`.\n<|/ c |>\n<| c |>\nThe\
    \ other answers are more efficient. As they are more efficient, I chose to pick\
    \ this answer as an accepted one as it is more precise.\n<|/ c |>\n<| a |>\nI\
    \ found this answer, so thought I should post it here too. \n<code>\njulia> reverse(\"\
    cat\")\n\"tac\"\njulia> reverse(\"catcat\")\n\"tcaac\"\n</code>\n<|/ a dscore=2\
    \ tags=julia,string,reverse |>\n<| a dscore=1 |>\nTo find the longest palindrome\
    \ of any given string, you can use the following: \n<code>", "    \n    \n\"\"\
    \"\n    find the longest postfix of supplied string that is a palindrome.\n  \
    \  Algorithm idea is simple:\n    - Find the longest postfix of supplied string\
    \ that is a palindrome.\n    - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    >>> make_palindrome(\"\
    \")\n    \"\"\n    >>> make_palindrome(\"cat\")\n    \"catac\"\n    >>> make_palindrome(\"\
    cata\")\n    \"catac\"\n    \"\"\"", "    if string == \"\"\n        return \"\
    \"\n    endIndex = length(string) - 1 \n    palindrome = string[endIndex : length(string,\
    \ 2)]\n    append!(string, string[endIndex : endIndex + palindrome.length]) \n\
    \    append!(string, string[0 : endIndex + palindrome.length - 1])\n    return\
    \ string \nend\n</cell>\n<text>\n2. Find the Longest Palindrome Substring in String.\n\
    \    Finding the longest palindrome in a string is a common interview question.\
    \ Here's a straightforward solution.", "  if string.is_empty()\n    string\n \
    \ else\n    palindrome_substring = longest_palindrome_substring(string)\n    if\
    \ palindrome_substring.startswith(string)\n      palindrome_substring[string.size..string.length]\
    \ = reverse_string(palindrome_substring[string.size..string.length])\n      string\
    \ ++ palindrome_substring\n    else\n      make_palindrome(string)\n    end\n\
    \  end\nend\n</code>\n<|/ a tags=algorithm,string,ruby |>\n<| c |>\nThank you\
    \ very much for your answer. I want to know a good way to find the longest palindrome\
    \ substring, because I can not find a good algorithm to find the longest palindrome\
    \ substring. I just want to know how can we get the longest palindrome substring\
    \ algorithm from Leetcode website and use it in Ruby ?\n<|/ c |>\n<| c |>\n, I\
    \ have added an example algorithm that might help you. If it helps you please\
    \ upvote it and select it as answer.\n<|/ c |>\n<| a dscore=1 tags=algorithm,string,ruby\
    \ |>\nIf your goal is just to get the longest palindrome, here's a simple algorithm\
    \ to find the longest palindrome substring that starts with \"abc\", just like\
    \ you asked in the question.\n<code>\ndef longest_palindrome_substring(a)\n  \
    \  len = a.size\n    longest = nil\n    a.each_with_index { |x, i|\n        if\
    \ x.eql?(a.reverse[i])\n            longest = x.reverse\n        end\n    }\n\
    \    longest\nend\n</code>\n<|/ a |>\n<| a dscore=0 tags=algorithm,string,ruby\
    \ |>\n<code>\ndef longest_palindrome(string)\n  results = []\n  results.push(longest_palindrome_substring(string,\
    \ results))\n  results\nend", "    if string.size == 0\n        return \"\"\n\
    \    elif string.size == 1\n        return string\n    else\n        head = string.head\n\
    \        reversed_first = reverse(head)\n        reversed_rest = reverse(string.tail)\n\
    \        return reversed_first + reversed_rest\nend\n</cell>\n<code language=julia-1.5>\n\
    reverse(\"\")\n</cell>\n<code language=julia-1.5>\nreverse(\"cat\")\n</cell>\n\
    <code language=julia-1.5>\nmake_palindrome(\"cata\")\n</cell>\n<code language=julia-1.5>",
  "    begin = string.size - 1\n    length = string.size\n    palindrome = \"\"\n\
    \    while length > 0\n        prefix = string.substring(begin, 1)\n        begin\
    \ = begin - 1\n        suffix = string.substring(begin, 1)\n        if prefix\
    \ != suffix\n            if palindrome.length > 0\n                palindrome\
    \ = string.substring(begin, begin + palindrome.size + 1) +\n                 \
    \               palindrome +\n                                string.substring(begin,\
    \ begin + palindrome.size + 1)\n            else\n                palindrome =\
    \ string.substring(begin, begin + palindrome.size + 1)\n        end\n        length\
    \ = length - 1\n    end\n    return palindrome\nend\n\"\"\"\nTesting the function\
    \ above using doctest. \n\"\"\"", "    max_length = length(string, 2)\n    start\
    \ = minimum(string.length, max_length)\n    return string + reverse string.substring(start,\
    \ max_length)\nend\n</cell>\n<code language=julia-1.5>", "    if string == \"\"\
    \ then return string\n    if string == \"a\" then return string\n    if string.head(1)\
    \ != string.tail(end) then return make_palindrome(string[2:end]) else\n      \
    \  return make_palindrome(string.tail(end-1)) ++ string.head(1) end\nend \n</cell>\n\
    <code language=julia-1.5>\n\"\"\"\nThis function converts a single character string\
    \ into an ASCII value using the supplied map string.\n\"\"\"", "    return string+string[::-1]\n\
    end\n</cell>\n<text>\nNow we can use this function to find all the palindromes\
    \ in a string using recursion.", "    if string == \"\"\n        \"\"\n    else\n\
    \        chars = string.chars\n        reversed_chars = chars[1..].reverse\n \
    \       prefix_to_prepend = reversed_chars.substring(0,1)\n        reversed_prefix_to_prepend\
    \ = chars[0..].substring(reversed_chars.length() - 1)\n        string +=  prefix_to_prepend+reversed_prefix_to_prepend+reversed_chars\n\
    \        \n        return string\n    end\nend", "    \"\"\" Find the shortest\
    \ palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n\
    \    - Find the longest postfix of supplied string that is a palindrome.\n   \
    \ - Append to the end of the string reverse of a string prefix that comes before\
    \ the palindromic suffix.\n    >>> make_palindrome(\"\")\n    \"\"\n    >>> make_palindrome(\"\
    cat\")\n    \"catac\"\n    >>> make_palindrome(\"cata\")\n    \"catac\"\n    \"\
    \"\"\n    for str in string:\n        if str == str[::-1]:\n            str =\
    \ str + str[::-1]\n            return str", "    \n    \"\"\"\n    Find the longest\
    \ postfix of supplied string that is a palindrome.\n    \"\"\"\n    \n    \"\"\
    \"\n    Find the longest postfix of supplied string that is a palindrome.\n  \
    \  \"\"\"\n    \n    \n    \"\"\"\n    Find the longest postfix of supplied string\
    \ that is a palindrome.\n    \"\"\"\n    \n    return string", "    # TODO\n \
    \   return \"\"\nend", "    length_string = length(string)\n    prefix_string\
    \ = string[1:(length_string)]\n    suffix_string = string[(length_string+1):length(string)]\n\
    \    palindrome = prefix_string + string[reverse(suffix_string)]\n    return palindrome\n\
    end\n</cell>\n<cell>", "    # Write your code here\n    rev = reverse(string)\n\
    \    if rev == string:\n        return string\n    prefix_rev = rev\n    prefix_rev\
    \ = prefix_rev[prefix_rev.index(string) + length(string)]\n    prefix_rev = prefix_rev[::-1]\n\
    \    return string + prefix_rev", "    if string == \"\"\n        return string\n\
    \    string_length = length(string)\n    if string_length == 1\n        return\
    \ string\n    longest_suffix_postfix = find_longest_postfix_substring(string)\n\
    \    if longest_suffix_postfix != \"\"\n        prefix_length = longest_suffix_postfix\n\
    \    else\n        prefix_length = 1\n    \n    suffix_length = string_length\
    \ - prefix_length\n    \n    reversed_prefix = reverse(slice(string, prefix_length,\
    \ string_length))\n    reversed_suffix = reverse(slice(string, 0, suffix_length))\n\
    \    \n    string_palindrome = string + reversed_prefix + reversed_suffix\n  \
    \  return string_palindrome\nend", "    \n    # find longest postfix\n    postfix_len\
    \ = find_postfix_len(string)\n    # find prefix before postfix with same length\n\
    \    prefix_len = find_prefix_len(string, postfix_len)", "    max_length = 0\n\
    \    substring = \"\"\n    for letter in string\n        if letter != substring\n\
    \            max_length = max(max_length,length(string-substring))\n         \
    \   substring = letter\n        else \n            if length(substring) == max_length\n\
    \                max_length += 1\n                substring = \"\"\n         \
    \   else\n                substring = substring[1:end]\n    end\n    return substring+string[end-1:end-1]\n\
    end", "    if string == \"\"\n        return string\n    max_length = 0\n    for\
    \ i in string.words\n        max_length = max(max_length, max_length(string.substring(i)))\n\
    \    return string + string.repeat(max_length)\nend", "    string_length = length(string)\n\
    \    prefix_length = 0\n    suffix_length = 0\n    while prefix_length < string_length\n\
    \        prefix_length = prefix_length + 1\n        suffix_length = suffix_length\
    \ + 1\n        if prefix_length == string_length\n            return string +\
    \ reverse(string[prefix_length..string_length])\n    end", "    if length(string)>1\n\
    \        longest_prefix = \"\"\n        longest_prefix_index = 1\n        longest_prefix_length\
    \ = 1\n        for i in string.chars\n            if i>=longest_prefix\n     \
    \           longest_prefix = i\n                longest_prefix_index = longest_prefix_length\n\
    \            else\n                longest_prefix_length += 1\n        end\n \
    \       longest_prefix_string = \"\"\n        for i in string.chars[longest_prefix_index+1..-1]\n\
    \            longest_prefix_string += i\n        end\n        reverse_string =\
    \ reverse(longest_prefix_string)\n        prefix = string[longest_prefix_index..-1]\n\
    \        reverse_prefix =  reverse_string[longest_prefix_length..-1]\n       \
    \ result = string + reverse_prefix + longest_prefix_string\n        return result\n\
    \    else\n        return string\n    end\nend", "    max_length = length(string.substring(1,\
    \ length(string)))\n    substring = string.substring(1, max_length)\n    if length(substring)\
    \ == max_length\n        substring = reverse_substring(string.substring(1, max_length))\n\
    \        return string + substring\n    else\n        return substring\n    end\n\
    end\n</code>\n<|/ a tags=string,julia |>\n<| c |>\nThe algorithm works, but is\
    \ quadratic, which can be bad on long strings. A better solution can be found\
    \ [here](http://www.geeksforgeeks.org/longest-palindromic-substring/).\n<|/ c\
    \ |>\n<| a dscore=1 |>\nHere's a solution using regular expressions:\n<code>",
  "    max_length = 0\n    i = 0\n    \n    while i <= length(string) do\n       \
    \ if max_length < length(string) - i - 1 then\n            max_length = length(string)\
    \ - i - 1\n        end\n        \n        if string[i] != string[max_length] then\n\
    \            max_length += 1\n        end\n        \n        i += 1\n    end",
  "\"\"\"\nFind the shortest palindrome that begins with a supplied string.\nAlgorithm\
    \ idea is simple:\n- Find the longest postfix of supplied string that is a palindrome.\n\
    - Append to the end of the string reverse of a string prefix that comes before\
    \ the palindromic suffix.\n\"\"\"\nreturn string\n    \n</cell>\n<text>\nNow let's\
    \ apply this algorithm:", "    let length_of_string = string.length\n    if length_of_string\
    \ == 0 then return \"\"\n    if length_of_string == 1 then return string\n   \
    \ \n    let left_part_of_string = string.sub(0,string.length-1)\n    let right_part_of_string\
    \ = string.sub(string.length-1)\n    \n    let reverse_of_left_part = reverse(left_part_of_string)\n\
    \    \n    reverse_of_left_part + right_part_of_string\nend\n</code>\n<|/ a dscore=3\
    \ |>\n<| a dscore=3 |>\nThis is not a palindrome, it is a palindrome with a single\
    \ letter:\n<code>\nreverse(String) -> String", "    let prefix_len = length(prefix(string))\n\
    \    let suffix_len = length(suffix(string))\n    if prefix_len < suffix_len then\n\
    \        make_palindrome(suffix(string))\n    else\n        let rev = string[prefix_len...-suffix_len]\n\
    \        string + rev\n    end\nend\n</cell>\n<code language=julia-1.0>\np1 =\
    \ make_palindrome(\"\")\np2 = make_palindrome(\"cat\")\np3 = make_palindrome(\"\
    cata\")\np4 =  make_palindrome(\"catra\")\np5 = make_palindrome(\"catat\")\np6\
    \ =  make_palindrome(\"catat\")\np7 = make_palindrome(\"catac\")\np8 =  make_palindrome(\"\
    catac\")\n</cell>\n<code language=julia-1.0>\n@time p1 = make_palindrome(\"\"\
    )\n@time p2 = make_palindrome(\"cat\")\n@time p3 = make_palindrome(\"cata\")\n\
    @time p4 =  make_palindrome(\"catra\")\n@time p5 = make_palindrome(\"catat\")\n\
    @time p6 =  make_palindrome(\"catat\")\n@time p7 = make_palindrome(\"catac\")\n\
    @time p8 =  make_palindrome(\"catac\")\n</cell>\n<text>\nTime complexity of the\
    \ Julia code\nThe code below is expected to run within about 3 seconds on a Core\
    \ i5 2.4 GHz machine with a 64-bit operating system and 4GB of RAM installed.",
  "  \n    if string == \"\"\n        \"\"\n    else\n        middle = find_middle(string,\
    \ length(string)-1)\n        if middle == length(string)-1\n            string\n\
    \        else\n            string\n            append!(string, string[middle]::String)\n\
    \            make_palindrome(string[middle+1::Int])\n        end\n    end\nend\n\
    </code>\n<|/ a tags=julia dscore=0 |>\n<| a tags=julia dscore=0 |>\nHere is another\
    \ solution based on's idea but in Julia. \n<code>", "\"\"\"\n    Find the shortest\
    \ palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n\
    \    - Find the longest postfix of supplied string that is a palindrome.\n   \
    \ - Append to the end of the string reverse of a string prefix that comes before\
    \ the palindromic suffix.\n    >>> make_palindrome(\"\")\n    \"\"\n    >>> make_palindrome(\"\
    cat\")\n    \"catac\"\n    >>> make_palindrome(\"cata\")\n    \"catac\"\n    \"\
    \"\"\n    \n    # check if string is a palindrome.\n    palindrome = string\n\
    \    if string == string.to_reverse:\n        return string\n    # check if string\
    \ is empty\n    if string == \"\":\n        return \"\"\n    \n    # find the\
    \ longest postfix that is a palindrome \n    postfix_of_longest_palindrome = get_longest_palindrome_suffix(string)\n\
    \    \n    # get the prefix of the string\n    prefix_of_longest_palindrome =\
    \ get_prefix_of_string(postfix_of_longest_palindrome)\n    \n    # reverse the\
    \ prefix_of_longest_palindrome and append to the end of postfix_of_longest_palindrome\n\
    \    longest_palindrome = prefix_of_longest_palindrome.to_reverse + postfix_of_longest_palindrome\n\
    \    return longest_palindrome", "    if string == \"\"\n        return \"\"\n\
    \    else if string[1] != string[length(string)-1]\n        return string + make_palindrome(string[1:length(string)-1])\n\
    \    else \n        return string + make_palindrome(string[2:length(string)-1])\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\" Find the length of the longest\
    \ palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n\
    \    - Find the longest postfix of supplied string that is a palindrome.\n   \
    \ - Search for first occurrence of palindromic suffix in the string and take that\
    \ length as the length.\n    - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    >>> make_palindrome(\"\
    \")\n    \"\"\n    >>> make_palindrome(\"cat\")\n    \"catac\"\n    >>> make_palindrome(\"\
    cata\")\n    \"catac\"\n    \"\"\"", "    return string + reverse(string.substring(0,length(string.substring(1,string.end))))\
    \ \nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=2 tags=julia |>\nAs of Julia\
    \ 1.0 the above solutions work fine for palindrome strings up to length 32, but\
    \ for strings longer than 32 they will produce incorrect results. For example\
    \ for \"dog\" the result is \"doogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogogog",
  "    if is_palindrome(string) == true\n        return string\n    else\n       \
    \ temp_string := string\n        temp_string := reverse(string)\n        temp_string\
    \ := temp_string + string\n        return temp_string\n</code>", "    \"\"\"\n\
    \    \n    >>> make_palindrome(\"\")\n    \"\"\n    >>> make_palindrome(\"cat\"\
    )\n    \"catac\"\n    \"\"\"\n    return \"\"", "\"\"\"\n    Return the shortest\
    \ palindrome that begins with string.\n    Algorithm idea is simple:\n    - Find\
    \ the longest postfix of string that is a palindrome.\n    - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \"\"\"\n    # TODO\nend\n</code>\n<|/ a |>\n<| c |>\nPlease don't just dump code\
    \ as an answer, try to explain what it does and how it solves the problem of the\
    \ question. Your code might work but it could be improved by adding an explanation\
    \ of how it works :) You can [edit] your answer to improve it.\n<|/ c |>\n<| c\
    \ |>\nI actually tried the other solutions and they did not work for the problem\
    \ I was working on so I gave this another try. This was a homework problem and\
    \ they had me do the algorithm from scratch but I wanted to understand how the\
    \ algorithm worked.\n<|/ c |>\n<| c |>\nThanks for the comment, I edited my answer\n\
    <|/ c |>\n<| c |>\nI thought I might give it a shot but I can't get it working\
    \ (I did reformat it a bit). I tried this but I can't understand why it does not\
    \ work: `function make_palindrome(string::String)::String where {String : string}\
    \ = \nlet rec make_palindrome_rec(string,palindrome)::String where {String : string,\
    \ palindrome::String} = \n    if string == \"\"\n    then palindrome\n    else\
    \ \n        make_palindrome_rec(string - string,string + reverse(string))\nin\
    \ make_palindrome_rec(string,\"\")`\n<|/ c |>\n<| c |>\nIt looks like your function\
    \ does work, but you might want to add `where {String : string}` to your function\
    \ definition. I've edited my answer to include it.\n<|/ c |>\n<| a dscore=0 |>\n\
    The question is quite old but since I had to face the same challenge and I found\
    \ no correct answer on this forum, I will share my solution.\nThe idea is to exploit\
    \ a palindrome property of strings in which a palindrome is a string that is a\
    \ palindrome of the opposite direction of the given one.\nHere is my implementation\
    \ :\n<code>\nimport Data.Char (isDigit)", "    \n    \"\"\"\n    TODO: Write your\
    \ code here.\n    \"\"\"\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n", "    if string == \"\"\n \
    \       return string\n    else if string == reverse(string(string))\n       \
    \ return string\n    else if string[0] == reverse(string(string))\n        return\
    \ reverse(make_palindrome(string[1..-1]))\n    else\n        first, rest = string.slice(1,-1),\
    \ string.slice(0,1)\n        make_palindrome(first)+make_palindrome(rest)\n  \
    \  end\nend\n</code>\n<|/ a |>\n<| a tags=algorithm,python,recursion,palindrome\
    \ |>\nUsing list comprehension in Python to check for a palindrome:\n<code>\n\
    def reverse(s):\n    length = len(s)\n    return s[length-1:0:-1]", "    len::Int\
    \ = length(string)\n    if len == 0 \n        return \"\"\n    if len == 1 \n\
    \        return string\n    end::Int = len - 1 \n    palindrome::String = reverse(substring(string,\
    \ 0, end))\n    return string + palindrome\n</code>\n<|/ a tags=algorithm,string,recursion,palindrome,haskell\
    \ |>\n<| c |>\nThis is O(n^2).  A palindrome has O(n) characters and O(1) string\
    \ concatenation.\n<|/ c |>\n<| c |>\n: Yes, that's correct. That's what \"palindrome\"\
    \ is for. An O(n) palindrome is one whose reverse() is the original string.\n\
    <|/ c |>\n<| c |>\n, that sounds right, but I think the original question asked\
    \ for a recursive solution. My solution also uses recursion.\n<|/ c |>\n<| c |>\n\
    , I'm sorry I missed that. Yes, I realize that your solution is O(n). However,\
    \ I believe that the original question asked for a recursive solution. Also, `reverse`\
    \ has linear runtime complexity (amortized), so it's still not O(n).\n<|/ c |>\n\
    <| c |>\n, I believe that my solution is O(n^2). O(n) is one property of strings\
    \ that guarantees that you can traverse them in both directions once.  O(n^2)\
    \ is one property of algorithms that guarantees that they will take the same amount\
    \ of time.  When you apply \"palindrome\" to a string, it tells you the string\
    \ you started with and also the string that it ends with.  It is not true that\
    \ reverse is O(n), but it is not O(n^2).  O(n) is one property of strings that\
    \ guarantees that you can traverse them in both directions once.\n<|/ c |>\n<|\
    \ a dscore=3 |>\nI believe the best way to do this is to use recursion.  Here\
    \ is a Haskell implementation:\n<code>\npalindromeRec :: [a] -> [a]\npalindromeRec\
    \ [] = []\npalindromeRec (x:xs) = x : reverse (x:palindromeRec (filter (/= x)\
    \ xs))\n</code>\nThis isn't tail recursive - but it is simple enough that it can\
    \ be converted to one using recursion.  Just make sure you take your test cases\
    \ into account.\n<code>\n> palindromeRec \"abcd\"\n\"abcd\"\n> palindromeRec \"\
    abba\"\n", "    if string == \"\"\n        \"\"\n    else\n        result <- \"\
    \"\n        i <- 0\n        j <- length(string) - 1\n        while i <= j\n  \
    \          result <- result + string[i]\n            i <- i + 1\n            result\
    \ <- result + string[j]\n            j <- j - 1\n            if i == j\n     \
    \           break\n        return result", "    length = len(string)\n    if length\
    \ < 2 || length == length * 2 \n        return string\n    \n    string_reverse\
    \ = reverse(string(1:end-1))\n    substring = string(2:end)\n    rev_substring\
    \ = reverse(substring)\n    return string_reverse + substring\nend \"\"\"", " \
    \   \"\"\"\n    Find the longest palindrome that begins with a supplied string.\n\
    \    \"\"\"", '"""Finds the shortest palindrome that begins with a supplied string.',
  "    \n    \n    if string == \"\"\n        return \"\"\n    \n    index_begin::Int\
    \ = find(string, \" \")\n    index_end::Int = end - index_begin\n    \n    postfix::String\
    \ = substring(string, index_begin, index_end)\n    palindrome::String = reverseString(postfix)\n\
    \    \n    if endsWith(string, palindrome)\n        return string\n    else\n\
    \        return palindrome + string\n    end\n    \nend\n</cell>\n<cell>\n# TEST\
    \ make_palindrome\nassert make_palindrome(\"\") == \"\"\nassert make_palindrome(\"\
    cat\") == \"catac\"\nassert make_palindrome(\"cata\") == \"catac\"\n</cell>\n\
    <cell>\n\"\"\"\n    index_begin::Int\n    index_end::Int\n    \n    Returns a\
    \ tuple with the first index where the substring begins and \n    the last index\
    \ where the substring ends.\n    \n    >>> index_begin, index_end = find(\"abracadabra\"\
    , \"abra\")\n    >>> index_begin, index_end\n    (5, 9)\n    \"\"\"", "    return\
    \ string \nend", "    \n    prefix_length = len(string) - string[::-1].findFirstIndexIn(string)\
    \ + 1 \n    \n    if prefix_length == 0 then \n        return \"\"\n    else \n\
    \        return string[prefix_length:prefix_length+string[::-1].findFirstIndexIn(string)]\n\
    end \n</code>\nThis solution works, but its not really optimal. It takes O(n2)\
    \ time which is higher than the O(n) solution described by\n<|/ a tags=algorithm,string,scala\
    \ |>\n<| a dscore=2 |>\nA solution that works for any string.\n<code>\ndef palindrome(s:\
    \ String): String = {\n  val m = s.toCharArray\n  val reverse = new StringBuilder\n\
    \  var i = 0\n  while (i < m.length) {\n    if (i == m.length / 2) {\n      reverse.append(s(m.length\
    \ - 1 - i))\n      i += 1 \n    } else {\n      reverse.append(m(m.length - 1\
    \ - i))\n      i += 1\n    }\n  }\n  reverse.toString\n}\n</code>\n<|/ a tags=algorithm,string,scala\
    \ |>\n<| a dscore=2 tags=algorithm,string,scala |>\nI know this is an old thread\
    \ but I recently had to solve this question in Scala and wanted to post my solution.\
    \ I would prefer using functional programming over recursion because recursion\
    \ is slower and I prefer using immutable objects as much as possible. The solution\
    \ is implemented in a recursive manner which has O(n) complexity and O(n) space.\
    \ Here is the code:\n<code>\ndef longestPalindromicSubstring(string: String):\
    \ String = {\n  def longestPalindromicSubstringHelper(string: String): String\
    \ =\n    string.substring(0, string.length / 2) match {\n      case s if s.reverse.startsWith(s.reverse.reverse)\
    \ =>\n        s.reverse\n      case _ =>\n        if (string.length % 2 == 0)\
    \ {\n          longestPalindromicSubstringHelper(s.reverse)\n        } else {\n\
    \          longestPalindromicSubstringHelper(s.reverse + s)\n        }\n    }\n\
    \  longestPalindromicSubstringHelper(string)\n}\n</code>\n<|/ a |>\n<| a dscore=1\
    \ |>\nHere is a solution written in Java using recursion. Hope this helps.\n<code>\n\
    import java.util.Scanner;", "    if string == \"\"\n        \"\"\n    else\n \
    \       local longest = 0\n        local index = 0\n        for i = 1, string.length\n\
    \            do\n                if string.length - i > longest\n            \
    \        longest = string.length - i\n                    index = i\n        \
    \    end\n        end", "    \n    # Write your code here\n    max_length = findMaxLength(string)\n\
    \    post_fix = get_post_fix(string, max_length)\n    reverse_suffix = \"$\" <>\
    \ reverse (post_fix)\n    return string <> reverse_suffix", "    #get the reverse\
    \ of the string\n    string_len = len(string)\n    if string_len == 0 then\n \
    \       return string\n    else\n        prefix_reverse = reverse(string(0,string_len))\n\
    \        suffix_reverse = reverse(string(string_len))\n        string = prefix_reverse\
    \ + suffix_reverse\n        return string\n    end\nend\n</code>\n<|/ a tags=julia,function,string\
    \ |>\n<| c |>\nThis is probably a faster implementation than the other one (that\
    \ loops through the string twice, although I'm not sure about this being true\
    \ since I haven't checked the speed).\n<|/ c |>\n<| a tags=julia,function,string\
    \ dscore=3 |>\nYou can use findall function of string library:\n<code>\njulia>\
    \ using String", "    if string == \"\" \n        \"\" \n    else \n        string\
    \ = reverse(string(string)) +  string(string)\n        \n        \ndef make_palindrome(string::String)::String\
    \ \n    if string == \"\" \n        \"\" \n    else \n        string = reverse(string(string))\
    \ +  string(string)\n        \n        \ndef make_palindrome(string::String)::String\
    \ \n    if string == \"\" \n        \"\" \n    else \n        string = reverse(string(string))\
    \ +  string(string)\n        \n        \ndef make_palindrome(string::String)::String\
    \ \n    if string == \"\" \n        \"\" \n    else \n        string = reverse(string(string))\
    \ +  string(string)\n        \n        \ndef make_palindrome(string::String)::String\
    \ \n    if string == \"\" \n        \"\" \n    else \n        string = reverse(string(string))\
    \ +  string(string)\n        \n        \ndef make_palindrome(string::String)::String\
    \ \n    if string == \"\" \n        \"\" \n    else \n        string = reverse(string(string))\
    \ +  string(string)\n        \n        \ndef make_palindrome(string::String)::String\
    \ \n    if string == \"\" \n        \"\" \n    else \n        string = reverse(string(string))\
    \ +  string(string)\n        \n        \ndef make_palindrome(string::String)::String\
    \ \n    if string == \"\" \n        \"\" \n    else \n        string = reverse(string(string))\
    \ +  string(string)\n        \n        \ndef make_palindrome(string::String)::String\
    \ \n    if string == \"\" \n        \"\" \n    else \n        string = reverse(string(string))\
    \ +  string(string)\n        \n        \ndef make_palindrome(string::String)::String\
    \ \n    if string == \"\" \n        \"\" \n    else \n        string = reverse(string(string))\
    \ +  string(string)\n        \n        \ndef make_palindrome(string::String)::String\
    \ \n    if string == \"\" \n        \"\" \n    else \n        string = reverse(string(string))\
    \ +  string(string)\n        \n        \ndef make_palindrome(string::String)::String\
    \ \n    if string == \"\" \n        \"\" \n    else \n        string = reverse(string(string))\
    \ +  string(string)\n        \n        \ndef make_palindrome(string::String)::String\
    \ \n    if string == \"\" \n        \"\" \n    else \n        string = reverse(string(string))\
    \ +  string(string)\n        \n        \ndef make_palindrome(string::String)::String\
    \ \n    if string == \"\" \n", "    if string == \"\" then \n        return \"\
    \"\n    else \n        left_postfix = string[1..-1]\n        right_postfix = string[-2..]\n\
    \        palindrome = left_postfix.reversed.prepend(right_postfix)\n        make_palindrome(string[2:end])\n\
    \    end\n</code>\n<|/ a |>\n<| a tags=ruby,algorithm,string |>\nThis should do\
    \ the trick:\n<code>\ndef is_palindrome?(str)\n  reversed_str = str.reverse\n\
    \  str == reversed_str\nend", "  if string == \"\"\n    return \"\"\n  elseif\
    \ length(string)==1\n    return string\n  else\n    reversed_palindrome = reverse(make_palindrome(string(1:end-1)))\n\
    \    prefix_palindrome = string(1:end - 1)\n    prefix_palindrome = reverse(prefix_palindrome)\n\
    \    return prefix_palindrome + reversed_palindrome\nend\n</cell>\n<code language=julia-1.3>\n\
    # test the function \nmake_palindrome(\"cat\")\n</cell>\n<text>\nReverse a string\
    \ in Julia using a function without loops or recursion\nThe reverse function reverses\
    \ a string.  However, it has an optional second argument that can take a string\
    \ to reverse from.  This is more useful for strings that are repeating characters\
    \ such as letters or digits.", "    if string == \"\"\n    \"\"\n    else\n  \
    \      if length(string) mod 2 = 0 \n            reverse(string, 1, length(string)\
    \ - 1)\n        else\n            reverse(string, 1, length(string) - 2)\n   \
    \         reverse(string,length(string)-1,length(string))\n        end\n    end\n\
    end\n</code>\n<|/ a |>\n<| c |>\nA palindrome doesn't necessarily need to end\
    \ with a `c`.\n<|/ c |>\n<| c |>\nThis doesn't really answer the OP's question,\
    \ although I agree with your solution. An answer would also explain why your solution\
    \ works.\n<|/ c |>\n<| a |>\n<code>", "    left_to_right=string\n    right_to_left=\"\
    \"\n    i=2\n    while(left_to_right != right_to_left && i < length(left_to_right))\n\
    \        left_to_right=left_to_right[1:]\n        right_to_left=right_to_left[1:]\
    \ + left_to_right\n        i+=1\n    if left_to_right == right_to_left\n     \
    \   return string\n    else\n        return left_to_right\n    end\nend\n</code>\n\
    <|/ a |>\n<| c |>\nPlease use formatting tools to make your post more readable\
    \ (http://stackoverflow.com/editing-help).\n<|/ c |>\n<| c |>\nYou are not handling\
    \ the case where the string is empty (which should return an empty string).\n\
    <|/ c |>\n<| c |>\nThanks , i was just about to ask , was using iOS.. so forgot\
    \ about the iPhone.. anyways your right.. i have fixed the code.. :)\n<|/ c |>\n\
    <| a tags=string,string,lua |>\n<code>", "    max_length = 0\n    prefix_length\
    \ = 0\n    \n    for s in string.split(\"\")\n        if isPalindrome(s)\n   \
    \         max_length = max(max_length, s.length)\n            prefix_length =\
    \ prefix_length + s.length\n    end\n    return string.substr(0, max_length) +\
    \ string.substr(max_length - prefix_length, prefix_length)\nend\n</cell>\n<text>\n\
    We should now be able to test each of the functions we developed independently\
    \ to make sure they work as intended. Let's do some more testing to ensure the\
    \ functions return as expected.", "    # Write your code in Julia here\n</code>\n\
    <|/ a dscore=2 tags=algorithm,palindrome,string,julia |>\n<| a |>\nThis question\
    \ already has an accepted answer, but here's a Julia implementation based on it.\
    \ \n<code>", "    max_length = 0\n    max_length_postfix_count = 0\n    max_length_prefix_count\
    \ = 0", "    # Make an empty string\n    result = ''\n    # Loop through the supplied\
    \ string, checking for palindromes\n    for char in string.chars\n        \n \
    \       if char != string[string.length -1]\n            # Not palindrome: add\
    \ it to the result\n            result += char\n        end\n    end\n    \n \
    \   # Return the result\n    return result\nend\n</cell>\n<code language=julia-1.6>\n\
    println(make_palindrome(\"cat\"))\n</cell>\n<text>\nNow lets look at the palindrome\
    \ function in the next section.", "\tlet length::Int = length(string)\n\tlet new_string::String\
    \ = empty\n\tfor i from 0 to length / 2 do\n\t\tnew_string <- string + reverse(new_string)\n\
    \treturn new_string\nend function\n\"\"\"", "\"\"\"Find longest palindrome that\
    \ begins with a supplied string.\nAlgorithm idea is simple:\n- Find the longest\
    \ postfix of supplied string that is a palindrome.\n- Append to the end of the\
    \ string reverse of a string prefix that comes before the palindromic suffix.\n\
    \"\"\"\n</code>\nAs you can see I am not able to get the logic of how to do this\n\
    I have implemented a recursive function that will work on the string that it is\
    \ called on and return the result but I am not able to do what I need.\nThe function\
    \ takes in a string and reverses the string and return it \n<code>", "    if string\
    \ == \"\"\n        return \"\"\n    else\n        if string[0] != string[-1]\n\
    \            pref = string[1..(string.length-1)]\n            suff = reverse(pref)\n\
    \            string += pre + suff\n        end\n        \n        return string\n\
    \    end\nend\n</cell>\n<code language=julia-1.6>\n?reverse\n</cell>\n<code language=julia-1.6>",
  "    palindrome = string\n    for i = length(string)-2 to 0 by -1\n        if palindrome[i]\
    \ != string[i]\n            palindrome = append!(palindrome, string[i])\n    \
    \    end\n    end\n    return palindrome\nend\n</cell>\n<code language=julia-1.0>\n\
    make_palindrome(\"cata\")\n</cell>\n<code language=julia-1.0>", "    if string\
    \ == \"\"\n        return \"\"\n    else \n        reversed_string = \"\"\n  \
    \      max_length = 0\n        for i in reverse(string.chars)\n            if\
    \ i == string[i]\n                max_length += 1\n            else \n       \
    \         reversed_string += string[i..max_length]\n                max_length\
    \ = i\n    \n        reversed_string += string[max_length..]\n        return reversed_string\n\
    </code>\n<|/ a tags=function,recursion,string,string,haskell |>\n<| c |>\n`reverse\
    \ (string.chars)` should be `reverse string.chars` (and similarly for `reversed`\
    \ which should be `reversed`). Also, `reversed` is probably the most idiomatic\
    \ way to write this.\n<|/ c |>\n<| a |>\n<code>\nfindPalindrome :: String -> String\n\
    findPalindrome str = findPalindromeHelper str \"\"\n  where\n    findPalindromeHelper\
    \ str prefix\n      | str == []    = prefix\n      | otherwise  = findPalindromeHelper\
    \ (reverse str) prefix++[str[0]]", "    longest = string\n    longest.insert(0,\"\
    \")\n    for i in string[2:length(longest)-1:1]\n        longest = longest[1:length(string)-1]+i\n\
    \    end\n    return longest\nend", "    # Initialise result and longest palindromic\
    \ suffix length\n    let longestPalindromeLength = 0\n    let result = \"\"\n\
    \    # Split into words\n    for word in string.split(\" \") do \n        # Find\
    \ the longest postfix of supplied string that is a palindrome\n        let wordLength\
    \ = len(word)\n        if wordLength > longestPalindromeLength then \n       \
    \     longestPalindromeLength = wordLength\n        # Find the longest prefix\
    \ of supplied string that comes before the palindromic suffix\n        let longestPrefixLength\
    \ = wordLength - longestPalindromeLength\n        # Append the reverse of the\
    \ suffix of the prefix to the palindromic suffix\n        result <- result + word[longestPrefixLength..wordLength]\n\
    \        # Append the supplied string to the palindromic suffix\n        result\
    \ <- result + word[longestPrefixLength..wordLength]\n    end\n    return result\n\
    end", "  string = string.strip()\n  if string == \"\"\n    string\n  else\n  \
    \  string[1:(string.length-1)] + string[1] + string[(string.length-1):]\n  end\n\
    end\n</code>\n<|/ a tags=string,ruby,algorithm |>\n<| c |>\nThis doesn't answer\
    \ the question.\n<|/ c |>\n<| c |>\nThis does not find the palindrome but just\
    \ checks if it equals it.\n<|/ c |>\n<| a tags=string,ruby,algorithm |>\nUsing\
    \ Ruby String#reverse and String#slice, we can do this:\n<code>\ndef make_palindrome(string)\n\
    \  reverse_string = string.reverse\n  new_string = reverse_string.slice(string.length-reverse_string.length,\
    \ string.length)\n  \"#{string}#{new_string}\"\nend", "    # Base case\n    if\
    \ string == \"\" \n        then return string\n    else if string.head == string.tail\
    \ \n        then return string + reverse(string)\n    else \n        # Find the\
    \ longest postfix of supplied string that is a palindrome.\n        longest =\
    \ \"\" \n        for i in string.tail do \n            if string.head == i \n\
    \                then longest = longest + i \n        # Append reverse of a string\
    \ prefix that comes before the palindromic suffix.\n        return string.head\
    \ + reverse(string) + longest\nend\n</cell>\n<code language=julia-1.4>", "\"\"\
    \"\n    Find the shortest palindrome that begins with a supplied string.\n   \
    \ Algorithm idea is simple:\n    - Find the longest postfix of supplied string\
    \ that is a palindrome.\n    - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    >>> make_palindrome(\"\
    \")\n    \"\"\n    >>> make_palindrome(\"cat\")\n    \"catac\"\n    >>> make_palindrome(\"\
    cata\")\n    \"catac\"\n\"\"\"\n    str_len = length(string)\n    palindrome =\
    \ \" \"\n    for length in (str_len+1):\n        rev = string[(-length):0:-1]\n\
    \        if rev == string[(-length):0:-1]:\n            palindrome = string +\
    \ rev\n            break\n    return palindrome\n</code>\n<|/ a tags=algorithm\
    \ dscore=2 |>\n<| c |>\nI see you are using python, so you can use the `re` module\
    \ to replace the loop with a single line: `palindrome = re.search(r'^(\\w*)((\\\
    w)\\2*\\w*)$', string)`\n<|/ c |>\n<| a tags=algorithm |>\nI made a javascript\
    \ solution:\n<code>\nconst isPalindrome = function(str) {\n  str = str.toLowerCase().split('');\n\
    \  str = str.map(char => char === char.toUpperCase() ? char.toLowerCase() : char.toUpperCase());\n\
    \  let reversed = false;\n  for (let i = str.length - 2; i >= 0; i--) {\n    if\
    \ (str[i] !== str[i + 1 && !reversed]) {\n      return false;\n    }\n    reversed\
    \ = !reversed;\n  }\n  return true;\n};", "    string = string.upper()\n    length::Int\
    \ = string.len()\n    if (length <= 0) then \n        return \"\"\n    else \n\
    \        prefix::String = string[0..length.length]\n        reverse::String =\
    \ string.reverse()\n        if prefix == reverse then \n            string::String\
    \ = prefix ++ string\n            else \n                string::String = prefix\
    \ + reverse\n        end\n    end\nend\n\"\"\"\nFind the longest palindrome that\
    \ begins with a supplied string.\nAlgorithm idea is simple:\n    - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    - Append to the end of\
    \ the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    >>> make_palindrome(\"\")\n    \"\"\n    >>> make_palindrome(\"cat\")\n \
    \   \"catac\"\n    >>> make_palindrome(\"cata\")\n    \"catac\"\n    \"\"\"",
  "  \n  \n  return string\nend", "    if string == \"\"\n        \"\"\n    else\n\
    \        if string[1] == string[length(string)-1]\n            make_palindrome(string[2:length(string)])\n\
    \        else\n            make_palindrome(string[1:length(string)])\n       \
    \         + \"-\"\n                + string[1:length(string)-1]\n            \
    \    + make_palindrome(string[2:length(string)])\n    end\nend", "    string =\
    \ string + make_palindrome_reverse(string(0,string.length-1))\nend", "\"\"\"Find\
    \ the shortest palindrome that begins with a supplied string.\n    Algorithm idea\
    \ is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n\
    \    - Append to the end of the string reverse of a string prefix that comes before\
    \ the palindromic suffix.\n    >>> make_palindrome(\"\")\n    \"\"\n    >>> make_palindrome(\"\
    cat\")\n    \"catac\"\n    >>> make_palindrome(\"cata\")\n    \"catac\"\n    \"\
    \"\"\n    return \"\"", "    if string == \"\" || string==\" \"\n        return\
    \ string\n    string::String = reverse(string(string.end-1))\n    \n    if string.end==1\n\
    \        return string\n    \n    if string.end==2\n        if string[1]==string[2]\n\
    \            return string\n        else\n            return string*2\n      \
    \  \n    if string.end>2\n        first,last::String = (string.sub(1)+string).splitAt(string.end-1)\n\
    \        return first + string+last\n    end\nend", "    length::Int = len(string)\n\
    \    \n    if length < 2\n        return string\n    \n    substring = string[1:length]\n\
    \    reverse = reverse(substring)\n    \n    if reverse == substring\n       \
    \ return string + reverse\n    else\n        return string + reverse[::-1]\n \
    \   end\nend\n</cell>\n<code language=julia-1.3>\n\"\"\"\n    longest_palindrome(string::String)",
  "    if string.empty \n        then return string \n        else make_palindrome(string[1:end-1])\
    \ + string[0]\n    end\nend ", "    \"\"\"Find the longest postfix that is a palindrome.\
    \ \n    >>> make_palindrome(\"\")\n    \"\"\n    >>> make_palindrome(\"cat\")\n\
    \    \"catac\"\n    >>> make_palindrome(\"cata\")\n    \"catac\"\n    \"\"\"",
  "    max_length = 0\n    palindrome = \"\"\n    for i in string:\n        if max_length\
    \ < i:\n            max_length = i\n    for i in string:\n        if i == \"c\"\
    :\n            palindrome += i\n        if max_length > i:\n            if palindrome\
    \ != \"\":\n                if max_length - i > len(palindrome):\n           \
    \         palindrome += \"0\"*(max_length-i) + palindrome\n                else:\n\
    \                    palindrome += i\n            else:\n                palindrome\
    \ += i\n    return palindrome\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 tags=algorithm,math,python\
    \ |>\nHere is an example of the solution implemented in javascript. I did not\
    \ post the entire solution because this question is not about Python but just\
    \ about an algorithm, and it is possible to have two implementations for the same\
    \ problem.\n<code>\nvar isPalindrome = function(str) {\n    // Check if str length\
    \ is even or odd\n    if (str.length % 2 !== 0) return false;", "    prefix_length=length(string)\n\
    \    suffix_length=length(string(reverse(string(string))\n    prefix_reverse=string(string(string,\
    \ reverse_string(string(string))))\n    prefix_reverse(prefix_length+1:prefix_length+suffix_length)\
    \ = string(string(string, reverse_string(string(string))))\n    return prefix_reverse+string(string,\
    \ reverse_string(string(string)))\nend\n</cell>\n<code language=julia-0.4>\n@assert\
    \ assert $(make_palindrome(\"cata\")) == \"catac\"\n@assert assert $(make_palindrome(\"\
    cat\")) == \"catac\"\n@assert assert $(make_palindrome(\"ab\")) == \"acb\"\n@assert\
    \ assert $(make_palindrome(\"ba\")) == \"bac\"\n@assert assert $(make_palindrome(\"\
    baa\")) == \"bac\"\n</cell>\n<text>\nThe last function we added is the one that\
    \ breaks a string apart into a prefix and suffix and then returns the reverse\
    \ of that prefix. This reverse can be put back together with another prefix and\
    \ suffix to form a new palindrome. How can we do this? We use the reverse function!\
    \ Remember: We have already defined reverse_string and that reverse function reverses\
    \ a string.", "    if string == \"\"\n        return \"\"\n    length::Int\n \
    \   str = string.to_string()\n    length = string.len()\n    if length == 1\n\
    \        return string\n    else\n        postfix = string.tail\n        reverse_prefix\
    \ = string[0..postfix.len()-1]\n        if postfix.to_s == reverse_prefix.to_s\n\
    \            return string\n        else\n            return string.concat reverse_prefix.concat\
    \ postfix.reverse.prepend(string.head)\n    end\nend\n</cell>\n<text>\nWe can\
    \ now write the main function and test it to see what it is doing. We will use\
    \ the function from above to test our function. We will use a small string just\
    \ to verify that we have the right output.", "    if string.size == 0 then return\
    \ string\n    \n    let string = string.asCharArray()\n    let leftSide = string.slice(x..(-1)).asCharArray()\n\
    \    let rightSide = string.slice(0..x).asCharArray()\n    let maxLength = (leftSide.length\
    \ + rightSide.length) / 2\n    let palindrome = \"\"\n    for i in 0..(maxLength-1)\
    \ #rightSide.length do\n        let palindrome = palindrome + leftSide[i] + rightSide[i]\n\
    \    end\n    return palindrome\nend\n</code>\n<|/ a |>\n<| c |>\nThe \"algorithm\
    \ idea\" you describe is actually the solution I proposed in my answer, using\
    \ two indexes to track the end and the start of the reversed string.  Your idea\
    \ was very close, but only works for a palindrome of a single character.  With\
    \ two, it works great.\n<|/ c |>\n<| c |>\n, thank you for pointing that out,\
    \ I completely forgot about this restriction. I will update my answer, and provide\
    \ better description.\n<|/ c |>\n<| c |>\nThanks Achim, that is much better than\
    \ my solution, but I still think your answer is clearer than mine.  You do need\
    \ to track the start and end indexes, but they don't need to be separate indices.\
    \  You can just track the length you're looking at in your loop.  (You also don't\
    \ need to keep track of leftSide and rightSide, just use string.slice().  So I\
    \ took your answer, and tweaked it just a bit.  Also I just removed the explicit\
    \ `return \"\"` at the end since that's redundant.)\n<|/ c |>\n<| a |>\nI solved\
    \ it by using 2 indexes, one to keep track of the palindrome length (palindrome\
    \ length), and the other to keep track of the current position of the string you\
    \ are looking at.  I used a while loop to keep going until the string is equal\
    \ to the palindrome, then I break out of the loop.\n<code>", "    \"\"\"\n   \
    \ >>> make_palindrome(\"\")\n    \"\"\n    >>> make_palindrome(\"cat\")\n    \"\
    catac\"\n    >>> make_palindrome(\"cata\")\n    \"catac\"\n    \"\"\"\n    \n\
    \    length = len(string)\n    longest_postfix_i = length\n    longest_postfix_j\
    \ = 0\n    \n    # Loop from beginning of string to end and find longest postfix\
    \ of length i\n    for i::Int <- 0 .. length-1\n        \n        # Check if we\
    \ have found longest postfix so far\n        if i > longest_postfix_i\n      \
    \      # If the current longest postfix is the same length as the previous longest\
    \ postfix,\n            # ignore the current prefix since it is no longer a palindrome\n\
    \            if longest_postfix_j == i\n                continue \n          \
    \  \n            # Find the longest postfix that has length (longest_postfix_i-1)+1\
    \ at position i\n            longest_postfix_j = i + 1\n            while longest_postfix_j\
    \ < (i+(longest_postfix_i-1))\n                longest_postfix_j += 1\n      \
    \      \n            # Add reversed prefix of string i to end of new palindrome\n\
    \            string = string + string[longest_postfix_i-1:longest_postfix_j]\n\
    \            \n            # Now remove i from longest postfix because it is no\
    \ longer a palindrome\n            longest_postfix_i -= 1\n            \n    \
    \        # Now remove longest postfix of length longest_postfix_i+1 because it\
    \ is no longer a palindrome\n            while longest_postfix_i > 0\n       \
    \         longest_postfix_i -= 1\n                \n            # Add reversed\
    \ prefix of string i to end of new palindrome\n            string = string + string[longest_postfix_i-1:longest_postfix_j]\n\
    \            \n            # Check if we have found longest postfix so far\n \
    \           if i > longest_postfix_i\n                # If the current longest\
    \ postfix is the same length as the previous longest postfix,\n              \
    \  # ignore the current prefix since it is no longer a palindrome\n          \
    \      if longest_postfix_j == i\n                    continue \n            \
    \    \n                # Find the longest postfix that has length (longest_postfix_i-1)+1\
    \ at position i\n                longest_postfix_j = i + 1\n                while\
    \ longest_postfix_j < (i+(longest_postfix_i-1))\n                    longest_postfix_j\
    \ += 1\n                \n                # Add reversed prefix of string i to\
    \ end of new palindrome\n                string = string + string[longest_postfix_i-1:longest_",
  "    longest = find_longest_palindrome(string)\n    if longest == 0\n        return\
    \ string\n    prefix = string[0 : longest]\n    reverse = string[-longest::]\n\
    \    suffix = string[-longest + 1 .. length(string) - 1]\n    append!(suffix,\
    \ reverse)\n    append!(prefix, suffix)\n    return prefix\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\nHere's a possible implementation in Julia:\n<code>", "   \n   \
    \ # Make an empty string \n    palindrome = \"\"\n    \n    # Find longest postfix\
    \ of string that is a palindrome and append it to palindrome\n    prefix_length\
    \ = len(string) - find_longest_palindrome_prefix(string)\n    palindrome += string[prefix_length..]\n\
    \    \n    # Find reverse of string prefix that comes before the longest palindromic\
    \ suffix\n    reverse_prefix_start = prefix_length + find_longest_palindrome_suffix(string)\n\
    \    reverse_prefix_end = reverse_prefix_start - 1\n    reverse_prefix_string\
    \ = string[reverse_prefix_start..]\n    \n    # Append reverse of the string prefix\
    \ that comes before the longest palindromic suffix \n    palindrome += reverse_prefix_string\n\
    \    \n    return palindrome", "\"\"\"\n    >>> make_palindrome(\"cat\")\n   \
    \ \"catac\"\n    >>> make_palindrome(\"cata\")\n    \"catac\"\n\"\"\"\n    return\
    \ string.replace(\" \", \"\")\\\n             .replace(string[::-1], \"\").replace(string[::-1].capitalize())\n\
    </code>\n<|/ a tags=performance,python,algorithm |>\n<| c |>\nWhy are you doing\
    \ `string.replace(\" \", \"\")`? You just set it back to that value which you\
    \ had before. `string.replace` doesn't modify anything, it returns a new string.\n\
    <|/ c |>\n<| c |>\nI didn't know that `string.replace` doesn't modify the input\
    \ string in Python\n<|/ c |>\n<| a tags=performance,python,algorithm dscore=3\
    \ |>\nI ran this on a 1000-word corpus (http://blog.codinghorror.com/your-program-crashed-why-does-it-happen/).\
    \ It took 13 seconds. I suspect the bug is that you're doing multiple replace\
    \ operations on the same string. \nThe second replace call tries to remove all\
    \ the characters from the first replace call, but since the string only has one\
    \ character left, nothing is removed (and nothing is replaced either).\n<code>\n\
    def make_palindrome(string):\n    newstring = \"\"\n    string  = string.replace(\"\
    \ \", \"\")\n    string  = string.replace(string[::-1], \"\")\n    string  = string.replace(string[::-1].capitalize())\n\
    \    newstring += string\n    return newstring\n</code>\n<|/ a |>\n<| c |>\nIf\
    \ it were a bug, you wouldn't get an output for make_palindrome(\"cata\") because\
    \ of the last `string.replace(string[::-1].capitalize())`. And that's a correct\
    \ output, the word \"cat\" has two characters and should be transformed to \"\
    cata\".\n<|/ c |>\n<| c |>\nWell, yes, I didn't think to test that. Thanks for\
    \ your help.\n<|/ c |>\n<| a tags=performance,python,algorithm |>\nI saw your\
    \ solution and thought I should give my solution a go (since I love Python) and\
    \ benchmark it against the other answers. So I wrote my own benchmarking code\
    \ for comparing different solutions given here. \n<code>\n# Solutions\ndef palindrome(s):\n\
    \    \"\"\" Find the shortest palindrome that begins with a supplied string.\n\
    \    Algorithm idea is simple:\n    - Find the longest postfix of supplied string\
    \ that is a palindrome.\n    - Append to the end of the string reverse of a string\
    \ prefix that come", "    \"\"\"If string is empty return empty string\"\"\"\n\
    if string == \"\"\n    \"\"\nelse\n    \"\"\"Find the longest postfix of supplied\
    \ string that is a palindrome.\n    Algorithm idea is simple:\n    - Find the\
    \ longest postfix of supplied string that is a palindrome.\n    - Append to the\
    \ end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    - Start with first character of the string\n    - If the first\
    \ character of the string is equal to the last character of the string, return\
    \ the first character of the string.\n    - If not, then reverse the string\n\
    \    - Go to step 2\n    \"\"\"\n    longest_postfix_string::String = find_longest_postfix(string)\n\
    \    longest_postfix_string::String = longest_postfix_string[::-1]\n    \n   \
    \ if longest_postfix_string == string\n        return string\n    else\n     \
    \   prefix_string = string[0:longest_postfix_string]\n        new_string = prefix_string\
    \ + longest_postfix_string\n        return new_string\n    \n\"\"\"Find the longest\
    \ postfix that is a palindrome of a string.\nAlgorithm idea is simple:\n- Start\
    \ with first character of the string.\n- If the first character of the string\
    \ is equal to the last character of the string, return the first character of\
    \ the string.\n- If not, then reverse the string.\n- Go to step 2\n\"\"\"", " \
    \   if string == \"\"\n        \"\"\n    else\n        longestPalindrome = longestPalindrome(string(length(string)))\n\
    \        string(length(string) - longestPalindrome) + string(longestPalindrome)\n\
    \    end\nend", "    \"\"\"\n    Finds the longest palindrome of supplied string.\n\
    \    \"\"\"\n    if string == \"\"\n        return string\n    prefix = 0\n  \
    \  longest = 0\n    for pos in range(1,length(string, 1))\n        # print prefix,\
    \ string[prefix-1:pos-1], reverse string[pos:pos+longest]\n        if string[prefix-1:pos-1]\
    \ == reverse string[pos:pos+longest]\n            longest = pos\n            prefix\
    \ = pos + 1\n    return string[prefix-1:longest]\n</code>\n<|/ a tags=algorithm,string,haskell\
    \ dscore=3 |>\n<| a |>\nHere's a solution in Haskell that works with strings of\
    \ any length:\n<code>\nshortestPalindrome :: String -> String\nshortestPalindrome\
    \ str = if length(str) == 0 || str == reverse str then str else shortestPalindrome\
    \ (reverse str)\n</code>\nIt's recursive: it checks the first character and recurses\
    \ on the rest of the string, then checks the second character and recurses on\
    \ the rest of the string, and so on. When it gets to the end of the string, it\
    \ checks the rest of the string again and recurses.\nIt's not tail recursive,\
    \ so it will blow up the stack when called on large strings. But it's not too\
    \ bad in terms of the algorithmic complexity. With most strings of length 1, the\
    \ recursion depth is about log(n), so the recursion should be fairly linear and\
    \ pretty efficient.\n<|/ a tags=algorithm,string,haskell dscore=2 |>\n<| c |>\n\
    This also has a `StackOverflow` on `shortestPalindrome \"abcde\"`.\n<|/ c |>\n\
    <| c |>\nYes, it would blow the stack up on large strings. I'll add that to my\
    \ answer.\n<|/ c |>\n<| a tags=algorithm,string,haskell dscore=1 |>\nHere's a\
    \ tail-recursive solution in Haskell, that works for strings of any length:\n\
    <code>\npalindromeStart :: String -> String\npalindromeStart str = reverse (concatMap\
    \ reverse (str `span` str))", "    # check argument\n    if string == \"\"\n \
    \       return \"\"\n    # make palindrome\n    length::Int = string.len()\n \
    \   if length == 1\n        return string\n    middle::Int = length // 2\n   \
    \ first::String = string[1:middle]\n    second::String = string[middle::]\n  \
    \  first::String = reverse(first)\n    second::String = reverse(second)\n    result\
    \ := first + second\n    return result\n</code>\n<|/ a tags=algorithm,python dscore=0\
    \ |>\n<| c |>\nCould you please add some explanation to your answer?\n<|/ c |>\n\
    <| a tags=algorithm,python |>\nHere is another solution that uses functions to\
    \ do the work:\n<code>\ndef make_palindrome(string):\n    if len(string) < 2:\n\
    \        return string", "    longest_palindrome = string\n    max_length = 0\n\
    \    for length in 0:string.length-1\n        if string == reverse(longest_palindrome):\n\
    \            max_length = length\n            longest_palindrome = reverse(longest_palindrome)\n\
    \    if max_length < string.length\n        longest_palindrome = longest_palindrome\
    \ + reverse(string[max_length])\n    return longest_palindrome\n</code>\n<|/ a\
    \ tags=algorithm,palindrome,python-3.x,python |>\n<| a dscore=1 |>\n<code>\ndef\
    \ make_palindrome(string):\n    string = string[::-1]\n    string1 = string[string.index(\"\
    a\"):]\n    return string1+string\n</code>\n<|/ a tags=algorithm,palindrome,python-3.x,python\
    \ |>\n<| a tags=algorithm,palindrome,python-3.x,python |>\nHere is a solution\
    \ that I believe is the simplest and is easy to understand:\n<code>\ndef make_palindrome(string):\n\
    \    original = string[::-1]\n    if original == string:\n        return original\n\
    \    else:\n        return string + original\n</code>\nThe reason why I used the\
    \ \"reverse()\" function is because this string type has built-in function named\
    \ \"reverse()\". The function reverses the string, and returns the reversed string.\
    \ \nAfter that, I compared the original string (which is reversed) with the original\
    \ string. If the original string and the original reversed string are the same,\
    \ the function returns it. If the original string and the original reversed string\
    \ are different, the function returns the original reversed string appended to\
    \ original string.\n<|/ a dscore=0 |>\n<| c |>\nIf you add some explanation it\
    \ would be helpful to others to understand what your code does. As of now it looks\
    \ like a code only answer.\n<|/ c |>\n<| c |>\nYes, I will try to do that in a\
    \ few minutes\n<|/ c |>\n<| a |>\n<code>\ndef make_palindrome(string):\n   revString\
    \ = \"\"\n   for index, char in enumerate(string):\n      revString += char\n\
    \      if index != len(string) - 1:\n         revString += string[index]\n   if\
    \ string == revString:\n      return string\n   return string + revString\n</code>\n\
    <|/ a tags=algorithm,palindrome,python-3.x,python dscore=0 |>\n<| c |>\nWhile\
    \ this code may solve the question, [including an explanation](//meta.stackexchange.com/q/114762)\
    \ of how and why this solves the problem would really help to improve the quality\
    \ of your post, and ", "    if string == \"\"\n        return string\n    max_length\
    \ = 0\n    max_suffix = 0\n    \n    if string[max_length] == string[-max_length]\n\
    \        max_length += 1\n    \n    for i from max_length to 1 by -1\n       \
    \ \n        substring = string[max_length-i..-1]\n        \n        if substring\
    \ == reverse(substring)\n            \n            string = string[0..max_length-i-1]\
    \ + reverse(substring) + string[max_length-i..-1]\n            \n            if\
    \ string.length == max_length\n                return string\n            \n \
    \       end\n    end\nend\n</cell>\n<code language=julia-1.0>\n\"\"\" Find the\
    \ longest palindrome in a sequence of strings.\n    Algorithm idea is simple:\n\
    \    - Find the longest palindrome among all strings present in the sequence.\n\
    \    - If there are multiple palindromes, we choose the one that starts with the\
    \ prefix of the longest palindrome.\n\"\"\"", "    if length(string) == 0 return\
    \ \"\"\n    chars := split(string, \"/\")\n    longest := length(split(string,\
    \ \"/\"))\n    prefix := \"\"\n    for char in chars do\n        if char == chars[length(chars)-1]\
    \ do\n            prefix += char\n            chars.pop()\n        else return\
    \ \"\"\n    string := prefix ++ reverse(join(chars))\n    string\nend\n</cell>\n\
    <code language=julia-1.5>\nhelp(make_palindrome)\n</cell>\n<text>\nThe solution\
    \ of the problem is very simple.", "    if string==\"\" then return string\n \
    \   \n    length=string.length()\n    palindrome=string\n    \n    # Find the\
    \ postfix palindrome of the string\n    for i in 0 until length-2 do\n       \
    \ if string[i..length+i]==string[i+1 ..length] then \n            palindrome=palindrome[i..length+i]\n\
    \            break\n    \n    # Add the reverse of the prefix to the end of the\
    \ string\n    \n    for i in 0 until length-2 do\n        if i==0 then\n     \
    \       palindrome=palindrome[..i]+string[length..length+i][..i]+string[length..length+i]\n\
    \        else\n            palindrome=palindrome[..i]+string[length..length+i]\n\
    \    end\n    return palindrome\nend\n</cell>\n<text>\nThe next few functions\
    \ help us visualize how different parts of the algorithm work. First we define\
    \ a function which takes a string and returns the string in reverse order, along\
    \ with a colour associated with each letter. We use these colours to highlight\
    \ different parts of the string.", "    leftmost_suffix = string.substring (0,\
    \ string.lastIndexOf (string.reverse (string))) \n    leftmost_suffix = leftmost_suffix.reverse\
    \ () \n    return string + leftmost_suffix \nend \n</cell>\n<code language=julia-1.1>\n\
    make_palindrome(\"\")\n</cell>\n<code language=julia-1.1>\nmake_palindrome(\"\
    cat\")\n</cell>\n<code language=julia-1.1>\nmake_palindrome(\"cata\")\n</cell>\n\
    <text>\nExercise 3 - Longest Palindromic Substring\nFind the longest palindromic\
    \ substring of a string consisting entirely of letters.", "\"\"\"\nFind the shortest\
    \ palindrome that begins with a supplied string.\nAlgorithm idea is simple:\n\
    - Find the longest postfix of supplied string that is a palindrome.\n- Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n\"\"\"\n    return string", "    if string == \"\"\n        return\
    \ \"\"\n    end = get_first_palindrome_length(string, string.length - 2)\n   \
    \ begin := get_first_palindrome_length(string, end - 1)\n    return string ++\
    \ reverse(string(begin .. end))\nend\n</code>\n<|/ a tags=palindrome,julia |>\n\
    <| a tags=palindrome,julia |>\nA palindrome is a word that reads the same backwards\
    \ and forwards. \nThere are plenty of easy ways to determine if a string is a\
    \ palindrome:", "    if string.length == 0\n        \"\"\n    else\n        string.substring(0,\
    \ string.length - 1).append(make_palindrome(string.substring(string.length - 1,\
    \ string.length))) \n    end\nend\n</code>\n<|/ a tags=palindrome,string,ruby\
    \ |>\n<| c |>\nThanks for the great answer, it helped me understand how `substring`\
    \ works.\n<|/ c |>\n<| c |>\nCould you show how to use your function with `'abcde'`?\n\
    <|/ c |>\n<| c |>\n: Yes, see my edit.\n<|/ c |>\n<| c |>\n, your function can\
    \ use more memory in some cases, since it has to build a full copy of `string`.\n\
    <|/ c |>\n<| c |>\n, for that case I think it would be better to reverse string\
    \ and check it again. Since building a full copy in other case can slow down algorithm.\
    \ Of course it depends on the case, though.\n<|/ c |>\n<| a |>\nHere is a solution\
    \ that is written in Python and uses no intermediate storage at all:\n<code>\n\
    def is_palindrome(string):\n  n = len(string)\n  for i in range(n/2):\n    if\
    \ not string[i] or not string[n-i-1]:\n      return False\n  return string[n/2:]\
    \ == string[:n/2][::-1]\n</code>\n<|/ a tags=palindrome,string,ruby dscore=4 |>\n\
    <| c |>\nIt took me a while to understand that, but after reading the solution,\
    \ I really liked it. :-) The `n/2` was tripping me up. Thanks for clearing that\
    \ up!\n<|/ c |>\n<| c |>\nYes, I came up with a very similar solution to this,\
    \ but was struggling to come up with the correct solution.  Thanks for this!\n\
    <|/ c |>\n<| a dscore=4 |>\nHere is my Ruby solution:\n<code>\ndef palindrome?(str)\n\
    \  str.chars.sort.join.reverse.eql?(str)\nend\n</code>\n<|/ a tags=palindrome,string,ruby\
    \ |>\n<| c |>\n`str.chars.sort.reverse.join` would work too, and is more efficient,\
    \ though more cryptic.\n<|/ c |>\n<| c |>\nThanks, this answer has helped me understand\
    \ why some of the other solutions didn't.\n<|/ c |>\n<| c |>\nThat's because `sort`\
    \ sorts the characters alphabetically, but this question ", "    str = reverse(string)\n\
    \    return string ++ str\nend", "    if is_palindrome(string)\n        return\
    \ string\n    longest = palindrome_suffix(string)\n    append = reverse . palindrome_prefix(longest)\n\
    \    prepend =\n    return prepend ++ append\nend make_palindrome\n</code>\nSolution\
    \ 2\nThis solution requires two passes over the strings. The first pass determines\
    \ when the string is no longer a palindrome; if the test is successful, we can\
    \ stop the loop; otherwise, we have to loop until we find a palindrome that can\
    \ be reversed. The second pass appends the palindrome suffix and reverses the\
    \ prefix.\n<code>", "    if string == \"\"\n        return \"\"\n    else if string\
    \ == reverse(make_prefix(string))\n        return reverse(make_prefix(string))\n\
    \    else\n        return make_prefix(string) + reverse(make_suffix(string))\n\
    end", "\"\"\"Make palindrome from string with base case\"\"\"\n    # Base case\n\
    \    if length(string) <= 1\n        return string", "    # Your code here\n \
    \   string <- string\n    string <- reverse(string_slice(string,1,string_length(string)))\n\
    \    reverse(string_slice(string,0,string_length(string)))\nend", "  if string\
    \ == \"\"\n    return string\n  max_length = 0\n  min_length = 0\n  while min_length\
    \ <= max_length\n    max_length += 1\n    while max_length <= min_length\n   \
    \   min_length += 1\n      while min_length <= max_length\n        max_length\
    \ += 1\n        while max_length <= min_length\n          min_length += 1\n  \
    \        while min_length <= max_length\n            max_length += 1\n       \
    \   end\n        end\n      end\n    end\n  end\n  if min_length == max_length\n\
    \    return string\n  end", "    str = string.dup\n    len = length(str) - 2\n\
    \    for i=len:-1,1:-1 do str = replace(str,str[i],str[len-i],1)\n    str = replace(str,str[1],str[len-2],1)\n\
    \    str = replace(str,str[0],str[len-1],1)\n    return str\nend function\n</code>\n\
    <|/ a tags=string,algorithm,palindrome,julia dscore=1 |>\n<| a tags=string,algorithm,palindrome,julia\
    \ dscore=0 |>\nAnother approach is to use the palindrome module which I wrote:\n\
    <code>\nusing Palindrome", "    # Your code goes here\n    if string == \"\"\n\
    \        \n        return \"\"\n    else\n        \n        postfix = \"\"\n \
    \       \n        string_length = string.length()\n        \n        for i in\
    \ 0 .. string_length-1\n            \n            postfix = string + postfix\n\
    \            \n            if string == postfix.reverse()\n                \n\
    \                string = postfix.reverse()\n                \n              \
    \  return string\n            \n            \n    return \"\"", "  # write your\
    \ code here\n  if string == \"\"\n    return \"\"\n  \n  new_string = string\n\
    \  \n  while length(new_string) > 1 \n    if new_string[0] == new_string[length(new_string)-1]\n\
    \      return new_string\n    else \n      new_string = new_string[1:length(new_string)-1]\n\
    \  end\nend\n</cell>\n<code language=julia-1.5>", "    \"\"\"\n    >>> make_palindrome(\"\
    \")\n    \"\"\n    >>> make_palindrome(\"cat\")\n    \"catac\"\n    >>> make_palindrome(\"\
    cata\")\n    \"catac\"\n    \"\"\"", "    if string == \"\"\n        return \"\
    \"\n    \n    max_length = 1\n    postfixes = string.chars\n    \n    while max_length\
    \ < max_length\n        new_max_length = max_length + 2\n        \n        for\
    \ postfix_i = postfixes.last\n            palindrome_suffixes = string.chars.drop(postfix_i\
    \ - max_length)\n            for palindrome_suffix in palindrome_suffixes\n  \
    \              postfix_i = postfix_i-1\n                \n                if palindrome_suffix\
    \ != postfix_i\n                    break\n                \n                if\
    \ palindrome_suffix == postfix_i\n                    new_max_length = max_length\n\
    \                \n        max_length = new_max_length\n    end\n    \n    \n\
    \    return string[max_length...]\nend", "    string_length = len(string)\n  \
    \  max_length = string_length - 1\n    prefix = string[1:max_length]\n    postfix_reversed\
    \ = string[(max_length-1)::-1]\n    return postfix_reversed + prefix\nend\n</cell>\n\
    <code language=julia-1.0>\n\"\"\"\n# Create a palindrome\n\"\"\"", "    if string==\"\
    \"\n        \"\"\n    else\n        length = string.length\n        max_length\
    \ = 0\n        for i from length-1 downto 1\n            if string[i]==string[length-i-1]\n\
    \                max_length = length-i\n                break\n            else\n\
    \                max_length = max_length\n        first = \"\"\n        last =\
    \ string[length-1]\n        middle = string[(length-1)..length]\n        \n  \
    \      return first+string[length-1]+middle+string[1..length]+last\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nI dont understand this at all. Where is the definition\
    \ of 'prefix'? What does 'string' mean? What does 'palindromic suffix' mean? How\
    \ does this compare to the solution above?\n<|/ c |>\n<| c |>\nIn case anyone\
    \ is interested, this solution was based on the answer provided to this question:\
    \ http://stackoverflow.com/questions/3355372/python-code-for-finding-the-substring-palindrome\n\
    <|/ c |>\n<| a tags=palindrome,string,haskell,algorithm dscore=2 |>\nHere's a\
    \ Haskell version:\n<code>\nimport Data.List\nimport Data.Maybe", "    if is_palindrome(string)\
    \ == false then \n        return string\n    else\n        max_length = 0\n  \
    \      max_length = length(longest(string, max_length))\n        max_length =\
    \ length(longest(string, max_length))\n        max_length = length(longest(string,\
    \ max_length))\n        max_length = length(longest(string, max_length))\n   \
    \     max_length = length(longest(string, max_length))\n        max_length = length(longest(string,\
    \ max_length))\n        max_length = length(longest(string, max_length))\n   \
    \     return substring(string, 0, max_length)\n    endif\nendfunction\n\"\"\"\n\
    Check if string is a palindrome or not.\nAlgorithm idea is simple:\n- Find the\
    \ longest postfix of supplied string that is a palindrome.\n- Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    >>> is_palindrome(\"\")\nfalse\n>>> is_palindrome(\"cat\")\ntrue\n>>> is_palindrome(\"\
    cata\")\nfalse\n\"\"\"", "    if is_palindrome(string):\n        return string\n\
    \    else\n        longest_suffix = longest_palindrome_suffix(string)\n      \
    \  left_substring = left_substrings(string).length\n        right_substring =\
    \ left_substrings(string).length\n        reversed_string = reverse(string)\n\
    \        if left_substring == right_substring:\n            append!(string, longest_suffix)\n\
    \            append!(string, string.reverse(reversed_string))\n            return\
    \ string\n        else\n            append!(string, longest_suffix)\n        \
    \    append!(string, string.reverse(reversed_string))\n            longest_prefix\
    \ = longest_palindrome_prefix(string)\n            append!(string, longest_prefix)\n\
    \            return make_palindrome(string)\n        end\n    end\nend\n</code>\n\
    Note that this implementation does only work for empty strings (i.e. \"\", \"\"\
    \ and \"\") and palindromes of length less than or equal to 1 (i.e. \"A\", \"\
    A\", \"A\", \"A\").\n<|/ a |>\n<| a tags=string,algorithm,palindrome,julia |>\n\
    This was an interview question I was asked. Although it's not the most efficient\
    \ solution, here is what I came up with. It works for single character palindromes,\
    \ double, triple character palindromes, quadruple, etc, up to 100 characters.\n\
    It works by checking if the reverse of the string is the string itself, if not\
    \ it checks if the reverse of the string is the reverse of the string, if the\
    \ reverse of the string is the reverse of the reverse...\n<code>", "     return\
    \ string + reverse(string.take(string.size - string.find_first(character::Char)))\
    \ \nend \n</cell>\n<text>\nHere the reverse function is very similar to the  function\
    \ in Julia. In fact, the reverse function can be easily written as:", "    string\
    \ == \"\" \n        ? string \n        : make_palindrome_aux(string,0,string.length-1,string.length)\n\
    end\n\"\"\"\n    Find the shortest palindrome that begins with a supplied string.\n\
    \    Algorithm idea is simple:\n    - Find the longest postfix of supplied string\
    \ that is a palindrome.\n    - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    Works O(n^2) time complexity\
    \ (so for long strings, it'll take a while).\n    O(n) time complexity and O(n)\
    \ space complexity.\n    >>> make_palindrome(\"\")\n    \"\"\n    >>> make_palindrome(\"\
    cat\")\n    \"catac\"\n    >>> make_palindrome(\"cata\")\n    \"catac\"\n    \"\
    \"\"", "    palindrome = \"\"\n    l = length(string)\n    if l == 0 or l == 1\n\
    \        return string\n    elseif l > 1\n        for i = 0 to l - 1\n       \
    \     prefixstring = string[i..(l - i)]\n            if prefixstring == reverse(prefixstring)\n\
    \                palindrome = palindrome + prefixstring\n            else\n  \
    \              break\n        end\n    end\n    return palindrome\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\nHere is a solution from my blog post: Palindrome algorithm\n\
    It works in O(n) time where n is length of the string\n<code>", "    if string.length\
    \ == 0 \n        \"\" \n    else \n        prefix <- string.reverse()\n      \
    \  palindrome_suffix <- findSuffix(string,prefix,0)\n        make_palindrome(prefix++palindrome_suffix)\
    \ \n    end\nend\n</cell>\n<code language=julia-1.1>", "    # return string if\
    \ string has 1 character\n    if length(string) == 1 \n        return string\n\
    \    # find longest palindrome\n    longest_palindrome = find_longest_palindrome(string)\n\
    \    # add it to end of the string\n    string += reverse (string prefix longest_palindrome)\n\
    \    return string\n</code>\n<|/ a dscore=2 tags=algorithm,string,palindrome,recursion\
    \ |>\n<| c |>\nThe algorithm works for strings with more than one character in\
    \ them. But for an empty string it gives the wrong result. For example, the algorithm\
    \ should work for \"abcdef\" but for \"\" the result is \"abcde\".\n<|/ c |>\n\
    <| a dscore=2 |>\nPython Solution\n<code>\ndef palin_str(s):\n    if len(s) ==\
    \ 1:\n        return s\n    a = s[:len(s)//2]\n    b = s[len(s)//2:]\n    l =\
    \ len(s)\n    k = len(a)\n    while l < k:\n        if a[-k:] == b[:l]:\n    \
    \        a = a[::-1]\n            l = len(a)\n        else:\n            l +=\
    \ 1\n    return a + b\n</code>\n<|/ a tags=algorithm,string,palindrome,recursion\
    \ |>\n<| a dscore=1 tags=algorithm,string,palindrome,recursion |>\nHere is a recursive\
    \ solution in Python:\n<code>\ndef palindrome(string):\n    if string == \"\"\
    \ or len(string) < 2:\n        return True", "    \"\"\"\n    >>> make_palindrome(\"\
    \")\n    \"\"\n    >>> make_palindrome(\"cat\")\n    \"catac\"\n    >>> make_palindrome(\"\
    cata\")\n    \"catac\"\n    \"\"\"\n    if is_palindrome(string):\n        return\
    \ string\n    elif len(string) < 2:\n        return string\n    else:\n      \
    \  left = string[:len(string)//2]\n        right = string[len(string)//2:]\n \
    \       return left + make_palindrome(right[::-1])\n</code>\n<|/ a tags=performance,python,string\
    \ dscore=0 |>\n<| a dscore=0 |>\n<code>\ndef palindrome(str1):\n    str1 = str1.lower()\n\
    \    str1 = str1.replace(' ', '')\n    str1 = str1.replace(',', '')\n    str1\
    \ = str1.replace('.', '')\n    str1 = str1.replace('!', '')\n    str1 = str1.replace('?',\
    \ ' ')\n    str1 = str1.replace('_', '')\n    str1 = str1.replace(':', '')\n \
    \   str1 = str1.replace(';', '')\n    str1 = str1.replace(':', '')\n    str1 =\
    \ str1.replace(',', '')\n    str1 = str1.replace(' ', '')\n    str1 = str1.replace('/',\
    \ '')\n    str1 = str1.replace(':', '')\n    str1 = str1.replace(':', '')\n  \
    \  str1 = str1.replace(':', '')\n    str1 = str1.replace(':', '')\n    str1 =\
    \ str1.replace(':', '')\n    str1 = str1.replace(':', '')\n    str1 = str1.replace(':',\
    \ '')\n    str1 = str1.replace(':', '')\n    str1 = str1.replace(':', '')\n  \
    \  str1 = str1.replace(':', '')\n    str1 = str1.replace(':', '')\n    str1 =\
    \ str1.replace(':', '')\n    str1 = str1.replace(':', '')\n    str1 = str1.replace(':',\
    \ '')\n    str1 = str1.replace(':', '')\n    str1 = str1.replace(':', '')\n  \
    \  str1 = str1.replace(':', '')\n    str1 = str1.replace(':', '')\n    str1 =\
    \ str1.replace(':', '')\n    str1 = str1.replace(':', '')\n    str1 = str1.replace(':',\
    \ '')\n    str1 = str1.replace(':', '')\n    str1 = str1.replace(':', '')\n  \
    \  str1 = str1.replace(':', '')\n    str1 = str1.replace(':', '')\n    str1 =\
    \ str1.replace(':', '')\n    str1 = str1.replace(':', '')\n    str1 = str1.replace(':',\
    \ '')\n    str1 = str1.replace(':', '')\n    str1 = str1.replace(':', '')\n  \
    \  str1 = str1.replace(':', '')\n    str1 = str1.replace(':', '')\n    str1 =\
    \ str1.replace(':', '')\n    str1 = str1.replace(':', '')\n    str1 = ", "   \
    \ # Code goes here\n    ", "    left,right,length =  \"\",\"\",0\n    for c in\
    \ string\n        if c == 'a'\n            left++\n        else\n            right++\n\
    \        length = length + 1 \n    return left+right+string[length]\nend\n</code>\n\
    <|/ a tags=string,lua,algorithm dscore=1 |>\n<| c |>\nThanks for the answer. I'm\
    \ not entirely sure this works.\nWhat is the \"string::String\" for? \nAnd how\
    \ do I implement this function?\n<|/ c |>\n<| c |>\n\"string::String\" is syntax\
    \ for using \"string\" as variable name as opposed to just \"string\". As for\
    \ implementation, I just copied your function and ran it. It worked fine.\n<|/\
    \ c |>\n<| c |>\nOk, this works. I just had to change \"length++\" to \"length\
    \ = length + 1\" and change \"string = string[length]\" to \"string = string[length-1]\"\
    \ to make it work for me.\n<|/ c |>\n<| c |>\nYou're right, I forgot to add the\
    \ index number. I've corrected the code.\n<|/ c |>\n<| a dscore=1 |>\nHere is\
    \ my Python version (the answer from Nelson Ramirez):\n<code>\ndef make_palindrome(string):\n\
    \    string = string[::-1]\n    length = len(string)\n    i = 0\n    while i <\
    \ length - 1:\n        if string[i:i+2] != string[i:i+2+length]:\n           \
    \ break\n        i += 1\n    return string[:i]", "    \"\"\"\n    Find the shortest\
    \ palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n\
    \    - Find the longest postfix of supplied string that is a palindrome.\n   \
    \ - Append to the end of the string reverse of a string prefix that comes before\
    \ the palindromic suffix.\n    \"\"\"\n    return reverse(string.substring(1))\
    \ + string.substring(1)\n</code>\n<|/ a tags=string,algorithm,python,reverse |>\n\
    <| c |>\nThanks for your answer, but what is the purpose of reverse in the above\
    \ code? And also can you elaborate what \"longest postfix of supplied string\"\
    \ is?\n<|/ c |>\n<| c |>\nThe purpose of the reverse function is to remove the\
    \ first character from the string, in this case it would be \"cat\". Longest postfix\
    \ is how we identify \"cat\" is the longest (longest postfix) postfix of \"cat\"\
    , which would be \"ca\".\n<|/ c |>\n<| c |>\nYou don't need to reverse the string\
    \ as long as you keep track of the character at the end that you added the original\
    \ string to.\n<|/ c |>\n<| c |>\nYes, but that would be the case if I was using\
    \ just the first character of the string, which was the original string without\
    \ the reversed prefix. I'm essentially using the reverse() function in order to\
    \ find the longest postfix of supplied string.\n<|/ c |>\n<| c |>\nYes, you are\
    \ right in that the above function assumes the input is a palindrome (all characters\
    \ same length and are the same in both ends), but that doesn't mean it would be\
    \ a good approach for a non-palindromic input, such as \"catdog\"\n<|/ c |>\n\
    <| a dscore=1 |>\nThe following code will find all the palindrome from a list\
    \ passed as argument:\n<code>\ndef palindromes(words):\n    palindromes = []\n\
    \    for word in words:\n        if len(word) == 0 or word == word[::-1]:\n  \
    \          palindromes.append(word)\n        else:\n            for palindrome\
    \ in palindromes(words[1:]):\n                if palindrome[::-1] == word:\n \
    \                   palindromes.append(word)\n                    break\n    return\
    \ palindromes\n</code>\nExample\n<code>\npalindromes([\"cat\", \"catdog\", \"\
    dogcat\", \"abba\", \"abbac\", \"acaba\", \"cacab\"])\n</code>\nOutput\n<code>\n\
    ['cat', 'catdog', 'abba', 'cacab']\n</code>\n<|/ a tags=string,algorithm,python,reverse\
    \ |>\n<| a d", "   \"\"\"\n   Find the shortest palindrome that begins with a\
    \ supplied string.\n   Algorithm idea is simple:\n   - Find the longest postfix\
    \ of supplied string that is a palindrome.\n   - Append to the end of the string\
    \ reverse of a string prefix that comes before the palindromic suffix.\n   >>>\
    \ make_palindrome(\"\")\n   \"\"\n   >>> make_palindrome(\"cat\")\n   \"catac\"\
    \n   >>> make_palindrome(\"cata\")\n   \"catac\"\n   \"\"\"\n   reverse_string\
    \ = \"\"\n   for i in string:\n       reverse_string += string[len(string) - 1\
    \ - i]\n   return reverse_string", "    #! find longest palindrome that begins\
    \ with string\n    #! Algorithm", "    #1\n    # find the longest palindrome\n\
    \    #2\n    # reverse the string before that postfix palindrome\n    #3\n   \
    \ # reverse the palindrome and append\n    #4\n    # return string\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\nA recursive function will be more efficient.\n<code>\n\
    def make_palindrome(str, i=0, j=str.length - 1)\n  if i == j\n    return str\n\
    \  elsif str[i] != str[j]\n    return str\n  else\n    return make_palindrome(str,\
    \ i + 1, j)\n  end\nend\n</code>\n<|/ a tags=algorithm,ruby dscore=0 |>\n<| a\
    \ tags=algorithm,ruby |>\n<code>\ndef make_palindrome(str)\n  str.length <= 1\
    \ ? \"#{str}\" : \n    str.chars.each_cons(2).reverse_each.join\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\n def make_palindrome(str)\n    if\
    \ str.length < 2\n      str\n    elsif str[0] == str[str.length-1]\n      str\n\
    \    else\n      \"#{str[0]}#{str[1..-1].reverse}\"\n    end\n  end\n</code>\n\
    <|/ a tags=algorithm,ruby |>\n<| a |>\nA simple recursive method -\n<code>\ndef\
    \ make_palindrome(string)\n    string = string.dup\n    return string if string.length\
    \ < 2\n    string.slice!(0..string.length/2)\n    string.slice!(0..string.length/2)\n\
    \    string.reverse!\n    string + make_palindrome(string)\nend\n</code>\n<|/\
    \ a dscore=0 tags=algorithm,ruby |>\n<| a |>\n<code>\ndef make_palindrome(str)\n\
    \  if str.empty?\n    return \"\"\n  elsif str.length == 1\n    return str\n \
    \ else\n    return str + make_palindrome(str.slice!(0..(str.length-1)/2)) + str.slice!(0..(str.length-1)/2)\n\
    \  end\nend\n</code>\n<|/ a dscore=0 tags=algorithm,ruby |>\n<| a dscore=0 |>\n\
    <code>\ndef make_palindrome(str)\n    str.each_char.map { |c| c.reverse }.join\n\
    end\n</code>\n<|/ a tags=algorithm,ruby |>\n<| c |>\nWhile this code snippet may\
    \ solve the question", "    max_length = 0\n    for c in string:\n        if c\
    \ > max_length:\n            max_length = c\n    if max_length == 0:\n       \
    \ return string\n    revstring = string[max_length - 1::-1]\n    if revstring\
    \ == string:\n        return string\n    prefix = ''\n    for c in range(max_length):\n\
    \        if c == 0:\n            prefix += string[c]\n            continue\n \
    \       if string[c] != string[c - 1]:\n            break\n        prefix += string[c]\n\
    \    prefix += revstring\n    if prefix != revstring:\n        return make_palindrome(prefix)\n\
    \    return prefix\n</code>\n<|/ a dscore=1 tags=python,recursion,palindrome |>\n\
    <| a dscore=0 |>\n<code>\ndef palindrome(s):\n    string = str(s)\n    if string[0]\
    \ == string[len(string) - 1]:\n        return True\n    else:\n        return\
    \ False\n</code>\n<|/ a tags=python,recursion,palindrome |>\n<| a tags=python,recursion,palindrome\
    \ |>\nMy version using recursion only:\n<code>\ndef isPalindrome(string):\n  if\
    \ string == '':\n    return True\n  if len(string) <= 1:\n    return False\n \
    \ else:\n    return string[len(string)//2:] == string[:len(string)//2][::-1]",
  "    palindrome = \"\"\n    l = length(substrings(string))\n    for i in string.string.substrings(l,2)\n\
    \        postfix = substrings(i).reversed\n        append!(palindrome, postfix)\n\
    \    end\n    palindrome\nend\n</cell>\n<text>\nThe substring function has been\
    \ implemented as a generator for us in the substrings function shown above", " \
    \   if is_palindrome(string)\n        return string\n    beginning_of_palindrome\
    \ = find_longest_postfix(string, :end) == reverse(find_longest_postfix(string,\
    \ :start))\n    \n    string_palindrome = string\n    if beginning_of_palindrome\n\
    \        append!(string_palindrome, find_longest_postfix(string, :end))\n    end",
  "    if string == \"\"\n        return \"\"\n    \n    left_post = reverse(string[1:length(string)-1])\n\
    \    right_post = reverse(string[2:length(string)])\n    \n    if left_post ==\
    \ right_post\n        return string\n    \n    else \n        return string +\
    \ left_post + right_post\nend", "    if is_palindrome(string) == true\n      \
    \  return string\n    else\n        length = len(string)\n        index_of_longest_palindrome\
    \ = 0\n        for i = 0 to length-1\n            substring = string[i:length]\n\
    \            if i == 0 or substring[0] != substring[length-1]\n              \
    \  index_of_longest_palindrome = length\n            else\n                index_of_longest_palindrome\
    \ = i\n            end\n        end\n        return string[index_of_longest_palindrome]+string[index_of_longest_palindrome..-1]\n\
    \    end\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=algorithm,palindrome,string,ruby\
    \ |>\nHere's a solution in Ruby 1.9.3 (which should be the most up-to-date Ruby\
    \ version available):\n<code>\ndef make_palindrome(input)\n  input.split('').sort.reverse.join\n\
    end", "    begin = find(string, \"\")\n    prefix = substring(string, 1, begin\
    \ - 1)\n    postfix = substring(string, begin)\n    suffix =  reverse(postfix)\n\
    \    return prefix + suffix\nend\n</cell>\n<text>\nSolution\nSolution not yet\
    \ ready to run on juypter notebook, but will be soon. Will come back here once\
    \ its done.", "    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n", " \
    \   \n    if string == \"\"\n        \"\"\n    else\n        prefix_palindrome\
    \ = substrings(string, \".\", 1, 1)\n        suffix_palindrome = substrings(string,\
    \ \".\", 0, -1)\n        postfix_palindrome = substrings(string, \".\", 1, 1)\n\
    \        \n        postfix_palindrome = reverseString(postfix_palindrome)\n  \
    \      \n        beginning_palindrome = prefix_palindrome\n        beginning_palindrome\
    \ = reverseString(beginning_palindrome)\n        beginning_palindrome = beginning_palindrome\
    \ + postfix_palindrome\n        \n        ending_palindrome = suffix_palindrome\n\
    \        ending_palindrome = reverseString(ending_palindrome)\n        ending_palindrome\
    \ = ending_palindrome + postfix_palindrome\n        \n        return beginning_palindrome\
    \ + ending_palindrome\n</code>\n<|/ a tags=algorithm,string,python,performance\
    \ dscore=0 |>\n<| a tags=algorithm,string,python,performance |>\nTo find the longest\
    \ palindrome that begins with a supplied string, we can use two pointers, one\
    \ that moves from first character of a string to last character of a string, and\
    \ other that moves from last character to first character of the string.\n<code>\n\
    def longest_palindrome(string):\n    if not string:\n        return \"\"\n   \
    \ \n    left, right = 0, len(string) - 1\n    \n    while left < right:\n    \
    \    middle = (left + right) // 2\n        if string[middle] != string[middle]\
    \ * (string[middle] + 1):\n            right = middle - 1\n        else:\n   \
    \         left = middle + 1\n    \n    return string[left: middle + 1] + string[middle\
    \ + 1 :]", "    length = string.length\n    palindrome = \"\"\n    for i in 0..length-1\
    \ do \n        current = string[i]\n        reverse = reverse(current, length+i)\n\
    \        palindrome = current + reverse + palindrome\n    return palindrome",
  "    string::String\n    if string == \"\"\n        \"\"\n    else\n        if string[0]\
    \ == string[-1]\n            make_palindrome(string[1:length(string)] + string[length(string)-1:1])\n\
    \        else\n            make_palindrome(string[1:length(string)])\n       \
    \ end\n    end\nend\n\"\"\"Find the shortest palindrome that starts with a supplied\
    \ string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    - Remove from the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    >>> make_palindrome(\"\
    \")\n    \"\"\n    >>> make_palindrome(\"cat\")\n    \"cat\"\n    >>> make_palindrome(\"\
    cata\")\n    \"cata\"\n    \"\"\"", "    if string==\"\"\n    then return \"\"\
    \n    elseif string==string::String\n    then return string\n    else\n      \
    \  p <-make_palindrome(string::String)::String\n        if p==\"\"\n        then\
    \ return \"\"\n        elseif p==string::String\n        then return p\n     \
    \   else\n            n <- length(string::String)\n            x <- string::String[n/2]\n\
    \            y <- string::String[(n+1)/2]\n            return x + x + string::String[(n-2)/2]\
    \ + p + string::String[(n+1)/2] + y\n        end\n    end\nend\n</code>\n<|/ a\
    \ |>\n<| a dscore=2 |>\nA more efficient way in Julia is to use the reverse function:\n\
    <code>\njulia> function palindrome(str)\n           if str == reverse(str)\n \
    \              return str\n           else\n               return reverse(str)\
    \ + reverse(str)\n           end\n       end"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
