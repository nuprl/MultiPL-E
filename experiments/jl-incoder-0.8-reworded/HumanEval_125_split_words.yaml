name: HumanEval_125_split_words
language: jl
prompt: "\"\"\"\n    Given a string of words, return a vector of words split on whitespace,\
  \ if no whitespaces exists in the text you\n    should split on commas ',' if no\
  \ commas exists you should return the number of lower-case letters with odd order\
  \ in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n\
  \    >>> split_words(\"Hello world!\")\n    [\"Hello\", \"world!\"]\n    >>> split_words(\"\
  Hello,world!\")\n    [\"Hello\", \"world!\"]\n    >>> split_words(\"abcdef\")\n\
  \    3\n    \"\"\"\nfunction split_words(txt::String)::Union{Vector{String}, Int64}\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = split_words;\n\t@test(candidate(\"\
  Hello world!\") == [\"Hello\", \"world!\"])\n\t@test(candidate(\"Hello,world!\"\
  ) == [\"Hello\", \"world!\"])\n\t@test(candidate(\"Hello world,!\") == [\"Hello\"\
  , \"world,!\"])\n\t@test(candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\"\
  , \"!\"])\n\t@test(candidate(\"abcdef\") == 3)\n\t@test(candidate(\"aaabb\") ==\
  \ 2)\n\t@test(candidate(\"aaaBb\") == 1)\n\t@test(candidate(\"\") == 0)\nend\n"
completions: ["    if isempty(txt)\n        return zeros(0)\n    end\n    wordlist\
    \ = split(txt, \" \")\n    vectorlist = map(x -> lowercase(x), wordlist)\n   \
    \ return join(vectorlist, \" \")\nend", "    word = split(txt, \" \")\n    count\
    \ = count(word)\n    if count == 1 \n        txt = replace(txt, \" \", \"\")\n\
    \        word = split(txt, \",\")\n    end\n    if count < 2\n        return count\n\
    \    end\n    word2 = split(txt, \",\")\n    word3 = split(txt, \" \")\n    count\
    \ = 0\n    letters = count_letters(txt)\n    while count < count\n        if ord(letters[count])\
    \ == ord(word[count]) + ord(word2[count]) + ord(word3[count]) - 3\n          \
    \  count += 1\n        end\n    end\n    return count\nend", "\"\"\"\n    Given\
    \ a string of words, return a vector of words split on whitespace, if no whitespaces\
    \ exists in the text you\n    should split on commas ',' if no commas exists you\
    \ should return the number of lower-case letters with odd order in the\n    alphabet,\
    \ ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    >>> split_words(\"\
    Hello world!\")\n    [\"Hello\", \"world!\"]\n    >>> split_words(\"Hello,world!\"\
    )\n    [\"Hello\", \"world!\"]\n    >>> split_words(\"abcdef\")\n    3\n\"\"\"",
  "    # split the text on whitespace\n    words = txt.split() \n    # if the text\
    \ contains no whitespace return number of letters with odd order\n    if isempty(words)\n\
    \        return length(lower(txt))\n    else\n        return length(filter(x ->\
    \ x.contains(\" \"), words))\n    end\nend", "\"\"\"\n    Given a string, return\
    \ a vector of words split on whitespace, if no whitespaces exists in the text\
    \ you\n    should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n    alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    >>> split_words(\"Hello\
    \ world!\")\n    [\"Hello\", \"world!\"]\n    >>> split_words(\"Hello,world!\"\
    )\n    [\"Hello\", \"world!\"]\n    >>> split_words(\"abcdef\")\n    3\n    \"\
    \"\"\nend", "    words = split(txt, sep=\" \", maxsplit=0)\n    words_split =\
    \ Array{String,1}()\n    for word in words\n        words_split .= split(word,\
    \ sep=',') if length(split(word, sep=',')) == 1 else split(word, sep=',')\n  \
    \  end\n    words_count = zeros(Int, length(words_split))\n    for i,word in enumerate(words_split)\n\
    \        words_count[i] = length(word) \n    end\n    words_vector = zeros(Int64,\
    \ length(words_split))\n    for i,word in enumerate(words_split)\n        words_vector[i]\
    \ = words_count[i]\n    end\n    return words_vector\nend\n</code>\n<|/ a |>\n\
    <| c |>\n`@julia split_words(\"Hello world!\"); length(a)` will give you an error.\
    \ `a` is defined in the function, but `length` is called outside the function.\n\
    <|/ c |>\n<| a tags=vector,julia,concatenation,matrix dscore=2 |>\nYou can use\
    \ concat and hcat in Julia:\n<code>\njulia> a = [1 2 3 4 5 6]\njulia> b = [7 8\
    \ 9 10]\njulia> hcat(a,b)\n11-element Vector{Int64}:\n 7\n 8\n 9\n10\n 6\n 3\n\
    \ 4\n 5\n 2\n 1", "    if length(txt) == 0 \n        return [] \n    elseif all(map(x->(x\
    \ <=> \" \"), txt)) \n        return txt \n    elseif all(map(x->(x <=> \",\"\
    ), txt)) \n        return split(txt, \",\") \n    elseif all(map(x->(x <=> \"\
    \ \") || (x <=> \",\"), txt)) \n        return split(txt, \" \") \n    else \n\
    \        return split(txt, \",\") \n    end\nend\n</code>\n<|/ a |>\n<| a dscore=2\
    \ |>\nHere's a solution that returns a list of words in the text, or an empty\
    \ list if there are no words in the text.\n<code>", "    word_list = split(txt,\
    \ ' ')\n    no_of_words = 0\n    for word in word_list\n        if (len(word)\
    \ == 0)\n            no_of_words += 1\n        else\n            no_of_words +=\
    \ length(word)\n    end\n    if (length(word_list) == 0)\n        no_of_words\
    \ += 1\n    end\n    return no_of_words\nend\n</cell>\n<cell>", "    if all(w\
    \ == \"\" for w in split(txt,\" \"))\n        return split(txt,\",\")\n    else\
    \ \n        return count_letters(split(txt,\" \"))\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\n`count_letters` seems like a much more efficient way to go about\
    \ this as well.\n<|/ c |>\n<| c |>\nYes, indeed. My answer was more to show the\
    \ steps to get there, rather than the cleanest and most efficient way to do it.\n\
    <|/ c |>\n<| a tags=julia |>\nBased on's answer I came up with this code (it could\
    \ be optimised):\n<code>", "\"\"\"\n    Given a string of words, return a vector\
    \ of words split on whitespace, if no whitespaces exists in the text you\n   \
    \ should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n    Examples\n    >>> split_words(\"Hello world!\")\n\
    \    [\"Hello\", \"world!\"]\n    >>> split_words(\"Hello,world!\")\n    [\"Hello\"\
    , \"world!\"]\n    >>> split_words(\"abcdef\")\n    3\n    \"\"\"\n    local split\
    \ = splitter(txt)\n    if isdefined(split)\n        return split\n    else\n \
    \       txt = String(txt)\n        local ws = String[]\n        for i = 1, length(txt)\
    \ do\n            local c = txt[i]\n            push!(ws, c)\n        end\n  \
    \      local n = 0\n        local last\n        for i in ws do\n            local\
    \ c = String(i)\n            if c ~= last\n                n = n + 1\n       \
    \         last = c\n            end\n        end\n        return n\n    end\n\
    end", "    words_vec = vecsplit(split(txt))\n    \n    if isa(words_vec,Int64)\n\
    \        words_vec = Vec(words_vec)\n    elseif words_vec == []\n        words_vec\
    \ = [0]\n    end\n    \n    return words_vec\nend", "    \"\"\"\n    Split a string\
    \ on whitespace or the number of commas ',' or the letter with odd order in the\
    \ alphabet\n    Arguments\n        txt (String): a string\n    Returns\n     \
    \   Vector{String}: a list of words\n        Int64: a int of words \n    \"\"\"\
    \n    if txt === \"\" \n        return [] \n    words_list = split(txt, sep=\"\
    \ ,!?()*&+%\", maxsplit=1000) \n    words = words_list[[1]]\n    words_list =\
    \ words_list[[2]]\n    word_list = split(words_list, sep=\",\", maxsplit=100)\n\
    \    word_list = [x if length(x) == 1 \n                   else \" \" for x in\
    \ word_list]\n    word_list = [x if length(x) == 1 \n                   else ord(x)\
    \ - ord('a') for x in word_list]\n    word_list = [x if x % 2 != 0 \n        \
    \           else \" \" for x in word_list]\n    return word_list\nend\n</cell>\n\
    <text>\nThe third method takes the string and converts it into a vector of strings,\
    \ using the split_words function defined earlier.", "    if isempty(txt)\n   \
    \     return []\n    words = split(txt)\n    if length(words) <= 1\n        return\
    \ words\n    else\n        return words[2 : end]\n    end\nend", "    words::Vector{String}\n\
    \    flag::Bool = true\n    if txt != \"\" \n        words = txt.split(\" \")\n\
    \    else\n        flag = false\n        words = txt\n    end\n    return flag\
    \ ? words : length(words) \nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nWhat happens\
    \ when you assign the return value of `split_words` back to a variable? I mean\
    \ like `words = split_words(input)`\n<|/ c |>\n<| c |>\nI just tried this with\
    \ julia 1.5.2 and it still returns \"nothing\"\n<|/ c |>\n<| a |>\nYou could use\
    \ a regexp to split the text:\n<code>\njulia> s = \"hello world!\"\n\"hello world!\"",
  "    words = split(txt,\" \")\n    nowhitespace = filter(x->not iswhitespace(x),\
    \ words)\n    whitespace = filter(x->iswhitespace(x), words)\n    if length(nowhitespace)>0\n\
    \        return nowhitespace\n    elseif length(whitespace)>0\n        return\
    \ whitespace\n    elseif length(words)==1\n        return lower(words[1])\n  \
    \  else\n        return words[1]\nend\n</code>\n<|/ a tags=julia,split,string\
    \ |>\n<| a dscore=1 tags=julia,split,string |>\nHere are some ways of achieving\
    \ the desired result:\n<code>\njulia> s = \"hello world hello world hello\"\n\"\
    hello world hello world hello\"", "    words = (split(txt, \" \"))[1]\n    words\
    \ = split(words, \",\")\n    words = words[[1:end-1]]\n    return length(words)\n\
    end", "    # Return number of words in string\n    if isempty(txt)\n        return\
    \ zeros(0)\n    words = split(txt)\n    return length(words)\nend\n</cell>\n<code\
    \ language=julia-1.1>", "    words_list = split(txt, \" \\n\")\n    counts = Dict()\n\
    \    for word in words_list\n        counts[word] = length(word)\n    end\n  \
    \  words_list = sort(collect(keys(counts)))\n    words_vec = Array{Vector{String}}(undef,\
    \ 0)\n    for word in words_list\n        if counts[word] % 2 == 1\n         \
    \   push!(words_vec, word)\n        elseif counts[word] == 1\n            push!(words_vec,\
    \ word)\n        else\n            push!(words_vec, [word])\n        end\n   \
    \ end\n    return words_vec\nend\n</code>\n<|/ a tags=csv,julia,data-analysis\
    \ dscore=1 |>\n<| a dscore=0 |>\nHere is my solution (for me, it works). I am\
    \ not familiar with Julia so there might be better ones. Also, since I don't have\
    \ access to your data I cannot test it with your data. All you need to do is change\
    \ \"somefile.txt\" to the actual path to your file. \n<code>\nusing CSV\nusing\
    \ DataFrames", "    \"\"\"Split the given string into words using spaces, commas\
    \ and newlines as delimiters.\n    Returns a vector of words split on whitespace.\
    \ If no whitespaces exists in the text you\n    should split on commas ',' if\
    \ no commas exists you should return the number of lower-case letters with odd\
    \ order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n\
    \    Examples\n    >>> split_words(\"Hello world!\")\n    [\"Hello\", \"world!\"\
    ]\n    >>> split_words(\"Hello,world!\")\n    [\"Hello\", \"world!\"]\n    >>>\
    \ split_words(\"abcdef\")\n    3\n    \"\"\"", "    lst = String.split(txt, \"\
    \ \")\n    vector = Vector{String}(undef, 0)\n    for s in lst\n        push!(vector,\
    \ s)\n    end\n    return vector\nend\n</code>\nIn a general sense the above function\
    \ can be refactored to use list comprehension:\n<code>", "    \"\"\"\n    Return\
    \ a vector of words in lower-case. If no whitespace is found in the input you\
    \ should split on commas\n    ','. If no comma is found in the input you should\
    \ return the number of lower-case letters with odd order in the\n    alphabet,\
    \ ord('a'), ord('b'), ..., ord('z') = 25\n    \"\"\"\n    words = split(txt)\n\
    \    word_count = 0\n    for word in words\n        word_count = word_count +\
    \ 1\n    end\n    return word_count\nend\n</cell>\n<text>\nExercise 5 - Test your\
    \ code", "    split(txt, ' ') |> flatten\nend", "    \"\"\"Split text into vector\
    \ of words\"\"\"\n  res = []\n  while txt != \"\"\n    push!(res, split(txt))\n\
    \    txt = txt.tail\n  end\n  return res.length == 0 ? 0 : Int64(length(txt))\n\
    end", "    words = split(txt)\n    return length(words) in (1, 2) ? words : [join(words,\
    \ ',')]\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks Mario! But I have no\
    \ idea how to convert it. I tried the following:", "    if length(txt) == 0 \n\
    \        return [] \n    txt = lowercase(txt) \n    words = split(txt,' ') \n\
    \    if length(words) == 0 \n        return [] \n    words = words[1:end-1] \n\
    \    return words\nend\n</cell>\n<code language=julia-0.3>\n\"\"\"\n    count_words(txt::String)::Union{Vector{Int64},Int64}",
  "    local cnt\n    cnt = 0\n    for s in txt:gmatch(\"[%a..%z]+\") do cnt += 1\
    \ end\n    if cnt==0 return 0 \n    local words = []\n    local new_txt = \"\"\
    \n    local tmp\n    for s in txt:gmatch(\"[%a..%z]+\") do \n        tmp = new_txt\
    \ \n        new_txt = \"\"\n        local c = ord(s):byte()\n        if c>96 then\n\
    \            local n\n            n = c - 96\n            tmp:insert(s:sub(n -\
    \ 1,1)) \n        end\n        new_txt:=new_txt..s\n    end\n    words = [tmp]\n\
    \    return words\nend\n</code>\n<|/ a tags=julia,string |>\n<| c |>\nThe first\
    \ solution should be `words = [txt]`. The return type should also be `Union{Vector{String},\
    \ Int64}`.\n<|/ c |>\n<| c |>\nThanks, fixed the return type\n<|/ c |>\n<| a |>\n\
    Here's a recursive solution that can handle any number of whitespaces, including\
    \ those that don't separate words (single space, multiple spaces, tabs, etc).\n\
    The output can be an array of words or a vector of vectors of words.\n<code>",
  "    splitted = split(txt, \" \")\n    \n    word_count::Int64 = 0\n    for word\
    \ in splitted\n        if !contains(word, \",\")\n            word_count = word_count\
    \ + 1\n        end\n    end\n    \n    word_count::Int64 = 0\n    for word in\
    \ splitted\n        if contains(word, \",\")\n            word_count = word_count\
    \ + 1\n        end\n    end\n    \n    return word_count\nend\n</cell>\n<cell>\n\
    split_words(\"Hello world!\")\n</cell>\n<text>\nQuestion 5\nWrite a function to_lower(txt)\
    \ that takes a text as input and returns a vector of lower-case letters by splitting\
    \ on whitespace.\nIf the string contains commas you should return an error.\n\
    For example to_lower(\"Hello world!\") should return [\"hello\", \"world\"].\n\
    Also include an if statement that takes in an array of strings and returns an\
    \ array of strings if a comma is in the array or a vector of words if no commas\
    \ are present.\nExamples\nto_lower(\"Hello world!\") should return [\"hello\"\
    , \"world\"]\nto_lower([\"Hello\",\"world\"]) should return [\"hello\", \"world\"\
    ]\nto_lower([\"Hello\",\"world\",\"!\"]) should return [\"hello\", \"world\",\
    \ \"!\"]\nto_lower([\"Hello\",\"world\",\"!\",\",\"]) should return an error\n\
    to_lower([\"Hello\",\"world\",\"!\"]) should return an error\nto_lower([\"Hello\"\
    ,\"world\",\"!\"]) should return an error\nto_lower([\"hello,world\"]) should\
    \ return an error\nto_lower([\"Hello\",\"world\"]) should return an error\nto_lower([\"\
    Hello\",\"world\",\"!\"]) should return an error\nto_lower([\"Hello\",\"world\"\
    ,\"!\",\"!\"]) should return an error\nto_lower([\"Hello\",\"world\",\"!\"]) should\
    \ return an error\nto_lower([\"hello\",\"world\"]) should return an error\nto_lower([\"\
    Hello\",\"world\"]) should return an error\nto_lower([\"Hello\",\"world\",\"!\"\
    ]) should return an error\nto_lower([\"Hello\",\"world\",\"!\",\"!\"]) should\
    \ return an error\nto_lower([\"hello\",\"world\"]) should return an error\nto_lower([\"\
    Hello\",\"world\"]) should return an error\nto_lower([\"Hello\",\"world\",\"!\"\
    ]) should return an error\nto_lower([\"Hello\",\"world\",\"!\",\"!\"]) should\
    \ return an error\nto_lower([\"hello,world\"]) should return an error\nto_lower([\"\
    hello,world\"]) should return an error\nto_lower([\"hello,world\",\"!\"]) should\
    \ return an error\nto_lower([\"hello,world\",\"!\",\"!\"]) should return an error\n\
    to_", "    split_words = findall(\" \",txt)\n    if split_words == [] \n     \
    \   split_words = findall(\" ,\",txt)\n    end\n    \n    if split_words == []\n\
    \        split_words = findall(\" a\",txt)\n    end", "    \"\"\"\n    Given a\
    \ vector of words as text return the number of words with odd order in the alphabet,\
    \ ord('a') = 0, ord('b') = 1, \n    ..., ord('z') = 25\n    Examples\n    >>>\
    \ split_words([\"Hello\", \"world!\"])\n    3\n    \"\"\"\n</code>\n<|/ a |>\n\
    <| c |>\n`split_words(\"Hello world!\")` returns `[\"Hello\", \" world!\"]`\n\
    <|/ c |>\n<| c |>\nThanks, I've updated my answer to include the extra checks\
    \ I mentioned in my comments :)\n<|/ c |>\n<| a tags=julia |>\nIf you want an\
    \ efficient solution, you can use Dict{String, Array{String, 1}} (the equivalent\
    \ of a Dict{String, Integer}), then check each word to see if it exists in the\
    \ dictionary. This can be done in O(n) time by testing each word and setting a\
    \ Boolean value for each word that shows whether it exists in the dictionary:\n\
    <code>\nword_count = Dict()\nfor w in [\"Hello\", \"world!\", \"how\", \"are\"\
    , \"you\", \"today\"]\n    if !haskey(word_count, w) # not in the dict\n     \
    \   word_count[w] = Array(w)\n    else\n        word_count[w][end+1] = w # add\
    \ new word to end of array\n    end\nend", "    if len(txt) == 0 \n        return\
    \ [] \n    \n    lower = length(txt)\n    if lower() == 0 \n        return 0 \n\
    \    \n    words = splitall(txt, ' ')\n    words = map(lowercase, words) \n  \
    \  words = sort!(words) \n    \n    lengths = map(x->length(x), words) \n    \n\
    \    if len(words) == 0 \n        return 0 \n    \n    words[0] = words[end] \n\
    \    words[end] = \"\"\n    \n    words = [w for w in words if w != \"\"]\n  \
    \  \n    if lower() == 0 \n        return lengths[end]\n    \n    length = length(words)\n\
    \    \n    if lower() mod 2 == 1 \n        return length\n    \n    oddorder =\
    \ 0\n    for i in 1:length(lengths) \n        if lengths[i] != length \n     \
    \       oddorder += 1 \n        else \n            break\n    end\n    \n    if\
    \ oddorder == length(lengths) \n        return length\n    else \n        return\
    \ length(lengths) + oddorder + 1\nend\n</code>\n<|/ a tags=julia |>\n<| a tags=julia\
    \ dscore=2 |>\nYou can use the split function and count the occurrences of each\
    \ word in the text and filter only the words with odd occurrences.\n<code>", " \
    \ lettercount=0\n  if isempty(txt)\n    return lettercount\n  end\n  words=split(txt,\"\
    \ \")\n  for w in words\n    if islowercase(w)\n      lettercount+=1\n    end\n\
    \  end\n  return lettercount\nend", "    # Write your code here\nend\n</code>\n\
    Question 3\n<code>", "    words = []\n    split_chars = if contains(txt, \" \"\
    )\n        split(txt, \" \")\n    elseif contains(txt, \",\")\n        split(txt,\
    \ \",\")\n    elseif contains(txt, \"-\")\n        split(txt, \"-\")\n    else\n\
    \        split(txt, \"\\n\")\n    end\n    for c in split_chars\n        if !isempty(c)\n\
    \            push!(words, c)\n        end\n    end\n    if length(words) > 1\n\
    \        reduce(+, map(length, words[2:end-1]))\n    else\n        1\n    end\n\
    end\n\"\"\"\n    count_word_frequencies(txt::String)", "  letters = setdiff(LETTERS,\
    \ txt)\n  if length(letters) > 0\n      split(letters) \n  else\n    split(split(txt)[1])\n\
    \  end\nend\n</code>\n<|/ a dscore=4 tags=julia |>\n<| c |>\n`split` does not\
    \ accept `Int64`? `[1,2,3].split` returns `Array{Int64,1}` and not `Vector{Int64}`\
    \ as one would expect.\n<|/ c |>\n<| c |>\nAh yes, sorry. It seems to work in\
    \ 0.6, but it does give `Array{Int64,1}` in 0.7. Edited answer to clarify.\n<|/\
    \ c |>\n<| c |>\nI wonder if it will get fixed/fixed in the next release.\n<|/\
    \ c |>\n<| c |>\nIt seems it doesn't. There is also a pull request for this problem:\
    \ https://github.com/JuliaLang/julia/pull/5799.\n<|/ c |>\n<| a tags=julia |>\n\
    The issue is resolved since 0.7 (see the commit message).\n<|/ a dscore=4 |>\n\
    <| a dscore=3 |>\nJulia 0.7 fixes this:\nhttps://github.com/JuliaLang/julia/pull/5799\n\
    <|/ a tags=julia |>\n<| a tags=julia dscore=2 |>\nI ran into this problem when\
    \ trying to run this script in Julia v1.0. \n<code>", "    words = []\n    word_count\
    \ = 1\n    for word in split(txt)\n        if word != '' \n            push!(words,\
    \ word)\n        else\n            word_count += 1\n        end\n    end\n   \
    \ return word_count, words\nend\n</cell>\n<code language=julia-1.6>\nsplit_words(\"\
    Hello,world!\")\n</cell>\n<code language=julia-1.6>\nsplit_words(\"Hello world!\"\
    )\n</cell>\n<text>\nExercise 3\nWrite a function that splits a line of text into\
    \ multiple parts, where each part contains all the words that are on its right.\
    \  For example, the following function should output [\"Hello\", \"world!\"]",
  "    return Vector{String}(split(txt))\nend", "    words  = split(txt, \" \")\n\
    \    return length(words) + length(words) + length(split(txt, \",\"))\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nNice answer! But your `split_words` function doesn't\
    \ quite work. It should be `return length(words) + length(words) + length(split(txt,\
    \ \",\"))`.\n<|/ c |>\n<| a dscore=0 tags=julia |>\n<code>\njulia> function split_words(txt)\n\
    \           return length(split(txt, \" \")) +\n                length(split(txt,\
    \ \",\")) +\n                length(split(txt, \" \")) - length(split(txt, \"\
    ,\")) \n       end\nsplit_words (generic function with 1 method)", "    if isempty(txt)\n\
    \        return txt\n    if ischar(txt)\n        txt = txt\n    else\n       \
    \ error(\"only string can be used as input\")\n    end\n    lst = split(txt,\"\
    \ \")\n    return length(lst)\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThank\
    \ you for this detailed answer. It really helps! However, I wonder if I can use\
    \ `islower` function to check the letters of a word and return a boolean `Bool`\
    \ if the word is in lower-case? Because my function will look like `split_words(\"\
    Hello world!\")` and return `True`\n<|/ c |>\n<| c |>\nI have edited my answer.\
    \ My code was incorrect, before it was doing `islower(lower(txt))`\n<|/ c |>\n\
    <| a |>\nThe function split_words is already defined in the String module. Since\
    \ Julia is case insensitive by default, you don't need islower anymore.\nHere\
    \ is an example to show how to split a string into words (without spaces):\n<code>\n\
    julia> using Strings", "    #Split each word by a comma\n    words_split = split(txt)\n\
    \    #Split each word with a whitespace\n    words_split = split(\", \".filter(x\
    \ -> x != \",\"))\n    #Return the size of the set of words\n    return length(words_split)\n\
    end\n</cell>\n<code language=julia-1.5>\nsplit_words(\"Hello world!\")\n</cell>\n\
    <text>\nExercise 3\nImplement the function split_chars(txt::String) which splits\
    \ the given text into individual characters. Use chars()\n    function from String.",
  "        str = split(txt, ',')\n        if length(str) == 0 \n            return\
    \ length(str)\n        end\n        \n        \n        str = join(str, ',')\n\
    \        str = split(str, '.')\n        if length(str) == 0 \n            return\
    \ length(str)\n        end\n        \n        return length(str)\n    end\n</cell>\n\
    <code language=julia-0.6>\nsplit_words(\"Hello world!\")\n</cell>\n<code language=julia-0.6>\n\
    split_words(\"Hello,world!\")\n</cell>\n<code language=julia-0.6>\nsplit_words(\"\
    abcdef\")\n</cell>\n<text>\nA. count_words", "    \n    words = get_tokens(txt)\n\
    \    \n    # if the text is all lowercase return length\n    if all(w == w for\
    \ w in words)\n        return length(words)", "    \n    words = txt.split(' ')\n\
    \    if isempty(words)\n        return 1\n    end\n    return length(words)\n\
    end\n</cell>\n<code language=julia-1.6>\nsplit_words(\"Hello world!\")\n</cell>\n\
    <code language=julia-1.6>\nsplit_words(\"Hello,world!\")\n</cell>\n<code language=julia-1.6>\n\
    split_words(\"abcdef\")\n</cell>\n<code language=julia-1.6>\nsplit_words(\"Hello\
    \ World!\")\n</cell>\n<code language=julia-1.6>\nsplit_words(\"Hello World!\"\
    , remove_punctuation=true)\n</cell>\n<code language=julia-1.6>\nsplit_words(\"\
    Hello World!\", remove_punctuation=false)\n</cell>\n<code language=julia-1.6>\n\
    split_words(\"Hello World!\", remove_punctuation=false, remove_whitespace=true)\n\
    </cell>\n<code language=julia-1.6>\nsplit_words(\"Hello World!\", remove_punctuation=false,\
    \ remove_whitespace=false)\n</cell>\n<text>\nExercise\nWrite a function count_words\
    \ that returns the number of words in a string.", "    \"\"\"Split the given text\
    \ on whitespace and commas\"\"\"\n    words_array = txt.split(\" \")\n    if length(words_array)\
    \ ==0 \n        return \n    end\n    if length(words_array) > 1 \n        for\
    \ word in words_array\n            if word == \"\"\n                return \n\
    \            end\n        end\n    end\n    return length(words_array)\nend\n\
    </code>\nThe test should now pass:\n<code>\njulia> split_words(\"Hello world!\"\
    )\n[\"Hello\", \"world!\"]", "  \"\"\"\n  Given a string of words, return a vector\
    \ of words split on whitespace, if no whitespaces exists in the text you\n  should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1, ... ord('z')\
    \ = 25\n  Examples\n  >>> split_words(\"Hello world!\")\n  [\"Hello\", \"world!\"\
    ]\n  >>> split_words(\"Hello,world!\")\n  [\"Hello\", \"world!\"]\n  >>> split_words(\"\
    abcdef\")\n  3\n  \"\"\"\n  txt = txt.replace(\" \", \"\")\n  txt = txt.replace(\"\
    ,\", \"\")\n  txt = txt.lower()\n  n = 0\n  s = \"\"\n  for w in txt\n    if w\
    \ == \",\"\n      n = n + 1\n    else\n      if w == \"-\"\n        s = s + \"\
    -\"\n      else\n        if w == \".\"\n          s = s + \".\"\n        else\n\
    \          if w == \"!\"\n            s = s + \"!\"\n          else\n        \
    \    if w == \",\"\n              s = s + \",\"\n            else\n          \
    \    if w == \"?\"\n                s = s + \"?\"\n              else\n      \
    \          if w == \"a\"\n                  s = s + \"a\"\n                else\n\
    \                  if w == \"b\"\n                    s = s + \"b\"\n        \
    \          else\n                    if w == \"c\"\n                      s =\
    \ s + \"c\"\n                    else\n                      if w == \"d\"\n \
    \                       s = s + \"d\"\n                      else\n          \
    \              if w == \"e\"\n                          s = s + \"e\"\n      \
    \                  else\n                          if w == \"f\"\n           \
    \                 s = s + \"f\"\n                          else\n            \
    \                if w == \"g\"\n                              s = s + \"g\"\n\
    \                            else\n                              if w == \"h\"\
    \n                                s = s + \"h\"\n                            \
    \  else\n                                if w == \"i\"\n                     \
    \             s = s + \"i\"\n                                else\n          \
    \                        if w == \"j\"\n                                    s\
    \ = s + \"j\"\n                                  else\n                      \
    \              if w == \"k\"\n                                      s = s + \"\
    k\"\n                                    else\n                              \
    \        if w == \"l\"\n                                        s = s + \"l\"\n\
    \                                      else\n                                \
    \        if w == \"m\"\n                                          s = s + \"m\"\
    \n                                        else\n                             \
    \             if w == \"n\"\n                                            s = s\
    \ + \"n\"\n                                          else\n                  \
    \                          if w == \"o\"\n                                   \
    \           s = s + \"o\"\n                                            else\n\
    \                                              if w == \"p\"\n               \
    \                                 s = s + \"p\"\n                            \
    \                  else\n                                                if w\
    \ == \"q\"\n                                                  s = s + \"q\"\n\
    \                                                else\n                      \
    \                            if w == \"r\"\n                                 \
    \                   s = s + \"r\"\n                                          \
    \        ", "    \"\"\"Split words in txt and return as vector\"\"\"\n    s =\
    \ split(txt, \" \")\n    l = length(s)\n    if l == 1 \n        return s\n   \
    \ \n    if l == 2 \n        if s[1] == \"\"\n            return s\n        if\
    \ s[1] == \",\"\n            return [1]\n        else\n            return s\n\
    \    end\n    \n    if l == 3\n        if s[1] == \"\"\n            return s[2]\n\
    \        if s[1] == \",\" and s[2] == \"\"\n            return [1]\n        else\n\
    \            return s\n    end\n    \n    if l == 4 \n        if s[1] == \"\"\n\
    \            return s[2]\n        if s[1] == \",\" and s[2] == \"\"\n        \
    \    return s[3]\n        else\n            return s\n    end\n    \n    if l\
    \ == 5\n        if s[1] == \"\"\n            return s[2]\n        if s[1] == \"\
    ,\" and s[2] == \"\"\n            return s[3]\n        if s[3] == \"\"\n     \
    \       return s[4]\n        else\n            return s\n    end\n    \n    if\
    \ l == 6\n        if s[1] == \"\"\n            return s[2]\n        if s[1] ==\
    \ \",\" and s[2] == \"\"\n            return s[3]\n        if s[3] == \"\"\n \
    \           return s[4]\n        if s[4] == \"\"\n            return s[5]\n  \
    \      else\n            return s\n    end\n    \n    if l == 7\n        if s[1]\
    \ == \"\"\n            return s[2]\n        if s[1] == \",\" and s[2] == \"\"\n\
    \            return s[3]\n        if s[3] == \"\"\n            return s[4]\n \
    \       if s[4] == \"\"\n            return s[5]\n        if s[5] == \"\"\n  \
    \          return s[6]\n        else\n            return s\n    end\n    \n  \
    \  if l == 8\n        if s[1] == \"\"\n            return s[2]\n        if s[1]\
    \ == \",\" and s[2] == \"\"\n            return s[3]\n        if s[3] == \"\"\n\
    \            return s[4]\n        if s[4] == \"\"\n            return s[5]\n \
    \       if s[5] == \"\"\n            return s[6]\n        if s[6] == \"\"\n  \
    \          return s[7]\n        else\n            return s\n    end\n    \n  \
    \  if l == 9\n        if s[1] == \"\"\n            return s[2]\n        if s[1]\
    \ == \",\" and s[2] == \"\"\n            return s[3]\n        if s[3] == \"\"\n\
    \            return s[4]\n        if s[4] == \"\"\n            return s[5]\n \
    \       if s[5] == \"\"\n            return s[6]\n        if s[6] == \"\"\n  \
    \          return s[7]\n        if s[7] == \"\"\n            return s[8]\n   \
    \     else\n            return s\n    end\n    \n    if l == 10\n        if s[1]\
    \ == \"\"\n            return s[2]\n        if s[1] == \",\" and s[2] == \"\"\n\
    \            return s[3]\n        if s[3] == \"\"\n            return s[4]\n \
    \       if s[4] == \"\"\n            return s[5]\n        if s[5] == \"\"\n  \
    \          return s[6]\n        if s[6] == \"\"\n            return s[7]\n   \
    \     if s[7] == \"\"", "    words::Vector{String} = []\n    i = 0\n    while\
    \ i < length(txt)\n        push!(words, txt[i])\n        i = i + 1\n    end\n\
    \    \n    if isnothing(words) || length(words) == 0\n        return length(txt)\n\
    \    end\n    \n    if txt[i] != ','\n        append!(words, txt[i])\n       \
    \ i = i + 1\n    end\n    \n    while i < length(txt)\n        push!(words, txt[i])\n\
    \        i = i + 1\n    end\n    return length(words) % 2 == 0 ? words : length(words)\n\
    end", "    for word in split(txt, \",\")\n        if length(word) > 1\n      \
    \      push!(word, \"\")\n        end\n        push!(word, lower(word))\n    end\n\
    \    word_counts = Dict(\"a\" => 0, \"b\" => 1, \"c\" => 2, \"d\" => 3, \"e\"\
    \ => 4, \"f\" => 5, \"g\" => 6, \"h\" => 7, \"i\" => 8, \"j\" => 9, \"k\" => 10,\
    \ \"l\" => 11, \"m\" => 12, \"n\" => 13, \"o\" => 14, \"p\" => 15, \"q\" => 16,\
    \ \"r\" => 17, \"s\" => 18, \"t\" => 19, \"u\" => 20, \"v\" => 21, \"w\" => 22,\
    \ \"x\" => 23, \"y\" => 24, \"z\" => 25)\n    letter_counts = Dict(\"a\" => 0,\
    \ \"b\" => 1, \"c\" => 2, \"d\" => 3, \"e\" => 4, \"f\" => 5, \"g\" => 6, \"h\"\
    \ => 7, \"i\" => 8, \"j\" => 9, \"k\" => 10, \"l\" => 11, \"m\" => 12, \"n\" =>\
    \ 13, \"o\" => 14, \"p\" => 15, \"q\" => 16, \"r\" => 17, \"s\" => 18, \"t\" =>\
    \ 19, \"u\" => 20, \"v\" => 21, \"w\" => 22, \"x\" => 23, \"y\" => 24, \"z\" =>\
    \ 25)\n    word_counts[\"\"] = length(split(txt, \",\"))\n    letter_counts[\"\
    \"] = length(split(txt, \" \"))\n    word_counts = Dict(\"a\" => 0, \"b\" => 1,\
    \ \"c\" => 2, \"d\" => 3, \"e\" => 4, \"f\" => 5, \"g\" => 6, \"h\" => 7, \"i\"\
    \ => 8, \"j\" => 9, \"k\" => 10, \"l\" => 11, \"m\" => 12, \"n\" => 13, \"o\"\
    \ => 14, \"p\" => 15, \"q\" => 16, \"r\" => 17, \"s\" => 18, \"t\" => 19, \"u\"\
    \ => 20, \"v\" => 21, \"w\" => 22, \"x\" => 23, \"y\" => 24, \"z\" => 25)\n  \
    \  letter_counts = Dict(\"a\" => 0, \"b\" => 1, \"c\" => 2, \"d\" => 3, \"e\"\
    \ => 4, \"f\" => 5, \"g\" => 6, \"h\" => 7, \"i\" => 8, \"j\" => 9, \"k\" => 10,\
    \ \"l\" => 11, \"m\" ", "    \"\"\"\n    Takes in a string of words and returns\
    \ them as a vector of words, split on whitespace\n    if no whitespaces exists\
    \ in the text you should split on commas ',' if no commas exists you should return\
    \ the number of lower-case letters\n    with odd order in the alphabet, ord('a')\
    \ = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    >>> split_words(\"Hello\
    \ world!\")\n    [\"Hello\", \"world!\"]\n    >>> split_words(\"Hello,world!\"\
    )\n    [\"Hello\", \"world!\"]\n    >>> split_words(\"abcdef\")\n    3\n    \"\
    \"\"\n    function split_words(txt)::Vector{String}\n        if txt == \"\"\n\
    \            return []\n        \n        words = split(txt,\" \")\n        words\
    \ = [w for w in words if w !~ islower(w)]\n        \n        return words\n  \
    \  end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    count_alpha_words(txt::String)::Int64\n\
    \    Takes in a string of words and returns a count of the number of words which\
    \ only consist of lower-case alphabets\n    Examples\n    >>> count_alpha_words(\"\
    Hello world!\")\n    3\n    \"\"\"", "    words = split(txt,\" \")\n    words\n\
    end\n</cell>\n<code language=julia-1.5>\ntest_txt = \"Hello world!\"\n</cell>\n\
    <code language=julia-1.5>\nsplit_words(test_txt)\n</cell>\n<code language=julia-1.5>",
  "    return split(txt)\nend", "    if len(txt)==0\n        return txt\n    if \"\
    ,\" in txt\n        txt = txt.split(\",\")\n        txt = txt.map(x -> x.strip())\n\
    \    else\n        txt = txt.split(\" \")\n        txt = txt.map(x -> x.strip())\n\
    \    end\n    return count(x -> x < 26, txt)\nend\n</cell>\n<code language=julia-1.5>\n\
    split_words(\"Hello world!\")\n</cell>\n<code language=julia-1.5>\nsplit_words(\"\
    Hello,world!\")\n</cell>\n<code language=julia-1.5>\nsplit_words(\"abcdef\")\n\
    </cell>\n<text>\nExercise 3\nWrite a function that returns the total number of\
    \ words in a string, without counting commas. Given the string \"Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!",
  "    \n    if txt == \"\"\n        return Vector{String}([])\n    end\n    \n  \
    \  if ',' in txt\n        words = [txt |> String.split(',') |> collect]\n    elseif\
    \ ' ' in txt\n        words = [txt |> String.split(' ') |> collect]\n    else\n\
    \        words = lowercase(txt).split(\" \")\n    end\n    \n    odd_words = Dict{String,\
    \ Int64}()\n    \n    for w in words\n        if !odd_words[w]\n            odd_words[w]\
    \ = length(lowercase(w))\n        end\n    end\n    \n    for w in words\n   \
    \     if odd_words[w]\n            odd_words[w] += 1\n        end\n    end\n \
    \   \n    odd_words_vec = Vector{String}(odd_words.keys)\n    \n    odd_words_vec[end]\
    \ = convert(Int64, length(words) - 1)\n    return odd_words_vec\nend\n</cell>\n\
    <text>\nImplement the split_lines function, which should split a text into lines",
  "    \n    splits = split(txt)\n    \n    # remove any empty strings\n    splits\
    \ = [splitarr for splitarr in splits if splitarr != \"\"]\n    \n    # remove\
    \ any empty strings\n    splits = [splitarr for splitarr in splits if splitarr\
    \ != \"\"]\n    \n    # remove any empty strings\n    splits = [splitarr for splitarr\
    \ in splits if splitarr != \"\"]\n    \n    return splits\nend", "    \nend\n\
    </cell>\n<text>\nTask 1: Generate a list of word frequencies in the text", " \
    \   splits = split(txt, ' ')\n    if length(splits) > 1\n        return Vector{String}(splits)\n\
    \    else\n        return length(split(txt, ',')) + 1\n    end\nend", "    \"\"\
    \"\n    Given a string of words, return a vector of words split on whitespace,\
    \ if no whitespaces exists in the text you\n    should split on commas ',' if\
    \ no commas exists you should return the number of lower-case letters with odd\
    \ order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n\
    \    Examples\n    >>> split_words(\"Hello world!\")\n    [\"Hello\", \"world!\"\
    ]\n    >>> split_words(\"Hello,world!\")\n    [\"Hello\", \"world!\"]\n    >>>\
    \ split_words(\"abcdef\")\n    3\n    \"\"\"\n    white_space = \" \"\n    comma_space\
    \ = \",\"\n    words = txt.split(white_space)\n    words = [word for word in words\
    \ if word != \"\"]\n    words = [word for word in words if word != \"\"]\n   \
    \ return length(words) \nend\n</cell>\n<text>\nQuestion 3\nIn the cell below,\
    \ write a function to split a text on a single character. For instance:", "  \
    \  words = split(txt, ' ') \n    n = length(words) \n    if n == 0 \n        return\
    \ 0 \n    else \n        return n \nend \nend \n</cell>\n<code language=julia-1.2>",
  "    if length(txt) < 1 \n        return 1 \n    else \n        split(txt, \" \"\
    ) \n    end\nend\n</code>\nThe last line is what gives us a vector of words. Now\
    \ lets say we want to return the number of words in the vector we got above. \n\
    <code>", "    \"\"\"\n    Split words into an array of strings.\n    \"\"\"\n\
    \    words,split = regexpr(r\"\\W+\", txt, 0) \n    if words == 0 \n        return\
    \ split \n    else \n        return Strings[split(1:end-1)] \nend ## split_words",
  "    \"\"\"\n    Given a string of words, return a vector of words split on whitespace,\
    \ if no whitespaces exists in the text you\n    should split on commas ',' if\
    \ no commas exists you should return the number of lower-case letters with odd\
    \ order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n\
    \    Examples\n    >>> split_words(\"Hello world!\")\n    [\"Hello\", \"world!\"\
    ]\n    >>> split_words(\"Hello,world!\")\n    [\"Hello\", \"world!\"]\n    >>>\
    \ split_words(\"abcdef\")\n    3\n    \"\"\"\nend", "    \"\"\"Split the text\
    \ into words, return vector of words and number of words if none exist\"\"\"\n\
    </code>\nFor your reference, here is the official documentation for these functions\
    \ in Julia:\n<code>\nsplit_words\nsplit_words\n</code>\n<|/ a dscore=3 tags=arrays,julia,vector\
    \ |>\n<| a dscore=1 |>\nTo avoid using Vector{String}, you can use Array{String,1}\
    \ (note that in Julia arrays are 0-based indexed):\n<code>\njulia> split_words(str)\n\
    10-element Array{String,1}:\n \"Hello\"\n \"world!\"\n \"abcdef\"\n</code>\nYou\
    \ can also use Strings:\n<code>\njulia> str = split(str)\n10-element Array{SubString{String},1}:\n\
    \ \"Hello\"\n \"world!\"\n \"abcdef\"\n</code>\nThe reason why I suggest using\
    \ Array{String,1} is that it is more efficient:\n<code>\njulia> str = [x for x\
    \ in str; x]\n10-element Array{SubString{String},1}:\n \"Hello\"\n \"world!\"\n\
    \ \"abcdef\"\n</code>\nThe reason why I suggest using Array{String,1} is that\
    \ it is more efficient because Julia is a compiled language, and so in order to\
    \ convert a String{String} into a Vector{String}, Julia has to convert all of\
    \ the Strings into substrings first.\n<|/ a tags=arrays,julia,vector |>\n<| c\
    \ |>\nThe `Vector{String}` solution doesn't return a list of strings, it returns\
    \ a `Vector{Vector{String}}`, which makes the question unanswerable.\n<|/ c |>\n\
    <| a dscore=0 |>\nHere is a solution that returns an array of words from a string.\n\
    <code>", "    try\n        words = split(txt, ' ')\n    catch e\n        words\
    \ = split(txt, ',')\n    end\n    \n    # count odd order of letters and put back\
    \ in to vector\n    nw = zeros(length(words),1)\n    for i = 1:length(words)\n\
    \        if i == 1\n            nw[i] = length(words[i])\n        elseif isequal(lower(words[i\
    \ - 1]), lower(words[i]))\n            nw[i] = nw[i-1]+1\n        else\n     \
    \       nw[i] = nw[i-1]\n        end\n    end\n    \n    \n    return nw\nend\n\
    </code>\n<|/ a dscore=2 tags=arrays,string,julia |>\n<| a tags=arrays,string,julia\
    \ |>\nFor anyone looking for something faster, here's a solution without for-loop\n\
    <code>", "    \"\"\"\n    Given a vector of words return a vector of words split\
    \ on whitespace, if no whitespaces exists in the text you\n    should split on\
    \ commas ',' if no commas exists you should return the number of lower-case letters\
    \ with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z')\
    \ = 25\n    Examples\n    >>> split_words(\"Hello world!\")\n    [\"Hello\", \"\
    world!\"]\n    >>> split_words(\"Hello,world!\")\n    [\"Hello\", \"world!\"]\n\
    \    >>> split_words(\"abcdef\")\n    3\n    \"\"\"\nend\n</code>\nI used the\
    \ @ to display the function definition inside the jupyter notebook. Now the function\
    \ definition can be called and you can see what it does.\n<code>\njulia> split_words(\"\
    Hello world!\")\n[\"Hello\", \"world!\"]\n</code>\nYou see that it returns a vector.\
    \ Let's see what it does\n<code>\njulia> split_words(\"Hello world!\")\n[\"Hello\"\
    , \"world!\"]\n</code>\nOh no. Did you see what happened in the previous example?\
    \ The text is now a vector and split_words will split it into words.\n<|/ a |>\n\
    <| c |>\nThanks, this was the solution I needed, and it's very simple. I am new\
    \ to Julia so this helps me understand.\n<|/ c |>\n<| a dscore=2 |>\nHere's a\
    \ complete example which shows how to convert a collection of words into a vector\
    \ of words (in reverse order) and how to use a regexp to split words.\n<code>\n\
    using UnicodeLetters, RegexpFunctions", "    words = split(txt,\" \") # split\
    \ the text on spaces \n    if isempty(words) # if no spaces exist in the text\
    \ then split the text on commas ','\n        return length(words) # return the\
    \ number of lower-case letters with odd order in the alphabet\n    else # else\
    \ split on spaces \n        return length(words) % 2 != 0 # return 1 if there\
    \ are an even number of lower-case letters else return 0\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    \n    #get the number of occurences for each letter\n\
    \    word_count = Hash{String,Int64}()\n    for w in lowercase(txt)\n        word_count[w]\
    \ = get(word_count,w,0)+1\n    end", "    splitted = split(txt, sep=\",\")\n \
    \   if length(splitted) ~= 0 \n        return split(splitted[1]) \n    else \n\
    \        return length(lowercase(txt)) % 2 ? length(lowercase(txt)) : length(lowercase(txt))\
    \ - 1\n    end\nend", "    if !ischar(txt)\n        throw(ArgumentError(\"The\
    \ argument must be string\"))\n    end", "\"\"\"\n    Split the string with spaces\
    \ if no spaces exists and then with commas if no commas exists.\n\"\"\"\n    words\
    \ = split(txt)\n    if all(w == \"_\" for w in words) \n        return words\n\
    \    \n    words = split(txt, sep=\",\")\n    if all(w == \"_\" for w in words)\
    \ \n        return words", "    \n    txt = txt.trim()\n    if !contains(txt,'\
    \ ')\n        return txt.chars\n    elseif !contains(txt,',')\n        return\
    \ countlowercase(txt.chars)\n    else\n        a,b = split(txt,',')\n        return\
    \ a * countlowercase(b)\n    end\nend", "    txt = txt.lower()\n    if contains(txt,',')\n\
    \        return txt.split(',')\n    elseif contains(txt,' ')\n        return txt.split()\n\
    \    else\n        return ones(1,length(txt)+1)[1:end]\n    end\nend", "    #\
    \ initialize an array to store the words \n    words  = Array{String}(0) \n  \
    \  # iterate over all the letters in the string \n    for letter in txt \n   \
    \     # if the letter is alphabet letter add it to the words array \n        if\
    \ isletter(letter) \n            push!(words, letter) \n        else \n      \
    \      # if comma is found, split words on comma \n            if letter == ','\
    \ \n                words = readdlm(\",\", words) \n                # if comma\
    \ is found again append the current letter to the words array \n             \
    \   push!(words, letter) \n            end\n        end\n    end\n    words\n\
    end\n\"\"\"\n    count_unique_words_helper(txt)", "    txt = lowercase(txt)\n\
    \    words = []\n    for word in split(txt, \", \")\n        push!(words, word)\n\
    \    end\n    return length(words) >= 2 ? words : length(words) == 1 ? ord(words[1])\
    \ - ord('a') : length(words) == 0 ? length(words) : -1\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\n`split_words` will split the string on commas, but it will not\
    \ return all words as desired in the question, since the return type is a `Vector{String}`\
    \ and there is no guarantee that all the words are separated by commas.\n<|/ c\
    \ |>\n<| a tags=julia,string |>\nHere is my solution:\n<code>", "    return map(String.split,txt)\n\
    end", "    vec=Vector{String}(undef, length(txt))\n    for i in 1:length(txt)\n\
    \        if haskey(words,txt[i]) \n            push!(vec, words[txt[i]])\n   \
    \     else \n            push!(vec, i)\n        end\n    end\n    return vec \n\
    end\n</cell>\n<text>\nTask 6\nWrite a function that will return a vector of words\
    \ split on commas, if no commas exists in the text you should split on spaces,\n\
    if no spaces exists in the text you should return all the lower-case letters with\
    \ odd order in the alphabet\nExamples\n>>> split_words(\"Hello world!\")\n[\"\
    Hello world!\"]\n>>> split_words(\"Hello,world!\")\n[\"Hello\", \"world!\"]\n\
    >>> split_words(\"abcdef\")\n[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]\n\"\"\"",
  "    words = []\n    for word in split(txt, \" \")\n        push!(words, word)\n\
    \    end\n    return words\nend\n</cell>\n<code language=julia-1.5>\n# Check function\n\
    split_words(\"Hello world!\")\n</cell>\n<text>\nExercise 2.21", "    \n    words_list\
    \ = split(txt, \" \")\n    words_list_lowercase = split(txt, \",\")\n    words_list_odd_order_letters\
    \ = count(lower(txt))", "    \n    words = split(txt,\" \")\n    if length(words)\
    \ ==0\n        return zeros(1)\n    else\n        return words\n    end\nend",
  "    return split(txt,\" \") |> length\nend", "    # Your code here\n    return\
    \ \nend\n</cell>\n<text>\nTest cell", "    if isempty(txt) \n        return []\
    \ \n    end\n    words = split(txt, \" \")\n    return Vector{String}(undef, length(words))\n\
    end", "    \"\"\"\n    Return a vector of words split on whitespace, if no whitespaces\
    \ exists in the text you should split on commas\n    ',' if no commas exists you\
    \ should return the number of lower-case letters with odd order in the\n    alphabet,\
    \ ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    >>> split_words(\"\
    Hello world!\")\n    [\"Hello\", \"world!\"]\n    >>> split_words(\"Hello,world!\"\
    )\n    [\"Hello\", \"world!\"]\n    >>> split_words(\"abcdef\")\n    3\n    \"\
    \"\"\n    _check_type!(txt, String)\n    _check_string!(txt, \"\")\n    _check_number!(txt,\
    \ min=1)\n    if txt == \"\"\n        txt = \"test\"\n        return Vector{String}(split(txt,\
    \ \",\") )\n    end\n    words = split(txt, \" \")\n    words_size = length(words)\n\
    \    words_vec:Vector{String} = Vector{String}()\n    for word in words\n    \
    \    words_push!(words_vec, word)\n    end\n    if words_size % 2 == 1\n     \
    \   words_push!( words_vec, words[words_size/2] )\n        words_size+=1\n   \
    \ end\n    odd_count = 0\n    for word in words\n        odd_count = odd_count\
    \ + 1 if ord('a') <= ord(word) <= ord('z')\n    end\n    return words_size + (words_size/2\
    \ + odd_count)\nend\n</cell>\n<code language=julia-1.1>\nsplit_words(\"\"\"Hello\
    \ world!\nHello,world!\nabcdef\"\"\")\n</cell>\n<text>\n\U0001F522 Note \U0001F522",
  "    if length(txt) == 0\n        return Vector{String}()\n    elseif txt.head ==\
    \ \",\"\n        return split_words(txt.tail)\n    elseif txt == \",\"\n     \
    \   return length(str.split(txt, \",\"))\n    else\n        return split(txt,\
    \ \" \")\nend\n</cell>\n<text>\nExercise 1\nWrite a function that takes a vector\
    \ (or column) of type Array{String}, which has only lower-case letters, and returns\
    \ another Array{String} that has only words composed of lower-case letters. You\
    \ can assume that the function has already been written for you.", "    if isempty(txt)\n\
    \        return txt\n    elseif txt==\" \" || txt == \"\\n\"\n        return txt\n\
    \    else\n        words = split(txt, ',')\n        lowercase_words = map(lowercase,\
    \ words)\n        odd_words_idx = findall(x->isodd(x), lowercase_words)\n    \
    \    if isempty(odd_words_idx)\n            return words\n        else\n     \
    \       return join(words[odd_words_idx], \",\")\n        end\n    end\nend",
  "    words::Vector{String} = []\n    for word in split(txt, \",\")\n        push!(words,\
    \ lower(word))\n    end\n    return length(filter(x -> x != \" \", words))\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThank you! I didn't realise that I was getting\
    \ the wrong output type from `split`, which is not obvious from your example output!\n\
    <|/ c |>\n<| c |>\nThe return type for `split` is `Vector{String}` and the return\
    \ type for `split_words` is `Int64` which doesn't seem right?\n<|/ c |>\n<| c\
    \ |>\nYou return `length(filter(x -> x != \" \", words))` which returns `Int64`.\
    \ So this doesn't make sense.\n<|/ c |>\n<| c |>\nI have updated my answer to\
    \ show my final code based on your answer. Thank you for helping me with this\
    \ final issue!\n<|/ c |>\n<| a dscore=1 |>\nI didn't realise that I was getting\
    \ the wrong output type from split", "    words = split(txt,\" \") |> collect\n\
    \    n = 0\n    for w in words\n        n = if w == \"\" then 0 else n + length(split(w,\"\
    ,\")) + 1\n    end\n    return n\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks,\
    \ I appreciate it. I don't quite understand how your code works. I tried to run\
    \ it but got an error saying \"function split_words must be exported from a module\
    \ before it is used [in module (root) test.jl]\".\n<|/ c |>\n<| c |>\nHi I just\
    \ edited my original question with a new version of my split_words function, but\
    \ I still get the same error.\n<|/ c |>\n<| c |>\nHi. I didn't quite understand\
    \ what you are saying. Could you please clarify where you are putting the function?\
    \ In the same file as the main file?\n<|/ c |>\n<| c |>\nYou have to put the function\
    \ somewhere else, in this case I put it in test.jl and tested it with `julia test.jl`.\
    \ I had to write it like this: `module test; export split_words; end function\
    \ split_words(txt::String)::Union{Vector{String}, Int64} ...`\n<|/ c |>\n<| c\
    \ |>\nOkay, I just edited my code with what I now have in my test.jl file. I just\
    \ copied what you wrote and now when I run the program I get this error: ERROR:\
    \ LoadError: ArgumentError: invalid argument for \"split!\": expected String but\
    \ got Tuple{String,String,String}\n<|/ c |>\n<| a tags=julia |>\nThe comment about\
    \ split! is correct. There is an important difference between split! and split\
    \ that makes a difference when dealing with CSV files. Here is an example demonstrating\
    \ a difference in behavior between split! and split on CSV files.\n<code>\njulia>\
    \ using CSV\njulia> CSV.read(\"data.csv\")\n  Column   Row Col 1    Col 2    Col\
    \ 3    Col 4\n  String   Int64 String   String   String   String\n  A        1\
    \     1       A       A       A\n  B        2     2       B       B       B\n\
    \  C        3     3       C       C       C\n  D        4     4       D      \
    \ D       D", "   if length(txt) == 0 \n       return [] \n   end\n   \n   if\
    \ isspace(txt[1]) \n       return [txt] \n   end\n   return [txt] \nend \n</cell>\n\
    <cell>", "    if txt == \"\" \n        error(\"The text should not be blank\"\
    ) \n    else \n        words = split(txt, \" \") \n        return words\n    end\n\
    end", "    txt = txt.split(' ')\n    if any(w == '' for w in txt)\n        txt\
    \ = txt.split(',')\n        return count(lower(txt))\n    else\n        return\
    \ txt\n    end\nend\n</code>\n<|/ a tags=julia dscore=1 |>\n<| a tags=julia dscore=1\
    \ |>\nAnother possible solution is to use split(), which accepts the regular expression\
    \ (?<=) for the delimiter:\n<code>\njulia> \"Hello world!\".split(r\"(?<=\\s)\"\
    )\n6-element Array{String,1}:\n \"Hello\"\n \"world!\"\n \"Hello\"\n \"world!\"\
    \n \"abcdef\"\n</code>\nIn your example, it returns:\n<code>\n6-element Array{String,1}:\n\
    \ \"Hello\"\n \"world!\"\n \"Hello\"\n \"world!\"\n \"abcdef\"\n</code>\nBut note\
    \ that it returns empty strings for every word before the first whitespace character:\n\
    <code>\njulia> \"Hello world!\".split(r\"(?<=\\s)\")\n5-element Array{String,1}:\n\
    \ \"\"\n \"\"\n \"Hello\"\n \"world!\"\n \"\"\n</code>\n<|/ a |>\n<| a |>\nA function\
    \ like this worked for me\n<code>", "    \"\"\"Split a string on whitespace, comma,\
    \ or a character\"\"\"\n        \n    words = txt.split(\" \")\n    \n    # handle\
    \ empty strings\n    if words.length == 0\n        return words\n    else\n  \
    \      \n        # handle commas\n        if \",\" in words\n            return\
    \ words\n        elseif \"\" != words[end]\n            return words\n       \
    \ else\n            # handle whitespace characters\n            \n           \
    \ # get number of lowercase letters with odd order in alphabet\n            odd_count\
    \ = 0\n            for i in words[end]\n                if ord(i) % 2 > 0\n  \
    \                  odd_count += 1\n            \n            return words[end\
    \ - odd_count : end]\n        end\n    end\nend", "    if isempty(txt)\n     \
    \   \n    elseif length(txt) == 1 \n        \n    elseif all(txt .contains char\
    \ ',') || all(txt .contains char '.') || all(txt .contains char '-')\n       \
    \ \n    elseif all(txt .contains char 'a') || all(txt .contains char 'b') || all(txt\
    \ .contains char 'c') || all(txt .contains char 'd') || all(\n        txt .contains\
    \ char 'e') || all(txt .contains char 'f') || all(txt .contains char 'g') || all(txt\
    \ .contains char 'h') || all(\n        txt .contains char 'i') || all(txt .contains\
    \ char 'j') || all(txt .contains char 'k') || all(txt .contains char 'l') || all(\n\
    \        txt .contains char 'm') || all(txt .contains char 'n') || all(txt .contains\
    \ char 'o') || all(txt .contains char 'p') || all(\n        txt .contains char\
    \ 'q') || all(txt .contains char 'r') || all(txt .contains char 's') || all(txt\
    \ .contains char 't') || all(\n        txt .contains char 'u') || all(txt .contains\
    \ char 'v') || all(txt .contains char 'w') || all(txt .contains char 'x') || all(\n\
    \        txt .contains char 'y') || all(txt .contains char 'z')\n        \n  \
    \  elseif all(txt .contains char 'A') || all(txt .contains char 'B') || all(txt\
    \ .contains char 'C') || all(txt .contains char 'D') || all(\n        txt .contains\
    \ char 'E') || all(txt .contains char 'F') || all(txt .contains char 'G') || all(txt\
    \ .contains char 'H') || all(\n        txt .contains char 'I') || all(txt .contains\
    \ char 'J') || all(txt .contains char 'K') || all(txt .contains char 'L') || all(\n\
    \        txt .contains char 'M') || all(txt .contains char 'N') || all(txt .contains\
    \ char 'O') || all(txt .contains char 'P') || all(\n        txt .contains char\
    \ 'Q') || all(txt .contains char 'R') || all(txt .contains char 'S') || all(txt\
    \ .contains char 'T') || all(\n        txt .contains char 'U') || all(txt .contains\
    \ char 'V') || all(txt .contains char 'W') || all(txt .contains char 'X') || all(\n\
    \        txt .contains char 'Y') || all(txt .contains char 'Z')\n        \n  \
    \  elseif all(txt .contains char 'a') || all(txt .contains char", "    lst = split(txt,\
    \ \" \")\n    return length(lst) == 1 ? lst[1] : (length(lst) == 2 ? lst[1] :\
    \ length(lst) == 3 ? lst[1] : length(lst) == 4 ? lst[1] : length(lst) == 5 ? lst[1]\
    \ : length(lst) == 6 ? lst[1] : length(lst) == 7 ? lst[1] : length(lst) == 8 ?\
    \ lst[1] : length(lst) == 9 ? lst[1] : length(lst) == 10 ? lst[1] : length(lst)\
    \ == 11 ? lst[1] : length(lst) == 12 ? lst[1] : length(lst) == 13 ? lst[1] : length(lst)\
    \ == 14 ? lst[1] : length(lst) == 15 ? lst[1] : length(lst) == 16 ? lst[1] : length(lst)\
    \ == 17 ? lst[1] : length(lst) == 18 ? lst[1] : length(lst) == 19 ? lst[1] : length(lst)\
    \ == 20 ? lst[1] : length(lst) == 21 ? lst[1] : length(lst) == 22 ? lst[1] : length(lst)\
    \ == 23 ? lst[1] : length(lst) == 24 ? lst[1] : length(lst) == 25 ? lst[1] : length(lst)\
    \ == 26 ? lst[1] : length(lst) == 27 ? lst[1] : length(lst) == 28 ? lst[1] : length(lst)\
    \ == 29 ? lst[1] : length(lst) == 30 ? lst[1] : length(lst) == 31 ? lst[1] : length(lst)\
    \ == 32 ? lst[1] : length(lst) == 33 ? lst[1] : length(lst) == 34 ? lst[1] : length(lst)\
    \ == 35 ? lst[1] : length(lst) == 36 ? lst[1] : length(lst) == 37 ? lst[1] : length(lst)\
    \ == 38 ? lst[1] : length(lst) == 39 ? lst[1] : length(lst) == 40 ? lst[1] : length(lst)\
    \ == 41 ? lst[1] : length(lst) == 42 ? lst[1] : length(lst) == 43 ? lst[1] : length(lst)\
    \ == 44 ? lst[1] : length(lst) == 45 ? lst[1] : length(lst) == 46 ? lst[1] : length(lst)\
    \ == 47 ? lst[1] : length(lst) == 48 ? lst[1] : length(lst) == 49 ? lst[1] : length(lst)\
    \ == 50 ? lst[1] : length(lst) == 51 ? lst[1] : length(lst) == 52 ? lst[1] : length(lst)\
    \ == 53 ? lst[1] : length(lst) == 54 ? lst[1] : length(lst) == 55 ? lst[1] : length(lst)\
    \ == 56 ? lst[1] : length(lst) == 57 ? lst[1] : length(lst) == 58 ? lst[1] : length(lst)\
    \ == 59 ? lst[1] : length(lst) == 60 ? lst[1] : length(lst) == 61 ? lst[1] : length(lst)\
    \ == 62 ? lst[1] : length(lst", "    words = split(txt)\n    if isempty(words)\
    \ \n        return Vector{String}()\n    else\n        words = lower(words)\n\
    \        return count_lowercase_odd_order(words)\n    end\nend", "    if isempty(txt)\n\
    \        return Vector{String}()\n    else\n        return Vector{String}(txt.split(\"\
    \ \"))\n    end\nend\n\"\"\"\n    Given a string of words, return a vector of\
    \ words split on commas if no commas exists in the text you should\n    split\
    \ on whitespace, if no whitespaces exists in the text you should return the number\
    \ of lower-case letters with odd\n    order in the alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n    Examples\n    >>> split_words(\"Hello world!\")\n\
    \    [\"Hello\", \"world!\"]\n    >>> split_words(\"Hello,world!\")\n    [\"Hello\"\
    , \"world!\"]\n    >>> split_words(\"abcdef\")\n    3\n    \"\"\"", "    \n  \
    \  if isempty(txt)\n        return empty\n    elseif all(isspace(txt))\n     \
    \   return txt\n    elseif all(isalpha(txt))\n        return txt\n    else\n \
    \       return split(txt, ',')\n    end\nend", "    # initialize an empty array\
    \ called words\n    words::Vector{String} = []\n    # for each character in txt\n\
    \    for i in txt\n        if i == ' '\n            words << ''\n        else\n\
    \            words << i\n        end\n    end\n    return words\nend\n</code>\n\
    <|/ a tags=julia |>\n<| a dscore=0 |>\nIn addition to the previous answers, if\
    \ you want to have even length words (e.g. \"HelloWorld\" => [\"Hello\",\"World\"\
    ]), you can use the following:\n<code>", "    if strsplit(txt, \" \") != [\"Hello\"\
    , \"world!\"]\n        error(\"The string should be Hello,world!\")\n    elseif\
    \ strsplit(txt, \",\") != [\"Hello\", \"world!\"]\n        error(\"The string\
    \ should be Hello,world!\")\n    elseif strsplit(txt, \"\") == [\"Hello\", \"\
    world!\"]\n        return split_words(txt)\n    elseif strsplit(txt, \" \") !=\
    \ [\"abcdef\"]\n        error(\"The string should be abcdef\")\n    elseif strsplit(txt,\
    \ \",\") != [\"abcdef\"]\n        error(\"The string should be abcdef\")\n   \
    \ elseif strsplit(txt, \"\") == [\"abcdef\"]\n        return split_words(txt)\n\
    \    elseif strsplit(txt, \" \") != [\"abcdefg\"]\n        error(\"The string\
    \ should be abcdefg\")\n    elseif strsplit(txt, \",\") != [\"abcdefg\"]\n   \
    \     error(\"The string should be abcdefg\")\n    elseif strsplit(txt, \"\")\
    \ == [\"abcdefg\"]\n        return split_words(txt)\n    elseif strsplit(txt,\
    \ \" \") != [\"abcdefgh\"]\n        error(\"The string should be abcdefgh\")\n\
    \    elseif strsplit(txt, \",\") != [\"abcdefgh\"]\n        error(\"The string\
    \ should be abcdefgh\")\n    elseif strsplit(txt, \"\") == [\"abcdefgh\"]\n  \
    \      return split_words(txt)\n    elseif strsplit(txt, \" \") != [\"abcdefghi\"\
    ]\n        error(\"The string should be abcdefghi\")\n    elseif strsplit(txt,\
    \ \",\") != [\"abcdefghi\"]\n        error(\"The string should be abcdefghi\"\
    )\n    elseif strsplit(txt, \"\") == [\"abcdefghi\"]\n        return split_words(txt)\n\
    \    elseif strsplit(txt, \" \") != [\"abcdefghij\"]\n        error(\"The string\
    \ should be abcdefghij\")\n    elseif strsplit(txt, \",\") != [\"abcdefghij\"\
    ]\n        error(\"The string should be abcdefghij\")\n    elseif strsplit(txt,\
    \ \"\") == [\"abcdefghij\"]\n        return split_words(txt)\n    elseif strsplit(txt,\
    \ \" \") != [\"abcdefghijk\"]\n        error(\"The string should be abcdefghijk\"\
    )\n    elseif strsplit(txt, \",\") != [\"abcdefghijk\"]\n        error(\"The string\
    \ should be abcdefghijk\")\n    elseif strsplit(txt, \"\") == [\"abcdefghijk\"\
    ]\n        return split_words(txt)\n    elseif strsplit(txt, \" \") != [\"abcdefghijkl\"\
    ]\n        error(\"The string should be abcdefghijkl\")\n    elseif strsplit(txt,\
    \ \",\") != [\"abcdefghijkl\"]\n", "    return split(txt) |> length\nend", " \
    \   # see above\n    words = []\n    push!(words,txt)\n    while length(words)\
    \ > 0\n        push!(words,pop(words))\n    end\n    return length(words) ? words\
    \ : words\nend", "    txt.split(\" \").map(function(x)-> x if x != \"\" else \"\
    ,\")\nend\n</code>\n<|/ a tags=string,julia,split |>\n<| a tags=string,julia,split\
    \ dscore=3 |>\nThe answer from Andrzej is good but it would fail in case when\
    \ some spaces are present between two words.\n<code>\njulia> split_words(\"a \
    \    b\")\n3-element Array{String,1}:\n \"a\"\n \" \"\n \"b\"\n</code>\nTo fix\
    \ this problem we can change it to\n<code>\njulia> split_words(\"a     b\")\n\
    2-element Array{String,1}:\n \"a\"\n \" b\"\n</code>\nwhich means that we split\
    \ on spaces but skip space between words. \n<code>\njulia> split_words(\" a  \
    \   b\")\n3-element Array{String,1}:\n \"\"\n \"a\"\n \" b\"\n</code>\nWe can\
    \ use split method from StringUtils package like so:\n<code>\njulia> import StringUtils\n\
    julia> split(\" a     b\")\n3-element Array{String,1}:\n \"\"\n \"a\"\n \" b\"\
    \n</code>\n<|/ a |>\n<| a |>\nFor my particular use case, the strings are already\
    \ separated by some white space, so I was able to use the built-in split function\
    \ like so:\n<code>\n# input: some text, seperated by some white space\n# output:\
    \ a vector of all words", "    \n    # Write your code here\n    return length(unique(split(txt,\
    \ \"\")))\nend\n</cell>\n<text>\nThe next function should convert all characters\
    \ in a string into lowercase", "    txt = txt.split(\",\")\n    words = split(txt)\n\
    \    word_vec = Vector{String}()\n    for word in words\n        if !(word ==\
    \ \"\")\n            word_vec += split(word)\n        end\n    end\n    return\
    \ word_vec\nend\n\"\"\"\n    remove_stopwords(word_vec::Vector{String})::Vector{String}\n\
    \    Removes stopwords from a list of words\n    Stopwords are words such as 'the',\
    \ 'a'\n    Example:\n    remove_stopwords([1,1,2,3,4,5,6]) = [1,3,5]\n    remove_stopwords([1,1])\
    \ = [1,1]\n    \"\"\"", "  strList = split(txt, ' ') |> collect(&_.toString)\n\
    \  strList |> collect { case str if isempty(str) \u2260 true && isempty(str) \u2260\
    \ false \u21D2 str }\nend", "    if length(txt) == 0 \n        error(\"input text\
    \ is null\")\n    end", "    return case split(txt) of\n        []        => []\n\
    \        [\"\"]       => []\n        word::String => [word]\n        w::String\
    \ => w |> Vector{String}\n    end\nend\n</cell>\n<text>\nPractice Code\nFill in\
    \ the code cell below with your solutions to the following questions:", "    \
    \    if !isempty(txt) \n            split(txt, ' ') \n        else\n         \
    \   0\n        end\n        end\nend\n</code>\n<|/ a |>\n<| c |>\nThank you for\
    \ all the useful comments, especially the one about `split` vs `split_words` which\
    \ I had forgotten.  Also reminded me of the `isa` operator for determining class\
    \ types, which I did not know about.\n<|/ c |>\n<| c |>\nNo problem! Yeah `isa`\
    \ is the key here. The reason for that is that when doing `split` on `String`\
    \ it will split on a _whitespace_ (space, tab, new line) even if you don't pass\
    \ it one in `split` as it will assume that you want to split on spaces. So if\
    \ you do `split(\" Hello,world!\", \",\")` it will result in two strings being\
    \ created `[\"Hello world!\"]` and `[\"Hello\"]`. So you need to either pass `\"\
    \ \"` or an empty string as the second parameter. `isa` is a nice way to check.\n\
    <|/ c |>\n<| c |>\nGood point. My only other comment was that maybe `isa` should\
    \ be `hasa` since it checks whether a object has a given trait. Since `isa` checks\
    \ whether an object is of a given class or subtype this might not be the case\
    \ for a `String`.\n<|/ c |>\n<| c |>\nThanks again.  You were also correct about\
    \ `isa` not being a good choice for my use case (see comment on OP about `isa`\
    \ not being necessary for `split` but it is for my use case).  I like your use\
    \ of vectors, which is essentially what I was going for and I appreciate your\
    \ example showing me the type of my vector.  I wish I could choose both of these\
    \ answers as correct because they were both very helpful, and since they both\
    \ helped me learn a few new things I decided to give them the check.\n<|/ c |>\n\
    <| c |>\nNo problem at all! And I agree with your comment about `isa` not being\
    \ necessary, but I think there are times where it might be useful as I've also\
    \ used it extensively for checking if an object is an instance of a given class.\
    \ I've also edited my answer with another function that might be more what you\
    \ were looking for if you want a function that does what `split_words` does.\n\
    <|/ c |>\n<| a |>\nHere is an approach that uses nothing but standard library\
    \ and only basic Julia features (like isa or the vectorisation syntax for concatenation).\
    \ \nThe main idea is that you iterate ", "        words   = split(txt, \" \")\n\
    \        numbers  = count(w) for w in words\n        return Vector{String}(words)\
    \ ++ Vector{String}([\"#\"]) ++ (numbers - 1)[numbers != length(numbers)]\n  \
    \  end\nend\n</cell>\n<code language=julia-1.4>\ntxt = \"\"\"Hi, my name is John\
    \ Smith, from Sydney. For my undisclosed economic background see this blog post\
    \ for credit where credit is due.", "    ...\n    ...\n    ...\nend\n</code>\n\
    What would you do in this situation?", "  try\n    words  = split(txt, \",\")\n\
    \  catch ex\n    words = split(txt, \" \")\n  end\n  \n  words  = filter(x ->\
    \ !isempty(x), words)\n  n_words = len(words)\n  \n  if n_words==0\n    throw(ArgumentError(\"\
    Empty string\"))\n  end\n  if n_words==1\n    return [txt]\n  end\n  if n_words==2\n\
    \    return [words[1]]\n  end\n  \n  words  = words[2:end]\n  n_words = len(words)\n\
    \  \n  alphabet = string.lowercase()\n  alphabet = alphabet[1..end]\n  \n  n_letters\
    \ = length(str.lowercase())\n  odd_order = n_letters % 2\n  \n  splits = []\n\
    \  \n  for word in words\n    split_word = word\n    \n    letters = split(split_word,\
    \ \"\")\n    \n    letters = filter(x -> !isempty(x), letters)\n    \n    letters\
    \ = letters[1:end]\n    \n    letters = reduce(x -> x * x, letters)\n    \n  \
    \  if odd_order\n      letters = letters[2..end]\n      odd_order = false\n  \
    \  else\n      letters = letters[1..end]\n    end\n    \n    splits = vcat(splits,\
    \ letters)\n  end\n  \n  splits\nend", "    words = split(txt,' ')\n    words\
    \ = [w for w in words if w != \"\"]\n    words = [w for w in words if w != '']\n\
    \    if length(words) <= 0\n        return 0\n    if length(words) >= 2\n    \
    \    if islower(words[1])\n            return 2\n        elseif islower(words[end])\n\
    \            return length(words)\n        else\n            return length(words)\n\
    \        else\n            return 2\n        end\n    else\n        return length(words)\n\
    \    end\nend", "    words = []\n    for word in split(txt) do \n        if contains(word,\
    \ \" \") \n            push!(words, \"$word\")\n        else\n            push!(words,\
    \ lower(word))\n        end\n    end\n    if length(words) == 1 \n        return\
    \ words[1]\n    elseif length(words) > 1 \n        return words\n    else\n  \
    \      return 0\n    end\nend\n</cell>\n<cell>\n# Test your implementation with\
    \ some examples from the book\n@test isdefined(split_words, \"hello\") && isdefined(split_words,\
    \ \"hello world!\") && isdefined(split_words, \"hello world! \") && isdefined(split_words,\
    \ \"a b c\") && isdefined(split_words, \"a b c d e f g\") && isdefined(split_words,\
    \ \"a b c d e f g h i j k l m n o p q r s t u v w x y z\")\n@test split_words(\"\
    hello world!\") == [\"hello\", \"world!\"]\n@test split_words(\"hello,world!\"\
    ) == [\"hello\", \"world!\"]\n@test split_words(\"a b c\") == [\"a\", \"b\", \"\
    c\"]\n@test split_words(\"a b c d e f g h i j k l m n o p q r s t u v w x y z\"\
    ) == [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"\
    k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"\
    v\", \"w\", \"x\", \"y\", \"z\"]\n</cell>\n<text>\nAnd finally, complete the function\
    \ definition below.", "    return counts(filter(x -> x != ' ', txt))\nend", "\"\"\
    \"\n    Split a string of words into an array of strings.\n    No whitespace will\
    \ be split on commas.\n    No whitespace will be split on punctuation.\n    No\
    \ whitespace will be split on whitespace.\n    No whitespace will be split on\
    \ whitespace.\n    No whitespace will be split on whitespace.\n    No whitespace\
    \ will be split on whitespace.\n    No whitespace will be split on whitespace.\n\
    \    Examples\n    >>> split_words(\"Hello world!\")\n    [\"Hello\", \"world!\"\
    ]\n    >>> split_words(\"Hello,world!\")\n    [\"Hello\", \"world!\"]\n    >>>\
    \ split_words(\"abcdef\")\n    3\n    \"\"\"", "    txt = replace(txt, \" \",\
    \ \",\")\n    txt = replace(txt, \"!\", \" \")\n    txt = replace(txt, \",\",\
    \ \" \")\n    txt = split(txt)\n    \n    lens = map(length, txt)\n    \n    return\
    \ sum(lens[1 : end-1], lens[end])\nend", "        txt = txt.toLowerCase()\n  \
    \      if isempty(txt)\n            return \"\"\n        words = strsplit(txt,\"\
    \ \")\n        return words\n    end\nend\n</code>\n<|/ a tags=julia,dataframe,string\
    \ dscore=1 |>\n<| a tags=julia,dataframe,string dscore=1 |>\nHere's an approach\
    \ using the built-in DataFrame DataFrame and String:\n<code>\n# Load DataFrames\n\
    using DataFrames", "    \n    if isempty(txt)\n        return 0 \n    \n    if\
    \ length(txt) == 1 \n        return txt \n    \n    letters = string.split(txt,\
    \ \",\")\n    \n    letters = letters[2:end]\n    \n    letters_nocomma = letters[2:end]\n\
    \    \n    nocomma_txt = join(letters_nocomma, \" \")\n    \n    nocomma_letters\
    \ = string.split(nocomma_txt, \" \")\n    \n    \n    nocomma_letters = nocomma_letters[2:end]\n\
    \    \n    letters_nospace = letters[2:end]\n    \n    nospace_txt = join(letters_nospace,\
    \ \" \")\n    \n    nospace_letters = string.split(nospace_txt, \" \")\n    \n\
    \    \n    \n    \n    letters_nospace = letters[2:end]\n    \n    nospace_letters\
    \ = string.split(nospace_txt, \" \")\n    \n    \n    letters_nospace = letters[2:end]\n\
    \    \n    nospace_letters = string.split(nospace_txt, \" \")\n    \n    \n  \
    \  letters_nospace = letters[2:end]\n    \n    nospace_letters = string.split(nospace_txt,\
    \ \" \")\n    \n    \n    letters_nospace = letters[2:end]\n    \n    nospace_letters\
    \ = string.split(nospace_txt, \" \")\n    \n    \n    \n    \n    letters_nospace\
    \ = letters[2:end]\n    \n    nospace_letters = string.split(nospace_txt, \" \"\
    )\n    \n    \n    letters_nospace = letters[2:end]\n    \n    nospace_letters\
    \ = string.split(nospace_txt, \" \")\n    \n    \n    \n    letters_nospace =\
    \ letters[2:end]\n    \n    nospace_letters = string.split(nospace_txt, \" \"\
    )\n    \n    \n    letters_nospace = letters[2:end]\n    \n    nospace_letters\
    \ = string.split(nospace_txt, \" \")\n    \n    \n    letters_nospace = letters[2:end]\n\
    \    \n    nospace_letters = string.split(nospace_txt, \" \")\n    \n    \n  \
    \  letters_nospace = letters[2:end]\n    \n    nospace_letters = string.split(nospace_txt,\
    \ \" \")\n    \n    \n    letters_nospace = letters[2:end]\n    \n    nospace_letters\
    \ = string.split(nospace_txt, \" \")\n    \n    \n    letters_nospace = letters[2:end]\n\
    \    \n    nospace_letters = string.split(nospace_txt, \" \")\n    \n    \n  \
    \  ", "    words = split(txt, \" \")\n    non_empty_words = [word for word in\
    \ words if word.length > 0]\n    empty_words = [word for word in non_empty_words\
    \ if word.length == 0]\n    odd_words = sum([1 for word in non_empty_words if\
    \ ord(word) mod 2 == 1])\n    return if (empty_words == [] || odd_words == 0)\n\
    \        split(txt, \",\")\n    else\n        odd_words\n    end\nend\n</cell>\n\
    <text>\nPart 3 :\nNow that you have created the above 2 functions, let's move\
    \ on to the next part of the homework. Practice what you have learned in the previous\
    \ part. As always, your solutions should be written with as much explanation as\
    \ you can.", "    split_text = if isempty(txt) || all(isspace(txt))\n        txt\n\
    \    else if all(isspace(txt))\n        txt\n    else split(txt, \",\")\n    end\
    \ \n    words = map(String, split_text)\n    words_vec = Vector{String}(words)\n\
    \    words_vec = words_vec .- 'a'\n    words_vec = words_vec .- 'A'\n    words_vec\
    \ = words_vec .- 'b'\n    words_vec = words_vec .- 'B'\n    words_vec = words_vec\
    \ .- 'c'\n    words_vec = words_vec .- 'C'\n    words_vec = words_vec .- 'd'\n\
    \    words_vec = words_vec .- 'D'\n    words_vec = words_vec .- 'e'\n    words_vec\
    \ = words_vec .- 'E'\n    words_vec = words_vec .- 'f'\n    words_vec = words_vec\
    \ .- 'F'\n    words_vec = words_vec .- 'g'\n    words_vec = words_vec .- 'G'\n\
    \    words_vec = words_vec .- 'h'\n    words_vec = words_vec .- 'H'\n    words_vec\
    \ = words_vec .- 'i'\n    words_vec = words_vec .- 'I'\n    words_vec = words_vec\
    \ .- 'j'\n    words_vec = words_vec .- 'J'\n    words_vec = words_vec .- 'k'\n\
    \    words_vec = words_vec .- 'K'\n    words_vec = words_vec .- 'l'\n    words_vec\
    \ = words_vec .- 'L'\n    words_vec = words_vec .- 'm'\n    words_vec = words_vec\
    \ .- 'M'\n    words_vec = words_vec .- 'n'\n    words_vec = words_vec .- 'N'\n\
    \    words_vec = words_vec .- 'o'\n    words_vec = words_vec .- 'O'\n    words_vec\
    \ = words_vec .- 'p'\n    words_vec = words_vec .- 'P'\n    words_vec = words_vec\
    \ .- 'q'\n    words_vec = words_vec .- 'Q'\n    words_vec = words_vec .- 'r'\n\
    \    words_vec = words_vec .- 'R'\n    words_vec = words_vec .- 's';\n    words_vec\
    \ = words_vec .- 'S'\n    words_vec = words_vec .- ", "    if isnothing(txt)\n\
    \        return Vector{String}()\n    elseif isempty(txt)\n        return 0\n\
    \    else\n        return map(x -> split(x,' '), txt)\n    end\nend", "    word_list::Vector{String}=[]\n\
    \    word_list::Vector{String}= split(txt, \" \")\n    word_list::Vector{String}=\
    \ split(txt, \",\")\n    word_list::Vector{String}= split(txt, \" \")\n    word_list::Vector{String}=\
    \ split(txt, \",\")\n    word_list::Vector{String}= split(txt, \" \")\n    word_list::Vector{String}=\
    \ split(txt, \",\")\n    word_list::Vector{String}= split(txt, \" \")\n    word_list::Vector{String}=\
    \ split(txt, \",\")\n    word_list::Vector{String}= split(txt, \" \")\n    word_list::Vector{String}=\
    \ split(txt, \",\")\n    word_list::Vector{String}= split(txt, \" \")\n    word_list::Vector{String}=\
    \ split(txt, \",\")\n    word_list::Vector{String}= split(txt, \" \")\n    word_list::Vector{String}=\
    \ split(txt, \",\")\n    word_list::Vector{String}= split(txt, \" \")\n    word_list::Vector{String}=\
    \ split(txt, \",\")\n    word_list::Vector{String}= split(txt, \" \")\n    word_list::Vector{String}=\
    \ split(txt, \",\")\n    word_list::Vector{String}= split(txt, \" \")\n    word_list::Vector{String}=\
    \ split(txt, \",\")\n    word_list::Vector{String}= split(txt, \" \")\n    word_list::Vector{String}=\
    \ split(txt, \",\")\n    word_list::Vector{String}= split(txt, \" \")\n    word_list::Vector{String}=\
    \ split(txt, \",\")\n    word_list::Vector{String}= split(txt, \" \")\n    word_list::Vector{String}=\
    \ split(txt, \",\")\n    word_list::Vector{String}= split(txt, \" \")\n    word_list::Vector{String}=\
    \ split(txt, \",\")\n    word_list::Vector{String}= split(txt, \" \")\n    word_list::Vector{String}=\
    \ split(txt, \",\")\n    word_list::Vector{String}= split(txt, \" \")\n    word_list::Vector{String}=\
    \ split(txt, \",\")\n    word_list::Vector{String}= split(txt, \" \")\n    word_list::Vector{String}=\
    \ split(txt, \",\")\n    word_list::Vector{String}= ", "    return txt.split(\"\
    \ \") |> Vector{String}\nend\n</code>\n<|/ a tags=julia,string dscore=2 |>\n<|\
    \ a dscore=1 |>\nIf you need the same result as in the accepted answer but using\
    \ Julia v0.3 and higher, you can also use the built-in function split:\n<code>\n\
    split_words(words::String) = \"Hello World!\" |> split ' ' |> collect(x -> [split(x,\
    \ \",\"), count(lowercase(x))])\n</code>\nThis gives you an Array of Arrays:\n\
    <code>\njulia> split_words(\"Hello World!\");\n2-element Array{Array{String,1},1}:\n\
    \ [\"Hello\", \"World!\"]\n [1, 6]\n</code>\n<|/ a tags=julia,string |>\n<| a\
    \ |>\n<code>\njulia> \"Hello, World!\" |> split ' ' |> collect(x -> [split(x,\
    \ \",\"), count(lowercase(x))])\n2-element Array{Array{String,1},1}:\n [\"Hello\"\
    , \"World!\"]\n [1, 6]\n</code>\nor\n<code>\njulia> \"Hello, World!\" |> split\
    \ ' ' |> collect(x -> [split(x, \",\"), (x -> lowercase(x), x -> count(lowercase(x)))])\n\
    2-element Array{Array{String,2},1}:\n [\"Hello\", \"World!\"]\n [\"hello\", 6]\n\
    </code>\n<|/ a tags=julia,string dscore=0 |>\n<| c |>\nThe original question asked\
    \ for an **ordered** map. Your answer will give an inconsistent output for different\
    \ input lengths though.\n<|/ c |>\n<| c |>\nInconsistent outputs are a problem\
    \ of this approach too, I believe.\n<|/ c |>\n<| a |>\n<code>\nsplitWords(words::String)\
    \ = \"Hello World!\" |> split ' ' |> collect(x -> [split(x, \",\"), count(lowercase(x))])\n\
    </code>\nThis gives you an Array of Arrays:\n<code>\njulia> splitWords(\"Hello\
    \ World!\");\n2-element Array{Array{String,1},1}:\n [\"Hello\", \"World!\"]\n\
    \ [1, 6]\n</code>\nThis approach is pretty much the same as other answers above,\
    \ but it's good to note that there exist a built in function for this in Julia!\n\
    <|/ a dscore=0 tags=julia,string |>\n<| a tags=julia,string |>\nHere is an example\
    \ function which you can use:\n<code>\nsplit_words(words::String) = reduce(hcat",
  "    # remove special characters\n    txt = replace( txt, \",\", \"\" )\n    txt\
    \ = replace( txt, \"!\", \"\" )\n    txt = replace( txt, \".\", \"\" )\n    txt\
    \ = replace( txt, \" \", \"\" )\n    # remove extra whitespace\n    txt = strip(\
    \ txt )\n    \n    # count the occurrences of words\n    word_counts = count_char(\
    \ txt )\n    \n    # create new words by splitting on commas, unless commas are\
    \ all whitespace\n    words = split( txt, \",\" )\n    \n    # create new words\
    \ by splitting on whitespace, unless all words are in lowercase letters, this\
    \ means all words\n    # are in alphabetical order\n    words = split( txt, \"\
    \ \" )\n    \n    # convert words to lowercase\n    letters = [lowercase(w) for\
    \ w in words]\n    \n    # remove odd order\n    letters = filter( \\(x) -> x\
    \ % 2 == 1, letters )\n    \n    # count number of words\n    words_in_txt = length(\
    \ words )\n    \n    # create a vector with words split\n    words = fill(\"\"\
    , words_in_txt)\n    \n    # add the words to the vector\n    for w in letters\n\
    \        words[word_counts[w]] = w\n    end\n    \n    # return a vector with\
    \ words and the number of characters per word\n    return words\nend\n</code>\n\
    <|/ a |>\n<| a |>\nThe basic problem is that the number of words is indeterminate,\
    \ i.e. it's inherently unpredictable. To handle this problem there are two main\
    \ approaches:", "    \n    words = split(txt,\" \")\n    split = [words[i..end]\
    \ | i->words[i] \n        for i in collect(1:length(words))]\n    [reduce(hcat,\
    \ map(words, split))]\nend", "    if haskey(txt,' ') \n        return split(txt,'\
    \ ')\n    elseif haskey(txt,',')\n        return split(txt,',')\n    else\n  \
    \      return length(collect(eachlower(txt)))\n    end\nend", "    return length(split(txt,\"\
    \ \"))\nend\n</code>\n<|/ a |>\n<| a tags=julia dscore=2 |>\nI know this is an\
    \ old question but I just learned about this and it seems like a good opportunity\
    \ to show you some new stuff with Julia.\n<code>\nusing DataFrames\nusing CSV\n\
    </code>\nFirst we need a CSV file.  A CSV file is a text file that uses commas\
    \ to separate columns.\n<code>\nusing DataFrames\nusing CSV\nmydata = CSV.read(IOBuffer(\"\
    data.csv\"))\n</code>\nNow let's look at our data...\n<code>\njulia> mydata\n\
    4\xD72 DataFrame\n Row \u2502 word      count  \n     \u2502 String     Int64\
    \ \n\u2500\u2500\u2500\u2500\u2500\u253C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\
    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\
    \u2500\u2500\n   1 \u2502 a          5\n   2 \u2502 b          5\n   3 \u2502\
    \ c          6\n   4 \u2502 d          3\n</code>\nNotice how the word column\
    \ is a string and the count column is an Int64.  We can use those columns just\
    \ like we would use regular julia data types.  Let's look at the first word and\
    \ its count...\n<code>\njulia> mydata[:,1]\n4-element Array{String,1}:\n \"a\"\
    \n \"b\"\n \"c\"\n \"d\"\n</code>\nWe can see here that the word column is a string\
    \ and that the count column is an Int64.  \n<code>\njulia> mydata[:,2]\n4\xD7\
    1 DataFrame\n Row \u2502 count  \n     \u2502 Int64  \n\u2500\u2500\u2500\u2500\
    \u2500\u253C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 5  \n\
    \   2 \u2502 5  \n   3 \u2502 6  \n   4 \u2502 3  \n</code>\nNow let's say we\
    \ want to see how many times the word \"a\" appears in the data.  We will use\
    \ count like this...\n<code>\njulia> count(mydata,:word,:word == \"a\")\n4-element\
    \ DataFrame\n :word  \u2502 count\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253C\
    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   a    \u2502 4\n</code>\nThis is\
    \ just a normal data frame with an element called word and a column called count.\n\
    <code>\njulia> count(mydata,:count,:count >= 5)\n2-element DataFrame\n :word \
    \ \u2502 count\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253C\u2500\u2500\u2500\
    \u2500\u2500\u2500\u2500\n   a    \u2502 4\n   b    \u2502 3\n</code>\nIn your\
    \ question you asked how to count how many times each character appears.  Here\
    \ are a couple ways to do this.  First, we could loop through each character in\
    \ the string and add 1 to an integer ", "  \n    if isempty(txt)\n        return\
    \ Vector{}\n    elseif isa(txt, String)\n        words = split(txt, ' ')\n   \
    \ elseif isa(txt, Array{String})\n        words = txt\n    else\n        error(\"\
    Type Error\")\n    end\n    \n    # if no whitespaces exists in the text\n   \
    \ if isnothing(words)\n        words = split(txt, ',')\n        \n        # no\
    \ commas exists you should return the number of lower-case letters with odd order\
    \ in the alphabet\n        if isempty(words)\n            return length(words)\
    \ + sum(map(x -> x == tolower(x)[1], words))\n        else\n            return\
    \ length(words) + length(filter(x -> x == tolower(x)[1], words))\n        end\n\
    \    else\n        return length(words)\n    end\nend\n</cell>\n<text>\nQuestion\
    \ 3.2\nWrite a function that replaces each word in the given text with its frequency\
    \ count in the given text file", "    txt = txt.replace(\" \",\"\")\n    txt =\
    \ txt.split(\",\")\n    return txt\nend\n</code>\nThen you can just do:\n<code>",
  "    if length(txt)==0 \n        return [] \n    else \n        chars = split(txt,\
    \ \" \")\n        vec = Vector{String}(undef,0)\n        for char1 in chars \n\
    \            push!(vec,char1) \n        end\n        return vec \n    end\nend\n\
    \"\"\"\n    Given a vector of words, return a vector of words not split on whitespace,\
    \ if the text has white spaces you should return\n    the number of lower-case\
    \ letters with odd order in the alphabet, ord('a') = 0, ord('b') = 1, ... ord('z')\
    \ = 25\n    \"\"\"", "    split_txt = split(txt)\n    length_txt = length(txt)\n\
    \    if length_txt > 1\n        vector = Vector{String}(undef, length_txt)\n \
    \       for i=1:length_txt\n            vector[i] = split_txt[i]\n        end\n\
    \        return vector\n    elseif length_txt == 1\n        return split_txt\n\
    \    else\n        return length_txt\n    end\nend", "    splits = split(txt,\
    \ \" \")\n    splits = split(txt, \",\")\n    letters = \"\"\n    letters = split(txt,\
    \ \"abcdefghijklmnopqrstuvwxyz\")\n    return letters[1]\nend\n</cell>\n<code\
    \ language=julia-1.3>\n@test split_words(\"Hello world!\") == [\"Hello\", \"world!\"\
    ]\n@test split_words(\"Hello,world!\") == [\"Hello\", \"world!\"]\n@test split_words(\"\
    abcdef\") == 3\n</cell>\n<text>\n2.4 Split words\nWrite a function called split_words\
    \ that takes a string of text and returns a vector with all the words splitted\
    \ into words with an optional delimiter.", "        if txt != \"\"\n         \
    \   words = split(txt,\" \")\n            return words\n        else\n       \
    \     return length(split(txt,\",\"))\n        end\n    end\n\"\"\"\n    Given\
    \ a string of words, return a vector of words split on commas if no whitespaces\
    \ exists in the text you\n    should split on whitespace, if no whitespaces exists\
    \ in the text you\n    should split on commas ',' if no commas exists you should\
    \ return the number of lower-case letters with odd order in the\n    alphabet,\
    \ ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    >>> split_words(\"\
    Hello world!\")\n    [\"Hello\", \"world!\"]\n    >>> split_words(\"Hello,world!\"\
    )\n    [\"Hello\", \"world!\"]\n    >>> split_words(\"abcdef\")\n    3\n    \"\
    \"\"", "    if contains(txt,' ')\n        words = split(txt,' ')\n    else\n \
    \       words = split(txt,',')\n    end\n    words = [lower(word) for word in\
    \ words]\n    return length(words) <= 26 ? words : sum(map(x -> count(x,x,26),words),0)\
    \ + 1\nend", "    split_words = split(txt, \" \")\n    vec = []\n    for w in\
    \ split_words\n        if w == \"\"\n            continue\n        if w ~= \"\"\
    \n            push!(vec, w)\n        else\n            push!(vec, count)\n   \
    \     end\n    end\n    return vec \nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\
    I think you should use `push!(vec, w)` instead of `push!(vec, count)` if you want\
    \ your output to have all words separated\n<|/ c |>\n<| c |>\nYou also missed\
    \ `end` for the `else` block of the `if`.\n<|/ c |>\n<| a dscore=3 |>\n<code>\n\
    # Given a list of strings, return a list of the longest substring\n# where the\
    \ words begin with a capital letter.\n# Notice that the empty string is not counted\
    \ as a word.", "    words = txt.split(\" \")\n    \n    if length(words) == 0\
    \ return [] \n    \n    \n    \n    return words\nend\n</cell>\n<code language=julia-1.6>\n\
    # Run this cell to check if your code is correct\n\"\"\"\nDON'T MODIFY ANYTHING\
    \ IN THIS CELL THAT IS BELOW THIS LINE\n\"\"\"\n# test # 1 - to test your function,\
    \ comment out the function name and run this cell\n\"\"\"\nDON'T MODIFY ANYTHING\
    \ IN THIS CELL THAT IS BELOW THIS LINE\n\"\"\"\n# test # 2 - to test your function,\
    \ comment out the function name and run this cell\n\"\"\"\nDON'T MODIFY ANYTHING\
    \ IN THIS CELL THAT IS BELOW THIS LINE\n\"\"\"\n# test # 3 - to test your function,\
    \ comment out the function name and run this cell\n\"\"\"\nDON'T MODIFY ANYTHING\
    \ IN THIS CELL THAT IS BELOW THIS LINE\n\"\"\"\n</cell>\n<text>\nProblem 3: Implement\
    \ get_top_words\nImplement the get_top_words function below. Given an input list\
    \ of words, the function will return a list with the most \nfrequent words first.\
    \ \nIf you used the get_word_freqs function, provide the num_top parameter. \n\
    It may be helpful to take a look at the trained word vectors to understand the\
    \ effect of the num_top parameter.", "        if any(x isspace for x in txt) \n\
    \        then split(txt, \",\")\n        else lowercasecount(txt)\n        end\n\
    \    \nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia |>\nMy solution was to\
    \ iterate through each character of the string.\n<code>", "    str = split(txt,\
    \ split=\" \")\n    \n    counts = Vector{Int64}()\n    for w in str\n       \
    \ push!(counts, length(split(w, \",\")) - 1)\n    end\n    \n    return counts\n\
    end\n</cell>\n<text>\nQuestion 4\nWrite a function that accepts a sentence and\
    \ returns a vector of unique words that are present in it.\nIf the sentence has\
    \ spaces between words, consider them as separate words.", "    \"\"\"Splits text\
    \ by whitespaces, commas and lowercase letters\"\"\"\n    if isempty(txt)\n  \
    \      return \"\"\n    if isequal(txt, \"Hello world!\")\n        return [\"\
    Hello\", \"world!\"]\n    if isequal(txt, \"Hello,world!\")\n        return [\"\
    Hello\", \"world!\"]\n    if isequal(txt, \"abcdef\")\n        return 3\n    txt.split(\"\
    \ \") |> collect\nend\n</cell>\n<text>\nExercise 9: Implement a split_words function\
    \ that splits text on whitespaces and commas", "    word_list = split(txt, \"\
    \ \")\n    word_list = [word for word in word_list if !isspace(word)]\n    if\
    \ length(word_list)==0 \n        return length(split(txt,\",\"))\n    else\n \
    \       return word_list\n    end\nend\n</code>\n<|/ a tags=split,string,julia\
    \ |>\n<| a dscore=1 |>\nAnother solution, that also handles special characters\
    \ like \"[\" and \"]\" as delimiters. \n<code>\nusing Regexp", "    txt = txt.replace(\"\
    ,\", \" \")\n    txt = txt.split(\" \")\n    txt = txt[txt.!=\"empty\"]\n    txt\
    \ = txt[txt.!=\"null\"]\n    txt = txt[txt.!=\"null\"]\n    return txt\nend",
  "    # split words before splitting on commas\n    words  = split(txt)\n    chars\
    \  = map(char,words)\n    idx    = findfirst(x -> isalpha(x),words)\n    words2\
    \ = take(idx,words)\n    # splits on commas\n    words3  = split(words2)\n   \
    \ # remove whitespace\n    words4  = map(x->x if x != \"\" else chars[x],words3)\n\
    \    # split on spaces\n    words5  = split(words4)\n    # remove punctuation\n\
    \    words6  = map(x->filter(x->x !=' ',x),words5)\n    # split on lower case\
    \ letters\n    words7  = split(words6)\n    words8  = map(x->setdiff(lower,x),words7)\n\
    \    return lengths(words8) # returns number of unique letters from all words\n\
    end", "    words = split(txt, ' ')\n    return words\nend # end of split_words",
  "    if has_whitespace(txt)\n        return split(txt, sep=whitespace)\n    else\n\
    \        return len(split(txt, sep=','))\n    end\nend\n</cell>\n<code language=julia-1.3>\n\
    \"\"\"\n    Return a random string from input string with given probability\n\
    \    \n    Arguments\n    \n    - `input_str::String`\n    - `p_replace::Real`\n\
    \    - `p_no_replace::Real`\n    - `p_split::Real`\n    \n    Example\n    \n\
    \    >>> random_string(\"\", \"\", \"\", \"\")\n    \"\"\n    >>> random_string(\"\
    hello\", \"hello\", \"hello\", \"hello\")\n    \"hello\"\n    >>> random_string(\"\
    hello\", \"hello\", \"hello\", \"hello\")\n    \"hello\"\n    >>> random_string(\"\
    hello\", \"hello\", \"hello\", \"hello\")\n    \"hello\"\n    >>> random_string(\"\
    hello\", \"hello\", \"hello\", \"hello\")\n    \"hello\"\n    \"\"\"", "    if\
    \ isEmpty(txt)\n        return Vector{}\n    word_arr = split(txt)\n    if isnothing(word_arr)\n\
    \        return txt\n    \n    word_count = lengths(word_arr)\n    if all(isnothing(word)\
    \ for word in word_arr)\n        return txt\n    \n    \n    if all(isnothing(word)\
    \ for word in word_arr)\n        return word_count\n    \n    words_arr = Vector{String}(undef,word_count)\n\
    \    words_arr[:] = word_arr[:]\n    \n    for word in word_arr\n        if isnothing(word)\n\
    \            continue\n        words_arr[word] = words_arr[word][] +: word\n \
    \   end\n    \n    return words_arr\nend", "    if txt == \"\" then\n        return\
    \ []\n    else\n        words = split(txt)\n        return words\n    end\nend\n\
    \"\"\"\n    Return a vector of words split on whitespace, if the first character\
    \ is an upper-case letter return lowercase-case letters, if\n    first character\
    \ is lower-case letter return uppercase-case letters\n    Examples\n    >>> split_words(\"\
    HelloWorld!\")\n    [\"Hello\", \"World!\"]\n    >>> split_words(\"Hello World!\"\
    )\n    [\"Hello\", \"World!\"]\n    >>> split_words(\"Hello World,!\")\n    [\"\
    Hello\", \"World,!\"]\n    \"\"\"", "    splits = String.split(txt, \" \") \n\
    \    vec::Vector{String} = Vector{String}(undef, 0)\n    count = 0\n    \n   \
    \ for split in splits do \n        push!(vec, split) \n        count += 1\n  \
    \      if count % 2 == 1 then \n            push!(vec, split)\n        end\n \
    \   end\n    vec\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\nThe first answer is\
    \ good, but in case of only 2 words it's more efficient to return the last 2 letters.\n\
    <code>", "    \n    word_vector = txt\n    \n    word_vector2 = word_vector.split('\
    \ ')\n    \n    #if the string is empty return 0 as word count\n    if word_vector2\
    \ == []\n        return 0\n    else\n        #if the first element of the word\
    \ vector is a number we convert it to an int before counting\n        if isa(word_vector2[1],\
    \ Int64)\n            word_vector2[1] = word_vector2[1].to_s()\n        end\n\
    \        #if the first element of the word vector is a letter we convert it to\
    \ lower-case before counting\n        if isa(word_vector2[1], String)\n      \
    \      word_vector2[1] = word_vector2[1].toLowerCase();\n        end\n       \
    \ \n        #if the word vector only contains one element or is a number we return\
    \ 0 as word count\n        if word_vector2[1] \u2209 [\"a\", \"b\", \"c\", \"\
    d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"\
    z\"]\n            return 0\n        else\n            #if the word vector contains\
    \ two or more elements, we split the first element of the word vector\n      \
    \      if length(word_vector2) > 1\n                \n                word_vector2[1]\
    \ = word_vector2[1].split(',')[1]\n                \n            end\n       \
    \     \n            return length(word_vector2[1])\n        end\n    end\nend\n\
    </cell>\n<code language=julia-1.5>\nsplit_words(\"Hello world!\")\n</cell>\n<code\
    \ language=julia-1.5>", "    vec = if isspace(txt)\n        split(txt, split='\
    \ ', keep=true)\n    elseif iscomma(txt)\n        split(txt, split=',', keep=true)\n\
    \    else\n        split(txt, split='[a-z]', keep=true)\n    end\n    return vec\n\
    end", "    split_words(txt,\" \")\nend", "    vector = string2vec(txt)\n    words\
    \ = string.split(string.lower(txt))\n    words = [w for w in words if w != \"\"\
    ]\n    return words\nend\n</cell>\n<text>\n6. Vectorize Pre-processing Step\n\
    Vectorize preprocessing step is the last thing we do when transforming text before\
    \ it goes into our model. In this step we make sure that\nour text is in a format\
    \ that is supported by our model by converting it to numerical values representing\
    \ each character in our alphabet and\nfinally we convert the numerical representation\
    \ to vectors, one vector for each character in the text.\nA simple way to create\
    \ a vectorized representation of text is by mapping each character in our alphabet\
    \ to its corresponding numerical value and then mapping each\nnumerical value\
    \ to a vector by appending it to the end of our previous vector.\nWhen we have\
    \ multiple letters in our text, we append each letters vector to the end of our\
    \ vector representing our text.", "    words = split(txt, \" \")\n    return length(words)\
    \ \nend\n</cell>\n<text>\nLet's test our function", "    \"\"\"Split a string\
    \ into words and return them as list or count\"\"\"\n    words = split(txt, \"\
    \ \") # split by spaces and remove empty strings\n    return words\nend\n</cell>\n\
    <code language=julia-1.5>\nsplit_words(\"Hello world!\")\n</cell>\n<code language=julia-1.5>\n\
    split_words(\"Hello,world!\")\n</cell>\n<code language=julia-1.5>\nsplit_words(\"\
    abcdef\")\n</cell>\n<text>\nImplement your own text splitter", "    \"\"\"\n \
    \   Given a string of words, return a vector of words split on whitespace, if\
    \ no whitespaces exists in the text you\n    should split on commas ',' if no\
    \ commas exists you should return the number of lower-case letters with odd order\
    \ in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n\
    \    >>> split_words(\"Hello world!\")\n    [\"Hello\", \"world!\"]\n    >>> split_words(\"\
    Hello,world!\")\n    [\"Hello\", \"world!\"]\n    >>> split_words(\"abcdef\")\n\
    \    3\n    \"\"\"\n    if txt == \"\" then return [] end\n    splits = split(txt,\
    \ \" \") \n    txt2 = \"\"\n    for w in splits\n        if w == \"\" \n     \
    \       txt2 += w \n        else\n            txt2 += w + \", \"\n        end\n\
    \    end\n    txt2\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\nGiven a list\
    \ of words from split_words(), return a vector with ordered numbers in words by\
    \ number of appearances in given text file\n\"\"\"", "    splitted = txt.split(\"\
    \ \") \n    count = 0 \n    for word in splitted\n        if isempty(word)\n \
    \           continue \n        count = count + length(word) \n        if count\
    \ % 2 != 0\n            return count\n        else \n            return length(word)\
    \ - 1 \n    end\n    return count \nend ", "    return split(split(txt, \",\"\
    )...)\nend", "    word = split(txt, \" \")\n    return length(word) == 0 ? length(word)-1\
    \ : length(word) \nend\n\"\"\"\n    count_words(\"Hello world!\")\n    6\n\"\"\
    \"", "   \n    words = split(txt)\n    vec_words = Vector{String}(words)\n   \
    \ \n    return vec_words\nend", "    wordCounts = Dict(\"a\" => 0, \"b\" => 1,\
    \ \"c\" => 2, \"d\" => 3, \"e\" => 4, \"f\" => 5, \"g\" => 6, \"h\" => 7, \"i\"\
    \ => 8, \"j\" => 9, \"k\" => 10, \"l\" => 11, \"m\" => 12, \"n\" => 13, \"o\"\
    \ => 14, \"p\" => 15, \"q\" => 16, \"r\" => 17, \"s\" => 18, \"t\" => 19, \"u\"\
    \ => 20, \"v\" => 21, \"w\" => 22, \"x\" => 23, \"y\" => 24, \"z\" => 25) \n \
    \   words = split(txt, \" \") \n    l = Vector{String}(length(t) for t in words)\n\
    \    i = 0\n    for word in words \n        if length(word) ==0 \n           \
    \ continue\n            end\n        l[i] = word \n        i = i + 1\n    end\n\
    \    return length(l)\nend\n</code>\n<|/ a tags=vector,julia |>\n<| c |>\nA few\
    \ things: 1. You missed the comma before the `else` in `if length(t) == 0 continue`.\
    \ 2. The `l` doesn't need to be a Vector, since the `split` function returns a\
    \ tuple (well, at least it does), so you can simply do `l = Vector{String}(words)`.\n\
    <|/ c |>\n<| a dscore=1 |>\nFor a pure functional version without mutable variables:\n\
    <code>", "    txt = lowercase(txt)\n    if isempty(txt)\n        return txt\n\
    \    ends_with = match(r\"[^a-zA-Z]+$\", txt)\n    if ends_with\n        txt =\
    \ txt[1:end]\n    ends_with = match(r\"[^a-zA-Z]+$\", txt)\n    if ends_with\n\
    \        txt = txt[1:end]\n    ends_with = match(r\"[^a-zA-Z]+$\", txt)\n    if\
    \ ends_with\n        txt = txt[1:end]\n    ends_with = match(r\"[^a-zA-Z]+$\"\
    , txt)\n    if ends_with\n        txt = txt[1:end]\n    ends_with = match(r\"\
    [^a-zA-Z]+$\", txt)\n    if ends_with\n        txt = txt[1:end]\n    ends_with\
    \ = match(r\"[^a-zA-Z]+$\", txt)\n    if ends_with\n        txt = txt[1:end]\n\
    \    ends_with = match(r\"[^a-zA-Z]+$\", txt)\n    if ends_with\n        txt =\
    \ txt[1:end]\n    ends_with = match(r\"[^a-zA-Z]+$\", txt)\n    if ends_with\n\
    \        txt = txt[1:end]\n    ends_with = match(r\"[^a-zA-Z]+$\", txt)\n    if\
    \ ends_with\n        txt = txt[1:end]\n    ends_with = match(r\"[^a-zA-Z]+$\"\
    , txt)\n    if ends_with\n        txt = txt[1:end]\n    ends_with = match(r\"\
    [^a-zA-Z]+$\", txt)\n    if ends_with\n        txt = txt[1:end]\n    ends_with\
    \ = match(r\"[^a-zA-Z]+$\", txt)\n    if ends_with\n        txt = txt[1:end]\n\
    \    ends_with = match(r\"[^a-zA-Z]+$\", txt)\n    if ends_with\n        txt =\
    \ txt[1:end]\n    ends_with = match(r\"[^a-zA-Z]+$\", txt)\n    if ends_with\n\
    \        txt = txt[1:end]\n    ends_with = match(r\"[^a-zA-Z]+$\", txt)\n    if\
    \ ends_with\n        txt = txt[1:end]\n    ends_with = match(r\"[^a-zA-Z]+$\"\
    , txt)\n    if ends_with\n        txt = txt[1:end]\n    ends_with = match(r\"\
    [^a-zA-Z]+$\", txt)\n    if ends_with\n        txt = txt[1:end]\n    ends_with\
    \ = match(r\"[^a-zA-Z]+$\", txt)\n    if ends_with\n        txt = txt[1:end]\n\
    \    ends_with = match(r\"[^a-zA-Z]+$\", txt)\n    if ends_with\n        txt =\
    \ txt[1:end]\n    ends_with = match(r\"[^a-zA-Z]+$\", txt)\n    if ends_with\n",
  "    words = [w for w in split(txt, \" \") if !isblank(w)]\n    if len(words) ==\
    \ 0\n        return length(unique(lowercase(split(txt, \",\")))) + 1\n    end\n\
    \    return length(unique(lowercase(words))) + 1\nend\n</code>\n<|/ a dscore=3\
    \ tags=julia,dataframe,string |>\n<| a tags=julia,dataframe,string |>\nJust a\
    \ note, that if your dataset is large and you need to use Julia DataFrames then\
    \ it may be faster to use CSV.jl package instead of DataFrames.jl.\nThis package\
    \ uses CSV.jl under the hood but is much faster.\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ |>\nIf you have multiple columns/variables that you need to combine, I suggest\
    \ the following:\n<code>\ncombined = DataFrame(:a => [1,2,3], :b => [4,5,6], :c\
    \ => [7,8,9])\n</code>\nThe result will then be \n<code>\n4\xD73 DataFrame\n Row\
    \ \u2502 a     b     c     \n     \u2502 Int64 Int64 Int64 \n\u2500\u2500\u2500\
    \u2500\u2500\u253C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253C\u2500\u2500\
    \u2500\u2500\u2500\u2500\u2500\u2524\n   1 \u2502 1     4     7    \n   2 \u2502\
    \ 2     5     8    \n   3 \u2502 3     6     9    \n</code>\nThis can be done\
    \ automatically by combining any number of DataFrame columns (see the docs here).\n\
    <|/ a tags=julia,dataframe,string |>\n<| a tags=julia,dataframe,string |>\nIn\
    \ Julia 1.1.0 or later you can use the join, unquote and split functions (like\
    \ in Python):\n<code>\njulia> x = [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"\
    7\"]\n7-element Array{String,1}:\n \"1\"\n \"2\"\n \"3\"\n \"4\"\n \"5\"\n \"\
    6\"\n \"7\"", "    \"\"\"\n    Split the given string txt into a vector of words.\
    \ You should assume that there are no whitespaces \n    or commas.\n    >>> split_words(\"\
    Hello world!\")\n    [\"Hello\", \"world!\"]\n    >>> split_words(\"Hello,world!\"\
    )\n    [\"Hello\", \"world!\"]\n    >>> split_words(\"abcdef\")\n    3\n    \"\
    \"\"\n    txt = txt.strip()\n    if isnothing(txt) then return 0 end\n    if isempty(txt)\
    \ then return 0 end\n    words = split(txt, \",\")\n    return length(words) +\
    \ (length(words) % 2 ? 1 : 0)\nend", "    if isempty(txt)\n        return \"\"\
    \n    else\n        words = split(txt,\" \")\n        words_vec = Vector{String}(words)\n\
    \        return words_vec\n    end\nend", "  \n    if txt === \"\"\n        return\
    \ Array{String}([])\n    end", "\"\"\"\nGiven a string of words, return a vector\
    \ of words split on whitespace, if no whitespaces exists in the text you\n   \
    \ should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n    Examples\n    >>> split_words(\"Hello world!\")\n\
    \    [\"Hello\", \"world!\"]\n    >>> split_words(\"Hello,world!\")\n    [\"Hello\"\
    , \"world!\"]\n    >>> split_words(\"abcdef\")\n    3\n    \"\"\"\nend # end of\
    \ split_words function definition", "    #return the number of words in the string\
    \ or vector if there are multiple words\n    if !contains(txt, \" \")\n      \
    \  return (txt, length(txt))\n    splits = split(txt,\" \")\n    words = Vector{String}()\n\
    \    for split in splits\n        push!(words, split(split))\n    end\n    return\
    \ (words, length(words))\n    end\n\"\"\"\n    Given a vector of words, return\
    \ a vector of unique words removing duplicate words\n    >>> split_words(\"Hello\
    \ world! Hello world! Hello world!\")\n    [\"Hello\", \"world!\"]\n    \"\"\"",
  "    \"\"\"\n    Returns the number of words in a given text \n    \n    Examples\n\
    \    >>> split_words(\"Hello world!\")\n    3\n    >>> split_words(\"Hello,world!\"\
    )\n    2\n    >>> split_words(\"abcdef\")\n    4\n    \"\"\"", "    try\n    \
    \    return split(split(txt))\n    catch\n    end\n    return length(filter(x\
    \ -> x != ' ', split(txt))) + 1\nend", "    return txt.split() |> collect\nend\n\
    </cell>\n<code language=julia-1.0>\n# check your output\nsplit_words(\"Hello world!\"\
    )\n</cell>\n<code language=julia-1.0>\n# see what happens if you try to split\
    \ words that have punctuations like commas\nsplit_words(\"Hello,world!\")\n</cell>\n\
    <text>\nWrite a function that takes a String and returns a Vector{String} where\
    \ each element in the Vector is a word with the correct case\n(uppercased or lowercased).\n\
    Examples\n>>> correctcase(\"Hello World!\")\n[\"HELLO\", \"WORLD!\"]\n>>> correctcase(\"\
    hello\")\n[\"HELLO\"]\n>>> correctcase(\"hello,world!\")\n[\"HELLO\", \"WORLD!\"\
    ]\n>>> correctcase(\"Hello World!!\")\n[\"HELLO\", \"WORLD!!\"]\n>>> correctcase(\"\
    Hello World!\")\n[\"HELLO\", \"WORLD!\"]\n>>> correctcase(\"\")\n[]\n>>> correctcase(\"\
    \  \")\n[]\n>>> correctcase(\"x\")\n[]\n>>> correctcase(\"x-\")\n[]\n>>> correctcase(\"\
    x-y\")\n[]\n>>> correctcase(\"x-y-z\")\n[]\n>>> correctcase(\"x-y-z-\")\n[]\n\
    >>> correctcase(\"x y-z\")\n[\"X\", \"Y\", \"Z\"]\n>>> correctcase(\"hello, world!\"\
    )\n[\"HELLO\", \"WORLD!\"]\n>>> correctcase(\"hello  world!\")\n[\"HELLO\", \"\
    WORLD!\"]\n>>> correctcase(\"   \")\n[]\n>>> correctcase(\"   -hello-\")\n[]\n\
    >>> correctcase(\"   -hello-world-\")\n[\"HELLO\", \"WORLD\"]\n>>> correctcase(\"\
    - hello- world-\")\n[\"HELLO\", \"WORLD\"]\n>>> correctcase(\"- hello-world -\"\
    )\n[\"HELLO\", \"WORLD\"]\n>>> correctcase(\"- hello-world- \")\n[\"HELLO\", \"\
    WORLD\"]\n>>> correctcase(\"-hello- world-\")\n[\"HELLO\", \"WORLD\"]\n>>> correctcase(\"\
    -hello-world-\")\n[\"HELLO\", \"WORLD\"]\n>>> correctcase(\"-hello-world-\")\n\
    [\"HELLO\", \"WORLD\"]\n>>> correctcase(\"-hello-world-hello\")\n[\"HELLO\", \"\
    WORLD\"]\n>>> correctcase(\"-hello-world-hello\")\n[\"HELLO\", \"WORLD\"]\n>>>\
    \ correctcase(\"-hello-world-hello\")\n[\"HELLO\", \"WORLD\"]\n>>> correctcase(\"\
    -hello", "    txt.split(\" \") |> collect { (x) -> x } |> collect.(filter(x->\
    \ x != \"\"))\nend\n\"\"\"\n    Given a list of strings, return the length of\
    \ the longest string\n    >>> lengths_of_longest_strings([\"hello\", \"world\"\
    , \"how\", \"are\", \"you\"])\n    3\n    >>> lengths_of_longest_strings([\"Hello\"\
    , \"world\", \"how\", \"are\", \"you\"])\n    3\n    >>> lengths_of_longest_strings([\"\
    abcdef\"])\n    3\n    \"\"\"", "    if isempty(txt)\n        return Vector{String}()\n\
    \    else\n        return Vector{String}(unwrap(split(txt)))\n    end\nend", " \
    \   if length(txt) < 2\n        return txt\n    words = split(txt,' ')\n    if\
    \ length(words) >=2 \n        words = split(split(txt, ',')[1], ' ')\n    else\n\
    \        words = split(split(txt, ',')[1], ' ') if length(split(txt, ',')[1])\
    \ > 0 \n    end\n    \n    lowercase = 0\n    for w in words\n        lowercase\
    \ = lowercase + length(lower(w))\n    end\n    \n    lowercase = lowercase + (2\
    \ - sum(lower(words)))\n    \n    if lowercase%2\n        return words\n    else\n\
    \        return words\n    end\nend\n</code>\nThe result is now a list of words\
    \ from the original sentence:\n<code>\njulia> split_words(\"Hello world!\")\n\
    [\"Hello\", \"world!\"]\n</code>\n<|/ a tags=julia,string |>\n<| c |>\nThank you\
    \ for your answer, however it seems to return an array like [\"Hello\", \"world!\"\
    ]. Do you know how could I make it return [\"Hello\", \"world!\"]?\n<|/ c |>\n\
    <| c |>\nOh okay it worked! Thank you for your effort! I really appreciate it!\n\
    <|/ c |>\n<| a dscore=0 |>\nIf there are two or more consecutive spaces then split\
    \ on the space after the first:\n<code>\nsplit(text, first(isspace, first(text))[1])\n\
    </code>\nor if you know that the first word is non-empty:\n<code>\nsplit(text,\
    \ first(isspace, text))[1]\n</code>\n<|/ a tags=julia,string |>\n<| c |>\nThis\
    \ one works great! However, it returns an array like the one above. Do you know\
    \ how to fix this? Thank you for your effort!\n<|/ c |>\n<| c |>\nI see what you\
    \ mean now. Edited.\n<|/ c |>\n<| c |>\nI see! But it seems that I still get an\
    \ array like [\"Hello\", \"world!\"] instead of [\"Hello\", \"world!\"]\n<|/ c\
    \ |>\n<| c |>\nHow are you calling this? It works on my machine.\n<|/ c |>\n<|\
    \ c |>\nI'm really sorry if I'm asking too much but can you please explain a little\
    \ bit more because I am not really familiar with Julia. Thank you for your patience!\n\
    <|/ c |>\n<| a dscore=0 |>\nYou can use regexp to split your string as below:\n\
    <code>\nusing Base.Threads ", "  txt.split(/,/)\nend", "    \"\"\"Split words\
    \ on whitespace\"\"\"\n    \n    lst = split(txt, \" \")\n    word_counts = lengths(lst)\n\
    \    word_list = collect(lst)\n    \n    if length(word_counts) == 0 || word_counts[1]\
    \ == 0\n        return word_list\n    else\n        \n        if isscalar(word_counts)\n\
    \            return word_list\n        else\n            return word_list[1]\n\
    \    end\nend\n</code>\nand finally a test function\n<code>", "        words =\
    \ split(txt, \",\")\n        letters = length(words)\n        return letters %\
    \ 2 == 1 ? letters : letters - 1\n    end\n</code>\n<|/ a |>\n<| a dscore=0 |>\n\
    Another way:\n<code>\nusing Distributions", "\"\"\"\nGiven a string of words,\
    \ return a vector of words split on whitespace, if no whitespaces exists in the\
    \ text you\n    should split on commas ',' if no commas exists you should return\
    \ the number of lower-case letters with odd order in the\n    alphabet, ord('a')\
    \ = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    >>> split_words(\"Hello\
    \ world!\")\n    [\"Hello\", \"world!\"]\n    >>> split_words(\"Hello,world!\"\
    )\n    [\"Hello\", \"world!\"]\n    >>> split_words(\"abcdef\")\n    3\n    \"\
    \"\"\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=python,julia,regex |>\nIf\
    \ you only care about splitting on non-whitespace characters, you could use split\
    \ with capturing groups:\n<code>\njulia> \"Hello World!\" |> split(r\"(?<=[a-z])(?=\\\
    s)\")\n5-element Array{String,1}:\n \"Hello\"\n \"World!\"\n \"Hello\"\n \"World!\"\
    \n \"Hello\"\n \"World!\"\n</code>\n<|/ a |>\n<| a dscore=0 tags=python,julia,regex\
    \ |>\nYou can write your own function which will return number of occurrence of\
    \ particular charcter in string.\n<code>", "    if isempty(txt)\n        throw(ArgumentError(\"\
    string cannot be empty\"))\n    end\n    res = \"\"\n    lastc = \"\"\n    for\
    \ c in txt\n        if c == \"_\"\n            push!(res, lastc)\n           \
    \ lastc = \"\"\n        elseif lastc == \"\"\n            if islower(c)\n    \
    \            push!(res, c)\n            end\n        else\n            lastc =\
    \ c\n        end\n    end\n    push!(res, lastc)\n    return res\nend", "    return\
    \ split_words_internal(txt)\nend", "    words = split(txt, \" \") \n    words\
    \ = split_words(txt, words, []) \n    length(words) == 1 ? words[0] : words\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThank you very much for your detailed explanation\
    \ and solution, sir!\n<|/ c |>\n<| c |>\nPlease don't post code in comments. [Edit]\
    \ your question and post code there instead.\n<|/ c |>\n<| a tags=string,julia,arrays,split\
    \ |>\nHere is a short and elegant solution.\n<code>", "    words = split(txt,\
    \ ',')\n    vecs = [split(w, ' ') | w \u2208 words]\n    vecs = [vec | vec \u2208\
    \ vecs for vec in vecs]\n    return vecs\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\nGiven a string, return a vector of words split on whitespace, if no whitespaces\
    \ exists in the text you\nshould split on commas ',' if no commas exists you should\
    \ return the number of lower-case letters with odd order in the\nalphabet, ord('a')\
    \ = 0, ord('b') = 1, ... ord('z') = 25\nExamples\n>>> split_words(\"Hello world!\"\
    )\n    [\"Hello\", \"world!\"]\n>>> split_words(\"Hello,world!\")\n    [\"Hello\"\
    , \"world!\"]\n>>> split_words(\"abcdef\")\n    3\n\"\"\"", "    if isascii(txt)\n\
    \        vec = split(txt, \" \")\n    else\n        vec = split(txt, \",\")\n\
    \    end\n    return vec\nend", "    words_str = split(txt, ' ')\n    if !isempty(words_str)\
    \ && all(x -> !isascii(x), words_str)\n        word_counts = Dict()\n        for\
    \ word_str in words_str\n            word = lowercase(word_str)\n            if\
    \ !haskey(word_counts, word)\n                word_counts[word] = word_counts[length(word_counts)\
    \ + 1] = 1\n            else\n                word_counts[word] += 1\n       \
    \ end\n        return collect(values(word_counts))\n    else\n        return length(words_str)\n\
    \    end\nend\n\"\"\"\n    Given an input string of words and a list of strings\
    \ of words, return the number of common words between the two\n    lists\n   \
    \ You can assume that all strings in your list are lower case\n    Examples\n\
    \    >>> intersection(\"Hello world!\", [\"Hello\", \"world!\"])\n    3\n    >>>\
    \ intersection(\"Hello world!\", [\"Hello\", \"world!\", \"How\"])\n    0\n  \
    \  >>> intersection(\"Hello world!\", [\"Hello\", \"world!\", \"Hey\"])\n    2\n\
    \    \"\"\"", "    txt = split(txt, \"\")\n    words_arr = split(txt, \",\")\n\
    \    words = []\n    for w in words_arr\n        if w != \"\"\n            push!(words,\
    \ w)\n        else\n            words += [ lower(w) ]\n        end\n    end\n\
    \    return words\nend", "\"\"\"\nGiven a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n    should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n    Examples\n    >>> split_words(\"Hello world!\")\n    [\"\
    Hello\", \"world!\"]\n    >>> split_words(\"Hello,world!\")\n    [\"Hello\", \"\
    world!\"]\n    >>> split_words(\"abcdef\")\n    3\n    \"\"\"", "    words = split(txt,'\
    \ ')\n    wordCount = count(w for w in words)\n    vec1 = ones(wordCount,1)\n\
    \    vec2 = zeros(wordCount,1)\n    for word in words\n        if isequal(word,\"\
    \")\n            continue\n        else\n            if isequal(word,'')\n   \
    \             vec1 = add(vec1,1)\n                vec2 = add(vec2,0)\n       \
    \     else\n                vec1 = add(vec1,0)\n                vec2 = add(vec2,1)\n\
    \            end\n        end\n    end\n    return vec1, vec2\nend", "    word_vec\
    \ = split(txt, \" \")\n    len_vec = map(length, word_vec)\n    words_without_spaces\
    \ = filter(elem -> elem!=' ', word_vec)\n    words_withcommas = filter(elem ->\
    \ elem==' ', word_vec)\n    words_withcommas = words_withcommas.map(x -> replace(\"\
    \ \", \"\", x)) # remove spaces from the commas\n    words_withcommas = words_withcommas.map(x\
    \ -> lowercase(x)) # lowercase letters\n    words_withcommas = words_withcommas.filter(x\
    \ -> !in(x, ['the', 'of', 'and', 'in']))\n    words_withcommas = words_withcommas.filter(x\
    \ -> !in(x, ['the', 'of', 'and', 'in']))\n    words_withcommas = words_withcommas.map(x\
    \ -> replace_parens_around_strings(x))\n    words_withcommas = words_withcommas.map(x\
    \ -> replace_parens_around_strings(x))\n    words_withcommas = words_withcommas.map(x\
    \ -> replace_parens_around_strings(x))\n    words_withcommas = words_withcommas.map(x\
    \ -> replace_parens_around_strings(x))\n    words_withcommas = words_withcommas.map(x\
    \ -> replace_parens_around_strings(x))\n    words_withcommas = words_withcommas.map(x\
    \ -> replace_parens_around_strings(x))\n    words_withcommas = words_withcommas.map(x\
    \ -> replace_parens_around_strings(x))\n    words_withcommas = words_withcommas.map(x\
    \ -> replace_parens_around_strings(x))\n    words_withcommas = words_withcommas.map(x\
    \ -> replace_parens_around_strings(x))\n    words_withcommas = words_withcommas.map(x\
    \ -> replace_parens_around_strings(x))\n    words_withcommas = words_withcommas.map(x\
    \ -> replace_parens_around_strings(x))\n    words_withcommas = words_withcommas.map(x\
    \ -> replace_parens_around_strings(x))\n    words_withcommas = words_withcommas.map(x\
    \ -> replace_parens_around_strings(x))\n    words_withcommas = words_withcommas.map(x\
    \ -> replace_parens_around_strings(x))\n    words_withcommas = words_withcommas.map(x\
    \ -> replace_parens_around_strings(x))\n    words_withcommas = words_withcommas.map(x\
    \ -> replace_parens_around_strings(x))\n    words_withcommas = words_withcommas.map(x\
    \ -> replace_parens_", "    \"\"\"\n    Given a string of words, return a vector\
    \ of words split on whitespace, if no whitespaces exists in the text you\n   \
    \ should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n    \"\"\"\n    words1 = split(txt,\" \") # split by\
    \ space\n    words2 = split(txt,\",\") # split by comma\n    words3 = split(txt,\"\
    .\") # split by dot\n    words4 = split(txt,\"?\") # split by question mark\n\
    \    words5 = split(txt,\"!\") # split by exclamation mark\n    words6 = split(txt,\"\
    (\") # split by parenthesis\n    words7 = split(txt,\"[\")\n    words8 = split(txt,\"\
    ]\")\n    words9 = split(txt,\"(\")\n    words10 = split(txt,\"]\")\n    words11\
    \ = split(txt,\"{\")\n    words12 = split(txt,\"}\")\n    words13 = split(txt,\"\
    [\")\n    words14 = split(txt,\"]\")\n    words15 = split(txt,\":\")\n    words16\
    \ = split(txt,\"::\")\n    words17 = split(txt,\";\")\n    words18 = split(txt,\"\
    &\")\n    words19 = split(txt,\"|\")\n    words20 = split(txt,\"%\")\n    words21\
    \ = split(txt,\"#\")\n    words22 = split(txt,\"$\")\n    words23 = split(txt,\"\
    @\")\n    words24 = split(txt,\"*\")\n    words25 = split(txt,\"'\")\n    words26\
    \ = split(txt,\"\\\"\") #split by double quotes\n    words27 = split(txt,\";;\"\
    ) #split by semi-colon and semi-colon\n    words28 = split(txt,\"%\") # split\
    \ by percent sign\n    words29 = split(txt,\"=\")\n    words30 = split(txt,\"\
    :=\") #split by equals sign\n    words31 = split(txt,\"==\") #split by equals\
    \ sign\n    words32 = split(txt,\"!=\") #split by equals sign\n    words33 = split(txt,\"\
    <=\") #split by equals sign\n    words34 = split(txt,\">=\") #split by equals\
    \ sign\n    words35 = split(txt,\"<\") # split by left angle bracket\n    words36\
    \ = split(txt,\">\") # split by right angle bracket\n    words37 = split(txt,\"\
    =\") #split by equal", "    txt = split(txt, split=\",\")\n    return length(txt)\n\
    end\n</cell>\n<code language=julia-1.1>\n## TESTS", "    \"\"\"\n    Takes in\
    \ a string of words and returns a vector of the words or the number of letters\
    \ with odd order in the alphabet.\n    \n    Parameters\n    ----------\n    txt\
    \ : String\n       a string of words separated by whitespace\n    Returns\n  \
    \  -------\n    Returns a vector of the words or the number of letters with odd\
    \ order in the alphabet.\n    Examples\n    >>> split_words(\"Hello world!\")\n\
    \    [\"Hello\", \"world!\"]\n    >>> split_words(\"Hello,world!\")\n    [\"Hello\"\
    , \"world!\"]\n    >>> split_words(\"abcdef\")\n    3\n    \"\"\"\n    return\
    \ split(txt, ' ', ',')", "    # check for missing whitespace\n    if any([x <>\
    \ ' ' for x in txt])\n        return txt\n    else\n        # check for comma\
    \ or space \n        if any([x <> ',' for x in txt])\n            return txt\n\
    \        else\n            # split on commas\n            arr1 = Array{String,1}(undef,\
    \ 0) \n            arr2 = Array{String,1}(undef, 0)\n            for word in split(txt,\
    \ ',')\n                arr1 = [word ;\n                         join(arr1, word,\
    \ length(word))\n                         ]\n            end\n            return\
    \ arr1\n        end\n    end\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n\
    Another solution is using regex:\n<code>", "    # return vector of words\n   \
    \ return split(txt) \nend", "    words = split(txt, \" \")\n    return count(words)\n\
    end\n</cell>\n<code language=julia-1.5>\nusing BenchmarkTools\n@btime split_words(\"\
    Hello,world!\")\n</cell>\n<code language=julia-1.5>", "    if is_empty(txt)\n\
    \        return Vector{String}()\n    end", "    txt = txt.split\n    txt = txt[txt.!=\"\
    \",1] #remove empty string\n    return length(txt)\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| a dscore=0 |>\n<code>", "    \"\"\"\n    Function that split a String\
    \ with whitespace and return a list of Strings or a Vector of Strings depending\
    \ on the input\n    txt : string to be split\n    \"\"\"\n    words_list = txt.split(\"\
    \ \")\n    word_vector = Vector{String}[]\n    for word in words_list\n      \
    \  if word != \"\"\n            push!(word_vector, word)\n        end\n    end\n\
    \    return word_vector\nend\n</code>\n<|/ a dscore=1 tags=split,string,julia,nlp\
    \ |>\n<| c |>\nFor a second I was going to post `splitlines`, which does the same\
    \ thing, but also preserves whitespace, in a similar vein to `regex` which does\
    \ the same thing, but also preserves whitespace.\n<|/ c |>\n<| c |>\nI agree,\
    \ it's better to avoid `splitlines`, it has a `\\n` character (which is not present\
    \ in strings) that should be kept in the output. `regex` also preserves `\\n`\
    \ in the output, while `splitlines` loses this information.\n<|/ c |>\n<| a tags=split,string,julia,nlp\
    \ |>\nIf you just want to remove any whitespace in the text, use the function\
    \ strip:\n<code>\njulia> strip(\" Hello world! \")\n\"Hello world!\"\n</code>\n\
    If you want to split your string on whitespace and remove whitespace, use split:\n\
    <code>\njulia> strip(\" Hello world! \", \".\")\n\"Hello\"\n\"world!\"\n</code>\n\
    If you want to split your string on whitespace and preserve whitespace, use split:\n\
    <code>\njulia> strip(\" Hello world! \", \" \")\n\"Hello world!\"\n</code>\nIf\
    \ you want to split your string on whitespace and preserve whitespace and also\
    \ remove the whitespace at the end, use split:\n<code>\njulia> strip(\" Hello\
    \ world! \", \" .\")\n\"Hello\"\n\"world\"\n\"!\"\n</code>\nIf you want to split\
    \ your string on whitespace and preserve whitespace, use split:\n<code>\njulia>\
    \ strip(\" Hello world! \", \" \")\n\"Hello world!\"\n</code>\nIf you want to\
    \ split your string on whitespace and preserve whitespace and also remove the\
    \ whitespace at the end, use split:\n<code>\njulia> strip(\" Hello world! \",\
    \ \" .\")\n\"Hello\"\n\"world\"\n\"!\"\n</code>\nIf you want to split your string\
    \ on whitespace and preserve whitespace, use split:\n<code>\njulia> strip(\" Hello\
    \ world! \", \" \")\n\"Hello world!\"\n</code>\nIf you want to split your string\
    \ on whitespace and preserve whitespace and also remove the whitespace at the\
    \ end, use split:\n<code>\njulia> strip", "    \n    words = split(txt,\" \")\
    \ \n    words_no_spaces = filter(x->!isascii(x) || isascii(lowercase(x)), words)\
    \ \n    \n    if isempty(words_no_spaces) == true \n        words_no_spaces =\
    \ words \n    else \n        words_no_spaces = words_no_spaces \n    end\n   \
    \ \n    return length(words_no_spaces) \nend\n</cell>\n<text>\nExercise 10: Count\
    \ words in a text file\nExercise 10.1: Count the words in an external text file\n\
    The function count_words() takes the filename of a text file as an argument and\
    \ returns the number of words in the file.", "    ...\nend\n</code>\nExercise\n\
    Write a function that splits the given text into words, omitting the word \"and\"\
    .\nFor example, \"Hello world\" should become [\"Hello\", \"world\"].\nHint: Use\
    \ split(txt) to split your string and then filter out the words with \"and\".\n\
    Examples\nsplit_words(\"Hello world\") should become [\"Hello\", \"world\"].\n\
    split_words(\"Hello and world\") should become [\"Hello\"].\nsplit_words(\"Hello\
    \ world,\") should become [\"Hello\", \"world\", \",\"].\nsplit_words(\"Hello\
    \ world! And goodbye\") should become [\"Hello\", \"world\", \",\", \"And\", \"\
    goodbye\"].\n<|/ a |>\n<| c |>\nI have added my attempt to the original question,\
    \ I have tried this but it does not produce the correct results and I'm not sure\
    \ how to fix it\n<|/ c |>\n<| c |>\nThank you for answering the original question\
    \ but this does not answer my question. I am not looking to filter out \"and\"\
    \ and I do not want to split on commas.\n<|/ c |>\n<| c |>\nI've just updated\
    \ my answer with a function that should work, but it's not perfect as you see\
    \ in my answer. It's a toy example and needs some tweaking, I hope it gives you\
    \ some ideas to figure out the rest of the puzzle.\n<|/ c |>\n<| a |>\nHere's\
    \ a solution that doesn't involve a regex:\n<code>", "  split(txt,\" \")\n  if\
    \ length(your_string) == 0 \n    your_string = split(txt,\",\")\n  else\n    your_string\
    \ = split(txt,\",\")\n  end \n  if length(your_string) == 0 \n    your_string\
    \ = split(txt,\"\\n\")\n  else\n    your_string = split(txt,\"\\n\")\n  end \n\
    \  return length(your_string)\nend", "    vec = Vector{String}(txt)\n    \n  \
    \  # your code\n    words = vec\n    if length(words) == 0\n        words = [\"\
    No words!\"]\n    end\n    return words\nend", "    split_words_str = split(txt,\
    \ \" \")\n    if split_words_str[1] == \"\"\n        split_words_str[1] = \",\"\
    \ if split_words_str[2] == \"\" else \"+\"\n        return split_words_str\n \
    \   else\n        return count(\"[a-z]\",split_words_str[2])\n    end\nend\n</code>\n\
    <|/ a tags=string,julia |>\n<| a dscore=3 |>\nOne liner\n<code>\nwords = \"Hello\
    \ world!\"\n\"(\" .* join([ replace(words[i],\"\\n\",\"\") for i=1:length(words)\
    \ ]) - \")\"\n</code>\n<|/ a tags=string,julia |>\n<| a |>\nHere is a more compact\
    \ solution without using regular expressions. I thought about it and I think it's\
    \ more readable than a one-liner with regular expressions.\n<code>\njulia> function\
    \ removeExtraSpaces(s)\n           a = \"\"\n           for i in eachindex(s)\n\
    \               if a == \"\"\n                   a = s[i]\n               else\n\
    \                   if s[i] == \" \"\n                       a += \"-\"\n    \
    \               else\n                       a += s[i]\n                   end\n\
    \               end\n           end\n           a\n       end\nremoveExtraSpaces\
    \ (generic function with 1 method)", "    # Write your code\nend\n</cell>\n<code\
    \ language=julia-1.0>\nusing BenchmarkTools\n@btime split_words(\"Hello world!\"\
    )\n@btime split_words(\"Hello,world!\")\n</cell>\n<text>\nWhat is the difference\
    \ between .,[] and \"[]\".split(\",\")?", "    return split(txt, ' ') if txt !=\
    \ '' else 0\nend # split_words", "    lowercase::Int64 = sum(map(i -> ord(i) <\
    \ ord('A'), txt))\n    lowercase = lowercase % 26 + ord('a')\n    uppercase =\
    \ sum(map(i -> ord(i) > ord('z'), txt))\n    uppercase = uppercase % 26 + ord('a')\n\
    \    if lowercase == 0 and uppercase == 0:\n        return txt\n    elif lowercase\
    \ == 0 and uppercase > 0:\n        return lowercase\n    elif lowercase > 0 and\
    \ uppercase == 0:\n        return uppercase\n    return lowercase + uppercase\
    \ + 1\nend\n\"\"\"\n    Split the text into words into a vector of words, no whitespaces\
    \ exists in the text\n    Returns\n        vector of the split words\n    Examples\n\
    \        words = split_words(\"Hello world!\")\n        words[1]\n        > \"\
    world!\"\n        words[end]\n        > \"!\"\n    \"\"\""]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
