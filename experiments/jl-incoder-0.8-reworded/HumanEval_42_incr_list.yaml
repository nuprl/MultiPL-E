name: HumanEval_42_incr_list
language: jl
prompt: "\"\"\"Return vector with elements incremented by 1.\n    >>> incr_list([1,\
  \ 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6,\
  \ 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\nfunction incr_list(l::Vector{Int64})::Vector{Int64}\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = incr_list;\n\t@test(candidate(Vector{Int64}([]))\
  \ == Vector{Int64}([]))\n\t@test(candidate([3, 2, 1]) == [4, 3, 2])\n\t@test(candidate([5,\
  \ 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])\nend\n"
completions: ["    l = l.copy()\n    inc(l)\n    return l\nend", "    tmp = Vector{Int64}()\n\
    \    for i in l\n        tmp += i\n    end\n    return tmp\nend", "    \n    @assert\
    \ length(l)>0, \"incr_list: Vector l must not be empty\" \n    \n    cumulative\
    \ = Vector{Int64}(0) \n    @inbounds for elt in l \n        cumulative = [elt]\
    \ + cumulative \n    end \n    return cumulative \nend\n</cell>\n<code language=julia-1.5>\n\
    @time a = incr_list(incr_list(vector(Int64, 8)))\n@time a = incr_list(incr_list(vector(Int64,\
    \ 8)))\n@time a = incr_list(incr_list(vector(Int64, 8)))\n@time a = incr_list(incr_list(vector(Int64,\
    \ 8)))\n@time a = incr_list(incr_list(vector(Int64, 8)))\n@time a = incr_list(incr_list(vector(Int64,\
    \ 8)))\n@time a = incr_list(incr_list(vector(Int64, 8)))\n@time a = incr_list(incr_list(vector(Int64,\
    \ 8)))\n@time a = incr_list(incr_list(vector(Int64, 8)))\n@time a = incr_list(incr_list(vector(Int64,\
    \ 8)))\n@time a = incr_list(incr_list(vector(Int64, 8)))\n@time a = incr_list(incr_list(vector(Int64,\
    \ 8)))\n@time a = incr_list(incr_list(vector(Int64, 8)))\n@time a = incr_list(incr_list(vector(Int64,\
    \ 8)))\n@time a = incr_list(incr_list(vector(Int64, 8)))\n@time a = incr_list(incr_list(vector(Int64,\
    \ 8)))\n@time a = incr_list(incr_list(vector(Int64, 8)))\n@time a = incr_list(incr_list(vector(Int64,\
    \ 8)))\n@time a = incr_list(incr_list(vector(Int64, 8)))\n@time a = incr_list(incr_list(vector(Int64,\
    \ 8)))\n@time a = incr_list(incr_list(vector(Int64, 8)))\n@time a = incr_list(incr_list(vector(Int64,\
    \ 8)))\n@time a = incr_list(incr_list(vector(Int64, 8)))\n@time a = incr_list(incr_list(vector(Int64,\
    \ 8)))\n@time a = incr_list(incr_list(vector(Int64, 8)))\n@time a = incr_list(incr_list(vector(Int64,\
    \ 8)))\n@time a = incr_list(incr_list(vector(Int64, 8)))\n@time a = incr_list(incr_list(vector(Int64, ",
  "    l = Int.(l)\n    ind = 0\n    l[ind+1] = l[ind] + 1\n    ind++\n    l[ind+1]\
    \ = l[ind] + 1\n    ind++\n    l[ind+1] = l[ind] + 1\n    ind++\n    l[ind+1]\
    \ = l[ind] + 1\n    ind++\n    l[ind+1] = l[ind] + 1\n    ind++\n    l[ind+1]\
    \ = l[ind] + 1\n    ind++\n    l[ind+1] = l[ind] + 1\n    ind++\n    l[ind+1]\
    \ = l[ind] + 1\n    ind++\n    l[ind+1] = l[ind] + 1\n    ind++\n    l[ind+1]\
    \ = l[ind] + 1\n    ind++\n    l[ind+1] = l[ind] + 1\n    ind++\n    l[ind+1]\
    \ = l[ind] + 1\n    ind++\n    l[ind+1] = l[ind] + 1\n    ind++\n    l[ind+1]\
    \ = l[ind] + 1\n    ind++\n    l[ind+1] = l[ind] + 1\n    ind++\n    l[ind+1]\
    \ = l[ind] + 1\n    ind++\n    l[ind+1] = l[ind] + 1\n    ind++\n    l[ind+1]\
    \ = l[ind] + 1\n    ind++\n    l[ind+1] = l[ind] + 1\n    ind++\n    l[ind+1]\
    \ = l[ind] + 1\n    ind++\n    l[ind+1] = l[ind] + 1\n    ind++\n    l[ind+1]\
    \ = l[ind] + 1\n    ind++\n    l[ind+1] = l[ind] + 1\n    ind++\n    l[ind+1]\
    \ = l[ind] + 1\n    ind++\n    l[ind+1] = l[ind] + 1\n    ind++\n    l[ind+1]\
    \ = l[ind] + 1\n    ind++\n    l[ind+1] = l[ind] + 1\n    ind++\n    l[ind+1]\
    \ = l[ind] + 1\n    ind++\n    l[ind+1] = l[ind] + 1\n    ind++\n    l[ind+1]\
    \ = l[ind] + 1\n    ind++\n    l[ind+1] = l[ind] + 1\n    ind++\n    l[ind+1]\
    \ = l[ind] + 1\n    ind++\n    l[ind+1] = l[ind] + 1\n    ind++\n    l[ind+1]\
    \ = l[ind] + 1\n    ind++\n    l[ind+1] = l[ind] + 1\n    ind++\n    l[ind+1]\
    \ = l[ind] + 1\n    ind++\n    l[ind+1] = l[ind] + 1\n    ind++\n    l[ind+1]\
    \ = l[ind] + 1\n    ind++\n    l[ind+1] = l[ind] + ", "    @assert length(l)>0\
    \ \"incr_list() requires input Vector of length > 0\"\n    return l |> copy()\
    \ |> resize(1)\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nI don't think this\
    \ works when l = [1, 2] and you're trying to increment each element\n<|/ c |>\n\
    <| c |>\nThis answer is still valid in 2021!\n<|/ c |>\n<| a |>\nHere is a more\
    \ idiomatic version of this:\n<code>\nincr_list(l::Vector{Int64})::Vector{Int64}\
    \ \n    return copy(l) |> resize(1)\nend\n</code>\n<|/ a tags=julia dscore=4 |>\n\
    <| c |>\nI like this one too!\n<|/ c |>\n<| c |>\nAnd I like this one because\
    \ its concise!\n<|/ c |>\n<| a tags=julia |>\nYou can use map to get a list of\
    \ vectors with incremented elements using range and broadcasting operators:\n\
    <code>\njulia> map(i->i+1, range(1,4))\n4-element Vector{Int64}:\n 2\n 3\n 4\n\
    </code>\n<|/ a dscore=4 |>\n<| c |>\nYes this is very nice, thank you. However\
    \ this won't work if the function takes multiple arguments e.g.:", "    @assert\
    \ length(l) >= 1 \n    result = l[]\n    i = length(l) - 1\n    for x in l\n \
    \       @incr result\n    end\n    return result\nend", "    return Int64(map(l,\
    \ inc))\nend", "    incr = 1\n    for i in l\n        incr = incr + 1\n    end\n\
    \    return l\nend", "    \n    ind = 0\n    out = Int64[]\n    for x in l\n \
    \       ind+=1\n        out[ind] = x + 1\n    end\n    return out\nend", "   \
    \ # Slicing \n    # Returns a new Vector with the contents of l after increasing\
    \ \n    # by 1. \n    # Elements from 0 to length of l are copied. \n    return\
    \ l[1:end-1] + l[2:end] \nend\n</cell>\n<code language=julia-1.5>\nincr_list([1,\
    \ 2, 3])\n</cell>\n<code language=julia-1.5>\nincr_list([5, 3, 5, 2, 3, 3, 9,\
    \ 0, 123])\n</cell>\n<text>\nExercise\nWrite a function named incr_vec that returns\
    \ l after incrementing it by 1. Recall that vector l is passed into the function\
    \ by reference. \nExample\nincr_vec([1, 2, 3]) should return [2, 3, 4]\nincr_vec([5,\
    \ 3, 5, 2, 3, 3, 9, 0, 123]) should return [6, 4, 6, 3, 4, 4, 10, 1, 124]", " \
    \   return Int64[(l[i] + 1)::Int64[i] | i in l]\nend\n</cell>\n<code language=julia-1.0>\n\
    incr_list([1, 2, 3])\n</cell>\n<code language=julia-1.0>\nincr_list([5, 3, 5,\
    \ 2, 3, 3, 9, 0, 123])\n</cell>\n<text>\nincr_list\nincr_list() is a more efficient\
    \ version of incr(). The only differences are", "    res = new(l) \n    for i\
    \ in 1:length(l) \n        res[i] = res[i] + 1 \n    end \n    return res \nend ",
  "    v = new(0)\n    for x in l \n        v += x\n    end\n    return v\nend\n</cell>\n\
    <text>\nWe can now use our defined function incr_list to apply the incr operator\
    \ on our vectors:", "    l = copy(l)\n    for (i,e) in enumerate(l)\n        l[i+1]\
    \ = e + 1\n    end\n    return l\nend", "    return map(sum, zip(l, l[1:]))\n\
    end", "    if length(l)==0\n        return l\n    end\n    if l[1] == 1\n    \
    \    return Int64[]\n    end\n    lo = l[1]\n    ln = length(l)\n    up = copy(l)\n\
    \    up[end] = lo+1\n    up[1:end-1] = up[1:end-1] + 1\n    return up\nend\n</cell>\n\
    <code language=julia-1.3>", "    l = l + 1\n    return l\nend", "    return Vector{Int64}((v\
    \ + 1 for v in l))\nend\n</cell>\n<cell>\n@doc incr_list\n</cell>\n<text>\nExercise\
    \ 4\nWrite a function which generates the integer vector, from which we will extract\
    \ the\nfirst three elements.", "    if l.len==0\n        return l\n    end\n \
    \   last = l[1]\n    l[1] = l[l]\n    \n    \n    \n    incr_list(l)\n    \n \
    \   last[1]+=1\n    return last\nend\n</cell>\n<code language=julia-1.3>", " \
    \   return Vector{Int64}([x+1...length(l) for x in l])\nend\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that adds all the elements of a given list together.",
  "    if l.length==0\n        l\n    elseif l==[]\n        l\n    elseif l[1]!=l[0]\n\
    \        l\n    else\n        incr_list(l[1..end-1]) + [l[1]+1]\n    end\nend\n\
    </code>\n<|/ a dscore=2 tags=julia,arrays |>\n<| c |>\nI think it's better to\
    \ use `if l==[]` over `if l==nothing` because `nothing` is often a falsey value.\n\
    <|/ c |>\n<| c |>\n`if nothing` is idiomatic in Julia and `if l==[]` is idiomatic\
    \ in R. It depends on what you are trying to do. Both are true\n<|/ c |>\n<| c\
    \ |>\n`nothing` is still not idiomatic: in Julia it is the only possible value,\
    \ and it is commonly used in functions as a way of indicating an error condition.\
    \ I recommend `if isnothing(l) ...` instead.\n<|/ c |>\n<| c |>\nthank you for\
    \ pointing that out. I've edited my answer to show that `nothing` is not idiomatic\
    \ but `isnothing` is.\n<|/ c |>\n<| a dscore=1 tags=julia,arrays |>\nYou can do\
    \ something like this:\n<code>", "    \n    # Copy input vector\n    v = copy(l)\n\
    \    \n    # Increment each element by 1\n    for i = 1:length(v)\n        v[i]\
    \ = v[i] + 1\n    end\n    \n    return v\nend\n</cell>\n<code language=julia-1.5>",
  "    l = l + [Inf]\n    l[end] = zero(eltype(l))\n    return l\nend", "    return\
    \ copy(l)\nend\n</code>\n<|/ a |>\n<| c |>\nThis does not take into account the\
    \ special case of an empty list. Though it may be useful for others so I'll post\
    \ it as a separate answer.\n<|/ c |>\n<| c |>\n: That's not special; it's simply\
    \ a different way of writing the empty list.\n<|/ c |>\n<| c |>\n\"The empty list\
    \ has type `Int64`\" is a bit ambiguous. The type of a list is `Int64`, not `List`.\
    \ The type of a vector is `Vector{Int64}`, not `Vector`. The type of a range (`1:10`)\
    \ is also `Vector`, not `Int64`. The type of a string is `String`, not `String`.\
    \ Similarly, the type of a matrix is `Matrix{Int64}`, not `Matrix`. But the type\
    \ of a matrix expression is `Matrix{Int64}`, not `AbstractArray`.\n<|/ c |>\n\
    <| c |>\nThe empty list has type `Int64` because in Julia the empty list has the\
    \ type `Int64` rather than `List`. A list can have different types in Julia. `Vector{Int}`\
    \ and `Vector{Int64}` are the same type in Julia. The reason why the empty vector\
    \ has type `Int64` instead of `Vector` is because `Vector{Int}` is `Vector{Int64}`\
    \ and `Vector{Int}` is `Int64`.  A matrix can have different types in Julia as\
    \ well.  In Julia all objects have a type. `Matrix{Int}` and `Matrix{Int64}` are\
    \ the same type in Julia. The reason why `Matrix{Int}` has type `Matrix{Int64}`\
    \ is because `Matrix{Int}` is `Matrix{Int64}` and `Matrix{Int}` is `Int64`.\n\
    <|/ c |>\n<| c |>\nI never said that the empty list has type `Int64`. I said the\
    \ empty list is a list, which has type `Int64`. It has nothing to do with type\
    \ `Vector{Int}` or `Matrix{Int}`, because the empty list has type `Int64`. It's\
    \ just a way to write `[]` as an empty list. You don't have to write `[]`; you\
    \ can write `[]()` instead (note the additional parentheses).\n<|/ c |>\n<| a\
    \ dscore=4 |>\nA functional solution with no mutable state and no copying is just\
    \ about as simple as the accepted answer, but I thought I'd post one that does\
    \ make use of iterators to make unsafe mutations in situations ", "    # this\
    \ is slightly faster than for t in l\n    # return [t + 1 for t in l]\n    \n\
    \    # this is a bit slower, but avoids allocating a list\n    # result = Vector{Int64}(undef,\
    \ 0)\n    # for t in l\n    #     result[t+1] = t+1\n    # return result", " \
    \   return Int64[ l.[i+1]+1 for i in 1:length(l)-1 ]\nend\n</cell>\n<text>\nNow\
    \ we can use incr_list function to add 1 to the end of every element in the vector\
    \ and return the resulting list.", "    v = Vector{Int64}()\n    for (i,j) in\
    \ enumerate(l)\n        v[j] = v[j] + 1\n    end\n    return v\nend\n</cell>\n\
    <code language=julia-0.5>\nincr_list([1,4,1,4,1])\n</cell>\n<text>\nAvoid for\
    \ loops in Julia: Vectorization", "    return l + [0 for _ in 1:length(l)] \n\
    end \n</code>\n<|/ a |>\n<| c |>\nNice use of zip, I've never used it before.\
    \ Nice answer!\n<|/ c |>\n<| a tags=julia |>\nJulia has an idiom for this, using\
    \ the zip and map functions (see help for these).\nThe zip function takes two\
    \ or more iterables and combines them into a single iterable, where the elements\
    \ of each iterable are paired up in tuples. In this case, we can zip together\
    \ the first and second element of our list.\n<code>\njulia> zip([1,2], [3,4])\n\
    2-element Array{Tuple{Int64,Int64},1}:\n (1,3)\n (2,4)\n</code>\nThe map function\
    \ applies a function element-wise to a collection. This means it takes a function\
    \ and applies it to the elements of the collection. Our function will need to\
    \ take a single tuple, since we want the function to take two elements (two elements\
    \ of each list we zipped).\n<code>\njulia> map((x,y) -> x+y, zip([1,2], [3,4]))\n\
    2-element Array{Int64,1}:\n 3\n 5\n</code>\nYou can use this to increment your\
    \ list:\n<code>\njulia> map((x,y) -> x+y, zip([1,2], [3,4])) + [100,200,300]\n\
    2-element Array{Int64,1}:\n 3\n 5\n 6\n</code>\n<|/ a dscore=2 |>\n<| a |>\nHere\
    \ is another solution using map+zip and collect:\n<code>\njulia> collect(map(x->x[1]+x[2]+100,zip([1],[10,20,30])))\n\
    10-element Array{Int64,1}:\n 110\n 120\n 130\n 140\n 150\n 160\n 170\n 180\n 190\n\
    \ 200", "    result = Vector{Int64}(undef, length(l)+1)\n    for i,v in enumerate(l)\
    \ \n        result[i+1] = result[i]+v\n    end\n    result\nend", "    ret = new()\n\
    \    ret.push!(l.last+1)\n    for i in l.drop(end-1)\n        ret.push!(ret[i-1]+1)\n\
    \    end\n    ret\nend\n</cell>\n<text>\nExercise 3\nWrite a function that takes\
    \ a vector of strings as input and returns another vector with strings concatenated\
    \ together with the string \" hello\" prepended. For example, a vector with two\
    \ strings \"hello\" and \"world\" would be returned with a vector that has \"\
    hello world\" prepended to each element. The function should only prepend \"hello\"\
    \ to the first two elements.", "    if l == []\n        return []\n    end\n \
    \   \n    incr = l[1]\n    \n    for i in 2 to length(l)\n        incr = incr\
    \ + l[i]\n    end\n    \n    l = [incr]\n    return l\nend", "    length = length(l)\n\
    \    if length == 1\n        push!(l, 0)\n    end\n    l .+= 1\n    while length\
    \ < length(l)\n        push!(l, 0)\n        length += 1\n    end\n    l\nend\n\
    </cell>\n<code language=julia-1.1>\n@code_native function incr_list(l::Vector{Int64})::Vector{Int64}\
    \ \n    length = length(l)\n    if length == 1\n        push!(l, 0)\n    end\n\
    \    l .+= 1\n    while length < length(l)\n        push!(l, 0)\n        length\
    \ += 1\n    end\n    l\nend\n</cell>\n<code language=julia-1.1>\n@code_native\
    \ function incr_list(l::Vector{Int64})::Vector{Int64} \n    length = length(l)\n\
    \    if length == 1\n        push!(l, 0)\n    end\n    l .+= 1\n    while length\
    \ < length(l)\n        push!(l, 0)\n        length += 1\n    end\n    l\nend\n\
    </cell>\n<code language=julia-1.1>", "    # Vector of Int64\n    return l + [length(l)+1]\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work in Julia 1.0.  I believe the\
    \ issue is that `length` returns an `Int64`, but your function is expecting `Vector{Int64}`.\n\
    <|/ c |>\n<| c |>\nYeah, I'm surprised it's not an actual error. I thought I was\
    \ doing something wrong, because I have been doing this same thing for years in\
    \ other languages and it works.\n<|/ c |>\n<| c |>\nHm, it *is* a error when I\
    \ run that in the REPL on 1.0.\n<|/ c |>\n<| a tags=julia,vector,arrays,append\
    \ |>\nAnother option to avoid using loops or any loops is to use collect + append.\
    \ For example, consider the following vectors:\n<code>\na = [1,2,3]\nb = [4,5,6]\n\
    </code>\nWe can use collect + append as follows:\n<code>\ncollect(collect(a, length(b))+b)\n\
    </code>\nThe inner collect(a, length(b)) creates a vector of vectors and then\
    \ we concatenate b to that inner vector using +.\n<|/ a dscore=4 |>\n<| a tags=julia,vector,arrays,append\
    \ |>\nOne approach is\n<code>\npush!(append!(c[end], a), b)\n</code>\n<|/ a dscore=4\
    \ |>\n<| a dscore=4 tags=julia,vector,arrays,append |>\nFor a more general version\
    \ of this question, we can use broadcasting operations to solve it efficiently\
    \ as we can't concatenate vectors of different lengths efficiently.\nHere's a\
    \ simple example of how to do this using broadcasting:\n<code>\njulia> c = collect(1:5)\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5", "    # Return copy of list with\
    \ elements incremented by 1\n    w = copy(l)\n    for (i, _) in enumerate(w)\n\
    \        w[i] = w[i] + 1\n    end\n    return w\nend", "    return map((x+1))\
    \ l\nend", "    i = 0\n    while i < length(l)\n        l[i] = l[i] + 1\n    \
    \    i = i + 1\n    end\n    return l\nend", "    return map(incr, l)\nend\n</cell>\n\
    <text>\nincr(l::Vector{Int64})\nincr l returns a vector with elements incremented\
    \ by 1. \nincr l is equivalent to incr_list(l)\nincr(l::Vector{Int64}, i::Int64)\
    \ = incr_list(l)[i]", "    return vcat(l, l+1)\nend", "    local c = 1 \n    for\
    \ i in l\n        c += 1 \n        push!(l,i) \n    end \n    return l \nend\n\
    </cell>\n<code language=julia-1.0>\nincr_list([1,2,3])\n</cell>\n<code language=julia-1.0>\n\
    incr_list([5,3,5,2,3,3,9,0,123])\n</cell>\n<text>\nReverse a vector.\nThe reverse\
    \ function returns a new list with the same elements, in reverse.", "    l = copy(l)\n\
    \    for i in eachindex(l)\n        if isa(l[i], Int64)\n            l[i] += 1\n\
    \        else \n            l[i] = i + 1\n    end\n    return l\nend\n\"\"\"\n\
    \    IncrList increments elements of vector by 1\n    \"\"\"", "    l = l + Vector{Int64}([])\n\
    \    return l\nend\n</cell>\n<code language=julia-1.6>\nincr_list([1, 2, 3])\n\
    </cell>\n<text>\nCombine Vectors", "    v = Vector{Int64}()\n    push!(v, 1)\n\
    \    v = v + l\n    push!(v, 1)\n    return v\nend\n</cell>\n<code language=julia-1.4>\n\
    incr_list(1:10)\n</cell>\n<code language=julia-1.4>\n@time incr_list(1:10000000)\n\
    </cell>\n<text>\nThe time complexity is $O(n)$, where n is the length of the list.",
  "\tm = length(l) + 1\n\tVector{Int64}(m + 1)\n\tfor i in 1 : m\n\t\tm[i] = m[i-1]\
    \ + 1\n\tend\n\treturn l\nend\n</cell>\n<text>\nincr_list returns the list l with\
    \ the element at the end incremented by 1.", "    return Vector{Int64}(l .+ 1,\
    \ l[1]) \nend\n</code>\nNow we can use incr_list to increment any vector in place:\n\
    <code>\njulia> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n10-element Vector{Int64}:\n\
    \ 6\n 4\n 6\n 3\n 4\n 6\n 3\n 4\n 10\n 1\n124\n</code>\nAs you can see, this is\
    \ rather useful. We can write a macro to automatically generate these:\n<code>",
  "    l = copy(l)\n    for i=1:length(l)\n        l[i] = l[i] + 1\n    end\n    return\
    \ l\nend", "    l = copy(l)\n    l+=(length(l))\n    return l\nend", "    i =\
    \ Int.(l)\n    while i < length(l) do \n        l[i] = l[i] + 1 \n        i =\
    \ i+1\n    end\n    return l\nend", "    return collect(Int64, zip(l, 1 : length(l)-1))\n\
    end\n</cell>\n<code language=julia-1.4>\nincr_list([1, 2, 3])\n</cell>\n<text>\n\
    incr_list([1, 2, 3]) does not work as expected:", "    return [ x+1 for x in l\
    \ ]\nend", "    for i = length(l) downto 1 \n        l[i] = l[i] + 1 \n    end\
    \ \n    return l \nend \n</cell>\n<text>\nLet's see how these two functions work\
    \ (try running the cells below):", "    vec=copy(l)\n    for i in eachindex(vec)\n\
    \        vec[i]+=1\n    end\n    return vec\nend", "    l = l |> Vector{Int64}\n\
    \    l[1] = l[1] + 1\n    l\nend\n</cell>\n<text>\nExercise 3: Define a function\
    \ that returns the sum of the elements in the list given as an argument (if the\
    \ list is empty, return 0). The function should have type Int64.", "    incr =\
    \ 0\n    for i in l \n        incr += 1\n        push!(l, incr)\n        \n  \
    \  return l\nend\n</cell>\n<text>\nThe first function we wrote to count the elements\
    \ of a vector is named count in the Base library. The incr_list function we wrote\
    \ is very similar, but more efficient because it does not use recursion. This\
    \ function is easy to write:", "    idx = length(l) \n    if idx == 0 \n     \
    \   return l \n    l += ones([idx-1]) \n    l += zeros(idx-1) \n    return l \n\
    end\n</cell>\n<code language=julia-1.4>\nincr_list([1, 2, 3])\n</cell>\n<code\
    \ language=julia-1.4>\nincr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n</cell>\n<code\
    \ language=julia-1.4>\n\"\"\"Return vector with elements in the range `start`\
    \ to `end`.\n    >>> incr_list(start=1, end=10, step=3)\n    [1, 3, 6, 10]\n \
    \   >>> incr_list(start=-5, end=10, step=2)\n    [-4, -3, -2, -1, 0, 1, 2, 3,\
    \ 4, 5]\n\"\"\"", "    incr = Vector{Int64}(undef, 0)\n    i = length(l)\n   \
    \ while i > 0\n        incr \u2190 Vector{Int64}(undef, incr[-1] + 1)\n      \
    \  i -= 1\n    end\n    l \u2190 incr\n    return l\nend", "    l = l + ones(length(l))\
    \ * -1\n    return l\nend\n</cell>\n<code language=julia-0.6>\n\"\"\"Return matrix\
    \ with elements incremented by 1.\n    >>> incr_matrix([[1, 2], [3, 4]])\n   \
    \ [[2, 3], [4, 5]]\n    >>> incr_matrix([[5, 3, 5], [2, 3, 3], [9, 0, 123], [3,\
    \ 4, 4], [10, 1, 124], [6, 4, 6]])\n    [[6, 4, 6], [3, 4, 4], [10, 1, 124], [6,\
    \ 4, 6], [3, 4, 4], [10, 1, 124], [6, 4, 6], [3, 4, 4], [10, 1, 124], [6, 4, 6],\
    \ [3, 4, 4], [10, 1, 124], [6, 4, 6]]\n    \"\"\"", "    result = copy(l)\n  \
    \  i = length(result) - 1\n    while i >= 1 \n        result[i+1] = result[i+1]+1\n\
    \        i -= 1\n    end\n    return result\nend\n</cell>\n<code language=julia-0.6>\n\
    ?incr_list\n</cell>\n<code language=julia-0.6>\n@time incr_list($numbers);\n@time\
    \ incr_list($numbers2); \n@time incr_list($numbers3); \n@time incr_list($numbers4);\
    \ \n@time incr_list($numbers5); \n@time incr_list($numbers6); \n@time incr_list($numbers7);\n\
    </cell>\n<text>\nVectorized version for multiple arguments", "    l = copy(l)\n\
    \    for i in 2:length(l)\n        l[i] = l[i - 1] + 1\n    end\n    l\nend",
  "    if length(l) == 0 \n        return zeros(eltype(l))\n    elseif length(l) ==\
    \ 1 \n        return [1]\n    else\n        # incr_list(list(a)) = list(a) + [1]\n\
    \        # incr_list(list(a), b) = list(a) + [b]\n        # incr_list(list(a),\
    \ c, d) = list(a) + [c, d]\n        return add(l, 1)\n    end\nend", "    n =\
    \ length(l)\n    if n == 0\n        Vector{Int64}()\n    else\n        l = l +\
    \ [1]\n        return l\n    end\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\n\
    I guess you meant `return l + 1` ?\n<|/ c |>\n<| c |>\nAlso, one should use `Int64`\
    \ instead of `Int` for performance.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  \
    \  return map(x -> x + 1, l)\nend", "    l = l + [0 for i in 1:length(l)] \n \
    \   l\nend\n</cell>\n<code language=julia-0.6>", "    if length(l)==0 \n     \
    \   l \n    elseif length(l)==1\n        l:=[l[1]+1] \n    else\n        l=l[1:end-1]+l[end]\
    \ \n    end\nend\n</cell>\n<code language=julia-1.5>\n# Define the function `incr_list`\
    \ that takes a list of integers and returns vector with elements incremented by\
    \ 1.", "    for i = 1:length(l)\n        l[i] = l[i] + 1\n    end\n    l\nend\n\
    </cell>\n<text>\nThe function incr_list() returns a new vector with the elements\
    \ of l incremented by 1.", "    Vector{Int64}(l + [1])\nend", "    l = l + Int64(1)\n\
    end\n</cell>\n<code language=julia-1.3>\n# TEST Return vector with elements incremented\
    \ by 1\n@test incr_list([1, 2, 3]) == [2, 3, 4]\n@test incr_list([5, 3, 5, 2,\
    \ 3, 3, 9, 0, 123]) == [6, 4, 6, 3, 4, 4, 10, 1, 124]\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that returns its first argument.", "    return map(inc,l)\n\
    end", "    l = l + [1]\n    return l\nend", "    return l + ((length(l)-1)*1)\n\
    end\n</cell>\n<text>\nSum all the elements in a list\nLet's say that we want to\
    \ keep track of how many times we see each element in a list. One approach would\
    \ be to create a dictionary and increment each element as we see it, but since\
    \ dictionaries are unordered, this will not be deterministic. Instead, we can\
    \ just sum the elements themselves.", "  n = length(l)\n  ret = Array{Int64}(n)\n\
    \  for i in 1:n\n    ret[i] = l[i] + 1\n  end\n  return ret\nend", "    #incr\
    \ returns the current value plus the next value in the vector.\n    l += l[1]\n\
    \    return l\nend\n</cell>\n<code language=julia-0.5>\n#Example: Vector with\
    \ elements incremented by 1\nincr_list([1, 2, 3])\n</cell>\n<code language=julia-0.5>\n\
    #Example: List with elements incremented by 1\nincr_list([5, 3, 5, 2, 3, 3, 9,\
    \ 0, 123])\n</cell>\n<code language=julia-0.5>\n#Example: Vector with elements\
    \ decremented by 1\ndecr_list([2, 3, 4])\n</cell>\n<code language=julia-0.5>\n\
    #Example: Vector with elements incremented by 1 and then decremented by 1\ndecr_list([2,\
    \ 3, 4], [1, 1])\n</cell>\n<code language=julia-0.5>\n\"\"\"Return matrix with\
    \ elements incremented by 1.\n>>> incr_matrix([1 2 3; 4 5 6])\n    2   3   4 \
    \  5   6\n    3   4   5   6   7\n    4   5   6   7   8\n\"\"\"", "    l.push!(l.last+1)\n\
    \    return l\nend", "    if length(l) == 1\n        return l\n    else\n    \
    \    head = l[1]\n        tail = l[2:end]\n        return [head+1]+incr_list(tail)\n\
    \    end\nend", "\tn=0\n\tfor i=1:length(l)\n\t\tn+=1\n\t\tl[i]=l[i]+n\n\tend\n\
    \treturn l\nend", "    l = l + [0; len((l))+1]\n    return l\nend\n</cell>\n<text>\n\
    Let's now try it out with a vector:", "    for i in eachindex(l)\n        l[i]\
    \ = l[i] + 1\n    end\n    return l\nend", "  r = Vector{Int64}(undef, length(l))\n\
    \  for i = 1:length(r)\n    r[i] = l[i] + 1\n  end\n  return r\nend\n</cell>\n\
    <code language=julia-1.0>\nincr_list([1,2,3])\n</cell>\n<code language=julia-1.0>",
  "    @assert length(l) == length(unique(l))\n    @assert !isempty(l)\n    aux =\
    \ Vector{Int64}(undef, 0)\n    for v in l\n        aux = v + aux\n    end\n  \
    \  return aux\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Return vector with\
    \ elements decremented by 1.\n    >>> decr_list([1, 2, 3])\n    [3, 2, 1]\n  \
    \  >>> decr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 2, 6, 4, 5, 4, 11, 2,\
    \ 124]\n    \"\"\"", "    i = length(l) + 1\n    push!(l, i)\n    l\nend\n</cell>\n\
    <text>\n3. Apply incr_list to our vector", "    return Vector{Int64}(l.base+1:end)\n\
    end\n</cell>\n<code language=julia-1.0>\n@code_warntype incr_list([1, 2, 3])\n\
    </cell>\n<text>\nIncr!", "    @assert(all(isfinite(l)) && all(isfinite(l.data)))\n\
    \    n = length(l) - 1\n    for i in 1:n\n        l[i] = l[i] + 1\n    end\n \
    \   return l\nend", "    size = length(l)\n    for i = 2:(size-1)\n        l[i]\
    \ = l[i] + 1\n    end\n    return l\nend", "    return l.*(2:end-1)\nend", " \
    \   result = []\n    for i in l\n        push!(result, i + 1)\n    end\n    return\
    \ result\nend", "    incr_vec_new(l)\nend", "    return map((+),l)\nend\n</cell>\n\
    <code language=julia-0.5>", "    return l.map(x + 1) \nend\n</cell>\n<code language=julia-1.5>",
  "    # initialize result list\n    res = Vector{Int64}()", "    return l + [1 for\
    \ i in 1:length(l)]\nend", "    l = sort(l)\n    i = length(l)\n    while i !=\
    \ 0\n        i = i - 1\n        l[i] = l[i] + 1\n    end\n    return l\nend\n\
    </code>\nNow we can use that to compute your results for our examples.\n<code>\n\
    julia> incr_list(x)\n10-element Vector{Int64}:\n 3\n 6\n 3\n 4\n 6\n 4\n 3\n 4\n\
    10\n</code>\nThe other way is to just do that in a loop which can be quite efficient.\n\
    <code>\njulia> for x in x\n           x = x + 1\n       end\n</code>\nThat is\
    \ the preferred way to go in Julia. Julia is designed to be very efficient for\
    \ array processing.\n<|/ a tags=arrays,julia |>\n<| c |>\nThanks for the response!\
    \ The code you posted is incorrect, it should return [2, 3, 4], [5, 6, 5], [6,\
    \ 4, 6], and so on...\n<|/ c |>\n<| c |>\nThat's what I thought at first too,\
    \ but if you look at the code you can see that it's doing what it should.\n<|/\
    \ c |>\n<| c |>\nAh I see what you mean now. So the issue is the looping through\
    \ the array and incrementing each value individually isn't the most efficient\
    \ way of doing it? The code you've posted above seems very inefficient, am I correct\
    \ in saying that?\n<|/ c |>\n<| c |>\nI've added a second way that will run faster.\
    \ The looping through a vector and updating it like you were doing was unnecessary\
    \ since the array itself would get updated.\n<|/ c |>\n<| a tags=arrays,julia\
    \ |>\nYour issue is that incr_list returns a vector of Int64 while you assign\
    \ it to a vector of Float64 (notice the f at the end).\nJust change the code inside\
    \ the function incr_list to:\n<code>\nreturn [x + 1 for x in l]\n</code>\nand\
    \ you will get the correct result.\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nThis\
    \ is an extension of my previous answer.  I think it's fair to say that it's important\
    \ to understand that the type of a value is not the same as the type of a variable\
    \ that holds the value.\nIn the question, the type of x is Int64.  So incr_list\
    \ returns a vector of Int64, while it is assigned to an array with Float64 elements.\
    \  The code [x + 1 for x in l] will indeed solve the problem.\nBut what if I want\
    \ to write a function that is only defined for a subset of possible types?  That\
    \ is, I want my function to work for types that have a constructor, like: Int64,\
    \ Float", "    i = length(l) + 1 \n    l = l[(i-1)::end]\n    return l\nend\n\
    </cell>\n<code language=julia-1.5>\nincr_list([1, 2, 3])\n</cell>\n<text>\nTask\
    \ 2.1.3 Create random permutation of a list and return a new list\nThe function\
    \ should create a new list with randomly shuffled elements of an already existing\
    \ list l.", "    return [v+1 for v in l]\nend", "\tn = length(l) \n\tout = similar(l)\
    \ \n\tfor i in 1:n \n\t\tout[i] = out[i] + 1 \n\tend \n\treturn out \nend\n</cell>\n\
    <code language=julia-1.6>\nincr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n</cell>\n\
    <code language=julia-1.6>", "    return Vector{Int64}(length(l)+1, 0) * l \nend\n\
    </cell>\n<code language=julia-0.5>", "    return l\nend", "    l += ones(length(l))\n\
    \    l\nend\n</cell>\n<text>\nNow let's put those two functions together in a\
    \ single function.", "  \n  new_list = Vector{Int64}(l)\n  \n  for i = 1:length(l)\n\
    \    new_list[i] = new_list[i] + 1\n  end\n  \n  return new_list\nend\n</cell>\n\
    <code language=julia-1.3>\n\"\"\" Return vector with elements decremented by 1.\n\
    \    >>> decr_list([1, 2, 3])\n    [1, 2, 2]\n    >>> decr_list([5, 3, 5, 2, 3,\
    \ 3, 9, 0, 123])\n    [5, 5, 5, 4, 4, 10, 1, 10, 0]\n    \"\"\"", "    if length(l)\
    \ == 0\n        return l\n    end\n    first = first(l) \n    l[first] = last(l)\
    \ + 1 \n    return l \nend\n</code>\nThe function incr_list returns a copy of\
    \ the list with the elements incremented by 1 starting at the first element.\n\
    You can now run each of the function below to see what happens.\n<code>", "  \
    \  res = zeros(Int64, length(l))\n    for i=1:length(l)\n        res[i] = l[i]+1\n\
    \    end\n    return res\nend\n</cell>\n<text>\nTask 2\nWrite a function that\
    \ counts the number of times a certain value appears in a given list. Your function\
    \ should accept the list as a parameter and return an integer", "    if length(l)==0\n\
    \        Vector{Int64}()\n    else\n        incr(l)\n    end\nend", "    for i\
    \ = 1:length(l)\n        l[i] = l[i] + 1\n    end\n    return l\nend", "    l\
    \ = l .+ 1\n    return l\nend ", "    Vector{Int64}([i+1 for i in l])\nend\n</cell>\n\
    <code language=julia-1.3>\nincr_list([1, 2, 3])\n</cell>\n<code language=julia-1.3>",
  "    l = copy(l)\n    local i\n    if length(l) == 0 \n        return l\n    elseif\
    \ length(l) == 1\n        l[1] += 1\n        return l\n    else\n        error(\"\
    IncrList can only update a list of length 1 or greater\")\n    end\nend\nincr_list(l)",
  "    return [ l[i] += 1  for i = 1:length(l)    ]\nend\n</cell>\n<code language=julia-1.0>\n\
    incr_list([1, 2, 3])\n</cell>\n<code language=julia-1.0>\nincr_list([5, 3, 5,\
    \ 2, 3, 3, 9, 0, 123])\n</cell>\n<text>\nFunction to add 1 to all elements in\
    \ list, while shifting all elements left.", "    return l .+ 1\nend\n</code>\n\
    <|/ a |>\n<| a dscore=1 tags=julia,list |>\nYou can use the + operator, as you\
    \ pointed out yourself. But there are several alternatives. I present two of them:\n\
    <code>\njulia> [x + 1 for x in [1, 1, 1]]\n3-element Vector{Int64}:\n 2\n 2\n\
    \ 2", "    incr_l =  l[1] + 1 \n    return incr_l \nend ", "    # we might want\
    \ to replace this with something that \n    # uses a builtin instead of an anonymous\
    \ function\n    i = length(l) - 1\n    acc = l[i]\n    while i > 0 \n        acc\
    \ = acc + l[i - 1]\n        i -= 1\n    end\n    return acc\nend", "    if isa(l,Vector{Int64})\
    \ == false\n        error(\"list is not a vector\")\n    end\n    h = collect(0:length(l)-1)\n\
    \    z = copy(l)\n    for i in length(h):-1:1\n        z[i] = z[i+1]+1\n    end\n\
    \    z\nend", "  return [x + 1 for x in l]\nend", "    lenl = length(l)\n    if\
    \ lenl == 0\n        return zeros(0)\n    end\n    res = []\n    i = 1 \n    while\
    \ i <= lenl\n        res.append(l[i-1] + 1)\n        i = i + 1\n    end\n    return\
    \ res\nend\n</code>\nThis function works on any Vector{Int64}. \nYou can test\
    \ it with\n<code>\njulia> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123, 1])\n10-element\
    \ Array{Int64,1}:\n  6\n  4\n  6\n  3\n  4\n  4\n  1\n  1\n  1\n  1\n  1\n  1\n\
    \  1\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThe code in the answer below is now\
    \ obsolete.\n<|/ c |>\n<| a dscore=3 |>\nFor completeness, here is a solution\
    \ that is more memory efficient, uses no intermediate array and works for any\
    \ input type (including Vector):\n<code>", "    l = length(l)+1 \n    Vector{Int64}(l)\n\
    end", "    \n    for n in l\n        n = n + 1\n    end\n    return l\nend\n</cell>\n\
    <text>\nTesting your functions\nWe will use unit tests so we can check our code\
    \ by hand.", "    v = Vector{Int64}()\n    for x in l\n        v = v + [x]\n \
    \   end\n    return v\nend", "    return Vector{Int64}([x + 1 for x in l])\nend\n\
    </cell>\n<code language=julia-0.4>\nincr_list([1, 2, 3])\n</cell>\n<code language=julia-0.4>\n\
    incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n</cell>\n<text>\nExercise 4\nWrite a\
    \ function that returns the vector v of integers from 1 to n.", "    v = copy(l)\n\
    \    for i = 1:length(v)\n        v[i] = v[i] + 1\n    end\n    return v\nend\n\
    </cell>\n<code language=julia-1.5>\nincr_list([1,2,3])\n</cell>\n<code language=julia-1.5>\n\
    incr_list([5,3,3,2,3,9,0,123])\n</cell>\n<text>\nIn Julia it is also possible\
    \ to do these things in the following ways:", "    l = l + [el for el in l]\n\
    \    return l\nend\n</cell>\n<code language=julia-1.5>", "    l = l + 1 \n   \
    \ return l \nend", "  if length(l)==0\n    Vector{Int64}()\n  else\n    l[1:end-1].+(l[end]-1)\n\
    \  end\nend\n</cell>\n<code language=julia-1.5>", "    l = l + 1 \n    Vector{Int64}(l)\n\
    end\n</cell>\n<cell>\n#export", "    for i::Int64 in 1 : length(l)\n        l[i]\
    \ += 1 \n    end\n    return l \nend\n</code>\n<|/ a |>\n<| c |>\nI agree.  I\
    \ wish OP accepted this answer instead of mine.\n<|/ c |>\n<| a dscore=0 |>\n\
    If you don't mind using Julia packages, you can use \"Iterators\".\n<code>\nusing\
    \ Iterators", "    ind = 0\n    n = 0\n    while ind < length(l) and n < length(l)\n\
    \        n+=1\n        l[ind+1] = l[ind]\n        ind+=1\n    end\n    return\
    \ l\nend", "    return l++\nend", "    l = l |> sort!\n    len::Int = length(l)\n\
    \    v = Vector{Int64}(len + 1)\n    v[1] = v[2] = 0\n    for i in 2:len\n   \
    \     v[i] = v[i-1] + 1\n    end\n    v\nend\n</cell>\n<text>\nFunction to count\
    \ the frequency of elements in a list:", "    ret = copy(l)\n    for i=1:length(ret)-1\n\
    \        ret[i] += 1 \n    end\n    return ret\nend\n</cell>\n<text>\nExercise:\
    \ Write a function called incr_vec that performs the incr_list function.", " \
    \   return l + [elem+1]\nend\n</cell>\n<text>\nExercise 3\nWrite a function named\
    \ incr_elem that takes an input array and a number as arguments. \nIf the element\
    \ of the array is greater than the number, then it should increment by 1.\nIf\
    \ the element of the array is less than or equal to the number, then it should\
    \ remain as is.", "    \"\"\"Increment list by 1.\"\"\"\n    if isa(l, Vector)\n\
    \        l = [x for x in l .+ [1]]\n    elseif isa(l,[Int64])\n        l .+= 1\n\
    \    else\n        error(\"Cannot increment non-numeric list\")\n    end\nend",
  "    if length(l) == 0 \n        error(\"Vectors with length 0 not supported.\"\
    )\n    end\n    ret = copy(l)\n    for i=1:length(l)\n        ret[i] = ret[i]\
    \ + 1\n    end\n    ret\nend\n</cell>\n<text>\nThe last function incr_vector can\
    \ be used to increment a vector by 1. For example:", "   if length(l) == 0 \n\
    \       return l\n   else\n       return incr_list(l[1:end-1]) + [l end]\n   end\n\
    end\n</cell>\n<code language=julia-0.6>", "  Vector{Int64}(l.len()) \n  for i\
    \ = 1:length(l)\n     l[i] = l[i] + 1\n  end\n  l\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| a dscore=0 tags=julia |>\nIn Julia, you can create a vector using a comprehension\
    \ like so\n<code>\na = [1,2,3]\nb = [i for i in 1:length(a)]\n</code>\nand then\
    \ you can perform operations on b like sum or multiply\n<code>\nsum(b)\n</code>\n\
    or\n<code>\nprod(b)\n</code>\n<|/ a |>\n<| c |>\nThis is actually quite inefficient\
    \ if your lists are very large because of the copy overhead.\n<|/ c |>\n<| c |>\n\
    What would be the efficient way to do it?\n<|/ c |>\n<| c |>\n: You would need\
    \ to do some benchmarking to see what works best for you. Another alternative\
    \ is `zip` from the `IterTools` package\n<|/ c |>\n<| c |>\nActually `zip` is\
    \ even slower than the list comprehension above. `zip` is a much slower alternative\
    \ and it is actually less efficient than the list comprehension.\n<|/ c |>\n<|\
    \ c |>\nThank you, I didn't know zip was slower than list comprehension. I will\
    \ go with itertools then.\n<|/ c |>\n<| a dscore=0 |>\nYou can use an iterator\
    \ to loop through your list without copying the entire list. \n<code>", "    \"\
    \"\"Increment elements in list l by one.\"\"\"\n    return Vector{Int64}(l + [1])",
  "    length(l) + 1 \nend\n</cell>\n<code language=julia-1.5>\nincr_list([5, 3, 5,\
    \ 2, 3, 3, 9, 0, 123])\n</cell>\n<text>\nA second function incr_list() was already\
    \ defined in the previous exercise. Now we have the chance to write a third one:",
  "    return l  \nend\n</cell>\n<code language=julia-1.5>\nincr_list([5, 3, 5, 2,\
    \ 3, 3, 9, 0, 123])\n</cell>\n<code language=julia-1.5>", "    l = l + 1 \n  \
    \  l\nend\n</cell>\n<code language=julia-0.5>\n@time incr_list(l1)\n@time incr_list(l2)\n\
    @time incr_list(l3)\n@time incr_list(l4)\n@time incr_list(l5)\n@time incr_list(l6)\n\
    @time incr_list(l7)\n@time incr_list(l8)\n</cell>\n<text>\nThe function incr_list()\
    \ returns a new list, but this list contains the elements of the original\nlist\
    \ incremented by 1.\nWe can see that the original list has grown larger from 5\
    \ to 15, and that it was already quite a bit\nof memory allocated for a list with\
    \ a length of 15 or more.", "        \n    for i=1:length(l)\n        l[i]+=1\n\
    \    end\n    return l\nend", "    if length(l) < 2 \n        l \n    else \n\
    \        l .+ (l[end-1]+1) \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    # incr_list works also on Vectors of Float64!", "    result = Vector{Int64}(length(l)+1)\n\
    \    result[1:end-1] = l\n    result\nend", "    v = [v+1 for v in l]\n    return\
    \ v\nend\n</cell>\n<text>\nThis works by using list comprehension to generate\
    \ a new vector by adding 1 to each element in the original vector", "    l = l\
    \ |> collect{x->x+1}\n    return l\nend\n</cell>\n<text>\nincr_list()", "    l\
    \ = l[:]\n    for (i, v) in enumerate(l)\n        v+=1\n        l[i] = v\n   \
    \ return l\nend", "    aux=l\n    for i=1:length(l)\n        if aux[i+1] < l[i]\n\
    \            aux[i+1] = aux[i+1]+1\n        else\n            break\n        end\n\
    \    end\n    aux\nend", "    for x in l do \n       x = x + 1\n       return\
    \ x\nend\n</cell>\n<text>\nLet's define a few more functions.  They will be easier\
    \ to test the final versions.", "    idx = 0\n    for x in l\n        idx += 1\n\
    \        l[idx] = x\n    end\n    return l\nend", "    return l.map((x) -> x +\
    \ 1)\nend\n</cell>\n<code language=julia-1.3>\n\"\"\"Return the index to left\
    \ of the element x", "    res = Vector{Int64}(length(l))\n    for i in 1:length(l)\n\
    \        res[i] = l[i] + 1\n    end\n    return res\nend", "    l = l + [0; length(l)-1]\n\
    \    return l\nend\n</cell>\n<text>\nExercise\nWrite a function that splits a\
    \ list l into n chunks\nwhere n is the length of the list.\nWrite a function that\
    \ splits a list l into n chunks\nwhere n is the length of the list.\nWrite a function\
    \ that splits a list l into n chunks\nwhere n is the length of the list.\nWrite\
    \ a function that splits a list l into n chunks\nwhere n is the length of the\
    \ list.\nWrite a function that splits a list l into n chunks\nwhere n is the length\
    \ of the list.\nWrite a function that splits a list l into n chunks\nwhere n is\
    \ the length of the list.\nWrite a function that splits a list l into n chunks\n\
    where n is the length of the list.\nWrite a function that splits a list l into\
    \ n chunks\nwhere n is the length of the list.", "    res = similar(l)\n    map!((index)\
    \ -> (index+1)::Int64, res)\n    return res\nend", "    v = copy(l)\n    push!(v,v[1])\n\
    \    push!(v,v[2]+1)\n    return v\nend", "    # incr_list([5,3,5,2,3,3,9,0,123])\
    \ = [6,4,6,3,4,4,10,1,124]\n    vec = Vector{Int64}(undef, length(l))\n    for\
    \ (i,val) in enumerate(l)\n        vec[i] = val+1\n    end\n    return vec\nend\n\
    </cell>\n<text>\nExercise 1\nWrite a function which returns the number of times\
    \ each element appears in the passed vector. \nFor example, incr_counts([1,2,1,5,3,1,1,3,2,4,2])\
    \ should return a dictionary {1 => 3, 2 => 2, 3 => 2, 4 => 1}.", "    if isa(l,Vector)\n\
    \        l = l |> sort\n        l = l |> collect((:))\n    else \n        l =\
    \ l |> collect((:))\n        for i=length(l):-1:1\n            l[i+1] = l[i]+1\n\
    \        end\n    end\n    return l\nend\n</code>\n<|/ a dscore=3 |>\n<| a tags=julia\
    \ |>\nI thought about this and decided to solve this problem using Julia syntax\
    \ instead of loops, as I feel Julia is good at handling lists and vectors.\nAs\
    \ we saw, there are two functions that need to be defined: one to increment a\
    \ list by one, and one to reverse the order of a list. These functions will look\
    \ something like this.\n<code>\n# Define a function that increments a list by\
    \ one", "    return l + [1, ]\nend", "    incr = l + 1 \n    l[1:end-1] = incr[1:end-1]\
    \ \n    return l \nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Return matrix\
    \ with elements incremented by 1.\n    >>> incr_mat((1,2))\n    [1 2 3 4]\n  \
    \  >>> incr_mat([1,2, 3])\n    [1 2 3 4]\n    \"\"\"", "    return l |> Vector{Int64}(l\
    \ |> tail |> map(_ + 1))\nend", "  return l+1\nend\n</cell>\n<code language=julia-1.4>\n\
    # Test it\nincr_list([1, 2, 3])\n</cell>\n<text>\nThe function randint(a,b) generates\
    \ random integers a and b (both inclusive) in the range 0 to b-1. It should be\
    \ noted that a random integer can be generated with replacement, i.e. a has probability\
    \ of 0.1 that another integer will also be generated with probability 0.1.", " \
    \   result=[]\n    for i=1:length(l)\n        result[i]=l[i]+1\n    end\n    return\
    \ result\nend", "    l = copy(l)\n    for i in length(l); i = i+1\n        l[i]\
    \ = l[i] + 1\n    end\n    return l\nend", "    incr_list = fill(NaN, (length(l)-1))\n\
    \    for i in 2:length(l)\n        incr_list[i-1] = incr_list[i-2]+1\n    end\n\
    \    return l\nend\n</cell>\n<code language=julia-1.5>\n# Now test it!\n@assert\
    \ isapprox(incr_list(collect(1:10))) == incr_list(collect(1:10))\n@assert isapprox(incr_list(collect(1:10)))\
    \ == incr_list(collect(1:10))\n@assert isapprox(incr_list([1,2,3,4,5,6,7,8,9,10]))\
    \ == incr_list([1,2,3,4,5,6,7,8,9,10])\n@assert isapprox(incr_list(collect(1:10)))\
    \ == incr_list(collect(1:10))\n</cell>\n<text>\nPart 2: Generating random numbers\
    \ with Distributions\nWe have already seen a few ways to generate random numbers\
    \ in Julia. Here are two more: uniform and random. These are used to generate\
    \ random numbers from a uniform distribution on the unit interval ($[0,1]$) or\
    \ a uniform distribution with a specified $\\mu$ and $\\sigma$ parameters. Both\
    \ can be combined together into a generator function as below, with optional seeding\
    \ to allow you to control the random numbers generated.", "    v = Vector{Int64}(l)\
    \ \n    last = v[end] \n    v[end] = v[end] + 1 \n    return v\nend\n</code>\n\
    And now the other way around without mutation, so it is faster:\n<code>", "  \
    \  l = copy(l)\n    n = 1\n    for i in l \n        n += 1\n        l[i] = n\n\
    \    end\n    l\nend\n</cell>\n<code language=julia-1.5>\n# test function\nincr_list([1,\
    \ 2, 3])\n</cell>\n<text>\n3. Sort a list\nFor any data structure A of which the\
    \ element type is some kind of an immutable (like Int), we can use A as the key\
    \ of a map.", "    l = copy(l)\n    length(l) += 1\n    return l\nend\n</cell>\n\
    <code language=julia-1.1>\n?incr_list\n</cell>\n<code language=julia-1.1>\n@time\
    \ incr_list([5,3,5,2,3,3,9,0,123])\n</cell>\n<text>\nExercise: Create a function\
    \ that removes a value from a list.", "    v = Vec{Int64}(undef, length(l)+1)\n\
    \    v[end] = l[end]\n    for i = length(l)-1:-1:1\n        v[i+1] = l[i+1]\n\
    \    end\n    v\nend", "    # Vector{Int64} will implicitly convert the input\
    \ to a Vector{Int64}\n    # since they have identical definitions\n    l = copy(l)\n\
    \    for i = 1:length(l)\n        l[i] += 1\n    end\n    l\nend\n</cell>\n<code\
    \ language=julia-1.4>\nincr_list([1, 2, 3])\n</cell>\n<text>\nThe function append(el1,\
    \ el2, el3, ..., elm) is used to add elements to a vector. The first element in\
    \ the vector is el1, the second element is el2, the third element is el3, and\
    \ so on. Note that the return type for append() is a vector, so this function\
    \ is equivalent to append!() in other languages.", "    return Vector{Int64}([x\
    \ + 1 for x in l])\nend\n</cell>\n<code language=julia-1.5>", "    return l |>\
    \ incr \nend\n</cell>\n<code language=julia-1.4>", "    return l + 1:(1:l) \n\
    end\n</cell>\n<code language=julia-1.5>", "    return l[1:end-1] + ones(length(l)\
    \ - 1)\nend\n</cell>\n<code language=julia-1.6>\nincr_list([1, 2, 3])\n</cell>\n\
    <code language=julia-1.6>\nincr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n</cell>\n\
    <text>\n3. Remove duplicates from a list\nTo remove duplicates from a list, we\
    \ use the function unique.", "    if length(l) == 0, return 0 \n    incr = 0\n\
    \    l = l .+ 1\n    for v in l\n        incr = incr + v \n    end\n    return\
    \ incr\nend", "    if !all(ismember(i->i, l))\n        error(\"invalid list -\
    \ all elements should be present for the list to be incremented\")\n    else\n\
    \        map(x->x+2, l) \n    end\nend\n</cell>\n<code language=julia-1.5>\n\"\
    \"\"Return the string with elements in reverse order. \n    Elements are joined\
    \ by a single space.\n    >>> incr_string(\"1 2 3\")\n    \"3 2 1\"\n    >>> incr_string(\"\
    5\")\n    \"5\"\n    \"\"\"", "    v = clone(l)\n    length(v)=length(v)-1\n \
    \   return v\nend", "    # return Vector{Int64}((1:size(l))*l)\n    return Vector{Int64}(1:size(l))*l\n\
    end\n</cell>\n<code language=julia-1.5>\n## Example", "    \"\"\"\n    Incr list\
    \ elements in-place\n    \"\"\"\n    return collect(l + 1)\n</code>\n<|/ a dscore=4\
    \ |>\n<| a tags=julia,increment |>\nThe other two answers pointed out that Vector{Int}\
    \ does not have a function inc! which would do what you need. But if you're using\
    \ Julia 1.2 or later, you can! \n<code>\njulia> v = Vector{Int}(5,6,7)\n5-element\
    \ Vector{Int64}:\n 5\n 6\n 7", "    if length(l)==0\n        error(\"list not\
    \ of size 0 or empty\")\n    elseif length(l)==1\n        return l\n    elseif\
    \ l[1]>0\n        push!(l, l[1]+1);\n        return l\n    else\n        push!(l,\
    \ l[1]-1);\n        return l\n    end\nend", "    l = l + 1 \n    return l \n\
    end\n</cell>\n<code language=julia-1.5>\n@time incr_list(1:1000000);\n@time incr_list(1:1000000);\n\
    @time incr_list(1:1000000);\n@time incr_list(1:1000000);\n@time incr_list(1:1000000);\n\
    </cell>\n<code language=julia-1.5>", "    @assert all(e >= 0 for e in l) \n  \
    \  idx = length(l) - 1\n    while idx>=0 \n        if l[idx]==1\n            l[idx]\
    \ = 0\n            l[idx+1] += 1\n            return l\n        else\n       \
    \     idx = idx-1\n    end\n    throw(UndefRefError(\"undefined value found\"\
    ))\nend", "    return l.+(1)\nend", "    return copy(l) + [nothing]\nend\n</cell>\n\
    <text>\nExercise 2: Using a list comprehension to return a list of incremented\
    \ doubles.", "    x = length(l)\n    l1 = zeros(x)\n    for i in 1:x\n       \
    \ l1[i+1] = l[i] + 1\n    end\n    return l1\nend\n</cell>\n<text>\nincr_list()\
    \ does not mutate l, but it creates a new vector of the same length as l. \nThe\
    \ elements of l1 are initialized to 0", "    new_l = []\n    for n in l\n    \
    \    new_l += [n+1]\n    end\n    return new_l\nend", "    return Vector{Int64}(l.len()+1,\
    \ 0)\n    for i = 1:length(l)\n        l[i+1] = l[i] + 1\n    end\n    l\nend\n\
    </code>\n<|/ a |>\n<| c |>\nI agree, that would be a lot better than my answer,\
    \ but I don't want to spend too much time on it :)\n<|/ c |>\n<| c |>\nOh, I totally\
    \ agree. Thank you for reminding me that I have the habit of copypasting code\
    \ from other answers without actually knowing how it works.\n<|/ c |>\n<| a dscore=0\
    \ tags=julia |>\nI cannot comment on the efficiency of the code, but it does what\
    \ it has to do:\n<code>", "    l = incr_list(l)\n    return l\nend", "    l =\
    \ l .+ 1\n    return l\nend", "    n = length(l)\n    if n == 0 \n        l \n\
    \    elseif n == 1 \n        [l[0] + 1]\n    else\n        rest = incr_list(last(l))\n\
    \        rest += [l[0] + 1]\n    end\nend\n</cell>\n<text>\nQuestion 9: Vectorized\
    \ Version\nWrite a vectorized version of the incr_list function above which operates\
    \ over the entire list at once.", "    l .+= 1\n    return l\nend\n</cell>\n<code\
    \ language=julia-1.4>\nincr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n</cell>\n<text>\n\
    Exercise 3: Write a function incr_vec that returns the vector incremented by 1\
    \ in the same way as incr_list.", "    l = l .+ 1 \n    return l \nend", "   \
    \ Vector{Int64}([x + 1 for x in l])\nend\n</cell>\n<code language=julia-1.3>\n\
    @code_native incr_list\n</cell>\n<text>\nTo calculate the distance between vectors,\
    \ use the norm() function:", "    return l + [1]\nend", "    return collect(1:length(l))\n\
    end", "    return l + 1 \nend ", "    l += 1 \n    return l \nend\n</cell>\n<code\
    \ language=julia-1.5>", "    l = l[1:end-1] + l[2:end] + l[3:end-1] + l[4:end]\n\
    \    return l\nend", "    l = copy(l)\n    for (i, v) in enumerate(l)\n      \
    \  if v==0\n            l[i] = 1\n        else\n            l[i] = v+1\n     \
    \   end\n    end\n    return l\nend\n</cell>\n<code language=julia-1.5>", "  ret\
    \  = Vector{Int64}(0)\n  local n = 0\n  for elem in l \n    ret[n+1] = elem+1\n\
    \    n += 1\n  end\n  return ret\nend\n\"\"\"\n  Add list l to vector v\n  \n\
    \  Arguments\n  ---------\n  v::Vector{Int64}\n    List to add to vector v\n \
    \ l::Vector{Int64}\n    List to add to vector v", "    return Vector{Int64}(l.max\
    \ + 1, l)\nend\n</cell>\n<cell>\n@doc incr_list\n</cell>\n<text>\nWe can easily\
    \ check the vectorization and see the performance improvement:", "    l = copy(l)\n\
    \    for i in length(l):\n        if l[i] < 0\n            l[i] += length(l) +\
    \ length(l[i:])\n        end\n    end\n    return l\nend", "    tmp = length(l)\
    \ + 1\n    result = Vector{Int64}(undef, tmp)\n    i = 0\n    while i<tmp\n  \
    \      result[i] = l[i]\n        i = i + 1\n    end\n    result\nend\n</cell>\n\
    <code language=julia-1.4>\nincr_list([1, 2, 3])\n</cell>\n<code language=julia-1.4>\n\
    incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n</cell>\n<text>\nExercises\nExercise\
    \ 1:\nHow would you define a function which adds a number to a vector? The function\
    \ would return the modified vector, without modifying the original vector.", " \
    \   aux = Vector{Int64}(l); \n    for i in aux \n        aux[i] = aux[i] + 1 \n\
    \    return aux \nend", "    return l |> List.reduce(+, 1) |> Vector{Int64}\n\
    end", "    return l.map(x => x + 1)\nend\n</cell>\n<code language=julia-1.5>\n\
    incr_list([1, 2])\n</cell>\n<text>\nDecrement a list\nSimilar to increment, except\
    \ it returns the original list, not a vector with incremented elements.", '    return
    l .+ (1 .- l)', "    for x in l\n        x.+1\n    end\n    return l\nend\n</code>\n\
    <|/ a |>\n<| c |>\nWhy not just `x + 1`?\n<|/ c |>\n<| c |>\nThis does work, thanks!\
    \ I'm going to try to adapt this to make it work for my application.\n<|/ c |>\n\
    <| c |>\n`x + 1` would work too in this case, but using `x.+1` would also work.\
    \ I used `x.+1` so `incr_list` can be used as a generic function instead of just\
    \ `incr_list`.\n<|/ c |>\n<| c |>\n, yes, that is true. I did mean to write `x\
    \ + 1` but I forgot the `()` in my previous comment. Thanks for reminding me!\n\
    <|/ c |>\n<| a tags=julia,vector |>\nYou just need to make a new vector with the\
    \ old vector plus 1 \n<code>\njulia> a = [1,2,3,4,5]\n5-element Array{Int64,1}:\n\
    \ 1\n 2\n 3\n 4\n 5"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
