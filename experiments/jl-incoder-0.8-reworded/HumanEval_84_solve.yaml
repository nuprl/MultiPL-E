name: HumanEval_84_solve
language: jl
prompt: "\"\"\"Given a positive integer N, return the total sum of its digits in binary.\n\
  \    \n    Example\n    >>> solve(1000)\n    \"1\"\n    >>> solve(150)\n    \"110\"\
  \n    >>> solve(147)\n    \"1100\"\n    \n    Variables:\n        @N integer\n \
  \            Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string\
  \ of binary number\n    \"\"\"\nfunction solve(N::Int64)::String \n"
tests: "using Test\n\n@testset begin\n\ncandidate = solve;\n\t@test(candidate(1000)\
  \ == \"1\")\n\t@test(candidate(150) == \"110\")\n\t@test(candidate(147) == \"1100\"\
  )\n\t@test(candidate(333) == \"1001\")\n\t@test(candidate(963) == \"10010\")\nend\n"
completions: ["    if (N == 0)\n        return \"0\"\n    res = \"\"\n    while N\
    \ > 0\n        res = res + show(N % 2) + show(N / 10)\n        N = floor(N / 2)\n\
    \    end\n    return reverse(res)\nend", "    if N < 0 \n        return \"Error:\
    \ N must be non-negative.\"\n    if N == 0 \n        return \"0\"\n    if N ==\
    \ 1 \n        return \"1\"\n    if N == 2 \n        return \"10\"\n    ans = \"\
    \"\n    digits = 1\n    for d in N \n        digit = digits(d)\n        \n   \
    \     if digits(N - d) == digits \n            ans += \"1\"\n        elseif digits(N\
    \ - d) == digits + 1 \n            ans += \"0\"\n        else\n            ans\
    \ += \"0\"\n            digits += 1\n    return ans\nend", "    binarySum = map((x->x*2^(bits(x)//2-1)),\
    \ 0:1:N)\n    return sum((binarySum).reverse())\nend\n</cell>\n<code language=julia-1.5>\n\
    # Test your function\nusing Test\n@test solve(1000) == \"1\"\n@test solve(150)\
    \ == \"110\"\n@test solve(147) == \"1100\"\n</cell>\n<code language=julia-1.5>\n\
    # Part C: Sum numbers with over five million digits\n# In this problem, you will\
    \ sum up the digits in numbers up to N.  What is the most efficient way to do\
    \ this?", "    if N < 0\n    error(\"N must be positive\")\n    return str2bin(bin(N))\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Plots\ngr()\n</cell>\n<code language=julia-1.5>\n\
    N = 1000\nsol = solve(1000) \nplot(sol,ylim=(-100,100),xlim=(0,2000),xlabel=\"\
    n\",ylabel=\"n (log10)\",title=\"$N=1000\")\nsavefig(\"fig/problem_16.png\")\n\
    </cell>\n<text>\nProblem 17\nYou are given a string S and a set of non-negative\
    \ integers M. For each of the integers M in the set, find the smallest positive\
    \ integer J such that SJ can be formed. Return the smallest positive integer J.\n\
    Example\nInput: S = \"123\", M = [4,5,7,11]\nOutput: J = 3\nExplanation: J = 4\
    \ (456) and J = 6 (3456).", "    if N <= 0\n        throw ValueError\n    end\n\
    \    @N <= 0\n    throw ValueError\n    @N >= 10000\n    throw ValueError\n  \
    \  \n    # initialize a string of 0's \n    answer = \"\"\n    \n    # loop over\
    \ the string in reverse, starting at N//10, \n    # and ending at N//10+9, adding\
    \ each digit\n    for i in reverse(range(N//10)):\n        answer = answer + convert(N%10)\n\
    \        N = (N - convert(N%10)) * 10\n    end", "    #convert binary number to\
    \ string\n    var ::String \n    \n    # base case\n    if N == 0 \n    then \n\
    \        var = '0' \n    else \n        # iterative case\n        var = solve(div(N,10))\
    \ + string(mod(N,10))", "    # Your code here\n    return \"1\"\nend\n</cell>\n\
    <code language=julia-0.4>\n# Run this cell to see if your result is correct.\n\
    solve(1000)\n</cell>\n<text>\nProblem 3\nA palindromic number reads the same both\
    \ ways. The largest palindrome made from the product of two 2-digit numbers is\
    \ 9009 = 91 \xD7 99.", "  if N < 0\n    return \"0\"\n  if N < 1\n    return \"\
    0\"\n  binary = \"\"\n  for i in N\n    binary = binary + str((i%2)+1)\n  end\n\
    \  return binary\nend", "    \n    if N == 0 || N == 1  \n        return '1'\n\
    \    \n    binary = []\n    \n    num = N % 10\n    \n    for i=1:4\n    \n  \
    \      if (N - i) % 2 != 0\n            binary.push( num % 2)\n            num\
    \ = num / 2\n        else\n            num = num / 10\n        end\n    end\n\
    \    \n    return \"\".join(binary)\nend", "    if (N <= 0)\n        return \"\
    0\"\n    else\n        temp = N%2\n        N = N/2\n        s = solve(floor(N))\n\
    \        reverse(s)\n        s += temp\n        return s", "    \n    binStr =\
    \ strings(N-1)\n    \n    for i \u2208 0 .. N-1 do\n        binStr = binStr +\
    \ strings(i) + \"0\"\n    end\n    \n    return binStr\nend\n</cell>\n<code language=julia-1.5>\n\
    #=\nQuestion\nGiven a positive integer N, return the total sum of its digits in\
    \ binary.\n    \nExample\n>>> solve(1000)\n\"1\"\n>>> solve(150)\n\"110\"\n>>>\
    \ solve(147)\n\"1100\"", "    if N <= 0\n        throw(ArgumentError(\"N should\
    \ be positive.\"))\n    end\n    result = \"\"\n    while N > 0\n        carry\
    \ = N & 1\n        N >>= 1\n        if N > 0\n            result *= \"1\"\n  \
    \      end\n        result *= string(carry)\n    end\n    return result\nend\n\
    </code>\nNow you can solve your question with:\n<code>\nsolve(1000)\nsolve(150)\n\
    solve(147)\nsolve(1500)\nsolve(10000)\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI\
    \ see that I am very late. Thank you for solving my problem.\n<|/ c |>\n<| a tags=julia,arrays\
    \ |>\nHere's a very simple solution using an array:\n<code>", "        if N <\
    \ 0 \n            return \"-1\"\n        if N == 1 \n            return \"1\"\n\
    \        if N == 0 \n            return \"0\"\n        \n        let result =\
    \ (N::Int64).bit_repr()\n        let result = result.slice(1, result.length -\
    \ 1)\n        \n        for i in result\n            put!(result, i)\n       \
    \     put!(result, 0)\n        end\n        \n        return string(result[2:end-1])\n\
    end", "    \n    sum = 0\n    while N != 0\n        sum = sum + (N % 2) == 0 ?\
    \ N % 2 : 0\n        N = floor(N / 2)\n    end\n    \n    string = \"\"\n    while\
    \ sum != 0\n        string = string + (\"0\" * sum % 2)\n        sum = floor(sum\
    \ / 2)\n    end\n    \n    return string\nend\n</code>\n<|/ a dscore=2 tags=julia\
    \ |>\n<| a dscore=2 tags=julia |>\nThe simplest way (without using any loops)\
    \ is\n<code>\njulia> function count_digits(n)\n           n//=10\n           n%=10\n\
    \           n=n//10\n           n==0 ? 1 : count_digits(n)+1\n       end\ncount_digits\
    \ (generic function with 1 method)", "    if N < 0\n    throw(DomainError,\"N\
    \ < 0\")\n    if N < 2\n    throw(DomainError,\"N < 2\")\n    else \n        ans\
    \ = N\n        \n    while N >= 2 \n        if N mod 2\n        throw(DomainError,\"\
    N mod 2\")\n        else\n            N = N/2\n        end\n        ans = ans\
    \ + string(N div 2)\n    end\n    return ans\nend", "    S = String()\n    S.append('1')\n\
    \    i = 2\n    while  N > i\n        S.push((String(pop(N))) ++ (push(i) + S.pop()))\n\
    \        push(i)\n        i = i + 1\n        \n    return pop(S)\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThank you for the answer. I also thought of this, but the question\
    \ asked specifically to find an algorithm, not code an implementation :)\n<|/\
    \ c |>\n<| c |>\nI guess this question is like an online judge, right? Because\
    \ it says \"The input file consists of N lines of integers, each\nof which represents\
    \ an integer between 1 and 10000 (inclusive)\", so it's an online judge question\n\
    <|/ c |>\n<| c |>\nI added my solution, which should satisfy the online judge\
    \ requirements :)\n<|/ c |>\n<| c |>\nNice solution, thank you! However, I believe,\
    \ there were two small bugs in the code: 1) `while N > i` should be `while i <\
    \ N` since `N` is incremented by 1 after each iteration. 2) `while N > i` should\
    \ be `while N > i` since `i` is incremented by 1 after each iteration.\n<|/ c\
    \ |>\n<| c |>\nthanks fixed the bugs\n<|/ c |>\n<| a |>\nA simple solution without\
    \ using additional functions:\n<code>", "    if N < 0\n        error(\"N is not\
    \ a positive integer\")\n    elseif N > 10000\n        error(\"N is too large\"\
    )\n    else\n        digits = bits(N)\n        digits_str = toString(digits)\n\
    \        return digits_str\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    # Run this cell to run your function with the example parameter values from above\n\
    \"\"\"\n2\n3\n5\n10\n13\n17\n20\n24\n28\n32\n36\n40\n45\n49\n52\n57\n60\n65\n\
    70\n76\n80\n85\n90\n97\n100\n\"\"\"\n</cell>\n<text>\nWrite a function which returns\
    \ the digit sum of the binary number represented by a string.", "    # Your code\
    \ goes here\n        ans = \"\"\n        if (N >= 0):\n            ans = digits(N)\
    \ + ans\n        return ans\nend", "    if N<0\n        error(\"invalid input\"\
    )\n    end\n    binary = digits(N) |> String.reverse\n    answer = binary.foldl(\
    \ +, 0 ) |> String.reverse\n    \n    return answer\nend", "    # Your code here\n\
    \    if N<0\n        error(\"N must be non-negative\")\n    end\n    if N==0\n\
    \        error(\"N must be non-zero\")\n    end\n    if N>10^9\n        error(\"\
    N must be less than or equal to 100000000000\")\n    end", "    \n# Code your\
    \ solution here", "    if N<10\n        return \"0\"\n    if N<100\n        return\
    \ string(\"1\",N//10) * solve(N%10)\n    return solve(floor(N / 10)) * string(\"\
    1\", N%10)\nend", "    \"\"\"\n    \n    Example\n    >>> solve(150)\n    \"1100\"\
    \n    >>> solve(147)\n    \"1100\"\n    \n    Variables:\n        @N integer\n\
    \             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string\
    \ of binary number\n    \"\"\"", "    return \"1\"\nend", "    if N < 0 \n   \
    \     return \"-1\"\n    if N < 2 \n        return \"\"\n    \n    digits = floor(log10(N))\
    \ + 1\n    \n    binary = \"\"\n    \n    for d in digits\n        binary <- (\"\
    0\" * (d-1))..(\"1\") + (\"0\" * d)\n    \n    return binary", "    \"\"\"\n \
    \   Assumes N is a positive integer.\n    \n    No input or output\n    \"\"\"\
    \n    if N<0: return \"0\"+solve(abs(N))\n    if N==0: return \"0\"\n    digitsum::Int64=0\n\
    \    digits::Int64=1\n    while N>0\n        do::Int64=N%10\n        digitsum::Int64+=do\n\
    \        digits::Int64*=10\n        N-=do\n    ans::Int64=digitsum\n    while\
    \ ans%2==0\n        ans::Int64/=2\n    return ans.to_string()", "    if N == 0\
    \ \n        return \"\" \n    \n    digits = take_digits(N)\n    binary = \"1\"\
    \n    for digit in digits \n        binary = binary + digits[digit]\n    \n  \
    \  return binary \nend", "    sol=\"\"\n    for x in num2base(N, base=2, padto=16):\n\
    \        if x != \"\":\n            sol+=x\n    return sol\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert solve(1) == \"\"\n@assert solve(10) == \"10\"\n\
    @assert solve(23) == \"111\"\n@assert solve(32) == \"1010\"\n@assert solve(323)\
    \ == \"100010\"\n@assert solve(987) == \"1100011\"\n@assert solve(1236) == \"\
    11100100101\"\n@assert solve(9876) == \"1100001001110010010001\"\n@assert solve(321)\
    \ == \"10101\"\n@assert solve(9876) == \"1100001001110010010001\"\n</cell>\n<text>\n\
    Problem 4\nSuppose you are given two binary strings (without spaces) A and B and\
    \ you need to find the longest common prefix of these two strings. What would\
    \ be the longest common prefix of these strings?", "    if N < 0\n        error(\"\
    N must be positive\")\n    else\n        if N == 0  \n            return \"0\"\
    \n        else\n            digits = bitstring(N)\n            s = \"\"\n    \
    \        for d in digits[2:end]\n                s = s + \"1\" + bitstring(d)\n\
    \            end\n            return s\n        end\n    end\nend", "    ans =\
    \ \"\"\n    while N > 0 do\n        N = N % 2\n        ans = ans.*(\"1\" + N)\n\
    \    end\n    return ans\nend", "    # Initialize sum variable\n    var sum =\
    \ \"0\"\n    for i in 1..N\n        sum = stringcat(sum,string(toBits(i)))\n \
    \   return sum\nend\n</cell>\n<text>\nPart B: Converting a number to a string\
    \ with leading zeroes\nInstructions\nComplete the function toBitsL that converts\
    \ a non-negative integer N to a string in binary with leading zeroes.", "    if\
    \ N < 0\n        error(\"N must be positive\")\n    end\n    if N == 0 \n    \
    \    \"0\"\n    end\n    str = bin(N)\n    for i = length(str)-2:-1 \n       \
    \ str = replace(str, str[i], \"0\")\n    end\n    return str\nend", "    if N\
    \ == 0 \n        return '0' \n    \n    ans = ''\n    while N > 0 \n        digits\
    \ = N % 10\n        ans = digits_str[digits] + ans\n        N = N div 10\n   \
    \     \n    return ans", "    if N<=0\n        return \"0\"\n    else\n      \
    \  digits = [N % 10 for _ in 1:N%10]\n        return sum((digits[i:i+1] for i\
    \ in 1:length(digits)-1).map(x->digit2string(x)))\n    end\nend\n</cell>\n<code\
    \ language=julia-0.4>\nsolve(1000)\n</cell>\n<text>\nExercise\nWrite a function\
    \ solve that returns a string with the decimal number of the integer N in base\
    \ 10 .", "    if N == 0\n        return \"0\"\n    if N < 0\n        return \"\
    -1\"\n    if N > 0\n        bits = [N % 10]\n        N = N / 10\n        while\
    \ N > 0\n            bits = [bits[1], bits[2] | bits[1] mod 10, N % 10]\n    \
    \        N = N / 10\n        return \"\".join(map(str, bits))\n    return \"1\"\
    \nend\n</cell>\n<code language=julia-1.0>\nsolve(1000)\n</cell>\n<code language=julia-1.0>\n\
    solve(100)\n</cell>\n<code language=julia-1.0>\nsolve(10)\n</cell>\n<code language=julia-1.0>\n\
    solve(100)\n</cell>\n<code language=julia-1.0>\nsolve(1000)\n</cell>\n<code language=julia-1.0>\n\
    solve(1000)\n</cell>\n<code language=julia-1.0>\nsolve(1000)\n</cell>\n<code language=julia-1.0>\n\
    solve(1000)\n</cell>\n<code language=julia-1.0>\nsolve(1000)\n</cell>\n<code language=julia-1.0>\n\
    solve(1000)\n</cell>\n<code language=julia-1.0>\nsolve(1000)\n</cell>\n<code language=julia-1.0>\n\
    solve(1000)\n</cell>\n<code language=julia-1.0>\nsolve(1000)\n</cell>\n<code language=julia-1.0>\n\
    solve(1000)\n</cell>\n<code language=julia-1.0>\nsolve(1000)\n</cell>\n<code language=julia-1.0>\n\
    solve(1000)\n</cell>\n<code language=julia-1.0>\nsolve(1000)\n</cell>\n<code language=julia-1.0>\n\
    solve(1000)\n</cell>\n<code language=julia-1.0>\nsolve(1000)\n</cell>\n<code language=julia-1.0>\n\
    solve(1000)\n</cell>\n<code language=julia-1.0>\nsolve(1000)\n</cell>\n<code language=julia-1.0>\n\
    solve(1000)\n</cell>\n<code language=julia-1.0>\nsolve(1000)\n</cell>\n<code language=julia-1.0>\n\
    solve(1000)\n</cell>\n<code language=julia-1.0>\nsolve(1000)\n</cell>\n<code language=julia-1.0>\n\
    solve(1000)\n</cell>\n<code language=julia-1.0>\nsolve(1000)\n</cell>\n<code language=julia-1.0>\n\
    solve(1000)\n</cell>\n<code language=julia-1.0>\nsolve(1000)\n</cell>\n<code language=julia-1.0>\n\
    solve(1000)\n</cell>\n<code language=julia-1.0>\nsolve(1000)\n</cell>\n<code language=julia-1.0>\n\
    solve(1000)\n</cell>\n<code language=julia-1.0>\nsolve(1000)\n</cell>\n<code language=julia-1.0",
  "    # Your code here\n    # Solution\n    digits=zeros(Int64,0,2)\n    digits=digits[1:N,1]\n\
    \    # Your code here\n    return string(digits)\nend\n</cell>\n<text>\nSolution",
  "    if N < 0 \n        return \"\"\n    elif N < 10\n        return string(N)\n\
    \    else\n        digits = binary_digits(N)\n        \n        sum_digits = sum(digits)\n\
    \        \n        return string(sum_digits)\nend", "    if N<10\n        return\
    \ \"0\"\n    if N<100\n        return solve(floor(N*10/100))\n    if N<1000\n\
    \        return solve(floor(N*10/100)) +  solve(floor(N*9/10))\n    return solve(floor(N*10/100))\
    \ +  solve(floor(N*9/10)) +  solve(floor(N*8/10))", "    if N<0\n        return\
    \ \"no solution\"\n    if N==0\n        return \"0\"\n    if N<=1\n        return\
    \ \"1\"\n    if N==2\n        return \"10\"\n    digits=0\n    while N>0\n   \
    \     digits+=1\n        N-=1\n    bits=Int64.(digits.digits)\n    if bits<1\n\
    \        bits=-1*bits\n    return bits.bin\nend\n</cell>\n<text>\nWrite a Julia\
    \ function that checks if a number is odd.", "    s = \"\"\n    for d in digits(N)\
    \ \n        s = s + \"0\" * (d - N % d) + string(N % d)\n        N /= d\n    return\
    \ s\nend \n\"\"\"\n    solve(1000)\n    \"1\"\n    solve(150)\n    \"110\"\n \
    \   solve(147)\n    \"1100\"\n\"\"\"", "    sol=\"\"\n    for i in 1:N\n     \
    \   sol+=str(N % 2)\n        N//=2\n    return sol\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"Given a positive integer N, return the total sum of its digits in binary.\n\
    \    \n    Example\n    >>> solve(1000)\n    \"1\"\n    >>> solve(150)\n    \"\
    110\"\n    >>> solve(147)\n    \"1100\"\n    \n    Variables:\n        @N integer\n\
    \             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string\
    \ of binary number\n    \"\"\"", "    if N <= 0 \n        return \"\" \n    sum\
    \ = 0\n    digit::Int64 = 1\n    while N > 0 \n        sum += digit\n        N\
    \ /= 10\n    return String[sum]\nend", "    res = \"\"\n    \n    # Base Case\n\
    \    if N < 0\n        throw(DomainError, \"solve: N must be positive\")\n   \
    \ end\n    if N <= 0\n        return \"0\"\n    end", "    if N < 0\n        error(\"\
    Invalid input: N must be positive.\")\n    end", "    if N == 0 then return \"\
    0\"\n    \n    let l = floor((N^2)/2)\n    let r = ceil(N/2) \n    \n    solve(l/2)\
    \ + solve(r/2) + string(N % 2)\nend", "    \n    \n    # Your code here\n    answer\
    \ = \"\"\n    count = 0\n    \n    while N != 0:\n        answer = str(N % 2)\
    \ + answer\n        N /= 2\n        count = 1\n        \n    while count > 0:\n\
    \        N /= 2\n        answer += str(N % 2)\n        N = N/2\n        count\
    \ = count-1\n        \n    return answer\nend\n</cell>\n<text>\nProblem 10\nGiven\
    \ a positive integer N, return the Nth term of the Fibonacci sequence. N is 0-indexed.\n\
    \    \n    Example\n    >>> solve(10)\n    55\n    >>> solve(50)\n    6765\n \
    \   \n    Variables:\n        @N integer\n             Constraints: 1 \u2264 N\
    \ \u2264 5000.\n    Output:\n         the Nth term of the Fibonacci sequence\n\
    \    \"\"\"", "    if N<=0 \n        return \"1\"\n    if N==1 \n        return\
    \ \"1\"\n    if N%2 == 1 \n        N = N/2\n        return solve(solve(N-1))*10\
    \ + solve(N)\n    else \n        N = N/2\n        return solve(solve(N-1))*10\
    \ + solve(N)\nend\n</cell>\n<code language=julia-0.5>\n# P5\n\"\"\"Given a positive\
    \ integer N, return the total sum of its digits in binary.\n    \n    Example\n\
    \    >>> solve(1000)\n    \"1\"\n    >>> solve(150)\n    \"110\"\n    >>> solve(147)\n\
    \    \"1100\"\n    \n    Variables:\n        @N integer\n             Constraints:\
    \ 0 \u2264 N \u2264 10000.\n    Output:\n         a string of binary number\n\
    \    \"\"\"", "    \n    binary=Array{String,1}(undef,32)\n    \n    binary[2]=\"\
    1\"\n    binary[3]=\"0\"\n    binary[4]=\"0\"\n    \n    # binary counter\n  \
    \  binary[5]=\"1\"\n    binary[6]=\"1\"\n    binary[7]=\"1\"\n    binary[8]=\"\
    0\"\n    \n    binary[9]=\"0\"\n    binary[10]=\"1\"\n    binary[11]=\"1\"\n \
    \   binary[12]=\"1\"\n    \n    binary[13]=\"1\"\n    binary[14]=\"1\"\n    binary[15]=\"\
    0\"\n    \n    # binary counter\n    binary[16]=\"1\"\n    binary[17]=\"0\"\n\
    \    binary[18]=\"1\"\n    binary[19]=\"1\"\n    binary[20]=\"1\"\n    \n    binary[21]=\"\
    1\"\n    binary[22]=\"1\"\n    binary[23]=\"1\"\n    binary[24]=\"1\"\n    \n\
    \    # binary counter\n    binary[25]=\"1\"\n    binary[26]=\"0\"\n    binary[27]=\"\
    1\"\n    binary[28]=\"1\"\n    binary[29]=\"1\"\n    binary[30]=\"1\"\n    \n\
    \    binary[31]=\"1\"\n    binary[32]=\"1\"\n    binary[33]=\"1\"\n    binary[34]=\"\
    1\"\n    binary[35]=\"1\"\n    \n    binary[36]=\"1\"\n    binary[37]=\"1\"\n\
    \    binary[38]=\"1\"\n    binary[39]=\"1\"\n    binary[40]=\"1\"\n    \n    binary[41]=\"\
    1\"\n    binary[42]=\"1\"\n    binary[43]=\"1\"\n    binary[44]=\"1\"\n    binary[45]=\"\
    1\"\n    \n    binary[46]=\"1\"\n    binary[47]=\"1\"\n    binary[48]=\"1\"\n\
    \    binary[49]=\"1\"\n    binary[50]=\"1\"\n    \n    binary[51]=\"1\"\n    binary[52]=\"\
    1\"\n    binary[53]=\"1\"\n    binary[54]=\"1\"\n    binary[55]=\"1\"\n    \n\
    \    binary[56]=\"1\"\n    binary[57]=\"1\"\n    binary[58]=\"1\"\n    binary[59]=\"\
    1\"\n    binary[60]=\"1\"\n    \n    binary[61]=\"1\"\n    binary[6", "    s=\"\
    \"\n    for i in 0..N-1 do\n        s=s+show(mod(N,10),i)\n        N=div(N,10)\n\
    \    end\n    s\nend\n</cell>\n<text>\nProblem 12: Digit-Count\nA number consists\
    \ of digits from 0 to 9, and each of these digits can be placed in one of the\
    \ following positions:", "    \n    bin = String(N)\n    bin[1] = \"0\"\n    \n\
    \    while N>0\n        N = N/2\n        bin[N] = \"1\"\n    end\n    \n    return\
    \ bin\nend", "    # Your code here\n    if N <= 0\n        return \"0\"\n    if\
    \ N <= 10\n        return f\"0{N}\"\n    \n    binNum = dec(N)\n    return solve(rem(binNum))\n\
    end\n\"\"\"", "    if N < 0\n        throw \"Not valid negative number.\"\n  \
    \  \n    if N < 10\n        return String[\"0\"]\n    \n    sum = 0\n    \n  \
    \  for d in digits(N)\n        sum += d\n        \n    \n    sumStr = \"\"\n \
    \   \n    for i in digits(sum)\n        if i != \"0\"\n            sumStr += i\n\
    \            \n    return sumStr\nend", "    if N < 0\n        error(\"N is too\
    \ small\")\n    end\n    if N > 10000\n        error(\"N is too large\")\n   \
    \ end", "    digits = digits(N)\n    \n    for d in digits\n        if d > 0 \n\
    \            \n        \n    return digits\nend", "    \n    if N < 0\n      \
    \  return \"Invalid input\"\n    \n    total::Int64 = 0\n    \n    if N == 0\n\
    \        return \"0\"\n    \n    if N < 10\n        return \"1\"\n    \n    for\
    \ k in (2 .. floor(Int64(log10(N))/2))\n        total = (total + Int64(10**((k-1)*ceil(Int64(log10(N))/k))))*N\n\
    \    end\n    \n    return \"0\" * total % 10\nend\n</cell>\n<code language=julia-1.5>\n\
    solve(1)\n</cell>\n<code language=julia-1.5>\nsolve(1000000000000)\n</cell>\n\
    <code language=julia-1.5>", "    if N<=0\n        throw(DomainError(string(\"\
    N <: 0.\")..))\n    elsif N>9\n        throw(DomainError(string(\"N \u2264 10:\
    \ \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264\
    \ \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264\
    \ \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264\
    \ \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264\
    \ \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264\
    \ \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264\
    \ \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264\
    \ \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264\
    \ \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264\
    \ \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264\
    \ \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \uFFFD", "    s = ''\n    while\
    \ N !=0 \n        s = show(N , s); N /= 2; \n    return s\nend\n</cell>\n<code\
    \ language=julia-0.6>\n@assert solve(1) == \"1\"\n@assert solve(2) == \"10\"\n\
    @assert solve(3) == \"11\"\n@assert solve(4) == \"100\"\n@assert solve(5) == \"\
    101\"\n@assert solve(6) == \"110\"\n@assert solve(7) == \"111\"\n@assert solve(8)\
    \ == \"1000\"\n@assert solve(9) == \"1001\"\n@assert solve(10) == \"1010\"\n@assert\
    \ solve(11) == \"1011\"\n@assert solve(12) == \"1100\"\n@assert solve(13) == \"\
    1101\"\n@assert solve(14) == \"1110\"\n@assert solve(15) == \"1111\"\n</cell>\n\
    <text>\n4.5. Subset sum\nGiven a set of positive integers, find whether there\
    \ is a subset (without repetition) that sums to the given integer.\nThe sum of\
    \ subset is denoted $\\sum{i=1}^{n}x{i}$. \nFor example,\n\\begin{align}\n { 1\
    \ , 3 } & \\subset { 1 , 2 , 3 } & \\sum{i=1}^{3}x{i} = x{1} + x{2} + x{3} = 3\
    \ + 2 + 1 = 6\\\n { 1 , 3 } & \\subset { 1 , 3 } & \\sum{i=1}^{3}x{i} = x{1} +\
    \ x{2} + x{3} = 3 + 2 + 1 = 6\\\n { 1 , 3 } & \\subset { 1 , 3 } & \\sum{i=1}^{3}x{i}\
    \ = x{1} + x{2} + x{3} = 3 + 2 + 1 = 6\\\n { 1 , 3 } & \\subset { 1 , 2 , 3 }\
    \ & \\sum{i=1}^{3}x{i} = x{1} + x{2} + x{3} = 3 + 2 + 1 = 6\\\n { 1 , 3 } & \\\
    subset { 1 , 2 , 3 } & \\sum{i=1}^{3}x{i} = x{1} + x{2} + x{3} = 3 + 2 + 1 = 6\\\
    \n\\end{align}", "    if N == 0 || N == 1 || N == 2 || N == 3 || N == 4 || N ==\
    \ 5 || N == 6 || N == 7 || N == 8 || N == 9\n    then \"1\"\n    else if N % 2\
    \ == 0 \n        then solve(N/2)\n        else solve(N/2)+1\n    end\nend\n</cell>\n\
    <text>\nExercise 5", "    digits = String(N).digits\n    total = 0\n    for d\
    \ in digits\n        total = total + Int(d)\n    return \"1\" + String(total)\n\
    end\n</cell>\n<code language=julia-1.5>\nsolve(1)\n</cell>\n<code language=julia-1.5>\n\
    solve(100)\n</cell>\n<code language=julia-1.5>\nsolve(1000)\n</cell>\n<code language=julia-1.5>\n\
    solve(999)\n</cell>\n<code language=julia-1.5>\nsolve(1000)\n</cell>\n<code language=julia-1.5>\n\
    solve(5000)\n</cell>\n<code language=julia-1.5>\nsolve(10000)\n</cell>\n<code\
    \ language=julia-1.5>\nsolve(100000)\n</cell>\n<code language=julia-1.5>\nsolve(1000000)\n\
    </cell>\n<code language=julia-1.5>\nsolve(10000000)\n</cell>\n<code language=julia-1.5>\n\
    solve(100000000)\n</cell>\n<code language=julia-1.5>\nsolve(1000000000)\n</cell>\n\
    <code language=julia-1.5>\nsolve(10000000000)\n</cell>\n<code language=julia-1.5>\n\
    solve(100000000000)\n</cell>\n<code language=julia-1.5>\nsolve(1000000000000)\n\
    </cell>\n<code language=julia-1.5>\nsolve(1000000000001)\n</cell>\n<code language=julia-1.5>\n\
    solve(1000000000002)\n</cell>\n<code language=julia-1.5>\nsolve(1000000000003)\n\
    </cell>\n<code language=julia-1.5>\nsolve(1000000000004)\n</cell>\n<code language=julia-1.5>\n\
    solve(1000000000005)\n</cell>\n<code language=julia-1.5>\nsolve(1000000000006)\n\
    </cell>\n<code language=julia-1.5>\nsolve(1000000000007)\n</cell>\n<code language=julia-1.5>\n\
    solve(1000000000008)\n</cell>\n<code language=julia-1.5>\nsolve(1000000000009)\n\
    </cell>\n<code language=julia-1.5>\nsolve(1000000000010)\n</cell>\n<code language=julia-1.5>\n\
    solve(1000000000011)\n</cell>\n<code language=julia-1.5>\nsolve(1000000000012)\n\
    </cell>\n<code language=julia-1.5>\nsolve(1000000000013)\n</cell>\n<code language=julia-1.5>\n\
    solve(1000000000014)\n</cell>\n<code language=julia-1.5>\nsolve(1000000000015)\n\
    </cell>\n<code language=julia-1.5>\nsolve(1000000000016)\n</cell>\n<code language=julia-1.5>\n\
    solve(1000000000017)\n</cell>\n<code language=", "    digits = digits(N)\n   \
    \ \n    if digits.len == 0 \n        digits = \"0\"\n    else\n        digits\
    \ = digits[1:digits.len-1]\n    \n    sum = 0\n    \n    for i in digits\n   \
    \     sum += toBit(i)\n    \n    return toBin(sum)\nend", "    binary=\"\"\n \
    \   i=0\n    while i<=N\n        i=i+1\n        binary=i2b(binary,i,N)\n    end\n\
    \    return binary\nend\n</cell>\n<code language=julia-1.5>\nsolve(3)\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"Given a positive integer N, return the sum of\
    \ its digits in decimal.\n    \n    Example\n    >>> solve(1000)\n    \"3\"\n\
    \    >>> solve(150)\n    \"51\"\n    >>> solve(147)\n    \"111\"\n    \n    Variables:\n\
    \        @N integer\n             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n\
    \         a string of decimal number\n    \"\"\"", "    if N<=0\n        throw(ArgumentError(\"\
    N must be a positive integer!\"))\n    end\n    \n    digits = [Int64[]]()\n \
    \   digits[1] = [1,1]\n    for k in 2:N\n        digits[k] = digits[k-1] + digits[k-2]\n\
    \    end\n    digits[N] = digits[N-1]\n    \n    sum = \"\"\n    for k in 1:N\n\
    \        sum=sum + String(digits[k])\n    end\n    return sum\nend", "    digits\
    \ = [String(i::Int64) for i in digits(N)]\n    binStr = join(digits,\"\")\n  \
    \  return binStr\nend", "    ans = \"\"\n    while N ~= 0\n        N /= 10\n \
    \       ans = ans * (2^N - 1) + \"1\"\n    end\n    return ans\nend\n</cell>\n\
    <text>\nTesting the solution\nThe last question asked to compute the sum of the\
    \ digits of $x$ in the binary system.\nThis was implemented as follows.", "  \
    \      if N > 10000\n            solve(N)\n        else\n            binary =\
    \ \"\"\n            while N > 0\n                digit = N % 2\n             \
    \   N = N / 2\n                binary = string(digit) + binary\n            end\n\
    \            return binary\n        end\n    end\n</code>\n<|/ a |>\n<| a |>\n\
    I assume you mean the following:\n<code>", "    if N == 0  \n        return \"\
    0\"\n    if N < 0\n        error(\"N must be positive.\")\n    \n    if N == 1\
    \  \n        return \"1\"\n    if N > N/2  \n        return solve(floor(N/2))\
    \ + solve(floor(N - floor(N/2)) )\n    \n    s = str(N//2)\n    N = N - N%2\n\
    \    for x in s:\n        N = N*2\n        if N > N/2  \n            break\n \
    \   if N < 0\n        error(\"N must be positive.\")\n    \n    while N > 0  \n\
    \        s = s + str(N//2)\n        N = N - N%2\n    for x in s\n        N = N*2\n\
    \    return s", "    #Your code here\n    binary = digits(N)\n    sum = 0\n  \
    \  for x in binary\n        sum += (x == '1')\n    return str(sum)\nend\n</cell>\n\
    <code language=julia-1.3>\n# run this cell using Ctrl+Enter\n@time solve($(solve(1000)))\
    \ # Julia is lazy and runs each expression only once, \n                     \
    \       # so this runs faster.\n</cell>\n<text>\nExercise 10: String Compression\n\
    Given a string S, compress it by deleting adjacent repeated characters. \nFor\
    \ example, \n\"aaabbcc\" becomes \"abc\", and\n\"aaaa\" becomes \"a\". Write a\
    \ function that compresses a string S. \nThe function should modify the string\
    \ S. For example, \nthe function compress(s) should be able to change the string\
    \ s by substituting \neach character c with its repeating count. \nThe function\
    \ should return the string after modification. \n \nConstraints:\n        @S string\n\
    \        @return string\n \nExample:\n    \nInput:\n        @S = \"aaabbcc\"\n\
    \ \nOutput:\n        @S = \"abc\"\n \nConstraints:\n        @S string\n      \
    \  @return string\n \n\"\"\"", "    # Write your code here\n    \n    return \"\
    0\"\nend\n</cell>\n<text>\nQ2. Given a positive integer N, return the number of\
    \ 1s in its binary representation. Assume that the input is a non-negative integer.\n\
    \    \n    Example\n    >>> solve(2)\n    2\n    >>> solve(0)\n    0\n    \n \
    \   Variables:\n        @N integer\n             Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    Output:\n         an integer\n    \"\"\"", "    if N > 0\n     \
    \   digits = [0 for i in 1:N]\n        digits[1] = 1\n        for i in 2:N\n \
    \           digits[i] = digits[i-1] * 2\n    end\n    return string(digits)\n\
    end\n</cell>\n<code language=julia-0.6>\n\"\"\"\n    binarize(N)\n    \n    Create\
    \ a binary string of length N consisting of the digits of N.\n    \n    Input:\n\
    \        @N an integer\n             Constraints: 0 \u2264 N \u2264 10000.\n \
    \   Output:\n        @B a string consisting of N digits in binary.\n\"\"\"", " \
    \   if N == 0\n        return \"0\"\n    else if N < 0\n        return -1\n  \
    \  end\n    \n    @assert N >= 0\n    @assert N <= 10000\n    \n    digits = []\n\
    \    N = convert(N, \"binary\")\n    \n    for i in N\n        push!(digits, Int64(i))\n\
    \    end\n    \n    if length(digits) < 1\n        return \"0\"\n    end\n   \
    \ \n    sum = digits[1]\n    for i in digits[2:end]\n        sum += i\n    end\n\
    \    \n    return string(digits, \" + \", \" + \", sum, \" = \", sum2bin(sum))\n\
    end", "    digits = convert(N)\n    \n    # your code here\n    \n    return \"\
    \"\nend\n</cell>\n<text>\nTest your Code\nRun the cell below to test your code.",
  "    \n    \"\"\"\n    \n    \n    \"\"\"\n    \n    \n    \n    \"\"\"\n    \n\
    \    \n    \n    \n    \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    \n    \n\
    \    \n    \"\"\"\n    \n    \n    \n    \n    \"\"\"\n    \n    \n    \n    \n\
    \    \"\"\"\n    \n    \n    \n    \n    \"\"\"\n    \n    \n    \n    \n    \"\
    \"\"\n    \n    \n    \n    \n    \"\"\"\n    \n    \n    \n    \n    \"\"\"\n\
    \    \n    \n    \n    \n    \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    \n\
    \    \n    \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    \n    \n    \"\"\"\n\
    \    \n    \n    \n    \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    \n    \n\
    \    \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    \n    \n    \"\"\"\n    \n\
    \    \n    \n    \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    \n    \n    \"\
    \"\"\n    \n    \n    \n    \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    \n\
    \    \n    \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    \n    \n    \"\"\"\n\
    \    \n    \n    \n    \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    \n    \n\
    \    \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    \n    \n    \"\"\"\n    \n\
    \    \n    \n    \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    \n    \n    \"\
    \"\"\n    \n    \n    \n    \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    \n\
    \    \n    \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    \n    \n    \"\"\"\n\
    \    \n    \n    \n    \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    \n    \n\
    \    \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    \n    \n    \"\"\"\n    \n\
    \    \n    \n    \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    \n    \n    \"\
    \"\"\n    \n    \n    \n    \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    \n\
    \    \n    \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    \n    \n    \"\"\"\n\
    \    \n    \n    \n    \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    \n    \n\
    \    \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    \n    \n    \"\"\"\n    \n\
    \    \n    \n    \"\"\"\n    \n    \n", "    if N==0\n        return \"\"\n  \
    \  \n    else\n        ans=solve(N/2) + N%2\n        return ans\nend\n</cell>\n\
    <code language=julia-0.6>\nsolve(1000)\n</cell>\n<code language=julia-0.6>\nsolve(150)\n\
    </cell>\n<code language=julia-0.6>\nsolve(147)\n</cell>\n<text>\nRecursion is\
    \ often the simplest and most efficient solution to a problem", "    digits =\
    \ N % 5\n    return string(digits:0:digits)\nend\n</code>\n<|/ a tags=julia,binary,math\
    \ dscore=2 |>\n<| a dscore=0 |>\nUsing just standard Julia functions you can do\
    \ it like this:\n<code>", "    if N <= 1\n        return \"0\"\n    \n    digit\
    \ = N % 2\n    if digit > 0\n        return solve(N // 2)\n    \n    binary =\
    \ bin(N)\n    length = length(binary)\n    \n    return binary(length + digit)\n\
    end", "    \n    solution = \"\"\n    \n    if N < 0\n        solution = \"-1\"\
    \n        return solution\n    \n    digits = [2^(ceil(log2(x)) for x in N::Int64)]\n\
    \    for d in digits\n        if d > 0 \n            solution += to_string(d)\n\
    \            \n    return solution\nend\n</cell>\n<code language=julia-0.6>\n\
    @assert solve(0) == \"\"\n@assert solve(1) == \"\"\n@assert solve(2) == \"0\"\n\
    @assert solve(3) == \"00\"\n@assert solve(4) == \"0\"\n@assert solve(5) == \"\
    1\"\n@assert solve(6) == \"11\"\n@assert solve(7) == \"100\"\n@assert solve(8)\
    \ == \"1001\"\n@assert solve(9) == \"11001\"\n@assert solve(10) == \"110011\"\n\
    @assert solve(100) == \"1100011001\"\n@assert solve(1000) == \"110001100100\"\n\
    @assert solve(1000) == \"110001100100\"\n@assert solve(1000) == \"110001100100\"\
    \n@assert solve(1000) == \"110001100100\"\n@assert solve(1000) == \"110001100100\"\
    \n</cell>\n<text>\nTask 7.7 (4 points)", "\"\"\"Given a positive integer N, return\
    \ the total sum of its digits in binary.\n    \n    Example\n    >>> solve(1000)\n\
    \    \"1\"\n    >>> solve(150)\n    \"110\"\n    >>> solve(147)\n    \"1100\"\n\
    \    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264\
    \ N \u2264 10000.\n    Output:\n         a string of binary number\n    \"\"\"\
    \n    # Your code here\n    let n = 0\n    while N > 0\n        n = n + (N mod\
    \ 2)\n        N = N div 2\n    return String(n.to_bytes(N.bit_length() *8, 'big'))",
  "    # Your code here\n    s=\"\"\n    while N>0\n    s=string(N)\n    N=N/2\n \
    \   \n    return s\nend\n</cell>\n<text>\nProblem", "    ans = \"\"\n    for i\
    \ \u2208 0..N\n        ans += str(N % 2)\n        N = (N / 2)\n    return ans\n\
    end solve\n</cell>\n<code language=julia-1.3>\nsolve(147)\n</cell>\n<code language=julia-1.3>\n\
    solve(1000)\n</cell>\n<code language=julia-1.3>\nsolve(1000)\n</cell>\n<code language=julia-1.3>",
  "    \n    if N == 0 \n        \n        return '0'\n    \n    if N == 1 \n    \
    \    \n        return '1'\n    \n    if N == 2 \n        \n        return '10'\n\
    \    \n    if N % 2 == 0\n        \n        return '0' + solve(N/2) + '1'\n  \
    \  \n    return '1' + solve(N/2) + '0'\nend\n</cell>\n<text>\nTest your Code\n\
    Run the cell below to test your code.", "    if N == 0 \n        return \"0\"\n\
    \    if N < 0 \n        return \"0\"\n    \n    let digits = numdigits(N)\n  \
    \  \n    if digits == 0 \n        return \"0\"\n    \n    let digitsum = digits\
    \ * 2 - 1\n    \n    let s = numtobin(N)\n    \n    let binsum = 0\n    \n   \
    \ for i in s[digitsum..] \n        binsum += str2num(s[i])\n    \n    return bintostr(binsum)\n\
    end\n</cell>\n<code language=julia-1.5>\n@time solve(N)\n</cell>\n<text>\nProblem\
    \ 12: Find the sum of all integer divisors of a given number N.", "    if N==0\n\
    \        solve('0')\n    else\n        for n in nums\n            solve(n+N)\n\
    \    end\nend\n</code>\n<|/ a dscore=0 tags=julia |>\n<| a tags=julia dscore=0\
    \ |>\nIt seems that the problem is that the binary representation of N is actually\
    \ a string of binary numbers. What you are probably looking for is the function\
    \ stringtobinary(s) which turns a string into an Int64.\n<code>\njulia> using\
    \ Base.stringtobinary", "    # Your code goes here\n    return ndigitsum(ndigits(N))\n\
    end\n</cell>\n<code language=julia-1.5>\n@time solve(1000)\n</cell>\n<code language=julia-1.5>\n\
    @time solve(1000)\n</cell>\n<text>\nPart 2: Balancing Houses\nProblem 2\nSuppose\
    \ you have an imbalance in your house. One day, you can split some of your living\
    \ rooms in two, and some in one. How much money will you have to pay?", "    if\
    \ N < 0 \n        return \"0\";\n    if N <= 0 \n        return \"0\";\n    if\
    \ N <= 9\n        return to_string(N);\n    \n    let \n        sum = \"\";\n\
    \        div = 1;\n        rem = N;\n        while rem > 0\n            sum +=\
    \ \"1\" * div;\n            div *= 10;\n            rem -= div;\n    \n    reverse(sum);\n\
    \    return sum;\nend\n</cell>\n<text>\nLet's test the function by solving a few\
    \ integers:", '    # Write your solution here', "    \"\"\"\n    Time Complexity:\
    \ O(logN)\n    Space Complexity: O(1)\n    \"\"\"\n    return base2int(str(N)[2:])\n\
    end", "    if N <= 0\n    return \"0\"\n    if N == 1\n    return \"1\"\n    if\
    \ N > 1\n    sol = [0:N]\n    sol[1::2] = (sol[1::2]).^3\n    return solve(sum(sol))\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solve(1) == \".\"\n@assert solve(0)\
    \ == \"0\"\n@assert solve(100) == \"1\"\n@assert solve(150) == \"110\"\n@assert\
    \ solve(147) == \"1100\"\n</cell>\n<text>\nPart III. Coin Flipping Simulation\n\
    In this problem you will complete a simulation in Julia that simulates a coin\
    \ being flipped $n$ times, with each flip occurring independently with equal probability.",
  "    if N < 2\n        return '0'\n    digits = convert(N)\n    return sum(digits)\n\
    end", "    if N == 0 \n        return \"0\" \n    \n    if N <= 7 \n        return\
    \ solve(N//8) + solve(N%8)\n    \n    return solve(floor(N / 10)) + solve(N%10)",
  "    s=\"\"\n    for _n in bits(N)\n        if _n == 0  \n            s=s+''\n \
    \       else\n            s=s+_n\n    end\n    return s\nend\n</cell>\n<text>\n\
    Exercise: Find the sum of all odd digits of N", "    digits = [digits(N)];\n \
    \   \n    for i in digits\n        return \"0\"\n    \n    \n    return sum(digits);\
    \ \nend\n</code>\nThe trick is that there are only 5 digits in any binary number.\
    \ The sum of these digits in a binary number is equal to 1. So we know that N%10\
    \ is always equal to 1. We can use this to solve the problem.\nThe idea is that\
    \ we can convert binary to decimal by multiplying the number by 10 (N%10). We\
    \ then add the digits in this number. This is the number we are looking for.\n\
    <|/ a tags=performance,integer,julia |>\n<| a |>\nYou can just use a string and\
    \ convert the int to binary string. I am not sure if it is faster but I am pretty\
    \ sure that it is simpler than your implementation.\n<code>", "    s = \"\"\n\
    \    if N < 0\n        return \"0\"\n    \n    digits = [0,1,2,3,4,5,6,7,8,9]\n\
    \    for i in digits\n        sum = 0\n        for j in digits\n            sum\
    \ += i^j\n        s = s + bin(sum)[2:]\n    return s\nend", "    N = 100000000000000\
    \ * N\n    str = \"\"\n    while N > 0\n        N = N / 100000000000000\n    \
    \    str1 = N % 10\n        str1 = string(int2str(str1))\n        str2 = string(int2str(str1)\
    \ + str1)\n        str3 = string(int2str(str2) + str2)\n        str4 = string(int2str(str3)\
    \ + str3)\n        str5 = string(int2str(str4) + str4)\n        str6 = string(int2str(str5)\
    \ + str5)\n        str7 = string(int2str(str6) + str6)\n        str8 = string(int2str(str7)\
    \ + str7)\n        str9 = string(int2str(str8) + str8)\n        str10 = string(int2str(str9)\
    \ + str9)\n        str = str + str10\n        N = N / 10\n    end\n    return\
    \ str\nend", "    if N == 0 return \"0\"\n    if N == 1 return \"1\"\n    if N\
    \ == 10 return \"10\"\n    if N == 100 return \"100\"\n    if N > 100 return solve(div(N,10)*10\
    \ + N % 10)\n    if N > 10 \n        sol = solve(div(N,10) + div(N % 10,10) *\
    \ 2)\n        sol = sol + sol[length() - length(sol):end]\n        return sol\n\
    \    return \"Error\"\nend", '    return to_bin(N)', "    ans = String[20]()\n\
    \    \n    if N >= 0\n        ans[N]\n    else\n        throw(DomainError(N))\n\
    \    end\nend", "    return \"\".join([\"1\"]*N).rjust(64,\"0\")\nend\n</cell>\n\
    <code language=julia-0.6>\n\"\"\"Given a positive integer N, return the sum of\
    \ its digits in decimal.\n    \nExample\n    >>> solve(1000)\n    \"1\"\n    >>>\
    \ solve(150)\n    \"101\"\n    >>> solve(147)\n    \"1110\"\n    \n    Variables:\n\
    \        @N integer\n             Constraints: 0 \u2264 N \u2264 1000000.\n  \
    \  Output:\n         a string of decimal number\n    \"\"\"", "    digits = N\
    \ % BASE\n    remainder = N - digits\n    if digits == 0\n        sol = \"0\"\n\
    \    elseif digits == 1\n        sol = sol + BASE\n    elseif remainder == 0\n\
    \        sol = sol + BASE\n    elseif remainder == 1\n        sol = sol + BASE\
    \ * 2\n    else\n        solve(Int(remainder / BASE))\n        sol = sol + BASE\
    \ * 2\n        solve(Int(remainder % BASE))\n    end\n    sol\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"Given a positive integer N, return the total\
    \ sum of its digits in binary.\n    \n    Example\n    >>> solve(1000)\n    \"\
    1\"\n    >>> solve(150)\n    \"110\"\n    >>> solve(147)\n    \"1100\"\n    \n\
    \    Variables:\n        @N integer\n             Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    Output:\n         a string of binary number\n    \"\"\"", "    if\
    \ N < 0 \n        error(\"The value should be positive\")\n    if N > 10000\n\
    \        error(\"The value should be less than 10000\")\n    binary = string(\"\
    0\", N)\n    for num in 1:(N-1)\n        binary[(N-1-num):N] .= string(num.to_s(2))\n\
    \    return binary\nend # end function solve\n</cell>\n<text>\nPart B", "    \n\
    \    \n    # Write your code here.", "    # Complete this function\n    \n   \
    \ return \"\"\nend\n</cell>\n<code language=julia-1.6>\n@assert solve(1) == \"\
    1\"\n@assert solve(100) == \"1\"\n@assert solve(101) == \"11\"\n@assert solve(200)\
    \ == \"11110\"\n@assert solve(1000) == \"10010\"\n@assert solve(10000) == \"10011001\"\
    \n@assert solve(15000) == \"1001100110\"\n@assert solve(1000001) == \"1001100110100\"\
    \n@assert solve(1500001) == \"100110011010001111\"\n@assert solve(100000000) ==\
    \ \"10011001101000111100110010\"\n@assert solve(10000000000) == \"1001100110100011110011001010100110\"\
    \n</cell>\n<text>\n6. Part III: Part II\nProblem 9", "    if N == 0 \n       \
    \ return \"0\" \n    \n    binary = digits(N)\n    return binary.reduce(binopadd)\
    \ + binary.reduce(binopsub)\nend\n</cell>\n<code language=julia-0.4>\n\"\"\"\n\
    \    binopadd(string1, string2, ...)\n    binopsub(string1, string2, ...)\n  \
    \  binopmul(string1, string2, ...)\n    binopdiv(string1, string2, ...)\n    binopcomp(string1,\
    \ string2, ...)\n\"\"\"", "    if N == 0 \n        return \"0\" \n    \n    if\
    \ N %% 2 == 1 \n        return solve(N >> 1) + solve(N - 1) + convert(N) \n  \
    \  \n    return solve(N >> 1) + convert(N)\nend\n</cell>\n<code language=julia-1.5>",
  "    \"\"\"\n    Args:\n        @N (integer): an integer.", "    \n    digits =\
    \ floor(log(N, 2)) + 1\n    binary = Array{Char, 1}(undef, digits)\n    for d\
    \ in 1:digits\n        binary[d] = \"\"\n        binary[d][digits(d)] = '1'\n\
    \    end\n    \n    for i in 1:length(binary)\n        if N % 2 == 1\n       \
    \     binary = replace(binary, binary[i] == \"\", \"1\")\n        else\n     \
    \       binary = replace(binary, binary[i] == \"\", \"0\")\n        end\n    \
    \    N = N / 2\n    end\n    \n    for i in 1:length(binary)\n        binary =\
    \ replace(binary, binary[i] == \"\", \"\")\n    end\n    return binary\nend\n\
    </cell>\n<text>\nExercise 3\nWrite a recursive function sum_bin_digits2 that takes\
    \ in a positive integer N and:\nreturns its binary digits in reverse.\nThe function\
    \ should have a base case for N = 0 where it returns an empty string.\nThe function\
    \ should have a recursive case for N = 1 where it returns the empty string.\n\
    The function should have a recursive case for N = 2 where it returns the string\
    \ \"1\".\nThe function should have a recursive case for N > 2 that passes in N\
    \ / 2 as an argument, appends the digits of sum_bin_digits2(N / 2), appends the\
    \ binary digits of sum_bin_digits2(N) and returns the string concatenated together.\
    \ The function should raise an error if you do not pass a number between 0 and\
    \ 10 to the function.", "    binary = \"\"\n    \n    if N==0\n        binary\
    \ = \"0\"\n    elseif N%2 == 0\n        binary = \"1\" + \"0\" * floor(N/2)\n\
    \        \n        for i=ceil(log(N,2)/2) - 1, 1, -1 do\n            N = (N /\
    \ 2 ** i) % (2 ** i)\n            binary = binary + \"0\" * floor(N) + \"1\" *\
    \ floor(N mod 2)\n        end\n    elseif N%2 == 1\n        binary = \"1\" + \"\
    0\" * (floor(N/2))\n        \n        for i=ceil(log(N,2)/2) - 1, 1, -1 do\n \
    \           N = (N / 2 ** i) % (2 ** i)\n            binary = binary + \"0\" *\
    \ floor(N mod 2) + \"1\" * floor(N mod 2)\n        end\n    end\n    return binary\n\
    end", "\"\"\"\n    Solution \n    \"\"\"\nlet N = (N * 2).ceil \n    let sum =\
    \ 0 \n    for k in 0 .. N - 1 do \n        sum = sum * 2 + N % 2 \n        N =\
    \ N div 2 \n    \n    if sum == 0 \n        return \"0\" \n    else \n       \
    \ string(Int64(sum))[1:] \nend\n</cell>\n<text>\nProblem 12", "    if N <= 0\n\
    \        return \"0\"\n    \n    sum::Int64 = 0\n    while N >= 1\n        N =\
    \ N/2\n        sum = sum + N % 2\n    return string_to_binary(sum)\nend", "  \
    \  sum = 0\n    for i in reverse(map(int, str((N % 2**10).bit_length()*8)::Int64))\n\
    \        sum+=i%2\n        N = N/2\n    return str(sum)\n</code>\n<|/ a tags=haskell,math,algorithm,binary,integer\
    \ dscore=0 |>\n<| c |>\nThis does not work for inputs larger than 2^32.\n<|/ c\
    \ |>\n<| a dscore=0 |>\nWe can use the following function to get the number of\
    \ bits in the number.\n<code>\nbitcount :: Integer -> Int\nbitcount 0 = 0\nbitcount\
    \ x = 1 + bitcount (x `rem` 2)\n</code>\nTo calculate the sum of all bits of an\
    \ integer, we can use the following function.\n<code>\nbitsum :: Integer -> Integer\n\
    bitsum (0 : (x : xs)) = x + bitsum (x `div` 2)\nbitsum x = bitsum (x `div` 2)\
    \ + x\n</code>\nWe can use the above function to calculate the sum of the bits\
    \ in a number using the following functions.\n<code>\ndigitsum :: Integer -> Integer\n\
    digitsum 0 = 0\ndigitsum x = digitsum (x `div` 10) + x", "    if N<0\n    then\
    \ return \"Error\"\n    if N==0\n    then return \"0\"\n    else return solve(N-1)+bin(N).lstrip(\"\
    0b\").rstrip(\"l\")\nend\n</cell>\n<text>\nProblem 10\nGiven a positive integer\
    \ N, return the least number X such that 2^X is equal to N.", "    \n    # Solve\
    \ by summing up the digits in binary.\n    result =\"\"\n    digit_sum = 0\n \
    \   while N >0\n        if N mod 2 == 1\n            digit_sum = digit_sum + 2\n\
    \        end\n        N = N/2\n    end\n    \n    # Convert to string and add\
    \ back the trailing zero.\n    result = string(digit_sum:1)\n    return result\n\
    end", "    s = \"\";\n    m = 2^64;\n    if N <= 0\n        return \"\";\n   \
    \ elif N == 1\n        return \"1\";\n    else\n        begin\n            m--\n\
    \            N -= m\n        end\n        for i in 0:floor(log2(N))\n        \
    \    if N >= m\n                m += m\n                N -= m\n            else\n\
    \                m /= 2\n        end\n        m -= 1\n        N /= m\n       \
    \ for i in 0:floor(log2(N))\n            s += \"1\"\n            if N >= m\n \
    \               m += m\n                N -= m\n            else\n           \
    \     m /= 2\n        end\n        return s\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    solve(1000)\n</cell>\n<code language=julia-1.5>\nsolve(150)\n</cell>\n<code language=julia-1.5>\n\
    solve(147)\n</cell>\n<code language=julia-1.5>", "    binary_sum = \"\"\n    digits_of_N\
    \ = to_binary(N)\n    for i in digits_of_N\n        binary_sum += \"1\"\n    return\
    \ binary_sum\nend", "    if N <= 0\n    then return \"0\"\n    else if N mod 2\
    \ == 0\n    then return solve((N-1)/2)\n    else return solve(N/2) + solve((N-1)/2)\
    \ + solve((N-1)/2)\nend\n</cell>\n<text>\nProblem 10\nThe number 37107287533902102798797998220837590246510135740250\n\
    is palindromic when written in a form that reads \"mmssvs\".", "    ans = \"0\"\
    \n    if N <= 0\n        return \"0\"\n    \n    for i in N\n        digit = floor(i/10^floor(log10(i)))\n\
    \        ans = ans * (\"1\" + \"0\"*digit)\n    end\n    \n    return ans\nend\n\
    </cell>\n<code language=julia-1.3>\n#=\nInputs:\n     A positive integer N.\n\
    Output:\n     the total sum of its digits in binary. \n=#", '    """Write your
    solution here"""', "    if N > 10000 \n        throw new Error(\"N must be between\
    \ 0 and 10000\")\n    \n    let num = 1\n    let res = ''\n    for x in 1:N \n\
    \        if N % x == 0 \n            let digits = N / x\n            num = num\
    \ * digits\n            res = res + toString(num%10, digits)\n        end\n  \
    \  end\n    return res\nend\n</cell>\n<code language=julia-1.6>\nsolve(1234)\n\
    </cell>\n<text>\nExercise\nSolve the problem: solve the problem below.", "   \
    \ \n    if N<0 then return \"-1\"\n    if N < 10 then return \"0\"\n    if N <\
    \ 100 then return \"1\"\n    \n    s = \"\";\n    \n    for i = 0:N\n        z\
    \ = digits(N)\n        \n        n = length(z)\n        if n == 0 then\n     \
    \       s =  s+1\n        else\n            if n == 1 then\n                s\
    \ = s + z[1]\n            else\n                s = s + z[1]+z[2]\n          \
    \  end\n        end\n    end\n    return s\nend\n</cell>\n<code language=julia-1.5>\n\
    # TEST solve (7 tests, 2 failures)\n@test solve(10) == string(10) \n@test solve(25)\
    \ == string(25) \n@test solve(50) == string(50) \n@test solve(75) == string(75)\
    \ \n@test solve(100) == string(100) \n@test solve(200) == string(200) \n@test\
    \ solve(500) == string(500) \n@test solve(1000) == string(1000) \n@test solve(1500)\
    \ == string(1500) \n@test solve(1000) == \"1\" \n@test solve(1500) == \"110\"\
    \ \n@test solve(2000) == \"1110\" \n@test solve(5000) == \"111100\" \n@test solve(10000)\
    \ == \"11111010\" \n@test solve(20000) == \"11111111010\" \n@test solve(100000)\
    \ == \"111111111111010\" \n@test solve(1000000) == \"11111111111111111111010\"\
    \ \n@test solve(10000000) == \"1111111111111111111111111111010\" \n@test solve(100000000)\
    \ == \"111111111111111111111111111111111111010\" \n@test solve(1000000000) ==\
    \ \"11111111111111111111111111111111111111111111010\" \n@test solve(10000000000)\
    \ == \"1111111111111111111111111111111111111111111111111111010\" \n@test solve(100000000000)\
    \ == \"111111111111111111111111111111111111111111111111111111111111010\" \n@test\
    \ solve(1000000000000) == \"11111111111111111111111111111111111111111111111111111111111111111111010\"\
    \ \n@test solve(10000000000000) == \"1111111111111111111111111111111111111111111111111111111111111111111111111111010\"\
    \ \n@test solve(100000000000000) == \"111111111111111111111111111111111111111111111111111111111111111111111111111111111111010\"\
    \ \n@test solve(1000000000000000) == \"111111111111111111111111111111111111111111111111111111111111111111111111111111111111010\"\
    \ \n@test solve(10000000000000000) == \"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111010\"\
    \ \n@test solve(100000000000000000) == \"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111010\"\
    \ \n@test solve(1000000000000000000) == \"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "    if N <= 0\n        error(\"N < 0\")\n    end", "    \n    if N == 0 \n    \
    \    return \"\"\n    elif N == 1 \n        return \"0\"\n    elseif N > 1 \n\
    \        result <- solve(floor(N / 2))\n        result <- result * 2\n       \
    \ result <- result + String(N mod 2)\n        return result\n    end\nend", " \
    \   binary = \"\"\n    N = N % 10\n    N = N / 10\n    \n    while N > 0\n   \
    \     binary = N % 10 + binary\n        N = N / 10\n    end\n    return binary\n\
    end", "    \n\"\"\"\n    Problem\n    >>> solve(150)\n    \"11110\"\n    >>> solve(1000)\n\
    \    \"1\"\n    >>> solve(147)\n    \"11100\"\n\"\"\"\n    return \"\".join((str(n\
    \ % 2) for n in range(0, N + 1)))", "    if N <= 0\n        return \"0\"\n   \
    \ if N <= 20\n        return convert(convert(N))\n    if N <= 100\n        return\
    \ convert(convert(N))\n    if N <= 1000\n        return convert(convert(N))\n\
    \    if N <= 10000\n        return convert(convert(N))\n    return convert(convert(N))\n\
    end", "    if N <= 0\n        return \"0\"\n    if N < 10\n        return toChar(N)\n\
    \    \n    sum::Int64 = 0\n    digits::Int64 = 10\n    while digits < N\n    \
    \    digits = digits * 2\n    end", "    if N < 0\n        return '' \n    s =\
    \ ''\n    while (N /= 2)\n        s = s * 10 + N % 2\n        N /= 2\n    end\n\
    \    return s\nend\n</cell>\n<text>\nSolution", "    binary = String[N,N]()\n\
    \    for a in 1:N-1\n        binary[a] = \"0\" + String(N - a)\n        binary[N-a]\
    \ = \"1\"\n    return string(binary)\nend\n</cell>\n<code language=julia-1.6>\n\
    solve(1000)\n</cell>\n<code language=julia-1.6>\nsolve(150)\n</cell>\n<code language=julia-1.6>\n\
    solve(147)\n</cell>\n<code language=julia-1.6>\nsolve(100)\n</cell>\n<code language=julia-1.6>\n\
    solve(50)\n</cell>\n<text>\nProblem 7: Sum of Prime Numbers\nThe sum of the primes\
    \ below 10 is 2 + 3 + 5 + 7 = 17.", "    if N < 0\n        throw(ArgumentError(\"\
    N is a negative integer\"))\n    \n    let \n        binary = '0' \n        sum\
    \ = 0\n        \n        for i in 0:N-1\n            binary = string append binary\
    \ '1' if i%2 == 0 else '0'\n            sum += string count binary\n        end\n\
    \    \n    string(sum)\nend\n</cell>\n<text>\nProblem", "\"\"\"Given a positive\
    \ integer N, return the total sum of its digits in binary.\n    \n    Example\n\
    \    >>> solve(1000)\n    \"1\"\n    >>> solve(150)\n    \"110\"\n    >>> solve(147)\n\
    \    \"1100\"\n    \n    Variables:\n        @N integer\n             Constraints:\
    \ 0 \u2264 N \u2264 10000.\n    Output:\n         a string of binary number\n\
    \    \"\"\"\ndef solve(N::Int)::String \n    \"\"\"Given a positive integer N,\
    \ return the total sum of its digits in binary.\n    \n    Example\n    >>> solve(1000)\n\
    \    \"1\"\n    >>> solve(150)\n    \"110\"\n    >>> solve(147)\n    \"1100\"\n\
    \    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264\
    \ N \u2264 10000.\n    Output:\n         a string of binary number\n    \"\"\"",
  "    if N < 10\n        return \"0\"\n    \n    digits = num2str(N)\n    numStr\
    \  = join(reverse(digits[2:end-2]),\"\")\n    \n    while sum(digits[2:end-2])\
    \ == 0\n        digits = num2str(N)\n        numStr  = join(reverse(digits[2:end-2]),\"\
    \")\n    end\n    \n    return numStr\nend", "    \n    if N == 0 \n        \"\
    \"\n    elseif N == 1 \n        \"1\"\n    elseif N == 2 \n        \"10\"\n  \
    \  elseif N == 3 \n        \"111\"\n    elseif N == 4 \n        \"1001\"\n   \
    \ elseif N == 5 \n        \"1010\"\n    elseif N == 6 \n        \"1011\"\n   \
    \ elseif N == 7 \n        \"11001\"\n    elseif N == 8 \n        \"110010\"\n\
    \    elseif N == 9 \n        \"1100110\"\n    else\n        # Find sum of digits\
    \ in binary of N\n        digits_sum = sum([digits(n) for n in range(N)])\n  \
    \      # Form binary(N)\n        binary = ['0']*(N-1) + ['1']\n        # Append\
    \ digits to binary list to form binary string\n        for i in range(digits_sum-1):\n\
    \            binary.insert(0,binary[len(binary)-1])\n        binary_string = ''.join(binary)\n\
    \        # Form binary string of the given N\n        return binary_string\n \
    \       \n    end", "    sum = 0\n    while N \u2265 0 do\n        sum = sum +\
    \ N % 2\n        N = N div 2\n    return string(\"1\" \u2219 sum)\nend\n</code>\n\
    <|/ a tags=julia |>\n<| a tags=julia dscore=3 |>\nThe Julia documentation provides\
    \ a solution that is simpler than the above answers because it is based on built-in\
    \ functions instead of explicit loops -- \"div\" and \"mod\".  In julia, div and\
    \ mod are defined as div(x, y) and mod(x, y), respectively, which can be used\
    \ in place of the / and % operators.\n<code>", "    if N<10\n        return str(N)\n\
    \    else if N<100\n        return N%10+solve(N/10)\n    else\n        return\
    \ solve(N/100)+solve(N/10)+solve(N%10)\nend\n</cell>\n<text>\nWe will test the\
    \ function with several cases:", "    solve(N, \"\")\nend", "    \n    # Initialize\
    \ a string to hold our result\n    result = \"\"\n    \n    # Initialize our counter\n\
    \    count = 0\n    \n    # While loop which runs while the count is less than\
    \ N\n    while (count < N) do\n        # Increment the count\n        count +=\
    \ 1\n        \n        # Pad the result with zeros\n        result = result +\
    \ \"0\"\n        \n        # Convert the result to a string\n        result =\
    \ toString(result)\n        \n        # Subtract 2 from the result\n        result\
    \ = result - 2\n        \n        # Convert the result to a string\n        result\
    \ = toString(result)\n        \n        # Add the result to the string\n     \
    \   result = result + result\n    \n    return result\nend", "    if N<0\n   \
    \     return \"-1\"\n    if N==0\n        return \"0\"\n    if N==1\n        return\
    \ \"1\"\n    \n    ones = \"1\"\n    tens = \"10\"\n    \n    digits = N::Int64\n\
    \    digits_str = digits2str(digits)\n    \n    sum = \"\"\n    \n    \n    for\
    \ digit in digits_str\n        if digit == \"1\"\n            sum += ones\n  \
    \      elseif digit == \"0\"\n            sum += tens\n        else\n        \
    \    println(digits_str,\"not a valid binary digit\")\n        end\n    end\n\
    \    \n    return sum\nend\n</cell>\n<code language=julia-1.0>\nsolve(147)\n</cell>\n\
    <code language=julia-1.0>\nsolve(146)\n</cell>\n<code language=julia-1.0>\nsolve(145)\n\
    </cell>\n<code language=julia-1.0>\nsolve(144)\n</cell>\n<code language=julia-1.0>\n\
    solve(144)\n</cell>\n<code language=julia-1.0>\nsolve(143)\n</cell>\n<code language=julia-1.0>\n\
    solve(143)\n</cell>\n<code language=julia-1.0>\nsolve(142)\n</cell>\n<code language=julia-1.0>\n\
    solve(142)\n</cell>\n<code language=julia-1.0>\nsolve(141)\n</cell>\n<code language=julia-1.0>\n\
    solve(141)\n</cell>\n<code language=julia-1.0>\nsolve(140)\n</cell>\n<code language=julia-1.0>\n\
    solve(140)\n</cell>\n<code language=julia-1.0>\nsolve(139)\n</cell>\n<code language=julia-1.0>\n\
    solve(139)\n</cell>\n<code language=julia-1.0>\nsolve(138)\n</cell>\n<code language=julia-1.0>\n\
    solve(138)\n</cell>\n<code language=julia-1.0>\nsolve(137)\n</cell>\n<code language=julia-1.0>\n\
    solve(137)\n</cell>\n<code language=julia-1.0>\nsolve(136)\n</cell>\n<code language=julia-1.0>\n\
    solve(136)\n</cell>\n<code language=julia-1.0>\nsolve(135)\n</cell>\n<code language=julia-1.0>\n\
    solve(135)\n</cell>\n<code language=julia-1.0>\nsolve(134)\n</cell>\n<code language=julia-1.0>\n\
    solve(134)\n</cell>\n<code language=julia-1.0>\nsolve(133)\n</cell>\n<code language=julia-1.0>\n\
    solve(133)\n</cell>\n<code language=julia-1.0>\nsolve(", "    if N < 0\n     \
    \   error(\"N must be >= 0\")\n    \n    # create an empty string\n    sumstring\
    \ = \"\"\n    \n    # start with a 1 \n    sumstring = sumstring + \"1\"\n   \
    \ \n    while N > 0\n        # calculate the number of digits in N\n        digits\
    \ = floor(log10(abs(N))) + 1 \n        \n        # break if the number is less\
    \ than or equal to 1\n        if digits <= 0\n            break\n        \n  \
    \      # append the number in binary\n        sumstring = sumstring + str((N%10).*digits)\n\
    \        N = floor(N / 10)\n    end\n    return sumstring\nend\n</cell>\n<text>\n\
    Tests\nNow that we have solved the problem and learned how to write tests, let's\
    \ test our solution. Let's test the case where N is zero.", "    if N==0\n   \
    \     return \"0\"\n    if N<0\n        return \"-\"+solve(abs(N))\n    \n   \
    \ let N = N mod 2\n    let bits = ceil(log2(n::Int64))\n    let bitstr = bitstring(Int64,\
    \ bits, \"\")\n    let bitstr1 = bitstr[1:bitstr.length-1]\n    let res = (N *\
    \ (bitstr1.bin*2)+bitstr1) / (2::Int64) \n    if res==0 \n        return \"0\"\
    \n    else \n        return string(res, 2, \"\")\nend", "    \"\"\"Given a positive\
    \ integer N, return the total sum of its digits in binary.\n    \n    Example\n\
    \    >>> solve(1000)\n    \"1\"\n    >>> solve(150)\n    \"110\"\n    >>> solve(147)\n\
    \    \"1100\"\n    \n    Variables:\n        @N integer\n             Constraints:\
    \ 0 \u2264 N \u2264 10000.\n    Output:\n         a string of binary number\n\
    \    \"\"\"\n    if N < 0\n        return \"-1\"\n    if N == 0\n        return\
    \ \"0\"\n    if N == 1\n        return \"1\"\n    digits = 0.\n    count = 0\n\
    \    total = \"0\"\n    while  N > 0\n        digits = digits + N % 2\n      \
    \  N = floor(N/2)\n        count = count + 1\n    end\n    total = \"1\"\n   \
    \ for i in count-1..count\n        total = total * \"0\"\n    end\n    for i in\
    \ 0..count-1\n        total = total + digits[i]\n    end\n    return total\nend\n\
    </cell>\n<code language=julia-1.0>\n## @testset \"solve tests\" begin\n    \n\
    \    ## Test 1\n    solve(1000)\n    \"1\"\n    solve(150)\n    \"110\"\n    solve(147)\n\
    \    \"1100\"\n    solve(125)\n    \"11111\"\n    solve(123)\n    \"111111\"\n\
    \    solve(101)\n    \"111010\"\n    solve(100)\n    \"10010\"\n    \n    ## Test\
    \ 2\n    solve(1100)\n    \"11110\"\n    solve(1300)\n    \"1111110\"\n    \n\
    \    ## Test 3\n    solve(999)\n    \"101011\"\n    solve(998)\n    \"10101101\"\
    \n    solve(997)\n    \"101011010\"\n    solve(996)\n    \"1010110100\"\n    solve(995)\n\
    \    \"10101101000\"\n    solve(994)\n    \"101011010000\"\n    solve(993)\n \
    \   \"1010110100000\"\n    solve(992)\n    \"10101101000000\"\n    solve(991)\n\
    \    \"101011010000000\"\n    solve(990)\n    \"1010110100000000\"\n    solve(989)\n\
    \    \"10101101000000000\"\n    solve(988)\n    \"101011010000000000\"\n    solve(987)\n\
    \    \"1010110100000000000\"\n    solve(986)\n    \"10101101000000000000\"\n \
    \   solve(985)\n    \"101011010000000000000\"\n    solve(984)\n    \"1010110100000000000000\"\
    \n    solve(983)\n    \"10101101000000000000000\"\n    solve(98", "    answer\
    \ = ''\n    digits(N) do n \n        answer = answer + string(n::Int)\n    end\n\
    \    return answer\nend\n</cell>\n<code language=julia-1.5>", "    if N < 0\n\
    \        return \"0\"\n    if N > 1000000\n        return \"0\"\n    digits =\
    \ N % 1000000000\n    N /= 1000000000\n    sum = 0\n    while(N > 0)\n       \
    \ sum += N % 10\n        N /= 10\n    binary_string = format(\"{:0\" + str(digits*3)\
    \ + \"b}\").format(sum)\n    return binary_string\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solve(1) == \"1\"\n@assert solve(2) == \"10\"\n@assert solve(10) == \"\
    100\"\n@assert solve(100) == \"1000\"\n@assert solve(1000) == \"1\"\n@assert solve(10000)\
    \ == \"1111\"\n@assert solve(100000) == \"1000110\"\n@assert solve(1000000) ==\
    \ \"100100101\"\n@assert solve(10000000) == \"100100001000110\"\n@assert solve(100000000)\
    \ == \"1001001001001001011\"\n@assert solve(1000000000) == \"1001001001001001001111\"\
    \n@assert solve(10000000000) == \"10010010010010010010011111\"\n@assert solve(100000000000)\
    \ == \"100100100100100100100100111111\"\n@assert solve(1000000000000) == \"1001001001001001001001001001111111\"\
    \n@assert solve(10000000000000) == \"100100100100100100100100100111111110\"\n\
    @assert solve(100000000000000) == \"100100100100100100100100100111111110\"\n@assert\
    \ solve(1000000000000000) == \"100100100100100100100100100111111110\"\n@assert\
    \ solve(10000000000000000) == \"100100100100100100100100100111111110\"\n@assert\
    \ solve(100000000000000000) == \"100100100100100100100100100111111110\"\n@assert\
    \ solve(1000000000000000000) == \"100100100100100100100100100111111110\"\n@assert\
    \ solve(10000000000000000000) == \"100100100100100100100100100111111110\"\n@assert\
    \ solve(100000000000000000000) == \"100100100100100100100100100111111110\"\n@assert\
    \ solve(1000000000000000000000) == \"100100100100100100100100100111111110\"\n\
    @assert solve(10000000000000000000000) == \"100100100100100100100100100111111110\"\
    \n@assert solve(100000000000000000000000) == \"100100100100100100100100100111111110\"\
    \n@assert solve(1000000000000000000000000) == \"100100100100100100100100100111111110\"\
    \n@assert solve(10000000000000000000000000) == \"100100100100100100100", "   \
    \ if N<0\n        throw(BoundsError)\n    elseif N==0\n        return \"0\"\n\
    \    else\n        str = bin(N)\n        str = str.lstrip(\"0b\")\n        str\
    \ = str.rstrip('0')\n        str = str * 2\n        str = str[2:end]\n       \
    \ str = strings(str, 0)\n        return str\n    end\nend", "    if N < 0\n  \
    \  \n    else if N < 10\n    \n    else\n    \n    end\nend", "    if N<0\n  \
    \      throw(ArgumentError(\"N\",\"N is a non-negative integer\"))\n    else if\
    \ N<10\n        return \"0\" + convert(N-1)\n    else if N==10\n        return\
    \ \"1\"\n    else if N%10 == 0\n        return solve(floor(N/10))\n    else\n\
    \        return solve(floor(N/10)) + convert(N%10)\nend", "    if N < 10 \n  \
    \      solve(N)\n    else\n        solve(10*N+N-1) + string(N%2)\nend", "    \
    \ \"\"\"Given a positive integer N, return the total sum of its digits in binary.\n\
    \    \n    Example\n    >>> solve(1000)\n    \"1\"\n    >>> solve(150)\n    \"\
    110\"\n    >>> solve(147)\n    \"1100\"\n    \n    Variables:\n        @N integer\n\
    \             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string\
    \ of binary number\n    \"\"\"\n    function solve(N::Int64)\n        str = str(N)\
    \ |> str\n        \n        return ''.join(str[end - 1:end + 1] for end in str[end\
    \ - 1..-1]) |> str\n    end\nend", "    \n    if N < 0\n        throw(\"Error\"\
    )\n        \n    if N ==0\n        return \"0\"\n    \n    if N == 0\n       \
    \ return \"\"\n    \n    let digits = map(digits(N), digits(N-1))\n    \n    binary\
    \ = reverse(digits)\n    \n    total = reverse(binary)\n    \n    total = reverse([total..\"\
    1\"])\n    \n    total = reverse(total)\n    \n    total = reverse(total)\n  \
    \  \n    return total\nend \nsolve\n</cell>\n<code language=julia-1.5>\n@code_warntype\
    \ solve(1)\n</cell>\n<text>\nProblem 2.2: Solve the problem of computing Nth number\
    \ with modulo K:", "  \n    solved = 0\n    sum = 0\n    \n    for x in N:\n \
    \       if x % 2 == 0: \n            sum += x % 2\n        elif x % 2 == 0:\n\
    \            sum += x\n        else: \n            sum += x/2\n        solved\
    \ = solved + sum\n    \n    return solved\n\"\"\"\n## Questions\n1. Write a function\
    \ that converts Celcius to Fahrenheit.\n    \n    Example\n    >>> solve(1)\n\
    \    32.00\n    >>> solve(2)\n    42.0\n    \n    Variables:\n        @K float\n\
    \             Constraints: 0 \u2264 K \u2264 100\n    Output:\n         a float\
    \ number in Fahrenheit\n\"\"\"", "    if N < 0 || N > 10000 \n        return \"\
    invalid input\"\n    if N < 10\n        return string_of(N)\n    return \"\"",
  "\"\"\"\n    Problem 8\n    \n    Input: an integer N\n    Output: the sum of the\
    \ digits of N in binary\n    \n    Constraints:\n        1 \u2264 N \u2264 10^9\n\
    \    \n    Example input:\n        N = 10\n    Example output:\n        \"1010\"\
    \n    \n    \n    \n    \n    \"\"\"\n    if N < 0 \n        error(\"N must be\
    \ positive\")\n    \n    return dec(N)", "    \n    sum:Int64 = 0\n    \n    for\
    \ n in N do\n        sum = sum + n\n    \n    sumStr = string(sum)\n    \n   \
    \ return sumStr\nend", "    \n    if N == 0 \n        then return \"0\" \n   \
    \ else \n        solve(N div 2) + solve(N mod 2)\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solve(0) == \"0\"\n@assert solve(10) == \"1\"\n@assert solve(30) == \"\
    111\"\n@assert solve(100) == \"100\"\n@assert solve(500) == \"1111\"\n@assert\
    \ solve(1000) == \"10000\"\n@assert solve(1500) == \"1111001\"\n</cell>\n<text>\n\
    Exercise 2", "    \n    if N < 10\n        return str(N)\n    \n    if N < 100\n\
    \        return bin(N)[2:].rjust(2, '0')\n    \n    if N < 1000\n        return\
    \ bin(N)[3:7].rjust(3, '0')\n    \n    if N < 10000\n        return bin(N)[7:11].rjust(4,\
    \ '0')\n    \n    return \"1\"\nend \n</cell>\n<code language=julia-1.5>\nsolve(1000)\n\
    </cell>\n<code language=julia-1.5>\nsolve(150)\n</cell>\n<code language=julia-1.5>\n\
    solve(147)\n</cell>\n<code language=julia-1.5>", "    \"Given a positive integer\
    \ N, return the total sum of its digits in binary\"\n    let s = N::Int64\n  \
    \  return sum((N % 10::Int64)::Int64[])\nend\n</cell>\n<code language=julia-1.5>\n\
    solve(1000)\n</cell>\n<text>\nProblem 4\nSolve the equation system: ax = bx \u2212\
    \ c = 0 with the coefficients given in the form of vectors.", "    if N==0\n \
    \       return \"\";\n    if N==1\n        return \"0\";\n    if N<0\n       \
    \ return \"-1\";\n    if N==2\n        return \"10\";\n    binary = \"\";\n  \
    \  carry = 0;\n    ones = 0;\n    twos = 0;\n    threes = 0;\n    fours = 0;\n\
    \    fives = 0;\n    sixes = 0;\n    sevens = 0;\n    eights = 0;\n    nines =\
    \ 0;\n    \n    binary = string(N, 2)\n    \n    carry = binary.reverse.index(\"\
    0\")\n    ones = binary.reverse.count(\"1\")\n    \n    twos = binary.reverse.count(\"\
    10\")\n    \n    threes = binary.reverse.count(\"100\")\n    \n    fours = binary.reverse.count(\"\
    1000\")\n    \n    fives = binary.reverse.count(\"10000\")\n    \n    sixes =\
    \ binary.reverse.count(\"100000\")\n    \n    sevens = binary.reverse.count(\"\
    1000000\")\n    \n    eights = binary.reverse.count(\"10000000\")\n    \n    nines\
    \ = binary.reverse.count(\"100000000\")\n    \n    \n    binary = binary.reverse\n\
    \    \n    binary = binary.replace(\"0\", \"1\")\n    binary = binary.replace(\"\
    1\", \"1\")\n    binary = binary.replace(\"2\", \"1\")\n    binary = binary.replace(\"\
    3\", \"1\")\n    binary = binary.replace(\"4\", \"1\")\n    binary = binary.replace(\"\
    5\", \"1\")\n    binary = binary.replace(\"6\", \"1\")\n    binary = binary.replace(\"\
    7\", \"1\")\n    binary = binary.replace(\"8\", \"1\")\n    binary = binary.replace(\"\
    9\", \"1\")\n    binary = binary.replace(\"*\", \"1\")\n    binary = binary.replace(\"\
    +\", \"1\")\n    binary = binary.replace(\"-\", \"1\")\n    binary = binary.replace(\"\
    =\", \"1\")\n    binary = binary.replace(\"%\", \"1\")\n    binary = binary.replace(\"\
    (\", \"1\")\n    binary = binary.replace(\")\", \"1\")\n    binary = binary.replace(\"\
    [\", \"1\")\n    binary = binary.replace(\"]\", \"1\")\n    binary = binary.replace(\"\
    {\", \"1\")\n    binary = binary.replace(\"}\", \"1\")\n    binary = binary.replace(\"\
    /\", \"1\")\n    binary = binary.replace(\"%\", \"1\")\n    binary = binary.replace(\"\
    <\", \"1\")\n    binary = binary.replace(\">\", \"1\")\n    binary = binary.replace(\"\
    &\", \"1\")\n    binary = binary.replace(\"^\", \"1\")\n    bin", "    digits\
    \ = digits(N)\n    return digits.reduce(+) \nend\n</cell>\n<text>\n4.2 Example\n\
    Let's try it!", "    digits_sum = 0\n    \n    for i in 2..N\n        digits_sum\
    \ += div(log10(i),2)\n    return div(digits_sum,2) == 0 ? \"1\" : \"0\"\nend\n\
    </cell>\n<code language=julia-0.6>\n\"\"\"Given a positive integer N, return the\
    \ total sum of its digits in binary.\n    \n    Example\n    >>> solve(1000)\n\
    \    \"1\"\n    >>> solve(150)\n    \"110\"\n    >>> solve(147)\n    \"1100\"\n\
    \    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264\
    \ N \u2264 10000.\n    Output:\n         a string of binary number\n    \"\"\"",
  "    if N == 0 \n        return \"0\" \n    else \n        digit = N % 10\n    \
    \    N = N / 10\n        reverse(digits, digit)\n        reverse(digits, N)\n\
    \        solve(N)\n    end\nend", "    if N < 0\n        return \"No such number\"\
    \n    if N == 0 || N == 1\n        return \"1\"\n    if N < 10\n        return\
    \ string(N) \n    res = \"\"\n    d = 0\n    while N > 1\n        d, N = div(N,\
    \ 2)\n        res = (char(d) * 2) + (string(d) * res)\n    \n    return res\n\
    end\n</code>\n<|/ a tags=algorithm,binary,math,julia |>\n<| c |>\n`N < 10` can\
    \ be done in the while loop. Also your answer does not match the expected result\
    \ for the input `1000`\n<|/ c |>\n<| c |>\nThe question is tagged 'julia' not\
    \ 'python', and you write 'No such number' in both Python and Julia but don't\
    \ mention this at all. Should you not be returning 'No such number' if N < 0 instead\
    \ of 'No such number'?\n<|/ c |>\n<| c |>\nThanks, fixed. Now `1000` returns `\"\
    1\"` as expected.\n<|/ c |>\n<| a tags=algorithm,binary,math,julia |>\nYou can\
    \ avoid a lot of boilerplate code by using the following recursive algorithm:\n\
    <code>", "    if N < 0 then return \"ERROR\"\n    if N == 0 then return \"0\"\n\
    \    binstr = \"\"\n    binary = N % 10\n    binstr ++ binary(10*floor(N/10))\
    \ + \" \"\n    return binstr\nend\n</cell>\n<code language=julia-0.3>\n\"\"\"\n\
    \ Write a Julia function called binary.", "    if N<0\n        throw(ArgumentError(\"\
    N must be positive\"))\n    end\n    if N <= 0\n        return \"0\"\n    end\n\
    \    if N <= 1\n        return \"1\"\n    end\n    sum = \"\"\n    while N > 0\n\
    \        if N mod 2 == 0\n            sum = \"01\" * sum + N % 2\n        end\n\
    \        N = N >> 1\n    end\n    return sum\nend", "    if N<0:\n        throw(ArgumentError(\"\
    N must be a positive integer\"))\n    if N<10\n        throw(ArgumentError(\"\
    N must be a positive integer larger than 10\"))\n    binstr = String(bin(N))\n\
    \    binstr1 = binstr[2:end]\n    binstr2 = binstr[end-5:end]\n    binstr3 = binstr[end-3:end]\n\
    \    binstr4 = binstr[end-1:end]\n    if length(binstr1) > length(binstr2)\n \
    \       return binstr3\n    else\n        return binstr4\n    end\nend", "   \
    \ if N==0 \n        return \"0\" \n    digits = strings(N) \n    digitsum = sum(digits)\
    \ \n    binarydigitsum = bin(digitsum)[2:] \n    \n    if digitsum == 0 \n   \
    \     return \"\"\n    if digitsum == 1 \n        return binarydigitsum\n    \n\
    \    \n    \n    return binarydigitsum + solve(digitsum-1)\nend\n</cell>\n<code\
    \ language=julia-1.1>\n@assert solve(1) == \"1\"\n@assert solve(5) == \"101\"\n\
    @assert solve(10) == \"1110\"\n@assert solve(22) == \"10101\"\n@assert solve(100)\
    \ == \"10010\"\n@assert solve(101) == \"110011\"\n</cell>\n<code language=julia-1.1>\n\
    \"\"\"Return the total sum of its digits in binary.", "    if N == 0 return \"\
    0\"\n    if N == 1 return \"1\"\n    s = solve(N/2)\n    return s + \"1\" + s\n\
    end\n</cell>\n<code language=julia-0.5>\nsolve(10)\n</cell>\n<code language=julia-0.5>",
  "    \n    if N < 0\n        return \"NA\"\n    \n    if N == 0 \n        return\
    \ \"0\"\n    \n    if N == 1 \n        return \"1\"", "    \n    if N < 0 \n \
    \       then return \"0\"\n    else if N == 0 \n        then return \"0\"\n  \
    \  else if N < 10 \n        then return \"0\" + solve(N / 2)\n    else if N <\
    \ 100 \n        then return \"1\" + solve(N / 2)\n    else\n        tmp = solve(floor(N\
    \ / 10)) + 1\n        tmp = tmp + solve(N % 10)\n        return tmp\nend\n</cell>\n\
    <text>\nExercise:\nWhat is the minimum number of zeros that must be appended to\
    \ get a positive integer N so that N's digits are in binary?", "    \"\"\"\n \
    \       Input:\n            @param N: an integer\n        Output:\n          \
    \   a string of binary number\n        \"\"\"\n    return \"\"\nend\n</cell>\n\
    <text>\nProblem 4\n(Adapted from Problem 1.) A palindromic number reads the same\
    \ both ways. The largest palindrome made from the product of two 2-digit numbers\
    \ is 9009 = 91 x 99.\nFind the largest palindrome made from the product of two\
    \ 3-digit numbers.", "    if N == 0  \n        return \"0\"\n    else\n      \
    \  str = string(N:Bit{N}*2)\n        str = string.split(str)\n        str = string.split(str,\
    \ \" \")\n        str = string.split(str, \",\")\n        for i in str\n     \
    \       i = string(i,\":\")\n            i = string(i,\"-\")\n            i =\
    \ string(i,\"_\")\n            i = string(i,\"^\")\n            if string.find(i)\
    \ == 2 \n                str = string.replace(string.replace(string.replace(string.replace(string.remove(i),\"\
    -\",\"_\"),\"_\",\"^\"),\"^\",\"+\"),\"+\",\"\")\n            end\n        end\n\
    \        return str\n    end\nend\n</cell>\n<code language=julia-1.4>", "    if\
    \ N < 0\n        return \"-1\"\n    \n    if N < 10\n        return string(\"\
    0\", N)\n    \n    binary = string(0, N)\n    \n    if N & 1 == 1\n        binary\
    \ = binary..string(1, 1)\n    end\n    \n    N >>= 1\n    \n    while N > 0\n\
    \        binary = string(binary, N % 2)\n        N /= 2\n    end\n    \n    binary\
    \ = string(binary, N)\n    \n    return binary\nend", "    if N == 0 \n      \
    \  \"\" \n    else \n        string = str(N) \n        for i in string.digits:\
    \ \n            string = string + i\n            \n    return string", "    \n\
    \    \"\"\"\n    Your Solution goes here\n    \"\"\"\n    s = ''\n    for digit\
    \ in N:\n        s += str(digit)\n    return s\n    \nend\n</cell>\n<text>\nExercise\
    \ 7: Problem 2b", "    \n    if N<0\n        return \"Invalid Input\"\n    \n\
    \    if N==0\n        return \"0\"\n    \n    if N<10 \n        return toChar(N)\n\
    \    \n    if N==10\n        return \"10\"\n    \n    if N<100\n        return\
    \ toChar(N)\n    \n    if N%10==0\n        return toChar(N/10) + \"+\" +  toChar(mod(N,10))\
    \ \n    \n    return toChar(N/10) + \"+\" + solve(N%10)\nend\n</cell>\n<code language=julia-1.0>\n\
    solve(123456789)\n</cell>\n<code language=julia-1.0>\nsolve(123456789,20)\n</cell>\n\
    <text>\nProblem 7.9\nWrite a Julia function called solve that takes in input the\
    \ total sum of its digits in binary and outputs the number of digits in the binary\
    \ representation of the input number. \nExample\nGiven a positive integer N, return\
    \ the total number of its digits in binary. \nConstraints: \n@N integer \n   \
    \      Constraints: 0 \u2264 N \u2264 10,000.", "    return str(bin(N)[2:])\n\
    end\n</cell>\n<code language=julia-0.5>\n# TEST solve (31 tests)\n@testset \"\
    Problem 15: Solve (solve)\" begin\n  Ns = [1000, 150, 147]\n  for N in Ns\n  \
    \  @test solve(N) == \"1\"\n  end\nend\n</cell>\n<text>\nProblem 16: Add Digits\
    \ Function\nInputs:", "    \n    if N<0\n        return \"0\"\n    \n    if N==0\n\
    \        return \"0\"\n    \n    if N==1\n        return \"1\"\n    \n    return\
    \ str(N%2) + solve(floor(N/2))\nend", "    digit_sums = N % digit(N)\n    digits\
    \ = digit(N)\n    answer = \"\"\n    for i in 1:digits\n        answer += digits[i]\n\
    \    end\n    return answer\n</code>\n<|/ a dscore=2 |>\n<| a |>\nUsing recursive\
    \ and memoization.\n<code>\nmodule MyRecurse", "    if N <= 0\n        error(\"\
    N must be greater than 0\")\n    end\n    \n    digitsum::Int64 = 0\n    \n  \
    \  for i in 0:N-1\n        digitsum += (i%2)*3\n        i /= 2\n    end\n    \n\
    \    digitsum = (digitsum + N*(N-1))%2\n    \n    digitsum == 0 \n        ? \"\
    0\"\n        : (digitsum == 1)\n        ? (\"1\")\n        : (\"0\" + string(digitsum,\
    \ \"b\")[2:end])\nend\n</cell>\n<code language=julia-1.0>\nsolve(1000)\n</cell>\n\
    <code language=julia-1.0>\nsolve(150)\n</cell>\n<code language=julia-1.0>\nsolve(147)\n\
    </cell>\n<text>\nQuestion:\nFor what values of $N$ is my code working?", "   \
    \ \n    \"\"\"Function for problem 11.\"\"\"\n    function digitSum2(n::Int64)::Int64\
    \ \n        \n        \"\"\"Function for problem 12.\"\"\"\n        function digitSum3(n::Int64)::Int64\
    \ \n            \n            \"\"\"Function for problem 13.\"\"\"\n         \
    \   function digitSum4(n::Int64)::Int64 \n            \n                \"\"\"\
    Function for problem 14.\"\"\"\n                function digitSum5(n::Int64)::Int64\n\
    \            \n                    \"\"\"Function for problem 15.\"\"\"\n    \
    \                function digitSum6(n::Int64)::Int64\n                \n     \
    \                   \"\"\"Function for problem 16.\"\"\"\n                   \
    \     function digitSum7(n::Int64)::Int64\n                        \n        \
    \                    \"\"\"Function for problem 17.\"\"\"\n                  \
    \          function digitSum8(n::Int64)::Int64\n                            \n\
    \                                \"\"\"Function for problem 18.\"\"\"\n      \
    \                          function digitSum9(n::Int64)::Int64\n             \
    \                   \n                                    \"\"\"Function for problem\
    \ 19.\"\"\"\n                                    function digitSum10(n::Int64)::Int64\n\
    \                                \n                                        \"\"\
    \"Function for problem 20.\"\"\"\n                                        function\
    \ digitSum11(n::Int64)::Int64\n                                        \n    \
    \                                        \"\"\"Function for problem 21.\"\"\"\n\
    \                                            function digitSum12(n::Int64)::Int64\n\
    \                                            \n                              \
    \                  \"\"\"Function for problem 23.\"\"\"\n                    \
    \                            function digitSum13(n::Int64)::Int64\n          \
    \                                      \n                                    \
    \                \"\"\"Function for problem 24.\"\"\"\n                      \
    \                              function digitSum14(n::Int64)::Int64\n        \
    \                                        \n                                  \
    \                      \"\"\"Function for problem 25.\"\"\"\n                \
    \                                        function digitSum15(n::Int64)::Int64\n\
    \                                                        \n                  \
    \                                          \"\"\"Function for problem 26.\"\"\"\
    \n                                                            function digitSum16(n::Int64)::Int64\n\
    \                                                            \n              \
    \                                                  \"\"\"Function for problem\
    \ 27.\"\"\"\n                                                                function\
    \ digitSum17(n::Int64)::Int64\n                                              \
    \                  \n                                                        \
    \            \"\"\"Function for problem 28.\"\"\"\n                          \
    \                                          function digitSum18(n::Int64)::Int64\n\
    \                                                                    \n      \
    \                                                                  \"\"\"Function\
    \ for problem 29.\"\"\"\n                                                    \
    \                    function digitSum19(n::Int64)::Int64\n                  \
    \                                                      \n                    \
    \                                                        \"\"\"Function for problem\
    \ 30.\"\"\"\n                                                                \
    \            function digitSum20(n::Int64)::Int64\n                          \
    \                                                  \n                        \
    \                                                        \"\"\"Function for problem\
    \ 31.\"\"\"\n                                                                \
    \                function digitSum21(n::Int64)::Int64\n                      \
    \                                                          \n                \
    \                                                                    \"\"\"Function\
    \ for problem 32.\"\"\"\n                                                    \
    \                                function digitSum22(n::Int64)::Int64\n      \
    \                                                                            \
    \  \n                                                                ", "    str\
    \ = \"\"\n    N = N % 2\n    \n    for n in 2..N\n        str +=  str[n-1] * (N\
    \ / n)\n    \n    return str\nend", "    # write your code in python/ipython notebook\n\
    \    return \"1\"\n    \n</cell>\n<text>\nProblem 7: Sum of Digits\nGiven a positive\
    \ integer N, return the sum of its digits in decimal. \n    \n    Example\n  \
    \  >>> solve(1000)\n    3\n    >>> solve(147)\n    10\n    >>> solve(999)\n  \
    \  6\n    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264\
    \ N \u2264 10000.\n    Output:\n         a real number\n    \"\"\"", '    return
    sum(map((x::Int64) -> Int64(str2bin(x)), digits(N))) ', "    if N < 0\n      \
    \  error(\"@N must be positive\")\n    elseif N > 10000\n        error(\"@N must\
    \ be no more than 10000\")\n    else\n        str = String(digits(N))\n      \
    \  str = str.reverse()\n        s = \"\"\n        for c in str\n            if\
    \ c == '1'\n                s = s + \"1\"\n            elseif c == '0'\n     \
    \           s = s + \"0\"\n            else\n                s = s + c\n     \
    \   end\n        return s\n    end\nend\n</cell>\n<code language=julia-1.4>\n\
    solve(1000)\n</cell>\n<code language=julia-1.4>\nsolve(150)\n</cell>\n<code language=julia-1.4>\n\
    solve(147)\n</cell>\n<code language=julia-1.4>\nsolve(10000)\n</cell>\n<code language=julia-1.4>\n\
    solve(1111)\n</cell>\n<text>\n6.7 Find the number of divisors of 100\nProblem\
    \ 7\nLet us solve the number - 8. How many divisors (divisors of the number itself\
    \ as well) there are and what are their digits?", "    @assert (N mod 2) == 0\n\
    \    @assert (N div 2) < 10000\n    @assert (N div 2) == 0\n    \n    \n    binary\
    \ = \"\"\n    \n    while N > 0\n        \n        if (N mod 2) == 0\n       \
    \     \n            # Only the bottom two digits are non-zero\n            \n\
    \            binary = binom.next_binary(N, 2)\n            \n        else\n  \
    \          \n            # The top three digits are non-zero\n            \n \
    \           binary = binom.next_binary(N, 3)\n        end\n        \n        N\
    \ /= 2\n    end\n    \n    return binary\nend", "\"\"\"\n    Problem 7.13: Solve\
    \ the problem\n    \n    Input:\n        @N an integer greater than 0.\n    Output:\n\
    \        @result a string of binary number\n\"\"\"\n    let result=\"\"\n    if\
    \ N==0\n    then return result\n    else\n    let digit=N//10\n    let N=N%10\n\
    \    for d in digit'..9\n    do\n        result=result+\"1\"\n    let result=result+digit\n\
    \    return solve(N)\nend", "    if N < 1\n        return \"0\"\n    \n    soln\
    \ = \"\"\n    # Loop from N to 0 \n    for i = N:-1:1\n        # Calculate the\
    \ binary representation for this power\n        # Convert it to string\n     \
    \   binstr = digit2bin(i)\n        # Add the binary representation to soln\n \
    \       soln += binstr\n    end\n    return soln\nend", "    digits = []\n   \
    \ rem = 0\n    sum = 0\n    while N > 0\n        digits.append(N % 10)\n     \
    \   sum = (sum + (digits[rem])*rem)/10\n        rem = rem*10\n        N = N /\
    \ 10\n    end\n    return convert(sum)\nend\n\"\"\"\n    Given a positive integer\
    \ N, return the sum of its digits as a string.\n    \n    Example\n    >>> solve(1000)\n\
    \    \"1\"\n    >>> solve(150)\n    \"110\"\n    >>> solve(147)\n    \"1100\"\n\
    \    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264\
    \ N \u2264 10000.\n    Output:\n         a string\n    \"\"\"", "    \n    if\
    \ N < 0 \n        error(\"ERROR: negative or zero argument\")\n    elseif N ==\
    \ 0\n        return \"0\"\n    elseif N == 1\n        return \"1\"\n    elseif\
    \ N > 1\n        digitsum::Int64 = 0\n        while N > 0\n            digitsum::Int64\
    \ += N mod 10\n            N::Int64 = N div 10\n        return digitsum.to_binary(digitsum)\n\
    \    end\nend", "    \n    if N < 0 \n        return \"0\"\n    elif N == 0 \n\
    \        return \"0\"\n    elif N % 2 == 0 \n        return solve(floor(sqrt(N)))\
    \ * \"1\" + \"0\" * solve(floor(sqrt(N)))\n    \n    else \n        return solve(floor(sqrt(N)))\
    \ * \"1\" + \"0\" * solve(floor(sqrt(N))) \n</code>\nThe code above is easy to\
    \ understand but I have been looking at some alternative methods. One of those\
    \ methods is using binary numbers to solve the problem of finding the sum of the\
    \ digits of a number, using the following code:\n<code>", "    \n    str_N = \"\
    1\" * Int(N).ceil\n    \n    str_len = (length(str_N) - 1) // 9\n    return str_N[1:str_len]\n\
    end", "    if N == 0\n        return \"0\"\n    if N < 0\n        return \"0\"\
    \n    if N < 10\n        return str((N * 2 - 1)%2) + solve(N/2)\n    if N < 100\n\
    \        return str((N * 3 - 2)%10) + solve(N/10)\n    if N < 1000\n        return\
    \ str((N * 4 - 3)%100) + solve(N/100)\n    if N < 10000\n        return str((N\
    \ * 5 - 4)%1000) + solve(N/1000)\n    if N < 100000\n        return str((N * 6\
    \ - 5)%10000) + solve(N/10000)\n    if N < 1000000\n        return str((N * 7\
    \ - 6)%100000) + solve(N/100000)\n    if N < 10000000\n        return str((N *\
    \ 8 - 7)%1000000) + solve(N/1000000)\n    return str((N * 9 - 8)%10000000) + solve(N/10000000)\n\
    end", "    if N <= 0 \n    then\n        return \"0\"\n    else if N <= 1\n  \
    \  then\n        return \"1\"\n    else if N <= 2\n    then\n        return \"\
    11\"\n    else if N <= 3\n    then\n        return \"111\"\n    else if N <= 5\n\
    \    then\n        return \"1111\"\n    else if N <= 7\n    then\n        return\
    \ \"11111\"\n    else\n        digits(N - 1) // \"1\"\n    end\nend", "    if\
    \ N <= 0\n        return \"0\"\n    \n    if N >= 100\n        return solve(N/10)\
    \ + string(N%10)\n    \n    ans = \"\"\n    \n    if N < 10\n        return f\"\
    0{N}\"\n    \n    for digit in reverse(digits(N))\n        ans += string((N%10)\
    \ * digit)\n        N /= 10\n    return ans\n</code>\nAnd here is my solution:\n\
    <code>", "    \n    if N < 0\n        error(\"N should be positive\")\n    \n\
    \    if N <= 0\n        error(\"N should be positive\")\n    \n    if N == 0 ||\
    \ N == 1\n        return \"0\"\n    \n    ans = \"\"\n    \n    while N > 0\n\
    \        ans = ans * (N mod 2) + N / 2\n        N = N div 2\n    end\n    ans\n\
    end\n</cell>\n<code language=julia-1.5>\nsolve(1000)\n</cell>\n<code language=julia-1.5>\n\
    solve(150)\n</cell>\n<code language=julia-1.5>\nsolve(147)\n</cell>\n<text>\n\
    Question 9\nWrite a function that returns the minimum number of digits that must\
    \ be added to a positive integer A to make A positive without changing the number.\
    \ For example, given A=15, return the value 2.\n \nVariables:\n        @A positive\
    \ integer\n        Constraints: 0 \u2264 A \u2264 10^9.", "    binary = zeros(N,\
    \ 'U64')\n    \n    for i \u2208 1:N\n        binary[i] = '1'\n    end\n    \n\
    \    for i \u2208 2:N\n        binary[i] = \"0\" + binary[i \u2212 1]\n    end\n\
    \    \n    sum = \"\"\n    for i in 1:N\n        sum += binary[i]\n    end\n \
    \   return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solve(4) == \"\
    10001\"\n@assert solve(100) == \"11001\"\n@assert solve(900) == \"101001\"\n@assert\
    \ solve(1000) == \"110001\"\n</cell>\n<text>\nProblem 8\nA company has recently\
    \ bought five unique machines with different prices and different quantities of\
    \ each. \nThe company has a certain amount of money which is divided among each\
    \ machine \nand each machine has a certain number of items which are also unique.\n\
    The company would like to know the total price of each machine bought together.\n\
    What is the total money amount made from these machines? Given the prices of each\
    \ machine and the quantities of each item,\ncalculate the total money made from\
    \ these machines.\nNotes:\nGiven the total prices of each machine, calculate the\
    \ total money made from these machines.\nEach machine has a unique price and quantity\
    \ of items bought together so it is easy to calculate the total price of the machine.\n\
    The total money amount made is equal to the sum of the prices of the machines.\
    \ Each price is separately multiplied by the number of items in the machine. \n\
    The product of the prices of the machines is equal to the sum of all the products\
    \ made from each machine.\nGiven the prices of each machine, calculate the total\
    \ money made from these machines.", "    \n    @N + 1 \n    function binary2str(n::Int64)\n\
    \        sum = 0\n        for i in 1..(n-1)\n            sum = sum + Int(n) %\
    \ 2\n            n = n//2\n        end\n        return String(sum)\n    end",
  "    digits = [0 for _ in 1:N]\n    digits = reverse(digits)\n    \n    sum = 0\n\
    \    for i in digits\n        sum = sum + Int(Int(i) / 2)\n    \n    return String(sum)\n\
    end\n</cell>\n<text>\nProblem 3\nWrite a recursive function called sumDigits that\
    \ takes in a positive integer N, and returns the sum of its digits, i.e., 0 \u2264\
    \ N \u2264 9.\n    \n    Example\n    >>> sumDigits(12)\n    6\n    >>> sumDigits(99)\n\
    \    7\n    >>> sumDigits(444)\n    5\n    >>> sumDigits(153)\n    6\n    >>>\
    \ sumDigits(9)\n    0\n    \n    Variables:\n        @N integer\n            \
    \ Constraints: 0 \u2264 N \u2264 9.\n    Output:\n         an integer with sum\
    \ of all digits in N.\n    \"\"\"", "    \n    digits=\"\"\n    while N>0 do\n\
    \        digits=(digits+[N%10])\n        N=floor(N/10)\n    end\n    \n    return\
    \ digits\nend", "    if N < 0\n    error(\"The parameter of solve must be a positive\
    \ integer\")\n    elseif N == 0\n    error(\"The parameter of solve must be a\
    \ positive integer\")\n    else\n    digits = num2str(N)\n    sum = 0\n    sum\
    \ = 0\n    for digit in digits\n        sum = sum + digit2bin(digit)\n    return\
    \ bin2num(sum)\nend\nsolve(123)\nsolve(125)\nsolve(129)\nsolve(0)\nsolve(1)\n\
    solve(12345)\nsolve(98765)\nsolve(98761)\nsolve(98765)\nsolve(98761)\nsolve(98765)\n\
    solve(98761)\nsolve(98765)\nsolve(98761)\nsolve(98765)\nsolve(98761)\nsolve(98765)\n\
    solve(98761)\nsolve(98765)\nsolve(98761)\nsolve(98765)\nsolve(98761)\nsolve(98765)\n\
    solve(98761)\nsolve(98765)\nsolve(98761)\nsolve(98765)\nsolve(98761)\nsolve(98765)\n\
    solve(98761)\nsolve(98765)\nsolve(98761)\nsolve(98765)\nsolve(98761)\nsolve(98765)\n\
    solve(98761)\nsolve(98765)\nsolve(98761)\nsolve(98765)\nsolve(98761)\nsolve(98765)\n\
    solve(98761)\nsolve(98765)\nsolve(98761)\nsolve(98765)\nsolve(98761)\nsolve(98765)\n\
    solve(98761)\nsolve(98765)\nsolve(98761)\nsolve(98765)\nsolve(98761)\nsolve(98765)\n\
    solve(98761)\nsolve(98765)\nsolve(98761)\nsolve(98765)\nsolve(98761)\nsolve(98765)\n\
    solve(98761)\nsolve(98765)\nsolve(98761)\nsolve(98765)\nsolve(98761)\nsolve(98765)\n\
    solve(98761)\nsolve(98765)\nsolve(98761)\nsolve(98765)\nsolve(98761)\nsolve(98765)\n\
    solve(98761)\nsolve(98765)\nsolve(98761)\nsolve(98765)\n", "  if N < 10\n    return\
    \ N\n  s = \"\"\n  \n  for i in (1..N) do \n    s = s ++ solve(i*10)\n  end",
  "    if N <= 0\n        return \"0\"\n    else\n        return string(N:-1:1) +string(N:1:-1)\
    \ + '0'\n    end\nend\n</cell>\n<code language=julia-1.0>\nsolve(53)\n</cell>\n\
    <text>\n(4.9) Write a function named digitsum that returns N's digit sum in binary.",
  "    if N < 0\n        error(\"N is negative\")\n    end\n    if N <= 0\n      \
    \  return \"0\"\n    end\n    return convert(N)\nend", "    if N<0 \n        error(\"\
    N must be positive\")\n    end"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
