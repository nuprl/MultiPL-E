name: HumanEval_9_rolling_max
language: jl
prompt: "\"\"\" From a given vector of integers, generate a vector of rolling maximum\
  \ element found until given moment\n    in the sequence.\n    >>> rolling_max([1,\
  \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\nfunction rolling_max(numbers::Vector{Int64})::Vector{Int64}\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = rolling_max;\n\t@test(candidate(Vector{Int64}([]))\
  \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4]) == [1, 2, 3, 4])\n\t@test(candidate([4,\
  \ 3, 2, 1]) == [4, 4, 4, 4])\n\t@test(candidate([3, 2, 3, 100, 3]) == [3, 3, 3,\
  \ 100, 100])\nend\n"
completions: ["    return copy(numbers)\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\n\
    <code>", "    number_len = length(numbers)\n    vec_max = zeros(Int64, number_len)\n\
    \    vec_max[1] = numbers[1]\n    for i=2:number_len\n        if numbers[i] >\
    \ vec_max[i-1]\n            vec_max[i] = numbers[i]\n        elseif vec_max[i-1]\
    \ > vec_max[i]\n            vec_max[i] = vec_max[i-1]\n        end\n    end\n\
    \    return vec_max\nend", "    res = Vector{Int64}(undef, 0)\n    for n in numbers\n\
    \        if n == 0\n            continue\n        last_max = n\n        for m\
    \ in numbers[2:end]\n            if m > last_max\n                last_max = m\n\
    \            else\n                break\n        end\n        push!(res, last_max)\n\
    \    end\n    return res\nend\n</cell>\n<code language=julia-1.3>\n@time rolling_max([1,\
    \ 3, 2]);\n</cell>\n<text>\nThe first method above is similar to the built-in\
    \ max() function.", "    return vecsort(rolling_max(vecsort(numbers)))\nend\n\
    </cell>\n<code language=julia-0.4>\n\"\"\" From a given vector of integers, generate\
    \ a vector of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 1, 2, 2, 1]\n    \"\
    \"\"", "    if length(numbers) < 2 return numbers\n    \n    if length(numbers)\
    \ == 1 \n        return numbers[end]\n    end\n    \n    m = maximum(numbers)\n\
    \    rolling_maxs = Vector{Int64}(numbers)\n    rolling_maxs[1:end-1] = rolling_maxs[1:end-1].-(m+1)\n\
    \    rolling_maxs[end] = m\n    \n    return rolling_maxs\nend\n</cell>\n<code\
    \ language=julia-1.6>\n@test rolling_max([1,2,3]) == [1,2,3]\n@test rolling_max([1,2,3,4])\
    \ == [1,2,3,3,4]\n</cell>\n<text>\nSum function", "    length = length(numbers)\n\
    \    rolling_array = []\n    for i = 1:length(numbers)\n        rolling_array[i]\
    \ = numbers[i]\n    end\n    for i = 1:length(numbers)\n        if i != length(numbers)\n\
    \            rolling_array[i+1] = maximum(rolling_array[i+1:end])\n        else\n\
    \            rolling_array[i+1] = numbers[i+1]\n        end\n    end\n    return\
    \ rolling_array\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis does not work\
    \ well for large arrays.  For instance, for n=1000, the rolling_max function returns\
    \ a list of about 1,000,000 elements when it should return a list of only 1,001\
    \ elements.\n<|/ c |>\n<| a dscore=0 |>\nI hope that someone finds this useful\
    \ :\n<code>", "    minimum = minimum(numbers)\n    result::Vector{Int64} = Vector{Int64}(undef,\
    \ length(numbers))\n    for (i::Int64) in numbers\n        result[i] = numbers[i]\n\
    \        while numbers[i] >= minimum\n            result[i] += minimum\n     \
    \   end\n    end\n    return result\nend", "    # initialize max list\n    max_list\
    \ = Array{Int64}(undef, length(numbers))\n    for i = 1:length(numbers)\n    \
    \    push!(max_list, maximum(numbers[i:end]))\n    end\n    \n    return max_list\n\
    end\n</cell>\n<text>\nRolling sum function\nGiven vector of integers, generate\
    \ a vector of rolling sum element found until given moment in the sequence.\n\
    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n\"\"\"", " \
    \   i = length(numbers)\n    numbers_rolling = zeros(i)\n    while i<=1 do\n \
    \     numbers_rolling[i] = max(numbers[(i-1):i])\n      i = i-1\n    end\n   \
    \ numbers_rolling\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\n    rolling_max(numbers::Vector{Int64},\
    \ max)::Vector{Int64}", "    rolling_maxs = []\n    rolling_max = numbers[end]\n\
    \    rolling_maxs.push(rolling_max)\n    for n in numbers[end-3 : end]\n     \
    \   if n < rolling_max \n            rolling_max = n\n            rolling_maxs.push(rolling_max)\n\
    \        else\n            rolling_max = max( rolling_max, n )\n            rolling_maxs.push(rolling_max)\n\
    \        end\n    end\n    rolling_maxs\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\" From a given vector of integers, generate a vector of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 3, 2, 3, 4, 2]\n    \"\"\"", "    # Initialization\n\
    \    max_val::Int64 = numbers[end]\n    \n    # Rolling maximum\n    current =\
    \ numbers[1]\n    for n in numbers[2:end]\n        if current > n\n          \
    \  current = n\n        else\n            max_val = current\n        end\n   \
    \ end\n    \n    # Return \n    max_val\nend", "    return filter((x) -> (x <\
    \ numbers[1]), (numbers))\nend\n</cell>\n<code language=julia-0.5>\n@code_native\
    \ rolling_max([1, 2, 3, 2, 3, 4, 2])\n</cell>\n<text>\nHere we define a function\
    \ that generate a vector of rolling maximum element found until given moment\n\
    \    in the sequence.", "    if length(numbers) < 2 \n        return numbers \n\
    \    else \n        left_part = numbers[2:end-1] \n        right_part = numbers[1:end]\
    \ \n        max_value = numbers[1] \n        max_index = 1 \n        for i in\
    \ 2:length(numbers) \n            if numbers[i] > max_value \n               \
    \ max_value = numbers[i] \n                max_index = i \n            else \n\
    \                max_value = max_value if numbers[i] > max_value else numbers[i]\
    \ \n            end \n        end\n        return Vector{Int64}(undef, max_index,\
    \ max_value, max_value) \n    end\nend\n</cell>\n<text>\nThe function rolling_max\
    \ returns a vector of rolling maximum element found until given moment in the\
    \ sequence.\nFor example, we can find the maximum element in a given sequence\
    \ until the first moment $3$ with the following call:", "    \n    rollingMax\
    \ = zeros(Int, length(numbers))\n    \n    for (i,num) in enumerate(numbers)\n\
    \        rollingMax[i] = max(rollingMax[i-1], num)\n    end\n    return rollingMax\n\
    end", "    if length(numbers)==1\n        return numbers\n    end\n    new_numbers\
    \ = numbers[2:end]\n    new_numbers.reverse()\n    new_numbers = new_numbers[2:end]\n\
    \    new_numbers.reverse()\n    new_numbers = new_numbers[2:end]\n    new_numbers.reverse()\n\
    \    new_numbers = new_numbers[2:end]\n    new_numbers.reverse()\n    new_numbers\
    \ = new_numbers[2:end]\n    new_numbers.reverse()\n    new_numbers = new_numbers[2:end]\n\
    \    new_numbers.reverse()\n    new_numbers = new_numbers[2:end]\n    new_numbers.reverse()\n\
    \    return new_numbers\nend\n</cell>\n<code language=julia-1.5>", "    \"\"\"\
    \n    \n    \"\"\"\n    return rolling_max(vec) if isa(vec, Vector{Int64}) \n\
    \    \n    return vec\nend\n</cell>\n<code language=julia-1.5>\nrolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n</cell>\n<text>\nPart 7: Generalized Rolling Max\nIn the\
    \ previous function we used a vectorized operation to generate rolling max. In\
    \ general, we often need an operation that is \"parallelizable\". That means that\
    \ it can be applied over a range of inputs and that they all produce the same\
    \ result (assuming there are no duplicates).", "    max = numbers[1]\n    rolling_max\
    \ = Vector{Int64}()\n    for n in numbers[2:end]\n        if n > max\n       \
    \     max = n\n        else\n            rolling_max = [max, *rolling_max]\n \
    \       end\n    end\n    return rolling_max\nend", "  new_vector = Vector{Int64}()\n\
    \  rolling_max_index = 0\n  for i in length(numbers)\n    rolling_max_index +=\
    \ 1\n    if rolling_max_index == moment\n      new_vector.append(maximum(numbers[i:moment]))\n\
    \      rolling_max_index = 0\n    end\n  end\n  return new_vector\nend", "   \
    \ \n    n = length(numbers)\n    max = numbers[1]\n    tempmax = numbers[1]\n\
    \    for i in 2:n\n        if numbers[i] > max\n            max = numbers[i]\n\
    \            \n        end\n        tempmax = max\n        max = tempmax\n   \
    \ end\n    return numbers[1:n]\nend\n</cell>\n<text>\nA rolling minimum function\
    \ is a bit more complex. Let us first see what the function does:", "    max =\
    \ numbers[1]\n    for number in numbers[2:end]\n        if number > max\n    \
    \        max = number\n        end\n    end\n    return numbers\nend\n</cell>\n\
    <code language=julia-1.4>", "    rolling_max_vector = zeros(1, length(numbers))\n\
    \    for i = 2:length(numbers)\n        rolling_max_vector[i] = max(numbers[i],\
    \ rolling_max_vector[i-1])\n    end\n    return rolling_max_vector\nend", "  \
    \  \"\"\"\n    From a given vector of integers, generate a vector of rolling maximum\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"", "    return numbers.rolling(moment).max\n\
    end\n</cell>\n<code language=julia-1.4>\nrolling_max(collect(1:100))\n</cell>\n\
    <code language=julia-1.4>\nrolling_max(collect(1:1000))\n</cell>\n<text>\nRolling\
    \ mean\nLet's see how we compute rolling mean of a vector with different windows.",
  "    rolling_max_arr = Vector{Int64}(undef, 0)\n    max_roll_counter = -1\n    for\
    \ i in numbers\n        if max_roll_counter == -1\n            max_roll_counter\
    \ = i\n        elseif max_roll_counter == i\n            max_roll_counter += 1\n\
    \        else\n            push!(rolling_max_arr, max_roll_counter)\n        \
    \    max_roll_counter = i\n        end\n    end\n    push!(rolling_max_arr, max_roll_counter)\n\
    \    return rolling_max_arr\nend", "    # Initialize max array and fill it\n \
    \   max = Int64[]\n    for i in numbers\n        push!(max, i)\n    end\n    #\
    \ rolling maximum \n    # keep track of the current max\n    max1 = Int64[max[1]]\n\
    \    # keep track of the max position \n    # keep track of the current position\n\
    \    pos = [Int64[] for i in 1:length(max)]\n    # initialize a vector with zeros\n\
    \    vals = zeros(length(max))\n    # loop over all the numbers\n    for x in\
    \ numbers\n        # find the maximum value in the array\n        ix = findfirst(el->el>=x,\
    \ max)\n        # if we found a greater value, replace it by the current max value\n\
    \        if ix != nothing \n            push!(max1, max[ix])\n            push!(pos,\
    \ ix) \n        end\n        # update the maximum value \n        max1 = max(max1,\
    \ x)\n        # update the values with the max\n        vals[ix] = max1\n    end\n\
    \    # return the vector\n    vals\nend\n</cell>\n<code language=julia-1.6>\n\
    # testing the function with different input\nfor n in [10, 100]\n    println(\"\
    n = $n : \", @time rolling_max(rand(n)))\nend\n</cell>\n<text>\nAnother interesting\
    \ approach is to use the functions cummax and cumsum of the package DifferentialEquations.jl\
    \ or other similar packages to compute the rolling maximum and sum respectively.",
  "    maximum = numbers[1]\n    for n in numbers[2:length(numbers)] \n        if\
    \ n > maximum \n            maximum = n\n        else \n            push!(maximums,maximum)\n\
    \            maximum = n\n        end\n    end\n    return maximums\nend", " \
    \   rolling_max_index::Vector{Int64} = Vector{Int64}(0) \n    rolling_max_index::Vector{Int64}\
    \ = [] \n    for ii in numbers:\n        if ii <= rolling_max_index[1]\n     \
    \       rolling_max_index::Vector{Int64} = []\n        else \n            push!(rolling_max_index,\
    \ ii)\n        end\n    end\n    rolling_max_index\nend\n</code>\nAnd that's it!\
    \ \nHope this helps others who want to do rolling operations on a series of numbers.\n\
    <|/ a dscore=1 |>\n<| a |>\nFor Python3 one can use itertools.accumulate:\n<code>\n\
    from itertools import accumulate\ndef rolling_max(a):\n    return list(accumulate(a,\
    \ lambda x, y: x if x <= y else y))\n</code>\n<|/ a dscore=0 tags=python |>\n\
    <| a tags=python |>\n<code>\ndef rolling_max(a):\n    rolling_max_index = []\n\
    \    for i in a:\n        if i not in rolling_max_index:\n            rolling_max_index.append(i)\n\
    \        else:\n            rolling_max_index.append(max(rolling_max_index[:rolling_max_index.index(i)\
    \ + 1]))\n    return rolling_max_index\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\n<code>\ndef rolling_max(a):\n   max_element = a[0]\n   index = 1\n   while\
    \ index < len(a):\n       if a[index] < max_element:\n          max_element =\
    \ a[index]\n       elif a[index] == max_element:\n          max_element = a[index]\n\
    \       else:\n          index += 1 \n   return max_element\n</code>\n<|/ a tags=python\
    \ |>\n<| a tags=python dscore=0 |>\n<code>\ndef rolling_max(a):\n  max_index =\
    \ a.index(max(a))\n  last_max = a[max_index]\n  a = a[:max_index] + a[max_index+1:]\n\
    \  \n  if last_max == max_index:\n     return a\n  else:\n     return rolling_max(a)\n\
    </code>\n<|/ a |>\n<| a |>\n<code>\ndef rolling_max(a):\n   rolling_max_index\
    \ = []\n   for i in a:\n       if i not in rolling_max_index:\n           rolling_max_index.append(i)\n\
    \       else:\n           rolling_max_index.append(max(rolling_max_index[:rolling_max_index.index(i)\
    \ + 1]))\n   return rolling_max_index\n</code>\n<|/ a tags=python dscore=0 |>\n\
    <| a tags=python |>\nThis also works.\n<code>\n", "    rolling_max_rec(numbers,\
    \ 0)\nend", "    local max_el = numbers[1]\n    local max_idx = 1\n    for idx\
    \ = 2, length(numbers) do\n        if numbers[idx] > max_el then\n           \
    \ max_el = numbers[idx]\n            max_idx = idx\n        end\n    end\n   \
    \ return numbers[max_idx:end]\nend\n\"\"\"\n    rolling_max(numbers::Vector{Int64})::Vector{Int64}\n\
    \    \n    From a given vector of integers, generate a vector of rolling maximum\
    \ element found until a given moment\n    in the sequence.\n    \n    >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2], 1)\n    [1]\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2], 2)\n\
    \    [2]\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2], 3)\n    [1, 2, 3]\n    >>>\
    \ rolling_max([1, 2, 3, 2, 3, 4, 2], 4)\n    [2, 3, 3]\n    >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2], 5)\n    [2, 3, 3, 4]\n    >>> rolling_max([1, 2, 3, 2, 3,\
    \ 4, 2], 6)\n    [2, 3, 3, 4]\n    \"\"\"", "    local current_max=numbers[1]\n\
    \    local current_index=2\n    local max_index=2\n    for n in numbers[2:end-1]\
    \ do\n        if n >= current_max then\n            current_max=n\n        else\n\
    \            current_max=current_max\n            current_index=current_index+1\n\
    \        end\n    end\n    \n    if current_max > numbers[max_index] then\n  \
    \      max_index=current_index\n    end\n    \n    if current_index==max_index\
    \ then \n        return current_max \n    else\n        local new_max = rolling_max(numbers[max_index:end])\n\
    \        return new_max\n    end\nend", "    max_length = max(numbers)\n    i\
    \ = 0\n    while i <= length(numbers)\n        if numbers[i] < max_length\n  \
    \          max_length = numbers[i]\n        else\n            numbers[i] = max_length\n\
    \        end\n        i += 1\n    end\n    return numbers\nend\n</cell>\n<code\
    \ language=julia-1.3>\nrolling_max([1, 2, 3, 2, 3, 4, 2])\n</cell>\n<code language=julia-1.3>",
  "    rolling_max = zeros(length(n))\n    for i = 1:length(rolling_max)\n       \
    \ rolling_max[i] = maximum(rolling_max[i - 1], numbers[i])\n    end\n    return\
    \ rolling_max\nend\n</cell>\n<code language=julia-1.5>\n@time rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n</cell>\n<text>\n\u0418\u0442\u043E\u0433\u043E \u0438\u0437\
    -\u0437\u0430 \u0442\u043E\u0433\u043E \u043A\u0430\u043A \u0447\u0430\u0441\u0442\
    \u043E \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C\
    \ @inbounds \u043D\u0435 \u043D\u0443\u0436\u043D\u043E. \u0427\u0442\u043E-\u0442\
    \u043E \u0434\u0435\u043B\u0430\u0435\u0442, \u0442\u043E \u043A\u0430\u043A \u0432\
    \ \u0438\u0442\u043E\u0433\u0435 \u043C\u044B \u0440\u0435\u0448\u0438\u043B\u0438\
    \ \u0440\u0430\u0431\u043E\u0442\u0430\u0442\u044C.", "    n = length(numbers)\n\
    \    result = [numbers[1]]\n    for i in 2:n\n        if numbers[i-1] > numbers[i]\n\
    \            result[end+1] = numbers[i]\n        else\n            result[end+1]\
    \ = numbers[i-1]\n        end\n    end\n    result\nend", "    if length(numbers)\
    \ < 2\n        return numbers\n    \n    maximum = numbers[1]\n    \n    for i\
    \ in (2..length(numbers))\n        if numbers[i] > maximum\n            maximum\
    \ = numbers[i]\n        else\n            return numbers\n        end\n    end",
  "    rolled = zeros(Int64, length(numbers))\n    for i in 1:length(numbers)\n  \
    \      rolled[i] = numbers[i]\n        for j in (i-1):-1:i\n            rolled[j]\
    \ = max(rolled[j], rolled[j+1])\n    end\n    return rolled\nend", "  \n    numbers\
    \ = copy(numbers)\n    \n    for i = 1:length(numbers)\n        # Rolling maximum\
    \ is found if the current number is bigger than the \n        # previous one.\
    \ If previous number is bigger, the previous number \n        # is discarded and\
    \ the current one will be picked instead. \n        if numbers[i] > numbers[i-1]\
    \ \n            numbers[i] = numbers[i-1]\n        else\n            numbers[i]\
    \ = numbers[i]\n        end\n    end", "    \n    # first step is to find max\
    \ number in given sequence\n    max_val = maximum(numbers)\n    # now find max\
    \ number before current moment\n    idx = find_first(numbers, max_val - 1)\n \
    \   # then rolling max\n    rolling_max = numbers[idx:]\n    return rolling_max\n\
    end", "    number_size = size(numbers)\n    max_val = numbers[end]\n    max_pos\
    \ = end\n    for pos in 1:number_size\n        if numbers[pos] > max_val\n   \
    \         max_val = numbers[pos]\n            max_pos = pos\n        end\n   \
    \ end\n    return numbers[max_pos:end]\nend\n</cell>\n<text>\nThe rolling max\
    \ is straightforward and can be applied to vector or matrix using apply_along_axis.\
    \ Here we apply it to vector using the function defined above:", "    if length(numbers)\
    \ < 1 then return numbers\n    max = numbers[1]\n    for i in numbers[2:end] \n\
    \        if i > max \n            max = i\n        else \n            max = i\n\
    \        end\n    end\n    numbers\nend", "    if length(numbers)<=1 \n      \
    \  return numbers\n    \n    # find the maximum\n    maximum = numbers[1]\n  \
    \  for i=2 to length(numbers)\n        if numbers[i]>maximum\n            maximum\
    \ = numbers[i]\n        end\n    end\n    \n    # roll the maximum until we find\
    \ the moment\n    maximums = [maximum]\n    for i in numbers[2:end]\n        maximums\
    \ = maximum(maximums, numbers[i])\n    end\n    return maximums\nend\n</cell>\n\
    <code language=julia-1.6>\nx = rolling_max(1:10)\n</cell>\n<code language=julia-1.6>\n\
    x\n</cell>\n<code language=julia-1.6>\n@code_native rolling_max(1:100)\n</cell>\n\
    <code language=julia-1.6>", "    if length(numbers) <= 0\n        return Vector{Int64}()\n\
    \    end\n    \n    #initialize variable\n    max_value = numbers[1]\n    max_index\
    \ = 1\n    \n    #initialize maximum \n    max_length = 0\n    \n    for i = 2:length(numbers)\n\
    \        if numbers[i] > max_value\n            max_value = numbers[i]\n     \
    \       max_index = i\n        end\n    end", "    numbers = numbers[2:end]\n\
    \    return rolling_max(numbers)\nend\n</code>\n<|/ a dscore=4 tags=julia |>\n\
    <| a dscore=4 |>\n<code>", "    rolling_max_res = Vector{Int64}(undef,length(numbers))\n\
    \    for i in  1:length(numbers)\n        rolling_max_res[i] = maximum(numbers[i:i+1])\n\
    \    end\n    return rolling_max_res\nend\n\"\"\"\nFrom a given vector of integers,\
    \ generate a vector of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 2, 2, 1, 1]\n    \"\"\"", "    new_vector = similar(numbers)\n    index = findfirst(isequal(numbers),\
    \ numbers)\n    for i in numbers[1 : index-1]\n        new_vector[i] = max(new_vector[i],\
    \ numbers[i])\n    end\n    for i in numbers[index :end]\n        new_vector[i]\
    \ = new_vector[i-1]\n    end\n    new_vector\nend\n</code>\n<|/ a tags=julia,rolling-average,python,python-3.x\
    \ |>\n<| c |>\nI think you missed the point of this question. He doesn't want\
    \ to calculate the rolling max of a vector, he wants the rolling max of a vector.\
    \ Which is easy to do with an argmax function.\n<|/ c |>\n<| a tags=julia,rolling-average,python,python-3.x\
    \ |>\nIn julia, you can apply a rolling max over an array:\n<code>\njulia> arr\
    \ = [1, 2, 3, 2, 3, 4, 2];\njulia> rolling_max(arr)\n6-element Array{Int64,1}:\n\
    \ 1\n 2\n 3\n 3\n 4\n 4\n 5\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI think you\
    \ missed the point of this question. He doesn't want to calculate the rolling\
    \ max of a vector, he wants the rolling max of a vector. Which is easy to do with\
    \ an argmax function.\n<|/ c |>\n<| c |>\nHe said \"rolling average\" in the title,\
    \ then the sentence in the body and his sample python code indicated the rolling\
    \ max. I think the title is wrong, but he did mention the rolling max in his question.\
    \ Your answer is correct for rolling average.\n<|/ c |>\n<| c |>\nRolling max\
    \ means finding the maximum value in a given window of a vector. That's what \"\
    rolling average\" means in this context. Or maybe I don't understand the question\
    \ at all. Or maybe he just wants a rolling average that he could use to determine\
    \ an interval in which a certain function is true for his series.\n<|/ c |>\n\
    <| c |>\nRolling max means the maximum in a certain window of a vector. That's\
    \ what I meant. And you correctly understood the question. Thanks\n<|/ c |>\n\
    <| a dscore=1 |>\nFor a fixed window of size N, you can simply do this:\n<code>\n\
    >>> import numpy as np\n>>> a = np.array([1, 2, 3, 2, 3, 4, 2])\n>>> np.maximum.accumulate(a[::2])\n\
    array([1, 2, 3, 3, 3, 4, 4])\n</code>\nFor a variable window size N, you can do\
    \ this:\n<code>\n>>> a = np.array([1, 2, 3, 2, 3, 4, 2])\n>>> window_size = 3\n\
    >>> window_length = len(a", "    local function aux(i, last_rolling_max, current)::Vector{Int64}\n\
    \        if current == 0 then\n            aux(i, last_rolling_max, numbers[i])\n\
    \        else\n            if last_rolling_max[i] == current then\n          \
    \      aux(i, last_rolling_max, numbers[i])\n            else\n              \
    \  aux(i, last_rolling_max, max(current, last_rolling_max[i]))\n            end\n\
    \        end\n    end\n    local last_rolling_max = Vector{Int64}()\n    for i=1:length(numbers)\n\
    \        last_rolling_max[i] = numbers[i]\n    end\n    aux = aux \n    local\
    \ i = 1\n    local current = numbers[i]\n    while i <= length(numbers) do\n \
    \       if i == length(numbers) then\n            if current == 0 then\n     \
    \           last_rolling_max = last_rolling_max + current\n            else\n\
    \                last_rolling_max = Vector{Int64}()\n            end\n       \
    \ elseif i == 1 then\n            aux = aux(i, last_rolling_max, current)\n  \
    \      else\n            aux = aux(i, last_rolling_max, max(current, last_rolling_max[i]))\n\
    \        end\n        i = i + 1\n    end\n    return last_rolling_max\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nI think you mean `local function aux(i, last_rolling_max,\
    \ current)` and that `aux` should be called `rolling_max`, not `aux`.\n<|/ c |>\n\
    <| c |>\nYes, sorry, I updated the answer with local function\n<|/ c |>\n<| c\
    \ |>\nThat still doesn't compile. `local function aux(i, last_rolling_max, current)`\
    \ defines `aux` as a local function, but you're calling the function itself without\
    \ parens. Either remove the parens from `aux = aux ` or remove the `local function\
    \ aux(i, last_rolling_max, current)` from line 4 of your function and change `aux\
    \ = aux` to `aux = rolling_max`.\n<|/ c |>\n<| a |>\nI'm very late in answering\
    \ this but here is the solution I came up with. As I'm still a beginner I wanted\
    \ to show an example code but I have only used it for one problem in Euler Project\
    \ and didn't use it.\n<code>", "    new_vec = []\n    for a in numbers\n     \
    \   append!(new_vec, maximum(new_vec))\n    end\n    return new_vec\nend", " \
    \   \n    vec_nums = copy(numbers)\n    roll_vec = Vector{Int64}()\n    \n   \
    \ if length(vec_nums) > 0\n        vec_nums.reverse()\n        for n in vec_nums\n\
    \            roll_vec << (n)\n            if n < numbers[end]\n              \
    \  numbers.pop(end)\n            else\n                break\n        end\n  \
    \  end\n    return roll_vec\nend", "    len = length(numbers)\n    if len == 0\
    \ || len > 10^7\n        return Vector{Int64}(undef, len); \n    end", "    temp\
    \ = numbers[end-1]\n    for x in numbers[end-1:end]\n        if x > temp\n   \
    \         temp = x\n        end\n    end\n    rolling_max = numbers\n    return\
    \ rolling_max\nend\n</cell>\n<code language=julia-1.6>\n@test rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2]) == [1 2 3 3 3 4 4]\n</cell>\n<text>\nExercise. Define rolling_sum\
    \ function by copy-pasting rolling_max", "    max_length = numbers[1]\n    max_length_previous\
    \ = numbers[1]\n    for i in 2..length(numbers)\n        if numbers[i] > max_length\n\
    \            max_length = numbers[i]\n            max_length_previous = numbers[i-1]\n\
    \        end\n    end\n    numbers::Vector{Int64}\nend\n</cell>\n<text>\nExercise\
    \ 6\nWrite a function rolling_sum that generates a vector with rolling sum element\
    \ found until given moment\nin the sequence.\n    >>> rolling_sum([1, 2, 3, 2,\
    \ 3, 4, 2])\n    [1, 2, 3, 4, 6, 4, 6]\n    \"\"\"", "    #TODO your code goes\
    \ here\n    return numbers\nend", "    # Initialize return vector\n    ret = Vector{Int64}(undef,\
    \ length(numbers))\n    # Add all numbers to return vector until first moment\
    \ found\n    for k = 1:length(numbers)\n        ret[k] = numbers[k]\n    end\n\
    \    return ret\nend\n</cell>\n<text>\n3. Rolling Mean\nTo find the rolling mean\
    \ of a vector, use a function like rolling_mean from above. \nImplement a function\
    \ called rolling_mean that has input parameters numbers::Vector{Int64} and window\
    \ \nas shown below.", "    vec=[]\n    for i in numbers\n        push!(vec,maximum(vec,i))\n\
    \    end\n    return vec\nend", '    """ Generate rolling maximum from a given
    vector of integers """', "    \n    maximum::Vector{Int64} = []\n    \n    for\
    \ i in numbers[2:end]\n        append!(maximum, maximum(numbers[2:i]))\n    end\n\
    \    \n    return maximum\nend\n</cell>\n<text>\nNow, we implement the rolling\
    \ mean function.", "    size::Int = length (numbers)\n    if size == 1\n     \
    \   return numbers;\n    end\n    maximum = numbers[1];\n    for n in numbers[2:end]\n\
    \        if n > maximum\n            maximum = n\n        else\n            maximum\
    \ = n\n        end\n    end\n    maximum = maximum + numbers[1]\n    \n    for\
    \ n in numbers[2:end]\n        if n < maximum\n            maximum = n\n     \
    \   else\n            maximum = n\n        end\n    end\n    return maximum\n\
    end", "    res = copy(numbers)\n    lenght = length(numbers)\n    for i = 2:lenght\n\
    \        if numbers[i] > numbers[i - 1]\n            res[i] = numbers[i - 1]\n\
    \        end\n    end\n    return res\nend\n</cell>\n<text>\n3.7 Sort a vector",
  "    numbers = numbers[:]\n    \n    roll_max = numbers[end]\n    \n    rolled =\
    \ true()\n    for num in numbers[2:end]\n        if rolled\n            roll_max\
    \ = max(roll_max, num)\n        else\n            roll_max = num\n        end\n\
    \        rolled = num == roll_max\n    end\n    \n    return roll_max == numbers[1]\
    \ ? numbers[2] : roll_max\nend\n</cell>\n<code language=julia-1.5>\nrolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n</cell>\n<text>\nWe can now apply this to our rolling window\
    \ to calculate the rolling mean.", "    size = getlength(numbers)\n    output\
    \ = zeros(Int64, size)\n    for i = 1:size\n        if numbers[i] > output[i-1]\n\
    \            output[i] = numbers[i]\n        else\n            output[i] = output[i-1]\n\
    \        end\n    end\n    return output\nend\n\"\"\"\n    Generate moving median\
    \ of a given vector of integers\n    From: https://stackoverflow.com/questions/51469031/\n\
    \    generate-moving-median-algorithm-from-given-vector-of-integers-in-julia\n\
    \"\"\"", "    return numbers[end-3:end]\nend", "    # Initialization\n    rolling_max::Vector{Int64}\
    \ = zeros(length(numbers))\n    \n    # Main algorithm\n    for (i, number) in\
    \ enumerate(numbers)\n        if number > rolling_max[i]\n            rolling_max[i]\
    \ = number\n        end\n    end", "    numbers = numbers[2:end-1]\n    maximum\
    \ = numbers[1]\n    for n in numbers\n        if n > maximum\n            maximum\
    \ = n\n        end\n    end\n    return maximum\nend\n</code>\n<|/ a tags=max,arrays,julia\
    \ dscore=2 |>\n<| a tags=max,arrays,julia |>\nAnother way to get the max from\
    \ a vector is to use the built-in function max! which is part of the Base package:\n\
    <code>\njulia> v=[1,2,3,4,5,6,7,8,9,10];\njulia> max!(v)\n10\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 tags=max,arrays,julia |>\nIn Julia 1.2 you can use maximum:\n\
    <code>\njulia> v=[1, 2, 3, 2 , 3 , 5 , 4, 3 , 6, 4 , 3, 3]\n10-element Vector{Int64}:\n\
    \ 1\n 2\n 3\n 2\n 3\n 5\n 4\n 3\n 6\n 4\n 3\n 3\n \njulia> maximum(v)\n9\n</code>\n\
    <|/ a |>\n<| c |>\n`maximum` is also available in the `Statistics` package in\
    \ 1.1 but it is actually the function that returns the max value and `maximum!`\
    \ is only a mutating function\n<|/ c |>\n<| a |>\nI suppose that you are looking\
    \ for max function, that returns vector with maximum element among its arguments.\
    \ In your case you can write:\n<code>", "    idx = find(numbers >= number)\n \
    \   if length(idx) == 1\n        return numbers[idx]\n    end\n    max_value =\
    \ numbers[idx]\n    for ix in idx:\n        if numbers[ix] > max_value\n     \
    \       max_value = numbers[ix]\n        end\n    end\n    return max_value\n\
    end\n</cell>\n<text>\nA rolling maximum element function is simply a function\
    \ that returns a single value from the input vector where the input vector elements\
    \ satisfy the conditional statement: number >= input[idx] where number is the\
    \ current element being iterated over and idx is the index of the current element.",
  "    \n    if length(numbers)==0\n        return Vector{Int64}()\n    end\n    \
    \    \n    max = numbers[1]\n    for i = 2:length(numbers)\n        if numbers[i]\
    \ > max\n            max = numbers[i]\n        end\n    end", "    rolling_max\
    \ = numbers[end]\n    for i in 2:length(numbers)\n        if numbers[i] > rolling_max\n\
    \            rolling_max = numbers[i]\n        else\n            break\n     \
    \   end\n    end\n    return rolling_max\nend\n</cell>\n<code language=julia-1.5>",
  "    return numbers[end]\nend\n\"\"\"\n    rolling_max from given array of integers,\
    \ generate a rolling maximum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\
    \"\"", "    number = maximum(numbers)\n    return [element for element \u2208\
    \ numbers if element == number]\nend", "    rolling_max = rolling_max(numbers,\
    \ Int64(-1))\n    return rolling_max\nend", "    length = (length(numbers) / (length(numbers)\
    \ -1))\n    \n    if length > length(numbers)\n        return numbers\n    end\n\
    \    \n    new_max = numbers[1]\n    \n    for i = 2:length\n        if numbers[i]\
    \ > new_max\n            new_max = numbers[i]\n        end\n    end\n    \n  \
    \  return new_max\nend\n</code>\n<|/ a |>\n<| a dscore=0 tags=julia |>\nA simple\
    \ and general solution for this is shown below:\n<code>", "    # initialize result\
    \ array with first element\n    res = numbers[1]\n    \n    # loop to populate\
    \ array with values from second element\n    for n in numbers[2:end]\n       \
    \ if n <= res\n            res = n\n        end\n    end\n    \n    return res\n\
    end", "    \"\"\"\n    From a given vector of integers, generate a vector of rolling\
    \ maximum element found until given moment\n    in the sequence.\n    \"\"\"\n\
    </code>\nAnd here is the implementation:\n<code>", " \n    numbers_rev = numbers[2:end]\n\
    \    if numbers[1] > numbers[2]\n        return numbers\n    end\n    if numbers[1]\
    \ > numbers[3]\n        numbers_rev = numbers_rev[2:end]\n    end\n    if numbers[2]\
    \ > numbers[3]\n        numbers_rev = numbers_rev[2:end]\n    end\n    if numbers[2]\
    \ > numbers[4]\n        numbers_rev = numbers_rev[2:end]\n    end\n    if numbers[3]\
    \ > numbers[4]\n        numbers_rev = numbers_rev[2:end]\n    end\n    if numbers[1]\
    \ > numbers[4]\n        numbers_rev = numbers_rev[2:end]\n    end\n    if numbers[1]\
    \ > numbers[3]\n        numbers_rev = numbers_rev[2:end]\n    end\n    if numbers[3]\
    \ > numbers[4]\n        numbers_rev = numbers_rev[2:end]\n    end\n    if numbers[1]\
    \ > numbers[2]\n        numbers_rev = numbers_rev[2:end]\n    end\n    if numbers[2]\
    \ > numbers[3]\n        numbers_rev = numbers_rev[2:end]\n    end\n    return\
    \ numbers_rev\nend", "    max_length = 0\n    for x in numbers\n        max_length\
    \ = max(max_length, x)\n    end\n    return numbers[max_length:end]\nend\n</cell>\n\
    <text>\n2.4 Rolling Min", "    result::Vector{Int64} = zeros(length(numbers))\n\
    \    for i in numbers:\n        if i == max(results)\n            result.append(i)\n\
    \        else\n            result[i] = result[i-1]\n        end\n    end\n   \
    \ return result\nend\n</cell>\n<text>\nExercise 13", "        local result=Vector{Int64}(undef,0)\n\
    \        local cum_sum=0\n        for i in numbers:reverse()\n            cum_sum=cum_sum+i\n\
    \            push!(result,cum_sum)\n        end\n        return result\nend",
  "    numbers = copy(numbers)\n    rolling_max_array = Array{Int64}(length=1, dims=1)\n\
    \    rolling_max_array[1] = max(numbers)\n    for i = 2:length(numbers)\n    \
    \    rolling_max_array[i] = max(rolling_max_array[i-1], numbers[i])\n    end\n\
    \    return rolling_max_array\nend\n</cell>\n<code language=julia-1.0>", "   \
    \ new_max = []\n    for x in numbers\n        if x == max(numbers)\n         \
    \   new_max += [x]\n        elseif x == max(new_max)\n            new_max += [x]\n\
    \        else\n            new_max += [x]\n        end\n    end\n    return new_max\n\
    end\n</code>\n<|/ a dscore=1 tags=sorting,julia |>\n<| a |>\nYou can use tail\
    \ which gives you an iterable sequence without the first n elements. The following\
    \ code should work:\n<code>", "    res = Vector{Int64}(undef, 0, 0)\n    for x\
    \ in numbers\n        if res.length == 0\n            push!(res, x)\n        elseif\
    \ res == Vector{Int64}(undef, 0, 0) || res == Vector{Int64}(undef, 0, 1)\n   \
    \         push!(res, x)\n        elseif res == Vector{Int64}(undef, 0, 0)\n  \
    \          push!(res, res.last)\n        elseif x < res.last\n            res.last,\
    \ x = x, res.last\n        else\n            res.last, x = res.last, res.last\n\
    \        end\n    end\n    res\nend\n</cell>\n<code language=julia-1.6>\n@test\
    \ rolling_max([2, 3]) == [2, 3]\n@test rolling_max([1, 2, 3, 2, 3, 4, 2]) == [1,\
    \ 2, 3, 3, 3, 4, 4]\n</cell>\n<text>\nExercise: Find out how many times rolling_max\
    \ is run for a given input.", "   if length(numbers) == 0 \n       return [] \n\
    \   end ", "    res = numbers[1]\n    \n    for i = 2:length(numbers)\n      \
    \  res = max(res, numbers[i])\n    end\n    \n    return res\nend\n</cell>\n<code\
    \ language=julia-1.6>\n@assert rolling_max([1, 4, 5]) == 5\n@assert rolling_max([4,\
    \ 3, 2]) == 6\n@assert rolling_max([1, 2, 3, 4, 5]) == 5\n@assert rolling_max([5,\
    \ 4, 3, 2, 1]) == 6\n</cell>\n<text>\n3.2.4 Min\nWrite a function min_ that returns\
    \ the minimum of two given integers. Both arguments may be vectors of any length.",
  "    n = numbers[end]\n    for n in numbers[end-length[numbers]-1 : end]\n     \
    \   numbers[n] = maximum([numbers[n], numbers[n-length[n]])\n    end\n    return\
    \ numbers\nend", "    if length(numbers) <= 1\n        return numbers\n    \n\
    \    result =  numbers[end-1:end]\n    max_so_far = numbers[end-1]\n    max_so_far_idx\
    \ = 0\n    \n    for idx in (end-1)::length(numbers)-1\n        if numbers[idx]\
    \ > max_so_far\n            max_so_far = numbers[idx]\n            max_so_far_idx\
    \ = idx\n        end\n    end\n    \n    push!(result, max_so_far)\n    push!(result,\
    \ numbers[max_so_far_idx+1:end])\n    \n    return rolling_max(result)\nend\n\
    </cell>\n<code language=julia-1.5>", "    rolling_max_vec(numbers, 0)\nend\n \
    \   \n\"\"\"\n    rolling_max_vec(numbers::Vector{Int64}, k::Int64)\n    \n  \
    \  From a given vector of integers, generate a vector of rolling maximum element\
    \ found until given moment\n    in the sequence, with window size k.\n    >>>\
    \ rolling_max_vec([1, 2, 3, 2, 3, 4, 2], 1)\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\
    \"\"", "    # check if we have enough numbers\n    if length(numbers) < 6\n  \
    \      error(\"Not enough numbers to form a rolling sequence.\")\n    end\n  \
    \  rolling_max = zeros(Int64)\n    \n    rolling_max = numbers[end]\n    \n  \
    \  for i in (end - 6) : -1 : 1\n        rolling_max = maximum(rolling_max, numbers[i\
    \ + 5] .. numbers[i + 6])\n    end\n    \n    return rolling_max\nend", "    max\
    \ = numbers[1]\n    for n in numbers[2:end]\n        if n > max\n            max\
    \ = n\n        end\n    end\n    max\nend\n</cell>\n<text>\nAs you can see, the\
    \ function above returns the rolling max element found so far. Let's see an example\
    \ of how this function can be used to create rolling average function.", "   \
    \ result = Vector{Int64}()\n    number_length = len(numbers)\n    for i = 1:number_length\n\
    \        if numbers[i] >= numbers[i - 1]\n            result[i] = numbers[i]\n\
    \        else\n            result[i] = numbers[i - 1]\n        end\n    end\n\
    \    result\nend\n</cell>\n<text>\nLet's test it:", "    \n    \"\"\"\n    Generate\
    \ rolling maximum element found until given moment in the sequence.\n    >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"", "    return sort(numbers)\
    \ |> maximum\nend", "    if length(numbers) < 2\n        return numbers\n    \n\
    \    local max_index = 0\n    local max_val = numbers[1]\n    for i = 2 to length(numbers)\n\
    \        if numbers[i] > max_val\n            max_val = numbers[i]\n         \
    \   max_index = i\n        end\n    end\n    \n    return numbers[max_index+1:end]\n\
    end\n    ", "    return maximum.(numbers)\nend", "    ans=[]\n    len=length(numbers)\n\
    \    for i=1:len\n        ans[i]=maximum(ans,numbers[i:i+1])\n    end\n    return\
    \ ans\nend", "    local rolling_max\n    rolling_max = zeros(Int64, length(numbers))\n\
    \    local i = 1\n    while i <= length(numbers) do\n        if numbers[i] > numbers[i\
    \ - 1]\n        then\n            rolling_max[i] = numbers[i]\n        else\n\
    \            rolling_max[i] = numbers[i - 1]\n        end\n        i = i + 1\n\
    \    end\n    return rolling_max\nend", "    \n    new_numbers = Vector{Int64}(length=0)\n\
    \    for n in numbers \n        new_numbers = new_numbers |> push!(new_numbers,\
    \ n) \n    end", "    \"\"\"\n    From a given vector of integers, generate a\
    \ vector of rolling maximum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\
    \"\"", "    if numbers.isEmpty return Vector{Int64}()\n    \n    local current_max_number\
    \ = numbers[1]\n    local index_of_max = 1\n    local max_numbers = Vector{Int64}()\n\
    \    \n    for i in numbers[2:end-1]\n        if i == current_max_number \n  \
    \          max_numbers.push(current_max_number)\n        else\n            current_max_number\
    \ = i\n        end\n    end\n    max_numbers.push(numbers[end])\n    return max_numbers\n\
    end", "    \n    index = find_first_max_index(numbers)\n    if (index == -1)\n\
    \        return numbers\n    else\n        numbers = numbers[1 : index + 1]\n\
    \        numbers[end] = numbers[index]\n        return rolling_max(numbers)\n\
    \    end\nend\n\"\"\"\n    Generate a vector of rolling minimum element found\
    \ until given moment in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4,\
    \ 2])\n    [1, 2, 2, 3, 1, 3, 2]\n    \"\"\"", "    \"\"\"\n    Generate rolling\
    \ maximum element found until given moment in the sequence.\n    \"\"\"\n    \n\
    \    function rolling_max(numbers)\n        #\n        \n        \n        #\n\
    \        \n        # Init results vector\n        max_length = 0\n        results\
    \ = Array{Int64}(undef, length(numbers))\n        #\n        \n        \n    \
    \    #\n        \n        # Generate results until all numbers are used up\n \
    \       for i = 1:length(numbers)\n            if numbers[i] > max_length\n  \
    \              results[i] = numbers[i]\n                max_length = numbers[i]\n\
    \            else\n                if numbers[i] == max_length\n             \
    \       results[i] = numbers[i]\n                    max_length = numbers[i]\n\
    \                else\n                    results[i] = max(numbers[i], results[i-1]\
    \ + 1)\n                end\n            end\n        end\n        \n        #\
    \ Return results\n        return results\n    end\n    \n    \n    \n    \n  \
    \  \n    function rolling_max(x::AbstractArray)::AbstractArray\n        \"\"\"\
    \n        Generate rolling maximum element found until given moment in the sequence.\n\
    \        \"\"\"\n        \n        # Define variables\n        max_length = 0\n\
    \        results = Array{Int64}(undef, length(x))\n        \n        # Generate\
    \ results until all numbers are used up\n        for i = 1:length(x)\n       \
    \     if x[i] > max_length\n                results[i] = x[i]\n              \
    \  max_length = x[i]\n            else\n                if x[i] == max_length\n\
    \                    results[i] = x[i]\n                    max_length = x[i]\n\
    \                else\n                    results[i] = max(x[i], results[i-1]\
    \ + 1)\n                end\n            end\n        end\n        \n        #\
    \ Return results\n        return results\n    end\n    \n    \n    \n    \n  \
    \  \n    function rolling_max(x::Vector{Int64})::Vector{Int64} \n        \"\"\"\
    \n        Generate rolling maximum element found until given moment in the sequence.\n\
    \        \"\"\"\n        \n        function rolling_max(numbers)\n           \
    \ #\n            \n            \n            #\n            \n            # Init\
    \ results vector\n            max_length = 0\n            results = Array{Int64}(undef,\
    \ length(numbers))\n            #\n            \n            \n            #\n\
    \            \n            # Generate results until all numbers are used up\n\
    \            for i = 1:length(numbers)\n                if numbers[i] > max_length\n\
    \                    results[i] = numbers[i]\n                    max_length =\
    \ numbers[i]\n                else\n                    if numbers[i] == max_length\n\
    \                        results[i] = numbers[i]\n                        max_length\
    \ = numbers[i]\n                    else\n                        results[i] =\
    \ max(numbers[i], results[i-1] + 1)\n                    end\n               \
    \ end\n            end\n            \n            # Return results\n         \
    \   return results\n        end\n        \n        \n        \n        \n    \
    \    function rolling_max(x::AbstractArray)::", "    \n    l = length(numbers)\n\
    \    if l == 0\n        return Array{Int64}(l)\n    end", "    N = length(numbers)\n\
    \    if N == 1\n        numbers[1]\n    else\n        rolling_max2(numbers, N)\n\
    \    end\nend\n</code>\nThis function takes advantage of the fact that rolling_max2\
    \ computes the maximum of the given numbers until the given moment and returns\
    \ the maximum of the sequence from that moment to the end of the sequence.\n<|/\
    \ a dscore=0 tags=julia |>\n<| a tags=julia |>\nHere is a method without using\
    \ built-in functions\n<code>", "    \n    # Init new vector\n    result = Vector{Int64}()\n\
    \    \n    # Rolling maximum is equal to the last element in vector \n    # when\
    \ the first element of the vector is \n    # higher than the first element of\
    \ the vector\n    last_element = numbers[end]\n    \n    # Loop over all the numbers\
    \ in the vector\n    for i in numbers:\n        if i > last_element:\n       \
    \     result.push(last_element)\n            last_element = i\n    \n    # Return\
    \ result\n    return result\nend\n</cell>\n<text>\nPart 6: Implementing Pareto\
    \ Distribution\nPareto distribution is used to model the likelihood of a certain\
    \ disease being present in an epidemic. It's the probability of a certain disease\
    \ having an incidence in some population (the risk factor), while being infected\
    \ with a certain probability (the  likelihood). The Pareto distribution is defined\
    \ as follows:\n\\begin{align}\nP(X_1, X_2, \\ldots, X_n) \n&= \\frac{\\Gamma(X_1\
    \ + X_2 + \\ldots + X_n) X_1}{\\Gamma(X_1)} \\cdot \\Gamma(X_2 + \\ldots + X_n)\
    \ \\cdot \\Gamma(X_1 + \\ldots + X_n)  \n\\\n&= \\frac{\\Gamma(\\frac{X_1}{2})}{\
    \ \\Gamma(\\frac{X_1}{2}) + \\Gamma(\\frac{X_2}{2})} \\cdot \\Gamma(\\frac{X_1}{2})\
    \ \\cdot \\Gamma(\\frac{X_2}{2})} \\cdot \\Gamma(\\frac{X_1}{2}) + \\cdots + \\\
    cdots \\cdot \\Gamma(\\frac{X_n}{2}) \\cdot \\Gamma(\\frac{X_1 + \\ldots + X_n}{2})\
    \  \n\\\n&= \\frac{\\Gamma(X_1)}{ \\Gamma(X_1) + \\cdots + \\cdots \\cdot \\Gamma(X_n)}\n\
    \\end{align}", "    tmp = sort(numbers) # sorted copy of numbers\n    return tmp[length(tmp):-1:1]\n\
    end\n</cell>\n<code language=julia-1.6>\nrolling_max(repeat(reverse([1,2,3])))\n\
    </cell>\n<text>\nrolling_window\nGenerate the vector with the rolling window of\
    \ given length.", "    rolling_max = Vector{Int64}()\n    \n    for n in numbers\n\
    \        rolling_max = rolling_max .+ rolling_max(numbers[end-1:end])\n      \
    \  push!(rolling_max, n)\n    end\n    \n    return rolling_max\nend\n</cell>\n\
    <cell>\n@test rolling_max([1, 2, 3, 2, 3, 4, 2]) == [1,2,3,3,3,4,4]\n</cell>\n\
    <text>\nExercise 5\nThe rolling mean is a function which takes a vector of numbers\
    \ and returns a vector of numbers, where each number is the mean of the numbers\
    \ before it.", "    \n    if length(numbers) < 4 \n        return numbers\n  \
    \  end\n    \n    max = numbers[1]\n    \n    for number in numbers[2:end-1]\n\
    \        if number > max \n            max = number\n        else\n          \
    \  break\n        end\n    end\n    \n    return numbers[2:end-1]\nend\n    \n\
    end # module\n</code>\n<|/ a |>\n<| c |>\nThis is great.  I wish I understood\
    \ this myself, but I really do appreciate you taking the time to show me this.\
    \  Thank you!\n<|/ c |>\n<| c |>\n`@Julia` is my favorite Julia user and I enjoyed\
    \ learning it.  I hope you enjoy it!\n<|/ c |>\n<| a tags=julia dscore=1 |>\n\
    My answer to the question \"Find a maximum in a given vector of integers with\
    \ no duplicates\" (I do not think this answer answers the question above) would\
    \ be\n<code>", "    if length(numbers) == 0\n        return Vector{Int64}()\n\
    \    end", "    \"\"\"\n    Compute the rolling max element in a given vector\
    \ of integers\n    \"\"\"\n    local rmax = 0 \n    local rmax2 = 0 \n    for\
    \ i = numbers[1]:stop=1\n        rmax2 = rmax \n        if rmax > numbers[i]\n\
    \            rmax = numbers[i]\n        elseif rmax2 < numbers[i]\n          \
    \  rmax2 = numbers[i]\n        end\n    end\n    return rmax2\nend", "    rolling_max_vec(numbers,\
    \ 0)\nend", "    return map(maximum, numbers)\nend # rolling_max()\n</code>\n\
    The function rolling_max is equivalent to the following piece of code:\n<code>\n\
    max_numbers = maximum([1, 2, 3, 2, 3, 4, 2])\nrolling_max = [max_numbers]\nfor\
    \ i in 2:length(numbers)\n    rolling_max = [maximum(rolling_max, numbers[i:end])]\n\
    end # for i in 2:length(numbers)\n</code>\nThe function rolling_max is useful\
    \ for obtaining rolling maximum element found in given vector (numbers in this\
    \ case).\nA sample application that use rolling_max can be found below:\n<code>\n\
    julia> rolling_max([1, 2, 3, 2, 3, 4, 2])\n1-element Array{Int64,1}:\n 3\n</code>\n\
    An application that use rolling_max for obtaining rolling minimum element can\
    \ be found below:\n<code>\njulia> rolling_min([4, 2, 7, 8, 1, 5])\n1-element Array{Int64,1}:\n\
    \ 1\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI find this question not clear. Why\
    \ do we need a function `rolling_min`? And why do we need a vector to store results\
    \ (`rolling_max`) as we find min and max in same vector?\n<|/ c |>\n<| c |>\n\
    The function `rolling_min` is for obtaining rolling minimum element found in a\
    \ given vector (numbers in this case).\n<|/ c |>\n<| c |>\nAnd why do we need\
    \ a vector to store results (`rolling_max`) as we find min and max in same vector?\
    \ We use `rolling_max` to store results of rolling max function in order to compute\
    \ rolling min function.\n<|/ c |>\n<| c |>\n\"We use rolling_max to store results\
    \ of rolling max function in order to compute rolling min function.\" We don't\
    \ use rolling_max to store results of rolling min function.\n<|/ c |>\n<| c |>\n\
    I guess you meant \"we don't\" instead of \"we\".\n<|/ c |>\n<| a dscore=2 tags=julia,algorithm\
    \ |>\nThis is an old question but still an interesting one in my opinion. In Julia\
    \ you can use mapslices to do this\n<code>\nmapslices(max, a::Vector{Int64}, dims=3)\n\
    </code>\nYou can also use broadcasting to do this:\n<code>\nmaximum(a[:,1,1],\
    \ a[:,2,2], a[:,3,3])\n</code>\n<|/ a |>\n<| a dscore=2 |>\nI realized a solution\
    \ using loops instead of using map", "    \n    \n    # Start from the first element\n\
    \    i = Int64(0) \n    \n    ans = []\n    \n    \n    while i < numbers.size\n\
    \        \n        \n        if numbers[i] != numbers[i-1]\n            \n   \
    \         append!(ans, numbers[i])\n            \n        else\n            \n\
    \            append!(ans, numbers[i-1])\n            \n        end\n        \n\
    \        i = i+1\n        \n    end\n    \n    \n    return ans\nend\n</cell>\n\
    <code language=julia-1.0>", "   if length(numbers) < 3\n       return numbers\n\
    \   else\n       mid = length(numbers) / 2\n       result = rolling_max(numbers[2..end-1])\
    \ + rolling_max(numbers[1..mid])\n       if numbers[1] > numbers[mid]\n      \
    \     result = result + numbers[1]\n       end\n       result\nend", "    local\
    \ rmax = numbers[1]\n    local rmaxcount = 0\n    for n in numbers[2:end]\n  \
    \      if n == rmax then\n            rmaxcount = rmaxcount + 1\n        elseif\
    \ rmaxcount > 1 then\n            rmax = n\n            rmaxcount = 1\n      \
    \  elseif n == rmax then\n            rmaxcount = rmaxcount + 1\n        elseif\
    \ rmaxcount == 1 then\n            rmax = n\n        else\n            rmaxcount\
    \ = 0\n        end\n    end\n    return rmax\nend\n</cell>\n<text>\nImplement\
    \ a rolling mean function using filter and rolling_max from above exercise. Test\
    \ your implementation on a few examples. Make sure you understand why the output\
    \ is not what you expected.", "  result = [numbers[0]] \n  for n in numbers[2:length(numbers)]\
    \ \n    result << (result[1] < n ? n : result[1]) \n  endfor \n  result \nend\n\
    </code>\n<|/ a tags=biginteger,julia |>\n<| a |>\nFor a slight speed up of about\
    \ 10% for my use case, I found a way to speed things up significantly without\
    \ sacrificing code legibility.\nFor an implementation that works with arbitrary\
    \ precision, check out the package https://github.com/robert-dodier/BigFloats.jl\n\
    To use it, all you need to do is import the package, e.g.\n<code>\nusing BigFloats\n\
    </code>\nAnd then you can define your function as\n<code>\nmyFunc(x::Vector{BigFloat})\
    \ = maximum(maximum(x))\n</code>\nIn other cases, where the input is a Vector{BigFloat},\
    \ the function will return a Vector{BigFloat} instead of an Int, but can be easily\
    \ adapted to this case.\n<|/ a tags=biginteger,julia dscore=0 |>\n<| a tags=biginteger,julia\
    \ |>\nHere is another solution which is faster but more complicated and less legible\
    \ (by my point of view).\nIt should be much faster as it only uses one function\
    \ call\n<code>", "    \n    for i in 1:length(numbers)\n        if numbers[i]\
    \ > numbers[i-1] \n            numbers[i:] = numbers[i:] - numbers[i-1]\n    \
    \    else\n            numbers[i:] = numbers[i:] - numbers[i]\n        end\n \
    \   end\n    return numbers\nend\n\"\"\"\n    Generate the moving average of the\
    \ given vector of integers\n    \"\"\"", "    if length(numbers) < 5\n       \
    \ return numbers\n    else\n        tail = rolling_max(tail)\n        local max_idx\
    \ = -1\n        for i = tail[1] to length(numbers)\n            if numbers[i]\
    \ > numbers[max_idx]\n                max_idx = i\n            elseif numbers[i]\
    \ > numbers[max_idx] \n                max_idx = i\n            end\n        end\n\
    \        append!(tail, numbers[max_idx])\n        return tail\n    end\nend\n\
    </cell>\n<code language=julia-1.6>", "    local result = Vector{Int64}(undef,\
    \ length(numbers))\n    for i in 1:length(numbers)\n        result[i] = numbers[i]\n\
    \    end\n    for i in 1:length(numbers)\n        result[i] = max(result[i], numbers[i])\n\
    \    end\n    return result\nend", "    minimum = minimum(numbers)\n    output\
    \ = zeros(size(numbers))\n    \n    for i = 2:length(numbers)\n        output[i]\
    \ = maximum(numbers[i-1:i+1])\n    end\n    \n    output[end] = minimum\n    \n\
    \    return output\nend\n</cell>\n<code language=julia-1.0>\n# test", "      \
    \  local index = 0\n        local max = 0 \n        for a in numbers do\n    \
    \        if index == 0 then\n                max = a\n            else\n     \
    \           if a > max then max = a end\n            end\n            index =\
    \ index + 1\n        end\n        return max\n    end\n\"\"\"\n    Function used\
    \ to generate random vectors \n    >>> from random import randint\n    >>> rand(5,\
    \ 5)\n    [[1, 7, 4, 9, 1], [9, 5, 3, 6, 8], [3, 9, 6, 2, 3], [4, 8, 7, 5, 6],\
    \ [6, 5, 8, 1, 1]]\n    >>> rand(5, 5)\n    [[4, 6, 6, 5, 5], [4, 3, 2, 3, 7],\
    \ [7, 8, 8, 8, 5], [7, 4, 1, 6, 3], [7, 5, 7, 4, 3]]\n    \"\"\"", "    idx =\
    \ copy(copy(numbers))\n    idx[-1] = numbers[-2]\n    idx[1:end-1] = maximum.(idx,\
    \ idx[1:end-1])\n    return idx\nend", "    \n    \n    # Return empty vector\
    \ if numbers is empty\n    if length(numbers) < 1\n        return zeros(0)\n \
    \   end\n    \n    maximum = numbers[1]\n    \n    numbers = numbers[2:end]\n\
    \    \n    # Loop over all elements of vector \n    for i in eachindex(numbers)\n\
    \        \n        # Check if current element is greater than maximum\n      \
    \  if numbers[i] > maximum\n            maximum = numbers[i]\n        end\n  \
    \      \n        # Replace current element with maximum and shift right the vector\n\
    \        numbers[i] = maximum\n        \n        # Shift all element to the left\
    \ with 1 \n        numbers = numbers[1:i] + numbers[i+1:end]\n    end\n    \n\
    \    return numbers\nend\n</cell>\n<text>\nrolling_max works similar to the built-in\
    \ maximum function. What does this function do?", "    res = Vector{Int64}(length(numbers))\n\
    \    for i \u2208 numbers:\n        res[i] = maximum(numbers[i:i])\n    return\
    \ res\nend", "    rolling_max = zeros(length(numbers))\n    \n    # initialize\
    \ rolling_max with initial numbers\n    for i in numbers:\n        push!(rolling_max,i)\n\
    \    \n    # loop over rolling_max until you find any element that is not in numbers(?)\n\
    \    while length(rolling_max) > 0\n        push!(rolling_max,maximum(rolling_max))\n\
    \    end\n    \n    return rolling_max\nend\n</cell>\n<code language=julia-1.3>\n\
    # Test rolling max\nrolling_max([1, 2, 3, 2, 3, 4, 2])\n</cell>\n<text>\nTask\
    \ 8: Create a vector with the difference between consecutive elements of a given\
    \ vector", "    res = Int64[]\n    count = 0\n    for i in numbers\n        if\
    \ (i >= min_value and i <= max_value)\n            push!(res, i)\n           \
    \ count = count + 1\n        end\n    end\n    while count > 0\n        push!(res,\
    \ max(res[end - count+1:end]))\n        count = count - 1\n    end\n    return\
    \ res\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nCan you please add a sentence\
    \ or two explaining why you think this will help?\n<|/ c |>\n<| c |>\nSorry, but\
    \ I do not get your comment. Can you clarify? Thanks\n<|/ c |>\n<| c |>\nI meant,\
    \ can you add some comments explaining the code? Just so it's clear for future\
    \ viewers.\n<|/ c |>\n<| c |>\nThank you. I understood the code after going through\
    \ the documentation of array and DataFrame. Thank you for adding explanation too\
    \ :)\n<|/ c |>\n<| a dscore=0 |>\nUsing mapslices, you can accomplish this quite\
    \ easily:\n<code>\njulia> xs = [2, 3, 1, 2, 3, 4, 1]\n8-element Array{Int64,1}:\n\
    \ 2\n 3\n 1\n 2\n 3\n 4\n 1", "        vec = Vector{Int64}(numbers)\n        rolling_max_result\
    \ = rolling_max_helper(vec,0,length(vec))\n        vec\n    end", "    sorted_numbers\
    \ = sort(numbers)\n    rolling_max = sorted_numbers[1]\n    \n    for n in sorted_numbers[2:end]\n\
    \        if n > rolling_max\n            rolling_max = n\n        end\n    end\n\
    \    \n    return rolling_max\nend\n</cell>\n<cell>\n\"\"\"\n    rolling_min\n\
    \    \n    From a given vector of integers, generate a vector of rolling minimum\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_min([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 3, 4, 2]\n    \"\"\"", "    n = numbers.length\n\
    \    if n == 0\n        return NIL\n    end\n    \n    rolling_maxs = Vector{Int64}()\n\
    \    \n    # first rolling max at beginning of the vector\n    rolling_maxs =\
    \ [numbers[end]]\n    \n    for  i = end - 2\n        if numbers[i] >= numbers[i+1]\n\
    \            rolling_maxs = [max(rolling_maxs[end], numbers[end]), numbers[i+1]]\n\
    \        end\n    end\n    \n    push!(rolling_maxs, rolling_maxs[end])\n    \n\
    \    return rolling_maxs\nend", "    result = Vector{Int64}(undef, size(numbers)+1)\n\
    \    \n    length(numbers) <= 1 ?\n        result << numbers[2] \n        :\n\
    \        numbers[1] <= 0 ? \n            result << numbers[1]\n        :\n   \
    \     numbers[1] > numbers[2] ? \n            result << numbers[1]\n        :\n\
    \        numbers[1] < numbers[2] ? \n            result << numbers[1]\n      \
    \  :\n            for i = 2 to size(result)[1]\n                local max = 0\n\
    \                local maxindex = 0\n                local prev = 0\n        \
    \        for j = i - 1; j >= 1\n                    if numbers[j] > numbers[i]\n\
    \                        prev = numbers[j]\n                        maxindex =\
    \ j\n                    end\n                end\n                \n        \
    \        if max > numbers[i]\n                    max = numbers[i]\n         \
    \       end\n                \n                if prev == numbers[i]\n       \
    \             result[maxindex + 1] = max\n                else\n             \
    \       result[maxindex + 1] = prev\n                end\n            end\n  \
    \  result\nend", "    local rollingMax = numbers[length(numbers)]\n    local maxIndex\
    \ = 0\n    local isMax = true\n    local lastMaxIndex = length(numbers)\n    for\
    \ i = length(numbers)+1 , lastMaxIndex-1 , -1 do\n        if numbers[i] >= rollingMax\
    \ then\n            lastMaxIndex = i\n            isMax = true\n        elseif\
    \ numbers[i] != rollingMax then\n            isMax = false\n        end\n    end\n\
    \    if isMax then\n        for i = lastMaxIndex , lastMaxIndex-1 , -1 do\n  \
    \          if numbers[i] < rollingMax then\n                maxIndex = i\n   \
    \             rollingMax = numbers[i]\n            end\n        end\n    end\n\
    \    return rollingMax\nend\n</code>\n<|/ a tags=max,python,vector,arrays,julia\
    \ |>\n<| a dscore=1 tags=max,python,vector,arrays,julia |>\nHere is a solution\
    \ that is O(n), i.e. linear in the size of the vector:\n<code>", "    lenght =\
    \ length(numbers)\n    rolling_max = []\n    for ix in 2:lenght\n        rolling_max.push(maximum(numbers[ix:ix+1]))\n\
    \    end\n    return rolling_max\nend\n    \"\"\"\n    numbers = convert(Vector,\
    \ numbers)\n    lenght = length(numbers)\n    rolling_max = []\n    for ix in\
    \ 2:lenght\n        rolling_max.push(maximum(numbers[ix:ix+1]))\n    end\n   \
    \ return rolling_max\nend", "    if length(numbers)==0\n        return []\n  \
    \  \n    leng=length(numbers)\n    result=numbers[end]\n    \n    for i = leng-1\
    \ downto 1 \n        rolling_max_element = numbers[i]\n        if i > 1 and numbers[i-1]\
    \ > rolling_max_element \n            numbers[leng-1] = rolling_max_element\n\
    \        else\n            numbers[i]=result\n        end\n    end\n    \n   \
    \ return numbers\nend", "    rolling_max = numbers[end]\n    index = end\n   \
    \ for element in numbers[end:-1:1]\n        if element > rolling_max\n       \
    \     rolling_max = element\n            index = end\n        else\n         \
    \   index = index - 1\n        end\n    end\n    \n    return rolling_max\nend\n\
    </cell>\n<text>\nPutting all together\nFinally, let's put everything together\
    \ to create a rolling average, median and stdev function that we will be using\
    \ to evaluate our hypothesis. We will use a random data set to illustrate our\
    \ findings.", "    result = []\n    number = numbers[1]\n    for element in numbers\n\
    \        if element > number\n            number = element\n        else\n   \
    \         result.push(element)\n        end\n    end\n    return reverse(result)\n\
    end\n</cell>\n<text>\nRolling Mean (RM)\nWe are going to use the same rolling\
    \ mean, but we will need to use the cumsum function before we continue with this\
    \ problem.", "    \n    # initialization\n    maximum = numbers[1]\n    position\
    \ = 1\n    \n    # loop\n    for number in numbers[2:end]\n        if number >\
    \ maximum\n            maximum = number\n            position = number\n     \
    \   end\n    end\n    \n    return maximum\nend\n</cell>\n<code language=julia-1.6>",
  "    if length(numbers) < 4 \n        return numbers\n    end", "    numbers = sort(numbers)\n\
    \    numbers = numbers[2:end]\n    if length(numbers) <= 1\n        numbers\n\
    \    else\n        rolling_max(numbers)\n    end\nend", "    rolling_max_vec =\
    \ []\n    for number in numbers\n        rolling_max_vec += rolling_max(number)\n\
    \    end\n    \n    return rolling_max_vec\nend\n</cell>\n<text>\n7. Finding the\
    \ mode\nThe mode of a set of numbers is often called the \"most common element\"\
    . The mode is either the most frequently occurring element, or the most abundant\
    \ element (with a very high probability). In the case of a tie, the most frequently\
    \ occurring element is returned.", "    if length( numbers ) <= 1\n        return\
    \ numbers\n    end\n    result = numbers[end]\n    numbers[end] = -Inf #set last\
    \ element to minus infinity\n    for i in (end - 1)::-1\n        if numbers[i]\
    \ > numbers[end]\n            numbers[i] = numbers[i]\n        else\n        \
    \    numbers[i] = numbers[end]\n        end\n    end\n    return numbers[end]\n\
    end\n</cell>\n<code language=julia-1.5>\n@testset \"A testset for rolling max\
    \ function\" begin\n    @test rolling_max(Vector{Int64}([1,2,3,2,3,4,2])) == [1,2,3,3,3,4,4];\n\
    \    @test rolling_max(Vector{Int64}([-1,-1,-2,-2,-3,-3,-4,-4])) == [-1, -1, -2,\
    \ -2, -3, -3, -4, -4]\nend\n</cell>\n<code language=julia-1.5>\n@testset \"A testset\
    \ for rolling max function\" begin\n    @test rolling_max(Vector{Int}([1,2,3,2,3,4,2]))\
    \ == [1,2,3,3,3,4,4];\n    @test rolling_max(Vector{Int}([-1,-1,-2,-2,-3,-3,-4,-4]))\
    \ == [-1, -1, -2, -2, -3, -3, -4, -4]\nend\n</cell>\n<code language=julia-1.5>",
  "    if length(numbers) < 2 \n        return numbers \n    index := 0 \n    result\
    \ := Vector{Int64}() \n    while index != length(numbers) \n        append!(result,\
    \ numbers[index]) \n        index += 1\n    result \nend\n\"\"\"\n    Return a\
    \ rolling sum of a given vector of integers. From a given vector of integers,\
    \ generate a vector of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4,\
    \ 4]\n    \"\"\"", "    numbers = numbers[2:end] \n    maximum = numbers[1] \n\
    \    maximums = [maximum] \n    for n in numbers[2:end] \n        if n > maximum\n\
    \            maximum = n\n        else\n            maximum = maximum\n      \
    \      maximums << maximum\n        end\n    end\n    return maximums\nend\n</cell>\n\
    <code language=julia-1.5>", "    number_sums = [numbers[x] for x in 1:length(numbers)]\n\
    \    \n    # find maximum from number_sums\n    maxium = maximum(number_sums)\n\
    \    \n    # find corresponding index in number_sums vector\n    index = length(number_sums)\n\
    \    \n    # generate rolling maximum based on given moment\n    rolling_max_vector\
    \ = []\n    for i in 1:maxium\n        rolling_max_vector.append(numbers[index])\n\
    \        index -= 1\n    end\n    \n    return rolling_max_vector\nend", "\"\"\
    \"\n    Generate the rolling maximum element found until a given moment in the\
    \ sequence.\n    \n    Arguments:\n        - numbers: Vector of integers.\n  \
    \  \n    Returns:\n        - max: Vector of integers containing the rolling maximum\
    \ element found until a given moment in the sequence. \n    \"\"\"\n    \n   \
    \ \n    max_so_far = Vector{Int64}(undef, length(numbers))\n    \n    for i =\
    \ 1:length(numbers)\n        if i >= length(max_so_far)\n            max_so_far[i]\
    \ = numbers[i]\n        else\n            if numbers[i] > max_so_far[i]\n    \
    \            max_so_far[i] = numbers[i]\n            else\n                push!(max_so_far,\
    \ numbers[i])\n            end\n        end\n    end\n    \n    return max_so_far\n\
    end", "    \"\"\"\n    Vector{Int64} -> Vector{Int64}\n    \"\"\"\n    numbers\
    \ = numbers.copy()\n    numbers[length(numbers)] = 0\n    numbers[(length(numbers)-1)]\
    \ = 1\n    numbers = na.omit(numbers)\n    numbers = na.omit(numbers)\n    numbers\
    \ = na.omit(numbers)\n    \n    rollingmax = (0...length(numbers)).map(x => max(numbers[x+1..end]))\n\
    \    return rollingmax\nend", "    rolling_max_roll = rolling_max(numbers)\n \
    \   index_max = 1\n    index_min = 1\n    if length(rolling_max_roll) == length(numbers)\n\
    \        return rolling_max_roll\n    elseif length(rolling_max_roll) < length(numbers)\n\
    \        index_max = length(rolling_max_roll) + 1\n        index_min = length(rolling_max_roll)\n\
    \    end\n    for index in 1:length(numbers)\n        if numbers[index] == rolling_max_roll[index_max-1]\n\
    \            index_max = index_max + 1\n        elseif numbers[index] == rolling_max_roll[index_min-1]\n\
    \            index_min = index_min + 1\n        else\n            rolling_max_roll[index_max]\
    \ = numbers[index]\n            index_max = index_max + 1\n        end\n    end\n\
    \    return rolling_max_roll\nend\n    ", "    rolling_max(numbers, Int64(0),\
    \ Int64(0))\nend", "    # Initialization\n    rolling_max = zeros(length(numbers))\n\
    \    \n    rolling_max[1] = numbers[1]\n    rolling_max[2] = max(numbers[2:end])\n\
    \    rolling_max[3] = max(numbers[3:end])\n    \n    for i=4:length(numbers)\n\
    \        rolling_max[i] = max(rolling_max[i-2], rolling_max[i-3], rolling_max[i-4])\n\
    \    end\n    return rolling_max\nend", "    vector=Vector{Int64}(length(numbers))\n\
    \    for i=1:length(numbers)\n        vector[i]=maximum(numbers[i-1:i+1])\n  \
    \  end\n    return vector\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| a tags=julia,arrays\
    \ |>\nHere is another way of doing it:\n<code>\nusing LinearAlgebra", "  numbers\
    \ = numbers[:]\n  rolling_max_size = length(numbers)\n  for i in 1:rolling_max_size\n\
    \      numbers[i] = maximum( numbers[i:i+rolling_max_size])\n  end\n  return numbers\n\
    end\n</code>\n<|/ a |>\n<| a tags=algorithm,julia dscore=2 |>\nHere's a solution\
    \ in Julia without allocating intermediate vectors (but it's probably inefficient).\n\
    <code>\nrolling_max(v::Vector{Int64}) =\n    maximum.(rolling(collect(v), Int,\
    \ length=length(v)))\n</code>\nIt's O(N) in the size of the input vector (v) and\
    \ O(N log N) in the size of the rolling window.\nHere's a little benchmark showing\
    \ it to be significantly faster than the solutions above:\n<code>\njulia> using\
    \ BenchmarkTools", "    rolling_max = numbers[end]\n    for number in numbers[1\
    \ : end-1]\n        rolling_max = max(rolling_max, number)\n    end\n    return\
    \ rolling_max\nend\n</cell>\n<text>\nExercice 9 : rolling_max([1, 2, 3, 2, 3,\
    \ 4, 2])", "    m = minimum(numbers)\n    res = [m]\n    for n in numbers[2:end]\n\
    \        if n != m\n            res = [n, maximum(res, m)]\n            m = n\n\
    \        else\n            m == n\n        end\n    end\n    return res\nend",
  "    sorted_numbers = sort(numbers)\n    \n    window_size = length(sorted_numbers)\
    \ - 1\n    rolling_max_vector = Vector{Int64}(undef, window_size)\n    \n    for\
    \ i=1:window_size\n        rolling_max_vector[i] = maximum(sorted_numbers[i:end])\n\
    \    end\n    \n    return rolling_max_vector\nend\n</code>\n<|/ a |>\n<| a tags=julia,performance,algorithm\
    \ |>\n<code>\nusing BenchmarkTools\nusing Random\nusing Random: rand, randn",
  "        rolling_max = zeros(length(numbers))\n        rolling_max[1 : length(numbers)]\
    \ = numbers\n        for ii in rolling_max[2 : length(numbers)-1]\n          \
    \  if numbers[ii] < numbers[ii+1]\n                rolling_max[ii+1:length(numbers)]\
    \ = numbers[ii+1:length(numbers)-1]\n            else\n                break\n\
    \            end\n        end\n        return rolling_max\n    end\n</code>\n\
    <|/ a dscore=1 tags=julia |>\n<| c |>\nPlease add some explanation to your answer\
    \ such that others can learn from it\n<|/ c |>\n<| c |>\nPlease [edit] your answer\
    \ to add an explanation of how your code solves the problem. [From Review](https://stackoverflow.com/review/low-quality-posts/29006653)\n\
    <|/ c |>\n<| a |>\nThe shortest possible (but inefficient) solution is:\n<code>\n\
    rolling_max(numbers::Vector{Int64}) = sort!(collect(reverse(numbers)), by=x->x<=>(x[-2])==(x[-1]),\
    \ rev=true)\n</code>\nI guess this does not answer your question but it is rather\
    \ a workaround than an answer. I also think it is more difficult than other solutions\
    \ and it involves unnecessary copying but this is unavoidable due to sort!.\n\
    <|/ a tags=julia dscore=0 |>\n<| c |>\nIt still copies the vector.\n<|/ c |>\n\
    <| c |>\nIt doesn't copy the vector. `sort!` returns a `Vector{Int}` and does\
    \ not modify the input vector. This should work fine in practice.\n<|/ c |>\n\
    <| a |>\nHere is another solution. It does not copy the vector but still it requires\
    \ much less effort than other solutions posted by others.\n<code>", "    #return\
    \ numbers[1:end-1]\n    return numbers[end-1:end]\nend\n</cell>\n<code language=julia-0.6>\n\
    #=\nrolling_max([1, 2, 3, 2, 3, 4, 2])\n=#\n</cell>\n<code language=julia-0.6>",
  "    # Fill with -1\n    numbers = Vector{Int64}(fill(-1, length(numbers)))\n  \
    \  # Create a rolling max vector and fill with number at 0th index\n    for i\
    \ in 1:length(numbers)\n        numbers[i] = numbers[i - 1] if numbers[i - 1]\
    \ > numbers[i] else numbers[i]\n    end\n    numbers\nend\n</code>\n<|/ a dscore=4\
    \ |>\n<| a dscore=3 |>\nFor me it worked the following way:\n<code>\nx = [1, 2,\
    \ 3, 4, 5];\ny = rolling_max(x);", "    rolling_max = numbers[1:length(numbers)+1]\n\
    \    for number in numbers[2:length(numbers)+1]\n        if number > rolling_max[1]\n\
    \            rolling_max[1] = number\n        end\n    end\n    rolling_max\n\
    end\n</cell>\n<code language=julia-0.6>\n@code_native(rolling_max)\n</cell>\n\
    <text>\nA better rolling max function might be to loop through each element in\
    \ the vector and compare it to the rest of the vector, keeping track of the largest\
    \ element as you go. Though this would have a higher time complexity, it would\
    \ have a higher overall performance as Julia can just go through the whole vector\
    \ once.", "    number_windows = numbers[1:end - 1]\n    number_windows_sum = sum(number_windows)\n\
    \    result = []\n    for number in numbers:\n        if number > number_windows_sum:\n\
    \            result.push(number)\n        else\n            result.push(numbers[end])\n\
    \        end\n    end\n    return result\nend\n\"\"\"\n    From a given vector\
    \ of integers, generate a vector of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n \
    \   [1, 2, 2, 3, 1, 4, 3]\n    \"\"\"", "    \n    index = -1\n    maximum_element\
    \ = numbers[1]\n    \n    # Keep rolling until the last moment\n    while index\
    \ != size(numbers)\n        index += 1\n        maximum_element = max(numbers[index],\
    \ maximum_element)\n    end\n    \n    return vec([numbers[index] for index in\
    \ 1:index])\nend", "    rolling_max = numbers[end]\n    for n in numbers[2:end]\n\
    \        rolling_max = max(rolling_max, n)\n    end\n    rolling_max\nend\n</code>\n\
    <|/ a tags=performance,arrays,julia |>\n<| c |>\nThanks, although this was what\
    \ I was trying to avoid. I'd love to see a more efficient way of doing this.\n\
    <|/ c |>\n<| c |>\nThis is very inefficient, as you build the `rolling_max` vector\
    \ in each iteration of the `for` loop. Instead, you should build the vector in\
    \ the beginning.\n<|/ c |>\n<| c |>\nI used a slightly different solution with\
    \ less code but the same result: https://stackoverflow.com/a/63207469/477087\n\
    <|/ c |>\n<| a dscore=3 tags=performance,arrays,julia |>\nThis solution is also\
    \ good for finding the maximum of any function defined by a vector:\n<code>",
  "   \n    max = numbers[1]\n    for number in numbers[2:end] \n        if number\
    \ > max \n            max = number \n        else\n            break\n    end\n\
    \    return max\nend", "    \n    if length(numbers) <= 1\n        return numbers\n\
    \    end", "    largest = numbers[1]\n    largest = maximum([largest, numbers[2]])\n\
    \    for n in numbers[2:end]\n        largest = maximum([largest, n])\n    end\n\
    \    return largest\nend\n</cell>\n<code language=julia-1.2>\nrolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n</cell>\n<text>\nRandom numbers\nRandom numbers are a function\
    \ that generates a sequence of random numbers. In this case, those numbers come\
    \ from the uniform distribution on the unit interval $[0,1]$. Therefore, a random\
    \ sequence $x_1, x_2, \\ldots, x_n$ will appear as", "    \n    rolling_max =\
    \ 0\n    \n    for n in numbers\n        if n > rolling_max\n            rolling_max\
    \ = n\n        end\n    end\n    \n    rolling_max\nend\n</cell>\n<text>\nNow\
    \ try it yourself on the rolling_max function above.", "    \n    roll <- Vector{Int64}(length(numbers))\n\
    \    for i in 1:length(numbers)\n        roll[i] = maximum(numbers[i-1:i])\n \
    \   end", "    #find maximum element in the given list\n    max_element = max_element(numbers)\n\
    \    \n    #find rolling maximum in the list\n    rolling_max = Vector{Int64}(max_element)\n\
    \    for i in max_element:\n        rolling_max[i] = max(rolling_max[i], numbers[i])\n\
    \    return rolling_max\nend", "    ans=[]\n    k=length(numbers)\n    last=numbers[k-1]\n\
    \    numbers[k-1]=last\n    roll=rolling_max(numbers[1:k])\n    roll=[last, last,\
    \ last]\n    for n in numbers\n        if n > last\n            roll = roll.(roll,\
    \ last)\n        end\n        last = n\n    end\n    push!(ans, roll)\n    return\
    \ ans\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI like the rolling_max idea.\
    \ I ended up writing something similar, but I ended up using an Array instead\
    \ of Vector. I'm sure it can be improved, but I'm new to Julia so I was just working\
    \ with something small.\n<|/ c |>\n<| c |>\nI'm curious if this can be done without\
    \ explicitly calling the rolling_max() function? Like a built-in function that\
    \ would just iteratively add the rolling_max values?\n<|/ c |>\n<| c |>\nYes,\
    \ you can do this by writing a recursive function.\n<|/ c |>\n<| a tags=julia\
    \ |>\nHere is my implementation:\n<code>\njulia> function rolling_max(x::Array{Int64,1})\n\
    \           return Array{Int64,1}(maximum(x[1:end-1],0))\n       end\nrolling_max\
    \ (generic function with 1 method)", "    rolling_max.numbers = numbers\n    rolling_max.result\
    \ = rolling_max.numbers[1]\n    for elem in rolling_max.numbers[2:end]\n     \
    \   if elem > rolling_max.result\n            rolling_max.result = elem\n    \
    \    end\n    end\n    rolling_max.result\nend", "     \n    # Initialization\n\
    \    index = zeros(Int64,0)\n    max_element = numbers[1]", "    maximums = Vector{Int64}()\n\
    \    maximum = numbers[1]\n    for n in numbers[2:end]\n        if n > maximum\n\
    \            maximum = maximum\n        else\n            maximum = maximum\n\
    \        end\n        push!(maximums, maximum)\n    end\n    return maximums\n\
    end", "    maximum = 0\n    index = length (numbers)\n    for i = 1:index\n  \
    \      if (numbers[i] > maximum)\n            maximum = numbers[i]\n        end\n\
    \    end\n    maximum\nend\n</code>\n<|/ a |>\n<| c |>\nThanks. I did not find\
    \ `rolling_max` when I browse the functions of Julia's `DataFrames` package, which\
    \ is quite confusing as `rolling_mean` seems like a very similar function.\n<|/\
    \ c |>\n<| a |>\nThe DataFrames package also includes the rolling* functions,\
    \ which are very similar to the rolling_* functions from pandas\n<|/ a dscore=5\
    \ tags=julia |>\n<| a dscore=4 tags=julia |>\nIn case you need rolling statistics\
    \ over multiple columns, here is a solution using the DataFrames package.\n<code>\n\
    using DataFrames", "    rolling_max = [numbers[0]]\n    for i in 2:length(numbers)\n\
    \        rolling_max[i] = maximum(rolling_max[i-1], numbers[i])\n    end\n   \
    \ rolling_max\nend\n</cell>\n<code language=julia-1.6>\nrolling_max([1, 2, 3,\
    \ 2, 3, 4, 2])\n</cell>\n<code language=julia-1.6>\n\"\"\"\n    rolling_mean(numbers::Vector{Int64})::Float64",
  "    n=length(numbers)\n    result=zeros(Int64,n)\n    for i in 1:n\n        result[i]=maximum(numbers[i:n],result[i:])\n\
    \    end\n    result\nend\n</cell>\n<text>\n3.4 Custom Functions", "    local\
    \ max_elements = []\n    for element in numbers\n        if element > max_elements[end]\
    \ \n            max_elements[end] = element\n        end\n    end\n    max_elements\n\
    end\n</cell>\n<code language=julia-1.5>", "    # Initialize the rolling maximum\n\
    \    rolling_max = numbers[1]", "    \n    return Int64(\n                @inbounds\
    \ max_elem(numbers) \n        )", "    rolling_max_value = numbers[1]\n    result\
    \ = numbers[2:end]\n    for i in numbers[2:end]\n        rolling_max_value = max(rolling_max_value,\
    \ i) # updating the rolling max value\n        result = [rolling_max_value] +\
    \ result\n    end\n    result\nend\n</cell>\n<code language=julia-1.6>", "   \
    \ rolling_max = Vector{Int64}(length(numbers))\n    rolling_max.fill(Inf)\n  \
    \  index_max = -1\n    # Find a rolling max index\n    for index in 1:length(numbers)\n\
    \        if numbers[index] > rolling_max[index_max]\n            rolling_max[index_max]\
    \ = numbers[index]\n        else\n            index_max = index\n        end\n\
    \    end\n    return rolling_max\nend", "    result = zeros(length(numbers))\n\
    \    for i = 1:length(numbers)\n        if (numbers[i] > numbers[i-1])\n     \
    \       result[i] = numbers[i]\n        else\n            result[i] = max(result[i],\
    \ numbers[i])\n        end\n    end\n    result\nend\n</code>\n<|/ a dscore=1\
    \ tags=performance,julia,numpy,python |>\n<| a tags=performance,julia,numpy,python\
    \ |>\nWith Julia, you can also do:\n<code>\njulia> data = [1,2,3,2,3,4,2]\n6x1\
    \ Array{Int64,1}:\n 1\n 2\n 3\n 2\n 3\n 4\n 2", "    \n    for i=1:length(numbers)\n\
    \        if numbers[i] > numbers[i-1]\n            numbers[i] = numbers[i-1]\n\
    \        else\n            numbers[i] = numbers[i]\n        end\n    end\n   \
    \ return numbers\nend\n</cell>\n<text>\nExercise 6 (15 points):\nCompute rolling\
    \ minimum using the function rolling_min. Do this for all elements of a vector\
    \ of integers. Plot the results using plot!.", "    \"\"\"\n    From a given vector\
    \ of integers, generate a vector of rolling maximum element found until given\
    \ moment\n    in the sequence.\n    \"\"\"\n    if numbers.size == 0\n       \
    \ return []\n    \n    if numbers[1] > numbers[0]\n        result = numbers[1:]\n\
    \    else\n        result = numbers[2:end]\n    end\nend\n</cell>\n<code language=julia-1.6>\n\
    # Generate a sample of size n of random numbers from uniform distribution", " \
    \   max_length = 0\n    for i in numbers\n        if i > max_length\n        \
    \    max_length = i\n        else\n            max_length = max_length > i ? max_length\
    \ : i\n        end\n    end\n    \n    return collect(1:max_length)\nend\n</cell>\n\
    <text>\nExercise 17: Calculate the maximum element in a vector using the rolling\
    \ maximum function.", "    index = Int64[]\n    max = 0\n    rolling_max = Int64[]\n\
    \    for number in numbers\n        if number > max\n            max = number\n\
    \            index = []\n        elseif max != 0\n            index += [index]\n\
    \            rolling_max += [index]\n            max =  number\n        end\n\
    \    end\n    rolling_max += [index]\n    return rolling_max\nend\n</cell>\n<text>\n\
    Rolling mean", "    maximums = zeros(length(numbers), 1)\n    for idx in 1:length(numbers)\n\
    \        maximums[idx] = maximum(numbers[idx:idx+length(numbers)-idx])\n    end\n\
    \    return maximums\nend", "    size::Int64 = length(numbers)\n    vector::Vector{Int64}\
    \ = zeros(Int64, size)\n    \n    for index in 0:size - 1\n        vector[index]\
    \ = max(numbers[index:index + 1])\n    end\n    \n    return vector\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis solution is not tail-recursive, so won't be accepted into\
    \ Julia 1.6.1\n<|/ c |>\n<| a dscore=2 |>\nHere's another simple solution, that\
    \ doesn't rely on any packages and works in Julia 1.6.1:\n<code>", "    numbers[numbers\
    \ == 0] = Inf #avoid zeros \n    numbers[isnan(numbers)] \n    numbers = sort(numbers)\
    \ #sort the numbers\n    rolled = rolling_window(numbers, length(numbers)) #generate\
    \ the rolling window \n    #find the maximum of the window for each number\n \
    \   maximums = maximum.(rolled) #generate the maximums\n    #find the maximum\
    \ of the window for each number (rolling window must be sorted)\n    maximums[maximums\
    \ == 0] = Inf #avoid zeros \n    return maximum(maximums)\nend", "    N = length(numbers)\n\
    \    m = minimum(numbers)\n    return map( x -> ifelse(x > (m+1), (max(numbers,\
    \ x)+m), x) ,numbers)\nend\n</cell>\n<code language=julia-1.4>\n# TEST rolling_max\
    \ (4c)\n@test rolling_max([1, 2, 3, 2, 3, 4, 2]) == [\n    1, 2, 3, 3, 3, 4, 4,\
    \ 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15\n\
    ]\n</cell>\n<text>\n7. Random sampling \nGenerate a vector of N random samples\
    \ from a uniform distribution between a and b.\nThe random sampling algorithm\
    \ is uniformly distributed between a and b while generating $N$ samples.", " \
    \   sorted_numbers = sort(numbers)\n    \n    rolling_max_of_sorted_numbers =\
    \ sorted_numbers[end]\n    \n    for i in length(sorted_numbers-1):\n        if\
    \ sorted_numbers[i] > rolling_max_of_sorted_numbers\n            rolling_max_of_sorted_numbers\
    \ = sorted_numbers[i]\n        end\n    end\n    return rolling_max_of_sorted_numbers\n\
    end\n\"\"\"\n## @doc \n## Generate new matrix from a given vector and given function\n\
    ## @param matrix The matrix to copy\n## @param function The function to apply\
    \ at each cell\n## @return The new matrix\n## @example\n## ```julia\n## julia>\
    \ f(x, y) = x + y\n## julia> matrix = rand(2, 3)\n## julia> new_matrix = generate_new_matrix(matrix,\
    \ f)\n## ```\n## @see [Linear Interpolation](@ref)\n## @since 0.3.0\n## @note\
    \ To use @ref linear interpolation algorithm @ref `@ref lerp` ", "  max_value\
    \ = numbers[1]\n  for i in 2:length(numbers)\n    if numbers[i] > max_value\n\
    \      max_value = numbers[i]\n    end\n  end\n  return numbers\nend", "    numbers\
    \ = map(minimum, numbers)\n    tail_start = 0\n    while tail_start < length(numbers)\
    \ - 1\n        if numbers[tail_start] == numbers[tail_start + 1]\n           \
    \ return numbers[tail_start:]\n        else\n            tail_start += 1\n   \
    \     end\n    end\n    return numbers\nend\n</cell>\n<code language=julia-1.2>\n\
    # Let's test our function\nrolling_max([1, 2, 3, 2, 3, 4, 2])\n</cell>\n<text>\n\
    Now that we have our rolling max function, let's test out the performance of it\
    \ on an array of random integers", "    rolling_max = numbers[end]\n    for n\
    \ in numbers[2:end]\n        rolling_max = maximum(rolling_max, n)\n    end\n\
    \    rolling_max\nend", "    numbers = Vector{Int64}(numbers)\n    rolling_max\
    \ = Vector{Int64}(undef, 0)\n    rolling_max.resize(size(numbers))\n    for i\
    \ in 0:length(numbers)-1\n        rolling_max[i] = maximum(numbers[i:i+1])\n \
    \   end\n    rolling_max\nend\n</cell>\n<code language=julia-1.5>\n@time rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n</cell>\n<text>\n\u0422\u0435\u0441\u0442\u0438\u0440\u043E\
    \u0432\u0430\u043D\u0438\u0435 \u0434\u0432\u0443\u0445 \u0444\u0443\u043D\u043A\
    \u0446\u0438\u0439", "    max_length = length(numbers)\n    rolling_maxs = Vector{Int64}(undef,\
    \ max_length)\n    for i = 1:length(numbers)\n        if numbers[i] == numbers[i-1]\n\
    \            rolling_maxs[i] = numbers[i]\n        else\n            rolling_maxs[i]\
    \ = numbers[i]\n            for j = i-1:-1:1\n                if numbers[j] >=\
    \ numbers[i]\n                    rolling_maxs[i] = numbers[j]\n             \
    \   else\n                    rolling_maxs[i] = numbers[i]\n                 \
    \   break\n                end\n            end\n        end\n    end\n    return\
    \ rolling_maxs\nend\n</code>\n<|/ a tags=performance,julia,optimization,arrays\
    \ |>\n<| c |>\nI like the speed of this approach. Can you explain why you used\
    \ `@time` on `rolling_max(collect(1:20))`? The results seem to be different and\
    \ I thought it should be the same.\n<|/ c |>\n<| c |>\nI think it's because `rolling_max`\
    \ will also take care of any `NaN` values in the input vector.  I haven't benchmarked\
    \ this with actual numbers yet, but I suspect `rolling_max` will be faster with\
    \ those `NaN` values.\n<|/ c |>\n<| c |>\nAlso I noticed I made a mistake in the\
    \ second `rolling_max`.  I thought it returned the element instead of the index.\
    \  It should now return the index.  I've corrected it now. I tested it and it\
    \ seems to work correctly now.\n<|/ c |>\n<| c |>\nI just tested this approach\
    \ on both vectors of 100,000 elements and it was about 20% faster (0.023 vs 0.038).\n\
    <|/ c |>\n<| c |>\nI benchmarked it and it does seem faster (0.036 vs 0.026).\
    \ However, I still think `rolling_max` should be faster than `rolling_max_2` because\
    \ it does not require the extra looping over `numbers`.\n<|/ c |>\n<| a tags=performance,julia,optimization,arrays\
    \ dscore=3 |>\nThe approach I like to use is the following. First, write a function\
    \ to return a single element from your array that is at a given position:\n<code>",
  "    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    if length(numbers)==0\n\
    \        return Vector{Int64}()\n    end", "    return if length(numbers) < 1\
    \ \n        numbers \n    else \n        reduce(max,numbers[1..end-1]) \n    \
    \    +  rolling_max(numbers[end+1:end]) \n    end\nend", "    largest = numbers[1]\n\
    \    rolling_max_idx = 0\n    for i in 2:length(numbers)\n        if numbers[i]\
    \ > largest\n            largest = numbers[i]\n            rolling_max_idx = i\n\
    \        end\n    end\n    return numbers[rolling_max_idx:end]\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\nThis is another solution that uses R's data.table\
    \ package.\n<code>\n# create a vector of indices\nindices <- c(FALSE, head(seq_along(x),-1))",
  "    idx = 1\n    rolling_max = numbers[idx]\n    for i in numbers[idx : end] \n\
    \        rolling_max = max(rolling_max, i) \n        idx += 1 \n    end\n    rolling_max\n\
    end\n</cell>\n<code language=julia-1.5>\nrolling_max([1, 2, 3, 2, 3, 4, 2])\n\
    </cell>\n<text>\nThe function also takes an optional parameter min_numbers to\
    \ define the minimum number of elements of the array that need to be included\
    \ in the result (defaults to 0).", "    return Array{Int64, 1}(map((x -> (x >\
    \ numbers .* length(numbers) ? x : numbers .* length(numbers)) - x) \n       \
    \                            numbers, numbers))\nend", "    \n    local max_element\
    \ \n    local min_element \n    local sum = 0\n    for i = numbers[1], 1, -1 do\
    \ \n        local x = numbers[i]\n        if min_element == nil then\n       \
    \     min_element = x;\n            max_element = x;\n        elseif x < min_element\
    \ then\n            min_element = x\n        end\n        if x > max_element then\n\
    \            max_element = x\n        end\n        sum = sum + x\n    end\n  \
    \  if min_element == nil then\n        min_element = 0\n    end\n    if max_element\
    \ == nil then\n        max_element = sum\n    end\n    \n    max_element = max_element\
    \ + sum\n    \n    return min_element:max_element\nend\n</cell>\n<code language=julia-1.5>",
  "    \"\"\"\n    From a given vector of integers, generate a vector of rolling maximum\
    \ element found until given moment\n    in the sequence.\n    \"\"\"\n    numbers\
    \ = numbers[end:end:end] #trim out the current number\n    #print(numbers)\n \
    \   max = numbers[end]\n    for n in numbers[2:end-1]\n        if n > max\n  \
    \          max = n\n        end\n    end\n    return max\nend\n</code>\n<code>\n\
    # test it\na = Vector{Int64}([1,2,3,2,3,4,2])\nprintln(rolling_max(a))", "   \
    \ # Base case\n    ret = numbers[1:end]\n    # Recursive case\n    for i = end\
    \ - 1\n        if numbers[i] > ret[end - 1]\n            ret[end] = numbers[i]\n\
    \        end\n    end\n    ret\nend", "    answer = []\n    minimum = numbers[1]\n\
    \    maximum = numbers[end]\n    for i in numbers[2:end-1]\n        if i < minimum\n\
    \            minimum = i\n        end\n    end\n    for i in numbers[2:end]\n\
    \        if minimum > i\n            answer.push(minimum)\n            minimum\
    \ = i\n        end\n    end\n    answer.push(maximum)\n    return answer\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThe OP wants the rolling maximum element of the given\
    \ sequence, not the maximum element of the sequence. I think this is what you\
    \ meant though.\n<|/ c |>\n<| c |>\nAh yes, I understand now. Sorry for my misunderstanding.\
    \ I thought you just wanted the maximum element of the given vector.\n<|/ c |>\n\
    <| a dscore=2 |>\nThis is my solution (I thought of it after posting the question)\n\
    <code>", "    rolling_max_idx <- Int64[]\n    for i in 0..numbers.size\n     \
    \   if numbers[i] >  numbers[rolling_max_idx]\n            rolling_max_idx <-\
    \ Int64[rolling_max_idx, i]\n        end\n    end\n    return numbers[rolling_max_idx]\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nHere's my simple implementation\
    \ using Vectors.\n<code>", "    length = length(numbers)\n    rolling_max = []\n\
    \    # Initialize all rolling max value\n    for i \u2208 0:(length - 1):\n  \
    \      rolling_max.push(0)\n    # Assign current max value to the last number\
    \ of the vector\n    last_value = numbers[length - 1]\n    rolling_max[length\
    \ - 1] = last_value\n    # Loop through the vector to find the next maximum\n\
    \    for i in (length - 2):-1:1\n        if numbers[i] > last_value\n        \
    \    rolling_max[i] = numbers[i]\n        else\n            break\n    return\
    \ rolling_max\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
