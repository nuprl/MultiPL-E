name: HumanEval_90_next_smallest
language: jl
prompt: "\"\"\"\n    You are given a vector of integers.\n    Write a function next_smallest()\
  \ that returns the 2nd smallest element of the vector.\n    Return nothing if there\
  \ is no such element.\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5,\
  \ 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    nothing\n    >>> next_smallest([1,\
  \ 1])\n    nothing\n    \"\"\"\nfunction next_smallest(lst::Vector{Int64})::Union{Int64,\
  \ Nothing} \n"
tests: "using Test\n\n@testset begin\n\ncandidate = next_smallest;\n\t@test(candidate([1,\
  \ 2, 3, 4, 5]) == 2)\n\t@test(candidate([5, 1, 4, 3, 2]) == 2)\n\t@test(candidate(Vector{Int64}([]))\
  \ == nothing)\n\t@test(candidate([1, 1]) == nothing)\n\t@test(candidate([1, 1, 1,\
  \ 1, 0]) == 1)\n\t@test(candidate([1, 1]) == nothing)\n\t@test(candidate([-35, 34,\
  \ 12, -45]) == -35)\nend\n"
completions: ["    if lst.size == 0 \n        return nothing \n    end\n    return\
    \ if lst[1] < lst[1]\n        lst[1] \n    else\n        lst[1] + 1\n    end\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nJust a warning: your function is supposed\
    \ to return the 2nd smallest element of the vector. This is not the case when\
    \ you have more than one element in the list.\n<|/ c |>\n<| c |>\nThis fails for\
    \ an empty vector.\n<|/ c |>\n<| c |>\nIt works for me (Julia 1.0.3). How do you\
    \ test it?\n<|/ c |>\n<| a dscore=1 tags=julia |>\nThe Julia standard library\
    \ has the nsmallest() and nsmallest() functions. Here is a simple example of a\
    \ function that implements this behavior:\n<code>", "    if lst == [] \n     \
    \   return nothing \n    end\n    smallest = lst[1]\n    for val in lst[2:end]\
    \ \n        if val < smallest \n            smallest = val \n        end \n  \
    \  end \n    return smallest \nend \n</code>\n<|/ a |>\n<| c |>\nCan you explain\
    \ why you decided to use `for val in lst[2:end]`? What's the advantage of that?\n\
    <|/ c |>\n<| c |>\nSure, it's an efficient way to iterate over all elements except\
    \ the first one. [You can find out more here](https://stackoverflow.com/questions/627066/why-does-the-range-function-from-python-iterate-from-the-end).\n\
    <|/ c |>\n<| a |>\nHere's a more efficient solution for finding both the second\
    \ and third smallest number in a vector of numbers. \n<code>\ndef find_smallest_3rd_max(nums)\n\
    \    third_max = (nums[1] + nums[2]) / 2\n    return first_max = (nums[1] + nums[2]),\
    \ third_max\nend\n</code>\n<|/ a dscore=2 tags=algorithm,julia,sorting |>\n<|\
    \ c |>\nThis does not work if the input is empty\n<|/ c |>\n<| c |>\nWhat about\
    \ negative numbers?\n<|/ c |>\n<| a dscore=1 |>\nThe fastest solution for finding\
    \ the second smallest element is given by Peter de Rivaz.\nFinding the 3rd smallest\
    \ element is given by the following function -\n<code>", "    smallest = min_elem(lst)\n\
    \    smallest_idx = findfirst(lt -> lt < smallest, lst)\n    if smallest_idx ==\
    \ nothing \n        return nothing\n    elseif smallest_idx == 1\n        return\
    \ smallest\n    else\n        return lst[smallest_idx+1]\n    end\nend\n</cell>\n\
    <code language=julia-0.6>\n\"\"\"\n    You are given a vector of integers.\n \
    \   Write a function next_largest() that returns the 3rd largest element of the\
    \ vector.\n    Return nothing if there is no such element.\n    >>> next_largest([1,\
    \ 2, 3, 4, 5])\n    4\n    >>> next_largest([5, 1, 4, 3, 2])\n    3\n    >>> next_largest([])\n\
    \    nothing\n    >>> next_largest([1, 1])\n    nothing\n    \"\"\"", "    if\
    \ size(lst) == 0\n        nothing\n    else\n        if lst[1] < lst[2]\n    \
    \        lst[1]\n        else\n            lst[2]\n        end\n    end\nend",
  "    if lst == []\n        return nothing\n    smallest = lst[1]\n    last = lst[1]\n\
    \    for i in lst[2:end]\n        if i < smallest \n            smallest = i\n\
    \            last = i\n        end\n    end\n    return smallest\nend\n</cell>\n\
    <code language=julia-0.6>\n\"\"\"\nWrite a function that finds the kth smallest\
    \ element in a vector of numbers.\nThe vector is sorted in ascending order. If\
    \ the vector is empty, then return nothing.\n>>> kth_smallest([1, 2, 3, 4, 5],\
    \ 2)\n3\n>>> kth_smallest([1, 2, 3, 4, 5], -1)\nnothing\n>>> kth_smallest([1,\
    \ 2, 3, 4, 5], 4)\n4\n\"\"\"", "    if length(lst) < 2\n        return nothing\n\
    \    else \n        smallest = lst[1]\n        lst.remove(smallest)\n        lst.remove(min(nth(lst),smallest))\n\
    \        lst.remove(max(nth(lst),smallest))\n        return smallest\nend", " \
    \   smallest = min(lst)\n    if smallest == lst[1]\n        return smallest\n\
    \    elseif smallest == lst[-2]\n        return smallest\n    else\n        return\
    \ nothing\n    end\nend\n</cell>\n<text>\nNext Smallest Number: Vector Subset",
  "    if length(lst) == 0 || lst[1] == nothing\n        nothing\n    else\n     \
    \   lst[1]\n    end\nend\n</cell>\n<code language=julia-1.3>\nnext_smallest([])\n\
    </cell>\n<code language=julia-1.3>\nnext_smallest([5,1,4,3,2])\n</cell>\n<code\
    \ language=julia-1.3>\nnext_smallest([7,9,2,1])\n</cell>\n<text>\nExercise: Implement\
    \ the function next_biggest. This function returns the 2nd biggest element of\
    \ the vector.", "    if isempty(lst)\n        nothing\n    else\n        if lst[1]\
    \ > lst[2]\n            nothing\n        else\n            if lst[1] < lst[2]\n\
    \                lst[2]\n            else\n                nothing\n         \
    \   end\n        end\n    end\nend\n</code>\n<|/ a |>\n<| a dscore=0 tags=julia\
    \ |>\n<code>", "    if isempty(lst)\n        return nothing\n    end\n    index\
    \ = findfirst(isequal(lst[1]),lst[2:end])\n    if index == nothing\n        error(\"\
    there is no such 2nd smallest element\")\n    end\n    return lst[index]\nend",
  "    # Your code here\n    return nothing\nend\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ dscore=0 |>\nThe following solution is in Julia and is also pretty fast on large\
    \ vectors.\n<code>", "    if length(lst) == 0\n        nothing\n    elseif length(lst)\
    \ == 1\n        lst[1]\n    elseif length(lst) == length(lst)\n        lst[1]\n\
    \    else\n        minimum(lst)\n    end\nend\n</code>\n<|/ a tags=list,sorting,julia\
    \ dscore=1 |>\n<| a tags=list,sorting,julia |>\nA different solution that will\
    \ work with any data type. It will return the index in the array of the minimum\
    \ value.\n<code>", "    if lst == []\n        nothing\n    elseif length(lst)\
    \ == 1 \n        lst[1]\n    else\n        min!(lst)\n    end\nend", "    pos\
    \ = findfirst(x->x<lst[1], lst)\n    if pos == nothing\n        return nothing\n\
    \    elseif pos==length(lst)\n        return lst[pos]\n    elseif pos > length(lst)\n\
    \        error(\"list too short\")\n    end\n    return lst[pos+1]\nend", "  \
    \  \n    if lst[1] == lst[2]\n        nothing\n    elseif lst[1] < lst[2]\n  \
    \      lst[1]\n    else\n        lst[2]\n    end\nend", "    if isempty(lst) \n\
    \        return nothing\n    \n    smallest = head(lst)\n    \n    for elem in\
    \ lst[2:end]\n        if elem < smallest \n            smallest = elem \n    \
    \    end\n    end\n    return smallest\nend\n</cell>\n<code language=julia-0.6>",
  "    if lst == []\n        return nothing\n    idx = minimum(lst)\n    lst[idx]\
    \ = nothing\n    return lst[idx]", "    if length(lst) == 0\n        nothing\n\
    \    elseif length(lst) == 1\n        lst[1]\n    else\n        if lst[1] <= lst[2]\n\
    \            lst[1]\n        else\n            lst[2]\n        end\n    end\n\
    end\n</cell>\n<text>\nLet's check our implementation:", "    if length(lst) <\
    \ 1 \n        nothing\n    elseif length(lst) == 1 \n        lst[1]\n    elseif\
    \ lst[1] <= lst[2]\n        lst[1]\n    else\n        lst[2]\n    end\nend\n</code>\n\
    <|/ a |>\n<| a tags=julia,list,sorting |>\nHere's a solution that doesn't require\
    \ sorting.\n<code>", "    if length(lst) == 0 \n        return nothing \n    \n\
    \    if length(lst) == 1 \n        return lst[1] \n    \n    smallest = lst[1]\
    \ \n    lst = lst[2:end] \n    \n    for i in lst\n        if i < smallest \n\
    \            smallest = i\n        else \n            return smallest\n      \
    \  end\n    end\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| a |>\nA bit more\
    \ efficient solution:\n<code>\njulia> function next_smallest(lst::Vector{Int64})::Union{Int64,\
    \ Nothing} \n           for i in lst\n               if i <= minimum(lst)\n  \
    \                 return i\n               end\n           end\n           return\
    \ nothing\n       end\nnext_smallest (generic function with 1 method)", "    for\
    \ x in lst\n        if x < lst[1]\n            return x\n        end\n    end\n\
    \    return nothing\nend\n</cell>\n<code language=julia-1.5>\n# Practice runs\n\
    @code_warntype next_smallest([1, 2, 3, 4, 5])\n@code_warntype next_smallest([5,\
    \ 1, 4, 3, 2])\n@code_warntype next_smallest([])\n@code_warntype next_smallest([1,\
    \ 1])\n</cell>\n<text>\nThe function next_smallest returns the 2nd smallest element\
    \ in the vector lst if lst has at least 2 elements. Otherwise, nothing is returned.",
  "    if lst.size == 1 \n        return nothing\n    lst = copy(lst)\n    sort!(lst)\n\
    \    \n    if lst[1] == lst[2] \n        lst[1] = nothing\n        return nothing\n\
    \    \n    i = lst.size - 2\n    \n    while i >= 0\n        if lst[i] > lst[i\
    \ + 1]\n            lst[i] = nothing\n            return nothing\n        i -=\
    \ 1\n    return lst[1]\nend", "    largest = max_index(lst)\n    if largest ==\
    \ -1\n        return nothing\n    smallest = lst[largest]\n    lst = lst[largest+1:]\n\
    \    return smallest", "    if length(lst) == 0\n        return nothing\n    end",
  "    if length(lst == 0) == false \n        nothing\n    elseif length(lst == 1)\
    \ == true \n        return lst[1] \n    elseif lst[1] < lst[0] \n        return\
    \ next_smallest(lst[2:end]) \n    else \n        return next_smallest(lst[1:end-1])\
    \ \n    end\nend\n</cell>\n<text>\nExercise 8\nWrite a function that returns the\
    \ index of the Nth smallest element of a given vector.", "    if length(lst) ==\
    \ 0 \n        return nothing \n    else \n        return lst[1] \n    end\nend",
  "    if length(lst) == 0 \n        return nothing\n    \n    if lst[1] < lst[end]\n\
    \        return nothing\n    else\n        return lst[1]\n    end\nend", "   \
    \ \n    if lst == []\n        nothing\n    else\n        next1 = find_smallest(lst)\n\
    \        length(lst) == 1 ? next1 : nothing\n    end\nend", "    if lst==[] \n\
    \        return nothing \n    end\n    smallest = lst[1]\n    for x in lst[2:length(lst)]\
    \ \n        if x < smallest \n            smallest = x \n        else \n     \
    \       break\n    end\n    return smallest \nend\n</code>\nThe for loop is necessary\
    \ because you cannot guarantee that the vector is not empty and the iterator won't\
    \ iterate over itself.\n<|/ a tags=julia dscore=0 |>\n<| c |>\nThis doesn't work\
    \ if you use `findfirst`. `findfirst` returns `nothing`, so you cannot use it\
    \ to check whether an element was found. You would need to use `if findfirst(...)\
    \ <> nothing ` and then check `if x < smallest` to find the 2nd smallest element.\n\
    <|/ c |>\n<| c |>\n: You're right. I didn't read the documentation carefully enough\
    \ and assumed `findfirst` returned `nothing` when it didn't find anything. I'll\
    \ edit my answer accordingly.\n<|/ c |>\n<| a dscore=0 |>\nSince Julia 0.5 you\
    \ can use:\n<code>\njulia> arr = [2, 3, 1, 3, 2, 5, 1, 3]\n7-element Vector{Int64}:\n\
    \ 2\n 3\n 1\n 3\n 2\n 5\n 1\n 3", "    if length(lst) == 0 || length(lst) == 1\
    \ \n        return nothing\n    local smallest = lst[1]\n    lst[1] = lst[end]\n\
    \    lst[end] = smallest\n    return smallest\nend\n</cell>\n<code language=julia-1.1>",
  "    first=lst[1]\n    last=lst[end]\n    if first < last\n        middle=first+last/2\n\
    \        if middle < lst[1]\n            return middle\n        elseif middle\
    \ > lst[end]\n            return middle\n        else\n            return nothing\n\
    \    end\n    return first\nend\n</code>\nI wrote the code with the idea of returning\
    \ nothing, to return the first element if there is none, and then returning the\
    \ 2nd smallest, to handle the case of an empty vector. I don't know if I understand\
    \ your question correctly...\n<|/ a tags=julia,algorithm dscore=1 |>\n<| a |>\n\
    <code>\njulia> function next_smallest(lst::Vector{Int64})::Union{Int64, Nothing}\n\
    \           if !isempty(lst)\n               return lst[findmin(lst)+1]\n    \
    \       else\n               return nothing\n           end\n       end\nnext_smallest\
    \ (generic function with 1 method)", "    smallest = lst[1]\n    if isnothing(smallest)\n\
    \        smallest = get_smallest(lst)\n    end\n    smallest\nend", "    if length(lst)\
    \ == 0\n        nothing\n    else\n        lst[findnext(lst)]\n    end\nend\n\
    </code>\n<|/ a |>\n<| c |>\nCan you please tell me where is the documentation\
    \ for findnext? It is not in Julia documentation and I searched online and couldn't\
    \ find it. Thanks!\n<|/ c |>\n<| c |>\nI believe it's been around forever, but\
    \ I can't find the doc now. Try typing `findnext?` in the Julia REPL.\n<|/ c |>\n\
    <| c |>\nIt's not in the latest Julia version (1.1) but I will try and add it\
    \ soon. Also, it's in the \"Core Library\" section of the [docs](http://docs.julialang.org/en/stable/manual/faq/#what-is-the-core-library)\
    \ you linked to.\n<|/ c |>\n<| c |>\nfindnext doesn't work in the latest version\
    \ of Julia 1.1 either. findnext is undefined. :-(\n<|/ c |>\n<| c |>\nSorry, I\
    \ don't have the docs at the moment :(\n<|/ c |>\n<| a dscore=3 |>\n<code>\njulia>\
    \ minimum(collect(1:5))\n2\njulia> minimum(collect(2:6))\n2\njulia> minimum(collect(3:7))\n\
    2\njulia> minimum(collect(4:8))\n3\njulia> minimum(collect(5:9))\n5\njulia> minimum(collect(10:12))\n\
    10\njulia> minimum(collect(11:15))\n11\njulia> minimum(collect(16:20))\n11\njulia>\
    \ minimum(collect(20:25))\n20\njulia> minimum(collect(25:30))\n30\njulia> minimum(collect(31:35))\n\
    20\njulia> minimum(collect(36:40))\n30\njulia> minimum(collect(41:45))\n45\njulia>\
    \ minimum(collect(46:50))\n30\njulia> minimum(collect(51:55))\n55\n</code>\n<|/\
    \ a tags=julia,arrays |>\n<| a dscore=3 |>\nI liked this answer but found it a\
    \ bit complicated. Here's an alternative:\n<code>", "    if is_empty(lst)\n  \
    \      return nothing\n    smallest = lst[1]\n    for (i, el) in enumerate(lst)\n\
    \        if el < smallest\n            smallest = el\n        elseif el == smallest\n\
    \            if i == 1\n                return smallest\n            else\n  \
    \              lst[1] = smallest\n            end\n        end\n    end\nend",
  "    if lst==[]\n        return nothing\n    end\n    return lst[1]\nend", "   \
    \ lst = sort(lst)\n    if length(lst) == 0 \n        return nothing\n    end\n\
    \    return lst[1] \nend", "    if length(lst) == 0 \n        return Nothing\n\
    \    end\n    smallest = minimum(lst)\n    return nothing if smallest==lst[1]\
    \ \n    if smallest == lst[1] \n        return smallest\n    end\n    if smallest\
    \ == lst[2]\n        return smallest\n    end\n    if smallest == lst[3]\n   \
    \     return smallest\n    end\n    if smallest == lst[4]\n        return smallest\n\
    \    end\n    if smallest == lst[5]\n        return smallest\n    end\n    return\
    \ nothing\nend\n</code>\nThis works because when lst[1] is compared to lst[2]\
    \ (the third value), lst[2] is larger than lst[1], and that means lst[2] is smaller\
    \ than the smallest value among all the values we've seen so far, so that's what\
    \ we return.  \nIf this doesn't make sense to you, then the answer is that you\
    \ need to do some more studying of what a sorting algorithm is, and how it works.\
    \ \nGood luck!\n<|/ a |>\n<| c |>\nThanks for the answer ! Can you please explain\
    \ what happens behind the scene of the function you wrote ?\n<|/ c |>\n<| c |>\n\
    I just edited my answer to show you a little bit about how a sorting algorithm\
    \ works.  I hope this helps.  I recommend that you try to figure this out on your\
    \ own, since it seems like the type of problem you're having is pretty basic.\
    \  You might want to try googling a sorting algorithm and then asking if anyone\
    \ else has any questions.\n<|/ c |>\n<| c |>\nThanks ! But I don't get what happens\
    \ under the hood. The function you wrote works only when the elements are sorted\
    \ ascending. How can you make the function work when for example a list is [3,2,1,4,5].\
    \ Can you please elaborate more on how the function is working ?\n<|/ c |>\n<|\
    \ c |>\nYou didn't say that in your question.  I assume that you meant that you\
    \ want it to be able to handle unsorted data.  That's a more difficult problem,\
    \ since unsorted data has different behavior than sorted data.  So to handle unsorted\
    \ data, you simply need to find the smallest element that you've seen so far,\
    \ then check if the current value is smaller than that.  So you need a function\
    \ that will check if a value is smaller than the next value that you've seen so\
    \ far.\n<|/ c |>\n<| c |>\nSo to handle unsorted data, you need a function that\
    \ will check if the value at `i` is smaller than the next value that you've seen\
    \ so far.  So you need a `next_smallest` function that will check if the current\
    \ value is smaller than the next value that you've seen so far.  So you need a\
    \ function that will check if a value is smaller than the next value that you've\
    \ seen so far.\n<|/ c |>\n", "    if length(lst) <= 1 \n        return nothing\
    \ \n    end", "    if length(lst) == 0 \n        return nothing\n    end\n   \
    \ smallest_index = findmin(lst)[2]\n    lst[smallest_index] = nothing\n    return\
    \ lst[smallest_index]\nend", "    \n    idx = 1\n    smallest_i = lst[idx]\n \
    \   while idx <= length(lst) && lst[idx] < smallest_i\n        smallest_i = lst[idx]\n\
    \        idx += 1\n    end\n    return smallest_i\nend", "    smallest = minimum(lst)\n\
    \    return lst[smallest] if smallest==length(lst) else nothing\nend\n</code>\n\
    <|/ a dscore=2 tags=julia |>\n<| c |>\nHi, I really appreciate the explanation.\
    \ Could you possibly explain the function a little more? I don't understand how\
    \ the if-else statement works. Thanks.\n<|/ c |>\n<| c |>\nThe function just returns\
    \ `nothing` if there is no such element. `if-else` is just a fancy way of writing\
    \ `if` followed by a colon (`:`) followed by the else clause.\n<|/ c |>\n<| c\
    \ |>\nThanks again, I'll try to understand it better myself in the future.\n<|/\
    \ c |>\n<| a dscore=1 |>\nThis question really depends on how you implement your\
    \ data structures, what you want to achieve, etc. There are lots of ways to implement\
    \ a priority queue in Julia, but a common data structure is to use Array{Union{Nothing,Int64},1}.\
    \ The key here is the type Union{Nothing,Int64}, which basically means either\
    \ nothing (nothing), or a Int64. The array is initialized with the first element\
    \ set to the lowest priority value, and for each subsequent element we check if\
    \ it is lower than the highest priority value. \n<code>", "    \n    smallest_index\
    \ := 1\n    while smallest_index <= length(lst)-1\n        if lst[smallest_index]\
    \ < lst[smallest_index+1]\n            break\n        end\n        smallest_index\
    \ += 1\n    end\n    if smallest_index == length(lst)\n        nothing\n    elseif\
    \ smallest_index > length(lst)-1\n        lst[smallest_index]\n    else\n    \
    \    lst[smallest_index]\n    end\nend", "    if length(lst) == 0 \n        nothing\n\
    \    elseif length(lst) == 1 \n        lst[1]\n    else\n        smallest = lst[1]\n\
    \        lst = lst[2:end]\n        for e in lst\n            if e < smallest \n\
    \                smallest = e \n        end\n        smallest\n    end\nend\n\
    </cell>\n<cell>\n# Run this cell to check your answer\ntest_next_smallest()\n\
    </cell>\n<text>\nSolution\nRun the cell below to test your function against a\
    \ small test case.", "    if length(lst) == 0 \n        nothing\n    elseif length(lst)\
    \ == 1 \n        lst[1]\n    elseif length(lst) == 2 \n        lst[1]\n    else\n\
    \        lst[2]\n    end\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n`nothing`\
    \ is just a placeholder for \"no value\", it's not a special keyword or anything\
    \ like that. Your function `next_smallest` doesn't return anything in the case\
    \ where there is no second smallest value, so you're not going to be able to call\
    \ that function on empty lists anyway, and I guess you're not going to be able\
    \ to call your function on empty lists if you just replace `nothing` with `nothing`\
    \ in your function anyway. Not that `nothing` is necessarily a special keyword,\
    \ `nothing` is just one of the default return values when nothing is returned.\n\
    <|/ c |>\n<| c |>\nI guess the point of the exercise is to make you think about\
    \ the case where `length(lst) == 0`, but even then you're not going to be able\
    \ to call that function on empty lists anyway, and I guess you're not going to\
    \ be able to call your function on empty lists if you just replace `nothing` with\
    \ `nothing` in your function anyway. Not that `nothing` is necessarily a special\
    \ keyword, `nothing` is just one of the default return values when nothing is\
    \ returned.\n<|/ c |>\n<| c |>\nThis is just an exercise for me to improve my\
    \ understanding of Julia language. If nothing is a special keyword then, in what\
    \ case would it be different from other keywords? If it is not a keyword then\
    \ how do we differentiate between a keyword and a reserved word (like nothing)?\n\
    <|/ c |>\n<| a dscore=1 tags=julia |>\nYou can do this in one line without recursion:\n\
    <code>\njulia> function next_smallest(x::Vector{Int})\n            if (length(x)==1)\n\
    \                x[1]\n            elseif (length(x)==2)\n                x[1]\n\
    \            else\n                x[1]\n            end\n        end\nnext_smallest\
    \ (generic function with 1 method)", "    if length(lst) == 0\n        return\
    \ nothing\n    end\n    minimum = minimum(lst)\n    rest = lst[minimum+1 :end]\n\
    \    nothing\nend\n</cell>\n<text>\nNext, implement next_largest_index() that\
    \ returns the index of the 2nd largest element in the vector.\nReturn nothing\
    \ if there is no such element.\nHint: use the function next_smallest()", "   \
    \ if lst == []\n        return nothing\n    i = Int64(length(lst))\n    smallest\
    \ = i\n    while i!=0 && smallest==i\n        smallest = i-1\n        i = i-1\n\
    \    end\n    return lst[smallest]\nend", "    if length(lst) == 0 return nothing\
    \ \n    el = lst[1]\n    if el < el[1] return nothing else lst[1] \n    \n   \
    \ return lst[2] \nend\n</code>\n<|/ a dscore=2 tags=julia,sorting,vector,arrays\
    \ |>\n<| c |>\nThank you for your response! I tried to implement this code into\
    \ my function but I am getting errors. I'll try again when I get home! Thank you!\n\
    <|/ c |>\n<| a tags=julia,sorting,vector,arrays |>\nI implemented the next_smallest\
    \ function and tested it. For some reason it did not work (my guess is probably\
    \ the function definition was wrong somehow). So, I wrote my own version which\
    \ works for both cases where there is one element in the vector and where there\
    \ is more than one element in the vector. \n<code>", "    if length(lst) == 0\
    \ \n        nothing \n    else \n        lst[1] \n    end\nend\n</cell>\n<code\
    \ language=julia-0.5>", "    if lst == []\n        return nothing\n    else \n\
    \        minimum = lst[1]\n        idx = 2\n        for i in lst[2:end]\n    \
    \        if i <= minimum\n                minimum = i\n                idx = 1\n\
    \            elseif minimum > i\n                break\n        end\n        return\
    \ minimum\n    end\nend\n</cell>\n<code language=julia-1.6>", "    if length(lst)\
    \ == 1 \n        nothing\n    elseif length(lst) == 0 \n        nothing\n    else\n\
    \        lst[findmin(lst)]\n    end\nend\n</code>\n<|/ a |>\n<| a dscore=1 |>\n\
    This is my solution:\n<code>", "    n = length(lst)\n    if n == 0\n        return\
    \ nothing\n    i = n - 1\n    while i >= 0 && !(lst[i] < lst[i+1])\n        i\
    \ = i - 1\n    return lst[i + 1]", "    if lst == []\n        return nothing\n\
    \    end\n    smallest = lst[1]\n    for i in 2:length(lst)\n        if lst[i]\
    \ < smallest\n            smallest = lst[i]\n        end\n    end\n    return\
    \ smallest\nend\n</cell>\n<code language=julia-0.5>\nnext_smallest([1, 2, 3, 4,\
    \ 5])\n</cell>\n<code language=julia-0.5>\nnext_smallest([5, 1, 4, 3, 2])\n</cell>\n\
    <code language=julia-0.5>\nnext_smallest([])\n</cell>\n<code language=julia-0.5>\n\
    next_smallest([1, 1])\n</cell>\n<text>\nExercise 3", "    if lst.length > 0\n\
    \        return lst[findnext(lst)]\n    else\n        nothing\nend\n</code>\n\
    <|/ a tags=julia dscore=1 |>\n<| a |>\nThis is not a straightforward question.\
    \ But you can try this\n<code>", "    if isempty(lst)\n        nothing\n    elseif\
    \ length(lst) == 2\n        lst[1]\n    elseif lst[1] < lst[2]\n        lst[1]\n\
    \    else\n        lst[2]\n    end\nend", "    i = Vector{Int64}(length(l))\n\
    \    for i in 1:length(lst)\n        j = i+1\n        while j < length(lst)\n\
    \            if lst[i]>lst[j]\n                j+=1\n            else\n      \
    \          i=j\n                break\n            end\n        end\n    end\n\
    \    nothing\nend", "    smallest_idx=1\n    if lst==[]\n        nothing\n   \
    \ else\n        smallest_idx=min(lst)\n        lst[smallest_idx]\n    end\nend\n\
    </cell>\n<text>\nThe smallest_idx=1 line is necessary as we are using next_smallest\
    \ on a list of Int64 data type. Note how this line is at the top of the function\
    \ definition, meaning that the function is only defined when the smallest_idx\
    \ line is reached.", "    if length(lst) == 0\n        return nothing\n    end\n\
    \    \n    smallest_idx = findfirst(lst[1:end-1], minimum(lst[1:end-1]))\n   \
    \ if smallest_idx == nothing\n        return nothing\n    elseif smallest_idx\
    \ == length(lst)\n        return lst[smallest_idx-1]\n    else\n        return\
    \ lst[smallest_idx-1]\n    end\nend", "    idx = 1\n    while idx<length(lst)\n\
    \        val = lst[idx]\n        if val < lst[idx - 1]\n            lst[idx] =\
    \ lst[idx - 1]\n            lst[idx - 1] = val\n            idx -= 1\n       \
    \ else\n            break\n        end\n    end\n    return nothing\nend", " \
    \   smallest = nothing\n    if length(lst) == 0 return nothing\n    \n    for\
    \ i = length(lst .+ 1) - 2 ; i >= 0 ; i-- \n        smallest = lst[i]\n      \
    \  break\n    \n    if smallest == nothing \n        return nothing\n    \n  \
    \  return smallest\n</code>\nTesting\n<code>\njulia> next_smallest([1, 5, 1, 4,\
    \ 3, 2])\n2\n</code>\n<|/ a |>\n<| a |>\nA possible solution involving nothing\
    \ (as suggested in other answers):\n<code>", "    if length(lst) == 0 \n     \
    \   nothing\n    elseif length(lst) == 1 \n        lst[1]\n    elseif length(lst)\
    \ == 2 \n        lst[1]\n    else\n        let y = lst[1]\n        lst[1] = lst[2]\n\
    \        lst[2] = y\n        y \n    end\nend\n</cell>\n<code language=julia-0.5>",
  "    if length(lst) == 0 return Nothing\n    else if length(lst) == 1 return lst[1]\n\
    \    else if lst[1] < lst[2]\n        return lst[1]\n    else\n        return\
    \ lst[2]\nend\n\"\"\"\n    You are given a vector of integers and a target number.\n\
    \    Return a boolean indicating whether the target is present in the vector.\n\
    \    >>> contains_target([1, 2, 3, 4, 5], 5)\n    true\n    >>> contains_target([1,\
    \ 2, 3, 4, 5], 6)\n    false\n    >>> contains_target([5, 1, 4, 3, 2], 2)\n  \
    \  true\n    >>> contains_target([5, 1, 4, 3, 2], 1)\n    false\n    >>> contains_target([5,\
    \ 1, 4, 3, 2], 4)\n    false\n    >>> contains_target([], 1)\n    false\n    \"\
    \"\"", "    if length(lst) == 0\n        return nothing\n    else if length(lst)\
    \ == 1\n        return lst[1]\n    end\n    i = length(lst)\n    while i <= length(lst)\
    \ - 1\n        if lst[i-1] < lst[i]\n            i = i - 1\n        else\n   \
    \         i = i + 1\n        end\n    end\n    return lst[i]\nend", "    smallest\
    \ = minimum(lst)\n    if smallest == nothing\n        return\n    smallest_index\
    \ = findfirst(lt -> lt < smallest, lst)\n    smallest_value = lst[smallest_index]\n\
    \    smallest_index -= 1\n    if smallest_index > 0\n        smallest_value =\
    \ lst[smallest_index]\n        smallest_index -= 1\n        if smallest_index\
    \ > 0\n            smallest_value = lst[smallest_index]\n            smallest_index\
    \ -= 1\n        end\n    end\n    return smallest_value\nend\n</code>\n<|/ a |>\n\
    <| a dscore=1 tags=julia,list |>\nThis can be solved using tail recursion.\n<code>",
  "    lst = sort(lst)\n    if length(lst) == 0 \n        return nothing \n    else\
    \ \n        return lst[1]\n    end\nend", "    if lst.length() == 0\n        return\
    \ Nothing\n    return lst[findmin(lst)]\nend", "    if length(lst) == 0 \n   \
    \     Nothing\n    elseif length(lst) == 1\n        lst[1]\n    else\n       \
    \ nextsmallest(lst[1:end-1], lst[1])\n    end\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=0 |>\nThis question was asked earlier. Anyone else having this issue\
    \ would like to know.\n<code>", "    if length(lst) == 0 \n        return Nothing\n\
    \    else \n        sorted = sort(lst)\n        index = findfirst(item -> item\
    \ > sorted, sorted)\n        if index != nothing \n            return sorted[index\
    \ + 1]\n        else \n            return Nothing\n    end\nend\n</code>\n<|/\
    \ a dscore=4 |>\n<| c |>\nIf you have `[5,1,4,3,2]` this code returns `2` instead\
    \ of `3` since `4` comes before the 2nd smallest value.\n<|/ c |>\n<| c |>\nYou're\
    \ right that this is a flawed solution, but I suspect it's more correct than some\
    \ of the others and that it might be better to just copy the original list instead\
    \ of using the `sorted` function.\n<|/ c |>\n<| c |>\n`findfirst` returns the\
    \ index of the found element. If it's not found, `nothing` is returned.\n<|/ c\
    \ |>\n<| c |>\nNote that this approach does not work for lists containing repeated\
    \ values. For a list that has repeated values, it will only find the first occurrence.\n\
    <|/ c |>\n<| a dscore=4 |>\n<code>", "    smallest, second = smallest_second(lst)\n\
    \    if smallest == nothing\n        return nothing\n    end\n    lst = lst .<\
    \ smallest\n    lst = lst.-1 .> second\n    return nothing\nend", "    if len(lst)\
    \ == 0 \n        return nothing\n    \n    # return nothing if there is only 1\
    \ item\n    if length(lst) == 1 \n        return nothing\n    \n    if lst[1]\
    \ < lst[2] \n        return nothing\n    \n    return lst[1]\nend\n</cell>\n<code\
    \ language=julia-1.5>\nnext_smallest([5, 1, 4, 3, 2])\n</cell>\n<text>\nWrite\
    \ a function next_biggest() that returns the 2nd biggest element of the vector.\n\
    Return nothing if there is no such element.\n    >>> next_biggest([2, 5, 1, 4,\
    \ 3])\n    4\n    >>> next_biggest([1, 5])\n    nothing\n    >>> next_biggest([])\n\
    \    nothing\n    >>> next_biggest([2, 1])\n    nothing\n    \"\"\"", "    if\
    \ lst == []\n        return nothing\n    end\n    return lst[findfirst(lst .<\
    \ lst[end-1])+2]\nend\n</cell>\n<code language=julia-1.0>\n@assert next_smallest([1,\
    \ 2, 3, 4, 5]) == 2\n@assert next_smallest([5, 1, 4, 3, 2]) == 2\n@assert next_smallest([])\
    \ == nothing\n@assert next_smallest([1, 1]) == nothing\n</cell>\n<text>\nExercise\
    \ 9\nWrite a function that takes an integer vector and returns true if and only\
    \ if it is a monotonically increasing vector.", "        smallest = nothing\n\
    \        for elem in lst\n            smallest = elem if smallest == nothing ||\
    \ elem < smallest end\n        end\n        smallest\n    end\n\"\"\"\n    You\
    \ are given a vector of integers.\n    Write a function next_largest() that returns\
    \ the 2nd largest element of the vector.\n    Return nothing if there is no such\
    \ element.\n    >>> next_largest([1, 2, 3, 4, 5])\n    4\n    >>> next_largest([5,\
    \ 1, 4, 3, 2])\n    4\n    >>> next_largest([])\n    nothing\n    >>> next_largest([1,\
    \ 1])\n    nothing\n    \"\"\"", "    if length(lst) == 1\n        nothing\n \
    \   elseif length(lst) == 2\n        lst[1]\n    else\n        lst[2]\n    end\n\
    end\n</code>\n<|/ a tags=julia dscore=4 |>\n<| a dscore=3 |>\nHere's a more compact\
    \ version, using broadcasting and if:\n<code>\njulia> [if(i==1||i==2||i==3||i==4||i==5||i==6||i==7||i==8)(i+1)else\
    \ nothing end\n7-element Vector{Union{Nothing, Int64}}:\n  nothing\n  nothing\n\
    \  nothing\n  nothing\n  nothing\n  nothing\n  nothing\n  nothing\n  nothing\n\
    \  nothing\n  nothing\n  nothing\n  nothing\n</code>\n<|/ a tags=julia |>\n<|\
    \ a tags=julia |>\nI did something like this:\n<code>", "    biggest = minimum(lst)\n\
    \    smaller = filter(x -> x != biggest, lst)\n    if length(smaller) == 0 \n\
    \        return nothing\n    else\n        return smaller[1]\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert next_smallest([1,4,3,2]) == 2\n@assert next_smallest([6,4,3,2])\
    \ == 2\n@assert next_smallest([1,2,3,4,5]) == 2\n@assert next_smallest([5,1,4,3,2])\
    \ == nothing\n@assert next_smallest([]) == nothing\n</cell>\n<text>\nQuestion\
    \ 2. (20 points)\nWrite a Julia function that generates an array of numbers from\
    \ 0 to 9. Then, write a function to find the index of two consecutive elements\
    \ in that array that have the same value.", "    \"\"\"\n    You are given a vector\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the vector.\n    Return nothing if there is no such element.\n  \
    \  >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4,\
    \ 3, 2])\n    2\n    >>> next_smallest([])\n    nothing\n    >>> next_smallest([1,\
    \ 1])\n    nothing\n    \"\"\"", "    if length(lst == 0)\n        nothing\n \
    \   else\n        lst[find(lst .== sort(lst)[end])+1]\n    end\nend\n</cell>\n\
    <text>\nNotice: this time our function takes advantage of the function sort()\
    \ in the Array package, which performs a sorting operation on the vector.", " \
    \   if is_empty(lst)\n        return nothing\n    else\n        smallest_index\
    \ = findmin(lst)[1]\n        if smallest_index == 1\n            return lst[1]\n\
    \        elseif smallest_index == 2\n            return nothing\n        else\n\
    \            return lst[smallest_index+1]\n        end\n    end\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 |>\nHere is another approach:\n<code>", "   \
    \ if length(lst_)>0\n    i = lst_[1]\n    i = i + 1 while lst_[i] < i\n    if\
    \ i == length(lst)\n        return nothing\n    else\n        return i\n    end\n\
    end\n</code>\n<|/ a tags=sorting,arrays,julia |>\n<| a |>\nHere is my solution\
    \ in Julia 1.0\n<code>", "     if length(lst) == 0\n         return nothing\n\
    \     else\n         return if lst[1] < lst[2]\n                  lst[1]\n   \
    \          else if lst[2] < lst[1]\n                  lst[2]\n             else\n\
    \                  nothing\n     end\nend\n</cell>\n<text>\nExercise 9\nWrite\
    \ a function that takes a list of integers and returns the sum of all elements\
    \ in the list divided by 2.", "    if length(lst) == 0 \n        return nothing\n\
    \    smallest_idx = findmin(lst)[2]\n    if smallest_idx == 0 \n        return\
    \ nothing\n    i = smallest_idx - 1\n    while i <= length(lst)-1 && lst[i] ==\
    \ lst[i-1]\n        i += 1\n    end\n    if i == length(lst)-1\n        return\
    \ nothing\n    else\n        return lst[i]\n    end\nend", "    if length(lst)\
    \ == 0 \n        nothing\n    elseif length(lst) == 1 \n        lst[1]\n    else\n\
    \        smallest_val = lst[1]\n        other_vals = lst[2:end]\n        if smallest_val\
    \ <= other_vals[1] \n            smallest_val = other_vals[1]\n        else\n\
    \            smallest_val = other_vals[1]\n        end\n    end\nend\n</code>\n\
    <|/ a tags=julia,function,arrays |>\n<| a dscore=1 |>\nBased on's answer, I've\
    \ written a vectorized solution:\n<code>", "    if lst == []\n        nothing\n\
    \    elseif length(lst) == 0\n        nothing\n    elseif length(lst) == 1\n \
    \       lst[1]\n    else\n        lst[2]\n    end\nend\n</cell>\n<text>\nnext_largest",
  "    if length(lst)>2\n        mid = round(Int, length(lst)/2)\n        if lst[mid-1]\
    \ < lst[mid]\n            lst[mid], lst[mid-1] = lst[mid-1], lst[mid]\n      \
    \      return nothing\n        end\n    end\n    nothing\nend\n</code>\n<|/ a\
    \ dscore=4 |>\n<| a dscore=3 |>\nI like Luis' answer, but if you want to find\
    \ two smallest values without sorting a list (that might be expensive on large\
    \ lists) you can do this:\n<code>", "    if length(lst) == 0 \n        nothing\n\
    \    else\n        lst[1]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\"\
    \"\"\n    You are given a vector of integers.\n    Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n    Return nothing if\
    \ there is no such element.\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n \
    \   >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n   \
    \ nothing\n    >>> next_smallest([1, 1])\n    nothing\n    \"\"\"", "    if !length(lst)\n\
    \        return nothing\n    smallest = lst[1]\n    if smallest < lst[2]\n   \
    \     smallest = lst[2]\n    end\n    for i in lst[2:end]\n        if i < smallest\n\
    \            smallest = i\n        end\n    end\n    return smallest\nend", " \
    \   if lst.size==0 \n        return nothing \n    \n    smallest=lst[1] \n   \
    \ smallest_i=1 \n    \n    for i in lst[2:end]\n        if i<smallest\n      \
    \      smallest=i \n            smallest_i=smallest_i+1 \n        end\n    end",
  "    largest = maximum(lst)\n    smallest = minimum(lst)\n    index = findfirst(x->x<smallest,lst)\n\
    \    if index==nothing\n        nothing\n    else\n        lst[index+1]\n    end\n\
    end\n</code>\n<|/ a dscore=3 tags=julia,list |>\n<| a dscore=2 |>\nHere is how\
    \ to get the 2nd smallest element in a vector:\n<code>", "    if isempty(lst)\n\
    \        return nothing\n    else\n        if lst[1] < lst[0]\n            return\
    \ lst[1]\n        else\n            return nothing\n        end\n    end\nend\n\
    </cell>\n<text>\nExercise 6\nThe following cell solves the classic problem of\
    \ finding the smallest element in a set.", "    \"\"\"\n    Return the 2nd smallest\
    \ element of the vector, or nothing if no such element\n    \"\"\"\nend\n</cell>\n\
    <code language=julia-1.4>\n# run this cell to check it works on an example\n@test\
    \ next_smallest([5, 1, 4, 3, 2]) == 2\n@test next_smallest([]) == nothing\n@test\
    \ next_smallest([1, 1]) == nothing\n</cell>\n<text>\nThe function is_smallest()\
    \ checks if its argument is the 2nd smallest element of the vector. If it is the\
    \ case, it returns true, otherwise it returns false. Here is how it works on an\
    \ example:", "    \n    smallest2::Vector{Int64} = Vector{Int64}(undef, 0)", " \
    \   \"\"\"\n    Returns the 2nd smallest element of the vector. \n    \"\"\"\n\
    \    i = Int64(1)\n    while i < length(lst)\n        if lst[i] < lst[min(i+1,\
    \ length(lst)-1)]\n            lst[i] = lst[min(i+1, length(lst)-1)]\n       \
    \ else\n            i = i + 1\n        end\n    end\n    return nothing\nend\n\
    </code>\nThis is basically a direct translation of what you want, except it does\
    \ it by iterating over the list twice. \nI find this solution simpler to understand\
    \ than the other one because I do not need to change the list as I am iterating\
    \ over it, so my code does not need to change when I add or remove elements from\
    \ the list. But this also has the downside that if someone changes the loop to\
    \ \n<code>\nfor i in 1:length(lst)\n</code>\nthen my code will fail, which is\
    \ not what you want. \nNote that I did not test this so there may be bugs. You\
    \ might have to tweak it a bit to get it working.\n<|/ a tags=julia,arrays dscore=1\
    \ |>\n<| c |>\nThis is interesting. I thought that Julia would have some builtin\
    \ function that would do that without iterating over the list twice. Maybe I missed\
    \ it though.\n<|/ c |>\n<| c |>\nThere isn't, but it is fairly simple to write.\
    \ It would simply be `idx = Int64(0)`, then `for i in lst; i = lst[idx] if (idx\
    \ == length(lst) || i > lst[idx]); idx += 1; end; lst[idx]`. The point of this\
    \ answer is to show how one could implement this kind of functionality by hand\
    \ in general, and not just for a specific list.\n<|/ c |>\n<| c |>\nI've edited\
    \ my post to include an alternative solution that might fit your needs.\n<|/ c\
    \ |>\n<| a tags=julia,arrays |>\nHere is a more efficient way of doing it.\n<code>\n\
    a = [1,2]\na[findfirst(x->x<2, a)+1] # returns 2\n</code>\nThe trick here is using\
    \ findfirst which returns the index of the first item that passes the condition.\
    \ This will cause your function to be called multiple times, which is why it is\
    \ more efficient.\n<|/ a dscore=0 |>\n<| c |>\nfindfirst does a linear scan over\
    \ the whole vector and then returns the first match, which is not what we want.\
    \ Here it would be more efficient to do a linear scan only over the part that\
    \ does not include the element we are looking for.\n<|/ c |>\n<| c |>\nYes findfirst\
    \ does a linear scan, but if you use a vector that does not contain the element\
    \ you're looking for then it will have to go over the whole vector. This is why\
    \ this is more ", "    \n    nothing_found = Nothing\n    if length(lst) == 0\
    \ \n        return nothing_found\n    end\n    smallest = lst[1]\n    if isless(lst[1],\
    \ lst[2])\n        smallest = lst[1]\n    end\n    \n    for elt in lst[2:end]\n\
    \        if !isless(smallest, elt) \n            smallest = elt\n        end\n\
    \    end\n    return smallest\nend\n</cell>\n<text>\nVectors", "    pos = 1\n\
    \    while pos <= length(lst)\n        if lst[pos-1] > lst[pos]\n            swap!(lst,\
    \ pos-1, pos)\n        end\n        pos = pos + 1\n    end\n    if pos > length(lst)\n\
    \        return nothing\n    end\n    return lst[pos-1]\nend", "    if length(lst)\
    \ == 0 return nothing\n    smallest_index = first_index(lst, min(lst))\n    if\
    \ smallest_index == 0 return Nothing\n    else return lst[smallest_index + 1]\n\
    end \n</cell>\n<code language=julia-1.1>\n\"\"\"\nYou are given a vector of integers,\
    \ each integer is between 1 and a million.\nWrite a function that returns a vector\
    \ of two integers, each between 1 and a million, that form a partition of the\
    \ original vector into two sets with exactly the same elements.\nReturn nothing\
    \ if there is any such partition.\n>>> partition([4, 1, 3, 2])\n([3, 2], [4, 1])\n\
    >>> partition([7, 8, 2, 5, 9, 3, 6, 8, 1, 4, 2, 6, 5, 9, 7])\n([9, 8, 2], [5,\
    \ 3, 6, 1, 4, 2, 8, 9])\n>>> partition([4, 5, 6, 7, 8])\n([], [])\n\"\"\"", " \
    \   \"\"\"\n    \"\"\"\n    for i = 1:length(lst)-1\n        if lst[i] > lst[i+1]\n\
    \            return lst[i+1]\n        end\n    end\n    return nothing\nend\n\
    </code>\n<|/ a |>\n<| c |>\nNice!  But wouldn't this be O(N^2) in complexity?\
    \  You start off by iterating through the vector, and then for each element you\
    \ iterate through the list up to `i`.  Wouldn't you have to worry about finding\
    \ the smallest element in the list after you iterate through the entire vector?\n\
    <|/ c |>\n<| c |>\nThe `if lst[i] > lst[i+1]` part is O(N). As you can see from\
    \ the first part, `i` is at most N-1. So the complexity of iterating through the\
    \ vector is at most N-1 and each iteration of the loop takes O(N) time. Notice\
    \ that in `if lst[i] > lst[i+1]` we're just checking if `i` itself is bigger than\
    \ `i+1`, which is O(1). So in the end it's O(N).\n<|/ c |>\n<| c |>\nAh, I see\
    \ now--the N is the length of the list.  My mistake.  But this still seems O(N^2)\
    \ since you are doing two loops, as opposed to one loop and another O(N) loop.\
    \  (Also, you probably want to use `if lst[i] > lst[i+1]` instead of `if lst[i]\
    \ < lst[i+1]`.)\n<|/ c |>\n<| c |>\nYou're right, I think you're right. I don't\
    \ have a computer to test this now, but I assume that your function will return\
    \ the smallest element of the vector in the first loop, so I guess it's O(N^2)?\
    \ And you're right, the code should be `if lst[i] > lst[i+1]`.\n<|/ c |>\n<| a\
    \ tags=vector,julia,arrays |>\nHere is a one-liner in Julia:\n<code>", "    if\
    \ length(lst) == 0 return nothing\n    smallest = lst[1]\n    lst[1:1] = nothing\n\
    \    return smallest\nend ", "    if lst == []\n        return nothing\n    elif\
    \ length(lst) == 1 || lst[1] == lst[1]\n        return lst[1]\n    end\n    idx\
    \ = 2\n    while idx < length(lst)\n        if lst[idx] < lst[idx + 1]\n     \
    \       return lst[idx]\n        end\n        idx += 1\n    end\nend\n</code>\n\
    <|/ a tags=julia |>\n<| c |>\n`if length(lst) == 1 || lst[1] == lst[1]` is superfluous.\
    \ It will always return `nothing` because `lst[1] == lst[1]` always evaluates\
    \ to `false`. Also `idx <= length(lst)` is superfluous as it also evaluates to\
    \ `true`. See https://stackoverflow.com/questions/46138936/julia-idiom-for-efficient-first-non-missing-value-in-vector\n\
    <|/ c |>\n<| c |>\nThank you for pointing that out. Yes I see that `idx <= length(lst)`\
    \ is redundant.\n<|/ c |>\n<| a dscore=1 |>\nI find this to be a good solution.\
    \ It does not require an external library and it is rather simple to understand:\n\
    <code>", "    smallest = nothing\n    for el in lst\n        if el < smallest\n\
    \            smallest = el\n        elseif el == smallest\n            return\
    \ nothing\n        else\n            return smallest\n        end\n    end\n \
    \   return nothing\nend", "    if lst.length() == 0 \n        nothing \n    else\
    \ \n        lst[1] \n    end\nend\n</cell>\n<code language=julia-0.6>", "    if\
    \ length(lst) == 0\n        nothing\n    else\n        idx = findfirst(i->lst[i]<lst[end],\
    \ lst)\n        if idx != length(lst)\n            lst[idx]\n        else\n  \
    \          nothing\n        end\n    end\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nYeah, that works... I guess I could have just done `idx == length(lst)-1`\
    \ but that looks too un-Julia like. Or just do `idx == 0` and avoid `end` statements\
    \ altogether... Anyway, your answer was very helpful. Thanks!\n<|/ c |>\n<| c\
    \ |>\n`idx == length(lst)-1` is already true in Julia... and `idx == 0` is true,\
    \ since the indexing starts from 1...\n<|/ c |>\n<| c |>\nYeah, I get that but\
    \ I mean the statement I wrote in the comment above. The `if` statement is `if\
    \ idx != length(lst)-1`. If that statement is true, it returns `nothing` but if\
    \ it isn't it returns the element at `idx`. This is what I'm trying to get at\
    \ with my question.\n<|/ c |>\n<| c |>\nBut `idx == length(lst)-1` already is\
    \ true.... `idx == 0` is also true.... Julia is based on C and that `if` statement....\
    \ is `if(idx == length(lst)-1){`\n<|/ c |>\n<| c |>\nYeah, I understand that,\
    \ but that's not what I'm asking. I'm trying to write a function like the one\
    \ I wrote in my question that doesn't use `findfirst` but does what it says in\
    \ the question that I'm asking.\n<|/ c |>\n<| a |>\nYou could use the fact that\
    \ the min function has an optional argument of whether it should use strict ordering.\n\
    <code>\njulia> min([1, 2, 3, 4], true)\n1", "    minimum = min(lst)\n    if minimum\
    \ == lst[1]\n        nothing\n    else\n        minimum\n    end\nend\n</cell>\n\
    <text>\nSolution\nTo solve this problem, we need to first find the smallest element\
    \ in the list and then return either the minimum number or nothing. Here is the\
    \ solution code:", "    first = lst[1]\n    if length(lst) > 2\n        return\
    \ nothing\n    \n    for i = 2:length(lst)\n        if lst[i] < first\n      \
    \      first = lst[i]\n        else\n            return first\n    end\n    return\
    \ first\nend\n</cell>\n<code language=julia-1.0>", "    if length(lst) == 0\n\
    \        return nothing\n    else\n        minimum(lst)\n    end\nend", "    try\n\
    \        largest = maximum(lst, key=abs)\n        smallest = minimum(lst, key=abs)\n\
    \    catch err\n        smallest = nothing\n    end\n    if smallest == nothing\n\
    \        smallest = 0\n    end\n    return smallest \nend", "    if length(lst\
    \ == 0)\n        return nothing\n    smallest = lst[1]\n    for x in lst[2:end]\n\
    \        if x < smallest\n            smallest = x\n        else\n           \
    \ break\n    end\n    nothing\nend\n</cell>\n<text>\nProblem 4.6\nWrite a function\
    \ smallest() that returns the smallest element of a vector.\nReturn nothing if\
    \ the vector is empty.\nReturn a vector of the smallest element and nothing else.\n\
    The smallest element is the 2nd smallest element in the vector,\nthe 3rd smallest\
    \ element is the 3rd smallest element,\n...\nThe nth smallest element is the nth\
    \ smallest element.", "    if length(lst) == 0 return nothing\n    mid = floor(Int,\
    \ length(lst) / 2)\n    if lst[mid] > lst[mid+1] \n        largest = next_smallest(lst[mid+1:end])\n\
    \        smallest = next_smallest(lst[mid:end-1])\n    else \n        largest\
    \ = next_smallest(lst[mid+1:end])\n        smallest = next_smallest(lst[mid:end-1])\n\
    \    end\n    return largest if largest < smallest else smallest\nend\n</cell>\n\
    <text>\nExercise 7\nWrite a function that returns a vector of Boolean values indicating\
    \ whether each of the numbers in a given vector are less than the previous element.\n\
    For example, given [3, 10, 9, 5], it should return [false, false, true, true]",
  "    if length(lst) == 0 \n        return nothing\n    idx = findfirst(i->i<length(lst),lst)\n\
    \    i = idx+1\n    if i == length(lst)\n        return nothing\n    else\n  \
    \      return lst[i]\n    end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n`i` is\
    \ not defined in your function.\n<|/ c |>\n<| c |>\nI tried to add `i` to the\
    \ `findfirst` function but it didn't work. I've edited my answer.\n<|/ c |>\n\
    <| c |>\nOh, that's because it's not an anonymous function.\n<|/ c |>\n<| c |>\n\
    , thank you for pointing out the error. I made the necessary edits.\n<|/ c |>\n\
    <| a tags=julia |>\nYou can use the function findfirst to find the index of an\
    \ element in a vector and index+1 to get the element at that position. \n<code>\n\
    julia> function next_smallest(lst::Vector{Int64})\n             i = findfirst(i->i<length(lst),lst)\n\
    \             i == nothing ? nothing : lst[i]+1\n         end\nnext_smallest (generic\
    \ function with 1 method)", "    if length(lst) == 0 \n        return nothing\
    \ \n    else \n        return sort(lst)[2] \n    end\nend\n\"\"\"\n    You are\
    \ given a vector of integers. Write a function that returns the number of times\
    \ the\n    number \"2\" appears in the vector.\n    >>> count_2([1, 2, 3, 4, 5])\n\
    \    2\n    >>> count_2([2, 3, 4, 5])\n    1\n    >>> count_2([5, 1, 4, 3, 2])\n\
    \    1\n    >>> count_2([])\n    0\n    >>> count_2([1, 1])\n    0\n    \"\"\"",
  "    \"\"\"\n    \n    Your task here is to find the 2nd smallest element in the\
    \ given vector and \n    return the value or return nothing if there are no such\
    \ elements. \n    You cannot use any library functions. \n    Use recursion. \n\
    \    \n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5,\
    \ 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    nothing\n    >>> next_smallest([1,\
    \ 1])\n    nothing\n    \"\"\"\n    if lst[1] < lst[1]\n        lst[1]\n    else\n\
    \        nothing\n    end\nend\n</cell>\n<code language=julia-0.4>\nnext_smallest([1,2,3])\n\
    </cell>\n<text>\n4.2 Task 3", "    smallest = get_smallest(lst)\n    if smallest\
    \ == nothing\n        return nothing\n    second = smallest[1]\n    remove!(lst,\
    \ smallest[1])\n    return second\n</code>\n<|/ a dscore=2 tags=big-o,algorithm,arrays,julia\
    \ |>\n<| a |>\n<code>\nusing Dates", "    if length(lst) == 0 \n        return\
    \ nothing\n    elseif length(lst) == 1\n        return lst[1]\n    else\n    \
    \    smallest = minimum(lst)\n        return if smallest == lst[1]\n         \
    \   smallest\n        else\n            smallest\n        end\n    end\nend\n\
    </code>\n<|/ a tags=julia,function |>\n<| a |>\nI came up with this function that\
    \ uses the fact that when an element is not in the vector, the minimum element\
    \ preceding it in the vector is also not in the vector:\n<code>", "    if length(lst)\
    \ == 1\n        nothing\n    else\n        lst[1]\n    end\nend\n</code>\nThe\
    \ function next_smallest has type Vector{Int64}; it returns nothing if the vector\
    \ is empty.\nIt is convenient to use function length to get the length of the\
    \ vector. \nThe function next_smallest is also a functional programming style\
    \ because we don't need to create an anonymous function and to name it next_smallest.\
    \ \nIn Julia language, we can do things like lst[1:end-1]\nIf we have a vector,\
    \ we can get the 2nd element of it by lst[1], \nand we can get the length of the\
    \ vector by length(lst).\nWe can check whether a vector is empty by checking the\
    \ length(lst) == 1.\nAnd we can get the last element of a vector by lst[-1].\n\
    <|/ a tags=julia |>\n<| c |>\nThanks for the detailed response!\n<|/ c |>\n<|\
    \ a |>\nYou want to get an item from a vector, right? Let's try to make it more\
    \ \"idiomatic\":\n<code>", "    if lst == []\n        nothing\n    elseif length(lst)==1\n\
    \        lst[1]\n    else\n        lst[1] if lst[1] < lst[2] else lst[2]\n   \
    \ end\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=2 tags=julia |>\nI came\
    \ up with the following code which is more elegant and shorter.\n<code>", "  if\
    \ isempty(lst)\n    return nothing\n  else\n    smallest = minimum(lst)\n    lst\
    \ = filter(x->x<smallest,lst)\n    if isempty(lst)\n      return nothing\n   \
    \ else\n      return lst[1]\n    end\n  end\nend\n\"\"\"\n    Find the minimum\
    \ value in a vector, and remove it from the vector\n    >>> a = [1, 1, 2, 3, 5,\
    \ 8, 13]\n    >>> v = Vector(a)\n    >>> minimum(v)\n    1\n    >>> minimum(v,2)\n\
    \    1\n    >>> minimum([],2)\n    nothing\n    \"\"\"", "    if isempty(lst)\n\
    \        return nothing\n    else \n        lst = lst[2:end]\n    end\nend\n</code>\n\
    <|/ a |>\n<| a tags=julia |>\nA simpler solution is to simply index the vector\
    \ with lst[1]:\n<code>\njulia> next_smallest(lst)\n2", "    minimum(lst)\n   \
    \ minimum2 = minimum(lst)\n    for x in lst\n        if minimum2 > x\n       \
    \     return minimum2\n        else\n            minimum2 = minimum\n        end\
    \ \n    end\n    return nothing\nend\n</cell>\n<code language=julia-1.0>\n@assert\
    \ next_smallest([1, 2, 3, 4, 5]) == 2\n@assert next_smallest([5, 1, 4, 3, 2])\
    \ == 2\n@assert next_smallest([]) == nothing\n@assert next_smallest([1, 1]) ==\
    \ nothing\n</cell>\n<text>\n9. find_smallest()", "    if length(lst) == 0\n  \
    \      nothing\n    else\n        lst[1] # return the second element\n    end\n\
    end", "    return findmin(lst)[1]\nend", "    if length(lst) == 1\n        return\
    \ nothing\n    end\n    minimum = minimum(lst)\n    index = findall(lst .== minimum)[1]\n\
    \    lst[index]\nend", "    smallest=minimum(lst)\n    smallest=smallest==0? nothing:smallest\n\
    \    smallest=minimum(lst)\n    smallest==nothing? nothing:lst[smallest]\nend\n\
    </cell>\n<code language=julia-1.5>\nnext_smallest([5, 1, 4, 3, 2])\n</cell>\n\
    <code language=julia-1.5>\nnext_smallest([])\n</cell>\n<code language=julia-1.5>\n\
    next_smallest([1, 1])\n</cell>\n<code language=julia-1.5>\nnext_smallest([1, 2,\
    \ 3, 4, 5])\n</cell>\n<text>\nQuestion 7", "    smallest = minimum(lst)\n    pos\
    \ = index(lst, smallest)\n    if pos == length(ls)\n        return nothing\n \
    \   elseif pos == 1\n        return smallest\n    else\n        return lst[pos+1]\n\
    \    end\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia,sorting |>\nJust to\
    \ add a more generic approach that works on arrays of arbitrary types (which can\
    \ be e.g. Ints, Floats or Symbols)\n<code>", "    \"\"\"\n    If there is an element\
    \ in the vector that is smaller than the 2nd smallest element,\n    we return\
    \ the 2nd smallest element.\n    Return nothing if there is no such element.\n\
    \    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4,\
    \ 3, 2])\n    2\n    >>> next_smallest([])\n    nothing\n    >>> next_smallest([1,\
    \ 1])\n    nothing\n    \"\"\"\n    if length(lst) == 0 || length(lst) == 1\n\
    \        return nothing\n    \n    lst = sort(lst)\n    if lst[1] == lst[2]\n\
    \        return lst[1]\n    return nothing", "    \n    smallest = min(lst)\n\
    \    if smallest == lst[1]\n        return nothing\n    end\n    \n    return\
    \ smallest\nend\n</cell>\n<text>\nQuestion 4.1\nBelow is a function next_bigger()\
    \ that returns the 2nd biggest element of the vector.", "    if length(lst) ==\
    \ 1\n        return Nothing\n    elseif length(lst) == 2 \n        return lst[1]\n\
    \    else\n        return lst[findnext(lst)]\n    end\nend", "    if length(lst)\
    \ == 0\n        return nothing\n    smallest_value = min(lst)\n    second_smallest_value\
    \ = lst[end]\n    if smallest_value == second_smallest_value\n        return nothing\n\
    \    return second_smallest_value\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    This code is unnecessarily complicated and inefficient. For a list of length N,\
    \ it requires O(N) operations to find the smallest value and O(N) operations to\
    \ find the 2nd smallest value, even if N is very large (which may or may not be\
    \ a problem). Try running the code, and you'll see why.\n<|/ c |>\n<| c |>\nThe\
    \ question asks for a general solution, also the code was meant to be run in Julia\
    \ as it is simple and concise. Furthermore, if you take a look at the code in\
    \ the question you'll see that it is doing what has been proposed in the question.\n\
    <|/ c |>\n<| c |>\nIt is not doing what has been proposed. The first time `next_smallest`\
    \ is called on a vector of length 3, it is calling `min` on all the elements of\
    \ that vector. Thus the function runs twice in total. The second time, it runs\
    \ once on the whole vector. It also assumes that there are at least 2 elements\
    \ in the vector, which is not necessarily the case. It also assumes there will\
    \ never be more than one element in the vector, which is not necessarily the case.\
    \ It also assumes no other elements in the vector are greater than the smallest\
    \ element, which is not necessarily the case. You are also calling `min` twice\
    \ per element in the vector, which runs more operations than needed. Just to name\
    \ a few...\n<|/ c |>\n<| a dscore=1 |>\nIn terms of efficiency, here's an alternative\
    \ answer that avoids explicit loops, uses Julia's built-in high-level vectorized\
    \ operations, and exploits the fact that Julia's min operation works with broadcasting\
    \ (i.e. it \"picks\" the element that has the smallest index in a vector). On\
    \ the other hand, it is more memory efficient, since it does not store any redundant\
    \ information, and thus is more concise.\n<code>", "    \n    if length(lst) ==\
    \ 0\n        nothing\n    elseif length(lst) == 1\n        lst[1]\n    else\n\
    \        push!(lst,lst[1])\n        lst[1]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\n    You are given a vector of integers. \n    Write a function that returns\
    \ its sum.\n    Return nothing if there are no elements.\n    >>> sum_of_list([])\n\
    \    nothing\n    >>> sum_of_list([1, 2, 3, 4])\n    10\n    >>> sum_of_list([1,\
    \ 2])\n    3\n    >>> sum_of_list([1, 3])\n    nothing\n    \"\"\"", "    if isempty(lst)\n\
    \        nothing\n    elseif isempty(lst[1])\n        nothing\n    elseif isempty(lst[2])\n\
    \        nothing\n    else\n        lst[2]\n    end\nend", "    sorted_list =\
    \ sort(lst)\n    if !isempty(sorted_list)\n        smallest = sorted_list[1]\n\
    \        smallest_idx = 1\n        for i = 2:length(sorted_list)\n           \
    \ if sorted_list[i] < smallest\n                smallest_idx = i\n           \
    \     smallest = sorted_list[i]\n            end\n        end\n        return\
    \ sorted_list[smallest_idx]\n    end\n    return nothing\nend\n</code>\n<|/ a\
    \ dscore=0 tags=julia |>\n<| c |>\nThanks for your time. I'm a little confused\
    \ because in my text book it shows the \"next\" function and it says to use it,\
    \ which is why I was confused. Could you elaborate a bit on what that means please?\
    \ Thanks.\n<|/ c |>\n<| c |>\nI just added the text that I wrote about `next`\
    \ function to the answer.\n<|/ c |>\n<| c |>\n`next` function is used to get some\
    \ next element of an iterator. In the text book, the authors use `next` function\
    \ here and `next_smallest` function in the answer to make it clear for you. Maybe\
    \ the text book author thinks about it in a different way. But the `next` function\
    \ can be used very similar way in Julia.\n<|/ c |>\n<| c |>\nThank you. I still\
    \ don't understand why the function next_smallest is needed in your example but\
    \ I'll have to look into that. Thanks again.\n<|/ c |>\n<| c |>\nOh, I see. Thanks\
    \ again!\n<|/ c |>\n<| a |>\nThe definition of next_smallest from your text book\
    \ doesn't work. From the code it looks like it is designed to find the last element\
    \ of a vector. \n<code>\njulia> next_smallest([1, 2, 3, 4, 5])\n5", "    if lst\
    \ == [] return nothing\n    \n    minimum = minimum(lst)\n    if minimum == nothing\
    \ \n        nothing \n    else \n        if minimum == 1 return minimum\n    \
    \    minimum = minimum(lst)\n        minimum == nothing ? nothing : minimum\n\
    \    end\n    \n    maximum = maximum(lst)\n    if maximum == nothing \n     \
    \   nothing \n    else \n        if maximum == 1 return maximum\n        maximum\
    \ = maximum(lst)\n        maximum == nothing ? nothing : maximum\n    end\nend\n\
    </code>\n<|/ a tags=julia,if-statement |>\n<| a |>\nI guess this is more concise\
    \ and straightforward:\n<code>\njulia> a = rand(1:10, 5)\n5\xD71 Array{Int64,2}:\n\
    \ 1  2  3  4  5  \n 3  8  7  5  1  \n 9  4  9  1  9  \n 2  5  2  5  6  \n 3  2\
    \  5  3  3  ", "    if length(lst) == 0 \n        nothing\n    else\n        lst[length(lst)-1]\n\
    \    end\nend\n</code>\nThe function checks if the length of the list is the same\
    \ as the length of the vector and if it is then it returns the last element of\
    \ the vector. Otherwise, it returns nothing (Nothing).\nYou can then simply call\
    \ this function in an if statement:\n<code>\nif next_smallest(input) == nothing\n\
    \    print(\"nothing\")\nelse\n    println(next_smallest(input))\nend\n</code>\n\
    <|/ a tags=julia |>\n<| c |>\nOh you beat me to it - I saw the `if length(lst)==length(lst)`\
    \ solution but thought that could be problematic if there were duplicates (i.e.\
    \ a vector with two `5`s in it).\n<|/ c |>\n<| a tags=julia |>\nI think that a\
    \ good way to solve your problem is to write your own function for \"next smallest\"\
    . The general idea is to keep two pointers in the vector, one to the start and\
    \ the other to the end. Both pointers have to keep moving until the element in\
    \ the end is smaller then the one at the start.\n<code>", "    lst = sort(lst)\n\
    \    l = length(lst)\n    if l == 0\n        return nothing\n    \n    \n    idx\
    \ = 1\n    while idx <= l\n        if lst[idx - 1] < lst[idx]\n            idx++\n\
    \        else\n            return lst[idx - 1]\n        end\n    end\n    return\
    \ nothing\nend", "    if !length(lst)\n        nothing\n    else\n        lst[length(lst)]\
    \ \n    end\nend\n</cell>\n<cell>\n#export\n\"\"\"\n    next_biggest\n    \n \
    \   returns the biggest element of the given vector\n    \"\"\"", "    smallest_2\
    \ = minimum(lst)\n    lst = filter(x->x!=smallest_2, lst)\n    if smallest_2 in\
    \ lst\n        smallest_2\n    else\n        nothing\n    end\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nYou should add a bit of explanation. Code-only answers\
    \ tend to get downvoted, which makes this question even harder for others to find.\n\
    <|/ c |>\n<| a dscore=1 tags=julia,list |>\n<code>\njulia> function next_smallest(lst::Vector{Int64})\n\
    \           if length(lst) == 0\n               nothing\n           elseif length(lst)\
    \ == 1\n               lst[1]\n           else\n               smallest_2 = minimum(lst)\n\
    \               lst = filter(x->x!=smallest_2, lst)\n               smallest_2\n\
    \           end\n       end", "  if length(lst) == 0 \n    return nothing \n \
    \ \n  smallest = lst[1] \n  \n  if length(lst) > 1 \n    smallest2 = next_smallest(lst[2:end])\
    \ \n    if smallest2 != nothing \n      smallest = min(smallest, smallest2) \n\
    \    else \n      return nothing \n  else \n    return smallest \nend ", "   \
    \ smallest = lst[1]\n    for i in lst[2:end]\n        if i < smallest\n      \
    \      smallest = i\n        end\n    end\n    if smallest == nothing\n      \
    \  return nothing\n    else\n        return smallest\n    end\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=julia |>\nThe solution without using any package:\n\
    <code>", "        if lst != [] \n            smallest = lst[1] \n            for\
    \ i in lst[2:end] \n                if i < smallest \n                    smallest\
    \ = i \n            nothing \n        end \n    end \nend ", "    local idx =\
    \ 1\n    while idx < length(lst) do\n        if lst[idx] < lst[idx - 1] then return\
    \ nothing\n        idx = idx + 1\n    end\n    return lst[idx]\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nYes, you can use the `find` function.  But you can\
    \ also use the builtin `find`. `find(lst, elem)` returns `nothing` if there is\
    \ no such element.  You can just say `if !find(lst, elem) then return nothing\
    \ end`.\n<|/ c |>\n<| c |>\nThank you for the useful comment, I'll add it to the\
    \ answer.\n<|/ c |>\n<| c |>\n`find` doesn't work with the OP's sample list because\
    \ he didn't pass `find` an array, but a vector of numbers. `find` operates on\
    \ a single element and only returns `nothing` if the element is not found.\n<|/\
    \ c |>\n<| a dscore=1 tags=julia,list |>\n<code>", "    smallest, i = smallest(lst)\n\
    \    if i > length(lst)\n        nothing\n    else\n        lst[i]\n    end\n\
    end\n</code>\n<|/ a dscore=4 tags=julia,list,sorting |>\n<| c |>\nThanks, I knew\
    \ about the sort function, but I wanted to see if I could do it in place.\n<|/\
    \ c |>\n<| c |>\nThanks. I added my own version of the function to the answer.\
    \ Let me know if that works.\n<|/ c |>\n<| c |>\nIn what sense is `sort(list::Vector{Int})`\
    \ an in-place operation?\n<|/ c |>\n<| c |>\nThanks, I suppose my question should\
    \ have been \"is there a built in function that performs the operation I describe\
    \ above in place?\".\n<|/ c |>\n<| c |>\n`sort` creates a new vector and sorts\
    \ the elements. `sort!` modifies existing vector in place.\n<|/ c |>\n<| a tags=julia,list,sorting\
    \ dscore=3 |>\nIn general, there is no sorting function in Julia's core packages.\n\
    However, there are lots of functions which can sort in place. For example, the\
    \ sort function, which modifies the array in place and has other options. \nThe\
    \ sort! function also modifies the array in place and has other options. \nThe\
    \ function sort also modifies the array in place. However, it has a bunch of other\
    \ options that will affect its performance, so it really depends on your use case.\n\
    <|/ a |>\n<| c |>\nThanks, I appreciate the clarification. I was confused because\
    \ I was getting an error message when using the sort function. I thought it was\
    \ a built in function.\n<|/ c |>\n<| a dscore=3 tags=julia,list,sorting |>\nFor\
    \ completeness, here is a simple implementation using sort! which I wrote:\n<code>\n\
    julia> function sort(a::Vector{T}) where {T}\n           m = length(a)\n     \
    \      a = sort(a)\n           m = length(a)\n           return m, a\n       end\n\
    sort (generic function with 1 method)", "    if length(lst) == 0 \n        return\
    \ nothing\n    index = find_index(lst, smallest_index(lst))\n    lst[index] =\
    \ -Inf + index\n    if length(lst) == 1 \n        return lst[1]\n    elseif lst[index]\
    \ < lst[index+1] \n        return lst[index]\n    elseif lst[index] > lst[index+1]\
    \ \n        return lst[index+1]\n    else \n        return nothing\nend", "  \
    \  \n    if length(lst) == 0 \n        return nothing\n    end", "    if length(lst)\
    \ == 0 \n        return Nothing \n    smallest = lst[1]\n    lst = lst[2:end]\n\
    \    return smallest if smallest < lst else next_smallest(lst)", "    \n    if\
    \ length(lst) == 0 \n        return nothing \n    end\n    \n    small = lst[1]\n\
    \    for i in (2:length(lst)) \n        if small == lst[i]\n            return\
    \ small\n        else \n            small = lst[i]\n        end\n    end\n   \
    \ return nothing\nend\n</code>\n<|/ a tags=julia |>\n<| a |>\n<code>", "    if\
    \ length(lst) == 0 \n        return nothing \n    else \n        min = lst[1]\
    \ \n        for el in lst[2:end] \n            if el < min \n                min\
    \ = el \n            else \n                return min \n    return nothing \n\
    end \n</code>\n<|/ a tags=julia,functional-programming,recursion,algorithm dscore=1\
    \ |>\n<| c |>\nWhat is the purpose of the `el` variable?\n<|/ c |>\n<| c |>\n\
    Hi Aran-, thank you so much for helping me with this problem! I think I understand\
    \ now why you chose to use the `el` variable in the code. I was wondering why\
    \ you chose to have the `el` variable be the second element in the list (`lst[1]`)\
    \ instead of the element at the index of the current `el` element (`lst[el]`).\
    \ Can you elaborate on why you chose to do this? I am not very familiar with vectors\
    \ and I appreciate your help with this and any future problems I have. Thanks\
    \ again!\n<|/ c |>\n<| c |>\nSure! I'll add some comments to my answer. Basically,\
    \ the idea is that if I'm looking for the 2nd smallest element, then I want the\
    \ \"smallest\" element in the vector that is the second element (and not the element\
    \ at index `el`). Since I'm looking for the \"smallest\" element, it would make\
    \ sense to me to pick the 2nd element (and not the one at index `el`).\n<|/ c\
    \ |>\n<| c |>\nThanks for the help! I appreciate it! I just want to make sure\
    \ I fully understand your code. For example, the code you wrote is comparing the\
    \ `el` element with the smallest element in the list `lst[1:end]`. Why did you\
    \ choose to do this? Why not just compare the `el` element with the `min` variable\
    \ instead of `lst[1:end]`?\n<|/ c |>\n<| c |>\nThat was a typo (I was copying\
    \ and pasting from a different part of the code and forgot to fix that part).\
    \ Corrected now. Basically, I'm comparing `el` with the smallest element in the\
    \ vector `lst[1:end]` because I'm looking for an element in the vector (`lst[1:end]`)\
    \ that is smaller than `el`. Since I'm looking for an element smaller than `el`,\
    \ then it makes sense to me to compare `el` with the smallest element (and not\
    \ the smallest element in the vector, which would have the 2nd smallest element).\n\
    <|/ c |>\n<| a |>\nYou can avoid using for loops by exploiting array broadcasting\
    \ and the built-in sort! function. Specifically, we define a function to find\
    \ the index of the smallest element in an array (with ", "    lst = lst[end-1:end]\n\
    \    if lst.min < lst[end]\n        return lst.min\n    return nothing\nend\n\
    </cell>\n<text>\nQuestion 3.3\nWrite a function remove_indice_from_indices(lst::Vector{Int64},\
    \ lst1::Vector{Int64})::Vector{Int64} that returns the elements of the first list\
    \ that are not in the second list.", "    if length(lst) == 0\n        return\
    \ nothing\n    idx1 = findfirst(lt -> lt == min(lst), lst)\n    idx2 = findfirst(lt\
    \ -> lt == max(lst), lst)\n    if idx1 == nothing, idx2 == nothing\n        return\
    \ nothing\n    else\n        return lst[idx2]\n    end\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\nHere is another solution:\n<code>", "    if isempty(lst)\n    \
    \    nothing\n    else\n        idx = 2\n        for j in 1 : length(lst)\n  \
    \          if j != idx\n                if lst[j] < lst[idx]\n               \
    \     idx = j\n                else\n                    nothing\n           \
    \     end\n            end\n        end\n        lst[idx]\n    end\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nIf you don't understand something about this solution,\
    \ please let me know. I'm sure I can explain it better.\n<|/ c |>\n<| a tags=sorting,julia\
    \ dscore=1 |>\nAnother solution using sort! which sorts the vector in-place (no\
    \ return value) and returns the modified vector\n<code>\njulia> next_smallest([2,\
    \ 1, 2, 3, 4, 3, 5])\n2", "    i = length(lst)\n    if i < 2\n        return nothing\n\
    \    end\n    if lst[i]<lst[i-1]\n        return nothing\n    end\n    return\
    \ lst[i]\nend", "    smallest_idx = 1\n    if lst == []\n        nothing\n   \
    \ elseif smallest_idx == 2\n        lst[smallest_idx]\n    else\n        next_smallest(lst[smallest_idx+1:end])\n\
    \    end\nend\n</code>\n<|/ a dscore=4 tags=julia,sorting,function |>\n<| c |>\n\
    Thanks. This is great, and works with the test data, but I'm still unsure why\
    \ my code didn't work. I'll try to look at this again more later, but this solution\
    \ does work though.\n<|/ c |>\n<| c |>\nI'm glad it helped. Can you please mark\
    \ this as an answer?\n<|/ c |>\n<| c |>\nI'm still unsure why the original code\
    \ didn't work. I'm going to try to find some time to read over the solutions and\
    \ see if I can find out why it didn't work, otherwise I'll mark this as an answer.\
    \ Thanks for the help!\n<|/ c |>\n<| c |>\nOh, I didn't even notice the typo.\
    \ I didn't get an error from my test data, but when I implemented it into my code\
    \ it didn't work. Thank you for the help!\n<|/ c |>\n<| c |>\nThis code can be\
    \ greatly reduced. `next_smallest` could be replaced by `idxmin`, which would\
    \ eliminate the `if` statement, as well as the `else` branch. `next_smallest`\
    \ could then be replaced by `lst[idx]`.\n<|/ c |>\n<| a tags=julia,sorting,function\
    \ |>\nHere's another simple (albeit not very efficient) way to write it, which\
    \ also works for other types of sequences (such as Sets or Matrixes). Here are\
    \ the steps:", "    if length(lst) == 0 return nothing \n    index = 2 \n    smallest_value\
    \ = lst[1] \n    for v in lst[2:end] \n        if v < smallest_value \n      \
    \      smallest_value = v \n            index = 2 \n        else \n          \
    \  index = index + 1 \n        end \n    end \n    return smallest_value\nend\
    \ \n</cell>\n<code language=julia-1.5>\n@test next_smallest([2, 5, 8, 1, 3]) ==\
    \ 1 \n</cell>\n<code language=julia-1.5>\n@test next_smallest([10, 2, 3, 9, 6,\
    \ 4, 5]) == 6 \n</cell>\n<code language=julia-1.5>\n@test next_smallest([10, 2,\
    \ 3, 9, 6, 4, 5]) == 3 \n</cell>\n<code language=julia-1.5>\n@test next_smallest([10,\
    \ 2, 3, 9, 6, 4, 5]) == 10 \n</cell>\n<code language=julia-1.5>\n@test next_smallest([10,\
    \ 2, 3, 9, 6, 4, 5]) == nothing \n</cell>\n<text>\nNextSmallest() function in\
    \ Python", "    smallest_value = lst[1]\n    if smallest_value == nothing\n  \
    \      return nothing\n    end\n    for elem in lst[2:end]\n        if elem <\
    \ smallest_value\n            smallest_value = elem\n        end\n    end\n  \
    \  return smallest_value\nend\n</cell>\n<code language=julia-1.0>\n@assert next_smallest([2,\
    \ 3, 1, 1, 4]) == 3\n@assert next_smallest([5, 4, 3, 2, 1]) == 3\n@assert next_smallest([1,\
    \ 3]) == nothing\n</cell>\n<code language=julia-1.0>", "    if length(lst) ==\
    \ 0\n        return nothing\n    \n    # get the smallest element and remove it\
    \ from the vector\n    smallest = lst[1]\n    lst = lst[2 : end]", "    if lst[1]\
    \ == lst[2]\n        nothing\n    else\n        lst[1]\n    end\nend", "    if\
    \ length(lst) == 0\n        return nothing\n    elseif length(lst) == 1\n    \
    \    return lst[1]\n    else\n        return sort(lst)[2]\n    end\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a |>\n<code>", "    if lst[1] == Nothing\n        nothing\n\
    \    else\n        lst[1]\n    end\nend", "    \n    if length(lst) == 0\n   \
    \     return nothing\n    end\n    \n    if lst[1] < lst[2]\n        return lst[1]\n\
    \    else\n        return lst[2]\n    end\nend", "    if lst == []\n        nothing\n\
    \    else\n        lst[end]\n    end\nend\n</code>\n<|/ a |>\n<| a dscore=0 tags=julia,sorting\
    \ |>\nThe answer by jamessu is good.\nIf you want to stick to Julia, here is a\
    \ solution without loops:\n<code>", "    smallest = minimum(lst)\n    pos = findfirst(i->i==smallest,lst)\n\
    \    if pos==nothing\n        nothing\n    else\n        lst[pos+1]\n    end\n\
    end\n</cell>\n<text>\nSolution", "    return if length(lst) == 0 then nothing\
    \ else lst[1]\nend # function next_smallest()", "    if lst[1] == nothing\n  \
    \      return nothing\n    \n    smallest = lst[1]\n    lst[1] = nothing\n   \
    \ \n    if length(lst) == 1\n        return nothing\n    end\n    \n    for i\
    \ in lst[2:end]\n        if i < smallest\n            smallest = i\n        else\n\
    \            break\n    end\n    \n    return smallest\nend", "    \n    # check\
    \ empty list\n    if length(lst) == 0\n        return nothing\n    \n    # find\
    \ the minimum element\n    min_idx = argmin(lst)\n    \n    # find the second\
    \ minimum element\n    idx = min_idx + 1\n    if idx < length(lst)\n        return\
    \ lst[idx]\n    end\n    \n    # find smallest element in the rest of the list\n\
    \    return nothing\nend", "    if length(lst) == 0 return nothing\n    smallest\
    \ = lst[1]\n    for el in lst[2:end]\n        if el < smallest\n            smallest\
    \ = el\n        end\n    end\n    return smallest\nend", "    if length(lst) ==\
    \ 0 \n        return nothing \n    \n    i = length(lst) - 1\n    while (i > 1\
    \ & lst[i] > lst[i-1])\n        i -= 1\n    end", "    if isempty(lst)\n     \
    \   return nothing\n    if length(lst) == 0 \n        return nothing\n    if length(lst)\
    \ == 1 \n        return lst[1]\n    idxs = findfirst(lst.<, lst[end])\n    if\
    \ idxs == nothing\n        return nothing\n    idxs+=1\n    lst[idxs]\nend", " \
    \   if length(lst) == 0 \n        nothing\n    elseif length(lst) == 1 \n    \
    \    lst[1]\n    elseif lst[1] < lst[2] \n        lst[1]\n    elseif lst[2] <\
    \ lst[1] \n        lst[2]\n    elseif lst[2] < lst[1] \n        lst[1]\n    elseif\
    \ lst[1] < lst[2] \n        lst[1]\n    else\n        nothing\n    end\nend\n\
    </cell>\n<text>\nNext Challenge\nFor a moment while we wait for your next challenge,\
    \ let's see how we might use your next_smallest() function to help us find all\
    \ the elements of a list smaller than a particular element.", "    if !isempty(lst)\
    \ && length(lst) <2\n        return nothing\n    else\n        if length(lst)\
    \ ==2\n            return lst[1]\n        else\n            return lst[end-1]\n\
    \        end\n    end\nend\n</cell>\n<text>\n4.4.3 Solution\nRun the cell below\
    \ to test your solution.", "    if length(lst) == 0 \n        nothing \n    elseif\
    \ length(lst) == 1 \n        lst[1] \n    elseif length(lst) == 2 \n        if\
    \ lst[1] < lst[2] \n            lst[1] \n        else \n            lst[2] \n\
    \        end\n    else \n        lst[end-1]\n    end\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThe code in the question doesn't work when you pass in empty lists.\n\
    <|/ c |>\n<| c |>\nI agree with you on that point, however I believe this is what\
    \ the OP was looking for.\n<|/ c |>\n<| c |>\nWell, he says \"Write a function\
    \ next_smallest() that returns the 2nd smallest element of the vector.\" And he\
    \ wants to return nothing if there is no such element.\n<|/ c |>\n<| a dscore=2\
    \ |>\nHere's a solution in Julia 0.5\n<code>", "    if lst == []\n        nothing\n\
    \    elseif length(lst) == 2\n        lst[1]\n    else\n        minimum(lst[2:end])\n\
    \    end\nend", "    if isempty(lst)\n        return nothing\n    i = 2\n    while\
    \ i < size(lst)\n        if lst[i] < lst[i-2]\n            return lst[i]\n   \
    \     end\n        i = i + 1\n    end\n    return nothing\nend\n</cell>\n<code\
    \ language=julia-0.5>\n\"\"\"\n    Your Task is to complete the function next_smallest()\
    \ using if\n    else construct.\n    You have to complete the function with if-else\
    \ block.\n    \"\"\"", "    nothing\n    if length(lst_i) != 0\n        smallest\
    \ = minimum(lst)\n        lst[index(lst,smallest)+1]\n    else\n        nothing\n\
    \    end\nend", "    if length(lst) == 0\n        nothing\n    else\n        lst[1]\n\
    \    end\nend\n</code>\n<|/ a tags=julia,list dscore=0 |>\n<| a tags=julia,list\
    \ |>\nIf you need to do this a lot, consider making your own function for it.\
    \ It's a little bit more flexible than using filter. For example:\n<code>", " \
    \   smallest = min(lst)\n    if smallest == lst[1]\n        nothing\n    elseif\
    \ smallest != lst[1]\n        smallest\n    else\n        nothing\n    end\nend",
  "    if lst==[]\n        return nothing\n    smallest = min(lst)\n    for i in [i\
    \ for i=1:length(lst)-1 if lst[i]<smallest]\n        smallest = lst[i]\n    end\n\
    \    return smallest\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nThe following\
    \ code can solve the problem.\n<code>", "    if length(lst) == 0 \n        nothing\n\
    \    elseif length(lst) == 1 \n        lst[1]\n    else\n        smallest_value\
    \ = lst[1]\n        lst[1] = smallest_value\n        lst[2] = smallest_value\n\
    \        lst[3] = smallest_value\n        smallest_value\n    end\nend\n</code>\n\
    <|/ a dscore=0 tags=arrays,algorithm,julia |>\n<| a dscore=0 |>\nJust in case\
    \ you want to do this in Julia without creating an intermediate array or without\
    \ using libraries.\n<code>", "    if length(lst ) == 0 \n        return nothing\n\
    \    else if length(lst ) == 1\n        return lst[1]\n    elseif length(lst)\
    \ == 2 \n        return lst[1]\n    else\n        smallest_value = lst[1]\n  \
    \      for v in lst[2:end]\n            if v < smallest_value\n              \
    \  smallest_value = v\n            end\n        end\n        return smallest_value\n\
    \    end\nend\n</code>\n<|/ a dscore=0 tags=julia,function |>\n<| a |>\nI did\
    \ some research on the topic after answering this question and here's the result\n\
    <code>", "    if lst[1] == nothing\n        nothing\n    else\n        lst[1]\n\
    \    end\nend", "    if !lst.length\n        nothing\n    else\n        if lst.head\
    \ == 0\n            nothing\n        else\n            if lst.head < lst.tail[1]\n\
    \                lst.head\n            else\n                lst.tail[1]\n   \
    \         end\n        end\n    end\nend\n</code>\n<|/ a |>\n<| a tags=sorting,julia,arrays\
    \ |>\nThis question already has several answers. However, I just wanted to throw\
    \ in another solution here for those of us who want to avoid the if ... else ...\
    \ end statement.\n<code>", "    if isempty(lst)\n        return nothing\n    else\n\
    \        smallest = eltype(lst)()\n        smallest_pos = find(lst<=smallest)\n\
    \        if smallest_pos != nothing\n            smaller_pos = find(lst>=smallest)\n\
    \            if smaller_pos != nothing\n                if smaller_pos == smallest_pos\n\
    \                    return nothing\n                else\n                  \
    \  smaller = lst[smaller_pos]\n                    lst[smaller_pos] = nothing\n\
    \                    lst[smallest_pos] = smallest\n                    return\
    \ smallest\n                end\n            end\n        end\n        return\
    \ nothing\n    end\nend\n</cell>\n<code language=julia-1.5>\nnext_smallest([1,\
    \ 2, 3, 4, 5])\n</cell>\n<code language=julia-1.5>\nnext_smallest([5, 1, 4, 3,\
    \ 2])\n</cell>\n<code language=julia-1.5>\nnext_smallest([])\n</cell>\n<code language=julia-1.5>\n\
    next_smallest([1, 1])\n</cell>\n<code language=julia-1.5>", "    min = Vector{Int64}()\n\
    \    for elt in lst \n        if elt < minimum(min)\n            minimum(min)\
    \ = elt\n        end\n    end\n    minimum(min)\nend", "    smallest = min(lst)\n\
    \    index = findall(lst .== smallest)[1]\n    if index < length(lst)-1\n    \
    \    lst[index+1]\n    else\n        nothing\n    end\nend", "    \n    i, j =\
    \ 1, 2\n    while i < length(lst) && j+1 < length(lst)\n        if lst[i] < lst[j]\n\
    \            i += 1\n        else\n            j += 1\n        end\n    end\n\
    \    if i == length(lst)\n        return nothing\n    elseif j == length(lst)\n\
    \        return lst[i]\n    else\n        return lst[j]\n    end\nend\n</code>\n\
    <|/ a tags=sorting,julia,algorithm |>\n<| a dscore=0 |>\nHere is a solution that\
    \ uses no extra memory:\n<code>", "    if length(lst) == 0 return nothing\n  \
    \  smallest=lst[1]\n    for i=2:length(lst)\n        if lst[i]<smallest \n   \
    \         smallest=lst[i]\n        end\n    end\n    return smallest", "     if\
    \ length(lst)==0\n         return nothing\n     else\n         if length(lst)==1\n\
    \            return lst[1]\n         elseif lst[1]<lst[2]\n             return\
    \ lst[1]\n         elseif lst[1]==lst[2]\n            return next_smallest(lst[3:end])\n\
    \         else\n            return next_smallest(lst[2:end])\n     end\n     end\n\
    \"\"\"\n    Write a function next_largest() that returns the 2nd largest element\
    \ of the vector.\n    Return nothing if there is no such element.\n    >>> next_largest([1,\
    \ 2, 3, 4, 5])\n    3\n    >>> next_largest([5, 1, 4, 3, 2])\n    5\n    >>> next_largest([])\n\
    \    nothing\n    >>> next_largest([1, 1])\n    nothing\n    \"\"\"", "    if\
    \ isEmpty(lst)\n        return nothing\n    elseif length(lst) == 1\n        return\
    \ lst[1]\n    else\n        smallest = minimum(lst)\n        remove!(lst, smallest)\n\
    \        return smallest\n    end\nend\n</code>\n<|/ a dscore=2 tags=algorithm,julia\
    \ |>\n<| a dscore=1 |>\nSince this question is tagged Julia, here is my implementation\
    \ in Julia.\n<code>", "    lst = lst.sort()\n    if lst.length == 2\n        return\
    \ lst[2]\n    end\n    i = findlastindex(lst, 2)\n    if i == 0\n        return\
    \ nothing\n    end\n    return lst[i]\nend", "    if isempty(lst) \n        nothing\
    \ \n    else\n        idx = findfirst(isequal(lst[1]),lst)\n        if idx ==\
    \ nothing \n            nothing \n        else\n            lst[idx]\n       \
    \ end\n    end\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>", "    if length(lst)\
    \ == 0\n        nothing\n    elseif length(lst) == 1\n        lst[1]\n    else\n\
    \        # get the smallest value that is greater then the current element\n \
    \       #smallest = findnext(lst, el)\n        smallest = minimum(lst) \n    \
    \    \n        # find the 2nd smallest element\n        #next_smallest = findnext(lst,\
    \ smallest)\n        next_smallest = findnext(lst, smallest)\n        \n     \
    \   # if the smallest is equal to the next smallest we are done \n        # otherwise\
    \ find the next smallest and repeat\n        while smallest == next_smallest \n\
    \            smallest = findnext(lst, smallest)\n            next_smallest = findnext(lst,\
    \ smallest)\n        end\n        \n    end\nend\n</code>\n<|/ a dscore=4 |>\n\
    <| c |>\nThis approach does not take advantage of the fact that duplicates are\
    \ allowed - it only considers the next element in the list, without considering\
    \ the current element.\n<|/ c |>\n<| c |>\nThis is pretty much a Python implementation\
    \ of Dietrich's answer. Just pointing out that the function is written in Julia\
    \ rather than Python. \nThe function `findnext` can be found in [`Base`](https://github.com/JuliaLang/julia/blob/master/base/Base.md)\n\
    <|/ c |>\n<| c |>\nThis finds the second largest element in an array. I'm looking\
    \ for the second smallest element.\n<|/ c |>\n<| c |>\nIt finds the 2nd smallest\
    \ element in the array, but then it repeats the algorithm until the 2nd smallest\
    \ element is found. \nThe only difference between the second smallest element\
    \ and the 2nd largest element is the variable `smallest` vs `next_smallest`. The\
    \ rest of the logic remains the same.\n<|/ c |>\n<| c |>\nYour code assumes that\
    \ the array is sorted, which is not guaranteed in general. In fact, in the example\
    \ array I gave it was, but I do think this is a good approach.\n<|/ c |>\n<| a\
    \ |>\nThe accepted solution does not take advantage of the fact that duplicates\
    \ are allowed - it only considers the next element in the list, without considering\
    \ the current element.\nHere is another solution that incorporates Dietrich's\
    \ answer:\n<code>", "    if isempty(lst)\n        return nothing\n    else\n \
    \       mid = div(length(lst), 2)\n        lst[mid]\n    end\nend\n</code>\n<|/\
    \ a dscore=2 tags=julia,function |>\n<| a dscore=1 |>\nA simple implementation\
    \ for Julia 0.5 would be as follows. \n<code>", "    if length(lst) == 0 \n  \
    \      return nothing \n    else \n        return lst[1]\nend \n</code>\n<|/ a\
    \ tags=julia |>\n<| a |>\n<code>", "    if lst == [] \n        return nothing\
    \ \n    end\n    pivot = lst[1]\n    lst[1] = nothing\n    pop!(lst)\n    push!(lst,pivot)\n\
    \    if lst.length == 1\n        return lst[1]\n    end\n    push!(lst,nothing)\n\
    \    smallest = next_smallest(lst)\n    push!(lst,smallest)\n    push!(lst,nothing)\n\
    \    smallest = next_smallest(lst)\n    push!(lst,smallest)\n    nothing\nend",
  "    lst[findmin(lst)]\nend\n</code>\n<|/ a |>\n<| c |>\nIt's worth pointing out\
    \ that `findmin(arr)` returns a `Int`, so the comparison function can actually\
    \ be written as `findmin \u2264 2`, though I agree that the type signature in\
    \ the question is more helpful.\n<|/ c |>\n<| c |>\nThe only thing I see here\
    \ that's not mentioned in the other answers is that this is O(n), so it's likely\
    \ to be faster than the naive sort method.\n<|/ c |>\n<| a tags=julia,arrays |>\n\
    The findmin function will return the index of a minimum value in the array.  It\
    \ will return nothing if the array is empty.  You can get the value itself with\
    \ arr[findmin(arr)]\n<|/ a dscore=3 |>\n<| a tags=julia,arrays |>\nHere's another\
    \ solution, using sort:\n<code>", "    if length(lst == 0) return nothing\n  \
    \  smallest = minimum(lst)\n    pos = findfirst(x -> x < smallest, lst)\n    return\
    \ nothing if pos == length(lst) || pos == -1 \n    \n    next_smallest(lst[pos:end-1])\n\
    end\n</cell>\n<code language=julia-1.5>\n# Test your code\nnext_smallest([1, 2,\
    \ 3, 4, 5])\n</cell>\n<code language=julia-1.5>\n# Test your code\nnext_smallest([5,\
    \ 1, 4, 3, 2])\n</cell>\n<code language=julia-1.5>\n# Test your code\nnext_smallest([])\n\
    </cell>\n<code language=julia-1.5>\n# Test your code\nnext_smallest([1, 1])\n\
    </cell>\n<text>\nExercise 2: Binary search\nNow implement binary search on your\
    \ own.", "    if length(lst) == 0 \n        return nothing\n    smallest = lst[1]\n\
    \    for el in lst[2:end] \n        if el < smallest \n            smallest =\
    \ el\n        end\n    end\n    return smallest\nend\n</cell>\n<code language=julia-1.0>",
  "    if length(lst) == 0 \n        Nothing \n    else \n        lst[end-1] \n  \
    \  end\nend\n</code>\n<|/ a tags=julia,sorting,indexing |>\n<| a tags=julia,sorting,indexing\
    \ dscore=2 |>\nHere's another approach that doesn't require an intermediate vector.\
    \ As suggested previously, it also doesn't require a temporary variable.\n<code>\n\
    # Get the 2nd smallest element in the vector", "    if length(lst) == 0 || length(lst)\
    \ == 1 \n        nothing\n    else\n        lst[1]\n    end\nend\n</cell>\n<text>\n\
    We then define a function to remove duplicates in a vector, which is exactly the\
    \ opposite of what we did in the previous section. The function remove_duplicates(lst::Vector{Int64})\
    \ is defined below:", "    if length(lst) == 0 return nothing\n    smallest =\
    \ lst[1]\n    idx = 0\n    for i in 2 :: length(lst)\n        if lst[i] < smallest\n\
    \            smallest = lst[i]\n            idx = i\n        end\n    end\n  \
    \  return smallest\nend", "    if length(lst) == 0 return nothing\n    \n    smallest\
    \ = lst[1]\n    for element in lst[2:end-1]\n        if element < smallest\n \
    \           smallest = element\n        elseif element == smallest\n         \
    \   return element\n        end\n    end\n    return nothing\nend\n</cell>\n<text>\n\
    Exercise: Write a program to find the 2nd largest element of a given vector",
  "    for e in lst\n        if e < lst[1]\n            return e\n        end\n  \
    \  end\n    return nothing\nend\n</code>\n<|/ a tags=julia |>\n<| a |>\nI suggest\
    \ you to use sort! function. With sort!, you are sorting in-place, so you don't\
    \ need to allocate memory for new array.\n<code>", "    return if length(lst)\
    \ == 1\n        nothing\n    elseif lst[1] < lst[2]\n        nothing\n    else\n\
    \        lst[1]\n    end\nend\n</cell>\n<text>\nLet's now have a look at the implementation\
    \ of next_smallest() for the different inputs:", "    smallest = minimum(lst)\n\
    \    if smallest == nothing\n        nothing\n    elseif smallest == minimum(lst[1:\
    \ end])\n        nothing\n    else\n        smallest\n    end\nend\n</cell>\n\
    <code language=julia-1.5>", "    smallest = nothing\n    if length(lst) == 0 \n\
    \        nothing\n    else\n        smallest = lst[1]\n        lst[1] = nothing\n\
    \        lst[end] = nothing\n        for i in 2:(length(lst))\n            if\
    \ lst[i] < smallest\n                smallest = lst[i]\n            end\n    \
    \    end\n        lst[1] = smallest\n    end\n    return nothing\nend\n</cell>\n\
    <code language=julia-1.6>\n# Solution using Julia's built in methods", "    if\
    \ lst.size == 0 return nothing\n    idx = 1\n    while idx<lst.size\n        if\
    \ lst[idx]<lst[idx-1]\n            lst[idx]\n        else\n            return\
    \ lst[idx]\n        end\n        idx+=1\n    end\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=1 |>\nI did this in Julia using recursion.\n<code>"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
