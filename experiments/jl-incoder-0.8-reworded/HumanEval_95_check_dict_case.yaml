name: HumanEval_95_check_dict_case
language: jl
prompt: "\"\"\"\n    Given a dictionary, return true if all keys are strings in lower\
  \ \n    case or all keys are strings in upper case, else return false.\n    The\
  \ function should return false is the given dictionary is empty.\n    Examples:\n\
  \    >>> check_dict_case(Dict(\"a\" => \"apple\", \"b\" => \"banana\"))\n    true\n\
  \    >>> check_dict_case(Dict(\"a\" => \"apple\", \"A\" => \"banana\", \"B\" =>\
  \ \"banana\"))\n    false\n    >>> check_dict_case(Dict(\"a\" => \"apple\", 8 =>\
  \ \"banana\", \"a\" => \"apple\"))\n    false\n    >>> check_dict_case(Dict(\"Name\"\
  \ => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"))\n    false\n    >>>\
  \ check_dict_case(Dict(\"STATE\" => \"NC\", \"ZIP\" => \"12345\"))\n    true\n \
  \   \"\"\"\nfunction check_dict_case(dict::Dict{String, String}>)::Bool \n"
tests: "using Test\n\n@testset begin\n\ncandidate = check_dict_case;\n\t@test(candidate(Dict(\"\
  p\" => \"pineapple\", \"b\" => \"banana\")) == true)\n\t@test(candidate(Dict(\"\
  p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\")) == false)\n\t@test(candidate(Dict(\"\
  p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\")) == false)\n\t@test(candidate(Dict(\"\
  Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\")) == false)\n\t@test(candidate(Dict(\"\
  STATE\" => \"NC\", \"ZIP\" => \"12345\")) == true)\n\t@test(candidate(Dict(\"fruit\"\
  \ => \"Orange\", \"taste\" => \"Sweet\")) == true)\n\t@test(candidate(Dict()) ==\
  \ false)\nend\n"
completions: ["    for i in dict.values()\n        if type(i) != String\n        \
    \    return false\n    end\n    return true\nend", "    for k in keys(dict)\n\
    \        if islower(k) || isupper(k)\n            return true\n        end\n \
    \   end\n    return false\nend", "    return all((key1 \u2208 dict.keys() for\
    \ key1 in keys(dict))) \\\n        and all((key2 \u2208 dict.keys() for key2 in\
    \ keys(dict))) \nend\n</cell>\n<code language=julia-0.6>", "    for key in keys(dict)\
    \ do \n        if islower(key) || isupper(key) \n            return false \n \
    \       end\n    end\n    return true\nend\n</cell>\n<code language=julia-1.3>\n\
    check_dict_case(Dict(\"a\" => \"apple\", \"b\" => \"banana\", \"a\" => \"apple\"\
    ))\n</cell>\n<text>\n3. Using if\nA more concise version of checking a dictionary\
    \ is to use if. \nIf is more concise than checking a dictionary, as it is a ternary\
    \ operator.\nIn Julia ifelse is an alias for if. \nWe will now use if to check\
    \ a dictionary for two conditions: \n1) All keys are strings in lower case, and\
    \ \n2) All keys are strings in upper case.", "    true\n    for k in keys(dict)\n\
    \        if lower(k) != k && upper(k) != k && \n            (lower(k) == k ||\
    \ upper(k) == k)\n            return false\n    end\n    return true\nend", " \
    \   not_upper = true\n    not_lower = true\n    for (key,value) in dict\n    \
    \    if !is_upper(value)\n            not_upper = false\n        elseif is_upper(value)\n\
    \            if key < value\n                not_lower = false\n            end\n\
    \        else\n            if key > value\n                not_lower = false\n\
    \            end\n        end\n    end\n    return not_lower && not_upper\nend\n\
    </code>\n<code>", "    if !dict_keys(dict) \n        return true\n    for key,\
    \ value in dict.iteritems()\n        if !isa(key, String) || !isa(value, String)\n\
    \            return false\n    end\n    return true\nend\n</cell>\n<text>\ncheck_dict_invariant",
  "    # go through each key and check if it is in upper or lower case\n    for k\
    \ in keys(dict) do \n        if is_upper(k)\n        elseif is_lower(k)\n    \
    \    else\n            return false\n        end\n    end", "    if not dict\n\
    \        return true\n    key_is_strs = not filter(x -> typeof(x) <: Symbol, dict)\n\
    \    key_is_strs_upper = !map(x -> x == x.upper(), dict)\n    return key_is_strs\
    \ and key_is_strs_upper\nend", "    true\nend", "    return all(map(lower, dict.values))\n\
    end", "    l = length (dict.tokeys) \n    true = l == 0\n    for k in dict.tokeys\n\
    \        if k isupper\n            true = false\n            break\n        if\
    \ k islower\n            true = false\n            break\n    end\n    return\
    \ true\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThe `else` is not needed: just\
    \ `return false` would work as well.\n<|/ c |>\n<| a |>\nThe best answer from\
    \ all here comes from:\nhttps://github.com/julien-sansan/check_dict_case.jl/issues/3\n\
    <code>\njulia> using DictUtils", "    return !dict.isEmpty() && all(k === k.upper()\
    \ for k in dict)\nend", "    true\n    for (k,v) in dict\n        @assert(not\
    \ isupper(k), k, \"should be lowercase\")\n        @assert(not islower(k), k,\
    \ \"should be uppercase\")\n    end\n    return true\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 |>\n<code>\ntype DictLike{T}\n  val dict :: Dict{T}\nend",
  "    if isEmpty(dict) \n        return true \n    for (k,v) in dict do \n      \
    \  if type(k) != String or type(v) != String \n            return false \n   \
    \ end \n    return true \nend \n\"\"\"\n    Given a dictionary, return true if\
    \ all keys are numbers in lower \n    case or all keys are numbers in upper case,\
    \ else return false.\n    The function should return false is the given dictionary\
    \ is empty.\n    Examples:\n    >>> check_dict_case_number(Dict(\"a\" => \"apple\"\
    , \"b\" => \"banana\"))\n    true\n    >>> check_dict_case_number(Dict(\"a\" =>\
    \ \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"))\n    false\n    >>> check_dict_case_number(Dict(\"\
    a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"))\n    false\n    >>> check_dict_case_number(Dict(\"\
    Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"))\n    false\n\
    \    >>> check_dict_case_number(Dict(\"STATE\" => \"NC\", \"ZIP\" => \"12345\"\
    ))\n    true\n    \"\"\"", "    if dict.is_empty() \n        return false\n  \
    \  else\n        for key in dict\n            if (string(\"A\") == key || string(\"\
    a\") == key || string(\"A\") == key.upper() || string(\"a\") == key.upper())\n\
    \                return false\n        end\n        return true\n    end\nend\n\
    \"\"\"\n    Given a dictionary and a value, check if that value exists in the\
    \ dictionary \n    and return true or false accordingly.\n    Examples:\n    >>>\
    \ check_dict(Dict(\"a\" => \"apple\", \"b\" => \"banana\"), \"apple\")\n    true\n\
    \    >>> check_dict(Dict(\"a\" => \"apple\", \"b\" => \"banana\"), \"grape\")\n\
    \    false\n    >>> check_dict(Dict(\"a\" => \"apple\", \"b\" => \"banana\"),\
    \ \"apple\", true)\n    false\n    >>> check_dict(Dict(\"a\" => \"apple\", \"\
    b\" => \"banana\"), \"apple\", false)\n    true\n    >>> check_dict(Dict(\"a\"\
    \ => \"apple\", \"b\" => \"banana\"), \"grape\", false)\n    false\n    >>> check_dict(Dict(\"\
    a\" => \"apple\", \"b\" => \"banana\"), false)\n    false\n    >>> check_dict(Dict(\"\
    a\" => \"apple\", \"b\" => \"banana\"), false)\n    false\n    \"\"\"", "    return\
    \ all(map(x -> islower(x) || isupper(x), keys(dict))) || all(map(x -> islower(x),\
    \ keys(dict)))\nend\n</cell>\n<text>\nTask 5.1\nWrite a function that given a\
    \ string returns a new string where all the \noccurrences of the string \"a\"\
    \ have been replaced with \"b\" and all the \noccurrences of the string \"A\"\
    \ have been replaced with \"B\".\n    Examples:\n    >>> replace_a_with_b(\"aba\"\
    )\n    \"bbb\"\n    >>> replace_a_with_b(\"abA\")\n    \"bbB\"\n    >>> replace_a_with_b(\"\
    a\")\n    \"b\"\n    >>> replace_a_with_b(\"aA\")\n    \"B\"\n    >>> replace_a_with_b(\"\
    \")\n    \"\"\n    \"\"\"", "   \n   return all(map.is_string) for elem in dict\
    \ if map.is_string(elem.key) \nend\n    \n</cell>\n<cell>\n\"\"\"\n    Given a\
    \ string, return true if the string contains any digits in the \n    alphabet,\
    \ else return false.\n    Examples:\n    >>> contains_digits(\"apple\") \n   \
    \ false\n    >>> contains_digits(\"1a\") \n    true\n    \"\"\"", "    if len(dict)==0\
    \ \n        true\n    else \n        for key in dict\n            if islower(key)==isupper(key)\n\
    \                return false\n            elseif isupper(key)==islower(key)\n\
    \                return false\n            end\n        end\n        return true\n\
    \    end\nend", "    \n    # check every key is a valid string in lower case\n\
    \    for k in keys(dict)\n        if !(k == lower(k) || k == upper(k))\n     \
    \       return false\n    end", "    dict_length = length(dict)\n    if dict_length\
    \ == 0\n        return false\n    end\n    \n    for k in keys(dict)\n       \
    \ if !is_string(k)\n            return false\n        end\n    end", "    for\
    \ k in keys(dict)\n        if islowercase k\n            continue \n        elseif\
    \ isuppercase k\n            continue \n        end\n        return false \n \
    \   end\n    return true \nend", "    check = true \n    for k in keys(dict) do\
    \ \n        if isupper(k)\n            check = false\n        end\n    end\n \
    \   return check\nend\n\"\"\"\nGiven a dictionary, return true if all keys are\
    \ strings in lower \n    case, or all keys are strings in upper case, else return\
    \ false.\n    The function should return false is the given dictionary is empty.\n\
    \    Examples:\n    >>> check_dict_case(Dict(\"a\" => \"apple\", \"b\" => \"banana\"\
    ))\n    true\n    >>> check_dict_case(Dict(\"a\" => \"apple\", \"A\" => \"banana\"\
    , \"B\" => \"banana\"))\n    true\n    >>> check_dict_case(Dict(\"a\" => \"apple\"\
    , 8 => \"banana\", \"a\" => \"apple\"))\n    true\n    >>> check_dict_case(Dict(\"\
    Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"))\n    false\n\
    \    >>> check_dict_case(Dict(\"STATE\" => \"NC\", \"ZIP\" => \"12345\"))\n  \
    \  true\n    \"\"\"", "    if dict == Dict() \n        return false \n    else\
    \ \n        return all(map(x->islower(x) || isupper(x), keys(dict)))\n    end\n\
    end", "    return true \nend", "    if not Dict()(dict) == true \n    else \n\
    \        for keyval in dict.values() \n            check_dict_case(keyval)\n \
    \       end \n    end \n    return true \nend \n</cell>\n<cell>\n\"\"\"\nGiven\
    \ a string, return true if the string contains any non-alphabetic \ncharacter,\
    \ false otherwise. The function should return false if the string \nis empty.\n\
    Examples:\n>>> check_if_alphabet(\"apple\")\ntrue\n>>> check_if_alphabet(\"banana\"\
    )\nfalse\n>>> check_if_alphabet(\"\")\nfalse\n>>> check_if_alphabet(\" \")\nfalse\n\
    >>> check_if_alphabet(\"apple!\")\nfalse\n\"\"\"", "    for pair in dict\n   \
    \     if pair[1] ~= pair[1]\n            return false\n    end\n    return true\n\
    end", "    return \nend", "\treturn check_key_case(dict, true)\nend", "  return\
    \ all(map(is_string, map(lower, dict))) == false\nend\n</cell>\n<text>\nTask:\
    \ Test your check_dict_case function using the examples below. Does it work?",
  "    return all(map.(false -> (x -> check_dict_case(Dict(x)) ) x , keys(dict)))\
    \ or\n           all(map.(false -> (x -> check_dict_case(Dict(x)) ) x , values(dict)))\n\
    end", "    if dict.is_empty()\n        return false\n    else\n        for key\
    \ in dict\n            if islower(key) || isupper(key)\n                return\
    \ true\n            elseif islower(key) || isupper(key)\n                return\
    \ false\n            end\n        end\n        return false\n    end\nend", " \
    \   for key in keys(dict)\n        if lowercase(key) !=! key\n            return\
    \ false\n    end\n    return true\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    Good answer, but note that your code doesn't work as is for dictionaries with\
    \ non-string keys (`Dict(\"a\" => \"apple\", \"b\" => \"banana\")`). See my answer\
    \ for a generic solution that works for any type whose keys could be compared\
    \ using lowercase/uppercase.\n<|/ c |>\n<| c |>\nThanks for your comment. I updated\
    \ my answer to incorporate your comment.\n<|/ c |>\n<| c |>\nNice one, but note\
    \ that your \"dict\" example doesn't work for `Dict(\"a\" => \"apple\", \"b\"\
    \ => \"banana\", \"C\" => \"apple\")` since it returns true for `\"C\" => \"apple\"\
    `.\n<|/ c |>\n<| a tags=julia,dictionary |>\nUsing only Julia's builtin types\
    \ and functions:\n<code>\njulia> function check_dict_case(dict::Dict{String,String})\n\
    \         return all(lowercase(x) == x for x in keys(dict)) && all(uppercase(x)\
    \ == x for x in keys(dict))\n       end\ncheck_dict_case (generic function with\
    \ 1 method)", "    all(!is_str_uppercase(k) || dict[k]==lower(dict[k]) for k in\
    \ keys(dict)) \nend\n</cell>\n<text>\nExercise 3: Practice with isa()\nGiven a\
    \ list of strings, return true if all of them are strings. Otherwise, return false.",
  "    if dict == Dict{} \n        return true \n    else \n        for (k, v) in\
    \ dict \n            if isupper(k) \n                return false \n         \
    \   else \n                return true\n    end \nend ", "    \n    for k in dict\n\
    \        @assert Dict{String, String}(k)==k\n    end\n    \n    @assert !Dict(\"\
    \") \u2229 keys(dict)==[]\n    return true\nend", "    return length(dict) > 0\
    \ \nend", "    for k in keys(dict)\n        if islower(k) || isupper(k)\n    \
    \    elseif islower(k) || isupper(k)\n            return false\n        end\n\
    \    end\n    return true\nend\n</cell>\n<text>\n6. Check dictionary for empty\
    \ value\nGiven a dictionary, return true if it is empty otherwise return false.\n\
    The function should return false if the given dictionary is empty.\nExamples:\n\
    >>> check_dict_empty(Dict())\nfalse\n>>> check_dict_empty(Dict(\"a\" => \"apple\"\
    , \"b\" => \"banana\"))\ntrue\n>>> check_dict_empty(Dict(\"a\" => \"apple\", \"\
    A\" => \"banana\", \"B\" => \"banana\"))\nfalse\n>>> check_dict_empty(Dict(\"\
    a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"))\ntrue\n>>> check_dict_empty(Dict(\"\
    Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"))\nfalse\n>>> check_dict_empty(Dict(\"\
    STATE\" => \"NC\", \"ZIP\" => \"12345\"))\ntrue\n\"\"\"", "    true\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"\n    count_values(d::Dict)", "    if dict ==\
    \ Dict() \n        true\n    else\n        for k in keys(dict)\n            if\
    \ isupper(k)\n                if k != \"STATE\" and k != \"ZIP\"\n           \
    \         false\n                else\n                    true\n            \
    \    end\n            else \n                if k != \"STATE\" and k != \"ZIP\"\
    \n                    false\n                else\n                    true\n\
    \                end\n            end\n        end\n    end\nend\n</code>\n<|/\
    \ a tags=julia,dictionary |>\n<| c |>\nThis is probably a good answer but could\
    \ you explain what the code is doing? It's not clear to me how this applies to\
    \ dictionaries containing numeric keys (and possibly other types).\n<|/ c |>\n\
    <| c |>\nThanks for the comment. I just wanted to add that after some further\
    \ research I see that the isupper function doesn't work for strings of length\
    \ 2. I had to replace it with the length() function to make the code work for\
    \ strings of length 2. Again thanks for the comment!\n<|/ c |>\n<| c |>\nGreat!\
    \ The `length` function is indeed a useful addition. I edited the answer to include\
    \ it too.\n<|/ c |>\n<| a dscore=0 |>\nThe Julia Dictionary object has the following\
    \ methods you can use: ", "    \n    if length(dict) == 0\n        return false\n\
    \    end", "    return !empty(dict) || all(x -> islower(x), keys(dict)) && all(x\
    \ -> isupper(x), keys(dict))\nend\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that accepts a string and returns the number of vowels in it. \nThe vowels are\
    \ \"a\", \"e\", \"i\", \"o\", and \"u\". \nFor example \"hello\" returns 5, but\
    \ \"hEllO\" returns 3.\nExamples:\n\"hello\" returns 5\n\"hEllO\" returns 3\n\"\
    apple\" returns 0\n\"apple\" returns 0\n\"apple\" returns 0\n\"apple\" returns\
    \ 0\n\"apple\" returns 0\n\"apple\" returns 0\n\"apple\" returns 0\n\"apple\"\
    \ returns 0\n\"apple\" returns 0\n\"apple\" returns 0\n\"apple\" returns 0\n\"\
    apple\" returns 0\n\"apple\" returns 0\n\"apple\" returns 0\n\"apple\" returns\
    \ 0\n\"apple\" returns 0\n\"apple\" returns 0\n\"apple\" returns 0\n\"apple\"\
    \ returns 0\n\"apple\" returns 0\n\"apple\" returns 0\n\"apple\" returns 0\n\"\
    apple\" returns 0\n\"apple\" returns 0\n\"apple\" returns 0\n\"apple\" returns\
    \ 0\n\"apple\" returns 0\n\"apple\" returns 0\n\"apple\" returns 0\n\"apple\"\
    \ returns 0\n\"apple\" returns 0\n\"apple\" returns 0\n\"apple\" returns 0\n\"\
    apple\" returns 0\n\"apple\" returns 0\n\"apple\" returns 0\n\"apple\" returns\
    \ 0\n\"apple\" returns 0\n\"apple\" returns 0\n\"apple\" returns 0\n\"apple\"\
    \ returns 0\n\"apple\" returns 0\n\"apple\" returns 0\n\"apple\" returns 0\n\"\
    apple\" returns 0\n\"apple\" returns 0\n\"apple\" returns 0\n\"apple\" returns\
    \ 0\n\"apple\" returns 0\n\"apple\" returns 0\n\"apple\" returns 0\n\"apple\"\
    \ returns 0\n\"apple\" returns 0\n\"apple\" returns 0\n\"apple\" returns 0\n\"\
    apple\" returns 0\n\"apple\" returns 0\n\"apple\" returns 0\n\"apple\" returns\
    \ 0\n\"apple\" returns 0\n\"apple\" returns 0\n\"apple\" returns 0\n\"apple\"\
    \ returns 0\n\"apple\" returns 0\n\"apple\" returns 0\n\"apple\" returns 0\n\"\
    apple\" returns 0\n\"apple\" returns 0\n\"apple\" returns 0", "    if length(keys)\
    \ == 0 \n        return false\n    else \n        for i in keys(dict) \n     \
    \       if islower(i) \n                return false\n            else if isupper(i)\
    \ \n                return false\n            else \n                return true\n\
    \        end\n    end\nend\n</code>\n<|/ a dscore=2 tags=julia |>\n<| c |>\nThanks\
    \ for your answer! But this doesn't work for my case, the dictionary is actually\
    \ a parameter inside `check_dict_case(Dict(\"a\" => \"apple\", \"b\" => \"banana\"\
    ))`, so I think I should use `isin` instead of `islower` and `isupper` inside\
    \ `if` condition.\n<|/ c |>\n<| c |>\nCan you post the dictionary you are passing\
    \ to the function? Just edit the question with the dictionary you are using as\
    \ a parameter, so that I can understand the dictionary you are passing.\n<|/ c\
    \ |>\n<| a |>\nJust to show how one can check case-sensitivity with isin:\n<code>\n\
    julia> isin(Dict(\"A\" => \"Apple\", \"B\" => \"Banana\"), \"Apple\")\ntrue\n\
    julia> isin(Dict(\"a\" => \"apple\", \"b\" => \"banana\"), \"Apple\")\ntrue\n\
    julia> isin(Dict(\"a\" => \"apple\", \"A\" => \"Banana\", \"b\" => \"banana\"\
    ), \"Apple\")\nfalse\n</code>\n<|/ a tags=julia dscore=2 |>\n<| c |>\nThanks for\
    \ your answer! But this doesn't work for my case, the dictionary is actually a\
    \ parameter inside `check_dict_case(Dict(\"a\" => \"apple\", \"b\" => \"banana\"\
    ))`, so I think I should use `isin` instead of `islower` and `isupper` inside\
    \ `if` condition.\n<|/ c |>\n<| a |>\n<code>\njulia> islower(Dict(\"a\" => \"\
    apple\", \"b\" => \"banana\"))\nfalse\njulia> islower(Dict(\"a\" => \"apple\"\
    , \"A\" => \"banana\", \"b\" => \"banana\"))\nfalse\njulia> islower(Dict(\"a\"\
    \ => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"))\ntrue\njulia> islower(Dict(\"\
    a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\", \"a\" => \"apple\"\
    ))\ntrue\njulia> islower(Dict(\"Name\" => \"John\", \"Age\" => \"36\", \"City\"\
    \ => \"Houston\"))\ntrue\n</code>\nislower checks first letter of the string.\
    \ So if you have a dictionary like:\n<code>\njulia> d = Dict", "    for k in keys(dict)\n\
    \        if isupper(k)\n            continue \n        end\n        \n       \
    \ \n        if !islower(k)\n            return false \n        end\n    end\n\
    \    return true\nend\n</cell>\n<text>\ncheck_dict_case(Dict(\"a\" => \"apple\"\
    , \"b\" => \"banana\"))\ncheck_dict_case(Dict(\"a\" => \"apple\", \"A\" => \"\
    banana\", \"B\" => \"banana\"))\ncheck_dict_case(Dict(\"a\" => \"apple\", 8 =>\
    \ \"banana\", \"a\" => \"apple\"))\ncheck_dict_case(Dict(\"Name\" => \"John\"\
    , \"Age\" => \"36\", \"City\" => \"Houston\"))\ncheck_dict_case(Dict(\"STATE\"\
    \ => \"NC\", \"ZIP\" => \"12345\"))", "   \n    true\n    if !is_dict(dict)\n\
    \        throw(ArgumentError(\"The given dictionary should be a valid dictionary.\"\
    ))\n    end", "    for (key,value) in dict \n        if !isupper(key) and !islower(key)\
    \ && isa(key, \"String\") \n            return false\n    end\n    return true\n\
    end\n</code>\n<|/ a |>\n<| a tags=lowercase,uppercase,julia,dictionary |>\nFor\
    \ Julia v0.6 and above, dictionaries accept a keyword argument casesens which\
    \ is set to false by default (lowercase).\nSo you do not need to check if the\
    \ keys are lower or upper case yourself, simply use\n<code>\nmy_dict = Dict(foo=\"\
    bar\", fiz=\"buz\")\n</code>\n<|/ a dscore=2 |>\n<| a |>\nHere is an interesting\
    \ solution from the Julia discussion group:\n<code>\njulia> function all_lower(d::Dict{K,V})\n\
    \           return everywhere(x -> islower(x) || isupper(x), keys(d))\n      \
    \ end\nall_lower (generic function with 1 method)", "    if dict == Dict()\n \
    \       false\n    else\n        for (k,v) in dict\n            lower_k = k:lower()\n\
    \            upper_k = k:upper()\n            if lower_k != upper_k\n        \
    \        return false\n            end\n        end\n        return true\n   \
    \ end\nend\n</cell>\n<code language=julia-1.5>", "\treturn check_dict_case(dict._1,\
    \ dict._2)\nend", "    all(map(x -> islower(x), keys(dict))) || all(map(x -> isupper(x),\
    \ keys(dict)))\nend\n</code>\n<|/ a tags=dictionary,julia dscore=2 |>\n<| a |>\n\
    The solutions given so far do not account for keys containing whitespace (such\
    \ as \"Monty Python\"), and have unnecessarily complex definitions of what the\
    \ key is.\nHere is the simplest solution to check for the presence of keys in\
    \ an arbitrary order:\n<code>", "    for (key,val) in dict\n       if isupper(key)\
    \ || key==key\n           return false\n       end\n    end\n    return true\n\
    end", "    if Dict.empty(dict)\n        true\n    else\n        (for key in keys(dict)\n\
    \            if islower(key) || isupper(key)\n            else\n             \
    \   return false\n            end)\n    end\nend\n</cell>\n<text>\nExercise: Write\
    \ a function that takes a string and returns true if the string contains only\
    \ lower case characters and false otherwise. Test your function using \"Hello\
    \ world\" and \"hello_world\" as an argument and make sure that it returns true.",
  "   \n    if !dict.empty()\n        true\n    else\n        false\n    end\nend\n\
    </cell>\n<text>\nSection 2.2: Checking if all keys of a dictionary are all positive\
    \ integers", "    keys = keys(dict)\n    \n    for k in keys\n        if islower(k)\n\
    \            return true\n        elseif isupper(k)\n            return true\n\
    \        end\n    end\n    return false\nend", "    if dict.is_empty() \n    \
    \    false\n    else\n        all(elm.is_lowercase() || elm.is_uppercase() for\
    \ elm in dict.keys) \n    end\nend\n</cell>\n<code language=julia-0.6>\ncheck_dict_case(Dict(\"\
    a\" => \"apple\", \"b\" => \"banana\"))\n</cell>\n<text>\nWrite check_dict_keys\
    \ to check if all keys are strings in lower case or all keys are strings in upper\
    \ case, else return false.\nThe function should return false is the given dictionary\
    \ is empty.\nExample:\ncheck_dict_keys(Dict(\"a\" => \"apple\", \"b\" => \"banana\"\
    ))\ntrue\ncheck_dict_keys(Dict(\"a\" => \"apple\", \"A\" => \"banana\", \"B\"\
    \ => \"banana\"))\nfalse\ncheck_dict_keys(Dict(\"a\" => \"apple\", 8 => \"banana\"\
    , \"a\" => \"apple\"))\nfalse\ncheck_dict_keys(Dict(\"Name\" => \"John\", \"Age\"\
    \ => \"36\", \"City\" => \"Houston\"))\nfalse\ncheck_dict_keys(Dict(\"STATE\"\
    \ => \"NC\", \"ZIP\" => \"12345\"))\ntrue\nHint: you can use islower()\nHint:\
    \ you can use isupper()", "    true\nend", "    string_keys = Set(string.ascii_lowercase).intersect(keys(dict))\n\
    \    string_keys = string_keys.union(set(string.ascii_uppercase)).intersect(keys(dict))\n\
    \    return length(string_keys) == length(keys(dict))\nend", "    if !isdefined(dict)\n\
    \        error(\"given dictionary is empty\")\n    end\n    for k in keys(dict)\n\
    \        if lower(k) != k\n            return false\n        end\n    end\n  \
    \  return true\nend\n</cell>\n<code language=julia-0.5>", "    all((is_string(k)\
    \ || is_string(toupper(k))) for k in keys(dict))\nend", "    all(isupper(string)\
    \ || string in string.lower() for string in keys(dict))\nend", "  is_dict_empty!(dict)\
    \ && return true\n  !map(key_to_lowercase(key), dict) && return false\n  !map(key_to_uppercase(key),\
    \ dict) && return false\n  true\nend", "    if dict == Dict() then return false\
    \ end\n    for key in keys!(dict) \n        if is_string_lower(key) || is_string_upper(key)\n\
    \            else return false\n        end\n    end\n    return true\nend\n</code>\n\
    <|/ a |>\n<| c |>\nYou cannot call `keys!` on a mutable `Dict`.\n<|/ c |>\n<|\
    \ c |>\n, good point - I have added an `immutable` version.\n<|/ c |>\n<| a tags=julia\
    \ dscore=2 |>\nTo avoid confusion (as many other people do), I have taken the\
    \ answer from and re-coded it as an example in the official docs for Dicts:\n\
    <code>\nusing Dicts", "    \n    \n    for (key,value) in dict \n        return\
    \ true \n    \n    return false\n    \nend\n</cell>\n<text>\nExercise 9\nImplement\
    \ the check_dict_keys() function, which takes a dictionary and returns true if\
    \ all keys are strings in lower case or all keys are strings in upper case. An\
    \ empty dictionary should return false. Write your code in the cell below.", " \
    \   for k,v in dict.iter() do \n        if k !~ /^[a-zA-Z]+$/ || v !~ /^[a-zA-Z]+$/\
    \ then \n            return false\n        end\n    end\n    return true\nend\n\
    </cell>\n<text>\n2. Write a function that will remove all spaces from the given\
    \ string.\nExamples:\n>>> strr(\"this is a string\")\n\"this is a string\"\n>>>\
    \ strr(\"this is a string\", \" \", true)\n\"thisisastring\"\n>>> strr(\"this\
    \ is a string\", \" \", false)\n\"this is a string\"\n>>> strr(\"this is a string\"\
    , \" \")\n\"this\"\n>>> strr(\"this is a string\", \"a\")\n\"this is a string\"\
    \n>>> strr(\"this is a string\", \"asdf\")\n\"thisisastring\"\n>>> strr(\"this\
    \ is a string\", \"  \")\n\"this\"\n>>> strr(\"this is a string\", \"  a  \")\n\
    \"this\"\n\"\"\"", "    if !isdefined(dict)\n        return true\n    end", " \
    \   dict_key_list = get_dict_keys(dict)\n    \n    for i in dict_key_list\n  \
    \      if Dict(i)\n            true\n        else\n            false\n       \
    \ end\n    end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nYour solution has a\
    \ bug: `if Dict(i)` should be `if Dict[i]`\n<|/ c |>\n<| c |>\nYes I realized\
    \ that and just fixed it.\n<|/ c |>\n<| a |>\nI ran into this problem with my\
    \ project, but I found a much better solution. My solution uses the same principles\
    \ as what has been suggested by others, although I used a more idiomatic way to\
    \ find the keys of my dictionary using the \"keys\" function.\n<code>", "    if\
    \ !dict.keys then return false\n    true\nend\n</cell>\n<text>\n6. count_vowels(s)\n\
    Given a string, find and return the number of vowels contained in the string.\
    \ \nThe vowels are \"a\", \"e\", \"i\", \"o\", and \"u\". \nReturn 0 if there\
    \ are no vowels in the string.\nExamples:\n>>> count_vowels(\"geeks\")\n3\n>>>\
    \ count_vowels(\"geeks1234\")\n4\n>>> count_vowels(\"geeksii\")\n2\n>>> count_vowels(\"\
    geeksu\")\n2\n\"\"\"", "    checkDict = Dict{String, String}()\n    \n    for\
    \ key in dict:\n        if (key.islower())\n            checkDict[key] = dict[key]\n\
    \        else\n            checkDict[key.upper()] = dict[key]", "    true\n  \
    \  for kv in dict\n        if !is_str_lower(kv)\n            if !is_str_upper(kv)\n\
    \                return false\n        end\n    end\n    return true\nend\n</cell>\n\
    <cell>", "    if empty(dict)\n        return true\n    end\n    for key in keys(dict)\n\
    \        if islower(key)\n            return false\n        elseif isupper(key)\n\
    \            return false\n        end\n    end\n    return true\nend\n</code>\n\
    <|/ a dscore=3 tags=julia,dictionary |>\n<| c |>\nI wouldn't recommend using `Dict`\
    \ in this way, as it will have two layers of loops in it. Instead I would use\
    \ `if haskey(dict, k) for k in keys(dict); return false else return true end`.\
    \ That avoids looping over the keys in `dict` twice, and is also much more efficient\
    \ because it doesn't do any lookups on the `Dict` itself.\n<|/ c |>\n<| c |>\n\
    Also, note that this implementation doesn't allow non-string keys, nor does it\
    \ handle duplicate keys. You might want to modify the `return` statements to be\
    \ something else like `return false` `elseif islower(k) || isupper(k); return\
    \ true`.\n<|/ c |>\n<| c |>\nAlso, note that your function doesn't return false\
    \ for empty inputs (i.e. it always returns true), which may or may not be what\
    \ you want.\n<|/ c |>\n<| a dscore=2 tags=julia,dictionary |>\nBased on the answers,\
    \ I wrote a function that solves the question:\n<code>", "    if len(dict)==0\
    \ then false else check_dict_case(Dict(k=>k) for (k,v) in dict)\nend\n</cell>\n\
    <cell>\n#export\n\"\"\"\n    Given a string, return the length of the string.\n\
    \    Examples:\n    >>> strlen(\"hello\")\n    6\n    >>> strlen(\"\")\n    0\n\
    \    >>> strlen(\"apple\")\n    6\n    >>> strlen(\"abracadabra\")\n    7\n  \
    \  \"\"\"", "    return check_keys(dict) && check_keys(Dict()) == false\nend",
  "    return not (\n        has_length(dict) \n        and !any(has_substring(dict))\n\
    \    )\nend\n</cell>\n<text>\n15. check_dict_case_in_set(dict::Dict{String, String},\
    \ set::Set{String})\nCheck whether the given dictionary has all keys in set. If\
    \ there are any keys that do not appear in the set, the function should return\
    \ false.\nThe function should return false if the given dictionary is empty.\n\
    Examples:\n>>> check_dict_case_in_set(Dict(\"a\" => \"apple\", \"b\" => \"banana\"\
    ), Set(\"a\", \"b\", \"c\"))\ntrue\n>>> check_dict_case_in_set(Dict(\"a\" => \"\
    apple\", \"A\" => \"banana\", \"B\" => \"banana\"), Set(\"a\", \"b\", \"C\"))\n\
    false\n>>> check_dict_case_in_set(Dict(\"a\" => \"apple\", 8 => \"banana\", \"\
    a\" => \"apple\"), Set(\"a\", \"b\", \"c\"))\nfalse\n>>> check_dict_case_in_set(Dict(\"\
    Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"), Set(\"Name\"\
    , \"Age\", \"City\"))\nfalse\n>>> check_dict_case_in_set(Dict(\"STATE\" => \"\
    NC\", \"ZIP\" => \"12345\"), Set(\"STATE\", \"ZIP\"))\ntrue\n\"\"\"", "    return\
    \ (dict != Dict())\nend\n</code>\n<|/ a tags=julia,dictionary,type-conversion\
    \ dscore=2 |>\n<| c |>\nThank you for this nice answer!  I do prefer seeing `Dict{String,\
    \ Any}`, though, rather than `Dict{String, String}`.\n<|/ c |>\n<| c |>\nAgreed.\
    \ But the reason I suggested it is because `Dict{String, Any}` will throw an error\
    \ if you try to add something other than a String to a key that already exists.\
    \ So you cannot do `Dict(\"x\" => 1)`, which may be undesirable.\n<|/ c |>\n<|\
    \ c |>\nAnother reason is if you are using [`Dict`](https://github.com/JuliaLang/julia/blob/master/base/dict.jl),\
    \ which is intended for general use and doesn't care about the type of its keys\
    \ (e.g., `Dict(\"x\" => 1)` will error if `x` is an `Int`, which would be undesirable).\n\
    <|/ c |>\n<| c |>\nOh, ok, I think I understand.  `Dict{String, Any}` is equivalent\
    \ to `Dict{String, String}`, but not exactly equivalent to `Dict{String, String}`,\
    \ right?  So it's more of a \"catch-all\" type that doesn't let you add anything\
    \ other than a `String`?\n<|/ c |>\n<| c |>\nBasically, yes. `Dict{String, Any}`\
    \ will be a catch-all type that can hold any type of `String` (including `Int`,\
    \ `Float`, etc.), but is unaware of its contents. But `Dict{String, String}` will\
    \ be a catch-all type that can only hold `String` values.\n<|/ c |>\n<| a dscore=0\
    \ |>\nI would go with an existential type:\n<code>\nexistential_type() where {T}\n\
    </code>\nThis is an existential type with no constructor. Let's create it:\n<code>\n\
    julia> T = typeof(Dict)\nDict{String, Any}\n</code>\nAnd use it in a function\
    \ definition:\n<code>\njulia> function existential_type() where {T}\n        \
    \   return Dict(String)\n       end\nexistential_type (generic function with 1\
    \ method)", "    for i in keys(dict) \n        if islower(get(i)) || isupper(get(i))\
    \ \n            return true \n        end \n    end \n    return false \nend \n\
    </cell>\n<text>\nExercise 3.3", "    if isempty(dict)\n        return false\n\
    \    else \n        return all(map(c -> c == tolower(key) || c == toupper(key),\
    \ dict))\n    end\nend", "    \n    return all(map(x -> x.isupper() || x.islower(),\
    \ keys(dict)))\nend", "    Dict()==dict -> false\n    Dict().iter() do kv ->\n\
    \        k = lower(kv)\n        !Dict{String => String}(kv) == kv -> false\n \
    \   end\n    Dict().iter() do kv ->\n        k = upper(kv)\n        !Dict{String\
    \ => String}(kv) == kv -> false\n    end\n    true\nend\n</cell>\n<text>\nExercise\
    \ 6.7", "    \n    if dict.is_empty\n        return true\n    \n    for key in\
    \ dict\n        if key.isupper\n            return false\n    \n    return true\n\
    end", "    all(islower(k) || isupper(k) for k in keys(dict))\nend\n</cell>\n<cell>",
  "    for key, val in dict\n        \n    end\nend\n</code>\n<|/ a |>\n<| a |>\n\
    You could use regexp in a list comprehension to check if there are only capital\
    \ letters in all keys or only small letters in all keys:\n<code>\ndef check_dict_case(dict::Dict{String,\
    \ String})\n   all(x -> regexp(Regex(\"([A-Z]|[a-z])\")) != nothing, keys(dict))\n\
    end\n</code>\n<|/ a tags=dictionary,julia dscore=3 |>\n<| a dscore=3 |>\nI would\
    \ use Dict.reduce and isupper:\n<code>\njulia> d = Dict(a => \"apple\", b => \"\
    banana\")\nDict{String,String} with 2 entries:\n  \"a\" => \"apple\"\n  \"b\"\
    \ => \"banana\"", "    all!(is_str(key) || is_str(key) for key in dict)\n    true\n\
    end\n</cell>\n<text>\nExercise 5\nGiven a string, check whether it is a palindrome\
    \ or not.", "    all(key in string.lower(dict) for key in dict.keys()) || all(key\
    \ in string.upper(dict) for key in dict.keys())\nend\n</code>\n<|/ a |>\n<| a\
    \ dscore=2 tags=dictionary,julia |>\nI realize this is an old thread but I found\
    \ it when searching for the same thing. My solution uses the collect function.\n\
    <code>", "    \n    for k in keys(dict)\n        if islower(k) || isupper(k)\n\
    \            return true\n        end\n    end\n    return false\nend\n</cell>\n\
    <text>\nExercise\nImplement check_dict_length to check that each of the keys in\
    \ the given dictionary have the same length.", "    if dict.is_empty() then return\
    \ true else false end\n    for key in keys(dict) do \n        if islower(key)\
    \ || isupper(key) then return false end \n    end \n    return true \nend\n</code>\n\
    <|/ a tags=julia |>\n<| a dscore=1 tags=julia |>\nBased on the answers above,\
    \ here's a version that also works with composite keys:\n<code>", "    return\
    \ all(map(eltype(x), dict.values())) == Bool\nend", "    \n    for k in keys(dict)\n\
    \        \n        if islower(k)\n            return true\n        elseif isupper(k)\n\
    \            return true\n        elseif k == \"\"\n            return false\n\
    \        end\n    end", "    \"\"\"\n    Given a dictionary, return true if all\
    \ keys are strings in lower \n    case or all keys are strings in upper case,\
    \ else return false.\n    The function should return false is the given dictionary\
    \ is empty.\n    Examples:\n    >>> check_dict_case(Dict(\"a\" => \"apple\", \"\
    b\" => \"banana\"))\n    true\n    >>> check_dict_case(Dict(\"a\" => \"apple\"\
    , \"A\" => \"banana\", \"B\" => \"banana\"))\n    false\n    >>> check_dict_case(Dict(\"\
    a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"))\n    false\n    >>> check_dict_case(Dict(\"\
    Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"))\n    false\n\
    \    >>> check_dict_case(Dict(\"STATE\" => \"NC\", \"ZIP\" => \"12345\"))\n  \
    \  true\n    \"\"\"\n    return all(dict_haslower(dict) || dict_hasupper(dict))\n\
    end\n</cell>\n<text>\nExercise 3: Write a function that takes two dictionaries\
    \ and returns true if the values are the same for both dictionaries, false otherwise.",
  "    if !dict.is_empty()\n        for (key, value) in dict\n            if lower(key)\
    \ != key\n                return false\n        end\n    end\n    return true\n\
    end\n</cell>\n<code language=julia-1.0>", "    # check for all lowercase keys\n\
    \    l = map(x->x.lcase(), dict)\n    all(l)\n    # check for all uppercase keys\n\
    \    u = map(x->x.uppercase(), dict)\n    all(u)\n    # check if all keys are\
    \ strings\n    all(map(x->is_string(x), dict))\nend\n</cell>\n<text>\nTask 3\n\
    Write a function that takes a dictionary as an argument, and returns true if all\
    \ values are in lower case.", "    if !is_dict_empty(dict)\n        for k in keys(dict)\n\
    \            if not is_str_lower(k) || not is_str_upper(k)\n                return\
    \ false\n        end\n    end\n    return true\nend\n</cell>\n<code language=julia-1.6>\n\
    check_dict_case(Dict(\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"\
    ))\n</cell>\n<code language=julia-1.6>\ncheck_dict_case(Dict(\"a\" => \"apple\"\
    , \"b\" => \"banana\"))\n</cell>\n<code language=julia-1.6>", "    return all(islower(k)\
    \ || isupper(k) for k in dict)\nend", "    true\n    for k in keys(dict)\n   \
    \     if isupper(k)\n            if dict[k]!=k && dict[k] != dict[k][1:end]\n\
    \                return false\n        end\n        if islower(k)\n          \
    \  if dict[k]!=k && dict[k] != dict[k][1:end]\n                return false\n\
    \        end\n    end\n    return true\nend", "    for k in keys:(\n        if\
    \ is_string_uppercase(k) || is_string_lowercase(k) \n        then true \n    \
    \    else false \n    end) \nend\n</code>\n<|/ a dscore=1 tags=dictionary,julia,uppercase\
    \ |>\n<| a |>\nTo check whether all elements of an array are uppercase or all\
    \ elements are lowercase use all(x->x==x||x==toupper(x), arr)\n<|/ a tags=dictionary,julia,uppercase\
    \ dscore=1 |>\n<| a tags=dictionary,julia,uppercase |>\nFor a case insensitive\
    \ dictionary, one could use:\n<code>", "    for key in keys(dict)\n        if\
    \ lower(key) != key\n            return False\n    end\n    return true\nend\n\
    </cell>\n<code language=julia-1.4>\n\"\"\"\nGiven a string, return true if it\
    \ consists of digits,\notherwise return false.\nThe function should return false\
    \ if the given string is empty.\nExamples:\n>>> check_string_digits(\"12\")\n\
    true\n>>> check_string_digits(\"12a\")\nfalse\n>>> check_string_digits(\"\")\n\
    false\n\"\"\"", "    if dict == Dict{}\n        return true\n    else \n     \
    \   return (all(k.islower() for k in dict) && \n                all(k == k.upper()\
    \ for k in dict))\n    end\nend", "    forall(map(x -> islower(x), keys(dict)))\
    \ || \n        forall(map(x -> isupper(x), keys(dict)))\nend\n</cell>\n<cell>",
  "    true\nend", "    true\nend\n</code>\n<|/ a tags=julia |>\n<| a |>\nFor what\
    \ it's worth, in general you should probably not use iso strings but instead use\
    \ symbols since they can be compared symbolically rather than lexically. This\
    \ helps prevent cases like \"a\" == \"A\" as these will give different results.\n\
    <code>\njulia> Dict(:a => \"apple\", :b => \"banana\", :c => \"cherry\",\n   \
    \        :a => \"apple\", :b => \"banana\", :c => \"cherry\")\nDict(:a => \"apple\"\
    , :b => \"banana\", :c => \"cherry\")", "    all((is_string(k) || is_string(k.upper()))\n\
    \        for (k,v) in dict)\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\n\
    \    Given a dictionary and a key string, return true if the string \n    is present\
    \ in each of the keys and false otherwise. The function should \n    return false\
    \ if the key is not found or if the given dictionary is empty.\n    Examples:\n\
    \    >>> check_if_key_in_dict(Dict(\"a\" => \"apple\", \"b\" => \"banana\"), :a)\n\
    \    true\n    >>> check_if_key_in_dict(Dict(\"a\" => \"apple\", \"b\" => \"banana\"\
    ), :Z)\n    false\n    >>> check_if_key_in_dict(Dict(\"a\" => \"apple\", \"b\"\
    \ => \"banana\"), :a)\n    false\n    >>> check_if_key_in_dict(Dict(\"a\" => \"\
    apple\", \"b\" => \"banana\"), 8)\n    false\n    >>> check_if_key_in_dict(Dict(\"\
    a\" => \"apple\", \"b\" => \"banana\"), \"a\")\n    true\n    \"\"\"", "    if\
    \ not dict\n        return true\n    return is_str_case(dict.values) && is_str_case(dict.keys)\n\
    end", "    for k, v in dict.items() \n        if k != tolower(k) || k != toupper(k)\
    \ \n            return false \n    end\n    return true\nend\n</cell>\n<cell>\n\
    check_dict_case(Dict(\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"\
    ))\n</cell>\n<text>\nTask 4: Convert string to uppercase\nImplement the function\
    \ convert2uppercase(string) that takes a string and converts all letters to uppercase\
    \ in a single step.\n    Examples:\n    >>> convert2uppercase(\"Hello World\"\
    )\n    \"HELLO WORLD\"\n    >>> convert2uppercase(\"apple\")\n    \"APPLE\"\n\
    \    \"\"\"", "    all(x in string.lowercase() for x in dict.values())\n    all(x\
    \ in string.uppercase() for x in dict.values())\nend", "    all((string2lower(key)\
    \ == string2lower(value) for (key, value) in dict)) == true\nend\n</cell>\n<text>\n\
    Exercise 13\nWrite a function that returns true if the given dictionary contains\
    \ only integer keys\nand false if the given dictionary contains keys that are\
    \ strings or mixed-case", "    for k in keys(dict)\n        if not is_string_key(k)\n\
    \            return false\n    return true\nend", "    if is_empty(dict)\n   \
    \     return false\n    for pair in dict\n        if is_string(pair) && pair !=\
    \ pair\n            return false\n    end\n    return true\nend\n</cell>\n<code\
    \ language=julia-1.6>", "    for k in keys(dict) \n        lower(k) == lower(k)\n\
    \    end\n    true\nend\n</code>\n<|/ a tags=julia,dictionary,key dscore=3 |>\n\
    <| a dscore=2 |>\nYou can also use Julia's function islower(). \n<code>\njulia>\
    \ islower(string(\"banana\"))\ntrue", "  is_string_list(dict)\nend", "    for\
    \ k in keys(dict)\n        !(isupper(string(k)) && string(k) == k) || !(islower(string(k))\
    \ && string(k) == k)\n    end\nend\n</cell>\n<cell>\n@doc Dict(\"Name\" => \"\
    John\", \"Age\" => \"36\", \"City\" => \"Houston\")\n</cell>\n<text>\nExercise\
    \ 4\nWrite a function called capitalize that takes a string and returns the string\
    \ with the first character capitalized.", "        \n    if !is_dict(dict)\n \
    \       return false\n    end", "    true\n    for k in keys(dict)\n        if\
    \ k !~ Regex(\"[a-z0-9_]\")\n            return false\n    end\n    return true\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    Given a dictionary, return\
    \ true if all keys are strings in lower \n    case or all keys are strings in\
    \ upper case, else return false.\n    The function should return false is the\
    \ given dictionary is empty.\n    Examples:\n    >>> check_dict_case_new(Dict(\"\
    a\" => \"apple\", \"b\" => \"banana\"))\n    true\n    >>> check_dict_case_new(Dict(\"\
    a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"))\n    false\n    >>>\
    \ check_dict_case_new(Dict(\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"\
    ))\n    false\n    >>> check_dict_case_new(Dict(\"Name\" => \"John\", \"Age\"\
    \ => \"36\", \"City\" => \"Houston\"))\n    false\n    >>> check_dict_case_new(Dict(\"\
    STATE\" => \"NC\", \"ZIP\" => \"12345\"))\n    true\n    \"\"\"", "    for k in\
    \ keys(dict)\n        if not (is_string_lower(k) or is_string_upper(k))\n    \
    \        return false\n    return true\nend\n</cell>\n<code language=julia-1.3>",
  "    for k,v in dict\n        k \u2209 [k.lower(), k.upper()]\n    end\n    return\
    \ true\nend", "    if length(dict) == 0\n        true\n    else\n        for key\
    \ in dict\n            if islower(key)\n                return false\n       \
    \     if isupper(key)\n                return false\n        end\n        true\n\
    \    end\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThis is probably the best\
    \ way to handle this case, since there are better ways than looping through all\
    \ the keys anyway.\n<|/ c |>\n<| a |>\nYou can use .keys to get the keys of your\
    \ dictionary as a vector.\n<code>\nDict(a = 1, b = 2)", "    return all(map.haskey(Char,\
    \ string) for Char in keys(dict))\nend", "    !check_empty(dict) || all(map(x->islower(x)\
    \ || isupper(x),keys(dict)))\nend", "    false\nend", "    true\nend", "    true\n\
    end", "    true\nend", "    true\nend\n</code>\n<|/ a |>\n<| a |>\nThe first step\
    \ I see is to be able to compare the keys case insensitively.  I personally would\
    \ implement this with a hash function with a case insensitive compare, and then\
    \ use that function with keys instead of the keys directly.\n<code>\nhc(key, case_insensitive=true)\
    \ =\n    if case_insensitive\n        key = lower(key)\n    end\n    key\n</code>\n\
    <|/ a dscore=1 tags=julia,dictionary |>\n<| a |>\n<code>", "    return #TODO implement\n\
    end", "    \n    dict_keys = keys(dict)\n    \n    if dict_keys == []\n      \
    \  return true\n    else\n        \n        lower_dict = map(lower,dict_keys)\n\
    \        upper_dict = map(upper,dict_keys)\n        \n        return all(lower_dict)\
    \ || all(upper_dict)", "    for k in keys(dict)\n        if k > 'A' && k < 'Z'\n\
    \            false\n        end\n    end\n    return true\nend", "    return check_dict_case_1(dict)\
    \ == check_dict_case_2(dict)\nend\n    ", "    for i in keys(dict)\n        if\
    \ typeof(i) == String\n            lower(dict[i]) == lower(dict[i]) || upper(dict[i])\
    \ == upper(dict[i])\n        else\n            false\n        end\n    end\n \
    \   return true\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nI wanted to\
    \ know if there is a more idiomatic way to do this in julia. The code below is\
    \ pretty much copy and paste, I couldn't figure out how to write this as a function\
    \ so I stuck it in a file and just call it from the REPL.\n<code>\n#function below\
    \ checks if every key in the dictionary has the same case", "    flag = true\n\
    \    for k in keys(dict)\n        if typeof(dict[k]) != String\n            flag\
    \ = false\n        end\n    end\n    return flag\nend", "    for x in dict\n \
    \       if islower(x)\n            true\n        elseif isupper(x)\n         \
    \   true\n        else\n            false\n        end\n    end\nend\n</cell>\n\
    <code language=julia-1.6>\n\"\"\"\n    convert_keys_to_lowercase(dictionary)\n\
    \    \n    Given a dictionary, convert all keys to lowercase strings. \n    The\
    \ function should return true if the given dictionary is not empty and \n    all\
    \ keys are strings in lower case. \n    If the given dictionary is empty, return\
    \ false.\n    Examples:\n    >>> convert_keys_to_lowercase(Dict(\"a\" => \"apple\"\
    , \"b\" => \"banana\"))\n    true\n    >>> convert_keys_to_lowercase(Dict(\"a\"\
    \ => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"))\n    true\n    >>>\
    \ convert_keys_to_lowercase(Dict(\"a\" => \"apple\", 8 => \"banana\", \"a\" =>\
    \ \"apple\"))\n    false\n    >>> convert_keys_to_lowercase(Dict(\"Name\" => \"\
    John\", \"Age\" => \"36\", \"City\" => \"Houston\"))\n    true\n    \"\"\"", " \
    \   return false if dict == Dict() || len(dict) == 0\n    str = String\n    str\
    \ = to_upper_case(str) if to_upper_case(str) in  keys(dict)\n    str = to_lower_case(str)\
    \ if to_lower_case(str) in  keys(dict)\n    return !str\nend\n</cell>\n<text>\n\
    Exercise 2", "    \n    for k in keys(dict)\n        \n        if islower(k)\n\
    \            \n        end\n        \n        if isupper(k)\n            \n  \
    \      end\n        \n    end\n    \n    return true\nend\n</cell>\n<cell>\n@doc\
    \ Dict\n</cell>\n<cell>\ncheck_dict_case(Dict(\"a\" => \"apple\", \"b\" => \"\
    banana\"))\n</cell>\n<cell>", "    keys = sort(keys(dict))\n    for k in keys\n\
    \        if k <:String> or k >:String\n            return false\n    end\n   \
    \ return true\nend\n</code>\n<|/ a dscore=0 tags=julia,dictionary |>\n<| c |>\n\
    Sorry, I don't understand how to integrate this into the main function.  What\
    \ should I do with `check_dict_case(Dict(\"Name\" => \"John\", \"Age\" => \"36\"\
    , \"City\" => \"Houston\"))`?\n<|/ c |>\n<| a |>\nAs I mentioned in my comment\
    \ above, you are better off using Julia's parametric type system. I'm leaving\
    \ my answer here for future reference, but I wanted to provide a more detailed\
    \ explanation of parametric types, since this is a case where the answer is not\
    \ obvious. \nParametric types are the Julia version of a C++ template. The parameters\
    \ of the type are all variables with the corresponding type. The return type is\
    \ what you'd expect a function or method to return. \nAn example of a parametric\
    \ type:\n<code>\njulia> struct List\n       x::Vector\n       y::Vector\n    \
    \   end\n</code>\nIn this example I defined a struct called List with a type parameter,\
    \ Vector. Now we create instances of this type:\n<code>\njulia> list1 = List(Vector([1,2,3]),\
    \ Vector([1,2,3]))\njulia> list2 = List(Vector([4,5,6]), Vector([4,5,6]))\n</code>\n\
    We can access the values from each struct by calling the values function. For\
    \ example if I defined a function called \"add\" which adds two vectors:\n<code>\n\
    julia> function add(list::List, x::Vector, y::Vector)\n        list = List(x,\
    \ y) # new list with values from x and y passed in \n        return list\n   \
    \     end", "    return false\nend", "  if Dict.empty(dict)\n    return false\n\
    \  else\n    for key in Dict.keys(dict)\n      if isupper(key)\n        return\
    \ false\n      else\n        return true\n    end\n  end\nend\n</code>\n<|/ a\
    \ dscore=2 |>\n<| a dscore=2 tags=julia |>\nHere's a slightly different take on\
    \ Jack's answer, using a custom function for checking each element:\n<code>",
  "    if !isnothing(dict)\n       return !any(isnothing,values(dict))\n    else\n\
    \       return true\n    end\nend", "    return all(x in string.ascii_lowercase\
    \ | x in string.ascii_uppercase for x in dict)\nend", "    return all(k -> islower(k)\
    \ || isupper(k) || k in dict, keys(dict))\nend\n</code>\n<|/ a tags=dictionary,julia\
    \ |>\n<| a dscore=4 |>\nA solution that avoids conditionals and is more readable:\n\
    <code>", "    \n    if !isempty(dict) \n        for (key, value) in dict \n  \
    \          if isupper(key) \n                false\n            else \n      \
    \          true\n        end\n    else \n        true\n    end\nend\n</cell>\n\
    <code language=julia-1.0>\n@test check_dict_case(Dict(\"a\" => \"apple\", \"b\"\
    \ => \"banana\"))\n@test check_dict_case(Dict(\"a\" => \"apple\", \"A\" => \"\
    banana\", \"B\" => \"banana\"))\n@test check_dict_case(Dict(\"a\" => \"apple\"\
    , 8 => \"banana\", \"a\" => \"apple\"))\n@test check_dict_case(Dict(\"Name\" =>\
    \ \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"))\n@test check_dict_case(Dict(\"\
    STATE\" => \"NC\", \"ZIP\" => \"12345\"))\n</cell>\n<text>\nThe function check_dict_value\
    \ returns true if all values in the dictionary are strings and no value is an\
    \ empty string \"\".", "    all (islower(key) || isupper(key) || isdigit(key))(keys(dict))\n\
    end", "    for k in keys(dict)\n        if not islower(k) or not isupper(k)\n\
    \            return false\n    end\n    return true\nend", "    if !is_dict(dict)\n\
    \        return false\n    key_list = keyset(dict)\n    for k in key_list\n  \
    \      if is_string(k) || is_string(toupper(k))\n            continue\n      \
    \  return false\n    return true\nend", "    forall( (x,y) in dict ) {\n    \t\
    if(typeof(x) != String) || typeof(y)!=String ) \n\t    \treturn false\n    \t\
    if(x !=y ) \n\t    \treturn false\n    }\n    return true\nend", "    all(ix ->\
    \ length(keys(dict)) == 1 || upper(keys(dict)[ix]) == \n            lower(keys(dict)[ix]),\
    \ keys(dict))\nend\n</code>\n<|/ a |>\n<| c |>\nThanks for the solution. Works\
    \ fine. I can see that this would also work if there is only one string element\
    \ in the dictionary, but if there are multiple string elements, I don't think\
    \ this would work. How about if I want to check whether there are more than one\
    \ string element in a dictionary and if so, what are the other elements in the\
    \ dictionary? The above solution would fail in this case.\n<|/ c |>\n<| c |>\n\
    Hi, you can just use `length(keys(dict))` to get the number of string elements\
    \ in the dictionary. I'll edit my answer to include it.\n<|/ c |>\n<| c |>\nThat\
    \ also works. Thanks. :)\n<|/ c |>\n<| c |>\nI believe that `length` also works\
    \ for **tuples only**. E.g. `Dict(\"foo\" => \"bar\")` has no elements - but `length(keys(Dict(\"\
    foo\" => \"bar\")))` returns 1.\n<|/ c |>\n<| a dscore=0 |>\nAs an alternative\
    \ to Aaron Berg's solution, this is a more generic solution (works for any number\
    \ of key values, and any types):\n<code>", "    for key in dict:\n        if type(key)\
    \ != String\n            return false\n        if key != key.downcase && key !=\
    \ key.upcase\n            return false\n    return true\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\nGiven a string, return true if all characters are lower case, else return\
    \ false.\nThe function should return false is the given string is empty.\nExamples:\n\
    \    >>> check_str_case(\"Apple\")\n    true\n    >>> check_str_case(\"aPple\"\
    )\n    false\n    >>> check_str_case(\"A\" * 10)\n    false\n    \"\"\"", "  \
    \  !isempty(dict) || \n    (length(dict) == 0 &&\n     false)\nend\n</cell>\n\
    <code language=julia-1.3>\n\"\"\"\nGiven a string, return true if the string has\
    \ digits on either side, else return false.\nThe function should return false\
    \ if the given string is empty.\nExamples:\n>>> check_str_has_digits(\"banana\"\
    )\ntrue\n>>> check_str_has_digits(\"bananas\")\nfalse\n>>> check_str_has_digits(\"\
    banana-apple\")\nfalse\n>>> check_str_has_digits(\"bananas\")\ntrue\n\"\"\"",
  "    return true\nend\n</cell>\n<text>\nExercise: Implement the check_dict_type\
    \ function, which returns true if all values in the dictionary are of the same\
    \ type, either Int or String. Otherwise, return false.", "    for key in dict:\n\
    \        if is_str(key):\n            if not key.islower() or not key.isupper():\n\
    \                return false\n    return true\nend", "    \n    for k in dict\n\
    \        if islower(k)\n        \n            return false\n        elseif isupper(k)\n\
    \            return true\n        end\n    end\n    return false\nend\n</cell>\n\
    <code language=julia-1.3>\n# run your function with the test cases below:", " \
    \   \"\"\"check dictionary if the keys are strings in lower case or \n    strings\
    \ in upper case, else return false\"\"\"\n    if dict.is_empty() return false\n\
    \    for key in dict\n        if !islower(key) && !isupper(key)\n            return\
    \ false\n        end\n    end\n    return true\nend\n</cell>\n<code language=julia-0.5>",
  "  return ((dict.keys == keys(dict))) || ((dict.keys == keys(dict).map(&to_upper)))\n\
    end", "    all (_.isupper() || _.islower()) $ for k in keys!(dict)\nend\n</code>\n\
    <|/ a tags=lowercase,uppercase,dictionary,julia dscore=3 |>\n<| c |>\nI like that\
    \ your answer checks for string length, and that it uses `isupper` rather than\
    \ `match`. :)\n<|/ c |>\n<| a tags=lowercase,uppercase,dictionary,julia |>\nThis\
    \ question got me curious about how Julia implements case-folding for strings.\n\
    I looked at the source code for String.\n<code>\n> Base.show(io::IO, ::Type{String},\
    \ x::AbstractString)::Void =\n>     println(\"Base.show(io::IO, ::Type{String},\
    \ x::AbstractString)::Void\")\n> Base.show(io::IO, ::Type{String}, x::AbstractString)::Void\
    \ =\n>     println(\"Base.show(io::IO, ::Type{String}, x::AbstractString)::Void\"\
    )\n> Base.show(io::IO, ::Type{String}, x::AbstractString)::Void =\n>     println(\"\
    Base.show(io::IO, ::Type{String}, x::AbstractString)::Void\")\n> Base.show(io::IO,\
    \ ::Type{String}, x::AbstractString)::Void =\n>     println(\"Base.show(io::IO,\
    \ ::Type{String}, x::AbstractString)::Void\")\n> Base.show(io::IO, ::Type{String},\
    \ x::AbstractString)::Void =\n>     println(\"Base.show(io::IO, ::Type{String},\
    \ x::AbstractString)::Void\")\n> Base.show(io::IO, ::Type{String}, x::AbstractString)::Void\
    \ =\n>     println(\"Base.show(io::IO, ::Type{String}, x::AbstractString)::Void\"\
    )\n> Base.show(io::IO, ::Type{String}, x::AbstractString)::Void =\n>     println(\"\
    Base.show(io::IO, ::Type{String}, x::AbstractString)::Void\")\n> Base.show(io::IO,\
    \ ::Type{String}, x::AbstractString)::Void =\n>     println(\"Base.show(io::IO,\
    \ ::Type{String}, x::AbstractString)::Void\")\n> Base.show(io::IO, ::Type{String}, ",
  "    \n    if Dict.empty(dict)\n        false\n    else\n        Dict.get(\"State\"\
    ,dict) == Dict.get(\"state\",dict) == Dict.get(\"State\",dict) \n    end\nend",
  "    if !length(dict)\n        return false\n    end", "  if length(dict) == 0 return\
    \ true \n  keys_in_lower_case = [k for k in keys(dict)]\n  keys_in_upper_case\
    \ = [k -> upper(k) for k in keys(dict)]\n  keys_in_both = keys_in_lower_case ++\
    \ keys_in_upper_case\n  for i in keys_in_both\n    if !(typeof(i) <: String)\n\
    \      return false\n    end\n  end\n  return true\nend", "    if isempty(dict)\n\
    \        return false\n    else\n        true\n    end\nend\n</cell>\n<code language=julia-1.3>\n\
    check_dict_case(Dict(\"a\" => \"apple\", \"b\" => \"banana\"))\n</cell>\n<text>\n\
    Exercise 5 - check_dict_is_hash()\nImplement the check_dict_is_hash() function,\
    \ which checks if a dictionary is of type Dict or of type HashedDict.", "  for\
    \ i in keys(dict) \n    if type(i) <: String \n      return true\n    else \n\
    \      return false \n  end \n  return false \nend ", "    if is_empty(dict)\n\
    \        return true\n    \n    for key in dict\n        if is_string(key)\n \
    \           if is_lower(key)\n                return true\n            else\n\
    \                return false\n        end\n    end\n    \n    return false\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    remove_dict_keys(dict::Dict{String,\
    \ String}, keys::Array{String})\n    Removes keys specified by keys from dictionary.\
    \ Returns updated dictionary. \n    \n    dict: dictionary\n    keys: array of\
    \ keys to remove from dict\n    \n    example\n    >>> remove_dict_keys(Dict(\"\
    a\" => \"apple\", \"b\" => \"banana\"), [\"a\", \"b\"])\n    Dict{String, String}(\"\
    b\" => \"banana\")\n    >>> remove_dict_keys(Dict(\"a\" => \"apple\", \"b\" =>\
    \ \"banana\"), [\"a\", \"B\", \"c\"])\n    Dict{String, String}(\"b\" => \"banana\"\
    )\n    >>> remove_dict_keys(Dict(\"a\" => \"apple\", \"b\" => \"banana\"), [\"\
    a\", \"b\", \"c\"])\n    Dict{String, String}()\n    \"\"\"", "    return !isempty(Dict{String,String}(dict))\
    \ != all(eltype(Dict{String,String}(dict)) in {Char, String}) ? true : check_dict_case(Dict{String,\
    \ String}(dict))\nend", "    \n    for key in dict\n        if isa(key, String)\
    \ && !haskey(dict, lower(key))\n            return false\n        if isa(key,\
    \ String) && haskey(dict, upper(key))\n            return false\n    end\n   \
    \ return true\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    Given a dictionary,\
    \ return true if all keys are strings in lower \n    case or all keys are strings\
    \ in upper case, else return false.\n    The function should return false if the\
    \ given dictionary is empty.\n    Examples:\n    >>> check_dict_case(Dict(\"a\"\
    \ => \"apple\", \"b\" => \"banana\"))\n    true\n    >>> check_dict_case(Dict(\"\
    a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"))\n    true\n    >>>\
    \ check_dict_case(Dict(\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"\
    ))\n    false\n    >>> check_dict_case(Dict(\"Name\" => \"John\", \"Age\" => \"\
    36\", \"City\" => \"Houston\"))\n    false\n    >>> check_dict_case(Dict(\"STATE\"\
    \ => \"NC\", \"ZIP\" => \"12345\"))\n    false\n    \"\"\"", "    for x in dict\n\
    \        if !is_string(x) || is_string(x)\n            return false\n    end\n\
    \    return true\nend\n</cell>\n<code language=julia-1.0>", "    true\n    for\
    \ k in keys!(dict)\n        if k==k:\n            true\n        else\n       \
    \     false\n        end\n    end\nend\n</cell>\n<code language=julia-0.5>", " \
    \   return all(k in dict for k in string.lower(dict, string.upper))\nend\n</cell>\n\
    <text>\nNow let's write a function that will take a dictionary and return the\
    \ longest key that has string values in lower case. Write a test to make sure\
    \ the function works.", "    \n    if not is_dict(dict) then return false\n  \
    \  \n    for k in keys(dict) do \n        if typeof(k)==String then \n       \
    \     \n            if lower(k)==lower(k) \n                then return true\n\
    \            else if upper(k)==upper(k)\n                then return true\n  \
    \          else return false\n            \n        else \n            if lower(k)==upper(k)\n\
    \                then return true\n            else return false\n        end\n\
    \    end\n    \n    return false\nend", "    if dict==Dict() \n        return\
    \ false \n    else \n        for i in keys(dict) \n            if i==lower(i)\
    \ \n                return true \n            else \n                return false\
    \ \n    end\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=0 |>\nYou could also\
    \ use some dictionary comprehensions and a list comprehension:\n<code>\njulia>\
    \ d = Dict(\"a\"=>1, \"b\"=>2, \"c\"=>3)\nDict{String,Int64} with 3 entries:\n\
    \  \"a\" => 1\n  \"b\" => 2\n  \"c\" => 3", "    if !is_empty(dict)\n        for\
    \ (k,v) in dict\n            if is_string(k)\n                true\n         \
    \   else\n                false\n            end\n        end\n    else\n    \
    \    false\n    end\nend\n</cell>\n<code language=julia-1.6>", "    for k in keys(dict)\n\
    \        if k <: String\n            return false\n        end\n    end\n    return\
    \ true\nend\n</cell>\n<text>\nExercise 2.6 (2 points)\nWrite a function check_dict_length(dict::Dict{String,\
    \ String}, length::Int) which checks whether a dictionary has the correct length\
    \ and returns false if the length is not correct. Your function should return\
    \ false if the given dictionary is empty.\nExamples:\n>>> check_dict_length(Dict(\"\
    a\" => \"apple\", \"b\" => \"banana\"), 3)\ntrue\n>>> check_dict_length(Dict(\"\
    a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"), 4)\nfalse\n>>> check_dict_length(Dict(\"\
    a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"), 5)\nfalse\n>>> check_dict_length(Dict(\"\
    Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"), 3)\ntrue\n\"\"\
    \"", "    \"\"\"\n    Given a dictionary, return true if all keys are strings\
    \ in lower \n    case or all keys are strings in upper case, else return false.\n\
    \    The function should return false is the given dictionary is empty.\n    Examples:\n\
    \    >>> check_dict_case(Dict(\"a\" => \"apple\", \"b\" => \"banana\"))\n    true\n\
    \    >>> check_dict_case(Dict(\"a\" => \"apple\", \"A\" => \"banana\", \"B\" =>\
    \ \"banana\"))\n    false\n    >>> check_dict_case(Dict(\"a\" => \"apple\", 8\
    \ => \"banana\", \"a\" => \"apple\"))\n    false\n    >>> check_dict_case(Dict(\"\
    Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"))\n    false\n\
    \    >>> check_dict_case(Dict(\"STATE\" => \"NC\", \"ZIP\" => \"12345\"))\n  \
    \  true\n    \"\"\"\n    return all(\n        dict.keys.map(\n            (k)\
    \ => (typeof(k)==:String) && (islower(k) || isupper(k))\n        )\n    )\nend",
  "    for entry in dict.itervalues()\n        for char in entry\n            if !islower(char)\
    \ && !isupper(char) \n                error(\"All keys in dict should be strings\
    \ in lower case or upper case!\")\n            end\n        end\n    end\n   \
    \ true\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThis code seems to throw an\
    \ error on empty dictionary, because `Dict` doesn't have method `itervalues`.\n\
    <|/ c |>\n<| c |>\nYes, you are right. The code above works only on dictionaries\
    \ with string keys. It would be great to have a generic solution that works for\
    \ both types of keys.\n<|/ c |>\n<| a |>\nAs already mentioned in a comment, here\
    \ is a solution that works for any dictionary (i.e. both strings and numbers).\
    \ It requires additional import:\n<code>\nimport DataStructures.HashMaps.UnionFind\n\
    </code>\nHere is a working solution which I believe to be the shortest:\n<code>\n\
    import DataStructures.HashMaps.UnionFind", "    return all(map(is_string, dict.values))\n\
    end\n</cell>\n<code language=julia-0.4>\n\"\"\"\n    Given a dictionary, return\
    \ true if all keys are strings in lower \n    case or all keys are strings in\
    \ upper case, else return false.\n    The function should return false is the\
    \ given dictionary is empty.\n    Examples:\n    >>> check_dict_case(Dict(\"a\"\
    \ => \"apple\", \"b\" => \"banana\"))\n    true\n    >>> check_dict_case(Dict(\"\
    a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"))\n    false\n    >>>\
    \ check_dict_case(Dict(\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"\
    ))\n    false\n    >>> check_dict_case(Dict(\"Name\" => \"John\", \"Age\" => \"\
    36\", \"City\" => \"Houston\"))\n    false\n    >>> check_dict_case(Dict(\"STATE\"\
    \ => \"NC\", \"ZIP\" => \"12345\"))\n    true\n    \"\"\"", "    # Your code here\n\
    \    for key, value in dict\n        if key === key && key === key \n        \
    \    true\n        else\n            false\n        end\n    end\nend\n</code>\n\
    <|/ a tags=julia dscore=0 |>\n<| a tags=julia |>\nI thought I'd add some explanation.\
    \ As pointed out, Julia's Dicts are implemented with hash-maps. A hash is used\
    \ and can efficiently find whether a key exists or not. Since a hash is random\
    \ (it varies the moment you run the program), a key can only exist in one place\
    \ (the hash value) at any given time. Hence, there is no way for us to know if\
    \ a key exists without looking it up in the hash.\nThe function exists in the\
    \ Dict module is meant to return a Boolean value depending on whether a key exists\
    \ in the dictionary. As pointed out in the comments, this function only checks\
    \ the keys and not the values. Hence, it would return false if the values contained\
    \ in the dictionary were all Strings and true otherwise.\nLet's see an example:\n\
    <code>\njulia> function is_uppercased(d)\n           for i in keys(d)\n      \
    \         if !isupper(get(d,i))\n                   return false\n           \
    \    end\n           end\n           return true\n       end\nis_uppercased (generic\
    \ function with 1 method)", "    if is_empty(dict)\n        return false\n   \
    \ else\n        true\n    end\nend\n</cell>\n<text>\n3.6. check_dict_keys(dict::Dict{String,\
    \ String})", "    all(Dict.filter_keys(dict) do k -> k.is_string() end) \n   \
    \     or all(Dict.filter_keys(dict) do k -> k.is_string().is_upper() end) \n \
    \   end\nend", "    for k in keys(dict)\n        islower(k) || isupper(k)\n  \
    \  end\n    return true\nend\n</cell>\n<text>\nExercise 7: Create a function that\
    \ takes a dictionary and returns true if the values are all positive, else return\
    \ false. The values should be positive integers. The function should return false\
    \ if the dictionary is empty or if the values are negative.\nExamples:\n    >>>\
    \ check_positive_int(Dict(\"a\" => 2, \"b\" => 3, \"c\" => -4))\n    true\n  \
    \  >>> check_positive_int(Dict(\"a\" => 2, \"b\" => 3, \"c\" => -3, \"d\" => -4))\n\
    \    false\n    >>> check_positive_int(Dict(\"a\" => 2, \"b\" => 3))\n    false\n\
    \    \"\"\"", "    for key in dict\n        @assert(check_dict_case_element(key,\
    \ dict))\n    end\n    true\nend", "    \n    not_empty!(dict)", "  !check_empty(dict)\n\
    \  \n  if !check_empty(dict)\n    return all(map(x -> islower(x) || isupper(x),\
    \ dict))\n  end", "    if dict.size == 0\n        false\n    else\n        true\n\
    \    end\nend", "    if Dict{String,String}(undef,undef) == dict then return true\
    \ else return false end\n    true\nend\n</cell>\n<text>\nExercise 5\nWrite a function\
    \ that returns true if the given dictionary has all values greater than 10.",
  "    false\nend", "    return all(map(x -> (typeof(x) == String) && (x \u2208 dict),\
    \ keys(dict)))\nend", "    all((key in string.ascii_lowercase) | \n        (key\
    \ in string.ascii_uppercase) | \n        (not key))\nend\n</cell>\n<text>\nExercise\
    \ 3\nWrite a boolean function called has_values(dict::Dict{String, Bool}), which\
    \ should return true if all values in dictionary are true, false otherwise. For\
    \ example, if a dictionary is {a => true, b => false}, has_values(dict) should\
    \ return true. If dictionary is {a => true, b => false}, has_values(dict) should\
    \ return false. \nThe function should return false if the given dictionary is\
    \ empty.\nExamples:\n>>> has_values(Dict(a => true, b => true))\ntrue\n>>> has_values(Dict(a\
    \ => true, b => false))\nfalse\n>>> has_values(Dict())\nfalse\n\"\"\"", "    for\
    \ k in keys(dict)\n        if islower(k)\n            false\n        else\n  \
    \          true\n        end\n    end\nend", "    for k in keys(dict)\n      \
    \  if isupper(k)\n            true\n        elseif islower(k)\n            true\n\
    \        else\n            false\n        end\n    end\nend", "    return all([check_string(i)\
    \ for i in dict]) || all([check_string(I) for i in dict]) || all([check_dict_case(dict[i]\
    \ for i in key) for key in dict])\nend", "    for k in keys(dict)\n        if\
    \ k == lower(k) || k == upper(k)\n            return false\n    end\n    return\
    \ true\nend", "    \n    # initialize boolean\n    bool = false\n    # check each\
    \ key in dictionary\n    for key in keys(dict)\n        # convert key to lower\
    \ case\n        dict_key = String.lower(key)\n        # convert value to lower\
    \ case\n        dict_value = String.lower(get(dict, key))\n        # check if\
    \ value is equal\n        if dict_key != dict_value\n            bool = true\n\
    \            break\n        end\n    end\n    \n    return bool\nend", "    dict\
    \ = Dict(dict)\n    return false if len(dict) == 0 else \n        all((key?(el)\
    \ for el in dict) == \n            all(key?(el) for el in tolower(dict)))", " \
    \   for i in keys(dict)\n        if isupper(i) || islower(i)\n            return\
    \ true\n        end\n    end\n    return false\nend\n</cell>\n<code language=julia-1.0>",
  "    if !is_empty(dict)\n        for key in keys(dict)\n            if !is_string(key)\
    \ || !is_string(get(dict, key))\n                return false\n        end\n \
    \       return true\n    end\n    return false\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\n    Given a list of dictionaries, check each dictionary in a list against\
    \ \n    each other dictionary in the list to see if all keys are the same \n \
    \   in all dictionaries within the list. The function should return false \n \
    \   if the lists are of different lengths.\n    Examples:\n    >>> check_dict_list_case([Dict(\"\
    a\" => \"apple\", \"b\" => \"banana\"), \n                             Dict(\"\
    a\" => \"apple\", \"c\" => \"cherry\", \"d\" => \"durian\")])\n    true\n    >>>\
    \ check_dict_list_case([Dict(\"a\" => \"apple\", \"b\" => \"banana\"), \n    \
    \                         Dict(\"a\" => \"apple\", \"c\" => \"cherry\", \"d\"\
    \ => \"durian\")])\n    false\n    >>> check_dict_list_case([Dict(\"a\" => \"\
    apple\", \"b\" => \"banana\"), \n                             Dict(\"a\" => \"\
    apple\", \"c\" => \"cherry\", \"d\" => \"durian\"),\n                        \
    \     Dict(\"e\" => \"eel\", \"f\" => \"fig\")])\n    false\n    >>> check_dict_list_case([Dict(\"\
    a\" => \"apple\", \"b\" => \"banana\"), \n                             Dict(\"\
    a\" => \"apple\", \"c\" => \"cherry\", \"d\" => \"durian\"),\n               \
    \              Dict(\"e\" => \"eel\", \"f\" => \"fig\")])\n    true\n    \"\"\"",
  "    return false if dict.empty\n    for (k,v) in dict\n        return (k == :name\
    \ or k == :state) ? true : check_dict_case(Dict(k => v))\n    end\n    return\
    \ true\nend\n</cell>\n<code language=julia-1.6>\n\"\"\"\nGiven a string, return\
    \ true if all characters are alphabetic,\nelse return false.\nThe function should\
    \ return false if the string contains any non-alphabetic\ncharacters.\nExamples:\n\
    >>> check_string(\"apple\")\ntrue\n>>> check_string(\"banana\")\nfalse\n>>> check_string(\"\
    a$&\")\ntrue\n\"\"\"", "    if keys(dict) == {}\n        return true\n    elseif\
    \ keys(dict) == map(x => x.lowercase(), keys(dict))\n        return false\n  \
    \  else\n        error(\"Dictionary contains keys that are not strings\")\n  \
    \  end\nend\n</cell>\n<text>\nExercise 8\nIn the function below, implement a function\
    \ that takes a string as a parameter and returns the number of times the string\
    \ occurs in a given string.", "    \n    for (k,v) in dict do \n        if type(k)\
    \ == String \n            return true\n        elseif type(k) == Int64 \n    \
    \        return true\n        end\n    end\n    return false\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    \n    for value in dict.values()\n        @assert\
    \ typeof(value) == String \"dictionary values must be strings\"\n    end\n   \
    \ \n    if !isEmpty(dict)\n        for value in keys(dict)\n            @assert\
    \ islower(value) || isupper(value) \"dictionary keys must be lower or upper case\"\
    \n        end\n    end\n    \n    true\nend\n</cell>\n<text>\nExercise #5: Validate\
    \ an Email Address\nWrite a function that validates an email address. If the email\
    \ address is not valid (it contains non-letters, non-numbers, and non-@, non-.,\
    \ non-+, or  symbols, for example), return false; otherwise return true.\nExamples:\n\
    >>> check_email(\"removed@example.com\")\ntrue\n>>> check_email(\"removed@example.com\"\
    )\ntrue\n>>> check_email(\"removed@example.com\")\nfalse\n>>> check_email(\"removed@example.com\"\
    )\nfalse\n>>> check_email(\"\")\nfalse\n\"\"\"", "  check_bool(dict.keys) == check_bool(dict.values)\
    \ \nend", "    return all(is_string(key) || is_string(key) for key in dict)\n\
    end", "    if !length(dict) \n        error(\"Given dictionary is empty.\") \n\
    \    else \n        for (key, value) in dict do \n            if islower(key)\
    \ || isupper(key) \n                return true\n            end\n        end\n\
    \        return false\n    end\nend\n</cell>\n<code language=julia-1.5>\n## check_dict_case(Dict(\"\
    Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"))\n</cell>\n<text>\n\
    Problem 3a\nGiven a boolean array and a target, return a new boolean array consisting\
    \ of True values in the array that corresponds to True values larger than the\
    \ target.", "    true\n    for k in keys(dict)\n        if k !~ /^[A-Z]+$/\n \
    \           return false\n        \n    end\n    return true\nend\n</cell>\n<code\
    \ language=julia-0.5>\n# Run test\ncheck_dict_case(Dict(\"a\" => \"apple\", \"\
    b\" => \"banana\"))\ncheck_dict_case(Dict(\"a\" => \"apple\", \"A\" => \"banana\"\
    , \"B\" => \"banana\"))\ncheck_dict_case(Dict(\"a\" => \"apple\", 8 => \"banana\"\
    , \"a\" => \"apple\"))\ncheck_dict_case(Dict(\"Name\" => \"John\", \"Age\" =>\
    \ \"36\", \"City\" => \"Houston\"))\ncheck_dict_case(Dict(\"STATE\" => \"NC\"\
    , \"ZIP\" => \"12345\"))\n</cell>\n<text>\nExercise 3\nWrite a function that takes\
    \ a string and returns true if its length is 3 or larger and false otherwise.\
    \ Test the function with the following examples:\n\"Hello World\" => true\n\"\
    Hi there\" => false\n\"Hi\" => false\n\"Hello World\" => false\n\"Hi\" => true\n\
    \"Hi\" => true\n\"Hi\" => true\n\"Hi\" => true\n\"Hi\" => true\n\"Hi\" => true\n\
    \"Hi\" => true\n\"Hi\" => true\n\"Hi\" => true\n\"Hi\" => true\n\"Hi\" => true\n\
    \"Hi\" => true\n\"Hi\" => true\n\"Hi\" => true\n\"Hi\" => true\n\"Hi\" => true\n\
    \"Hi\" => true\n\"Hi\" => true\n\"Hi\" => true\n\"Hi\" => true\n\"Hi\" => true\n\
    \"Hi\" => true\n\"Hi\" => true\n\"Hi\" => true\n\"Hi\" => true\n\"Hi\" => true\n\
    \"Hi\" => true\n\"Hi\" => true\n\"Hi\" => true\n\"Hi\" => true\n\"Hi\" => true\n\
    \"Hi\" => true\n\"Hi\" => true\n\"Hi\" => true\n\"Hi\" => true\n\"Hi\" => true\n\
    \"Hi\" => true\n\"Hi\" => true\n\"Hi\" => true\n\"Hi\" => true\n\"Hi\" => true\n\
    \"Hi\" => true\n\"Hi\" => true\n\"Hi\" => true\n\"Hi\" => true\n\"Hi\" => true\n\
    \"Hi\" => true\n\"Hi\" => true\n\"Hi\" => true\n\"Hi\" => true\n\"Hi", "    return\
    \ !isempty(keys(dict)) && all(map(x -> String(x) == String(x), keys(dict)))\n\
    end\n</cell>\n<text>\n3.2.2 check_dict_value\nImplement a function check_dict_value.\
    \ This function should take in \n    a dictionary and returns true if all the\
    \ values are numeric, or \n    false otherwise.\n    Examples:\n    >>> check_dict_value(Dict(\"\
    a\" => \"apple\", \"b\" => \"banana\", \"c\" => \"carrot\"))\n    false\n    >>>\
    \ check_dict_value(Dict(\"a\" => \"apple\", \"b\" => \"banana\", \"c\" => 33))\n\
    \    false\n    >>> check_dict_value(Dict(\"a\" => \"apple\", \"b\" => \"banana\"\
    , \"c\" => 33, \"d\" => 9))\n    true\n    \"\"\"", "    l = length(dict)\n  \
    \  for i in keys(dict) do \n        if isupper(i) == False && islower(i) == False\
    \ return false end\n    end\n    return true\nend", "    # Write your logic here\n\
    \    return true\nend\n</cell>\n<text>\nC. Counting Functions\nNext, we will count\
    \ the total number of each element in the list.", "    return (Dict{String, String}(dict)\
    \ == dict)\nend", "    return all(map.has_key?(k) where k in map.keys() for k\
    \ in keys)\nend\n</code>\n<|/ a tags=julia |>\n<| a tags=julia |>\nHere's a one-liner\
    \ that should work:\n<code>\njulia> Dict(k=>v for (k,v) in pairs(Dict(\"a\" =>\
    \ \"apple\", \"b\" => \"banana\")) if k \u2209 keys(lowercase(Dict(\"a\" => \"\
    apple\", \"b\" => \"banana\"))) and k \u2209 keys(uppercase(Dict(\"a\" => \"apple\"\
    , \"b\" => \"banana\")))\nDict{String,String} with 2 entries:\n  \"a\" => \"apple\"\
    \n  \"b\" => \"banana\"\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like the one-liner\
    \ ;-)\n<|/ c |>\n<| a dscore=2 |>\nHere's a one-liner that seems to do what you\
    \ want:\n<code>\njulia> Dict(k=>v for (k,v) in pairs(Dict(\"a\" => \"apple\",\
    \ \"b\" => \"banana\")) \n           if k \u2209 keys(lowercase(Dict(\"a\" =>\
    \ \"apple\", \"b\" => \"banana\"))) \n           and k \u2209 keys(uppercase(Dict(\"\
    a\" => \"apple\", \"b\" => \"banana\"))))\nDict{String,String} with 2 entries:\n\
    \  \"a\" => \"apple\"\n  \"b\" => \"banana\"\n</code>\n<|/ a tags=julia |>\n<|\
    \ a |>\nThis seems to work fine for me:\n<code>\njulia> Dict(\"a\" => \"apple\"\
    , \"b\" => \"banana\")\nDict{String, String} with 2 entries:\n  \"a\" => \"apple\"\
    \n  \"b\" => \"banana\""]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
