name: HumanEval_34_unique
language: jl
prompt: "\"\"\"Return sorted unique elements in a vector\n    >>> unique([5, 3, 5,\
  \ 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\nfunction unique(l::Vector{Int64})::Vector{Int64}\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = unique;\n\t@test(candidate([5,\
  \ 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123])\nend\n"
completions: ["    \n    if len(l) == 0  \n        throw(DomainError())\n    end\n\
    \    \n    seen = Set()\n    \n    push!(seen, l[1])\n    \n    for i in 2:length(l)\n\
    \        if l[i] \u2209 seen\n            push!(seen, l[i])\n        end\n   \
    \ end\n    return seen\nend", "    unique_elems= setdiff(l, l[])\n    l\nend",
  "    idx = Dict()\n    idx[1] = 1\n    for v in l\n        idx[v] = idx[v] + 1\n\
    \    end\n    return l\nend", "    sort!(l)\n    u = Vector{Int64}(length(l)-1)\n\
    \    for i=1:length(l)-1\n        u[i] = l[i] \n    end\n    unique!(u)\nend\n\
    </code>\n<|/ a |>\n<| c |>\nI agree, a bit cleaner: `unique(unique(s))`\n<|/ c\
    \ |>\n<| c |>\nNote that this will remove duplicates\n<|/ c |>\n<| a dscore=4\
    \ |>\nBuilding on jonas' answer, this one actually sorts the unique elements and\
    \ also outputs them in a sorted order.\n<code>", "    \"\"\"Return a vector containing\
    \ sorted unique elements of a vector\"\"\"\nend\n</cell>\n<code language=julia-0.6>",
  "        \n    \n    unique = Array{Any}(length(l))\n    \n    unique[sortperm(l)]\
    \ \nend #end function unique\nend #end module C\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThanks for the answer! I edited my question to add my version of `unique`\
    \ based on this one. Unfortunately, it throws an error. I'll edit it again to\
    \ include it here.\n<|/ c |>\n<| c |>\nYou don't need to use an anonymous function\
    \ when defining your `unique` function; `unique = Array{Any}(length(l))` should\
    \ be sufficient.\n<|/ c |>\n<| c |>\nI'm getting an error: `julia> unique(arr::Vector{Int64})\n\
    ERROR: syntax: unexpected \"=\"`\n<|/ c |>\n<| c |>\nYeah, sorry, I missed a colon.\
    \ I've edited it again and added your version.\n<|/ c |>\n<| c |>\n`unique` seems\
    \ to work for me. I tried it with a smaller sample of 10 and it seemed to work.\
    \ I'll edit the question again to include a larger sample.\n<|/ c |>\n<| a tags=julia\
    \ |>\nHere's a variant of the solution by that doesn't require copying or allocating\
    \ a new array.\n<code>", "    res = Array(Int, length(unique(l)))\n    i, j =\
    \ 0, 0\n    while j < length(unique(l))\n        res[i] = unique(l[j])\n     \
    \   i += 1\n        j += 1\n    end\n    return res\nend", "    # sort\n    #\
    \ unique\n    v = copy(l)\n    sort!(v)\n    # remove\n    remove!(v, v)\n   \
    \ return v\nend\n</cell>\n<code language=julia-1.0>\nunique(vec(nums))\n</cell>\n\
    <text>\nFind index of maximum element in array", "    if length(l)<2 return l\n\
    \    v = Vector{Int64}()\n    push!(v,l[1])\n    last=l[1]\n    for x in l[2:end]\n\
    \        if x!=last\n            last=x\n            push!(v,last)\n        end\n\
    \    end\n    v\nend\n</cell>\n<text>\nJulia has several built-in functions that\
    \ operate on sequences (and arrays). One of the most useful ones is length, which\
    \ returns the length of a sequence in elements:", "    @assert length(unique(l))\
    \ > 0 \"Vector must not be empty\"\n    local unique_map = SortedSet{Int64}()\n\
    \    for val in l\n        @assert !contains(unique_map, val) \"Duplicate values\
    \ not allowed in vector\"\n        insert(unique_map, val)\n    end\n    return\
    \ unique_map\nend\n</code>\n<|/ a dscore=3 tags=julia,set,unique |>\n<| a |>\n\
    In Julia 0.6 one can use the Union function from Base. The resulting type depends\
    \ on the types of the input arguments and this can be quite cumbersome in some\
    \ situations, e.g. if the types do not match (i.e. if all elements of an input\
    \ vector should be considered distinct, some sort of Union result type should\
    \ be returned). In such a case I would recommend using a package like Sets.jl\
    \ (also available on GitHub or through Pkg.add)\n<code>\njulia> using Sets", " \
    \   local uniques = Set()\n    for item in l\n        uniques.add(item)\n    end\n\
    \    return uniques\nend", "    \n    v = Int64[]\n    for i in l \n        if\
    \ !contains(v,i) \n            push!(v,i) \n        end \n    end\n    \n    return\
    \ v \nend \nunique(l::Vector{Float64}) = unique([sort(Float64(i)) for i in l]) ",
  "    l=[i for i in l if !ismissing(i)]\n    sort(l)\n    l\nend\nunique(l::Vector{T})::Vector{T}\
    \ where T <: Number=unique([i for i in l if isa(itype, T)])\nunique(l::Vector{T})::Vector{T}\
    \ where T <: Number=unique([i for i in l if isa(itype, T)])\nunique(l::Vector{T})::Vector{T}\
    \ where T <: Number=unique([i for i in l if isa(itype, T)])\nunique(l::Vector{T})::Vector{T}\
    \ where T <: Number=unique([i for i in l if isa(itype, T)])\nunique(l::Vector{T})::Vector{T}\
    \ where T <: Number=unique([i for i in l if isa(itype, T)])\nunique(l::Vector{T})::Vector{T}\
    \ where T <: Number=unique([i for i in l if isa(itype, T)])\nunique(l::Vector{T})::Vector{T}\
    \ where T <: Number=unique([i for i in l if isa(itype, T)])\nunique(l::Vector{T})::Vector{T}\
    \ where T <: Number=unique([i for i in l if isa(itype, T)])\nunique(l::Vector{T})::Vector{T}\
    \ where T <: Number=unique([i for i in l if isa(itype, T)])\nunique(l::Vector{T})::Vector{T}\
    \ where T <: Number=unique([i for i in l if isa(itype, T)])\nunique(l::Vector{T})::Vector{T}\
    \ where T <: Number=unique([i for i in l if isa(itype, T)])\nunique(l::Vector{T})::Vector{T}\
    \ where T <: Number=unique([i for i in l if isa(itype, T)])\nunique(l::Vector{T})::Vector{T}\
    \ where T <: Number=unique([i for i in l if isa(itype, T)])\nunique(l::Vector{T})::Vector{T}\
    \ where T <: Number=unique([i for i in l if isa(itype, T)])\nunique(l::Vector{T})::Vector{T}\
    \ where T <: Number=unique([i for i in l if isa(itype, T)])\nunique(l::Vector{T})::Vector{T}\
    \ where T <: Number=unique([i for i in l if isa(itype, ", "    n=length(l)\n \
    \   uniq=Vector{Int64}(n)\n    ind=Vector{Int64}(n)\n    for i=1:n\n        if\
    \ l[ind[i]]==0\n            uniq[ind[i]]=l[i]\n            ind[i]=i\n        end\n\
    \    end\n    return uniq\nend\n    ", "    return sort(uniques(l))\nend\n\"\"\
    \"\nReturn the unique elements in a vector\n\"\"\"", "    if length(l) == 0\n\
    \        return []\n    seen = Set{Int64}()\n    uniques = Set{Int64}()\n    for\
    \ i in l\n        if i \u2209 seen \u222A uniques\n            push!(seen, i)\n\
    \            push!(uniques, i)\n        end\n    end\n    uniques\nend\n</code>\n\
    <|/ a tags=set,julia |>\n<| a dscore=2 |>\nThe answer by Steven Majewski is great\
    \ if you need unique numbers in an array. It might be slightly more efficient\
    \ to preallocate the output vector, though, for large arrays. An approach that\
    \ keeps all the numbers in an array and uses the built-in setdiff! function:\n\
    <code>", "    @assert length(l) == length(unique(sort(l)))\n    # this works because\
    \ unique already sorts \n    uniqueList = unique(sort(l))\n    # reconstruct original\
    \ order\n    return uniqueList[end]\nend\n</code>\n<|/ a dscore=5 tags=julia,unique,arrays\
    \ |>\n<| c |>\nThis works well for me (I'm sorting a DataFrame in Julia 0.6.0).\
    \ However, I am a bit uncomfortable with this as I always try to avoid macros\
    \ in Julia when I can, so I would like to know if there is an alternative solution.\n\
    <|/ c |>\n<| c |>\nThe macro `@unique` has a few drawbacks compared to your solution.\
    \ The first being that the code is not type-stable, and is prone to breaking if\
    \ you change a type from Int64 to Float64. Also, it is quite verbose and slow.\
    \ Here is an alternative without macros, using only builtins: `unique(x) -> sort(unique(x))\
    \ |> last`.\n<|/ c |>\n<| c |>\nFor me the main drawback of the `@unique` macro\
    \ is that it relies on `sort`ing first, so this can be quite inefficient in case\
    \ of large `Vector`s.\n<|/ c |>\n<| a |>\nFor an ordered array, you can use unique.\n\
    <code>\njulia> a = [1,5,5,5,4,3,2,7,8,8];", "    return sort(unique(sort(l)))\n\
    end\n</cell>\n<code language=julia-1.0>\n# Example\nunique([5, 3, 5, 2, 3, 3,\
    \ 9, 0, 123])\n</cell>\n<code language=julia-1.0>\n# Return unique elements as\
    \ a new vector of the same type", "    l=unique!(l)\n    return l\nend\nunique!(l::Vector{Int64})::Vector{Int64}=sort(l)",
  "    unique(setdiff(l, Int64[]))\nend\nunique(l)", "    return sort(unique.(unique.(l)))\n\
    end\nunique.(l)", "    res = l\n    for v in l\n        if !ismember(v, res)\n\
    \            push!(res, v)\n        end\n    end\n    return res\nend\n\"\"\"\n\
    \ unique(l::Vector{UInt8})::Vector{UInt8}\n unique(l::Vector{UInt16})::Vector{UInt16}\n\
    \ unique(l::Vector{UInt32})::Vector{UInt32}\n unique(l::Vector{UInt64})::Vector{UInt64}\n\
    \ unique(l::Vector{Int8})::Vector{Int8}\n unique(l::Vector{Int16})::Vector{Int16}\n\
    \ unique(l::Vector{Int32})::Vector{Int32}\n unique(l::Vector{Int64})::Vector{Int64}\n\
    \ unique(l::Vector{Float32})::Vector{Float32}\n unique(l::Vector{Float64})::Vector{Float64}\n\
    \ unique(l::Vector{Bool})::Vector{Bool}\n unique(l::Vector{ComplexF64})::Vector{ComplexF64}\n\
    \ unique(l::Vector{ComplexF32})::Vector{ComplexF32}\n unique(l::Vector{UInt8})::Vector{UInt8}\n\
    \ unique(l::Vector{UInt16})::Vector{UInt16}\n unique(l::Vector{UInt32})::Vector{UInt32}\n\
    \ unique(l::Vector{UInt64})::Vector{UInt64}\n unique(l::Vector{Int8})::Vector{Int8}\n\
    \ unique(l::Vector{Int16})::Vector{Int16}\n unique(l::Vector{Int32})::Vector{Int32}\n\
    \ unique(l::Vector{Int64})::Vector{Int64}\n unique(l::Vector{Float32})::Vector{Float32}\n\
    \ unique(l::Vector{Float64})::Vector{Float64}\n unique(l::Vector{Bool})::Vector{Bool}\n\
    \ unique(l::Vector{ComplexF64})::Vector{ComplexF64}\n unique(l::Vector{ComplexF32})::Vector{ComplexF32}\n\
    \ unique(l::Vector{String})::Vector{String}\n unique(l::Vector{Any})::Vector{Any}\n\
    \ unique(l::Vector{AnyVal", "    unique = Set()\n    unique = [x for (x , _) in\
    \ sortperm(l, 1)]\n    return unique\nend\n</code>\n<|/ a dscore=2 tags=julia,vector\
    \ |>\n<| c |>\nThanks for reminding me that Julia has these functions. I guess\
    \ I can use this if I ever have to use one of these again :) I was thinking of\
    \ using filter to do this, but since I already had a vector of sorted values (which\
    \ I needed to use to order them in the right order), this seemed more complicated\
    \ than necessary.\n<|/ c |>\n<| c |>\nI agree that this answer is probably as\
    \ good as it gets. However, it is very verbose. Especially since you haven't mentioned\
    \ any performance optimizations for your specific situation. My solutions don't\
    \ use any `map`, which means that the code is probably a little faster than yours.\
    \ But again, I don't know if it will be the bottleneck in your case.\n<|/ c |>\n\
    <| c |>\nI completely agree that this answer is probably as good as it gets. However,\
    \ it is very verbose. Especially since you haven't mentioned any performance optimizations\
    \ for your specific situation. My solutions don't use any `map`, which means that\
    \ the code is probably a little faster than yours. But again, I don't know if\
    \ it will be the bottleneck in your case.\n<|/ c |>\n<| c |>\nI'm very glad to\
    \ see that my answer still helps someone! Your comment about performance being\
    \ a concern seems reasonable, so I'm glad you brought it up.\n<|/ c |>\n<| a tags=julia,vector\
    \ |>\nI would use unique like this:\n<code>\njulia> unique(vec)\n10-element Array{Int64,1}:\n\
    \ 0\n 2\n 4\n 5\n 7\n 8\n 10\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis also removes\
    \ duplicated values.\n<|/ c |>\n<| c |>\nThanks for your response. The reason\
    \ I wanted a vector is that I want to then use that vector to order another vector\
    \ (which is a function of another vector). I'm basically trying to get the order\
    \ of the elements in vec to match the order of the elements in another vector\
    \ (which is also a function of another vector).\n<|/ c |>\n<| c |>\nThat is exactly\
    \ what `unique` does, it orders elements according to the unique values in the\
    \ original vector. If the second vector is also a function of the first vector,\
    \ why do you need a vector?\n<|/ c |>\n<| c |>\nSorry, I edited my original post\
    \ to be more clear. I want to order my original ", "    \n    # sort list\n  \
    \  l = sort!(l)\n    \n    # remove duplicates\n    l = l[!isdupe(l)];\n    \n\
    \    # return unique values\n    return l\nend", "    # return sorted unique elements\
    \ in a vector\n    \n    seen = Set()\n    for i in l\n        if !haskey(seen,\
    \ i) \n            push!(seen, i)\n        else\n            remove!(seen, i)\n\
    \        end\n    end\n    return seen\nend\n</cell>\n<code language=julia-1.5>",
  "    \"\"\"Return a sorted unique set of numbers in a vector\n    >>> unique([5,\
    \ 3, 5, 2, 3, 3, 9, 0, 123])\n    [2, 3, 5, 9, 0, 123]\n    \"\"\"", "    unique={}\n\
    \    for x in l\n        if x not in unique\n            unique[x]=true\n    \
    \    else\n            unique[x]=false\n        end\n    end\n    return sort(unique)\n\
    end\n</cell>\n<text>\n$5$ \uD68C\uC218 $\\rightarrow$ \uC774\uBBF8 \uC5EC\uB7EC\
    \ \uCD9C\uD604\uC73C\uB85C \uC0B4\uD3B4\uBCF4\uBA74 $\\text{unique}(\\text{rand}(100))$\
    \ \uAC00 \uB9DE\uB2E4.", "    l = sort(l)\n    l\nend\nunique()", "    \n    if\
    \ length(l) == 0 \n        return l\n    \n    unique_array = []\n    \n    for\
    \ v in l \n        if !contains(unique_array, v) \n            unique_array =\
    \ [v] + unique_array\n        else \n            unique_array = unique_array .+\
    \ [v]\n    end\n    \n    return unique_array\nend\n\"\"\"Return sorted unique\
    \ elements in a vector\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0,\
    \ 2, 3, 5, 9, 123]\n    \"\"\"", "     @inbounds a = [i for i in l if l[i] !=\
    \ i]\n     a\nend\n</cell>\n<text>\nA simple test shows how this function works:",
  "    #return sort(l)\n    uniques = Set()\n    uniques.union!(l)\n    return uniques\n\
    end\n</code>\n<|/ a dscore=3 tags=julia,performance |>\n<| c |>\nThis looks quite\
    \ slow for my use case. I have a vector with about 1 million elements and I want\
    \ to find unique elements from this vector with speed in mind. Can you explain\
    \ why you take your last line out and replace it with `uniques = Set()`?\n<|/\
    \ c |>\n<| c |>\nThe line `uniques.union!(l)` is basically a `@inbounds uniques\
    \ = uniques.union!(l)`. In your example `uniques` is already a set so you could\
    \ also do `@inbounds uniques = unique(uniques.union!(l))` but you avoid a race\
    \ condition with the `@parallel` block. You might also want to do some benchmarking\
    \ (I guess it's really slow, since your example size is small).\n<|/ c |>\n<|\
    \ c |>\nYes, I actually benchmarked your code. It took about 3 seconds to complete\
    \ when it was just `unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(",
  "    seen = Set()\n    l = copy(l)\n    for elt in l \n        if !in(elt, seen)\n\
    \            seen += elt\n            l =  l .- elt \n        end\n    end\n \
    \   return l\nend\n</cell>\n<code language=julia-0.6>\n# function unique(l::Vector{Int64})::Vector{Int64}\n\
    #     seen = Set()\n#     l = copy(l)\n#     for elt in l\n#         if !in(elt,\
    \ seen)\n#             seen = seen.union([elt])\n#             l =  l .- elt\n\
    #         end\n#     end\n#     return l\n# end\n</cell>\n<code language=julia-0.6>\n\
    # function unique(l::Vector{Int64})::Vector{Int64}\n#     seen = Set()\n#    \
    \ l = copy(l)\n#     for elt in l\n#         if !in(elt, seen)\n#            \
    \ seen += elt\n#             l =  l .- elt \n#         end\n#     end\n#     return\
    \ l\n# end\n</cell>\n<code language=julia-0.6>\n# function unique(l::Vector{Int64})::Vector{Int64}\n\
    #     seen = Set()\n#     l = copy(l)\n#     for elt in l\n#         if !in(elt,\
    \ seen)\n#             seen += elt\n#             l =  l .- elt \n#         end\n\
    #     end\n#     return l\n# end\n</cell>\n<code language=julia-0.6>\n# function\
    \ unique(l::Vector{Int64})::Vector{Int64}\n#     seen = Set()\n#     l = copy(l)\n\
    #     for elt in l\n#         if !in(elt, seen)\n#             seen += elt\n#\
    \             l =  l .- elt \n#         end\n#     end\n#     return l\n# end\n\
    </cell>\n<code language=julia-0.6>", "    if l == []\n        l = [0]\n    end\n\
    \    l = union(sort(l), l) \n    unique = Vector{Int64}(undef, 0)\n    for element\
    \ in l\n        if !in(element, unique)\n            unique = unique + [element]\n\
    \        end\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.0>\n\
    unique([5, 3, 5, 2, 3, 3, 9, 0, 123]);\n</cell>\n<text>\nunique! Example", " \
    \ result=copy(l)\n  sort!(result)\n  unique(result)\nend\n</code>\nThis implementation\
    \ is more efficient than a version that sorts the entire vector.  It should be\
    \ obvious that it requires more memory, but it's usually not that expensive to\
    \ allocate as it is to sort, and often faster to copy than to sort.\n<|/ a tags=julia\
    \ |>\n<| c |>\nThis should be the accepted answer - it is more efficient than\
    \ `unique(sort(l))`\n<|/ c |>\n<| a tags=julia |>\nIf you don't need to preserve\
    \ ordering (you don't) you can do:\n<code>\nunique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    </code>\nwhich will give you [0, 2, 5, 9, 123]\nIf you do need to preserve ordering,\
    \ you can use sort\n<code>\njulia> sort!([5, 3, 5, 2, 3, 3, 9, 0, 123])\njulia>\
    \ sort!([5, 3, 5, 2, 3, 3, 9, 0, 123])\njulia> sort!([5, 3, 5, 2, 3, 3, 9, 0,\
    \ 123])\njulia> sort!([5, 3, 5, 2, 3, 3, 9, 0, 123])\njulia> sort!([5, 3, 5, 2,\
    \ 3, 3, 9, 0, 123])\njulia> sort!([5, 3, 5, 2, 3, 3, 9, 0, 123])\njulia> sort!([5,\
    \ 3, 5, 2, 3, 3, 9, 0, 123])\njulia> sort!([5, 3, 5, 2, 3, 3, 9, 0, 123])\njulia>\
    \ sort!([5, 3, 5, 2, 3, 3, 9, 0, 123])\njulia> sort!([5, 3, 5, 2, 3, 3, 9, 0,\
    \ 123])\njulia> sort!([5, 3, 5, 2, 3, 3, 9, 0, 123])\njulia> sort!([5, 3, 5, 2,\
    \ 3, 3, 9, 0, 123])\njulia> sort!([5, 3, 5, 2, 3, 3, 9, 0, 123])\njulia> sort!([5,\
    \ 3, 5, 2, 3, 3, 9, 0, 123])\njulia> sort!([5, 3, 5, 2, 3, 3, 9, 0, 123])\njulia>\
    \ sort!([5, 3, 5, 2, 3, 3, 9, 0, 123])\njulia> sort!([5, 3, 5, 2, 3, 3, 9, 0,\
    \ 123])\njulia> sort!([5, 3, 5, 2, 3, 3, 9, 0, 123])\njulia> sort!([5, 3, 5, 2,\
    \ 3, 3, 9, 0, 123])\njulia> sort!([5, 3, 5, 2, 3, 3, 9, 0, 123])\njulia> sort!([5,\
    \ 3, 5, 2, 3, 3, 9, 0, 123])\njulia> sort!([5, 3, 5, 2, 3, 3, 9, 0, 123])\njulia>\
    \ sort!([5, 3, 5, 2, 3, 3, 9, 0, 123])\njulia> sort!([5, 3, 5, 2, 3, 3, ", " \
    \   inds = Vector{Int64}(length(l)+1)\n    inds[0] = 1\n    inds[1] = 1\n    for\
    \ i in 2:length(l)\n        if inds[i] != inds[i-1]+1\n            inds[i] = inds[i-1]+1\n\
    \        else\n            inds[i] = inds[i-1]+1\n        end\n    end\n    return\
    \ l[inds[1:end-1]]\nend\n</cell>\n<code language=julia-1.5>\nunique(1:10)\n</cell>\n\
    <text>\nJulia has a set data structure that can store an unordered collection\
    \ of unique elements.  It is called Set{T}.  The syntax for a set is Set{T}([Ts...]).\
    \  For example,", "    if length(l) == 0 then \n        Vector{Int64}() \n   \
    \ else \n        return sort(unique(sort(l)))\n    end\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThis has already been answered many times over, and this answer is no\
    \ different than others I have seen. Why post it? What is wrong with it? It is\
    \ a good answer.\n<|/ c |>\n<| c |>\nHa! I didn't know that there was a canonical\
    \ duplicate. Thank you for pointing that out. Will you add it or shall I?\n<|/\
    \ c |>\n<| c |>\nNo need to! I'll add a link just incase.\n<|/ c |>\n<| c |>\n\
    I see you deleted it, but here it is.\n<|/ c |>\n<| c |>\n: Thank you for the\
    \ edit. Feel free to revert if that's not okay\n<|/ c |>\n<| a dscore=3 |>\n<code>\n\
    julia> a = [1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5]\n10-element Array{Int64,1}:\n\
    \ 1\n 5\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n\
    \ 1\n 1", "    for x in unique(l)\n        push!(l, x)\n    end\n    return l\n\
    end", "    seen = Set{Int64}()\n    \n    for (i, elem) in enumerate(l)\n    \
    \    if !seen[elem]\n            seen[elem] = true\n            return elem ::\
    \ seen\n        end\n    end\n    return l\nend\n</code>\n<|/ a tags=julia |>\n\
    <| c |>\nThis works for `unique` but does not work for `sorted`. For example,\
    \ `@unique [5, 3, 5, 2, 3, 3, 9, 0, 123]` returns `[0,2,3,9,123]`\n<|/ c |>\n\
    <| c |>\n`@unique` and `@sorted` do the same thing: return unique elements of\
    \ a vector. `unique` returns sorted unique elements of a vector. `sorted` returns\
    \ unique elements of a vector sorted, but does not guarantee the original order\
    \ of the elements. This is why it sorts the input vector. That's why I used `@sorted`\
    \ for you. See the examples in their help pages.\n<|/ c |>\n<| c |>\n`@unique`\
    \ does not return the elements in the original order. It does not sort anything.\
    \ I guess you misunderstood me completely. If you want to sort the elements then\
    \ use `@sorted` instead of `@unique`.\n<|/ c |>\n<| c |>\nNo I mean to say that\
    \ the input vector is passed untouched - `@unique` and `@sorted` return the same\
    \ output. I do not think it is important to return it in the original order.\n\
    <|/ c |>\n<| c |>\nYes it is. If you want a sorted unique vector then you need\
    \ to sort it using `@sorted` - see my example.\n<|/ c |>\n<| a tags=julia |>\n\
    An alternative to unique, using the in-built Set{T} type. ", "    n = length(l);\n\
    \    uniqueVec = Vector{Int64}()\n    while n > 0\n        uniqueVec = append(uniqueVec,\
    \ l[n-1])\n        n -= 1\n    end\n    return uniqueVec\nend\nuniqueVec,uniqueIndices,invUniqueIndices\
    \ = unique(sort(v))\nv[v] .= uniqueIndices\nreturn uniqueVec", "  idx = sort(l)\n\
    \  if length(idx) == length(l)\n    return idx\n  else\n    return collect(idx[1:end-1])\n\
    \  end\nend\n</code>\n<|/ a tags=unique,sorting,julia |>\n<| a dscore=2 tags=unique,sorting,julia\
    \ |>\nJust to mention that you can use built-in function unique:\n<code>\njulia>\
    \ unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n0-element Array{Int64,1}\n</code>\nAnd\
    \ this also works with sequences:\n<code>\njulia> unique([3, 5, 3, 9, 0, 123])\n\
    3-element Array{Int64,1}:\n 3\n 9\n 123\n</code>\n<|/ a |>\n<| a dscore=0 |>\n\
    If you want it to be sorted (which you do if you use sort!) then you could use\
    \ sort! after the unique:\n<code>\njulia> sort!(unique([5, 3, 5, 2, 3, 3, 9, 0,\
    \ 123]))\n3-element Array{Int64,1}:\n 3\n 9\n 123\n</code>\nThis also works with\
    \ (say) Float64:\n<code>\njulia> sort!(unique([5.4, 5.9, 5.8, 5.6, 5.5, 5.3, 5.2,\
    \ 5.1, 5.0]))\n5-element Array{Float64,1}:\n 5.0\n 5.1\n 5.2\n 5.3\n 5.4\n 5.5\n\
    \ 5.6\n 5.8\n 5.9\n</code>\n<|/ a tags=unique,sorting,julia |>\n<| c |>\nActually\
    \ `sort!` returns nothing. `sort!` modifies the original array, and returns nothing.\n\
    <|/ c |>\n<| c |>\nThanks. I'll update my answer.\n<|/ c |>\n<| a dscore=0 tags=unique,sorting,julia\
    \ |>\nI came up with this one:\n<code>", "    \"\"\"Return sorted unique elements\
    \ in a vector\"\"\"\n    \n    push!(unique, Int64[])\n    push!(unique, l)\n\
    \    \n    \n    for u in unique[end-1] \n        while u < length(unique) \n\
    \            pop!(unique)\n            push!(unique, l)\n        end\n    end\n\
    \    unique\nend\n</cell>\n<text>\n2. Search for specific values", "    s = Set()\n\
    \    for i in l\n        if !contains(s, i)\n            push!(s, i)\n       \
    \ end\n    end\n    unique(collect(s))\nend\nunique(l)\nend\n</cell>\n<code language=julia-0.4>\n\
    @code_warntype unique(l)\n</cell>\n<text>\nNote that this function is only necessary\
    \ for speed or if you need to recreate the original vector. One common use case\
    \ is storing the unique values in a dictionary where the keys are the unique elements.\
    \ We do not need to return a new vector for this.", "    # Find unique elements,\
    \ return new vector\n    v = copy(l)\n    unique_idx = 1:length(v)\n    for i\
    \ in unique_idx\n        if v[i] == nil\n           v[i] = i\n        else\n \
    \          if i \u2209 unique_idx\n               unique_idx[unique_idx] = i\n\
    \           end\n        end\n    end\n    v = v[unique_idx]\n    return v\nend\n\
    </code>\nIt also uses this Julia package which implements a simple set data structure,\
    \ using a hash-table (which itself uses BSTs internally but you can also implement\
    \ it yourself if you want: https://github.com/JuliaCollections/Set.jl).\n<|/ a\
    \ dscore=5 tags=julia |>\n<| c |>\nJulia has an in-built set of data structure\
    \ called set: https://julialang.github.io/Base/set/\n<|/ c |>\n<| a |>\nFor a\
    \ vector, one could use:\n<code>\njulia> v = [5, 4, 1, 2, 3, 4]", "    seen =\
    \ {}\n    push!(seen, 0); append!(seen, 0); return seen\n    for i in l\n    \
    \    if !haskey(seen, i)\n            seen[i] = 1\n            push!(seen, i)\n\
    \        end\n    end\n    return seen\nend", "    @assert length(l) == length(uunique(sort(l)))\n\
    \    return uunique(sort(l))\nend", "    if length(l) == 0 \n        return l\n\
    \    \n    u = sort(unique(l))\n    return sort(union(l, u))\nend", "  return\
    \ sort(collect(l))\nend", "    v1 = Vector{Int64}(sort(l))\n    for a in v1 \n\
    \        if haskey(v1,a) == false \n            break\n        else \n       \
    \     remove!(v1,a)\n    end\n    v1\nend\n</code>\n<|/ a tags=julia |>\n<| c\
    \ |>\nThis doesn't work for `julia> unique(unique(unique(1:4))) \n5-element Vector{Int64}:\n\
    \ 3\n 4\n 5\n 6\n 7\n 8`\n<|/ c |>\n<| a dscore=1 |>\nI wanted to have a similar\
    \ function but was unable to find one. Based on the answers above, I created an\
    \ improved version that works for me:\n<code>", "    return sort(collect(l))\n\
    end", "    # use set to remove duplicates\n    set = Set()\n    for x in l \n\
    \        push!(set,x)\n    end\n    return sort(set)\nend", "    \"\"\"Return\
    \ sorted unique elements in a vector\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0,\
    \ 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"", "    l = sort(l)\n    unique(l)\n\
    end\nunique(a)", "    unique_indices = Vector{Int64}()\n    for i in 1:length(l)\
    \ \n        if !has(unique_indices, l[i]) \n            push!(unique_indices,\
    \ l[i]) \n        else \n            continue \n        end \n    end \n    return\
    \ unique_indices\nend ", "    sort(unique(l))\nend\n</cell>\n<code language=julia-1.6>\n\
    @assert unique([5, 4, 4, 3, 1, 5, 1]) == [5, 4, 3, 1, 5]\n@assert unique([5, 4,\
    \ 4, 3, 1, 5, 2]) == [5, 4, 4, 3, 1]\n@assert unique([5, 4, 4, 3, 1, 5, 3]) ==\
    \ [5, 4, 4, 3]\n@assert unique([5, 4, 4, 3, 1, 5, 4]) == [5, 4, 4]\n@assert unique([5,\
    \ 4, 4, 3, 1, 5, 5]) == [5, 4, 4]\n@assert unique([5, 4, 4, 3, 1, 5, 6]) == [5,\
    \ 4, 4, 3]\n@assert unique([5, 4, 4, 3, 1, 5, 7]) == [5, 4, 4, 3]\n@assert unique([5,\
    \ 4, 4, 3, 1, 5, 8]) == [5, 4, 4, 3, 1]\n@assert unique([5, 4, 4, 3, 1, 5, 9])\
    \ == [5, 4, 4, 3]\n@assert unique([5, 4, 4, 3, 1, 5, 10]) == [5, 4, 4, 3, 1]\n\
    @assert unique([5, 4, 4, 3, 1, 5, 11]) == [5, 4, 4, 3, 1]\n@assert unique([5,\
    \ 4, 4, 3, 1, 5, 12]) == [5, 4, 4, 3]\n</cell>\n<code language=julia-1.6>", " \
    \   uniques = Set{Int64}()\n    for x in l\n        if !haskey(uniques, x)\n \
    \           push!(uniques, x)\n        end\n    end\n    return unique(uniques)\n\
    end\n</code>\nThe function unique uses recursion to do all the work. You could\
    \ probably find a better way to sort a vector than just sorting and uniq'ing it\
    \ (perhaps by sorting it, then uniq'ing it). The original function was written\
    \ by someone else on SO, so credit where credit is due.\n<|/ a tags=vector,julia,sorting\
    \ |>\n<| c |>\nI should also mention that I tested the function `unique` above\
    \ on a vector of 10,000 elements and it was almost instantaneous. It was almost\
    \ instantaneous because the code was written in Julia, but you might get the same\
    \ speed for other languages. ", "    \n    n = 0\n    \n    for x in l \n    \
    \    if n <= x\n            n += 1\n        else \n            deleteat!(l, n)\n\
    \            n += 1\n            push!(l, n)\n        end\n    end\n    return\
    \ l\nend\n</code>\n<|/ a |>\n<| c |>\nThe order of the output is not guaranteed\
    \ to be sorted as you say, only that the values are unique.\n<|/ c |>\n<| c |>\n\
    Yes, you are right, but this was already mentioned in the question so I didn't\
    \ repeat it.\n<|/ c |>\n<| c |>\nI disagree that ordering is not guaranteed, as\
    \ this answer is accepted and this code does produce the same output. If you do\
    \ care about the ordering, then you would have to sort the output with something\
    \ like `sort(unique(v))`.\n<|/ c |>\n<| c |>\nYes, I see your point. I agree that\
    \ ordering is not guaranteed as written. However, this question is about unique\
    \ elements and the accepted answer is clear about that fact.\n<|/ c |>\n<| a tags=julia\
    \ |>\nHere is how to get unique elements from a vector:\n<code>", "    i = Int64[]\n\
    \    push!(i, 1)\n    u = Vector{Int64}()\n    while !isempty(i)\n        j =\
    \ pop(i)\n        if !in(u, j)\n            push!(u, j)\n        end\n    end\n\
    \    return u\nend\n</code>\n<|/ a dscore=2 tags=julia,unique,arrays |>\n<| c\
    \ |>\nThis is an excellent solution to the problem presented in the original question\
    \ (I actually had that problem before you posted this question), but your answer\
    \ does not generalize to other situations where we want to have unique elements\
    \ within a vector, such as when doing something like `unique([10, 10, 10, 20,\
    \ 10, 30, 10, 10])`. So the accepted answer is the most generalizable, and probably\
    \ the most efficient solution.\n<|/ c |>\n<| a tags=julia,unique,arrays |>\nHere\
    \ is an implementation using ArrayTools.jl that is much faster than the pure-Julia\
    \ solution and it is also much more general:\n<code>\nimport ArrayTools", "  \
    \  return uniques(l)\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\n`uniques` will\
    \ also work `julia> uniques([1,2,1,1,2,1])\n2-element Array{Int64,1}:\n 1\n 2`\n\
    <|/ c |>\n<| a dscore=2 tags=julia |>\nAs a supplement to previous answers.\n\
    <code>\njulia> using SortedArrays", "    if length(l) == 0 \n        return Vector{Int64}()\
    \ \n    else \n        l = sort(l)\n        unique = Vector{Int64}()\n       \
    \ for i in eachindex(l) \n            if l[i] != i \n                unique =\
    \ unique(unique:append(l[i]))\n            end\n        end\n        return unique\
    \ \n    end\nend\n</cell>\n<code language=julia-1.5>\n@time unique(A);\n@time\
    \ unique(B);\n@time unique(C);\n</cell>\n<text>\n5.7 Using a vector to filter\n\
    A common pattern in Julia is to use a vector to filter elements in an array. For\
    \ instance, the elements of A less than 5 is given by A[A .< 5].", "    \n   \
    \ return unique(sort(l))\nend", "    l = sort!(unique(l))\n    return l\nend\n\
    </cell>\n<text>\nReplacing elements with NA", "    unique = sort(unique(l))\n\
    \    return unique\nend ", "  result = Set()\n  for elem in l\n    if !contains(result,\
    \ elem) && elem > 0\n      insert(result, elem)\n    end\n  end\n  return result\n\
    end\n</code>\n<|/ a |>\n<| c |>\nI understand what your code is doing, but I don't\
    \ understand how it works. I mean if I don't understand some code, my head will\
    \ be sore and I'll god if I know how. Anyways, thanks for posting your answer\
    \ :).\n<|/ c |>\n<| c |>\nI posted a small explanation of the code at the end\
    \ of my answer, hope it is helpful.\n<|/ c |>\n<| a |>\nHere's a version that\
    \ works for any number of dimensions (up to 32). You might want to have a look\
    \ at the \"recursive version\" that doesn't use mapslices.\n<code>", "    \n \
    \   # First create a list of unique elements\n    l = sort(l)\n    unique = setdiff(l,\
    \ sort(l))\n    \n    # Then remove any duplicate elements\n    unique = [i for\
    \ i in unique if !haskey(unique, i)]\n    \n    return unique\nend\n</cell>\n\
    <text>\nExercise\nExperiment with different input types.", "    aux = Set()\n\
    \    for i in l\n        aux += i\n    end\n    unique = Set()\n    for i in aux\n\
    \        unique += i\n    end\n    return unique\nend\n\"\"\"\n    unique(l::Vector{Int64})::Vector{Int64}\
    \ \n    unique = Set()\n    for i in l\n        unique += i\n    end\n    return\
    \ unique\nend\n\"\"\"\n    unique(l::Vector{Float64})::Vector{Float64} \n    unique\
    \ = Set()\n    for i in l\n        unique += i\n    end\n    return unique\nend\n\
    \"\"\"\n    unique(l::Vector{String})::Vector{String} \n    unique = Set()\n \
    \   for i in l\n        unique += i\n    end\n    return unique\nend\n\"\"\"\n\
    \    unique(l::Vector{Any})::Vector{Any} \n    unique = Set()\n    for i in l\n\
    \        unique += i\n    end\n    return unique\nend\n\"\"\"\n    unique(l::Vector{Any})::Vector{Any}\
    \ \n    unique = Set()\n    for i in l\n        unique += i\n    end\n    return\
    \ unique\nend\n\"\"\"\n    unique(l::Vector{Bool})::Vector{Bool} \n    unique\
    \ = Set()\n    for i in l\n        unique += i\n    end\n    return unique\nend\n\
    \"\"\"\n    unique(l::Vector{Nothing})::Vector{Nothing} \n    unique = Set()\n\
    \    for i in l\n        unique += i\n    end\n    return unique\nend\n\"\"\"\n\
    \    unique(l::Vector{Any})::Vector{Any} \n    unique = Set()\n    for i in l\n\
    \        unique += i\n    end\n    return unique\nend\n\"\"\"\n    unique(l::Vector{Any})::Vector{Any}\
    \ \n    unique = Set()\n    for i in l\n        unique += i\n    end\n    return\
    \ unique\nend\n\"\"\"\n    unique(l::Vector{Any})::Vector{Any} \n    unique =\
    \ Set()\n    for i in l\n        unique += i\n    end\n    return unique\nend\n\
    \"\"\"\n    unique(l::Vector{Any})::Vector{Any} \n    unique = Set()\n    for\
    \ i in l\n        unique += i\n    end\n    return unique\nend\n\"\"\"\n    unique(l::Vector{Any})::Vector{Any}\
    \ \n    unique = Set()\n    for i in l\n        unique += i\n    end\n    return\
    \ unique\nend\n\"\"\"\n    unique(l::Vector{Any})::", "    return sort(unique(sort(l)))\n\
    end\n</cell>\n<code language=julia-1.5>", "    seen = Set{Int64}()\n    for i\
    \ in l\n        if !seen.add(i)\n            push!(seen, i); return i\n      \
    \  end\n    end\n    return []\nend\n</cell>\n<code language=julia-0.6>", "  \
    \  ret = Array{Int64}(length(unique(l)))\n    for i,x in enumerate(l)\n      \
    \  if ret[i] != x\n            ret[i] = x\n        end\n    end\n    return ret\n\
    end", "    unique_set = sort(unique(l))\n    unique_set\nend\nunique(v)\n</code>\n\
    <|/ a tags=julia,function |>\n<| a dscore=4 |>\nIf you need this a lot, you can\
    \ also define it in a module. For example, define your function unique:\n<code>\n\
    module Unique", "    inds = zeros(Int64, length(l))\n    inds[l] = Int64(1)\n\
    \    uniques = Set()\n    for i in 1:length(l)\n        if !contains(uniques,\
    \ inds[i])\n            inds[i] = inds[inds[i]] + 1\n            uniques = uniques\
    \ union (Set(inds[i:]))\n        end\n    end\n    return uniques\nend\n</code>\n\
    <|/ a dscore=1 tags=julia,set |>\n<| a dscore=0 tags=julia,set |>\nI wrote this\
    \ a long time ago, and now use it all my life.\n<code>", "     if l == [] return\
    \ []\n     if unique(l[1:end-1]) == unique(l[2:end]) return unique(l[1:end-1])\
    \ \n     return unique(l[1:end-1]) + unique(l[2:end]) \nend", "    return sort!(unique(Vector{Int64}(l)))\n\
    end", "    # find unique elements\n    idxs = Vector{Int64}(collect(1:length(l)))\n\
    \    idxs[find(l .== idxs)]\nend", "    res = Int64[]\n    push!(res, 1)\n   \
    \ for x in l\n        push!(res, x) \n        remove!(res, x) # remove x\n   \
    \ end\n    unique(res)\nend\n</code>\n<|/ a |>\n<| a |>\n<code>\nimport Base.push!",
  '    """ Return unique elements of a vector """', "    \n    \"\"\"\n    \n    \"\
    \"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n\
    \    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n\
    \    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\
    \"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n\
    \    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n\
    \    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\
    \"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n\
    \    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n\
    \    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\
    \"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n\
    \    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n\
    \    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\
    \"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n\
    \    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n\
    \    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\
    \"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n\
    \    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n\
    \    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\
    \"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n\
    \    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n\
    \    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\
    \"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n\
    \    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n\
    \    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\
    \"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n\
    \    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n\
    \    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\
    \"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n\
    \    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n    \"\"\"\n    \n\
    \    \"\"\"\n", "    seen = Set()\n    for i in l\n        if i not in seen \n\
    \            push!(seen, i)\n        end\n    end\n    return seen\nend", "  \
    \  u = sort(uniquevec(l))\n    u\nend", "    uniques = Set()\n    l = sort(l)\n\
    \    l = l[1:end-1]\n    push!(uniques,l[1])\n    for e in l[2:end]\n        if\
    \ e != l[end]\n            push!(uniques,e)\n        end\n    end\n    return\
    \ uniques\nend\n\"\"\"\n    unique(l::Vector{Int64}, k::Int64)::Vector{Int64}\n\
    \    Return the unique elements of a vector, ordered as first by the \n    order\
    \ of appearance and second by lexical ordering.\n    >>> unique([5, 3, 5, 2, 3,\
    \ 3, 9, 0, 123], 2)\n    [0, 3, 9, 123]\n    \"\"\"", "    # return l.sorted().unique();\n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n", "   \n    return sort(unique(l))\nend", "  \
    \  unique = uniqueElements(l)\n    return sort(unique)\nend\n</cell>\n<code language=julia-0.6>",
  "    result = Vector{Int64}()\n    push!(result, 1)\n    push!(result, 2)\n    for\
    \ element in l\n        if element != result[1]\n            push!(result, element)\n\
    \        end\n    end\n    return result\nend\n</code>\n<|/ a dscore=1 |>\n<|\
    \ c |>\nSorry I didn't include that in the original question but the numbers won't\
    \ be negative so I believe I'll be OK if I just do `unique(sort(numbers))`\n<|/\
    \ c |>\n<| c |>\n: If you do not want to use the built-in `unique` function you\
    \ can implement it yourself (see my answer)\n<|/ c |>\n<| a |>\nI would use a\
    \ hash table for the first pass and a list for the second. Something like\n<code>",
  "    seen = Set()\n    seenadd!(seen, Int64(l))\n    uniques = Array{Int64}(undef,\
    \ 0)\n    for elem in l\n        elem == 0 && continue\n        if elem == 0 &&\
    \ !seen\n            uniques\n        elseif elem == 0 && !iszero(elem)\n    \
    \        uniques\n        elseif elem in seen\n            push!(uniques, elem)\n\
    \        else\n            push!(uniques, elem)\n            seenadd!(seen, elem)\n\
    \        end\n    end\n    uniques\nend\nunique(a)", "    # make unique list\n\
    \    unique_l = copy(l)\n    unique_l .sort!()\n    unique_l .unique!()\n    unique_l\n\
    end\n</code>\n<|/ a dscore=5 tags=julia,set-theory,julia-set |>\n<| c |>\nThe\
    \ Julia documentation states that `unique!` is deprecated. So it's better to replace\
    \ `unique!` with `.unique!` in all cases.\n<|/ c |>\n<| c |>\nThanks, I added\
    \ that to the answer\n<|/ c |>\n<| a tags=julia,set-theory,julia-set |>\nIf you're\
    \ only looking to remove duplicates (no order), then I recommend the following\
    \ method. Here is an explanation of what's going on underneath:\n<code>\njulia>\
    \ mySet = [1 2 1 1 3 4 5]\n6-element Array{Int64,1}:\n 1\n 2\n 1\n 1\n 3\n 4\n\
    \ 5", "    return sort(unique(sort(l)))\nend\nunique(r::Array{Int64,1}) = unique(r,dims=1)\n\
    unique(r::Array{Int64,2}) = unique(r,dims=2)\nunique(r::Array{Int64,3}) = unique(r,dims=3)\n\
    unique(r::Array{Int64,4}) = unique(r,dims=4)", "    l = sort!(l)\n    return unique(unique(l))\
    \ == unique(l)\nend", "    uniq l = sort(l)\nend\n</code>\n<|/ a tags=julia dscore=2\
    \ |>\n<| a |>\nTo get unique values, you can just use unique.\nTo get all the\
    \ unique values from a vector, you should use unique.\n<code>\njulia> using LinearAlgebra",
  "    \n    sort!(unique(unique(sort(l)))::Vector{Int64})\nend", "  local unique\
    \ = Vector{Int64}()\n  for elem in l \n    if elem ~= 0 && !unique.include(elem)\
    \ \n      unique.(elem) = true\n    end \n  end\n  return unique\nend", "\tu =\
    \ sort(l)\n\twhile !all(isin(u,l))\n\t\tu = sort(u)\n\tu\nend\n\"\"\"\n    unique(l::Vector{T})\
    \ where T # unique elements, sorted and deduplicated\n\"\"\"", "    h = zeros(Int,\
    \ length(l)+1)\n    h[1] = 1\n    for x in l\n        h[x, 1] += 1\n    end\n\
    \    idx = h[:,2]\n    i = idx == 1\n    while i\n        idx = idx[!i]\n    \
    \    h[i] = h[idx] .+ 1 # we assume no two elements have the same frequency\n\
    \        i = idx == 1\n    end\n    unique(h[:,1])\nend\n</cell>\n<code language=julia-0.3>",
  "    return filter(x->x <, l); # return the unique elements\nend\n</code>\n<|/ a\
    \ dscore=5 |>\n<| c |>\n`uniq` seems to remove duplicates. `unique` does not seems\
    \ to remove duplicates.\n<|/ c |>\n<| c |>\n: I made a typo, `uniq` indeed remove\
    \ duplicates.\n<|/ c |>\n<| c |>\n`unique()` does not remove duplicates. But `uniq()`\
    \ **does**.\n<|/ c |>\n<| c |>\nThe `<` operator is not available in Julia\n<|/\
    \ c |>\n<| c |>\n: Ok, I updated the answer and added the missing operator. Thanks\
    \ for pointing this out.\n<|/ c |>\n<| a tags=julia |>\nThe unique function from\
    \ DataFrames removes duplicate rows from a DataFrame based on a specified column:\n\
    <code>\njulia> using DataFrames", "  result = Set.empty{Int64}\n  for v in l\n\
    \    add(result, v)\n  end\n  result\nend", "    l = unique(l)\n    sort(l)\n\
    \    l\nend\n</code>\n<|/ a |>\n<| c |>\nThank you,, this is indeed a much better\
    \ solution.\n<|/ c |>\n<| a dscore=2 |>\nAnother simple method is to put all the\
    \ numbers in a hash (dictionary) and then sort them.\n<code>", "    seen=Set()\n\
    \    u = Vector{Int64}()\n    for i in l \n        if !haskey(seen,i) \n     \
    \       push!(seen,i) \n        else \n            push!(u,i)\n        end\n \
    \   end\n    push!(u,1) \n    return u\nend\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ tags=julia,arrays,dictionary |>\nHere is a simple solution to get a unique vector\
    \ of length n from a vector of length n:\n<code>", "    sort(unique(l))\nend\n\
    </code>\n<|/ a tags=julia dscore=4 |>\n<| c |>\nThis is probably the best answer\
    \ for most Julia users, so I thought I'd mention that `unique` has been deprecated\
    \ in favor of `Set`. I think this answer should now be updated.\n<|/ c |>\n<|\
    \ a dscore=4 tags=julia |>\nThis works on Array{Int} and Vector{Int} and in general\
    \ for any other AbstractArray like Set{Int}, Dict{String,Int}, etc.\n<code>\n\
    julia> Vector{Int}([1,2,2,3,4,5]).sort()\n5-element Array{Int64,1}:\n 2\n 3\n\
    \ 4\n 1\n 5", "    l = sort(l)\n    i = Set()\n    push!(i, l[1])\n    for i in\
    \ l[2:end-1]\n        if i \u2209 i\n            push!(i,  i)\n        else\n\
    \            return l\n        end\n    end\n    return l\nend\n</code>\nThe function\
    \ above returns sorted unique elements in a vector.\n<code>\nunique(vec) # unique\
    \ elements in a vector\n</code>\n<|/ a tags=algorithm,julia,arrays dscore=2 |>\n\
    <| a tags=algorithm,julia,arrays dscore=2 |>\n<code>\nusing Statistics", "   \
    \     \n    n = 0\n    for i in l\n        n += 1\n        if n <= 1\n       \
    \     return l\n        end\n    end\n    \n    i = 2\n    last = 0\n    \n  \
    \  while i < n\n        if l[i]==l[i-1]\n            last = i\n        end \n\
    \        i += 1\n    end\n    \n    return l[1:last]\nend\n</cell>\n<code language=julia-1.4>\n\
    x = rand(5)\ny = rand(5)\nz = unique(x)\n</cell>\n<code language=julia-1.4>\n\
    # Benchmark\n@time unique(x); @time unique(y); @time unique(z);\n</cell>\n<text>\n\
    Vectorization\nIf we want to make code faster, then we have to make code faster.\
    \  Julia has a lot of built-in functions that already do vectorization.", "  \
    \  \"\"\"Return sorted unique elements in an array\n    >>> unique([5, 3, 5, 2,\
    \ 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"", "    seen = Set{Int64}()\n\
    \    for i in l\n        if !seen.contains(i)\n            seen.add(i)\n     \
    \       push!(seen, i)\n        end\n    end\n    return seen\nend\n</cell>\n\
    <code language=julia-1.5>", "    unique = sort(unique(sort(l)))\n    return unique\n\
    end", "    for x in l do if haskey(uniques,x) then uniques[x] else uniques[(x)]\
    \ = x end end\nuniques = Dict{Int64, Int64}()\nunique(x) = x\nunique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(",
  "    return sort(unique_(l, length(l)-1))\nend\nunique_ = function(a::Vector{Int64},\
    \ i::Int64)::Vector{Int64} \n    if i == 1 \n        return a\n    else\n    \
    \    u = set(a[1:i])\n        @append!(u, a[i])\n        return unique_(set(a[i+1:end]),\
    \ u) + u\n    end\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nWhat does this do?\
    \ Could you give a more in-depth description on what is going on? How does this\
    \ compare to the other answer that uses the same algorithm as this answer?\n<|/\
    \ c |>\n<| c |>\n`set` only returns unique elements. It does not sort.\n<|/ c\
    \ |>\n<| c |>\nYeah, I know. I was wondering if you could add some explanation\
    \ to your answer. Thanks.\n<|/ c |>\n<| a |>\nThe first answer is a bit verbose\
    \ for my taste, however the second answer is not as efficient (O(n^2)). Here is\
    \ a faster solution.\n<code>\nusing Statistics", "  \"\"\"Return sorted unique\
    \ elements in a vector\n  \n  Arguments\n  ---------\n  l (Vector): vector to\
    \ filter\n  \n  Returns\n  -------\n  Vector: unique elements of input vector\n\
    \  \"\"\"\n  return unique(unique(l))\nend", " \n    unique = Set()\n    for i\
    \ in l\n        if !in(f, unique, i)\n            push!(f, i)\n            unique\
    \ = unique + [i]\n        end\n    end\n    unique\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| a tags=julia |>\nIf you want unique elements, you can do something like\
    \ this:\n<code>\njulia> function unique(a::Vector{Int64})\n           b = Set()\n\
    \           for i in a\n               push!(b,i)\n           end\n          \
    \ return b\n       end\nunique (generic function with 1 method)", "\tl=sort(l)\n\
    \tu=unique(l)\n\tu=setdiff(l, u)\n\treturn u\nend", "    unique(unique(l))\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nI do not think this problem has\
    \ an efficient solution, but I might still try to find a solution myself.\nI am\
    \ guessing that the problem is equivalent to \"Find a sequence of elements that\
    \ appear in an array.\" \nThe function below is O(n^2) in time but probably O(n*logn)\
    \ in space. \n<code>", "    unique = Set()\n    unique.add(0)\n    unique.update(l)\n\
    \    unique(unique)\nend", "    unique_list = Set()\n    unique_vector = Vector{Int64}()\n\
    \    for i in unique_list\n        if contains(unique_vector, i)\n        else\n\
    \            unique_vector = unique_vector + [i]\n            unique_list = union!(unique_list,\
    \ i)\n        end\n    end\n    return unique_vector\nend", "    result = Array{Int64}(length(l))\n\
    \    seen = Set{Int64}()\n    for i in eachindex(l)\n        if !haskey(seen,\
    \ i) || l[i] < result[i]\n            result[i] = l[i]\n            seen[i] =\
    \ true\n        end\n    end\n    return copyto(result, result)\nend\n</cell>\n\
    <text>\nExercise 1: Unique Elements\nWrite a function that returns a sorted unique\
    \ elements in a vector.", "    unique = Set()\n    for i in l \n        if i not\
    \ in unique \n            unique.add(i)\n        end\n    end\n    unique\nend\n\
    </cell>\n<text>\n2. Problem to solve\nFor each of the following input files, output\
    \ a list of unique integers representing a palindrome.", "    uniques = Vector{Int64}()\n\
    \    count = 0\n    for x in l\n        if !haskey(uniques, x)\n            uniques[x]\
    \ = count\n            count += 1\n        end\n    end\n    return uniques\n\
    end", "    \"\"\"Find unique elements in an array\n    >>> unique([5, 3, 5, 2,\
    \ 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"", "    unique = Vector{Int64}()\n\
    \    unique[unique.last_index] = l\n    unique\nend\n\"\"\"\nFind the unique elements\
    \ in a vector using the Julia idiom `Set`\n\"\"\"", "    sort(l)\n    return l\n\
    end\n</cell>\n<code language=julia-1.6>", "    \n    if length(l) < 2\n      \
    \  return l\n    end\n    \n    l = sort(l)\n    i = 2\n    while i < length(l)\n\
    \        if l[i] == l[i-1]\n            i += 1\n        else\n            push!(l,\
    \ l[i])\n        end\n    end\n    return l\nend", "    indices = Vector{Int64}()\n\
    \    unique!(l, indices, 0)\n    return indices\nend\nunique(l::Vector{Int64},\
    \ indices, i::Int64)::Int64 = length(l)>i ? unique!(l, indices, i+1)::i\nunique(l::Vector{Int64},\
    \ indices::Vector{Int64}, i::Int64)::Int64 = length(l)>i ? unique!(l, indices,\
    \ i+1)::length(indices[i:])\nunique(l::Vector{Int64}, indices::Vector{Int64},\
    \ i::Int64)::Int64 = length(l)>i ? unique!(l, indices, i+1)::indices[i:]\nunique(l::Vector{Int64},\
    \ indices::Vector{Int64}, i::Int64)::Int64 = length(l)>i ? unique!(l, indices,\
    \ i+1)::indices[i:]\nunique(l::Vector{Int64}, indices::Vector{Int64}, i::Int64)::Int64\
    \ = length(l)>i ? unique!(l, indices, i+1)::indices[i:]\nunique(l::Vector{Int64},\
    \ indices::Vector{Int64}, i::Int64)::Int64 = length(l)>i ? unique!(l, indices,\
    \ i+1)::indices[i:]\nunique(l::Vector{Int64}, indices::Vector{Int64}, i::Int64)::Int64\
    \ = length(l)>i ? unique!(l, indices, i+1)::indices[i:]\nunique(l::Vector{Int64},\
    \ indices::Vector{Int64}, i::Int64)::Int64 = length(l)>i ? unique!(l, indices,\
    \ i+1)::indices[i:]\nunique(l::Vector{Int64}, indices::Vector{Int64}, i::Int64)::Int64\
    \ = length(l)>i ? unique!(l, indices, i+1)::indices[i:]\nunique(l::Vector{Int64},\
    \ indices::Vector{Int64}, i::Int64)::Int64 = length(l)>i ? unique!(l, indices,\
    \ i+1)::indices[i:]\nunique(l::Vector{Int64}, indices::Vector{Int64}, i::Int64)::Int64\
    \ = length(l)>i ? unique!(l, indices, i+1)::indices[i:]\nunique(l::Vector{Int64},\
    \ indices::Vector{Int64}, i::Int64)::Int64 = length(l)>i ? unique!(l, indices,\
    \ i+1)::indices[i:]\nunique(l::Vector{Int64}, indices::Vector{Int64}, i::Int",
  "    uniq = Vector{Int64}()\n    uniq = uniq + uniq \n    for i in l\n        if\
    \ i !in uniq\n            uniq = uniq + i \n        end\n    end\n    uniq\nend\n\
    </code>\n<|/ a tags=julia |>\n<| a dscore=2 tags=julia |>\nTo complement the answers\
    \ already given, in Julia 1.x you can use the in keyword.\n<code>\njulia> [1,\
    \ 2, 3] for n in [1, 2, 3] if n in [1, 2]\n3-element Array{Any,1}:\n 2\n 3\n 1\n\
    </code>\n<|/ a |>\n<| c |>\nIt appears that Julia 1.x does have this feature.\
    \ https://docs.julialang.org/en/v1/manual/control-flow/#for-loops-and-conditional-expressions-1\n\
    <|/ c |>\n<| c |>\nOh, cool! It looks like this feature was added in Julia 1.5.0.\n\
    <|/ c |>\n<| a tags=julia |>\n<code>\njulia> xs = [1,2,2,3,4]\n4-element Array{Int64,1}:\n\
    \ 1\n 2\n 2\n 3\n ", "    if length(l)==0\n        return l\n    \n    l = uniqueSorted(l)\n\
    \    \n    m = length(l) \n    n = floor((m+1)*m/2)\n    \n    q = Array{Int64}(m,\
    \ n)\n    \n    k = 1 \n    \n    aux = zeros(Int, m)\n    \n    for i = 1:m\n\
    \        aux = setdiff(unique(l[i*n:end]), l[i])\n        \n        for j = 1:n\n\
    \            q[i,j] = l[k-1]\n            \n            k=k+1\n        end\n \
    \   end\n    \n    return q\nend", "    seen = Set{Int64}()\n    result = Vector{Int64}()\n\
    \    for i in l\n        if !haskey(seen, i)\n            push!(result, i)\n \
    \           push!(seen, i)\n        end\n    end\n    result\nend", "    s = Set()\n\
    \    for x in l\n        if !contains(s, x)\n            push!(s, x)\n       \
    \ end\n    end\n    return collect(s)\nend\n</cell>\n<text>\nUnique rows in a\
    \ DataFrame with Julia\nWe can use Julia to get a unique list of rows in a DataFrame.",
  "    seen = {}\n    uniques = []\n    for x in l\n        if seen[x] == 0\n    \
    \        seen[x] = 1\n            uniques << x\n        end\n    end\n    return\
    \ uniques\nend", "    if l==[]\n        return [] \n    elseif length(l)==1\n\
    \        return l \n    else\n        push!(Unique, l[1]) \n        uniq_sort(Unique,\
    \ l[2:end]) \nend ", "    # Sort and remove duplicates\n    s = sort(l)\n    idx\
    \ = find(x -> x != last(s) ,s)\n    \n    l -= s[idx+1:end]\n    return l\nend",
  "    unique = Vector{Int64}()\n    unique = [i for i in unique, j in l if !(j \u2209\
    \ unique and j != i)]\n    unique\nend\nunique = convert(Array, unique)", "  \
    \  \n    uniqued = {}\n    uniqued = vcat(uniqued, v)\n    uniqued = setdiff(uniqued,\
    \ v)\n    return uniqued\nend\n</cell>\n<code language=julia-1.4>", "    return\
    \ setdiff(unique(l), l)\nend", "\tunique(filter(i -> !iszero(i), l))\nend\n</cell>\n\
    <code language=julia-0.5>", "    \n    index = Set{Int64}()\n    result = Vector{Int64}()\n\
    \    for x in l\n        if !haskey(index, x)\n            push!(index, x)\n \
    \           push!(result, x)\n        end\n    end\n    return result\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 |>\nHere is a simple way using Dicts.\n<code>\n\
    julia> using Dicts", '    """Remove all duplicate elements from a vector"""',
  "    #Get unique elements (with duplicates removed) from a vector\n    s = set()\
    \ \n    for elt in l \n        push!(s, elt) \n    end\n    unique(sort(s))\n\
    end", "    seen = Set{Int64}()\n    push!(seen,0)\n    unique_vector = Vector{Int64}()\n\
    \    for i in l\n        if !in(i, seen)\n            push!(seen, i)\n       \
    \     push!(unique_vector, i)\n        end\n    end\n    return unique_vector\n\
    end\n</code>\nAnd it also has a nice feature of being vectorized:\n<code>\njulia>\
    \ unique(vec1)\n5-element Vector{Int64}:\n 0\n 1\n 2\n 3\n 4", "  t = []\n  for\
    \ e in l \n    push!(t, e) \n  end\n  unique(sort(t)) # Sort again \nend\n\"\"\
    \"Return sorted unique elements in a vector\n    >>> unique([5, 3, 5, 2, 3, 3,\
    \ 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"", "    n = length(l) \n  \
    \  \n    # create output \n    ret = Array{Int64}(undef, n)\n    \n    # sort\
    \ \n    sort!(l, by = x -> x)\n    \n    # loop through elements and store in\
    \ output\n    for i = 1:n\n        if l[i] != i\n            ret[l[i]] = i\n \
    \       end\n    end\n    \n    # return output\n    return ret\nend\n</cell>\n\
    <code language=julia-1.0>\nunique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n</cell>\n<text>\n\
    Write a function that takes a vector of strings as input and returns a vector\
    \ of the lengths of each string in the input. For example, if input = [\"Hello\"\
    , \"my\", \"name\", \"is\", \"Bobby\"], the function should return [3, 5, 6].\
    \ Note that your function should work for both Unicode strings and ASCII strings.",
  "    \"\"\"\n    Get sorted unique elements in a vector\n    \"\"\"", "    if length(l)\
    \ == 1 return l\n    k = 0\n    for e in l \n        if k != e\n            k++\n\
    \        end\n    end\n    unique(sort(l, by=:<_))\nend\n</code>\n<|/ a |>\n<|\
    \ a tags=sorting,julia,arrays |>\nThe other answers here don't work properly if\
    \ the array has duplicate elements. Here's a working example that returns unique\
    \ elements from an array:\n<code>", "    uniques = Set{Int64}()\n    for i in\
    \ l\n        uniques.insert(i)\n    end\n    uniques\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Compute mean of a vector\n\"\"\"", "    l = sort(l)\n    return l\nend\n\
    </cell>\n<text>\nThis function is also quite useful: it gives you the indices\
    \ of the unique values, as given by unique.", "    seen = Set{Int64}()\n    for\
    \ i in l\n        if !seen.add(i)\n            yield i\n    end\nend", "    unique\
    \ = Vector{Int64}()\n    \n    for i in l\n        if !unique.includes(i) \n \
    \           unique.push(i)\n        end\n    end", "    unique=HashSet()\n   \
    \ for x in l\n        unique.add(x)\n    return unique(unique)\nend\nunique=@fastmath\
    \ unique(l)\n</code>\n<|/ a dscore=2 |>\n<| a tags=julia,sorting |>\nI prefer\
    \ to use Julia's built-in functions for this\n<code>\njulia> x = sort([5,3,5,2,3,3,9,0,123])\n\
    123-element Array{Int64,1}:\n 9\n 0\n 3\n 5\n 2", "    unique=Vector{Int64}()\n\
    \    unique=[i for i in l if i!=i || unique.length==0 || unique.last!=i]\n   \
    \ return unique\nend", "    return sort(unique_inplace(l))\nend", "    uniqueset\
    \ = Set()\n    uniqueset.addall(l)\n    return uniqueset\nend\nunique(xs) = unique(xs)",
  "    unique = sort(l)\n    length(unique(unique(unique))) == 1\n    unique\nend\n\
    </cell>\n<text>\nExercise\nCreate a function that returns the first element in\
    \ a vector, and removes that element from the vector.  It should return a copy\
    \ of the vector with the first element removed.", "    \"\"\" Return unique elements\
    \ of a vector\n    \"\"\"\n# endregion", "    return filter(!@isnt l, unique(sort(l)))\n\
    end\n</cell>\n<code language=julia-0.6>", "    idx = Set()\n    l = sort(l)\n\
    \    for i in l \n        if !haskey(idx, i) \n            idx[i] = true\n   \
    \     else \n            idx[i] = false\n    end\n    l\nend\n</code>\n<|/ a dscore=3\
    \ tags=julia |>\n<| a tags=julia dscore=3 |>\nSince Julia 1.6 this can be done\
    \ simply by using a Set and sorting (for lexicographically sorted):\n<code>\n\
    julia> using Sets", "    if length(l) == 0 return l\n    \n    unique_values =\
    \ unique(vec(sort(l)))\n    unique_vector = convert(Vector{Int64}, unique_values)\n\
    \    return unique_vector\nend ", "    uniques = Set()\n    uniques[length(l)]\
    \ = l\n    for i in uniques\n        if i !in l\n            push!(uniques,i)\n\
    \        end\n    end\n    uniques\nend\n</cell>\n<code language=julia-0.5>\n\
    #export\n\"\"\"Return unique elements in a matrix\n\"\"\"", "    seen = Set()\n\
    \    unique_l = list()\n    for e in l \n        if !haskey(seen,e) \n       \
    \     unique_l.append(e)\n            push!(seen, e)\n        else \n        \
    \    continue\n    end\n    return unique_l\nend\n</code>\n<|/ a dscore=0 tags=julia,arrays,duplicates\
    \ |>\n<| a dscore=0 |>\nI needed something like this recently and ended up writing\
    \ a custom Julia library for solving this problem: https://github.com/jmckay/DuplicationRemoval.jl\n\
    The function can be called as follows:\n<code>\njulia> removeDuplicates(a)\n1-element\
    \ Array{Int64,1}:\n 3\n</code>\nIt uses a hash table (which is implemented as\
    \ a map) and does not preserve order.\n<|/ a tags=julia,arrays,duplicates |>\n\
    <| a tags=julia,arrays,duplicates dscore=0 |>\nIf you don't care about preserving\
    \ order, then you can use uniq function. \n<code>\njulia> a = [1,1,1,2,2,2,3,3,3,4,5,5]\n\
    5-element Array{Int64,1}:\n 1\n 1\n 2\n 2\n 3\n 3", "    local l2 = unique(l);\n\
    \    idxs = l2.==l;\n    return idxs.*l2 .+ l2.==l;\nend;\n</code>\nand another\
    \ alternative is to use the function union:\n<code>\n\"\"\"Return sorted unique\
    \ elements in a vector\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0,\
    \ 2, 3, 5, 9, 123]\n    \"\"\"", "    l = sort(l)\n    i = 0\n    j = length(l)\
    \ - 1\n    while i <= j\n        if l[i] == l[j]\n            i += 1\n       \
    \     j += 1\n        else\n            if i > j\n                l[i] = l[j]\n\
    \                i += 1\n                j += 1\n            else\n          \
    \      if l[i] > l[j]\n                    l[j], l[i] = l[i], l[j]\n         \
    \           i += 1\n                    j += 1\n                else\n       \
    \             i += 1\n                end\n            end\n        end\n    end\n\
    \    return l\nend", "    idx = Set{Int64}()\n    for e in l\n        !haskey(idx,\
    \ e) && idx += e\n    end\n    return idx.to_a\nend\n</code>\n<|/ a tags=julia,set,unique\
    \ dscore=3 |>\n<| a tags=julia,set,unique |>\nBased on the solution by Steven\
    \ Lokto, here is a solution which doesn't need any external packages. It is even\
    \ shorter!\n<code>", "   sort(l)\n   unique_values = setdiff(l, values(l))\n \
    \  sort(unique_values)\nend\n</code>\n<|/ a tags=julia,algorithm,arrays |>\n<|\
    \ a dscore=1 |>\n<code>\njulia> a = unique([5, 5, 3, 3, 3, 9, 0, 123])\n5-element\
    \ Vector{Int64}:\n 3\n 9\n 0\n 123\n \njulia> sort(a)\n5-element Vector{Int64}:\n\
    \ 3\n 9\n 0\n 123\n \njulia> sort(unique(a))\n5-element Vector{Int64}:\n 3\n 9\n\
    \ 0\n 123\n \njulia> sort(unique(a, remove=true))\n5-element Vector{Int64}:\n\
    \ 3\n 9\n 0\n 123\n \njulia> sort(unique(a, remove=false))\n5-element Vector{Int64}:\n\
    \ 3\n 9\n 0\n 123\n \njulia> sort(unique(a, sort = true))\n5-element Vector{Int64}:\n\
    \ 3\n 9\n 0\n 123\n \njulia> sort(unique(a, sort = [true]))\n5-element Vector{Int64}:\n\
    \ 3\n 9\n 0\n 123\n \njulia> sort(unique(a, sort = false))\n5-element Vector{Int64}:\n\
    \ 3\n 9\n 0\n 123\n \njulia> sort(unique(a, sort = [false]))\n5-element Vector{Int64}:\n\
    \ 3\n 9\n 0\n 123\n \njulia> sort(unique(a, sort = true))\n5-element Vector{Int64}:\n\
    \ 3\n 9\n 0\n 123\n \njulia> sort(unique(a, sort = [true]))\n5-element Vector{Int64}:\n\
    \ 3\n 9\n 0\n 123\n \njulia> sort(unique(a, sort = false))\n5-element Vector{Int64}:\n\
    \ 3\n 9\n 0\n 123\n \njulia> sort(unique(a, sort = [false]))\n5-element Vector{Int64}:\n\
    \ 3\n 9\n 0\n 123\n \njulia> sort(unique(a, sort = []))\n5-element Vector{Int64}:\n\
    \ 3\n 9\n 0\n 123\n \njulia> sort(unique(a, sort = false))\n5-element Vector{Int64}:\n\
    \ 3\n ", "    uniqueElements = collect(l)\n    uniqueElementsSortedUnique = sort(uniqueElements)\n\
    \    return uniqueElementsSortedUnique\nend\n\"\"\"\nA function `unique` that:\n\
    1. Returns unique elements of a list.\n2. Returns sorted unique elements of a\
    \ list.\n\"\"\"", "    if length(l) == 1 then return [l]\n    let m = @max l \n\
    \    if m == 0 then return [l]\n    else \n        return unique(setdiff(l, m)).+(m)\n\
    \    end\nend\nunique()\n</cell>\n<text>\nLet's look at how this works.  For each\
    \ element in the vector, if the element is greater than the maximum value of the\
    \ vector, remove it from the list.  If the length of the resulting list is equal\
    \ to the length of the original list, then that element was not in the original\
    \ list.  Otherwise return the new list.  Let's try it out.  Let's first start\
    \ with some random vector and see how the algorithm works:", "  l = sort(l)\n\
    \  idx = Set()\n  for (i,n) in enumerate(l)\n    if !contains(idx, n)\n      idx\
    \ += n\n    end\n  end\n  return idx\nend", "    uniques = Set()\n    for i in\
    \ l\n        push!(uniques,i)\n    end\n    uniques\nend\n</cell>\n<code language=julia-1.5>",
  "    sort!(unique(l))\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=2 |>\nIf you\
    \ do not need to preserve the original ordering, you can use Sets:\n<code>\njulia>\
    \ s = Set([1, 2, 3, 4]);\njulia> push!(s, 5);\njulia> s\nSet{Int64}([1,2,3,5,4])\n\
    </code>\n<|/ a tags=julia |>\n<| c |>\nA set is not guaranteed to preserve ordering\
    \ like an array or list\n<|/ c |>\n<| c |>\nThe order of set elements is guaranteed\
    \ to be stable in julia 1.5 onwards.\n<|/ c |>\n<| a |>\nAvoid using unique and\
    \ sort!\n<code>\njulia> s = Set([1, 2, 3, 4]);\njulia> push!(s, 5);\njulia> s\n\
    Set{Int64}([1,2,3,5,4])", "    unique = Set()\n    for x in l\n        if !unique.contains(x)\n\
    \            push!(unique, x)\n        end\n    end\n    unique\nend\n</code>\n\
    <|/ a dscore=1 tags=julia,unique,vector |>\n<| c |>\nYes, I didn't know about\
    \ Set, thank you. On the performance aspect, is it not possible to do this without\
    \ creating a new vector?\n<|/ c |>\n<| c |>\nAh. Ok, now I remember. Yes, this\
    \ could be done without creating a new vector. But the `push!` would make things\
    \ much slower, since `unique` would also have to check the `push!` to see if it\
    \ was already there. So, it could be faster to create an empty `unique` vector,\
    \ `push!` everything to that vector, and then `unique`. Then, at the end, return\
    \ the vector you created. See edit above.\n<|/ c |>\n<| c |>\nOk, that is a little\
    \ better. Thanks for your help.\n<|/ c |>\n<| c |>\nGlad I could help. Also, if\
    \ you don't mind, I'd appreciate an upvote and an accept. Thanks.\n<|/ c |>\n\
    <| c |>\nI tried, but I don't have enough reputation yet to do so. Thanks again\
    \ though!\n<|/ c |>\n<| a dscore=1 |>\nThis is another solution that is O(n) in\
    \ the number of elements, but O(n\xB2) in the number of duplicates. I believe\
    \ this is more readable, and can be made even more performant by using a mutable\
    \ set instead of hash-tables.\n<code>\njulia> function unique(l::Vector{Int})\n\
    \           sets = Set()\n           for i in l\n               push!(sets, i)\n\
    \           end\n           return sets[1]\n       end", "    unique = Set()\n\
    \    for x in l do \n        if not (x in unique) then unique.add(x); end\n  \
    \  end\n    return unique\nend\n</cell>\n<code language=julia-1.5>\nunique([5,\
    \ 3, 5, 2, 3, 3, 9, 0, 123])\n</cell>\n<text>\nA very important point in this\
    \ section is, the order of the elements in the returned list will be the same\
    \ as the order of the original list! This means that a solution can not be guaranteed\
    \ if the elements of the original list are not in ascending order.", "    if length(l)\
    \ == 0 \n        return l \n    \n    uniques = Set{Int64}() \n    for i in l\n\
    \        if !haskey(uniques,i) \n            push!(uniques, i) \n        else\
    \ \n            uniques[i] = delete!(uniques,i) \n    uniques \nend \n</code>\n\
    <|/ a tags=julia,set-theory |>\n<| a dscore=0 |>\nIn Julia v0.7 you can use function\
    \ setdiff\n<code>\njulia> setdiff([1], 2, [3])\n2-element Array{Int64,1}:\n 2\n\
    \ 3\n</code>\n<|/ a tags=julia,set-theory |>\n<| c |>\nThe question is about sets\
    \ not arrays. Also sets are unordered. `setdiff([1], 2, [3])` will produce an\
    \ error. Also sets are unhashable.\n<|/ c |>\n<| c |>\nThis answer was posted\
    \ before Julia v0.7. The question was about sets, not arrays.\n<|/ c |>\n<| c\
    \ |>\nThis is wrong. `setdiff` does not work with `Set`s. It only works on set-like\
    \ collections such as `Set` or `Dict`.\n<|/ c |>\n<| c |>\nThe questions asks\
    \ for unique elements and you answered with `setdiff`. How is that any different?\n\
    <|/ c |>\n<| c |>\nThe questions asks for unique elements and you answered with\
    \ setdiff. So this answer was posted before Julia v0.7. How is that any different?\
    \ It was posted before Julia v0.7 because the question was about sets not arrays.\n\
    <|/ c |>\n<| a dscore=0 |>\nI needed to find out unique elements of a vector and\
    \ I used Set\n<code>\njulia> Set([5, 3, 5, 2, 3, 3, 9, 0, 123]) \nSet{Int64}([2,\
    \ 3, 5, 9, 123])\n</code>\nthen use Set's methods to find out unique elements:\n\
    <code>\njulia> Set([5, 3, 5, 2, 3, 3, 9, 0, 123]).uniq \nSet{Int64}([0, 2, 3,\
    \ 5, 9, 123])\n</code>\n<|/ a tags=julia,set-theory |>\n<| c |>\n`Set` does not\
    \ maintain the order of the unique elements and so this solution will not work\
    \ for any input.\n<|/ c |>\n<| c |>\nIt does preserve the order of the unique\
    \ elements though, since it produces a set. `unique` then does the job of ordering.\n\
    <|/ c |>\n<| c |>\n`unique(Set([5, 3, 5, 2, 3, 3, ", "    index = sort(l)\n  \
    \  unique(index) #make sure we don't return duplicate elements\n    return index\n\
    end", "  if length(l) == 0 \n    []\n  else if length(l) == 1 \n    vecfirst(l)\n\
    \  else\n    uniq(sort(unique(l)))\n  end\nend", "    i = Set()\n    forall(i,\
    \ x -> !(i.add(x), true))\n    i\nend\n</code>\n<|/ a tags=julia dscore=1 |>\n\
    <| a tags=julia |>\nI think the best solution is the following one, using Sorting\
    \ package:\n<code>\nusing Sorting", "    v = []\n    for x in l\n        if !ismember(x,\
    \ v)\n            v = [v; x]\n        end\n    end\n    v\nend\n</cell>\n<code\
    \ language=julia-1.4>\nunique([5, 3, 5, 2, 3, 3, 9, 0, 123]);\n</cell>\n<text>\n\
    We have defined many useful operations on vectors. We can now use these in a variety\
    \ of ways. One example is finding the mean:", "    unique = Set()\n    for i in\
    \ l\n        if i not in unique\n            unique = unique + [i]\n        end\n\
    \    end\n    return unique\nend\nunique(r::Vector{String}) = unique(r::Vector{String})\n\
    unique(r::Vector{Int64}) = unique(r::Vector{Int64})\nunique(r::Vector{Float64})\
    \ = unique(r::Vector{Float64})", "    if length(l)==0 return [] \n    seen = Set{Int64}()\n\
    \    unique_result = []\n    for i in l\n        !seen.add(i) && unique_result.append(i)\n\
    \    end\n    return unique_result\nend\nend\n</code>\n<|/ a tags=julia |>\n<|\
    \ a tags=julia dscore=2 |>\nJulia has a very nice function for this built in:\
    \ distinct:\n<code>\njulia> distinct([2, 3, 9, 9, 0, 1])\n3-element Array{Int64,1}:\n\
    \ 2\n 9\n 1\n</code>\n<|/ a |>\n<| c |>\nThanks. I did not know about this function.\
    \  Unfortunately, it only works in Julia 0.7.\n<|/ c |>\n<| c |>\nThe function\
    \ was added in Julia 0.8, so you can use `Base.distinct` in 0.7.\n<|/ c |>\n<|\
    \ c |>\nYes, I agree with both of you. This was added in Julia 0.8, which I believe\
    \ is the latest version, and I am currently using 0.7.\n<|/ c |>\n<| c |>\nNote\
    \ that `distinct` removes the duplicate elements from the original array.\n<|/\
    \ c |>\n<| a |>\nA possible solution is to use the function sort combined with\
    \ filter. \n<code>\na = [2, 3, 9, 9, 0, 1];\nprintln(sort(filter(x -> x<9,a)))\n\
    </code>\n<|/ a dscore=1 tags=julia |>\n<| a dscore=1 |>\nI believe this to be\
    \ the most efficient in terms of performance:\n<code>\nusing BenchmarkTools",
  "    if length(l) == 0 then return []\n    i = sort(unique(sort(l)))\n    \n   \
    \ # i is sorted so just use index to get unique values\n    unique_values = [l[index]\
    \ for index in i ]\n    unique_values[end] = l[end]\n    return unique_values\n\
    end", "    \n    unique = unique(l,false)\n    \nend", "    n = 0\n    while n\
    \ < length(l)\n        n += 1\n        if l[n] == l[n-1]\n            l[n] = l[n-1]\n\
    \            l[n-1] = l[n-1]\n        end\n    end\n    return l\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThe `if l[n] == l[n-1] end` clause should be `if n == 1 l[n]\
    \ = l[n-1] end`.\n<|/ c |>\n<| c |>\nIndeed! I did that in haste when I was trying\
    \ to figure out how to fix the error. Edited the answer appropriately.\n<|/ c\
    \ |>\n<| a tags=julia |>\nI needed a solution for my problem using an iterator\
    \ function without changing my data type and without changing the original ordering.\
    \ My solution is:\n<code>", "    seen = Set{Int64}()\n    seen.add(x)\n    for\
    \ x in l \n        if x not in seen \n            seen.add(x)\n            return\
    \ x \nend \n    return l\nend ", "    unique_elements = Set()\n    for elem in\
    \ l\n        unique_elements = unique_elements | Set(elem)\n    end\n    return\
    \ unique_elements\nend", "    return sort(collect(l))\nend", "    l = sort(l)\n\
    \    @assert length(l) == length(unique(sort(l)))\n    unique_list = Set()\n \
    \   unique_list_index = Set{Int64}()\n    for i in 1:length(l)\n        if i not\
    \ in unique_list_index\n            push!(unique_list, l[i])\n            push!(unique_list_index,\
    \ i)\n        end\n    end\n    unique_list = unique(unique_list)\n    return\
    \ unique_list\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThanks, this also seems\
    \ much faster than the answer provided by T. Frederic, for small number of unique\
    \ elements.\n<|/ c |>\n<| a |>\nHere's a more efficient solution. \nIt involves\
    \ two passes over the original vector. On one pass it uses unique() to remove\
    \ the duplicate elements, and on the other pass it converts the vector to a set,\
    \ and then back to a vector. \n<code>\njulia> v = [5,3,5,2,3,3,9,0,123]\njulia>\
    \ setdiff(unique(convert(Set{Int64},v)),v)\n10-element Array{Int64,1}:\n 0\n 2\n\
    \ 3\n 5\n 9\n 123\n</code>\n<|/ a dscore=4 tags=julia |>\n<| c |>\nThis also seems\
    \ much faster than the answer by T.Frederic.\n<|/ c |>\n<| a |>\nThis should work\
    \ too:\n<code>\njulia> v = [5,3,5,2,3,3,9,0,123]\njulia> setdiff(unique(collect((v)...)),v)\n\
    10-element Array{Int64,1}:\n 0\n 2\n 3\n 5\n 9\n 123\n</code>\nIt uses v... (splat)\
    \ to convert v into a tuple and then calls unique. Collecting the tuple into a\
    \ vector and then calling unique on that vector is slightly faster than calling\
    \ unique on a tuple and then calling unique on the result.\n<|/ a tags=julia dscore=3\
    \ |>\n<| c |>\nThis also seems much faster than the answer by T.Frederic.\n<|/\
    \ c |>\n<| c |>\nThis works and doesn't produce a new array.  `collect` makes\
    \ a copy and `setdiff` makes a copy.\n<|/ c |>\n<| a dscore=3 |>\nA slightly more\
    \ efficient solution is to use the BitArray type to store a vector of Bools. \n\
    <code>\nusing BenchmarkTools", "    unique=unique(l);\n    unique\nend\n\"\"\"\
    Return the first element from a vector\n   \n   ```julia\n   first([1, 2, 3, 4])\
    \ \n   ```\n\"\"\"", "    \n    indices = [i for (i, item) in enumerate(l) if\
    \ item != 0]\n    unique_indices = unique(indices)\n    unique_indices = [item\
    \ for item in unique_indices ]\n    unique_indices.sort!(function(a,b) -> a <\
    \ b ? true : a > b ? false : a == b ? false : a<b)\n    return unique_indices\n\
    end\n    ", "    if length(l) <= 1\n        l\n    else\n        sort!(unique(l))\n\
    \    end\nend\n</cell>\n<code language=julia-1.4>\n\"\"\"Return sorted unique\
    \ elements in a matrix\n>>> unique([\n    ... [[1, 1], [1, 1]],\n    ... [[1,\
    \ 2], [2, 2]]\n    ... ])\n    [[1, 1], [1, 2], \n     [2, 2]]\n\"\"\"", "   \
    \ unique = Vector{Int64}([])\n    sorted = sort(l)\n    while sorted != unique(sorted)\n\
    \        push!(unique,pop!(sorted))\n    end\n    return unique\nend", "    a\
    \ = sort(l)\n    uniq = Set()\n    for x in a\n        !in(a,uniq) && push!(uniq,x)\n\
    \    end\n    return uniq\nend\n</code>\nAnd an example to test\n<code>\njulia>\
    \ unique([5,3,5,2,3,9,0,123])\n0-based indexing [1:12]\n  1.0:  5\n  2.0:  3\n\
    \  3.0:  2\n  4.0:  9\n  5.0:  0\n  6.0:  3\n  7.0:  5\n  8.0:  3\n  9.0:  9\n\
    \ 10.0:  0\n 11.0:  123\n 12.0:  5\n</code>\n<|/ a dscore=2 tags=julia |>\n<|\
    \ a dscore=2 |>\nThe most efficient algorithm for finding unique elements is called\
    \ counting sort and has a complexity of O(n+k) where n is the number of elements\
    \ and k is the number of different elements seen in a given run.\nIn Julia, we\
    \ have the function sorting.count:\n<code>\njulia> using Enumerate, DataFrames",
  "    \"\"\"\n    Return a sorted unique vector\n    \"\"\"\n    unique = []\n  \
    \  unique_map = {}\n    \n    for x in l \n        if unique_map[x] == nil \n\
    \            unique.append(x) \n            unique_map[x] = 1 \n        else \n\
    \            unique_map[x] = unique_map[x] + 1 \n    \n    unique\nend", "   \
    \  s = Set()\n     for n in l\n       if !haskey(s, n)\n         push!(s, n)\n\
    \       end\n     end\n     return s\n end\n</code>\nThe output is\n<code>\njulia>\
    \ unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n10-element Array{Int64,1}:\n 0\n 1\n\
    \ 2\n 3\n 5\n 9\n 123\n</code>\n<|/ a tags=julia |>\n<| c |>\nI added an edit\
    \ about why I prefer this solution.\n<|/ c |>\n<| c |>\nI updated my answer. My\
    \ solution also works but I wanted to show how to implement `unique` using other\
    \ libraries.\n<|/ c |>\n<| a tags=julia |>\nIn your case you can use the combinations\
    \ function from the itertools package:\n<code>\njulia> using itertools, Base.Iterators:\
    \ combinations(1:10)\njulia> combinations(1:10)\n10-element Array{Tuple{Int64,Int64},1}:\n\
    \ (1, 1)\n (1, 2)\n (1, 3)\n (1, 4)\n (1, 5)\n (1, 6)\n (1, 7)\n (1, 8)\n (1,\
    \ 9)\n (1, 10)\n (2, 1)\n (2, 2)\n (2, 3)\n (2, 4)\n (2, 5)\n (2, 6)\n (2, 7)\n\
    \ (2, 8)\n (2, 9)\n (2, 10)\n (3, 1)\n (3, 2)\n (3, 3)\n (3, 4)\n (3, 5)\n (3,\
    \ 6)\n (3, 7)\n (3, 8)\n (3, 9)\n (3, 10)\n (4, 1)\n (4, 2)\n (4, 3)\n (4, 4)\n\
    \ (4, 5)\n (4, 6)\n (4, 7)\n (4, 8)\n (4, 9)\n (4, 10)\n (5, 1)\n (5, 2)\n (5,\
    \ 3)\n (5, 4)\n (5, 5)\n (5, 6)\n (5, 7)\n (5, 8)\n (5, 9)\n (5, 10)\n (6, 1)\n\
    \ (6, 2)\n (6, 3)\n (6, 4)\n (6, 5)\n (6, 6)\n (6, 7)\n (6, 8)\n (6, 9)\n (6,\
    \ 10)\n (7, 1)\n (7, 2)\n (7, 3)\n (7, 4)\n (7, 5)\n (7, 6)\n (7, 7)\n (7, 8)\n\
    \ (7, 9)\n (7, 10)\n (8, 1)\n (8, 2)\n (8, 3)\n (8, 4)\n (8, 5)\n (8, ", "   \
    \ non_unique = Vector{Int64}()\n    unique_count = 0\n    for elt in l\n     \
    \   if !contains(non_unique, elt)\n            non_unique = append(non_unique,\
    \ elt)\n            unique_count += 1\n        end\n    end\n    unique\nend",
  "    unique_vals = collect(Iterators.unique(Vector{Int64}(l)))\n    return unique_vals[unique_vals]\n\
    end", "    seen = Set()\n    uniques = Vector{Int64}()\n    for x in l \n    \
    \    if !isin(seen, x)\n            push!(uniques, x) \n            push!(seen,\
    \ x)\n        end\n    end\n    return uniques\nend\n</code>\n<|/ a |>\n<| c |>\n\
    I guess you misunderstood the question, I'm looking for the unique elements not\
    \ how many unique elements are there in a vector\n<|/ c |>\n<| c |>\nI updated\
    \ my answer with a more efficient solution\n<|/ c |>\n<| c |>\nYour new solution\
    \ is much faster than my code!\n<|/ c |>\n<| a |>\nIf you're looking for a more\
    \ idiomatic Julia solution, you can use ntuple:\n<code>\njulia> ntuple(x -> x,\
    \ 1)([1,4,7,2,2,1])\n(1,2,3,4)\n</code>\nThe first argument to the ntuple function\
    \ creates a 1-tuple with one element and returns it. The second argument specifies\
    \ the number of elements in the tuple to be created, so here it specifies 1.\n\
    <|/ a dscore=4 tags=julia |>\n<| a tags=julia |>\nIn addition to the previous\
    \ answers, you can also use the ntuples function:\n<code>\njulia> ntuples(1)([1,4,7,2,2,1])\n\
    (1,2,3,4)\n</code>\n<|/ a dscore=3 |>\n<| a dscore=2 |>\nHere's another one using\
    \ reduce, that also uses isin to remove the duplicates:\n<code>\nreduce(isin,\
    \ (collect(x) for x=(1:3)...))\n</code>\n<|/ a tags=julia |>\n<| c |>\nThis doesn't\
    \ work if `x` is a vector and `x` contains duplicates.\n<|/ c |>\n<| c |>\nThe\
    \ question states that x is an `Int64`, which should only contain unique values.\
    \ If the array contains duplicates, then they can be removed prior to calling\
    \ `isin`.\n<|/ c |>\n<| c |>\nThe issue is still with the `collect(x)` call. The\
    \ question says \"in a vector\". It should probably say \"in a vector, sorted\
    \ or unsorted\".\n<|/ c |>\n<| c |>\nI guess you misunderstood the question, I'm\
    \ looking for the unique elements not how many unique elements are there in a\
    \ vector\n<|/ c |>\n<| c |>\nAh, I see... Well, then, your question is somewhat\
    \ unclear. You're not asking how to find unique elements in a vector, but rather\
    \ how to find the number of unique elements in a vector. You're going to have\
    \ to clarify what you really ", "    uniques = Vector{Int64}(length(unique(sort(l))))\n\
    \    append!(uniques, sort(l))\n    uniques\nend\n</cell>\n<code language=julia-1.5>\n\
    ## @doc unique", "    u = zeros(0)\n    for x in l\n        if unique(u) == 0\
    \ \n            push!(u,x)\n        else\n            break\n        end\n   \
    \ end\n    u\nend\n</cell>\n<text>\nNow we can compare the runtime of both solutions\
    \ by testing the solutions on random data", "\tvset = Set{Int64}()\n\tfor i in\
    \ l\n\t\tvset.add(i)\n\tend\n\tl = Vector{Int64}()\n\tfor x in vset\n\t\tpush!(l,\
    \ x)\n\tend\n\treturn l\nend", "    return Vector{Int64}(filter(!$in, $(sort(l))))\n\
    end", "    if length(l) == 0 \n        return [] \n    uniques := Set{Int64}()\
    \ \n    for x in l \n        if x not in uniques \n            push!(uniques,\
    \ x) \n        else \n            delete!(uniques, x) \n    uniques \nend", " \
    \   return sort(l)\nend\n\"\"\"\nReturn sorted unique elements in a matrix\n\"\
    \"\"", "    \n    @assert length(l)>0\n    n = length(l)\n    aux = Vector{Int64}(undef,\
    \ n)\n    \n    for i in 1:n\n        aux[findall(x -> x == l[i], aux)[i]] = l[i]\n\
    \    end", "    return setdiff(1:size(l), collect(unique(l))) \nend\n</code>\n\
    The same is true for other types. And you can always implement a more specialized\
    \ version for your types.\n<code>", "    unique!(l,[],set())\n    return l\nend",
  "    seen = Set()\n    seen_add = seen.add\n    unique = Set()\n    for x in l\n\
    \        if x not in seen and seen_add(x) == false \n            unique += [x]\n\
    \            seen.add(x)\n        end\n    end\n    unique\nend\n</code>\n<|/\
    \ a tags=julia dscore=1 |>\n<| a tags=julia dscore=1 |>\nThis is pretty similar\
    \ to's answer but uses a functional approach:\n<code>\njulia> function unique_every(xs)\n\
    \           seen = set()\n           return filter(x -> x \u2209 seen && push!(seen,\
    \ x), xs)\n       end", "  local counts = Vector{Int64}(Int64[], l)\n  for k in\
    \ unique_indices(l)\n    counts[k] = counts[k] + 1\n  end\n  return unique_values(counts,\
    \ l)\nend", "    if l == [] \n        return l\n    end\n    seen = Set{Int64}()\n\
    \    for x in l \n        if !seen[x] \n            seen[x] = true\n         \
    \   push!(seen, x)\n        end\n    end\n    return collect(seen)\nend\nunique(l::Vector{Int64})::Vector{Int64}\n\
    \    return unique(l)\nend", "    \"\"\"Return unique elements in l\"\"\"\n  \
    \  \n    uniqueset = Set()\n    for e in l \n        uniqueset[e] = true\n   \
    \ end\n    return uniqueset.value\nend\n</cell>\n<text>\nThe set type is like\
    \ a set, but unlike sets, it can only contain unique elements. For example, the\
    \ following code is an error"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
