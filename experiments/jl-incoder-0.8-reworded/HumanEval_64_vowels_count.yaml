name: HumanEval_64_vowels_count
language: jl
prompt: "\"\"\"Write a function vowels_count which takes a string representing\n \
  \   a word as input and returns the number of vowels in the string.\n    Vowels\
  \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but\
  \ only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"\
  abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\nfunction vowels_count(s::String)::Int64\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = vowels_count;\n\t@test(candidate(\"\
  abcde\") == 2)\n\t@test(candidate(\"Alone\") == 3)\n\t@test(candidate(\"key\") ==\
  \ 2)\n\t@test(candidate(\"bye\") == 1)\n\t@test(candidate(\"keY\") == 2)\n\t@test(candidate(\"\
  bYe\") == 1)\n\t@test(candidate(\"ACEDY\") == 3)\nend\n"
completions: ["    if s == \"\" then 0 else count(\"aeiou\", s)\n    ", "\"\"\"\n\
    \    vowels_count(s) = sum(is_vowel(c) for c in s)\n\"\"\"", "    | s == \"\"\
    \ = error \"string can't be empty\"\n    | s == \"y\" = error \"string contains\
    \ 'y'; vowel should not be counted\"\n    | otherwise = count_vowels(s,0,false)\n\
    where\ncount_vowels(s::String,i,is_vowel::Bool)::Int64\n    | i == s.length  \
    \  = 0\n    | i <- 0 .. s.length - 1\n    = if s[i] == 'y' \n       then if is_vowel\n\
    \              then count_vowels(s,i+1,true)\n              else count_vowels(s,i+1,false)\n\
    \       else if is_vowel\n              then count_vowels(s,i+1,true)\n      \
    \        else count_vowels(s,i+1,false)\n    | otherwise\n    = if s[i] == 'y'\
    \ \n       then count_vowels(s,i+1,false)\n       else count_vowels(s,i+1,true)\n\
    \    where\n    is_vowel::Bool\n        = if s[i] == 'a' || s[i] == 'e' || s[i]\
    \ == 'i' || s[i] == 'o' || s[i] == 'u'\n              then true\n            \
    \  else false\n\"\"\"", "|\n\"\"\"\n    vowels_count(s) = count(vowels('a'), s)\n\
    \    vowels_count(s) = count(vowels('e'), s)\n    vowels_count(s) = count(vowels('i'),\
    \ s)\n    vowels_count(s) = count(vowels('o'), s)\n    vowels_count(s) = count(vowels('u'),\
    \ s)\n    vowels_count(s)\nend\n</code>\n<code>", "    if vowel_counts(s)==0 then\
    \ 0 else vowel_counts(s)/length(s) end\n    \n\"\"\"Write a function that takes\
    \ a string as a parameter and returns\na boolean value indicating if the string\
    \ contains the letter 'a'.", "\"\"\"count vowels\"\"\"\n    return s.count{|w|\
    \ vowels_count(w)}\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nIt looks like you\
    \ are writing in Julia rather than Erlang. Is this intentional?\n<|/ c |>\n<|\
    \ c |>\nIt isn't. This is Julia code. Notice the `end` and also the indentation.\
    \ The code is being run in a REPL with `@noprofile`. I'm surprised you asked about\
    \ Erlang when you wrote the answer.\n<|/ c |>\n<| c |>\nSorry about that, I didn't\
    \ realize that. Thanks for clarifying.\n<|/ c |>\n<| c |>\nI've added an example\
    \ in the answer that demonstrates how you might write this in Julia, but the answer\
    \ is not wrong, I just thought it would be helpful to show a Julia implementation\
    \ of a recursive function.\n<|/ c |>\n<| c |>\nIt would really help if you made\
    \ that example a bit easier to understand by writing a recursive function instead\
    \ of using String comprehensions. And then you could show how the recursive function\
    \ would work with String comprehensions, and how the recursive function would\
    \ work with your solution.\n<|/ c |>\n<| a tags=ocaml,python,erlang,recursion\
    \ |>\nYou can try this in Python:\n<code>\ndef countVowels(string):\n  return\
    \ string.count(\"a\")+string.count(\"e\")+string.count(\"i\")+string.count(\"\
    o\")+string.count(\"u\")\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis solution returns\
    \ incorrect results for strings with spaces.\n<|/ c |>\n<| c |>\nThe other solutions\
    \ do not work for strings with spaces.\n<|/ c |>\n<| c |>\nYeah, I forgot to mention\
    \ that.\n<|/ c |>\n<| a dscore=0 |>\nHere's a solution in Python:\n<code>\ndef\
    \ vowels_count(s):\n    if s == '':\n        return 0\n    vowels = {'a','e','i','o','u'}\n\
    \    count = 0\n    for char in s:\n        if char in vowels:\n            count\
    \ += 1\n    count += 1\n    return count\n</code>\nThe idea is to count all the\
    \ vowels first and then count all the remaining characters. I hope that's helpful\
    \ :)\n<|/ a tags=ocaml,python,erlang,recursion |>\n<| c |>\nThis solution returns\
    \ incorrect results for strings with spaces.\n<|/ c |>\n<| c |>\nYes, that's true,\
    \ but that's not ", "    if s == \"y\" or s == \"Y\"\n        return 0\n    vowels_arr::Array{Char,1}\
    \ = [ 'a', 'e', 'i', 'o', 'u', 'y']\n    count = 0\n    for i in s\n        for\
    \ j in vowels_arr\n            if i == j\n                count += 1\n       \
    \         break\n    end\n    return count", "    # Initialize a variable called\
    \ vowels_count to zero.\n    vowels_count := 0\n    # Iterate over every character\
    \ in the string.\n    for x in s\n        do if x in['a'..'z']\n            then\
    \ vowels_count := vowels_count + 1\n            elseif x in['e'..'z']\n      \
    \      then vowels_count := vowels_count + 1\n            elseif x in['o'..'z']\n\
    \            then vowels_count := vowels_count + 1\n            elseif x in['u'..'z']\n\
    \            then vowels_count := vowels_count + 1\n            elseif x in['0'..'9']\n\
    \            then vowels_count := vowels_count + 1\n            else\n       \
    \     vowels_count := vowels_count + 1\n        end\n    end\n    return vowels_count",
  "    count = 0\n    for c in s\n        if c == 'a' || c == 'e' || c == 'i' || c\
    \ == 'o' || c == 'u'\n            count += 1\n        else\n            break\n\
    \    return count", "    \"\"\"\n    Declare and implement the function vowels_count.\n\
    \    \"\"\"", "    if s == \"\" then return 0\n    let l = s.length\n    for i\
    \ = 2 to l do\n        if s.substring(i, (i+1)) == vowels('y') then return i\n\
    \    return l\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThe last for loop will never\
    \ terminate because of the if statement that looks for y's at the end. Also, don't\
    \ forget to add the case for empty strings.\n<|/ c |>\n<| c |>\nSorry, I didn't\
    \ even see that last `if`, thanks! I did fix my `vowels_count` function.\n<|/\
    \ c |>\n<| c |>\nAlso, it's very un-idiomatic to iterate from `2` to `l-1`. I'd\
    \ use `for i = 2 to l`.\n<|/ c |>\n<| c |>\n: I know, I like your way of thinking\
    \ about it. But the algorithm is really easy to read and understand. I just went\
    \ for the most idiomatic way to solve the problem.\n<|/ c |>\n<| c |>\n: That's\
    \ why I wrote this answer. :-)\n<|/ c |>\n<| a dscore=1 tags=ocaml,functional-programming\
    \ |>\nMy solution:\n<code>\nlet vowels str = String.sub str 0 ((String.length\
    \ str) -1) in\nlet rec count str n =\n  if String.length str > n then\n    0\n\
    \  else\n    let a = String.sub str 0 n in\n    let b = String.sub str (String.length\
    \ str - n) n in\n    if (vowels a = \"a\") then (count b n + 1)\n    else if (vowels\
    \ a = \"e\") then (count b n + 1)\n    else if (vowels a = \"i\") then (count\
    \ b n + 1)\n    else if (vowels a = \"o\") then (count b n + 1)\n    else if (vowels\
    \ a = \"u\") then (count b n + 1)\n    else\n      (count b n)\nin\ncount \"aaaa\"\
    \ 1\n</code>\n<|/ a |>\n<| a |>\nThis is my solution:\n<code>\nlet vowels str\
    \ = String.sub str 0 ((String.length str) -1) in", "    \"\"\"\n    vowels_count(String)::Int64",
  "    vowels = \"aeiouAEIOU\"\n    vowel_count = 0\n    for i in vowels\n       \
    \ if s.contains(i)\n            vowel_count += 1\n    return vowel_count\n</code>\n\
    My solution\nI wanted to know which solution is fastest. My solution is the one\
    \ above because I wrote it in Julia.\nI decided to compare the two solutions I\
    \ had. The code I used was this one:\n<code>", '    return sum(s.elems("aeiouAEIOU"))',
  "    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count=0\n    for i in s\n        if\
    \ i in vowels\n            count +=1\n        end\n    end\n    return count\n\
    end\n</cell>\n<code language=julia-0.4>\nusing Test\n@test vowels_count(\"abcde\"\
    ) == 2\n@test vowels_count(\"ACEDY\") == 3\n@test vowels_count(\"abxd\") == 3\n\
    </cell>\n<text>\nThe next function count_vowels in Julia is almost the same as\
    \ the one in Python.  It works with strings of any length and is very similar\
    \ to the code we wrote in Python.  However, the Julia version has three major\
    \ changes:", "    vowels = \"aieou\"\n    vowel_count = 0\n    for c in s\n  \
    \      if c in vowels\n            vowel_count = vowel_count + 1\n        else\n\
    \            break\n    end\n    return vowel_count\nend\n</cell>\n<code language=julia-1.5>",
  "    lets=sort(s)\n    if ends_with? lets,\"y\" \n        lets=lets.drop(1)\n  \
    \  end\n    vowels= [\"a\",\"e\",\"i\",\"o\",\"u\",\"y\"]\n    lets.each_index{|i|\n\
    \        if !vowels[i]\n            vowels[i]=1\n        end\n    }\n    vowels.count\n\
    end\n</code>\n<|/ a |>\n<| a tags=string,algorithm,ruby |>\nHere's another one:\n\
    <code>\ndef count_vowels(str)\n  vowels = ['a', 'e', 'i', 'o', 'u']\n  str.gsub(/[aeiou]*/).count{\
    \ |c| vowels.include?(c) }\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nYes, that's\
    \ what I was thinking of. I thought it might be more elegant, but I'm still trying\
    \ to think of why you'd want to do that.\n<|/ c |>\n<| c |>\nIt could be used\
    \ to count word occurrences in the body of a text file. Perhaps that's one reason\
    \ :)\n<|/ c |>\n<| c |>\nJust a nitpick: `str.gsub(/[aeiou]*/)` could be written\
    \ as `str.gsub(/[aeiou]/)`\n<|/ c |>\n<| c |>\nThat's true. `[aeiou]*` means *zero\
    \ or more* occurrences of `aeiou`. I'm surprised that `[aeiou]` means *one or\
    \ more* occurrences, though. Perhaps it's something to do with how it works in\
    \ C? `[aeiou]` means *any single letter in that range*. Or perhaps the regex is\
    \ getting remembered by the Ruby engine since `/[aeiou]*/` is the same as the\
    \ regex `/[aeiou]/`?\n<|/ c |>\n<| c |>\nI don't really know. I don't know ruby.\n\
    <|/ c |>\n<| a |>\nRuby\n<code>\n\"ruby has elephants\".gsub(/[aeiouy]/,'').count\n\
    </code>\n<|/ a tags=string,algorithm,ruby dscore=3 |>\n<| c |>\nThis is nice as\
    \ it's one-liner and easy to understand. But does it handle the case when string\
    \ is empty? I thought it will, but I'm not sure...\n<|/ c |>\n<| c |>\nYes, it\
    \ works also when the string is empty. Empty strings are falsy values in ruby.\n\
    <|/ c |>\n<| c ", "    vowels='aieouy' \n    for word in split(s) do \n      \
    \  match word[-1] do \n            'a' | \n            'e' | \n            'i'\
    \ | \n            'o' | \n            'u' | \n            'y' -> return 1\n  \
    \          _ -> return 0 \n        end\n    end\n    return 0\nend\n</cell>\n\
    <code language=julia-1.3>\n# Testing the function", "    | vowels_count(\"\")\
    \ = 0\n    | vowels_count(s) = if substring(s,length(s)-1,length(s)) == \"\" then\
    \ 0 else 1 + vowels_count(substring(s,0,length(s)))\n    | otherwise = vowels_count(substring(s,0,length(s)))\n\
    </code>\n<|/ a tags=haskell |>\n<| c |>\nI guess you meant `length (tail s)` in\
    \ the second case. Also, note that `length (tail s)` is O(n) which is not ideal.\n\
    <|/ c |>\n<| c |>\nYes I meant `length (tail s)`, thanks for the correction. In\
    \ the second case I used `tail` from [Data.List](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-List.html#v:tail).\
    \ `Data.List.tail` has linear complexity, but `Data.String.tail` has linear complexity\
    \ O(n) so it is not so bad.\n<|/ c |>\n<| c |>\nSorry, I meant `length (tail s)`.\
    \ And no, `Data.List.tail` is linear complexity; it is a strictly increasing function.\
    \ The Haskell prelude defines it to be O(n) for lists. Strictly increasing functions\
    \ require that the functions are strict and non-strict in both arguments and return\
    \ types, which is in general not true.\n<|/ c |>\n<| c |>\nOh, I see. Well, I\
    \ did read about `tail` from [Data.List](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-List.html#v:tail),\
    \ so it is still linear, but `Data.String.tail` has linear complexity `O(n)`,\
    \ so it is better. Thanks for pointing it out.\n<|/ c |>\n<| a dscore=3 tags=haskell\
    \ |>\nYou could use something like this (I changed vowels_count to return the\
    \ count rather than printing):\n<code>\nvowels_count :: String -> Int\nvowels_count\
    \ \"\" = 0\nvowels_count str = let (x,_) = span (/='a' || /='e' || /='i' || /='o'\
    \ || /='u') str in x + vowels_count (drop (length str) x)\n</code>\nOr if you\
    \ prefer more compact code (but probably less efficient code) you could write\
    \ it like this:\n<code>\nvowels_count :: String -> Int\nvowels_count \"\" = 0\n\
    vowels_count str = length str + vowels_count (drop (length str) str)\n</code>\n\
    <|/ a |>\n<| a |>\nYou can ", "    | if vowel_check (c) then 1 else 0 end\n  \
    \  | in count_chars(s)", "\"\"\"Write a function vowels_count(s::String)::Int64\n\
    \    where s is a string representing a word.\n    vowels in this case are 'a',\
    \ 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the\
    \ end of the given word.\n\"\"\"", "\"\"\"Return the number of vowels in s. \n\
    The vowels are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\nvowel, but only when\
    \ it is at the end of the given word.", "    vowels = [\"a\", \"e\", \"i\", \"\
    o\", \"u\"]\n    vowels_count = 0\n    for i in vowels\n        if i == s[end\
    \ -1]\n            vowels_count +=1\n    return vowels_count\nend\n</cell>\n<code\
    \ language=julia-1.0>\nvowels_count \"ACEDY\"\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"Write a function count_vowels which takes a string representing\na word\
    \ as input and returns the number of vowels \n\"\"\"", "    if is_empty(s)\n \
    \       return 0\n    else\n        # Initialize count as zero\n        count\
    \ = 0\n        # Iterate over all characters in the string\n        for i in s\n\
    \            if is_vowel(i)\n                count += 1\n        \n        return\
    \ count\nend", "    vowels = \"aououaeiou\"\n    vowel_count = 0\n    for w in\
    \ lowercase(s) {\n        if w == w || w in vowels\n            vowel_count =\
    \ vowel_count + 1\n        else if w in uppercase(s) {\n            if w in vowels\
    \ {\n                vowel_count = vowel_count + 1\n            }\n        }\n\
    \    }\n    vowel_count\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=1 tags=julia\
    \ |>\nA simple solution would be:\n<code>", "  | (s = <>(\"\"),\n     let vowels\
    \ = \"AEIOUYAEIOUY\"\n     in\n       let n = 0\n       for c in s do\n      \
    \     if c in vowels then n += 2\n           elseif c <> \"Y\" then n += 1 \n\
    \           else ()\n       n\n     end\n   )\n  | (let vowels_count(\"AEIOUY\"\
    ),\n     let vowels = \"AEIOUYAEIOUY\"\n     in\n       let n = 0\n       for\
    \ c in s do\n           if c in vowels then n += 2\n           elseif c <> \"\
    Y\" then n += 1 \n           else ()\n       n\n     end\n   )", "    \"\"\"Write\
    \ a function vowels_count which takes a string representing\n    a word as input\
    \ and returns the number of vowels in the string.\n    Vowels in this case are\
    \ 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is\
    \ at the end of the given word.", "    vowels <- ['a','e','i','o','u']\n    count\
    \ <- 0\n    length <- length(s)\n    position <- 1\n    for position < length\n\
    \        for vowel in vowels\n            if s[position] == vowel\n          \
    \      count += 1\n            position += 1\n    return count\nend \n</cell>\n\
    <code language=julia-1.5>\nvowels_count(\"aecto\")\n</cell>\n<code language=julia-1.5>\n\
    vowels_count(\"a\")\n</cell>\n<text>\nExercises", "| s = \"\" \n| let rec vowels_count\
    \ (n::Int64) (v::Char) = (n == 0 || n == 1) ? (v == \"u\" ? ((n-1) * v) : n) :\
    \ vowels_count (n-1) ((v == \"u\") ? \"u\" : v)", "    | s == \"a\" || s == \"\
    e\" || s == \"i\" || s == \"o\" || s == \"u\" |\n      s == \"y\" ||  s == \"\
    A\" || s == \"E\" || s == \"I\" || s == \"O\" || s == \"U\" |\n      s == \"Y\"\
    \n    | otherwise = vowels_count(s[1:])\n</code>\nThen you can count all vowels:\n\
    <code>", "\"\"\"\n\"\"\"\nWrite a function vowel_count which takes a string representing\n\
    \    a word as input and returns the number of vowels in the string.\n    Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but\
    \ only when it is at the end of the given word.", "    return (s.count(\"a\")+s.count(\"\
    e\")+s.count(\"i\")+s.count(\"o\")+s.count(\"u\"))\nend", "  | (s,\"\") = 0\n\
    \  | vowels_count(head::String)::Int64 \n  | vowels_count(head,tail)::Int64 \n\
    \  | (head == \"y\" && tail == \"\") = 1\n  | (head == \"y\" && tail == \"y\"\
    ) = 1\n  | (head == \"y\" && tail != \"\") = 1\n  | (head != \"y\" && head ==\
    \ tail) = 0\n  | (head != \"y\" && head != tail) = 1\n  | (head == \"y\" && tail\
    \ != \"y\") = 1\n  | head == \"a\" = 1\n  | head == \"e\" = 1\n  | head == \"\
    i\" = 1\n  | head == \"o\" = 1\n  | head == \"u\" = 1\n  | head == \"y\" = 1\n\
    \  | head != \"y\" =  vowels_count(tail)\n  | head != \"y\" =  1\n  | head ==\
    \ \"y\" =  vowels_count(tail)\n  | head == \"y\" =  1\n  | head != head =  vowels_count(tail)\n\
    \  | head != head =  1\n  | head == tail =  vowels_count(tail)\n  | head == tail\
    \ =  1\n  | head != tail =  vowels_count(tail)\n  | head != tail =  1\n  | head\
    \ != head != tail =  vowels_count(tail)\n  | head != head != tail =  1\n  | head\
    \ == head != tail =  vowels_count(tail)\n  | head == head != tail =  1\n  | head\
    \ == head != head != tail =  vowels_count(tail)\n  | head == head != head != tail\
    \ =  1\n  | head == head != head != head != tail =  vowels_count(tail)\n  | head\
    \ == head != head != head != tail =  1\n  | head == head != head != head != head\
    \ != tail =  vowels_count(tail)\n  | head == head != head != head != head != head\
    \ != tail =  1\n  | head == head != head != head != head != head != head != tail\
    \ =  vowels_count(tail)\n  | head == head != head != head != head != head != head\
    \ != head != tail =  1\n  | head == head != head != head != head != head != head\
    \ != head != head != tail =  vowels_count(tail)\n  | head == head != head != head\
    \ != head != head != head != head != head != head != tail =  1\n  | head == head\
    \ != head != head != head != head != head != head != head != head != head != tail\
    \ =  vowels_count(tail)", "| s.length == 0 = 0\n| true = vowels_count(s[1:])\n\
    | false = vowels_count(s[0, 1])\n    | \n</code>\n<|/ a |>\n<| c |>\nThe first\
    \ version is not working. In the last line of the second version I get a syntax\
    \ error.\n<|/ c |>\n<| a tags=ocaml,recursion |>\nHere are some examples of recursive\
    \ algorithms using OCaml:", "    vowels_count_result <- 0\n    for vowel in vowels\
    \ {\n        vowels_count_result <- vowels_count_result + (s == vowel)\n    }\n\
    \    return(vowels_count_result)\nend\n</code>\nTests:\n<code>\n# test 1\ntest_1_result\
    \ <- vowels_count(test_1)\nprintln(test_1_result)\n# test 2\ntest_2_result <-\
    \ vowels_count(test_2)\nprintln(test_2_result)\n# test 3\ntest_3_result <- vowels_count(test_3)\n\
    println(test_3_result)\n</code>\nOutput:\n<code>\n2\n2\n1\n</code>\nNote: This\
    \ solution might not be the most efficient one, but it is simple and easy to understand.\n\
    <|/ a tags=haskell,string dscore=0 |>\n<| c |>\nCan you please tell what is the\
    \ difference between this solution and `count x 'a'`?\n<|/ c |>\n<| c |>\nIn this\
    \ case `count x 'a'` will iterate over the whole list and compare each element\
    \ with the `'a'` letter. In my answer, only the `vowels` list will be iterated\
    \ over and the `vowels_count_result` variable will contain how many vowels occur\
    \ in `x`. The `vowels_count` function is more efficient as it only compares elements\
    \ from the `vowels` list.\n<|/ c |>\n<| c |>\nSo, if I understood correctly, the\
    \ difference between the two solutions is that one iterates over the whole list\
    \ while the other iterates only over the first 10 elements of the list?\n<|/ c\
    \ |>\n<| c |>\nYes, exactly. You are right about iterating over the whole list.\
    \ Another difference is that the `vowels_count_result` variable will contain how\
    \ many vowels occur in `x`. I will edit the answer to add this.\n<|/ c |>\n<|\
    \ c |>\nYes, exactly as you said. Another advantage of this solution is that it\
    \ is easier to understand and more efficient (I think).\n<|/ c |>\n<| a dscore=0\
    \ tags=haskell,string |>\n<code>\nvowels :: String -> [Char]\nvowels (x:xs) =\
    \ filter (==x) ['a':'z'] : vowels xs\nvowels [] = []\n</code>\n<|/ a |>\n<| a\
    \ |>\nThe simplest solution I can think of is:\n<code>\nvowels :: String -> Int\n\
    vowels xs = length $ filter (\\ch -> ch == 'a' || ch == 'e' || ch == 'i' || ch\
    \ == 'o' || ch == 'u') xs\n</code>\n<|/ a ", "    if is_empty(s), return 0\n \
    \   letter::Char = first(s)\n    vowels::Set[Char] = ['a','e','i','o','u']\n \
    \   if is_vowel(letter)\n       if letter != last(s) // 'a' // 'e' // 'i' // 'o'\
    \ // 'u'\n           return 0\n       else\n           return 1\n    end\n   \
    \ return 0\nend\n</cell>\n<cell>\nvowels_count(\"Aedcba\")\n</cell>\n<text>\n\
    Let's write another function called vowels_count which takes a string\n    and\
    \ a char as input. Vowels is the set of vowels in the string, and ch\n    is the\
    \ char to find. Return the number of vowels in s that are\n    either in the given\
    \ char, or in the given string as a substring.", "    if s.is_empty() \n     \
    \   then 0 else count(filter(_.is_vowel,s)) \n    end\nend\n</cell>\n<code language=julia-0.4>\n\
    vowels_count(\"abcde\")\n</cell>\n<code language=julia-0.4>\nvowels_count(\"ACEDY\"\
    )\n</cell>\n<text>\nWrite a function that takes a string as input and returns\
    \ the string with all the\nnon-vowels removed and all the other charcters replaced\
    \ by the strings \"vowel counterpart\"\nof the vowel. For example, vowel_counter(\"\
    ACEDY\") returns \"aCeDy\".", "    \"\"\"Count the number of vowels in the given\
    \ string\"\"\"\nif s == \"y\" then 0 else (vowels_count(s-1) || vowels_count(s-1))\n\
    </code>\n<|/ a tags=scala,string,pattern-matching,recursion |>\n<| c |>\nThanks\
    \ for your input. However, the question wants the solution using `recursion`.\n\
    <|/ c |>\n<| c |>\nThe first solution should also work but is a bit more verbose\
    \ than the other one. The second one is more clear and it also uses recursion.\n\
    <|/ c |>\n<| c |>\nThe second one is also recursive. However it's using a function\
    \ call in the return statement of the `if` statement.\n<|/ c |>\n<| c |>\nYes,\
    \ I just realized that. Thank you so much. :)\n<|/ c |>\n<| c |>\nYour solution\
    \ also solves the problem and does it without any additional function.\n<|/ c\
    \ |>\n<| a dscore=0 |>\n<code>\ndef vowels(str: String): Int = str.takeWhile(c\
    \ => c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').length +\n  str.takeWhile(c\
    \ => c == 'y').length\n</code>\n<|/ a tags=scala,string,pattern-matching,recursion\
    \ |>\n<| c |>\nWhile this code snippet may solve the question, [including an explanation](http://meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion.\n<|/ c |>\n<| a tags=scala,string,pattern-matching,recursion\
    \ |>\n<code>\ndef vowels(str: String): Int = {\n  def isVowel(c: Char) = {\n \
    \   val lower = c.toLower\n    \"aeiou\".contains(lower) \n  }\n  def recurse(str:\
    \ String, count: Int): Int = {\n    str match {\n      case \"\"   => count\n\
    \      case c => c match {\n        case 'a' => recurse(\"\", count+1)\n     \
    \   case 'e' => recurse(\"\", count+1)\n        case 'i' => recurse(\"\", count+1)\n\
    \        case 'o' => recurse(\"\", count+1)\n        case 'u' => recurse(\"\"\
    , count+1)\n        case 'y' => recurse(\"\", count+1)\n        case _  => recurse(str.tail,\
    \ count+isVowel(c))\n      }\n    }\n    recurse(str, 0)\n  }\n  ", "    vowels\
    \ <- [\"a\",\"e\",\"i\",\"o\",\"u\"]\n    \n    if s==\"y\" then 0 else 1 \n \
    \   \n    for word in split(s,\" \")\n    let count = sum(word in vowels)\n  \
    \  if count==0 then 0 else count\nend # end vowels_count\n</cell>\n<code language=julia-1.2>\n\
    \"\"\"\nWrite a function vowel_counts takes a string representing a word as input\n\
    and returns the number of vowels, consonants, and occurrences of each\nvowel.",
  "  counter=0\n  for i in s \n  if i in 'aeiou' \n  then counter += 1 \n  else \n\
    \  counter += 0 \n  return counter \nend \nprintln(vowels_count(\"a\"))\nprintln(vowels_count(\"\
    aba\"))\nprintln(vowels_count(\"aaba\"))\nprintln(vowels_count(\"uaca\"))\nprintln(vowels_count(\"\
    ab\"))\nprintln(vowels_count(\"ac\"))\nprintln(vowels_count(\"a\"))\nprintln(vowels_count(\"\
    ac\"))\n</cell>\n<code language=julia-1.4>\n#M2 start \n\"\"\"\n# M2 - Problem\
    \ 1\nWrite a function vowel_count which takes a string representing\n    a word\
    \ as input and returns the number of vowels in the string.\n    Vowels in this\
    \ case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when\
    \ it is at the end of the given word.", '"""Count vowels in a string', "    \"\
    \"\"Count the number of vowels in the given string\"\"\"\nreturn sum(map(x in(\"\
    a\", \"e\", \"i\", \"o\", \"u\") -> x == s[end], s))\n\"\"\"Write a function count_vowels\
    \ whose input is a string and returns\nthe amount of words in the given string\
    \ that contain at least one\nvowel. Words are counted consecutively in the string,\
    \ e.g. \"abbc\",\n\"abcabc\", etc. Return the number of words in the string. Here,\
    \ \"word\"\nis a contiguous substring with at least 1 vowel.", "    if is_empty(s)\
    \ {return 0}\n    let chars = split(s, \"\")\n    let vowels = \"aeiou\"\n   \
    \ let vowel_count = filter (\\_ -> vowels == \"aeiou\") chars\n    let count =\
    \ length(vowel_count) + 1\n    return count\nend\n</cell>\n<cell>\n@test vowels_count(\"\
    abcde\") == 2\n@test vowels_count(\"ACEDY\") == 3\n</cell>\n<text>\nVoxels\nGiven\
    \ a point cloud, a voxel has two positions, a position of x and y and a value\
    \ z. We define an adjacency matrix A that represents the adjacency structure of\
    \ the point cloud.", "\"\"\"\n    vowels_count(s) = sum([\n        length(s) .-\
    \ [length(s)[1]] .- [length(s)[1] + 1] .- [length(s)[1] + 2]\n        where\n\
    \        length(s) = if s == \"a\" .+ if s == \"e\" .+ if s == \"i\" .+ if s ==\
    \ \"o\" .+ if s == \"u\"\n            else 0,\n        length(s) .== 3\n    ])\n\
    \"\"\"\n\"\"\"\n    vowels_count(s) = sum(if s == \"a\" .+ if s == \"e\" .+ if\
    \ s == \"i\" .+ if s == \"o\" .+ if s == \"u\"\n            else 0, length(s)\
    \ .== 3)\n\"\"\"\n\"\"\"\n    vowels_count(s) = sum([length(s) - [1]] .- [length(s)\
    \ + [1]])\n\"\"\"\n\"\"\"\n    vowels_count(s) = sum([length(s)] .- [length(s)[1]]\
    \ .- [length(s) + [1]])\n\"\"\"\n\"\"\"\n    vowels_count(s) = length(s) - [1]\n\
    \"\"\"\n\"\"\"\n    vowels_count(s) = length(s) .- [length(s)[1]]\n\"\"\"\n\"\"\
    \"\n    vowels_count(s) = length(s) .- [length(s)[1]] .- [length(s) + [1]]\n\"\
    \"\"\n\"\"\"\n    vowels_count(s) = length(s) .- [length(s)[1]] .- [length(s)\
    \ + [1]] .- [length(s) + [2]]\n\"\"\"\n\"\"\"\n    vowels_count(s) = length(s)\
    \ .- [length(s)[1]] .- [length(s) + [1]] .- [length(s) + [2]] .- [length(s) +\
    \ [3]]\n\"\"\"\n\"\"\"\n    vowels_count(s) = length(s) .- [length(s)[1]] .- [length(s)\
    \ + [1]] .- [length(s) + [2]] .- [length(s) + [3]] .- [length(s) + [4]]\n\"\"\"\
    \n\"\"\"\n    vowels_count(s) = length(s) .- [length(s)[1]] .- [length(s) + [1]]\
    \ .- [length(s) + [2]] .- [length(s) + [3]] .- [length(s) + [4]] .- [length(s)\
    \ + [5]] .- [length(s) + [6]]\n\"\"\"\n\"\"\"\n    vowels_count(s) = length(s)\
    \ .- [length(s)[1]] .- [length(s) + [1]] .- [length(s) + [2]] .- [length(s) +\
    \ [3]] .- [length(s) + [4]] .- [length(s) + ", "\"\"\"\n    Write a function vowel_count\
    \ which takes a string representing\n    a word as input and returns the number\
    \ of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'.\
    \ Here, 'y' is also a\n    vowel, but only when it is at the end of the given\
    \ word.", "\"\"\"\n    # Solution goes here\n    return 0\nend\n</cell>\n<code\
    \ language=julia-1.4>", "   if length(s) == 0\n     return 0\n   end\n   vowels\
    \ <- \"aeiou\"\n   vowels_count0 <- length(filter(vowels, s[end]) == 0)\n   if\
    \ vowels_count0\n     return length(s)/2 # ignore first vowel\n   end\n   vowels_count\
    \ <- length(filter(vowels, s[end]) != 0) - vowels_count0\n   return vowels_count\n\
    end\n</cell>\n<code language=julia-1.5>\n@test vowels_count(\"a\") \u2248 0\n\
    @test vowels_count(\"b\") \u2248 1\n@test vowels_count(\"c\") \u2248 1\n@test\
    \ vowels_count(\"d\") \u2248 2\n@test vowels_count(\"e\") \u2248 1\n@test vowels_count(\"\
    f\") \u2248 0\n@test vowels_count(\"g\") \u2248 0\n@test vowels_count(\"h\") \u2248\
    \ 0\n@test vowels_count(\"i\") \u2248 0\n@test vowels_count(\"j\") \u2248 0\n\
    @test vowels_count(\"k\") \u2248 1\n@test vowels_count(\"l\") \u2248 0\n@test\
    \ vowels_count(\"m\") \u2248 0\n@test vowels_count(\"n\") \u2248 1\n@test vowels_count(\"\
    o\") \u2248 0\n@test vowels_count(\"p\") \u2248 0\n@test vowels_count(\"q\") \u2248\
    \ 0\n@test vowels_count(\"r\") \u2248 0\n@test vowels_count(\"s\") \u2248 0\n\
    @test vowels_count(\"t\") \u2248 0\n@test vowels_count(\"u\") \u2248 0\n@test\
    \ vowels_count(\"v\") \u2248 0\n@test vowels_count(\"w\") \u2248 0\n@test vowels_count(\"\
    x\") \u2248 0\n@test vowels_count(\"y\") \u2248 0\n@test vowels_count(\"z\") \u2248\
    \ 0\n@test vowels_count(\"aa\") \u2248 0\n@test vowels_count(\"ab\") \u2248 1\n\
    @test vowels_count(\"ac\") \u2248 1\n@test vowels_count(\"ad\") \u2248 2\n@test\
    \ vowels_count(\"ae\") \u2248 1\n@test vowels_count(\"af\") \u2248 0\n@test vowels_count(\"\
    ag\") \u2248 0\n@test vowels_count(\"ah\") \u2248 0\n@test vowels_count(\"ai\"\
    ) \u2248 0\n", "    vowels:Set{Char} = ['a', 'e', 'i', 'o', 'u']\n    vowel_count\
    \ = Set.new()\n    for i in s\n        if vowels.contains(i)\n            vowel_count.add(i)\n\
    \    return vowel_count.length\nend\n</cell>\n<cell>\nvowels_count(\"abcde\")\n\
    </cell>\n<cell>\nvowels_count(\"ACEDY\")\n</cell>\n<text>\n(10) The first few\
    \ lines in the file data/first_lines.txt are as follows", "    #Write your code\
    \ here\n    let count_vowels:Int64 = 0\n    for char of s {\n    if char==\"a\"\
    \ || char==\"e\" || char==\"i\" || char==\"o\" || char==\"u\" || char==\"y\" {\n\
    \        count_vowels += 1 \n    }\n}\n    return count_vowels\n</code>\n<|/ a\
    \ |>\n<| a tags=haskell dscore=0 |>\n<code>\nimport Data.List\nvowel_count ::\
    \ String -> Int\nvowel_count str = length $ filter isVowel str\n</code>\n<|/ a\
    \ |>\n<| a tags=haskell |>\n<code>\nimport Data.List\nvowel_count :: String ->\
    \ Int\nvowel_count str = length $ filter isVowel str\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>\nvowel_count :: String -> Int\nvowel_count [] =\
    \ 0\nvowel_count (x:xs) = length $ filter (`elem` \"aeiou\") x\n</code>\n<|/ a\
    \ tags=haskell |>\n<| c |>\n`filter` works with `Bool` not `Char`\n<|/ c |>\n\
    <| c |>\nI changed it to `elem`.\n<|/ c |>\n<| a tags=haskell |>\nAnother solution,\
    \ using foldr to reduce the string to a list, and pattern matching to isolate\
    \ vowels.\n<code>\nvowel :: String -> Int\nvowel = foldr (\\x acc -> if x `elem`\
    \ \"aeiou\" then x:acc else acc) []\n</code>\nfoldr takes two arguments, a function\
    \ and an initial value.\nThe function takes one argument, and that argument is\
    \ the value returned by the function applied to the previous argument.\nThe initial\
    \ value is the empty list. \nSo vowel returns the length of the final list returned\
    \ by foldr. \nThe function applied to each character in the string, uses elem\
    \ to find out if the character is in the set of vowels, returns it if it is, or\
    \ else returns the empty list. \nFinally, the result returned by foldr will be\
    \ the length of the final list - the number of vowels in the original string.\n\
    <|/ a dscore=0 |>\n<| a dscore=0 tags=haskell |>\nAnother solution using Data.List.\n\
    <code>\nvowel :: String -> Int\nvowel str = length $ filter (`elem` \"aeiou\"\
    ) str\n</code>\n<|/ a |>\n<| c |>\nPlease explain why you think this will work.\n\
    <|/ c |>\n<| a dscore=0 tags=haskel", "    vowels = \"aeiouy\"\n    count = 0\n\
    \    for ch in s:\n        if ch in vowels:\n            count += 1\n    return\
    \ count", "    if isvowel(s) return 0 else return 1\n    else if s.length == 0\n\
    \    return 0\n    else if s[s.length - 2] == 'y'\n    then if s[s.length - 1]\
    \ == 'a'\n    or s[s.length - 1] == 'e'\n    or s[s.length - 1] == 'i'\n    or\
    \ s[s.length - 1] == 'o'\n    or s[s.length - 1] == 'u'\n    then 1\n    else\
    \ 0\n    else 0\n    else return vowels_count(s.substring(1, s.length - 1))\n\"\
    \"\"\n    function vowels_count(s::String)::Int64 {\n        if isvowel(s) return\
    \ 0\n        else if s.length == 0\n        return 0\n        else if s[s.length\
    \ - 2] == 'y'\n        then if s[s.length - 1] == 'a'\n        or s[s.length -\
    \ 1] == 'e'\n        or s[s.length - 1] == 'i'\n        or s[s.length - 1] ==\
    \ 'o'\n        or s[s.length - 1] == 'u'\n        then 1\n        else 0\n   \
    \     else return vowels_count(s.substring(1, s.length - 1))\n\"\"\"", "</code>\n\
    <|/ a |>\n<| a dscore=0 tags=ocaml,functional-programming,ocamlfind,ocamlbuild\
    \ |>\nThe \"problem\" with your implementation is that you've defined an explicit\
    \ vowel function, and you've called it (implicitly) with the dot operator.  Here's\
    \ a version that fixes that.  \nNote that this version uses pattern matching;\
    \ there's some interesting tricks going on here.\n<code>\nlet rec vowels word\
    \ =\n    match word with\n    | \"a\" -> 1\n    | \"e\" -> 1\n    | \"i\" -> 1\n\
    \    | \"o\" -> 1\n    | \"u\" -> 1\n    | \"y\" -> 2\n    | _ -> 0\n</code>\n\
    <|/ a |>\n<| c |>\nBut `vowels` now returns `3` for `\"ACEDY\"`.\n<|/ c |>\n<|\
    \ c |>\nTrue.  But I thought that was the intent.\n<|/ c |>\n<| c |>\nNot quite\
    \ -- I think the intent was that `vowels` would return `3` for *any* string, not\
    \ just `\"ACEDY\"`. I would have done it a different way.\n<|/ c |>\n<| c |>\n\
    I agree it wasn't the intent as much as the original code.  I assumed that the\
    \ purpose of the function was to count the vowels in a given word; otherwise I\
    \ would have suggested using pattern matching.\n<|/ c |>\n<| a dscore=0 tags=ocaml,functional-programming,ocamlfind,ocamlbuild\
    \ |>\nHere's an OCaml program that counts the number of vowels in a word, and\
    \ I think it does what you want.\n<code>\nopen Core.Std (Std);;", "    | [] |\
    \ [_] =\n        sum (\n            if isupper(s[0])\n            then 1\n   \
    \         else 0\n            )\n        | count{ x in \"aeiouAEIOU\" }\n    |\
    \ vowels_count(tail(s))\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThank you for taking\
    \ the time to provide such a detailed answer! It will be extremely helpful!\n\
    <|/ c |>\n<| a tags=haskell,functional-programming |>\n<code>\nvowels :: String\
    \ -> [Char]\nvowels = map isUpper\n</code>\n<|/ a dscore=1 |>\n<| c |>\n`vowels\
    \ = filter isUpper`\n<|/ c |>\n<| a dscore=1 |>\nTo answer the original question\
    \ directly, there is a very efficient solution in Haskell:\n<code>\nvowels ::\
    \ String -> Int\nvowels xs | length xs <= 0 = error \"empty string\"\n       \
    \   | otherwise     = sum [x `elem` \"aeiouAEIOU\" | (x,xs) <- zip xs (tail xs)]\n\
    </code>\nThe code above is a variation of William Pursell's answer, which has\
    \ several advantages. First, William Pursel's solution builds up the entire string\
    \ xs and then calls tail xs just once. This is a very inefficient way to do the\
    \ same thing, as the tail xs call has to be repeated for every element of xs.\
    \ Second, William Pursell's solution uses elem to do the same sort of thing: It\
    \ checks whether an element is in one string or another. elem performs a linear\
    \ search of the second argument, one element at a time. As you can see, this solution\
    \ is much more efficient than William's solution. The disadvantage of William's\
    \ solution is that it requires that the second argument be sorted.\nHowever, this\
    \ answer is somewhat tangential. The question also asks why Haskell code does\
    \ not always perform well. The answer has to do with the fact that Haskell is\
    \ lazy, and thus not fully evaluated. In William Pursell's solution, the function\
    \ head is called on the list returned by tail xs just once, because it appears\
    \ on the right-hand side of the list comprehension, rather than being evaluated\
    \ and stored in xs. In William's solution, the head function is called on every\
    \ element of xs, which can be very inefficient. A lazy language avoids this, by\
    \ building up only what is necessary to produce the result for the right-hand\
    \ side of the list comprehension. This is a common optimization called the \"\
    desugaring\" optimization, which is a feature of the ", "    if s.length == 0\
    \ || s.length == 1\n        return 0;\n    if (s[0] == 'a' || s[0] == 'e' || s[0]\
    \ == 'i' || s[0] == 'o' || s[0] == 'u' || s[0] == 'y')\n        return 1;\n  \
    \  else\n        return vowels_count(s[1:]);\nend\n</cell>\n<text>\nExercise 1:\
    \ Count Vowels\nWrite a function that takes as input a string and returns the\
    \ number of vowels in the given string.", "    \"\"\"This function will count\
    \ the number of vowels in a string\"\"\"\n    vowels = \"aeiouy\"\n    count =\
    \ 0\n    for i in s\n        if i in vowels\n            count += 1\n    return\
    \ count", "\"\"\"\nWrite a function count_vowels that takes a string representing\
    \ a word\nas input and returns the number of vowels in the string.\nVowels in\
    \ this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\nvowel, but only\
    \ when it is at the end of the given word.", "    if length(s) <> 0 then \n  \
    \      if substring(s, 0, length(s)) = \"a\" ||\n                            \
    \   substring(s, 0, length(s)) = \"e\" ||\n                               substring(s,\
    \ 0, length(s)) = \"i\" ||\n                               substring(s, 0, length(s))\
    \ = \"o\" ||\n                               substring(s, 0, length(s)) = \"u\"\
    \n           then vowels_count(substring(s, 0, length(s))) + 1\n        else vowels_count(substring(s,\
    \ 0, length(s))) \n    end\n    return 0\nend", "\"\"\"Return a function vowels_count\
    \ which takes a string representing\n    a word as input and returns the number\
    \ of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'.\
    \ Here, 'y' is also a\n    vowel, but only when it is at the end of the given\
    \ word.\n    We recommend writing a function of the form vowels_count(s::String)::Int64\n\
    \    or vowels_count(s:String)::Int64 in order to be consistent with other\n \
    \   functions you write in later questions.\n    Your function should work correctly\
    \ even if s contains no vowels.\n\"\"\"", "    # Your code here\n    vowel_count\
    \ = 0\n    l = s.length\n    for i in 0..length()\n        if isVowel(s[i]) ==\
    \ true\n            vowel_count = vowel_count + 1\n        else\n            vowel_count\
    \ = vowel_count + 0\n    return vowel_count\n    \"\"\"\n    We don't know how\
    \ long the string is, so let's just assume that we\n    will always have some\
    \ vowels in it, and then count them.\n    \"\"\"\n\"\"\"\nExercise 4\nWrite a\
    \ function vowel_count which takes a string representing\n    a word as input\
    \ and returns the number of vowels in the string.\n    Vowels in this case are\
    \ 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is\
    \ at the end of the given word.", "    vowel_count =0\n    for c in s\n      \
    \  if c in ['A','E','I','O','U']\n            vowel_count +=1\n    if vowel_count\
    \ == 0\n        return -1\n    return vowel_count\nend", "    count = 0\n    vowels\
    \ = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    for i in s\n        if i in vowels\n\
    \            count += 1\n        end\n    end\n    return count\nend", "    vowels\
    \ = ['a','e','i','o','u']\n    let mutable count = 0\n    for word in words\n\
    \        for vowel in vowels\n            if vowel in word \n                count\
    \ += 1 \n    return count ", "    | s == \"\"\n        = 1\n    | vowel_count(s,\
    \ \"\")\n        = 1\n    | vowel_count(s, vowel_count(s, \"\")) + 1\n       \
    \ = vowel_count(s, \"\")", "    if s.length < 2 return 0\n    let has_a = countVowel(s,0)\
    \ == 3\n    let has_e = (countVowel(s,1) == 1) || (countVowel(s,1) == 2) && (has_a)\n\
    \    let has_i = (countVowel(s,2) == 1) || (countVowel(s,2) == 2) && (has_e) ||\
    \ (countVowel(s,2) == 3)\n    let has_o = (countVowel(s,3) == 1) || (countVowel(s,3)\
    \ == 2) && (has_i) || (countVowel(s,3) == 3)\n    let has_u = (countVowel(s,4)\
    \ == 1) || (countVowel(s,4) == 2) && (has_o) || (countVowel(s,4) == 3)\n    return\
    \ sum [has_a, has_e, has_i, has_o, has_u]\nend\n</code>\n<|/ a tags=string,julia,performance\
    \ |>\n<| c |>\nIn Julia 0.3, the type signature of `countVowel` was changed, from\
    \ `(a::String, i::Int64)->Int64` to `(a::String, i::Int)->Int`. Thanks for the\
    \ feedback, it is very helpful!\n<|/ c |>\n<| a |>\nThe short answer: use Regexps:\n\
    <code>\njulia> using Regexp", '  |"""vowels_count which takes a string representing
    a word as input and returns the number of vowels in the string.', "\"\"\"\n  \
    \  Given a string, return an integer\n    representing the number of vowels\n\
    \    in the string.\n\"\"\"", '"""Count vowels in a string"""', "    if s in vowel_table\n\
    \        vowel_count := 0\n        for c in s\n            if c in vowel_table\n\
    \                vowel_count := vowel_count + 1\n        return vowel_count\n\
    \    else\n        return 0", "    |\n    |\n    |\n    |\n    |\n    |\n    |\n\
    \    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n\
    \    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n\
    \    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n\
    \    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n\
    \    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n\
    \    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n\
    \    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n\
    \    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n\
    \    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n\
    \    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n\
    \    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n\
    \    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n\
    \    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n\
    \    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n\
    \    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n\
    \    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n\
    \    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n\
    \    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n\
    \    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n\
    \    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n\
    \    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n\
    \    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n    |\n\
    \    |\n    |\n    |\n    |\n    |\n    |\n    |\n", "\"\"\"\n```{note}\nExercise:\n\
    Write a function vowels_count which takes a string representing\n    a word as\
    \ input and returns the number of vowels in the string.\n    Vowels in this case\
    \ are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it\
    \ is at the end of the given word.", "    vowels := ['a','e','i','o','u']\n  \
    \  vowel_counts := Dict{Char, Int64}()\n    for c in s\n        if c in vowels\n\
    \            vowel_counts[c] = vowel_counts.get(c, 0) + 1\n    end\n    return\
    \ sum(vowel_counts.values)\nend\n</cell>\n<code language=julia-1.5>", "\"\"\"\
    Write a function count_chars which takes a string representing\n    a string as\
    \ input and returns the number of characters in the\n    given string. Here, 'y'\
    \ is considered a character and can be anywhere.", "    letters = split(s)\n \
    \   return count(letters, \"a\" .. \"u\")\nend", "| let vowels = \"aeiou\"\n|\
    \ let mut count = 0\n| for c in s\n| if c in vowels\n| then count += 1\n| else\
    \ \n| if c == 'y'\n| then count += 1 \n| else \n| count += 0\n| return count\n\
    \"\"\"\n## Write a function word_count which takes a string representing\n## a\
    \ word as input and returns the number of times the word appears\n## in the string.\
    \ Include words and punctuation as part of the count.", "    # Write your solution\
    \ here\n    return sum([1 for c in s if c in \"aeiouy\"])\n</code>\n<|/ a tags=ocaml,if-statement,functional-programming\
    \ |>\n<| a |>\nFor this simple problem you can just do this:\n<code>\nlet count_vowels(s)\
    \ =\n  let n = String.length s in\n  let rec loop i =\n    if i > n then 0\n \
    \   else match s with\n      | `a when `a` = 'a' -> 1\n      | `a when `a` = 'e'\
    \ -> 1\n      | `a when `a` = 'i' -> 1\n      | `a when `a` = 'o' -> 1\n     \
    \ | `a when `a` = 'u' -> 1\n      | `a -> loop i+1\n      | _ -> loop i\n  in\
    \ loop 0\n</code>\nIt will take more time complexity than your solutions because\
    \ your solution is actually O(n^3) but the above is O(n).\n<|/ a tags=ocaml,if-statement,functional-programming\
    \ dscore=1 |>\n<| c |>\nThank you, this is very helpful. I did have a similar\
    \ solution, but since I'm really new to OCaml, I felt like it might be too advanced\
    \ for me to understand it fully.\n<|/ c |>\n<| a tags=ocaml,if-statement,functional-programming\
    \ |>\nThe question was originally asking about using functional programming, which\
    \ was the subject of the original post. However, a very good answer has already\
    \ been given. I just want to add that you can use List.fold_left to do the same\
    \ thing as your solution using less code:\n<code>\nlet vowels_count s =\n  let\
    \ chars = String.split (match s with `a -> ['a'; 'e'; 'i'; 'o'; 'u'] | `b -> ['b'])\
    \ s in\n  List.fold_left (fun acc char ->\n    if char = 'a' then acc + 1 else\
    \ acc) 0 chars\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nI do not know OCaml,\
    \ but I think you can do something like this:\n<code>\nlet vowels s =\n  let c\
    \ = String.length s in\n  let rec count i =\n    if i >= c then 0\n    else match\
    \ s with\n      | `a when `a` = 'a' -> 1\n      | `a when `a` = 'e' -> 1\n   \
    \   | `a when `a` = 'i' -> 1\n      | ", " \n\"\"\"\n    Write a function count_consonants\
    \ which takes a string representing\n    a word as input and returns the number\
    \ of consonants in the string.\n    Consonants are 'b', 'c', 'd', 'f', 'g', 'h',\
    \ 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't',\n    'v', 'w', 'x', 'z'. 'Y'\
    \ is a consonant, but only when it is at the end of the\n    given string.", " \
    \   s = String.toLower(s)\n    let chars = []\n    for (i, c) in s.chars.enumerated()\
    \ do\n        chars += [c]\n        if c == \" \" then\n            let j = i\
    \ - 1\n            while j >= 0 do\n                chars += [s[j]]\n        \
    \        j -= 1\n            end\n        end\n    end\n    let s = String.toLower(chars)\n\
    \    let v = s.replace(\"a\", \"\").replace(\"e\", \"\").replace(\"i\", \"\").replace(\"\
    o\", \"\").replace(\"u\",\"\")\n    v = v == \"y\"\n    return v.length()\nend\n\
    </cell>\n<code language=julia-1.1>\nvowels_count(\"abcde\")\n</cell>\n<text>\n\
    Part 6: Counting Consonants - A Consonant is an individual letter which is either\
    \ vowel or not, but is not a space\nIn Julia, consonants are letters which are\
    \ not space characters.\nFor example, in the string \"abcde\", there are 5 consonants\
    \ a, b, c, d, e which are non-space characters. However, there are two spaces\
    \ between the letters and these two spaces are considered a consonant as well.",
  "\"\"\"\n    Define a function that takes the name of a string and returns\n   \
    \ the number of vowels in the string. Vowels in this case are 'a',\n    'e', 'i',\
    \ 'o', 'u'. Here, 'y' is also a vowel, but only when\n    it is at the end of\
    \ the given word.\n    \"\"\"\n    let result = 0\n    let vowels = \"aeiouAEIOUY\"\
    \n    let vowel_count = 0\n    for i in s \n        let charcode = i |> ord\n\
    \        if vowels |> Array.contains charcode\n            vowel_count + 1\n \
    \   result\n    ", "    vowels = \"aeiouAEIOU\"\n    count = 0\n    for c in s\
    \ do\n        if c is in vowels then\n            count = count + 1\n        end\n\
    \    end\n    return count\nend\n</code>\n<|/ a |>\n<| a tags=count,string,julia,count\
    \ dscore=2 |>\nI tried to make a function that does not require any loops and\
    \ I believe it to be the most efficient solution. This is a little bit complicated\
    \ (but I also believe that it is more efficient than other answers):\n<code>",
  "    \"\"\"Write a function vowels_count which takes a string representing\n   \
    \ a word as input and returns the number of vowels in the string.\n    Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but\
    \ only when it is at the end of the given word.", "    vowels = [\"a\", \"e\"\
    , \"i\", \"o\", \"u\"]\n    vowel_count = sum((vowels.contains(el) for el in s))\n\
    \    return vowel_count\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis solution is\
    \ O(n\xB2) in the number of vowels, but it can be modified to become O(n) by using\
    \ a set. Also, it is simpler to write `vowels.contains(el)` than `el in vowels`.\n\
    <|/ c |>\n<| c |>\nThe O(n) solution still requires you to iterate over all the\
    \ letters of the word, which is O(n). You can do better by building a hash table,\
    \ like `vowel_counts = HashMap(\"a\" => 0, \"e\" => 0, \"i\" => 0, \"o\" => 0,\
    \ \"u\" => 0)`, and then iterating over the word and incrementing the appropriate\
    \ value in that map.\n<|/ c |>\n<| a dscore=1 |>\nThe solution by is definitely\
    \ the way to go. I just wanted to point out another way and to show that it is\
    \ also possible.\nThe idea is to use sets to represent the vowels and then count\
    \ how many times each vowel shows up in the string. There is some complexity involved\
    \ in getting a set from a string, but it is only O(n). To illustrate the complexity\
    \ we start with a string of length 10.\n<code>\n> s = \"aeiouaeiouaeiou\"\n> length(s);\n\
    10\n</code>\nTo get the set of vowels in s:\n<code>\n> vowels = takewhile(=='a'\
    \ or == 'e' or == 'i' or == 'o' or == 'u', s)\n> vowels\n\"aeiouaeiouaeiou\"\n\
    </code>\nTo get the number of times each vowel shows up in s:\n<code>\n> map(flip\
    \ included, vowels)\n[0, 0, 0, 1, 1, 0, 1, 1, 1, 0]\n</code>\nNow all we need\
    \ to do is count how many times each 0 shows up and add that number to our result\
    \ (since each of the vowels is always counted).\n<code>\n> length(map(included,\
    \ vowels)) - count(0)\n4\n</code>\nSo our final solution would be:\n<code>\n>\
    \ length(s) - count(0)\n4\n</code>\n<|/ a tags=julia,string |>\n<| a dscore=0\
    \ |>\nAnother solution (without regular expressions):\n<code>", "    vowels_count\
    \ = 0\n    for character in s\n        if character in \"aeiouAEIOU\"\n      \
    \      vowels_count += 1\n    return vowels_count\n</cell>\n<text>\nExercise 10:\
    \ Write a function to count the number of characters in the given string that\
    \ are not vowels.", "    | s == \"\" = 1\n    | s == \"a\" = 1\n    | s == \"\
    e\" = 1\n    | s == \"i\" = 1\n    | s == \"o\" = 1\n    | s == \"u\" = 1\n  \
    \  | otherwise = 0\n</code>\n<|/ a tags=haskell,python |>\n<| c |>\nIt should\
    \ be noted that while this approach might work, it is a rather clumsy way to solve\
    \ this problem. It's a great idea and I'm glad to see that you took the time to\
    \ write it, but I do think that it would be better to write out your solution\
    \ in plain old Haskell. Your solution does not scale well to bigger data sets,\
    \ because it is basically an imperative programming language with a very simple\
    \ and straightforward structure, where Haskell has a much more declarative and\
    \ readable paradigm.\n<|/ c |>\n<| c |>\nI'm glad to hear that people like you\
    \ make StackOverflow worth it's weight in gold. Your solution is indeed a great\
    \ improvement to the original solution, and I completely agree that it is much\
    \ nicer to write in Haskell than in Python.\n<|/ c |>\n<| a dscore=1 tags=haskell,python\
    \ |>\nYou could use a list comprehension:\n<code>\n[c | c <- [head \"ACEDY\"],\
    \ c /= 'y', c /= 'y']\n</code>\nIn English, this says, \"For each character c\
    \ in [head \"ACEDY\"], keep only those that are not 'y', and remove any that are\
    \ 'y'.\"\nThis will return a list of characters which are not the letters 'y'\
    \ in the string. You can then count the number of elements in that list to get\
    \ the number of vowels present.\nThis is not as efficient as some of the other\
    \ solutions, but it seems straightforward and easy to understand.\n<|/ a |>\n\
    <| a tags=haskell,python |>\nA very simple solution with no list comprehensions\
    \ would be to keep track of the vowels in a set and test the character at the\
    \ current index in the list against the set and remove from the set if it is 'y'.\n\
    <code>\nvowels :: String -> Int\nvowels s = length (filter (\\c -> c /= 'y') (map\
    \ toUpper s))\n</code>\n<|/ a dscore=1 |>\n<| c |>\nA simple solution is often\
    \ a bad one. The list comprehension in Daniel's solution is elegant, but it is\
    \ also quite inefficient because you create a new list every time you call `toUpper`,\
    \ which can be quite expensive if the string gets long.\n<|/ c |>\n<| ", "   \
    \ |1\n    |2\n    |3\n    |4\n    |5\n    |6\n    |7\n    |8\n    |9\n    |10\n\
    \    |11\n    |12\n    |13\n    |14\n    |15\n    |16\n    |17\n    |18\n    |19\n\
    \    |20\n    |21\n    |22\n    |23\n    |24\n    |25\n    |26\n    |27\n    |28\n\
    \    |29\n    |30\n    |31\n    |32\n    |33\n    |34\n    |35\n    |36\n    |37\n\
    \    |38\n    |39\n    |40\n    |41\n    |42\n    |43\n    |44\n    |45\n    |46\n\
    \    |47\n    |48\n    |49\n    |50\n    |51\n    |52\n    |53\n    |54\n    |55\n\
    \    |56\n    |57\n    |58\n    |59\n    |60\n    |61\n    |62\n    |63\n    |64\n\
    \    |65\n    |66\n    |67\n    |68\n    |69\n    |70\n    |71\n    |72\n    |73\n\
    \    |74\n    |75\n    |76\n    |77\n    |78\n    |79\n    |80\n    |81\n    |82\n\
    \    |83\n    |84\n    |85\n    |86\n    |87\n    |88\n    |89\n    |90\n    |91\n\
    \    |92\n    |93\n    |94\n    |95\n    |96\n    |97\n    |98\n    |99\n    |100\n\
    \    |101\n    |102\n    |103\n    |104\n    |105\n    |106\n    |107\n    |108\n\
    \    |109\n    |110\n    |111\n    |112\n    |113\n    |114\n    |115\n    |116\n\
    \    |117\n    |118\n    |119\n    |120\n    |121\n    |122\n    |123\n    |124\n\
    \    |125\n    |126\n    |127\n    |128\n    |129\n    |130\n    |131\n    |132\n\
    \    |133\n    |134\n    |135\n    |136\n    |137\n    |138\n    |139\n    |140\n\
    \    |141\n    |142\n    |143\n    |144\n    |145\n    |146\n    |147\n    |148\n\
    \    |149\n    |150\n    |151\n    |152\n    |153\n    |154\n    |155\n    |156\n\
    \    |157\n    |158\n    |159\n    |160\n    |161\n    |162\n    |163\n    |164\n\
    \    |165\n    |166\n    |167\n    |", "\"\"\"Write a function vowel_count which\
    \ takes a string representing\n    a word as input and returns the number of vowels\
    \ in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y'\
    \ is also a\n    vowel, but only when it is at the end of the given word.", " \
    \   | s.length == 0 = 0\n    | s contains 'a' = 0\n    | s contains 'e' = 0\n\
    \    | s contains 'i' = 0\n    | s contains 'o' = 0\n    | s contains 'u' = 0\n\
    \    | s contains 'y' = 0\n    | otherwise = 1 + vowels_count(s[1..$])\n    \"\
    \"\"\n    \n    \ndef wordcount(file::String)::Int64\n    \"\"\"Write a function\
    \ wordcount which takes a string representing\n    a word as input and returns\
    \ the number of times that word occurs in the\n    given file.", "    vowels =\
    \ \"aeiouAEIOU\"\n    vowel_count = 0\n    for char in s\n        if vowels.contains(char)\
    \ == True\n            vowel_count += 1;\n    return vowel_count\n\"\"\"", " \
    \ \"\"\" Your Code \"\"\"\n  return vowels_count_aux(s)\nend", "    \"\"\"\n \
    \   ### Solution ###\n    vowels = Set(\"aeiou\")\n    vowels_count = s.length\
    \ - vowels.filter(x => x != s[s.length-1]).length\n    \"\"\"\n    ### Solution\
    \ ###\n    vowels = Set(\"aeiou\")\n    vowels_count = s.length - vowels.filter(x\
    \ => x != s[s.length-1]).length\n    \"\"\"\n    return vowels_count\n    \"\"\
    \"\n    ### Solution ###\n    vowels = Set(\"aeiou\")\n    vowels_count = s.length\
    \ - vowels.filter(x => x != s[s.length-1]).length\n    \"\"\"\n    return vowels_count\n\
    \    \"\"\"\n    ### Solution ###\n    vowels = Set(\"aeiou\")\n    vowels_count\
    \ = s.length - vowels.filter(x => x != s[s.length-1]).length\n    \"\"\"\n   \
    \ return vowels_count\n    \"\"\"\n    ### Solution ###\n    vowels = Set(\"aeiou\"\
    )\n    vowels_count = s.length - vowels.filter(x => x != s[s.length-1]).length\n\
    \    \"\"\"\n    return vowels_count\n    \"\"\"\n    ### Solution ###\n    vowels\
    \ = Set(\"aeiou\")\n    vowels_count = s.length - vowels.filter(x => x != s[s.length-1]).length\n\
    \    \"\"\"\n    return vowels_count\n    \"\"\"\n    ### Solution ###\n    vowels\
    \ = Set(\"aeiou\")\n    vowels_count = s.length - vowels.filter(x => x != s[s.length-1]).length\n\
    \    \"\"\"\n    return vowels_count\n    \"\"\"\n    ### Solution ###\n    vowels\
    \ = Set(\"aeiou\")\n    vowels_count = s.length - vowels.filter(x => x != s[s.length-1]).length\n\
    \    \"\"\"\n    return vowels_count\n    \"\"\"\n    ### Solution ###\n    vowels\
    \ = Set(\"aeiou\")\n    vowels_count = s.length - vowels.filter(x => x != s[s.length-1]).length\n\
    \    \"\"\"\n    return vowels_count\n    \"\"\"\n    ### Solution ###\n    vowels\
    \ = Set(\"aeiou\")\n    vowels_count = s.length - vowels.filter(x => x != s[s.length-1]).length\n\
    \    \"\"\"\n    return vowels_count\n    \"\"\"\n    ### Solution ###\n    vowels\
    \ = Set(\"aeiou\")\n    vowels_count = s.length - vowels.filter(x => x != s[s.length-1]).length\n\
    \    \"\"\"\n    return vowels_count\n    \"\"\"\n    ### Solution ###\n    vowels\
    \ = Set(\"aeiou\")\n    vowels_count = s.length - vowels.filter(x => x != s[s.length-1]).length\n\
    \    \"\"\"\n    return vowels_count\n    \"\"\"\n    ### Solution ###\n    vowels\
    \ = Set(\"aeiou\")\n    vowels_count = s.length - vowels.filter(x ", "    |[String]\n\
    \    |Int64\n    |Int64 = \n    if (vowels_count(s)==0)\n        0\n    else\n\
    \        vowels_count(s)-1\n</code>\n<|/ a tags=ocaml,recursion dscore=1 |>\n\
    <| c |>\nI think your final `vowels_count` implementation is wrong (it should\
    \ be `vowels_count(s)-1` instead of `vowels_count(s)`. Also, I don't think your\
    \ code compiles, `vowels_count` has no return type.\n<|/ c |>\n<| c |>\nThat doesn't\
    \ really help either, since OP seems to have figured it out. Your code doesn't\
    \ seem any simpler or better than the OP's.\n<|/ c |>\n<| c |>\nYeah. I wrote\
    \ it out myself (using Ocaml toplevel) when I was writing this so I was just curious\
    \ how you did it lol. I guess the OP posted his code so I thought I'd just leave\
    \ it for others to learn from it as well. Anyway, thanks for the heads up and\
    \ I'll edit that now.\n<|/ c |>\n<| c |>\nI appreciate the effort though! Just\
    \ wanted to give you guys a heads up :D\n<|/ c |>\n<| a dscore=1 tags=ocaml,recursion\
    \ |>\nHere's my suggestion (using OCaml toplevel):\n<code>\n# let vowels_count\
    \ x = List.fold_right (fun x acc -> x | 'a' :: acc | 'e' :: acc)\n           \
    \                  (x ^ \"a\" :: []) (x::[]) |> List.length;;\nval vowels_count\
    \ : string -> int = <fun>\n# vowels_count(\"abcde\");;\n- : int = 7\n</code>\n\
    I started from Christopher Rooney's solution, but my solution builds on his idea\
    \ of using an accumulator to store the counts of all the vowels in the word. Instead\
    \ of using an explicit while loop, I'm using the List.length function and fold_right.\
    \ This also means that my solution will count the number of times each vowel appears\
    \ rather than the number of times the word appears.\n<|/ a |>\n<| a |>\nI guess\
    \ my solution is not much different from others, but I hope it's clearer and easier\
    \ to understand.\n<code>\nlet vowels_count = function\n  | [] -> 0\n  | x::xs\
    \ -> (if x==\"a\" or x==\"e\" or x==\"i\" or x==\"o\" or x==\"u\" then 1 else\
    \ 0)+vowels_count xs;;\n</code>\n<|/ a dscore=", "     \n    \"\"\"Count all vowels\
    \ in the string\"\"\"\n    vowel_count = 0", "    if vowel_count(\"a\")==0 | vowel_count(\"\
    e\")==0 | vowel_count(\"i\")==0 | vowel_count(\"o\")==0 | vowel_count(\"u\")==0\n\
    \        then return 0\n    else\n        let vowel_count = vowel_count(\"a\"\
    ) + vowel_count(\"e\") + vowel_count(\"i\") + vowel_count(\"o\") + vowel_count(\"\
    u\")\n        return if vowel_count > 1\n            then vowel_count\n      \
    \      else vowel_count - 1\n    end\nend\n</code>\n<|/ a |>\n<| c |>\nCan you\
    \ add some explanation to what you've changed, and why?\n<|/ c |>\n<| c |>\nThis\
    \ looks like a homework problem. I think you should rewrite it for us, and tell\
    \ us where you're stuck.\n<|/ c |>\n<| c |>\n: I guess the OP just wants to know\
    \ how it works. I did write the function and explained it in an edit.\n<|/ c |>\n\
    <| c |>\nIt might be easier for you to understand the solution if you were to\
    \ step through it with pen and paper to understand the algorithm.\n<|/ c |>\n\
    <| a tags=ocaml,algorithm,recursion |>\nA different solution that is similar to\
    \ your code, is to use recursion:\n<code>\nlet rec vowels_count str = match str\
    \ with\n  | x :: xs ->\n      if x = \"a\" then 1\n      else if x = \"e\" then\
    \ 1\n      else if x = \"i\" then 1\n      else if x = \"o\" then 1\n      else\
    \ if x = \"u\" then 1\n      else 0\n  | [] -> 0\n</code>\nYou will need to add\
    \ more cases if the string you give to the function has more than two consecutive\
    \ vowels.\n<|/ a dscore=1 |>\n<| c |>\nA function that takes two arguments is\
    \ just too much. A function that takes one argument should be enough.\n<|/ c |>\n\
    <| a tags=ocaml,algorithm,recursion |>\nTry this:\n<code>\nlet rec vowels_count\
    \ =\n  function\n    | []     -> 0\n    | x::xs ->\n      if x = \"a\" then 1\n\
    \      else if x = \"e\" then 1\n      else if x = \"i\" then 1\n      else if\
    \ x = \"o\" then 1\n      else if x = \"u\" then 1\n      else 0\n  ;;", "   \
    \ # Your code here\n    vcount::Int64 = 0\n    for x in split(s)\n        if x\
    \ in \"aeiouAEIOU\"\n            then vcount += 1\n        end\n    end\n    return\
    \ vcount\nend\n</cell>\n<code language=julia-1.5>\n# %load solutions/vowel_count.jl\n\
    </cell>\n<text>\nExercise 1.\nWrite a function is_palindrome which takes a string\
    \ representing\n    a word as input and checks whether the string is a palindrome\
    \ or not.", "  r\"\"\"The docstring of a function named vowels_count with a docstring\
    \ comment\"\"\"\n  vowels = list('aeiou')\n  for i in s\n    if i in vowels\n\
    \      return 1\n    return 0\nend\n</cell>\n<text>\nNote that we used the string\
    \ method index to check if the character is a vowel.  This is a more flexible\
    \ way of looking at a single character.  It also has the advantage of being able\
    \ to return 0 when the string is not found.", "    vowels:Set{Char} = Set(['a',\
    \ 'e', 'i', 'o', 'u', 'y']) # the set of vowels we want\n    vowel_count:Int64\
    \ = 0\n    for character in s do # loop over each character in the string\n  \
    \      if character in vowels then # if the character is a vowel\n           \
    \ vowel_count += 1\n        end \n    end\n    return vowel_count\nend\n</cell>\n\
    <code language=julia-0.6>\n# example to test your function vowels_count\nvowels_count(\"\
    test\")\n</cell>\n<text>\nAs a final exercise, you should modify your function\
    \ vowels_count so that it counts the total number of vowels rather than just vowels\
    \ that appear in the end of the string. Hint: You will probably want to use a\
    \ for loop to do this, since a string is iterable in Julia.", "\"\"\"Count the\
    \ number of vowels in a string\"\"\"\n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = 0\n    for vowel in vowels:\n        if vowel in s:\n            vowels_count\
    \ += 1\n    return vowels_count\n</code>\n<|/ a |>\n<| a |>\nHere is the solution\
    \ I came up with. Its simple and can be easily modified to return a list of characters\
    \ with occurrences instead of a single count.\n<code>\ndef countVowels(string):\n\
    \    vowels = ['a', 'e', 'i', 'o', 'u']\n    vowelCount = 0\n    vowelList = []\n\
    \    for character in string:\n        if character in vowels:\n            vowelCount\
    \ += 1\n            vowelList.append(character)\n    return vowelCount, vowelList\n\
    </code>\n<|/ a dscore=1 tags=ocaml,ocamlbuild,ocamlfind |>\n<| a dscore=0 tags=ocaml,ocamlbuild,ocamlfind\
    \ |>\n<code>\nlet countVowels s = \n    let vowels = \"aeiou\" in\n    let len\
    \ = String.length s in\n    List.fold_left (fun acc e -> if List.mem e vowels\
    \ then (acc + 1) else acc) 0 (List.map Char.to_string s)\n</code>\n<|/ a |>\n\
    <| c |>\nWhile this code may answer the question, providing additional context\
    \ regarding how and/or why it solves the problem would improve the answer's long-term\
    \ value.\n<|/ c |>\n<| a |>\nHere is another possible solution without using List.fold_left\
    \ (but that's a good exercise).\n<code>\nlet rec countVowels s i =\n  match s\
    \ with\n  | []  -> i\n  | c :: t -> (if c = ('a' | 'e' | 'i' | 'o' | 'u') then\
    \ 1 + countVowels t (i) else i)", "    \"\"\"Write a function vowels_count which\
    \ takes a string representing\n    a word as input and returns the number of vowels\
    \ in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y'\
    \ is also a\n    vowel, but only when it is at the end of the given word.", '"""Return
    the number of vowels in a string', "    \"\"\"Write a function\n    letter_frequency(s::String)\n\
    \    which takes a string representing a word as input and returns the\n    number\
    \ of times each letter appears in the given word. The letters\n    in the word\
    \ are 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n    'k', 'l', 'm', 'n',\
    \ 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\n    'x', 'y', 'z'. The letters\
    \ can be in any case.", "    if s == \"\"\n        return 0;\n    if any(c <=\
    \ 'z' || c >= 'A' for c in s)\n        return 0;\n    if any(c <= 'Z' || c >=\
    \ 'a' for c in s)\n        return 0;\n    return sum(\"aeiou\".find(c) > -1 for\
    \ c in s);\nend\"\"\"", "    if s.length == 0 \n        0\n    elseif s.length\
    \ == 1 \n        1\n    else\n        if isUpperCase(s[1]) \n            vowels_count(tail(s))\n\
    \        elseif isLowerCase(s[1]) \n            vowels_count(tail(s))\n      \
    \  else\n            vowels_count(tail(s))\n        end\n    end\nend\n</code>\n\
    <|/ a dscore=0 tags=haskell,recursion |>\n<| a |>\nHere's a solution that uses\
    \ no imports:\n<code>\nvowels_count :: String -> Int\nvowels_count \"\" = 0\n\
    vowels_count \"a\" = 1\nvowels_count xs = case (toUpper $ last xs) of\n    'a'\
    \ -> 1\n    'e' -> 1\n    'i' -> 1\n    'o' -> 1\n    'u' -> 1\n    _ -> vowels_count\
    \ (tail xs)\n</code>\nThe most complicated line is toUpper $ last xs, where the\
    \ last function splits a string into an array. The function last returns its last\
    \ element, so if we use toUpper on the last element of the array, we will be able\
    \ to distinguish between uppercase and lowercase letters. For example, last \"\
    Hello\" returns \"l\".\n<|/ a tags=haskell,recursion dscore=0 |>\n<| a |>\nFor\
    \ this question it would be better to use function length instead of string length\n\
    <code>\nvowels_count :: String -> Int\nvowels_count \"\" = 0\nvowels_count \"\
    a\" = 1\nvowels_count xs = case (last xs) of\n    'a' -> 1\n    'e' -> 1\n   \
    \ 'i' -> 1\n    'o' -> 1\n    'u' -> 1\n    _ -> vowels_count (tail xs)\n</code>\n\
    <|/ a tags=haskell,recursion dscore=0 |>\n<| a |>\nMy solution to counting the\
    \ vowels in string is: \n<code>\nmodule CountVowels\n    (vowels_count)\n    where",
  "\"\"\"Return the number of vowels in the given string\"\"\"\n    return sum(map(is_vowel,\
    \ s))\nend\n</cell>\n<code language=julia-1.6>", "  vowels = \"aeiouAEIOU\"\n\
    \  for i in 0..s.length-1 do\n      if vowels.find(s[i]) <> -1 then\n        \
    \  count += 1\n      else\n          if vowels.len() == count then\n         \
    \     return vowels.len()\n          else\n              return count\n      end\n\
    \  end\n  1\nend\n</cell>\n<text>\nExercise 1: Count Number of Vowels\nWrite a\
    \ function vowel_count which takes a string representing\n    a word as input\
    \ and returns the number of vowels in the string.\n    Vowels in this case are\
    \ 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is\
    \ at the end of the given word.", "\"\"\"\n    >>> vowels_count(\"ACEDY\")\n \
    \   3\n\"\"\"", "    \"\"\"\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"\
    ACEDY\")\n    3\n    \"\"\"", "    if s == \"\" then return 0\n    for letter\
    \ in s do \n        if letter == \"a\" || letter == \"e\" || letter == \"i\" ||\
    \ letter == \"o\" || letter == \"u\" then \n            return 1 + vowels_count(substring(s,\
    \ 1, length - 1))\n        else if letter == \"y\" then \n            if substring(s,\
    \ 1, length) == \"y\" then \n                return 1 + vowels_count(substring(s,\
    \ 1, length - 1))\n            else return 0\n    end\n    return 0\nend\n</cell>\n\
    <text>\nProblem 4\nWrite a function filter_vowels which takes a string representing\n\
    \    a word as input and returns a string where all the vowels are\n    replaced\
    \ with '#' and the consonants are replaced with '#'\n    Example:\n    >>> filter_vowels(\"\
    abracadabra\")\n    '#b#r#c#a#d#b#r'\n    \"\"\"", "  | (vowels(s)) <- ['a', ...,\
    \ 'u']\n  | (vowel_count(s)) <- count(vowels(s))\n  return vowel_count(s)\n</code>\n\
    Now we can use the count function in our other function to return the number of\
    \ vowels:\n<code>\n\"\"\"Write a function vowel_count which takes a string representing\n\
    \    a word as input and returns the number of vowels in the string.\n    Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but\
    \ only when it is at the end of the given word.", "    | vowels_count('') | vowels_count(\"\
    \") \n    = 0\n    | vowels_count(s) = \n    if length(s) <= 1 then 0\n    else\
    \ if upper(s[1]) = 'Y' then (vowels_count(drop(s,2)) + 1)\n    else if upper(s[1])\
    \ in 'AEIOU' then (vowels_count(drop(s,2)) + 1)\n    else (vowels_count(drop(s,1))\
    \ + vowels_count(drop(s,2)))\n    \"\"\"", "    vowels <- [\"a\",\"e\",\"i\",\"\
    o\",\"u\"]\n    let vs = s |> chars\n    count <- vs\n    count |> Enum.filter(fun\
    \ c -> vowels |> List.contains) |> List.length\n    return count\n</code>\n<|/\
    \ a tags=haskell,string dscore=0 |>\n<| a |>\nWe can use filter and count to write\
    \ this more concisely\n<code>\nvowels_count :: String -> Int\nvowels_count = filter\
    \ (== 'a') . count\n</code>\n<|/ a tags=haskell,string dscore=0 |>\n<| c |>\n\
    This doesn't compile. It just gives a type error saying that `filter` has `Int\
    \ -> a -> [a]` constraint. That's because `filter` expects a function that takes\
    \ one argument and produces a boolean result. As you note, `'a' == True` and `(==\
    \ 'a')` is `True`, but `filter` only operates on `Bool` values, so it can't convert\
    \ `'a' == True` into a `Bool`. The other problem is that `filter` takes two arguments\
    \ and only produces one, so you end up with something like `(== True) . (count\
    \ True)`.\n<|/ c |>\n<| c |>\n: This does not compile for me on ghci.\n<|/ c |>\n\
    <| c |>\n: I didn't think about that -- thanks!  I remember that I've used `filter`\
    \ with one argument before.  I thought it would throw an error, but apparently\
    \ it doesn't.  My bad.  `count` is probably a better choice here.\n<|/ c |>\n\
    <| c |>\n: This was a very old version of haskell.  The filter syntax has changed\
    \ somewhat.  My bad.\n<|/ c |>\n<| c |>\n: I wasn't sure which version it was,\
    \ so I tested it on GHC and got the error you saw.\n<|/ c |>\n<| a |>\nMy version\
    \ is simple and straightforward:\n<code>\nimport Data.List(group)\nimport Data.Char(toUpper)",
  "    vowels <- \"aeiou\"\n    x <- \"y\"\n    let vowels_in_s = count(vowels) in\
    \ s\n    let vowels_in_x = count(vowels) in x \n    let vowels_in_y = count(vowels)\
    \ in x\n    if vowels_in_s then \n        vowels_in_s + vowels_in_x + vowels_in_y\n\
    \    else\n        vowels_in_x + vowels_in_y\nend\n\"\"\"Write a function words_count_vowels\
    \ which, given a word s as input, counts \nthe number of vowels in each word.\n\
    \    Write your solution using if/else statements and pattern matching.", "  \
    \  vowels= ['a','e','i','o','u']\n    vowel_count= 0\n    for x in vowels\n  \
    \      if x in s\n            if vowels.last(x) in s\n                vowel_count\
    \ = vowel_count+1\n        \n    return vowel_count\n    \n\"\"\"\nWrite a function\
    \ word_count which takes a string representing\n    a word as input and returns\
    \ the number of times each letter appears\n    in the word (including duplicates).\
    \ Here, 'y' is also a letter, but\n    only when it is at the end of the given\
    \ word.", "    if s in {\"a\",\"e\",\"i\",\"o\",\"u\",\"y\"}\n        then return\
    \ 1\n        else return 0\n    end\nend\n\"\"\"\n    Write a function vowels_count\
    \ which takes a string representing\n    a word as input and returns the number\
    \ of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'.\
    \ Here, 'y' is also a\n    vowel, but only when it is at the end of the given\
    \ word.", "    vowels = \"aeiouAEIOU\"\n    return s.count(vowels)", "    return\
    \ (\n        let\n            vowels = Set(\"a\",\"e\",\"i\",\"o\",\"u\")\n  \
    \      end\n        in \n        sum \n            (\n                let\n  \
    \                  vowel_occurrences = Dict(\"a\"->0, \"e\"->0, \"i\"->0, \"o\"\
    ->0, \"u\"->0)\n                    word_length        = length(s)\n         \
    \           vowel_end_pos      = (word_length) - vowel_occurrences\n         \
    \           vowel_end_pos_bool = inRange((word_length) - vowel_occurrences,1,0)\n\
    \                in\n                    if vowel_end_pos_bool && !vowel_occurrences[s[vowel_end_pos\
    \ - 1]]\n                        then (\n                            vowel_occurrences[s[vowel_end_pos\
    \ - 1]] +=1 \n                        ) \n                        else 0\n   \
    \             )\n            )\n        end)", "|      |      |\n|      |    \
    \  | \n|      |      | \n|      |      | \n|      |      | \n|      |      | \n\
    |      |      | \n|      |      | \n|      |      | \n|      | \n|      | \n|\
    \      | \n|      | \n|      | \n|      | \n|      | \n|      | \n|      | \n\
    |      | \n|      | \n|      | \n|      | \n|      | \n|      | \n|      | \n\
    |      | \n|      | \n|      | \n|      | \n|      | \n|      | \n|      | \n\
    |      | \n|      | \n|      | \n|      | \n|      | \n|      | \n|      | \n\
    |      | \n|      | \n|      | \n|      | \n|      | \n|      | \n|      | \n\
    |      | \n|      | \n|      | \n|      | \n|      | \n|      | \n|      | \n\
    |      | \n|      | \n|      | \n|      | \n|      | \n|      | \n|      | \n\
    |      | \n|      | \n|      | \n|      | \n|      | \n|      | \n|      | \n\
    |      | \n|      | \n|      | \n|      | \n|      | \n|      | \n|      | \n\
    |      | \n|      | \n|      | \n|      | \n|      | \n|      | \n|      | \n\
    |      | \n|      | \n|      | \n|      | \n|      | \n|      | \n|      | \n\
    |      | \n|      | \n|      | \n|      | \n|      | \n|      | \n|      | \n\
    |      | \n|      | \n|      | \n|      | \n|      | \n|      | \n|      | \n\
    |      | \n|      | \n|      | \n|      | \n|      | \n|      | \n|      | \n\
    |      | \n|      | \n|      | \n|      | \n|      | \n|      | \n|      | \n\
    |      | \n|      | \n|      | \n|      | \n|      | \n|      | \n|      | \n\
    |      | \n|      | \n|      | \n", "  |= vowels_count(s, 0)\n  | vowels_count(s,\
    \ 1)\n  | vowels_count(s, 2)\n  | vowels_count(s, 3)\n  | vowels_count(s, 4)\n\
    \  | vowels_count(s, 5)\n  | vowels_count(s, 6)\n  | vowels_count(s, 7)\n  | vowels_count(s,\
    \ 8)\n  | vowels_count(s, 9)\n  | vowels_count(s, 10)\n  | vowels_count(s, 11)\n\
    \  | vowels_count(s, 12)\n  | vowels_count(s, 13)\n  | vowels_count(s, 14)\n \
    \ | vowels_count(s, 15)\n  | vowels_count(s, 16)\n  | vowels_count(s, 17)\n  |\
    \ vowels_count(s, 18)\n  | vowels_count(s, 19)\n  | vowels_count(s, 20)\n  | vowels_count(s,\
    \ 21)\n  | vowels_count(s, 22)\n  | vowels_count(s, 23)\n  | vowels_count(s, 24)\n\
    \  | vowels_count(s, 25)\n  | vowels_count(s, 26)\n  | vowels_count(s, 27)\n \
    \ | vowels_count(s, 28)\n  | vowels_count(s, 29)\n  | vowels_count(s, 30)\n  |\
    \ vowels_count(s, 31)\n  | vowels_count(s, 32)\n  | vowels_count(s, 33)\n  | vowels_count(s,\
    \ 34)\n  | vowels_count(s, 35)\n  | vowels_count(s, 36)\n  | vowels_count(s, 37)\n\
    \  | vowels_count(s, 38)\n  | vowels_count(s, 39)\n  | vowels_count(s, 40)\n \
    \ | vowels_count(s, 41)\n  | vowels_count(s, 42)\n  | vowels_count(s, 43)\n  |\
    \ vowels_count(s, 44)\n  | vowels_count(s, 45)\n  | vowels_count(s, 46)\n  | vowels_count(s,\
    \ 47)\n  | vowels_count(s, 48)\n  | vowels_count(s, 49)\n  | vowels_count(s, 50)\n\
    \  | vowels_count(s, 51)\n  | vowels_count(s, 52)\n  | vowels_count(s, 53)\n \
    \ | vowels_count(s, 54)\n  | vowels_count(s, 55)\n  | vowels_count(s, 56)\n  |\
    \ vowels_count(s, 57)\n  | vowels_count(s, 58)\n  | vowels_count(s, 59)\n  | vowels_count(s,\
    \ 60)\n  | vowels_count(s, 61)\n  | vowels_count(s, 62)\n  | vowels_count(s, 63)\n\
    \  | vowels_count(s, 64)\n  | vowels_count(s, 65)\n  | vowels_count(s, 66)\n \
    \ | vowels_count(s, 67", "    | s:substr_count(s:lower(), a:'a')::Int64 \n   \
    \ | s:substr_count(s:lower(), a:'e')::Int64 \n    | s:substr_count(s:lower(),\
    \ a:'i')::Int64 \n    | s:substr_count(s:lower(), a:'o')::Int64 \n    | s:substr_count(s:lower(),\
    \ a:'u')::Int64 \n    | s:substr_count(s:lower(), a:'A')::Int64 \n    | s:substr_count(s:lower(),\
    \ a:'E')::Int64 \n    | s:substr_count(s:lower(), a:'I')::Int64 \n    | s:substr_count(s:lower(),\
    \ a:'O')::Int64 \n    | s:substr_count(s:lower(), a:'U')::Int64\n    \"\"\"",
  "    if s == \"\" then 0 else (count_chars(s)-count_vowels(s)) + 1\n    end\nend",
  "{\n    let vowels = \"aieouy\";\n    let vowel_count = 0;\n    let letter_count\
    \ = s.length();\n    for letter in s.chars()\n        where letter in vowels\n\
    \        do letter_count -= 1\n    letter_count > 0 && letter_count < letter_count\
    \ ? vowel_count += 1 : null;\n    vowel_count\n}", "    | vowels_count(\"\"::String)\
    \ = -1\n    | vowels_count(\"\"::String) = -1\n    | vowels_count(x::String)::Int64\
    \ = if vowel_count(x) = vowel_count(\"\"::String)\n        then vowels_count(x::String)\
    \ else vowel_count(x::String)\n</code>\nAnd voila:\n<code>\njulia> vowels_count(\"\
    abcde\")\n2", "    if s==\"\" then return 0 \n    else if \"aeiou\".contains(s)\
    \ then return 1 \n    else if \"AEIOU\".contains(s) then return 1 \n    else return\
    \ vowels_count(tail(s))+vowels_count(head(s))\nend", "        sum::Int64=0\n \
    \       for i in s\n            if i in \"aeiouAEIOU\"\n                sum::Int64+=1\n\
    \        \n        return sum\n</cell>\n<cell>\n@test vowels_count(\"abcde\")\
    \ == 2\n@test vowels_count(\"ACEDY\") == 3\n</cell>\n<text>\nPart 2: Strings\n\
    Now it's your turn to write code that takes an arbitrary string, s\nas input and\
    \ returns the string with all the vowels deleted. You can use\nthe vowels_count\
    \ function you wrote earlier to help you with this!", "     if s.length == 0\n\
    \       return 0\n     var a::Int64 = 0\n     var e::Int64 = 0\n     var i::Int64\
    \ = 0\n     var o::Int64 = 0\n     var u::Int64 = 0\n     var y::Int64 = 0\n \
    \    for (i,_) in enumerate(s)\n       if i % 2 == 0\n         a += 1\n      \
    \ if i % 3 == 0\n         e += 1\n       if i % 5 == 0\n         i +=1\n     \
    \  if i % 7 == 0\n         o +=1\n       if i % 9 == 0\n         u +=1\n     \
    \  if i == s.length-1 && i%3 == 0\n         y += 1\n     return a*e+i*o+u*y+y\n\
    \ \n</cell>\n<code language=julia-1.0>", "| s == \"\"\n| vowel(head(s, 1)) = false\
    \ || vowel(tail(s, 1)) || vowel(head(s, 2)) = false || vowel(tail(s, 2)) || vowel(head(s,\
    \ 3)) = false || vowel(tail(s, 3))\n| vowel(head(s, 4)) = false || vowel(tail(s,\
    \ 4))\n| vowel(head(s, 5)) = false || vowel(tail(s, 5))\n| vowel(head(s, 6)) =\
    \ false || vowel(tail(s, 6))\n| vowel(head(s, 7)) = false || vowel(tail(s, 7))\n\
    | vowel(head(s, 8)) = false || vowel(tail(s, 8))\n| vowel(head(s, 9)) = false\
    \ || vowel(tail(s, 9))\n| vowel(head(s, 10)) = false || vowel(tail(s, 10))\n|\
    \ vowel(head(s, 11)) = false || vowel(tail(s, 11))\n| vowel(head(s, 12)) = false\
    \ || vowel(tail(s, 12))\n| vowel(head(s, 13)) = false || vowel(tail(s, 13))\n\
    | vowel(head(s, 14)) = false || vowel(tail(s, 14))\n| vowel(head(s, 15)) = false\
    \ || vowel(tail(s, 15))\n| vowel(head(s, 16)) = false || vowel(tail(s, 16))\n\
    | vowel(head(s, 17)) = false || vowel(tail(s, 17))\n| vowel(head(s, 18)) = false\
    \ || vowel(tail(s, 18))\n| vowel(head(s, 19)) = false || vowel(tail(s, 19))\n\
    | vowel(head(s, 20)) = false || vowel(tail(s, 20))\n| vowel(head(s, 21)) = false\
    \ || vowel(tail(s, 21))\n| vowel(head(s, 22)) = false || vowel(tail(s, 22))\n\
    | vowel(head(s, 23)) = false || vowel(tail(s, 23))\n| vowel(head(s, 24)) = false\
    \ || vowel(tail(s, 24))\n| vowel(head(s, 25)) = false || vowel(tail(s, 25))\n\
    | vowel(head(s, 26)) = false || vowel(tail(s, 26))\n| vowel(head(s, 27)) = false\
    \ || vowel(tail(s, 27))\n| vowel(head(s, 28)) = false || vowel(tail(s, 28))\n\
    | vowel(head(s, 29)) = false || vowel(tail(s, 29))\n| vowel(head(s, 30)) = false\
    \ || vowel(tail(s, 30))\n| vowel(head(s, 31)) = false || vowel(tail(s, 31))\n\
    | vowel(head(s, ", "|\n\"\"\"Write a function count_chars which, given a string,\n\
    returns the number of occurrences of each character in the string.\nExample:\n\
    >>> count_chars(\"acdabd\")\n{a: 3, b: 2, d: 2, c: 2}\n\"\"\"", "</code>\nFor\
    \ this problem, you only need to use one function. Your function should have a\
    \ signature of vowels_count :: String -> Int64. Your function should only contain\
    \ one line of code.\n<code>\nreturn count(x != \".\") + 1\n</code>\nYou also have\
    \ to be careful of corner cases. In particular, if you pass in a string that has\
    \ no vowels, your function should return 0. You should also not assume that all\
    \ the characters in a string are valid characters for vowels. For example, \"\
    .\" is definitely not a vowel, so your function shouldn't count that. \nYou also\
    \ haven't told us what to return in the case that there are no vowels. We can't\
    \ just assume that 0 should be returned in that case. \nThis is one situation\
    \ where you might want to use an if statement. Basically, what you need to do\
    \ is something like this:\n<code>\nif x !~ \"a\"..\"z\" || x !~ \"A\"..\"Z\"\n\
    </code>\nAnd if x has no vowels, then what do we return in the case that x has\
    \ no vowels? Well, the simplest thing to do is return 0. Since 0 is a valid result\
    \ for vowels_count, we don't have to do anything special in that case. \nThis\
    \ is what that if statement will look like.\n<code>\nif x !~ \"a\"..\"z\" || x\
    \ !~ \"A\"..\"Z\"\n    then return 0\n    else return count(x != \".\") + 1\n\
    </code>\nFinally, you don't want to use a while statement. That's not going to\
    \ work. Even if you did use one, it would not be correct. \n<code>\nwhile x !~\
    \ \"a\"..\"z\" || x !~ \"A\"..\"Z\"\n</code>\nIf you use while you're going to\
    \ be consuming characters in the string until you find a vowel. For example, here's\
    \ what the while loop would look like: \n<code>\nwhile x !~ \"a\"..\"z\" || x\
    \ !~ \"A\"..\"Z\"\n</code>\nThat will consume the character 'A', but only when\
    \ you find a vowel. That means, your while loop will stop consuming characters,\
    \ and your function will only return the number of vowels you consumed, which\
    \ is probably not what you want. You want to consume all characters in the string\
    \ until you encounter a vowel, and that's exactly what we would do in the while\
    \ statement: \n<code>\nwhile x !~ \"a\"..\"z\" || x !~ \"A\"..\"Z\"\n</code>\n\
    If you use while statements correctly, you'll have no problems using the while\
    \ statement. \nThe last thing I said about using while statements is that you're\
    \ going to need to use an if statement. Basically, your if statement will be something\
    \ like this:\n<code>\nif x ", "\"\"\"\n    vowels_count(\"ACEDY\")\n    vowels_count(\"\
    abcde\")\n\"\"\"\n    ", "  vowels = filter( (!isUpper),(isVowel(s)) )\n  return\
    \ length(vowels)\nend\n</code>\n<|/ a tags=julia,function,performance |>\n<| c\
    \ |>\nThanks for the answer. But, what is the advantage of using `filter` over\
    \ `match`?\n<|/ c |>\n<| c |>\nMy bad, I didn't see the filter in the question\
    \ and assumed it was part of the answer. Sorry about that. As for match, it's\
    \ been more efficient in Julia 1.0 than it was in 0.6 where I was comparing it\
    \ to filter. Here's a comparison of performance: https://github.com/stevengj/julia-performance\n\
    <|/ c |>\n<| c |>\nNice! Thanks!\n<|/ c |>\n<| c |>\nHi thanks for the answer.\
    \ Your code gives me `ERROR: LoadError: UndefVarError: isUpper not defined`. However,\
    \ I do not get that error when I run `function vowels_count(s::String)::Int64\
    \ \n  vowels = filter( (!isUpper),(isVowel(s)) )\n  return length(vowels)\nend`\n\
    <|/ c |>\n<| c |>\nIn Julia 1.0 you would write `filter(!isUpper,isVowel(s))`\n\
    <|/ c |>\n<| a tags=julia,function,performance |>\nHere's my suggestion\n<code>",
  "    vowels = \"aeiou\"\n    vowel_count = 0\n    for char in s\n        if char\
    \ in vowels\n            vowel_count++\n    return vowel_count\nend \"\"\"", "|\
    \ s == \"y\" || s == \"Y\" || s == \"o\" || s == \"O\" || s == \"u\" || s == \"\
    U\" || s == \"e\" || s == \"E\"  = \n1\n| otherwise = 0\n</code>\n\"\"\"\n<|/\
    \ a tags=string,function,ocaml |>\n<| c |>\nI like the OCaml way (I do know my\
    \ way is a bit verbose), but you should have added an explanation to the code\
    \ for the OP so they can learn from it.  And yes, it won't run as posted, but\
    \ I see what you're saying about the code not being a complete program.  Apologies\
    \ for the downvote - I can't remove it now.\n<|/ c |>\n<| c |>\nSorry, I had a\
    \ typo in the code. The code I gave should run. Hope it helps.\n<|/ c |>\n<| a\
    \ tags=string,function,ocaml |>\n<code>\nlet vowel_count input =\n    let rec\
    \ loop i count =\n        match i with\n        | 0 -> count\n        | _ -> loop\
    \ i count + 1\n    in\n    loop 0 0 in\n</code>\n<|/ a dscore=1 |>\n<| a |>\n\
    <code>\nlet vowel_count str =\n  let len = String.length str in\n  String.substr\
    \ str 0 (len - 1) |> String.match \"[aeiouAEIOU]\"\n</code>\n<|/ a tags=string,function,ocaml\
    \ dscore=1 |>\n<| a |>\n<code>\nlet vowel_count str = let len = String.length\
    \ str in String.substr str 0 (len - 1) |> String.match \"[aeiouAEIOU]\"\n</code>\n\
    <|/ a tags=string,function,ocaml dscore=0 |>\n<| c |>\nWelcome to Stack Overflow.\
    \ Code-only answers are not very useful. Add some descriptions of how this code\
    \ solves the problem. Thanks!\n<|/ c |>\n<| a |>\n<code>\nlet vowel_count input\
    \ = \n  let rec loop i count =\n    match i with\n    | 0 -> count\n    | _ ->\
    \ loop i count + 1\n  in\n  loop 0 0\n</code>\n<|/ a tags=string,function,ocaml\
    \ dscore=0 |>\n<| c |>\nI tried to improve the formatting of the code but in the\
    \ end I gave up, maybe you can help?\n<|/ c |>\n<| a |>\nHere are few ways how\
    \ you can do this:\n<code>\n# String.length <<\"abcde\">> |> String.substring\
    \ 0 3 ", "\"\"\"Write a function vowels_count which takes a string representing\n\
    \    a word as input and returns the number of vowels in the string.\n    Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but\
    \ only when it is at the end of the given word.", "    if s == \"\" \n       then\
    \ return 0\n    else if islower(s) \n       then return if endwith(s,\"y\") \n\
    \           then 0 else 1\n        else if endwith(s,\"e\") \n           then\
    \ 1 else 0\n        else if endwith(s,\"i\") \n           then 2 else 0\n    \
    \    else if endwith(s,\"o\") \n           then 3 else 0\n        else if endwith(s,\"\
    u\") \n           then 4 else 0\n        else if endwith(s,\"y\")\n          \
    \ then 1 else 0\n        else 0\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    @assert vowels_count(\"abcde\") == 2\n@assert vowels_count(\"ACEDY\") == 3\n</cell>\n\
    <text>\nExercise\nWrite a function count_letters which, given a list of strings,\
    \ returns the number of letters in each string. The function should work for strings\
    \ of any length.", "\"\"\"\nSolution\n\"\"\"", "    if s is null then 0\n    else\
    \ if length(s) == 0 then 0\n    else if substring(s,0,1)=\"y\" then length(vowels_count(substring(s,0,end-1)))\n\
    \    else length(vowels_count(substring(s,0,end)))\n    end \nend\n</cell>\n<code\
    \ language=julia-1.2>\nvowels_count(\"acbdefg\")\n</cell>\n<code language=julia-1.2>\n\
    vowels_count(\"acbbdefg\")\n</cell>\n<code language=julia-1.2>", "    vowels =\
    \ Set.new(\"aeiou\")\n    vowel_chars = s.chars\n    vowel_chars |> Set.filter\
    \ (char => vowels.Contains(char))\n    vowel_chars |> Set.filter (char => char\
    \ == 'y')\n    vowel_chars |> Set.count\nend\n</cell>\n<code language=julia-1.5>\n\
    vowels_count(\"abcde\")\n</cell>\n<text>\nExercise 1: Write a function word_count\
    \ which takes a string representing\n    a word as input and returns the number\
    \ of characters in the string not\n    including spaces and capital letters.",
  "    if length(s)==0\n        return 0\n    vowels_count = 0\n    for char in s\n\
    \        vowels_count += if char==\"a\"\n                       1\n          \
    \          elsif char==\"e\"\n                       1\n                    elsif\
    \ char==\"i\"\n                       1\n                    elsif char==\"o\"\
    \n                       1\n                    elsif char==\"u\"\n          \
    \             1\n                    else\n                       0\n    end\n\
    \    return vowels_count\nend", "    | vowels_count(\"\") | vowels_count(x::String)\
    \ \n        = if ends_with(x, \"Y\") \n            then vowels_count([x,\"Y\"\
    ]) \n            else vowels_count([x|tail])\n    | vowels_count(\"\") \n    \
    \    = 0\n    | vowels_count(x::String)\n        = vowels_count([x,x])\n    |\
    \ vowels_count(x::String, n)\n        = if ends_with(x, \"Y\") \n            then\
    \ vowels_count([x,\"Y\"], n)\n            else if n==1\n                then vowels_count([x|tail],\
    \ n-1)\n                else if vowels_count([x|tail], n-1)\n                \
    \    <= vowels_count([x|tail], n)\n                    then vowels_count([x,x],\
    \ n-1)\n                    else vowels_count([x|tail], n)\n        end", "  \
    \  vowels <- [a,e,i,o,u]\n    return sum [ i in vowels for i in s]\nend", "  \
    \  let vowels = [a, e, i, o, u] in\n    vowels_count(s,0)", "    \"\"\"Write a\
    \ function vowels_count which takes a string representing\n    a word as input\
    \ and returns the number of vowels in the string.\n    Vowels in this case are\
    \ 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is\
    \ at the end of the given word.", "    | s.length < 1 = 0\n    | length s < 1\
    \ = 0\n    | head s != \"y\" = 0\n    | vowel_count s <= 1\n    | otherwise =\
    \ vowel_count(s) + 1\n\"\"\"\n    \n# Solution 3\n\"\"\"\nSolution 1", "     \
    \   vowels = \"aeiou\"\n        vowel_count = 0\n        for c in s\n        \
    \    if c not in vowels\n                vowel_count += 1\n        return vowel_count\n\
    </code>\n<|/ a tags=julia,string,count,function dscore=2 |>\n<| a dscore=2 |>\n\
    This is an older question, but for the sake of completeness, here is yet another\
    \ solution that combines a few of the other answers:\n<code>", "    | vowels_count'(vowels_count'(s))\
    \ = vowels_count'(s) \n    | otherwise = 0 \n    function vowels_count'(s::String)::Int64\
    \ \n        | length(s) = 0 \n        | otherwise = length \n        function\
    \ vowels_count'(s)::Int64 \n            | vowels_count'(tail(s, 1)) == 0 = (vowels_count'(tail(s,\
    \ 0))+vowels_count'(tail(s, 1)))\n            | otherwise = vowels_count'(tail(s,\
    \ 0))+vowels_count'(tail(s, 1))\n        end\n    end", '    #write your code',
  "    return sum(char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\"\
    \ || char == \"u\" || char == \"Y\" for char in s)\nend\n</cell>\n<code language=julia-1.0>\n\
    @assert vowels_count(\"abcde\") == 2\n@assert vowels_count(\"ACEDY\") == 0\n</cell>\n\
    <text>\nExercise 5\nWrite a function is_palindrome which takes a string and checks\
    \ if the given string\n    is a palindrome.\n    \n    Example:\n    >>> is_palindrome(\"\
    A man, a plan, a canal: Panama\")\n    True\n    >>> is_palindrome(\"A man, a\
    \ plan, a canal: Panama.\")\n    False\n    \"\"\"", "  \n\"\"\"\nExercise 8:\
    \ vowels_count\nDefine a function is_consonant_char which takes a string representing\n\
    \    a character as input and checks if it is a vowel or a consonant.\n    Your\
    \ function should return True or False for these two conditions:\n    * The character\
    \ is a consonant.\n    * The character is a vowel.", "    |\n\"\"\"Write a function\
    \ vowels_count_words whose input is a string representing\n    a word as input,\
    \ and whose output is a list of tuples consisting of the\n    number of times\
    \ the word occurs and the number of vowels in the\n    word. Tuples in the list\
    \ will look like (\"word\", 1). Here the word\n    occurs exactly once and one\
    \ vowel is in the word. For example, the\n    list [(\"dog\", 2), (\"dog\", 3)]\
    \ means \"The word dog occurs twice, and the\n    word dog has three vowels\"\
    . Here, the word \"dog\" occurs twice and one vowel\n    is \"g\". If there is\
    \ no vowel after a word in the given string, it\n    should be treated as a single\
    \ unique word.", "    vowels = Set(\"aeiou\")\n    count = 0\n    for i in 0..length(s)\
    \ {\n        if vowels(s[i])\n            count + 1\n        }\n    return count\n\
    end", "\tvowel_count=0\n\tvowels=\"aeiou\"\n\tfor i in s\n\tdo \n\t\tif  i in\
    \ vowels\n\tthen \n\t\tvowel_count+=1 \n\tend \n\treturn vowel_count\nend\nvowels_count(s)\n\
    </cell>\n<cell>\n# Write a function that takes a string and returns its length.\n\
    # HINT: You may want to use the built-in function len().", "    | vowels_count(_)\
    \ = 0\n    | vowels_count(c::Char) = (c in \"aeiouy\")\n    | vowels_count(c::Char)\
    \ = vowels_count(c) + 1 if c not in \"aeiouy\" else 0", "    \"\"\"Write a function\
    \ that takes a string representing the name of a person \n    (and maybe a nickname)\
    \ and returns the number of vowels in that name.", "\"\"\"\n\"\"\"Write a function\
    \ vowel_count which takes a string representing\n    a word as input and returns\
    \ the number of vowels in the string. Here\n    'y' is a vowel but only when it\
    \ is at the end of the given word.\n    Vowels in this case are 'a', 'e', 'i',\
    \ 'o', 'u'.", "    \"\"\"Write a function vowels_count which takes a string representing\n\
    \    a word as input and returns the number of vowels in the string.\n    Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but\
    \ only when it is at the end of the given word.", "| s == \"a\" => 1\n| s == \"\
    e\" => 1\n| s == \"i\" => 1\n| s == \"o\" => 1\n| s == \"u\" => 1\n| s == \"y\"\
    \ => 2\n| s == \"Y\" => 2\n| s == \"a\" => 1\n| s == \"e\" => 1\n| s == \"i\"\
    \ => 1\n| s == \"o\" => 1\n| s == \"u\" => 1\n| s == \"y\" => 2\n| s == \"Y\"\
    \ => 2\n| s == \"a\" => 1\n| s == \"e\" => 1\n| s == \"i\" => 1\n| s == \"o\"\
    \ => 1\n| s == \"u\" => 1\n| s == \"y\" => 2\n| s == \"Y\" => 2\n| s == \"a\"\
    \ => 1\n| s == \"e\" => 1\n| s == \"i\" => 1\n| s == \"o\" => 1\n| s == \"u\"\
    \ => 1\n| s == \"y\" => 2\n| s == \"Y\" => 2\n| s == \"a\" => 1\n| s == \"e\"\
    \ => 1\n| s == \"i\" => 1\n| s == \"o\" => 1\n| s == \"u\" => 1\n| s == \"y\"\
    \ => 2\n| s == \"Y\" => 2\n| s == \"a\" => 1\n| s == \"e\" => 1\n| s == \"i\"\
    \ => 1\n| s == \"o\" => 1\n| s == \"u\" => 1\n| s == \"y\" => 2\n| s == \"Y\"\
    \ => 2\n| s == \"a\" => 1\n| s == \"e\" => 1\n| s == \"i\" => 1\n| s == \"o\"\
    \ => 1\n| s == \"u\" => 1\n| s == \"y\" => 2\n| s == \"Y\" => 2\n| s == \"a\"\
    \ => 1\n| s == \"e\" => 1\n| s == \"i\" => 1\n| s == \"o\" => 1\n| s == \"u\"\
    \ => 1\n| s == \"y\" => 2\n| s == \"Y\" => 2\n| s == \"a\" => 1\n| s == \"e\"\
    \ => 1\n| s == \"i\" => 1\n| s == \"o\" => 1\n| s == \"u\" => 1\n| s == \"y\"\
    \ => 2\n| s == \"Y\" => 2\n| s == \"a\" => 1\n", "  if s.length == 0 then 0\n\
    \  else if is_vowel(s[1], s[length(s) - 1]) then 1 + vowels_count(substring(s,\
    \ 2, length(s))) \n  else vowels_count(substring(s, 2, length(s))) + 1\nend\n\
    println(vowels_count(\"abcde\"))", "    |=\n    if s == \"\"\n        then 0\n\
    \    else if all(elem in \"aeiouAEIOU\" for elem in s)\n        then vowels_count(tail(s))\n\
    \    else vowels_count(tail(s)) + vowels_count(head(s)) \nend function vowels_count\"\
    \"\"", "    vowels_count = s.length()\n    vowel_count = vowel_count\n    for\
    \ i \u2208 [0...vowels_count]\n        if s[i] == 'a'\n            vowel_count\
    \ += 1\n        elseif s[i] == 'e'\n            vowel_count += 1\n        elseif\
    \ s[i] == 'i'\n            vowel_count += 1\n        elseif s[i] == 'o'\n    \
    \        vowel_count += 1\n        elseif s[i] == 'u'\n            vowel_count\
    \ += 1\n        else\n            vowel_count -= 1\n    return vowel_count\n</code>\n\
    <|/ a tags=haskell,list dscore=0 |>\n<| c |>\nThis only works for ASCII strings\
    \ and would not work for EBCDIC characters, if that matters to you.\n<|/ c |>\n\
    <| c |>\nThe above comment was written before the question was clarified that\
    \ it should be able to handle accented characters. I added a comment to clarify.\n\
    <|/ c |>\n<| c |>\nThat comment is still wrong. There are three character sets\
    \ that it can run on: `ASCII`, `EBCDIC`, and `Unix`. Your solution would also\
    \ work with `EBCDIC`.\n<|/ c |>\n<| c |>\nNo, that's not true, EBCDIC is a superset\
    \ of ASCII (which is also a superset of Unix). The comment was not written after\
    \ the question was clarified.\n<|/ c |>\n<| c |>\nThen this answer would be confusing\
    \ to newer users. Maybe I should delete it entirely, and add a new answer that\
    \ handles `EBCDIC`?\n<|/ c |>\n<| a tags=haskell,list dscore=0 |>\n<code>\ncount_vowel\
    \ :: String -> Int\ncount_vowel s = length . filter (\\c -> c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u') s\n</code>\nEdit: As JasonSmith points\
    \ out, this doesn't work on EBCDIC, only ASCII. As suggested, it may be better\
    \ to convert the input string into ASCII or EBCDIC first:\n<code>\nimport Data.Char\n\
    import Data.ByteString (ByteString)\nimport qualified Data.ByteString as BS\n\
    import Data.List (elemIndex)\nimport Data.Maybe (fromJust)", "    count=0\n  \
    \  for e in s\n        if e in \"aeiou\"\n            count+=1\n    \n    return\
    \ count", "    vowels = \"aeiouAEIOU\"\n    vowel_count = 0\n    vowel_pos = 1\n\
    \    for char in s\n        match vowel_pos\n            case 1\n            \
    \    if char == vowels[vowel_count]\n                    vowel_count += 1\n  \
    \          case 2\n                if char == vowels[vowel_count-1]\n        \
    \            if char == vowels[vowel_count-2]\n                        vowel_count\
    \ += 1\n            case 3\n                if char == vowels[vowel_count-1]\n\
    \                    if char == vowels[vowel_count-2]\n                      \
    \  vowel_count += 1\n            case 4\n                if char == vowels[vowel_count-1]\n\
    \                    if char == vowels[vowel_count-2]\n                      \
    \  vowel_count += 1\n            case 5\n                if char == vowels[vowel_count-1]\n\
    \                    if char == vowels[vowel_count-2]\n                      \
    \  vowel_count += 1\n            case 6\n                if char == vowels[vowel_count-1]\n\
    \                    if char == vowels[vowel_count-2]\n                      \
    \  vowel_count += 1\n            case 7\n                if char == vowels[vowel_count-1]\n\
    \                    if char == vowels[vowel_count-2]\n                      \
    \  vowel_count += 1\n            case 8\n                if char == vowels[vowel_count-1]\n\
    \                    if char == vowels[vowel_count-2]\n                      \
    \  vowel_count += 1\n            case 9\n                if char == vowels[vowel_count-1]\n\
    \                    if char == vowels[vowel_count-2]\n                      \
    \  vowel_count += 1\n            case 10\n                if char == vowels[vowel_count-1]\n\
    \                    if char == vowels[vowel_count-2]\n                      \
    \  vowel_count += 1\n            case 11\n                if char == vowels[vowel_count-1]\n\
    \                    if char == vowels[vowel_count-2]\n                      \
    \  vowel_count += 1\n            case 12\n                if char == vowels[vowel_count-1]\n\
    \                    if char == vowels[vowel_count-2]\n                      \
    \  vowel_count += 1\n            case 13\n                if char == vowels[vowel_count-1]\n\
    \                    if char == vowels[vowel_count-2]\n                      \
    \  vowel_count += 1\n            case 14\n                if char == vowels[vowel_count-1]\n\
    \                    if char == vowels[vowel_count-2]\n                      \
    \  vowel_count += 1\n            case 15\n                if char == vowels[vowel_count-1]\n\
    \                    if char == vowels[vowel_count-2]\n                      \
    \  vowel_count += 1\n            case 16\n                if char == vowels[vowel_count-1]\n\
    \                    if char == vowels[vowel_count-2]\n                      \
    \  vowel_count += 1\n            case 17\n                if char == vowels[vowel_count-1]\n\
    \                    if char == vowels[vowel_count-2]\n                      \
    \  vowel_count += 1\n            case 18\n                if char == vowels[vowel_count-1]\n\
    \                    if char == vowels[vowel_count-2]\n                      \
    \  vowel_count += 1\n            case 19\n                if char == vowels[vowel_count-1]\n\
    \                    if char == vowels[vowel_count-2]\n                      \
    \  ", '|', "    vowels <- \"aeiou\"\n    let mut count = 0\n    for i in s { \n\
    \        if i \u2209 vowels { \n            count += 1 \n        }\n    }\n  \
    \  return count\n    \"\"\"\n</cell>\n<text>\nNow, let's use the new function\
    \ to check the count of the vowels in the input string", "    | s = \"\"\n   \
    \ | \n    | if s contains \"a\"\n        then 1\n    | else if s contains \"e\"\
    \n        then 1\n    | else if s contains \"i\"\n        then 1\n    | else if\
    \ s contains \"o\"\n        then 1\n    | else if s contains \"u\"\n        then\
    \ 1\n    | else \n        0", "    if length(s)==0 then 0 else if all(y in 'aeiou'\
    \ for y in tail(s)) \n    then 1 else 0 + vowels_count(tail(s))\nend\n</code>\n\
    <|/ a |>\n<| c |>\nI see you wrote this solution by hand without even trying to\
    \ figure out how it works. How about some explanation of your solution so someone\
    \ can learn from it?\n<|/ c |>\n<| c |>\nI figured it out, thanks for the help!\n\
    <|/ c |>\n<| c |>\nThis code doesn't do what you think it does. For example, `vowels_count(\"\
    ab\")` returns 1, but it should return 0.\n<|/ c |>\n<| c |>\nYour code doesn't\
    \ do what you think it does. For example, `vowels_count(\"ab\")` returns 1, but\
    \ it should return 0.\n<|/ c |>\n<| c |>\n, you are correct. I was getting results\
    \ as 1 (instead of 0) because of the `+` sign. After adding `0`, I got 0 for the\
    \ same reason.\n<|/ c |>\n<| a |>\n<code>\n# Counting number of vowels in a given\
    \ string", "    | vowels_count = []\n    | vowels_count = (if in(xs, x\"aeiou\"\
    ) then 1 else 0 end) + length s\n    | vowels_count + length\n    | vowels_count",
  "    count = 0\n    for i in filter(str.isupper, s)\n        count += sum(\"aeiou\"\
    .contains(x) for x in i)\n    return count\n\"\"\"", "    vowels = \"aieou\"\n\
    \    count = 0\n    for char in s\n        if char in vowels\n            count\
    \ = count + 1\n    return count\n</code>\n<|/ a tags=julia,string |>\n<| a |>\n\
    <code>", "    \"\"\"\n    vowels_count(s)", '"""', "    if s.size <= 0\n     \
    \   0\n    else\n        for each c in s\n            if c == 'a'\n          \
    \      return 1\n            else\n                if c == 'e'\n             \
    \       return 1\n                else\n                    if c == 'i'\n    \
    \                    return 1\n                    else\n                    \
    \    if c == 'o'\n                            return 1\n                     \
    \   else\n                            if c == 'u'\n                          \
    \      return 1\n            else\n                if c == 'a'\n             \
    \       return 1\n                else\n                    if c == 'e'\n    \
    \                    return 1\n                    else\n                    \
    \    if c == 'i'\n                            return 1\n                     \
    \   else\n                            if c == 'o'\n                          \
    \      return 1\n                            else\n                          \
    \      if c == 'u'\n                                    return 1\n           \
    \                 end\n        end\n    end\nend", "    count::Int64 = 0\n   \
    \ for letter in s\n        if letter !in \"aeiouAEIOU\"\n            count +=\
    \ 1\n    return count", "    count = 0\n    for c in s do \n        if c in \"\
    aeiouAEIOU\" do \n            count += 1\n        end\n    end\n    return count\n\
    end", "    \n    if s.length == 0\n        0\n    else if s[s.length - 1] == 'y'\n\
    \        1\n    else if s.head == 'a'\n        1\n    else if s.head == 'e'\n\
    \        1\n    else if s.head == 'i'\n        1\n    else if s.head == 'o'\n\
    \        1\n    else if s.head == 'u'\n        1\n    else\n        0\n    end\n\
    end\n</cell>\n<code language=julia-1.3>\nvowels_count(\"abcde\")\n</cell>\n<code\
    \ language=julia-1.3>\nvowels_count(\"ACEDY\")\n</cell>\n<text>\nWrite a function\
    \ count_letters which, given a string representing\n    a string of letters and\
    \ a letter 'c', returns the number of times\n    that letter c appears in the\
    \ string.\n    \n    Example:\n    >>> count_letters(\"abaccde\", \"c\")\n   \
    \ 1\n    \"\"\"", "    | s == \"ACEDY\" = 2 + 1\n    | s == \"ABE\"  = 2 + 0\n\
    \    | s == \"ACE\"  = 2 + 0\n    | s == \"AEC\"  = 2 + 0\n    | s == \"AEI\"\
    \  = 2 + 0\n    | s == \"AIO\"  = 2 + 0\n    | s == \"AEY\"  = 2 + 0\n    | s\
    \ == \"YAE\"  = 1 + 0\n    | s == \"YAEI\" = 1 + 0\n    | s == \"YAI\"  = 1 +\
    \ 0\n    | s == \"YAIO\" =  1 + 0\n    | s == \"YAIZ\" =  1 + 0\n    | s == \"\
    YAIZZ\" = 1 + 0\n    | s == \"YAIZZZ\" = 1 + 0\n    | s == \"YAIZZZZ\" = 1 + 0\n\
    \    | s == \"YAIZZZZZ\" = 1 + 0\n    | s == \"YAIZZZZZZ\" = 1 + 0\n    | s ==\
    \ \"YAIZZZZZZZ\" = 1 + 0\n    | s == \"YAIZZZZZZZZ\" = 1 + 0\n    | s == \"YAIZZZZZZZZZ\"\
    \ = 1 + 0\n    | s == \"YAIZZZZZZZZZZ\" = 1 + 0\n    | s == \"YAIZZZZZZZZZZZ\"\
    \ = 1 + 0\n    | s == \"YAIZZZZZZZZZZZZ\" = 1 + 0\n    | s == \"YAIZZZZZZZZZZZZZ\"\
    \ = 1 + 0\n    | s == \"YAIZZZZZZZZZZZZZZ\" = 1 + 0\n    | s == \"YAIZZZZZZZZZZZZZZZ\"\
    \ = 1 + 0\n    | s == \"YAIZZZZZZZZZZZZZZZZ\" = 1 + 0\n    | s == \"YAIZZZZZZZZZZZZZZZZZ\"\
    \ = 1 + 0\n    | s == \"YAIZZZZZZZZZZZZZZZZZZ\" = 1 + 0\n    | s == \"YAIZZZZZZZZZZZZZZZZZZZ\"\
    \ = 1 + 0\n    | s == \"YAIZZZZZZZZZZZZZZZZZZZZ\" = 1 + 0\n    | s == \"YAIZZZZZZZZZZZZZZZZZZZZZ\"\
    \ = 1 + 0\n    | s == \"YAIZZZZZZZZZZZZZZZZZZZZZZ\" = 1 + 0\n    | s == \"YAIZZZZZZZZZZZZZZZZZZZZZZZ\"\
    \ = 1 + 0\n    | s == \"YAIZZZZZZZZZZZZZZZZZZZ", "  | (length(s)==0)=?1\n  | (length(vowels(s))==0)=?1\n\
    \  | (vowels(s)==\"a\")=?1\n  | (vowels(s)==\"o\")=?1\n  | (vowels(s)==\"i\")=?1\n\
    \  | (vowels(s)==\"e\")=?1\n  | (vowels(s)==\"y\")=?1\n  | (vowels(s)==\"i\")=?1\n\
    \  | (vowels(s)==\"o\")=?1\n  | (vowels(s)==\"e\")=?1\n  | (vowels(s)==\"y\")=?1\n\
    \  | (vowels(s)==\"u\")=?1\n  | (vowels(s)==\"a\")=?1\n  | (vowels(s)==\"i\")=?1\n\
    \  | (vowels(s)==\"o\")=?1\n  | (vowels(s)==\"e\")=?1\n  | (vowels(s)==\"y\")=?1\n\
    \  | (vowels(s)==\"u\")=?1\n  | (vowels(s)==\"a\")=?1\n  | (vowels(s)==\"e\")=?1\n\
    \  | (vowels(s)==\"y\")=?1\n  | (vowels(s)==\"u\")=?1\n  | (vowels(s)==\"a\")=?1\n\
    \  | (vowels(s)==\"e\")=?1\n  | (vowels(s)==\"y\")=?1\n  | (vowels(s)==\"u\")=?1\n\
    \  | (vowels(s)==\"a\")=?1\n  | (vowels(s)==\"e\")=?1\n  | (vowels(s)==\"y\")=?1\n\
    \  | (vowels(s)==\"u\")=?1\n  | (vowels(s)==\"a\")=?1\n  | (vowels(s)==\"e\")=?1\n\
    \  | (vowels(s)==\"y\")=?1\n  | (vowels(s)==\"u\")=?1\n  | (vowels(s)==\"a\")=?1\n\
    \  | (vowels(s)==\"e\")=?1\n  | (vowels(s)==\"y\")=?1\n  | (vowels(s)==\"u\")=?1\n\
    \  | (vowels(s)==\"a\")=?1\n  | (vowels(s)==\"e\")=?1\n  | (vowels(s)==\"y\")=?1\n\
    \  | (vowels(s)==\"u\")=?1\n  | (vowels(s)==\"a\")=?1\n  | (vowels(s)==\"e\")=?1\n\
    \  | (vowels(", "    vowels_count := 0\n    for c in s do \n        if c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u' then \n            vowels_count\
    \ + 1\n        else if c == 'y' && length(s) >= 2 then \n            vowels_count\
    \ + 1\n        end\n    end\n    return vowels_count\nend\n</code>\n<|/ a dscore=3\
    \ tags=functional-programming,ocaml,python |>\n<| a dscore=2 |>\nHere's a way\
    \ to do this in a functional way using recursion:\n<code>\ndef count_vowels(string):\n\
    \    if string:\n        head = string[0]\n        if head == 'a' or head == 'e'\
    \ or head == 'i' or head == 'o' or head == 'u':\n            return 1 + count_vowels(string[1:])\n\
    \        else:\n            return 1 + count_vowels(string[1:])\n    return 0\n\
    </code>\n<|/ a tags=functional-programming,ocaml,python |>\n<| c |>\nHow about\
    \ `count_vowels(string[1:])`?\n<|/ c |>\n<| c |>\nI didn't see you guys already\
    \ posted similar answers. I was just trying to be more functional\n<|/ c |>\n\
    <| c |>\nNo worries! Just trying to encourage you to show your functional solutions.\n\
    <|/ c |>\n<| a dscore=2 |>\nPythonic version using filter + lambda:\n<code>\n\
    def count_vowels(word):\n    return sum(map(lambda x: (x not in \"aeiou\") and\
    \ (x.lower() != \"y\"), word.lower()))\n</code>\n<|/ a tags=functional-programming,ocaml,python\
    \ |>\n<| c |>\nYes, that's better, especially if you don't care about the vowels\
    \ being at the end of the word.\n<|/ c |>\n<| c |>\nThis looks very good :) I\
    \ wasn't thinking about using filter for my solution. I'll definitely give this\
    \ a try\n<|/ c |>\n<| a tags=functional-programming,ocaml,python |>\n<code>\n\
    def count_vowels(word):\n    return sum(word.lower() not in 'aeiou')\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis looks like the solution. Could you please explain\
    \ the purpose of (word.lower() != \"y\")? How does that line work?\n<|/ c |>\n\
    <| c |>\nIt is checking if the first char is neither a vowel nor an 'y'\n<|/ c\
    \ |>\n<| a tags=functional-programming,ocaml,python dscore=1 |>\nThis ", " \n\
    \  for i in s\n    for j in (\"a\",\"e\",\"i\",\"o\",\"u\")\n      if i==j\n \
    \       return i+1\n  return 0\nend ", "     \"\"\"Write a function vowels_count\
    \ which takes a string representing\n     a word as input and returns the number\
    \ of vowels in the string.\n     Vowels in this case are 'a', 'e', 'i', 'o', 'u'.\
    \ Here, 'y' is also a\n     vowel, but only when it is at the end of the given\
    \ word.", "    \"\"\"Write a function vowels_count which takes a string representing\n\
    \    a word as input and returns the number of vowels in the string.\n    Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but\
    \ only when it is at the end of the given word.", "\"\"\"Write a function vowels_count\
    \ which takes a string representing\n    a word as input and returns the number\
    \ of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'.\
    \ Here, 'y' is also a\n    vowel, but only when it is at the end of the given\
    \ word.", "    if s.length == 0 || s.head == \"\"\n        return 0 \n    let\
    \ vowels = ('A':'a','E':'e','I':'i','O':'o','U':'u')\n    let rec count_vowels(start::Int64,stop::Int64)::Int64\
    \ = \n        if (start > stop) \n        then 0 \n        else \n           \
    \ if vowels.contains(s[start])\n            then count_vowels(start+1,stop) \n\
    \            else count_vowels(start+1,stop+1) \n    count_vowels(0,s.length)\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert count_vowels(0,6) == 3\n@assert\
    \ count_vowels(0,7) == 2\n@assert count_vowels(0,9) == 0\n@assert count_vowels(0,10)\
    \ == 1\n</cell>\n<text>\nRemember that strings in Julia have a head function that\
    \ gets the head of a string.\nTherefore, we can use the head function to get the\
    \ first character of our string,\nwhich is our first character.", "    | if is_empty_string(s)\n\
    \        0\n    | else\n        let c = count_vowels(s)\n        if c == 0\n \
    \           then 0\n            else\n                if is_vowel(s[end-1]) &&\
    \ s[end-1] == s[end-2] && (is_vowel(s[end-1]) || s[end-1] == 'y')\n          \
    \          then c-1\n                    else c\n                endif\n     \
    \   endif\n    end\nendfunction\n</cell>\n<code language=julia-0.4>\n#Pkg.add(\"\
    Examples\")\n</cell>\n<code language=julia-0.4>\nusing Examples\n</cell>\n<code\
    \ language=julia-0.4>\nvowels_count(\"abcde\")\n</cell>\n<code language=julia-0.4>\n\
    vowels_count(\"ACEDY\")\n</cell>\n<code language=julia-0.4>\n\"\"\"This function\
    \ takes a string and returns the length of string.\"\"\"", "    if s.length ==\
    \ 0 || s.length == 1 \n        return 0\n    vowel_count = 0\n    for c in s:\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' \n      \
    \  vowel_count += 1\n    return vowel_count\nend ", "    if s in vowels then return\
    \ 1\n    if !islower(s) then return 0\n    let mut cnt = 0\n    for i in s do\
    \ cnt += vowels.contains(i) end\n    return cnt\nend \n    \n</cell>\n<code language=julia-1.5>",
  "    count_a :Int64 = 0\n    count_e :Int64 = 0\n    count_i :Int64 = 0\n    count_o\
    \ :Int64 = 0\n    count_u :Int64 = 0\n    count_y :Int64 = 0", "  result <- 0\n\
    \  for char in s\n    do\n      if char in \"aeiouAEIOU\"\n        then result\
    \ <- result + 1\n        else if char == \"Y\"\n          then if last char not\
    \ in \"aeiouAEIOU\"\n            then result <- result + 1\n            else result\
    \ <- result - 1\n        end\n    end\n  return result", "    vowels:Set{Char}\
    \ = Set(\"aeiouAEIOU\")\n    return sum(map(_is_vowel,s,vowels))\n</code>\n<|/\
    \ a tags=ocaml,string |>\n<| c |>\n`vowels_count` has nothing to do with vowels,\
    \ it just counts the number of vowels in a string. I think OP has a homework that\
    \ wants him to solve with the above algorithm.\n<|/ c |>\n<| c |>\nThank you for\
    \ giving the hint. I think the algorithm can be generalized to count any set of\
    \ characters instead of just vowels, I just thought of vowels since OP mentioned\
    \ the words to be vowels.\n<|/ c |>\n<| a dscore=1 |>\n<code>\nlet rec count_vowels\
    \ str count =\n  match str with\n  | [] -> count\n  | x :: xs -> count_vowels\
    \ xs (if is_vowel x then count + 1 else count)", "\"\"\"\n\"\"\"\n    vowels_count(s)\
    \ = vowels_count(s, 1)\n\"\"\"", "    return (if \"AEIOUaeiouAEIOU\".contains(s)\
    \ then 2 else 0)\nend\n</cell>\n<cell>\nvowels_count(\"abcde\")\n</cell>\n<cell>\n\
    vowels_count(\"ACEDY\")\n</cell>\n<text>\nExercise 8: Write a function isupper,\
    \ which takes a string as input and\n    returns True if the string has only uppercase\
    \ letters, otherwise it returns\n    False.", "    | vowels_count(\"\") = 0\n\
    \    | vowels_count(str::String) = (length(str)==0) ? 0 : (count(str) where str\
    \ in \"aeiou\") + (vowels_count(str[1..end])==0)\n</code>\nThe last line of the\
    \ function will return the number of vowels in the string and add that to the\
    \ number of vowels in that last letter (which will be zero if the last letter\
    \ is not a vowel)\n<|/ a tags=haskell,recursion |>\n<| c |>\nThank you so much\
    \ for the solution! But why do you write \"(length(str)==0) ? 0 : (count(str)\
    \ where str in \"aeiou\") + (vowels_count(str[1..end])==0)\" instead of \"vowels_count(str[1..end])==0)\"\
    ?\n<|/ c |>\n<| c |>\nAh I see. But why are you using str[1..end], and not str?\
    \ Thank you for taking the time to answer my question! I'm going to have to learn\
    \ more about recursive functions and how they work, but this solution has helped\
    \ me a great deal! Again, thank you!\n<|/ c |>\n<| c |>\n`str[1..end]` is `'a'..'u'`,\
    \ which is the string `\"abcde\"`.  `str` would have to be `'a'..'e'` for `vowels_count(\"\
    ABCDE\")` to be 2, since `vowels_count(\"a\")` is 0, which would cause an infinite\
    \ loop.\n<|/ c |>\n<| a tags=haskell,recursion dscore=0 |>\nThis is quite a bit\
    \ of a trivial problem, and your initial attempt looks pretty good as far as recursion\
    \ is concerned.  I suppose you have a reason for trying to solve it recursively,\
    \ but this is just a question of how to solve a trivial problem recursively.\n\
    The basic problem here is how do you keep track of the current index in a string\
    \ if you need to process all characters?  Since you know how long a word is, you\
    \ know how many letters need to be processed and can thus determine the current\
    \ index by simply taking the remainder of the division of your current index by\
    \ the length of the word minus 1.\nIn order to do this, you need to keep track\
    \ of the index outside of the recursive call.  You can do that by making a helper\
    \ function which takes the index you pass in.  It can then add 1 to the index\
    \ and then pass it back into your recursive call.  It can return an updated index\
    \ which is returned from your helper function.\nHere's a simple example:\n<code>\n\
    vowels_count :: String -> Int\nvowels_count []     = 0\nvowels_count word  = vowels\
    \ (length word", "    if is_empty(s)\n        return 0\n    let mut counter=0\n\
    \    let mut prev_v=True\n    for i in s\n        if i == 'a'\n        {\n   \
    \         prev_v=False\n        }\n        else if i == 'e'\n        {\n     \
    \       prev_v=True\n        }\n        else if i == 'i'\n        {\n        \
    \    prev_v=True\n        }\n        else if i == 'o'\n        {\n           \
    \ prev_v=True\n        }\n        else if i == 'u'\n        {\n            prev_v=True\n\
    \        }\n        else\n        {\n            if prev_v\n            {\n  \
    \              counter++\n                prev_v=False\n            }\n      \
    \  }\n    end\n    counter\nend", "    if s.length == 0 \n        0\n    else\
    \ if s.length == 1 \n        1\n    else if vowels_count(s[1..-1]) == 0 \n   \
    \     1\n    else\n        vowels_count(s[1..-1]) + 1\n    end\nend\n</code>\n\
    <|/ a |>\n<| a |>\nThe simplest solution I could come up with is this:\n<code>\n\
    vowels_count(string::String) = (string.gsub(\"[aeiou]\", \"\")).count(\"u\")\n\
    </code>\nWhich is just a replacement on the string with an empty string removing\
    \ any vowels. Then simply counts the number of u's in the resultant string.\n\
    This only works because you specifically asked for u to be removed. Not all strings\
    \ will have vowels in them so if that is an issue for you then you will have to\
    \ come up with a different approach.\n<|/ a dscore=1 tags=functional-programming,ocaml,string,regex\
    \ |>\n<| a tags=functional-programming,ocaml,string,regex dscore=0 |>\nA more\
    \ functional approach\n<code>\nlet rec vowels_count str =\n    match str with\n\
    \    | \"a\" -> 1\n    | \"e\" -> 1\n    | \"i\" -> 1\n    | \"o\" -> 1\n    |\
    \ \"u\" -> 1\n    | [] -> 0\n    | str -> \n        let (vowels, rest) = List.fold_left\
    \ (fun acc c -> (if c = 'u' then acc + 1 else acc, String.substr rest 0)) (1,str)\
    \ in\n        (vowels + vowels_count rest)\n</code>\n<|/ a |>\n<| a dscore=0 |>\n\
    <code>\nlet vowels_count s =  \n  let vowels = \"aeiouAEIOU\" in  \n  List.fold_left\
    \ (fun acc c -> (if c in vowels then acc + 1 else acc)) 0 (String.split s \"\"\
    );;  \n</code>\n<|/ a tags=functional-programming,ocaml,string,regex |>\n<| a\
    \ dscore=0 |>\n<code>\nlet vowels_count string = \n    List.fold_left (fun acc\
    \ c -> (if c = 'u' then acc + 1 else acc)) 0 string;;", "    if s.length == 0\
    \ \n        0\n    else \n        if s.head == 'y' && vowel(s.tail) == true \n\
    \            vowels_count(tail)\n        else\n            if vowel(s.head) ==\
    \ true\n                vowels_count(tail) + 1 \n            else \n         \
    \       vowels_count(tail)\n            end\n        end\n    end\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=1 tags=ocaml,recursion |>\nHere is an iterative\
    \ solution which works in O(n) time for a strings of length less than a million:\n\
    <code>\nlet rec count_vowels (s:string) =\n    let vowels = \"aeiou\" in\n   \
    \ let vowels_map = Hashtbl.create (string_length s) in\n    let rec aux acc s\
    \ = function\n        | [] -> acc\n        | h :: t -> aux acc t (match s with\
    \ \n            | h1 :: t1 when h=h1 -> (aux acc t1 t) |\n            | h1 ::\
    \ t1 when h<>h1 -> (aux acc t1 t) |\n            | _ -> (aux acc t s)\n      \
    \      end) in\n    aux 0 (List.map char s)(fun c -> (\n        if c in vowels\
    \ then aux 1 (List.map char s) (fun c -> (c::acc)\n        elif c in vowels_map\
    \ then vowels_map.remove c else aux (1::acc) c\n        )\n    )\n</code>\n<|/\
    \ a |>\n<| a dscore=1 |>\nThe solution provided by is the best one, but I thought\
    \ I'd put some thought into a non-recursive solution which might be interesting\
    \ too.\n<code>\nlet vowels str = \n  let rec check c chars = \n    if c = ' '\
    \ then [] \n    else if List.mem c chars then \n      char::(check c chars) \n\
    \    else \n      (check c chars) @ [|c|] in\n  let chars = \n    match str with\n\
    \    | [] -> []\n    | x::xs -> List.map String.chr xs @ [\"a\",\"e\",\"i\",\"\
    o\",\"u\"] \n  in\n  match chars with\n  | [] -> []\n  | x::xs -> x :: (check\
    \ (String.chr x) xs)\n</code>\nThis is essentially the code in the solution provided\
    \ by but with some additional conditional checks to see if the string starts or\
    \ ends with a vowel.\n<|/ a tags=ocaml,recursion |>\n<| a dscore=0 tags=ocaml,recursion\
    \ |>", "| vowels(s) = if last in s then last + 1 else last + 0\n</code>\n<|/ a\
    \ tags=list,prolog,recursion dscore=0 |>\n<| c |>\nHi Rishabh, Thank you for your\
    \ help. My problem is that I already have a solution that uses lists, and I am\
    \ struggling to see how it would be used to count the number of vowels in a given\
    \ word.\n<|/ c |>\n<| c |>\nHi again, I've updated the question to include my\
    \ attempt at using lists. I am unsure how to recursively traverse through the\
    \ list, counting each vowel and then returning the number of vowels.\n<|/ c |>\n\
    <| c |>\nUpdated with my attempt at using lists. The problem is that I am unsure\
    \ of how to recursively traverse through the list, counting each vowel and then\
    \ returning the number of vowels.\n<|/ c |>\n<| c |>\n: Can you show what you\
    \ have tried so far?\n<|/ c |>\n<| c |>\nHi Rishabh, I've updated the question\
    \ to show my attempt at using lists and I've also included the code for the vowels\
    \ function. I can't seem to find a way to recursively traverse through the list\
    \ to count each vowel and then return the number of vowels.\n<|/ c |>\n<| a |>\n\
    A recursive solution using append/3:\n<code>\nvowel_count([], _, 0).\nvowel_count([H|T],\
    \ Vs, Vs) :-\n    append([H|Vs], Vs0, Vs1),\n    vowel_count(T, Vs1, Vs0).", " \
    \   vowels <- \"aeiou\"\n    vowels_count <- length(filter!(s ==.,vowels))\n \
    \   return vowels_count", "    return sum(1 for c in s if c in ['a', 'e', 'i',\
    \ 'o', 'u'])\n\"\"\"\n    Write a function  count_vowels which, given a string,\
    \ returns the number\n    of vowels in the string. Vowels in this case are 'a',\
    \ 'e', 'i', 'o', 'u'.\n    Example:\n    >>> count_vowels(\"abcde\")\n    2\n\
    \    >>> count_vowels(\"ACEDY\")\n    3\n    \"\"\"", "    if length(s) == 0 then\
    \ 0 else if substring(s, 0, 1) == substring(s, length(s) - 1) \n    then 1 else\
    \ 0\nend # end vowels_count()\n</cell>\n<text>\nExercise 1: vowels_count\nUse\
    \ vowels_count to count the vowels in a string. For example,", "    vowels = \"\
    aouieouy\"\n    count = 0\n    for c in s\n        if c in vowels\n          \
    \  count + 1\n    return count\n</code>\n<|/ a tags=julia,functional-programming\
    \ |>\n<| c |>\nThank you for this solution. Could you please explain why the function\
    \ has to take an argument of String?\n<|/ c |>\n<| c |>\nYou are welcome. Functions\
    \ in Julia are also objects, so the function has a method called `count`, which\
    \ accepts a string. Check out this post [here](https://www.tutorialspoint.com/julia/julia_functions.htm)\
    \ for further details. I hope this has helped you out\n<|/ c |>\n<| c |>\nYou\
    \ might also want to check out this post [here](https://stackoverflow.com/questions/43979190/how-do-you-get-the-length-of-a-string-in-julia#43979281)\
    \ for a more functional approach to getting the length of strings.\n<|/ c |>\n\
    <| a |>\nThis is how I usually do it:\n<code>", "|   let vowels=\"aeiouAEIOU\"\
    \n|   let mutable count=0\n|   for vowel in vowels\n|   do if vowel in s then\
    \ count+=1 else count=0\n|   return count\nend function vowels_count", "    vowels::Vector[\"\
    a\"] = \"AEIOU\"\n    count = 0\n    \n    for char in s\n        if char in vowels\n\
    \            count += 1\n    ends_with_vowel = s[end] == vowels[end]\n    if ends_with_vowel\n\
    \        count += 1\n    ends_with_vowel = s[end-1] == vowels[end-1]\n    if ends_with_vowel\n\
    \        count += 1\n    ends_with_vowel = s[end-2] == vowels[end-2]\n    if ends_with_vowel\n\
    \        count += 1\n    ends_with_vowel = s[end-3] == vowels[end-3]\n    if ends_with_vowel\n\
    \        count += 1\n    ends_with_vowel = s[end-4] == vowels[end-4]\n    if ends_with_vowel\n\
    \        count += 1\n    ends_with_vowel = s[end-5] == vowels[end-5]\n    if ends_with_vowel\n\
    \        count += 1\n    return count\n\"\"\"\nWrite a function count_vowels that\
    \ takes a string and counts the number of\nvowels in the string and returns the\
    \ count in a tuple. The function can\nalso be used to count the number of times\
    \ a vowel occurs in the string.", "\"\"\"Write a function vowel_count which takes\
    \ a string representing\n    a word as input and returns the number of vowels\
    \ in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y'\
    \ is also a\n    vowel, but only when it is at the end of the given word."]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
