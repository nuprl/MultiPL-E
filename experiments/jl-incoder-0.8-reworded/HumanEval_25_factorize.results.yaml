language: jl
name: HumanEval_25_factorize
results:
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factorization\
    \ = factor(n)\n    factors = Array{Int64}(undef, length(factorization))\n    i\
    \ = 1\n    for factor in factorization\n        factors[i] = factor\n        i\
    \ += 1\n    end\n    return factors\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\
    \t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249)\
    \ == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t\
    @test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpnx_h_7fn.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpnx_h_7fn.jl:26\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  UndefVarError: factor not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpnx_h_7fn.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnx_h_7fn.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnx_h_7fn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpnx_h_7fn.jl:27\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  UndefVarError: factor not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpnx_h_7fn.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnx_h_7fn.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnx_h_7fn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpnx_h_7fn.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  UndefVarError: factor not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpnx_h_7fn.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnx_h_7fn.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnx_h_7fn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpnx_h_7fn.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  UndefVarError: factor not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpnx_h_7fn.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/"
  timestamp: 1659979599
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ zeros(Int, n)\n    \n    for k in 1:n\n        if isPrime(k) == true\n     \
    \       for i = 2:k\n                if k%i == 0\n                    factors[k]\
    \ = i\n                    k /= i\n                    break\n            end\n\
    \        end\n    end\n    \n    return factors\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) ==\
    \ [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\
    \t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3,\
    \ 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18)\
    \ == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpb5k1i1fp.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpb5k1i1fp.jl:1\n\
    in expression starting at /tmp/tmpb5k1i1fp.jl:1\n"
  stdout: ''
  timestamp: 1659979597
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if isPrime(n)\n\
    \        return [Int(n)]\n    factors = factor(n)\n    res = []\n    for factor\
    \ in factors\n        for n in factors\n            res << (factor * n)\n    end\n\
    \    return res\nend\n</cell>\n<code language=julia-1.6>\n\"\"\"\nReturns vector\
    \ of primes of the given integer in the order from smallest to largest.\nEach\
    \ of the factors should be vectored number of times corresponding to how many\
    \ times it appeares in factorization.\nInput number should be equal to the product\
    \ of all factors\n\"\"\"\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpiffjch3p.jl:22\nin expression starting at\
    \ /tmp/tmpiffjch3p.jl:22\n"
  stdout: ''
  timestamp: 1659979597
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    \n    factors\
    \ = []\n    \n    # To factorize a number n, the process starts off by finding\
    \ the prime factors\n    # of the number and then multiplies them together to\
    \ get a number that is \n    # factorized from the product of all factors.\n \
    \   \n    # To get the prime factors of a number n, we first find prime factors\
    \ and then \n    # multiply them together to get a number that is factorized from\
    \ the product \n    # of all factors.\n    if n % 2 == 0\n        factors.append(2)\n\
    \        n = n / 2\n    end\n    \n    for x in 2:round(Int, sqrt(n))\n      \
    \  if n % x == 0\n            push!(factors, x)\n            n /= x\n        end\n\
    \    end\n    \n    return factors\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) ==\
    \ [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t\
    @test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t\
    @test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) ==\
    \ [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw27w3kp8.jl:36\nin expression starting at\
    \ /tmp/tmpw27w3kp8.jl:36\n"
  stdout: ''
  timestamp: 1659979597
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    vec=[]\n \
    \   temp=[]\n    for x in 1:(n/2)\n        temp=[]\n        temp=factorize(n-x)\n\
    \        for x in 1:length(temp)\n            for y in 1:(temp[x])\n         \
    \       push!(vec,temp[x]*y)\n            end\n        end\n    end\n    return\
    \ vec\nend\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
    \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
    \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\
    \t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmprypq5a7j.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmprypq5a7j.jl:30\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  MethodError: no method matching factorize(::Float64)\n\
    \  Closest candidates are:\n    factorize(!Matched::Int64) at /tmp/tmprypq5a7j.jl:11\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmprypq5a7j.jl:16\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmprypq5a7j.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmprypq5a7j.jl:29\ntest set:\
    \ Error During Test at /tmp/tmprypq5a7j.jl:31\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  MethodError: no method matching factorize(::Float64)\n\
    \  Closest candidates are:\n    factorize(!Matched::Int64) at /tmp/tmprypq5a7j.jl:11\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmprypq5a7j.jl:16\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmprypq5a7j.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmprypq5a7j.jl:29\ntest set:\
    \ Error During Test at /tmp/tmprypq5a7j.jl:32\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  MethodError: no method matching factorize(::Float64)\n\
    \  Closest candidates are:\n    factorize(!Matched::Int64) at /tmp/tmprypq5a7j.jl:11\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmprypq5a7j.jl:16\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmprypq5a7j.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmprypq5a7j.jl:29\ntest set:\
    \ Error During Test at /tmp/tmprypq5a7j.jl:33\n  Test thre"
  timestamp: 1659979600
- exit_code: -1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    return factorize(factorial(n))\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
    \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
    \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\
    \t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659979601
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    \n    if n\
    \ == 1 \n        return [n ]\n    \n    factors = []\n    # find the factors\n\
    \    div, mod = n % 2, n-1\n    while div > 0\n        if div == 1 \n        \
    \    factors.push(mod)\n            break\n        div, mod = div % 2, mod \n\
    \    end\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
    \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
    \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\
    \t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"while\" at /tmp/tmpit56a5kn.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpit56a5kn.jl:1\n\
    in expression starting at /tmp/tmpit56a5kn.jl:1\n"
  stdout: ''
  timestamp: 1659979597
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ factorization(n)\n    return map(factors, factors)\nend\n</cell>\n<text>\nExercise\
    \ 3: What is the number of factors of $2^16$ ($2^4 + 1$)?\nWrite a function that\
    \ calculates $2^16$ factors.\nMake sure to write it efficiently.\nTry to make\
    \ your function more general (more efficient as $N$ is big).\nusing Test\n\n@testset\
    \ begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp38ove29q.jl:15\nin expression starting at\
    \ /tmp/tmp38ove29q.jl:15\n"
  stdout: ''
  timestamp: 1659979597
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factorization\
    \ = prime_factorization(n)\n    factorization = sort(factorization)\n    return\
    \ factorization\nend\n</cell>\n<text>\nPrime factorization with BigInt\nAs far\
    \ as I know, there is no big integer library in Julia, so it is quite hard to\
    \ compute very large factorials, even not for large numbers. Even if we can use\
    \ vectorized functions, it is still impossible to compute large factorials for\
    \ BigInts.\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
    \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
    \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\
    \t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpt6ww9akx.jl:16\nin expression starting at\
    \ /tmp/tmpt6ww9akx.jl:16\n"
  stdout: ''
  timestamp: 1659979597
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ factor(n)\n    \n    factorization = Vector{Int64}()\n    push!(factorization,\
    \ 1)\n    \n    for i in 2:length(factors)\n        push!(factorization, factors[i]*factors[i-1])\n\
    \    end\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
    \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
    \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\
    \t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpcjag_0ac.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpcjag_0ac.jl:1\n\
    in expression starting at /tmp/tmpcjag_0ac.jl:1\n"
  stdout: ''
  timestamp: 1659979597
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    \n    if n\
    \ == 1 \n        return [1]\n    \n    # Find prime factors of n\n    i = 2\n\
    \    while i <= sqrt(n) do \n        if n % i == 0 \n            break\n     \
    \   i += 1\n    end\n    \n    # Return array of factors\n    factors = Vector{Int64}()\n\
    \    while i <= sqrt(n) do \n        if n % i == 0 \n            push!(factors,\
    \ i)\n            n /= i\n        i += 1\n    end\n    \n    push!(factors, n)\n\
    \    return factors\nend\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"while\" at /tmp/tmpu1raqqbk.jl:26\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpu1raqqbk.jl:1\n\
    in expression starting at /tmp/tmpu1raqqbk.jl:1\n"
  stdout: ''
  timestamp: 1659979597
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    # initialize\
    \ array of prime numbers\n    primes = Vector{Int64}()\n    for p in primes\n\
    \        primes += [p]\n    end\n    \n    # loop through all primes and update\
    \ factorization\n    for i in primes\n        nf = factor(n)\n        \n     \
    \   for k in nf\n            if n mod k == 0 \n                push!(primes, k)\n\
    \            end\n        end\n    end\n    \n    return primes\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"k\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpzumg9r_i.jl:23\nin expression starting at /tmp/tmpzumg9r_i.jl:23\n"
  stdout: ''
  timestamp: 1659979597
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factorization\
    \ = factorizeVector(n)\n    factorization[findall(x -> x == 1, factorization)]\
    \ .= 0\n    return factorization\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\
    \t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249)\
    \ == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t\
    @test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp63ux2c5e.jl:18

    '
  stdout: "test set: Error During Test at /tmp/tmp63ux2c5e.jl:21\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  UndefVarError: factorizeVector not defined\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmp63ux2c5e.jl:12\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp63ux2c5e.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp63ux2c5e.jl:20\ntest set:\
    \ Error During Test at /tmp/tmp63ux2c5e.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  UndefVarError: factorizeVector not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmp63ux2c5e.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp63ux2c5e.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp63ux2c5e.jl:20\ntest set:\
    \ Error During Test at /tmp/tmp63ux2c5e.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  UndefVarError: factorizeVector not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmp63ux2c5e.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp63ux2c5e.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp63ux2c5e.jl:20\ntest set:\
    \ Error During Test at /tmp/tmp63ux2c5e.jl:24\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  UndefVarError: factorizeVector not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmp63ux2c5e.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]"
  timestamp: 1659979599
- exit_code: -1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ factorize(n-1)\n    factors_count = 0\n    f_list = factorization(n-1)\n   \
    \ for x in f_list\n        if x != 1\n            factors_count += 1\n       \
    \ end\n    end\n    factors = factors.^(0:factors_count)\n    factors\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\
    \t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57)\
    \ == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659979601
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n == 1\n\
    \        factors = [1]\n    elseif n >= 2\n        factors = primefactors(n)\n\
    \        factors = Vector{Int64}(factors)\n    end\n    return factors\nend\n\
    using Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) ==\
    \ [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t\
    @test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t\
    @test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) ==\
    \ [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpzljdo466.jl:22

    '
  stdout: "test set: Error During Test at /tmp/tmpzljdo466.jl:25\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  UndefVarError: primefactors not defined\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmpzljdo466.jl:15\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzljdo466.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzljdo466.jl:24\ntest set:\
    \ Error During Test at /tmp/tmpzljdo466.jl:26\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  UndefVarError: primefactors not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpzljdo466.jl:15\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzljdo466.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzljdo466.jl:24\ntest set:\
    \ Error During Test at /tmp/tmpzljdo466.jl:27\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  UndefVarError: primefactors not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpzljdo466.jl:15\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzljdo466.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzljdo466.jl:24\ntest set:\
    \ Error During Test at /tmp/tmpzljdo466.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  UndefVarError: primefactors not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpzljdo466.jl:15\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macr"
  timestamp: 1659979599
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    prime_array\
    \ = (2..ceil(sqrt(n)))\n    factorizations =\n        for p in prime_array\n \
    \           if n % p == 0 \n                yield p\n    end\n    factorizations\
    \ = [x for z in factorizations for x in (z => z*z)]\n    return factorizations\n\
    end\n</code>\nAnd that's it.\n<|/ a dscore=1 |>\n<| a tags=primes,functional-programming,ocaml\
    \ dscore=1 |>\n<code>\nlet is_prime n =\n  let rec is_prime n =\n    if n = 0\
    \ then false\n    else if n%2 = 0 then is_prime (n/2)\n    else\n      let p =\
    \ ref (n) in\n      for i = 1 to n/2 do\n        p := n\n        is_prime !p\n\
    \      done\n  in\n  is_prime n\n;;\n</code>\n<|/ a |>\n<| a tags=primes,functional-programming,ocaml\
    \ dscore=1 |>\nMy solution, inspired by this one (written in F#):\n<code>\nlet\
    \ rec factorize n = \n    let rec factorize n k = \n      if k > n then k\n  \
    \    elif n%k = 0 then k\n      else \n        let q = n//k in\n        let r1\
    \ = factorize n k - 1 in\n        if r1 >= 2 then r1 :: [k] else r1::[k]\n   \
    \ in\n    factorize n 2\n;;\n</code>\n<|/ a |>\n<| c |>\nYou probably want to\
    \ return an empty list if n is less than 2 rather than throwing an error.\n<|/\
    \ c |>\n<| a tags=primes,functional-programming,ocaml |>\nHere's a more advanced\
    \ OCaml solution, using lazy sequences and explicit tail recursion. It also shows\
    \ the power of lazy sequences:\n<code>\nlet factorize n = \n  List.map (fun i\
    \ -> (i, n//i)) \n  (List.filter \n   (fun i -> n%i = 0) \n   (factorize n-1))\n\
    using Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) ==\
    \ [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t\
    @test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t\
    @test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) ==\
    \ [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"p\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp_i1metlp.jl:16\nin expression starting at /tmp/tmp_i1metlp.jl:16\n"
  stdout: ''
  timestamp: 1659979597
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factorized_vec\
    \ = Vector{Int64}()\n    primes = prime_factors(n)\n    for p in primes\n    \
    \    if factorized_vec \u2209 primes\n            factorized_vec += [p]\n    \
    \    end\n    end\n    factorized_vec\nend\n</cell>\n<code language=julia-1.5>\n\
    @time factorize(70)\n@time factorize(75)\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) ==\
    \ [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t\
    @test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t\
    @test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) ==\
    \ [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgjcf_6wj.jl:21\nin expression starting at\
    \ /tmp/tmpgjcf_6wj.jl:21\n"
  stdout: ''
  timestamp: 1659979597
- exit_code: -1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n == 0\n\
    \        return [1]\n    else\n        div::Int = divrem(n,2)\n        return\
    \ [2*div + 1] + factorize(div)\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) ==\
    \ [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\
    \t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3,\
    \ 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18)\
    \ == [2, 3, 3])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: LoadError: '''
  stdout: 'b''test set: Error During Test at /tmp/tmpm1cy_hbx.jl:24\n  Test threw
    exception\n  Expression: candidate(2) == [2]\n  MethodError: Cannot `convert`
    an object of type Tuple{Int64, Int64} to an object of type Int64\n  Closest candidates
    are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at ~/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T},
    !Matched::T) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T},
    !Matched::Number) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n   [1]
    factorize(n::Int64)\n     @ Main /tmp/tmpm1cy_hbx.jl:15\n   [2] macro expansion\n     @
    ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [3]
    macro expansion\n     @ /tmp/tmpm1cy_hbx.jl:24 [inlined]\n   [4] macro expansion\n     @
    ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [5]
    top-level scope\n     @ /tmp/tmpm1cy_hbx.jl:23\ntest set: Error During Test at
    /tmp/tmpm1cy_hbx.jl:25\n  Test threw exception\n  Expression: candidate(4) ==
    [2, 2]\n  MethodError: Cannot `convert` an object of type Tuple{Int64, Int64}
    to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},
    !Matched::Ptr) where T<:Integer at ~/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T},
    !Matched::T) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T},
    !Matched::Number) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n   [1]
    factorize(n::Int64)\n     @ Main /tmp/tmpm1cy_hbx.jl:15\n   [2] macro expansion\n     @
    ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [3]
    macro expansion\n     @ /tmp/tmpm1cy_hbx.jl:25 [inlined]\n   [4] macro expansion\n     @
    ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [5]
    top-level scope\n     @ /tmp/tmpm1cy_hbx.jl:23\ntest set: Error During Test at
    /tmp/tmp'
  timestamp: 1659979600
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    n = checkInt(n)\n\
    \    if n <= 1 \n        return [1]\n    primes = primefactors(n)\n    factors\
    \ = factorization(n)\n    return primes .* factors\nend\n\"\"\"\nReturn vector\
    \ of prime factors of given integer in the order from smallest to largest.\n \
    \   Each of the factors should be vectored number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n\
    \    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\nusing Test\n\n\
    @testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpjustdvpu.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpjustdvpu.jl:1\n\
    in expression starting at /tmp/tmpjustdvpu.jl:1\n"
  stdout: ''
  timestamp: 1659979597
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n  \n    # initialize\
    \ vector with 0 elements\n    a = Vector{Int64}()\n    \n    # compute first five\
    \ prime factors\n    for i in 2:5\n        a[i] = n%i\n        n /= i\n      \
    \  if n == 1\n            break\n        end\n    end\nusing Test\n\n@testset\
    \ begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpu1zaxqd5.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpu1zaxqd5.jl:1\n\
    in expression starting at /tmp/tmpu1zaxqd5.jl:1\n"
  stdout: ''
  timestamp: 1659979597
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ []\n    while n > 1\n        factors.append(n % 10)\n        n = div(n, 10)\n\
    \    end\n    return factors\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t\
    @test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249)\
    \ == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t\
    @test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpsx0mihkl.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmpsx0mihkl.jl:24\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  type Array has no field append\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] factorize(n::Int64)\n\
    \     @ Main /tmp/tmpsx0mihkl.jl:14\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpsx0mihkl.jl:24 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpsx0mihkl.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpsx0mihkl.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  type Array has no field append\n  Stacktrace:\n  \
    \ [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] factorize(n::Int64)\n\
    \     @ Main /tmp/tmpsx0mihkl.jl:14\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpsx0mihkl.jl:25 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpsx0mihkl.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpsx0mihkl.jl:26\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  type Array has no field append\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] factorize(n::Int64)\n\
    \     @ Main /tmp/tmpsx0mihkl.jl:14\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpsx0mihkl.jl:26 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpsx0mihkl.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpsx0mihkl.jl:27\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  type Array has no field append\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] factorize(n::I"
  timestamp: 1659979599
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n==1 \n\
    \        return [1]\n    else\n        factors = factor(n)\n        factor = factors[end]\n\
    \        new_factors = [factor]\n        for i in factors[2:end]\n           \
    \ if i%factor == 0 \n                new_factors *= (i/factor)\n            end\n\
    \        end\n        return new_factors\n    end\nend\n</cell>\n<text>\nFactorization\
    \ of a number $k$ is given as $k^p = \\left(\\prod{i=1}^n x_{i}\\right)^\\frac{p}{p-1}$,\
    \ where $x_i$ is the factor of $k$, e.g. $x_1$ is the smallest factor, $x_n$ is\
    \ the largest factor and $p$ is the prime number of the number $k$. Here, we first\
    \ compute the prime factorization of $k$, then check whether each of the prime\
    \ factors is actually a factor of the original $k$, if so we multiply their frequency\
    \ $x_i$ number of times to the $p$ of the original $k$ to get the $k^p$ factorization.\n\
    using Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) ==\
    \ [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t\
    @test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t\
    @test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) ==\
    \ [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwlift7ra.jl:26\nin expression starting at\
    \ /tmp/tmpwlift7ra.jl:26\n"
  stdout: ''
  timestamp: 1659979597
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n  factors = [1]\n\
    \  for f in factorization(Int(n)) do\n    if f % 2 == 0 \n      factors = factors\
    \ + f\n    elseif f % 2 == 1\n      factors = factors + [2*f]\n    end\n  end\n\
    \  return factors\nend\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpnqfa96vh.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpnqfa96vh.jl:1\n\
    in expression starting at /tmp/tmpnqfa96vh.jl:1\n"
  stdout: ''
  timestamp: 1659979597
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    primes = primes(n)\n\
    \    factorization = []\n    i = 2\n    while i <= n do\n        push!(factorization,\
    \ primes[i])\n        i *= primes[i]\n    end\n    factorization\nend\n</cell>\n\
    <code language=julia-1.0>\nfactorize(35)\n</cell>\n<code language=julia-1.0>\n\
    using Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) ==\
    \ [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t\
    @test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t\
    @test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) ==\
    \ [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmptmyya_7c.jl:15\nin expression starting at /tmp/tmptmyya_7c.jl:15\n"
  stdout: ''
  timestamp: 1659979598
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ primefactors(n)\n    factors = sort(factors)\n    \n    temp = zeros(Int, length(factors))\n\
    \    for i = 1:length(factors)\n        for j = 0:i-1\n            if factors[i]*factors[j]\
    \ == n\n                temp[i] += 1\n                break\n            end\n\
    \        end\n    end\n    \n    return temp\nend\n</cell>\n<code language=julia-1.5>\n\
    factorize(12)\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) ==\
    \ [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\
    \t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3,\
    \ 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18)\
    \ == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2505r1x9.jl:27\nin expression starting at\
    \ /tmp/tmp2505r1x9.jl:27\n"
  stdout: ''
  timestamp: 1659979598
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    # Initialize\
    \ factorization vector\n    facts = zeros(Int64, n)\n    facts[1] = 2\n    \n\
    \    # Compute factorization\n    for i = 2; i<n-1; i+=facts[i]\n        facts[i]\
    \ = i\n        for j = i-1:-1:1\n            if facts[j] % i == 0\n          \
    \      facts[i] = facts[j] // i\n                break\n        end\n    end\n\
    \    \n    return facts\nend\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpx8_xbvp6.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpx8_xbvp6.jl:1\n\
    in expression starting at /tmp/tmpx8_xbvp6.jl:1\n"
  stdout: ''
  timestamp: 1659979598
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    \n    if n==1\n\
    \        return [1]\n    else\n        \n        factors=prime_factors(n)\n  \
    \      \n        \n        result=[1]\n        for factor in factors\n       \
    \     result=[result;factor*result[end-1]]\n        end\n    \n    \n        return\
    \ result\n    end\nend\n</cell>\n<text>\nThe function prime_factors returns all\
    \ factors of a given number. Its implementation is the same as the one that we\
    \ created earlier.\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t\
    @test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqfp903vc.jl:29\nin expression starting at\
    \ /tmp/tmpqfp903vc.jl:29\n"
  stdout: ''
  timestamp: 1659979598
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    primes = primefactors(n)\n\
    \    answer = collect(1:n) do i\n        product = 1\n        for p in primes\n\
    \            product *= p\n            product /= i\n            if i == product\n\
    \                push!(answer, i)\n                break\n            end\n  \
    \      end\n        answer\n    end\n    return answer\nend\n</cell>\n<cell>\n\
    #export\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
    \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
    \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\
    \t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpg3up38hy.jl:27\nin expression starting at\
    \ /tmp/tmpg3up38hy.jl:27\n"
  stdout: ''
  timestamp: 1659979598
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n < 2\n\
    \        return ones(n,1)\n    else if isPrime(n)\n        return [prime_factors(n)]\n\
    \    else\n        factorization = factorize(n)\n        vectorization = factorization\n\
    \        for (i,j) in factorization\n            vectorization[i] = vectorization[i]*(j-1)\n\
    \        end\n        return vectorization\n    end\nend\n</cell>\n<code language=julia-1.3>\n\
    @assert factorize(8) == [2, 2, 2]\n@assert factorize(25) == [5, 5]\n@assert factorize(70)\
    \ == [2, 5, 7]\n</cell>\n<text>\nExcercise 3\nusing Test\n\n@testset begin\n\n\
    candidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) ==\
    \ [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\
    \t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3,\
    \ 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18)\
    \ == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpchnjmqoq.jl:14\nin expression starting at\
    \ /tmp/tmpchnjmqoq.jl:14\n"
  stdout: ''
  timestamp: 1659979598
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    \n    v =\
    \ zeros(Int64, n)\n    for i in 1:n\n        for j in 1:i\n            if j ==\
    \ 0 \n                v[i] += 1\n            else if v[j] >= 2 \n            \
    \    v[i] += 1\n            else \n                continue # skip, already counted\n\
    \        end\n    end\n    return v\nend\n</cell>\n<code language=julia-1.1>\n\
    @time _ = factorize(8)\n</cell>\n<code language=julia-1.1>\n@time _ = factorize(25)\n\
    </cell>\n<code language=julia-1.1>\n@time _ = factorize(70)\n</cell>\n<text>\n\
    Finding Factors\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
    \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
    \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\
    \t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpui6_l65i.jl:18\nin expression starting at\
    \ /tmp/tmpui6_l65i.jl:18\n"
  stdout: ''
  timestamp: 1659979598
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ zeros(Int, length(primes))\n    for p in primes\n        factors[p] += 1\n \
    \   end\n    factors\nend\n</cell>\n<code language=julia-1.4>\nfactorize(8)\n\
    </cell>\n<code language=julia-1.4>\nfactorize(25)\n</cell>\n<code language=julia-1.4>\n\
    factorize(70)\n</cell>\n<text>\nSieve of Eratosthenes\nSieve of Eratosthenes is\
    \ simple and effective way to find prime numbers (all numbers except 1 and 2,\
    \ which are trivial to find).\nIt also have O(\u221An) complexity, which is great\
    \ because most of our numbers will be quite large and thus factorization will\
    \ become too time consuming.\nHere we implement this Sieve of Eratosthenes algorithm.\n\
    This algorithm is also known as Sieve of Atkin algorithm (it's also known as Atkin\
    \ Sieve).\nWe will need to keep track of the numbers we have already factorized\
    \ (to avoid factorizing them again and again).\nThe basic idea is that we consider\
    \ all even numbers, that are not divisible by any prime numbers (since 2 is a\
    \ prime number). \nSo we simply divide them by all prime numbers less than or\
    \ equal to sqrt(n).\nWe will use only those factors which are greater than or\
    \ equal to sqrt(n).\nWe will keep dividing them by all numbers whose greatest\
    \ common divisor is greater than or equal to sqrt(n).\nAt the end we will have\
    \ all the prime numbers up to sqrt(n).\nWe will keep storing those numbers in\
    \ a vector and return it.\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgy1ol94g.jl:18\nin expression starting at\
    \ /tmp/tmpgy1ol94g.jl:18\n"
  stdout: ''
  timestamp: 1659979598
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    ans=[]\n \
    \   for d in 1:(floor(log(n,2))+1)\n        if n%d == 0 \n            ans << d\n\
    \            ans *= n // d\n        end\n    end\n    return ans\nend\n</cell>\n\
    <code language=julia-1.5>\nfactorize(8)\n</cell>\n<code language=julia-1.5>\n\
    factorize(25)\n</cell>\n<code language=julia-1.5>\nfactorize(70)\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmperob_u38.jl:21\nin expression starting at\
    \ /tmp/tmperob_u38.jl:21\n"
  stdout: ''
  timestamp: 1659979598
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    # Find a factor\
    \ and remove it from original number\n    factor = 1\n    original_number = n\n\
    \    i = 2\n    while i < n\n        if n % i == 0\n            factor = i\n \
    \           n /= i\n        else\n            i += 1\n        end\n    end\n \
    \   \n    # Return the number of times each factor appeared in factorization\n\
    \    factor_counts = collect(1:factor-1)\n    count_of_number = 1\n    while original_number\
    \ > 1\n        if n % original_number == 0\n            count_of_number += 1\n\
    \            n /= original_number\n        else\n            original_number /=\
    \ factor\n        end\n    end\n    \n    # Return vector of factors and number\
    \ of times each appeared in factorization\n    prime_factorization = [factor_counts,\
    \ count_of_number]\n    \n    return prime_factorization\nend\n</cell>\n<code\
    \ language=julia-1.5>\nfactorize(8)\n</cell>\n<text>\nPart II: Finding all factors\
    \ of a given number\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t\
    @test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8ldih0ki.jl:42\nin expression starting at\
    \ /tmp/tmp8ldih0ki.jl:42\n"
  stdout: ''
  timestamp: 1659979598
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    primes = Primes(n)\n\
    \    prime_vec = Vector{Int64}(undef, length(primes))\n    for (p, i) in zip(primes,\
    \ 1:length(primes))\n        if p == 1\n            prime_vec[i] = 1\n       \
    \ else\n            prime_vec[i] = 0\n        end\n    end\n    prime_vec = vec(prime_vec)\n\
    \    return prime_vec\nend\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp_m65cauo.jl:26

    '
  stdout: "test set: Error During Test at /tmp/tmp_m65cauo.jl:29\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  UndefVarError: Primes not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmp_m65cauo.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_m65cauo.jl:29 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_m65cauo.jl:28\ntest set:\
    \ Error During Test at /tmp/tmp_m65cauo.jl:30\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  UndefVarError: Primes not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmp_m65cauo.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_m65cauo.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_m65cauo.jl:28\ntest set:\
    \ Error During Test at /tmp/tmp_m65cauo.jl:31\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  UndefVarError: Primes not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmp_m65cauo.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_m65cauo.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_m65cauo.jl:28\ntest set:\
    \ Error During Test at /tmp/tmp_m65cauo.jl:32\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  UndefVarError: Primes not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmp_m65cauo.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/"
  timestamp: 1659979600
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    vec = []\n\
    \    factors = factorize_to_set(n)\n    \n    for factor in factors\n        push!(vec,factor)\n\
    \    end\n    return vec\nend\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpbplbfwqk.jl:22

    '
  stdout: "test set: Error During Test at /tmp/tmpbplbfwqk.jl:25\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  UndefVarError: factorize_to_set not defined\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmpbplbfwqk.jl:13\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbplbfwqk.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbplbfwqk.jl:24\ntest set:\
    \ Error During Test at /tmp/tmpbplbfwqk.jl:26\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  UndefVarError: factorize_to_set not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpbplbfwqk.jl:13\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbplbfwqk.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbplbfwqk.jl:24\ntest set:\
    \ Error During Test at /tmp/tmpbplbfwqk.jl:27\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  UndefVarError: factorize_to_set not defined\n \
    \ Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmpbplbfwqk.jl:13\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbplbfwqk.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbplbfwqk.jl:24\ntest set:\
    \ Error During Test at /tmp/tmpbplbfwqk.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  UndefVarError: factorize_to_set not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpbplbfwqk.jl:13\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inli"
  timestamp: 1659979601
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ @view factor(n).factors\n    vec_of_factors = Vector{Int64}()\n    for f in\
    \ factors\n        if f==1 \n            vec_of_factors.push(f)\n        else\n\
    \            vec_of_factors.push(factorize(f*n))\n        end\n    end\n    return\
    \ vec_of_factors\nend\n</cell>\n<code language=julia-1.6>\n## Factorization for\
    \ given n\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
    \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
    \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\
    \t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: ArgumentError: Invalid use of @view macro: argument must\
    \ be a reference expression A[...].\nStacktrace:\n [1] var\"@view\"(__source__::LineNumberNode,\
    \ __module__::Module, ex::Any)\n   @ Base ./views.jl:136\n [2] #macroexpand#51\n\
    \   @ ./expr.jl:115 [inlined]\n [3] macroexpand\n   @ ./expr.jl:114 [inlined]\n\
    \ [4] docm(source::LineNumberNode, mod::Module, meta::Any, ex::Any, define::Bool)\
    \ (repeats 2 times)\n   @ Base.Docs ./docs/Docs.jl:537\n [5] var\"@doc\"(::LineNumberNode,\
    \ ::Module, ::String, ::Vararg{Any})\n   @ Core ./boot.jl:517\nin expression starting\
    \ at /tmp/tmp504b1xgl.jl:1\nin expression starting at /tmp/tmp504b1xgl.jl:1\n"
  stdout: ''
  timestamp: 1659979599
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n==1\n\
    \        vec(1)\n    else\n        n = floor(n)\n        vec(n-1) * factorize(floor(n/n))\n\
    \    end\nend\n</cell>\n<text>\nExamples of factorization\nusing Test\n\n@testset\
    \ begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdvgk9gdp.jl:19\nin expression starting at\
    \ /tmp/tmpdvgk9gdp.jl:19\n"
  stdout: ''
  timestamp: 1659979598
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n == 1\n\
    \        return [1]\n    else\n        divs = factorizeDiv(n)\n        return\
    \ prod(divs) + divs\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t\
    @test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249)\
    \ == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t\
    @test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpjvpd9els.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmpjvpd9els.jl:24\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  UndefVarError: factorizeDiv not defined\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmpjvpd9els.jl:15\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpjvpd9els.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpjvpd9els.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpjvpd9els.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  UndefVarError: factorizeDiv not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpjvpd9els.jl:15\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpjvpd9els.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpjvpd9els.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpjvpd9els.jl:26\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  UndefVarError: factorizeDiv not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpjvpd9els.jl:15\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpjvpd9els.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpjvpd9els.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpjvpd9els.jl:27\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  UndefVarError: factorizeDiv not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpjvpd9els.jl:15\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macr"
  timestamp: 1659979600
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n==1\n\
    \        return [1]\n    else\n        factorization = prime_table(n)\n      \
    \  result = factorization\n        for i = 2:n-1\n            add = 1\n      \
    \      for j in factorization[i]\n                add = add*j\n            result\
    \ = [add*i for i in result]\n        end\n        result\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\
    \t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57)\
    \ == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpvtr_kx8u.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpvtr_kx8u.jl:1\n\
    in expression starting at /tmp/tmpvtr_kx8u.jl:1\n"
  stdout: ''
  timestamp: 1659979600
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ factor(n-1)\n    res = [n for i in 1:length(factors)]\n    for i in factors:\n\
    \        if res == [1]\n            res = [1]\n        else\n            res =\
    \ res * i\n        end\n    end\n    return res\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) ==\
    \ [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t\
    @test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t\
    @test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) ==\
    \ [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbedcj7_6.jl:15\nin expression starting at\
    \ /tmp/tmpbedcj7_6.jl:15\n"
  stdout: ''
  timestamp: 1659979600
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    \"\"\"\n \
    \   O(1)\n    \n    Returns\n    -------\n    factor : Vector{Int64}\n       \
    \ Vector of primes factorizing the given integer\n    \n    Implementation\n \
    \   --------------\n    function factorize(n::Int64)\n        \n        if (n<=1)\n\
    \            return [1]\n        \n        factors = factorize(n)\n        \n\
    \        for factor in factors\n            if (factor % n != 0)\n           \
    \     push!(factors, factor)\n        end\n        \n        return factors\n\
    \    end\n    \"\"\"\n    \n    n = int(n)\n    factors = [1]\n    \n    while\
    \ (n > 2)\n        \n        popped_factor = factors[end]\n        \n        if\
    \ ((n % popped_factor) != 0)\n            push!(factors, popped_factor)\n    \
    \    \n        n = n / popped_factor\n    end\n    \n    return factors\nend\n\
    using Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) ==\
    \ [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t\
    @test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t\
    @test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) ==\
    \ [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpw05o1jhn.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpw05o1jhn.jl:1\n\
    in expression starting at /tmp/tmpw05o1jhn.jl:1\n"
  stdout: ''
  timestamp: 1659979600
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    \"\"\"\nReturn\
    \ vector of prime factors of given integer in the order from smallest to largest.\n\
    \    Each of the factors should be vectored number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n\
    \    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\nusing Test\n\n\
    @testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmphmb52jrm.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmphmb52jrm.jl:1\n\
    in expression starting at /tmp/tmphmb52jrm.jl:1\n"
  stdout: ''
  timestamp: 1659979600
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ [1]\n    for f in 2..sqrt(n) do \n        \n        if n % f == 0\n        \
    \    factors.push(f)\n            n /= f\n        else\n            factors[end-1]\
    \ += 1\n        end\n    end\n    factors\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) ==\
    \ [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\
    \t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3,\
    \ 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18)\
    \ == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp876brt99.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp876brt99.jl:1\n\
    in expression starting at /tmp/tmp876brt99.jl:1\n"
  stdout: ''
  timestamp: 1659979600
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    l = 2\n  \
    \  while l < n\n        if n % l == 0\n            push!(factorization, [l, n/l])\n\
    \            l = l * 2\n        else\n            l = l * 2\n        end\n   \
    \ end\n    return factorization\nend\n</cell>\n<code language=julia-1.5>\nfactorize(8);\
    \ factorize(25)\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) ==\
    \ [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\
    \t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3,\
    \ 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18)\
    \ == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4dbe50x7.jl:23\nin expression starting at\
    \ /tmp/tmp4dbe50x7.jl:23\n"
  stdout: ''
  timestamp: 1659979600
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if isPrime(n)\n\
    \        return [n ]\n    factors = [i for i in factorization(n)]\n    \n    sumFactors\
    \ = 0\n    for i in factors\n        sumFactors += i \n    \n    factors = factors*(sumFactors/n)\n\
    \    \n    factors = [i for i in factors\n                 if i != 1 ] \n    \n\
    \    return factors\nend\n\"\"\"\nReturns factorization of the given integer by\
    \ using the algorithm by Tom\xE1\u0161 M\xEDchalsk\xFD.\nInput number should be\
    \ equal to the product of all factors\n\"\"\"\nusing Test\n\n@testset begin\n\n\
    candidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) ==\
    \ [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\
    \t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3,\
    \ 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18)\
    \ == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzow4pqb7.jl:1\nin expression starting at /tmp/tmpzow4pqb7.jl:1\n"
  stdout: ''
  timestamp: 1659979600
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    i = 2\n  \
    \  factors = Vector{Int64}()\n    while i * i <= n\n        if n % i == 0\n  \
    \          factors *= i\n            n /= i\n        else\n            i += 1\n\
    \        end\n    end\n    return factors\nend\n</cell>\n<code language=julia-0.6>\n\
    using Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) ==\
    \ [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t\
    @test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t\
    @test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) ==\
    \ [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpphv6av1j.jl:24\nin expression starting at\
    \ /tmp/tmpphv6av1j.jl:24\n"
  stdout: ''
  timestamp: 1659979600
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    \n    v =\
    \ zeros(Int64, 2)\n    \n    while n >= 2\n        if n % 2 == 0\n           \
    \ n = n / 2\n        else\n            n = n * 3 + 1\n        end\n        push!(v,n)\n\
    \    end\n    \n    v\nend\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpms2649r6.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpms2649r6.jl:31\n  Expression: candidate(2)\
    \ == [2]\n   Evaluated: [0, 0, 1] == [2]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpms2649r6.jl:31 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpms2649r6.jl:30\ntest set: Test Failed at /tmp/tmpms2649r6.jl:32\n\
    \  Expression: candidate(4) == [2, 2]\n   Evaluated: [0, 0, 2, 1] == [2, 2]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpms2649r6.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpms2649r6.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpms2649r6.jl:33\n  Expression: candidate(8) == [2, 2, 2]\n\
    \   Evaluated: [0, 0, 4, 2, 1] == [2, 2, 2]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpms2649r6.jl:33 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpms2649r6.jl:30\ntest set: Test Failed at /tmp/tmpms2649r6.jl:34\n\
    \  Expression: candidate(57) == [3, 19]\n   Evaluated: [0, 0, 172, 86, 43, 130,\
    \ 65, 196, 98, 49  \u2026  13, 40, 20, 10, 5, 16, 8, 4, 2, 1] == [3, 19]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpms2649r6.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpms2649r6.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpms2649r6.jl:35\n  Expression: candidate(3249) == [3, 3, 19,\
    \ 19]\n   Evaluated: [0, 0, 9748, 4874, 2437, 7312, 3656, 1828, 914, 457  \u2026\
    \  80, 40, "
  timestamp: 1659979601
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    \n    factors\
    \ = Vector{Int64}()\n    \n    factorization = nfactors(n)\n    \n    i = length(factorization)\n\
    \    \n    while i!=0\n        \n        for j in i:-1:1\n            \n     \
    \       if factorization[j] == n\n                \n                factors+=[j]\n\
    \                \n                i = length(factorization)-1\n            \n\
    \            elseif j > length(factorization)-1\n                factors+=factorization[j-1]\n\
    \                factors.remove(j)\n            end\n        end\n    end\n  \
    \  \n    return factors\nend\n</cell>\n<code language=julia-1.5>\nfactorize(80)\n\
    </cell>\n<code language=julia-1.5>\nfactorize(100)\n</cell>\n<code language=julia-1.5>\n\
    factorize(1000)\n</cell>\n<code language=julia-1.5>\nfactorize(10000)\n</cell>\n\
    <code language=julia-1.5>\nfactorize(1000000)\n</cell>\n<code language=julia-1.5>\n\
    factorize(100)\n</cell>\n<code language=julia-1.5>\nnfactors(100) == factorize(100)\n\
    </cell>\n<code language=julia-1.5>\n# nfactors(100)\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) ==\
    \ [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t\
    @test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t\
    @test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) ==\
    \ [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0t_9w0al.jl:38\nin expression starting at\
    \ /tmp/tmp0t_9w0al.jl:38\n"
  stdout: ''
  timestamp: 1659979600
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n<2 \n\
    \        throw(DomainError(Int64(\"n must be greater than 2\")))\n    end\nusing\
    \ Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\
    \t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57)\
    \ == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpf7fect5d.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpf7fect5d.jl:1\n\
    in expression starting at /tmp/tmpf7fect5d.jl:1\n"
  stdout: ''
  timestamp: 1659979600
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n        \n   \
    \ if n == 1\n        Vector[]\n    elseif n % 2 == 0\n        factorize(n/2)\n\
    \    else\n        push!(factorize(n/2),n)\n        \n    end\n    return factorize(n/2)\n\
    \    \nend\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
    \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
    \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\
    \t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpo1ewldxj.jl:26

    '
  stdout: "test set: Error During Test at /tmp/tmpo1ewldxj.jl:29\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  MethodError: no method matching factorize(::Float64)\n\
    \  Closest candidates are:\n    factorize(!Matched::Int64) at /tmp/tmpo1ewldxj.jl:11\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmpo1ewldxj.jl:0\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpo1ewldxj.jl:29 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpo1ewldxj.jl:28\ntest set:\
    \ Error During Test at /tmp/tmpo1ewldxj.jl:30\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  MethodError: no method matching factorize(::Float64)\n\
    \  Closest candidates are:\n    factorize(!Matched::Int64) at /tmp/tmpo1ewldxj.jl:11\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmpo1ewldxj.jl:0\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpo1ewldxj.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpo1ewldxj.jl:28\ntest set:\
    \ Error During Test at /tmp/tmpo1ewldxj.jl:31\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  MethodError: no method matching factorize(::Float64)\n\
    \  Closest candidates are:\n    factorize(!Matched::Int64) at /tmp/tmpo1ewldxj.jl:11\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmpo1ewldxj.jl:0\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpo1ewldxj.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpo1ewldxj.jl:28\ntest set:\
    \ Error During Test at /tmp/tmpo1ewldxj.jl:32\n  Test threw e"
  timestamp: 1659979604
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    ans = Vector{Int64}(0)\
    \ \n    for factor in primefactors(n)\n        push!(ans, factor)\n    end\n \
    \   return ans\nend\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t\
    @test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp_7vqzs6e.jl:20

    '
  stdout: "test set: Error During Test at /tmp/tmp_7vqzs6e.jl:23\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  MethodError: no method matching Vector{Int64}(::Int64)\n\
    \  Closest candidates are:\n    Vector{T}() where T at ~/.conda/envs/polyglot/share/julia/base/boot.jl:476\n\
    \    Array{T, N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at ~/.conda/envs/polyglot/share/julia/base/bitarray.jl:494\n\
    \    Vector{T}(!Matched::Core.Compiler.AbstractRange{T}) where T at ~/.conda/envs/polyglot/share/julia/base/range.jl:1286\n\
    \    ...\n  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmp_7vqzs6e.jl:12\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_7vqzs6e.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_7vqzs6e.jl:22\ntest set:\
    \ Error During Test at /tmp/tmp_7vqzs6e.jl:24\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  MethodError: no method matching Vector{Int64}(::Int64)\n\
    \  Closest candidates are:\n    Vector{T}() where T at ~/.conda/envs/polyglot/share/julia/base/boot.jl:476\n\
    \    Array{T, N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at ~/.conda/envs/polyglot/share/julia/base/bitarray.jl:494\n\
    \    Vector{T}(!Matched::Core.Compiler.AbstractRange{T}) where T at ~/.conda/envs/polyglot/share/julia/base/range.jl:1286\n\
    \    ...\n  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmp_7vqzs6e.jl:12\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_7vqzs6e.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_7vqzs6e.jl:22\ntest set:\
    \ Error During Test at /tmp/tmp_7vqzs6e.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  MethodError: no method matching Vector{Int64}(::Int64)"
  timestamp: 1659979604
- exit_code: -1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    prime_array\
    \ = 1:2:n\n    prime_array = collect(prime_array)\n    factorization = prime_array\n\
    \    for p in prime_array\n        factorization = factorization .- p\n    end\n\
    \    return factorization\nend\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpd0t1_et5.jl:25\n  Expression: candidate(2)
    == [2]\n   Evaluated: [0] == [2]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpd0t1_et5.jl:25 [inlined]\n [3] macro
    expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpd0t1_et5.jl:24\ntest set: Test Failed
    at /tmp/tmpd0t1_et5.jl:26\n  Expression: candidate(4) == [2, 2]\n   Evaluated:
    [-3, -1] == [2, 2]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpd0t1_et5.jl:26 [inlined]\n [3] macro
    expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpd0t1_et5.jl:24\ntest set: Test Failed
    at /tmp/tmpd0t1_et5.jl:27\n  Expression: candidate(8) == [2, 2, 2]\n   Evaluated:
    [-15, -13, -11, -9] == [2, 2, 2]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpd0t1_et5.jl:27 [inlined]\n [3] macro
    expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpd0t1_et5.jl:24\ntest set: Test Failed
    at /tmp/tmpd0t1_et5.jl:28\n  Expression: candidate(57) == [3, 19]\n   Evaluated:
    [-840, -838, -836, -834, -832, -830, -828, -826, -824, -822  \xe2\x80\xa6  -802,
    -800, -798, -796, -794, -792, -790, -788, -786, -784] == [3, 19]\nStacktrace:\n
    [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpd0t1_et5.jl:28 [inlined]\n [3] macro
    expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpd0t1_et5.jl:24\ntest set: Test Failed
    at /tmp/tmpd0t1_et5.jl:29\n  Expression: candidate(32'
  timestamp: 1659979604
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n==2 return\
    \ [2]\n    factorization = factorize(floor(n/2))\n    if factorization==[] then\
    \ return [n]\n    factorization = [n*factorization...] #multiply all factors\n\
    \    [x,y] = minimum(factorization)\n    finalFactorization = factorization[x:y]\
    \ #factor number from minimum to maximum\n    finalFactorization = sort(finalFactorization)\n\
    \    return finalFactorization\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\
    \t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249)\
    \ == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t\
    @test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpdzdc8pwg.jl:14\nin expression starting at /tmp/tmpdzdc8pwg.jl:14\n"
  stdout: ''
  timestamp: 1659979601
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factorized_nums\
    \ = []\n    \n    for num_to_factor in factors(n)\n        factorized_nums = [num_to_factor]\n\
    \        for num in factors(num_to_factor)\n            if num != num_to_factor\n\
    \                factorized_nums *= num\n                break\n        end\n\
    \        factorized_nums = [x for x in factorized_nums if x != num_to_factor]\n\
    \        factorized_nums = [x for x in factorized_nums if x != 1]\n        factorized_nums\
    \ = [x for x in factorized_nums if x != 0]\n        factorized_nums = [x for x\
    \ in factorized_nums if x != 1]\n    end\n    \n    return factorized_nums\nend\n\
    using Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) ==\
    \ [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t\
    @test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t\
    @test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) ==\
    \ [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp5c5zc_1c.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp5c5zc_1c.jl:1\n\
    in expression starting at /tmp/tmp5c5zc_1c.jl:1\n"
  stdout: ''
  timestamp: 1659979601
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n < 2 \n\
    \        return Int64[]\n    elseif n % 2 == 0\n        return [Int64(n / 2)]\n\
    \    else\n        factors = factorize(n / 2)\n        for f in factors\n    \
    \        push!(factors, Int64(f + 1))\n        end\n        return factors\n \
    \   end\nend\n</cell>\n<text>\nLet's test it on the given test case\nusing Test\n\
    \n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzrazlb1d.jl:24\nin expression starting at\
    \ /tmp/tmpzrazlb1d.jl:24\n"
  stdout: ''
  timestamp: 1659979602
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    primeFactors=[]\n\
    \    for p in range(1,n-1)\n        if n%p==0\n            primeFactors=primeFactors.+(repeat(p,n%p))\n\
    \        end\n    end\n    return primeFactors\nend\n</code>\n<|/ a dscore=1 tags=integer,primes,julia\
    \ |>\n<| c |>\nThis has quadratic time complexity O(n\xB2). Please see [my answer](http://stackoverflow.com/a/43777701/4183191)\
    \ for a simple O(n) algorithm. :)\n<|/ c |>\n<| a dscore=0 |>\nAs a fast alternative\
    \ to factorize(n::Int64) you can use a precomputed vector to speed up the computation.\n\
    For example the following precomputed vector for 1000:\n<code>\nusing Test\n\n\
    @testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp086qmlu9.jl:20\nin expression starting at\
    \ /tmp/tmp086qmlu9.jl:20\n"
  stdout: ''
  timestamp: 1659979602
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n <= 0\n\
    \        return Vector{Int64}()\n    \n    primes = primefactorization(n)\n  \
    \  \n    factors = Vector{Int64}()\n    \n    for prime in primes\n        factors\
    \ = append!(factors,1:length(primes)) \n    end\n    \n    factors\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\
    \t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57)\
    \ == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpbduqad5q.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpbduqad5q.jl:1\n\
    in expression starting at /tmp/tmpbduqad5q.jl:1\n"
  stdout: ''
  timestamp: 1659979602
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n <= 1\n\
    \        Vector{}\n    elseif n % 2 == 0\n        Vector{n}\n    else\n      \
    \  p <- factorize(n/2) \n        for f in factorize(n-1) \n            if f !=\
    \ p\n                push!(p...f)\n            else \n                push!(p,\
    \ f) \n        end\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t\
    @test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249)\
    \ == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t\
    @test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9kesmxa0.jl:20\nin expression starting at\
    \ /tmp/tmp9kesmxa0.jl:20\n"
  stdout: ''
  timestamp: 1659979602
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ Factorization(n)\n    prime_numbers = factors[1]\n    factor = factors[2]\n\
    \    factors = []\n    for p in prime_numbers:\n        if p * factor in prime_numbers:\n\
    \            factors = append(factors, factor)\n            factors = append(factors,\
    \ p)\n            factor = 1\n        else\n            factor = factor * p\n\
    \        end\n    end\n    return factors\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) ==\
    \ [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\
    \t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3,\
    \ 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18)\
    \ == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplo6gsld5.jl:17\nin expression starting at\
    \ /tmp/tmplo6gsld5.jl:17\n"
  stdout: ''
  timestamp: 1659979602
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factorization\
    \ = primeFactorization(n)\n    factors = []\n    product = productOfFactors(factorization)\n\
    \    push!(factors, product)\n    for factor in factorization\n        if factor\
    \ * product != n \n            push!(factors, factor)\n            push!(factors,\
    \ product)\n        end\n    end\n    return factors\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmplrrdhhho.jl:26

    '
  stdout: "test set: Error During Test at /tmp/tmplrrdhhho.jl:29\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  UndefVarError: primeFactorization not defined\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmplrrdhhho.jl:12\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmplrrdhhho.jl:29 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmplrrdhhho.jl:28\ntest set:\
    \ Error During Test at /tmp/tmplrrdhhho.jl:30\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  UndefVarError: primeFactorization not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmplrrdhhho.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmplrrdhhho.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmplrrdhhho.jl:28\ntest set:\
    \ Error During Test at /tmp/tmplrrdhhho.jl:31\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  UndefVarError: primeFactorization not defined\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmplrrdhhho.jl:12\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmplrrdhhho.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmplrrdhhho.jl:28\ntest set:\
    \ Error During Test at /tmp/tmplrrdhhho.jl:32\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  UndefVarError: primeFactorization not defined\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmplrrdhhho.jl:12\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:4"
  timestamp: 1659979604
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n < 2\n\
    \        return Vector{Int64}(2)\n    end\n    factors = factorize(n/2)\n    for\
    \ a in factors\n        if n % a == 0\n            push!(factors, a)\n       \
    \     return factors\n        end\n    end\n    push!(factors, n)\n    return\
    \ factors\nend\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
    \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
    \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\
    \t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp1hbax1se.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmp1hbax1se.jl:30\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  MethodError: no method matching factorize(::Float64)\n\
    \  Closest candidates are:\n    factorize(!Matched::Int64) at /tmp/tmp1hbax1se.jl:11\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmp1hbax1se.jl:15\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1hbax1se.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1hbax1se.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp1hbax1se.jl:31\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  MethodError: no method matching factorize(::Float64)\n\
    \  Closest candidates are:\n    factorize(!Matched::Int64) at /tmp/tmp1hbax1se.jl:11\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmp1hbax1se.jl:15\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1hbax1se.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1hbax1se.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp1hbax1se.jl:32\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  MethodError: no method matching factorize(::Float64)\n\
    \  Closest candidates are:\n    factorize(!Matched::Int64) at /tmp/tmp1hbax1se.jl:11\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmp1hbax1se.jl:15\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1hbax1se.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1hbax1se.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp1hbax1se.jl:33\n  Test thre"
  timestamp: 1659979605
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    \n    primes\
    \ = prime_table(n)\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t\
    @test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpung7dwrh.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpung7dwrh.jl:1\n\
    in expression starting at /tmp/tmpung7dwrh.jl:1\n"
  stdout: ''
  timestamp: 1659979602
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    # check for\
    \ special cases\n    if n < 2\n        return [2]\n    \n    if n == 2\n     \
    \   return [2, 2]\n    \n    # initialize vector with size equal to number of\
    \ factors\n    factors = zeros(Int, n)\n    \n    # find prime factors up to given\
    \ number\n    for a in 2..n\n        if n % a == 0\n            factors[a] +=\
    \ 1\n            n /= a\n            if n == 1\n                break\n    \n\
    \    # reconstruct factors vector\n    for a in factors\n        if a != 1\n \
    \           factors[a-1] /= a\n        end\n    end\n    \n    return factors\n\
    end\n</cell>\n<text>\nExercise: Factorization II\nusing Test\n\n@testset begin\n\
    \ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) ==\
    \ [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\
    \t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3,\
    \ 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18)\
    \ == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmim9v61c.jl:39\nin expression starting at\
    \ /tmp/tmpmim9v61c.jl:39\n"
  stdout: ''
  timestamp: 1659979602
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ factorizeHelper(n)\n    factors = [f for factor in factors for f in factor]\n\
    \    return factors\nend\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpsrtnvnao.jl:18

    '
  stdout: "test set: Error During Test at /tmp/tmpsrtnvnao.jl:21\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  UndefVarError: factorizeHelper not defined\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmpsrtnvnao.jl:12\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpsrtnvnao.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpsrtnvnao.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpsrtnvnao.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  UndefVarError: factorizeHelper not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpsrtnvnao.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpsrtnvnao.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpsrtnvnao.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpsrtnvnao.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  UndefVarError: factorizeHelper not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpsrtnvnao.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpsrtnvnao.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpsrtnvnao.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpsrtnvnao.jl:24\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  UndefVarError: factorizeHelper not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpsrtnvnao.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]"
  timestamp: 1659979604
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    v = [n for\
    \ k in factors(n)]\n    return v\nend\n</cell>\n<code language=julia-1.4>\nfactorize(70)\n\
    </cell>\n<text>\nFactorization of a number $x$ is a set of all the prime factors\
    \ of $x$. For example, for $x = 23$, $x$ is factored into $(3, 5)$, as it can\
    \ be written as $\\frac{23}{5} = 3$ and $\\frac{23}{5} = 5$.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpk_vggqdo.jl:15\nin expression starting at\
    \ /tmp/tmpk_vggqdo.jl:15\n"
  stdout: ''
  timestamp: 1659979602
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    n = n ^ 1\n\
    \    \n    if n == 1\n        return [1]\n    end\nusing Test\n\n@testset begin\n\
    \ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) ==\
    \ [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\
    \t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3,\
    \ 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18)\
    \ == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2qc6rv0w.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2qc6rv0w.jl:1\n\
    in expression starting at /tmp/tmp2qc6rv0w.jl:1\n"
  stdout: ''
  timestamp: 1659979602
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    primeFactor\
    \ = factors(n)\n    return Vector{Int64}(undef, length(primeFactor))\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\
    \t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57)\
    \ == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpdv_0kqb9.jl:17

    '
  stdout: "test set: Error During Test at /tmp/tmpdv_0kqb9.jl:20\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  UndefVarError: factors not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpdv_0kqb9.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpdv_0kqb9.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpdv_0kqb9.jl:19\ntest set:\
    \ Error During Test at /tmp/tmpdv_0kqb9.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  UndefVarError: factors not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpdv_0kqb9.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpdv_0kqb9.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpdv_0kqb9.jl:19\ntest set:\
    \ Error During Test at /tmp/tmpdv_0kqb9.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  UndefVarError: factors not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpdv_0kqb9.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpdv_0kqb9.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpdv_0kqb9.jl:19\ntest set:\
    \ Error During Test at /tmp/tmpdv_0kqb9.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  UndefVarError: factors not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpdv_0kqb9.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /"
  timestamp: 1659979604
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ [1]\n    factors = factors .+ [x | x <- factors(n-1)]\n    factors = factors\
    \ .+ [x | x <- factors(n-2)]\n    factors\nend\n</code>\nFor example in factorize(8)\
    \ function I created vector with values 1 2 2, since 2 is repeated 3 times I added\
    \ 2 in vector three times and then I added 1 2 1 because 3 is repeated 2 times,\
    \ and then I added one 2 3 because 8 is repeated 1 time.\n<|/ a tags=biginteger,factorization,algorithm,julia,math\
    \ |>\n<| a tags=biginteger,factorization,algorithm,julia,math |>\nThe previous\
    \ answers are fine for factoring small numbers like 100. \nFor larger numbers\
    \ the following is an efficient implementation:\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkraxs2hi.jl:17\nin expression starting at\
    \ /tmp/tmpkraxs2hi.jl:17\n"
  stdout: ''
  timestamp: 1659979602
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    \n    primes\
    \ = PrimeFactorization(n + 1)\n    answer = [primes[primes.length - 1]]\n    for\
    \ i in 1:primes.length\n        if n % primes[i] == 0\n            answer += [i]\n\
    \            n /= primes[i]\n        else\n            break\n        end\n  \
    \  end\n    return answer\nend\n</cell>\n<code language=julia-1.0>\n@time factorize(21);\n\
    @time factorize(21);\n@time factorize(21);\n</cell>\n<text>\nImplement the Sieve\
    \ of Eratosthenes for finding prime numbers using the Sieve of Atkin algorithm.\n\
    To implement the algorithm, we first need to implement the Sieve of Atkin.\nThe\
    \ Sieve of Atkin is an algorithm for finding all the prime numbers smaller than\
    \ n (where n can be any number except zero).\nThe algorithm is as follows:\nusing\
    \ Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\
    \t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57)\
    \ == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpookq2li_.jl:25\nin expression starting at\
    \ /tmp/tmpookq2li_.jl:25\n"
  stdout: ''
  timestamp: 1659979603
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n<2\n \
    \       return [n ]\n    \n    smaller_factor = factorize(n-1)\n    if n < sum(smaller_factor)\n\
    \        return [n for f in smaller_factor if n == f]\n    else\n        \n  \
    \      largest_factor = 1\n        for i in smaller_factor\n            if i >largest_factor\n\
    \                largest_factor = i\n    end\n    \n    res = []\n    for i in\
    \ smaller_factor\n        res = [i for i in res if i % largest_factor != i]\n\
    \        res = [i for i in res if i < largest_factor]\n        res = [i for i\
    \ in res if i > 1]\n    end\n    \n    return res\nend # function factorize\n\
    using Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) ==\
    \ [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t\
    @test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t\
    @test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) ==\
    \ [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmpxbtcbqzy.jl:16\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpxbtcbqzy.jl:1\n\
    in expression starting at /tmp/tmpxbtcbqzy.jl:1\n"
  stdout: ''
  timestamp: 1659979603
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factorization\
    \ = getFactorization(n)\n    factors = []\n    for factor in factorization\n \
    \       factors.append(factorial(factor))\n    return factors\nusing Test\n\n\
    @testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"for\" at /tmp/tmp24xznspe.jl:14\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp24xznspe.jl:1\n\
    in expression starting at /tmp/tmp24xznspe.jl:1\n"
  stdout: ''
  timestamp: 1659979603
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    return factorization(n)\n\
    end\n</cell>\n<code language=julia-1.5>\n@time factorize(21);\n@time factorize(42);\n\
    @time factorize(311);\n@time factorize(312);\n@time factorize(909);\n@time factorize(73819);\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\
    \t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249)\
    \ == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t\
    @test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpofbr_2jq.jl:14\nin expression starting at\
    \ /tmp/tmpofbr_2jq.jl:14\n"
  stdout: ''
  timestamp: 1659979603
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factor = ones(Int,\
    \ n)\n    factor[0] = primeFactors(n)[1]\n    for i = 2:n\n        factor[i] =\
    \ prod(factor[i-1])\n        factor[i] = factor[i] * primeFactors(n)[i+1]\n  \
    \  end\n    return factor\nend\n\"\"\"\n    factorize(n::Int64, n::Int64)::Vector{Int64}\
    \ \n    \n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: cannot document the following expression:\n\nusing Test\n\
    \nStacktrace:\n [1] error(::String, ::String)\n   @ Base ./error.jl:42\n [2] top-level\
    \ scope\n   @ /tmp/tmpr8fds3pf.jl:20\nin expression starting at /tmp/tmpr8fds3pf.jl:20\n"
  stdout: ''
  timestamp: 1659979603
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    primeFactors\
    \ = factorize2(n)\n    if isPrime(primeFactors)\n        return primeFactors\n\
    \    else\n        primeFactors = primeFactors |> sort\n        primeFactors =\
    \ map((x -> x + 1) |> collect, primeFactors)\n        return primeFactors\n  \
    \  end\nend\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
    \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
    \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\
    \t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpn7r1_jrp.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpn7r1_jrp.jl:26\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  UndefVarError: factorize2 not defined\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmpn7r1_jrp.jl:12\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpn7r1_jrp.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpn7r1_jrp.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpn7r1_jrp.jl:27\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  UndefVarError: factorize2 not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpn7r1_jrp.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpn7r1_jrp.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpn7r1_jrp.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpn7r1_jrp.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  UndefVarError: factorize2 not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpn7r1_jrp.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpn7r1_jrp.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpn7r1_jrp.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpn7r1_jrp.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  UndefVarError: factorize2 not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpn7r1_jrp.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expans"
  timestamp: 1659979605
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n <= 1\n\
    \        return zeros(Int64, 1)\n    else\n        @assert n > 0\n        @assert\
    \ n % 2 == 0\n        factors = Vector{Int64}()\n        div = 2\n        while\
    \ div <= n / 2\n            if n % div == 0 && div * div <= n\n              \
    \  factors[div] += 1\n                n /= div\n            elseif n % div ==\
    \ 0 && div * div > n\n                factors[div] += 1\n            else\n  \
    \              div += 1\n            end\n        end\n        factors[div] +=\
    \ 1\n        return factors\n    end\nend\n</cell>\n<code language=julia-1.3>\n\
    factorize(25)\n</cell>\n<code language=julia-1.3>\n\"\"\"\nfactorize(n)\nusing\
    \ Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\
    \t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57)\
    \ == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpudyfc0k7.jl:33\nin expression starting at\
    \ /tmp/tmpudyfc0k7.jl:33\n"
  stdout: ''
  timestamp: 1659979603
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n==1 return\
    \ Vector{Int64}(n)\n    factors=factor(n)\n    \n    factors_sorted=sort(factors)\n\
    \    \n    prime_factors=factors_sorted\n    \n    prime_factors_sorted=sort(prime_factors)\n\
    \    \n    factorized=Vector{Int64}(n)\n    \n    len=length(prime_factors_sorted)\n\
    \    \n    factorized[1]=1\n    \n    for i=2:len\n        factorized[i]=prime_factors_sorted[i]*factorized[i-1]\n\
    \    end\n    \n    return factorized\nend\n</cell>\n<code language=julia-1.0>\n\
    factorize(8)\n</cell>\n<code language=julia-1.0>\nusing Test\n\n@testset begin\n\
    \ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) ==\
    \ [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\
    \t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3,\
    \ 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18)\
    \ == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqdtui7up.jl:33\nin expression starting at\
    \ /tmp/tmpqdtui7up.jl:33\n"
  stdout: ''
  timestamp: 1659979603
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ Vector{Int64}()\n    for f in prime_factors(n) \n        if n mod f == 0 \n\
    \            push!(factors, f)\n            n /= f\n        end\n    end\n   \
    \ return factors\nend\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"f\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpl0bjiq_e.jl:14\nin expression starting at /tmp/tmpl0bjiq_e.jl:14\n"
  stdout: ''
  timestamp: 1659979603
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    result = Array{Int64}(length(primes))\n\
    \    for p in primes\n        if n % p == 0\n            result[primes.index(p)]\
    \ += 1\n            n /= p\n        end\n    end\n    return result\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\
    \t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57)\
    \ == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmplk4vwd7i.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmplk4vwd7i.jl:26\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  UndefVarError: primes not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmplk4vwd7i.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmplk4vwd7i.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmplk4vwd7i.jl:25\ntest set:\
    \ Error During Test at /tmp/tmplk4vwd7i.jl:27\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  UndefVarError: primes not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmplk4vwd7i.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmplk4vwd7i.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmplk4vwd7i.jl:25\ntest set:\
    \ Error During Test at /tmp/tmplk4vwd7i.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  UndefVarError: primes not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmplk4vwd7i.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmplk4vwd7i.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmplk4vwd7i.jl:25\ntest set:\
    \ Error During Test at /tmp/tmplk4vwd7i.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  UndefVarError: primes not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmplk4vwd7i.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/"
  timestamp: 1659979605
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factorization\
    \ = factorization(n.n) \n    return map(x->n*x, factorization) \nend \nusing Test\n\
    \n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpsv7qmhmg.jl:17

    '
  stdout: "test set: Error During Test at /tmp/tmpsv7qmhmg.jl:20\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  type Int64 has no field n\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] factorize(n::Int64)\n\
    \     @ Main /tmp/tmpsv7qmhmg.jl:12\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpsv7qmhmg.jl:20 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpsv7qmhmg.jl:19\ntest set:\
    \ Error During Test at /tmp/tmpsv7qmhmg.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  type Int64 has no field n\n  Stacktrace:\n   [1] getproperty\n\
    \     @ ./Base.jl:42 [inlined]\n   [2] factorize(n::Int64)\n     @ Main /tmp/tmpsv7qmhmg.jl:12\n\
    \   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpsv7qmhmg.jl:21 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpsv7qmhmg.jl:19\ntest set:\
    \ Error During Test at /tmp/tmpsv7qmhmg.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  type Int64 has no field n\n  Stacktrace:\n   [1]\
    \ getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] factorize(n::Int64)\n   \
    \  @ Main /tmp/tmpsv7qmhmg.jl:12\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpsv7qmhmg.jl:22 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpsv7qmhmg.jl:19\ntest set:\
    \ Error During Test at /tmp/tmpsv7qmhmg.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  type Int64 has no field n\n  Stacktrace:\n   [1]\
    \ getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] factorize(n::Int64)\n   \
    \  @ Main /t"
  timestamp: 1659979606
- exit_code: -1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ 2\n    for i in 1:sqrt(n)\n        factors = i * factors\n        if n%factors\
    \ == 0\n            break\n        end\n    end\n    return factors\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\
    \t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57)\
    \ == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Error During Test at /tmp/tmph8894m3n.jl:26\n  Test threw
    exception\n  Expression: candidate(2) == [2]\n  MethodError: Cannot `convert`
    an object of type Float64 to an object of type Vector{Int64}\n  Closest candidates
    are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray
    at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1]
    factorize(n::Int64)\n     @ Main /tmp/tmph8894m3n.jl:19\n   [2] macro expansion\n     @
    ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [3]
    macro expansion\n     @ /tmp/tmph8894m3n.jl:26 [inlined]\n   [4] macro expansion\n     @
    ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [5]
    top-level scope\n     @ /tmp/tmph8894m3n.jl:25\ntest set: Error During Test at
    /tmp/tmph8894m3n.jl:27\n  Test threw exception\n  Expression: candidate(4) ==
    [2, 2]\n  MethodError: Cannot `convert` an object of type Float64 to an object
    of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)
    where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1]
    factorize(n::Int64)\n     @ Main /tmp/tmph8894m3n.jl:19\n   [2] macro expansion\n     @
    ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [3]
    macro expansion\n     @ /tmp/tmph8894m3n.jl:27 [inlined]\n   [4] macro expansion\n     @
    ~/.conda/envs/po'
  timestamp: 1659979607
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n  fs::Vector{Int64}\
    \ = sort(collect(factors(n)))\n  if fs == [1]\n    return [1]\n  end\n  p = product(fs)\n\
    \  fs = filter(x->ismultiple(n,x,fs), fs)\n  c::Vector{Int64} = [1]\n  for i in\
    \ fs\n    push!(c,i)\n  end\n  return c[(p+1):end]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpkkd1nbr8.jl:26

    '
  stdout: "test set: Error During Test at /tmp/tmpkkd1nbr8.jl:29\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  UndefVarError: factors not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpkkd1nbr8.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkkd1nbr8.jl:29 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkkd1nbr8.jl:28\ntest set:\
    \ Error During Test at /tmp/tmpkkd1nbr8.jl:30\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  UndefVarError: factors not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpkkd1nbr8.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkkd1nbr8.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkkd1nbr8.jl:28\ntest set:\
    \ Error During Test at /tmp/tmpkkd1nbr8.jl:31\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  UndefVarError: factors not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpkkd1nbr8.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkkd1nbr8.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkkd1nbr8.jl:28\ntest set:\
    \ Error During Test at /tmp/tmpkkd1nbr8.jl:32\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  UndefVarError: factors not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpkkd1nbr8.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /"
  timestamp: 1659979606
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n == 1\
    \ \n        vectored = [1]\n        return vectored \n    else \n        factors\
    \ = factorization(n)\n        vectored = zeros(Int, length(factors))\n       \
    \ for (i, factor) in enumerate(factors)\n            vectored[factor] += 1\n \
    \       end\n        return vectored\nend\n</cell>\n<code language=julia-1.5>\n\
    @time factorize(100)\n</cell>\n<text>\nFinding perfect numbers\nusing Test\n\n\
    @testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3dss802d.jl:23\nin expression starting at\
    \ /tmp/tmp3dss802d.jl:23\n"
  stdout: ''
  timestamp: 1659979604
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    \"\"\"\n \
    \   Calculate vector of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be vectored number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n \
    \   >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\
    \"\"\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
    \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
    \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\
    \t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp6z1yddcv.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp6z1yddcv.jl:1\n\
    in expression starting at /tmp/tmp6z1yddcv.jl:1\n"
  stdout: ''
  timestamp: 1659979604
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    div = 1:n\n\
    \    div = div[div .!= 0]\n    \n    factor = Vector{Int64}()\n    \n    while\
    \ div.length > 0\n        p = div.pop\n        factor = [p] .+ factor\n      \
    \  for i in div\n            if factor[div .!= i] == p\n                push!(div,\
    \ i)\n            end\n        end\n    end\n    \n    return factor\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\
    \t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57)\
    \ == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp4ydwk7gj.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmp4ydwk7gj.jl:34\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  type Array has no field length\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] factorize(n::Int64)\n\
    \     @ Main /tmp/tmp4ydwk7gj.jl:17\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp4ydwk7gj.jl:34 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp4ydwk7gj.jl:33\ntest set:\
    \ Error During Test at /tmp/tmp4ydwk7gj.jl:35\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  type Array has no field length\n  Stacktrace:\n  \
    \ [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] factorize(n::Int64)\n\
    \     @ Main /tmp/tmp4ydwk7gj.jl:17\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp4ydwk7gj.jl:35 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp4ydwk7gj.jl:33\ntest set:\
    \ Error During Test at /tmp/tmp4ydwk7gj.jl:36\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  type Array has no field length\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] factorize(n::Int64)\n\
    \     @ Main /tmp/tmp4ydwk7gj.jl:17\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp4ydwk7gj.jl:36 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp4ydwk7gj.jl:33\ntest set:\
    \ Error During Test at /tmp/tmp4ydwk7gj.jl:37\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  type Array has no field length\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] factorize(n::I"
  timestamp: 1659979606
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n < 2\n\
    \        return Int64[]\n    end\n    factors = factor(n) \n    if length( factors)\
    \ == 0\n        return [n ]\n    end\n    primeFactors = factorizeHelper(factors)\n\
    \    return primeFactors\nend\n</cell>\n<text>\nThe function factorizeHelper will\
    \ be the most interesting one as it contains all necessary logic to do factorization.\n\
    We have several main goals:\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnyj7n4al.jl:22\nin expression starting at\
    \ /tmp/tmpnyj7n4al.jl:22\n"
  stdout: ''
  timestamp: 1659979604
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    \n    if n\
    \ == 1\n        return [Int64(1)]\n    \n    factors = factorize(n-1)\n    res\
    \ = [Int64(1)]\n    \n    for factor in factors\n        res = [Int64(factor)\
    \ * res | res]\n    end\n    \n    return res\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) ==\
    \ [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\
    \t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3,\
    \ 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18)\
    \ == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp1r230t4k.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp1r230t4k.jl:1\n\
    in expression starting at /tmp/tmp1r230t4k.jl:1\n"
  stdout: ''
  timestamp: 1659979604
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    return Vector{Int64}(repeat(n,n))\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a tags=recursion,primes,julia,math |>\nI think\
    \ I got it to work, here's the code\n<code>\nusing Test\n\n@testset begin\n\n\
    candidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) ==\
    \ [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\
    \t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3,\
    \ 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18)\
    \ == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo15cel9m.jl:14\nin expression starting at\
    \ /tmp/tmpo15cel9m.jl:14\n"
  stdout: ''
  timestamp: 1659979604
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n <= 0\n\
    \        return zeros(1, Int64)\n    end\n    factors = factor(n)\n    count =\
    \ 0\n    push!(factors, 1)\n    for i in factors\n        count += i\n       \
    \ push!(factors, count)\n    end\n    factors\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) ==\
    \ [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\
    \t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3,\
    \ 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18)\
    \ == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpsoulsiyi.jl:26

    '
  stdout: "test set: Error During Test at /tmp/tmpsoulsiyi.jl:29\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  UndefVarError: factor not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpsoulsiyi.jl:15\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpsoulsiyi.jl:29 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpsoulsiyi.jl:28\ntest set:\
    \ Error During Test at /tmp/tmpsoulsiyi.jl:30\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  UndefVarError: factor not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpsoulsiyi.jl:15\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpsoulsiyi.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpsoulsiyi.jl:28\ntest set:\
    \ Error During Test at /tmp/tmpsoulsiyi.jl:31\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  UndefVarError: factor not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpsoulsiyi.jl:15\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpsoulsiyi.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpsoulsiyi.jl:28\ntest set:\
    \ Error During Test at /tmp/tmpsoulsiyi.jl:32\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  UndefVarError: factor not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpsoulsiyi.jl:15\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/"
  timestamp: 1659979606
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n < 2 return\
    \ []\n    factorization = primes(Int(sqrt(n)))\n    factor_counts = Dict{Int64,\
    \ Int}()\n    for factor in factorization\n        factor_counts[factor] = get(factor_counts,\
    \ factor, 0) + 1\n    prime_factorization = factor_counts.keys\n    \n    return\
    \ sort(prime_factorization)\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t\
    @test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249)\
    \ == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t\
    @test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphrhd9qzp.jl:1\nin expression starting at /tmp/tmphrhd9qzp.jl:1\n"
  stdout: ''
  timestamp: 1659979605
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ [i | i <- nfactors(n), n > i]\n    [factors.(i) for i in 1:length(factors)]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
    \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
    \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\
    \t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpbole5kx0.jl:17

    '
  stdout: "test set: Error During Test at /tmp/tmpbole5kx0.jl:20\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  UndefVarError: i not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpbole5kx0.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbole5kx0.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbole5kx0.jl:19\ntest set:\
    \ Error During Test at /tmp/tmpbole5kx0.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  UndefVarError: i not defined\n  Stacktrace:\n   [1]\
    \ factorize(n::Int64)\n     @ Main /tmp/tmpbole5kx0.jl:12\n   [2] macro expansion\n\
    \     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \   [3] macro expansion\n     @ /tmp/tmpbole5kx0.jl:21 [inlined]\n   [4] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbole5kx0.jl:19\ntest set:\
    \ Error During Test at /tmp/tmpbole5kx0.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  UndefVarError: i not defined\n  Stacktrace:\n \
    \  [1] factorize(n::Int64)\n     @ Main /tmp/tmpbole5kx0.jl:12\n   [2] macro expansion\n\
    \     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \   [3] macro expansion\n     @ /tmp/tmpbole5kx0.jl:22 [inlined]\n   [4] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbole5kx0.jl:19\ntest set:\
    \ Error During Test at /tmp/tmpbole5kx0.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  UndefVarError: i not defined\n  Stacktrace:\n  \
    \ [1] factorize(n::Int64)\n     @ Main /tmp/tmpbole5kx0.jl:12\n   [2] macro expansion\n\
    \     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \   [3] macro expansion\n     @ /tmp/tmpbole5kx0.jl:23 [i"
  timestamp: 1659979607
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n        factors\
    \ = []\n        for i in factorization(n)\n            if i != 0\n           \
    \     append!(factors, i)\n            end\n        end\n        return factors\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
    \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
    \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\
    \t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpabq8caa8.jl:22

    '
  stdout: "test set: Error During Test at /tmp/tmpabq8caa8.jl:25\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  UndefVarError: factorization not defined\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmpabq8caa8.jl:13\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpabq8caa8.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpabq8caa8.jl:24\ntest set:\
    \ Error During Test at /tmp/tmpabq8caa8.jl:26\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  UndefVarError: factorization not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpabq8caa8.jl:13\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpabq8caa8.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpabq8caa8.jl:24\ntest set:\
    \ Error During Test at /tmp/tmpabq8caa8.jl:27\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  UndefVarError: factorization not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpabq8caa8.jl:13\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpabq8caa8.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpabq8caa8.jl:24\ntest set:\
    \ Error During Test at /tmp/tmpabq8caa8.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  UndefVarError: factorization not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpabq8caa8.jl:13\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] "
  timestamp: 1659979607
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n == 1\n\
    \        vec = []\n    elseif n == 2\n        vec = [2]\n    elseif isPrime(n)\
    \ && isPrime(n/2)\n        vec = factorize(n/2)\n        push!(vec, 2)\n    end\n\
    \    return vec\nend\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,
    0 broken.

    in expression starting at /tmp/tmp9r1wzw6r.jl:24

    '
  stdout: "test set: Error During Test at /tmp/tmp9r1wzw6r.jl:28\n  Test threw exception\n\
    \  Expression: candidate(4) == [2, 2]\n  UndefVarError: isPrime not defined\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmp9r1wzw6r.jl:16\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9r1wzw6r.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9r1wzw6r.jl:26\ntest set:\
    \ Error During Test at /tmp/tmp9r1wzw6r.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  UndefVarError: isPrime not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmp9r1wzw6r.jl:16\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9r1wzw6r.jl:29 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9r1wzw6r.jl:26\ntest set:\
    \ Error During Test at /tmp/tmp9r1wzw6r.jl:30\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  UndefVarError: isPrime not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmp9r1wzw6r.jl:16\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9r1wzw6r.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9r1wzw6r.jl:26\ntest set:\
    \ Error During Test at /tmp/tmp9r1wzw6r.jl:31\n  Test threw exception\n  Expression:\
    \ candidate(3249) == [3, 3, 19, 19]\n  UndefVarError: isPrime not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmp9r1wzw6r.jl:16\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expa"
  timestamp: 1659979607
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ [1]\n    function factorize(n::Int64)\n        if n == 0\n            return\
    \ factors\n        q = div(n,2)\n        if q == 1\n            factors = [q]\n\
    \        elseif q == 2\n            factors = [2,q]\n        else\n          \
    \  append!(factors, factorize(q)...)\n        end\n        return factorize(n/2)\n\
    \    end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nYou don't need recursive calls.\
    \ `append!` can be used with tuples or vectors (`append!([1,2], [2])`). `append!`\
    \ also does nothing if the vector already contains the element.\n<|/ c |>\n<|\
    \ c |>\nOh, you're right. I don't know how I missed that. Thanks for pointing\
    \ it out.\n<|/ c |>\n<| a tags=primes,algorithm,factors,julia,recursion |>\nHere\
    \ is another answer, which does not use recursion.  It also avoids generating\
    \ and storing multiple copies of the same number.\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgd6dcct7.jl:27\nin expression starting at\
    \ /tmp/tmpgd6dcct7.jl:27\n"
  stdout: ''
  timestamp: 1659979605
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n<2\n \
    \       return Vector[]\n    factors = factorize(n/2)\n    i = 2\n    for factor\
    \ in factors\n        push!(factors, factor)\n    end\n    while i <= sqrt(n)\n\
    \        if n % i == 0\n            push!(factors, i)\n        end\n        i\
    \ += 1\n    end\n    factors\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t\
    @test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249)\
    \ == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t\
    @test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2ts5l29z.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2ts5l29z.jl:1\n\
    in expression starting at /tmp/tmp2ts5l29z.jl:1\n"
  stdout: ''
  timestamp: 1659979606
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    div::Vector{Int64}\
    \ = 1:div(n)\n    divs = div[:]\n    for i in divs\n        if n % i == 0\n  \
    \          if div[i] < divs[end(i)]\n                divs[end(i)] += div[i]\n\
    \            else\n                divs[end(i)] = div[i]\n            end\n  \
    \      end\n    end\n    divs\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\
    \t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249)\
    \ == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t\
    @test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp_2hv9tgx.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmp_2hv9tgx.jl:30\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  UndefVarError: div not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmp_2hv9tgx.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_2hv9tgx.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_2hv9tgx.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp_2hv9tgx.jl:31\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  UndefVarError: div not defined\n  Stacktrace:\n  \
    \ [1] factorize(n::Int64)\n     @ Main /tmp/tmp_2hv9tgx.jl:12\n   [2] macro expansion\n\
    \     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \   [3] macro expansion\n     @ /tmp/tmp_2hv9tgx.jl:31 [inlined]\n   [4] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_2hv9tgx.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp_2hv9tgx.jl:32\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  UndefVarError: div not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmp_2hv9tgx.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_2hv9tgx.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_2hv9tgx.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp_2hv9tgx.jl:33\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  UndefVarError: div not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmp_2hv9tgx.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_2hv9tgx."
  timestamp: 1659979607
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n == 1\n\
    \        return [Int64(1), ]\n    elseif n % 2 == 0 || n < 2\n        return [Int64(2),\
    \ ]\n    elseif n % 3 == 0 || n < 3\n        return [Int64(3), ]\n    else\n \
    \       rest = factorize(n/2) \n        factors = (1..Int(log(rest.last,2))).collect\
    \ {factor -> \n            if rest == factorize(factor)\n                factor\n\
    \            else \n                factor * factorize(factor)\n            }\n\
    \        return factors\n    end\nend\n</cell>\n<text>\nMain function of our program\n\
    We are going to use the factorial function from above and calculate the factorial\
    \ of any number.\nWe will see that our function works with different types of\
    \ numbers, including complex numbers, decimal, matrices, fractions, and even fractions\
    \ with decimal fractions such as 2/3.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\
    \t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249)\
    \ == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t\
    @test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: space before \"{\" not allowed in \"(1 .. Int(log(rest.last,\
    \ 2))).collect {\" at /tmp/tmpnwvecizb.jl:20\nStacktrace:\n [1] top-level scope\n\
    \   @ /tmp/tmpnwvecizb.jl:20\nin expression starting at /tmp/tmpnwvecizb.jl:20\n"
  stdout: ''
  timestamp: 1659979606
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ prime_factorize(n)\n    n = n\n    i = 1\n    for factor in factors\n      \
    \  n *= factor\n        i += 1\n    end\n    return collect(1 : n-1)\nend\n</code>\n\
    <|/ a tags=factors,algorithm,primes,julia dscore=2 |>\n<| a |>\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\
    \t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57)\
    \ == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3eagqx7e.jl:21\nin expression starting at\
    \ /tmp/tmp3eagqx7e.jl:21\n"
  stdout: ''
  timestamp: 1659979605
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    \n    factors\
    \ = []\n    factor = 1\n    \n    for p in primefactors(n)\n        if p != 1\n\
    \            factor /= p\n            factor *= factor\n            factors.push(factor)\n\
    \        end\n    end\n    return factors\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) ==\
    \ [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\
    \t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3,\
    \ 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18)\
    \ == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpnnli9uj6.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmpnnli9uj6.jl:30\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  UndefVarError: primefactors not defined\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmpnnli9uj6.jl:16\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnnli9uj6.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnnli9uj6.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpnnli9uj6.jl:31\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  UndefVarError: primefactors not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpnnli9uj6.jl:16\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnnli9uj6.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnnli9uj6.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpnnli9uj6.jl:32\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  UndefVarError: primefactors not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpnnli9uj6.jl:16\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnnli9uj6.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnnli9uj6.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpnnli9uj6.jl:33\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  UndefVarError: primefactors not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpnnli9uj6.jl:16\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macr"
  timestamp: 1659979608
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factorization\
    \ = [1]\n    primes = primeFactorization(n)\n    for p in primes\n        factorization\
    \ *= p\n    end\n    return factorization\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) ==\
    \ [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\
    \t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3,\
    \ 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18)\
    \ == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpt7wnl8bf.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmpt7wnl8bf.jl:24\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  UndefVarError: primeFactorization not defined\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmpt7wnl8bf.jl:13\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpt7wnl8bf.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpt7wnl8bf.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpt7wnl8bf.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  UndefVarError: primeFactorization not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpt7wnl8bf.jl:13\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpt7wnl8bf.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpt7wnl8bf.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpt7wnl8bf.jl:26\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  UndefVarError: primeFactorization not defined\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmpt7wnl8bf.jl:13\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpt7wnl8bf.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpt7wnl8bf.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpt7wnl8bf.jl:27\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  UndefVarError: primeFactorization not defined\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmpt7wnl8bf.jl:13\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:4"
  timestamp: 1659979608
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    \n    factors=[]\n\
    \    for f in factorize(BigInt(n))\n        push!(factors,f)\n    end\n    return\
    \ factors\nend\n\"\"\"\n    factorize(n::BigInt)::Vector{Int64}\nusing Test\n\n\
    @testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpd2e1cjua.jl:19\nin expression starting at\
    \ /tmp/tmpd2e1cjua.jl:19\n"
  stdout: ''
  timestamp: 1659979606
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    \n    # base\
    \ case: factor is 1, return 1\n    if n == 1\n        vec = [n]\n        return\
    \ vec\n    \n    # find all factors of n, starting from 1\n    \n    # this loop\
    \ finds factors of n and stores in fac[]\n    fac = [1]\n    for i in 1:(n-1)\n\
    \        if n % i == 0\n            push!(fac, i)\n            n = n / i\n   \
    \     end\n    end\n    \n    # this loop factorizes all factors \n    # and stores\
    \ in factors[]\n    factors = Array{Int64}(undef, length(fac))\n    for i = 1:length(fac)\n\
    \        if fac[i] > 1\n            factors[i] = fac[i]\n            factorize(n\
    \ * fac[i])\n        end\n    end\n    \n    # this loop adds n to each factor\
    \ of factors[]\n    \n    for i = 1:length(factors)\n        if !isnothing(factors[i])\n\
    \            push!(factors, n + factors[i])\n        end\n    end\n    \n    return\
    \ factors\nend\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
    \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
    \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\
    \t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpi4zjr4gi.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpi4zjr4gi.jl:1\n\
    in expression starting at /tmp/tmpi4zjr4gi.jl:1\n"
  stdout: ''
  timestamp: 1659979606
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    \n    if n==2\
    \ return [n]\n    \n    p=n\n    f=1\n    s=1\n    while p!=1 && f<=p\n      \
    \  \n        while p%f==0 && f<=p\n            s=s+f\n            f=f+1\n    \
    \    end\n        p=p/f\n        \n        if p>1\n            \n            push!(factorize(p),\
    \ p)\n            f=f+1\n        end\n    end\n    return [1]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp0uzbvx3s.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp0uzbvx3s.jl:1\n\
    in expression starting at /tmp/tmp0uzbvx3s.jl:1\n"
  stdout: ''
  timestamp: 1659979606
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if isPrime(n)\n\
    \        return n::Int64\n    \n        \n        \n        \n        \n     \
    \   \n        \n        \n        \n        \n        \n        \n        \n \
    \       \n        \n        \n        \n        \n        \n        \n       \
    \ \n        \n        \n        \n        \n        \n        \n        \n   \
    \     \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n\nusing\
    \ Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\
    \t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57)\
    \ == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpj6_5wuio.jl:1\nin expression starting at /tmp/tmpj6_5wuio.jl:1\n"
  stdout: ''
  timestamp: 1659979606
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n==1\n\
    \        Vector[1]\n    elseif n mod 2==0\n        factorize(n/2)\n    else\n\
    \        factorize(n/2)*[(n/2)]\n    end\nend\n</cell>\n<text>\nWe know that if\
    \ all factors of the given number are odd, its product is also odd. For example,\
    \ if $8$ has all its factors $3$ and $5$, then the product is $8$, and hence $8$\
    \ has all its factors $3$ and $5$. On the other hand, if it has all its factors\
    \ $3$ and $5$, but one of them is even, then the product is $15$, and hence $15$\
    \ has all its factors $3$ and $5$, and one of them is even.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"2\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpb0ql31pf.jl:14\nin expression starting at /tmp/tmpb0ql31pf.jl:14\n"
  stdout: ''
  timestamp: 1659979606
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    div = 1\n\
    \    sqr = 1\n    factors = []\n    while sqr < n\n        if n % div == 0\n \
    \           factors.push(div)\n            div *= div\n        else\n        \
    \    sqr += div\n            div *= sqr\n        end\n    end\n    factors.push(sqr)\n\
    \    return factors\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\nReturn vector\
    \ of factors of given integer in the order from smallest to largest.\nEach of\
    \ the factors should be vectored number of times corresponding to how many times\
    \ it appeares in factorization.\nInput number should be equal to the product of\
    \ all factors\n\"\"\"\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmph0uc5at0.jl:27\nin expression starting at\
    \ /tmp/tmph0uc5at0.jl:27\n"
  stdout: ''
  timestamp: 1659979607
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    primes = []\n\
    \    i = 0\n    while i < n \n        candidates = prime_candidates(n)\n     \
    \   prime_candidates_length = length(candidates)\n        if prime_candidates_length\
    \ == 0 \n            prime_candidates_length = 1\n        end\nusing Test\n\n\
    @testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"while\" at /tmp/tmp921owlpn.jl:14\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp921owlpn.jl:1\n\
    in expression starting at /tmp/tmp921owlpn.jl:1\n"
  stdout: ''
  timestamp: 1659979607
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ primeFactors(n)\n    factors = filter(x->x==1, factors)\n    return map(x ->\
    \ factors[x], 1:length(factors))\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\
    \t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249)\
    \ == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t\
    @test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpwml22s2f.jl:18

    '
  stdout: "test set: Error During Test at /tmp/tmpwml22s2f.jl:21\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  UndefVarError: primeFactors not defined\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmpwml22s2f.jl:12\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpwml22s2f.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpwml22s2f.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpwml22s2f.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  UndefVarError: primeFactors not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpwml22s2f.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpwml22s2f.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpwml22s2f.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpwml22s2f.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  UndefVarError: primeFactors not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpwml22s2f.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpwml22s2f.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpwml22s2f.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpwml22s2f.jl:24\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  UndefVarError: primeFactors not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpwml22s2f.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macr"
  timestamp: 1659979610
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n <= 0\n\
    \        error(\"Invalid input. factorize() should recieve positive number\")\n\
    \    end\n    factorization = [n]\n    for factor in primes\n        if factor\
    \ * factorization[-1] < n\n            factorization[factor] = n + factorization[factor]\n\
    \        else\n            factorization[factor] += factorization[factor-1]\n\
    \        end\n    end\n    return factorization\nend\n</cell>\n<code language=julia-1.3>\n\
    using Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) ==\
    \ [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t\
    @test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t\
    @test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) ==\
    \ [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpg_1iuuk4.jl:25\nin expression starting at\
    \ /tmp/tmpg_1iuuk4.jl:25\n"
  stdout: ''
  timestamp: 1659979607
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    \"\"\"\n \
    \   >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>>\
    \ factorize(70)\n    [2, 5, 7]\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\
    \t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249)\
    \ == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t\
    @test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp241q2o2a.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp241q2o2a.jl:1\n\
    in expression starting at /tmp/tmp241q2o2a.jl:1\n"
  stdout: ''
  timestamp: 1659979607
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n < 2\n\
    \        return Int64[]\n    else\n        factors = factorize(n/2)\n        l\
    \ = length(factors)\n        Vector{Int64}(repeat(factors, l))\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) ==\
    \ [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t\
    @test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t\
    @test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) ==\
    \ [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpbvdxs36e.jl:22

    '
  stdout: "test set: Error During Test at /tmp/tmpbvdxs36e.jl:25\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  MethodError: no method matching factorize(::Float64)\n\
    \  Closest candidates are:\n    factorize(!Matched::Int64) at /tmp/tmpbvdxs36e.jl:11\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmpbvdxs36e.jl:15\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbvdxs36e.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbvdxs36e.jl:24\ntest set:\
    \ Error During Test at /tmp/tmpbvdxs36e.jl:26\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  MethodError: no method matching factorize(::Float64)\n\
    \  Closest candidates are:\n    factorize(!Matched::Int64) at /tmp/tmpbvdxs36e.jl:11\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmpbvdxs36e.jl:15\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbvdxs36e.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbvdxs36e.jl:24\ntest set:\
    \ Error During Test at /tmp/tmpbvdxs36e.jl:27\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  MethodError: no method matching factorize(::Float64)\n\
    \  Closest candidates are:\n    factorize(!Matched::Int64) at /tmp/tmpbvdxs36e.jl:11\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmpbvdxs36e.jl:15\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbvdxs36e.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbvdxs36e.jl:24\ntest set:\
    \ Error During Test at /tmp/tmpbvdxs36e.jl:28\n  Test thre"
  timestamp: 1659979610
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ Vector{Int64}()\n    factor = 1\n    while n > 1\n        if n % factor\n  \
    \          n /= factor\n        else\n            factor += 1\n        end\n \
    \       push!(factors, factor)\n    end\n    return factors\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp68a9gdhm.jl:26

    '
  stdout: "test set: Error During Test at /tmp/tmp68a9gdhm.jl:29\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  TypeError: non-boolean (Int64) used in boolean\
    \ context\n  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmp68a9gdhm.jl:15\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp68a9gdhm.jl:29 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp68a9gdhm.jl:28\ntest set:\
    \ Error During Test at /tmp/tmp68a9gdhm.jl:30\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  TypeError: non-boolean (Int64) used in boolean context\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmp68a9gdhm.jl:15\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp68a9gdhm.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp68a9gdhm.jl:28\ntest set:\
    \ Error During Test at /tmp/tmp68a9gdhm.jl:31\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  TypeError: non-boolean (Int64) used in boolean\
    \ context\n  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmp68a9gdhm.jl:15\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp68a9gdhm.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp68a9gdhm.jl:28\ntest set:\
    \ Error During Test at /tmp/tmp68a9gdhm.jl:32\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  TypeError: non-boolean (Int64) used in boolean context\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmp68a9gdhm.jl:15\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/"
  timestamp: 1659979610
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n == 1\
    \ return Vector{Int64}(1)\n    ret = factorize(n/2)\n    for i in eachindex(ret)\n\
    \        ret[i] *= 2\n    end\n    return ret\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) ==\
    \ [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\
    \t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3,\
    \ 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18)\
    \ == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp0910d0qw.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp0910d0qw.jl:1\n\
    in expression starting at /tmp/tmp0910d0qw.jl:1\n"
  stdout: ''
  timestamp: 1659979607
- exit_code: -1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors= factorize(n-1)\
    \ #find all factors of n\n    factors = factors .- 1 #remove 1 from factors \n\
    \    factors = factors .* factors #multiply each factor to its number of appearences\
    \ \n    factors = collect(1:length(factors)) \n    for f in factors \n       \
    \ push!(factors,f)\n    end\n    factors\nend \nusing Test\n\n@testset begin\n\
    \ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) ==\
    \ [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\
    \t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3,\
    \ 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18)\
    \ == [2, 3, 3])\nend\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659979612
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    n = round(n,digits=digits)\n\
    \    if n==1\n        return [1]\n    v = factors(n)\n    l = length(v)\n    vecflag\
    \ = vecflag + 1\n    vecflag = vecflag % 2 == 0 ? vecflag + 1 : vecflag\n    factors_tovec\
    \ = [[] for i=1:l]\n    for i = 1:l\n        factors_tovec[sort(v)[i]] = i\n \
    \   end\n    \n    for i=1:l\n        factors_tovec[i] = [1 for j in 1:factors_tovec[i]]\n\
    \    end\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
    \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
    \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\
    \t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnnennr1g.jl:1\nin expression starting at /tmp/tmpnnennr1g.jl:1\n"
  stdout: ''
  timestamp: 1659979608
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n == 1\n\
    \        return [1]\n    \n    factors = factorize(n)\n    \n    if sum(factors)\
    \ > n\n        push!(factors, n)\n    end\n    \n    return factors\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp661oaf9l.jl:23\nin expression starting at\
    \ /tmp/tmp661oaf9l.jl:23\n"
  stdout: ''
  timestamp: 1659979608
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ Vector{Int64}()\n    flag = 1\n    for f in factorization(n)\n        if f !=\
    \ 0\n            flag += 1\n        else\n            factors[end+flag] = f\n\
    \        end\n    end\n    return factors\nend\n\"\"\"\n    factorization(n::Int64)::Vector{Int64}\n\
    using Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) ==\
    \ [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t\
    @test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t\
    @test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) ==\
    \ [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpeud8868v.jl:23\nin expression starting at\
    \ /tmp/tmpeud8868v.jl:23\n"
  stdout: ''
  timestamp: 1659979608
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n<2 return\
    \ []\n    primes = factors(n)\n    \n    factor_count = zeros(Int, length(primes))\n\
    \    for i=1:length(primes)\n        factor_count[i] = 0\n    end\nusing Test\n\
    \n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplbgg2xge.jl:1\nin expression starting at /tmp/tmplbgg2xge.jl:1\n"
  stdout: ''
  timestamp: 1659979608
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factorized_list\
    \ = []\n    factorized_list = [0 for i in 1:n]\n    \n    for x in factorized_list\n\
    \        count = 0\n        \n        if n % x == 0\n            count += 1\n\
    \            \n            while n % x == 0\n                n /= x\n        \
    \        count += 1\n            \n            factorized_list[count] += 1\n \
    \           \n        end\n    end\n    \n    vectored_factorization = Vector{Int64}(factorized_list)\n\
    \    \n    vectored_factorization\nend\n</code>\n<|/ a tags=big-o,julia,algorithm\
    \ |>\n<| c |>\nIt should be noted that this answer only gives factors in the order\
    \ they appear in the factorization, and does not give any information on \"what\
    \ fractional multiples appear in factorization\".\n<|/ c |>\n<| c |>\n: I guess\
    \ your solution is just fine, except that `factorized_list` can be replaced by\
    \ `factorization` directly (which should be `Vector{Int}`, not `Vector{Int64}`).\n\
    <|/ c |>\n<| c |>\n: Ah, yes, you're right about `factorized_list`; I was using\
    \ my own code. I fixed the answer by changing `factorized_list` to `factorization`.\n\
    <|/ c |>\n<| a dscore=2 |>\nI find this to be the simplest solution in Julia\n\
    <code>\nfactorize(70)\n</code>\n<|/ a tags=big-o,julia,algorithm |>\n<| a |>\n\
    Using list comprehension:\n<code>\nusing Test\n\n@testset begin\n\ncandidate =\
    \ factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t\
    @test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249)\
    \ == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t\
    @test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpm8zt2si3.jl:34\nin expression starting at\
    \ /tmp/tmpm8zt2si3.jl:34\n"
  stdout: ''
  timestamp: 1659979608
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    # create factorization\n\
    \    primes = primeFactors(n)\n    factorization = Vector{Int64}(undef, 0)\n \
    \   for prime in primes\n        if n mod prime == 0\n            factorization[factorization[prime]]\
    \ = factorization[prime] + 1\n            factorization[prime] = 1\n        end\n\
    \    end\n    factorization\nend\n</cell>\n<text>\nWrite a function factorize\
    \ that will return a vector of prime factors of a given number\nusing Test\n\n\
    @testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"prime\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmprh3w20rb.jl:16\nin expression starting at /tmp/tmprh3w20rb.jl:16\n"
  stdout: ''
  timestamp: 1659979608
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n==1\n\
    \        return [1]\n    else\n        if isPrime(n)\n            return [2,n]\n\
    \        else\n            n = div(n,2)\n            fac =[1, 1]\n           \
    \ while n != 1\n                fac = fac*(n/2)\n                n = div(n,2)\n\
    \            end\n            return fac\n        end\n    end\nend\n    \n\"\"\
    \"\n    Solve the nth fibonacci number with memoization\n    \n    Input : n,\
    \ a positive integer\n    Returns the nth fibonacci number\n    \n    >>> fib(1)\n\
    \    1\n    >>> fib(2)\n    1\n    >>> fib(10)\n    55\n    \"\"\"\nusing Test\n\
    \n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: cannot document the following expression:\n\nusing Test\n\
    \nStacktrace:\n [1] error(::String, ::String)\n   @ Base ./error.jl:42\n [2] top-level\
    \ scope\n   @ /tmp/tmp09hxskav.jl:29\nin expression starting at /tmp/tmp09hxskav.jl:29\n"
  stdout: ''
  timestamp: 1659979609
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    # initialize\
    \ vectors\n    factors = Vector{Int64}()\n    factor = 1\n    # check if n is\
    \ odd\n    if n & 1 == 1\n        push!(factors, 1)\n        return factors\n\
    \    \n    # find factors\n    for factor in factorization(Int(n))\n        push!(factors,\
    \ factor)\n    end\n    return factors\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\n    findFactors(n)\n    \n    Find factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be vectored number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ Input number should be equal to the product of all factors\n    \"\"\"\nusing\
    \ Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\
    \t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57)\
    \ == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdk7eq_vd.jl:26\nin expression starting at\
    \ /tmp/tmpdk7eq_vd.jl:26\n"
  stdout: ''
  timestamp: 1659979609
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factorization\
    \ = Array{Int64}(undef, length(primes))\n    factorization[1] = primes[1]\n  \
    \  for p in 2:length(primes)\n        if primes[p] <= n\n            factorization[p]\
    \ = primes[p]\n        elseif n % primes[p] == 0\n            factorization[p]\
    \ = primes[p]\n        else\n            factorization[p] = ceil(n / primes[p])\n\
    \        end\n    end\n    return factorization\nend\n</cell>\n<text>\nExercise\
    \ 4: Write a function that can generate all prime factors of a given integer\n\
    using Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) ==\
    \ [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t\
    @test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t\
    @test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) ==\
    \ [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4t7h8the.jl:25\nin expression starting at\
    \ /tmp/tmp4t7h8the.jl:25\n"
  stdout: ''
  timestamp: 1659979609
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    # initialize\
    \ empty vector to store factors\n    factors = Vector{Int64}()\n    # start dividing\
    \ n by all prime factors\n    prime_factorization = primeFactors(n)\n    for factor\
    \ in prime_factorization\n        # check if factor was already in factorization,\
    \ if yes then just append it \n        if factor in factors\n            push!(factors,\
    \ factor)\n        else\n            # if factor was not found in factorization\
    \ then push it into factorization\n            push!(factors, factor)\n      \
    \      # now start dividing n by factor\n            n %= factor\n           \
    \ # repeat till condition is met\n        end\n    end\n    # return factorization\n\
    \    return factors\nend\n</code>\n<|/ a tags=sieve-of-eratosthenes,primes,factors,julia\
    \ |>\n<| c |>\nThank you! This works perfectly. Although I only need it for sieve\
    \ of eratosthenes, I see that there are several other ways to solve this problem.\n\
    <|/ c |>\n<| c |>\nThis code is really slow. Could you please tell me why it takes\
    \ so long? I thought it was O(n^2) complexity but when I tried it on very large\
    \ numbers, it got very slow.\n<|/ c |>\n<| c |>\nYou can't avoid having to loop\
    \ through each `n` to see if it's in factorization. So this solution will take\
    \ O(n^2) time for most cases. You can, however, keep track of prime factors already\
    \ found so as to save some time.\n<|/ c |>\n<| c |>\nOk, thank you. Do you know\
    \ a way to keep track of prime factors already found so as to avoid a loop?\n\
    <|/ c |>\n<| a dscore=4 |>\nI like Chris Rackauckas' solution, but wanted to offer\
    \ a solution using the Sieve of Eratosthenes as well. I think the following will\
    \ be quite a bit faster in practice:\n<code>\nusing Test\n\n@testset begin\n\n\
    candidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) ==\
    \ [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\
    \t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3,\
    \ 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18)\
    \ == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppow_bye1.jl:31\nin expression starting at\
    \ /tmp/tmppow_bye1.jl:31\n"
  stdout: ''
  timestamp: 1659979609
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ [1]\n    if n==1\n        factors\n    elseif n==2\n        [1,1]\n    else\n\
    \        for f in factorize(floor(Int, n/2))\n            if n % f == 0\n    \
    \            push!(factors, f)\n            elseif f > 1\n                factors\
    \ = factors * f\n            end\n        end\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    # Solve the problem using Dynamic Programming\nusing Test\n\n@testset begin\n\n\
    candidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) ==\
    \ [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\
    \t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3,\
    \ 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18)\
    \ == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp62ybs2ek.jl:27\nin expression starting at\
    \ /tmp/tmp62ybs2ek.jl:27\n"
  stdout: ''
  timestamp: 1659979609
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ factorization(n)\n    product = prod(factors)\n    factors = factors.reverse()\n\
    \    factors = sort(factors)\n    primes = [x for x, count in factors ]\n    factors\
    \ = sort(factors)\n    return factors\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\
    \t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249)\
    \ == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t\
    @test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid iteration specification\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpiwlptwnf.jl:16\nin expression starting at\
    \ /tmp/tmpiwlptwnf.jl:16\n"
  stdout: ''
  timestamp: 1659979609
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factorization\
    \ = Factorization(n) \n    factorizations = factorizeAll(factorization) \n   \
    \ factorizations = removeDuplicates(factorizations) \n    factorizations = [i\
    \ for i in factorizations if i != n] \n    return factorizations\nend\n</cell>\n\
    <cell>\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
    \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
    \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\
    \t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4j_t_ejk.jl:18\nin expression starting at\
    \ /tmp/tmp4j_t_ejk.jl:18\n"
  stdout: ''
  timestamp: 1659979609
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    primes = primes(n)\n\
    \    factorized = Vec{Int64}()\n    for p in primes\n        if n % p == 0\n \
    \           factorized *= p\n            n /= p\n            factorized += factorized[n]\n\
    \        end\n    end\n    return factorized\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) ==\
    \ [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t\
    @test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t\
    @test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) ==\
    \ [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7fk70z6n.jl:23\nin expression starting at\
    \ /tmp/tmp7fk70z6n.jl:23\n"
  stdout: ''
  timestamp: 1659979609
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n==1\n\
    \        return [1]\n    \n    if n==2\n        return [1,2]\n    \n    \n   \
    \ if n%3==0\n        return [1,3]\n    \n    if n%5==0\n        return [1,3,5]\n\
    \    \n    if n%7==0\n        return [1,3,5,7]\n    \n    \n    \n    # here we\
    \ get our number's factors\n    factors=[]\n    factor=2\n    while factor<=n\n\
    \        if n%factor==0\n            push!(factors,factor)\n            n//=factor\n\
    \        else\n            factor+=1\n        end\n    end\n    \n    return factors\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
    \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
    \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\
    \t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2vpvhxpw.jl:1\nin expression starting at /tmp/tmp2vpvhxpw.jl:1\n"
  stdout: ''
  timestamp: 1659979609
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    facts::Vector{Int64}=[]\n\
    \    \n    # Initialize list with all factors\n    facts=factors(n)\n    \n  \
    \  # Initialize list with factor numbers\n    fac_num::Int64=0\n    \n    # Loop\
    \ through list of factors and check each of the factors for multiplicity \n  \
    \  for fac in facts\n        if n%fac==0\n            push!(facts, fac)\n    \
    \        push!(fac_num, 1)\n        else\n            fac_num[fac_num.==1]=fac_num[fac_num.==1]+fac_num[fac_num.==fac]\n\
    \        end\n    end\n    return facts\nend\n</cell>\n<text>\nExercise 3: Infinite\
    \ factorial\nLet us consider the factorial function that we have created before\
    \ for finding the factors of a number. Let us now try to use this function to\
    \ find the factorial of number $10$ and see how it works. Let us try to print\
    \ factorial of $10$ on the screen but we do not want to actually calculate the\
    \ factorial of $10$, we want it to print a message and exit the program.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\
    \t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57)\
    \ == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpc4ctwz4f.jl:31\nin expression starting at\
    \ /tmp/tmpc4ctwz4f.jl:31\n"
  stdout: ''
  timestamp: 1659979609
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    \n    if isPrime(n)\n\
    \        return [n]\n    end\n    factors = factorizeVector(n)\n    \n    count\
    \ = 0\n    factors = sort(factors)\n    factors = setdiff(factors, 1)\n    \n\
    \    for f in factors\n        push!(factors, f)\n        count += 1\n    end\n\
    \    \n    return fill(count,length(factors))\nend\n    \nusing Test\n\n@testset\
    \ begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpb_v_g68i.jl:32

    '
  stdout: "test set: Error During Test at /tmp/tmpb_v_g68i.jl:35\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  UndefVarError: isPrime not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpb_v_g68i.jl:13\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpb_v_g68i.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpb_v_g68i.jl:34\ntest set:\
    \ Error During Test at /tmp/tmpb_v_g68i.jl:36\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  UndefVarError: isPrime not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpb_v_g68i.jl:13\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpb_v_g68i.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpb_v_g68i.jl:34\ntest set:\
    \ Error During Test at /tmp/tmpb_v_g68i.jl:37\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  UndefVarError: isPrime not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpb_v_g68i.jl:13\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpb_v_g68i.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpb_v_g68i.jl:34\ntest set:\
    \ Error During Test at /tmp/tmpb_v_g68i.jl:38\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  UndefVarError: isPrime not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpb_v_g68i.jl:13\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /"
  timestamp: 1659979611
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    result = Vector{Int64}()\n\
    \    for factor in factorization(n)\n        push!(result, factor)\n    end\n\
    \    return result\nend\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpwn9fu51n.jl:20

    '
  stdout: "test set: Error During Test at /tmp/tmpwn9fu51n.jl:23\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  UndefVarError: factorization not defined\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmpwn9fu51n.jl:13\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpwn9fu51n.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpwn9fu51n.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpwn9fu51n.jl:24\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  UndefVarError: factorization not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpwn9fu51n.jl:13\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpwn9fu51n.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpwn9fu51n.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpwn9fu51n.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  UndefVarError: factorization not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpwn9fu51n.jl:13\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpwn9fu51n.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpwn9fu51n.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpwn9fu51n.jl:26\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  UndefVarError: factorization not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpwn9fu51n.jl:13\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] "
  timestamp: 1659979612
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n  if n==1 \n \
    \   vec[]=n\n  else\n    factors=factorize(n-1)\n    for f in factors \n     \
    \ vec[]=f\n    end\n  end\n  return vec\nend\n</cell>\n<code language=julia-1.6>\n\
    factorize(14)\n</cell>\n<code language=julia-1.6>\nusing Test\n\n@testset begin\n\
    \ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) ==\
    \ [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\
    \t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3,\
    \ 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18)\
    \ == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplyzgpg8r.jl:22\nin expression starting at\
    \ /tmp/tmplyzgpg8r.jl:22\n"
  stdout: ''
  timestamp: 1659979609
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    \n    factors\
    \ = Set()\n    \n    for factor in factorization(n)\n        if factor in factors\n\
    \            factors.remove(factor)\n        else\n            factors.add(factor)\n\
    \    end\n    \n    return factors\nend\n</cell>\n<code language=julia-1.5>\n\
    @time factorize(10)\n</cell>\n<text>\nPrime factors of $3$ are $3$, $5$, $7$ and\
    \ $11$:\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
    \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
    \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\
    \t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxho445ys.jl:24\nin expression starting at\
    \ /tmp/tmpxho445ys.jl:24\n"
  stdout: ''
  timestamp: 1659979610
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    return factorize(n,\
    \ 1:prod(factorization(n))) \nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t\
    @test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249)\
    \ == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t\
    @test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpois6n1um.jl:16

    '
  stdout: "test set: Error During Test at /tmp/tmpois6n1um.jl:19\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  UndefVarError: factorization not defined\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmpois6n1um.jl:12\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpois6n1um.jl:19 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpois6n1um.jl:18\ntest set:\
    \ Error During Test at /tmp/tmpois6n1um.jl:20\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  UndefVarError: factorization not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpois6n1um.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpois6n1um.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpois6n1um.jl:18\ntest set:\
    \ Error During Test at /tmp/tmpois6n1um.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  UndefVarError: factorization not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpois6n1um.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpois6n1um.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpois6n1um.jl:18\ntest set:\
    \ Error During Test at /tmp/tmpois6n1um.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  UndefVarError: factorization not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpois6n1um.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] "
  timestamp: 1659979612
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ zeros(Int, n+1)\n    for i = 2 to Int(sqrt(n))\n        while n % i == 0\n \
    \           factors[i] += 1\n            n /= i\n    end\n    factors\nend\n</cell>\n\
    <code language=julia-1.0>\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"for\" at /tmp/tmp2vmx14n7.jl:13 expected \"\
    end\", got \"Int\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2vmx14n7.jl:13\n\
    in expression starting at /tmp/tmp2vmx14n7.jl:13\n"
  stdout: ''
  timestamp: 1659979610
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    # Check if\
    \ given number is prime or composite\n    if n % 2 == 1\n        # Even number\
    \ is not prime\n        prime = Vector{Int64}()\n        composite = Vector{Int64}()\n\
    \        return prime ++ composite\n    else\n        # Find prime factors of\
    \ n\n        factors = factor(n) \n        # Check if n is prime by comparing\
    \ factors with all factors of n.\n        # If all factors are equal, then n is\
    \ prime\n        if all(isPrime(factor) for factor in factors)\n            #\
    \ Sort factors from smallest to largest.\n            sorted = sort(factors)\n\
    \            # Multiply sorted factors by their occurances to get unique factors.\n\
    \            factors = sorted .* collect(1:length(sorted))\n            return\
    \ factors\n        else\n            # All factors are not prime so they must\
    \ be composite.\n            # Since all factors are not prime we can simply add\
    \ them to the composite vector.\n            return factors\n        end\n   \
    \ end\nend\n\"\"\"\n    factorize2(n::Int64)::Vector{Int64} \n    # Check if given\
    \ number is prime or composite\n    if n % 2 == 1\n        # Even number is not\
    \ prime\n        prime = Vector{Int64}()\n        composite = Vector{Int64}()\n\
    \        return prime ++ composite\n    else\n        # Find prime factors of\
    \ n\n        factors = factor(n) \n        # Check if n is prime by comparing\
    \ factors with all factors of n.\n        # If all factors are equal, then n is\
    \ prime\n        if all(isPrime(factor) for factor in factors)\n            #\
    \ Sort factors from smallest to largest.\n            sorted = sort(factors)\n\
    \            # Multiply sorted factors by their occurances to get unique factors.\n\
    \            factors = sorted .* collect(1:length(sorted))\n            return\
    \ factors\n        else\n            # All factors are not prime so they must\
    \ be composite.\n            # Since all factors are not prime we can simply add\
    \ them to the composite vector.\n            return factors\n        end\n   \
    \ end\nend\n\"\"\"\n    factorize2(n::Int64)::Vector{Int64} \n    # Check if given\
    \ number is prime or composite\n    if n % 2 == 1\n        # Even number is not\
    \ prime\n        prime = Vector{Int64}()\n        composite = Vector{Int64}()\n\
    \        return prime ++ composite\n    else\n        # Find prime factors of\
    \ n\n        factors = factor(n) \n        # Check if n is prime by comparing\
    \ factors with all factors of n.\n        # If all factors are equal, then n is\
    \ prime\n        if all(isPrime(factor) for factor in factors)\n            #\
    \ Sort factors from smallest \nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: cannot document the following expression:\n\nfactorize2(n::Int64)::Vector{Int64}\n\
    \nStacktrace:\n [1] error(::String, ::String)\n   @ Base ./error.jl:42\n [2] top-level\
    \ scope\n   @ /tmp/tmpqg0d5if3.jl:36\nin expression starting at /tmp/tmpqg0d5if3.jl:36\n"
  stdout: ''
  timestamp: 1659979610
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ [1]\n    \n    for i in 2:n\n        if n % i == 0 \n            push!(factors,\
    \ i)\n            n//=i\n        else\n            push!(factors, 0)\n       \
    \ end\n    end\n    \n    \n    return factors\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) ==\
    \ [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\
    \t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3,\
    \ 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18)\
    \ == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp_qom3jna.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp_qom3jna.jl:31\n  Expression: candidate(2)\
    \ == [2]\n   Evaluated: [1, 2] == [2]\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp_qom3jna.jl:31 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp_qom3jna.jl:30\ntest set: Test Failed at /tmp/tmp_qom3jna.jl:32\n\
    \  Expression: candidate(4) == [2, 2]\n   Evaluated: [1, 2, 0, 0] == [2, 2]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_qom3jna.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_qom3jna.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp_qom3jna.jl:33\n  Expression: candidate(8) == [2, 2, 2]\n\
    \   Evaluated: [1, 2, 0, 4, 0, 0, 0, 0] == [2, 2, 2]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_qom3jna.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_qom3jna.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp_qom3jna.jl:34\n  Expression: candidate(57) == [3, 19]\n \
    \  Evaluated: [1, 0, 3, 0, 0, 0, 0, 0, 0, 0  \u2026  0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0] == [3, 19]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_qom3jna.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_qom3jna.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp_qom3jna.jl:35\n  Expression: candidate(3249) == [3, 3, 19,\
    \ 19]\n   Evaluated: [1, 0, 3, 0, 0, 0, 0, 0, 0, 0  \u2026  0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0] == [3, 3, "
  timestamp: 1659979611
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ factorize(n)\n    factors = Vector{Int64}[factors[i] for i in factors]\n   \
    \ \n    if length(factors) == 0 \n        return [1]\n    elseif length(factors)\
    \ == 1 \n        return factors\n    else\n        return sum(factors)\n    end\n\
    end \n</code>\n<|/ a dscore=2 tags=primes,julia,factorization |>\n<| a |>\nJust\
    \ use factors function from the Factors package (https://github.com/franke/Factors.jl),\
    \ like that:\n<code>\nusing Factors\nusing Test\n\n@testset begin\n\ncandidate\
    \ = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\
    \t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249)\
    \ == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t\
    @test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpn50kmn4o.jl:23\nin expression starting at\
    \ /tmp/tmpn50kmn4o.jl:23\n"
  stdout: ''
  timestamp: 1659979610
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    primes = primeFactors(n)\n\
    \    factors = zeros(length(primes))\n    for p in primes\n        factors[p]\
    \ = factors[p] + 1\n    end\n    return factors\nend\n</cell>\n<code language=julia-0.5>\n\
    factorize(35)\n</cell>\n<code language=julia-0.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) ==\
    \ [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\
    \t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3,\
    \ 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18)\
    \ == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppl46s92r.jl:19\nin expression starting at\
    \ /tmp/tmppl46s92r.jl:19\n"
  stdout: ''
  timestamp: 1659979610
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factorization\
    \ = [2 for i in 2..n]\n    for factor in factorization\n        if n%factor ==\
    \ 0\n            factorization += [factor]\n            n//= factor\n        end\n\
    \    end\n    return factorization\nend\n</code>\nThe factorization is calculated\
    \ using nested loops. As you can see in code above, each of the loop iteration\
    \ iterates through the factors of the given number. Each factor is iterated through\
    \ until all factors of the given number are taken into account. After every iteration,\
    \ I check if the current number has all its factors taken into account, if not,\
    \ I skip the next iteration. \nThe function above is called inside another function\
    \ factorize_all_factors(n::Int64)::Vector{Int64}. This function returns the factorization\
    \ of a number given as a parameter. \n<code>\nusing Test\n\n@testset begin\n\n\
    candidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) ==\
    \ [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\
    \t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3,\
    \ 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18)\
    \ == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_lj6km9_.jl:21\nin expression starting at\
    \ /tmp/tmp_lj6km9_.jl:21\n"
  stdout: ''
  timestamp: 1659979611
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if isPrime(n)\
    \ and n % 2 == 0  && n > 2\n        factors = factorization(n)\n        for factor\
    \ in factors\n            push!(factors, factor)\n        end\n    else\n    \
    \    factors = []\n    end\n    return factors\nend\n</cell>\n<code language=julia-0.6>\n\
    using Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) ==\
    \ [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t\
    @test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t\
    @test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) ==\
    \ [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"n\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp5qdzw2em.jl:12\nin expression starting at /tmp/tmp5qdzw2em.jl:12\n"
  stdout: ''
  timestamp: 1659979611
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ factor(n)\n    product = 1\n    for f in factors\n        product *= f\n   \
    \ end\n    return collect(0:length(factors) - 1).map(i -> ((factors[i])*product))\n\
    end\n</cell>\n<code language=julia-1.0>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\
    \t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249)\
    \ == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t\
    @test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkv4ybr9c.jl:19\nin expression starting at\
    \ /tmp/tmpkv4ybr9c.jl:19\n"
  stdout: ''
  timestamp: 1659979611
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n==1 ||\
    \ n==0\n        factors=[n]\n    else\n        factors=factorize(ceil(n/2))\n\
    \        for j in 1:length(factors)\n            factors[j]*=(factors[j-1]+n%factors[j])\n\
    \        end\n    end\n    return factors\nend\n</cell>\n<code language=julia-1.4>\n\
    factorize(25) # check it work\n</cell>\n<text>\nProblem 7: Finding the multiplicative\
    \ inverses of a large collection of integers\nThe idea of the multiplicative inverse\
    \ is to find the number $x$ such that\n$$ x^A = B^C $$\nwhere $A$ and $B$ are\
    \ known, and $C$ is unknown.\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1_on3z2l.jl:22\nin expression starting at\
    \ /tmp/tmp1_on3z2l.jl:22\n"
  stdout: ''
  timestamp: 1659979611
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ factors(n)\n    factor_count = Dict{Int64, Int64}()\n    for factor in factors\n\
    \        if factor in factor_count\n            factor_count[factor] += 1\n  \
    \      else\n            factor_count[factor] = 1\n        end\n    end\n    \n\
    \    factor_vec = [Int64[] for _ in 1:max(factor_count.values())]\n    \n    for\
    \ factor in factors\n        if factor in factor_count\n            index = factor_count[factor]\n\
    \            factor_vec[index] = factor_vec[index] + 1\n        else\n       \
    \     factor_vec[factor_count(factor)] = factor_vec[factor_count(factor)] + 1\n\
    \        end\n    end\n    \n    return factor_vec\nend\n    \nusing Test\n\n\
    @testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp0u588bdh.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmp0u588bdh.jl:41\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  UndefVarError: factors not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmp0u588bdh.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0u588bdh.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0u588bdh.jl:40\ntest set:\
    \ Error During Test at /tmp/tmp0u588bdh.jl:42\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  UndefVarError: factors not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmp0u588bdh.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0u588bdh.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0u588bdh.jl:40\ntest set:\
    \ Error During Test at /tmp/tmp0u588bdh.jl:43\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  UndefVarError: factors not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmp0u588bdh.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0u588bdh.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0u588bdh.jl:40\ntest set:\
    \ Error During Test at /tmp/tmp0u588bdh.jl:44\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  UndefVarError: factors not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmp0u588bdh.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /"
  timestamp: 1659979613
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    vec = [i \u2208\
    \ factorization(n)] \n    vec\nend\n\"\"\"Return vector of prime factors of given\
    \ integer in the order from smallest to largest.\n    Each of the factors should\
    \ be vectored number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n    >>> factorize(8)\n\
    \    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n   \
    \ [2, 5, 7]\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: cannot document the following expression:\n\nusing Test\n\
    \nStacktrace:\n [1] error(::String, ::String)\n   @ Base ./error.jl:42\n [2] top-level\
    \ scope\n   @ /tmp/tmpc66tbutj.jl:15\nin expression starting at /tmp/tmpc66tbutj.jl:15\n"
  stdout: ''
  timestamp: 1659979611
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    \n    factors\
    \ = []\n    for fin in factorization(n)\n        if fin[1] > 0\n            push!(factors,\
    \ fin[1]*fin[2])\n        end\n    end\n    return factors\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nHow is this different from what was already in his question?\n\
    <|/ c |>\n<| c |>\nIt is not different, but for me, the implementation is cleaner\
    \ compared to mine. \nThe main difference is, I wrote the function which generates\
    \ factorization at one place and calling it at many places in the code, while\
    \ I was writing the function with all the computations inside it. I think these\
    \ two ways are very different. Anyways, I edited my answer.\n<|/ c |>\n<| c |>\n\
    I understand.  What I was saying is that your solution is different from what\
    \ was already given.  It doesn't use the code you posted, which is why it isn't\
    \ an answer.\n<|/ c |>\n<| a tags=primes,julia dscore=0 |>\nAs I wrote in comment,\
    \ here is a version that does not use any external functions.\n<code>\nusing Test\n\
    \n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgsx746rg.jl:21\nin expression starting at\
    \ /tmp/tmpgsx746rg.jl:21\n"
  stdout: ''
  timestamp: 1659979611
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    \n    if n\
    \ < 2\n        return ones(length(n), Int64)\n    end\nusing Test\n\n@testset\
    \ begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpst56mwgr.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpst56mwgr.jl:1\n\
    in expression starting at /tmp/tmpst56mwgr.jl:1\n"
  stdout: ''
  timestamp: 1659979611
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n < 2\n\
    \        return zeros(1)\n    factors = factor(n)\n    vectored_factors = zeros(length(factors))\n\
    \    for k in factors\n        vectored_factors[k] .= k\n    end\n    return vectored_factors\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\
    \t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249)\
    \ == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t\
    @test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5pzycunm.jl:21\nin expression starting at\
    \ /tmp/tmp5pzycunm.jl:21\n"
  stdout: ''
  timestamp: 1659979611
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factorization\
    \ = Vector{Int64}()\n    div = (Int, Int)\n    for factor in factors(n)\n    \
    \    if factor > 1\n            div = (factor, 1)\n        else\n            push!(factorization,\
    \ factor)\n        end\n    end\n    div\nend\n</code>\n<|/ a |>\n<| a |>\nJust\
    \ for fun, I decided to implement a sieve for numbers up to 2^64. Here it is:\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
    \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
    \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\
    \t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvlacbga7.jl:23\nin expression starting at\
    \ /tmp/tmpvlacbga7.jl:23\n"
  stdout: ''
  timestamp: 1659979611
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    n = abs(n)\n\
    \    if n < 2 \n        throw(Exception, \"Invalid input $n. Factorization input\
    \ should be of the form of the number of the products of all factors\")\n    end\n\
    \    \n    primes = prime_vector(n+1)\n    rev_primes = reverse(primes)\n    \n\
    \    factors = Vector{Int64}(undef, 0)\n    \n    for p in primes \n        if\
    \ p == n\n            factors\n        end\n        \n        fac = 0\n      \
    \  for j in rev_primes \n            if p % j == 0 \n                fac += 1\n\
    \                break\n            end\n        end\n        push!(factors, fac)\n\
    \    end\n    \n    factors\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t\
    @test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249)\
    \ == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t\
    @test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpbkfpne4i.jl:41

    '
  stdout: "test set: Error During Test at /tmp/tmpbkfpne4i.jl:44\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  UndefVarError: prime_vector not defined\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmpbkfpne4i.jl:17\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbkfpne4i.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbkfpne4i.jl:43\ntest set:\
    \ Error During Test at /tmp/tmpbkfpne4i.jl:45\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  UndefVarError: prime_vector not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpbkfpne4i.jl:17\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbkfpne4i.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbkfpne4i.jl:43\ntest set:\
    \ Error During Test at /tmp/tmpbkfpne4i.jl:46\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  UndefVarError: prime_vector not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpbkfpne4i.jl:17\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbkfpne4i.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbkfpne4i.jl:43\ntest set:\
    \ Error During Test at /tmp/tmpbkfpne4i.jl:47\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  UndefVarError: prime_vector not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpbkfpne4i.jl:17\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macr"
  timestamp: 1659979614
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factorization\
    \ = factorize(Int, n)\n    return map(x -> n*x, factorization)\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpvliuuhif.jl:17

    '
  stdout: "test set: Error During Test at /tmp/tmpvliuuhif.jl:20\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  MethodError: no method matching factorize(::Type{Int64},\
    \ ::Int64)\n  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmpvliuuhif.jl:12\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvliuuhif.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvliuuhif.jl:19\ntest set:\
    \ Error During Test at /tmp/tmpvliuuhif.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  MethodError: no method matching factorize(::Type{Int64},\
    \ ::Int64)\n  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmpvliuuhif.jl:12\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvliuuhif.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvliuuhif.jl:19\ntest set:\
    \ Error During Test at /tmp/tmpvliuuhif.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  MethodError: no method matching factorize(::Type{Int64},\
    \ ::Int64)\n  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmpvliuuhif.jl:12\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvliuuhif.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvliuuhif.jl:19\ntest set:\
    \ Error During Test at /tmp/tmpvliuuhif.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  MethodError: no method matching factorize(::Type{Int64},\
    \ ::Int64)\n  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmpvliuuhif.jl:12\n\
    \   [2] macro ex"
  timestamp: 1659979615
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n%2 ==\
    \ 0\n        return Vector{Int64}[n]\n    \n    factors = factorize(n/2)\n   \
    \ \n    for factor in factors\n        if factor == n/2\n            factors *=\
    \ factor\n        else\n            factors *= factor + 1\n    end\n    \n   \
    \ return factors\nend\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpk901_yii.jl:1\nin expression starting at /tmp/tmpk901_yii.jl:1\n"
  stdout: ''
  timestamp: 1659979611
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    primes = []\n\
    \    for i in 2:floor(Int, log(n,2))\n        if isPrime(i)\n            primes\
    \ << i\n        end\n    end\n    result = primes[end]\n    for i in primes\n\
    \        result = result*i\n    end\n    return result\nend\n</cell>\n<text>\n\
    Exercise 4:\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
    \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
    \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\
    \t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp65bv15kd.jl:24\nin expression starting at\
    \ /tmp/tmp65bv15kd.jl:24\n"
  stdout: ''
  timestamp: 1659979611
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    \n    if n<0\n\
    \        error(\"The given number is not positive\")\n    end\nusing Test\n\n\
    @testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2xurtkit.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2xurtkit.jl:1\n\
    in expression starting at /tmp/tmp2xurtkit.jl:1\n"
  stdout: ''
  timestamp: 1659979612
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factorization\
    \ = factors(n)\n    n = prod(factorization)\n    vector = zeros(Int, length(n))\n\
    \    for i=1:length(n)\n        vector[i] = factorization[n - i - 1]\n    end\n\
    \    vector\nend\n</cell>\n<code language=julia-1.5>\n@time factorize(832983298)\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\
    \t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249)\
    \ == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t\
    @test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprxryyzkl.jl:20\nin expression starting at\
    \ /tmp/tmprxryyzkl.jl:20\n"
  stdout: ''
  timestamp: 1659979612
- exit_code: -1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n < 2 \n\
    \        factors = [n]\n    else\n        factors = []\n        while n != 1 \n\
    \            append!(factors, (n-1) % (2 ^ (length(factors)+2)))\n           \
    \ n = n / (2 ^ (length(factors)+2))\n        end\n    end\n    return factors\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
    \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
    \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\
    \t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659979616
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n==1 \n\
    \        return [1]\n    factorization = factorize(n-1)\n    factors = []\n  \
    \  for f in factorization\n        if f==0 \n            factors.push(0)\n   \
    \         continue\n        factors.push(f*factorization[f])\n    end\n    return\
    \ factors\nend\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
    \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
    \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\
    \t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpaynyo596.jl:1\nin expression starting at /tmp/tmpaynyo596.jl:1\n"
  stdout: ''
  timestamp: 1659979612
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    primes, i\
    \ = findprimes(n)\n    factors = i==0 ? [1] : factorize(n/primes[end-i])\n   \
    \ i = length(factors)\n    factors = factors[end-i:]\n    for f in factors\n \
    \       push!(factors,1)\n    end\n    return factors\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) ==\
    \ [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t\
    @test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t\
    @test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) ==\
    \ [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing last argument in \"(end - i):\" range\
    \ expression \nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpa8c_j76c.jl:15\n\
    in expression starting at /tmp/tmpa8c_j76c.jl:15\n"
  stdout: ''
  timestamp: 1659979612
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    primes = factorization(n)\
    \ \n    product = 1\n    for p in primes\n        product *= p\n    end\n    ans\
    \ = Int64[]\n    for p in primes\n        push!(ans, product/p)\n    end\n   \
    \ return ans\nend\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t\
    @test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpmu09raff.jl:25

    '
  stdout: "test set: Error During Test at /tmp/tmpmu09raff.jl:28\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  UndefVarError: factorization not defined\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmpmu09raff.jl:12\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpmu09raff.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpmu09raff.jl:27\ntest set:\
    \ Error During Test at /tmp/tmpmu09raff.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  UndefVarError: factorization not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpmu09raff.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpmu09raff.jl:29 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpmu09raff.jl:27\ntest set:\
    \ Error During Test at /tmp/tmpmu09raff.jl:30\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  UndefVarError: factorization not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpmu09raff.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpmu09raff.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpmu09raff.jl:27\ntest set:\
    \ Error During Test at /tmp/tmpmu09raff.jl:31\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  UndefVarError: factorization not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpmu09raff.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] "
  timestamp: 1659979615
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n  vec = Vector{Int64}()\n\
    \  for fac in factorization(n)\n    push!(vec, fac[1])\n  end\n  return vec\n\
    end\n</cell>\n<text>\nQuestion 6. Write function which returns list of prime factors\
    \ of given number. Input number should be equal to the product of all factors\n\
    (Hint: check this link: https://rosettacode.org/wiki/Prime_factors#Julia)\nusing\
    \ Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\
    \t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57)\
    \ == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2lbzh7o8.jl:18\nin expression starting at\
    \ /tmp/tmp2lbzh7o8.jl:18\n"
  stdout: ''
  timestamp: 1659979613
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    prime_arr\
    \ = findfactors(n)\n    factors = []\n    for i in 1:length(prime_arr)\n     \
    \   factors += prime_arr[i]\n    end\n    return factors\nend\n</code>\n<|/ a\
    \ tags=primes,factors,julia |>\n<| a tags=primes,factors,julia dscore=1 |>\nHere's\
    \ my attempt, using primes.jl\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\
    \t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249)\
    \ == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t\
    @test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvb2nr7r1.jl:19\nin expression starting at\
    \ /tmp/tmpvb2nr7r1.jl:19\n"
  stdout: ''
  timestamp: 1659979613
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n        \n   \
    \ factorization = factor(n)\n    \n    \n    return factorization\nusing Test\n\
    \n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk5tyz9ne.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk5tyz9ne.jl:1\n\
    in expression starting at /tmp/tmpk5tyz9ne.jl:1\n"
  stdout: ''
  timestamp: 1659979613
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ Factorization(n)\n    vec = Vector{Int64}()\n    for f in factors\n        push!(vec,\
    \ n)\n        push!(vec, f)\n    end\n    return vec\nend\n</code>\n<|/ a tags=performance,primes,factorization,julia\
    \ dscore=1 |>\n<| c |>\nThank you for taking the time to write a complete answer\
    \ and for the code example. It is a very informative answer, I appreciate that.\
    \ But your first suggestion is about 4 times slower than my original code on my\
    \ machine.\n<|/ c |>\n<| c |>\nYeah, I guess that's because your approach is much\
    \ slower. Your code is doing two redundant things: (1) find factorization of given\
    \ number `n`, then (2) find prime factors out of that factorization. Instead,\
    \ you can just use `factor(n)`, which does both in one step.\n<|/ c |>\n<| c |>\n\
    But that would be much slower, wouldn't it? It would be equivalent to calling\
    \ `factor(n)` for each number in the range `2^n`\n<|/ c |>\n<| c |>\nYeah, I guess\
    \ it's because `factor(n)` is much faster than your approach in some cases (though\
    \ I didn't try it out on bigger numbers than 20), I'll update my answer soon.\n\
    <|/ c |>\n<| c |>\nI updated my answer, it turns out that it doesn't really make\
    \ sense to recalculate all factorization for each number because `factor(n)` already\
    \ gives all the factors of `n` at once. Now I'm curious how to make it much faster.\n\
    <|/ c |>\n<| a |>\nThe first answer given by Yuriy Tachenko was very helpful to\
    \ me. I am adding the final code as an answer here to show you how I ended up\
    \ solving this problem in the end, in case anyone is interested in a Julia solution.\n\
    The basic idea is that we start with numbers in the set {2,3,5,7...,2^k - 1}.\
    \ We then divide those numbers by the largest number in the set. We repeat this\
    \ process for every number in the set. Eventually all the numbers left in the\
    \ set are factors of the number we want to find prime factors for.\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\
    \t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57)\
    \ == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmput60cqvh.jl:20\nin expression starting at\
    \ /tmp/tmput60cqvh.jl:20\n"
  stdout: ''
  timestamp: 1659979613
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    primeFactors\
    \ = factorizePrimes(n)\n    factors = factorization(n)\n    factors = factors.-\
    \ primeFactors\n    factors = sort(factors)\n    return factors\nend\n</cell>\n\
    <code language=julia-0.6>\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpccgv5bvs.jl:18\nin expression starting at\
    \ /tmp/tmpccgv5bvs.jl:18\n"
  stdout: ''
  timestamp: 1659979613
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ []\n    push!(factors, n)\n    for f in factors:\n        if f > 1\n       \
    \     push!(factors, f / f)\n            push!(factors, f % f)\n        end\n\
    \    end\n    factors\nend\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_ealil_l.jl:15\nin expression starting at\
    \ /tmp/tmp_ealil_l.jl:15\n"
  stdout: ''
  timestamp: 1659979613
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factorization\
    \ = factors(n)\n    prime_factors = Set(factorization)\n    factorization1 = Set(factorization)\n\
    \    for prime in prime_factors\n        factorization1 -= factorization\n   \
    \     factorization1 = factorization1 ++ factorization\n    end\n    return prime_factors\
    \ ++ factorization1\nend\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpo_3vnuuz.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpo_3vnuuz.jl:26\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  UndefVarError: factors not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpo_3vnuuz.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpo_3vnuuz.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpo_3vnuuz.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpo_3vnuuz.jl:27\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  UndefVarError: factors not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpo_3vnuuz.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpo_3vnuuz.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpo_3vnuuz.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpo_3vnuuz.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  UndefVarError: factors not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpo_3vnuuz.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpo_3vnuuz.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpo_3vnuuz.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpo_3vnuuz.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  UndefVarError: factors not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpo_3vnuuz.jl:12\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /"
  timestamp: 1659979615
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factorization\
    \ = factorizeInt(n)\n    \n    return factorization\nend\n</cell>\n<cell>\n\"\"\
    \"\nReturns vector of prime factors of given integer in the order from smallest\
    \ to largest.\nInput number should be equal to the product of all factors\n\"\"\
    \"\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
    \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
    \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\
    \t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6wqpa_xi.jl:16\nin expression starting at\
    \ /tmp/tmp6wqpa_xi.jl:16\n"
  stdout: ''
  timestamp: 1659979613
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    # check input\
    \ number\n    if n < 1 || sqrt(n) == Inf \n        return Vector{Int64}()\n  \
    \  end\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
    \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
    \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\
    \t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpxojv4gvt.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpxojv4gvt.jl:1\n\
    in expression starting at /tmp/tmpxojv4gvt.jl:1\n"
  stdout: ''
  timestamp: 1659979613
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factorization\
    \ = Vector{Int64}(ceil(log2(n)))\n    if n == 1\n        return factorization\n\
    \    factorization[1] = 1\n    for d in factorization[2:end]\n        if n % d\
    \ == 0\n            factorization[d] = factorization[d] * d\n            n /=\
    \ d\n        end \n    end\n    factorization\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) ==\
    \ [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\
    \t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3,\
    \ 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18)\
    \ == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp3p42hg75.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp3p42hg75.jl:1\n\
    in expression starting at /tmp/tmp3p42hg75.jl:1\n"
  stdout: ''
  timestamp: 1659979613
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factorizations\
    \ = factors(n)\n    \n    factors = []\n    for factor in factorizations\n   \
    \     factors << factor * factorizations[factor]\n    end\n    \n    return factors\n\
    end\n</cell>\n<code language=julia-1.5>\nfactorize(8) == [2, 2, 2]\n</cell>\n\
    <code language=julia-1.5>\nfactorize(25) == [5, 5]\n</cell>\n<code language=julia-1.5>\n\
    factorize(70) == [2, 5, 7]\n</cell>\n<text>\nNext we will implement primality\
    \ test of number by checking if all factors of number are prime.\nusing Test\n\
    \n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdfx764l_.jl:21\nin expression starting at\
    \ /tmp/tmpdfx764l_.jl:21\n"
  stdout: ''
  timestamp: 1659979613
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factors =\
    \ factor(n)\n    sorted_factors = sort(factors)\n    vec = [sorted_factors[n]]\n\
    \    for f in factors\n        push!(vec, f)\n    end\n    vec\nend\n</cell>\n\
    <code language=julia-1.5>\n#export\nusing Test\n\n@testset begin\n\ncandidate\
    \ = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\
    \t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249)\
    \ == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t\
    @test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbocleqth.jl:20\nin expression starting at\
    \ /tmp/tmpbocleqth.jl:20\n"
  stdout: ''
  timestamp: 1659979613
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n        primeFactors\
    \ = getPrimeFactors(n) \n        newFactors = [] \n        for factor in primeFactors\
    \ \n            if factor == 1 \n                newFactors[length(newFactors)]\
    \ = factor \n            else \n                j = 0\n                while j\
    \ < length(newFactors) \n                    if newFactors[j] == factor \n   \
    \                     j += 1\n                    else \n                    \
    \    newFactors[j] = factor \n                        j += 1\n               \
    \         newFactors[length(newFactors)] = factor \n            end\n        end\n\
    \        return newFactors\nend\n    \nusing Test\n\n@testset begin\n\ncandidate\
    \ = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\
    \t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249)\
    \ == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t\
    @test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"for\" at /tmp/tmpwfwj_ex6.jl:14\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpwfwj_ex6.jl:1\n\
    in expression starting at /tmp/tmpwfwj_ex6.jl:1\n"
  stdout: ''
  timestamp: 1659979614
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    for i in 2:floor(n/2)\n\
    \        factors = factor(n)\n        factor in factors if i <= length(factors)\n\
    \        factors[i] *= i\n    end\n    return factors\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nPlease see my edit, and comment if there are any questions.\n<|/\
    \ c |>\n<| c |>\nThanks! I'm still confused but will try to review this later.\
    \ I don't think this counts as a \"vectorized\" solution because of the loops,\
    \ right? But then again, I could be wrong.\n<|/ c |>\n<| c |>\nVectorized solutions\
    \ would be something like `factorize(n) = sort(factorization(n))` which would\
    \ be `O(nlogn)`. And it would be much faster because of the use of SORT - O(n)\
    \ operations. However, in such vectorized solution you can't get factors themselves,\
    \ only their counts, which is another O(n) operation. So, vectorization doesn't\
    \ help here.\n<|/ c |>\n<| a tags=performance,primes,factors,julia |>\nYou could\
    \ create a hash of all the prime factors of each number and then get the counts\
    \ for the hash. Here's an example with the factors method you suggested:\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) ==\
    \ [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t\
    @test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t\
    @test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) ==\
    \ [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"for\" at /tmp/tmpt4bx2daa.jl:12 expected \"\
    end\", got \"if\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpt4bx2daa.jl:14\n\
    in expression starting at /tmp/tmpt4bx2daa.jl:14\n"
  stdout: ''
  timestamp: 1659979614
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    i = 2\n  \
    \  f = Vec{Int64}()\n    while i <= sqrt(n)\n        if n % i == 0\n         \
    \   f.push(i)\n            n /= i\n        else\n            i += 1\n        \
    \    if n == 1\n                break\n        end\n    end\n    return f\nend\n\
    </cell>\n<code language=julia-0.4>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\
    \t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249)\
    \ == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t\
    @test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7o7i5iwf.jl:26\nin expression starting at\
    \ /tmp/tmp7o7i5iwf.jl:26\n"
  stdout: ''
  timestamp: 1659979613
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    vector = Vector{Int64}()\n\
    \    while n % 2 == 0\n        n = div(n, 2)\n    end\n    while n % 2 == 1\n\
    \        n /= 2\n    end\n    i = 1\n    while i <= sqrt(n)\n        if n % i\
    \ == 0\n            n /= i\n            push!(vector, i)\n        end\n      \
    \  i += 1\n    end\n    push!(vector, 2)\n    return vector\nend\n</cell>\n<text>\n\
    \u0410. \u0413\u0435\u043D\u0435\u0440\u0430\u0446\u0438\u044F \u0442\u0435\u0441\
    \u0442\u043E\u0432\u044B\u0445 \u0434\u0430\u043D\u043D\u044B\u0445\n\u0413\u0435\
    \u043D\u0435\u0440\u0430\u0446\u0438\u044F \u0442\u0435\u0441\u0442\u043E\u0432\
    \u044B\u0445 \u0434\u0430\u043D\u043D\u044B\u0445 \u0441\u043E\u0441\u0442\u043E\
    \u0438\u0442 \u0438\u0437 \u0434\u0432\u0443\u0445 \u0447\u0430\u0441\u0442\u0435\
    \u0439: \u0441\u043E\u0437\u0434\u0430\u043D\u0438\u044F \u0438 \u043E\u0431\u0443\
    \u0447\u0435\u043D\u0438\u044F \u0430\u043B\u0433\u043E\u0440\u0438\u0442\u043C\
    \u043E\u0432 \u0438 \u0442\u0435\u0441\u0442\u0438\u0440\u043E\u0432\u0430\u043D\
    \u0438\u044F. \u041E\u0431\u0443\u0447\u0435\u043D\u0438\u0435 \u0430\u043B\u0433\
    \u043E\u0440\u0438\u0442\u043C\u0430 \u043F\u043E\u0434\u0441\u0447\u0438\u0442\
    \u0430\u0435\u0442\u0441\u044F \u043D\u0430 \u0432\u0445\u043E\u0434 \u0433\u0435\
    \u043D\u0435\u0440\u0430\u0446\u0438\u0438 \u043F\u0440\u043E\u0446\u0435\u0441\
    \u0441\u0430 \u043F\u043E\u0441\u0447\u0438\u0442\u0430\u0435\u0442\u0441\u044F\
    \ \u0438\u0437 \u0444\u0430\u0439\u043B\u0430 \u0434\u0430\u043D\u043D\u044B\u0445\
    , \u043F\u043E\u0441\u0447\u0438\u0442\u0430\u0435\u0442\u0441\u044F \u0438\u0437\
    \ \u043F\u0440\u043E\u0446\u0435\u0441\u0441\u0430 \u0440\u0430\u043D\u0435\u0435\
    \ \u0441\u043D\u043E\u0432\u0430 \u0432 \u0437\u0430\u0432\u0438\u0441\u0438\u043C\
    \u043E\u0441\u0442\u0438 \u043E\u0442 \u043F\u0430\u0440\u0430\u043C\u0435\u0442\
    \u0440\u043E\u0432 \u0430\u043B\u0433\u043E\u0440\u0438\u0442\u043C\u0430 \u0438\
    \ \u0442\u0435\u0441\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F.\n\u0418\
    \u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\u043C \u0444\u0443\u043D\u043A\
    \u0446\u0438\u044E \u0440\u0430\u0441\u0447\u0435\u0442\u0430 \u0447\u0438\u0441\
    \u0435\u043B. \u041F\u0440\u043E\u0433\u0440\u0430\u043C\u043C\u0430 \u0434\u043E\
    \u043B\u0436\u043D\u0430 \u0432\u044B\u043F\u043E\u043B\u043D\u044F\u0442\u044C\
    \u0441\u044F \u0434\u043E \u0442\u0435\u0441\u0442\u0438\u0440\u043E\u0432\u0430\
    \u043D\u0438\u044F, \u043D\u0430 \u043A\u043E\u0442\u043E\u0440\u043E\u0439 \u043E\
    \u043D \u043F\u043E\u043B\u0443\u0447\u0430\u0435\u0442 \u0432\u0445\u043E\u0434\
    \u043D\u0443\u044E \u0434\u0430\u0442\u0430\u0444\u0440\u0435\u0439\u043C \u0432\
    \ \u0434\u0438\u0441\u043A\u0435.\n\u041E\u0442\u043C\u0430\u0441\u0448\u0442\u0430\
    \u0431\u0438\u0440\u0443\u0435\u043C \u0434\u0430\u043D\u043D\u044B\u0435 \u0432\
    \ \u0442\u0435\u0441\u0442\u043E\u0432\u044B\u0439 \u0434\u0438\u0441\u043A, \u0438\
    \u0441\u043F\u043E\u043B\u044C\u0437\u0443\u044F \u0444\u0443\u043D\u043A\u0446\
    \u0438\u044E \u0440\u0430\u0441\u0447\u0435\u0442\u0430 \u0447\u0438\u0441\u0435\
    \u043B.\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
    \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
    \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\
    \t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkje7t4kc.jl:30\nin expression starting at\
    \ /tmp/tmpkje7t4kc.jl:30\n"
  stdout: ''
  timestamp: 1659979614
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    \n    factorization\
    \ = PrimeFactorization(n)\n    primes = factorization[\"primes\"]\n    factors\
    \ = factorization[\"factors\"]\n    \n    \n    result = Vector{Int64}(undef,\
    \ primes.length)\n    for (i, f) in enumerate(factors)\n        if f > 1\n   \
    \         result[i] = f\n        end\n    end\n    \n    return result\nend\n\
    </code>\nTo calculate the factor of a number we can use Sieve of Eratosthenes\
    \ algorithm, which gives us list of all numbers which will be factors of number\
    \ in O(n). Then, for each of them we can find factors and then sum them to get\
    \ the answer.\n<code>\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqakd0qgq.jl:27\nin expression starting at\
    \ /tmp/tmpqakd0qgq.jl:27\n"
  stdout: ''
  timestamp: 1659979614
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n <= 0\n\
    \        error(\"n should be positive\")\n    end\nusing Test\n\n@testset begin\n\
    \ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) ==\
    \ [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\
    \t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3,\
    \ 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18)\
    \ == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmphqnv74v4.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmphqnv74v4.jl:1\n\
    in expression starting at /tmp/tmphqnv74v4.jl:1\n"
  stdout: ''
  timestamp: 1659979614
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    ans=[1]\n\
    \    for i in 2:(n/2)\n        if n%i==0\n            push!(ans,i)\n         \
    \   n=n/i\n        else\n            break\n        end\n    end\n    return ans\n\
    end\n</cell>\n<code language=julia-0.6>\nfactorize(30)\n</cell>\n<text>\nHow many\
    \ divisors does a number have?\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo6em2d8a.jl:23\nin expression starting at\
    \ /tmp/tmpo6em2d8a.jl:23\n"
  stdout: ''
  timestamp: 1659979614
- exit_code: -1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    factor <-\
    \ factorize(n)\n    factor\nend\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659979619
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    divisors =\
    \ Array{Int64, 1}()\n    for i in 1:n\n        divisors = divisors .+ (n-i).fdiv(i)\n\
    \    end\n    divisors\nend\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpla5gsit6.jl:20

    '
  stdout: "test set: Error During Test at /tmp/tmpla5gsit6.jl:23\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  type Int64 has no field fdiv\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] factorize(n::Int64)\n\
    \     @ Main /tmp/tmpla5gsit6.jl:14\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpla5gsit6.jl:23 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpla5gsit6.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpla5gsit6.jl:24\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  type Int64 has no field fdiv\n  Stacktrace:\n   [1]\
    \ getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] factorize(n::Int64)\n   \
    \  @ Main /tmp/tmpla5gsit6.jl:14\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpla5gsit6.jl:24 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpla5gsit6.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpla5gsit6.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  type Int64 has no field fdiv\n  Stacktrace:\n \
    \  [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] factorize(n::Int64)\n\
    \     @ Main /tmp/tmpla5gsit6.jl:14\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpla5gsit6.jl:25 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpla5gsit6.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpla5gsit6.jl:26\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  type Int64 has no field fdiv\n  Stacktrace:\n  \
    \ [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] factorize(n::Int64)\n\
    \  "
  timestamp: 1659979616
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    ans = Array{Int64}(length(primes))\n\
    \    for (i, p) in enumerate(primes)\n        if n % p == 0\n            ans[i]\
    \ += 1\n            n /= p\n        else\n            ans[i] -= 1\n          \
    \  if n == 1\n                ans[i] = 0\n                break\n            end\n\
    \        end\n    end\n    return ans\nend\n</code>\nThen just call it from the\
    \ main function:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmo8cibf6.jl:27\nin expression starting at\
    \ /tmp/tmpmo8cibf6.jl:27\n"
  stdout: ''
  timestamp: 1659979615
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n % 2 ==\
    \ 0 \n        primes = primes_list(2)\n        while n % primes[1] == 0\n    \
    \        primes = primes_list(primes[1])\n        end\n        return [primes[1],\
    \ primes[1]]\n    else\n        primes = primes_list(n)\n        while n % primes[1]\
    \ == 0\n            primes = primes_list(primes[1])\n        end\n        return\
    \ [primes[1], primes[1]]\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\
    \t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249)\
    \ == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t\
    @test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpg265yype.jl:28

    '
  stdout: "test set: Error During Test at /tmp/tmpg265yype.jl:31\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  UndefVarError: primes_list not defined\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmpg265yype.jl:13\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpg265yype.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpg265yype.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpg265yype.jl:32\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  UndefVarError: primes_list not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpg265yype.jl:13\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpg265yype.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpg265yype.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpg265yype.jl:33\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  UndefVarError: primes_list not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpg265yype.jl:13\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpg265yype.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpg265yype.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpg265yype.jl:34\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  UndefVarError: primes_list not defined\n  Stacktrace:\n\
    \   [1] factorize(n::Int64)\n     @ Main /tmp/tmpg265yype.jl:19\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro ex"
  timestamp: 1659979616
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    # return Vector{Int64}(n)\n\
    \    n %= max_num_primes\n    primeFactors = primeFactorization(n)\n    factors\
    \ = Dict{Int, Int}()\n    for (p, count) in primeFactors\n        factors[p] =\
    \ count\n    end\n    return primeFactors[end][1] == n ? collect(values(factors))\
    \ : factorize(n-factors[end])\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\
    \t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57)\
    \ == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpb5sbig4h.jl:21\nin expression starting at\
    \ /tmp/tmpb5sbig4h.jl:21\n"
  stdout: ''
  timestamp: 1659979615
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    \"\"\"\n \
    \   Function that calculates factors and returns them in correct order.\n    Input\
    \ number should be equal to the product of all factors\n    >>> factorize(8)\n\
    \    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n   \
    \ [2, 5, 7]\n    \"\"\"\n</code>\n<|/ a dscore=0 tags=python,primes,algorithm,math,factorization\
    \ |>\n<| c |>\nThis would be a better answer if you explained how the code you\
    \ provided answers the question.\n<|/ c |>\n<| c |>\nI agree but I have tried\
    \ the code on the website and it has some errors. But I am just learning python.\
    \ Hope that helps.\n<|/ c |>\n<| c |>\nThank you very much. I have updated the\
    \ answer with the explanation.\n<|/ c |>\n<| a dscore=0 tags=python,primes,algorithm,math,factorization\
    \ |>\nI made a small function that calculates how many factors there are:\n<code>\n\
    import math\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
    \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
    \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\
    \t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcidoxuny.jl:22\nin expression starting at\
    \ /tmp/tmpcidoxuny.jl:22\n"
  stdout: ''
  timestamp: 1659979615
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    \n    return\
    \ prime_factorization(n) .+ [prod(factorial(r) for r in prime_factorization(n))]\
    \ \nend\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
    \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
    \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\
    \t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp9zog1lxl.jl:17

    '
  stdout: "test set: Error During Test at /tmp/tmp9zog1lxl.jl:20\n  Test threw exception\n\
    \  Expression: candidate(2) == [2]\n  UndefVarError: prime_factorization not defined\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmp9zog1lxl.jl:13\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9zog1lxl.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9zog1lxl.jl:19\ntest set:\
    \ Error During Test at /tmp/tmp9zog1lxl.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(4) == [2, 2]\n  UndefVarError: prime_factorization not defined\n \
    \ Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmp9zog1lxl.jl:13\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9zog1lxl.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9zog1lxl.jl:19\ntest set:\
    \ Error During Test at /tmp/tmp9zog1lxl.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(8) == [2, 2, 2]\n  UndefVarError: prime_factorization not defined\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmp9zog1lxl.jl:13\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9zog1lxl.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9zog1lxl.jl:19\ntest set:\
    \ Error During Test at /tmp/tmp9zog1lxl.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(57) == [3, 19]\n  UndefVarError: prime_factorization not defined\n\
    \  Stacktrace:\n   [1] factorize(n::Int64)\n     @ Main /tmp/tmp9zog1lxl.jl:13\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test."
  timestamp: 1659979617
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    x = 1\n  \
    \  factors = []\n    while x * x <= n\n        x = x * x\n        factors.push(x)\n\
    \    end\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
    \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
    \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\
    \t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpn2dd570w.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpn2dd570w.jl:1\n\
    in expression starting at /tmp/tmpn2dd570w.jl:1\n"
  stdout: ''
  timestamp: 1659979615
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    \n    primes\
    \ = primefactors(n)\n    \n    factorization = Vector{Int64}(primes.length + 1)\n\
    \    \n    for number in primes\n        \n        if number == 1\n          \
    \  factorization[1] = 1\n        else\n            \n            factorization[1]\
    \ = number\n            for ii in 2:factorization[1]\n                \n     \
    \           if number % ii == 0\n                    factorization[ii] = factorization[ii]\
    \ * number\n                end\n            end\n            \n        end\n\
    \    end\n    \n    return factorization\nend\n</cell>\n<code language=julia-1.0>\n\
    factorize(100)\n</cell>\n<code language=julia-1.0>\nusing Test\n\n@testset begin\n\
    \ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) ==\
    \ [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\
    \t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3,\
    \ 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18)\
    \ == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmph1hhxt7q.jl:36\nin expression starting at\
    \ /tmp/tmph1hhxt7q.jl:36\n"
  stdout: ''
  timestamp: 1659979615
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    if n < 2\n\
    \        return [1,1]\n    factors = factorize(n-1)\n    ret = Vector{Int64}()\n\
    \    for f in factors\n        for i = 1:f\n            push!(ret,i)\n       \
    \ end\n    end\n    return ret\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\
    \t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249)\
    \ == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t\
    @test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp4zm8fsww.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp4zm8fsww.jl:1\n\
    in expression starting at /tmp/tmp4zm8fsww.jl:1\n"
  stdout: ''
  timestamp: 1659979615
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    vec = Vector{Int64}(n)\n\
    \    for i in 1:n\n        flag = 0\n        for j=1:i\n            if i %% j\
    \ == 0\n                flag = 1\n                break\n            end\n   \
    \     end\n        if flag\n            push!(vec, i)\n        end\n    end\n\
    \    vec\nend\n</cell>\n<text>\nProblem 10\nImplement Fibonacci function\nusing\
    \ Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\
    \t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57)\
    \ == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"%\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpeqbna8al.jl:16\nin expression starting at\
    \ /tmp/tmpeqbna8al.jl:16\n"
  stdout: ''
  timestamp: 1659979615
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    \n    factors\
    \ = factorize_prime(n);\n    factorized_number = prod(factors);\n    \n    factorized_number;\n\
    end\n</cell>\n<text>\nTask 4\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\
    \t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8)\
    \ == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) ==\
    \ [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmps42lvrhx.jl:18\nin expression starting at\
    \ /tmp/tmps42lvrhx.jl:18\n"
  stdout: ''
  timestamp: 1659979615
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    vec = [n for\
    \ i <- 1:factor(n)]\n    while isPrime(vec)\n        vec = vec .- vec[1]\n   \
    \ end\n    return vec\nend\n</code>\n<|/ a dscore=2 |>\n<| a |>\nAs you pointed\
    \ out yourself in a comment, there is no need to rewrite isPrime yourself. As\
    \ far as I understand, the question asked for a function which would return all\
    \ prime factors of a given number. So, here is an answer which does it:\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) ==\
    \ [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t\
    @test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t\
    @test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) ==\
    \ [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid iteration specification\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpx39vx38m.jl:12\nin expression starting at\
    \ /tmp/tmpx39vx38m.jl:12\n"
  stdout: ''
  timestamp: 1659979615
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    vec = []\n\
    \    for i in factors(n)\n        if n mod i == 0\n            vec += [i] * factorial(n\
    \ / i)\n        end\n    end\n    return vec\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) ==\
    \ [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\
    \t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3,\
    \ 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18)\
    \ == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"i\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpq_a6_g24.jl:14\nin expression starting at /tmp/tmpq_a6_g24.jl:14\n"
  stdout: ''
  timestamp: 1659979615
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    x = 2\n  \
    \  y = 0\n    while x*x <=n && y<=n \n        if n % x == 0 \n            x +=\
    \ 1\n        else \n            y += 1\n    end\nusing Test\n\n@testset begin\n\
    \ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) ==\
    \ [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\
    \t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3,\
    \ 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18)\
    \ == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"while\" at /tmp/tmpq77x0dcz.jl:14\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpq77x0dcz.jl:1\n\
    in expression starting at /tmp/tmpq77x0dcz.jl:1\n"
  stdout: ''
  timestamp: 1659979615
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    prime_factors\
    \ = []\n    factors = prime_factor_factorization(n)\n    \n    for factor in factors\
    \ do\n        prime_factors += factor\n    end\n    return prime_factors\nend\n\
    </cell>\n<code language=julia-1.5>\nprime_factorize(12)\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) ==\
    \ [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t\
    @test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t\
    @test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) ==\
    \ [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpa_qnn_zo.jl:15\nin expression starting at /tmp/tmpa_qnn_zo.jl:15\n"
  stdout: ''
  timestamp: 1659979615
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    primes = factors(n)\n\
    \    prime_vects = Vector{Int64}()\n    for p in primes\n        prime_vects =\
    \ push!(prime_vects, factorize(p))\n    end\n    return prime_vects\nend\n</cell>\n\
    <text>\nNext, we have to implement multiplication of two matrices. As an example,\
    \ consider matrix multiplication in which two matrices are multiplied element-wise:\n\
    using Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) ==\
    \ [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t\
    @test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t\
    @test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) ==\
    \ [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8tbvr4i2.jl:19\nin expression starting at\
    \ /tmp/tmp8tbvr4i2.jl:19\n"
  stdout: ''
  timestamp: 1659979616
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    \n    if n\
    \ < 2\n        return Vector{Int64}()\n    elseif n == 0\n        return [1]\n\
    \    else\n        factors = factorize(n/2)\n        new_factors = factors\n \
    \       for f in factors\n            if n % f == 0\n                push!(new_factors,\
    \ f)\n            end\n        end\n        return collect(new_factors) ++ factors\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\nfactorize(5)\n</cell>\n<code\
    \ language=julia-1.5>\nfactorize(8)\n</cell>\n<code language=julia-1.5>\nfactorize(25)\n\
    </cell>\n<code language=julia-1.5>\nfactorize(70)\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) ==\
    \ [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t\
    @test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t\
    @test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) ==\
    \ [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpx3ylninx.jl:28\nin expression starting at\
    \ /tmp/tmpx3ylninx.jl:28\n"
  stdout: ''
  timestamp: 1659979616
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    largest =\
    \ sqrt(n)\n    factorization = Vector{Int64}()\n    for div in factorrange(n)\n\
    \        if div == largest\n            factorization += div\n        else\n \
    \           factorization += div\n            while div % div == 0\n         \
    \       div *= div\n            factorization += div\n        end\n    end\n \
    \   factorization\nend\n</cell>\n<code language=julia-1.4>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4)\
    \ == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3,\
    \ 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193)\
    \ == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t\
    @test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6e527ac5.jl:26\nin expression starting at\
    \ /tmp/tmp6e527ac5.jl:26\n"
  stdout: ''
  timestamp: 1659979616
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    # Input number\
    \ should be equal to the product of all factors\n    if n == 0\n        Vector{Int64}()\n\
    \    else\n        factors = factor(n)\n        l = length!(factors)\n       \
    \ Vector{Int64}(undef, l) \n        for f in factors\n            push!(factors,\
    \ f) \n        end\n        factors\n    end\nend\n\"\"\"\n    factorize_vec(v::Vector{Int64})\n\
    \    Returns the factorization of vector\n    \"\"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) ==\
    \ [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\
    \t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3,\
    \ 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18)\
    \ == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: cannot document the following expression:\n\nusing Test\n\
    \nStacktrace:\n [1] error(::String, ::String)\n   @ Base ./error.jl:42\n [2] top-level\
    \ scope\n   @ /tmp/tmp8d94z6hq.jl:25\nin expression starting at /tmp/tmp8d94z6hq.jl:25\n"
  stdout: ''
  timestamp: 1659979617
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    result = Set()\n\
    \    factorial = 1\n    for prime in primefactors(n)\n        factorial = factorial\
    \ * prime\n        push!(result, factorial)\n    end\n    return result\nend\n\
    </cell>\n<cell>\n@test factorize(8) == [2, 2, 2]\n@test factorize(25) == [5, 5]\n\
    @test factorize(70) == [2, 5, 7]\n</cell>\n<text>\nWhat if I want to find the\
    \ factorization of a number that has more than 100 digits in the form of 10^1000\
    \ digits. What would be the best way to get the factorization? Let's look at the\
    \ time complexity of the function factorize. According to BigOh notation, it is\
    \ $O(\\sqrt{n})$, which is very slow. Let's check the time for different values\
    \ of $n$\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2)\
    \ == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\
    \t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\
    \t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577)\
    \ == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkoa3gev1.jl:20\nin expression starting at\
    \ /tmp/tmpkoa3gev1.jl:20\n"
  stdout: ''
  timestamp: 1659979616
- exit_code: 1
  program: "\"\"\" Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8)\n    [2,\
    \ 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5,\
    \ 7]\n    \"\"\"\nfunction factorize(n::Int64)::Vector{Int64} \n    i = 2\n  \
    \  factors = Vector{Int64}(length(factorization(n)))\n    while factorization(n)\
    \ % i == 0\n        i += 1\n    end\n    while i <= sqrt(n)\n        if factorization(n)\
    \ mod i == 0\n            factors = append!(factors, i)\n        end\n       \
    \ i += 1\n    end\n    return factors\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\
    \t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249)\
    \ == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t\
    @test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"i\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpttftm04j.jl:18\nin expression starting at /tmp/tmpttftm04j.jl:18\n"
  stdout: ''
  timestamp: 1659979616
