name: HumanEval_12_longest
language: jl
prompt: "\"\"\" Out of vector of strings, return the longest one. Return the first\
  \ one in case of multiple\n    strings of the same length. Return nothing in case\
  \ the input vector is empty.\n    >>> longest([])\n    nothing\n    >>> longest([\"\
  a\", \"b\", \"c\"])\n    \"a\"\n    >>> longest([\"a\", \"bb\", \"ccc\"])\n    \"\
  ccc\"\n    \"\"\"\nfunction longest(strings::Vector{String})::Union{String, Nothing}\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = longest;\n\t@test(candidate(Vector{String}([]))\
  \ == nothing)\n\t@test(candidate([\"x\", \"y\", \"z\"]) == \"x\")\n\t@test(candidate([\"\
  x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")\nend\n"
completions: ["    if not strings, return nothing\n    longeststr = nothing\n    \n\
    \    for (index, s) in ipairs(strings)\n        if longeststr != nothing\n   \
    \         if length(s) > length(longeststr)\n                longeststr = s\n\
    \            end\n        else\n            longeststr = s\n        end\n    end\n\
    \    return longeststr\nend\n</cell>\n<code language=julia-1.0>\nlongest([\"a\"\
    , \"bb\", \"ccc\"])\n</cell>\n<text>\nThe function above can now be used inside\
    \ a fold expression:", "    if length(strings) == 0\n        return nothing\n\
    \    else if length(strings) == 1 || isequal(strings[1], strings[2])\n       \
    \ return strings[1]\n    end\n    longest_length = -1\n    for str in strings\n\
    \        if isequal(str, strings[longest_length])\n            longest_length\
    \ += 1\n        elseif length(str) > longest_length\n            longest_length\
    \ = length(str) \n        end\n    end\n    return strings[longest_length]\nend\n\
    </code>\n<|/ a |>\n<| c |>\nAs a side note for anybody who comes across: This\
    \ method is called `maximum` in Mathematica. `longest` has nothing to do with\
    \ the Mathematica library for lists/vectors.\n<|/ c |>\n<| a dscore=3 |>\nThis\
    \ problem has already been addressed by the Mathematica-answers and I thought\
    \ I would offer my own solution to my own question for the sake of completeness.\
    \ Since I never seem to have found a good solution, I thought I'd share my own\
    \ solution here so others might find it useful.\nI wanted to find the longest\
    \ substring in a list of strings. Since I wanted to avoid looping, I used recursion.\n\
    The solution I found here was as follows:\n<code>\nlongest(lstStrings::Vector[String])\
    \ =\n    First[lstStrings, longestRecursive[lstStrings, 0]]", "    longest_len\
    \ = 1\n    for i in strings\n        if length(i) > longest_len\n            longest_len\
    \ = length(i)\n        end\n    end\n    if longest_len > 1\n        return strings[longest_len]\n\
    \    else\n        return nothing\n    end\nend", "    if strings.length() ==\
    \ 0 \n        return nothing \n    else \n        longest_string = strings[length(strings)]\
    \ \n        for i in length(strings)+1 : \n            if strings[i] != longest_string\
    \ \n                longest_string = strings[i] \n    return longest_string \n\
    endfunction \n</code>\n<|/ a tags=julia,string |>\n<| a tags=julia,string |>\n\
    In general cases, you cannot know whether a string is shorter than all other strings,\
    \ or longer than all other strings, so you can not guarantee that any particular\
    \ string is lexicographically earlier or later than all other strings. For example,\
    \ if we had the following strings:\n<code>\n\"aaa\"\n\"aba\"\n\"abb\"\n\"acb\"\
    \n\"baa\"\n</code>\nthen there is no clear order, as both strings have length\
    \ 3.\nIf you want to sort strings by their lengths, you can define an ordering\
    \ like so:\n<code>\njulia> struct LengthOrdering end", "    if isempty(strings)\n\
    \        return nothing\n    end\n    return longest_helper(strings[1:end-1],\
    \ lengths(strings))\nend", "    if length(strings) == 0\n        nothing\n   \
    \ elseif length(strings) == 1\n        first(strings)\n    else\n        longest(sort!(lengths(strings)))\n\
    \    end\nend\n</code>\nA few comments on the previous implementation:\nThe sort\
    \ call at the start is unnecessary because lengths returns a Vector{Int}. sort\
    \ will sort the indices in the vector in increasing order, and then we can get\
    \ the lengths by indexing the vector.\nThe sorting is done on the fly so sorting\
    \ an immutable vector is faster than sorting a mutable one.\nThe sort call at\
    \ the end will sort the indices of the vector, and then we need to get the lengths\
    \ of those indices by indexing the vector. This is done by first getting the lengths\
    \ with lengths, then sorting those lengths, and then indexing the vector of strings\
    \ to get our result.\nFor this implementation to work correctly, the vector of\
    \ strings must have unique strings; otherwise, longest(strings) will return the\
    \ last string in the vector.\n<|/ a |>\n<| c |>\nThat's what I call an elaborate\
    \ answer! Thanks a lot for making it clear and sharing your knowledge. I'll read\
    \ up on this topic further and try to understand it myself and implement it myself\
    \ in my code. :)\n<|/ c |>\n<| c |>\nNice answer! I didn't know `sort!(...)` could\
    \ be used like that. Learned something new today.\n<|/ c |>\n<| c |>\n: I didn't\
    \ know `sort!(...)` could be used like that. Learned something new today.\n<|/\
    \ c |>\n<| c |>\nIt took me a while to understand, but I think you made it much\
    \ easier for a beginner like me! Thanks a lot. :)\n<|/ c |>\n<| c |>\n: I didn't\
    \ know `sort!(...)` could be used like that. Learned something new today.\n<|/\
    \ c |>\n<| a tags=max,sorting,julia,string |>\nIf you use an immutable array as\
    \ the data structure for your strings, then you can simply use max_by:\n<code>\n\
    julia> using Random\njulia> s = rand(5,3)\n5-element Array{Any,1}:\n \"A\"\n \"\
    B\"\n \"C\"\n \"D\"\n \"E\"", "    # Your code here\n    if length(strings) <\
    \ 1\n        nothing\n    else\n        maximum(strings)\n    end\nend\n</code>\n\
    <|/ a tags=julia |>\n<| a dscore=1 |>\nI assume that you want to find the longest\
    \ string from a vector of strings (i.e. the function to be called longest)\nI\
    \ would do something like this:\n<code>\nlongest(s::Vector{String}) = maximum([length(s)\
    \ if length(s) > length(longest(s)) for s in s])\n</code>\n<|/ a tags=julia |>\n\
    <| c |>\nThis should be much faster than a for loop\n<|/ c |>\n<| a dscore=0 tags=julia\
    \ |>\nA very naive implementation of the longest string in a vector:\n<code>",
  "    \n    longest = strings[length(strings)]\n    \n    if isempty(strings)\n \
    \       return nothing\n    else\n        return longest\nend", "    if is_empty(strings)\
    \ return nothing\n    lengths = [length(word) for word in strings]\n    i = findmin(lengths)\n\
    \    return strings[i]\nend\n</cell>\n<code language=julia-1.0>\nlongest([\"a\"\
    , \"b\", \"c\"])\n</cell>\n<code language=julia-1.0>\nlongest([\"a\", \"bb\",\
    \ \"ccc\"])\n</cell>\n<text>\nExercise 3\nGiven the vectors words = [\"abba\"\
    , \"cba\", \"da\", \"dede\"], words_dict = [(1, \"abba\"), (2, \"cba\"), (3, \"\
    da\"), (4, \"dede\")], find the longest common substring in each dictionary element.",
  "    # O(n) (but could also be O(1))\n    max_length = 0\n    max_length_string\
    \ = \"\"\n    for i in strings\n        len = length(i)\n        if len > max_length\n\
    \            max_length = len\n            max_length_string = i\n        end\n\
    \    end\n    return max_length_string\nend", "    if length(strings) == 0 \n\
    \        return nothing \n    else \n        return strings[end] # return the\
    \ last item \nend\n</code>\n<|/ a dscore=2 tags=julia |>\n<| c |>\nI like that\
    \ it doesn't require the length to be known ahead of time to be used.\n<|/ c |>\n\
    <| a tags=julia |>\nIf you just want to find the longest string, you don't need\
    \ to sort or use indexing, you can just use max\n<code>\njulia> longest(words)\n\
    \"and\"\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia |>\n<code>", "    if strings.length==0\n\
    \        nothing\n    else\n        longest_idx=0\n        longest=strings[longest_idx]\n\
    \        for idx=1:length(strings)\n            if length(strings[idx])>length(longest)\n\
    \                longest_idx=idx\n                longest=strings[longest_idx]\n\
    \            end\n        end\n        return longest\n    end\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=1 |>\nIn addition to the other solutions: this\
    \ could be done with Julia's extreme collection comprehension syntax (assuming\
    \ strings is an Array{String,1}):\n<code>\nstrings = [\n    \"a string\",\n  \
    \  \"another string\",\n    \"yet another string\",\n    \"yet another string\"\
    ,\n]", "    for s in strings \n        if length(s) > length(longest(s)) \n  \
    \          longest(s)\n        end\n    end\nend\n</code>\n<|/ a |>\n<| a |>\n\
    My implementation:\n<code>", "    if length(strings)>0 \n        longest = maximum(strings)\n\
    \    else\n        nothing\n    end\nend", "    if length(strings)==0 \n     \
    \   nothing\n    else \n        longest = maximum(strings)\n        for s in strings\
    \ \n            if length(longest)>length(s) \n                longest = s\n \
    \       end\n        longest\n    end\nend\n</code>\n<|/ a dscore=1 tags=julia,string,arrays,sorting\
    \ |>\n<| c |>\nI think he wants the first longest one, but your function will\
    \ return all longest strings except the longest one. Try with longest([\"ab\"\
    , \"c\", \"d\"]) and longest([\"aa\", \"ab\", \"bc\"]).\n<|/ c |>\n<| c |>\nYeah,\
    \ I just noticed that and fixed it.\n<|/ c |>\n<| a |>\nHere's a short one line\
    \ solution using the same idea as\n<code>", "    longest_string = nothing\n  \
    \  for s in strings\n        if longest_string == nothing || length(s) >= length(longest_string)\n\
    \            longest_string = s\n        end\n    end\n    longest_string\nend",
  "    strings = sort_by(strings, length) \n    longest = Nothing \n    if !isempty(strings)\
    \ \n        longest = head(strings) \n        for s in tail(strings) \n      \
    \      if length(s) > length(longest) \n                longest = s \n       \
    \     end \n        end \n    end \n    return longest \nend \n</code>\nThe same\
    \ with mapcat, since mapcat is faster than map.\n<code>", "    longest = nothing\n\
    \    for s in strings\n        if longest == nothing\n            longest = s\n\
    \        elseif length(longest) < length(s) \n            longest = s\n      \
    \  end\n    end\n    longest\nend", "    longest = nothing\n    for string in\
    \ strings\n        if !isnothing(longest) && longest == string\n            longest\
    \ == string\n        elseif !isnothing(longest)\n            longest = nothing\n\
    \        else\n            longest = string\n        end\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nlongest([\"a\", \"bb\", \"ccc\"])\n</cell>\n<code language=julia-1.5>\n\
    longest([\"a\", \"b\", \"c\", \"cc\", \"ccc\", \"ddd\"])\n</cell>\n<code language=julia-1.5>\n\
    longest([\"a\", \"bb\", \"ccc\", \"aaaa\", \"a\"])\n</cell>\n<code language=julia-1.5>\n\
    longest([\"a\", \"bb\", \"ccc\", \"aaaa\", \"a\"])\n</cell>\n<code language=julia-1.5>\n\
    longest([\"a\", \"bb\", \"ccc\", \"aaaa\", \"a\"])\n</cell>\n<code language=julia-1.5>\n\
    longest([\"a\", \"bb\", \"ccc\", \"aaaa\", \"a\"])\n</cell>\n<code language=julia-1.5>\n\
    longest([\"a\", \"bb\", \"ccc\", \"aaaa\", \"a\"])\n</cell>\n<text>\nExercise\n\
    Implement a function that returns the longest string of a list of strings. Return\
    \ a default value if the list is empty.", "    # Nothing is returned in case of\
    \ empty vector\n    if length(strings) == 0 \n        return nothing \n    else\
    \ \n        max_length =  maximum(strings, lengths) \n        for string in strings\
    \ \n            if length(string) == max_length \n                return string\
    \ \n        endfor \n        return nothing \nendfunction \n</cell>\n<code language=julia-1.5>\n\
    longest([\"a\", \"b\", \"c\"])\n</cell>\n<code language=julia-1.5>\nlongest([\"\
    a\", \"bb\", \"ccc\"])\n</cell>\n<code language=julia-1.5>\nlongest([\"a\", \"\
    b\", \"c\", \"de\", \"ef\"])\n</cell>\n<code language=julia-1.5>\nlongest([\"\
    a\", \"bb\", \"ccc\", \"ddde\", \"e\", \"fff\"])\n</cell>\n<text>\nExercise\n\
    Write a function longest2(strings::Vector{String})::String which returns the longest\
    \ string in the input vector.", "    if length(strings) == 0\n        nothing\n\
    \    elseif length(strings) == 1\n        strings[1]\n    else\n        strings[length(strings)==0\
    \ ? 0 : argmax (map length, strings)]\n    end\nend", "   if length(strings) <\
    \ 1 \n       return nothing \n   end \n   length_strings = map(length, strings)\
    \ \n   longest_string = maximum.(length_strings) \n   longest_string = filter(x\
    \ -> x == longest_string, length_strings) \n   if length(longest_string) > 1 \n\
    \       return longest_string \n   end \n   return longest_string[1] \nend", " \
    \   if isempty(strings) \n        return nothing\n    else \n        return maximum(strings)\n\
    end\n</cell>\n<code language=julia-1.0>", "    if !length(strings)\n        return\
    \ nothing\n    end=minimum(lengths(strings))\n    longest=nothing\n    longest_length=nothing\n\
    \    for s in strings\n        if length(s)==end\n            if !longest_length\n\
    \                longest_length=length(s)\n                longest=s\n       \
    \     elseif length(s)>longest_length\n                longest_length=length(s)\n\
    \                longest=s\n            end\n        elseif longest_length>length(s)\n\
    \            longest_length=length(s)\n            longest=s\n        end\n  \
    \  end\nend\nlongest\nend", "    if length(strings) == 0 \n    then Nothing \n\
    \    else longest(sort(strings, by=length))[1] \n    end\nend\n</cell>\n<text>\n\
    Now we write a function which checks if the vectors given as input are isomorphic\
    \ or not. The vector is said to be isomorphic if every pair i,j of them have the\
    \ same string length. Otherwise it's not. Note that the function checks one by\
    \ one the input vectors. If the first pair are isomorphic, then the function returns\
    \ $true$, otherwise the function returns $false$. Note also that in the case of\
    \ isomorphism, we consider pairs $(i,j)$ such that $i$ and $j$ are mutually isomorphic\
    \ if and only if $i \\in j$. For instance, the vector [\"a\", \"a\"] is not isomorphic\
    \ because $i$ and $j$ are not mutually isomorphic and $i = \"a\"$.", "    lengths\
    \ = map length, (strings)\n    if lengths.max() == lengths[lengths.argmax()]\n\
    \        return strings[lengths.argmax()]\n    ends_with_a = any((x -> endsWith(x,\
    \ \"a\")) == string -> endsWith(string, \"a\") for string in strings)\n    if\
    \ ends_with_a\n        a_strings = filter((string -> endsWith(string, \"a\"))\
    \ == string -> endsWith(string, \"a\") for string in strings)\n        b_strings\
    \ = filter((string -> endsWith(string, \"b\")) == string -> endsWith(string, \"\
    b\") for string in strings)\n        a_lengths = map length, (strings[a_strings])\n\
    \        b_lengths = map length, (strings[b_strings])\n        if a_lengths.max()\
    \ == b_lengths.max()\n            return strings[a_strings.argmax()]\n       \
    \ ends_with_ab = any((x -> endsWith(x, \"ab\")) == string -> endsWith(string,\
    \ \"ab\") for string in strings)\n        if ends_with_ab\n            ab_strings\
    \ = filter((string -> endsWith(string, \"ab\")) == string -> endsWith(string,\
    \ \"ab\") for string in strings)\n            ab_lengths = map length, (strings[ab_strings])\n\
    \            if ab_lengths.max() == a_lengths.max()\n                return strings[ab_strings.argmax()]\n\
    \            ends_with_abc = any((x -> endsWith(x, \"abc\")) == string -> endsWith(string,\
    \ \"abc\") for string in strings)\n            if ends_with_abc\n            \
    \    abc_strings = filter((string -> endsWith(string, \"abc\")) == string -> endsWith(string,\
    \ \"abc\") for string in strings)\n                abc_lengths = map length, (strings[abc_strings])\n\
    \                if abc_lengths.max() == ab_lengths.max()\n                  \
    \  return strings[abc_strings.argmax()]\n                ends_with_abcd = any((x\
    \ -> endsWith(x, \"abcd\")) == string -> endsWith(string, \"abcd\") for string\
    \ in strings)\n                if ends_with_abcd\n                    abcd_strings\
    \ = filter((string -> endsWith(string, \"abcd\")) == string -> endsWith(string,\
    \ \"abcd\") for string in strings)\n                    abcd_lengths = map length,\
    \ (strings[abcd_strings])\n                    if abcd_lengths.max() == abc_lengths.max()\n\
    \                        return strings[abcd_strings.argmax()]\n             \
    \       return nothing\n            ends_with_abbb = any((x -> endsWith(x, \"\
    abbb\")) == string -> endsWith(string, \"abbb\") for string in strings)\n    \
    \        if ends_with_abbb\n                abbb_strings = filter((string ", " \
    \   if length(strings)==0 \n        return nothing \n    else \n        max_length\
    \ := maximum(strings) \n        for i in strings:\n            if length(i)==max_length\n\
    \                return i\n            else\n                max_length := length(i)\n\
    end ", "    longest = Nothing\n    if length(strings) == 0 \n        return nothing\n\
    \    elseif length(strings) == 1\n        longest = strings[end]\n    else \n\
    \        longest = strings[argmax(lengths)]\n    end \nend\n</code>\n<|/ a dscore=3\
    \ |>\n<| a tags=julia |>\nFor a vector of Strings:\n<code>", "\t\n\tfor string\
    \ in strings\n\t\tif length(string) > length(longest_string)\n\t\t\tlongest_string\
    \ = string\n\t\tend\n\tend\n\t\n\tif longest_string == nothing\n\t\treturn nothing\n\
    \telse\n\t\treturn longest_string\n\tend\nend", "    if isempty(strings) return\
    \ nothing \n    max_length = nothing \n    max_length_pos = nothing \n    max_length_len\
    \ = nothing \n    for s in strings \n        if length(s)>max_length_len \n  \
    \          max_length = s \n            max_length_pos = length s \n         \
    \   max_length_len = length s \n        end \n    end \n    if max_length_pos\
    \ == max_length_len return max_length \n    else return nothing\nend ", "    lengths\
    \ = map(length, strings)\n    if all(lengths == lengths[1])\n        longest_string\
    \ = strings[1]\n    else\n        longest_string = strings[argmax(lengths)]\n\
    \    end\n    return longest_string\nend", "    \"\"\"Given vector of strings,\
    \ return the longest string. Return nothing in case the input vector is empty.\"\
    \"\"\n    max_length = 0\n    max_length_str = \"\"\n    for string in strings\n\
    \        if length(string) > max_length\n            max_length = length(string)\n\
    \            max_length_str = string\n        end\n    end\n    return max_length_str\n\
    end\n</cell>\n<code language=julia-1.0>\nlongest([\"a\", \"bb\", \"ccc\"])\n</cell>\n\
    <code language=julia-1.0>\nlongest([\"a\", \"b\", \"ccc\"])\n</cell>\n<code language=julia-1.0>\n\
    longest([\"a\", \"bb\", \"ccccc\"])\n</cell>\n<text>\nTask 2\nWrite a function\
    \ that takes a vector of strings and returns a vector of strings containing the\
    \ longest subsequences.", "    longest_length = nothing\n    for s in strings\
    \ do \n        if isnothing(longest_length) or length(s) >= length(longest_length)\
    \ then\n            longest_length = s\n        else \n            longest_length\
    \ = nothing\n        end\n    end\n    if isnothing(longest_length) then return\
    \ nothing \n    else return longest_length \n    end\nend", "    if length(strings)\
    \ == 0 \n        nothing \n    else \n        longest = length(max(strings)) \n\
    \        maximums(strings, longest) \n    end\nend\n</cell>\n<text>\nPart 4: Exercise\n\
    Implement a function that takes a vector of strings and returns a vector of vectors,\
    \ where each vector contains the number of occurrences of each string in its original\
    \ vector. Your function should perform case-insensitivity and ignore whitespace.",
  "    if length(strings) == 0\n        nothing\n    elseif length(unique(strings))\
    \ == 1\n        unique(strings)[1]\n    else\n        longest(longest(tail(strings)))\n\
    \    end\nend\n</cell>\n<text>\nExercise", "    if length(strings) < 1\n     \
    \   return nothing\n    el = maximum(strings)\n    for i in 0 .. length(strings)-1\n\
    \        if el == strings[i]\n            return el\n        end\n    end\n  \
    \  return nothing\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis looks promising\
    \ but I don't understand the function call: longest([String]) in the last line\
    \ of code. Thanks!\n<|/ c |>\n<| c |>\nOh, I should clarify. I am calling it like\
    \ this, longest(vec), where vec is of type Vector{String}. So you are passing\
    \ in something of type Vector{String}. My understanding is that this will return\
    \ a String, which is the longest element in vec. I will edit my post to clarify.\n\
    <|/ c |>\n<| c |>\nThat was exactly what I needed, thanks! I was trying to write\
    \ a function that would find both the longest and the smallest element of a vector,\
    \ but I wasn't sure how to go about it. I will edit my post to include my final\
    \ solution. Thanks again for your help!\n<|/ c |>\n<| a dscore=1 |>\nHow about\
    \ using filter() to return only the indices of values which are the largest?\n\
    <code>", "    longest <- Nothing\n    for string in strings do\n        if length(longest)\
    \ == 0 \n        then longest <- string \n        else if length(longest) > length(string)\n\
    \        then longest <- string\n        end\n    end\n    longest\nend", "  \
    \  if isempty(strings) return nothing\n    max_length = 0\n    for str in strings\n\
    \        if length(str) > max_length\n            max_length = length(str) \n\
    \        end\n    end\n    for str in strings\n        if length(str) == max_length\
    \ \n            return str\n        end\n    end\n    return nothing\nend", " \
    \   max_length = Int.max\n    for str in strings\n        max_length = max max_length,\
    \ length(str) \n    end\n    return strings[max_length]\nend", "    longest_index::Int\
    \ \n    longest_length::Int = 0\n    longest_length = 0\n    for i in 0 .. length(strings)\n\
    \        length = length(strings[i])\n        if longest_length < length\n   \
    \         longest_length = length\n            longest_index = i\n        end\n\
    \    end\n    longest_string::String = strings[longest_index]\n    if longest_length\
    \ > 1\n        longest_string::Vector{String}\n    else\n        nothing\n   \
    \ end\nend\n</cell>\n<text>\nGreedy algorithm\nImplement greedy algorithm\nImplement\
    \ a function that will receive a sequence of strings and return a single string.",
  "    longest = max(strings, lengths)\n    if length(longest) == 1 && longest ==\
    \ \"\"\n        return nothing\n    return longest\nend\n</cell>\n<text>\nThe\
    \ last thing you need to do is to use map! to apply the function to the test vector:",
  "    if strings.length == 0 \n        return nothing \n    else \n        length\
    \ = maximum([length(s) for s in strings])\n        return strings[findfirst(s\
    \ -> length(s) == length, strings)] \nend\n</code>\n<|/ a tags=julia dscore=4\
    \ |>\n<| c |>\nThe return type should be `Vector{String}`, not `Vector`.\n<|/\
    \ c |>\n<| c |>\nthanks, corrected it. I was in a hurry when writing it.\n<|/\
    \ c |>\n<| c |>\nIt's also worth noting that the `longest()` function is already\
    \ in the base package as `Base.longest`.  To use it, you would just do `longest(some_list)`.\n\
    <|/ c |>\n<| c |>\nThanks for the comment. I will update the answer.\n<|/ c |>\n\
    <| c |>\nTo clarify, `longest` also works on `Int` values while `findfirst` does\
    \ not.\n<|/ c |>\n<| a tags=julia dscore=3 |>\nI haven't had much experience with\
    \ Julia, but I would guess that there is probably a nice way to do this with a\
    \ map or reduce function.\nSomething along the lines of:\n<code>\nlongest(strings)\
    \ = reduce(length=>strings[length], lengths, 1)\n</code>\nor \n<code>\nlongest(strings)\
    \ = map(length=>strings[length], lengths)[1]\n</code>\n<|/ a |>\n<| c |>\nThe\
    \ first example is great, but you forgot a closing parenthesis. I fixed that,\
    \ and it seems to work well. I think it's more intuitive than some of the other\
    \ answers. It's also not clear to me that the `reduce` function even exists. I've\
    \ never used it.\n<|/ c |>\n<| c |>\nYeah, I think that's pretty cool too. I would\
    \ still be interested to see if there are any other (more idiomatic) solutions.\n\
    <|/ c |>\n<| a dscore=3 tags=julia |>\nTo answer the question about using reduce\
    \ for this problem (which has already been answered), you can do:\n<code>\njulia>\
    \ reduce(maximum, [\"a\", \"b\", \"c\"])\n\"c\"\n</code>\nThis is not very different\
    \ to the other answers, but this one uses reduce which is part of the base package.\n\
    <|/ a |>\n<| a tags=julia dscore=3 |>\nHere is a one liner:\n<code>\njulia> reduce(maximum,\
    \ [\"a\", \"b\", \"c\"])\n\"c\"\n</code>\n<|/ a |>\n<| c |>\nThis answer just\
    \ became ", "    if isempty(strings) \n        return nothing \n    \n    longest\
    \ := maximum(strings, key=lambda s: length(s))\n    if length(longest) == 1 \n\
    \        return longest \n    return nothing \nend\n</cell>\n<code language=julia-0.6>\n\
    longest([\"a\", \"b\", \"c\", \"c\"])\n</cell>\n<code language=julia-0.6>\nlongest([\"\
    a\", \"bb\", \"ccc\"])\n</cell>\n<code language=julia-0.6>\nlongest([\"a\"]) ==\
    \ nothing\n</cell>\n<code language=julia-0.6>\nlongest([\"a\"]) == nothing\n</cell>\n\
    <text>\nExercise 3\nImplement function all_diff, that takes an array of arrays\
    \ as an input and returns a new array that contains all differences between elements\
    \ of the input arrays.\nIf there is no element in a given array that does not\
    \ correspond to an element in the other arrays, return an empty array.\nIf there\
    \ is more than one element in the input arrays, return an array with more than\
    \ one element.", "    # strings::Vector{String}\n    if strings.length == 0\n\
    \        return nothing\n    max_length = 0\n    longest_str = nothing\n    for\
    \ str in strings\n        max_length = length(str)\n        if max_length > max_length\n\
    \            longest_str = str\n        end\n    end\n    return longest_str\n\
    end\n</code>\n<|/ a tags=julia,string |>\n<| a dscore=0 |>\nA solution to the\
    \ problem which uses the built-in max function and no loops or conditionals is\
    \ shown below\n<code>\nlongest(vector::Vector{String}) = maximum(map(length, vector))\n\
    </code>\nThis has the advantage of also returning the first string in case of\
    \ multiple longest strings with the same length and, as mentioned in other answers,\
    \ also works for empty vectors.\n<|/ a tags=julia,string |>\n<| a dscore=0 |>\n\
    One liner solution using Julia's \"reduce\" function:\n<code>\nlongest = reduce(x\
    \ -> length(x) > length(x[1]) ? x : x[1], ls)\n</code>\n<|/ a tags=julia,string\
    \ |>\n<| a dscore=0 |>\nHere is an example of a function which accepts any number\
    \ of strings and returns one of them which is the longest:\n<code>", "    \n \
    \   for s in strings \n        if s !~= '' \n            return s \n    \n   \
    \ return nothing \nend ", "    if len(strings) == 0\n        return nothing\n\
    \    longest = strings[end]\n    for i in end - length(strings)\n        longest\
    \ = if longest == strings[i]\n            nothing\n            else longest\n\
    \        end\n    end\n    longest\nend", "    if length(strings) == 0 \n    \
    \    return nothing\n    else if length(strings) == 1 \n        return strings[1]\
    \ \n    else \n        longest_string = maximum(strings, lengths)\n        return\
    \ longest_string\nend \n</code>\n<|/ a |>\n<| a |>\nHere is one way to do this:\n\
    <code>\nstrings = [\"a\",\"b\",\"c\",\"d\",\"e\"]", "    longest := Nothing\n\
    \    for s in strings\n        if length(s) > length(longest) || length(longest)\
    \ == 0 \n            longest = s\n        elseif length(longest) > length(s)\n\
    \            longest = s\n        end\n    end\n    return longest\nend\n</cell>\n\
    <code language=julia-1.5>\nlongest([\"a\", \"bb\", \"ccc\"])\n</cell>\n<text>\n\
    Returning multiple strings\nIf you need to return multiple values, you can use\
    \ multiple return statements:", "    if length(string(strings)) == 0 \n      \
    \  nothing \n    else \n        longest(last(strings))\n    end\nend\n</cell>\n\
    <text>\nFinally, let's apply the longest function to the following list of strings:",
  "    if strings.length == 0\n        nothing\n    else\n        longest = strings[length(strings)]\
    \ \n        for str in strings\n            if longest.length < str.length\n \
    \               longest = str\n            end\n        end\n        longest\n\
    \    end\nend\n\"\"\"\n    find_last(strings::Vector{String})::Union{String, Nothing}\
    \ \n    if strings.length == 0\n        nothing\n    else\n        find_last =\
    \ strings[length(strings)] \n        for str in strings\n            if find_last.length\
    \ > str.length\n                find_last = str\n            end\n        end\n\
    \        find_last\n    end\nend\n\"\"\"\n    find_last_index(strings::Vector{String})::Int\
    \ \n    if strings.length == 0\n        nothing\n    else\n        find_last_index\
    \ = strings[length(strings)] \n        for str in strings\n            if find_last_index\
    \ >= str.length\n                find_last_index = length(find_last_index)\n \
    \           end\n        end\n        find_last_index\n    end\nend\n\"\"\"\n\
    \    longest_index(strings::Vector{String})::Int \n    if strings.length == 0\n\
    \        nothing\n    else\n        longest_index = strings[length(strings)] \n\
    \        for str in strings\n            if longest_index > str.length\n     \
    \           longest_index = str.length\n            end\n        end\n       \
    \ longest_index\n    end\nend\n\"\"\"\n    index_last(strings::Vector{String})::Int\
    \ \n    if strings.length == 0\n        nothing\n    else\n        index_last\
    \ = strings[length(strings)] \n        for str in strings\n            if index_last\
    \ < str.length\n                index_last = length(index_last)\n            end\n\
    \        end\n        index_last\n    end\nend\n\"\"\"\n    remove_blanks(strings::Vector{String})::Vector{String}\n\
    \    remove_blanks(strings::Vector{String})::String\n    remove_blanks(strings::Vector{String})::Union{String,\
    \ Nothing}\n    remove_blanks(strings::Vector{String})::Union{String, Nothing}\n\
    \    remove_blanks(strings::Vector{String})::Union{String, Nothing}\n    remove_blanks(strings::Vector{String})::Union{String,\
    \ Nothing}\n    remove_blanks(strings::Vector{String})::Union{String, Nothing}\n\
    \    remove_blanks(strings::Vector{String})::Union{String, Nothing}\n    remove_blanks(strings::Vector{String})::Union{String,\
    \ Nothing}\n    remove_blanks(strings::Vector{String})::Union{String, ", "   \
    \ # @assert length(strings) >= 1 \"Input vector is empty.\"\n    if length(strings)\
    \ == 0 \n        return nothing \n    endOfLongest = \"\" \n    longestLength\
    \ = 0 \n    for string in strings \n        if (length(string) == longestLength)\n\
    \            if string == endOfLongest \n                return string \n    \
    \        else \n                return endOfLongest \n        else \n        \
    \    longestLength = length(string) \n            endOfLongest = string \n   \
    \ end \n    return endOfLongest \nend\n</cell>\n<text>\nFind the most common element\
    \ in a vector\nGiven a vector of strings, find the most common element and return\
    \ the number of occurrences. Return nothing in case the input vector is empty.",
  "    if length(vector(strings)) == 0 \n        return nothing \n    else \n    \
    \    if length(strings) == 1 \n            return strings[0] \n        else \n\
    \            longeststring(strings) \nend \n</code>\n<|/ a |>\n<| c |>\nYou should\
    \ use the `length` function instead of `length(vector)`.\n<|/ c |>\n<| c |>\n\
    That's true, but in this case I guess you know that :)\n<|/ c |>\n<| a tags=string,julia\
    \ dscore=2 |>\nThe other answers work but this is my take:\n<code>\nlongest(vec)\
    \ = [x for (y, x) in zip( vec , vec ) ; length(x) <=> length(y) ][1]\n</code>\n\
    This works by zipping the two vectors together, but only if the lengths of the\
    \ strings are equal and returns the first element in that pair, i.e. the longest\
    \ string.\n<|/ a |>\n<| c |>\nI think you meant `longest(vec) = [x for (y, x)\
    \ in zip( vec , vec ) ; length(x) <=> length(y) ][1];`, otherwise `longest(vec)`\
    \ is `nothing`\n<|/ c |>\n<| a dscore=1 |>\n<code>\nlongest(vec) = last(vec)\n\
    </code>\n<|/ a tags=string,julia |>\n<| c |>\nThis has the advantage of handling\
    \ empty vectors, i.e. `longest(\"\")` returns `\"\"`, rather than throwing an\
    \ error\n<|/ c |>\n<| a dscore=1 |>\nTo find the longest string, the following\
    \ code might be used:\n<code>", "    if !strings || length(strings) == 0\n   \
    \     nothing\n    else\n        longest = max(strings, lengths)\n    end\nend",
  "    longest = strings[1]\n    for i in 2:length(strings)\n        if strings[i].length\
    \ >  longest.length\n            longest = strings[i]\n        end\n    end\n\
    \    longest\nend\n</cell>\n<text>\nExercise 4\nWrite a function that returns\
    \ an arbitrary element from a vector.", "    if strings == []\n        nothing\n\
    \    elseif strings.length == 0\n        nothing\n    else\n        longest_string(strings)\n\
    \    end\nend", "    longest = nothing\n    if isempty(strings)\n        return\
    \ nothing\n    longest = strings[1]\n    for string in strings\n        if string.length\
    \ > longest.length\n            longest = string\n        end\n    end\n    return\
    \ longest\nend\n</cell>\n<text>\nSolution using Julia's builtins:", "    longest\
    \ = nothing\n    for str in strings \n        if longest == nothing\n        \
    \    longest = str\n        else if str != longest\n            longest = nothing\n\
    \        end\n    end\n    longest\nend", "    if length(strings) == 0 return\
    \ nothing \n    \n    local maxlen=0\n    maxstring=\"\"\n    for s in strings\
    \ do \n        if length(s) > maxlen then \n            maxlen=length(s) \n  \
    \          maxstring=s\n        end \n    end \n    return maxstring \nend\n</cell>\n\
    <text>\nThe function longest is a short hand for map (longest, strings).", " \
    \   # TODO Vectorize this\n    # TODO Use `Vector{String}` instead of `Vector{<:AbstractString}`\n\
    \    if length(strings) == 0:\n        nothing\n    \n    max_length = 1\n   \
    \ for i in 1:length(strings)\n        max_length = max(max_length, length(strings[i]))\n\
    \    end", "    if length(strings) == 0 \n        return nothing \n    else \n\
    \        max_length = length(strings) \n        max_length_idx = 1 \n        for\
    \ idx in 2:length(strings) \n            if length(strings[idx]) > max_length\
    \ \n                max_length = length(strings[idx]) \n                max_length_idx\
    \ = idx \n            end \n        end \n        return strings[max_length_idx]\
    \ \n    end \nend \n</cell>\n<code language=julia-1.5>\nlongest([\"a\", \"b\"\
    , \"c\"])\n</cell>\n<text>\nmap", "    longest = nothing\n    for string in strings\n\
    \        length = length(string)\n        if length == 0 \n            continue\n\
    \        elif length <= length(longest)\n            return string\n        else\n\
    \            longest = string\n        end\n    end\n    longest\nend\n</cell>\n\
    <text>\nPractice\nWrite a function that removes all spaces from a string.", " \
    \   longest(sort!(collect(strings)))\nend", "    if length(strings) == 0 return\
    \ nothing\n    lengths = Vector{Int64}(undef, length(strings))\n    for i in 1:length(strings)\n\
    \        lengths[i] = length(strings[i])\n    end\n    return strings[argmax(lengths)]\n\
    end", "    if isempty(strings) \n        return nothing \n    else \n        longest\
    \ = nothing\n        longest = minimum(strings) \n        for i in strings[1:]\
    \ \n            if i.length < longest.length \n                longest = i \n\
    \            end \n        end \n        return longest \n    end \nend \n</cell>\n\
    <text>\nWe use the same function we defined before:", "    switch strings\n  \
    \      when is_empty(strings) return nothing\n        when length(strings) <=\
    \ 1 return first(strings)\n        for s in strings\n            if length(s)\
    \ > length(longest(strings))\n                return s\n            else\n   \
    \             longest(s)\n            end\n        end\n    end\nend\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\nThis is probably the easiest way:\n<code>", "    \n\
    \    for str in strings\n        if str.length > longest.length\n            longest\
    \ = str\n        end\n    end\n    longest\nend\n</cell>\n<code language=julia-0.5>\n\
    longest(\"abc\", \"abcd\", \"aad\", \"aaddd\", \"xa\", \"aa\")\n</cell>\n<code\
    \ language=julia-0.5>\nlongest([\"a\", \"b\", \"c\"], [\"a\"])\n</cell>\n<code\
    \ language=julia-0.5>\nlongest([\"a\", \"bb\", \"ccc\"], [\"a\", \"b\"])\n</cell>\n\
    <code language=julia-0.5>\nlongest([\"a\", \"bb\", \"ccc\"], [\"a\", \"bb\"])\n\
    </cell>\n<code language=julia-0.5>\nlongest([\"a\", \"bb\", \"ccc\"], [\"a\",\
    \ \"bb\", \"cc\", \"dddd\"])\n</cell>\n<code language=julia-0.5>\nlongest([\"\
    a\", \"bb\", \"ccc\"], [\"a\", \"bb\", \"ccc\", \"dddd\", \"eeeee\", \"ffff\"\
    ])\n</cell>\n<code language=julia-0.5>\nlongest([\"a\", \"bb\", \"ccc\"], [\"\
    a\", \"bb\", \"ccc\", \"dddd\", \"eeeee\", \"ffff\", \"ggggg\"])\n</cell>\n<code\
    \ language=julia-0.5>\nlongest([\"a\", \"bb\", \"ccc\"], [\"a\", \"bb\", \"ccc\"\
    , \"dddd\", \"eeeee\", \"ffff\", \"ggggg\", \"hhhhh\"])\n</cell>\n<code language=julia-0.5>\n\
    longest([\"a\", \"bb\", \"ccc\"], [\"a\", \"bb\", \"ccc\", \"dddd\", \"eeeee\"\
    , \"ffff\", \"ggggg\", \"hhhhh\", \"iiiii\"])\n</cell>\n<code language=julia-0.5>\n\
    longest([\"a\", \"bb\", \"ccc\"], [\"a\", \"bb\", \"ccc\", \"dddd\", \"eeeee\"\
    , \"ffff\", \"ggggg\", \"hhhhh\", \"iiiii\", \"jjjjj\", \"kkkkk\"])\n</cell>\n\
    <code language=julia-0.5>\nlongest([\"a\", \"bb\", \"ccc\"], [\"a\", \"bb\", \"\
    ccc\", \"dddd\", \"eeeee\", \"ffff\", \"ggggg\", \"hhhhh\", \"iiiii\", \"jjjjj\"\
    , \"kkkkk\", \"lllll\", \"mmmmm\"])\n</cell>\n<code language=julia-0.5>\nlongest([\"\
    a\", \"bb\", \"ccc\"], [\"a\", \"bb\", \"ccc\", \"dddd\", \"eeeee\", \"ffff\"\
    , \"ggggg\", \"hhhhh\", \"iiiii\", \"jjjjj\", \"kkkkk\", \"lllll\", \"mmmmm\"\
    , \"nnnnn\", \"ooooo\"])\n</cell>\n<code language=julia-0.5>\nlongest([\"a\",\
    \ \"bb\", \"ccc\"], [\"a\", \"bb\", \"ccc\", \"dddd\", \"eeeee\", \"ffff\", \"\
    ggggg\", \"", "  if length(strings) > 1 \n    longest := strings[1]\n    for s\
    \ in strings[2:end]\n      if length(longest) > length(s) \n        longest :=\
    \ s\n      end\n    end\n    longest\n  else \n    nothing\n  end \nend\n</cell>\n\
    <code language=julia-1.3>\nlongest([\"a\", \"bb\", \"ccc\"])\n</cell>\n<text>\n\
    Exercise: Write a function that takes a vector of strings and returns the number\
    \ of different words in it.", "    if length(strings)==0\n        return nothing\n\
    \    max_length = maximum(strings)\n    idx=0\n    for s in strings\n        if\
    \ length(s==max_length)\n            return s\n    end\n    return nothing\nend\n\
    </cell>\n<code language=julia-1.4>\nlongest([\"a\", \"b\", \"c\"])\n</cell>\n\
    <code language=julia-1.4>\nlongest([\"a\", \"bb\", \"ccc\"])\n</cell>\n<text>\n\
    A better solution would be to first sort and then return the longest string in\
    \ the vector. The reason we do this is that the above solution may return the\
    \ wrong answer if the input vector is sorted in ascending order.", "    longest\
    \ = \"\"\n    for s in strings \n        if length(s) > length(longest)\n    \
    \        longest = s\n        end\n    end\n    longest\nend", "    if isnothing(longest(strings))\
    \ then return nothing else return longest(strings[1]) end\n    \n    function\
    \ longest(string)\n        length = length(string(strings[1]))\n        \n   \
    \     for string in strings\n            length <= length(string(strings[1]))\
    \ && return string(strings[1])\n        end\n        \n        return nothing\n\
    \    end\n    return longest(strings)\nend", "    if len(strings) < 1\n      \
    \  nothing\n    elseif strings[0].length == strings[1].length\n        strings[0]\n\
    \    else\n        nothing\n    end\nend", "    longest = nothing \n    for string\
    \ in strings \n        if string.length > length(longest) \n            longest\
    \ = string \n        end\n    end\n    return longest\nend", "    longest = nothing\n\
    \    for s in strings\n        if longest == nothing\n            longest = s\n\
    \        else\n            if length(s) > length(longest)\n                longest\
    \ = s\n            end\n        end\n    end\n    return longest\nend\n</cell>\n\
    <code language=julia-1.5>\nlongest([\"a\", \"b\", \"c\"])\n</cell>\n<text>\nExercise\n\
    Write a function that counts the number of times each character appears in each\
    \ of the given strings vectors.", "    \n    if length(strings) == 0 \n      \
    \  return nothing \n    \n    # sort them in descending length order (for ties,\
    \ return the first one)\n    lengths = Vector{String}(map(length, reverse(strings)))\n\
    \    \n    # find the first one that's longer than the others\n    i = length(lengths)\
    \ - 1\n    while i >= 0\n        if lengths[i] == lengths[i+1] \n            lengths[i]\
    \ = 0 \n        else \n            lengths[i] = lengths[i+1] \n            i -=\
    \ 1\n        end\n    end\n    \n    # return the longest one\n    return lengths[end]\
    \ == 0 ? nothing : strings[end]\nend", "    longest = String[nothing]() \n   \
    \ for s in strings do \n        if length(s) > length(longest) then longest =\
    \ s; end \n    end \n    return longest \nend \n</code>\n<|/ a |>\n<| a dscore=4\
    \ |>\nHere's a Julia version that doesn't require any additional packages:\n<code>",
  "    if strings == []\n        nothing\n    else\n        longest = max_by(strings,\
    \ len)\n        if longest == \"\" \n            nothing\n        else\n     \
    \       longest\n        end\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    longest([\"a\", \"bb\", \"ccc\"])\n</cell>\n<text>\n4.3. Mean of a vector or matrix\n\
    Compute the mean of a vector of numbers. If the input is a vector, compute the\
    \ mean across all the\nrows and return the mean. If the input is a matrix, compute\
    \ the mean across all the columns and \nreturn the mean.", "    if length(strings)==0\
    \ \n        return nothing \n    else \n        longest=strings[1]\n        for\
    \ string in strings \n            if length(longest)<length(string) \n       \
    \         longest=string \n            end\n        end\n        return longest\n\
    \    end\nend\n</cell>\n<text>\nNotice that longest() will return nothing in case\
    \ the vector is empty rather than an error message.", "    max_length = 0\n  \
    \  longest = nothing\n    for i in strings\n        if i.length > max_length \n\
    \            max_length = i.length\n            longest = i\n        end\n   \
    \ end\n    return longest\nend\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ to determine whether a vector is sorted in ascending order.", "    if length(strings)\
    \ == 0 return nothing\n    longest_string = \"nothing\"\n    for s in strings\n\
    \        if length(longest_string) < length(s) \n            longest_string =\
    \ s\n        end\n    end\n    return longest_string\nend\n</code>\n<|/ a tags=julia,string\
    \ |>\n<| a dscore=2 |>\nI know this is a pretty old question, but I came up with\
    \ a different solution and thought it might help someone else coming across this\
    \ question.\nUsing a comprehension, we can also avoid the if-else statement, as\
    \ follows:\n<code>\njulia> [x for x in [string1, string2, string3] if length(x)\
    \ > 1]\n2-element Array{String,1}:\n \"string1\"\n \"string3\"\n</code>\nThis\
    \ gives the result in a single line while avoiding the if-else statement\n<|/\
    \ a tags=julia,string |>\n<| a tags=julia,string |>\nI would use eachslice function\n\
    <code>\njulia> eachslice(\"abcdeefghijklmnopqrstuvwxy\", length(longest(\"abcdeefghijklmnopqrstuvwxy\"\
    ))) do s\n       if length(longest(s)) > 1 then return s end\n       end\n\"abcdefghijklmnopqrstuvwxy\"\
    \n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\n<code>\nusing Statistics # for\
    \ the median() function", "    longest = \"\"\n    longest.length = 0\n    forall\
    \ i in 1:length(strings) do\n        if strings[i].length > longest.length then\n\
    \            longest = strings[i]\n        end\n    end\n    if longest == \"\"\
    \ \n        return nothing\n    else\n        return longest\n    end\nend", " \
    \   if len(strings) == 0\n        nothing\n    else\n        return length(strings)\
    \ == length(strings.first) ? strings.first : nothing\n    end\nend", "    string_length\
    \ = length(strings)\n    if string_length == 0 \n        nothing\n    elseif string_length\
    \ == 1 \n        strings[1]\n    elseif string_length == 2 \n        if strings[1]\
    \ == strings[1]\n            strings[1]\n        else\n            nothing\n \
    \       end\n    elseif string_length > 2\n        if strings[1] == strings[2]\n\
    \            if strings[3] == strings[3]\n                strings[3]\n       \
    \     else\n                nothing\n            end\n        else\n         \
    \   if strings[strings[2] != strings[string_length]] == strings[strings[string_length]]\n\
    \                strings[strings[string_length]]\n            else\n         \
    \       nothing\n            end\n        end\n    else\n        nothing\n   \
    \ end\nend", "    if length(strings) == 0 then nothing \n    else \n        longest_length\
    \ = length(strings[1]) \n        for s in strings[2:end]\n            if length(s)\
    \ > longest_length \n                longest_length = length(s) \n           \
    \ end\n        end\n        longest_string <- strings[1]\n        for s in strings[2:end]\n\
    \            if length(s) > longest_length \n                longest_length =\
    \ length(s) \n            end\n            if length(s) == longest_length\n  \
    \              longest_string <- (longest_string == s) ? nothing : longest_string\n\
    \            end\n        end\n        longest_string\n    end\nend\n</code>\n\
    <|/ a |>\n<| c |>\nHmm, i don't see how the second function can possibly be called\
    \ with an empty vector\n<|/ c |>\n<| c |>\nThe second function can be called with\
    \ an empty vector, but since it's a top-level function, you can always call it\
    \ with an empty vector. Try calling longest([]) in the REPL.\n<|/ c |>\n<| c |>\n\
    Oh, sorry, didn't see the second function. And how do you know it actually works?\
    \ I thought you wrote it yourself and posted it here so you can learn from it.\n\
    <|/ c |>\n<| c |>\nThe second function I wrote.  I tried to explain how the function\
    \ worked as I read the original code.  I didn't write it myself, I did it in response\
    \ to the original question.\n<|/ c |>\n<| c |>\nThe first function `longest` works\
    \ correctly for an empty vector. However, if the first element in the vector is\
    \ a string which is longer than the previous element in the vector, the output\
    \ from the first function will be wrong. For example, `longest([\"abc\", \"def\"\
    , \"ghi\"])` will return \"def\" instead of \"abc\".\n<|/ c |>\n<| a tags=julia\
    \ |>\n<code>", "    longest := strings[argmax(lengths(strings))]\n    if longest.length\
    \ == 0 \n        return nothing \n    else \n        return longest\nend # def\
    \ longest", "    max_length = 0\n    max_length_str =  \"\"\n    \n    for i in\
    \ strings\n        if i.length > max_length\n            max_length = i.length\n\
    \            max_length_str = i\n        end\n    end\n    if max_length > 0\n\
    \        return max_length_str\n    else\n        return nothing\n    end\nend\n\
    </cell>\n<code language=julia-1.6>\nlongest([\"a\", \"bb\", \"ccc\"])\n</cell>\n\
    <text>\nSum all numbers in an array", "    \n    if strings.length==0\n      \
    \  return nothing\n    else\n        longest_len=strings.length\n        longest_str=\"\
    \"\n        for i in strings\n            if i.length==longest_len\n         \
    \       longest_str=i\n            else\n                longest_len=i.length\n\
    \        end\n        return longest_str\n    end\nend\n</cell>\n<code language=julia-0.6>\n\
    longest([\"a\", \"b\", \"c\"])\n</cell>\n<text>\nSort a vector of integers", " \
    \   lens = map(length, strings)\n    if isempty(lens)\n        return nothing\n\
    \    best = minimum(lens)\n    for i in lens, 1:length(lens)\n        if best==i[1]\n\
    \            return strings[best]\n    end\n    return nothing\nend\n</code>\n\
    <|/ a tags=julia,string,arrays dscore=2 |>\n<| c |>\nI like that you can also\
    \ use `minimum(lens)` which returns the minimum value of the `lengths` array in\
    \ one line.\n<|/ c |>\n<| c |>\nIt's not that \"you can't use it\", it's that\
    \ it's unnecessary. `minimum` is implemented in terms of `findfirst` and `findlast`,\
    \ so it is exactly the same speed and memory usage as the `findfirst` and `findlast`\
    \ alternatives. And `findfirst` and `findlast` have comparable memory and speed\
    \ characteristics.\n<|/ c |>\n<| c |>\nThanks for the comment. I know that `findfirst`\
    \ and `findlast` have comparable memory and speed characteristics but I thought\
    \ `minimum(lens)` would be faster.\n<|/ c |>\n<| a dscore=2 |>\nThe accepted answer\
    \ works, but is pretty inefficient. Here is a version that uses an array comprehension\
    \ that has constant memory usage, that is about 5-10% slower than the accepted\
    \ answer:\n<code>\njulia> function longest(x::Vector{String})\n           return\
    \ x[minimum(lengths(x))]\n       end\nlongest (generic function with 1 method)",
  "    longest = nothing \n    for string in strings \n        if length(string) >\
    \ length(longest) \n            longest = string \n        end\n    end\n    return\
    \ longest\nend\n</code>\n<|/ a dscore=2 tags=function,string,julia |>\n<| a dscore=1\
    \ |>\nFor completeness, here is another example of a function where you want to\
    \ find the longest element of a set of strings:\n<code>", "    \"\"\"\n    Out\
    \ of vector of strings, return the longest one. Return the first one in case of\
    \ multiple\n    strings of the same length. Return nothing in case the input vector\
    \ is empty.\n    \"\"\"\nend\n</cell>\n<code language=julia-1.5>\nlongest([\"\
    a\", \"bb\", \"ccc\", \"dddd\", \"eeeeee\", \"ffff\", \"gg\", \"h\", \"ii\"])\n\
    </cell>\n<text>\nRemember we can convert strings to lower case", "    if length(strings)\
    \ < 1 \n        nothing \n    else \n        length(reduce(max, map(length, strings)))\n\
    \    end\nend\n</code>\n<code>\n\"\"\"\n    shortest(strings::Vector{String})::String",
  "    if length(strings)==0\n        return nothing\n    max_length=0\n    for s\
    \ in strings\n        if length(s)>max_length\n            max_length=length(s)\n\
    \        end\n    end\n    max_length==0 ? nothing : longest(strings[max_length+1:end])\n\
    end", "    if length(strings) == 0 \n        nothing \n    else \n        longest_value\
    \ = strings[end-1] \n        max_length = 1\n        for i in strings[2:end]\n\
    \            if length(i) > max_length\n                max_length = length(i)\n\
    \                longest_value = i\n            elseif length(i) == max_length\
    \ and i != longest_value\n                longest_value = i\n        end\n   \
    \     longest_value\n    end\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\n\
    \    longest(vector::AbstractVector)", "    longest = nothing\n    if length(strings)\
    \ > 0\n        longest = strings[1]\n        for str in strings\n            if\
    \ str.length > longest.length\n                longest = str\n        end\n  \
    \  end\n    return longest\nend", "    if len(strings)==0 \n        nothing \n\
    \    else \n        strings[end-1] \n    end\nend\n</cell>\n<cell>\nlongest([\"\
    a\", \"b\", \"c\"])\n</cell>\n<text>\nmap\nApply a function element-wise to a\
    \ vector.", "    max_length = 0\n    for string in strings\n      if string.length\
    \ > max_length\n        max_length = string.length\n      end\n    end\n    return\
    \ strings[max_length] \n  else\n    return nothing\n  end\nend\n</cell>\n<text>\n\
    Solution\nAfter doing some research, we come up with the following solution.",
  "    if isempty(strings)\n        nothing\n    else\n        max(strings)\n    end\n\
    end\n</cell>\n<text>\nNotice how longest is a higher-order function taking strings\
    \ as input. This function will return the longest string in the vector if any\
    \ (else it will return nothing). We can test this as follows:", "    if length(strings)==0\
    \ return nothing\n    longest = max(strings, key=lambda x: (length(x), x))\n \
    \   return longest == \"\" ? nothing : longest\nend\n</code>\n<|/ a dscore=4 |>\n\
    <| c |>\nNice, I like this one\n<|/ c |>\n<| c |>\n`longest` does not return a\
    \ string like `longest` does; it returns a `Nothing`, like `nothing`.\n<|/ c |>\n\
    <| c |>\nThe `longest` function can be simplified a bit using `max(strings, key=length)`.\
    \ `longest` can also be reduced to a single line using `reduce(max, strings, \"\
    \")`, which is shorter and easier to read.\n<|/ c |>\n<| a dscore=4 tags=julia\
    \ |>\nThe answer of Tomas A. is great but Julia has some special functions already\
    \ available:\n<code>\njulia> max(x->length(x), [\"a\", \"bb\", \"ccc\"])\n\"ccc\"\
    \njulia> reduce(max, xs, \"\")\n\"ccc\"\njulia> reduce(max, xs, \"\")\n\"ccc\"\
    \n</code>\nFor those who prefer functional approach:\n<code>\njulia> reduce(max,\
    \ filter(x -> x != \"\", xs))\n\"ccc\"\n</code>\n<|/ a |>\n<| a |>\nThe same can\
    \ be achieved using the filter function combined with length. Also note that in\
    \ Julia all functions except for ones with an _ to their name are in-place.\n\
    <code>\njulia> a = [\"a\", \"bb\", \"ccc\"]\njulia> filter(x -> x != \"\", a)\n\
    3-element Array{String,1}:\n \"a\"\n \"bb\"\n \"ccc\"", "    if len(strings) <\
    \ 1\n        return nothing\n    lengths = map(length, strings)\n    return maximum(strings)\
    \ |> nothing\nend\n</cell>\n<code language=julia-1.0>\nlongest([\"a\", \"b\",\
    \ \"c\"])\n</cell>\n<text>\nNow let's do the same with the function findfirst.\
    \ Findfirst returns the first element of the array that satisfies a predicate,\
    \ or nothing if the array is empty or does not satisfy the predicate.", "    longest_length\
    \ = 0\n    longest = nothing\n    for s in strings\n        if longest_length\
    \ < length(s) \n            longest_length = length(s) \n            longest =\
    \ s\n        end\n    end\n    return longest\nend", "    if isempty(strings)\
    \ return nothing\n    max_length = nothing\n    for s in strings\n        length\
    \ = length(s)\n        if max_length == nothing\n            max_length = length\n\
    \        elseif length > max_length\n            max_length = length\n       \
    \ end\n    end\n    if max_length != nothing\n        longest = strings[end]\n\
    \        for s in strings[1:end]\n            if length(s) > max_length\n    \
    \            longest = s\n            end\n        end\n        return longest\n\
    \    end\n    return nothing\nend", "    longest = nothing \n    if length(strings)\
    \ == 0\n        return nothing\n    ends_with_empty = true \n    for string in\
    \ strings\n        if string == \"\"\n            ends_with_empty = false\n  \
    \      end\n    end\n    if ends_with_empty && length(strings) == 1\n        longest\
    \ = strings[1]\n    else\n        longest = strings[longestindex(strings, longestindex(strings,\
    \ 0))]\n    end\n    return longest\nend\n\"\"\"\n    longestindex(strings::Vector{String},\
    \ index::Int)::Int\n    \n    Find the index of the longest string in ``strings``\
    \ with index ``index``, or ``nothing`` if no such string exists.\n    \n    >>>\
    \ longestindex([\"a\", \"b\", \"c\"], 0)\n    0\n    >>> longestindex([\"a\",\
    \ \"bb\", \"ccc\"], 0)\n    1\n    >>> longestindex([\"a\", \"b\", \"c\"], 1)\n\
    \    2\n    >>> longestindex([\"a\", \"bb\", \"ccc\"], 2)\n    nothing\n    \"\
    \"\"", "    longest = nothing \n    for i in strings\n        if longest.length\
    \ < i.length\n            longest = i \n        end\n    end\n    return longest\
    \ \nend", "    if (not strings) return Nothing\n    largest = Nothing\n    largestLength\
    \ = Nothing\n    for s in strings\n        len = length(s)\n        if len > largestLength\n\
    \            largest = s\n            largestLength = len\n        end\n    end\n\
    \    return largest\nend", "    for s in strings\n        if length(s) == length(longest(s))\n\
    \            return s\n    return nothing\nend # longest", "    string_length\
    \ = maximum(strings)\n    \n    for i in strings if string_length == maximum(i)\
    \ \n        string_length = minimum(strings)\n    end\n    return string_length\n\
    end\n</cell>\n<text>\nProblem 3\nWrite a function that returns the number of strings\
    \ in a given vector that satisfy a given condition. This can be done by iterating\
    \ over the input vector and checking if every element satisfies the condition\
    \ or by using a map or filter. The function should return the number of elements\
    \ that satisfy the condition, i.e. a number > 0.", "    \"\"\"\n    Out of vector\
    \ of strings, return the longest one. Return the first one in case of multiple\n\
    \    strings of the same length. Return nothing in case the input vector is empty.\n\
    \    \"\"\"\n    if length(strings) < 1 \n        return nothing \n    longest\
    \ = length(max(strings, key = length))\n    for s in strings \n        if length(s)\
    \ > longest \n            longest = length(s) \n        end \n    end \n    return\
    \ longest \nend \nend ", "    if length(strings)==0 \n        nothing \n    else\
    \ \n        longest(strings[1:end-1]) \n    end\nend", "    string_sizes = map(length,\
    \ strings)\n    longest = argmax(string_sizes)\n    longest_string = strings[longest]\n\
    \    if longest_string.length == string_length(strings[longest])\n        return\
    \ longest_string\n    return nothing\nend", "    \n    longest <- OptionValue((strings[[1]]\
    \ == '') ? nothing : strings[[1]])\n    for string in strings[2:end]\n       \
    \ if OptionValue(string.length > longest)\n            longest <- string\n   \
    \ end\n    longest\nend\n</cell>\n<code language=julia-1.5>\nlongest([\"a\", \"\
    bb\", \"ccc\"])\n</cell>\n<text>\nExercise: Convert an Option Vector into an Array\
    \ of Strings", "  if length(strings) <= 1\n    nothing\n  else\n    strings[1]\n\
    \  end\nend\n</code>\nI haven't really checked the other cases (maybe they should\
    \ be added), but this should get you started.\n<|/ a dscore=1 |>\n<| a dscore=0\
    \ |>\nYou can try this:\n<code>", "    if length(strings)>0\n        longest_str=length(longest(strings[1:]))\n\
    \        if longest_str>length(strings)\n            longest_str=length(strings)\n\
    \        end\n        longest_str\n    else\n        nothing\n    end\nend\n\"\
    \"\"\n    longest(strings::Vector{String})", "    longest_length = 0\n    for\
    \ string in strings\n        if length(string) > longest_length\n            longest_length\
    \ = length(string)\n        end\n    end\n    longest = nothing\n    for string\
    \ in strings\n        if longest == nothing || length(string) > length(longest)\n\
    \            longest = string\n        end\n    end\n    return longest\nend\n\
    </cell>\n<text>\nExercise: Write a function that returns true if a string contains\
    \ at least one of a list of characters. Return false otherwise.", "    for s in\
    \ strings \n        if length(s) >= length(longest)\n            return s\n  \
    \      end\n    end\n    return nothing\nend", "    if length(string.(string.(vectorOfStrings(strings))))==1\n\
    \        maximumLength =  string.(string.(vectorOfStrings(strings)))[[1]]\n  \
    \  else\n        maximumLength = nothing\n    end\n    for string in strings\n\
    \        if maximumLength!==nothing\n            if length(string.(string.(vectorOfStrings(strings))))==1\
    \ && maximumLength < length(string.(string.(vectorOfStrings(strings))))\n    \
    \            maximumLength = length(string.(string.(vectorOfStrings(strings))))\n\
    \            end\n        else\n            maximumLength = nothing\n        end\n\
    \    end\n    return maximumLength\nend", "    longest_string = length(strings)\
    \ \n    longest = if longest_string==1 \n        strings[longest_string] \n  \
    \      else return Nothing \n    else \n        longest = if longest > longest_string\n\
    \            strings[longest]\n            else longest \n        end \n    end\
    \ \n    return longest \nend \n</cell>\n<cell>\nlongest(vecOfStrings)\n</cell>\n\
    <text>\n3.2. Finding the shortest string\nInput: In vector of strings, return\
    \ the shortest one. Return the first one in case of multiple strings of the same\
    \ length.", "  result = \"\"\n  for e in strings do \n    if length(e) >= length(result)\n\
    \      result = e\n    end\n  end\n  result\nend\n</cell>\n<text>\nTest the longest()\
    \ function", "    if (length(strings)<1) return nothing \n    max_length = length(max(strings))\
    \ \n    longest_string = Nothing \n    for string in strings \n        if (length(string)==max_length)\
    \ \n            longest_string = string \n        end \n    end \n    return longest_string\
    \ \nend \n</cell>\n<code language=julia-1.5>\nlongest(words)\n</cell>\n<text>\n\
    Exercise 2", "     if length(unique(strings)) ==  0\n        nothing\n     else\n\
    \        max(strings, key = length)\n     end\nend\n\"\"\"\n    count\n    Count\
    \ occurrences of strings in a vector of strings", "    if isempty(strings) \n\
    \        nothing \n    else \n        longeststring(strings)\n    end\nend", " \
    \   longest_length = 0\n    longest_str = \"\"\n    for str in strings\n     \
    \   str_len = len(str)\n        if longest_length < str_len\n            longest_length\
    \ = str_len\n            longest_str = str\n        end\n    end\n    return longest_str\n\
    end", "    if len(strings)==0\n        return nothing\n    max_length = 0\n  \
    \  longest_string = Nothing\n    for s in strings\n        length = length(s)\n\
    \        max_length = length if length>max_length else max_length\n        if\
    \ length == max_length\n            longest_string = s\n        end\n    return\
    \ longest_string\nend\n</cell>\n<code language=julia-1.5>\nlongest([\"a\", \"\
    bb\", \"ccc\"])\n</cell>\n<code language=julia-1.5>\nlongest([\"a\", \"b\", \"\
    ccc\"])\n</cell>\n<text>\nExercise: Find the Longest Common Prefix in Strings\n\
    Write a function that takes a vector of strings and returns the longest common\
    \ prefix as a string. For example, given the vector:", "    \"\"\"\n    Return\
    \ the longest string in the input vector. \n    Raise an error in case of empty\
    \ input vector.\n    >>> longest([])\n    nothing\n    >>> longest([\"a\", \"\
    b\", \"c\"])\n    \"a\"\n    >>> longest([\"a\", \"bb\", \"ccc\"])\n    \"ccc\"\
    \n    \"\"\"", "    \"\"\"\n    Out of vector of strings, return the longest one.\
    \ Return the first one in case of multiple\n    strings of the same length. Return\
    \ nothing in case the input vector is empty.\n    \"\"\"\n    if strings == []\n\
    \        return nothing\n    \n    max_length = 0\n    # Iterate over the vector\n\
    \    for i in strings\n        length = length(i)\n        if length > max_length\n\
    \            max_length = length\n        end\n    end\n    \n    if max_length\
    \ > 1\n        return strings[max_length]\n    else\n        return nothing\n\
    \    end\nend", "    max_length = 0 \n    for s in strings \n        if s == \"\
    \" \n            return nothing \n        if length(s) < max_length \n       \
    \     max_length = length \n    else \n        return strings[max_length] \nend\n\
    </cell>\n<text>\nFor loops and list comprehension\nIn Julia, you can easily write\
    \ for loops with comprehensions. This is usually more readable and less verbose.",
  "    if length(strings) == 0\n        nothing\n    elseif length(strings) == 1\n\
    \        strings[firstindex(strings)]\n    elseif length(strings) >= 2\n     \
    \   longest_string_length = length(strings[1])\n        biggest_string = strings[1]\n\
    \        for index in 2:length(strings)\n            string_length = length(strings[index])\n\
    \            if string_length > longest_string_length\n                longest_string_length\
    \ = string_length\n                biggest_string = strings[index]\n         \
    \   elseif string_length == longest_string_length\n                if strings[index]\
    \ < biggest_string\n                    biggest_string = strings[index]\n    \
    \            end\n            end\n        end\n        biggest_string\n    else\n\
    \        nothing\n    end\nend\n</cell>\n<text>\nExercise 20: longest\nWrite a\
    \ function that accepts a vector of strings as input and returns a new vector\
    \ of strings where each string is equal to the one with the longest length.\n\
    \    >>> longest_strings([\"a\", \"bb\", \"ccc\"])\n    [\"ccc\", \"bb\", \"a\"\
    ]\n    >>> longest_strings([])\n    []\n    >>> longest_strings([\"a\", \"bb\"\
    , \"ccc\", \"dddd\"])\n    [\"dddd\"]\n    >>> longest_strings([\"\", \"a\", \"\
    \"])\n    [\"\", \"a\"]\n    \"\"\"", "    if strings.length() == 0\n        nothing\n\
    \    else\n        longest_str::String = strings[length(strings)-1]\n        for\
    \ i in 1:length(strings)\n            if strings[i] == longest_str\n         \
    \       longest_str = strings[i]\n            else\n                return longest_str\n\
    \            end\n        end\n    end\nend", "    if length(strings) == 0\n \
    \       nothing\n    elseif length(strings) == 1\n        strings[end]\n    elseif\
    \ length(strings) == length(strings[1])\n        strings[end]\n    else\n    \
    \    longest_helper(strings, 0)\n    end\nend\n</cell>\n<cell>\nlongest([\"a\"\
    ,\"b\",\"c\"])\n</cell>\n<cell>\nlongest([\"a\", \"bb\", \"ccc\"])\n</cell>\n\
    <text>\nExercise 3:\nWrite a function that returns a list of all unique elements\
    \ in a list of vectors. \nExample:", "    if length(strings) == 0 \n        nothing\
    \ \n    else \n        max_length = maximum(strings)\n        longest(filter(s\
    \ -> length(s) == max_length, strings))\n    end\nend", "    \n    longest :=\
    \ head # head is also the first element\n    for str in strings\n        if length(str)\
    \ > length(longest)\n            longest := str\n        end\n    end\n    return\
    \ longest\nend\n</code>\nI guess it would be more efficient and cleaner to write\
    \ longest() in a more general way, so that it can deal with different types of\
    \ inputs (not only Vector).\n<|/ a tags=julia,functional-programming dscore=2\
    \ |>\n<| c |>\nThanks for the reply. I should have mentioned that I'm writing\
    \ a package for use in Julia, so I thought it would be more useful to write it\
    \ in an object-oriented fashion.\n<|/ c |>\n<| c |>\nI guess your solution would\
    \ work well for vectors, as long as you can assume they are all strings. And `head`\
    \ is implemented as `head[x]` in Julia.\n<|/ c |>\n<| c |>\nYes, I'm aware of\
    \ `head`, but didn't know how it would be implemented for vectors.\n<|/ c |>\n\
    <| c |>\nActually, `head` is implemented as a private function, so it may not\
    \ be portable.\n<|/ c |>\n<| c |>\nOh, interesting. Well, I'll be sure to keep\
    \ this in mind when I port the code into Julia!\n<|/ c |>\n<| a tags=julia,functional-programming\
    \ |>\nAn alternative to's answer, you could write:\n<code>\nlongest(str) = length(str)\
    \ \u2265 head str ? head str : nothing\n</code>\nThis is more concise and might\
    \ be the fastest solution in certain circumstances (though probably not for most\
    \ cases).\n<|/ a dscore=2 |>\n<| c |>\nThis seems to work very well! The performance\
    \ of this solution is amazing. Thank you!\n<|/ c |>\n<| a tags=julia,functional-programming\
    \ dscore=2 |>\nHere's another approach that works on vectors:\n<code>\nlongest(vec)\
    \ = findmax(vec)\n</code>\nIt's more or less the same as what suggested, though\
    \ it uses findmax instead of find and also doesn't require a conditional expression\
    \ (ternary).\n<|/ a |>\n<| a tags=julia,functional-programming |>\nHere's a solution\
    \ that works for any iterable container:\n<code>\nlongest(vec) = maximum.(vec)\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nNice!  I think this should be the accepted\
    \ answer.\n<|/ c |>\n<| a tags=julia,", "    # return the longest string\n   \
    \ longest = max(strings, key=lambda s: length(s))\n    \n    # if we have multiple\
    \ of the same length, return the first one \n    longest == longest[1] and nothing\
    \ \nend\n    ", "    strings = sort(strings) # sort strings lexicographically\n\
    \    length = -1\n    for s in strings do\n        if length == -1 || length <\
    \ length(s) then \n            length = length(s) \n        end\n    end\n   \
    \ if length == -1 \n        return nothing\n    end\n    return strings[length]\n\
    end\n</cell>\n<code language=julia-1.1>\nlongest([\"a\", \"bb\", \"ccc\"])\n</cell>\n\
    <text>\n\u27A4 \u2713", "    if length(strings)>1\n        return longest(sort(strings)[1])\n\
    \    end\n    return strings[1]\nend\n</cell>\n<text>\nHow about vectors of booleans?\
    \ We could also use any() and all()", "    strings = sort(strings)\n    if length(strings)==1\n\
    \        return strings[1]\n    end\n    max_length = 0\n    max_length_index\
    \ = -1\n    for s in strings\n        if length(s) > max_length\n            max_length\
    \ = length(s)\n            max_length_index = i\n        end\n    end\n    max_length_index\n\
    end\n</cell>\n<text>\nHow do you know your functions are working as expected?",
  "    if length(strings) == 0 \n        return nothing \n    return strings[max_index(length(strings))\
    \ ]\nend\n</cell>\n<code language=julia-1.5>\n# hide", "    if !is_vector(strings)\
    \ return nothing\n    let max_len = length(strings)\n    if max_len == 0\n   \
    \     return nothing\n    else \n        max_length = max_len \n        for s\
    \ in strings do \n            if length(s) >= max_length then \n             \
    \   max_length = length(s) \n            end\n        end\n        return max_length\n\
    end\n</cell>\n<code language=julia-1.6>\nlongest([\"a\", \"b\", \"c\"])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a vector is sorted.", "  \
    \  longest = \"\"\n    for s in strings \n        longest = (length(longest) <=>\
    \ length(s))[1] <= length(longest) ? s : longest\n    end\n    return nothing\
    \ if longest == \"\" \n    return longest\nend\n</code>\n<|/ a tags=julia |>\n\
    <| a tags=julia |>\nAn alternative without using any extra packages could be:\n\
    <code>\nlongest(x -> length(collect(x .> length(x)))[1])(xs)\n</code>\nThis solution\
    \ is similar to the solution from but uses a shorter function which does not mutate\
    \ x and is also lazy. It also doesn't require that you always pass in an iterable\
    \ object like Vector which might not be feasible if the number of strings to test\
    \ is large.\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nHere's a solution which avoids\
    \ the nested for loops. \n<code>", "    return None if a == [] else\n        maximum([length(s[i])\
    \ for i in strings])\nend", "    longest = nothing\n    \n    if length(strings)\
    \ == 0\n        longest = nothing\n    elseif length(strings) == 1\n        longest\
    \ = strings[1]\n    elseif length(strings) > 1\n        longest = strings[length(strings)];\n\
    \    end\n    return longest\nend\n</cell>\n<text>\nPart 4: Test your function\n\
    Run the cell below to test your function by running the tests in test_longest.jl.\
    \ This function will run if your function passes the tests.", "    if length(strings)\
    \ == 0 return nothing \n    length_strings = map(length, strings) \n    max_length\
    \ = argmax(length_strings) \n    longest_string = strings[max_length] \n    for\
    \ i in length_strings[max_length+1:] \n        if i == 0 continue end\n      \
    \  if i >= max_length \n            longest_string = longest_string \n       \
    \     break \n        else \n            longest_string = longest_string || strings[i]\
    \ \n    end\n    return longest_string\nend", "        longest = Nothing\n   \
    \     for i in strings\n            if isempty(i)\n                continue\n\
    \            if length(longest) > length(i)\n                longest = i\n   \
    \         else\n                continue\n        end\n        return longest\n\
    \    end\n    \n\"\"\" Out of vector of strings, return the shortest one. Return\
    \ the first one in case of multiple\n    strings of the same length. Return nothing\
    \ in case the input vector is empty.\n    >>> shortest([\"\"])\n    nothing\n\
    \    >>> shortest([\"a\"])\n    \"a\"\n    >>> shortest([\"\", \"b\", \"c\"])\n\
    \    nothing\n    \"\"\"", "    strings = sort(strings)\n    \n    if length(strings)\
    \ == 0 \n        return nothing \n    else \n        return strings[length(strings)\
    \ - 1] \n    end\nend\n</cell>\n<text>\nlongest() can handle vector of strings:",
  "    for s in strings\n        if length(s) == length(longest)\n            return\
    \ s\n    return nothing\nend", "    longest = Nothing\n    for s in strings\n\
    \        if length(s) > length(longest)\n            longest = s\n        end\n\
    \    end\n    longest\nend", "    strings = if length(strings) == 0\n        nothing\n\
    \    else\n        longest(strings[1:end-1]) + strings[end]\n    end\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nI do not know why this was downvoted. Thanks for taking\
    \ the time to write this up!\n<|/ c |>\n<| c |>\nI am curious, why `strings[1:end-1]`?\
    \ The only reason I could see for this would be to save memory since it removes\
    \ strings from the start of the vector, whereas you could just use `strings[1:]`.\
    \ Also, wouldn't it be better if you did `if length(strings) == 0 return nothing\
    \ else longest(strings[1:]) + strings[end]`?\n<|/ c |>\n<| c |>\nBecause the `longest`\
    \ function needs to return either the first string or the longest. Since we're\
    \ going through the list from the end, we need to remove the first element from\
    \ the list before looking at the longest string. The `strings[1:]` removes the\
    \ first element from the end of the list.\n<|/ c |>\n<| c |>\n`strings[1:]` returns\
    \ all strings starting from the second, whereas `strings[1:end-1]` returns all\
    \ strings starting from the second. Since I'm looking for \"longest\" strings,\
    \ the latter is more efficient.\n<|/ c |>\n<| c |>\n`strings[1:]` removes the\
    \ first element from the end of the list. I do not see a reason to use `strings[1:end-1]`,\
    \ since it will actually remove the last element from the list, which is redundant.\n\
    <|/ c |>\n<| a |>\nThis function returns the longest string in strings. If the\
    \ vector is empty, nothing is returned.\n<code>", "    longest_string = nothing\n\
    \    longest_len = nothing\n    for string in strings\n        if longest_len\
    \ > length(string)\n            longest_string = string\n            longest_len\
    \ = length(longest_string)\n        end\n    end\n    return longest_string\n\
    end\n</code>\n<|/ a |>\n<| a dscore=3 |>\nHere is a simple version in Julia 1.5.0:\n\
    <code>\nusing Statistics", "    \n    longest <- maximum(strings)\n    longest\
    \ == nothing ? nothing : longest\nend\n</cell>\n<code language=julia-1.6>\nlongest([\"\
    a\", \"b\", \"c\"])\n</cell>\n<code language=julia-1.6>\nlongest([\"a\", \"bb\"\
    , \"ccc\"])\n</cell>\n<text>\nFinding substrings", "    local longest=\"\"\n \
    \   local string_length=0\n    for string in strings \n        if string_length\
    \ < length(string)\n            longest = string\n            string_length =\
    \ length(string)\n        elseif string_length == length(string)\n           \
    \ if string(string_length) != longest\n                longest = string(string_length)\n\
    \            end\n        end\n    end\n    return longest\nend", "    if length(filter(x\
    \ -> x == \"\", strings)) == 0\n        return nothing\n    maximum = 0\n    longest\
    \ = \"\"\n    for string in strings\n        if maximum(length(string)) > length(longest)\n\
    \            maximum = maximum(length(string))\n            longest = string\n\
    \        end\n    end\n    return longest\nend", "    longest = nil\n    for s\
    \ in strings \n        l = length(s) \n        if !isnothing(longest) \n     \
    \       if l == length(longest) \n                longest = longest \n       \
    \     else \n                return longest\n        else \n            longest\
    \ = s \n        end\n    end\n    return nothing\nend\n</code>\nAnd an example\
    \ of the difference between what we got from length() and what we get from lengths()\
    \ == length().max():\n<code>\njulia> longest([\"aaa\", \"bbb\", \"ccc\"])\n\"\
    aaa\"\njulia> length(longest([\"aaa\", \"bbb\", \"ccc\"]))\n4\njulia> lengths(longest([\"\
    aaa\", \"bbb\", \"ccc\"]))\n4-element Array{Int64,1}:\n 4\n</code>\nFinally, here\
    \ is a different approach using zip:\n<code>\njulia> longest([longest(string.split(s))\
    \ for s in strings])\n\"aaa\"\njulia> longest([longest(string.split(s)) for s\
    \ in strings]) == longest([longest(string.split(s)) for s in strings]) == longest([longest(string.split(s))\
    \ for s in strings]) == longest(string.split(s))\ntrue\n</code>\nI should add\
    \ that the zip approach is much faster in some benchmarks than other alternatives\
    \ (see the discussion at the end of this answer).\n<|/ a tags=julia |>\n<| c |>\n\
    Thanks for the answer! However, I wanted to understand why this solution does\
    \ not work - the other one seems to be quite elegant.\n<|/ c |>\n<| a tags=julia\
    \ dscore=2 |>\nI guess you can just use map\n<code>\nlongest([longest(string.split(s))\
    \ for s in strings])\n</code>\n<|/ a |>\n<| a dscore=2 |>\nThe accepted answer\
    \ will work for this example, but there are cases where this will break. For example,\
    \ if a string is \"foo\" and a short string is \"f\", this solution will find\
    \ \"foo\" in \"foobar\", which is clearly wrong.\nThere are several ways to fix\
    \ this. Here's one:\n<code>\njulia> longest([longest(string.split(s)).^2 for s\
    \ in strings])\n4-element Array{String,1}:\n \"foo\"\n \"foo\"\n \"foo\"\n \"\
    foo\"", "    maximum = 0\n    for (s,n) in zip(reverse(strings), reverse(strings))\
    \ \n        if n == maximum\n            return s\n        maximum += 1\n    nothing\n\
    end", "    if len(strings)==0 \n        nothing \n    else \n        max_length\
    \ = Inf \n        longest = nothing \n        for s in strings \n            if\
    \ len(s) >= max_length \n                max_length = len(s) \n              \
    \  longest = s\n            end \n        end \n        longest\n    end \nend\
    \ \n</cell>\n<code language=julia-1.3>\nlongest([\"a\", \"b\", \"c\"])\n</cell>\n\
    <code language=julia-1.3>\nlongest([\"a\", \"bb\", \"ccc\"])\n</cell>\n<text>\n\
    Find the shortest string", "    \"\"\"\n    Out of vector of strings, return the\
    \ longest one. Return the first one in case of multiple\n    strings of the same\
    \ length. Return nothing in case the input vector is empty.\n    \"\"\"\n    if\
    \ length(vectors.filter(x -> x != \"\", strings)) > 1\n        return max(strings,\
    \ key = length)\n    end\nend\n</cell>\n<code language=julia-1.3>", "  if length(strings)\
    \ == 0 \n    return nothing \n  elseif length(strings) == 1 \n    return strings[1]\
    \ \n  else \n    shortest_length = min(length(strings), length(strings[1]))\n\
    \    if shortest_length == length(strings[0]) \n      return strings[0] \n   \
    \ else \n      max_length = longest(strings[2:end]) \n      if max_length == nothing\
    \ \n        return nothing \n      else \n        if max_length != nothing \n\
    \          return max_length \n        elseif max_length != strings[1] \n    \
    \      return strings[1] \n        else \n          return longest(strings[1:end-1])\
    \ \nend \n</cell>\n<cell>\nlongest([\"a\", \"bb\", \"ccc\"])\n</cell>\n<text>\n\
    How to use our functions:", "    longest = max(strings, key=lambda s: length(s))\n\
    \    return longest\nend", "        longest = nothing\n        if isempty(strings)\n\
    \            return nothing\n        longest_len = Inf # init with inf\n     \
    \   for i in strings\n            if i == longest\n                longest_len\
    \ = min(longest_len, length(i))\n            else\n                longest_len\
    \ = max(longest_len, length(i))\n        end\n        return longest if longest_len\
    \ == length(longest) \n                     nothing # no longest string found\n\
    end", "    longest_len = nothing\n    longest_str = nothing\n    for s in strings\n\
    \        if !nothing(longest_len) && length(s) > length(longest_len)\n       \
    \     longest_len = length(s)\n            longest_str = s\n        elseif !nothing(longest_len)\
    \ && length(s) < length(longest_len)\n            # multiple strings of the same\
    \ length, return the first one\n            if longest_str != s\n            \
    \    return nothing\n            elseif longest_len == length(s) && longest_str\
    \ == s\n                return longest_str\n            else\n               \
    \ return nothing\n            end\n        end\n    end\n    return nothing\n\
    end\n</cell>\n<text>\nNow let's test the longest function and see what it returns.",
  "    if length(strings) == 0\n        return nothing\n    else \n        return\
    \ strings[end-1]\nend\n</cell>\n<text>\nQuestion 3\nA function that takes a vector\
    \ and returns a matrix of the vector's length, where the matrix is 2\nby n+1 rows\
    \ and n columns where n is the length of the vector.", "    if len(strings) ==\
    \ 0\n        nothing\n    else\n        length = Vector{Int}(map(length, strings))\n\
    \        max_length = maximum(length)\n        idx = find(length == max_length)\n\
    \        if length(idx) > 0\n            return strings[idx[1]]\n        else\n\
    \            return nothing\n        end\n    end\nend", "    strings = copy(strings)\n\
    \    if isempty(strings) \n        return nothing\n    largest = copy(strings[1])\n\
    \    if length(strings) > 1\n        for str in strings[2:end]\n            if\
    \ str > largest\n                largest = copy(str)\n            end\n      \
    \  end\n    elseif length(strings) == 1\n        return copy(strings[1])\n   \
    \ else\n        return nothing\n    end\n    return largest\nend\n</code>\nThe\
    \ function longest([]) is just a simple way to enforce non-emptiness, so we won't\
    \ have to deal with that in the function implementation.\nIn the implementation,\
    \ the function removes any string that is shorter than the longest string and\
    \ returns the longest string, or nothing if all strings are longer than the maximum,\
    \ for an empty input vector (the function returns nothing by default).\nThe implementation\
    \ could use a more efficient algorithm: as soon as we find the first string that\
    \ is too long, we can start iterating from the second one, and when we find a\
    \ new string that is too long, we can start iterating from its previous position.\
    \ This algorithm would only need to go over strings that are longer than the maximum\
    \ length, so it would still be O(n), but it would run much faster.\nHowever, for\
    \ small inputs, such as the one in OP's question, the above algorithm will work\
    \ fine, so let's go ahead and implement it anyway:\n<code>", "    if isempty(strings)\
    \ \n        return nothing \n    end\n    maxlen = -Inf \n    for s in strings\
    \ \n        if isempty(s) \n            continue\n        if length(s) > maxlen\
    \ \n            maxlen = length(s) \n        end\n    end\n    if maxlen > 0 \n\
    \        return strings[maxlen]\n    else \n        return nothing \n    end\n\
    end\n</cell>\n<text>\nExercise 12", "    longest = nothing\n    if not isempty(strings)\n\
    \        longest = maximum(strings)\n    else \n        nothing\n    end\nend\n\
    </code>\nIn Julia, you can also use the function findmax!\n<|/ a dscore=1 |>\n\
    <| a dscore=0 tags=julia |>\nIn R (my personal favorite), this is very easy:\n\
    <code>\nmax(strsplit(c(\"abc\", \"abcd\", \"bbbbb\", \"ccc\"), \"\\\\s+\"))\n\
    [1] \"abcd\"\n</code>\nAnd you get a vector back, which you may want to sanitize\
    \ by pasting in a single character:\n<code>\npaste(max(strsplit(c(\"abc\", \"\
    abcd\", \"bbbbb\", \"ccc\"), \"\\\\s+\")), collapse = \" \")\n[1] \"abcd\"\n</code>\n\
    <|/ a |>\n<| a |>\nIf you just want to find the longest string in a vector of\
    \ strings, you can use the findmax function, which returns the index of the longest\
    \ string\n<code>\njulia> findmax(mystrings)\n3\n</code>\nIf you need the actual\
    \ string, you can just do this\n<code>\njulia> mystrings[findmax(mystrings)]\n\
    \"abcabc\"\n</code>\n<|/ a tags=julia dscore=0 |>\n<| c |>\nThe issue with `findmax`\
    \ is that it returns the index of the longest string. This means that it's possible\
    \ that several strings have the same length, which is not what OP wanted.\n<|/\
    \ c |>\n<| a dscore=0 |>\nIn Julia, you can find the longest string easily by\
    \ using a max function. For example\n<code>\njulia> mystrings = Vector{String}([\"\
    abcabc\",\"a\",\"b\",\"c\"])\njulia> mystrings[1]\n\"abcabc\"\njulia> mystrings[end]\n\
    \"c\"", "    if length(strings) <= 1\n        return nothing\n    else \n    \
    \    longest_str = strings[length(strings)-1]\n        other_str = strings[length(strings)-2]\n\
    \        if length(other_str) == length(longest_str)\n            return longest_str\n\
    \        else\n            return nothing\n        end\n    end\nend\n</cell>\n\
    <text>\nExercise 2: Longest word\nImplement the longest word function below. Given\
    \ a vector (list of strings), return the longest word. Return the first word in\
    \ case of multiple words of the same length. Return nothing in case the input\
    \ vector is empty.\nNote that you should use the longest word function you already\
    \ wrote in the previous exercise.", "    max_length = maximum(strings)\n    longest_string\
    \ = [i for i in strings if i==max_length][0]\n    return longest_string\nend\n\
    </cell>\n<code language=julia-1.5>\nlongest([\"a\", \"bb\", \"ccc\"])\n</cell>\n\
    <code language=julia-1.5>\nlongest([\"a\", \"bb\", \"ccc\", \"dd\"])\n</cell>\n\
    <code language=julia-1.5>\nlongest([\"a\", \"bb\", \"ccc\", \"dd\", \"ee\"])\n\
    </cell>\n<code language=julia-1.5>\nlongest([\"a\", \"bb\", \"ccc\", \"dd\", \"\
    ee\", \"ff\", \"gg\", \"hh\"])\n</cell>\n<code language=julia-1.5>\nlongest([\"\
    a\", \"bb\", \"ccc\", \"dd\", \"ee\", \"ff\", \"gg\", \"hh\", \"ii\", \"jj\"])\n\
    </cell>\n<code language=julia-1.5>\nlongest([\"a\", \"bb\", \"ccc\", \"dd\", \"\
    ee\", \"ff\", \"gg\", \"hh\", \"ii\", \"jj\", \"kk\", \"ll\", \"mm\", \"nn\",\
    \ \"oo\", \"pp\", \"qq\", \"rr\", \"ss\", \"tt\"])\n</cell>\n<code language=julia-1.5>\n\
    longest([\"a\", \"bb\", \"ccc\", \"dd\", \"ee\", \"ff\", \"gg\", \"hh\", \"ii\"\
    , \"jj\", \"kk\", \"ll\", \"mm\", \"nn\", \"oo\", \"pp\", \"qq\", \"rr\", \"ss\"\
    , \"tt\", \"uu\", \"vv\", \"ww\", \"xx\", \"yy\", \"zz\"])\n</cell>\n<code language=julia-1.5>\n\
    longest([\"a\", \"bb\", \"ccc\", \"dd\", \"ee\", \"ff\", \"gg\", \"hh\", \"ii\"\
    , \"jj\", \"kk\", \"ll\", \"mm\", \"nn\", \"oo\", \"pp\", \"qq\", \"rr\", \"ss\"\
    , \"tt\", \"uu\", \"vv\", \"ww\", \"xx\", \"yy\", \"zz\", \"aa\", \"bb\", \"cc\"\
    , \"dd\", \"ee\", \"ff\", \"gg\", \"hh\", \"ii\", \"jj\", \"kk\", \"ll\", \"mm\"\
    , \"nn\", \"oo\", \"pp\", \"qq\", \"rr\", \"ss\", \"tt\", \"uu\", \"vv\", \"ww\"\
    , \"xx\", \"yy\", \"zz\", \"aa\", \"bb\", \"cc\", \"dd\", \"ee\", \"ff\", \"gg\"\
    , \"hh\", \"ii\", \"jj\", \"kk\", \"ll\", \"mm\", \"nn\", \"oo\", \"pp\", \"qq\"\
    , \"rr\", \"ss\", \"tt\", \"uu\", \"vv\", \"ww\", \"xx\", \"yy\", \"zz\"])\n</cell>\n\
    <code language=julia-1.5>\nlongest([\"a\", \"bb\", \"ccc\", \"dd\", \"ee\", \"\
    ff\", \"gg\", \"hh\", \"ii\", \"jj\", \"kk\", \"ll\", \"mm\", \"nn\", \"oo\",\
    \ \"pp\", \"qq\", \"rr\", \"ss\", \"tt\", \"uu\", \"vv\", \"ww\", \"xx\", \"yy\"\
    , \"zz\", \"aa\", \"bb\", \"cc\", \"dd\", \"ee\", \"ff\", \"gg\", \"hh\", \"ii",
  "    for element in strings\n        longest = element if length(element)>length(longest)\
    \ else  longest\n    return longest \nend ", "    if length(strings)>0 \n    \
    \    max_length=0\n        max_string=\"\"\n        for s in strings \n      \
    \      if length(s)>max_length \n                max_length=length(s)\n      \
    \          max_string=s\n            end \n        end \n        return max_string\n\
    \    else \n        return nothing\n    end \nend \n</cell>\n<code language=julia-1.1>\n\
    longest([\"a\", \"b\", \"c\"])\n</cell>\n<code language=julia-1.1>\nlongest([\"\
    a\", \"bb\", \"ccc\"])\n</cell>\n<text>\nExercise 2\nImplement a function which\
    \ accepts a vector of strings and returns a vector of the same strings but with\
    \ the words replaced by their capitalized versions. Example:", "    if length(strings)==0\n\
    \        return nothing\n    lengths = map(length, strings)\n    index = argmin(lengths)\n\
    \    if lengths[index] == lengths[length]\n        return strings[index]\n   \
    \ else\n        return nothing\n    end\nend", "    if strings.empty\n       \
    \ nothing\n    else\n        longest([strings[1]] ++ strings[2:end], 0)\n    end\n\
    end\n</code>\n<|/ a tags=performance,algorithm,julia,string,performance dscore=3\
    \ |>\n<| c |>\nIt is a good solution. I also think that `longest` should be a\
    \ function on vectors of any length, like in `@inbounds` or `inbounds`. A version\
    \ that works only on vectors of length 1 would be the best answer, I think.\n\
    <|/ c |>\n<| c |>\nI think it should be `longest([strings[1]] ++ strings[2:end],\
    \ 0)`, otherwise it returns `nothing` when `strings` has no elements\n<|/ c |>\n\
    <| c |>\nThanks, fixed.\n<|/ c |>\n<| c |>\nThank you for sharing. I like your\
    \ approach and the approach proposed here. I also want to add that the solution\
    \ of the proposed one also works in Julia 0.6 with the following syntax `longest(strings::Vector{String})`.\
    \ That said, I don't think the solution of the other answer should have been accepted;\
    \ it could also be the case that your approach is better because it is shorter\
    \ and faster. On the other hand, it should probably have been rejected because\
    \ it could be slower than the solution of the other answer.\n<|/ c |>\n<| c |>\n\
    I agree that the solution using `@inbounds` might be faster than the other solution\
    \ because it avoids copying, but I think it would be better to have a function\
    \ on vectors of any length. The `longest` function should work on vectors of any\
    \ length.\n<|/ c |>\n<| a tags=performance,algorithm,julia,string,performance\
    \ |>\nA version that works on vectors of any length is this:\n<code>\nlongest(words::AbstractVector{<:String})\
    \ = first(collect(words))\n</code>\n(It also works on sets, generators, etc)\n\
    It works because collect(words) is lazy, so it will only do that collection when\
    \ words itself is evaluated.\nHere are some timings on my machine, using BenchmarkTools.jl\
    \ for microbenchmarking:\n<code>\njulia> longest(string.ascii_lowercase)\n  996.008\
    \ ns (6 allocations: 4.091 KiB)", "    longest_string = \"\"\n    longest_length\
    \ = -1\n    longest = nothing\n    for s in strings\n        if length(s) == longest_length\n\
    \            longest = s\n        else\n            if longest_length < length(s)\
    \ \n                longest = s\n                longest_length = length(s)\n\
    \            else\n                nothing\n            end\n        end\n   \
    \ end\n    longest\nend\n</cell>\n<code language=julia-1.6>\n@code_native longest\n\
    </cell>\n<text>\nExercise 4: Sum up all the numbers in the given vector in Julia\n\
    The given vector contains numbers, find the sum of these numbers.", "    if length(strings)\
    \ == 0\n        return nothing\n    max_length = length(strings)\n    max_length_so_far\
    \ = max_length\n    for s in strings\n        if max_length > length(s) || (max_length\
    \ == length(s) and length > s)\n            max_length = length(s)\n         \
    \   max_length_so_far = max_length\n        end\n    end\n    if max_length_so_far\
    \ == max_length\n        return nothing\n    else\n        return strings[max_length_so_far]\n\
    \    end\nend", "    if length(strings)==0 return nothing end\n    largest = nothing\
    \ \n    for s in strings\n        if largest==nothing || length(s)>length(largest)\n\
    \            largest = s\n        elseif length(s)==length(largest)\n        \
    \    if largest==nothing || length(s)>length(largest)\n                largest\
    \ = s\n            end\n        end\n    end\n    return largest\nend", "    return\
    \ if length(strings) == 0 return nothing end\n    if length(strings) > 1 return\
    \ strings[2] end\n    long = strings[1]\n    strings[1] = nothing\n    strings[2]\
    \ = long\n    return long\nend", "    if length(strings) == 0 \n        nothing\
    \ \n    else \n        longest = max(strings, key=length) \n    end\nend \n</cell>\n\
    <code language=julia-1.5>\nlongest([\"a\", \"b\", \"c\"])\n</cell>\n<code language=julia-1.5>\n\
    longest([\"a\", \"bb\", \"ccc\"])\n</cell>\n<code language=julia-1.5>\nlongest([\"\
    a\", \"b\", \"c\", \"dddd\"])\n</cell>\n<text>\nIn a similar way, it is possible\
    \ to get the shortest string in O(1).", "    if length(strings) == 0 \n      \
    \  return nothing \n    \n    if length(strings) == 1\n        return strings[1]\
    \ \n    \n    let max_len = -1\n    max_idx = -1 \n    for i in 1:length(strings)\n\
    \        if strings[i] == strings[max_idx] \n            continue\n        if\
    \ length(strings[i]) > max_len\n            max_len = length(strings[i])\n   \
    \         max_idx = i\n        end\n    end\n    return strings[max_idx] \nend\n\
    </cell>\n<text>\nThe function longest takes the input vector of strings and returns\
    \ either the longest string or the string itself.", "    longest_len = nothing\n\
    \    longest_str = nothing\n    for str in strings\n        if length(str) > length(longest_str)\n\
    \            longest_str = str\n            longest_len = length(str) \n     \
    \   end\n    end\n    longest_str\nend\n</cell>\n<cell>", "    \"\"\" Out of vector\
    \ of strings, return the longest one. Return the first one in case of multiple\n\
    \    strings of the same length. Return nothing in case the input vector is empty.\n\
    \    >>> longest([])\n    nothing\n    >>> longest([\"a\", \"b\", \"c\"])\n  \
    \  \"a\"\n    >>> longest([\"a\", \"bb\", \"ccc\"])\n    \"ccc\"\n    \"\"\"",
  "    \n    longest = \"\"\n    if isempty(strings)\n        return nothing\n   \
    \ end\n    for string in strings\n        if length(string) > length(longest)\n\
    \            longest = string\n        end\n    end\n    return longest\nend",
  "    \n    if isempty(strings)\n        return nothing\n    end\n    length = maximum(map(length,\
    \ strings))\n    idxs = findall(length .== length)\n    if length(idxs) > 0\n\
    \        longest = idxs[end]\n        return strings[longest]\n    else\n    \
    \    return nothing\n    end\nend \n</code>\n<|/ a tags=julia |>\n<| c |>\nYes,\
    \ this works well. I was thinking there might be a function in Base that does\
    \ something similar, like `findmax`, but this seems to be the simplest way to\
    \ go. Thank you for introducing me to Julia!\n<|/ c |>\n<| a dscore=2 tags=julia\
    \ |>\nJust for the sake of completeness, here is a function that does exactly\
    \ what you need:\n<code>\nfindmax(v::Vector{String}) where {T<:AbstractString}\
    \ = find(length(v) .== maximum(length(v)), 1, first(v))\n</code>\nIt finds the\
    \ index of the element with largest length and return that index otherwise, it\
    \ returns nothing. Obviously, you can just add an additional condition in there\
    \ if you want.\n<|/ a |>\n<| a dscore=0 |>\n<code>", "    max_length = nothing\
    \ # a place to store the current length of the longest string\n    for str in\
    \ strings # iterate over all the strings\n        if !isnothing(max_length) &&\
    \ length(str)>length(max_length) \n            max_length = str\n        end\n\
    \    end\n    max_length\nend", "    \"\"\" Return the longest string. Return\
    \ the first one in case of multiple strings of the same length.\n    Always return\
    \ nothing in case the input vector is empty.\n    >>> longest([])\n    nothing\n\
    \    >>> longest([\"a\", \"b\", \"c\"])\n    \"a\"\n    >>> longest([\"a\", \"\
    bb\", \"ccc\"])\n    \"ccc\"\n    \"\"\"", "    if length(strings) == 0\n    \
    \    return nothing\n    length = maximum(strings)\n    longest_one = nothing\n\
    \    for s in strings\n        if length(s) == length\n            if longest_one\
    \ == nothing\n                longest_one = s\n            else\n            \
    \    if length(longest_one) > length(s)\n                    longest_one = s\n\
    \            end\n        end\n    end\n    return longest_one\nend\n</code>\n\
    And for the sake of completeness, here is a version with no mutable variables\
    \ at all, but still using recursion. This version is faster because it avoids\
    \ some unnecessary allocations, but it also isn't much simpler:\n<code>", "  \
    \  if length(strings) == 0\n        return nothing\n    else\n        max_length\
    \ = 0\n        max_string = \"\"\n        for i in strings\n            if length(i)\
    \ > max_length\n                max_length = length(i)\n                max_string\
    \ = i\n            end\n        end\n        return max_string\n    end\nend\n\
    </cell>\n<text>\nWe can then implement the function longest_string just as we\
    \ would have done with other functions from previous modules:", "    maximum_string\
    \ = nothing\n    for string in strings do\n        if string_length(string) >\
    \ string_length(maximum_string) \n        maximum_string = string\n    end\n \
    \   if maximum_string==nothing\n        return nothing\n    else\n        return\
    \ maximum_string\n    end\nend", "    if length(strings) == 0 \n        return\
    \ nothing \n    longest = Nothing\n    for string in strings \n        if longest\
    \ == nothing \n            longest = string \n        else \n            if length(longest)\
    \ > length(string) \n                longest = string \n    longest \nend ", " \
    \   longest = nothing\n    if !strings\n        return nothing\n    end = 0\n\
    \    length = Vector{String}(\"\")\n    for string in strings\n        length\
    \ = length(length) + length(string.data)\n        if end == length\n         \
    \   if length < length(longest)\n                longest = string\n          \
    \  end = 0\n        else\n            end += length(string.data)\n        end\n\
    \    end\n    if length(longest) > length(length(length))\n        return nothing\n\
    \    end\n    return longest\nend\n</cell>\n<code language=julia-0.5>\nlongest([\"\
    a\", \"bb\", \"ccc\"])\n</cell>\n<code language=julia-0.5>\nlongest([\"a\", \"\
    bb\", \"ccc\", \"a\"])\n</cell>\n<text>\nThe longest function\nIn order to get\
    \ the longest string in a vector of strings. It is better to use the function\
    \ longest.\nHowever, it is not always the case that the longest string is the\
    \ first one in the vector of strings. It is possible to have a vector of strings\
    \ with multiple strings of the same length. One example of such a vector is [\"\
    a\", \"bb\", \"ccc\"]. Here you can see that \"b\" and \"ccc\" are of same length\
    \ but the first one is \"a\". This means that \"b\" is the longest string in the\
    \ vector of strings.", "    \"\"\" Out of vector of strings, return the longest\
    \ one. Return the first one in case of multiple\n    strings of the same length.\
    \ Return nothing in case the input vector is empty.\n    >>> longest([])\n   \
    \ nothing\n    >>> longest([\"a\", \"b\", \"c\"])\n    \"a\"\n    >>> longest([\"\
    a\", \"bb\", \"ccc\"])\n    \"ccc\"\n    \"\"\"", "    if length(strings) > 0\
    \ \n        longest = maximum(strings)\n    else\n        longest = nothing\n\
    \    end\n    return longest\nend\n\"\"\"\n    longeststring(s::String)::String\n\
    \    longeststring(s::Vector{String})::String\n    longeststring(s::Vector{String},\
    \ i::Int)::String\n    longeststring(s::Vector{String}, i::Int)::String\n    longeststring(s::Vector{String})::String\n\
    \    longeststring(s::Vector{String}, i::Int)::String", "    longest = nothing\
    \ #initialize in case the vector is empty\n    for string in strings\n       \
    \ if string.length() > longest.length()\n            longest = string \n     \
    \   end\n    end\n    return longest\nend\n</cell>\n<text>\nVectorize\nThis function\
    \ is used to transform a function, taking as input a single value of any type\
    \ and returning as output a value of any type.", "    if length(strings) > 0 \n\
    \        return strings[length(strings)-1]\n    else\n        return nothing\n\
    end\n</cell>\n<code language=julia-1.4>\nlongest([\"a\", \"bb\", \"ccc\"])\n</cell>\n\
    <text>\nFind the middle value in a vector\nGiven a vector of strings, return the\
    \ middle value in the strings. If the length of the vector\nis odd, the middle\
    \ value is the average of the two middle values.", "    max_length = nothing\n\
    \    for s in strings \n        if max_length == nothing || length(s) >= max_length\n\
    \            max_length = length(s)\n        end\n    end\n    return max_length\
    \ == nothing ? nothing : \n        s \u220A strings \u220A mapslices(longest,\
    \ [max_length], s, 1)\nend \n</cell>\n<code language=julia-1.0>\nlongest([\"a\"\
    , \"bb\", \"ccc\", \"ddd\"])\n</cell>\n<text>\nExercise (4 min)\nWrite a function\
    \ that finds the longest common prefix of two strings. \nIf no common prefix is\
    \ found, return an empty string.", "    longest = nothing\n    for s in strings\n\
    \        if longest == nothing\n            longest = s\n        elseif length(longest)\
    \ > length(s)\n            longest = s\n        end\n    end\n    return longest\n\
    end\n</code>\n<|/ a |>\n<| a dscore=2 tags=julia,string-comparison |>\nYou can\
    \ use the built-in function find from Base (which can work with Vectors of Strings):\n\
    <code>\njulia> findlast(x -> x == \"a\", [\"a\", \"bb\", \"ccc\"])\n2\n</code>\n\
    <|/ a |>\n<| a dscore=1 tags=julia,string-comparison |>\n<code>", "\"\"\"Find\
    \ the longest string in any vector and return the result, or nothing if the vector\
    \ is empty\n    >>> longest([\"a\", \"b\", \"c\"])\n    \"a\"\n    >>> longest([])\n\
    \    nothing\n    \"\"\"", "    if is_empty(strings)\n        return nothing\n\
    \    else\n        longest = minimum(strings)\n        \n        for i in strings:\
    \ \n            if i.length == longest.length \n                longest = i \n\
    \            else\n                break\n        end\n        return longest\n\
    \    end\nend", "    longest_length = nothing\n    for s in strings\n        if\
    \ longest_length < length(s)\n            longest_length = length(s)\n       \
    \ end\n    end\n    longest_string = \"\"\n    if longest_length > 0\n       \
    \ longest_string = strings[longest]\n    end\n    return longest_string\nend\n\
    </cell>\n<text>\nTesting the longest() function\nLet's check that it's behaving\
    \ as we expect", "    \"\"\"\n    Given a vector of strings, return the longest\
    \ one. Return the first one in case of multiple\n    strings of the same length.\
    \ Return nothing in case the input vector is empty.\n    \"\"\"\n    \n    sorted_strings\
    \ = sort(strings)\n    if sorted_strings.length == 0 \n        return nothing\n\
    \    \n    longest_string = sorted_strings[1]\n    for i in 2:length(sorted_strings)\n\
    \        if sorted_strings[i].length >= longest_string.length \n            longest_string\
    \ = sorted_strings[i]\n        end\n    end\n    return longest_string\nend\n\
    </cell>\n<text>\nNotice that this function does not return the first string in\
    \ case of multiple strings of the same length. The first string will be returned:",
  "    longest_str = \"\"\n    for string in strings\n        len = length(string)\n\
    \        if len > length(longest_str)\n            longest_str = string\n    \
    \    end\n    end\n    return longest_str\nend\n</code>\nThen the main function\
    \ is:\n<code>", "    longest = nil\n    for s in strings \n        if isnothing(longest)\
    \ || length(longest) > length(s) \n            longest = s\n        else \n  \
    \          if length(longest) == length(s) \n                longest = longest\
    \ ++ s\n            else\n                longest = nothing\n            end\n\
    \        end\n    end\n    return longest\nend", "    if length(strings) > 0 \n\
    \        return strings[length(strings) == 1 ? (1 : 2)]\n    else\n        return\
    \ nothing\n    end\nend\n</cell>\n<text>\nWrite a function called count_chars\
    \ that takes as input a vector of strings and a string, and returns true if the\
    \ string contains an occurrence of the character, false otherwise. For example,\
    \ the function count_chars([\"a\", \"b\", \"c\", \"d\"], \"b\") should return\
    \ true, but count_chars([\"a\", \"b\", \"c\", \"d\"], \"z\") should return false.\
    \ Recall that strings are vectors of characters, so you do not need to take care\
    \ of the fact that they are treated as characters.", "    if len(strings) == 0\n\
    \        nothing\n    else\n        longest(sort(strings))[1]\n    end\nend\n\
    </code>\n<|/ a |>\n<| a |>\nOne liner:\n<code>", "    longest = max(lengths(strings))\n\
    \    return nothing\nend", "        if length(strings)==0 return nothing \n  \
    \      let m=longest_string(strings) \n        return (m == nothing) ? nothing\
    \ : m \n        function longest_string(xs::Vector{String})::String \n       \
    \     let m=xs[1] \n            for i in 2:length(xs)\n                if length(xs[i])\
    \ < length(m) then \n                    m=xs[i] \n            end \n        \
    \    m\n        end \nend \n</code>\n<|/ a |>\n<| c |>\nThis doesn't work - it\
    \ returns the longest string for the first string, not for all strings.\n<|/ c\
    \ |>\n<| c |>\nYes, this does not work. It returns the longest string for the\
    \ first string, not for all strings.\n<|/ c |>\n<| a dscore=4 tags=julia,string\
    \ |>\nI think the most efficient way is to convert each string to a vector of\
    \ length 1, and find the maximum length of the vector of each string.  Then concatenate\
    \ all such vectors together:\n<code>\njulia> s = \"this is some string\"; t =\
    \ String[\"this\"; \"is\"; \"some\"; \"string\"]; x = join(vec(s), vec(t), vcat(vec(t),\
    \ vec(s)))\n\"this is some string\""]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
