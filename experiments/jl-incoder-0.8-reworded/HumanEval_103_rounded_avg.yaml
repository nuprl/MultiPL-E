name: HumanEval_103_rounded_avg
language: jl
prompt: "\"\"\"You are given two positive integers n and m, and your task is to compute\
  \ the\n    average of the integers from n through m (including n and m). \n    Round\
  \ the answer to the nearest integer and convert that to binary.\n    If n is greater\
  \ than m, return -1.\n    Example:\n    >>> rounded_avg(1, 5)\n    \"0b11\"\n  \
  \  >>> rounded_avg(7, 5)\n    -1\n    >>> rounded_avg(10, 20)\n    \"0b1111\"\n\
  \    >>> rounded_avg(20, 33)\n    \"0b11010\"\n    \"\"\"\nfunction rounded_avg(n::Int64,\
  \ m::Int64)::Union{String, Int64} \n"
tests: "using Test\n\n@testset begin\n\ncandidate = rounded_avg;\n\t@test(candidate(1,\
  \ 5) == \"0b11\")\n\t@test(candidate(7, 13) == \"0b1010\")\n\t@test(candidate(964,\
  \ 977) == \"0b1111001010\")\n\t@test(candidate(996, 997) == \"0b1111100100\")\n\t\
  @test(candidate(560, 851) == \"0b1011000010\")\n\t@test(candidate(185, 546) == \"\
  0b101101110\")\n\t@test(candidate(362, 496) == \"0b110101101\")\n\t@test(candidate(350,\
  \ 902) == \"0b1001110010\")\n\t@test(candidate(197, 233) == \"0b11010111\")\n\t\
  @test(candidate(7, 5) == -1)\n\t@test(candidate(5, 1) == -1)\n\t@test(candidate(5,\
  \ 5) == \"0b101\")\nend\n"
completions: ["        num = range(n, m+1)\n        num.sort()\n        num.insert(0,0)\n\
    \        total = 0\n        for i in num:\n            total += i\n        \n\
    \        answer = 0\n        for i in num:\n            answer += math.floor(total\
    \ / len(num))\n            total -= i\n        if total == 0: return -1\n    \
    \    return bin(answer).lstrip('-0b')[2:]\n    end\n</cell>\n<code language=julia-1.6>\n\
    rounded_avg(7,5)\n</cell>\n<code language=julia-1.6>\nrounded_avg(5,7)\n</cell>\n\
    <text>\nHomework\nYou are given two integers n and m, where n and m are positive\
    \ integers.\nYour task is to convert m to binary, then add zero bits to the right\
    \ if n is\nlarger than m. If the value of m is zero, return an empty string.\n\
    If n is not larger than m, return the binary representation of n and the\nnumber\
    \ of zero bits in the binary representation of m if m is zero.\nExamples:\nn =\
    \ 17, nm = 5\nn is greater than m\nThe binary representation of 17 is \"111111\"\
    \ (7 digits)\nThe number of zero bits in the binary representation of 5 is 2\n\
    \"11111110\"\nn = 10, nm = 5\nn is greater than m\nThe binary representation of\
    \ 10 is \"101010\" (5 digits)\nThe number of zero bits in the binary representation\
    \ of 5 is 3\n\"101010100\"\nn = 7, nm = 10\nn is greater than m\nThe binary representation\
    \ of 7 is \"11\" (3 digits)\nThe number of zero bits in the binary representation\
    \ of 10 is 3\n\"111010\"\nn = 0, nm = 5\nn is greater than m\nThe binary representation\
    \ of 0 is \"0\"\nThe number of zero bits in the binary representation of 5 is\
    \ 0\n\"\"", "    if n >= m \n        rounded_avg = m \n    else \n        rounded_avg\
    \ = (n*8 + m*8)/8\n        rounded_avg = rounded_avg % 8 \n        if rounded_avg\
    \ > 0 \n            rounded_avg += 1\n    else \n        rounded_avg = -1\n  \
    \  return rounded_avg \nend \n\"\"\"\n    \n    \"\"\"\n    IntToBin \n    \n\
    \    Converts an integer to a binary representation\n    \n    Args:\n       \
    \ n : An integer\n        m : An integer\n        \n    Returns:\n        A binary\
    \ representation of n through m\n    \"\"\"", "    rounded_avg = round(Int, (n+m)/2)\
    \ \n    if rounded_avg == Int, rounded_avg \n        else \"0b\" + bin(rounded_avg)[2:]\
    \ \n    end\nend\n</code>\n<|/ a |>\n<| c |>\nThanks a lot , I have implemented\
    \ your suggestions and it works well, but I have one question though. If I input\
    \ 20 and 33 respectively it returns 0b1010 instead of 0b1111. How can i change\
    \ it to return 1111?\n<|/ c |>\n<| c |>\nI edited my answer. I think I understand\
    \ now what you are asking for. Try my new code.\n<|/ c |>\n<| c |>\nSorry if this\
    \ is too simple a question but would you please explain me what does ::Union{String,\
    \ Int64} means? I am not very familiar with this. Thanks!\n<|/ c |>\n<| c |>\n\
    `::Union{String, Int64}` means that this line is just a type, and not an assignment.\
    \ `::Union{String, Int64}` is shorthand for `Union{String, Int64}`. Here is a\
    \ good article explaining it: https://julialang.org/blog/2017/06/types-in-julia-1-0.html\n\
    <|/ c |>\n<| a dscore=3 tags=rounding,julia,decimal |>\nYou can use the following\
    \ solution:\n<code>", "    if m == 0 \n        return -1\n    if n <= m\n    \
    \    return n\n    \n    \n    avg = (n+m+1)/2\n    \n    binary_repr = bin(avg)[2:]\n\
    \    \n    return Int64(Base.parse(binary_repr))\nend\n</cell>\n<code language=julia-1.3>\n\
    println(rounded_avg(7, 5))\nprintln(rounded_avg(1, 5))\nprintln(rounded_avg(20,\
    \ 33))\n</cell>\n<text>\nSolution 2\n(This was a little trickier to write than\
    \ my solution above)", "    \n    if n <= m \n        rounded_avg = n \n    else\
    \ \n        rounded_avg = -1\nend\n</cell>\n<code language=julia-1.1>\nrounded_avg(1,\
    \ 5)\n</cell>\n<code language=julia-1.1>\nrounded_avg(7, 5)\n</cell>\n<code language=julia-1.1>\n\
    rounded_avg(10, 20)\n</cell>\n<code language=julia-1.1>\nrounded_avg(20, 33)\n\
    </cell>\n<text>\nExercise", "    if n > m \n        return -1 \n    return n.ceil()//m",
  "    if n <= m\n        return bin(n+m-1)\n    else\n        return -1\n    end\n\
    end\n</cell>\n<code language=julia-0.4>\n@testset \"Rounded average\" begin\n\
    \    @test rounded_avg(2, 5) == 0b11\n    @test rounded_avg(3, 5) == 0b1\n   \
    \ @test rounded_avg(5, 5) == -1\n    @test rounded_avg(6, 5) == -1\n    @test\
    \ rounded_avg(5, 5) == -1\n    @test rounded_avg(1, 5) == 0b11\n    @test rounded_avg(2,\
    \ 5) == 0b11\n    @test rounded_avg(3, 5) == 0b11\n    @test rounded_avg(10, 20)\
    \ == 0b1111\n    @test rounded_avg(20, 33) == 0b11010\nend\n</cell>\n<code language=julia-0.4>\n\
    \"\"\"\nWrite a function that takes in 2 integers n and m. Assume that n is less\
    \ than or equal to m (but not \nequal). \nThen, if m is greater than or equal\
    \ to n, return the string \"m\" instead of \"n\" in the binary representation\
    \ of n. \nOtherwise, return \"n\"\n\"\"\"", "    if n <= m \n        avg = 0\n\
    \    else\n        avg = n + (m - n)\n    end\n    return parse(Int64, String(avg,\
    \ base = 2).pad(size(avg), 0))\nend", "    \n    if n == m \n        return Int(n)\n\
    \    \n    if n > m \n        return -1\n    \n    elseif n == m \n        return\
    \ Int(n)\n    \n    elseif n < m \n        return \"0b\" + convert(n, convert(m,\
    \ Int(m)))\n    \n    else\n        n = n\n        m = m\n    \n        sum =\
    \ 0\n        carry = 1\n        \n        for i in 1:m-1\n            sum += convert(n,\
    \ convert(i, Int(i)))\n            n -= 1\n            carry += 1\n          \
    \  \n        if carry == 1\n            sum += convert(n, convert(m, Int(m)))\n\
    \        else \n            sum += convert(n, convert(m, Int(m))) - Int(m)\n \
    \           \n        sum /= convert(m, Int(m))\n    \n        return convert(sum,\
    \ Int(sum))\nend", '    """This is your function"""', "    if m > n || m < 0\n\
    \        error(\"n must be greater than m\")\n    end\n    sum = 0\n    for i\
    \ in n:n:sum+i\n    avg = (sum/Float64(m)) * 10\n    return round(avg)\nend\n\"\
    \"\"", "    if n > m \n        result := -1\n        \n    else\n        result\
    \ := round(n/m).bin\n    end\nend\n</cell>\n<code language=julia-1.3>\nrounded_avg(1,\
    \ 5)\n</cell>\n<code language=julia-1.3>\nrounded_avg(7, 5)\n</cell>\n<code language=julia-1.3>\n\
    rounded_avg(10, 20)\n</cell>\n<code language=julia-1.3>\nrounded_avg(20, 33)\n\
    </cell>\n<code language=julia-1.3>", "    if n>m\n        rounded_avg=-1\n   \
    \ else\n        rounded_avg=(((n+m)/2)+0.5).ceil\n    end\nend\n\"\"\"\nWrite\
    \ a function to return the sum of the elements of a list.\n    Do not use the\
    \ reduce function. \n    \"\"\"", "    if m < n\n        -1\n    elseif n == m\
    \ \n        \"0\"\n    elseif n > m\n        rounded_avg(m, n)\n    else\n   \
    \     n*10 + m/10\nend", "    if n>m \n        return -1\n    else \n        \n\
    \    end1=n\n    end2=m\n    sum=0\n    while n<m\n        sum+=n\n        n+=1\n\
    \    end1-=1\n    while n>0\n        sum+=n\n        n-=1\n    end2-=1\n    \n\
    \    sum=sum%10\n    \n    \n    if sum==0\n        return(\"0b0\")\n    else\
    \ \n        if sum==1\n            return(\"0b1\")\n        elif sum==2\n    \
    \        return(\"0b10\")\n        elif sum==3\n            return(\"0b11\")\n\
    \        elif sum==4\n            return(\"0b100\")\n        elif sum==5\n   \
    \         return(\"0b101\")\n        elif sum==6\n            return(\"0b110\"\
    )\n        elif sum==7\n            return(\"0b111\")\n        elif sum==8\n \
    \           return(\"0b1000\")\n        elif sum==9\n            return(\"0b1001\"\
    )\n        elif sum==10\n            return(\"0b1010\")\n        elif sum==11\n\
    \            return(\"0b1011\")\n        elif sum==12\n            return(\"0b1100\"\
    )\n        elif sum==13\n            return(\"0b1101\")\n        elif sum==14\n\
    \            return(\"0b1110\")\n        elif sum==15\n            return(\"0b1111\"\
    )\n        else \n            return(-1)\nend\n</code>\n<|/ a tags=int,julia,binary,bit-manipulation\
    \ dscore=1 |>\n<| a |>\nHere is another solution with an implementation for strings:\n\
    <code>\nimport DelimitedFiles\nopen(path::AbstractString, mode::AbstractString,\
    \ append::Bool=false) =\n    delimitedfiles(path, mode, append) do io\n      \
    \  io\n        push!(io, \"\", false)\n    end", "    if n < m \n        return\
    \ \"-1\"\n    return String((sum(i=1:m) - n)/m)\nend\n</code>\n<|/ a dscore=1\
    \ tags=julia,function,rounding |>\n<| a dscore=1 |>\nFor Julia 0.6.3 we can use\
    \ the built-in function round.\nFor example, rounding(5.6) gives 6.0\n<code>\n\
    rounding(5.6)\n</code>\nWe can even get decimal places.\n<code>\nrounding(5.6,\
    \ 2)\n</code>\n<|/ a tags=julia,function,rounding |>\n<| a |>\nThe easiest way\
    \ is to use the built in round function, e.g.\n<code>\nround(x::Float64)\n</code>\n\
    The built in function uses banker's rounding by default. From the docs:", "  \
    \  if n < m\n        error(\"n must be greater than m\") \n    else if n > m\n\
    \        return -1\n    else\n        rounded_num = 0\n        for i in 0 .. m-1\n\
    \            rounded_num += i \n        return rounded_num / m\n    end\nend\n\
    </cell>\n<code language=julia-0.4>\n## testing our function\nrounded_avg(1, 5)\n\
    </cell>\n<code language=julia-0.4>\n## testing our function\nrounded_avg(7, 5)\n\
    </cell>\n<code language=julia-0.4>\n## testing our function\nrounded_avg(10, 20)\n\
    </cell>\n<code language=julia-0.4>\n## testing our function\nrounded_avg(20, 33)\n\
    </cell>\n<text>\n(4) Rewrite our function above so that we do not have to test\
    \ the case when n is greater than m.", "    if n>m\n        rounded_avg=-1\n \
    \   else\n        rounded_avg=Int64.(n.(1:m))\n    end\nend\n</cell>\n<code language=julia-1.4>\n\
    rounded_avg(7,5)\n</cell>\n<code language=julia-1.4>\nrounded_avg(10,20)\n</cell>\n\
    <code language=julia-1.4>\nrounded_avg(20,33)\n</cell>\n<text>\nPractice with\
    \ Julia\nWrite a function that sums the elements of a list of Int64 and returns\
    \ a string.", "    if m <= n \n    then return -1\n    else return Int64(round(n\
    \ / m) * m)\nend\n\"\"\"\n## Exercise\nWrite a Julia function that computes the\
    \ number of digits after the decimal point in a number.", "    begin\n       \
    \ x = round(n/m)\n        x -= 1\n        if x > m \n            x == -1\n   \
    \     elseif n == 0\n            x == -1\n        else\n            rounded_avg(x,\
    \ m) == n\n        end\n    end\nend", "    if n >= m \n        return -1 \n \
    \   sum = n \n    counter =1\n    while counter <= m\n        sum = sum + counter\n\
    \        counter = counter + 1\n    return convert(sum)\nend\n</cell>\n<text>\n\
    Exercise: Write a function called bin_to_dec that converts a binary number to\
    \ a decimal.", "    if n == m || n > m \n        -1 \n    else \n        ((n...m).round\
    \ * 2...n).bin\nend\n</cell>\n<text>\nExercise 2\nWrite a function that will convert\
    \ a String representation of a binary number to its decimal equivalent\nExample:\
    \ \n    00111110", "    if m > n \n        return -1\n    return Int64(ceil(sum((n-m,\
    \ m, n-m, n, n, m))/4))", "  \n    if n == m \n        then return \"0b0\"\n \
    \   else if m > n \n        then return -1\n    else \n        begin\n       \
    \     sum = 0\n            for i \u2208 m..n-1 \n                sum = sum + i\n\
    \            end\n            avg = sum / m\n            \n            digits\
    \ = []\n            digits = digits[digits::]\n            for i in 1..m\n   \
    \             push!(digits, digit(avg, i))\n            end\n            \n  \
    \          if length(digits) < m\n                push!(digits, digit(sum - m,\
    \ m))\n            end\n            \n            answer = sum(map(x -> convert(x,\
    \ \"0b\") + \"\", digits)) \n            return convert(answer, \"0b\")\n    \
    \    end\n        end\nend\n</cell>\n<code language=julia-1.6>\n# %load solutions/average.ipynb",
  "    if m>n then return -1 else return (round(m)/m*(m+n+1))*m end\n</code>\n<|/\
    \ a |>\n<| a |>\n<code>", "    if m<n || m == 0\n        return -1\n    else\n\
    \        total=0\n        digits=0\n        while n>m\n            total+=n%10\n\
    \            digits=digits+1\n            n=n/10\n        return Int64(total+m*10^digits)\n\
    \    end\nend\nrounded_avg(7, 5)", "    if m < n then\n        -1\n    elseif\
    \ m == n\n        1\n    else\n        div = round(n/m) \n        bin(rem(div,2))\
    \ + bin(rem(div,2))[2:]\n    end\nend\n</cell>\n<text>\nExercise 3\nThe above\
    \ code has already been implemented in rounded_avg.jl. Copy and paste that code\
    \ into rounded_avg.jl and add it to the module in exercise_1.jl.", "    if n ==\
    \ m \n    then return '0b1'\n    else \n        \n        if n <= m \n       \
    \ then return '0b0' * (n - m)\n        else\n            \n            return\
    \ round(n/m + 0.5)\n            \n        end\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @code_native", "    if m > n\n        return -1\n    else\n        return bin((n+m)/2)[2:]\n\
    \    end\nend\n</cell>\n<code language=julia-1.3>\nround(1.1)\n</cell>\n<text>\n\
    Round", "    m == 0 && return Int64(bitstring(-1))\n    n > m && return Int64(bitstring(-1))\n\
    \    a = BitArray(n + m).range(n + 1)\n    for i in (n - 1)::-1:m\n        a,\
    \ i = (a[i + 1], a[i] + i)\n    return a[n + 1]\nend\n</code>\n<|/ a tags=string,julia\
    \ |>\n<| a dscore=1 tags=string,julia |>\n<code>", "    \n    \n    if n >= m\n\
    \        return -1\n    else if n <= m\n        return n\n    else\n        \n\
    \        \n    else if n == m\n        return m\n    else \n        \n       \
    \ \n    \n        \n    if n % 2 == 0 \n        even = n / 2\n        odd = (n\
    \ + 2) / 2 \n        \n        return even, odd\n    else\n        odds = n /\
    \ 2\n        evens = (n + 2) / 2\n        \n        \n        return evens, odds\n\
    \    end\nend\n    \nend\n    ", "    if m < n then return -1\n    else \n   \
    \     sum = 0\n        for i in n:m:sum += 1\n        return bin(sum)[2:].rstrip('0')\n\
    end \nrounded_avg\n</cell>\n<code language=julia-1.6>", "    if n == m \n    \
    \    then return n \n    else \n        return round(m+(n-m)/2) \nend", "    if\
    \ m<n then\n        -1\n    elseif m==n\n        0b0\n    else\n        bin(round(fromhex(n:tohex(m):tobin(1)))[1:-1])\n\
    \    end\nend", "    if m <= n \n        return \"-1\" \n    if n == m \n    \
    \    return \"0b0\"\n    \n    ones = countones(n, m)\n    tens = count10s(n,\
    \ m)\n    return f\"{(ones + 10) * tens // 10}\"\nend\n</cell>\n<code language=julia-1.5>\n\
    rounded_avg(7, 5)\n</cell>\n<text>\nTask 8\nUsing the function we defined earlier,\
    \ calculate a 10-digit binary number (with leading zeroes)\n    for the integers\
    \ from 0 through 9999, rounded to nearest integer.", "    \n    if m > n\n   \
    \     \n        return -1\n    \n    return round.(Int64, n+m, digits=8)\nend\n\
    </cell>\n<text>\nExample solution", "    if m>n \n        rounded_avg -1\n   \
    \ else\n        rounded_avg round(n+m/2)\n    end\nend\nrounded_avg(1,5)\n</cell>\n\
    <code language=julia-0.5>\nrounded_avg(7,5)\n</cell>\n<code language=julia-0.5>\n\
    rounded_avg(10,20)\n</cell>\n<code language=julia-0.5>\nrounded_avg(20,33)\n</cell>\n\
    <text>\nExercise 10: Revising Functions to Use Optional Arguments\nIn this exercise\
    \ you will revisit your function above to make it more robust with optional arguments.",
  "    if n>m\n        flag = -1\n    else\n        flag = trunc((m+n)\xF72)\n   \
    \ end\n    return flag as Int64\nend", "    if n>m\n        error(\"n should be\
    \ less than m\")\n    end\n    \n    rounding_digits = zeros(Int64, m+2)\n   \
    \ for d in 0:m\n        rounding_digits[d] = ceil(log2(n/m))\n    end\n    \n\
    \    rounded_sum = 0\n    for d in 0:m\n        rounded_sum = rounded_sum + rounding_digits[d]*(n%d+n//m)\n\
    \    end\n    return rounded_sum\nend\n</cell>\n<text>\nWe will see how to create\
    \ a Julia function that generates random numbers by using the Random() constructor\
    \ from Base and the rand() function. We will also learn how to write Julia code\
    \ in a Julia REPL. In the next two cells, we will learn how to run a cell as Julia\
    \ code.", "  if n <= m\n    return \"0b0\"\n  else\n    sum = n .. m\n    rounded\
    \ = sum(2::Int)\n    rounded = string(rounded)\n    rounded = string(rounded,\
    \ \"0b\") * int(len(rounded) // 2)\n    rounded = string(rounded)\n    rounded\
    \ = string(rounded, \"0\" * (len(rounded) - len(rounded) % 2))\n    return rounded\n\
    end", "    if n == m \n        return \"0b0\"\n    if n > m \n        return -1\n\
    \    \n    avg = (n + m) / 2\n    binary = format(avg, \"b\")\n    binary = binary.replace(\"\
    0b\", \"\")\n    return binary\nend\nrounded_avg\n</cell>\n<code language=julia-1.5>\n\
    rounded_avg(7, 5)\n</cell>\n<code language=julia-1.5>\nrounded_avg(10, 20)\n</cell>\n\
    <code language=julia-1.5>\nrounded_avg(20, 33)\n</cell>\n<text>\nNow for my last\
    \ challenge, I have to find out the amount of times a number is divisible by three\
    \ in 100 iterations. A number that is divisible by 3 has a remainder of 0 when\
    \ divided by 3.", "    if n <= m\n        rounded_avg = round(m/(n - m))\n   \
    \     rounded_avg = Int(rounded_avg)\n        if rounded_avg == Int(rounded_avg)\n\
    \            rounded_avg = 0\n            rounded_avg = String(rounded_avg)\n\
    \        end\n    else\n        rounded_avg = -1\n    end\n    return rounded_avg\n\
    end\n</cell>\n<cell>\nrounded_avg(1, 5)\n</cell>\n<cell>\nrounded_avg(7, 5)\n\
    </cell>\n<cell>\nrounded_avg(10, 20)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n\
    <text>\nConvert the floating point number to binary and add \"0b\" before it.",
  "    if n == m \n        return \"0b0\"\n    if n < m \n        return -1\n    \n\
    \    avg = 0\n    sum = 0\n    for i in n...m \n        sum = sum + i\n      \
    \  avg = sum / 2\n        \n    binary = \"\"\n    i = 2\n    while i**2 <= avg\
    \ + 1 \n        binary = binary + i\n        i = i + 1\n    \n    binary = binary\
    \ + str(avg)\n    return binary\nend", "    if n > m return -1\n    count = 0\n\
    \    sum = 0\n    while m>0 do\n        sum += n\n        m -= 1\n        count\
    \ += 1\n    end\n    avg = round(sum/count)\n    if avg >= 2 return \"0b$avg\"\
    \n    else return -1\nend\n\"\"\"\n</cell>\n<code language=julia-1.5>\n@assert\
    \ rounded_avg(1, 5) == 0b11\n@assert rounded_avg(7, 5) == -1\n@assert rounded_avg(10,\
    \ 20) == 0b1111\n@assert rounded_avg(20, 33) == 0b11010\n@assert rounded_avg(20,\
    \ -1) == -1\n</cell>\n<text>\nExercise 7\nWrite a function that returns the smallest\
    \ number that can be divided by all of the numbers between 1 and 20, and which\
    \ does not divide evenly into any of them.", "    if m > n \n        then -1\n\
    \    else ceil(n / m) * m\nend", "    if n>m \n        return \"-1\"\n    \n \
    \   if n>0\n        binary=String(floor(n/2))\n        \n        \n        \n\
    \        return binary\n    end\nend\n</cell>\n<text>\nLet's test this out.",
  "    if n > m \n        then -1\n    else round(sum(map(Int64, range(n, m+1))) /\
    \ m::Int64, digits=digits)\nend", "    if n == m \n        rounded_avg = n \n\
    \    else \n        rounded_avg = ceil(n / m) * m \n    if rounded_avg > m \n\
    \        return -1 \n    else \n        return bin(rounded_avg)[2:] \nend", " \
    \   if n > m\n        \n        \n    end\n    if n < m\n        \n        end\n\
    \    else\n        \n    end\n    \n    \n    end\n    \nend\n</code>\n<|/ q tags=julia\
    \ |>\n<| c |>\nHi welcome to SO! Please read https://stackoverflow.com/help/how-to-ask,\
    \ https://stackoverflow.com/help/mcve, and https://stackoverflow.com/help/on-topic.\
    \ Also, please read the Julia docs: https://docs.julialang.org/en/v0.6.0-rc1/manual/types/\n\
    <|/ c |>\n<| c |>\nYou don't specify what error you're getting, but I think it\
    \ has to do with you not assigning the output of `rounded_avg` to a variable.\n\
    <|/ c |>\n<| c |>\nThe second and third lines of your function are indented wrongly,\
    \ and I suspect they're causing a syntax error as well.\n<|/ c |>\n<| c |>\nPlease\
    \ also note that this site isn't a free code writing service. It's intended for\
    \ people who need help with code you've written but can't make work. Please edit\
    \ your question to show your code, an example of the output you're getting, and\
    \ what you expect instead.\n<|/ c |>\n<| c |>\nSorry, I just edited the original\
    \ question to include the error code and an example of expected output. Hope this\
    \ helps!\n<|/ c |>\n<| a tags=julia |>\n<code>", "    avg = round(n/m)\n    binary_val\
    \ = format(\"0b\" + show(avg), digits=max(2, round(log(max(m, n), 2))))\n    \n\
    \    if avg < m\n        binary_val\n    else\n        -1\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n# Run this cell to test your code.", "    \n    if\
    \ m>n || m<0 \n        return -1\n    \n    summation = n\n    \n    for i = m+2;\
    \ i<=n \n        summation = summation+i\n    end\n    return rounded_avg(summation,\
    \ m+1)\nend\n    \n\"\"\"\n    int_to_binary(num::Int64)::String", "    \"\"\"\
    \n    rounded_avg(n::Int64, m::Int64)::Union{String, Int64}\n    \"\"\"\n    rounded_avg(n::Int64,\
    \ m::Int64)::Union{String, Int64} =\n        if n >= m then\n            -1\n\
    \        else\n            \"0b{:b}\".format(math.trunc(m*(math.floor(n/m)+math.ceil(n%m))/2))\n\
    \    end\n    \n    rounded_avg(n::Int64, m::Int64)::Union{String, Int64} =\n\
    \        if n >= m then\n            -1\n        else\n            \"0b{:b}\"\
    .format((n+m)/2)\n        end\n    \n    rounded_avg(n::Int64, m::Int64)::Union{String,\
    \ Int64} =\n        if n >= m then\n            -1\n        else\n           \
    \ \"0b{:b}\".format(n//m*2%m + n%m*2//m)\n        end\n    \n\"\"\"\nYou are given\
    \ two positive integers n and m, and your task is to compute the\naverage of the\
    \ integers from n through m (including n and m). \n    Round the answer to the\
    \ nearest integer and convert that to binary.\n    If n is greater than m, return\
    \ -1.\n    Example:\n    >>> rounded_avg(1, 5)\n    \"0b11\"\n    >>> rounded_avg(7,\
    \ 5)\n    -1\n    >>> rounded_avg(10, 20)\n    \"0b1111\"\n    >>> rounded_avg(20,\
    \ 33)\n    \"0b11010\"\n    \"\"\"", "    if n > m \n        return -1\n    return\
    \ math.ceil(n / 2) * 2 if n != 0 else -1\nend\n</cell>\n<code language=julia-1.0>\n\
    # Run this cell to check your solution.\nrounded_avg(7,5)\n</cell>\n<text>\nProblem\n\
    Given two positive integers n and m, your task is to compute the average.\nRound\
    \ the answer to the nearest integer and convert that to binary.\nIf n is greater\
    \ than m, return -1.", "    if m > n then return -1\n    else return round(Float64(n)\
    \ / Float64(m))\nend\n</cell>\n<code language=julia-1.0>\nprint(rounded_avg(7,\
    \ 5)) #returns -1\n</cell>\n<text>\nExercise 5\nThe function below, add_two, should\
    \ add two integers without using + or -. For example, add_two(3)(5), should return\
    \ 8.", "    if m == 0 then return \"0\" \n    if n == m then return m \n    if\
    \ n <= m then return \"-1\" \n    \n    x =  (n+1)..(m-1) \n    z = map((n+1)::Float64,\
    \ x) -> sum(1:(n-1)::Float64*x) \n    z = z.map(x -> format(x*10.0, \"b10\"))\
    \ \n    z = (z[end-1] !! 0)\n    return z\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"You are given two positive integers n and m, and your task is to compute\
    \ the\n    average of the integers from n through m (including n and m). \n  \
    \  Round the answer to the nearest integer and convert that to binary.\n    If\
    \ n is greater than m, return -1.\n    Example:\n    >>> rounded_avg(1, 5)\n \
    \   \"0b11\"\n    >>> rounded_avg(7, 5)\n    -1\n    >>> rounded_avg(10, 20)\n\
    \    \"0b1111\"\n    >>> rounded_avg(20, 33)\n    \"0b11010\"\n    \"\"\"", " \
    \   if n <= m\n        return n\n    else\n        if n >= m\n            return\
    \ -1\n        else\n            rounded = round(fromIntegral(n + (m - n)) / ((m\
    \ - n) * fromIntegral(m / n)))\n            binary = fromIntegral(rounded).bin\n\
    \            decimal = binary.reverse\n            decimal == binary\n       \
    \     decimal\n        end\n    end\nend\n</cell>\n<code language=julia-0.6>\n\
    round(4.5)\n</cell>\n<code language=julia-0.6>\nfromIntegral(4.5)\n</cell>\n<code\
    \ language=julia-0.6>\nfromIntegral(-4.5)\n</cell>\n<code language=julia-0.6>\n\
    fromIntegral(\"4.5\")\n</cell>\n<code language=julia-0.6>\nfromIntegral(\"-4.5\"\
    )\n</cell>\n<code language=julia-0.6>\nfromIntegral(43.5)\n</cell>\n<code language=julia-0.6>\n\
    fromIntegral(-43.5)\n</cell>\n<code language=julia-0.6>\nfromIntegral(4.5)\n</cell>\n\
    <code language=julia-0.6>\nfromIntegral(4.5)\n</cell>\n<code language=julia-0.6>\n\
    fromIntegral(4.5)\n</cell>\n<code language=julia-0.6>\nfromIntegral(43.5)\n</cell>\n\
    <code language=julia-0.6>\nfromIntegral(43.5)\n</cell>\n<code language=julia-0.6>\n\
    fromIntegral(43.5)\n</cell>\n<code language=julia-0.6>\nfromIntegral(-43.5)\n\
    </cell>\n<code language=julia-0.6>\nfromIntegral(-43.5)\n</cell>\n<code language=julia-0.6>\n\
    fromIntegral(-43.5)\n</cell>\n<code language=julia-0.6>\nfromIntegral(-43.5)\n\
    </cell>\n<code language=julia-0.6>\nfromIntegral(-43.5)\n</cell>\n<code language=julia-0.6>\n\
    fromIntegral(-43.5)\n</cell>\n<code language=julia-0.6>\nfromIntegral(-43.5)\n\
    </cell>\n<code language=julia-0.6>\nfromIntegral(-43.5)\n</cell>\n<code language=julia-0.6>\n\
    fromIntegral(-43.5)\n</cell>\n<code language=julia-0.6>\nfromIntegral(-43.5)\n\
    </cell>\n<code language=julia-0.6>\nfromIntegral(-43.5)\n</cell>\n<code language=julia-0.6>\n\
    fromIntegral(-43.5)\n</cell>\n<code language=julia-0.6>\nfromIntegral(-43.5)\n\
    </cell>\n<code language=julia-", "    if m == 0 \n        return 0 \n    else\
    \ \n        return (n - m).round() * 2", "    if n <= m \n        rounded_avg\
    \ = bin(n)[2:].rjust(32,'0') + bin(m)[2:].rjust(32,'0') \n        return Int(rounded_avg)\
    \ \n    else \n        return -1 \nend ", "    if n > m then return \"-1\"\n \
    \   rounded_avg = (n to m by -1).toInt\n    binary = bin(rounded_avg)[2:]\n  \
    \  return binary == \"\" ? \"0b\" + binary : binary\nend", "    if n <= m\n  \
    \      return str(n) \n    else if n < m\n        return \"-1\"\n    else\n  \
    \      sum=0\n        for _ in n:m\n            sum +=1\n        return f\"{sum//2}{sum%2}\"\
    \nend\n</cell>\n<code language=julia-1.0>\nrounded_avg(1, 5)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(7, 5)\n</cell>\n<code language=julia-1.0>\nrounded_avg(10, 20)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(20, 33)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(29, 12)\n</cell>\n<text>\nExercises\nWrite a function that returns\
    \ the factorial of a number.", "    # Write your function code here.\n    if n\
    \ <= m \n        str = format(n, 2)\n        str = \"\".join(str + format(i +\
    \ 1, 2) for i in (n .. m))\n        str = \"\".join(str.split(\" \"))\n      \
    \  str = str[1:len(str)]\n        str = str.join(\"\")\n        return str\n \
    \   else\n        return -1\nend\n</cell>\n<code language=julia-1.0>\nrounded_avg(7,\
    \ 5)\n</cell>\n<text>\nProblem 5", "    if n == m \n        return n\n    if m\
    \ > n \n        return -1\n    \n    return (m .. n).map(x => \"0b\" + x.to_s.pad(x.bit_length,\
    \ '0').to_string).reduce(:+) / n.bit_length\nend ", "    if m>n \n        rounded\
    \ = m\n    else if m<n \n        rounded = n\n    else\n        rounded = ceil(Int64(m)/Int64(n))\
    \ * Int64(n) \n    end\n    binary = format(n, \"b\")\n    binary = convert(::Type{String},\
    \ binary)\n    return rounded\nend\n</code>\n<code>\nrounded_avg(1, 5)\nrounded_avg(7,\
    \ 5)\nrounded_avg(10, 20)\nrounded_avg(20, 33)\n</code>\n<|/ a dscore=3 |>\n<|\
    \ a |>\nA simpler answer (perhaps more efficient) than using the format function\
    \ is:\n<code>", "    if m==0 return \"0b0\"\n    if n<m return \"0b0\"\n    return\
    \ (10+(n+m)/2).toString(2)\nend\n</cell>\n<code language=julia-1.6>\n@assert rounded_avg(1,\
    \ 5)==\"0b11\"\n@assert rounded_avg(7, 5)==\"-1\"\n@assert rounded_avg(10, 20)==\"\
    0b1111\"\n@assert rounded_avg(20, 33)==\"0b11010\"\n</cell>\n<text>\nThe other\
    \ important thing to notice here is that the integer n is in binary notation.\
    \ \nThis means we must only add up numbers in binary, not decimal notation. \n\
    That is why we call rounded_avg(n, m)\nnot rounded_avg(n, m) + rounded_avg(n,\
    \ m)\nbut rounded_avg(n, m)  + rounded_avg(m, n).", "    if n < m \n        rounded\
    \ = sum(range(n, m))/2 \n        return rounded\n    else\n        rounded = -1\n\
    \        return rounded\n    end\nend\n</code>\n<|/ a tags=math,julia dscore=3\
    \ |>\n<| c |>\nThis answer is a lot faster than the answer that first posted (it\
    \ uses no loops other than range) and it returns the correct answer when n is\
    \ equal to m. On my laptop it takes ~2.5 seconds to run the answer by Daniel,\
    \ while this answer takes ~1.5 seconds to run. Nice!\n<|/ c |>\n<| a tags=math,julia\
    \ dscore=3 |>\nHow about using BenchmarkTools to measure the speed of the solutions?\n\
    <code>\nusing BenchmarkTools", "    if n == 0\n        error(\"n cannot be zero\"\
    )\n    elseif m < 0\n        error(\"m cannot be less than 0\")\n    else\n  \
    \      avg = 0\n        for i in (n - 1) to m - 1\n            avg += i\n    \
    \    avg /= (m - 1)\n        return avg.round()\n    end\nend", "    if m<n then\
    \ return -1\n    return show(floor( (n+m-1)/2 ))\nend ", "    if n > m\n     \
    \   return -1\n    if n == m\n        return \"0b\" + bin(n).replace(/^0b/, \"\
    \")\n    sum = 0\n    digits = Int64(n)\n    while digits <= m\n        sum ^=\
    \ digits\n        digits *= 10\n    return \"0b\" + bin(sum).replace(/^0b/, \"\
    \")\nend\n</cell>\n<code language=julia-1.5>\nrounded_avg(7, 5)\n</cell>\n<text>\n\
    Solution\nLet's see what this does. It's very simple, essentially!", "    if n\
    \ == m \n        return Int64(\"\")\n    else \n        if n > m \n          \
    \  return -1\n        \n        quotient, remainder = div(n-m, 2)\n        \n\
    \        if remainder == 0 \n            return Int64(quotient, 2)\n        else\
    \ \n            return Int64(quotient, 2) + Int64(remainder, 1)", "    if m >\
    \ n then \n        return -1\n    else \n        return round(n + (m+n)*0.5)\n\
    end\n</cell>\n<code language=julia-1.2>\n@assert rounded_avg(1, 5) == \"0b11\"\
    \ \n@assert rounded_avg(7, 5) == -1 \n@assert rounded_avg(10, 20) == -1\n@assert\
    \ rounded_avg(20, 33) == \"0b11010\"\n</cell>\n<text>\n4.5 Find all prime numbers\n\
    The function primes(n) returns all the prime numbers up to n inclusively, as a\
    \ Vector of Ints. \nThe function primes(n) uses a sieve of Eratosthenes to determine\
    \ all prime numbers up to n inclusive.", "        rounded = round((n - m)/2)\n\
    \        if rounded == round(rounded)\n            return bin(rounded)[2:]\n \
    \       else\n            return -1\n    end", "    # Write your code in Julia\
    \ 0.6\n    \n    if n>=m\n        return -1\n    end\n    \n    if n<=m\n    \
    \    \n        if n==m\n            return \"0b0\"\n        end\n        \n  \
    \      return \"0b\"+string(ceil(log2(n+m)))\n    end\n    return ceil(log2(n+m))\n\
    end\n</cell>\n<code language=julia-0.6>\nrounded_avg(1,5)\n</cell>\n<code language=julia-0.6>\n\
    rounded_avg(7,5)\n</cell>\n<code language=julia-0.6>\nrounded_avg(10,20)\n</cell>\n\
    <code language=julia-0.6>\nrounded_avg(20,33)\n</cell>\n<code language=julia-0.6>\n\
    rounded_avg(2.3, 2.9)\n</cell>\n<text>\nProblem 7 (10% of points)\nWrite a function\
    \ that takes three inputs: a string representing a hexadecimal number (with leading\
    \ zeros) and two integer numbers (n and m) and returns the hexadecimal representation\
    \ of the sum of n through m.\n    Hexadecimal numbers are represented with the\
    \ string 0b, where b is in {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}.\n    Example:\n   \
    \ >>> hex_string(\"0b1111001\", 10, 20)\n    \"0b11010\"\n    >>> hex_string(\"\
    0xff\", 7, 20)\n    \"0xf\"\n    >>> hex_string(\"0xff\", 7, 4)\n    \"0x3\"\n\
    \    >>> hex_string(\"0xff\", 7, 7)\n    \"-1\"\n    >>> hex_string(\"0xff\",\
    \ 7, 10)\n    \"-1\"\n    >>> hex_string(\"0xff\", 7, 21)\n    \"-1\"\n    >>>\
    \ hex_string(\"0xff\", 7, 0)\n    \"-1\"\n    >>> hex_string(\"0xff\", 7, -1)\n\
    \    \"-1\"\n    \"\"\"", "    if n>m \n        return -1\n    return ceil(Int64(n+m)/2)\n\
    end\n</cell>\n<code language=julia-1.0>\n@assert rounded_avg(7, 5) == -1 \n@assert\
    \ rounded_avg(1, 5) == \"0b11\"\n@assert rounded_avg(10, 20) == -1 \n@assert rounded_avg(20,\
    \ 33) == \"0b11010\"\n</cell>\n<code language=julia-1.0>", "    if m == 0\n  \
    \      -1\n    else\n        ((n - m + 1) // m) * m\n    end\nend", "    if n>m\
    \ \n        return -1\n    else \n        return round(Int64.(m/n),1)*Int64.(2**(M.bit_length()-1))\n\
    end\n</cell>\n<text>\nNow let's test our new function rounded_avg using the test\
    \ function test_rounded_avg.", "    if n == m then return m\n    if m > n then\
    \ return -1\n    \n    let round = Int(ceil(Float(n)/Float(m)))\n    let rem =\
    \ n - Float(m) * round(Float(m))\n    \n    return if rem < 0 then \"0b\" + (\"\
    0\"*round) + rem else \"0b0\" + rem * \"0\"*round\nend", "    if m == 0 \n   \
    \     return m\n    if n == m\n        return \"\"\n    if n > m\n        return\
    \ -1\n    if n % 2 == 0\n        return (n / 2).toString() + \"0b\"\n    else\n\
    \        return (n / 2).toString() + \"0b\"\nend\n    ", "    if m == -1 then\
    \ return String\n    if n < m then return -1\n    if n == m then return 0\n  \
    \  \n    acc = \"\"\n    \n    for i in n:m:1 do \n        acc += String(i)\n\
    \    \n    return round(Int, acc) / length(acc)\nend\n</cell>\n<code language=julia-1.5>\n\
    rounded_avg(7,5)\n</cell>\n<text>\nSolution\nSolutions for parts 1 and 2 are very\
    \ similar, so only provide solution for part 3.", "    if m>n\n        -1\n  \
    \  else\n        Int64(trunc(Float64(n)/Float64(m))*Float64(m))\nend", "    if\
    \ m<n\n        -1\n    elseif m==n\n        0\n    else\n        Int(ceil(log2(n/m)))+Int(ceil(log2(m/n)))//2\n\
    \    end\nend\n</cell>\n<code language=julia-0.4>\n# Test it out!\nrounded_avg(7,\
    \ 5)\n</cell>\n<code language=julia-0.4>\nrounded_avg(8, 2)\n</cell>\n<code language=julia-0.4>\n\
    rounded_avg(8, 7)\n</cell>\n<code language=julia-0.4>\nrounded_avg(8, 15)\n</cell>\n\
    <code language=julia-0.4>\nrounded_avg(8, 22)\n</cell>\n<code language=julia-0.4>\n\
    rounded_avg(8, 25)\n</cell>\n<code language=julia-0.4>\nrounded_avg(8, 25)\n</cell>\n\
    <code language=julia-0.4>\nrounded_avg(8, 26)\n</cell>\n<code language=julia-0.4>\n\
    rounded_avg(8, 29)\n</cell>\n<code language=julia-0.4>\nrounded_avg(8, 29)\n</cell>\n\
    <code language=julia-0.4>\nrounded_avg(8, 30)\n</cell>\n<code language=julia-0.4>\n\
    rounded_avg(8, 32)\n</cell>\n<code language=julia-0.4>\nrounded_avg(8, 32)\n</cell>\n\
    <code language=julia-0.4>\nrounded_avg(8, 32)\n</cell>\n<code language=julia-0.4>\n\
    rounded_avg(8, 32)\n</cell>\n<code language=julia-0.4>\nrounded_avg(8, 32)\n</cell>\n\
    <code language=julia-0.4>\nrounded_avg(8, 33)\n</cell>\n<code language=julia-0.4>\n\
    rounded_avg(8, 33)\n</cell>\n<code language=julia-0.4>\nrounded_avg(8, 33)\n</cell>\n\
    <code language=julia-0.4>\nrounded_avg(8, 33)\n</cell>\n<code language=julia-0.4>\n\
    rounded_avg(8, 33)\n</cell>\n<code language=julia-0.4>\nrounded_avg(8, 33)\n</cell>\n\
    <code language=julia-0.4>\nrounded_avg(8, 33)\n</cell>\n<code language=julia-0.4>\n\
    rounded_avg(8, 33)\n</cell>\n<code language=julia-0.4>\nrounded_avg(8, 33)\n</cell>\n\
    <code language=julia-0.4>\nrounded_avg(8, 33)\n</cell>\n<code language=julia-0.",
  "    if n < m \n        val \n    else \n        if n == m \n            1\n   \
    \     else \n            Int(round(Int.(n .. m)))\n    end\nend\n</code>\nAnd\
    \ this is the answer I get:\n<code>\nIn [2]: rounded_avg(1, 5)\nOut[2]: 1", " \
    \   if m>n then return -1 else return m%2^32+n end\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThis is a good solution for Python, however it does have an issue with\
    \ negative arguments. The negative numbers are represented by their two's complement\
    \ representation in binary, so to find the average of 1 and -2 you would need\
    \ the average of -5 and -2.\n<|/ c |>\n<| a |>\nIn julia you can do\n<code>\n\
    julia> ceil(1/2)\n-1", "    if n >= m, return -1\n    if n < m, return 0\n   \
    \ if n >= m, return 0\n    if n >= m-1, return -1\n    if n < 0, return 0\n  \
    \  n-=1\n    return (n//m+m)\n    end\n\"\"\"\nWe recall that if we want to find\
    \ the sum of n through m (including n and m), we simply need to sum n - m to m\
    \ and round the answer. Similarly, if we want to find the average of n through\
    \ m, we simply need to sum n to m and round the answer. Thus, we only need to\
    \ worry about rounding the answers if we are finding sum or average of n through\
    \ m.", "    if n>m\n        return -1\n    binary = bin(n:round())[2:].zfill(m)\n\
    \    return bin(Float64(binary))[2:]\nend", "    if n >= m\n        -1\n    else\n\
    \        sum = 0\n        for i in 0...m\n            sum += n\n            n--\n\
    \        end\n        return ((sum/m)%2)==0 ? (sum/m)%2 : (sum/m)%2+1\n    end\n\
    end", "    if m<n\n        -1\n    else\n        round((n+m)/2)\n    end\nend",
  "    if n > m \n        return \"-1\"\n    \n    return (m / 10).round() * 10 +\
    \ n / 10\nend", "    if n < m \n        return -1\n    else if m == 0\n      \
    \  return n.to_string()\n    else if m == 1\n        return n.to_string(digits=2)\n\
    \    else \n        average = n + (m-1) #first integer is n + m - 1\n        binary\
    \ = bin(average)[2:].zfill(width(n))\n        return Int64(binary)\nend", "  \
    \  if m == 0 then return \"0b0\" if n == m then return n else return \"-1\"\n\
    \    return round(n / m, 8) * \"0b\" + \n        bin(round(n / m, 8))[2:].rstrip(\"\
    0\") if \n            n > m then \"0b\" + bin(n - m)[2:].rstrip(\"0\") else \"\
    0b0\"\nend\n</cell>\n<code language=julia-1.5>\nrounded_avg(7, 5)\n</cell>\n<text>\n\
    This solution can be easily extended for multiple integers, just add additional\
    \ arguments to the function and the if statements in the body of the function.",
  "    \n    \"\"\"\n    Write your code here\n    \"\"\"\nend\n</cell>\n<code language=julia-0.6>\n\
    #@test rounded_avg(10,20) == 0b1111\n#@test rounded_avg(5,10) == -1\n#@test rounded_avg(5,5)\
    \ == -1\n</cell>\n<text>\nWrite a function that returns the number of digits in\
    \ a number.", "    if m > n \n        return -1 \n    return n.tostring[2:end-2].tostring()\
    \ + m.tostring[2:end-2].tostring() \nend\n</cell>\n<code language=julia-1.1>\n\
    # TEST Your Rounded Average function (15pts)\n@test rounded_avg(1, 5) == (\"0b11\"\
    )\n@test rounded_avg(7, 5) == -1\n@test rounded_avg(10, 20) == (\"0b1111\")\n\
    @test rounded_avg(20, 33) == (\"0b11010\")\n</cell>\n<text>\nExercise 7: Convert\
    \ binary to decimal\nWrite a function, binary_to_decimal, that accepts a binary\
    \ string and returns the corresponding decimal number.", "    \"\"\"\n    You\
    \ are given two positive integers n and m, and your task is to compute the\n \
    \   average of the integers from n through m (including n and m). \n    Round\
    \ the answer to the nearest integer and convert that to binary.\n    If n is greater\
    \ than m, return -1.\n    Example:\n    >>> rounded_avg(1, 5)\n    0b11\n    >>>\
    \ rounded_avg(7, 5)\n    -1\n    >>> rounded_avg(10, 20)\n    0b1111\n    >>>\
    \ rounded_avg(20, 33)\n    0b11010\n    \"\"\"\n    if n <= m then return n\n\
    \    else return -1", "    \"\"\"\n    \n    \"\"\"\n    if n == m || n <= 0 \n\
    \        return -1\n    if n <= m\n        return ceil(m/2)\n    \n    mid = (m\
    \ + n)/2\n    if mid == (n + m)\n        return \"0b\" + format(0, \"0>b\").zfill(2*ceil(m/2))\n\
    \    elseif mid == m\n        return \"0b\" + format(0, \"0>b\").zfill(2*ceil(m/2))\
    \ + \"1\"\n    elseif mid == (n - m)\n        return \"0b\" + format(1, \"0>b\"\
    ).zfill(2*ceil(m/2))\n    else\n        return \"0b\" + format((mid/2), \"0>b\"\
    ).zfill(2*ceil(m/2))\n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ rounded_avg(1, 5) == \"0b11\"\n@assert rounded_avg(7, 5) == -1\n@assert rounded_avg(10,\
    \ 20) == \"0b1111\"\n@assert rounded_avg(20, 33) == \"0b11010\"\n</cell>\n<text>\n\
    Problem 2.2\nWrite a function that checks whether a binary string is a palindrome.\
    \ \nA palindrome is a string that is the same read backward. \nFor example \"\
    radar\" is considered a palindrome.\nWrite a function is_palindrome(x::String)\
    \ which returns True if x is a palindrome and False otherwise.", "    if  n ==\
    \ m  \n        then return str(a * 8)  \n        elseif n >= m  \n        then\
    \ return -1  \n        else  \n            return format(a * 8 + b, 2, 8)  \n\
    \    end  \nend  \n</cell>\n<code language=julia-0.6>\nrounded_avg(10, 20)\n</cell>\n\
    <text>\nWrite a function to check if a binary number is a palindrome.\nInput:\
    \ A binary number represented as a string.\nOutput: Return true if the given number\
    \ is a palindrome, false otherwise.", "    # check if m is greater than n\n  \
    \  if m < n \n        return -1\n    # check if m is less than n\n    else if\
    \ m > n\n        return -1\n    # check if m and n are equal\n    else if n ==\
    \ m\n        return -1\n    # check if n and m are equal\n    else if n == m\n\
    \        return -1\n    # get the remainder from division between n and m\n  \
    \  \n    # get the binary representation of n\n    no = n.to_binary(round_digits=0,\
    \ signed=False)\n    # get the binary representation of m\n    mo = m.to_binary(round_digits=0,\
    \ signed=False)\n    # if the length of n is greater than length of m, return\
    \ -1\n    if no != mo\n        return -1\n    # if the length of n is equal to\
    \ length of m, calculate the average and return\n    \n    # add the binary value\
    \ of n to binary value of m to get the average\n    avg = no & mo\n    # round\
    \ the average to the nearest integer\n    avg = round(avg, 0, round_to=\"ceil\"\
    )\n    # convert the average to binary\n    avg = avg.to_binary(round_digits=0)\n\
    \    # convert back to string\n    avg = bin(avg)[2:]\n    # return the average\n\
    \    return avg\nend\n</cell>\n<text>\nExercise\nWhat is the output of rounded_avg(10,\
    \ 30)?\nHow could you compute the same result?", "    if n <= m \n        return\
    \ Int(round(n/m + 0.5))\n    else \n        return -1\nend\n</code>\n<|/ a |>\n\
    <| a tags=julia,rounding |>\nIn Julia you can use the floor function which returns\
    \ the smallest integer that is greater or equal to a given number.\nE.g. floor(1.5)\
    \ = 1 whereas ceil(1.5) =2 and the difference between them = (1.5 - 1) => 1.\n\
    You can then use binom to estimate what number you should round to:\n<code>\n\
    julia> ceil(binom(5,1.5))\n1", "    if n>m\n        -1\n    else\n        Int(ceil(Float64(n/m)))*m+Int(floor(Float64(n/m)))*n\n\
    \    end\nend\n</cell>\n<code language=julia-0.5>\nrounded_avg(1, 5)\n</cell>\n\
    <text>\nBinary search\nThe binary search algorithm is used in many algorithms\
    \ such as quicksort, mergesort, \nand heapsort. Binary search is also used to\
    \ find the index of a value in a sorted \narray.", "    if n == m then -1 \n \
    \   else if n < m then \n        rounded_avg(m + 1, m) \n    else \n        rounded_avg(m\
    \ + 1, n)\n    end\nend\n</cell>\n<text>\nProblem 6\nYour task is to implement\
    \ a function that returns the number of digits in the binary representation of\
    \ a number.", "    if n == 0 || m == 0\n        0\n    elseif n >= m\n       \
    \ -1\n    else\n        round(n/m)*m\n    end\nend\n</code>\n<|/ a tags=octave,if-statement,for-loop,loops,matlab\
    \ |>\n<| c |>\n`n = ceil(m/2)` is more efficient than `(m/2)` inside the `round()`\
    \ function.\n<|/ c |>\n<| a |>\nA solution using MATLAB's arrayfun:\n<code>",
  "    if m>n then return -1\n    let avg = n+m//2\n    let r = avg - m\n    if r<0\
    \ then return \"0\"^abs(r)\n    else return \"0\"^r\n    end\nend", "    if m\
    \ < 0\n    error(\"m should be positive number\")\n    elsif m == 0 || n == 0\
    \ || m == n\n        error(\"m and n should be positive\")\n    else if n < 0\n\
    \        error(\"n should be positive number\")\n    else\n        s = sum(i for\
    \ i in BitVector(bitvec(n:m)).traverse(round))\n        \n        if m * 2 + 1\
    \ == s\n            return \"0b\" + convert(s % 2)\n        else\n           \
    \ return -1\n    end\nend", "    if n<m \n        return -1\n    else \n     \
    \   return ceil(Int64(m)/n)*2\nend", "    if m > n then return -1\n    if n ==\
    \ 0 || m == 0 then return 0\n    if n == m then return n\n    \n    let x = m\n\
    \    let y = n\n    let z = x-y\n    let s = ceil(Float64(z)) * 16\n    let r\
    \ = 16\n    while r < s do r = r + 16\n    \n    z = r - z\n    s = ceil(Float64(z))\
    \ * 16\n    r = 16\n    while r < s do r = r + 16\n    \n    z = r - z\n    s\
    \ = ceil(Float64(z)) * 16\n    r = 16\n    while r < s do r = r + 16\n    \n \
    \   z = r - z\n    s = ceil(Float64(z)) * 16\n    r = 16\n    while r < s do r\
    \ = r + 16\n    \n    z = r - z\n    s = ceil(Float64(z)) * 16\n    r = 16\n \
    \   while r < s do r = r + 16\n    \n    z = r - z\n    s = ceil(Float64(z)) *\
    \ 16\n    r = 16\n    while r < s do r = r + 16\n    \n    z = r - z\n    s =\
    \ ceil(Float64(z)) * 16\n    r = 16\n    while r < s do r = r + 16\n    \n   \
    \ z = r - z\n    s = ceil(Float64(z)) * 16\n    r = 16\n    while r < s do r =\
    \ r + 16\n    \n    z = r - z\n    s = ceil(Float64(z)) * 16\n    r = 16\n   \
    \ while r < s do r = r + 16\n    \n    z = r - z\n    s = ceil(Float64(z)) * 16\n\
    \    r = 16\n    while r < s do r = r + 16\n    \n    z = r - z\n    s = ceil(Float64(z))\
    \ * 16\n    r = 16\n    while r < s do r = r + 16\n    \n    z = r - z\n    s\
    \ = ceil(Float64(z)) * 16\n    r = 16\n    while r < s do r = r + 16\n    \n \
    \   z = r - z\n    s = ceil(Float64(z)) * 16\n    r = 16\n    while r < s do r\
    \ = r + 16\n    \n    z = r - z\n    s = ceil(Float64(z)) * 16\n    r = 16\n \
    \   while r < s do r = r + 16\n    \n    z = r - z\n    s = ceil(Float64(z)) *\
    \ 16\n    r = 16\n    while r < s do r = r + 16\n    \n    z = r - z\n    s =\
    \ ceil(Float64(z)) * 16\n    r = 16\n    while r < s do r = r + 16\n    \n   \
    \ z = r - z\n    s = ceil(Float64(z)) * ", "    \n    end # end of function",
  "    if m < 0\n        -1\n    elseif m == 0\n        n\n    elseif n == 0\n   \
    \     m\n    else\n        divmod_64(n, m).1\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    @time rounded_avg(10000,20000);\n</cell>\n<code language=julia-1.0>\n@time rounded_avg(10000,20000);\n\
    </cell>\n<text>\nExercise: Implement the function rounded_sum(n::Int64, m::Int64)::Int64\
    \ that computes the sum of the integers from n through m (including n and m).\
    \ Round the result to the nearest integer and convert that to binary.", "    \
    \    if n>m then return -1 else return int(math.ceil(m/n))*bin(int(math.ceil(m/n))).lstrip('0b')\n\
    end\n</code>\nThe result is binary and converted to an integer in string format,\
    \ but we can just as well return the binary and convert it to an integer if we\
    \ want.\n<code>", "    if m>n then return -1\n    if m==n then return m\n    if\
    \ m<n \n    else \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n", "    if n>m \n        rounded_avg(m, n)\n    else \n        rounded_avg(n,\
    \ m-1)\n    end\nend", "    rounded_avg = round(m/n) * n\n    return tostring(rounded_avg)\n\
    end", "    if m > n || n < 0 || m==0 || n == 0\n        return -1\n    else\n\
    \        avg = (n+m)/2\n        return round(avg).to_string()\n    end\nend\n\
    </cell>\n<code language=julia-0.6>\nrounded_avg(1, 5)\n</cell>\n<code language=julia-0.6>\n\
    rounded_avg(7, 5)\n</cell>\n<code language=julia-0.6>\nrounded_avg(10, 20)\n</cell>\n\
    <code language=julia-0.6>\nrounded_avg(20, 33)\n</cell>\n<code language=julia-0.6>\n\
    rounded_avg(7, 33)\n</cell>\n<text>\nProblem 3\nIn this problem, you will be given\
    \ an array of integers, A = [a1 a2 ... an] and another integer n. You need to\
    \ find the maximum number of consecutive zeroes in the array.", "    if n > m\
    \ \n        return -1 \n    else \n        return format((n+m-1)/2*2::Int64, '0b')\
    \ + format((n-m)/2, '0b')\n</code>\n<|/ a dscore=2 |>\n<| a tags=floating-point,bit-manipulation,integer,julia,binary\
    \ dscore=2 |>\nThis can be simplified a little if you remember that floating point\
    \ numbers are represented in binary, and that bitwise operators (the ones used\
    \ for bit manipulation in Julia) are defined for integers. For example:\n<code>\n\
    >>> 0b1111_1111_1111_1111_1111\n-6213568972\n>>> 0b1111_1111_1111_1110\n-6213568981\n\
    >>> 0b1111_1111_1111_1111_1111_1111_1111_1111\n-6213568972\n</code>\nThe first\
    \ two examples are all identical. The last two are all different because the bitwise\
    \ operation is performed on a floating point number.\nWe can use this to define\
    \ the average of a series of floating point numbers, by accumulating a series\
    \ of bits from each number, and returning when we've accumulated 4 bits.\n<code>\n\
    def avg(fs):\n    count = 0\n    accum = 0\n    for f in fs:\n        if count\
    \ < 4:\n            accum = accum | f\n        else:\n            count += 1\n\
    \            accum = accum * 2 if accum == 0 else accum\n    return accum & 0b1111_1111_1111_1111_1111\n\
    </code>\nHere's a quick test:\n<code>\n>>> print avg([1.01, 1.02, 1.03, 1.04,\
    \ 1.1, 1.05])\n3.6\n</code>\nThis should work with any numbers, not just doubles.\n\
    <|/ a |>\n<| a tags=floating-point,bit-manipulation,integer,julia,binary |>\n\
    For a non-Julia solution, just use Python:\n<code>\nfrom math import ceil\ndef\
    \ bit_avg(low, high):\n    if low >= high:\n        return None\n    diff = (high\
    \ - low)\n    if diff == 0:\n        return 0\n    elif diff < 0:\n        return\
    \ -1\n    elif diff == 1:\n        return int(ceil(float(low) / 2.0))\n    else:\n\
    \        mid = (high + low) // 2\n        return bit_avg(low, mid) + bit_avg(mid\
    \ + 1, high)", "    if n == m then\n        0\n    else if n > m then\n      \
    \  rounded_avg(n - 1, m) + 2^ceil(log2(n))\n    else\n        rounded_avg(n -\
    \ 1, m) - 2^ceil(log2(n))\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    @assert rounded_avg(1, 5) == \"0b11\" \n@assert rounded_avg(7, 5) == -1 \n@assert\
    \ rounded_avg(10, 20) == \"0b1111\" \n@assert rounded_avg(20, 33) == \"0b11010\"\
    \ \n</cell>\n<text>\nTo check your results, run the following cell:", "    if\
    \ m>n \n        rounded_avg(-1, -1*(n-m)+1)\n    else\n        rounded_avg(round(n),round(m))\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| a tags=julia |>\nUsing a loop with bitwise\
    \ operators (|, &, ~, ~&):\n<code>\nsum(1 << (n-i-1) | 1 << (i-1) for i=1:m)/m\n\
    </code>\nor equivalently:\n<code>\nsum(1 << (n-i-1) & 1 << (i-1) for i=1:m)/m\n\
    </code>\nThe above works for positive integers only. \nFor larger numbers:\n<code>\n\
    sum(1 << (n-i-1) & 1 << (i-1) for i=1:m)/m\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\
    Interesting, I did not know that the `&` operator could be used like that in Julia.\n\
    <|/ c |>\n<| c |>\n`1 & (2^64-1)` results in `1`, while `1 >> 1` results in `2^64\
    \ - 1`. So using `&` is dangerous, since `-1 >> 1 == -1` evaluates to `false`,\
    \ but `-1 & 1 == 1` evaluates to `true`. In fact, `x & 1` is equivalent to `x\
    \ >> 1`.\n<|/ c |>\n<| a dscore=2 |>\nI figured out a solution to this.  \n<code>",
  "    if m > n then\n        rounded_avg(n, m)\n    else\n        round(Int64((n+m)/2)).bin\n\
    \    end\nend\n</cell>\n<text>\nThe rounded_avg function has a similar signature\
    \ to the one in the question (i.e., it accepts two Int64 parameters), but now\
    \ the function returns an Int64 value instead of String. Why does it return a\
    \ String? The function rounds a number to two decimal places. In this case we\
    \ want the number to be rounded up if the rounded number equals the number we\
    \ provide. For example, rounding 4.3 to two decimal places results in 4.5, so\
    \ rounding the result to two decimal places should give us 4.5 and not 5. To do\
    \ this, we can use round and add 1 to the result.", "    rounded_avg=round(m/n)*m\n\
    \    if rounded_avg==-1\n        return -1\n    elseif n<m\n        return String.from_char(rounded_avg)\n\
    \    else\n        return String.from_char(rounded_avg+48)\nend\n</cell>\n<code\
    \ language=julia-1.5>\n\"\"\"\n    binary_to_dec\n    \n    Convert binary digits\
    \ in an ASCII string to decimal.\n    \n    Definition:\n        - Return decimal\
    \ equivalent of input string digits in an ASCII string, \n        which means\
    \ input string should have only 0 and 1.\n        - Return 0 if input string doesn't\
    \ contain any binary digits.\n        - Return 0 if input string contains invalid\
    \ binary digits.\n        - The decimal equivalent of empty string is 0.\n   \
    \     - The decimal equivalent of null string is 0.\n    \n    Example:\n    \
    \    - input_string = \"1011\"\n        - binary_to_dec(input_string)\n      \
    \  - \"15\"\n    \n    Arguments:\n        - input_string::String\n    \n    Returns:\n\
    \        - Int64\n\"\"\"", "    sum = Int(0)\n    for i in n..m\n        sum +=\
    \ Int(i)\n    return if sum < 0\n        -1\n    else\n        bin(Int(sum))[2:]\n\
    \    end\nend\n</cell>\n<code language=julia-1.0>\n@code_warntype rounded_avg(7,\
    \ 5)\n</cell>\n<text>\nThe function rounded_avg returns the rounded integer as\
    \ a string. You need to convert the string to an integer.", "    if n < m\n  \
    \      rounded_avg(m, n)\n    else\n        avg = (n+m) /2\n        if avg < 2\n\
    \            rounded_avg(1, avg)\n        else\n            rounded_avg(avg-1,\
    \ avg)\n        end\n    end\nend\n</cell>\n<text>\nExercise: write a function\
    \ to find out how many integers from 1 to n are greater than or equal to m, including\
    \ n and m.\nExample: n = 3, m = 4\nThe integers from 1 through 3 are 1, 2, and\
    \ 3. The integers from 4 through 7 are 4, 5 and 6. The integers from 8 through\
    \ 9 are 7 and 8. The integers from 10 through 13 are 9 and 10. The integers from\
    \ 14 through 17 are 13 and 14. The integers from 18 through 19 are 17 and 18.",
  "    if n<=m then return m\n    else return -1\n    end\nend\n</cell>\n<code language=julia-0.6>\n\
    rounded_avg(7,5)\n</cell>\n<code language=julia-0.6>\nrounded_avg(10,20)\n</cell>\n\
    <code language=julia-0.6>\nrounded_avg(20,33)\n</cell>\n<code language=julia-0.6>",
  "    rounded_sum = (n+m)\n    rounded_avg = rounded_sum / 2\n    if rounded_sum\
    \ > m\n        return -1\n    else\n        return String(rounded_avg, length(rounded_avg))\n\
    \    end\nend", "    if n < m \n        rounded = round(n/m)*m\n        return\
    \ string(bin(rounded))\n    end\n    if m == 0\n        return string(\"0\")\n\
    \    rounded = round(m/n)*n\n    return string(bin(rounded))\nend\n\"\"\"\n  \
    \  rounded_avg(n::Int64, m::Int64)::Union{String, Int64}\n        if n < m\n \
    \           return rounded_avg(round(n/m),m)\n        end\n        if m == 0\n\
    \            return string(\"0\")\n        end\n        return rounded_avg(round(m/n),n)\n\
    \    end\n\"\"\"", "    if m>n \n        return -1 \n    else \n        s=\"\"\
    \n        i=n\n        sum=0\n        while i<=m \n            sum += i \n   \
    \         s = \"0b\"+\"b\"*sum\n            i+=1\n        return s \nend\nrounded_avg(5,5)\n\
    rounded_avg(10,10)\nrounded_avg(20,20)\nrounded_avg(5,10)\nrounded_avg(10,20)\n\
    rounded_avg(20,10)\nrounded_avg(5,20)\nrounded_avg(10,33)\nrounded_avg(20,33)\n\
    rounded_avg(5,33)\nrounded_avg(10,40)\nrounded_avg(20,40)\nrounded_avg(5,40)\n\
    rounded_avg(10,50)\nrounded_avg(20,50)\nrounded_avg(5,50)\nrounded_avg(10,60)\n\
    rounded_avg(20,60)\nrounded_avg(5,60)\nrounded_avg(10,70)\nrounded_avg(20,70)\n\
    rounded_avg(5,70)\nrounded_avg(10,80)\nrounded_avg(20,80)\nrounded_avg(5,80)\n\
    rounded_avg(10,100)\nrounded_avg(20,100)\nrounded_avg(5,100)\nrounded_avg(10,125)\n\
    rounded_avg(20,125)\nrounded_avg(5,125)\nrounded_avg(10,150)\nrounded_avg(20,150)\n\
    rounded_avg(5,150)\nrounded_avg(10,165)\nrounded_avg(20,165)\nrounded_avg(5,165)\n\
    rounded_avg(10,200)\nrounded_avg(20,200)\nrounded_avg(5,200)\nrounded_avg(10,225)\n\
    rounded_avg(20,225)\nrounded_avg(5,225)\nrounded_avg(10,250)\nrounded_avg(20,250)\n\
    rounded_avg(5,250)\nrounded_avg(10,300)\nrounded_avg(20,300)\nrounded_avg(5,300)\n\
    rounded_avg(10,350)\nrounded_avg(20,350)\nrounded_avg(5,350)\nrounded_avg(10,400)\n\
    rounded_avg(20,400)\nrounded_avg(5,400)\nrounded_avg(10,450)\nrounded_avg(20,450)\n\
    rounded_avg(5,450)\nrounded_avg(10,500)\nrounded_avg(20,500)\nrounded_avg(5,500)\n\
    rounded_avg(10,550)\n", "    if n > m \n        error(\"n must be less than m\"\
    )\n    elseif n == m \n        \"\"\n    elseif n == 0\n        0\n    elseif\
    \ m == 0\n        -1\n    else\n        bits = Int64(n:min(m))\n        return\
    \ bits.round()\n    end\nend\n</cell>\n<text>\nPart 4: Combining Functions ",
  "    if m < n \n        rounded_avg(n,m+1)\n    else\n        if m < n\n       \
    \     rounded_avg(n,m+1) - n\n        else\n            if m < n\n           \
    \     rounded_avg(n,m+1) + n\n            else\n                if m < n\n   \
    \                 rounded_avg(n,m+1)\n                else\n                 \
    \   if m < n\n                        rounded_avg(n,m+1) - n\n               \
    \ end\n            end\n        end\n    end\nend\n</code>\n<|/ a tags=julia dscore=3\
    \ |>\n<| c |>\nThanks for your answer! I am not familiar with the syntax of Julia.\
    \ Can you please explain how it works? The reason is because I do not know julia\
    \ at all. I want to use it for my own project so I need an explanation of what\
    \ is happening in the code. Thanks again!\n<|/ c |>\n<| a |>\nHere's a recursive\
    \ solution in Julia. It uses the \"accumulator pattern\":\n<code>", "  if m==0\
    \ then\n    return n\n  else\n    if m==n then\n      return Int(round(n))\n \
    \   else if n>m then\n      return -1\n    else\n      return Int(round(n))\n\
    \    end\n  end\nend\n  \n\"\"\"\n  Compute the sum between two integers\n  \n\
    \  Function signature:\n  \n  sum(n::Int64, m::Int64)::Int64\n  \n  >>> sum(7,\
    \ 5)\n  14\n  >>> sum(5, 5)\n  0\n  >>> sum(0, 0)\n  0\n  \n  Write a function\
    \ that computes the sum of two integers.\n  \n  >>> sum(1, 3)\n  4\n  \n  The\
    \ sum of two numbers can be negative.\n  \n  >>> sum(-1, 3)\n  -1\n  \n  Note:\
    \ The function should work even if n is negative.\n  \n  >>> sum(1, -3)\n  -3\n\
    \  >>> sum(-3, 1)\n  -1\n  \n  To avoid overflow, use Int64 as type for the result\
    \ variable. Example:\n  \n  >>> sum(1, 1_000_000_000)\n  100000000000\n  \n  Write\
    \ a function that computes the sum of two integers and convert it to binary.\n\
    \  \n  >>> sum(1, 1_000_000_000).to_bytes(8, 'big')\n  b'0000000000000001'\n \
    \ \n  Write a function that computes the sum of the first n positive integers.\n\
    \  \n  >>> sum(1, 10)\n  55\n  \n  Test your function with a few examples.\n \
    \ \n  >>> sum(1, 10)\n  55\n  \n  >>> sum(0, 0)\n  0\n  \n  >>> sum(0, 0)\n  0\n\
    \  \n  >>> sum(0, 0)\n  0\n  \n  >>> sum(1, -1)\n  -1\n  \n  >>> sum(-1, 1)\n\
    \  -1\n  \n  >>> sum(-1, -1)\n  0\n  \n  >>> sum(1, 1_000_000_000)\n  100000000000\n\
    \  \n  >>> sum(1, 1_000_000_000).to_bytes(8, 'big')\n  b'0000000000000001'\n \
    \ \n  >>> sum(1, 10)\n  55\n  \"\"\"", "    if m < n \n        then -1\n     \
    \   else Int64.(round(Int64.(n), digits=0)..round(Int64.(m), digits=0))\n    end\n\
    end", "    n <= m && return m == 0 ? \"0b1\" : floor(Int(ceil(m/2.0)) * pow(2,(ceil(log(n,2)-ceil(log(m,2))+1)))\n\
    end\n</cell>\n<text>\nQ. Describe the following behavior of rounded_avg:", " \
    \   if m > n \n        rounded_avg = -1\n    else \n        rounded_avg = (n+m)/2\n\
    \        rounded_avg = round(rounded_avg)\n        if rounded_avg == rounded_avg\
    \ || rounded_avg == rounded_avg - 1\n            rounded_avg += \"0\"\n      \
    \  end\n    end\n    return rounded_avg\nend", "    if n >= m \n        then -1\n\
    \    else round((Int64)n+Int64(m))\n    end\nend\n</cell>\n<code language=julia-1.6>\n\
    rounded_avg(7,5)\n</cell>\n<code language=julia-1.6>\nrounded_avg(7, 5)\n</cell>\n\
    <code language=julia-1.6>\nrounded_avg(12, 20)\n</cell>\n<code language=julia-1.6>\n\
    rounded_avg(20, 33)\n</cell>\n<code language=julia-1.6>\n# Now for Julia\nrounded_avg\
    \ = round(Int, n::Int64, m::Int64)::Union{String, Int64} \n    if n >= m \n  \
    \      then -1\n    else round((Int64)n+Int64(m))\n    end\nend\n</cell>\n<code\
    \ language=julia-1.6>\nrounded_avg(7, 5)\n</cell>\n<code language=julia-1.6>\n\
    rounded_avg(7, 5)\n</cell>\n<code language=julia-1.6>\nrounded_avg(12, 20)\n</cell>\n\
    <code language=julia-1.6>\nrounded_avg(20, 33)\n</cell>\n<text>\nRound Function",
  "    if n == m then return m\n    if n >= m then return -1\n    else return Int64(n+m)/2\n\
    end", "    if n > m\n        return -1\n    else \n        rounded_avg = math.ceil(n/float(m))*m\n\
    \        return rounded_avg\nend", "    if n <= m \n    then \n        binary\
    \ = string(Int64.(range(n, m)))\n        return parseuint(binary)\n    else\n\
    \        return -1\n    end\nend\n</cell>\n<code language=julia-1.5>", "    if\
    \ n <= m\n        str = str0(round_to_binary(n) - str0(round_to_binary(m)))\n\
    \    else\n        str = str0(round_to_binary(n))\n    end\n    return Int64(str)\n\
    end\n</code>\n<|/ a |>\n<| a |>\nThis is an answer to your second question.\n\
    Your first question was about a general solution. I don't really know how that\
    \ works in Julia. I also don't really know whether there is a general solution\
    \ here. But one thing that comes to my mind is that you could write an recursive\
    \ function. \n<code>", "    if n == m \n        0\n    else\n        if n > m\n\
    \            -1\n        else\n            ceil(m / 2)*2^ceil(n / 2) - m\n   \
    \     end\n    end\nend\n</cell>\n<code language=julia-1.5>\n@time mean(rounded_avg(1:10000,\
    \ 1:10000))\n</cell>\n<text>\n6.3 Exercise - Write a function  to find all subarrays\
    \ of size n in the array $A$. The function should return an array of arrays. For\
    \ example, if\n$A = [1, 2, 3, -1, -4, 5, 8, 3, -7, 1]$, then\n$A[1] = [1, -4,\
    \ 5, 8, 3]$\n$A[3] = [3, -7, 1]$\n$A[6] = [1, -4, 5, 8, 3]$\n$A[7] = [1, -4, 5,\
    \ 8, 3]$", "    avg_sum = 0.0\n    for i=n-m+1 to m\n        avg_sum += i\n  \
    \  end\n    return convert(Int64, round(avg_sum))\nend", "    if n < m\n     \
    \   return -1\n    \n    sum = (n+1)::Int64\n    sum -= m\n    sum *= 2\n    \n\
    \    sum_str = to_binary(sum)\n    \n    mul = to_binary(n*m-sum)\n    \n    mul\
    \ = mul.replace(mul[mul.end-1] == '1', mul[mul.end-1] == '0')\n    \n    if mul.chars[0]\
    \ == '0'\n        return mul\n    else\n        return sum_str\n    end\nend\n\
    </cell>\n<cell>\nrounded_avg(1, 5)\n</cell>\n<text>\n3.3 Converting Integers to\
    \ Binary", "    if n>m \n        return -1\n    else\n        answer::Int64 =\
    \ 0\n        for i in (n..m)\n            answer+=i\n        return format(answer,\
    \ \"b\")\n</code>\n<|/ a tags=julia,rounding dscore=1 |>\n<| a tags=julia,rounding\
    \ dscore=0 |>\nRound a number to any number of decimal places.\n<code>", "   \
    \ \n    if m < 0 \n        error(\"n must be greater than m\")\n    end\n    \n\
    \    if n == 0 \n        return m\n    elseif m == 0 \n        return -1\n   \
    \ elseif m > n \n        error(\"m must be greater than n\")\n    end", "    if\
    \ n>m then -1\n    else return round(Int64(n-m, 2), 2)\nend", "    if m < n then\
    \ return -1\n    else return (bin(n:m).rstrip(\"0\").zfill(length(n) + length(m))[2:])\n\
    \    end\nend \n</cell>\n<code language=julia-1.0>\nrounded_avg(1, 5)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(7, 5)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(10, 20)\n</cell>\n<code language=julia-1.0>\nrounded_avg(20, 33)\n\
    </cell>\n<code language=julia-1.0>\nrounded_avg(20, 99)\n</cell>\n<text>\nExercise\
    \ 4\nWrite a function called to_hex that takes in a single 32-bit integer and\
    \ returns a string with the hexadecimal\nrepresentation of the integer. The returned\
    \ string should be formatted with the leading zeroes in front of each\ncharacter\
    \ of the string, if the integer has fewer than four digits. Otherwise, leading\
    \ zeroes are not used.\nExamples:\n>>> to_hex(42)\n\"2a\"\n>>> to_hex(33)\n\"\
    03\"\n>>> to_hex(1000)\n\"0100\"\n>>> to_hex(1001)\n\"0101\"\n>>> to_hex(1002)\n\
    \"0102\"\n>>> to_hex(168)\n\"00010\"\n>>> to_hex(200)\n\"00001\"\n>>> to_hex(9999)\n\
    \"00fff\"\n>>> to_hex(1000000000)\n\"ffffffff\"\n>>> to_hex(10000000000)\n\"ffffffff\"\
    \n>>> to_hex(100000000000)\n\"ffffffff\"\n>>> to_hex(2000000000)\n\"010\"\n>>>\
    \ to_hex(3000000000)\n\"011\"\n>>> to_hex(1000000000000000)\n\"0111111111111111111111111111111111111111111111111\"\
    \n>>> to_hex(10000000000000001)\n\"0111111111111111111111111111111111111111111111111\"\
    \n>>> to_hex(1000000000000000000)\n\"00000000000000000000000000000000\"\n>>> to_hex(10000000000000000001)\n\
    \"00000000000000000000000000000000\"\n>>> to_hex(10000000000000000002)\n\"00000000000000000000000000000000\"\
    \n>>> to_hex(10000000000000000003)\n\"00000000000000000000000000000000\"\n>>>\
    \ to_hex(4294967295)\n\"ffff\"\n>>> to_hex(-1)\n\"ffffffff\"\n>>> to_hex(-2)\n\
    \"00000000\"\n>>> to_hex(-3)\n\"00000001\"\n>>> to_hex(-4294967294)\n\"00000000\"\
    \n>>> to_hex(-4294967295)\n\"ffffffff\"\n>>> to_hex(10000000000000000000)\n\"\
    00000000000000000000000000000000\"\n>>> to_hex(1000000000000000000000)\n\"00000000000000000000000000000000\"\
    \n>>> to_hex(1000000000000000000001)\n\"00000000000000000000000000000000\"\n>>> ",
  "    digit = round(m*(1+n))//(m+n)\n    if m>n\n       return -1\n    return digit\n\
    end", "    if n<m \n        rounded_avg -1\n    else\n        return round(convert(Float64,\
    \ m) / convert(Float64, n))\n    end\nend\nrounded_avg(0, 0)\n</code>\n<|/ a |>\n\
    <| c |>\nThat's a good one. Thank you! I edited the answer to add the result I\
    \ got on my computer, in case someone wants to test it. Anyway, the problem with\
    \ the solution is that I'm supposed to convert this into binary without using\
    \ BigInts.\n<|/ c |>\n<| c |>\nThat's really cool! Thank you so much! Do you know\
    \ any way to fix the problem of the negative numbers? I'm going to accept this\
    \ as answer since it solved my question for positive numbers, but I'm curious\
    \ about the negative numbers.\n<|/ c |>\n<| c |>\nI edited the answer to include\
    \ the negative numbers\n<|/ c |>\n<| c |>\nI tested your solution for -2 -> 1\
    \ but this does not work.\n<|/ c |>\n<| a |>\nHere is a solution that uses BigInt\n\
    <code>", "    if n == m then\n        return n\n    \n    if n > m then\n    \
    \    return -1\n    end\n    \n    if m == 0 then\n        return -1\n    end\n\
    \    \n    return Int(round(n/m + 0.5, digits=0))\nend\nrounded_avg(1,5)\n</cell>\n\
    <code language=julia-1.5>\nrounded_avg(7, 5)\n</cell>\n<text>\nProblem 8\nA robot\
    \ is located at the top-left corner of a m x n grid (marked 'Start' in the diagram\
    \ below).", "    rounded_avg = if n <= m \n                    else -1\n    else\
    \ if n < m \n                then \"0b\" ++ show(n - m).replace(\" \", \"\")\n\
    \                else rounded_avg(m, n) \n    end\nend\nrounded_avg(n::Int64,\
    \ m::Int64) = rounded_avg(n, m)\n</cell>\n<code language=julia-1.5>\nrounded_avg(20,\
    \ 33)\n</cell>\n<code language=julia-1.5>\nrounded_avg(7, 5)\n</cell>\n<code language=julia-1.5>\n\
    rounded_avg(10, 20)\n</cell>\n<text>\nProblem 3.3: How many integers from 1 to\
    \ n are multiples of m?\nInputs:", "    if n>=m then return -1\n    else return\
    \ ((n/m+1)*Int(floor(Int,rem((n-m+1),(m-1)/2,Int(m>0)))))\nend\n</cell>\n<text>\n\
    Now we are going to define the reverse function reverse_num that converts binary\
    \ to decimal\nExample:\n    >>> reverse_num(\"0b11\")\n    7\n    >>> reverse_num(\"\
    0b1111\")\n    33\n    >>> reverse_num(\"0b11010\")\n    20\n    \"\"\"", "  \
    \  if n >= m\n    then return -1 \n    else return round(n + m - 1)/2 \n    end\
    \ \nend\n</cell>\n<code language=julia-1.0>\nrounded_avg(1, 5)\n</cell>\n<code\
    \ language=julia-1.0>\nrounded_avg(7, 5)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(10, 20)\n</cell>\n<code language=julia-1.0>\nrounded_avg(20, 33)\n\
    </cell>\n<code language=julia-1.0>\nrounded_avg(24, 42)\n</cell>\n<text>\nWrite\
    \ a function to add one to the digit at the end of a given integer. \nThis function\
    \ should work for all positive integers.\nExample: \nif x = 101 then 1+1 = 102\
    \ \nif x = 535 then 1+3 = 543 ", "    if n < m \n        rounded = -1\n    else\n\
    \        rounded = sum((n+m)..m) \n    end\n    if rounded == -1\n        return\
    \ \"-1\" \n    else \n        bits = [rounded]\n        current = rounded\n  \
    \      i = 1\n        while current > 1\n            current = current // 10\n\
    \            bits.append(current)\n            i += 1\n        end\n        return\
    \ bits[end-1]\n    end\nend", "    rounded = (ceil(n) - floor(m)) * floor(n/m)\n\
    \    rounded = ceil(rounded)\n    return Int64(bin(rounded)[2:])\nend\n</cell>\n\
    <code language=julia-1.5>\nrounded_avg(1, 5)\n</cell>\n<text>\nQuestion 10", " \
    \   if n >= m then \n        rounded_avg = -1\n    elseif n < m then \n      \
    \  rounded_avg = n::Int64\n    elseif n == m then\n        rounded_avg = 0\n \
    \   else\n        rounded_avg = round(((n+m)/2)::Int64)\n    end\n    return rounded_avg\n\
    end", "    if m < n return -1\n    if n == m then return 0\n    else: \n     \
    \   rounded_avg = Int(floor((n-m+1)/2))\n        binary = decBin(rounded_avg)\n\
    \        if binary[1] == 1 then return binary\n        else: return binary\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert rounded_avg(1, 5) == \"0b11\"\n@assert\
    \ rounded_avg(7, 5) == -1\n@assert rounded_avg(10, 20) == \"0b1111\"\n@assert\
    \ rounded_avg(20, 33) == \"0b11010\"\n</cell>\n<text>\nTask #3\nWrite a function\
    \ that takes two integers n and m and returns True if n is divisible by m\nand\
    \ False otherwise. \nExample:\n>>> is_divisible(10, 3)\nFalse\n>>> is_divisible(10,\
    \ 5)\nTrue", "    if m < n then return -1\n    return (((n+1)::Int64-(m+1)::Int64)/2::Int64).round().to_string()\n\
    end\n</cell>\n<code language=julia-1.1>\nrounded_avg(1,5)\n</cell>\n<text>\nConverting\
    \ to Binary\nConverting binary to decimal is also called \"Decimal to Binary\"\
    .", "    if n == m then\n        m\n    else if n > m then\n        -1\n    else\n\
    \        Int64(n + m - 1 ) / 2 % 2\n    end\nend\nrounded_avg =", "    if n >=\
    \ m\n        rounded_avg = -1\n    elseif n < m\n        rounded_avg = (n+m)/2\n\
    \    else\n        rounded_avg = (n+m+2)/3\n    end\nend\n</cell>\n<code language=julia-1.1>\n\
    \"\"\"\nFunction to convert binary number back to decimal number\n\"\"\"", " \
    \   if m == 0\n        rounded_sum = round(n)\n        rounded_sum == n\n    \
    \    return rounded_sum\n    else\n        total = round(n + (m/2))\n        total\
    \ == (n + (m/2))\n        rounded_sum = round(n + (m/2))\n        rounded_sum\
    \ == (n + (m/2))\n        return total\n    end\nend\nrounded_avg(1,5)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(7,5)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(10,20)\n</cell>\n<code language=julia-1.0>\nrounded_avg(20,33)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(20, 33)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(20,33)\n</cell>\n<code language=julia-1.0>\nrounded_avg(20,33)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(20,33)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(20,33)\n</cell>\n<code language=julia-1.0>\nrounded_avg(20,33)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(20,33)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(20,33)\n</cell>\n<code language=julia-1.0>\nrounded_avg(20,33)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(20,33)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(20,33)\n</cell>\n<code language=julia-1.0>\nrounded_avg(20,33)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(20,33)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(20,33)\n</cell>\n<code language=julia-1.0>\nrounded_avg(20,33)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(20,33)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(20,33)\n</cell>\n<code language=julia-1.0>\nrounded_avg(20,33)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(20,33)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(20,33)\n</cell>\n<code language=julia-1.0>\nrounded_avg(20,33)\n</cell>\n\
    <code language=", "    if n > m \n        return -1\n    else \n        avg =\
    \ (n + m) div 2\n        return round(avg).tobin(16)\n    end\nend", "    if n\
    \ == m \n        rounded_avg = \"0b0\"\n    else\n        rounded_avg = (Int64.(n+m)-Int64.(n))/(Int64.(n+m)-Int64.(n-1))\n\
    \        rounded_avg = rounded_avg .+ Int64.(n-1)\n    end\nend", "    if n <=\
    \ m \n        return String(x)\n    else\n        return -1\n    end\nend\n</cell>\n\
    <code language=julia-1.2>\n@assert rounded_avg(3, 7) == -1\n@assert rounded_avg(2,\
    \ 3) == -1\n@assert rounded_avg(10, 20) == -1\n@assert rounded_avg(20, 33) ==\
    \ -1\n@assert rounded_avg(100, 200) == -1\n</cell>\n<text>\nPart 2: Palindrome\
    \ Strings\nA palindrome is a word, number, or other sequence of symbols which\
    \ reads the same backward as forward. \nThe example below is a palindrome:", " \
    \   if n <= m \n        return n\n    elseif n < m \n        return -1\n    end\n\
    \    sum_val = n\n    sum_val2 = m\n    for i in (sum_val + sum_val2)\n      \
    \  sum_val = (sum_val + sum_val2)/2\n        sum_val2 = sum_val\n    end\n   \
    \ binary = string((sum_val - sum_val2)/2::Int64) \n    return binary\nend", " \
    \   if n == m\n        str(n)\n    else\n        bin(round(fromIntegral(n)) +\
    \  round(fromIntegral(m))-1)\n    end\nend\n</cell>\n<text>\nExercise 14: Write\
    \ a function to round a floating point value to the nearest integer.", "    if\
    \ n <= m \n        return str(bin(n)[2:])\n    else\n        return -1\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\nrounded_avg(1, 5)\n</cell>\n<code language=julia-1.5>\n\
    rounded_avg(7, 5)\n</cell>\n<code language=julia-1.5>\nrounded_avg(10, 20)\n</cell>\n\
    <code language=julia-1.5>\nrounded_avg(20, 33)\n</cell>\n<code language=julia-1.5>\n\
    rounded_avg(20, 33)\n</cell>\n<text>\nPart 5: Binary Addition Table", "    if\
    \ n <= m\n        return n\n    return -1\nend\n</cell>\n<text>\nExercise 9: Write\
    \ a function that converts a decimal number to a binary number.\n    We should\
    \ assume that the decimal number given is valid.\n    Round the answer to nearest\
    \ binary number and convert that to decimal.\n    Example:\n    >>> decToBin(1)\n\
    \    \"0b1\"\n    >>> decToBin(2)\n    \"0b10\"\n    >>> decToBin(5)\n    \"0b101\"\
    \n    >>> decToBin(9)\n    \"0b1011\"\n    >>> decToBin(10)\n    \"0b10111\"\n\
    \    >>> decToBin(100)\n    \"0b101111001\"\n    \"\"\"", "    if m==0 || n<m\
    \ \n        rounded_avg=-1\n    elseif n==m\n        rounded_avg=n\n    elseif\
    \ n>m\n        rounded_avg=-1\n    else\n        rounded_avg=round(n/m)*m \n \
    \   end\nend\n</cell>\n<text>\nQuestion 6\nWrite a function that takes three strings\
    \ as arguments. The first string is the name of a file, \nthe second string is\
    \ the name of a directory the file will reside in, and the third string is a filename.\n\
    The function should open the file in the directory specified by the second string\
    \ and write out the file's contents to the console.\nFor example, if the file\
    \ to be read is called \"test_file.txt\" and the directory to read from is called\
    \ \"test\",\nand the filename to read from is called \"test.txt\",\nthe function\
    \ should print \"Hello, test_file!\"", "    if n <= m\n        binary = string(x::Int64\
    \ in n .. m | x in m .. n)\n    else\n        binary = string(x::Int64 in m ..\
    \ n | x in n .. m)\n    return Int(binary)\nend", "    if n >= m\n        rounded_avg\
    \ = ceil(n/m)\n        return bin(rounded_avg)[2:]\n    else\n        rounded_avg\
    \ = ceil(n/m+1)\n        return bin(rounded_avg)[2:]\n    end\nend\n\"\"\"\n \
    \   rounded_avg documentation\n\"\"\"", "    if m > n \n        return -1\n  \
    \  \n    return round(Int64(n)/Int64(m))*Int64(2).bin\nend\n</cell>\n<text>\n\
    Problem 3\nWrite a function to compute the sum of the squares of two given integers.\n\
    For example, sum(5, 5) = 10, sum(1, 2) = 5", "    if n > m\n        return -1\n\
    \    else\n        return round((n+1)/(m+1))\nend\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(10,5)\n</cell>\n<text>\nExercise 2", "    # check if n is greater\
    \ than m\n    if n > m\n        rounded = -1\n    else\n        rounded = round(n/m,\
    \ digits = 0)\n        # convert to binary\n        rounded = bin(rounded)[2:]\n\
    \    end\n    return rounded\nend\n</cell>\n<text>\n\u25CF Round the sum of two\
    \ positive integers\nThe sum of two positive integers n and m is defined as the\
    \ sum of their absolute values.\n    Round the sum of the absolute values of n\
    \ through m to nearest integer.\n    Example:\n    >>> rounded_sum(4, 6)\n   \
    \ 3\n    >>> rounded_sum(5, 6)\n    3\n    >>> rounded_sum(20, 33)\n    4\n  \
    \  >>> rounded_sum(20, 30)\n    2\n    >>> rounded_sum(20, 31)\n    0\n    \"\"\
    \"", "    if n>m\n        return -1\n    \n    else\n        return round(Float64(n)/Float64(m),\
    \ digits=0) \n    end\nend\n</cell>\n<text>\nExercise: Write a function that returns\
    \ all the prime numbers between the integers given as arguments. \nThe function\
    \ will receive two integer arguments: n and m, and will return all prime numbers\
    \ p such that p is strictly smaller than m and p is greater than n.", "    if\
    \ m > n then return -1\n    m = m+1\n    if m > n then return -1\n    sum = 0\n\
    \    for i in 0:n-m\n        sum += i\n    return sum/m %2==0\nend\n</code>\n\
    <|/ a dscore=0 tags=ruby,function,rounding |>\n<| c |>\nYou don't need to use\
    \ `ceil` here. As stated in the documentation for [`Int`](https://docs.julialang.org/en/v1/stdlib/math/#Base.Int)\
    \ `Int` is implemented as `Float64`.\n<|/ c |>\n<| c |>\nThis doesn't actually\
    \ answer the question. OP asked for a solution that uses no loops, only native\
    \ functions.\n<|/ c |>\n<| c |>\n: Please read the question: he mentions \"Round\
    \ the answer to the nearest integer\". I think he doesn't care whether the fraction\
    \ is rounded to integers or not.\n<|/ c |>\n<| c |>\nYes, I read that. He wants\
    \ to round the answer to the nearest integer, regardless of whether that integer\
    \ is an odd or even integer.\n<|/ c |>\n<| c |>\n: No, you misread that. You said\
    \ *\"to the nearest integer\"* but in the question you said *\"to binary\"*. So\
    \ he doesn't want fractional digits.\n<|/ c |>\n<| a tags=ruby,function,rounding\
    \ dscore=0 |>\nTo round a float to its nearest integer, just use round() with\
    \ the second parameter as :up. For example, the following code:\n<code>\nceil(1.5)\n\
    </code>\nwill print 2\n<code>\nceil(1.5)\n</code>\nwill print 2\n<code>\nceil(1.5)\n\
    </code>\nwill print 2\n<|/ a |>\n<| c |>\nHe wants to round it to the nearest\
    \ integer, which would result in `ceil(1.5)` being `2`. Not the nearest integer\
    \ to the nearest integer, which would result in `ceil(1.5)` being `1`.\n<|/ c\
    \ |>\n<| a |>\nFor integers, use ceil() which rounds a number up or down to the\
    \ nearest integer.\n<code>\nceil(6.5)\n</code>\nwill print 6.\n<code>\nceil(7.0)\n\
    </code>\nwill print 7.\n<|/ a tags=ruby,function,rounding dscore=0 |>\n<| a |>\n\
    To round a floating point number to its nearest integer you can simply use the\
    \ ceil function. It will return the nearest integer to the float passed as a parameter.\n\
    <code>\ndef rounding_to_nearest_integer(number)\n  ceil(number)\nend\n</code>\n\
    <|/ a dscore=0 tags=", "    if n >= m \n        -1 \n    else \n        ((2^n\
    \ - 1)/(n+m)) * n + m\n    end\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=julia\
    \ |>\nHere is a solution without using any packages. It is based on the idea that\
    \ in the range [a, b] the average is given as [a, b + n/2].\n<code>", "    if\
    \ n >= m \n        m -= 1\n    else\n        n -= 1\n    end\n    return bin(n*m\
    \ + m*n + n + m)\nend", "    if n > m \n        return -1\n    elseif n <= 0\n\
    \        return \"-1\"\n    else\n        repeat_n = 10000000000\n        repeat_m\
    \ = 10000000000\n        repeat_n2 = 10\n        repeat_m2 = 10\n        n2 =\
    \ floor(m/2)\n        m2 = floor(m/2)\n        \n        while m2 >= n \n    \
    \        repeat_m2 = 10000000000\n            repeat_n2 = 10\n            m2 =\
    \ floor(m/2)\n            n2 = floor(m/2)\n        end\n        while n2 > n \n\
    \            repeat_n = 10000000000\n            repeat_n2 = 10\n            n2\
    \ = floor(m/2)\n            m2 = floor(m/2)\n        end", "    if m == 0\n  \
    \      \"\"\n    else\n        round(Int64(n)/m) * m\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@test rounded_avg(1, 5) == 0b11\n@test rounded_avg(7,\
    \ 5) == -1\n@test rounded_avg(10, 20) == 0b1111\n@test rounded_avg(20, 33) ==\
    \ 0b11010\n</cell>\n<text>\n4.3 Sum The Squares\nYou are given three integers\
    \ n and k that represent the number of rows and number of columns in a square\
    \ matrix respectively.\n    Create a square matrix and fill it with n rows and\
    \ k columns.\n    You have to fill each cell of the matrix with sum of squares\
    \ of row and column indices separated by one.\n    For example if n = 4, k = 3\n\
    \    Matrix of the order 4 * 3 with elements \n    \n    $\\begin{bmatrix}\n \
    \   1 & 2 & 3 & 4\\\n    5 & 6 & 7 & 8\\\n    9 & 10 & 11 & 12\\\n    13 & 14\
    \ & 15 & 16\\\n    \\end{bmatrix}$", "    if n <= m\n        rounded_avg = Float64(n)\
    \ / Float64(m)\n    else\n        rounded_avg = -1\n    end\n    rounded_avg =\
    \ round(rounded_avg)\n    if Float64(rounded_avg) < 0\n        return -1\n   \
    \ \n    rounded_avg = String(Int, rounded_avg, base=2)\n    return rounded_avg\n\
    end\n</cell>\n<code language=julia-1.2>\nrounded_avg(1, 5)\n</cell>\n<code language=julia-1.2>\n\
    rounded_avg(7, 5)\n</cell>\n<code language=julia-1.2>\nrounded_avg(10, 20)\n</cell>\n\
    <code language=julia-1.2>\nrounded_avg(20, 33)\n</cell>\n<code language=julia-1.2>\n\
    rounded_avg(20, 0)\n</cell>\n<text>\nExercise: Write a Julia function that accepts\
    \ a positive integer and returns the factorial of it.", "    if m==-1 return -1\n\
    \    if n<m then \n        rounded_avg(n,m-1)\n    else\n        rounded_avg(m,n-1)\n\
    \    end\nend\n</cell>\n<code language=julia-1.6>\nround(21.5-0.5) == round(6.5)\n\
    </cell>\n<code language=julia-1.6>\n@code_warntype round(21.5-0.5) == round(6.5)\n\
    </cell>\n<code language=julia-1.6>", "    if n > m\n        return -1\n    else\
    \ if n < m\n        return \"0b\" + to_binary((m - n) / 2)\n    else\n       \
    \ return \"0b\" + to_binary((n+m-2) / 2)\n    end\nend\n</cell>\n<text>\nThe answer\
    \ should be \"0b1111\" (because \"0b11111111\" rounded to 5 would be 5 decimal\
    \ places). How do we do that without using any string formatting functions?",
  "    # Initialize variable\n    res = -1\n    # Check if there are enough numbers\
    \ between n and m\n    if m < n\n        error(\"Not enough numbers between\"\
    )\n    elseif n == m\n        error(\"One number not enough between\")\n    else\n\
    \        # Round up the numbers and store them in variable\n        res = round(Float64(n+m)/2)\n\
    \        # Convert the result to binary\n        resInt = bin(res)[2:]\n     \
    \   # Remove the 0b from the result\n        resInt = filter(x -> x == '0', resInt)\n\
    \        # Re-concatenate the result\n        res = \"\".join(resInt)\n    end\n\
    \    # Return the result\n    return res\nend\n</cell>\n<code language=julia-1.5>\n\
    rounded_avg(12, 6)\n</cell>\n<text>\nExercise 6.1\nWrite a function that checks\
    \ if a given number is positive and returns the binary representation.\nExample:\n\
    >>> is_positive(52)\n\"0101\"\n>>> is_positive(-1)\n\"0101\"\n>>> is_positive(0)\n\
    \"0101\"\n>>> is_positive(30)\n\"0111\"\n>>> is_positive(511)\n\"0111\"\n>>> is_positive(510)\n\
    \"0111\"\n>>> is_positive(520)\n\"0111\"\n>>> is_positive(1520)\n\"0111\"\n>>>\
    \ is_positive(1510)\n\"0111\"\n>>> is_positive(1500)\n\"0111\"\n>>> is_positive(15001)\n\
    \"0111\"\n>>> is_positive(-511)\n\"0111\"\n>>> is_positive(-510)\n\"0111\"\n>>>\
    \ is_positive(-520)\n\"0111\"\n>>> is_positive(-1520)\n\"0111\"\n>>> is_positive(-1510)\n\
    \"0111\"\n>>> is_positive(-1500)\n\"0111\"\n>>> is_positive(-15001)\n\"0111\"\n\
    >>>", "    if n <= m\n        return n\n    \n    \n    \n    end = (n + m) //\
    \ 2\n    \n    return round(end.to_binary() + end.to_binary()[end.length], 2).to_string(2)\n\
    \    \n    \nend\n</cell>\n<code language=julia-1.6>\nrounded_avg(1, 5)\n</cell>\n\
    <code language=julia-1.6>\nrounded_avg(7, 5)\n</cell>\n<code language=julia-1.6>\n\
    rounded_avg(10, 20)\n</cell>\n<code language=julia-1.6>\nrounded_avg(20, 33)\n\
    </cell>\n<text>\nProblem 9\nThe following is probably the simplest way to find\
    \ the longest common subsequence of two given strings. In English, the definition\
    \ of the LCS means \"longest common subsequence.\" The LCS of two strings is the\
    \ length of the longest (non-overlapping) subsequence of the two strings that\
    \ appear right next to each other. For example, \u201Cabba\u201D and \u201Cabac\u201D\
    \ have the LCS\_(length 3). Write a function that returns the length of the LCS\
    \ between two given strings.", "    if m<n || n==0 return 0\n    avg = floor(n/m)*m\n\
    \    binary = tobinary(avg)\n    return binary\nend", "    diff = n-m;\n    if\
    \ diff < 0 \n        return -1;\n    \n    if diff == 0 \n        return m;\n\
    \    \n    return (((diff == 0) and m) or (floor((m+diff)/2) and rounded_avg(n,m))\
    \ );\nend \n\"\"\"", "    \n    if n > m\n        return \"-1\"\n    \n    return\
    \ bin(n+m).rstrip(\"0\").zfill(n+m)", "    if n > m \n        then \"0b0\"\n \
    \       else rounding(sum((n-m, n+m))/2) \n    end\nend", "    if m > n \n   \
    \     return -1\n    else \n        return round(round(n::Int64, 2)/round(m::Int64,\
    \ 2)*2^10)\n</code>\n<|/ a dscore=4 |>\n<| a |>\nIn Julia, you can define new\
    \ types using typedef, but you cannot define new methods on an existing type.\n\
    You can create new types using struct, but you cannot define new methods on an\
    \ existing type.\nYou can create new types using typedef, but you cannot define\
    \ new methods on an existing type.\n<|/ a dscore=4 tags=julia |>\n<| a |>\nI realize\
    \ this is an old question, but I thought I should add an answer.\nIf you want\
    \ a function to return your custom type instead of a primitive data type, you\
    \ can do the following:\n<code>\nstruct MyType\n    a::Float64\nend", "    if\
    \ m >= n then return -1\n    else if m > n then return -1\n    else if m == n\
    \ then\n        n = n - 1\n        m = m - 1\n        \n        rounded_avg =\
    \ ((n-1)..m).reduce((x, y) -> (x // 2) + y // 2)\n        \n        rounded_bin\
    \ = bitstring(rounded_avg)\n    end\n    return rounded_bin\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| a |>\nHere is some Ruby code to do what you want I suppose.\
    \ Sorry if its not idiomatic ruby\n<code>\ndef rounded_avg(m, n)\n  return -1\
    \ if m < 0 || n < 0\n  m = (m % 2 == 0) ? m / 2 - 1 : m / 2\n  n = (n % 2 == 0)\
    \ ? n / 2 - 1 : n / 2\n  if m < n\n    diff = n-m\n    diff.to_i\n  else\n   \
    \ diff = m-n\n    diff.to_i\n  end\nend\n</code>\n<|/ a tags=ruby dscore=0 |>\n\
    <| c |>\nThis isn't what the OP asked for. This code doesn't return the desired\
    \ result for inputs `rounded_avg(2, 5)`, `rounded_avg(5, 2)`, and `rounded_avg(6,\
    \ 1)`. For example, try `rounded_avg(2, 5)` and it returns `\"0b10\"` when it\
    \ should be `\"0b11\"`. And what about `rounded_avg(6, 1)`? It returns `\"0b1111\"\
    `, when it should be `\"0b11010\"`.\n<|/ c |>\n<| a tags=ruby dscore=0 |>\nA Ruby\
    \ solution\n<code>\ndef round(n)\n  n % 2 ==0 ? n/2 : n/2 - 1\nend", "    if m\
    \ == n then return 0 \n    \n    if n>m then return -1", "    # Your code here\n\
    \    if n > m \n        return -1\n    \n    if n == m\n        return \"0b0\"\
    \n    \n    bin = bin(n).reverse()\n    \n    i = 0\n    count = 0\n    \n   \
    \ while i < m\n        if bin[i] == \"0\"\n            count = count + 1\n   \
    \     i += 1\n    \n    if count == m\n        return bin\n    \n    bin = bin[0:i]\n\
    \    \n    if bin[m-1] == \"1\"\n        bin = bin[0:m]\n    \n    bin = bin[0:m]\n\
    \    \n    return bin\nend", "    if n == m\n        return String(n)\n    \n\
    \    if n > m \n        return -1\n    \n    left = (n+m)/2\n    right = (n+m+1)/2\n\
    \    \n    binary = \"\"\n    \n    while left != right\n        if left == 0\n\
    \            binary = left + \"0\"\n            left -= 1\n            right -=\
    \ 1\n        \n        elif left == 1\n            binary = left + \"1\"\n   \
    \         left -= 2\n            right -= 1\n        \n        else\n        \
    \    binary = left + \"1\" + \"0\"\n            left -= 1\n            right -=\
    \ 1\n    \n    binary = bin[::-1]\n    \n    return binary.to_s(2)\nend\n</cell>\n\
    <code language=julia-0.6>\nprintln(rounded_avg(7, 5))\nprintln(rounded_avg(8,\
    \ 5))\nprintln(rounded_avg(7, 10))\nprintln(rounded_avg(7, 20))\nprintln(rounded_avg(8,\
    \ 33))\n</cell>\n<text>\nWhat do you notice about the pattern? How can we fix\
    \ it?", "    if n == m\n        return str(n)\n    elif n >= m\n        return\
    \ -1\n    \n    binary = \"\"\n    begin = n.bit_length()\n    end = m.bit_length()\n\
    \    \n    for i = begin:-1:1\n        binary = binary + int2binary(n.bit_length()-i-1)\n\
    \    \n    for i = end:-1:1\n        binary = binary + int2binary(m.bit_length()-i-1)\n\
    \    \n    binary = binary + int2binary(n.bit_length()-1)\n    binary = binary\
    \ + int2binary(m.bit_length()-1)\n    \n    return binary", "    if n <= m \n\
    \        return n\n    \n    else \n        return -1\nend", "    if n >= m\n\
    \        return -1\n    else\n        rounded_sum = 0\n        rounded_count =\
    \ 1\n        for n in n:n:\n            rounded_sum += n\n            rounded_count\
    \ += 1\n        rounded_avg = rounded_sum / rounded_count\n        return convert(Int64,\
    \ rounded_avg)\n    end\nend\n</cell>\n<cell>\nrounded_avg(1, 5)\n</cell>\n<text>\n\
    Problem 2b\nWrite a function that takes three floating point numbers and returns\
    \ the sum of all three. Round the answer to the nearest integer and convert that\
    \ to binary.\nThe function should ignore the rounding error. \nThis function should\
    \ return an error if the numbers cannot be represented exactly with 64 bits.\n\
    Example:\n>>> sum_fp_numbers(2.7, 3.8, 4.3)\n\"0b0110011001100110011001101011101010\"\
    \n>>> sum_fp_numbers(2.7, 3.8, 4.3)\n\"0b0110011001100110011001101011101010\"\n\
    >>> sum_fp_numbers(2.7, 3.8, 4.3)\n\"0b0110011001100110011001101011101010\"\n\
    >>> sum_fp_numbers(2.7, 3.8, 4.3)\n\"0b0110011001100110011001101011101010\"\n\
    >>> sum_fp_numbers(2.7, 3.8, 4.3)\n\"0b0110011001100110011001101011101010\"\n\"\
    \"\"", "    if n == m then return string(\"0\")\n    round(n/m)*m \nend", "  \
    \  bits = bigdecimal.Decimal(n).round(bigdecimal.ROUND_HALF_UP).to_binary(bigdecimal.ROUND_HALF_UP)\n\
    \    if bits == n.to_binary(bigdecimal.ROUND_HALF_UP)\n        n\n    else\n \
    \       bigdecimal.Decimal(-1).round(bigdecimal.ROUND_HALF_UP).to_binary(bigdecimal.ROUND_HALF_UP)\n\
    \    end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nWhile this answer might be\
    \ correct, it is always better to add some explanation of your code to help readers.\n\
    <|/ c |>\n<| c |>\nI have added some explanation to this answer. Thanks!\n<|/\
    \ c |>\n<| a dscore=1 |>\n<code>\n# Convert the given number to binary", "   \
    \ if m < n \n        return -1\n    if n == m \n        return \"0b1\"\n    return\
    \ \"0b\" + bin(m)[2:].zfill(int(n-m))", "    if n <= m \n    then \n        return\
    \ to_binary(n, rounding_point=\"nearest\")\n    else\n        return -1\n    end\n\
    end\n</cell>\n<text>\nExercise\nNow, suppose we want to round the average from\
    \ n to m to n to m (including n and m) without using any built-in function.\n\
    Write a custom function rounded_avg that has the same functionality as rounded_avg.\n\
    Write your function rounded_avg to use the following three steps:", "    if n\
    \ > m \n        then \n            \"0b-1\"\n        else \n            round(n/(m\
    \ - n))*(m - n) + n\n    end\nend\n</cell>\n<code language=julia-0.6>\nrounded_avg(1,\
    \ 5)\n</cell>\n<code language=julia-0.6>\nrounded_avg(7, 5)\n</cell>\n<code language=julia-0.6>\n\
    rounded_avg(10, 20)\n</cell>\n<code language=julia-0.6>\nrounded_avg(20, 33)\n\
    </cell>\n<text>\n3. String Manipulation", "    if m < n\n        -1\n    else\n\
    \        return round(Float64(n) / Float64(m), 2)\n    end\nend\n</cell>\n<code\
    \ language=julia-1.6>", "    if m > n \n        -1\n    else\n        round(n/m,\
    \ digits=1) * m\n    end\nend\n</cell>\n<code language=julia-1.6>\nrounded_avg(4,10)\n\
    </cell>\n<code language=julia-1.6>", "  if n < m \n    return -1\n  else \n  \
    \  return convert(Int64, ceil(m / n)) * \"0b\" + convert(Int64, ceil(n / m)) *\
    \ \"0\"\n  end\nend\n</cell>\n<code language=julia-1.0>\n@test rounded_avg(1,\
    \ 5) == \"0b11\"\n@test rounded_avg(7, 5) == -1\n@test rounded_avg(10, 20) ==\
    \ \"0b1111\"\n@test rounded_avg(20, 33) == \"0b11010\"\n</cell>\n<text>\nWrite\
    \ a function that converts binary to decimal using the rule specified below:\n\
    $$ 10n\\cdot2^{n-1} + ... + 2 \\cdot 1 + 0 = 0$$\nExample:\n$$ 0b1111010 \\cdot2^{5}\
    \ = 0b15$$", "    if n <= m\n        rounded_avg = round((n + m) / 2)\n      \
    \  return convert(rounded_avg, Int64)\n    else\n        return -1\nend", "  \
    \  if n > m \n        return -1\n    \n    if n < m \n        return f\"{to_binary_str(n)}{to_binary_str(m)}\"\
    \n    \n    let \n        avg = floor((m+n)/2) \n        binary0 = to_binary_str(avg)\n\
    \        binary1 = to_binary_str(avg+1)\n        binary2 = to_binary_str(avg+2)\n\
    \        \n    in \n        binary0 + binary1 + binary2\nend\n</cell>\n<text>\n\
    The average of the numbers n is given as n + n/2, where n and n/2 are integers,\
    \ and is the middle integer.\nThe average of the numbers m is given as m + m/2,\
    \ where m and m/2 are integers, and is the middle integer.\nAs a reminder, we\
    \ can round a number x to its nearest integer by taking the integer and dividing\
    \ by two. For example, for x equal to 4, we divide by 2 to get 0.\nIn our algorithm,\
    \ we only need three bits of accuracy, namely the low order bit and low order\
    \ and middle bits of the answer.", "    if m>n \n        return -1\n    else \n\
    \        sum = Int64(0)\n        for i in n..m \n            sum = sum + i\n \
    \       return show(0, base, 2)(sum / m)\n</code>\n<|/ a |>\n<| a tags=binary,floating-point,python\
    \ |>\n<code>\ndef bfloat2bin(a):\n  return bin(a).replace('0b',\"0\")\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nThis worked for me when `a` was a float, thank you!\n\
    <|/ c |>\n<| a tags=binary,floating-point,python dscore=2 |>\nAnother solution\
    \ I found on some site:\n<code>\nfrom numpy import binary_repr"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
