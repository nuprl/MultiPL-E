name: HumanEval_97_multiply
language: jl
prompt: "\"\"\"Complete the function that takes two integers and returns \n    the\
  \ product of their unit digits.\n    Assume the input is always valid.\n    Examples:\n\
  \    >>> multiply(148, 412)\n    16\n    >>> multiply(19, 28)\n    72\n    >>> multiply(2020,\
  \ 1851)\n    0\n    >>> multiply(14, -15)\n    20\n    \"\"\"\nfunction multiply(a::Int64,\
  \ b::Int64)::Int64 \n"
tests: "using Test\n\n@testset begin\n\ncandidate = multiply;\n\t@test(candidate(148,\
  \ 412) == 16)\n\t@test(candidate(19, 28) == 72)\n\t@test(candidate(2020, 1851) ==\
  \ 0)\n\t@test(candidate(14, -15) == 20)\n\t@test(candidate(76, 67) == 42)\n\t@test(candidate(17,\
  \ 27) == 49)\n\t@test(candidate(0, 1) == 0)\n\t@test(candidate(0, 0) == 0)\nend\n"
completions: ["    # Write your code here.\n    return b*10-a\nend", "    if b < 0\n\
    \        return 0\n    product = 1 \n    for digit in digits(b)\n        product\
    \ = product * digit\n    end\n    return product\nend", "    \"\"\"\n    Define\
    \ the function that takes two integers and returns the product of \n    their\
    \ unit digits.\n    Assume the input is always valid.\n    Examples:\n    >>>\
    \ multiply(148, 412)\n    16\n    >>> multiply(19, 28)\n    72\n    >>> multiply(2020,\
    \ 1851)\n    0\n    >>> multiply(14, -15)\n    20\n    \"\"\"\n    \n    if a\
    \ > b\n        x, y = b, a\n    else\n        x, y = a, b\n    \n    result =\
    \ 1\n    \n    while y > 0\n        result *= y\n        y -= 1\n    \n    while\
    \ x > 0\n        result *= x\n        x -= 1\n    \n    return result", "    if\
    \ a==0 && b==0 \n        0 \n    else \n        carry = 1\n        product = a\
    \ / b\n        while a>0 \n            carry, a = a % b, (a / b) \n          \
    \  if carry == 1 \n                product = product * b + carry\n           \
    \ else \n                product = product * b\n                carry = 1\n  \
    \      end\n        product * b + carry \n    end\nend\n</cell>\n<code language=julia-0.6>\n\
    multiply(2, 3)\n</cell>\n<code language=julia-0.6>\n\"\"\"\n    square(a::Int64)::Int64",
  "    if a==0 || b==0\n    else return (a*b)\n    end", '    return a*b', "    return\
    \ a*b\nend \n</cell>\n<code language=julia-1.6>\n# Test the function\ntests =\
    \ [\n    (148, 412),\n    (19, 28),\n    (2020, 1851),\n    (14, -15)\n]\nfor\
    \ test in tests\n    print(test, \", \", multiply(test[1], test[2]))\nend\n</cell>\n\
    <text>\nTask: Implement the function sum_digits(a::Int64) using only multiplication\
    \ operations.", "    if b == 0\n    then return 0\n    else \n        return a\
    \ * b\n    end\nend\n</cell>\n<code language=julia-1.5>\n#export\n\"\"\"Complete\
    \ the function that takes two integers and returns the \nabsolute value of the\
    \ product of their unit digits.\nAssume the input is always valid.\nExamples:\n\
    \    >>> absolute(multiply(148, 412))\n    160\n    >>> absolute(multiply(19,\
    \ 28))\n    80\n    >>> absolute(multiply(2020, 1851))\n    0\n    >>> absolute(multiply(14,\
    \ -15))\n    -20\n\"\"\"", "    if a==0 || b==0\n        return 0\n    if a>=0\
    \ && b>0\n        return a * b\n    if a<0 && b<0\n        return abs(a) * abs(b)\n\
    \    if a>=0 && b>=0\n        return (a/b) * (b/a)\n    if a<0 && b<0\n      \
    \  return abs(a/b) * abs(-b/a)\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n\
    The above answers are great, and they do answer the question. However, they do\
    \ not properly address the underlying issue of how to correctly implement an algorithm\
    \ that needs to handle \"invalid inputs\".\nAn algorithm that handles an input\
    \ of \"invalid inputs\" is to simply throw an exception. This avoids any additional\
    \ logic or checking, but it does not address the underlying issue of how to actually\
    \ implement such an algorithm.\nThe reason is simply because the algorithm itself\
    \ cannot handle \"invalid inputs\". The input \"invalid input\" is simply a possible\
    \ input for which there is no \"correct\" answer; i.e. no valid solution exists\
    \ for the algorithm. There is no correct answer for a number which does not have\
    \ a valid solution for a \"unit digit\" number. Thus, an algorithm that handles\
    \ \"invalid inputs\" simply cannot possibly return \"valid\" results.\nTherefore,\
    \ the question is really how to handle \"invalid inputs\" when trying to implement\
    \ a unit digit multiplication algorithm that can actually solve the \"unit digit\
    \ problem\", as stated in the question.\nOne solution is to simply throw an exception.\
    \ Then, the \"invalid input\" is handled elsewhere by the calling code (perhaps\
    \ by passing a function to the multiplication algorithm that can handle the exception).\n\
    Another solution is to throw an exception, even though the user can see the result\
    \ of the exception. For example, in the multiplication algorithm, throw an exception\
    \ if a negative input value was provided. This would also allow the caller to\
    \ handle the exception, if desired.\nThe question specifically asks how to implement\
    \ a \"unit digit multiplication algorithm\". There is really no \"correct\" answer\
    \ for a unit digit multiplication algorithm that can solve the unit digit problem.\
    \ So there is nothing to implement.\n<|/ a tags=haskell,algorithm |>\n<| a tags=haskell,algorithm\
    \ |>\nThis is not exactly what you asked for, but I thought I'd share the approach\
    \ I went with:\nI used the list function and passed it to show which gave me a\
    \ string in which the units were separated by \"+\". I then parsed it into an\
    \ Int using the reads function. I had to check the validity of the Int by adding\
    \ a guard to the main function.\n<code>\nmain :: IO()\nmain = do\n  n <- readLn\
    \ :: IO (Maybe Int)\n  case n of\n      Just n -> putStrLn ", "    \n    local\
    \ digit = math.trunc(a/b)*b\n    local remainder = a%b\n    \n    return digit+remainder",
  "  if a < 0 \n    else b == 0\n  else a < b \n  ? 0\n  else b % a == 0\n  ? b %\
    \ a \n  : multiply(a % b, a + b)\nend", "    if b == 0\n        0\n    else \n\
    \        10 * b + multiply(a/10, b%10)\nend\n</cell>\n<cell>\nmultiply(148, 412)\n\
    </cell>\n<cell>\nmultiply(19, 28)\n</cell>\n<cell>\nmultiply(2020, 1851)\n</cell>\n\
    <cell>\nmultiply(14, -15)\n</cell>\n<text>\nProblem 3\nWrite a function that takes\
    \ in a date and returns the number of the year that was that day. The input should\
    \ be a valid date in the form \"YYYY-MM-DD\".", "    if a==0 || b==0\n       \
    \ return 0;\n    else\n        return b*divide(a, b);\n    end\nend", "    if\
    \ a==0 || b==0\n        return 0\n    end\n    return (a*10*b)/((a%10)*10+b%10)\n\
    end\n</cell>\n<code language=julia-1.5>\n@testset \"Unit digits product\" begin\n\
    \    check(multiply(148, 412))  == 16\n    check(multiply(19, 28))    == 72\n\
    \    check(multiply(2020, 1851))  == 0\n    check(multiply(14, -15))    == 20\n\
    end\n</cell>\n<text>\nUnit digits multiply\nProblem #6: Unit digits multiply",
  "    | a < 0 || b < 0 = (error \"Negative arguments for multiply\")\n    | a ==\
    \ 0 || b == 0 = 0\n    | a == 1 = 0\n    | b == 1 = 0\n    | a > 0 && b > 0 =\
    \ a*b\n    | otherwise = (error \"Non-positive numbers for multiply\")\n    return\
    \ 0", "    if a * b == 0 \n        then return 0\n    else \n        multiply(b,\
    \ a%b) \nend\n\"\"\"\n    Complete the function which takes a non-negative integer\
    \ and returns the \n    sum of its unit digits.\n    Examples:\n    >>> sumDigits(148)\n\
    \    4\n    >>> sumDigits(19)\n    9\n    >>> sumDigits(2020)\n    10\n    >>>\
    \ sumDigits(1)\n    0\n    \"\"\"", "    if (b==0)\n        return 0\n    else\
    \ if (a==0)\n        return 1\n    else\n        return (a*b)/(b^(a-1))\n    end\n\
    end\n</cell>\n<text>\nTask\nThe function below computes the factorial of $n$.\
    \ Your function should take an $n$ integer as an input and return the factorial\
    \ of $n$. Do not use built-in functions, only basic operators (+, -, *, /).",
  "    if b == 0\n        return 0\n    if a > 0\n        return a*b\n    else\n \
    \       if a < 0\n            return -a * b\n        else\n            return\
    \ b\n</code>\n<|/ q dscore=0 |>\n<| c |>\nIt would help to post the complete error\
    \ messages. Also, you should indent your code properly.\n<|/ c |>\n<| c |>\nAlso,\
    \ I think your conditional statement is wrong. Why do you have `if a > 0 if a\
    \ < 0 else` and not just `if a > 0`?\n<|/ c |>\n<| a |>\nThe error message is\
    \ quite clear:\n<code>\njulia> multiply(148, 412)\nERROR: ArgumentError: invalid\
    \ argument for multiplication\n</code>\nYou pass it invalid arguments. In your\
    \ example, 148 and 412 are valid argument values, but this does not mean that\
    \ they are valid inputs to the function. \nThe problem is that you expect it to\
    \ be able to handle integer inputs that could have a fractional part, but you\
    \ are not doing that. The function you wrote is written to handle integer inputs,\
    \ and it is clearly not designed to handle them. There are other functions in\
    \ Base that do handle fractional inputs, but it isn't clear which one you should\
    \ be using. If you want to handle fractional arguments, you should use Base.approx\
    \ from Base instead of writing your own.\n<|/ a dscore=0 tags=julia |>\n<| c |>\n\
    I have used `Base.approx` and `Base.promote` but they don't seem to work. Could\
    \ you explain how to use `Base.approx` please?\n<|/ c |>\n<| c |>\nIt's not clear\
    \ what you are trying to do. What is `Base.approx` supposed to be doing? It's\
    \ not documented on the `Base` module. I think you are trying to write a function\
    \ that can handle arbitrary precision (i.e. `BigInt`), but I can't tell from your\
    \ example what you are trying to accomplish. Your code looks like you are trying\
    \ to do `Base.approx.(148, 412)`, but that will error if you pass it `BigInt`s.\
    \ If you are trying to accomplish the same thing that `Base.approx.` does, then\
    \ you are trying to reinvent the wheel. Just use `Base.approx.` instead.\n<|/\
    \ c |>\n<| c |>\nMy intention is to make a function that can handle arbitrary\
    \ precision numbers, for which I am using the `Base.approx` function. The problem\
    \ is that `Base.approx` does not seem to work with `BigInt`. Could you suggest\
    \ how to use `Base.approx` with a `BigInt`?\n<|/ c |>\n<| c |>\nSo you want to\
    \ handle arbitrary precision numbers, but your function only takes integers? That\
    \ makes no ", "    if b == 0 \n        0\n    else\n        divrem(b, 1, a, 1)\n\
    \    end\nend", "    local x = 1\n    for i in (a - 1..b) do \n        x = x*10\
    \ + (i%10)\n    end \n    return x\nend\n</code>\nThis code will work only with\
    \ a pair of digits, like your examples. \nFor a pair of letters, you can use this\
    \ code:\n<code>", "    a_rem = a % 10\n    b_rem = b % 10\n    mul = (a_rem *\
    \ b_rem)/10\n    if mul == 0\n        mul = a_rem * 10 + b_rem\n    end\n    return\
    \ mul\nend\n</cell>\n<text>\nProblem 8: Write a function is_prime() that takes\
    \ a natural number and \nreturns whether it is prime. Assume that all natural\
    \ numbers are \nvalid.\nExamples:\n>>> is_prime(14)\ntrue\n>>> is_prime(19)\n\
    false\n>>> is_prime(2020)\ntrue\n>>> is_prime(123)\nfalse\n>>> is_prime(-4)\n\
    false\n>>> is_prime(10000)\ntrue\n>>> is_prime(1000)\nfalse\n>>> is_prime(-100000000000000000000)\n\
    false\n>>> is_prime(100000000000000000000)\ntrue\n>>> is_prime(-1000000000000000000000)\n\
    false\n>>> is_prime(1000000000000000000000)\ntrue\n>>> is_prime(10000000000000000000001)\n\
    false\n\"\"\"", "    if a == 0 || b == 0 \n        return 0 \n    \n    remainder\
    \ = a % b \n    if remainder == 0 \n        return b \n    \n    return b + multiply(remainder,\
    \ b) \nend\n</code>\n<|/ a tags=julia |>\n<| a tags=julia |>\nHere is my approach\
    \ that uses an accumulator while walking through the digits. \nI implemented it\
    \ as a function where a is your first number and b is your second number to be\
    \ multiplied. \n<code>", "    if a == 0 || b == 0 \n        0 else \n        product\
    \ = a % 10 * b % 10 * multiply_digit(a/10, b/10) \nend", "    if a == 0 || b ==\
    \ 0 \n        0\n    else\n        (a * b) `div` 10\nend\n\"\"\"\n## ## ## ##\
    \ ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##\
    \ ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##\
    \ ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##\
    \ ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##\
    \ ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##\
    \ ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##\
    \ ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##\
    \ ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##\
    \ ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##\
    \ ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##\
    \ ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##\
    \ ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##\
    \ ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##\
    \ ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##\
    \ ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##\
    \ ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##\
    \ ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##\
    \ ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##\
    \ ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ", "    if a < 0 or b < 0\n   \
    \     return 0 \n    else: \n        return a * b\nend", "    if a < 0 && a>0\
    \ \n        return 0 \n    else if a < 0 \n        return a*-1\n    else if a\
    \ == 0 \n        return b*-1\n    else \n        return b*a \n    end\nend", " \
    \   if a == 0 || b == 0 \n        return 0 \n    if a < 0 \n        return multiply(abs(a),\
    \ abs(b)) \n    if b < 0 \n        return multiply(abs(a), abs(b)) \n    return\
    \ a * b\n\"\"\"", "    if b == 0 \n        return 0 \n    else \n        return\
    \ (a * b) \nend ", "    \n    digitsum = 0\n    for digit in digits(a)\n     \
    \   digitsum = digitsum * 10 ^ digit\n    end\n    for digit in digits(b)\n  \
    \      digitsum = digitsum * 10 ^ digit\n    end\n    return digitsum", "    #\
    \ Return the result of a*b\n    if (a < 0 || b < 0)\n        # Handle negative\
    \ numbers\n        if (a < 0)\n            # Handle negative numbers\n       \
    \     if (b < 0)\n                # Handle negative numbers\n                return\
    \ 0\n            else\n                return -multiply(a, -b)\n            end\n\
    \        else\n            # Handle negative numbers\n            return -multiply(a,\
    \ -b)\n        end\n    elseif (a >= 10)\n        # Handle larger numbers than\
    \ 10\n        if (b >= 10)\n            # Handle larger numbers than 10\n    \
    \        return multiply(a,b)\n        else\n            # Handle smaller numbers\
    \ than 10\n            if (a < 10)\n                return 0\n            else\n\
    \                return multiply(a, 10) - multiply(a, 9)*10\n            end\n\
    \        end\n    elseif (b >= 10)\n        # Handle larger numbers than 10\n\
    \        return multiply(a, b)\n    else\n        # Handle smaller numbers than\
    \ 10\n        if (a*b >= 10)\n            return multiply(a, 10)*10 + multiply(a,\
    \ 9)\n        else\n            return a*b\n        end\n    end\nend\n# Test\
    \ your code\nprintln(multiply(148, 412))\nprintln(multiply(19, 28))\nprintln(multiply(2020,\
    \ 1851))\nprintln(multiply(14, -15))\n</cell>\n<text>\nExercise 7\nComplete the\
    \ function below which takes in a positive integer as an argument, and returns\
    \ the sum of the unit digits of the input integer.\n    Examples:\n    >>> sum(412)\n\
    \    16\n    >>> sum(444)\n    6\n    >>> sum(100000)\n    9\n    >>> sum(99)\n\
    \    10\n    >>> sum(9999)\n    100\n    >>> sum(99999)\n    1000\n    >>> sum(99999999)\n\
    \    10000\n    >>> sum(999999999)\n    100000\n    >>> sum(999999999999)\n  \
    \  1000000\n    >>> sum(9999999999999)\n    1000000000\n    >>> sum(999999999999999)\n\
    \    10000000000\n    >>> sum(999999999999999999)\n    1000000000000\n    >>>\
    \ sum(99999999999999999999)\n    1000000000000000\n    >>> sum(99999999999998888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888",
  '    if a < 0 || b < 0 || b > a || a == 0 || b == 0 then 0 else if b == a then 1
    else (a % b) * pow(10, (a - b)/10)', "    if b == 0\n        0\n    elseif b <\
    \ 0\n        mod(-a, -b)\n    else\n        mod(a, b) \n    end\nend", "    local\
    \ c = a * b\n    if c > Int64(0) && c < Int64(1)\n        return c \n    end\n\
    \    return 0\nend\n</code>\n<|/ a |>\n<| c |>\nThis is great but I can't see\
    \ how you implement it for the function I was given.\n<|/ c |>\n<| c |>\nI've\
    \ updated the answer with an implementation for you. I hope this helps. Feel free\
    \ to ask any questions you have.\n<|/ c |>\n<| c |>\nThank you! It looks very\
    \ promising, but I'm getting an error when I try to execute `julia> using UnitDigits`\
    \ from the command line.\n<|/ c |>\n<| c |>\nI believe you need to `using UnitDigits`.\n\
    <|/ c |>\n<| c |>\nThe function `Multiply` does not take two integers. It takes\
    \ two `Int64` variables. I've added a solution for you which shows how to use\
    \ the `UnitDigits` package.\n<|/ c |>\n<| a tags=julia |>\nYou can use the function\
    \ UnitDigits to get the unit digits from an integer and then map the product over\
    \ them. \nFor example\n<code>\njulia> using UnitDigits", "    if a < 0 || b <\
    \ 0 \n        error(\"input arguments must be positive\")\n    elseif b == 0 \n\
    \        0\n    elseif a == 0 \n        1\n    else\n        (a * b) mod mod \n\
    \    end\nend", "    if a < 0 and b < 0 \n        return 0 \n    \n    unit1 =\
    \ (a % 10 % 10 % 10) * (b % 10 % 10 % 10)\n    unit2 = (a % 100 % 10) * (b % 10)\
    \ % 10\n    unit3 = (a % 100 % 100) * (b % 100) % 10\n    unit4 = (a % 100 % 100)\
    \ % 10 * b\n    \n    digit1 = (a % 10) * (b % 10)\n    digit2 = (a % 100) * (b\
    \ % 100)\n    digit3 = (a % 100) % b\n    digit4 = a * b\n    \n    if unit4 <\
    \ 0\n        return unit1 * (unit2 * unit3 + unit4)\n    else\n        return\
    \ unit1 * unit2 * unit3 * unit4\nend\n</cell>\n<cell>", "    if b == 0\n     \
    \   return 0\n    else if a == 0\n        return b\n    else\n        return (b\
    \ mod a) * a\nend\n</cell>\n<text>\nExercise 9\nWrite a function that takes a\
    \ single integer $a$ and returns the \nprime factors of $a$.", "    if a < 0 or\
    \ b < 0 \n        error(\"invalid arguments for multiply function\")\n    end\n\
    \    \n    return sum([a % 10, b % 10])\nend", "    if b == 0\n        return\
    \ a\n    elseif a == 0\n        return b\n    else\n        return a*b\n    end\n\
    end", "  if a < 0 \n    error('Not a positive number', errLevel = 1)\n  else if\
    \ a > 0 \n    error('Not a positive number', errLevel = 1)\n  else\n    return\
    \ 0\n  \n  if b < 0 \n    error('Not a positive number', errLevel = 1)\n  else\
    \ if b > 0 \n    error('Not a positive number', errLevel = 1)\n  else\n    return\
    \ 0", "    if (a==0 && b==0) \n        return 0 else \n    return (a * b) // div(b,10)\n\
    end\n</cell>\n<code language=julia-1.6>\n@time multiply(148, 412)\n</cell>\n<code\
    \ language=julia-1.6>\n@time multiply(19, 28)\n</cell>\n<code language=julia-1.6>\n\
    @time multiply(2020, 1851)\n</cell>\n<code language=julia-1.6>\n@time multiply(14,\
    \ -15)\n</cell>\n<text>\nExercise 2\nWrite a function that returns the sum of\
    \ all integers up to and including the one you pass in. ", "    if b < 0\n   \
    \     return a*0\n    else \n        if a == 0\n            return abs(b)\n  \
    \      if a < 0\n            if b > 0\n                return 0\n            else\n\
    \                return a*-1\n        elseif b == 0\n            return a\n  \
    \      \n        else if a < 0\n            if b > 0\n                return a*-1\n\
    \            else\n                return a*-1\n        end\n    end\nend\n\"\"\
    \"Print the results of the multiply function in a new line. \n\"\"\"\nprintln(multiply(148,\
    \ 412))\nprintln(multiply(19, 28))\nprintln(multiply(2020, 1851))\nprintln(multiply(14,\
    \ -15))\nprintln(multiply(-2, -3))", "    return a*b\nend", "    if a < 0 or b\
    \ < 0\n        error(\"Input cannot be negative.\")\n    elseif a==0 || b==0\n\
    \        return 0\n    elseif a==b\n        return a\n    else\n        unit =\
    \ a%10\n        product = b%10\n        if product == 0\n            return a\n\
    \        else\n            return a*10 + product\n        end\n    end\nend",
  "    if a < 0 or b < 0 then \n        return 0 \n    elseif b < a then \n      \
    \  a = abs(a)\n        b = abs(b)\n        return (a * b) // 10\n    elseif b\
    \ > a then \n        a = abs(a)\n        b = abs(b)\n        return (a * b) //\
    \ 10\n    else \n        a = abs(a)\n        b = abs(b)\n        return (a * b)\
    \ // 10\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThe first two conditions are\
    \ unnecessary because the else clause will never execute if you reach the else\
    \ condition. Also, it won't work because you aren't using absolute value correctly.\
    \ Your else condition would have to be: ```else \n        a = abs(a)\n       \
    \ b = abs(b)\n        return (a * b) // 10```\n<|/ c |>\n<| a |>\nA simple solution\
    \ using built-in functions without using recursion and without using if-elseif-else\
    \ conditions:\n<code>", "    if b == 0 \n        b \n    else\n        if a ==\
    \ 0 \n            0 \n        else\n            floor(100*(a/(b*10^floor(log10(b)))%10))\n\
    end", "    if a >= 0 && b >= 0 \n    else \n        throw(\"A negative number\
    \ or B negative number\")\n    end", "    if b == 0\n        return 0\n    elif\
    \ a < 0\n        return -1 * (multiply(abs(a), abs(b)))\n    else\n        return\
    \ (b - multiply(a/10, mod(a)))*10 + a%10\nend", "    # Add your code here\n  \
    \  return (a * b) // gcd(a, b)\nend", "    if a < 0 \n        error(\"Can't multiply\
    \ negative numbers\")\n    if b < 0 \n        error(\"Can't multiply negative\
    \ numbers\")\n    if a > 0 \n        error(\"Can't multiply negative numbers\"\
    )\n    if b > 0 \n        error(\"Can't multiply negative numbers\")\n    \n \
    \   let digits = a % 10\n    let remainder = a / 10\n    let remainder_digits\
    \ = remainder % 10\n    let remainder_remainder = remainder / 10", "    \n   \
    \ \n    \n    return 0", "    if a > 0 && b > 0 && a%b == 0 && a/b <= 10 && a/b\
    \ % 10 == 0 && a/b < 100 \n    then return a*b\n    else return 0\n    end\nend\n\
    </cell>\n<text>\nExercise\nWrite a function that returns the greatest common divisor\
    \ of a and b.", "    if a >= 0 & b >= 0 \n    then \n        return ((b mod 10)^(a-(b%10)))\n\
    \    else\n        return -1\n</code>\n}\n<|/ a dscore=0 |>\n<| a dscore=0 tags=haskell\
    \ |>\n<code>", "    if b == 0\n        0\n    elseif b == -1\n        -1\n   \
    \ elseif isunitdigit(b) && isunitdigit(a)\n        digittoint(b) * digittoint(a)\
    \ \n    else\n        error(\"Integer overflow in multiply\")\n    end\nend\n\
    </cell>\n<code language=julia-1.6>\n\"\"\"Complete the function that takes two\
    \ integer numbers and returns their \n    unit digits, in order.\n    Assume the\
    \ input is always valid.\n    Examples:\n    >>> unit_digits(183)\n    [3, 3,\
    \ 6]\n    >>> unit_digits(2020)\n    [4, 4, 1]\n    >>> unit_digits(2020)\n  \
    \  [4, 4, 1]\n    >>> unit_digits(-20)\n    [-5, -5, -3]\n    \"\"\"", "    if\
    \ a < 0 || b < 0\n        throw(Exception, \"Argument must be a non-negative number\"\
    )\n    elseif a == 0 || b == 0\n        throw(Exception, \"Argument must be a\
    \ non-zero number\")\n    else\n        mult_result = 1\n        a_digits = divrem(a,\
    \ 10, digits::Int64)\n        b_digits = divrem(b, 10, digits::Int64)\n      \
    \  for i = digits-1, -1, -1 do\n            mult_result = mult_result * a_digits[i]\
    \ + b_digits[i]\n        end\n        mult_result\n    end\nend", "    if b ==\
    \ 0\n        0\n    else\n        a = a % 10\n        b = b % 10\n        if b\
    \ < 0\n            b = b + 10\n            reverse(a, 1)\n            reverse(b,\
    \ 1)\n            a = a / 10\n            b = b / 10\n        end\n        digit\
    \ = mult_digits(a, b)\n        if digit > 0\n            a = a / 10\n        \
    \    b = b / 10\n            digit = mult_digits(a, b)\n        end\n        digit\
    \ = mult_digits(a, b)\n        if digit > 0\n            a = a / 10\n        \
    \    b = b / 10\n            digit = mult_digits(a, b)\n        end\n        digit\
    \ = mult_digits(a, b)\n        if digit > 0\n            a = a / 10\n        \
    \    b = b / 10\n            digit = mult_digits(a, b)\n        end\n        digit\
    \ = mult_digits(a, b)\n        if digit > 0\n            a = a / 10\n        \
    \    b = b / 10\n            digit = mult_digits(a, b)\n        end\n        digit\
    \ = mult_digits(a, b)\n        if digit > 0\n            a = a / 10\n        \
    \    b = b / 10\n            digit = mult_digits(a, b)\n        end\n        digit\
    \ = mult_digits(a, b)\n        if digit > 0\n            a = a / 10\n        \
    \    b = b / 10\n            digit = mult_digits(a, b)\n        end\n        digit\
    \ = mult_digits(a, b)\n        if digit > 0\n            a = a / 10\n        \
    \    b = b / 10\n            digit = mult_digits(a, b)\n        end\n        digit\
    \ = mult_digits(a, b)\n        if digit > 0\n            a = a / 10\n        \
    \    b = b / 10\n            digit = mult_digits(a, b)\n        end\n        digit\
    \ = mult_digits(a, b)\n        if digit > 0\n            a = a / 10\n        \
    \    b = b / 10\n            digit = mult_digits(a, b)\n        end\n        digit\
    \ = mult_digits(a, b)\n        if digit > 0\n            a = a / 10\n        \
    \    b = b / 10\n            digit = mult_digits(a, b)\n        end\n        digit\
    \ = mult_digits(a, b)\n        if digit > 0\n            a = a / 10\n        \
    \    b = b / 10\n            digit = mult_digits(a, b)\n        end\n        digit\
    \ = mult_digits(a, b)\n        if digit > 0\n            a = a / 10\n        \
    \    b = b / 10\n            digit = mult_digits(a, b)\n        end\n        digit\
    \ = mult_digits(a, b)\n        if digit > 0\n            a = a / 10\n        \
    \    b = b / 10\n            digit = mult_", "    if b == 0 \n        0\n    else\
    \ \n        if a == 0\n            else \n                multiply(a/10, b*10)\
    \ + a*b\n        end\nend", "    if b == 0\n        product = 0\n    else\n  \
    \      product = a % b\n    end\nend", "    product = 1 \n    \n    for i in a\
    \ \n        product = product * i\n    \n    for i in b \n        product = product\
    \ * i\n        \n    return product\n</code>\n<|/ q tags=julia,recursion,function\
    \ dscore=1 |>\n<| a tags=julia,recursion,function dscore=1 |>\nYour multiply function\
    \ could be simplified to:\n<code>", "    \"\"\"Complete the function that takes\
    \ two integers and returns \n    the product of their unit digits.\n    Assume\
    \ the input is always valid.\n    Examples:\n    >>> multiply(148, 412)\n    16\n\
    \    >>> multiply(19, 28)\n    72\n    >>> multiply(2020, 1851)\n    0\n    >>>\
    \ multiply(14, -15)\n    20\n    \"\"\"\n    a *= unit(b)\n    return a\nend\n\
    </cell>\n<text>\nNow let's test the function to see if it is correct:", "    if\
    \ b == 0\n        0\n    elseif b >= a # handle both b > a and b < a\n       \
    \ 1\n    else\n        (a * b) / divisor(b) # handle both b > a and a < b\n  \
    \  end\nend\n</cell>\n<code language=julia-1.3>", "    if a == 0 || b == 0\n \
    \   else if a == 1\n    then return b\n    else\n        multiply(b % 10, (a/10)\
    \ % 10)\n    end\nend\n\"\"\"\nWrite a function that, given an array of integers,\
    \ checks if the integers in \nthe array are evenly divisible.\nExamples\n>>> divisible_by_three([1,\
    \ 2, 1])\nTrue\n>>> divisible_by_three([2])\nFalse\n>>> divisible_by_three([3,\
    \ 4])\nTrue\n>>> divisible_by_three([5])\nFalse\n>>> divisible_by_three([6, 7])\n\
    True\n\"\"\"", "    if a < 0 || b < 0\n        return 0 \n    else \n        if\
    \ a == 0\n            return b\n        else\n            return b * 10 + multiply(a\
    \ div 10, b div 10) \n    end\nend\n</cell>\n<code language=julia-1.6>\nmultiply(148,\
    \ 412)\n</cell>\n<text>\nThe function above will take two integers and return\
    \ the product of their unit digits. There are three scenarios we could encounter:",
  "    if b == 0 || a == 0 \n        then 0\n    else\n        mult_str = [(a/10,\
    \ a/100), (a%10, a%100), (b/10, b/100), (b%10, b%100)]\n        mult_str.map{|x|\
    \ x[1] * x[2]}\n    end\nend", "    return a*b\nend", "    num = max(a, b) \n\
    \    if num == 0 \n        0\n    else \n        product = 1\n        power =\
    \ 0\n        while num > 0 \n            digit = num % 10 \n            product\
    \ *= digit\n            num /= 10\n            power += 1\n            if power\
    \ > 1 \n                return 0\n        product *= 10\n        while product\
    \ > 0 \n            digit = product % 10 \n            product /= 10\n       \
    \     if power > 1 \n                return 0\n            product *= digit\n\
    \            power -= 1\n        return product\n\"\"\"\nComplete the function\
    \ that takes a number as input and returns the \nsum of the unit digits of that\
    \ number.\nExamples:\n>>> add(148, 412)\n168\n>>> add(19, 28)\n57\n>>> add(2020,\
    \ 1851)\n5\n>>> add(14, -15)\n12\n\"\"\"", "    if a < 0 || b < 0 \n        throw\
    \ IllegalArgumentException(\"Integers are invalid\")\n    \n    var total = 1\n\
    \    for _ in 0..(b - a) \n        total *= (a + b)", "    if a < 0 \n       \
    \ error(\"a must be non-negative\")\n    else if a <= 0 \n        error(\"a must\
    \ be positive\")\n    else if b < 0 \n        error(\"b must be non-negative\"\
    )\n    else if b <= 0 \n        error(\"b must be positive\")\n    else\n    \
    \    return a*b\nend", "    if a == 0 || b == 0 \n    then 0 \n    elseif isUnit(a)\n\
    \    then a \n    elseif isUnit(b)\n    then b \n    else\n        if a > b \n\
    \        then multiply(a div 10, (a mod 10) *(b div 10))\n        else multiply(b\
    \ div 10, (a mod 10) *(b div 10))\n    end\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=0 |>\nThe algorithm is simple:\n<code>\nif b == 0:\n    return a\n\
    if a == 0:\n    return b", "    if b==0 return 0\n    if a==0 return 0\n    if\
    \ b<0 return 0\n    if a<0 return 0\n    if b==a return 0\n    if b==(a-1) then\
    \ return 0\n    if a==1 return a\n    if a==(b-1) then return 0\n    if a>1 then\
    \ return 0\n    if b>1 then return 0\n    if b==(a-1) then return 0\n    if b==(a-2)\
    \ then return 0\n    if a>2 then return 0\n    if b>2 then return 0\n    if b>=b\
    \ then return 0\n    if b==(a-2) then return 0\n    if b==(a-3) then return 0\n\
    \    if a>3 then return 0\n    if b>=(b+2) then return 0\n    if b==(a-3) then\
    \ return 0\n    if b==(a-4) then return 0\n    if a>4 then return 0\n    if b>=(b+3)\
    \ then return 0\n    if b==(a-4) then return 0\n    if b==(a-5) then return 0\n\
    \    if a>5 then return 0\n    if b>=(b+4) then return 0\n    if b==(a-5) then\
    \ return 0\n    if b==(a-6) then return 0\n    if a>6 then return 0\n    if b>=(b+5)\
    \ then return 0\n    if b==(a-6) then return 0\n    if b==(a-7) then return 0\n\
    \    if a>7 then return 0\n    if b>=(b+6) then return 0\n    if b==(a-7) then\
    \ return 0\n    if b==(a-8) then return 0\n    if a>8 then return 0\n    if b>=(b+7)\
    \ then return 0\n    if b==(a-8) then return 0\n    if b==(a-9) then return 0\n\
    \    if a>9 then return 0\n    if b>=(b+8) then return 0\n    if b==(a-9) then\
    \ return 0\n    if b==(a-10) then return 0\n    if a>10 then return 0\n    if\
    \ b>=(b+9) then return 0\n    if b==(a-10) then return 0\n    if b==(a-11) then\
    \ return 0\n    if a>11 then return 0\n    if b>=(b+10) then return 0\n    if\
    \ b==(a-11) then return 0\n    if b==(a-12) then return 0\n    if a>12 then return\
    \ 0\n    if b>=(b+11) then return 0\n    if b==(a-12) then return 0\n    if b==",
  "    if a < 0 || b < 0 \n        throw ValueError (Messages.IntegerFormatError)\
    \ \n    \n    if b == 0 \n        throw ZeroDivisionError ()\n    \n    if b >\
    \ 0 \n        return a * 10 * b\n    \n    if a > 0 \n        return a * pow(10,\
    \ -b)\n</code>\n<|/ q tags=big-o,math,performance,python,algorithm |>\n<| c |>\n\
    `if b > 0` can be written as `if not b` :)\n<|/ c |>\n<| c |>\n: I didn't know\
    \ that :)\n<|/ c |>\n<| c |>\n: No, that doesn't give a big enough improvement.\
    \ `a < 0` still needs to be tested for too, which costs two comparisons.\n<|/\
    \ c |>\n<| a |>\nThe key observation is that the number of digits in multiplication\
    \ is always less than or equal to half the power of 10 in its number.\nThis makes\
    \ the problem trivial: just return the multiplication of the unit digits, multiplied\
    \ by 10 and truncated to an integer.\n<code>\ndef multiply(a, b):\n    return\
    \ int(round(10 ** a * b))\n</code>\nThe first part of the proof can be derived\
    \ from the fact that the number of digits in multiplication of a number with 0\
    \ is exactly the number of digits in that number.  That is because the number\
    \ of digits in 0 is less than the number of digits in 0.  That means that the\
    \ number of digits in multiplication of a number with 0 is exactly the number\
    \ of digits in that number.\nThis leads to the following proof:\nAssume that we\
    \ have two integers k and m.  Let us assume that k = 10^m.  That means that m\
    \ = k / 10.  That means that m = 10^(k/10), or m is exactly the number of digits\
    \ in the number.  Therefore, k = k / 10^m.\nNow, we have (10^(k/10)) x m =\n(10^(m))\
    \ x 10^k =\n10^(k / 10) x 10^m =\n10^(m) / 10^k =\n10^(m) / 10^(m) =\n10^(m) /\
    \ 10^(m) =\n10^(m) / 10^(m) =\n10^(m) / 10^(m) =\n10^(m) / 10^(m) =\n10^(m) /\
    \ 10^(m) =\n10^(m) / 10^(m) =\n10^(m) / 10^(m) =\n10^(m) / 10^(m) =\n10^(m) /\
    \ 10^(m) =\n10^(m) / 10^(m) =\n10^(m) / 10^(m", "    if b < 0\n        error(\"\
    The second number cannot be less than 0\")\n    elseif b == 0\n        error(\"\
    The second number cannot be zero\")\n    elseif b == 1 && a > 0\n        a\n \
    \   else\n        a * b \nend", "    if a < 0 || b < 0\n    0 \n    elseif b ==\
    \ 0 \n    a\n    else \n        multiply(a / 10, b / 10)\n    end\nend\n</code>\n\
    <|/ q tags=julia,performance |>\n<| c |>\nI assume that `a` and `b` are always\
    \ non-negative, and that there won't be any exceptions. Also, please make your\
    \ function return an `Int64`; I assume it does for now, but it will certainly\
    \ be a problem in the future.\n<|/ c |>\n<| c |>\nGood points.  I've updated the\
    \ original post to reflect these comments.\n<|/ c |>\n<| c |>\nAs for what exceptions,\
    \ I don't think there will be any exceptions.  `a` and `b` should always be non-negative.\n\
    <|/ c |>\n<| c |>\nOK, now I'm confused. What exceptions would there be in a *valid*\
    \ `a` and `b`? Would you accept `a` = 0? And if `b` = 0 should it return 0?\n\
    <|/ c |>\n<| c |>\n, good question. I've updated the original post to reflect\
    \ this.\n<|/ c |>\n<| a dscore=3 tags=julia,performance |>\nThe main problem with\
    \ your solution is that you're recomputing the result every time the function\
    \ is called. In your case, this means recomputing a*b every time the function\
    \ is called. You can fix this by moving the call to multiply to outside your loops,\
    \ e.g.\n<code>", "    if b > 0\n       return a * (b - div(b, b - 1))\n    else\
    \ \n       return 0\nend", "    if b == 0 \n        return 0 \n    else if b <\
    \ 0 \n        return 0 \n    else\n        return (a * 10 * b / b).toInt64()\n\
    \    end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI don't think this answers\
    \ the question. Please don't post answers based on what you've already posted.\n\
    <|/ c |>\n<| c |>\nMy apologies, I didn't see the other answer posted before mine.\
    \  I apologize for the delay.\n<|/ c |>\n<| a dscore=0 |>\nI've been looking for\
    \ this answer for quite a while now. I know this is a very old question, but if\
    \ anybody else stumbles across it like I did, here is the answer:\n<code>\nimport\
    \ Numeric", '    if b == 0 then 0 else (a % 10) * (b / 10)', "    if a==0 or b==0\n\
    \        return 0 \n    \n    if a==1\n        return b\n    else\n        return\
    \ b * multiply((a - 1)/b, b)\nend", "    return if a > 0 \n        then b * 10\
    \ + a % 10\n        else b\n    end\nend\n</code>\n<|/ a tags=biginteger,julia\
    \ dscore=1 |>\n<| a |>\nA bit late, but here is another solution:\n<code>", " \
    \   if a < 0 || b < 0 \n        then return 0\n    else if a == 0 && b == 0 \n\
    \        then return 0\n    else if a == 0 || b == 0\n        then return 0\n\
    \    else \n        if a < b\n            then return 0\n        \n        else\
    \ if a == b\n            then return 0\n        else \n            if a < b &&\
    \ b < 10\n                then return 0\n            else if a < b && b >= 10\n\
    \                then return a * b\n            else if a >= b && b >= 10\n  \
    \              then return 0\n            else if a >= b && b < 10\n         \
    \       then return 0\n        end\n    end\nend\n</cell>\n<text>\nProblem 4\n\
    Write a function that converts degrees to radians \nand another to convert to\
    \ degrees.\nFor example:\n>>> convert(10)\n1.5707963267948966\n>>> convert(180)\n\
    3.141592653589793\n>>> convert(360)\n6.283185307179586\n</text>", "    \n    \
    \    if isZero(a)\n            return b\n        if isZero(b)\n            return\
    \ a\n        if isNegative(a) && isNegative(b)\n            \n            return\
    \ multiply(-a, -b)\n        else if isNegative(a)\n            return multiply(a,\
    \ -2)\n        else\n            return multiply(2, a)\nend", "    if a < 0 |\
    \ b < 0\n        return 0\n    elseif b == 0 | b == 1\n        return a\n    else\n\
    \        return (a * b) % 10\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @test multiply(148, 412) == 16\n@test multiply(19, 28) == 72\n@test multiply(2020,\
    \ 1851) == 0\n@test multiply(14, -15) == 20\n</cell>\n<text>\nExercise: Write\
    \ a function that takes two integers and returns their sum\n    in the unit digits.\
    \  If either input equals 1, then return 0.\n    Examples:\n    >>> add(14, 412)\n\
    \    16\n    >>> add(19, 1)\n    0\n    >>> add(2020, 1)\n    2020\n    >>> add(19,\
    \ 1)\n    0\n    \"\"\"", "  if a==0 && b==0\n    0 else a*b\n  else \n    multiply(a/10,\
    \ b%10)\nend\n</cell>\n<text>\nTask 2: Write the function factorial that takes\
    \ as input a positive integer and returns the factorial of that number. The function\
    \ should assume that the input is always valid. \nExamples:\n>>> factorial(7)\n\
    5040\n>>> factorial(9)\n362880\n>>> factorial(-10)\n0\n>>> factorial(0)\n1\n>>>\
    \ factorial(1)\n1\n\"\"\"", "    if a<0 || b<0 \n        error \"negative numbers\
    \ are invalid\" \n    end\n    if a==0 || b==0 \n        0\n    end\n    \n  \
    \  # initialize sum\n    sum =0\n    # find sum of digits of a\n    for i in a:divmod(10,\
    \ 10):sum+=i\n    # find sum of digits of b\n    for j in b:divmod(10, 10):sum+=j\n\
    \    return sum\nend\n</cell>\n<code language=julia-1.5>\nmult_test(14, -15) \
    \ # should be 20\n</cell>\n<code language=julia-1.5>\nmult_test(19281850, 20201855)\
    \  # should be 0\n</cell>\n<text>\nUnit digit of sum", "    if b==0 \n       \
    \ return a \n    else if b<0 \n        return multiply(-a, b) \n    else \n  \
    \      return multiply(a*10, b%10) \nend", "    if b == 0 \n        return 0 \n\
    \    if a < 0 \n        return 0 \n    if b < a \n        return 0 \n    \n  \
    \  prod = 1 \n    i = 1 \n    digit = a \n    while(i < b) \n        digit = digit*10\
    \ \n        i = i + 1 \n        if digit == 0 \n            break \n        prod\
    \ = prod * digit \n    return prod \nend", "  if b == 0 \n    0 \n  else \n  \
    \  return (a * b) \nend", "    if a < 0 || b < 0\n        return 0\n    else if\
    \ a == 0 || b == 0\n        return a * b\n    else if a == 0\n        return b\n\
    \    else if b == 0\n        return a\n    else\n        mul = int64(10 ** digits(a))\n\
    \        muli = int64(10 ** digits(b))\n        if mul * muli == int64(9) * int64(9)\n\
    \            return mul * muli\n        else\n            div = mul(mul, muli)\n\
    \            remainder = div - int64(9) * mul\n            if remainder == int64(0)\n\
    \                return div\n            else\n                return remainder\
    \ + int64(9) * mul\n        end\nend\n</cell>\n<code language=julia-1.5>\nmultiply(148,\
    \ 412)\n</cell>\n<text>\nThe last thing we need to do is determine how many digits\
    \ there are in a given integer. The function digits() can do this:", "    \n \
    \   local result = a * b\n    if result == 0 then \n        return 0\n    else\n\
    \        return result \n    end\nend", "    if b < 0\n        return 0\n    if\
    \ a < 0\n        return a * b\n    digits = floor(log10(a))\n    mult_digit =\
    \ floor(log10(b))\n    mult_digs = a * digits + mult_digit\n    if mult_digs >=\
    \ floor(log10(10^mult_digs))\n        return 0\n    return 10^mult_digs\nend\n\
    </cell>\n<code language=julia-1.0>\nmultiply(148, 412)\n</cell>\n<code language=julia-1.0>\n\
    multiply(19, 28)\n</cell>\n<code language=julia-1.0>\nmultiply(2020, 1851)\n</cell>\n\
    <code language=julia-1.0>\nmultiply(14, -15)\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"Complete the function that takes two integers and returns \nthe product\
    \ of their unit digits.\nAssume the input is always valid.\nExamples:\n>>> multiply(148,\
    \ 412)\n16\n>>> multiply(19, 28)\n72\n>>> multiply(2020, 1851)\n0\n>>> multiply(14,\
    \ -15)\n20\n\"\"\"", "    if b == 0\n        0\n    else\n        if a < 0\n \
    \           -1 * multiply(-a, -b)\n        else\n            if a > b\n      \
    \          multiply(-a, b)\n            else\n                if b == 1 && a ==\
    \ 0\n                    0\n                else\n                    if a >=\
    \ 1 && b >= 1\n                        a * b\n                    else\n     \
    \                   if a == 0\n                            b\n               \
    \         else\n                            a * 0\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@testset \"multiply\" begin\n    @test multiply(14, 15)\
    \ == 30\n    @test multiply(10, 1) == 10\n    @test multiply(19, 1) == 19\n  \
    \  @test multiply(12, 3) == 60\n    @test multiply(-14, 15) == -30\n    @test\
    \ multiply(-10, 1) == -10\n    @test multiply(-19, 1) == -19\n    @test multiply(-12,\
    \ 3) == -60\n    @test multiply(148, 412) == 16\n    @test multiply(19, 28) ==\
    \ 72\n    @test multiply(2020, 1851) == 0\n    @test multiply(14, -15) == 20\n\
    end\n</cell>\n<text>\nExercise 10\nRepeat the following exercises in the Julia\
    \ notebook:", "    if isZero(a) || isZero(b) || isZero(product(a,b)) \n      \
    \  return 0 \n    else \n        return product(a,b) \nend", "    if a < 0 or\
    \ b < 0 \n        throw(ArgumentError(\"Invalid arguments\"))\n    elseif b ==\
    \ 0 \n        return a\n    elseif b < 0 \n        throw(ArgumentError(\"Invalid\
    \ arguments\"))\n    elseif a == 0 \n        return 0\n    elseif b == 0 \n  \
    \      return a\n    elseif b == 1  \n        return a\n    elseif b == 2 \n \
    \       return a*2\n    elseif b == 3 \n        return a*3\n    elseif b == 4\
    \ \n        return a*4\n    elseif b == 5 \n        return a*5\n    elseif b ==\
    \ 6 \n        return a*6\n    elseif b == 7 \n        return a*7\n    elseif b\
    \ == 8 \n        return a*8\n    elseif b == 9 \n        return a*9\n    elseif\
    \ b == 10 \n        return a*10\n    elseif b == 11 \n        return a*11\n  \
    \  elseif b == 12 \n        return a*12\n    elseif b == 13 \n        return a*13\n\
    \    elseif b == 14 \n        return a*14\n    elseif b == 15 \n        return\
    \ a*15\n    elseif b == 16 \n        return a*16\n    elseif b == 17 \n      \
    \  return a*17\n    elseif b == 18 \n        return a*18\n    elseif b == 19 \n\
    \        return a*19\n    elseif b == 20 \n        return a*20\n    elseif b ==\
    \ 21 \n        return a*21\n    elseif b == 22 \n        return a*22\n    elseif\
    \ b == 23 \n        return a*23\n    elseif b == 24 \n        return a*24\n  \
    \  elseif b == 25 \n        return a*25\n    elseif b == 26 \n        return a*26\n\
    \    elseif b == 27 \n        return a*27\n    elseif b == 28 \n        return\
    \ a*28\n    elseif b == 29 \n        return a*29\n    elseif b == 30 \n      \
    \  return a*30\n    elseif b == 31 \n        return a*31\n    elseif b == 32 \n\
    \        return a*32\n    elseif b == 33 \n        return a*33\n    elseif b ==\
    \ 34 \n        return a*34\n    elseif b == 35 \n        return a*35\n    elseif\
    \ b == 36  \n        return a*36\n    elseif b == 37 \n        return a*37\n \
    \   elseif b == 38 \n        return a*38\n    elseif b == 39 \n        return\
    \ a*39\n    elseif b == 40 \n        return a*40\n    elseif b == 41 \n      \
    \  return a*41\n    elseif b == 42 \n        return a*42\n    elseif b == 43 \n\
    \        return a*43\n    elseif b == 44 \n        return a*44\n    elseif b ==\
    \ 45 \n        return a*45\n    elseif b == 46 \n        return a*46", "    #\
    \ convert input to Int or Int, if it's not an Int then throw\n    # an exception\n\
    \    let a = a :: Int64\n    let b = b :: Int64", "    if b == 0 \n        return\
    \ 0 \n    else \n        if a <= b \n            return mult_digits(b, a) \n \
    \       else \n            digit_sum(a) + digit_sum(b) % digit_sum(a) \n     \
    \   end \n    end \nend \n\"\"\"Complete the function that takes two integers\
    \ and returns \n    the sum of the unit digits of both inputs.\n    Assume the\
    \ input is always valid.\n    Examples:\n    >>> add(148, 412)\n    15\n    >>>\
    \ add(19, 28)\n    26\n    >>> add(2020, 1851)\n    7\n    >>> add(14, -15)\n\
    \    15\n    \"\"\"", "    if a < 0 || b < 0 \n        0\n    else \n        a\
    \ >= 0 ? a * b % 10 \n            : ((a - 1) * b + 10 * b) % 10\n        end\n\
    end\n</code>\nAnd you can try this out yourself:\n<code>\njulia> multiply(148,\
    \ 412)\n16\njulia> multiply(19, 28)\n72\njulia> multiply(2020, 1851)\n0\njulia>\
    \ multiply(14, -15)\n20\n</code>\nNow you can write the function to accept the\
    \ numbers in the format <integer> followed by optional white space and then  <integer>\
    \ like so:\n<code>", "    if a > 0 && b > 0 \n        \n    else if a == 0 ||\
    \ b == 0\n        \n    else\n        multiply(a%10, a//10)*(b%10) + multiply(b%10,\
    \ b//10)\n    \nend", "    return a * b\nend\n</cell>\n<code language=julia-1.0>\n\
    # TEST Complete the function that takes two integers and returns the product of\
    \ their unit digits (5th Case)\n@test multiply(148, 412) == 16\n@test multiply(19,\
    \ 28) == 72\n@test multiply(2020, 1851) == 0\n@test multiply(14, -15) == 20\n\
    </cell>\n<text>\n3.5 Validate Digits\nWrite a function that tests whether a given\
    \ integer is within a given range.", "    if b == 0 then return 0 \n    else \n\
    \        mul = a % 10 * b\n        return mul * multiply(mul, (b - mul / 10))\n\
    \    end\nend\n</cell>\n<code language=julia-0.6>\n# TEST Complete the function\
    \ that takes two integers and returns \n# the product of their unit digits (6a)\n\
    @test multiply(148, 412) == 16\n@test multiply(19, 28) == 72\n@test multiply(2020,\
    \ 1851) == 0\n@test multiply(14, -15) == 20\n</cell>\n<text>\nProblem 1b\nWrite\
    \ a function that returns true if the first number has an even number of unit\
    \ digits, and false otherwise. For example,", "    if b == 0 \n        return\
    \ a\n    else \n        return multiply(a*10, b%10)\nend", "    if (a > 0 && b\
    \ > 0) then\n        return a * b\n    else\n        return a * b\n    endif\n\
    endfunction\n</cell>\n<text>\nExercise 2\nThe module in exercise 1 contains a\
    \ function called getUnit which takes an integer and returns its unit digit. Write\
    \ a test for the getUnit function.\nThe getUnit function has a bug! If the input\
    \ value is too large, the program crashes!\nFix the getUnit function.", "    #\
    \ Your code here\n    \n    return a*b\nend", "    \"\"\"Takes two numbers and\
    \ returns the product of their unit digits.\"\"\"\n    return a * b\n</code>\n\
    This is where my confusion comes from. Because the function takes two numbers,\
    \ I assumed that they should be numerically converted to Int64. I've tried a few\
    \ ways below and they all give me the exact same error.\n<code>", "    if b <\
    \ 0\n        return -1\n    return a*b\nend\n</cell>\n<text>\nExercise 6: Define\
    \ a function get_sign() that takes one integer and returns the sign (-1 if negative,\
    \ 0 if zero, and 1 if positive).\nExamples:\n>>> get_sign(200)\n1\n>>> get_sign(-200)\n\
    -1\n>>> get_sign(200)\n-1\n>>> get_sign(400)\n0\n>>> get_sign(600)\n1\n>>> get_sign(700)\n\
    0\n>>> get_sign(-700)\n-1\n>>> get_sign(0)\n0\n>>> get_sign(600)\n-1\n>>> get_sign(700)\n\
    1", "    \n    return (a * b) % 10", "    if a == 0 || b == 0 \n        return\
    \ 0  \n    else \n        return a % 10 * b % 10 * multiply(a/10, b/10)\n    end\n\
    end", "    \"\"\"Compute the product of two integers\"\"\"\nif b == 0\n    return\
    \ 0\nelif b == 1\n    return a\nelse\n    return (a % 10) * (b % 10)\n    end\n\
    end", "    \"\"\"\n    multiply function \n    \n    Parameters\n    ----------\n\
    \    a : Int64\n        the first input number \n    b : Int64\n        the second\
    \ input number\n    \n    Returns\n    -------\n    product: Int64\n        the\
    \ product of two numbers\n    \n    Notes\n    -----\n    The function returns\
    \ 0 if either of the inputs is 0. \n    \"\"\"\n    if a is 0 or b is 0 \n   \
    \     return 0 \n    return (a * b) % 10 \n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Complete the function that takes two integers and returns \nthe difference\
    \ of their unit digits.\nAssume the input is always valid.\nExamples:\n    >>>\
    \ subtract(148, 412)\n    6\n    >>> subtract(19, 28)\n    3\n    >>> subtract(2020,\
    \ 1851)\n    153\n    >>> subtract(14, -15)\n    3\n\"\"\"", "    \n    c =  a\
    \ * b\n    return c\nend\n</cell>\n<code language=julia-1.5>\nx = multiply(20,\
    \ 10)\n</cell>\n<code language=julia-1.5>\ntypeof(x)\n</cell>\n<text>\nExercise\
    \ 5", "    if b == 0 \n        return 0 \n    else \n        return a*b/100\n\
    </code>\n<|/ a tags=math,mathematical-expressions,python,algorithm |>\n<| c |>\n\
    Welcome to Stack Overflow! Thanks for posting an answer to this question. Code-only\
    \ answers are discouraged on Stack Overflow because they don't explain how it\
    \ solves the problem. Please edit your answer to explain what this code does and\
    \ how it answers the question, so that it is useful for other users also as well\
    \ as the OP.\n<|/ c |>\n<| a tags=math,mathematical-expressions,python,algorithm\
    \ dscore=2 |>\nI think it is better to use a dictionary, where key is original\
    \ number and the value is new number.\n<code>\ndict = {\n    148:16,\n    19:\
    \ 72,\n    2020: 1851,\n}\n</code>\nThe code will be :\n<code>\nnew_number = {\n\
    \    148:16,\n    19: 72,\n    2020: 1851,\n}", "    \n    digit_1, digit_2, digit_3,\
    \ digit_4, digit_5, digit_6, digit_7, digit_8 = (\n        0, 0, 0, 0, 0, 0,\n\
    \        0, 0, 0, 0, 0, 0)\n    for digit in (a, b, a, b):\n        digit_1, digit_2,\
    \ digit_3, digit_4, digit_5, digit_6, digit_7, digit_8 = mult_helper(\n      \
    \      digit_1, digit_2, digit_3, digit_4, digit_5, digit_6, digit_7, digit_8,\
    \ digit)\n    return digit_1 * digit_2 * digit_3 * digit_4 * digit_5 * digit_6\
    \ * digit_7 * digit_8\nend", "    if b == 0\n        0\n    elseif a==0\n    \
    \    b\n    elseif b<0\n        a\n    else\n        ((b * a) % 10) - a + 9\n\
    end\n</cell>\n<code language=julia-1.5>\nmultiply(148, 412)\n</cell>\n<code language=julia-1.5>\n\
    multiply(19, 28)\n</cell>\n<code language=julia-1.5>\nmultiply(2020, 1851)\n</cell>\n\
    <code language=julia-1.5>\nmultiply(14, -15)\n</cell>\n<text>\nExercise 1.10\n\
    Write a function that returns the square root of a number.\nThe input number is\
    \ guaranteed to be a positive real number.", "\"\"\"\n    \n    if b > 0 \n  \
    \      then \n            if a > 0 \n                then \n                 \
    \   result <- multiplyDigits(a mod 10, (a - 10*a mod 10) mod 10)\n           \
    \         result <- multiplyDigits(b mod 10, (b - 10*b mod 10) mod 10)\n     \
    \               result <- multiplyDigits(result mod 10, (result - 10*result mod\
    \ 10) mod 10)\n                    result <- multiplyDigits(result mod 10, (result\
    \ - 10*result mod 10) mod 10)\n                else\n                    result\
    \ <- multiplyDigits(a mod 10, (b - 10*a mod 10) mod 10)\n                    result\
    \ <- multiplyDigits(result mod 10, (result - 10*result mod 10) mod 10)\n     \
    \               result <- multiplyDigits(result mod 10, (result - 10*result mod\
    \ 10) mod 10)\n            else\n                result <- multiplyDigits(a mod\
    \ 10, (b - 10*a mod 10) mod 10)\n                result <- multiplyDigits(result\
    \ mod 10, (result - 10*result mod 10) mod 10)\n                result <- multiplyDigits(result\
    \ mod 10, (result - 10*result mod 10) mod 10)\n        else\n            result\
    \ <- multiplyDigits(a mod 10, (b - 10*a mod 10) mod 10)\n            result <-\
    \ multiplyDigits(result mod 10, (result - 10*result mod 10) mod 10)\n        \
    \    result <- multiplyDigits(result mod 10, (result - 10*result mod 10) mod 10)\n\
    \        \n        \n        \n        \n        \n        \n        \n    elseif\
    \ b < 0 \n        then \n            if a > 0 \n                then \n      \
    \              result <- multiplyDigits(a mod 10, (a - 10*a mod 10) mod 10)\n\
    \                    result <- multiplyDigits(-(b mod 10), (b - 10*b mod 10) mod\
    \ 10)\n                    result <- multiplyDigits(result mod 10, (result - 10*result\
    \ mod 10) mod 10)\n                    result <- multiplyDigits(result mod 10,\
    \ (result - 10*result mod 10) mod 10)\n                else\n                \
    \    result <- multiplyDigits(a mod 10, (a - 10*a mod 10) mod 10)\n          \
    \          result <- multiplyDigits(result mod 10, (result - 10*result mod 10)\
    \ mod 10)\n                    result <- multiplyDigits(result mod 10, (result\
    \ - 10*result mod 10) mod 10)\n            else\n                result <- multiplyDigits(a\
    \ mod 10, (-(b - 10*a mod 10) mod 10), 10)\n                result <- multiplyDigits(result\
    \ mod 10, (result - 10*result mod 10) mod 10)\n                result <- multiplyDigits(result\
    \ mod 10, (result - ", "    if b == 0 \n        return 0 \n    return (a * b)\
    \ % 9 + 1 \nend ", "    if iszero(b) || iszero(a)\n        return 0 \n    end\n\
    \    sum::Int64 = 0\n    for i in (1 .. length(a))\n        digit::Int64 = a[i]\
    \ \xF7 b[i]\n        sum += digit\n    end\n    return sum\nend\n</cell>\n<code\
    \ language=julia-1.0>\n\"\"\"\nCalculate the product of the unit digits of two\
    \ integers \n(both valid positive integers) and return the remainder.\nAssume\
    \ the input is always valid.\nExamples:\n>>> multiply(148, 412)\n16\n>>> multiply(19,\
    \ 28)\n72\n>>> multiply(2020, 1851)\n0\n>>> multiply(14, -15)\n20\n\"\"\"", " \
    \   if b == 0 then return 0 else return a*b\n    return a * b\nend", "    \n \
    \   \"\"\"Complete the function that takes two integers and returns the \n   \
    \ product of their unit digits.\n    Assume the input is always valid.\n    Examples:\n\
    \    >>> multiply(148, 412)\n    16\n    >>> multiply(19, 28)\n    72\n    >>>\
    \ multiply(2020, 1851)\n    0\n    >>> multiply(14, -15)\n    20\n    \"\"\"\n\
    if b > a:\n    \n    \"\"\"Complete the function that takes two integers and returns\
    \ the \n    product of their unit digits.\n    Assume the input is always valid.\n\
    \    Examples:\n    >>> multiply(148, 412)\n    16\n    >>> multiply(19, 28)\n\
    \    72\n    >>> multiply(2020, 1851)\n    0\n    >>> multiply(14, -15)\n    20\n\
    \    \"\"\"", "    if b == 0 \n        0\n    elseif b == 0 \n        0\n    elseif\
    \ b < 0 \n        0 \n    else\n        (a * div(b)) \n    end\nend\n\"\"\"\n\
    \    \n## Return an Int64 integer that represents the sum of all its unit digits\
    \ \n## up to and including its integer digit.\n## Assume the input is always valid.\n\
    ## Examples:\n##\n## sum_digits(1234, 1) --> 4\n## sum_digits(1234, 2) --> 5\n\
    ## sum_digits(1234, 3) --> 6\n## sum_digits(1234, 4) --> 7\n\"\"\"", "    # your\
    \ code goes here\n    \nend\n</code>\nSolution 3\n<code>", "    return 0\n</code>\n\
    I am still getting a type error on the function \"multiply\"\nAny help will be\
    \ appreciated\n<|/ q |>\n<| c |>\nI recommend using the Scala REPL to play around\
    \ with code.  It has useful features like automatic conversion of types and automatic\
    \ printing of any exceptions so you can see what is happening.  Just hit `ctrl+D`\
    \ to get out of the REPL and it will print the type error (unless the REPL prints\
    \ a stack trace on exception it encountered).\n<|/ c |>\n<| c |>\nI did, I ran\
    \ the code and it says \"type mismatch\" on the return type\n<|/ c |>\n<| c |>\n\
    You're missing the `return` keyword on the line before.\n<|/ c |>\n<| c |>\nThanks,\
    \ fixed it\n<|/ c |>\n<| c |>\nDid you try to add `return` before `multiply(a*b,\
    \ a*b)` ?\n<|/ c |>\n<| a tags=haskell |>\nThe function multiply does not return\
    \ a value.  It just performs the calculation and then returns 0.  You could make\
    \ it return something by adding an explicit return keyword before the call to\
    \ multiply.\n<code>\nmultiply :: Int -> Int -> Int\nmultiply a b = product (abs\
    \ a) (abs b)\n        where product a b = if (a>0 && b>0) then (a*b) else 0\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThanks, it works, I added the type signature\
    \ and now it doesn't throw a type error. Can you explain why this works?\n<|/\
    \ c |>\n<| c |>\nHaskell is type inferred so you don't have to specify the type\
    \ yourself - you can leave it off and it will infer it for you.  In this case,\
    \ the `product (abs a) (abs b)` expression will have a type `Int -> Int -> Int`,\
    \ so when you do `where product a b = if (a>0 && b>0) then (a*b) else 0` the two\
    \ variables have the same type as well.  So, when you do `product a b` where a\
    \ and b are both `Int`s, `product a b` will be a `Int` too.\n<|/ c |>\n<| c |>\n\
    You don't need to explicitly write `Int` in `where product a b`, Haskell can infer\
    \ that `product (abs a) (abs b)` should return `Int`.\n<|/ c |>\n<| a tags=haskell\
    \ dscore=", "    if b == 0 then\n        return 0\n    elseif b < 0 then\n   \
    \     return a\n    else\n        return a*b\n    end\nend\n\"\"\"\n    \n   \
    \ \"\"\"", "    if a > 0 \n        then if b > 0 \n            then a / b\n  \
    \          else 0 \n        else if b < 0 \n            then abs(a) * -b\n   \
    \         else 0\n    else\n        if b < 0 \n            then abs(a) * b\n \
    \           else 0\n    end\nend\n\"\"\"\n    multiply_digits(digits::Array{Int64,1})::Int64\n\
    \    multiply_digits(digits)::Int64\n    multiply_digits(digits::Array{Int64,2})::Int64\n\
    \    multiply_digits(digits::Array{Int64,3})::Int64\n    multiply_digits(digits::Array{Int64,4})::Int64\n\
    \    multiply_digits(digits::Array{Int64,5})::Int64\n    multiply_digits(digits::Array{Int64,6})::Int64\n\
    \    multiply_digits(digits::Array{Int64,7})::Int64\n    multiply_digits(digits::Array{Int64,8})::Int64\n\
    \    multiply_digits(digits::Array{Int64,9})::Int64\n    multiply_digits(digits::Array{Int64,10})::Int64\n\
    \    multiply_digits(digits::Array{Int64,11})::Int64\n    multiply_digits(digits::Array{Int64,12})::Int64\n\
    \    multiply_digits(digits::Array{Int64,13})::Int64\n    multiply_digits(digits::Array{Int64,14})::Int64\n\
    \    multiply_digits(digits::Array{Int64,15})::Int64\n    multiply_digits(digits::Array{Int64,16})::Int64\n\
    \    multiply_digits(digits::Array{Int64,17})::Int64\n    multiply_digits(digits::Array{Int64,18})::Int64\n\
    \    multiply_digits(digits::Array{Int64,19})::Int64\n    multiply_digits(digits::Array{Int64,20})::Int64\n\
    \    multiply_digits(digits::Array{Int64,21})::Int64\n    multiply_digits(digits::Array{Int64,22})::Int64\n\
    \    multiply_digits(digits::Array{Int64,23})::Int64\n    multiply_digits(digits::Array{Int64,24})::Int64\n\
    \    multiply_digits(digits::Array{Int64,25}", "    if b == 0 \n        error(\"\
    The dividend is zero\")\n    \n    else \n        product = 1\n        \n    \
    \    factor = b\n        \n        while factor >= 10 \n            product *=\
    \ (a / factor)\n            factor /= 10\n        \n        product *= (a / factor)\n\
    \        return product\n    \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Complete the function that takes two integers and returns \n    the sum\
    \ of their unit digits.\n    Assume the input is always valid.\n    Examples:\n\
    \    >>> add(148, 412)\n    168\n    >>> add(19, 28)\n    72\n    >>> add(2020,\
    \ 1851)\n    2020\n    >>> add(14, -15)\n    20\n    \"\"\"", "    if a == 0 ||\
    \ b == 0 \n        0 \n    else \n        (a % 10 * b) / 10 \nend\n</code>\n<|/\
    \ a tags=julia |>\n<| a tags=julia |>\nI did something like this in python using\
    \ strings and eval. Maybe there is a julia equivalent of eval.\n<code>\ndef num_digits(num):\n\
    \    count = 0\n    while num > 0:\n        count += 1\n        num = num // 10\n\
    \    return count", "    if b == 0\n        0\n    else if a > b\n        multiply(b\
    \ - a, a)\n    else\n        multiply(a - b, b)\n    end\nend", "    if a > 0\
    \ && b > 0 \n        \n        # initialize output \n        c <- 0\n        #\
    \ loop while a is greater than 0 or b is greater than 0 \n        while a > 0\
    \ || b > 0 \n            \n            # update c \n            c <- c + (a %\
    \ 10) * b % 10 \n            \n            # update b \n            b <- b div\
    \ 10\n            # update a \n            a <- a div 10\n            \n     \
    \   # return output \n        c\n    else\n        0\n    end\nend\n</cell>\n\
    <text>\nExercise 5\nThe above code should now run. The function returns a valid\
    \ integer result for all the examples tested so far. Can you think of a situation\
    \ where the function would return a wrong result?", "  if iszero(a) == true &&\
    \ iszero(b) == true\n    zero\n  else\n    digitsum = sum(bigdigits(a))\n    if\
    \ digitsum == 0 && a >= 0 && b >= 0 \n      zero\n    elseif digitsum == 0 &&\
    \ a == b\n      zero\n    elseif digitsum == 0 && a < 0 && b >= 0 \n      abs(a)\n\
    \    elseif digitsum == 0 && a < 0 && b < 0\n      abs(a)\n    elseif digitsum\
    \ == 0 && a < 0 && b >= 0\n      abs(a)\n    elseif digitsum == 0 && a >= 0 &&\
    \ b < 0\n      abs(b)\n    elseif digitsum == 0 && a >= 0 && b >= 0\n      abs(b)\n\
    \    elseif digitsum < 0\n      multiply(abs(a), abs(b))\n    else\n      digitsum\
    \ + multiply(a, digitsum - bigdigits(b))\nend\n</code>\n<|/ a tags=julia,unit-testing\
    \ |>\n<| a dscore=0 |>\nHere's a naive approach that may be fast enough for your\
    \ needs:\n<code>", "    if a < 0 || b < 0 \n    then\n        error(\"The numbers\
    \ are not valid. Try again\")\n    else if a == 0 \n    then\n        return 0\n\
    \    elseif b == 0 \n    then\n        return 1\n    else \n        if a > b\n\
    \        then\n            a := b\n        end \n        d := 0\n        k :=\
    \ 0\n        i := 0\n        while i <= a\n        do\n            k := k + 1\n\
    \            d := d + k\n            i := i + k\n        end\n        d := d -\
    \ b\n        x := k / d\n        n := 0\n        while k != 0\n        do\n  \
    \          i := k / d\n            n := n + i * power(10, x - i)\n           \
    \ k := k - d\n        end\n        return n\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Complete the function that returns the product of the unit digits of a and\
    \ b\"\"\"", "    if b == 0 \n        0\n    else if b < 0 \n        0\n    else\
    \ \n        (a*b)%10\nend\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ computes the factorial of its input.\nWrite a function that computes the factorial\
    \ of a given number.\nUse these two functions to compute the factorial of 14.\n\
    What do you observe? Does it make sense?", "    if b < 0\n        throw(\"$b is\
    \ not a valid number\")\n    else if a < 0\n        throw(\"$a is not a valid\
    \ number\")\n    else if b == 0\n        return a\n    else\n        return a\
    \ / b\n    end\nend", "    if iszero(a) || iszero(b) \n        return 0 \n   \
    \ else \n        return (10 * (a - b)) \n    end\nend\n</code>\n<|/ a dscore=0\
    \ tags=julia |>\n<| a |>\nBased on 's answer (thanks!), the following solution\
    \ uses Julia's builtin function Base.prod:\n<code>", "    if a < 0\n        error(\"\
    Invalid number!\")\n    else if b < 0\n        error(\"Invalid number!\")\n  \
    \  else if a < b\n        return -multiply(a, -b)\n    end\n    return b * digit_sum(a)\
    \ - digit_sum(-b)\nend", "    if a == 0\n        1\n    else if a == -1\n    \
    \    0\n    else if a == -2\n        -1\n    else\n        multiply(a/10, a%10)\
    \ * multiply(b, b%10)\nend\n</cell>\n<code language=julia-1.0>", "    if a < b\n\
    \        multiply(b, a)\n    else\n        div(b, 10, a)\n    end", "    if b\
    \ < 0\n        error(\"Negative numbers are not supported.\")\n    elseif b ==\
    \ 0\n        return a\n    elseif b == 1\n        return 1\n    else\n       \
    \ return a*b\nend", "    if b == 0 \n        0 \n    else\n        a = 10*a \n\
    \        b = 10*b \n        digits = [a | b | a..b] \n        remainder = a %\
    \ b \n        product = multiply_digits(digits) \n        product *= 10^(remainder)\
    \ \n        return product \n    end\n    return 0\nend\n\"\"\"\nCalculate the\
    \ product of two integers\n\"\"\"", "    if a > 0 \n        and (a < 1000000)\
    \ && (b > 0) \n        && (b < 1000000) \n        && ((b < a || b - a) == 0) \n\
    \        && ((b < a || b - a) == 0) \n        && ((b < a) || (b - a) == 0) \n\
    \        && ((b < a) || (b - a) == 0) \n        && ((b < a) || (b - a) == 0) \n\
    \        && ((b < a) || (b - a) == 0) \n        && ((b < a) || (b - a) == 0) \n\
    \        && ((b < a) || (b - a) == 0) \n        && ((b < a) || (b - a) == 0) \n\
    \        && ((b < a) || (b - a) == 0) \n        && ((b < a) || (b - a) == 0) \n\
    \        && ((b < a) || (b - a) == 0) \n        && ((b < a) || (b - a) == 0) \n\
    \        && ((b < a) || (b - a) == 0) \n        && ((b < a) || (b - a) == 0) \n\
    \        && ((b < a) || (b - a) == 0) \n        && ((b < a) || (b - a) == 0) \n\
    \        && ((b < a) || (b - a) == 0) \n        && ((b < a) || (b - a) == 0) \n\
    \        && ((b < a) || (b - a) == 0) \n        && ((b < a) || (b - a) == 0) \n\
    \        && ((b < a) || (b - a) == 0) \n        && ((b < a) || (b - a) == 0) \n\
    \        && ((b < a) || (b - a) == 0) \n        && ((b < a) || (b - a) == 0) \n\
    \        && ((b < a) || (b - a) == 0) \n        && ((b < a) || (b - a) == 0) \n\
    \        && ((b < a) || (b - a) == 0) \n        && ((b < a) || (b - a) == 0) \n\
    \        && ((b < a) || (b - a) == 0) \n        && ((b < a) || (b - a) == 0) \n\
    \        && ((b < a) || (b - a) == 0) \n        && ((b < a) || (b - a) == 0) \n\
    \        && ((b < a) || (b - a) == 0) \n        && ((b < a) || (b - a) == 0) \n\
    \        && ((b < a) || (b - a) == 0) \n        && ((b < a) || (b - a) == 0) \n\
    \        && ((b < a) || (b - a) == 0) \n        && ((b < a) || (b - a) == 0) \n\
    \        && ((b < a) || (b - a) == 0) \n        && ((b < a) || (b - a) == 0) \n\
    \        && ((b < a) || (b - a) == 0) \n        && ((b < a) || (b - a) == 0) \n\
    \        && ((b < a) || (b - a) == 0) \n        && ((b < a) || (b - a) == 0) \n\
    \        && ((b < a) || (b - a) == 0) \n        && ((b < a) || (b - a) == 0) \n\
    \        && ((b < a) || (b - a) == 0) \n        && ((b < a) || (b - a) == ", " \
    \   if b == 0 \n        0\n    else\n        if a < 0 \n            0\n      \
    \  else\n            convert(Int64, a) * convert(Int64, b)\n        end\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"Complete the function that takes\
    \ two integers and returns \n    the difference between them.\n    Assume the\
    \ input is always valid.\n    Examples:\n    >>> subtract(148, 412)\n    15\n\
    \    >>> subtract(19, 28)\n    23\n    >>> subtract(2020, 1851)\n    -1\n    >>>\
    \ subtract(14, -15)\n    15\n    \"\"\"", "    | a == 0 && b == 0 || b == 0 &&\
    \ a == 0 => 0\n    | a == 0 && b == 0 => a * b\n    | a > 0 && b == 0 => 0\n \
    \   | a < 0 && b == 0 => 0\n    | a < 0 && b > 0 => 0\n    | a < 0 && b < 0 =>\
    \ multiply(a/abs(a), abs(b))*abs(b)\n    | a < 0 && b > 0 => multiply(abs(a),\
    \ abs(b))\n    | a > 0 && b > 0 => multiply(abs(a), abs(b))\n    | a > 0 && b\
    \ < 0 => multiply(abs(a), abs(b))\n    | a > 0 && b == 0 => a * b\n    | a < 0\
    \ && b == 0 => a * b\n    | a > 0 && b > 0 => a * b\n    | a < 0 && b > 0 => a\
    \ * b\n    | a > 0 && b < 0 => a * b\n    | a < 0 && b < 0 => a * b\n    | a >\
    \ 0 && b == 0 && b < 0 => 0\n    | a > 0 && b == 0 && b > 0 => 0\n    | a < 0\
    \ && b == 0 && b > 0 => 0\n    | a < 0 && b == 0 && b < 0 => 0\n    | a > 0 &&\
    \ b > 0 && b < 0 => 0\n    | a > 0 && b > 0 && b > 0 => a * b\n    | a < 0 &&\
    \ b > 0 && b < 0 => a * b\n    | a < 0 && b > 0 && b > 0 => a * b\n    | a > 0\
    \ && b < 0 && b > 0 => 0\n    | a > 0 && b < 0 && b < 0 => 0\n    | a < 0 && b\
    \ < 0 && b > 0 => 0\n    | a < 0 && b < 0 && b < 0 => 0\n    | a == 0 && b > 0\
    \ => 0\n    | a == 0 && b < 0 => 0\n    | a > 0 && b > 0 => 0\n    | a > 0 &&\
    \ b < 0 => 0\n    | a < 0 && b > 0 => 0\n    | a < 0 && b < 0 => 0\n    | a >\
    \ 0 && b == 0 && b < 0 => 0\n    | a > 0 && b == 0 && b > 0 => 0\n    | a < 0\
    \ && b == 0 && b > 0 => 0\n    | a < 0 && b == 0 && b < 0 => 0\n    | a > 0 &&\
    \ b > 0 && b < 0 => 0\n    | a > 0 && b > 0 && b > 0 => 0\n    | a < 0 && b >\
    \ 0 && b < 0 => 0\n    | a < 0 && b > 0 && b > 0 => 0\n    | a > 0 && b < 0 && ",
  "    if b == 0\n        return a\n    \n    else if a == 0\n        return 0\n \
    \   \n    else\n        mult_digit = a%10 * b / 10\n        return (multiply(mult_digit,\
    \ b-1))", "    if b == 0 then return 0\n    else if b > 0 then \n        if a\
    \ >= 1000 then\n            digits = a - 999\n            product = digits*b\n\
    \            result <- multiply(digits, product)\n            if result >= 1000\
    \ then return result - 1000\n            else return result\n        else if a%10\
    \ % 10 == 0 then\n            digits = a % 10\n            product = digits*b\n\
    \            result <- multiply(digits, product)\n            return result\n\
    \        else if a%10 >= 1 then\n            digits = a%10\n            product\
    \ = digits*b\n            result <- multiply(digits, product)\n            return\
    \ result\n        else return 0\n    else \n        if a <= -999 then\n      \
    \      digits = -999 - a\n            product = digits*b\n            result <-\
    \ multiply(digits, product)\n            if result <= -999 then return result\
    \ - -999\n            else return result\n        else if a%10 >= 1 then\n   \
    \         digits = a%10\n            product = digits*b\n            result <-\
    \ multiply(digits, product)\n            return result\n        else return 0",
  "    local res::Int64\n    local mul\n    mul = math.floor(math.log10(b))\n    if\
    \ mul > math.floor(math.log10(a))\n        res = a % 10 * pow(10, mul)\n    else\n\
    \        res = a % 10 * pow(10, mul)\n    end\n    return res\nend\n\"\"\"\n \
    \   Write a function that takes a string and returns True if the string is \n\
    \    a palindrome and False otherwise.\n    Examples:\n    >>> palindrome(\"abba\"\
    )\n    True\n    >>> palindrome(\"koko\")\n    False\n    \"\"\"", "    if a ==\
    \ 0 || b == 0\n        return 0  \n    else \n        mult := 0\n        digit1\
    \ := a % 10 \n        digit2 := b % 10\n        if digit1 > digit2\n         \
    \   mult := 10 * mult + digit1\n        else\n            mult := 10 * mult +\
    \ digit2\n        \n        digit3 := a // 10\n        digit4 := b // 10\n   \
    \     if digit3 > digit4\n            mult := 10 * mult + digit3\n        else\n\
    \            mult := 10 * mult + digit4\n        return mult \nend\n</code>\n\
    <|/ a tags=algorithm,math,performance,mathematical-optimization,big-o |>\n<| c\
    \ |>\nI believe the question is asking to do `O(n)`, not `O(1)`.\n<|/ c |>\n<|\
    \ c |>\nI believe this is O(n) but not O(1).\n<|/ c |>\n<| c |>\nI agree with\
    \ you, I missed a 0 in my code (before or after the loop) which I fixed. However\
    \ I believe this is still O(n) because I added a O(log n) loop :)\n<|/ c |>\n\
    <| c |>\nThe complexity of the above code is still O(n).\n<|/ c |>\n<| c |>\n\
    No, it's O(n+m) where m is the log n of the second number. Where is the log n\
    \ of the second number?\n<|/ c |>\n<| a dscore=0 |>\nThe most important thing\
    \ for me is that it is the largest O(n), not O(1).", "    \"\"\"Calculate the\
    \ product of the unit digits of a and b.\"\"\"\n    return sum(x*y for x, y in\
    \ zip(a//10*10, b//10*10)) \nend ", "\"\"\"\n\"\"\"\n    Unit test for the add\
    \ function.\n    \"\"\"\n    assert(add(a) == add(b, a))\n    assert(add(a, b)\
    \ == add(b, a))", "    if b == 0\n        return a\n    return multiply(a % 10\
    \ * b, (b / 10))", "    if b==0\n        return 0\n    else\n        a = a*10\n\
    \        b = b*10\n        c= a%10\n        d = b%10\n        result = c*10 +\
    \ d\n        return result\n    end\nend\n</cell>\n<text>\nProblem 4\nWrite a\
    \ function that returns the sum of their squares. \nAgain assume the input is\
    \ valid. \nExamples:\n>>> sumsquares(148)\n522\n>>> sumsquares(19)\n18\n>>> sumsquares(2020)\n\
    0\n>>> sumsquares(10)\n0\n>>> sumsquares(-15)\n20\n>>> sumsquares(10)\n0\n\"\"\
    \"", "    if isunitdigit(b) and isunitdigit(a):\n        if isunitdigit(b):\n\
    \            return mul(a, b, mulunitdigit(b),mulunitdigit(a))\n        elif isunitdigit(a):\n\
    \            return mul(a, b, mulunitdigit(a),mulunitdigit(b))\n        else:\n\
    \            return mul(a, b)\n    error(\"invalid input digits\")\nend", "  \
    \  if a < 0 || b < 0\n        error(\"The number should be non-negative\")\n \
    \   else\n        if b == 0 \n            error(\"The number should divide first\"\
    )\n        else\n            if a == 0\n                error(\"The number should\
    \ divide first\")\n            else\n                return (a * b) % 10\n   \
    \ end\nend\n</cell>\n<code language=julia-1.0>\n@assert multiply(148, 412) ==\
    \ 16\n@assert multiply(19, 28) == 72\n@assert multiply(2020, 1851) == 0\n@assert\
    \ multiply(14, -15) == 20\n</cell>\n<code language=julia-1.0>", "    if a < 0\
    \ or b < 0\n        return 0\n    \n    return b * digits(a)\nend\n</cell>\n<text>\n\
    Problem 3b (20 Points)\nWrite a function called digits(a) which takes an integer\
    \ a\nand returns an array containing the units digits of the number a \nin ascending\
    \ order.\nExamples:\n>>> digits(3)\n[3, 1, 2]\n>>> digits(12)\n[12, 1, 2, 1, 0]\n\
    >>> digits(180)\n[18, 0, 0, 1, 2, 0]\n>>> digits(148)\n[14, 8, 4, 2, 0]\n>>> digits(2020)\n\
    [20, 0, 0, 2, 0]\n>>> digits(-14)\n[18, 0, 0, 1, 2, 0]\n>>> digits(0)\n[0]\n>>>\
    \ digits(19)\n[19]\n>>> digits(-3)\n[3, 1, 2]\n>>> digits(-6)\n[6, 3, 2]\n>>>\
    \ digits(-4)\n[4, 3]\n>>> digits(-9999)\n[9, 9, 9, 9]\n>>> digits(-9999)\n[9,\
    \ 9, 9, 9]\n\"\"\"", "    if (a==0) or (b==0) \n        return 0 \n    else\n\
    \        return (a%10*(b%10))%10\n    end\nend\n</code>\n<|/ a tags=julia,math,bigint\
    \ dscore=2 |>\n<| a |>\nThis is an old question, but since it is getting a lot\
    \ of views, I thought I'd post my solution here.\nFirst, a few quick functions\
    \ to convert a bigint to a string\n<code>", "    sum = a % b\n    carry = a -\
    \ b\n    if carry > 0 {\n        sum = c*10 + sum\n        carry = carry%10\n\
    \    }\n    \n    return sum + carry\nend\n</cell>\n<code language=julia-1.6>\n\
    @assert multiply(148, 412) == 16\n@assert multiply(19, 28) == 72\n@assert multiply(2020,\
    \ 1851) == 0 \n@assert multiply(14, -15) == 20\n</cell>\n<text>\nQuestion: can\
    \ you figure out a way to multiply a negative number? Can you multiply a negative\
    \ number by any positive number?", "    if a > b\n        a, b = b, a\n    \n\
    \    ones = zeros(Int64, 1)\n    tens = zeros(Int64, 10)\n    if b == 0\n    \
    \    return 0\n    elseif b > 0\n        ones\n    elseif b < 0\n        tens\n\
    \    end\n    \n    for i in 1:b\n        if a[i] == 0\n            continue\n\
    \        end\n        \n        if b > 0\n            ones[i] += (a[i]*10)\n \
    \           tens += a[i]\n        elseif b < 0\n            tens[i] += (a[i]*10)\n\
    \            ones += a[i]\n        end\n    end\n    \n    return ones + tens\n\
    end", "    if b == 0\n        0\n    else\n        a * b\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=julia,functional-programming |>\nFor those who are working in\
    \ Julia, and would like to do some \"math-like\" operations with the input arguments,\
    \ one may use the following solution, where the function fct is some operation\
    \ to be applied to the inputs:\n<code>\nfct = (x,y)->x+y", "    # Your code here\n\
    \    \n    return 0\nend\n</cell>\n<text>\nSolution", "    if b < 0 || b > 9 ||\
    \ b < a then \n        return 0\n    else \n        return a * b\nend", "    if\
    \ b < 0\n        error(\"Invalid input: b should be non-negative\")\n    elseif\
    \ b == 0\n        return 0\n    else\n        digits = digits_of(a) * digits_of(b)\n\
    \        total = digits_of(a) * (digits_of(b) - digits_of(a))\n        if total\
    \ % 2 == 1\n            total -= 1\n            digits -= 1\n        return total\
    \ * digits\n    end\nend\n</code>\nThe functions digits_of() and error() are defined\
    \ as follows:\n<code>", "    \"\"\"Complete the function that takes two integers\
    \ and returns \n    the product of their unit digits.\n    Assume the input is\
    \ always valid.\n    Examples:\n    >>> multiply(148, 412)\n    16\n    >>> multiply(19,\
    \ 28)\n    72\n    >>> multiply(2020, 1851)\n    0\n    >>> multiply(14, -15)\n\
    \    20\n    \"\"\"", "\"\"\"\n    Return the product of their unit digits, assuming\
    \ the input is valid. \n    Examples:\n    >>> multiply(148, 412)\n    16\n  \
    \  >>> multiply(19, 28)\n    72\n    >>> multiply(2020, 1851)\n    0\n    >>>\
    \ multiply(14, -15)\n    20\n    \"\"\"\n    digits = a%10*10 + b%10\n    digits_product\
    \ = digits*(digits+1)/10\n    return digits_product", "    if b == 0 || b < 0\n\
    \        return 0\n    \n    \n    if a < 0\n        return -multiply(abs(a),\
    \ b)\n    \n    if b == 0\n        return 1\n    \n    return 10 ** ceil(log10(b))\
    \ * (a % 10) * multiply(a / 10, b % 10)\nend", "    if a > 0 && b > 0\n      \
    \  return (a * b) // 10\n    else\n        return a\n    end\nend", "    | a >\
    \ b = b\n    | otherwise = if a > 0 && b > 0 then a * b else 0\n    end\n    return\
    \ multiply(b, a)\nend\n</cell>\n<code language=julia-1.5>\n@assert multiply(4,\
    \ 10) == 40\n@assert multiply(4, -4) == 16\n@assert multiply(4, 0) == 0\n@assert\
    \ multiply(4, -10) == 10\n@assert multiply(4, 20) == 60\n@assert multiply(4, -4000)\
    \ == -40\n</cell>\n<text>\nProblem 3\nLet us define a new function called divisibleby2\
    \ that takes a single integer number as input and returns the sum of the two digits\
    \ of this number that are divisible by 2.\nFor example:\n>>> divisibleby2(14)\n\
    4\n>>> divisibleby2(12)\n1\n>>> divisibleby2(2)\n0\n>>> divisibleby2(5)\n0\n>>>\
    \ divisibleby2(15)\n1\n>>> divisibleby2(16)\n0\n>>> divisibleby2(-13)\n-1\n>>>\
    \ divisibleby2(-20)\n-2\n>>> divisibleby2(-5)\n-2\n>>> divisibleby2(4)\n0\n>>>\
    \ divisibleby2(-9)\n-2\n>>> divisibleby2(20)\n0\n>>> divisibleby2(100)\n2\n>>>\
    \ divisibleby2(10)\n0\n>>> divisibleby2(-4)\n-2\n>>> divisibleby2(10)\n0\n>>>\
    \ divisibleby2(-100)\n-2\n>>> divisibleby2(0)\n0\n>>> divisibleby2(10)\n0", " \
    \   \"\"\"Complete the function that takes two integers and returns \n    the\
    \ product of their unit digits.\"\"\"\n    return (b/a%10)*(a/b)%10\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis is amazing! Thank you!\n<|/ c |>\n<| c |>\nHi\
    \ there, I have another question regarding your code. I've noticed that if you\
    \ try and multiply \"14\" and \"412\" the result will be 0. Is there any way to\
    \ fix this? I wanted to make sure that the product of one unit digit and another\
    \ was valid.\n<|/ c |>\n<| c |>\nI've fixed this by removing the '%' sign from\
    \ the second line. Thanks for the help!\n<|/ c |>\n<| a tags=python,integer,python-3.x,type-conversion\
    \ dscore=0 |>\nThe problem is you are multiplying numbers to get a product that\
    \ is not a whole number. Just replace / with // like this:\n<code>\ndef multiply(a::Int64,\
    \ b::Int64)::Int64 \n\"\"\"Complete the function that takes two integers and returns\
    \ \nthe product of their unit digits.\"\"\"\nreturn (b//a%10)*(a//b)%10\n</code>\n\
    <|/ a |>\n<| c |>\nHi there, I have another question regarding your code. I've\
    \ noticed that if you try and multiply \"14\" and \"412\" the result will be 0.\
    \ Is there any way to fix this? I wanted to make sure that the product of one\
    \ unit digit and another was valid.\n<|/ c |>\n<| c |>\n, I don't see why it would.\
    \ Did you even try it? It's just dividing numbers before multiplying, so the result\
    \ should be some positive number.\n<|/ c |>\n<| c |>\nNo I didn't! My apologies!\n\
    <|/ c |>\n<| a |>\n<code>\ndef multiply(a::Int64, b::Int64)::Int64 \n    \"\"\"\
    Complete the function that takes two integers and returns \n    the product of\
    \ their unit digits.\"\"\"\n    return (b//a%10)*(a//b)%10\n</code>\n<|/ a tags=python,integer,python-3.x,type-conversion\
    \ dscore=0 |>\n<| c |>\nHi there, I have another question regarding your code.\
    \ I've noticed that if you try and multiply \"14\" and \"412\" the result will\
    \ be 0. Is there any way to fix this? I wanted to make sure that the product of\
    \ one unit digit and another was valid.\n<|/ c |>\n<| a |>\nI did try the other\
    \ solutions above and they seemed fine, but I ", "    if b == 0 \n        0\n\
    \    else \n        a / b * power(10, floor(log10(b) / floor(log10(a))) - 1) +\
    \ multiply(a, b - floor(b / a))\nend\n</cell>\n<text>\nExercise 3", "    local\
    \ result\n    \n    if a<0 or b<0 then\n       result=0\n    elseif a==0 then\n\
    \       result = b\n    elseif b==0 then\n       result = a\n    else\n      \
    \ result = (a * b)%10\n    end\n    return result\nend", "    if a < 0 || b <\
    \ 0\n        error(\"Cannot multiply negative numbers.\")\n    elseif a == 0 ||\
    \ b == 0\n        0\n    elseif b < 0\n        error(\"Cannot multiply a negative\
    \ number to a positive number.\")\n    else\n        a * b\n    end\nend\n</cell>\n\
    <code language=julia-0.6>\nmultiply(148, 412)\n</cell>\n<code language=julia-0.6>\n\
    multiply(19, 28)\n</cell>\n<code language=julia-0.6>\nmultiply(2020, 1851)\n</cell>\n\
    <code language=julia-0.6>\nmultiply(14, -15)\n</cell>\n<code language=julia-0.6>\n\
    \"\"\"Given a number `input`, return the first two units of that number.\nExample:\n\
    >>> first_two(51)\n(50, 5)\n>>> first_two(156)\n(150, 6)\n>>> first_two(-102)\n\
    (-100, 2)\n>>> first_two(-19)\n(-10, 0)\n\"\"\"", "    if b == 0 \n        0\n\
    \    else \n        a * b\n    \n    \n\"\"\"Complete the function that takes\
    \ two integers and returns \n    the sum of the first N unit digits. Assume the\
    \ input is always valid.\n    Examples:\n    >>> sum(148, 412)\n    168\n    >>>\
    \ sum(19, 28)\n    72\n    >>> sum(2020, 1851)\n    1854\n    >>> sum(14, -15)\n\
    \    20\n    \"\"\"", "    return div(a, b) * b\nend", "    if b < 0\n       \
    \ error(\"Second argument should be non-negative\")\n    \n    if a == 0\n   \
    \     return 0\n    \n    let product = zeros(a)\n    for i in 0..a - 1\n    \
    \    product[i] = product[i] + b % 10\n        b = b % 10\n    \n    product[a]\
    \ = b\n    return product\nend\n</cell>\n<cell>\nusing Plots\ngr()", "  if b ==\
    \ 0 \n    0 else a * b \n  else \n    return multiply(a/10, b/10)\nend\n</cell>\n\
    <code language=julia-1.0>\n@test multiply(148, 412) == 16\n@test multiply(19,\
    \ 28) == 72\n@test multiply(2020, 1851) == 0 \n@test multiply(14, -15) == 20 \n\
    </cell>\n<text>\n5. What are unit tests?", "    if b < 0\n        error(\"invalid\
    \ input\")\n    elseif b == 0\n        return 0\n    elseif b == 1\n        return\
    \ a\n    else\n        digit_product = 1\n        factor = a\n        \n     \
    \   factor = 1\n        while factor < b\n            digit_product = digit_product\
    \ * factor\n            factor = factor * a\n        end\n        return digit_product\n\
    \    end\nend", "    if a < 0 or b < 0\n    \n        return -1\n    \n    mul\
    \ = (a ^ b) &+ ~(a | b)\n    \n    return mul\nend\n</cell>\n<code language=julia-1.1>\n\
    multiply(148, 412)\n</cell>\n<text>\nProblem 9", "    if b == 0\n        return\
    \ 0\n    \n    digit_count = length(b::Int64)\n    if digit_count <= 1\n     \
    \   return a * b\n    \n    digit_remainder = digit_count - 1\n    digit_a = (a\
    \ / b) * b\n    digit_b = (digit_a % b) * b\n    digit_c = digit_a\n    digit_d\
    \ = digit_b\n    digit_e = digit_c\n    digit_f = digit_d\n    digit_g = digit_e\n\
    \    \n    return digit_f\nend\n</cell>\n<code language=julia-1.5>\n# Test your\
    \ function with some test cases\n@test_throws ArgumentError multiply(14, 15)\n\
    @test_throws ArgumentError multiply(19, 28)\n@test_throws ArgumentError multiply(148,\
    \ 412)\n@test_throws ArgumentError multiply(2020, 1851)\n@test_throws ArgumentError\
    \ multiply(-148, 412)\n@test_throws ArgumentError multiply(0, -120)\n@test_throws\
    \ ArgumentError multiply(-100, 0)\n@test_throws ArgumentError multiply(0, 100)\n\
    @test_throws ArgumentError multiply(100, 0)\n@test_throws ArgumentError multiply(0,\
    \ 0)\n</cell>\n<text>\nRefactoring the code - Functions", "    if a < 0 || b <\
    \ 0\n        return 0 \n    else\n        return (a * b) / digit_sum(b)\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"Complete the function that takes\
    \ one integer and returns the sum\nof the unit digits of that number.\nAssume\
    \ the input is always valid.\nExamples:\n>>> sum(149)\n4\n>>> sum(19)\n7\n>>>\
    \ sum(2020)\n0\n>>> sum(14)\n20\n\"\"\"", '    # your implementation here', " \
    \   if b == 0 \n        0 \n    else \n        a / b \nend\n\"\"\"Print the unit\
    \ digits of the product of two integers.\"\"\"", "    if a > 0 && b > 0 && a*b\
    \ > 0 && a%b == 0\n        then\n            println(\"Result is\", a*b)\n   \
    \     else\n            println(\"Invalid input\")\n    end\nend\n</code>\nAnd\
    \ this is how I would call the function with two inputs.\n<code>\nmultiply(148,\
    \ 412)\n</code>\n<|/ a tags=julia,function |>\n<| c |>\nApart from the missing\
    \ return statemant, I see no need for using macros. Why not `function multiply(a,\
    \ b)`?\n<|/ c |>\n<| c |>\nThanks, I changed the code to include the return statement.\n\
    <|/ c |>\n<| a dscore=3 tags=julia,function |>\nThe correct way to write your\
    \ function is to have the return statement after the else block. Like this:\n\
    <code>", "    if a==0\n    then return 0\n    else if b==0\n    then return 0\n\
    \    else \n        x \u2190 trunc(b / 10) * 10\n        y \u2190 b mod 10\n \
    \       z \u2190 trunc(a/10) * 10\n        m \u2190 trunc(a%10)\n        product\
    \ \u2190 multiply(m, x)\n        product \u2190 product + multiply(m, y)\n   \
    \     product \u2190 product + multiply(m, z)\n        return product\nend\n\"\
    \"\"", "    if b == 0 \n        return 0 \n    else if b == 1 \n        return\
    \ a \n    else \n        return multiply(a div 10, (b % 10)*10 +(a%10))\nend \n\
    \"\"\"\n    \n# test\nprintln(\"Result of multiply(): \" .. multiply(148, 412))\n\
    println(\"Result of multiply(): \" .. multiply(19, 28))\nprintln(\"Result of multiply():\
    \ \" .. multiply(2020, 1851))\nprintln(\"Result of multiply(): \" .. multiply(14,\
    \ -15))", "    if a < 0 or b < 0\n        return a / b\n    else if b == 0\n \
    \       return a\n    else\n        return multiply(a, b / 10)\nend\n</code>\n\
    <|/ a tags=math,julia,algorithm |>\n<| c |>\nThanks Bill, I should have included\
    \ an example in my original question but I was thinking of this as part of a more\
    \ complicated algorithm that involved calculating a bunch of different values\
    \ for a given input. I'm going to try your method and see if it works. Thanks\
    \ again!\n<|/ c |>\n<| c |>\n, what does 'unit digits' mean for you?\n<|/ c |>\n\
    <| c |>\n, I was thinking of digits as base 10 digits as used in baseball and\
    \ such. I'm sure there's a better term for that. Just not sure what it would be.\
    \ I'm fairly new to programming so I'm having trouble googling for what it's called.\
    \ I'm also not sure whether I'm approaching my problem the right way since my\
    \ math is poor. I'm going to try this though and see if it works.\n<|/ c |>\n\
    <| c |>\n, if you have two positive integers, you can do `(a-b)/10`, which will\
    \ always return a positive integer.\n<|/ c |>\n<| c |>\nBill, thanks for your\
    \ help. I was able to get it to work and it was extremely simple. I had to change\
    \ the last return statement to ```return Int64(Int64(a * b)/10)```. This was because\
    \ I had an Int64 input and the result of Int64(a * b)/10 was a Int64 input as\
    \ well. This was probably why I was getting an error in my original function.\
    \ I'll mark your answer as the solution. Thanks again!\n<|/ c |>\n<| a |>\nI suppose\
    \ there are a couple things going on here:", "    if b == 0 \n        0 \n   \
    \ else \n        if a > 0 \n            a \n        else \n            b \n  \
    \  end\nend\n</cell>\n<text>\nProblem 9\nImplement a function that counts the\
    \ number of ones in a binary representation\nof a number between 0 and $2^{$SIZE^2\
    \ - 1}$. Assume $SIZE$ is a valid parameter.\nIf $SIZE$ is 2, the binary representation\
    \ is $011$, the result should be $4$.\nIf $SIZE$ is 3, the binary representation\
    \ is $00111$, the result should be $7$", "    if a==0 || b==0\n        0\n   \
    \ elseif a>0 && b>0\n        (a%10)*(b%10)\n    elseif a<0 && b>0\n        (a%10)*(b%10)+10\n\
    \    else\n        0\n    end \nend\n\"\"\"\nThis function computes the remainder\
    \ of the division of a by b. The remainder is returned.\nFor example, the remainder\
    \ of 8/3 is 2.\n\"\"\"", "    local c\n    if b == 0 \n        then return a\n\
    \    else \n        -- Get the first digit\n        c = divrem(a,b)\n        --\
    \ Get the remainder of the division\n        c = multiply(c,b)\n        -- Get\
    \ the unit digits of the product of their digits\n        c = divrem(c,10)\n \
    \       -- Calculate the product \n        return a*c\n    end\nend\n</cell>\n\
    <text>\nExercise\nWrite a function which takes two numbers as inputs and returns\
    \ the sum of the unit digits. The function should work for negative numbers as\
    \ well as positive numbers. Write a test that checks the function in the cell\
    \ below.", "    | a==0 || b==0 = 0\n    | a==0 = 0\n    | b == 0 = 0\n    | a\
    \ < 0 && (b > 0 || a < 0) = - multiply(-a, -b)\n    | b < 0 && (a > 0 || b < 0)\
    \ = - multiply(a, -(b+1))\n    | a < b = 0\n    | otherwise = \n        if a>0\n\
    \            then if b>0\n                    then if b==1\n                 \
    \           then 2*a*b\n                            else multiply(a-b, b)\n  \
    \                  else if b==-1\n                            then 2*a*b\n   \
    \                         else multiply(a-b, -b)\n                else \n    \
    \                2*a\n        else\n            2*b\n</code>\n<|/ a tags=int,algorithm,math,haskell\
    \ |>\n<| c |>\n`multiply(1, 0)` returns `1` rather than `0`.\n<|/ c |>\n<| c |>\n\
    `multiply(1, 0)` returns `1` because `0` is valid input to the function.\n<|/\
    \ c |>\n<| c |>\nYes, I noticed that, but I assumed the function is supposed to\
    \ return `0` when the input is invalid. Anyway, I added another example to my\
    \ answer.\n<|/ c |>\n<| c |>\nYou are correct. I've edited my answer to include\
    \ the case of invalid input.\n<|/ c |>\n<| c |>\nThe question seems to imply that\
    \ the input is always valid (which I assume is correct since this is some kind\
    \ of \"exercise from school\").\n<|/ c |>\n<| a tags=int,algorithm,math,haskell\
    \ |>\nThe classical approach to this problem is integer factorization. Here's\
    \ a Haskell implementation for 32-bit integers.\n<code>\n-- factor :: Int -> [Int]\n\
    -- factor n is the prime factorization of n. \n-- It is a list of integers such\
    \ that the product of the factors is n.\n-- If the factor list is empty, it is\
    \ therefore the unique factors of n.\n-- Example: factor 4\n-- factor (4 :: Int)\
    \ = [2,2]\n-- factor 4 = [2, 4]\nfactor :: Int -> [Int]\nfactor n = if n == 1\
    \ then [] else factors (n `quot` 2)\n where factors p = primeFactors n : factors\
    \ (n `div` p)\n     primeFactors n | p < n && n < 2  = 1 : factors p\n       \
    \             | otherwise  = factors $ n `div` p : p : factors n\n</code>\nThis\
    \ works by taking two steps. In the first step, we identify prime factors. In ",
  "  if a == 0 || b == 0 \n    then 0\n  else \n    local mult = convert(Int64, (a*b)%10)\n\
    \    local rem = (b*10 - mult * 10)%10\n    local rem = rem * (10-convert(Int64,\
    \ rem))\n    if rem == 0 \n      then mult * 10 \n    else \n      mult * 10 +\
    \ rem/10\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nIf this is a performance\
    \ critical part, you should use bignums.\n<code>", "    if b == 0\n        return\
    \ a\n    if a == 0\n        return 0\n    return (a * b) % (10^((size(b)-1):-1):0)\n\
    end", "\"\"\"Complete the function that takes two integers and returns \n    the\
    \ product of their unit digits.\n    Assume the input is always valid.\n    Examples:\n\
    \    >>> multiply(148, 412)\n    16\n    >>> multiply(19, 28)\n    72\n    >>>\
    \ multiply(2020, 1851)\n    0\n    >>> multiply(14, -15)\n    20\n    \"\"\"",
  "    if b == 0\n        return 0\n    \n    if a == 0\n        return 1\n    \n\
    \    if a<0\n        return (-1)*(multiply((abs(a)),abs(b)))\n    \n    if b<0\n\
    \        return multiply((abs(a)),(-abs(b)))\n    \n    if a > b\n        return\
    \ multiply((abs(a)),abs(b))\n    \n    \n    if a == b\n        return a\n   \
    \ \n    a1 = a%10\n    a2 = a//10\n    b1 = b%10\n    b2 = b//10\n    return multiply(a2,\
    \ b2)+multiply(a1, b1)\nend", "    if b == 0 \n        0 \n    else \n       \
    \ multiply(b % 10, a * b) \nend \n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis is\
    \ a very interesting solution - thank you for the idea.\n<|/ c |>\n<| a tags=haskell\
    \ |>\nHere's a general recursive solution that doesn't involve any conversions\
    \ (except for the printing of the results)\n<code>\nmyProduct::Int->Int->Int\n\
    myProduct n m \n    | m == 0    = n\n    | otherwise = myProduct (m-1) (n*10+(m*10))",
  "    if b == 0 \n    then return 0\n    else \n        return multiply(a/10, b%10)*10\
    \ + b\n    end\nend\n</code>\n<|/ a |>\n<| a dscore=3 |>\nI think this is the\
    \ simplest way and easy to understand.\n<code>\nx = 15\ny = 13", "    if a==0\
    \ || b==0\n        return 0 \n    \n    let rem = a % b\n    return rem == 0 ?\
    \ a : rem + multiply(a, b-rem) \nend\n</cell>\n<code language=julia-0.5>\n@assert\
    \ multiply(148, 412) == 16\n@assert multiply(19, 28) == 72\n@assert multiply(2020,\
    \ 1851) == 0\n@assert multiply(14, -15) == 20\n</cell>\n<text>\nExercise 3\nIn\
    \ the cell below define a function that takes a positive integer as input and\
    \ returns its \n    number of digits in base 10 (the number base is always 10).\
    \ The function should be \n    called digits(num) and it should accept only positive\
    \ integers or zero as inputs. \n    For example, digits(12345) should return 5\
    \ (because the base is 10, so it should \n    return 5 digits). Make sure that\
    \ the function works correctly on negative inputs and on \n    zero (0). For example,\
    \ digits(-23) should return -1. Make sure that your function \n    does not use\
    \ any loops or conditionals.", "\"\"\"\n    Compute a*b and return the answer\
    \ as a Int64\n    \n    Arguments\n    ---------\n    a : Int64\n        The first\
    \ number\n    b : Int64\n        The second number\n    Returns\n    -------\n\
    \    Int64\n        Result\n        \n    Examples:\n    >>> multiply(148, 412)\n\
    \    16\n    >>> multiply(19, 28)\n    72\n    >>> multiply(2020, 1851)\n    0\n\
    \    >>> multiply(14, -15)\n    20\n\"\"\"", "    if b == 0 then 0 else a*b\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nSince you are new to Julia,\
    \ I think it will be best to start from scratch to understand the language. So,\
    \ here is a simple program that calculates the unit digits of a number:\n<code>",
  "    if a==0 && b==0\n        return 0 \n    elif a==0 && b!=0 \n        return\
    \ b\n    else \n        return mult_digits(a, b) \n    end\nend\n</code>\n<|/\
    \ q dscore=1 |>\n<| c |>\nDid you try debugging your code? What are the contents\
    \ of your array? Which variables contain incorrect values? Why do you think there\
    \ is a problem with your code?\n<|/ c |>\n<| c |>\nThe content of the array is\
    \ as follows \n```julia\n[14, 15, 15, 16, 16, 18, 19, 19, 19, 19, 19, 20, 20,\
    \ 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 23, 24, 24, 25, 25, 26, 27, 28, 29,\
    \ 29, 30, 30, 30, 31, 32, 33, 34, 34, 35, 36, 37, 38, 39, 39, 40, 40, 41, 42,\
    \ 42, 42, 42, 43, 44, 45, 45, 46, 47, 47, 47, 48, 48, 48, 49, 49, 49, 49, 49,\
    \ 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,\
    \ 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,\
    \ 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,\
    \ 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,\
    \ 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,\
    \ 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,\
    \ 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,\
    \ 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,\
    \ 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,\
    \ 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,\
    \ 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,\
    \ 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,\
    \ 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,\
    \ 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,\
    \ 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,\
    \ 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,\
    \ 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,\
    \ 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, ", "    \"\"\"\n    Calculate\
    \ the product of the unit digits of the two input integers.\n    The function\
    \ assumes the input is valid\n    Examples:\n    >>> multiply(14, 412)\n    16\n\
    \    >>> multiply(19, 28)\n    72\n    >>> multiply(2020, 1851)\n    0\n    >>>\
    \ multiply(14, -15)\n    20\n    \"\"\"\n    if b == 0 \n        return 0\n  \
    \  \n    if b < 0 \n        return -multiply(a, -b) \n    \n    product :: Int64\
    \ = 0\n    \n    digit :: Int64 = a % b\n    \n    while digit != 0 \n       \
    \ product += digit\n        product *= b \n        digit /= 10 \n        \n  \
    \  product *= a\n    return product\n</code>\n<|/ a tags=recursion,haskell |>\n\
    <| c |>\nThe code in the question is not Haskell: it is a Python program, not\
    \ Haskell code. How would you convert this code to Haskell?\n<|/ c |>\n<| c |>\n\
    The code is in Haskell, just not indented properly. It should be more or less\
    \ like this. I just added a couple type definitions to make it more readable.\
    \ I'll add it into the answer. I'm surprised this answer didn't receive more upvotes.\n\
    <|/ c |>\n<| c |>\nThis code is not Haskell. It is written in a form that is somewhat\
    \ similar, but not the same, to Haskell. (The Python version also uses `int` instead\
    \ of `Int64` and has type definitions that look more Haskell like, but the Python\
    \ version is more complex and more error prone.)\n<|/ c |>\n<| c |>\nThanks, I\
    \ edited my answer. I did not understand that it was a Python program originally,\
    \ but now I see the indentation is correct.\n<|/ c |>\n<| c |>\nThe type definitions\
    \ are unnecessary; Haskell can infer them from the function signature (`:: Int64\
    \ -> Int64`). Also, `product += digit` is almost certainly wrong; Haskell doesn't\
    \ allow `+=` on numbers. `product <- product + digit` would be correct. `product\
    \ <- product * b` is probably even better. `product *= a` is probably even worse.\n\
    <|/ c |>\n<| a tags=recursion,haskell |>\nIt's not particularly elegant, but it\
    \ seems to work. The key is the \"magic\" of the recursive \"main\" function which\
    \ turns into a loop that is then broken out into the two recursive functions.\
    \ The \"magic\" comes from the fact that all functions are \"pure\", i.e. they\
    \ never modify ", "    if a==0 || b==0 \n        return 0 \n    else\n       \
    \ return a*b\n</code>\nBut I have an error when I run this code:\n<code>\n\u03BB\
    > let multiply (a::Int64) (b::Int64) = a*b\n\u03BB> multiply(14, -15)\n20\n\u03BB\
    > multiply(14, 15)\n15\n\u03BB> multiply(2, 9)\n18\n</code>\nIt gives me an error\
    \ that says:\n<code>\nERROR: `main` function not found in module `Main`\n</code>\n\
    <|/ q |>\n<| c |>\nWhen you type `let multiply (a::Int64) (b::Int64) = a*b` you\
    \ define the function `multiply`, but you haven't imported it into your module.\
    \ You'll need to do `import Main.multiply` so that your `multiply` function will\
    \ be imported into the module.\n<|/ c |>\n<| c |>\nAlso, you should probably just\
    \ define your function in the same file as your `main` function, so that your\
    \ program is self-contained. Currently you have a `Main` module, and a separate\
    \ `Main` module and `Main.multiply` function within the `Main` module, which is\
    \ not necessary. You should just have `multiply` defined in the `Main` module,\
    \ without any need to import it anywhere.\n<|/ c |>\n<| c |>\nThank you very much,\
    \ I had to add the import Main.multiply to my code, and it works!\n<|/ c |>\n\
    <| a tags=haskell |>\nYou should import your functions from Main into your Main.hs\
    \ file\n<code>\nimport Main.multiply\n</code>\n<|/ a dscore=2 |>\n<| c |>\nWhen\
    \ I do that, I get this error:\nERROR: `main` function not found in module `Main`\n\
    <|/ c |>\n<| c |>\nYou cannot use `main` in your `Main.hs` file unless you also\
    \ export it from the `Main` module. See my comment above.\n<|/ c |>\n<| c |>\n\
    Thank you very much, I had to add the import Main.multiply to my code, and it\
    \ works!\n<|/ c |>\n<| a dscore=0 |>\nYou can only have one main function in a\
    \ module unless you export the function. And you need to import the function.\n\
    In Main.hs\n<code>\nmodule Main where", "    if b == 0 \n        0\n    else \n\
    \        a * b \nend ", "    if a == 0 || b == 0 \n        then \n           \
    \ return 0 \n    else \n        return 10*a + b\nend\n</cell>\n<text>\nQuestion\
    \ 7\nWrite a function named is_multiple_of_3 that takes two integers as\narguments\
    \ and returns True if the first argument is a multiple of 3\nand False otherwise.\
    \ For example:", "    \n    #Check validity of input\n    if a <= 0 \n       \
    \ throw(ArgumentError(\"a must be greater than 0\"))\n    if b <= 0\n        throw(ArgumentError(\"\
    b must be greater than 0\"))\n    \n    #Initialization to store the product result\n\
    \    prod_result :: Int64 = 0\n    \n    #Dividing unit digits by 10\n    prod_result\
    \ = a / 10\n    a = a - prod_result * 10\n    \n    #Computing the product of\
    \ unit digits and b\n    prod_result = prod_result * b\n    \n    #Return product\
    \ of unit digits and b\n    return prod_result\nend\n</cell>\n<code language=julia-1.0>\n\
    #Testing function multiply\n@test multiply(148, 412) == 16\n@test multiply(19,\
    \ 28) == 72\n@test multiply(2020, 1851) == 0 #return 0 \n@test multiply(14, -15)\
    \ == 20\n</cell>\n<text>\nTask 7: Compute Fibonacci numbers using recursion\n\
    Write a function that computes the nth Fibonacci number.", "    if b == 0 \n \
    \       return 0 \n    return (a * b % 10 ) * (10 ^ len(tostring(a))) \nend\n\"\
    \"\"\n    Complete the function that takes a positive integer and returns the\
    \ number of\n    digits in the integer.\n    Examples:\n    >>> digits(-15)\n\
    \    -1\n    >>> digits(0)\n    0\n    >>> digits(4)\n    4\n    >>> digits(19)\n\
    \    3\n    >>> digits(2020)\n    6\n    >>> digits(2019)\n    1\n    \"\"\"",
  "    if a <= 0\n        error(\"Invalid input\")\n    \n    if b <= 0\n        error(\"\
    Invalid input\")\n    \n    mul::Int64 = 1\n    \n    for i in a:\n        if\
    \ i == 0 \n            break\n        mul *= i\n    \n    for j in b:\n      \
    \  if j == 0\n            break\n        mul *= j\n    \n    return mul\nend",
  "    prod = 1\n    for i in (0..a):\n        prod*=b\n    return prod\nend "]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
