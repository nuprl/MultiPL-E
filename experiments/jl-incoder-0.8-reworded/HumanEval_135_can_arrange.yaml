name: HumanEval_135_can_arrange
language: jl
prompt: "\"\"\"Create a function which returns the largest index of an element which\n\
  \    is not greater than or equal to the element immediately preceding it. If\n\
  \    no such element exists then return -1. The given vector will not contain\n\
  \    duplicate values.\n\n    Examples:\n    >>> can_arrange([1, 2, 4, 3, 5])\n\
  \    3\n    >>> can_arrange([1, 2, 3])\n    -1\n    \"\"\"\nfunction can_arrange(arr::Vector{Int64})::Int64\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = can_arrange;\n\t@test(candidate([1,\
  \ 2, 4, 3, 5]) == 3)\n\t@test(candidate([1, 2, 4, 5]) == -1)\n\t@test(candidate([1,\
  \ 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\n\t@test(candidate([4, 8, 5, 7, 3]) == 4)\n\t\
  @test(candidate(Vector{Int64}([])) == -1)\nend\n"
completions: ["  i=1\n  while i <= length(arr) \n    if arr[i-1] >= arr[i]\n     \
    \ break\n    else\n      i += 1\n  end\n  return i\nend\n</cell>\n<code language=julia-1.3>\n\
    @test can_arrange(Int64[1,2,4,3,5])==3\n@test can_arrange(Int64[1,2,3])==-1\n\
    </cell>\n<text>\nExercise 3", "  \n    # initialize largest possible index\n \
    \   largest = -1\n    \n    # go through each element in the vector\n    for idx\
    \ in 1:length(arr)\n        if arr[idx] > arr[largest]\n            largest =\
    \ idx\n        end\n    end\n    return largest\nend", "   if length(arr)==0\n\
    \    return -1\n   end\n   largest = -1\n   for elt in arr\n       if elt > largest\n\
    \           largest = elt\n       end\n   end\n   return largest\nend", "    #println(\"\
    Arranging array\")\n    max = -1\n    for i in 2:length(arr) \n        if arr[i]\
    \ > arr[max] \n            max = i\n        end \n    end \n    return max\nend\n\
    \"\"\"\nCreate a function which returns the index of the element which is greater\
    \ than\nor equal to the element immediately preceding it. Return -1 in case no\
    \ such\nelement exists. Note that you cannot assume that the array contains no\
    \ duplicate\nvalues.", "    largest = -1\n    largest_idx = -1\n    for i \u2208\
    \ arr\n        largest = i\n        if i == (largest-1)\n            largest_idx\
    \ = i\n        end\n    end\n    return largest_idx\nend", "    arr = sort(arr)\n\
    \    index = findlast(arr, x->x>arr[end])\n    if index == -1\n        return\
    \ -1\n    return index\nend\n</cell>\n<code language=julia-0.6>", "        lenarr\
    \ = length(arr)\n        largest = Int64(-1)\n        if lenarr < 2\n        \
    \    return -1\n        elseif lenarr == 2\n            return 1\n        end\n\
    \        for idx in 2:(lenarr - 1)\n            if arr[idx] > arr[largest]\n \
    \               largest = idx\n            end\n        end\n        return largest\n\
    \    end\n    ", "    sorted = sort(arr)\n    largest = first(arr[end-1]) != last(arr[end-1])\
    \ ? first(arr[end-1]) : last(arr[end-1])\n    if largest == sorted[1] \n     \
    \   return -1\n    return findfirst(x -> x >= largest, sorted)\nend\n</cell>\n\
    <code language=julia-1.3>\n@assert can_arrange([1]) == -1\n@assert can_arrange([1,2,3,4])\
    \ == 3\n@assert can_arrange([1,2,3,3,4,5,6,7,8,9]) == -1\n@assert can_arrange([2,2,1,1,1,2,2,3,3,4,4])\
    \ == 7\n@assert can_arrange([2,2,1,1,1,2,2,3,3,4,4,5,5,6,6,7,8,8,9,9,10]) == -1\n\
    @assert can_arrange([2,2,1,1,1,2,2,3,3,4,4,5,6,6,7,8,8,9,9,10,11]) == -1\n@assert\
    \ can_arrange([2,2,1,1,1,2,2,3,3,4,4,5,6,6,7,8,8,9,9,10,11,12]) == -1\n@assert\
    \ can_arrange([2,2,1,1,1,2,2,3,3,4,4,5,6,6,7,8,8,9,9,10,11,12,13,14,15,16,16,17,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33,34,34,35,35,36,36,37,37,38,38,39,39,40,40,41,41,42,42,43,43,44,44,45,45,46,46,47,47,48,48,49,49,50,50,51,51,52,52,53,53,54,54,55,55,56,56,57,57,58,58,59,59,60,60,61,61,62,62,63,63,64,64,65,65,66,66,67,67,68,68,69,69,70,70,71,71,72,72,73,73,74,74,75,75,76,76,77,77,78,78,79,79,80,80,81,81,82,82,83,83,84,84,85,85,86,86,87,87,88,88,89,89,90,90,91,91,92,92,93,93,94,94,95,95,96,96,97,97,98,98,99,99,100,100,101,101,102,10",
  "    if arr.size == 0 \n        return -1\n    end\n    if arr[1] <= arr[0]\n  \
    \      return -1\n    end\n    return findfirst(arr[1] > arr[end], arr[2:end])\n\
    end", "    arr.size\n    largest = -1\n    \n    for i in 1:(arr.size - 1)\n \
    \       if arr[i] > largest\n            largest = i\n        end\n    end\n \
    \   return largest\nend", "    if length(arr)<2 return -1\n    res=-1\n    for\
    \ i in 1:(length(arr)-1)\n        res=max(res,arr[i])\n    end\n    res\nend\n\
    \"\"\"\nCreate a function which takes an array and returns that array sorted in\
    \ \nascending order. If given an empty array then return an empty array. If\n\
    given an array of length 0 then return an empty array. Do not sort the \narray.\n\
    \"\"\"", "    return \nend\n    \n\"\"\"\n    can_rearrange(arr::Vector{Int64})::Vector{Int64}\n\
    \    \nCreate a function which rearranges the values in the array such that\n\
    it is the smallest value which is not less than or equal to the next\nsmallest\
    \ value. Repeated values are only allowed in the array.", "    n = length(arr)\n\
    \    for i in reverse(1:n)\n        if arr[i-1] > arr[i]\n            return i\n\
    \    return -1\nend\n</cell>\n<code language=julia-0.6>\n@time can_arrange([1,\
    \ 2, 4, 3, 5])\n</cell>\n<code language=julia-0.6>\n@time can_arrange([1, 2, 3])\n\
    </cell>\n<text>\nTo check your work we will use the same function as before but\
    \ with the @timeit macro.", "    for i \u2208 1:length(arr) - 1 do \n        if\
    \ arr[i] > arr[i+1] \n            return i \n    end\n    return -1\nend\n</cell>\n\
    <text>\n4.11 Find kth largest element in an array", "  i = 1\n  while i <= length(arr)\
    \ do \n    if arr[i] > arr[i-1] \n      break\n    else \n      i += 1\n  end\n\
    \  if i == length(arr)\n    return -1\n  else\n    return i\n  end\nend", "  \
    \  arr_length = length(arr)\n    for i in 1:arr_length-1\n        if arr[i] >\
    \ arr[i+1] \n            return i\n        end\n    end\n    return -1\nend",
  "    len = length(arr)\n    largest = 0\n    largestidx = 0\n    for i in 1:len\
    \ - 1\n        if arr[i] >= arr[largest] \n            largest = i\n         \
    \   largestidx = i\n        end\n    end\n    if largest == len - 1\n        largest\
    \ = len\n        largestidx = len\n    end\n    return largestidx\nend\n</cell>\n\
    <code language=julia-0.6>\narr = [2, 3, 4, 5, 1, 2, 3, 4, 3, 1, 2, 5, 6, 8, 1,\
    \ 2, 3, 4, 5]\nprintln(can_arrange(arr))\n</cell>\n<code language=julia-0.6>",
  "\tlargest = 0\n\tfor i in eachindex(arr):\n\t\tif arr[i] <= arr[largest] \n\t\t\
    \tlargest = i\n\t\telse\n\t\t\treturn -1\n\t\n\treturn largest\nend\n\"\"\"\n\"\
    \"\"\n### Array Manipulation Functions\n\"\"\"", "    largest = 0\n    largestIndex\
    \ = -1\n    for i in reverse(arr)\n        if i>largest\n            largest =\
    \ i\n            largestIndex = i\n        end\n    end\n    largestIndex\nend\n\
    </cell>\n<code language=julia-1.5>\n\"\"\"\n    can_arrange(arr::Vector{Int64})::Int64\
    \ \n    largest = 0\n    largestIndex = -1\n    for i in reverse(arr)\n      \
    \  if i>largest\n            largest = i\n            largestIndex = i\n     \
    \   end\n    end\n    largestIndex\nend\n\"\"\"", "    arr = sort(arr)\n    i\
    \ = arr[end]\n    if arr[i] <= 0 \n        error(\"no such element\")\n    end\n\
    \    j = arr[i]\n    k = j-1\n    while k > 0 && arr[k] > arr[j]\n        arr[k+1]\
    \ = arr[k]\n        k = k-1\n    end\n    arr[k+1] = arr[j]\n    return j\nend",
  "    # Write your code in Julia 1.5 *or* Python 2.7\n    # but make sure you have\
    \ the latest Julia 1.5 or the latest Python 2.7 \n    i = 0\n    largest = arr.length\n\
    \    index = -1\n    while i != largest\n        i += 1\n        if arr[i] > arr[i-1]\n\
    \            index = i\n        end\n    end\nend\n</cell>\n<text>\nQ13: Create\
    \ a function which takes a function and an array of numbers and returns a new\
    \ vector in which each of the elements in the input array is passed into the function\
    \ with the corresponding number in the input array.", "    largest = -1\n    largest\
    \ = 0\n    for i in arr\n        if i > 0\n            break\n        elseif largest\n\
    \            largest = i\n        end\n    end\n    largest\nend\n</cell>\n<code\
    \ language=julia-1.6>\n@code_warntype can_arrange(vec(0:9))\n</cell>\n<code language=julia-1.6>\n\
    can_arrange(vec(0:9))\n</cell>\n<text>\nExercise 10: Can I reorder the elements\
    \ of this vector?\nThe function can_arrange is able to tell you the largest index\
    \ of an element which\nis not greater than or equal to the element immediately\
    \ preceding it. But does it also tell\nyou whether all the elements in arr can\
    \ be arranged in such a way to satisfy the requirements?\nWhat about the elements\
    \ which are less than the smallest element?", "    arr = sort(arr)\n    i = arr[1]\n\
    \    while(arr[i] > arr[i-1]) do\n        i = i + 1\n    end\n    i\nend", " \
    \   if length(arr)<2 return -1\n    largest=sort(arr)[1]\n    largest_index=find(arr>largest)[1]\n\
    \    largest_index+=1\n    if arr[largest_index] == arr[largest_index-1] then\
    \ largest_index+1 else largest_index\nend", "    local max = arr[end]\n    for\
    \ x in arr\n        if x > max\n            max = x\n        end\n    end\n  \
    \  return max\nend\n</cell>\n<text>\nThis function is also useful to check for\
    \ validity. For example, how would you check that a vector does not contain any\
    \ duplicates?", "    a=-1\n    i=size(arr)-1\n    while i>0\n        if arr[i]>arr[i-1]\n\
    \            a=i\n            break\n        end\n        i-=1\n    end\n    return\
    \ a\nend\nprintln(can_arrange([1, 2, 4, 3, 5]))\nprintln(can_arrange([1, 2, 3]))",
  "    len = length(arr)\n    if len < 2\n        -1\n    elseif len == 2\n      \
    \  arr[1] < arr[1]\n    elseif arr[1] == arr[end]\n        -1\n    else\n    \
    \    arr[1] > arr[end] ? end - 2 : end - 1\n    end\nend\n</cell>\n<code language=julia-1.6>",
  "    arr = arr[arr.>arr[end].-1]\n    if isempty(arr)\n        return -1\n    else\n\
    \        return arr[end]\nend\n</cell>\n<code language=julia-1.5>", "    \"\"\"\
    \n    Create an anonymous function that returns the largest index of an element\n\
    \    which is not greater than or equal to the element immediately preceding it.\n\
    \    If no such element exists then return -1. The given vector will not contain\n\
    \    duplicate values.\n    \"\"\"", "    i = length(arr)\n    while i>1\n   \
    \     \n        if arr[i-1] >= arr[i]\n            return i-1\n        else\n\
    \            i -= 1\n    end\n    return -1\nend", "    for k in 1:length(arr)\n\
    \        if k <= arr[k]\n            return k\n        else\n            return\
    \ k - 1\n        end\n    end\n    return -1\nend\n</cell>\n<text>\nLet's run\
    \ that function on a few examples to see what it does.", "    \n    if length(arr)\
    \ == 0 \n        return -1 \n    \n    largest = arr[1] \n    largestIndex = 1\
    \ \n    for idx in 2:length(arr) \n        if arr[idx] < largest \n          \
    \  largest = arr[idx] \n            largestIndex = idx \n        else \n     \
    \       return largestIndex \n    end\n    return largestIndex\nend", "    largest\
    \ = -2\n    for i = 1:length(arr)\n        if arr[i] > arr[i+1]\n            largest\
    \ = i\n        else\n            break\n        end\n    end\n    return largest\n\
    end", "    if length(arr) == 1 return 0\n    idx = 1\n    while idx <= length(arr)-1\
    \ do \n        if arr[idx - 1] >= arr[idx] \n            idx += 1\n        else\n\
    \            return idx\n        end\n    end\n    return -1\nend\n</cell>\n<code\
    \ language=julia-1.5>\n# Check that the function does what we expect\narr = [1,\
    \ 2, 3, 4, 5]\nassert_equals(can_arrange(arr), 3)\n</cell>\n<code language=julia-1.5>\n\
    # Check that it works when given an empty array\nassert_equals(can_arrange([]),\
    \ -1)\n</cell>\n<code language=julia-1.5>\n# Check that it works when given a\
    \ vector with duplicate values\narr = [1, 2, 3, 5, 5]\nassert_equals(can_arrange(arr),\
    \ 3)\n</cell>\n<text>\nExercise 4.12: Can you find the first index where an element\
    \ does not equal the previous element?", "    largest = -2\n    pos = 0\n    for\
    \ x in arr\n        if x > largest\n            largest = x\n        elseif x\
    \ == largest\n            largest\n        else\n            pos = pos + 1\n \
    \       end\n    end\n    largest\nend", "    if arr.length == 0\n        return\
    \ -1\n    end = 1\n    \n    for val in arr\n        if val >= arr[end]\n    \
    \        end = val\n        else\n            end += 1\n        end\n    end\n\
    \    return end\nend", "    if isempty(arr) \n        return -1\n    largest =\
    \ -1\n    for x in arr \n        if x > largest \n            largest = x \n \
    \   end\n    return largest\nend", "    largest = 0\n    largestIndex = 0\n  \
    \  for x in arr\n        if largestIndex == 0 || x >= arr[largestIndex-1]\n  \
    \          largestIndex = i\n            largest = x\n        end\n    end\n \
    \   return largestIndex\nend\n</cell>\n<text>\nQuestion 4\nWrite a function which\
    \ accepts a vector of Int64 values as input and outputs the largest element and\
    \ its index from that vector. Note that the output vector should include both\
    \ the largest element and its index.", "    idx = 0\n    largest = -1\n    for\
    \ e in arr\n        if e < arr[idx]\n            largest = idx\n        idx +=\
    \ 1\n        if idx == length(arr)\n            break\n    end\n    return largest\n\
    end\n</cell>\n<text>\n4.2 Generate all permutations of size k\nThe function permutations\
    \ generates all permutations of size k in a given array\nA permutation of size\
    \ 1 contains exactly the original array. A permutation of size 2 contains two\
    \ elements from the\noriginal array, and so on. The number of permutations is\
    \ equal to the number of ways you can choose to arrange the elements in\nthe original\
    \ array in any way you like.", "    high = 1\n    high = arr[1]\n    \n    for\
    \ element in arr[2:length(arr)]\n        if element > high\n            high =\
    \ element\n        end\n    end", "    last=-1\n    for i in arr\n        if (i!=last)\
    \ && (i<=last)\n            last = i\n        else\n            last = -1\n  \
    \      end\n    end\n    return last\nend", "    if arr.size == 0\n        return\
    \ -1\n    \n    max_idx = 0\n    max_val = arr[max_idx]", "    arr_length = length(arr)\n\
    \    \n    for i in 2:arr_length-1\n        if arr[i-1] <= arr[i]\n          \
    \  return i-1\n        end\n    end\n    return -1\nend", "    for el in arr[end-1:end]\
    \ \n        if el > arr[1] \n            return el\n        else \n          \
    \  arr[1] = el\n    end\n    return -1\nend\n\"\"\"\n    Given a vector, return\
    \ the number of unique elements in it.\n\"\"\"", "    \"\"\"Create a function\
    \ which returns the largest index of an element which\n    is not greater than\
    \ or equal to the element immediately preceding it. If\n    no such element exists\
    \ then return -1. The given vector will not contain\n    duplicate values.", " \
    \   largest = Int.MAX\n    idx = 0\n    for elt in arr\n        if elt > largest\n\
    \            largest = elt\n        else\n            idx = 1\n        end\n \
    \   end\n    return largest\nend\n</cell>\n<code language=julia-1.3>", "    largest\
    \ = 0\n    index_of_largest = -1\n    for el in arr\n        if el <= arr[largest]\n\
    \            index_of_largest = largest\n            largest = el\n        else\n\
    \            if index_of_largest == -1\n                index_of_largest = largest\n\
    \            else\n                break\n        end\n    end\n    return index_of_largest\n\
    end\n</cell>\n<text>\nThe code above is the simplest version of the function.\
    \ We will write another version to understand how it works.", "    for i in arr\n\
    \        if i > arr[i-1]\n            return -1\n    return arr[i-1]\nend", " \
    \   idx = Int64(-1)\n    for i in arr\n        if i>idx\n            idx = i\n\
    \        end\n    end\n    return idx\nend\n</code>\n<|/ a |>\n<| a dscore=0 tags=julia\
    \ |>\nYou can use the function find and return the index when the condition is\
    \ met.\n<code>", "    if length(arr)==0 \n        return -1\n    largest=arr[1]\n\
    \    indx=2\n    while indx < length(arr) \n        if arr[indx] > largest \n\
    \            largest=arr[indx]\n            indx=indx+1\n        else\n      \
    \      indx=indx+1\n        end\n    end\n    return indx\nend\n\"\"\"\n    \n\
    \    \n    ", "    l = length(arr)\n    if l == 0\n        return -1\n    idx\
    \ = 1\n    while idx < l\n        if arr[idx] <= arr[idx - 1]\n            idx\
    \ += 1\n        else\n            break\n    end\n    return idx\nend\n\"\"\"\n\
    Create a function which returns the smallest index of an element which is\ngreater\
    \ than or equal to the element immediately preceding it. if no such\nelement exists\
    \ then return -1. The given vector will not contain duplicate\nvalues.", "   \
    \ largest = 0\n    index = -1\n    for elt in arr \n        if elt > arr[largest]\
    \ \n            largest = index\n        else\n            index = index + 1\n\
    \        end\n    end\n    return index\nend", "    for i=1:length(arr)-1 \n \
    \       if arr[i] <= arr[i-1] \n            return i \n        else \n       \
    \     return -1 \n        end \n    end \nend \n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\n  arranges(arr, k, inplace)", "    l = length(arr)\n    for (i,j) in combinations(arr,2)\n\
    \        if j > l-1 || j == 0 || j == l-1 && arr[j-1] >= arr[j]\n            return\
    \ -1\n        end\n    end\n    return -1\nend", "    pos = find(arr .> arr[end\
    \ - 1]) \n    if pos == -1 \n        return -1\n    else\n        return pos\n\
    \    end\nend\n\"\"\"\nCreate a function which returns the smallest index of an\
    \ element which\nis not less than or equal to the element immediately following\
    \ it. If\nno such element exists then return -1. The given vector will not contain\n\
    duplicate values.", "    if arr.length == 1\n        -1\n    else\n        arr[1]>arr[end]?-1:end\n\
    \    end\nend\n</cell>\n<text>\nExercise\nWrite a function that returns the index\
    \ of the element which is not greater\nthan or equal to the element immediately\
    \ following it in a vector.", "    return find(x -> x > arr[1], arr) + 1 \nend\n\
    </cell>\n<text>\nExercise: Which of the above functions is the best way of solving\
    \ this problem in a single line (without a for loop)?\nHint: You can use the built-in\
    \ function find for this purpose.", "    if arr.length == 0 \n        return -1\n\
    \    # check first element\n    if arr[1] <= arr[1] \n        return -1\n    #\
    \ check last element\n    if arr[end] <= arr[end-1]\n        return -1\n    #\
    \ check middle element\n    if arr[end] <= arr[end-1] and arr[end-1] <= arr[1]\n\
    \        return -1\n    # all elements are sorted\n    if arr[end] == arr[end-1]\n\
    \        return end\n    return end-1\nend", "    i=-1\n    for el in arr\n  \
    \      if el>arr[i]\n            i=el\n        end\n    end\n    i\nend", "  \
    \  \n    largest = -1\n    i = 0\n    \n    while i < length(arr) && arr[i] <=\
    \ largest\n        i += 1\n    end\n    \n    largest\nend", "    for idx1 in\
    \ eachindex(arr)\n        if arr[idx1] < arr[idx1-1] \n            return idx1\n\
    \        end\n    end\n    return -1\nend", "    largest_idx = -1\n    for idx\
    \ \u2208 1:length(arr) do \n        if arr[idx] > arr[idx-1] \n        then largest_idx\
    \ = idx \n        else return -1 \n        end \n    end \n    return largest_idx\
    \ \nend\n</cell>\n<text>\n3.3 Create function which returns the index of element\
    \ with value x if such element exists\nIf no such element exists return -1.",
  "    return max((i-arr[i-1] for i in arr))\nend", "    largest = -1\n    for i in\
    \ arr\n        if i>largest\n            largest = i\n        end\n    end\n \
    \   largest\nend\n</cell>\n<cell>\n@testset \"can_arrange\" begin\n    @test can_arrange([1,2,4,3,5])\
    \ == 3\n    @test can_arrange([1,2,3]) == -1\n    @test can_arrange([1,2,4,5,6,7]\
    \ == 7) == 7\n    @test can_arrange([1,2,4,5,6,7] == 4) == -1\n    @test can_arrange([1,2,4,5,6,7]\
    \ == 1) == -1\nend\n</cell>\n<text>\nTask 8: Create a function which takes a vector\
    \ x and an integer value k and returns a\nnew vector which contains elements from\
    \ x which have indices k in the same order as in the input vector.", "    if length(arr)\
    \ == 0 \n        return -1 \n    end \n    largest = -1 \n    largestIndex = 0\
    \ \n    for i in reverse(arr) do \n        if i > (largest + 1) \n           \
    \ largest = i \n            largestIndex = i \n        end \n    end \n    return\
    \ largest \nend \n</cell>\n<code language=julia-1.5>\n# Test your code \n\"\"\"\
    Check your code\"\"\"\nusing Test\n@test can_arrange([]) == -1\n@test can_arrange([1])\
    \ == 1\n@test can_arrange([1, 2, 3]) == 3\n@test can_arrange([1, 2, 4, 3, 5])\
    \ == 3\n</cell>\n<code language=julia-1.5>\n# Part B: Challenge yourself!\n\"\"\
    \"Solve the problem!\"\"\"", "  i, maxi = 0, 0\n  for val in arr\n    i = i +\
    \ 1\n    if i > maxi\n      maxi = i\n    end\n    if val < arr[i-1]\n      maxi\
    \ = i\n    end\n  end\n  maxi\nend\n</cell>\n<code language=julia-1.0>", "   \
    \ last::Int64 = -1\n    for i in reverse(arr)\n        if i >= last || last ==\
    \ -1\n            last = i\n        end\n    end\n    return last\nend\n</cell>\n\
    <code language=julia-1.1>", "    largest = arr[1]\n    for i in arr[2:end]\n \
    \       if i == largest\n            return -1\n        if i < largest\n     \
    \       largest = i\n        end\n    end\n    return largest\nend", "    \n \
    \   for i in 1:length(arr)-1\n        if arr[i] > arr[i+1]\n            return\
    \ i\n        end\n    end\n    return -1\nend\n</cell>\n<text>\nPart 2: Sorting\
    \ Algorithms\nThe next few cells implement a few sorting algorithms which are\
    \ designed to work on an array of numbers and return an array that contains the\
    \ sorted elements. The goal is to get the correct type of sorting algorithm working\
    \ for the problem. We'll start by implementing bubble sort on our own. Bubble\
    \ sort is implemented by simply repeatedly swapping adjacent pairs of elements\
    \ in the array. When the array is fully sorted, the algorithm exits.", "    if\
    \ length(arr)==1 \n        return -1 \n    i =  find_index(arr,maximum(arr)-1)\
    \ \n    if i>=1 \n        return i-2 \n    else \n        return -1 \nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nI like how you did it, but your function does not\
    \ return `-1` when the array is `[]` (`can_arrange([]) == -1`). I fixed it by\
    \ adding an `else` clause to `find_index`\n<|/ c |>\n<| a tags=julia dscore=1\
    \ |>\nHere is a solution that works with vectors with more than two elements:\n\
    <code>", "    sz = length(arr)\n    if sz == 0 \n        return -1\n    end\n\
    \    \n    largest = 0\n    largestidx = -1\n    for i in 1:sz\n        if arr[i]\
    \ > arr[largest]\n            largest = i\n            largestidx = i\n      \
    \  end\n    end\n    \n    if largestidx == 0 \n        return -1\n    else\n\
    \        return largestidx - 1\n    end\nend\n</code>\n<|/ a |>\n<| c |>\nI understand\
    \ your solution but this is way too complex. It can be done in one line by simply\
    \ using function `findfirst`\n<|/ c |>\n<| c |>\nyes that's true but I am writing\
    \ this answer for OP to understand and implement with their own code :). `findfirst`\
    \ can do it but OP wants index and `findfirst` will give it only in one line (I\
    \ mentioned that)\n<|/ c |>\n<| a dscore=0 tags=julia |>\nAn even more \"Julian\"\
    \ solution:\n<code>\nlargest(seq::Vector{Int64}) where {T} = (maximum(seq) - minimum(seq)\
    \ + 1)::Int64\n</code>\n<|/ a |>\n<| a dscore=0 |>\nA non-array solution:\n<code>\n\
    using DelimitedFiles", "    l = length(arr)\n    return if l == 0 \n        -1\n\
    \    elseif l == 1\n        arr[1]\n    else\n        arr[1] <= arr[l-1] and -1\
    \ \n    end\nend", "    idx = 1\n    previous = arr[1]\n    \n    for i in 2:length(arr)\n\
    \        if arr[i] > previous\n            idx=i\n        else\n            previous\
    \ = arr[i]\n        end\n    end", "    if arr[1] == 0\n        return -1\n  \
    \  return can_arrange(arr[2:end]) + arr[1]\nend", "    if arr.length == 1\n  \
    \      return -1\n    return max(arr.tail.take(1:end-1).findIndex(x -> x >=arr[1]))\n\
    end\n\"\"\"\nA function that returns the largest index of an element which is\
    \ not greater than or\nequal to the element immediately preceding it. No such\
    \ element exists\nthen return -1. The given vector will not contain duplicate\
    \ values.", "   \n    largest = arr[1]\n    for n in arr[2:end] \n        if n\
    \ > largest\n            largest = n\n        else\n            break\n    end\n\
    \    return largest\nend\n</cell>\n<code language=julia-1.0>", "    largest =\
    \ Inf\n    for i in reverse(arr)\n        if i <= largest\n            largest\
    \ = i\n        else\n            break\n    end\n    if largest == Inf\n     \
    \   return -1\n    else\n        return largest\n    end\nend\n</code>\n<|/ a\
    \ dscore=1 |>\n<| c |>\nI like the approach, but can you elaborate on the \"clever\"\
    \ part? It doesn't seem obvious to me.\n<|/ c |>\n<| c |>\nMy apologies for the\
    \ poor explanation.\n<|/ c |>\n<| a |>\nThis can be solved using a variant of\
    \ the longest increasing subsequence problem. \nIn short its a problem of finding\
    \ the longest increasing subsequence in a given array and there can be many ways\
    \ to solve this problem.\n<code>", "    for idx2 in findall(x->x>=arr[idx-1],arr)\
    \ #find the index of the element that is greater than the current element\n  \
    \      arr[idx2]=arr[idx-1] #set the element after this index to the element before\
    \ it\n        return idx2 #return the index\n    return -1 #no such element\n\
    end", "    for i = 1:length(arr)\n        if arr[i] > arr[i-1]\n            return\
    \ i-1\n        end\n    end\n    return -1\nend\n</cell>\n<cell>", "    largest\
    \ = arr[1]\n    for n in arr[2:end]\n        if n <= largest\n            largest\
    \ = n\n        else\n            break\n    end\n    if largest == arr[1]\n  \
    \      return -1\n    else\n        return largest\n    end\nend\n</code>\n<|/\
    \ a tags=julia,sorting,arrays |>\n<| c |>\nWhile this works, it only works for\
    \ `Int64`, for any other type than `Int64`, you'll have to use `sort!`: `sort!(inv[x],\
    \ revcomp(inv[x]))`.\n<|/ c |>\n<| c |>\nYeah, I just realized that. Thanks Karoly.\n\
    <|/ c |>\n<| a dscore=0 tags=julia,sorting,arrays |>\nHere is a solution using\
    \ sort and comprehensions.\n<code>\njulia> inv = 1:10\n10-element Vector{Int64}:\n\
    \ 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n 10", "    largest = arr[1]\n    for index\
    \ in (index for index in (1:length(arr)) if arr[index] > largest)\n        largest\
    \ = index\n    end\n    largest\nend", "    return maximum(arr) - first(arr) <\
    \ 0\nend", "    largest = -1\n    largestidx = 0\n    for k in length(arr) ..\
    \ 1 \n        if arr[k] > arr[largest]\n            largest = arr[k]\n       \
    \     largestidx = k\n        end\n    end\n    return largestidx\nend\n</cell>\n\
    <code language=julia-1.0>\n\"\"\"\n    can_arrange(arr::Vector{Int64})::Int64",
  "    pos = findfirst(isequal(max(arr)), reverse(arr))\n    if pos == nothing\n \
    \       return -1\n    else \n        return pos\nend\n</code>\n<|/ a tags=julia,performance,vectorization\
    \ |>\n<| c |>\nI like your use of `findfirst`, but it returns `nothing` on empty\
    \ input vectors, and the OP asked for \"negative number\" as return value. `findlast`\
    \ would be more appropriate.\n<|/ c |>\n<| c |>\nI did not notice that the answer\
    \ contained `Nothing` in its return value. Is that a problem? It is easy to change\
    \ `nothing` to a non-value by `firstindex`.\n<|/ c |>\n<| c |>\nNo, it is not\
    \ a problem, but I think that would be unnecessary. I just wondered if that situation\
    \ might come up at some point when someone wants to do some analysis on this problem,\
    \ or when someone is learning Julia, or when someone is trying to make sense of\
    \ some code that they did not write, etc. And if that situation does occur, your\
    \ example makes sense. Just my two cents.\n<|/ c |>\n<| c |>\nThat's a good point\
    \ actually. I will add an answer that does not depend on `Nothing` for the return\
    \ value.\n<|/ c |>\n<| a |>\nThis should be faster for larger arrays. \n<code>",
  "    largest = 0\n    for x in arr\n        if x < largest\n            largest\
    \ = x\n        elseif x > largest\n            return largest\n        end\n \
    \   end\n    return largest\nend", "    #local l\n    #local i\n    #local j\n\
    \    #local x\n    l = length(arr)\n    if l == 0 \n        return -1\n    end\n\
    \    x = arr[1]\n    i = 2\n    while i < l \n        if x != arr[i] \n      \
    \      return i\n        end\n        i += 1\n    end\n    return l + 1\nend\n\
    </cell>\n<text>\n3.3 Vectorize Functions", "\tindex=1\n\tmaximum=arr[1]\n\tfor\
    \ el in arr[2:end] \n\t\tif el>maximum \n\t\t\tmaximum=el\n\t\t\tindex=el\n\t\t\
    end \n\tend \n\tindex=maximum\n\treturn index\nend ", "    largest = -1\n    for\
    \ index in (arr.size - 1)..(-1) do\n        if arr[index] <= arr[largest] \n \
    \       then\n            largest = index\n        else\n            break\n \
    \       end\n    end\n    return largest\nend\n</cell>\n<code language=julia-0.4>\n\
    can_arrange(arr)\n</cell>\n<text>\nQuestion 3.2\nWrite a function called can_arrange_2\
    \ which returns the largest index of\nan element which is not greater than or\
    \ equal to the element immediately preceding it. If\nno such element exists then\
    \ return -1. Write a second function called\ncan_arrange_3_1 which returns the\
    \ largest index of an element which is\nnot greater than or equal to the element\
    \ immediately preceding it.\nThe given vector will not contain duplicate values.",
  "    largest = arr[end]\n    for i in arr[end-1:end]\n        if i > largest\n \
    \           largest = i\n        end\n    end\n    largest\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nWhy are you reinventing the wheel here? `max` is already implemented\
    \ for a bunch of types and is likely to be faster than any loops.\n<|/ c |>\n\
    <| c |>\n`max` is a builtin, I do not think it is faster than any loops. And it\
    \ returns the element in the array which has the maximum value, not the element\
    \ which is closest to it.\n<|/ c |>\n<| c |>\n: I doubt that this is faster than\
    \ any loops at all, as it requires looping over every element of the array. `max`\
    \ might be implemented as a loop internally, but it's still a loop. `findmax`\
    \ is probably implemented in C and might be faster if you need something other\
    \ than a built-in function, but I wouldn't count on it.\n<|/ c |>\n<| c |>\n`findmax`\
    \ is implemented as a loop. The point is that if you need to find the element\
    \ closest to another element of the same array, then the built-in `findmax` isn't\
    \ a good choice.\n<|/ c |>\n<| c |>\n: I believe the point is that if you need\
    \ to find the element closest to another element of the same array, then the built-ins\
    \ aren't a good choice.\n<|/ c |>\n<| a dscore=2 tags=julia,performance,algorithm\
    \ |>\n<code>\nfindmax(arr::Vector{Int64})::Int64\n    largest = arr[1]\n    for\
    \ i in arr[2:end]\n        if i > largest\n            largest = i\n        end\n\
    \    end\n    largest\nend\n</code>\n<|/ a |>\n<| c |>\nThis isn't quite what\
    \ OP asked for. `findmax` returns the value with the maximum value, not the value\
    \ which is closest to it.\n<|/ c |>\n<| a dscore=2 tags=julia,performance,algorithm\
    \ |>\nHere is an example with different approaches. First, an array:\n<code>\n\
    julia> a = [5,10,15,20,25,30]\n10-element Vector{Int64}:\n  5\n 10\n 15\n 20\n\
    \ 25\n 30\n</code>\nWe want to find the element which is closest to its predecessor\
    \ in the array. Here are the different approaches:\n<code>\njulia> using BenchmarkTools",
  "    if arr.length == 1\n        return arr.first\n    elseif arr.last == arr.first\
    \ + 1\n        return -1\n    else\n        return arr.first\n    end\nend", " \
    \   arr.max\nend", "    largest = 0\n    for i \u2208 arr \n        if i <= arr[i-1]\
    \ \n            largest = i\n        else \n            largest = i\n        \
    \    \n    return largest\nend\n</cell>\n<code language=julia-0.6>\n@time can_arrange([1,\
    \ 4, 3, 2, 5, 6, 7, 8])\n</cell>\n<code language=julia-0.6>\n@time can_arrange(1:1000)\n\
    </cell>\n<text>\nFind the second largest element in a vector", "    largest =\
    \ arr[1]\n    largestIdx = 1\n    for el in arr[2:end]\n        if el < largest\
    \ \n            largest = el\n            largestIdx = el\n        else\n    \
    \        break\n    end\n    return largestIdx\nend", "    largest = findfirst(x\
    \ -> x <= arr[end], arr)\n    largest = findlast(x -> x <= arr[end], arr)\n  \
    \  if largest == -1\n        largest = length(arr)\n    end\n    largest\nend\n\
    </code>\n<|/ a |>\n<| a dscore=1 tags=julia,arrays,algorithm |>\nA recursive version\
    \ could be implemented as below\n<code>", "    if arr.head < arr.tail[1] \n  \
    \      return -1\n    return arr.head - 1\nend", "\tfor i in 1:length(arr)\n\t\
    \tif arr[i-1] > arr[i]\n\t\t\treturn i\n\t\tend\n\tend\n\treturn -1\nend\n@testset\
    \ \"Sorting and indexing\" begin\n\t@test can_arrange([1, 4, 3, 2]) == 3\n\t@test\
    \ can_arrange([1, 4]) == 1\n\t@test can_arrange(range(3)) == -1\nend", "    l\
    \ = length(arr)\n    if l == 0\n        return -1\n    \n    # find index of the\
    \ first element which is <= to the current element\n    first = find(arr \u2264\
    \ arr[end])\n    if first == nothing\n        return -1\n    \n    # loop until\
    \ the first element >= to the current element\n    i = first\n    while arr[i]\
    \ \u2264 arr[first]\n        i = i + 1\n    end\n    \n    if i - 1 < l\n    \
    \    return i - 1\n    end", "    for i=2:length(arr)\n        if arr[i-1] >=\
    \ arr[i]\n            return i-1\n        end\n    end\n    return -1\nend\n</cell>\n\
    <code language=julia-1.3>", "    arr2 = copy(arr)\n    flag = 1\n    last = arr2[end]\n\
    \    for i in arr2\n        if i > last\n            flag = 0\n            last\
    \ = i\n        end\n    end\n    return flag ? last : -1\nend", "    largest =\
    \ 0\n    largest = 1\n    for i in arr\n        if i > largest\n            largest\
    \ = i\n        end\n    end\n    return largest\nend\n</cell>\n<code language=julia-1.0>\n\
    @time can_arrange(1:100000);\n</cell>\n<text>\nExercise 3", "    largest = Inf\n\
    \    smallest = Inf\n    for i in arr \n        largest = max(i) if i > largest\
    \ else i\n        smallest = min(i) if i < smallest else i\n    end\n    largest\n\
    end\n</code>\n<|/ a tags=julia |>\n<| c |>\nI'm glad you posted the answer here,\
    \ as I wasn't aware of this tool.\n<|/ c |>\n<| a dscore=0 |>\nI believe the accepted\
    \ solution is more efficient (because it's O(n) instead of O(n^2)), but here is\
    \ another approach, using findlast() from IteratorTools.jl\n<code>\nusing IteratorTools",
  "    if length(arr) == 0 || arr[0] != arr[1] \n        return -1\n    end\n    i\
    \ = 2\n    while i < length(arr) \n        if arr[i] > arr[i-1] \n           \
    \ return i\n        end\n        i += 1\n    end\n    return -1\nend\n\"\"\"\n\
    \    Given a vector containing unique integers sorted in descending order, \n\
    \    return the index of the element which appears second in the vector.", " \
    \ local i=2\n  local max=arr[i]\n  while i < length(arr) do \n    if arr[i] <\
    \ max then \n      max=arr[i] \n    else \n      if arr[i-1] > max then \n   \
    \     max=arr[i-1]\n      end\n    end\n    i=i+1\n  end\n  if max==arr[i-1] then\
    \ return -1 else return i end\nend\n</cell>\n<code language=julia-1.5>", "   \
    \ idx = -1\n    for i in 1:length(arr)\n        if i < idx\n            idx =\
    \ i\n        elseif i > idx\n            idx = i\n        end\n    end\n    return\
    \ idx\nend\n</cell>\n<code language=julia-1.0>\n@assert can_arrange(range(1,10))==9\n\
    @assert can_arrange(range(1,10,2))==3\n</cell>\n<text>\nGreedy Algorithm\nThe\
    \ \"greedy\" version of an algorithm is one in which we repeatedly consider an\
    \ alternative that results in less work. The alternative we consider is called\
    \ the \"best so far\" because it is the one that gives us the best possible result.\
    \ Greedy algorithms can be quite intuitive once you get the hang of it! Once you\
    \ are familiar with the idea of finding the best solution, it is time to write\
    \ a function to implement greedy algorithms. There are two versions of the greedy\
    \ algorithm. One uses dynamic programming, and the other uses recursion. Since\
    \ we already implemented dynamic programming in can_arrange, we can implement\
    \ the greedy version in can_arrange_greedy!", "    i, idx = 0, 1\n    while idx\
    \ < length(arr)\n        if arr[idx] < arr[i]\n            idx = idx + 1\n   \
    \     else\n            if idx == i\n                return i\n            else\n\
    \                return idx\n        end\n        i = i + 2\n    end\n    return\
    \ -1\nend", "    largest = Int.max(arr)\n    largest = Int.max(largest)\n    largest\
    \ = Int.max(largest)\n    largest = Int.max(largest)\n    largest = Int.max(largest)\n\
    \    largest = Int.max(largest)\n    return largest\nend", "    \n    # Return\
    \ index of the first element that isn't greater than or equal to \n    # the element\
    \ immediately preceding it. If no such element exists then return -1\n    \n \
    \   i, max = 0, arr[1]\n    \n    for el in arr[2:end]\n        if el > max\n\
    \            max = el\n            i = end\n        end\n    end\n    return i\n\
    end", "    last = 0\n    for i in arr\n        if i >= last\n            last\
    \ = i\n        else\n            return -1\n        end\n    end\n    return last\n\
    end", "    largest = -1\n    for value in arr\n        if value <= largest\n \
    \           return -1\n        largest = value\n    return largest\nend\n</code>\n\
    <|/ a tags=julia,function |>\n<| c |>\nWhy do you need to use `arr[1]` instead\
    \ of `largest` in the first place? Also, you can replace `if arr[1] <= largest`\
    \ with `if arr[1] > largest`\n<|/ c |>\n<| c |>\n`arr[1]` is faster than `largest`\
    \ because `largest` is an argument passed to the function, which may or may not\
    \ be initialized to `arr[1]` (if that argument is not passed to `can_arrange`\
    \ at all).\n<|/ c |>\n<| a dscore=0 tags=julia,function |>\nI wrote this simple\
    \ version, which I think is simpler and is efficient:\n<code>", "    largest =\
    \ Int64(0)\n    for el in arr\n        if el > largest\n            largest =\
    \ el\n        end\n    end\n    return largest\nend\n</cell>\n<text>\nAnd now\
    \ for practice:", "    n = length(arr)\n    if n <= 1 \n        n \n    elseif\
    \ n == 2 \n        arr[1] - arr[0] \n    elseif n > 2 \n        prev_idx = arr[1]\
    \ - arr[0]\n        return max((prev_idx + 1) * n - arr[1], -1) \n    end\nend\n\
    </cell>\n<text>\nAs a final function, we can now write our own arrange function\
    \ which behaves\nthe same as Python's list.sort method", "    pos = findfirst(x\
    \ -> x > arr[pos+1], 1:length(arr))\n    if pos <= length(arr)\n        pos\n\
    \    else\n        -1\n    end\nend\n</cell>\n<text>\nQ. Implement a function\
    \ which returns all indices of an element which is\ngreater than or equal to the\
    \ given element.", "    \n    for i=1:length(arr)\n        if arr[i-1] > arr[i]\n\
    \            return i-1\n        end\n    end\n    return -1\nend\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that returns True if the given array contains all\
    \ of the elements of another array. \nYou can do this in O(n) time where n is\
    \ the number of elements in the first array.\nFor example, if you have an array\
    \ [2, 6, 9] and another array [6, 4, 3] then this function should return True.",
  "    return find(arr .!= arr .[i-1]) + 1 \nend", "    if arr[1] == arr[2] \n   \
    \     \n        return -1\n    end", "    for a in arr\n        if a <= arr[a-1]\n\
    \            return -1\n        end\n    end\n    return length(arr)\nend", " \
    \   for i in length(arr):-1:1\n        if arr[i] > arr[i-1]\n            return\
    \ i\n    return -1\nend\n\"\"\"Create a function which returns the index of the\
    \ largest element which is\n    greater than or equal to the element immediately\
    \ preceding it. No such element\n    exists then return -1. The given vector will\
    \ not contain duplicate values.\n    If there are multiple elements which are\
    \ equal, then the smaller of the first\n    such element and the largest is returned.\
    \ \n    \n    Examples:\n    >>> can_arrange([1, 2, 4, 3, 5])\n    4\n    >>>\
    \ can_arrange([1, 2, 3])\n    -1\n    \"\"\"", "    if length(arr)==0 \n     \
    \   return -1 \n    end", "    largest = -1\n    largestIndex = -1\n    for ix\
    \ in arr:\n        if ix < largest and ix != largest:\n            return -1\n\
    \        largest = ix\n        largestIndex = ix\n    return largestIndex", " \
    \   i = 1\n    while i <= length(arr)\n        if arr[i-1] > arr[i]\n        \
    \    return i\n        else\n            i += 1\n        end\n    end\n    return\
    \ -1\nend\n</cell>\n<code language=julia-0.3>\n\"\"\"Return an array containing\
    \ all the numbers from 1 to n without duplication.\"\"\"", "    high_index = 0\n\
    \    for element in arr\n        if element < arr[high_index]\n            high_index\
    \ += 1\n        elseif element > arr[high_index]\n            return high_index\n\
    \        end\n    end\n    return -1\nend\n</cell>\n<code language=julia-1.5>",
  "    largest = -1\n    for k in 1:length(arr)\n        if arr[k] <= arr[largest]\n\
    \            largest = k\n        else\n            break\n        end\n    end\n\
    \    largest\nend", "    \n    i = find(arr .> arr[-length(arr)], 1)[1]\n    if\
    \ i==length(arr)\n        -1\n    else\n        i\n    end\nend\n</cell>\n<text>\n\
    3. Write a recursive function which takes a vector of n elements and returns\n\
    \    the maximum element in the vector which is not less than or equal to the\n\
    \    first element. If there is no such element then return -1.", "    for i in\
    \ 1:length(arr)\n        if arr[i] < arr[i-1] \n            return i\n       \
    \ end\n    end\n    return -1\nend\n</cell>\n<text>\nThis code is a bit different\
    \ from the previous one. Let's discuss what it does first.", "    arr_length =\
    \ length(arr)\n    maximum = arr[1]\n    for i in 2:(arr_length-1)\n        maximum\
    \ = maximum if maximum > arr[i] else arr[i]\n    end\n    return maximum\nend",
  "    if length(arr)==0 \n        return -1\n    return argmax(arr) - arr[argmax(arr)]\n\
    end", "  if length(arr)==0 return -1\n  last=arr[1]\n  for i=2:length(arr)\n \
    \   if arr[i]>last\n      return i-1\n    else\n      last=arr[i]\n  end\nend",
  "    largest = -1\n    largest = findlast(arr .* (arr .!= largest), largest)\nend\n\
    </cell>\n<cell>\n@doc cannot_arrange", "    for i in 1:length(arr)-1 \n      \
    \  if arr[i] < arr[arr[i]-1] \n            return i \n        end\n    end\n \
    \   return -1\nend\n</cell>\n<code language=julia-0.4>\n# Scratch Cell\n\"\"\"\
    \nWrite a function, `can_replace`, which takes a vector and a target value,\n\
    and returns a Boolean indicating whether such a vector contains a\ntarget value\
    \ which is equal to the target value but also preceded by another\nvalue which\
    \ is less than the target value. If such a target value exists\nthen return True,\
    \ otherwise return False.", "    i=arr[1]\n    \n    for i in arr[2:end]\n   \
    \     if i<=arr[1]\n            return i\n    end\n    return -1\nend\n</cell>\n\
    <code language=julia-0.6>\narrange(data)\n</cell>\n<code language=julia-0.6>",
  "    len = length(arr)\n    if len == 0 return -1\n    last = arr[1]\n    for i\
    \ in 2:len\n        if arr[i] > last \n            return i-1\n        end\n \
    \       last, last, = arr[(i-1):i]\n    end\n    return -1\nend", "    arr.sort!\n\
    \    largest = arr[end]-1\n    for i in arr[end:-1]\n        if i > largest\n\
    \            largest = i\n        end\n    end\n    return largest\nend\n</cell>\n\
    <code language=julia-1.5>", "    # Write your code in Julia 0.6\n    for i = 2:length(arr)\n\
    \        if arr[i-1] < arr[i]\n            return i\n        end\n    end\n  \
    \  return -1\nend\n</cell>\n<cell>\n@testset \"can_arrange\" begin\n    @test\
    \ can_arrange([1, 2, 3]) == -1\n    @test can_arrange([5, 1, 2, 3, 4, 6]) == 6\n\
    \    @test can_arrange([1, 2, 4, 3, 5]) == 3\nend\n</cell>\n<text>\nQuestion 5.2\
    \ Write a Julia function (can_arrange_if!) for arranging a vector such that the\
    \ elements less than the element immediately preceding it are moved towards the\
    \ end of the vector. If there are no such elements, the vector will be left unchanged.",
  "    largest = -1\n    largestIndex = -100\n    for index in arr\n        if index\
    \ >= largest\n            largest = index\n        elseif largest == -1 && index\
    \ > largest\n            largest = index\n        elseif largest == index\n  \
    \          largestIndex = largest\n        end\n    end\n    return largestIndex\n\
    end\n\"\"\"\nCreate a function which returns the smallest index of an element\
    \ which\n    is not smaller than or equal to the element immediately following\
    \ it. If\n    no such element exists then return -1. The given vector will not\
    \ contain\n    duplicate values.", "    pos = 1\n    largest = -1\n    for el\
    \ in arr\n        if el < arr[pos-1]\n            pos = pos+1\n        else\n\
    \            if el > largest\n                largest = el\n            end\n\
    \        end\n    end\n    return largest\nend\n</cell>\n<text>\nExercise 5: Find\
    \ The Next Greater Element\nGiven the vector [1, 2, 4, 3, 5] find the index of\
    \ the next greater element which\nis greater than or equal to 3.", "    i = 0\n\
    \    while i < (length(arr) - 1) \n        if arr[i] < arr[i + 1] \n         \
    \   return i\n        end \n        i += 1\n    end\n    return -1\nend\n</cell>\n\
    <text>\nExercise 3 - Write a function to return the first index of every element\
    \ which is\n    greater than a given value. If there are two or more equal elements\
    \ then return all\n    indices. If there are no elements greater than the value\
    \ then return -1. If\n    the value is not included in the array then return -1.",
  "    if arr.length == 0\n        return -1\n    end\n    largest = first(arr[1 :\
    \ (end - 1)])\n    if last == largest\n        return -1\n    else\n        return\
    \ first(arr[(end - 1):end])\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [1, 2, 3, 4, 5]\n</cell>\n<code language=julia-1.5>\ncan_arrange(arr)\n\
    </cell>\n<text>\nWrite a function to compute the length of the longest increasing\
    \ subsequence in the given array. The function should return -1 if the given array\
    \ is empty. The function should work for any type of array.", "    if arr==[]\n\
    \        throw(ArgumentError(\"No array provided\"))\n    end\n    if arr[1]>arr[2]\n\
    \        return arr[2]\n    else\n        return arr[1]\n    end\nend\n</code>\n\
    <|/ a tags=julia,sorting,arrays |>\n<| c |>\nThe code works but is very slow.\
    \ On a 100 x 1000 random array it took me 5.939529 seconds to execute which is\
    \ not acceptable.\n<|/ c |>\n<| c |>\nFor performance comparisons, could you post\
    \ your original problem definition? That would probably help a lot.\n<|/ c |>\n\
    <| c |>\nI have added my original problem definition to my original question\n\
    <|/ c |>\n<| c |>\nI see two things that might be the issue: 1. `sort` takes `stable`\
    \ as default argument but your original example is not stable and thus this would\
    \ result in different outputs. 2. Your sorting function could be very slow. Can\
    \ you try `@time sort(arr)[1]` to see if it makes a difference?\n<|/ c |>\n<|\
    \ c |>\nStill the same time as my original problem. The issue is that the code\
    \ I have written needs to return an Int64 and sort the array and then return the\
    \ largest element which is not greater than or equal to the element before it\n\
    <|/ c |>\n<| a |>\nAs noted by, this can be done in O(n) using the sort function.\n\
    I wanted to also point out that your original algorithm doesn't actually work.\
    \ The following are my results and code. It does actually work, however.\n<code>",
  "    if arr.size == 0 \n        return -1\n    \n    index = arr.size - 1\n    while\
    \ index >=0 \n        if arr[index] <= arr[index-1]\n            return index\n\
    \        else\n            index -= 1\n    end\n    return index\nend\n    ",
  "    largest = 0\n    for el in arr\n        if el >= arr[largest]\n           \
    \ largest = el\n        end\n    end\n    return largest\nend", "    if length(arr)\
    \ == 1\n        return -1\n    end\n    if length(arr) == 2\n        if arr[1]\
    \ > arr[2]\n            return 1\n        elseif arr[1] < arr[2]\n           \
    \ return 2\n        else\n            return 3\n        end\n    end\n    largest\
    \ = -1\n    largestIdx = 1\n    for i in 1:length(arr)\n        if arr[i] > arr[largestIdx]\n\
    \            largestIdx += 1\n        elseif arr[i] < arr[largestIdx]\n      \
    \      largestIdx = i\n        end\n    end\n    return largestIdx\nend\n\"\"\"\
    \nCreate a function which returns the element in the given vector that is\ngreatest\
    \ when the rest of the elements are sorted in descending order.", "    # O(n)\
    \ but we assume that duplicates are allowed\n    largest = Int(-1)\n    for i\
    \ in length(arr):-1\n        if arr[i] > arr[i+1]\n            if largest == Int(-1)\n\
    \                largest = i\n            else\n                largest = largest\n\
    \        end\n    end\n    return largest\nend\n</cell>\n<code language=julia-1.5>",
  "\tindx = 1\n\twhile indx < length(arr)\n\t\tindx += 1\n\t\tif arr[max(indx - 1,\
    \ 0)] < arr[min(indx + 1, length(arr))] # arr[indx] < arr[max(indx-1, 0)] or arr[indx]\
    \ > arr[min(indx+1,length(arr))]\n\t\t\treturn indx\n\t\tend\n\tend\n\treturn\
    \ -1\nend\n@testset \"Array Functions\" begin\n\tarr1 = rand(10)\n\tarr2 = arr1\n\
    \tfor indx in arr1\n\t\tarr2[indx] = 0\n\tend\n\t@test can_arrange(arr1) == length(arr2)\n\
    \t@test can_arrange(arr1) == can_arrange(arr2) # check that equal vectors are\
    \ the same\nend\nend", "    arr = copy(arr)\n    largest = find(arr .> arr .-\
    \ 1)\n    return if largest < 0 \n    else largest\nend\n</cell>\n<code language=julia-0.6>\n\
    arr = [1, 2, 4, 3, 5]\nlargest = can_arrange(arr)\n</cell>\n<code language=julia-0.6>\n\
    arr = [1, 2, 4, 3, 5]\nlargest = can_arrange(arr)\n</cell>\n<code language=julia-0.6>\n\
    arr = [1, 2, 4, 3, 5]\nlargest = can_arrange(arr)\n</cell>\n<code language=julia-0.6>\n\
    arr = [1, 2, 4, 3, 5]\nlargest = can_arrange(arr)\n</cell>\n<code language=julia-0.6>\n\
    arr = [1, 2, 4, 3, 5]\nlargest = can_arrange(arr)\n</cell>\n<code language=julia-0.6>\n\
    arr = [1, 2, 4, 3, 5]\nlargest = can_arrange(arr)\n</cell>\n<code language=julia-0.6>\n\
    arr = [1, 2, 4, 3, 5]\nlargest = can_arrange(arr)\n</cell>\n<text>\nPractice Problems",
  "    if length(arr)<=0\n        return -1\n    if arr[1]>arr[-2]\n        return\
    \ -1\n    index = find_index(arr)\n    if index>=0\n        return index\n   \
    \ end=arr\n    last=last(arr)\n    length=length(arr)\n    while last==arr[end]\n\
    \        push!(end,last)\n        last=last(end)\n    end\n    push!(end,last)\n\
    \    return length(arr)-length(end)+1\nend", "    largest = -1\n    for ix in\
    \ 1:length(arr)-1\n        if arr[ix] < arr[ix + 1]\n            largest = ix\n\
    \        end\n    end\n    return largest\nend\n</cell>\n<text>\nLet's test this\
    \ out!", "    for i=1:length(arr)-1\n        if arr[i+1] < arr[i] \n         \
    \   return i\n        end\n    end\n    return -1\nend\n</cell>\n<cell>\n@assert\
    \ can_arrange([1, 2, 4, 3, 5]) == 3\n@assert can_arrange([1, 2, 3]) == -1\n</cell>\n\
    <text>\nProblem 7: Can the arrangement be partitioned into two parts?\nWrite a\
    \ function that takes two vectors as input, and returns a boolean indicating whether\
    \ they can be partitioned into two disjoint subsets. Each vector will contain\
    \ at least one element and will contain at most one element that is greater than\
    \ or equal to the element immediately preceding it.", "   if length(arr) == 0\
    \ \n       return -1 \n   end\n   \n   for idx in 1:length(arr)\n       if arr[idx]\
    \ > arr[arr[idx-1]] \n           return idx \n       end\n   end\n   \n   return\
    \ -1\nend", "    max = -1\n    for idx in 2:length(arr)\n        if idx > max\n\
    \            max = idx\n        end\n    end\n    return max\nend", "    largest\
    \ = 0\n    for x in arr\n        if largest<x \n            largest=x\n      \
    \  end\n    end\n    return largest\nend\n</cell>\n<code language=julia-1.5>\n\
    # Test function\n@assert can_arrange([1,2,4,3,5]) == 3\n@assert can_arrange([1,2])\
    \ == -1\n@assert can_arrange([1,5,4,3,2]) == 3\n</cell>\n<text>\n5.4 Create and\
    \ use a function to find the maximum and minimum values of a vector.", "    \n\
    \    max = -1\n    for i in 1:length(arr)\n        if arr[i] > arr[max]\n    \
    \        max = i\n        end\n    end\n    return max\nend\n</cell>\n<cell>\n\
    @test can_arrange([1, 2, 4, 3, 5]) == 3\n@test can_arrange([1, 2, 3]) == -1\n\
    </cell>\n<text>\n7. Write a function to find all numbers in a given range where\
    \ the sum of the numbers is divisible by 7 and where the difference between the\
    \ largest number and the smallest number is less than 14. \nHint: You'll need\
    \ to use the modulo operator in combination with the sum function.", "    len\
    \ = length(arr)\n    largest = arr[len-1]\n    for i in len-1:-1:1\n        if\
    \ arr[i] > largest\n            largest = arr[i]\n        else\n            return\
    \ i\n        end\n    end\n    return -1\nend\n</code>\n<|/ a tags=arrays,sorting,julia\
    \ |>\n<| a tags=arrays,sorting,julia dscore=0 |>\nUsing \"vsort\" (or its faster\
    \ \"vsort!\") with custom comparison function :\n<code>", "   if length(arr)==1\n\
    \     return 1\n   end\n   largest = -1\n   for i=2:length(arr)\n     if arr[i-1]\
    \ > arr[i]\n       if largest < 0\n         largest = i\n       end\n     end\n\
    \   end\n   if largest == -1\n     return -1\n   end\n   return largest\nend\n\
    </cell>\n<text>\nExercise 3\nCreate a function which returns the size of the vector\
    \ or -1 if it is\n    an empty vector. Hint: use the function length().", "  \
    \  if arr.length < 2\n        return -1\n    end\n    max = arr[1]\n    for i\
    \ in arr[2:end]\n        if i <= max\n            max = i\n        else\n    \
    \        return end\n    end\n    return max\nend\n</cell>\n<text>\nNow let's\
    \ see it working on some example inputs:", "    for i in 2:length(arr) \n    \
    \    if arr[i] > arr[i-1] \n            return i-1 \n        end \n    end\n \
    \   return -1\nend\n    \"\"\"\n    \n    # Return the largest index of an element\
    \ which is not greater than\n    # or equal to the element immediately preceding\
    \ it. If no such element\n    # exists then return -1.\n    return -1\nend", "\t\n\
    \tlast_value = arr[1]\n\ti = 1\n\tfor element in arr[2:end]\n\t\tif element >=\
    \ last_value \n\t\t\tbreak\n\t\tlast_value = element\n\t\ti = i + 1\n\t\n\tif\
    \ i == length(arr)\n\t\t-1\n\telse\n\t\ti\n\tend\nend\n</cell>\n<code language=julia-1.5>\n\
    @time can_arrange([10, 40, 20, 50])\n@time can_arrange([10, 40, 20, 30, 50])\n\
    @time can_arrange([10, 20, 40, 30, 50])\n@time can_arrange([10, 20, 30, 40, 50])\n\
    @time can_arrange([10, 20, 30, 40, 50, 60])\n@time can_arrange([10, 20, 30, 40,\
    \ 50, 60, 70])\n@time can_arrange([10, 20, 30, 40, 50, 60, 70, 80])\n</cell>\n\
    <text>\nTask 3: Find the first three consecutive elements that equal each other",
  "    maximum = maximum_in_list(arr)\n    if maximum == -1\n        return -1\n \
    \   else\n        return maximum(maximum(arr) - arr - 1)\n    end\nend\n</cell>\n\
    <code language=julia-1.3>", "     \n    if length(arr) == 0 \n        return -1\n\
    \    end\n    largest = 0\n    largestIndex = 0\n    lastVal = -1\n    for i in\
    \ arr[1 : end-1]\n        if i > lastVal \n            lastVal = i\n         \
    \   largest = i\n            largestIndex = i - 1\n        else\n            largest\
    \ = largest\n            if i != largestIndex\n                largestIndex =\
    \ i\n            end\n        end\n    end\n    if largestIndex == -1 \n     \
    \   return -1\n    else\n        return largestIndex\n    end\nend", "    largest\
    \ = first(arr)\n    largestInd = firstindex(arr)\n    largestInd -= 1\n    if\
    \ largest == 0\n        return 0\n    while largestInd > 0\n        if arr[largestInd]\
    \ > largest\n            largestInd -= 1\n            largest = arr[largestInd]\n\
    \        else\n            largestInd -= 1\n        end\n    end\n    largestInd\
    \ -= 1\n    return largestInd + 1\nend", "    len = length(arr)\n    if len <\
    \ 2 \n        return -1\n    \n    idx = 1\n    largest = arr[1]\n    idx2 = 1\n\
    \    while idx2 < len\n        if arr[idx2] < largest\n            largest = arr[idx2]\n\
    \            idx2 = idx2 + 1\n        else\n            idx2 = idx2 + 1\n    \
    \    end\n    end\n    return idx2\nend\n</cell>\n<code language=julia-1.2>\n\
    @time can_arrange([x for x in 1:100]);\n</cell>\n<text>\nExercise 2", "    arr\
    \ = sort(arr)\n    idx = findlast(arr .> arr[-end])\n    return idx != -1 ? idx\
    \ : -1\nend\n</cell>\n<text>\nThe function above returns a number which indicates\
    \ that it is possible to arrange the given numbers in ascending order. For example,\
    \ it is possible to arrange [1,2] and [3,4] to [1,2,3,4,5]. Another example is\
    \ [1,3,5] and [2,4,6] to [1,3,5,2,4,6]. The function also returns -1 if no such\
    \ arrangement is possible.", "    if arr.length == 1 \n        return -1 \n  \
    \  \n    if arr[1] < arr[2] \n        return -1 \n    \n    return 2 \nend", " \
    \   # Your code here\n    return \nend\n</cell>\n<code language=julia-1.1>\n@code_warntype\
    \ can_arrange(vec)\n</cell>\n<text>\nQuestion 14\nWrite a function which returns\
    \ the largest index of an element which is not less than or equal to the element\
    \ immediately preceding it. \nIf no such element exists then return -1. The given\
    \ vector will not contain duplicate values.", "    last = lastindex(arr)\n   \
    \ if last == -1\n        -1\n    elseif arr[last] > arr[last-1]\n        last\n\
    \    else\n        -1\n    end\nend\n</cell>\n<code language=julia-1.6>\n@assert\
    \ can_arrange([1,2,4,3,5]) == 3\n@assert can_arrange([1,2,3]) == -1\n</cell>\n\
    <code language=julia-1.6>", "  i = 1 \n  while arr[i] != arr[i - 1]\n    i = i\
    \ + 1\n  end\n  i\nend\n</cell>\n<code language=julia-1.5>\ncan_arrange([1,2,3,4,5])\n\
    </cell>\n<text>\nThe above function is an incomplete implementation of the above\
    \ pseudocode. Can you complete it?", "  local largest = arr[end]\n  for i = end\
    \ - 1, 1, -1 do \n    if arr[i] > largest then largest = arr[i] end\n  end\n \
    \ return largest\nend\n</cell>\n<code language=julia-0.5>\n# We define the test\
    \ vector\narr = ones(Int64, (1,7))\narr[end,:] = [1,1,1,4,5,7,8]\narr[end,2:end]\
    \ = [8,5,4,3,2,1]\narr\n</cell>\n<code language=julia-0.5>\n# We can now find\
    \ the largest index of an element which is greater than\n# or equal to the element\
    \ immediately preceeding it\ncan_arrange(arr)\n</cell>\n<code language=julia-0.5>\n\
    arr\n</cell>\n<code language=julia-0.5>\n# We can now find the largest index of\
    \ an element which is greater than\n# or equal to the element immediately preceding\
    \ it\ncan_arrange(arr)\n</cell>\n<code language=julia-0.5>\narr\n</cell>\n<code\
    \ language=julia-0.5>\n# We can now find the largest index of an element which\
    \ is greater than\n# or equal to the element immediately preceding it\ncan_arrange(arr)\n\
    </cell>\n<code language=julia-0.5>\narr\n</cell>\n<code language=julia-0.5>\n\
    # We can now find the largest index of an element which is greater than\n# or\
    \ equal to the element immediately preceding it\ncan_arrange(arr)\n</cell>\n<code\
    \ language=julia-0.5>\n# We can now find the largest index of an element which\
    \ is greater than\n# or equal to the element immediately preceding it\ncan_arrange(arr)\n\
    </cell>\n<code language=julia-0.5>\narr\n</cell>\n<code language=julia-0.5>\n\
    # We can now find the largest index of an element which is greater than\n# or\
    \ equal to the element immediately preceding it\ncan_arrange(arr)\n</cell>\n<code\
    \ language=julia-0.5>\narr\n</cell>\n<text>\nExercise: Can you write another function\
    \ which returns the last index of an element which is greater than or equal to\
    \ the element immediately preceding it? This function should return the largest\
    \ index of an element which  is not greater than or equal to the element immediately\
    \ preceding it.", "    \n    len = length(arr)\n    if len == 0\n        return\
    \ -1\n    end\n    \n    largest = arr[len-1]\n    \n    for i in 1:len\n    \
    \    if arr[i] > largest\n            largest = arr[i]\n        end\n    end\n\
    \    \n    return len\nend", "    for i=1:length(arr)-1 \n        if arr[i] >\
    \ arr[i-1] \n            return i\n        end \n    end \n    return -1 \nend\
    \ \n</cell>\n<text>\nExercise 5", "    largest = arr[1]\n    largestIdx = 1\n\
    \    for idx in 2:length(arr)\n        if arr[idx] > largest\n            largest\
    \ = arr[idx]\n            largestIdx = idx\n        end\n    end\n    return largestIdx\n\
    end\n</cell>\n<code language=julia-1.5>\ncan_arrange([1, 2, 4, 3, 5])\n</cell>\n\
    <code language=julia-1.5>", "    \"\"\"\n    Create an anonymous function which\
    \ returns the index of the largest\n    value not greater than or equal to the\
    \ element immediately preceding it. If\n    no such value exists, return -1.\n\
    \    \"\"\"\n    max_index = -1\n    max_value = arr[1]\n    for i in 2:length(arr)\n\
    \        if arr[i] > max_value\n            max_value = arr[i]\n            max_index\
    \ = i\n        end\n    end\n    return max_index\nend", "    if arr.length ==\
    \ 0 || arr[0] ~= arr[1]\n        -1\n    end\n    \n    for i in 2\n        if\
    \ arr[i] > arr[i - 1]\n            return i - 1\n        end\n    end\n    return\
    \ -1\nend\n</cell>\n<code language=julia-1.3>", "   \n    if length(arr) == 0\
    \ \n        return -1 \n    \n    largest = arr[1] \n    for i in 2:length(arr)\
    \ \n        if arr[i] > largest \n            largest = arr[i] \n        end\n\
    \    end\n    \n    return largest\nend", "    # find the first element which\
    \ is greater than or equal to the previous element\n    last = nothing\n    for\
    \ (i,x) in enumerate(arr)\n        if last!=nothing && x > last \n           \
    \ continue \n        last = x\n    end\n    \n    # this element doesn't exist,\
    \ return -1\n    return -1\nend", "    largest=-1\n    largest1=0\n    largest2=0\n\
    \    largest3=0\n    for n in arr\n        if n > largest\n            largest\
    \ = n\n            largest1 = largest2\n            largest2 = largest3\n    \
    \    else\n            if n > largest1\n                largest1 = n\n       \
    \     elseif n > largest2\n                largest2 = n\n            else\n  \
    \              largest3 = n\n        end\n    end\n    return largest3\nend\n\
    </cell>\n<cell>", "    if arr[1] == arr[1] \n        can = -1\n        for i =\
    \ 2:length(arr) \n            if arr[i] > arr[i-1] \n                can = i \n\
    \            elseif can== -1\n                can = -1 \n            else \n \
    \               break\n            end \n        end \n        return can \n \
    \   else \n        return -1 \n    end \nend \n</cell>\n<text>\n4.2 Create a function\
    \ which returns the average of an array of integers", "    largest = 0\n    smallest\
    \ = size(arr)[1]\n    largest = smallest-1\n    for i = 1:size(arr)[1]\n     \
    \   if arr[i] > largest\n            largest = i\n        elseif arr[i] < smallest\n\
    \            smallest = i\n        else\n            return -1\n        end\n\
    \    end\n    return largest\nend", "    \n    if arr.head == arr.last\n     \
    \   return arr.last\n    \n    if arr.last == 0\n        return -1\n    \n   \
    \ arr.last\nend\n</cell>\n<code language=julia-1.0>", "    i = 0\n    max = -1\n\
    \    while i < size(arr)\n        if arr[i] > arr[i-1]\n            max = i\n\
    \        end\n        i += 1\n    end\n    return max\nend", "    \n    i = -1\n\
    \    \n    for j in arr[1:end-1]\n        if j <= arr[i]\n            i = j\n\
    \        else\n            break\n    end", "    if length (arr) == 1 \n     \
    \   return -1 \n    end", "    \n    if len(arr) <2 return -1\n    \n    local\
    \ maxix = -1\n    for i in 2:length(arr) \n        if arr[i] > arr[i-1] \n   \
    \         then maxix = i-1\n        end\n    end\n    \n    return maxix\nend\n\
    \"\"\"\n    \n    ", "    \n    i=0;\n    while i<length(arr)\n        if arr[i]\
    \ > arr[i-1]\n            return i\n        else\n            i=i+1\n        end\n\
    \    end\n    return -1\nend", "    lo=1\n    hi=length(arr)-1\n    while lo<=hi\n\
    \        if arr[lo]>=arr[hi]\n            lo+=1\n        else\n            hi-=1\n\
    \        end\n    end\n    return lo\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ dscore=1 |>\n<| c |>\nWhat is the reason for using `@everywhere` ?\n<|/ c |>\n\
    <| c |>\nI don't think `@everywhere` has an effect on performance.\n<|/ c |>\n\
    <| c |>\nI think it is bad practice, but it is nice to know about. Thanks for\
    \ sharing.\n<|/ c |>\n<| a dscore=1 tags=julia,sorting,arrays |>\nHere is an attempt\
    \ using Base.findlast, Base.searchsorted and Vector.subarray:\n<code>", "    largest\
    \ = 0\n    for idx in (1:length(arr)):\n        if arr[idx] > arr[idx-1]\n   \
    \         largest = idx\n        end\n    end\n    \n    return largest\nend",
  "    if arr.length == 0 \n        return -1\n    else\n        largest = arr[1]\n\
    \        for i in 2:arr.length\n            if arr[i] > largest \n           \
    \     largest = arr[i]\n            end\n        end\n        return largest\n\
    \    end\nend\n</cell>\n<code language=julia-1.3>\ncan_arrange([1, 2, 4, 3, 5])\n\
    </cell>\n<text>\nWe can easily rewrite this function as a vectorized function\
    \ using a broadcasting array operation on both vectors.", "    largest = Int64(-1)\n\
    \    for x in arr\n        if x < largest\n            largest = x\n        end\n\
    \    end\n    largest\nend", "    largest = -1\n    for idx in 1:length(arr)-1\n\
    \        if idx == 0 or arr[idx] > arr[largest-1]\n            largest = idx\n\
    \        else\n            return largest\n        end\n    end\n    return -1\n\
    end", "    i = 0\n    while i < length(arr) && arr[i] < arr[i-1]\n        i =\
    \ i+1\n    end\n    if i == length(arr)\n        return -1\n    end\n    while\
    \ i >= 1\n        if arr[i] >= arr[i-1]\n            return i\n        end\n \
    \       i = i-1\n    end\n    return i\nend", "    for idx=1:length(arr)\n   \
    \     if arr[idx] < arr[idx-1]\n            return idx\n        end\n    end\n\
    \    return -1\nend", "    largest = -1\n    for idx in 1:length(arr)\n      \
    \  if arr[idx] > arr[largest] \n            largest = idx\n        end\n    end\n\
    \    largest\nend\n</cell>\n<text>\nExercise", "    arr.sort()\n    return findlast(x\
    \ -> x > arr[1], arr) + 1\nend\n</cell>\n<code language=julia-1.5>", "    max_idx\
    \ = 0\n    for i in 1:length(arr)\n        if arr[i] > arr[i+1] \n           \
    \ break\n        else\n            max_idx = i\n        end\n    end\n    return\
    \ max_idx\nend", "    \"\"\"Create a function which returns the largest index\
    \ of an element which\n    is not greater than or equal to the element immediately\
    \ preceding it. If\n    no such element exists then return -1. The given vector\
    \ will not contain\n    duplicate values.", "    len = length(arr)\n    if len\
    \ == 0\n        return -1\n    else\n        largest = arr[1]\n        for i =\
    \ 2 to len-1\n            if arr[i] > largest\n                largest = arr[i]\n\
    \            else\n                return -1\n        end\n        return largest\n\
    \    end\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| c |>\nI added a more generic\
    \ implementation to my answer\n<|/ c |>\n<| c |>\nI actually wanted it to return\
    \ -1 if it did not find the largest index but I think yours does that just fine.\
    \ Thanks for teaching me something new today\n<|/ c |>\n<| a tags=julia,arrays\
    \ dscore=0 |>\nYou can simply use findmax with findfirst:\n<code>\njulia> findfirst(findmax(1:5),\
    \ (x) -> x > 3)\n5\n</code>\nIf nothing is found, the default return value is\
    \ the last element in the range. So, this works:\n<code>\njulia> findfirst(findmax(1:5),\
    \ (x) -> x > 5)\n-1\n</code>\n<|/ a |>\n<| a tags=julia,arrays |>\nI like's answer\
    \ above but if you're not happy with the default return value you can do this:\n\
    <code>", "    pos = 1\n    largest = -1\n    for i in arr\n        if i > largest\n\
    \            largest = i\n        else\n            pos = pos + 1\n        end\n\
    \    end\n    return pos\nend", "    sorted!(arr)\n    if arr[1] == arr[0]\n \
    \       return -1\n    end\n    low = arr[1]\n    for i in arr[1 .. end]\n   \
    \     if i < low\n            return -1\n        elseif i >= low\n           \
    \ low = i\n        end\n    end\n    return low\nend", "    n = length(arr)\n\
    \    return if n == 0 \n            then -1\n        elseif arr[n - 1] > arr[n\
    \ - 2] \n            then n - 2\n        elseif arr[n - 1] == arr[n - 2]\n   \
    \         then -1\n        else n - 1\n    end\nend\n</cell>\n<text>\nTask 6.\
    \ Implement a function to find all elements in the list which occur more than\
    \ once.", "    largest = arr.last\n    forall(arr[i + 1 ] == largest-arr[i] ->\
    \ arr[i+1] == largest) \n    largest\nend\n</cell>\n<code language=julia-0.6>\n\
    @assert can_arrange([1, 2, 4, 3, 5]) == 3\n@assert can_arrange([1, 2, 3]) == -1\n\
    </cell>\n<text>\nPart 6: More in Julia\nOkay, let's do a bit more with vectors.\
    \ We already know that vectors are like lists in Python, so let's see some more\
    \ of them.", "    i = length(arr)-1\n    largest = -1\n    while i != 0\n    \
    \    if arr[i-1] > arr[i]\n            largest = i-1\n            break\n    \
    \    elseif arr[i-1] < arr[i]\n            largest = i\n        elseif arr[i-1]\
    \ == arr[i]\n            largest = i\n        else\n            i = i-1\n    \
    \    end\n    end\n    largest\nend", "\tidx = 0\n\tfor i = 1:length(arr)\n\t\t\
    while idx <= length(arr)-i and arr[idx] <= arr[i]\n\t\t\tidx += 1\n\t\tend\n\t\
    \tif idx > length(arr)\n\t\t\treturn -1\n\t\tend\n\tend\n\treturn idx\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
