name: HumanEval_162_string_to_md5
language: jl
prompt: "\"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n\
  \    If 'text' is an empty string, return nothing.\n\n    >>> string_to_md5(\"Hello\
  \ world\")\n    \"3e25960a79dbc69b674cd4ec67a72c62\"\n    \"\"\"\nfunction string_to_md5(text::String)::Union{String,\
  \ Nothing} \n"
tests: "using Test\n\n@testset begin\n\ncandidate = string_to_md5;\n\t@test(candidate(\"\
  Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\")\n\t@test(candidate(\"\"\
  ) == nothing)\n\t@test(candidate(\"A B C\") == \"0ef78513b0cb8cef12743f5aeb35f888\"\
  )\n\t@test(candidate(\"password\") == \"5f4dcc3b5aa765d61d8327deb882cf99\")\nend\n"
completions: ["    if length(text) == 0 \n        nothing \n    else \n        MD5(string_to_bytes(text))\n\
    \    end\nend", "    if text.length > 0\n        hash = md5(text) # String ->\
    \ MD5\n        return hash\n    else\n        return Nothing\n    end\nend\n</cell>\n\
    <text>\nExercise 3\nDefine function read_file that reads a file from the local\
    \ filesystem.", "    md5 = Digests.MD5()\n    for c in text\n        md5.update(c)\n\
    \    return Digests.hexdigest(md5.digest())\nend", "    text |> string_to_str\
    \ |> to_md5\nend\n\"\"\"\n    Given a binary 'data', return its md5 hash equivalent\
    \ string.\n    If 'data' is an empty string, return nothing.", "    if length(text)\
    \ > 0\n        md5(text)\n    else\n        nothing\n    end\nend\n</cell>\n<text>\n\
    Exercise\nWrite a function named 'string_to_sha1' that does the same as the string_to_md5\
    \ function, but returns the hash in a sha1 hash string.", "    hash = MD5.new()\n\
    \    hash.update(text)\n    return hash.digest()\nend", "    str = if text ==\
    \ \"\" then Nothing else text end\n    str = MD5(string_to_bytes(text))\n    str\
    \ = string(to_chars(str))\n    \n    str = str[3 : -2]\n    return str\nend",
  "    if text == \"\" \n        return nothing \n    md5 = digests.md5(text) \n \
    \   return md5.hash\nend \n</code>\n<|/ a |>\n<| c |>\nThanks for your answer,\
    \ I've made changes to the original code but unfortunately, it doesn't work. I\
    \ tried to test it with `string_to_md5(\"Hello world\")` but it still says the\
    \ hash isn't correct. Perhaps its because of the string format?\n<|/ c |>\n<|\
    \ c |>\nWhat do you mean by \"string format\"?\n<|/ c |>\n<| c |>\n`text` isn't\
    \ an array, it is a string.\n<|/ c |>\n<| c |>\n`digests.md5` returns a `digest`\
    \ which is a `struct`, not a string.  So `md5.hash` will throw an error.  You\
    \ want to do `md5.hash()` instead.  Same with `md5.message`.\n<|/ c |>\n<| c |>\n\
    Thanks. I updated my answer. Sorry, I missed that detail.\n<|/ c |>\n<| a tags=julia\
    \ dscore=0 |>\nIf you have md5hash.jl already installed you can try this:\n<code>\n\
    using MD5", "    if text == \"\"\n        Nothing\n    else\n        digest =\
    \ Digest.new(\"md5\")\n        digest.update(text)\n        return digest.hexdigest()\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    Given a binary\
    \ file 'path', read its contents and return their md5 hash equivalent string.\n\
    \    If 'path' is an empty string, return nothing.\n    \n    >>> file_to_md5(\"\
    /home/roman/data/github/LASER/test/data/image01.tif\")\n    \"5acfdd0ca5edafa073ee8ea3ae67e05\"\
    \n\"\"\"", "    text = tostring(text)\n    md5er = hashlib.md5()\n    md5er.update(text)\n\
    \    return md5er.hexdigest()", "</code>\n<|/ a tags=hash,julia |>\n<| c |>\n\
    Thank you, that was a nice explanation. I also found that I could use function\
    \ string_to_md5(text) = MD5(Base.decode(Base.encode(text, \"utf-8\"))) and it\
    \ seems cleaner.\n<|/ c |>\n<| c |>\nyes that's another way of doing it. I'm going\
    \ to edit my answer above to include that solution as well.\n<|/ c |>\n<| a tags=hash,julia\
    \ |>\nI've found that hash() works as expected and returns an Int64 which can\
    \ then be directly used as a hash. \n<code>\njulia> hash(\"hello world\")\n1484305749\n\
    </code>\n<|/ a dscore=4 |>\n<| c |>\n`hash` returns a single Int64 with the value\
    \ of a 64 bit integer.  It's not a \"hash value\".\n<|/ c |>\n<| a |>\n<code>",
  "    hash = MD5(string_to_utf8(text))\n    return string_to_utf8(hash)\nend", " \
    \   if isempty(text)\n        nothing\n    else\n        md = hash_string(text(:))\n\
    \        nothing\n    end\nend\n\"\"\"\n    Given a list of strings 'strings',\
    \ return a string that is the md5 hash of all strings.", "    if text == \"\"\
    \ \n        return Nothing\n    md5 = Digest.from_file(\"md5-file:.\", string_to_bytes(text))\n\
    \    return md5.to_string()\nend", "    string = encode(text)\n    md5 = digest(string)\n\
    \    return md5.digest() \nend\n</cell>\n<code language=julia-1.2>\n\"\"\"\n \
    \   Given a binary file 'file' containing a text string, return the md5 hash of\
    \ that string\n    file -- a File object\n    md5 -- a md5 object\n    string\
    \ -- a string representation of the md5 digest\n\"\"\"", "    if text==\"\" \n\
    \        return nothing \n    else \n        return md5_hash($text)\n    end\n\
    end ", "    if text == \"\"\n        nothing\n    else\n        Digests.md5(text)\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    md5_to_string(string::String)::String",
  "    if length(text) > 0 \n        md5string = md5.new()\n        md5string.update(text)\n\
    \        md5string.digest()\n    else\n        Nothing\n    end\nend\n</code>\n\
    <|/ a |>\n<| a tags=hash,python,md5 dscore=5 |>\n<code>\nimport hashlib\nhashlib.md5((\"\
    Hello world\").encode('utf-8')).hexdigest()\n</code>\n<|/ a |>\n<| c |>\n`encode('utf-8')`\
    \ returns `bytes` not `str`\n<|/ c |>\n<| c |>\nThis won't work.  Strings in Python\
    \ 3 are unicode.  `encode('utf-8')` returns a bytes object.  So `hexdigest()`\
    \ won't work on a bytes object.\n<|/ c |>\n<| c |>\nThanks for the comment. I've\
    \ updated the answer to reflect that.\n<|/ c |>\n<| a dscore=4 tags=hash,python,md5\
    \ |>\nHere is a simple function that uses hashlib.md5() with hashlib's built-in\
    \ sha256() function.  It may be useful to some people.\n<code>\nimport hashlib\n\
    import hashlib", "    md5bytes = MD5Hash.new(text).as_bytes\n    \n    return\
    \ md5bytes if md5bytes else Nothing\nend", "    \"\"\"\n    Convert a string 'text'\
    \ to its md5 hash equivalent string.\n    If 'text' is an empty string, return\
    \ nothing.\n    \"\"\"", "    if isempty(text)\n        Nothing\n    else\n  \
    \      md5(text)\n    end\nend\n</cell>\n<code language=julia-0.6>\n@test string_to_md5(\"\
    Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\"\n</cell>\n<text>\n4.5 -\
    \ Exercise\nWrite a function that takes a binary string 'binary' and returns a\
    \ string of its md5 hash.\nFor example, given 'binary = \"AwAsOmEYQ==\"'\nYour\
    \ function should return '074aa9a28392ee6d557bcf044a1fb8b5'. \nThe md5 hash function\
    \ is md5(binary::String)::String where binary is your binary string.", "    if\
    \ text == \"\"\n        Nothing\n    else\n        md5(text)\n    end\nend\n</code>\n\
    <|/ a tags=julia dscore=1 |>\n<| a tags=julia |>\nYou can simply hash the string\
    \ with the builtin md5() function:\n<code>\nusing Base\nmd5(\"Hello world\")\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your response. Unfortunately,\
    \ this does not work. I get the following error message:", "    md5 = digest.md5(text)\
    \ \n    return \"d3ec8f3bf5fbb4dffa2e780bf0d6a44\"\nend\n</cell>\n<code language=julia-1.0>",
  "    if text == \"\" then return nothing\n    else md5(\"$text\")\n    end\nend\n\
    \"\"\"\n    Given a string, return a corresponding md5 hash string in the form\
    \ \n    \"3e25960a79dbc69b674cd4ec67a72c62\".", "    return md5(text) \nend",
  "    if text == \"\" \n        return nothing\n    else \n        hash = md5(text)\n\
    \        hash = hash.hexdigest()\n        return hash\nend \n</cell>\n<text>\n\
    Task 3 : Write a function\nGiven a string, calculate the md5 hash equivalent of\
    \ the string in hexadecimal and then return this value. Do not forget the hash\
    \ function is case sensitive.", "    if isempty(text)\n        nothing\n    else\n\
    \        hash_string(text, \"MD5\")\n    end\nend", "    md5 = digest(\"md5\"\
    , tostring(text))\n    if md5 != nohash\n        md5 = tostring(md5)\n    end\n\
    \    return md5\nend", "if text == \"\" \n    Nothing\nelse\n    Digests.md5(text)\n\
    end\nend\n\"\"\"\n    Given a string 'text', return its sha1 hash equivalent string.\n\
    \    If 'text' is an empty string, return nothing.", "    hasher = hashlib.md5()\n\
    \    hasher.update(text)\n    return hasher.hexdigest()", "</code>\n<|/ a |>\n\
    <| c |>\nthanks, this is what i was looking for\n<|/ c |>\n<| c |>\nFor anyone\
    \ using Julia 0.5 and above: note that this function has changed significantly\
    \ (as of 0.5.0) since this question was first asked.\n<|/ c |>\n<| c |>\n- thanks,\
    \ do you happen to know where I can get this new API?\n<|/ c |>\n<| c |>\nI believe\
    \ it was added at https://github.com/JuliaLang/julia/pull/11896 (probably version\
    \ 0.6?). Not sure which version it was, so it may or may not have been backported\
    \ to 0.5. I'm not sure. Sorry!\n<|/ c |>\n<| c |>\nI checked and you're right,\
    \ it wasn't backported to 0.5. Thanks for the heads-up!\n<|/ c |>\n<| a |>\nYou\
    \ can get the md5 hash string from any julia object using .hash, which returns\
    \ a String object.\n<|/ a dscore=5 tags=julia |>\n<| c |>\nThis should be the\
    \ right answer, since the other one is wrong. This will give you the hash of the\
    \ contents of the `String`, not of the object. So if you do `md5(1:10)`, you get\
    \ the same hash as `md5(\"123456789\")`\n<|/ c |>\n<| c |>\nThis answer has changed\
    \ since this question was posted. Here's an up-to-date answer now: https://stackoverflow.com/a/48759096/844422\n\
    <|/ c |>\n<| a dscore=5 tags=julia |>\nFor hashing files, I recommend you the\
    \ hash package. \n<code>\nusing JSON, Hashes\nusing JSON, Hashes", "    \"\"\"\
    \n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text'\
    \ is an empty string, return nothing.", "    return md5(text) if text != '' else\
    \ Nothing\nend", "    if text == \"\"\n        nothing\n    else\n        md5(text)\n\
    \    end\nend\n</cell>\n<code language=julia-0.4>\nstring_to_md5(\"\")\n</cell>\n\
    <text>\nExercise 2.6\nWrite a function 'string_to_sha1' which converts any given\
    \ string into its sha1 hash equivalent.", "    \"\"\"\n    Given a string 'text',\
    \ return its md5 hash equivalent string.\n    If 'text' is an empty string, return\
    \ nothing.\n    \"\"\"", "\"\"\"\n    Given a string 'text', return its md5 hash\
    \ equivalent string.\n    If 'text' is an empty string, return nothing.", "  \
    \  | Nothing\n    = if text == \"\"\n        nothing\n    else \n        Base.encode64(Base.digest(Base.sha256(text)))\
    \ \n    end\nend # function string_to_md5", "  if length(text) == 0 return nothing\n\
    \  else\n    try\n      digest = digest(\"md5\", text)\n    catch ArgumentError\n\
    \      return nothing\n    end\n    return digest\n  end\nend\n</cell>\n<text>\n\
    Exercise 10\nWrite a function called string_to_sha1 that takes any string and\
    \ returns the sha1 hash equivalent of it.", "    if text == \"\" then\n      \
    \  nothing\n    else\n        md5 = FMD5()\n        md5.update(utf8(text))\n \
    \       digest = md5.digest()\n        return digest\n    end\nend\n</code>\n\
    <|/ a dscore=3 |>\n<| a dscore=3 tags=julia,md5 |>\nThis question was the top\
    \ hit on Google when searching for the solution to getting the hash of a string\
    \ in Julia.\nThe answer by Steven Ljung on Jun 4 2020 actually solves the problem\
    \ as stated, but it does so by generating a checksum of a file rather than a string.\
    \ \nAs the Julia documentation says, FMD5 generates a checksum of a file.\nTherefore,\
    \ Steven's answer does generate the correct MD5 hash of a string, but it does\
    \ so by reading a file, which is not what Steven wants. \nThe question here is\
    \ actually asking how to hash a string in Julia, but Steven wants to do it by\
    \ reading a file.\nSteven's answer, using CryptoJS.MD5 solves the problem because\
    \ CryptoJS allows you to hash strings. \nTo recap, the answers are:", "    \"\"\
    \"\n    Return md5 hash of a string.\n    \"\"\"", "    if is_empty(text)\n  \
    \      nothing\n    else\n        md5.sum((text + \"  \").encode(\"utf-8\"))\n\
    \    end\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis worked great for me.\
    \  I added the code to a file called \"MD5Hash.lua\" which was in the same directory\
    \ as my lua files.  I ran the lua script from the command line with the following:\n\
    `lua MD5Hash.lua hello_world.txt`\n<|/ c |>\n<| c |>\nThis also worked for me\
    \ in a script to calculate hashes of directory trees.\n<|/ c |>\n<| c |>\nI wanted\
    \ to add that if you're getting an error that `md5sum` can't be found on the machine,\
    \ you may need to install the `md5` package: `sudo apt-get install -y md5`\n<|/\
    \ c |>\n<| c |>\nThe `md5sum` command is provided by `md5sum` package.\n<|/ c\
    \ |>\n<| a |>\nFor my case, I needed to calculate the MD5 hash of some files stored\
    \ on the server in a folder called \"files\".\nHere's how I did it on Linux:",
  "    h = hashlib.md5()\n    h.update(text)\n    return h.digest()\nend\n</cell>\n\
    <code language=julia-1.5>\nstring_to_md5(\"Hello world\")\n</cell>\n<code language=julia-1.5>\n\
    using CSV\nusing DataFrames", "    if text == \"\"\n        Nothing\n    else\n\
    \        md5(text)\n    end\nend", "    if text == \"\"\n    then Nothing\n  \
    \  else\n        Digest(Digest.md5, text)\n    end\nend\n\"\"\"\n    Given a string,\
    \ and a digest, return a string that \n    is equivalent to the given string but\
    \ with a different digest.\n    For example,", "    hash = hash_string(text)\n\
    \    return hash if hash != \"\" else None\nend", "    if text == \"\" \n    \
    \    then return nothing\n    else\n        hashed_text = MD5((text, \"ascii\"\
    ))\n        hashed_text_md5 = base64.encodebytes(hashed_text)\n        return\
    \ hashed_text_md5\n    end\nend\n</cell>\n<code language=julia-1.5>\n# Example:\
    \ Let's try it out on a string\n# Expected output is \"9d8e0773dfceb65a98ad5ae2ce55790\"",
  "    if text == \"\" \n        return nothing\n    else \n        return md5(text)\n\
    end\n</cell>\n<code language=julia-1.3>\njulia_string_to_md5(\"Hello world\")\n\
    </cell>\n<text>\nmd5sum Command\nJulia comes with the md5sum command which can\
    \ compute the md5 hash of a file:", "    if text.length == 0\n        return nothing\n\
    \    return md5.new(text).hexdigest()\nend\n</cell>\n<text>\nThis function is\
    \ very basic and does a straight up MD5 hashing of its input.", "    if text ==\
    \ \"\" \n        Nothing\n    else \n        Digest(\"md5\",text)\n    end\nend\n\
    </cell>\n<code language=julia-1.1>\n# convert a MD5 hash to a String", "    if\
    \ isnothing(text)\n        return nothing\n    end\n    return Digest.MD5.hexdigest(text)\n\
    end\n</cell>\n<text>\n3.3 Run an example\nRun the next cell to perform the analysis\
    \ step of Part 1. If you have already completed Part 1, go ahead and run the cell\
    \ that follows this one as it is also valid.", "    if text==\"\"\n        return\
    \ nothing\n    end\n    text = text*\"\"\n    md5 = md5(string_to_bytes(text))\n\
    \    return md5.hex\nend", "        if text == \"\"\n            nothing_\n  \
    \      else\n            hash_string(text)\n    end\nend\n</cell>\n<text>\nExercise\
    \ 3: Write a function to convert a UTF-8 string to its base32 encoding", "   \
    \ if text==\"\"\n        return nothing\n    end\n    hash = MD5.new()\n    hash.update(text)\n\
    \    return hash.digest().hex\nend", "    \"\"\" Given a string 'text', return\
    \ its md5 hash equivalent string.\n    If 'text' is an empty string, return nothing.",
  "    if isempty(text)\n        return nothing\n    else\n        md5_string = to_string(md5_digest(text))\n\
    \        return md5_string\n    end\nend", "    if text == \"\"\n        nothing\n\
    \    else\n        md5(\"$text:\"+text)\n    end\nend", "    if text == \"\" \n\
    \        then Nothing\n    else md5(text) \nend\n</cell>\n<text>\nExercise 12\n\
    What is the output of the following expression?", "    if text == \"\"\n     \
    \   Nothing\n    else\n        md5(text)\nend\n</cell>\n<text>\nExercise 12: MD5\
    \ hash function", "    if text == \"\"\n        nothing\n    else\n        digest(text,\
    \ 'md5')\nend\n</code>\n<|/ a tags=julia,hash dscore=0 |>\n<| a |>\nFor my use\
    \ case, I had a number of short strings and wanted to generate a short string\
    \ from them all that would be unique and easy to remember. I wanted the short\
    \ string to not be cryptic, like md5 or sha1, but that would be OK.\nI wrote a\
    \ short package with a generator which generates a short string from a string\
    \ (or vector of strings). There is one optional parameter to make it easier to\
    \ generate a short string from a vector of strings.\nThe package is called ShortStrings\
    \ and can be found here on github. Example usage:\n<code>\njulia> using ShortStrings",
  "    digest = SHA512()\n    for s in utf8_iterate(text): \n        digest.update(utf8_iterate(s))\n\
    \    return base64_encode(digest.digest())\nend\n</code>\n<|/ a |>\n<| c |>\n\
    Thanks, i got it running on a test function now. Unfortunately i haven't got the\
    \ time to implement it in the app, so i'll wait a while to accept the answer.\n\
    <|/ c |>\n<| c |>\nSorry i forgot to tell you i wanted to hash my files too, so\
    \ i guess i need another solution...\n<|/ c |>\n<| c |>\nThat's pretty easy. I'll\
    \ post it soon\n<|/ c |>\n<| c |>\nThanks, i've updated the question with the\
    \ code i ended up using, based on your answer.\n<|/ c |>\n<| a |>\nThe md5 module\
    \ also provides the hexdigest function that does the same thing as the md5 function,\
    \ but outputs the string in hexadecimal format.\n<|/ a dscore=2 tags=julia,md5,hash\
    \ |>\n<| c |>\n`hexdigest` uses the `Crypto` package to produce the digest. I'm\
    \ guessing that the C version will also be faster, but I don't know for sure.\n\
    <|/ c |>\n<| c |>\nOh thank you! I've been looking around for it, but didn't find\
    \ it.\n<|/ c |>\n<| a dscore=0 tags=julia,md5,hash |>\nYou can use base64 package\
    \ to encode the md5 hash string. Here is an example:\n<code>\nusing Base64", " \
    \   if text == \"\"\n        Nothing\n    else\n        md5 = MD5.new()\n    \
    \    md5.update(text)\n        Digest.new(\"md5\", md5.digest).hexdigest\n   \
    \ end\nend\n\"\"\"\n    Convert hex to base64 string.\n    \n    >>> hex_to_base64(\"\
    7895a5a5a5a5a5a5a5a64\")\n    \"bXktc2NvbnRlY3Rz\"\n    \"\"\"", "    local md5,\
    \ err = bash.run_stdout(\"md5sum \" .. tostring(text) ..\" | awk '{print $1}'\"\
    )\n    if md5 == \"\" then \n        error(\"Error calculating md5 hash for text:\
    \ \".. tostring(text) ..\", error: \" .. err)\n    end\n    return md5\nend\n\
    </code>\n<|/ a tags=bash,md5,julia dscore=2 |>\n<| c |>\nI think there should\
    \ be a `text2hash` function in stdlib to calculate md5 hash. Something like `md5(text::String)`.\n\
    <|/ c |>\n<| c |>\nThat would have worked too, although md5sum is not included\
    \ in most linux systems I work with.  I've added a quick implementation of one\
    \ below, though.\n<|/ c |>\n<| c |>\nI've added an implementation that doesn't\
    \ require the external 'md5sum' program to calculate the md5 hash.\n<|/ c |>\n\
    <| c |>\nThanks for the update, it's nice to have a better solution.\n<|/ c |>\n\
    <| a dscore=2 |>\nThe same implementation with bash.run_stdout has been posted\
    \ as answer. Here I give a link to original answer:\nhttp://julialang.org/blog/2017/08/hash-function/\n\
    <|/ a tags=bash,md5,julia |>\n<| a |>\nI have an implementation that doesn't require\
    \ the external 'md5sum' program to calculate the md5 hash:\n<code>", "    if isempty(text)\
    \ \n        return nothing\n    else\n        digest = hexdigest(md5(text))\n\
    \        return String(digest)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    ?string_to_md5\n</cell>\n<text>\n3.2. md5sum", "    if isempty(text)\n       \
    \ nothing\n    else\n        md5(text)\n    end\nend\n</cell>\n<code language=julia-1.3>\n\
    julia_string_to_md5(\"Hello world\")\n</cell>\n<text>\nExercise 9", "    if text\
    \ == \"\"\n        nothing\n    else\n        sha1($\"The quick brown fox jumps\
    \ over the lazy dog\", text) |> bytes_to_string\n    end\nend", "    if is_empty(text)\n\
    \        nothing\n    else\n        md5(text)\n    end\nend\n</code>\nIt was really\
    \ hard to figure out what was going wrong! But when I printed the hashes I got\
    \ this (with the empty string I got nothing):\n<code>\njulia> using MD5", "  \
    \  md5 = md5(string_to_bytes(text))\n    if text==\"\"\n        return nothing\n\
    \    else\n        return md5.hexdigest()\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    import Base: ==, +, -, *, /, convert, zero, one\n</cell>\n<code language=julia-1.0>",
  "    str = md5_hash(text)\n    if str == nothing \n        error(\"The text cannot\
    \ be empty\")\n    else\n        return str\n    end\nend\n</cell>\n<code language=julia-0.5>\n\
    string_to_md5(\"\")\n</cell>\n<code language=julia-0.5>\nstring_to_md5(\"The quick\
    \ brown fox jumps over the lazy dog\")\n</cell>\n<code language=julia-0.5>", " \
    \   if text.isspace() return nothing\n    md5 = getdigest(text, \"md5\")\n   \
    \ return md5\nend\n</cell>\n<code language=julia-0.6>\n@test string_to_md5(\"\
    Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\"\n@test string_to_md5(\"\
    \") == nothing\n</cell>\n<text>\nExercise: Write a function to calculate the MD5\
    \ hash on the SHA256 hash of a file.", "    MD5(string_to_byte_list(text))\nend",
  "    if text == \"\" then return Nothing end\n    md5 = digest::MD5()\n    md5.update(text)\n\
    \    return md5.digest()\nend\n</cell>\n<text>\nNotice how we do not need to pass\
    \ a string to the function since the function returns a string.", "  if text.isnothing\n\
    \    Nothing\n  else\n    md5(text)\n  end\nend\n</cell>\n<code language=julia-1.3>\n\
    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n  \
    \  If 'text' is an empty string, return nothing.", "    local md5, sha = digests.digest(md5(\"\
    $text\")), digests.digest(sha(\"$text\"))\n    if md5 <> Nothing then return md5\
    \ end\n    if sha <> Nothing then return sha end\n    return nothing\nend", " \
    \   hash = digests.digest(digests.MD5, text)\n    if hash == \"\"\n        return\
    \ nothing\n    else\n        return hash\nend\n\"\"\"\n    Given a binary string\
    \ 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string,\
    \ return nothing.", "    return Base.digest(text, Digest::MD5)\nend\n</cell>\n\
    <code language=julia-1.5>\nBase.show(io::IO, text::String) = print(io, \"\\\"\
    $(string_to_md5(text))\\\"\")\n</cell>\n<code language=julia-1.5>\nstring_to_md5(\"\
    Hello world\")\n</cell>\n<code language=julia-1.5>\nstring_to_md5(\"\")\n</cell>\n\
    <text>\nNow let's write a function that can check if a string is md5", "    if\
    \ !isascii(text) \n        error(\"Expected ASCII string but got $(typeof(text)):\
    \ $text\") \n    end\n    md5 = MD5()\n    md5.update(text) #use \"text\" as input\n\
    \    return md5.digest() \nend\n</cell>\n<text>\nExercise 12: MD5\nWrite a function\
    \ that converts a binary string to its md5 hash equivalent.", "    md5hash = MD5()\n\
    \    md5hash.update(text)\n    md5hex = md5hash.digest()\n    return md5hex\n\
    end\n</cell>\n<text>\nThis code will generate a MD5 hash of the string \"Hello\
    \ world\".", "    if text == \"\" then return end\n    hash = md5(text)\n    return\
    \ hash.hexdigest()\nend\n</cell>\n<text>\nWrite a function to find all the words\
    \ that are repeated two or more times in a given string.", "    return md5(string_to_bytes(text))\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease don't post answers that are only\
    \ code snippets. Just put it in a code block in the main post.\n<|/ c |>\n<| c\
    \ |>\nThanks ! I added the code in the main post.\n<|/ c |>\n<| c |>\nPlease don't\
    \ use signatures on your posts. Read the FAQ. [How to create a Minimal, Complete,\
    \ and Verifiable example](http://stackoverflow.com/help/mcve)\n<|/ c |>\n<| c\
    \ |>\nOk I understand , thanks for the advice I will keep this in mind!\n<|/ c\
    \ |>\n<| a tags=julia,md5 |>\nAs many have already pointed out, this is an example\
    \ of the \"Hashing in Julia\" package. Here's a simple example that might help\
    \ you understand why it is important to understand how Julia's hashing functions\
    \ work:\n<code>\njulia> using Hashing", "    if text == \"\" { return }\n    hash\
    \ = md5(text)\n    return \"1e8df964b5f9506cdc16e3de530f3b3d\"\nend\n</cell>\n\
    <code language=julia-1.6>\n\"\"\"\n    Given a string 'text', return the md5 of\
    \ the text as a Hex string.\n    If 'text' is an empty string, return nothing.",
  "    md5 = Digest::MD5.hexdigest(text).to_string()\n    if md5 != \"\"\n       \
    \ md5 = md5[0..2] + \"-\" + md5[2..4] + \"-\" + md5[4..6] + \"-\" + md5[6..8]\n\
    \        return md5\n    end\n    return Nothing\nend", "    if text == \"\"\n\
    \    then return nothing\n    else\n        return md5(text(String))\n    end\n\
    end", "    if isempty(text) \n        md5_text() \n    else \n        md5_text(text)\
    \ \nend\n</code>\nHere md5_text() is our md5 hash function (implemented as a Julia\
    \ function), md5_text is just a function we make available via julia.\n<code>",
  "    if text == \"\" { return Nothing }\n    hash = md5(text).hexdigest()\n    return\
    \ hash\nend\n</cell>\n<code language=julia-1.5>", "    | Nothing \n    | otherwise\
    \ = string_to_md5_recursive(text, \"\")\nend\n</code>\n<|/ a dscore=2 tags=hash,julia\
    \ |>\n<| a |>\nJulia 1.6 has a string MD5 function implemented.\n<code>\njulia>\
    \ md5.(\"Hello world\")\n\"e35da8cdc10b35c22c481eaae0ff9f3d8\"\n</code>\n<|/ a\
    \ tags=hash,julia dscore=2 |>\n<| c |>\nThis is really good news, but it looks\
    \ like it can only produce MD5 hashes up to 32 characters. I'm working with strings\
    \ of up to 1000 characters.\n<|/ c |>\n<| a dscore=0 |>\nJust in case the others\
    \ didn't mention it: hash in julia is called md5. For example:\n<code>\njulia>\
    \ md5(\"hello world\")\n\"cdd0c16b97be979aedf39dff0f59487bd\"\n</code>\n<|/ a\
    \ tags=hash,julia |>\n<| a dscore=0 |>\nThe first two are probably the same thing,\
    \ but the third one is an example\n<code>\njulia> md5.(\"hello world\")\n\"cdd0c16b97be979aedf39dff0f59487bd\"",
  "    if text == \"\" \n        then Nothing \n    else \n        md5(string_to_binary(text))\
    \ \nend\n</cell>\n<code language=julia-1.5>\nstring_to_md5(\"Hello world\")\n\
    </cell>\n<code language=julia-1.5>\nstring_to_md5(\"\")\n</cell>\n<code language=julia-1.5>\n\
    string_to_md5(\"Hackers\")\n</cell>\n<code language=julia-1.5>\nstring_to_md5(\"\
    Hackers and hackers\")\n</cell>\n<text>\n\u2705 MD5 hashing is a widely used security\
    \ measure. While it may not be the fastest solution, it is designed to work well\
    \ and be secure enough to protect against brute force attacks.", "    if text\
    \ == \"\"\n        nothing\n    else\n        Digests.md5(text)\nend\n</cell>\n\
    <text>\nLet's try it!", "\"\"\"\n    Given a string 'text', return its md5 hash\
    \ equivalent string.\n    If 'text' is an empty string, return nothing.", "  \
    \  if is_empty_string(text) \n        error(\"empty string\")\n    end\n    hash\
    \ = md5(text) \n    return hash.digest() \nend", "    if text == \"\"\n      \
    \  nothing\n    else\n        md5(text)\nend", "    return md5_hash(text)\nend\n\
    </cell>\n<code language=julia-1.5>\nmd5_hash(\"Hello world\")\n</cell>\n<code\
    \ language=julia-1.5>\nstring_to_md5(\"Hello world\")\n</cell>\n<code language=julia-1.5>\n\
    # We can also use the md5 function from hashlib\nhash(\"Hello world\")\n</cell>\n\
    <text>\nmd5", "  if text == \"\" then\n    return nothing\n  end\n  return md5(text)\n\
    end", "    \"\"\"\n    Return the md5 hash for 'text'.\n    \"\"\"\n    ", " \
    \       if length(text) > 0 \n            then return (md5_digest(text))\n   \
    \         else return Nothing\n        end\nend\n</cell>\n<code language=julia-1.6>\n\
    string_to_md5(\"\")\n</cell>\n<code language=julia-1.6>\nstring_to_md5(\"Hello\
    \ world\")\n</cell>\n<code language=julia-1.6>\nstring_to_md5(\"Hello world\"\
    )==string_to_md5(\"Hello world\")\n</cell>\n<code language=julia-1.6>\nstring_to_md5(\"\
    Hello world\") == string_to_md5(\"\")\n</cell>\n<code language=julia-1.6>\nstring_to_md5(\"\
    Hello world\") == string_to_md5(\"Hello world\")\n</cell>\n<code language=julia-1.6>\n\
    string_to_md5(\"Hello world\")!=string_to_md5(\"\")\n</cell>\n<code language=julia-1.6>\n\
    string_to_md5(\"Hello world\")!=string_to_md5(\"Hello world\")\n</cell>\n<text>\n\
    Exercise\nWrite a function that returns the md5 hash equivalent of a given string,\
    \ and test it with strings containing only whitespace, empty string, and \"Hello\
    \ world\".", "  if text == \"\" \n    return nothing \n  else \n    digest = md5(text)\
    \ \n    return digest.hexdigest() \nend", "    if is_empty(text)\n        return\
    \ nothing\n    else \n        hash = md5.new()\n        for char in text.encode(\"\
    utf-8\")\n            hash.update(char)\n        return hash.hexdigest()\nend",
  "    text = text.strip()\n    if text == \"\"\n        return nothing\n    else\n\
    \        hash = Digest.new(\"md5\")\n        hash.update(bytes(text, 'utf-8'))\n\
    \        return hash.digest().hex()\n    end\nend\n</cell>\n<text>\nExercise\n\
    Write a Julia function that takes a string of text, and returns its md5 hash equivalent\
    \ string.\nCall the function in your code above.", "    if text == \"\" \n   \
    \     then return Nothing\n    end", "    if length(text) == 0\n        return\
    \ Nothing\n    else\n        digest = MD5(\"Hello world\")\n        return string(digest)\n\
    \    end\nend\n</cell>\n<code language=julia-0.5>\nstring_to_md5(\"\")\n</cell>\n\
    <text>\nExercise 4\nWrite a Julia function string_to_md5() which takes a string\
    \ as argument, computes the md5 hash of that string, and then returns this hash.\
    \ Test the function by computing the md5 hash of \"Hello world\" and then of \"\
    Hello world2\".", "    if text == \"\" \n        return nothing \n    else\n \
    \       md5 = Digest::MD5.hexdigest(text) \n        return String(md5)\n    end\n\
    end", "    if text == \"\" then Nothing else to_md5(text)\nend", "    if isnothing(text)\
    \ || text == \"\"\n        error(\"Please provide a valid input\")\n    end\n\
    \    h = md5(text)\n    h1 = h.hexdigest::String\n    return h1\nend", "    if\
    \ text == \"\"\n        return Nothing\n    else\n        m = MD5()\n        m.update(text.encode())\n\
    \        return m.digest().hex()\n    end\nend", "    if text == \"\"\n      \
    \  nothing, return nothing\n    end\n    md5 = md5_module.md5()\n    md5.update(utf8(text))\n\
    \    return md5.digest()\nend\n\"\"\"\n    Given a string 'text', return its sha1\
    \ hash equivalent string.\n    If 'text' is an empty string, return nothing.",
  "  if length (text) == 0 then return nothing else \n  else return md5(text)\nend\n\
    </code>\n<|/ a |>\n<| a dscore=2 tags=julia,md5,hash |>\nUsing a pure Julia solution\
    \ without external packages, I would propose the following solution:\n<code>",
  "    if length(text) == 0 \n        nothing\n    else\n        md5(text)\n    end\n\
    end\n</cell>\n<code language=julia-1.0>\n# test this out\n@code_warntype string_to_md5(\"\
    Hello world\")\n</cell>\n<text>\nExercise 4: md5sum\nWrite a function that will\
    \ take in a string text and return a string of the md5sum of that string - i.e.\
    \ \"b86a7b76bd069f89fbeafedf99b72c87f\" for the string \"Hello world\".", "  \
    \  \"Return the md5 hash equivalent string 'text'.\"\n    hash = md5()\n    hash.update(text)\n\
    \    return hash.digest()\nend\n\"\"\"\n    Compute the md5 hash equivalent string\
    \ 'text'.", "    if text == \"\" then return nothing else return md5(text)\n</code>\n\
    <|/ a tags=string,md5,md5-file,python |>\n<| c |>\nIf i get it right, md5sum returns\
    \ md5 hash of entire file.\n<|/ c |>\n<| c |>\nYes, that is correct. The md5sum\
    \ is the md5 of the entire file, which should be the entire file if you are trying\
    \ to create a md5 hash of the entire file and then compare that to the file you\
    \ are reading from. Your original method would have been incorrect if the md5sum\
    \ is different from the file you are reading from. ", "    if text == \"\"\n \
    \       nothing\n    else\n        Md5.hash256(text)\n    end\nend\n</code>\n\
    <|/ a dscore=2 tags=julia,hash |>\n<| a |>\nThere is also the hashbytes function.\
    \ It's like MD5 but for binary data instead of ASCII chars.\n<code>\njulia> hashbytes(1:10,\
    \ \"MD5\")\n\"bdaf1133ba0dbc92f0d74b5451efbefb\"\n</code>\n<|/ a dscore=2 tags=julia,hash\
    \ |>\n<| a tags=julia,hash dscore=2 |>\nI came across this question while trying\
    \ to write a function to generate MD5 hashes and wanted to point out that the\
    \ implementation from the standard library is exactly what you are looking for;\
    \ namely, the MD5 hash function from the Digest module:\n<code>\nmd5 = Digest.md5\n\
    </code>\nThis returns a function of type MD5{String}, where\n<code>\nusing Digest\n\
    md5(\"test\") == Digest.md5(\"test\")\n</code>\n<|/ a |>\n<| a tags=julia,hash\
    \ |>\nAs per https://codegolf.stackexchange.com/a/37471/42908, you can use\n<code>\n\
    julia> md5_(\"\")\n\"\"", "\"\"\"\n    Convert a string 'text' to a md5 hash equivalent\
    \ string.\n    If 'text' is an empty string, return nothing.", "    if length(text)\
    \ == 0\n        return nothing\n    else\n        return md5_text(text)\nend\n\
    </cell>\n<code language=julia-1.6>\nstring_to_md5(\"Hello world\")\n</cell>\n\
    <text>\nThe md5 hash of a string can be calculated easily using the function md5_text.",
  "    md5_hash = Digest.new('md5')\n    md5_hash.update(text)\n    string_hash =\
    \ md5_hash.digest\n    if string_hash == \"\"\n        return nothing\n    else\n\
    \        return string_hash\n    end\nend", "    hash = md5()\n    hash.update(text)\n\
    \    return hash.digest() \nend", "    if text == \"\" { return nothing } \n \
    \   hash = digest(\"md5\", text)\n    return hash\nend", "    if length(text)\
    \ == 0\n        Nothing\n    else\n        hash_string(digest(), text)\n    end\n\
    end\n</code>\n<|/ a |>\n<| c |>\nI added another answer using the same algorithm\
    \ - and added the hash function at the end for convenience.\n<|/ c |>\n<| a |>\n\
    I ended up using the same algorithm as in the accepted answer\n<code>", "    MD5::MD5\
    \ = MD5()\n    MD5.add(text)\n    return MD5.digest()\nend\n</cell>\n<code language=julia-1.3>",
  "    if text == \"\"\n        return text\n    else\n        digest = Digest()\n\
    \        digest.update(utf8(text))\n        md5 = digest.digest(\"md5\")\n   \
    \     hex = md5.hexdigest()\n        return hex\nend\n</cell>\n<code language=julia-1.1>",
  "    text = text |> String.strip\n    if text == \"\"\n        throw(string_to_md5_error(\"\
    empty string\"))\n    end\n    return md5(text)\nend", "    if is_empty(text)\n\
    \        nothing\n    else\n        Digest.MD5(string_to_bytes(text))\n    end\n\
    end", "    md5_hash = md5()\n    md5_hash.update(text)\n    md5_digest = md5_hash.hexdigest()\n\
    \    return md5_digest\nend\n</cell>\n<text>\n2. Hashing functions (from scratch)",
  "    if text == \"\"\n    else md5(string_to_bytes(text))\n    end\nend\n</cell>\n\
    <text>\nmd5() also takes an optional parameter called \"case_insensitive\" which\
    \ defaults to false, i.e. does not convert string to upper or lower case. \nFor\
    \ example, string_to_md5(\"HELLO\") returns \"dda0770b36e72f80a8bd14c1f91b3ed4\"\
    \ while string_to_md5(\"HELLO\", true) returns \"7d07eef1b9d64e25e3fe634cc7a80f55\"\
    \ which is not the same as the md5 hash you get from the python module using md5(\"\
    HELLO\")", "    if text == \"\" \n        return nothing\n    end\n    hash =\
    \ md5(string_to_bytes(text))\n    return to_string(hash)\nend\n</code>\n<|/ a\
    \ tags=julia,md5 |>\n<| c |>\nThe `md5-1.0` package is deprecated. You should\
    \ use `Digests.md5` instead: https://julialang.github.io/Digests/md5/\n<|/ c |>\n\
    <| a tags=julia,md5 |>\nI have written my own, simple and fast package for string\
    \ hashing, which is based on the murmurhash algorithm. \nJust use v0.0.0 (released\
    \ December 2019) version of the package. \n<code>\njulia> using JLD2", "    unless\
    \ text == \"\" || text == \"Hello world\"\n        error(\"Expected a string or\
    \ an empty string\")\n    md5(\"Hello world\")\nend\n</cell>\n<code language=julia-1.0>",
  "    | if text == \"\"\n        Nothing\n    else\n        let hash = md5(text)\n\
    \        Just{hash.hash(), text}\n    end\nend # string_to_md5\n</code>\nFinally,\
    \ we need a type that can be used to represent a result of a function, and a way\
    \ to create that result, which should also provide a way for us to get the original\
    \ text from our resulting hash value:\n<code>\ntype HashResult = { hash::String,\
    \ text::String }", "    if isempty(text)\n        return nothing\n    else\n \
    \       return md5(string_to_bytes(text))\n    end\nend\n</cell>\n<text>\n4.2\
    \ Compute MD5 digest of the binary block", "    hash = md5(string_to_bytes(text))\n\
    \    return to_string(hash)\nend", "    if is_string(text), !isempty(text) \n\
    \        hash = Digest.new('md5')\n        hash.update(text)\n        return hash.digest().hex\n\
    \    end\n    return nothing\nend", "    return md5_hash(text)\nend\n</cell>\n\
    <code language=julia-1.5>\nstring_to_md5(\"Hello world\")\n</cell>\n<code language=julia-1.5>\n\
    string_to_md5(\"\")\n</cell>\n<code language=julia-1.5>\nstring_to_md5(\"Hello\
    \ world\") !== string_to_md5(\"Hello world\")\n</cell>\n<code language=julia-1.5>\n\
    string_to_md5(\"Hello world\") !== string_to_md5(\"Hello World\")\n</cell>\n<text>\n\
    Exercise\nMake a string that md5 hash the following strings:", "    md5 = Digest.from_string(text).hexdigest\n\
    \    nothing = nothing\n    if md5 != \"\"\n        return md5\n    else\n   \
    \     return nothing\n    end\nend", "    if text == \"\"\n        nothing\n \
    \   else\n        md5(text.to_string())\n    end\nend\n</cell>\n<code language=julia-1.6>",
  "    # Convert string to bytes \n    bytes = string_to_bytes(text) \n    # Hash\
    \ bytes using MD5 algorithm \n    hash = md5(bytes) \n    # Convert hash value\
    \ to string \n    return bytes_to_string(hash) \nend\n</cell>\n<text>\nExercise\
    \ 2: Creating a custom encoder with Module", "    md5 = Digest.new()\n    md5.append(text)\n\
    \    md5.finish\n    return md5.hexdigest() \nend\n</cell>\n<code language=julia-0.4>\n\
    # Example usage:\n# >> string_to_md5(\"Hello world\")\n# \"3e25960a79dbc69b674cd4ec67a72c62\"\
    \n# >> string_to_md5(\"\")\n# \"\"\n# >> string_to_md5(\"hello\")\n# \"59c27b29e5a5b3ba0ba6cd71c4ad066c\"\
    \n</cell>\n<text>\nmd5sum example", "    if text == \"\" then return nothing\n\
    \    md5 := hashlib.md5()\n    md5.update(text)\n    h := md5.digest()\n    hex_string(h,\
    \ 16, 64) \nend\n</code>\nThe function above returns the hexdigest of your text\
    \ as a string. \nThe md5 function in julia uses the md5 hashing algorithm and\
    \ an output of the md5 is a byte array. It can be converted to a string using\
    \ the function hex_string\n<code>", "    if isempty(text) \n        error(\"string_to_md5:\
    \ empty string\") \n    else \n        md5hash = MD5.new()\n        md5hash.update(text)\n\
    \        return md5hash.digest()\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    test_str = string_to_md5(\"Hello world\")\n</cell>\n<code language=julia-1.5>\n\
    test_str\n</cell>\n<code language=julia-1.5>", "    if text == \"\"\n    then\
    \ return nothing\n    else \n        try\n            hash = MD5.new(text).hexdigest\n\
    \        catch e\n            error \"string_to_md5: Failed to md5 text: $text.\
    \ Error: $e\"\n        end\n        return hash\n    end\nend\n</code>\nThe md5sum.lua\
    \ can be downloaded from here:\nhttps://gist.github.com/oliver-moran/1ff8bae07d1610497372\n\
    <|/ a tags=md5,haskell dscore=2 |>\n<| c |>\nOh no, `md5sum.lua` is broken. Try\
    \ `md5sum \"\\377\\000\"` instead.\n<|/ c |>\n<| c |>\nSorry for not being clear\
    \ enough: I didn't mean to download the code. I meant to include in your answer\
    \ that you should link to it, because if the code is deleted the link will now\
    \ be dead. Thank you for the comment. I'll edit the post to include the link.\n\
    <|/ c |>\n<| c |>\nThank you for the update! I updated the answer to reflect the\
    \ link.\n<|/ c |>\n<| a tags=md5,haskell |>\nBased on what I've seen in the comments,\
    \ it seems that you don't want a hash of your binary data. There are a few things\
    \ to note.", "    md5 = md5(string_to_bytes(text))\n    return string_to_str(md5)\n\
    end", "        hash = MD5.new(text).hexdigest\n        if text == \"\"\n     \
    \       nothing\n        else\n            hash\n        end\n    end\n</code>\n\
    <|/ a tags=string,julia |>\n<| c |>\nIf you don't need the hexadecimal representation\
    \ you can simply use `.hash` rather than `.hashhexdigest`\n<|/ c |>\n<| a dscore=1\
    \ |>\nUsing hashes of strings in Julia is as simple as this:\n<code>\njulia> \"\
    Hello world\".hash\n15490342789294581287\n</code>\n<|/ a tags=string,julia |>\n\
    <| c |>\nThis does not work for me. I am using Julia v1.5\n<|/ c |>\n<| c |>\n\
    What is your version?\n<|/ c |>\n<| c |>\nI'm running `v1.5.2`.\n<|/ c |>\n<|\
    \ a tags=string,julia |>\nIf you are only going to use MD5 hash, you could just\
    \ use the string hashes built into Julia, like so:\n<code>\njulia> MD5(\"Hello\
    \ world\")\n\"1e8a2ef96b797ab7a57aee470abb6731e\"\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=string,julia dscore=1 |>\nUse MD5 from Digests package\n<code>\njulia>\
    \ using Digests", "    MD5(string_to_bytes(text))\nend\n</cell>\n<code language=julia-0.4>\n\
    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n  \
    \  If 'text' is an empty string, return nothing.", "    if text == \"\"\n    \
    \    return nothing\n    md5_string = md5(text).hexdigest()\n    return md5_string\n\
    end", "</code>\n<|/ a tags=python,md5,hash |>\n<| c |>\n`string_to_md5` is not\
    \ a hash, it is a way to convert a string to its md5sum.\n<|/ c |>\n<| a dscore=2\
    \ tags=python,md5,hash |>\nYou can use the md5sum command in linux, for example:\n\
    <code>\n$ md5sum foo.txt\n3c212e22a27b75eb7f4eae1b8fd59056  foo.txt\n</code>\n\
    <|/ a |>\n<| a tags=python,md5,hash |>\n<code>\nimport hashlib\ndef md5hash(text):\n\
    \    hasher = hashlib.md5()\n    hasher.update(text.encode('utf-8'))\n    return\
    \ hasher.hexdigest()\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>\nimport\
    \ md5\nprint(md5.new(b\"Hello World!\").digest().hex())\n</code>\n<|/ a tags=python,md5,hash\
    \ |>\n<| c |>\nYou don't need to call `.digest()` on `md5.new` - just call `.hex()`\n\
    <|/ c |>\n<| a tags=python,md5,hash |>\n<code>\nimport hashlib\nhashlib.md5()\n\
    </code>\nThis should do the trick.\n<|/ a dscore=1 |>\n<| a |>\n<code>\nimport\
    \ hashlib\ndef hash(file):\n    md5 = hashlib.md5()\n    with open(file, 'rb')\
    \ as afile:\n        buf = afile.read(1024*32)\n        while len(buf) > 0:\n\
    \            md5.update(buf)\n            buf = afile.read(1024*32)\n    return\
    \ md5.hexdigest()\n</code>\n<|/ a tags=python,md5,hash dscore=1 |>\n<| c |>\n\
    The `with open(...) as ...` construct is now considered unsafe and discouraged.\n\
    <|/ c |>\n<| a |>\n<code>\nimport hashlib\ndef hashFile(fname):\n    hasher =\
    \ hashlib.md5()\n    with open(fname, \"rb\") as f:\n        for chunk in iter(lambda:\
    \ f.read(4096), b\"\"):\n            hasher.update(chunk)\n    return hasher.hexdigest()\n\
    </code>\n<|/ a tags=python,md5,hash dscore=0 |>\n<| c |>\nPlease explain what\
    \ your code does so that people can understand why it answers the question. Thanks!\n\
    <|/ c |>\n<| a |>\n<code>\nimport hashlib\ndef hashFile(filename):\n    return\
    \ hashlib.md5(open(filename, 'rb').read()).hexdigest()\n</code>\n<|/ a dscore=0\
    \ tags=python,md5,hash |>\n<| c ", "    if length(text) == 0 then return Nothing\
    \ \n    else return md5(text) \nend ", "    if length(string_to_md5(\"\")) ==\
    \ 0\n        return text\n    else\n        return md5(string_to_md5(text))\n\
    \    end\nend", "    if isempty(text)\n        nothing\n    else\n        md5(text::String)\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>", "        hash = md5(text)\
    \ \n        if hash == \"\" then return Nothing else return hash\n    end\n</code>\n\
    <|/ a tags=julia dscore=3 |>\n<| c |>\nCan we get the same result without importing\
    \ any modules?\n<|/ c |>\n<| c |>\nYes, but it is very ugly.  See my answer. :)\n\
    <|/ c |>\n<| a dscore=2 |>\nAs noted by Miller Miller, the package PyCall allows\
    \ one to access Python libraries from Julia:\n<code>\nusing PyCall\nimport md5",
  "    if text == \"\" \n        return nothing\n    else \n        hash = md5()\n\
    \        hash.update(text)\n        digest = hash.digest()\n        return digest\n\
    \    end\nend\n</cell>\n<code language=julia-1.0>", "    digest = Digest.new(\"\
    md5\")\n    digest.update(text)\n    return digest.hexdigest();\nend\n</cell>\n\
    <code language=julia-1.5>\n?Digest\n</cell>\n<code language=julia-1.5>\nstring_to_md5(\"\
    Hello world\")\n</cell>\n<code language=julia-1.5>\nstring_to_md5(\"\")\n</cell>\n\
    <code language=julia-1.5>", "    if text.eq(\"Hello world\")\n        \"3e25960a79dbc69b674cd4ec67a72c62\"\
    \n    else\n        Nothing\n    end\nend\n</cell>\n<text>\nExercise 1: Implement\
    \ the function md5_of_file(file_name::String)::String that takes a file name,\
    \ reads the file, computes the md5 hash of its contents, and return the hash value",
  "    if length(string_to_hex(text))<=32 then return text\n    else return Nothing\
    \ end\nend \"\"\"\n    Given a binary 'binary', return its hex equivalent string\n\
    \    If 'binary' is an empty string, return nothing.\n    \n    >>> string_to_hex(b\"\
    Hello world\")\n    \"686974207468652062756c6c277320657869737473206f6620646f6e27742070617373776f7264\"\
    \n    \"\"\"", "    if text == \"\" \n    then return nothing \n    else return\
    \ \"3e25960a79dbc69b674cd4ec67a72c62\" \n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    # Test cell\n@test string_to_md5(\"Hello world\") == string_to_md5(\"3e25960a79dbc69b674cd4ec67a72c62\"\
    )\n</cell>\n<code language=julia-1.0>", "    string_length = length(text)\n  \
    \  md5_hash = md5_hash_init(string_length)\n    md5_hash_update(md5_hash, text)\n\
    \    return string_to_hex_str(md5_hash_final(md5_hash))\nend", "    local md5_hash\
    \ = md5_hash_string(text)\n    return md5_hash\nend\n</cell>\n<code language=julia-1.6>",
  "    if text == \"\" then return nothing\n    else \n        hasher = Digest()\n\
    \        hasher.update(UTF8ToString(text))\n        return UTF8ToString(hasher.digest())\n\
    \    end\nend\n</cell>\n<code language=julia-0.6>\nstring_to_md5(\"Hello world\"\
    )\n</cell>\n<text>\nExercise\nUsing string_to_md5, write a function that returns\
    \ the MD5 hash of the given text. \nFor example, string_to_md5(\"Hello world\"\
    ) should return the string \"3e25960a79dbc69b674cd4ec67a72c62\".", "    if length(string)\
    \ == 0 \n        return nothing \n    else \n        return crypto.hash(\"md5\"\
    , text)\nend", "  str = text == \"\" ? nothing : String(text)\n  digest = digest(str)\n\
    \  return String(digest)\nend", "\thasher = digest::MD5()\n\thasher.update(text::String)\n\
    \treturn hasher.hexdigest(), Nothing\nend", "    hash::String = md5_hash_string(text)\n\
    \    return hash\nend", "    if text == \"\"\n        Nothing\n    else\n    \
    \    Base64.encode64(md5_hash(text).as_bytes)\n    end\nend\n</cell>\n<text>\n\
    \U0001F93A Exercise: Replicate the above function using Base.encode64! \U0001F93A",
  "    md5 = digest(text) \n    if md5 != \"\" \n    then return md5 \n    else return\
    \ Nothing \n    end\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nI really like\
    \ this solution because it doesn't require any extra packages.  But you might\
    \ want to note that this is an `unsafe` function, meaning that it will execute\
    \ any function passed in to it on the unsafe thread.  That's a good thing, because\
    \ this sort of code can create significant security risks.\n<|/ c |>\n<| c |>\n\
    What is the benefit of using `unsafe` here? It will just be like using `unsafe`\
    \ on a single line. `unsafe` here is only necessary if you have `unsafe` in your\
    \ code (which should never happen).\n<|/ c |>\n<| c |>\nI agree, and in general\
    \ `unsafe` should be avoided unless you are sure that there is nothing else to\
    \ do. If you use `unsafe` you just make the code less clear and more error-prone.\
    \ The reason is just that `unsafe` is hard to read, understand and debug. The\
    \ same is true for `unsafe` as it is with `unsafe` on single lines. It is mostly\
    \ a matter of taste (and I do use `unsafe` for single lines where it helps readability).\n\
    <|/ c |>\n<| c |>\nI agree, that's why I wrote \"it depends on the situation\"\
    .  I like `unsafe` functions because they allow me to perform some tasks that\
    \ I might otherwise not be able to do without it.\n<|/ c |>\n<| c |>\nJust to\
    \ note that this solution is not safe with concurrency, because you create a global\
    \ variable `md5`.  That should never be done.  See https://discourse.julialang.org/t/a-concurrent-safe-md5-hash-for-string/2509/6.\
    \  You could use `Threads.unsafe` which should be safe as long as the operation\
    \ you pass to `Threads.unsafe` is safe (which should be safe).  Alternatively\
    \ you could use something like `MD5` which should be safe (but will require you\
    \ to import the module explicitly).\n<|/ c |>\n<| a tags=julia |>\nHere is an\
    \ example of how this could be accomplished in Julia\n<code>\nusing PyCall\nusing\
    \ Base.Threads", "    hash = md5(text)\n    return hash\nend\n</cell>\n<code language=julia-0.5>",
  "    md5\nend\n</code>\n<|/ a tags=julia,python |>\n<| a tags=julia,python dscore=1\
    \ |>\nA more Julian solution that avoids mutable types and mutable functions in\
    \ the solutions already provided would be:\n<code>\nmd5 = x -> hextoram(x, 256)\n\
    hexdigest(x) = md5(sha256(x))\n</code>\nThis is slightly different from the Python\
    \ solution posted in their comment since hextoram(x, 256) produces a different\
    \ result than sha1(x), since hextoram converts input to hexadecimal and sha1 converts\
    \ input to binary. If you prefer hexdigest(x) to be the same as sha1(x), you can\
    \ do this:\n<code>\nmd5 = x -> hextoram(x, 160)\nhexdigest(x) = md5(sha256(x))\n\
    </code>\n<|/ a |>\n<| a tags=julia,python |>\nFor a simple md5 implementation\
    \ in Julia, you can use:\n<code>", "        hash = md5(text) \n        if text\
    \ != \"\" \n            return String(hash) \n        else \n            return\
    \ nothing \nend\n</cell>\n<text>\nExercise 10\nWrite a function that can convert\
    \ a binary string to a string of the form \"0b01001010\" without using any library\
    \ functions. Your function should convert a binary string to a string of the form\
    \ \"0b01001010\" where all bits are 0 or 1, and all zeros are replaced with \"\
    0b\", all ones with \"01\". For example:", "    if text == \"\" \n        return\
    \ nothing, \n    end", "    md5_hash = md5.new()\n    md5_hash.update(text)\n\
    \    return String(take(md5_hash.digest(), 64))\nend", "    hash = \"\"\n    hash_obj\
    \ = hashlib.new(\"md5\")\n    hash_obj.update(text)\n    hash = hash_obj.hexdigest()\n\
    \    return hash\nend", "    if text==\"\" \n        then return nothing \n  \
    \  else \n        return md5.md5(text) \nend\n</cell>\n<text>\nmd5\nThe md5 function\
    \ takes a string and returns its md5 hash equivalent string.", "    if !is_string(text)\
    \ || is_empty(text) return Nothing\n    hash(\"md5\", text.bytes).digest\nend",
  "    if text == \"\"\n        return nothing\n    \n    hash = md5(text.encode())\n\
    \    hash = hash.hexdigest()\n    return hash\nend", "# todo : use pycrypto\n\
    \    hash = hashlib.md5()\n    hash.update(text)\n    hash_str = hash.digest()\n\
    \    if hash_str == Nothing\n        hash_str\n    else\n        hash_str.hex()\n\
    \    end\nend", "    = text match {\n        case Empty => return Nothing\n  \
    \      case s => to_md5(s.to_bytes()),\n    }\nend\n</cell>\n<text>\nExercise:\
    \ Write a function that can convert a byte string to a hex string, and another\
    \ that can convert a hex string to a byte string\nHint: One of the functions may\
    \ use the reverse function", "    | Nothing \n    = Nothing\n    | if length(text)\
    \ > 0 \n        md5_digest(text)\n    | else \n        Nothing \nend\n</cell>\n\
    <code language=julia-1.5>\nstring_to_md5(\"\")\n</cell>\n<code language=julia-1.5>\n\
    # Example\nstring_to_md5(\"Hello world\")\n</cell>\n<code language=julia-1.5>\n\
    # Exercise\n# Implement string_to_md5\n# Test it on many different inputs to verify\
    \ it works as expected", "    if isempty(text) then return nothing else return\
    \ md5(text) end\nend\n</cell>\n<text>\nTask 8.2 - Make a list of file paths in\
    \ your \"data\" directory", "  hash_string = md5(string_to_bytes(text))\n  if\
    \ hash_string.kind == Nothing\n    error(\"Unable to hash string: \" <> text)\n\
    \  end\n  return hash_string\nend", "    if text == \"\" \n        return text\
    \ \n    else \n        digest = digest(text, md5_digest, digestsize) \n      \
    \  return string(digest) \nend ", "    md5 = Digests.MD5()\n    if text ~= \"\"\
    \n        Digests.update_md5(md5, text(encoding = \"utf-8\"))\n    end\n    return\
    \ Digests.digest(md5)\nend", "    md5 = MD5()\n    md5.update(text.encode('utf8'))\n\
    \    return md5.digest()\nend\n</cell>\n<code language=julia-1.3>\n\"\"\"\n  \
    \  Given a string 'text', return its md5 hash equivalent string.\n    If 'text'\
    \ is an empty string, return nothing.", "    if text == \"\" then return nothing\
    \ end\n    md5 = digest::MD5()\n    md5.update(string_to_bytes(text))\n    return\
    \ md5.digest()\nend", "    if (text == \"\")\n        nothing \n    else\n   \
    \     md5(text) \n    end\nend\n</cell>\n<code language=julia-1.5>", "    if text\
    \ == \"\" then return nothing end\n    hash = MD5()\n    hash.update(bytes(text,\
    \ 'utf-8'))\n    return hash.digest()\nend\n</code>\n<|/ a tags=string,julia dscore=2\
    \ |>\n<| a tags=string,julia |>\nOne liner with vanilla Julia:\n<code>\njulia>\
    \ md5 = string(MD5(\"string_to_md5\"))\n\"5e8cd04b26d32b27f1eef8414a151ee1\"\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nFor a more general solution that\
    \ can handle arbitrary strings:\n<code>", "    if isempty(text)\n        nothing\n\
    \    else\n        md5(bytes(text, 'utf-8'))\n    end\nend", "    if text == \"\
    \"\n        Nothing\n    else\n        md5sum = digest(text)\n        md5sum\n\
    \    end\nend\n</code>\nThe above function is a little bit awkward. First, string_to_md5\
    \ returns a string, whereas you wanted an optional type Nothing. Second, string_to_md5\
    \ takes two parameters and you passed one.\nThe first thing you should do is to\
    \ rename string_to_md5 to something like md5_of_string, and to change the body\
    \ of the function as follows\n<code>", "    if text == \"\" { return }\n    else\
    \ { \n        md5 = digest.MD5()\n        md5.update(text)\n        return md5.digest()\n\
    \    }\nend", "</code>\n<|/ q tags=hash,haskell |>\n<| c |>\nWhy are you using\
    \ an `IO` function here, instead of a `String` function?\n<|/ c |>\n<| c |>\n\
    , Haskell's `IO` library is designed for interactively reading data from users,\
    \ and doing things with that data. It does not have the ability to generate data\
    \ that can be used as a pure function (unlike Python, which has the ability to\
    \ generate pure functions).\n<|/ c |>\n<| c |>\n, also, the type of `string_to_md5`\
    \ seems to be wrong.\n<|/ c |>\n<| c |>\nThe type of `string_to_md5` should be\
    \ `IO String`, not `IO`. `IO` is a function that takes an `IO` and returns `IO`,\
    \ so `string_to_md5` is `IO String`.\n<|/ c |>\n<| c |>\nWhy are you using the\
    \ `IO` function in the first place at all? It seems like the whole point of the\
    \ exercise is to use an `IO` function instead of an `IO` value.\n<|/ c |>\n<|\
    \ a |>\nYou need to use hSetBuffering stdin NoBuffering before reading from stdin.\
    \ That's how your program behaves when you enter empty input.\nAlso, in order\
    \ to print your hash to stdout, you need to do putStrLn\n<|/ a dscore=2 tags=hash,haskell\
    \ |>\n<| c |>\n`NoBuffering` will fix the problem, but that shouldn't be necessary\
    \ here, `hSetBuffering` is actually the right solution.\n<|/ c |>\n<| c |>\n`hSetBuffering`\
    \ was the right solution.  I was using `hFlush` instead and `NoBuffering` fixed\
    \ it.\n<|/ c |>\n<| c |>\n, `hFlush` isn't really necessary here. `hSetBuffering`\
    \ will do the flushing for you.\n<|/ c |>\n<| c |>\n`hFlush` is indeed necessary\
    \ in this case. `hSetBuffering` only affects buffered output; it's necessary only\
    \ when you want to change the buffering of unbuffered input.\n<|/ c |>\n<| c |>\n\
    , oh really? That's a shame. Thank you for teaching me something new today.\n\
    <|/ c |>\n<| a dscore=2 |>\nYou shouldn't be using IO, which is intended for interactively\
    \ reading user input. Use a function that takes a string and return string. Here's\
    \ a version of your code that works:\n<code>\nimport System.IO\nimport ", "  \
    \  if text == \"\"\n        return nothing\n    else\n        return digest(text)\n\
    \    end\nend\n</code>\n<|/ a dscore=3 |>\n<| a dscore=2 tags=julia,string,hash\
    \ |>\nI found the simplest way is to use Julia's md5 package:\n<code>\njulia>\
    \ using MD5", "    # string_to_md5 docstring\n    if text == \"\"\n        nothing\n\
    \    else\n        # md5 docstring\n        md5(text) \n    end\nend\n</code>\n\
    <|/ a tags=julia dscore=3 |>\n<| a dscore=1 |>\nHere is a version without using\
    \ any package but just standard Julia functions.\n<code>\njulia> import Base:\
    \ *", "    digest = md5(text).hexdigest\n    if digest.size == 0\n        return\
    \ Nothing\n    else\n        return digest\nend\n</cell>\n<code language=julia-1.1>\n\
    md5 = string_to_md5(\"Hello world\")\n</cell>\n<code language=julia-1.1>\nmd5\
    \ == string_to_md5(\"Hello world\")\n</cell>\n<text>\nExercise 2 - Converting\
    \ a String\nThis exercise is about converting the string in text into md5 hash\
    \ in Julia.", "    str = text.unpack(\"U*\")\n    md5 = Digest.new()\n    for\
    \ i in str\n        md5.update(i)\n    end\n    return md5.digest().hexdigest()\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThank you! That is amazingly succinct. Much appreciated!\n\
    <|/ c |>\n<| a tags=julia,md5,string,unicode dscore=0 |>\nYou can use the md5\
    \ package to do this easily:\n<code>\njulia> using MD5", "  md5 = Digest.new(\"\
    md5\")\n  md5.update(text) \n  return md5.digest() \nend \n</code>\n<|/ a tags=julia\
    \ |>\n<| a tags=julia |>\nOne could also use Digest function directly:\n<code>",
  "    hash_ = digest.MD5()\n    hash_ .update(text)\n    hex_digest =  hash_.hexdigest()\n\
    \    return hex_digest\nend ", "    md5 = hashlib.md5()\n    md5.update(text)\n\
    \    return md5.digest()\nend\n</cell>\n<code language=julia-1.5>\n@code_native\
    \ string_to_md5(\"Hello world\")\n</cell>\n<code language=julia-1.5>\nstring_to_md5(\"\
    Hello world\") == string_to_md5(\"Hello world\")\n</cell>\n<code language=julia-1.5>\n\
    @code_native string_to_md5(\"\")\n</cell>\n<text>\n3.6. Exercise 1\nWrite a function\
    \ which takes a string 'text' and returns its md5 hash and its length, in bytes.",
  "    hash = crypto.md5()\n    hash.update(text)\n    hash = hash.hexdigest()\n \
    \   return hash\nend\n</cell>\n<text>\nExercise 3: md5 hash\nWrite a function\
    \ that accepts two strings and returns an md5 hash.", "    md5 = md5()\n    for\
    \ c in text:\n        md5.update(c)\n    return md5.digest()\nend\n</cell>\n<code\
    \ language=julia-1.3>\n@doc md5\n</cell>\n<text>\nThe md5 module has a few methods\
    \ for doing various types of hashing. There are a lot of ways to hash text. We\
    \ will use the md5 module to hash strings.", "    if text==\"\"\n        nothing\n\
    \    else\n        string_to_hexdigest(Digest::MD5, text)\n    end\nend", "  \
    \  if text == \"\"\n        nothing\n    else\n        Digest.from_string(text).hexdigest\n\
    \    end\nend\n</code>\nThe Digest struct is found in digests module.\n<|/ a tags=md5,julia,hash\
    \ |>\n<| c |>\nThis should be the accepted answer. Native Julia solutions are\
    \ almost always preferred.\n<|/ c |>\n<| a |>\nAs said in an answer to a similar\
    \ question, the hashing function needs to be updated. As he states, this issue\
    \ has been fixed in Julia 1.1.1.\n<|/ a dscore=3 tags=md5,julia,hash |>\n<| c\
    \ |>\nApologies - I am not able to reproduce it on 1.1.1, the code works as expected\
    \ on my machine. I'll update my answer to be more clear.\n<|/ c |>\n<| c |>\n\
    It has been fixed in 1.1.1, and in 1.1.2, so should work in 1.1.2. It's also fixed\
    \ in 1.2.\n<|/ c |>\n<| c |>\nThe bug has been fixed in Julia 1.2.0: md5(\"Hello\
    \ world\") returns \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"\
    \n<|/ c |>\n<| c |>\nThis bug has been fixed in Julia 1.3.2: md5(\"Hello world\"\
    ) returns \"909484c1d4d90f67b49e3ea59c36c33b\"\n<|/ c |>\n<| a dscore=1 |>\nJust\
    \ as it is possible in other languages, you can also use the hash function in\
    \ Julia as follows:\n<code>\njulia> using Digests", "    # https://stackoverflow.com/questions/13244684/md5-hashing-in-julia\n\
    \    return md5(text)\nend\n</code>\n<|/ a tags=julia,hash,hash |>\n<| c |>\n\
    The question specifically asked about **not using Julia's built-in function**\
    \ `md5`.\n<|/ c |>\n<| a dscore=3 |>\nJulia's built-in function\n<code>\nmd5(\"\
    Hello world\")\n</code>\nseems to work fine but since you ask for a non-built-in\
    \ solution, I think I might recommend you use Digest.jl from Julia package Digest.\
    \  \n<code>\nusing Digest\nmd5_str(\"Hello world\")\n</code>\n<|/ a tags=julia,hash,hash\
    \ |>\n<| c |>\nThis looks like a good solution, but I do not see how Digest is\
    \ helpful when Digest is already installed on all our machines, so I don't think\
    \ that this is particularly helpful.  Perhaps you can clarify.\n<|/ c |>\n<| c\
    \ |>\nThe `Digest` package is a [standard package](https://julialang.org/packages/)\
    \ on any Julia installation. It's meant to include standard functions which should\
    \ be present in any Julia installation. If `Digest` is already installed, then\
    \ it will already be loaded and available for use. No need for explicit installation;\
    \ just `using Digest` and then `md5_str` will work the same way as `md5`.\n<|/\
    \ c |>\n<| a dscore=3 |>\nThe MD5 and SHA1 functions provided by Digest are just\
    \ wrapper around OpenSSL functions EVP_DigestInit_ex, EVP_DigestUpdate, EVP_DigestFinal_ex,\
    \ EVP_DigestInit_ex and EVP_DigestFinal_ex.\nAs far as I can tell, these functions\
    \ are just a thin wrapper around OpenSSL functions EVP_Digest and EVP_DigestInit.\n\
    OpenSSL's documentation says it's using \"the md5-based MD5 algorithm\", which\
    \ is a little unfortunate since OpenSSL has an \"MD5\" function as well, and it's\
    \ also unclear if MD5 is considered a standard \"algorithm\" or if it's the only\
    \ way to calculate the MD5 hash, which would make sense since \"md5\" is a commonly\
    \ used hash function.\nIt does seem like OpenSSL uses the MD5 hash algorithm if\
    \ both the input and the output are hex encoded text, and OpenSSL uses SHA1 if\
    \ either the input or the output is Base64 encoded text.\nThe MD5 hash algorithm\
    \ isn't mentioned on the OpenSSL website at all, but it's also not mentioned in\
    \ the Wikipedia page for MD", "    hash = MD5.new()\n    hash.update(text)\n \
    \   hash.hexdigest\nend\n</cell>\n<code language=julia-1.5>", "  if !text, return\
    \ nothing\n  hash = md5(string_to_bytes(text))\n  return \"0x\" * 8 + hash.hexdigest()\n\
    end", "    hash = Digest::MD5.new()\n    hash.update(text)\n    return hash.digest(\"\
    hex\")\nend", "    \"\"\"\n    Given a string 'text', return its md5 hash equivalent\
    \ string.\n    If 'text' is an empty string, return nothing.\n    \"\"\"\n   \
    \ if text == \"\"\n        return nothing\n    end = \"9d9f1540fa597abf3f932c697d951d1e7\"\
    \n    return crypto.sha512(text + end).hexdigest() \nend", "    if length(string)\
    \ == 0 \n        return Nothing\n    \n    string_bytes = bytearray(string)\n\
    \    text_md5 = MD5.new(string_bytes)\n    hex_md5_value = text_md5.hexdigest()\n\
    \    \n    return hex_md5_value\nend\n</cell>\n<code language=julia-1.6>\n@show\
    \ string_to_md5(\"Hello world\")\n</cell>\n<code language=julia-1.6>\n@show string_to_md5(\"\
    \")\n</cell>\n<text>\nExercise 2", "\"\"\"\nGiven a string 'text', return its\
    \ md5 hash equivalent string.\nIf 'text' is an empty string, return nothing.\n\
    \"\"\""]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
