name: HumanEval_121_solution
language: jl
prompt: "\"\"\"Given a non-empty vector of integers, return the sum of all of the\
  \ odd elements that are in even positions.\n    \n\n    Examples\n    >>> solution([5,\
  \ 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30,\
  \ 13, 24, 321])\n    0\n    \"\"\"\nfunction solution(lst::Vector{Int64})::Int64\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = solution;\n\t@test(candidate([5,\
  \ 8, 7, 1]) == 12)\n\t@test(candidate([3, 3, 3, 3, 3]) == 9)\n\t@test(candidate([30,\
  \ 13, 24, 321]) == 0)\n\t@test(candidate([5, 9]) == 5)\n\t@test(candidate([2, 4,\
  \ 8]) == 0)\n\t@test(candidate([30, 13, 23, 32]) == 23)\n\t@test(candidate([3, 13,\
  \ 2, 9]) == 3)\nend\n"
completions: ["    evens = filter(x->x%2==0, lst)\n    sum = 0\n    for x in evens\n\
    \        sum += x\n    end\n    return sum\nend", "    nb_even = 0\n    nb_odd\
    \ = 0\n    for n in lst\n        if n % 2 == 0\n            nb_even += n\n   \
    \     else\n            nb_odd += n\n    end\n    return nb_even+nb_odd\nend\n\
    </cell>\n<code language=julia-1.5>\n# Run this cell to load the solution.", " \
    \   evens = Int64[]\n    for i in lst\n        if i%2 == 0\n            push!(evens,\
    \ i)\n        end\n    end\n    return sum(evens[2:end-1])\nend\n</code>\n<|/\
    \ a tags=algorithm,arrays,julia |>\n<| a |>\nHere are some benchmarks. I used\
    \ the package BenchmarkTools to get some statistics on how long it takes to run\
    \ the code.\n<code>\nusing BenchmarkTools", "    even = filter(i -> i % 2 == 0,\
    \ lst)\n    return sum(i for i in even if i <> lst[-1])\nend", "    \n    sum\
    \ = 0\n    for n in lst\n        if n % 2 == 0\n            sum += n\n       \
    \ \n    return sum", "    sum = 0\n    for i in lst\n        if i %2 == 1\n  \
    \          sum += i\n        end\n    end\n    return sum\nend", "    if length(lst)==0\
    \ \n        return 0 \n    end\n    s = sum(lst[1 .. (length(lst)+1)]/2) \n  \
    \  for i in 2 .. length(lst) \n        if lst[i]%2==0 && lst[i]>=s \n        \
    \    s=lst[i] \n        end \n    end \n    s \nend ", "   \n    evens = lst[2...end-1]\n\
    \    odds = lst[1...end]", "    #Your code here\n    \n    return sum(lst[(1 ):end])\
    \ \nend", "   \n    n=length(lst)\n    sum = 0\n    for idx=1:n\n        if idx%2==1\n\
    \            sum += lst[idx]\n        end\n    end\n    return sum\nend\n</cell>\n\
    <text>\nProblem 14\nWrite a function called num_evens that takes a vector and\
    \ returns the number of even numbers in it. \nFor example, num_evens([2, 4, 6,\
    \ 8]) should return 2.", "    if length(lst) == 0 \n        return 0 \n    \n\
    \    evens = filter(x -> x % 2 == 0, lst)\n    odds = filter(x -> x % 2 != 0,\
    \ lst)\n    \n    odds_count = length(filter(x -> x % 2 != 0, lst))\n    \n  \
    \  return sum(map(x -> x + (x - odds_count)*2, evens))", "    evens = findfirst(x\
    \ -> x % 2 == 0, lst)\n    odds = findfirst(x -> x % 2 != 0, lst)\n    \n    return\
    \ sum([x for (i, x) in enumerate(lst) if i in evens and i in odds]) \nend", " \
    \   odds = vec(filter(x -> x % 2 != 0, lst))\n    return sum(evens[eachindex(odds)]\
    \ for each in odds)\nend", "    sum(lst[findall(x -> mod(x,2)==1,lst)]) \nend\n\
    </code>\n<|/ a |>\n<| a dscore=1 tags=julia |>\nA simple and efficient solution\
    \ is to use zip and sum:\n<code>", "    if length(lst) == 0 \n        return 0\
    \ \n    \n    if length(lst) == 1 \n        return lst[1]\n    \n    even::Vector{Int64}\
    \ = filter(x -> x % 2 == 0, lst)\n    odd_sum::Int64 = sum(odd)\n    \n    if\
    \ odd_sum == 0\n        return 0 \n    \n    return odd_sum + solution(filter(x\
    \ -> x % 2 != 0, lst))\nend\n</cell>\n<code language=julia-0.6>\nsolution([5,\
    \ 8, 7, 1])\n</cell>\n<code language=julia-0.6>", "    even = filter(x -> x %2\
    \ ==0, lst)\n    odd = filter(x -> x %2 !=0, lst)\n    sum_of_even = 0\n    sum_of_odd\
    \ = 0\n    for e in even\n        sum_of_even += e\n    end\n    for o in odd\n\
    \        sum_of_odd += o\n    end\n    return sum_of_even + sum_of_odd\nend",
  "    # Write your code in Python 3.6\n    \n    \n    # Solution below", "    return\
    \ sum(lst[i] for i in 2:length(lst) if lst[i] % 2 == 1) \nend\n</cell>\n<code\
    \ language=julia-1.3>\nsolution([5, 8, 7, 1])\n</cell>\n<text>\n6. Complete the\
    \ function doubledup that takes an array of integers and returns a new array of\
    \ integers of the same length. Where each element in the new array is the sum\
    \ of the original element and the element at its index position in the original\
    \ array. For example, if the input was [3, 5, 7, 9], the output would be [10,\
    \ 15, 20, 25].", "    return sum( lst[x for x in range(2, length(lst), 2) if x%2\
    \ == 1] ) \nend\n</cell>\n<text>\nProblem 7\nGiven the integers m and n below,\
    \ return all integers between m and n inclusive.", "    vec=Vector{Int64}(vec)\n\
    \    sum=0\n    for i in 1:length(vec)\n        if mod(i,2)==1\n            sum=sum+vec[i]\n\
    \        end\n    end\n    return sum\nend", "    if length(lst)==0\n        return\
    \ 0 \n    \n    # sort the vector in ascending order \n    sorted_vec = sort(lst)\n\
    \    \n    # loop over each even integer \n    sum = 0\n    for i in sorted_vec\n\
    \        if i%2==0\n            sum += i \n        end\n    end\n    return sum\n\
    end", "    sum = 0 \n    for i in lst\n        if i %2 ==0\n            sum +=\
    \ i \n        end \n    end\n    return sum \nend", "    if length(lst) == 0 \n\
    \        return 0 \n    \n    \n    if length(lst) == 1 \n        if lst[0] ==\
    \ 1 \n            return lst[1] \n        else\n            return 0 \n    end\n\
    \    \n    \n    even::Vector{Int64} = lst[findall(x -> x % 2 == 0, lst)]\n  \
    \  return sum(map(x -> x if x in even else 0, lst))\nend \n</cell>\n<code language=julia-1.3>\n\
    sol = solution([5, 8, 7, 1])\n@test sol == 12 \n</cell>\n<text>\n6. \uC870\uAC74\
    \uBD80 \uD655\uC778\n\uD6C8\uB828\uB41C \uB370\uC774\uD130\uC5D0\uC11C \uC608\uCE21\
    \uAC12\uC774 \uC601\uD5A5\uC744 \uBBF8\uCE58\uC9C0 \uC54A\uC740 \uB370\uC774\uD130\
    \uC14B\uC740 \uD30C\uC774\uC36C\uC5D0\uC11C \uBB34\uC5C7\uC778\uC9C0 \uB2E4\uC74C\
    \uACFC \uAC19\uC2B5\uB2C8\uB2E4.", "    if length(lst) == 0 \n        return 0\
    \ \n    \n    if lst[1] == 2 \n        return lst[1] \n    \n    odd_sum = lst[1]\
    \ \n    for ii in 2:length(lst) \n        if lst[ii] == 0 \n            continue\
    \ \n        \n        if lst[ii-1] == 1 \n            continue \n        \n  \
    \      odd_sum += lst[ii] \n    end\n    return odd_sum \nend\n</cell>\n<text>\n\
    Problem 9: Sum all the elements of a Vector", '    return lst.sum .+ sum((lst[index]
    for index=1:length(lst)) .% 2 .== 0)', "    odd = 0\n    for n in lst\n      \
    \  if n%2 != 0\n            odd = odd + n\n        end\n    end\n    return odd\n\
    end\n</cell>\n<code language=julia-1.0>", "    \n    s = sum(lst[1::2])\n    for\
    \ i in lst[1::2]\n        if i mod 2 != 0\n            s += i\n        end\n \
    \   end\n    s\nend\n</cell>\n<text>\n3. Bubble Sort", "    return sum(lst[(2\
    \ .< lst) .& (lst .> 0)]) # filter out odd numbers from the even positions, sum\
    \ the elements\nend\n</cell>\n<text>\nSolution 2", "    even = lst[even.(lst)]\n\
    \    odd = lst[odd.(lst)]\n    sum = 0\n    for v in odd do\n        if v & 1\
    \ == 1 \n            sum += v\n        end\n    end\n    return sum\nend", " \
    \   \n    sum = 0\n    for i in 2:length(lst)\n        if lst[i] % 2 == 1\n  \
    \          sum += lst[i]\n        end\n    end\n    return sum\nend \n</code>\n\
    <|/ a tags=julia |>\n<| a |>\nUsing a combination of map, filter, and reduce:\n\
    <code>", "    n=length(lst)\n    if n==0 \n        throw(ArgumentError(\"the vector\
    \ is empty\"))\n    end\n    \n    even=filter(x -> x%2==1, lst)\n    odd=filter(x\
    \ -> x%2==0, lst)\n    return sum(filter(x -> x != n-1, odd))\nend\n</cell>\n\
    <text>\nPart 2\nDefine a function that takes in an integer $n$, and, if the number\
    \ is even and odd, returns the product of $n$ and $n-1$. If the number is odd\
    \ and even, return the product of $n$ and $n-2$. In all other cases, return the\
    \ product of $n$ and $n+1$. The function should throw an error if the input is\
    \ invalid.", "  if length(lst) == 0 \n    return 0\n  end\n  odd = filter(x ->\
    \ x % 2 != 0, lst)\n  even = filter(x -> x % 2 == 0, lst)\n  return sum(filter(x\
    \ -> x % 2 != 0, even)) + sum(filter(x -> x % 2 == 0, odd))\nend\n</cell>\n<code\
    \ language=julia-0.6>\n@time solution(collect(1:100000));\n</cell>\n<text>\nExercise:\
    \ Write a function to get an even number that appears at least three times in\
    \ a given vector.", "    even = lst[findall(x -> x % 2 != 0, lst)]\n    odd =\
    \ lst[findall(x -> x % 2 == 0, lst)]\n    return sum(odd - even)\nend\n</cell>\n\
    <text>\nExercise 7\nWrite a function that calculates the sum of all of the positive\
    \ integers less than 1000.", "    return sum( lst[end-2:end] .== 2 ) \nend\n</cell>\n\
    <code language=julia-0.6>\n@test solution([5, 8, 7, 1]) == 12\n@test solution([3,\
    \ 3, 3, 3, 3]) == 9\n@test solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\n\
    Part 5", "\t\n\t\n    count=0\n    for element in lst\n        if mod(element,\
    \ 2) == 1\n            count=count+1\n        end\n    end\n    return count\n\
    end\n</cell>\n<code language=julia-1.6>", '    return sum(lst[i : i + 2] .== 1)
    / 2 end', "    lst_ = copy(lst)\n    accumulate(lst_, +, ::Int64[2])\n    return\
    \ sum(lst_)\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8,\
    \ 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30,\
    \ 13, 24, 321]) == 0\n</cell>\n<text>\nsumsq\nGiven a vector of positive numbers,\
    \ return the sum of the squares of all of the elements.", "    s = 0\n    for\
    \ i in lst \n        if i%2==1 \n            s+=i\n        end \n    end\n   \
    \ return s\nend ", "\t\n\tlen = length(lst)\n\t\n\tif len==0 \n\t\treturn 0\n\t\
    end\n\t\n\tsum = 0\n\t\n\tfor i in 1 : len - 1 \n\t\tif lst[i] % 2 == 0 \n\t\t\
    \tsum += lst[i] \n\t\tend\n\tend\n\t\n\treturn sum\nend", "    if length(lst)\
    \ == 0 \n        return 0 \n    end", "  sum = 0 \n  for v in lst \n    if v%2\
    \ != 0 \n      sum += v \n  sum\nend\n</cell>\n<code language=julia-1.0>\n@assert\
    \ solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert\
    \ solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nProblem 15", "    \"\"\"\n\
    \    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n \
    \   9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    if lst.is_empty\
    \ || length(lst) <= 0\n        return 0\n    return sum(lst[lst.index(l)+lst.index(l+1)+1\
    \ : lst.index(l)+lst.index(l+1) : -1]) - sum(lst[lst.index(l) : lst.index(l)+1])",
  "    if lst == []\n        return 0\n    if length(lst) == 1\n        return lst[0]\n\
    \    if lst[end-1] % 2 == 0\n        return 0\n    sum = lst[end-1]\n    for i\
    \ in lst[start:end]\n        if i%2 == 1\n            sum += i\n    return sum\n\
    end ", "  if length(lst) == 0 \n    return 0\n  elseif length(lst) == 1 \n   \
    \ return lst[1]\n  elseif length(lst) == 2 \n    return lst[1] + lst[2]\n  end\n\
    \  \n  # Recursive case. \n  return sum(filter(x -> x % 2 == 1, lst))\nend\n</cell>\n\
    <code language=julia-1.1>\n\"\"\"\nReturn true if the given matrix is a valid\
    \ Sudoku matrix. ", "    sum = 0\n    for i in lst \n        if i%2==1 \n    \
    \        sum+=i\n        end\n    end\n    return sum\nend", "    n = length(lst)\n\
    \    if n <= 0 \n        return 0 \n    return sum(lst[i : i+2][i%2 ==1]) \nend\n\
    </cell>\n<code language=julia-1.4>\n@assert solution([5, 8, 7, 1]) == 12\n@assert\
    \ solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) == 0\n</cell>\n\
    <text>\nNotice that, just as in the previous challenge, the elements that we are\
    \ summing up are the even ones. If we sum up all the odd elements instead, we\
    \ would obtain the correct answer.", "    if length(lst) == 0 \n        return\
    \ 0 \n    \n    even_idx = 2:length(lst)\n    odd_idx = length(lst)-2:-1\n   \
    \ \n    even = [lst[i] where i in even_idx]\n    odd = [lst[i] where i in odd_idx]\n\
    \    \n    even = sum(filter(x -> x%2==0, even))\n    odd = sum(filter(x -> x%2==1,\
    \ odd))\n    \n    return even+odd\nend\n</cell>\n<code language=julia-1.5>",
  "    evens = filter(x -> x%2 == 0,lst)\n    return sum(evens)\nend", "    return\
    \ sum(lst[findlast(i->i%2==1,lst)]) \nend\n</cell>\n<code language=julia-1.6>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart B\nWrite a function\
    \ that computes the median of a vector of numbers, without using an extra data\
    \ structure.  Assume that the vector is sorted in ascending order (from smallest\
    \ to largest).", "    return sum((lst[x+1:y]:x<y&&y<x+2) for x=1:length(lst)-1\
    \ && y=1:(length(lst.minus(lst[x]))-length(lst[x]))+2)\nend", "    sum = 0 \n\
    \    for i in lst \n        if i%2 == 1 \n            sum += i \n        end \n\
    \    end \n    return sum \nend \n</cell>\n<code language=julia-1.0>", "    for\
    \ i in lst \n        if mod(i, 2) == 1 \n            \n        end \n    end \n\
    \    \n    \n    return sum(lst)\nend\n</cell>\n<code language=julia-1.5>\n##\
    \ Your code here", "    # write your code in Python 3.6\n    \n    sum = 0\n \
    \   odd = 1\n    even = 1\n    for i in lst\n        if odd % 2 == 0\n       \
    \     sum += i\n        else if even % 2 == 0\n            sum += i\n        else\n\
    \            even = odd + 1\n            odd = 1\n        end\n    end\n    return\
    \ sum\nend", "    if length(lst) == 0\n        return 0\n    \n    odd = lst[findall(lst\
    \ .%2==1)] \n    even = lst[findall(lst .%2==0)]\n    return sum(odd[findall(even.>0)])",
  "    answer = 0.0\n    for n in lst\n        if n % 2 == 1\n            answer +=\
    \ n\n        end\n    end\n    return answer\nend\n</cell>\n<code language=julia-1.5>\n\
    # Run this cell for unit tests\n@test solution([5, 8, 7, 1]) == 12\n@test solution([3,\
    \ 3, 3, 3, 3]) == 9\n@test solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\n\
    Solution 3\nFor our final problem, let's write a function that uses mapslices\
    \ to find the sum of numbers in an array. mapslices allows you to easily find\
    \ subsets of the elements of an array. The syntax is mapslices(f, A, idxs). Here\
    \ f is a function handle that you pass in, A is the array you wish to apply f\
    \ to, and idxs is the indices of the elements of A that you wish to apply f to.",
  "    evensum = 0\n    for x in lst\n        evensum = evensum + x%2 == 0 ? x : 0\n\
    \    end\n    return evensum\nend", "    sum = 0\n    for i in 2:length(lst)\n\
    \        if lst[i]%2 != 0 && lst[i-1]%2 == 0\n            sum += lst[i]\n    \
    \    end\n    end\n    return sum\nend\n</cell>\n<code language=julia-0.6>\n@code_warntype\
    \ solution([5, 8, 7, 1])\n</cell>\n<code language=julia-0.6>\n@code_warntype solution([3,\
    \ 3, 3, 3, 3])\n</cell>\n<code language=julia-0.6>\n@code_warntype solution([30,\
    \ 13, 24, 321])\n</cell>\n<code language=julia-0.6>\n@code_warntype solution([0,\
    \ 13, 24, 321])\n</cell>\n<code language=julia-0.6>", "\"\"\"\n    \n    \n  \
    \  \n    \n\"\"\"\n    Given a non-empty vector of integers, return the sum of\
    \ all of the even elements that are in odd positions.\n    ", "    if lst==[]\
    \ then return 0\n    sum=0\n    for i in lst\n        if i%2==0 then\n       \
    \     sum+=i\n        elseif i%2==1 then\n            sum+=(i-1)\n        end\n\
    \    end\n    return sum\nend\n</cell>\n<code language=julia-0.4>\n@code_warntype\
    \ solution([5, 8, 7, 1])\n</cell>\n<text>\nExercise 2\nWrite a function that takes\
    \ a vector of integers and a number, $n$, and returns the sum of the first $n$\
    \ odd integers in the vector. \nFor example, given [1, 2, 3, 4], a call to odd_sum([],\
    \ 3) should return 6.", "    even = lst[findall(lst .== 3)] \n    odd = lst[findall(lst\
    \ .== 2)] \n    sum(even) .+ sum(odd) \nend\n</cell>\n<text>\n Question 2.2 ",
  "    evenSum = 0\n    for num in lst\n        evenSum += mod(num,2)\n    end\n \
    \   return evenSum\nend", "    sum = Int.(0)\n    for i in 2 : (lst[i] - 1)\n\
    \        if lst[i] % 2 == 1\n            sum += lst[i]\n        end \n    end\
    \ \n    return sum\nend \n</code>\n<|/ a tags=julia |>\n<| a tags=julia |>\n<code>",
  "    even = filter(x -> x % 2 == 0, lst)\n    odd = filter(x -> x % 2 == 1, lst)\n\
    \    return sum(map(x -> odd.indexOf(x) + even.indexOf(x), lst))\nend\n</cell>\n\
    <code language=julia-1.0>\n@testset \"Problem 3\" begin\n    solution([5, 8, 7,\
    \ 1])\n    solution([3, 3, 3, 3, 3])\n    solution([30, 13, 24, 321])\nend\n</cell>\n\
    <text>\nProblem 4\nGiven a matrix of zeros and ones, find the row with the maximum\
    \ number of ones. Return this row as a two-element vector A, and the sum of its\
    \ non-zero elements.", "    \n    \"\"\"\n    Return the sum of the elements of\
    \ the vector, excluding the first\n    element.\n    \n    Parameters\n    ----------\n\
    \    lst : Vector\n        Vector of integers\n    \n    Returns\n    -------\n\
    \    sum : Int64\n        Sum of the elements of `lst`\n    \"\"\"\n    \n\"\"\
    \"\n    Given a non-empty vector of integers, return a new vector of\n    alternating\
    \ True and False elements with the length of the vector.", "    return sum(lst[(i+1):(i+length(lst)):2])\
    \ % 2 == 0\nend\n</cell>\n<code language=julia-1.0>", "  lst.sort()\n  lst.take(length(lst):-1:1).sum\
    \ + lst.take(length(lst):-1:2).sum\nend\n</cell>\n<code language=julia-0.6>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nExercise 2\nWrite a\
    \ function which accepts a single non-negative integer ($n$) which represents\
    \ the number of elements in the input vector. Then, return a vector consisting\
    \ of only the even numbers of that vector. For example, if the input is [3, 5,\
    \ 6, 1, 4, 2], the function should return [3, 6, 4, 2].", "    sum = 0 \n    for\
    \ i in lst\n        sum += i%2 == 0 ? i : -1\n    end\n    sum\nend\n</cell>\n\
    <code language=julia-1.0>", "    return sum(lst[(2i+1)%3==0 for i in 1:length(lst)])\n\
    end", "    return (lst[findall(x -> x % 2 != 0, lst)].sum) \nend", "    \n   \
    \ vec1 = zeros(0, Int64)\n    vec2 = zeros(0, Int64)\n    \n    # iterate through\
    \ the list\n    for i in lst\n        if i%2 == 1\n            push!(vec1, i)\n\
    \        else \n            push!(vec2, i)\n        end\n    end", "    sum(lst[1::2])\n\
    end\n</cell>\n<text>\nExercise 8\nWrite a function that finds the maximum value\
    \ in a list of numbers.", "    if lst == []\n        0\n    elseif length(lst)\
    \ == 1\n        lst[1]\n    else\n        sum((lst[2:end] .== lst[1]) .* lst[1:end-1])\
    \ \n    end\nend\n</cell>\n<text>\nQuestion 9\nWrite a function is_valid that\
    \ takes one vector of integers and returns true if the vector contains a valid\
    \ set of numbers.", "    lst = lst.sort\n    odd = findfirst(x->x%2==1, lst)\n\
    \    if odd != nothing\n        sum(lst[begin:odd:2])\n    end\nend", "    \"\"\
    \"\n    Given a non-empty vector of integers, return the sum of all of the odd\
    \ elements that are in even positions.\n    \n    Parameters\n    ----------\n\
    \    lst : Vector{Int64}\n        List of integers", "    return sum(x for x in\
    \ lst if x % 2 == 1)\nend\n</cell>\n<text>\nReturn an $n$-by-$m$ matrix that represents\
    \ the following transformation $\n\\begin{bmatrix}\n    x{11} & x{12} & x{13}\
    \ & x{14} & x{15} \\\n    x{21} & x{22} & x{23} & x{24} & x{25} \\\n    x{31}\
    \ & x{32} & x{33} & x{34} & x{35} \\\n    x{41} & x{42} & x{43} & x{44} & x{45}\
    \ \\\n    x{51} & x{52} & x{53} & x{54} & x{55}\n\\end{bmatrix}\n$ where $\n\\\
    begin{bmatrix}\n    x{11} \\\n    x{12} \\\n    x{13} \\\n    x{14} \\\n    x{15}\
    \ \\\n\\end{bmatrix}\n= y{11} x{11} + y{12} x{12} + y{13} x{13} + y{14} x{14}\
    \ + y{15} x{15}\n$", "    \"\"\"\n    sum=0\n    for n in lst\n        if n%2==0\n\
    \            sum+=n\n        end\n    end\n    return sum\nend", "    if length(lst)==0\
    \ || length(lst)==1 || lst[1]==0 || length(lst)==2 return 0\n    sum = 0\n   \
    \ for x in lst[2:end]\n        if x%2 ==1\n            sum += 1\n        end\n\
    \    end\n    return sum\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n\
    The easiest method I found and most straightforward for me was to use the sum()\
    \ function on the slices [2:end] of the vector.  The function takes two arguments\
    \ \u2014 a vector and a range.  If the first argument is omitted, the range defaults\
    \ to 0:end-1.\n<code>\nv = [3, 1, 2, 4, 5, 5, 4]\nsum(v[2:end])\n</code>\n<|/\
    \ a tags=julia,algorithm |>\n<| a |>\nHere are a couple more options that don't\
    \ require a loop:\n<code>\njulia> sum(x -> x % 2 ==1 , each(v))\n12", "    \n\
    \    vec= vecdiff(lst)\n    \n    for v in vec\n        if vec[v]%2==1\n     \
    \       return vec[v]\n            \n    return 0\nend\n</cell>\n<code language=julia-1.1>\n\
    # Testing solution\nsolution([5, 8, 7, 1])\n</cell>\n<text>\nProblem 5\nA partially\
    \ filled matrix M has an entry of the form [x_1, x_2, x_3, ... , x_n] where x_i\
    \ are nonnegative integers and M[i, j] is equal to the product of x_i and x_j.",
  "    \n    if length(lst) == 0 \n        0\n    else \n        sum(lst[1 .. end-1])\
    \ \n    end\nend\n</cell>\n<code language=julia-0.6>\n@code_warntype solution([3,\
    \ 9, 7, 4, 2])\n</cell>\n<text>\nPart 3 - Infinite Streams\nWe are going to look\
    \ at what happens when we try to do \"infinite\" streams. We want to be able to\
    \ iterate over them without having to explicitly know how long they are. A very\
    \ basic thing to do is to return something that acts like an iterator but does\
    \ not actually have a finite length.", "    evens=find(lst==0)\n    odds=find(lst~=0)\n\
    \    evensum=0\n    for e in evens\n        evensum+=lst[e]\n    end\n    return\
    \ evensum+reduce(+, lst[odds])\nend\n</cell>\n<code language=julia-0.4>\n@test\
    \ solution([1,2,3]) == 3\n@test solution([3]) == 0\n@test solution([5,8,7,1])\
    \ == 12\n@test solution([3,3,3,3,3]) == 9\n@test solution([30, 13, 24, 321]) ==\
    \ 0\n@test solution([-5,-3,-7,-6,-23,-29,-33,-25]) == 3\n</cell>\n<text>\nExercise\
    \ 15: Find all elements in a vector less than 3", "    #import Base.sum\n    #\
    \ import Base.sum_by \n    # import Base.count_by\n    \n    even=filter(x ->\
    \ x%2==0, lst)\n    odd = filter(x -> x%2 != 0, lst)\n    \n    return sum(odd)\n\
    end", "    # sum of odd elements\n    even = 0\n    for i in lst\n        if mod(i,\
    \ 2) == 0\n            even = even + i\n        end\n    end\n    return even\n\
    end\n</cell>\n<text>\nQuestion 6\nWrite a function that will take a vector of\
    \ integers, and return a vector with all the numbers in it, but sorted from smallest\
    \ to largest.", "  summ = 0\n  for i in lst:\n    if i%2 == 1\n      summ+= i\n\
    \    end\n  end\n  return summ\nend\n</cell>\n<code language=julia-1.5>\nsol =\
    \ @time solution([5,8,7,1])\n</cell>\n<text>\nVectorize is another option, and\
    \ you can read about it in the documentation. Here we're going to see it briefly\
    \ using vectorize:", "    result = Int64(0)\n    for a in lst\n        result\
    \ += Int(a[1%2:end]) \n    return result", "    if length(lst)==0 \n        return\
    \ 0 \n    \n    return lst[even_inds(lst)].reduce(+) + lst[odd_inds(lst)].reduce(+)\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) ==\
    \ 0\n</cell>\n<text>\n12.13. Odd sums II\nA set of numbers $X = {x_1, x_2, \\\
    cdots, x_n}$ can be partitioned into two subsets $A \\subseteq X$ and $B \\subseteq\
    \ X$ such that $x_1 + x_2 + \\cdots + x_n = 2n$. We define an odd sum over $X$\
    \ to mean the sum of all odd positive integers that appear in $X$, that is $O(n).$",
  "    # write your code in Ruby\n    evens = filter((x)->x%2==0, lst)\n    return\
    \ sum(filter(x -> x%2==1, evens))\nend\n</cell>\n<text>\nExercise - Write a function\
    \ that takes two vectors of integers as parameters and returns the element-wise\
    \ sum of the two vectors.", "    if length(lst) == 0 \n        return 0 \n   \
    \ end\n    sum = lst[1]\n    for i in 2:length(lst)\n        if lst[i] % 2 ==\
    \ 0\n            sum += lst[i]\n        end\n    end\n    return sum\nend\n\"\"\
    \"\nGiven a non-empty vector of integers, return a new vector consisting of the\
    \ largest elements from\nthe original followed by the sum of all of the even elements\
    \ in the original vector. \nIf two or more elements are equal, only the first\
    \ occurrence is kept. \nYou may assume that the original vector does not contain\
    \ any duplicate elements.", "    if length(lst)==0 \n        return 0 \n    end\n\
    \    evenpos = lst[div(length(lst),2)]\n    evensum = sum(lst[div(length(lst),2)+1:div(length(lst),2)+2])\n\
    \    oddsum = sum(lst[div(length(lst),2)+2:length(lst)])\n    return evensum+oddsum-evenpos\n\
    end\n</cell>\n<text>\nCoding Exercise #2\nWe have already written the function\
    \ that sums the even and odd numbers in a given vector. Now, write a function\
    \ that takes in a list of numbers and returns the sum of numbers in the even positions.",
  "    # write your code in Python 3 or in Julia 0.6 or later\n    # YOUR_CODE_HERE\n\
    \    sum = 0\n    for i = 1:length(lst)\n        if lst[i] % 2 == 1\n        \
    \    sum += lst[i]\n        end\n    end\n    return sum\nend\n</cell>\n<code\
    \ language=julia-0.6>\n# run this cell to check your answer\nt = Vector{Int64}([5,\
    \ 8, 7, 1])\nsol = solution(t)\n@show sol\n</cell>\n<text>\nSolution 2", "  if\
    \ length(lst) == 0\n    return 0\n  end\n    \n  # find first even number\n  idx\
    \ = first(i for i in lst if i%2 == 0)\n  \n  if idx < length(lst)\n    # find\
    \ sum of all odd numbers in even positions\n    sum = sum((lst[i] for i in idx...idx+2))\n\
    \  else\n    sum = -1\n  end\n  return sum\nend\n</code>\n<|/ a |>\n<| c |>\n\
    Yes, this is better than the accepted answer (which uses `filter`), but the accepted\
    \ answer is simpler and better.\n<|/ c |>\n<| c |>\nThanks so much. I really appreciate\
    \ this. \nI appreciate it very much.\n<|/ c |>\n<| c |>\n- Thanks for that!\n\
    <|/ c |>\n<| a tags=sum,arrays,julia |>\nThe correct way of doing it is:\n<code>",
  "    \n    sum_ = 0\n    \n    for i in 1:length(lst)\n        sum_ += lst[i] mod\
    \ 2 != 0 ? 0 : lst[i]\n    end", "    sum=0\n    evens=[]\n    for i in lst\n\
    \        if i%2==0\n            sum+=i\n        else\n            evens+=[i]\n\
    \    end\n    for e in evens\n        sum+=e\n    end\n    return sum\nend\n</cell>\n\
    <code language=julia-1.2>\n@code_native solution([5, 8, 7, 1])\n</cell>\n<code\
    \ language=julia-1.2>\n@code_native solution([3, 3, 3, 3, 3])\n</cell>\n<code\
    \ language=julia-1.2>\n@code_native solution([30, 13, 24, 321])\n</cell>\n<code\
    \ language=julia-1.2>\n@code_native solution([])\n</cell>\n<code language=julia-1.2>\n\
    @code_native solution([2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,\
    \ 19, 20, 21])\n</cell>\n<code language=julia-1.2>\n@code_native solution([10,\
    \ 20, 30, 40, 50, 60, 70])\n</cell>\n<code language=julia-1.2>\n@code_native solution([20,\
    \ 50, 100, 200, 300, 500, 1000])\n</cell>\n<code language=julia-1.2>\n@code_native\
    \ solution([50, 200, 300, 500, 1000])\n</cell>\n<code language=julia-1.2>\n@code_native\
    \ solution([50, 500, 1000])\n</cell>\n<code language=julia-1.2>\n@code_native\
    \ solution([50, 200])\n</cell>\n<code language=julia-1.2>\n@code_native solution([50,\
    \ 200, 500, 1000])\n</cell>\n<text>\nExercise 3\nYou have a vector of real numbers,\
    \ and want to know if any two consecutive elements in the vector sum to the same\
    \ value. You need to return whether there is a solution or not.", "    sum = Int64(0)\n\
    \    for (index, element) in enumerate( lst)\n        if index%2 ==0 \n      \
    \      sum+=element\n        end\n    end\n    return sum\nend\n</cell>\n<text>\n\
    The first argument passed to the function is a vector. Vectors are a generalization\
    \ of a list. The Julia language provides an abstract datatype Vector, which is\
    \ used here to define the function. Vectors are similar to arrays except for their\
    \ element type, and unlike arrays, they have a length field.", "    if lst ==\
    \ [] return 0\n    local sum = 0\n    for i in lst\n        if i%2 == 0 then sum\
    \ += i\n        else sum\n        end\n    end\n    return sum\nend", "    ans\
    \ = 0\n    for i in lst\n        if i%2 == 0\n            ans += i\n        end\
    \ \n    end\n    ans\nend\n</cell>\n<text>\nProblem 3\nGiven an input string (s)\
    \ and a target string (t), check whether the\ntarget string appears in the same\
    \ position in s as the string t.\nThe same positions means the same letter, even\
    \ the same case. Return True if\nthe target string appears in the same position\
    \ in s as the string t.\nOtherwise return False.", "    if length(lst) == 0 ||\
    \ length(lst) == 1 \n        return 0 \n    sum = 0 \n    for i in lst \n    \
    \    if i%2 == 0 \n            sum += i \n        end \n    end \n    return sum\
    \ \nend ", "    for i in 0..(length(lst)-1)\n        if lst[i] % 2 != 0 && lst[i+1]\
    \ % 2 == 0\n            lst[i+1] += lst[i]\n            lst[i] = 0\n        end\n\
    \    end\n    return sum(lst)\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nCan you\
    \ please explain me what does `function solution(lst::Vector{Int64})::Int64` mean?\n\
    <|/ c |>\n<| c |>\nthat is a function definition for a function \"solution\".\
    \ `function foo()` defines a function that is a \"foo\" function, and `function\
    \ foo(arg1, arg2)` defines a function that has 2 arguments and has a return value.\
    \ In this case, you just need the return value, so you just need to write `function\
    \ solution(lst::Vector{Int64})::Int64`, but you can also write `solution = foo`\
    \ or you can even skip the function name `function solution(lst::Vector{Int64})`\
    \ and simply write `solution(lst::Vector{Int64})`. The `::Int64` is just the return\
    \ type, which specifies that the function returns a `Int64`\n<|/ c |>\n<| a |>\n\
    <code>", "    # Write your code in Python 3.6\n    return sum([lst[j] for j in\
    \ 2:length(lst) if lst[j] % 2 == 1])\nend", "    evensum = 0\n    for i in lst\n\
    \        if i%2==0\n            evensum+=i\n        end\n    end\n    return evensum\n\
    end\n</cell>\n<code language=julia-0.6>\n@code_warntype solution([5, 8, 7, 1])\n\
    </cell>\n<code language=julia-0.6>", "    sum = 0\n    for i in lst\n        if\
    \ i%2==1\n            sum=sum+i\n        end\n    end\n    return sum\nend\n</cell>\n\
    <code language=julia-1.5>\n#export", "    oddSum::Int64 = 0\n    for i in lst\n\
    \        if i%2==1\n            oddSum += i\n        end\n    end\n    return\
    \ oddSum\nend\n</cell>\n<text>\nExercise 3 - The Largest Product Subset", "  \
    \  return sum(lst[x for x = 1:length(lst)-1 if x % 2 == 1]) \nend\n</cell>\n<text>\n\
    Part 4: Recursion", "    count = 0\n    for i in lst\n        if i %2 != 0\n \
    \           count += 1\n        else\n            count += i\n    end\n    return\
    \ count\nend", "    odds = Vector{Int64}(length(lst)+1)\n    odds[1] = 1\n   \
    \ for i in 2:length(lst)\n        if lst[i] % 2 != 0\n            odds[i] = odds[i-1]\
    \ + odds[i-2]\n        else\n            odds[i] = odds[i-1]\n        end\n  \
    \  end\n    return sum(odds)\nend", "    s = 0 \n    for i in 1:length(lst)\n\
    \        s += lst[i] %% 2\n        if lst[i] % 2 > 0\n            s += lst[(i-1)\
    \ % length(lst)]\n        end\n    end\n    return s\nend", "  \n    @assert all(isodd(lst))\n\
    \    sum = 0\n    for i = 2:length(lst)\n        if lst[i] % 2 != 0 && lst[i-1]\
    \ % 2 == 0\n            sum = sum + lst[i]\n        end\n    end\n    return sum\n\
    end\n</cell>\n<code language=julia-1.5>", "    sum = 0 \n    \n    for x in lst\n\
    \        if x%2 != 0 \n            sum += x\n        end\n    end\n    return\
    \ sum\nend", "    \n    if length(lst) == 0 \n        return 0 \n    \n    \n\
    \    odd_elements = lst[lst[1::2] - 1 ] \n    \n    if length(odd_elements) ==\
    \ 0 \n        return 0 \n    \n    \n    evens_elements = lst[2: length(lst)]\
    \ \n    \n    if length(evens_elements) == 0 \n        return 0 \n    \n    \n\
    \    \n    odd_sum = sum(odd_elements)\n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    ", "    odd =\
    \ falses(length(lst))\n    for i in eachindex(lst)\n        if lst[i] % 2 != 0\n\
    \            odd[i] = true\n            \n    return sum(lst[i] for i in eachindex(lst)\
    \ if !odd[i]) \nend ", "    \n    sum::Int64 = 0\n    \n    for i in lst\n   \
    \     if i %2 == 1\n            sum += i\n        end\n    end", "    if length(lst)\
    \ == 0 \n        return 0 \n    else \n        odd = map(i -> if mod(i, 2) ==\
    \ 1 then i else 0, lst)\n        return sum(map(i -> odd[i], lst))\nend\n</cell>\n\
    <code language=julia-1.4>\n@time solution([30, 13, 24, 321])\n</cell>\n<text>\n\
    Challenge Problem 8\nGiven a vector of integers, return a new vector where each\
    \ element is multiplied by 2, and all other elements are multiplied by 5 (no other\
    \ elements should be changed). You may return the original vector if no modifications\
    \ are allowed.", "    evens = collect(2::Int64)\n    odds = collect(1::Int64)\n\
    \    \n    if length(lst) == 0 \n        return 0 \n    end", "    even = filter(x\
    \ -> x % 2 != 0, lst)\n    sum = reduce(+, even)\n    return sum\nend", "    if\
    \ length(lst) == 0 || lst[1] == 0 \n        return 0 \n    end\n    even::Vector{Int64}\
    \ = Vector{Int64}(lst[2 : 2end]) \n    odd::Vector{Int64} = Vector{Int64}(lst[1\
    \ : end-1]) \n    odd_sum = sum(odd)\n    even_sum = sum(even) \n    return odd_sum\
    \ - even_sum\nend\n</cell>\n<text>\nThe first thing we did was define two vectors\
    \ that we want to sum. The first vector holds all the even elements and the second\
    \ holds all the odd elements. These two vectors have a few differences. \nThe\
    \ first is that they have an extra element at the end to account for the last\
    \ element in an odd vector. \nThe second is that even starts at an index 2 while\
    \ odd starts at an index 1", " \n    if length(lst)==0\n        return 0\n   \
    \ end\n    \n    if length(lst)==1\n        if lst[0]%2==0\n            return\
    \ lst[0]\n        end\n    end\n    \n    for i in 1:length(lst)\n        if lst[i]%2==0\
    \ && lst[i]%2!=i\n            return lst[i]\n        end\n    end\n    return\
    \ 0\nend \n</cell>\n<code language=julia-1.0>\n#== C) Naive Implementation ==#",
  "    sum = 0 \n    for v in lst[2 : 2end .. end]\n        if mod(v, 2) == 1 \n \
    \           sum += v\n        end\n    end\n    return sum\nend", "    # Write\
    \ your code in Python 2.7\n    \n    return sum(lst[lst[ind]==0] for ind in 1:length(lst)-1)\n\
    end\n</cell>\n<code language=julia-1.5>\n# Test your function", "    sum = 0\n\
    \    evenidx = 1\n    for i = 1, length(lst) do\n        if lst[i] % 2 == 0 then\n\
    \            sum += lst[i]\n        else\n            sum += lst[i]\n        \
    \    if lst[i] % 2 == 1 then\n                evenidx += 1\n            end\n\
    \        end\n    end\n    \n    oddidx = 1\n    for i = 1, length(lst) do\n \
    \       if lst[i] % 2 ~= 0 then\n            sum += lst[i]\n        else\n   \
    \         sum += lst[i]\n            if lst[i] % 2 == 1 then\n               \
    \ oddidx += 1\n            end\n        end\n    end\n    return sum - sum*oddidx/evenidx\n\
    end\n</cell>\n<code language=julia-1.0>", "    \n    return sum([v for v in lst\
    \ if v%2==1])\nend\n</cell>\n<code language=julia-1.0>\n@assert solution([5, 8,\
    \ 7, 1]) == 12 \n@assert solution([3, 3, 3, 3, 3]) == 9 \n@assert solution([30,\
    \ 13, 24, 321]) == 0\n</cell>\n<text>\nPart Two\nOne more application of filters.\
    \ Here, given a non-empty vector of integers, return a new vector that contains\
    \ only the even elements from this original vector.", "    sum = 0\n    for x\
    \ in lst\n        if x%2 != 0 && x%2 == 1\n            sum += x\n        end\n\
    \    end\n    return sum\nend\n</cell>\n<text>\nQ9. Write a function that takes\
    \ a vector as an input and returns another vector that contains only even elements\
    \ of the original vector.", "    summ=0\n    for i in lst\n        if i%2==1\n\
    \            summ+=i\n        end\n    end\n    return summ\nend", "    if length(lst)\
    \ == 0 \n        return 0 \n    end\n    even = findall(x -> x % 2 == 0, lst)\n\
    \    odd = findall(x -> x % 2 != 0, lst)\n    \n    if length(even) == 0\n   \
    \     return lst[end] + sum(odd)\n    else\n        odd_val = sum(lst[findfirst(x\
    \ -> x % 2 != 0, lst):end])\n        return odd_val + sum(even)\n    end\nend\n\
    </cell>\n<text>\nVectorized Functions\nThis section deals with the use of vectorized\
    \ functions in Julia.", "    for i in lst:\n        if i%2==1:\n            i+=i\n\
    \    return i\nend\n</cell>\n<code language=julia-0.5>\n@time solution(1:100000)\n\
    </cell>\n<code language=julia-0.5>\n@time solution([1,2,3,4,5])\n</cell>\n<text>\n\
    Problem 8: Find the sum of the primes below 2 million", "    vec =zeros(Int, length(lst))\n\
    \    \n    for i in eachindex(lst)\n        vec[i] = sum(lst[i-2 :i]) #sum of\
    \ even numbers on index i \n    end", "    s = 0\n    for i in lst\n        if\
    \ i%2 == 1\n            s += i\n        end\n    end\n    return s\nend\n</cell>\n\
    <code language=julia-1.3>", "    if length(lst) == 0 \n        return 0 \n   \
    \ \n    summed = 0\n    for elem in lst\n        summed += elem\n        if elem\
    \ % 2 == 0\n            summed += sum( lst[elem+1:length(lst)])\n        end\n\
    \    end", "    sum=0\n    for v in lst\n        if v%2 == 0\n            sum\
    \ += v\n        end\n    end\n    return sum\nend", "    even_idxs = findall((x\
    \ -> x % 2 != 0, lst))\n    odds = lst[even_idxs]\n    sum(odds..maximum(odds..0)+0)\n\
    end", "    evensum = sum(lst[x % 2 == 0])\n    oddsum = sum(lst[x % 2 != 0])\n\
    \    return evensum + oddsum\nend", "    evensum::Int64 = 0\n    evensum = 0\n\
    \    for i in lst\n        if i %% 2 == 0\n            evensum = evensum + i\n\
    \        \n    return evensum\nend", "    sum = 0\n    for i in lst\n        sum\
    \ += i\n        if ((i .%2)==0) \n            sum += (i + 1)\n        end\n  \
    \  end\n    sum\nend\n</cell>\n<text>\nDay 12: Binary Search", "    \n    odd\
    \ = falses(length(lst))\n    even = trues(length(lst))\n    for i in 0 .. length(lst)-1\
    \ do\n        if even[i] && odd[i]\n            odd[i] = false\n        elseif\
    \ even[i] && !odd[i]\n            even[i] = false\n        else\n            odd[i]\
    \ = true\n            even[i] = true\n        end\n    end\n    return sum(filter(x\
    \ -> x % 2 != 0, lst))\nend\n</cell>\n<text>\nSum All Elements Odd With Repetitions",
  "  sum = 0\n  for n in lst\n    if n % 2 == 1\n      sum += n\n    end\n  end\n\
    \  sum\nend", "    evens = lst[findall(lst .% 2 == 1)]\n    return sum( evens[find(evens\
    \ .== 2)[2]] )\nend\n</cell>\n<code language=julia-1.3>\n@time solution(large_vector_of_numbers)\n\
    </cell>\n<code language=julia-1.3>\n@time solution(large_vector_of_numbers)\n\
    </cell>\n<code language=julia-1.3>", "   \n    if length(lst)==0\n        return\
    \ 0\n    end", "    evens = filter(x -> x % 2 ==0, lst)\n    return sum(evens)\n\
    end", "    if length(lst) < 1\n        return -1\n    elseif length(lst) == 2\n\
    \        return lst[1]+lst[1]\n    elseif length(lst) > 2\n        return sum(lst[findall(x\
    \ -> x%2==0, lst):2:end])\n    end\nend\n</code>\n<|/ a |>\n<| a |>\nHere's a\
    \ version that works for any size of list. Also, you don't need to use type annotations\
    \ when calling functions in Julia:\n<code>", "    return sum(lst[findall(lst .==\
    \ 3)])\nend", "    if length(lst)<2 return 0\n    \n    \n    even::Vector{Int64}\
    \ = lst[findall(x -> x == 0, lst)]\n    odd::Vector{Int64} = lst[findall(x ->\
    \ x == 1, lst)]\n    return sum(even[findall(x -> x == 2, even)])+sum(odd)\nend\n\
    </cell>\n<code language=julia-1.3>\n@test solution([5, 8, 7, 1]) == 12\n@test\
    \ solution([3, 3, 3, 3, 3]) == 9\n@test solution([30, 13, 24, 321]) == 0\n</cell>\n\
    <code language=julia-1.3>\n\"\"\"Given a vector of strings, return a vector where\
    \ each string in the original vector has been surrounded by double quotes and\
    \ separated by commas.\n    ", "    for i in 0 .. (length(lst) - 1) \n       \
    \ if lst[i] % 2 == 1 \n            i += 1 \n        else \n            return\
    \ i + sum((lst[i:end])[2:end]) \n    end \n    return 0\nend ", "    return sum(lst[1::2])\
    \ \nend", "    for i in lst \n        if mod(i, 2) == 1 \n            sum = sum\
    \ + i \n        end \n    end \n    \n    return sum \nend ", "    if length(lst)\
    \ == 0 \n        return 0 \n    \n    total = 0 \n    for index1 in 1:length(lst)\
    \ \n        total = total + lst[index1] % 2 == 1 ? \n        lst[index1] \n  \
    \      :: 0 \n    end \n    return total \nend \nend \n</code>\n<|/ a dscore=1\
    \ tags=julia,arrays,algorithm |>\n<| a dscore=0 |>\nA bit late, just posting my\
    \ solution here. Hope it helps.\n<code>", "    \n    return 0\nend", "    if length(lst)\
    \ < 2 \n        return Int64(0)\n    end\n    sum = 0\n    for i in lst \n   \
    \     if i%2 != 0\n            sum += i\n        end\n    end\n    return sum\n\
    end\n</code>\n<|/ a tags=julia,if-statement,sum dscore=0 |>\n<| c |>\nI believe\
    \ that this code would have problems if the vector had a length smaller than 2.\
    \ Try testing with [1,2] or [1,1,2]\n<|/ c |>\n<| c |>\nThanks for the feedback.\
    \ I have included a better solution that should cover all cases.\n<|/ c |>\n<|\
    \ c |>\nYou probably don't need to convert to a vector and loop at all. There\
    \ are `sum` and `mean` (which would also get rid of the problem of vectors of\
    \ length less than 2) functions.\n<|/ c |>\n<| c |>\nYes, I totally agree, but\
    \ I think it is helpful to understand the process behind what is going on. I believe\
    \ that if he doesn't know how to do this with the built-in functions he should\
    \ understand how to do it. I will edit my answer to include this solution.\n<|/\
    \ c |>\n<| a |>\nAs an alternative to previous answers, you could use reduce and\
    \ sum to do the same thing, in a single line:\n<code>\nreduce(+, vfilter(x ->\
    \ x%2 != 0, v))\n</code>\n<|/ a tags=julia,if-statement,sum dscore=0 |>\n<| c\
    \ |>\nYou can shorten this to: `reduce(+, vfilter(x -> x%2 != 0, v))`\n<|/ c |>\n\
    <| a |>\nYou can simply sum the elements except the odd ones:\n<code>\njulia>\
    \ sum.([5,7,8,1])\n12\n</code>\n<|/ a tags=julia,if-statement,sum dscore=0 |>\n\
    <| a |>\nSolution with no loops and no if condition:\n<code>", "    even, odd\
    \ = [], []\n    for i in lst\n        if i % 2 == 0 \n            push!(even,\
    \ i)\n        else\n            push!(odd, i)\n        end\n    end\n    return\
    \ sum(odd + even)\nend\n</cell>\n<text>\nQ16. Given an array arr of positive numbers,\
    \ return the product of the odd numbers. \nYou may assume that the array is length\
    \ 3 or more.", "    sum = 0\n    for x in lst\n        if x % 2 != 0\n       \
    \     sum += x\n        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @time solution(vec(1:10000000))\n</cell>\n<text>\nEjercicio 6\nEl siguiente ejercicio\
    \ esta basado en el conjunto de datos de Kaggle de sobrea\xF1os, a\xF1os y cinco\
    \ paises del siglo de Mexico, disponible en la p\xE1gina de Kaggle.", "    odd_positions\
    \ = [i for i in lst if i %% 2 == 1]\n    even = sum(odd_positions)\n    return\
    \ even\nend", "    sum = 0 \n    for ele in lst[1 : (end-1) : 2]\n        sum\
    \ += ele * 1\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\n4.2 Using mapslices()\
    \ for applying a function on every element of a vector", "    sum = 0\n    for\
    \ i in lst\n        if i%2==0\n            sum += i\n        end\n    end\n  \
    \  \n    return sum\nend\n</cell>\n<text>\nProblem 7\nWrite a function that takes\
    \ one vector of length n, and returns its absolute value sum.", "    if length(lst)\
    \ == 0\n        return 0\n    else\n        sum(lst[findall(x -> x == lst, lst[end-1:end])])\n\
    \    end\nend\n</cell>\n<code language=julia-0.6>\n@assert solution([5, 8, 7,\
    \ 1]) == 12 \n@assert solution([3, 3, 3, 3, 3]) == 9 \n@assert solution([30, 13,\
    \ 24, 321]) == 0 \n</cell>\n<text>\nNotice that when the list is empty the sum\
    \ of all odd elements is 0", "    n = length(lst)\n    evens = zeros(Int64, n-2)\n\
    \    for i in 1:n-2\n        if lst[i] % 2 == 0\n            evens[i] += 1\n \
    \       end\n    end\n    return sum(evens)\nend\n</cell>\n<code language=julia-1.1>\n\
    #export", "    if lst == []\n        return 0 \n    end\n    \n    sum = 0\n \
    \   i = 1;\n    while i < length(lst)\n        if lst[i] % 2 == 0\n          \
    \  sum += lst[i]\n            lst.pop(i)\n        else\n            i += 1\n \
    \       end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.6>\n\
    @time solution([5,8,7,1]);\n@time solution([3,3,3,3,3]);\n@time solution([30,13,24,321]);\n\
    </cell>\n<text>\n5. Write a recursive function to count the number of positive\
    \ integers less than or equal to k.", "    if sum(lst[1 .. end-1]) %2 != 0\n \
    \       error(\"Not even length vector\")\n    end\n    return sum(lst[1 .. end-1])\
    \ %2 == 1 ? 0 \nend", "    return sum(lst[findall(x->x%2==0, lst)])\nend", " \
    \   return sum(lst[findall(x -> mod(x,2)==1,lst)]) \nend\n</cell>\n<code language=julia-1.5>\n\
    @time solve(vec(1:2000000));\n</cell>\n<text>\nPart 3: Hashmaps\nHashmaps are\
    \ a fast and memory efficient way to store key-value\npairs (think dictionary)\
    \ where the keys are unique.  Unlike a normal array,\nwhere the elements of an\
    \ array are ordered, a hashmap is a hash table.  It\nuses something called a hash\
    \ to generate the indices of the array.  So for\nexample, if we had a vector of\
    \ integers named vec with values ranging from\n1 to 100,000, then accessing vec[200]\
    \ would go through a hash process to\nfind the correct location.  In this way,\
    \ you avoid the cost of indexing into\nan array by its index.  For example, vec[200]\
    \ requires fewer integer\ncomparisons than vec[1], vec[10], vec[100], vec[1000],\
    \ etc.  In addition,\nsince the positions of the elements in the array are known,\
    \ it requires less\nmemory to store the array as well.  In Julia, you can create\
    \ and access hashmaps by\nusing the built-in types in Base that begin with hash.\
    \  For example,\nHash{Int}() creates an empty hashmap.  The following creates\
    \ a hashmap with\n100 buckets.", "    evens, odds = partition(lst)\n    evensum\
    \ = sum(v for v in evens[2:end])\n    oddsum = sum(v for v in odds[2:end])\n \
    \   return (evensum + oddsum) - (evensum + oddsum % 2)\nend\n</cell>\n<code language=julia-1.5>\n\
    @test solution([2, 6, 4, 8, 5]) == 5\n@test solution([2, 9, 4, 5]) == 12\n@test\
    \ solution([5, 8, 7, 1]) == 12\n@test solution([3, 3, 3, 3, 3]) == 9\n@test solution([30,\
    \ 13, 24, 321]) == 0\n</cell>\n<text>\n(2) Part 1", "    if length(lst) == 0 \n\
    \        return 0 \n    \n    # Write code here\n    return length(lst)%2==0 ?\
    \ sum(lst[findall(lst==1 , lst[findall(lst%2==0)]):end-1]):sum(lst[findall(lst==0\
    \ , lst[findall(lst%2==1)]):end-1]) \nend\n</cell>\n<code language=julia-1.0>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart 2\nWrite a function\
    \ called all_different_sum which takes in a vector of integers and returns the\
    \ sum of all integers which are different from all other integers in the vector",
  "    if length(lst) == 1 \n        return lst[1]\n    end\n    vals = lst[1...]\n\
    \    vals = sort(vals)\n    v = vals[end]\n    vals[end:] = vals[end][2:end]\n\
    \    if vals[end] % 2 == 0 \n        vals = vals[vals[end]+1:end]\n    end\n \
    \   return sum(vals[vals[end]+1:end])\nend\n</cell>\n<code language=julia-1.5>",
  "    if length(lst) == 0\n        return 0;\n    end\n    l = lst[1]\n    sum_of_odd_elements_in_first_half\
    \ = sum_of_elements_in_first_half(lst[1:end-1]);\n    odd_elements_in_first_half\
    \ = [i for i in lst if i mod 2 == 1];\n    return sum_of_odd_elements_in_first_half\
    \ + sum(odd_elements_in_first_half);\nend ", "    # Your code here\n    return\
    \ 0\nend ", "    oddsum = 0\n    for i in lst \n        if i%2 != 0 \n       \
    \     oddsum += i\n        end\n    end\n    \n    return oddsum\nend \n</cell>\n\
    <code language=julia-1.6>\n@test solution([5, 8, 7, 1]) == 12\n@test solution([3,\
    \ 3, 3, 3, 3]) == 9\n@test solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\n\
    Question 3\nWrite a Julia function that returns a list containing all of the numbers\
    \ from 0 up to but excluding the number given as a parameter. Do not hard-code\
    \ the number 2 in the function definition.", "    sum = 0\n    for i = 2:length(lst)\n\
    \        if lst[i]%2 != 0 \n            sum += lst[i-1]\n        end\n    end\n\
    \    return sum\nend\n</cell>\n<text>\nExercise 3\nWrite a function named odd_sum\
    \ which takes an array of numbers and returns the sum of all of the odd elements\
    \ that are in even positions.", "  sum = 0\n  for e in lst\n    if e%2 == 1 &&\
    \ (sum + e) > 2\n      sum = sum + e\n    else if e%2 == 0\n      sum = sum -\
    \ e\n    end\n  end\n  return sum\nend", "    total = 0\n    for i in 0:(length(lst)-1)\
    \ \n        if mod(lst[i], 2)==1\n            total += lst[i]\n        end\n \
    \   end\n    return total\nend\n</cell>\n<code language=julia-1.5>\n@code_native\
    \ @which solution([5, 8, 7, 1])\n@code_native @which solution([3, 3, 3, 3, 3])\n\
    @code_native @which solution([30, 13, 24, 321])\n</cell>\n<text>\nSolution 2:\
    \ For Loop\nThe function solution above is clearly not the right way to solve\
    \ this problem.  A for loop is a much more efficient way to solve this problem.\
    \  You will learn more about for loops later in the course, but for now, let us\
    \ first look at the for loop implementation for solving this problem.", "    even\
    \ = findin(lst,evenpos)\n    oddsum = sum(lst[even])\n    return oddsum\nend\n\
    </code>\n<|/ a tags=julia,sum |>\n<| c |>\nYou don't need `sort!` in the first\
    \ place. Just `findin(sort(lst),evenpos)` will do.\n<|/ c |>\n<| c |>\nI was just\
    \ trying to explain in simple words. I understand that it would be nicer to write\
    \ it more concise way. Thanks for comment. Edited answer to include your suggestion.\n\
    <|/ c |>\n<| c |>\nAwesome, thank you! I learned a lot here. I think I see what\
    \ happened now.  I used a vector in the solution. Is there a way to do this with\
    \ a list?\n<|/ c |>\n<| c |>\nSure, no problem. Just convert your list to vector\
    \ by `vec(lst)`. You can then use this solution as `solution(vec(lst))`.\n<|/\
    \ c |>\n<| a dscore=2 tags=julia,sum |>\n<code>", "    if length(lst) == 0 \n\
    \        0\n    elseif length(lst) == 1 \n        lst[1]\n    elseif length(lst)\
    \ == 2 \n        lst[1]+lst[2]\n    elseif length(lst) > 2 \n        return lst[2]+solution(lst[3:end])\n\
    \    else\n        return Int64(0)\n    end\nend\n</code>\n<|/ a tags=recursion,arrays,julia\
    \ |>\n<| a |>\nA short version\n<code>", "    evenpos = filter(x -> x % 2 == 0,\
    \ lst)\n    oddpos = filter(x -> x % 2 == 1, lst)\n    return sum(evenpos)+sum(oddpos)\n\
    end\n</code>\n<|/ a tags=julia,performance |>\n<| c |>\nOh wow, I didn't know\
    \ there was a `filter` function inside `filter`! Thanks for sharing, this will\
    \ be very useful to me.\n<|/ c |>\n<| c |>\nNote that `filter(x -> x % 2 == 0,\
    \ lst)` is equivalent to `filter(x -> x % 2 == 0, lst, init=nothing)` when `lst`\
    \ is an empty vector.\n<|/ c |>\n<| a dscore=2 |>\nThis is one way:\n<code>\n\
    using Statistics", "    \"\"\"Solution goes here\"\"\"\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 tags=function,arrays,functional-programming,julia,syntax |>\n\
    <code>", "    odds = filter(x -> x % 2 == 1, lst)\n    evens = filter(x -> x %\
    \ 2 == 0, lst)\n    sum = 0\n    length(odds) >= length(evens) and return\n  \
    \  for o in odds\n        if evens.contains(o)\n            sum+=o\n        end\n\
    \    end\n    sum\nend\n</cell>\n<text>\nNotice that in the above solution, there\
    \ is no need for the sum variable to be a global variable.  In Julia, a global\
    \ variable is a variable that can exist outside of any function without being\
    \ explicitly passed in.", "    \n    sum = 0\n    for a in lst\n        if iszero(a)\n\
    \            sum+=a\n        elseif a%2==1\n            sum+=a\n        end\n\
    \    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\nProblem\
    \ 8\n============", "    even::Vector{Int64} = Vector{Int64}(length(lst))\n  \
    \  for i in 0:length(lst)-1\n        if lst[i] % 2 != 0\n            even[i] =\
    \ lst[i]\n        end\n    end\n    sum(even[length(even):end])\nend\n</cell>\n\
    <code language=julia-1.6>", "    evenpos = findfirst(iseven)\n    return sum(lst[evenpos-1\
    \ .. evenpos])\nend\n</cell>\n<code language=julia-1.6>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30,\
    \ 13, 24, 321]) == 0\n</cell>\n<text>\nTask 8. Write a function that returns the\
    \ sum of the first n Fibonacci numbers, starting with 1 and 2. All Fibonacci numbers\
    \ are positive and less than or equal to 20. Hint: use the recursive formula for\
    \ calculating a Fibonacci number.", "    for ele in lst \n        if ele % 2 ==\
    \ 0 \n            ele += sum(lst[ele:end])\n        end\n    end\n    return ele\n\
    end\n</code>\n<|/ a tags=arrays,sum,julia |>\n<| c |>\nThis seems like a pretty\
    \ intuitive and efficient way of solving it. Thanks!\n<|/ c |>\n<| c |>\nThis\
    \ does not work. Try `solution([1,3,3,3,3])`, which returns `3` instead of `3`.\n\
    <|/ c |>\n<| a dscore=3 |>\nHere's a short solution using map and filter:\n<code>\n\
    julia> function sum_odd_in_evens(x::Vector{Int})::Int64\n           return reduce(+,filter(i->i%2==1,x))\n\
    \       end\nsum_odd_in_evens (generic function with 1 method)", "    \"\"\"\n\
    \    \n    Parameters\n    ----------\n    lst: Vector{Int64}\n    \n    Returns\n\
    \    -------\n    sum: int64\n    \"\"\"\n    \n    count = 0\n    for i in lst\n\
    \        if i%2 != 0\n            count += 1\n            \n    return count\n\
    end\n</cell>\n<code language=julia-1.1>", "    odd=0\n    for el in lst\n    \
    \    if el%2==0\n            odd+=el\n        end\n    end\n    return odd\nend\n\
    </cell>\n<text>\nExercise 2\nWrite a function that prints the contents of a file\
    \ to the terminal. The filename is given as an argument to the function.", " \
    \   \n    # YOUR CODE HERE\n    # Calculate the sum of the odd elements in the\
    \ list\n    \n    \n    return sum((i%2 != 0) for i in lst)\nend\n</cell>\n<code\
    \ language=julia-1.6>\nsolution(vec(1:20));\n</cell>\n<code language=julia-1.6>\n\
    @assert solution([5, 8, 7, 1]) == 12 \n@assert solution([3, 3, 3, 3, 3]) == 9\
    \ \n@assert solution([30, 13, 24, 321]) == 0 \n@show solution([5, 8, 7, 1, 3])\
    \ == 15\n@show solution([3, 3, 3, 3]) == 9 \n@show solution([30, 13, 24, 321])\
    \ == 0 \n@show solution([5, 8, 7, 1]) == 12 \n</cell>\n<text>\nBonus question\
    \ - Write a function that will calculate the median of a given vector. You should\
    \ use the median of the two middle numbers if there are an odd number of items\
    \ in the vector. Use the median of the two smallest numbers if there are an even\
    \ number of items in the vector.", "    \n    odds = zeros(Int64)\n    for i in\
    \ 0 : 1\n        if lst[i] % 2 != 0\n            odds[] = lst[i]\n        end\n\
    \    end\n    return sum(odds)\nend\n</cell>\n<code language=julia-0.6>\n@time\
    \ solution([1, 2, 3, 4, 5])\n</cell>\n<text>\nSolution 2: For loop with if condition",
  "    return sum([lst[x+3] for x=1:length(lst) if mod(x,2)==1])\nend\n</code>\nAnd\
    \ it turns out this code is pretty fast:\n<code>\njulia> solution([5, 8, 7, 1])\n\
    12", "    \"\"\"\n    Write your solution here.\n    \"\"\"\n    \n    l = length(lst)\n\
    \    # check if vector is empty\n    if l == 0\n        return 0;\n    \n    #\
    \ check if vector is of even length\n    if mod(l) == 0 \n        return sum(lst[2\
    \ .. l - 1]);\n    end", "    evens  = findall(x -> x % 2 == 0, lst)\n    odds\
    \   = findall(x -> x % 2 != 0, lst)\n    \n    return sum(filter(x -> x % 2 !=\
    \ 0, odds)) + sum(filter(x -> x % 2 == 0, evens))", "    \n    sum = 0\n    for\
    \ i in 1:length(lst)\n        if lst[i]%2 == 1 \n            sum += lst[i]\n \
    \       end\n    end\n    return sum\nend", "    even = map(x -> x % 2 == 0, lst)\n\
    \    odd = filter(x -> x % 2 != 0, lst)\n    sum1 = sum(x -> x % 2 == 1, odd)\n\
    \    sum2 = sum(x -> x % 2 != 1, even)\n    \n    return sum1 + sum2\nend\n</code>\n\
    <|/ a tags=julia |>\n<| c |>\nWhat is your reasoning behind this? How is this\
    \ different from [my answer](https://stackoverflow.com/a/62619406/5280396)? Did\
    \ you actually benchmark these two functions to see which is faster?\n<|/ c |>\n\
    <| c |>\nThank you so much for your answer! I actually was looking for the fastest\
    \ one! I tested it against the one I wrote and it was faster, and yeah, your answer\
    \ is faster than mine but still not fast enough.\n<|/ c |>\n<| c |>\nI tested\
    \ it against the one I wrote and it is faster (2x). I was writing a solution without\
    \ benchmark but I missed that you were already benchmarking it!\n<|/ c |>\n<|\
    \ c |>\nThat's fine. I'll still upvote your answer even though it looks like you\
    \ were already benchmarking it. I was just curious if there was some unnecessary\
    \ \"inlining\" going on in the other answer. Seems like there isn't.\n<|/ c |>\n\
    <| c |>\nI added benchmark results (1x), and I think my solution is 3x faster\
    \ than yours. Also I like your solution because it uses only one loop and I like\
    \ the way it is being done to my taste.\n<|/ c |>\n<| a dscore=1 |>\nYou can use\
    \ the function sum to sum a vector, like this:\n<code>", "    # Write your code\
    \ in Python 3.6\n    if lst.length==0\n        return 0\n    return sum(lst[1\
    \ .. end-1].map(&:odd==true) |> sum)\nend\n</cell>\n<code language=julia-1.5>",
  "    evens = lst[even.(lst)]\n    evensum = sum(evens)\n    if evensum == 0 \n \
    \       return 0 \n    else\n        return evensum\n    end\nend", "    if length(lst)\
    \ == 0 \n        0\n    else \n        sum(lst[2:end]).*(lst[1] % 2 == 0).*(lst[2]\
    \ % 2 == 0)\n    end\nend\n</code>\n<|/ a tags=sum,algorithm,big-o,sum-of-digits,time-complexity\
    \ |>\n<| c |>\nIt might seem inelegant but I think this solution can easily be\
    \ proven to be correct.\n<|/ c |>\n<| c |>\nYes. But it depends on the specific\
    \ definition of the problem. For example, if the problem statement states that\
    \ you only want to count the digits, then a more efficient solution would be to\
    \ not calculate the sum of the digits, but simply count them. Also, if there are\
    \ other characteristics of the input (for example, the number of digits in a number),\
    \ then a more efficient solution would depend on those characteristics.\n<|/ c\
    \ |>\n<| a |>\nHere is my O(n log n) solution:\n<code>\ndef sum_of_digits(number):\n\
    \    digits = str(number)\n    odddigits = [i for i, x in enumerate(digits) if\
    \ x % 2 == 1]\n    return sum([int(digit) for digit in digits]) - sum(odddigits)\n\
    </code>\nThe idea is to build a list of odd digits, then compute the sum of the\
    \ digits, and then subtract the sum of odd digits from the sum of the digits.\n\
    <|/ a dscore=2 tags=sum,algorithm,big-o,sum-of-digits,time-complexity |>\n<| c\
    \ |>\nCould you please explain how it works?\n<|/ c |>\n<| c |>\nThis approach\
    \ uses only O(n) space, while all the other solutions use O(n) space.\n<|/ c |>\n\
    <| c |>\nIt uses O(n) space, because it doesn't compute `digits`, and so it uses\
    \ only O(1) space.\n<|/ c |>\n<| c |>\nThanks for the explanation. I've edited\
    \ my answer to include a more pythonic solution.\n<|/ c |>\n<| a dscore=2 |>\n\
    My solution is very similar to the one posted earlier but it can handle any number\
    \ without converting it to a string. \n<code>\ndef sum_of_digits(number)\n   \
    \ factors = Float.(digits(number))\n    odd_nums = factors % 2 != 0\n    sum =\
    \ 0\n    current = number\n    while (current > 0)\n        sum = sum + mod(current,10)\n\
    \        current = current / 10\n    end\n    return sum + sum(odd_nums.*factors[odd_nums])\n\
    end\n</code>\n<|/ a tags=sum,algorithm,big-o,sum-of-digits,time-complex", "  \
    \  even = lst[(1::2)]\n    odd = lst[(2::2)]\n    even.+ sum(odd)\nend", "   \
    \ n = length(lst)\n    odd_sum = 0\n    for x in lst\n        if x % 2 == 1\n\
    \            odd_sum += x\n        end\n    end\n    return odd_sum\nend\n</cell>\n\
    <code language=julia-1.5>\n# run this cell for testing\n@testset \"Test odd numbers\
    \ sum\" begin\n    @test solution([5, 8, 7, 1]) == 12\n    @test solution([3,\
    \ 3, 3, 3, 3]) == 9\n    @test solution([30, 13, 24, 321]) == 0\nend\n</cell>\n\
    <text>\nWrite a function that returns the number of odd integers in a given vector\
    \ that are not in the range of 0 to 100.", "  if length(lst) == 0\n    return\
    \ 0\n  elseif length(lst) == 1\n    return lst[1]\n  elseif length(lst) == length(lst[1..-1])\n\
    \    if mod(lst[1], 2) == 0\n      return lst[1-1] + lst[end]\n    else\n    \
    \  return lst[1-1] + lst[1..-1][2]\n    end\n  else\n    if mod(lst[1], 2) ==\
    \ 0\n      return lst[1..-1][1] + solution(lst[1..-1][2:end])\n    else\n    \
    \  return lst[1..-1][1] + solution(lst[1..-1][2:end])\n    end\n  end\nend\n</code>\n\
    <|/ a dscore=0 tags=algorithm,dynamic-programming |>\n<| c |>\nthanks for your\
    \ reply, this solution is definitely not very elegant nor efficient. Your code\
    \ seems way too complicated for my taste.\n<|/ c |>\n<| c |>\nWell I appreciate\
    \ your concern but i don't think it's that complicated. Especially when you get\
    \ to more complicated solutions. I guess it might not be very efficient in terms\
    \ of complexity, but it's still quite easy to understand. And your solution would\
    \ not work given this case: solution([10,2,1,3,4])\n<|/ c |>\n<| c |>\nI just\
    \ tested this on [10,2,1,3,4] and got the correct result : 7\n<|/ c |>\n<| c |>\n\
    sorry my bad. Your code works perfectly well and I am not complaining about the\
    \ complexity. I was more concerned about the efficiency of your solution.\n<|/\
    \ c |>\n<| a dscore=0 |>\nHere is a solution using a slightly different approach.\n\
    The idea is to build a tree whose root node is your input vector.  The leftmost\
    \ node has 2 children and a sum of its two children.  You can repeat this for\
    \ the next level until the vector is length 1.  Then you can just take the root's\
    \ two children.\nHere is my Python code:\n<code>\ndef solution(L):\n    if not\
    \ L:\n        return 0\n    T = L[0]\n    if L[-1] & 1:\n        T.rightSum =\
    \ L[1] + solution(L[2:end])\n    else:\n        T.rightSum = L[1] - solution(L[2:end])\n\
    \    return T.rightSum", "    \n    return sum(lst[2:end]-lst[1:end-1]) % 2 ==\
    \ 0 ? sum(lst[2:end]-lst[1:end-1]) : 0\nend \n</cell>\n<text>\n15. Write a Python\
    \ program to check whether a given number is palindrome or not. (Python3 Solution)\n\
    Input:\n10010", "    return sum([x for i=1:length(lst)-1 if x%2==0 && lst[i]!=lst[i+1]])\n\
    end \n</cell>\n<cell>\n# export\n@testset \"solving homework exercises\" begin\n\
    \    \n    solution([5, 8, 7, 1])\n    solution([3, 3, 3, 3, 3])\n    solution([30,\
    \ 13, 24, 321])\nend \n</cell>\n<text>\nExercise 2\nThe following is the code\
    \ for the \"solving homework exercises\" notebook.", "    evens = findall((x ->\
    \ x % 2 == 0, lst), lst)\n    if length(evens)==0\n        return 0\n    else\
    \ \n        return sum(lst[i] for i in evens)\n    end\nend\n</code>\n<|/ a tags=julia\
    \ dscore=1 |>\n<| a tags=julia dscore=1 |>\nHere's another one:\n<code>", " \n\
    end", "    if length(lst) == 0 \n        return 0 \n    \n    for i in 2:length(lst)\
    \ \n        if lst[i]%2 != 0 \n            return 0 \n    \n    return lst[1]\
    \ + lst[2] + lst[3] + (2*lst[2])\nend \n</cell>\n<text>\nVectorize an inner loop",
  "    if length(lst)==0\n        return 0\n    \n    sum=0\n    odd_idx=findall(lst!=0)\
    \ # find all odd positions of the given list\n    even_idx=findall(lst==0)  #\
    \ find all even positions of the given list\n    for idx in odd_idx \n       \
    \ if lst[idx]==0 && length(odd_idx)>1\n            sum+=lst[even_idx[idx - 1]]\n\
    \        end\n    end\n    return sum\nend", "    n = length(lst)\n    sum = 0\n\
    \    for idx in indices(lst)\n        if idx % 2 == 1\n            sum = sum +\
    \ lst[idx]\n        end\n    end\n    return sum\nend\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function called sumOfOdds that sums the odd numbers within a vector.",
  "    if length(lst) == 0 \n        throw(ArgumentError(\"List is empty\"))\n   \
    \ end", "    evens = Vector{Int64}[]\n    odds = Vector{Int64}[]\n    for i in\
    \ lst\n        if i%2==0\n            push!(evens, i)\n        else\n        \
    \    push!(odds, i)\n        end\n    end\n    \n    return sum(filter(x -> x%2!=0,\
    \ odds)) + sum(filter(x -> x%2==0, evens))\nend\n</cell>\n<code language=julia-1.1>",
  "  even = lst[! (lst .== 0)]\n  if length(even) ==  0\n    throw(ArgumentError(\"\
    Invalid input\"))\n  end\n  return sum(even) \nend\n</cell>\n<text>\n3. Odd elements\
    \ II\nWrite a function that sums the odd elements in an vector", "    even = lst[2::2]\n\
    \    odd = lst[1:2:end]\n    return sum(x -> isodd(x) ? x + 1 : x, even) + sum(x\
    \ -> isodd(x) ? x : x - 1, odd)\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\n\
    This is really nice, and I think I'm going to give it a try. I can see how this\
    \ could be generalized to include all elements of an array, but this doesn't allow\
    \ for vectorization. I'm going to play around with this in the coming days to\
    \ see if I can get it to work with an array.\n<|/ c |>\n<| c |>\nI just realized\
    \ that my code isn't vectorized, as I realized that I had neglected the fact that\
    \ you only need to count up from 1 to the number of elements in the array. I've\
    \ fixed it up so that it works with an array, but I'm not sure how it will scale\
    \ for arrays with more than a million elements. I'm not sure if that's going to\
    \ be a problem, though.\n<|/ c |>\n<| c |>\nI have a new version of my solution\
    \ I tested with over 1 million elements and it works pretty fast. I'll write it\
    \ up and post it here, and I'll post a link to it on a blog somewhere that has\
    \ a lot of other stuff to say about Julia. I'll post a link to it here as well,\
    \ if you'd like to check it out. Thanks again!\n<|/ c |>\n<| a tags=julia |>\n\
    Okay, so I actually tried doing this with multiple arrays, and it's actually quite\
    \ a bit faster. I did this on arrays consisting of a million elements and a million\
    \ elements, and it took about 4 seconds. The time it took to run the first time\
    \ was about 4.2 seconds, and it took about 4.1 seconds to run the second time.\
    \ \nHere's the code I ended up with. I first made the arrays I needed:\n<code>\n\
    using LinearAlgebra, BenchmarkTools"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
