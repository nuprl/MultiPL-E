name: HumanEval_117_select_words
language: jl
prompt: "\"\"\"Given a string s and a natural number n, you have been tasked to implement\
  \ \n    a function that returns a vector of all words from string s that contain\
  \ exactly \n    n consonants, in order these words appear in the string s.\n   \
  \ If the string s is empty then the function should return an empty vector.\n  \
  \  Note: you may assume the input string contains only letters and spaces.\n   \
  \ Examples:\n    >>> select_words(\"Mary had a little lamb\", 4)\n    [\"little\"\
  ]\n    >>> select_words(\"Mary had a little lamb\", 3)\n    [\"Mary\", \"lamb\"\
  ]\n    >>> select_words(\"simple white space\", 2)\n    []\n    >>> select_words(\"\
  Hello world\", 4)\n    [\"world\"]\n    >>> select_words(\"Uncle sam\", 3)\n   \
  \ [\"Uncle\"]\n    \"\"\"\nfunction select_words(s::String, n::Int64)::Vector{String}\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = select_words;\n\t@test(candidate(\"\
  Mary had a little lamb\", 4) == [\"little\"])\n\t@test(candidate(\"Mary had a little\
  \ lamb\", 3) == [\"Mary\", \"lamb\"])\n\t@test(candidate(\"simple white space\"\
  , 2) == Vector{String}([]))\n\t@test(candidate(\"Hello world\", 4) == [\"world\"\
  ])\n\t@test(candidate(\"Uncle sam\", 3) == [\"Uncle\"])\n\t@test(candidate(\"\"\
  , 4) == Vector{String}([]))\n\t@test(candidate(\"a b c d e f\", 1) == [\"b\", \"\
  c\", \"d\", \"f\"])\nend\n"
completions: ["    \n    # Your code goes here\n    \n    return []\n    \nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"\nGiven a list of words, return a list of the\
    \ words that are common to all \nthe given words. Words that don't appear in all\
    \ the words should be ignored.\nThe order of words in common should reflect the\
    \ order of the given words.\nThe string in each element should only be a character\
    \ or a space.\n\"\"\"", "    if s == \"\"\n    return []\n    words = split(s,\
    \ \" \")\n    words = [word for word in words if count_consonants(word) == n]\n\
    \    return words\nend\n</cell>\n<code language=julia-1.2>\n\"\"\"\n    select_words_in_file(fn::String,\
    \ m::Int64)::Vector{String}\n    Given a file fn and a natural number m, you have\
    \ been tasked to implement a \n    function that returns a vector of all words\
    \ from file fn that contain exactly \n    m consonants, in order these words appear\
    \ in the file fn.\n    If the file fn is empty then the function should return\
    \ an empty vector.\n    Note: you may assume the file contains only letters and\
    \ spaces.\n    Examples:\n    >>> select_words_in_file(\"Mary had a little lamb\"\
    , 4)\n    [\"little\"]\n    >>> select_words_in_file(\"Mary had a little lamb\"\
    , 3)\n    [\"Mary\", \"lamb\"]\n    >>> select_words_in_file(\"simple white space\"\
    , 2)\n    []\n    >>> select_words_in_file(\"Hello world\", 4)\n    [\"world\"\
    ]\n    >>> select_words_in_file(\"Uncle sam\", 3)\n    [\"Uncle\"]\n    \"\"\"",
  "    # write your code here\n    return Vector{String}()\nend\n</code>\n<|/ q tags=julia,string\
    \ |>\n<| a |>\nThe most obvious thing to do would be to iterate over all possible\
    \ combinations and count the number of matches. If you know that you have at most\
    \ 4 matches per string, you only need 4 nested loops over all possible combinations,\
    \ each one running over the possible lengths of your string and your target word.\n\
    Here's a possible implementation:\n<code>", "    \nend\n</code>\nSolution: \n\
    <code>\n# function select_words(s, n)\nselect_words(s, n) =  \n    s = re.sub('[^a-zA-Z\
    \ ]','',s)\n    select( x -> x in s, split(s) )\nend", "    if length(s) < 0 \n\
    \        empty_vector \n    else \n        words = split(s)\n        select_words_recursive(words,\
    \ n)\n    end\nend", "    \n    let w = vec()\n    for i in eachindex(s) do\n\
    \        if length(findall(isspace(s[i]), s)) == n && isalpha(s[i]) == false &&\
    \ isascii(s[i]) == false && s[i] == ' '\n            push!(w, s[i])\n        end\n\
    \    end\n    \n    return w\nend\n</cell>\n<code language=julia-1.5>\nselect_words(\"\
    Mary had a little lamb\", 4)\n</cell>\n<code language=julia-1.5>\nselect_words(\"\
    Hello world\", 4)\n</cell>\n<code language=julia-1.5>\nselect_words(\"Uncle sam\"\
    , 3)\n</cell>\n<code language=julia-1.5>\nselect_words(\"Uncle sam\", 4)\n</cell>\n\
    <code language=julia-1.5>", "    \n    v = Vector{String}()\n    if s == \"\"\
    \ \n        push!(v, \"empty string\")\n    else \n        for w in words\n  \
    \          if sum(isalpha(word)) >= n\n                push!(v, w)\n         \
    \   end\n        end\n    end\n    return v\nend\n</cell>\n<code language=julia-0.3>\n\
    select_words(\"Mary had a little lamb\", 4)\n</cell>\n<text>\nExercise: How many\
    \ words are there that contain at least 2 consonants?", "    if s.length == 0\n\
    \        return Vector{}\n    word = s[1..-1]\n    word_list = split(\" \", word)\n\
    \    word_list = filter(s => length(s) <= n, word_list)\n    word_list = sort(word_list)\n\
    \    word_list = unique(word_list)\n    return word_list\nend", "    #function\
    \ selects all words from string s that contains n consonants\n    \n    #your\
    \ code here\n    \nend\n</code>\n<|/ a dscore=3 tags=string,julia,arrays,vector\
    \ |>\n<| c |>\nA small comment: if you are not using the `matchall` function as\
    \ I suggested, you can just replace the line `m = matchall(s, \"[bcdfghjklmnpqrstvwxyz]\"\
    )` with `m = Array{Any}(size(s))`\n<|/ c |>\n<| c |>\nThis answer is incorrect\
    \ because it does not consider case (that is, `a` but `A`). Also, if you use the\
    \ same string `s` twice (in the loop), you end up with double counting. This could\
    \ be fixed by wrapping the call to `findall` into an `if`-statement. Also, your\
    \ answer does not use the built-in `Vector` but rather `Array{String, 1}`. I edited\
    \ your answer to fix these issues. You can see the revisions [here](http://stackoverflow.com/posts/30951065/revisions)\n\
    <|/ c |>\n<| c |>\nThanks! I just want to add that `matchall` does not work with\
    \ regexes and in general is not a good idea to use it in production. Since we\
    \ are dealing with strings, there is an alternative - `findfirst`.\n<|/ c |>\n\
    <| c |>\nthank you for the corrections. I am also new with Julia, I find it very\
    \ intuitive and fast to write these kind of code. So thank you for the edits.\n\
    <|/ c |>\n<| a dscore=3 |>\nSince I feel like I'm getting a lot of people saying\
    \ \"why are you using Vector, when you can use an array?\" let me give you some\
    \ more insight on how to use arrays instead of Vectors.\nFirst, if you haven't\
    \ read this already, you should read Julia by Example. This book goes through\
    \ every major component in Julia, from basic syntax and semantics, to all the\
    \ tools and packages.\nSecond, let me point out that there is an important distinction\
    \ between the type of a variable and the type of an object in Julia. For example,\
    \ in Julia, x is an object. x is of type Int64. x is also called a scalar; x is\
    \ of type Vector{Int}. x is of type Array{Int64,1}. x is of type Array{Int64,2}.\
    \ x is of type Array{Int64,3}. x is of type Array{Int64,4}. x is of type Array{Int64,5}.\
    \ x is of type Array{Int64,6}. x is of type Array{Int64,7}. x is of type ", " \
    \   if s.length == 0\n        return Vector{String}()\n    \n    counts = count_consonants(s)\n\
    \    res = []\n    for w in all_words(s)\n        if counts[w] == n\n        \
    \    res.push(w)\n        end\n    end\n    return res\nend\n    \nend\n</cell>\n\
    <code language=julia-1.5>\n@test select_words(\"\", 0)==[]\n@test select_words(\"\
    \ \", 1)==[]\n@test select_words(\"Hello\", 1)==[\"Hello\"]\n@test select_words(\"\
    Hello world\", 1)==[]\n@test select_words(\"Hello world\", 1)==[\"world\"]\n@test\
    \ select_words(\"Hello world\", 1)==[\"Hello world\"]\n@test select_words(\"Hello\
    \ world\", 2)==[]\n@test select_words(\"Hello world\", 2)==[\"Hello world\"]\n\
    @test select_words(\"Hello world\", 3)==[]\n@test select_words(\"Hello world\"\
    , 3)==[\"Hello world\"]\n@test select_words(\"Hello world\", 3)==[\"Hello\", \"\
    world\"]\n@test select_words(\"Hello world\", 3)==[\"Hello\"]\n@test select_words(\"\
    Hello world\", 4)==[]\n@test select_words(\"Hello world\", 4)==[\"Hello\", \"\
    world\"]\n@test select_words(\"Hello world\", 4)==[\"Hello\"]\n@test select_words(\"\
    Hello world\", 5)==[]\n@test select_words(\"Hello world\", 5)==[\"Hello\", \"\
    world\"]\n@test select_words(\"Hello world\", 5)==[\"Hello\"]\n@test select_words(\"\
    Hello world\", 6)==[]\n@test select_words(\"Hello world\", 6)==[\"Hello\", \"\
    world\"]\n@test select_words(\"Hello world\", 6)==[\"Hello\"]\n@test select_words(\"\
    Hello world\", 7)==[]\n@test select_words(\"Hello world\", 7)==[\"Hello\", \"\
    world\"]\n@test select_words(\"Hello world\", 7)==[\"Hello\"]\n@test select_words(\"\
    Hello world\", 8)==[]\n@test select_words(\"Hello world\", 8)==[\"Hello\", \"\
    world\"]\n@test select_words(\"Hello world\", 8)==[\"Hello\"]\n@test select_words(\"\
    Hello world\", 9)==[]\n@test select_words(\"Hello world\", 9)==[\"Hello\", \"\
    world\"]\n@test select_words(\"Hello world\", 9)==[\"Hello\"]\n@test select_words(\"\
    Hello world\", 10)==[]\n@test select_words(\"Hello world\", 10)==[\"Hello\", \"\
    world\"]\n@test select_words(\"Hello world\", 10)==[\"Hello\"]\n", "    \n   \
    \ vec = Vector{String}(undef, 0)\n    if !isempty(s) && n > 0 && n > length(s)\
    \ \n        return vec\n    \n    for c in s\n        if c == \" \" || c == \"\
    \\n\" || c == \"\\t\"\n            continue\n        end\n        \n        if\
    \ c != \"a\"..\"z\"\n            if c == \"A\" || c == \"E\" || c == \"I\" ||\
    \ c == \"O\" || c == \"U\" || c == \"Y\"\n                continue\n         \
    \   end\n        end\n        \n        for w in get_valid_words(c)\n        \
    \    if length(w) == n\n                push!(vec, w)\n            end\n     \
    \   end\n    end\n    vec\nend", "</code>\n<code>\n## A better solution to this\
    \ problem", "    # Write your function here\n    return []\nend", "    return\
    \ Vector{String}()\n</code>\nThis is probably the best solution so far. I haven't\
    \ tested it yet, but I believe it works correctly. If anyone can figure out what\
    \ I've done wrong with this algorithm, I would greatly appreciate it. Thanks!\n\
    <|/ q dscore=0 |>\n<| c |>\nYou should tag this with the language you're using,\
    \ which is probably not Javascript (looks like OCaml).\n<|/ c |>\n<| a |>\nThe\
    \ problem here is that you are using recursion to solve this problem, but what\
    \ you need to do here is just use a for loop.\n<code>", "    if s.length == 0\n\
    \        return Vector{String}()\n    \n    candidates = select_words_internal(s,\
    \ n)\n    \n    return filter( (x) -> x.contains(n), candidates)\nend\n</cell>\n\
    <text>\nProblem 7\nWrite a function that returns the product of any two given\
    \ numbers, including zero. You may assume that the given numbers are non-negative\
    \ and will contain no leading zero. For example: product(3,2) returns 6.", " \
    \   s = lower(s)\n    if s == \"\" \n        return Vector{String}()\n    v =\
    \ Array{String, 1}(lowercase(s))\n    ans = Vector{String}()\n    for i in 1:length(v)\n\
    \        if v[i] == n-1\n            push!(ans, lowercase(v[i]))\n        end\n\
    \    end\n    return ans\nend", "    \n\"\"\"\n    \n    Given a string s and\
    \ a natural number n, you have been tasked to implement \n    a function that\
    \ returns a vector of all words from string s that contain exactly \n    n vowels,\
    \ in order these words appear in the string s.\n    If the string s is empty then\
    \ the function should return an empty vector.\n    Note: you may assume the input\
    \ string contains only letters and spaces.\n    Examples:\n    >>> select_words(\"\
    Mary had a little lamb\", 4)\n    [\"little\"]\n    >>> select_words(\"Mary had\
    \ a little lamb\", 3)\n    [\"Mary\", \"lamb\"]\n    >>> select_words(\"simple\
    \ white space\", 2)\n    []\n    >>> select_words(\"Hello world\", 4)\n    [\"\
    world\"]\n    >>> select_words(\"Uncle sam\", 3)\n    [\"Uncle\"]\n\"\"\"", " \
    \ \n    if s == \"\"\n    return []\n    else \n        result = []\n        for\
    \ w in words\n            if length(w)==n && all(consonant_count(w) == n)\n  \
    \              push!(result, w)\n        end\n        return result\nend", " \
    \   if length(s) == 0\n        return Vector{}\n    \n    \n    counts::Vector{Int64}\
    \ = count_chars(s)\n    \n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n",
  "    if s == \"\"\n        Vector{String}\n    else\n        result = []\n     \
    \   for w in words\n            if length(w)==n && w[n-1] in \"aeiouAEIOU\"\n\
    \                push!(result, w)\n            end\n        end\n        return\
    \ result\n    end\nend\n</cell>\n<text>\n3.6.4 Modifying select_words()\nNow modify\
    \ select_words() to return a vector of words, ordered by the number of vowels\
    \ in each word. \nThe new function should take one argument, the number of vowels\
    \ used to order the words. \nYou will call your function from previous exercise\
    \ with\nselect_words(4, vowel_counts)\nand the parameter vowel_counts is a dictionary\
    \ where each key is a word \n(e.g. \"white\") and the value is the number of vowels\
    \ in the word (e.g. 3)\nThe function should return a vector of words ordered by\
    \ the number of vowels in each word. \nFor example, the following two statements\
    \ should produce the same result:", "    if length(s) < n return []\n    \n  \
    \  word_vec = []\n    word_vec = word_vec + select_words(s[2:end-1], n)\n    word_vec\
    \ = word_vec + select_words(s[end-2:end], n)\n    word_vec = word_vec + select_words(s[end-3:end],\
    \ n)\n    word_vec = word_vec + select_words(s[end-1:end], n)\n    \n    \n  \
    \  for word in word_vec\n    \n        if word == s[end]\n            break\n\
    \        end\n    end\n    \n    return word_vec\nend\n</cell>\n<text>\nLet's\
    \ verify that our function works as expected:", "    # Your code goes here\n \
    \   return []\nend\n</cell>\n<text>\nPart II: Map-reduce exercise", "    #import\
    \ Base.show\n    #show(s,n)\n    #print(\"----------------\")\n    words=[]\n\
    \    if s.length>0\n        if n==\"word\"\n            words=select_words_word(s,n)\n\
    \        else if n==\"letter\"\n            words=select_words_letter(s,n)\n \
    \       else if n==\"letters\"\n            words=select_words_letters(s,n)\n\
    \        else if n==\"letters_number\"\n            words=select_words_letters_number(s,n)\n\
    \        else if n==\"words\"\n            words=select_words_words(s,n)\n   \
    \     else if n==\"words_num\"\n            words=select_words_words_number(s,n)\n\
    \        else if n==\"words_num\"\n            words=select_words_words_number(s,n)\n\
    \        end\n    end\n    return words\nend", "    if s == \"\"\n        return\
    \ vec[]\n    \n    words = split(s)\n    \n    for word in words\n        \n \
    \       \n    end\nend", "    if length(s)==0\n        return Vector{}\n    else\
    \ if n==1\n        return [] \n    end\n    stack = [] \n    for ele in split(s)\n\
    \        if length(ele)>=n\n            if ele in stack\n                remove!(stack,ele)\n\
    \            else\n                push!(stack, ele)\n            end\n      \
    \  end\n    end\n    stack\nend\n</cell>\n<text>\nExercise 4\nWrite a function\
    \ called count_substrings that takes in an n-element vector of strings and returns\
    \ a vector of the number of times that each substring appears. \nFor example if\
    \ the input vector contains [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"] then\
    \ the output should be [1, 0, 1, 0, 1]", "    vectors = Vector{String}()\n   \
    \ if n == 0\n        vectors\n    else\n        for word in split(s, \" \")\n\
    \            if length(w) == n\n                if count_cons(w) == n\n      \
    \              push!(vectors, word)\n                end\n            end\n  \
    \      end\n    end\nend\n</cell>\n<text>\nWrite a function count_vowels(s, v)\
    \ that takes a string s and returns a vector of all words in that string that\
    \ contain exactly one vowel in any order. Test your function using the following:",
  "    if s == \"\"\n        return Vector{String}()\n    else\n        count_consonants\
    \ = count(s, String)\n        select_words_helper(s, n, count_consonants)\n  \
    \  end\nend", "    if length(s)==0 return []\n    let str::String = split(s,\"\
    \ \")\n    let count::Int64 = Int64(length(s))\n    let n::Int64 = convert(n,Int64)\n\
    \    let vec::Vector{String} = [\"\"]\n    for i in 1:count\n        if n==0 ||\
    \ (str[i]==' ' && n==1) || (n>1 && str[i-1]==' ' && n<length(str))\n         \
    \   push!(vec,str[i])\n            n = n-1\n        else\n            push!(vec,\"\
    \")\n        end\n    end\n    vec\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\n<code>\n# select a word in a string", "    if n < 1\n        return Vector{}\n\
    \    if n==1\n        return [[s]]\n    \n    consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    \n    vowels = \"aeiou\"\n    \n    word = s[:n-1]\n    \n    left = []\n    middle\
    \ = []\n    right = []\n    \n    for i in consonants\n        if word[i] in vowels\n\
    \            left.append(word)\n        else if word[i-1:i] in vowels\n      \
    \      middle.append(word)\n        else if word[i+1:i+2] in vowels\n        \
    \    right.append(word)\n        else\n            pass\n    end\n    \n    return\
    \ left+middle+right\nend", "    s = replace(s)\n    \n    if n == 1\n        return\
    \ split(s)\n    else\n        return filter(x -> count(x, n) == n, s)\n    end\n\
    end", "    # Your code here\nend\n</cell>\n<text>\nExercise 9\nWrite a function\
    \ that checks if a string is a palindrome.", "    \n    arr = new Array{String}(n)\n\
    \    \n    for i in 1:n\n        \n        if isalpha(s)\n            \n     \
    \       for j in 1:length(s) \n            \n                if contains(s, cchar(j))\n\
    \                    \n                    if length(intersect(split(s), split(cchar(j))))==1\n\
    \                        arr[i] = intersect(split(s), split(cchar(j)))\n     \
    \               else\n                        arr[i] = \"not found\"\n       \
    \             end\n                    \n                    \n              \
    \      s = substring(s, end-1)\n                else\n                    \n \
    \                   s = substring(s, j+1)\n                end\n             \
    \   \n            end\n        end\n        \n    end\n    return arr\nend\n</cell>\n\
    <code language=julia-1.4>\nselect_words(\"Hello world\", 4)\n</cell>\n<text>\n\
    Task 5. Implement a function that removes all the vowels (consonants) from a given\
    \ string.\nExamples:\n    >>> remove_vowels(\"Hello World\") \n    \"ello orld\"\
    \n    >>> remove_vowels(\"Hello World\") \n    \"Hello World\"\n    >>> remove_vowels(\"\
    \") \n    \"\"\n\"\"\"", "    if s == \"\"\n        return Vector{String}()\n\
    \    \n    vowels = \"AEIOU\"\n    \n    word = select_word(vowels, n)\n    \n\
    \    word = select_word(word, n - 1)\n    \n    word = word[0..n]\n    \n    return\
    \ word\n    \n    \n    ", "    \n    return [] \nend\n</cell>\n<text>\nThe function\
    \ select_words should return the vector of words from input string s that contains\
    \ exactly n consonants in order these words appear in the string s. If the string\
    \ s is empty then the function should return an empty vector.", "    \n    \n\
    \    #Your code goes here\n    \nend\n</cell>\n<text>\nSolution\nClick below for\
    \ a solution.", "    if s == \"\"\n        Vector{String}()\n    else\n      \
    \  find_words = filter(x -> x ==n || x == \"\", find_consonants(s))\n        select_words(s,\
    \ find_words)\nend", "    return []\nend\n</code>\n<|/ q dscore=1 |>\n<| c |>\n\
    What is the question here?\n<|/ c |>\n<| c |>\nthe code is not working, I cant\
    \ figure out why it doesnt work\n<|/ c |>\n<| c |>\nYou might want to check out\
    \ Julia documentation for [string operations](https://docs.julialang.org/en/v1/base/strings/#Base.substring).\n\
    <|/ c |>\n<| c |>\nDoes this answer your question? [Finding all occurrences of\
    \ an element in a string in Julia](https://stackoverflow.com/questions/42527440/finding-all-occurrences-of-an-element-in-a-string-in-julia)\n\
    <|/ c |>\n<| a tags=string,julia,recursion |>\nOne way to do this is to count\
    \ the occurrences of each letter of the alphabet. Given a string s and a positive\
    \ integer n you are allowed to add n consonants. Then, for each letter of the\
    \ alphabet, count how many times it appears in your string. If it appears n times,\
    \ we add that letter to your output vector, otherwise we don't.\nOne way to do\
    \ this is to first find the number of occurrences of each letter, then filter\
    \ them out based on that:\n<code>", "    \n    \n    v = Vector{String}()\n  \
    \  if n == 0\n        return v\n    \n    for i in split(s)\n        \n      \
    \  if find(i) == n-1\n            push!(v,i)\n        end\n    end\n    v\nend\n\
    </cell>\n<text>\nFor your final program, please submit the code as a notebook,\
    \ with your name on the top, as well as a description of your assignment.  Feel\
    \ free to use the web submission feature of Kaggle to help you do this, but please\
    \ remember that Kaggle does not accept submissions of raw solutions to homework.\
    \  Learning how to write functions is an integral part of learning Julia.", " \
    \   \n    \n    return [] \nend", "    \n\"\"\"\nGiven a vector V of strings and\
    \ a natural number n, you have been tasked \nto implement a function that returns\
    \ a vector of all words from V that \ncontain exactly n vowels, in order these\
    \ words appear in the vector V.\nIf the vector V is empty then the function should\
    \ return an empty vector.\nNote 2: You may assume the input vector V contains\
    \ only strings and \n    contain only letters and spaces.\n    Examples:\n   \
    \ >>> vowel_words(\"Mary had a little lamb\", 4)\n    [\"little\"]\n    >>> vowel_words(\"\
    Mary had a little lamb\", 3)\n    [\"lamb\"]\n    >>> vowel_words(\"simple white\
    \ space\", 2)\n    []\n    >>> vowel_words(\"Hello world\", 4)\n    [\"world\"\
    ]\n    >>> vowel_words(\"Uncle sam\", 3)\n    [\"sam\"]\n\"\"\"", "    if n ==\
    \ 0\n        return empty\n    \n    substrings = partition(s,c)\n    \n    filtered_substrings\
    \ = filter( \n        (substring) => length(substring) == n,\n        substrings\n\
    \    )\n    \n    \n    return filtered_substrings\nend\n    \n</cell>\n<code\
    \ language=julia-1.5>\nselect_words(\"Mary had a little lamb\", 4)\n</cell>\n\
    <text>\nExercise: Write a function that returns a vector of all words from string\
    \ s that contain exactly n vowels, in order these words appear in the string s.\n\
    If the string s is empty then the function should return an empty vector.\nNotes:\n\
    You can assume that a string contains only letters and spaces.\nYou may assume\
    \ that the number of vowels in the alphabet is 5.\nYou may assume that n and s\
    \ are integers.\nExamples:\nselect_words(\"Mary had a little lamb\", 4) should\
    \ return [\"lamb\", \"little\"]\nselect_words(\"Mary had a little lamb\", 3) should\
    \ return [\"Mary\", \"lamb\"]\nselect_words(\"simple white space\", 2) should\
    \ return []\nselect_words(\"Hello world\", 4) should return [\"world\"]\nselect_words(\"\
    Uncle sam\", 3) should return [\"Uncle\"]", "    return vec()\n</code>\n<|/ q\
    \ tags=julia,string |>\n<| c |>\nCan you clarify what you mean by \"in order these\
    \ words appear in the string s\"? Is it only letters that you want to match, or\
    \ does it also include digits, punctuation, or other non-letters?\n<|/ c |>\n\
    <| c |>\nHe wants to match any words that contain a certain amount of letters.\
    \ In other words, he wants to count the letters that are consecutive. The word\
    \ \"Mary\" would be counted as if it contained only 3 letters since \"M\" matches\
    \ \"Mary\".\n<|/ c |>\n<| a |>\nHere is a function that will do it:\n<code>",
  "    \n    if n == 0\n        return []\n    \n    l = filter(x -> isconsonant(x),\
    \ s)\n    if l == []\n        return []\n    \n    l = sort(l)\n    if l == []\n\
    \        return []\n    \n    l = l[length(l) - n : length(l)]\n    l = filter(x\
    \ -> x != \" \", l)\n    l = sort(l)\n    \n    return l\n    \nend\n</cell>\n\
    <code language=julia-0.6>\nselect_words(\"Mary had a little lamb\", 4)\n</cell>\n\
    <code language=julia-0.6>\nselect_words(\"Mary had a little lamb\", 3)\n</cell>\n\
    <code language=julia-0.6>\nselect_words(\"simple white space\", 2)\n</cell>\n\
    <code language=julia-0.6>\nselect_words(\"Hello world\", 4)\n</cell>\n<code language=julia-0.6>\n\
    select_words(\"Uncle sam\", 3)\n</cell>\n<text>\nQ5. Write a function countvowels(s),\
    \ that returns the number of vowels (as in \"aeiou\") in the string s, given a\
    \ non-empty string.", "    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O',\
    \ 'U']\n    letters = collect(lowercase(s))\n    \n    positions = filter(i ->\
    \ vowels.contains(letters[i]), letters)\n    positions = positions.filter(i ->\
    \ length(i) == n)\n    \n    selectables = letters[positions]\n    \n    return\
    \ selectables\nend\n</code>\n<|/ a tags=arrays,sorting,string,julia |>\n<| c |>\n\
    `@time select_words(\"hello world\",10^7)` is `0.063 sec`. You can run it multiple\
    \ times to see the speedup.\n<|/ c |>\n<| c |>\nAlso note that the `@time` macro\
    \ only works if you use either `@time` or `@parallel`.\n<|/ c |>\n<| c |>\nThis\
    \ doesn't produce the expected output for select_words(\"hello world\",10^7).\
    \ It returns `[\"olle\"]` instead of `[\"hel\",\"o\",\"rld\"]`.\n<|/ c |>\n<|\
    \ a tags=arrays,sorting,string,julia |>\nHere's my solution using Julia version\
    \ 1.7.0:\n<code>", "    if s == \"\"\n    then []\n    else select_words(s.substring(1),\
    \ n)\n    for w in s\n    if contains(w, n, true)\n    then [w]\n    else select_words(w,\
    \ n)\nend\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3 |>\nThe above answers are\
    \ very good, but to understand why the problem was occurring, let's walk through\
    \ it step by step.\n<code>", "    \n    vec1 = String[]\n    for i in 1:n\n  \
    \      vec1[i] = [find(s, \" \", i+1)]\n    end", "    \n    \n\"\"\"\n    count_words(s::String)::Int64\n\
    \    \n    \n\"\"\"\n    count_words(s::Vector{String})::Int64\n    \n    \n\"\
    \"\"\n    count_words(s::String, n::Int64)::Int64\n    \n    \n\"\"\"\n    count_words(s::Vector{String})::Int64\n\
    \    \n    \n\"\"\"\n    count_words(s::String, n::Int64)::Int64\n    \n    \n\
    \"\"\"\n    count_words(s::Vector{String}, n::Int64)::Int64\n    \n    \n\"\"\"\
    \n    count_words(s::String, n::Int64)::Int64\n    \n    \n\"\"\"\n    count_words(s::Vector{String},\
    \ n::Int64)::Int64\n    \n    \n\"\"\"\n    count_words(s::String, n::Int64)::Int64\n\
    \    \n    \n\"\"\"\n    count_words(s::Vector{String}, n::Int64)::Int64\n   \
    \ \n    \n\"\"\"\n    count_words(s::String, n::Int64)::Int64\n    \n    \n\"\"\
    \"\n    count_words(s::Vector{String}, n::Int64)::Int64\n    \n    \n\"\"\"\n\
    \    count_words(s::String, n::Int64)::Int64\n    \n    \n\"\"\"\n    count_words(s::Vector{String},\
    \ n::Int64)::Int64\n    \n    \n\"\"\"\n    count_words(s::String, n::Int64)::Int64\n\
    \    \n    \n\"\"\"\n    count_words(s::Vector{String}, n::Int64)::Int64\n   \
    \ \n    \n\"\"\"\n    count_words(s::String, n::Int64)::Int64\n    \n    \n\"\"\
    \"\n    count_words(s::Vector{String}, n::Int64)::Int64\n    \n    \n\"\"\"\n\
    \    count_words(s::String, n::Int64)::Int64\n    \n    \n\"\"\"\n    count_words(s::Vector{String},\
    \ n::Int64)::Int64\n    \n    \n\"\"\"\n    count_words(s::String, n::Int64)::Int64\n\
    \    \n    \n\"\"\"\n    count_words(s::Vector{String}, n::Int64)::Int64\n   \
    \ \n    \n\"\"\"\n    count_words(s::String, n::Int64)::Int64\n    \n    \n\"\"\
    \"\n    count_words(s::Vector{String}, n::Int64)::Int64\n    \n    \n\"\"\"\n\
    \    count_", "    # implement code here\n    \nend", "\"\"\"\nGiven a string\
    \ s and a natural number n, you have been tasked to implement \n    a function\
    \ that returns a vector of all words from string s that contain exactly \n   \
    \ n consonants, in order these words appear in the string s.\n    If the string\
    \ s is empty then the function should return an empty vector.\n    Note: you may\
    \ assume the input string contains only letters and spaces.\n    Examples:\n \
    \   >>> select_words(\"Mary had a little lamb\", 4)\n    [\"little\"]\n    >>>\
    \ select_words(\"Mary had a little lamb\", 3)\n    [\"Mary\", \"lamb\"]\n    >>>\
    \ select_words(\"simple white space\", 2)\n    []\n    >>> select_words(\"Hello\
    \ world\", 4)\n    [\"world\"]\n    >>> select_words(\"Uncle sam\", 3)\n    [\"\
    Uncle\"]\n    \"\"\"", "    if n == 0\n        Vector{}\n    else\n        \n\
    \        if n == 1\n            s = [i for i in split(s)]\n            \n    \
    \    else\n            \n            ans = Set{String}()\n            \n     \
    \       for i in split(s)\n                if count(i) == n\n                \
    \    push!(ans, i)\n            end", "    return if n == 0 return [] else [w\
    \ for w in split(s) if length(w)>=n] \n</code>\n<|/ a dscore=2 tags=string,julia\
    \ |>\n<| a |>\nI agree with and I came up with a solution that uses split:\n<code>",
  "    \"\"\"\n    Code Block for select_words()\n    \"\"\"", "# your code here\n\
    end", "    \nend\n</cell>\n<text>\nExercise\nImplement a function that returns\
    \ all words in a string, that have three or more vowels, \nbut no consonants.",
  "    \n    function select_words::Vector{String}\n        \n    end \n    \n   \
    \ select_words(s, n)\nend\n</code>\n<|/ q |>\n<| c |>\nWhat is your question?\n\
    <|/ c |>\n<| c |>\nThis is an exercise from Coursera where I'm supposed to get\
    \ my code working and I can't figure out how to get it working and I'm having\
    \ a lot of difficulty understanding the errors that I keep getting. I've tried\
    \ searching for similar problems and can't seem to find anything that helps me.\n\
    <|/ c |>\n<| a tags=julia,julia-jump |>\nThe error message you got is quite clear:\
    \ You cannot pass 2 arguments to a function which accepts 1 parameter. See the\
    \ docs: https://docs.julialang.org/en/v1/manual/methods/#man-method-parameters-1\n\
    The syntax for the function parameters is different in julia v1 and v2. Try the\
    \ code below in julia v1:\n<code>", "    if s == \"\"\n        return Vector{String}()\n\
    \    \n    select_words(s, n, \"\")\nend", "    \n    words = ''\n    for c in\
    \ s\n        if isLetter(c.upcase) && n==0\n            words += c\n         \
    \   n = 1\n        elsif isLetter(c.upcase)\n            n -= 1\n        end\n\
    \    end\n    return words\nend\n</cell>\n<code language=julia-1.5>\nselect_words(\"\
    Mary had a little lamb\", 4)\n</cell>\n<code language=julia-1.5>\nselect_words(\"\
    Mary had a little lamb\", 3)\n</cell>\n<code language=julia-1.5>\nselect_words(\"\
    simple white space\", 2)\n</cell>\n<code language=julia-1.5>\nselect_words(\"\
    Hello world\", 4)\n</cell>\n<code language=julia-1.5>\nselect_words(\"Uncle sam\"\
    , 3)\n</cell>\n<text>\nImplement the replace_word() function to replace all words\
    \ in a string with another string. \nYou can use the function contains(s, w) to\
    \ check if a string s contains a substring w.\nYou will also use the function\
    \ wordcount(s) to find the total number of times w occurs in string s. \nYou will\
    \ use the map and filter functions to help you complete this function.\nThe replace_word(s,\
    \ w, r) function should return a new string r where all appearances of w have\
    \ been replaced with r. \nIf w is not found in s, then the replace_word(s, w,\
    \ r) function should return s.\nExamples:\n>>> replace_word(\"My name is Sarah\"\
    , \"name\", \"Alice\")\n\"My name is Alice\"\n>>> replace_word(\"The quick brown\
    \ fox jumps over the lazy dog\", \"brown\", \"dog\")\n\"The quick dog jumps over\
    \ the lazy dog\"\n>>> replace_word(\"the quick brown fox jumps over the lazy dog\"\
    , \"dog\", \"fox\")\n\"The quick brown fox jumps over the lazy fox\"\n>>> replace_word(\"\
    the quick brown fox jumps over the lazy dog\", \"brown\", \"lazy\")\n\"The quick\
    \ brown lazy fox jumps over the lazy dog\"\n>>> replace_word(\"the quick brown\
    \ fox jumps over the lazy dog\", \"lazy\", \"brown\")\n\"The quick brown fox jumps\
    \ over the lazy dog\"\n>>> replace_word(\"the quick brown fox jumps over the lazy\
    \ dog\", [], \"quick\")\n\"the quick brown fox jumps over the lazy dog\"\n>>>\
    \ replace_word(\"the quick brown fox jumps over the lazy dog\", [\"quick\", \"\
    brown\"], \"dog\")\n\"the quick dog jumps over the lazy dog\"\n>>> replace_word(\"\
    the quick brown fox jumps ", "    \nend\n</cell>\n<code language=julia-1.0>",
  "</code>\nAnd then you write a main function to test your function:\n<code>\nusing\
    \ Main.Arrays", "    \"\"\"\n    select_words(s, n)\n    \n    Given a string\
    \ s and a natural number n, you have been tasked to implement \n    a function\
    \ that returns a vector of all words from string s that contain exactly \n   \
    \ n consonants, in order these words appear in the string s.\n    If the string\
    \ s is empty then the function should return an empty vector.\n    Note: you may\
    \ assume the input string contains only letters and spaces.\n    Examples:\n \
    \   >>> select_words(\"Mary had a little lamb\", 4)\n    [\"little\"]\n    >>>\
    \ select_words(\"Mary had a little lamb\", 3)\n    [\"Mary\", \"lamb\"]\n    >>>\
    \ select_words(\"simple white space\", 2)\n    []\n    >>> select_words(\"Hello\
    \ world\", 4)\n    [\"world\"]\n    >>> select_words(\"Uncle sam\", 3)\n    [\"\
    Uncle\"]\n    \"\"\"\nif n == 0 || s == \"\"\n    return []\n    if n > 0\n  \
    \      \n    if n == 1\n        return filter( word->find_cons(word,s) >= n,word_list)\n\
    \    else\n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    ", "  \
    \  words_containing_consonants = filter(x->contains(s, x), words)\n    \n    #return\
    \ the length of the vector\n    return length(words_containing_consonants)\nend\n\
    </code>\n<|/ q tags=julia |>\n<| a dscore=1 |>\nYour implementation of find_substring\
    \ looks for every single word in the dictionary that starts with the letters in\
    \ word. Instead, you can use a regular expression (\\<word\\>) to match words\
    \ starting with word:\n<code>", "\"\"\"\n## Task 7 - Write a function called replace_letters\
    \ that can replace all consonants in a \n    string with a letter, where consonants\
    \ are all letters except for \"a\", \"e\", \"i\", \n    \"o\", \"u\" and vowels\
    \ are all consonants and \"A\" and \"E\", \"I\", \"O\" and \"U\".\n    \n    As\
    \ a special case, if there are fewer than two letters in the string, \n    then\
    \ return the string unchanged.\n    Examples:\n    >>> replace_letters(\"awesome\"\
    )\n    \"Awesome\"\n    >>> replace_letters(\"aeiou\")\n    \"Aeiou\"\n    >>>\
    \ replace_letters(\"aeiou\", consonants = \"AEIOU\")\n    \"Ayiou\"\n    >>> replace_letters(\"\
    aeiou\", consonants = \"AEIOU\", letter = \"A\")\n    \"Ay\"\n    >>> replace_letters(\"\
    abcdefg\", consonants = \"AEIOU\", letter = \"A\")\n    \"Ayz\"\n    \"\"\"",
  "    if s == \"\"\n        Vector{String}()\n    else\n        if n==1\n       \
    \     if isalpha(s[1])\n                push!(Vector{String}(), s[2:end])\n  \
    \          else\n                push!(Vector{String}(), \"\")\n            end\n\
    \        else\n            if isalpha(s[1])\n                push!(select_words(s[2:end],\
    \ n-1), s[2:end])\n            else\n                push!(select_words(s[2:end],\
    \ n-1), \"\")\n            end\n        end\n    end\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThanks for the answer. I've been trying to learn Julia, and I got stuck\
    \ at this point.\n<|/ c |>\n<| c |>\nWhat if I want to use a string function instead\
    \ of `isalpha()`? How would I modify this code?\n<|/ c |>\n<| c |>\nThe function\
    \ `isalpha()` returns `true` if and only if the first character of the string\
    \ is a letter, and false otherwise. How would you modify the code to work with\
    \ a string? I assume you mean something like: `\"hello\".isalpha()` returns `false`,\
    \ but what would you expect `\"hello\".isalpha(string)` to return?\n<|/ c |>\n\
    <| c |>\nOh I see - you are asking to return words containing exactly n consonants.\
    \ I'll edit the answer accordingly.\n<|/ c |>\n<| c |>\nThank you very much!\n\
    <|/ c |>\n<| a dscore=2 tags=string,algorithm,julia,split |>\nHere is a solution\
    \ that avoids using regexes.\n<code>", "    \nend # function\n</cell>\n<text>\n\
    Part 4", "    \n    \"\"\"\n    \n    \n    \"\"\"\n    # Write your code in Python\
    \ 3.6\n    \n    import collections\n    \n    # write your code in Python 3.6\n\
    \    \n    return words\n    \n    \n    \"\"\"\n    return words\n    \n    \n\
    \    \"\"\"\n    return words\n    \n    \n    \"\"\"\n    return words\n    \n\
    \    \n    \"\"\"\n    return words\n    \n    \n    \"\"\"\n    return words\n\
    \    \n    \n    \"\"\"\n    return words\n    \n    \n    \"\"\"\n    return\
    \ words\n    \n    \n    \"\"\"\n    return words\n    \n    \n    \"\"\"\n  \
    \  return words\n    \n    \n    \"\"\"\n    return words\n    \n    \n    \"\"\
    \"\n    return words\n    \n    \n    \"\"\"\n    return words\n    \n    \n \
    \   \"\"\"\n    return words\n    \n    \n    \"\"\"\n    return words\n    \n\
    \    \n    \"\"\"\n    return words\n    \n    \n    \"\"\"\n    return words\n\
    \    \n    \n    \"\"\"\n    return words\n    \n    \n    \"\"\"\n    return\
    \ words\n    \n    \n    \"\"\"\n    return words\n    \n    \n    \"\"\"\n  \
    \  return words\n    \n    \n    \"\"\"\n    return words\n    \n    \n    \"\"\
    \"\n    return words\n    \n    \n    \"\"\"\n    return words\n    \n    \n \
    \   \"\"\"\n    return words\n    \n    \n    \"\"\"\n    return words\n    \n\
    \    \n    \"\"\"\n    return words\n    \n    \n    \"\"\"\n    return words\n\
    \    \n    \n    \"\"\"\n    return words\n    \n    \n    \"\"\"\n    return\
    \ words\n    \n    \n    \"\"\"\n    return words\n    \n    \n    \"\"\"\n  \
    \  return words\n    \n    \n    \"\"\"\n    return words\n    \n    \n    \"\"\
    \"\n    return words\n    \n    \n    \"\"\"\n    return words\n    \n    \n \
    \   \"\"\"\n    return words\n    \n    \n    \"\"\"\n    return words\n    \n\
    \    \n    \"\"\"\n    return words\n    \n    \n    \"\"\"\n    return words\n\
    \    \n    \n    \"\"\"\n    return words\n    \n    \n    \"\"\"\n    return\
    \ words\n    \n    \n    \"\"\"\n    return words\n    \n    \n    \"\"\"\n  \
    \  return words\n    \n    \n    \"\"\"\n    return words\n    \n    \n    \"\"\
    \"\n    return words\n    \n    \n    \"\"\"\n    return words\n    \n    \n \
    \   \"\"\"\n    return words\n    \n    \n    \"\"\"\n    return words\n    \n\
    \    \n    \"\"\"\n    return words\n    \n    \n    \"\"\"\n    return words\n\
    \    \n    \n    \"\"\"\n    return words\n    \n    \n    \"\"\"\n    return\
    \ words\n    \n    \n    \"\"\"\n    return words\n    \n    \n    \"\"\"\n  \
    \  return words", "    if s == \"\" \n        return Vector{String}()\n    end\n\
    \    let l = length(s) \n    words = []\n    for i in 1:l \n        if char.index(s[i],1)\
    \ <= n \n            push!(words,s[i])\n        end\n    end \n    return words\n\
    end \n</code>\n<|/ a |>\n<| c |>\nI understand why this doesn't work, but I'm\
    \ afraid I didn't say that this is an assignment... And I'm afraid this doesn't\
    \ work either... :/\n<|/ c |>\n<| a dscore=0 |>\nI wrote this simple solution\
    \ that is easy to understand.\nIt uses pattern matching.\n<code>", "  \n    v\
    \ = Vector{String}()\n    \n    push!(v,s)\n    \n    v = v + []\n    \n    for\
    \ i in length(s):-1\n        for j in 0:n-1\n            if s[i+j] != \" \"\n\
    \                break\n            else\n                push!(v,s[i:i+j+1])\n\
    \        end\n    end\n    \n    v\nend\n</code>\n<|/ q tags=string,julia |>\n\
    <| c |>\nIf you're looking for efficiency and for simplicity, you should avoid\
    \ `push!` and `index`, which cause allocations and copying of data. Instead, I'd\
    \ suggest you use [`Vec{String}()`](https://docs.julialang.org/en/v1/base/arrays/#Base.Vec{T})\
    \ and [`push!`](https://docs.julialang.org/en/v1/base/arrays/#Base.push!).\n<|/\
    \ c |>\n<| c |>\nAlso, there are some issues with your code. On the first iteration,\
    \ `k` will always be 0, so you might as well drop the `else` branch. On the other\
    \ hand, you use `v` in the `for` loop, but never assign to it after the loop (`v\
    \ = v + []`). Finally, I believe that you should replace `isspace(i)` with `i\
    \ != \" \"` in `select_words` if you do not intend to match against a space, since\
    \ `\" \"` is a single whitespace character.\n<|/ c |>\n<| c |>\nThank you for\
    \ the tips.  I will fix the issues you mentioned.  I also added a comment at the\
    \ top of my code showing how it can be used; I thought I would try it first to\
    \ see if I could get a working solution.\n<|/ c |>\n<| a tags=string,julia dscore=0\
    \ |>\nHere is how I solved the problem of identifying words that contain all n\
    \ consonants using the same method as suggested by Ian Roberts and Roberts Zigmond:\n\
    <code>", "    \n    # Complete this function\n    return []\nend\n</cell>\n<code\
    \ language=julia-1.0>\nusing Test", "    \n    return [] \nend", "    if !is_empty(s)\
    \ {\n        select_words(s, n)\n    }\n    else {\n        return []\n    }\n\
    end", "    #your code goes here\nend\n</cell>\n<text>\n6. Implement the function\
    \ count_vowels that takes a string s and a natural number n and returns \n   \
    \ an integer that represents the number of vowels in s. \n    The vowels are \"\
    a\", \"e\", \"i\", \"o\", and \"u\". \n    Note: the string s contains only lowercase\
    \ letters.\n    Examples:\n    >>> count_vowels(\"Mary had a little lamb\", 1)\n\
    \    3\n    >>> count_vowels(\"Mary had a little lamb\", 2)\n    3\n    >>> count_vowels(\"\
    Mary had a little lamb\", 3)\n    0\n    >>> count_vowels(\"Hello world\", 4)\n\
    \    3\n    >>> count_vowels(\"Uncle sam\", 3)\n    3\n    \"\"\"", "    # Write\
    \ your answer here\n    \n    return \nend", "    if s == \"\" \n        Vector{String}()\
    \ \n    else\n        \n        if n == 0 \n            return [] \n        elseif\
    \ n == 1 \n            return vec([s]) \n        else \n            \n       \
    \     \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n",
  "    \n    list = Vector{String}()\n    \n    for i in eachindex(s)\n        if\
    \ isconsonant(s[i]) && length([c for c in s[i:i+n] if isconsonant(c)])==n\n  \
    \          push!(list, s[i])\n        end\n    end\n    list\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| a |>\nThis can be done quite concisely using regular expressions.\
    \ Here's an example for the same problem as OP:\n<code>", "    \n\"\"\"\n    Problem\
    \ 3: count_vowels\n    Input: s\n    Output: vector of all vowels in s\n    Constraints:\n\
    \    s should be a string\n    s should be non empty\n    vowel can be a letter,\
    \ an accent or an umlaut\n    vowels can be repeated\n    Examples:\n    >>> count_vowels(\"\
    Mary had a little lamb\")\n    [\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"", "    if s == \"\"\n        return Vector{String}()\n    \n\
    \    ends = Vector{Int64}(find_consonants(s))\n    \n    candidates = Vector{String}()\n\
    \    for w in words\n        if length(w) >= n\n            push!(candidates,\
    \ w)\n        ends[ends.index(w)] += 1\n    ends\nend\n</cell>\n<text>\nPart Two\n\
    Implement a function that takes a vector v and an integer n, and returns a new\
    \ vector w containing exactly n copies of the elements in v.  \nThe vector v should\
    \ not be modified in any way but passed back.  \nFor example, if v = [1, 2, 3],\
    \ then w = [1, 2, 3, 1, 2, 3, 1, 2, 3]. \nThe vector v may be a vector of strings,\
    \ Ints, Reals, or whatever other type that is acceptable.  \nIf n is greater than\
    \ the length of v, then you should return an empty vector. \nIf n is less than\
    \ or equal to the length of v, then you should return v.  \nIn other words, you\
    \ should not change v.  \nNote: The function should be passed a vector of arbitrary\
    \ type.  ", "  \n    str = split(s)\n    if str == []\n        vec = []\n    else\n\
    \        vec = str .filter(x -> string(x) == n)\n    end\n    return vec", " \
    \   \"\"\"\n    Implement a function that returns a vector of all words from string\
    \ s that contain exactly \n    n consonants, in order these words appear in the\
    \ string s.\n    If the string s is empty then the function should return an empty\
    \ vector.\n    Note: you may assume the input string contains only letters and\
    \ spaces.\n    Examples:\n    >>> select_words(\"Mary had a little lamb\", 4)\n\
    \    [\"little\"]\n    >>> select_words(\"Mary had a little lamb\", 3)\n    [\"\
    Mary\", \"lamb\"]\n    >>> select_words(\"simple white space\", 2)\n    []\n \
    \   >>> select_words(\"Hello world\", 4)\n    [\"world\"]\n    >>> select_words(\"\
    Uncle sam\", 3)\n    [\"Uncle\"]\n    \"\"\"\n    \n    if s == \"\"\n       \
    \ \n    \n    \"\"\"\n    \n    \n    \"\"\"", "    return \"\"\nend", "    \n\
    \    # Your code here\n    if s == \"\"\n        return Vector{String}()\n   \
    \ end\n    \n    words = []\n    for letter in s\n        if letter in \"aeiouAEIOU\"\
    \n            if length(words) == n or n == 0\n                push!(words, letter)\n\
    \            end\n        end\n    end\n    \n    return words\nend\n</cell>\n\
    <text>\n3.1.2 Vectorize Your Code\nYour code should always vectorize before submission.\
    \ Vectorizing does not only improve efficiency (you know it because you were able\
    \ to vectorize your original code), it also leads to clearer and more understandable\
    \ code.", "    \n    if length(s) < n\n        Vector{}\n    else\n        \n\
    \    end1 = false\n    end2 = false\n    \n    for i in eachindex(s)\n       \
    \ if s[i] == 'd'\n            if end1\n                end2 = true\n         \
    \       word = \"\"\n            else\n                end1 = true\n         \
    \       word += s[i]\n            end\n        else\n            if end2\n   \
    \             word += s[i]\n            else\n                if n == 1\n    \
    \                word += s[i]\n                else\n                    end1\
    \ = true\n                    word += s[i]\n                end\n            end\n\
    \        end\n    end\n    return word\nend\n</cell>\n<code language=julia-0.6>\n\
    select_words(\"Mary had a little lamb\", 4)\n</cell>\n<code language=julia-0.6>\n\
    select_words(\"Mary had a little lamb\", 3)\n</cell>\n<code language=julia-0.6>\n\
    select_words(\"simple white space\", 2)\n</cell>\n<code language=julia-0.6>\n\
    select_words(\"Hello world\", 4)\n</cell>\n<code language=julia-0.6>\nselect_words(\"\
    Uncle sam\", 3)\n</cell>\n<text>\nPart 3: Rewrite your functions using pattern\
    \ matching", "    word_vec = Vector{String}()\n    \n    # Your code here\n  \
    \  \n    return word_vec\nend", "    select_words(s, n, [])\nend", "    \n   \
    \ return words[word_index[s]] .- n", "    if n == 0 \n        Vector{String}()\n\
    \    else \n        if length(s)==0 \n            [] \n        else \n       \
    \     select_words(s, n - 1) |> Vector{String} ++ select_words(s, n) \n    end\n\
    end\n</cell>\n<code language=julia-1.0>\nusing Test", "\"\"\"\nImplement this\
    \ function\n\"\"\"", "</code>\nAnd now that we have the basic function, how do\
    \ we implement it?\nFirst, we need to define the function wordCount:\n<code>\n\
    wordCount(s::String)::Int64\n</code>\nThis function counts the number of occurences\
    \ of each word in an input string.\nTo count the number of occurences of a word\
    \ we can use the function filter:\n<code>\nfilter isWord(s::String)::Bool\n</code>\n\
    And finally, we need to define an auxiliary function filterWord:\n<code>\nfilterWord(s::String)::String\n\
    </code>\nThis function will take a string and filter the words out of it using\
    \ the isWord function.\nThe two functions together give:\n<code>\nwordCount(s:String)::Int64\
    \ = filter isWord(s) |> length\nfilterWord(s:String)::String = filter (isWord)\
    \ s\n</code>\nBut wait, there's more! \nWhat if we want to apply these functions\
    \ to a vector of strings? We can use a fold to do this \n<code>\nwordCount(s::Vector{String})::Int64\
    \ = fold(length, 0, s)\nfilterWord(s::Vector{String})::String = fold(filterWord,\
    \ [], s)\n</code>\nAnd there we have it!\n<|/ a tags=haskell,string dscore=1 |>\n\
    <| c |>\nNote that `isWord` could be implemented as `not . null . filter (/= '\
    \ ')`.\n<|/ c |>\n<| c |>\nOk, this looks great, but I'm a bit puzzled why you\
    \ put the `filter` function after the `isWord` function... Can you explain this\
    \ to me, please? It seems logical to me that these functions would be applied\
    \ in the order as they are defined...\n<|/ c |>\n<| c |>\nThe `filter` function\
    \ takes all the `String`s and only returns those where the `isWord` function returns\
    \ `True`. By calling `filter isWord` you effectively get a list of `String`s and\
    \ then use `length` on that list.\n<|/ c |>\n<| c |>\nRight, so the filter function\
    \ in my original answer would be: ```wordCount(s:String)::Int64 = fold(length,\
    \ 0, filter isWord(s))```\n<|/ c |>\n<| a |>\nAs you said you only want a solution\
    \ which works with String (and you probably already found this out but i want\
    \ to add a solution that works with String). But lets do it with [String]\nFirst\
    \ we need a function that takes a string and returns true if there are any characters\
    \ that match the pattern [a]\n<code>\nanychar :: String -> Bool\nanychar a = [c]\
    \ `elem", "    if s.length == 0 \n        return [] \n    if n == 1 \n       \
    \ return select_words_1(s) \n    \n    \n    else \n        \n        words =\
    \ select_words_1(s) \n        \n        \n        \n        \n        \n     \
    \   \n    \n    end\n    \nend\n</cell>\n<code language=julia-1.0>\nselect_words(\"\
    Mary had a little lamb\", 4)\n</cell>\n<code language=julia-1.0>\nselect_words(\"\
    Mary had a little lamb\", 3)\n</cell>\n<code language=julia-1.0>\nselect_words(\"\
    simple white space\", 2)\n</cell>\n<code language=julia-1.0>\nselect_words(\"\
    Hello world\", 4)\n</cell>\n<code language=julia-1.0>\nselect_words(\"Uncle sam\"\
    , 3)\n</cell>\n<code language=julia-1.0>\ns = \"\"\nn = 4\nselect_words(s, n)\n\
    </cell>\n<code language=julia-1.0>\ns = \"\"\nn = 3\nselect_words(s, n)\n</cell>\n\
    <code language=julia-1.0>\ns = \"\"\nn = 2\nselect_words(s, n)\n</cell>\n<text>\n\
    Problem 7\nFor this problem, we define the function split_words_1(s) which splits\
    \ the string s into words using the following rules:\nIf the current character\
    \ is a space, append the word to a vector.\nIf the current character is a letter,\
    \ append the letter to a list of words.\nIf the current character is a non-letter,\
    \ append the letter to a list.\nIf the current character is a punctuation mark,\
    \ append the punctuation mark to a list.\nIf the current character is a number,\
    \ append the number to a list of words.\nIf the current character is a non-letter,\
    \ append the letter to a list.\nNote: The string s consists only of letters, spaces,\
    \ punctuation marks, numbers, and non-letters.\nTo split the string s into words,\
    \ this function first splits the string s into characters using split_chars_1(s).\
    \ Then it splits each character into words using split_words_1(s).", "    if s\
    \ == \"\"\n        return Vector{}\n    v = Vector{String}()\n    v = v ++ filter((word)\
    \ -> length(strings(word)) <= n , words)\n    v = v ++ filter((word) -> length(strings(word))\
    \ > n , words)\n    return v\nend", "    if s == \"\" \n    else select_words(s.substring(0,n+1),\
    \ n) \n    end\nend\n</cell>\n<text>\nTask 4.3: Vectorize the select_words function",
  "    if s.length == 0 then return [] \n    # Split the string into words on space\n\
    \    splits = split(s, \" \")\n    # Filter the words in the list to those containing\
    \ exactly n\n    selected_words = filter (n -> length(filter (x -> x==\"C\", xs))\
    \ == n) splits\n    return selected_words;\nend \n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\n`length()` is O(1), so it is not really a good idea to use it here. Instead,\
    \ `if length(filter (x -> x==\"C\", xs)) == n then ...` would be more efficient.\n\
    <|/ c |>\n<| c |>\nI didn't know about that function. Thanks! I still think though\
    \ that `if length(filter (x -> x==\"C\", xs)) == n then ...` is more readable.\
    \ Do you have a better idea? What would you do?\n<|/ c |>\n<| c |>\nI think I\
    \ would use the `filter` function and `==` inside the `if` statement just as you\
    \ did in the OP.\n<|/ c |>\n<| c |>\nYes, I agree. I guess I started off a bit\
    \ too complicated and got caught up with `==`. I'll edit the answer.\n<|/ c |>\n\
    <| c |>\nThanks for your help. I do have a question about your solution. Why do\
    \ you filter by `xs == \"C\"`? That doesn't seem necessary.\n<|/ c |>\n<| a |>\n\
    Just for fun, here is another solution that is shorter but not as easy to read:\n\
    <code>", "    l = length(s)\n    \n    if n <= 0\n        return Vector{}\n  \
    \  \n    if n >= l \n        return Vector{String}\n    \n    \n    contador =\
    \ 0\n    \n    for w in 1:l\n        if s.contains(String{\"consonant\"}) & contador\
    \ == n\n            return String{w, length(w)}\n        contador = contador +\
    \ 1\n    end\n    \n    return Vector{}\nend\n</code>\nThis implementation does\
    \ not work with nested words. For example:\n<code>\njulia> select_words(\"Mary\
    \ had a little lamb\", 3)\n2-element Vector{String}:\n \"Mary\"\n \"little\"\n\
    </code>\n<|/ a tags=julia,vector,string |>\n<| c |>\nA very nice solution that\
    \ is easy to understand and does not require an external package. The problem\
    \ is that it does not solve the issue of words containing a substring of a word\
    \ that should be kept. For example select_words(\"A quick brown fox\", 2)\n[\"\
    fox\"]\n<|/ c |>\n<| a |>\nHere is another solution, without using any additional\
    \ package and with short code\n<code>", "    \nend\n</cell>\n<text>\nProblem 9\n\
    Write a function that removes all the stop words from a given list, and returns\
    \ the remaining elements.\nFor example:\n    [\"a\", \"the\", \"and\", \"of\"\
    , \"to\", \"is\"] -> [\"a\", \"of\"]\n    remove_stopwords(\"The rain in Spain\
    \ stays mainly in the plain\") ->\n    [\"rain\", \"Spain\", \"mainly\"]\nMake\
    \ sure the returned vector does not contain duplicate words.\n    \"\"\"", " \
    \   \n    vector=Vector{String}()\n    \n    if s.length==0 \n        return vector\n\
    \    end=findlastindex(s,\" \")\n    \n    for i in (1:end)\n        \n      \
    \  if n>=s[end]\n            push!(vector,s[end]) #pushes the last word after\
    \ the last space\n            break\n        else\n            word=substring(s,i+1,end)\n\
    \            \n            if n<length(word)\n                push!(vector,word)\n\
    \            end\n        end\n    end\n    return vector\nend", "    str = strsplit(s,\
    \ \"\\s\")\n    vec_result = []\n    for i in str\n        if i == \"\"\n    \
    \        vec_result.push()\n        else\n            if length(i) == n\n    \
    \            vec_result.push(i)\n            else\n                println(\"\
    Not enough characters\")\n            end\n        end\n    end\n    return vec_result\n\
    end", "    str = split(s, \" \")\n    words = []\n    for w in str\n        if\
    \ length(findall(w, r\"[b-zA-Ha-h]\", Inf)) == n\n            push!(words, w)\n\
    \        end\n    end\n    return words\nend\n</cell>\n<text>\nExercises:\nTest\
    \ your function with the example code below.", "    s = s.lower()\n    \n    if\
    \ n == 0\n        return Vector{String}()\n    \n    words  = [] #stores all words\
    \ from given string s\n    count = 0\n    \n    for c in s.chars()\n        if\
    \ count==n\n            push!(words, s)\n        end\n        count += 1\n   \
    \ end\n    \n    return words\nend", "    if s == \"\" \n        return Vector{String}()\n\
    \    end", "    \n    words = []\n    for i in 1:n\n        push!(words, filter(isempty,\
    \ words(s)))\n    end\n    \n    return words\nend\n</cell>\n<text>\nProblem 5\n\
    Write a function that returns a list of words that are longer than the specified\
    \ number of characters. For example, if you called your function with n = 10,\
    \ then:", "    if s == \"\"\n        return Vector{String}()\n    \n    words\
    \ = Vector{String}()\n    for w in words\n        if w.count(n) == 1\n       \
    \     push!(words, w)\n        end\n    end\n    \n    return words\nend\n</cell>\n\
    <text>\nQ9. Consider the following function definition", "  ans = Vector{String}()\n\
    \  len = length(s)\n  if len == 0\n    ans\n  else\n    for i = 1 : len\n    \
    \  if chars.contains(s[i], n)\n        push!(ans, s[i])\n      end\n    end\n\
    \  end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for the quick response!\
    \ This worked really well, except for two problems: 1) I needed a case that would\
    \ give an empty vector if the string had no spaces, and 2) I needed to convert\
    \ the letters of the word to upper case before I could find them in the string.\
    \ I edited your example to reflect these changes. Thank you again!\n<|/ c |>\n\
    <| a dscore=1 |>\nBased off of Piotr's answer, here is a solution that works with\
    \ any length for consonants and includes the ability to find the words with multiple\
    \ consonants as well:\n<code>", "    if s == \"\"\n        return Vector{String}()\n\
    \    words = split(s) #Split string\n    sorted_words = sort(words) #Sort words\n\
    \    res = [] #Create empty result\n    for word in sorted_words\n        if length(res\
    \ + [word]) == n\n            res.append(word)\n        end\n    end\n    return\
    \ res\nend", "    if s == \"\" \n        Vector{String}() \n    else \n      \
    \  words = split(s, \" \")\n        \n        select_words_aux(words, n, Vector{String}())\
    \ \n    end\nend", "    \n    # Your code goes here\n    \n    return []\nend\n\
    </cell>\n<text>\nProblem 7\nImplement the function is_vowel(s::String) which checks\
    \ if a word is a vowel.\nExamples:\n>>> is_vowel(\"a\") # True\n>>> is_vowel(\"\
    e\") # True\n>>> is_vowel(\"i\") # True\n>>> is_vowel(\"o\") # True\n>>> is_vowel(\"\
    u\") # True\n>>> is_vowel(\"oops\") # False\n>>> is_vowel(\"hello\") # False\n\
    >>> is_vowel(\"goodbye\") # False\n\"\"\"", "    if s == \"\"\n        return\
    \ Vector{String}()\n    # add your code here\n    return Vector{String}()\nend\
    \ \n</code>\n<|/ q dscore=0 tags=julia |>\n<| c |>\nIn general, `println` is used\
    \ only in interactive sessions, like REPL. Generally, you should use either `print`\
    \ or `println` to output to console. `print` is just a helper function which can\
    \ do whatever it wants depending on the output type.\n<|/ c |>\n<| c |>\nSo then\
    \ what is ```println```? Can you explain why I cannot use ```println```?\n<|/\
    \ c |>\n<| c |>\n```println``` is for outputting a message to a console (REPL).\n\
    <|/ c |>\n<| c |>\nIt looks like you are using the REPL. Your function works as\
    \ written, if you put it into the REPL then run it by typing `select_words(s)`\
    \ with some string `s`.\n<|/ c |>\n<| c |>\nWhen I try it from the REPL I get\
    \ the following error: `\"UndefVarError: println not defined\"`\n<|/ c |>\n<|\
    \ a tags=julia |>\n<code>", "    # Your code here\n    l = s.split(\" \")\n  \
    \  vec = Vector{String}()\n    for i = 1:length(l)\n        if length(l[i]) ==\
    \ n\n            push!(vec, l[i])\n        end\n    end\n    return vec\nend\n\
    </cell>\n<code language=julia-1.5>\n# %load solutions/s14_find_words_with_the_number_consonants.jl\n\
    \"\"\"Given a string s and a natural number n, you have been tasked to implement\
    \ \n    a function that returns a vector of all words from string s that contain\
    \ exactly \n    n consonants, in order these words appear in the string s.\n \
    \   If the string s is empty then the function should return an empty vector.\n\
    \    Note: you may assume the input string contains only letters and spaces.\n\
    \    Examples:\n    >>> select_words(\"Mary had a little lamb\", 4)\n    [\"little\"\
    ]\n    >>> select_words(\"Mary had a little lamb\", 3)\n    [\"Mary\", \"lamb\"\
    ]\n    >>> select_words(\"simple white space\", 2)\n    []\n    >>> select_words(\"\
    Hello world\", 4)\n    [\"world\"]\n    >>> select_words(\"Uncle sam\", 3)\n \
    \   [\"Uncle\"]\n\"\"\"", "    if s == \"\"\n        return Vector{String}()\n\
    \    vowels = Set{String}(\"a\", \"e\", \"i\", \"o\", \"u\", \"y\");\n    return\
    \ select_words_helper(s, n, vowels, Set{String}())\nend\n\"\"\"\n    Given a string\
    \ s and a natural number n, you have been tasked to implement \n    a function\
    \ that returns a vector of all words from string s that contain exactly \n   \
    \ n consonants, in order these words appear in the string s.\n    If the string\
    \ s is empty then the function should return an empty vector.\n    Note: you may\
    \ assume the input string contains only letters and spaces.\n    Examples:\n \
    \   >>> select_words_helper(\"Mary had a little lamb\", 4)\n    [\"little\"]\n\
    \    >>> select_words_helper(\"Mary had a little lamb\", 3)\n    [\"Mary\", \"\
    lamb\"]\n    >>> select_words_helper(\"simple white space\", 2)\n    []\n    >>>\
    \ select_words_helper(\"Hello world\", 4)\n    [\"world\"]\n    >>> select_words_helper(\"\
    Uncle sam\", 3)\n    [\"Uncle\"]\n    \"\"\"", "    str = split(s, \" \") \n \
    \   ans = Vector{String}() \n    \n    for word in str do \n      i = 1 \n   \
    \   while i <= n do \n        if word[i] in \"aeiouAEIOU\" then break end\n  \
    \      i+=1\n      end \n      if i > n then \n        ans = append(ans, word)\
    \ \n      end\n    end \n    \n    return ans\nend \n</code>\n<|/ a tags=string,julia\
    \ |>\n<| a dscore=1 tags=string,julia |>\nHere is another solution that might\
    \ be easier to understand, perhaps easier to understand/maintain, though probably\
    \ not as fast as others:\n<code>", "    if s == \"\" \n        return Vector{String}()\
    \ \n    elseif n < 0\n        return [] \n    elseif n == 0\n        return [\"\
    s\"]\n    else\n        # first we need to determine what vowels we'll need to\
    \ use\n        consonants = string.ascii_lowercase[1 .. length(s) -1]\n      \
    \  vowels = string.ascii_lowercase[1 .. length(s) ]\n        \n        # then\
    \ we need a way to determine if each word contains exactly n vowels\n        function\
    \ contains_n_vowels(s::String, n::Int64)::Bool\n            vowel_counts = Map[Char,\
    \ Int64]() \n            for character in s \n                if character ==\
    \ character && character in vowels\n                    vowel_counts[character]\
    \ = vowel_counts[character] + 1 \n                else \n                    return\
    \ false \n                end \n            end \n            if vowel_counts[\"\
    a\"] >= n && vowel_counts[\"e\"] >= n && \n                vowel_counts[\"i\"\
    ] >= n && vowel_counts[\"o\"] >= n &&\n                vowel_counts[\"u\"] >=\
    \ n\n                \n                return true \n                else \n \
    \                   return false \n                end \n            end \n  \
    \          \n        end \n        \n        # now we need to go through each\
    \ word in the string\n        words = filter(contains_n_vowels, s)\n    \n   \
    \     # now we need to find all the words that contain n consonants \n       \
    \ selected_words = Vector{String}() \n        for word in words \n           \
    \ if contains_n_consonants(word, n) == true \n                push!(selected_words,\
    \ word) \n            end \n        end \n        return selected_words \n   \
    \ end \nend \n</cell>\n<text>\nTest your code\nRun the cell below to test your\
    \ code. The output of your code should match the example output.", "    \n   \
    \ return []\nend", "    \n    # Your code here\n    return \"\"\nend\n</cell>\n\
    <code language=julia-1.5>\n# run this cell to check your answer\n@time select_words(\"\
    Mary had a little lamb\", 4)\n</cell>\n<text>\n(extra) Task\nThe objective of\
    \ this exercise is to test whether a given string is a palindrome or not. Palindromes\
    \ are strings that read the same backward as forward, e.g. \"abba\" is a palindrome.",
  "    \n    return []\nend", "    words = collect(split(s))\n    words_with_n_consonants\
    \ = filter(word -> count(consonants(word))==n, words)\n    words_with_n_consonants\
    \ = sort(words_with_n_consonants)\n    words_with_n_consonants\nend", "    ans\
    \ = Vector{String}()\n    for i in s\n        if length(i)>=n\n            push!(ans,i)\n\
    \        end\n    end\n    return ans\nend\n</code>\nBut I get the following error:\n\
    <code>\njulia> select_words(\"Mary had a little lamb\", 4)\nERROR: LoadError:\
    \ MethodError: no method matching length(::String)\nClosest candidates are:\n\
    \  length(::Type{<:AbstractString})(::Any) at io.jl:724\nStacktrace:\n [1] top-level\
    \ scope at none:0\n</code>\nI believe the error is caused by the fact that in\
    \ the first line of the function I have:\n<code>\nans = Vector{String}()\n</code>\n\
    I am unsure why I should use typeof() here since the type is already specified\
    \ as Vector{String}. Could someone help me out?\n<|/ q tags=julia |>\n<| c |>\n\
    If you want `ans` to be a vector with type `Vector{String}`, then you also need\
    \ `push!(ans, i)` and not `push!(ans, length(i))`.\n<|/ c |>\n<| c |>\nI used\
    \ `push!(ans, i)` and the error does not appear, but `ans` is still a String and\
    \ if I try to access `ans[1]` I get the error `ERROR: UndefRefError: access to\
    \ undefined reference`.\n<|/ c |>\n<| c |>\n`ans` is defined as a vector, but\
    \ you have not defined a vector.\n<|/ c |>\n<| c |>\nI edited my question to make\
    \ it more clear about what I am aiming for.\n<|/ c |>\n<| c |>\nYou are still\
    \ missing definitions for `select_words`, `my_words`, and `count_letters`. Please\
    \ post the entire code that you would like to have working.\n<|/ c |>\n<| a dscore=3\
    \ |>\nYou have to define ans before using it.\nA Vector is a type. For example,\n\
    <code>\njulia> typeof([1, 2, 3])\nInt64\n</code>\nis no different from:\n<code>\n\
    julia> typeof(Vector([1, 2, 3]))\nVector{Int64}\n</code>\nTo define ans as an\
    \ empty vector, you should write:\n<code>\nans = Vector{String}()\n</code>\n<|/\
    \ a tags=julia |>\n<| c |>\nI changed it to `ans = Vector{String}()` and I do\
    \ not get the error message anymore, but `ans` is still a String and if I try\
    \ to access `ans[1]` I get the error `ERROR: UndefRefError: access to undefined\
    \ reference`.\n<|/", "    if s == \"\"\n        Vector{String}()\n    else\n \
    \       select_words(s[1..end-1], n-1)\n    end\nend", "    \"\"\"\n    Implement\
    \ a function that takes a string and a natural number n \n    and returns a vector\
    \ of strings that contain exactly n consonants, in \n    order these words appear\
    \ in the string s.\n    Note: you may assume the input string contains only letters\
    \ and spaces.\n    \"\"\"\n    return Vector{String}()\nend\n</cell>\n<code language=julia-0.5>\n\
    select_words(\"Mary had a little lamb\", 4)\n</cell>\n<code language=julia-0.5>\n\
    select_words(\"Mary had a little lamb\", 3)\n</cell>\n<code language=julia-0.5>\n\
    select_words(\"simple white space\", 2)\n</cell>\n<code language=julia-0.5>\n\
    select_words(\"Hello world\", 4)\n</cell>\n<code language=julia-0.5>\nselect_words(\"\
    Uncle sam\", 3)\n</cell>\n<text>\nTask 4: Words\nTask: Implement a function words()\
    \ that accepts a vector of words and returns \na vector of the same length as\
    \ the input vector with the first element of \neach sublist consisting of the\
    \ number of words in the sublist.\nExamples:\n>>> words([[\"hello\", \"world\"\
    ], [\"and\", \"goodbye\"], [\"and\", \"happy\", \"day\"]])\n[2, 1, 3]\n>>> words([[\"\
    and\", \"goodbye\"], [\"and\", \"happy\", \"day\"], [\"hello\", \"world\"]])\n\
    [2, 3, 1]\n>>>\nTask: Implement a function words_count(words) that returns the\
    \ number of \ntimes each word in words is repeated as a sublist in words.\nExamples:\n\
    >>> words_count([[\"and\", \"goodbye\"], [\"and\", \"happy\", \"day\"], [\"hello\"\
    , \"world\"]])\n[2, 1, 3]\n>>> words_count([[\"and\", \"goodbye\"], [\"and\",\
    \ \"happy\", \"day\"]])\n[1, 3, 0]\n>>> words_count([\"hello\"])\n[0, 0]\n>>>\
    \ words_count([\"hello\", \"world\"])\n[1, 0, 0]\n\"\"\"", "    if s == \"\"\n\
    \        []\n    else\n        words_from_string(s, n).map(word => word[..n])\n\
    \    end\nend\n</cell>\n<cell>\n#export", "  return([])\nend\n</cell>\n<text>\n\
    Exercise 3: Implement the function count_words that counts the number of words\
    \ in a string.\nThe function should take a string and a natural number n as inputs\
    \ and return a natural number.\nIt should only count the occurrence of words in\
    \ the string.\nExamples:\ncount_words(\"\", 0) should return 0\ncount_words(\"\
    Mary had a little lamb\", 4) should return 3\ncount_words(\"Hello world\", 4)\
    \ should return 1\ncount_words(\"Mary had a little lamb\", 7) should return 1\n\
    count_words(\"Hello world\", 4) should return 1\ncount_words(\"Simple text with\
    \ words\", 4) should return 5\ncount_words(\"simple white space\", 2) should return\
    \ 3\ncount_words(\"simple white space\", 3) should return 3\ncount_words(\"simple\
    \ white space\", 4) should return 3\ncount_words(\"Uncle sam\", 3) should return\
    \ 2\ncount_words(\"Uncle sam\", 4) should return 2\ncount_words(\"Uncle sam\"\
    , 5) should return 2\ncount_words(\"Uncle sam\", 6) should return 2\ncount_words(\"\
    Uncle sam\", 7) should return 2\ncount_words(\"Uncle sam\", 8) should return 2\n\
    count_words(\"Uncle sam\", 9) should return 2\ncount_words(\"Uncle sam\", 10)\
    \ should return 2\ncount_words(\"Uncle sam\", 11) should return 2\ncount_words(\"\
    Uncle sam\", 12) should return 2\ncount_words(\"Uncle sam\", 13) should return\
    \ 2\ncount_words(\"Uncle sam\", 14) should return 2\ncount_words(\"Uncle sam\"\
    , 15) should return 2\ncount_words(\"Uncle sam\", 16) should return 2\ncount_words(\"\
    Uncle sam\", 17) should return 2\ncount_words(\"Uncle sam\", 18) should return\
    \ 2\ncount_words(\"Uncle sam\", 19) should return 2\ncount_words(\"Uncle sam\"\
    , 20) should return 2\ncount_words(\"Uncle sam\", 21) should return 2\ncount_words(\"\
    Uncle sam\", 22) should return 2\ncount_words(\"Uncle sam\", 23) should return\
    \ 2\ncount_words(\"Uncle sam\", 24) should return 2\ncount_words(\"Uncle sam\"\
    , 25) should return 2\ncount_words(\"Uncle sam\", 26) should return 2\ncount_words(\"\
    Uncle sam\", 27) should return 2\ncount_words(\"Uncle sam\", 28) should return\
    \ 2\ncount_words(\"Uncle sam\", 29) should return 2\ncount_word", "    # write\
    \ your code in Ruby\n    words = String[]\n    i = 0\n    while i <= length(s)\
    \ - n + 1\n        if s[i:i+n] == \" \"\n            push!(words, s[i .. i + n])\n\
    \        end\n        i += 1\n    end\n    return words\nend\n</cell>\n<text>\n\
    Let's test your implementation:", "    if s == \"\"\n    return Vector{String}\n\
    \    else\n        vowels = \"AEIOU\"\n        letters = unique(s:gsub(\"[^A-Za-z0-9]\"\
    , \"\"))\n        letter_counts = Dict()\n        for l in letters\n         \
    \   if !contains(vowels, l) && l not in letter_counts\n                letter_counts[l]\
    \ = 0 \n            end\n        end\n        \n        word_counts = Dict()\n\
    \        word_freqs = Dict()\n        for l in letters\n            letter_counts[l]\
    \ += 1\n            if letter_counts[l] == n\n                word_counts[l] +=\
    \ 1\n            end\n        end\n        \n        words = []\n        for word\
    \ in word_counts\n            if word_counts[word] == n\n                push!(words,\
    \ word)\n            end\n        end\n        for word in words\n           \
    \ push!(word_freqs[word], letter_counts[word])\n        end\n        \n      \
    \  wordfreqs = Dict()\n        for word in words\n            wordfreqs[word]\
    \ = sum(word_freqs[word])\n        end\n        \n        word_ranks = Dict{String,\
    \ Int64}()\n        for word in words\n            word_ranks[word] = rand(word_freqs[word])\
    \ + 1\n        end\n        \n        ranked_words = vcat(word_ranks, wordfreqs)\n\
    \        ranks = sort(collect(ranked_words))\n        ranks = ranks[end:-1:1]\n\
    \        \n        ranks = reverse(ranks)\n        \n        word_ranks = vcat(ranks,\
    \ word_ranks)\n        word_ranks = sort(word_ranks)\n        \n        word_ranks\
    \ = reverse(word_ranks)\n        \n        ranks = collect(word_ranks)\n     \
    \   \n        ranks = ranks[end:-1:1]\n        \n        ranks = reverse(ranks)\n\
    \        \n        selected_words = vcat(ranks, words)\n        selected_words\
    \ = sort(selected_words)\n        \n        return selected_words\n    end\nend",
  "    \n    if s isa String and n > 0\n        n = n - 1\n        words = \"\"\n\
    \        for letter in s\n            if letter in [\"a\", \"e\", \"i\", \"o\"\
    , \"u\"]\n                if n == 0\n                    break\n             \
    \   else\n                    words += letter\n                    n -= 1\n  \
    \          else\n                words += letter\n        end\n        push!(words,\
    \ s)\n        return words\n    else\n        return []\n    end\nend", "    return\
    \ [] #TODO\nend", "    \n    function check_len(s::String, n::Int64)::Int64\n\
    \        if s.length < n\n            error(\"Not enough letters found in string\"\
    )\n        elseif s.length == n\n            return 1\n        else\n        \
    \    return check_len(s[1..end], n)\n        end\n    end", "    \nend\n</cell>\n\
    <text>\nQuestion 5\nImplement the function count_vowels which takes in a vector\
    \ of strings and returns the number of vowels in each string.", "    \n    return\
    \ select_words_rec(s,n,[])\nend\n</cell>\n<text>\nExercise 7", "    \n    if s\
    \ == \"\"\n        return []\n    \n    if n == 0\n        return [s]\n    \n\
    \    letters = split(s)\n    \n    count = 0\n    \n    for i in letters\n   \
    \     count += length(consonant_count(i))\n    \n    if count == n\n        \n\
    \        words = collect(letters)\n        \n        unique = unique(words)\n\
    \        \n        ans = []\n        \n        for j in unique\n            if\
    \ length(consonant_count(j)) == n\n                push!(ans, j)\n           \
    \ end\n        end\n        \n        return ans\n    end\n    \n    return []\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nAs I understand, you have a\
    \ string s containing letters from all languages. Your task is to find all words\
    \ in that string that have exactly n consonants. So that means, you need to define\
    \ some rules for words. In your case rules for letters are simple, but you might\
    \ need to define rules for other languages. \nFirst of all you need to define\
    \ some rules for languages, for example, for English letters you might have:",
  "    if s == \"\"\n    \n    return [] \n    else\n    if n == 0\n    \n       \
    \ return [] \n    else\n        ", "    if n == 0 then \n        return []\n \
    \   elseif n == 1 then \n        return filter(x -> x == s, split(s))\n    elseif\
    \ n > 1 then \n        return setdiff(union(select_words(s, n-1), select_words(s,\
    \ n-2)), s)\n    else \n        return []\n    end\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\nBased off of other answers I created this solution (I feel it looks\
    \ nicer now):\n<code>", "</code>\n<|/ q dscore=0 |>\n<| a |>\nI am not sure what\
    \ your question is, but I believe this is what you need:\n<code>", "    \n   \
    \ \"\"\"\n    Your code here\n    \"\"\"\n    return []\nend", "    if n == 0\
    \ || s == \"\" then return [] end\n    return filter(x->((x==s) && (isvowel(x)),\
    \ split(s))\nend\n</cell>\n<cell>\nselect_words(\"Mary had a little lamb\", 3)\n\
    </cell>\n<text>\nQuestion 2\nWrite a function that takes as input a word and two\
    \ vectors dict1 and dict2, and returns the index of the dictionary that matches\
    \ the first letter of the word.\nThe matching must be case insensitive, so the\
    \ function should also return an optional return vector that contains the index\
    \ of the dictionary. \nIf no dictionary contains the first letter of the word\
    \ then the function should return nothing or an empty vector\nExamples:\n>>> get_dict(\"\
    Hello\", dict1, dict2)\n([4], [])\n>>> get_dict(\"Uncle Sam\", dict1, dict2)\n\
    ([3], [])\n>>> get_dict(\"Mary had a little lamb\", dict1, dict2)\n([4], [])\n\
    >>> get_dict(\"Hello world\", dict1, dict2)\n([], [])\n>>> get_dict(\"Uncle sam\"\
    , dict1, dict2)\n([], [])\n>>> get_dict(\"Mary\", dict1, dict2)\n([], [])\n>>>\
    \ get_dict(\"hello\", dict1, dict2)\n([], [])\n>>> get_dict(\"Uncle\", dict1,\
    \ dict2)\n([], [])\n</text>", "    # Your code goes here\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@test select_words(\"Mary had a little lamb\", 4) == [\"\
    little\"]\n</cell>\n<code language=julia-1.5>\n@test select_words(\"Mary had a\
    \ little lamb\", 3) == [\"Mary\", \"lamb\"]\n</cell>\n<code language=julia-1.5>\n\
    @test select_words(\"simple white space\", 2) == []\n</cell>\n<code language=julia-1.5>\n\
    @test select_words(\"Hello world\", 4) == [\"world\"]\n</cell>\n<code language=julia-1.5>\n\
    @test select_words(\"Uncle sam\", 3) == [\"Uncle\"]\n</cell>\n<text>\nTask 2.3\n\
    Write a function filter_words_containing_letters which takes a string and returns\
    \ a vector\ncontaining all words that contain exactly one letter. For example,\
    \ given a string s containing\nthe string \"aardvark\" and the letter \"a\", this\
    \ function should return [\"aardvark\"].\nWrite a function filter_words_containing_letters_2\
    \ which takes a string s and a natural number\nn, you have been tasked to implement\
    \ a function that returns a vector of all words\ncontaining exactly n letters,\
    \ in order these words appear in the string s. \nIf the string s is empty then\
    \ the function should return an empty vector. \nExamples:\n    >>> filter_words_containing_letters(\"\
    Mary had a little lamb\", 4)\n    [\"aardvark\"]\n    >>> filter_words_containing_letters(\"\
    Mary had a little lamb\", 3)\n    [\"Mary\", \"little\", \"lamb\"]\n    >>> filter_words_containing_letters(\"\
    simple white space\", 2)\n    []\n    >>> filter_words_containing_letters(\"Hello\
    \ world\", 4)\n    []\n    >>> filter_words_containing_letters(\"Uncle sam\",\
    \ 3)\n    []\n    \"\"\"", "    if n == 1 \n        return [s]\n    if n == 0\
    \ \n        return []\n    if isspace(s) \n        return select_words(s, 1)\n\
    \    words = split(s)\n    letters = split(s)\n    lettersFound = falses(length(letters))\n\
    \    for i in 1:length(letters) \n        if contains(letters[i], \"aeiou\") \n\
    \            lettersFound[i] = true\n        end\n    end\n    wordsInOrder =\
    \ words[find(lettersFound)]\n    if length(wordsInOrder) == 1 \n        return\
    \ select_words(wordsInOrder, 1)\n    else\n        return select_words(wordsInOrder,\
    \ n-1)\n    end\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\nHere is my solution:\n\
    <code>", "    return \"\"\nend", "    word_list = []\n    \n    if s == \"\"\n\
    \        return word_list\n    \n    if n == 0\n        return word_list\n   \
    \ \n    for word in all_words(s)\n        if n == length(word)\n            push!(word_list,\
    \ word)\n        end\n    end\n    return word_list\nend\n</cell>\n<code language=julia-0.6>\n\
    s = \"\"\"Mary had a little lamb\"\"\"\nselect_words(s, 4)\n</cell>\n<code language=julia-0.6>\n\
    s = \"\"\"Mary had a little lamb\"\"\"\nselect_words(s, 3)\n</cell>\n<code language=julia-0.6>\n\
    s = \"\"\"simple white space\"\"\"\nselect_words(s, 2)\n</cell>\n<code language=julia-0.6>\n\
    s = \"\"\"Hello world\"\"\"\nselect_words(s, 4)\n</cell>\n<code language=julia-0.6>\n\
    s = \"\"\"Uncle sam\"\"\"\nselect_words(s, 3)\n</cell>\n<text>\nQuestion 3\nImplement\
    \ the function count_consonants(s::String) which returns a dictionary containing\
    \ the number of times a \nconsonant appears in s in lexicographical order.\nExamples:\n\
    \    >>> count_consonants(\"Mary had a little lamb\")\n    (3:3)\n    >>> count_consonants(\"\
    Hello world\")\n    (2:1)\n    >>> count_consonants(\"Uncle sam\")\n    (1:2)\n\
    \    >>> count_consonants(\"Mary had a little lamb\")\n    (3:3)\n    >>> count_consonants(\"\
    Mary had a little lamb\")\n    (3:3)\n    >>> count_consonants(\"Mary had a little\
    \ lamb\")\n    (3:3)\n    >>> count_consonants(\"Mary had a little lamb\")\n \
    \   (3:3)\n    \"\"\"", "    if s == \"\"\n    else select_words(s, n - 1) ++\
    \ select_words(s, n)\nend\n</code>\nAs the algorithm is relatively simple, we\
    \ do not use any for loop, but use recursion.\n<|/ a dscore=0 |>\n<| c |>\nIt\
    \ would be helpful to explain why your code works and why it doesn't.\n<|/ c |>\n\
    <| c |>\nThis will not work for \"HelloWorld\", it should return an empty list\
    \ instead.\n<|/ c |>\n<| c |>\nYou don't need to define `select_words` twice,\
    \ just inline the definition of `select_words`. And you don't need to do `== \"\
    \"` in a separate conditional. Also, you can just write `\"\"` instead of `\"\
    \ \"`.\n<|/ c |>\n<| c |>\nIt does not need to do `== \"\"` in a separate conditional\
    \ because it does not care about the second argument. If you define it this way\
    \ then it is easy to see why it does not work on the second example I gave.\n\
    <|/ c |>\n<| c |>\nSure, I understand that. I meant that you don't need to do\
    \ `s == \"\"` in a separate conditional. You're not comparing anything, just checking\
    \ whether `s` is empty or not. `\"\"` is an empty string, just like `\" \"` is\
    \ an empty string. Similarly, `\" \"` will be true for `\" \"` even if `s == \"\
    \"` is false.\n<|/ c |>\n<| a |>\nHere's another solution that doesn't use recursion\n\
    <code>", " \n    # Your code here\n    \nend\n</cell>\n<code language=julia-1.5>\n\
    @assert select_words(\"Mary had a little lamb\", 4) == [\"little\"]\n@assert select_words(\"\
    Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"]\n@assert select_words(\"\
    simple white space\", 2) == []\n@assert select_words(\"Hello world\", 4) == [\"\
    world\"]\n@assert select_words(\"Uncle sam\", 3) == [\"Uncle\"]\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that will generate all possible n-grams of length\
    \ at least 2\nfrom a given string s:", "    if n == 0\n        return Vector{String}()\n\
    \    \n    selected_words::Vector{String} = []\n    \n    for word in words\n\
    \        if count(word) == n\n            selected_words.push(word)\n        end\n\
    \    end\n    return selected_words\nend\n</cell>\n<text>\nLet's test our function\
    \ by checking the size of the resulting vector selected_words:", "    return []\n\
    end\n</cell>\n<code language=julia-1.5>\n@test select_words(\"Mary had a little\
    \ lamb\", 4) == [\"little\"]\n</cell>\n<text>\nTask 2\nWrite a function that returns\
    \ the number of words in your input string. \n    Examples:\n    >>> count_words(\"\
    Hello world\")\n    3\n    >>> count_words(\"simple white space\")\n    0\n  \
    \  \"\"\"", '"""', "  word_set = Set[String]()\n  if s == \"\"\n    return Vector[]\n\
    \  else\n    char_set = Set[Char]()\n    for c in s\n      if c not in char_set\n\
    \        push!(word_set, c)\n        push!(char_set,c)\n      end\n    end\n \
    \   \n    res = []\n    for word in word_set\n      if n<=length($word)\n    \
    \    push!(res, word)\n      end\n    end\n    return res\n  end\nend\n</cell>\n\
    <code language=julia-1.6>\nselect_words(\"Hello world\", 2)\n</cell>\n<text>\n\
    Task 3\nWrite a function count_letters(s, n) which takes in a string s and a natural\
    \ number n and returns the number of letters in the string. \nIf the string s\
    \ is empty then it should return 0.\nIf the string s contains less than n letters\
    \ then it should return 0.\nThe letters are case sensitive.\nExamples:\ncount_letters(\"\
    Mary had a little lamb\", 4)\n12\ncount_letters(\"Hello world\", 4)\n4\ncount_letters(\"\
    Hello world\", 0)\n0\ncount_letters(\"\", 6)\n0\ncount_letters(\"Mary had a little\
    \ lamb\", 6)\n9", "    \n    \"\"\"\n    Your task is to implement the function\
    \ select_words as shown in the docstring. \n    \"\"\"\nend\n</cell>\n<code language=julia-1.4>",
  "    select_words_helper(s, n, [])\nend", "    \n    \n    #\n    # your solution\
    \ is here\n    #\n    \n    \n    \n    return ", "    \n    letters=split(s)\n\
    \    vec=Array{String}(undef,0)\n    count=0\n    \n    for word in letters \n\
    \        count=count+1\n        if count(word)==n\n            push!(vec,word)\n\
    \        end\n    end", "    #raise Exception(\"Not implemented yet\")\nend\n\
    </cell>\n<text>\nPart II: Finding the most common words\nIn this section of the\
    \ lab you will write code to find the words that appear \nthe most in a given\
    \ text and also the most common words.", "    \n    \n    if n == 0 || s == \"\
    \"\n        return []\n    \n    select_words_helper(s, n)\nend", "    \n    return\
    \ [] \nend", "  \n  words = \"\"\n  \n  if s == \"\"\n    words\n  else\n    \n\
    \    # Split string into words\n    split_string = split(s)\n    \n    # Find\
    \ number of consonants in words\n    n_consonants = count(split_string)\n    \n\
    \    # If number of consonants in words is exactly n, return that words\n    if\
    \ n_consonants == n\n      words\n    # Otherwise, return words that contain the\
    \ number of consonants exactly n\n    else\n      \n      # For each word in split_string\n\
    \      for i in split_string\n        # Check for consonants in word\n       \
    \ if count(i) == n\n          # Append to words string\n          words += i\n\
    \        end\n      end\n    end\n  end\nend\n</code>\n<|/ a dscore=2 tags=string,julia,split\
    \ |>\n<| a |>\nIf you have the strings package installed, the following function\
    \ should work:\n<code>", "    \n    if n < 0\n        return [];\n    \n    if\
    \ length(s)==0\n        return [];\n    \n    words= split(s, \" \");\n    \n\
    \    res= Vector{String}(undef, length(words));\n    \n    for w in words\n  \
    \      if length(w) == n && isfinite(length(find(collect(w)) )) \n           \
    \ push!(res, w);\n        end\n    end\n    \n    return res;\nend\n</cell>\n\
    <text>\nProblem 7 - Searching a Vector for Elements\nLet's now implement a function\
    \ that searches a vector for a given element and returns a\nvector of indexes\
    \ of such elements.\nYou should write a function named search_in_vector that takes\
    \ an vector v and an element e and returns a vector whose ith element is the index\
    \ of element v[i] in v.\nIf you do not know how to implement search_in_vector,\
    \ you are welcome to find an implementation on the web.", "    \n    word_array\
    \ = Array.new()\n    \n    for word in split(s)\n        if count(word) == n\n\
    \            word_array += word\n        end\n    end", "    if (s == \"\")\n\
    \        return Vector{String}()\n    \n    \n    if (n == 1)\n        return\
    \ [s]\n    \n    \n    \n    \n    if (n > length(s))\n        n=length(s)\n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n", "    if s == \"\" then return []\n    \n    if n <= length(s)\
    \ then return [] end\n    \n    vowels = \"aeiouAEIOU\"\n    letters = s[1..end]\n\
    \    vowel_letters = letters.split(vowels)\n    \n    return filter(x -> length(x)\
    \ == n, vowel_letters)\nend", "    # Your code here\n    return []\nend", "  \
    \  \"\"\"\n    Implement your solution here.\n    \"\"\"\n</code>\n<|/ a |>\n\
    <| c |>\n`select_words(s, n)` should return an empty vector when `s` == ''. Can\
    \ you fix that? It also should probably return an empty vector when `s == n`.\n\
    <|/ c |>\n<| c |>\nThe `select_words` function must return a vector of all words\
    \ from string s that contain exactly `n` consonants, in order these words appear\
    \ in the string `s`.", "    \"\"\"\n    Implement this function\n    \"\"\"\n\
    \    return Vector{String}()\nend\n</cell>\n<code language=julia-0.6>", "    #\
    \ Complete this function\n    return []\nend", "    vec = Vector{String}()\n \
    \   for w in w \n        push!(vec,w) \n        if length(vec) == n \n       \
    \     return vec\n        end\n    end\n    return vec\nend\n</cell>\n<text>\n\
    Solution\nRun the cell below to test your implementation.", "    words = split_words(s)\n\
    \    i = 0\n    while i < length(words) do \n        if length(select_word(words[i],\
    \ n)) > 0\n            push!(words, select_word(words[i], n))\n        end\n \
    \       i = i + 1\n    end\n    return words\nend", "    \n    \n    return []\n\
    end", "    if s == \"\" \n        []\n    else\n        words = split(s)\n   \
    \     selected_words = []\n        \n        for word in words\n            if\
    \ n <= length(word) && count(word) == n\n                push!(selected_words,\
    \ word)\n            end\n        end", "    if !s \n        return Vector{String}()\n\
    \    \n    words = split(s, \" \")\n    for word in words \n        if contains_n(word,\
    \ n) \n            return words\n    return words\nend\n</cell>\n<code language=julia-1.3>",
  "     \n    s = lowercase(s) # Convert string to lowercase\n    words = split(s)\
    \ # Split the string into a vector of strings\n    return filter(x->count(x)==n,\
    \ words) # Return words where count of chars = n\nend", "    if s.length() ==\
    \ 0\n        return Vector{String}()\n    ends = select_words(s, 0)\n    begins\
    \ = select_words(s, 1)\n    \n    if length(ends) == 0 || length(begins) == 0\
    \ || length(begins) >= length(ends)\n        return ends\n    ends = remove_duplicates(ends)\n\
    \    begins = remove_duplicates(begins)", "    if n == 0\n        []\n    elseif\
    \ n == 1\n        select_word(s,1)\n    else\n        select_words(s, n-2).append(select_word(s,n-1))\n\
    \    end\nend\n</cell>\n<code language=julia-1.0>\nselect_words(\"Mary had a little\
    \ lamb\", 4)\n</cell>\n<text>\nGreat! Now we know how to implement a recursive\
    \ function! Now let's see if we can solve the original problem:", "\"\"\"\n##\
    \ Solution ##\n\"\"\"\n\"\"\"", "    \"\"\"\n    Given a string s and a natural\
    \ number n, you have been tasked to implement \n    a function that returns a\
    \ vector of all words from string s that contain exactly \n    n consonants, in\
    \ order these words appear in the string s.\n    If the string s is empty then\
    \ the function should return an empty vector.\n    Note: you may assume the input\
    \ string contains only letters and spaces.\n    Examples:\n    >>> select_words(\"\
    Mary had a little lamb\", 4)\n    [\"little\"]\n    >>> select_words(\"Mary had\
    \ a little lamb\", 3)\n    [\"Mary\", \"lamb\"]\n    >>> select_words(\"simple\
    \ white space\", 2)\n    []\n    >>> select_words(\"Hello world\", 4)\n    [\"\
    world\"]\n    >>> select_words(\"Uncle sam\", 3)\n    [\"Uncle\"]\n    \"\"\"\n\
    \    if n < 0\n        return []\n    \n    \n    \n    return \n</cell>\n<text>\n\
    Question 3\nUse select_words to find which words in word_list occur more than\
    \ 50% of the time. Then, print the 10 (arbitrarily) words that occur more than\
    \ 50% of the time.", "    ans = Vector{String}()\n    \n    # your code goes here\n\
    \    \nend\n</cell>\n<text>\nSolution notebook\nClick here to access the solution.",
  "    if s.length == 0\n        return Vector{String}()\n    \n    select_words_aux(s,\
    \ n, Vector{String}())\nend", "    \"\"\"\n    Create a function which given a\
    \ string s and a natural number n, returns \n    a vector of all words from string\
    \ s that contain exactly n consonants in \n    order these words appear in the\
    \ string s.\n    \"\"\"\n    return filter(elem => elem == ncons(s)==n, split(s))",
  "    \n    \n    \"\"\"\n    # Practice implementing select_words. \n    # You can\
    \ choose the name you like.\n    \"\"\"\n    \n    \n    \"\"\"\n    return []\n\
    \    \nend", "    ans = []\n    \n    if s == \"\" \n        ans\n    else\n \
    \       for i in 1:length(s) do \n            if substr(s[i],i,n) == substring(reverse(s),i,n)\
    \ \n                push!(ans, s[length(s):i])\n            end \n        end\
    \ \n    end \nend \n</code>\n<|/ a dscore=1 |>\n<| c |>\nPlease don't post only\
    \ code as answer, but also provide an explanation what your code does and how\
    \ it solves the problem of the question. Answers with an explanation are usually\
    \ more helpful and of better quality, and are more likely to attract upvotes.\n\
    <|/ c |>\n<| c |>\nThe original question (before I edited) was asking for a solution\
    \ to the code I posted above. My question was specifically asking for some help\
    \ in making the code I have posted.\n<|/ c |>\n<| c |>\nThank you for your help\
    \ but your solution is incorrect for cases like \"Mary had a little lamb\". What\
    \ you have provided still returns the string: \"Mary had a little\"\n<|/ c |>\n\
    <| a tags=string,r,algorithm dscore=1 |>\nHere's a recursive version, but it's\
    \ not as efficient.  It should work for your case.\n<code>\nwords <- function(s,\
    \ n) {\n  res <- c()\n  n <- n - 1\n  if (n == 0)\n    return(res)\n  for (i in\
    \ 1:length(s))\n    if (substr(s[i],i,n) == substring(reverse(s),i,n))\n     \
    \ res <- c(res, s[i])\n    else break\n  words(s, n)\n  res\n}", "    \n    if\
    \ length(s)==0 || n==0\n        return \n    \n    vec=Vector{String}()\n    \n\
    \    for word in words\n        if length(word)==n || n==1\n            push!(vec,\
    \ word)\n        end\n    end\n    \n    return vec\nend\n</cell>\n<text>\nNotice\
    \ that in the above solution, the only variable in the recursive call that really\
    \ needs to change is the current character being checked.", "    \n    let mut\
    \ words = Vec::new()\n    if s == \"\"\n    else for i in s.split() do \n    \
    \  if i.to_lowercase().contains(&\"a..zA..Z\")\n      else if i.to_lowercase().contains(&\"\
    A..ZA..Z\")\n      else if i.to_lowercase().contains(&\"0..9\")\n      else if\
    \ i.to_lowercase().contains(&\"A..ZA..Z0..9\")\n      else if i.to_lowercase().contains(&\"\
    aA..zA..zA..zA..zA..zA..zA..zA..\")\n      else if i.to_lowercase().contains(&\"\
    aA..zA..zA..zA..zA..zA..zA..zA..zA..\")\n      else if i.to_lowercase().contains(&\"\
    A..ZA..Z0..9\")\n      else if i.to_lowercase().contains(&\"A..ZA..ZA..zA..zA..zA..zA..zA..\"\
    )\n      else if i.to_lowercase().contains(&\"A..ZA..ZA..zA..zA..zA..zA..zA..\"\
    )\n      else if i.to_lowercase().contains(&\"A..ZA..ZA..zA..zA..zA..zA..zA..\"\
    )\n      else if i.to_lowercase().contains(&\"A..ZA..ZA..zA..zA..zA..zA..zA..\"\
    )\n      else if i.to_lowercase().contains(&\"A..ZA..ZA..zA..zA..zA..zA..zA..\"\
    )\n      else if i.to_lowercase().contains(&\"A..ZA..ZA..zA..zA..zA..zA..zA..\"\
    )\n      else if i.to_lowercase().contains(&\"A..ZA..ZA..zA..zA..zA..zA..zA..\"\
    )\n      else if i.to_lowercase().contains(&\"A..ZA..ZA..zA..zA..zA..zA..zA..\"\
    )\n      else if i.to_lowercase().contains(&\"A..ZA..ZA..zA..zA..zA..zA..zA..\"\
    )\n      else if i.to_lowercase().contains(&\"A..ZA..ZA..zA..z", "    if s ==\
    \ \"\"\n        return empty()\n    else\n        result = []\n        for i in\
    \ 1:length(s)\n            letter = s[i]\n            if letter in \"aeiouAEIOU\"\
    \n                if isupper(letter)\n                    if n < length(letter)\n\
    \                        result += select_words(s[begin:i], n-1)\n           \
    \             n -= 1\n                    else\n                        result\
    \ += select_words(s[begin:i], n)\n                    end\n                else\n\
    \                    if n < length(letter)\n                        result +=\
    \ select_words(s[begin:i], n-1)\n                        n -= 1\n            \
    \        else\n                        result += select_words(s[begin:i], n)\n\
    \                    end\n                end\n            else\n            \
    \    if n == length(letter)\n                    result += select_words(s[begin:i],\
    \ n-1)\n                else\n                    result += select_words(s[begin:i],\
    \ n)\n                end\n            end\n        end\n        return result\n\
    \    end\nend\n</cell>\n<text>\nRun the cell below to check your answer", "  \
    \  # Your code here\n</code>\n<|/ a tags=string,arrays,julia dscore=2 |>\n<| c\
    \ |>\n`strsplit` splits at any whitespace, not just spaces.\n<|/ c |>\n<| c |>\n\
    oh yes, I was confused between `split ; strsplit ; strsplit` ... Thank you for\
    \ noticing :)\n<|/ c |>\n<| a dscore=2 tags=string,arrays,julia |>\nMy favorite\
    \ Julia solution would be to use regular expressions:\n<code>", "    \nend\n</cell>\n\
    <text>\nProblem 4\nWrite a function that returns a vector of all words from string\
    \ s that contain exactly n vowels, in order these words appear in the string s.\n\
    If the string s is empty then the function should return an empty vector.\nNotes:",
  "    \nend\n</cell>\n<text>\nPart III. Words containing less than n consonants ",
  "    if is_empty(s)\n        \n    else\n        \n        \n    else\n        ",
  "    \n    for w \u2208 words(s) \n        if contains(w, consonants(n))\n     \
    \       return w \n    end\n    return []\nend", "    if length(s) < 1\n     \
    \   []\n    else\n        vowels = \"AEIOUaeiou\"\n        select_words_aux(s,\
    \ n, vowels)\n    end\nend", '    ', "    if s == \"\"\n        return Vector{String}()\n\
    \    else\n        select_words(s, n, \"\", \"\")\n    end\nend\n</code>\n<|/\
    \ a dscore=1 tags=string,recursion,algorithm,clojure |>\n<| c |>\nThank you. I'll\
    \ try it out. I think I will first need to understand the code, because I'm not\
    \ sure I understand it, and I don't even know where to start because I don't understand\
    \ Clojure. I'm going to be using this exercise as a mentor, and I'd hate to have\
    \ to have to get someone else to do it for me. :) Anyway, thank you.\n<|/ c |>\n\
    <| c |>\nNo problem. If you need a quick mentor for some particular language (for\
    \ example Clojure), you can always ask here: http://www.reddit.com/r/clojure/\n\
    <|/ c |>\n<| a dscore=1 |>\nHere's a solution that avoids mutable state:\n<code>\n\
    (defn has-at-least-n [s n]\n  (let [chars (clojure.string/split s #\"[^a-zA-Z]\"\
    )]\n    (filter #(= 0 (count %)) (filter #(= n (count %)) chars))))\n</code>\n\
    It splits the input string into a list of all character sets (excluding non-letters)\
    \ and then filters that list for the number of consonants. A more efficient version\
    \ could count the number of consonants already seen and skip the character set\
    \ if it reaches the required length.\n<|/ a tags=string,recursion,algorithm,clojure\
    \ |>\n<| a dscore=0 |>\nYou can use a mutable state with a ref and an if-else:\n\
    <code>\n(defn has-at-least-n [s n]\n  (let [s (ref s)]\n    (loop [s s n n\n \
    \          chars (clojure.string/split (.getValue s) #\"[^a-zA-Z]\")]\n      (if\
    \ (.contains chars (.getValue s))\n        (do (print (.getValue s)) (recur (.setValue\
    \ s (.getValue s))\n                                 (.- (.getValue s) (.getValue\
    \ s))\n                                 (.- (.length chars) n))))))\n</code>\n\
    <|/ a tags=string,recursion,algorithm,clojure |>\n<| a tags=string,recursion,algorithm,clojure\
    \ |>\nHere's a short function that will do what you want.\n<code>\n(defn has-at-least-n\n\
    \  [s n]\n  (if-let [s (clojure.string/split s #\"[^a-zA-Z]\")]\n    (let [[w\
    \ _] (filter #(= 0 (count %)) (filter #", "    \n    \"\"\"\n    Write your code\
    \ here!\n    \"\"\"\n    \n    \n    \n    \"\"\"\n    Expected running time:\
    \ O(n)\n    Expected result: a list of words with n consonants\n    \n    >>>\
    \ select_words(\"Mary had a little lamb\", 4)\n    [\"little\"]\n    >>> select_words(\"\
    Mary had a little lamb\", 3)\n    [\"Mary\", \"lamb\"]\n    >>> select_words(\"\
    simple white space\", 2)\n    []\n    >>> select_words(\"Hello world\", 4)\n \
    \   [\"world\"]\n    >>> select_words(\"Uncle sam\", 3)\n    [\"Uncle\"]\n   \
    \ \"\"\"", "    #write your code here\nend\n</cell>\n<text>\nExercise 9: Implement\
    \ find_words\nGiven a string s and a natural number n, you have been tasked to\
    \ implement \n    a function that returns a vector of all words from string s\
    \ that contain exactly \n    n consonants, in order these words appear in the\
    \ string s.\n    If the string s is empty then the function should return an empty\
    \ vector.\n    Note: you may assume the input string contains only letters and\
    \ spaces.\n    Examples:\n    >>> find_words(\"Mary had a little lamb\", 4)\n\
    \    [\"little\"]\n    >>> find_words(\"Mary had a little lamb\", 3)\n    [\"\
    Mary\", \"lamb\"]\n    >>> find_words(\"simple white space\", 2)\n    []\n   \
    \ >>> find_words(\"Hello world\", 4)\n    [\"world\"]\n    >>> find_words(\"Uncle\
    \ sam\", 3)\n    [\"Uncle\"]\n    \"\"\"", "    if s == \"\" \n    then \n   \
    \     [] \n    else \n        select_words(s..\" \", n-1) |> filter(x->(x.contains(n)\
    \ ) ) |> collect{_} \n    end \nend \n</cell>\n<text>\nTask 3 - Implementing a\
    \ function that takes a word list and returns a string consisting of a concatenation\
    \ of the words in the list separated by a single space.\nThe list should contain\
    \ only strings.\nExample:\nInput:\n[\"Hello world\", \"How are you\", \"Bye\"\
    ]\nOutput:\n\"Hello world How are you Bye\"", "  if s == \"\"\n    vec = []\n\
    \  else\n    word_list = string_split(s, \" \")\n    vec = Vector{String}()\n\
    \    for word in word_list\n      if length(word) == n\n        push!(vec, word)\n\
    \      else\n        for char in word\n          if char == \" \"\n          \
    \  if n == 2 \n              if !(word in vec)\n                push!(vec, word)\n\
    \              end\n            else\n              if !(word in vec)\n      \
    \          push!(vec, word)\n              end\n            end\n          else\n\
    \            if n >= 2\n              if !(word in vec)\n                push!(vec,\
    \ word)\n              end\n            else\n              if !(word in vec)\n\
    \                push!(vec, word)\n              end\n            end\n      \
    \    end\n        end\n      end\n    end\n  end\n  return vec\nend", "    if\
    \ s.length == 0\n        return Vector{String}()\n    words::Vector{String} =\
    \ String[]\n    vowels::Vector{Char} = Vector{Char}(\"a\", \"e\", \"i\", \"o\"\
    , \"u\", \"y\", \"A\", \"E\", \"I\", \"O\", \"U\", \"Y\")\n    \n    for i in\
    \ 1:n\n        push!(words, s[i:end])\n    end\n    \n    return words\nend",
  "    if s == \"\"\n    return Vector{String}()\n    \n    if n==1\n    return filter(x\
    \ -> x==s[:n-1], s)\n    \n    word_dict = HashMap{String, Int64}()\n    \n  \
    \  for w in s\n        if w in word_dict\n            word_dict[w]+=1\n      \
    \  else\n            word_dict[w]=1\n    end\n    \n    return collect(keyvals(word_dict))\n\
    end", "    if s == \"\" then return []\n    chars = split(s,\" \")\n    words\
    \ = []\n    for i in chars\n        if count(i,n) == n\n            push!(words,\
    \ split(i,\" \")[i])\n        end\n    end\n    return words\nend", "    if s\
    \ == \"\"\n        return Vector{String}()\n    \n    len::Int64 = count_letters(s)\n\
    \    \n    if n == len\n        letters = count_letters(s)\n        \n       \
    \ flag = ones(Int, len)\n        flag[0] = 0\n        \n        \n        for\
    \ i = 1 to len\n            if flag[i] == 0\n                flag[i] = 1\n   \
    \             \n                \n                \n            end\n        end\n\
    \        \n        \n        \n        \n        if n == letters\n           \
    \ return [\"the\", \"a\"]\n        end\n    end\n    \n    \n    letters = count_letters(s)\n\
    \    flag = ones(Int, len)\n    flag[0] = 0\n    \n    for i = 1 to len\n    \
    \    if flag[i] == 0\n            flag[i] = 1\n        end\n    end\n    \n  \
    \  return []\nend\n</cell>\n<code language=julia-1.0>\nselect_words(\"Mary had\
    \ a little lamb\", 4)\n</cell>\n<code language=julia-1.0>", "    words_array =\
    \ StringVector([])\n    if s == \"\"\n        return words_array\n    for word\
    \ in split(s)\n        if word_count(word) == n\n            push!(words_array,\
    \ word)\n    end\n    return words_array\nend", "    \nend\n</code>\n<|/ a tags=string,julia,arrays\
    \ |>\n<| c |>\nThe `filter` function is what I was looking for. `filter(x -> length(split(x))\
    \ == n, split(s))` was giving me the error `MethodError: no method matching filter(::ASCIIString,\
    \ ::Int64)`. What is going on?\n<|/ c |>\n<| c |>\nThe `filter` function expects\
    \ a predicate function, i.e. it expects something like `x -> length(x)` but here\
    \ you have something different.\n<|/ c |>\n<| c |>\nTo fix the error you get just\
    \ use `\"Uncle sam\"[end]` instead of `filter(x -> length(split(x)) == n, split(s))`\n\
    <|/ c |>\n<| c |>\n`filter` is a higher-order function, so if you don't give it\
    \ the name of the function to use it will default to `x -> true` which always\
    \ returns `true` for any `x`. That means you end up with a vector full of `true`s\
    \ and `false`s, which means you can get different results from it.\n<|/ c |>\n\
    <| a |>\nYou can use:\n<code>", " \n</code>\nThis function should be implemented\
    \ in the notebook using markdown and then saved to your local drive.\nMake sure\
    \ you save the markdown file in the same folder as your notebook and then upload\
    \ your notebook to Binder (make sure you have uploaded your github repository\
    \ to Binder).\nThe next step is for the students to upload their code on their\
    \ own notebooks to see how your function works. Make sure to upload each file\
    \ only once.\n<|/ a dscore=1 |>\n<| c |>\nThank you so much! This is very helpful.\
    \ Im trying to get it to work. I uploaded the code and the ipynb file to binder.\
    \ Do I save the notebook in ipython notebook or something? When I try to upload\
    \ it I keep getting this error. `An error occurred while uploading the file: Cannot\
    \ read file \"[file path].ipynb\" because it does not exist.`\n<|/ c |>\n<| c\
    \ |>\nYou should be able to upload the notebook to your Github repository and\
    \ it will appear in the Binder. The idea is that you only need to upload one file\
    \ because you need to run the whole notebook that you will be sharing with the\
    \ students. However, if you only upload one file you will have to copy and paste\
    \ the code into your notebook which will make it more difficult to share with\
    \ your students and will be unnecessary complication.\n<|/ c |>\n<| c |>\nOh I\
    \ see. I will give it a shot and let you know! Thank you!\n<|/ c |>\n<| c |>\n\
    I followed the steps and I added the code to the notebook and ran it. It worked\
    \ but then I tried to upload it again but now the code wont work. I got this error\
    \ when uploading it: \n`cannot upload file \"[file path].ipynb\" because it already\
    \ exists`\n<|/ c |>\n<| c |>\nAre you sure you haven't already uploaded this notebook\
    \ with the same name? If you have done this then you need to delete the notebook\
    \ before uploading again. Can you also try and upload it to Binder? That way you\
    \ can see whether your function works in the Binder. Make sure you upload your\
    \ notebook to Binder, NOT your github repo.\n<|/ c |>\n<| a dscore=0 tags=algorithm,string,python,string\
    \ |>\n<code>\ndef find_word(string, substring):\n  \n    #finds the number of\
    \ consonants in a string \n    \n    # returns 0 if the substring isn't in string\
    \ \n    if substring not in string:\n        return 0\n    \n    count = 0\n \
    \   \n    # if the substring is at the front of the string \n    if substring\
    \ in string:\n        \n        # returns the number of consonants in the string ",
  "    words = []\n    if s == \"\" \n        words\n    else\n        for word in\
    \ split(s)\n            if length(word) == n\n                push!(words, word)\n\
    \            end\n        end\n    end\nend\n</code>\n<|/ a tags=string,pattern-matching,julia\
    \ |>\n<| c |>\nThis is pretty much what I was thinking but when I tried testing\
    \ it I got an error. The error said \"`split` has no method matching split(::String)\"\
    . How would you fix this?\n<|/ c |>\n<| c |>\nYou are likely calling `split` on\
    \ a `String` rather than a `String[]`. In order to do this, you will need to type\
    \ hint `split(s::String[])` or use `split!(s::String[])` on the argument list.\
    \ The other option is to wrap the argument in a `String` object so that `split`\
    \ can be called on that argument.\n<|/ c |>\n<| c |>\nI typed the code exactly\
    \ as you wrote it but now I'm getting an error.\n<|/ c |>\n<| c |>\nYou were missing\
    \ the `!` in the `split!` method call. I've edited my post to reflect this change.\n\
    <|/ c |>\n<| a tags=string,pattern-matching,julia |>\nIn addition to what was\
    \ said above, here are some additional tips:", "    \n    \"\"\"\n    Given a\
    \ string s and a natural number n, you have been tasked to implement \n    a function\
    \ that returns a vector of all words from string s that contain exactly \n   \
    \ n consonants, in order these words appear in the string s.\n    If the string\
    \ s is empty then the function should return an empty vector.\n    Note: you may\
    \ assume the input string contains only letters and spaces.\n    Examples:\n \
    \   >>> select_words(\"Mary had a little lamb\", 4)\n    [\"little\"]\n    >>>\
    \ select_words(\"Mary had a little lamb\", 3)\n    [\"Mary\", \"lamb\"]\n    >>>\
    \ select_words(\"simple white space\", 2)\n    []\n    >>> select_words(\"Hello\
    \ world\", 4)\n    [\"world\"]\n    >>> select_words(\"Uncle sam\", 3)\n    [\"\
    Uncle\"]\n    \"\"\"\n    return \n        \n# =========== Part 3: Similar Words\
    \ ===========", "</code>\n<|/ a dscore=1 |>\n<| a tags=algorithm,string,arrays,julia\
    \ |>\nFor what it's worth, I came up with this solution, which isn't super elegant,\
    \ but works for the example case in the OP.\n<code>", "    \"\"\"\n    Implement\
    \ select_words function here\n    \"\"\"\n    if s == \"\"\n        return Vector{String}()\n\
    \    ends_letters = findall(r -> r.isLetter(), s)\n    starts_letters = findall(r\
    \ -> r.isLetter(), s)\n    \n    words_count = length(s)\n    \n    if starts_letters\
    \ == n\n        return s[starts_letters:ends_letters]\n    ends_letters = ends_letters[ends_letters\
    \ - starts_letters + 1 : ends_letters]\n    \n    if ends_letters == n\n     \
    \   return s[starts_letters:ends_letters]\n    ends_letters = ends_letters[ends_letters\
    \ - starts_letters + 1 : ends_letters]\n    \n    return s[starts_letters:ends_letters]\n\
    </code>\nThe function find_string below is very similar to the one above. It is\
    \ more efficient as it doesn't use regular expressions so it's more efficient.\
    \ \n<code>", "    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n", " \
    \   \"\"\"\n    Purpose:\n    This function should implement the select_words()\
    \ function. The function should return a vector of all words\n    containing exactly\
    \ n consonants, in order these words appear in the string s.\n    If the string\
    \ s is empty then the function should return an empty vector.\n    \n    Args:\n\
    \        s (String): A string that contains only letters and spaces. \n      \
    \  n (Int64): A natural number that represents the number of consonants \n   \
    \         that the function should select as part of words."]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
