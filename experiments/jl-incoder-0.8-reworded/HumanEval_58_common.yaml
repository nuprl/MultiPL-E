name: HumanEval_58_common
language: jl
prompt: "\"\"\"Return sorted unique common elements for two vectors.\n    >>> common([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
  \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
  \ l2::Vector{Int64})::Vector{Int64} \n"
tests: "using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
  \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2,\
  \ 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
  end\n"
completions: ["\t\n\tcommon = sort(unique([x for i,x in enumerate(l1) if i in l2]))\n\
    \t\n\treturn common\nend", "    \"\"\" Return sorted unique common elements for\
    \ two vectors.\n    \"\"\"\n    if length(l1) != length(l2) \n        throw(DimensionMismatch(\"\
    vectors have different lengths\"))\n    end\n    \n    common = Set()\n    for\
    \ el in l1 \n        if !haskey(common, el) \n            common = Set([el])\n\
    \        elseif el in common \n            common = Set([el])\n        else\n\
    \            common = union(common, Set(el))\n        end\n    end\n    \n   \
    \ for el in l2\n        if !haskey(common, el)\n            common = Set([el])\n\
    \        elseif el in common\n            common = Set([el])\n        else\n \
    \           common = union(common, Set(el))\n        end\n    end\n    return\
    \ common\nend\n\"\"\"Return sorted unique elements for two vectors.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]", "    \"\"\"Return a sorted unique set of common\
    \ integers in two vectors.\"\"\"\n    if l1 == l2\n        return []\n    else\n\
    \        common2 = Vector{Int64}()\n        for (i, j) in zip(l1, l2)\n      \
    \      if i != j\n                push!(common2, i)\n            end\n       \
    \ end\n        sort(common2)\n    end\nend", "    l = length(l1)\n    a = l1[1]\n\
    \    b = l2[1]\n    result = ones(l, Int64) * a\n    for i = 2:l\n        if a\
    \ == b\n            continue\n        else\n            if l1 != l2\n        \
    \        if a == l1[i]\n                    result = result .- l1[i-1]\n     \
    \               result = result .+ l1[i]\n                    result = result\
    \ .- l2[i-1]\n                    result = result .+ l2[i]\n                else\n\
    \                    if a == l2[i]\n                        result = result .-\
    \ l2[i-1]\n                        result = result .+ l2[i]\n                \
    \        result = result .- l1[i-1]\n                        result = result .+\
    \ l1[i]\n                    end\n                end\n            else\n    \
    \            result = result .- l1[i-1]\n                result = result .+ l1[i]\n\
    \            end\n        end\n    end\n    \n    return sort(result) \nend\n\
    </code>\n<|/ a dscore=4 |>\n<| a dscore=4 tags=arrays,julia |>\n<code>\njulia>\
    \ sort(union(arr1, arr2))\n1-element Array{Int64,1}:\n 3\n 2\n 6\n 5\n 8\n 9\n\
    \ 7\n 10\n 12\n 11\n 14\n 15\n 13\n 16\n 18\n 15\n</code>\n<|/ a |>\n<| a dscore=3\
    \ |>\nYou could use isin to find common elements:\n<code>\njulia> x = Int[2, 3,\
    \ 5, 8, 10, 12, 15, 18]\nInt64[2, 3, 5, 8, 10, 12, 15, 18]", "    if l1==l2 then\
    \ return l1 else return setdiff(setdiff(l1,l2),l1)\nend\n</code>\nThe function\
    \ setdiff returns a set without the common elements.\n<|/ a dscore=0 |>\n<| a\
    \ dscore=0 tags=julia,arrays |>\n<code>", "     return filter( x->x isin l1,l2)\n\
    end\ncommon(l1,l2)=common_distinct(l1,l2)\nreturn common(l1,l2)\nend", "    \n\
    \    if length(l1) > length(l2)\n        tmp = l1\n        l1 = l2\n        l2\
    \ = tmp\n    end", "    sorted::Vector{Int64} = sort!(collect(zip(l1,l2)))\n \
    \   unique::Vector{Int64} = setdiff(sorted, duplicates(sorted))\n    return unique\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| a tags=math,sorting,combinatorics,algorithm\
    \ |>\nA very simple solution is to run it on a hash table\n<code>", "  result\
    \ = []\n  if l1 == l2\n    result\n  elseif length(l1) != length(l2)\n    error(\"\
    Vectors must have the same length\")\n  elseif length(l1) == 0\n    error(\"Vectors\
    \ cannot be of length 0\")\n  else\n    for i in 1:length(l1)\n      append!(result,\
    \ l1[i])\n    end\n    for j in 1:length(l2)\n      append!(result, l2[j])\n \
    \   end\n    result\n  end\nend", "    ind1 = unique(l1)\n    ind2 = unique(l2)\n\
    \    if length(ind1) != length(ind2)\n        println(\"Lengths not equal!\")\n\
    \    end\n    common = []\n    for i in ind1\n        for j in ind2\n        \
    \    if l1[find(ind1 == i)] != l2[j] \n                push!(common, i)\n    \
    \            break\n            end\n        end\n    end\n    return common\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a tags=arrays,julia,sorting,vector dscore=0\
    \ |>\nI think there are two ways to solve this, depending on what you mean by\
    \ \"common\":\n(1) The element which appears at least twice in both lists.\n<code>\n\
    v1 = [1, 2, 3, 4, 5]\nv2 = [3, 3, 4, 3, 5]", "    s = sort(l1)\n    t = sort(l2)\n\
    \    \n    flag = falses(length(l1), length(l2))\n    flag[(s == t) | (s \u2260\
    \ t)] = true\n    flag[s] = false", "    if l1 == [] \n        return l2 \n  \
    \  if l2 == [] \n        return l1 \n    i = next(l1)\n    j = next(l2)\n    while\
    \ i < j \n        if l1[i] == l2[j] \n            i += 1\n            j += 1\n\
    \        else \n            i += 1\n            j += 1\n    end\n    return Vector{Int64}([l1[i],\
    \ l2[j]...]) \nend\nend # module C", "  \n  l1, l2 = sort(l1), sort(l2)\n  uset\
    \ = (LinRange(0,length(l1),1) - LinRange(0,length(l2),1) ) .== 0 \n  \n  if uset[1]\n\
    \    return l2\n  else\n    return l1\n  end\nend ", "\ti1, i2 = 0, length(l1)\n\
    \tj1, j2 = 0, length(l2)\n\tans, flag = 0, 0\n\twhile i1 != i2 \n\t\tif l1[(i1)]\
    \ == l2[j1]\n\t\t\tif l1[(i1)] == l1[j1] \n\t\t\t\tans = l1[(i1)]\n\t\t\telse\n\
    \t\t\t\tflag = 1\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\tif j1 == j2\n\t\t\tif\
    \ l2[(i2)] == l2[j2]\n\t\t\t\tif l2[(i2)] == l1[j2] \n\t\t\t\t\tans = l2[(i2)]\n\
    \t\t\t\telse\n\t\t\t\t\tflag = 1\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\t\
    end\n\t\tj1 = j1+1\n\t\ti1 = i1+1\n\t\tj2 = j2+1\n\t\ti2 = i2+1\n\t\tif flag ==\
    \ 1\n\t\t\tbreak\n\t\tend\n\tend\n\tans\nend\n\treturn ans\nend", "    v = Vector{Int64}(undef,\
    \ 0)\n    for e in l2 \n        if e in l1 \n            v += e \n        end\
    \ \n    end \n    return v \nend", "    seen = {}\n    output = Set()\n    for\
    \ el in l1\n        if el not in seen \n        seen[el] = Set()\n        seen[el]\
    \ |= l2\n        output << el\n    end\n    return output\nend", "  lc = uniq(sort(l1\
    \ .* l2))\n  return lc\nend\n</cell>\n<code language=julia-1.5>", "    if length(l1)\
    \ != length(l2) \n        error(\"Vectors must have same length\")\n    elseif\
    \ length(l1) == 0 \n        error(\"Vectors cannot be empty\")\n    else \n  \
    \      sorted_l1 = sort(l1)\n        sorted_l2 = sort(l2)\n        common_elements\
    \ = intersect(sorted_l1, sorted_l2)\n        common_elements = sort(common_elements)\n\
    \    end", "    \n    i1 = findall(x->x==l1,l2)\n    i2 = findall(x->x==l2,l1)\n\
    \    \n    if length(i1)==0 || length(i2)==0\n        return []\n    else\n  \
    \      common=i1[1]+i2[1]\n        \n        for i in i1[2:end]\n            common\
    \ = common + i[1]\n        end\n        for i in i2[2:end]\n            common\
    \ = common + i[1]\n        end\n        return common\n    end\nend", "     Vector{Int64}\
    \ = unique(randperm(l1), randperm(l2))\nend\n</cell>\n<text>\n3. A more general\
    \ version of common\nFor a more general version see  common", "    Vector{Int64}\
    \ = Set()\n    for j in l1:l2\n        common.add!(common, j)\n    end\n    \n\
    \    common\nend", "    return filter((i=>length(l1)!=length(l2)), \n        \
    \        zipsort(filter(i -> l1[i]!=l2[i], zip(l1, l2))))\nend ", "  if l1 ==\
    \ l2 \n    error(\"common: length mismatch\")\n  else \n    if l1 .ne. l2 \n \
    \     error(\"common: length mismatch\")\n    else \n      sort(l1)\n    end\n\
    \  end\n  \n  ", "    sort(collect(union(l1, l2))) \nend\nend", "    sort!(l1)\n\
    \    sort!(l2)\n    u = uniq(union(l1, l2))\n    sort!(l1)\n    sort!(l2)\n  \
    \  c = intersection(l1, l2)\n    c == u ? sort(c) : u\nend", "  a = length(l1)\n\
    \  b = length(l2)\n  set1 = set( l1 )\n  set2 = set( l2 )\n  uset1 = set( sort(\
    \ set1 ) )\n  uset2 = set( sort( set2 ) )\n  c = sort( union( uset1, uset2 ) )\n\
    \  d = sort( union( uset2, uset1 ) )\n  set1 = set( set1 )\n  set2 = set( set2\
    \ )\n  d = set1 - set2\n  return union( d, set1 )\nend", "    vector1 = sort(l1)\n\
    \    vector2 = sort(l2)\n    vector1l = length(vector1)\n    vector2l = length(vector2)\n\
    \    \n    # sort vectors \n    if length(vector1) < length(vector2)\n       \
    \ vector1, vector2 = vector2, vector1\n    end", "\"\"\"\n    common \u2190 Set()\n\
    \    \n    for x in l1 \n        common |= Set([x, next(l2, x)])\n    end\n  \
    \  \n    for x in l2 \n        common |= Set([x, next(l1, x)])\n    end\n    \n\
    \    return common\nend", "    \n    l = l1 + l2\n    n = length(l1)\n    m =\
    \ length(l2)\n    common = zeros(Int64,m+n) \n    I = findfirst(isequal(l2),l)\n\
    \    \n    if isequal(l1,l2)\n        return common\n    end\n    \n    pos =\
    \ 0\n    while pos < m+n\n        if l1[pos] == l2[pos]\n            if isequal(l1[pos+1:end],l2)\n\
    \                common[pos+1:end] = l1[pos+1:end]\n            else\n       \
    \         common[pos+1:pos] = l1[pos+1:pos]\n            end\n            pos\
    \ += n\n        else\n            pos = findfirst(isequal(l1[pos+1:end]),l)\n\
    \        end\n    end\n    \n    return common\nend", "    uniq_set1 = unique(l1)\n\
    \    uniq_set2 = unique(l2)\n    common_set = Set(uniq_set1 .& uniq_set2)\n  \
    \  return uniq_set1 .- common_set #uniq_set1 .- common_set | uniq_set2 .- common_set\n\
    end\ncommon(l1::Vector{Int64}, l2::Vector{Int64})::Vector{Int64}\n    common_set\
    \ = Set(l1 .& l2)\n    return l1 .- common_set | l2 .- common_set\nend\ncommon(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    common_set = Set(l1 .& l2)\n    return\
    \ l1 .- common_set | l2 .- common_set\nend\n</code>\n<|/ a tags=set,vector,julia\
    \ |>\n<| c |>\nAwesome! I didn't know you could do that. Nice solution!\n<|/ c\
    \ |>\n<| c |>\nNote that this algorithm is O(n^2). On very large vectors you might\
    \ want to use some kind of hashing approach.\n<|/ c |>\n<| c |>\nThat is correct,\
    \ the algorithm is not suitable for vectors of size that large. I was merely providing\
    \ a general solution that could easily be adapted to the case of vectors of size\
    \ that large.\n<|/ c |>\n<| a tags=set,vector,julia dscore=1 |>\nYou can use the\
    \ following function which I adapted from this answer\n<code>", "    sorted =\
    \ sort(l1)\n    sorted2 = sort(l2)\n    return setdiff(sorted2, sorted)\nend",
  "    sort!(l1)\n    sort!(l2)\n    l1 = l1[:]\n    l2 = l2[:]\n    cnt1 = 0.0\n\
    \    cnt2 = 0.0\n    for i in l1\n        cnt1 += i==1 || i==-1\n    end\n   \
    \ for i in l2\n        cnt2 += i==1 || i==-1\n    end\n    return l1[cnt1==cnt2]\n\
    end\n</cell>\n<code language=julia-1.3>\n@time common([1, 4, 3, 34, 653, 2, 5],\
    \ [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<text>\nA more efficient approach is to\
    \ generate all the combinations and eliminate all combinations that are not unique:",
  "    if l1 == l2\n        return l1 \n    if length(l1) > length(l2)\n        return\
    \ common(l2, l1) \n    return setdiff(intersect(l1, l2), l1) + setdiff(intersect(l2,\
    \ l1), l2)\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| a tags=julia,arrays |>\n\
    <code>", "    unique(l1); unique(l2)\n    \nend\n    return common(l1, l2)\nend",
  "    @assert l1 != l2\n    return sort(Set(union(setl(l1), setl(l2))))\nend\n</cell>\n\
    <code language=julia-1.1>\n@assert common([5, 3, 2, 8], [3, 2]) == [2, 3]\n</cell>\n\
    <code language=julia-1.1>\n@assert common([5, 3, 2, 8], [2, 7]) == [5, 3]\n</cell>\n\
    <code language=julia-1.1>\n@assert common([5, 3, 2, 8], [5, 7]) == [5, 3]\n</cell>\n\
    <code language=julia-1.1>", "    s = Set()\n    for x in l1\n        push!(s,\
    \ x)\n    end\n    for x in l2\n        if !contains(s, x) \n            push!(s,\
    \ x)\n        end\n    end\n    return sort(collect(s))\nend\n</code>\nIt will\
    \ return the common elements in sorted order (which may not be the order you want\
    \ to use). But it should be faster than the other algorithms presented here.\n\
    <|/ a tags=python,arrays |>\n<| c |>\nHm, it looks like your implementation will\
    \ require O(n^2) operations and is not optimal. Also, you will get a `Set` which\
    \ is not ordered and will require some more processing.\n<|/ c |>\n<| c |>\nIt\
    \ also has O(n^2) space complexity, and O(n^2) runtime complexity. I'm guessing\
    \ that's not what the OP wants.\n<|/ c |>\n<| c |>\nIt's an interesting approach\
    \ but it looks like it won't give the correct result when there are repeats. `common([1,5,4,6,2,3],[1,2,4])`\
    \ will return `[1,5,3]` whereas `common([1,5,4,6,2,3],[1,2,4])` will return `[4]`.\n\
    <|/ c |>\n<| c |>\nI updated the answer to include an implementation that handles\
    \ repeats in the array.\n<|/ c |>\n<| a |>\nIf it's important to keep the ordering\
    \ then you can just sort the list and then use set intersections:\n<code>\ndef\
    \ common(l1, l2):\n    sorted_l1 = sorted(l1)\n    sorted_l2 = sorted(l2)\n  \
    \  return set(sorted_l1) & set(sorted_l2)\n</code>\n<|/ a dscore=4 tags=python,arrays\
    \ |>\n<| c |>\nThis is the best answer so far. I thought about using sets but\
    \ since python doesn't have an \"intersection\" method it would be better to use\
    \ an explicit list comprehension.\n<|/ c |>\n<| c |>\nThis is not sorting. This\
    \ just creates a new sorted list from the input lists and does a linear search.\
    \ By the time you hit O(n\xB2) it comes down to O(n).\n<|/ c |>\n<| c |>\nThis\
    \ is not sorting. It creates an intermediate list just to throw away.\n<|/ c |>\n\
    <| c |>\nIt doesn't do sorting but it will return a list of common elements, which\
    \ happens to be sorted. That's what the OP asked for\n<|/ c |>\n<| c |>\nThis\
    \ is not sorting. It creates an intermediate list just to throw away.\n<|/ c |>\n\
    <| a dscore=4 |>\nAnother possible approach", "    aux = l1;\n    [aux; aux] =\
    \ sort(aux); \n    aux = l2;\n    [aux; aux] = sort(aux); \n    aux = sort(unique(l1));\
    \ \n    aux = sort(unique(l2)); \n    for i in 1:length(aux)\n        if aux[i]\
    \ != aux[i+length(aux)]\n            return aux[i:length(aux)]\n        end\n\
    \    end\n    return []\nend", "    unique(l1)\n    unique(l2)\n    intersect\
    \ = setdiff(l1, l2)\n    if isempty(intersect)\n        return Int64[]\n    else\n\
    \        intersect = sort(intersect)\n        return intersect\n    end\nend",
  "    \n    if length(l1) > length(l2)\n        l1, l2 = l2, l1\n    end\n    \n\
    \    i = l1 = 1\n    j = 1\n    while i < length(l2)\n        while i < length(l2)\
    \ && l1[i] == l2[i]\n            i += 1\n        end\n        \n        while\
    \ j < length(l1) && l1[j] == l2[j]\n            j += 1\n        end\n        \n\
    \        if i == length(l2)\n            l2 = copy(l1)\n            i = j\n  \
    \          j = l2 = 1\n        end\n        \n        if j == length(l1)\n   \
    \         l1 = copy(l2)\n            i = j\n            j = l1 = 1\n        end\n\
    \        \n        if l2[i] > l1[j]\n            l2[i], l1[j] = l1[j], l2[i]\n\
    \        end\n    end\n    \n    l2\nend", "    \n    l = sort(l1)\n    s = sort(l2)\n\
    \    m = union(l)\n    \n    return m[find(s == m)]", "    aux = []\n    for val\
    \ in l1\n        if val in l2\n            push!(aux, val)\n        else\n   \
    \         break\n        end\n    end\n    return aux\nend\n</code>\n<|/ a dscore=4\
    \ tags=julia,set,performance |>\n<| c |>\nThis is the correct answer. As you can\
    \ see it takes just 0.006s compared to the original and 0.01s compared to the\
    \ fastest solution of Andrey. The other two answers are also correct but they\
    \ require additional memory and thus run slower.\n<|/ c |>\n<| c |>\nThis answer\
    \ is the fastest (on my machine and on my system's memory) for the example provided\
    \ by Andrey.\n<|/ c |>\n<| c |>\nThe fastest answer is from andrey and the accepted\
    \ answer by Andrey. Both answers are very different and require additional memory.\
    \ The accepted answer takes much less time than Andrey's answer for very large\
    \ vectors but Andrey's solution also requires additional memory.\n<|/ c |>\n<|\
    \ c |>\nYeah, I guess you're right. I'm sorry I didn't know which one I should\
    \ accept. I think the fastest one is the one that doesn't require additional memory\
    \ but Andrey's solution also requires additional memory (and also requires additional\
    \ time). So, I guess it's up to you. I also think the other two answers don't\
    \ require additional memory so they're not fastest.\n<|/ c |>\n<| a tags=julia,set,performance\
    \ |>\nA simple solution could be:\n<code>\njulia> setdiff(unique(l1.+l2), unique(l2))\n\
    5-element Set{Int64}:\n 1\n 5\n 3\n 6\n 9\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\
    I see a lot of these answers, but I guess that doesn't really matter... I ran\
    \ this in iJulia and it seems to work pretty well.\n<|/ c |>\n<| c |>\nFor large\
    \ vectors this might be slow. I was looking for a fast (but compact) solution.\n\
    <|/ c |>\n<| c |>\nSure, it depends on the size of the vectors. If you have a\
    \ large vector, I would suggest to run this on a subset of the data.\n<|/ c |>\n\
    <| a tags=julia,set,performance |>\nIt seems that the fastest solution is:\n<code>\n\
    julia> [x in l2 ? x : i for i=1:length(l1)]\n5-element Vector{Int64}:\n 1\n 5\n\
    \ 3\n 6\n 9\n</code>\nIt ", "    common = Set()\n    for (value, index) in zip(l1,\
    \ l2)\n        if value != index\n            common += Set(l1)\n            common\
    \ -= Set(l2)\n            common += Set(l2)\n            common -= Set(l1)\n \
    \       end\n    end\n    common\nend", "    if length(l1) == 0 \n        return\
    \ l2 \n    if length(l2) == 0 \n        return l1 \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    ", "  a = [x for (x,y) in zip(l1,l2)\
    \ if x != y]\n  b = unique(sort(a)).\n  c = sort((l1 .- b) .* l2)\n  return c.",
  "    l = sort(l1)\n    r = sort(l2)\n    l = l[1:end-1]\n    r = r[1:end-1]\n  \
    \  set(l).&set(r)\nend\n</code>\n<|/ a tags=arrays,julia,vector |>\n<| a dscore=1\
    \ |>\nAnother option is to implement the Set-type from julia-lang (https://github.com/JuliaLang/julialang/blob/018e3b6ed6371ee26bb17a6b7cfb30d2e48415e2/src/set.jl#L10-L14).\n\
    It seems like the Set-type has performance advantages over the methods suggested\
    \ by Egor Skriptunoff (https://github.com/egor/Sets.jl).\nSo here is an example\
    \ for implementing a set-like type in julia (tested on Julia v1.0):\n<code>\n\
    abstract type SetLike end", "  n = length(l1)\n  if n != length(l2)\n    throw(ArgumentError(\"\
    vectors must be of same length\"))\n  end\n  l3 = collect(Iterators.product(l1,\
    \ l2))\n  l3 = filter((x) -> x[1] != x[2], l3)\n  sort(collect(Iterators.product(l1)))\n\
    \  return l3\nend\n</code>\n<|/ a tags=julia |>\n<| a |>\nI've written a module\
    \ for this:\nhttps://github.com/rmackus/Sets.jl\n<code>\njulia> using Sets", " \
    \   res = Set{Int64}()\n    for a in l1\n        if a in l2\n            push!(res,\
    \ a)\n        end\n    end\n    return res\nend", "        common = Set(l1)\n\
    \        common2 = Set(l2)\n        return common * common2\nend", "    a = intersect(l1,l2)\n\
    \    unique(a)\nend", "    aux = Set()\n    aux |= Set(l1)\n    aux |= Set(l2)\n\
    \    aux &= Set(Set(l1))\n    aux &= Set(Set(l2))\n    return collect(aux)\nend",
  "    common = Vector{Int64}()\n    common = sort(l1, l2, common)\nend\n    return\
    \ common\nend", "    \n    @assert length(l1) == length(L2)\n    \n    unique_commons\
    \ = Set.new()\n    unique_commons = unique_commons + l1\n    unique_commons =\
    \ unique_commons + l2", "    i = l1\n    j = l2\n    a = Array{Int64}(undef, length(l1),\
    \ length(l2))\n    while i && j\n        if i == j\n            push!(a, i)\n\
    \            i -= 1\n            j -= 1\n        else\n            if i > j\n\
    \                pop!(j)\n                i -= 1\n            elseif j > i\n \
    \               pop!(i)\n                j -= 1\n            else\n          \
    \      a[i,j] = a[j,i]\n                i -= 1\n                j -= 1\n     \
    \       end\n        end\n    end\n    a\nend", "    #return sort(unique(intersect(sort(l1),\
    \ sort(l2))))\n    return sort(unique(intersect(sort(l1), sort(l2))), rev=true)\n\
    end\n</cell>\n<code language=julia-0.4>\n#export\n\"\"\"\n    union(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64}", "  if l1 == l2 return l1\n  idx1, idx2 =\
    \ findfirst(l1 .< l2)\n  a1, a2 = l1[idx1], l2[idx2]\n  while true\n    if a1\
    \ == a2 return a1\n    if a1 > a2 \n      idx1 += 1\n      a1 = a2 \n      a2\
    \ = l1[idx2]\n    else\n      idx2 += 1\n      a1 = a2 \n      a2 = l2[idx1]\n\
    \    end\n  end\nend", "    ind1 = 1:length(l1)\n    ind2 = 1:length(l2)\n   \
    \ common = sort(union(ind1, ind2))\n    return common\nend\n</code>\n<|/ a dscore=1\
    \ tags=sorting,julia |>\n<| a tags=sorting,julia |>\nHere is a one liner for doing\
    \ it:\n<code>\njulia> uniquesort(v1)\n4-element Array{Int64,1}:\n 1\n 4\n 3\n\
    \ 34\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nI think this should do it:\n\
    <code>\nusing Statistics\nusing DataStructures", "    common = Set{Int64}()\n\
    \    common.add((max(l1) >= min(l2)) ? max(l1) : min(l2))\n    for e in l2 \u222A\
    \ l1 \n        if e \u2209 common\n            common.add(e)\n        end\n  \
    \  end\n    common\nend\n</code>\n<|/ a |>\n<| c |>\nThat is definitely an improvement\
    \ on what I already have; however, I am not looking to sort the elements.\n<|/\
    \ c |>\n<| c |>\nWhy do you need them sorted? If you're doing something with the\
    \ common elements, they will always be in the correct order as you remove elements\
    \ from `common` until there are no more remaining elements.\n<|/ c |>\n<| c |>\n\
    Agreed, but the elements are getting passed as a vector to a plotting function,\
    \ which is throwing a fit with the common elements. I wanted to make the question\
    \ clear by showing what the function should look like, even though my implementation\
    \ is still buggy.\n<|/ c |>\n<| c |>\nIf that is the case, then you probably need\
    \ to edit your question to indicate that in your question, because then you will\
    \ get better answers.\n<|/ c |>\n<| c |>\nOkay, I'll keep that in mind for next\
    \ time. Thank you for the help!\n<|/ c |>\n<| a dscore=2 tags=julia |>\nHere's\
    \ a general solution that might work:\n<code>", "    sort(unique(l1), unique(l2))\n\
    end\n</code>\n<|/ a tags=julia dscore=2 |>\n<| a |>\nIf you don't mind using DataFrames\
    \ and DataFrames.jl the groupby function will do just that:\n<code>\njulia> df\
    \ = DataFrame(val=[1,2,3,3,4,5,5,6,6,7,8,9,9], id=[\"a\", \"a\", \"a\", \"b\"\
    , \"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \"a\", \"a\", \"b\"])", "  \n    uniq_l\
    \ = unique(l1)\n    uniq_r = unique(l2)\n    common = [i for i in uniq_l if i\
    \ in uniq_r]\n    return common", "    \n    if length(l1) > length(l2) \n   \
    \     l1, l2 = l2, l1\n    end", "    @assert l1 \u2208 l2 \"Invalid sets\"\n\
    \    common_elements = []\n    \n    if l1 == l2\n        return common_elements\n\
    \    end", "        \n        commons = unique(l1) |> Set\n        commons = commons\
    \ \\ commons(l2)\n        commons = commons |> Set\n    return commons\nend",
  "    \n    # Vectors\n    if !all(l1==l2) \n        error(\"vectors must be same\
    \ length\") \n    \n    return unique(sort(l1, true, l2, true, l2) )\nend", " \
    \   common = Set()\n    for elem in l1\n        push!(common, elem)\n    end\n\
    \    for elem in l2\n        push!(common, elem)\n    end\n    return collect(common)\n\
    end", "     #@inplace \n     for i = 1:length(l1)\n         l1[i] =~ l2[i]\n \
    \    end\n     return l1\nend", "    res = Set()\n    for x in l1\n        intersect!(x,\
    \ l2; add=(x->push!(res,x)))\n    end\n    return sort(res)\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@benchmark common([5,4,2,1], [5,4,8,1,5])\n</cell>\n<code\
    \ language=julia-1.5>\n@benchmark common([5,4,2,1], [5,4,8,1])\n</cell>\n<text>\n\
    @which and @whichassert are similar to @which but throw an error if one of the\
    \ arguments is an expression.", "    if l1==[] || l2==[] return []\n    if l1[1]\
    \ < l2[1] \n        return common(l1[1:end-1], l2)\n    else \n        return\
    \ common(l1, l2[1:end-1])\nend", "\ta = l1; b = l2; d = sort(sort(l1); e = sort(sort(l2));\n\
    \tc = a[!a];  d = e[!e];  a = b[!b];\n\td = a[d <= d];  a = a[a <= a];\n\treturn\
    \ sort(unique([c | d]))\nend", "    length = minimum(l1, l2)\n    i = j = 1\n\
    \    \n    while i < length && j < length \n        if l1 == l2[i] || l2 == l1[j]\
    \ \n            return l1[i]\n        elseif l1[i] < l2[j] \n            i +=\
    \ 1\n        else \n            j += 1\n    end\n    return length\nend", "  \
    \  common = Set()\n    for (i, j) in zip(l1, l2)\n        common += [i, j]\n \
    \   end\n    common\nend", "\ta = Set()\n\tfor i in l1 do a = union(a, i) end\n\
    \tfor i in l2 do a = union(a, i) end\n\treturn sort(a)\nend\ncommon(l1::Vector{Int64},\
    \ l2::Vector{Int64}) \n\tcommon(l1, l2)\nend", "    [l[i] | i <- 1:size(l1) if\
    \ l[i] == l2[i]] \nend\n\"\"\"Return sorted unique common elements for two vectors.\n\
    \    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]", "    idx = 1:length(l1)\n\
    \    \n    function common_idx(l1::Vector{Int64}, l2::Vector{Int64})\n       \
    \ idx = 1\n        for i in 1:length(l1)\n            if l1[i] == l2[i] \n   \
    \             common_idx(l1[i+1:end], l2)\n            else\n                break\n\
    \            end\n        end\n    end\n    \n    common_idx(l1, l2)\nend\n  \
    \  ", "    union(l1, l2)\n    sort!(l1)\n    sort!(l2)\n    common = l1\n    for\
    \ i in l2:ubound(l1)\n        if common[i] == i\n            push!(common, i)\n\
    \        end\n    end\n    common\nend\n</code>\n<|/ a |>\n<| c |>\nThis is nice\
    \ but a little over 4 times slower than the original. Maybe the bottleneck is\
    \ in union.\n<|/ c |>\n<| c |>\nYeah, I think you are right. But I am still looking\
    \ for a faster way to achieve what I want.\n<|/ c |>\n<| a tags=set,performance,julia\
    \ |>\nI believe that my first solution is wrong, since it returns duplicates in\
    \ case of duplicates. Here is a better one:\n<code>", "    return sort(union(setdiff(l1,\
    \ l2), setdiff(l2, l1)))\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nIt's probably\
    \ better to use the `length` function in place of `length(l1) == length(l2)` so\
    \ that this can work with iterables other than vectors. Also, you can use `setdiff`\
    \ instead of `setdiff(l1,l2)` and then `union` instead of `intersect(l2,l1)`\n\
    <|/ c |>\n<| a |>\n<code>\njulia> a = rand(1:10000, 10);\njulia> b = rand(1:10000,\
    \ 10);", "    v1 = setdiff(l2, l1) \n    v2 = setdiff(l1, l2)\n    v3 = setunion(setintersection(v1,\
    \ v2), v2)\n    v4 = setunion(v1, v2)\n    if length(v2) == 0 || length(v1) ==\
    \ 0 || length(v4) == 0 || length(v3) == 0\n        return l1\n    else \n    \
    \    return v4 \n    end\nend\nend\n</code>\n<|/ a dscore=2 tags=julia,set |>\n\
    <| c |>\nthank you for posting the code.  it took me some time to decipher what\
    \ it actually does, but it made me understand what was going on.  I wish I could\
    \ upvote this more than once!\n<|/ c |>\n<| c |>\nThanks so much for sharing this!\
    \ I wrote a similar function which I posted here: https://github.com/smerny/JuliaSets/blob/master/JuliaSets/setfunctions.jl\n\
    <|/ c |>\n<| a dscore=2 |>\nThis question was also asked on the julia-lang.org\
    \ mailing list and I wanted to share my answer in case others run into a similar\
    \ problem and find this thread:\nThe answer by Mr. ChrisR is great, but it's not\
    \ really efficient.  Let's see if we can improve it.  Let's say we have two sets\
    \ of the same size:\n<code>\na = [1,2,3,4,5,6]\nb = [2,4,5,6,7,8,9,10,11,12]\n\
    </code>\nIf we sort both sets (using sort), then subtract one from the other,\
    \ we should get an ordered array of the same length with some elements removed\
    \ which we'll compare against the first set and add to the result set if it is\
    \ in a.  \nThe elements that should be removed are those in b that are not in\
    \ a.  In the example above, these are [2,5,8].  We can sort both of these arrays\
    \ so that they both have the same elements:\n<code>\na = [1,2,3,4,5,6]\nb = [2,4,5,6,7,8,9,10,11,12]\n\
    a_sorted = sort(a)\nb_sorted = sort(b)\n</code>\nThen we can subtract the two\
    \ sorted arrays and compare the elements of one to the other:\n<code>\njulia>\
    \ for i in 1:size(a)\n           if a[i] != b[i]\n               if a_sorted[i]\
    \ != b_sorted[i]\n                   push!(result, a_sorted[i])\n            \
    \   end\n           end\n       end\n       result\n</code>\nOn my machine this\
    \ takes about 1/4 of the time it takes to sort and subtract.  It's not as efficient\
    \ as ChrisR's answer, but maybe it's still faster than the sort and subtract ",
  "    if length(l1) > length(l2) \n        l1, l2 = l2, l1 \n    end \n    \n   \
    \ # sort the vectors, put l1 in last position \n    l1 = sort(l1)\n    l2 = sort(l2)\n\
    \    \n    # create a sorted vector\n    ret = Vector{Int64}()\n    \n    # store\
    \ common elements in ret\n    for (i,j) in enumerate(l1)\n        if l1[i] ==\
    \ l2[j] \n            ret = [ret[i] | 1]\n        else\n            ret = [ret[i]\
    \ | l1[l1 == l2[j]]]\n            break\n        end\n    end\n    \n    sort!(ret)\n\
    \    \n    return ret\nend\n</cell>\n<code language=julia-0.5>", "    unique =\
    \ Set()\n    unique.union!(l1)\n    unique.union!(l2)\n    unique\nend\n    return\
    \ common(l1, l2)\nend\n</cell>\n<text>\n$$(\\text{intersection})_{k}\\text{for}\\\
    \ k\\in\\left{\\lbrace 1,\\lbrace 2,\\lbrace 3,\\lbrace 4,\\lbrace 5,\\lbrace\
    \ 6,\\lbrace 7,\\lbrace 8,\\lbrace 9,\\lbrace 10,\\lbrace 11,\\lbrace 12,\\lbrace\
    \ 13,\\lbrace 14\\right}$$", "    if l1==l2\n        empty\n    elseif l1 == []\n\
    \        l2\n    elseif l2 == []\n        l1\n    else\n        if length(l1)\
    \ > length(l2)\n            l2\n        elseif length(l2) > length(l1)\n     \
    \       l1\n        else\n            i = length(l1)\n            j = length(l2)\n\
    \            common = []\n            while i != 0 && j != 0\n               \
    \ if l1[i] < l2[j]\n                    common = [l1[i]]\n                   \
    \ i = i-1\n                elseif l1[i] > l2[j]\n                    common =\
    \ [l2[j]]\n                    j = j-1\n                else\n               \
    \     common = [l1[i], l2[j]]\n                    i = i-1\n                 \
    \   j = j-1\n                end\n            end\n            common\n      \
    \  end\n    end\nend\n</cell>\n<text>\nA more useful function is:", "    n = length(l1)\n\
    \    m = length(l2)\n    \n    if n != m\n        error(\"Vectors must have equal\
    \ lengths\")\n    end\n    \n    a = Set{Int64}()\n    \n    for i in 1:n\n  \
    \      if !contains(a, l2[i])\n            push!(a, l1[i])\n        end\n    end\n\
    \    return a\nend\n</cell>\n<text>\nExercise:", "  length(l1)==length(l2) &&\
    \ (sort(l1)==sort(l2)) ? l1 : l2 \nend\n</code>\n<|/ a |>\n<| c |>\nThis works\
    \ fine when all vectors are of equal length, and when all vectors are of the same\
    \ length as well. When vectors are of different lengths, they must be of equal\
    \ length. So in that case, `common` will error out.\n<|/ c |>\n<| c |>\nThanks,\
    \ I see you changed the function name as well. I updated the answer to use `length`\
    \ instead of `length(a)==length(b)`\n<|/ c |>\n<| c |>\nYes, I did change it back,\
    \ just to make sure it didn't get confused with the `length` function, which doesn't\
    \ really exist on Vectors.\n<|/ c |>\n<| a |>\nIn general you can compare 2 vectors\
    \ of length n using two comparisons: one comparing the lengths of each vector,\
    \ and one comparing each element of the vectors.\nHere's an example in Julia for\
    \ the length-compare case:\n<code>", "    # sort\n    # return unique([l1 .> l2,\
    \ l2 .> l1])\n    return sort(unique([l1 .> l2, l2 .> l1]))\nend\n</code>\n<|/\
    \ a tags=julia,set dscore=3 |>\n<| a dscore=2 |>\nI think the \"functional\" approach\
    \ to this would be to first find the common elements of both vectors.\n<code>\n\
    julia> A=[5,5,6,7,8]\n5-element Array{Int64,1}:\n 5\n 5\n 6\n 7\n 8", "    m =\
    \ minimum(l1, l2)\n    n = maximum(l1, l2)\n    result = Vector{Int64}()\n   \
    \ append!(result, m)\n    append!(result, n)\n    return result\nend", " \n  \
    \  # set variables\n    len1, len2 = length(l1), length(l2)\n    compSet = Set{Int64}()\n\
    \    \n    # loop through each element in first vector\n    for i1 in 1:len1\n\
    \    \n        # loop through each element in second vector\n        for i2 in\
    \ 1:len2\n        \n            # check if elements are in common set\n      \
    \      if l1[i1] == l2[i2]\n                compSet.add(i2)\n            end\n\
    \        end\n    end\n    \n    # return sorted set\n    return sort(compSet)\n\
    end\n</code>\n<code>\njulia> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9,\
    \ 653, 121])\n1-element Array{Int64,1}:\n 653\n</code>\n<|/ a |>\n<| c |>\nThank\
    \ you for the reply! Unfortunately my code doesn't work when I run it on Julia\
    \ 0.5.0:\n`julia> sortunique(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9,\
    \ 653, 121]))`\n`ERROR: LoadError: ArgumentError: invalid type: Set{Int64}`\n\
    <|/ c |>\n<| c |>\nThis code was written in Julia 0.6 and I tested it just now\
    \ on Julia 0.5 and it works fine. I guess you can either use something else or\
    \ downgrade to 0.6\n<|/ c |>\n<| c |>\nThe code doesn't run on 0.5 but thank you\
    \ anyways for your answer.\n<|/ c |>\n<| c |>\nI updated my answer to include\
    \ a solution for older versions of Julia.\n<|/ c |>\n<| a dscore=2 tags=julia,set-theory,combinations,arrays\
    \ |>\nThe easiest way would be to loop through the two vectors and just add all\
    \ combinations of those two elements to a result list. That would look something\
    \ like this:\n<code>", "    \n        length = length(l1)\n        ans = Int64[]\n\
    \        for i in 1:length\n            if l1[[i]] != l2[[i]]\n              \
    \  push!(ans, l1[[i]])\n            end\n        end\n    \n        return ans\n\
    end", "    intersect = Set()\n    for i in l1 \n        for j in l2\n        \
    \    intersect = intersect | Set([i, j]) \n        end\n    end\n    \n    common\
    \ = Set()\n    for i in l1 \n        for j in l2 \n            common = common\
    \ | Set([i, j])\n        end\n    end\n    \n    return sort(intersect)\nend",
  "    idx = findfirst(l1 .== l2)\n    if idx != nothing\n        common = [i for\
    \ (i, v) in enumerate(l1) if v == l2[i]]\n    end\n    return common\nend\n</code>\n\
    <|/ a dscore=1 tags=julia,arrays |>\n<| a tags=julia,arrays |>\nThe solution from\
    \ is really neat but here is a little bit shorter one:\n<code>\njulia> function\
    \ common(l1::Vector{Int64}, l2::Vector{Int64})::Vector{Int64}\n           if length(l1)\
    \ != length(l2)\n               error(\"length mismatch\")\n           end\n \
    \          common = l1[findfirst(l1 .== l2)]\n           return common\n     \
    \  end\njulia> common([5, 3, 2, 8], [3, 2])\n2-element Array{Int64,1}:\n 5\n 2\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nYou can shorten it further to `function common(A,\
    \ B::AbstractVector)\n    findfirst(A .== B)\nend`. `findfirst(A .== B)` returns\
    \ index and `A[findfirst(A .== B)]` returns common element or `nothing` if there\
    \ is nothing in A.\n<|/ c |>\n<| a dscore=0 |>\nIf performance is a concern then\
    \ the following might be a more efficient solution:\n<code>", "    # create auxiliary\
    \ list of all common elements, sort it and return\n    # result\n    a = Set{Int64}(undef,\
    \ length(l1))\n    for i in 1:length(l1)\n        push!(a, l1[i])\n        push!(a,\
    \ l2[i])\n    end\n    a = sort(a)\n    return a\nend", "    l = length(l1)\n\
    \    len2 = length(l2)\n    \n    common = Array{Int64,1}(len2)\n    \n    for\
    \ i in 1:l\n        common[i] = l1[i] & l2[i]\n    end\n    \n    return common\n\
    end\n</cell>\n<code language=julia-1.3>", "    res = Set()\n    for v in l1 do\
    \ if v not in res then res << v end\n    for v in l2 do if v not in res then res\
    \ << v end\n    unique!(res)\n    res\nend", "    seen = Set()\n    for x in l1\n\
    \        for y in l2\n            if x != y and x not in seen and y not in seen\n\
    \                push!(seen, x)\n                push!(seen, y)\n            end\n\
    \        end\n    end\n    seen\nend\n</code>\n<|/ a tags=julia,set-operations\
    \ dscore=2 |>\n<| a dscore=2 tags=julia,set-operations |>\nAnother option is the\
    \ set-operations.jl package in Julia's Macro ecosystem:\n<code>\njulia> using\
    \ SetOperations", "    if l1 == [] && l2 == [] \n        return [] \n    end\n\
    \    common_length = length(l1)\n    if common_length == 0 \n        return l2\
    \ \n    end\n    i = 0\n    j = 0\n    common_element = l1[0]\n    common_length\
    \ = length(common_element)\n    while i < common_length \n        if l1[i] ==\
    \ l2[j] \n            if i == j \n                i += 1\n                j +=\
    \ 1\n                common_element = l1[i] \n                common_length =\
    \ length(common_element) \n            else\n                i += 1\n        \
    \    end\n        else\n            i += 1\n        end\n    end\n    j = common_length\n\
    \    while j > 0 \n        if l1[j] == l2[j] \n            if j == common_length\
    \ \n                j -= 1 \n                common_element = l1[j] \n       \
    \         common_length = length(common_element) \n            else\n        \
    \        j -= 1 \n            end\n        else\n            j -= 1 \n       \
    \ end\n    end\n    return common_element\nend\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ is a good solution, however, it only works on vectors that have a length of\
    \ 2.\n<|/ c |>\n<| c |>\n, thanks for pointing out the error, I've fixed it by\
    \ adding a check for `l1` and `l2` length before calling the function.\n<|/ c\
    \ |>\n<| c |>\nThe function can be shortened to the following: `function common(l1::Vector{Int64},\
    \ l2::Vector{Int64})\n  if length(l1) < 1 || length(l2) < 1 \n    return []\n\
    \  elseif length(l1) == length(l2) \n    return l1\n  else\n    common_elements\
    \ = Dict()\n    for el in l1\n      if el in l2\n        common_elements[el] =\
    \ true\n      end\n    end\n    return values(common_elements)\n  end\nend`\n\
    <|/ c |>\n<| c |>\nNote that `return Dict()` in the first branch of the `if` statement\
    \ is redundant. `Dict()` returns an empty dict by default.\n<|/ c |>\n<| a tags=julia,vector\
    \ |>\nA slight modification of the method proposed by to take both arrays as arguments.\
    \ \nThe output can be sorted with sort(common_elements). \n<code>", "  set1 =\
    \ Set(l1)\n  set2 = Set(l2)\n  return intersect(set1, set2)\nend", "    n = length(l1)\n\
    \    idx = 1\n    r = []\n    for x in l1\n        while idx<n && x==l2[idx]\n\
    \            idx += 1\n        end\n        if idx == n\n            push!(r,\
    \ x) \n        else\n            push!(r, l2[idx])\n        end\n    end\n   \
    \ r\nend", "    common = Set{Int64}()\n    for x in l1\n        push!(common,\
    \ x)\n    push!(common, l2[1])\n    return Set{Int64}([x for x in common if length(l1[x])\
    \ >=\n                    length(l2[x]) and l1[l1.length()] == l2[l2.length()]])\n\
    end", "    \"\"\"\n    Sorted unique common elements.\n    >>> common([1, 4, 3,\
    \ 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    \"\"\"\n  \
    \  @assert length(l1) == length(l2) \"Vector lengths don\u2019t match.\"\n   \
    \ sorted = zip(l1,l2) \n    sorted = sort(sorted)\n    common = []\n    for el\
    \ in sorted \n        if el[1] != el[1]\n            common = [el[1]]\n      \
    \      break\n        end\n    end\n    return common\nend", "    @dsort{Int64}(l1)\
    \ & @dsort{Int64}(l2)\nend", "    for n in l1\n        occur_counter = Dict()\n\
    \        for v in l2\n            if occur_counter[v] == 0\n                occur_counter[v]\
    \ = 1\n                break\n            end\n        end\n        if occur_counter[n]\
    \ == 0\n            push!(common, v)\n        end\n    end\n    return common\n\
    end", "    s = sort(l1)\n    t = sort(l2)\n    k = length(l1)\n    l = length(l2)\n\
    \    if k != l\n        @error \"Vectors do not have the same length\"\n    end\n\
    \    a = s[1:k]\n    b = t[1:k]\n    return unique(a.^b)\nend", "    flag = zeros(Int,\
    \ length(l1)) + 1 \n    for i in eachindex(flag) \n        if l1[i] == l2[i] \n\
    \            flag[i] += 1\n        elseif l1[i] < l2[i] \n            flag[i]\
    \ = 1\n        else\n            flag[i] = 2\n        end\n    end\n    result\
    \ = zeros(Int64, length(l2))\n    for i in eachindex(flag)\n        if flag[i]\
    \ == 1 \n            result[i] = l1[i]\n        elseif flag[i] == 2 \n       \
    \     result[i] = l2[i]\n        end\n    end\n    return Vector{Int64}(result)\n\
    end\n</code>\n<|/ a tags=duplicates,sorting,julia |>\n<| c |>\nThis is very clever,\
    \ but you might want to use `if flag[i] == 1 \n            result[i] = l1[i]\n\
    \        elseif flag[i] == 2 \n            result[i] = l2[i]\n        else\n \
    \           result[i] = l1[i]\n        end` instead of `elseif` in the else branch.\n\
    <|/ c |>\n<| c |>\nGood catch! I was going to use `if` but couldn't think of a\
    \ good way to avoid the problem with duplicate values. I changed my answer to\
    \ use `if` instead of `elseif`.\n<|/ c |>\n<| a dscore=1 |>\nI modified the code\
    \ to solve the problem that multiple copies are being inserted when two numbers\
    \ appear in the same index position. The updated code is listed below:\n<code>",
  "   x = sort(l1)\n   y = sort(l2)\n   z = set(x,y)\n   z = filter(x -> x != y, z)\n\
    \   return sort(z)\nend", "    \n    n = length(l1)\n    m = length(l2)\n    \n\
    \    common = Vector{Int64}()", "    if length(l1) < length(l2) then return l1\
    \ else return l2\n    len1 = length(l1)\n    len2 = length(l2)\n    i = 0\n  \
    \  j = len2-1\n    while i < len1 and j < len2\n        if l1[i] == l2[j]\n  \
    \          i += 1\n            j += 1\n        elseif l1[i] < l2[j]\n        \
    \    i += 1\n        else\n            j -= 1\n        end\n    end\n    if i\
    \ == len1\n        return l2[j+1:]\n    elseif j == len2\n        return l1[i+1:]\n\
    \    else\n        return l1[i:j]\n    end\nend", "    if l1 == [] && l2 == []\
    \ \n    else if l1 == [] && l2 != [] \n    else if l2 != [] && l1 == [] \n   \
    \ else if l2 != [] && l1 == [] \n    else if l1[1] == l2[1] \n    else common(l1[1:end-1],\
    \ l2[1:end-1]) \n    else l1[1:end-1] == l2[1:end-1] ? l1[2:end] : [l1[1], l2[1]]\
    \ \n    end\nend\n</cell>\n<text>\n4.5.3 Merge Sort\nGiven two vectors, merge\
    \ them in sorted order and return the result.", "    res = Set{Int64}()\n    for\
    \ elt in l1 ++ l2\n        insert(res, elt)\n    end\n    sort(res)\n    return\
    \ res\nend", "    len = length(l1)\n    if len != length(l2)\n        println(\"\
    Vector length is different\")\n        return Int[]\n    end\n    set1 = unique(sort(l1))\n\
    \    set2 = unique(sort(l2))\n    return set1 \u222A set2\nend\n    return common(l1,\
    \ l2)\nend\n</cell>\n<text>\n4.4 How many times a character appears in the input\
    \ file? Write a function to do that", "    i, j ,k = 0, 0, 0\n    common = Array{Int64,1}()\n\
    \    while i < length(l1) and j < length(l2) do\n        if l1[i] == l2[j] then\n\
    \            common = common+[l1[i]]\n            i = i + 1\n            j = j\
    \ + 1\n        elseif l1[i] > l2[j] then\n            k = j\n        else\n  \
    \          i = i + 1\n        end\n    end\n    if i == length(l1) then\n    \
    \    common = common + [l1[i]]\n    elseif i == length(l2) then\n        common\
    \ = common + [l2[j]]\n    else\n        common = common + [l1[i]]\n    end\n \
    \   common = common+[l2[j]]\n    return common\nend\nend\n</code>\n<|/ a tags=julia\
    \ dscore=4 |>\n<| a |>\nTo do this, I would use a Set, as this is what it's designed\
    \ to do:\n<code>\njulia> a = Set([1, 2, 3, 4, 5])\nSet([1, 2, 3, 4, 5])", "  \
    \  ind1 = findall(l1 == l2)\n    ind2 = findall(l2 == l1)\n    for i in ind2\n\
    \        l2[i] = l1[i]\n    end\n    return l2\nend", "    \n    # return empty\
    \ list if either list is empty\n    if length(l1) == 0 || length(l2) == 0 \n \
    \       return Vector{Int64}()\n    end", "    if l1 == l2\n        return l1\n\
    \    i = -1\n    j = -1\n    \n    while true\n        if l1[i] == l2[j]\n   \
    \         i += 1\n            j += 1\n        elseif l1[i] > l2[j]\n         \
    \   i += 1\n        else\n            j += 1\n        end\n        if i == length(l1)\n\
    \            return l1[j:]\n        end\n    end\nend\n</cell>\n<text>\nIntersection\
    \ of two vectors\nFind the intersection between two vectors given two indices\
    \ in each vector.", "    a1 = sort(l1)\n    a2 = sort(l2)\n    a = a1[findall(!(i\
    \ == j) for i in a1 & a2, ind.(a1 & a2))]\nend\n</code>\nTo explain this a bit\
    \ further, sort sorts the vector.  And unique only returns unique elements.\n\
    And I used ind.(a1 & a2) because that's a little tricky to explain.  Basically\
    \ it finds the indices of the unique elements of a1 & a2.  And then you can use\
    \ ind to get the indexes of the unique elements from the vector.\nThis should\
    \ take care of your issue.\n<|/ a tags=combinations,permutation,performance,julia\
    \ |>\n<| c |>\nThank you for the fast response! The performance improvements were\
    \ quite significant. I will take into account the comments from and I will test\
    \ the solution with some random input data.\n<|/ c |>\n<| c |>\nOne thing that\
    \ I should mention is that if you have more than two vectors, you will have to\
    \ put them in a tuple: common((v1, v2, v3))\n<|/ c |>\n<| c |>\nWhat is the purpose\
    \ of using `ind.` here?  Seems to me that `a1[findall(!(i == j) for i in a1 &\
    \ a2, ind.(a1 & a2))]` would just as well have been written `a1[findall(!(i ==\
    \ j) for i in a1 & a2)]`?\n<|/ c |>\n<| c |>\nThe reason I didn't use ind.(a1\
    \ & a2) is because I wanted to show the indexes of the unique elements, not the\
    \ unique elements.  If you use ind.(a1 & a2) you get the unique elements of the\
    \ intersection of the vectors, not of the intersection of the unique elements.\n\
    <|/ c |>\n<| a |>\nFor those who are interested in performance, here are the results\
    \ from benchmarking with Julia 1.5.1:\n<code>\nusing BenchmarkTools\nusing Base.Iterators",
  "    \n    uniq = Set()\n    for i in l1:\n        if i \u2209 uniq\n          \
    \  push uniq, i\n        end\n    end\n    uniq = Set()\n    for i in l2:\n  \
    \      if i \u2209 uniq\n            push uniq, i\n        end\n    end\n    uniq\n\
    end\n</cell>\n<text>\nThis solution is O(n). However, we can improve the performance\
    \ a bit if we do better with another data structure. We could use a hash table,\
    \ which maps each value to its position in the sorted list. The code will look\
    \ like this:", "    # TODO vectorize this\n    common = Vector{Int64}()\n    for\
    \ i in eachindex(l1)\n        if l2[i] != -1 && l2[i] < l1[i]\n            common\
    \ = [common[i], l2[i]]\n        end\n    end\n    common\nend\n</code>\n<|/ a\
    \ tags=julia,performance |>\n<| c |>\nI believe the performance of common should\
    \ be higher than my solution, no?\n<|/ c |>\n<| c |>\nI ran this comparison with\
    \ `l1 = rand(1:1000, 100); l2 = rand(1:1000, 100); function common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64}\n    # TODO vectorize this\n    common = Vector{Int64}()\n\
    \    for i in eachindex(l1)\n        if l2[i] != -1 && l2[i] < l1[i]\n       \
    \     common = [common[i], l2[i]]\n        end\n    end\n    common\nend` and\
    \ got `l1 = rand(1:1000, 100); l2 = rand(1:1000, 100); function common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64}\n    # TODO vectorize this\n    common = Vector{Int64}()\n\
    \    for i in eachindex(l1)\n        if l2[i] != -1 && l2[i] < l1[i]\n       \
    \     common = [common[i], l2[i]]\n        end\n    end\n    common\nend", " \
    \   \n    local l1=l1 \n    local l2=l2\n    l1=sort(l1) \n    l2=sort(l2) \n\
    \ \n    local common=zeros(0)\n    local i=1\n    while i <= length(l1) and i\
    \ <= length(l2) do\n        if l1[i] == l2[i] then\n            common=union(common,\
    \ i)\n        end\n        i=i+1\n    end\n    return common\nend", "    \n  \
    \  common=Vector{Int64}() \n    common=findnat(sort(l1), sort(l2))\nend", "  \
    \  \n    flag1 = zeros(Bool, length(l1))\n    flag2 = zeros(Bool, length(l2))",
  "  \n    if length(l1) > length(l2) \n        return common(l2, l1)\n    end\n \
    \   result = Vec{Int64}(undef, length(l1))\n    for k in 1:length(l1)\n      \
    \  if l1[k] == l2[k]\n            result[k] = l1[k]\n        else\n          \
    \  for j in 1:length(l2) \n                if l2[j] == l1[k] \n              \
    \      result[k] = l2[j]\n                end\n            end\n        end\n\
    \    end\n    result\nend", "    return sort(union(l1, l2), dims=2)\nend\n</cell>\n\
    <text>\nExercise 4\nWrite a function that returns the number of times each element\
    \ in a vector appears.", "   if l1 == l2\n       return l1\n   else\n       return\
    \ sort(sort(l1), sort(l2))\n   end\nend", "    i, j = 0, 0\n    l = length(l1)\n\
    \    l = length(l2)\n    res = zeros(l)\n    while i < l\n        if l1[i] ==\
    \ l2[j]\n            res[i] = l1[i]\n            i += 1\n            j += 1\n\
    \        elseif l1[i] > l2[j]\n            i += 1\n        else\n            j\
    \ += 1\n        end\n    end\n    return res\nend\n</cell>\n<code language=julia-1.5>",
  "    if length(l1) != length(l2) \n        return [] \n    i = j = 0 \n    sz =\
    \ length(l1) \n    while i < sz \n        if l1[i] == l2[j] \n            i =\
    \ i + 1 \n            j = j + 1 \n        else \n            i = i + 1 \n    \
    \        j = j \n        end\n    end\n    return [l1[i], l2[j]] \nend", "   \
    \ common1 = Set.Set()\n    common2 = Set.Set()\n    for x in l1\n        push!(common1,\
    \ x)\n    end\n    for x in l2\n        push!(common2, x)\n    end\n    return\
    \ unique([x for x in common1 if x in common2])\nend", "      =     \n      sort(l1)\
    \ + sort(l2)\nend", "    l = length(l1)\n    m = length(l2)\n    \n    if (l ==\
    \ 0) return l2\n    if (m == 0) return l1", "    common = Vector{Int64}()\n  \
    \  for e in l1\n        if e in  l2 \n            push!(common, e)\n        end\n\
    \    end\n    common\nend\nend\n</code>\n<|/ a dscore=2 tags=julia,algorithm |>\n\
    <| a tags=julia,algorithm dscore=2 |>\nIf efficiency is your concern, you should\
    \ consider using broadcasting to get the common elements in two arrays:\n<code>",
  "    \n    i = Set()\n    j = Set()\n    \n    for x in l1 do\n        push!(i,\
    \ x)\n    end\n    for x in l2 do\n        push!(j, x)\n    end\n    \n    union!(i,\
    \ j)\n    \n    return collect(i) - collect(j)\nend\n</cell>\n<text>\nThe function\
    \ above works by constructing two sets containing the elements of both vectors.\
    \ Then, it joins them together by using the union operator. Then, it returns a\
    \ new vector containing the elements that are unique to each vector.", "    l1\
    \ = sort(l1) \n    l2 = sort(l2)\n    \n    return setdiff(union(l1, l2), intersection(l1,\
    \ l2))\nend", "    s = l1\n    for i = 1:length(l2)\n        push!(s, l2[i])\n\
    \    end\n    sort(s)\n    return s\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    This was my first thought too, however it does not work for me. `common([5,3,1,3],\
    \ [4,6,1])` yields `[3, 3, 1, 6]`.\n<|/ c |>\n<| c |>\nthanks for pointing out,\
    \ I missed the fact that order matters. I fixed my answer.\n<|/ c |>\n<| a tags=arrays,julia,algorithm\
    \ |>\nA Julia implementation of Boyer-Moore algorithm as suggested by Ilya Bochkaryov:\n\
    <code>\nusing Base.Iterators", "    \n    if l1 == l2\n        return l1\n   \
    \ end", "\ti1, i2 =  length(l1), length(l2)\n\tl1, l2 = map(sort, [l1, l2])\n\t\
    c1, c2 = 0, 0\n\twhile i1 > 0 && i2 > 0\n\t\t(c1 == 0) ? (c2 = l1[c1]) : (l1[c1],\
    \ c2 = l1[c2])\n\t\t(c1 == 0) ? (c2 = l2[i2]) : (l2[c2], c2 = l2[i2])\n\t\tl1[c1],\
    \ l2[c2] = l1[c2], l1[c1]\n\t\ti1 -= 1\n\t\ti2 -= 1\n\tend\n\tl1[c1:end], l2[c2:end]\
    \ = l2[c2:end], l1[c1:end]\n\treturn l1\nend", "   \n     \n    \n    common =\
    \ sort(sort(l1), sort(l2))\n    common = unique([c for c in common if c != 0])\n\
    \    common = setdiff(common, l1)\n    return common\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Return sorted unique common elements for two arrays.\n    >>> common([1,4,3,34,653,2,5],\
    \ [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3,\
    \ 2])\n    [2, 3]", "    indxs = find((l1 .== l2).+0)\n    return l1[indxs].'\n\
    end \n</cell>\n<code language=julia-0.6>", "    \"\"\"\n    Return the sorted\
    \ unique common elements for two vectors.\n    >>> common([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8],\
    \ [3, 2])\n    [2, 3]\n    \"\"\"\n    if l1==[] || l2==[]\n        return []\n\
    \    \n    flag = [false]*length(l1)\n    flag[1] = true\n    flag[2] = true\n\
    \    flag[4] = true\n    flag[5] = true\n    flag[length(l1)] = true", "  a1=collect(l1)\n\
    \  a2=collect(l2)\n  a1=removeDuplicates(a1)\n  a2=removeDuplicates(a2)\n  a1=sort(a1)\n\
    \  a2=sort(a2)\n  return a1\nend", "    return sort(intersect1d(l1, l2))\nend",
  "    common = @union(l1, l2)\n    if length(common) < length(l1)\n        common\
    \ = common[ones(length(common), 1)]\n    end\n    common\nend\n</code>\n<|/ a\
    \ tags=julia,vector,element,unique |>\n<| c |>\nThe `sort!` function can be applied\
    \ to `common` to get rid of the extra sort\n<|/ c |>\n<| c |>\nYeah I noticed\
    \ that but couldn't find how to do it. I have updated the code.\n<|/ c |>\n<|\
    \ c |>\nThe `sort!` function can actually be applied to the resulting array (instead\
    \ of `common`) so that it preserves the original order, e.g. `sort!(common, inplace=true)`\n\
    <|/ c |>\n<| c |>\nYes that is true as well, thanks for the tip\n<|/ c |>\n<|\
    \ a tags=julia,vector,element,unique |>\nI like's approach but wanted to try some\
    \ approaches that didn't involve the creation of an extra array. I was thinking\
    \ about a method that's also memory efficient and avoids the creation of the extra\
    \ array (which is what setdiff does internally):\n<code>\njulia> function common_nonarray(l1::Vector{Int64},\
    \ l2::Vector{Int64})\n           ind = setdiff(l1, l2)\n           if length(ind)\
    \ > 0\n               l1[ind]\n           else\n               l2\n          \
    \ end\n       end\ncommon_nonarray (generic function with 1 method)", "    a=sort(l1)\n\
    \    b=sort(l2)\n    common=Set()\n    for i=1:length(a)\n        if a[i]==b[i]\
    \ && i \u2209 common\n            push!(common, a[i])\n        end\n    end\n\
    \    return sort(common)\nend\nend\n</code>\n<|/ a dscore=2 tags=julia,performance,performance\
    \ |>\n<| a tags=julia,performance,performance |>\nI assume your data is stored\
    \ as arrays and you need a sorted result. Here's an implementation that runs about\
    \ twice faster than your original approach, on both small and big arrays. On my\
    \ machine it runs about 3x faster than the other solution. On the other hand,\
    \ it's also quite readable and probably much shorter:\n<code>", "    n = l1+l2\n\
    \    m = l1-l2\n    return if n==m \n    i, j = findfirst(i->l1[i]<=l2[j], n)\n\
    \    common = (i==j) ? [] : l1[min(i,j):max(i,j)]\n    common, n = min(n, m),\
    \ m\n    return common\nend\n</cell>\n<code language=julia-1.5>", "    \n    intersect\
    \ = Set.intersection(l1, l2)\n    return Set(l1) & Set(l2) ", "    len1 = length(l1)\n\
    \    len2 = length(l2)\n    \n    if len1 == 0 || len2 == 0\n        return Int64[]\n\
    \    end1 = end(l1)\n    end2 = end(l2)\n    if end1 > end2\n        return l1[end1:end]\n\
    \    else\n        return l2[end2:end]\n    end\nend", "    # unfortunately in\
    \ Julia the common function does not work for Int64, so\n    # here we manually\
    \ do the type conversion\n    l1 = Int64(l1) \n    l2 = Int64(l2) \n    union(l1,l2)\n\
    \    ind1, ind2 = find(l1==l2), find(l2==l1)\n    ind1 = ind1[findmin(ind2)[2]]\
    \ \n    l1[ind1] = l2[ind1]\n    l2[ind2] = l1[ind2]\n    return l1, l2\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a |>\nThis works as well:\n<code>", "  if l1 ==\
    \ l2\n    return l1 \n  elseif l1[1] == l2[1]\n    return common(l1[2], l2[2])\n\
    \  elseif l1[2] == l2[2]\n    return common(l1[3], l2[3])\n  end\n  if l1[1] <\
    \ l2[1]\n    return common(l1, l2[2])\n  elseif l1[2] < l2[2]\n    return common(l1[2],\
    \ l2)\n  elseif l1[3] < l2[3]\n    return common(l1[3], l2[3])\n  end\n  return\
    \ l1\nend\n\"\"\"\n    common([5, 3, 2, 8], [3, 2])\n\"\"\"\nVector{Int64} = common([5,\
    \ 3, 2, 8], [3, 2])", "    zip = zip(l1,l2)\n    common=[];\n    for (i1,i2)in\
    \ zip\n        if i1 i2 != 0\n            push!(common, i1)\n            push!(common,\
    \ i2)\n        end\n    end\n    sort(common)\nend", "    common_set = Set{Int64}(l1)\n\
    \    common_set = intersect(common_set, Set{Int64}(l2))\n    common_set |> collect{v->[v]}\n\
    end", "\"\"\"\n    local common=Vector{Int64}()\n    for i in unique(l1) do\n\
    \        for j in unique(l2) do\n            common=union( common, [i, j])\n \
    \       end\n    end\n    return common\nend", "\tn = length(l1)\n\tm = length(l2)\n\
    \tcommon = Vector{Int64}()\n\tfor i= 1:n\n\t\ti1 = l1[i]\n\t\tfor j= 1:m\n\t\t\
    \tj1 = l2[j]\n\t\t\tif i1 == j1\n\t\t\t\tpush!(common, i1)\n\t\t\t\tbreak\n\t\t\
    \tend\n\t\tend\n\tend\n\treturn common\nend", "    a = sort!(l1)\n    b = sort!(l2)\n\
    \    common_values = setdiff(a,b)\n    return common_values\nend\n</cell>\n<text>\n\
    Example", "    l1=l1[!ismissing(l1)];l2=l2[!ismissing(l2)];\n    res=sort(l1-l2);\n\
    \    res=setdiff(res,l1); res=setdiff(res,l2);\n    return res\nend", "    sorted\
    \ = sort(l1)\n    unique = sort(unique(sorted))\n    common = sort(intersect(unique,l2))\n\
    \    return common\nend", "    result = Set()\n    for a in l1\n        if !haskey(l2,a)\n\
    \            result.add(a)\n        end\n    end\n    for a in l2\n        if\
    \ !haskey(l1,a)\n            result.add(a)\n        end\n    end\n    return result\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI tried to test this by making a `v1\
    \ = Vector{Int64}([5,5,5,5])` vector and `v2 = Vector{Int64}([4,4,4])` and then\
    \ `common(v1,v2)` but got an error: `type mismatch: expected Vector{Int64} got\
    \ Array{Any,1}`.\n<|/ c |>\n<| c |>\nSorry, I missed that `Vector` has an indexing\
    \ operator as well. My bad.\n<|/ c |>\n<| c |>\nIf you don't want to create new\
    \ sets, you can use  \n`for v in v1 \n    if !haskey(v2) \n      push!(result,v)\
    \ \n    end \n  end`\n<|/ c |>\n<| c |>\nAlso note that `Set` is unordered set,\
    \ so you should use something like `Set{Int}` or `Set{Int64}` (or `Set{Integer}`)\
    \ if you need order.\n<|/ c |>\n<| a tags=performance,julia,set,arrays |>\nI think\
    \ I got something that is significantly faster, though I'm still not sure how\
    \ to get around a type error. \n<code>", "    result = common(l1, l2)\n    if\
    \ isempty(result)\n        result = [x for y in l1 for x in y]\n    end\n    return\
    \ result\nend", "    uniq(sort(union(l1, l2)), sorted = true)\nend", "  l1.+=(l2==0)\n\
    \  l2.+=(l1==0)\n  i1 = 1:length(l1)\n  i2 = 1:length(l2)\n  l1.-=(l1==0)\n  l2.-=(l2==0)\n\
    \  l1.+=(l2!=0) ; l2.+=(l1!=0)\n  u1=sort(l1) \n  u2=sort(l2)\n  l1.-=(l1==0)\n\
    \  l2.-=(l2==0)\n  return u1[i1&u2] \nend", "    l1 = sort(l1) \n    l2 = sort(l2)\
    \ \n    length = maximum(length(l1), length(l2)) \n    return filter( x -> x <\
    \ length, product(l1, l2))\nend\n</code>\n<|/ a |>\n<| c |>\nHow would you write\
    \ this without using sort, filter and product?\n<|/ c |>\n<| c |>\nSorted the\
    \ vectors then iterated over both vectors and compared the elements.  This is\
    \ not O(n) but still O(n) because the sorting is amortized O(n log n).\n<|/ c\
    \ |>\n<| c |>\n: I added a solution without sorts and products.\n<|/ c |>\n<|\
    \ c |>\n, your second function returns `[]` when given an empty list, which is\
    \ not what OP was expecting. It also seems like it could be done with a one-liner\
    \ using `filter`, or possibly using `zip` instead. I can't see any such one-liner.\n\
    <|/ c |>\n<| a tags=julia,set |>\nHere is an O(n) solution that should be pretty\
    \ efficient:\n<code>", "    common = Set()\n    for e in l1\n        common =\
    \ common:union(l2[ e == common])\n    end\n    common\nend", "    if l1==[] \n\
    \        return l2 \n    else \n        return l1 ++ l2 -- common(l1[1:end-1],\
    \ l2)\nend", "    \n    # sort the vectors\n    sorted_a = sort(l1)\n    sorted_b\
    \ = sort(l2)\n    \n    # return unique common elements\n    intersection = Set(sorted_a)\
    \ & Set(sorted_b)\n    [v for v in intersection]\nend\nend\n</cell>\n<code language=julia-1.3>\n\
    ## Example of use of common\n## 1. Find common elements for two lists\n## 2. Print\
    \ common elements", "    \n    l = length(l1)\n    li = length(l2)\n    \n   \
    \ lmn = min(l, li)\n    \n    i = zeros(lmn+1, Int64)\n    j = zeros(lmn+1, Int64)\n\
    \    \n    lcnt = zeros(lmn+1, Int64)\n    \n    cnt = 0\n    \n    for ix in\
    \ 1:lmn\n        lcnt[ix] = lcnt[ix-1] + l1[ix]\n        for jx in 1:li\n    \
    \        if l2[jx] == l1[ix]\n                j[ix] = j[ix-1]\n            else\n\
    \                i[ix] = i[ix-1]\n                j[ix] = j[ix-1]\n          \
    \      cnt += 1\n            end\n        end\n    end\n    \n    i[1] = cnt\n\
    \    \n    return [i;j];\nend\n</cell>\n<code language=julia-1.5>", "    result\
    \ = sort(l1, l2)\n    idx = findfirst(x -> x != result[x], 2:end)\n    result[idx\
    \ + 1]\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nFor small arrays the answer\
    \ from is much faster.\n<|/ c |>\n<| c |>\nYes, it is! However, your answer seems\
    \ more memory efficient so I accepted it.\n<|/ c |>\n<| a dscore=1 |>\nYou can\
    \ use the following function\n<code>", "        common = Set.union(l1, l2)\n \
    \       common_ = Set.union(common, Set(l1))\n        common_ = Set.union(common_,\
    \ Set(l2))\n        return common_\nend\n</code>\n<|/ a tags=julia,vector,arrays\
    \ |>\n<| c |>\nThanks for your answer. Can you please explain this part `@inbounds\
    \ @simd for i in 1:length(r1)` ?\n<|/ c |>\n<| c |>\n`@inbounds` means a for loop.\
    \ Inside of it I iterate over `r1` with index `i`. It's a way of making a `for`\
    \ loop without needing to write a `for` loop in Julia. `@simd` means `simd ` which\
    \ means for performance optimization. I am not sure what the benefit of this is\
    \ but I am pretty sure it saves a lot of time for calculating `length(r)` instead\
    \ of `length(r)[i]`.\n<|/ c |>\n<| c |>\nThe reason for this is: `@simd` allows\
    \ vectorized code - which means that it can do the same operation without writing\
    \ a for loop. `@inbounds` basically says this: \"the length of each of the vectors\
    \ should be the same. so I am doing this for performance.\n<|/ c |>\n<| c |>\n\
    So what is the benefit of using `@simd` instead of `@inbounds`?\n<|/ c |>\n<|\
    \ c |>\nThe reason why you use these two are mentioned in the comments above.\
    \ I think you can find this by googling \"julia simd\". I will edit my answer\
    \ to include this.\n<|/ c |>\n<| a |>\nHere is a more efficient solution:\n<code>",
  "    seen1 = Set()\n    seen2 = Set()\n    seen1 += l1 \n    seen2 += l2\n    common\
    \ = Set()\n    for a in seen1\n        if a in seen2\n            common += a\
    \ \n        end \n    end \n    return common\nend", "    [i for i in l1 where\
    \ i in l2]\nend", "    if length(l1) != length(l2) \n        error(\"Vectors must\
    \ have equal length\") \n    else \n        common = Set()\n        for i in l1\n\
    \            if i \u2209 l2\n                common = Set([i]) \n            else\
    \ \n                common = Set([i], common)\n        end\n        return common\
    \ \n    end\n    return []\nend", "    return sort(intersect(l1, l2))\nend", " \
    \   n1 = length(l1)\n    n2 = length(l2)\n    i = Int64(0)\n    j = Int64(0)\n\
    \    v = Int64(0)\n    if (n1 <= n2) \n        return l1\n    else\n        return\
    \ l2\n    end\n    while i < n1\n        while j < n2\n            if l1[i] ==\
    \ l2[j]\n                v = v + i\n                i = i + 1\n              \
    \  j = j + 1\n            else\n                j = j + 1\n            end\n \
    \       end\n        i = i + 1\n    end\n    while i < n1\n        v = v + i\n\
    \        i = i + 1\n    end\n    while j < n2\n        v = v + j\n        j =\
    \ j + 1\n    end\n    while j < n2\n        push!(ret, v)\n        j = j + 1\n\
    \    end\n    return ret\nend\n\"\"\"\n    common(l1::Vector{Int}, l2::Vector{Int})::Vector{Int}",
  "    result = copy(l1)\n    for x in l2\n        ind = find(result == x, 1, true)\n\
    \        result[ind] = null\n    end\n    result\nend", "    seen = Set()\n  \
    \  seen.add(false)\n    seen.add(false)\n    seen.add(false)\n    return l1 ++\
    \ l2 -- unfold(seen, 3)\nend", "    intersect(l1, l2)\nend\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nWhat is the problem with your solution? Can you explain in more\
    \ detail?\n<|/ c |>\n<| c |>\nThe code you wrote doesn't compile, the `intersect`\
    \ function does not exist.\n<|/ c |>\n<| a dscore=4 tags=julia,set-intersection\
    \ |>\n<code>", "    if length(l1) == 0 || length(l2) == 0 return l1\n    \n  \
    \  common = Vector{Int64}()\n    for e1 in l1\n        for e2 in l2\n        \
    \    if e1 == e2 && !contains(common, e1) && !contains(common, e2)\n         \
    \       push!(common, e1)\n            end\n        end\n    end\n    common\n\
    end", "    idx1 = 0\n    idx2 = 0\n    while idx1 < length(l1) && idx2 < length(l2)\n\
    \        if l1 == l2 \n            return l1\n        end\n        if l1[idx1]\
    \ != l2[idx2]\n            break\n        end\n        idx1 += 1\n        idx2\
    \ += 1\n    end", "    # Sorting and unique will be done in the function \"common\"\
    \n    # and will be passed to function \"common\"\n    l1 = sort(l1)\n    l2 =\
    \ sort(l2)\n    u1 = unique(l1)\n    u2 = unique(l2)\n    return common(u1, u2)\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a |>\nJust sort and uniq\n<code>\nsort(a)\
    \ == sort(unique(sort(a)))\n</code>\n<|/ a tags=algorithm,duplicates,sorting,unique,julia\
    \ dscore=2 |>\n<| c |>\nThanks. But this doesn't work for `a = [1, 4, 3, 34, 653,\
    \ 2, 5]`.\n<|/ c |>\n<| c |>\nI think you misunderstood my question. I know how\
    \ to use sort to remove duplicates and I know how to use unique to remove duplicates.\
    \ My question is asking how to remove duplicates from two sets (of integers) without\
    \ knowing which set has all the unique elements. For example, `a = [1, 4, 3, 34,\
    \ 653, 2, 5]` and `b = [5, 7, 1, 5, 9, 653, 121]`. The result should be `common([a,\
    \ b]) = [1, 5, 653]` because `[5, 7, 1, 5, 9, 653, 121]` contains all the elements\
    \ of `a`.\n<|/ c |>\n<| c |>\nAh, I didn't read the whole question when I answered\
    \ it.  I should have gone for reading the question more closely before answering!\n\
    <|/ c |>\n<| a tags=algorithm,duplicates,sorting,unique,julia |>\nYou can use\
    \ set union\n<code>\njulia> setdiff(set(a,b),set(a,b)) # removes elements from\
    \ a that are also in b\nSet{Int64}([34, 653, 5])", "    if length(l1) == length(l2)\n\
    \        common = l1\n    elseif length(l1) > length(l2)\n        common = l2\n\
    \    else\n        common = l1\n    end\n    seen = Set{Int64}()\n    result =\
    \ Set{Int64}()\n    for i in common\n        if !isempty(setdiff(seen, i))\n \
    \           result+=[i]\n        end\n        seen+=[i]\n    end\n    \n    return\
    \ result \nend\n</cell>\n<text>\n3.5 Vectorization\n3.5.1 Vectorizing function",
  "    \n    idx1::Int64 = 0\n    idx2::Int64 = 0", "    zipWith(=, zip(l1, l2))\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like it. I was looking for a function\
    \ that does a merge sort and your answer looks like a clean way to implement it.\
    \ Thanks for sharing this.\n<|/ c |>\n<| a |>\nThe solutions above are all O(n\
    \ log n).\nHere is a solution that uses O(1) space.\n<code>\n# Merge two sorted\
    \ vectors", "        local i, j = 0, 0\n        common = Vector{Int64}()\n   \
    \     while i < length(l1) && j < length(l2)\n            if l1[i] == l2[j]\n\
    \                push!(common, l1[i])\n                i += 1\n              \
    \  j += 1\n            elseif l1[i] < l2[j]\n                push!(common, l1[i])\n\
    \                i += 1\n            else\n                push!(common, l2[j])\n\
    \                j += 1\n            end\n        end\n        return common\n\
    end", "    common=[]\n    for (a,b) in zip(l1,l2) \n        if a==b\n        \
    \    common=[a]\n        else\n            if b>a\n                push!(common,b)\
    \ \n            else\n                push!(common,a) \n            end\n    \
    \    end\n    end\n    return common\nend\ncommon(l1::Vector{Int64}, l2::Vector{Int64})::Vector{Int64}\
    \ \n    common=[]\n    for (a,b) in zip(l1,l2) \n        if a==b\n           \
    \ common=[a]\n        else\n            if a>b\n                push!(common,a)\
    \ \n            else\n                push!(common,b) \n            end\n    \
    \    end\n    end\n    return common\nend", "    common = Set()\n    common |=\
    \ l1\n    common |= l2\n    return Set([i for i in common if l1[i] >= l2[i]])\n\
    end", "  if l1==l2 return l1\n  u1 =  unique(sort(l1))\n  u2 =  unique(sort(l2))\n\
    \  common = u1 .& u2\n  return common\nend", "    map(i->l1[i], unique([i for\
    \ v in l1 for i in find(l1==v)]))\nend", "    \n    len1=length(l1)\n    len2=length(l2)\n\
    \    i=0\n    j=0\n    l=Vector{Int64}()\n    while i<len1 && j<len2\n       \
    \ if l1[i]==l2[j]\n            push!(l,l1[i])\n            i=i+1\n           \
    \ j=j+1\n        else\n            if l1[i]<l2[j]\n                i=i+1\n   \
    \         else\n                j=j+1\n            end\n        end\n    end\n\
    \    while i<len1\n        push!(l, l1[i])\n        i=i+1\n    end\n    while\
    \ j<len2\n        push!(l, l2[j])\n        j=j+1\n    end\n    l\nend", "    sorted1\
    \ = sort(l1)\n    sorted2 = sort(l2)\n    common = Set{Int64}[]\n    \n    for\
    \ a in sorted1\n        if a in sorted2\n            push!(common, a)\n      \
    \  end\n    end\n    \n    common = sorted1[common]\n    return common\nend",
  "    res=Int64[]\n    for i in l1\n        for j in l2\n            if i==j\n  \
    \              push!(res, i)\n                break\n        end\n    end\n  \
    \  res\nend", "  result = new Vector{Int64}()\n  append!(result, find(l1) .==\
    \ find(l2) .== 0)\n  return result\nend", "    if l1!=l2 \n      new=[]\n    \
    \  ind = 0\n      for k in l1 \n        if contains(l2, k) \n          ind=ind\
    \ + 1\n        else\n          new[ind] = k\n        end\n      end\n      new\n\
    \    else \n      l2\n    end\nend", "    sorted = sort(l1)\n    sorted = sort(l2)\n\
    \    return setdiff(sorted, sorted)\nend \n</code>\nThis function uses setdiff\
    \ function to return unique common elements. \n<code>", "    a = Set(l1)\n   \
    \ b = Set(l2)\n    common = Set()\n    for n in a\n        if n in b\n       \
    \     common = Set((common << n) | b[n])\n        end\n    end\n    return common\n\
    end\n</code>\n<|/ a dscore=3 tags=set,julia |>\n<| a tags=set,julia |>\nA simple\
    \ approach is just using Sets.jl like this:\n<code>\njulia> using Sets", "   \
    \ \n    common_array = [i for i in l1 .- l2 if i .in l2 .- l1]\n    common_array\
    \ = [i for i in common_array if i != i]\n    common_array = [i for i in common_array\
    \ if i in l1]\n    return sort(common_array)\nend\n</cell>\n<code language=julia-1.0>\n\
    ## test on small vectors\n@time println(common([1, 4, 3, 34, 653, 2, 5], [5, 7,\
    \ 1, 5, 9, 653, 121]))\n@time println(common([5, 3, 2, 8], [3, 2]))\n</cell>\n\
    <code language=julia-1.0>\n## test on large vectors\n@time println(common([1,4,3,34,653,2,5,7,1,5,9,653,121,5,3,2,8],[3,2]))\n\
    </cell>\n<text>\nSorting vectors", "    res=Vector{Int64}()\n    if length(l1)==0\
    \ || length(l2)==0 return res\n    \n    len_1=length(l1)\n    len_2=length(l2)\n\
    \    \n    i=0\n    j=0\n    while i<len_1 && j<len_2\n        if l1[i]==l2[j]\n\
    \            push!(res, l1[i])\n            i=i+1\n            j=j+1\n       \
    \ else\n            i=i+1\n        end\n    end\n    \n    while i<len_1\n   \
    \     push!(res, l1[i])\n        i=i+1\n    end\n    \n    while j<len_2\n   \
    \     push!(res, l2[j])\n        j=j+1\n    end\n    \n    return res\nend\nend",
  "    return sortunique(intersect((l1, l2)))\nend\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"Compute Hamming distance between 2 strings\n    >>> hamming_distance(\"\
    hello\", \"hello\")\n    0\n    >>> hamming_distance(\"hello\", \"world\")\n \
    \   1\n    >>> hamming_distance(\"hello\", \"wo\")\n    1\n\"\"\"", "    commons\
    \ = Set()\n    for a in l1\n        commons = commons & (l1->isMember(a))\n  \
    \  end\n    for b in l2\n        commons = commons & (l2->isMember(b))\n    end\n\
    \    return sort(collect(commons))\nend\n</code>\n<|/ a tags=performance,julia,vector,intersection,set-intersection\
    \ |>\n<| c |>\nWhile this may solve the problem, you should include an explanation\
    \ of the code and how it solves the problem.\n<|/ c |>\n<| c |>\nI thought that\
    \ the only difference between this and that in the answer is that they are using\
    \ `Set` to keep all the unique elements of both.\n<|/ c |>\n<| a dscore=2 |>\n\
    This might not be the best solution, but is efficient and does what you want:\n\
    <code>", "    uniq = Set{Int64}(Set([l1, l2]) - Set([l1] + l2))\n    sort(uniq)\n\
    \    return uniq\nend", "    if length(l1) != length(l2) \n        raise ArgumentError(\"\
    Vectors must be of same length\")\n    if length(l1) == 0 \n        return l2\
    \ \n    end\n    sorted1 = sortperm(l1)\n    sorted2 = sortperm(l2)\n    # Since\
    \ common() should return the sorted unique elements in l1, and \n    # l2 common\
    \ to both, it should sort it again and return it.\n    # Otherwise, common() will\
    \ never terminate\n    sorted1 = reverse(sortperm(sorted1))\n    sorted2 = reverse(sortperm(sorted2))\n\
    \    common = sortperm(intersect(sorted1, sorted2))\n    return common\nend",
  "    common = Set()\n    n1 = length(l1)\n    n2 = length(l2)\n    i1::Int64 = 1\n\
    \    i2::Int64 = 1\n    while i1 < n1 && i2 < n2 do\n        if l1[i1] == l2[i2]\
    \ then\n            common += l1[i1]\n            i1 += 1\n            i2 += 1\n\
    \        else if l1[i1] < l2[i2] then\n            i1 += 1\n        else \n  \
    \          i2 += 1\n        end\n    end\n    while i1 < n1 do\n        common\
    \ += l1[i1]\n        i1 += 1\n    end\n    while i2 < n2 do\n        common +=\
    \ l2[i2]\n        i2 += 1\n    end\n    common\nend", "    l = length(l1)\n  \
    \  m = length(l2)\n    \n    if l == 0 || m == 0\n        return Int64[]\n   \
    \ end", "  if l1 == l2 then return l1 else return union(l1, l2)\nend", "    if\
    \ length(l1) < length(l2)\n        common(l1, l2)\n    elseif length(l1) > length(l2)\n\
    \        common(l2, l1)\n    elseif l1==l2\n        []\n    else\n        sort(union(l1,\
    \ l2))\n    end\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nIt might be interesting\
    \ to add a benchmark to the answer - I'm guessing there might be some differences,\
    \ although the question didn't specify any such benchmark.\n<|/ c |>\n<| c |>\n\
    Added benchmarks to the answer based on your feedback. Thanks for your feedback.\n\
    <|/ c |>\n<| c |>\nI'm just curious: is `l1==l2` really better than `l1!=l2` ?\n\
    <|/ c |>\n<| a |>\nIn case you use Julia v0.6 (most likely you do), you can use\
    \ the following code:\n<code>\njulia> function common(l1::Vector{Int64}, l2::Vector{Int64})::Vector{Int64}\
    \ \n           if length(l1) > length(l2)\n               common(l2, l1)\n   \
    \        elseif length(l1) < length(l2)\n               common(l1, l2)\n     \
    \      elseif l1==l2\n               []\n           else\n               sort(union(l1,\
    \ l2))\n           end\n       end\ncommon (generic function with 1 method)",
  "    \n    \n    \n    if l1 == l2\n        return [l1]\n    else\n        \n  \
    \      common = Set()\n        if l1 == l2\n            common = [l1]\n      \
    \  elseif length(l1) < length(l2)\n            common = union(l1, l2)\n      \
    \  else\n            common = union(l2, l1)\n        end\n        \n        common\
    \ = sort(common)\n    end\n    \n    return common\n    \nend", "    ind=findfirst(l1<l2)\n\
    \    if ind == -1 then ind=findfirst(l1==l2) else ind=ind\n    if ind == -1 then\
    \ return [] else return l1[ind] \nend\n    ", "      l = length(l1)\n      m =\
    \ length(l2)\n      \n      if m == 0 || l == 0\n        return []\n      end\n\
    \      \n      x = l1[1]\n      y = l2[1]\n      \n      c = Vector{Int64}(m)\n\
    \      \n      for i in 1:m\n        if x == y\n          c[i] = x\n        else\n\
    \          continue\n        end\n      end\n      \n      return c\nend\n   \
    \   \n      \n      \n    \"\"\"\nReturn sorted unique common elements for two\
    \ vectors.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n\
    \    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]", "    l1 =\
    \ sort(l1)\n    l2 = sort(l2)\n    common = setdiff(union(l1, l2), setdiff(union(l2,\
    \ l1), l2))\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
