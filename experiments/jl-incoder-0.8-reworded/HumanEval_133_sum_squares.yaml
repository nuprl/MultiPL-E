name: HumanEval_133_sum_squares
language: jl
prompt: "\"\"\"You are given a vector of numbers.\n    You need to return the sum\
  \ of squared numbers in the given vector,\n    round each element in the vector\
  \ to the upper int(Ceiling) first.\n    Examples:\n    >>> lst([1.0, 2.0, 3.0])\n\
  \    14\n    >>> lst([1.0, 4.0, 9.0])\n    98\n    >>> lst([1.0, 3.0, 5.0, 7.0])\n\
  \    84\n    >>> lst([1.4, 4.2, 0.0])\n    29\n    >>> lst([-2.4, 1.0, 1.0])\n \
  \   6\n    \n\n    \"\"\"\nfunction sum_squares(lst::Vector{Float64})::Int64 \n"
tests: "using Test\n\n@testset begin\n\ncandidate = sum_squares;\n\t@test(candidate([1.0,\
  \ 2.0, 3.0]) == 14)\n\t@test(candidate([1.0, 2.0, 3.0]) == 14)\n\t@test(candidate([1.0,\
  \ 3.0, 5.0, 7.0]) == 84)\n\t@test(candidate([1.4, 4.2, 0.0]) == 29)\n\t@test(candidate([-2.4,\
  \ 1.0, 1.0]) == 6)\n\t@test(candidate([100.0, 1.0, 15.0, 2.0]) == 10230)\n\t@test(candidate([10000.0,\
  \ 10000.0]) == 200000000)\n\t@test(candidate([-1.4, 4.6, 6.3]) == 75)\n\t@test(candidate([-1.4,\
  \ 17.9, 18.9, 19.9]) == 1086)\n\t@test(candidate([0.0]) == 0)\n\t@test(candidate([-1.0])\
  \ == 1)\n\t@test(candidate([-1.0, 1.0, 0.0]) == 2)\nend\n"
completions: ["    sum=0\n    for i in lst\n        sum = sum+i*i\n    return sum\n\
    end # function sum_squares(lst::Vector{Float64})::Int64", "    res = 0.0\n   \
    \ for x in lst\n        res = res + x^2 \n    end\n    return round(res)\nend",
  "    for i in lst\n        sum = i + i\n        sum += i\n    end\n    return sum\n\
    end", "    sum = 0\n    for x in lst\n        sum += x^2\n    end\n    return\
    \ sum\nend\n\"\"\"\n>>> lst = [1.0, 2.0, 3.0]\n>>> sum_squares(lst)\n14.0\n>>>\
    \ lst = [1.0, 4.0, 9.0]\n>>> sum_squares(lst)\n98.0\n>>> lst = [1.0, 3.0, 5.0,\
    \ 7.0]\n>>> sum_squares(lst)\n84.0\n>>> lst = [1.4, 4.2, 0.0]\n>>> sum_squares(lst)\n\
    29.0\n>>> lst = [-2.4, 1.0, 1.0]\n>>> sum_squares(lst)\n6.0\n\"\"\"", "    sum_sq\
    \ = 0.0\n    for x in lst\n        sum_sq = sum_sq + pow(x,2)\n    return sum_sq\n\
    end\n</cell>\n<code language=julia-1.0>\n# run this cell and click on the link\
    \ to see the answer\n@time sum_squares([1.0,2.0,3.0,4.0])\n</cell>\n<text>\nProblem\
    \ 2\nWrite a function that returns the sum of the squares of the numbers in the\
    \ given vector.", "    total=0\n    for i in lst\n        total+=i*i\n    end\n\
    \    return total\nend\n</cell>\n<code language=julia-1.1>\nsum_squares(lst_1)\n\
    </cell>\n<text>\nProblem 7", "\tsum=0\n\tfor item in lst \n\t\tsum += item*item\n\
    \tend\n\treturn sum\nend", "    sum = 0.\n    for i in lst \n        sum = sum\
    \ + i*i\n    end\n    \n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    sum_squares([1.0, 2.0, 3.0])\n</cell>\n<code language=julia-1.5>\nsum_squares([1.0,\
    \ 4.0, 9.0])\n</cell>\n<code language=julia-1.5>\nsum_squares([1.0, 3.0, 5.0,\
    \ 7.0])\n</cell>\n<code language=julia-1.5>\nsum_squares([1.4, 4.2, 0.0])\n</cell>\n\
    <code language=julia-1.5>\nsum_squares([-2.4, 1.0, 1.0])\n</cell>\n<text>\nTask.\
    \ Write a function, that returns the sum of the positive elements in the given\
    \ vector", "    \n    sum_ = 0", "  sum=0\n  for element in lst\n    sum=sum+element*element\n\
    \  end\n  return sum\nend", "    sum = 0\n    for i in lst\n        sum = sum\
    \ + i^2\n    end\n    return sum\nend", "    return sum(x.^2 for x = lst) \nend\n\
    </cell>\n<code language=julia-1.5>\nsum_squares([1.0, 2.0, 3.0])\n</cell>\n<code\
    \ language=julia-1.5>\nsum_squares([1.0, 4.0, 9.0])\n</cell>\n<code language=julia-1.5>\n\
    sum_squares([1.0, 3.0, 5.0, 7.0])\n</cell>\n<code language=julia-1.5>\nsum_squares([1.4,\
    \ 4.2, 0.0])\n</cell>\n<code language=julia-1.5>\nsum_squares([-2.4, 1.0, 1.0])\n\
    </cell>\n<code language=julia-1.5>\nsum(map(x -> x^2, [1.0, 2.0, 3.0]))\n</cell>\n\
    <code language=julia-1.5>\nsum(map(x -> x^2, [1.0, 4.0, 9.0]))\n</cell>\n<code\
    \ language=julia-1.5>\nsum(map(x -> x^2, [1.0, 3.0, 5.0, 7.0]))\n</cell>\n<code\
    \ language=julia-1.5>\nsum(map(x -> x^2, [1.4, 4.2, 0.0]))\n</cell>\n<code language=julia-1.5>\n\
    sum(map(x -> x^2, [-2.4, 1.0, 1.0]))\n</cell>\n<text>\nChallenge 2.2\nWrite a\
    \ function that can calculate the inverse of a matrix with N rows and N columns.\
    \ We will test your function with different sized matrices.", "    return sum(map(x\
    \ -> round(Int, sqrt(x))*x, lst))\nend", "    sum = 0\n    for i in lst\n    \
    \    sum+=i*i\n    end\n    return round(sum)\nend\n</cell>\n<code language=julia-1.1>\n\
    sum_squares(lst)\n</cell>\n<text>\n4.3\nNow let's try with a larger list containing\
    \ random float numbers. Run the cell below repeatedly.", "    n=length(lst)\n\
    \    square_sum = 0\n    for i in lst\n        square_sum+=(i^2)\n    end\n  \
    \  return round(square_sum, n)\nend \n</code>\n<|/ a tags=julia |>\n<| c |>\n\
    Please check my answer. Your code has a bug, so it's wrong. Moreover, `lst([1.0,\
    \ 4.0, 9.0])` returns `14` and `lst([-2.4, 1.0, 1.0])` returns `-6`.\n<|/ c |>\n\
    <| c |>\nIt doesn't return a wrong answer as I tested it. I just forgot to include\
    \ the `round` call in my code. Also I tested with negative numbers as well. For\
    \ negative numbers your function returns a negative number instead of a zero.\n\
    <|/ c |>\n<| c |>\nI tested your functions with negative numbers too and both\
    \ methods return the same negative number. Your function doesn't work for negative\
    \ numbers at all.\n<|/ c |>\n<| c |>\nYou must be doing something wrong. Because\
    \ I just tested it on Julia 0.6.2 and it works fine.\n<|/ c |>\n<| c |>\nOk, I\
    \ was using an older version of Julia, that's why it didn't work for me. Thanks\
    \ for your help.\n<|/ c |>\n<| a dscore=2 |>\nI believe that this is the simplest\
    \ solution. As you mentioned, you can easily use a for-loop but since you mentioned\
    \ vectors, here is a vectorized solution:\n<code>\njulia> function sum_vector(x::Vector{Int})\n\
    \           s = 0\n           for i in x\n              s += i^2\n           end\n\
    \           return s\n       end", "    s = 0\n    for x in lst\n        s +=\
    \ x * x\n    end\n    s\nend", "    if length(lst)==0\n        return 0;\n   \
    \ end\n    return sum(lst).^2 # return square of sum of all elements\nend", " \
    \   #println(lst)\n    s = 0.0\n    for i in 0 : (length(lst) - 1) \n        s\
    \ = s + lst[i]*lst[i] \n    end\n    return round(s)\nend\n</cell>\n<code language=julia-1.5>\n\
    sum_squares(lst)\n</cell>\n<code language=julia-1.5>\nsum_squares(lst)\n</cell>\n\
    <text>\n\u0417\u0430\u0434\u0430\u043D\u0438\u0435 2", "    for i in lst \n  \
    \      x := round(Int, i)\n        y := round(Int, i)\n        sum += x*x\n  \
    \      sum += y*y\n    end\n    return sum\nend", "    sum = 0\n    for i in lst\n\
    \        sum = sum + i**2\n    end\n    return sum\nend\n</code>\nThis way the\
    \ function will return the correct output no matter what inputs you give it (except\
    \ it will break if you give it a Vector of integers instead of a Vector of Float64\
    \ numbers)\n<|/ a dscore=3 tags=julia,vector,types |>\n<| c |>\nThis is the best\
    \ answer. The other answers are all overly complicated (like using sum and sumsq).\
    \ Just use the sum() function. You don't even have to wrap the function in an\
    \ if statement.\n<|/ c |>\n<| a |>\nMy answer is\n<code>", "    return sum(x.^2\
    \ for x in lst)\nend \n</cell>\n<code language=julia-1.0>\n@assert sum_squares([1.0,\
    \ 2.0, 3.0]) == 14\n@assert sum_squares([1.0, 4.0, 9.0]) == 98\n@assert sum_squares([1.0,\
    \ 3.0, 5.0, 7.0]) == 84\n@assert sum_squares([1.4, 4.2, 0.0]) == 29\n@assert sum_squares([-2.4,\
    \ 1.0, 1.0]) == 6\n</cell>\n<text>\nProblem 9 (Solution)\nNow implement the function\
    \ sum_squares_approx which calculates the exact sum of squares. You will need\
    \ to write an expression for the summation explicitly, and then use an optimization\
    \ technique to solve it. You will need to use an expression similar to the one\
    \ that you have already used to implement sum_squares(). You may find it useful\
    \ to use a matrix representation to help you solve these kind of problems.", " \
    \   sum(map(x -> round(x * x), lst))\nend", "    sum_ = 0\n    for i in lst\n\
    \        sum_ += i^2\n    end\n    return sum_\nend\n</cell>\n<code language=julia-0.6>\n\
    sum_squares(lst)\n</cell>\n<text>\nProblem 7: Write a function that takes in a\
    \ list of numbers and returns the average.", "    \"\"\"\n    Your function should\
    \ return the sum of squared numbers in the given vector,\n    round each element\
    \ in the vector to the upper int(Ceiling) first.\n    \"\"\"\n    \n    sum =\
    \ 0.0\n    for n in lst\n        sum = sum + round(Float64(n)) ** 2\n    return\
    \ sum\nend", "    \"\"\"\n    Sum of the squares of the elements in a vector.\n\
    \    \"\"\"\n    \n    return sum(map(x -> round(x^2, ceiling), lst))\nend\n</cell>\n\
    <code language=julia-0.6>\nsum_squares(lst)\n</cell>\n<text>\n(2) Sum all elements\
    \ in a vector and square", "  sum(map(x -> pow(x, 2), lst))\nend\n  \n\"\"\"\n\
    You are given a vector of numbers. You need to find the product of \nnumbers in\
    \ the vector. Remember that product of negative numbers is \nnot defined. If there\
    \ is more than one product of any number, \nreturn the  largest.\nExamples:\n\
    \    >>> lst([1.0, 2.0, 3.0])\n    6\n    >>> lst([1.0, 4.0, 9.0])\n    18.0\n\
    \    >>> lst([1.0, 3.0, 5.0, 7.0])\n    54.0\n    >>> lst([1.4, 4.2, 0.0])\n \
    \   0.2\n    >>> lst([-2.4, 1.0, 1.0])\n    4.0\n\"\"\"", "    sum_sq = sum([x^2\
    \ for x in lst])\n    return round(sum_sq, Int(ceil))\nend\n\"\"\"\n    Define\
    \ a function that returns a vector of numbers such that each element in the vector\
    \ is the square root of its corresponding elements in the given vector. \n   \
    \ \n    Examples:\n    >>> lst([-2.4, 1.0, 1.0])\n    [-0.7071067811865475, 1.4142135623730951,\
    \ 3.316624790356452, 2.0]\n    >>> lst([1.0, -2.4, 1.0])\n    [1.0, 2.8284271247461903,\
    \ 2.8284271247461903, 3.316624790356452]\n    >>> lst([-1.2, 2.4, -3.1])\n   \
    \ [1.4142135623730951, 3.316624790356452, 3.316624790356452, 4.0]\n    >>> lst([2.4,\
    \ 2.4, 2.4])\n    [1.0, 4.0, 9.0]\n    >>> lst([2.4, 2.4, 2.4, 2.4])\n    [1.0,\
    \ 4.0, 9.0, 19.0]\n    ", "    sum = 0\n    map(x -> round(x, ceiling(x)), lst)\n\
    \    for x in lst\n        sum = sum + x^2\n    end\n    sum\nend\n</cell>\n<text>\n\
    4.3 Exercise: Create a function which calculates and returns the average value\
    \ of the given list of numbers.\nFor a list of numbers:", "    \n    if length(lst)\
    \ == 0 \n        return 0 \n    else \n        sum = 0\n        for i in lst\n\
    \            sum += i * i \n    end\n    \n    return sum \nend\n</cell>\n<code\
    \ language=julia-1.3>\nsum_squares(vec1)\n</cell>\n<code language=julia-1.3>\n\
    sum_squares(vec2)\n</cell>\n<code language=julia-1.3>\nsum_squares(vec3)\n</cell>\n\
    <code language=julia-1.3>\nsum_squares(vec4)\n</cell>\n<code language=julia-1.3>\n\
    sum_squares(vec5)\n</cell>\n<code language=julia-1.3>\nsum_squares(vec6)\n</cell>\n\
    <code language=julia-1.3>\nsum_squares(vec7)\n</cell>\n<text>\nProblem 3: Write\
    \ a function that returns the minimum of a given vector.", "    sum=0\n    for\
    \ i in lst\n        sum=sum+i^2\n    end\n    return sum\nend #sum_squares", " \
    \   sum = 0\n    for x in lst\n        sum += x*x\n    return sum\nend", "   \
    \ sum(lst)\nend", "    \"\"\"Solution 1: Using a loop\"\"\"\n    sum = 0\n   \
    \ for i in lst\n        sum += i^2\n    end\n    return sum\nend", "    sum_ =\
    \ 0\n    for elt in lst\n        sum_ = elt .* elt\n    end\n    return sum_\n\
    end", "    sum=0\n    for i in 0..(lst.length-1) \n        sum+=lst[i]*lst[i]\n\
    \    return sum\nend\n</cell>\n<code language=julia-0.6>\n\"\"\"\nYou are given\
    \ a vector of numbers.\n    You need to return the sum of squared numbers in the\
    \ given vector,\n    round to the nearest int.\n    Examples:\n    >>> lst([1.0,\
    \ 2.0, 3.0])\n    14\n    >>> lst([1.0, 4.0, 9.0])\n    98\n    >>> lst([1.0,\
    \ 3.0, 5.0, 7.0])\n    84\n    >>> lst([1.4, 4.2, 0.0])\n    29\n    >>> lst([-2.4,\
    \ 1.0, 1.0])\n    6\n    ", "    return (lst...).^2 # list comprehension\nend ",
  "    lst.round\n    return sum(map(sq, lst))\nend", "    #print(lst)\n    sum =\
    \ 0\n    for x in lst\n        push!(sum, x*x)\n    end\n    \n    return sum(sum)\n\
    end", "    sum_sqr = 0\n    for x in lst\n        sum_sqr += x^2\n    return round(sum_sqr)\n\
    end\n</cell>\n<code language=julia-1.0>\n@time sum_squares(A)\n</cell>\n<text>\n\
    5.2 Vectorized Computation of Square of Vector Elements\nThe previous section\
    \ involved for loops and iterating through the elements of a vector to compute\
    \ the square of each element. While this approach may be slow for larger arrays,\
    \ it scales much better to large vectors and arrays than to iterating through\
    \ each element and computing the square individually.", " \n    sum=0\n    for\
    \ i in lst\n        sum+=i*i\n    end\n    return sum\nend", " \n    for i in\
    \ lst \n        j = ceil(i); return i + j\n    end\n    return 0\nend", " \n \
    \   for i in lst\n        i=round(i)\n        i=i+i\n        i=i+i\n    end\n\
    \    sum_squares=i\n    return sum_squares\nend", "    sum = 0\n    for x in lst\n\
    \        sum += x^2\n    return sum\nend", "    \n    sum=0\n    for element in\
    \ lst \n        sum+=element*element\n    end\n    return sum\nend\n</cell>\n\
    <text>\nTask 4\nWrite a function to count the number of nonnegative integers less\
    \ than or equal to a given value.", "    sum_ = 0\n    for i in lst\n        sum_+=(i*i)\n\
    \    return sum_\nend", "    sum = 0.\n    for ele in lst\n        sum += ele^2\n\
    \    \n    return round(sum, ceiling)\nend", "    sum = 0\n    for i in lst\n\
    \        sum = sum + i^2\n    end\n    return sum\nend", "    n=length(lst)\n\
    \    sum=0\n    for i=1:n\n        sum=sum+lst[i]^2\n    end\n    return sum\n\
    end", "    sum = 0.0\n    for x in lst\n        sum = sum + x^2\n    end\n   \
    \ \n    return sum\nend", "    sum = 0\n    for num in lst \n        sum += num^2\
    \ \n    end\n    return sum\nend", "    sum = 0\n    for x in lst\n        sum\
    \ += (x^2)\n    end\n    return sum\nend \n</code>\n<|/ a dscore=2 tags=julia,function,arrays,arraylist\
    \ |>\n<| a dscore=1 tags=julia,function,arrays,arraylist |>\nThe sum of squares\
    \ is  equal to sum([x^2 for x in lst])", "    return sum(x * x for x in lst)\n\
    end", "    sum=0\n    for i in lst\n        sum+=i*i\n    end\n    return sum\n\
    end", "    return sum(map(x->round(x*x), lst))\nend # function sum_squares(lst::Vector{Float64})",
  "    return sum(map(sq, lst))\nend", "    return sum(map(x -> round(x*x, 1), lst))\n\
    end\n</cell>\n<code language=julia-1.5>\nsum_squares([1.0, 2.0, 3.0])\n</cell>\n\
    <text>\nPart 2: List comprehension", "    for i in 1:length(lst)\n        lst[i]\
    \ = round(Int64, lst[i]^2)\n    end\n    \n    return sum(lst)\nend", "\tsum=0\n\
    \tfor i in lst\n\t\tsum+=i*i\n\t\n\treturn sum\nend", "    n=length(lst)\n   \
    \ sum=0\n    for i=1:n\n        sum=sum+lst[i]^2\n    end\n    return sum\nend",
  "    s = 0.0\n    for num in lst\n        s = s + num*num\n    return roundToInt(s)\n\
    end\n</cell>\n<code language=julia-1.6>", "    sum=0\n    for v in lst\n     \
    \   sum+=v*v\n    end\n    return sum\nend", "  sum_squares=0\n  for item in lst\n\
    \    sum_squares+=item*item\n  end\n  return sum_squares\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nThank you so much for your help and for explaining your code and\
    \ what it does in simple words. I understand that your code is shorter than mine,\
    \ but I do have another concern; I'm relatively new to coding and my teacher told\
    \ us to always try to keep it as simple as possible in order to learn new things.\
    \ However, I understand that your code is way more efficient than mine.\n<|/ c\
    \ |>\n<| c |>\nOkay, I understand your concern. My teacher just told me to try\
    \ my hand in coding before taking a class. He always said that we should try to\
    \ keep it as simple as possible, but I also agree that it's probably more efficient.\
    \ I'll keep your advice in mind next time I meet somebody who's going to use my\
    \ code. Thanks again for your help!\n<|/ c |>\n<| c |>\n`@user1890121`: Yes, I\
    \ believe you were right to not use `@` while writing a comment. `@user1890121`:\
    \ Glad to help. But I recommend you to read more about [Julia](https://docs.julialang.org/en/v1/)?\n\
    <|/ c |>\n<| c |>\nThank you for pointing me towards Julia! I definitely will\
    \ and I already did. I just want to make it more efficient so that I don't have\
    \ to redo it again and again.\n<|/ c |>\n<| a |>\nThe basic structure of this\
    \ solution is as follows:", "    return sum(x->round(x*x,digits=ceiling(x)),lst)\n\
    end ", "    \"\"\"\n    \n    \"\"\"\n    if length(lst) == 0 \n        return\
    \ 0 \n    sum_squares = 0\n    for i in lst\n        sum_squares += i * i \n \
    \   end\n    return sum_squares\nend\n</cell>\n<text>\nQuestion 4: Write a function\
    \ called square_mean that returns the mean of the elements of lst.  It should\
    \ round the returned value to the upper(int(ceil(Int64)) first.", "    #assert(all(isa(lst,\
    \ Vector{Float64})), \n    #    \"lst should be a vector of Float64\")\n    total\
    \ = 0\n    \n    for i in lst\n        total += i^2\n    end\n    return total\n\
    end\n</cell>\n<code language=julia-1.0>\nlst([1.0, 2.0, 3.0])\n</cell>\n<code\
    \ language=julia-1.0>\nsum_squares([1.0, 2.0, 3.0])\n</cell>\n<code language=julia-1.0>\n\
    sum_squares([1.0, 4.0, 9.0])\n</cell>\n<code language=julia-1.0>\nsum_squares([1.0,\
    \ 3.0, 5.0, 7.0])\n</cell>\n<code language=julia-1.0>\nsum_squares([1.4, 4.2,\
    \ 0.0])\n</cell>\n<code language=julia-1.0>\nsum_squares([-2.4, 1.0, 1.0])\n</cell>\n\
    <text>\nExercise: Write a function called sum_of_squares that returns the sum\
    \ of squares of any number.", "    #@assert lst.ndim == 1 \"Error: List must have\
    \ 1 dimension.\"\n    sum = 0\n    for i in lst\n        sum = sum + i^2\n   \
    \ return sum\nend", "    sum = 0\n    length = length(lst)\n    for i in 1:length\n\
    \        sum += lst[i]^2\n    end\n    return sum\nend\nsum_squares(lst)", " \
    \   result = 0.0\n    for i in lst\n        result += i * i\n    end\n    return\
    \ round(result)\nend\n</cell>\n<text>\nQuestion 2\nUsing sum_squares(lst, round)\
    \ defined above, return a vector with the square of all elements in lst.", " \
    \   n = 0\n    for x in lst\n        n += x.^2 \n    end\n    return n\nend",
  "    sum = 0\n    for i in lst\n        sum = sum + i ** 2\n    end\n    return\
    \ sum\nend", "    a=1\n    sum=0\n    for i in lst\n        a=a*i\n        sum=sum+a\n\
    \    end\n    return sum\nend", "    sum = 0\n    for x in lst\n        sum +=\
    \ x*x\n    end\n    return sum\nend", "    result = 0.0\n    for i in lst\n  \
    \      result += i^2 \n    end\n    return result\nend\n</cell>\n<text>\nNow let's\
    \ try it out:", "    s = sum(lst*lst)\n    return s\nend\n    ", "    sqsum =\
    \ 0\n    for elt in lst\n        sqsum = sqsum + elt * elt\n    end\n    return\
    \ round(sqsum, digits)\nend", "    if length(lst)==0\n        return 0;\n    end\n\
    \    \n    sum_of_squares = 0\n    for x in lst\n        sum_of_squares += (x^2)\n\
    \    end\n    return sum_of_squares\nend", "    sum = 0\n    for n in lst\n  \
    \      sum += n*n\n    end\n    return round(sum, digits(Float64))\nend", "  \
    \  total = 0\n    for i in 0..(length(lst)-1) do \n        total += lst[i]^2 \
    \ \n    end\n    return total\nend", "    sum = 0\n    for i in lst\n        sum\
    \ += i * i\n    end\n    return sum\nend\n</cell>\n<text>\nQuestion 5\nImplement\
    \ the function is_divisible that takes a list of numbers a\n    and a number b\
    \ as arguments and checks if b is a divisor of a,\n    then returns the index\
    \ of the first element in the list which is not divisible by b.", '    return
    Int64(reduce(+,map(round,lst))^2)', "    sum = 0\n    for i in lst\n        sum\
    \ += i * i\n    end\n    return sum\nend\n</cell>\n<text>\nExercise\nExercise:\
    \ Write a function with two parameters, a vector and the number of elements. \n\
    This function should return an integer with the number of elements rounded up\
    \ to the next integer.", "    return (lst*lst).sum()\nend", "    sum_of_squares\
    \ = 0\n    for i in lst\n        sum_of_squares += i^2\n    end\n    return sum_of_squares\n\
    end", "    \nend", "    sum = 0.0\n    for i in 0..lst.len-1\n        sum += lst[i]*lst[i]\n\
    \    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Write\
    \ a function that takes a number as input, and returns its factorial.\nExample:\
    \ \nfactorial(3) => 6\nfactorial(5) => 120\nfactorial(0) => 1\n\"\"\"", "    for\
    \ i in lst\n    square = i^2\n    return square\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThe code does not run for me; I get errors on `Int64` and `Float64`,\
    \ and the function does not work either; it returns \"NoMethodError\".\n<|/ c\
    \ |>\n<| c |>\nSorry - I did not test the code - it should work now\n<|/ c |>\n\
    <| a dscore=0 tags=julia,performance,vectorization,loops |>\n<code>\njulia> function\
    \ sum_squares(lst::Vector{Float64})\n           squares = vcat(lst...)\n     \
    \      sum(map(square, squares))\n       end\nsum_squares(::Array{Float64,1},\
    \ ::Array{Float64,1}) at none:0\nsum_squares(::Array{Float64,1}, ::Array{Float64,1})\
    \ at none:0\n</code>\n<|/ a |>\n<| a dscore=0 |>\nJust for fun, here's another\
    \ way to do it. It uses a combination of cat, map, and broadcasting and is quite\
    \ fast, but still uses twice the memory. If you're going to run a lot of these\
    \ in parallel, I'd recommend going the parallel solution if you can afford it.\n\
    <code>\njulia> function sum_squares(lst::Vector{Float64})\n           squares\
    \ = vcat(lst...)\n           sum(map(square, squares))\n       end\nsum_squares(::Array{Float64,1},\
    \ ::Array{Float64,1}) at none:0\nsum_squares(::Array{Float64,1}, ::Array{Float64,1})\
    \ at none:0", "    res=0\n    for v in lst\n        res+=v^2\n    end\n    return\
    \ res\nend", "    sum = 0.0\n    for e in lst\n        sum += e ^ 2\n    end\n\
    \    return sum\nend", "    result = 0\n    for i in lst\n        result+=i^2\n\
    \    end\n    return round(result)\nend", "    nr_elements = length(lst)\n   \
    \ sum_of_squared_numbers = 0.\n    for element in lst\n        sum_of_squared_numbers\
    \ += element * element\n    return round(sum_of_squared_numbers, nr_elements)\n\
    end\n</cell>\n<cell>\nsum_squares(lst)\n</cell>\n<text>\nTask 1.10: Write a function\
    \ to compute the mean value of the given vector.\nFor this task you should round\
    \ the sum of the elements to integer.", "    return (sum((map(ceil,lst)).*lst))\n\
    end", "    sum_squares = 0.\n    for i in lst\n        sum_squares = sum_squares\
    \ + (i*i)\n    end\n    return round!(sum_squares)\nend", "    s = 0.0\n    for\
    \ x in lst\n        s = s + x*x\n    end\n    return round(s)\nend\nsum_squares(lst)\n\
    </cell>\n<code language=julia-0.5>", "    sum = 0\n    for elt in lst\n      \
    \  sum+=elt * elt\n    end\n    return round(sum,Ceil)\nend\n</cell>\n<code language=julia-1.5>\n\
    sum_squares([2.0, 1.0])\n</cell>\n<code language=julia-1.5>\nsum_squares([-4.0,\
    \ 1.0, 1.0])\n</cell>\n<code language=julia-1.5>\nsum_squares([1.0, 4.0, 9.0])\n\
    </cell>\n<code language=julia-1.5>\nsum_squares([1.0, 3.0, 5.0, 7.0])\n</cell>\n\
    <code language=julia-1.5>\nsum_squares([1.4, 4.2, 0.0])\n</cell>\n<code language=julia-1.5>\n\
    sum_squares([-2.4, 1.0, 1.0])\n</cell>\n<code language=julia-1.5>", "    sum =\
    \ 0\n    for x in lst\n        sum += (x*x)\n    end\n    return sum\nend\n\"\"\
    \"\n    Same as lst but takes a Float32 instead of Float64.", "    s = 0.0\n \
    \   for i in lst\n        s += i^2\n    return round(s)\nend", "    sum=0\n  \
    \  for i=0:length(lst)-1\n        sum=sum+lst[i]*lst[i]\n    end\n    return sum\n\
    end", "    sum = 0\n    for a in lst\n        sum = sum + (a*a)\n    end\n   \
    \ return sum\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nI like this way\
    \ of doing it:\n<code>", "    sum=0\n    for i in lst \n        sum=sum+i^2 \n\
    \    return sum\nend \nsum_squares(lst)\n</cell>\n<code language=julia-0.6>",
  "    if length(lst) == 0 \n        return 0 \n    else \n        sum = 0\n     \
    \   for i in lst \n            sum += i * i \n        return sum\n    end\nend ",
  "    \n    sum = 0\n    for i in lst\n        sum += i**2\n    end\n    return sum\n\
    end\n</cell>\n<text>\nLet's now try to test our code:", "     \n    sum = sq =\
    \ 0.0\n    for x in lst\n        sum += x * x\n        sq += x\n    return round(sq,\
    \ Int64), sum\nend", "        \n    sum(map(x -> x^2, lst))\nend", "    sum =\
    \ 0\n    for i in lst\n        sum += i^2\n    end\n    return sum\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert sum_squares([1.0, 2.0, 3.0]) == 14\n@assert\
    \ sum_squares([1.0, 4.0, 9.0]) == 98\n@assert sum_squares([1.0, 3.0, 5.0, 7.0])\
    \ == 84\n@assert sum_squares([1.4, 4.2, 0.0]) == 29\n@assert sum_squares([-2.4,\
    \ 1.0, 1.0]) == 6\n</cell>\n<text>\nExercise 5: Write a function to find the minimum\
    \ element of the given list\nExercise 5.1: Write a function that finds the minimum\
    \ element of a list", "    sum_vals=0 \n    for i in lst\n        sum_vals=sum_vals\
    \ + i^2\n    end\n    return sum_vals\nend\n</cell>\n<text>\nWe see that the function\
    \ is now working as expected:", "    sum_ = 0\n    for x in lst\n        sum_\
    \ += x^2\n    end\n    return sum_\nend\n</cell>\n<text>\nNow let's define the\
    \ objective function and the gradient (first derivative) of the function:", " \
    \   n::Int64 = 0\n    for i in lst\n        n::Int64 += i^2\n    return round(n,digits)\n\
    end\nsum_squares(lst)\nend", "\"\"\"Compute the sum of squares of numbers in the\
    \ vector.\"\"\"\n    sum(map(Math::sqrt, lst))\nend", "    # your code goes here\n\
    \    #for i in lst do \n        \n    \n    for i in lst\n        x = round(Float64(i))\n\
    \        y = round(Float64(i))\n        z = x+y\n        return z\n    end\n \
    \   return 0\nend\n</cell>\n<text>\nExercise 10\nWrite a function that returns\
    \ a vector of a given length containing all the even numbers in the range. The\
    \ even numbers are 2, 4, 6, 8 and so on. Hint: use the function map!", "    for\
    \ i in lst\n        return i + i\n    end\nend", "    sum=0\n    for x in lst\n\
    \        sum=sum+x^2\n    end\n    return sum\nend\n\"\"\"", "    sum_val = 0\n\
    \    sum_square_sum = 0\n    for x in lst\n        sum_val = sum_val + x\n   \
    \     sum_square_sum = sum_square_sum + x**2\n    return sum_square_sum\nend",
  "    n = lst.len\n    sum = 0\n    for x in lst\n        sum += x^2\n    end\n \
    \   return sum\nend", "    sum_of_squares = 0.\n    for x in lst\n        sum_of_squares\
    \ += x * x\n    return sum_of_squares\nend", "     return  sum( map( x -> round(sqrt(x)),lst))\n\
    end", "    #assert(all(isfinite(lst)))\n    sum = 0\n    for x in lst\n      \
    \  sum = sum + x.^2\n    end\n    return sum\nend ", "    sum(map(x->sqrt(x),\
    \ lst))\nend\n\"\"\"\n    \n\"\"\"\n    \n    \n\"\"\"\n    \n    \n\"\"\"", " \
    \   sum=0\n    \n    for i in lst\n        sum += i^2\n    end\n    return sum\n\
    end", "    # write your code in Python 3 or Python 2.7\n    # return sum((x for\
    \ x in lst)^2) ", "    \"\"\"sums the squares of all elements in the vector\"\"\
    \"\n    sum = 0\n    for i in lst\n        sum += i^2\n    end\n    return sum\n\
    end", "    sum = 0\n    for x in lst\n        sum = sum + (x.^2)\n    return sum\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a tags=julia |>\nSince you are new to Julia,\
    \ I recommend you read up on the docs, especially on how to vectorize computations.\
    \ \nYour example could be written as:\n<code>", "  sum(lst.*lst)\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\nHere is an iterative solution in Julia using\
    \ iterators. First we define an iterator:\n<code>\nusing Iterators", "    sum\
    \ = 0\n    for v in lst\n        sum += v * v\n        \n    return sum\nend",
  "  sum_ = 0\n  for n in lst\n    sum_ += n*n \n  end\n  return sum_\nend", "   \
    \ sum=0\n    for i in lst\n        sum += i*i\n    end\n    return sum\nend",
  "    sum = 0.0\n    sum_sq = 0.0\n    for ele in lst\n        sum_sq += ele * ele\n\
    \        sum += Int(ele)\n    end\n    return round(sum_sq + sum)\nend", "   \
    \ sum=0\n    for i in lst \n        sum+=i*i\n    end\n    return sum\nend", " \
    \   lst.round()\n    sum((x * x).^2 for x in lst)\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\nGiven a vector, return a new vector, where each element\nis squared-root\
    \ of original element.\n\"\"\"", "    return sum(map(x -> round(x*x, digits=digits),\
    \ lst))\nend\n</cell>\n<code language=julia-0.6>\n\"\"\"\nWrite a function that\
    \ returns the sum of the squares of numbers in the given vector.", "  result =\
    \ 0.0\n  for i in lst\n      result += i*i\n  end\n  return round!(result)\nend\n\
    </cell>\n<cell>\n@assert sum_squares([1.0, 2.0, 3.0]) == 14\n@assert sum_squares([1.0,\
    \ 4.0, 9.0]) == 98\n@assert sum_squares([1.0, 3.0, 5.0, 7.0]) == 84\n@assert sum_squares([1.4,\
    \ 4.2, 0.0]) == 29\n@assert sum_squares([-2.4, 1.0, 1.0]) == 6\n</cell>\n<text>\n\
    Question 5", "    result = 0.\n    for i in lst\n        result = result + (i^2);\
    \ \n    return result\nend", "    return sum(map(x -> round(x*x),lst))\nend\n\
    </cell>\n<text>\nProblem 2.3\nWrite a function sum_cubes(lst::Vector{Float64})\n\
    that returns the sum of the cubes of the numbers in the vector.\nExamples:\n>>>\
    \ lst([1.0, 4.0, 9.0])\n144\n>>> lst([1.0, 3.0, 5.0, 7.0])\n168\n>>> lst([1.0,\
    \ 2.0, 3.0])\n14\n>>> lst([1.4, 4.2, 0.0])\n30", "    sum = 0 \n    for i in 0..(length(lst)-1)\
    \ \n        sum += (lst[i]*lst[i]) \n    endfor \n    return sum \nend", "   \
    \ result = 0.\n    for number in lst\n        result += (number * number)\n  \
    \  end\n    return result\nend", "    sum=0\n    for e in lst\n        sum=sum+e*e\n\
    \    return sum\nend\n\"\"\"\n    Write a function that checks the validity of\
    \ an expression.\n    Any input that does not conform to the rules of the expression\
    \ is invalid.\n    \n    You may assume that each input is a valid expression\
    \ (i.e. each expression can have\n    valid expressions nested inside of it).\n\
    \    \n    The valid expressions include +, -, *, and /.\n    \n    Examples:\n\
    \    >>> validity(+)\n    True\n    >>> validity(+(-(+((*(-2.0,2.0),2.0)))))\n\
    \    True\n    >>> validity(+(-(+((*(-2.0,2.0),2.0)))))\n    True\n    >>> validity((*(-(+((*(-2.0,2.0),2.0)),2.0)),2.0))\n\
    \    True\n    >>> validity((*(-(+((*(-2.0,2.0),2.0)),2.0)),2.0))\n    False\n\
    \    \n    You can assume that all valid expressions have valid inputs as well.\n\
    \    \n    Example:\n    >>> validity((*(-(+((*(-2.0,2.0),2.0)),2.0)),2.0))\n\
    \    False\n    >>> validity(+(-(+((*(-2.0,2.0),2.0)),2.0)))\n    False\n    >>>\
    \ validity(-(-(+((*(-2.0,2.0),2.0)),2.0)))\n    False\n    >>> validity((*(-(+((*(-2.0,2.0),2.0)),2.0)),2.0))\n\
    \    False\n    \n    \"\"\"", "    sum = 0 \n    for i in lst\n        sum =\
    \ sum + i * i \n    end\n    round(sum)\nend\n    \"\"\"\n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    ", "    sum = 0\n    for i in lst\n \
    \       sum += i * i\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.3>\n\
    sum_squares([1.0, 2.0, 3.0])\n</cell>\n<code language=julia-1.3>\nsum_squares([1.0,\
    \ 4.0, 9.0])\n</cell>\n<code language=julia-1.3>\nsum_squares([1.0, 3.0, 5.0,\
    \ 7.0])\n</cell>\n<code language=julia-1.3>\nsum_squares([1.4, 4.2, 0.0])\n</cell>\n\
    <code language=julia-1.3>\nsum_squares([-2.4, 1.0, 1.0])\n</cell>\n<text>\nExercise:\
    \ Inverse of a vector\nWrite a function, that takes an array and returns its inverse.\n\
    Examples:", "    sum = 0.0\n    for i in lst\n        sum += i * i\n    return\
    \ sum\nend", "    \"\"\"\n        sum_squares(lst::Vector{Float64})", "    return\
    \ sum((lst |> map(round) |> collect))\nend\n</cell>\n<code language=julia-1.5>",
  "  square = Float64(1.0)\n  sum = 0\n  for x in lst\n    square *= x\n    sum +=\
    \ square\n  end\n  return round( sum, Int( ceil ))\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| c |>\nThank you! Your function really helped. \nI added a few lines to\
    \ calculate the standard deviation, and now it works.\nI posted the final code\
    \ below.\n<|/ c |>\n<| a tags=julia |>\nThanks so much to and for their help!\
    \ \nThis is my final code for the summation of a vector in Julia.\n<code>", " \
    \   sum=0\n    for element in lst\n        sum=sum+element*element\n    end\n\
    \    return sum\nend", "    return sum((map(ceil,lst))^2)\nend\n</cell>\n<code\
    \ language=julia-0.4>\nsum_squares(lst)\n</cell>\n<code language=julia-0.4>\n\
    lst = [1.0, 4.0, 9.0]\nmap(ceil,lst)\n</cell>\n<text>\nQuestion 2\nThe following\
    \ two cells are a modified version of exercise 1 from Chapter 2 of Data Science\
    \ from William H. Watson.", "    sum = 0\n    for i in lst\n        sum += i*i\n\
    \    end\n    return sum\nend", "  sum=0.0\n  for v in lst\n      sum += v*v\n\
    \  end\n  return sum\nend", "    sum_ = 0\n    for i in lst\n        sum_ = sum_\
    \ + i*i\n    end\n    return sum_\nend \n</cell>\n<code language=julia-1.0>",
  "\"\"\"\nThis function computes the sum of squared numbers in the given vector.\n\
    It uses @fastmath for performance. \n\"\"\"\n    return sum((lst[i] ^2)\n    for\
    \ i in lst)\nend", "    # Your code here\n    sum = 0\n    for i in lst\n    \
    \    sum += i*i\n    end\n    return sum\nend\n</code>\nNow I do not have the\
    \ compiler at the moment, but I think you should be able to do something like\
    \ this (you might need to use Float64):\n<code>", "\tsum = 0\n\tfor item in lst\n\
    \t\tsum += item*item\n\tend\n\treturn sum\nend", "    lst.map(x->round(x*x))\n\
    \    return sum(lst)\nend", "    return sum(v*v for v in lst)\nend", "    \"\"\
    \"\n    # return sum(map(x -> x.^2, lst))\n    sum = 0\n    for x in lst\n   \
    \     sum = sum + x\n    return sum\nend", "    \"\"\"Your code goes here\n  \
    \  \"\"\"\n    sum=0\n    for x in lst\n        sum+=x^2\n    end\n    return\
    \ round(sum,0)\nend\n</cell>\n<code language=julia-1.0>\nsum_squares(lst([1.0,\
    \ 2.0, 3.0]))\n</cell>\n<code language=julia-1.0>\nsum_squares(lst([1.0, 4.0,\
    \ 9.0]))\n</cell>\n<code language=julia-1.0>\nsum_squares(lst([1.0, 3.0, 5.0,\
    \ 7.0]))\n</cell>\n<code language=julia-1.0>\nsum_squares(lst([1.4, 4.2, 0.0]))\n\
    </cell>\n<code language=julia-1.0>\nsum_squares(lst([-2.4, 1.0, 1.0]))\n</cell>\n\
    <text>\nExercise 1\nThe sum of the squares of odd numbers is given by $$\n$$\n\
    \\sum_{n}^{\\infty}\\bigl(f(n)+\\sqrt{n}\\bigr)^2\n$$\nWrite a function odd_sum_square(lst)\
    \ which takes a vector of numbers as an input and returns the sum of the squares\
    \ of odd numbers. Round each element in the vector to an integer before applying\
    \ the formula. Test your function with $[1, 4, 9, 16, 25, 36]$.", "    sum_of_squares\
    \ = 0\n    len_of_list = length(lst)\n    for i in 1:len_of_list\n        sum_of_squares\
    \ += lst[i]^2\n    return sum_of_squares\nend\n</cell>\n<code language=julia-1.5>\n\
    sum_squares([1, 2, 3, 4])\n</cell>\n<text>\nPractice\nWrite a function that takes\
    \ an array and produces the sum of the squares of the elements, rounded up to\
    \ the next integer.", "    sum(map(x -> round(x^2), lst))\nend\n</cell>\n<code\
    \ language=julia-1.0>\n\"\"\"\n    round.(x \u21D2 y, n) rounds x to the nearest\
    \ integer that is greater than or equal to n\n    \n    When x is negative, the\
    \ function rounds down to zero if negative, and to the nearest \n    integer if\
    \ positive.\n\"\"\"", "    sum = 0\n    for i in lst\n        sum += i * i\n \
    \   return round(sum, digits=digits)\nend", "    sum = 0.0\n    for i in lst\n\
    \        sum += i * i\n    end\n    return sum\nend ", "    for i in 1:length(lst)\n\
    \        lst[i] = round(toint(lst[i])^2)\n    end\n    return sum(lst)\nend\n\
    sum_squares(vec)\nend\n</cell>\n<text>\nTask 1.2: Vectors and Matrices", "   \
    \ \n    for i in 0 .. length(lst)-1\n        lst[i] = round(lst[i])\n    end\n\
    \    return sum(lst*lst)\nend\n</cell>\n<code language=julia-1.5>\nsum_squares([1.0,\
    \ 2.0, 3.0])\n</cell>\n<code language=julia-1.5>\nsum_squares([1.0, 4.0, 9.0])\n\
    </cell>\n<code language=julia-1.5>\nsum_squares([1.0, 3.0, 5.0, 7.0])\n</cell>\n\
    <code language=julia-1.5>\nsum_squares([1.4, 4.2, 0.0])\n</cell>\n<code language=julia-1.5>\n\
    sum_squares([-2.4, 1.0, 1.0])\n</cell>\n<text>\n1.5.2 Find median of a vector",
  "    sum = 0\n    for i in lst\n        sum += i * i\n    end\n    return sum\n\
    end", "    sum_ = 0\n    for i in lst \n        sum_ += i * i\n    end\n    return\
    \ sum_\nend\n</cell>\n<code language=julia-0.6>\nsum_squares(lst)\n</cell>\n<text>\n\
    Exercise: Calculate the sum of square of the numbers from the given list.", " \
    \   sum = 0\n    for e in lst\n        sum += e * e\n    return sum\nend\n</cell>\n\
    <code language=julia-1.6>\nsum_squares([1.0, 2.0, 3.0])\n</cell>\n<code language=julia-1.6>\n\
    sum_squares([1.0, 4.0, 9.0])\n</cell>\n<code language=julia-1.6>\nsum_squares([1.0,\
    \ 3.0, 5.0, 7.0])\n</cell>\n<code language=julia-1.6>\nsum_squares([1.4, 4.2,\
    \ 0.0])\n</cell>\n<code language=julia-1.6>\nsum_squares([-2.4, 1.0, 1.0])\n</cell>\n\
    <code language=julia-1.6>\n# function squares_vector(vec::Vector)\n#     return\
    \ sum(vec * vec)\n# end\n# function squares_vector(vec::Vector{T}) where T\n#\
    \     return sum(vec * vec)\n# end\n# function squares_vector(vec::Vector{T})\
    \ where T <: Real\n#     return sum(vec * vec)\n# end\n# function squares_vector(vec::Vector{T})\
    \ where T <: AbstractFloat\n#     return sum(vec * vec)\n# end\n# function squares_vector(vec::Vector{T})\
    \ where T <: AbstractFloat64\n#     return sum(vec * vec)\n# end\n# function squares_vector(vec::Vector{T})\
    \ where T <: Number\n#     return sum(vec * vec)\n# end\n# function squares_vector(vec::Vector{T})\
    \ where T <: NumberComplex\n#     return sum(vec * vec)\n# end\n# function squares_vector(vec::Vector{T})\
    \ where T <: Integer\n#     return sum(vec * vec)\n# end\n# function squares_vector(vec::Vector{T})\
    \ where T <: Int\n#     return sum(vec * vec)\n# end\n# function squares_vector(vec::Vector{T})\
    \ where T <: AbstractInt\n#     return sum(vec * vec)\n# end\n# function squares_vector(vec::Vector{T})\
    \ where T <: Integer\n#     return sum(vec * vec)\n# end\n# function squares_vector(vec::Vector{T})\
    \ where T <: Int\n#     return sum(vec * vec)\n# end\n# function squares_vector(vec::Vector{T})\
    \ where T <: AbstractInt\n#     return sum(vec * vec)\n# end\n# function squares_vector(",
  "    result = 0.0\n    for i in lst\n        result += i*i\n    end\n    return\
    \ round(result,round_to)\nend\n</cell>\n<cell>\nsum_squares([1.0, 2.0, 3.0])\n\
    </cell>\n<text>\nTask 1: Write a function that returns the largest integer in\
    \ an array of integers. Input is a vector of integers. Output is a single integer.",
  "    result = Int64(0)\n    for elt in lst\n        result = result + elt * elt\n\
    \    end\n    return result\nend", "    for i in lst\n    i=round(i)\n    i=Ceiling(i)\n\
    \    end\n    sum(((i-i)^2)^2)\nend", "    sum(map(abs,lst))^2\nend", "    if\
    \ size(lst) == 1 \n        return lst[0]^2\n    elseif size(lst) == 2 \n     \
    \   return sum(lst)\n    elseif size(lst) == 3\n        sum = 1\n        for i\
    \ in lst\n            sum += i^2\n        return sum\n    else\n        return\
    \ 0\n    end\nend", "    sum(map(x -> x^2, lst))\nend", "    return sum(x.^2 for\
    \ x \u2208 lst)\nend ", "    sum_square=0\n    for x in lst\n        sum_square+=x^2\n\
    \    end\n    return sum_square\nend\n    return sum_squares(lst)\nend\n    ",
  "    total=0\n    for num in lst\n        total += num*num\n    end\n    return\
    \ total\nend\n</cell>\n<code language=julia-1.5>", "  result = Float64(0)\n  for\
    \ i in 0 .. size(lst)[1] \n    result += (lst[i]).^2 \n  end \n  return round(result)\n\
    end", "    sum = 0\n    for e in lst\n        sum = sum + e^2;\n    end\n    return\
    \ round(sum);\nend\n</cell>\n<cell>\nsum_squares([1.0, 2.0, 3.0])\n</cell>\n<cell>\n\
    sum_squares([1.0, 4.0, 9.0])\n</cell>\n<cell>\nsum_squares([1.0, 3.0, 5.0, 7.0])\n\
    </cell>\n<cell>\nsum_squares([1.4, 4.2, 0.0])\n</cell>\n<cell>\nsum_squares([-2.4,\
    \ 1.0, 1.0])\n</cell>\n<text>\nTask 11: Create a generic function which converts\
    \ a given list into a string with each element separated by a comma\nExamples:\n\
    >>> lst([1.0, 2.0, 3.0])\n'1.0, 2.0, 3.0'\n>>> lst([1.0, 4.0, 9.0])\n'1.0, 4.0,\
    \ 9.0'\n>>> lst([1.4, 4.2, 0.0])\n'1.4, 4.2, 0.0'\n>>> lst([-2.4, 1.0, 1.0])\n\
    '-2.4, 1.0, 1.0'", "    ans = Float64(0.0)\n    for i in lst\n        ans = ans\
    \ + i^2\n    end\n    return ans\nend\n</code>\n<|/ a tags=julia,floating-point\
    \ |>\n<| c |>\nThanks Stefan. I have edited the answer to include the remarks\
    \ on rounding. Your answer is the one I have chosen, so I will accept it. I think\
    \ your remarks also have helped other people who have a similar question.\n<|/\
    \ c |>\n<| a dscore=0 |>\nI liked James' answer (although I ended up not using\
    \ it). Here are some other options which might be helpful:\n<code>", "    sum\
    \ = 0.0\n    for i in lst\n        sum += i * i\n    end\n    return sum\nend\n\
    \    \nend\n</cell>\n<code language=julia-1.5>", "    sum = 0\n    for i in lst\n\
    \        sum+=i*i\n    return sum\nend \n</code>\n<|/ a dscore=3 |>\n<| c |>\n\
    A bit hard to read your solution. Maybe some lines would help.\n<|/ c |>\n<| c\
    \ |>\nYes, I think it is a little hard to read. Do you mean that it is hard to\
    \ read, or hard to understand by reading the code? I tried to understand what\
    \ you mean by the solution and then edited it to make it clearer. I think the\
    \ code itself is quite readable. I think it would be great to have some comments\
    \ in the code (maybe some people will read it more easily, I really don't know).\
    \ Thanks!\n<|/ c |>\n<| c |>\nI mean to read: I do not get the meaning behind\
    \ `for i in lst` and `if typeof(Int64) == typeof(i)`. I see no use of `typeof`,\
    \ so i do not see the benefit of it.\n<|/ c |>\n<| c |>\nI have some questions\
    \ about the code: Why is the return type `Int64`?\n<|/ c |>\n<| c |>\nYou can\
    \ leave it without Int64, it would work without it too. The reason is that in\
    \ Julia a Vector{Int64} is convertable to an Int64. If you use typeof(i) you check\
    \ that the object i has type Int64.\n<|/ c |>\n<| a dscore=3 |>\nYou can use a\
    \ simple function\n<code>", "    sum = 0\n    for i in lst\n        sum+=i*i\n\
    \    return sum\nend", "    if length(lst) == 0\n        return 0 \n    \n   \
    \ sum = 0\n    for i in lst\n        sum += i*i\n    end\n    return roundup(sum,Ceil)\n\
    end\n</cell>\n<code language=julia-1.3>\nsum_squares([1.0,2.0,3.0])\n</cell>\n\
    <code language=julia-1.3>\nsum_squares([1.0,4.0,9.0])\n</cell>\n<code language=julia-1.3>\n\
    sum_squares([1.0,3.0,5.0,7.0])\n</cell>\n<code language=julia-1.3>\nsum_squares([-1.4,1.0,1.0])\n\
    </cell>\n<code language=julia-1.3>\nsum_squares([-2.4,1.0,1.0])\n</cell>\n<text>\n\
    Exercise 2", "    n = length(lst)\n    total = 0\n    for i in 1:n\n        total\
    \ = total + (lst[i]^2)\n    end\n    return total\nend", "    lst.round\n    sum=0\n\
    \    for i in lst\n        sum += i^2\n    end\n    return sum\nend \n</code>\n\
    <|/ a dscore=0 tags=julia,types |>\n<| a tags=julia,types dscore=0 |>\nTo round\
    \ a number to the nearest int, you can use ceiling.\nTo round a number to the\
    \ nearest float, you can use ceil.\nTo round a number to the nearest long double\
    \ number you can use ceiling if your compiler supports it.\n<|/ a |>\n<| c |>\n\
    What if the number is not an int?\n<|/ c |>\n<| c |>\nThen you should use the\
    \ appropriate function.\n<|/ c |>\n<| a dscore=0 |>\nYou can use round() and ceil()\
    \ functions like this:\n<code>\nround(3.1) --> 3\nround(3.15) --> 4\nceil(3.1)\
    \ --> 3\nceil(3.15) --> 4\n</code>\n<|/ a tags=julia,types |>\n<| c |>\nWhat if\
    \ number is not an int?\n<|/ c |>\n<| a dscore=0 |>\n<code>\njulia> round(3.1)\n\
    3", "  ans = sum([x*x for x in  lst])\n  return ans.round()\nend", "    sq = sum([x\
    \ .* x for x in lst])\n    return round(sq)\nend", "\tsum = 0\n\tfor i in lst\n\
    \t\tpush!(sum,i*i)\n\tend\n\treturn sum\nend", " \n    \n    sum_square = 0\n\
    \    for i in lst\n        sum_square += round(Float64(i),5)\n    end\n    return\
    \ sum_square\nend", "  \nend", "    lst = sort(lst)\n    squares = sum(lst*lst)\n\
    \    return round(squares)\nend\n</cell>\n<text>\nProblem 2b: Write a function\
    \ that takes in a vector and returns the mean of the vector.", "    # return sum(map(x\
    \ -> x^2, lst)) \n    # sum(map(x -> Int64, map(round, x))) \n    sum = 0\n  \
    \  for el in lst \n        sum += el^2 \n    end\n    return sum\nend\n</cell>\n\
    <text>\nExercise 4\nWrite a function is_palindrome that determines if the given\
    \ number is palindrome or not.\nYou should not convert it into string, just test\
    \ if the number is a palindrome.\nExamples:", "    if length(lst) == 0 \n    \
    \    0\n    elseif length(lst) == 1 \n        lst[0]^2 \n    else\n        sum(map(x\
    \ -> x^2, lst))\n    end\nend\n</cell>\n<text>\nTests", "    square_sum = 0\n\
    \    for i in lst\n        square_sum += i^2\n    end\n    return square_sum\n\
    end", "    result = sum(lst.^2)\n    return result\nend\n</code>\n<|/ a tags=julia,list\
    \ |>\n<| a |>\nUsing a for loop:\n<code>", "    \n    sum_ = 0\n    for x in lst\n\
    \        sum_ += x^2\n    end\n    return sum_\nend\n</cell>\n<code language=julia-1.6>\n\
    @test sum_squares([1.0, 2.0, 3.0]) == 14\n@test sum_squares([1.0, 4.0, 9.0]) ==\
    \ 98\n@test sum_squares([1.0, 3.0, 5.0, 7.0]) == 84\n@test sum_squares([1.4, 4.2,\
    \ 0.0]) == 29\n@test sum_squares([-2.4, 1.0, 1.0]) == 6\n</cell>\n<code language=julia-1.6>\n\
    \"\"\"", "    sum = 0.0\n    for x in lst\n        sum += (x^2)\n    end\n   \
    \ return sum\nend", "\t\n\tsum = 0\n\tfor i in 1:length(lst)\n\t\tsum = sum +\
    \ lst[i]^2\n\tend\n\treturn sum\nend", "    s = sum(lst)\n    for i in lst\n \
    \       s = s + (i * i)\n    end\n    s\nend", "    sum = 0\n    for i in lst\n\
    \        sum += i^2\n    end\n    return sum\nend\nsum_squares(lst)\n</cell>\n\
    <text>\nPart 5: Write a function to average a list of numbers\nWrite a function\
    \ that averages numbers in a list. \nIt is ok to assume that the list is non-empty.\n\
    It should return 0 if the list is empty or a list of numbers if the list is not\
    \ empty.", "    for i in lst\n        i+=i\n    end\n    return sum(map(x -> x.^2,\
    \ lst))\nend\n</code>\n<|/ a tags=julia,list |>\n<| a |>\nThe answer by is good\
    \ and I upvoted it, but it is still possible to improve it by doing some optimizations.\
    \ Here are my suggestions:\n<code>", "    if length(lst) == 0 \n        return\
    \ 0 \n    \n    sum = 0.0\n    for x in lst \n        sum += x^2 \n    end", " \
    \   sum = 0\n    for i in lst\n        sum += i * i\n    end\n    return sum\n\
    end", "    return sum(map(x -> round(x*x, ceil(Int, ceil(Int, x))), lst))\nend\n\
    sum_squares(vec())\n</cell>\n<code language=julia-1.6>", "    sum = 0\n    for\
    \ x in lst\n        sum += x^2\n    end\n    return sum\nend\n</cell>\n<text>\n\
    Task: What is your fastest function?"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
