name: HumanEval_27_flip_case
language: jl
prompt: "\"\"\" For a given string, flip lowercase characters to uppercase and uppercase\
  \ to lowercase.\n    >>> flip_case(\"Hello\")\n    \"hELLO\"\n    \"\"\"\nfunction\
  \ flip_case(string::String)::String \n"
tests: "using Test\n\n@testset begin\n\ncandidate = flip_case;\n\t@test(candidate(\"\
  \") == \"\")\n\t@test(candidate(\"Hello!\") == \"hELLO!\")\n\t@test(candidate(\"\
  These violent delights have violent ends\") == \"tHESE VIOLENT DELIGHTS HAVE VIOLENT\
  \ ENDS\")\nend\n"
completions: ["    str = string.to_lower()\n    for i in string.chars():\n       \
    \ if i.isupper():\n            str = str.replace(i, i.to_upper())\n    return\
    \ str\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work for strings containing\
    \ numbers, such as `'1a2b'`, nor does it work for strings containing punctuation.\n\
    <|/ c |>\n<| c |>\nThis is my answer but is too long\n<|/ c |>\n<| c |>\nI posted\
    \ this before you posted your answer, but I'm really not happy about your answer.\n\
    <|/ c |>\n<| c |>\nMy answer is more efficient\n<|/ c |>\n<| a dscore=0 tags=string,lowercase,uppercase\
    \ |>\nHere's a more straightforward answer:\n<code>", "        mutable res = \"\
    \"\n        for i in string:\n            if i.isUpper\n                res =\
    \ res..i.toLower\n            else if i.isLower\n                res = res..i.toUpper\n\
    \            else if i.isUpper\n                res = res..i.toLower\n       \
    \     else if i.isLower\n                res = res..i.toUpper\n            end\n\
    \        end\n        return res\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @doc flip_case\n</cell>\n<code language=julia-1.5>\n## Try it out on some examples:\n\
    </cell>\n<code language=julia-1.5>\n## Try it out on some examples:\n</cell>\n\
    <code language=julia-1.5>\n@doc flip_case\n</cell>\n<text>\nNow write a function\
    \ that accepts a list of strings and returns a list of words that end with the\
    \ letter 'e'", "    return string.map(string.toLowerCase) |> String.concat |>\
    \ string.toLowerCase\nend\n</cell>\n<text>\nWe could have also written this more\
    \ succinctly:", "    \n    string = string.lower()\n    string = string.capitalize()\n\
    \    return string\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\n    remove_punctuation(string::String)::String\
    \ \n    \n    Removes all punctuation from given string.\n\"\"\"", "    local\
    \ upper_char = string.characters:upper()\n    local lower_char = string.characters:lower()\n\
    \    return upper_char + lower_char\nend", "    \n    \"\"\"\n    Input:\n   \
    \ \n    string - A string to be flipped.\n    \n    Output:\n    \n    flipped_string\
    \ - A string with flipped case.\n    \n    Hint: Remember that strings are immutable.\
    \ Mutate strings instead.\n    \"\"\"", "    \n\"\"\"\n## flip_case_with_locale()",
  "    flip_case_result = string.map(x->string.toUpperCase()) if string.includes(\"\
    L\") else string.map(x->string.toLowerCase())\n    return flip_case_result\nend",
  "\"\"\"\n    return string.map(c=>c.isUpper?c.toLower():c.toUpper()).join(\"\")\n\
    end\n</cell>\n<code language=julia-1.5>\nusing BenchmarkTools\n</cell>\n<code\
    \ language=julia-1.5>\nflip_case(\"hello\")\n</cell>\n<text>\nBenchmarking\nJulia\
    \ comes with a benchmarking library BenchmarkTools.jl.  We can use this to benchmark\
    \ our two implementations.", "    if string == nil \n        \"\" \n    else \n\
    \        string.chars.map { |c| c == 'a' ? c : 'A' }\n            .foldl2(string)\
    \ { |acc, c| acc * 26 + c }.to_s\n    end\nend", "    \n    \"\"\"\n    lowercase\
    \ letters\n    uppercase letters\n    \"\"\"\n    mutable lowercase = \"\"\n \
    \   mutable uppercase = \"\"", "    string_lower = string.toLowerCase()\n    string_upper\
    \ = string.toUpperCase()\n    return string_lower + string_upper\nend\n</cell>\n\
    <code language=julia-1.1>\nusing BenchmarkTools\n</cell>\n<code language=julia-1.1>\n\
    @btime flip_case(\"Hello\")\n</cell>\n<code language=julia-1.1>\n@btime flip_case(\"\
    Hello\");\n</cell>\n<text>\nJulia's built-in functions include", "    return string\
    \ match {\n        'A'..'Z' => 'a'..'z',\n        'a'..'z' => 'A'..'Z',\n    \
    \    _ => string\n    }\nend\n</cell>\n<code language=julia-1.5>\n# Now let's\
    \ test the function with some examples.\nprintln(flip_case(\"Hello\"))\nprintln(flip_case(\"\
    world\"))\nprintln(flip_case(\"hello\"))\n</cell>\n<text>\nRemember that in Julia,\
    \ functions return a value rather than perform their work in-place. Here we see\
    \ that the function returns a new string rather than mutating the string in-place.",
  "    return string.replace(string.lower(), \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", string.upper())\n\
    end\n</cell>\n<code language=julia-1.0>\nusing Test\n</cell>\n<code language=julia-1.0>\n\
    @test flip_case(\"hELLO\") == \"hello\"\n</cell>\n<code language=julia-1.0>\n\
    @test flip_case(\"hello\") == \"hELLO\"\n</cell>\n<code language=julia-1.0>",
  "return string |> to_upper |> to_lower |> reverse |> to_string\n</code>\nThis works\
    \ because the functions to_upper and to_lower convert the string to Uppercase\
    \ and Lowercase, which are then flipped by reversing the string.\n<|/ a tags=string,julia\
    \ |>\n<| c |>\nThe last statement can be simplified to `return string.reverse`.\n\
    <|/ c |>\n<| c |>\nThanks a lot! My only problem with this is that I'm doing this\
    \ for my own practice in Julia. I would really appreciate an explanation of how\
    \ exactly these functions work, and why their output is the way they are. Thanks\
    \ again!\n<|/ c |>\n<| a |>\nThis is another possibility that doesn't involve\
    \ string manipulation:\n<code>", "    return string.toLowerCase() match {\n  \
    \      case x if x.isUpper() => x.toLower()\n        case x if x.isLower() =>\
    \ x.toUpper()\n        case _ => string\n    }\nend", "    \n    if string ==\
    \ \"\"\n        return string\n    \n    let char_list::Vector<Char> = string.chars()\n\
    \    \n    let result = char_list\n        .filter(fun x -> x >= 'a' && x <= 'z')\n\
    \        .map(fun x -> x.swapcase())\n        .mkString(\"\")\n    \n    if result\
    \ == \"\"\n        return string\n    \n    result\nend\n</cell>\n<code language=julia-1.6>\n\
    # Example", "    str = string.toLowerCase()\n    str = string.capitalize()\n \
    \   return str\n</code>\nThe above functions will only affect the string in memory.\
    \ \nIf you want a function to modify a variable in place (which you probably don't\
    \ want), you need to use the return keyword and explicitly assign the value to\
    \ the variable.\n<|/ a dscore=1 tags=julia,string |>\n<| c |>\nThis doesn't actually\
    \ answer the question.\n<|/ c |>\n<| c |>\nThe question asks how to upper/lower\
    \ case a string. Uppercase and lowercase are two very different operations and\
    \ they both have a different solution. Plus, you can always write your own function\
    \ if you need something more complex. It doesn't have to be a function.\n<|/ c\
    \ |>\n<| a |>\nIn julia you can do this:\n<code>\nstr = \"hello world\"", "  \
    \  if string == \"\"\n    else string \n        |> char.upper\n        |> char.lower\n\
    \        |> char.upper\n        |> string\n    end\nend\n</cell>\n<text>\nNow\
    \ let's try it with our sentence:", "    \n    string_chars = string.split('')\n\
    \    \n    return ''.join(map(lambda x: x if x.islower() else x.upper(), string_chars))",
  "    return string::String |> String.toUpperCase |> String.toLowerCase \nend\n</cell>\n\
    <code language=julia-1.1>\ntest_str = \"Hello\"\nflip_case(test_str)\n</cell>\n\
    <code language=julia-1.1>\ntest_str = \"HELLO\"\nflip_case(test_str)\n</cell>\n\
    <code language=julia-1.1>\ntest_str = \"hello\"\nflip_case(test_str)\n</cell>\n\
    <code language=julia-1.1>\ntest_str = \"HellO\"\nflip_case(test_str)\n</cell>\n\
    <code language=julia-1.1>\ntest_str = \"hello\"\nflip_case(test_str)\n</cell>\n\
    <code language=julia-1.1>\ntest_str = \"HELLO\"\nflip_case(test_str)\n</cell>\n\
    <code language=julia-1.1>", "\"\"\"    \n## Flip a string\nflip_case(string::String)\
    \ = \"\\U0153\\U0117\\U00E1\\U00E8\\U00E9\\U00EA\" |> string\n\"\"\"\n## Flip\
    \ a string\nflip_case(string::String) = \"\\U0153\\U0117\\U00E1\\U00E8\\U00E9\\\
    U00EA\" |> string\n\"\"\"", "    return string.map(flip_case).join(\" \")\nend",
  "  local upper = string.upper() \n  local lower = string.lower() \n  return upper\
    \ .. lower \nend", "    string = string.toLowerCase()\n    string = string.upper()\n\
    \    string = string.toLowerCase()\n    return string\nend\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"\n    capitalize_first(string::String)", "    uppercase = string.uppercase\n\
    \    lowercase = string.lowercase\n    return uppercase + lowercase\nend\n</cell>\n\
    <code language=julia-0.5>\n@time flip_case(\"Hello\") # ~10 ms\n</cell>\n<text>\n\
    Exercise: What is the time complexity of the function above?\nHint: Remember that\
    \ O() notation denotes the worst-case scenario for given inputs. Thus, for the\
    \ worst-case scenario of \"Hello\", the function has linear complexity. This is\
    \ a great time to remember that O() notation denotes the worst-case scenario!",
  "    string = string.map(x=>toupper(x))\n    string = string.map(x=>tolower(x))\n\
    \    return string\nend", "    local result = \"\"\n    for char in string:\n\
    \        if char.isupper():\n            char = tolower(char)\n        elif char.islower():\n\
    \            char = toupper(char)\n        else :\n            char\n        end\n\
    \        result += char\n    return result\nend\n</cell>\n<code language=julia-1.6>",
  "    local new_string = \"\"\n    local index = 0\n    while index < length(string)\
    \ do\n        if lower(string(index)) == upper(string(index)) then\n         \
    \   new_string =  new_string..upper(string(index))\n        elseif upper(string(index))\
    \ == lower(string(index)) then\n            new_string =  new_string..lower(string(index))\n\
    \        else\n            new_string =  new_string..string(index)\n        end\n\
    \        index = index + 1\n    end\n    return new_string\nend", "    \n    \"\
    \"\"\n    Write your function below.\n    \"\"\"\n    \n    return string\n</cell>\n\
    <cell>\n\"\"\"\nDON'T MODIFY ANYTHING IN THIS CELL THAT IS BELOW THIS LINE\n\"\
    \"\"\ntests.test_flip_case(flip_case)\n</cell>\n<text>\nThe string matching with\
    \ regular expressions\nIn Python, regular expressions (sometimes called regex)\
    \ are used for matching patterns in text. These patterns are not just strings,\
    \ but also have a representation similar to what we see in text. For example,\
    \ patterns like . or * are used in regex to match any one character from a set\
    \ of characters. In short, we use these kinds of patterns to find specific words\
    \ in our text: for example, in the sentence \"I saw a frog .\", the .(dot) represents\
    \ an actual dot, and the * means any number of characters.", "    return (string.map\
    \ { |character| character.downcase }).join(\"\").gsub(/[[:upper:]]/) { |a| a.upcase\
    \ }\nend\n</cell>\n<code language=julia-1.3>\n# Testing our function\nflip_case(\"\
    hello\")\n</cell>\n<text>\nString split and join\nThis section is adapted from\
    \ JuliaCon 2015 Data Science.", "    let\n        new_string = String()\n    \
    \    for i in string.chars() {\n            if i.is_lower {\n                new_string\
    \ += Character(i.upcase())\n            } else {\n                new_string +=\
    \ Character(i.lower())\n            }\n        }\n        new_string\n    end\n\
    end", "  new_string = string\n  for i in 0..length(string)\n    if string[i] >=\
    \ 'A' && string[i] <= 'Z' then\n      new_string = new_string.replace(string[i],\
    \ string[i].toupper())\n    elseif string[i] >= 'a' && string[i] <= 'z' then\n\
    \      new_string = new_string.replace(string[i], string[i].tolower())\n    end\n\
    \  end\n  return new_string\nend", "    uppercase = \"\"\n    for char in string:\n\
    \        if char.isUpperCase()\n            uppercase += char.lower()\n      \
    \  else\n            uppercase += char.upper()\n    return uppercase\nend", " \
    \   string = \"A\" + string + C(\"A\")\n    return string[2:]\nend", "  return\
    \ string.map(to_uppercase).map(to_lowercase)\nend", "    string = string.upcase()\n\
    \    string = string.downcase()\n    return string\nend", "  \n    for (ii,c)\
    \ in string:\n        if  (ii == 'A')\n        {\n            c = 'a'\n      \
    \  }\n        else if (ii == 'a')\n        {\n            c = 'A'\n        }\n\
    \        else if (ii == 'B')\n        {\n            c = 'B'\n        }\n    \
    \    else if (ii == 'b')\n        {\n            c = 'B'\n        }\n        else\
    \ if (ii == 'C')\n        {\n            c = 'C'\n        }\n        else if (ii\
    \ == 'c')\n        {\n            c = 'C'\n        }\n        else if (ii == 'D')\n\
    \        {\n            c = 'D'\n        }\n        else if (ii == 'd')\n    \
    \    {\n            c = 'D'\n        }\n        else if (ii == 'E')\n        {\n\
    \            c = 'E'\n        }\n        else if (ii == 'e')\n        {\n    \
    \        c = 'E'\n        }\n        else if (ii == 'F')\n        {\n        \
    \    c = 'F'\n        }\n        else if (ii == 'f')\n        {\n            c\
    \ = 'F'\n        }\n        else if (ii == 'G')\n        {\n            c = 'G'\n\
    \        }\n        else if (ii == 'g')\n        {\n            c = 'G'\n    \
    \    }\n        else if (ii == 'H')\n        {\n            c = 'H'\n        }\n\
    \        else if (ii == 'h')\n        {\n            c = 'H'\n        }\n    \
    \    else if (ii == 'I')\n        {\n            c = 'I'\n        }\n        else\
    \ if (ii == 'i')\n        {\n            c = 'I'\n        }\n        else if (ii\
    \ == 'J')\n        {\n            c = 'J'\n        }\n        else if (ii == 'j')\n\
    \        {\n            c = 'J'\n        }\n        else if (ii == 'K')\n    \
    \    {\n            c = 'K'\n        }\n        else if (ii == 'k')\n        {\n\
    \            c = 'K'\n        }\n        else if (ii == 'L')\n        {\n    \
    \        c = 'L'\n        }\n        else if (ii == 'l')\n        {\n        \
    \    c = 'L'\n        }\n        else if (ii == 'M')\n        {\n            c\
    \ = 'M'\n        }\n        else if (ii == 'm')\n        {\n            c = 'M'\n\
    \        }\n        else if (ii == 'N')\n        {\n            c = 'N'\n    \
    \    }\n        else if (ii == 'n')\n        {\n            c = 'N'\n        }\n\
    \        else if (ii == 'O')\n        {\n            c = 'O'\n        }\n    \
    \    else if (ii == 'o')\n        {\n            c = 'O'\n        }\n        else\
    \ if (ii == 'P')\n        {\n            c = 'P'\n        }\n        else if (ii\
    \ == 'p')\n        {\n            c = 'P'\n        }\n        else if (ii == 'Q')\n\
    \        {\n            c = 'Q'\n        }\n        else if (ii == 'q')\n    \
    \    {\n            c = 'Q'\n        }", "    uppercase_chars = string.chars()\n\
    \    lowercase_chars = string.chars().filter(x => x >= 'a' && x <= 'z')\n    uppercase_chars\
    \ = uppercase_chars.map(x => x - 'A')\n    lowercase_chars = lowercase_chars.map(x\
    \ => x - 'a')\n    \n    return String(uppercase_chars).concat(String(lowercase_chars))\n\
    end", "    \n  \n    string=string.map(tonumber)\n    \n    return string.map(char.upper)\n\
    end", "    for c in string:\n        if islower(c):\n            tolower(c)\n\
    \            toupper(c)\n        else \n            toupper(c)\n            tolower(c)\n\
    \    end\nend", "    \n    uppercase::String = \"\"\n    lowercase::String = \"\
    \"\n    for character in string\n        if character == character .upcase()\n\
    \            uppercase += character\n        else\n            lowercase += character\n\
    \    end\n    return lowercase\nend\n</cell>\n<text>\nTask: Convert all characters\
    \ in a string to uppercase. For example, \"ABC\" -> \"ABC\"", "    \n    uppercase\
    \ = string.upcase()\n    lowercase = string.downcase()\n    \n    return uppercase\
    \ + lowercase\nend", "    return string.chars.map {|c| c.swapcase.to_s}.join(\"\
    \")\nend", "    if string.isEmpty then return string\n    mutable result = \"\"\
    \n    for c in string.chars\n        if c.isUpper\n            then result +=\
    \ c.toUpper\n            else result += c.toLower\n    return result\n</cell>\n\
    <cell>\n@test flip_case(\"hello\") == \"hELLO\"\n@test flip_case(\"HELLO\") ==\
    \ \"hELLO\"\n</cell>\n<text>\nFilters\nFilters act on collections, either to select\
    \ out certain elements or to filter out certain elements.", "    if string.size\
    \ > 0\n        begin, end = string.begin(), string.end()\n        swap_case(begin,\
    \ end)\n        return string.substring(begin, end)\n    else\n        return\
    \ \"\"\nend", "    characters = string.split(\"\")\n    for i in characters\n\
    \        switch i\n            case \"a\" -> \"A\"\n            case \"b\" ->\
    \ \"B\"\n            case \"c\" -> \"C\"\n            case \"d\" -> \"D\"\n  \
    \          case \"e\" -> \"E\"\n            case \"f\" -> \"F\"\n            case\
    \ \"g\" -> \"G\"\n            case \"h\" -> \"H\"\n            case \"i\" -> \"\
    I\"\n            case \"j\" -> \"J\"\n            case \"k\" -> \"K\"\n      \
    \      case \"l\" -> \"L\"\n            case \"m\" -> \"M\"\n            case\
    \ \"n\" -> \"N\"\n            case \"o\" -> \"O\"\n            case \"p\" -> \"\
    P\"\n            case \"q\" -> \"Q\"\n            case \"r\" -> \"R\"\n      \
    \      case \"s\" -> \"S\"\n            case \"t\" -> \"T\"\n            case\
    \ \"u\" -> \"U\"\n            case \"v\" -> \"V\"\n            case \"w\" -> \"\
    W\"\n            case \"x\" -> \"X\"\n            case \"y\" -> \"Y\"\n      \
    \      case \"z\" -> \"Z\"\n            case \"A\" -> \"a\"\n            case\
    \ \"B\" -> \"b\"\n            case \"C\" -> \"c\"\n            case \"D\" -> \"\
    d\"\n            case \"E\" -> \"e\"\n            case \"F\" -> \"f\"\n      \
    \      case \"G\" -> \"g\"\n            case \"H\" -> \"h\"\n            case\
    \ \"I\" -> \"i\"\n            case \"J\" -> \"j\"\n            case \"K\" -> \"\
    k\"\n            case \"L\" -> \"l\"\n            case \"M\" -> \"m\"\n      \
    \      case \"N\" -> \"n\"\n            case \"O\" -> \"o\"\n            case\
    \ \"P\" -> \"p\"\n            case \"Q\" -> \"q\"\n            case \"R\" -> \"\
    r\"\n            case \"S\" -> \"s\"\n            case \"T\" -> \"t\"\n      \
    \      case \"U\" -> \"u\"\n            case \"V\" -> \"v\"\n            case\
    \ \"W\" -> \"w\"\n            case \"X\" -> \"x\"\n            case \"Y\" -> \"\
    y\"\n            case \"Z\" -> \"z\"\n            default -> i\n        end\n\
    \    end\n    return join(characters, \"\")\nend\n</cell>\n<code language=julia-1.5>",
  "    \"Replace each character in a string with its uppercase version and vice versa\"\
    \n    let=string.lowercase\n    string.lowercase=string.uppercase\n    string.uppercase=let\n\
    \    return string\nend\n</code>\n<|/ a dscore=1 tags=lowercase,uppercase,julia,string\
    \ |>\n<| c |>\nThe first solution also works in python 3.8. Thank you!\n<|/ c\
    \ |>\n<| a dscore=1 tags=lowercase,uppercase,julia,string |>\nHere is a fast solution,\
    \ using Julia's broadcasting features (a feature that many people fail to understand\
    \ yet).\n<code>", "    \n    string_length = len(string)\n    \n    for i in string_length\n\
    \        \n        if string[i] == string[i+1]\n            string[i] = string[i].upper()\n\
    \            string[i+1] = string[i+1].lower()\n        \n        else\n     \
    \       string[i] = string[i].lower()\n            string[i+1] = string[i+1].upper()\n\
    \        \n    end\n    \n    return string\nend\n</cell>\n<code language=julia-1.2>\n\
    \"\"\"\nFor a given string, convert every uppercase letter to lowercase and vice\
    \ versa.\n>>> to_lower(\"Hello\")\n\"hello\"\n>>> to_upper(\"hello\")\n\"HELLO\"\
    \n>>> to_lower(\"HELLO\")\n\"hello\"\n>>> to_upper(\"hello\")\n\"HELLO\"\n\"\"\
    \"", "    tmp = string # in case the string is empty\n    map(char,string) do\
    \ c \n        char(c) = (if char(c) < \"a\" then char(c) + 32\n              \
    \  elseif char(c) >= \"A\" then char(c) - 32\n                else char(c)) \n\
    \    end\n    return string\nend\n</code>\n<|/ a |>\n<| a |>\nMy answer is a bit\
    \ too late, but I think it is still useful. I want to post it for future reference.\n\
    You can do something like this.\n<code>\nlet replace_lower_case(c::Char)::Char\
    \ = if c < 'a' then c - 'a' + 'A'\n                else if c < 'A' then c - 'A'\
    \ + 'a'\n                else c\n</code>\n<|/ a tags=string,julia dscore=3 |>\n\
    <| c |>\nThis works very well for ASCII characters, but is broken for non-ASCII\
    \ characters.\n<|/ c |>\n<| a tags=string,julia |>\nTo make it work for ASCII\
    \ and non-ASCII characters, you could use the following code:\n<code>", "    \n\
    \    mutable outstring = \"\"\n    for char in string.chars\n        if islower(char)\n\
    \            outstring .= upper(char)\n        else \n            outstring .=\
    \ lower(char)\n    return outstring\n</cell>\n<code language=julia-1.0>", "  \
    \  local result = \"\"\n    for character in string:\n        if character ==\
    \ \"a\" or character == \"A\":\n            character = \"A\"\n        elif character\
    \ == \"b\" or character == \"B\":\n            character = \"B\"\n        elif\
    \ character == \"c\" or character == \"C\":\n            character = \"C\"\n \
    \       elif character == \"d\" or character == \"D\":\n            character\
    \ = \"D\"\n        elif character == \"e\" or character == \"E\":\n          \
    \  character = \"E\"\n        elif character == \"f\" or character == \"F\":\n\
    \            character = \"F\"\n        elif character == \"g\" or character ==\
    \ \"G\":\n            character = \"G\"\n        elif character == \"h\" or character\
    \ == \"H\":\n            character = \"h\"\n        elif character == \"i\" or\
    \ character == \"I\":\n            character = \"I\"\n        elif character ==\
    \ \"j\" or character == \"J\":\n            character = \"J\"\n        elif character\
    \ == \"k\" or character == \"K\":\n            character = \"K\"\n        elif\
    \ character == \"l\" or character == \"L\":\n            character = \"L\"\n \
    \       elif character == \"m\" or character == \"M\":\n            character\
    \ = \"m\"\n        elif character == \"n\" or character == \"N\":\n          \
    \  character = \"N\"\n        elif character == \"o\" or character == \"O\":\n\
    \            character = \"o\"\n        elif character == \"p\" or character ==\
    \ \"P\":\n            character = \"P\"\n        elif character == \"q\" or character\
    \ == \"Q\":\n            character = \"Q\"\n        elif character == \"r\" or\
    \ character == \"R\":\n            character = \"R\"\n        elif character ==\
    \ \"s\" or character == \"S\":\n            character = \"s\"\n        elif character\
    \ == \"t\" or character == \"T\":\n            character = \"t\"\n        elif\
    \ character == \"u\" or character == \"U\":\n            character = \"U\"\n \
    \       elif character == \"v\" or character == \"V\":\n            character\
    \ = \"v\"\n        elif character == \"w\" or character == \"W\":\n          \
    \  character = \"W\"\n        elif character == \"x\" or character == \"X\":\n\
    \            character = \"X\"\n        elif character == \"y\" or character ==\
    \ \"Y\":\n            character = \"Y\"\n        elif character == \"z\" or character\
    \ == \"Z\":\n            character = \"Z\"\n        elif character == \"A\" or\
    \ character == \"a\":\n            character = \"a\"\n        elif character ==\
    \ \"B\" or character == \"b\":\n            character = \"b\"\n        elif character\
    \ == \"C\" or character == \"c\":\n            character = \"c\"\n        elif\
    \ character == \"D\" or character == \"d\":\n            character = \"d\"\n \
    \       elif character == \"E\" or character == \"e\":\n            character\
    \ = \"e\"\n        elif character == \"F\" or character == \"f\":\n          \
    \  character = \"", "    \n    lowercase_string = \"\" \n    uppercase_string\
    \ = \"\" \n    for letter in string.split() do \n        if letter == \"A\" then\
    \ \n            uppercase_string += \"a\" \n        else if letter == \"B\" then\
    \ \n            uppercase_string += \"b\" \n        else if letter == \"C\" then\
    \ \n            uppercase_string += \"c\" \n        else if letter == \"D\" then\
    \ \n            uppercase_string += \"d\" \n        else if letter == \"E\" then\
    \ \n            uppercase_string += \"e\" \n        else if letter == \"F\" then\
    \ \n            uppercase_string += \"f\" \n        else if letter == \"G\" then\
    \ \n            uppercase_string += \"g\" \n        else if letter == \"H\" then\
    \ \n            uppercase_string += \"h\" \n        else if letter == \"I\" then\
    \ \n            uppercase_string += \"i\" \n        else if letter == \"J\" then\
    \ \n            uppercase_string += \"j\" \n        else if letter == \"K\" then\
    \ \n            uppercase_string += \"k\" \n        else if letter == \"L\" then\
    \ \n            uppercase_string += \"l\" \n        else if letter == \"M\" then\
    \ \n            uppercase_string += \"m\" \n        else if letter == \"N\" then\
    \ \n            uppercase_string += \"n\" \n        else if letter == \"O\" then\
    \ \n            uppercase_string += \"o\" \n        else if letter == \"P\" then\
    \ \n            uppercase_string += \"p\" \n        else if letter == \"Q\" then\
    \ \n            uppercase_string += \"q\" \n        else if letter == \"R\" then\
    \ \n            uppercase_string += \"r\" \n        else if letter == \"S\" then\
    \ \n            uppercase_string += \"s\" \n        else if letter == \"T\" then\
    \ \n            uppercase_string += \"t\" \n        else if letter == \"U\" then\
    \ \n            uppercase_string += \"u\" \n        else if letter == \"V\" then\
    \ \n            uppercase_string += \"v\" \n        else if letter == \"W\" then\
    \ \n            uppercase_string += \"w\" \n        else if letter == \"X\" then\
    \ \n            uppercase_string += \"x\" \n        else if letter == \"Y\" then\
    \ \n            uppercase_string += \"y\" \n        else if letter == \"Z\" then\
    \ \n            uppercase_string += \"z\" \n        else if letter == \"a\" then\
    \ \n            lowercase_string += \"A\" \n        else if letter == \"b\" then\
    \ \n            lowercase_string += \"B\" \n        else if letter == \"c\" then\
    \ \n            lowercase_string += \"C\" \n        else if letter == \"d\" then\
    \ \n            lowercase_string += \"D\" \n        else if letter == \"e\" then\
    \ \n            lower", "    return string.map(x=>x.upper()+x.toLowerCase())\n\
    end", "\"\"\"Flip uppercase characters to lowercase and lowercase characters to\
    \ uppercase.\n    >>> flip_case(\"hello\")\n    \"HELLO\"\n    \"\"\"", "    if\
    \ string.isUpper() then\n        string.upper() \n    else\n        string.lower()\n\
    \    end\nend", "    return string.map(x => x == char(\"A\") ? char(\"a\") : x\
    \ == char(\"a\") ? char(\"A\") : char(x))\nend", "    # Write your code in Python\
    \ 3 style here\n    result = \"\"\n    for char in string:\n        if char.isupper():\n\
    \            result += char.lower()\n        else:\n            result += char.upper()\n\
    \    return result\n</cell>\n<cell>\n# Run this cell to check your result\nresult\
    \ = flip_case(\"Hello\")\ncheck('result', result, expected = 'hELLO')\n</cell>\n\
    <text>\nFinally! You've learned how to write loops in Julia. One more thing before\
    \ we continue: you can also write while loops. While loops are extremely useful\
    \ when working with continuous computation, as we're doing in this notebook. For\
    \ example, we can use while loops to keep asking the user for input until they\
    \ give us what we want.", "    result <- string\n    for(i in 1:length(result))\
    \ {\n        if(result[i] < \"a\") {\n            result[i] <- toupper(result[i])\n\
    \        } else if (result[i] > \"Z\") {\n            result[i] <- tolower(result[i])\n\
    \        }\n    }\n    return result\nend\n</cell>\n<code language=julia-0.5>\n\
    # Test Case #1\n@test flip_case(\"hello\") == \"hELLO\"\n</cell>\n<code language=julia-0.5>\n\
    # Test Case #2\n@test flip_case(\"H\") == \"h\"\n</cell>\n<text>\nmap()", "  \
    \  lowercase_chars = string.lower()\n    uppercase_chars = string.upper()\n  \
    \  return uppercase_chars + lowercase_chars\nend \"\"\"", "    # write your code\
    \ here\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    remove_excess_spaces()",
  "   return string.swapcase()\nend\n</cell>\n<code language=julia-0.6>\n\"\"\"\n\
    \    title_case(string::String)::String", "    local new_string = \"\"\n    for\
    \ c in string:gmatch(\"([a-z])\") do\n        if c == \"l\" then\n           \
    \ new_string = new_string .. \"L\"\n        elseif c == \"L\" then\n         \
    \   new_string = new_string .. \"l\"\n        else\n            new_string = new_string\
    \ .. c\n        end\n    end\n    return new_string\nend", "    str = string |>\
    \ toUpper\n    str = string |> toLower\n    str = str |> toUpper\n    \n    return\
    \ str\nend", "    \n    #write your code here\n    \n    \n    return string\n\
    \    \n</cell>\n<text>\nProblem 4.\nWrite a function that takes a string as an\
    \ argument and returns a string with all the punctuation removed.\nThe punctuation\
    \ should be removed from the following list of punctuations: \",.!?;:'\\\"()[]{}\"\
    \n(Use this list to define the function and to test it.)", "    char_map = map((x->if\
    \ x==x.tolower() then x.toupper() else x), string)\n    return \"\".join(char_map)\n\
    end\n</cell>\n<code language=julia-1.5>\nflip_case(\"Hello\")\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that removes characters from a given string that\
    \ appear in a given list.", "    l = string.split(\"\") \n    for i in l do \n\
    \        i = toupper(i) \n    end\n    return join(l,\"\")\nend\n</cell>\n<text>\n\
    Tests\nLet's see some examples.", "    if string == \"\"\n        return \"\"\n\
    \    uppercase = \"\"\n    lowercase = \"\"\n    for c in string\n        if isUpper(c)\n\
    \            uppercase += toLower(c)\n        else if isLower(c)\n           \
    \ lowercase += toUpper(c)\n        else \n            uppercase += c\n    return\
    \ uppercase + lowercase\nend", "   return string.chars.map {|x| x.eql?(\"a\")\
    \ ? \"A\".upcase :\n                                 x.eql?(\"A\") ? \"a\".upcase\
    \ :\n                                 x.eql?(\"i\") ? \"I\".upcase :\n       \
    \                          x.eql?(\"I\") ? \"i\".upcase :\n                  \
    \               x.eql?(\"o\") ? \"O\".upcase :\n                             \
    \    x.eql?(\"O\") ? \"o\".upcase :\n                                 x.eql?(\"\
    u\") ? \"U\".upcase :\n                                 x.eql?(\"U\") ? \"u\"\
    .upcase :\n                                 x.eql?(\"y\") ? \"Y\".upcase :\n \
    \                                x.eql?(\"Y\") ? \"y\".upcase :\n            \
    \                     x }\nend\n</cell>\n<code language=julia-0.6>\n\"\"\"\n \
    \   strip_spaces(string::String)", "    local char = string.[1]\n    if char ==\
    \ 'a' then\n        return 'A'\n    elseif char == 'A' then\n        return 'a'\n\
    \    elseif char == 'e' then\n        return 'E'\n    elseif char == 'E' then\n\
    \        return 'e'\n    elseif char == 'i' then\n        return 'I'\n    elseif\
    \ char == 'I' then\n        return 'i'\n    elseif char == 'o' then\n        return\
    \ 'O'\n    elseif char == 'O' then\n        return 'o'\n    elseif char == 'u'\
    \ then\n        return 'U'\n    elseif char == 'U' then\n        return 'u'\n\
    \    elseif char == 'y' then\n        return 'Y'\n    elseif char == 'Y' then\n\
    \        return 'y'\n    else\n        return string\n    end\nend\n</cell>\n\
    <code language=julia-1.5>", "    str = string:lower()\n    str = str:upper()\n\
    \    str = str:lower()\n    return str\nend\n</cell>\n<code language=julia-1.5>\n\
    # Let's test our function\nflip_case(\"HellO\")\n</cell>\n<text>\nExercise 9\n\
    Write a function that will apply a function to every element of an array. For\
    \ example, to multiply all the elements of a vector by a number (say 2), you can\
    \ do something like this.", "    return string.replace(string.lower(),string.upper())\n\
    end\n</cell>\n<code language=julia-1.4>\nflip_case(\"hello\")\n</cell>\n<code\
    \ language=julia-1.4>", "    string::String \n    string::String = \n        if\
    \ string.charAt(0)==\"A\" then string.charAt(1) == \"a\" else string.charAt(0)\
    \ == \"a\" end\n        else string\n    end\nend\n</cell>\n<code language=julia-1.0>",
  "    \"\"\"\n    Convert all uppercase letters to lowercase and vice versa.\n  \
    \  >>> flip_case(\"Hello\")\n    \"hELLO\"\n    \"\"\"", "    \"Returns a string\
    \ with all the lowercase chars replaced by uppercase and vice-versa.\"\n    return\
    \ string.fold(\"[A-Z]\", char::Char, char::Char)::String\nend \n</cell>\n<code\
    \ language=julia-0.6>", "    \n    if string == \"\"\n        then return \"\"\
    \n    else\n        let\n            chars = string.to_list()\n            result\
    \ = \"\"\n            for i in 0..chars.length-1\n                do if chars[i]\
    \ == 'A' \n                    then result += \"B\"\n                    else\
    \ if chars[i] == 'a'\n                        then result += \"b\"\n         \
    \           else if chars[i] == 'B' \n                        then result += \"\
    a\"\n                    else if chars[i] == 'b'\n                        then\
    \ result += \"A\"\n                    else\n                        result +=\
    \ chars[i]\n        end\n    \n        result\nend\n</cell>\n<code language=julia-1.3>\n\
    # Solution", "    mutable out = \"\"\n    string.split('').map(char.upper).map(char.lower).map(out.append(_))\n\
    \    out\nend\n</cell>\n<text>\nExample\nLet's try it out!", "    if is_string(string)\
    \ == true\n        string = string.to_lowercase()\n        string = string.to_uppercase()\n\
    \        string = string.to_lowercase()\n    end\n    return string\nend", " \
    \   local string = string\n    for i, c in ipairs(string) do\n        if c:lowercase()\
    \ ~= c:uppercase() then \n            string[i] = c:uppercase() \n        end\n\
    \    end\n    return string\nend\n</cell>\n<code language=julia-1.6>", "    local\
    \ result = \"\"\n    local char = \"\"\n    local index = 1\n    local length\
    \ = string.length", "\"\"\"\n    flip_case(string::String) = \"\\U$string\"\n\
    end", "    \n    string = string\n    string_len = length(string)", "    \n  \
    \  lowercase_string = string.lower()\n    uppercase_string = lowercase_string.upper()\n\
    \    \n    return uppercase_string\n</cell>\n<cell>\n\"\"\"# Problem 1\n\"\"\"",
  "    \"\"\"Transform string to lowercase\"\"\"\n    return string.lower()", "  \
    \  string = string.to_string()\n    \n    for x in string.chars() {\n        if\
    \ (x.isLower())\n            x.toUpper()\n        else\n            x.toLower()\n\
    \    }\n    \n    return string\nend ", "    upperCaseString::String = string.uppercase\n\
    \    lowerCaseString::String = string.lowercase\n    return lowerCaseString +\
    \ upperCaseString\n</code>\n<|/ a dscore=0 tags=case,uppercase,lowercase,string,haskell\
    \ |>\n<| a dscore=0 |>\nIn Haskell, strings come in two main forms:", "    local\
    \ result = \"\" \n    for c in string.chars() \n        do \n            if c.lower()\
    \ == c then result = result + c.upper() \n            else result = result + c.lower()\
    \ \n            end \n        end \n    return result \nend\n</cell>\n<code language=julia-1.6>",
  "</code>\n<|/ a tags=lowercase,uppercase,string,python |>\n<| c |>\nThe main thing\
    \ with this is that you don't have to type the return everytime.\n<|/ c |>\n<|\
    \ c |>\n`string.upper()` does not change the original string.  You must explicitly\
    \ assign the return value.\n<|/ c |>\n<| a tags=lowercase,uppercase,string,python\
    \ dscore=5 |>\nThis should do the trick:\n<code>\n>>> s = 'hello world'\n>>> s.swapcase()\n\
    'HELLO WORLD'\n</code>\n<|/ a |>\n<| c |>\nYou don't need to assign the result\
    \ of `s.swapcase()` to anything; you can just call it on the original string.\n\
    <|/ c |>\n<| a dscore=5 |>\n<code>\n>>> s = 'Hello World'\n>>> s.upper()\n'HELLO\
    \ WORLD'\n</code>\n<|/ a tags=lowercase,uppercase,string,python |>\n<| c |>\n\
    No, that will change s to upper case string. s = s.upper() will change string\
    \ to upper case string. s.upper() and s both are same.\n<|/ c |>\n<| c |>\n`s.upper()\
    \ returns <string> object` and assignment statement `s = s.upper()` just assigns\
    \ the `<string> object` to `s`. There is no return value. The `<string> object`\
    \ will be changed to upper case string. Try `s.upper() == 'HELLO WORLD'`.\n<|/\
    \ c |>\n<| c |>\nYes, but you assign the return value of .upper() to s. If you\
    \ just call .upper() then you dont have to.\n<|/ c |>\n<| c |>\n: Nope. Assignment\
    \ statement `s = s.upper()` will change the `<string> object` to upper case string.\
    \ Try `s = 'hello world'\ns.upper() == 'HELLO WORLD'`.\n<|/ c |>\n<| c |>\ns.upper()\
    \ returns a new string\n<|/ c |>\n<| a tags=lowercase,uppercase,string,python\
    \ dscore=5 |>\nYou can use upper, lower:\n<code>\n>>> 'hello world'.upper()\n\
    'HELLO WORLD'", "    \n    flip_case = string.swapcase() \n    \n    return flip_case\n\
    </cell>\n<text>\nTest your Code\nRun the cell below to test your code.", "   \
    \ local ret = \"\"\n    for char in string\n        do\n            local new\
    \ = char == tolower(char) and toupper(char) or tolower(char)\n            ret\
    \ ~= new and ret ~= char(tolower(ret)) or ret ~= char(toupper(ret))\n        end\n\
    \    end\n    return ret\nend\n</code>\n<|/ a dscore=5 |>\n<| a dscore=5 tags=string,lowercase,uppercase,lua,python\
    \ |>\nI know this was answered but here's an alternative to that which just uses\
    \ python's string library:\n<code>\nimport string ", "    \n    local result=string.lower()\n\
    \    local upper=string.upper\n    for i=string.len(result)-1,1,-1 do \n     \
    \   result[i]=upper(result[i])\n    end\n    return result\nend\n</code>\n<|/\
    \ a dscore=5 |>\n<| c |>\nThis is great, thanks for sharing. I was trying to figure\
    \ a way to solve this using regular expressions and I love this solution.\n<|/\
    \ c |>\n<| c |>\nI like this solution since it makes it easy to extend it to handle\
    \ more cases.\n<|/ c |>\n<| c |>\nThanks a lot!  This was extremely helpful and\
    \ saved me a lot of time.\n<|/ c |>\n<| a |>\nIf you need to transform a string\
    \ of any kind to uppercase or lowercase:\n<code>", "return string.map (\\c ->\
    \ if c in ('a','A') then c else ('A' + c))\nend\n\"\"\"", "    local new_string\
    \ = \"\"\n    for character in string:\n        if character == character:\n \
    \           new_string += character\n        else if character == tostring(lower(character)):\n\
    \            new_string += tostring(upper(character))\n        else if character\
    \ == tostring(upper(character)):\n            new_string += tostring(lower(character))\n\
    \        else \n            new_string += tostring(character)\n    return new_string",
  "    \n    local uppercase = [Char.ascii_uppercase]\n    local lowercase = [Char.ascii_lowercase]\n\
    \    \n    for c in string:\n        if c in uppercase:\n            string =\
    \ string.replace(tostring(c), tostring(c).upper())\n        elif c in lowercase:\n\
    \            string = string.replace(tostring(c), tostring(c).lower())\n    \n\
    \    return string\nend", "return string.map(char => char.isUppercase ? char.toLowercase\
    \ : char.toUppercase)\n</code>\n<|/ a tags=uppercase,string,lowercase,swift |>\n\
    <| c |>\nWhat about `\xDF` which is valid in the German language?\n<|/ c |>\n\
    <| a tags=uppercase,string,lowercase,swift dscore=5 |>\nSwift 4 with extension:\n\
    <code>\nextension String {\n    func toUppercase() -> String {\n        return\
    \ self.capitalizingFirstLetter()\n    }\n}\n</code>\nUsage:\n<code>\n\"\xDCber\"\
    .toUppercase() // \"\xDCber\"\n</code>\n<|/ a |>\n<| c |>\nThis should be the\
    \ accepted answer. Much more simple and readable.\n<|/ c |>\n<| c |>\nThis should\
    \ be the accepted answer. Much more simple and readable.\n<|/ c |>\n<| a dscore=5\
    \ |>\nSwift 3.0\n<code>\nextension String{\n   var toUpper: String {\n       \
    \ return self.map { String($0) }\n                .map { String($0, uppercase)\
    \ }\n                .joinWithSeparator(\"\")\n   }\n}\n</code>\nUsage\n<code>\n\
    \"\xDCber\".toUpper // \"\xDCber\"\n</code>\n<|/ a tags=uppercase,string,lowercase,swift\
    \ |>\n<| c |>\nThis is an improvement on [Kyle's answer](http://stackoverflow.com/a/30449363/2227743)\
    \ which uses `map` and `.joinWithSeparator`. You might want to explain how that\
    \ works.\n<|/ c |>\n<| c |>\nExplanation of code can be found here: https://stackoverflow.com/a/30449363/2827520\n\
    <|/ c |>\n<| c |>\nThis answer is better than my answer as it also replaces the\
    \ non-alpha character with empty string\n<|/ c |>\n<| a dscore=5 tags=uppercase,string,lowercase,swift\
    \ |>\nIn Swift 2.2 and Swift 3, you can use the following code snippet:\n<code>\n\
    extension String {\n    func toTitleCase() -> String {\n        let firstLetter\
    \ = self.characters.first\n        if let firstLetter = firstLetter {\n      \
    \      return String(firstLetter).uppercased() + String(firstLetter).lowercased()\n\
    \        } else {\n            return \"\"\n        }\n    }\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThis does not work if the string starts with a letter that cannot\
    \ be capitalized (", "    let  chars = string.lowercase()\n    chars = chars.uppercase()\n\
    \    chars = chars.lowercase()\n    return chars\nend", '    return string.map
    { char ->  char.toUpperCase + char.toLowerCase }', "    lowercase_string = \"\"\
    \n    for char in string:\n        if char.islower()\n            char.upcase()\n\
    \        else\n            char.lowercase()\n            lowercase_string += char\n\
    \    end\n    lowercase_string\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\nHere\
    \ is a simple solution using string manipulation and regex. I've also added a\
    \ type signature for clarity and flexibility.\n<code>", "    if string.size ==\
    \ 0 \n        return string\n    if string.size == 1 \n        return string\n\
    \    if string.head[1] == string.head[1] \n        string.head[2] = string.head[2]\n\
    \        string.head[3] = string.head[3]\n        return string\n    head :: String\n\
    \    head::String = string.head\n    tail :: String\n    tail::String = string.tail\n\
    \    return head::String + string.tail\nend \"\"\"", "    lowercase(string)\n\
    \    uppercase(string)\n    lowercase(string)\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\n    uppercase(string::String)", "    local new_string = \"\"\n    for\
    \ c in string\n        do \n            if tostring(c) == 'a'\n              \
    \  then new_string = new_string .. 'A' \n            else if tostring(c) == 'A'\n\
    \                then new_string = new_string .. 'a'\n            else new_string\
    \ = new_string .. tostring(c)  \n            end\n        end \n    return new_string\n\
    end", "    return string.fold(\"[XYZ]\", (x,y) -> (if x == y then x else lower(x))::Char)\n\
    end", "    \n    upper_str = string\n    upper_str = upper_str.toUpperCase()\n\
    \    lower_str = upper_str\n    lower_str = lower_str.toLowerCase()\n    \n  \
    \  return lower_str\n    \nend\n</cell>\n<text>\nLet's test it out using the example\
    \ from above:", "     \n     \n    return string.map((x) -> (if x.isLowerCase\
    \ then x.toUpperCase else x.toLowerCase end)).mkString\nend\n</cell>\n<code language=julia-1.5>\n\
    # Exercise 3\n\"\"\"\nFlip a string case if an upper case character follows a\
    \ lower case character and vice versa", "    char = string.head\n    new_string\
    \ = \"\"\n    while char do \n        if char.isUpper() then\n            new_string\
    \ += char.lowerCase()\n        else\n            new_string += char\n        end\n\
    \        char = char.tail\n    end\n    return new_string\nend\n</cell>\n<text>\n\
    Exercise 8: Write a function that prints all the possible combinations of all\
    \ the characters in a string using a backtracking algorithm. For example, if your\
    \ input string is \"ABCD\", your output would be:\nA\nAB\nABC\nABCD\nB\nBC\nBCD\n\
    C\nCD", "    \n    string = lower(string)\n    string = string.capitalize()\n\
    \    \n    return string\nend\n</cell>\n<code language=julia-1.1>\n\"\"\"\n  \
    \  function convert_case(string::String)::String", "    return string.map(toUpper)\n\
    end\n</code>\n<|/ a tags=uppercase,lowercase,lowercase,julia dscore=2 |>\n<| c\
    \ |>\nIn case you want to use this package on Windows `tolower()` will work instead\
    \ of `toUpper()`.\n<|/ c |>\n<| a dscore=2 |>\nThis seems to be the most efficient\
    \ solution. I am not aware of a package that does this efficiently though.\n<code>\n\
    using Random", "\"\"\"\n    flip_case(string)\n    string = string.lower()\n \
    \   string.upcase()\n    return string\nend", "    char_map(string, toUpperCase)\n\
    \    char_map(string, toLowerCase)\nend", "        string |> String.reverse |>\
    \ String.toUpper |> String.toLower\nend", "  case string.head of\n    string[]\
    \ -> string.tail.map flip_case string.tail.head\n    _ -> string\nend\n</code>\n\
    <|/ a tags=string,lowercase,uppercase,julia |>\n<| a tags=string,lowercase,uppercase,julia\
    \ |>\nThis might be another option\n<code>\ns = \"hello\"\nflip = map(x->isupper(x)\
    \ ? x : tolower(x), s)\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nHere are\
    \ 2 other methods that do not use the standard library:\n<code>\nuppercase(String)\n\
    lowercase(String)", "    string_arr = split(string,\" \")\n    for (i,s) in enumerate([lower(x)\
    \ for x in string_arr]):\n        string_arr[i] = flip(s,\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    )\n    string = join(string_arr,\" \")\n    return string\nend\n</code>\n<|/ a\
    \ tags=string,julia,arrays,split |>\n<| a dscore=2 |>\nHere is a solution using\
    \ a regular expression to split on non-word characters, e.g. spaces, punctuation,\
    \ and digits (and more).\n<code>\nusing Regexp", "    # Initialize result to the\
    \ empty string.\n    result = \"\"\n    # Iterate over the string and add each\
    \ character in the string to the result string. \n    for (index, element) in\
    \ enumerate(string) \n        # if the character is lowercase add the character\
    \ to the result string in uppercase \n        if (element >= 'a' and element <=\
    \ 'z') \n            result += element.upper()\n        # if the character is\
    \ uppercase add the character to the result string in lowercase\n        if (element\
    \ >= 'A' and element <= 'Z') \n            result += element.lower()\n    end",
  "    lowercase = copy(string)\n    uppercase = copy(string)\n    for i in lowercase:\n\
    \        if lowercase[i] == uppercase[i]:\n            lowercase[i] = uppercase[i].upper()\n\
    \            uppercase[i] = lowercase[i].lower()\n    return uppercase\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThe first solution is slower than this one because\
    \ it iterates over all the characters.  If you were to write this in a function,\
    \ it would be the best solution.\n<|/ c |>\n<| a tags=string,uppercase,lowercase,haskell\
    \ |>\n<code>\nimport Data.List (split,takeWhile)\nimport Data.Char (toUpper, toLower)\n\
    import Data.List (sort,group)", "    l = string.chars()\n    l = filter(flip_case,\
    \ l)\n    return \"\".join(l)\n</code>\n<|/ a tags=string,lowercase,uppercase,python\
    \ |>\n<| a tags=string,lowercase,uppercase,python |>\n<code>\ndef swap_case(string):\n\
    \    return \"\".join(sorted(string, key=lambda c: c.upper() if c.isupper() else\
    \ c.lower(), reverse=True))", "    return string.to_s[string.to_s.chars().map(&:downcase).reduce(&:+)]\n\
    end\n</cell>\n<code language=julia-1.5>\n@time flip_case(large_test);\n</cell>\n\
    <text>\nExercise 2.1", "    string_lower = string.lower()\n    string_upper =\
    \ string.upper()\n    string_upper.lower()\n    string_lower.upper()\n    string\n\
    end\n</code>\n<|/ a tags=julia |>\n<| c |>\nPlease do not add \"thanks\" or \"\
    this answer\" as answers. They [can get lost on SO](https://meta.stackexchange.com/questions/126180/is-it-okay-to-add-a-thanks-to-your-answer-or-question),\
    \ especially when it's your own. Instead, vote on the answer, with the [tag:language]\
    \ tag below the answer.\n<|/ c |>\n<| c |>\nOk, sorry, I didn't know about that\n\
    <|/ c |>\n<| a tags=julia |>\nYou can use map(x->isupper(x)? x : lowercase(x),\
    \ string_lower), but this will only work for one-character strings. If you want\
    \ it for all characters, you can use the fact that map will return an array, and\
    \ you can use the ? operator to conditionally apply the function to each element:\n\
    <code>\njulia> x = \"hello\"\n\"hello\"", "    return (string in uppercase) ?\
    \ lowercase(string) : uppercase(string)\n</code>\n<|/ a dscore=5 |>\n<| c |>\n\
    Thanks for this, I think this should be the accepted answer, as it is more general\
    \ than the existing answers since it allows for multiple characters to be flipped\
    \ at the same time.\n<|/ c |>\n<| c |>\nHi Tal! Can you help me with this question?\
    \ https://stackoverflow.com/questions/47744983/how-to-do-a-regex-replacement-in-a-file-using-sed-replace-string-function\n\
    <|/ c |>\n<| a |>\nUsing Maple (and assuming the input is an ASCII character string),\
    \ it can be done in a single line\n<code>\nStringReplace({{x}, {'A', 'B'}, {'B',\
    \ 'A'}}, {{x}, {'a','b'}, {'b','a'}}, {x=string})\n</code>\n<|/ a tags=haskell,string\
    \ dscore=5 |>\n<| c |>\nThis is much cleaner and more efficient than's answer.\
    \ Thanks!\n<|/ c |>\n<| a dscore=3 |>\nI needed a way to swap any two characters\
    \ in a string in Haskell, and thought I'd try a solution that utilizes Data.List.permutations.\
    \ \n<code>\nswap :: String -> String\nswap str = (map fst $ permutations str)\
    \ ++ [last str, head str] ++ (map snd $ permutations str)\n</code>\n<|/ a tags=haskell,string\
    \ |>\n<| a tags=haskell,string |>\nI thought there might be a more concise way\
    \ but here's my solution:\n<code>\nimport Data.List.Split (split)", "    return\
    \ string.map( \\\n        letter => letter.isUppercase ? letter : letter.lower()\
    \ ) \nend", "    return string |> flip |> toLowercase\nend", "    string_lower\
    \ = string.lower()\n    string_upper = string.upper()\n    return string_lower\
    \ + string_upper\nend\n</cell>\n<code language=julia-1.5>\n# test the function\
    \ using some test cases and print the results\n@test flip_case(\"hello\") == \"\
    hELLO\"\n@test flip_case(\"HellO\") != \"hELLO\"\n@test flip_case(\"HeLLo\") !=\
    \ \"hELLO\"\n@test flip_case(\"Hello World!\") == \"hELLO WORLD!\"\n@test flip_case(\"\
    Hello World\") != \"hELLO WORLD!\"\n@test flip_case(\"HeLLo WorLd!\") == \"hELLO\
    \ WORLD!\"\n</cell>\n<text>\nExercise 2\nWrite a function that takes in a list\
    \ of numbers and returns the product of the numbers.", "    # Declare a result\
    \ variable to hold the answer\n    answer::String = \"\"", "    \"Returns a string\
    \ with uppercase characters converted to lowercase, and vice versa.\"\n    \n\
    \    for i in string:\n        if i == 'a':\n            string = 'A'\n      \
    \  elif i == 'b':\n            string = 'B'\n        elif i == 'c':\n        \
    \    string = 'C'\n        elif i == 'd':\n            string = 'D'\n        elif\
    \ i == 'e':\n            string = 'E'\n        elif i == 'f':\n            string\
    \ = 'F'\n        elif i == 'g':\n            string = 'G'\n        elif i == 'h':\n\
    \            string = 'H'\n        elif i == 'i':\n            string = 'I'\n\
    \        elif i == 'j':\n            string = 'J'\n        elif i == 'k':\n  \
    \          string = 'K'\n        elif i == 'l':\n            string = 'L'\n  \
    \      elif i == 'm':\n            string = 'M'\n        elif i == 'n':\n    \
    \        string = 'N'\n        elif i == 'o':\n            string = 'O'\n    \
    \    elif i == 'p':\n            string = 'P'\n        elif i == 'q':\n      \
    \      string = 'Q'\n        elif i == 'r':\n            string = 'R'\n      \
    \  elif i == 's':\n            string = 'S'\n        elif i == 't':\n        \
    \    string = 'T'\n        elif i == 'u':\n            string = 'U'\n        elif\
    \ i == 'v':\n            string = 'V'\n        elif i == 'w':\n            string\
    \ = 'W'\n        elif i == 'x':\n            string = 'X'\n        elif i == 'y':\n\
    \            string = 'Y'\n        elif i == 'z':\n            string = 'Z'\n\
    \        elif i == '0':\n            string = 'O'\n        elif i == '1':\n  \
    \          string = '1'\n        elif i == '2':\n            string = '2'\n  \
    \      elif i == '3':\n            string = '3'\n        elif i == '4':\n    \
    \        string = '4'\n        elif i == '5':\n            string = '5'\n    \
    \    elif i == '6':\n            string = '6'\n        elif i == '7':\n      \
    \      string = '7'\n        elif i == '8':\n            string = '8'\n      \
    \  elif i == '9':\n            string = '9'\n        else:\n            string\
    \ = string.lower()\n    return string", "    result = \"\"\n    for i in string:\n\
    \        if i.isUpper():\n            result += i.lower()\n        else:\n   \
    \         result += i.upper()\n    return result\nend\n</code>\n<|/ a dscore=0\
    \ tags=lowercase,uppercase,string,julia |>\n<| a tags=lowercase,uppercase,string,julia\
    \ |>\nBased on's answer, this is my solution:\n<code>", "  local out = string.lower();\n\
    \  for i in string.charindices(out) do\n    if string.sub(i, 2, 1) == \"l\" then\n\
    \      local char = string.sub(i, 1, 2);\n      out = string.sub(out, 1, i)..char..string.sub(out,\
    \ i + 1, string.len(out));\n    end;\n  end;\n  return out;\nend;\n\"\"\"", " \
    \   \n    uppercase = string.uppercase\n    lowercase = string.lowercase\n   \
    \ return uppercase + lowercase.lowercase\nend\n</cell>\n<text>\nHere's how you\
    \ use it", "    str = string.map {strchar($0) => strchar($0).capitalize()}\n \
    \   return str.join(\"\")\nend", "    return (string.lowercase + string.uppercase).uppercase\
    \ \n</code>\n<|/ a tags=string,lowercase,uppercase,haskell dscore=5 |>\n<| c |>\n\
    That's really nice and compact code! The only thing I would change is to use `String.toUpper`\
    \ instead of `toUpper`, just to be a bit more generic.\n<|/ c |>\n<| c |>\nTo\
    \ improve on Jakub's answer: I think it would be better to `Data.Char.isUpper`\
    \ and `Data.Char.isLower` instead of `isUpper` and `isLower`. I guess it might\
    \ make sense to replace `Data.Char` with some kind of \"string like\" typeclass.\n\
    <|/ c |>\n<| a tags=string,lowercase,uppercase,haskell |>\nIf it is not a one-off\
    \ requirement that \"Hello\" be converted to \"hELLO\", then I think it's useful\
    \ to include a list comprehension:\n<code>\nimport Data.List\nimport Data.Char",
  "    string_lower = string.toLowercase()\n    string_upper = string.toUppercase()\n\
    \    return string_lower * string_upper\nend\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"\n    flip_case(string::String)", '    # Write your code here.', "    \n\
    \    for i in 0 .. length(string) do \n        flip_case(string[i])\n    end\n\
    \    return string\nend", "    \n    if string == \"\" \n        then string\n\
    \    else string |> string.map String.toUpper\n        |> String.toLower\n   \
    \     |> String.concat \"\"\n    end", "    return string\nend\n</cell>\n<text>\n\
    Exercise 7\nWrite a function that takes a single string as an input, and returns\
    \ the reverse of the string. For example, the string \"hello\" would return \"\
    olleh\"", "    if string.head == string.last\n        string.head\n    else\n\
    \        string.head + string.last + string.tail\nend", "    for i in 1:length(lowercase(string))\n\
    \        flipped = uppercase(string[i])\n        replace(string, i, 1, flipped)\n\
    \    end\n    return string\nend\n</code>\n<|/ a |>\n<| c |>\nJust an addendum\
    \ here -- a good reason to try and stick with standard functions, instead of writing\
    \ your own versions of them. For example, the `lowercase` and `uppercase` functions\
    \ are both pretty slow in Julia. So, try to avoid them if possible.\n<|/ c |>\n\
    <| c |>\nIn Julia 0.4.3, `lowercase()` and `uppercase()` are slower than the equivalent\
    \ `islower()` and `isupper()`. But in Julia 0.6.0, `lowercase()` and `uppercase()`\
    \ are faster.\n<|/ c |>\n<| a dscore=4 |>\nFor Julia 0.6 (as of Oct 2019) this\
    \ is now (as of Oct 2019) a built-in\n<code>\njulia> uppercase(\"Hello World!\"\
    )\n\"HELLO WORLD!\"", "    begin\n        flipped = \"\"\n        for i in string\n\
    \            if  i.isUpper()\n                flipped = flipped++i.toLower()\n\
    \            else\n                flipped = flipped++i\n        end\n       \
    \ return flipped\n    end \nend\n</code>\n<|/ a |>\n<| a dscore=2 tags=julia,string,uppercase,lowercase,arrays\
    \ |>\nI know this is an old question, but it is also worth noting that there is\
    \ a tolower() method that converts a string to lowercase.\n<|/ a |>\n<| a tags=julia,string,uppercase,lowercase,arrays\
    \ |>\nUsing map (from Iterators module) to convert a vector of Chars to lowercase:\n\
    <code>\njulia> v = \"Hello\";", "  result = string\n  for i in string.characters\n\
    \    if i.isLower\n      result := i.uppercase\n    else\n      result := i.lowercase\n\
    \    end\n  end\n  return result\nend\n</cell>\n<text>\nExercise 3\nUse a for-loop\
    \ to reverse the characters in a string.", "    if string == \"\" \n        then\
    \ \"\" \n    else if string.starts_with(\"!\")\n        then flip_case(string[2:])\
    \ + string[1:] \n    else if string.starts_with(\"?\")\n        then flip_case(string[2:])\
    \ + string[1:] \n    else if string.starts_with(\"$\")\n        then flip_case(string[2:])\
    \ + string[1:] \n    else if string.starts_with(\"&\")\n        then flip_case(string[2:])\
    \ + string[1:] \n    else if string.starts_with(\"\\\\\")\n        then flip_case(string[2:])\
    \ + string[1:] \n    else if string.starts_with(\"$\")\n        then flip_case(string[2:])\
    \ + string[1:] \n    else if string.starts_with(\"%\")\n        then flip_case(string[2:])\
    \ + string[1:] \n    else if string.starts_with(\"*\")\n        then flip_case(string[2:])\
    \ + string[1:] \n    else if string.starts_with(\"(\")\n        then flip_case(string[2:])\
    \ + string[1:] \n    else if string.starts_with(\")\")\n        then flip_case(string[2:])\
    \ + string[1:] \n    else if string.starts_with(\"+\")\n        then flip_case(string[2:])\
    \ + string[1:] \n    else if string.starts_with(\"-\")\n        then flip_case(string[2:])\
    \ + string[1:] \n    else if string.starts_with(\".\")\n        then flip_case(string[2:])\
    \ + string[1:] \n    else if string.starts_with(\",\")\n        then flip_case(string[2:])\
    \ + string[1:] \n    else if string.starts_with(\"=\")\n        then flip_case(string[2:])\
    \ + string[1:] \n    else if string.starts_with(\"^\")\n        then flip_case(string[2:])\
    \ + string[1:] \n    else if string.starts_with(\"~\")\n        then flip_case(string[2:])\
    \ + string[1:] \n    else if string.starts_with(\"`\")\n        then flip_case(string[2:])\
    \ + string[1:] \n    else if string.starts_with(\"{\")\n        then flip_case(string[2:])\
    \ + string[1:] \n    else if string.starts_with(\"}\")\n        then flip_case(string[2:])\
    \ + string[1:] \n    else if string.starts_with(\"|\")\n        then flip_case(string[2:])\
    \ + string[1:] \n    else if string.starts_with(\":\")\n        then flip_case(string[2:])\
    \ + string[1:] \n    else if string.starts_with(\"[\")", "    local s = \"\"\n\
    \    for i in string.gmatch(string, \"[A-Z]\") do \n        s = s .. string.gsub(i,\
    \ \"A\", \"a\") \n        s = s .. string.gsub(i, \"B\", \"b\")\n        s = s\
    \ .. string.gsub(i, \"C\", \"c\")\n        s = s .. string.gsub(i, \"D\", \"d\"\
    )\n        s = s .. string.gsub(i, \"E\", \"e\")\n        s = s .. string.gsub(i,\
    \ \"F\", \"f\")\n        s = s .. string.gsub(i, \"G\", \"g\")\n        s = s\
    \ .. string.gsub(i, \"H\", \"h\")\n        s = s .. string.gsub(i, \"I\", \"i\"\
    )\n        s = s .. string.gsub(i, \"J\", \"j\")\n        s = s .. string.gsub(i,\
    \ \"K\", \"k\")\n        s = s .. string.gsub(i, \"L\", \"l\")\n        s = s\
    \ .. string.gsub(i, \"M\", \"m\")\n        s = s .. string.gsub(i, \"N\", \"n\"\
    )\n        s = s .. string.gsub(i, \"O\", \"o\")\n        s = s .. string.gsub(i,\
    \ \"P\", \"p\")\n        s = s .. string.gsub(i, \"Q\", \"q\")\n        s = s\
    \ .. string.gsub(i, \"R\", \"r\")\n        s = s .. string.gsub(i, \"S\", \"s\"\
    )\n        s = s .. string.gsub(i, \"T\", \"t\")\n        s = s .. string.gsub(i,\
    \ \"U\", \"u\")\n        s = s .. string.gsub(i, \"V\", \"v\")\n        s = s\
    \ .. string.gsub(i, \"W\", \"w\")\n        s = s .. string.gsub(i, \"X\", \"x\"\
    )\n        s = s .. string.gsub(i, \"Y\", \"y\")\n        s = s .. string.gsub(i,\
    \ \"Z\", \"z\")\n        s = s .. string.gsub(i, \"[\", \"_\")\n        s = s\
    \ .. string.gsub(i, \"]\", \"_\")\n        s = s .. string.gsub(i, \"/\", \"_\"\
    )\n        s = s .. string.gsub(i, \" \", \"_\")\n        s = s .. string.gsub(i,\
    \ \".\", \"_\")\n        s = s .. string.gsub(i, \",\", \"_\")\n        s = s\
    \ .. string.gsub(i, \":\", \"_\")\n        s = s .. string.gsub(i, \";\", \"_\"\
    )\n        s = s .. string.gsub(i, \"!\", \"_\")\n        s = s .. string.gsub(i,\
    \ \"@\", \"_\")\n        s = s .. string.gsub(i, \"$\", \"_\")\n        s = s\
    \ .. string.gsub(i, \"%\", \"_\")\n        s = s .. string.gsub(i, \"^\", \"_\"\
    )\n        s = s .. string.gsub(i, \"&\", \"_\")\n        s = s .. ", "    return\
    \ string.replace(' ', '_')\nend", "    if string==\"\" then return \"\" \n   \
    \ else \n        local firstletter = string.sub(1,1)\n        if firstletter ==\
    \ \"_\" then \n            return string.sub(2) \n        else \n            return\
    \ string.sub(1,1) .. flip_case(string.sub(2)) \n    end\nend\n</code>\n<|/ a tags=string,lowercase,uppercase,julia\
    \ dscore=1 |>\n<| a tags=string,lowercase,uppercase,julia |>\n<code>", "    \n\
    \    lower_case = string.lower()\n    upper_case = string.upper()\n    return\
    \ string ^ lower_case ^ upper_case", "    if string == \"\" \n        then return\
    \ string \n        else return string.map((x) -> if x <: String then String{Char.upper(x)\
    \ else Char.lower(x)})\n    end\nend\n</code>\n<|/ a tags=string,julia |>\n<|\
    \ c |>\nYou could also use [`uppercase.(lowercase(string))`](https://docs.julialang.org/en/v1/base/strings/uppercase/)\
    \ to directly apply `uppercase` to your string in the first place\n<|/ c |>\n\
    <| c |>\n: This is good if your string may contain non-ASCII characters (like\
    \ emojis).\n<|/ c |>\n<| c |>\nThank you for your answer! Is there a way to achieve\
    \ the same result without having to define a function though? The thing is I'm\
    \ working with strings of length up to 1000 characters and I'm thinking it would\
    \ be better to use something similar to [this](https://stackoverflow.com/a/48122959/1214161)\
    \ answer (which uses regex to check whether a character is lowercase or uppercase)\
    \ than to define a function for each case. Thank you!\n<|/ c |>\n<| c |>\n: As\
    \ said, a function that will work with arbitrary strings without having to define\
    \ a function for each *possible case* can be easily created with the `uppercase`\
    \ function and a `switch` statement: `uppercase(ch) -> case ch of\n       x when\
    \ isupper(x) -> x\n       x when islower(x) -> Char.upper(x)\n       _ -> x\n\
    \       end`\n<|/ c |>\n<| a tags=string,julia dscore=1 |>\nJust to expand on\
    \ what wrote:\n<code>\n# Function that checks if a character is a lowercase or\
    \ uppercase\n# Returns a lowercase or uppercase string", "    \n    capitalized_string\
    \ = string.capitalize()\n    \n    return capitalized_string\nend\n</cell>\n<code\
    \ language=julia-1.4>\n\"\"\"\n    generate_primes(max_number::Int64)::Array{Int64,1}",
  "    str = string:sub(1, length)\n    if length == 1\n        str = str:upper()\n\
    \    else\n        str = str:lower()\n        str = str:swapcase()\n    return\
    \ str\nend", "    if null string \n        return string\n    local out = \"\"\
    \n    for character in string \n        do\n            if character == character\
    \ \n                out = out .. toupper(character)\n            else\n      \
    \          out = out .. tolower(character)\n            end\n        end\n   \
    \ end\n    return out\nend\n</cell>\n<text>\nWhat if there are non-alphanumeric\
    \ characters in our string?", "  return string |> String.toLowerCase |> String.toUpperCase\
    \ \nend", "    string\n        |> String.toLower\n        |> String.toUpper\n\
    \        |> String.toLower\n        |> String.toString\nend\n</cell>\n<text>\n\
    Exercise\nWrite a Julia function (that takes any string) which returns the first\
    \ word of each sentence in the string.\n>>> strange_sentence = \"This isn't so\
    \ strange. It's just strange.\"\n>>> strange_sentence\n\"This isn't so strange.\
    \ It's just strange.\"\n>>> # Your function should return the string \"This\"\n\
    >>> strange_sentence = \"This isn't so strange. It's just strange.\"\n>>> strange_sentence\n\
    \"This isn't so strange. It's just strange.\"\n</text>\n<text>\nExercise\nWrite\
    \ a Julia function (that takes any string) which returns the length of each word\
    \ in the string.\n>>> strange_sentence = \"This isn't so strange. It's just strange.\"\
    \n>>> strange_sentence\n\"This isn't so strange. It's just strange.\"\n>>> # Your\
    \ function should return the vector [7, 7, 5, 8]\n>>> strange_sentence = \"This\
    \ isn't so strange. It's just strange.\"\n>>> strange_sentence\n\"This isn't so\
    \ strange. It's just strange.\"\n</text>\n<text>\nExercise\nWrite a Julia function\
    \ (that takes any string) which returns the number of characters that appear before\
    \ a certain character in a string.\n>>> strange_sentence = \"This isn't so strange.\
    \ It's just strange.\"\n>>> strange_sentence\n\"This isn't so strange. It's just\
    \ strange.\"\n>>> # Your function should return the integer 13\n>>> strange_sentence\
    \ = \"This isn't so strange. It's just strange.\"\n>>> strange_sentence\n\"This\
    \ isn't so strange. It's just strange.\"\n</text>\n<text>\nExercise\nWrite a Julia\
    \ function (that takes any string) which returns the number of words that appear\
    \ before a certain character in a string.\n>>> strange_sentence = \"This isn't\
    \ so strange. It's just strange.\"\n>>> strange_sentence\n\"This isn't so strange.\
    \ It's just strange.\"\n>>> # Your function should return the integer 4\n>>> strange_sentence\
    \ = \"This isn't so strange. It's just strange.\"\n>>> strange_sentence\n\"This\
    \ isn't so strange. It's just strange.\"\n</text>\n<text>\nExercise\nWrite a Julia\
    \ function (that takes any string) which returns the number of sentences that\
    \ appear before a certain character in a string.\n>>> strange_sentence = \"This\
    \ isn't so strange. It's just strange", "    return (string.lower().capitalize())\n\
    end\n</cell>\n<code language=julia-1.0>\n\"\"\"\nThis function will take in a\
    \ string, a dictionary of words, and a key string that we want to find in the\
    \ dictionary. \nIt will then return the number of times that the key string was\
    \ found in the dictionary.\n\"\"\"", "    string = string.lower()\n    for i in\
    \ string.chars():\n        if i.isupper():\n            string = string.replace(i,\
    \ i.swapcase())\n    return string\nend\n</cell>\n<cell>\n\"\"\"\n### Split a\
    \ sentence into a list of words\n\"\"\"", "    return string.map(fun(char -> char.isUppercase\
    \ ? char.lowercase : char.uppercase))\nend\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"\n    fix_camel(string)", "    \n    if string.starts_with('!'):\n     \
    \ first_letter, other_letters = string.split(\"!\",2)\n      return other_letters\
    \ + \"!\" + first_letter", "    local new_string = string:gsub(\"%a\",\"%A\")\n\
    \    new_string = new_string:gsub(\"%A\",\"%a\")\n    return new_string\nend",
  "    \"\"\"Flip the case of a given string\n    \"\"\"\n    lowercase_letters =\
    \ (string.lowercase)\n    uppercase_letters = (string.uppercase)\n    \n    string.lowercase\
    \ = string.uppercase = \"\"\n    \n    for i in string:\n        if i.isupper():\n\
    \            string.uppercase += i\n        else:\n            string.lowercase\
    \ += i\n    \n    return string.lowercase\n</code>\n<|/ a tags=haskell dscore=3\
    \ |>\n<| c |>\nYour `flip_case` function doesn't actually work: it capitalizes\
    \ letters that aren't uppercase to lowercase and vice versa. For example, `flip_case\
    \ \" HaCkS0me \"` returns `\"HaCKS0ME\"`.\n<|/ c |>\n<| c |>\nYeah, I just noticed\
    \ that... I will update the answer.\n<|/ c |>\n<| c |>\nAnd what would you suggest\
    \ to correct it?\n<|/ c |>\n<| c |>\nOh, I see now. Oops! I didn't notice that\
    \ the `lowercase_letters` variable was never used.\n<|/ c |>\n<| c |>\nYeah, I\
    \ thought it would be a good idea to make a variable out of it. And then use it\
    \ like `string.lowercase`.\n<|/ c |>\n<| a |>\nHere's an alternative to Simon\
    \ Peyton Jones's solution that is somewhat more general (since it also works on\
    \  Strings that contain a lot of digits and letters) but also a little more efficient.\n\
    <code>\nflipCase:: String -> String\nflipCase x = do\n  x `isUpper` flip x\n \
    \ x `isLower` flip x\n  return x\n</code>\nHere we use the functions isUpper and\
    \ isLower to detect whether a given character is upper or lower case, then flip\
    \ them together using the function flip.\nNote that this doesn't make use of any\
    \ recursion, so if speed matters, you should use a list comprehension instead.\n\
    <|/ a dscore=3 tags=haskell |>\n<| a |>\nThe first thing that comes to mind is\
    \ to use pattern matching.  It's not terribly elegant, but I think it works and\
    \ it's at least as readable as other solutions:\n<code>\nflipCase :: String ->\
    \ String\nflipCase x\n  | isUpper x = uppercase\n  | isLower x = lowercase\n \
    \ | otherwise = x\n  where\n    isUpper c = c == 'A'\n    isLower c = c == 'a'\n\
    \    uppercase x' = reverse (x':x'') : x''\n    ", "    if string.length == 0\
    \ then string\n    else if string(0) != string(string.length-1) then\n       \
    \ flipped_letter = string[string.length-1]\n        string[string.length-1] =\
    \ string[0]\n        string[0] = flipped_letter\n    end\n    return string\n\
    end\n</cell>\n<code language=julia-1.0>", "    local result = string.lower()\n\
    \    for c in string.gmatch(result, \"%l\") do result = result:gsub(c, \"%U\"\
    ) end\n    return result\nend", "    if all(letter(string) == letter(string[0])\
    \ for string in string.split(\"_\"))\n        string.swapcase()\n    else\n  \
    \      string\n    end\nend", "    if is_lower(string) == False\n        string\
    \ = string.upper()\n    else if is_lower(string) == True\n        string = string.lower()\n\
    \    end\n    return string\nend", "    return string.replace(string.toLowerCase(),\
    \ string.toUpperCase()) \nend", "    return string.to_lowercase().reverse + string.to_uppercase()\n\
    end\n</cell>\n<code language=julia-1.0>", "    local s = string:lower()\n    for\
    \ c in s:gmatch(\".\"):gsub(\"^(.)\",\"\\U\\1\",c)\n    return s\nend\n</code>\n\
    <|/ a dscore=4 tags=lowercase,uppercase,string,julia |>\n<| c |>\nThe above solution\
    \ worked for me but I had to add () to the end of the function calls like so:\
    \ `return s.(lowercase)()`\n<|/ c |>\n<| a |>\nA solution without writing a macro:\n\
    <code>\n\"hello\".(lowercase).(uppercase)\n\"hello\".(lowercase).(uppercase).(lowercase)\n\
    \"hello\".(lowercase).(uppercase).(lowercase).(lowercase)\n</code>\ngives\n<code>\n\
    \"Hello\"\n\"HELLO\"\n\"HELLO\"\n\"Hello\"\n</code>\n<|/ a tags=lowercase,uppercase,string,julia\
    \ dscore=4 |>\n<| c |>\nAvoid dots inside single quotes. Thus use \".\" (not \"\
    .\") to concatenate string parts.\n<|/ c |>\n<| a tags=lowercase,uppercase,string,julia\
    \ dscore=4 |>\nIf you're looking for a general function which performs lowercase\
    \ and uppercase simultaneously, you can use (using Julia 1.3):\n<code>\njulia>\
    \ lowercase(\"HelloWorld\")\n\"helloworld\"", "  return string |> \n    map (char::Char)\
    \ ->\n      if char == 'a'\n        'A'\n      else\n        char.upper()", " \
    \   if string == \"\" \n        return string\n    return string.map(c -> if c\
    \ == 'A'\n                        'B' \n                    elseif c == 'a'\n\
    \                        'b' \n                    else if c == 'A'\n        \
    \                'a' \n                    else c).filter(c -> c != 'a')\nend\n\
    </cell>\n<code language=julia-1.6>\n@code_warntype flip_case(\"Hello\")\n</cell>\n\
    <text>\nP. E. De La Cruz", "    return string.map(x->(if x == \"A\" then \"B\"\
    \ else if x == \"B\" then \"A\" else x)).mkString\nend\n</cell>\n<cell>\n@test\
    \ flip_case(\"Hello\") == \"hELLO\"\n</cell>\n<text>\nConclusion\nHopefully you\
    \ now have a little understanding of Julia and how to get started with Julia.",
  "    if string == \"\"\n        \"\"\n    else\n        match string.lower with\
    \ \n        \"\" => string.upper\n        string.lower => string.lower\n     \
    \   end\nend\n</code>\n<code>\n\"\"\"\nFor a given string, flip uppercase characters\
    \ to lowercase and lowercase to uppercase.\n>>> flip_case(\"Hello\")\n\"hello\"\
    \n\"\"\"", "    return string.map((x) -> if x >= 'A' && x <= 'Z' then x-'A' else\
    \ x).toUppercase + string.map((x) -> if x >= 'a' && x <= 'z' then x-'a' else x).toLowercase\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    has_digit(string::String)\n\
    \    Checks if the string contains digits\n\"\"\"", "    #string will be a String\
    \ type \n    return string |> \n       map (fun ch -> if ch = 'a' then 'A' else\
    \ ch) |> \n       String.concat \"\" \nend\n</code>\n<|/ a |>\n<| c |>\nI like\
    \ the idea of using a lambda to do this - makes it very clear what is happening,\
    \ but I did a quick performance test on a small dataset and yours is around 3-4\
    \ times slower than the other solution.  I think this solution is more straightforward\
    \ and therefore might be worth the extra performance.\n<|/ c |>\n<| a tags=lowercase,uppercase,string,julia\
    \ |>\nBased on Nelson Reynold's answer I created this slightly faster solution:\n\
    <code>", "    \n    if islower(string)\n        return upper(string)\n    else\n\
    \        return lower(string)\nend", "    if string == \"\"\n        \"\"\n  \
    \  else\n        return string[1].to_upper+string[2].to_lower+string[3].to_upper+string[4].to_lower\n\
    \    end\nend\n\"\"\"", "    if string == \"\"\n        then string\n    else\
    \ if string.head == string.last\n        then flip_case(string.tail) + string.head\n\
    \    else flip_case(string.tail) + string.head + string.last\nend\n</code>\nThe\
    \ function flip_case is recursive, meaning it calls itself. Therefore, if you\
    \ pass it an empty string, it just returns an empty string. If you pass it a string,\
    \ the function returns it unchanged as is.\nNow, you know that you can just use\
    \ string.flip to swap the case of a string. In fact, string.flip will return the\
    \ original string in any case and reverse the case of the other characters. Therefore,\
    \ if you pass in an empty string string.flip will return an empty string.\nNow\
    \ that you have an idea of what the function flip_case does, you can create another\
    \ function called flip that does the same as string.flip, but without using any\
    \ recursion. \n<code>", "    \n    temp_string =\"\"\n    for character in string\n\
    \        if character isalpha \n            then temp_string += character + toupper(character)\n\
    \            else temp_string += character\n    end\n    return temp_string\n\
    end\n</code>\n<|/ a tags=julia,string |>\n<| c |>\nThis is really cool. I tried\
    \ something like that but couldn't get it to work. I was doing something like:\
    \ `function flip_case(string::String)::String \n    \n    temp_string =\"\"\n\
    \    for character in string\n        if character isalpha \n            then\
    \ temp_string += character + toupper(character)\n            else temp_string\
    \ += character\n    end\n    return temp_string\nend` but couldn't get it to work.\n\
    <|/ c |>\n<| a tags=julia,string |>\nUse join:\n<code>\njulia> function flip_case(s::String)\n\
    \           join(map(i -> char.(lowercase(i)) ? uppercase(i) : lowercase(i), s))\n\
    \       end\nflip_case (generic function with 1 method)", "    let\n        result\
    \ = \"\"\n    \n    for char in string\n        match char with\n        | \"\
    a\" -> result += \"A\"\n        | \"b\" -> result += \"b\"\n        | \"c\" ->\
    \ result += \"C\"\n        | \"d\" -> result += \"D\"\n        | \"e\" -> result\
    \ += \"E\"\n        | \"f\" -> result += \"F\"\n        | \"g\" -> result += \"\
    G\"\n        | \"h\" -> result += \"H\"\n        | \"i\" -> result += \"I\"\n\
    \        | \"j\" -> result += \"J\"\n        | \"k\" -> result += \"K\"\n    \
    \    | \"l\" -> result += \"L\"\n        | \"m\" -> result += \"M\"\n        |\
    \ \"n\" -> result += \"N\"\n        | \"o\" -> result += \"O\"\n        | \"p\"\
    \ -> result += \"P\"\n        | \"q\" -> result += \"Q\"\n        | \"r\" -> result\
    \ += \"R\"\n        | \"s\" -> result += \"S\"\n        | \"t\" -> result += \"\
    T\"\n        | \"u\" -> result += \"U\"\n        | \"v\" -> result += \"V\"\n\
    \        | \"w\" -> result += \"W\"\n        | \"x\" -> result += \"X\"\n    \
    \    | \"y\" -> result += \"Y\"\n        | \"z\" -> result += \"Z\"\n        |\
    \ \"A\" -> result += \"a\"\n        | \"B\" -> result += \"b\"\n        | \"C\"\
    \ -> result += \"c\"\n        | \"D\" -> result += \"d\"\n        | \"E\" -> result\
    \ += \"e\"\n        | \"F\" -> result += \"f\"\n        | \"G\" -> result += \"\
    g\"\n        | \"H\" -> result += \"h\"\n        | \"I\" -> result += \"i\"\n\
    \        | \"J\" -> result += \"j\"\n        | \"K\" -> result += \"k\"\n    \
    \    | \"L\" -> result += \"l\"\n        | \"M\" -> result += \"m\"\n        |\
    \ \"N\" -> result += \"n\"\n        | \"O\" -> result += \"o\"\n        | \"P\"\
    \ -> result += \"p\"\n        | \"Q\" -> result += \"q\"\n        | \"R\" -> result\
    \ += \"r\"\n        | \"S\" -> result += \"s\"\n        | \"T\" -> result += \"\
    t\"\n        | \"U\" -> result += \"u\"\n        | \"V\" -> result += \"v\"\n\
    \        | \"W\" -> result += \"w\"\n        | \"X\" -> result += \"x\"\n    \
    \    | \"Y\" -> result += \"", "    return string.upper().join(string.lower())\n\
    end", "    char::Char\n    for char in string\n        cased_char::Char = if char\
    \ >= 'A' && char <= 'Z' then char - 'A' + 'a' else char\n        string := string\
    \ == char::String ? cased_char : char \n    end\n    string\nend\n</code>\nThis\
    \ program is much more succinct than the previous solution:\n<code>\n\"\"\"\n\
    Flip all the characters in a string.", "    for i in string.words\n        let\
    \ i = toupper(i)\n    end for \n    string\nend\n</cell>\n<code language=julia-1.4>\n\
    # test\nflip_case(\"Hello\")\n</cell>\n<text>\nExercise 2: Palindromes\nWrite\
    \ a function that checks whether a string is a palindrome. Recall that a palindrome\
    \ is a string that is the same when its letters have been reversed. If it is the\
    \ same length it should be considered a palindrome. Recall that a palindrome is\
    \ a string that is the same when its letters have been reversed. To write a function\
    \ that checks whether a word is a palindrome, it is very similar to the one that\
    \ checks whether a string is a palindrome. Write a palindrome function that takes\
    \ in a string and checks whether it is a palindrome. Hint: You do not need to\
    \ use the reverse function to reverse a string in Julia.", "    if string.size\
    \ > 0\n        lowers = string.chars.map(&:lower)\n        uppers = string.chars.map(&:upper)\n\
    \        return string.chars.zip([lowers, uppers]).map(&:join).join(\"\")\n  \
    \  return \"\"\nend", "    # Lowercase\n    lowercase_string = string.lower()\n\
    \    # Uppercase\n    uppercase_string = lowercase_string.upper()\n    # Return\n\
    \    return uppercase_string\n</code>\n<|/ a tags=string,julia,function,regex\
    \ |>\n<| c |>\nThanks for the feedback. Unfortunately I already tried this method.\
    \ The problem with this is that it creates another string that then gets deleted\
    \ by the function `replace` and then the function is called on the original string\
    \ that gets replaced again. The performance is very bad on large strings.\n<|/\
    \ c |>\n<| c |>\nI have added another solution with no loop\n<|/ c |>\n<| c |>\n\
    Ok I understand now what you mean. Thanks! Do you know how I might do that for\
    \ regex? I am not sure what it is doing, but I notice that it seems like it keeps\
    \ some kind of internal structure on the regex match. Is there a way to return\
    \ that structure without creating a new string?\n<|/ c |>\n<| c |>\nYou might\
    \ want to check out the `Base.Regex` module for that. https://docs.julialang.org/en/v1/base/regex/\n\
    <|/ c |>\n<| c |>\nThanks, that is helpful. I think I will check it out\n<|/ c\
    \ |>\n<| a |>\nThe regex package might be worth looking into, as it is a Julia\
    \ package. With that, you can use this solution:\n<code>\nusing Regex", "    local\
    \ string1 = string\n    local length1 = length(string1)\n    local i = 0\n   \
    \ while i < length1 do\n        local c = string1[i]\n        local lower = tolower(c)\n\
    \        local upper = toupper(c)\n        local new_char = lower(upper)\n   \
    \     local new_string = new_char\n        \n        local j = 1\n        while\
    \ j < i do\n            local char1 = string1[j]\n            local char2 = string1[j+1]\n\
    \            if char1 == upper and char2 == lower then\n                new_string\
    \ = new_string .. char2\n            elseif char1 == lower and char2 == upper\
    \ then\n                new_string = new_string .. char1\n            else\n \
    \               new_string = new_string .. char1\n            end\n          \
    \  j = j + 1\n        end\n        string1[i] = new_char\n        i = i + 1\n\
    \    end\n    return string1\nend\n</code>\n<|/ a tags=lua |>\n<| a dscore=0 tags=lua\
    \ |>\n<code>", "        mutable new_string = \"\" \n        for i in string.chars:\
    \ \n            if i.is_upper(): \n                new_string += i.to_lowercase()\
    \ \n            else: \n                new_string += i.to_uppercase() \n    \
    \    return new_string \n</code>\n<|/ a dscore=2 tags=string,case-sensitive,uppercase,lowercase,python\
    \ |>\n<| c |>\nThis could be improved by using `string.replace` instead of `str.replace`\n\
    <|/ c |>\n<| c |>\nI like this approach, but it's inefficient. Since it has to\
    \ iterate over the whole string on every call. Using a regular expression (also\
    \ known as \"regex\") might be an improvement, but it'll be harder to read than\
    \ the loop-based approach.\n<|/ c |>\n<| a |>\n<code>\ndef swap_case(s):\n   \
    \ return ''.join( [x.upper() if x.islower() else x.lower() for x in s] )\n</code>\n\
    <|/ a dscore=2 tags=string,case-sensitive,uppercase,lowercase,python |>\n<| c\
    \ |>\nThis should be the accepted answer. The other answers use loops which iterate\
    \ over the whole string each time. While this is very fast, it also makes it less\
    \ readable and harder to understand. Using a regex or some other approach that\
    \ involves manipulating a single character at a time, as in other answers, is\
    \ also more readable and maintainable, but is not fast, as it's an overhead in\
    \ itself.\n<|/ c |>\n<| c |>\nI don't think it's less readable. The list comprehension\
    \ makes it easy to read.\n<|/ c |>\n<| c |>\nTo be honest, it just looks ugly.\
    \ Sure, it's easy to read. That's why I thought it was ugly. I'm open to any comments\
    \ on my readability. Also, I think the accepted answer should have been accepted,\
    \ but I don't have enough reputation to change it.\n<|/ c |>\n<| c |>\nI agree\
    \ that it's ugly, but it's a good example of how to do the task without resorting\
    \ to regex, which you shouldn't use when your problem can be solved by other means.\
    \ But I agree that it's ugly as well.\n<|/ c |>\n<| c |>\nI agree, it is ugly.\
    \ But I wanted to add an alternative. Also, I'd love to learn more about the difference\
    \ between your answer and a regex one. I'm very new to python.\n<|/ c |>\n<| a\
    \ |>\n<code>\ndef swap_case(s):\n  newStr = ''\n  for ch in s:\n    if ch.islower():\n\
    \      newStr += ch.upper()\n    else:\n      newStr += ch.lower()", "    local\
    \ s = \"\"\n    for char in string:\n        s = s .. tostring(char):lower():upper():lower()\n\
    \    end\n    return s\nend", "    \n    \n    if string == nil\n        return\
    \ string\n    \n    if string.isupper()\n        return string.lower()\n    \n\
    \    if string.islower()\n        return string.upper()\n    \n    return string\n\
    end\n</cell>\n<code language=julia-1.5>\n# test the function above\n@test flip_case(\"\
    hello\") == \"hELLO\"\n</cell>\n<text>\nisupper()\nThis function checks if a string\
    \ contains only uppercase characters.", "    str = string.downcase()\n    str\
    \ = str.replace(\" \", \"\")\n    str = str.replace(\"/\", \"\")\n    str = str.replace(\"\
    \ \", \"\")\n    str = str.replace(\"/\", \"\")\n    str = str.replace(\" \",\
    \ \"\")\n    str = str.replace(\"/\", \"\")\n    str = str.replace(\"/\", \"\"\
    )\n    str = str.replace(\" \", \"\")\n    str = str.replace(\"/\", \"\")\n  \
    \  str = str.replace(\" \", \"\")\n    str = str.replace(\"/\", \"\")\n    str\
    \ = str.replace(\" \", \"\")\n    str = str.replace(\"/\", \"\")\n    str = str.replace(\"\
    \ \", \"\")\n    str = str.replace(\"/\", \"\")\n    str = str.replace(\" \",\
    \ \"\")\n    str = str.replace(\"/\", \"\")\n    str = str.replace(\" \", \"\"\
    )\n    str = str.replace(\"/\", \"\")\n    str = str.replace(\" \", \"\")\n  \
    \  str = str.replace(\"/\", \"\")\n    str = str.replace(\" \", \"\")\n    str\
    \ = str.replace(\"/\", \"\")\n    str = str.replace(\" \", \"\")\n    str = str.replace(\"\
    /\", \"\")\n    str = str.replace(\" \", \"\")\n    str = str.replace(\"/\", \"\
    \")\n    str = str.replace(\" \", \"\")\n    str = str.replace(\"/\", \"\")\n\
    \    str = str.replace(\" \", \"\")\n    str = str.replace(\"/\", \"\")\n    str\
    \ = str.replace(\" \", \"\")\n    str = str.replace(\"/\", \"\")\n    str = str.replace(\"\
    \ \", \"\")\n    str = str.replace(\"/\", \"\")\n    str = str.replace(\" \",\
    \ \"\")\n    str = str.replace(\"/\", \"\")\n    str = str.replace(\" \", \"\"\
    )\n    str = str.replace(\"/\", \"\")\n    str = str.replace(\" \", \"\")\n  \
    \  str = str.replace(\"/\", \"\")\n    str = str.replace(\" \", \"\")\n    str\
    \ = str.replace(\"/\", \"\")\n    str = str.replace(\" \", \"\")\n    str = str.replace(\"\
    /\", \"\")\n    str = str.replace(\" \", \"\")\n    str = str.replace(\"/\", \"\
    \")\n    str = str.replace(\" \", \"\")\n    str = str.replace(\"/\", \"\")\n\
    \    str = str.replace(\" \", \"\")\n    str = str.replace(\"/\", \"\")\n    str\
    \ = str.replace(\" \", \"\")\n    str = str.replace(\"/\", \"\")\n    str = str.replace(\"\
    \ \", \"\")\n    str = str.replace(\"/\", \"\")\n    str = str.replace(\" \",\
    \ \"\")\n    str = str.replace(\"/\", \"\")\n    str = str.replace(\" \", \"\"\
    )\n    str = str.replace(\"/\", \"\")\n    str = str.replace(\" \", \"\")\n  \
    \  str = str.replace(\"/\", \"\")\n    str = str.replace(\" \", \"\")\n    str\
    \ = str.replace(\"/\", \"\")\n    str = str.replace(\" \", \"\")\n    str = str.replace(\"\
    /\", \"\")\n    str = str.replace(\" \", \"\")\n    str = str.replace(\"/\", \"\
    \")\n    str = str.replace(\" \", \"\")\n    str = str.replace(\"/\", \"\")\n\
    \    str = str.replace(\" \", \"\")\n    str = str.replace(\"/\", \"\")\n    str\
    \ = str.replace(\" \", \"\")\n    ", "  case string of\n    \"\" -> \"\"\n   \
    \ x -> x\n  end \nend", "    \n    if (length(string) == 0)\n        return \"\
    \"\n    \n    characters::Vector[Char] = split(string, \"_\")\n    \n    for character\
    \ in characters\n        return toupper(character)\n    \n    return string\n\
    end", "  \n    local uppercase = false\n    local lowercase = false\n    local\
    \ s = \"\"\n    \n    for char in string.gmatch( string, \"%W\") do\n        if\
    \ char == string.upcase(char) then\n            uppercase = true\n        elseif\
    \ char == string.lower(char) then\n            lowercase = true\n        else\n\
    \            s = s .. char\n        end\n    end\n    return s\nend\n\"\"\"",
  "    string = ''.join(i for i in string if i.isupper()).lower()\n    return string",
  "    let result = (string |> char.upcase |> char.downcase)\n    result |> printf\
    \ \"%s\\n\" (* print the resulting string *)\n    \nflip_case(\"Hello\")\nflip_case(\"\
    Howdy\")\nflip_case(\"HellO\")\nflip_case(\"HOWDy\")\nflip_case(\"Hello\")\nflip_case(\"\
    HellO\")\nflip_case(\"Howdy\")\nflip_case(\"HellO\")\nflip_case(\"HOWDy\")\nflip_case(\"\
    Hello\")\nflip_case(\"HellO\")\nflip_case(\"Howdy\")\nflip_case(\"HellO\")\nflip_case(\"\
    HOWDy\")\nflip_case(\"Hello\")\nflip_case(\"HellO\")\nflip_case(\"Howdy\")\nflip_case(\"\
    HellO\")\nflip_case(\"HOWDy\")\nflip_case(\"Hello\")\nflip_case(\"HellO\")\nflip_case(\"\
    Howdy\")\nflip_case(\"HellO\")\nflip_case(\"HOWDy\")\nflip_case(\"Hello\")\nflip_case(\"\
    HellO\")\nflip_case(\"Howdy\")\nflip_case(\"HellO\")\nflip_case(\"HOWDy\")\nflip_case(\"\
    Hello\")\nflip_case(\"HellO\")\nflip_case(\"Howdy\")\nflip_case(\"HellO\")\nflip_case(\"\
    HOWDy\")\nflip_case(\"Hello\")\nflip_case(\"HellO\")\nflip_case(\"Howdy\")\nflip_case(\"\
    HellO\")\nflip_case(\"HOWDy\")\nflip_case(\"Hello\")\nflip_case(\"HellO\")\nflip_case(\"\
    Howdy\")\nflip_case(\"HellO\")\nflip_case(\"HOWDy\")\nflip_case(\"Hello\")\nflip_case(\"\
    HellO\")\nflip_case(\"Howdy\")\nflip_case(\"HellO\")\nflip_case(\"HOWDy\")\nflip_case(\"\
    Hello\")\nflip_case(\"HellO\")\nflip_case(\"Howdy\")\nflip_case(\"HellO\")\nflip_case(\"\
    HOWDy\")\nflip_case(\"Hello\")\nflip_case(\"HellO\")\nflip_case(\"Howdy\")\nflip_case(\"\
    HellO\")\nflip_case(\"HOWDy\")\nflip_case(\"Hello\")\nflip_case(\"HellO\")\nflip_case(\"\
    Howdy\")\nflip_case(\"HellO\")\nflip_case(\"HOWDy\")\nflip_case(\"Hello\")\nflip_case(\"\
    HellO\")\nflip_case(\"Ho", "    let mut buffer = StringBuffer()\n    for c in\
    \ string.to_lowercase() {\n        match c {\n            'a' => { 'A' }\n   \
    \         'b' => { 'B' }\n            'c' => { 'C' }\n            'd' => { 'D'\
    \ }\n            'e' => { 'E' }\n            'f' => { 'F' }\n            'g' =>\
    \ { 'G' }\n            'h' => { 'H' }\n            'i' => { 'I' }\n          \
    \  'j' => { 'J' }\n            'k' => { 'K' }\n            'l' => { 'L' }\n  \
    \          'm' => { 'M' }\n            'n' => { 'N' }\n            'o' => { 'O'\
    \ }\n            'p' => { 'P' }\n            'q' => { 'Q' }\n            'r' =>\
    \ { 'R' }\n            's' => { 'S' }\n            't' => { 'T' }\n          \
    \  'u' => { 'U' }\n            'v' => { 'V' }\n            'w' => { 'W' }\n  \
    \          'x' => { 'X' }\n            'y' => { 'Y' }\n            'z' => { 'Z'\
    \ }\n            ' ' => { '' }\n            '_' => { '' }\n            '!' =>\
    \ { c }\n            '?' => { c }\n            '-' => { c }\n            '/' =>\
    \ { c }\n            '&' => { c }\n            '#' => { c }\n            '@' =>\
    \ { c }\n            '~' => { c }\n            '%' => { c }\n            '^' =>\
    \ { c }\n            '&' => { c }\n            '*' => { c }\n            '(' |\
    \ ')' | '+' => { c }\n            '<' => { c }\n            '>' => { c }\n   \
    \         '=' => { c }\n            '|' => { c }\n            '~' => { c }\n \
    \           '%' => { c }\n            '{' => { c }\n            '}' => { c }\n\
    \            '\\\\' => { c }\n            ';' => { c }\n            '\\\"' =>\
    \ { c }\n            '\\'' => { c }\n            '|' => { c }\n            '~'\
    \ => { c }\n            '%' => { c }\n            '{' => { c }\n            '}'\
    \ => { c }\n            '\\\\' => { c }\n            ';' => { c }\n          \
    \  '\\'' => { c }\n            '\\\"' => { c }\n            '!' => { c }\n   \
    \         '?' => { c }\n            '-' => { c }\n            '/' => { c }\n \
    \           '", "    \n    str = string.to_string\n    \n    for i in str:\n \
    \       if i.isUpper():\n            str = str.replace(i, i.toLower)\n       \
    \ else:\n            str = str.replace(i, i.toUpper)\n        \n    return str\n\
    </cell>\n<cell>\n?flip_case\n</cell>\n<text>\n3. Filtering Strings\nWe can filter\
    \ strings based on a condition. This is done by using the filter function on a\
    \ given string. \nThe filter function takes a function as an argument and applies\
    \ that function to the strings matching the function criteria. \nThe function\
    \ argument is a predicate function which takes the current string as an argument\
    \ and returns true or false. The function returns true if the string matches the\
    \ function criteria. \nThe filter function returns a new string which contains\
    \ only the string matched by the given predicate function. \nIf the predicate\
    \ function returns false for any string, then that string is not included in the\
    \ resulting string.", "    char_list = string.chars\n    char_list.zipWithIndex.map\
    \ { \n        | c, index | (if index == 0 || c.isUppercase() then c.toUppercase()\
    \ else c.toLowercase())\n    }\n    string\nend\n</cell>\n<code language=julia-1.1>\n\
    \"\"\"\n    has_substrings(string::String, substrings::Array{String})", "    \n\
    \    if string == \"\"\n        return string\n    \n    characters = string.characters\n\
    \    \n    for char in characters\n        if char >= \"a\" && char <= \"z\"\n\
    \            char = \"A\"\n        else if char >= \"A\" && char <= \"Z\"\n  \
    \          char = \"a\"\n        else if char >= \"0\" && char <= \"9\"\n    \
    \        char = \"0\"\n        else \n            char = char\n    end\n    return\
    \ string(characters)\nend\n</cell>\n<code language=julia-1.6>", "    str = string.downcase()\n\
    \    for c in string.chars() {\n        if c.upcase < c.lowercase {\n        \
    \    str = str + c.upcase()\n        } else {\n            str = str + c.lowercase()\n\
    \        }\n    }\n    return str\nend", "    string = string.chars.map(x->char(x)==x.upper?x.upper:x.lower).join\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\nIt should be noted that this is _not_\
    \ thread-safe, as you are not guaranteed that `char` returns unique values.\n\
    <|/ c |>\n<| c |>\nThanks for the comment - I have updated the example to fix\
    \ that.\n<|/ c |>\n<| c |>\nThis won't work on UTF-8 strings because of the implicit\
    \ conversion to ASCII. In UTF-8 any character can be represented by multiple bytes.\n\
    <|/ c |>\n<| c |>\nThis is fine for ASCII, but if you try to do `\"\xFC\".chars.map(x\
    \ -> x.ord).max` for example, you'll get `nil`.\n<|/ c |>\n<| c |>\nNote that\
    \ `Char` is not available in Julia 0.7+, but if you replace it with `String`,\
    \ the code will work on both versions.\n<|/ c |>\n<| a |>\nThe method Char.lowercase\
    \ and Char.uppercase are now deprecated. You can now use:\n<code>\nstring(lower(input))\n\
    string(upper(input))\n</code>\n<|/ a tags=julia dscore=5 |>\n<| c |>\nI wonder\
    \ why this is happening.\n<|/ c |>\n<| c |>\nThis is so because of the new `String`\
    \ type in Julia 0.7 which was added in May 2017. This has probably been done to\
    \ avoid a lot of problems caused by using UTF-8 encoded strings. You can see more\
    \ about this here: https://github.com/JuliaLang/julia/issues/24571\n<|/ c |>\n\
    <| c |>\nIt's not about the type, but the fact that `Char` no longer works.\n\
    <|/ c |>\n<| c |>\nIn fact, the type `Char` is deprecated but it's still there\
    \ and does work like `Char`. E.g. `lowercase(\"\xFC\".char)` gives `\"\xFC\"`\
    \ and `uppercase(\"\xFC\".char)` gives `\"\xDC\"`. It also gives the correct result\
    \ for `\"\xFC\".char`. This is why `Char.lowercase` was removed from the standard\
    \ library.\n<|/ c |>\n<| c |>\nWhat I really don't understand is the fact that\
    \ `lowercase` is deprecated but `uppercase` still works. `uppercase('\xFC'.char)`\
    \ gives `\"\xDC\"`, but `uppercase('\xFC'.char)` still works. Also, `lowercase`\
    \ works just fine on UTF-8 encoded strings. `lowercase('\xFC'.char)` gives `\"\
    \xFC\"`.\n<|/", "</code>\nAs you can see, this function can easily be implemented\
    \ in one line of code. The function you wrote is more complicated and it involves\
    \ some overhead:", "    if string==null or string.len==0\n        return string\n\
    \    else \n        let s = string.chars\n        s[0,0] = char tolower (char\
    \ toupper (char at 0 s))\n        string.chars = s\n        return string\nend",
  "    string = string.toLowerCase()\n    string = string.toUpperCase()\n    return\
    \ string\nend\n\"\"\"\n\"\"\"\n## Function to capitalize first letter of string\n\
    Given a string, return a capitalized version of it by prepending it to every word\
    \ in the string.\n\"\"\"\n\"\"\"", "    \n    lowercase = string.lowercase\n \
    \   uppercase = string.uppercase\n    return uppercase+lowercase[1:]+lowercase[0]\n\
    end", "        \n    string |> String.map String.upper", "  x = string.chars\n\
    \  mutable string2 = \"\"\n  for c in x:\n    if islower(c): \n      string2 +=\
    \ toupper(c)\n    else:\n      string2 += tolower(c)\n  return string2\nend",
  "    \"Return the string with its case flipped.\"\n    let flip_case_table = \n\
    \        [\"a\"=\"A\",\n         \"b\"=\"B\",\n         \"c\"=\"C\",\n       \
    \  \"d\"=\"D\",\n         \"e\"=\"E\",\n         \"f\"=\"F\",\n         \"g\"\
    =\"G\",\n         \"h\"=\"H\",\n         \"i\"=\"I\",\n         \"j\"=\"J\",\n\
    \         \"k\"=\"K\",\n         \"l\"=\"L\",\n         \"m\"=\"M\",\n       \
    \  \"n\"=\"N\",\n         \"o\"=\"O\",\n         \"p\"=\"P\",\n         \"q\"\
    =\"Q\",\n         \"r\"=\"R\",\n         \"s\"=\"S\",\n         \"t\"=\"T\",\n\
    \         \"u\"=\"U\",\n         \"v\"=\"V\",\n         \"w\"=\"W\",\n       \
    \  \"x\"=\"X\",\n         \"y\"=\"Y\",\n         \"z\"=\"Z\"]\n    let uppercase_letters\
    \ = string.split(\"\")\n    let lowercase = string.split(\"\").map(flip_case_table.get)\n\
    \    let result = string.join(\"\")::String \n    let result = string.split(\"\
    \").map(flip_case_table.get)::String \n    let result = string.split(\"\").map(flip_case_table.get)::String\
    \ \n    let result = string.split(\"\").map(flip_case_table.get)::String \n  \
    \  let result = string.split(\"\").map(flip_case_table.get)::String \n    let\
    \ result = string.split(\"\").map(flip_case_table.get)::String \n    let result\
    \ = string.split(\"\").map(flip_case_table.get)::String \n    let result = string.split(\"\
    \").map(flip_case_table.get)::String \n    let result = string.split(\"\").map(flip_case_table.get)::String\
    \ \n    let result = string.split(\"\").map(flip_case_table.get)::String \n  \
    \  let result = string.split(\"\").map(flip_case_table.get)::String \n    let\
    \ result = string.split(\"\").map(flip_case_table.get)::String \n    let result\
    \ = string.split(\"\").map(flip_case_table.get)::String \n    let result = string.split(\"\
    \").map(flip_case_table.get)::String \n    let result = string.split(\"\").map(flip_case_table.get)::String\
    \ \n    let result = string.split(\"\").map(flip_case_table.get)::String \n  \
    \  let result = string.split(\"\").map(flip_case_table.get)::String \n    let\
    \ result = string.split(\"\").map(flip_case_table.get)::String \n    let result\
    \ = string.split(\"\""]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
