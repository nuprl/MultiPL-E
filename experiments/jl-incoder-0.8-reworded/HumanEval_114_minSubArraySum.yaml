name: HumanEval_114_minSubArraySum
language: jl
prompt: "\"\"\"\n    Given a vector of integers nums, find the minimum sum of any\
  \ non-empty sub-vector\n    of nums.\n    Example\n    >>> minSubArraySum([2, 3,\
  \ 4, 1, 2, 4])\n    1\n    >>> minSubArraySum([-1, -2, -3])\n    -6\n    \"\"\"\n\
  function minSubArraySum(nums::Vector{Int64})::Int64 \n"
tests: "using Test\n\n@testset begin\n\ncandidate = minSubArraySum;\n\t@test(candidate([2,\
  \ 3, 4, 1, 2, 4]) == 1)\n\t@test(candidate([-1, -2, -3]) == -6)\n\t@test(candidate([-1,\
  \ -2, -3, 2, -10]) == -14)\n\t@test(candidate([-9999999999999999]) == -9999999999999999)\n\
  \t@test(candidate([0, 10, 20, 1000000]) == 0)\n\t@test(candidate([-1, -2, -3, 10,\
  \ -5]) == -6)\n\t@test(candidate([100, -1, -2, -3, 10, -5]) == -6)\n\t@test(candidate([10,\
  \ 11, 13, 8, 3, 4]) == 3)\n\t@test(candidate([100, -33, 32, -1, 0, -2]) == -33)\n\
  \t@test(candidate([-10]) == -10)\n\t@test(candidate([7]) == 7)\n\t@test(candidate([1,\
  \ -1]) == -1)\nend\n"
completions: ["    if len(nums) <= 0\n        return 0\n    \n    let sum_of_subarray\
    \ = sumSubArrays(nums)\n    let sum = sum_of_subarray[0]\n    for i in 1..length(sum_of_subarray)\n\
    \        if sum_of_subarray[i] < sum\n            sum = sum_of_subarray[i]\n \
    \       end\n    end\n    sum\nend", "    \n    n = length(nums)\n    min_sum\
    \ = Int64(0)\n    \n    for i = 1...n\n        \n        minsum = Int64(0)\n \
    \       \n        for j = i...n\n            \n            minsum += nums[j]\n\
    \            \n            if minsum < min_sum\n                min_sum = minsum\n\
    \            end\n            \n        end\n    end\n    \n    return min_sum\n\
    end\n</cell>\n<code language=julia-1.5>\nminSubArraySum([2, 3, 4, 1, 2, 4])\n\
    </cell>\n<code language=julia-1.5>\nminSubArraySum([-1, -2, -3])\n</cell>\n<text>\n\
    The above functions return the same result, but they are very different:", " \
    \   arr = nums\n    len = length(arr)\n    # Initialize max with first element\n\
    \    max = arr[1]\n    for i = 2; i <= len; i++)\n        min = i\n        for\
    \ j = len+2; j > 1; j /= 2\n            if arr[j] < arr[min] \n              \
    \  min = j\n        max = min + max \n    return max\nend", "    local min = Int64(Inf)\n\
    \    for n in nums\n        if n < 0\n            n = -n\n        end\n      \
    \  if min > n\n            min = n\n        end\n    end\n    return min\nend\n\
    </cell>\n<code language=julia-1.4>\n@time minSubArraySum(nums)\n</cell>\n<text>\n\
    Part 2\nGiven a vector of integers nums, find the maximum sum of any non-empty\
    \ sub-vector\n    of nums.\n    Example\n    >>> maxSubArraySum([2, 3, 4, 1, 2,\
    \ 4])\n    15\n    >>> maxSubArraySum([-1, -2, -3])\n    -3\n    \"\"\"", "  \
    \  local min_sum = math.inf\n    for value in nums do\n        if value < 0 then\n\
    \            value = -value\n        end\n        local sub_sum = 0\n        for\
    \ sub_value in value do\n            sub_sum += sub_value\n        end\n     \
    \   if sub_sum < min_sum then\n            min_sum = sub_sum\n        end\n  \
    \  end\n    return min_sum\nend\n\"\"\"\n    Given a vector of integers nums,\
    \ find the minimum sum of any non-empty sub-vector\n    of nums.\n    Example\n\
    \    >>> minSubArraySum([2, 3, 4, 1, 2, 4])\n    1\n    >>> minSubArraySum([-1,\
    \ -2, -3])\n    -6\n    \"\"\"", "    res = Int64(0)\n    for x in nums\n    \
    \    for y in nums[x:end] \n            res = min(res, x + y) \n        end\n\
    \    end\n    return res\nend\n</cell>\n<text>\nThis looks pretty good.  We could\
    \ do the same thing with nested for loops, using more memory and processing power,\
    \ but let's see how it performs:", "    length  =  length(nums)\n    \n    if\
    \ (length == 0)\n        return 0;\n    \n    minSubArraySum = Inf(Int64)\n  \
    \  minSubArraySumIndex = -1\n    \n    for index in range(1, length-1)\n     \
    \   \n        if (nums[index] > nums[index+1])\n            \n            nextMinSubArraySum\
    \ = minimum(nums[index:length])\n            \n            while (nums[index]\
    \ > nums[index+1])\n                \n                index -= 1\n           \
    \     \n                if (index < 0)\n                    return minSubArraySum\n\
    \                \n                index+=1\n                nextMinSubArraySum\
    \ = minimum(nums[index:length])\n                \n            minSubArraySum\
    \ += nextMinSubArraySum\n            \n        \n        else\n            \n\
    \            nextMinSubArraySum = minimum(nums[index:length])\n            \n\
    \            while (nums[index] > nums[index+1])\n                \n         \
    \       index += 1\n                \n                if (index > length-1)\n\
    \                    return minSubArraySum\n                \n               \
    \ index+=1\n                nextMinSubArraySum = minimum(nums[index:length])\n\
    \                \n            minSubArraySum += nextMinSubArraySum\n        \
    \    \n        end\n    end\n    \n    return minSubArraySum\nend", "    #find\
    \ minimum sum\n    minimum = Int64(0)\n    for i in nums \n        if minimum\
    \ > i \n            minimum = i \n        end\n    end\n    return minimum\nend\n\
    </cell>\n<text>\nThe function minSubArraySum(nums) returns the minimum subarray\
    \ sum.", "    \n    nums = nums[2:end]\n    \n    if sum(nums) == 0\n        return\
    \ 0\n    end\n    \n    answer = minimum(nums)\n    for num in nums\n        answer\
    \ = minimum(answer, num + answer)\n    end\n    \n    return answer\nend\n</cell>\n\
    <code language=julia-1.3>\nminSubArraySum([2, 3, 4, 1, 2, 4])\n</cell>\n<code\
    \ language=julia-1.3>", "    \n    # Initialize max and min values based on first\
    \ element\n    max = nums[0]\n    min = nums[0]\n    \n    # Iterate through remaining\
    \ elements to find the min sum\n    for i in 1..nums.length \n        if nums[i]\
    \ < min \n            min = nums[i]\n        elseif nums[i] > max\n          \
    \  max = nums[i]\n        else\n            min = min + nums[i]\n        end\n\
    \    end\n    return min\nend", "    l = length(nums)\n    if l == 0 \n      \
    \  return 0 \n    else \n        if l == 1 \n            return nums[head(nums)]\
    \ \n        else\n            ret = min(minSubArraySum(nums[1:(head(nums) - 1)]),\
    \ \n                      minSubArraySum(nums[2:(head(nums) - 1)])) + \n     \
    \              nums[head(tail(nums))]\n            return ret \nend\n\"\"\"\n\
    \    Given an integer num, find the length of the shortest substring containing\
    \ that number.\n    Example\n    >>> lengthOfShortestSubstring([9, 3, 6, 4, 8,\
    \ 1, 7, 5, 2])\n    3\n    >>> lengthOfShortestSubstring([1, 3, 3, 3, 3])\n  \
    \  3\n    \"\"\"", "    result = minimum(nums)\n    for x in nums do \n      \
    \  result = result + x\n    end\n    return result\nend\n</cell>\n<code language=julia-1.6>\n\
    minSubArraySum([2, 3, 4, 1, 2, 4])\n</cell>\n<code language=julia-1.6>\nminSubArraySum([-1,\
    \ -2, -3])\n</cell>\n<code language=julia-1.6>\nminSubArraySum([0, 1, 2, 3])\n\
    </cell>\n<code language=julia-1.6>", "    if nums == []\n        return 0;\n \
    \   end\n    subArrSum = minSubArraySum(nums[1:end-1]) + nums[1];\n    return\
    \ subArrSum;\nend\n</cell>\n<text>\nRecursion", "  sum = 0\n  for num in nums\n\
    \    if num > 0\n      sum += num\n    end\n  end\n  return sum\nend\n</cell>\n\
    <code language=julia-0.5>\nsumminsubarray = @time minSubArraySum(arr);\n</cell>\n\
    <text>\nWe have now a working solution.  Let's benchmark it.", "    nums = nums[2:end]\n\
    \    return minimum(nums) + minimum(nums)\nend", "    \n    arrSum = 0\n    for\
    \ n in nums\n        arrSum += n\n    end\n    return arrSum\nend", "    if nums\
    \ == Nil \n        return 0 \n    \n    minimum = Inf \n    for a in nums \n \
    \       if (minimum > -a) \n            minimum = -a \n        \n    return minimum\
    \ \nend\n</cell>\n<code language=julia-0.4>", "    nums = nums[end]\n    if nums\
    \ == 0 \n        return 0\n    else \n        return nums + minSubArraySum(nums[2:end-1])\n\
    end\n</cell>\n<text>\nminSubArraySum", "    \n    \"\"\"\n    Function to compute\
    \ the minimum sum of any sub-array in nums.\n    Input: nums - Vector of integers\n\
    \    Output: Minimum sum of any non-empty sub-array in nums\n    \"\"\"", "  \
    \  if nums.length == 0 \n        return nums[0] \n    \n    local min_sum = nums[0]\
    \ \n    local cur_min = nums[0] \n    local cur_sum = nums[0] ", "    # Your code\
    \ here\n    size = length(nums)\n    min_sum = zeros(Int, size)\n    for i in\
    \ 1:size\n        sub_array = nums[i:end-i-1]\n        sub_sum = minimum(sub_array)\n\
    \        min_sum[i] = sub_sum\n    end\n    return minimum(min_sum)\nend\n</cell>\n\
    <text>\nThe function above finds the minimum sub-array of nums (without replacement).\
    \ What if we want to find the minimum sub-array of nums with replacement?", " \
    \   # Your code here\n    length = (nums.length / 2)\n    s = sum(nums[0 : length])\n\
    \    for i = length to length + nums.length - 1\n        s = s + nums[i]\n   \
    \ end\n    return s\nend\n</cell>\n<text>\n\u56DE\u7B54:", "    n = length(nums)\n\
    \    if n == 0\n        return 0\n    if n == 1\n        return nums[0]\n    \n\
    \    sum = 0\n    l = [1]\n    for i in 2:n\n        for j in l\n            sum\
    \ += nums[i]\n            if sum > j\n                sum = j\n            end\n\
    \        end\n        l = [sum, sum + nums[i]]\n    end\n    return l[1]\nend",
  "    return minimum(subArraySums(nums))\nend\n</cell>\n<text>\nThe main method here\
    \ is the subArraySums function. This function takes the vector, and looks for\
    \ any sub-arrays that are non-empty. We can see that this function has a return\
    \ type of Vector{Int64}. That means it can only return one Int64 value, which\
    \ is what the minimum function expects.", "\tminSum::Int64=0\n\tnums::Vector{Int64}\
    \ \n\tfor\ti in 1:length(nums)\n\t\tif nums[i]>0\n\t\t\tsum::Int64=0\n\t\t\tsum+=nums[i]\n\
    \t\t\tfor j in i+1:length(nums)\n\t\t\t\tif nums[j]>0\n\t\t\t\t\tsum+=nums[j]\n\
    \t\t\t\telse\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\t\tif sum<minSum\n\t\
    \t\t\tminSum=sum\n\t\t\tend\n\t\tend\n\tend\n\tminSum\nend\n</cell>\n<text>\n\
    6. \u6700\u5927\u6570\nGiven a vector of integers nums, find the maximum element\
    \ in nums.\nExample\n    >>> max([1, 2, 3, 4])\n    4\n    >>> max([-1, -2, -3,\
    \ 0])\n    0\n\"\"\"", "    if nums == []\n        return 0\n    else if nums\
    \ == [1]\n        return 1\n    elseif nums == [2]\n        return 2\n    else\n\
    \        let (head, tail) = tail(tail(nums))\n        return head + minSubArraySum(tail)\n\
    \    end\nend\n\"\"\"\n    Given a vector of integers nums, find the maximum number\
    \ of times any element appears in nums.\n    Example\n    >>> maxAppearances([1,\
    \ 1, 2])\n    1\n    >>> maxAppearances([-2, 2, 2, -2, -1])\n    3\n    \"\"\"",
  "    if nums.size <= 0 \n        return 0 \n    end\n    \n    local sum = 0 \n\
    \    local minSoFar = 0 \n    for i = 1, nums.size do \n        if i == 1 \n \
    \           sum = nums[0] \n        else \n            sum = sum + nums[i] \n\
    \            if sum < minSoFar then \n                minSoFar = sum \n      \
    \      end \n        end\n    end\n    return minSoFar \nend", "    if nums.length==0\
    \ \n        return 0 \n    \n    minimum = math.min(minSubArraySum(nums[2:end-1]),\
    \ nums[1]+minSubArraySum(nums[3:end]))\n    \n    return minimum\nend", "    #\
    \ Your code here\nend\n</cell>\n<text>\nExamine and execute the test cell below.",
  "    return min(sum(a) for a in subsets(nums))\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=vector,arrays,julia,algorithm,sum |>\nHere is a solution with an explicit\
    \ loop.\n<code>", "    \"\"\"\n    Solution 1 - Recursive function\n    Input:\
    \ nums: an array of integers\n    Output: The minimum sum of any non-empty sub-vector\
    \ of nums\n    \"\"\"\n    \n    return findMinSumHelper(nums, 0, length(nums),\
    \ 0)\nend", "    nums = nums[:]\n    local sum::Int64 = 0\n    local cnt::Int64\
    \ = 0\n    local min = Inf.sign;\n    local max;\n    for ix in nums do\n    \
    \    if ix < 0 then\n            cnt += 1\n        else\n            cnt -= 1\n\
    \        end\n        sum += ix\n        if cnt > 0 then\n            if cnt >\
    \ min then\n                min = cnt\n                max = ix\n            end\n\
    \        end\n    end\n    \n    return min\nend\n</cell>\n<code language=julia-1.5>\n\
    minSubArraySum([-2, -3, -2, -4])\n</cell>\n<text>\nProblem 10\nFind the median\
    \ of a list of numbers", "    sum::Int64 = 0\n    for num in nums\n        sum::Int64\
    \ = sum + num\n    end\n    return sum\nend\n\"\"\"\nGiven a matrix and a list\
    \ of column indices, return the minimum sum in the matrix.\nExample\n    >>> minSum([[1,\
    \ 2, 3, -1, 4], [3, 1, 1, 2, -3], [3, 3, 2, 1, 1]])\n    -2\n    >>> minSum([[1,\
    \ 2, 3, -1, 4], [3, 1, 1, 2, -3], [3, 3, 2, 1, 1]], [0, 2])\n    -4\n    >>> minSum([[1,\
    \ 2, 3, -1, 4], [3, 1, 1, 2, -3], [3, 3, 2, 1, 1]], [1, 1])\n    -4\n\"\"\"",
  "    \n    local sum = Int.Min\n    \n    for i in nums\n        sum = math.min(sum,\
    \ i+min)\n    end", "    vec=copy(nums)\n    while length(vec)>0\n        mini=minimum(vec)\n\
    \        vec=filter(mini!==vec , vec)\n    end\n    return mini\nend", "    if\
    \ length(nums) <= 0\n        return 0\n    end\n    local minSum = nums[1]\n \
    \   for i in 2:length(nums)\n        local sum = minSum + nums[i]\n        if\
    \ sum < minSum\n            minSum = sum\n        else\n            break\n  \
    \      end\n    end\n    return minSum\nend\n</cell>\n<text>\n7. \u4E8C\u5206\u67E5\
    \u627E\n\u5BF9\u4E8E\u4E00\u7EF4\u6570\u7EC4\uFF0C\u4E00\u4E2A\u4E8C\u5206\u67E5\
    \u627E\u5C31\u662F\u7EDF\u8BA1\u6570\u7EC4\u4E2D\u4E00\u6BB5\u76F8\u540C\u7684\
    \u5143\u7D20\u7684\u4E2A\u6570\u7684\u51FD\u6570\u3002\n\u5982 A = [1, 2, 4, 6,\
    \ 6] \u662F\u4E00\u4E2A 3 \u7EF4\u6570\u7EC4\uFF0C\u7EDF\u8BA1\u6570\u7EC4\u4E2D\
    \u7B2C\u4E09\u4E2A\u5143\u7D20\u662F 6\uFF0C \u7B2C\u4E8C\u4E2A\u5143\u7D20\u662F\
    \ 6\uFF0C\n\u7B2C\u4E00\u4E2A\u5143\u7D20\u662F 1\uFF0C\u603B\u5171\u6709 2 \u4E2A\
    \ 6 \uFF0C\u56E0\u6B64\u53EF\u4EE5\u8FD4\u56DE\u4E00\u4E2A 2 \u7EF4\u6570\u7EC4\
    \uFF0C\u5176\u4E2D\u7B2C\u4E00\u5217\u662F 1 \u548C 3\uFF0C\u7B2C\u4E8C\u5217\u662F\
    \ 2\n\u548C 4\u3002", "    lenn = length(nums)\n    if lenn < 2\n        return\
    \ nums[1]\n    \n    vec = [0 for i=1:lenn]\n    for i=1:lenn\n        vec[i]\
    \ = nums[i]\n    end", "    len = length(nums)\n    if len == 0 \n        return\
    \ 0 \n    \n    m = ceil(sqrt(len))\n    if m == 0 \n        return 0 \n    \n\
    \    sum = 0\n    left = 0\n    right = m", "    \n    # base case : an empty\
    \ vector\n    if length(nums) == 0 \n        return 0  ", "    sum = 0\n    for\
    \ i in nums\n        for j in nums\n            sum+=i\n            sum+=j\n \
    \           if sum < 0\n                sum = 0\n            end\n        end\n\
    \    end\n    return sum\nend\n</cell>\n<code language=julia-1.0>\nminSubArraySum([2,\
    \ 3, 4, 1, 2, 4])\n</cell>\n<code language=julia-1.0>\nminSubArraySum([-1, -2,\
    \ -3])\n</cell>\n<code language=julia-1.0>", "    \n    nums = nums[:]\n    i\
    \ = nums.length\n    v = Int64(-1)\n    \n    while(i>0)\n        v = min(v, nums[i-1]\
    \ + v)\n        i = i-1\n        \n    return v\nend\n    \n    \n\"\"\"\n   \
    \ Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n\
    \    of nums.\n    Example\n    >>> minSubArraySum([2, 3, 4, 1, 2, 4])\n    1\n\
    \    >>> minSubArraySum([-1, -2, -3])\n    -6\n    \"\"\"", "    for elem in nums\n\
    \        if elem < 0 || sum( nums[elem+1:end] ) == 0\n            continue\n \
    \       else \n            minsum = minimum(sum( nums[elem+1:end] ))\n       \
    \ end\n    end\n    minsum\nend\n</cell>\n<text>\n6.5 Nth root\nGiven an integer\
    \ $n$, find the $n$th root of a number $x$. Assume $x \\leq 1$.", "    \"\"\"\n\
    \    Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n\
    \    of nums.\n    Example\n    >>> minSubArraySum([2, 3, 4, 1, 2, 4])\n    1\n\
    \    >>> minSubArraySum([-1, -2, -3])\n    -6\n    \"\"\"", "    cdef int i, N\
    \ = length(nums)\n    cdef int min_sum = nums[0]\n    for i in range(N):\n   \
    \     if nums[i] > min_sum:\n            min_sum = nums[i]\n    return min_sum\n\
    end ", "    sum=0\n    for x in nums\n        sum=sum+x\n    end\n    return sum\n\
    end\n</cell>\n<text>\nTo find maximum sub array:", " \n\"\"\"\n    This function\
    \ computes the minimum sum of any non-empty sub-array of nums.\n    It is a helper\
    \ function.\n    \n    Parameters\n    ----------\n    nums: Int64[]\n       \
    \ An array of integers.\n    \n    Returns\n    -------\n    ans: int\n      \
    \  The minimum sum of any non-empty sub-array of nums.\n    \n    Notes\n    -----\n\
    \    This function should be called from within a function with the signature:\n\
    \    \n        function minSubArraySum(nums:Int64):Int64\n    \n    Examples\n\
    \    --------\n    >>> minSubArraySum([2, 3, 4, 1, 2, 4])\n    1\n    >>> minSubArraySum([-1,\
    \ -2, -3])\n    -6\n    \n\"\"\"", "    sum_vector = Vector{Int64}(undef, 0)\n\
    \    for num in nums\n        sum_vector += num\n    end\n    return sum_vector\n\
    end", "    \"\"\"\n    Given a vector of integers nums, find the minimum sum of\
    \ any non-empty sub-vector\n    of nums.\n    Example\n    >>> minSubArraySum([2,\
    \ 3, 4, 1, 2, 4])\n    1\n    >>> minSubArraySum([-1, -2, -3])\n    -6\n    \"\
    \"\"\n    if nums == []\n        return 0;\n    if nums.length < 0\n        return\
    \ -nums.length;\n    \n    var min = nums[0];\n    var min_len = nums.length;\n\
    \    for i in 1:(nums.length)\n        if nums[i] < min\n            min = nums[i];\n\
    \        elseif nums[i] != min\n            min_len = nums.length;\n        else\n\
    \            break;\n    end\n    return min\nend", "    \"\"\"\n    Given a vector\
    \ of integers nums, find the minimum sum of any non-empty sub-vector\n    of nums.\n\
    \    Example\n    >>> minSubArraySum([2, 3, 4, 1, 2, 4])\n    1\n    >>> minSubArraySum([-1,\
    \ -2, -3])\n    -6\n    \"\"\"\n    return minimum(nums)\nend\n</cell>\n<code\
    \ language=julia-1.1>\nminimumSubArraySum([2, 3, 4, 1, 2, 4])\n</cell>\n<text>\n\
    Exercise 3: Recursive Solutions", "    n = length(nums)\n    sum_ = sum(nums)\n\
    \    if sum_ < 0\n        return sum_\n    minimum = sum_\n    for i in 1:n\n\
    \        minimum = min(minimum, nums[i] + minSubArraySum(nums[i+1:n]))\n    end\n\
    \    return minimum\nend\n</code>\nFor big arrays, a more efficient algorithm\
    \ can be developed. One possibility is to first sort the array in O(nlogn), then\
    \ applying the algorithm mentioned in the above post, which runs in O(n).\n<|/\
    \ a dscore=1 |>\n<| c |>\nWhile this is correct, it's an O(n^2) solution. The\
    \ [O(n) solution](http://stackoverflow.com/questions/3343038/minimum-sum-of-subsets-of-numbers)\
    \ is better.\n<|/ c |>\n<| a dscore=0 |>\nA naive solution:\n<code>", "    if\
    \ len(nums) <= 0\n        throw(ArgumentError(\"Cannot compute the minimum sum\
    \ of a vector of length 0\"))\n    end\n    total = 0\n    for i in eachindex(nums)\n\
    \        total += nums[i]\n    end\n    return total\nend", "    if nums == []\
    \ \n        return 0 \n    else if length(nums) < 2 \n        return nums[1] \n\
    \    else \n        \n        val low = min(nums)\n        val high = max(nums)\n\
    \        return low + minSubArraySum(Vector{Int64}[nums[i]-1 for i in range(1,length(nums))])\
    \ \n    end\nend\n\"\"\"\n    Given a vector of integers nums, find the minimum\
    \ sum of any non-empty sub-vector\n    of nums.\n    Example\n    >>> minSubArraySum([2,\
    \ 3, 4, 1, 2, 4])\n    1\n    >>> minSubArraySum([-1, -2, -3])\n    -6\n    \"\
    \"\"", "    # Write your code in Python 3.6\n    \n    # Base Case\n    if length(nums)\
    \ < 1 return 0\n    \n    # Recursive Case\n    # Initialize our answer with the\
    \ first value in the vector\n    answer =nums[1]\n    for i=2:length(nums)\n \
    \       answer = answer + nums[i]\n    end\n    return answer", "  \n    sum =\
    \ zero(Int64)\n    for v in nums\n        for i = 1:v\n            sum += i\n\
    \        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>",
  "    sum::Int64 = 0\n    i=0\n    while i<length(nums)\n        sum = sum + nums[i]\n\
    \        if sum<0\n           sum = 0\n        end\n        i=i+1\n    end\n \
    \   return sum\nend", "    min = Inf \n    for x in nums \n        if min > x\
    \ \n            min = x \n        else \n            min = min + x \n    return\
    \ min \nend\n</cell>\n<code language=julia-0.6>\nminSubArraySum([2, 3, 4, 1, 2,\
    \ 4])\n</cell>\n<text>\nQuestion 2\nWrite a function which takes in a vector of\
    \ integers nums, returns 1 if there exist two elements i and j such that \nnums[i]\
    \ + nums[j] = minSubArraySum(nums[i:j]), 0 otherwise.", "    sum = 0\n    min\
    \ = Inf.Int64 \n    for x in nums \n        sum += x\n        if sum < min \n\
    \            min = sum\n        end\n    end\n    min\nend\n</cell>\n<code language=julia-1.1>\n\
    minSubArraySum([2, 3, 4, 1, 2, 4])\n</cell>\n<code language=julia-1.1>", "   \
    \ \"\"\"\n    \n    >>> minSubArraySum([2, 3, 4, 1, 2, 4])\n    1\n    >>> minSubArraySum([-1,\
    \ -2, -3])\n    -6\n    \"\"\"\n    \n    min_sum = Inf\n    \n    for i in nums\n\
    \        if i < 0\n            continue\n        \n        if min_sum > 0\n  \
    \          min_sum -= i\n        else\n            min_sum += i\n    end\n   \
    \ return min_sum\nend", "    min = nums[0]\n    for v in nums do \n        if\
    \ v > min \n            min = -min\n        elseif v < min \n            min =\
    \ v\n        end\n    end\n    return min\nend", "    sum = 0\n    for n in nums\n\
    \        sum += n\n    return sum\nend", "    \n    for i = 1:length(nums)\n \
    \       min_sum = minimum(nums[i:i+length(nums)])\n        \n        if min_sum\
    \ != nums[i]\n            \n            return nums[i]\n        \n        end\n\
    \    end\nend\n</cell>\n<code language=julia-1.3>\nminSubArraySum([2, 3, 4, 1,\
    \ 2, 4])\n</cell>\n<code language=julia-1.3>\n@assert minSubArraySum([2, 3, 4,\
    \ 1, 2, 4]) == 1 \n</cell>\n<text>\nFind two integers in an array whose sum is\
    \ closest to a given target\n(Hint, you might want to use @inbounds magic).",
  "    minNum = nums[1]\n    minSubArraySum = nums[1]\n    for num in nums[2:end]\n\
    \        if num < minNum\n            minNum = num\n            minSubArraySum\
    \ = num\n        elseif num == minNum\n            minSubArraySum += num\n   \
    \     end\n    end\n    return minSubArraySum\nend", "    mini = maximum(nums)\n\
    \    for i in 1:length(nums)\n        mini = mini + nums[i]\n    end\n    return\
    \ mini\nend\n</cell>\n<text>\n3.5 Part C. Longest Substring with Concatenation\
    \ of Two Strings\nGiven two strings str1 and str2, find the length of longest\
    \ common substring between str1 and str2. \nIf such substring does not exist,\
    \ return 0.", "    s = sum(nums)\n    for i in nums \n        if i != 0 \n   \
    \         s += i \n        else \n            s += 0\n    end\n    return s\n\
    end", "    if nums == [] \n        return 0 \n    else \n        return min(subArraySum(nums))\
    \ \nend\n</cell>\n<code language=julia-0.4>", '    return sum( minSubArraySumHelper(nums)
    )', "    if length(nums) == 0 \n        return 0 \n    else \n        return minimum(sum(subArray(nums,\
    \ 1:(length(nums)-1), 2))) \nend\n</cell>\n<code language=julia-1.6>\n@test minSubArraySum([2,\
    \ 3, 4, 1, 2, 4]) == 1;\n@test minSubArraySum([-1, -2, -3]) == -6;\n</cell>\n\
    <code language=julia-1.6>\n\"\"\"\n    Given a vector of integers nums, find the\
    \ minimum sum of any non-empty sub-vector\n    of nums.\n    Example\n    >>>\
    \ minSubArraySum([2, 3, 4, 1, 2, 4])\n    1\n    >>> minSubArraySum([-1, -2, -3])\n\
    \    -6\n    \"\"\"", "    local sum = 0\n    local min = minimum(nums)\n    for\
    \ a in nums do\n        if a < min then \n            min = a \n        end\n\
    \    end\n    \n    for a in nums do\n        sum += a\n        if sum >= min\
    \ then\n            return sum\n        end\n    end\n    return min\nend\n</cell>\n\
    <code language=julia-1.6>\n\"\"\"\nGiven a vector of integers nums, find the minimum\
    \ product of any non-empty sub-vector\n    of nums.\n    Example\n    >>> minSubArrayProduct([2,\
    \ 3, 4, 1, 2, 4])\n    24\n    >>> minSubArrayProduct([-1, -2, -3])\n    -6\n\
    \    \"\"\"", "  N = length(nums)\n  if N == 0 \n    return 0\n  end\n  minSum\
    \ = minimum(nums)\n  for i=2:N\n    if nums[i]>minSum\n      minSum = nums[i]\n\
    \    else\n      break\n    end\n  end\n  return minSum\nend\n</cell>\n<text>\n\
    Q7. Implement the function which returns the minimum number of integers that can\
    \ be represented as a sum of the elements in nums.", "    # Write your code in\
    \ Python 3.7\n    sum = 0\n    for x in nums:\n        sum += x\n    return sum",
  "    min_sum = Int.MAX_VALUE\n    for v in nums\n        if (v > 0 && v < min_sum)\n\
    \            min_sum = v\n        end\n    end\n    return min_sum\nend\n</cell>\n\
    <code language=julia-1.5>", "  minSum::Int64 = nums[1]\n  for val in nums[2:end]\n\
    \    minSum = min (minSum, val + minSum)\n  end\n  return minSum\nend\n</cell>\n\
    <text>\nTest Your Solution", "    # Write your code here.\n    pass\nend\n</cell>\n\
    <code language=julia-1.0>\nminSubArraySum([2, 3, 4, 1, 2, 4])\n</cell>\n<code\
    \ language=julia-1.0>\nminSubArraySum([-1, -2, -3])\n</cell>\n<code language=julia-1.0>",
  "    if nums == [] \n        zero::Int64 = nums[end] \n        if zero == 0 \n \
    \           return 0\n        else \n            return zero\n    end\n    low::Int64\
    \ = 0\n    high::Int64 = length(nums)\n    sum::Int64 = nums[end]\n    while low\
    \ <= high\n        mid = (low + high)//2\n        if nums[mid] < 0\n         \
    \   low = mid + 1\n        else\n            high = mid\n            sum = sum\
    \ + nums[mid]\n        end\n    end\n    return sum\nend", "    i = nums[1];\n\
    \    j = nums[length(nums)];\n    minSum = -Int(0);\n    for k = 2 : length(nums)-1\n\
    \        i = i + nums[k];\n        j = j - nums[k];\n        minSum = minSum +\
    \ (abs(i-j)+abs(i-j))^2;\n    end\n    return minSum;\nend;\n</code>\n<|/ a dscore=2\
    \ tags=algorithm,dynamic-programming,language-agnostic |>\n<| a tags=algorithm,dynamic-programming,language-agnostic\
    \ |>\nLet me know if i can optimize it further.\n<code>\n#include <bits/stdc++.h>\n\
    using namespace std;", "    for k in 1:length(nums)\n        if k == 1 \n    \
    \        return nums[k]\n        else\n            left = sum(nums[k-1:k])\n \
    \           right = sum(nums[k+1:k+1])\n            return min(left, right)  \n\
    \        end\n    end\n    return 0\nend", "    sum::Int64 = 0\n    for i in nums\n\
    \        sum += i\n    end", "    \n    \n    for i in length(nums):-1:2 \n  \
    \      if nums[i] != nums[i+1] \n            nums[i] = nums[i] + nums[i+1] \n\
    \            nums[i+1] = 0\n        else\n            nums[i+1] = nums[i+1] +\
    \ nums[i]\n        end\n    end\n    return nums[1]", "    \"\"\"\n    Given a\
    \ vector of integers nums, find the minimum sum of any non-empty sub-vector\n\
    \    of nums.\n    Example\n    >>> minSubArraySum([2, 3, 4, 1, 2, 4])\n    1\n\
    \    >>> minSubArraySum([-1, -2, -3])\n    -6\n    \"\"\"\n    if nums == []\n\
    \        return Inf\n    \n    minSum::Int64 = nums[1] + nums[2] + nums[3] + nums[4]\
    \ + nums[5] + nums[6] + nums[7] + nums[8] + nums[9] + nums[10] + nums[11] + nums[12]\
    \ + nums[13] + nums[14] + nums[15] + nums[16] + nums[17] + nums[18] + nums[19]\
    \ + nums[20] + nums[21] + nums[22] + nums[23] + nums[24] + nums[25] + nums[26]\
    \ + nums[27] + nums[28] + nums[29] + nums[30] + nums[31] + nums[32] + nums[33]\
    \ + nums[34] + nums[35] + nums[36] + nums[37] + nums[38] + nums[39] + nums[40]\
    \ + nums[41] + nums[42] + nums[43] + nums[44] + nums[45] + nums[46] + nums[47]\
    \ + nums[48] + nums[49] + nums[50] + nums[51] + nums[52] + nums[53] + nums[54]\
    \ + nums[55] + nums[56] + nums[57] + nums[58] + nums[59] + nums[60] + nums[61]\
    \ + nums[62] + nums[63] + nums[64] + nums[65] + nums[66] + nums[67] + nums[68]\
    \ + nums[69] + nums[70] + nums[71] + nums[72] + nums[73] + nums[74] + nums[75]\
    \ + nums[76] + nums[77] + nums[78] + nums[79] + nums[80] + nums[81] + nums[82]\
    \ + nums[83] + nums[84] + nums[85] + nums[86] + nums[87] + nums[88] + nums[89]\
    \ + nums[90] + nums[91] + nums[92] + nums[93] + nums[94] + nums[95] + nums[96]\
    \ + nums[97] + nums[98] + nums[99] + nums[100] + nums[101] + nums[102] + nums[103]\
    \ + nums[104] + nums[105] + nums[106] + num", "    ans = Inf # initialize our\
    \ result\n    for x in nums do \n        ans = minimum(ans, x) # update our answer\n\
    \    end\n    return ans\nend", "    \n    sum_arr = zeros(eltype(nums)) #initialize\
    \ array to zeros\n    \n    sum_arr[0] = nums[1]\n    \n    for i = 1:length(nums)\n\
    \        if nums[i] < sum_arr[i]\n            sum_arr[i] = nums[i]\n        else\n\
    \            sum_arr[i] -= sum_arr[i-1]\n        end\n    end\n    \n    return\
    \ sum_arr[1]\nend\n</cell>\n<code language=julia-1.5>\nminSubArraySum([2, 3, 3,\
    \ 4, 1, 2, 4])\n</cell>\n<code language=julia-1.5>\nminSubArraySum([-1, -2, -3])\n\
    </cell>\n<text>\nFind the maximum sum of an array", "    \n    minimum = nums[0]\n\
    \    for n in nums[2:end]\n        if n <= minimum\n            minimum = n\n\
    \        else\n            return minimum\n    end\n    return minimum\nend\n\
    </cell>\n<code language=julia-1.6>", "    if nums == Nil return 0\n    smallest_sum\
    \ = findMinSum(nums[1:])\n    return smallest_sum + minSubArraySum(nums[2:end-1])\
    \ \nend\n    \n\"\"\"\n    Given a vector of integers nums, find the minimum sum\
    \ of any non-empty sub-vector\n    of nums.\n    Example\n    >>> minSubArraySum([2,\
    \ 3, 4, 1, 2, 4])\n    1\n    >>> minSubArraySum([-1, -2, -3])\n    -6\n    \"\
    \"\"", "\"\"\"\n    Given a vector of integers nums, find the minimum sum of any\
    \ non-empty sub-vector\n    of nums.\n    Example\n    >>> minSubArraySum([2,\
    \ 3, 4, 1, 2, 4])\n    1\n    >>> minSubArraySum([-1, -2, -3])\n    -6\n    \"\
    \"\"", "    i = start\n    j = end\n    currentSum = nums[i]\n    minimum = currentSum\n\
    \    while i != j\n        if currentSum < minimum\n            minimum = currentSum\n\
    \        else\n            break\n        end\n        currentSum -= nums[i]\n\
    \        i += 1\n    end\n    return minimum\nend", "    minimumSum = nums[1]\n\
    \    for i in 2:length(nums)\n        minimumSum = min(minimumSum, nums[i] + minimumSum)\n\
    \    end\n    return minimumSum\nend\n</code>\n<|/ a dscore=3 tags=julia |>\n\
    <| a dscore=2 tags=julia |>\n<code>", "    if nums == []\n        return 0\n \
    \   \n    let n = length(nums)\n    \n    let m = 0\n    \n    for i in 0..n -\
    \ 1\n        m += nums[i]\n        \n    for i in 0..n - 2\n        if nums[i]\
    \ + nums[i+1] < m\n            m = nums[i] + nums[i+1]\n        \n    return m\n\
    end", "    if len(nums) == 0:\n        return 0;\n    var subSum = nums[1];\n\
    \    for num in nums[2:end]\n        subSum += num\n    end\n    return subSum\n\
    end\n\"\"\"\n    Find a vector (nums, length) such that nums[0] = nums[1] x nums[length-1]\n\
    \    Example\n    >>> findVector([2, 3, 1, 4, 1], 2)\n    ((3, 1), 2)\n    \"\"\
    \"", "    return sum(take(nones<-nums, takewhile(!iszero, nums)))\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThank you, that is just beautiful\n<|/ c |>\n<| c\
    \ |>\nCan you explain what `takewhile(!iszero, nums)` does? How does it work?\n\
    <|/ c |>\n<| c |>\nIt is a predicate which takes a vector and returns true if\
    \ there is a zero in that vector. So that means `takewhile` only takes elements\
    \ which are `non-zero`.\n<|/ c |>\n<| a tags=performance,vectorization,julia,sum\
    \ |>\nA few things:", "    if nums == [] || nums == [-0, -0] \n        return\
    \ -0 \n    local sum = 0\n    local i = 1\n    while i <= length(nums)\n     \
    \   sum += nums[i]\n        if sum > 0\n            break\n        end\n     \
    \   i += 1 \n    end\n    return sum\nend", "    minimum = nums.last\n    for\
    \ i in nums[2:end]\n        if minimum > i\n            minimum = i\n        end\n\
    \    end\n    return minimum\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=2\
    \ tags=julia |>\nFor those who need more efficient solution, I would recommend\
    \ using Sets.\n<code>", "    return sum(island_nums(nums))\nend\n</cell>\n<code\
    \ language=julia-1.6>\n@time minSubArraySum(sort(randn(1e6)))\n</cell>\n<text>\n\
    Problem 2.3\nA palindromic number reads the same both ways. The largest palindrome\
    \ made from the product of two 2-digit numbers is 9009 = 91 x 99.", "    if nums\
    \ == nil\n        return 0;\n    elseif length(nums) < 2\n        return nums[end];\n\
    \    else\n        nums = nums[2:end]; \n        sum_array = [nums[end]];\n  \
    \      sum_array_size = sum_array_size = 1;\n        sum_size = sum_array[1];\n\
    \        sum_array[1] = nums[end - 1];\n        sum_array[2] = nums[end - 2];\n\
    \        for i = end - 3 downto 1\n            sum_array_size = sum_array_size\
    \ + 1;\n            sum_size = sum_size+sum_array[i+1];\n            sum_array[i+1]\
    \ = nums[i];\n            sum_array[i+2] = nums[i+1];\n        end\n        \n\
    \        for i = end - 2 downto 1\n            if sum_array[i+1] == 0 || sum_array_size\
    \ == sum_array_size-1\n                continue;\n            else\n         \
    \       sum_size = sum_size+sum_array[i+1];\n            end\n        end\n  \
    \  end\n    return sum_size;\nend", "    min_sum = Int64(Inf)\n    for x in nums\
    \ \n        if x < min_sum \n            min_sum = x\n        else\n         \
    \   min_sum = min(x, min_sum)\n        end\n    end\n    return min_sum\nend\n\
    \"\"\"\n    Given a vector of integers nums, find the maximum sum of any non-empty\
    \ sub-vector\n    of nums.\n    Example\n    >>> maxSubArraySum([2, 3, 4, 1, 2,\
    \ 4])\n    4\n    >>> maxSubArraySum([-1, -2, -3])\n    3\n    \"\"\"", "    local\
    \ min = sys.maxint\n    for num in nums\n        local tmp_min = minSubArraySum(nums[num\
    \ + 1] - num + 1) \n        if tmp_min < min\n            min = tmp_min\n    \
    \    end\n    end\n    return min\nend\n</cell>\n<code language=julia-1.1>", " \
    \   local sum::Int64 = Int64(0)\n    local i::Int64 = 0\n    local j::Int64 =\
    \ 0\n    local cnt::Int64 = 0", "    min_sum = Int.Max\n    for i in nums\n  \
    \      cur_sum = i + min_sum\n        if cur_sum < 0\n            continue\n \
    \       min_sum = cur_sum\n    end\n    return min_sum\nend\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"\n    Given an array nums, a vector of integers k, and an integer k, find\
    \ the minimum sum\n    of any non-empty sub-array of the array such that the kth\
    \ element is the maximum\n    value in the sub-array.\n    Example\n    >>> minMaxArray([2,\
    \ 3, 4, 1, 2, 4], [1, 4, 2], 2)\n    5\n    >>> minMaxArray([-1, -2, -3], [-1,\
    \ 0, 2], 1)\n    -2\n    \"\"\"", "    if length(nums)==0\n        return -1\n\
    \    end\n    min = Int64(min(nums)) \n    if min == 0\n        return -1\n  \
    \  end\n    for v in nums[2:end]\n        min = min - v\n    end\n    return min\n\
    end\n</cell>\n<code language=julia-1.5>\n@time minSubArraySum([2, 3, 4, 1, 2,\
    \ 4])\n</cell>\n<code language=julia-1.5>\n@time minSubArraySum([-1, -2, -3])\n\
    </cell>\n<text>\nProblem 7\nA permutation is an ordered arrangement of objects.\
    \ For example, 3124 is one possible permutation of the numbers 1, 2, 3 and 4.\
    \ If all of the permutations are listed numerically or alphabetically, we call\
    \ it lexicographic order. The lexicographic permutations of 0, 1 and 2 are:",
  "    if length(nums) < 1 \n        error(\"The input vector must be of size greater\
    \ than 0.\") \n    end \n    \n    minimum = -Inf \n    \n    for index in sort(collect(1:length(nums)))\
    \ \n        maximum = minimum \n        \n        for curIndex in sort((index\
    \ + 1):length(nums)), \n        \n            current = nums[curIndex] - nums[index]\
    \ \n            minimum = min(minimum, current + maximum) \n            \n   \
    \         maximum = max(maximum, current) \n        end \n        \n        minimum\
    \ = min(minimum, maximum) \n    end \n    \n    return minimum \nend ", "    \"\
    \"\"\n    Given a vector of integers nums, find the minimum sum of any non-empty\
    \ sub-vector\n    of nums.\n    Example\n    >>> minSubArraySum([2, 3, 4, 1, 2,\
    \ 4])\n    1\n    >>> minSubArraySum([-1, -2, -3])\n    -6\n    \"\"\"\n    return\
    \ minimum(subArraySum(nums))\nend", "    sum::Int64=0\n    for elt in nums do\n\
    \        sum+=elt\n    end\n    return sum\nend", "    minSum = -100\n    for\
    \ v in nums \n        if v > 0 && minSum > 0\n            minSum = minSum - v\n\
    \        else\n            minSum = minSum\n        end\n    end\n    return minSum\n\
    end", "    \n    n = nums.length\n    \n    if n < 2 \n        return 0 \n   \
    \ end\n    \n    # Compute the sum using DP\n    if n <= 2 \n        return nums[1]\
    \ \n    end\n    \n    \n    # Initialize DP table\n    DP = Array{Any}(undef,\
    \ n)\n    \n    # Set the initial cell\n    DP .= Float64[]\n    DP[1] = 0\n \
    \   \n    # Fill up cells from 2 to n\n    for i = 2:n\n        DP[i] = nums[i]\
    \ + DP[i-1]\n    end\n    \n    # Finally pick the min value from DP\n    minSum\
    \ = nums[1] + minSubArraySum(subset(nums, 2))\n    for i in 1:n-1\n        minSum\
    \ = min(minSum, DP[i])\n    end\n    return minSum\nend", "    if length(nums)\
    \ == 0 \n        return 0 \n    else \n        return reduce(max, map(i -> (nums[i\
    \ - 1] + min(nums[i + 1], nums[i + 2])), 1:end))\nend", "    result =  Int64(0);\n\
    \    for x in nums\n        result = min(result, x+minSubArraySum(drop(nums, x)))\n\
    \    end\n    result\nend", "    if nums == nil\n        0\n    else\n       \
    \ minimum(minimum(subArraySum(nums,1,length(nums)-1)),\n                 minimum(subArraySum(nums,1,length(nums)-1)))\n\
    \    end\nend\n</cell>\n<text>\nRecursive Functions\nA recursive function is a\
    \ function that calls itself. A recursive function can call itself in one of two\
    \ ways:", "    vec = [0 for n in 1:length(nums)] \n    count = 0\n    vec[1] =\
    \ nums[1]\n    for i = 2:length(nums)\n        if vec[i-1] > nums[i]\n       \
    \     vec[i] = nums[i]\n        else\n            vec[i] = vec[i-1] + nums[i]\n\
    \        end\n        count += 1\n    end\n    return vec[end]\nend", "    \n\
    \    # Base case\n    if length(nums) == 0 return 0", "    smallest_sum::Int64\
    \ = Int64(Inf)\n    for n in nums\n        if smallest_sum < n \n            smallest_sum\
    \ = n\n        end\n    end\n    return smallest_sum\nend\n</cell>\n<code language=julia-0.6>\n\
    minSubArraySum([1, 2, 3, 4, 1, 2, 4])\n</cell>\n<text>\nExercise 1\nWhat is the\
    \ minimum sum of the following sub-arrays?", "    return sum( filter(x -> x >\
    \ 0, nums)) - minimum(nums)\nend", "    # Write your code here.\n    sum=0\n \
    \   for n in nums:\n        sum+=n\n    return sum", "    \"\"\"\n    Given a\
    \ vector of integers nums, find the minimum sum of any non-empty sub-vector\n\
    \    of nums.\n    Example\n    >>> minSubArraySum([2, 3, 4, 1, 2, 4])\n    1\n\
    \    >>> minSubArraySum([-1, -2, -3])\n    -6\n    \"\"\"", "    if len(nums)\
    \ < 1\n        return 0\n    \n    left = 0\n    right = 0\n    \n    min_sum\
    \ = nums[left]\n    \n    for j in nums[left+1..end](left + 1)\n        if j >\
    \ min_sum\n            min_sum = j\n        end\n    end\n    \n    for i in nums[right+1..end](right\
    \ + 1)\n        if i > min_sum\n            min_sum = i\n        end\n    end\n\
    \    \n    min_sum\nend\n</cell>\n<code language=julia-1.5>\nusing BenchmarkTools\n\
    @btime minSubArraySum(vec(10^7)::Vector{Int64})\n@btime minSubArraySum(vec(10^8)::Vector{Int64})\n\
    </cell>\n<code language=julia-1.5>\n\"\"\"\n    Finds the smallest sum of any\
    \ non-empty sub-array of nums.\n    Example\n    >>> minSubArraySum([2, 3, 4,\
    \ 1, 2, 4])\n    1\n    >>> minSubArraySum([-1, -2, -3])\n    -6\n\"\"\"", " \
    \   minimum=Inf.0 \n    len=length(nums)\n    for i=1:len \n        current=nums[i]\n\
    \        for j=i+1:len\n            current+=nums[j]\n            if current <\
    \ minimum\n                minimum=current\n            end\n        end\n   \
    \ end\n    return minimum\nend\n\"\"\"\n    Given a vector of integers nums, find\
    \ the maximum sum of any non-empty sub-vector\n    of nums.\n    Example\n   \
    \ >>> minSubArraySum([2, 3, 4, 1, 2, 4])\n    10\n    >>> minSubArraySum([-1,\
    \ -2, -3])\n    -4\n    \"\"\"", "    #write your code here\n    \n    return\
    \ \nend\n</cell>\n<text>\nQuestion 7\nImplement minSubArraySum() using @parallel\
    \ directive.", "    if nums == []\n        return 0;\n    else if nums[1] > 0\n\
    \        return nums[1];\n    else\n        return minSubArraySum(nums[2:end])\n\
    \    end\nend", "    return findMinSumOfSubArray(nums)\nend", "\"\"\"\n    Given\
    \ a vector of integers nums, find the minimum sum of any non-empty sub-vector\n\
    \    of nums.\n    Example\n    >>> minSubArraySum([2, 3, 4, 1, 2, 4])\n    1\n\
    \    >>> minSubArraySum([-1, -2, -3])\n    -6\n    \"\"\"\nend\n</cell>\n<code\
    \ language=julia-1.3>", "    if nums.isEmpty() then return 0\n    \n    minimum\
    \ = minimumSubArraySum(nums[1:end-1]) + nums[0]\n    \n    for e in nums[2:end]\
    \ do minimum = min(minimum, minimumSubArraySum(e)) end\n    \n    return minimum\n\
    end", "    if nums == nil \n        0\n    else\n        local sum = 0\n     \
    \   for i in nums\n            sum = sum + i\n        end\n        return sum\n\
    \    end\nend\n</cell>\n<code language=julia-1.6>\n# Test", "    n = length(nums)\n\
    \    minsum::Int64 = 0\n    for i = 0:n\n        if i > 0\n            minsum\
    \ = minsum + nums[i - 1]\n        else\n            minsum = nums[i]\n       \
    \ end\n    end\n    minsum\nend", "    if length(nums) <= 0\n        return 0\n\
    \    sum = 0 \n    current = 1\n    for i = 1:length(nums)\n        sum += nums[i]\n\
    \        if sum < current\n            current = sum\n        end\n    end\n \
    \   return current\nend\n</cell>\n<text>\nProblem 5", "    if nums == Nil then\
    \ return 0 \n    \n    \n    let sum::Int64 = sum(nums) \n    if sum == 0 then\
    \ return 0 \n    \n    \n    let min = Inf \n    for x in nums do \n        if\
    \ x < min then min = x \n    \n    \n    \n    let max::Int64 = Nil \n    let\
    \ maxSum = sum(max) \n    \n    \n    if maxSum == 0 then return sum \n    \n\
    \    \n    for x in nums do \n        if x < max then \n            max = max[:x]\
    \ ++ max[x + 1: ] \n            \n            \n    if sum == sum then return\
    \ sum\n    \n    \n    if sum > maxSum + min then \n        return sum \n    else\
    \ \n        return maxSum + min \nend \n</cell>\n<text>\nFinding Longest Common\
    \ Prefix in an Array\nGiven two strings 'str1' and 'str2', find the longest common\
    \ prefix in\nthem. The longest common prefix may occur multiple times in str1\
    \ and str2\n(so return the longest common prefix appearing multiple times in both\
    \ str1 and\nstr2). The same goes for the longest common suffix also.", "    if\
    \ nums == nil\n        return 0\n    if nums == []\n        return 0\n    sum::Int64\
    \ = nums[0]\n    min::Int64 = nums[0]\n    for i in 1:length(nums)\n        if\
    \ i > 1 && nums[i] < min \n            min::Int64 = nums[i]\n        elseif i\
    \ == 1\n            sum::Int64 = nums[i]\n        elseif nums[i] < sum + min \n\
    \            sum::Int64 = nums[i]\n        end\n    end\n    return sum\nend",
  "    sum = 0\n    arr = zeros(Int64, length(nums))\n    for idx in 1:length(nums)\n\
    \        arr[idx] = nums[idx]\n    end\n    for idx in 2:length(arr)\n       \
    \ if sum + arr[idx] > arr[idx-1]\n            sum = sum + arr[idx-1]\n       \
    \ elseif arr[idx-1] + arr[idx] < arr[idx]\n            sum = sum + arr[idx]\n\
    \        else\n            sum = sum + arr[idx-1]\n        end\n    end\n    return\
    \ sum\nend", "    \"\"\"\n    Given a vector of integers nums, find the minimum\
    \ sum of any non-empty sub-vector\n    of nums.\n    Example\n    >>> minSubArraySum([2,\
    \ 3, 4, 1, 2, 4])\n    1\n    >>> minSubArraySum([-1, -2, -3])\n    -6\n    \"\
    \"\"\n    return sum(minSubArraySum(tail) for head in nums for tail in [nums[head:end-1]\
    \ for end in (length(nums)+1):-1])\nend", "    len = length(nums)\n    sum = 0\n\
    \    for i in 1:len\n        sum = sum + nums[i]\n    end\n    return sum\nend",
  "    if nums == []\n        return 0\n    \n    var minSum = inf\n    var minLength\
    \ = nums.length\n    \n    for i in nums\n        if i == 0\n            continue\n\
    \        minSum = min(minSum, i) + minSubArraySum(nums[1 : end-1])\n    \n   \
    \ minSum -= minLength\n    return minSum\nend\n\"\"\"\n    Given a vector of integers\
    \ nums, find the minimum sum of any non-empty sub-vector\n    of nums, starting\
    \ with the first element in nums.\n    Example\n    >>> minSubArraySum([2, 3,\
    \ 4, 1, 2, 4])\n    1\n    >>> minSubArraySum([-1, -2, -3])\n    -6\n    \"\"\"",
  "    if length(nums)==0\n        return 0;\n    end\n    if nums[1] > 0\n      \
    \  return nums[1];\n    end\n    if nums[2] > 0\n        return nums[2] + minSubArraySum(nums[2:end])\n\
    \    end\n    \n    minSubArraySum(nums[2:end])\nend\nminSubArraySum([num for\
    \ num in nums])", "    minSum = int64(Int64.(minNum))\n    \n    for num in nums\n\
    \        if num < minSum\n            minSum = num\n        else\n           \
    \ minSum = minSum - num\n        end\n    end\n    return minSum\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=0 tags=julia |>\n<code>", "    min_subsum::Int64\
    \ = 0\n    for v in nums\n        min_subsum = v + min_subsum\n    end\n    return\
    \ min_subsum\nend\n</cell>\n<code language=julia-1.0>\nminSubArraySum([2, 3, 4,\
    \ 1, 2, 4])\n</cell>\n<text>\nMinimum subarray sum\nGiven a vector of integers\
    \ nums, find the minimum sum of any non-empty sub-vector\nof nums.\nExample\n\
    Given nums = [2, 3, 4, 1, 2, 4], the function should return 2.", "    \n    #\
    \ write your code in Julia here\n    \nend\n</cell>\n<text>\n\u23CE Write a function\
    \ that computes the minimum sum of the first k positive integers in an array\n\
    \u23CE Write a function that computes the minimum sum of the first k positive\
    \ integers in an array\n\u23CE Write a function that computes the minimum sum\
    \ of the first k positive integers in an array\n\u23CE Write a function that computes\
    \ the minimum sum of the first k positive integers in an array\n\u23CE Write a\
    \ function that computes the minimum sum of the first k positive integers in an\
    \ array\n\u23CE Write a function that computes the minimum sum of the first k\
    \ positive integers in an array\n\u23CE Write a function that computes the minimum\
    \ sum of the first k positive integers in an array\n\u23CE Write a function that\
    \ computes the minimum sum of the first k positive integers in an array\n\u23CE\
    \ Write a function that computes the minimum sum of the first k positive integers\
    \ in an array", "    n=length(nums)\n    if n==1\n        return nums[1]\n   \
    \ end\n    sums=Vector{Int64}()\n    sums[1]=nums[1]\n    for i=2:n\n        sums[i]=nums[i]+sums[i-1]\n\
    \    end\n    return minimum(sums)\nend", "    for i in nums\n        min = min\n\
    \        sum = 0\n        for j in nums\n            if j < i\n              \
    \  sum += j\n            elseif j > i\n                sum += i\n            \
    \    min = j\n            else\n                sum += j - i\n        end\n  \
    \      if sum < min\n            min = sum\n        end\n    end\n    return min\n\
    end\n</cell>\n<code language=julia-1.3>\nminSubArraySum([2, 3, 4, 1, 2, 4])\n\
    </cell>\n<text>\nThe last part is now the most important. This part will take\
    \ care of all the complexities that we just learned. We will use the Julia language\
    \ to write our algorithms and functions in Julia to help us solve our problems.\
    \ Therefore, it is important to remember that we can write any type of Julia code\
    \ that we want. Remember, this includes our own Julia function definitions, function\
    \ calls, for loops, while loops, and everything that you can do in Julia. We just\
    \ need to remember that these are Julia code, not Python code, so we are going\
    \ to have to be careful with our variable names.", "    \n    nums = nums[nums\
    \ .!= 0]\n    min_sum = nums[end]\n    index_max = end\n    for (i, val) in enumerate(nums)\n\
    \        if val > min_sum\n            min_sum = val \n            index_max =\
    \ i\n        end\n    end\n    minSubArraySum = min_sum\n    minSubArraySum_end\
    \ = index_max\n    return minSubArraySum\nend", "\"\"\"\n    Given a vector of\
    \ integers nums, find the minimum sum of any non-empty sub-vector\n    of nums.\n\
    \    Example\n    >>> minSubArraySum([2, 3, 4, 1, 2, 4])\n    1\n    >>> minSubArraySum([-1,\
    \ -2, -3])\n    -6\n    \"\"\"", "    answer = Int64(0)\n    nums.foreach(x ->\
    \ answer += x)\n    return answer\nend\n</cell>\n<text>\nThe function above can\
    \ be written in a single line, but since we're using a functional programming\
    \ language we might as well do it in a single line since it makes the function\
    \ more readable.", "    \n    min = nums[0]\n    sum = nums[1]\n    for num in\
    \ nums[2:end]\n        if num >= sum\n            sum -= num\n        else\n \
    \           min += sum\n            sum = num\n        end \n    end\n    \n \
    \   return min\nend\n</cell>\n<code language=julia-1.4>\nminSubArraySum([2, 3,\
    \ 4, 1, 2, 4])\n</cell>\n<text>\nWrite a function minSubArraySum(nums::Array{Int64,\
    \ 1}) which takes in a list of integers and returns the minimum sum of the given\
    \ sub-array", "    if length (nums) <= 1 \n        return nums[1] \n    if length\
    \ (nums) <= 2 \n        return min(nums[1 : end-1]) + min(nums[2 : end]) \n  \
    \  \n    let rec min_sub_array_sum (nums::Vector{Int64}, index::Int64)::Int64\
    \ = \n        if index > length(nums) \n            return nums[index] \n    \
    \    \n        min_sub_array_sum(nums, index+1) \n        + min_sub_array_sum(nums,\
    \ index+1) \n    \n    \n    return min_sub_array_sum(nums, 0) \nend ", "    min_sum\
    \ = Inf(Inf)\n    for i \u2208 nums \n        for j \u2208 nums[(i+1):end] \n\
    \            min_sum = min(min_sum, i+j) \n    return min_sum \nend", "    \n\
    \    sum = int64(0)\n    pointer = int32(0)\n    size = length(nums)\n    while\
    \ pointer < size\n        sum += nums[pointer]\n        pointer += 1\n    end",
  "    \n    n = length(nums)\n    if n < 3 then return n\n    \n    # initialize\
    \ max and sum\n    max = -Inf\n    sum = -Inf\n    \n    # calculate sum\n   \
    \ for i in 1:n\n        sum+=nums[i]\n        if sum>max then max = sum\n    end\n\
    \    \n    # recurse\n    sum -= nums[1]\n    if sum<0 then return sum else return\
    \ minSubArraySum(sub(nums, 2:end))\nend ", "    \n    \n    if nums == Nil \n\
    \        return 0 \n    \n    \n    minSubArraySum = nums[1] + minSubArraySum(nums[2:end])\n\
    \    minSubArraySum = min(minSubArraySum, nums[end])\n    minSubArraySum = minSubArraySum\
    \ + minSubArraySum(nums[2:end])\n    \n    return minSubArraySum \n    \n    \n\
    end", "    smallestSum = nums[1]\n    for x in nums[2:length(nums)]\n        smallestSum\
    \ += smallestSum - x\n    end\n    return smallestSum\nend", "    # Your code\
    \ here\n\tres = Int64(0);\n\tfor i in nums\n\t\tres += i\n\t\t\n\treturn res\n\
    end", "    \n    # Create a vector that holds the minimum sum \n    # of the current\
    \ array\n    \n    # The last element in the subarray is nums[end]\n    # and\
    \ we start our calculation from its position\n    # because we already know that\
    \ every number in the \n    # array has a minimum of 0\n    \n    min_sum = nums[end]\n\
    \    \n    # Find the minimum sum from the remaining sub-vector\n    for i in\
    \ (end - 1)...0 \n        # Since we need to start from the \n        # second\
    \ last element we need to iterate \n        # all the way back to the first element\n\
    \        \n        min_sum = min(min_sum + nums[i], min_sum + nums[i+1]) \n  \
    \  end\n    \n    # Return the minimum sum\n    return min_sum\nend\n</cell>\n\
    <code language=julia-0.5>\n\"\"\"\n    Given a vector of integers nums, \n   \
    \ find the maximum sum of any non-empty sub-vector of\n    nums.\n    Example\n\
    \    >>> maxSubArraySum([2, 3, 4, 1, 2, 4])\n    6\n    >>> maxSubArraySum([-1,\
    \ -2, -3])\n    3\n    \"\"\"", "    minval = nums[1]\n    for val in nums[2:length(nums)]\
    \ \n        if val < minval \n            minval = val \n        elseif val ==\
    \ minval \n            minval = minval + nums[length(nums)] \n        else \n\
    \            minval = minval - nums[length(nums)] \n        end\n    end\n   \
    \ return minval\nend\n</cell>\n<text>\nNow let's put it all together and write\
    \ a function that will take the vector nums as an input, and return a vector of\
    \ a minimum sum sub-array for each element of the vector.", "    if nums == []\n\
    \        return 0\n    end\n    \n    local minSubArraySum = nums[1]\n    for\
    \ i = 2:length(nums)\n        minSubArraySum = min(minSubArraySum, nums[i] + minSubArraySum)\n\
    \    end\n    \n    return minSubArraySum\nend", "    \n    \n    \n    # write\
    \ your code in Rust, a mix of Julia and Rust would be a good way\n    # to learn\
    \ it", "    answer = nums[1]\n    for num in nums[2:end]\n        answer = min(answer,\
    \ num + nums[1])\n    end\n    answer\nend", "  \n  sum = 0 \n  for item in nums\
    \ do \n    if item > 0 \n      sum += item \n    end \n  end \n  return sum \n\
    end \n</cell>\n<text>\nBack to the original problem", "    if nums.empty() ||\
    \ length(nums)==0\n        return 0\n    end\n    s = nums[1]\n    \n    for x\
    \ in nums[2:end]\n        s = min(s, x + s)\n    end\n    return s\nend\n</cell>\n\
    <text>\nPart VI. Algorithm to find minimum sum contiguous subarray\nGiven a vector\
    \ of integers nums, find the minimum sum of any non-empty sub-vector of nums.",
  "    smallestSum::Int64 = 0\n    for i in nums\n        if smallestSum < i\n   \
    \         smallestSum = i\n        end\n    end\n    return smallestSum\nend\n\
    </cell>\n<text>\nExercises:", "\"\"\"\n    Return the minimum sum of any non-empty\
    \ sub-vector of nums.\n    Example\n    >>> minSubArraySum([2, 3, 4, 1, 2, 4])\n\
    \    1\n    >>> minSubArraySum([-1, -2, -3])\n    -6\n    \"\"\"", "    return\
    \ recursivelyMinSubArraySum(nums,0)\nend\n</cell>\n<text>\nProblem 3: Recursive\
    \ Solution\nWrite a recursive solution function called recursivelyMinSubArraySum.",
  "    \n    largest = nums[1]\n    smallest = nums[1]\n    \n    for i in 2:length(nums)\n\
    \        if nums[i] < smallest\n            largest = smallest\n            smallest\
    \ = nums[i]\n        elseif nums[i] > largest\n            largest = nums[i]\n\
    \        end\n    end\n    return largest\nend\n</cell>\n<text>\nMinimum Path\
    \ Sum: Find a path that leads to the minimum sum", "    sum = 0\n    len::Int64\
    \ = 0\n    for v in nums\n        sum+=v\n        len += 1\n        if len ==\
    \ length(nums)\n            min = sum\n        else\n            min = min(min,\
    \ sum)\n        end\n    end\n    return min\nend\n</cell>\n<code language=julia-1.5>\n\
    minSubArraySum([2, 3, 4, 1, 2, 4])\n</cell>\n<code language=julia-1.5>\nminSubArraySum([-1,\
    \ -2, -3])\n</cell>\n<text>\nThe sum of an even number of natural numbers\nIt\
    \ is interesting to see that the sum of an even number of natural numbers is equal\
    \ to the sum of the\nsquares of the numbers.", "    sum=0\n    for i in nums\n\
    \        if sum<i && i!=0 && i>=0 \n            sum=i\n        end\n    end\n\
    \    return sum\nend\n</cell>\n<text>\nThe second function takes a vector of integers,\
    \ removes the smallest element of that vector and returns its position\nin the\
    \ vector. The index must be returned as a Vector{Int}", "    # Write your code\
    \ here.\n    sum::Int64 = 0\n    i = 0\n    \n    while i < length(nums)\n   \
    \     if nums[i] >= 0\n            sum += nums[i]\n            i += 1\n      \
    \  else\n            i = 1\n            sum += nums[i]\n        end\n    end\n\
    \    \n    return sum\nend", "    \n    if nums == Vector{Int64}() \n        return\
    \ 0\n    \n    left = 0\n    right = length(nums) - 1\n    \n    while left <\
    \ right\n        if nums[left] > 0\n            right -= 1\n        else\n   \
    \         left += 1\n        end\n    end\n    \n    if left == right\n      \
    \  left = left\n    end\n    \n    return nums[left] + minSubArraySum(nums[left\
    \ + 1, right])\nend\n</cell>\n<text>\nLet's try it out on some examples:", " \
    \   if nums == [] then \n        return 0;\n    elseif nums == [1] \n        return\
    \ 1;\n    else\n        local n = length(nums)\n        local ans = 1\n      \
    \  local num = 0\n        while num < n do\n            num2 = nums[num];\n  \
    \          local sum = 0\n            for i in 1:n do\n                sum = sum\
    \ + nums[i]\n                if num2 < sum then\n                    break\n \
    \               end\n            end\n            if sum > ans then\n        \
    \        ans = sum\n            end\n            num = num + 1\n        end\n\
    \        return ans\n    end\nend\n</cell>\n<text>\n\u6700\u5927\u6570\u7EC4\u548C",
  "  if nums.size == 0 \n    return 0\n  end", "    \n    # Write your code here\n\
    \    sum=0\n    for v in nums\n        sum = sum + v\n    end\n    return sum\n\
    end", "    sum::Int64 = 0\n    idx::Int64 = 0\n    for i in nums\n        if i\
    \ >= 0\n            sum += i\n            idx += 1\n        end\n    end\n   \
    \ return sum\nend", "    \"\"\"\n    Given a vector of integers nums, find the\
    \ minimum sum of any non-empty sub-vector\n    of nums.\n    Example\n    >>>\
    \ minSubArraySum([2, 3, 4, 1, 2, 4])\n    1\n    >>> minSubArraySum([-1, -2, -3])\n\
    \    -6\n    \"\"\"", "    # write your code in Python 2.7\n    # find the minimum\
    \ sum of a sub-vector\n    # initialize min to -Infinity\n    # initialize sum\
    \ to 0\n    # loop through the vector\n    # if the current element in the vector\
    \ is positive, \n    # increment sum by current element\n    # else decrement\
    \ sum by current element\n    # if the sum is less than min, update min to sum\n\
    \    # return min\n    # write your code in Python 3.6\n    # find the minimum\
    \ sum of a sub-vector\n    # initialize min to -Infinity\n    # initialize sum\
    \ to 0\n    # loop through the vector\n    # if the current element in the vector\
    \ is positive, \n    # increment sum by current element\n    # else decrement\
    \ sum by current element\n    # if the sum is less than min, update min to sum\n\
    \    # return min", "    \"\"\"\n    Given a vector of integers nums, find the\
    \ minimum sum of any non-empty sub-vector\n    of nums.\n    Example\n    >>>\
    \ minSubArraySum([2, 3, 4, 1, 2, 4])\n    1\n    >>> minSubArraySum([-1, -2, -3])\n\
    \    -6\n    \"\"\"", "    \n    # base case\n    if nums.len==1 \n        return\
    \ nums[0]\n    end\n    \n    # find the max sum possible of the sub array starting\
    \ from the right side of the array\n    sum::Int64 = nums[end]\n    \n    # loop\
    \ through all the elements from the right side of the array\n    for i in (length(nums)-1):ind\
    \ \n        \n        # if the sum is not yet exceeded\n        if sum+nums[i]>sum\
    \ \n        \n            # find the minimum sum possible of the sub array starting\
    \ from the right side of the array and ignoring the current element \n       \
    \     newSum::Int64 = sum+nums[i]\n            \n            # if the minimum\
    \ sum possible of the sub array starting from the right side of the array is smaller\
    \ than the current sum then update the current sum and ignore the current element\n\
    \            if newSum<sum\n                sum = newSum\n            end\n  \
    \          \n            # if the minimum sum possible of the sub array starting\
    \ from the right side of the array is greater than the current sum then ignore\
    \ the current element\n            elseif newSum>sum\n                continue\n\
    \            end\n        elseif sum+nums[i]<sum\n            \n            #\
    \ find the minimum sum possible of the sub array starting from the right side\
    \ of the array and ignore the current element\n            newSum::Int64 = sum+nums[i]\n\
    \            \n            # if the minimum sum possible of the sub array starting\
    \ from the right side of the array is smaller than the current sum then update\
    \ the current sum and ignore the current element\n            if newSum<sum\n\
    \                sum = newSum\n            end\n            \n            # if\
    \ the minimum sum possible of the sub array starting from the right side of the\
    \ array is greater than the current sum then ignore the current element\n    \
    \        elseif newSum>sum\n                continue\n            end\n      \
    \  end\n    end\n    return sum\nend\n</cell>\n<text>\nFind the maximum subarray\
    \ of size k which sums to n.\nThe function should return an array containing one\
    \ integer which is the max sum of a subarray of size k which sums to n. \nThe\
    \ function is defined as:", "    if length(nums) <= 1\n        return nums[end]\n\
    \    end\n    \n    min_sum = minimum(subArraySum(nums[1:end-1]))\n    if min_sum\
    \ == 0 && length(nums) > 1\n        min_sum = minimum(subArraySum(nums[2:end]))\n\
    \    end", "    n = length(nums)\n    if n < 1 \n        return -1\n    end",
  "    if nums == []\n        return 0\n    \n    min = math.inf\n    index = 1\n\
    \    while index <= length(nums)\n        sum = sumSubArraySum(nums, index, length(nums))\n\
    \        if sum < min\n            min = sum\n        elseif sum == min\n    \
    \        index = index + 1 \n        else\n            index = 1\n        end\n\
    \    end\n    min\nend\n</code>\n<|/ a |>\n<| a |>\nHere's a recursive approach\
    \ which seems to me to be the simplest to implement and understand:\n<code>",
  "    sum::Int64 = 0\n    for i in nums\n        sum += i\n    end\n    return sum\n\
    end\n</cell>\n<text>\nSolution\nWe could now solve the problem by writing a custom\
    \ function with the minimum subArray sum function written above. The function\
    \ signature will look like this:", "    i, s = 0, zero(0)\n    for el in nums\n\
    \        if el > 0 \n            s += el\n        else\n            s += i\n \
    \       i += 1\n    end\n    return s\nend\n</cell>\n<code language=julia-1.5>\n\
    @time minSubArraySum([2, 3, 4, 1, 2, 4])\n</cell>\n<code language=julia-1.5>\n\
    @time minSubArraySum([-1, -2, -3])\n</cell>\n<text>\nExercise\nFor each of the\
    \ five exercises, solve the algorithm for a different size vector and check its\
    \ correctness. How long does the algorithm take to run for a vector of size $10^5$\
    \ and $10^6$? Can you tell by how much each run takes compared to the run that\
    \ took so long for the smaller vector?", "    \"\"\"\n    Given a vector of integers\
    \ nums, find the minimum sum of any non-empty sub-vector\n    of nums.\n    Example\n\
    \    >>> minSubArraySum([2, 3, 4, 1, 2, 4])\n    1\n    >>> minSubArraySum([-1,\
    \ -2, -3])\n    -6\n    \"\"\"\n    function minSubArraySum(nums::Vector{Int64})\n\
    \        return sum(nums[:]) \n    end", "    \n    minSum = -Inf \n    for num\
    \ in nums do \n        minSum = min(minSum, num + num) \n    end\n    return minSum\n\
    end\n</cell>\n<code language=julia-1.3>\nminSubArraySum([2, 3, 4, 1, 2, 4])\n\
    </cell>\n<text>\nQuestion 1.3: Which of the following is faster, min or max?",
  "    if len(nums)==0 return 0\n    minimum=nums[0]\n    for i in nums[2:end-1] minimum+=i\n\
    \    return minimum\nend \n</cell>\n<text>\nProblem 10\nGiven two arrays of ints,\
    \ find the length of the smallest common prefix of all elements.", "    \"\"\"\
    \n    This function returns the minimum sum of a sub-array of the \n    input\
    \ vector, nums.", "    return sum(nums)\nend", "    \n    for i in nums\n    \
    \    \n        if i == 0\n        \n            minSum = i\n            \n   \
    \     else \n        \n            if i + minSum > i\n            \n         \
    \       minSum = i + 1\n            \n            else \n            \n      \
    \          minSum = i\n            \n            end\n        end\n        \n\
    \    end\n    \n    return minSum\nend\n</cell>\n<code language=julia-1.0>\nminSubArraySum([2,\
    \ 3, 4, 1, 2, 4])\n</cell>\n<code language=julia-1.0>\nminSubArraySum([-1, -2,\
    \ -3])\n</cell>\n<code language=julia-1.0>\n# Using a while loop", "    \"\"\"\
    \n    Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n\
    \    of nums.\n    Example\n    >>> minSubArraySum([2, 3, 4, 1, 2, 4])\n    1\n\
    \    >>> minSubArraySum([-1, -2, -3])\n    -6\n    \"\"\"\n    minimum = nums.min()\n\
    \    idx = nums.indexof(minimum)\n    minimums = Vector{Int64}()\n    minimums.push(minimum)\n\
    \    for i in nums[idx+1:end]\n        if minimums.last == minimum + i\n     \
    \       minimums.push(minimum + i)\n        else\n            return minimum\n\
    \        end\n    end\n    return minimum\nend\n\"\"\"\n    Given a vector of\
    \ integers nums, find the minimum sum of any non-empty sub-vector\n    of nums.\n\
    \    Example\n    >>> minSubArraySum([2, 3, 4, 1, 2, 4])\n    1\n    >>> minSubArraySum([-1,\
    \ -2, -3])\n    -6\n    \"\"\"", "    \n    min = Int.max(nums[0])\n    \n   \
    \ for a in nums do \n        if a > min then \n            min = a \n        end\n\
    \    end\n    min\nend\n</cell>\n<text>\nWrite a function which accepts a vector\
    \ of integers (nums) and finds the maximum sum of any non-empty sub-vector of\
    \ nums.", "    len = length(nums)\n    if len == 0 then return 0 end\n    if len\
    \ == 1 then return nums[0] end", "    len = length(nums)\n    if len == 0 \n \
    \       throw(ArgumentError(\"Invalid array length\"))\n    end\n    local cur_min\
    \ = nums[1]\n    for i = 2:len\n        local current_sum = sum(nums[2 : i])\n\
    \        if current_sum < cur_min\n            cur_min = current_sum\n       \
    \ end\n    end\n    return cur_min\nend\n</cell>\n<code language=julia-0.5>\n\
    minSubArraySum([4, -5, 6, -3, 1, -2, -1])\n</cell>\n<text>\nGreat! Now let's use\
    \ our minSubArraySum function to find the minimum number in a vector!", "    minSum\
    \ = Int.max\n    for k in nums\n        if k == 0\n            continue\n    \
    \    if k < 0\n            continue\n        minSum = min(minSum, k)\n    end\n\
    \    minSum\nend\n</cell>\n<text>\nWe will now implement a function which determines\
    \ whether a given array contains only 1s or not. \nNote that we will only use\
    \ vectorized code for this function (i.e. no explicit loops). \nThis will be a\
    \ benefit for our overall performance.", "    # Write your code in Julia 0.5.1\n\
    \    k = nums[1]\n    ans = k\n    for j in 2:length(nums)\n        ans = max(ans,\
    \ k + nums[j])\n        k = ans\n    end\n    return ans\nend\n</cell>\n<text>\n\
    Part III: Implementing QuickSelect\nImplement the function quickSelect() that\
    \ takes as input a sorted vector nums and an integer k, and returns kth smallest\
    \ element of nums. It is assumed that all values in nums are unique.", "    minArraySum\
    \ = 0\n    for x in nums\n        minArraySum = minArraySum + x\n    end", " \
    \   for i in length(nums):-1:1\n        sum = sum(nums[i:end])\n        if sum\
    \ < 0\n            return sum\n        elseif sum == 0\n            return abs(nums[i])\n\
    \        else\n            return min((sum, abs(nums[i])))\n        end\n    end\n\
    \    return 0\nend\n</cell>\n<code language=julia-0.6>\nminSubArraySum([2, 3,\
    \ 4, 1, 2, 4])\n</cell>\n<code language=julia-0.6>\nminSubArraySum([-1, -2, -3])\n\
    </cell>\n<text>\nPart 2\nUsing the same method, find the minimum sum of any non-negative\
    \ integer sub-array of nums.\nExample\nminSubArraySum([2, 3, 4, 1, 2, 4])\nminSubArraySum([-1,\
    \ -2, -3])\nminSubArraySum([4, 0, 1, 2])\nminSubArraySum([7, 4, 3, 1])\nminSubArraySum([2,\
    \ 2, 2])\nminSubArraySum([2, 2, 2, 1])\nminSubArraySum([0, 3, 2])\nminSubArraySum([1,\
    \ 3, 2, 1, 2, 3])\nminSubArraySum([0, -2, -5, -4, -3, -6, -7, -8])\nminSubArraySum([10,\
    \ 20, 30, 10, 20, 20, 20, 20])\nminSubArraySum([10, 20, 30, 10, 20, 20, 20, 20])\n\
    minSubArraySum([-10, -20, -30, -10, -20, -20, -20, -20])\nminSubArraySum([-5,\
    \ -10, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20,\
    \ -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20,\
    \ -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20,\
    \ -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20,\
    \ -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20,\
    \ -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20,\
    \ -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20,\
    \ -20, -20, -20, -20, -20, -20, -", "    \n    nums = nums[2:end] #O(n) but better\
    \ than O(n)\n    \n    #O(n) solution\n    minSum = nums[1]\n    for i in 2:length(nums)\n\
    \        if nums[i-1] > nums[i]\n            minSum = min(nums[i], minSum)\n \
    \       else\n            minSum = min(nums[i-1], minSum)\n        end\n    end\n\
    \    return minSum\nend\n</cell>\n<code language=julia-1.5>\nusing BenchmarkTools",
  "    sum = 0\n    for a in nums\n        sum += a\n    end", "    \n    if length(nums)\
    \ < 1 \n        throw(ArgumentError(\"Vector not long enough\")) \n    end\n \
    \   \n    if length(nums) == 1 \n        return nums[0] \n    end", "    if isempty(nums)\
    \ \n        error(\"Subset sum to zero not possible\") \n    end\n    lengthOfSubArray\
    \ = zeros(Int, length(nums))\n    sumOfSubArray = zeros(Int, length(nums))\n \
    \   for i in 1:length(nums)\n        if nums[i] <= 0\n            error(\"Subset\
    \ sum cannot contain negative numbers\")\n        end\n        lengthOfSubArray[i]\
    \ = 1\n        sumOfSubArray[i] = nums[i]\n    end\n    for i in 1:length(lengthOfSubArray)\n\
    \        if sumOfSubArray[i] < sumOfSubArray[i - 1] \n            return sumOfSubArray[i]\n\
    \        end\n        lengthOfSubArray[i] = lengthOfSubArray[i - 1] + 1\n    \
    \    sumOfSubArray[i] = nums[i - 1] + nums[i]\n    end\n    return sumOfSubArray[end]\
    \ \nend", "    if nums.is_empty() \n        return 0 \n    min = nums.last \n\
    \    for x in nums[2:end] \n        min = min + x \n    min = min + nums[1] \n\
    \    return min \nend", "    minSubArraySum = Int64(0)\n    \n    function minSubArraySumHelper(nums,\
    \ minSubArraySum, minSubArray)::Int64 \n        if length(nums) == 0 \n      \
    \      return minSubArraySum\n        elseif length(nums) == 1 \n            return\
    \ minSubArraySum + nums[0]\n        end\n        \n        var minSum = Int64(Inf)\n\
    \        var minSubArray = Int64(0)\n        for elem in nums\n            if\
    \ elem < minSum\n                minSum = elem\n                minSubArray =\
    \ elem\n            elseif elem >= minSum\n                minSubArray += elem-minSum\n\
    \            end\n        end\n        minSubArraySumHelper(nums[1:end-1], minSubArraySum+minSubArray,\
    \ minSubArray)\n    end\n    \n    minSubArraySumHelper(nums, Int64(Inf), Int64(Inf))\n\
    \    return minSubArraySum\nend\n</cell>\n<code language=julia-1.0>\nminSubArraySum([2,\
    \ 3, 4, 1, 2, 4])\n</cell>\n<code language=julia-1.0>\nminSubArraySum([-1, -2,\
    \ -3])\n</cell>\n<code language=julia-1.0>\nminSubArraySum([-6, -2, -3])\n</cell>\n\
    <code language=julia-1.0>\nminSubArraySum([-6, -3, -6, -6, -6])\n</cell>\n<code\
    \ language=julia-1.0>\nminSubArraySum([-6, -7, -3, -6, -6, -6])\n</cell>\n<code\
    \ language=julia-1.0>", "    \n    nums = nums[:]\n    \n    sum = 0\n    \n \
    \   lenNum = length(nums)\n    \n    \n    for num in nums\n        if num !=\
    \ 0\n            sum += num\n        else\n            sum -= num\n        end\n\
    \    end\n    \n    \n    \n    return sum\nend", "    # Your code goes here\n\
    \    return nums.sum\nend\n</cell>\n<text>\nProblem 8 (60 pts)\nA common application\
    \ of $k$-means is to determine the optimal number of clusters for your dataset.\
    \  Here are a few things you might want to try, in decreasing order of difficulty:",
  "    if nums == [] \n        return 0 \n    \n    left = minSubArraySum(nums[1:end-1])\
    \ \n    right = minSubArraySum(nums[2:end]) - nums[1] - nums[2] + nums[1] - nums[3]\n\
    \    return left if left <= right else right \nend \n</cell>\n<code language=julia-1.6>\n\
    # Solution 2", "    minimum_so_far = 0\n    for n in nums\n        minimum_so_far\
    \ += n \n    end\n    return minimum_so_far\nend\n</cell>\n<code language=julia-1.6>",
  "    \n    sum = 0\n    \n    for x in nums\n        \n        sum += x\n    end\n\
    \    \n    return sum\nend\n</cell>\n<code language=julia-1.5>\n# %load solutions/minSubArraySum.jl",
  "    min = length(nums)\n    for i in 1:length(nums)\n        min = min if nums[i]\
    \ == 0 else min(nums[i], min - nums[i])\n    end\n    min\nend\n</cell>\n<text>\n\
    Q2. What is the minimum sum of a non-empty sub-vector of nums?\nExample 1:\nInput:\
    \ nums = [2,4,1,2,4]\nOutput: 1\nExplanation: The minimal sum is 1+2+4 = 6\nExample\
    \ 2:\nInput: nums = [-1,-2,-3]\nOutput: -6", "    minSubArraySum = minimum(sum(nums))\n\
    \    for i=1:length(nums)\n        if nums[i]-minSubArraySum > 0 \n          \
    \  minSubArraySum = nums[i]\n        end\n    end\n    return minSubArraySum\n\
    end\n</cell>\n<text>\nRecursive Solution"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
