name: HumanEval_57_monotonic
language: jl
prompt: "\"\"\"Return true is vector elements are monotonically increasing or decreasing.\n\
  \    >>> monotonic([1, 2, 4, 20])\n    true\n    >>> monotonic([1, 20, 4, 10])\n\
  \    false\n    >>> monotonic([4, 1, 0, -10])\n    true\n    \"\"\"\nfunction monotonic(l::Vector{Int64})::Bool\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = monotonic;\n\t@test(candidate([1,\
  \ 2, 4, 10]) == true)\n\t@test(candidate([1, 2, 4, 20]) == true)\n\t@test(candidate([1,\
  \ 20, 4, 10]) == false)\n\t@test(candidate([4, 1, 0, -10]) == true)\n\t@test(candidate([4,\
  \ 1, 1, 0]) == true)\n\t@test(candidate([1, 2, 3, 2, 5, 60]) == false)\n\t@test(candidate([1,\
  \ 2, 3, 4, 5, 60]) == true)\n\t@test(candidate([9, 9, 9, 9]) == true)\nend\n"
completions: ["    n = length(l)-1\n    if n == 0\n        return true\n    end\n\
    \    sort(l)\n    return isincreasing(l) && isdecreasing(l)\nend", "    # check\
    \ for increasing\n    if l.last < l.first\n        l.first = l.first\n    end\n\
    \    # check for decreasing\n    if l.first > l.last\n        l.last = l.last\n\
    \    end\n    for v in l\n        if v < l.first\n            return false\n \
    \       end\n        if v > l.last\n            return true\n        end\n   \
    \ end\n    return true\nend", "    if len(l) < 2\n        return true\n    lmin\
    \ = minimum(l)\n    lmax = maximum(l)\n    return lmin >= lmax\nend\n</cell>\n\
    <code language=julia-1.0>\n#export", "    \n    return (l.length>1 && (l[2]==0\
    \ || l[1]==0))\nend\n</cell>\n<text>\nSome of the algorithms implemented in Julia\
    \ require some knowledge of the structure of the domain. These methods will only\
    \ work where this structure is known. If the structure is not known, then the\
    \ algorithm may fail.", "    if length(l)==0\n        true\n    elseif l[1]<l[2]\n\
    \        true\n    elseif l[1]==l[2]\n        if l[1]>l[3]\n            true\n\
    \        else\n            false\n        end\n    else\n        false\n    end\n\
    end\n</code>\n<|/ a dscore=3 tags=julia,algorithm |>\n<| c |>\nYour solution is\
    \ pretty good, but it can be done with much less code: `(first(l) < last(l)) ||\
    \ all(l[i] < l[i+1] for i=2:end)`. Or just `all(l[i] <= l[i+1] for i=2:end), or\
    \ l[1] <= l[2] <= l[3]`. You can also use `<=` instead of `<`. Same for other\
    \ comparisons.\n<|/ c |>\n<| c |>\nYes that is a better option, I had just started\
    \ learning Julia, and my prof always uses the \"Julia way\" which is why I went\
    \ down this route.\n<|/ c |>\n<| c |>\nGreat solution! Can you please share your\
    \ solution for \"if any elements between the first and second element are greater\
    \ or equal than the third element\" ?\n<|/ c |>\n<| c |>\nThis works great for\
    \ the monotonic case in my question. But when one looks for a way to extend the\
    \ monotonic case to other monotonic cases, my problem becomes more complicated.\
    \ I cannot simply change the <= to <, as that would break the monotonic case.\n\
    <|/ c |>\n<| a tags=julia,algorithm |>\nA solution that uses iterators and does\
    \ not allocate any more memory:\n<code>", "    if l.length == 1\n        return\
    \  (l.head < l.last)\n    else\n        if l.head > l.last\n            return\
    \ true\n        else\n            return false\n    end\nend\n\"\"\"Return a new\
    \ vector that is the negative of the given vector, in-place. \nIf the vector is\
    \ empty, return an empty vector.\n    >>> v1 = Vector{Int}([4, 2, 10])\n    >>>\
    \ negate!(v1)\n    >>> v1\n    Vector{Int}([-2, -2, -2])\n\"\"\"", "    #sort\n\
    \    l = sort(l)\n    return all(diff(l)>0)\nend\n</cell>\n<code language=julia-0.6>\n\
    println(\"Vector\")\n</cell>\n<code language=julia-0.6>\nprintln(\"Vector{Int64}\"\
    )\n</cell>\n<code language=julia-0.6>\nprintln(\"Vector{Int64}\") \nprintln(\"\
    Vector{Int64} is $(monotonic([1, 2, 4, 20]))\")\nprintln(\"Vector{Int64} is $(monotonic([1,\
    \ 20, 4, 10]))\")\nprintln(\"Vector{Int64} is $(monotonic([4, 1, 0, -10]))\")\n\
    </cell>\n<code language=julia-0.6>\nprintln(\"Vector{Int64} is $(monotonic([4,\
    \ 1, 20, -10]))\")\n</cell>\n<text>\nExercise\nWhat is wrong with this function?",
  "    l.sort()\n    return all(i > l[i-1] for i in l)\nend", "    l = sort(l)\n \
    \   return l[1] <= l[2] or l[2] <= l[3]\nend", "    l = sort(l)\n    for i in\
    \ 2:length(l)-1\n        if l[i-1] > l[i]\n            return false\n        if\
    \ l[i-1] < l[i]\n            return true\n    end\n    return true\nend\n</cell>\n\
    <code language=julia-1.5>\n# Monotonicity check\nmonotonic([2, 3, 4, 1])\n</cell>\n\
    <code language=julia-1.5>\n# Testing monotonic function\nprintln(monotonic([2,\
    \ 3, 4, 1]))\nprintln(monotonic([1, 20, 4, 10]))\nprintln(monotonic([4, 1, 0,\
    \ -10]))\n</cell>\n<text>\nLinear Regression\nLinear regression is used to describe\
    \ the relationship between two variables.  In this case we are trying to find\
    \ the relationship between an individual's height and weight.  Here are the steps:",
  "    mult = 1 \n    last = 0\n    for x in l \n        if x == last\n          \
    \  mult = mult + 1\n        else \n            last = x\n            mult = 1\n\
    \        end\n    end\n    return mult <= 2\nend\n</cell>\n<text>\nThe next cell\
    \ defines the function my_sort() which implements the sorting algorithm for sorting\
    \ a list of integers:", "    return (l.length() == 1) || (l[end-1] <= l[end])\n\
    end \n</cell>\n<code language=julia-1.5>\n@assert monotonic([1, 2, 3]) \n@assert\
    \ !monotonic([3, 2, 1]) \n@assert !monotonic([3, 1, 2]) \n@assert monotonic([3,\
    \ 2, 4, 1]) \n@assert monotonic([1, 2, 4, 20])\n</cell>\n<text>\n4.4 Sorting\n\
    The Julia sorting functions are implemented as generic (parametric) functions.\
    \  They take a type parameter, A, which denotes the type of element being sorted.\
    \  They will produce a sorted version of a collections of elements having a particular\
    \ type, provided they can be compared element-wise.  We will see how to define\
    \ our own functions which we can then call on arrays or collections of elements\
    \ of a particular type.", "    n=length(l)\n    for i in 2:n\n        if l[i-1]\
    \ > l[i]\n            return false\n    end\n    return true\nend", "    l = unique([l])\n\
    \    for i in 2:length(l)\n        if l[i-1] < l[i] or l[i-1] == l[i] and i >\
    \ 1\n            return false\n        end\n    end\n    return true\nend\n\"\"\
    \"\nReturn true if a vector is monotonic, ie, no element is less than or equal\
    \ to a previous element.\n    \n    >>> monotonic([1,2,3])\n    true\n    >>>\
    \ monotonic([1,3,2])\n    false\n    >>> monotonic([1,3,3])\n    true\n    >>>\
    \ monotonic([10,2,1,3,5])\n    false\n    >>> monotonic([10,2,1,3,5])\n    false\n\
    \    >>> monotonic([10,2,1,3,5])\n    false\n\"\"\"", "    for i in 1:length(l)\n\
    \        if l[i] > l[i-1]\n            return True\n        else if l[i] < l[i-1]\n\
    \            return False\n        end\n    end\n    return false\nend\n</code>\n\
    <|/ a tags=julia |>\n<| a tags=julia |>\nThis is a classic example of counting\
    \ sort. There are many ways to implement it in Julia, the most popular is by using\
    \ sortperm:\n<code>\njulia> sortperm([1,5,4,2])\n1-element Array{Int64,1}:\n 1\n\
    </code>\nThis produces random permutation, so you can shuffle your array first\
    \ to obtain desired result:\n<code>\njulia> shuffle([1,5,4,2])\n5-element Array{Int64,1}:\n\
    \ 1\n 4\n 5\n 2\n 3", "    lmin =  minimum(l)\n    lmax = maximum(l)\n    return\
    \ !((lmin > lmax) & (lmin < -lmax))\nend\n</cell>\n<code language=julia-1.5>",
  "    l = sort!(l) \n    l == first(l) || l == last(l) || l == maximum(l)\nend",
  "    \n    i = sort(l)\n    j = 1\n    for k in i:\n        while j > k and l[j-1]\
    \ == l[k-1]\n            j += 1\n        if j > k\n            return false\n\
    \    return true\nend", "    if length(l)==0 \n        return true\n    \n   \
    \ prev = NaN\n    for i in 1:(length(l)-1)\n        if l[i] > prev \n        \
    \    return true\n        prev = l[i]\n    end\n    return false\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"\nCompute a rolling average. Supports different\
    \ window sizes.\n\"\"\"", "    len = length(l) \n    if len == 0 \n        return\
    \ true \n    el = first(l) \n    prev = 0\n    for v in tail(l) \n        if v\
    \ < el \n            prev := v \n            el := first(l) \n        else \n\
    \            if v > el \n                true \n            elseif prev >= v \n\
    \                false \n            else \n                prev := v \n     \
    \           el := first(l) \n            end\n        end\n    end\n    return\
    \ true\nend", "    return any(l .< l[end - 1]) \nend", "    if issorted(l)\n \
    \       true\n    else\n        false\n    end\nend\n</cell>\n<code language=julia-1.0>",
  "    if isnan(l) || l==[] || l==0\n        return true\n    end\n    l = sort(l)\n\
    \    return ((l[1]-l[0] <= 0) and (l[2]-l[0] <= 0) and (l[3]-l[0] <= 0))\nend",
  "    l = sort(l)\n    length(l) == 0 || l[1] == 0 || l[l[1] - 1] != l[l[2] - 1]\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a |>\nOne can also use .head and .tail of\
    \ the list to check if list element is monotonically increasing\n<code>", "  \
    \  if length(l) == 1 then return true \n    else if l[1] < l[0] then return false\
    \ \n    else return true \nend ", "    if isnan(l[1]) || isnan(l[end])\n     \
    \   return false\n    end\n    \n    if l[1] <= l[end]\n        return true\n\
    \    end\n    \n    if l[1] >= l[end]\n        return false\n    end\n    \n \
    \   return monotonic(subset(l, 1, end-1))\nend\n</cell>\n<text>\nSubset an array",
  "   return(all(l[2:end] .<= l[1:end-1]))\nend\n</cell>\n<text>\nWe will now run\
    \ this function to verify that it works as expected:", "    !isfinite(l) || isnan(l)\
    \ || all(l[i+1] < l[i] for i in 2:length(l))\nend\n</cell>\n<text>\nFor performance\
    \ reasons, we only want to call monotonic once per vector rather than call it\
    \ for every element.  This is why we cache the value of monotonic when it is called:",
  "    l = sort(l)\n    return l[1] < l[2]\nend\n</cell>\n<text>\nExercise\nWrite\
    \ a function that accepts a vector of monotonically increasing numbers and returns\
    \ true if the vector contains the numbers 1, 2, and 3.", "    m = length(l) -\
    \ 1\n    for idx in range(m) do \n        if l[idx] < l[idx+1] then \n       \
    \     return false \n        else \n            return true \n    end \n    return\
    \ false \nend ", "    if length(l) <= 1 \n        true\n    else \n        sort(l)\
    \ == l \n    end\nend\n</cell>\n<code language=julia-0.6>\n?sort\n</cell>\n<code\
    \ language=julia-0.6>", "    low = minimum(l)\n    high = maximum(l)\n    diff\
    \ = high - low\n    return diff >= 0 || low == 0 && high == 0\nend\n</cell>\n\
    <code language=julia-1.5>", "    m = maximum(l)\n    r = minimum(l)\n    return\
    \ r < m \nend \n</cell>\n<text>\nExercise: Write a function that returns the number\
    \ of positive elements in an array.", "    if length(l) < 3 \n        return true\n\
    \    \n    if l[1] <= l[2] \n        return false\n    \n    if l[1] <= l[3] \n\
    \        return true\n    \n    if l[2] <= l[3] \n        return false\n    \n\
    \    if l[1] <= l[2] \n        return true\n    \n    if l[3] <= l[2] \n     \
    \   return false\n    \n    if l[1] <= l[3] \n        return true\n    \n    if\
    \ l[2] <= l[3] \n        return false\n    \n    return true\nend", "    len =\
    \ length(l) \n    return any(a>b for a in l[1:len-1], b in l[1:len-1] ) \nend ",
  "    x = l[1]\n    for i in 2:length(l) do \n        if l[i] < x \n            x\
    \ -= 1\n        else \n            if l[i] > x \n                x += 1\n    \
    \        end\n        end\n    end\n    return x == 1\nend", "    return all((i\
    \ > j) and (i < j-1) for (i,j) in zip(l[:-1],l[1:]))\nend", "    return all(i>j\
    \ for (i,j) in enumerate(l))\nend\n</cell>\n<text>\nExercise: Find the index of\
    \ the element in the sorted array which has the smallest value", "    if length(l)\
    \ == 1\n        return true\n    end", "    l = copy(l)\n    l.sort()\n    if\
    \ l.first > l.last\n        return false\n    end\n    return true\nend\n</cell>\n\
    <code language=julia-0.5>\n@doc @testset \"Test monotonic\"\n@testset \"Test monotonic\"\
    \ begin\n    a = Float64[]\n    b = Float64[]\n    for e in [1,2,3,4]\n      \
    \  push!(a, e)\n        push!(b, e)\n    end\n    @test monotonic(a) == true\n\
    \    @test monotonic(b) == false\n    @test monotonic([1,1,1]) == true\n    @test\
    \ monotonic([1,1,0]) == false\n    @test monotonic([1,0,1,0]) == true\n    @test\
    \ monotonic([1,1,0]) == true\n    @test monotonic([1,1,0,1,0]) == false\n    @test\
    \ monotonic([1,1,0,1]) == true\nend\n</cell>\n<text>\nIllustration\nGiven a vector\
    \ X = [x_1, ..., x_N] and another vector Y = [y_1, ..., y_N] where x_i and y_i\
    \ are distinct and i \\in [1,...,N], \nthe function should return false if there\
    \ exists any pair of elements x_i, y_i such that the Euclidean distance of x_i\
    \ and y_i is less than or equal to some threshold T.", "    if length(l) < 2 \n\
    \        true\n    else\n        l1 = sort(l)\n        if l1[end] > l1[1]\n  \
    \          true\n        else\n            false\n        end\n    end\nend\n\
    </cell>\n<text>\nTest on Iris Dataset", "    # Check for NaN first as NaN sorts\
    \ after all other values\n    nanflag = isnan(l)\n    l = l.data\n    if isnan(flag)\n\
    \        flag = nanflag\n        l = l.data\n        l = l.sort()\n    else\n\
    \        l = l.sort()\n    end\n    l = sort(l)\n    flag =  l.data[end] == l.data[1]\n\
    \    return flag\nend", "    \"\"\"\n    monotonic(l::Vector{Int64})::Bool\n \
    \   Check if vector elements are monotonically increasing or decreasing.\n   \
    \ \"\"\"\n    l = vec(l)\n    len = length(l)\n    prev = 0\n    for i in 1:len\n\
    \        if l[i] > prev\n            return false\n        elseif l[i] < prev\n\
    \            return true\n        end\n        prev = l[i]\n    end\n    return\
    \ true\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nJust to clarify -- this is just\
    \ like `@monotonic` except that it returns `true` when all elements are negative.\
    \ `@monotonic([1,20,4,10,-1])` will return `true`, whereas `@monotonic([1,20,4,10,0])`\
    \ will return `false`.\n<|/ c |>\n<| a dscore=2 tags=julia,algorithm |>\nFor Julia\
    \ versions >= 0.4\n<code>\njulia> using BenchmarkTools", "    for i = 2:length(l)\n\
    \        diff = abs(l[i] - l[i-1])\n        if diff <= 1\n            return true\n\
    \        end\n    end\n    return false\nend\n</cell>\n<text>\nHere are a few\
    \ examples of its use:", "    (l[2]-l[1])<=0 && (l[1]-l[0])<=0\nend", "    return\
    \ any(l .<= last(l)) \nend\n</cell>\n<code language=julia-1.5>\n# Many vector\
    \ types have the method sort!() but that doesn't work with Float64s.", "    l\
    \ = sort(l)\n    last = l[1]\n    for x in l[2:end]\n        if x != last\n  \
    \          return false\n        last = x\n    return true\nend \n</code>\n<|/\
    \ a |>\n<| c |>\nThis doesn't handle duplicates. It would return `true` for `monotonic([1,\
    \ 20, 3, 10, 20])`\n<|/ c |>\n<| a tags=julia |>\nI think the best way is to use\
    \ sort(l) followed by last(l). \nIf your vector l has only unique numbers, then\
    \ sort(l) will put them in order, while last(l) will give you the value of the\
    \ last number of the sorted vector. \nThis can be implemented in Julia as follows:\
    \ \n<code>", "    if length(l) < 2 \n        return true\n    if l[1] < l[2] \n\
    \        return true\n    return false\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Return true if the vector elements are monotonically increasing or decreasing.\n\
    >>> monotonic([1, 2, 4, 20])\ntrue\n>>> monotonic([1, 20, 4, 10])\nfalse\n>>>\
    \ monotonic([4, 1, 0, -10])\ntrue\n\"\"\"", "    \"\"\"\n    Determine if the\
    \ elements of a vector are monotonically\n    increasing or decreasing. Elements\
    \ with equal value are\n    considered to be equal in order.\n    \"\"\"\n   \
    \ l = copy(l)\n    @inbounds \n    local i = 0\n    local min = -Inf\n    local\
    \ max = Inf\n    while i < size(l)\n        if l[i] < min then\n            min\
    \ = l[i]\n        end\n        if l[i] > max then\n            max = l[i]\n  \
    \      end\n        i += 1\n    end\n    if min < Inf and max > -Inf then\n  \
    \      return true\n    else\n        return false\n    end\nend\nend\n</code>\n\
    A couple of notes on my solution:", "    lmin = minimum(l)\n    lmax = maximum(l)\n\
    \    if lmin > lmax\n        true\n    elseif lmin == lmax\n        false\n  \
    \  else\n        if lmin < -1\n            false\n        elseif lmin == -1\n\
    \            true\n        else\n            if lmax > 1\n                true\n\
    \            else\n                if lmax == 1\n                    false\n \
    \               else\n                    true\n                end\n        \
    \    end\n        end\n    end\nend\n</code>\n<|/ a tags=julia,arrays,time-complexity,performance,algorithm\
    \ |>\n<| a tags=julia,arrays,time-complexity,performance,algorithm |>\nA little\
    \ bit of metaprogramming will make this solution very elegant, and it also has\
    \ the benefit of being extensible.\n<code>", "    # Sort and check monotonicity\
    \ \n    if minimum(l) == maximum(l) \n        return true \n    \n    # Compare\
    \ and swap if different \n    diff = maximum(l) - minimum(l) \n    \n    for i\
    \ \u2208 1 : l \n        if diff \u2260 0 \n            if l [i] > l [i - 1] +\
    \ diff \n                l [i - 1], l [i] = l [i], l [i - 1] + diff \n       \
    \     end \n        end \n    end \n    \n    return diff == 0 \nend \n</cell>\n\
    <code language=julia-0.6>\n\"\"\"Return true if a vector elements are non-decreasing.\n\
    \    >>> non_decreasing([5, 2, 1, 4, 3, -2])\n    false\n    >>> non_decreasing([5,\
    \ 4, 3, 2, 1])\n    true\n    >>> non_decreasing([5, 4, 3, 1])\n    false\n  \
    \  \"\"\"", "    if length(l) == 0 || all(i < j for (i, j) in zip(l, l[1:]))\n\
    \        return true\n    end\n    \n    head_ind = headindex(l)\n    headval\
    \ = l[head_ind]\n    headval = headval - headval % 2 != 0\n    \n    tail_ind\
    \ = tailindex(l)\n    tailval = l[tail_ind]\n    tailval = tailval - tailval %\
    \ 2 != 0\n    \n    return headval == tailval && monotonic(l[end-1:end])\nend\n\
    </cell>\n<code language=julia-1.5>\n\"\"\"\nReturn a list of all elements in a\
    \ vector, except those in the excluded set.\n\"\"\"", "    return l[1] < l[2]\n\
    end\n</cell>\n<code language=julia-1.3>\n\"\"\"Return elements of the given vector\
    \ in order.\n    >>> monotonic([1, 3, 5, 10, 2, 9, 10, 6, 5, 7])\n    [1, 3, 5,\
    \ 10, 2, 9, 10, 6, 5, 7]\n    >>> monotonic([1, 3, 10, 9, 3, 6, 9, 1, 7, 4, 0])\n\
    \    [1, 3, 10, 9, 3, 6, 9, 1, 7, 4, 0]\n\"\"\"", "    return length(l) > 1 &&\
    \ all(l[end] < l[begin] for begin, end in pairs(l))\nend ", "    for i in l:\n\
    \        if i > max(i+1,0)\n            return false\n    return true\nend", "\t\
    len = length(l)\n\tsorted = sort(l)\n\treturn (sorted[1] <= sorted[len-1]) &&\
    \ (sorted[len-2] >= sorted[1]) \nend\n\"\"\"Return the value of a single element\
    \ in a vector.\n    \n    >>> monotonic([1, 2, 4, 20])\n    1\n    >>> monotonic([1,\
    \ 20, 4, 10])\n    -20\n    >>> monotonic([4, 1, 0, -10])\n    0\n    \"\"\"",
  "    n = length(l) \n    for i = 2:n\n        if l[i-1] < l[i] and l[i-1] > l[i]\n\
    \            return false \n        else if l[i] > l[i-1] and l[i] > l[i-1]\n\
    \            return false \n        else return true \n    endfor \n    return\
    \ false \nendfunction \n</code>\n<|/ a dscore=2 tags=julia,arrays,performance,sorting\
    \ |>\n<| a tags=julia,arrays,performance,sorting |>\nI got tired of looking for\
    \ something that doesn't work. So I made this:\n<code>", "    if length(l) <=\
    \ 1\n        return true\n    end\n    \n    first = head(l) \n    for x in tail(l)\n\
    \        if x != first \n            return false\n    end\n    return true\n\
    end\n</cell>\n<code language=julia-1.3>", "    for n in l\n        if n < 0 ||\
    \ (n == 0 && any(n == _ for _ in l))\n            return true\n        else if\
    \ n > 0 || (n == 0 && any(n == _ for _ in l))\n            return false\n    \
    \    end\n    end\n    return true\nend\n</code>\n<|/ a |>\n<| a |>\nI believe\
    \ that you can do it with a comprehension using any\n<code>\nall([i > j for i\
    \ in arr for j in arr])\n</code>\nThis can be generalized to an arbitrary number\
    \ of iterators\n<code>\nall([any([i > j for i in arr]) for j in arr])\n</code>\n\
    <|/ a tags=arrays,julia dscore=2 |>\n<| c |>\n`all(x -> x > 0, arr)` works for\
    \ me, since `all(x -> x > 0, [5, -10, 0])` gives `true`.\n<|/ c |>\n<| c |>\n\
    This doesn't work if you have negative numbers in the array.\n<|/ c |>\n<| c |>\n\
    I suppose it depends what you mean by \"work\". Negative numbers do not satisfy\
    \ the condition `x > 0`, so it will only return `true` for numbers that are greater\
    \ than 0.\n<|/ c |>\n<| c |>\nAh, thanks for that. I didn't pay attention to that\
    \ part. I'll edit my answer.\n<|/ c |>\n<| c |>\nHm, this still seems to return\
    \ true for negative numbers: `all([x > 0 for x in [-10, 5, 0]])`. I'll update\
    \ my answer again.\n<|/ c |>\n<| a dscore=2 tags=arrays,julia |>\nOne option is\
    \ to use Array's comprehension syntax:\n<code>\n[a for a in arr]\n</code>\nOr\
    \ Vector's comprehension syntax:\n<code>\n[v for v in arr]\n</code>\nHowever,\
    \ this would also return empty arrays if arr is empty, so it's not a complete\
    \ solution.\n<|/ a |>\n<| a tags=arrays,julia |>\nYou can use a comprehension\
    \ with the any function. So you end up with\n<code>\nall([any(x -> x > 0, a) for\
    \ a in arr])\n</code>\nThis will be quite slow for a large array, but for small\
    \ arrays it should do exactly what you want.\n<|/ a dscore=2 |>\n<| a tags=arrays,julia\
    \ |>\nThis should do it:\n<code>\njulia> using StatsBase", "   l[1]>l[2]\nend",
  "  if length(l)<=1\n    return true\n  end\n  flag = false\n  for i in l\n    if\
    \ i>l[end] \n      flag = not flag\n    end\n  end\n  return flag\nend\n</cell>\n\
    <text>\nExample\nHere are some vectors drawn from the probability distributions\
    \ used in this notebook:", "    x = minimum(l) \n    y = maximum(l) \n    return\
    \ x <= y \nend\n</cell>\n<code language=julia-0.6>\n## A quick test \n## >>> monotonic([2,\
    \ 1, 2, 3, 3]) \n## true\n## >>> monotonic([3, 2, 1, 2, 3])\n## false\n## >>>\
    \ monotonic([3, 1, 2, 1, 2])\n## true\n## >>> monotonic([3, 1, 2, 1, 3])\n## true\n\
    ## >>> monotonic([3, 1, 2, 1, 4])\n## false\n## >>> monotonic([2, 2, 1, 2, 2])\n\
    ## true\n</cell>\n<text>\nAs with many functions, we can pass any kind of collection\
    \ to our function - whether it be a sequence, vector or array.", "    return (l[1]\
    \ < l[2] || l[2] < l[1]) &&\n        ((l[1] == 0 && l[2] > 0) || (l[1] == 0 &&\
    \ l[2] < 0))\nend\n</cell>\n<code language=julia-0.5>\nusing Test\n@testset \"\
    monotonic test\" begin\n    @testset \"monotonic\" begin\n    @test monotonic([20,\
    \ 1]) == true\n    @test monotonic([2, 0]) == false\n    @test monotonic([1, 1])\
    \ == true\n    @test monotonic([1, 1]) == true\n    @test monotonic([2, 2]) ==\
    \ true\n    @test monotonic([20, 3]) == false\n    end\nend\n</cell>\n<text>\n\
    Binary search\nThe binary search algorithm searches an ordered list (array) of\
    \ values \nusing the \"left\" rule of the binary search. The search is repeated\
    \ \nuntil the value we are searching for is found.", "    \n    return l.length\
    \ < 2 || l.last() > l.first() or l.last() < l.first() \nend", "    # return l.min()\
    \ <= l.max() \n    # return all(l.min <= x) for x in l or all(l.max >= x) for\
    \ x in l\n    return all(l.min <= x) for x in l and all(l.max >= x) for x in l",
  "     r=0\n     for e in l\n       if r==0\n          r=e<r\n       else\n     \
    \     r=e>=r\n       end\n     end\n     return r\nend\n\"\"\"Return true is vector\
    \ elements are monotonically increasing or decreasing.\n    >>> monotonic([1,\
    \ 2, 4, 20])\n    true\n    >>> monotonic([1, 20, 4, 10])\n    false\n    >>>\
    \ monotonic([4, 1, 0, -10])\n    true\n\"\"\"", "    if minimum(l) == minimum(tail(l))\
    \ == maximum(l) == maximum(tail(l)) \n        true\n    else false\n    end\n\
    end\n</code>\n<|/ a dscore=4 |>\n<| a tags=sorting,algorithm,scala,collections,java\
    \ |>\nThis is a scala version with tail and sliding, which is probably the most\
    \ efficient for this problem:\n<code>\ndef monotonic[T: Ordering](xs: Seq[T]):\
    \ Boolean = xs.sliding(2).forall(_.toList == List(x.toList, x.toList.tail)).sorted\n\
    </code>\n<|/ a dscore=4 |>\n<| a dscore=4 tags=sorting,algorithm,scala,collections,java\
    \ |>\nAs a slight variant on's answer, I used the following, which I think is\
    \ more readable.\n<code>\ndef monotonic[T: Ordering](xs: Seq[T]): Boolean = xs.sliding(2).forall(_.toList\
    \ == List(xs.head, xs.tail).sorted)\n</code>\n<|/ a |>\n<| a tags=sorting,algorithm,scala,collections,java\
    \ |>\nIn java8 this could be solved as:\n<code>\nboolean monotonic(List<Integer>\
    \ l){\n    return l.stream().allMatch(i -> l.stream().filter(j -> j == i).count()\
    \ == 2);\n}\n</code>\n<|/ a dscore=4 |>\n<| a dscore=3 tags=sorting,algorithm,scala,collections,java\
    \ |>\n<code>\n/**\n * a sorted list of integers\n * true if all elements are monotonically\
    \ increasing\n */\npublic static boolean isMonotonic(List<Integer> a) {\n    final\
    \ int size = a.size();\n    boolean increasing = true;\n    boolean increasingPrev\
    \ = true;", "    n = length(l)\n    if n < 2 \n        return false\n    else\n\
    \        diff = zeros(Int64, (n-1))\n        diff .= l[1:n] - l[1:n-1]\n     \
    \   return diff .> 0 & diff .< 0\n    end\nend\n</code>\n<|/ a tags=julia,math,algorithm,python\
    \ |>\n<| c |>\nThe \"Julia\" code you provide is much nicer but sadly not portable\
    \ to any machine where the `cffi` package isn't installed, as it's not (yet) part\
    \ of the standard install.\n<|/ c |>\n<| a tags=julia,math,algorithm,python |>\n\
    A Julia version (inspired by Wenzel Ackermann suggestion) using Base.Diff.\n<code>",
  "    if l.length == 1\n        return true\n    elseif l.length == 2\n        return\
    \ l[1] > l[0]\n    else\n        local max = l[1]\n        for v in l[2:end-1]\n\
    \            if max < v\n                max = v\n            else\n         \
    \       return false\n            end\n        end\n        return true\n    end\n\
    end\n</cell>\n<code language=julia-1.6>", "    s = sort(l)\n    if length(l) ==\
    \ 0 || length(s)==0\n        return true\n    else\n        return s[1]<s[length(l)]\n\
    \    end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nWhy `sort` is needed here?\n\
    <|/ c |>\n<| a dscore=1 tags=julia,sorting |>\nI know this question has been answered\
    \ and accepted already, but wanted to provide some additional insight, based on\
    \ my own personal experience with this problem that might be helpful in some cases.\n\
    One approach is to just sort the data with a custom comparator that will always\
    \ return the same value for equal values.\n<code>\njulia> function custom_sortby(x::Vector,\
    \ fn::Function)\n           if length(x)==0 || length(fn(x)) == 0 || any(map(x\
    \ -> false, fn.(x)) )\n               return x\n           else\n            \
    \   return fn(x)[end-1]\n           end\n       end\ncustom_sortby (generic function\
    \ with 1 method)", "        \n    if size(l)==1\n        return true\n    end\n\
    \    \n    if l[end(l)]-l[end(l-1)] > 0\n        return false\n    end\n    \n\
    \    for i in 1:end(l-1)\n        if l[end]-l[i] > 0\n            return false\n\
    \        end\n    end\n    return true\nend\n</cell>\n<text>\n2.3 Design a search\
    \ algorithm to find all the elements in a list within a given distance r of the\
    \ element e\nImplement the function function search(l::Vector{Int64}, e::Int64,\
    \ r::Int64)::Vector{Int64} that takes as input a list of numbers and a single\
    \ element e and returns the list of numbers in l that are within a distance r\
    \ of e. \nExample: \nInput: l = [3, 5, 4, 8, 8, 5, 10], e = 8, r = 2\nOutput:\
    \ [8, 5, 10]\nIt is assumed that l is sorted in non-decreasing order.\nNote: You\
    \ must use the function monotonic to determine whether a given element e is in\
    \ a given list l.\nYou may assume that 0 <= e <= |l| <= 100.", "\tresult=true\n\
    \tfor ii in 1:length(l)\n\t\tv=l[ii]\n\t\tv=v>result?1:0\n\t\tresult=v>0\n\tend\n\
    \treturn result\nend", "    return all(l[i] <= l[i+1] for i in 1:length(l)) \n\
    end\n</cell>\n<text>\nAnd here we define a function to do the computation:", " \
    \   if minimum(l) >= maximum(l) \n    else minimum(l) < maximum(l) \n    end\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Statistics\n</cell>\n<code language=julia-1.5>\n\
    @assert isapprox(monotonic([1]), true)\n@assert isapprox(monotonic([2,4,20,10]),\
    \ false)\n@assert isapprox(monotonic([2,4,20]), true)\n@assert isapprox(monotonic([4,\
    \ 1, 0, -10]), true)\n</cell>\n<text>\nThe @which function is useful for debugging.\
    \ Let's write a function to compute the distance between two points x and y using\
    \ the Euclidean distance formula:\n$$\n\\begin{aligned}\n\\text{dist}(\\vec{x},\
    \ \\vec{y}) &= \\sqrt{\\vec{x}^{2} + \\vec{y}^{2}}\n\\end{aligned}\n$$", "   \
    \ return all(i <= l[i-1] for i in l[1:end-1]) \nend \n</code>\n<|/ a tags=julia,arrays\
    \ |>\n<| c |>\nNice, I like this solution, even if it doesn't directly answer\
    \ the question.\n<|/ c |>\n<| a dscore=4 |>\nHere's a solution which involves\
    \ no external packages, no type annotations and is (IMHO) more readable:\n<code>",
  "    if l==0\n        return true\n    end\n    if length(l) < 2\n        return\
    \ false\n    \n    if all(l[1:end-1]<l[1:end-1])\n        return true\n    end\n\
    \    return false\nend", "    # from http://www.algorithmist.com/index.php/Monotonic\n\
    \    # find the leftmost value that changes and compare it to the previous one\n\
    \    # if they are the same, then the list is monotonically non-decreasing\n \
    \   # otherwise, the list is monotonically non-increasing\n    i = length(l)\n\
    \    while i > 1 && (l[i-1] != l[i-2]) do\n        i = i-1\n    end\n    \n  \
    \  if i == 1\n        return false\n    else\n        l = l[i-1:end]\n       \
    \ return l[1] < l[2]\n    end\nend", "    return l==sort(l)\nend\n</cell>\n<code\
    \ language=julia-1.5>\n\"\"\"Return true is vector elements are monotonically\
    \ increasing or decreasing.\n    >>> monotonic([5, 4, 1])\n    true\n    >>> monotonic([20,\
    \ 1, -1])\n    false\n    >>> monotonic([1, 4, 2])\n    true\n    \"\"\"", " \
    \   x = l[1]\n    for e in l[2:end]\n        if x < e \n            return false\
    \ \n        x = e\n    return true \nend\n</cell>\n<text>\nMonotonicity Tests\n\
    Let's use the test above to make sure monotonicity is actually working.", "  \
    \  if l[1] == l[0]\n        true\n    elseif l[1] < l[0]\n        true\n    else\n\
    \        false\n    end\nend\n</cell>\n<code language=julia-0.6>", "    l = sort(l)\n\
    \    if all(l[i] <= l[i+1] for i in 2:length(l))\n        return true\n    return\
    \ false\nend", "    for i in 2:length(l)\n        if l[i] < l[i-1]\n         \
    \   return false\n        end \n    end\n    return true\nend", "    return all(l[i]\
    \ <= l[i+1] for i in 1:end-l)\nend \n</code>\n<|/ a dscore=3 tags=arrays,julia\
    \ |>\n<| c |>\n`return all(l[i] <= l[i+1] for i in 1:length(l))` should also work\
    \ without having to preallocate.\n<|/ c |>\n<| c |>\nThat is definitely cleaner.\
    \ I've updated my answer to reflect this.\n<|/ c |>\n<| a |>\nAn alternative to\
    \ the answer by that avoids preallocating the output array, is\n<code>\n ismonotonic(randn(10))\
    \ \u2248 true\n ismonotonic(randn(10)) \u2248 false\n</code>\n<|/ a tags=arrays,julia\
    \ dscore=3 |>\n<| a dscore=3 tags=arrays,julia |>\nThe ismonotonic function in\
    \ StatsBase.jl seems to be the best way to go:\n<code>\njulia> using StatsBase",
  "    l = sort(l)\n    return !isincreasing(l) && !isdecreasing(l)\nend\n</cell>\n\
    <code language=julia-1.5>", "    return all(l[i] > l[i+1] for i in 1:length(l)-1)\
    \ \nend", "    if length(l) == 0 \n        return true\n    if l[1] < l[2] \n\
    \        return true\n    if l[2] < l[1]\n        return true\n    if l[1] > l[3]\
    \ \n        return true\n    if l[3] > l[1]\n        return true\n    return false\n\
    end \n</cell>\n<code language=julia-1.5>\n# Testing function\n@time begin\n  \
    \  @assert not monotonic([1,2,3,4,5])\n    @assert monotonic([1,2,4,5,6])\n  \
    \  @assert monotonic([1,1,4,4,5])\n    @assert monotonic([1,4,1,4,5])\n    @assert\
    \ monotonic([1,4,1,1,1])\nend", "    \"\"\"return true if vector elements are\
    \ monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n\
    \    true\n    >>> monotonic([1, 20, 4, 10])\n    false\n    >>> monotonic([4,\
    \ 1, 0, -10])\n    true\n    \"\"\"\n    sort(l)\n    for i in reverse(collect(2:end-1,\
    \ l, l, l, l, l))\n        return false\n    end\n    return true\nend", "   \
    \ return all( x<l[i-1] or x>l[i+1] for i in 1:length(l) )\nend", "    \"\"\"\n\
    \    Check if vector elements are monotonically increasing or decreasing.\n  \
    \  \"\"\"\n    \n    length = length(l)-1\n    \n    if length == 0 || length(l)[1]\
    \ == 0\n        return true\n    end\n    \n    l = l[end-length+1:end]\n    \n\
    \    return all(l[1:end] < l[end-1:end+1])\nend\n</cell>\n<text>\n4.12 Monotonicity\
    \ of vector elements: Finding minimum and maximum elements of a vector\nTo find\
    \ minimum or maximum element of a vector, one can use findmin and findmax methods\
    \ from Statistics module. These methods return minimum or maximum element of a\
    \ vector. If there are multiple minimum or maximum elements, it returns an array\
    \ containing all of them.", "    if l==0 \n        return true\n    else if l\
    \ < l[1] \n        return true\n    else \n        return false\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis code checks only the first element, not all elements of\
    \ the vector.\n<|/ c |>\n<| c |>\nAs I mentioned in my answer above, the `@` operator\
    \ is not meant for vectors but for lists. `@` is an operator for element-wise\
    \ multiplication. If you want to multiply a vector with itself, use `*` operator.\
    \ So, it is better not to use `@` operator here.\n<|/ c |>\n<| c |>\nOh I see,\
    \ I thought `@` is used to multiply matrix and vector and matrix multiplication\
    \ with vector, my mistake. Thanks\n<|/ c |>\n<| c |>\nI appreciate your help,\
    \ but i just need to check if one vector of ints contains monotonically increasing\
    \ values or decreasing values. So I guess, your solution doesn't work for me.\n\
    <|/ c |>\n<| c |>\nMy apologies, I misinterpreted your comment. What do you mean\
    \ by \"monotonically increasing values or decreasing values\"? The monotonic condition\
    \ is satisfied only for the first element, if you have `v = [1,2,3,4]`, then `monotonic(v)`\
    \ is true, but `monotonic([4,3,2,1])` is false. Do you want to check if the vector\
    \ contains monotonically increasing elements or decreasing elements?\n<|/ c |>\n\
    <| a dscore=3 tags=julia |>\nYou probably want your function to look like (since\
    \ you're using Vector{Int64}, I'll assume the vectors are monotonically increasing\
    \ or decreasing):\n<code>", "    if l[1] == l[2]\n        return true\n    \n\
    \    if l[1] < l[2]\n        return false\n    \n    return true\nend\n</cell>\n\
    <code language=julia-1.6>\n@time monotonic(1:5)\n</cell>\n<code language=julia-1.6>\n\
    @time monotonic([1,2,3,4])\n</cell>\n<code language=julia-1.6>\n@time monotonic([1,2,3,4,5])\n\
    </cell>\n<code language=julia-1.6>\n@time monotonic([1,2])\n</cell>\n<code language=julia-1.6>\n\
    @time monotonic([1,2,3])\n</cell>\n<code language=julia-1.6>\n@time monotonic([1,3,2])\n\
    </cell>\n<code language=julia-1.6>\n@time monotonic([1,2,3,4,5,6,7,8,9])\n</cell>\n\
    <code language=julia-1.6>\n@time monotonic([1,2,3,4,5])\n</cell>\n<code language=julia-1.6>\n\
    @time monotonic([1,2,3,4,5,6,7,8,9,10])\n</cell>\n<code language=julia-1.6>\n\
    @time monotonic([1,2,3,4,5,6,7,8,9,10])\n</cell>\n<text>\nVectorized solution\n\
    To find if a vector is monotonically increasing or decreasing we must use broadcasting\
    \ which can be expensive.", "    \"\"\"\n    Check if vector elements are monotonically\
    \ increasing or decreasing.\n    \n    Arguments:\n        l (Int64): Vector\n\
    \        \n    Returns:\n        Bool: Result of check\n    \n    >>> monotonic([1,\
    \ 20, 4, 10])\n    true\n    >>> monotonic([1, 2, 4, 20])\n    true\n    >>> monotonic([1,\
    \ 4, 6, 10])\n    false\n    >>> monotonic([4, 1, 0, -10])\n    true\n    \"\"\
    \"", "  i=0;j=0;\n  while (i<length(l)-1) do \n    if ((l[i]<l[i+1])||(l[j]<l[i+1]))\n\
    \      i=i+1;\n    else\n      j=j+1;\n    end\n  end\n  j<i\nend\n</code>\n<|/\
    \ a dscore=4 |>\n<| c |>\nThis does not work. Try with monotonic([1,1,2,1]). You\
    \ get True instead of False.\n<|/ c |>\n<| a dscore=3 tags=julia |>\nSince Julia\
    \ 1.0 you can use ismonotonic():\n<code>\njulia> ismonotonic([1,4,3])\ntrue",
  "    \"\"\"\n    Check vector elements for monotonicity, i.e.\n    given increasing,\
    \ decreasing or equal values.\n    \n    Arguments\n    ---------\n    l: Vector{Int64}\n\
    \        Vector to check\n    \n    Returns\n    -------\n    Bool\n        Returns\
    \ true if vector is monotonic, false otherwise.\n    \"\"\"\n    l != sort(l)\n\
    end", "        l = sort(l)\n        switch l[1]-l[0] \n            case 1 => true\n\
    \            case 0 => false\n            case _ => true\n        end\n    end\n\
    </code>\n<|/ a |>\n<| a |>\nHere's a pure Julia solution:\n<code>\njulia> using\
    \ IntervalSets", "    for i in l\n        return (i<(i+1)) || (i>(i-1))\n    end\n\
    \    return true\nend\n</code>\n<|/ a |>\n<| a tags=julia,indexing,vector |>\n\
    <code>", "    m = minimum(l)\n    return m == l[1] and m > l[2] \nend \n</cell>\n\
    <code language=julia-0.6>\n@assert monotonic([2, 4, 0, -10]) == true\n@assert\
    \ monotonic([2, 1, 0, -10]) == false\n@assert monotonic([1, 4, 0, -10]) == false\n\
    @assert monotonic([4, 1, 0, -10]) == true\n</cell>\n<text>\nA more efficient way\
    \ to find the next minimum value is to sort the array and get the first element.\
    \ This requires only linear time.", "    for i in 2:length(l)\n        if l[i-1]\
    \ < l[i] || l[i-1] == l[i] && l[i-2] <= l[i]\n            return false\n     \
    \   end\n    end\n    return true\nend\n</cell>\n<text>\nWe can then wrap the\
    \ monotonic function in a check", "    i = length(l)-1\n    while i > 0 && l[i-1]\
    \ <= l[i]\n        i -= 1\n    \n    return i > 0 && l[i-1] > l[i]\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert @code_warntype @inbounds monotonic([4, 1, 0,\
    \ -10]) == true\n@assert @code_warntype @inbounds monotonic([1, 2, 4, 20]) ==\
    \ true\n@assert @code_warntype @inbounds monotonic([1, 20, 4, 10]) == false\n\
    @assert @code_warntype @inbounds monotonic([10, 4, 1, -3]) == true\n</cell>\n\
    <text>\nFinding the maximum element in a vector\nGiven an n x m vector, find the\
    \ maximum element in a vector and return its coordinates, i.e. (row, column).\n\
    Here the maximum element is the one that has the highest value and the row and\
    \ column are both 1-based row and column indices.", "        sorted = sort(l)\n\
    \        if length sorted == 0 \n            return false\n        elseif sorted[0]\
    \ == sorted[1] \n            return true\n        end\n        \n        first\
    \ = sorted[1]\n        last = sorted[end]\n        return ((first < last)==(last>first))\n\
    \    end\n</code>\n<|/ a |>\n<| a tags=function,julia,performance |>\nThe answer\
    \ by is very good; however, I found a faster way by using some pre-compiled code.\
    \ Here is an example:\n<code>", "    \"\"\"\n    Return true is vector elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n\
    \    true\n    >>> monotonic([1, 20, 4, 10])\n    false\n    >>> monotonic([4,\
    \ 1, 0, -10])\n    true\n    \"\"\"\n    @boundscheck(False)\n    @unpack\n  \
    \  @boundscheck(False)\n    function monotonic(L, out::Union{Nothing, Vector{Int64}})\n\
    \        l = copy(L)\n        n = length(l) \n        i = 1\n        last = first(l)\n\
    \        while i < n \n            if l[i] == last \n                last = first(l)\n\
    \            elseif l[i - 1] < l[i] \n                last = l[i] \n         \
    \   elseif l[i - 1] > l[i] \n                last = l[i - 1] \n            end\n\
    \            i += 1\n        end\n        return !isequal(last, first(l)...)\n\
    \    end", "    if length(l) == 0 \n        return false\n    elseif length(l)\
    \ == 1 \n        return true\n    elseif all(l[i] <= l[i+1] for i in 2:end) \n\
    \        return true\n    elseif all(l[i] >= l[i+1] for i in 2:end) \n       \
    \ return false\n    else \n        return true\nend", "    if l==l \n        true\n\
    \    else \n        if l[1]<l[2] \n            false\n        else \n        \
    \    if l[2]<l[3] \n                false\n            else \n               \
    \ if l[1]<l[3] \n                    false\n                else \n          \
    \          true\n                end\n            end\n        end\n    end\n\
    end\n</cell>\n<code language=julia-1.3>\n\"\"\"Return true is vector elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n\
    \    true\n    >>> monotonic([1, 20, 4, 10])\n    false\n    >>> monotonic([4,\
    \ 1, 0, -10])\n    true\n    \"\"\"", "     if all(l[i+1] < l[i]) for i in 1:length(l)-1\
    \ \n         return false\n     return true\nend", "    l = sort(l)\n    \n  \
    \  local last_x = first(l)\n    for i in l\n        if i > last_x\n          \
    \  true\n        elseif i == last_x\n            true\n        else\n        \
    \    false\n        end\n    end\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=julia,algorithm,sorting\
    \ |>\nIn Julia v0.6.0 you can use sortperms(vec) to return an OrderedSet containing\
    \ indices of the elements in vec that can be used to sort the elements. The elements\
    \ are sorted according to the natural ordering of the elements in the vector.\
    \ \nTo sort by another criteria, for example a vector of type Int64:\n<code>\n\
    sortperms(vec)\n</code>\nand to sort by the vector elements themselves use sortperms(vec,\
    \ lt=) where lt is the function to use to compare the elements of the vector.\
    \ For example:\n<code>\njulia> sortperms([4, 7, 3, 6, 5, 1, 2], lt=(a, b) -> a\
    \ < b ? -1 : 1)\nOrderedSet(Int64, 1, 2, 3, 4, 5, 6)\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\nSorting by Julia is quite straight forward. In order to sort your\
    \ array in Julia use the following syntax:\n<code>\nsort!(array)\n</code>\n<|/\
    \ a dscore=0 tags=julia,algorithm,sorting |>\n<| c |>\nThis is an incorrect solution\
    \ for sorting by value which is what this question asks about.\n<|/ c |>\n<| c\
    \ |>\nSorting by value is not possible in Julia v0.6 `sort!` only works on collections\
    \ of numbers, not on collections of objects.\n<|/ c |>\n<| c |>\nThis answers\
    \ the question asked by the asker. It's a solution for what people would consider\
    \ to be the \"correct\" solution.\n<|/ c |>\n<| a tags=julia,algorithm,sorting\
    \ |>\nIf you want a more in-depth answer, here you go:\n<code>", "    return (minimum(l)\
    \ < maximum(l)) \nend", "    return l.is_sorted\nend", "    for x in l \n    \
    \    m := length(l) \n        j := m-1\n        while j > 1 \n            if x[j]\
    \ < x[j-1] \n                j = j-1 \n            else \n                break\
    \ \n        end\n        if j == 0 \n            return true \n        else \n\
    \            if x[j] < x[j-1] \n                j = j-1 \n            else \n\
    \                return false \n            end\n        end\n    end\n    return\
    \ true \nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\nIn Julia 1.5 you can do this:\n\
    <code>\njulia> a = [1,3,5,7,9,13]\n5-element Array{Int64,1}:\n 1\n 3\n 5\n 7\n\
    \ 9", "    # make sure lengths are the same\n    len_l = length(l); \n    len_x\
    \ = length(x);\n    \n    # return true if l is strictly increasing or decreasing\n\
    \    return len_l <= len_x & (all(l[2:end-1] < x[2:end-1]) || all(l[2:end-1] >\
    \ x[2:end-1]))\nend", "    if l[1] < l[2] \n    then true\n    else false\n  \
    \  end\nend", "    s = sort(l)\n    if s == l\n      true\n    else if rem(s,\
    \ 1) < 1\n      false\n    else if rem(s, -1) < 1\n      true\n    else\n    \
    \  monotonic(s[2:end-1]) \n    end\nend\nmonotonic(l)", "    for i in l\n    \
    \    if i < min(i)\n            return false\n        end\n    end\n    return\
    \ true\nend", "    for i=1:length(l)\n        if l[i-1] > l[i]\n            return\
    \ false\n        else if l[i-1] < l[i]\n            return true\n        else\n\
    \            return true\n        end\n    end\n    return false\nend", "    \"\
    \"\"Return if all elements in l are monotonic.\"\"\"\n    @boundscheck \n    @unpack\
    \ \n    l = sort(l)\n    if l[1] < l[2] && l[1] < l[3] \n        true\n    elseif\
    \ l[2] < l[1] && l[2] < l[3] \n        true\n    else\n        false\n    end\n\
    end\n\"\"\"Return true if all values in x are unique.\"\"\"\n@boundscheck \n@unpack ",
  "    l = sort(l)\n    prev = l[1]\n    for i in 2:length(l)\n        if l[i] < prev\
    \ \n            return false\n        prev = l[i]\n    end\n    return true\n\
    end\n</code>\n<|/ a tags=julia |>\n<| c |>\nYou can shorten this to `return all(l[i]\
    \ .< prev for i = 2:length(l)-1)`.\n<|/ c |>\n<| c |>\nGood point, thanks. I guess\
    \ it's also worth noting that in this case `all` can short-circuit, so it may\
    \ be less efficient than a full traversal.\n<|/ c |>\n<| c |>\nAh, but in this\
    \ case `all` is an iterator so it needs to allocate an iterator. I think `all`\
    \ with multiple arguments are better than `all` with just one argument.\n<|/ c\
    \ |>\n<| c |>\nI wouldn't use `all` at all. It's just a bit too hard to reason\
    \ about. `all(prev .< l[i] for i = 2:length(l))` is even more straightforward.\n\
    <|/ c |>\n<| c |>\nThanks for all the examples. I like how you did it all in one\
    \ function. Is it possible to write this in one line? Also, what do you think\
    \ about putting this in the `sort` function itself? Any thoughts?\n<|/ c |>\n\
    <| a tags=julia |>\nI would define your custom function to return a Boolean indicating\
    \ whether your vector is monotonic:\n<code>", "    sort = sort(l)\n    diff =\
    \ diff(l[sort])\n    for i in sort(sort(diff))\n        if diff[i] < 0\n     \
    \       return true\n        end\n    end\n    return false\nend", "    s = sort(l)\n\
    \    return s[2] >= s[1]\nend\n</cell>\n<text>\nIn a vector, elements below the\
    \ lower bound of the vector are increasing and those above the upper bound are\
    \ decreasing.", "    l = sort(l)\n    \n    if l[1] == l[2] \n        l == l[3:]\n\
    \    else \n        l == l[1:end-1]\n    end\nend", "    m = 0\n    for x in l\
    \ \n        if x <= m \n            m += 1\n        else\n            if m > 0\
    \ \n                if m > x \n                    m = 0\n                else\n\
    \                    m = x\n            end\n        end\n    end\n    return\
    \ m > 0\nend\n</code>\n<|/ a dscore=5 tags=julia,arrays |>\n<| c |>\nThis is the\
    \ way to go :-)\n<|/ c |>\n<| c |>\nI like your solution much better than the\
    \ accepted one because it's more readable (my vote goes to yours!).\n<|/ c |>\n\
    <| c |>\nI would suggest using x==min(l) instead of x>m because it's easier to\
    \ see what is going on. I think also it may run faster\n<|/ c |>\n<| c |>\nThis\
    \ does not work for vectors, it fails with errors like `MethodError: no method\
    \ matching getindex(::Float64, ::Int64)`\n<|/ c |>\n<| c |>\n: this works for\
    \ Vectors -- I tested it with `julia> a = [1, 2, 4, 3]; a<getindex(minimum(a),2)`\n\
    `1`\n`1`\n`0` . Are you sure you're using a Vector?\n<|/ c |>\n<| a tags=julia,arrays\
    \ dscore=5 |>\nYou can find the first index where a condition holds by using the\
    \ find function:\n<code>\njulia> [1 2 3 4 2 3 4 5 4 7 8];", "    for e in l.sorted()\n\
    \        if e > last(e)\n            return false\n        elseif e < last(e)\n\
    \            return true\n        end\n    end\n    return true\nend\n</code>\n\
    <|/ a |>\n<| a dscore=3 |>\nThis should work for a generic type T\n<code>", " \
    \   if l == sort(l)\n        true\n    else\n        false\n    end\nend\n</cell>\n\
    <text>\nTesting whether a vector is monotonic is easy:", "    i=l[1]\n    for\
    \ j in l[2:end]\n        if i>j \n            i=j\n        else\n            return\
    \ false\n        end\n    end\n    return true\nend\n\"\"\"\nReturn the index\
    \ of the element that is bigger than x\n\"\"\"", "    #l = length(l); l = l .-\
    \ l[1]; \n    l = sort(l); \n    l > 0 && l < length(l); \nend\nmonotonic(l)\n\
    end\n</cell>\n<code language=julia-1.4>\n?monotonic\n</cell>\n<code language=julia-1.4>\n\
    ?sort\n</cell>\n<code language=julia-1.4>", "    diff = zeros(Int64, length(l)-1)\n\
    \    for (i,j) in zip(1:size(l,1), 2:size(l,1))\n        diff[j-i] = l[j] - l[j-i]\
    \ \n    end\n    return diff[1:end-1] .> 0\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=julia |>\nJust for kicks, I did some benchmarks for this, and it seems\
    \ that most of the answers here are faster, but this one is fastest:\n<code>",
  "    \"\"\"Check if vector elements are monotonically increasing or decreasing.\n\
    \    >>> monotonic([4, 1, 0, -10])\n    true\n    >>> monotonic([1, 2, 4, 20])\n\
    \    true\n    >>> monotonic([1, 20, 4, 10])\n    false\n    \"\"\"\n    if l[1]\
    \ < l[2] and l[2] < l[3] and l[3] < l[1]\n        return true\n    elseif l[1]\
    \ > l[2] and l[2] > l[3] and l[3] > l[1]\n        return false\n    elseif l[1]\
    \ < l[2] and l[2] < l[3] and l[3] > l[1]\n        return true\n    else\n    \
    \    return false\n    end\nend", "    l[argmax(l)] <= l[min(l)] #check min and\
    \ max elements \nend\n</code>\n<|/ a tags=python,performance,julia dscore=4 |>\n\
    <| c |>\nThis works well, especially for arrays that have a `max` but not a `min`.\n\
    <|/ c |>\n<| a dscore=4 |>\nHere's a version that is quite similar to Matthias'\
    \ code. I added a min option for when you want to enforce the lowest value to\
    \ be non-zero and the highest to be non-negative. \n<code>", "    if l.length==1\n\
    \        l.head < l.tail[1]\n    else\n        l.head < l.tail[1] && monotonic(l.tail)\n\
    \    end\nend", "    l = sort(l)\n    \n    for i = length(l); i >= 1; i-- \n\
    \        if l[i-1] > l[i] \n            return false \n        end \n    \n  \
    \  return true\nend", "    l.sort()\n    return all(isless(l[i+1], l[i]) for i\
    \ in 1:length(l))\nend \n</code>\n<|/ a dscore=2 |>\n<| a tags=arrays,julia,sorting,vector,performance\
    \ |>\n<code>", "    n = length(l) \n    i = j = 1\n    while j < n \n        j\
    \ = j + 2 \n        if l[j] < l[j+1] \n            i = i + 1 \n            j =\
    \ j + (l[j] - l[j+1] == 0) ? 0 : 1 \n        else \n            i = i + 1 \n \
    \           j = j + (l[j] - l[j+1] < 0) ? 0 : 1 \n        end \n    end\n    \n\
    \    if i == n \n        return true\n    else \n        return false \n    end\n\
    end", "    # Check for length\n    if length(l) != size(l)\n        return false\n\
    \    # Return true if all elements are monotonically increasing or decreasing\n\
    \    if all(l .> l[end-1]) == true\n        true\n    else\n        false\n  \
    \  end\nend", "    return l.min <= l.max\nend", "    \n    l = sort!(l)\n    diffs\
    \ = [l[i+1]-l[i] for i in range(1,length(l))]\n    \n    for d in diffs\n    \
    \    if d <= 0\n            return false\n        end\n    end\n    \n    return\
    \ true\nend\n</cell>\n<code language=julia-1.5>\n@testset \"monotonic tests\"\
    \ begin\n    vectors() = random_vectors(1000000)\n    \n    truth = map(monotonic,\
    \ vectors())\n    \n    @test all(truth)\nend\n</cell>\n<text>\nConjunction Tests\n\
    An $n$-element set satisfies the following conjunction tests:", "    i, k = lastindex(l),\
    \ length(l) - 1\n    return i > k || l[i-1] > l[k] || k > i\nend\n</cell>\n<code\
    \ language=julia-1.5>\n# Check that monotonicity holds:\n@testset \"monotonicity\
    \ test 2\" begin\n    vec1 = [3, 1, 2, 4, 5, 7]\n    vec2 = [3, 1, 2, 4, 5, 8]\n\
    \    vec3 = [3, 1, 2, 4, 5, 9]\n    vec4 = [3, 1, 2, 4, 5, 10]\n    vec5 = [3,\
    \ 1, 2, 4, 5, 11]\n    vec6 = [3, 1, 2, 4, 5, 12]\n    vec7 = [3, 1, 2, 4, 5,\
    \ 13]\n    vec8 = [3, 1, 2, 4, 5, 14]\n    vec9 = [3, 1, 2, 4, 5, 15]\n    vec10\
    \ = [3, 1, 2, 4, 5, 16]\n    vec11 = [3, 1, 2, 4, 5, 17]\n    vec12 = [3, 1, 2,\
    \ 4, 5, 18]\n    vec13 = [3, 1, 2, 4, 5, 19]\n    vec14 = [3, 1, 2, 4, 5, 20]\n\
    \    vec15 = [3, 1, 2, 4, 5, 21]\n    vec16 = [3, 1, 2, 4, 5, 22]\n    vec17 =\
    \ [3, 1, 2, 4, 5, 23]\n    vec18 = [3, 1, 2, 4, 5, 24]\n    vec19 = [3, 1, 2,\
    \ 4, 5, 25]\n    vec20 = [3, 1, 2, 4, 5, 26]\n    vec21 = [3, 1, 2, 4, 5, 27]\n\
    \    vec22 = [3, 1, 2, 4, 5, 28]\n    vec23 = [3, 1, 2, 4, 5, 29]\n    vec24 =\
    \ [3, 1, 2, 4, 5, 30]\n    vec25 = [3, 1, 2, 4, 5, 31]\n    vec26 = [3, 1, 2,\
    \ 4, 5, 32]\n    vec27 = [3, 1, 2, 4, 5, 33]\n    vec28 = [3, 1, 2, 4, 5, 34]\n\
    \    vec29 = [3, 1, 2, 4, 5, 35]\n    vec30 = [3, 1, 2, 4, 5, 36]\n    vec31 =\
    \ [3, 1, 2, 4, 5, 37]\n    vec32 = [3, 1, 2, 4, 5, 38]\n    vec33 = [3, 1, 2,\
    \ 4, 5, 39]\n    vec34 = [3, 1, 2, 4, 5, 40]\n    vec35 = [3, 1, 2, 4, 5, 41]\n\
    \    vec36 = [3, 1, 2, 4, 5, 42]\n    vec37 = [3, 1, 2, 4, 5, 43]\n    vec38 =\
    \ [3, 1, 2, 4, 5, 44]\n    vec39 = [3, 1, 2, 4, 5, 45]\n    vec40 = [3, 1, 2,\
    \ 4, 5, 46]\n    vec41 = [3, 1, 2, 4, 5, 47]\n    vec42 = [3, 1, 2, 4, 5, 48]\n\
    \    vec43 = [3, 1, 2, 4, 5, 49]\n    vec44 = [3, 1, 2, 4, 5, 50]\n    vec45 =\
    \ [3, 1, 2, 4, 5, 51]\n    vec46 = [3, 1, 2, 4, 5, 5", "    \"\"\"\n    Check\
    \ if a vector is monotonically increasing or decreasing.\n    \n    Parameters\n\
    \    ----------\n    l\n        A vector of integers that may or may not be sorted.\n\
    \    \n    Returns\n    -------\n    monotonic\n        True if `l` is monotonically\
    \ increasing or decreasing.\n    \n    Notes\n    -----\n    Based on [Wikipedia](https://en.wikipedia.org/wiki/Monotonic_function)\
    \ \n    \"\"\"\n    if length(l) < 2 || length(unique(sort(l))) != length(l)\n\
    \        error(\"Vector contains duplicate elements!\")\n    end\n    return ((diff(l)[1]\
    \ < 0) == (diff(l)[2] < 0) == (diff(l)[1] > 0) == (diff(l)[2] > 0))\nend\n</cell>\n\
    <code language=julia-0.6>\n\"\"\" \nReturns random vector sampled from uniform\
    \ distribution on\n[-1,1] and returns boolean indicating if sample is sorted or\
    \ not.\n\"\"\"", "    return all(diff(l)<=0)\nend", "    return all(i1 <= i2 for\
    \ (i1, i2) in zip(reversed(l), l))\nend # monotonic", "    l = sort!(l)\n    i\
    \ = 2\n    \n    while i <= length(l)\n        if l[i] > l[i-1] \n           \
    \ return false\n        elseif l[i] < l[i-1] \n            return true\n     \
    \   end\n        i = i+1\n    end\n    return false\nend", "    # Based on code\
    \ from \n    # http://julia.readthedocs.org/en/latest/stdlib/v1.0/basics/arithOps.html#monotonic-numbers\n\
    \    # and https://stackoverflow.com/questions/41112676/julia-counting-elements-greater-than-x-in-array\n\
    \    i = findfirst(x -> x > 0, l)\n    j = findfirst(x -> x > 0, reverse(l)) -\
    \ 1\n    return i <= j\nend", "    (l, l[end] <= l[1]) == (l, l[1] <= l[l+1])\n\
    end\nmonotonic(a)\n</cell>\n<code language=julia-1.6>\na = [1, 2, 3, 4]\n</cell>\n\
    <code language=julia-1.6>", "    for n in 1:length(l) \n        if l[n-1] <= l[n]\
    \ \n            return false \n        end \n    end \n    return true \nend \n\
    </cell>\n<code language=julia-1.1>\n\"\"\"Return true if two vectors are equal.\n\
    \    >>> equal([1.0, 0.0, 0.0], [1.0, 0.0, 0.0])\n    true\n    >>> equal([0.0,\
    \ 0.0, 0.0], [0.0, 0.0, 0.0])\n    true\n    >>> equal([0.0, 0.0, 0.0], [1.0,\
    \ 0.0, 0.0])\n    false\n    >>> equal([0.0, 0.0, 0.0], [0.0, 0.0])\n    false\n\
    \    >>> equal([1.0, 0.0, 0.0], [0.0, 1.0])\n    false\n    \"\"\"", "    return\
    \ all((i > j) and (i < length(l)-1) for (j, i) in zip(l, l[1:end-1]))\nend ",
  "        local last_index = length(l) - 1\n        local is_monotonic = false\n\
    \        for i = (last_index + 1) % length(l) \n            do\n             \
    \   is_monotonic = is_monotonic or (i > l[last_index])\n            end\n    \
    \    end\n        return is_monotonic\n    end", "    if length(l) < 2 \n    \
    \    true\n    else \n        (l[1] < l[2]) || \n        ((l[1] <= l[2]) && (l[2]\
    \ <= l[3]))\n    end\nend\n</code>\n<|/ a dscore=3 |>\n<| a tags=vector,julia\
    \ |>\nA very quick way would be to sort the vector and compare the indices to\
    \ find if the vector is in increasing order:\n<code>\na = [4, 10, 1, 20, 2]\n\
    a[sortperm(a)] == a\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis could be useful\
    \ in some cases (for example, if one wants to check if a vector is sorted ascending),\
    \ but is quite inefficient on large vectors. I would recommend using sort! if\
    \ performance is an issue.\n<|/ c |>\n<| a dscore=3 |>\nThe most efficient way\
    \ to check if the vector is sorted is to use the issorted function.\n<code>\n\
    julia> a = [4,10,1,20,2]\njulia> issorted(a)\ntrue\njulia> a = [4,10,1,20,2,1]\n\
    julia> issorted(a)\nfalse\n</code>\nThe issorted function has a lower bound on\
    \ the time complexity of O(log(n)) and has a constant time complexity of O(1).\n\
    This can save a lot of time if you have large vectors.\n<|/ a tags=vector,julia\
    \ |>\n<| a tags=vector,julia |>\nIf one wants a faster solution, one can use sort!\
    \ on a copy of the vector, as follows:\n<code>\njulia> a = [4,10,1,20,2]\n5-element\
    \ Array{Int64,1}:\n  4\n 10\n  1\n 20\n  2", "    sorted_idx = sort(l)\n    sorted_idx.start\
    \ < sorted_idx.stop\nend\n</cell>\n<code language=julia-1.3>", "    l = sort(l)\n\
    \    return all(l[i] <= l[i+1] for i in 2:length(l))\nend", "    i = 2\n    j\
    \ = length(l) - 1\n    while i <= j\n        if l[i] > l[j]\n            return\
    \ false\n        elseif l[i] < l[j]\n            i += 1\n        else\n      \
    \      j += 1\n        end\n    end\n    return true\nend\n</cell>\n<code language=julia-1.6>\n\
    @testset \"monotonic\" begin\n@test monotonic([1, 2, 4, 20]) == true\n@test monotonic([1,\
    \ 20, 4, 10]) == false\n@test monotonic([4, 1, 0, -10]) == true\nend\n</cell>\n\
    <text>\n5. Statistics", "  \n    l = sort(l)\n  \n    for i=1:length(l)\n    \
    \    if l[i] < l[i-1] \n          return false\n        end\n    end\n    return\
    \ true\nend\n</code>\n<|/ a |>\n<| c |>\nPlease edit your answer to include some\
    \ explanation.\n<|/ c |>\n<| a |>\nA more robust solution would be to check whether\
    \ the first and last elements are increasing or decreasing. If they are not, then\
    \ this means that the array is not monotonical.\n<code>", "    if length(l) <\
    \ 2 \n        return true\n    end", "    if length(l) <= 1\n        return true\n\
    \    \n    head = 0\n    for i=2:length(l)\n        if l[i] > l[i-1]\n       \
    \     return false\n        end\n    end\n    return true\nend\n</cell>\n<code\
    \ language=julia-1.5>\n# Test Code\n</cell>\n<code language=julia-1.5>", "   \
    \ # monotonic function\n    # https://en.wikipedia.org/wiki/Monotonic_descending\
    \ \n    l = l[end]-l[end-1]\n    if l > 0 \n        true\n    else\n        false\n\
    \    end\nend\n</code>\n<|/ a tags=vectorization,function,julia |>\n<| a dscore=2\
    \ |>\nIf your data is of type Vector{Int64} you can simply use:\n<code>\nmaximum(vec)\n\
    </code>\nThis finds the maximum element in the vector and returns it, while minimum()\
    \ and mean() return the minimum and mean respectively.\nIf you need to compare\
    \ elements to each other, you can do that with map() and a custom function like\
    \ this:\n<code>\njulia> x = [1,3,2]\n1-element Vector{Int64}:\n 1", "        l\
    \ = length(l)\n        for i in 2:l\n            if l[i-1] > l[i]\n          \
    \      return false\n            if l[i-1] < l[i]\n                return true\n\
    \        end\n        return false\nend", "    if all(diff(l)==0) \n        return\
    \ true\n    \n    return false\nend", "    if length(l) <= 2 || all(map(>=, l,\
    \ l[1:end-1]))\n        return True\n    end\n    l, last = sort(l)\n    return\
    \ monotonic(last) && monotonic(l)\nend\n\"\"\"Return true is vector elements are\
    \ non-decreasing or non-increasing.\n    >>> nonmonotonic([-1, 0, 1, 1])\n   \
    \ true\n    >>> nonmonotonic([-1, 1, 0, 1])\n    false\n    >>> nonmonotonic([-1,\
    \ 1, -1, 1])\n    true\n    \"\"\"", "    if length(l) <= 1 \n        return true\n\
    \    else \n        i = 1\n        while i < length(l)-1 \n            if l[i]\
    \ > l[i+1] \n                return false\n            else \n               \
    \ i += 1\n        return true\n    end\nend", "    l = sortperm(l)\n    return\
    \ l[1]-l[0] == 0\nend", " \n    if issorted(l)\n        return true\n \n    return\
    \ all(bigger(l[i], l[i-1]) for i in 2:end-1) || all(bigger(l[i], l[i+1]) for i\
    \ in 1:end-1)\nend\n</cell>\n<code language=julia-1.6>\n#export", "    len = length(l)-1\n\
    \    if len == 0\n        return true\n    end\n    for i in 2:len\n        if\
    \ l[i-1] < l[i] and l[i-1] > l[i]\n            return false\n        end\n   \
    \ end\n    return true\nend\n\"\"\"Return true if the input array is increasing\
    \ or decreasing in monotonic order\"\"\"", "    v = 0\n    l = sorted(l)\n   \
    \ for i in l\n        if v < i\n            v = i\n        elseif v > i\n    \
    \        return false\n        end\n    end\n    return true\nend\n</cell>\n<code\
    \ language=julia-0.6>\n# TEST monotonic (4d)\n@test monotonic([10, 4, 2, 1])\n\
    @test !monotonic([5, 4, 2, 1])\n@test monotonic([4, 2, 1])\n@test !monotonic([2,\
    \ 1, 4])\n@test !monotonic([-1, -2, -4, 2])\n@test !monotonic([1, 2, 4, 20])\n\
    @test !monotonic([1, 20, 4, 10])\n@test !monotonic([4, 1, 0, -10])\n</cell>\n\
    <text>\n4.2 Find the index of a value\nFind the index of a value in a given vector.",
  "    for i in l\n        if i>l[i-1] \n            return false\n    return true\n\
    end", "    return ((l .< last(l)) .& (l .> first(l))) \nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Return true is vector elements are monotonically increasing or decreasing.\n\
    \    >>> monotonic([1, 20, 4, 10])\n    true\n    >>> monotonic([4, 1, 0, -10])\n\
    \    true\n    \"\"\"", "  return all(l.>first(l)) && all(l.<last(l))\nend", " \
    \   if length(l) == 1 \n        return true\n    \n    l = copy(l)\n    if l[1]\
    \ == l[0] \n        return true\n    \n    if l[1] < l[0] \n        swap!(l, 1,\
    \ 2)\n    \n    if l[2] == l[1] \n        return true\n    \n    i = 2\n    while\
    \ l[i] < l[i-1] \n        i += 1\n    \n    if i == length(l) \n        return\
    \ false\n    \n    while i < length(l) \n        if l[i] > l[i-1] \n         \
    \   break\n        i += 1\n    \n    return true\nend", "    for i \u2208 enumerate(l)\n\
    \        if l[i-1] < l[i] \n            return false\n        elseif l[i-1] >\
    \ l[i] \n            return true\n        end\n        return false \n    end\n\
    \    return true\nend\n</cell>\n<code language=julia-1.5>\nx = zeros(10)\nx[8]\
    \ = 5\nx\n</cell>\n<code language=julia-1.5>\nx[2:4] = 5\nx\n</cell>\n<code language=julia-1.5>\n\
    x[4:10] = 5\nx\n</cell>\n<code language=julia-1.5>\nx[1:9:-1] = 5\nx\n</cell>\n\
    <code language=julia-1.5>\nx[1:10:-1] = 5\nx\n</cell>\n<code language=julia-1.5>\n\
    x[1:10:-5]\n</cell>\n<code language=julia-1.5>\nx[1:10:-5] = 5\nx\n</cell>\n<code\
    \ language=julia-1.5>\nx[1:10:-5] = 5.4\nx\n</cell>\n<code language=julia-1.5>\n\
    x[1:10:-5] = 5.6\nx\n</cell>\n<code language=julia-1.5>\nx[1:10:-5] = 5.4\nx\n\
    </cell>\n<code language=julia-1.5>\nx = ones(10)\nx[10:12] = 2\nx\n</cell>\n<code\
    \ language=julia-1.5>\nx = zeros(10)\nx[10:12] = 2\nx\n</cell>\n<code language=julia-1.5>\n\
    x = zeros(10)\nx[10:12] = -2\nx\n</cell>\n<code language=julia-1.5>\nx = zeros(10)\n\
    x[10:12] = -2 \nx\n</cell>\n<code language=julia-1.5>", "    return sum(l[1:end-1]\
    \ < l[2:end]) > sum(l[2:end] < l[1:end-1])\nend", "    # from http://stackoverflow.com/questions/9307710/check-if-a-vector-is-monotonically-increasing-decreasing\n\
    \    # check \n    # if the list is not empty\n    if length(l) > 0\n        #\
    \ then check if the first element is the smallest\n        if l[1] < l[0]\n  \
    \          # if the first element is smaller, the vector is monotonic\n      \
    \      true\n        else\n            # otherwise, the vector is not monotonic\n\
    \            false\n        end\n    else\n        # if the list is empty, return\
    \ false\n        false\n    end\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis\
    \ works well for monotonic vectors, but it fails to catch the case of a monotonically\
    \ increasing vector with some decreasing values, such as `[4, 1, 0, -10]`.\n<|/\
    \ c |>\n<| a dscore=3 |>\nThe solution by Michael Butscher works well, but unfortunately\
    \ it fails to catch the case of a monotonically increasing vector with some decreasing\
    \ values, such as [4, 1, 0, -10]. \nHere's a version that does catch this\n<code>",
  "    if length(l)==0 \n        return true \n    end\n    if l[1]<l[2] \n      \
    \  return true\n    elseif l[1]==l[2] \n        if l[1]>l[3] \n            return\
    \ true\n        else \n            return false \n        end\n    else \n   \
    \     return false \n    end\nend", "    m = maximum(l) - minimum(l)\n    return\
    \ m <= 0 && all(l[!, i] < m[i] for i = 1:size(l)[1])\nend", "    @dprintln(2,\
    \ \"monotonic:\", l)\n    @dprintln(2, \"monotonic:\", ismonotonic(l))\n    @dprintln(2,\
    \ \"monotonic:\", isordered(l))\n    @dprintln(2, \"monotonic:\", isincreasing(l))\n\
    \    @dprintln(2, \"monotonic:\", isdecreasing(l))\n    @dprintln(2, \"monotonic:\"\
    , isincreasingmonotonic(l))\n    @dprintln(2, \"monotonic:\", isdecreasingmonotonic(l))\n\
    \    @dprintln(2, \"monotonic:\", isincreasingdecreasing(l))\n    @dprintln(2,\
    \ \"monotonic:\", isdecreasingincreasing(l))\n    @dprintln(2, \"monotonic:\"\
    , isdecreasingdecreasing(l))\n    @dprintln(2, \"monotonic:\", isdecreasingincreasing(l))\n\
    \    @dprintln(2, \"monotonic:\", isincreasingdecreasing(l))\n    @dprintln(2,\
    \ \"monotonic:\", isincreasingincreasing(l))\n    @dprintln(2, \"monotonic:\"\
    , isincreasingdecreasing(l))\n    @dprintln(2, \"monotonic:\", isdecreasingincreasing(l))\n\
    \    @dprintln(2, \"monotonic:\", isdecreasingdecreasing(l))\n    @dprintln(2,\
    \ \"monotonic:\", isdecreasingincreasing(l))\n    @dprintln(2, \"monotonic:\"\
    , isdecreasingdecreasing(l))\n    @dprintln(2, \"monotonic:\", isincreasingdecreasing(l))\n\
    \    @dprintln(2, \"monotonic:\", isdecreasingincreasing(l))\n    @dprintln(2,\
    \ \"monotonic:\", isdecreasingincreasing(l))\n    @dprintln(2, \"monotonic:\"\
    , isincreasingdecreasing(l))\n    @dprintln(2, \"monotonic:\", isdecreasingdecreasing(l))\n\
    \    @dprintln(2, \"monotonic:\", isincreasingdecreasing(l))\n    @dprintln(2,\
    \ \"monotonic:\", isdecreasingincreasing(l))\n    @dprintln(2, \"monotonic:\"\
    , isdecreasingdecreasing(l))\n    @dprintln(2, \"monotonic:\", isincreasingdecreasing(l))\n\
    \    @dprintln(2, \"monotonic:\", isdecreasingincreasing(l))\n    @dprintln(2,\
    \ \"monotonic:\", isdecreasingincreasing(l))\n    @dprintln(2, \"monotonic:\"\
    , isincreasingdecre", "    # Return false if any NaN or Inf\n    if any(isnan(l))\n\
    \        false\n    elseif any(isinf(l))\n        false\n    else\n        # Return\
    \ false if any element is less than 0\n        if any(l < 0)\n            false\n\
    \        # Return false if any element > 1\n        elseif any(l > 1)\n      \
    \      false\n        else\n            # Return true if all elements are strictly\
    \ increasing\n            all(head < last(head) for head in l[1:end-1]) \n   \
    \     end\n    end\nend\n</code>\n<|/ a |>\n<| a tags=julia,vector |>\nThe code\
    \ can be simplified and optimized a bit (as of Julia v0.3.6 and v0.5.0) by using\
    \ the Base.sorted function and returning the first and last element of the resulting\
    \ array as a tuple:\n<code>", "    if issorted(l)\n        return true\n    return\
    \ false\nend", "     return l == sort(l)\nend\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ is very slow. I tried a little and found that `sort l` has a runtime of 3ns\
    \ for an array of length 100 and a runtime of 7ns for an array of length 1000.\
    \ Although a quick test shows that `sort(l)` runs in O(n^2), `sort!(l); return\
    \ l == l` runs in O(n). I still think your `monotonic` function can be improved.\n\
    <|/ c |>\n<| c |>\nWhat are those numbers meant to represent? The runtime for\
    \ my function is very close to `O(n)` on my computer, but of course it depends\
    \ on your input. For example, for `[5,5,5,5,5,5,5,5,5,5]`, it is `O(n)`. In general,\
    \ `O(n^2)` means that your algorithm is `O(n^2)`. `O(n)` means that it is `O(n)`.\n\
    <|/ c |>\n<| c |>\nSorry, I didn't mean to be obtuse. Yes, I agree with you. I\
    \ just meant that your `monotonic` function is very slow.\n<|/ c |>\n<| c |>\n\
    The reason why `sort!` has a runtime of 7ns is that the `sort` function runs in\
    \ O(n^2) in the general case. Hence `sort!` runs in `O(n^2)`.\n<|/ c |>\n<| c\
    \ |>\n`sort!` just iterates the entire array (in this case, sorting it in-place)\
    \ and calls swap for each element. Hence my `sort` function runs in `O(n)`. `sort!`\
    \ is `O(n^2)` only when `swap` is `O(n)`. `sort!` has O(n^2) when `swap` is `O(n^2)`\
    \ (or when `swap` has complexity O(n^2) at all, that is, when `swap` is really\
    \ `O(n)`).\n<|/ c |>\n<| a |>\nAs mentioned in another answer, in Julia, it's\
    \ pretty straight forward to sort an array in O(N*logN) time. Here's an implementation:\n\
    <code>", "    return all( l.>first(l) .or. l.<last(l) )\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert ! (monotonic([1, 2, 4, 20]) && monotonic([1, 20, 4, 10]));\n</cell>\n\
    <code language=julia-1.5>\n@assert ! (monotonic([1, 2, 4, 20]) && monotonic([20,\
    \ 4, 10, 1]));\n</cell>\n<text>\nIn Julia a Vector can be considered to be an\
    \ \"array like\" structure, i.e. it is an array and you can access its elements\
    \ as if it was an array.", "    if iseven(l) \n        return false\n    else\
    \ if l == sort(l) \n        return true\n    else \n        return false\n   \
    \ end\nend\n</cell>\n<text>\nNow let's test our monotonicity function.", "   \
    \ l = sort(l)\n    return all(x == l[i-1] <= x for (i, x) in enumerate(l))\nend",
  "    if length(l) < 2 then return false end\n    if l[1] <= l[2] then return false\
    \ end\n    if l[1] <= l[3] then return false end\n    if l[2] <= l[3] then return\
    \ false end\n    if l[1] <= l[2] and l[2] <= l[3] then return true end\n    return\
    \ true\nend", "    return ( l[1] < l[2] || (l[1] == l[2] && l[2] < l[3]) ) &&\
    \ \n        ( l[1] < l[3] || (l[1] == l[3] && l[3] < l[2]) ) \nend\n</cell>\n\
    <text>\nNow suppose you wanted to know the value at $i=4$.  What would you do?\
    \  There are a number of answers, but the easiest is to look at the value at $i=3$\
    \ and $i=4$.  The third value in the list is $-10$ and $20$.  Those are both less\
    \ than the value of $i=4$.  So the answer is $20$.  We already know the answer\
    \ is $20$, so we could have continued on from there.  We know $i=3$ is less than\
    \ $i=4$, so we could have continued on from that.  We know $i=3$ and $i=4$ have\
    \ the same value, so there is no need to continue.", "        l = sort!(l)\n \
    \       for i in 1:length(l)-1\n            if l[i] > l[i+1]\n               \
    \ return false\n            end\n        end\n        return true\n    end\n</code>\n\
    <|/ a dscore=2 |>\n<| a |>\nHere are two more implementations:\n<code>", "   \
    \ if l[1] <= l[2] \n    then true\n    else false \n    end\nend\n\"\"\"\nReturns\
    \ true if the specified list contains only monotonically increasing elements\n\
    \"\"\"", "    if all(l[i] <= l[i+1] for i=2:end(l))\n        return true\n   \
    \ else\n        return false\n    end\nend\n</cell>\n<text>\nLet's test the monotonicity\
    \ of the function by comparing it to a linear function. Since a linear function\
    \ has a known minimum and maximum value, we can easily compute the maximum and\
    \ minimum of our monotonically increasing or decreasing function. Note that we\
    \ cannot compute a maximum or minimum if the vector is empty (because there is\
    \ no minimum or maximum value of a vector of length 0).", "  \n    if l[1] <=\
    \ l[2] \n        return true\n    elseif l[2] <= l[3] \n        return true\n\
    \    elseif l[3] <= l[1] \n        return true\n    elseif l[2] <= l[3] \n   \
    \     return true\n    elseif l[1] <= l[2] \n        return true\n    elseif l[3]\
    \ <= l[2] \n        return true\n    elseif l[3] <= l[1] \n        return true\n\
    \    elseif l[1] <= l[3] \n        return true\n    end\n    return false\nend\n\
    </cell>\n<code language=julia-1.5>\n\"\"\"Return true is vector elements are monotonically\
    \ increasing or decreasing.\n    >>> monotonic([1, 20, 4, 10])\n    true\n   \
    \ >>> monotonic([4, 1, 0, -10])\n    false\n    \"\"\"", "    if length(l) < 2\
    \ \n        return false \n    end\n    if l[1] < l[2]\n        true\n    elseif\
    \ l[1] > l[2]\n        false\n    else\n        monotonic(l[2:end-1]) \n    end\n\
    end\n\"\"\"\n    monotonic()", "    l = sort(l)\n    for i = 2:length(l)\n   \
    \     if l[i-1] < l[i] || l[i-1] == l[i] && l[i] != 0\n            return false\n\
    \        end\n    end\n    return true\nend\nmonotonic(x) = x\n</cell>\n<code\
    \ language=julia-1.3>\n\"\"\" Sort an array in increasing order.\n    >>> increasing([5,\
    \ 2, 1, 3, 10, 4, 2, 1])\n    [1, 2, 1, 2, 3, 4, 5]\n    >>> increasing([5, 2,\
    \ 1, 3, 10, 4, 2, 10])\n    [1, 2, 1, 2, 3, 4, 5]\n    >>> increasing([5, 2, 1,\
    \ 3, 10, 4, 2, 30])\n    [1, 2, 1, 2, 3, 4, 5]\n    \"\"\"", "  l = sort(l)\n\
    \  if length(l)<=1\n    true\n  elseif l[1] == l[2]\n    true\n  else\n    if\
    \ l[2] - l[1] < 0\n      l[2] += (l[2] - l[1])\n      l[2] += 1 \n      l[1] =\
    \ 1\n    else\n      l[1] = 1\n    end\n    true\n  end\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=optimization,julia,arrays dscore=0 |>\nAnother method would be\
    \ to use sortperm:\n<code>\nusing BenchmarkTools", "    # Sort and check if any\
    \ elements are equal\n    l = sort(l)\n    return all(l[i] <= l[i + 1] for i in\
    \ 2:size(l))\nend ", "    v1 = l[1:end-1]\n    v2 = l[2:end]\n    return (v1 <\
    \ v2) || (v1 == v2 && l[1] < l[2])\nend\n</cell>\n<code language=julia-1.5>\n\
    @test monotonic([4, 1, 0, -10]) == true\n@test monotonic([1, 20, 4, 10]) == false\n\
    @test monotonic([3, 15, 1, -2]) == false\n</cell>\n<text>\nAside: What is Julia's\
    \ Array type?\nJulia's Array is a fixed-size vector-like data structure, which\
    \ can be thought of as an ordered vector of values indexed by integers. For example,\
    \ if we set $A = [1 2 3 4 5]$, then $A[2]=3$, and $A[3]=4$, and $A[4]=5$. Or,\
    \ if we set $A = rand(5)$, then $A[2]=1.0$, and $A[3]=2.0$, and $A[4]=0.0$. Julia's\
    \ Array is designed to be \"memory-efficient\", meaning that operations on it\
    \ use only a subset of the underlying vector storage (that is, it only allocates\
    \ memory for the parts of the array that are actually used, so for dense arrays,\
    \ that means only those elements that are referenced by an element of a subarray,\
    \ or those elements that are referenced by an index).", "    s = l.sort()\n  \
    \  return s.last<(length(l)-1)\nend", "    if length(l)==0\n        true\n   \
    \ elseif l[1] < l[2]\n        true\n    elseif l[1] > l[2]\n        false\n  \
    \  elseif l[1] < l[2]\n        false\n    elseif l[2] < l[1]\n        true\n \
    \   elseif l[2] > l[1]\n        false\n    elseif l[2] > l[1]\n        false\n\
    \    else\n        true\n    end\nend\n</cell>\n<text>\nThe function above will\
    \ check whether the elements of the list are monotonic (decreasing or increasing).\
    \ In a vector $x$, the elements are $x{1}, x{2}, \\ldots, x{n}$, and if $x{1}\
    \ \\leq x{2}, \\ldots, x{n} \\leq x{n+1}$, then the vector is monotonic.", " \
    \   if isa(l,Vector{Int64}) && length(l) == 1 && l[1] > l[1] \n        true\n\
    \    else\n        false\n    end\nend\n</cell>\n<code language=julia-1.1>\n\"\
    \"\"Return true if a sequence is monotonically increasing or decreasing.\"\"\"",
  "    m = minimum(l)\n    M = maximum(l)\n    \n    if m <= M\n        true\n   \
    \ else\n        false\n    end\nend\nmonotonic.(l)", "    sorted_l = sort(l)\n\
    \    diff <- diff(l[1:end-1]) \n    \n    return (all(diff(sorted_l) == 0)) or\
    \ (all(diff(sorted_l) == 1))\nend", "    v<-sort(l)\n    \n    if v[1] > v[2]\n\
    \        return true\n    else\n        return false\n    end\nend\n</code>\n\
    <|/ a dscore=3 tags=vector,julia,performance |>\n<| a |>\nIn julia v0.23, you\
    \ can now do:\n<code>\njulia> a = [1, 6, 5, 8, 3]\n5-element Array{Int64,1}:\n\
    \ 1\n 6\n 5\n 8\n 3", "    l = sort(l)\n    if l[1] <= l[2] || l[1] <= l[3] ||\
    \ l[2] <= l[3]\n        return true\n    else\n        return false\n    end\n\
    end", "    return all(i in [1,-1] for i in vec(l))\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Return true is vector elements are non-decreasing or non-increasing.\n \
    \   >>> monotonic([1, 2, 4, 20])\n    true\n    >>> monotonic([1, 20, 4, 10])\n\
    \    false\n    >>> monotonic([4, 1, 0, -10])\n    true\n    \"\"\"", "    return\
    \ (l[1]<l[2]) && (l[2]<l[3])\nend", "    for i=1:length(l)\n        if l[i] >\
    \ l[i-1]\n            return false\n        end\n    end\n    return true\nend",
  "    l[end]-l[l[1]] <= 0\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\nIf you're looking\
    \ for a vectorized solution, you can use diff and cumsum:\n<code>\nisIncreasing\
    \ = (x .- last) > 0\nlast = x[1]\nreturn last, cumsum(isIncreasing)\n</code>\n\
    <|/ a tags=vectorization,julia,arrays |>\n<| a dscore=0 tags=vectorization,julia,arrays\
    \ |>\nA more modern approach (as of June 2019) would be to use the ismonotonic\
    \ function that is part of StatsBase.jl:\n<code>\nusing StatsBase\nismonotonic([1,2,4,20])\n\
    </code>\nThat will return a boolean vector that is true if each element is increasing,\
    \ false if it is decreasing or if there are no elements left. It also works on\
    \ vectors with different lengths.\n<|/ a |>\n<| a |>\nThe first and last elements\
    \ are sorted, so you can find the first and last indices (indices of sorted array)\
    \ using findfirst() and findlast() and then get the differences between them.\n\
    Example:\n<code>\na = 1:10\n# [1,2,3,4,5,6,7,8,9,10]\nfindfirst(a,a[1]-1)\n# 1\n\
    findlast(a,a[1])\n# 9\ndiff(a[findfirst(a,a[1]-1):findlast(a,a[1])])\n# 3-7\n\
    </code>\n<|/ a dscore=0 tags=vectorization,julia,arrays |>\n<| a tags=vectorization,julia,arrays\
    \ |>\nI prefer to use diff to find the changes in an array or vector and cumsum\
    \ to find how many changes are made in a vector. For example:\n<code>\nusing Statistics",
  "    l = sort(l)\n    for i in 2:length(l); return false if (l[i-1] > l[i]) end;\
    \ return true\nend\n\"\"\"Return the lexicographically first increasing sequence\
    \ from a vector.", "    if len(l) < 2\n        return true\n    if all(l[i] >\
    \ l[i+1] for i in 2:end(l))\n        return true\n    if all(l[i] < l[i-1] for\
    \ i in 2:end(l))\n        return false\n    \n    if l[1] == l[2]\n        return\
    \ false", "    l = sort(l)\n    for i in 2:length(l)\n        if l[i-1] > l[i]\
    \ \n        then return false\n        end \n    end \n    return true\nend "]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
