name: HumanEval_116_sort_array
language: jl
prompt: "\"\"\"\n    In this Kata, you have to sort a vector of non-negative integers\
  \ according to\n    number of ones in their binary representation in ascending order.\n\
  \    For similar number of ones, sort based on decimal value.\n\n    It must be\
  \ implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4])\n    [1, 2, 3, 4,\
  \ 5]\n    >>> sort_array([-2, -3, -4, -5, -6])\n    [-6, -5, -4, -3, -2]\n    >>>\
  \ sort_array([1, 0, 2, 3, 4])\n    [0, 1, 2, 3, 4]\n    \"\"\"\nfunction sort_array(arr::Vector{Int64})::Vector{Int64}\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate([1,\
  \ 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\t@test(candidate([-2, -3, -4, -5, -6]) == [-4,\
  \ -2, -6, -5, -3])\n\t@test(candidate([1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\n\t@test(candidate(Vector{Int64}([]))\
  \ == Vector{Int64}([]))\n\t@test(candidate([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
  \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\t@test(candidate([3, 6, 44, 12, 32, 5])\
  \ == [32, 3, 5, 6, 12, 44])\n\t@test(candidate([2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
  \ 32])\n\t@test(candidate([2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nend\n"
completions: ["    if length(arr)==0 \n        arr\n    elseif length(arr)==1\n  \
    \      arr\n    else\n        sort_array(arr[2:end-1]) + [arr[end],arr[1],arr[end-1]]\n\
    \    end\nend", "    if length(arr) == 0 \n        arr \n    else \n        left_ones\
    \ = count(arr) == 0 \n        arr_dec = dec(arr) \n        arr_dec_sorted = sort(arr_dec)\
    \ \n        left_ones = left_ones or arr_dec_sorted == 0 \n        right_ones\
    \ = count(arr_dec) != 0 \n        arr_sorted = sort(arr) if left_ones == right_ones\
    \ \n        arr_sorted = arr_dec_sorted if left_ones == right_ones \n        if\
    \ left_ones == right_ones \n            arr_sorted \n        else \n         \
    \   arr_sorted + arr_dec_sorted \n        end \n    end \nend \n</code>\n<|/ a\
    \ |>\n<| a |>\nHere is a simple answer without sorting the array\n<code>", " \
    \   sort(arr)\nend", "    idx = Vector{Int64}(sort(collect(arr)))\n    idx2 =\
    \ Vector{Int64}(sort((x->Int(log2(x)))(x)))\n    return idx2.-idx\nend", "   \
    \ \"\"\"\n    Sort given array in ascending order.\n    \"\"\"\n    if arr.length\
    \ == 1 then return arr\n    if arr.length == 2 then\n        if arr[1] == 1 then\
    \ return arr\n        \n        arr2 = copy(arr)\n        arr2[1] = arr[1]\n \
    \       arr2[2] = arr[2]\n        \n        return arr2\n    end", "\"\"\"\n \
    \   Sort the array based on number of ones in its binary representation in ascending\
    \ order.\n\"\"\"\n    arr=deepcopy(arr)\n    s=zeros(Int, length(arr))\n    for\
    \ k in 1:length(arr)\n        s[arr[k]-1]=1\n    end\n    return s\nend", "  \
    \  arr \u2190 sort_array(arr[1 :end]); \n    arr \u2190 sort_array(arr[1 :end]);\
    \ \n    arr \u2190 sort_array(arr[1 :end]); \n    arr\nend\n</cell>\n<code language=julia-1.0>\n\
    sort_array([1, 5, 2, 3, 4])\n</cell>\n<code language=julia-1.0>\nsort_array([-2,\
    \ -3, -4, -5, -6])\n</cell>\n<code language=julia-1.0>\nsort_array([1, 0, 2, 3,\
    \ 4])\n</cell>\n<text>\nPart II: Sort array by its index", "    return sort(arr)\
    \ \nend ", "    arr1 = sort(arr)\n    arr2 = sort(arr1)\n    if arr1==arr2\n \
    \       return arr\n    else\n        arr3 = sort(arr2)\n        arr = arr3\n\
    \        return arr\n    end\nend", "    \n    arr = deepcopy(arr)\n    arr =\
    \ sort(arr)", "    \n    sorted = sort(arr)\n    ones = zeros(Int, length(sorted))\n\
    \    \n    for (i, e) in enumerate(sorted)\n        ones[i] = (e == 1)\n    end\n\
    \    \n    return sorted[findall(ones)] .+ \n            zeros(Float64, (length(ones)\
    \ - length(findall(ones))))\nend", "    arr = sort(arr)\n    arr = arr[(arr &\
    \ ones(length(arr))) != 0]\n    return arr\nend\n</cell>\n<code language=julia-1.0>\n\
    @test sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n@test sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n@test sort_array([1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 3, 4]\n</cell>\n<text>\nPart C: Design a function to do X\nWrite a function\
    \ that given a binary string will return an Integer. The input string may contain\
    \ multiple consecutive zeros. Your function can return nothing or any integer.",
  "    arr = convert(Vector{Int64}, arr)\n    arr2 = arr.clone()\n    sort(arr2)\n\
    \    arr3 = Vector{Int64}(undef, length(arr))\n    for i in 1:length(arr)\n  \
    \      arr3[i] = arr2[i]\n    end\n    arr3\nend\n</code>\n<|/ a tags=sorting,julia,vector,arrays\
    \ |>\n<| a tags=sorting,julia,vector,arrays dscore=3 |>\nThis is a solution that\
    \ avoids allocations (and is a bit more efficient):\n<code>\njulia> sort(\n  \
    \         readdlm(\"testdata/arrays.txt\", Int64, (Int, Int, Int)), \n       \
    \    by=length\n       )\n</code>\nThe benefit of this is that you don't need\
    \ to convert the data to a vector.\n<|/ a |>\n<| a tags=sorting,julia,vector,arrays\
    \ |>\nI came across this problem trying to solve a similar problem, and I came\
    \ up with this solution:\n<code>", "\"\"\"\n    Sort `arr` according to number\
    \ of ones in binary representation in ascending order", "    arr2 = bitcount(arr)\n\
    \    \n    l = zeros(Int64, length(arr2))\n    for (i,e) in enumerate(arr2)\n\
    \        if e == 1\n            l[i] = arr[i]\n        end\n    end\n    \n  \
    \  l = l .> 0 ? l[l .== 1] : l\n    l = l .> 0\n    \n    return sort(l)\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=julia,algorithm,sorting,arrays\
    \ |>\n<code>", "    ones = zeros(Int, length(arr))\n    for i in 1:length(arr)\n\
    \        ones[i] = count_ones(arr[i])\n    end\n    \n    sort!(unique(ones))\
    \ # sort to get unique elements and sort them\n    \n    return arr[ones]\nend",
  "    sortedArray = sort(arr)\n    if sortedArray[1] == 1\n        sortedArray =\
    \ sortedArray[1:end]\n    elseif sortedArray[1] == -1\n        sortedArray = sortedArray[end:1]\n\
    \    else\n        sortedArray = sortedArray\n    end\n    return sortedArray\n\
    end\n</code>\n<|/ a tags=performance,sorting,julia,bit-manipulation dscore=2 |>\n\
    <| a tags=performance,sorting,julia,bit-manipulation |>\nMy solution is almost\
    \ identical to but more succinct:\n<code>", "    counts = zeros(Int64, length(arr))\n\
    \    for x in arr\n        counts[x] += 1\n    end", "        sort(arr)\n    \
    \    for i in eachindex(arr)\n            arr[i] = decbit(arr[i])\n        end\n\
    \        return arr\nend\n</cell>\n<code language=julia-0.5>\nusing Base.Test",
  "    A = zeros(Int64, nb_elements(arr))\n    for (i,val) in enumerate(arr)\n   \
    \     A[val] = i\n    A = vec(sort(A))\n    return A\nend\n</cell>\n<code language=julia-1.5>\n\
    sort_array([1, 5, 2, 3, 4])\n</cell>\n<code language=julia-1.5>\nsort_array([-2,\
    \ -3, -4, -5, -6])\n</cell>\n<code language=julia-1.5>\nsort_array([1, 0, 2, 3,\
    \ 4])\n</cell>\n<text>\nExercise: Find two numbers that when summed, give the\
    \ maximum number of zeros in the binary representation of the number (not necessarily\
    \ in the decimal representation).", "    \"\"\"\n    Sort an array according to\
    \ the number of ones in their binary representation in ascending order.\n    \"\
    \"\"\n    sortby = sort(arr)\n    last = 1\n    for i in sortby\n        if last\
    \ < i\n            last = i\n        elseif last == i\n            last = last\
    \ + 1\n        end\n    end\n    return sortby\nend", "    if all(arr == 0)\n\
    \        sort!(arr)\n        return arr\n    end", "    \n    return \nend", " \
    \   if length(arr) < 1\n        return arr\n    count_arr = zeros(Int, length(arr))\n\
    \    for i=1:length(arr)\n        count_arr[i] = sum(bin(arr[i])[2:end-1] == '1')\n\
    \    end\n    count_arr.sort()\n    arr =  Array(count_arr)\n    arr\nend\n</cell>\n\
    <code language=julia-1.3>\nsort_array([1, 5, 2, 3, 4])\n</cell>\n<code language=julia-1.3>\n\
    sort_array([-2, -3, -4, -5, -6])\n</cell>\n<code language=julia-1.3>\nsort_array([1,\
    \ 0, 2, 3, 4])\n</cell>\n<text>\nProblem 2. Partitioning Arrays\nIn this Kata,\
    \ you will solve the problem of partitioning an array into two partitions where\
    \ the first partition contains all elements greater than the second partition's\
    \ maximum element.", "    vec = deepcopy(arr)\n    sort!(vec)\n    vec\nend",
  "    return sort_array2(arr)\nend", "    sort(arr)\nend\n</cell>\n<text>\nSolution\n\
    Implement the function sort_array here. You should implement the two sorts in\
    \ that order but with different orders of arguments.", "    # return sorted(arr,\
    \ key=lambda x: -bincount(bin(x)[2:], width=8)[::-1])\n    vec = Vector{Int64}(arr)\n\
    \    \n    # count the number of 0s and 1s, reverse it, and sort by decimal value\n\
    \    counts = count!(vec)\n    reverse!(reverse(counts)) \n    sort!(sortperm(counts))",
  "    arr\nend\n</code>\n<|/ a dscore=3 tags=julia,sorting |>\n<| a dscore=2 |>\n\
    You can try this :\n<code>\nsort_array(arr::Vector{Int64}) = \n    arr[(arr .==\
    \ 1) .== 1, :]\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\nJust a side note:\
    \ You can use this for sorting any kind of array\n<|/ c |>\n<| a tags=julia,sorting\
    \ dscore=1 |>\nYou can also use a different sort:\n<code>", "    \n    lenarr\
    \ = length(arr)\n    if lenarr == 0 \n        return arr \n    \n    onearr =\
    \ 0\n    odd_sum = 0\n    for i \u2208 1:lenarr \n        if arr[i] == 1 \n  \
    \          onearr \u2190 onearr + 1 \n        else \n            if onearr ==\
    \ 1 \n                odd_sum \u2190 odd_sum + arr[i] \n            elseif arr[i]\
    \ < 0 \n                odd_sum \u2190 odd_sum - arr[i] \n            elseif arr[i]\
    \ > 0 \n                odd_sum \u2190 odd_sum + arr[i] \n                onearr\
    \ \u2190 0 \n            end \n        end \n    end \n    \n    odd_ones = odd_sum\
    \ - onearr \n    \n    if odd_ones > 0 \n        return sort_array(reverse(arr[end+1:end+odd_ones+1]))\
    \ + \n            reverse(arr[end+1:end+odd_ones])\n    elseif odd_ones < 0 \n\
    \        return sort_array(reverse(arr[end+1:end+odd_ones+1])) + \n          \
    \  reverse(arr[end:end+odd_ones+1])\n    elseif odd_ones == 0 \n        return\
    \ arr\n    else \n        return sort_array(reverse(arr[end+1:end+odd_ones+1]))\n\
    \    end \nend \n</cell>\n<code language=julia-1.4>\n\"\"\"\n    In this Kata,\
    \ you have to decode a string with ROT13 encryption\n    and decode the same string\
    \ with the decryption of ROT13.", "    return sort(arr) # return sorted array\n\
    end\n</code>\nTesting:\n<code>\njulia> sort_array([1, 5, 2, 3, 4])\n1-element\
    \ Array{Int64,1}:\n 2\n 3\n 4\n 5\n 1", "    \"\"\"\n    This function should\
    \ sort a vector of non-negative integers according to\n    number of ones in their\
    \ binary representation in ascending order.\n    For similar number of ones, sort\
    \ based on decimal value.\n    \"\"\"\n    \n    if length(arr)<=1 \n        return\
    \ arr \n    \n    \n    \n    \n        \n    \n    ", "    # arr is the input\
    \ vector \n    sz = length(arr)\n    # initialize a new vector to store sorted\
    \ output\n    sorted_arr = zeros(Int64, sz)\n    # count number of ones in the\
    \ input vector arr\n    count = zeros(Int, sz)\n    for i in arr\n        count[i]\
    \ = (1 .== i)\n    end\n    for i in 1:length(arr)\n        # sort the indices\
    \ of elements whose number of ones is less than or equal to count[i]\n       \
    \ sorted_arr[i] = findfirst(i -> count[i] <= 1, indmax(count))\n        # increment\
    \ the count of elements whose number of ones is greater than or equal to count[i]\n\
    \        count[sorted_arr[i]] += 1\n    end\n    return sorted_arr\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=sorting,julia |>\nThis was an interesting exercise,\
    \ but I found it very difficult to do in Julia. So I thought I'd share my solution:\n\
    <code>", "    sortedarr = copy(arr)\n    for i in 1:length(arr)\n        if arr[i]\
    \ == 0\n            sortedarr[i] = 0\n        else\n            pos = findall(x->x==1,\
    \ reverse(arr[1::-1]))[1]\n            sortedarr[i] = arr[pos]\n            sortedarr[pos]\
    \ = 0\n        end\n    end\n    sortedarr\nend\n</code>\n<|/ a tags=sorting,julia\
    \ dscore=3 |>\n<| a |>\nA simple sorting function for the case of the sorted array\
    \ is as follows:\n<code>\njulia> function sort_by_ones(arr::Vector{Int})\n   \
    \        pos = 0\n           for i in 1:length(arr)\n               if arr[i]\
    \ == 1\n                   pos = i\n               end\n           end\n     \
    \      sortedarr = copy(arr)\n           sortedarr[pos] = length(arr) + 1\n  \
    \         sortedarr\n       end", "    arr = arr:sort()\n    vec = Vector{Int64}(undef,\
    \ length(arr))\n    for i in eachindex(arr)\n        if arr[i] == 0\n        \
    \    vec[i] = 1\n        else\n            vec[i] = 2\n        end\n    end\n\
    \    return vec\nend\n</code>\n<|/ a tags=julia dscore=1 |>\n<| c |>\nThe original\
    \ question was about sorting an array of numbers. Your solution is about sorting\
    \ a vector of booleans.\n<|/ c |>\n<| a |>\nIn case you have a vector/array of\
    \ booleans, you can convert them into integers using sum.\n<code>\njulia> bools\
    \ = [true, false, true]\njulia> bools = Int[sum(b == 0 for b in bools)] \n1-element\
    \ Array{Int64,1}:\n 2\n</code>\n<|/ a tags=julia dscore=1 |>\n<| a dscore=1 |>\n\
    Based on other answers I came up with a solution that avoids creating any temporary\
    \ arrays:\n<code>", "    sorted = sort(arr)\n    binary = reverse(sorted.map(x\
    \ -> dec2bin(x) == x)[sorted.indices])\n    decimal = reverse(sorted.map(x ->\
    \ bin2dec(x) == x)[sorted.indices])\n    return sorted .+ sorted.indices + 1 +\
    \ binary.zip(decimal)\nend", "    \"\"\"\n    Sorts arr into ascending order.\n\
    \    \"\"\"\n    if length(arr) <= 1\n        return arr\n    \n    arr_copy =\
    \ copy(arr)\n    \n    sort(arr_copy)\n    \n    return arr_copy\nend", "    \"\
    \"\"\n    Vector{Int64} -> Vector{Int64}", "    sort_idx = Array{Int64, 1}(undef,\
    \ length(arr))\n    \n    sort_idx[1:length(arr)] = argsort(arr)\n    \n    arr_sorted\
    \ = arr[sort_idx]\n    \n    sort(arr_sorted)\n    return arr_sorted", "    \"\
    \"\"\n    Helper function: \n    Sort the given array of integers according to\
    \ the number of ones in their binary representation in ascending order.\n    \"\
    \"\"\n    n = zeros(Int, length(arr))\n    for i = 1:length(arr)\n        n[i]\
    \ = count_ones(arr[i])\n    end\n    return sortperm(n) .+ arr .+ sortperm(n -\
    \ cumsum(n))\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nCan you please explain\
    \ how you arrived at the solution?\n<|/ c |>\n<| c |>\nHi Wyzard, I actually did\
    \ this myself, but I thought there would be a more elegant solution, which I thought\
    \ would be hard to find. \nThe code basically creates a vector of counts of each\
    \ 1-bit number, and then sorts it according to number of 1s.\n<|/ c |>\n<| c |>\n\
    thank you very much for the detailed description! I'm still trying to wrap my\
    \ head around it. I found it weird that you have to subtract cumsum() from the\
    \ result of sortperm(). Is there any good reason for that?\n<|/ c |>\n<| c |>\n\
    I edited my answer to include an explanation of `cumsum`.\n<|/ c |>\n<| c |>\n\
    Thank you for the explanation. I've tried implementing your solution, but I'm\
    \ getting an error. My implementation is basically the same, but I get a `MethodError\
    \ (no method matching length(::Int64) at ...)` error when I try to use your function\
    \ with `sort_array([1, 5, 2, 3, 4])`. I'm not sure how that happens. I tried debugging\
    \ it and it seems like `length(arr::Vector{Int64})` doesn't get called for some\
    \ reason, so I suspect that my implementation might be wrong. Any ideas?\n<|/\
    \ c |>\n<| a |>\nMy attempt:\n<code>\nsort_array(x) = [y[1:end-1] for y in sort(sort(x),by=identity)]\n\
    </code>\nIt sorts the array and returns the sorted array. Maybe not the most elegant\
    \ code, but it works.\n<|/ a tags=arrays,julia,sorting dscore=1 |>\n<| c |>\n\
    Thank you, this is a nice solution. However, I went with the other solution that\
    \ I posted on my own answer.\n<|/ c |>\n<| a tags=arrays,julia,sorting |>\nThis\
    \ is my solution:\n<code>\nsort_array(arr::Vector{Int64}) = sortperm(arr .* (Int[1\
    \ for i in eachindex(arr)]))\n</code>\n<|/ a dscore=1 |>\n<| a |>\nAnother possibility\
    \ (that I have personally used) is to use map", "    \n    ones = one_indices(arr)\n\
    \    sorted = sort(ones)\n    \n    if arr == sorted\n        sorted == sort(arr)\n\
    \    else\n        sorted\n    end\nend\n</cell>\n<code language=julia-0.5>\n\
    using Base: ==, <, <=\n</cell>\n<code language=julia-0.5>\nones = one_indices(arr)\n\
    sorted1 = sort(ones)\nsorted2 = sort(arr)", "    #initialize array with the size\
    \ of arr\n    arr2 = Array.zeros(length(arr))\n    \n    # loop through the array\n\
    \    for i = 1:length(arr)\n        arr2[i] = count_one_bits(arr[i])\n    end\n\
    \    \n    # sort arr2 based on arr order\n    arr2.sort()\n    return arr2\n\
    end\n</code>\n<|/ a |>\n<| a dscore=1 |>\nHere is a solution using Julia's bitwise\
    \ operations:\n<code>", "    sort(arr)\nend", "    \"\"\"Sort an array according\
    \ to their binary representation in ascending order\"\"\"\n    if arr == []\n\
    \        return []\n    n = length(arr)\n    ones = zeros(Int, n)\n    decs =\
    \ zeros(Int, n)\n    for j in 1:n\n        ones[j] = sum(arr[j:j+2]) == 1 ? 1\
    \ \n            : sum(arr[j:j+2]) == 0 ? 0\n            : sum(arr[j:j+2])\n  \
    \      decs[j] = sum(arr[j:j+2]) == 0 ? 0\n            : sum(arr[j:j+2]) == 1\
    \ ? 1\n            : arr[j] - sum(arr[j:j+2])\n    end\n    decs = [decs[i] <\
    \ decs[i+1] ? decs[i] : decs[i+1] for i=1:length(decs)]\n    return decs > 0 ?\
    \ decs\n            : decs < 0 ? reverse(decs)\n            : reverse(sort(decs)) ",
  "    vec=Vector{Int64}(length(arr))\n    for i in 1:length(arr)\n        vec[i]=length(arr[i])-length(findall(x\
    \ -> x==1, arr[i]))\n    end\n    for i in 1:length(arr)\n        arr[i]=arr[i][1:(length(arr[i])-length(findall(x\
    \ -> x==1, arr[i])))]\n    end\n    arr\nend\n</code>\n<|/ a tags=arrays,sorting,julia,algorithm\
    \ |>\n<| c |>\nPlease add some explanation to your answer, such that others can\
    \ learn from it\n<|/ c |>\n<| a dscore=1 |>\n<code>\nsort_array(arr) = sortperm(arr)\n\
    </code>\n<|/ a tags=arrays,sorting,julia,algorithm |>\n<| a |>\nI like these solutions\
    \ but I found another one that I liked. It is similar to that of Shih Yun, with\
    \ some extra functional programming techniques.\n<code>", "    if arr == [] then\
    \ return [] \n    zeros = findall(x-> x == 0, arr) \n    arr[(arr[zeros] == 1)]\
    \ = -arr[arr[zeros]]\n    arr[(arr[zeros] > 0)] = arr[arr[zeros]]\n    arr[(arr[zeros]\
    \ > 0)] = -arr[arr[zeros]]\n    return arr \nend", "\"\"\"\n    Implement this\
    \ function to sort a vector of non-negative integers.", "    arr = sort(arr) \n\
    \    return arr\nend", "    \"\"\"\n    Helper method to sort the given array,\
    \ given its element type is Int64.", "  \n    sorted = zeros(size(arr))\n    count\
    \ = 0\n    \n    for i in arr\n        push!(sorted, i)\n        if 1 == count\n\
    \            push!(sorted, 0)\n            count = 0\n        else\n         \
    \   count += 1\n        end\n    end\n    \n    sorted\nend", "    \n    return\
    \ arr\nend", "    if length(arr)==0\n        return arr\n    twos = zeros(Int64,\
    \ length(arr))\n    for i in 1:length(arr)\n        twos[i] = (2^(arr[i]))-1\n\
    \    end\n    return twos[sortperm(twos)]\nend", "    return arr[arr .!= 0] .+\
    \ arr[arr .!= 0] .> 0\nend", "    A = sort(arr)\n    A = A.map(x -> x == 0 ? x\
    \ : x + 2^ceil(log2(x)))\n    return A\nend\n</cell>\n<code language=julia-1.0>\n\
    sort_array([1, 5, 2, 3, 4])\n</cell>\n<code language=julia-1.0>\nsort_array([-2,\
    \ -3, -4, -5, -6])\n</cell>\n<code language=julia-1.0>\nsort_array([1, 0, 2, 3,\
    \ 4])\n</cell>\n<text>\n\u0423\u0431\u0438\u0440\u0430\u0435\u0442 \u0438\u0441\
    \u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0435 \u0441 \u043F\u043E\u043C\u043E\
    \u0449\u044C\u044E try-finally \u043A\u043E\u0434\u0430\n\u041C\u043E\u0434\u0438\
    \u0444\u0438\u043A\u0430\u0446\u0438\u044F \u0438\u0437 \u0431\u0438\u0431\u043B\
    \u0438\u043E\u0442\u0435\u043A\u0438 try \u0438 catch\n\u0411\u0435\u0437 \u043D\
    \u0435\u0433\u043E \u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E\u0441\u0442\
    \u044C \u0438\u0437\u0432\u043B\u0435\u0447\u044C \u0442\u043E \u0436\u0435 \u0441\
    \u0430\u043C\u043E\u0435, \u043D\u043E \u043D\u0435 \u0442\u043E\u043B\u044C\u043A\
    \u043E \u0444\u0443\u043D\u043A\u0446\u0438\u0438, \u0430 \u043C\u0435\u0442\u043E\
    \u0434\u044B\ntry-finally\ntry-catch \u0438\u0441\u043F\u043E\u043B\u044C\u0437\
    \u0443\u0435\u0442\u0441\u044F \u0442\u043E\u043B\u044C\u043A\u043E \u0447\u0430\
    \u0441\u0442\u0438\u0446\u0430 \u0432\u044B\u0440\u0430\u0436\u0435\u043D\u0438\
    \u044F, \u043A\u043E\u0442\u043E\u0440\u0443\u044E \u0435\u0449\u0435 \u043D\u0435\
    \ \u0432\u043E\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442\u0441\u044F\ntry-catch-finally",
  "    arr = sort(arr)\n    arr = arr[arr[findall(arr != 0)]]\n    return arr\nend",
  "    for n in arr\n        if n >= 0\n            ones = n & 1\n            if ones\
    \ > 0\n                n -= 1\n            else\n                n += 1\n    \
    \    end\n    end\n    sort!(arr)\n    return arr\nend\n</cell>\n<text>\n4.4 Practice\
    \ with Sorting\n4.4.1 Sorting Strings\nIn this Kata, you have to sort a string\
    \ according to its length in ascending order.", "    sorted = sort_array2(arr)\n\
    \    return sorted", "    vecs = arr.map(function(x) sum((x==1).bits))\n    return\
    \ vecs\nend", "    \"\"\"\n    Implement this function\n    \"\"\"\nend", "  \
    \  for i in 2:length(arr)\n        if arr[i-1] < arr[i]\n            tmp =  arr[i-1]\n\
    \            arr[i-1] = arr[i]\n            arr[i] = tmp\n        end\n    end\n\
    \    arr\nend\n</code>\n<|/ a tags=sorting,julia |>\n<| a tags=sorting,julia |>\n\
    Here's another approach. I found it a bit easier to implement than sorting by\
    \ length, but this could also possibly be faster if one can vectorize the comparison\
    \ function.\n<code>", "    \n    local result = vec(Int64, length(arr))\n    local\
    \ idx = 0\n    for x in arr\n        idx = idx + (x % 2)\n        result[idx]\
    \ = x\n    end\n    return result\nend\n</code>\n<|/ a |>\n<| c |>\nThanks for\
    \ your answer. The `Array` type can handle Int64 values directly, so there is\
    \ no need for `Int` here.\n<|/ c |>\n<| a |>\nHere's a quick solution that is\
    \ similar to your solution.  Basically, we just sort the numbers using a naive\
    \ bubble sort.\n<code>", "    \"\"\"\n    Sort a vector of non-negative integers\
    \ according to number of ones in their binary \n    representation in ascending\
    \ order. For similar number of ones, sort based on decimal \n    value.\n    \"\
    \"\"\n    \n    let res = []\n    for i in arr\n        if 0 == bin(i).find(\"\
    1\")\n            push!(res, i)\n        elseif 0 == bin(i).find(\"0\")\n    \
    \        push!(res, -1)\n        else\n            push!(res, i-bin(i).count(\"\
    1\"))\n        end\n    end\n    res\nend\n</cell>\n<code language=julia-1.4>\n\
    sort_array([1, 5, 2, 3, 4])\n</cell>\n<text>\nQuestion 9\nImplement a function\
    \ that sorts a vector of non-negative integers according to their absolute value.",
  "    \"\"\"\n    Sort vector in descending order.\n    \"\"\"\n    if length(arr)\
    \ <= 1\n        return arr\n    local res = sort(arr)\n    for ii = 2:length(arr)\n\
    \        if arr[ii] != res[end]\n            res[end] = arr[ii]\n        end\n\
    \    end\n    return res\nend", "\tsorted_array = arr.copy()\n\tnum_ones_array\
    \ = arr.copy()\n\tnum_ones_array[num_ones_array==0] = 1\n\tnum_bits_array = num_ones_array.^2\n\
    \tnum_bits_array[num_ones_array==0] = 1\n\tsort_bits(num_bits_array,sorted_array)\n\
    \treturn sorted_array\nend\n\t", "    n = length(arr)\n    m = map(i -> sum(arr),\
    \ arr)\n    # binary representation of each value\n    bin = map(i -> i==1 ? 1\
    \ : 0, arr)\n    # sorting\n    sort(collect(m), by=bitsort); # sort the number\
    \ of ones\n    sort(collect(m), by=bitsort,rev=true); # sort the decimal values\n\
    \    # re-index\n    arr = arr .+ (0:(n-1))\n    return arr\nend\n</code>\n<|/\
    \ a tags=sorting,julia |>\n<| a tags=sorting,julia |>\nThis question is actually\
    \ a follow-up to https://stackoverflow.com/a/62636870/335265.\nHere's another\
    \ way:\n<code>\nsort_array x\n    arr = []\n    m, n = size(x)\n    if n > 0\n\
    \        push!(arr,x)\n        while n > 0\n            push!(arr, copy(x[rand(1:n)]))\n\
    \            x .-= copy(x[rand(1:n)])\n        end\n        sort(arr, by=rand)\n\
    \    else\n        arr\n    end\nend\n</code>\nwhich produces deterministic results:\n\
    <code>\njulia> sort_array([1,5,2,3,4])\n4-element Array{Int64,1}:\n 1\n 2\n 3\n\
    \ 4\n</code>\nand also returns an empty array if you provide an empty array:\n\
    <code>\njulia> sort_array([])\n0-element Array{Int64,1}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a |>\nHere's another way: create a vector of indices and sort them based\
    \ on a random ordering:\n<code>\njulia> sort_array x\n    arr = []\n    m, n =\
    \ size(x)\n    if n > 0\n        push!(arr,x)\n        while n > 0\n         \
    \   push!(arr, rand(1:n)) \n            x .-= rand(1:n)\n        end\n       \
    \ sort(arr, by=rand)\n    else\n        arr\n    end\nend\n</code>\n<|/ a tags=sorting,julia\
    \ dscore=1 |>\n<| c |>\nI think a while loop is unnecessary here. You can do `arr\
    \ .= rand(1:n); x .-= arr`\n<|/ c |>\n<| a tags=sorting,julia |>\nFor a general\
    \ case without specifying the length of vector, you can try this:\n<code>", " \
    \   sorted_arr=copy(arr)\n    for i in (length(arr)-1):reverse(collect(eachslice(sorted_arr))))\n\
    \      \n        for j in i:sort_arr[j]=sort_arr[j] or sort_arr[j]+1\n    end\n\
    \    sorted_arr\nend", "    if length(arr)==0 \n        arr \n    else\n     \
    \   sorted(arr, by = t -> popcount(t)) \n    end\nend\n</cell>\n<text>\nPart 2\
    \ - Bringing it all together\nNow that we have the basic framework, let's put\
    \ it all together by implementing a function that can sort an arbitrary number\
    \ of arrays of integers and strings according to some given criteria.\nAs always,\
    \ remember: you can write one line of code and then execute it line by line.",
  "    zeros = zeros(Int64, length(arr))\n    ones = zeros(Int64, length(arr))\n \
    \   ones_index = zeros(Int64, length(arr))\n    zeros_index = zeros(Int64, length(arr))\n\
    \    for idx in 1:length(arr)\n        mask = convert(BitArray, arr[idx])\n  \
    \      if sum(mask[findfirst(zeros)])\n            zeros_index[idx] = idx\n  \
    \      end\n        if sum(mask[findfirst(ones)])\n            ones_index[idx]\
    \ = idx\n        end\n        if sum(mask) == 0\n            zeros[idx] = 1\n\
    \        end\n        if sum(mask) == 1\n            ones[idx] = 1\n        end\n\
    \    end", "    \n    # Initialize new vector for sorting\n    vec_sort = copy(arr)",
  "    \"\"\"\n    Sort the vector. ", "\"\"\"\n    Sort an array of non-negative\
    \ integers according to number of ones in their binary representation in ascending\
    \ order.\n    For similar number of ones, sort based on decimal value.", "   \
    \ return sort(arr)\nend\n</cell>\n<text>\nNow that you know what to do, let's\
    \ do the exercise.", "    \"\"\"Sort an array of non-negative integers according\
    \ to number of ones in their binary representation in ascending order.\"\"\"\n\
    \    ones = arr.filter(i -> i==1)\n    largest = first(ones)\n    if largest==0\n\
    \        return sort(arr)\n    pos = find(arr>largest)\n    if pos==length(arr)\n\
    \        return reverse(arr)\n    end1 = pos+1\n    ones1 = arr[pos:end1]\n  \
    \  smallest = first(ones1)\n    if smallest==0\n        return reverse(sort_array(reverse(arr)))\n\
    \    end2 = pos\n    ones2 = arr[pos:end2]\n    largest = first(ones2)\n    if\
    \ largest==0\n        return reverse(sort_array(reverse(arr)))\n    return reverse(sort_array(reverse(sort_array(reverse(arr)))))\
    \ \nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nIt's better to post some explanations\
    \ along with codes.\n<|/ c |>\n<| c |>\nA better alternative would be to create\
    \ a dictionary of the binary representation of numbers in the sorted array, and\
    \ then sort on the dictionary keys.\n<|/ c |>\n<| c |>\nWhat about `sort_array(Int64.(collect(1:10)))`?\n\
    <|/ c |>\n<| c |>\n, that would work for `Int64`. If you want to sort a `Vector{Int64}`\
    \ in a different way, you could also use the `sort!` function from the [`sort`](https://github.com/JuliaLang/julia/blob/master/base/sort.jl)\
    \ package\n<|/ c |>\n<| a |>\nAnother option to consider:\n<code>", "    \"\"\"\
    \ Write your code here! \"\"\"\n    sortInd = arr.sort\n    onesInd = findIndices(sortInd)\n\
    \    return arr[onesInd]\nend\n</code>\n<|/ a dscore=2 tags=julia,sorting,arrays\
    \ |>\n<| a tags=julia,sorting,arrays |>\nThe accepted answer is good, but it is\
    \ inefficient for large arrays. Here is a more efficient version, inspired by\
    \ this answer:\n<code>", "    arr = arr[:]\n    \n    \n    \n    if arr.length\
    \ == 1\n        return arr\n    end", "    res=Vector{Int64}()\n    i=0\n    \n\
    \    while i<length(arr)\n        if arr[i]==1\n            push!(res,arr[i])\n\
    \        else\n            push!(res,0)\n        end\n        i+=1\n    end\n\
    \    \n    while i<length(arr)\n        if arr[i]==1\n            push!(res,0)\n\
    \        else\n            push!(res,arr[i])\n        end\n        i+=1\n    end\n\
    \    \n    return res\nend\n</cell>\n<code language=julia-1.5>\nsort_array([-2,\
    \ -3, -4, -5, -6])\n</cell>\n<code language=julia-1.5>", "    ...\nend", "   \
    \ #\n    # write your answer here\n    # arr::Vector{Int64}\n    # res::Vector{Int64}\n\
    \    \n    ones = ones(length(arr))\n    res  = sort(arr)\n    \n    for (i, j)\
    \ in zip(ones, res) \n        if i >= j\n            res[j], res[i] = res[i],\
    \ res[j]\n        end\n    end", "    if arr.iszero()\n        throw(ArgumentError(\"\
    invalid input: array of zero length\"))\n    end\n    sorted = unique(arr)\n \
    \   return sorted\nend\n</cell>\n<code language=julia-1.5>\n@time sort_array([1,\
    \ 5, 2, 3, 4])\n@time sort_array([-2, -3, -4, -5, -6])\n@time sort_array([1, 0,\
    \ 2, 3, 4])\n</cell>\n<text>\nProblem 3\nImplement the function count_ones(i::Int64)::Int64,\
    \ which returns the number of ones in binary representation of i.", "    return\
    \ arr\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nSorry but this doesn't work.\n\
    It just sorts the values lexicographically which is not what was intended. The\
    \ order of the values needs to be descending as shown in the example output.\n\
    <|/ c |>\n<| a tags=sorting,julia |>\nAs an alternative to 's answer, you can\
    \ also use the built-in function sortperm(...) which sorts indices of a vector\
    \ in ascending or descending order according to the input criteria.\n<code>\n\
    julia> sortperm(x, iszero)\n4-element Array{Int64,1}:\n 2\n 1\n 3\n 7\n</code>\n\
    <|/ a dscore=0 |>\n<| a |>\nI came across this question because I was trying to\
    \ solve a similar problem in Julia. I was using DataFrames.jl to construct a table\
    \ of data and needed a way to sort it. My situation was slightly different, though,\
    \ and I used the method from here: How to sort a DataFrame by values of one column\
    \ with two other columns being equal?. \n<code>\ndf = DataFrame(x=rand(5), y=rand(5),\
    \ z=rand(5), w=rand(5), \n               x1=rand(5), y1=rand(5), z1=rand(5), w1=rand(5))\n\
    df\n</code>\nI wanted to sort by the z column of the DataFrame, but I didn't want\
    \ to sort by the x or y columns or the w column, so I created a list of tuples\
    \ containing the columns I wanted to sort by, in this case z and z1:\n<code>\n\
    tups = [tuple([\"z\", \"z1\"]), tuple([\"z\", \"z1\"])]\n</code>\nI then used\
    \ the sort_at method like so:\n<code>\ndf[sort_at(df, tups)];\n</code>\nThis resulted\
    \ in an output that was sorted the way I needed it to. \n<code>\njulia> df[sort_at(df,\
    \ tups)]\n2\xD75 DataFrame\n Row \u2502 x  y  z  w  x1  y1  z1  w1\n     \u2502\
    \ Float64  Float64  Float64  Float64  Float64  Float64\n\u2500\u2500\u2500\u2500\
    \u2500\u253C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\
    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\
    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\
    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\
    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\
    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1\
    \ \u2502 0.268889  0.248708  0.772023  0.707916  0.291881  0.698931\n   2 \u2502\
    \ 0.394412  0.680581  0.793493  0.545467  0.395726  0.432695\n</code>\n<|/ a tags=sorting,juli",
  "    if arr.size == 0 \n        return arr\n    \n    binarr = zeros(Int, length(arr))\n\
    \    for i in eachindex(arr)\n        binarr[i] = countBits(arr[i])\n    end\n\
    \    \n    binarr = vec(binarr)\n    return sort(binarr)\nend\n</cell>\n<code\
    \ language=julia-1.0>\nsort_array([1, 5, 2, 3, 4])\n</cell>\n<code language=julia-1.0>\n\
    sort_array([-2, -3, -4, -5, -6])\n</cell>\n<code language=julia-1.0>\nsort_array([1,\
    \ 0, 2, 3, 4])\n</cell>\n<text>\n13. Find median in array", "    if length(arr)<2\
    \ \n        return arr\n    counts = count(arr)\n    pos = getindex.(counts,0)\n\
    \    neg = counts[pos].-1\n    sort!(arr, pos=pos, neg=neg)\n    sort!(arr, neg=neg,\
    \ pos=pos)\n    return arr\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>\n\
    let sort2(x) = sort(x,by=length) # sort from most to least length\nlet sort3(x)\
    \ = sort(x,by=x>0) # sort from most to least zero\nlet sort4(x) = sort(x,by=x>1)\
    \ # sort from most to least one\n</code>\nThen I compared them like these:\n<code>\n\
    julia> sort2(1:10) # sort from most to least length\n5-element Vector{Int64}:\n\
    \ 2\n 1\n 3\n 4\n 5", "    if arr.size <= 1 \n        return arr\n    end\n  \
    \  binarr = zeros(Int64, arr.size)\n    for a in arr\n        binarr[a+1] += 1\n\
    \    end\n    binarr ./= sum!(binarr)\n    sort(binarr, by = x->x)\n    return\
    \ arr\nend\n</code>\n<|/ a tags=function,julia,arrays |>\n<| c |>\n`sort_array(reverse(arr))`\
    \ seems to be equivalent to `sort!(arr, by = x -> x)`. Also, `arr.size == length(arr)`\
    \ looks weird.\n<|/ c |>\n<| c |>\n`arr.size == length(arr)` is to ensure the\
    \ vector is not empty (otherwise `sort!(arr, by = x -> x)` will throw an error),\
    \ but it should be `arr.size == 1` since `sort!` will still be called on an empty\
    \ vector (`sort!(Int64, Int64[])` will throw an error for sure).\n<|/ c |>\n<|\
    \ c |>\nIn your first comment you wrote `arr.size == length(arr)`. This does not\
    \ seem to work. Using `length` on `arr` throws an error.\n<|/ c |>\n<| c |>\n\
    The answer is now edited to fix that.\n<|/ c |>\n<| a tags=function,julia,arrays\
    \ |>\nHere's my solution:\n<code>", "    sort(arr)\nend", "  sort_array_helper(arr,\
    \ [], 0)\nend", '    """Sort an array in ascending order', "    sort_array(sort(arr))\n\
    end\n</cell>\n<text>\nTest your sort function\nRun the cell below to test your\
    \ sort function.", "\"\"\"\n    I added some comments to the code because I didn't\
    \ know what to do with them!\n\"\"\"\n    # I sort the array!\n    \n    function\
    \ reverse_binary_number(x::Int64)\n        \n        # I create a binary array\n\
    \        function binary_array(x)\n            binary_array = zeros(UInt8, 10)\n\
    \            binary_array[8] = 1 << (8 - x)\n            binary_array[7] = 1 <<\
    \ (7 - x)\n            binary_array[6] = 1 << (6 - x)\n            binary_array[5]\
    \ = 1 << (5 - x)\n            binary_array[4] = 1 << (4 - x)\n            binary_array[3]\
    \ = 1 << (3 - x)\n            binary_array[2] = 1 << (2 - x)\n            binary_array[1]\
    \ = 1\n            return binary_array\n    end\n    \n    # I iterate over the\
    \ array, count the ones\n    one_count = 0\n    for x in arr\n        # I reverse\
    \ the bits (I call them binary digits)\n        y = reverse_binary_number(x)\n\
    \        one_count += y != 0\n    end\n    \n    # I sort the array\n    ones\
    \ = zeros(Int64, length(arr))\n    for j in 1:length(arr)\n        ones[one_count[j]]\
    \ = arr[j]\n    end\n    return ones\nend\n</code>\n<|/ a tags=arrays,julia,sorting\
    \ |>\n<| a dscore=2 |>\nUsing Julia 0.7, this can be done quite simply using Int64's\
    \ reinterpreting constructor and sorting:\n<code>\nusing Statistics\nsort_array(arr::Vector{Int64})\
    \ = sort(reinterpret(UInt8,arr))\n</code>\n<|/ a tags=arrays,julia,sorting |>\n\
    <| c |>\nThis doesn't give the same output as the example given above.\n<|/ c\
    \ |>\n<| c |>\nIt does. I ran this in Julia 0.7.2\n<|/ c |>\n<| c |>\nOh, I'm\
    \ sorry. I didn't notice that `sort` has a `sorted` argument. Maybe you should\
    \ add that to it as well (I thought Julia sort was just ascending by default).\
    \ Anyway, I'm happy you posted it.\n<|/ c |>\n<| a |>\nIf you use bitarray package,\
    \ it can be done like this:\n<code>\njulia> using BitArrays\njulia> sort_array([1,2,3,4,5])\n\
    5-element BitVector:\n 1\n 2\n 3\n 4\n 5", "    sort_idx = [i for i in arr.indices\
    \ sortby((arr.data[i]) <=> 1)]\n    return arr[sort_idx]\nend", "    if length(arr)\
    \ == 0 then \n        return arr\n    end\n    sort!(arr, by=x->length(findall(x\
    \ .== 1)[0]), rev=true)\n    sort!(arr, by=x->x.decimal(), rev=true)\n    return\
    \ arr\nend\n</cell>\n<text>\nPart 5: String Manipulation\nWrite a function that\
    \ removes all occurrences of one string from another.\nFor example, if you have\
    \ a string \"Hello, world! Hello world!\", and you\nremove \"Hello\", the result\
    \ will be \"world! World!\"", "    ones = findall(arr .== 1)\n    decimal = sum(arr\
    \ .== 1)\n    if length(ones) < length(decimal)\n        temp = ones\n       \
    \ ones = decimal\n        decimal = temp\n    end\n    return reverse(sort(ones,\
    \ decimal))\nend", "    \"\"\"Sort an array in ascending order\"\"\"\n    zero,\
    \ one, two, three = 0, 0, len(arr)-1, len(arr)\n    while zero < three\n     \
    \   zero += 1\n        one += 1\n        while two > one\n            two -= 1\n\
    \            three = zero\n            while three < two\n                if arr[three]\
    \ == 0\n                    arr[zero], arr[three] = arr[three], arr[zero]\n  \
    \              three += 1\n            zero -= 1\n    return arr\n</code>\n<|/\
    \ a |>\n<| a dscore=1 tags=sorting,julia |>\nHere is an implementation with a\
    \ stable merge sort. It works with any type for which the sort is stable and can\
    \ be done in O(n).\n<code>", "    \n    sortedArr=sort(arr)\n    sortedArr=sort(sortedArr,by=function\
    \ (x::Int64) abs(x))\n    sortedArr\nend\n</cell>\n<code language=julia-1.2>\n\
    #hide\nusing Test\nusing CairoMakie\n</cell>\n<text>\nVisualize your Solution",
  "    ones = ones(size(arr))\n    arr = sort(arr)\n    return map(x -> x == 1 ? ones[x]\
    \ : x, arr)\nend\n</code>\nThe result is:\n<code>\njulia> sort_array([1, 5, 2,\
    \ 3, 4])\n5-element Array{Int64,1}:\n 1\n 5\n 2\n 3\n 4", "    sort(arr)\nend",
  "    if length(arr)<=1\n        arr\n    else\n        sort_array(arr[2:end-1])\
    \ + [arr[1]] + sort_array(arr[1:end-1])\n    end\nend", "    if arr.length < 2\
    \ \n        return arr \n    else \n        a = arr[1]\n        last = arr |>\
    \ reverse!\n        arr := arr[2:end]\n        for b in last \n            arr[last.index(b)]\
    \ := b \n        end\n        arr := reverse(arr) \n        arr[last.index(a)]\
    \ := a \n        return arr \n    end\nend\n</cell>\n<text>\nThe most significant\
    \ bit is 1 if the element is one, and 0 if it is not.", "    \"\"\"\n    Implement\
    \ your code here\n    \"\"\"\n    if arr[1] == 0 \n        arr = arr[2:end]\n\
    \    else \n        arr = arr[1:end-1]\n    end\n    return arr\nend\n</code>\n\
    Now it is straight forward to call the sort function on your vector:\n<code>\n\
    julia> sort_array([1, 0, 2, 3, 4])\n[0, 1, 2, 3, 4]\n</code>\nAs you can see,\
    \ our sort function does exactly what the name says: It sorts the vector according\
    \ to number of ones in their binary representation. Since this kind of sorting\
    \ is quite common and it is also a very efficient algorithm, it is implemented\
    \ as a built-in function in Julia called sort!.\n<|/ a tags=arrays,julia,sorting\
    \ dscore=2 |>\n<| c |>\nThis looks great! But unfortunately the problem with your\
    \ solution is that it does not work for arrays of more than 10 elements. I am\
    \ still trying to figure out how to make it work. Do you think you can help me\
    \ with this?\n<|/ c |>\n<| c |>\nThe problem is that your solution sorts arrays\
    \ in ascending order. As soon as you try this with bigger arrays, you end up with\
    \ wrong results. My solution works with bigger arrays but in descending order.\n\
    <|/ c |>\n<| c |>\nIt will work for bigger arrays, just change the line `if x\
    \ > y` in the `is_sorted_desc!` function to `if x < y`\n<|/ c |>\n<| c |>\nThat\
    \ is a great solution! It doesn't work for bigger arrays. However, I managed to\
    \ get a working solution with your help: https://pastebin.com/3W7mz6XB. Thank\
    \ you very much for your help!\n<|/ c |>\n<| c |>\nYou really should use `@everywhere`\
    \ in this case, since you are clearly accessing `is_sorted_desc!` outside of the\
    \ function anyway.\n<|/ c |>\n<| a dscore=2 tags=arrays,julia,sorting |>\nHere\
    \ is my solution in Julia. I use mutable arrays as you said in your question.\
    \ \n<code>", "    if length(arr) == 0 \n        return arr\n    elseif length(arr)\
    \ == 1 \n        return arr\n    end\n    \n    local ones = 0\n    for x in arr\
    \ \n        if x==1 \n            ones = ones + 1\n        end\n    end\n    \n\
    \    if ones <= 1 \n        return arr\n    end\n    \n    local arr2 = deepcopy(arr)\n\
    \    arr2[sort(collect(keys(arr2)))] = arr2[sort(collect(keys(arr2)))] + ones\n\
    \    \n    return arr2\nend\n</code>\n<|/ a tags=sorting,julia |>\n<| c |>\nThe\
    \ sort function seems to fail when it is given a vector of Int64 arrays. So I\
    \ replaced it with sort!\n<|/ c |>\n<| c |>\nIn that case, just replace the sort\
    \ function with sort!. See the code I added at the end of the answer (just before\
    \ \"function sort_array(arr::Vector{Int64})::Vector{Int64}\")\n<|/ c |>\n<| c\
    \ |>\n`sort!` is not needed at all. `sort` will sort in-place.\n<|/ c |>\n<| c\
    \ |>\nThe reason for the `sort!` is that it will fail for `sort!([0,2,1,0])` because\
    \ it has `Int64` elements.  `sort!` will change `Int64` to `BigInt`\n<|/ c |>\n\
    <| c |>\nI don't think it's a good idea to write code like `arr2[sort(collect(keys(arr2)))]\
    \ = arr2[sort(collect(keys(arr2)))] + ones`. It's more efficient to use in-place\
    \ sorting `sort!` instead.\n<|/ c |>\n<| a dscore=4 |>\nThis is my solution:\n\
    <code>", "    sort!(arr, (arr==0)->(sort(arr)<sort(-arr)), less_than=(x->x==0),\
    \ key=->(Int,Int) -> (Int, Int) -> Int)\n    arr\nend", "    if length(arr) <\
    \ 2 return arr\n    ones = ones_array(arr)\n    zeros = zeros_array(arr)\n   \
    \ zeros = sort(zeros)\n    ones = sort(ones)\n    \n    left_len = length(ones)\n\
    \    right_len = length(zeros)\n    \n    if left_len > right_len \n        ones,\
    \ zeros = zeros(left_len - right_len), ones(right_len - left_len)\n    end\n \
    \   \n    left_ones = ones[end-1:end]\n    right_zeros = zeros[end-1:end]\n  \
    \  \n    right_ones = ones[2:end]\n    left_zeros = zeros(2:end)\n    \n    return\
    \ sort(left_ones + right_zeros) + sort(right_ones + left_zeros)\nend", "    if\
    \ arr.length == 0\n        return arr\n    end\n    one_count = 1\n    count =\
    \ 0\n    for i in arr\n        if i == 0\n            count += 1\n        else\n\
    \            one_count *= 2\n            count += 1\n        end\n    end\n  \
    \  one_bits = count * one_count\n    one_bins = bin(one_bits)[2:][2:end]\n   \
    \ dec = 0\n    for i in one_bins\n        dec += 2^(length(i) - 1)\n    end\n\
    \    return map(x -> dec + x, arr)\nend\n</cell>\n<code language=julia-1.5>\n\
    sort_array([1, 5, 2, 3, 4])\n</cell>\n<code language=julia-1.5>\nsort_array([-2,\
    \ -3, -4, -5, -6])\n</cell>\n<code language=julia-1.5>\nsort_array([1, 0, 2, 3,\
    \ 4])\n</cell>\n<text>\nProblem 2. Sort an Array", "    \"\"\"Sort an array, return\
    \ the sorted array.\"\"\"\n    \n    array = convert(Vector{Int64}, arr)\n   \
    \ l = array.length\n    m = convert(Int64, 0)\n    for i in 1:l\n        if array[i]\
    \ == 1\n            m += i\n        else\n            array[i] = array[m]\n  \
    \          array[m] = i\n        end\n    end\n    return array\nend\n</cell>\n\
    <text>\nLet's test the solution:", "  \"\"\"\n  sort an array in ascending order\
    \ according to the number of ones in its binary representation in ascending order.\n\
    \  \"\"\"\n  if length(arr)==0\n    []\n  elseif length(arr)==1\n    [1]\n  elseif\
    \ length(arr)==2\n    sorted!(arr, by = x -> x %% 2 == 0)\n  else\n    sorted!(arr,\
    \ by = x -> length(regexp_matches(string(x), r\"1+\")))\n  end\nend", "    \"\"\
    \"\n    In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n    number of ones in their binary representation in ascending order.\n\
    \    For similar number of ones, sort based on decimal value.", "    arr.sort!()\
    \ \n    return arr \nend", "    return Array{Int64}(undef, length(arr))\nend",
  "    \"\"\"\n    In this Kata, you have to sort a vector of non-negative integers\
    \ according to\n    number of ones in their binary representation in ascending\
    \ order.\n    For similar number of ones, sort based on decimal value.\n    \n\
    \    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4])\n\
    \    [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6])\n    [-6, -5, -4,\
    \ -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4])\n    [0, 1, 2, 3, 4]\n    \"\"\"",
  "    \"\"\"\n    Your code here\n    \"\"\"", "    if arr[1] == 0\n        arr =\
    \ arr[2:end]\n    elseif arr[1] == 1\n        arr = arr[3:end]\n    else\n   \
    \     arr = arr[2:end]\n        arr = arr[1:end]\n        arr = arr[1:end]\n \
    \   end\n    arr\nend", "    return sort(arr, (x -> sum(x)) == 1)\nend\n\"\"\"\
    \n    Given a sorted array of integers, reverse the ordering so that the last\
    \ one\n    appears first.\n    \"\"\"", "    \"\"\"\n    Sort the array in ascending\
    \ order according to number of ones in their binary representation in ascending\
    \ order.\n    \"\"\"\n    return sort(arr.to_bitarray())", "    \n    arr = sort(arr)\n\
    \    arr = arr[1:end-1]\n    \n    i = 0\n    while i < length(arr)\n        if\
    \ arr[i] < 0\n            arr[i] = 0\n            arr[i+1] = arr[i+1] - 1\n  \
    \      else\n            arr[i] = arr[i] - 1\n        end\n        i = i + 1\n\
    \    end\n    \n    return arr\nend\n</cell>\n<text>\nTo test your solution, run\
    \ the cell below.", "    if arr.length == 1\n        arr\n    else\n        sort!(arr,by=x->length(x)\
    \ == 1 ? x[1] : x[1])\n        arr\n    end\nend", "    sort = sort_array_impl(arr)\n\
    \    return sort(arr)\nend\n</code>\n<|/ a |>\n<| a dscore=2 |>\nHere's a function\
    \ that does it in O(n log n). It uses sort.\n<code>", "    sorted_arr = sort(arr)\n\
    \    sort_arr = zeros(length(arr))\n    counts = zeros(UInt64)\n    sorted_idx\
    \ = 0\n    for el in arr\n        if el == 1\n            counts[el] += 1\n  \
    \      elseif counts[el] > 0\n            sort_arr[sorted_idx] = el\n        \
    \    counts[el] -= 1\n            sorted_idx += 1\n        end\n    end\n    sorted_arr\n\
    end", "    local binary = \"\"\n    for i in arr\n        binary = binary * \"\
    1\"\n    end\n    binary = binary.reverse()\n    binary = String(binary)\n   \
    \ binary = reverse(binary)\n    binary = split(binary,\"\")\n    binary = map(x->parseInt64(bitset(x,length(binary))),\
    \ binary)\n    binary = sort(binary)\n    binary = map(x->bitset(x,length(binary)),\
    \ binary)\n    binary = reverse(binary)\n    binary = join(binary,\"\")\n    return\
    \ reverse(binary)\nend", "    sort!(arr,by=(x,n->n==1 ? x : tonumber((x)+\".0\"\
    )),rev=true)\n    return arr\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\nI've recently\
    \ been working on a similar problem, so I've been thinking about how I can solve\
    \ the problem in the most efficient way possible.\nThe goal is to find the largest\
    \ integer in an array with a given number of ones in its binary representation.\n\
    The most efficient way to solve this problem is to create a table of the number\
    \ of ones in each number in the array and then find the maximum number by comparing\
    \ each element in the table with the number of ones in its binary representation.\n\
    This problem is quite easy to solve using MapReduce.\nThe only tricky part is\
    \ getting the number of ones in each number. While there are many ways to do this,\
    \ here is how I did it.  \nFirst, let's take a look at the table of number of\
    \ ones in each number. This table is a vector of integers with the number of ones\
    \ in each number. In our example, for the number 10, it would be [0,0,1,0,1,1,0].\n\
    Next, let's look at the function count_ones_in_number. Here is the pseudocode:\n\
    <code>", "    ones = zeros(Int, 0)\n    for i in arr\n        if i > 0\n     \
    \       ones += 1\n        else\n            ones += 0\n    end", "    \"\"\"\n\
    \    Sort an Int64 vector in ascending order", "    \n    # Your code goes here\n\
    \    arr = sort(arr)\n    \n    return arr\nend", "    answer = sort(arr)\n  \
    \  return answer\nend", "    \"\"\"\n    \n    \n    sort an array of non-negative\
    \ integers according to number of ones in their binary representation in ascending\
    \ order.\n    For similar number of ones, sort based on decimal value.", "   \
    \ sort(arr)\n    for i in 1:length(arr)\n        arr[i] = count_ones(arr[i])\n\
    \    end\n    return arr\nend\n</cell>\n<text>\nTest your code", "    sort(arr)\n\
    end\n</cell>\n<text>\nTask 3: Sort a vector of non-negative integers in descending\
    \ order based on decimal value\nImplement a function descendingsort, which sorts\
    \ a vector of non-negative integers in descending order based on their decimal\
    \ value.", "    ones_count = filter(x -> x==1, arr)\n    \n    if length(ones_count)\
    \ > length(arr)\n        ones_count = ones_count[length(ones_count)]\n    end",
  "    \"\"\" Sorts the vector in ascending order. \n    It must be implemented like\
    \ this:\n    >>> sort_array([1, 5, 2, 3, 4])\n    [1, 2, 3, 4, 5]\n    >>> sort_array([-2,\
    \ -3, -4, -5, -6])\n    [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3,\
    \ 4])\n    [0, 1, 2, 3, 4]\n    \"\"\"", "    sort(arr)\n    return arr\nend",
  "    tmp = zeros(Int, length(arr))\n    for (i in 1:length(arr))\n        tmp[i]\
    \ = count_ones(arr[i])\n    end\n    @assert(all(tmp <= maximum(arr)))\n    @assert(all(tmp\
    \ >= minimum(arr)))\n    @assert(length(sort(tmp, 1))==length(arr))\n    \n  \
    \  return sort(tmp, 1) \nend\n</cell>\n<text>\nTest Your Solution", "    if length(arr)==0\
    \ \n        return arr \n    \n    if arr[1]==0 && length(arr)==2 \n        return\
    \ arr \n    \n    if arr[1]==0 \n        arr = arr[2:end] \n        return sort_array(arr)\
    \ \n    \n    if arr[end]==0 \n        arr = arr[1:end-1] \n        return sort_array(arr)\
    \ \n    \n    arr = arr[1:end-1]\n    arr1 = sort_array(arr)\n    arr2 = sort_array(arr1)\n\
    \    arr3 = sort(arr2)\n    arr = arr3\n    \n    arr4 = arr\n    \n    arr5 =\
    \ sort(arr)\n    arr6 = sort(arr5)\n    \n    arr = arr6\n    arr = arr[end-1:end]\n\
    \    arr = arr[1:end]\n    return arr4\nend\n</cell>\n<code language=julia-1.5>",
  "    \n    \n    \"\"\"\n    Here we declare a vector called `num_ones` which stores\
    \ the number of ones in each element of `arr`. \n    We use it to sort the array.\
    \ \n    \"\"\"\n    num_ones = count_ones(arr)\n    \n    \"\"\"\n    Here we\
    \ get the decimal value of each element in `arr`. \n    We use them to sort the\
    \ array. \n    \"\"\"\n    decimal = decimals(arr)\n    \n    \"\"\"\n    We use\
    \ our `num_ones` and `decimal` vectors to sort `arr`. \n    When the number of\
    \ ones is equal, we use their decimal values to sort.\n    When the number of\
    \ ones is unequal, we use the value of `num_ones` to sort.\n    \"\"\"\n    sorted_arr\
    \ = \n        # Here we create a boolean array which stores true if `num_ones[i]==decimal[i]`\
    \ \n        # where `i` is the index of arr. \n        zeros(length(arr))\n  \
    \      for i in 1:length(arr)\n            if num_ones[i] == decimal[i]\n    \
    \            sorted_arr[i] = true\n            else\n                sorted_arr[i]\
    \ = false\n            end\n        end\n        \n    \"\"\"\n    Since we created\
    \ `sorted_arr`, we directly use it to sort `arr`.\n    \"\"\"\n    arr[sorted_arr]\n\
    end", "    \n    return sort(arr)\nend\n</code>\n<|/ a |>\n<| a tags=julia dscore=3\
    \ |>\nHere is a solution using sortperm:\n<code>\njulia> sortperm(collect(0:2^length(a)-1))\n\
    4-element Vector{Int64}:\n  4\n  0\n  1\n  2\n</code>\n<|/ a |>\n<| a tags=julia\
    \ |>\nAn interesting solution using an extra variable that only needs to be set\
    \ once and is used many times over:\n<code>\njulia> sort_array(array) = sortperm(collect(0:2^length(array)-1))\n\
    sort_array (generic function with 1 method)", "    answer = []\n    for x in arr\n\
    \        answer.push(x)\n    end\n    return answer\nend", "    # convert vector\
    \ to ints \n    arr = arr.map(x -> int(x))\n    \n    # count number of ones\n\
    \    num_ones = zeros(Int, length(arr))\n    for elem in arr\n        num_ones[elem]\
    \ += 1\n    end", "    arr = sort(arr)\n    \n    function cmp (a, b)\n      \
    \  if a == 0\n            return b == 0\n        elseif b == 0\n            return\
    \ a == 0\n        else\n            return a < b\n    end", "  \"\"\"\n  Input:\n\
    \    Vector{Int64} of numbers to be sorted", "    if arr == zeros(Int64)\n   \
    \     arr\n    else\n        arr = convert(Vector{Int64}, arr)\n        reverse(sort(arr))\n\
    \    end\nend\n</code>\n<|/ a tags=julia dscore=2 |>\n<| c |>\nNice solution!\
    \ But it is an O(n^2) solution, which is slow if n is large.\n<|/ c |>\n<| c |>\n\
    I did not know the existence of `sort` and `sortperm` for Arrays. This solves\
    \ the performance issue without an O(n^2) solution. Thanks!\n<|/ c |>\n<| c |>\n\
    Thanks for your solution. However I believe there should be a `sortperm` method\
    \ for `Arrays`. I think this is a common problem in Julia so I think there should\
    \ be a `sortperm` method.\n<|/ c |>\n<| a dscore=1 |>\nJust another solution:\n\
    <code>\nsort_array(arr) = arr[sort(perm(arr))] \n</code>\n<|/ a tags=julia |>\n\
    <| a dscore=0 |>\nHere is my version for Julia 1.2 \n<code>", "    sorted_arr::Vector{Int64}\
    \ = copy(arr)\n    for idx in indices(arr)\n        ones = arr[idx] == 1\n   \
    \     if ones\n            sorted_arr[ones] = idx\n        end\n    end\n    return\
    \ sorted_arr\nend", "    length = length(arr)\n    count = zeros(Int, length)\n\
    \    for i in 1:length\n        count[arr[i]] += 1\n    end\n    \n    result\
    \ = sort(count)\n    result = (result .- 1)\n    \n    for i in 1:length\n   \
    \     arr[result[i]] = i\n    end\n    \n    return arr\nend\n</cell>\n<code language=julia-1.0>\n\
    sort_array([0, 3, 15, 17, 20])\n</cell>\n<code language=julia-1.0>\nsort_array([-2,\
    \ -3, -4, -5, -6])\n</cell>\n<code language=julia-1.0>\nsort_array([1, 0, 2, 3,\
    \ 4])\n</cell>\n<text>\nWhat is your favorite Julia programming language ?\nJulia\
    \ is a free and open-source programming language that allows you to do all kinds\
    \ of science, math, physics, and machine learning (ML) in an easy, intuitive way.",
  "    \n\"\"\"\n    Sort an array of non negative integers based on their decimal\
    \ value.", '    """', "    l = length(arr)\n    ones = ones(Int64, l)\n    zeros\
    \ = zeros(Int64, l)\n    m = zeros(Int64, l)\n    for i in 1:l\n        m[i] =\
    \ sum(bitcount(arr[i]))\n    end\n    for i in 1:l\n        ones[i] = bitcount(arr[i])\n\
    \        zeros[i] = sum( ones[i:end] )\n    end\n    return collect(sort( ones(eltype(zeros),l),\
    \ lt=(x,y) -> m[x] > m[y] ) )\nend", "    # Write your code here. \nend", "  \
    \      sorted_arr = copy(arr)\n        sorted_arr2 = copy(arr)\n        \n   \
    \     for i in 1:length(sorted_arr2)\n            sorted_arr[i] = 0\n        end\n\
    \        for i in 1:length(sorted_arr)\n            sorted_arr2[i] = 0\n     \
    \   end", "    \"\"\"\n    Sort the given array in ascending order based on number\
    \ of ones in their\n    binary representation in ascending order.\n    \"\"\"\n\
    \    sorted = sort(arr)\n    sort(sorted, by=function(x::Int64) \n           \
    \     length(bits(x)) === 1 ? x : x^(-1^bits(x))) \n    return sorted\nend", " \
    \   sorted_arr = copy(arr)\n    count_zero = zeros(Int64, length(sorted_arr))\n\
    \    for k in 1:length(sorted_arr)\n        if sorted_arr[k] == 0\n          \
    \  count_zero[k] = count_zero[k] + 1\n            sorted_arr[k] = count_zero[k]\n\
    \        end\n    end\n    return sorted_arr\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n@assert sort_array([1,\
    \ 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n</cell>\n<text>\nPart IV. Sort a vector of\
    \ strings in lexicographical order", "    vec = sort(vec)\n    arr1 = sort(arr)\n\
    \    sort_array = 0\n    for i in 1:length(vec)\n        for j in 1:length(arr1)\n\
    \            if arr1[j] == 1\n                sort_array = sort_array + 1\n  \
    \              break\n            end\n        end\n    end\n    vec\nend\n</cell>\n\
    <code language=julia-1.0>\nsort_array([-2, -3, -4, -5, -6])\n</cell>\n<code language=julia-1.0>\n\
    sort_array([1, 0, 2, 3, 4])\n</cell>\n<text>\nThe next step is that for each number\
    \ $v$ in the vector, multiply it with the number \nof ones in its binary representation\
    \ and subtract the number of the number \nof ones in the number $v$'s binary representation.\
    \ Thus, we get the number of \nones in its binary representation. This can be\
    \ done easily using bitcount() ", "    \"\"\"\n    In this Kata, you have to sort\
    \ a vector of non-negative integers according to\n    number of ones in their\
    \ binary representation in ascending order.\n    For similar number of ones, sort\
    \ based on decimal value.", "    sort_array = [0 for _ in 1:length(arr)]\n   \
    \ count_bits(arr, count_array)\n    sort_array[1] = arr[1]\n    for i = 2:length(arr)\n\
    \        if count_array[i] < count_array[i - 1]\n            sort_array[i] = sort_array[i\
    \ - 1]\n        elseif count_array[i] > count_array[i - 1]\n            sort_array[i]\
    \ = sort_array[i - 1] + 1\n        end\n    end\n    return sort_array\nend",
  "    if length(arr)==0 return arr\n    counts = arr.map(counts::Integer)\n    counts_sorted\
    \ = sort_array(counts)\n    arr[counts_sorted] = arr\n    return arr\nend\n</cell>\n\
    <code language=julia-1.6>\n@assert sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4,\
    \ 5]\n@assert sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n@assert\
    \ sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n</cell>\n<text>\n2. Count number\
    \ of 1s in the binary representation of an array", "    sorted_arr = sort(arr)\n\
    \    one_cnt = zeros(Int64, length(arr))\n    for i in eachindex(arr)\n      \
    \  one_cnt[i] = sum(arr & -arr) == length(x)\n    end\n    one_cnt_in_binary =\
    \ zeros(Int64, length(arr))\n    for idx in eachindex(arr)\n        one_cnt_in_binary[idx]\
    \ = sum(one_cnt == idx)\n    end\n    \n    if length(one_cnt_in_binary) != length(one_cnt)\n\
    \        zero_cnt = length(arr)-length(one_cnt_in_binary)\n        one_cnt_in_binary[zero_cnt]\
    \ = -1\n    end\n    \n    sorted_arr_sorted = sort(one_cnt_in_binary)\n    \n\
    \    return sorted_arr\nend", "    # Write your code here.\n    \nend", "    #\
    \ Write your code here\nend\n</cell>\n<text>\nPart 4: Find all prime factors of\
    \ a number", "    arr = sortperm(arr)\n    return arr\nend", "    if length(arr)==0\
    \ \n        return arr\n    \n    pos = zeros(Int, length(arr))\n    neg = -ones(Int,\
    \ length(arr))\n    \n    for (ii, x) in enumerate(arr) \n        if (x != 0)\
    \ \n            pos[ii] = ii+1\n        elseif x == 0 \n            neg[ii] =\
    \ ii+1\n        end\n    end", "    ones = findall(arr .== 1)\n    if length(ones)\
    \ <= length(x)\n        ones = repeat(ones, each=length(x))\n    end\n    if length(ones)\
    \ <= length(x)\n        sort(ones)\n    else\n        sort(sort(ones))\n    end\n\
    end", "    if length(arr) ==0 return arr\n    \n    arr = sort(arr)\n    \n  \
    \  count = 1\n    \n    for (i,x) in enumerate(arr)\n        if x==1 \n      \
    \      count+=1 \n        else\n            count-=1\n            \n        if\
    \ count==0 \n            arr[i] = x\n            \n    count = 1\n    \n    for\
    \ (i,x) in enumerate(arr)\n        if x==1 \n            count+=1 \n        else\n\
    \            count-=1\n            \n        if count==0 \n            arr[i]\
    \ = x\n            \n    return arr\nend #sort_array", "        \n\"\"\"\n   \
    \ Sort a vector of non-negative integers according to number of ones in their\
    \ binary representation in descending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\"\"\"", "    \n    binarr = zeros(length(arr))\n\
    \    binarr[arr .== 1] .+= 1\n    binarr[arr .== -1] .-= 1\n    binarr[arr .==\
    \ 0] .= 0\n    binarr[arr .== 0] .= 0\n    binarr = binarr / 2", "    arr = arr\
    \ |> Vector{Int64}\n    bins = zeros(Int, length(arr))\n    for (i,x) in enumerate(arr)\n\
    \        bins[x] = i\n    end\n    idx = zeros(Int, length(arr))\n    for (i,\
    \ x) in enumerate(bins)\n        idx[i] = x\n    end\n    return idx |> arr[sort_indices(idx)]\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a |>\nI hope it would be helpful to some who\
    \ are looking to do same thing as I was. To find the most efficient solution for\
    \ a sorting problem (for sorting integers or strings), I did some performance\
    \ benchmarks for different methods. I added a random seed (using Julia's Base.randseed())\
    \ to make the results reproducible.\nThe benchmark is in Julia 1.6.1 and I did\
    \ these benchmarks on MacBook Pro (2015) with OSX 10.14.6 (Mojave). The code is\
    \ available here. Below is the performance comparison between different methods:\n\
    <code>\nBenchmarkTools 2.5.3\n\u250C Test Suite: sort_array (2.70 ms)\n\u251C\
    \ Sorting Integers: sort_array! (1.85 ms)\n\u251C Sorting Strings: sort_array!\
    \ (2.01 ms)\n\u251C Sorting Integers: sort_array (2.61 ms)\n\u251C Sorting Strings:\
    \ sort_array (2.60 ms)\n\u2514 Sorting Integers: sort_array! (1.93 ms)\n\u2514\
    \ Sorting Strings: sort_array! (1.93 ms)\n</code>\nThe benchmark code\n<code>",
  "    sorted = sort_vector(arr)\n    sorted = reverse(sorted)\n    return sorted\n\
    end", "    sorted_arr = sort(arr)\n    \n    return sorted_arr\nend\n</cell>\n\
    <code language=julia-1.5>", "    ones=zeros(Int64, length(arr))\n    ones[1]=1\n\
    \    ones=ones-ones\n    sortedones=zeros(Int64, length(arr))\n    sortedones[1]=ones[1]\n\
    \    for i in 2:length(arr)\n        ones=ones-ones\n        sortedones[i]=ones[i]\n\
    \    end\n    sortedones=sortedones[findall(sortedones<0)]\n    return sortedones[findall(sortedones>0)]\n\
    end\n</code>\n<|/ a tags=sorting,julia,arrays |>\n<| a tags=sorting,julia,arrays\
    \ dscore=1 |>\nI made an answer myself.\n<code>", "    sort_array(sort(arr))\n\
    end", "    \"\"\"\n    >>> sort_array([1, 5, 2, 3, 4])\n    [1, 2, 3, 4, 5]\n\
    \    >>> sort_array([-2, -3, -4, -5, -6])\n    [-6, -5, -4, -3, -2]\n    >>> sort_array([1,\
    \ 0, 2, 3, 4])\n    [0, 1, 2, 3, 4]\n    \"\"\"\n    return sort(arr)\nend", " \
    \   return arr[sort_index(arr)...]\nend\n</code>\nAnd the output:\n<code>\njulia>\
    \ sort_array(test_array)\n6-element Array{Int64,1}:\n 0\n 1\n 2\n 3\n 4\n 5",
  "    if arr == [] \n        [] \n    else \n        sorted_arr = sort(arr)\n   \
    \     sum = 0\n        for i in sorted_arr \n            sum = (sum + i) mod 2\n\
    \            \n        sum_array = []\n        for i in sorted_arr \n        \
    \    if sum == 0 \n                sum_array[i] = i\n            elseif sum ==\
    \ 1 \n                sum_array[i] = sum - i\n            end \n            sum\
    \ = (sum + i) mod 2\n        end\n        return sum_array \n    end\nend\n</code>\n\
    Here is the test function:\n<code>", "    sorted=copy(arr)\n    sorted=sortperm(sorted)\n\
    \    return sorted\nend", "        \n    #sort the vector\n    return sort_vec(arr)\n\
    end", '    @assert length( arr ) >=0', "    vec = Vector{Int64}([])\n    for x\
    \ in arr\n        for i = dec2bin(bitcount(x), 8)\n            push!(vec, 0 if\
    \ i == \"0\" else 1)\n        end\n    end\n    vec \nend\n</cell>\n<text>\nBonus\
    \ Challenge: Sort the array according to it's magnitude", "    sort(arr)\n   \
    \ return arr\nend", "    sortedArray = arr\n    if length(arr) < 2 \n        sortedArray\n\
    \    else\n        sortedArray = arr \n        if length(arr) < 4\n          \
    \  for i = length(arr) - 2\n                sortedArray[i] = arr[i + 1]\n    \
    \            sortedArray[i + 1] = arr[i]\n            end\n            return\
    \ sortedArray\n        end\n        ones = zeros(1)\n        ones[1] = 1\n   \
    \     ones = ones\n        sortArray = zeros(length(arr), 2)\n        sortArray[:,\
    \ 1] = 0\n        sortArray[:, 1] .= ones\n        sortArray = sortArray[sortArray[:,\
    \ 1].>0]\n        sortArray = sortArray[sortArray[:, 1].<length(arr)]\n      \
    \  sortArray[:, 1] = sortArray[:, 1] .- sortArray[:, 1] .+1 \n        sortArray\
    \ = sortArray[sortArray[:, 1].>0]\n        sortArray = sortArray[sortArray[:,\
    \ 1].<length(arr)]\n        sortArray = sortArray[sortArray[:, 1].<length(arr)]\n\
    \        sortArray[:, 1] = sortArray[:, 1] .- sortArray[:, 1] .+1 \n        sortArray\
    \ = sortArray[sortArray[:, 1].>0]\n        sortArray = sortArray[sortArray[:,\
    \ 1].<length(arr)]\n        sortArray = sortArray[sortArray[:, 1].<length(arr)]\n\
    \        sortArray = sortArray[sortArray[:, 1].<length(arr)]\n        sortArray\
    \ = sortArray[sortArray[:, 1].<length(arr)]\n        sortArray = sortArray[sortArray[:,\
    \ 1].<length(arr)]\n        sortArray = sortArray[sortArray[:, 1].<length(arr)]\n\
    \        return sort_array(sortArray[:, 1])\n    end\nend", "    # Your code here\n\
    end\n</cell>\n<code language=julia-1.5>\nsort_array([1, 0, 2, 3, 4])\n</cell>\n\
    <code language=julia-1.5>\nsort_array([0, -4, 0, 2, 1])\n</cell>\n<code language=julia-1.5>\n\
    sort_array([0, -4, 0, 2, 1])\n</cell>\n<code language=julia-1.5>\nsort_array([2,\
    \ -4, 0, 2, 1])\n</cell>\n<text>\nImplement the function count_ones! that takes\
    \ an array of integers stored in variable arr and returns an integer corresponding\
    \ to the number of ones in the array.", "    sort_arr = sort(arr)\n    if any(sort_arr\
    \ \u2264 0, sort_arr != sort_arr[1])\n        sort_arr = sort(sort_arr)\n    end\n\
    \    return sort_arr\nend", "    len = length(arr)\n    if len == 0 \n       \
    \ return arr \n    binarr = Vector{Int64}(len) \n    for i in 1:len \n       \
    \ binarr[i] = (arr[i] > 0) \n    end", "    sorted = sort_array(vec(arr))\n  \
    \  return arr\nend\n\"\"\"\n    In this Kata, you have to sort a vector of non-negative\
    \ integers according to\n    number of ones in their binary representation in\
    \ descending order.\n    For similar number of ones, sort based on decimal value.",
  "    if arr.size < 2 return arr\n    one = sum(arr & [1]) == 0\n    neg = arr.size\
    \ - one\n    bigger_one = reverse(arr & [1]) ~= reverse(arr & ~[1])\n    big_negative\
    \ = reverse(arr) ~= reverse(arr)\n    \n    if one\n        sort_arr = [arr[1]]\n\
    \        return sort_arr\n    end", "    ones = [1 for i in arr]\n    twos = [2\
    \ for i in arr]\n    threes = [3 for i in arr]\n    fours = [4 for i in arr]\n\
    \    fives = [5 for i in arr]\n    sixes = [6 for i in arr]\n    \n    # Sort\
    \ the vector according to their binary number\n    sorted_ones = sort(ones)\n\
    \    sorted_twos = sort(twos)\n    sorted_threes = sort(threes)\n    sorted_fours\
    \ = sort(fours)\n    sorted_fives = sort(fives)\n    sorted_sixes = sort(sixes)",
  "    arr = arr |> map(x -> bin(x)[2:].count('1'), arr)\n    return arr |> sort()\
    \ |> map(x -> x, arr)\nend\n</cell>\n<code language=julia-1.3>\n@test sort_array([1,\
    \ 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n@test sort_array([-2, -3, -4, -5, -6]) == [-6,\
    \ -5, -4, -3, -2]\n@test sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n</cell>\n\
    <code language=julia-1.3>\n\"\"\"\n    In this Kata, you have to return the index\
    \ of minimum value in vector\n    according to the order of appearance in the\
    \ vector.\n    For example, if the vector is [1, 1, 2, 3] you should return 3.\n\
    \"\"\"", "        sort_arr = zeros(Float64, length(arr))\n        for i in 1:length(arr)\n\
    \            sort_arr[i] = countones(arr[i])\n        end\n        return sort_arr\n\
    end", "    if length(arr)<1 \n        return [] \n    end\n    if all(iszero(arr))\
    \ \n        return arr \n    end\n    i=1\n    last=arr[1] \n    while i<length(arr)\
    \ do \n        if arr[i]==0 \n            arr[i]=last \n            last=arr[i-1]\
    \ \n            i=i-1 \n        end \n        i=i+1 \n    end \n    if last>0\
    \ \n        arr[end-1]=last \n        arr[end]=0 \n    end \n    return arr \n\
    end\n</cell>\n<text>\nQ2\nImplement a function that computes the decimal representation\
    \ of the binary representations of an input vector of integers.\nFor example,\
    \ if the input vector is [1,2,4,8,16,32], then the function should return the\
    \ decimal representation [10, 2, 16, 4, 32].\nIt must work for negative numbers\
    \ as well as integers.\nIt must return an error if the input vector is empty or\
    \ has multiple zeros.", "    return arr\nend", "    \n    # sort array base on\
    \ one\n    binrep = zeros(Int, length(arr))\n    for indx in eachindex(arr)\n\
    \        binrep[indx] = convert(Bool, bin(arr[indx])[2:end])\n    end", "\"\"\"\
    \n    In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n    number of ones in their binary representation in ascending order.\n\
    \    For similar number of ones, sort based on decimal value.", "    sorted =\
    \ @. sort(arr,asc=true)\n    if sorted[end]==0\n        sorted[end] = 2\n    end\n\
    \    \n    temp = sort\n    temp = sort[sorted]\n    return sorted + temp\nend\n\
    </cell>\n<text>\nProblem 3. Merge Two Binary Trees Given Two Binary Search Trees\n\
    For this Kata, you have to merge two binary search trees.\nThey are represented\
    \ in this way:", "    v = Vector{Int64}()\n    i = 0\n    while i <= length(arr)\n\
    \        if arr[i] > 0\n            push!(v, i)\n        end\n        i += 1\n\
    \    end\n    sorted = v\n    i = 0\n    while i <= length(arr)\n        if arr[i]\
    \ > 0\n            push!(sorted, arr[i])\n        end\n        i += 1\n    end\n\
    \    return sorted\nend\n</code>\n<|/ a tags=vectorization,julia |>\n<| c |>\n\
    Could you post some of your benchmarks?\n<|/ c |>\n<| c |>\nI did not have a benchmarks,\
    \ but I am quite satisfied with the results. Your solution is better than mine\
    \ and, in addition to that, it is much faster. Thanks!\n<|/ c |>\n<| c |>\nI tried\
    \ to benchmark this on 10000 random numbers in range 0 to 20. The fastest was\
    \ `@benchmark sort_array(vec)` with result: `71.7 \u03BCs (6 allocations: 3.33\
    \ KiB)`. I think it would be better to have some bigger range or to test it on\
    \ more numbers (for instance by adding `sleep(1)` to make it more realistic).\n\
    <|/ c |>\n<| c |>\nThanks, your solution was more effective, although I didn't\
    \ really compare it to the other answers, because it was way too slow.\n<|/ c\
    \ |>\n<| a |>\nI would use isless (not less!) like this:\n<code>\njulia> x = Vector{Int}(Int64[],\
    \ [1,0,0,0,0,0,0,1])\n6-element Vector{Int64}:\n 1\n 0\n 0\n 0\n 0\n 1", "   \
    \ \n    for i=1:length(arr)\n        if arr[i]==1\n            arr[i]+=1\n   \
    \     else\n            arr[i]-=1\n        end\n    end\n    return arr\nend\n\
    </cell>\n<text>\nExpected Outcome:", "    if length(arr) == 0 return []\n    \n\
    \    count = 0\n    zero = falses(length(arr))\n    for e in arr\n        if e\
    \ == 1 count += 1\n        else zero[e] = true\n    end\n    \n    arr = arr[count..end-1]\n\
    \    \n    if length(arr) == 0\n        return arr\n    end\n    \n    arr[end]\
    \ = length(arr)\n    \n    if count == 0\n        return arr\n    end\n    \n\
    \    i = 0\n    while i < length(arr)\n        \n        if i == length(arr)\n\
    \            arr[i+1] = arr[end]\n            arr[end] = length(arr)\n       \
    \ end\n        \n        if arr[i] == length(arr)\n            \n            if\
    \ arr[i+1] == length(arr)\n                arr[i+1] = arr[i]\n               \
    \ arr[i] = length(arr)\n            else\n                if arr[i+1] == length(arr)\n\
    \                    arr[i+1] = arr[end]\n                    arr[end] = arr[i]\n\
    \                end\n                \n                arr[i+1] += 1\n      \
    \          arr[end] -= 2\n            end\n        end\n        \n        if arr[i]\
    \ > length(arr)\n            if arr[i+1] == length(arr)\n                arr[i+1]\
    \ = arr[i]\n                arr[i] = length(arr)\n            else\n         \
    \       if arr[i+1] == length(arr)\n                    arr[i+1] = arr[end]\n\
    \                    arr[end] = arr[i]\n                end\n                \n\
    \                arr[i+1] -= 1\n                arr[end] -= 1\n            end\n\
    \        end\n        i += 1\n    end\n    \n    return arr\nend", "    if length(arr)==0\n\
    \        return arr\n    end\n    \n    sorted_arr = copy(arr)\n    if length(arr)==1\n\
    \        return sorted_arr\n    end\n    \n    sorted_idx = copy(1:length(sorted_arr))\n\
    \    one_idx = findfirst(x -> x == 1, arr)\n    if one_idx == length(arr)\n  \
    \      return sorted_arr\n    end\n    \n    one = arr[one_idx]\n    if one ==\
    \ 0\n        return sort_array(sorted_arr)\n    end", "    l = length(arr)\n \
    \   binary = dec2bin(arr)\n    binary = Vector{String}(undef, l*2)\n    binary.fill(\"\
    0\")\n    for k in 0:l-1\n        binary[k+l*l-1] = binary[k] \n        binary[k+l*l]\
    \ = binary[k+1] \n    end\n    \n    binary.sort!\n    return bin2dec(binary)\n\
    end\n</cell>\n<code language=julia-0.5>\n@testset \"Test sort_array\" begin\n\
    \    @test sort_array([1, 5, 2, 3, 4]) == [1,2,3,4,5]\n    @test sort_array([-2,\
    \ -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    @test sort_array([1, 0, 2, 3,\
    \ 4]) == [0,1,2,3,4]\nend\n</cell>\n<text>\nExercise: sort a vector of strings\
    \ in lexicographical order", "    if length(arr)==0\n        return arr\n    one_counts\
    \ = zeros(Int64, length(arr))\n    for idx in length(arr)\n        ones = count_bits(arr[idx])\n\
    \        one_counts[idx] = ones\n    end\n    \n    sorted_ones = sort_vec(one_counts)\n\
    \    \n    sorted_idxs = zeros(Int64, length(arr))\n    for idx in length(arr)\n\
    \        ones = count_bits(arr[idx])\n        ones = ones - sorted_ones[ones -\
    \ 1]\n        sorted_idxs[idx] = ones\n    end\n    return arr[sorted_idxs]\n\
    end\n    \n\"\"\"\n    sort_vec(vector) -> vector", "    return sort(arr)\nend",
  "    \"\"\"Sort an array according to number of ones in their binary representation\
    \ in ascending order\"\"\"\n    \n    sorted_index = collect(1:length(arr))\n\
    \    binary_arr = arr2bitarray(arr)\n    \n    #Sort based on number of 1s in\
    \ binary representation\n    for index in 1:length(binary_arr)\n        idx =\
    \ binary_arr[index]\n        if idx <= 0\n            continue\n        \n   \
    \     if binary_arr[index] <= 1\n            sorted_index[index]=1\n        elseif\
    \ binary_arr[index] == 0\n            sorted_index[index]=idx\n        end\n \
    \   end\n    return arr2decarray(sorted_index)\nend", "    res=[]\n    bits=reverse(arr)\n\
    \    for i in 0 until length(bits); \n        ones=bits[i]\n        num=i\n  \
    \      while ones==1; num+=1\n        res=[num+1] ++ res\n    end\n    res\nend\n\
    </cell>\n<code language=julia-1.5>\n@test sort_array([1, 5, 2, 3, 4]) \u2248 [1,\
    \ 2, 3, 4, 5]\n@test sort_array([-2, -3, -4, -5, -6]) \u2248 [-1, -2, -3, -4,\
    \ -5]\n@test sort_array([1, 0, 2, 3, 4]) \u2248 [0, 1, 2, 3, 4]\n</cell>\n<text>\n\
    Part II. More on vectors\nNow you are going to get some practice with vectors\
    \ and matrices. You will want to use vectors and matrices throughout this kata,\
    \ but it is only a small part of what you will do. Here are a few things to keep\
    \ in mind:", "    sort = quicksort(sort(sort(arr)))\n    if length(sort) != length(arr)\n\
    \        @warn \"Sort failed\" sort\n    end\n    return sort\nend\n</code>\n\
    <|/ a tags=sorting,julia,arrays |>\n<| c |>\nYeah, I think this is the best answer\
    \ so far. It seems pretty straightforward to me, yet I am surprised that nobody\
    \ else has given this solution. Thanks for your answer!\n<|/ c |>\n<| c |>\n`sort_array`\
    \ in `BenchmarkTools.jl` has a higher complexity than this solution in `sortperm`.\
    \ You can find more info [here](https://github.com/JuliaLang/BenchmarkTools.jl/issues/173#issuecomment-407701586)\n\
    <|/ c |>\n<| c |>\n- I suppose it may depend on the number of elements that it\
    \ has to sort, so I suppose the difference in performance may not be as noticeable\
    \ as you might expect for large vectors.\n<|/ c |>\n<| c |>\nIt seems like `sortperm`\
    \ also has a lower complexity than this solution. [See here](https://github.com/JuliaLang/BenchmarkTools.jl/issues/173#issuecomment-407701656)\n\
    <|/ c |>\n<| a tags=sorting,julia,arrays |>\nHere is my solution which compares\
    \ the performance of sorting and ranking algorithms for integer arrays:\n<code>\n\
    julia> using BenchmarkTools", "    sorted = sort(arr)\n    \n    function compare(arr::Vector{Int64},\
    \ i::Int64)\n        binarr(arr[sortindex])[1]\n    end\n    \n    for j=1:length(sorted)\n\
    \        swap!(sorted, j, sortindex(sorted[j], sorted))\n    end\n    \n    sorted\n\
    end\n    \n\"\"\"\n    In this Kata, you have to sort a vector of non-negative\
    \ integers according to\n    number of ones in their binary representation in\
    \ descending order.\n    For similar number of ones, sort based on decimal value.",
  "    sort!(arr)\n    return arr\nend\n</code>\nThe second function sort! sorts the\
    \ array in-place and returns the sorted array. The function can be found in this\
    \ Kata. \nAnd then you have the function sort_array which calls sort! and returns\
    \ the sorted array.\n<|/ a dscore=3 |>\n<| c |>\nIt's not working for me (I'm\
    \ using Julia v0.4.1), but I've already tried the one you proposed (using `sort!`)\
    \ and it works. So thank you!\n<|/ c |>\n<| c |>\n: This kata is about sorting\
    \ a vector of ints, not about sorting an array of ints. I tested both versions\
    \ and they work fine for me.\n<|/ c |>\n<| c |>\nAh okay, thanks for your help.\
    \ I think this should be the accepted answer, because it's the most straightforward\
    \ to implement, and it works out of the box (Julia v0.4.1). I would have preferred\
    \ a more generic solution, but this is also an easy solution.\n<|/ c |>\n<| a\
    \ tags=sorting,julia dscore=2 |>\nBased on the answer from Sascha Barthelem, the\
    \ following function seems to work even when comparing floating point values.\
    \ \n<code>\nimport Base.sort", "\"\"\"\n    Implement this function by sorting\
    \ an array in ascending order using the\n    function you learned in previous\
    \ katas.\n    \n    You need this function because in this kata, we will have\
    \ to sort a vector of\n    non-negative integers according to number of ones in\
    \ their binary representation in\n    ascending order.\n    For similar number\
    \ of ones, sort based on decimal value.\n    \n    You cannot use the sort() function\
    \ for this Kata.\n    \n    Arguments: \n        - arr (Array{Int64}): array of\
    \ integers to sort\n    \n    Returns: \n        - Array{Int64}: sorted array\n\
    \"\"\"", '    sort_array(arr)::Vector{Int64} = arr']
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
