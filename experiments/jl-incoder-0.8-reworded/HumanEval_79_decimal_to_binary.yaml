name: HumanEval_79_decimal_to_binary
language: jl
prompt: "\"\"\"You will be given a number in decimal form and your task is to convert\
  \ it to\n    binary format. The function should return a string, with each character\
  \ representing a binary\n    number. Each character in the string will be '0' or\
  \ '1'.\n\n    There will be an extra couple of characters 'db' at the beginning\
  \ and at the end of the string.\n    The extra characters are there to help with\
  \ the format.\n\n    Examples:\n    >>> decimal_to_binary(15)\n    \"db1111db\"\n\
  \    >>> decimal_to_binary(32)\n    \"db100000db\"\n    \"\"\"\nfunction decimal_to_binary(decimal::Int64)::String\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = decimal_to_binary;\n\t@test(candidate(0)\
  \ == \"db0db\")\n\t@test(candidate(32) == \"db100000db\")\n\t@test(candidate(103)\
  \ == \"db1100111db\")\n\t@test(candidate(15) == \"db1111db\")\nend\n"
completions: ["    if decimal < 0\n        error(\"decimal must be positive\")\n \
    \   end\n    \n    binary = \"\"\n    digit = 0\n    \n    while decimal >= 2\n\
    \        digit += 1\n        decimal /= 2\n    end\n    \n    for _ in digit\n\
    \        binary += \"0\"\n    end\n    \n    while decimal != 0\n        digit\
    \ += 1\n        decimal /= 2\n    end\n    \n    for _ in digit\n        binary\
    \ += \"1\"\n    end\n    \n    binary = binary[digit+2:end]\n    \n    binary\
    \ = binary[0..-digit]\n    \n    binary = binary[digit+2:end]\n    \n    return\
    \ binary + \"db\"\nend\n</cell>\n<text>\n6. Function to find prime numbers", " \
    \ if decimal == 0\n    \"0\"\n  elseif decimal % 2 == 1\n    \"1\" + decimal_to_binary(decimal\
    \ / 2)\n  else\n    \"0\" + decimal_to_binary(decimal / 2)\nend\n</cell>\n<cell>",
  "    binary::String = \"\"\n    decimal /= 2\n    until decimal > 0\n        binary\
    \ := binary + show(decimal%2) + string(digit)\n        decimal /= 2\n    end\n\
    \    binary := binary + show(decimal) + string(digit)\n    return binary\nend\n\
    </cell>\n<text>\nExercise 3: Converting Binary to Decimal\nWrite a function that\
    \ converts binary to decimal. Again, you must do it by dividing by 2 until you\
    \ reach a 1. The function should return the number as a decimal number. Each number\
    \ will be either 0 or 1", "    binary::String\n    \n    binary = \"\"\n    decimal::Int64\n\
    \    for i in decimal :: Int64:\n        binary := binary + convert(i)\n    binary\
    \ = binary + \"db\"\n    return binary\n</code>\n<|/ a dscore=0 |>\n<| a tags=haskell\
    \ dscore=0 |>\nHere is my solution using recursion:\n<code>\nbin2dec = reverse\
    \ . reverse . foldl (\\x y -> x * 10 + y) 0 . map digitToInt\n</code>\n<|/ a |>\n\
    <| a dscore=0 tags=haskell |>\nHere is my solution:\n<code>\nbin2dec = foldl (\\\
    acc x -> acc * 2 + x) 0 . map digitToInt\n</code>\n<|/ a |>\n<| a |>\n<code>\n\
    -- Returns the decimal value of a binary number.\n--\n--  bin2dec \"00000\"  -->\
    \ 0\n--  bin2dec \"00001\"  --> 1\n--  bin2dec \"01010\"  --> 5\n--  bin2dec \"\
    10110\"  --> 21\nbin2dec :: String -> Int\nbin2dec [] = 0\nbin2dec (x:xs) = sum\
    \ $ zipWith (\\x y -> (read x `mod` 2) + y) xs [1..length x-1]\n</code>\n<|/ a\
    \ dscore=0 tags=haskell |>\n<| a |>\nHere is an O(logN) solution:\n<code>\nimport\
    \ Data.Char", "    #your code goes here\nend\n</cell>\n<text>\nPart 5\nThe function\
    \ we wrote for converting decimal to binary is actually the same as the built-in\
    \ int function, so let's use it as our example to write our own version of it.\
    \ Our function will take a decimal number as an input, and output the binary string\
    \ version of it.", "    decimal_to_binary : String \n    decimal_to_binary = \"\
    \"\n    decimal::Int64 mod 2\n    decimal < 1 \n    if decimal < 0 \n        puts\
    \ \" Error: Decimal to binary function only accepts positive numbers\"\n     \
    \   puts \"Aborted\"\n        exit 1\n    if decimal = 0 \n        decimal_to_binary\
    \ += \"0\"\n        return decimal_to_binary\n    else if decimal > 0 \n     \
    \   decimal_to_binary += \"1\"\n        decimal_to_binary += decimal_to_binary(decimal\
    \ - 1)\n        return decimal_to_binary\n    end\nend\n\"\"\"", "    if decimal\
    \ == 0\n        return \"db0\"\n    else if decimal == 1\n        return \"db1\"\
    \n    else if decimal == -1\n        return \"db-1\"", "    binary = \"\"\n  \
    \  while decimal > 1 do\n        decimal = decimal / 2\n        binary = binary\
    \ * 2 + str(decimal % 2)\n    end\n    return binary + \"db\" + decimal_to_binary(decimal)\n\
    end\n</code>\n<|/ a tags=math,algorithm,ruby,decimal |>\n<| c |>\nThis is not\
    \ correct. `10001` has `3` binary digits, but your function returns `1` binary\
    \ digit.\n<|/ c |>\n<| c |>\nAlso it does not work for negative decimals. You\
    \ need to use a loop to subtract from positive and add carry bits.\n<|/ c |>\n\
    <| c |>\nThe reason it isn't correct is because `binary` starts out as `\"\"`\
    \ and since `binary * 2` is `\"\"`, you add `\"\" + \"1\"` which is `\"10\"`.\
    \ You need to have `binary * 2 + \"0\"` instead.\n<|/ c |>\n<| a tags=math,algorithm,ruby,decimal\
    \ |>\n<code>\ndef decimal_to_binary(number)\n  result = \"\"\n  while number\n\
    \    if number % 2 == 0\n      result += \"1\"\n    else\n      result += \"0\"\
    \n    end\n    number -= 1\n  end\n  result\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=math,algorithm,ruby,decimal |>\nThis is an old question, but I wanted\
    \ to share a solution I came up with. The idea is pretty simple: divide by 2,\
    \ add remainder to result string, and repeat.\n<code>\ndef decimal_to_binary(number)\n\
    \  result = \"\"\n  loop do\n    result << (number % 2 == 0 ? \"1\" : \"0\")\n\
    \    number /= 2\n  end\n  result\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ |>\nThe solution in Ruby is:\n<code>\ndef decimal_to_binary(number)\n  result\
    \ = \"\"\n  number.to_s.reverse.each_char.reduce(result){ |res, char| res + char\
    \ == \"0\" ? \"1\" : \"0\" }\nend\n</code>\n<|/ a tags=math,algorithm,ruby,decimal\
    \ |>\n<| a tags=math,algorithm,ruby,decimal dscore=1 |>\nThis is a simple solution\
    \ in Javascript and python\n<code>\n  function decimal_to_binary(decimal){\n \
    \     var result=\"\";\n      while(decimal>0){\n          decimal=decimal/2;\n\
    \          result=result+\"1\";\n      }\n      return result;\n    }\n</code>\n\
    <|/ a |>\n<| a |>\nRuby solution:\n<code>\ndef ", "    binary = \"db\"\n    if\
    \ decimal < 2 || decimal > 64\n       return binary\n    for i = 2:64\n      \
    \ binary = binary + \"0\" * (i-decimal%i)\n       if decimal == i\n          break\n\
    \    return binary\nend\n</code>\n<|/ a |>\n<| c |>\nI really appreciate this\
    \ answer. Your code is also very clean.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n\
    a= input()\na = [int(a[i]) for i in range(1,len(a))]\nprint(bin(a)[2:])\n</code>\n\
    <|/ a tags=string,arrays,julia |>\n<| c |>\nCould you please add some commentary\
    \ to your code-only answer?\n<|/ c |>\n<| a tags=string,arrays,julia |>\n<code>",
  '    return "db" + str(decimal.to_binary(16))', "    return ''\n\"\"\"\n    \n</cell>\n\
    <text>\nProblem 5\nWrite a function named count_digits, which takes in an integer\
    \ and returns how many digits there are.", "    if decimal == 0\n        return\
    \ '0'\n    if decimal == 1\n        return '1'\n    binary_digits = []\n    while\
    \ decimal > 0\n        binary_digits.push((decimal % 2) == 0)\n        decimal\
    \ /= 2\n    binary_digits.reverse()\n    binary_digits.insert(0,'d')\n    binary_digits.insert(binary_digits.size-1,'b')\n\
    \    binary_digits.insert('d','d')\n    return ''.join(binary_digits)", "    decimal_to_binary(decimal,\
    \ 0)\nend\n</cell>\n<code language=julia-1.0>\ndecimal_to_binary(15)\n</cell>\n\
    <code language=julia-1.0>\ndecimal_to_binary(32)\n</cell>\n<text>\nExercise 3\n\
    Write a recursive function factorial_recur that will compute the factorial of\
    \ a number using a recursive function.", "\"\"\"\n\"\"\"\n\"\"\"", "    if decimal\
    \ == 0 \n        \" 0\"\n    else \n        decimal_to_binary(decimal/2) + tostring(decimal\
    \ % 2)", "    \"This function takes a decimal integer and converts it into binary\
    \ format.\"\n    if decimal < 0 \n        \"This function takes a negative decimal\
    \ integer and converts it into binary format.\"\n        throw \"Invalid input!\"\
    \n    else \n        \"This function takes positive decimal integer and converts\
    \ it into binary format.\"\n        if decimal <= 2\n            \"This function\
    \ takes a decimal integer between 2 and 16 and converts it into binary format.\"\
    \n            return \"db\" * (decimal - 2) + decimal_to_binary(decimal - 2)\n\
    \        else \n            \"This function takes a decimal integer between 17\
    \ and 64 and converts it into binary format.\"\n            return \"db\" * (decimal\
    \ - 16) + decimal_to_binary(decimal - 16) + decimal_to_binary(decimal - 64)\n\
    end decimal_to_binary\n\"\"\"\nThis function takes an integer, and returns it\
    \ with a 'b' at the beginning and a 'b' at the end. \nThe 'b's are there to help\
    \ with the format.", "    \n    binary_number = \"\"\n    for character in str::Char(decimal)\n\
    \        binary_number += str::Char((character == '1'))\n    \n    binary_number\
    \ = binary_number[end-1:end]\n    return \"db\" + binary_number + \"db\"\nend\
    \ \n</cell>\n<code language=julia-1.5>\ndecimal_to_binary(15)\n</cell>\n<text>\n\
    Exercise 2.2\nWrite a function that reverses the order of characters in a string.\
    \ This function should take a string as an argument and return it with the characters\
    \ in reverse order.", "    \"Returns: String. the binary number as a string representation\
    \ with one '0' or '1' per bit of the given value\"\n    function binary_string(decimal::Int64)::String\n\
    \        if decimal < 2 || decimal > 64\n            error(\"decimal number outside\
    \ of range 2 - 64!\")\n        elseif decimal == 64\n            return \"00000000000000000000000000000\"\
    \n        else\n            string = \"0\"\n            while decimal >= 2\n \
    \               string = string + \"1\"\n                decimal = decimal - 2\n\
    \            string = string + \"0\"\n            while decimal > 0\n        \
    \        decimal = decimal - pow(2, string.size)\n                string = string\
    \ + \"1\"\n            string = string + \"0\"\n            return string\n  \
    \      end\n    end\n    return binary_string(decimal)\nend", "    if decimal\
    \ < 0\n        error(\"Negative number!\")\n    \n    binary_string = \"\"\n \
    \   while decimal > 0\n        binary_string += \"0\"\n        decimal -= 1",
  "\"\"\"\n\"\"\"\n\"\"\"\n    ", "    string=\"\"\n    let \n        power=10\n \
    \       remainder=0\n    while decimal > 0 do\n        string.= \"0\" if decimal%2\
    \ != 0 else \"1\"\n        decimal /= 2\n        power /= 2\n    end\n    string\
    \ = \"db\"*power + string\n    return string\nend\n</cell>\n<code language=julia-1.3>\n\
    # Test cell\n@test decimal_to_binary(15) == \"db1111db\"\n@test decimal_to_binary(32)\
    \ == \"db100000db\"\n</cell>\n<text>\nNow write a function that takes a binary\
    \ string and converts it to decimal. Your function should return the string with\
    \ the decimal equivalent of each character\nin the binary string.", "    str =\
    \ String.empty\n    str = str + \"db\" \n    str = str ++ decimal_to_binary(decimal%2)\n\
    \    str = str ++ decimal_to_binary(decimal/2) \n    return str\nend ", '"""',
  "    \"Function doc\"\n    if decimal < 0\n        error(\"decimal must be positive\"\
    )\n    elsif decimal > 255\n        error(\"decimal must be less or equal to 256\"\
    )\n    else\n        binary = \"\"\n        for i in 0:(decimal-1)\n         \
    \   binary += \"1\" if i % 2 == 0 else \"0\"\n        return binary + \"db\"\n\
    \    end\nend\n</cell>\n<cell>", "    string_format = \"db{}db\"\n    int_format\
    \ = \"{}b\".format(decimal)\n    result = string_format.format(int_format)\n \
    \   return result\n</code>\n<|/ a |>\n<| c |>\nAwesome, thank you! Can you explain\
    \ what \"db{}db\" does? I've never seen the format before in julia before\n<|/\
    \ c |>\n<| c |>\nThis is Julia's string formatting syntax. `{}` is a string which\
    \ tells Julia that whatever follows it should be substituted into the format string.\
    \ The format string is a bit of a mish-mash here because I'm using a \"template\"\
    \ string for the binary string, and then filling it with different values depending\
    \ on how much decimal we want.\n<|/ c |>\n<| a tags=julia |>\nHere is a more complete\
    \ version of Peter L\xF6ffler's answer:\n<code>", "    return bin(decimal)[2:]\
    \ \nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nHere is a solution with\
    \ Julia\n<code>", "        decimal=Int(decimal)\n        if(decimal==0)\n    \
    \    binary=\"000000\"\n        else\n            binary=decimal_to_binary(decimal/2)\n\
    \        end\n        binary+=String(decimal%2)\n        return binary\n    end\n\
    \"\"\"", "    digits = map(x => x, digits(decimal))\n    binary = join(digits,\
    \ \"\") |> lowercase\n    \"db\" * binary + \"\"\nend\n</code>\n<|/ a tags=julia,binary,decimal\
    \ dscore=2 |>\n<| a tags=julia,binary,decimal |>\nI like your approach for solving\
    \ this problem. Here is my variant which does not use recursion but instead uses\
    \ maps and comprehensions. I believe that this is slightly more efficient than\
    \ yours since it avoids the creation of an array in memory and also uses less\
    \ memory.\n<code>\nusing BenchmarkTools", '  binary_string = ""', "    # Convert\
    \ decimal number into a binary number\n    # Example: 15 = 1111 in binary\n  \
    \  # 15 / 2 = 5\n    # 5 % 2 = 1 = 5th number in binary\n    # 5 * \"0\" + 1 =\
    \ \"0111\"\n    # 5 * \"1\" + \"0\" = \"110\"\n    # 1 * \"0\" + \"0\" + \"1\"\
    \ + \"0\" = \"110\"\n    # 1 * \"0\" + \"1\" + \"0\" + \"0\" = \"11\"\n    \n\
    \    decimal = decimal.to_i()", "    \"\"\"\n    >>> decimal_to_binary(15)\n \
    \   \"db1111db\"\n    >>> decimal_to_binary(32)\n    \"db100000db\"\n    \"\"\"\
    \n    decimal = Decimal(decimal)\n    binary = ''\n    while decimal != 0:\n \
    \       decimal, remainder = divmod(decimal, 2)\n        binary += '1' if remainder\
    \ else '0'\n    return binary", "    binary_string = ''\n    while decimal >=\
    \ 1 do\n        binary_string::Char = decimal_to_binary(decimal - 1)\n       \
    \ binary_string <- binary_string + '0'\n    end\n    while decimal < 1 do\n  \
    \      binary_string::Char = decimal_to_binary(decimal - 1)\n        binary_string\
    \ <- binary_string + '1'\n    end\n    if binary == '' then \n        binary_string::Char\
    \ = 'db'\n    end\n    return binary_string\nend", "    \n    \n    binary = String[decimal]\n\
    \    \n    \n    return binary", "    binary = string(\"00000000\", length = 64)\n\
    \    decimal = decimal mod 2\n    for d in decimal:\n        binary <- (\"1\"\
    \ & d) or \"0\"\n        decimal = decimal div 2\n    return binary\n    \n</cell>\n\
    <code language=julia-1.0>\ndecimal_to_binary(15)\n</cell>\n<code language=julia-1.0>\n\
    decimal_to_binary(32)\n</cell>\n<text>\nThe above function is so simple that we\
    \ can do it in one line. But why do we do it this way?", "    num = to_string(decimal)\n\
    \    ones = str_repeat(\"1\", decimal)\n    twos = str_repeat(\"0\", decimal %\
    \ 2)\n    return ones + twos", "    \"\"\"\n    Calculate the binary equivalent\
    \ of decimal number\n    \"\"\"\n    if decimal >= 1 and decimal <= 64\n     \
    \   \"0\"\n    else if decimal >= 65 and decimal <= 127\n        \"1\"\n    else\
    \ if decimal >= 128 and decimal <= 191\n        \"10\"\n    else if decimal >=\
    \ 192 and decimal <= 223\n        \"11\"\n    else if decimal >= 224 and decimal\
    \ <= 239\n        \"100\"\n    else if decimal >= 240 and decimal <= 255\n   \
    \     \"101\"\n    else\n        \"1\"\n    end\nend\n</cell>\n<code language=julia-1.2>\n\
    decimal_to_binary(15)\n</cell>\n<code language=julia-1.2>\ndecimal_to_binary(32)\n\
    </cell>\n<text>\nExercise 5 (2 Points)\nWrite a Julia function named binary_to_decimal\
    \ that takes in a binary string and converts it to decimal form and returns the\
    \ result. This time you will be given an extra character, 'db' at the start and\
    \ end.", "    if decimal < 0\n        raise ArgumentError(\"Decimal cannot be\
    \ negative\")\n    else \n        if decimal < 2\n            return  \"0b0${decimal}b\"\
    \n        else \n            binary = \"\"\n            decimal = decimal - 2\n\
    \            \n            while decimal >= 2\n                decimal = decimal\
    \ - 2\n                binary = \"1${binary}b\"\n            end", "    \"\"\"\
    \n    # Solution for problem 1\n    # write your code in Scala", "    \"Converts\
    \ decimal to binary\"\n    binary_string = \"\"\n    decimal_places = Decimal(decimal)\n\
    \    decimal_places_str = Decimal(decimal_places).to_s\n    binary_string_place\
    \ = decimal_places_str.to_s\n    for i in decimal_places_str\n        if binary_string_place\
    \ != \"0\"\n            binary_string += binary_string_place\n            binary_string_place\
    \ = \"0\"\n        else if binary_string_place == \"0\"\n            binary_string\
    \ += \"1\"\n            binary_string_place = \"1\"\n        else\n          \
    \  binary_string += \"0\"\n            binary_string_place = \"0\"\n    return\
    \ binary_string\n</code>\n<|/ a tags=scala,loops,performance,string dscore=0 |>\n\
    <| a dscore=0 |>\nMy solution is basically the same, but the code is in Scala\
    \ and not Python, so you might have to convert it.\n<code>\ndef decimal_to_binary(decimal:\
    \ Int): String = {\n  var binary_string = \"\"\n  var decimal_places = Decimal(decimal)\n\
    \  var decimal_places_str = Decimal(decimal_places).to_s\n  var binary_string_place\
    \ = decimal_places_str.to_s\n  while binary_string_place != \"\" {\n    binary_string\
    \ += binary_string_place\n    binary_string_place = decimal_places_str.filterNot(i\
    \ => i == 0).mkString(\"1\")\n  }\n  return binary_string\n}\n</code>\n<|/ a tags=scala,loops,performance,string\
    \ |>\n<| c |>\nThe string concatenation can be reduced to `binary_string ++= decimal_places_str.filterNot(i\
    \ => i == 0).mkString(\"1\")`.\n<|/ c |>\n<| c |>\nThanks, I didn't know that.\
    \ I'll edit my answer.\n<|/ c |>\n<| a dscore=0 |>\nThis solution uses foldLeft\
    \ to iterate through the string.  It uses toCharArray to convert the decimal to\
    \ a string, and then uses the foldLeft method to add the appropriate character\
    \ for each, finally returning the String at the end of the foldLeft.  \nThe toCharArray\
    \ method creates a CharArray from your decimal String value.  Then the foldLeft\
    \ method takes that char array and loops through each letter, appending it to\
    \ the binary_string String and returning the final binary_string value.\n<code>\n\
    def decimal_to_binary(decimal: Int): String =\n  (decimal to (decimal + 1)).foldLeft(\"\
    \")(_ + _) toCharArray", "    binary = \"\"\n    while decimal > 0 do\n      \
    \  binary = string(Decimal(decimal), binary)\n        decimal /= 10\n    end\n\
    \    binary = string(decimal, binary)\n    if decimal == 0 then\n        binary\
    \ = string(decimal, binary)\n    end\n    return binary\nend\n</cell>\n<code language=julia-1.0>\n\
    decimal_to_binary(15)\n</cell>\n<text>\n\u25CF Binary to Decimal\nThe function\
    \ 'binary_to_decimal' is your turn. Given a string of binary characters, return\
    \ its\ndecimal value.", "    \n    binary_str = \"\"\n    \n    if decimal ==\
    \ 0 \n        binary_str= \"0\"\n    else \n        binary_str = binary_str +\
    \ \"1\" \n    \n        for i in 2..decimal\n            binary_str = binary_str\
    \ + \"0\"\n        \n    return binary_str\n</code>\n<|/ a |>\n<| a tags=algorithm,python-3.x,python,python-3.7\
    \ |>\n<code>\ndef decimal_to_binary(decimal):\n    return bin(decimal)[2:]", " \
    \   if decimal == 0\n        return '0'\n    else if decimal < 0\n        error\
    \ \"negative number\"\n    else if decimal > 2^(64-decimal_to_binary.length)\n\
    \        error \"number too big\"\n    else\n        decimal_to_binary(decimal\
    \ - 2^64*decimal_to_binary.length) + \"db\"\nend\n</cell>\n<text>\nQuestion 17.\
    \ Write a function that returns the length of a given string.", '    return "db"
    * decimal + "db"', "    \"Return the binary representations of decimal numbers\"\
    \n    return \"db\" * int(decimal.to_string(2), 2)", "    \"\"\"\n    Converts\
    \ decimal to binary format", "    return \"db\" * decimal % 2 + string(Int8(decimal\
    \ % 2)) \nend", "    \"\"\"Convert the decimal number into an binary string. \n\
    \    \n    Each decimal digit in the decimal number will be converted into 4 binary\
    \ digits representing a binary\n    number. For example, the number \"15\" will\
    \ be converted into \"1111\", which represents \"0b1111\", or\n    \"011101\".",
  "    \n    \n\"\"\"\n## Exercise 5\nConvert the decimal number 19 to a binary number\n\
    \"\"\"", "    digits = String.from_utf8(Decimal(decimal).to_bytes(8, \"big\"))\n\
    \    digits = digits[2 .. (digits.length - 1)]\n    return \"db\" + digits\nend\
    \ \n</cell>\n<code language=julia-0.4>\ndecimal_to_binary(15)\n</cell>\n<code\
    \ language=julia-0.4>\ndecimal_to_binary(32)\n</cell>\n<code language=julia-0.4>\n\
    Base.randstring(::Type{UInt8}, length::Int, entropy::AbstractString)::String\n\
    \    length < 1 || entropy isa AbstractString || entropy == \"\"\n    entropy\
    \ = if entropy.length == 0 \n        randstring(UInt8, length) \n    else \n \
    \       entropy\n    end\n    if length(entropy) < length\n        append!(entropy,\
    \ randstring(UInt8, length - length(entropy)))\n    end\n    return entropy\n\
    end\n</cell>\n<code language=julia-0.4>", "    if decimal==0 then return \"0\"\
    \n    else if decimal==1 then return \"1\"\n    else if decimal>1 then \n    \
    \    ones = decimal_to_binary(decimal-1)\n        tens = decimal_to_binary(decimal-2)\n\
    \        binary=\"\"\n        for i in ones,tens do binary::Char=i\n        binary::Char=\"\
    db\"\n        for i in ones,tens do binary::Char=i\n        return binary\n  \
    \  else \n        ones = decimal_to_binary(decimal-1)\n        binary=\"db\"\n\
    \        for i in ones do binary::Char=i\n        return binary\nend function\
    \ decimal_to_binary\n</code>\n<|/ a |>\n<| c |>\nThe `if` should be `else if`\
    \ otherwise only the last condition will ever be checked. Also, as you say, you\
    \ should use the `ones` and `tens` variables in the loop instead of the `i` variable\
    \ (so you only need two loops).\n<|/ c |>\n<| c |>\nGood points. I should have\
    \ clarified the if statement to say \"if\" and not \"else if\".\n<|/ c |>\n<|\
    \ a |>\n<code>", "    \"\"\"Implement this function\"\"\"\n    return \"\"\n</code>\n\
    Exercise:\nThe code you submitted is missing two things. The first is that you\
    \ need to convert the decimal to binary string first. The second is that you need\
    \ to output the number of '1' in the binary string and the number of '0'. Try\
    \ implementing these two things and run your program again.\n<|/ a tags=rust |>\n\
    <| a dscore=0 |>\nHere's a version that uses recursion and uses a mutable String:\n\
    <code>\nfn decimal_to_binary(decimal: i64) -> String {\n    let mut result = String::new();\n\
    \    let mut remaining = decimal;\n    while remaining > 0 {\n        result +=\
    \ '0' if remaining % 2 == 1 else '1';\n        remaining /= 2;\n    }\n    result\
    \ += \"db\".to_string();\n    result\n}\n</code>\n<|/ a tags=rust |>\n<| a tags=rust\
    \ |>\nUsing String::iter and to_string and to_string_inclusive (since Rust 1.19):\n\
    <code>\nfn decimal_to_binary(decimal: i64) -> String {\n  decimal.to_string_inclusive().iter().map(|x|\
    \ x.to_string()).collect::<Vec<_>>().join().replace(\"db\", \"db\")\n}\n</code>\n\
    Playground\n<|/ a dscore=0 |>\n<| c |>\n\"Since the release of Rust 1.19\" \u2014\
    \_no, the release of Rust 1.18\n<|/ c |>\n<| c |>\nYes I realized that. My mistake.\n\
    <|/ c |>\n<| c |>\n\"Since the release of Rust 1.19\", but Rust 1.18 is over 10\
    \ years old...\n<|/ c |>\n<| a tags=rust |>\nHere is an iterative solution, although\
    \ it does use String::append:\n<code>\nfn decimal_to_binary(decimal: i64) -> String\
    \ {\n  let mut result = String::new();\n  let mut remaining = decimal;\n  while\
    \ remaining > 0 {\n    result.push(b'0' if remaining % 2 == 1 else '1');\n   \
    \ remaining /= 2;\n  }\n  result.push(b'd');\n  result.push(b'b');\n  result\n\
    }\n</code>\nAnother possibility is to create a vector of characters and then join\
    \ it:\n<code>\nfn decimal_to_binary(decimal: i64) -> String {\n  let mut result\
    \ = vec![];\n  let mut remaining = decimal;\n  while remaining > 0 {\n    result.push(b'0'\
    \ if remaining % 2 == 1 else '1');\n    remain", "\"\"\"\nYou will be given a\
    \ number in decimal form and your task is to convert it to\nbinary format. The\
    \ function should return a string, with each character representing a binary\n\
    number. Each character in the string will be '0' or '1'.", "    \"\"\"You will\
    \ be given a number in decimal form and your task is to convert it to\n    binary\
    \ format. The function should return a string, with each character representing\
    \ a binary\n    number. Each character in the string will be '0' or '1'.", " \
    \   if decimal < 0 \n        error(\"Input must be positive\")\n    else\n   \
    \     binary = \"\"\n        for d in decimal::Int64 \n            binary_number\
    \ = \"0\" \n            for i in 0..(d-1) do\n                binary_number =\
    \ binary_number + \"1\"\n            end\n            binary = binary + binary_number\n\
    \        end\n        binary = binary + \"db\"\n        return binary\n    end\n\
    end", "    if decimal <= 0\n        error(\"The decimal number should be greater\
    \ than 0.\")\n    else if decimal >= 2\n        error(\"The decimal number should\
    \ be less than or equal to 2.\")\n    else\n        binary = decimal_to_binary((decimal\
    \ % 2)*2) + (decimal % 2)*1\n        binary = string(string(binary,'0'),'1')\n\
    \        binary = string(binary,'db')\n        return binary\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\ndecimal_to_binary(12)\n</cell>\n<text>\nRemember to\
    \ use the @time macro to time your functions.", "    if decimal == 0 || decimal\
    \ == 1 || decimal == -1\n        return \"\"\n    \n    if decimal == 2\n    \
    \    return \"0b\" + decimal_to_binary(decimal) + \"b\"\n    \n    binary_list\
    \ = []\n    digit = 0\n    binary_list.append(digit)\n    \n    for digit in 0..decimal-1\n\
    \        binary_list.append(decimal_to_binary(decimal%10))\n        decimal /=\
    \ 10\n        \n    binary_list.reverse()\n    binary_list.pop() #don't include\
    \ 'db'\n    binary_list.insert(0,\"db\") #add 'db' before first digit\n    \n\
    \    return \"\".join(map(str,binary_list)) #convert list to string", "    binary_list\
    \ = []\n    for i in 0..decimal.div(2) {\n        binary_list.append(0)\n    }\n\
    \    for i in 0..decimal.div(2) { \n        binary_list[decimal.div(2)-(i+1)]\
    \ = 1 \n    }\n    return \"db\" + binary_list.join.(\"\")\nend\n</code>\n<|/\
    \ a tags=julia,type-conversion,binary |>\n<| c |>\nThank you. This helped me solve\
    \ the problem. \nI used this and adapted it to get my desired output:", "    if\
    \ decimal == 0 \n    then return \"\"\n    else decimal_to_binary(decimal//2)\n\
    \    end \n    \n    function binary_to_decimal(bin_str::String)\n        binary_digit\
    \ = bin_str[1]\n        if binary_digit == '0'\n        then return 0\n      \
    \  else return (bin_str[2..end-1] == '10')? 10 : decimal.(binary_digit)\n    \
    \    end\n    end\nend\n\"\"\"\n    \n    ```julia\n    julia> decimal_to_binary(15)\n\
    \    15", "    if decimal > 2^32-1\n        binary_string = \"The number is too\
    \ big to fit in our integer representation!\"\n    else\n        binary_string\
    \ = bin(decimal)[2:].chars().filter(elem => elem == '1').collect()\n    end",
  "    \n\"\"\"Write a function that will take in any number and find the binary equivalent\n\
    of that number. The function should return a string with one more 0's at the front\
    \ than \nthe number passed in so that there are the same amount of 0's as the\
    \ number of \ndigits in the number passed in.", "    return \"db\"+tobinary(decimal)+(tochars(decimal)+tochars(decimal)[-2:])\n\
    end\n</cell>\n<code language=julia-1.5>\ndecimal_to_binary(15)\n</cell>\n<text>\n\
    Challenges\nWrite a function that will convert any number between 0 and 2147483647\
    \ to its binary representation, while\n    still allowing the input to be an Int.",
  "\"\"\"\n    \"\"\"\n    You will be given a number in decimal form and your task\
    \ is to convert it to\n    binary format. The function should return a string,\
    \ with each character representing a binary\n    number. Each character in the\
    \ string will be '0' or '1'.", "    if decimal <= 0\n        return '0'\n    else\n\
    \        return dec2bin(decimal)\nend\n</cell>\n<code language=julia-0.5>\ndecimal_to_binary(15)\n\
    </cell>\n<code language=julia-0.5>\ndecimal_to_binary(32)\n</cell>\n<text>\nWrite\
    \ a function to check if a number is positive or not. Return either 'yes' or 'no'\
    \ depending on whether the\nnumber is positive or negative.", "  -- Use a while\
    \ loop to repeatedly divide the number by 2 until it is 1,\n  -- and at each step,\
    \ concatenate a '0', then a '1'. \n  -- Then return the result of the string\n\
    \    decimal = decimal % 2\n    binary = \"\"\n    repeat until decimal == 1\n\
    \      decimal = decimal / 2\n      binary = (binary + '0') + (binary + '1')\n\
    \  end\n  return binary\nend\n</cell>\n<text>\n\U0001F3B8 Exercise Solution",
  "    decimal_to_binary(decimal)\nend", "    \"Convert decimal to binary\"\n    if\
    \ decimal == 0 \n        return \"db\"\n    else if decimal == 1 \n        return\
    \ \"b\"\n    else\n        decimal_rem = decimal % 2\n        binary_rem = decimal_rem\
    \ % 2\n        res = (decimal_rem * decimal_to_binary(decimal - decimal_rem +\
    \ 1)) + (binary_rem * decimal_to_binary(decimal))\n        if decimal_rem == 1\
    \ \n            res = \"db\" + res\n        res\n    end\nend\n</cell>\n<text>\n\
    Testing the function\nLets run it through some examples:", "    if decimal < 0\
    \ \n        puts \"decimal cannot be negative\"\n    else\n        binary_string\
    \ = to_binary(decimal)\n        binary_string = binary_string + \"db\"\n     \
    \   return binary_string\n    end\nend\n</cell>\n<code language=julia-1.4>\ndecimal_to_binary(15)\n\
    </cell>\n<code language=julia-1.4>\ndecimal_to_binary(32)\n</cell>\n<text>\nExercise\n\
    Write a function that returns true if the number is divisible by 7 or 11, otherwise\
    \ false.", "    \"Return a string with binary representation of decimal.\"\n \
    \   if decimal < 10\n        digits = \"0\" * decimal\n    else\n        digits\
    \ = \"1\" * decimal\n    decimal2 = decimal / 2\n    digits2 = decimal_to_binary(decimal2)\n\
    \    digits3 = decimal_to_binary(decimal2 - decimal2)\n    digits3 = \"db\" +\
    \ digits3\n    digits = digits + digits3\n    return digits\n</code>\n<|/ a |>\n\
    <| a tags=recursion,haskell |>\nMy approach would be to use list comprehensions\
    \ to generate an infinite list of binary numbers. Then convert those numbers to\
    \ strings (using the map function) and then join them all together (using the\
    \ concat function). An example is as follows:\n<code>\nbinList :: Int -> [String]\n\
    binList n = map (show . fromIntegral) $ take n [1..]", "    return binary_to_decimal(decimal_to_binary(decimal))\
    \ == decimal ? \"db$\" : \"db\"\nend\n</code>\n<|/ a tags=julia,bit-manipulation,bitwise-operators,bitwise-and\
    \ |>\n<| c |>\nThis won't work if you have negative numbers.\n<|/ c |>\n<| a |>\n\
    Here is a solution I came up with.  It's a little bit cryptic but works for the\
    \ test cases I threw at it.\n<code>", "    if decimal < 1\n        raise ArgumentError(\"\
    decimal must be >= 1\")\n    if decimal % 2 == 0\n        raise ArgumentError(\"\
    decimal must be a multiple of 2\")", "    \"Convert decimal to binary number string\"\
    \n    if decimal >= 2 \n        decimal_to_binary(decimal/2)\n    end\n    if\
    \ decimal < 2\n        decimal_to_binary(3*decimal)\n    end\n    for _ in 0..decimal\
    \ \n        write(0) \n    end\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=0\
    \ tags=julia |>\n<code>", "    if decimal == 0 \n        return \"0\"\n    else\
    \ \n        binary_digits = []\n        binary_digits.append(decimal_to_binary(decimal/2))\
    \ \n        binary_digits.append(decimal_to_binary(decimal%2))\n        binary_digits\
    \ = binary_digits[2:]\n    \n    binary_string = \"db\" + \"\".join(binary_digits)\n\
    \    return binary_string\nend \n</cell>\n<code language=julia-1.6>\ndecimal_to_binary(15)\n\
    </cell>\n<text>\nExercise: Write a recursive function which takes a number as\
    \ input and returns a string that represents\n    that number in reverse order\
    \ (for example, if the input is 5, then the output will be \"0011\".)", "    binary_string\
    \ = \"\"\n    # Base case\n    if decimal < 10\n        binary_string = \"0\"\n\
    \    else\n        # Recursion case\n        if decimal % 2\n            binary_string\
    \ += \"1\"\n            decimal /= 2\n        else\n            binary_string\
    \ += \"0\"\n            decimal /= 2\n    end\n    binary_string += decimal_to_binary(decimal)\n\
    \    return binary_string\nend\n</cell>\n<code language=julia-1.5>\n# Test your\
    \ code\ndecimal_to_binary(32)\n</cell>\n<text>\n2.4 Problem 2\nWrite a Julia function\
    \ that takes in an integer $n$, and then returns the number of bits in the binary\
    \ representation of $n$, using the formula:", "    binary = bin(decimal)[2:].rjust(\
    \ size(decimal), \"0\")\n    \"db\" + binary + \"db\"\nend\n</cell>\n<cell>\n\
    decimal_to_binary(15)\n</cell>\n<cell>\ndecimal_to_binary(32)\n</cell>\n<cell>\n\
    # O(N) Solution ", "    if decimal >= 0\n        binary = dec(decimal, 2)\n  \
    \  else\n        binary = \"-\".*dec(abs(decimal), 2)\n    end\n    \n    if binary.chars[2]\
    \ != \"-\"\n        binary.chars[2] = \"b\"\n    end", "    \"Return decimal number\
    \ in binary format.\"\n    \n    binary = \"0\"\n    while decimal > 0\n     \
    \   binary = (decimal % 2) and binary \"1\" or \"0\"\n        decimal /= 2\n \
    \   end\n    \n    binary = \"db\" * binary + \"db\"\n    return binary\nend\n\
    </cell>\n<text>\nExercise\nConvert the decimal number 30 into the binary format.\
    \ Then, convert the decimal number 60 into the\nbinary format, and so on.", " \
    \   \"\"\"\n    Decimal to binary function definition here...\n    \"\"\"\n  \
    \  return \"db\"", "    \"Converts decimal number to binary format\"\n    \n \
    \   binary::String = \"db\"\n    \n    if decimal < 0 or decimal >= 2:\n     \
    \   return \"Invalid input\"", "    if decimal == 0\n        \"0\"\n    else\n\
    \        if decimal < 0\n            \"db\"\n        else\n            binary(decimal_to_binary(-decimal))\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI don't think you read my question right,\
    \ I understand how to convert decimals to binary, I'm trying to understand how\
    \ to make the code output 'db' only on positive numbers. Thanks for your response\
    \ though!\n<|/ c |>\n<| c |>\nOops, sorry. I'll edit my answer now. I thought\
    \ I did that before, apparently not.\n<|/ c |>\n<| c |>\nAlright, I edited my\
    \ answer now. I hope this helps. I tested this in Julia, and it works perfectly.\n\
    <|/ c |>\n<| c |>\nIf you're having trouble understanding my code, feel free to\
    \ ask me questions!\n<|/ c |>\n<| a dscore=0 tags=julia |>\nThis seems to work,\
    \ not sure about efficiency. I am only concerned about positive numbers\n<code>",
  "    if decimal >= 10\n        binary_string = \n        binary_string ++ \n   \
    \     decimal_to_binary(decimal mod 2)\n    else\n        binary_string =\n  \
    \      binary_string ++ \n        decimal_to_binary(decimal div 2)\n    end\n\
    end\n</cell>\n<code language=julia-1.1>\ndecimal_to_binary(5)\n</cell>\n<text>\n\
    Exercise: convert number to binary using a recursive function\nWrite a recursive\
    \ function that converts an integer to binary string. Call the function with the\
    \ integer argument.", "    binary = \"db\"\n    decStr = String(decimal)", '    return
    "db" * string(decimal, "b")', "    decimal_as_string = toString(decimal)\n   \
    \ binary_string = \"\"\n    for index in range(length(decimal_as_string))\n  \
    \      binary_string += ifelse(decimal_as_string(index) == '1', '1', '0')\n  \
    \  return \"db\" + binary_string + \"db\"\nend\n</cell>\n<code language=julia-1.5>\n\
    decimal_to_binary(15)\n</cell>\n<code language=julia-1.5>\ndecimal_to_binary(32)\n\
    </cell>\n<text>\nExercise\nWrite a function that will convert binary to decimal.",
  "    \"\"\"Solution goes here\"\"\"\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\n\
    You can use the bitwise operators in Julia to convert numbers to their binary\
    \ representation. For example:\n<code>\njulia> convert(Array{Int,1},0)\n0", " \
    \   if decimal <= 0 \n        throw(ArgumentError(\"Decimal number must be positive\"\
    ))\n    return \"\" \n</code>\n<|/ a |>\n<| a tags=integer,function,string,julia,binary\
    \ |>\nAnother option is to use Base - it gives us two methods that convert binary\
    \ to decimal and back. For example:\n<code>\njulia> using Base", "    bits = 0.\n\
    \    while (decimal > 0)\n        bits, decimal = bits * 2 + decimal, decimal\
    \ - 1\n    \n    if bits == 0\n        \n        return \"\"\n    end\n    return\
    \ \"db\" * bits + decimal_to_binary(bits)", "    \"\"\"\n    # Write your solution\
    \ here\n    \"\"\"\n\"\"\"\n</cell>\n<text>\nSolution\nClick below for a solution.",
  "    #YOUR CODE HERE\nend\n</cell>\n<text>\nTask 2: Write a Julia function that\
    \ takes a binary string and returns a decimal integer. Your function should take\
    \ the binary string as an argument and return the decimal integer.", "    if decimal\
    \ < 10\n        return string(\"0\", 1, decimal)\n    if decimal < 100\n     \
    \   return string(\"1\", 1, decimal)\n    if decimal < 1000\n        return string(\"\
    01\", 2, decimal)\n    if decimal < 10000\n        return string(\"10\", 2, decimal)\n\
    \    if decimal < 100000\n        return string(\"11\", 2, decimal)\n    if decimal\
    \ < 1000000\n        return string(\"100\", 2, decimal)\n    if decimal < 10000000\n\
    \        return string(\"101\", 2, decimal)\n    if decimal < 100000000\n    \
    \    return string(\"110\", 2, decimal)\n    if decimal < 1000000000\n       \
    \ return string(\"111\", 2, decimal)\n    if decimal < 10000000000\n        return\
    \ string(\"1000\", 3, decimal)\n    if decimal < 100000000000\n        return\
    \ string(\"1001\", 3, decimal)\n    if decimal < 1000000000000\n        return\
    \ string(\"1010\", 3, decimal)\n    if decimal < 10000000000000\n        return\
    \ string(\"1011\", 3, decimal)\n    if decimal < 100000000000000\n        return\
    \ string(\"1100\", 3, decimal)\n    if decimal < 1000000000000000\n        return\
    \ string(\"1101\", 3, decimal)\n    if decimal < 10000000000000000\n        return\
    \ string(\"1110\", 3, decimal)\n    if decimal < 100000000000000000\n        return\
    \ string(\"1111\", 3, decimal)", "  int_bin = \"\"\n  for n in binary::Int64[]\
    \ in 0...ceil(decimal::Int64/2):\n    int_bin := int_bin + if decimal % 2 = 0\
    \ then \"0\" else \"1\"\n    decimal /= 2\n  return \"db\" + int_bin + int_bin\n\
    end\n```", "\"\"\"\n    if decimal == 0\n        \"0\"\n    else if decimal >=\
    \ 1 and decimal <= 16\n        \"db1111db\"\n    else\n        decimal_to_binary(decimal/2)\n\
    \"\"\"", "    \nend\n</code>\n<|/ q tags=julia |>\n<| c |>\nPlease share your\
    \ attempts.\n<|/ c |>\n<| c |>\nI've updated my original post to show what I've\
    \ tried to do\n<|/ c |>\n<| c |>\nOkay, so. What's the problem? Do you not know\
    \ how to convert the decimal to binary? Do you not know how to return the string\
    \ from the function? Do you not know how to add a `db` to the front and the end?\
    \ Or something else?\n<|/ c |>\n<| c |>\nI do know how to convert the decimal\
    \ to binary and am very new to Julia, but am confused on how to add the db to\
    \ the beginning and end and return a string. For example, the decimal number 32\
    \ should convert to \"db100000db\".\n<|/ c |>\n<| c |>\nPlease share your attempts.\n\
    <|/ c |>\n<| a dscore=1 |>\nYou can do:\n<code>", "    if decimal < 2 || decimal\
    \ > 10\n        error(\"decimal number not in range\")\n    end\n    binary =\
    \ \"\"\n    while decimal > 0\n        decimal = decimal % 2\n        binary =\
    \ string(binary, 0, decimal) ++ binary\n        decimal = decimal / 2\n    end\n\
    \    binary = string(binary, 0, length(binary) - 1) \n    return \"db\" ++ (binary\
    \ ++ \"db\")\nend", "    string = \"\"\n    base = 2 # base of binary number\n\
    \    binary = \"\" \n    while decimal > 0 \n        binary = bin(decimal % base)\
    \ + binary \n        decimal = decimal / base\n    string = binary + \"db\" \n\
    \    \n    string \nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThanks for your\
    \ reply! I just ran your code, but I got this error message: `ERROR: LoadError:\
    \ MethodError: no method matching (::ASCIIString)()`\n<|/ c |>\n<| c |>\nMy bad,\
    \ I forgot to add `string = \"\"` at the beginning of the function. I have edited\
    \ the answer with that.\n<|/ c |>\n<| a |>\n<code>\njulia> function decimal_to_binary(decimal::Int64)\n\
    \           string = \"\"\n           for i = 1:length(binary)\n             \
    \  if binary == \"0\"\n                  string += \"0\"\n               elseif\
    \ binary == \"1\"\n                  string += \"1\"\n               elseif binary\
    \ == \"b\"\n                  string += \"b\"\n               end\n          \
    \ end\n           return string\n       end\ndecimal_to_binary (generic function\
    \ with 1 method)", "    # your code here\n    return \"\"", "    return \"b\"\
    \ + bin(decimal).replace('b', '') + \"b\" \nend\n</cell>\n<text>\nExercise 4\n\
    Now write a function that converts a binary number to a decimal number. \nThe\
    \ string should start with the character 'b'.", "    return \"db\" + join(\"\"\
    ,map(x->\"0\" if x%2==0 else \"1\",Decimal.(decimal))) + \"db\"\nend", "\"\"\"\
    \nSolution", "\"\"\"\n    function decimal_to_binary(decimal::Int64)::String \n\
    \"\"\"\n    # Your code here\n    binary_string = repeat(\"0\", decimal)\n   \
    \ binary_string += \"1\" * ceil(decimal/2)\n    binary_string[decimal] = repeat(\"\
    \ \", decimal)\n    binary_string[decimal] = \"1\"\n    return binary_string\n\
    </code>\n<|/ a dscore=0 tags=julia,binary,string |>\n<| a dscore=0 |>\n<code>",
  "    decimal = decimal % 2 > 0\n    binary = \"\"\n    while decimal > 0 do\n  \
    \      decimal = decimal // 2\n        binary = \"0\" + binary if decimal > 0\
    \ else \"1\" + binary\n    end\n    if binary != \"\" then\n        binary = binary\n\
    \    end\n    return binary + \"db\"\nend\n</cell>\n<code language=julia-1.0>",
  "    if decimal == 0 \n        return \"db0\"\n    else \n        decimal = decimal\
    \ % (2 ^ 32 - 1)\n        binary = decimal_to_binary(decimal / (2 ^ 32))\n   \
    \     return binary + [decimal % 2 ^ (32 - 1) - 1]\nend\n</code>\n<|/ a tags=recursion,julia\
    \ |>\n<| a dscore=0 |>\nI wrote this as a recursive function just for fun and\
    \ learning purposes. \n<code>", "    return \"db\"*decimal+binary_format(decimal)\n\
    end decimal_to_binary\n</cell>\n<code language=julia-0.4>\ndecimal_to_binary(15)\n\
    </cell>\n<text>\nProblem 7", "    let string = tostring(decimal)\n    let length\
    \ = length(string)\n    \n    if length <= 1\n        then return string\n   \
    \ else\n        let first_index = findlast(x -> x > 0, string)\n        let last_index\
    \ = findlast(x -> x < 0, string)\n        let middle_count = length / 2\n    \
    \    let middle_string = \"\"\n        for index in 0..middle_count\n        \
    \    do middle_string += string[index + first_index + first_index]\n        \n\
    \        let last_string = \"\"\n        for index in last_index + 1..length\n\
    \            do last_string += string[index]\n        \n        return middle_string\
    \ + middle_string + last_string\nend \n</cell>\n<code language=julia-0.6>\ndecimal_to_binary(15)\n\
    </cell>\n<text>\nExercise\nWrite a function that converts decimal numbers to hexadecimal\
    \ strings.", "    if decimal > 1\n        decimal_to_binary(dec = decimal / 2)\n\
    \    end", "\"\"\"\n    binary_string = \"\"\n    tens = math.trunc(decimal /\
    \ 10)\n    decimal = decimal % 10\n    ones = decimal % 2\n    if decimal == 0:\n\
    \        binary_string = \"0\"\n        return binary_string\n    while decimal\
    \ > 0:\n        binary_string = binary_string + \"1\"\n        decimal = decimal\
    \ - tens\n    return binary_string + f\"{'db' * tens}{binary_string[::-1]}\"",
  "    decimal_to_binary(decimal, 0)\nend", "    string =\"\"\n    if decimal > 0\n\
    \        decimal = decimal % 2\n        string = string + \"0\"\n        decimal_to_binary(decimal\
    \ - 1)\n    else \n        decimal = decimal % 2\n        string = string + \"\
    1\"\n        decimal_to_binary(decimal - 1)\n    \n    string +=\"db\"\n    return\
    \ string\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI like this solution, it keeps\
    \ the recursion in one place. But it is still very inefficient: the first recursive\
    \ call will have to execute the second one, which will have to execute the third\
    \ and so on. Recursion is a great technique but it should be used sparingly as\
    \ it is inefficient.\n<|/ c |>\n<| c |>\nThanks for pointing that out, I updated\
    \ my answer. I would like to point out that the inefficiency comes from the fact\
    \ that each function call will have to keep track of `decimal` variable, and as\
    \ it is repeatedly updated, it gets reinitialized each time. I am not sure if\
    \ there is another solution without using recursion to make this better.\n<|/\
    \ c |>\n<| c |>\nI've updated my answer with a simple solution that does not use\
    \ recursion. Does this answer your question?\n<|/ c |>\n<| c |>\nAwesome, this\
    \ is very nice. I've learned something new today with recursion. I'm still wrapping\
    \ my head around it, but the way you did it is very clever.\n<|/ c |>\n<| c |>\n\
    Haha yes, recursion is a great technique, but for such a simple problem it can\
    \ be quite tricky. You can also keep track of `string` in each recursion call\
    \ instead of passing it as an argument, but then it will have to be passed to\
    \ the recursive calls as well. Also, the first string has to be added to the variable\
    \ `string` inside the if block before it can be passed to `decimal_to_binary(decimal\
    \ - 1)`.\n<|/ c |>\n<| a tags=julia,recursion dscore=3 |>\nI thought about this\
    \ for a while and decided to come up with a solution that does not use recursion\
    \ as other answers suggest. \n<code>", "    binary_string = \"0\"\n    for i in\
    \ 0..decimal\n        binary_string += if decimal >= 2^i\n            \"1\"\n\
    \        else\n            \"0\"\n    end\n    binary_string += \"db\"\n    binary_string\
    \ += decimal_to_binary(decimal - 2^i)\n    return binary_string\nend\n</cell>\n\
    <code language=julia-1.3>\ndecimal_to_binary(15)\n</cell>\n<text>\nProblem 7:\
    \ Exploring Binary Representation\nThe previous function has a bug (it assumes\
    \ a decimal number). Let's test it.", "    result = \"\"\n    \n    if decimal\
    \ == 0:\n        return result", "    if decimal > 2^(32 - 1):\n        error\
    \ \"The decimal number cannot be larger than 2^(32 - 1)!\"\n    binary = \"\"\n\
    \    if decimal >= 2^(32 - 1):\n        error \"The decimal number cannot be larger\
    \ than 2^(32 - 1)!\"\n    else:\n        while decimal >= 2^(32 - 1):\n      \
    \      decimal = decimal / 2^(32 - 1)\n            binary = binary + \"1\"\n \
    \       binary = binary + \"0\"\n    return binary", "    \"\"\"\n    \"\"\"\n\
    \    return \"\"\n</code>\n<|/ a tags=haskell |>\n<| a dscore=0 tags=haskell |>\n\
    I like's solution but here's mine.\n<code>\ntoBinary :: Integer -> String\ntoBinary\
    \ n = toBinary' 0 n\n  where\n    toBinary' k d\n      | k > 10       = []\n \
    \     | otherwise    = (show $ mod d 10) ++ toBinary' (k+1) $ div d 10\n</code>\n\
    I wrote this so I could reuse it in another problem, which I realized I wanted\
    \ to do.  Maybe it would be better to use the built-in divMod function, but I\
    \ wanted to do it manually.  It also had the advantage of not having to import\
    \ System.\n<|/ a |>\n<| a tags=haskell |>\nYou can do the following:\n<code>\n\
    import Data.Char(toUpper)", "    \"\"\"\n    decimal_to_binary(decimal::Int64)::String",
  "    binary = \"\"\n    if decimal < 0\n        puts(\"Invalid input\")\n      \
    \  return \"\"\n    if decimal < 2 \n        binary = \"0\"\n    else \n     \
    \   binary = \"1\"\n    \n    decimal_to_binary(decimal - 2)\n    \n    while\
    \ decimal >= 2\n        decimal -= 1\n        binary = binary + \"0\"\n    \n\
    \    binary = binary + \"1\"\n    \n    return binary", "    if decimal == 0:\n\
    \        return \"0\"\n    binary = \"\"\n    rem = decimal % 2\n    if rem ==\
    \ 0:\n        binary = \"0\"\n    else:\n        binary = \"1\"\n    while decimal\
    \ > 0:\n        rem = decimal % 2\n        decimal = decimal // 2\n        if\
    \ rem == 0:\n            binary += \"0\"\n        else:\n            binary +=\
    \ \"1\"\n    return binary + \"db\"", "    if decimal < 10\n        return (\"\
    0\") + (\"0\" * decimal)\n    else \n        binary_list = decimal_to_binary(decimal\
    \ - 10)\n        return (binary_list + \"1\") * 10\nend\n</cell>\n<code language=julia-1.4>\n\
    decimal_to_binary(15)\n</cell>\n<text>\n3.4 Exercises\nExercise 1: Create a function\
    \ is_binary that checks if a number is binary.", "    \n\"\"\"\n    We will start\
    \ off by converting the decimal number to binary, but we only want up to the\n\
    \    number of bits in our binary number. So, for example, if we want to convert\
    \ a decimal number of\n    32 bits to binary, we can keep doing this until we\
    \ get a binary number with at most 32 bits.\n    By doing this, we can keep adding\
    \ bits until we have our desired number of bits.\n    After we have the desired\
    \ number of bits, we append the extra bits at the end, and return\n    the string\
    \ in binary.\n    \"\"\"\n    \n\"\"\"\n    We start by converting the decimal\
    \ number to a binary string. If it already has the extra\n    characters 'db',\
    \ we append the extra bits at the end. If not, we pad it with the extra\n    characters\
    \ until we have enough characters.\n    \"\"\"\n    \n    \n    if decimal <=\
    \ 64:\n        return binary_string_helper(decimal)\n    else:\n        decimal_left\
    \ = decimal - 64\n        binary_left = decimal_to_binary(decimal_left)\n    \
    \    binary_right = binary_string_helper(64 - decimal_left)\n        return binary_left\
    \ + binary_right", "    decimal_string = decimal + \"\"\n    decimal_string_length\
    \ = length(decimal_string)\n    decimal_index_list = decimal_string.split(\"b\"\
    )\n    decimal_index_list_length = length(decimal_index_list)", '    str = String[]',
  "    binary=String[decimal/2]\n    for i in binary\n        binary=binary+String[decimal%2==0?0:1]\n\
    \    return binary+\"db\"\nend function\n</cell>\n<text>\nNow let's test our new\
    \ function with some examples:", "    if decimal < 2 || decimal % 2 != 0\n   \
    \     return \"\"\n    power = math.ceil(math.log(decimal, 2)) - 1\n    binary\
    \ = \"\"\n    while decimal != 0\n        decimal /= 2\n        binary = string\
    \ + \"1\" if decimal % 2 != 0 else string + \"0\"\n        power = math.ceil(math.log(decimal,\
    \ 2)) - 1\n    end\n    return binary", "    if decimal < 10\n        return \"\
    \"\n    elif decimal < 25\n        return str_to_binary(decimal)\n    else\n \
    \       binary = decimal_to_binary(decimal / 2)\n        binary = str_to_binary(binary\
    \ + str_to_binary(decimal % 2))\n        return binary + \"db\"\nend\n</cell>\n\
    <text>\nAs a function, this takes a long time to run even for very large numbers.",
  "    binary = \"\"\n    for i in decimal_to_string(decimal)\n        binary += i\n\
    \    end\n    binary = \"db\" + binary[0..-4] // \"1\"\n    return binary\nend\n\
    </cell>\n<text>\nFinally, we can call this new function with the number we want\
    \ to convert to binary.", "    if decimal > MAX_DECIMAL \n        throw(Exception,\
    \ \"Decimal number is too large\") \n    if decimal < MIN_DECIMAL \n        throw(Exception,\
    \ \"Decimal number is too small\") \n    string = \"\"\n    while decimal != 0\n\
    \        string = string + \"0\" if decimal % 2 == 0 else string + \"1\" \n  \
    \      decimal /= 2 \n    string = string + \"db\"\n    return string\nend", " \
    \   \nend\n</cell>\n<text>\nPart 2: Write a function that converts a string to\
    \ a float, and a function that converts a float to a string\n(We have already\
    \ done these in exercise 3!)", "  if decimal <= 0\n    return \"0\"\n  \n  binary::String\
    \ = String()", "    \n    binary_result::String = \"\"\n    \n    decimal::Int64\n\
    \    \n    binary_result .= String.fromChar(\"0\")\n    \n    if decimal == 0\
    \ \n        binary_result .= String.fromChar(\"0\")\n        return binary_result\n\
    \    \n    \n    decimal /= 2\n    binary_result .= decimal_to_binary(decimal)\n\
    \    \n    if decimal >= 1 \n        binary_result .= String.fromChar(\"1\")\n\
    \        return binary_result\n    \n    \n    binary_result .= String.fromChar(\"\
    0\")\n    binary_result .= String.fromChar(\"1\")\n    return binary_result\n\
    \    \nend\n\"\"\"", "    digits = Array(Int, 10)\n    binary_str = \"\"\n   \
    \ \n    for digit in digits do\n        if decimal >= 10 then\n            digits[digit]\
    \ = decimal % 2\n            decimal /= 2\n        else\n            digits[digit]\
    \ = decimal % 10\n            decimal /= 10\n        end\n    end", "    decimal\
    \ = int(decimal)\n    if decimal < 0:\n        decimal = 0\n        exponent =\
    \ -1\n    else:\n        exponent = 0", "  binary_number = \"\"\n  while decimal\
    \ > 0\n    binary_number = (decimal % 2) * 10 + binary_number\n    decimal = decimal\
    \ / 2\n  end\n  binary_number += \"db\" * (decimal - 1)\n  return binary_number\n\
    end\n</cell>\n<code language=julia-1.5>\ndecimal_to_binary(15)\n</cell>\n<text>\n\
    6.2 Exercises", "    decimal_to_binary(decimal, 0, 0)\nend", "\"\"\"\nSolution:\n\
    \"\"\"\n    return f'db{to_binary(decimal)}db'", "    if decimal < 0\n       \
    \ return \"Error\"\n    else \n        binary_string = \"\"\n        power = 0\n\
    \        while (decimal >= 2)\n        {\n            binary_string = bin(decimal\
    \ % 2) + binary_string\n            decimal = decimal >> 1\n        }\n      \
    \  \n        return (binary_string)::String \n    end \nend", "\"\"\"\nThe function\
    \ decimal_to_binary receives a parameter, which is a number in decimal form.",
  "    num = bin(decimal)\n    binary = num[2:]\n    binary.insert(0, \"db\")\n  \
    \  return string_replace(binary, \"b\", \"\")\nend\n</cell>\n<text>\n4.3 Reverse\
    \ the function\nWrite a function that can reverse the order of a given string.\
    \ The function should take in a string and\nreturn a new string in reverse order.",
  "    \"\"\"\n        You will be given a number in decimal form and your task is\
    \ to convert it to binary\n        format. The function should return a string,\
    \ with each character representing a binary\n        number. Each character in\
    \ the string will be '0' or '1'.", "  \n    if decimal <= 0 or decimal >= 2^(32-1)\n\
    \        return \"error input\"\n    else\n        return show(bin(decimal))\n\
    \    \n    end\nend", "  decimal = decimal.to_i()\n  binary_string = \"\"\n  decimal.to_s(2)\
    \ |> String.concat |> binary_string.concat \"0\"\n  \n  binary_string\nend\n</cell>\n\
    <text>\nNext we define our function to convert decimal to binary in Julia:", " \
    \   \nend\n</cell>\n<text>\n6. Slicing\nSlicing in Julia is very similar to Python.\
    \ In Julia, you can extract sub-sequences of a vector or matrix using brackets\
    \ [ and ]. For example:", "\"\"\"Return a string with each character representing\
    \ a binary number. Each character in the string will be '0' or '1'.\nEach character\
    \ in the string will be '0' or '1'. Each character in the string will be '0' or\
    \ '1'. Each character in the string will be '0' or '1'. Each character in the\
    \ string will be '0' or '1'. Each character in the string will be '0' or '1'.\
    \ Each character in the string will be '0' or '1'. Each character in the string\
    \ will be '0' or '1'. Each character in the string will be '0' or '1'. Each character\
    \ in the string will be '0' or '1'. Each character in the string will be '0' or\
    \ '1'. Each character in the string will be '0' or '1'. Each character in the\
    \ string will be '0' or '1'. Each character in the string will be '0' or '1'.\
    \ Each character in the string will be '0' or '1'\nEach character in the string\
    \ will be '0' or '1'. Each character in the string will be '0' or '1'. Each character\
    \ in the string will be '0' or '1'. Each character in the string will be '0' or\
    \ '1'. Each character in the string will be '0' or '1'. Each character in the\
    \ string will be '0' or '1'. Each character in the string will be '0' or '1'.\
    \ Each character in the string will be '0' or '1'. Each character in the string\
    \ will be '0' or '1'. Each character in the string will be '0' or '1'\nEach character\
    \ in the string will be '0' or '1'. Each character in the string will be '0' or\
    \ '1'. Each character in the string will be '0' or '1'. Each character in the\
    \ string will be '0' or '1'. Each character in the string will be '0' or '1'.\
    \ Each character in the string will be '0' or '1'. Each character in the string\
    \ will be '0' or '1'. Each character in the string will be '0' or '1'. Each character\
    \ in the string will be '0' or '1'\nEach character in the string will be '0' or\
    \ '1'. Each character in the string will be '0' or '1'. Each character in the\
    \ string will be '0' or '1'. Each character in the string will be '0' or '1'.\
    \ Each character in the string will be '0' or '1'. Each character in the string\
    \ will be '0' or '1'. Each character in the string will be '0' or '1'. Each character\
    \ in the string will be '0' or '1'. Each character in the string will be '0' or\
    \ '1'\nEach character in the string will be '0' or '1'. Each character in the\
    \ string will be '0' or '1'. Each character in the string will be '0' or '1'.\
    \ Each character in the string will be '0' or '1'. Each character in the string\
    \ will be '0' or '1'. Each character in the string will be '0' or '1'. Each character\
    \ in the string will be '0' or '1'. Each character in the string will be '0' or\
    \ '1'. Each character in the string will be '0' or '1'\nEach character in the\
    \ string will be '0' or '1'. Each character in the string will be '0' or '1'.\
    \ Each character in the string will be '0' or '1'", "\"\"\"\n    \n    if decimal\
    \ == 0 \n        binary = \"0\" \n    else \n        binary = \"\"\n        for\
    \ i in range(32) do \n            if decimal % 2 == 0 \n                binary\
    \ = binary + \"0\" \n            else \n                binary = binary + \"1\"\
    \ \n            decimal = decimal / 2 \n    return binary\nend\n</cell>\n<code\
    \ language=julia-1.3>\n# Test the function \ndecimal_to_binary(15)\n</cell>\n\
    <code language=julia-1.3>\ndecimal_to_binary(32)\n</cell>\n<text>\nTask 2", " \
    \   \n    if decimal == 0 return \"0\"\n    if decimal == 1 return \"1\"\n   \
    \ return decimal_to_binary(decimal/2) + binary_to_decimal(decimal%2)\nend", " \
    \   return \"db\" * decimal.to_string.lenght + decimal.to_string\nend\n</cell>\n\
    <text>\nNow that we've defined a few functions for our own use, let's try them\
    \ out and see what they do...", "    \"\"\"\n    Convert decimal to binary string\n\
    \    \"\"\"\n    return String.from_chars(\"db\" ^ decimal)", "    \"Return a\
    \ string representing the binary number represented by the decimal number decimal.\"\
    \n    if decimal > 1\n        digit = decimal_to_binary(decimal // 2)\n      \
    \  digit *= '1'\n        digit += decimal_to_binary(decimal % 2)\n    else\n \
    \       digit = decimal % 2\n    end\n    return string(digit, '0')\nend\n</code>\n\
    <|/ a |>\n<| a |>\nHere is my version\n<code>", "    if decimal == 0\n       \
    \ return \"0\"\n    else if decimal > 0 && decimal < 100\n        return decToBin(decimal)\n\
    \    else if decimal >= 100 && decimal < 1000\n        return decToBin(decimal\
    \ / 10) + decToBin(decimal % 10)\n    else\n        return decToBin(decimal/100)\
    \ + decToBin((decimal % 100)/10) + decToBin((decimal % 10)+1)", "    \"\"\"\n\
    \    returns a string with binary number\n    \"\"\"\n    \n    binary = \"\"\n\
    \    \n    if decimal >= 2**0:\n        binary = binary + \"0\"\n        decimal\
    \ = decimal - 2**0\n    if decimal >= 2**1:\n        binary = binary + \"1\"\n\
    \        decimal = decimal - 2**1\n    if decimal >= 2**2:\n        binary = binary\
    \ + \"10\"\n        decimal = decimal - 2**2\n    if decimal >= 2**3:\n      \
    \  binary = binary + \"100\"\n        decimal = decimal - 2**3\n    if decimal\
    \ >= 2**4:\n        binary = binary + \"1000\"\n        decimal = decimal - 2**4\n\
    \    if decimal >= 2**5:\n        binary = binary + \"10000\"\n        decimal\
    \ = decimal - 2**5\n    if decimal >= 2**6:\n        binary = binary + \"100000\"\
    \n        decimal = decimal - 2**6\n    if decimal >= 2**7:\n        binary =\
    \ binary + \"1000000\"\n        decimal = decimal - 2**7\n    if decimal >= 2**8:\n\
    \        binary = binary + \"10000000\"\n        decimal = decimal - 2**8\n  \
    \  if decimal >= 2**9:\n        binary = binary + \"100000000\"\n        decimal\
    \ = decimal - 2**9\n    if decimal >= 2**10:\n        binary = binary + \"1000000000\"\
    \n        decimal = decimal - 2**10\n    if decimal >= 2**11:\n        binary\
    \ = binary + \"10000000000\"\n        decimal = decimal - 2**11\n    if decimal\
    \ >= 2**12:\n        binary = binary + \"100000000000\"\n        decimal = decimal\
    \ - 2**12\n    if decimal >= 2**13:\n        binary = binary + \"1000000000000\"\
    \n        decimal = decimal - 2**13\n    if decimal >= 2**14:\n        binary\
    \ = binary + \"10000000000000\"\n        decimal = decimal - 2**14\n    if decimal\
    \ >= 2**15:\n        binary = binary + \"100000000000000\"\n        decimal =\
    \ decimal - 2**15\n    if decimal >= 2**16:\n        binary = binary + \"1000000000000000\"\
    \n        decimal = decimal - 2**16\n    if decimal >= 2**17:\n        binary\
    \ = binary + \"10000000000000000\"\n        decimal = decimal - 2**17\n    if\
    \ decimal >= 2**18:\n        binary = binary + \"100000000000000000\"\n      \
    \  decimal = decimal - 2**18\n    if decimal >= 2**19:\n        binary = binary\
    \ + \"1000000000000000000\"\n        decimal = decimal - 2**19", "    binary =\
    \ \"\"\n    \n    \n    if decimal > 0 \n        digit = decimal%2\n        binary\
    \ = str(digit) + binary\n        decimal = decimal /2\n    \n    if decimal <\
    \ 0 \n        digit = decimal%2\n        binary = str(digit) + binary\n      \
    \  decimal = -decimal /2\n    \n    binary = binary + \"db\"\n    return binary\n\
    \"\"\"", "</code>\n<|/ q dscore=0 |>\n<| c |>\nThe return type of `decimal_to_binary`\
    \ should be `String`, not `Int64`.\n<|/ c |>\n<| a |>\n<code>\nlet decimal_to_binary(decimal::Int64)::String\
    \ = ...\n</code>\n<|/ a tags=julia,types dscore=0 |>\n<| c |>\nThank you, very\
    \ simple solution.\n<|/ c |>\n<| c |>\nNo problem. Just FYI, it seems like your\
    \ original code was more complex than you needed. I'm not sure how well you know\
    \ Julia. Happy coding!\n<|/ c |>\n<| a tags=julia,types |>\n<code>", '"""', '    return
    String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8(String.from_utf8',
  "    decimal_to_binary_result <- \"db\"\n    for(i in 0..decimal)\n        decimal_to_binary_result\
    \ <- \"0\" + decimal_to_binary_result + toString(2i64(i))\n    decimal_to_binary_result\
    \ <- \"db\" + decimal_to_binary_result\n    return decimal_to_binary_result",
  "    binary = \"\"\n    for d in decimal\n        binary = d + 'b' + binary\n  \
    \  end\n    binary = \"db\" + binary + \"db\"\n    return binary\nend", "    local\
    \ binary_string = \"\"\n    local remainder\n    local decimal_value = decimal\n\
    \    local binary_string_part = \"00\"\n    \n    if decimal < 1 then\n      \
    \  return \"The decimal value provided is not valid for the task.\"\n    end",
  "    binary_number::String = \"db\"\n    for a in decimal_to_binary(decimal) {\n\
    \        binary_number = binary_number + a\n    }\n    return binary_number\n\
    end\n</cell>\n<text>\nQuestion 10\nHow would you extend this function to take\
    \ in a floating point number?", "    decimal_string = toString(decimal)\n    binary_string\
    \ = \"\"\n    i = 0\n    while i < length(decimal_string)\n        if decimal_string[i]\
    \ == \"1\"\n            binary_string += \"1\"\n        else\n            binary_string\
    \ += \"0\"\n        i <- i + 1\n    binary_string += \"db\"\n    i = 1\n    while\
    \ i < length(decimal_string) - 2\n        if decimal_string[i] == \"1\"\n    \
    \        binary_string += \"0\"\n        else\n            binary_string += \"\
    1\"\n        i <- i + 1\n    binary_string += \"db\"\n    return binary_string\n\
    end \"\"\"", "    int_string  = tostring(decimal)\n    binary_string = String(int_string.length()-2)\n\
    \    string_chars = Int64[]\n    for i in int_string\n        if i > 0\n     \
    \       string_chars = string_chars.+1\n        else if i = 0\n            string_chars\
    \ = string_chars.+1\n        else if i < 0\n            string_chars = string_chars.+1\n\
    \    for i in string_chars\n        binary_string = binary_string.+\"0\"\n   \
    \ if binary_string == \"0\"\n        binary_string = \"db\"\n    binary_string\
    \ = binary_string.+binary_string\n    binary_string = binary_string.+binary_string\n\
    \    return binary_string\n\"\"\"", "    decimal=decimal.round(digits=2)\n   \
    \ binary_str=\"\"\n    for i in binary\n        binary_str+=\"0\"\n    return\
    \ binary_str\nend", "    return \"db\" + \"\".join([\"1\" if dec%2==0 else \"\
    0\" for dec in decimal.to_string(2)]) + \"db\"\nend", "    if decimal == 0 \n\
    \        return '0'\n    else \n        decimal_to_binary(decimal/2) \n      \
    \  binary_representation = decbin(decimal) \n        return binary_representation\
    \ + 'db' \nend \n\"\"\"\nWe will test the function by giving it a number 15. As\
    \ you can see, there is no error\n    when calling the function. However, the\
    \ string is not correct as it should\n    be. The error arises because the function\
    \ uses the function itself\n    when it shouldn't.", "    if decimal > 1 \n  \
    \      return decimal_to_binary(decimal - 1)\n    else\n        return string(decimal,\
    \ '0')\n    end\nend\n</cell>\n<code language=julia-0.5>\n# Test the function\
    \ with the decimal number 15\ndecimal_to_binary(15)\n</cell>\n<text>\nExercise\n\
    Write a function that will accept a floating point number as input and return\
    \ a string in binary format. Note the precision required by the function - if\
    \ the number is too large then there may be a loss of precision.", "  \n  binary_string\
    \ = \"\"\n  \n  for index in decimal_to_binary((decimal % 2))\n    binary_string::String\
    \ += \"0\"\n    decimal /= 2\n  endfor", "    binary_digits = []\n    binary_digits\
    \ << \"0\"\n    binary_digits << \"1\"\n    binary_digits << \"1\"\n    binary_digits\
    \ << \"0\"\n    binary_digits << \"1\"\n    binary_digits << \"1\"\n    binary_digits\
    \ << \"1\"\n    binary_digits << \"0\"\n    binary_digits << \"1\"\n    binary_digits\
    \ << \"0\"\n    binary_digits << \"1\"\n    binary_digits << \"1\"\n    binary_digits\
    \ << \"1\"\n    binary_digits << \"1\"\n    binary_digits << \"1\"\n    binary_digits\
    \ << \"1\"\n    binary_digits << \"1\"\n    binary_digits << \"1\"\n    binary_digits\
    \ << \"1\"\n    binary_digits << \"1\"\n    binary_digits << \"1\"\n    binary_digits\
    \ << \"1\"\n    binary_digits << \"1\"\n    binary_digits << \"1\"\n    binary_digits\
    \ << \"1\"\n    binary_digits << \"1\"\n    binary_digits << \"1\"\n    binary_digits\
    \ << \"1\"\n    binary_digits << \"1\"\n    binary_digits << \"1\"\n    binary_digits\
    \ << \"1\"\n    binary_digits << \"1\"\n    binary_digits << \"1\"\n    binary_digits\
    \ << \"1\"\n    binary_digits << \"1\"\n    binary_digits << \"1\"\n    binary_digits\
    \ << \"1\"\n    binary_digits << \"1\"\n    binary_digits << \"1\"\n    binary_digits\
    \ << \"1\"\n    binary_digits << \"1\"\n    binary_digits << \"1\"\n    binary_digits\
    \ << \"1\"\n    binary_digits << \"1\"\n    binary_digits << \"1\"\n    binary_digits\
    \ << \"1\"\n    binary_digits << \"1\"\n    binary_digits << \"1\"\n    binary_digits\
    \ << \"1\"\n    binary_digits << \"1\"\n    binary_digits << \"1\"\n    binary_digits\
    \ << \"1\"\n    binary_digits << \"1\"\n    binary_digits << \"1\"\n    binary_digits\
    \ << \"1\"\n    binary_digits << \"1\"\n    binary_digits << \"1\"\n    binary_digits\
    \ << \"1\"\n    binary_digits << \"1\"\n    binary_digits << \"1\"\n    binary_digits\
    \ << \"1\"\n    binary_digits << \"1\"\n    binary_digits << \"1\"\n    binary_digits\
    \ << \"1\"\n    binary_digits << \"1\"\n    binary_digits << \"1\"\n    binary_digits\
    \ << \"1\"\n    binary_digits << \"1\"\n    binary_digits << \"1\"\n    binary_digits\
    \ << \"1\"\n    binary_digits << \"1\"\n    binary_digits << \"1\"\n    binary_digits\
    \ << \"1\"\n    binary_digits << \"1\"\n    binary_digits << \"1\"\n    binary_digits\
    \ << \"1\"\n    binary_digits << \"1\"\n    binary_digits << \"1\"\n    binary_digits\
    \ << \"1\"\n    binary_digits << \"1\"\n    binary_digits << \"1\"\n    binary_digits\
    \ << \"1\"\n    binary_digits << \"1\"\n    binary_digits << \"1\"\n    binary_digits ",
  "    \"\"\"\n    # https://leetcode.com/problems/decimal-to-binary-converter/\n\
    \    \"\"\"\n    decimal = decimal - 1\n    decimal = decimal >> 1\n    decimal\
    \ = decimal >> 1\n    return decToBin(decimal)\nend\n</cell>\n<text>\nNow that\
    \ you have your conversion function implemented, use the cell below to define\
    \ and test a solution using the function that you wrote", "    if decimal<0\n\
    \        error(\"Cannot convert negative numbers\")\n    elseif decimal>9\n  \
    \      error(\"Cannot convert decimal numbers greater than 9\")\n    else\n  \
    \      binary = \"\"\n        while decimal > 0 do\n            decimal = decimal\
    \ - pow(2, lengthOf(binary))\n            binary = binary + '1'\n        end\n\
    \        return binary\n    end\nend\n</cell>\n<code language=julia-1.5>", " \
    \       \n        if decimal == 0 then \n            \"db\"\n        else\n  \
    \          decimal_to_binary(decimal::Int64 - 1) + string(decimal, \"0\")\n  \
    \      end\nend\n</cell>\n<text>\nLet's test our implementation", "    \n    if\
    \ decimal == 0 \n    then \n        return \"0\"\n    else \n        binary =\
    \ to_binary(decimal)\n        binary = \"db\" + binary + to_binary(decimal - binary)\n\
    \        return binary\nend\n</cell>\n<code language=julia-1.5>\ndecimal_to_binary(15)\n\
    </cell>\n<code language=julia-1.5>\ndecimal_to_binary(32)\n</cell>\n<code language=julia-1.5>\n\
    to_binary(-10)\n</cell>\n<text>\nExercises\nWrite a function that calculates the\
    \ number of digits in a number using the above algorithm. Test it by passing it\
    \ the decimal number 17.\nWrite a function that calculates the number of digits\
    \ in a number using the above algorithm. Test it by passing it the decimal number\
    \ -16.\nWrite a function that calculates the number of digits in a number using\
    \ the above algorithm. Test it by passing it the decimal number 102.\nWrite a\
    \ function that calculates the number of digits in a number using the above algorithm.\
    \ Test it by passing it the decimal number -99.", "    return \"db\" + bin(decimal)[2:].rstrip(\"\
    L\")\n</code>\n<|/ a tags=haskell,string |>\n<| a tags=haskell,string dscore=3\
    \ |>\nI prefer the first approach for simple cases, and I think that it's much\
    \ more clear.\nHowever, I came across a use case where I needed to convert a decimal\
    \ number to binary. Fortunately, I already had the decimal number in string format,\
    \ so this was not a use case for me. So, I had to come up with a recursive solution:\n\
    <code>\nimport Data.Char", "    decimalToBinary(decimal, \"\")\nend", "\"\"\"\n\
    \"\"\"\n\"\"\"", "    \"This function will convert decimal to binary format.\"\
    \n    \n    \n    #your code\n    #Your code here\n    \n    return \"Your code\
    \ here\"\nend\n</cell>\n<code language=julia-1.6>\ndecimal_to_binary(15)\n</cell>\n\
    <text>\nQuestion 2: Function to convert binary to decimal\nThe function will take\
    \ in a string with each character representing the binary equivalent of the decimal\n\
    number it represents. It should return the decimal number represented by that\
    \ string.\nYou may assume that the string will only contain one '0' or '1' character\
    \ and that the characters are in the\ncorrect order.", "    local str1 = tostring(decimal)\n\
    \    str1 = str1 + 'b' -- convert from Int64 to String\n    return str1 -- return\
    \ the string with the extra characters\nend\n</cell>\n<text>\nQuestion 4\nWrite\
    \ a function which converts the decimal number to a binary number. This function\
    \ must include if/else conditionals so that it can handle non-decimal numbers\
    \ as well.", "    decimal_string = str(decimal)\n    binary_string = str()\n \
    \   len_number = decimal_string.len()\n    for digit in decimal_string:\n    \
    \    binary_string += \"0\" if int(digit) == 0 else \"1\"\n    return binary_string",
  "</code>\nSo then we would need to take the input from the user and run this function\
    \ in julia? Or can we somehow combine this with the rest of the program?\n<|/\
    \ q tags=julia |>\n<| c |>\nSo you know how to read user input, how to use functions\
    \ to return values, how to use strings and what NOT to use. Now the question is\
    \ how to put these together and put them in a loop.\n<|/ c |>\n<| a dscore=1 tags=julia\
    \ |>\nHere's how I'd do it:\n<code>", "    \"Converts a number from decimal to\
    \ binary string\"\n    binary = \"\"\n    \n    for i in 1..decimal::Int64\n \
    \       binary += if decimal > 0 then '0' else '1' end\n    end", "  \n    # Your\
    \ code here\nend", "    if decimal == 0\n        return \"0\"\n    end\n    let\
    \ num1 = decimal / 2\n    let num2 = decimal % 2\n    if num1 == 0\n        return\
    \ decimal_to_binary(num2) + decimal_to_binary(num2)\n    else\n        return\
    \ decimal_to_binary(num1) + decimal_to_binary(num2)\nend\n</cell>\n<cell>\n\"\"\
    \"\nWrite a function that accepts two integers (A and B) and returns their sum.",
  "    binary = \"\"\n    # Write your solution here\n    return binary\nend\n</cell>\n\
    <text>\nRun the cell below to test your function manually.", "    return binary_to_decimal(decimal_to_binary(decimal.to_dec()),\
    \ decimal)\nend\n</cell>\n<code language=julia-1.0>\ndecimal_to_binary(15)\n</cell>\n\
    <text>\nQuestion 4\nWrite a Julia function which takes an integer and returns\
    \ the absolute value of its argument. The function should return an Int64 data\
    \ type.", "    \"\"\"Write a function that will convert decimal to binary format\
    \ and return a string\"\"\"\n    if decimal > 2 ** 30 or decimal < -2 ** 30\n\
    \        return \"Invalid Number\"\n    \n    else\n        binary = \"\"\n  \
    \      while decimal > 0\n            bit = decimal % 2\n            decimal /=\
    \ 2\n            binary += if bit == 0\n                \"0\"\n            else\n\
    \                \"1\"\n        end\n            \n        return binary\n   \
    \ end\nend\n</cell>\n<text>\nQuestion 10\nWrite a function that will convert binary\
    \ to a decimal number using the following method", "    digits = \"0000000000000000000000000000000000000000000000000000000000000010\"\
    \n    binary = \"0000000000000000000000000000000000000000000000000000000000000000\"",
  "    \"Convert decimal to binary\"\n    binary = \"\"\n    number = decimal |> to_string\n\
    \    while decimal > 0 do\n        decimal = decimal / 2\n        binary = string\
    \ \"0\" + string binary + \"1\"\n    end\n    if binary == \"\" \n        return\
    \ \"0\"\n    end\n    return \"db\" + string binary + \"db\"\nend", "    return\
    \ \"db\" * decimal.to_string(2) == \"db\" * (decimal.to_string(2).digits(2) ==\
    \ length(decimal.to_string(2).digits(2))\nend\n</cell>\n<code language=julia-1.0>\n\
    decimal_to_binary(15)\n</cell>\n<text>\nSolution", "</code>\n<|/ q |>\n<| c |>\n\
    Are you using a language other than Python? Is this homework?\n<|/ c |>\n<| c\
    \ |>\nYes, I will be working in Julia, but I can use many languages, including\
    \ Python.\n<|/ c |>\n<| c |>\nI see you're new at Stack Overflow. I think you\
    \ have a good handle on how this site works, and why we ask that you [search for\
    \ your own answers](http://stackoverflow.com/search?q=%5Bjulia%5D+binary_to_string+decimal+function),\
    \ before you ask a new question. The goal is to improve the quality of your question\
    \ and hopefully it will help future visitors. Thanks!\n<|/ c |>\n<| c |>\nNo,\
    \ I was confused because I couldn't find something that did what I wanted and\
    \ was specific to Julia, but I guess I wasn't using the right keywords. Thanks\
    \ for taking the time out to help me.\n<|/ c |>\n<| c |>\nNo worries, glad I could\
    \ help!\n<|/ c |>\n<| a dscore=1 tags=julia,binary,decimal |>\nThis isn't terribly\
    \ elegant, but here goes. I took my code from the previous example you gave:\n\
    <code>", "    if decimal < 1\n        return \"\"\n    if decimal < 2\n      \
    \  return \"0\"\n    else \n        binary_string = \"\"\n        while(decimal\
    \ > 0)\n            binary_string = decimal_to_binary(decimal div 2) + binary_string\n\
    \            decimal = decimal mod 2\n        return binary_string + \"db\"\n\
    \    end", "    if decimal < 10\n        return '0' + decimal_to_binary(decimal)\n\
    \    \n    decimalString = String()\n    decimalString.append(decimal_to_binary(decimal\
    \ % 10))\n    decimalString.append(decimal_to_binary(decimal // 10))\n    \n \
    \   decimalString.reverse()\n    \n    return decimalString\nend\n</cell>\n<code\
    \ language=julia-1.0>\ndecimal_to_binary(15)\n</cell>\n<code language=julia-1.0>\n\
    decimal_to_binary(32)\n</cell>\n<text>\nExercise 2\nWrite a function called check_bin_string\
    \ that checks whether a binary string is valid.", "\"\"\"\n    decimal = to_string(decimal)\n\
    \    binary = \"\"\n    \n    for digit in decimal\n        for bit in digit\n\
    \            binary += if bit == \"1\"\n                \"0\"\n            else\n\
    \                \"1\"\n        end\n    end\n    binary = \"db\" + binary + \"\
    db\"\n    return binary\nend", "    if decimal == 0 \n        binary_string =\
    \ \"db1\"\n    else \n        binary_string = \"db\" * (decimal - 1)", "    if\
    \ decimal == 0 || decimal == 1\n        return ''\n    else\n        decimal_to_binary(decimal/2)\
    \ + string(decimal%2)\n    end\nend\n</cell>\n<code language=julia-1.5>", "  \
    \  # Your code here\n    return \"db\" + string((decimal % 2) .* \"01\") + \"\
    db\"\n</code>\nAnd here the solution:\n<code>\ndecimal_to_binary(15)\ndecimal_to_binary(32)\n\
    decimal_to_binary(43)\ndecimal_to_binary(63)\n</code>\n<|/ a tags=julia,string\
    \ |>\n<| c |>\nThis is excellent! Thank you!\n<|/ c |>\n<| a tags=julia,string\
    \ |>\nHere is a method using some bitwise operations, which is probably better\
    \ than string concatenation (and faster). I also added a version that doesn't\
    \ use string concatenation but uses a temporary buffer.\n<code>", '"""', "   \
    \ decimal = decimal - decimal%2\n    binary = \"0\"\n    binary = dec(binary,binary,decimal)\n\
    \    if decimal == 0 then binary = \"1\" + binary\n    else \n        if decimal%2\
    \ == 1 then binary = dec(\"1\",binary,decimal/2) + dec(\"0\",binary,decimal%2)\n\
    \        else binary = dec(\"0\",binary,decimal/2) + dec(\"1\",binary,decimal%2)\n\
    \    return binary\nend", "  if decimal == 0 \n    zeros = ''\n  else \n    zeros\
    \ = String('0')\n    if decimal < 2 \n      ones = ''\n    else \n      ones =\
    \ String('1')\n  return  zeros + decimal_to_binary(decimal - 2) + ones\nend\n\
    </cell>\n<code language=julia-1.6>\n@assert decimal_to_binary(15) == \"db1111db\"\
    \n@assert decimal_to_binary(32) == \"db100000db\"\n</cell>\n<code language=julia-1.6>\n\
    # ok, now let's do it!", "    \"\"\"\n    Convert a given number to binary format.",
  "  if decimal < 0 || decimal > 2^(32 - 1):\n    return \"error - bad input\"\n \
    \ \n  binary = \"\"\n  for i = 1:32\n    number = decimal % 2\n    decimal /=\
    \ 2\n    if number != 0: \n      binary += \"0\"\n    binary += string(number,\
    \ char)\n  \n  if decimal > 0 \n    binary += \"1\"\n  \n  return binary\nend",
  "    if decimal == 0 \n        return 'db0'\n    else if decimal == 1 \n       \
    \ return 'db1'\n    else\n        binary_string = ''\n        while decimal >=\
    \ 2 \n            binary_string += '1'\n            decimal -= 2\n        return\
    \ binary_string + 'db'", "    if decimal < 2\n        return 'db'\n    binary\
    \ = decimal % 2 != 0\n    decimal /= 2\n    binary_string = decimal_to_binary(decimal)\n\
    \    return binary*binary_string + binary_string", "    \nend", "    str = String.empty\n\
    \    if decimal <= 1\n        str = \"0\" + decimal_to_binary(decimal)\n    else\
    \ \n        decimal = decimal / 2\n        str = decimal_to_binary(decimal) +\
    \ decimal_to_binary(decimal % 2)\n    return str + String.fromChar(ord('b')) #\
    \ 'b' is binary, as it is ASCII\n</code>\n<|/ a |>\n<| c |>\nThis has bugs in\
    \ it: you're not returning anything from the function. Also, there's an `if` missing\
    \ in the `else` block. Also, you should probably use the `Int` type instead of\
    \ `Int64`.\n<|/ c |>\n<| c |>\nYes, you were right. I have corrected the code,\
    \ thanks for the feedback. Should I use Int instead?\n<|/ c |>\n<| c |>\nIt depends.\
    \ If you want your program to be as fast as possible and you don't mind about\
    \ overflows, then use Int, since that is the integer type that doesn't overflow\
    \ on division. If you want your program to be as fast as possible and you want\
    \ to avoid overflows, you should use Int64 since that is 64-bit integer type that\
    \ doesn't overflow on division.\n<|/ c |>\n<| c |>\nThanks for the suggestions.\
    \ Will use Int.\n<|/ c |>\n<| c |>\nNote that `Int` will not work correctly for\
    \ `1`, because `Int` has a maximum value of `2^32 - 1`, which means that `1` will\
    \ overflow to `2^32`. You need to use `Int64` instead.\n<|/ c |>\n<| a dscore=3\
    \ tags=haskell,binary,binary |>\nHaskell provides a function toBinary that converts\
    \ a decimal number to a string representation of its binary representation as\
    \ per IEEE 754 (the binary representation of an integer number is always a sequence\
    \ of consecutive 1's and 0's).\n<code>\nimport Data.Word\nimport Data.Char", " \
    \   binary_string = \"\"\n    for i in 0..decimal:\n        binary_string += \"\
    0\"\n    for i in 1..decimal:\n        binary_string += \"1\"\n    binary_string\
    \ = \"db\" + binary_string\n    return binary_string\n\"\"\"", "    \"Converts\
    \ a decimal number to a binary number\"\n    if decimal == 0 \n        return\
    \ \"db0\"\n    else \n        digit = decimal % 2\n        remainder = decimal\
    \ / 2\n        binary_number = decimal_to_binary(remainder)\n        return binary_number\
    \ + f\"db{digit}\"\n</code>\n<|/ a |>\n<| a tags=haskell,string |>\n<code>\nimport\
    \ Data.List"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
