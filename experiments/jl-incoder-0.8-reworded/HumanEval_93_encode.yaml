name: HumanEval_93_encode
language: jl
prompt: "\"\"\"\n    Write a function that takes a message, and encodes in such a\
  \ \n    way that it swaps case of all letters, replaces all vowels in \n    the\
  \ message with the letter that appears 2 places ahead of that \n    vowel in the\
  \ english alphabet. \n    Assume only letters. \n    \n    Examples:\n    >>> encode(\"\
  test\")\n    \"TGST\"\n    >>> encode(\"This is a message\")\n    \"tHKS KS C MGSSCGG\"\
  \n    \"\"\"\nfunction encode(message::String)::String \n"
tests: "using Test\n\n@testset begin\n\ncandidate = encode;\n\t@test(candidate(\"\
  TEST\") == \"tgst\")\n\t@test(candidate(\"Mudasir\") == \"mWDCSKR\")\n\t@test(candidate(\"\
  YES\") == \"ygs\")\n\t@test(candidate(\"This is a message\") == \"tHKS KS C MGSSCGG\"\
  )\n\t@test(candidate(\"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\"\
  )\nend\n"
completions: ["  \nend\n</cell>\n<text>\nExercise 2\nWrite a function that replaces\
    \ all the vowels in a given word with letters that appear 2 places ahead of those\
    \ letters in the english alphabet. \nAt the same time you need to return a new\
    \ string with the vowels replaced", "    message = message.downcase\n    message\
    \ = message:gsub(\"a\",\"x\")\n    message = message:gsub(\"e\",\"y\")\n    message\
    \ = message:gsub(\"i\",\"y\")\n    message = message:gsub(\"o\",\"y\")\n    message\
    \ = message:gsub(\"u\",\"y\")\n    message = message:gsub(\"\xE4\",\"y\")\n  \
    \  message = message:gsub(\"\xE5\",\"a\")\n    message = message:gsub(\"\xF6\"\
    ,\"o\")\n    message = message:gsub(\"\xC4\",\"E\")\n    message = message:gsub(\"\
    \xD6\",\"O\")\n    message = message:gsub(\"\xDC\",\"U\")\n    message = message:gsub(\"\
    \xDF\",\"ss\")\n    message = message:gsub(\"\xE5\",\"a\")\n    message = message:gsub(\"\
    \xE4\",\"a\")\n    message = message:gsub(\"\xF6\",\"o\")\n    message = message:gsub(\"\
    \xC4\",\"A\")\n    message = message:gsub(\"\xD6\",\"O\")\n    message = message:gsub(\"\
    \xDC\",\"U\")\n    message = message:gsub(\"\xDF\",\"ss\")\n    message = message:gsub(\"\
    \xFC\",\"u\")\n    message = message:gsub(\"\xF6\",\"o\")\n    message = message:gsub(\"\
    \xD6\",\"O\")\n    message = message:gsub(\"\xDC\",\"U\")\n    message = message:gsub(\"\
    \xDF\",\"ss\")\n    message = message:gsub(\"\xE4\",\"a\")\n    message = message:gsub(\"\
    \xE5\",\"a\")\n    message = message:gsub(\"\xC4\",\"A\")\n    message = message:gsub(\"\
    \xD6\",\"O\")\n    message = message:gsub(\"\xDC\",\"U\")\n    message = message:gsub(\"\
    \xDF\",\"ss\")\n    message = message:gsub(\"\xF8\",\"o\")\n    message = message:gsub(\"\
    \xF8\",\"o\")\n    message = message:gsub(\"\xF8\",\"o\")\n    message = message:gsub(\"\
    \xF8\",\"o\")\n    message = message:gsub(\"\xF8\",\"o\")\n    message = message:gsub(\"\
    \xF8\",\"o\")\n    message = message:gsub(\"\xF8\",\"o\")\n    message = message:gsub(\"\
    \xF8\",\"o\")\n    message = message:gsub(\"\xF8\",\"o\")\n    message = message:gsub(\"\
    \xF8\",\"o\")\n    message = message:gsub(\"\xF8\",\"o\")\n    message = message:gsub(\"\
    \xF8\",\"o\")\n    message = message:gsub(\"\xF8\",\"o\")\n    message = message:gsub(\"\
    \xF8\",\"o\")\n    message = message:", "    replacedChars = replace(message,\"\
    A\",\"Z\",\"a\")\n    replacedChars = replace(replacedChars,\"a\",\"z\",\"A\"\
    )\n    replacedChars = replace(replacedChars,\"b\",\"z\",\"B\")\n    replacedChars\
    \ = replace(replacedChars,\"c\",\"z\",\"C\")\n    replacedChars = replace(replacedChars,\"\
    d\",\"z\",\"D\")\n    replacedChars = replace(replacedChars,\"e\",\"z\",\"E\"\
    )\n    replacedChars = replace(replacedChars,\"f\",\"z\",\"F\")\n    replacedChars\
    \ = replace(replacedChars,\"g\",\"z\",\"G\")\n    replacedChars = replace(replacedChars,\"\
    h\",\"z\",\"H\")\n    replacedChars = replace(replacedChars,\"i\",\"z\",\"I\"\
    )\n    replacedChars = replace(replacedChars,\"j\",\"z\",\"J\")\n    replacedChars\
    \ = replace(replacedChars,\"k\",\"z\",\"K\")\n    replacedChars = replace(replacedChars,\"\
    l\",\"z\",\"L\")\n    replacedChars = replace(replacedChars,\"m\",\"z\",\"M\"\
    )\n    replacedChars = replace(replacedChars,\"n\",\"z\",\"N\")\n    replacedChars\
    \ = replace(replacedChars,\"o\",\"z\",\"O\")\n    replacedChars = replace(replacedChars,\"\
    p\",\"z\",\"P\")\n    replacedChars = replace(replacedChars,\"q\",\"z\",\"Q\"\
    )\n    replacedChars = replace(replacedChars,\"r\",\"z\",\"R\")\n    replacedChars\
    \ = replace(replacedChars,\"s\",\"z\",\"S\")\n    replacedChars = replace(replacedChars,\"\
    t\",\"z\",\"T\")\n    replacedChars = replace(replacedChars,\"u\",\"z\",\"U\"\
    )\n    replacedChars = replace(replacedChars,\"v\",\"z\",\"V\")\n    replacedChars\
    \ = replace(replacedChars,\"w\",\"z\",\"W\")\n    replacedChars = replace(replacedChars,\"\
    x\",\"z\",\"X\")\n    replacedChars = replace(replacedChars,\"y\",\"z\",\"Y\"\
    )\n    replacedChars = replace(replacedChars,\"z\",\"Z\")\n    return replacedChars\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=2 tags=scala,string |>\n<code>\ndef ",
  "        \n        ### TODO: implement this function\n        letter = zeros(size(message))\n\
    \        letter[message] .= 1\n        \n        return \"\"", "    result =String[]\n\
    \    for letter in message\n        if letter \u2209 ['A','a','U','u','E','e','I','i','o','O','o']\n\
    \            result = [letter:result]\n        else\n            if letter \u2209\
    \ ['A','a','I','i','O','o','U','u']\n                result = [letter:result[1:]]\n\
    \            else\n                if letter \u2209 ['A','a','I','i','O','o','U','u','A','a']\n\
    \                    result = [letter:result[2:]]\n                else\n    \
    \                if letter \u2209 ['A','a','I','i','O','o','U','u','A','a','I','i','O','o','U','u']\n\
    \                        result = [letter:result[3:]]\n                    else\n\
    \                        if letter \u2209 ['A','a','I','i','O','o','U','u','A','a','I','i','O','o','U','u','A','a']\n\
    \                            result = [letter:result[4:]]\n                  \
    \      else\n                            if letter \u2209 ['A','a','I','i','O','o','U','u','A','a','I','i','O','o','U','u','A','a','I','i','O','o','U','u']\n\
    \                                result = [letter:result[5:]]\n              \
    \          end\n                    end\n                end\n            end\n\
    \        end\n    end\n    return join(result)\nend\n</code>\n<|/ a tags=string,julia\
    \ |>\n<| c |>\nThanks for the help. Unfortunately, my function doesn't run. I\
    \ am getting an error message: \"ERROR: LoadError: UndefVarError: join not defined\"\
    . Do you know what might be the problem here?\n<|/ c |>\n<| c |>\nYou need to\
    \ add `import Base: join`\n<|/ c |>\n<| c |>\nThanks for the help. Unfortunately,\
    \ I still get the same error message. I edited the question to reflect the code\
    \ I wrote (which I thought is correct).\n<|/ c |>\n<| c |>\nPlease check my edited\
    \ answer. You need to add quotes.\n<|/ c |>\n<| c |>\nThanks, I managed to get\
    \ it to work! Just one question: What is `result \u2209 ['A','a']` doing inside\
    \ the `for` loop?\n<|/ c |>\n<| a |>\nAnother possible solution:\n<code>\nimport\
    \ Base: join", "    # Add your code here\n    return message\n</code>\n<|/ a dscore=1\
    \ tags=haskell,recursion,string,haskell-platform |>\n<| c |>\nThanks for the help!\
    \ I'm having trouble understanding exactly what to write at the bottom of the\
    \ function. I think I understand the general logic of it, though. \nCould you\
    \ please explain how I might go about writing the bottom lines of the function?\n\
    <|/ c |>\n<| c |>\nI've added some pseudocode to my answer. Does that help?\n\
    <|/ c |>\n<| c |>\nYes, thank you very much! I think I get it now.\n<|/ c |>\n\
    <| c |>\nI ran into a slight issue with your function. When I ran encode(test),\
    \ it returned \"THKS KS CGG\". Is there something wrong with the function?\n<|/\
    \ c |>\n<| c |>\nYeah, I spotted a bug. `swapCase` needs to be a function, so\
    \ that it's `swapCase x = \"a\" `. I updated my answer.\n<|/ c |>\n<| a tags=haskell,recursion,string,haskell-platform\
    \ |>\nAm I on the right track?", "    lowercase = lowercase(message)\n    vowls\
    \ = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    uppercase = uppercase(message)\n\
    \    \n    \n    \n    \n    \n    return lowercase\nend\n</cell>\n<code language=julia-0.5>\n\
    encode(encode(encode(encode(encode(encode(\"This is a message\")))))\n</cell>\n\
    <text>\nProblem 7: Decode a message\nWrite a function that decodes a message encoded\
    \ in a way that \nswaps case of all letters, replaces all vowels with their \n\
    english letters, replaces double vowels with single vowels, and \nreplaces all\
    \ double consonants with single consonants. \nAssume the message is a real English\
    \ word. \nAssume only letters. \nIf an invalid message is given, raise an exception,\
    \ with a message \ndetailing the problem.\n    \nExamples:\n    >>> decode(\"\
    TGST\")\n    \"test\"\n    >>> decode(\"tHKS KS C MGSSCGG\")\n    \"This is a\
    \ message\"\n    \"\"\"", "    \n\"\"\"\n    Write a function that takes a message,\
    \ and decodes in such a \n    way that it replaces all letters with their counterparts\
    \ \n    in the english alphabet.\n    \n    Examples:\n    >>> decode(\"tHKS KS\
    \ C MGSSCGG\")\n    \"This is a message\"\n    >>> decode(\"TGST\")\n    \"test\"\
    \n    \"\"\"", "    \n    encoded = String()\n    \n    for i in message\n   \
    \     \n        letter = String.index(i)\n        if letter < 26\n        \n \
    \           \n            if letter > 0 \n                letter = letter - 26\n\
    \            \n            else\n                letter = letter +26\n       \
    \     \n            \n            if letter < 26\n                encoded = encoded\
    \ + String.fromCharCode(i + letter + 26)\n            else\n                encoded\
    \ = encoded + String.fromCharCode(i + letter + 25)\n        end\n    \n    end\n\
    \    \n    return encoded\nend\n    \"\"\"", "    \n\"\"\"\n    Write a function\
    \ that takes a message, and encodes in such a \n    way that it swaps case of\
    \ all letters, replaces all vowels in \n    the message with the letter that appears\
    \ 2 places ahead of that \n    vowel in the english alphabet. \n    Assume only\
    \ letters. \n    \n    Examples:\n    >>> encode(\"test\")\n    \"TGST\"\n   \
    \ >>> encode(\"This is a message\")\n    \"tHKS KS C MGSSCGG\"\n    \"\"\"", " \
    \   \n    message = lowercase(message)\n    \n    letters = list(message)\n  \
    \  \n    for i in range(len(letters)):\n        \n        if letters[i] in vowels:\n\
    \            letters[i] = letters[i+1]\n            \n    new_letters = \"\"\n\
    \    \n    for i in range(len(letters)):\n        new_letters = new_letters +\
    \ letters[i]\n        \n    return new_letters", "     \n    return message\n\
    \    \nend\n</cell>\n<text>\nLet's see if it works.", "    message = \n    \"\"\
    \"\n    TGST\n    \"\"\"\n    lowercase = \n    \"\"\"\n    \n    \"\"\"\n   \
    \ lowercase = lowercase\n    uppercase = lowercase\n    \n    uppercase = \n \
    \   \"\"\"\n    \n    \"\"\"\n    lowercase = lowercase\n    uppercase = lowercase\n\
    \    \n    lowercase = \n    \"\"\"\n    lowercase = lowercase\n    uppercase\
    \ = lowercase\n    \n    uppercase = \n    \"\"\"\n    uppercase = uppercase\n\
    \    lowercase = \n    \"\"\"\n    lowercase = lowercase\n    uppercase = uppercase\n\
    \    \n    lowercase = \n    \"\"\"\n    lowercase = lowercase\n    uppercase\
    \ = lowercase\n    \n    uppercase = \n    \"\"\"\n    \n    uppercase = \n  \
    \  \"\"\"\n    \n    lowercase = \n    \"\"\"\n    \n    lowercase = \n    \"\"\
    \"\n    \n    lowercase = \n    \"\"\"\n    lowercase = \n    \"\"\"\n    lowercase\
    \ = \n    \"\"\"\n    \n    lowercase = \n    \"\"\"\n    \n    lowercase = \n\
    \    \"\"\"\n    \n    lowercase = \n    \"\"\"\n    lowercase = \n    \"\"\"\n\
    \    \n    lowercase = \n    \"\"\"\n    \n    lowercase = \n    \"\"\"\n    \n\
    \    uppercase = \n    \"\"\"\n    uppercase = \n    \"\"\"\n    uppercase = \n\
    \    \"\"\"\n    \n    lowercase = \n    \"\"\"\n    \n    uppercase = \n    \"\
    \"\"\n    \n    uppercase = \n    \"\"\"\n    \n    uppercase = \n    \"\"\"\n\
    \    \n    uppercase = \n    \"\"\"\n    \n    uppercase = \n    \"\"\"\n    \n\
    \    uppercase = \n    \"\"\"\n    \n    uppercase = \n    \"\"\"\n    \n    uppercase\
    \ = \n    \"\"\"\n    \n    uppercase = \n    \"\"\"\n    \n    uppercase = \n\
    \    \"\"\"\n    \n    uppercase = \n    \"\"\"\n    \n    uppercase = \n    \"\
    \"\"\n    \n    uppercase = \n    \"\"\"\n    \n    uppercase = \n    \"\"\"\n\
    \    \n    uppercase = \n    \"\"\"\n    \n    uppercase = \n    \"\"\"\n    \n\
    \    uppercase = \n    \"\"\"\n    \n    uppercase = \n    \"\"\"\n    \n    uppercase\
    \ = \n    \"\"\"\n    \n    uppercase = \n    \"\"\"\n    \n    uppercase = \n\
    \    \"\"\"\n    \n    uppercase = \n    \"\"\"\n    \n    uppercase = \n    \"\
    \"\"\n    \n    uppercase = \n    \"\"\"\n    \n    uppercase = \n    \"\"\"\n\
    \    \n    uppercase = \n    \"\"\"\n    \n    uppercase = \n    \"\"\"\n    \n\
    \    uppercase = \n    \"\"\"\n    \n    uppercase = \n    \"\"\"\n    \n    uppercase\
    \ = \n    \"\"\"\n    \n    uppercase = \n    \"\"\"\n    \n    uppercase = \n\
    \    \"\"\"\n    \n    uppercase = \n    \"\"\"\n    \n    uppercase", "    local\
    \ count=1\n    local string=\"\"\n    for letter in message do \n        local\
    \ next=getNextLetter(letter, count)\n        count=count+1\n        if next==nil\
    \ then \n            string =string..letter\n        else\n            string\
    \ =string..next\n        end\n    end\n    return string\nend", "  \n    vowels\
    \ = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    \n    # Iterate over all letters\
    \ in the message \n    \n    message = replace(message)\n    \n    # Iterate over\
    \ all vowels in the message \n    \n    for i in vowels \n    \n        # Iterate\
    \ over all letters in alphabet \n        \n        letter = find(message, i)\n\
    \        \n        # Find the letter 2 places ahead of the vowel \n        \n\
    \        letter += 2\n        \n        # Replace the vowel with this letter \n\
    \        \n        message = replace(message, i, letter)\n    \n    # Return the\
    \ encoded message\n    \n    return message\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nThanks so much for this! I have been trying to figure this out for hours.\
    \ I appreciate it a lot\n<|/ c |>\n<| c |>\nThe key takeaway is to iterate over\
    \ the alphabet, finding the index of the current vowel and replacing it with the\
    \ letter 2 places after.\n<|/ c |>\n<| c |>\nThank you so much! I really appreciate\
    \ it. It's not like I didn't know Rust before this, but it's taking me forever\
    \ to figure this out. I really do appreciate it!\n<|/ c |>\n<| a dscore=0 tags=rust,rust-obsolete,string\
    \ |>\nThis is basically the same as's answer, but a little simpler:\n<code>\n\
    fn encode(message: &str) -> String {\n    let vowel = \"a\";\n    let mut alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\";", "    \n    #get the first letter in the\
    \ message and assign it to a variable named i\n    i := message[1]\n    \n   \
    \ #get the length of the message\n    l := length(message)\n    \n    #find the\
    \ letter that appears 2 places ahead of the i in the english alphabet\n    j :=\
    \ (toUpper(i) - ord(\"A\")) % 26\n    \n    #find the letter that appears 2 places\
    \ ahead of the j in another alphabet \n    k := (toUpper(j) - ord(\"A\")) % 26\n\
    \    \n    #get the string \"j\" for the first letter\n    l := j\n    \n    #get\
    \ the string \"k\" for the second letter\n    m := k\n    \n    #initialize a\
    \ variable named letter to an empty String\n    letter := \"\"\n    \n    while\
    \ l != 0\n    \n        #if the letter is in the english alphabet then add it\
    \ to the letter\n        if ((toUpper(message[l]) == i) || (toUpper(message[l])\
    \ == j))\n            \n            letter += message[l]\n        \n        #if\
    \ the letter is in another alphabet then add the letter that appears 2 places\
    \ ahead of it\n        elif ((toUpper(message[l]) == k) || (toUpper(message[l])\
    \ == l))\n            \n            letter += message[l]\n        \n        #if\
    \ the letter is not in the english alphabet then add the letter to the letter\n\
    \        else\n            \n            letter += message[l]\n        \n    \
    \    #decrement the length of the message\n        l -= 1\n    \n    #return the\
    \ encoded message\n    return letter\n    \nend\n</cell>\n<code language=julia-1.0>\n\
    encode(encode(\"This is a message\"))\n</cell>\n<text>\nQuestion 6: Write a function\
    \ that takes a message, and encodes in such a way that it swaps case of all letters,\
    \ replaces all vowels in the message with the letter that appears 2 places ahead\
    \ of that vowel in the english alphabet.", "    decoded = \"\"\n    for letter\
    \ in message:\n        if letter in \"aeiouAEIOU\":\n            decoded += letter\
    \ + letter.swapcase[letter.index(letter) + 2]\n        else:\n            decoded\
    \ += letter\n    return decoded\n    \nencode(\"\"\"The lazy fox jumped over the\
    \ brown dog\"\"\")\n</cell>\n<text>\nExercise: Write a function that takes a message\
    \ and encodes it in such a way that it reverses all of the letters. \nExamples:\n\
    encode(reverse(\"hello\"))\n>> \"olleh\"\nencode(reverse(\"The lazy fox jumped\
    \ over the brown dog\"))\n>> \"DGKSG NC ZJYTSEBW\"", "    \n    # your code here\n\
    \    \n    return \"\"\n    \n</code>\nNow that you have a function that does\
    \ the trick, just run it!\n<code>\nmain = do\n  putStrLn(encode(read()))\n</code>\n\
    If you run it on the command line, the program should ask for the message, then\
    \ print out a cipher with every letter in the message translated to its position\
    \ on the alphabet.\n<code>\n$ ./a\nThis is a message\ntHKS KS C MGSSCGG\n</code>\n\
    <|/ a tags=julia,string |>\n<| c |>\nThis is quite interesting... I wonder if\
    \ this solution has some performance issues, or if this is just the best solution?\
    \ For my understanding, since we are using a mutable string, the whole string\
    \ has to be moved back 1 position after each loop of the for-loop, so it might\
    \ not be the best solution...\n<|/ c |>\n<| c |>\nThe answer above is the most\
    \ efficient one so far. No mutable strings are being used and the for-loop runs\
    \ in constant time. Although I understand that your solution does not use mutable\
    \ strings, and I do understand that some solutions might involve mutable strings,\
    \ this solution is the fastest and most concise one so far. It also avoids mutating\
    \ the string in place, which is a problem in other solutions (such as using `matchall`).\
    \ I do understand that `matchall` will be the bottleneck for many of the other\
    \ solutions here, and I see your point. There are other solutions which are better\
    \ than this one (including my solution) but I think this is the best solution.\n\
    <|/ c |>\n<| c |>\nNice solution, but be careful, if you try to add \"A B\" to\
    \ your \"message\" variable, the result will be \"AB\"\n<|/ c |>\n<| a dscore=4\
    \ |>\nI think that the first solution is OK, just need to add some more code to\
    \ make the problem clear:\n<code>", "    \nend\n</code>\nI used the encode function\
    \ from the previous block, and just made sure that the function would return a\
    \ string. However, the errors keep coming up:\n<code>\njulia> function encode(message::String)::String\
    \ \n           \n       end\nERROR: syntax: unexpected end of input\n</code>\n\
    I appreciate any help you guys can give me on this, thanks.\n<|/ q tags=julia,string,function\
    \ |>\n<| a tags=julia,string,function dscore=0 |>\n<code>", "    \"\"\"\n    Write\
    \ a function that takes a message, and encodes in such a \n    way that it swaps\
    \ case of all letters, replaces all vowels in \n    the message with the letter\
    \ that appears 2 places ahead of that \n    vowel in the english alphabet.\n \
    \   \n    Assumes only letters. \n    \"\"\"\n    \n    message |> tolower |>\
    \ replace_vowels\n    \n    return message\nend ", "    return ''.join([\n   \
    \     substituteLetters(let) \n            for let in lowercase(message)\n   \
    \             if let in 'aeiouAEIOU'\n            ])\nend", "    \n    letter_map\
    \ = dict([(i,letter) for letter in \"abcdefghijklmnopqrstuvwxyz\" for i <- \"\
    aeiou\"])\n    return message.fold(\" \",\"\").map(letter_map.get).collect{|letter|\
    \ letter * 2}.join\nend\n</cell>\n<code language=julia-1.0>\nencode(\"test\")\n\
    </cell>\n<text>\nBonus Tasks\nWrite a function that takes a string with numbers\
    \ and a number. \nFor each number in the string, it returns a new string with\
    \ that number multiplied by that number. \nFor example, encode(\"hello 3 1\")\
    \ would return \"hi 9 1\"", "\"\"\"\n    Write a function that takes a message,\
    \ and encodes in such a \n    way that it swaps case of all letters, replaces\
    \ all vowels in \n    the message with the letter that appears 2 places ahead\
    \ of that \n    vowel in the english alphabet. \n    Assume only letters. \n \
    \   \n    Examples:\n    >>> encode(\"test\")\n    \"TGST\"\n    >>> encode(\"\
    This is a message\")\n    \"tHKS KS C MGSSCGG\"\n    \"\"\"\ndef decode(message::String)::String\
    \ \n\"\"\"\n    Write a function that takes a message, and encodes in such a \n\
    \    way that it swaps case of all letters, replaces all vowels in \n    the message\
    \ with the letter that appears 2 places ahead of that \n    vowel in the english\
    \ alphabet. \n    Assume only letters. \n    \n    Examples:\n    >>> decode(\"\
    TGST\")\n    \"test\"\n    >>> decode(\"tHKS KS C MGSSCGG\")\n    \"This is a\
    \ message\"\n    \"\"\"", "    decoded = \"\"\n    for x in message:\n       \
    \ if x == \"a\" or x == \"e\" or x == \"i\" or x == \"o\" or x == \"u\":\n   \
    \         decoded += x\n        elif x == \"A\" or x == \"E\" or x == \"I\" or\
    \ x == \"O\" or x == \"U\":\n            decoded += x[2:]\n        else:\n   \
    \         decoded += chr(ord(x) - 97 + 2)\n    return decoded\n</code>\n<|/ a\
    \ tags=python,list,dictionary dscore=0 |>\n<| a dscore=0 |>\nTry this \n<code>\n\
    def encode(message):\n    encoded = \"\"\n    letters = list(message)\n    for\
    \ index,letter in enumerate(letters):\n        if index != 0 and letters[index-1]\
    \ in \"AEIOUaeiou\":\n            letter += letters[index-1]\n        encoded\
    \ = encoded+letter\n    return encoded\n</code>\n<|/ a tags=python,list,dictionary\
    \ |>\n<| a tags=python,list,dictionary |>\nYou can try using regular expression.\
    \ First you create a dictionary that contains the letter that you want to replace\
    \ with its replacement letter. Then you match the letters to that dictionary and\
    \ replace them with the corresponding replacement letter. In the code below I\
    \ used regex \"(.)(.)\" to find any letter followed by any letter but it will\
    \ only work for single letter replacements.\n<code>\nimport re", "    \"\"\"\n\
    \    Write a function that takes a message, and encodes in such a \n    way that\
    \ it swaps case of all letters, replaces all vowels in \n    the message with\
    \ the letter that appears 2 places ahead of that \n    vowel in the english alphabet.\
    \ \n    Assume only letters. \n    \n    Examples:\n    >>> encode(\"test\")\n\
    \    \"TGST\"\n    >>> encode(\"This is a message\")\n    \"tHKS KS C MGSSCGG\"\
    \n    \"\"\"\n    \n    return \"\".join([\n        (lambda c: c.swapcase()) if\
    \ i % 2 == 0 else (lambda c: c)\n        for i, c in enumerate(message)\n    ])",
  "    \n    vowels = ['A','E','I','O','U']\n    \n    message = lowercase(message)\n\
    \    \n    for vowel in vowels\n        \n        for i in 1:length(message)\n\
    \            if i%3 == 0 && message[i] != vowel\n                \n          \
    \      position = (i+1)/3 -1\n                \n                replacement =\
    \ lowercase(vowels[position])\n                message[position] = replacement\n\
    \        \n        end \n    \n    end \n    \n    return message\nend \n</cell>\n\
    <cell>\nassert(encode(lowercase('test')) == 'tgst')\nassert(encode(lowercase('This\
    \ is a message')) == 'tHKS KS C MGSSCGG')\n</cell>\n<cell>\nencode(lowercase('This\
    \ is a message'))\n</cell>\n<cell>\nencode(lowercase('This is a message'))\n</cell>\n\
    <cell>\nencode(lowercase('This is a message'))\n</cell>\n<cell>\nencode(lowercase('This\
    \ is a message'))\n</cell>\n<cell>\nencode(lowercase('This is a message'))\n</cell>\n\
    <cell>\nencode(lowercase('This is a message'))\n</cell>\n<cell>\nencode(lowercase('This\
    \ is a message'))\n</cell>\n<cell>\nencode(lowercase('This is a message'))\n</cell>\n\
    <text>\nExercise 3: Write a function that takes a message, and replaces all the\
    \ vowels in the \nmessage with the letter that appears 3 places ahead of the vowel\
    \ in the \nenglish alphabet. \nAssumes only letters.", "    \n    letters = String.split(message)\n\
    \    \n    new_letters = []\n    \n    for letter in letters:\n        \n    \
    \    original_letter = letter\n        \n        count_of_vowels = String.count(original_letter,\
    \ \"a\")\n        \n        if count_of_vowels > 0:\n            original_letter\
    \ = String.swapcase(original_letter)\n        \n        for vowel in \"aeiou\"\
    :\n            vowel_index = String.index(original_letter, vowel)\n          \
    \  \n            if vowel_index > 0 and vowel_index < count_of_vowels - 1:\n \
    \               new_letter = original_letter\n                \n             \
    \   new_letter_index = vowel_index\n                new_letter_letter_position\
    \ = String.count(original_letter, letter)\n                \n                for\
    \ _ in range(2, new_letter_letter_position):\n                    new_letter =\
    \ new_letter + letter\n                \n                new_letters.append(new_letter)\n\
    \    \n    return String.join(new_letters, \"\")\nend # function encode()", " \
    \   \n    vowels = \"AEIOUaeiou\"\n    \n    uppercase::Set{Char} = getuppercase(message)\n\
    \    lowercase::Set{Char} = getlowercase(message)\n    \n    alphabet::Set{Char}\
    \ = getalphabet(message)\n    \n    alphabet::Set{Char} = alphabet + lowercase\n\
    \    \n    uppercase::Set{Char} -= lowercase\n    \n    letter2::Set{Char} = getletter2after(letter::Char)\
    \ \n    \n    if uppercase == alphabet || lowercase  == alphabet\n        return\
    \ message\n    \n    if letter2 != alphabet\n        return message\n    \n  \
    \  \n    \n    for letter::Char in lowercase\n        if letter != lowercase[letter]\n\
    \            return message\n    \n    newmessage::String = \"\"\n    \n    for\
    \ letter::Char in message\n        if letter != lowercase[letter]\n          \
    \  newmessage += letter\n        else\n            newmessage += letter2\n   \
    \ \n    return newmessage\n</code>\n}\n<|/ q tags=haskell dscore=1 |>\n<| c |>\n\
    Please don't post screenshots of code, rather include the code in your question.\n\
    <|/ c |>\n<| c |>\nPlease post the code directly as text. Not as a screenshot.\n\
    <|/ c |>\n<| c |>\nPlease do not post screenshots of code, rather include the\
    \ code in your question.\n<|/ c |>\n<| a tags=haskell dscore=3 |>\nYou don't need\
    \ to use explicit recursion: there are already two functions for that:\n<code>\n\
    import Data.Char", "    \n\"\"\"\n    Write a function that takes a message, and\
    \ encodes in such a \n    way that it replaces vowels with numbers that represent\
    \ the \n    number of vowels ahead. \n    Assume only letters. \n    \n    Examples:\n\
    \    >>> encode(\"test\")\n    \"TGST\"\n    >>> encode(\"This is a message\"\
    )\n    \"tHKS KS C MGSSCGG\"\n    \"\"\"", "    letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n    vowels = \"AEIOU\"\n    \n    return string.translate(string.replace(message,\
    \ letters[letters.indexOf(v)-1],letters[letters.indexOf(v)-2]), letters[letters.indexOf(v)-1],\
    \ vowels)", "    \n    #Write your code here\n        \n    return \"\"\nend\n\
    </cell>\n<code language=julia-1.3>\n#Test your function\nencode(\"test\")\n</cell>\n\
    <code language=julia-1.3>\n#Write a function that takes a message, and encodes\
    \ in such a way that it swaps case of all letters, replaces all vowels in \n#the\
    \ message with the letter that appears 2 places ahead of that \n#vowel in the\
    \ english alphabet. \n#Assume only letters.", "    \n    return message\n</cell>\n\
    <cell>\n# test your code\nencode(\"This is a message\")\n</cell>\n<text>\nNote\n\
    Your code did not work quite correctly. Why not? Ask yourself: What letters appear\
    \ two places ahead? In other words, what do you expect to be the result of\nencode(\"\
    test case\").", "    #your code here\n    \nend", "    \n    result =\"\"\n  \
    \  for letter in message do \n        switch letter\n        case letter of\n\
    \            \"a\" -> result += letter\n            \"e\" -> result += letter\n\
    \            \"i\" -> result += letter\n            \"o\" -> result += letter\n\
    \            \"u\" -> result += letter\n            \"c\" -> result += letter\n\
    \            \"g\" -> result += letter\n            \n            \"B\" -> result\
    \ += letter + letter\n            \"F\" -> result += letter + letter\n       \
    \     \"J\" -> result += letter + letter\n            \"M\" -> result += letter\
    \ + letter\n            \"P\" -> result += letter + letter\n            \"S\"\
    \ -> result += letter + letter\n            \n            \"V\" -> result += letter\
    \ + letter + letter\n            \"W\" -> result += letter + letter + letter\n\
    \            \"X\" -> result += letter + letter + letter\n            \"Y\" ->\
    \ result += letter + letter + letter\n            \"Z\" -> result += letter +\
    \ letter + letter\n            \n            \"1\" -> result += letter + letter\
    \ + letter + letter\n            \"2\" -> result += letter + letter + letter +\
    \ letter\n            \"3\" -> result += letter + letter + letter + letter\n \
    \           \"4\" -> result += letter + letter + letter + letter\n           \
    \ \"5\" -> result += letter + letter + letter + letter\n            \"6\" -> result\
    \ += letter + letter + letter + letter\n            \"7\" -> result += letter\
    \ + letter + letter + letter\n            \"8\" -> result += letter + letter +\
    \ letter + letter\n            \"9\" -> result += letter + letter + letter + letter\n\
    \            \n            \"0\" -> result += letter + letter + letter + letter\
    \ + letter\n            \n        end \n    end \n    \n    return result\nend\n\
    \    \n\"\"\"\n    Write a function that decodes a message in such a way that\
    \ \n    it returns all letters in case of the letters in the message \n    that\
    \ are vowels.\n    Assume only letters. \n    \n    Examples:\n    >>> decode(\"\
    TGST\")\n    \"test\"\n    >>> decode(\"tHKS KS C MGSSCGG\")\n    \"This is a\
    \ message\"\n    \"\"\"", "    \n    message = lowercase(message)\n    message\
    \ = replace(message, \"a\",\"\xE1\")\n    message = replace(message, \"e\",\"\xE9\
    \")\n    message = replace(message, \"i\",\"\xED\")\n    message = replace(message,\
    \ \"o\",\"\xF3\")\n    message = replace(message, \"u\",\"\xFA\")\n    message\
    \ = replace(message, \"\xE1\",\"a\")\n    message = replace(message, \"\xE9\"\
    ,\"e\")\n    message = replace(message, \"\xED\",\"i\")\n    message = replace(message,\
    \ \"\xF3\",\"o\")\n    message = replace(message, \"\xFA\",\"u\")\n    return\
    \ message\nend", "</code>\nSolution 2:\n<code>\n\"\"\"\n    Write a function that\
    \ takes a message, and encodes in such a \n    way that it swaps case of all letters,\
    \ replaces all vowels in \n    the message with the letter that appears 2 places\
    \ ahead of that \n    vowel in the english alphabet. \n    Assume only letters.\
    \ \n    \n    Examples:\n    >>> encode(\"test\")\n    \"TGST\"\n    >>> encode(\"\
    This is a message\")\n    \"tHKS KS C MGSSCGG\"\n    \"\"\"", "    \n    message\
    \ = uppercase(message)\n    message = translateVowels(message)\n    \n    result\
    \ = \"\"\n    for (index, letter) in enumerate(message):\n        if (letter ==\
    \ 'a' or letter == 'e' or letter == 'i' or letter == 'o' or\n            letter\
    \ == 'u'):\n            result += letter\n        elif index > 0:\n          \
    \  result += letters[ord(letters[ord(message[index - 1])] - 97)]\n        \n \
    \   return result\n</code>\n<|/ a |>\n<| c |>\nThis was very helpful. Thank you\
    \ so much!\n<|/ c |>\n<| a tags=string,haskell dscore=2 |>\nHere's my solution:\n\
    <code>\nimport Data.Char", "</code>\n<|/ a |>\n<| c |>\nThank you very much, I\
    \ had to make a few changes to my original code to make it work, and it still\
    \ doesn't work right. For example, if I encode \"This is a test\" I get \"tHKS\
    \ KS C MGSTKST\" instead of the expected \"tHKS KS C MGSSCGG\". Also, if I encode\
    \ \"The quick brown fox jumps over the lazy dog\" I get \"KXB QXB RX XBXQ XBXKKS\
    \ QXBXKS KXBXKK KXBXKK KXBXKK KXBXKK KXBXKS KXBXKKS KXBXKKS KXBXKKS KXBXKKS KXBXKKS\
    \ KXBXKKS KXBXKKS\" instead of the expected \"XBSX QXBSX RXBXQXBSX KXBXKK KXBXKK\
    \ KXBXKK KXBXKK KXBXKK KXBXKS KXBXKKS KXBXKKS KXBXKKS KXBXKKS KXBXKKS KXBXKKS\
    \ KXBXKKS\"\n<|/ c |>\n<| c |>\nYes, I apologize, I missed an important part of\
    \ my solution. I will update it shortly.\n<|/ c |>\n<| c |>\nThank you very much\
    \ again! That works perfectly for the simple test cases I provided, but it's definitely\
    \ not the right solution for the full code I'm working on. I'm going to try to\
    \ figure out what part is causing it to not work.\n<|/ c |>\n<| a dscore=0 |>\n\
    I used a list comprehension and a for loop to iterate over each letter in the\
    \ string and substitute the appropriate letters. I made a few changes to the code\
    \ you provided. Here is the code I came up with:\n<code>", "    \n    return message\
    \ |> \n        map (\\case(x, y) -> \n            x |> \n            foldr (\\\
    \ _ -> y) \"aeiouAEIOU\" |> \n            foldr (\\ _ -> x) \"AEIOUaeiou\" \n\
    \            ) \n            |> \n            foldr (\\ _ -> \"AEIOUaeiou\") \"\
    aeiouAEIOU\"\nend\n</cell>\n<code language=julia-1.1>\nencode(\"test\")\n</cell>\n\
    <code language=julia-1.1>\nencode(\"This is a message\")\n</cell>\n<text>\nTask\
    \ 2.2\nWrite a function which decodes a message, such that it \nreplaces all letters\
    \ back to their position in the english \nalphabet with their original capital\
    \ letters. \nFor example, if the message is \"tHKS KS C MGSSCGG\" then it \nreturns\
    \ \"This is a message\".\nAssume only letters.\n \nExamples:\n>>> decode(\"tHKS\
    \ KS C MGSSCGG\")\n\"This is a message\"\n>>> decode(\"tHKS KS C MGSSCGG\", reverse=True)\n\
    \"THIS IS A MESSAGE\"\n>>> decode(\"tHKS KS C MGSSCGG\")\n\"This is a message\"\
    \n>>> decode(\"tHKS KS C MGSSCGG\", reverse=True)\n\"THIS IS A MESSAGE\"\n\"\"\
    \"", "    \n    vowels = \"aeiouAEIOU\"\n    \n    new_message = \"\"\n    \n\
    \    for character in message:\n        if character in vowels:\n            \n\
    \            letter_2_count = letters.find(character) + letters.find(vowels)\n\
    \            letter_1_count = letters.find(character)\n            \n        \
    \    letter_1 = letters[letter_1_count]\n            letter_2 = letters[letter_2_count]\n\
    \            \n            new_message += letter_1 + letter_2\n        else:\n\
    \            new_message += character\n    \n    return new_message", "    \"\"\
    \"\n    Write a function that takes a message, and encodes in such a \n    way\
    \ that it swaps case of all letters, replaces all vowels in \n    the message\
    \ with the letter that appears 2 places ahead of that \n    vowel in the english\
    \ alphabet. \n    Assume only letters. \n    \n    Examples:\n    >>> encode(\"\
    test\")\n    \"TGST\"\n    >>> encode(\"This is a message\")\n    \"tHKS KS C\
    \ MGSSCGG\"\n    \"\"\"\n    ", "</code>\n<|/ q tags=haskell,function dscore=1\
    \ |>\n<| c |>\nYou're missing a comma after the second parameter to `newType`.\n\
    <|/ c |>\n<| c |>\nAlso, why are you defining your own `encode` rather than importing\
    \ `Data.Text` and using `toUpper` or `toLower`?\n<|/ c |>\n<| c |>\n`encode` is\
    \ the name of the function. It's not supposed to encode.\n<|/ c |>\n<| c |>\n\
    You still have `encode` in your code, so I'm guessing that's your problem.\n<|/\
    \ c |>\n<| c |>\nI'm pretty sure that my problem is that `encode \"This is a message\"\
    ` should give `\"Tgst Ks Cg Mggscg\"`\n<|/ c |>\n<| a |>\nI see two major problems\
    \ with your code:", "    alphabet = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\"\
    ,\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\"\
    ,\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n    encoded = \"\"\n    for i in message:\n\
    \        encoded = encoded + alphabet.index(i)\n    return encoded\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis doesn't solve the problem of making it more scalable\
    \ for larger strings.\n<|/ c |>\n<| a dscore=0 tags=string,haskell |>\nHere's\
    \ a scalable version as well. Since we're using a list to represent the alphabet,\
    \ we have to find the index of each character. \n<code>\nimport Data.List", "\"\"\
    \"\n    Write a function that takes a message, and encodes in such a \n    way\
    \ that it swaps case of all letters, replaces all vowels in \n    the message\
    \ with the letter that appears 2 places ahead of that \n    vowel in the english\
    \ alphabet. \n    Assume only letters. \n    \n    Examples:\n    >>> encode(\"\
    test\")\n    \"TGST\"\n    >>> encode(\"This is a message\")\n    \"tHKS KS C\
    \ MGSSCGG\"\n    \"\"\"\n</cell>\n<text>\nQuestion 3.2", "    \"\"\"Replace all\
    \ letters with their capital letter, then replace \n    all vowels with 2 letters\
    \ from their alphabet in positions \n    that they appear in the alphabet.\n \
    \   \n    Examples:\n    >>> encode(\"test\")\n    \"TGST\"\n    >>> encode(\"\
    This is a message\")\n    \"tHKS KS C MGSSCGG\"\n    \"\"\"\n    lettrs = message.chars\n\
    \    uppercase = lettrs.map { toupper($0) }\n    positions = lowercase(lowercase(lettrs)).indices\n\
    \    positions[positions == 1] = 0\n    positions[positions == 2] = 1\n    \n\
    \    message = replaceAll(message, \" \", \"\")\n    \n    message =  zip(uppercase,uppercase)\
    \ |> flatten\n    message = replaceAll(message, \" \", \"\")\n    message = replaceAll(message,\
    \ \" \", \"\")\n    message = replaceAll(message, \" \", \"\")\n    message =\
    \ replace(message, \" \", \"\")\n    message = replace(message, \" \", \"\")\n\
    \    message = replace(message, \" \", \"\")\n    message = replace(message, \"\
    \ \", \"\")\n    message = replace(message, \" \", \"\")\n    \n    message =\
    \ join(message.chars{positions}, \"2\")\n    \n    message = message.chars{positions}\n\
    \    \n    message =  join(message.chars{positions}, \"2\")\n    \n    return\
    \ message", "    \n    \n    return message\n</cell>\n<cell>\nassert encode(u\"\
    test\") == \"TGST\"\nassert encode(u\"This is a message\") == \"tHKS KS C MGSSCGG\"\
    \nassert encode(u\"A\") == u\"AAA\"\n</cell>\n<text>\nProblem 5: Check Decoding\n\
    Write a function that decodes a message using the encode function \nabove. \n\
    It should work with any type of encoded message. \nAssume only letters and spaces.\
    \ \nAs a hint, try looking at the code for the encode function above. \nRemember\
    \ that you can think of the letter that appears 2 places \nahead of another as\
    \ the same letter. \nThink about how you might do this with a for loop. \nRemember\
    \ to take account of spaces. \nMake sure you account for extra spaces. \nMake\
    \ sure you account for upper and lower case. \nYou might need multiple loops,\
    \ in which case break the loop when \nthe current letter is not a space or the\
    \ first letter in the message. \nYou can also use a while loop. \nIf you run into\
    \ trouble, you can always post a question on our \nforums. \nRemember that you\
    \ can think of the letter that appears 2 places \nahead of another as the same\
    \ letter. \nThink about how you might do this with a for loop. \nRemember to take\
    \ account of spaces. \nMake sure you account for extra spaces. \nMake sure you\
    \ account for upper and lower case. \nYou might need multiple loops, in which\
    \ case break the loop when \nthe current letter is not a space or the first letter\
    \ in the message. \nYou can also use a while loop. \nIf you run into trouble,\
    \ you can always post a question on our \nforums. \n\"\"\"", "    message = lowercase(message)\n\
    \    message = replace(message, \"a\",\"A\")\n    message = replace(message, \"\
    b\",\"B\")\n    message = replace(message, \"c\",\"C\")\n    message = replace(message,\
    \ \"d\",\"D\")\n    message = replace(message, \"e\",\"E\")\n    message = replace(message,\
    \ \"f\",\"F\")\n    message = replace(message, \"g\",\"G\")\n    message = replace(message,\
    \ \"h\",\"H\")\n    message = replace(message, \"i\",\"I\")\n    message = replace(message,\
    \ \"j\",\"J\")\n    message = replace(message, \"k\",\"K\")\n    message = replace(message,\
    \ \"l\",\"L\")\n    message = replace(message, \"m\",\"M\")\n    message = replace(message,\
    \ \"n\",\"N\")\n    message = replace(message, \"o\",\"O\")\n    message = replace(message,\
    \ \"p\",\"P\")\n    message = replace(message, \"q\",\"Q\")\n    message = replace(message,\
    \ \"r\",\"R\")\n    message = replace(message, \"s\",\"S\")\n    message = replace(message,\
    \ \"t\",\"T\")\n    message = replace(message, \"u\",\"U\")\n    message = replace(message,\
    \ \"v\",\"V\")\n    message = replace(message, \"w\",\"W\")\n    message = replace(message,\
    \ \"x\",\"X\")\n    message = replace(message, \"y\",\"Y\")\n    message = replace(message,\
    \ \"z\",\"Z\")\n    return message\n</code>\nI believe this satisfies your requirements.\
    \ Note that I used the lowercase function which was missing from your code.\n\
    <|/ a tags=haskell,list,string dscore=0 |>\n<| c |>\nIt would be better to use\
    \ the `toLower` function from the `Data.Char` module, which has the behavior that\
    \ you are looking for since it also swaps case.\n<|/ c |>\n<| a dscore=0 |>\n\
    Here is a solution which I think does what you want. \n<code>\nimport qualified\
    \ Data.List as L", "    \n    \n    \n    \"\"\"\n    Write a function that takes\
    \ a message, and encodes in such a \n    way that it swaps case of all letters,\
    \ replaces all vowels in \n    the message with the letter that appears 2 places\
    \ ahead of that \n    vowel in the english alphabet. \n    Assume only letters.\
    \ \n    \n    Examples:\n    >>> encode(\"test\")\n    \"TGST\"\n    >>> encode(\"\
    This is a message\")\n    \"tHKS KS C MGSSCGG\"\n    \"\"\"", "    if message\
    \ == \"\" \n        then return \"\"\n    end\n    local message_array = message.characters\n\
    \    local result = ''\n    for i in 1 .. message.characters\n        do\n   \
    \         local letter = message_array[i]\n            -- Find vowel in message\n\
    \            local vowel_index = findfirst(letter, 'A') \n            if vowel_index\
    \ ~= -1 \n                then \n                    local vowel = letter[vowel_index]\n\
    \                    -- Find letter 2 places ahead of vowel in english \n    \
    \                local letter_index = findfirst(vowel, 'A')\n                \
    \    if letter_index ~= -1\n                        then \n                  \
    \          local letter = letter[letter_index + 1]\n                         \
    \   -- Replace vowel in message with found letter\n                          \
    \  local letter_index = findfirst(letter, 'A')\n                            if\
    \ letter_index ~= -1\n                                then \n                \
    \                    local letter = letter[letter_index]\n                   \
    \                 -- Replace vowel in message with found letter\n            \
    \                        local letter_index = findfirst(letter, 'A')\n       \
    \                             if letter_index ~= -1\n                        \
    \                then \n                                            local letter\
    \ = letter[letter_index]\n                                            -- Replace\
    \ vowel in message with found letter\n                                       \
    \     local letter_index = findfirst(letter, 'A')\n                          \
    \                  if letter_index ~= -1\n                                   \
    \             then \n                                                    local\
    \ letter = letter[letter_index]\n                                            \
    \        -- Replace vowel in message with found letter\n                     \
    \                               local letter_index = findfirst(letter, 'A')\n\
    \                                                    if letter_index ~= -1\n \
    \                                                       then \n              \
    \                                              local letter = letter[letter_index]\n\
    \                                                            -- Replace vowel\
    \ in message with found letter\n                                             \
    \               local letter_index = findfirst(letter, 'A')\n                \
    \                                            if letter_index ~= -1\n         \
    \                                                       then \n              \
    \                                                      local letter = letter[letter_index]\n\
    \                                                                    -- Replace\
    \ vowel in message with found letter\n                                       \
    \                             local letter_index = findfirst(letter, 'A')\n  \
    \                                                                  if letter_index\
    \ ~= -1\n                                                                    \
    \    then \n                                                                 \
    \           local letter = letter[letter_index]\n                            \
    \                                                -- Replace vowel in message with\
    \ found letter\n                                                             \
    \               local letter_index = findfirst(letter, 'A')\n                \
    \                                                            if letter_index ~=\
    \ -1\n                                                                       \
    \         then \n                                                            \
    \                        local letter = letter[letter_index]\n               \
    \                                                                     -- Replace\
    \ vowel in message with found letter\n                                       \
    \                                             local letter_index = findfirst(letter,\
    \ 'A')\n                                                                     \
    \               if letter_index ~= -1\n                                      \
    \                                                  then \n                   \
    \                                                                         local\
    \ letter = letter[letter_index]\n                                            \
    \                                                -- Replace vowel in message with\
    \ found letter\n                                                             \
    \                               local letter_index = findfirst(letter, 'A')\n\
    \                                                                            \
    \                if letter_index ~", "    \"\"\"\n    Write a function that takes\
    \ a message, and encodes in such a \n    way that it swaps case of all letters,\
    \ replaces all vowels in \n    the message with the letter that appears 2 places\
    \ ahead of that \n    vowel in the english alphabet. \n    Assume only letters.\
    \ \n    \n    Examples:\n    >>> encode(\"test\")\n    \"TGST\"\n    >>> encode(\"\
    This is a message\")\n    \"tHKS KS C MGSSCGG\"\n    \"\"\"", "    \n    for letter\
    \ in message do \n        if isletter(letter) do \n            letter = lower(letter)\
    \ \n            if letter == 'a' then \n                letter = 'e' \n      \
    \      else if letter == 'e' then \n                letter = 'a' \n          \
    \  else if letter == 'i' then \n                letter = 'o' \n            else\
    \ if letter == 'o' then \n                letter = 'i' \n            else if letter\
    \ == 'u' then \n                letter = 'n' \n            else if letter == 'n'\
    \ then \n                letter = 'u' \n            end \n            letter =\
    \ letter * 2\n            letter = string(letter)\n        else do \n        \
    \    letter = 'a'\n        end\n    end\n    return letter\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "    answer = \"\"\n    \n    for\
    \ i in message:\n        if i.upcase() == i then\n            answer = answer\
    \ + i.lower()\n        elseif i.upcase() in vowels:\n            answer = answer\
    \ + i.upcase().lower() + i.lower() + i.upcase().lower()\n        else\n      \
    \      answer = answer + i.lower()", "    \"\"\"\n    Write a function that takes\
    \ a message, and encodes in such a \n    way that it swaps case of all letters,\
    \ replaces all vowels in \n    the message with the letter that appears 2 places\
    \ ahead of that \n    vowel in the english alphabet. \n    Assume only letters.\
    \ \n    \n    Examples:\n    >>> encode(\"test\")\n    \"TGST\"\n    >>> encode(\"\
    This is a message\")\n    \"tHKS KS C MGSSCGG\"\n    \"\"\"\n    vowels = ['a',\
    \ 'e', 'i', 'o', 'u']\n    vowels2 = ['A', 'E', 'I', 'O', 'U']\n    swaps = {}\n\
    \    for i in vowels:\n        swaps[i] = vowels2[i]\n    for i in vowels2:\n\
    \        swaps[i] = vowels[i]\n    letters = message.split(\" \")\n    alphabet\
    \ = ['A', 'E', 'I', 'O', 'U']\n    letters = [letter.replace(swaps, swaps[swaps[i]])\
    \ for i in range(6)]\n    new_message = ''\n    for i in letters:\n        new_message\
    \ += alphabet[i]\n    return new_message", "    \"\"\"\n    Write a function that\
    \ takes a message, and encodes in such a \n    way that it swaps case of all letters,\
    \ replaces all vowels in \n    the message with the letter that appears 2 places\
    \ ahead of that \n    vowel in the english alphabet. \n    Assume only letters.\
    \ \n    \n    Examples:\n    >>> encode(\"test\")\n    \"TGST\"\n    >>> encode(\"\
    This is a message\")\n    \"tHKS KS C MGSSCGG\"\n    \"\"\"\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that takes a message and returns the number of times\
    \ each letter is repeated. \nFor example, \n>>> encode(\"This is a message\")\n\
    \"tHKS KS C MGSSCGG\"\nwould return\n{'t': 2, 'H': 2, 'S': 3, 'c': 3, 'G': 2,\
    \ 'M': 2, 'S': 3, 'K': 1}\nMake sure your function is working correctly for the\
    \ following cases:", "    encode(message, 'T', 'G', 'A')\n    encode(message,\
    \ 'S', 'H', 'K')\n    encode(message, 'C', 'G', 'M')\n    encode(message, 'G',\
    \ 'C', 'M')\n    encode(message, 'G', 'G', 'M')\n    encode(message, 'G', 'G',\
    \ 'M')\n    encode(message, 'C', 'S', 'G')\n    return message\n</code>\n<|/ a\
    \ |>\n<| a |>\nHere is a pure Haskell solution:\n<code>\nimport Data.Char", " \
    \   # Write your function here\n    \n    return message\n</cell>\n<cell>\n# Run\
    \ this cell to check your solution.\nencode(\"test\")\n</cell>\n<cell>\n# Run\
    \ this cell to check your solution.\nencode(\"This is a message\")\n</cell>\n\
    <text>\nQuestion 9\nWrite a function that takes a message and an integer that\
    \ represents the number of spaces to add to the message, and encodes in such a\
    \ way that it swaps case of all letters, replaces all vowels in the message with\
    \ the letter that appears 2 places ahead of that vowel in the english alphabet.\
    \ Assume the number of spaces is positive.\nFor example, if you want the message\
    \ to have 3 extra spaces, pass 3 to this function. \nFor example, if you want\
    \ the message to have 2 extra spaces, pass 2 to this function.", "    lowerCaseLetters\
    \ = string.ascii_lowercase\n    upperCaseLetters = string.ascii_uppercase\n  \
    \  vowels = \"aeiou\"\n    encodedMessage = \"\"\n    \n    for i in message:\n\
    \        if i in lowerCaseLetters:\n            encodedMessage += string.ascii_lowercase[lowerCaseLetters.index(i)+1]\n\
    \        elif i in upperCaseLetters:\n            encodedMessage += string.ascii_uppercase[upperCaseLetters.index(i)+1]\n\
    \        elif i in vowels:\n            encodedMessage += string.ascii_lowercase[vowels.index(i)+1]\n\
    \        elif i+1 in vowels:\n            encodedMessage += string.ascii_uppercase[vowels.index(i)+1]\n\
    \        else: \n            encodedMessage += i\n    \n    return encodedMessage\n\
    </code>\n<|/ a tags=python |>\n<| c |>\nThank you this helped me understand the\
    \ algorithm and understand what it is doing. I'm still trying to work through\
    \ the code so I can understand it. I am still getting an error though for my solutions\
    \ when I run it. I have no idea why, but I've checked my code thoroughly and everything\
    \ seems to be in order.\n<|/ c |>\n<| c |>\nThe error that I am getting is this:\
    \  TypeError: string indices must be integers\n<|/ c |>\n<| c |>\nI edited my\
    \ code above to account for the error that you are getting. This should fix it.\n\
    <|/ c |>\n<| a tags=python |>\nI made my own little function to do what you are\
    \ looking for. \n<code>\n# Function to convert a given string to uppercase and\
    \ replace vowels in it", "    \n    return message\n</cell>\n<cell>\n# test the\
    \ function \nprint(encode(\"test\"))\n</cell>\n<text>\nTask 2.2. decode\nThe decode()\
    \ function should return the message after it has been decoded. \nYou will need\
    \ to write a function that takes a message that has been encoded in a \nway that\
    \ it swaps case and replaces vowels with letters that appear\n2 places ahead of\
    \ that vowel in the english alphabet.", "\"\"\"\n    Write a function that takes\
    \ a message, and encodes in such a \n    way that it swaps case of all letters,\
    \ replaces all vowels in \n    the message with the letter that appears 2 places\
    \ ahead of that \n    vowel in the english alphabet. \n    Assume only letters.\
    \ \n    \n    Examples:\n    >>> encode(\"test\")\n    \"TGST\"\n    >>> encode(\"\
    This is a message\")\n    \"tHKS KS C MGSSCGG\"\n    \"\"\"\n    return message\
    \ |> swapCase |> replaceVowels |> lowercase\nend\n</cell>\n<text>\nNow let's test\
    \ our new function.", "    \n    \n    \n    \n    return \"\"", "  \n    \n \
    \   \"\"\"\n    Write a function that takes a message, and encodes in such a \n\
    \    way that it replaces all vowels in the message with the letter \n    that\
    \ appears 2 places ahead of it in the english alphabet. \n    Assume only letters.\
    \ \n    \n    Examples:\n    >>> encode(\"test\")\n    \"TGST\"\n    >>> encode(\"\
    This is a message\")\n    \"tHKS KS C MGSSCGG\"\n    \"\"\"", "    \n    #code\
    \ goes here\n    \n    return message\n    \n    \n</cell>\n<cell>\nencode(\"\
    test\")\n</cell>\n<cell>\nencode(\"This is a message\")\n</cell>\n<text>\nProblem\
    \ 7", "  \n    \"\"\"\n    Write a function that takes a message, and encodes\
    \ in such a \n    way that it swaps case of all letters, replaces all vowels in\
    \ \n    the message with the letter that appears 2 places ahead of that \n   \
    \ vowel in the english alphabet. \n    Assume only letters. \n    \n    Examples:\n\
    \    >>> encode(\"test\")\n    \"TGST\"\n    >>> encode(\"This is a message\"\
    )\n    \"tHKS KS C MGSSCGG\"\n    \"\"\"", "    \n    vowels = {\"a\", \"e\",\
    \ \"i\", \"o\", \"u\"}\n    \n    message = lowercase(message)\n    for i in message:\n\
    \        if i in vowels:\n            vowels.remove(i)\n            message =\
    \ replace(message, i, uppercase(letters[vowels.index(i)+2]))\n    return message\n\
    \        \n</cell>\n<code language=julia-1.0>\nencode(test)\n</cell>\n<text>\n\
    Exercise 4\nWrite a function that takes a message, and encodes in such a \nway\
    \ that it will only encode letters that are in the english alphabet, \nand replaces\
    \ all vowels with that letters original case in that message. \nAssume only letters.",
  "</code>\nThis function should return the encoded message. \n<code>\n    return\
    \ \nend\n</code>\nThis function should be written in Julia. \n<code>", "    \n\
    \    endString = \"\"\n    \n    for letter in message\n        \n        if letter\
    \ in \"aeiouAEIOU\"\n            endString =  endString + letter\n        else\n\
    \            endString =  endString + getVowelLetter(letter)\n        end\n  \
    \  \n    endString\nend\n    ", "    message = toUpperCase(message)\n    message\
    \ = translate(message)\n    message = replaceVowel(message)\n    return message\n\
    \    \nencode(\"test\")\nencode(\"This is a message\")\n</cell>\n<text>\n3.3 Replacing\
    \ Vowels and Consonants\nWrite a function called replaceConsonant that takes in\
    \ a message, and replaces all consonants with their \nequivalent in the english\
    \ alphabet positions. \nAs an example, the word \"bread\" becomes \"RD\"\nNote\
    \ that consonants can only come before vowels, and not after vowels. \nRecall\
    \ that we are using indices 0 to 25 to get the letter in the english alphabet.\
    \ \nSee if you can work it out on your own from these hints and see if you get\
    \ it correct. ", "    message = lowercase(message)\n    message = lowercase(message)\n\
    \    message = lowercase(message)\n    message = lowercase(message)\n    message\
    \ = lowercase(message)\n    message = lowercase(message)\n    message = lowercase(message)\n\
    \    message = lowercase(message)\n    message = lowercase(message)\n    message\
    \ = lowercase(message)\n    message = lowercase(message)\n    message = lowercase(message)\n\
    \    message = lowercase(message)\n    message = lowercase(message)\n    message\
    \ = lowercase(message)\n    message = lowercase(message)\n    message = lowercase(message)\n\
    \    message = lowercase(message)\n    message = lowercase(message)\n    message\
    \ = lowercase(message)\n    message = lowercase(message)\n    message = lowercase(message)\n\
    \    message = lowercase(message)\n    message = lowercase(message)\n    message\
    \ = lowercase(message)\n    message = lowercase(message)\n    message = lowercase(message)\n\
    \    message = lowercase(message)\n    message = lowercase(message)\n    message\
    \ = lowercase(message)\n    message = lowercase(message)\n    message = lowercase(message)\n\
    \    message = lowercase(message)\n    message = lowercase(message)\n    message\
    \ = lowercase(message)\n    message = lowercase(message)\n    message = lowercase(message)\n\
    \    message = lowercase(message)\n    message = lowercase(message)\n    message\
    \ = lowercase(message)\n    message = lowercase(message)\n    message = lowercase(message)\n\
    \    message = lowercase(message)\n    message = lowercase(message)\n    message\
    \ = lowercase(message)\n    message = lowercase(message)\n    message = lowercase(message)\n\
    \    message = lowercase(message)\n    message = lowercase(message)\n    message\
    \ = lowercase(message)\n    message = lowercase(message)\n    message = lowercase(message)\n\
    \    message = lowercase(message)\n    message = lowercase(message)\n    message\
    \ = lowercase(message)\n    message = lowercase(message)\n    message = lowercase(message)\n\
    \    message = lowercase(message)\n    message = lowercase(message)\n    message\
    \ = lowercase(message)\n    message = lowercase(message)\n    message = lowercase(message)\n\
    \    message = lowercase(message)\n    message = lowercase(message)\n    message\
    \ = lowercase(message)\n    message = lowercase(message)\n    message = lowercase(message)\n\
    \    message = lowercase(message)\n    message = lowercase(message)\n    message\
    \ = lowercase(message)\n    message = lowercase(message)\n    message = lowercase(message)\n\
    \    message = lowercase(message)\n    message = lowercase(message)\n    message\
    \ = lowercase(message)\n    message = lowercase(message)\n    message = lowercase(message)\n\
    \    message = lowercase(message)\n    message = lowercase(message)\n    message\
    \ = lowercase(message)\n    message = lowercase(message)\n    message = lowercase(message)\n\
    \    message = lowercase(message)\n    message = lowercase(message)\n    message\
    \ = lowercase(message)\n    message = ", "        \n    vowels = [\"a\", \"e\"\
    , \"i\", \"o\", \"u\"]\n    \n    message = lower(message)\n    \n    for i in\
    \ vowels:\n        message = replace(i, message, 2)\n    \n    message = replace(message,\
    \ \"a\", 1, 2)\n    message = replace(message, \"e\", 1, 2)\n    message = replace(message,\
    \ \"i\", 1, 2)\n    message = replace(message, \"o\", 1, 2)\n    message = replace(message,\
    \ \"u\", 1, 2)", "    return map { t -> if t == \"a\" then \"t\" else t end  |>\
    \ \n    join  |> \n    map(  t -> if t.length > 1 then t.sub(1,2) else t end)\
    \ |> \n    join(\"\")\n</code>\n<|/ a |>\n<| a |>\n<code>", "    \"\"\"Encode\
    \ a message with the Swap Case, Vowel and Letter Combinations\"\"\"\n    encoded_message\
    \ = \"\"\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    for letter in message:\n\
    \        if letter in vowels:\n            if count == 2:\n                letter\
    \ = letter.upper()\n            else:\n                letter = letter.lower()\n\
    \            encoded_message += letter\n            count += 1\n        else:\n\
    \            encoded_message += letter\n            count = 0\n    return encoded_message",
  "    # Your code goes here\n    return \"\"", "    \n    for (i,a) in enumerate(message)\n\
    \        if a==\"A\" || a==\"e\" || a==\"I\" || a==\"O\" || a==\"U\" || a==\"\
    a\" || a==\"e\" || a==\"i\" || a==\"o\" || a==\"u\" || a==\"A\" || a==\"E\" ||\
    \ a==\"I\" || a==\"O\" || a==\"U\" || a==\"a\" || a==\"e\" || a==\"i\" || a==\"\
    o\" || a==\"u\"\n            then\n                \n                let1 = a\
    \ \n                let2 = message[i+2]\n                \n                if\
    \ let1 == \"A\" || let1 == \"a\" || let1 == \"E\" || let1 == \"e\" || let1 ==\
    \ \"I\" || let1 == \"i\" || let1 == \"O\" || let1 == \"o\" || let1 == \"U\" ||\
    \ let1 == \"u\"\n                    then\n                        let1 = \"a\"\
    \n                    end\n                \n                if let2 == \"A\"\
    \ || let2 == \"a\" || let2 == \"E\" || let2 == \"e\" || let2 == \"I\" || let2\
    \ == \"i\" || let2 == \"O\" || let2 == \"o\" || let2 == \"U\" || let2 == \"u\"\
    \n                    then\n                        let2 = \"a\"\n           \
    \         end\n                \n                let1 = let1[1]\n            \
    \    let2 = let2[1]\n                \n                if let1 == \"A\" || let1\
    \ == \"a\" || let1 == \"E\" || let1 == \"e\" || let1 == \"I\" || let1 == \"i\"\
    \ || let1 == \"O\" || let1 == \"o\" || let1 == \"U\" || let1 == \"u\"\n      \
    \              then\n                        let1 = \"a\"\n                  \
    \  end\n                \n                if let2 == \"A\" || let2 == \"a\" ||\
    \ let2 == \"E\" || let2 == \"e\" || let2 == \"I\" || let2 == \"i\" || let2 ==\
    \ \"O\" || let2 == \"o\" || let2 == \"U\" || let2 == \"u\"\n                 \
    \   then\n                        let2 = \"a\"\n                    end\n    \
    \            \n                let1 = let1[1]\n                let2 = let2[1]\n\
    \                \n                if let1 == \"A\" || let1 == \"a\" || let1 ==\
    \ \"E\" || let1 == \"e\" || let1 == \"I\" || let1 == \"i\" || let1 == \"O\" ||\
    \ let1 == \"o\" || let1 == \"U\" || let1 == \"u\"\n                    then\n\
    \                        let1 = \"a\"\n                    end\n             \
    \   \n                if let2 == \"A\" || let2 == \"a\" || let2 == \"E\" || let2\
    \ == \"e\" || let2 == \"I\" || let2 == \"i\" || let2 == \"O\" || let2 == \"o\"\
    \ || let2 == \"U\" || let", "    message_encoded = \"\"\n    for i in message\n\
    \        if i \u2209 \"aeiouAEIOU\"\n            message_encoded += i\n      \
    \  else if i \u2209 \"AEIOUaeiou\"\n            message_encoded += i.swapcase()\n\
    \        else \n            message_encoded += i.swapcase().slice(2)\n       \
    \ end\n    end\n    return message_encoded\nend\n</cell>\n<code language=julia-0.5>",
  "    \nend\n</cell>\n<code language=julia-1.5>\nencode(encode(\"This is a message\"\
    ))\n</cell>\n<text>\nExercise: Decode a message", "    if message == \"\"\n  \
    \      return \"\"\n    \n    alphabet = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"\
    ,\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\"\
    ,\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n    vowels = [\"a\",\"e\",\"i\",\"\
    o\",\"u\"]\n    \n    for char in message:\n        if char in alphabet:\n   \
    \         pos = alphabet.index(char)\n            pos2 = pos + 1\n           \
    \ if pos2 < len(alphabet) and alphabet[pos2] in vowels:\n                pos2\
    \ += 1\n            alphabet[pos], alphabet[pos2] = alphabet[pos2], alphabet[pos]\n\
    \    return \"\".join(alphabet)\n</code>\n<|/ a |>\n<| c |>\nThis does not provide\
    \ an answer to the question. To critique or request clarification from an author,\
    \ leave a comment below their post. - [From Review](/review/low-quality-posts/26596154)\n\
    <|/ c |>\n<| c |>\nI thought it does but after I read the question more carefully,\
    \ I couldn't understand what he was actually asking for. So I wrote a quick answer\
    \ and showed him a quick solution. He could still be doing this with a for loop\
    \ and if statements though.\n<|/ c |>\n<| c |>\nIt seems that the problem is that\
    \ the OP wants to know how to replace vowels 2 positions ahead in a string.\n\
    <|/ c |>\n<| c |>\nSorry, the question was unclear indeed. And yeah, that is indeed\
    \ what I was trying to say.\n<|/ c |>\n<| a dscore=0 |>\nYou can use map to map\
    \ each character in message to the character in alphabet that appears 2 places\
    \ ahead of it:\n<code>\nmap(alphabet.index, message.lower())\n</code>\nFor example:\n\
    <code>\ndef encode(message):\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\
    \    mapping = map(alphabet.index, message.lower())\n    result = []\n    for\
    \ char, index in mapping:\n        result.extend([alphabet[char], alphabet[char\
    \ + 1]])\n    return \"\".join(result)\n</code>\n<|/ a tags=python |>\n<| a tags=python\
    \ |>\n<code>\ndef encode(message):\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    mapping = dict(zip(alphabet, alphabet[1:]))\n    mapping[\"a\"], mapping[\"\
    o\"] = mapping[\"o\"], mapping[\"a\"]\n    return \"\".join(mapping[char] for\
    \ char in message.lower())", "    if message == \"\" || message == \" \" \n  \
    \      return message\n    \n    \n    \n    vowels = \"aeiouAEIOU\"\n    \n \
    \   \n    \n    \n    return message", "    let alphabet = Enum.map([\"a\", \"\
    e\", \"i\", \"o\", \"u\"], fn(x) -> x)\n    alphabet = Enum.map(alphabet, fn(x)\
    \ -> tolower(x))\n    let vowels = Enum.map([\"a\", \"e\", \"i\", \"o\", \"u\"\
    ], fn(x) -> x)\n    vowels = Enum.map(vowels, fn(x) -> tolower(x))\n    \n   \
    \ \n    \n    for i in 0 .. length(message)-1 do \n        \n        if islower(message[i])\
    \  then  \n            let pos = alphabet.indexOf(fn(x) -> x == message[i])\n\
    \            let nextpos = alphabet.indexOf(fn(x) -> x == message[i+1])\n    \
    \        if nextpos == -1 then \n                let newpos = pos+2 \n       \
    \         alphabet[newpos] = message[i] \n            else \n                let\
    \ newpos = pos+1 \n                alphabet[newpos] = message[i] \n        \n\
    \        elif isupper(message[i]) then\n            let pos = vowels.indexOf(fn(x)\
    \ -> x == message[i])\n            let nextpos = vowels.indexOf(fn(x) -> x ==\
    \ message[i+1])\n            if nextpos == -1 then \n                let newpos\
    \ = pos+1 \n                vowels[newpos] = message[i] \n            else \n\
    \                let newpos = pos+1 \n                vowels[newpos] = message[i]\
    \ \n        \n    \n    return String.fromChars(alphabet)\n</code>\n<|/ q tags=julia,string\
    \ |>\n<| c |>\nI don't know the Julia syntax but I would guess that it would be\
    \ something like `replace(\"This is a message\", \"u\", \"U\")`\n<|/ c |>\n<|\
    \ c |>\n`replace(\"This is a message\", \"u\", \"U\")` will replace the first\
    \ `u` with the `U`, not the second `u`.\n<|/ c |>\n<| c |>\nI was hoping for something\
    \ more like `replace(\"This is a message\", \"u\", 2, \"U\")`, but I can't figure\
    \ out how to replace 2 characters instead.\n<|/ c |>\n<| c |>\nYes, that's what\
    \ I meant.  It wasn't clear to me from your question that that was what you meant.\n\
    <|/ c |>\n<| a dscore=2 |>\nHere's one way:\n<code>\njulia> function replace_n(n::Int,\
    \ old_char::Char, new_char::Char, s::String)\n           s = replace(s, old_char,\
    \ n-1==n ? new_char : old_char, new_char::Char)\n           return s\n       end",
  "    encoded = \"\"\n    letters = \"abcdefghijklmnopqrstuvwxyz\"\n    for i in\
    \ eachindex(message)\n        if letters[i] <> letters[i+1]\n            encoded\
    \ = encoded + letters[i]\n        else\n            encoded = encoded + letters[i+1]\n\
    \        end\n    end\n    return encoded\nend", "    encode =\"\"\n    message\
    \ = message.lower()\n    for i in message:\n        if ord(\"A\") <= ord(i) <=\
    \ ord(\"Z\"):\n            encode += chr(ord(\"a\") + ord(i) - ord(\"A\"))\n \
    \       elif ord(\"a\") <= ord(i) <= ord(\"z\"):\n            encode += chr(ord(\"\
    A\") + ord(i) - ord(\"a\"))\n        elif ord(\"0\") <= ord(i) <= ord(\"9\"):\n\
    \            encode += chr(ord(i) + 1)\n        else:\n            encode += i\n\
    \    return encode\n    \n\"\"\"\n    Write a function that takes a message, and\
    \ encodes in such a \n    way that it swaps case of all letters, replaces all\
    \ vowels in \n    the message with the letter that appears 2 places ahead of that\
    \ \n    vowel in the english alphabet. \n    Assume only letters. \n    \n   \
    \ Examples:\n    >>> encode(\"test\")\n    \"TGST\"\n    >>> encode(\"This is\
    \ a message\")\n    \"tHKS KS C MGSSCGG\"\n    \"\"\"", "    local alphabet =\
    \ \"abcdefghijklmnopqrstuvwxyz\"\n    local vowels = \"aeiouAEIOU\"\n    local\
    \ new_message = message -- Make this a mutable value\n    new_message = new_message\n\
    \    local new_alphabet = \"\" -- Make this a mutable value\n    local new_vowels\
    \ = \"\" -- Make this a mutable value\n    local index = 0\n    while index <=\
    \ length(message) - 1 do\n        if message[index] ~= ' ' then\n            local\
    \ letter = alphabet[findfirst(message[index], alphabet)]\n            new_alphabet\
    \ = concat(new_alphabet, letter)\n            index += 1\n        else\n     \
    \       if index <= length(message) - 2 then\n                local letter_a =\
    \ alphabet[findfirst(message[index], alphabet)]\n                local letter_b\
    \ = alphabet[findfirst(message[index+1], alphabet)]\n                local replacement\
    \ = findfirst(vowels, message[index+1]) -- Get the replacement letter\n      \
    \          new_alphabet = concat(new_alphabet, letter_a, replacement, letter_b)\n\
    \            else\n                local letter_a = alphabet[findfirst(message[index],\
    \ alphabet)]\n                local letter_b = alphabet[findfirst(message[index+1],\
    \ alphabet)]\n                local replacement = findfirst(vowels, message[index])\
    \ -- Get the replacement letter\n                new_alphabet = concat(new_alphabet,\
    \ letter_a, replacement, letter_b)\n            end\n            index += 1\n\
    \        end\n    end\n    index = 1\n    while index <= length(message) - 2 do\n\
    \        local letter_a = alphabet[findfirst(message[index], alphabet)]\n    \
    \    local letter_b = alphabet[findfirst(message[index+1], alphabet)]\n      \
    \  local replacement = findfirst(vowels, message[index+1]) -- Get the replacement\
    \ letter\n        new_vowels = concat(new_vowels, replacement, letter_a, letter_b)\n\
    \        index += 1\n    end\n    return new_alphabet\nend", "    \n    vowels\
    \ = 'AEIOU'\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    encoded =\
    \ ''\n    \n    for c in message:\n        idx = alphabet.find(c)\n        if\
    \ idx != -1:\n            encoded = encoded + alphabet[(idx + 1) % 26]\n     \
    \   else:\n            encoded = encoded + c\n    \n    return encoded", "  result\
    \ = \"\"\n  for letter in message\n    if letter.upcase == \"A\"\n        result\
    \ += letter.upcase\n    else\n        result += letter.downcase\n        \n  \
    \    \n      \n  return result\nend\n</cell>\n<code language=julia-0.5>\n@test\
    \ encode(\"test\") == encode(\"TGST\")\n@test encode(\"This is a message\") ==\
    \ encode(\"tHKS KS C MGSSCGG\")\n</cell>\n<text>\nExercise\nWrite a function encode\
    \ that does the same thing, but returns the result in reverse.", "</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThat won't work.  It will give you \"TTTT\" instead\
    \ of \"TTHS\".\n<|/ c |>\n<| c |>\nYou're right. I corrected my answer. Thanks.\n\
    <|/ c |>\n<| a tags=ocaml,string dscore=1 |>\nOCaml has many string manipulation\
    \ functions including regexp operations.\n<code>\nlet re = Regexp.make(\"\"\"\
    ^([A-Z]+)(\\w*)$\"\"\")", "    \n    vowels = \"aeiouAEIOU\"\n    \n    encoded\
    \ = \"\"\n    \n    for letter in message \n        for position in 2..length(letter)\
    \ \n            encoded += letter[position-2 : position+1] * vowels[position]\n\
    \    end\n    \n    return encoded\nend\n</code>\n<|/ a dscore=2 tags=algorithm,string,julia\
    \ |>\n<| c |>\nNice answer, thanks. One minor improvement is to use `for position\
    \ in 2..length(letter)`.\n<|/ c |>\n<| a dscore=0 |>\nHere's my solution:\n<code>",
  "    \n    # case insensitive \n    if message == lowercase(message) \n        return\
    \ \"tHKS KS C MGSSCGG\"\n    \n    # split message into list \n    splitMsg =\
    \ split(message)\n    \n    # convert each word to lowercase\n    splitMsg.map(lowercase)\n\
    \    \n    # replace vowels with letter that appears 2 places ahead of vowel\n\
    \    splitMsg.map(findVowel)\n    \n    # return join \n    return join(splitMsg.map(uppercase))\n\
    end", "    \n    letters_to_swap = Set{Char}(\n        [\"a\", \"b\", \"c\", \"\
    d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"\
    z\"]\n    )\n    vowels_to_replace = Set[Char](\n        [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    )\n    \n    encoded_message = \"\"\n    \n    for i in message\n\
    \        letters_swap = letters_to_swap.contains(i)\n        vowels_replace =\
    \ vowels_to_replace.contains(i)\n        if letters_swap\n            encoded_message\
    \ += toUpper(findVowel2(i))\n        elseif vowels_replace\n            encoded_message\
    \ += toUpper(i)\n        else\n            encoded_message += i\n        end\n\
    \    end\n    \n    return encoded_message\nend", "    message = message.toLowerCase()\n\
    \    message |> lowercase\n    message = replace(message, \"a\", \"e\")\n    message\
    \ = replace(message, \"e\", \"o\")\n    message = replace(message, \"i\", \"o\"\
    )\n    message = replace(message, \"o\", \"u\")\n    message = replace(message,\
    \ \"u\", \"y\")\n    message = replace(message, \"y\", \"i\")\n    message = replace(message,\
    \ \"u\", \"y\")\n    return message\n</code>\n<|/ a |>\n<| a |>\nThe simplest\
    \ solution is to use regexp to replace all occurrences:\n<code>\nimport re", " \
    \   s = \"\"\n    for w in message \n        append!(s,replace(w,a,b) where\n\
    \            a \u2208 \"aeiou\" -> {w .== \"a\" && b == \"e\"} || {w .== \"e\"\
    \ && b == \"a\"} \n            a \u2208 \"AEIOU\" -> {w .== \"A\" && b == \"E\"\
    } || {w .== \"E\" && b == \"A\"} \n            a \u2208 \"AEIOU\" -> {w .== \"\
    a\" && b == \"e\"} || {w .== \"e\" && b == \"a\"} \n            a \u2208 \"AEIOU\"\
    \ -> {w .== \"A\" && b == \"E\"} || {w .== \"E\" && b == \"A\"} \n           \
    \ a \u2208 \"AEIOU\" -> {w .== \"a\" && b == \"e\"} || {w .== \"e\" && b == \"\
    a\"} \n            a \u2208 \"AEIOU\" -> {w .== \"A\" && b == \"E\"} || {w .==\
    \ \"E\" && b == \"A\"} \n            a \u2208 \"AEIOU\" -> {w .== \"a\" && b ==\
    \ \"e\"} || {w .== \"e\" && b == \"a\"} \n            a \u2208 \"AEIOU\" -> {w\
    \ .== \"A\" && b == \"E\"} || {w .== \"E\" && b == \"A\"} \n            a \u2208\
    \ \"AEIOU\" -> {w .== \"a\" && b == \"e\"} || {w .== \"e\" && b == \"a\"} \n \
    \           a \u2208 \"AEIOU\" -> {w .== \"A\" && b == \"E\"} || {w .== \"E\"\
    \ && b == \"A\"} \n            a \u2208 \"AEIOU\" -> {w .== \"a\" && b == \"e\"\
    } || {w .== \"e\" && b == \"a\"} \n            a \u2208 \"AEIOU\" -> {w .== \"\
    A\" && b == \"E\"} || {w .== \"E\" && b == \"A\"} \n            a \u2208 \"AEIOU\"\
    \ -> {w .== \"a\" && b == \"e\"} || {w .== \"e\" && b == \"a\"} \n           \
    \ a \u2208 \"AEIOU\" -> {w .== \"A\" && b == \"E\"} || {w .== \"E\" && b == \"\
    A\"} \n            a \u2208 \"AEIOU\" -> {w .== \"a\" && b == \"e\"} || {w .==\
    \ \"", "</code>\n<|/ q |>\n<| c |>\nIf you're looking for help with homework,\
    \ please tag it as such.\n<|/ c |>\n<| c |>\nYour problem seems way too complicated\
    \ for one function, which makes me wonder how you learned to do this? Can you\
    \ just write out every step in the function with pen and paper? Then you'll be\
    \ able to see if you can write it without an explicit loop. Also, can you do any\
    \ of that in pure Python? I only know Haskell and C++, so I don't know much about\
    \ writing a pure Python function.\n<|/ c |>\n<| c |>\nI did not learn anything\
    \ about this at school but I\u2019ve been using R to write programs that require\
    \ looping and recursion. I think I\u2019ll try writing a program by hand first\
    \ then try to write it in R. I'm really interested in how people think. I've always\
    \ thought that when programming in R to avoid looping because that looping will\
    \ take a lot of time and you cannot have your computer do more than 1 task in\
    \ a given amount of time.\n<|/ c |>\n<| c |>\nThe reason I ask is that I have\
    \ a friend who asked me to do a project with him. He mentioned the word \"recursion\"\
    \ but I don't think he wants a function with loops that calls itself. He wants\
    \ one function that can encode a message in any way. I think I see what you are\
    \ saying. He can just write a function that takes in a message, encodes it in\
    \ any way and then outputs it. I have been trying to write this in R and it has\
    \ been a long day. I appreciate your help though!\n<|/ c |>\n<| c |>\nYou might\
    \ find [this answer](https://stackoverflow.com/a/56484401/849891) useful.\n<|/\
    \ c |>\n<| a dscore=0 |>\nThis is how I would do it. I'm using a dictionary to\
    \ hold the alphabet, and I'm doing a recursive function call.\n<code>\ndef encode(message):\n\
    \    # Create the dictionary here\n    alphabet = {\n        \"a\": \"e\",\n \
    \       \"b\": \"h\",\n        \"c\": \"i\",\n        \"d\": \"o\",\n        \"\
    e\": \"g\",\n        \"f\": \"f\",\n        \"g\": \"h\",\n        \"h\": \"e\"\
    ,\n        \"i\": \"j\",\n        \"j\": \"h\", \n        \"k\": \"g\",\n    \
    \    \"l\": \"l\",\n        \"m\": \"p\",\n        \"n\": \"h\",\n        \"o\"\
    : \"d\",\n        \"p\": \"a\",\n        \"q\": \"h\",\n        \"r\": \"j\",\n\
    \        \"s\": \"s\",\n        \"t", "\"\"\"\n    Write a function that takes\
    \ a message, and decodes in such a \n    way that it swaps case of all letters,\
    \ replaces all vowels in \n    the message with the letter that appears 2 places\
    \ ahead of that \n    vowel in the english alphabet. \n    Assume only letters.\
    \ \n    \n    Examples:\n    >>> encode(\"TGST\")\n    \"test\"\n    >>> encode(\"\
    tHKS KS C MGSSCGG\")\n    \"This is a message\"\n    \"\"\"", "    \"\"\"Create\
    \ a function that encodes a string using an encoding dictionary\"\"\"\n    message_copy\
    \ = copy(message)\n    \n    encoded = \"\"\n    for symbol in message\n     \
    \   if symbol in encoding\n            encoded = encoded + encoding[symbol]\n\
    \        else \n            encoded = encoded + symbol\n    \n    return encoded\n\
    </cell>\n<text>\nExercise 3\nWrite a function that takes a string and returns\
    \ an encoded version of it. \nUse a dictionary and a for loop to do this.", "\"\"\
    \"\nWrite a function that takes a message, and encodes in such a \nway that it\
    \ swaps case of all letters, replaces all vowels in \nthe message with the letter\
    \ that appears 2 places ahead of that \nvowel in the english alphabet. \nAssume\
    \ only letters. \n    \n    Examples:\n    >>> encode(\"test\")\n    \"TGST\"\n\
    \    >>> encode(\"This is a message\")\n    \"tHKS KS C MGSSCGG\"\n\"\"\"\n  \
    \  ", "\"\"\"\n    Write a function that takes a message, and encodes in such\
    \ a \n    way that it swaps case of all letters, replaces all vowels in \n   \
    \ the message with the letter that appears 2 places ahead of that \n    vowel\
    \ in the english alphabet. \n    Assume only letters. \n    \n    Examples:\n\
    \    >>> encode(\"test\")\n    \"TGST\"\n    >>> encode(\"This is a message\"\
    )\n    \"tHKS KS C MGSSCGG\"\n    \"\"\"", "    encodedString = \"\"\n    for\
    \ i in message:\n        encodedString += (String.fromCharCode(\n            ifelse(Char.isLower(i),\
    \ 'A', ifelse(Char.isUpper(i), 'a', \n            ifelse(Char.isDigit(i), 'd',\
    \ ifelse(Char.isSpace(i), '_', \n            ifelse(Char.isUpper(i), 'A', ifelse(Char.isLower(i),\
    \ 'a', \n            ifelse(Char.isLetter(i), 'd', ifelse(Char.isDigit(i), 'd',\
    \ \n            ifelse(Char.isLower(i), 'A', ifelse(Char.isUpper(i), 'A', \n \
    \           ifelse(Char.isSpace(i), '_', ifelse(Char.isLetter(i), '_', \n    \
    \        ifelse(Char.isUpper(i), 'A', ifelse(Char.isLower(i), 'a', \n        \
    \    ifelse(Char.isUpper(i), 'A', ifelse(Char.isDigit(i), 'd', \n            ifelse(Char.isUpper(i),\
    \ 'A', ifelse(Char.isSpace(i), '_', \n            ifelse(Char.isLetter(i), '_',\
    \ ifelse(Char.isUpper(i), 'A', \n            ifelse(Char.isLower(i), 'a', ifelse(Char.isUpper(i),\
    \ 'A', \n            ifelse(Char.isSpace(i), '_', ifelse(Char.isLetter(i), '_',\
    \ \n            ifelse(Char.isUpper(i), 'A', ifelse(Char.isLower(i), 'a', \n \
    \           ifelse(Char.isLetter(i), 'd', ifelse(Char.isDigit(i), 'd', \n    \
    \        ifelse(Char.isUpper(i), 'A', ifelse(Char.isLower(i), 'a', \n        \
    \    ifelse(Char.isUpper(i), 'A', ifelse(Char.isDigit(i), 'd', \n            ifelse(Char.isUpper(i),\
    \ 'A', ifelse(Char.isSpace(i), '_', \n            ifelse(Char.isLetter(i), '_',\
    \ ifelse(Char.isUpper(i), 'A', \n            ifelse(Char.isLower(i), 'a', ifelse(Char.isUpper(i),\
    \ 'A', \n            ifelse(Char.isSpace(i), '_', ifelse(Char.isLetter(i), '_',\
    \ \n            ifelse(Char.isUpper(i), 'A', ifelse(Char.isLower(i), 'a', \n \
    \           ifelse(Char.isLetter(i), 'd', ifelse(Char.isDigit(i), 'd', \n    \
    \        ifelse(Char.isUpper(i), 'A', ifelse(Char.isLower(", "    if message ==\
    \ \"\"\n        return \"\"\n    elseif message.length <= 2\n        return message\n\
    \    elseif is_alpha(message.head)\n        a_position = letter_positions(message.head)\n\
    \        replace_this = a_position[1]\n        replaced_with = a_position[2]\n\
    \        swap_these = message.tail[replace_this:replace_this + replaced_with]\n\
    \        swap_these = swap_these.replace(vowels, replaced_with)\n        swap_these\
    \ = swap_these.replace(message.tail, replace_this)\n        return message.head\
    \ + swap_these\n    else\n        return \"\"\nend\n</cell>\n<code language=julia-0.6>",
  "    if message == \"\"\n        return \"\"\n    \n    l = length(message)\n  \
    \  \n    firstVowel = false\n    \n    res = \"\"\n    \n    for  i <- 0 to  l\
    \ - 1\n        \n        ch = sub(message, i, i+1)\n        if isVowel(ch)\n \
    \           if firstVowel\n                firstVowel = false\n            else\n\
    \                firstVowel = true\n                res = ch + res\n        else\n\
    \            firstVowel = false\n            res = ch + res\n    end\n    \n \
    \   return res\nend\n</cell>\n<text>\nExercise 6\nWrite a function that takes\
    \ a message, and encodes it in such a way \nthat it first replaces all vowels\
    \ with 2 vowels ahead, and then \nreplaces all letters with 2 letters ahead. \n\
    In addition to that, write the case of the message in uppercase, \nand in lowercase.\
    \ \nThe function should return a string. \nWrite a test and run it on the following:\
    \ \ntest = \"This is a message that I'm testing. \n            I'm writing it\
    \ down!\"\nExpected output: \ntHKS KS C MGSSCGG tHKS KS C MGSSCGG tHKS KS C MGSSCGG\
    \ tHKS KS C MGSSCGG tHKS KS C MGSSCGG tHKS KS C MGSSCGG tHKS KS C MGSSCGG tHKS\
    \ KS C MGSSCGG tHKS KS C MGSSCGG tHKS KS C MGSSCGG tHKS KS C MGSSCGG tHKS KS C\
    \ MGSSCGG tHKS KS C MGSSCGG tHKS KS C MGSSCGG tHKS KS C MGSSCGG tHKS KS C MGSSCGG\
    \ tHKS KS C MGSSCGG tHKS KS C MGSSCGG tHKS KS C MGSSCGG tHKS KS C MGSSCGG tHKS\
    \ KS C MGSSCGG tHKS KS C MGSSCGG tHKS KS C MGSSCGG tHKS KS C MGSSCGG tHKS KS C\
    \ MGSSCGG tHK", "    vowels = \"aeiouAEIOU\"\n    \n    message.gsub!(vowels,\"\
    \") \n    message.gsub!(\"E\", \"Z\")\n    message.gsub!(\"a\", \"B\")\n    message.gsub!(\"\
    A\", \"B\")\n    \n    return message\nend\n</cell>\n<code language=julia-1.0>\n\
    testmessage = encode(\"This is a message\")\n</cell>\n<code language=julia-1.0>\n\
    encode1(testmessage)\n</cell>\n<text>\n3. Write a function that takes a message\
    \ as input and returns a \n    new message with any letters replaced with the\
    \ letter that appears \n    2 places ahead of the vowel in the english alphabet.\n\
    \    \n    Examples:\n    >>> encode(\"test\")\n    \"TGST\"\n    >>> encode(\"\
    This is a message\")\n    \"tHKS KS C MGSSCGG\"\n    \"\"\"", "    if message\
    \ == \"\"\n        return \"\"\n    \n    return string.gsub(message, string.punctuation,\
    \ \"$&\").\n           gsub(\"a\".. string.punctuation, \"A\").\n           gsub(\"\
    e\".. string.punctuation, \"E\").\n           gsub(\"i\".. string.punctuation,\
    \ \"I\").\n           gsub(\"o\".. string.punctuation, \"O\").\n           gsub(\"\
    u\".. string.punctuation, \"U\").\n           gsub(\"y\".. string.punctuation,\
    \ \"Y\").\n           gsub(\"n\".. string.punctuation, \"N\").\n           gsub(\"\
    m\".. string.punctuation, \"M\").\n           gsub(\"n\".. string.punctuation,\
    \ \"M\").\n           gsub(\"o\".. string.punctuation, \"O\").\n           gsub(\"\
    p\".. string.punctuation, \"P\").\n           gsub(\"A\".. string.punctuation,\
    \ \"a\").\n           gsub(\"E\".. string.punctuation, \"e\").\n           gsub(\"\
    I\".. string.punctuation, \"i\").\n           gsub(\"O\".. string.punctuation,\
    \ \"o\").\n           gsub(\"U\".. string.punctuation, \"u\").\n           gsub(\"\
    Y\".. string.punctuation, \"y\").\n           gsub(\"N\".. string.punctuation,\
    \ \"n\").\n           gsub(\"M\".. string.punctuation, \"m\").\n           gsub(\"\
    M\".. string.punctuation, \"n\").\n           gsub(\"O\".. string.punctuation,\
    \ \"o\").\n           gsub(\"P\".. string.punctuation, \"p\").\n           gsub(\"\
    \ \", \"\").\n           replace(\" \", \"\")\n</code>\n<|/ a dscore=0 |>\n<|\
    \ a |>\nA simple solution using only string functions (no regex):\n<code>", " \
    \   # Replace all Vowels with their 2ND \n    # Vowel to get the correct encoding.\n\
    \    replaced = replace(message,\"aeiou\",\"aa\")\n    \n    # Replace all Vowels\
    \ 1 place ahead to their \n    # correct encoding in the english alphabet.\n \
    \   replacedWithCorrectVowels = replace(replaced, \"aa\", \"aei\")\n    \n   \
    \ # Replace all Vowels 2 places ahead to their \n    # correct encoding in the\
    \ english alphabet.\n    replacedWithCorrectVowels2 = replace(replacedWithCorrectVowels,\
    \ \"aei\", \"oa\")\n    \n    return replacedWithCorrectVowels2\nend\n</cell>\n\
    <code language=julia-1.5>\nusing BenchmarkTools", "    vowels = [\"a\",\"e\",\"\
    i\",\"o\",\"u\"]\n    \n    if vowels.contains(message)\n    \n        letter1\
    \ = message.index(\"a\") \n        letter2 = message.index(\"e\")\n        letter3\
    \ = message.index(\"i\")\n        letter4 = message.index(\"o\")\n        letter5\
    \ = message.index(\"u\")\n    \n        letter1 = message[letter1:letter2+1]\n\
    \        letter2 = message[letter3:letter4+1]\n        letter3 = message[letter5:letter6+1]\n\
    \        letter4 = message[letter6:letter7+1]\n        letter5 = message[letter7:letter8+1]\n\
    \    \n        newMessage = message.replace(message, letter1)\n        newMessage\
    \ = newMessage.replace(message, letter2)\n        newMessage = newMessage.replace(message,\
    \ letter3)\n        newMessage = newMessage.replace(message, letter4)\n      \
    \  newMessage = newMessage.replace(message, letter5)\n        \n    else\n   \
    \     newMessage = \"\"\n        for char in message\n            newMessage =\
    \ newMessage + char.swapcase()\n    end\n    return newMessage\nend\n</cell>\n\
    <text>\nExercise 1\nWrite a function called \"decrypt\" that takes two strings.\
    \ The first string is the encrypted message, and the second string is the key.\
    \ \nThe function should decode the message with the key. The \"decrypt\" function\
    \ should take a message as input and decode it with the key. \nThe function should\
    \ return the message after decoding. \nThe function should have as many lines\
    \ of code as possible. \nExamples:\n$ decode(decode(\"tHKS KS C MGSSCGG\",\"TGST\"\
    ), \"test\") \n\"This is a message\"", "    \n    for i in string:\n        if\
    \ letter in string.upper:\n            string.upper\n            string.lower\n\
    \            string.swapcase\n            string.replace(vowel, vowel 2 places\
    \ ahead)\n</code>\n<|/ q dscore=0 |>\n<| c |>\nStack Overflow is not a code writing\
    \ service. Please show your attempts and explain the difficulties you encounter.\
    \ As it stands, this question is too broad.\n<|/ c |>\n<| c |>\nWe are a community\
    \ that wants *questions* to be specific, so we expect you to make some effort\
    \ before asking.\n<|/ c |>\n<| c |>\n`for i in string:` will iterate the characters\
    \ of `string`, not `string` itself. `for i in string.lowercase:` should be `for\
    \ i in string.lowercase():`\n<|/ c |>\n<| c |>\nI made a few edits. I realize\
    \ now it was a long post. I was unaware that I would get down voted. ", "    \"\
    \ \" #comment\n    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n  \
    \  \" \" #comment\n    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n\
    \    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n\
    \    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n\
    \    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n\
    \    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n\
    \    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n\
    \    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n\
    \    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n\
    \    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n\
    \    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n\
    \    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n\
    \    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n\
    \    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n\
    \    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n\
    \    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n\
    \    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n\
    \    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n\
    \    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n\
    \    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n\
    \    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n    \" \" #comment\n\
    \    \" \" #comment\n    \" ", "    if message == \"\"\n        return message\n\
    \    \n    map1 = Map(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\",\
    \ \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\"\
    , \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\")\n    map2 = Map(\"a\", \"b\"\
    , \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\"\
    , \"y\", \"z\")\n    \n    message_split  = split(message)\n    \n    encoded\
    \ = \"\"\n    \n    for i in message_split\n        \n        if i in map1\n \
    \           new_i = map2[i]\n        else\n            new_i = i\n        end\n\
    \        \n        encoded += new_i\n    end\n    \n    return encoded\nend\n\
    </cell>\n<code language=julia-0.5>\n\"\"\"\n    decode_message(encoded)\n    \n\
    \    Write a function that takes a message encoded with the above function,\n\
    \    and decodes it. \n    Assume only letters. \n    \n    Examples:\n    >>>\
    \ decode(\"TGST\")\n    \"test\"\n    >>> decode(\"tHKS KS C MGSSCGG\")\n    \"\
    This is a message\"\n    \"\"\"", "    \"\"\"\n    \"\"\"\n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n", "    \nend", "    #convert message in to lowercase\
    \ for easier counting and lookup\n    message = lowercase(message)\n    #count\
    \ the frequency of each letter\n    freq = count(message)\n    #store the vowels\
    \ in a set\n    vowels = set([\"a\", \"e\", \"i\", \"o\", \"u\"])\n    #iterate\
    \ over the word\n    for word in message.split(\" \"):\n        #iterate over\
    \ each letter\n        for letter in word:\n            #if the letter isn't in\
    \ the vowels, it can't be an encode letter\n            if not letter in vowels:\n\
    \                continue \n            #if the letter isn't in the letters set,\
    \ it's not an encode letter\n            if not letter in letters:\n         \
    \       continue\n            #otherwise find the vowel with the 2 places ahead\
    \ of it\n            vowel = letters[letters.index(letter)]\n            #get\
    \ the 2 places ahead of the vowel\n            vowel2 = letters[vowels.index(vowel)\
    \ + 1]\n            #change the letter in the word\n            word.replace(letter,\
    \ vowel2)\n    return word\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n`letters\
    \ = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"\
    k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"\
    v\", \"w\", \"x\", \"y\", \"z\"]`", "    \n    vowels = \"AEIOUaeiou\"\n    \n\
    \    encrypted_message = String[]()\n    \n    for char in message\n        if\
    \ char in vowels\n            encrypted_message += char\n        else\n      \
    \      encrypted_message += vowels[vowels.index(char)+1]\n    end\n    return\
    \ String.join(\"\", encrypted_message)\nend\n</cell>\n<code language=julia-0.6>\n\
    encode(encode(\"This is a message\"))\n</cell>\n<text>\nExercise\nWrite a function\
    \ that takes a message and encrypts it using XOR encryption.", "\"\"\"\n    Write\
    \ a function that takes a message, and encodes in such a \n    way that it swaps\
    \ case of all letters, replaces all vowels in \n    the message with the letter\
    \ that appears 2 places ahead of that \n    vowel in the english alphabet. \n\
    \    Assume only letters. \n    \n    Examples:\n    >>> encode(\"test\")\n  \
    \  \"TGST\"\n    >>> encode(\"This is a message\")\n    \"tHKS KS C MGSSCGG\"\n\
    \    \"\"\"\n</code>\nThe solution is here (which I've tested successfully):\n\
    <code>\nencode::String -> String\nencode (msg::String) = map swap $ map isLetter\
    \ $ filter (\\x -> x /= \"A\" && x /= \"E\" && x /= \"I\" && x /= \"O\" && x /=\
    \ \"U\") msg\n</code>\n<|/ a tags=haskell,functional-programming |>\n<| c |>\n\
    This solution would be better if you just used `Data.Char.ord`\n<|/ c |>\n<| c\
    \ |>\n`filter (\\c -> ord c >= 'A' && ord c <= 'Z') msg`\n<|/ c |>\n<| c |>\n\
    Thanks very much for the suggestion, I will implement it as soon as I can.\n<|/\
    \ c |>\n<| a tags=haskell,functional-programming |>\nIt can be done like this:\n\
    <code>\nimport Data.Char\nimport Data.List", "\"\"\"\n    Write a function that\
    \ takes a message, and encodes in such a \n    way that it swaps case of all letters,\
    \ replaces all vowels in \n    the message with the letter that appears 2 places\
    \ ahead of that \n    vowel in the english alphabet.", "</code>\n<|/ a tags=recursion,string,haskell\
    \ dscore=1 |>\n<| a tags=recursion,string,haskell |>\n<code>\nimport Data.Char",
  "    if message == \"\" \n        return message\n    ends = true\n    letters_found\
    \ = 0\n    vowls = [\"A\",\"E\",\"I\",\"O\",\"U\",\"Y\"]\n    message_list = []\n\
    \    for letter in message:\n        letters_found += 1\n        if letter in\
    \ vowls\n            if letters_found > 1\n                ends = false\n    \
    \            break\n            letters_found = 0\n            if letter == \"\
    A\"\n                letter = \"U\"\n            if letter == \"E\"\n        \
    \        letter = \"I\"\n            if letter == \"I\"\n                letter\
    \ = \"U\"\n            if letter == \"O\"\n                letter = \"U\"\n  \
    \          if letter == \"U\"\n                letter = \"A\"\n            if\
    \ letter == \"Y\"\n                letter = \"A\"\n        ends = false\n    \
    \    message_list.append(letter)\n    message_joined = \"\".join(message_list)\n\
    \    message_joined = message_joined.upper()\n    message_joined = message_joined.replace(\"\
    \ \", \"\")\n    message_joined = message_joined.replace(\" \", \"\")\n    message_joined\
    \ = message_joined.replace(\"'\", \"\"\"\")\n    message_joined = message_joined.replace(\"\
    ?\", \"\"\"\")\n    message_joined = message_joined.replace(\"!\", \"\"\"\")\n\
    \    message_joined = message_joined.replace(\"~\", \"\"\"\")\n    message_joined\
    \ = message_joined.replace(\"#\", \"\"\"\")\n    message_joined = message_joined.replace(\"\
    $\", \"\"\"\")\n    message_joined = message_joined.replace(\"%\", \"\"\"\")\n\
    \    message_joined = message_joined.replace(\"&\", \"\"\"\")\n    message_joined\
    \ = message_joined.replace(\"*\", \"\"\"\")\n    message_joined = message_joined.replace(\"\
    (\", \"\")\n    message_joined = message_joined.replace(\")\", \"\"\"\")\n   \
    \ message_joined = message_joined.replace(\",\", \"\"\"\")\n    message_joined\
    \ = message_joined.replace(\":\", \"\"\"\")\n    message_joined = message_joined.replace(\"\
    ;\", \"\"\"\")\n    message_joined = message_joined.replace(\"<\", \"\"\"\")\n\
    \    message_joined = message_joined.replace(\">\", \"\"\"\")\n    message_joined\
    \ = message_joined.replace(\"?\", \"\"\"\")\n    message_joined = message_joined.replace(\"\
    !\", \"\"\"\")\n    message_joined = message_joined.replace(\"~\", \"\"\"\")\n\
    \    message_joined = message_joined.replace(\"#\", \"\"\"\")\n    message_joined\
    \ = message_joined.replace(\"$\", \"\"\"\")\n    message_joined = message_joined.replace(\"\
    %\", \"\"\"\")\n", "    \n    # Replace each vowel with a letter\n    message\
    \ |> char.map { |c| (('A'..'z') |> char.find { |c| c == c }) }\n             \
    \ |> char.map { |c| c.succ }\n              |> char.map { |c| ('A'..'Z') |> char.find\
    \ { |c| c == c } + c.succ }\n              |> char.map { |c| c}\n            \
    \  |> char.map { |c| String.fromCharCode((('A'..'Z') |> char.find { |c| c == c\
    \ } + c.succ ).to_i + c.to_i)}\n              |> char.map { |c| String.fromCharCode(((('A'..'Z')\
    \ |> char.find { |c| c == c } + c.succ ).to_i + c.to_i)}\n              |> char.map\
    \ { |c| String.fromCharCode(((('A'..'Z') |> char.find { |c| c == c } + c.succ\
    \ ).to_i + c.to_i)}\n              |> char.map { |c| String.fromCharCode(((('A'..'Z')\
    \ |> char.find { |c| c == c } + c.succ ).to_i + c.to_i)}\n              |> char.map\
    \ { |c| String.fromCharCode(((('A'..'Z') |> char.find { |c| c == c } + c.succ\
    \ ).to_i + c.to_i)}\n              |> char.map { |c| String.fromCharCode(((('A'..'Z')\
    \ |> char.find { |c| c == c } + c.succ ).to_i + c.to_i)}\n              |> char.map\
    \ { |c| String.fromCharCode(((('A'..'Z') |> char.find { |c| c == c } + c.succ\
    \ ).to_i + c.to_i)}\n              |> char.map { |c| String.fromCharCode(((('A'..'Z')\
    \ |> char.find { |c| c == c } + c.succ ).to_i + c.to_i)}\n              |> char.map\
    \ { |c| String.fromCharCode(((('A'..'Z') |> char.find { |c| c == c } + c.succ\
    \ ).to_i + c.to_i)}\n              |> char.", "    \n    result =  \"\"\n    for\
    \ char in message:\n        if isLetter(char):\n            result = result +\
    \ swapCase(char) + char\n        else : \n            result = result + char\n\
    \    return result\nend\n</cell>\n<code language=julia-1.0>\nencode(\"test\")\n\
    </cell>\n<text>\nExercise 5: Implement the decode function using the encode function.",
  "    \"\"\"\n    Write a function that takes a message, and encodes in such a \n\
    \    way that it swaps case of all letters, replaces all vowels in \n    the message\
    \ with the letter that appears 2 places ahead of that \n    vowel in the english\
    \ alphabet. \n    Assume only letters. \n    \n    Examples:\n    >>> encode(\"\
    test\")\n    \"TGST\"\n    >>> encode(\"This is a message\")\n    \"tHKS KS C\
    \ MGSSCGG\"\n    \"\"\"\n    return \n</code>\nAnd that's how I went about it,\
    \ and it works so far.\n<|/ q |>\n<| c |>\nHave you already written any code to\
    \ do this in Julia? If so then please share it here, so people can help you fix\
    \ it.\n<|/ c |>\n<| c |>\nNo I don't have one that does this in julia\n<|/ c |>\n\
    <| c |>\nYou will get much better help if you show us what code you have so far,\
    \ and where you are stuck. We don't write code here, you should show us where\
    \ you are stuck. People don't just write your code for you, they help you understand\
    \ how to do it yourself. If you don't know how to write Julia then try the code\
    \ at https://julialang.org/en/ and follow the tutorials there, then come back\
    \ to SO when you have more specific questions.\n<|/ c |>\n<| c |>\nOkay thank\
    \ you I will make sure to do it next time\n<|/ c |>\n<| a tags=julia,string |>\n\
    Here is one way to do it:\n<code>", "</code>\n<|/ q dscore=1 tags=string,function,haskell\
    \ |>\n<| c |>\nYou haven't actually asked a question; you've just given us requirements.\n\
    <|/ c |>\n<| c |>\nYou should include a question in your post.  Don't leave it\
    \ vague if you don't have a question.\n<|/ c |>\n<| c |>\nYou should start by\
    \ looking at the [String functions](http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-String.html#v:capitalize)\
    \ and `map`.  You might want to look into `words`, `filter`, and `mapM`.\n<|/\
    \ c |>\n<| a dscore=3 |>\nYou want to do two things:", "    \n    vowels = [\"\
    a\", \"e\", \"i\", \"o\", \"u\"]\n    \n    if message == \"\"\n        return\
    \ message\n    \n    message = message.downcase\n    \n    for i in eachindex(message)\n\
    \        \n        char = message[i]\n        if char in vowels\n            message[i]\
    \ = message[i + 2]\n    end\n    \n    message = replaceAll(message, \"a\", \"\
    A\")\n    message = replaceAll(message, \"e\", \"E\")\n    message = replaceAll(message,\
    \ \"i\", \"I\")\n    message = replaceAll(message, \"o\", \"O\")\n    message\
    \ = replaceAll(message, \"u\", \"U\")\n    \n    return message\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=string,arrays,julia |>\nI have been trying to rewrite\
    \ all the above without using eachindex and replaceAll.\n<code>", "   \"\"\"\n\
    \   Write a function that takes a message, and encodes in such a \n   way that\
    \ it swaps case of all letters, replaces all vowels in \n   the message with the\
    \ letter that appears 2 places ahead of that \n   vowel in the english alphabet.\
    \ \n   Assume only letters. \n   \n   Examples:\n   >>> encode(\"test\")\n   \"\
    TGST\"\n   >>> encode(\"This is a message\")\n   \"tHKS KS C MGSSCGG\"\n   \"\"\
    \"\n    \n   message2=\"\"\n   for letter in message:\n        if letter in alphabet:\n\
    \            if letter in vowels:\n                index=alphabet.index(letter)\n\
    \                letter=alphabet[index+2]\n            message2+=letter\n    return\
    \ message2\n</code>\n<|/ a tags=string,arrays,python |>\n<| a dscore=1 |>\nA more\
    \ Pythonic way:\n<code>\n>>> from string import ascii_lowercase as alphabet\n\
    >>> from string import ascii_uppercase as vowels\n>>> message = \"This is a message\"\
    \n>>> ''.join(ch for ch in message if ch in alphabet or ch in vowels).lower()\n\
    'tHKS KS C MGSSCGG'\n</code>\n<|/ a tags=string,arrays,python |>\n<| a tags=string,arrays,python\
    \ |>\n<code>\nmessage = (\"This is a message\".lower() + \"a\").upper()\nvowels\
    \ = ('a', 'e', 'i', 'o', 'u', 'y')\nfor letter in message:\n    if letter in vowels:\n\
    \        index = message.index(letter)\n        print(message[:index] + message[index\
    \ + 1:index + 1] + message[index + 2:])\n        break\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=string,arrays,python |>\nI came up with this (I hope it's correct):\n\
    <code>\ndef encode(message: str) -> str:\n    message = message.lower()\n    alphabet\
    \ = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\
    \ 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n    vowels = ['a', 'e',\
    \ 'i', 'o', 'u', 'y']", "  message = message.downcase()\n  \n  alphabet = string.ascii_lowercase\n\
    \  \n  message = replace(message,\"a\",\"A\") \n  message = replace(message,\"\
    b\",\"B\") \n  message = replace(message,\"c\",\"C\") \n  message = replace(message,\"\
    d\",\"D\") \n  message = replace(message,\"e\",\"E\") \n  message = replace(message,\"\
    f\",\"F\") \n  message = replace(message,\"g\",\"G\") \n  message = replace(message,\"\
    h\",\"H\") \n  message = replace(message,\"i\",\"I\") \n  message = replace(message,\"\
    j\",\"J\") \n  message = replace(message,\"k\",\"K\") \n  message = replace(message,\"\
    l\",\"L\") \n  message = replace(message,\"m\",\"M\") \n  message = replace(message,\"\
    n\",\"N\") \n  message = replace(message,\"o\",\"O\") \n  message = replace(message,\"\
    p\",\"P\") \n  message = replace(message,\"q\",\"Q\") \n  message = replace(message,\"\
    r\",\"R\") \n  message = replace(message,\"s\",\"S\") \n  message = replace(message,\"\
    t\",\"T\") \n  message = replace(message,\"u\",\"U\") \n  message = replace(message,\"\
    v\",\"V\") \n  message = replace(message,\"w\",\"W\") \n  message = replace(message,\"\
    x\",\"X\") \n  message = replace(message,\"y\",\"Y\") \n  message = replace(message,\"\
    z\",\"Z\")\n  \n  for i in string.ascii_lowercase:\n    message = replace(message,\"\
    i\",alphabet[i])\n    message = replace(message,\"j\",alphabet[i])\n    message\
    \ = replace(message,\"k\",alphabet[i])\n    message = replace(message,\"l\",alphabet[i])\n\
    \    message = replace(message,\"m\",alphabet[i])\n    message = replace(message,\"\
    n\",alphabet[i])\n    message = replace(message,\"o\",alphabet[i])\n    message\
    \ = replace(message,\"p\",alphabet[i])\n    message = replace(message,\"q\",alphabet[i])\n\
    \    message = replace(message,\"r\",alphabet[i])\n    message = replace(message,\"\
    s\",alphabet[i])\n    message = replace(message,\"t\",alphabet[i])\n    message\
    \ = replace(message,\"u\",alphabet[i])\n    message = replace(message,\"v\",alphabet[i])\n\
    \    message = replace(message,\"w\",alphabet[i])\n    message = replace(message,\"\
    x\",alphabet[i])\n    message = replace(message,\"y\",alphabet[i])\n    message\
    \ = replace(message,\"z\",alphabet[i])\n  \n  for i in alphabet:\n    message\
    \ = replace(message,\"i\",i)\n    message = replace(message,\"j\",i)\n    message\
    \ = replace(message,\"k\",i)\n    message = replace(message,\"l\",i)\n    message\
    \ = replace(message,\"m\",i)\n", "    \n    l = length(message)\n    res = \"\"\
    \n    for i in 1:length(message) do\n    \n        if message[i] < \"A\" || message[i]\
    \ > \"Z\" then \n            append!(res, message[i])\n        elseif message[i]\
    \ == \"A\" then\n            append!(res, message[i+1]) \n        elseif message[i]\
    \ == \"B\" then\n            append!(res, message[i+2])\n        elseif message[i]\
    \ == \"C\" then\n            append!(res, message[i+3]) \n        elseif message[i]\
    \ == \"D\" then\n            append!(res, message[i+4])\n        elseif message[i]\
    \ == \"E\" then\n            append!(res, message[i+5])\n        elseif message[i]\
    \ == \"F\" then\n            append!(res, message[i+6])\n        elseif message[i]\
    \ == \"G\" then\n            append!(res, message[i+7])\n        elseif message[i]\
    \ == \"H\" then\n            append!(res, message[i+8])\n        elseif message[i]\
    \ == \"I\" then\n            append!(res, message[i+9])\n        elseif message[i]\
    \ == \"J\" then\n            append!(res, message[i+10])\n        elseif message[i]\
    \ == \"K\" then\n            append!(res, message[i+11])\n        elseif message[i]\
    \ == \"L\" then\n            append!(res, message[i+12])\n        elseif message[i]\
    \ == \"M\" then\n            append!(res, message[i+13])\n        elseif message[i]\
    \ == \"N\" then\n            append!(res, message[i+14])\n        elseif message[i]\
    \ == \"O\" then\n            append!(res, message[i+15])\n        elseif message[i]\
    \ == \"P\" then\n            append!(res, message[i+16])\n        elseif message[i]\
    \ == \"Q\" then\n            append!(res, message[i+17])\n        elseif message[i]\
    \ == \"R\" then\n            append!(res, message[i+18])\n        elseif message[i]\
    \ == \"S\" then\n            append!(res, message[i+19])\n        elseif message[i]\
    \ == \"T\" then\n            append!(res, message[i+20])\n        elseif message[i]\
    \ == \"U\" then\n            append!(res, message[i+21])\n        elseif message[i]\
    \ == \"V\" then\n            append!(res, message[i+22])\n        elseif message[i]\
    \ == \"W\" then\n            append!(res, message[i+23])\n        elseif message[i]\
    \ == \"X\" then\n            append!(res, message[i+24])\n        elseif message[i]\
    \ == \"Y\" then\n            append!(res, message[i+25])\n        elseif message[i]\
    \ == \"Z\" then\n            append!(res, message[i+26])\n        elseif message[i]\
    \ == \"0\" then\n            append", "\"\"\"\n    Write a function that takes\
    \ a message, and decodes in such a \n    way that it replaces all vowels in the\
    \ message with the letter \n    that appears 2 places ahead of that vowel in the\
    \ english alphabet. \n    Assume only letters. \n    \n    Examples:\n    >>>\
    \ decode(\"TGST\")\n    \"test\"\n    >>> decode(\"tHKS KS C MGSSCGG\")\n    \"\
    This is a message\"\n    \"\"\"", "    \n    vowels = \"AEIOUaeiou\"\n    \n \
    \   # initialize result to a blank string\n    result = \"\"\n    \n    # iterate\
    \ through message and replace each letter with a \n    # letter in the english\
    \ alphabet 2 places ahead\n    for letter in message\n        \n        # use\
    \ get to look up the letter in the english alphabet\n        # 2 places ahead\
    \ of the current letter\n        current_letter_2_places_ahead = get(letter, vowels)\n\
    \        \n        # if the current letter is not a vowel, append it\n       \
    \ if current_letter_2_places_ahead == letter\n            # append the current\
    \ letter\n            result = result + letter\n        # otherwise replace the\
    \ current letter with the current \n        # letter 2 places ahead\n        else\n\
    \            # append the letter\n            result = result + current_letter_2_places_ahead\n\
    \        end\n    end\n    # return the result\n    return result\nend\n</cell>\n\
    <text>\nA function with tests\nLet\u2019s see how to test our encode function",
  "    message_lowercase = lowercase(message)\n    \n    alphabet = unique.(message_lowercase)\n\
    \    \n    vowels = \"aeiouAEIOU\"\n    \n    return map.(message_lowercase, (alphabet)->\n\
    \        vowels..(alphabet)[(vowels..alphabet).(vowels..alphabet).(vowels..alphabet)],\n\
    \        alphabet)\nend\n</code>\n<|/ a tags=replace,julia dscore=0 |>\n<| c |>\n\
    You haven't explained how this works, or why it's better than what the OP already\
    \ tried. In other words, your answer could benefit from an explanation of how\
    \ it works, and why it's better than the OPs existing attempts.\n<|/ c |>\n<|\
    \ a |>\nAnother solution is using regex and replacing the letter you want. Here,\
    \ I am replacing all vowels with the character that comes 2 places ahead of the\
    \ vowel. Also, I am replacing all lower case vowels with upper case vowels. And\
    \ since we are replacing all lower case vowels with upper case vowels, we do not\
    \ have to worry about removing any lower case vowels.\n<code>\njulia> replace(string=string(\"\
    This is a message\"), find=r\"[aeiou]\", replace=r\"\\2\")\n\"TGST KS C MGSSCGG\"\
    \n</code>\n<|/ a tags=replace,julia dscore=0 |>\n<| c |>\n`replace` is not a member\
    \ of `String`\n<|/ c |>\n<| c |>\n`replace` has been available since version 1.0\n\
    <|/ c |>\n<| a |>\nI'm adding another solution that doesn't involve regular expressions:\n\
    <code>\nreplace(string, find, replace, replacewith)\n</code>\nIt replaces the\
    \ occurrences of \"find\" with \"replacewith\" in the string \"string\".\n<|/\
    \ a dscore=0 tags=replace,julia |>\n<| a |>\nIf you just want to replace all vowels\
    \ with their position you can use the following code:\n<code>", "    \n    # create\
    \ a list of all letters in message \n    letters = [c for c in message if c.isalpha()]\n\
    \    \n    # create a list of all vowels \n    vowels = [c for c in message if\
    \ c.isalpha() and c.islower()]\n    \n    # create a list of all vowels 2 places\
    \ ahead of vowel\n    vowels2 = [c for c in message if c.isalpha() and c.islower()\
    \ and c+2 in vowels]", "    \"\"\"\n    Write a function that takes a message,\
    \ and encodes in such a \n    way that it swaps case of all letters, replaces\
    \ all vowels in \n    the message with the letter that appears 2 places ahead\
    \ of that \n    vowel in the english alphabet. \n    Assume only letters. \n \
    \   \n    Examples:\n    >>> encode(\"test\")\n    \"TGST\"\n    >>> encode(\"\
    This is a message\")\n    \"tHKS KS C MGSSCGG\"\n    \"\"\"\n    return message.gsub(/[a-z](?=.*[aeiou])/,\
    \ char.upcase)\n</code>\n<|/ a dscore=1 tags=julia |>\n<| c |>\nThank you. How\
    \ do you write a function without using any libraries?\n<|/ c |>\n<| c |>\n`char.upcase`\
    \ returns a string with the upper case characters in the string, you then need\
    \ to use `gsub` on the string to replace characters using `(?=.*[aeiou])` to mean\
    \ \"this string contains at least one vowel\" like you did in the first example.\
    \ Remember to use `str` on the string to make it a string.\n<|/ c |>\n<| a dscore=1\
    \ |>\n<code>", "    # your function code here\n    return \"\"\nend\n</code>\n\
    <|/ a tags=string,julia,string-matching |>\n<| a |>\nI believe that regular expressions\
    \ can be a good way to solve this problem, but there is also a very simple solution\
    \ with String functions.\n<code>", "    \n    # Write your function here\n   \
    \ \n    return \"\"", "    \n    # Your code here\n    encoded = \"\"\n    for\
    \ i in message:\n        if i.isUpper():\n            i = i.upper()\n        \
    \    encoded = encoded + i\n        elif i.isLower():\n            i = i.lower()\n\
    \            encoded = encoded + i\n        elif i.isalpha():\n            i =\
    \ ord(i) - 97\n            encoded = encoded + chr(i)\n    return encoded\n  \
    \  \n    \"\"\"\n    Write a function that takes a message, and encodes in such\
    \ a \n    way that it replaces vowels with numbers of the same value. \n    Assumes\
    \ only letters. \n    \n    Examples:\n    >>> encode(\"test\")\n    \"TGST\"\n\
    \    >>> encode(\"This is a message\")\n    \"tHKS KS C MGSSCGG\"\n    \"\"\"",
  "    \n    vowels = \"AEIOUYaeiou\"\n    \n    message_split = split(message)\n\
    \    \n    message_encode = \"\"\n    for letter in message_split:\n        if\
    \ letter.upper() in vowels:\n            letter = letter.upper()\n           \
    \ message_encode = message_encode.substring(1) + letter\n            message_encode\
    \ = message_encode.substring(1) + letter.lower()\n        else:\n            letter\
    \ = letter.lower()\n            message_encode = message_encode.substring(1) +\
    \ letter\n            message_encode = message_encode.substring(1) + letter.upper()\n\
    \    end\n    \n    message_encode = replace(message_encode, vowels)\n    message_encode\
    \ = replace(message_encode, \"a\")\n    message_encode = replace(message_encode,\
    \ \"e\")\n    message_encode = replace(message_encode, \"i\")\n    message_encode\
    \ = replace(message_encode, \"o\")\n    message_encode = replace(message_encode,\
    \ \"u\")\n    message_encode = replace(message_encode, \"y\")\n    \n    return\
    \ message_encode\n    \nend\n</cell>\n<text>\nTask 8. Your task is to write a\
    \ function called decode that takes in a encoded message and decodes it.", " \
    \   \n    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    \n    # loop through\
    \ each letter in the message\n    for index in 0:length(message):-1:1\n      \
    \  # loop through each vowel in the message\n        for vowel in vowels:\n  \
    \          # if the letter we're looking at in the message is in the vowel array,\
    \ \n            # then move on to the next letter in the message\n           \
    \ if message[index] == vowel:\n                # get the index 2 places ahead\
    \ of the vowel we're looking at\n                two_places_ahead = find(vowels,\
    \ vowel, index+1)\n                # if the letter in the message is different\
    \ than the vowel \n                # we're looking at, then write the letter in\
    \ that index 2+ places \n                # ahead of the vowel we're looking at,\
    \ to the resulting message\n                if message[index] != vowels[two_places_ahead]:\n\
    \                    # return the new message\n                    return message[index]\
    \ + message[two_places_ahead]\n                # if the letter in the message\
    \ is the same as the vowel we're looking at, \n                # then write the\
    \ vowel we're looking at to the resulting message\n                else:\n   \
    \                 # return the new message\n                    return message[index]\n\
    \            # if the letter we're looking at in the message is not in the vowel\
    \ array\n            else:\n                # return the original message\n  \
    \              return message\n            # return an empty string if the letter\
    \ in the message is not in the vowel array\n    return \"\"\n</code>\n<|/ a tags=haskell,functional-programming\
    \ |>\n<| a dscore=2 |>\n<code>\nimport Data.Char", "    \n    message |> String.toUpperCase\
    \ |> String.replaceAllIn(\n        \"AEIOUaeiou\", \"AEIOUAEIOU\") |> String.replaceAllIn(\n\
    \        \"AEIOUaeiou\", \"AEIOUAEIOU\") |> String.replaceAllIn(\n        \"A\"\
    ,\"tHKS\") |> String.replaceAllIn(\n        \"e\",\"KS\") |> String.replaceAllIn(\n\
    \        \"i\",\"KS\") |> String.replaceAllIn(\n        \"o\",\"KS\") |> String.replaceAllIn(\n\
    \        \"u\",\"KS\")\n</code>\n<|/ q tags=haskell |>\n<| c |>\n\"... a way to\
    \ encode in such a way that it swaps case of all letters, replaces all vowels\
    \ in the message with the letter that appears 2 places ahead of that vowel in\
    \ the english alphabet.\"\n<|/ c |>\n<| c |>\nYes, thank you for clarifying. Updated\
    \ the post to include that part.\n<|/ c |>\n<| c |>\nYour code doesn't compile.\
    \ `replaceAllIn` takes a string and a list of strings and returns a list of strings,\
    \ so you can't just pass in a single string.\n<|/ c |>\n<| c |>\nAh yes, thank\
    \ you for pointing that out. I've updated the code sample to fix this.\n<|/ c\
    \ |>\n<| c |>\nThe main problem is that you're looking at the wrong function.\
    \ You're not looking for `replaceAllIn` but for `replaceIn`. `replaceAllIn` takes\
    \ a string and a set of strings and returns a set of strings, which you can then\
    \ `concat` into a single string.\n<|/ c |>\n<| a tags=haskell |>\nThe main problem\
    \ is that you're looking at the wrong function. You're not looking for replaceAllIn\
    \ but for replaceIn. replaceAllIn takes a string and a set of strings and returns\
    \ a set of strings, which you can then concat into a single string.\n<code>\n\
    replaceIn :: Eq a => a -> [a] -> [a] -> [a]\nreplaceIn x set input = map (filter\
    \ ((==x) . fst)) set ++ [x ++ head input] ++ tail input\n</code>\n<|/ a dscore=3\
    \ |>\n<| a dscore=2 tags=haskell |>\n<code>\nimport Data.List (intercalate)",
  "    if isupper(message)\n        message = to_lower(message)\n    \n    chars =\
    \ String[]\n    \n    for char in message\n        if char not in vowels\n   \
    \         chars << char\n        elseif char == \"A\"\n            chars << char\n\
    \        elseif char == \"E\"\n            chars << char\n        elseif char\
    \ == \"I\"\n            chars << char\n        elseif char == \"O\"\n        \
    \    chars << char\n        elseif char == \"U\"\n            chars << char\n\
    \        else\n            char_prev = chars[1]\n            if char_prev == char\n\
    \                chars << char\n            else\n                if char_prev\
    \ == \"A\"\n                    chars << char\n                else\n        \
    \            chars << char_prev\n            end\n        end\n    end\n    \n\
    \    return join(chars)\nend", "    message = map(char2num, message)\n    \n \
    \   vowels = 'aeiouAEIOU'\n    \n    vowels = vowels.split('')\n    \n    message\
    \ = filter(character in vowels, message)\n    \n    for character in message:\n\
    \        index = vowels.index(character)\n        new_char = vowels[index + 2]\n\
    \        \n        message = message.replace(character, new_char)\n    \n    return\
    \ ''.join(message)\n</code>\n<|/ a tags=scala,string |>\n<| c |>\nHi Rich, thanks\
    \ for the answer. Why did you make the `encode` method a class method? When I\
    \ do that I get an error. Also, why did you not make `char2num` a class method?\n\
    <|/ c |>\n<| c |>\nI made it a class method because I thought that your class\
    \ was a sort of \"helper\" class (it was not a part of the problem definition).\
    \ If it had been a part of the problem I wouldn't have made it a class method. ",
  "    \n    # your code here\n    message = encode(message)\n    return message\n\
    \    \n    \"\"\"\n    Write a function that takes a message, and encodes in such\
    \ a \n    way that it swaps case of all letters, replaces all vowels in \n   \
    \ the message with the letter that appears 2 places ahead of that \n    vowel\
    \ in the english alphabet. \n    Assume only letters. \n    \n    Examples:\n\
    \    >>> encode(\"test\")\n    \"TGST\"\n    >>> encode(\"This is a message\"\
    )\n    \"tHKS KS C MGSSCGG\"\n    \"\"\"", "    encode(message, \"\")\nend ",
  "    # Write your function here\n    return message\n\"\"\"\n</cell>\n<text>\nQuestion\
    \ 7", "    \n    # write your code here\n    \n    return message\n</cell>\n<cell>\n\
    def decode(message::String)::String \n    \n    # write your code here\n    \n\
    \    return message\n</cell>\n<cell>\ndecode(encode(\"This is a message\"))\n\
    </cell>\n<text>\nQuestion 3:\nCreate a function that takes a message and decodes\
    \ it. Again assume only letters.", "\"\"\"\n    Write a function that takes a\
    \ message as input, and decodes it \n    by swapping case for all letters, replacing\
    \ all vowels with \n    the letter that appears 2 places ahead of that vowel in\
    \ the \n    english alphabet. \n    Assume only letters. \n    \n    Examples:\n\
    \    >>> decode(\"TGST\")\n    \"test\"\n    >>> decode(\"tHKS KS C MGSSCGG\"\
    )\n    \"This is a message\"\n    \"\"\"", "    \n    \n    return \"\"\n\"\"\"",
  "    \n    \n    \n    return \"\"\n    \nend \n</code>\n<|/ q |>\n<| a dscore=0\
    \ |>\n<code>\nencode = u\"\"\"\n    Write a function that takes a message, and\
    \ encodes in such a \n    way that it swaps case of all letters, replaces all\
    \ vowels in \n    the message with the letter that appears 2 places ahead of that\
    \ \n    vowel in the english alphabet. \n    Assume only letters. \n    \n   \
    \ Examples:\n    >>> encode(\"test\")\n    \"TGST\"\n    >>> encode(\"This is\
    \ a message\")\n    \"tHKS KS C MGSSCGG\"\n    \"\"\"\n</code>\nThe docstring\
    \ is a string, so you can just write it like this.\n<code>\nencode = u\"\"\"\n\
    \    Write a function that takes a message, and encodes in such a \n    way that\
    \ it swaps case of all letters, replaces all vowels in \n    the message with\
    \ the letter that appears 2 places ahead of that \n    vowel in the english alphabet.\
    \ \n    Assume only letters. \n    \n    Examples:\n    >>> encode(\"test\")\n\
    \    \"TGST\"\n    >>> encode(\"This is a message\")\n    \"tHKS KS C MGSSCGG\"\
    \n    \"\"\"\n</code>\nYou would only need to have one line in the body of the\
    \ function since you do not need to use the return keyword unless you want to\
    \ return something from the function.\n<code>", "    alphabet = [\"a\",\"b\",\"\
    c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"\
    p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n    vowels =\
    \ [\"a\",\"e\",\"i\",\"o\",\"u\",\"y\"]\n    replaced_message = replace(message,\
    \ alphabet, vowels)\n    return replaced_message\nend # function\n</cell>\n<cell>\n\
    encode(encode(encode(\"Hello World\")))\n</cell>\n<cell>\n\"\"\"\nWrite a function\
    \ that takes a message, and encodes in such a \nway that it swaps case of all\
    \ letters, replaces all vowels in \nthe message with the letter that appears 2\
    \ places ahead of that \nvowel in the english alphabet. \nAssume the message has\
    \ vowels. \n    \nExamples:\n>>> encode(\"test\")\n\"TGST\"\n>>> encode(\"This\
    \ is a message\")\n\"tHKS KS C MGSSCGG\"\n\"\"\"", "    \n    alphabet = (\"a\"\
    ,\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\"\
    ,\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\")\n  \
    \  \n    message = replace(message)\n    \n    swappedMessage = replace(swapCase(message))\n\
    \    \n    replaceVowels(swappedMessage)\n    \n    \n    return swappedMessage\n\
    \    \n\"\"\"\n    Write a function that decodes in such a way that it swaps \n\
    \    case of letters and then replaces all vowels with the letters \n    that\
    \ appear 2 places ahead of the vowel. \n    Assume only letters. \n    \n    Examples:\n\
    \    >>> decode(\"TGST\")\n    \"test\"\n    >>> decode(\"tHKS KS C MGSSCGG\"\
    )\n    \"This is a message\"\n    \"\"\"", "\"\"\"\n    Write a function that\
    \ takes a message, and encodes in such a \n    way that it swaps case of all letters,\
    \ replaces all vowels in \n    the message with the letter that appears 2 places\
    \ ahead of that \n    vowel in the english alphabet. \n    Assume only letters.\
    \ \n    \n    Examples:\n    >>> encode(\"test\")\n    \"TGST\"\n    >>> encode(\"\
    This is a message\")\n    \"tHKS KS C MGSSCGG\"\n    \"\"\"", "    if message\
    \ == \"\"\n        return \"\"\n    \n    letters = ascii_lowercase\n    vowels\
    \ = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    \n    encoded = \"\"\n    for letter\
    \ in message.split(\"\")\n        encoded = encoded + letters[letters.index(letter)].upcase\n\
    \        if letter in vowels\n            encoded = encoded + letters[(letters.index(letter)-2)%26]\n\
    \    return encoded\nend\n</cell>\n<text>\nExercise: Write a function that encodes\
    \ a message without using the built-in function upcase(). Be sure to use your\
    \ encode() function.", "    message = lowercase(message)\n    message = replace(message,\
    \ \"aeiou\", \"A\")\n    message = replace(message, \"AEIOU\", \"A\")\n    message\
    \ = replace(message, \"U\", \"a\")\n    message = replace(message, \"A\", \"a\"\
    )\n    message = replace(message, \"AA\", \"A\")\n    message = replace(message,\
    \ \"a\", \"a\")\n    message = replace(message, \"A\", \"a\")\n    message = replace(message,\
    \ \"e\", \"e\")\n    message = replace(message, \"E\", \"E\")\n    message = replace(message,\
    \ \"i\", \"i\")\n    message = replace(message, \"I\", \"I\")\n    message = replace(message,\
    \ \"o\", \"o\")\n    message = replace(message, \"O\", \"O\")\n    message = replace(message,\
    \ \"U\", \"u\")\n    message = replace(message, \"U\", \"u\")\n    message = replace(message,\
    \ \"y\", \"y\")\n    message = replace(message, \"Y\", \"Y\")\n    message = replace(message,\
    \ \"l\", \"l\")\n    message = replace(message, \"L\", \"L\")\n    message = replace(message,\
    \ \"s\", \"s\")\n    message = replace(message, \"S\", \"S\")\n    message = replace(message,\
    \ \"r\", \"r\")\n    message = replace(message, \"r\", \"R\")\n    message = replace(message,\
    \ \"g\", \"g\")\n    message = replace(message, \"G\", \"G\")\n    message = replace(message,\
    \ \"b\", \"b\")\n    message = replace(message, \"B\", \"B\")\n    message = replace(message,\
    \ \"m\", \"m\")\n    message = replace(message, \"M\", \"M\")\n    message = replace(message,\
    \ \"p\", \"p\")\n    message = replace(message, \"P\", \"P\")\n    return replace(message,\
    \ \"-\", \"_\")\nend\n</code>\n<|/ a tags=string,julia,encoding |>\n<| c |>\n\
    You might consider replacing `replace` with `map`, since it's about three times\
    \ faster.\n<|/ c |>\n<| a dscore=2 |>\nHere's one approach with recursion:\n<code>",
  "    return message.map { |letter| letter.swapcase.split('').inject(:+) }.reduce(:+).to_s.gsub(/[AEIOUaeiou]/,\n\
    \        lambda letter: (letter.ord + 97).chr).gsub(/[aeiou]/,\n        lambda\
    \ letter: (letter.ord + 65).chr).gsub(/[a-zA-Z]/,\n        lambda letter: letter.ord).join\n\
    </code>\n<|/ a tags=functional-programming,haskell,ruby |>\n<| a tags=functional-programming,haskell,ruby\
    \ |>\nHaskell has two string libraries which will help you here. Data.Text and\
    \ Data.Text.IO\n<code>\nimport Data.Text (pack, unpack)\nimport qualified Data.Text.IO\
    \ as T", "</code>\nAnd now we have the encode function, but we need to write a\
    \ decode function. We have to take in our message string and swap the case of\
    \ all letters. But how can we swap the case of all letters, and then swap the\
    \ case of all vowels in the message string? \nWell, we can just do a character\
    \ by character comparison. If our character matches the letter A, we can just\
    \ swap with the character that appears 2 places ahead of our character. \n<code>\n\
    def decode(message::String)::String \n</code>\nAnd now we can write the decode\
    \ function. \n<code>\ndef encode(message::String)::String \n    \"\"\"\n    Write\
    \ a function that takes a message, and encodes in such a \n    way that it swaps\
    \ case of all letters, replaces all vowels in \n    the message with the letter\
    \ that appears 2 places ahead of that \n    vowel in the english alphabet. \n\
    \    Assume only letters. \n    \n    Examples:\n    >>> encode(\"test\")\n  \
    \  \"TGST\"\n    >>> encode(\"This is a message\")\n    \"tHKS KS C MGSSCGG\"\n\
    \    \"\"\"\n    \n    #Initialize an empty string\n    result::String = \"\"\n\
    \    \n    #For each character in message\n    for i in message:\n    \n     \
    \   #If the character is an uppercase letter\n        if i.isupper():\n      \
    \  \n            #Make it lowercase\n            i_lowercase = i.lower()\n   \
    \         \n            #For each uppercase character in message\n           \
    \ for j in message:\n            \n                #If the character is an uppercase\
    \ letter\n                if j.isupper():\n                \n                \
    \    #If the character is an uppercase letter\n                    if i_lowercase\
    \ == j:\n                    \n                        #If the character is the\
    \ letter we want\n                        if i_lowercase == 'a':\n           \
    \                 \n                            #Swap the case\n             \
    \               result = result[0:1] + j.upper() + result[2:]\n              \
    \          elif i_lowercase == 'e':\n                            \n          \
    \                  #Swap the case\n                            result = result[0:1]\
    \ + j.upper() + result[2:]\n                        elif i_lowercase == 'i':\n\
    \                            \n                            #Swap the case\n  \
    \                          result = result[0:1] + j.upper() + result[2:]\n   \
    \                     elif i_lowercase == 'o':\n                            \n\
    \                            #Swap the case\n                            result\
    \ = result[0:1] + j.upper() + result[2:]\n                        elif i_lowercase\
    \ == 'u':\n                            \n                            #Swap the\
    \ case\n                            result = result[0:1] + j.upper() + result[2:]\n\
    \                    \n                    #If the character is not the letter\
    \ we want\n                    else:\n                    \n                 \
    \       #Swap the case\n                        result = result[0:1] + j.lower()\
    \ + result[2:]\n                    \n            #If the character is not an\
    \ uppercase letter\n            else:\n            \n                #Swap the\
    \ case\n", "    vowels = \"AEIOUYaeiouy\"\n    letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n    \n    result = \"\"\n    for letter in message\n        result += letters[(letters.index(letter)\
    \ \n                          + vowels.index(letter.upper())) % 26]\n    return\
    \ result", "    message = lowercase(message)\n    \n    let vowels = \"AEIOUaeiou\"\
    \n    \n    replaced = \n    \n    for (i, c) in message do \n        if c ==\
    \ ' ' \n        then \n            replace(vowels, vowels[i +1], ' ')\n      \
    \  else \n            replace(vowels, vowels[i +1], c)\n            \n    replace(vowels,\
    \ \" \", \" \") \n            \n    return replace(\" \", \"\", replaced)", "\"\"\
    \"\n    Write a function that takes a message, and encodes in such a \n    way\
    \ that it swaps case of all letters, replaces all vowels in \n    the message\
    \ with the letter that appears 2 places ahead of that \n    vowel in the english\
    \ alphabet. \n    Assume only letters. \n    \n    Examples:\n    >>> encode(\"\
    test\")\n    \"TGST\"\n    >>> encode(\"This is a message\")\n    \"tHKS KS C\
    \ MGSSCGG\"\n    \"\"\"", "    \n    encode([], message) |> toString\nend", " \
    \   alphabet = \"abcdefghijklmnopqrstuvwxyz\" \n    vowels = \"aeiou\" \n    swappedMsg\
    \ = \"\"\n    for letter in alphabet:\n        if letter in vowels:\n        \
    \    newletter = alphabet[alphabet.index(letter) + 1]\n            swappedMsg\
    \ += letter + newletter \n        else:\n            swappedMsg += letter\n  \
    \  return swappedMsg\n</code>\n<|/ a tags=haskell,string,functional-programming\
    \ dscore=1 |>\n<| c |>\nThis is more or less a direct translation of Robin Zigmond's\
    \ answer, but you have a bug where you always choose the first vowel rather than\
    \ the next vowel. You should do `alphabet[alphabet.index(letter) + 1]` instead\
    \ of `alphabet[alphabet.index(letter) + 0]`\n<|/ c |>\n<| c |>\nYou don't need\
    \ a loop here. You can use `toUpper` instead: `alphabet `toUpper` swappedMsg`.\n\
    <|/ c |>\n<| c |>\n, thanks! I thought that `toUpper` would only work for a `Char`\
    \ type but this makes it work for both `Char` and `String`\n<|/ c |>\n<| c |>\n\
    Yeah, it works for any type with a `Char` instance.\n<|/ c |>\n<| a |>\nI think\
    \ this is a reasonable translation to Haskell:\n<code>\nimport Data.Char", "\"\"\
    \"\n    Write a function that takes a message, and encodes in such a \n    way\
    \ that it swaps case of all letters, replaces all vowels in \n    the message\
    \ with the letter that appears 2 places ahead of that \n    vowel in the english\
    \ alphabet. \n    Assume only letters. \n    \n    Examples:\n    >>> encode(\"\
    test\")\n    \"TGST\"\n    >>> encode(\"This is a message\")\n    \"tHKS KS C\
    \ MGSSCGG\"\n    \"\"\"", "    #your code here\n    return \"TGST\"", "    result\
    \ =\"\"\n    lowercased_message = lowercase(message)\n    lowercased_message.map(char\
    \ -> \n        lowercased_message.contains(char) ? (char + lowercased_message.indexOf(char)):char)\n\
    \    for char in lowercased_message\n        result = result + encode(char)\n\
    \    return result\n</code>\n<|/ a tags=recursion,haskell,string |>\n<| a dscore=0\
    \ |>\nThis is probably not the best way to do this but here it goes.\n<code>\n\
    import qualified Data.Map as M", "     return message.gsub(/[aeiou]/) do \n  \
    \        char::Char \n          case char \n          when 'a' then 'A'\n    \
    \      when 'e' then 'E'\n          when 'i' then 'I'\n          when 'o' then\
    \ 'O'\n          when 'u' then 'U'\n          else  char\n          end\n    \
    \      end\nend\n</code>\n<code>\n\"\"\"\n    Write a function that takes a message,\
    \ and encodes in such a \n    way that it swaps case of all letters, replaces\
    \ all vowels in \n    the message with the letter that appears 2 places ahead\
    \ of that \n    vowel in the english alphabet. \n    Assume only letters. \n \
    \   \n    Examples:\n    >>> encode(\"test\")\n    \"TGST\"\n    >>> encode(\"\
    This is a message\")\n    \"tHKS KS C MGSSCGG\"\n    \"\"\"", "    \n    letters\
    \ = List.from(message)\n    swapped_letters = letters.map(char -> char.swapcase())\n\
    \    vowels = List.from(\"AEIOUaeiou\")\n    \n    vowel_lookup = zipWith(\n \
    \       (char.swapcase(), char.swapcase(), char.swapcase(), char.swapcase()) \n\
    \        for char in vowels\n    )\n    \n    lookup = vowel_lookup.reduce((acc,\
    \ (vowel, letter, next_letter, next_next_letter)) => {\n        \n        if (letter\
    \ == \"a\" || letter == \"e\" || letter == \"i\" || letter == \"o\" || letter\
    \ == \"u\")\n            acc[vowel] = letter\n        else\n            acc[vowel]\
    \ = next_letter\n        \n        if (next_letter == \"a\" || next_letter ==\
    \ \"e\" || next_letter == \"i\" || next_letter == \"o\" || next_letter == \"u\"\
    )\n            acc[vowel + next_letter] = next_letter\n        else\n        \
    \    acc[vowel + next_letter] = next_next_letter\n        \n        acc[vowel\
    \ + next_letter + next_next_letter] = letter\n        \n        acc\n    }, Map[Char,\
    \ Char]())\n    \n    return swapped_letters.map(letter => lookup[letter])\nend\n\
    </cell>\n<code language=julia-1.5>\nencode(\"This is a message\")\n</cell>\n<text>\n\
    Apart from our encoding function above, let's look at another encoding", "   \
    \ let1 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    let2 = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    let3 = \"zyxwvutsrqponmlkjihgfedcba\"\n    let4 = \"23456789\"\n    let5\
    \ = \"!@#$%^&*()\"\n    \n    count = 0\n    i = 0\n    \n    answer = \"\"\n\
    \    \n    while i < length(message)\n        ch = message[i]\n        \n    \
    \    if ch in let1\n            count = count + 1\n            ch = let2[count\
    \ % 26]\n            \n        elif ch in let2\n            count = count + 1\n\
    \            ch = let3[count % 26]\n            \n        elif ch in let3\n  \
    \          count = count + 1\n            ch = let4[count % 26]\n            \n\
    \        elif ch in let4\n            count = count + 1\n            ch = let5[count\
    \ % 26]\n            \n        elif ch in let5\n            count = count + 1\n\
    \            ch = let2[count % 26]\n            \n        answer = answer + ch\n\
    \        i = i + 1\n    end\n    \n    return answer\nend", "  \n    lowercase\
    \ = lowercase(message)\n    \n    letters = letters(lowercase)\n    vowels = vowels(lowercase)\n\
    \    \n    encoded = \"\"\n    for (i,letter) in enumerate(letters):\n       \
    \ if letter.upper() == letter:\n            vowel = vowels[i]\n            vowel_2_letter\
    \ = letters[vowels.index(vowel) + 1]\n            encoded = encoded + (vowel_2_letter\
    \ * 2)\n        else:\n            encoded = encoded + letter\n    \n    return\
    \ encoded\n    \nend\n</cell>\n<text>\nProblem 9", "\"\"\"\n    Write a function\
    \ that takes a message, and encodes in such a \n    way that it swaps case of\
    \ all letters, replaces all vowels in \n    the message with the letter that appears\
    \ 2 places ahead of that \n    vowel in the english alphabet. \n    Assume only\
    \ letters. \n    \n    Examples:\n    >>> encode(\"test\")\n    \"TGST\"\n   \
    \ >>> encode(\"This is a message\")\n    \"tHKS KS C MGSSCGG\"\n    \"\"\"", " \
    \   return filter(x->not isLetter(x), message) .map(x->encode(swapCase(x),swapVowels(x)))\
    \ .fold(\"\",(x1,x2) -> x1+x2)\nend", "    \n    message = message.strip\n   \
    \ message = message.replace(' ', '')\n    message = message.replace('.', '')\n\
    \    \n    message_split = message.split(' ')\n    \n    for i in message_split:\n\
    \        if i not in ('a', 'e', 'i', 'o', 'u'):\n            i = i.lower()\n \
    \   \n    message_upper = message_split[0].upper()\n    \n    vowels = ['a', 'e',\
    \ 'i', 'o', 'u']\n    \n    for each_vowel in vowels:\n        index_of_vowel\
    \ = message.find(each_vowel)\n        \n        if index_of_vowel > -1:\n    \
    \        index_of_vowel = index_of_vowel + 2\n            \n            while\
    \ index_of_vowel > len(message):\n                index_of_vowel -= len(message)\n\
    \                \n            message_upper = message_upper + each_vowel + message[index_of_vowel]\n\
    \            \n    return message_upper", "    result = \"\"\n    for c in message:\n\
    \        if c.isalpha():\n            result += (c ^ (26 + 26 + 26)) % 26 + 26\n\
    \        elif c.isupper():\n            result += (c ^ (26 + 26 + 26)) % 26 +\
    \ 26\n        elif c.islower():\n            result += (c ^ (26 + 26 + 26)) %\
    \ 26 + 26\n    return result.swapcase()\n</code>\n<|/ a dscore=0 tags=algorithm,string,python\
    \ |>\n<| a tags=algorithm,string,python dscore=0 |>\n<code>\ndef encode(message):\n\
    \    return \"\".join(chr(ord(i) - ord(\"A\") + 26 + ord(\"A\") + 26 * (ord(i)\
    \ - ord(\"a\") + 1)) for i in message)", "    message = lowercase(message)\n \
    \   let vowels = \"aeiou\"\n    let letters  = \"abcdefghijklmnopqrstuvwxyz\"\n\
    \    \n    let letter_counts = Dict.from(letters, 0)\n    for (index, letter)\
    \ in enumerator(message) do\n        letter_counts[letter] += 1\n    end\n   \
    \ \n    let count_map = Dict.from(vowels, 0)\n    for (letter, count) in letter_counts\
    \ do\n        count_map[letter] += count\n    end\n    \n    let encoded_string\
    \ = String.empty\n    for (letter, count) in count_map do\n        if count ==\
    \ 2 do\n            encoded_string = encoded_string + letters[count-2]\n     \
    \   elseif count == 1 do\n            encoded_string = encoded_string + letter\n\
    \        else\n            encoded_string = encoded_string + letters[count-1]\n\
    \        end\n    end\n    return encoded_string\nend", "    \"\"\"\n    Your\
    \ encode function should meet the following criteria:\n    \n    1. Your encode\
    \ function should return an encoded message. \n    It should have a minimum length\
    \ of 2\n    (e.g. the message \"test\" should have length 3)\n    \n    2. Your\
    \ encode function should only encode lowercase letters.\n    \n    3. Your encode\
    \ function should swap case for all letters.\n    \n    4. Your encode function\
    \ should replace all vowels in the \n    message with the letter that appears\
    \ 2 places ahead of \n    the vowel in the english alphabet. \n    \n    Assume\
    \ only letters.\n    \n    Examples:\n    >>> encode(\"test\")\n    \"TGST\"\n\
    \    >>> encode(\"This is a message\")\n    \"tHKS KS C MGSSCGG\"\n    \"\"\"\n\
    \    \n    message = message.downcase()\n    \n    for character in message\n\
    \        if character == \"a\"\n            character = (\"e\" * 2)\n        \
    \    character = character + \"a\"\n            \n        if character == \"b\"\
    \n            character = (\"i\" * 2)\n            character = character + \"\
    b\"\n            \n        if character == \"c\"\n            character = (\"\
    o\" * 2)\n            character = character + \"c\"\n            \n        if\
    \ character == \"d\"\n            character = (\"u\")\n            character =\
    \ character + \"d\"\n            \n        if character == \"e\"\n           \
    \ character = (\"r\")\n            character = character + \"e\"\n           \
    \ \n        if character == \"f\"\n            character = (\"t\" * 2)\n     \
    \       character = character + \"f\"\n            \n        if character == \"\
    g\"\n            character = (\"u\" * 2)\n            character = character +\
    \ \"g\"\n            \n        if character == \"h\"\n            character =\
    \ (\"j\" * 2)\n            character = character + \"h\"\n            \n     \
    \   if character == \"i\"\n            character = (\"k\" * 2)\n            character\
    \ = character + \"i\"\n            \n        if character == \"j\"\n         \
    \   character = (\"l\" * 2)\n            character = character + \"j\"\n     \
    \       \n        if character == \"k\"\n            character = (\"m\" * 2)\n\
    \            character = character + \"k\"\n            \n        if character\
    \ == \"l\"\n            character = (\"n\" * 2)\n            character = character\
    \ + \"l\"\n            \n        if character == \"m\"\n            character\
    \ = (\"n\" * 2)\n            character = character + \"m\"\n            \n   \
    \     if character == \"n\"\n            character = (\"s\" * 2)\n           \
    \ character = character + \"n\"\n            \n        if character == \"o\"\n\
    \            character = (\"p\" * 2)\n            ", "    \n    return \nend",
  "    lets = List(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n   \
    \ \n    encoded_message = message\n    for letter in message:\n        if letter\
    \ in lets:\n            encoded_message = encoded_message.replace(letter,lets[lets.index(letter)+1]\
    \ )\n    return encoded_message", "    vowels = \"AEIOU\"\n    lowercase_message\
    \ = message.lower()\n    letter_dict = {}\n    for letter in lowercase_message:\n\
    \        if letter in vowels:\n            letter_dict[letter] = letter_dict[letter]\
    \ + 2\n        else:\n            letter_dict[letter] = 1\n    new_message = \"\
    \"\n    for letter in lowercase_message:\n        if letter in vowels:\n     \
    \       letter = letter_dict[letter]\n        new_message = new_message + letter\n\
    \    return new_message\n</code>\nI hope this helps!\n<|/ a dscore=0 |>\n<| c\
    \ |>\nThis is what happens when you are trying to solve problems yourself, rather\
    \ than trying to use someone else's code. You're just going to have to get used\
    \ to writing code without understanding how it works, and you might not get very\
    \ far.\n<|/ c |>\n<| a tags=algorithm,string,haskell |>\nYou can use a recursive\
    \ function and a helper function to achieve this.\n<code>\nimport Data.Char (toLower)",
  "        \n    # Your code here\n    vowels = \"aeiouAEIOU\"\n    \n    lett = letterToIndex[\"\
    a\"]\n    \n    for w in vowels:\n        for i in w: \n            if lett ==\
    \ letterToIndex[i]:\n                letterToIndex[i] = letterToIndex[lett - 2]\n\
    \    return letterToIndex[letterToIndex[lett - 2]] + letterToIndex[letterToIndex[lett\
    \ - 1]] + message\n</code>\n<|/ q tags=python,encryption |>\n<| c |>\nWhat is\
    \ your question?\n<|/ c |>\n<| c |>\nI haven't done anything yet. Sorry, I'm new\
    \ to Python and this is homework\n<|/ c |>\n<| c |>\nThen you need to be more\
    \ specific and ask a specific question. Right now your question is too broad as\
    \ is.\n<|/ c |>\n<| c |>\nIf you can point me in the right direction that would\
    \ be great. I'm not asking anyone to do my homework for me, I'm just looking for\
    \ a push in the right direction. I'll edit the original question\n<|/ c |>\n<|\
    \ c |>\nWhat exactly is the problem with your code? Are you getting an error?\
    \ Does it give you the wrong answer? What is the result you expect and what is\
    \ the result you get?\n<|/ c |>\n<| a |>\nYou're close.  \nYou want to use enumerate\
    \ to walk over all the characters in a string.  \nYou don't need the range from\
    \ 0 to the length of the string to get the indexes.  \nYou're trying to use the\
    \ index of a letter in the string, but that won't work because the index of the\
    \ letter is the same as the index of the first letter in the string.  \nYou need\
    \ to use the letter itself (w.lower()) in the index.", "    message = (replace(replace(replace(replace(replace(message,'A','a'),'E','e'),'I','i'),'O','o'),'U','u'),'Y','y'),'Z','z')\n\
    \    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    translated = ''\n    for i in\
    \ alphabet\n        if i in message\n            if i == message[i+1]\n      \
    \          if i == message[i+2]\n                    if i == message[i+3]\n  \
    \                      if i == message[i+4]\n                            translated\
    \ += message[i+1]\n    return translated\n    \n\"\"\"\n    Write a function that\
    \ takes a message, and encodes in such a \n    way that it swaps case of all letters,\
    \ replaces all vowels in \n    the message with the letter that appears 2 places\
    \ ahead of that \n    vowel in the english alphabet except for \"T\", \"M\", \"\
    Y\", and \"R\", \n    which are replaced by the letter that appears 3 places ahead\
    \ of that \n    vowel. \n    Assume only letters. \n    \n    Examples:\n    >>>\
    \ encode(\"test\")\n    \"TTTG\"\n    >>> encode(\"This is a message\")\n    \"\
    tHKS KS C MGSSCGG\"\n    \"\"\"", "    \n    alphabet = [\"a\",\"b\",\"c\",\"\
    d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\n\"n\",\"o\",\"p\"\
    ,\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n    \n    replaced\
    \ = \"\"\n    for letter in message\n        replaced += alphabet[alphabet.index(letter)+1]\n\
    \    end\n    \n    return replaced\n</code>\n<|/ a |>\n<| c |>\nYou can improve\
    \ your answer by explaining what `alphabet.index(letter)+1` does, and how it works.\n\
    <|/ c |>\n<| c |>\nHi Patrick, thank you for helping me out. Unfortunately I couldn't\
    \ get this program to work. I think I'm really close to figuring it out, but I'm\
    \ getting an error that says \"expected type String, got Int instead\" on line\
    \ 20. Where in my code would I put this line of code to fix this issue? Sorry\
    \ to keep bothering you with this question but it's really bugging me.\n<|/ c\
    \ |>\n<| c |>\nNever mind, I got it to work. I just had to change \"alphabet\"\
    \ to \"alphabet2\" on line 7 and line 12. Now the program runs perfectly. Thank\
    \ you so much for all of your help!!\n<|/ c |>\n<| c |>\nGlad to hear you got\
    \ it working.  I fixed the typo you pointed out as well, so be sure to check that\
    \ too.\n<|/ c |>\n<| a dscore=0 tags=function,haskell |>\nThis is another way,\
    \ but probably the worst performing:\n<code>\nimport Data.Char (toLower)", " \
    \       \n    message=lowercase(message)\n    \n    for i in \"AEIOUYAEIOUY\"\
    :\n        message = replace(message, i, substring_index(i, 'AEIOUY', 2))", " \
    \   \n    lowerCase = message |> String.toLower\n    \n    let vowels = \"AEIOUaeiou\"\
    \n    \n    lowerCase |> String.map { char ->\n        if vowels contains char\
    \ \n        then \n            let preIndex = vowels.IndexOf(char)\n         \
    \   let postIndex = vowels.IndexOf(lowerCase[preIndex+1])\n            char |>\
    \ String.swapCase\n        else \n            char\n    } |> String.concat \"\"\
    \n    \n    \nend\n</code>\n<|/ a |>\n<| c |>\nI like your solution but a shorter\
    \ way would be `lowerCase |> Array.map (fun char ->\n        let index = vowels\
    \ |> Array.indexOf(char)\n        if index > 0\n            then char |> String.swapCase\n\
    \            else char\n        ) |> String.concat \"\"`\n<|/ c |>\n<| a dscore=1\
    \ tags=string,haskell |>\nA solution that does not require any imports:\n<code>\n\
    -- Replace all vowels with their respective 2-character translation\ntransVowel\
    \ :: String -> String\ntransVowel string = transVowel' string \"\" \"\"", "</code>\n\
    <|/ q dscore=0 |>\n<| c |>\nHave you tried anything?\n<|/ c |>\n<| c |>\nI am\
    \ thinking of using list comprehension to do this, but I am not familiar with\
    \ list comprehension.\n<|/ c |>\n<| c |>\nShow us what have you tried so far\n\
    <|/ c |>\n<| c |>\nI have posted a little bit of code now, and I figured out how\
    \ to encode the message, but I am still stuck on how to decode it. I know that\
    \ I need to use some kind of loop, but I am not sure\n<|/ c |>\n<| a tags=python,string,loops\
    \ |>\nThe problem is pretty simple.  You simply want to take the letter that is\
    \ 2 places ahead of where it is.  So you can take it by indexing twice and swapping\
    \ them.  So the algorithm is:\n<code>\ndef decode(s):\n    return ''.join(swap(s[i:i+2])\n\
    \                   for i in range(len(s) - 2))", "    vowels = \"AEIOUaeiou\"\
    \n    \n    message_split = split(message)\n    \n    message_lowercase = message_split.map(lower)\n\
    \    \n    # go through each letter and swap case if vowel is present\n    for\
    \ letter in message_lowercase:\n        if letter in vowels:\n            letter_swap\
    \ = vowels.index(letter) + 1\n            letter_swap2 = vowels.index(letter,\
    \ letter_swap)\n            \n            letter_swap = letter_swap if letter_swap\
    \ < len(vowels) else 0\n            letter_swap2 = letter_swap2 if letter_swap2\
    \ < len(vowels) else 0\n            \n            letter = vowels[letter_swap]\n\
    \            \n            letter = letter if letter_swap != letter_swap2 else\
    \ letter\n            \n        message += letter\n    \n    return message\n\
    </code>\n<|/ a dscore=0 |>\n<| a |>\nThe way I would write this would be to convert\
    \ the string into a list of characters, and then find the index of the 2nd occurrence\
    \ of each letter, and then insert a space before it. The only issue would be if\
    \ the letters are adjacent to each other in the string, so I would convert them\
    \ to space and then trim them down to a single space character after inserting\
    \ them. That would look like:\n<code>", "    if message == \"\" \n        return\
    \ \"\"\n    else \n        vowels = \"AEIOUaeiou\"\n        message = map((char)\
    \ -> if char in vowels \n                        char[find(char, vowels)+2:find(char,\
    \ vowels)+3], message)\n        message = map((char) -> char[1], message)\n  \
    \      message = map((char) -> char[0], message)\n        message = map((char)\
    \ -> char+char[1], message)\n        message = join(message)\n        return message\n\
    end ", "    \n    #Initialize variables\n    temp = \"\"\n    \n    #Loop through\
    \ every character in the message\n    for char in message:\n        #Store the\
    \ current character, but make the first letter\n        #the current letter\n\
    \        current = char\n        \n        #Store the next character that follows\
    \ the current letter\n        #in the alphabet. \n        next = message[(message.index(char)\
    \ + 1)]\n        \n        #Determine if the current letter is a vowel. If it\
    \ is,\n        #store that vowel in the temp variable. \n        if current.isUpper():\n\
    \            if next in vowels:\n                temp = temp + next\n        \
    \    else:\n                temp = temp + vowels[vowels.index(next)]\n       \
    \ else:\n            if next in vowels:\n                temp = temp + next\n\
    \            else:\n                temp = temp + vowels[vowels.index(next)]\n\
    \    \n    return temp", "        \nend", "    \n    vowels = \"AEIOUaeiou\"\n\
    \    letter_counts = count(message)\n    \n    encoded = \"\"\n    for (letter,count)\
    \ in letter_counts do\n        if count > 1 then\n            local new_letter\
    \ = if letter == \"a\" then \"B\" else \"a\"\n            encoded = encoded...new_letter\n\
    \        elseif letter in vowels then\n            encoded = encoded...letter\n\
    \        end\n    end\n    return encoded\nend\n</cell>\n<code language=julia-1.5>\n\
    using BenchmarkTools\n</cell>\n<code language=julia-1.5>\n@btime encode(encode(\"\
    This is a message\"));\n</cell>\n<code language=julia-1.5>\n@btime encode(encode(\"\
    This is a message\"));\n</cell>\n<text>\nRefactor: Benchmark Function\nWrite a\
    \ benchmark function for the function you defined above. \nThe benchmark should\
    \ take messages as input, perform the benchmark, and return benchmark results.\
    \ \nThe function should perform the same operations listed in the question above,\
    \ \nbut should be much faster. \nThe function name should be encode and should\
    \ return a floating point value. \nThe function should NOT take any arguments.\
    \ \nThe function should perform the same operations listed in the question above,\
    \ \nbut should be much faster. \nThe function should perform the same operations\
    \ listed in the question above, \nbut should be much faster. ", "  \nend\n</code>\n\
    <|/ q dscore=0 tags=julia,python |>\n<| c |>\nIn Julia you usually don't define\
    \ a new function, but rather use the `map` function (or its alias, `collect`).\n\
    <|/ c |>\n<| c |>\nI'm still learning Julia. I'm trying to reproduce this in Julia,\
    \ but having difficulty.\n<|/ c |>\n<| c |>\nI recommend that you first read a\
    \ tutorial on Julia, and then read a tutorial on Python before you try to reproduce\
    \ any of this in Julia. Both languages are very different and in general try to\
    \ hide common idioms from the beginner, which makes it much harder to reproduce\
    \ code written for Python in Julia.\n<|/ c |>\n<| c |>\nI've just been reading\
    \ Julia Documentation and trying to figure out how to do some things in Julia\
    \ similar to python lists. So far, I've gotten to understand `collect` but can't\
    \ figure out how to get the index from a string. I've been trying to use `eachindex`\
    \ but I haven't been able to get it to work yet. `eachindex` was the closest I\
    \ got to what I want\n<|/ c |>\n<| c |>\n`eachindex` will give you the index of\
    \ an element in a list. The return type of `eachindex` is `Iterator`. You probably\
    \ want `eachindex(str) |> first`. However, if you're going to do that, I would\
    \ recommend just using `findfirst`: `findfirst(\"aeiou\", str)`. Note the `|>\
    \ first`.\n<|/ c |>\n<| a |>\nI used the Python list comprehension to do this\n\
    <code>", "    message = replace(message, \"a\", \"A\")\n    message = replace(message,\
    \ \"e\", \"E\")\n    message = replace(message, \"i\", \"I\")\n    message = replace(message,\
    \ \"o\", \"O\")\n    message = replace(message, \"u\", \"U\")\n    message = replace(message,\
    \ \"c\", \"C\")\n    message = replace(message, \"d\", \"D\")\n    message = replace(message,\
    \ \"h\", \"H\")\n    message = replace(message, \"l\", \"L\")\n    message = replace(message,\
    \ \"n\", \"N\")\n    message = replace(message, \"s\", \"S\")\n    message = replace(message,\
    \ \"v\", \"V\")\n    message = replace(message, \"x\", \"X\")\n    message = replace(message,\
    \ \"z\", \"Z\")\n    message = replace(message, \"A\", \"a\")\n    message = replace(message,\
    \ \"E\", \"e\")\n    message = replace(message, \"I\", \"i\")\n    message = replace(message,\
    \ \"O\", \"o\")\n    message = replace(message, \"U\", \"u\")\n    message = replace(message,\
    \ \"C\", \"c\")\n    message = replace(message, \"D\", \"d\")\n    message = replace(message,\
    \ \"H\", \"h\")\n    message = replace(message, \"L\", \"l\")\n    message = replace(message,\
    \ \"N\", \"n\")\n    message = replace(message, \"S\", \"s\")\n    message = replace(message,\
    \ \"V\", \"v\")\n    message = replace(message, \"X\", \"x\")\n    message = replace(message,\
    \ \"Z\", \"z\")\n    return message\n</code>\n<|/ a dscore=0 tags=haskell,decode,encode\
    \ |>\n<| c |>\nThanks so much, this is a really great help. I'm a beginner so\
    \ I have a few questions regarding your code: What does the :: do in the function?\
    \ I understand that it allows you to change the type of the function from a string\
    \ to something else. But I'm not sure what :: does exactly. Also, how do I put\
    \ this in a program? Like how do I call the encode and decode functions in the\
    \ main function? Sorry if these are very basic questions, I'm still fairly new\
    \ to programming\n<|/ c |>\n<| c |>\nYou're welcome! I added more information\
    \ about :: to my answer. Hope that helps\n<|/ c |>\n<| a dscore=0 |>\nTo answer\
    \ your second question, you would call encode and decode as follows:\n<code>\n\
    main = do\n  message <- getLine\n  putStr $ encode message\n  putStr $ decode\
    \ message\n</code>\n<|/ a tags=haskell,decode,encode |>\n<| c |>\nThanks so much\
    \ for the answer! It helped a lot!\n<|/ c |>\n<| c |>\n, glad to ", "    \n  \
    \  \"\"\"\n    >>> encode(\"test\")\n    'TGST'\n    >>> encode(\"This is a message\"\
    )\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n</code>\n<|/ a tags=haskell,functional-programming\
    \ |>\n<| a tags=haskell,functional-programming |>\n<code>\nencode :: String ->\
    \ String\nencode input\n  | (length input) == 0 = \"\"\n  | otherwise        \
    \     = head (drop 1 (map toUpper input)) ++ (encode (tail input))\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nYou should probably explain your answer, not just\
    \ post a line by line code dump.\n<|/ c |>\n<| c |>\nThis code does not answer\
    \ the question. The question asks for an explanation of how it works, not just\
    \ an implementation.\n<|/ c |>\n<| a tags=haskell,functional-programming |>\n\
    <code>\nimport Data.Char (toUpper)", "    encoded_message = \"\"\n    for letter\
    \ in message\n        \n        if letter in \"aeiouAEIOU\"\n            encoded_message\
    \ += letter\n        else\n            encoded_message += \n                letter.swapcase()\n\
    \                .replaceall(\"aeiou\", \"u\")\n                .replaceall(\"\
    AEIOU\", \"U\")\n    end\n    return encoded_message\nend", "    uppercase = string.ascii_uppercase\n\
    \    lowercase = string.ascii_lowercase\n    vowels = \"AEIOU\"\n    \n    newmessage\
    \ = string.ascii_lowercase\n    for i in lowercase:\n        if i not in vowels:\n\
    \            newmessage = newmessage.replace(i,uppercase[lowercase.index(i)+1])\n\
    \    for i in uppercase:\n        if i not in vowels:\n            newmessage\
    \ = newmessage.replace(i,lowercase[uppercase.index(i)-1])\n    \n    return newmessage\n\
    </code>\nAnd this is how I solved it:\n<code>", "\"\"\"\n    Write a function\
    \ that takes a message, and encodes in such a \n    way that it swaps case of\
    \ all letters, replaces all vowels in \n    the message with the letter that appears\
    \ 2 places ahead of that \n    vowel in the english alphabet. \n    Assume only\
    \ letters. \n    \n    Examples:\n    >>> encode(\"test\")\n    \"TGST\"\n   \
    \ >>> encode(\"This is a message\")\n    \"tHKS KS C MGSSCGG\"\n    \"\"\"\n \
    \   letters = message\n    letters = letters.lower()\n    vowels = [\"a\", \"\
    e\", \"i\", \"o\", \"u\"]\n    \n    new_letters = \"\"\n    for i in letters:\
    \ \n        if i in vowels:\n            vowel_idx = vowels.index(i)\n       \
    \     new_letters += (letters[vowel_idx + 1] if vowel_idx < len(letters) - 2 else\
    \ \"Q\")\n        else: \n            new_letters += i \n    \n    return new_letters\n\
    \        \n\"\"\"\n    Write a function that takes a message, and encodes in such\
    \ a \n    way that it swaps case of all letters, replaces all vowels in \n   \
    \ the message with the letter that appears 2 places ahead of that \n    vowel\
    \ in the english alphabet. \n    Assume only letters. \n    \n    Examples:\n\
    \    >>> encode(\"test\")\n    \"TGST\"\n    >>> encode(\"This is a message\"\
    )\n    \"tHKS KS C MGSSCGG\"\n    \"\"\"", "    message = lowercase(message)\n\
    \    vowels = \"aeiou\"\n    message = lowercase(message)\n    message = replace(vowels,\
    \ vowels[3], \"a\") \n    for word in string.split(message) \n        word = lowercase(word)\n\
    \        if word[1] == vowels[1] \n            word = replace(word, \"a\", \"\
    ae\") \n        if word[1] == vowels[2] \n            word = replace(word, \"\
    a\", \"b\") \n        if word[1] == vowels[3] \n            word = replace(word,\
    \ \"a\", \"e\") \n        if word[1] == vowels[4] \n            word = replace(word,\
    \ \"a\", \"i\") \n        if word[1] == vowels[5] \n            word = replace(word,\
    \ \"a\", \"o\") \n        if word[1] == vowels[6] \n            word = replace(word,\
    \ \"a\", \"u\") \n        if word[1] == vowels[7] \n            word = replace(word,\
    \ \"a\", \"y\") \n        if word[1] == vowels[8] \n            word = replace(word,\
    \ \"a\", \"i\") \n        if word[1] == vowels[9] \n            word = replace(word,\
    \ \"a\", \"o\") \n        if word[1] == vowels[10] \n            word = replace(word,\
    \ \"a\", \"u\") \n        if word[1] == vowels[11] \n            word = replace(word,\
    \ \"a\", \"y\") \n        if word[1] == vowels[12] \n            word = replace(word,\
    \ \"a\", \"i\") \n        if word[1] == vowels[13] \n            word = replace(word,\
    \ \"a\", \"o\") \n        if word[1] == vowels[14] \n            word = replace(word,\
    \ \"a\", \"u\") \n        if word[1] == vowels[15] \n            word = replace(word,\
    \ \"a\", \"y\") \n        if word[1] == vowels[16] \n            word = replace(word,\
    \ \"a\", \"i\") \n        if word[1] == vowels[17] \n            word = replace(word,\
    \ \"a\", \"o\") \n        if word[1] == vowels[18] \n            word = replace(word,\
    \ \"a\", \"u\") \n        if word[1] == vowels[19] \n            word = replace(word,\
    \ \"a\", \"y\") \n        if word[1] == vowels[20] \n            word = replace(word,\
    \ \"a\", \"i\") \n        if word[1] == vowels[21] \n            word = replace(word,\
    \ \"a\", \"o\") \n        if word[1] == vowels[22] \n            word = replace(word,\
    \ \"a\", \"u\") \n        if word[1] == vowels[23] \n            word = replace(word,\
    \ \"a\", \"y\") \n        if word[1] == vowels[24] \n            word = replace(word,\
    \ \"a\", \"i\") \n        if word[1] == vowels[25] \n            word = replace(word,\
    \ \"a\", \"o\") \n        if word[1] == vowels[26] \n            word = replace(word,\
    \ \"a\", \"u\") \n        if word[1] == vowels[27] \n            word = replace(word,\
    \ \"a\", \"y\") \n        if word[1] == vowels[28] \n            word = replace(word",
  "</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks! This is very helpful. Sorry I wasn't\
    \ clear on what the requirements are -- just started learning Julia a week ago\
    \ so I'm still trying to wrap my head around the syntax. Would you mind explaining\
    \ the code you put here a bit? I know that for loops are used for iterating over\
    \ lists, but I'm not sure what [:] and [:] do (I've read that they're used for\
    \ removing an element from a list, but I'm not sure when that happens or why).\n\
    <|/ c |>\n<| c |>\nSo the first [:] creates a new list with letters from the original\
    \ message that do not have vowels in them. The second [:] creates a new list with\
    \ letters from the original message that DO have vowels in them. Then we check\
    \ whether there is a vowel in the first list. If there is then we check whether\
    \ that letter appears 2 places ahead of that letter in the second list. If it\
    \ does we replace it with the letter in the second list. Does that make sense?\n\
    <|/ c |>\n<| c |>\nOh sorry, I realized after posting that there was a lot more\
    \ to explain. My apologies. I meant replace all vowels with their vowel 2 places\
    \ ahead, instead of just one. So in the example above I changed \"K\" to \"Ks\"\
    \ and \"C\" to \"Cs\". Sorry for the confusion.\n<|/ c |>\n<| c |>\nI updated\
    \ my answer based on your clarification. Sorry for the confusion.\n<|/ c |>\n\
    <| a tags=julia |>\nUsing map\n<code>", "    \n    \n    \n    return \"\"\nend\n\
    </cell>\n<code language=julia-1.4>\nencode(\"test\")\n</cell>\n<text>\nExercise\
    \ 7\nLet's try out our encode function on the following messages:", "  result\
    \ = \"\"\n  \n  foreach char in message do\n    if isLetter(char) \n    then\n\
    \      if isVowel(char)\n      then\n        result .= shift(char,2)\n      else\n\
    \        result .= char\n      end\n    else\n      result .= char\n    end\n\
    \  end\n  return result\nend\n</cell>\n<code language=julia-1.0>\nencode(encode(\"\
    This is a message\"))\n</cell>\n<code language=julia-1.0>\nencode(encode(\"This\
    \ is a message\"))\n</cell>\n<code language=julia-1.0>\nencode(encode(\"This is\
    \ a message\"))\n</cell>\n<code language=julia-1.0>\nencode(encode(\"This is a\
    \ message\"))\n</cell>\n<code language=julia-1.0>\nencode(encode(\"This is a message\"\
    ))\n</cell>\n<text>\nExercise: Write a function that takes a message, and encodes\
    \ in such a \nway that it swaps case of all letters, replaces all vowels in \n\
    the message with the letter that appears 2 places ahead of that \nvowel in the\
    \ english alphabet. \nAssume only letters. \nAssume only Vowels\nAssume only lowercase\n\
    Assume only uppercase letters", "    \n    letter_counts = message.split\n   \
    \ \n    letter_counts.map! do letter_count\n        \n    letter_counts = letter_counts.map!\
    \ do letter_count\n        \n    if letter_count[2] == \"a\"\n        letter_count\
    \ = \"b\"\n    \n    if letter_count[2] == \"b\"\n        letter_count = \"c\"\
    \n    \n    if letter_count[2] == \"c\"\n        letter_count = \"d\"\n    \n\
    \    if letter_count[2] == \"d\"\n        letter_count = \"e\"\n    \n    if letter_count[2]\
    \ == \"e\"\n        letter_count = \"f\"\n    \n    if letter_count[2] == \"f\"\
    \n        letter_count = \"g\"\n    \n    if letter_count[2] == \"g\"\n      \
    \  letter_count = \"h\"\n    \n    if letter_count[2] == \"h\"\n        letter_count\
    \ = \"i\"\n    \n    if letter_count[2] == \"i\"\n        letter_count = \"j\"\
    \n    \n    if letter_count[2] == \"j\"\n        letter_count = \"k\"\n    \n\
    \    if letter_count[2] == \"k\"\n        letter_count = \"l\"\n    \n    if letter_count[2]\
    \ == \"l\"\n        letter_count = \"m\"\n    \n    if letter_count[2] == \"m\"\
    \n        letter_count = \"n\"\n    \n    if letter_count[2] == \"n\"\n      \
    \  letter_count = \"o\"\n    \n    if letter_count[2] == \"o\"\n        letter_count\
    \ = \"p\"\n    \n    if letter_count[2] == \"p\"\n        letter_count = \"q\"\
    \n    \n    if letter_count[2] == \"q\"\n        letter_count = \"r\"\n    \n\
    \    if letter_count[2] == \"r\"\n        letter_count = \"s\"\n    \n    if letter_count[2]\
    \ == \"s\"\n        letter_count = \"t\"\n    \n    if letter_count[2] == \"t\"\
    \n        letter_count = \"u\"\n    \n    if letter_count[2] == \"u\"\n      \
    \  letter_count = \"v\"\n    \n    if letter_count[2] == \"v\"\n        letter_count\
    \ = \"w\"\n    \n    if letter_count[2] == \"w\"\n        letter_count = \"x\"\
    \n    \n    if letter_count[2] == \"x\"\n        letter_count = \"y\"\n    \n\
    \    if letter_count[2] == \"y\"\n        letter_count = \"z\"\n    \n    return\
    \ letter_count\n    end", "    message = split(message)\n    \n    \n    for i\
    \ in message:\n        if i.upper() in alphabet:\n            message(index(i,\
    \ alphabet)+1) = i.lower()\n    for i in message:\n        if i.lower() in alphabet:\n\
    \            message(index(i, alphabet)+1) = i.upper()\n    \n    \n    return\
    \ join(message)\nend\n</cell>\n<code language=julia-1.0>", "    # Write your code\
    \ here\nend\n</cell>\n<text>\nExercise 7: Write a function that takes a message,\
    \ and encodes in such a \n    way that it swaps case of all letters, replaces\
    \ all vowels in \n    the message with the letter that appears 2 places ahead\
    \ of that \n    vowel in the english alphabet.", "    \n    #make all letters\
    \ lowercase\n    message = lowercase(message)\n    \n    #make all vowels uppercase\n\
    \    message = uppercase(message)\n    \n    message = replace(message, \"a\"\
    , \"@\")\n    message = replace(message, \"e\", \"@\")\n    message = replace(message,\
    \ \"i\", \"@\")\n    message = replace(message, \"o\", \"@\")\n    message = replace(message,\
    \ \"u\", \"@\")\n    \n    message = replace(message, \"b\", \"@\")\n    message\
    \ = replace(message, \"c\", \"@\")\n    message = replace(message, \"d\", \"@\"\
    )\n    message = replace(message, \"f\", \"@\")\n    message = replace(message,\
    \ \"g\", \"@\")\n    message = replace(message, \"h\", \"@\")\n    message = replace(message,\
    \ \"j\", \"@\")\n    message = replace(message, \"k\", \"@\")\n    message = replace(message,\
    \ \"l\", \"@\")\n    message = replace(message, \"m\", \"@\")\n    message = replace(message,\
    \ \"n\", \"@\")\n    message = replace(message, \"p\", \"@\")\n    message = replace(message,\
    \ \"q\", \"@\")\n    message = replace(message, \"r\", \"@\")\n    message = replace(message,\
    \ \"s\", \"@\")\n    message = replace(message, \"t\", \"@\")\n    message = replace(message,\
    \ \"v\", \"@\")\n    message = replace(message, \"w\", \"@\")\n    message = replace(message,\
    \ \"x\", \"@\")\n    message = replace(message, \"y\", \"@\")\n    message = replace(message,\
    \ \"z\", \"@\")\n    \n    return message\nend\n</cell>\n<code language=julia-1.0>\n\
    @test encode(\"test\") == (\"tgst\")\n</cell>\n<code language=julia-1.0>\n@test\
    \ encode(\"This is a message\") == (\"tHKS KS C MGSSCGG\")\n</cell>\n<text>\n\
    Task 2: Write a function that takes a message, and encodes in such a \nway that\
    \ it swaps case of all letters, replaces all vowels in \nthe message with the\
    \ letter that appears 2 places ahead of that \nvowel in the english alphabet.\
    \ \nAssume the letters are lowercase.\nExamples: \nencode(\"test\") = \"TGST\"\
    \nencode(\"This is a message\") = \"tHKS KS C MGSSCGG\"", "    \n    return replaceChars(message).\n\
    \    \n\"\"\"\n    Write a function that takes a message, and encodes in such\
    \ a \n    way that it swaps case of all letters, replaces all vowels in \n   \
    \ the message with the letter that appears 2 places ahead of that \n    vowel\
    \ in the english alphabet. \n    Assume only letters. \n    \n    Examples:\n\
    \    >>> encode(\"test\")\n    \"TGST\"\n    >>> encode(\"This is a message\"\
    )\n    \"tHKS KS C MGSSCGG\"\n    \"\"\"", "    return map{\n        x -> match{\n\
    \            match{x==\"a\"}->\"b\"\n            match{x==\"e\"}->\"f\"\n    \
    \        match{x==\"i\"}->\"g\"\n            match{x==\"o\"}->\"h\"\n        \
    \    match{x==\"u\"}->\"j\"\n        }\n    }(message)", "\"\"\"\n    Write a\
    \ function that takes a message, and encodes in such a \n    way that it swaps\
    \ case of all letters, replaces all vowels in \n    the message with the letter\
    \ that appears 2 places ahead of that \n    vowel in the english alphabet. \n\
    \    Assume only letters. \n    \n    Examples:\n    >>> encode(\"test\")\n  \
    \  \"TGST\"\n    >>> encode(\"This is a message\")\n    \"tHKS KS C MGSSCGG\"\n\
    \    \"\"\"", "    \n    # Replace all letters with their english counterpart\n\
    \    # using regular expressions\n    # and convert the resulting list to an array\n\
    \    \n    # 1. Create array of letters in message\n    # 2. Replace vowels in\
    \ the message with their counterparts\n    # 3. Join the array with a space to\
    \ produce the final encoded message\n    \n    # 1. Create array of letters in\
    \ message\n    letters = regex(message, \"[a-z]\")\n    \n    # 2. Replace vowels\
    \ in the message with their counterparts\n    # and convert resulting list to\
    \ an array\n    encoded = [(letters[i+1] if letters[i+1] in [\"a\", \"e\", \"\
    i\", \"o\", \"u\"] \n        else letters[i]) for i in range(0, len(letters)-1)]\n\
    \    \n    # 3. Join the array with a space to produce the final encoded message\n\
    \    encoded_message = join(encoded, \" \")\n    \n    # Return to user the encoded\
    \ message\n    return encoded_message\n</code>\n<|/ a |>\n<| c |>\nThank you so\
    \ much, this is really helpful!\n<|/ c |>\n<| a |>\nA much more efficient and\
    \ readable version would be:\n<code>", "    \n    chars = string.ascii_lowercase\n\
    \    vowels = \"aeiouAEIOU\"\n    \n    new_message = \"\"\n    \n    for i in\
    \ string.ascii_lowercase:\n        new_message += message.replace(i,chars[i+1])\n\
    \    \n    vowel_indices = []\n    \n    for i,j in enumerate(new_message):\n\
    \        if j in vowels:\n            vowel_indices.append(i)\n    \n    new_message\
    \ = \"\"\n    for i,j in enumerate(new_message):\n        if i in vowel_indices:\n\
    \            new_message += chars[(i+2)%len(chars)]\n        else:\n         \
    \   new_message += j\n        \n    return new_message\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=string,python,algorithm dscore=1 |>\nUsing regex to find all substrings\
    \ of an alphabet. Replace the vowels with their second letter and then use itertools.combination\
    \ to combine the strings.\n<code>\nimport re\nfrom itertools import combinations,\
    \ product", "    \n    message = string.lower(message)\n    \n    vowels = \"\
    aeiou\"\n    \n    replaced_letters = {\n        \"a\": \"A\",\n        \"e\"\
    : \"E\",\n        \"i\": \"I\",\n        \"o\": \"O\",\n        \"u\": \"U\",\n\
    \        \"y\": \"Y\"\n    }\n    \n    replaced_letters_2 = {\n        \"a\"\
    : \"a\",\n        \"e\": \"e\",\n        \"i\": \"i\",\n        \"o\": \"o\",\n\
    \        \"u\": \"u\",\n        \"y\": \"y\"\n    }\n    \n    swapped = 0\n \
    \   swap_counter = 0\n    \n    for char in message:\n        if char in vowels:\n\
    \            swapped = swap_counter % 2\n            swap_counter += 1\n     \
    \       \n            if swapped == 1:\n                new_char = replaced_letters[char]\n\
    \            else:\n                new_char = replaced_letters_2[char]\n    \
    \    \n            new_message += new_char\n        else:\n            new_message\
    \ += char\n    \n    return new_message", "\"\"\"\n    Your code here!\n\"\"\""]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
