name: HumanEval_4_mean_absolute_deviation
language: jl
prompt: "\"\"\" For a given vector of input numbers, calculate Mean Absolute Deviation\n\
  \    around the mean of this dataset.\n    Mean Absolute Deviation is the average\
  \ absolute difference between each\n    element and a centerpoint (mean in this\
  \ case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0,\
  \ 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\nfunction mean_absolute_deviation(numbers::Vector{Float64})::Float64\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = mean_absolute_deviation;\n\t@test(candidate([1.0,\
  \ 2.0]) == 0.5)\n\t@test(candidate([1.0, 2.0, 3.0, 4.0]) == 1.0)\n\t@test(candidate([1.0,\
  \ 2.0, 3.0, 4.0, 5.0]) == 1.2)\nend\n"
completions: ["    if len(numbers) == 0 \n        error(\"Cannot calculate MAD on\
    \ an empty dataset\")\n    end\n    mean_number = mean(numbers)\n    return sum([abs(x\
    \ - mean_number) for x in numbers]) / length(numbers)\nend\n</cell>\n<text>\n\
    A function that can calculate mean absolute deviation for a vector of numbers\
    \ and a number x\nand returns the result. \n(Note that this is different from\
    \ mean absolute deviation. \nThis calculates the mean absolute deviation for the\
    \ entire vector, \nwhereas Mean Absolute Deviation only calculates the MAD for\
    \ one number)", "    center = mean(numbers)\n    return sum(abs2(number - center)\
    \ for number in numbers) / length(numbers)\nend\n</code>\n<|/ a tags=julia,standard-deviation\
    \ |>\n<| c |>\nI believe this has already been answered here: https://stackoverflow.com/questions/56406555/how-to-calculate-the-standard-deviation-of-a-vector-of-numbers-in-julia\n\
    <|/ c |>\n<| a |>\nJust to follow up on the answer from, I found that VectorStats.jl\
    \ has a function mad() which does what I've asked above.\nhttps://github.com/ksteele/VectorStats.jl\n\
    <|/ a dscore=1 tags=julia,standard-deviation |>\n<| a tags=julia,standard-deviation\
    \ dscore=0 |>\nFor completeness, the following is how one can calculate the standard\
    \ deviation with StatsBase.std() by using the same functions as in StatsBase.jl\
    \ (using rsqrt for simplicity):\n<code>", "    numbers = numbers[:]\n    sum =\
    \ 0.0\n    for i in numbers\n        sum += abs(i - mean(numbers))\n    end\n\
    \    return sum / length(numbers)\nend", "    \"\"\" Calculate Mean Absolute Deviation\
    \ around mean of input data. \"\"\"\n    sum = 0\n    for x in numbers\n     \
    \   sum += abs(x - mean)\n    return sum/length(numbers)\nend\n</cell>\n<code\
    \ language=julia-1.3>\nmean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n</cell>\n\
    <text>\nMean Absolute Deviation (MAD) can be used for data smoothing or outlier\
    \ removal.", "    sum(abs2(numbers - mean(numbers))) \nend", "    if length(numbers)\
    \ < 2\n        raise \"Number of entries must be greater than 2\"\n    end\n \
    \   # calculate the mean\n    mean = mean(numbers)\n    return mean(map(abs, numbers\
    \ - mean))\nend\n</cell>\n<text>\nThe next function will be used to calculate\
    \ a moving average. It takes the mean of the passed in values and calculates the\
    \ average. In the example above, the mean was calculated over the vector [1,2,3,4,5,6,7,8,9,10]\
    \ and the average was calculated from 1 through 10. The moving average is calculated\
    \ by taking each element of the vector and adding it to the running average. The\
    \ return value is the mean of the values in the vector.", "    mean_ = mean(numbers)\n\
    \    diff = numbers - mean_\n    sum_abs = sum(abs2, diff)\n    return sum_abs\
    \ / length(diff)\nend\n</cell>\n<text>\nCalculate Root Mean Squared Error\nThe\
    \ RMSE (root mean squared error) measures the average of the squared errors, dividing\
    \ the squared errors by their sizes:\nRMSE = SQRT(SUM((x - x_mean)^2))\nwhere:",
  "    return mean((numbers - mean(numbers)) .^ 2)\nend\n</cell>\n<text>\nCalculating\
    \ the median is pretty much identical to the mean:", "    mean_val = mean(numbers)\n\
    \    return (reduce(+, map(abs, numbers)) - mean_val).^2/length(numbers)\nend\n\
    </cell>\n<text>\n$$\\large \\text{MAE} = \\sqrt{\\frac{\\sum |y-\\hat{y}|}{\\\
    sum |y|}}$$", "    \"\"\"\n    Mean Absolute Deviation\n    \n    \n    \n   \
    \ >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", " \
    \   \n    n = length(numbers)\n    if n == 0 \n        return 0.0\n    end", "\t\
    sum_absolute_deviation = 0.0 \n\tfor i in numbers do \n\t\tsum_absolute_deviation\
    \ = sum_absolute_deviation + abs  (i-mean(i))\n\tend \n\tMAD = sum_absolute_deviation/length(numbers)\n\
    \treturn MAD\nend", "        sum = 0\n        count = 0\n        for element in\
    \ numbers\n            sum = sum + abs(element - mean(numbers))\n            count\
    \ = count + 1\n        return sum / count\n</code>\nThe example above is simple\
    \ and clear. Now, let us try it with the example from Andrew Stravinsky's book\
    \ Linear Algebra and its example: Calculating Standard Deviation of an Array in\
    \ Python. \n<code>", "    mean_ = mean(numbers)\n    return sum((numbers - mean_)\
    \ .* numbers .- numbers .* (numbers - mean_))/length(numbers)\nend\n</cell>\n\
    <cell>\n@time mean_absolute_deviation(data)\n</cell>\n<text>\nExercise: Write\
    \ a function that returns an array of element-wise square roots \nof the input\
    \ array of numbers.", "        sum=0.0\n        for n in numbers\n           \
    \ sum += (n - mean(numbers))^2\n        end\n        return sum/(length(numbers)-1.0)\n\
    \    end\n</cell>\n<text>\nExercise 2\nWrite a function that takes a vector of\
    \ input numbers, and returns the sum of the squared differences between all elements\
    \ and the corresponding mean of the input vector.", "    avg = mean(numbers)\n\
    \    return mean(abs(numbers - avg))\nend\n</cell>\n<text>\nFunction to generate\
    \ random numbers (uniform distribution)", "    \"\"\"\n    Calculate Mean Absolute\
    \ Deviation for each element in a vector\n    >>> [mean_absolute_deviation([1.0,\
    \ 2.0, 3.0]), mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]), mean_absolute_deviation([1.0,\
    \ 2.0, 3.0, 4.0])]\n    1.0\n    2.0\n    3.0\n    \"\"\"\n    return mean(map(abs,\
    \ numbers)) \nend\n</cell>\n<text>\nCalculate Mean Absolute Deviation of Vector\
    \ with Data\nThe Mean Absolute Deviation (MAD) is calculated as", "    sum = sum(abs2,\
    \ numbers)\n    return sum / length(numbers)\nend\n</cell>\n<code language=julia-1.6>\n\
    mean_absolute_deviation(numbers)\n</cell>\n<text>\nThe average absolute error\
    \ is another useful metric to study when comparing predictions to observations.\
    \ By computing the average absolute error, you can study the performance of your\
    \ model on new and unseen data. Below, we calculate the mean absolute error of\
    \ our predictions on the first three observations of our test set.", "    local\
    \ m = 0\n    for n in numbers do\n        local m = m + math.abs(n - mean(numbers))\n\
    \    end\n    return m\nend", "    return sqrt(mean(abs2.(numbers - mean(numbers))))\n\
    end\n</cell>\n<text>\nThe RMS of a set of numbers is defined as the square root\
    \ of the mean of the squared differences from the mean.", "  deviations = map(abs,\
    \ numbers)\n  mean = mean(numbers)\n  return sum(abs(deviations) - mean)/length(deviations)\n\
    end\n</cell>\n<code language=julia-1.6>\njulia> mean_absolute_deviation([1.0,\
    \ 2.0, 3.0, 4.0])\n1.0\n</cell>\n<code language=julia-1.6>\nmean_absolute_deviation([0.5,\
    \ 0.2, 0.8, 0.6])\n</cell>\n<text>\nLet's look at this in Julia", '    """Calculate
    the mean absolute deviation of a set of numbers', "    abs_deviations = map(abs,\
    \ numbers)\n    abs_deviations_mean = mean(abs_deviations)\n    return mean(abs_deviations.map(x\
    \ -> (x - abs_deviations_mean).abs))\nend\n</cell>\n<text>\nExercise", "    total\
    \ = sum(numbers)\n    return sqrt(sum([(n-total)^2 for n in numbers]) / length(numbers))\n\
    end\n</cell>\n<text>\nLet's check that our Mean Absolute Deviation calculation\
    \ is working correctly:", "    mean =  mean(numbers)\n    return sum(abs2 - mean\
    \ for abs2 in numbers)/length(numbers)\nend\n</cell>\n<code language=julia-0.5>",
  "    n::Int = length(numbers)\n    sum::Float64 = 0.0\n    for j in 1:n\n      \
    \  sum += (numbers[j] - mean(numbers)) * (numbers[j] - mean(numbers))\n    end\n\
    \    return sum / n\nend\n</cell>\n<code language=julia-1.4>\nmean_absolute_deviation([1,2,3,4])\n\
    </cell>\n<code language=julia-1.4>\n# We want to plot the input number array for\
    \ different deviation\n# levels and compare the results with the MAD value.",
  "    mean =  mean(numbers)\n    sum = 0.0\n    for number in numbers\n        sum\
    \ += (number - mean) * (number - mean)\n    end", "    return mean(abs2(numbers))\
    \ \nend", "    \"\"\"For a given vector of input numbers, calculate Mean Absolute\
    \ Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation\
    \ is the average absolute difference between each\n    element and a centerpoint\
    \ (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0,\
    \ 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "    avg = mean(numbers)\n    return\
    \ sum([abs(x - avg) for x in numbers]) / length(numbers)\nend\n</cell>\n<code\
    \ language=julia-1.6>\n# Testing our mean absolute deviation function\n@test mean_absolute_deviation([1.0,\
    \ 2.0, 3.0, 4.0]) == 1.0\n@test mean_absolute_deviation([1.0, 2.0]) == 0.5\n</cell>\n\
    <code language=julia-1.6>\n# Plot the distribution of mean absolute deviations\n\
    x = 1:100\ny = map(x->mean_absolute_deviation(x), x)\nplot(x, y)\nplot!(; label=\"\
    \")\n</cell>\n<text>\nThis function is useful for calculating and plotting variance.\
    \ There are many more functions such as mean-squared error, standard deviation,\
    \ and correlation.", "    sum = 0.0\n    for i in numbers\n        sum += abs(i\
    \ - mean)\n    end\n    return sum / (length(numbers) - 1)\nend", "    sum(abs2,\
    \ numbers)/length(numbers)\nend\n</cell>\n<code language=julia-1.0>\n# Your mean_absolute_error\
    \ function should also work on the GPU.\n@cuda function mean_absolute_error(numbers::Vector{Float64})::Float64\n\
    \  mean(abs2, numbers)\nend\n</cell>\n<code language=julia-1.0>\n@assert mean_absolute_error(Vector{Float64}([4.0,\
    \ 5.0, 6.0])) == 3.0\n@assert mean_absolute_error(Vector{Float64}([1.0, 2.0, 3.0,\
    \ 4.0])) == 1.0\n</cell>\n<text>\nMean Squared Error", "    # Calculate sum of\
    \ all deviations\n    sum_of_all_deviations = 0.0\n    for number in numbers\n\
    \        sum_of_all_deviations += fabs(number - mean(numbers))\n    end\n    #\
    \ Divide by total number of observations\n    return sum_of_all_deviations / length(numbers)\n\
    end\n</code>\n<|/ a dscore=2 tags=statistics,julia |>\n<| a dscore=1 |>\nA straightforward\
    \ way to calculate mean absolute deviation is\n<code>\nimport Statistics", " \
    \   sum::Float64 = 0.0\n    total::Float64 = 0.0\n    for x in numbers\n     \
    \   sum += abs(x - mean(x))\n        total += 1\n    return sum / total\n</code>\n\
    <|/ a tags=julia |>\n<| a |>\nI like to use JIT-compiled functions for this kind\
    \ of thing, as these will be faster than unsafe and non-JIT-compiled code. \n\
    <code>\njulia> using BenchmarkTools", "    sum_of_squared_deviations = 0.0\n \
    \   for i in numbers\n        sum_of_squared_deviations += pow((numbers[i] - mean(numbers)),\
    \ 2)\n    return sqrt(sum_of_squared_deviations / length(numbers))\nend\n</cell>\n\
    <text>\nExercise #5", "    average::Float64 = 0.0\n    sum::Float64 = 0.0\n  \
    \  for num in numbers\n        average += num\n        sum += 1.0\n    end\n \
    \   average/sum\nend\n</cell>\n<code language=julia-0.4>\njulia_stat(numbers)\n\
    </cell>\n<code language=julia-0.4>\n# Mean Absolute Deviation\njulia_stat(numbers)\n\
    </cell>\n<code language=julia-0.4>", "    return mean(filter(x -> abs(x - mean(numbers)),\
    \ numbers))\nend", "    summand = numbers.sum::Float64\n    return sqrt(summand/length(numbers))\n\
    end\n</cell>\n<cell>\n# Let's check it out:\nmean_absolute_deviation([1,2,3,4,5])\n\
    </cell>\n<text>\nWe can see that our implementation does produce reasonable results:\n\
    $$\n\\mbox{mean_absolute_deviation}(\\mathbf{x}) = \\sqrt{n}\\cdot \\left[ \\\
    sum{i=1}^n | x_i - \\mu| \\right]\n$$\n(we ignore the denominator for now and\
    \ just focus on \\sqrt{n})", "    sum = sum(numbers)\n    return sum / length(numbers)\n\
    end", "  n = length(numbers)\n  mad <- 0.0;\n  for i in 1:n\n    mad = mad + abs(numbers[i]\
    \ - mean(numbers))\n  end\n  mad / n\nend", "    if numbers == []\n        error(\"\
    mean_absolute_deviation was called with an empty list\")\n    end\n    numbers_mean\
    \ = mean(numbers)\n    return mean(abs.(numbers - numbers_mean))\nend", "    sum\
    \ = 0.0\n    for x in numbers\n        sum = sum + abs(x - sum / length(numbers))\n\
    \    end\n    return sum / length(numbers)\nend\n</cell>\n<code language=julia-1.2>\n\
    mean([1,2,3,4,5])\n</cell>\n<code language=julia-1.2>", "   \n    return mean(map(abs,\
    \ numbers - mean(numbers)))\nend\n</cell>\n<text>\nExercise: Find the mean absolute\
    \ deviation for a vector of input numbers:", "    sum_abs_deviation = 0\n    sum_mean\
    \ = 0\n    for x in numbers\n        sum_abs_deviation += math.abs(x - mean(x))\n\
    \        sum_mean += x\n    end\n    return sum_abs_deviation / length(numbers)\n\
    end\n</cell>\n<text>\n4. Mean Absolute Deviation on all vectors:\nThe function\
    \ below takes in an array of vectors and calculates the mean MAD between \nall\
    \ the vectors. The vectors are sorted by the vector's length.", "    median =\
    \ quantile(numbers, 0.5)\n    dev = map(x -> abs(x - median), numbers)\n    mean(dev)\n\
    end\n</cell>\n<text>\nStatistical Tests\nWe now need to perform some statistical\
    \ tests to see if we can reject the null hypothesis that all input numbers are\
    \ drawn from the same distribution. We will perform some tests on random samples\
    \ of input numbers to see if the mean value is the same as that of the mean of\
    \ all input numbers.", "    sum((x - mean(numbers)) .* x, dims = 1)\nend\n</cell>\n\
    <text>\n4.2.3 Mean Absolute Deviation Function", "    if length(numbers) <= 1\n\
    \        return NaN\n    end", "\tsum = 0.0\n\tfor n in numbers\n\t\tsum = sum\
    \ + abs(n - mean(n))\n\tend\n\tMAD = sum / length(numbers)\nend", "    if length(numbers)\
    \ < 2\n        error(\"Invalid input\")\n    end\n    d1 = numbers[1] - numbers[2]\n\
    \    return d1 / mean(numbers)\nend", "    sum(abs  (x-mean(x))  for x \u2208\
    \ numbers)/length(numbers)\nend", "\"\"\"\n    return mean(abs2(numbers-mean(numbers)))\n\
    end #function _mean_absolute_deviation\n</code>\n<|/ a tags=julia,statistics dscore=4\
    \ |>\n<| c |>\nCan you be specific how this is different from the already existing\
    \ answer which used `statistics` package?\n<|/ c |>\n<| a dscore=3 |>\nJust to\
    \ mention that in Julia v0.3 and later you can do this:\n<code>\njulia> mean(collect(1:20))\n\
    6", "    \n\"\"\"\n    Calculate the root mean squared deviation from the mean\
    \ of a vector.\n    RMSD = square root of (sum of squares - mean of vector)\n\
    \    >>> rms_deviation([1.0, 2.0, 3.0])\n    0.7071067811865476\n\"\"\"", "  \
    \  # Find the mean and calculate the difference between each number and the mean\n\
    \    mean := mean(numbers)\n    differences := filter(x->abs(x-mean) < MAX, numbers)\n\
    \    return mean(differences)\nend\n</code>\n<|/ a tags=vector,mean,julia |>\n\
    <| c |>\nThat's a lot slower than mine, about as fast as `std(numbers)`\n<|/ c\
    \ |>\n<| a dscore=2 |>\nThis might be a good use case for the StatsTools.jl package.\n\
    <code>\njulia> using StatsTools\njulia> data = [1.0 2 3 4 5]\njulia> mean(data)\n\
    1.414214\njulia> stdev(data)\n0.707107\n</code>\n<|/ a tags=vector,mean,julia\
    \ |>\n<| c |>\nFor small number of elements (e.g. only 1) and a small number of\
    \ standard deviations you can get significant performance gain by calculating\
    \ `mean` and `stdev` separately.\n<|/ c |>\n<| a tags=vector,mean,julia |>\nI\
    \ have done this in Julia by converting the list into an array and find the mean\
    \ and variance using statistics.jl:\n<code>\njulia> using Statistics\njulia> data\
    \ = [1, 2, 3, 4, 5, 6]\njulia> mean(data)\n3.0\njulia> std(data)\n1.581139\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=1 |>\n<code>\nusing Statistics, Statistics.Distributions",
  "    diff = numbers - mean(numbers)\n    ma = sum(abs2(diff))/length(numbers)\n\
    \    return ma\nend", "    sum::Float64 = 0\n    for number in numbers\n     \
    \   sum += abs(number-mean(numbers))\n    end\n    return sum / length(numbers)\n\
    end", "    diff = numbers[2:end] - numbers[1:end-1]\n    return ma(diff)\nend\n\
    </cell>\n<code language=julia-1.6>", "    sum::Float64 = 0.0\n    for i in numbers\
    \ do\n        sum += abs(i - mean)\n    end\n    return sum / length(numbers)\n\
    end", "  mean1 = mean(numbers)\n  squared_deviations = map(x -> abs (x-mean1),\
    \ numbers)\n  return mean(squared_deviations)\nend\n</cell>\n<text>\n4.5. Mean\
    \ Square Error\nFor a given vector of input numbers, calculate Mean Square Error.\n\
    Mean Square Error is calculated as mean( squared absolute differences ):\nMSLE\
    \ = mean | x - x_mean |^2\n    >>> mean_sqaure_error([1.0, 2.0, 3.0, 4.0])\n \
    \   1.5\n    \"\"\"", "    n = length(numbers)\n    mean = sum(numbers) / n\n\
    \    deviations = map(deviation, numbers)\n    return sum(deviations) / n\nend\n\
    </code>\nI guess you can do this in a few lines of python code but I just wanted\
    \ to give a Julia solution. \nThe benefit of Julia is that it will take care of\
    \ vectorization and broadcasting automatically for you.\nThe Julia code below\
    \ is the same as the python code above. \n<code>\nusing Statistics \n# using LinearAlgebra",
  "    return mean(abs2, numbers)\nend\n</cell>\n<code language=julia-0.6>\n@testset\
    \ \"Mean Absolute Deviation\" begin\n    numbers = Vector{Float64}(undef, 5)\n\
    \    numbers[1] = 1\n    numbers[2] = 2\n    numbers[3] = 3\n    numbers[4] =\
    \ 4\n    numbers[5] = 3\n    \n    @test mean_absolute_deviation(numbers) == 3.0\n\
    \    @test mean_absolute_deviation([1,2,3,4,5]) == 3.0\nend\n</cell>\n<text>\n\
    The function mean returns the mean of a vector of numbers.", "    mean_val::Float64\
    \ = mean(numbers)\n    return sum([abs(x - mean_val) for x in numbers]) / length(numbers)\n\
    end\n</cell>\n<text>\nMean Absolute Deviation (MAD) is a common metric to evaluate\
    \ outliers in a dataset. It measures how far a value is from the mean (average),\
    \ or the expected value from a population mean.", "    absdiffs = abs.(numbers\
    \ - mean(numbers))\n    return mean(absdiffs)\nend", "    mean_ = mean(numbers)\n\
    \    return mean(map(abs, numbers-mean_))", "    deviations = numbers .- mean(numbers)\n\
    \    absolute_deviations = map(fabs(deviations), numbers)\n    mad = reduce(+,\
    \ absolute_deviations)\n    return mad \nend\n</cell>\n<text>\nTests\nLet's test\
    \ our implementation of Mean Absolute Deviation:", "    return (sum(abs2.(numbers\
    \ - mean(numbers))) /  length(numbers)) \nend \n</cell>\n<text>\nMean Absolute\
    \ Deviation - Part 2", "    mean(absdiff(numbers))\nend\n</cell>\n<text>\nThe\
    \ mean_absolute_deviation function works on any type of Vector of numbers.", " \
    \ mean(mean(abs(numbers - mean(numbers))))\nend\n</cell>\n<text>\nLet's plot some\
    \ data to see the variance this measures over:", "    \n    sum = 0.0\n    for\
    \ x in numbers\n        sum += abs(x - mean(x))\n    end\n    return sum / length(numbers)\n\
    end\n</cell>\n<code language=julia-1.4>\nmean_absolute_deviation(numbers)\n</cell>\n\
    <text>\nIn Julia there are many built-in math functions including mean, median,\
    \ min, max, abs, sin, cos, sqrt, and even the pow function. Here we use the median\
    \ function to calculate the value of a number as the middle value in a vector\
    \ or list. Let's see how it works.", "    average = mean(numbers)\n    sum_of_squares\
    \ = 0\n    for i in numbers\n        sum_of_squares = sum_of_squares + i*i\n \
    \   end\n    return (sum_of_squares - average*average)/ length(numbers)\nend\n\
    </cell>\n<code language=julia-1.3>\n@assert mean_absolute_deviation([1,2,3]) ==\
    \ (sqrt(3)/2)\n</cell>\n<text>\nPart 6: Descriptive Statistics for Routines and\
    \ Other Containers\nWe have just seen, how our functions work on vectors. This\
    \ section will help us understand what these functions do on other containers,\
    \ like lists and matrices. It is best to look at the official documentation, as\
    \ this is highly detailed and explains many subtleties.", "    return sqrt(mean(absdiff(numbers,\
    \ mean(numbers))))\nend", "\"\"\"\nCalculate the mean absolute deviation (MAD)\
    \ of a given vector of input numbers\n\"\"\"", "    mean_x = mean(numbers)\n \
    \   return mean(map (abs2, numbers - mean_x)) \nend", "    MAD = zeros(length(numbers))\n\
    \    for i in eachindex(numbers)\n        MAD[i] = mean((numbers[i] - mean(numbers))\
    \ / mean(numbers))\n    end\n    return MAD\nend\n</cell>\n<text>\nMean Absolute\
    \ Deviation Function", "    sum = 0.0\n    for x in numbers\n        sum += abs(x\
    \ - mean(x))\n    return sum/length(numbers)\nend", "    mean_of_the_numbers =\
    \ mean(numbers)\n    deviations = [abs(number - mean_of_the_numbers) for number\
    \ in numbers]\n    return mean(deviations)", "    # Compute the mean\n    mean\
    \ = mean(numbers)\n    # Compute the deviation\n    deviation = map(x -> abs (x-mean),\
    \ numbers)\n    # Return the average\n    mean(deviation)\nend\n</cell>\n<text>\n\
    Exercise 1: Mean Absolute Deviation\nWrite a function that takes an array as an\
    \ argument and returns the mean absolute deviation\nof the values in the array.\n\
    For a vector of input numbers, calculate MAD.\nFor example, if the input vector\
    \ is [1, 2, 3, 4], the output should be 3.0.\nThe function should ignore non-numeric\
    \ types and return a NaN instead.", "    absdiff(numbers, mean(numbers))\nend\n\
    </cell>\n<text>\nWe will also need mean squared deviation function:", "    \n\
    \    \n    sum_of_squared_differences = 0.0 \n    for x in numbers \n        sum_of_squared_differences\
    \ += (x - mean(x))^2 \n    return sqrt(sum_of_squared_differences/length(numbers))\
    \ \nend \n</cell>\n<code language=julia-0.5>\n## Practice: \n# Write a function\
    \ to calculate the median absolute deviation of a given vector of input numbers.",
  "    mean_number = mean(numbers)\n    differences = numbers - mean_number\n    absolute_differences\
    \ = map(f->abs(f), differences)\n    mad = mean(absolute_differences)\n    return\
    \ mad \nend\n</cell>\n<code language=julia-1.3>\nusing Random", "  return mean(abs.(numbers\
    \ - mean(numbers)))\nend", "    median(numbers)\n    numbers = [abs(i-median(numbers))\
    \ for i in numbers]\n    mean(numbers)\nend\n</cell>\n<text>\nExercise: What is\
    \ the value of this function for a vector of length 3? How would you modify it\
    \ if you were instead given a vector of length 4?", "    return mean(map(abs,\
    \ numbers))\nend\n</cell>\n<code language=julia-1.3>\n\"\"\"\n    median_absolute_deviation",
  "  m = (sum(numbers) + mean(numbers)) / 2\n  mad = 0\n  for n in numbers\n     \
    \ mad += abs(n - m) \n  end\n  mad /= length(numbers)\n  return mad\nend", " \
    \   import numpy as np\n    return np.mean(np.fabs(numbers - np.mean(numbers)))",
  "    return mean(abs.(numbers)) \nend", "    return sqrt(mean(absdiff(numbers, mean(numbers))))\n\
    end", "    return mean(\n        map(\n            abs\n            , numbers\n\
    \        )\n    ) \nend\n</code>\n<|/ a |>\n<| a dscore=4 tags=julia |>\nThere\
    \ has got to be a better way. Anybody know about a package that takes care of\
    \ this? Pretty much all standard statistics libraries in Julia are not suited\
    \ for this.\nI ended up writing a package for this.\nhttps://github.com/kristopherrschner/StatisticsFunctions\n\
    <|/ a |>\n<| a tags=julia |>\nThis might be too late, but there is a simpler way\
    \ to do this using StatsBase.jl. \n<code>\njulia> using StatsBase", "    n = length(numbers)\n\
    \    sum = 0.0\n    for x in numbers\n        sum += abs(x - mean(x))\n    end\n\
    \    sum / (n-1.0)\nend\n</cell>\n<code language=julia-0.5>\nusing DataFrames\n\
    </cell>\n<code language=julia-0.5>\nmean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n\
    </cell>\n<code language=julia-0.5>", "    return (map(abs, numbers) - mean(numbers))\
    \ .^ 2 \nend ", "    avg := mean(numbers)\n    squares := map(numbers, (x) ->\
    \ pow(x, 2))\n    square_avg := sum(squares) / length(numbers)\n    square_diff\
    \ := map(squares, (x) -> x - square_avg)\n    mad_avg := sum(map(square_diff,\
    \ abs) / length(numbers)) \n    mad_avg \nend", "    # calculate the mean and\
    \ standard deviation of the input numbers\n    number_mean = mean(numbers)\n \
    \   number_std = std(numbers)\n    # calculate the MAD\n    return mean(map((number-number_mean).abs,\
    \ numbers))\nend", "    sum_of_squares = 0.\n    for i in numbers\n        sum_of_squares\
    \ += math.pow((i - mean(numbers)), 2)\n    return sqrt(sum_of_squares) / length(numbers)\n\
    end", "    return (sum([abs(i-mean_number(numbers)) for i in numbers])::Float64\
    \ / length(numbers))\nend\n</cell>\n<text>\nPart 3: Regression Analysis", "  \
    \  mean = sum(numbers)\n    diff = numbers - mean\n    return mean(abs.(diff))\n\
    end\n</code>\n<|/ a dscore=2 tags=julia,math,mean,vector,stddev |>\n<| a |>\n\
    The question asks for the standard deviation of a vector (i.e., sqrt(sum((x-mean(x))^2)/length(x)))\
    \ but the answer given by does not take into account the degrees of freedom. Here\
    \ is a function that accounts for this.\n<code>\nusing Statistics", "\tsum = sum(numbers)\n\
    \tnn = length(numbers)\n\tmean = sum / nn\n\tmad = 0.0\n\tfor number in numbers\n\
    \t\tmad += abs(number - mean)\n\tend\n\treturn mad\nend", "    sum = 0\n    for\
    \ n in numbers\n        sum += abs(n - mean(n))\n    end\n    sum / length(numbers)\n\
    end\n</cell>\n<code language=julia-1.2>", "    sum::Float64 = 0.0\n    for i in\
    \ numbers\n        sum += abs(i - mean(i))\n    return sum/length(numbers)\nend\n\
    </cell>\n<text>\nTest the function with some sample data:", "    abs_vals = map(abs,\
    \ numbers)\n    mean_val = mean(abs_vals)\n    return mean(map(abs, filter(e ->\
    \ e < mean_val, numbers))) \nend\n</cell>\n<code language=julia-1.0>\n@doc mean_absolute_deviation\n\
    </cell>\n<code language=julia-1.0>\n@code_native mean_absolute_deviation\n</cell>\n\
    <text>\nTo calculate the variance (standard deviation), we need the squared deviation\
    \ from the mean:", "    \"\"\"\n    Args:\n        numbers (Vector[Float64]):\
    \ Vector of input numbers\n    Returns:\n        Float64: Mean Absolute Deviation\
    \ around the mean of the input numbers\n    \"\"\"\n    return mean(abs.(numbers\
    \ - mean(numbers)))\nend ", "  length = length(numbers)\n  mean = mean(numbers)\n\
    \  sum = 0.0\n  for n in numbers\n    sum += abs(n - mean)\n  end\n  return sum\
    \ / length\nend\n</cell>\n<text>\nThis function is a bit more efficient than the\
    \ built-in mean() function, as it does not need to calculate the mean of all numbers.\
    \ However, it is much more inefficient for large vectors.", "\t\n\tsum = 0\n\t\
    for (el) in numbers \n\t\tsum = sum + (el-mean(numbers))^2 \n\tend\n\treturn sum/length(numbers)\n\
    end", "  x_mean = mean(numbers)\n  return abs(numbers .- x_mean)\nend\n</cell>\n\
    <code language=julia-1.5>\n@time mean_absolute_deviation([1.0 for _ in 1:10000])\n\
    </cell>\n<text>\n1.3 Find outliers\nIn the previous section we calculated the\
    \ Mean Absolute Deviation for a vector of numbers. \nThis gives us a good idea\
    \ of what we expect this dataset to look like. \nTo find outliers, we could use\
    \ other methods. \nOne such method is the Interquartile range (IQR) which we calculate\
    \ by\n$$ IQR = Q3 - Q1 $$\nwhere Q1, Q3 are the quartiles of this dataset. \n\
    We can then plot this and see where it starts to get bad.", " \n  return(sum(abs2,numbers)/length(numbers))\n\
    end", "    sum = 0.0\n    for i in numbers:\n        sum = sum + abs(i - mean)\n\
    \    return sum/length(numbers)\nend", "    sum=0\n    for x in numbers \n   \
    \     sum += abs(x - mean(x))\n    end\n    return sum/length(numbers)\nend\n\
    </cell>\n<text>\nLet's now calculate the MAD for a few different inputs, and see\
    \ what result we get back.", "    center = mean(numbers)\n    sum((numbers - center).abs)\n\
    end", "  \n    sum = 0\n  \n    for i in numbers:\n        sum = sum + abs(i -\
    \ mean(i))\n  \n    return sum / length(numbers)", "  sum = 0.0\n  for n in numbers\n\
    \    sum += abs(n - mean(numbers))\n  end\n  return sum / length(numbers)\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| a |>\nThis is more general than the other answers\
    \ since it calculates the median of a set of numbers.\n<code>", "    diff = numbers\
    \ .- mean (numbers)\n    return sum diff .* diff ./(length(diff)-1)\nend\n</cell>\n\
    <code language=julia-0.5>\nmean_absolute_deviation([1,2,3])\n</cell>\n<code language=julia-0.5>\n\
    mean_absolute_deviation([1,2,4])\n</cell>\n<text>\nMean Absolute Deviation Function\
    \ for DataFrames", "    return sqrt(mean(abs2(numbers-mean(numbers))))\nend\n\
    </cell>\n<text>\nLet's look at the MAD.", "    N = length(numbers)\n    average\
    \ = sum(numbers)/N\n    devs = Float64[]\n    for n in numbers\n        devpush!(devs,\
    \ n - average)\n    end\n    return mean(devs)\nend\n</cell>\n<code language=julia-1.5>\n\
    mean_absolute_deviation([1,2,3,4,5,6])\n</cell>\n<text>\nWhat is the median of\
    \ a set of numbers?", "    sum::Float64 = 0.\n    for i in numbers:\n        sum\
    \ = sum + abs(i - mean(i))\n    return sum/length(numbers)\nend mean_absolute_deviation\n\
    \"\"\"\n    Calculate the mean absolute deviation of the given data set.\n   \
    \ >>> data = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0,\
    \ 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0, 26.0]\n\
    \    >>> mean_absolute_deviation(data)\n    5.166666666666666\n    \n    \"\"\"",
  '    return mean(abs.(numbers-mean(numbers)))', "    return mean(abs.(numbers -\
    \ mean(numbers)))\nend #", "    return mean(abs.(numbers - mean(numbers)))\nend",
  "    sum(abs.(numbers - mean(numbers)))/length(numbers)\nend", "    sum = 0.0\n\
    \    count = 0\n    for n in numbers:\n        sum += abs (n - mean (numbers))\n\
    \        count += 1\n    if count > 0\n        return sum / count\n    else\n\
    \        return 0.0\n    end\nend\n</cell>\n<text>\nExercise 1: Calculate the\
    \ Mean Absolute Deviation for a dataset with 2 input elements\nCalculate the mean\
    \ absolute deviation for the dataset with 2 input elements. \nWhat is your answer?",
  "    \n    # calculate mean of numbers\n    average = sum(numbers) / length(numbers)",
  "    sum(abs(self-mean(numbers))) / length(self)\nend", "\"\"\"\n    \n    \"\"\"\
    \n    Calculate standard deviation\n    \"\"\"", "    \"\"\"Calculate the Mean\
    \ Absolute Deviation using Python built-in function\n    statistics.mean() with\
    \ one argument - a list.\n    \"\"\"\n\"\"\"\n    Calculate the Mean Absolute\
    \ Deviation using Python built-in function\n    statistics.mean() with two arguments\
    \ - the list and the centerpoint \n    (mean in this case).\n    \"\"\"", "  \
    \  mean(abs2, numbers)\nend\n</cell>\n<text>\nWhat does it mean to calculate MAD?\n\
    What does it mean to calculate an absolute deviation?", "    number_mean = mean(numbers)\n\
    \    dev = [abs(x-number_mean) for x in numbers]\n    return mean(dev)\nend\n\
    </cell>\n<code language=julia-1.5>\n@code_native mean_absolute_deviation(numbers)\n\
    </cell>\n<text>\nAs you can see, the performance of this function has improved\
    \ over previous, slower implementations. So let's now have a look at how we can\
    \ use it!", "    abs_diff = @-@ numbers .- @mean!(numbers)\n    mad = mean(abs_diff)\n\
    end", "    abs2 = |numbers| |> abs\n    abs2 |> sum\nend\n</cell>\n<cell>", " \
    \   \n    abs_deviations = map(abs, numbers)\n    mean_abs_deviation = mean(abs_deviations)\n\
    \    \n    return mean_abs_deviation\nend", "\tsum = 0.0\n\tn = length(numbers)\n\
    \tfor i in 0 .. n-1 do\n\t\tsum = sum + abs(numbers[i] - mean(numbers))\n\tend\n\
    \treturn sum / n\nend\n</cell>\n<code language=julia-0.5>\n## Let's make our own\
    \ function to do this", "    sum(abs2.(numbers - mean(numbers)))/length(numbers)\n\
    end\n</cell>\n<text>\n3. Plot MAD", "    mad <- mean(abs.(numbers - mean(numbers)))\n\
    \    return mad", "    sum_abs_diff <- sum(abs2, numbers)\n    return sum_abs_diff\
    \ / length(numbers)\nend\n</cell>\n<text>\n4. Exploratory Data Analysis\nBefore\
    \ starting our exploratory data analysis process, let's do some basic preliminary\
    \ data analysis and have a basic idea of how data looks like. We'll start with\
    \ creating a data frame with just a single column.", "    \"\"\" For a given vector\
    \ of input numbers, calculate Mean Absolute Deviation\n    around the mean of\
    \ this dataset.\n    Mean Absolute Deviation is the average absolute difference\
    \ between each\n    element and a centerpoint (mean in this case):\n    MAD =\
    \ average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n\
    \    1.0\n    \"\"\"\n\"\"\"\n## Mean Squared Deviation\n### mean - average |\
    \ x - x_mean |^2\n\"\"\"\n\"\"\"\n#### mean - average | x - x_mean |^2\n\"\"\"",
  "    median = sort(numbers)[length(numbers)/2]\n    diff = numbers - median\n  \
    \  maad = mean(abs.(diff))\n    return maad", " \n    return mean(map(abs, numbers))\
    \ \nend", "    sum((numbers - mean(numbers)) .^ 2)\nend\n</cell>\n<text>\nAs shown\
    \ above, Mean Absolute Deviation is a robust measure of variability in a set of\
    \ numbers. This is because we are measuring the distance between the points, and\
    \ so points closer than others will be affected by outliers not far away from\
    \ the mean by outliers far away from them.", "    number = mean(numbers)\n   \
    \ deviation = numbers .- number\n    mean_abs = mean(deviation)\n    return mean_abs\n\
    end", "  sum_abs = 0.0\n  for x in numbers \n    sum_abs += abs(x - mean(x))\n\
    \  end\n  return sum_abs / length(numbers)\nend\n</cell>\n<text>\nMean Squared\
    \ Error", "    s = 0.0\n    for i in numbers\n        s = s + abs\n    s /= length(numbers)\n\
    \    return s\nend", "    sum = 0.0\n    for number in numbers\n        sum +=\
    \ abs(number - mean(numbers))\n    end\n    return sum / length(numbers)\nend",
  "  \n  n_numbers = length(numbers)\n  x_mean = mean(numbers)\n  made_numbers = copy(numbers)\n\
    \  made_numbers .-= x_mean\n  \n  made_numbers./=n_numbers\n  return mean(made_numbers)\n\
    end\n</cell>\n<code language=julia-1.5>\nmean_absolute_deviation([1.0, 2.0, 3.0,\
    \ 4.0])\n</cell>\n<code language=julia-1.5>", "    sum = 0.0\n    for number in\
    \ numbers\n        sum += abs(number-mean(numbers))\n    end\n    return sum/length(numbers)\n\
    end", "    if length(numbers)==0\n        error(\"Mean Absolute Deviation requires\
    \ at least one data point.\")\n    end\n    \n    let mean=mean(numbers)\n   \
    \ \n    return sum((x-mean)^2 for x in numbers)/length(numbers)\nend", "    \n\
    \    return mean(map(abs, numbers))\nend\n</cell>\n<text>\nVectorized Mean Absolute\
    \ Deviation\nIf you have many numbers, you may find this function is much more\
    \ efficient than looping over them. Vectorized mean-squared deviation is a mathematical\
    \ concept that generalizes the mean absolute deviation function.", "    sum::Float64\
    \ = 0.0\n    for value in numbers\n        sum += value\n    end\n    return sum\
    \ / Float64(length(numbers))\nend", "    sum_of_squares = 0.0 \n    for n in numbers\
    \ do \n        sum_of_squares += math.pow(n-mean(n),2)\n    avg = sum_of_squares/length(numbers)\
    \ \n    return math.sqrt(avg)\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nIf\
    \ this answered your question, you should accept it (click the check mark). This\
    \ will give reputation to the person who posted it, and others who will come to\
    \ this question later will know that it's been answered.\n<|/ c |>\n<| c |>\n\
    You also can use [`StatsBase`](https://github.com/JuliaData/StatsBase.jl) with\
    \ `mean(x)`.\n<|/ c |>\n<| a dscore=3 |>\nIf your array is big, you may want to\
    \ use map to compute mean quickly.\n<code>\nusing Statistics", "    return (Float64)mean(abs.(numbers\
    \ - mean(numbers)))\nend\n</cell>\n<cell>\n# export", "    numbers.mean()\nend\n\
    </cell>\n<text>\nExercise 3.13: Implement the function std_dev(numbers::Vector{Float64})\n\
    The function std_dev should calculate the standard deviation for a given\nvector\
    \ of numbers. The standard deviation is the square root of the\naverage of squaring\
    \ the differences between the numbers given and the\nmean of the numbers given.\n\
    Standard deviation is a measure of the variability of a set of numbers\naround\
    \ its mean.\nFor a sample of size n, calculate the standard deviation as follows,\n\
    $$\n\\sigma = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} (x_i - \\bar{x})^2}\n$$\nHere,\
    \ $\\bar{x}$ is the sample mean.\nStandard deviation is the square root of the\
    \ average of squaring the\ndifferences between the numbers given and the sample\
    \ mean.\nstd_dev should accept a vector of numbers and return its standard\ndeviation.\n\
    Standard deviation is a measure of the variability of a set of numbers\naround\
    \ its mean. For a sample of size n, calculate the standard\ndeviation as follows,\
    \ $$\\sigma = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} (x_i - \\bar{x})^2}$$\nHere,\
    \ $\\bar{x}$ is the sample mean.\nStandard deviation is the square root of the\
    \ average of squaring the\ndifferences between the numbers given and the sample\
    \ mean.\nExample: \nFor a sample of size 3 with elements [2, 3, 4] calculate the\
    \ standard\ndeviation as follows, $$\\sigma = \\sqrt{\\frac{1}{3} \\sum_{i=1}^{3}\
    \ (x_i - \\bar{x})^2}$$\nHere, $\\bar{x}$ is the sample mean 2.5.\nstd_dev([2.5,\
    \ 3, 4.0])\n2.0\nExample: \nFor a sample of size 3 with elements [2, 3, 4] calculate\
    \ the standard\ndeviation as follows, $$\\sigma = \\sqrt{\\frac{1}{3} \\sum_{i=1}^{3}\
    \ (x_i - \\bar{x})^2}$$\nHere, $\\bar{x}$ is the sample mean 2.5.\nstd_dev([2.5,\
    \ 3, 4.0])\n2.0\nExample: \nFor a sample of size 3 with elements [2, 3, 4] calculate\
    \ the standard\ndeviation as follows, $$\\sigma = \\sqrt{\\frac{1}{3} \\sum_{i=1}^{3}\
    \ (x_i - \\bar{x})^2}$$\nHere, $\\bar{x}$ is the sample mean 2.5.\nstd_dev([2.5,\
    \ 3, 4.0])\n2.0\nExample: \nFor a sample of size 3 with elements [2, 3, 4] calculate\
    \ the standard", "    total = 0.0\n    sum_of_squares = 0.0\n    for i in numbers\n\
    \        total += i\n        sum_of_squares += i**2\n    end\n    return total\
    \ / length(numbers) - sum_of_squares / length(numbers)\nend", "    result = 0.0\n\
    \    for number in numbers\n        result += abs ((number - mean(numbers)) )\n\
    \    end\n    result / length(numbers)\nend\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\n<code>\nusing Statistics", "  return mean(map((numbers-mean(numbers)).abs,\
    \ numbers))\nend\n</cell>\n<text>\nMean Absolute Deviation", "    mean_number\
    \ = mean(numbers)\n    return sum((numbers - mean_number).abs) / (length(numbers)\
    \ - 1)\nend\n</cell>\n<text>\nLet's test the mean absolute deviation function:",
  "    # Calculate the mean of the numbers\n    sum_of_squares = 0.\n    for x in\
    \ numbers\n        sum_of_squares += (x - mean(x))^2\n    end\n    return sqrt(sum_of_squares/length(numbers))\n\
    end\n</cell>\n<cell>\n# Run the code\n</cell>\n<cell>\n# TEST Calculate Mean Absolute\
    \ Deviation (2a)\nTest.assertTrue( mean_absolute_deviation([1,2,3]) == 1.0, \"\
    Mean Absolute Deviation does not work\" )\nTest.assertTrue( mean_absolute_deviation([1,2,3,4])\
    \ == 1.0, \"Mean Absolute Deviation does not work\" )\nTest.assertTrue( mean_absolute_deviation([1,-1,2,-2])\
    \ == 1.0, \"Mean Absolute Deviation does not work\" )\nTest.assertTrue( mean_absolute_deviation([1,-1,2,-2])\
    \ == 1.0, \"Mean Absolute Deviation does not work\" )\nTest.assertTrue( mean_absolute_deviation([1.0])\
    \ == 1.0, \"Mean Absolute Deviation does not work\" )\nTest.assertTrue( mean_absolute_deviation([1.5])\
    \ == 1.0, \"Mean Absolute Deviation does not work\" )\nTest.assertTrue( mean_absolute_deviation([1,2,3])\
    \ == 1.0, \"Mean Absolute Deviation does not work\" )\nTest.assertTrue( mean_absolute_deviation([-1.5])\
    \ == 1.0, \"Mean Absolute Deviation does not work\" )\nTest.assertTrue( mean_absolute_deviation([1,2,-3])\
    \ == 1.0, \"Mean Absolute Deviation does not work\" )\nTest.assertTrue( mean_absolute_deviation([-1.5,2.5,3.5])\
    \ == 1.0, \"Mean Absolute Deviation does not work\" )\n</cell>\n<text>\nProblem\
    \ 3\nWrite a function that will compute the kurtosis of the input data set.",
  "    \"\"\"\n    :param numbers: the data\n    :return: the MAD around the mean\n\
    \    \"\"\"\n    \"\"\"\n    Calculate the Mean Absolute Deviation.\n    \n  \
    \  For a given vector of input numbers, calculate Mean Absolute Deviation\n  \
    \  around the mean of this dataset.\n    Mean Absolute Deviation is the average\
    \ absolute difference between each\n    element and a centerpoint (mean in this\
    \ case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0,\
    \ 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\nend\n    ", "    sum = 0.0\n    for x\
    \ in numbers\n        sum += (x - mean(x))^2.0\n    div = length(numbers)\n  \
    \  return sum / (div * 1.0)\nend", "    _mean = mean(numbers)\n    _madev = sum([abs(x\
    \ - _mean) for x in numbers]) / length(numbers)\n    return _madev\nend", "  \
    \  \n    mean_number = mean(numbers)\n    return mean(map(abs, numbers-mean_number))\n\
    end\n</code>\n<|/ a tags=julia |>\n<| a dscore=2 |>\nAn alternative to writing\
    \ your own function and using it would be to use the Statistics.jl package, here\
    \ is an example using your data\n<code>\njulia> using Statistics", "    sum_abs\
    \ = 0\n    sum_abs_squared = 0\n    for n in numbers\n        sum_abs_squared\
    \ += n**2\n        sum_abs += n\n    \n    return sum_abs / (sum(numbers)-sum_abs_squared)",
  "    sum = 0\n    count = 0\n    for x in numbers:\n        sum += abs(x - mean(x))\n\
    \        count += 1\n    if count == 0\n        error(\"List is empty\")\n   \
    \ end\n    return sum / count\nend", "    return (sum(abs2(numbers - mean(numbers))))\
    \ / length(numbers)\nend\n</cell>\n<text>\nMean Absolute Deviation Coefficient\n\
    $$ MADc = \\displaystyle\\sum{x\\in\\mathbb{R}}|x - \\bar{x}|$$", "    # Calculate\
    \ mean of data\n    mean := mean(numbers)\n    # Calculate MAD using mean\n  \
    \  mad := 0.0\n    for x in numbers\n        diff = x - mean\n        mad = mad\
    \ + abs2(diff)\n    end\n    return mad\nend\n</cell>\n<text>\nMean Absolute Deviation\
    \ Coefficient (MAPD).\nThe MAPD is a measure of how similar the data is to a normal\
    \ distribution.\nMAPD = average | x - x_mean |\nThe MAPD can be calculated as\
    \ follows:\nMAPD = sum(x * [x - x_mean] ) / sum(x) * 1.0\nFor a list of values,\
    \ MAPD can be calculated by taking the sum of the absolute values\nof the difference\
    \ of the values from the mean and then dividing by the sum of the values.\nMAPD\
    \ can range from 0 to 1 where 0 indicates no difference and 1 indicates some \n\
    similarity. For example, with [2.0, 1.0, 0.0, 3.0, 4.0, 5.0], the mean would be\
    \ 2.0 \nand the MAPD would be 0.5.", "    numbers.mean(abs) + sqrt((numbers-mean(numbers)).^2./length(numbers))\n\
    end\n</cell>\n<text>\nThis code snippet takes advantage of the built-in map()\
    \ function, which applies a function to every element in a collection. map() can\
    \ take a function with a single argument that returns any number of values, and\
    \ returns a new collection of the same type with those values appended together.",
  "    return mean(abs(numbers - mean(numbers)))\nend", "    mean(abs(numbers - mean(numbers)))\n\
    end\n</cell>\n<text>\nExercise 13\nWrite a function max_in_vector that accepts\
    \ a vector and returns the max element of that vector. This function should use\
    \ reduce to solve the problem.", "    return mean(abs.(numbers - mean(numbers)))\n\
    end\n</cell>\n<text>\nExercise 3\nWrite a function that takes in a list of numbers\
    \ and returns the sum of the squares\nof the numbers. Write a test for this function.\n\
    To test your function, use the following numbers:\nnumbers = [1, 2, 3, 4, 5, 6,\
    \ 7]\nExpected output:\n22.25\n\"\"\"", "    abs_diff = Float64[]\n    for x in\
    \ numbers\n        abs_diff += abs(x - mean(x))\n    end\n    return mean(abs_diff)\n\
    end", "    sum_of_squares = 0.\n    for number in numbers\n        sum_of_squares\
    \ += (number - mean(number)) ^ 2\n    end\n    return sqrt(sum_of_squares/length(numbers))\n\
    end", "    \n    absDiff = numbers .- mean(numbers)\n    absDiff = absDiff ./\
    \ sum(absDiff)\n    return mean(absDiff) \nend ", "    return (sum([abs(x - mean(numbers))\
    \ for x in numbers]) / length(numbers)) \nend \n</cell>\n<text>\nMean Absolute\
    \ Deviation vs. Sample Size\nTo understand the performance of our MAD vs Sample\
    \ Size test, we compare these two metrics:", "    numbers = convert(Vector{Float64},\
    \ numbers)\n    ma = 0.0\n    for n in numbers\n        ma += abs(n - mean(n))\n\
    \    end\n    return ma / length(numbers)\nend\n</code>\nThe MAD function works\
    \ extremely well on large datasets and vectors containing tens of thousands of\
    \ floating point numbers. \n<code>\n# Calculate Mean Absolute Deviation of a dataset\
    \ and compare it with \n# the mean of the dataset\nmean_absolute_deviation([1.0,2.0,3.0,4.0])\
    \ \n# 1.0\n</code>\n<|/ a dscore=4 |>\n<| a |>\nI used the above answers but with\
    \ R:\n<code>\n# calculate mean from dataset\nmean <- rowMeans(dat)", "    sum\
    \ = 0.0\n    for n in numbers:\n        sum = sum + abs(n - sum)\n    return sum\
    \ / length(numbers)\nend\n</cell>\n<code language=julia-1.1>", "  local x = numbers\n\
    \  local mean = x[1]\n  for x in x[2:end]\n    local d = x - mean\n    local new_mean\
    \ = mean + d * d\n    mean =  new_mean / 2.0\n  end\n  return mean\nend\n</cell>\n\
    <text>\nMean Absolute Deviation is the average absolute difference between each\
    \ element and a centerpoint (mean in this case):", "    median = mean(numbers)\n\
    \    sum = 0\n    for i in numbers\n        sum += abs(i-median)\n    end\n  \
    \  return sum/length(numbers)\nend", "    len = length(numbers)\n    if len <\
    \ 2\n        error(\"Input vector must have at least two elements\") \n    end\n\
    \    sum(abs2(numbers - mean(numbers))) / len\nend", "    MAD = 0\n    for number\
    \ in numbers:\n        MAD = MAD + abs(number - mean(number))\n    return MAD\n\
    end #mean_absolute_deviation\n</cell>\n<code language=julia-0.4>\n#To use this\
    \ function, uncomment it below and run the cell\n#@code_native(pyfunc, pyfunc_arguments)\n\
    #pyfunc(pyfunc_arguments)\nmean_absolute_deviation([1,2,3])\n</cell>\n<code language=julia-0.4>",
  "    sum_abs = 0\n    for x in numbers \n        sum_abs += abs(x-mean(x))\n   \
    \ \n    return sum_abs / length(numbers)\nend", "    return mean(abs.(numbers\
    \ - mean(numbers)))\nend\n</cell>\n<text>\nNow, let's try it out with some numbers:",
  "    \"\"\"\n    Mean Absolute Deviation calculation\n    \"\"\"\n    sum = 0.0\n\
    \    N = length(numbers)\n    for n in numbers do\n        sum = sum + abs (n)\n\
    \    end\n    return sum/N\nend\n</cell>\n<code language=julia-1.0>\nmean_absolute_deviation([1.0,\
    \ 2.0, 3.0, 4.0])\n</cell>\n<text>\nMean Absolute Error (MAE) function", "\"\"\
    \"\n    Calculate the Mean Absolute Deviation (MAD) of a dataset.\n    MAD = average\
    \ | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n\
    \    \"\"\"", "  mean_number = mean(numbers)\n  mad =  sum((numbers-mean_number)^2)\n\
    \  return mad/length(numbers)\nend\n</cell>\n<code language=julia-1.3>\n@testset\
    \ \"mean_absolute_deviation\" begin\n  numbers = [1, 2, 3, 4, 5]\n  @test mean_absolute_deviation(numbers)\
    \ == 1\n  @test mean_absolute_deviation(numbers) == 1.5\n  @test mean_absolute_deviation(numbers)\
    \ == 2\n  @test mean_absolute_deviation(numbers) == 2.5\n  @test mean_absolute_deviation(numbers)\
    \ == 3\n  @test mean_absolute_deviation(numbers) == 3.5\n  @test mean_absolute_deviation(numbers)\
    \ == 4\n  @test mean_absolute_deviation(numbers) == 4.5\n  @test mean_absolute_deviation(numbers)\
    \ == 5\nend\n</cell>\n<code language=julia-1.3>\n@testset \"mean_absolute_deviation\"\
    \ begin\n  numbers = [1, 2, 3, 4, 5]\n  @test mean_absolute_deviation(numbers)\
    \ == mean(numbers)\nend\n</cell>\n<text>\nMedian Absolute Deviation\nMedian Absolute\
    \ Deviation in Julia can be implemented as follows", "    return sqrt(mean(abs2(numbers\
    \ - mean(numbers))))\nend", "    \"\"\" This function calculates mean absolute\
    \ deviation (MAD) \n    of a dataset \"\"\"\n    \n    size = length(numbers)\n\
    \    return sum((numbers - mean(numbers)).^2, 1/size) - mean(numbers.^2, 1/size)",
  "</code>\nI used this function to calculate the average deviation for the whole\
    \ dataset, and plot the results:\n<code>\n# Plotting \nscatter(vector, deviations)\n\
    plot!(means, deviations)\n</code>\nAnd the results are shown below:\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 |>\nOne way to do this would be to use cumsum from the base\
    \ package to accumulate running sum of square deviation from mean. Then use cumprod\
    \ to get the running product of deviation from mean:\n<code>\nimport Base.cumsum\n\
    import Base.cumprod", "    \n    # initialize sum\n    sum =0.0", "    numbers\
    \ = copy(numbers)\n    length = length(numbers)\n    sum = 0.0\n    for index\
    \ in 1:length\n        sum = sum + abs(numbers[index] - mean(numbers))\n    end\n\
    \    return sum / length\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThis answer\
    \ is incorrect, because `mean` is not applied to a vector. `mean(numbers)` will\
    \ compute an element of the vector `numbers` so you end up computing the mean\
    \ of `numbers` itself.\n<|/ c |>\n<| c |>\nThanks for your comment. I updated\
    \ the solution and I hope that it is now correct.\n<|/ c |>\n<| c |>\nThis is\
    \ now correct.\n<|/ c |>\n<| a |>\nYou can achieve this easily with the Statistics\
    \ package:\n<code>\njulia> using Statistics", "    return (numbers - mean(numbers))\
    \ .^ 2 ./ sqrt(length(numbers)) \nend \n</code>\n<|/ a dscore=2 |>\n<| a dscore=1\
    \ |>\n<code>\nusing Statistics\nusing LinearAlgebra", "    abs_devs = abs(numbers\
    \ - mean(numbers))\n    return mean(abs_devs)\nend", "  sum(abs2(numbers - mean(numbers))\
    \ / length(numbers)) / length(numbers)\nend", "  sum::Float64 = 0.0\n  for n in\
    \ numbers\n    sum += abs{n} - mean(n)\n  end\n  return(sum/length(numbers))\n\
    end\n  \n  ", "    return (Float64)mean(abs.(numbers-mean(numbers)))\nend\n</cell>\n\
    <text>\nMean Absolute Deviation on a Dataset", "    \"\"\" Calculate Mean Absolute\
    \ Deviation around a mean of a given dataset.\n    Mean Absolute Deviation is\
    \ the average absolute difference between each\n    element and a centerpoint\
    \ (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0,\
    \ 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "    # Calculate mean value\n    m_x\
    \ = np.mean(numbers)", "    mean_number = mean(numbers)\n    abs_devs = abs_diff(numbers,\
    \ mean_number)\n    ma = mean(abs_devs)\n    return ma", "    sum = 0.0\n    for\
    \ i in numbers\n        sum += abs(i - mean(numbers))\n    end\n    return sum/length(numbers)\n\
    end\n</code>\nThis function is written in Julia language (see the Julia documentation\
    \ here).\n<|/ a dscore=2 tags=statistics,julia,arrays |>\n<| c |>\nthanks, although\
    \ not exactly what I wanted, this is nice and clean and easy to understand\n<|/\
    \ c |>\n<| c |>\nYou're welcome. This is not exactly what you wanted, but it's\
    \ what you're looking for!\n<|/ c |>\n<| a dscore=1 tags=statistics,julia,arrays\
    \ |>\nThe first part is easy. Just get the mean using sum and len. \n<code>\n\
    mean(x) = sum(x)/length(x)\n</code>\nYou get the difference between each number\
    \ and the mean with map, and then take the mean of the map result. \n<code>\n\
    mean(map(abs(x-mean(x)), x))\n</code>\n<|/ a |>\n<| c |>\nthank you! I have used\
    \ your solution but edited it slightly.\n<|/ c |>\n<| a tags=statistics,julia,arrays\
    \ |>\n<code>\nusing Statistics\nusing Distributions\nusing StatsPlots\nusing DataFrames\n\
    using GLM\nusing CSV\nusing StatsBase", "    \"\"\"Calculate Mean Absolute Deviation\
    \ from vector \"\"\"\n    diff = numbers - mean(numbers)\n    MAD = sum(abs2(diff))\
    \ / (length(numbers)) \n    return MAD\nend", "\tsum(abs2, numbers)/length(numbers)\n\
    end\n</cell>\n<text>\nNow let's use our new mean_absolute_deviation function defined\
    \ above:", "    abs_diffs = map abs  (numbers-mean(numbers))\n    return mean(abs_diffs)\n\
    end", "    if length(numbers) == 0 \n        error(\"Not enough numbers. Cannot\
    \ calculate mean absolute deviation\")\n    end\n    \n    mean =  mean(numbers)\n\
    \    \n    return mean((numbers .- mean)\n            .* (numbers .- mean)) \n\
    end\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    ", "    sum = 0.0\n\
    \    for i in numbers\n        sum += abs(i - mean(i))\n    end\n    return sum\
    \ / length(numbers)\nend", "    # average of absolute differences between points\n\
    \    number_mean = mean(numbers)\n    abs = map(abs, numbers)\n    return sum(abs)\
    \ / length(abs) \nend", "    sum = 0.0\n    for i in numbers\n        sum = sum\
    \ + abs(i - mean(x))\n    end\n    return sum / length(numbers)\nend", "    center\
    \ = mean(numbers)\n    return sum(abs2(number - center) for number in numbers)\
    \ / length(numbers)\nend\n</cell>\n<text>\n4.5.2 Mean Absolute Error\nIn statistics,\
    \ Mean Absolute Error or MAE is a measurement of how far the errors between two\
    \ variables are from a mean. This quantity can be thought of as distance, with\
    \ the mean (or median) being our reference quantity."]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
