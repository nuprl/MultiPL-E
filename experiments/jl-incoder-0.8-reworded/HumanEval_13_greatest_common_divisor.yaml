name: HumanEval_13_greatest_common_divisor
language: jl
prompt: "\"\"\" Return a greatest common divisor of two integers a and b\n    >>>\
  \ greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n\
  \    5\n    \"\"\"\nfunction greatest_common_divisor(a::Int64, b::Int64)::Int64\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = greatest_common_divisor;\n\t@test(candidate(3,\
  \ 7) == 1)\n\t@test(candidate(10, 15) == 5)\n\t@test(candidate(49, 14) == 7)\n\t\
  @test(candidate(144, 60) == 12)\nend\n"
completions: ["</code>\n<|/ a dscore=0 |>\n<| c |>\nNote that `gcd x y = x \\oplus\
    \ y` but `gcd(x,y) \u2260 (x \\oplus y)`.\n<|/ c |>\n<| c |>\n`greatest_common_divisor`\
    \ can be written as `gcd_((a, b)) = (a \u2295 b) \u2295 (a \u2227 b)`\n<|/ c |>\n\
    <| c |>\nI see. I was thinking of `greatest_common_divisor` as a `greatest_common_divisor_or_zero`\
    \ function but in fact it actually is a `greatest_common_divisor` function :)\n\
    <|/ c |>\n<| a tags=math,greatest-common-divisor,haskell,algorithm,function dscore=0\
    \ |>\nThis code gives correct results, but I think it can be improved. Can anyone\
    \ help?\n<code>\ngcd :: Int -> Int -> Int\ngcd x y = gcd_(x, y)\n    where \n\
    \      gcd_ :: Int -> Int -> Int\n      gcd_ x y = let \n                a ::\
    \ Int\n                a = if x == y then 0 else x\n                b :: Int\n\
    \                b = if x > y then x else y\n            in if (a > b) then a\
    \ else b\n</code>\n<|/ a |>\n<| a dscore=0 tags=math,greatest-common-divisor,haskell,algorithm,function\
    \ |>\nHere are some ways to do this.\n<code>\ngreatestCommonDivisors :: Int ->\
    \ Int -> [Int]\ngreatestCommonDivisors x y = \n    let a = [x,y]\n        b =\
    \ [x,y]\n        c = zip a b\n        c /= [] &&& flip elem (head c) c\n     \
    \   -- or c = zipWith (\\(a,b) (c,d) -> if c == d then [a,b] else []) a b\n  \
    \      -- or c = zipWith (\\(a,b) (c,d) -> if c == d then [a,b] else [a,c])\n\
    \        -- or c = zipWith (\\(a,b) (c,d) -> if c == d then [a,b] else [b,c])\n\
    \        -- or c = zipWith (\\(a,b) (c,d) -> if c == d then [a,b] else [a])\n\
    \        -- or c = zipWith (\\(a,b) (c,d) -> [a,b])\n        -- or c = zipWith\
    \ (\\", "    if a < b\n        then return a\n        else return b\n    else\n\
    \        then return greatest_common_divisor(b,a%b)\n    end\nend\n</cell>\n<code\
    \ language=julia-1.6>\ngreatest_common_divisor(6, 4)\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function to return the sum of all the elements in a given vector",
  "    greatest_common_divisor_helper(a, b, 0, 0, 0)\nend", "    if a == 0 || b ==\
    \ 0 \n        return a \n    elseif b == 0 \n        return a \n    else \n  \
    \      return greatest_common_divisor(a / b, b)", "    if a > b\n        (a, b)\
    \ = (b, a)\n    for x in divisors(b)\n        if a % x == 0\n            return\
    \ x\n    return a\n</code>\nThe for loop will iterate over all prime numbers in\
    \ range from 2 to the divisors of b. \nThe if condition will check if the number\
    \ a divides b. \nIf it does, then we return the divisor and break the for loop.\
    \ \nIf it doesn't, then we return the larger of the two numbers. \n(Note that\
    \ the return in the else condition is not needed. It would be more logical to\
    \ have it inside the loop. But since we are using laziness, that won't matter\
    \ in this case.)\n<|/ a tags=primes,integer-division,prime-factoring,julia |>\n\
    <| a dscore=1 |>\n<code>", "    if b == 0 \n        == 1 \n    else \n       \
    \ == gcd(a, b) \n    end\nend\n</code>\n<|/ q dscore=0 |>\n<| c |>\nPlease don't\
    \ add extra spaces or newlines to your code. Instead, just indent it 4 spaces\
    \ (use backticks to mark it as a code block). Also, please provide a [mcve] including\
    \ the error message.\n<|/ c |>\n<| c |>\n\"Please help...\" is not a problem description\n\
    <|/ c |>\n<| c |>\nPlease have a look at [ask] and how to provide a [mcve].\n\
    <|/ c |>\n<| c |>\nPlease see \"[ask]\" and the linked pages and \"[mcve]\", and\
    \ edit your post accordingly.  In particular, include the code that causes the\
    \ error.\n<|/ c |>\n<| c |>\nPlease provide code snippets that reproduce the problem\
    \ you are having.\n<|/ c |>\n<| a |>\nYour function does not return anything.\
    \ Perhaps you want to return greatest_common_divisor(b,a). But this would return\
    \ an Int64 and not a String. \nYou also don't have to give the type annotation\
    \ if the function returns an Int64.\n<|/ a tags=julia,function dscore=2 |>\n<|\
    \ c |>\nThank you very much for your answer. Your answer helped me to understand\
    \ my mistakes.\n<|/ c |>\n<| a dscore=2 |>\nYou're missing a return statement.\
    \ Here is an example of a function returning nothing:\n<code>", "    if a==0 ||\
    \ b==0 \n        then return 0\n    else \n        if a==b\n            then return\
    \ a\n        else\n            if a>b\n                then return greatest_common_divisor(b,a%b)\
    \ \n            else \n                return greatest_common_divisor(a,b%a)\n\
    end\n</cell>\n<text>\nExercise 4\nWrite a function, is_prime(integer) which will\
    \ test if a given integer is a prime number or false if not.", "    if b == 0\
    \ \n        then a\n    else greatest_common_divisor(b, a % b)\nend\n</cell>\n\
    <code language=julia-1.0>\ngreatest_common_divisor(31, 55)\n</cell>\n<code language=julia-1.0>\n\
    @code_native greatest_common_divisor_native(31, 55)\n</cell>\n<text>\nGreatest\
    \ common divisor is often used to get the smallest common multiple of two or more\
    \ integers. For example, the smallest common multiple of two integers a and b\
    \ is the largest integer not evenly divisible by both a and b. Here are two implementations\
    \ of this function:", "    return a // b\nend\n</cell>\n<code language=julia-1.3>\n\
    @time for n in 1:10^5\n    greatest_common_divisor(7, n)\nend\n</cell>\n<text>\n\
    Exercise 4\nWrite a function that returns the greatest common divisor of three\
    \ integers a b c\nHint: You can use the function greatest_common_divisor you wrote\
    \ previously", "  if (b == 0)\n    return a\n  else\n    return greatest_common_divisor(b,\
    \ a % b)\nend\n</cell>\n<code language=julia-1.5>\n@testset \"Greatest Common\
    \ Divisor Tests\" begin\n@test greatest_common_divisor(6, 7) == 3\n@test greatest_common_divisor(21,\
    \ 25) == 5\n@test greatest_common_divisor(9, 12) == 2\n@test greatest_common_divisor(3,\
    \ 5) == 1\n@test greatest_common_divisor(25, 15) == 5\nend\n</cell>\n<text>\n\
    Write a function to return the smallest common multiple of two integers a and\
    \ b\nWrite a function to find if a number is a prime number (i.e. it can only\
    \ be divided by 1 and itself.", "    \"\"\" Return a greatest common divisor of\
    \ a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25,\
    \ 15)\n    5\n    \"\"\"", "    if a==0 then return b else greatest_common_divisor(b,a%b)\n\
    </code>", "    if a == 0 || b == 0 \n        return a \n    \n    greatest_common_divisor(a\
    \ div b, b) \n    if a % b == 0 \n        return b \n    \n    greatest_common_divisor(b,\
    \ a div b) \n    if a % b == 0 \n        return b \n    \n    greatest_common_divisor(b,\
    \ b div a) \n    if a % b == 0 \n        return b \n    \n    greatest_common_divisor(b,\
    \ a) \n    return a \nend\n</code>\n<|/ a |>\n<| c |>\nOh, this one is really\
    \ good too. One thing though, you might want to add some more checks for when\
    \ `a` and `b` are equal to 0, because you'll be dividing by 0, and then you'll\
    \ have nothing to divide by. Also a little weird to call the function `greatest_common_divisor`,\
    \ since that's a function in Julia.\n<|/ c |>\n<| c |>\nThis won't work for `greatest_common_divisor(5344,\
    \ 8331)`\n<|/ c |>\n<| c |>\nThe correct answer is `5344, 8331`, because `greatest_common_divisor(5344,\
    \ 8331)` is `5344`.\n<|/ c |>\n<| a tags=algorithm,julia |>\nI believe that there\
    \ is a more concise solution, but I cannot really give it since I do not know\
    \ Julia enough.\nAnyway, here is my proposal (I leave the function body to you\
    \ as a bonus).  \nFirst, it is important that you use the mod operator instead\
    \ of the div operator, because if you use the div operator and pass 0 as the second\
    \ parameter, the code will throw an error. \nSecond, you can use the recurrence\
    \ relation to calculate the GCD by yourself. To do so, you can use this formula:\n\
    <code>\n  GCD(a, n) = (n <= 0) ? a : GCD(gcd(a, n % a), n)\n</code>\n(Here you\
    \ have the gcd function coded here for you: julia> gcd(9,6)\n    2)\n    3)\n\
    \    4)\n    5)\n    6)\n    8)\n    9)\n    10)\n    11)\n    12)\n    13)\n\
    \    14)\n    15)\n    16)\n    17)\n    18)\n    19)\n    20)\n    21)\n    22)\n\
    \    23)\n    24)\n    25)\n    26)\n    27)\n    28)\n    29)\n    30)\n    31)\n\
    \    32)\n    33)\n    34)\n    35)\n    36", "    if a * b == a // b \n    then\
    \ a // b \n    else greatest_common_divisor(a // b, b) \nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| a dscore=4 |>\nFor a general integer n x x x x x x... (x x x x x x x\
    \ x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x\
    \ x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x\
    \ x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x\
    \ x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x\
    \ x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x\
    \ x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x\
    \ x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x\
    \ x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x\
    \ x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x\
    \ x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x\
    \ x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x\
    \ x x x x x x x x x x x x x x x x x x x x x x x x x x ", "    \"\"\"\n    greatest_common_divisor(a::Int64,\
    \ b::Int64)::Int64", "    if a < b\n        then greatest_common_divisor(b, a)\n\
    \    else\n        gcd(a,b)", "    return (a // b) if (b % a == 0) else (a //\
    \ b)\nend\n</code>\n<|/ a tags=julia |>\n<| a tags=julia |>\nThe other answers\
    \ use // which is very nice but if you use integer division (i.e.: when you don't\
    \ want your result to be float) you need to make sure that your numbers are big\
    \ enough to avoid overflow and that there exist integers with exactly the minimum\
    \ number of decimal places you need.\nIn Julia 1.7 there is an isa() function\
    \ that will return true if the variable is really an integer.\n<code>", "    \"\
    \"\"Return a greatest common divisor of two integers a and b\"\"\"\n    return\
    \ b % a if a > b else a\n</code>\nAnd finally to test this function:\n<code>\n\
    julia> greatest_common_divisor(3,4)\n2\njulia> greatest_common_divisor(15,25)\n\
    5\n</code>\n<|/ a dscore=3 tags=function,julia,if-statement |>\n<| a tags=function,julia,if-statement\
    \ |>\nSince Julia 0.6 you can define a binary operator in Julia, which then allows\
    \ to write your function as a one-liner. \n<code>\njulia> +(a, b) = (a * b); #\
    \ Same as a = a * b\njulia> -(a, b) = (a * b * b) ; # Same as a = a * b * b\n\
    julia> /(a, b) = (a * b) ; # Same as a = a * b\n</code>\nOf course you can also\
    \ define this operator for custom types. Check out this link to Julia documentation.\n\
    <|/ a dscore=3 |>\n<| a dscore=3 |>\nYou don't need any special syntax for this\
    \ in Julia. You just need to remember that you can define a function in terms\
    \ of other functions, as long as they are all defined. For example,\n<code>",
  "    \"\"\"\n    greatest_common_divisor(a::Int64, b::Int64)::Int64", "    if a\
    \ < b\n        greatest_common_divisor(a+1, b) \n    elseif b < a\n        greatest_common_divisor(a,\
    \ (b+1)) \n    else\n        a\n    end\nend\n</code>\n<|/ a tags=julia |>\n<|\
    \ c |>\nThis is incorrect. `greatest_common_divisor(3,5)` returns `1` but should\
    \ return `3` because `greatest_common_divisor(3,4)` is `3`\n<|/ c |>\n<| c |>\n\
    Thanks for pointing this out, I've updated my answer\n<|/ c |>\n<| a dscore=1\
    \ |>\nI personally found this implementation to be the most elegant:\n<code>\n\
    gcd2(a, b) =\n    if b <= 0 \n        abs(a)\n    else\n        gcd(a, b % abs(a))\n\
    \    end\n</code>\n<|/ a tags=julia |>\n<| c |>\nThat works correctly and is more\
    \ efficient than the accepted answer. However, you missed a case of `gcd(a, 0)`\
    \ which is `abs(a)`. A simple change to my answer would make it more robust: `gcd2(a,\
    \ b) =\n    if b <= 0 \n        abs(a)\n    else\n        gcd(a, b % abs(a))\n\
    \    end\n<|/ c |>\n<| c |>\nGood catch! I missed that one. I've edited the answer.\n\
    <|/ c |>\n<| a tags=julia |>\nThe first thing is that I suggest you use Julia's\
    \ syntax for function definitions:\n<code>\ngreatest_common_divisor(a, b) =\n\
    \    if a < b\n        greatest_common_divisor(a+1, b)\n    elseif b < a\n   \
    \     greatest_common_divisor(a, b)\n    else\n        a\n    end\n</code>\nThe\
    \ second thing is that it might be more efficient to calculate gcd only once instead\
    \ of twice.\n<code>", "    if b == 0 \n        then return a\n    else \n    \
    \    return greatest_common_divisor(b, a%b) \nend\n</cell>\n<code language=julia-1.2>\n\
    @assert greatest_common_divisor(2, 2) == 2\n@assert greatest_common_divisor(2,\
    \ 5) == 5\n@assert greatest_common_divisor(36, 100) == 6\n@assert greatest_common_divisor(8,\
    \ 5) == 3\n@assert greatest_common_divisor(25, 15) == 5\n</cell>\n<text>\nExercise\
    \ 3.4\nFor a given positive integer $x$, write a function that returns the remainder\
    \ of $x/2$ and $x$ if the remainder is even. Write this function in Julia without\
    \ using any conditional statements, loops, or recursion (unless absolutely necessary).\
    \ Assume that the input is a real number and the output is an integer or float.",
  "    \"\"\" Return the greatest common divisor of two integers a and b\n    >>>\
    \ greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n\
    \    5\n    \"\"\"", "    if a == 0 \n        then return b \n    else \n    \
    \    if b == 0 \n            then return a\n        else \n            greater_common_divisor(a,\
    \ greatest_common_divisor(b,a % b)) \nend\n</cell>\n<cell>\n# Problem 6", "  \
    \  if b == 0 \n        return a\n    else \n        return greatest_common_divisor(b,\
    \ a % b)\n</code>\n<|/ a |>\n<| a tags=recursion,haskell,functional-programming\
    \ |>\n<code>\ngreatest_common_divisor :: (Integral a) => a -> a -> a\ngreatest_common_divisor\
    \ x y = max x y\n  where gcdx y = if y == 0 then x else gcdx (y `mod` x)\n   \
    \     gcdy x = if x == 0 then y else gcdy (x `mod` y)\n</code>\n<|/ a dscore=5\
    \ |>\n<| a |>\n<code>\ngreatestCommon :: Int -> Int -> Int\ngreatestCommon a b\n\
    \   | a > b     = error \"wrong arguments\"\n   | a == b    = a\n   | otherwise\
    \ = 1 + greatestCommon (mod a b) (mod b a)\n</code>\n<|/ a dscore=4 tags=recursion,haskell,functional-programming\
    \ |>\n<| c |>\nThat isn't the greatest common divisor.\n<|/ c |>\n<| c |>\n- it\
    \ is the greatest common divisor of 2 numbers, which is what the question asks\
    \ for.\n<|/ c |>\n<| c |>\nGreat. Now it is the greatest common divisor of two\
    \ numbers. BTW, your code is O(n^2).\n<|/ c |>\n<| c |>\n- Thanks for commenting!\
    \ I corrected the code now.\n<|/ c |>\n<| c |>\nNo need for the `a > b` guard.\
    \ `a == b` is sufficient.\n<|/ c |>\n<| a tags=recursion,haskell,functional-programming\
    \ dscore=4 |>\nI used the solutions above to solve my problem. \nThey all were\
    \ correct, but they didn't have explanations for what they did.\nHere are my solutions.\n\
    <code>\ngreatestCommon :: Int -> Int -> Int\ngreatestCommon a b\n   | b == 0 ||\
    \ a == 0    = a\n   | otherwise             = 1 + greatestCommon (mod a b) (mod\
    \ b a)\n</code>\nThis solution uses recursion. The function takes two numbers\
    \ and returns their greatest common divisor, if the two numbers are equal to zero\
    \ then return a. Otherwise, we take the remainder of the first number and divide\
    \ it by the second number recursively, and add 1 to the result.\n<code>\ngreatestCommon\
    \ :: Int -> Int -> Int\ngreatestCommon a b", "    if (b == 0) then\n        return\
    \ a\n    elseif (b < 0) then\n        return greatest_common_divisor(b, a mod\
    \ b)\n    else\n        return greatest_common_divisor(b, a div b)", "    | 0\
    \ == b = a\n    | 0 == a = b\n    | a > b\n    = 1\n    | otherwise\n    = gcd(a,\
    \ b) \n    where\n    gcd(a, 0) = a\n    gcd(a, b) = gcd(b, a % b)\n    gcd(0,\
    \ a) = a\n    gcd(0, b) = b\n    \"\"\"\n</cell>\n<text>\n3.3 Greatest Common\
    \ Divisor of a and b\nA common feature of mathematics is the division of two integers\
    \ $a \\times (b) $ . The Greatest Common Divisor of $a$ and $b$ is the largest\
    \ integer $r \\in \\mathbb{N}$ such that $a = r \\times b$ and $b \\times r$.\
    \ Write a function that returns the greatest common divisor of a and b", "   \
    \ \"\"\" Return greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3,\
    \ 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"", "  \
    \  \"\"\"Greatest common divisor\n    \"\"\"\n    gcd = gcd(a, b)\n    if gcd\
    \ == a:\n        return b\n    elif gcd == b:\n        return a\n    else:\n \
    \       return gcd(a, b)\n    end\nend", "    if a <= 0 or b <= 0 \n        then\
    \ error \"Arguments cannot be <= 0\"\n    else\n        function gcd(a::Int64,\
    \ b::Int64)::Int64\n            if a <= 0 || b <= 0 \n                then error\
    \ \"Arguments cannot be <= 0\"\n            else\n                if b == 0 \n\
    \                    then return a\n                else\n                   \
    \ function gcd(a::Int64, b::Int64)::Int64\n                        let tmp::Int64\
    \ = greatest_common_divisor(b, a mod b)\n                        if a > b \n \
    \                           then return tmp\n                        else return\
    \ gcd(a, tmp)\n                end\n            end\n        end\n        return\
    \ gcd(a, b)\n    end\nend\n</cell>\n<text>\nExercise 3\nWrite a function to find\
    \ the smallest integer that is evenly divisible by the number of days between\
    \ two dates. For example, if the first date is 1/1/2016 and the second date is\
    \ 2/20/2016, then the function should return 7/20.", "    if b == 0 || a % b ==\
    \ 0\n        then\n            1\n        else\n            greatest_common_divisor(b,\
    \ a % b)\n    end\nend", "    if a == 0 then return b\n    if b == 0 then return\
    \ a\n    else return greatest_common_divisor(b, a mod b)\nend \n</code>\n<|/ a\
    \ tags=greatest-common-divisor,julia,performance |>\n<| c |>\nThanks for sharing\
    \ your implementation. Does it have a name ? How did you come up with it ? Is\
    \ there an online resource that I can refer to for this implementation ?\n<|/\
    \ c |>\n<| a dscore=3 |>\n<code>", "    \"\"\"\n    Return the greatest common\
    \ divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n   \
    \ 1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"", "if b == 0 then\n\
    \    return a\nelseif b > a then\n    return greatest_common_divisor(b, a % b)\n\
    else\n    return greatest_common_divisor(b, (a-a) % b)\nend\nend\n\"\"\"\n\"\"\
    \"\nReturns the greatest common divisor of a and b.\n\"\"\"", "  \"\"\"Greatest\
    \ common divisor of two integers a and b\n  \"\"\"\n  if a == 0 || b == 0\n  \
    \  return 1\n  else if b <= a\n    return greatest_common_divisor(a-1, b)\n  else\n\
    \    return greatest_common_divisor(b-1, a)", "    greatest_common_divisor = \n\
    \    if a > b\n        greatest_common_divisor(greatest_common_divisor(b, a),\
    \ a)\n    else\n        greatest_common_divisor(a, greatest_common_divisor(b,\
    \ b))\nend", "    if (b == 0)\n        return 0\n    if (a == 0)\n        return\
    \ 0\n    if (b == 1)\n        return a\n    if (a > b)\n        big, small = a,\
    \ b\n    else\n        big, small = b, a\n    \n    factor1 = greatest_common_divisor(big,\
    \ small)\n    factor2 = greatest_common_divisor(big, small)\n    \n    while (factor2\
    \ > factor1)\n        if ((factor1 %% factor2) == 0)\n            return factor2\n\
    \        factor1 += 1\n        factor2 += 1\n    end", "# GREATER-COMMON-DIVISOR\n\
    \    guard (a >= 0 && b >= 0)\n    guard b == 0 || a % b == 0\n    if b == 0 \n\
    \        guard a == 0\n        return a\n    else \n        return greatest_common_divisor(b,\
    \ a % b)\nend\n</cell>\n<text>\nLet's try it out", "    if a > b\n        a, b\
    \ = b, a\n    \n    a, b = abs(a), abs(b)\n    while a != 0\n        a, b = b,\
    \ (a // b)\n    return b\nend", "    if b == 0 \n        then return a\n    else\
    \ \n        c := greatest_common_divisor(b, a % b)\n        return if a == c then\
    \ b else c", "    if a > b\n        (a,b) = (b, a)\n    \n    while a != 0\n \
    \       (a, b) = (b, a % b)\n    end\n    return b\nend", "    if b == 0 \n  \
    \  then return a\n    else if b > a \n    then greatest_common_divisor(b, a-1)\
    \ \n    else greatest_common_divisor(a-1, b)\nend\n</code>\n<|/ a tags=recursion,julia,function,if-statement\
    \ dscore=3 |>\n<| a dscore=3 |>\nThe function you gave does work, but is too complicated\
    \ and does not look nice (at least, I do not know Julia very well, only Python).\
    \ I will suggest the following code:\n<code>", "    if a==0 \n    then\n     \
    \   gcd := b\n    else if b==0\n    then\n        gcd := a\n    else\n       \
    \ gcd := greatest_common_divisor(b, a % b)\n    end\n    return gcd\nend\n</code>\n\
    <|/ a dscore=1 tags=julia,recursion,performance |>\n<| c |>\nThanks for the answer!\
    \ But it seems like my code gets stuck at some point sometimes. I tried to find\
    \ out what was the reason, but it seems my code just doesn't work right...\n<|/\
    \ c |>\n<| c |>\nI've fixed the bug in my code (I had `if b==0` instead of `if\
    \ b==0==0`, which of course meant it would never stop the recursion). The code\
    \ I posted runs correctly on my machine, so if it doesn't work for you, I'd try\
    \ changing your implementation to the one I posted - maybe there's a subtle bug\
    \ you're overlooking.\n<|/ c |>\n<| c |>\nThanks a lot for the answer! I fixed\
    \ my code based on the one you provided but it still doesn't work properly...\
    \ Maybe there's something wrong with my code?\n<|/ c |>\n<| c |>\nI have no idea\
    \ what could be wrong with it. The code I posted runs correctly on my machine\
    \ and I copy-pasted it exactly as it's written. Are you sure you copy-pasted the\
    \ code correctly? Also, do you mind sharing the specific error you're getting\
    \ with the code I posted? Just edit your original post and add that information\
    \ there.\n<|/ c |>\n<| c |>\nOh! I got it now... It's not recursion... Thanks\
    \ a lot for your help!\n<|/ c |>\n<| a dscore=0 tags=julia,recursion,performance\
    \ |>\nYou can use a while loop to repeatedly divide the first number by the second\
    \ until they are equal:\n<code>", "    if (a%b==0):\n        return b\n    else:\n\
    \        return greatest_common_divisor(b,a%b)\nend", "    if b==0 \n        then\n\
    \            println(\"The Greatest Common Divisor of \",a,\" \",b,\"is \",1)\n\
    \        else\n            greatest_common_divisor(b,a%b)\n        end\n    else\n\
    \        greatest_common_divisor(b,a%b)\n    end\nend", "    \"\"\"Compute the\
    \ greatest common divisor of two integers \n    a and b\"\"\"\n</code>\n<|/ a\
    \ tags=julia,function,greatest-common-divisor dscore=2 |>\n<| a dscore=1 |>\n\
    I did a simple recursive function which works on integers and doesn't use any\
    \ packages. \n<code>", "    if b == 0\n    then return a\n    else return greatest_common_divisor(b,\
    \ a%b)\n    end\n</code>\nAs you can see it returns 1 because 5 and 3 are the\
    \ greatest common divisors.\n<|/ a tags=math,recursion,python dscore=0 |>\n<|\
    \ c |>\nThis won't work if `b == 0`. You have to do `if b == 0 then return a`\n\
    <|/ c |>\n<| c |>\nHe doesn't have a problem with 0. He just wants to find the\
    \ greatest common divisor, not the greatest common divisor of 0 and 1.\n<|/ c\
    \ |>\n<| c |>\nI apologize, I didn't read properly. I was thinking about this\
    \ problem and assumed it would work. I'll correct it.\n<|/ c |>\n<| a dscore=0\
    \ |>\nI assume that you actually want to find the greatest common divisor of some\
    \ numbers, not just the GCD of two numbers that may or may not both be zero.\n\
    <code>\ndef greatest_common_divisor(a: int, b: int) -> int:\n  if b == 0:\n  \
    \  return a\n  return greatest_common_divisor(b, a%b)\n</code>\n<|/ a tags=math,recursion,python\
    \ |>\n<| c |>\nThis would return 1 for both 5 and 3. As 5 and 3 are the greatest\
    \ common divisors of 5 and 3.\n<|/ c |>\n<| c |>\nWhat are you talking about?\n\
    <|/ c |>\n<| c |>\nThis does **not** work: `greatest_common_divisor(5, 3)` returns\
    \ 1 instead of 5.\n<|/ c |>\n<| c |>\nI thought I said that.\n<|/ c |>\n<| c |>\n\
    The OP says \"I don't need help with finding greatest common divisors of 1 and\
    \ 1\". That's why I assumed they were interested in the GCD of numbers that may\
    \ or may not both be zero, just as they say in their question.\n<|/ c |>\n<| a\
    \ tags=math,recursion,python |>\n<code>\ndef gcd(a: int, b: int) -> int:\n   \
    \ if b == 0:\n        return a\n    else:\n        return gcd(b, a%b)\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis doesn't work. Try it with `gcd(5, 3)`.\n<|/ c\
    \ |>\n<| c |>\nIt doesn't, but OP's code does `if b == 0 then return a`. And that\
    \ return statement is what makes it work.\n<|/ c |>\n<|", "    if a==0 || b==0\
    \ \n        then return a\n    else if a>b \n        then return greatest_common_divisor(b,a%b)\n\
    \        else return greatest_common_divisor(a,b%a)\n    endif\nendfunction",
  "    if b == 0 \n        then return a\n        \n    else \n        return greatest_common_divisor(b,\
    \ a % b)\n    \nend greatest_common_divisor\n</cell>\n<text>\nExercise 4 (6 Points)\n\
    Write a function that computes fibonacci numbers. You will need to implement the\
    \ function using recursion.", "</code>\n<|/ a dscore=2 tags=julia |>\n<| a |>\n\
    Julia has a built-in library for this: gcd\nJust write: \n<code>\ngcd(x, y)\n\
    </code>\n<|/ a dscore=2 tags=julia |>\n<| a dscore=1 |>\nThis is an old question,\
    \ my answer was given for older versions of Julia but here it is:\n<code>", " \
    \   if a < b\n    then greatest_common_divisor(b, a % b)\n    else a\n    end\
    \ \nend\n</cell>\n<code language=julia-1.1>\n@assert greatest_common_divisor(17,\
    \ 18) == 3\n@assert greatest_common_divisor(7, 13) == 2\n@assert greatest_common_divisor(8,\
    \ 24) == 4\n@assert greatest_common_divisor(34, 21) == 3\n@assert greatest_common_divisor(19,\
    \ 4) == 1\n@assert greatest_common_divisor(100, 110) == 10\n@assert greatest_common_divisor(5,\
    \ 5) == 0\n</cell>\n<code language=julia-1.1>", "    if a==0 || b==0\n       return\
    \ 0\n    elseif a>b\n       return greatest_common_divisor(b,a)\n    else\n  \
    \     return greatest_common_divisor(a,b)\n    end\nend", "    \"\"\"\n    Return\
    \ a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3,\
    \ 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n    return\
    \ greatest_common_divisor(a >= 0 ? a : -a, b >= 0 ? b : -b)", "    greatest_common_divisor\
    \ = if b == 0 then\n                             a\n                         else\n\
    \                             greatest_common_divisor(a%b, b)\n              \
    \       end\n    return(greatest_common_divisor)\nend\n</cell>\n<code language=julia-1.3>",
  "    if b == 0 \n        return a \n    else \n        return greatest_common_divisor(b,\
    \ a % b) \nend\n</cell>\n<code language=julia-1.4>\n# Exercise 1\n\"\"\"\nWrite\
    \ a function `sum_of_digits(x::Int64)` that returns the sum of the\n    digits\
    \ of an integer `x`. The result should be returned as an `Int64`.\n\"\"\"", "\"\"\
    \"\nGreatest Common Divisor\n    \n    Computes the greatest common divisor of\
    \ a and b\n    >>> greatest_common_divisor(2, 3)\n    1\n    >>> greatest_common_divisor(5,\
    \ 10)\n    5\n    \"\"\"", "    greatest_common_divisor = (min a b)\nend\n</code>\n\
    <|/ a dscore=1 tags=julia |>\n<| a dscore=1 |>\nThe above solutions did not work\
    \ for me because I was getting a stack overflow error.  Here is what I ended up\
    \ doing to fix it:\n<code>", "    if a > b\n        return greatest_common_divisor(b,\
    \ a%b)\n    else\n        return a", "    if a==0\n        then return b\n   \
    \ else if a > b\n        then return greatest_common_divisor(b,a%b)\n        else\
    \ return greatest_common_divisor(a,b%a)\n</code>\n<|/ a tags=julia,bigint |>\n\
    <| c |>\nWhy are you dividing `b` by `a` in the recursive calls?\n<|/ c |>\n<|\
    \ a dscore=4 |>\nAs of Julia 0.5, this has been implemented:\n<code>", "    \"\
    \"\"\n    Implements the greatest common divisor of two integers a and b\n   \
    \ >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25,\
    \ 15)\n    5\n    \"\"\"", "    \"\"\"\n    Calculate the greatest common divisor\
    \ of two integers \n    a and b with \n    \"\"\"\n    \n    gcd_(a, b) = \n \
    \       if (a > b)\n            gcd(a - b, b)\n        else\n            gcd(b,\
    \ a - b)\n    gcd_(a, b)\nend\n</cell>\n<code language=julia-0.3>\n@doc gcd\n\
    </cell>\n<code language=julia-0.3>\n@doc greatest_common_divisor\n</cell>\n<text>\n\
    Exercise 1\nImplement the function modular_inverse(a, b) which will return the\
    \ modular inverse of a modulo b.", "    if a == 0 || b == 0\n        0\n    else\n\
    \        greatest_common_divisor(b, a % b)\nend\n</code>\n<|/ a dscore=3 tags=julia\
    \ |>\n<| c |>\nThis code is slightly incorrect in the case where `a` equals `b`.\n\
    <|/ c |>\n<| c |>\nI agree, but I think this should be fixed now that it works\
    \ for most cases\n<|/ c |>\n<| c |>\nThe issue in the case where `a` and `b` are\
    \ equal (and both are `0`) is the same as in the case where `a` and `b` are both\
    \ `1`. This code will return `1` instead of `a` (which should also be `1`).\n\
    <|/ c |>\n<| a dscore=3 |>\nI believe that is a good way to do it, unless you\
    \ need to get that value very often and want to optimise a bit. \nIt will also\
    \ prevent you from using a loop.\n<code>", "    \n    if a > b\n        return\
    \ greatest_common_divisor(b, a)\n    \n    divisor = a\n    \n    while b != 0\n\
    \        divisor = b % divisor\n        b = div(b, divisor)\n    end\n    \n \
    \   return divisor\nend", "  \n    if a<b\n      return a\n    return greatest_common_divisor(b,a%b)\n\
    end\n    ", "    # Your code here\n    if a==0 || b==0\n        return 0\n   \
    \ \n    \n    if a>b\n        a,b = b,a\n        \n    if a%b==0\n        return\
    \ b\n    else\n        return greatest_common_divisor(b,a%b)\n    \n    \n   \
    \ \n# Write a function that returns the sum of the squares of the integers from\
    \ 1 to n\n# squared(1) = 1\n# squared(2) = 1, squared(3) = 9, squared(4) = 27,\
    \ ...\n# squared(n) = squared(n-1) + squared(n-2)\n# For example, squared(1) =\
    \ 1, squared(2) = 2, squared(3) = 4, and squared(4) = 16.", "    if a == 0 ||\
    \ b == 0\n        return 0\n    else if a == 1\n        return b\n    elseif b\
    \ == 1\n        return a\n    elseif b < a\n        return greatest_common_divisor(b,\
    \ a % b)\n    else\n        return greatest_common_divisor(a, b % a)\nend\n</code>\n\
    <|/ a tags=julia,math dscore=0 |>\n<| a |>\n<code>", "    return (a // b) if (a\
    \ % b == 0) else greatest_common_divisor(b, a % b)\nend\n</cell>\n<code language=julia-1.6>\n\
    @time greatest_common_divisor(1000000, 2000000)\n</cell>\n<text>\nExercise: Write\
    \ a function that calculates the factorial of an integer.", "\"\"\"\n    guard\
    \ a >= 0 && b >= 0 \n    guard a == b || a > b \n    guard a > 1 && (a % 2 ==\
    \ 1 || b % 2 == 1) \n    guard b > 1 && (a % 2 == 1 || b % 2 == 1) \n    if a\
    \ % 2 == 0 \n        guard a == 1 \n        return a \n    else \n        guard\
    \ b == 1 \n        return b \n    else \n        if b < a \n            return\
    \ greatest_common_divisor(b, a % b) \n        else \n            return greatest_common_divisor(a,\
    \ b % a) \n\"\"\"\n    gcd :: Int64 a -> Int64 a -> Int64 \n\"\"\"\n    gcd ::\
    \ Int64 a -> Int64 a -> Int64 \n    gcd x y = \n        if x < 0 \n          \
    \  then x\n        else if y < 0 \n            then y\n        else if x < y \n\
    \            then greatest_common_divisor(x, y)\n            else greatest_common_divisor(y,\
    \ x) \n\"\"\"\n    gcd_sum :: (Int64 a) -> [a] -> Int64 \n\"\"\"\n    gcd_sum\
    \ :: (Int64 a) -> [a] -> Int64 \n    gcd_sum x [] = \n        if x == 0 \n   \
    \         then 0\n        else if x < 0 \n            then 0\n        else gcd_sum\
    \ (x `div` 2) (tail x) \n\"\"\"\n    gcd_product :: (Int64 a) -> [a] -> Int64\
    \ \n\"\"\"\n    gcd_product :: (Int64 a) -> [a] -> Int64 \n    gcd_product x []\
    \ = \n        if x == 0 \n            then 0\n        else if x < 0 \n       \
    \     then 0\n        else gcd_product (x `div` 2) (tail x) \n\"\"\"\n    gcd_product\
    \ x y = gcd_product x $ tail y \n\"\"\"\n    gcd :: Int64 a -> Int64 a -> Int64\
    \ \n    gcd x y = \n        if x < 0 \n            then x\n        else if y <\
    \ 0 \n            then y\n        else if x < y \n            then greatest_common_divisor(x,\
    \ y)\n            else greatest_common_divisor(y, x) \n\"\"\"\n    gcd_sum ::\
    \ (Int64 a) -> [a] -> Int64 \n    gcd_sum x [] = \n        if x == 0 \n      \
    \      then 0\n        else if x < 0 \n            then 0\n        else gcd_sum\
    \ (x `div` 2) (tail x) \n\"\"\"\n    gcd_product :: (Int64 a) -> [a] -> Int64\
    \ \n    gcd_product x [] = \n        if x == ", "    if a > b \n        largest\
    \ = a\n    else \n        largest = b\n    while largest != 1 \n        x := largest\n\
    \        largest := largest / 2 \n        if largest == x \n            return\
    \ x \n    return largest \nend", "    if a <= 0 || b <= 0 \n        then 1\n \
    \       else gcd(a, b) \n    end\nend\n</code>\nIn Julia we could have used the\
    \ builtin gcd function which would have eliminated the need to write our own gcd.\
    \ Here is a similar Julia function with a more readable implementation:\n<code>",
  "    \n    if  a < b \n    then a \n    else  b\n    \nend\n</code>\n<|/ a dscore=4\
    \ tags=julia |>\n<| c |>\nI think this should be the accepted answer. Both `div`\
    \ and `rem` provide integer division as opposed to floating point, and `rem` makes\
    \ use of the `divmod` function.\n<|/ c |>\n<| c |>\nThis is a good answer, but\
    \ note that it is incomplete and incorrect. `greatest_common_divisor(25,15)` should\
    \ return 5, not 1. To get the correct result, one needs to write `greatest_common_divisor(a,b)*b`\
    \ instead.\n<|/ c |>\n<| a dscore=4 tags=julia |>\nThe shortest answer is:\n<code>\n\
    div(a,b)*b\n</code>\n<|/ a |>\n<| c |>\nYes, this is the correct solution, but\
    \ note that it is incomplete and incorrect. `greatest_common_divisor(25,15)` should\
    \ return 5, not 1. To get the correct result, one needs to write `greatest_common_divisor(a,b)*b`\
    \ instead.\n<|/ c |>\n<| a |>\nJulia has a divmod function that can do the job.\n\
    <code>\njulia> divmod(3,5)\n(1,1)\n</code>\n<|/ a tags=julia dscore=3 |>\n<| c\
    \ |>\nThis is incorrect, since it only works with integers, not with floating\
    \ point numbers like `divmod(3.5,5.2)`.  \nUsing `divmod` as a replacement of\
    \ `div` and `rem` does not work for non-integers. `divmod` does only work with\
    \ `Int64`.\n<|/ c |>\n<| a tags=julia |>\nIn addition to the existing answers,\
    \ there is also a dedicated function gcd which does exactly what you want:\n<code>\n\
    julia> gcd(15, 25)\n5\n</code>\n<|/ a dscore=3 |>\n<| c |>\nIt is not the gcd.\
    \ `gcd(3.5, 5.2)` should be 2.\n<|/ c |>\n<| c |>\nI understand that it doesn't\
    \ work for floating point numbers, but as far as I understand the question, the\
    \ OP doesn't have floating point numbers in his code. As I understand it, the\
    \ question is about the best way to find the greatest common divisor of two integer\
    \ numbers. The gcd function does exactly that.\n<|/ c |>\n<| c |>\nBut 3.5 !=\
    \ 3.5.\n<|/ c |>\n<| c |>\nHmm, you're right. I must have misinterpreted the question.\
    \ Thanks for pointing that ", "    if a < b then\n        greatest_common_divisor(b,\
    \ a)\n    else \n        return a\n</code>\n<|/ a tags=recursion,math,bignum,haskell,algorithm\
    \ |>\n<| c |>\nthis fails on `greatest_common_divisor(2147483647, 2147483648)`\n\
    <|/ c |>\n<| a tags=recursion,math,bignum,haskell,algorithm |>\nI made my own\
    \ implementation of this function, although its complexity is O(n\xB2). \n<code>\n\
    import Data.List\nimport Data.Maybe", "# function greatest_common_divisor(a::Int64,\
    \ b::Int64)\n# returns a greatest common divisor of two integers a and b\n   \
    \ return (a % b == 0) ? a : greatest_common_divisor(b, a % b)\nend", "    \"\"\
    \"\n    greatest_common_divisor(a::Int64, b::Int64)::Int64", "    if a == 0 ||\
    \ b == 0\n        0\n    elseif b == 0 || a == 0\n        a\n    else\n      \
    \  greatest_common_divisor(b, a % b)\nend", "    if a < b then \n        b_rem_a\
    \ = b%a\n        greatest_common_divisor(b_rem_a, a)\n    else \n        greatest_common_divisor(a,b%a)\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\" Calculate the greatest common\
    \ divisor of two integers a and b \n    >>> greatest_common_divisor(1, 1)\n  \
    \  1\n    >>> greatest_common_divisor(2, 2)\n    1\n    >>> greatest_common_divisor(3,\
    \ 5)\n    1\n    >>> greatest_common_divisor(4, 5)\n    1\n    >>> greatest_common_divisor(20,\
    \ 15)\n    5\n    \"\"\"", "    if a == 0 || b == 0 \n    then return 0\n    else\
    \ return greatest_common_divisor(b, a % b)\nend ", "    \"\"\" Compute the greatest\
    \ common divisor of a and b\n    >>> greatest_common_divisor(2, 3)\n    1\n  \
    \  >>> greatest_common_divisor(4, 5)\n    3\n    \"\"\"", "    if b==0\n    then\
    \ return a\n    else \n        return greatest_common_divisor(b, a % b)\nend",
  "    gcd(a,b)\nend", "    if a >= b then return a\n    else return greatest_common_divisor(b,\
    \ a % b)\nend\n</cell>\n<code language=julia-0.5>\n@time greatest_common_divisor(25,\
    \ 15) # 25 iterations are enough to get the whole result in seconds\n</cell>\n\
    <text>\nAs for timing functions, @time will print the time it took to execute\
    \ the whole block of code. We will use it again on greatest_common_divisor to\
    \ see how long it would take to compute the greatest common divisor.", "    if\
    \ a == 0 or b == 0:\n        return 0\n    if a < b:\n        a, b = b, a\n  \
    \  while b != 0:\n        a, b = b, a%b\n    return a\n</code>\n<|/ a dscore=1\
    \ tags=julia |>\n<| c |>\nI like this function\n<|/ c |>\n<| c |>\nI liked this\
    \ too, but I felt my answer was more general. I think it's fine to leave my answer\
    \ as is though.\n<|/ c |>\n<| c |>\nI like the idea, but it's too slow. I was\
    \ hoping for a faster way. I'll accept the answer, but if anyone finds a faster\
    \ method, I'd love to see it.\n<|/ c |>\n<| c |>\nYour solution runs into the\
    \ same problem as mine, except it will still crash on the `b == 0` case. I'm curious\
    \ what an efficient way would be...\n<|/ c |>\n<| c |>\nIt crashes because a remainder\
    \ is taken for \"b\" when it reaches 0. You can fix that by changing `if b ==\
    \ 0` to `if a == 0` and changing the `else if b == 0` of `b != 0` to `else`.\n\
    <|/ c |>\n<| a tags=julia |>\nTo expand on Brew's answer, you can also use this:\n\
    <code>", "    if a==0 || b==0 \n        0\n    else\n        if a>b \n       \
    \     greatest_common_divisor(b, a) \n        else \n            greatest_common_divisor(a,b)\
    \ \nend\n</code>\n<|/ a |>\n<| a |>\nA recursive function with tail recursion\
    \ will do the trick.\n<code>", "    return (a >= 0) ? (a / b) : 0;\nend\n</cell>\n\
    <code language=julia-1.4>\n\"\"\"\n greatest_common_divisor(b::Int64, n::Int64)::Int64",
  "    if a==0\n        then return b\n    else if b==0\n        then return a\n \
    \   else \n        greatest_common_divisor(b,a mod b)\n    end", "    a = a %\
    \ b\n    while a > 0:\n        b = b % a\n        a = a % b\n    return b\nend",
  "    if a == 0 \n        then return b\n    else if b == 0 \n        then return\
    \ a\n    else \n        return greatest_common_divisor(b, a % b)\n    end\nend\n\
    </code>\nThe same is true for the gcd function with Integers, but the return type\
    \ should also be Integer:\n<code>", "    if b == 0 \n        return a \n    else\
    \ if a == 0 \n        return b \n    else \n        return greatest_common_divisor(b,\
    \ a % b) \nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n`greatest_common_divisor`\
    \ should be `greatest_common_divisor_fast` in this case\n<|/ c |>\n<| c |>\n`greatest_common_divisor`\
    \ is not a built-in function in Julia 1.0. Instead, it should be `greatest_common_divisor_fast`\n\
    <|/ c |>\n<| c |>\nThe only reason to use `greatest_common_divisor_fast` is if\
    \ you want to use `%` which has a much worse asymptotic complexity than `greatest_common_divisor`.\
    \  `greatest_common_divisor_fast` does a little better in most cases.\n<|/ c |>\n\
    <| a dscore=2 |>\nThere is an excellent blog post here that details some nice\
    \ optimizations for computing greatest common divisors. In summary, it appears\
    \ to be:\n<code>\ngcd (a, b) == gcd(b, a % b)\n</code>\nwhere % is a modulus operation,\
    \ and thus this should be the fastest solution. Another interesting optimizations\
    \ are in the comments about reducing the number of loops when a and b are equal.\n\
    <|/ a tags=julia |>\n<| c |>\nI implemented this in Julia, and it works really\
    \ fast :) https://gist.github.com/csheridan/5eae60c59cf0c4910be956ea4ffdba28\n\
    <|/ c |>\n<| a tags=julia |>\nHere's an implementation using greatest_common_divisor_fast\
    \ for those interested:\n<code>", "    if a==b \n        1 \n    else \n     \
    \   greatest_common_divisor(b, a % b) \nend", "    if a>b \n        greatest_common_divisor(b,a)\
    \ \n    else \n        greatest_common_divisor(a,b) \nend \n</code>\n<|/ a tags=recursion,scala,functional-programming\
    \ |>\n<| c |>\nThanks so much. This was an incredibly helpful example!\n<|/ c\
    \ |>\n<| c |>\nThis is definitely more succinct than my version, but it's not\
    \ as clear.  I upvoted it anyway.\n<|/ c |>\n<| c |>\n, thanks for upvoting :)\n\
    <|/ c |>\n<| c |>\nthank you! it made my day\n<|/ c |>\n<| a |>\nThis is very\
    \ similar to Andrey's answer, but uses foldLeft, which is a little more concise\
    \ (but possibly a bit less efficient if you need something faster than foldLeft).\n\
    <code>\ndef gcd(a: int, b: int) -> Int = \n  a match {\n    case 0 | b => 1\n\
    \    case x => b == 0? x : gcd(x-1, b%x)\n  }\n</code>\n<|/ a tags=recursion,scala,functional-programming\
    \ dscore=5 |>\n<| c |>\nNot sure why this got a down vote, it is extremely concise.\
    \ It even works with negative integers.\n<|/ c |>\n<| c |>\nJust to be clear though,\
    \ this won't work in Scala 2.11 because they dropped the support for foldLeft,\
    \ but they did add support for foldRight.\n<|/ c |>\n<| c |>\nIn Scala 2.11.0,\
    \ this does not work because foldRight is not defined.\n<|/ c |>\n<| c |>\nFor\
    \ those who are using scala 2.11 use foldRight and foldLeft.\n<|/ c |>\n<| c |>\n\
    : Actually, that's a compiler warning, not an error.\n<|/ c |>\n<| a |>\n<code>\n\
    def gcd(a:Int, b:Int) = if(a == 0 || b == 0) 1 else gcd(a % b, b)\n</code>\n<|/\
    \ a dscore=5 tags=recursion,scala,functional-programming |>\n<| c |>\nThis is\
    \ the most idiomatic solution\n<|/ c |>\n<| c |>\nThe only reason I see for using\
    \ fold instead of recursion is if you want to go beyond the recursion limit of\
    \ Scala (e.g. `java.lang.StackOverflowError`). But that shouldn't be the case\
    \ here, so I think the solution is just fine.\n<|/ c |>\n<| c |>\nThis should\
    \ be ", "    if a<b then\n        greatest_common_divisor(b,a)\n    else\n   \
    \     return a\n    end\nend\n</cell>\n<text>\nWrite a recursive function GCD\
    \ that returns the greatest common divisor of two integers given a and b.", " \
    \   if a == 0 or b == 0\n        0\n    else\n        greatest_common_divisor(a\
    \ / b, b)\n    end\nend", "    if a > b then return greatest_common_divisor(b,\
    \ a) else a\n    if b == 0 then return a\n    return greatest_common_divisor(b,\
    \ a % b)\nend", "    # Return greatest common divisor of two integers a and b\n\
    \    if b == 0 \n        then return a\n    else \n        if b > a \n       \
    \     then return greatest_common_divisor(b, a%b)\n            else return greatest_common_divisor(a%b,\
    \ b)\nend\n</cell>\n<code language=julia-1.5>", "    if a == 0 | b == 0 \n   \
    \     0\n    else\n        greatest_common_divisor(b, a % b) + 1\nend\n</code>\n\
    <|/ a dscore=2 tags=julia,gcd |>\n<| a dscore=2 tags=julia,gcd |>\nHere's a one-liner\
    \ (inspired by this discussion). We can take the gcd of any number of integers\
    \ using the built-in function GCD (see the documentation). But we only want to\
    \ take it one step at a time. So, we can take GCD of a and b, then GCD of the\
    \ result with a, and then GCD of the result with b. By taking the GCD of a and\
    \ b after each step, we can easily compute the greatest common divisor of a and\
    \ b.\n<code>", "    return ifelse(isinf(a) || isinf(b), 0, gcd(a, b))\nend", " \
    \   \n    gcd = a % b\n    \n    while gcd != 0 \n        do\n            gcd\
    \ = b\n            b = a % b\n        end\n    \n    return b\nend", "    greatest_common_divisor_helper(a,b,\
    \ 1)\nend", "    greatest_common_divisor_helper(a,b,0)\nend\n</code>\nand you\
    \ can call this function using greatest_common_divisor_helper(a,b,0)\n<code>",
  "    (assert a >= 0 && b >= 0 && a <= b && b >= a && a % b == 0)\n    return b\n\
    \    end", "    Int64((a %% b + b) %% a)\nend\n</cell>\n<text>\nWe can test our\
    \ function with our test cases using the function test_greatest_common_divisor",
  "    if (a == 0) || (b == 0)\n        0\n    else\n        gcd (a, b)\nend", " \
    \   if a<b then\n        greatest_common_divisor(b,a)\n    else\n        gcd(a,b)\n\
    \    end\nend\n</code>\n<|/ a tags=julia,recursion |>\n<| a dscore=1 tags=julia,recursion\
    \ |>\n<code>", "    if (a==0 || b==0) then return 0\n    else return greatest_common_divisor(b,\
    \ a % b) \nend", "    if b == 0 \n        then return a\n    else \n        return\
    \ greatest_common_divisor(b, a%b) \n    end", "    if a == 0 and b == 0 \n   \
    \     then 1 \n    else if b == 0\n        then a \n    else \n        greatest_common_divisor(a\
    \ div b, b) \nend \n</code>\n<|/ a tags=function,greatest-common-divisor,recursion,ocaml,division\
    \ dscore=2 |>\n<| c |>\nThis looks good. I'll try it out with my functions. Thanks.\n\
    <|/ c |>\n<| c |>\nActually, it looks terrible. I'm working through my functions.\
    \ I'm going to take some of your ideas and clean it up.\n<|/ c |>\n<| c |>\nThanks\
    \ again! I got it working how I wanted. I modified some of your suggestions and\
    \ ended up with the following: `let rec greatest_common_divisor a = function\n\
    \  | 0 -> 1\n  | n -> if a mod b = 0 then b else greatest_common_divisor(b, a\
    \ mod b) end\n;; `\n<|/ c |>\n<| c |>\nThe above is incorrect (it will never work\
    \ for a and b both positive, both negative, where b is even). See my answer for\
    \ one that will work.\n<|/ c |>\n<| a |>\nA few points: ", "    if a==0 || b==0\n\
    \        return a\n    return greatest_common_divisor(b, a mod b)\n</code>\n<|/\
    \ a dscore=2 |>\n<| a tags=math,julia,algorithm |>\n<code>", "    if a == 0 ||\
    \ b == 0 then 0\n    elif a > b then greatest_common_divisor(b,a)\n    else greatest_common_divisor(a,b)\
    \ \nend\n</cell>\n<code language=julia-0.6>\n\"\"\"\ngreatest_common_divisor(a::Int64,\
    \ b::Int64)::Int64\nCompute greatest common divisor of two integers a and b\n\"\
    \"\"", "    if a == 0 return b\n    gcd = greatest_common_divisor(b, a % b)\n\
    \    return (a // gcd) * gcd\nend\n</cell>\n<text>\nGreatest common divisor: More\
    \ Pythonic", "    if a<b then return a\n    if a>b then return b\n    while a%b\
    \ != 0 do\n        a = a+1\n        b = b-1\n    return a", "    greatest_common_divisor\
    \ = gcd(a,b) \n    return greatest_common_divisor \nend\n</cell>\n<code language=julia-1.5>",
  "    if (a > b) then\n        greatest_common_divisor(b, a mod b)\n    else\n  \
    \      greatest_common_divisor(a, a mod b)\n    end\nend", "    gcd (a::Int64,\
    \ b::Int64) = if a > b then a else b\n    gcd (a::Int64, b::Int64) = if a > b\
    \ then b else a\n    gcd (a::Int64, b::Int64) = if a > b then a else b\n    gcd\
    \ (a::Int64, b::Int64) = if a > b then a else b\n    gcd (a::Int64, b::Int64)\
    \ = if a > b then a else b\n    gcd (a::Int64, b::Int64) = if a > b then a else\
    \ b\n    gcd (a::Int64, b::Int64) = if a > b then a else b\n    gcd (a::Int64,\
    \ b::Int64) = if a > b then a else b\n    gcd (a::Int64, b::Int64) = if a > b\
    \ then a else b\n    gcd (a::Int64, b::Int64) = if a > b then a else b\n    gcd\
    \ (a::Int64, b::Int64) = if a > b then a else b\n    gcd (a::Int64, b::Int64)\
    \ = if a > b then a else b\n    gcd (a::Int64, b::Int64) = if a > b then a else\
    \ b\n    gcd (a::Int64, b::Int64) = if a > b then a else b\n    gcd (a::Int64,\
    \ b::Int64) = if a > b then a else b\n    gcd (a::Int64, b::Int64) = if a > b\
    \ then a else b\n    gcd (a::Int64, b::Int64) = if a > b then a else b\n    gcd\
    \ (a::Int64, b::Int64) = if a > b then a else b\n    gcd (a::Int64, b::Int64)\
    \ = if a > b then a else b\n    gcd (a::Int64, b::Int64) = if a > b then a else\
    \ b\n    gcd (a::Int64, b::Int64) = if a > b then a else b\n    gcd (a::Int64,\
    \ b::Int64) = if a > b then a else b\n    gcd (a::Int64, b::Int64) = if a > b\
    \ then a else b\n    gcd (a::Int64, b::Int64) = if a > b then a else b\n    gcd\
    \ (a::Int64, b::Int64) = if a > b then a else b\n    gcd (a::Int64, b::Int64)\
    \ = ", "    if b == 0 \n        then return a\n    else \n        return greatest_common_divisor(b,\
    \ a % b)\n    end\nend\n</cell>\n<code language=julia-1.3>\n@assert greatest_common_divisor(3,\
    \ 5) == 1\n@assert greatest_common_divisor(25, 15) == 5\n</cell>\n<text>\nProblem\
    \ 3", "    if a > b\n        a, b = b, a\n    while b != 0\n        b = b - 1\n\
    \    return a\nend", "    if b == 0 \n        then return a\n    else \n     \
    \   greatest_common_divisor(b, a%b)\n</code>\n<|/ a tags=haskell dscore=1 |>\n\
    <| c |>\nAs a general rule, *tail recursion elimination* is an optimization technique\
    \ that is very beneficial to programmers. Unfortunately, the compiler is not smart\
    \ enough to figure out that it can safely replace `gcd x y` with `gcd y x` (since\
    \ `x `is` `y`), and in this case, the function becomes a non-terminating function.\
    \ As you probably realize, this is a terrible habit to get into. Instead, try\
    \ `gcd x y = gcd y x`.\n<|/ c |>\n<| c |>\n`greatest_common_divisor = div . gcd\
    \ . quot`\n<|/ c |>\n<| a dscore=0 tags=haskell |>\nIn Haskell there is no concept\
    \ of a \"gcd function\", there is only a function named gcd that takes two numbers\
    \ and returns the greatest common divisor of the two.\nTo solve the problem you\
    \ probably want to use the following function definition:\n<code>\ngcd :: Int\
    \ -> Int -> Int\ngcd x y = if y == 0 || y == x then 0 else gcd (y div x) (x div\
    \ y)\n</code>\nThe function gcd takes as inputs (x, y) and returns x, y if both\
    \ x and y are positive integers and gcd(x, y) if either x or y is negative.\n\
    The function div takes two numbers and returns the quotient of x/y and the remainder\
    \ of x/y - this is the \"division\" operator in Haskell and it is often used to\
    \ get the \"modulus\" of a division.\nThe function div has the type Int -> Int\
    \ -> Int, which means that it takes two integers and returns a pair of integers.\
    \ In Haskell you can use the following syntax to get a pair:\n<code>\n(,)\n</code>\n\
    The function div is also an operator, which means that it takes two numbers and\
    \ returns the quotient and the remainder. This means that you can use the following\
    \ notation to define a function:\n<code>\ndiv x y = let q = x/y in let r = x%y\
    \ in (q,r)\n</code>\nYou can then write the gcd function like so:\n<code>\ngcd\
    \ x y = let (q,r) = div x y in if y == 0 || y == x then 0 else gcd (y div x) (x\
    \ div y)\n</code>\nNote that I have written a let expression to create a pair\
    \ of integers rather than using the function div. I prefer this notation because\
    \ it makes it easier to see where I am creating the pair", "    if (a == 0) ||\
    \ (b == 0)\n        0\n    else\n        if b == 0 || a == 1\n            1\n\
    \        else\n            if a > b\n                greatest_common_divisor(b,\
    \ a % b)\n            else\n                greatest_common_divisor(a, (b * b)\
    \ % a)\nend\n</cell>\n<text>\nThe greatest common divisor function is a recursive\
    \ function, it makes use of the fact that the modulo of a positive number is equal\
    \ to the greatest common divisor of the two numbers minus one. The modulo of a\
    \ negative number is not defined, in such case we use the least common multiple\
    \ instead.", "    if a < b then\n        greatest_common_divisor(b, a)\n    else\n\
    \        true\n    end", "    if (a==0) || (b==0) return 0\n    \n    if (a==b)\
    \ then return a\n    \n    c::Int64 = b % a\n    \n    if (c != 0) then return\
    \ greatest_common_divisor(a,c)\n    else return a\nend\n</cell>\n<text>\nExercise\
    \ 3\nWrite a function that calculates the multiplicative inverse of a number.\
    \ \n    Multiplicative inverse of a number is the number \n    that when multiplied\
    \ by itself equals the original number. \n    \n    For example, the multiplicative\
    \ inverse of 4 is -2, \n    and multiplicative inverse of 7 is -4:\n        7(-4)\
    \ = -2 \n        4(-4) = 2 \n    \n    You will need to use the greatest common\
    \ divisor function for this. \n    \n    When you have a gcd function, you are\
    \ guaranteed that your function will \n    always return a positive integer.\n\
    \    \n    You can assume that a and b are positive integers and gcd(a,b) = 1.",
  "    return if a <= b then greatest_common_divisor(b, a) else a\nend\n</cell>\n\
    <code language=julia-1.2>\n@assert greatest_common_divisor(5, 4) == 2\n@assert\
    \ greatest_common_divisor(5, 1) == 1\n@assert greatest_common_divisor(4, 4) ==\
    \ 2\n@assert greatest_common_divisor(4, 3) == 1\n@assert greatest_common_divisor(5,\
    \ 4) == 2\n@assert greatest_common_divisor(5, 1) == 1\n@assert greatest_common_divisor(6,\
    \ 2) == 2\n@assert greatest_common_divisor(6, 1) == 1\n@assert greatest_common_divisor(2,\
    \ 2) == 4\n@assert greatest_common_divisor(2, 1) == 2\n@assert greatest_common_divisor(5,\
    \ 4) == 2\n@assert greatest_common_divisor(5, 1) == 1\n@assert greatest_common_divisor(6,\
    \ 2) == 2\n@assert greatest_common_divisor(6, 1) == 1\n@assert greatest_common_divisor(2,\
    \ 2) == 4\n@assert greatest_common_divisor(2, 1) == 2\n@assert greatest_common_divisor(5,\
    \ 4) == 2\n@assert greatest_common_divisor(5, 1) == 1\n@assert greatest_common_divisor(6,\
    \ 2) == 2\n@assert greatest_common_divisor(6, 1) == 1\n@assert greatest_common_divisor(2,\
    \ 2) == 4\n@assert greatest_common_divisor(2, 1) == 2\n@assert greatest_common_divisor(5,\
    \ 4) == 2\n@assert greatest_common_divisor(5, 1) == 1\n@assert greatest_common_divisor(6,\
    \ 2) == 2\n@assert greatest_common_divisor(6, 1) == 1\n@assert greatest_common_divisor(2,\
    \ 2) == 4\n@assert greatest_common_divisor(2, 1) == 2\n@assert greatest_common_divisor(5,\
    \ 4) == 2\n@assert greatest_common_divisor(5, 1) == 1\n@assert greatest_common_divisor(6,\
    \ 2) == 2\n@assert greatest_common_divisor(6, 1) == 1\n@assert greatest_common_divisor(2,\
    \ 2) == 4\n@assert greatest_common_divisor(2, 1) == 2\n@assert greatest_common_divisor(5,\
    \ 4) == 2\n@assert greatest_common_divisor(5, 1) == 1\n@assert greatest_common_divisor(6,\
    \ 2) == 2\n@assert greatest_common_divisor(6, 1) == 1\n@assert greatest_common_divisor(2,\
    \ 2) == 4\n@assert greatest_common_divisor(2, 1) == 2\n@assert greatest_common_divisor(5,\
    \ 4) == 2\n@assert greatest_common_divisor(5, 1) == 1\n@assert greatest_", " \
    \   if b == 0 \n        then return a\n        \n    else greatest_common_divisor(b,\
    \ a % b)\n    \nend\n</cell>\n<text>\nExercise\nWrite a function that tests two\
    \ integers a and b are coprime. A coprime of two integers is a number $a \\ne\
    \ 0$ such that there exist positive integers $p, q$ such that $a^p \\ne 0$ and\
    \  $a^q \\ne 0$ and $a^p + a^q < 1$. Recall that $a^0 \\ne 0$.", "    if a ==\
    \ 0 || b == 0 \n        then return 0\n    else if a == b \n        then return\
    \ a\n    else \n        greatest_common_divisor(a - 1, b - 1) \nend\n</cell>\n\
    <cell>\ntest_greatest_common_divisor(greatest_common_divisor)\n</cell>\n<text>\n\
    6. Write a function that returns a list of prime numbers up to N.\nhint: use generate_primes(N)\
    \ where N is a positive integer.", "    if (b == 0)\n        then return a\n \
    \   else return greatest_common_divisor(b, a % b)\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| c |>\nYou might want to use the `%` operator in place of `greatest_common_divisor`\
    \ since it seems to perform better (though I can't say for sure).\n<|/ c |>\n\
    <| c |>\nI did some benchmarks on this and I realized that `greatest_common_divisor`\
    \ is faster for large arguments. The `%` operator is much faster even for small\
    \ integers. You can check it out here: [benchmark](http://julialang.org/blog/?p=603)\n\
    <|/ c |>\n<| a dscore=5 tags=julia |>\nThe answer by Eric Tang already provides\
    \ a solution, but I'll go through some of the options here.\nFor small integers,\
    \ you can use a binary search algorithm to find the GCD and then simply multiply\
    \ with the correct factor.\n<code>", "    if a > b\n        a, b = b, a\n    for\
    \ x in (a :: Int64, b :: Int64)\n        if x > 0\n            return x\n    \
    \    x -= 1\n    error(\"can't find a common divisor\")\nend \n</cell>\n<code\
    \ language=julia-1.4>", "    if a < b\n        a,b = b,a\n    while a != b\n \
    \       if a > b\n            a,b = b,a\n        else\n            b,a = a,b\n\
    \    end\n    return b\nend", "    if a == 0 || b == 0 \n        then return 0\n\
    \    elseif b > a\n        then return b\n    else\n        x \u2190 a\n     \
    \   y \u2190 b\n        y \u2190 greatest_common_divisor(x, y)\n        return\
    \ y", "    if a>b\n        a,b=b,a\n    if b==0\n        return a\n    return\
    \ greatest_common_divisor(b, a % b)\n</code>\n<|/ a tags=math,primes,julia dscore=3\
    \ |>\n<| c |>\nNice solution, I like it! However, I believe that there may be\
    \ a bug in the recursive call of `greatest_common_divisor`. When `a` is equal\
    \ to `b`, then `a%b` will always return `0`, so the recursion will never stop.\
    \ Try it out and see for yourself.\n<|/ c |>\n<| c |>\nThanks for the feedback,\
    \ I believe I fixed that issue in the new solution!\n<|/ c |>\n<| c |>\nThanks\
    \ for the feedback! The recursive call does indeed seem to be broken in Julia.\
    \ I'll see if I can fix it myself but in the meantime I will try to submit a pull\
    \ request to fix the issue. In the mean time, I tested the solution on Julia version\
    \ 0.6.1 and it worked just fine. Thanks for your contribution! :-)\n<|/ c |>\n\
    <| c |>\nI submitted a PR to fix this issue, please see https://github.com/JuliaLang/julia/pull/30253\n\
    <|/ c |>\n<| a tags=math,primes,julia dscore=2 |>\nI wrote a solution using recursive\
    \ generators that was a little more elegant than the one suggested by Dan Farrish.\
    \ The function primes() returns the list of prime factors in an iterable (any\
    \ iterable - it could be a range, a list, a generator, an array, a dataframe...).\
    \ \n<code>\njulia> primes(10)\n([2,3],4)", "    | a < b -> greatest_common_divisor(b,\
    \ a)\n    | a > b -> greatest_common_divisor(a, b)\n    | otherwise -> a\n</code>\n\
    <|/ a tags=types,julia,performance |>\n<| a dscore=1 tags=types,julia,performance\
    \ |>\nIf you use Julia 0.7 you can also make use of functions like broadcasting\
    \ which can improve the performance of loops. For example:\n<code>", "    if b\
    \ == 0 \n        then\n            Greatest_Common_Divisor = 0\n        elsif\
    \ a == 0 \n            then\n                Greatest_Common_Divisor = 1\n   \
    \         else\n                Greatest_Common_Divisor = \n                 \
    \  greatest_common_divisor(b, a % b) \n                    \n    else\n      \
    \  Greatest_Common_Divisor = greatest_common_divisor(b, a%b)\n    end\nend", " \
    \   if a < 0 || b < 0 \n        throw(ArgumentError(\"Greatest common divisor\
    \ of negative numbers not supported.\"))\n    if (a == 0) || (b == 0) \n     \
    \   throw(ArithmeticError(\"Greatest common divisor of zero\"))\n    else if a\
    \ == b \n        throw(ArithmeticError(\"The greatest common divisor of two numbers\
    \ is zero.\"))\n    else \n        let a = a \n        let b = b \n        gcd\
    \ = a\n        loop\n            a <- a/b\n            b::gcd <- b\n         \
    \   if a < b \n                then break\n            else gcd <- gcd\n     \
    \   end\n    return gcd\nend", "    if a<b\n        return b\n    else\n     \
    \   return greatest_common_divisor(b,a)\nend\n</cell>\n<code language=julia-1.4>\n\
    @time greatest_common_divisor(20, 1000000000)\n</cell>\n<code language=julia-1.4>\n\
    @time greatest_common_divisor(20, 1000000000)\n</cell>\n<code language=julia-1.4>\n\
    @time greatest_common_divisor(20, 1000000000)\n</cell>\n<code language=julia-1.4>\n\
    @time greatest_common_divisor(20, 1000000000)\n</cell>\n<code language=julia-1.4>\n\
    @time greatest_common_divisor(20, 1000000000)\n</cell>\n<code language=julia-1.4>\n\
    @time greatest_common_divisor(20, 1000000000)\n</cell>\n<code language=julia-1.4>\n\
    @time greatest_common_divisor(20, 1000000000)\n</cell>\n<code language=julia-1.4>\n\
    @time greatest_common_divisor(20, 1000000000)\n</cell>\n<code language=julia-1.4>\n\
    @time greatest_common_divisor(20, 1000000000)\n</cell>\n<code language=julia-1.4>\n\
    @time greatest_common_divisor(20, 1000000000)\n</cell>\n<code language=julia-1.4>\n\
    @time greatest_common_divisor(20, 1000000000)\n</cell>\n<code language=julia-1.4>\n\
    @time greatest_common_divisor(20, 1000000000)\n</cell>\n<code language=julia-1.4>\n\
    @time greatest_common_divisor(20, 1000000000)\n</cell>\n<code language=julia-1.4>\n\
    @time greatest_common_divisor(20, 1000000000)\n</cell>\n<code language=julia-1.4>\n\
    @time greatest_common_divisor(20, 1000000000)\n</cell>\n<code language=julia-1.4>\n\
    @time greatest_common_divisor(20, 1000000000)\n</cell>\n<code language=julia-1.4>\n\
    @time greatest_common_divisor(20, 1000000000)\n</cell>\n<code language=julia-1.4>\n\
    @time greatest_common_divisor(20, 1000000000)\n</cell>\n<code language=julia-1.4>\n\
    @time greatest_common_divisor(20, 1000000000)\n</cell>\n<code language=julia-1.4>\n\
    @time greatest_common_divisor(20, 1000000000)\n</cell>\n<code language=julia-1.4>\n\
    @time greatest_common_divisor(20, 1000000000)\n</cell>\n<code language=julia-",
  "    if a==0 || b==0 then \n        return 0\n    elseif b == 0 then \n        return\
    \ a\n    elseif b > a then \n        return greatest_common_divisor(b, a % b)\n\
    \    else\n        return greatest_common_divisor(a, a % b)\nend", "    cdef long\
    \ long int c\n    c=0\n    while a != 0:\n        while b != 0:\n            c\
    \ = b\n            while (a & 1) and (b & 1):\n                c = c * a % b\n\
    \                a //= 2\n                b //= 2\n            a //= 2\n     \
    \       b //= 2\n    return c", "    if b==0 || a==0\n        0\n    else\n  \
    \      a\n        %\n        greatest_common_divisor(b, a % b)\n    end\nend\n\
    </code>\n<|/ a |>\n<| a tags=performance,julia dscore=2 |>\nHere's an iterative\
    \ approach that works well for non-trivial divisors: \n<code>", "    if (a==0||\
    \ b==0||a>b)\n        throw(ArithmeticException,\"aor b is not zero\")\n    else\
    \ if (a==0)\n        return b\n    else if (b==0)\n        return a\n    else\n\
    \        return (greatest_common_divisor(a-1, b%a)) if a > b else a\nend", "if\
    \ b == 0 then return a\nelse return greatest_common_divisor(b, a%b)", "    x <-\
    \ a\n    y <- b\n    while x > 0\n        do\n            x <- x \\`div\\` y\n\
    \            y <- y \\`div\\` x\n        end\n    return x\nend", "    return\
    \ (a * b) `div` gcd(a, b) \nend\n</code>\n<|/ a dscore=2 tags=julia,gcd,greatest-common-divisor\
    \ |>\n<| c |>\nYou shouldn't use `div` here but `rem`.\n<|/ c |>\n<| c |>\nThe\
    \ question is tagged `julia`.  `div` is valid on both `Int64` and `Float64`.\n\
    <|/ c |>\n<| c |>\nHi, thanks for taking the time to respond to my question and\
    \ for your code. I'm getting a syntax error when I run `julia` and don't know\
    \ why. Can you explain to me what I'm doing wrong?\n<|/ c |>\n<| c |>\nI believe\
    \ that `::Int64` should be removed in your code. Also, `div` returns a `Real`\
    \ while `rem` returns an `Int`.\n<|/ c |>\n<| c |>\nI just removed `::Int64` and\
    \ changed `div` to `rem`. Thanks for the suggestions :)\n<|/ c |>\n<| a |>\nI\
    \ have found a solution that doesn't rely on div and I don't believe it is the\
    \ most efficient one, but it's probably the simplest to understand and probably\
    \ the least prone to errors. Here's a solution inspired by this post:\n<code>",
  "    if a < b then return greatest_common_divisor(b, a)\n    if a == 0 then return\
    \ b\n    if b == 0 then return a\n    return gcd(a,b) \nend", "    if b==0 then\
    \ return a\n    else return greatest_common_divisor(b, a % b)", "    if a == b\
    \ then return a else greatest_common_divisor(b,(a%b)%a)\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\nWrite a function that accepts a matrix A and a vector b and \nreturns\
    \ an array C where each element of C is the sum of \nthe elements of A multiplied\
    \ by each element of b.\nFor example, if\nA = [1 2 3]\nand b = [1]\nthen C = [1*1\
    \ + 2*2 + 3*3]\n\"\"\"", "    #TODO: Use recursive algorithm\n    if a>b\n   \
    \     return greatest_common_divisor(b,a)\n    if a==0\n        return 1\n   \
    \ if b==0\n        return 1\n    return greatest_common_divisor(b%a,a)\nend",
  "    \"\"\"Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3,\
    \ 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"", "  \
    \  \n    \"\"\"\n    Compute the greatest common divisor of two integers a and\
    \ b\n    \n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25,\
    \ 15)\n    5\n    \"\"\"\n    if b < 0 \n        then b = 0\n    else if b ==\
    \ 0\n        then return a\n        else return 0\n    else\n        if a < 0\n\
    \            then a = 0\n        else\n            if a == 0\n               \
    \ then return b\n            else\n                let x = gcd(b, a) \n      \
    \          let y = a \\ x \n                let z = b \\ x \n                let\
    \ r = gcd(b, z) \n                if r == x \n                    then return\
    \ y \n                else\n                    else return z\nend\nend\n</cell>\n\
    <code language=julia-1.0>\n\"\"\"\nCompute the greatest common divisor of a positive\
    \ integer x and integer y.\nIf y is non-positive then gcd(y, x) = gcd(y, abs(x))\n\
    \"\"\"", "</code>\nAnd now we can finally write a function that finds the least\
    \ common multiple of a and b. This is the core of the algorithm, but we'll start\
    \ by implementing what we already have:\n<code>", "    x <- a\n    y <- b\n  \
    \  while (y != 0)\n        x <- y\n        y <- x % y\n    return x\nend function\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nThis is much more efficient than doing it\
    \ naively! I made a version with more comments below\n<|/ c |>\n<| c |>\nCould\
    \ you please elaborate why do we have to use xor here?\n<|/ c |>\n<| c |>\nThis\
    \ is actually the fastest solution I've found. Great work!\n<|/ c |>\n<| c |>\n\
    Thank you. This is the best solution. The xor trick is so much better!\n<|/ c\
    \ |>\n<| c |>\nThis solution is definitely the fastest on many platforms. However,\
    \ it should be noted that this doesn't do well with negative numbers. It's easy\
    \ to get this wrong if you're not careful.\n<|/ c |>\n<| a |>\n<code>", "    return\
    \ (a // b)*b\nend\n</cell>\n<text>\nGreat job! You are now ready to do some coding\
    \ exercises. Feel free to jump to the solutions notebook or the exercises directory\
    \ to look at (or even look at other files in the workspace). Let's get started!",
  "  if (b == 0)\n    a\n  else\n    greatest_common_divisor(b, a%b)\nend\n</cell>\n\
    <code language=julia-0.6>", "    return gcd(a,b) \nend\n\"\"\"", "    if a < b\
    \ then \n        gcd(a, b) else gcd(b, a) \n    else \n        gcd(a, b)\n</code>\n\
    <|/ a |>\n<| c |>\nHow do you know which version of `greatest_common_divisor`\
    \ you are using?\n<|/ c |>\n<| c |>\nI am using julia version 1.3.1. I guess I\
    \ got the syntax from here.\n<|/ c |>\n<| c |>\nJulia's documentation should be\
    \ the preferred source of syntax for you. https://julialang.org/en/v1/manual/functions/\n\
    <|/ c |>\n<| c |>\nI guess it is. Thanks.\n<|/ c |>\n<| a tags=julia,syntax |>\n\
    As of Julia 1.0 the following is possible:\n<code>\njulia> a = 3\n3", "    if\
    \ a < 0 || b < 0 \n    then \n        error \"Illegal input: Cannot compute greatest\
    \ common divisor for negative numbers\"\n    end\n    if a == 0\n    then \n \
    \       b\n    elseif b == 0\n    then \n        a\n    else\n        greatest_common_divisor(a\
    \ // b, b)\n    end\nend", "    if a>b\n        return greatest_common_divisor(a,b)\n\
    \    else if a==b\n        return a\n    else\n        return greatest_common_divisor(b,a)\n\
    end", "    greatest_common_divisor = gcd(a, b) \n    return greatest_common_divisor\n\
    end", '    return (a % b + b) % b', "    \n    \"\"\"\n    return gcd(a, b)\n\
    \    \n    \"\"\"\n}", "     if a==0 || b==0 then return 0 else return a%b\n \
    \    end \n</code>\nThe function greatest_common_divisor has two arguments, a\
    \ and the other. a is an integer, b is a integer.\nIn function greatest_common_divisor,\
    \ the variable a is a Int64 integer, and b is a Int64 integer.\nIn function greatest_common_divisor,\
    \ if the two numbers are equal, then return zero.\nIn function greatest_common_divisor,\
    \ if the two numbers are NOT equal, then return the remainder of the division\
    \ between a and b.\nTest Code\nI ran the test code below to make sure that the\
    \ function greatest_common_divisor was working correctly.\n<code>\n## test code\n\
    using Pkg\nusing StatsBase\nusing Random", "if a>b \n    then greatest_common_divisor(b,\
    \ a)\n    else greatest_common_divisor(a,b)\n</code>\n<|/ a tags=julia,algorithm,greatest-common-divisor,performance\
    \ |>\n<| c |>\nThanks, although this doesn't answer the question as asked (at\
    \ least as I understand it).\n<|/ c |>\n<| c |>\nThe solution does answer the\
    \ question. There were several answers posted earlier which did not answer the\
    \ question as asked (I guess because they had been posted earlier).\n<|/ c |>\n\
    <| a tags=julia,algorithm,greatest-common-divisor,performance |>\nHere's a version\
    \ that I believe is faster with Julia 1.3 or 1.4:\n<code>", "    return if a ==\
    \ 0 then 0 else b / greatest_common_divisor(a,b%a)\n</code>\n<|/ a dscore=1 tags=math,julia,algorithm\
    \ |>\n<| c |>\nThis approach doesn't work for negative integers since `a%b` will\
    \ return the remainder of division, and `a` can be negative since we take modulus.\
    \ What I did was to first take absolute value with `abs()` before dividing.\n\
    <|/ c |>\n<| a tags=math,julia,algorithm |>\nThis can be solved using the Euclidean\
    \ algorithm (as the name suggests) by checking out the following article:\nhttp://en.wikipedia.org/wiki/Euclidean_algorithm\n\
    The article suggests a solution in Java in the following manner:\n<code>\npublic\
    \ static int[] euclideanAlgorithm(double[] vector1, double[] vector2) {\n    int[]\
    \ euclideanVector = new int[2];\n    double x1, y1, x2, y2, dot;\n    int k;\n\
    \    \n    for (int i = 0; i < vector1.length; i++) {\n        x1 = vector1[i];\n\
    \        y1 = vector2[i];\n        \n        for (int j = 0; j < vector1.length;\
    \ j++) {\n            x2 = vector1[j];\n            y2 = vector2[j];\n       \
    \     \n            dot = 0;\n            \n            for (k = 0; k < vector1.length;\
    \ k++) {\n                dot += x1 * x2;\n                x1 = x2;\n        \
    \        x2 = k;\n            }\n            \n            euclideanVector[0]\
    \ += dot;\n            euclideanVector[1] += (y2 - y1)*(x2 - x1);\n        }\n\
    \    }\n    return euclideanVector;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=math,julia,algorithm\
    \ |>\nThis problem is called the \"greatest common divisor\" problem and can be\
    \ solved in O(logn) time using the Euclidean algorithm.\nThe pseudocode for the\
    \ problem (where n is the size of the integer type) is:\n<code>\ngcd(a,b) = gcd(a,b)\
    \ \u2264 0 ? gcd(b,a) : a\n</code>\nTo calculate the GCD, the Euclidean algorithm\
    \ is applied repeatedly until it reaches the base case, which is the case when\
    \ a = b.\nIn julia, the implementation is given below:\n<code>", "    \nend\n\
    </cell>\n<code language=julia-1.5>", "    if a>b \n        a, b = b, a\n    while\
    \ a % b == 0\n        a, b = b, a%b\n    return a", "    if b == 0\n        return\
    \ a\n    elseif a == 0\n        return b\n    elseif b > a\n        return greatest_common_divisor(b,\
    \ a % b)\n    else\n        return greatest_common_divisor(a % b, b)\nend\n</code>\n\
    <|/ a tags=julia,math dscore=4 |>\n<| c |>\nThe question was about Julia, so I\
    \ think that this answer would be more appropriate, since it also supports integers.\
    \ Also, you should be aware that the `gcd` implementation is wrong in the case\
    \ of a negative `a` or `b`.\n<|/ c |>\n<| c |>\nThis is not correct since it fails\
    \ for non-integers. For instance, this returns 1 instead of 2: gcd(42, 24) = gcd(24\
    \ % 42, 24) = gcd(42, 24 % 24) = gcd(1, 24) = 1.\n<|/ c |>\n<| c |>\nThe correct\
    \ solution would be `gcd(b, a % b)` instead of `a % b`.\n<|/ c |>\n<| c |>\nThe\
    \ question was about julia, so I thought the answer would fit better. `greatest_common_divisor`\
    \ also works on non integers just fine.\n<|/ c |>\n<| c |>\nIf `a` and `b` are\
    \ integers, then `a % b` is the _greatest common divisor_. So, `a % b` will give\
    \ the greatest common divisor of `a` and `b`. For example, if `a = 7` and `b =\
    \ 2`, then `a % b` is `3`.\n<|/ c |>\n<| a tags=julia,math |>\nThis might not\
    \ exactly be a direct answer to your question, but I think it's a lot simpler\
    \ to implement and easier to understand. For example:\n<code>\ngcd(x, y) = if\
    \ y == 0\n              x\n          elseif x == 0\n              y\n        \
    \  else\n              gcd(y, x % y)\n          end\n</code>\n<|/ a dscore=4 |>\n\
    <| c |>\nThis is the most efficient and cleanest solution for Julia, since it\
    \ avoids any recursion.\n<|/ c |>\n<| c |>\nNote that if `gcd(x, y)` is called\
    \ a large number of times then this algorithm will call it once for each pair\
    \ of arguments. An alternative would be to call `x % y` only once and cache the\
    \ result.\n<|/ c |>\n<| a dscore=3 tags=julia,math |>\nI recently went through\
    \ this exercise and after a while, I found the most elegant solution using recursion:\n\
    <code>\ngcd(a,b) = gcd(b, a % b)", "    if b == 0\n        0\n    else\n     \
    \   if a % b == 0\n            greatest_common_divisor(b, a div b)\n        else\n\
    \            greatest_common_divisor(b, a % b)\n        end\n    end\nend", " \
    \   if a==0 || b==0 \n    then\n        return 1\n    else \n        return greatest_common_divisor(a-1,\
    \ b) % a\nend\n</code>\nNow the code for the greatest_common_divisor_of_an_array_of_integers(arrayOfInts::Array{Int64})::Int\
    \ function, which computes the greatest common divisor of an array of integers\
    \ \n<code>", "    if a==b then return a\n    else if b > a then return greatest_common_divisor(b,a)\
    \ \n    else return greatest_common_divisor(a,b) \nend greatest_common_divisor(a,b)\n\
    </code>\n<|/ a tags=recursion,greatest-common-divisor,julia |>\n<| c |>\nPlease\
    \ don't post code-only answers. Please explain how your code answers the question.\
    \ BTW, `isless` might be preferable to `==`\n<|/ c |>\n<| c |>\nThe function should\
    \ be called `greatest_common_divisor`\n<|/ c |>\n<| c |>\nThe function has already\
    \ the name \"greatest_common_divisor\" so I thought it would be better to call\
    \ it that way, but I agree that the naming should have been improved.\n<|/ c |>\n\
    <| a tags=recursion,greatest-common-divisor,julia |>\nI like the function from:\
    \ \n<code>", "    if a==0 or b==0 return 0\n    let gcd=a%b\n    if gcd(gcd(a,b),b)==a\
    \ return gcd else return greatest_common_divisor(b,gcd) \nend\n</code>\n<|/ a\
    \ |>\n<| a tags=julia,loops,greatest-common-divisor |>\nThe solution is simple\
    \ and straightforward:\n<code>\ngcd(x, y) = gcd(y, x % y) == x ? y : gcd(y, x\
    \ % y)\n</code>\nExplanation: this function returns the greatest common divisor\
    \ of a and b, if b divides a then b divides gcd(a,b). This is just a recursive\
    \ call, and is very efficient because it does not require division.\nIn Julia,\
    \ all functions return a value. So:\n<code>\ngcd(a, b)\n</code>\nis a function\
    \ returning greatest common divisor of a and b. There are other functions returning\
    \ the greatest common divisor of a and b:\n<code>\ngcd(a::Int64, b::Int64)\ngcd(a::BigInt,\
    \ b::BigInt)\ngcd(a::Real, b::Real)\n</code>\nThe other ones are also recursive.\
    \ These ones can also return nothing:\n<code>\ngcd(a::Nothing, b::Nothing) = nothing\n\
    gcd(a::Bool, b::Bool) = nothing\ngcd(a::Array{Nothing}, b::Array{Nothing}) = nothing\n\
    </code>\nThe reason why it can return nothing is that both a and b are integers.\n\
    <|/ a dscore=2 |>\n<| c |>\nYou don't need a ternary operator in this case. `gcd\
    \ = x if y == x && x == y || y == x ? x : gcd(y, x % y)` will work just fine.\n\
    <|/ c |>\n<| a dscore=2 |>\nUsing recursion is the most efficient solution I found,\
    \ at least for me\n<code>", "    if a == 0 || b == 0\n        0\n    else\n  \
    \      gcd(a, b) \nend\n</cell>\n<text>\n3.3 Exercise 3\nWrite a function primes?\
    \ that takes a number x and returns true if the number is prime and false otherwise.\
    \ Hint: Use the primes function to implement this function.", "    if b == 0 \n\
    \    then \n        if a == 0 \n        then return 1 \n        else return 0\
    \ \n    else \n        f <- greatest_common_divisor(b, a mod b) \n        if a\
    \ == b \n        then return f \n        else if f == 0 \n        then return\
    \ b \n        else return f ", "    if a < b\n        return greatest_common_divisor(b,\
    \ a) \n    else if a == 0\n            then return b\n            else return\
    \ greatest_common_divisor(a-1, b) \nend\n</code>\n<|/ a tags=math,julia,performance,algorithm\
    \ |>\n<| c |>\nThis code can be further optimized by writing it as `greatest_common_divisor(a::Int,\
    \ b::Int) = a < b ? greatest_common_divisor(b, a) : a > 0 ? greatest_common_divisor(a-1,\
    \ b) : b` which avoids the need for ternary operators.\n<|/ c |>\n<| c |>\nThanks,\
    \ I edited my answer. I think it's much easier to read\n<|/ c |>\n<| c |>\nThe\
    \ solution with the ternary operator is faster. With `a = 1` the ternary operator\
    \ is slower than the functional solution. With `a = 2` it is even faster. This\
    \ also means that it's better to write `greatest_common_divisor(a::Int, b::Int)\
    \ = a < b ? greatest_common_divisor(b, a) : b`.\n<|/ c |>\n<| c |>\nThe ternary\
    \ operator is also faster than the functional solution since it avoids creating\
    \ the temporary object `greatest_common_divisor(a > 0 ? a - 1 : b, a > 0 ? b :\
    \ a > 0 ? a : b - 1)`.\n<|/ c |>\n<| c |>\nIndeed, thank you. I've edited my answer.\n\
    <|/ c |>\n<| a |>\nHere is a version without using any if-else statements. \n\
    <code>", "    if (a == 0) || (b == 0)\n        error(\"Cannot divide by 0\")\n\
    \    else if ((a < b) && (a != 0))\n        error(\"Left argument cannot be less\
    \ than the right argument\")\n    else if ((b < a) && (b != 0))\n        error(\"\
    Right argument cannot be less than the left argument\")\n    else if ((a > b)\
    \ && (a != 0))\n        error(\"Right argument cannot be greater than the left\
    \ argument\")\n    else if ((b > a) && (b != 0))\n        error(\"Left argument\
    \ cannot be greater than the right argument\")\n    else if (a > b)\n        return\
    \ a\n    else if (b > a)\n        return b\n    else\n        error(\"The arguments\
    \ are the same\")\nend", "    if b == 0 then return a\n    else return greatest_common_divisor(b,\
    \ a%b)\nend", "    \"\"\"\n    greatest_common_divisor(Int64, Int64)::Int64",
  "    if a == 0\n    then return b\n    else return greatest_common_divisor(b, a\
    \ % b)\n    end\n\"\"\"\n\"\"\"\n    Function to check if a given number is a\
    \ power of two\n\"\"\"", "    # check inputs and return error message\n    if\
    \ b==0 then \n        error!(\"Argument b must be positive.\") \n    end\n   \
    \ if b==0 then \n        error!(\"Argument b must be positive.\") \n    end\n\
    \    if a==0 then \n        error!(\"Argument a must be positive.\") \n    end\n\
    \    \n    if a==b then \n        return a\n    end\n    \n    \n    while true\n\
    \        gcd = get_greatest_common_divisor(a,b) \n        if gcd==a then \n  \
    \          return a\n        end\n        if gcd==b then \n            return\
    \ b\n        end\n        a = gcd\n    end\nend\n</cell>\n<code language=julia-1.0>",
  "    if b == 0 \n        then return a\n    else \n        return greatest_common_divisor(b,\
    \ a%b)\n    end\nend", "  \n    if a==0\n        then b\n    else\n        gcd(a,\
    \ b) % a\nend", "    if a == 0 \n        then return b \n    else if a == 1 \n\
    \        then return 1\n    else return greatest_common_divisor(b div a, a)",
  "    if b == 0 \n        then return a\n    else \n        tmp = greatest_common_divisor(b,\
    \ a % b) \n        if tmp > a \n            then return tmp\n        else return\
    \ a\n</code>\n<|/ a dscore=3 |>\n<| c |>\nWhile this may answer the question,\
    \ please add some explanation why it does so.\n<|/ c |>\n<| c |>\nSure I will,.\
    \ Sorry I didn't have that information when I wrote my answer. :)\n<|/ c |>\n\
    <| a |>\nFor someone looking to implement a solution in Julia I wrote a quick\
    \ implementation in Python which you can find below:\n<code>\ndef gcd(a,b):\n\
    \    while b != 0:\n        c = a % b\n        a = b\n        b = c\n    return\
    \ a\n</code>\n<|/ a dscore=2 tags=math,algorithm,greatest-common-divisor,julia\
    \ |>\n<| a tags=math,algorithm,greatest-common-divisor,julia dscore=2 |>\nMy simple\
    \ recursive function in Julia that calculates the Greatest Common Divisor of a\
    \ and b, and also the least common multiple of a and b which is GCD(a, b).\n<code>",
  "    if b == 0 then \n        return a \n    else \n        return greatest_common_divisor(b,\
    \ a % b) \nend\n</code>\n<|/ a tags=math,julia,algorithm,integer,big-o |>\n<|\
    \ c |>\nI agree with this answer. Just one thing: you don't need to use ternary\
    \ operators here. You can use an if-else statement instead.\n<|/ c |>\n<| c |>\n\
    The above does not give the greatest common divisor! It gives the GCD, but not\
    \ the greatest one.\n<|/ c |>\n<| a dscore=3 tags=math,julia,algorithm,integer,big-o\
    \ |>\n<code>", "\"\"\"\n    local gcd a b\n    gcd = a\n    if b < a then\n  \
    \      gcd = b\n    else\n        gcd = a\n        for i = b + 1 downto 1 do\n\
    \            if a%i == 0 then\n                gcd = i\n            end\n    \
    \    end\n    end\n    return gcd\nend\n\"\"\"\n    Return the product of two\
    \ integers a and b\n    >>> product = product(1, 2)\n    2.0\n    >>> product\
    \ = 3, 4\n    (3.0, 4.0)\n\"\"\"", "    if a==0 or b==0\n        0\n    elseif\
    \ a==1 || b==1\n        a\n    else\n        greatest_common_divisor(b, a % b)\
    \ \nend\n</cell>\n<text>\n\u261D\U0001F3FF Exercise: Write the greatest common\
    \ divisor of a and b modulo 3", "    greatest_common_divisor = a\n    if b < a\
    \ \n        greatest_common_divisor = b\n    end\n    return greatest_common_divisor\n\
    end", "  if a==0 then return b else greatest_common_divisor(b,a%b) end\n  if b==0\
    \ then return a\n  else return greatest_common_divisor(a%b, b) end\nend\n</cell>\n\
    <code language=julia-1.0>\n\"\"\"\nGreatest Common Divisor for Arrays (in place)\n\
    \"\"\"", "    if a==0 \n    then return 0\n    else if b==0\n    then return a\n\
    \    else return greatest_common_divisor(b, a % b)\n    end\nend \n\"\"\"\n  \
    \  \n    \n\"\"\"\n    greatest_common_divisor_iterative(a::Int64, b::Int64)::Int64\
    \ \nReturn a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor_iterative(3,\
    \ 5)\n    1\n    >>> greatest_common_divisor_iterative(25, 15)\n    5\n    \"\"\
    \"", "    gcd = a % b\n    if gcd == 0\n        gcd = b % a\n    if gcd == 0\n\
    \        gcd = a % b\n    if gcd == 0\n        gcd = b % a\n    if gcd == 0\n\
    \        gcd = a % b\n    if gcd == 0\n        gcd = b % a\n    if gcd == 0\n\
    \        gcd = a % b\n    return gcd", "# compute greatest common divisor\n  \
    \  return if a == 0 || b == 0 \n    then 1\n    else greatest_common_divisor(b,\
    \ a % b) \nend\n</cell>\n<code language=julia-1.0>\n# test\ngreatest_common_divisor(3,4)\n\
    </cell>\n<text>\nExercise 3.17: greatest_common_divisors(n,k)", "    \n    gcd\
    \ = gcd(a,b) \n    if (gcd != 1) \n        gcd = greatest_common_divisor(a/gcd,\
    \ b/gcd) \n    else \n        gcd = a \n    end\n    return gcd \nend\n</cell>\n\
    <code language=julia-1.5>\n# Test code\n@test greatest_common_divisor(100, 22)\
    \ == 10\n@test greatest_common_divisor(100, 2) == 20\n@test greatest_common_divisor(50,\
    \ 22) == 50\n@test greatest_common_divisor(50, 2) == 20\n</cell>\n<text>\nPart\
    \ 3: Computing Riemann's constant $\\mathbb{R}$\nRiemann's constant $\\mathbb{R}$\
    \ describes the limit of the sum of the absolute value of a positive definite\
    \ $\\mathbb{Z}$ function. The sum of the absolute value of $\\mathbb{Z}$ function\
    \ $f$ is given by:", "    if a==0 || b==0 \n        then \n            return\
    \ b\n    else\n        return greatest_common_divisor(a-1, b) or greatest_common_divisor(a,\
    \ b-1)\nend\n</code>\nThe function above can help you find the greatest common\
    \ divisor of two positive integers. But how can you find it if both a and b are\
    \ negative? In this case, we have no choice but to repeatedly find the least common\
    \ multiple of the two integers until one of them is 1, or we find a difference\
    \ of 1. Then we can find the gcd between the two integers like this:\n<code>",
  "    if b==0 then return a\n    else return greatest_common_divisor(b, (a%b)/b)\
    \ \nend ", "    if a == 0 || b == 0 \n        0\n    elseif b == 1 \n        1\n\
    \    else\n        greatest_common_divisor(b, a mod b)\nend\n</code>\n<|/ a dscore=4\
    \ |>\n<| a dscore=4 |>\nThere are two ways of doing this in Julia:\n<code>\njulia>\
    \ a = 1\n1", "    | a<b = 0\n    | a>b = a\n    | a==b = 1\n    | a > b && a ==\
    \ a%b = greatest_common_divisor(a-b,b)\n    | otherwise = greatest_common_divisor(a,b-1)\
    \ + a\n</code>\n<|/ a |>\n<| a dscore=2 tags=math,algorithm,python |>\nI did this\
    \ in one line of C#:\n<code>\npublic static int GreatestCommonDivisor(int a, int\
    \ b)\n{\n    return a > b ? b : a % b == 0 ? a : GreatestCommonDivisor(b, a %\
    \ b);\n}\n</code>\n<|/ a |>\n<| a |>\n<code>\npublic static int gcd_fast(int a,\
    \ int b){\n        return b == 0 ? a : gcd_fast(b, a % b);\n    }\n</code>\n<|/\
    \ a dscore=2 tags=math,algorithm,python |>\n<| c |>\nThis works only because gcd\
    \ is a Euclid function (it won't work for non-Euclid numbers)\n<|/ c |>\n<| c\
    \ |>\nIn some cases it won't work like that, e.g. if the arguments are negatives\
    \ and zero\n<|/ c |>\n<| c |>\nThat's why I wrote \"in some cases\" because it\
    \ is based on Euclid's definition of gcd.\n<|/ c |>\n<| a dscore=1 |>\nThis is\
    \ not an answer to your original question, but I post it here because it has a\
    \ better title than your original question.\n<code>\ndef gcd(a,b):\n    while\
    \ b:\n        a, b = b, a%b\n    return a\n</code>\n<|/ a tags=math,algorithm,python\
    \ |>\n<| c |>\nThis answer does not give the greatest common divisor of the two\
    \ numbers, it gives the greatest common divisor of one number and one number.\n\
    <|/ c |>\n<| a dscore=1 |>\nHere is a more performant version in Rust:\n<code>\n\
    fn greatest_common_divisor(a: i64, b: i64) -> i64 {\n    if b == 0 {\n       \
    \ a\n    } else {\n        greatest_common_divisor(b, a%b)\n    }\n}\n</code>\n\
    It does not require the b == 1 case.\n<|/ a tags=math,algorithm,python |>\n<|\
    \ a tags=math,algorithm,python dscore=0 |>\n<code>\ndef gcd(a,b):\n if(a==b):\n\
    \  return a\n while(True):\n  if(a%b!=0):\n   a=a%b\n  else:\n   b=b", "    |\
    \ a < b = (a % b, b)\n    | a == b = 0\n    | otherwise = greatest_common_divisor(b,\
    \ a % b)\n    end\n</code>\n<|/ a tags=math,algorithm,performance |>\n<| c |>\n\
    Your gcd doesn't take into account negative numbers.\n<|/ c |>\n<| c |>\n: I see\
    \ - I've edited my answer to add that.\n<|/ c |>\n<| c |>\n: yes, that is true.\n\
    <|/ c |>\n<| c |>\nNice implementation, but in many cases the GCD could be negative,\
    \ e.g. `greatest_common_divisor(8, -6) == -2`.\n<|/ c |>\n<| c |>\n: good point.\
    \ I had edited my answer to take into account negative numbers as well; however,\
    \ I hadn't tested the solution for negative numbers; I hadn't noticed that I had\
    \ written it without taking this into account.\n<|/ c |>\n<| a dscore=2 |>\nYou\
    \ will get wrong answer if your first number is a factor of second number:\n<code>\n\
    def gcd(a, b):\n    while b != 0:\n        a, b = b, a%b\n    return a\n</code>\n\
    <|/ a tags=math,algorithm,performance |>\n<| c |>\nYes that's the point of greatest\
    \ common divisor function... to compute greatest common divisor\n<|/ c |>\n<|\
    \ c |>\nAh yes, that's true... I'll change my answer.\n<|/ c |>\n<| c |>\nThis\
    \ will return -1 if b is not even.\n<|/ c |>\n<| c |>\nAhh I see it now. Thanks.\n\
    <|/ c |>\n<| c |>\nIf you find my answer to useful, please consider accepting\
    \ it by clicking the green check mark.\n<|/ c |>\n<| a dscore=1 tags=math,algorithm,performance\
    \ |>\n<code>\nint gcd(int a, int b) {\n    while (b != 0) {\n        int tmp =\
    \ a % b;\n        a = b;\n        b = tmp;\n    }\n    return a;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis returns negative numbers if b is not even.\n<|/ c |>\n\
    <| c |>\nYes, it returns negative numbers when b is not even.\n<|/ c |>\n<| a\
    \ tags=math,algorithm,performance |>\n<code>\ndef gcd(a,b):\n    while b != 0:\n\
    \        a, b = b, a%b\n    return a\n</code>\n<|/ a ", "    \"\"\"Function <function-name>\"\
    \"\"\n    if b == 0 \n        return a \n    else if a % b == 0\n        then\
    \ return greatest_common_divisor(b, a % b) \n        else return greatest_common_divisor(b,\
    \ (a%b)/b) \nend\n</code>\n<|/ a dscore=2 tags=julia |>\n<| c |>\nGreat answer!\
    \  Thank you! The first return can be replaced with `a / b`.\n<|/ c |>\n<| a tags=julia\
    \ |>\nI made some changes that allow you to compute GCD of any integer with any\
    \ number using Division.\n<code>\ngcd(a::Int64, b::Int64)::Int64 = if a > b \n\
    \    a \nelse \n    b > 0 ? gcd(a % b, b) : gcd(b, a % b) \nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\n`gcd(a,b)=gcd(b,a%b)=b` - this could be slightly more\
    \ efficient.\n<|/ c |>\n<| a dscore=1 |>\nHere's a variation on the \"Euclid's\
    \ algorithm\" which does not use recursion:\n<code>", "    \"\"\"\n    >>> greatest_common_divisor(32,\
    \ 10)\n    8\n    >>> greatest_common_divisor(32, 2)\n    32\n    \"\"\"\n   \
    \ if b == 0 or b == a then return b\n    else if b > a then return greatest_common_divisor(a\
    \ * b, b) \n    else return greatest_common_divisor(a, b div a)\nend\n</code>\n\
    <|/ a dscore=1 tags=julia |>\n<| c |>\nAh, but your first code example is not\
    \ using recursion.\n<|/ c |>\n<| a tags=julia |>\nAn alternative solution which\
    \ uses tail recursion:\n<code>", "    if b == 0 \n        then return a\n    else\
    \ \n        return greatest_common_divisor(b, a % b)\nend\n</code>\nThis function\
    \ works well for most of the test cases except for case where both the numbers\
    \ are of even digits. In that case gcd function is not working. I tried to figure\
    \ out the root cause for the issue but no luck so far. Please help me with this.\
    \ Thanks in advance.\n<|/ q dscore=0 |>\n<| c |>\nWhat do you mean by \"is not\
    \ working\"? Does it throw an error? Does it not produce the correct result?\n\
    <|/ c |>\n<| c |>\nWhat do you mean by \"is not working\"? The code you posted\
    \ will \"work\" for most of the test cases except for \"case where both the numbers\
    \ are of even digits\", right? What test cases fail?\n<|/ c |>\n<| c |>\nSorry\
    \ for the confusion. I meant that gcd function is not working for the case of\
    \ both the numbers are of even digits. For example, gcd(10, 5) should be 1 but\
    \ it is giving 5. I am not able to figure out the root cause for the issue.\n\
    <|/ c |>\n<| c |>\nOh, ok. So what \"not working\" are you referring to? What's\
    \ it giving you when it \"doesn't work\"? And what \"root cause\" are you referring\
    \ to? Please be more specific.\n<|/ c |>\n<| a dscore=1 |>\nYou are calling gcd\
    \ recursively in your gcd function. This will result in a stack overflow. Here\
    \ is a link to the official gcd implementation on Julia documentation: https://julialang.org/en/v1/stdlib/math/gcd.html\n\
    The correct code for the gcd function should be the following:\n<code>", "   \
    \ \"\"\"\n    greatest_common_divisor(a::Int64, b::Int64)", "    a = a.abs()\n\
    \    b = b.abs()\n    \n    while a > b\n        a = a.mod(b)\n    return a\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"\n greatest_common_divisor_iter\
    \ \n    Iterative implementation of greatest_common_divisor", "    if (a<b) then\n\
    \        return greatest_common_divisor(b, a)\n    else\n        return a\n</code>\n\
    <|/ a |>\n<| a tags=greatest-common-divisor,haskell,recursion |>\n<code>\ngcd::Int64->Int64->Int64\n\
    gcd x 0 = 1\ngcd x y = gcd y (x `div` y)\n</code>\n<|/ a dscore=2 |>\n<| a tags=greatest-common-divisor,haskell,recursion\
    \ dscore=1 |>\nIn case you like more readable definition, you can use the following\
    \ definition\n<code>\ngreatestCommonDivisor :: Integral a => a -> a -> a\ngreatestCommonDivisor\
    \ 1 0 = 0\ngreatestCommonDivisor x y = greatestCommonDivisor (x `mod` y) y\n</code>\n\
    <|/ a |>\n<| c |>\n`greatestCommonDivisor` is a terrible name for a function that\
    \ computes GCD. It would be better if that function returned the GCD of 2 numbers.\
    \ In fact, you should also have `greatestCommonDivisor x y = greatestCommonDivisor\
    \ y x`\n<|/ c |>\n<| a dscore=1 |>\n<code>\nimport Data.Int", "    if b == 0 then\
    \ return a\n    return greatest_common_divisor(b, a%b)\nend", "    if b == 0 \n\
    \        then return a\n    else \n        greatest_common_divisor(b, a%b)\n \
    \   end\nend\n</code>\n<|/ a |>\n<| c |>\nThis solution is not tail recursive,\
    \ since the recursive call to `greatest_common_divisor` does not return.\n<|/\
    \ c |>\n<| c |>\nThe `greatest_common_divisor` function ends with `return`, so\
    \ it's tail recursive.\n<|/ c |>\n<| c |>\nOh, I see.  I didn't notice that the\
    \ original `greatest_common_divisor` was the recursive one.\n<|/ c |>\n<| c |>\n\
    Why did you decide that `greatest_common_divisor` should return `Int64`? As far\
    \ as I can tell it doesn't. Also, why is it not tail recursive? How does this\
    \ differ from [my answer](https://stackoverflow.com/a/52479344/192373), which\
    \ uses tail recursion?\n<|/ c |>\n<| c |>\nYes, but isn't the return type `Int64`\
    \ not necessary for tail recursion? And isn't the return type `Int64` required\
    \ for tail recursion?\n<|/ c |>\n<| a |>\nIt is not possible to compute this in\
    \ a way that is both faster and tail-recursive, since it involves computing the\
    \ greatest common divisor and taking its ceiling -- both of which are not tail\
    \ recursive.\n<|/ a tags=math,julia,integer-division dscore=3 |>\n<| c |>\nWhat\
    \ about this - https://math.stackexchange.com/questions/27825/algorithm-to-find-greatest-common-divisor-for-2-numbers?\n\
    <|/ c |>\n<| a dscore=3 tags=math,julia,integer-division |>\nThe function below\
    \ returns GCD using Euclid's algorithm, which is fast.\n<code>", "    if a > b\
    \ then\n        return(greatest_common_divisor(b,a))\n    else\n        return(a)\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>", "    if a < 0\n        throw(ArgumentError(\"\
    a must be non-negative\"))\n    elseif b < 0\n        throw(ArgumentError(\"b\
    \ must be non-negative\"))\n    else if a == 0\n        throw(ZeroDivisionError(\"\
    a cannot be zero\"))\n    elseif b == 0\n        throw(ZeroDivisionError(\"b cannot\
    \ be zero\"))\n    else if b > a\n        throw(ArgumentError(\"b must be greater\
    \ than a\"))\n    else\n        return (a // b)\nend\n</cell>\n<text>\nThe greatest\
    \ common divisor of two integers a and b is the greatest integer $a\\lfloor\\\
    frac{b}{a}\\rfloor$ such that $a\\lfloor\\frac{b}{a}\\rfloor \\bmod \\equiv 0$.\
    \ Thus, $a\\lfloor\\frac{b}{a}\\rfloor$ would be the least common multiple of\
    \ a and b."]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
