name: HumanEval_69_search
language: jl
prompt: "\"\"\"\n    You are given a non-empty vector of positive integers. Return\
  \ the greatest integer that is greater than \n    zero, and has a frequency greater\
  \ than or equal to the value of the integer itself. \n    The frequency of an integer\
  \ is the number of times it appears in the vector.\n    If no such a value exist,\
  \ return -1.\n    Examples:\n    >>> search([4, 1, 2, 2, 3, 1])\n    2\n    >>>\
  \ search([1, 2, 2, 3, 3, 3, 4, 4, 4])\n    3\n    >>> search([5, 5, 4, 4, 4])\n\
  \    -1\n    \"\"\"\nfunction search(lst::Vector{Int64})::Int64 \n"
tests: "using Test\n\n@testset begin\n\ncandidate = search;\n\t@test(candidate([5,\
  \ 5, 5, 5, 1]) == 1)\n\t@test(candidate([4, 1, 4, 1, 4, 4]) == 4)\n\t@test(candidate([3,\
  \ 3]) == -1)\n\t@test(candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8)\n\t@test(candidate([2,\
  \ 3, 3, 2, 2]) == 2)\n\t@test(candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4,\
  \ 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1)\n\t@test(candidate([3, 2, 8, 2]) == 2)\n\t\
  @test(candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1)\n\t@test(candidate([8,\
  \ 8, 3, 6, 5, 6, 4]) == -1)\n\t@test(candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9,\
  \ 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1)\n\t@test(candidate([1, 9,\
  \ 10, 1, 3]) == 1)\n\t@test(candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3,\
  \ 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5)\n\t@test(candidate([1]) == 1)\n\t@test(candidate([8,\
  \ 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4)\n\t\
  @test(candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2)\n\
  \t@test(candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1)\n\t@test(candidate([9,\
  \ 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2,\
  \ 8, 10, 9, 4]) == 4)\n\t@test(candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3,\
  \ 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4)\n\t@test(candidate([9, 8, 6, 10, 2, 6, 10,\
  \ 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2)\n\t@test(candidate([5, 5, 3, 9, 5, 6,\
  \ 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1)\n\t@test(candidate([10])\
  \ == -1)\n\t@test(candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2)\n\t\
  @test(candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1)\n\t@test(candidate([7,\
  \ 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1)\n\t@test(candidate([3,\
  \ 10, 10, 9, 2]) == -1)\nend\n"
completions: ["    cnt = 0\n    for x in lst \n        if x==0 \n            return\
    \ -1\n        else \n            cnt += 1;\n    end\n    return cnt\nend", " \
    \    for i in 1 .. length(lst)\n         if lst[i-1] > 0\n             if count(i)\
    \ > count(lst[i-1]) + count(lst[i]) \n                 return i\n            \
    \ else\n                 return -1\n         else\n             return -1\n  \
    \   end\nend", "    lst = sort(lst)\n    n = 0\n    maximum = 0\n    maximum_frequency\
    \ = -1\n    for x in lst\n        if x < maximum_frequency \n            maximum_frequency\
    \ = x\n        elseif x == maximum_frequency\n            n += 1\n           \
    \ maximum_frequency = x\n        else\n            maximum = maximum_frequency\n\
    \            maximum_frequency = x\n            n = maximum\n        end\n   \
    \ end\n    if n <= 0\n        return -1\n    else\n        return maximum\n  \
    \  end\nend\n</code>\n<|/ a |>\n<| c |>\nNice solution. I would just add a `break`\
    \ after the `else` block and omit the unnecessary `else` block.\n<|/ c |>\n<|\
    \ c |>\nThe only problem with this approach is that it fails for vectors with\
    \ negative values.  For example, search([-1, 0, 1, 2, 2, 2]) returns 4 when it\
    \ should be 3.\n<|/ c |>\n<| a tags=search,arrays,algorithm,julia |>\nMy attempt:\n\
    <code>\nusing BenchmarkTools", "    \"\"\"\n    Vector{Int64}\n    \"\"\"\n  \
    \  if length(lst) == 0 || length(lst) == 1 || lst[0] == 0 || lst[0] == 1\n   \
    \     return -1\n    else\n        for v in lst\n            if v > 0\n      \
    \          tmp = 1\n                while tmp <= v\n                    tmp +=\
    \ 1\n                end\n                if tmp > v\n                    return\
    \ v\n                else\n                    v = tmp - 1\n                end\n\
    \            end\n        end\n        return -1\n    end\nend\n</cell>\n<code\
    \ language=julia-0.4>", "    \n    ans = -1\n    lst = sort(lst)\n    for i in\
    \ lst\n        if i >= 0\n            ans = i\n            break\n    end\n  \
    \  \n    return ans\nend", "        if all(element > 0 for element in lst) ==\
    \ false \n            return -1\n            \n            \n            \n  \
    \          \n            \n            \n            \n            \n        \
    \    \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            ", "    sorted\
    \ = sort(lst)\n    for el in sorted \n        if el > 0\n            return el\n\
    \        end\n    end\n    return -1\nend", "    \"\"\"\n    You are given an\
    \ integer and a non-empty vector of positive integers. \n    Determine if the\
    \ vector contains at least one occurrence of the integer \n    and, if so, return\
    \ that integer. If the integer does not appear in the vector, \n    return -1.\n\
    \    \"\"\"\n    sum=0\n    freq=0\n    for i in lst\n        if sum<=i \n   \
    \         sum+=i\n        else \n            if sum==i\n                freq+=1\n\
    \            sum=0\n        end\n    end\n    if freq>0\n        return i\n  \
    \  else\n        return -1\n    end\nend\n</cell>\n<code language=julia-1.0>",
  "    if lst == []\n        return -1\n    \n    minimum = minimum(lst)\n    \n \
    \   if minimum == 0 \n        return -1\n    \n    count = 1\n    for i in lst\n\
    \        count += 1\n        if i == minimum\n            count += 1\n       \
    \ end\n    \n    return minimum\nend\n</code>\n<|/ a tags=algorithm,julia dscore=0\
    \ |>\n<| a dscore=0 tags=algorithm,julia |>\nI am posting two answers as there\
    \ were 2 issues pointed out in the comments (@Matt Hamilton and in his answer),\
    \ but I think they are relevant to show some approaches. So I am posting them\
    \ separately for completeness.\nLet's start with the second question. Recall that\
    \ it is easy to find the maximum (the one with the most occurrences) in a vector.\
    \ There are a couple ways to do this. A simple way is to use the maximum() function\
    \ (which we already know). This will return the maximum of a vector. For example,\
    \ maximum([5, 4, 3, 6, 2]) will return 6. There are other functions that can do\
    \ this job for you (e.g., the sum() function which will return the sum of the\
    \ elements in the vector). But I wanted to show that there are (as far as I know)\
    \ two functions that can do this for you as well: maximum and sort. For example,\
    \ maximum([5, 4, 3, 6, 2]) will return 6. sort([5, 4, 3, 6, 2]) will return a\
    \ vector that is sorted in ascending order (from smallest to greatest). So, in\
    \ order to find the maximum, you need to find the maximum of your vector after\
    \ it is sorted. There are many ways to do this as well, but I wanted to show one\
    \ simple way - using maximum. Let's start with the second issue (@Matt Hamilton).\n\
    <code>", "    freqs = frequency(lst)\n    len = length(lst)\n    inds = findall(x\
    \ -> x > 0, lst)\n    inds = setdiff(inds, setdiff(1:length(lst), inds))\n   \
    \ for i in inds\n        if freqs[i] == 0 && len > 1\n            return -1\n\
    \        elseif freqs[i] == 1 && (len == 0 || len == 1)\n            return lst[i]\n\
    \        elseif freqs[i] > 0 && len == 1 && freqs[i] > freqs[inds[1]]\n      \
    \      return lst[i]\n        else\n            return -1\n        end\n    end\n\
    \    return -1\nend\n</cell>\n<code language=julia-1.4>", "    freq = Dict{Int64,Int64}()\n\
    \    for i in lst\n        if freq[i] < 1\n            freq[i] = 0\n        end\n\
    \        freq[i] += 1\n    end\n    if freq[max(freq)] < 0\n        return -1\n\
    \    else\n        return max(freq)\n    end\nend", "    \n    if lst==[]\n  \
    \      return -1\n    end\n    \n    minimum = minimum(lst)\n    \n    count =\
    \ 0\n    for i in lst\n        if i==minimum\n            count += 1\n       \
    \ else\n            return -1\n        end\n    end\n    return minimum\nend",
  "    \"\"\"\n    O(N)\n    \"\"\"\n    for x in lst \n        if x > 0 \n      \
    \      return x \n    end\n    return -1 \nend", "    if length(lst)==0 \n   \
    \     return -1 \n    end\n    freq = Dict()\n    for x in lst \n        freq[x]\
    \ = get!(freq,x,0) + 1\n    end\n    return first(freq,last(freq))\nend\n</cell>\n\
    <text>\nThe function search! modifies the dictionary freq in-place to store the\
    \ frequency of each integer. \nThis is done efficiently using get!. \nNote that\
    \ this idiom is called a \u201Cmutating dictionary\u201D in Julia. \nMutating\
    \ dictionaries are extremely fast, and Julia\u2019s implementation is pretty good.",
  "  local v = zeros(Int64)\n  local i =-1\n  \n  for i=1:length(lst)\n    v[lst[i]]+=1\n\
    \  endfor\n  for i=1:length(lst)\n    if v[lst[i]]>=v[lst[i]]\n      return lst[i]\n\
    \    end\n  endfor\n  return -1\nend", "    if length(lst) < 1 \n        return\
    \ -1 \n    else \n        index = findfirst(x -> x > 0, lst)\n        if index\
    \ < 1 \n            return -1 \n        else \n            return lst[index-1]\n\
    \    end\nend\n</cell>\n<text>\n4. Implement a function to count and return the\
    \ number of times the given value occurs in a given vector.", "    if isempty(lst)\n\
    \        return -1\n    end", "    if lst.isEmpty\n        return -1\n    elseif\
    \ head(lst) == -1\n        return -1\n    else\n        firstVal = head(lst)\n\
    \        firstIndex = find(lst, firstVal)\n        if firstIndex == -1\n     \
    \       return -1\n        else\n            lastVal = last(lst)\n           \
    \ lastIndex = find(lst, lastVal)\n            if lastIndex == -1\n           \
    \     return -1\n            else\n                searched = firstIndex + lastIndex\n\
    \                if searched == length(lst)\n                    return -1\n \
    \               else\n                    if searched%2 == 0\n               \
    \         return last(lst)\n                    else\n                       \
    \ return first(lst)\n                end\n            end\n        end\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\n# In[44]:= search([4, 1, 2, 2, 3, 1])\n\
    </cell>\n<text>\nSearching in a BST", "    #Your code goes here\n    \nend\n</cell>\n\
    <text>\n13. Repetition\nA repetition is a sequence of words or phrases containing\
    \ repeated words, such as \"please help me\" and \"please help me\nyou\". You\
    \ can think of a repetition as a repetition of the same word or phrase.", "  \
    \ local result=-1\n   for i in lst\n    if i > 0 \n        local freq=length(find(lst==i))\n\
    \        if freq > result \n            result=i\n        end\n    end\n end\n\
    \   return result\nend\n\"\"\"\nYour Solution object (100 points)\nWrite a solution\
    \ object with the following methods:", "\"\"\"\n    You are given a vector of\
    \ the integers you are searching through, and a target value.  Return the\n  \
    \  index of the target value if it is in the vector; otherwise return -1.\n  \
    \  \n    Examples:\n    >>> search([4, 1, 2, 2, 3, 1], 2)\n    2\n    >>> search([1,\
    \ 2, 2, 3, 3, 3, 4, 4, 4], 3)\n    3\n    >>> search([5, 5, 4, 4, 4], 4)\n   \
    \ -1\n    \"\"\"", "    \n    for i in lst\n        if i == 0 return 0\n    end\n\
    \    \n    if length(lst) == 0 return -1\n    \n    \n    for i in lst\n     \
    \   if i == 0 \n            return i\n        elseif i == lst[end]\n         \
    \   return length(lst)\n        end\n    end\nend", "    if lst[1] == 1 \n   \
    \     return lst[0] \n    end\n    i = 1\n    freq = Dict{Int64, Int64}()\n  \
    \  while i <= length(lst) and i in freq \n        freq[i] = freq[i] + (lst[i]\
    \ - i)\n        i += 1\n    end\n    if length(lst) > i \n        minimum = minimum(freq.values())\
    \ \n        freq[i] = freq[minimum]\n    end\n    return minimum\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=performance,julia |>\nHere is my solution:\n<code>",
  "  \n    # Write your code here\n    \n    first = lst[1]\n    last = lst[n]\n \
    \   if last < first\n        return -1\n    elseif last == first \n        return\
    \ last\n    else\n        freq_count = 0\n        for i = first to last\n    \
    \        if lst[i] == first\n                freq_count+=1\n            else\n\
    \                freq_count-=1\n                \n                if freq_count\
    \ >= last\n                    return i\n                end\n            end\n\
    \        end\n    end\nend\n</code>\n<|/ a |>\n<| a |>\nThe algorithm can use\
    \ O(n) time and O(n) space. Here is an implementation in Julia:\n<code>", "  \
    \  \n    if length(lst) == 0 \n        return -1 \n    \n    i = length(lst) \n\
    \    \n    while i \n    \n        while i \n        \n            if lst[i] >\
    \ 0 \n                i -= 1\n                break\n            \n          \
    \  if lst[i] == 0 \n                return -1 \n            \n            i -=\
    \ 1\n        \n        if i \n            i -= 1\n        else\n            i\
    \ = length(lst)\n        \n    end\n    return lst[i - 1]\nend\n</cell>\n<code\
    \ language=julia-1.5>\nsearch([4, 1, 2, 2, 3, 1])\n</cell>\n<text>\n4.3 Binary\
    \ Search\nWe will now implement binary search algorithm to find an element in\
    \ the sorted vector.", "    if length(lst) <= 0 \n        \n        return -1\n\
    \    end\n    \n    maximum = minimum(lst)\n    greatest = maximum(lst)\n    \n\
    \    index_of_maximum = findfirst(x -> x == maximum, lst)\n    \n    if index_of_maximum\
    \ == -1\n        return -1\n    end\n    \n    freq_of_greatest = frequency(index_of_maximum,\
    \ lst)\n    \n    if freq_of_greatest >= greatest\n        return -1\n    end\n\
    \    \n    return maximum\nend", "    flag = Any\n    for i in lst do\n      \
    \  if i == 0 then \n            flag = i\n            break\n        elseif i%2\
    \ == 0 then \n            flag = i\n            break\n        else\n        \
    \    flag = Any\n            break\n        end\n    end\n    \n    if flag ==\
    \ Any \n        return -1\n    end\n    \n    count = 1\n    for i in lst do\n\
    \        if i == flag % 2\n            count += 1\n        end\n    end\n    return\
    \ count\nend\n\"\"\"\n    You are given an integer matrix representing an image.\n\
    \    You are asked to fill the matrix with zeros and ones.\n    One represents\
    \ the pixel that has value of 1 (white).\n    All other pixels are black except\
    \ for ones that are adjacent to white ones.\n    For example, given the following\
    \ image\n    0 0 0 0 0\n    1 1 0 0 0\n    0 0 1 1 1\n    1 1 1 1 1\n    The given\
    \ matrix should be\n    0 0 0 0 0\n    1 1 0 0 0\n    0 0 1 1 1\n    1 1 1 1 1\n\
    \    1 1 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n \
    \   1 1 1 1 1\n    1 1 1 1 1\n    1 1 1 1 1\n    1 1 0 0 0\n    0 0 0 0 0\n  \
    \  0 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n    1 1 0 0 0\n    0 0 0 0 0\n   \
    \ 0 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n    1 1 1 1 1\n    1 1 1 1 1\n    1\
    \ 1 1 1 1\n    1 1 1 1 1\n    1 1 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n    0 0\
    \ 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n    1 1 0 0 0\n    0 0 0 0 0\n    0 0 0\
    \ 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n    1 1 1 1 1\n    1 1 1 1\
    \ 1\n    1 1 1 1 1\n    1 1 1 1 1\n    1 1 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n\
    \    0 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n    1 1 0 0 0\n \
    \   0 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n  \
    \  0 0 0 0 0\n    1 1 1 1 1\n    1 1 1 1 1\n    1 1 1 1 1\n    1 1 1 1 1\n   \
    \ 1 1 1 1 1\n    1 1 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n    0\
    \ 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n    1 1 0 0 0\n    0 0\
    \ 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n    0 0 0\
    \ 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n    1 1 1 1 1\n    1 1 1 1 1\n    1 1 1 1\
    \ 1\n    1 1 1 1 1\n    1 1 1 1 ", "    if length(lst) == 0 \n        return -1\n\
    \    end\n    return search_inorder(lst)\nend\nend\n</code>\n<|/ a tags=recursion,julia,search\
    \ dscore=3 |>\n<| a tags=recursion,julia,search |>\nThis is just to provide another\
    \ answer, since the accepted answer is wrong and has been deleted.\n<code>", " \
    \   lst = sort(lst)\n    for a in lst[1..end-1] \n        if a == lst[end]\n \
    \           return -1\n        else\n            if a < lst[end]\n           \
    \     return search(lst, a+1)\n            else\n                return a\n  \
    \          end\n        end\n    end\nend", "    \n    if length(lst)==0 return\
    \ -1\n    \n    val=sort(lst)\n    val=unique(val)\n    \n    for i in val\n \
    \       if i!=val[end] \n            if i==val[end] \n                if val[end]==val[end-1]\
    \ \n                    return val[end]\n                else \n             \
    \       return -1\n            else\n                return i\n        end\n \
    \   end\n    return -1\nend\n</cell>\n<text>\nExercise 6\nWrite a function that\
    \ accepts a vector of positive integers and returns the first non-negative integer\
    \ that appears in it. If no such integer exists, return -1.", "    findmax = 0\n\
    \    for n in lst\n        if findmax < n\n            findmax = n\n        elseif\
    \ n != findmax && findmax >= n\n            findmax = n\n        end\n    end\n\
    \    return findmax\nend\n</code>\n<|/ a |>\n<| a |>\nA solution for those who\
    \ are still looking for a solution. My solution takes into account the requirement\
    \ that the list is sorted.\n<code>", "    if length(lst) == 0 \n        return\
    \ -1 \n    \n    local freq::Int64 = 0 \n    \n    for i in lst\n        freq\
    \ += 1 \n        if i > 0 \n            return i \n        else \n           \
    \ local counter::Int64 = 0 \n            for j in lst\n                counter\
    \ += 1 \n                if counter == freq \n                    return j \n\
    \                end\n            end\n        end\n    end\nend\n</cell>\n<code\
    \ language=julia-1.1>\n# TEST search_sorted\n@test search_sorted([1,2,2,3]) ==\
    \ 3\n@test search_sorted([2,4,2,5]) == 3\n@test search_sorted([10,11,10,10]) ==\
    \ -1\n@test search_sorted([5,4,4,5]) == -1\n</cell>\n<text>\nExercise 2: Find\
    \ an index\nWrite a function that takes in a sorted vector of ints, and returns\
    \ the index of an int if it exists in the vector, otherwise returns -1.", "  \
    \      \n    if lst == []\n        return -1\n    \n    # sort on increasing value\
    \ \n    lst.sort\n    \n    # find first value which is greater than 0\n    pos1\
    \ = find(lst .>= 0)\n    \n    if pos1 == 0\n        return 0\n    \n    # find\
    \ first value in increasing sequence which has frequency greater than the value\
    \ at pos1\n    pos2 = find(lst .>= lst [pos1])\n    \n    if pos2 == length(lst)\n\
    \        return pos2\n    \n    # find last value which is greater than pos1 and\
    \ less than pos2\n    pos3 = find(lst .<= lst [pos1])\n    \n    if pos3 == length(lst)\n\
    \        return pos3\n    \n    # find last value in increasing sequence which\
    \ has frequency greater than the value at pos3\n    pos4 = find(lst .<= lst [pos3])\n\
    \    \n    if pos4 == length(lst)\n        return pos4\n    \n    # find first\
    \ value in decreasing sequence which has frequency greater than the value at pos3\n\
    \    pos5 = find(lst .<= lst [pos3])\n    \n    if pos5 == length(lst)\n     \
    \   return pos5\n    \n    # find first value in decreasing sequence which has\
    \ frequency greater than the value at pos4\n    pos6 = find(lst .>= lst [pos4])\n\
    \    \n    if pos6 == length(lst)\n        return pos6\n    \n    # find last\
    \ value which is greater than pos5 and less than pos6\n    pos7 = find(lst .>=\
    \ lst [pos5])\n    \n    if pos7 == length(lst)\n        return pos7\n    \n \
    \   # find last value in decreasing sequence which has frequency greater than\
    \ the value at pos7\n    pos8 = find(lst .>= lst [pos7])\n    \n    if pos8 ==\
    \ length(lst)\n        return pos8\n    \n    # find first value in increasing\
    \ sequence which has frequency greater than the value at pos7\n    pos9 = find(lst\
    \ .>= lst [pos7])\n    \n    if pos9 == length(lst)\n        return pos9\n   \
    \ \n    # find first value in increasing sequence which has frequency greater\
    \ than the value at pos9\n    pos10 = find(lst .>= lst [pos9])\n    \n    if pos10\
    \ == length(lst)\n        return pos10\n    \n    # find last value which is greater\
    \ than pos10 and less than pos9\n    pos11 = find(lst .>= lst [pos10])\n    \n\
    \    if pos11 == length(lst)\n        return pos11\n    \n    # ", "    for num\
    \ in lst \n        if freq[num] == freq[num] && (freq[num] >= num) \n        \
    \    return num \n    return -1 \nend", "    \n    local max=-1\n    local maxfreq=0\n\
    \    for i in 1 .. length(lst)\n        if (lst[i] >= 0)\n            then\n \
    \               local counter=0\n                for k in 1 .. length(lst)\n \
    \                   if (lst[k] == i)\n                        then\n         \
    \                   counter=counter+1\n                        end\n         \
    \       end\n                \n                if (counter >= maxfreq)\n     \
    \               then\n                        max=i\n                        maxfreq=counter\n\
    \                end\n            end\n    end\n    return max\nend\n</cell>\n\
    <code language=julia-1.4>\n# Run this cell to load the tests.\ninclude(\"./Tests.jl\"\
    )\n</cell>\n<code language=julia-1.4>\n@test search([4, 1, 2, 2, 3, 1]) == 2 #\
    \ this should not throw any error\n@test search([1, 2, 2, 3, 3, 3, 4, 4, 4]) ==\
    \ 3\n@test search([5, 5, 4, 4, 4]) == -1\n</cell>\n<text>\n13. Intersection\n\
    Given two arrays arr1 and arr2, write a function that returns an array that contains\
    \ the values common to both arr1 and arr2, without duplicates.", "    for i in\
    \ lst\n        if i > 0 && i%2 != 0 && listfreq(lst) == listfreq(lst[i-1])\n \
    \           return i\n        else\n            return -1\n        end\n    end\n\
    \    return -1\nend", "    n=length(lst)\n    if n==0\n        return -1\n   \
    \ end\n    cnt=zeros(Int64,n)\n    for (i,x) in enumerate(lst)\n        cnt[i]=get(cnt,i)+1\n\
    \    end\n    return argmax(cnt[!cnt.==0])\nend\n</cell>\n<code language=julia-1.3>\n\
    # using BenchmarkTools\n@btime search([4,1,2,3,3])\n@btime search([4,1,2,2,3,1])\n\
    @btime search([5,5,4,4,4])\n</cell>\n<text>\nA more efficient version of the search\
    \ function", "    \n    if length(lst) == 0 \n        return -1 \n    \n    if\
    \ lst[0] < 0 \n        return -1 \n    \n    if lst[1] > lst[0] \n        return\
    \ -1 \n    \n    if lst[1] > 0 \n        return lst[1] \n    \n    search(lst[2:end])\
    \ \nend", "    \n    cnts = Dict{Int64, Int64}()\n    for i in lst\n        cnts[cnts[i]]\
    \ = get(cnts, i, 0) + 1\n    end\n    max(cnts, key = collect(x -> x[2], cnts)[2],\
    \ default=-1)\nend\n</cell>\n<text>\nSearch in sorted vector\nTo search for a\
    \ value in the sorted vector, the binary search method can be used as:", "   \
    \ #write your code here\n    n = length(lst)\n    if n==0\n        error(\"empty\
    \ list\")\n    end\n    \n    if lst[1]>0\n        return lst[1]\n    end\n  \
    \  \n    \n    \n    \n    if length(lst)>1\n        maximum = Int64(-1)\n   \
    \     minimum = Int64(1) \n        \n        i = 2\n        \n        while i\
    \ < n\n            if lst[i]>maximum\n                maximum = lst[i]\n     \
    \       elseif lst[i]<minimum\n                minimum = lst[i]\n            else\n\
    \                continue\n            end\n            \n            i += 1\n\
    \        end\n        return maximum\n    end\n    \n    \n    \n    \n    return\
    \ -1\nend\n</cell>\n<code language=julia-1.0>\n@time search(collect(1:1e7))\n\
    </cell>\n<text>\nA function to be used only in testing part", "    if lst == []\
    \ \n        return -1\n    if maximum(lst) == lst \n        return maximum(lst)\n\
    \    \n    if length(lst) > size(lst,1) \n        return -1", "    max = -1\n\
    \    pos = 0\n    for e in lst\n        if max < 0\n            max = e\n    \
    \    elseif e > max\n            max = e\n        end\n    end\n    if max >=\
    \ 0\n        for e in lst\n            if e > max\n                max = e\n \
    \               pos = 1\n            end\n        end\n    end\n    return max\n\
    end\n</cell>\n<text>\nSearch for the first maximum\nNow let's have a look at the\
    \ previous implementation. Let's try out what happens when we try to find the\
    \ first maximum of a vector. Here's the example that produced the incorrect result:",
  "    lst.sort()\n    return search(lst,0)\nend", "        if length(lst) == 0\n\
    \            return -1\n        else if length(lst) == 1\n            return lst[1]\n\
    \        else\n            lst[length(lst)] = 0\n            if lst[length(lst)\
    \ - 1] > 0\n                index = search(lst[1 : end - 1]) + 1\n           \
    \     lst[index] = lst[length(lst) - 1] + 1\n                return index\n  \
    \          else\n                index = search(lst[1 : end - 1]) + 1\n      \
    \          return index - 1\n            end\n        end\n    end\n    \"\"\"\
    \n    You are given a vector of integers. Return all non-zero elements in the\
    \ vector in increasing order.\n    You can assume each element in the vector is\
    \ nonnegative.\n    Examples:\n    >>> a = [1,-2,3,-4]\n    >>> remove_negative(a)\n\
    \    [1, 2, 3, 4]\n    \"\"\"", "    if lst.size==0 \n        return -1\n    greatest=0\n\
    \    greatest_freq=0\n    for i in lst do \n        \n        if i>=greatest \n\
    \            greatest=i \n        else if i>=greatest_freq \n            greatest_freq=i\
    \ \n        end\n    end\n    return greatest\nend", "    \n    if length(lst)\
    \ == 0 \n        return -1\n    end\n    if lst[end] == 0\n        return -1\n\
    \    end\n    if lst[end] == 1\n        return lst[end-1]\n    end\n    \n   \
    \ i = search(lst[end-1:-1:1])\n    if i == -1\n        return -1\n    end\n  \
    \  if i < (end - 1)\n        \n        if i > length(lst)\n            return\
    \ -1\n        end\n        \n        if lst[i] > lst[end]\n            lst[i]\
    \ = 1\n        end\n        \n        if lst[i] == 1\n            return i\n \
    \       end\n        return -1\n    end\n    \n    \n    return -1\nend\n    ",
  "    \n    if lst == nil\n        return -1\n    \n    last = lst[1]\n    \n   \
    \ for ix in 2:length(lst)\n        if lst[ix] < last\n            last = lst[ix]\n\
    \        else\n            if last > lst[ix]\n                return last\n  \
    \          else\n                last = lst[ix]\n            end\n        end\n\
    \    end\n    return last\nend\n</cell>\n<cell>", "    \n    if length(lst) ==\
    \ 0 \n        return -1 \n    \n    i = findfirst(x -> x > 0, lst)\n    \n   \
    \ if i == length(lst)-1 \n        return -1 \n    \n    return lst[i] \nend\n\
    </code>\n<|/ a tags=julia |>\n<| a dscore=2 |>\nThe answer from is great, but\
    \ if you're looking for something quick and dirty, you could simply do the following,\
    \ though it may have a small advantage (at least in terms of performance) than\
    \ the other answers:\n<code>", "  \n  maximum, count = -1, 0\n  for elem in lst\n\
    \    if elem < 0\n      continue\n    if elem == maximum\n      count += 1\n \
    \   else\n      maximum = elem\n      count = 1\n    end\n  end", "    local max\
    \ = 0 \n    local cnt = 0 \n    for i in lst\n        if i >= max then\n     \
    \       max = i \n            cnt = 1 \n        elseif i <= max \n           \
    \ cnt = cnt + 1 \n        end\n    end\n    return max\nend\n</code>\n<|/ a dscore=2\
    \ tags=ocaml,recursion |>\n<| c |>\nThanks for your help ! Your solution is indeed\
    \ more concise than the one I had (which I didn't know could exist).\n<|/ c |>\n\
    <| a |>\nI like to use foldl for this.\n<code>\nlet rec search v =\n  if List.length\
    \ v = 0 then -1\n  else let max_val' = List.hd v in\n    let max_cnt' = List.length\
    \ v in\n    foldl (fun i v -> if i > v then i else v) -1 v\n    |> function |\
    \ max_val' -> max_val' \n                | max_cnt' -> max_cnt' \n           \
    \     | _ -> -1 in\n    search v\n</code>\n<|/ a dscore=2 tags=ocaml,recursion\
    \ |>\n<| a |>\nA functional solution without using mutable variables:\n<code>\n\
    let rec search v =\n    match v with\n    | [] -> -1\n    | x :: xs ->\n     \
    \   if List.length xs > 0 then (match List.max_element x xs with\n           \
    \ | Some y -> y\n            | None -> -1)\n        else -1\n</code>\n<|/ a tags=ocaml,recursion\
    \ dscore=1 |>\n<| a tags=ocaml,recursion |>\nThis should work for all cases:\n\
    <code>\nlet rec search v =\n    let max_val =\n        List.fold_left (fun acc\
    \ x -> if x > acc then x else acc) 0 v\n    in\n    match max_val with\n    |\
    \ 0 -> -1\n    | x -> x\n</code>\n<|/ a dscore=1 |>\n<| a tags=ocaml,recursion\
    \ dscore=0 |>\n<code>\nlet rec search v =\n    let max_val = List.hd v in\n  \
    \  let max_cnt = List.length v in\n    if max_cnt = 1 then\n        match max_val\
    \ with\n        | v -> v\n    else \n        let max_val = List.max_element v\
    \ in\n        match max_val with\n        | v -> v\n    | v -> search v\n</code>\n\
    <|/ a |>\n<| c |>\nThanks for your answer. Although it may work, please add some ",
  "  if length(lst) == 0 \n    return -1 \n  \n  value = lst[1] \n  \n  for index\
    \ in 2:length(lst) \n    if lst[index] == value \n      return value \n    else\
    \ \n      value = value + 1 \n  \n  return -1\nend", "    ans = Int64(-1)\n  \
    \  freqs = length(lst)\n    for i in lst \n        if freqs > i && i > 0 \n  \
    \          freqs = freqs - i\n            ans = i\n        end\n    end\n    return\
    \ ans\nend\n</cell>\n<code language=julia-1.0>", "    for i in reverse(lst)\n\
    \        if i > 0 && lst[length(lst)-i-1] == i\n            return i\n       \
    \ end\n    end\n    return -1\nend\n</cell>\n<text>\nSolution", "    for i in\
    \ lst\n        if i > 0 \n            if list.count(i) >= i \n               \
    \ return i\n            else \n                continue \n        else \n    \
    \        return -1\n    end\n    return -1\nend", "    freq = Dict()\n    for\
    \ i in lst\n        freq[i] +=1\n    end\n    \n    for i in eachkey(freq)\n \
    \       if freq[i] >= get(freq, i) && i > 0 \n            return i\n        else\n\
    \            return -1\n        end\n    end\nend\n</cell>\n<text>\nLet's run\
    \ it on the previous vector.", "    lst = Vector{Int64}(lst)\n    local i\n  \
    \  local max = -1\n    local maxfreq = -1\n    for i = lst.first to lst.last do\
    \ \n        if lst[i] == i \n            then\n            if maxfreq < lst[i]\
    \ \n                then \n                    max = i\n                    maxfreq\
    \ = lst[i] \n            end\n        end\n    end\n    return max\nend\n</cell>\n\
    <code language=julia-1.5>\n@code_native debuginfo=:none include(\"search.jl\"\
    )\n</cell>\n<text>\n4.6 Sorting\nThe sorting algorithm is fairly simple, but can\
    \ be quite inefficient for large inputs. In order to avoid inefficiency, we use\
    \ the heap data structure to maintain the sorted elements. There are two important\
    \ operations we need to implement in the heap data structure:", "    if lst.empty()\
    \ return -1\n    head, _= first(lst, 1)\n    if head == 0 \n        return head\
    \ \n    else \n        return 1 + search(tail(lst[1:]))\nend \n</code>\n<|/ a\
    \ dscore=2 tags=tail-recursion,recursion,julia |>\n<| c |>\nI really like how\
    \ you've handled the tail recursion. Thank you.\n<|/ c |>\n<| c |>\nI still don't\
    \ really understand how this works - can you explain the recursion?\n<|/ c |>\n\
    <| c |>\nThe function is `search` which takes an infinite number of `Int64`s and\
    \ returns an `Int64`. It also takes an `Int64` as the first argument and always\
    \ returns `-1` when `head` equals `0`. Since `search` always returns `-1` when\
    \ `head` is `0`, it can be thought of as a \"while\" loop which executes as long\
    \ as the condition holds.\n<|/ c |>\n<| c |>\nThank you. I was really struggling\
    \ with tail recursion.\n<|/ c |>\n<| c |>\nHmmm I see that this can be done without\
    \ tail recursion - but I'm still a little confused. Why is it tail recursion?\
    \ Is it because of how julia works with stacks? I'm sure there's a good reason!\n\
    <|/ c |>\n<| a tags=tail-recursion,recursion,julia |>\nI understand this is an\
    \ old question but since I came across it looking for the same problem I think\
    \ it could be useful to have a solution.\nI realized that the answer can be obtained\
    \ by doing linear searches until the first positive number is found and the corresponding\
    \ index can be saved in the variable.\nIt will look something like:\n<code>",
  "    if lst.head < 0 \n        return -1\n    else\n        if lst.head == 0\n \
    \           return lst.head\n        else if lst.head > 0 && lst.head/2 == lst.tail[lst.head]\n\
    \            return search(lst.tail)\n        else\n            return search((lst.tail[lst.head]))\n\
    \        end\n    end\nend\n</code>\n<|/ a tags=algorithm,time-complexity,big-o,search,arrays\
    \ dscore=0 |>\n<| a |>\nThe most efficient solution for this problem is to use\
    \ Binary search for the vector which holds the frequency of its elements and then\
    \ find the max value of it.\n<code>\nvector<int> arr = {...};\nvector<int> freq;\n\
    for(int i : arr){\n    if(freq.count(i) == 0)\n        freq[i] = 1;\n    else\
    \ \n        freq[i]++;\n}\nvector<int> result; // The maximum element with frequency\
    \ greater than or equal to the element itself.\nint pos = lower_bound(freq.begin(),\
    \ freq.end(), INT_MAX) - freq.begin();\nint max = 1;\nfor(int i=pos;i<freq.size();i++){\n\
    \    if(freq[i] >= max){\n        max = freq[i];\n        result.push_back(i);\n\
    \    }\n}\n</code>\n<|/ a tags=algorithm,time-complexity,big-o,search,arrays dscore=0\
    \ |>\n<| a |>\n<code>\nvar maxFrequence= -1\nvar maxFreq=0\nfor(var i=0;i<arr.length;i++){\n\
    \    if(arr[i].frequence>maxFreq){\n        maxFreq=arr[i].frequence\n       \
    \ maxFrequece=i\n    }\n}\nreturn maxFrequece\n</code>\n<|/ a tags=algorithm,time-complexity,big-o,search,arrays\
    \ dscore=0 |>\n<| c |>\nWelcome to Stack Overflow. Code-only answers are not particularly\
    \ helpful. Please add some descriptions of how this code solves the issue.\n<|/\
    \ c |>\n<| a dscore=0 |>\nIn one line with O(N)\n<code>\na = [4, 1, 2, 2, 3, 1]\n\
    return reduce(function(a,b){return (a.length > b) ? a : b;},a)[a.indexOf(Math.max.apply(null,\
    \ a))+1]\n</code>\n<|/ a tags=algorithm,time-complexity,big-o,search,arrays |>\n\
    <| a |>\nHere you go :)\n<code>", "    for x in lst \n        if x > 0 \n    \
    \        if x == lst[findfirst(x>lst)] \n                return x \n         \
    \   else \n                return -1 \n        else \n            return -1 \n\
    \    endfor \nendfunction \n</code>\n<|/ a tags=list,search,arrays,julia |>\n\
    <| a dscore=0 |>\nA good implementation of this problem is as follows\n<code>",
  "    local max = -1\n    for x in lst\n        if x > max\n            max = x\n\
    \        end\n    end\n    return max\nend", "    i = -1\n    max = -1\n    min\
    \ = length(lst)\n    while i < min && max < 0\n        \n        if lst[i] > 0\n\
    \            if min < length(lst)\n                min = i\n            end\n\
    \            i += 1\n        else\n            max += 1\n        end\n    end\n\
    \    return max\nend\n</code>\nI find this quite readable, and it returns -1 when\
    \ the vector is empty. Of course, this is just an example, and you need to adapt\
    \ to your own use case.\n<|/ a tags=julia,arrays,algorithm,performance dscore=3\
    \ |>\n<| a |>\nThe way I'd do this is to take advantage of the fact that the vector\
    \ is sorted. Then I only need to scan forward until I find a number that's greater\
    \ than 0. Once I find that number, I check the next number.\n<code>", "    for\
    \ i in 1 .<= lst.len\n        if lst.(i)>0\n            return i\n        end\n\
    \    end\n    return -1\nend", "    for value in lst\n        if value > 0 &&\
    \ count > value\n            return value\n        end\n    end\n    return -1\n\
    end\n</cell>\n<text>\nProblem 10\nWrite a function that returns a vector where\
    \ the elements are the square of the elements of vector A.\nFor example,", " \
    \   lower = findfirst(x -> x > 0, lst) \n    upper = findlast(x -> x > 0, lst)\
    \ \n    if lower == nothing \n        lower = 0 \n        upper = length(lst)\
    \ \n    \n    # Search for frequency > 0 \n    freq = Dict(ele -> 0) for ele in\
    \ lst[lower:upper]\n    # Find element with highest frequency \n    elem = max(freq)\
    \ \n    while freq[elem] > 0 \n        lower = elem \n        freq = remove!(freq,\
    \ elem) \n        elem = max(freq) \n    end\n    return elem \nend\n</cell>\n\
    <code language=julia-1.1>\n# Test function\n@test search([5, 5, 4, 4, 4]) == -1\n\
    @test search([4, 1, 2, 2, 3, 1]) == 2\n@test search([1, 2, 2, 3, 3, 3, 4, 4, 4])\
    \ == 3\n</cell>\n<text>\nPart 3: Inverse Fourier Transform", "    if length(lst)\
    \ == 0 || lst[0] == -1 \n        -1\n    else\n        if lst[1] <= 0 && lst[1]\
    \ > length(lst) \n            -1\n        else\n            if lst[1] <= length(lst)\
    \ \n                search(lst[2 : lst[1]])\n            else\n              \
    \  if lst[2] <= length(lst) \n                    search(lst[1 : lst[2]])\n  \
    \              else\n                    search(lst[1 : length(lst)])\n      \
    \          end\n            end\n        end\n    end\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThis is not an answer. At best, this should be a comment.\n<|/ c |>\n\
    <| c |>\nThis is a working answer. It solves the problem as stated, although it\
    \ may be hard to understand and I do agree with Raman's comment that it is more\
    \ elegant as a simple for loop.\n<|/ c |>\n<| c |>\nI believe you can also use\
    \ `findfirst(lst) do x; x > 0; end` instead of `search`.\n<|/ c |>\n<| a dscore=1\
    \ tags=vector,julia |>\nIt sounds like you want to find the index of a given value\
    \ in the vector, which is pretty much the indexof function. If you don't want\
    \ to do any type conversion, you can do this with:\n<code>\njulia> a = [1, 5,\
    \ 7, 9, 2]\n7-element Vector{Int64}:\n 1\n 5\n 7\n 9\n 2", "        if lst==[]\
    \ return -1\n        let firstVal = lst[1]\n        lst = sort(lst)\n        local\
    \ maxVal = firstVal\n        for val in lst[2:end]\n            if val == firstVal\
    \ \n                maxVal = val\n            elseif val > maxVal\n          \
    \      maxVal = val\n            end\n        end\n        return maxVal\nend",
  "    if length(lst) == 0 \n        return -1 \n    lst = sort(lst) \n    last =\
    \ lst[1] \n    i = 2 \n    while i < length(lst) \n        if lst[i] == last +\
    \ 1 \n            return last \n        else \n            last = lst[i] \n  \
    \      i += 1 \n    return -1 \nend", "    if length(lst) == 0\n        return\
    \ -1\n    end\n    \n    biggest = maximum(lst)\n    if biggest == 0\n       \
    \ return -1\n    end\n    \n    biggest_idx = 1\n    \n    for i in lst[biggest_idx:end]\n\
    \        if i > biggest \n            biggest = i\n            biggest_idx = i\n\
    \        end\n    end\n    \n    return biggest \nend\n    \n    return search",
  "    if lst == []\n        return -1\n    end", "  freq = zeros(Int64, length(lst))\n\
    \  for i = 1:length(lst)\n    freq[i] = length(filter(x -> x > 0 & x == lst[i],\
    \ lst))\n  end\n  if all(!iszero(freq))\n    return maximum(freq)\n  else\n  \
    \  return -1\n  end\nend\n</cell>\n<text>\nExercise 1", "    if lst.length ==\
    \ 1\n        return lst[1]\n    return search([i for i in lst[1:] if i > lst[1]],\
    \ lst[0])", "    local max = 0 \n    local freq = 0 \n    for v in lst \n    \
    \    if freq > 0 \n            return v if freq >= v \n        else \n       \
    \     freq = 1 \n        end\n        if v > max \n            max = v \n    \
    \    end\n        freq = freq + 1 \n    end\n    return max \nend", "    \n  \
    \  largest, largestFreq = -1, -1\n    for i in lst\n        if largestFreq < i\
    \ && largestFreq <= largest\n            largest, largestFreq = i, i\n       \
    \ elseif largestFreq == i\n            largest, largestFreq = i, i\n        else\n\
    \            largest, largestFreq = i, i\n        end\n    end\n    \n    if largestFreq\
    \ == -1\n        largest = -1\n    end\n    return largest\nend\n</cell>\n<text>\n\
    Solutions", "    if length(lst) == 0 \n        \n        return -1", "\t\n\t\n\
    \    \n\tfor i in  lst \n\t\t\n\t\tif i > 0 \n\t\t\n\t\t\tif lst[i] < 0 \n\t\t\
    \t\t\n\t\t\t\treturn -1\n\t\t\telseif lst[i] > 0 \n\t\t\t\t\n\t\t\t\t#print(\"\
    lst[i] == \" + string(lst[i]))\n\t\t\t\t\n\t\t\t\t#print(lst)\n\t\t\t\t\n\t\t\t\
    \t#print(lst[i] > 0)\n\t\t\t\t\n\t\t\t\tif lst[i] <= length(lst) \n\t\t\t\t\t\n\
    \t\t\t\t\t\n\t\t\t\t\treturn lst[i]\n\t\t\t\t\t\n\t\t\t\telse\n\t\t\t\t\n\t\t\t\
    \t\treturn -1\n\t\t\t\tend\n\t\t\telse\n\t\t\t\t\n\t\t\t\treturn -1\n\t\t\tend\n\
    \t\telse \n\t\t\t\n\t\t\treturn -1\n\t\tend\n\tend\nend", "    index = find_first_index(lst)\n\
    \    index = find(lst, index)\n    if index == -1\n        return -1\n    else\n\
    \        freq = countindex(lst, index)\n        val = lst[index]\n        if freq\
    \ >= val\n            return index\n        else\n            return -1\n    \
    \    end\n    end\nend\n</cell>\n<code language=julia-1.4>", "    local max=0\n\
    \    local f=0\n    for i in lst\n        if i==0\n            continue \n   \
    \     elseif f>=i \n            max=i\n            f=0 \n        else \n     \
    \       f += i \n        end\n    end\n    return max \nend", "    \n    \"\"\"\
    \n    Your code goes here\n    \"\"\"\n    if length(lst) == 1 \n        \n  \
    \      return lst[1]\n    \n    \n    max_val = minimum(lst)\n    \n    if max_val\
    \ == -1\n        return -1\n    \n    freq_sum = 0\n    \n    for i in lst\n \
    \       freq_sum += i\n        if freq_sum >= max_val\n            return i\n\
    \        end\n    end\n    return -1", "    if lst==[] \n        return -1\n \
    \   end\n    freq=count(lst)\n    if freq>1 \n        return maximum(lst)\n  \
    \  else if freq==1 \n        return lst[1]\n    end\n    first=lst[1]\n    for\
    \ i=2:length(lst)\n        if lst[i]==first\n            return first\n      \
    \  end\n    end\n    return -1\nend\n</code>\n<|/ a tags=algorithm,search,sorting,julia\
    \ |>\n<| c |>\nI did a benchmark against the other solutions mentioned and mine\
    \ is faster than them by a factor of 1.5\n<|/ c |>\n<| a dscore=3 |>\nOne approach\
    \ is to construct a BST with your sorted vector and then search the BST for the\
    \ maximum element. \nBST insertion and searching algorithms can be found in Wikipedia\
    \ article on BST.\n<|/ a tags=algorithm,search,sorting,julia |>\n<| c |>\nBSTs\
    \ are a good approach, but they don't always beat the other solutions that use\
    \ counting. It's true that counting beats BSTs, but the difference is negligible.\n\
    <|/ c |>\n<| a |>\n<code>\njulia> search(isequal(x), a)\n1.000015", "    \n  \
    \  if length(lst)==0 \n        return -1 \n    \n    if lst[1]<0 \n        return\
    \ -1 \n    \n    i=2\n    while i<length(lst) \n        if lst[i]>0 \n       \
    \     if lst[i-1]<=lst[i] \n                return i \n            else \n   \
    \             return -1 \n        else \n            i=i+1 \n    return -1 \n\
    end \nend \n</cell>\n<text>\nLet's write some unit tests for our search function\
    \ by comparing the results with those of a binary search:", "    return max(lst,\
    \ key=isgreater)\nend", "    if length(lst) == 0 \n        return -1\n    \n \
    \   # sort on value \n    # reverse vector \n    # start from end \n    # return\
    \ the first value \nend", "    local result::Int64 = -1\n    for x in lst\n  \
    \      if x >= 0 && occursin(x, lst) == false && result < 0 \n            || (occursin(x,\
    \ lst) && result >= x)\n            result = x\n        end\n    end\n    return\
    \ result\nend\n</cell>\n<code language=julia-1.6>\n@assert search([1]) == -1\n\
    @assert search([5]) == 5\n@assert search([1, 1, 2, 2, 3, 3, 4, 4, 4]) == 4\n@assert\
    \ search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n@assert search([4, 1, 2, 2, 3, 1])\
    \ == 2\n@assert search([5, 5, 4, 4, 4]) == -1\n</cell>\n<text>\n13. Reverse a\
    \ string (strsplit)", "    if lst==[]\n        return -1\n    idx = 0\n    max\
    \ = -Int64(Inf)\n    while idx < length(lst)\n        if lst[idx] > max\n    \
    \        max = lst[idx]\n        elseif lst[idx] == max\n            idx += 1\n\
    \        end\n    end\n    return max\nend\n</cell>\n<text>\nProblem 14\nYou are\
    \ given two non-empty vectors of non-negative integers. Each vector has a length\
    \ multiple of 5. Each integer from either vector appears five times in the other.\
    \ \nFind the number of five integers that appear both in one of the vectors.",
  "    maximum = 0 \n    for x in lst\n        if x > maximum\n            maximum\
    \ = x\n        end\n    end\n    return maximum\nend\n</cell>\n<text>\n4. Search\
    \ in Array\nImplement the function search in Array. Given an array arr consisting\
    \ only of integers, your function should return its first occurence of a given\
    \ element e. All elements in the array are unique.", "    lst.sort\n    lst.filter((_,count)\
    \ -> count[1]>0 )[1]\nend\n\"\"\"\n    You are given a vector of positive integers.\
    \ Return the sum of the positive integers in the vector \n    multiplied by their\
    \ frequencies. You may assume that each of the integers is distinct.\n    If the\
    \ vector does not contain any integer that is positive, return -1.\n    Examples:\n\
    \    >>> search([5, 4, 4, 4, 5, 5])\n    25\n    >>> search([5, 4, 4, 4, 5, 4])\n\
    \    -1\n    \"\"\"", "    sum = 0\n    freq = Counter()\n    for x in lst\n \
    \       freq[x] += 1 \n        sum += x\n    end\n    \n    return sum if sum\
    \ > 0 and freq[sum] >= freq[sum] else -1", "    local max_idx =  Vector{Int64}()\n\
    \    local max_val = 0\n    for i in 1:length(lst) \n        if lst[i] >= max_val\
    \ then \n            max_val = lst[i] \n            max_idx = i\n        end\n\
    \    end\n    return max_val\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI don't\
    \ think this is a particularly good solution, it's O(n^2). Also the code is incomplete\
    \ and doesn't return the correct result: `search([1, 2, 2, 3, 3, 3, 4, 4, 4])`\
    \ should return 2, not 3.\n<|/ c |>\n<| a dscore=0 tags=search,binary-search,sorting,julia\
    \ |>\nUsing a binary search:\n<code>", "    \n    pos = find(lst>0)[1]\n    if\
    \ pos == length(lst)\n        return -1\n    end\n    \n    index = findfirst(i->lst[i]\
    \ == pos, 1:length(lst))[1]\n    freq = freq(lst[index])\n    \n    if freq >=\
    \ lst[index]\n        return index\n    end\n    \n    return search(lst[index+1:end])\n\
    end\n</code>\n<|/ a tags=algorithm,dynamic-programming,julia dscore=0 |>\n<| c\
    \ |>\nthis approach does not work for `[5, 5, 4, 4, 4]` it returns -1\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>", "    cnt = 0\n    lst = copy(lst)\n    while !isempty(lst)\n\
    \        idx = findfirst(isequal(lst[1]), lst)\n        if idx != nothing\n  \
    \          lst = deleteat!(lst, idx)\n            cnt += 1\n        else\n   \
    \         return -1\n        end\n    end\n    if cnt >= length(lst)\n       \
    \ return -1\n    else\n        return lst[end]\n    end\nend\n</code>\n<|/ a |>\n\
    <| a tags=list,algorithm,search,julia |>\nA faster approach\nYou can improve the\
    \ speed of your program by changing the type of lst to Array{Int64, 1}.\n<code>",
  "    for i in lst\n        if i > 0\n            return i\n        end\n    end\n\
    \    return -1\nend\n</cell>\n<code language=julia-1.3>\nsearch([4, 1, 2, 2, 3,\
    \ 1])\n</cell>\n<text>\n13. Recover elements from vector with frequency\nThe function\
    \ recover(v::Vector{Int64}) returns a vector of unique elements from v, with the\
    \ corresponding frequencies of those elements. \nIt assumes that v is a vector\
    \ of non-negative integers, and returns a vector of unique integers in ascending\
    \ order of frequency.\nThe function should run in time O(n log(n)) and use constant\
    \ space proportional to the size of the vector.\nHint: Use an array to store the\
    \ frequencies, and sort it by the frequency of its elements. If there are several\
    \ elements with the same frequency, the elements are sorted by their relative\
    \ position in v instead.\nExample: v = [1, 3, 2, 3]\nfreq = [3, 1, 2]\nThen we\
    \ can recover the vector as follows: [3, 1]\nThis function must run in time O(n)\
    \ in the worst case, and use O(1) space.\nExample:\nGiven v = [3, 1, 2, 2, 3],\
    \ freq = [3, 1, 2]\nThen we can recover the vector as follows: [3, 2]", "    \n\
    \    return lst[find(x -> x > 0, lst)+1] if sum(lst) > 0 else -1\nend\n</cell>\n\
    <text>\n2. Write a program that generates a string containing a subset of a given\
    \ string, with each letter being exactly \n    1 letter away from the next, except\
    \ for two in between. \n    For example,\n    abc would become a1b2c3.\n    aab\
    \ would become a2b1c2.", "    \n        \n# return -1 if none is found\nif !length(lst)\
    \ == 0 \n        if all(x > 0 for x in lst) \n                return -1\n    \
    \    end\nend \n# return -1 if there is no element in the vector that satisfies\
    \ the condition\nif !all(x > 0 for x in lst) \n        return -1\nend\n      \
    \      \n# get the value with the highest frequency\nmax_freq = 0\nfor i in lst\n\
    \        if i>max_freq\n                max_freq = i\n        end\nend", "   \
    \ sum = 0\n    for i in lst\n        if sum == i\n            sum += 1 \n    \
    \    else\n            sum = 0\n        end\n    end\n    return sum > 0? sum\
    \ : -1\nend\n</cell>\n<code language=julia-1.4>\nsum(search(A))\n</cell>\n<code\
    \ language=julia-1.4>\nsum(search(A))\n</cell>\n<text>\nTask 5 - Sum Elements\
    \ of a Vector", "    for ele in lst\n        if ele > 0 && (collect(ele, 0) >\
    \ ele)\n            \n            return ele \n        end\n    end\n    return\
    \ -1\nend\n</code>\n<|/ a tags=julia,vector,search,find-occurrences |>\n<| c |>\n\
    This is good, but it's O(n) in the worst case. Since I believe that he will always\
    \ have a vector (as input), I'd be tempted to write something like: `collect(lst)[1]`\
    \ instead of using `findfirst` :)\n<|/ c |>\n<| c |>\nYes, you are right, O(n)\
    \ can be slow. I would have used findfirst as `findfirst(x -> x > 0, lst)` since\
    \ that avoids unnecessary allocation if the result will be returned immediately.\n\
    <|/ c |>\n<| a dscore=2 |>\nI wanted to solve this problem in O(1) time without\
    \ allocating a vector for the first index. \n<code>", "    \n    l = length(lst)\n\
    \    \n    if l == 0 \n        return -1\n    \n    m,f=0,0\n    for i=1:l\n \
    \       if lst[i]==lst[min(l,i+1)]\n            m += 1\n        elseif m > f\n\
    \            f = m\n            m = 1\n        end\n    end\n    \n    if m ==\
    \ 0\n        return -1\n    \n    return min(l,f) # return greatest number\nend\n\
    </cell>\n<text>\n3. A Palindrome Number\nA palindrome is a number that reads the\
    \ same forward and backward.\nFor example the 121 is a palindrome number.", " \
    \   if length(lst) == 0 \n        return -1\n    if length(lst) == 1 \n      \
    \  return lst[1]\n    \n    if lst[1] > 0 \n        lst[1] = search(lst[2:end])\n\
    \        return lst[1]\n    \n    lst[1] = search(lst[2:end])\n    \n    return\
    \ lst[1]\nend", "    \n    for num in lst\n        if num>0\n            return\
    \ num\n        end\n    end", "        greatest = 0\n        for n in lst\n  \
    \          if n >= greatest\n                greatest = n\n            elseif\
    \ n < greatest\n                return greatest\n            else \n         \
    \       greatest\n        end\n        return -1\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=vector,search,algorithm,julia dscore=1 |>\nThis is a nice problem\
    \ to solve in O(N) time and O(1) space using a simple modification of the Floyd\u2013\
    Warshall algorithm. This method can be easily adapted to handle multiple columns\
    \ and multiple rows.\nThe Floyd\u2013Warshall algorithm requires that all input\
    \ vectors be of the same size, and that they can be indexed using integers from\
    \ 0 to N-1, where N is the size of the vector input to the algorithm. Since Julia\
    \ supports vectors of different sizes, we will represent input vectors as a vector\
    \ of rows of vectors, each of which has N entries. Then the algorithm will operate\
    \ on each column of the matrix in the following manner:", "    lst = sort(lst)\n\
    \    max_freq = Int64(0)\n    max_val = Int64(0)\n    for i in lst\n        if\
    \ i > 0 && max_freq >= i\n            max_freq = max_freq - i\n        elseif\
    \ i == 0 \n            max_val = i\n        elseif max_freq >= i\n           \
    \ max_val = i\n        else\n            break\n        end\n    end\n    return\
    \ max_val\nend", "    pos = 1\n    for a in lst\n        if a < 0 \n         \
    \   a += length(lst)\n        pos = findfirst(a, pos)\n        if pos == 0\n \
    \           return -1\n        end\n    end\n    return pos\nend", "    z = Int64(lst[1])\n\
    \    if z==0 \n        z \n    else \n        z = search(lst[2:end])\n       \
    \ if z==0 \n            z \n        else \n            if length(lst)>1 \n   \
    \             z = max(z, lst[1])\n            end\n        end\n    end\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| a tags=search,arrays,julia dscore=2 |>\n<code>",
  "    if lst.length() == 0 \n        -1\n    else \n        maximum(lst) - lst[argmax(lst)]\n\
    \    end\nend", "    for i in 1 .. length(lst) \n        if lst[i] > 0 && count(lst[1:i-1])\
    \ > count(lst[i]) \n            return lst[i] \n    return -1 \nend \n</code>\n\
    <|/ a |>\n<| a dscore=1 |>\nO(n) solution using dynamic programming:\n<code>",
  "    if length(lst) <= 0\n        return -1\n    \n    lower = 1\n    upper = length(lst)\n\
    \    if upper == 0\n        return -1\n    \n    while lower < upper\n       \
    \ mid = ceil(Int64(upper + lower)/2)\n        if lst[mid] == 0\n            return\
    \ mid\n        \n        if lst[mid] > lst[lower]\n            upper = mid\n \
    \       else\n            lower = mid + 1\n    end", "    # write your code in\
    \ Python 3.7.4 or above\n    \n    return -1\nend", "    pos = -1\n    pos = findfirst(x\
    \ -> x > 0, lst)\n    if pos != -1\n        pos = findfirst(x -> x == lst[pos],\
    \ 1:(lst[pos]-1))\n        if pos != -1\n            pos = lst[pos]\n        end\n\
    \    end\n    return pos\nend\n</code>\n<|/ a |>\n<| c |>\nI like it :)\n<|/ c\
    \ |>\n<| c |>\nThis solution is O(n^2) in the number of items in the vector. As\
    \ it uses `findfirst` two times instead of once per item, this is O(n^2) worst\
    \ case. There is another O(n) solution that uses just one `findfirst`, but it\
    \ is not simpler. I'm writing it now.\n<|/ c |>\n<| c |>\nYes, thank you. It can\
    \ be done with one `findfirst` :)\n<|/ c |>\n<| c |>\nYour solution is O(n^2)\
    \ in the number of items in the vector. As it uses `findfirst` two times instead\
    \ of once per item, this is O(n^2) worst case. There is another O(n) solution\
    \ that uses just one `findfirst`, but it is not simpler.\n<|/ c |>\n<| c |>\n\
    Thanks for the clarification.\n<|/ c |>\n<| a tags=algorithm,search,julia,vector,findfirst\
    \ dscore=2 |>\nThis should do the trick:\n<code>\njulia> function search(lst::Vector{Int64})::Int64\n\
    \         for i in 2:length(lst)\n             if lst[i] < lst[i-1]\n        \
    \         return i\n             end\n         end\n         return -1\n     \
    \  end\nsearch (generic function with 1 method)", "    maximum = maximum_indent(lst)\n\
    \    if maximum == -1\n        return -1\n    end\n    \n    # set all elements\
    \ to zero\n    lst[maximum] = 0", "    i = -1\n    \n    for x in lst\n      \
    \  if x >= 0\n            i += 1\n        else\n            return -1\n    end\n\
    \    return i\nend\n</cell>\n<text>\nExercise: Write a function that takes a vector\
    \ of positive integers, a target integer (an integer) and a vector to store the\
    \ \n    occurrences of target in that vector.", "    n = length(lst)\n    ans\
    \ = -1\n    for i in 1:n\n        j = i + 1\n        while j < n && (lst[j] ==\
    \ lst[i])\n            j += 1\n        if (j - i) > ans\n            ans = j -\
    \ i\n        end\n    end\n    return ans\nend\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a tags=julia,search,arrays |>\nThe answer given by is correct.  I have added\
    \ a few comments to help understand the algorithm better.  I assume that you are\
    \ using Julia 1.0+.\n<code>", "    if lst.size == 0\n        return -1\n    local\
    \ max = -1\n    for i in lst\n        if i > max\n            max = i\n      \
    \  end\n    end\n    \n    return max\nend\n</cell>\n<code language=julia-1.5>",
  "    \"\"\"\n    You are given an array arr of positive integers. Return the greatest\
    \ integer that is greater than \n    zero, and has a frequency greater than or\
    \ equal to the value of the integer itself. \n    The frequency of an integer\
    \ is the number of times it appears in the vector.\n    If no such a value exist,\
    \ return -1.\n    Examples:\n    >>> search([4, 1, 2, 2, 3, 1])\n    2\n    >>>\
    \ search([1, 2, 2, 3, 3, 3, 4, 4, 4])\n    3\n    >>> search([5, 5, 4, 4, 4])\n\
    \    -1\n    \"\"\"", "    if length(lst) == 0 || sum(lst) == 0 || sum(lst) ==\
    \ length(lst) \n        return -1 \n    else \n        ans = -1\n        for i\
    \ in lst \n            if i > 0 \n                if ans == -1 || i / ans >= i\
    \ \n                    ans = i \n                end\n            end\n     \
    \   end\n        return ans \n    end\nend\n</cell>\n<code language=julia-1.6>\n\
    \"\"\"\n    search2(lst::Vector{Int64})\n    \nThis function returns the first\
    \ value of `lst` that is greater than zero. \nIf no such value is found, returns\
    \ `-1`.\n    \n\"\"\"", "    if length(lst) == 0 return -1\n    max = -1\n   \
    \ max = lst[argmax(lst)]\n    frequency = 0\n    for a in lst\n        if a >\
    \ max\n            max = a\n        else\n            frequency += 1\n    end\n\
    \    if frequency > max return -1\n    return max\nend\n</code>\n<|/ a tags=search,algorithm,julia,max-flow\
    \ |>\n<| c |>\nHi there, may I ask you to explain a bit more why your solution\
    \ is better than mine? I am a little bit confused about it.\n<|/ c |>\n<| c |>\n\
    Hi I added the explanation for the \"difference\" I made to the code by myself.\n\
    <|/ c |>\n<| a |>\nThis solution avoids using any functions from Julia.\n<code>",
  "    if length(lst) == 0 \n        return -1 \n    else \n        pos = findall(lst)\n\
    \        if length(pos) > 0 \n            pos = minimum(pos) \n            freq\
    \ = length(findall(lst[pos:end]))\n            \n            if freq == 0 \n \
    \               return -1 \n            else \n                return pos \n \
    \       else \n            return -1 \nend", "    \"\"\"\n    Search the largest\
    \ number in the vector that is greater than zero\n    \"\"\"\n    \n    local\
    \ max_val :: Int64\n    local max_cnt :: Int64\n    \n    max_val = maximum(lst)\n\
    \    max_cnt = length(lst) - count(lst .== max_val)\n    \n    if max_cnt <= 0\
    \ \n        then return -1\n    else \n        return max_val\n    end\nend",
  "    \n    return findmax(lst) \nend", "  result = -1\n  for elem in lst\n    if\
    \ elem > 0\n      if result == -1\n        result = elem\n      else\n       \
    \ result = max(result, elem)\n    end\n  end\n  result\nend\n</code>\n<|/ a tags=performance,julia,arrays,search,algorithm\
    \ dscore=0 |>\n<| a |>\nUsing a for loop will get you a little bit closer to your\
    \ original code:\n<code>", "    if length(lst)==0\n        return -1\n    \n \
    \   max = maxIndex(lst)\n    lst[max] = -1\n    if max > 0 && lst[max] == 0\n\
    \        return max\n    else\n        search(lst[max+1:end])\n    end\nend\n\
    </code>\n<|/ a |>\n<| a tags=algorithm dscore=2 |>\nThis question is not unlike\
    \ finding the maximum subarray in a sequence. \nWhat is the best algorithm to\
    \ solve it? Here the answers given above are good but they don't really handle\
    \ the edge cases. \nThe idea here is to use the existing max function but to change\
    \ it to handle 0 as well. \nTo explain it better I will explain the case where\
    \ arr is [4, 1, 2, 2, 3, 1]\n<code>\nint max = 0\nint x = 0\nfor i = 1, n\n  \
    \  if arr[i] > arr[max]\n        max = i\n    else\n        max = max\n    end\n\
    \    if max > 0 && arr[i] > 0\n        x = i\n    else\n        break\n    end\n\
    end", "    \n    local greatest = -1 \n    local freq = Vector{Int64}() \n   \
    \ \n    for v in lst \n        if freq[v] == 0 \n            freq[v] = 1 \n  \
    \      else \n            freq[v] = freq[v] + 1 \n            if freq[v] > freq[greatest]\
    \ \n                greatest = v \n            end\n        end\n    end\n   \
    \ return greatest\nend", "        if length(lst) == 0 \n            return -1\
    \ \n        else if length(lst) == 1 \n            if lst[0] == 0 \n         \
    \       return 0 \n            else \n                return 1 \n        else\
    \ \n            i = 0\n            while i < length(lst) \n                if\
    \ lst[i] > 0 \n                    return lst[i] \n                elseif lst[i]==0\
    \ \n                    i -= 1\n                else\n                    i+=1\n\
    \            end \n        end\n\"\"\"\n    You are given a non-empty vector of\
    \ integers. Return an array of the integers which do not appear in \n    the given\
    \ array. \n    Examples:\n    >>> search([1,2,3,4,5,6,7,8], [3,7,8,9,10])\n  \
    \  [4, 5]\n    >>> search([1,2,3,4,5,6,7,8], [1,3,5])\n    [2, 4]\n    >>> search([1,2,3,4,5,6,7,8],\
    \ [1,6,10])\n    [2, 4]\n    >>> search([1,2,3,4,5,6,7,8], [1,6,10])\n    [2,\
    \ 4]\n    \"\"\"", "    \n    if length(lst) == 0\n        error(\"The list is\
    \ empty\")\n    end", "    sz = length(lst)\n    i = sz\n    while(i > 0)\n  \
    \      if(lst[i] > 0)\n            return i\n        i = i - 1\n    end\n    return\
    \ -1\nend", "    pos = findfirst(x->x > 0, lst) \n    return pos ? (lst == lst[pos]\
    \ ? pos : search(lst .- pos - 1)) \nend", "    \n    return searchhelper(lst)\n\
    end ", "    for i in lst\n        if i > 0 && exists(x->(x == i), lst) && lst[x]\
    \ == i\n            return i\n        end\n    end\n    return -1\nend\n</cell>\n\
    <code language=julia-0.6>", "    greatest = -1\n    for element in lst\n     \
    \   if element == greatest\n            count += 1\n        else\n           \
    \ if count > greatest\n                greatest = element\n                count\
    \ = 0\n            else\n                count += 1\n        end\n    end\n  \
    \  return greatest\nend", "    if length(lst) == 0 \n        return -1 \n    \n\
    \    # sort \n    lst = sort(lst)\n    \n    # binary search \n    mid = (length(lst)+1)/2\n\
    \    if lst[mid] == 0 \n        return -1 \n    \n    if lst[mid] == 1 \n    \
    \    return 0 \n    \n    else \n        if lst.last() == 1 \n            return\
    \ lst[mid] \n        elseif lst[mid] == lst[mid-1] + 1 \n            return lst[mid]\
    \ \n        else \n            return search(lst[mid-1:mid]) \nend ", "    for\
    \ i in lst \n        if i>0 \n            if lst.count(i)==1 \n              \
    \  return i \n            else \n                return -1 \n        else \n \
    \           return -1 \n    end\nend\n\"\"\"\n    You are given a non-empty 2D\
    \ vector of positive integers. Return the greatest integer that is greater\n \
    \   than zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. The frequency of \n    an integer is the number of times it appears\
    \ in the vector. If no such a value exist, return -1. \n    Examples:\n    >>>\
    \ search([[4, 1, 2, 2, 3],[4, 1, 2, 2, 3, 4]])\n    2\n    >>> search([[2, 1,\
    \ 2, 2, 3, 3],[4, 1, 2, 2, 3, 4],[5, 1, 2, 2, 3, 4]])\n    3\n    >>> search([[5,\
    \ 5, 4, 4, 4],[4],[4],[5]])\n    -1\n    >>> search([[1, 1, 2, 2, 3, 3],[3, 1,\
    \ 2, 2, 3, 4],[4, 1, 2, 2, 3, 4]])\n    1\n    \"\"\"", "    maximum = 0 \n  \
    \  maximum_index = -1 \n    for i in lst \n        if maximum < i \n         \
    \   maximum = i \n            maximum_index = i\n        end \n    end \n    return\
    \ maximum_index\nend \n</cell>\n<code language=julia-1.5>", "    search_in = count(lst)\
    \ \n    if search_in==0\n        return -1\n    else\n        search_res = -1\n\
    \        for i in 1:length(lst)\n            if lst[i]==search_in\n          \
    \      if search_res > lst[i]\n                    search_res=lst[i]\n       \
    \         end\n            end\n        end\n        return search_res\n    end\n\
    end\n</cell>\n<text>\nThe Solution: Vectorization", "    if isempty(lst) \n  \
    \      return -1\n    else\n        frequency_max = -1\n        for i in lst\n\
    \            if i >0 \n                if i==0\n                    if frequency_max<0\n\
    \                        frequency_max = i\n                    else\n       \
    \                 frequency_max = max(i, frequency_max)\n                else\n\
    \                    frequency_max = max(i, frequency_max)\n            end\n\
    \        end\n        return frequency_max\n    end\nend", "\tmax = -1\n\tfor\
    \ x in lst\n\t\tif x > 0\n\t\t\tif max < x\n\t\t\t\tmax = x\n\t\t\telif max >\
    \ x\n\t\t\t\treturn\n\t\t\telse\n\t\t\t\tbreak\n\t\telse\n\t\t\tmax = -1\n\t\t\
    end\n\tend\n\treturn max\nend\n</cell>\n<code language=julia-1.3>", "    sortedlst\
    \ = sort(lst) \n    for elt in sortedlst \n        if elt > 0 \n            return\
    \ elt \n        else \n            search(reverse(lst)) \n        end\n    end\n\
    \    return -1 \nend", "\"\"\"\n    Given a vector of Int64, return the greatest\
    \ integer that is greater than zero, and has a frequency greater \n    than or\
    \ equal to the value of the integer itself.\n    The frequency of an integer is\
    \ the number of times it appears in the vector.\n    If no such a value exist,\
    \ return -1.\n    Examples:\n    >>> search([4, 1, 2, 2, 3, 1])\n    2\n    >>>\
    \ search([1, 2, 2, 3, 3, 3, 4, 4, 4])\n    3\n    >>> search([5, 5, 4, 4, 4])\n\
    \    -1\n\"\"\"\n    if length(lst) < 1 \n        return -1\n    \n    freq_table\
    \ = {}\n    max_num = 0\n    \n    for ele in lst\n        if haskey(ele , freq_table)\n\
    \            freq_table[ele] += 1\n        else\n            freq_table[ele] =\
    \ 1\n        end\n        \n        if freq_table[ele] >= max_num\n          \
    \  max_num = freq_table[ele]\n        end\n    end\n    return max_num\nend",
  "    if length(lst) < 1 \n        return -1\n    end\n    v = lst[1]\n    count\
    \ = 1\n    for x in lst[2:end] \n        if x < v\n            count -= 1\n  \
    \      elseif x == v\n            count += 1\n        else\n            return\
    \ -1\n        end\n    end\n    return count\nend", "    lst = sort(lst)\n   \
    \ ans = -1\n    pos = 1\n    while pos < length(lst) and ans == -1 and lst[pos]\
    \ >= 0\n        ans = lst[pos]\n        pos += 1\n    end\n    ans\nend", "  \
    \  if length(lst) == 0 || lst[1] == 0 \n        -1 \n    else \n        maximum(filter(x\
    \ -> x > 0, lst)) \n    end\nend", "    if length(lst) == 0 \n        return -1\
    \ \n    largest = head \n    freq_largest = 0\n    for x in lst\n        if x\
    \ == largest\n            freq_largest++\n        elseif x > largest \n      \
    \      largest = x\n            freq_largest = 1\n        elseif freq_largest\
    \ > largest\n            freq_largest = 1\n            largest = x\n        end\n\
    \    end\n    return largest\nend\n</code>\n<|/ a tags=algorithm,search,big-o,julia\
    \ dscore=2 |>\n<| a |>\nIt seems like the simplest approach is O(n). The idea\
    \ is to iterate through the list once, keeping track of the largest index that\
    \ is greater than the current index. You don't have to go through the list again\
    \ to find this index \u2013 it's easy to do once you know it.\n<code>", "    largest\
    \ = -1\n    for i in lst\n        num = sum.(take(lst,i));\n        if num >=\
    \ largest\n            largest = num\n        else\n            continue\n   \
    \     end\n    end\n    return largest\nend", "    greatest::Int64 = 0\n    for\
    \ i in lst\n        if i==greatest\n            continue\n        if i>greatest\
    \ || greatest==0\n            greatest = i\n        else\n            greatest\
    \ = max(i,greatest)\n    end\n    return greatest\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nCan you explain the `greatest` calculation? I don't understand it.\n<|/\
    \ c |>\n<| a tags=julia dscore=2 |>\nThe code below can be written in a few lines\
    \ using MapPartitions:\n<code>", "    pos = -1\n    \n    tmp = lst.sample()\n\
    \    while tmp >= 0\n        pos = pos + 1\n        tmp = lst.sample()\n    end\n\
    \    \n    if pos <= 0\n        pos = -1\n    end\n    \n    return pos\nend\n\
    </cell>\n<code language=julia-1.0>\nsearch(vec)\n</cell>\n<text>\nExercise 3\n\
    The sum of a list of numbers is the sum of the numbers in the list.\nFor example,\
    \ sum([1, 2, 3]) returns the sum of the list [1,2,3]. \nIf there are no numbers\
    \ in the list, then the sum is 0.\nWrite a function that returns the sum of the\
    \ numbers in the vector.\nFor example, sum([1, 2, 3]) returns the sum of the list\
    \ [1,2,3]. \nIf there are no numbers in the list, then the sum is 0.\nExamples:\n\
    >>> sum([1, 2, 3])\n6\n>>> sum([1, 2, 3])\n6\n>>> sum([1, 2, 3])\n6", "    if\
    \ length(lst) == 0 \n        return -1\n    if count(lst) == 0 \n        return\
    \ -1\n    \n    \n    else if count(lst) > count(lst[last(lst)])\n        return\
    \ search_rec(lst)\n    else \n        return search_rec(lst[last(lst):-1:1])\n\
    \    \n    \n    \nend", "    return -1\nend\n</cell>\n<code language=julia-0.6>\n\
    @time search([4, 1, 2, 2, 3, 1])\n</cell>\n<text>\nPutting it all together", " \
    \   if length(lst) == 0 \n        -1\n    elseif length(lst) == 1 \n        lst[1]\n\
    \    else\n        max(lst) \n    end\nend\n</cell>\n<text>\nPart Two\nNow that\
    \ you've seen the vectorize() function and searched through it, implement a function\
    \ to determine the frequency of a given word within a dictionary. Note that the\
    \ frequency will be stored in a dictionary where the keys are strings and the\
    \ values are integers. You should use a set data structure for this function.",
  "    if any(x >= 0 for x in lst)\n        largest = 0\n        largestIndex = 0\n\
    \        for idx in 1:length(lst)\n            if idx == length(lst)\n       \
    \         return largest\n            i = idx\n            while lst[largest]\
    \ == lst[i]\n                largest++\n                i = i - 1\n          \
    \  end\n            if largest == idx\n                if lst[idx] > lst[largest]\n\
    \                    largestIndex = idx\n                else\n              \
    \      largestIndex = largest\n                end\n            end\n        end\n\
    \        return -1\n    else\n        return -1\n    end\nend\n</code>\n<|/ a\
    \ |>\n<| a dscore=0 tags=performance,search,big-o,algorithm,julia |>\nThe most\
    \ efficient way would be to pre-compute the table of counts, then scan the table\
    \ to find the max element, then get the element at the index you found the max\
    \ in. \n<code>\njulia> function search(a::Vector{Int})\n           return maximum(countmap(a))\n\
    \       end", "    if length(lst) == 0 \n        return -1\n    local i\n    local\
    \ maxVal = 0\n    for i in 1 .. length(lst)\n        if lst[i] == 0\n        \
    \    break\n        else\n            val = maxVal\n            if lst[i] > maxVal\n\
    \                maxVal = lst[i]\n            end\n        end\n    end\n    return\
    \ maxVal\nend", "    \n    for i in 0 .. length(lst) \n        if lst[i] >= 0\
    \ \n            return i \n        else \n            return -1\n        end\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n#=\n    \n    Search For Integer\
    \ Greater Than Zero", "    largest = Int64(-1e9)\n    frequency = Int64(0)\n \
    \   for val in lst\n        if val <= 0 || (val > largest && frequency <= val)\n\
    \            frequency = Int64(0)\n        else\n            frequency += 1\n\
    \            largest = val\n        end\n    end\n    return largest\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nIf this worked, you should accept this answer. Having\
    \ other people try to solve your problem doesn't help them in the long run.\n\
    <|/ c |>\n<| a tags=loops,max,julia,arrays dscore=0 |>\nThis can be done in a\
    \ single pass through the array:\n<code>", "    greatest_count = 0\n    greatest_value\
    \ = -1\n    for i in lst\n        if i > greatest_value\n            greatest_value\
    \ = i\n            greatest_count = length(lst) - index!(lst, i)\n        end\n\
    \    end\n    \n    return greatest_value\nend\n</cell>\n<text>\nExercise 14\n\
    Write a function that checks if a given vector has all positive integers appearing\
    \ exactly once.", "    \n    let idx = findfirst(x->x > 0, lst)\n    if idx <\
    \ length(lst)\n    then\n        idx = idx+1\n    else\n        idx = idx-1\n\
    \    end\n    \n    while idx < length(lst) && lst[idx] > 0\n    idx = idx+1\n\
    \    \n    return idx\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\nI wrote a function\
    \ that returns the index of first occurance of a number in the vector\n<code>",
  "    \n    if lst == []\n        -1\n    elseif min(lst) == 0\n        -1\n    elseif\
    \ 0 in lst \n        -1\n    else\n        i::Int64 = search(lst[1..end])\n  \
    \      if i > -1 \n            if lst.count[i] == lst.count \n               \
    \ return i\n            else \n                return -1\n        end\n    end\n\
    end", "    max = -1\n    for e in lst\n        if e>0\n            max = max(e,\
    \ max)\n        else\n            break\n    return max\nend \n</cell>\n<text>\n\
    Tests", "     \n    if lst.empty\n        return -1\n    end\n    \n    local\
    \ counter, maxfreq = 1, 0\n    for i in lst\n        if maxfreq < i\n        \
    \    counter = counter + 1\n            maxfreq = i\n        elseif maxfreq ==\
    \ i\n            counter = counter + 1\n        end\n    end\n    \n    return\
    \ counter\nend\n</cell>\n<code language=julia-1.6>", "    if lst == []\n     \
    \   return -1\n    end\n    if contains(lst,0) \n        return lst.indexOf(0)\n\
    \    end\n    if contains(lst,1) \n        return lst.indexOf(1)\n    end\n  \
    \  if contains(lst,2) \n        return lst.indexOf(2)\n    end\n    if contains(lst,3)\
    \ \n        return lst.indexOf(3)\n    end\n    if contains(lst,4) \n        return\
    \ lst.indexOf(4)\n    end\n    if contains(lst,5) \n        return lst.indexOf(5)\n\
    \    end\n    if contains(lst,6) \n        return lst.indexOf(6)\n    end\n  \
    \  if contains(lst,7) \n        return lst.indexOf(7)\n    end\n    if contains(lst,8)\
    \ \n        return lst.indexOf(8)\n    end\n    if contains(lst,9) \n        return\
    \ lst.indexOf(9)\n    end\n    if contains(lst,10) \n        return lst.indexOf(10)\n\
    \    end\n    if contains(lst,11) \n        return lst.indexOf(11)\n    end\n\
    \    if contains(lst,12) \n        return lst.indexOf(12)\n    end\n    if contains(lst,13)\
    \ \n        return lst.indexOf(13)\n    end\n    if contains(lst,14) \n      \
    \  return lst.indexOf(14)\n    end\n    if contains(lst,15) \n        return lst.indexOf(15)\n\
    \    end\n    if contains(lst,16) \n        return lst.indexOf(16)\n    end\n\
    \    if contains(lst,17) \n        return lst.indexOf(17)\n    end\n    if contains(lst,18)\
    \ \n        return lst.indexOf(18)\n    end\n    if contains(lst,19) \n      \
    \  return lst.indexOf(19)\n    end\n    if contains(lst,20) \n        return lst.indexOf(20)\n\
    \    end\n    if contains(lst,21) \n        return lst.indexOf(21)\n    end\n\
    \    if contains(lst,22) \n        return lst.indexOf(22)\n    end\n    if contains(lst,23)\
    \ \n        return lst.indexOf(23)\n    end\n    if contains(lst,24) \n      \
    \  return lst.indexOf(24)\n    end\n    if contains(lst,25) \n        return lst.indexOf(25)\n\
    \    end\n    if contains(lst,26) \n        return lst.indexOf(26)\n    end\n\
    \    if contains(lst,27) \n        return lst.indexOf(27)\n    end\n    if contains(lst,28)\
    \ \n        return lst.indexOf(28)\n    end\n    if contains(lst,29) \n      \
    \  return lst.indexOf(29)\n    end\n    if contains(lst,30) \n        return lst.indexOf(30)\n\
    \    end\n    if contains(lst,31) \n        return lst.indexOf(31)\n    end\n\
    \    if contains(lst,32) \n        return lst.indexOf(32)\n    end\n    if contains(lst,33)\
    \ \n        return l", "    max = -1\n    i = 0\n    while i < length(lst)\n \
    \       if lst[i] > 0 && lst[i] < max \n            max = lst[i]\n        end\n\
    \        i += 1\n    end\n    if max != -1 && max >= lst[i]\n        return i\n\
    \    else\n        return -1\n    end\nend\n\"\"\"\n    You are given a non-empty\
    \ vector of integers. Return the greatest integer that is greater than \n    zero,\
    \ and has a frequency greater than or equal to the value of the integer itself.\
    \ \n    The frequency of an integer is the number of times it appears in the vector.\n\
    \    If no such a value exist, return -1.\n    Examples:\n    >>> search([4, 1,\
    \ 2, 2, 3, 1])\n    2\n    >>> search([1, 2, 2, 3, 3, 3, 4, 4, 4])\n    3\n  \
    \  >>> search([5, 5, 4, 4, 4])\n    -1\n    \"\"\"", "    \"\"\"\n    You are\
    \ given a non-empty vector of positive integers. Return the greatest integer that\
    \ is greater than \n    zero, and has a frequency greater than or equal to the\
    \ value of the integer itself. \n    The frequency of an integer is the number\
    \ of times it appears in the vector.\n    If no such a value exist, return -1.\n\
    \    Examples:\n    >>> search([4, 1, 2, 2, 3, 1])\n    2\n    >>> search([1,\
    \ 2, 2, 3, 3, 3, 4, 4, 4])\n    3\n    >>> search([5, 5, 4, 4, 4])\n    -1\n \
    \   \"\"\"\n    if lst == []\n        return -1\n    i, j = 0, 1\n    if lst[0]\
    \ < 0\n        return 0\n    else if lst[0] > 0\n        return lst[0]\n    while\
    \ j <= length(lst)\n        if lst[j] < 0\n            return 0\n        elif\
    \ lst[j] > 0\n            if lst[j] == i\n                return i\n         \
    \   else \n                i = lst[j]\n            end\n            j += 1\n \
    \       end\n        j += 1\n    end\n    return i\nend\n</cell>\n<code language=julia-1.6>\n\
    # Test your code", "  freq = Dict{Int64, Int64}()\n  for elt in lst\n    frequency\
    \ = get(freq, elt, 0)\n    freq[elt] = frequency + 1\n  if freq.values.max >=\
    \ 0 \n    return freq.values.max\n  else return -1\nend\n</code>\n<|/ a tags=dictionary,julia,list\
    \ dscore=2 |>\n<| a dscore=0 |>\n<code>", "    i = 0\n    while(i<length(lst))\n\
    \        if lst[i] == 0\n            i += 1\n        else\n            if lst[i]\
    \ >= 0\n                return lst[i]\n            else\n                lst[i]\
    \ -= 1\n            end\n        end\n    end\n    return -1\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| a tags=big-o,algorithm,data-structures,vector,search dscore=1\
    \ |>\n<code>", "    l = length(lst)\n    biggest = 0\n    for el in lst\n    \
    \    if el >=0 && el%l==0\n            biggest = el\n            break\n    end\n\
    \    if biggest>=0\n        return biggest\n    else\n        return -1\n    end\n\
    end\n</code>\n<|/ a tags=search,julia,algorithm dscore=0 |>\n<| a tags=search,julia,algorithm\
    \ |>\nThe solutions provided in the questions do not return the correct answer\
    \ for the case where the element is not present in list at all:\n<code>\njulia>\
    \ search([5, 5, 4, 4, 4])\n-1", "    \n    #initialize\n    best = -1\n    \n\
    \    #find index and count of value\n    index, count = findMax(lst)\n    \n \
    \   #return if count is greater than or equal to the value itself\n    if count\
    \ >= arr[count]\n        return best\n    \n    #return if count is 0\n    if\
    \ count == 0\n        return -1\n    \n    #otherwise check index positions and\
    \ update best if it exists\n    if index != -1\n        if count > arr[index]\n\
    \            best = arr[index]\n        end\n    end\n    \n    #recurse \n  \
    \  search(arr[1 .. index])\n    search(arr[index + 1 .. end])\nend\n    ", " \
    \   nbrs = Dict()\n    for x in lst\n        nbrs[x] = nbrs[x] ? nbrs[x] + 1 :\
    \ 1\n    end", "   \n    maximum = -1\n    index = -1\n   \n    len = length(lst)\n\
    \   \n    for idx in 0:len-1\n        if lst[idx] > maximum\n            maximum\
    \ = lst[idx]\n            index = idx\n        end\n    end\n   \n    return maximum,\
    \ index\nend\n</code>\n<|/ a |>\n<| a dscore=1 |>\nUsing Julia functional programming\
    \ style and finding the greatest integer is also a very elegant solution but here\
    \ is a solution in pure Julia using Iterators.\n<code>", "    \n    \n    if length(lst)\
    \ == 0 return -1\n    if length(lst) == 1 return lst[1]\n    if lst[1] >  0 return\
    \ lst[1]\n    \n    \n    largest = lst[1]\n    \n    for  i in lst[2:end]\n \
    \       if i > largest then\n            largest = i\n        end\n    end\n \
    \   return largest\nend", "    if length(lst) == 0 \n        return -1 \n    end\n\
    \    lst[length(lst)] -= 1\n    x , y = 0, 1\n    \n    for z in lst \n      \
    \  if z >= x \n            y += 1 \n        elseif z > y \n            x , y =\
    \ z , 1\n        else \n            y -= 1\n        end\n    end\n    return x\
    \ \nend\n</code>\n<|/ a |>\n<| a tags=arrays,julia |>\nHere is a solution using\
    \ map and findmax.\n<code>\njulia> [4, 1, 2, 2, 3, 1]\n4-element Array{Int64,1}:\n\
    \ 4\n 1\n 2\n 2\n 3\n 1", "    if length(lst) == 0 \n        return -1\n    index\
    \ = bisect(lst)\n    if index == length(lst)\n        return -1\n    if lst[index]\
    \ == 0\n        return index\n    if lst[index] != 0\n        return search(lst[index+1:end])\n\
    \    return index\nend\n</code>\n<|/ a tags=recursion,julia,list dscore=2 |>\n\
    <| a dscore=2 |>\nFor a vector:\n<code>", "    \"\"\"\n    search\n    \"\"\"\n\
    \    for x in lst\n        if x > 0 && x > lst[1]\n            return x\n    \
    \    end\n    end\n    return -1\nend\n</cell>\n<code language=julia-1.1>\nsearch(search([4,\
    \ 1, 2, 2, 3, 1]))\n</cell>\n<code language=julia-1.1>\nsearch(search([5, 5, 4,\
    \ 4, 4]))\n</cell>\n<text>\nExercise 3\nWrite a function that tests whether a\
    \ given number is a power of two (for positive integers).", "    findval = find(lst)\n\
    \    if findval == -1 \n        return -1 \n    else\n        freq = freq(lst[findval])\n\
    \        if freq == 0 \n            return -1 \n        else\n            return\
    \ findval \n    end\nend\n</code>\n<|/ a |>\n<| a |>\nThe algorithm is as follows:\n\
    1. Find the index of the greatest element in the array.\n2. Increment the frequency\
    \ of that element.\n3. Repeat until all elements are processed.\n<code>", "  \
    \  \n    if length(lst) == 0 \n        -1\n    else if lst[1] == 0 \n        lst[1]\n\
    \    else\n        if lst[end] == 0 \n            -1\n        else\n         \
    \   if lst[end] >= lst[end-1] \n                search(lst[end-1:end])\n     \
    \       else\n                search(lst[end-1:end])\n            end\n      \
    \  end\n    end\nend\n</cell>\n<code language=julia-1.1>\n@assert search([4, 1,\
    \ 2, 2, 3, 1]) == 2\n@assert search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n@assert\
    \ search([5, 5, 4, 4, 4]) == -1\n</cell>\n<text>\n12.3 Kth Smallest Element in\
    \ Matrix\nGiven a matrix $A\\in\\mathbb{R}^{m\\times n}$, let $A_{i,j}$ be the\
    \ $i$-th row vector and $A{j,i}$ be the $j$-th column vector of the matrix. \n\
    Write a function kthsmallest(A::Matrix{Int64})(k::Int) which returns the $k$-th\
    \ smallest element of $A$.", "    \n    local max_freq = -1\n    local current_freq\
    \ = 0\n    local i = 0\n    \n    while i < length(lst) and current_freq + lst[i]\
    \ > max_freq\n        \n        i += 1\n        current_freq += lst[i]\n     \
    \   \n        if current_freq > max_freq\n            \n            max_freq =\
    \ current_freq\n        end\n    end\n    \n    return -1  if i == length(lst)\n\
    \    \n    return max_freq\nend\n</cell>\n<text>\nThis approach of using a loop\
    \ seems more natural than using the built-in function max. Remember that in Julia,\
    \ functions are first-class objects and can be passed around and assigned to variables.\
    \ Here's how we might implement the algorithm you just learned:", "    \n    \n\
    \    count::Int64 = 0\n    for x in lst\n        if x > count\n            count\
    \ = x\n        end\n    end\n    return count\nend", "    greatest_num::Int64\
    \ = 9999999\n    most_frequent_num::Int64 = 9999999\n    for elt in lst \n   \
    \     if elt > most_frequent_num\n            most_frequent_num = elt\n      \
    \  elseif elt > greatest_num\n            greatest_num = elt\n        elseif elt\
    \ == most_frequent_num\n            most_frequent_num = elt\n        else\n  \
    \          most_frequent_num\n        end\n    end\nend", "        if length(lst)\
    \ == 0 \n            return -1\n        \n        greatest_value = -2 \n     \
    \   frequency = 0\n        \n        for i in lst\n            if i >= 0 && i\
    \ <= greatest_value\n                frequency += 1\n                if frequency\
    \ > greatest_value\n                    greatest_value = i\n                 \
    \   frequency = 1\n            else\n                frequency -= 1\n        \
    \        if frequency <= 0\n                    frequency = 1\n              \
    \  end\n            end\n        end\n        \n        return greatest_value\
    \ if frequency > 0 \n        return -1\n    end", "    if lst.head == -1\n   \
    \     return -1\n    if lst.tail == -1\n        return -1\n    if lst.head ==\
    \ lst.tail\n        return lst.head\n    if lst.head < lst.tail\n        if lst.head\
    \ % 2 == 1\n            search(lst.tail)\n        else\n            search(lst.tail)\n\
    \        end\n    end\n    \nend\n</code>\n<|/ a |>\n<| a |>\nUsing Maps and folds\n\
    <code>\nusing LinearAlgebra", "    cnt = 0\n    max = -1\n    for i in lst\n \
    \       if cnt==0\n            max = i\n            cnt = 1\n        elseif i>max\n\
    \            max = i\n            cnt+=1\n        end\n    end\n    return max\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>", "    if length(lst)\
    \ == 0\n        return -1\n    if length(lst) == 1  \n        return lst[1]\n\
    \    v = lst[1]\n    freq = length(lst.filter(x -> x > v))\n    while freq < v\n\
    \        freq = freq + length(lst.filter(x -> x > v))\n    end\n    return v if\
    \ freq >= v else freq\nend\n</code>\n<|/ a dscore=1 tags=search,vector,julia |>\n\
    <| a tags=search,vector,julia |>\nThis works on R:\n<code>\nmax(x[a <= x & a <=\
    \ max(x)]) for x in a\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis will return all\
    \ elements of x that are <= than max(x) if there are more than one.\n<|/ c |>\n\
    <| a tags=search,vector,julia |>\nIn R this would be something like this:\n<code>\n\
    x = [4, 1, 2, 2, 3, 1]\nx[which.max(x[x<=max(x)])]\n</code>\nWhich returns 2\n\
    <|/ a dscore=0 |>\n<| a |>\nI believe that this will also work in Julia. \n<code>\n\
    julia> search([4, 1, 2, 2, 3, 1])\n2", "    for i in lst\n        if i >= 0\n\
    \            if lst[i] == i && i <= length(lst)\n                return i\n  \
    \          end\n        end\n    end\n    return -1\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 |>\nUsing a hash table and a recursive function.\n<code>",
  "    # write your code in Python 3. Remember to add the conversion to Int in line\
    \ 3.\n    # your code here\n    \n    for i = 1:length(lst)\n        if lst[i]\
    \ == 0\n            return -1\n        else if lst[i] > 0 && lst[i] >= lst[i-1]\n\
    \            return lst[i-1]\n        end\n    end\n    return -1\nend", "   \
    \ sum = 0\n    for i in lst\n        sum += i\n        if sum > 0\n          \
    \  sum += i - sum\n            return sum\n        else\n            return -1\n\
    \        end\n    end\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThis isn't\
    \ correct. Try it with the example in the question. You will find that the answer\
    \ is not `2`, but `3`.\n<|/ c |>\n<| c |>\nSorry, I didn't notice that it was\
    \ sorted, I thought it wasn't.\n<|/ c |>\n<| a dscore=0 tags=julia |>\nHere's\
    \ a solution that will work even if the input vector is sorted.\n<code>", "  \
    \  \n    pos = findlast(x -> x > 0, lst)\n    if pos != length(lst)\n        return\
    \ -1\n    \n    last = lst[end]\n    if last > 0 && last == lst[pos]\n       \
    \ return pos\n    elseif last == 0 && lst[pos] > 0\n        return pos\n    elseif\
    \ last == 0 && lst[pos] == 0\n        return -1\n    else\n        return -1\n\
    \    end\nend\n</code>\n<|/ a tags=algorithm,julia,vector |>\n<| a tags=algorithm,julia,vector\
    \ dscore=1 |>\nI took some time looking at this but found that the solution I\
    \ came up with (very similar to what you have posted) was quite efficient and\
    \ easy to understand, so I went with it. I would like to understand more about\
    \ why this solution is better than the others provided so I will post my own solution\
    \ here if anyone is interested.\nHere is my solution and I hope it helps.\n<code>",
  "  if lst.zero?() \n    return -1\n  else\n  \tfrequency = findall(x -> x==lst[end],lst)\n\
    \tmax(frequency)\nend\n</cell>\n<text>\n3.4 Counting\nYou now have enough experience\
    \ to know how to use groupby and merge. Using these functions, you will be able\
    \ to easily get the frequency of numbers in a list of numbers.", "    \n    if\
    \ lst.isEmpty\n        return -1\n    end\n    \n    freq = collect(lst, length(lst))\n\
    \    \n    max = -1\n    \n    freq = freq - freq.filter( x -> x % 2 == 0)\n \
    \   \n    freq = freq.filter( x -> x > 0)\n    \n    for i in freq\n        if\
    \ freq[i] > max \n            max = i\n        end\n    end\n    \n    return\
    \ max\nend\n</cell>\n<code language=julia-1.6>\nsearch([4, 1, 2, 2, 3, 1])\n</cell>\n\
    <code language=julia-1.6>\nsearch([1, 2, 2, 3, 3, 3, 4, 4, 4])\n</cell>\n<code\
    \ language=julia-1.6>\nsearch([5, 5, 4, 4, 4])\n</cell>\n<code language=julia-1.6>\n\
    search([0, -1, 1, 2])\n</cell>\n<code language=julia-1.6>\nsearch([0, -1, 1, 2])\n\
    </cell>\n<code language=julia-1.6>\nsearch([0, -1, 1, 2])\n</cell>\n<code language=julia-1.6>\n\
    search([0, -1, 1, 2])\n</cell>\n<code language=julia-1.6>\nsearch([0, -1, 1, 2])\n\
    </cell>\n<code language=julia-1.6>\nsearch([0, -1, 1, 2])\n</cell>\n<code language=julia-1.6>\n\
    search([0, -1, 1, 2])\n</cell>\n<code language=julia-1.6>\nsearch([0, -1, 1, 2])\n\
    </cell>\n<code language=julia-1.6>\nsearch([0, -1, 1, 2])\n</cell>\n<code language=julia-1.6>\n\
    search([0, -1, 1, 2])\n</cell>\n<code language=julia-1.6>\nsearch([0, -1, 1, 2])\n\
    </cell>\n<code language=julia-1.6>\nsearch([0, -1, 1, 2])\n</cell>\n<code language=julia-1.6>\n\
    search([0, -1, 1, 2])\n</cell>\n<code language=julia-1.6>\nsearch([0, -1, 1, 2])\n\
    </cell>\n<code language=julia-1.6>\nsearch([0, -1, 1, 2])\n</cell>\n<code language=julia-1.6>\n\
    search([0, -1, 1, 2])\n</cell>\n<code language=julia-1.6>\nsearch([0, -1, 1, 2])\n\
    </cell>\n<code language=julia-1.6>\nsearch([0, -1, 1, 2])\n</cell>\n<code language=julia-1.6>\n\
    search([0, -1, 1, 2])\n</cell>\n<code language=julia-1.6>\nsearch([0, -1, 1, 2])\n\
    </cell>\n<code language=julia-1.6>\nsearch([0, -1, 1, 2])\n</cell>\n<code language=julia-1.6>\n\
    search([0, ", "    if lst.size <= 0\n        return -1\n    elseif lst.head==0\n\
    \        return -1\n    else\n        search(lst.tail)\n    end\nend", "    for\
    \ i in 0..length(lst) \n        idx = find(lst==lst[i], 1) \n        if idx >\
    \ 0 \n            return idx \n        else \n            return -1 \n    end\
    \ \nend \n</code>\n<|/ a dscore=0 tags=arrays,julia,performance,for-loop |>\n\
    <| a tags=arrays,julia,performance,for-loop |>\nThis solution utilizes broadcasting\
    \ mechanism which works in Julia v0.6:\n<code>", "    largest = Int64(1) \n  \
    \  largest = Int64(0) \n    for x in lst \n        if x > largest \n         \
    \   largest = x \n            \n            \n    for x in lst \n        if largest\
    \ == x \n            largest += 1\n            if largest >= x \n            \
    \    return x \n            end\n        end\n    end\n    return -1\nend\n</cell>\n\
    <text>\n15. Find the greatest integer that does not appear twice in a row\nGiven\
    \ a vector of ints, find and return the greatest integer that does not appear\
    \ twice in a row.\nExample 1:\nInput: [1, 2, 3, 2, 1]\nOutput: 1", "    # write\
    \ your code here\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nIt would be much nicer\
    \ if you added some explanation as to why this code is the solution to the question.\n\
    <|/ c |>\n<| c |>\nthanks for your suggestion, I added some explanation and modified\
    \ my answer.\n<|/ c |>\n<| a |>\nThis is my answer:\n<code>", "    \n    maximum\
    \ = 0\n    for each in lst \n        if each>0 \n            if each>maximum \n\
    \                maximum = each \n            end \n        end \n    end\n  \
    \  return maximum if maximum>0 \n    return -1 \nend ", "    #intialize to -1\n\
    \    minimum::Int64 = -1\n    #initialize to 0\n    freq::Int64 = 0\n    for i\
    \ in lst\n        minimum = minimum if minimum>i else i\n        freq = freq+1\
    \ #increment frequency by 1\n    end\n    return minimum if minimum>0 \n    return\
    \ -1 \nend", "    z = findfirst(x->x>0&&x==sort(lst),lst)\n    if z==nothing ||\
    \ z==length(lst)\n        -1\n    else\n        lst[z]\n    end\nend", "    return\
    \ search(lst, -1) # default return value is -1, but -1 is better\nend", "    biggest\
    \ = inf\n    for (i, val) in enumerate(lst) \n        if val == 0 && i > biggest\
    \ \n            biggest = i \n        else \n            if val > 0 \n       \
    \         return i \n            else \n                return biggest\n    return\
    \ -1 \nend ", "    if length(lst) == 0 \n        return -1\n    end\n    \n  \
    \  if lst[1] < 0 \n        return -1\n    end\n    \n    if length(lst) == 1 \n\
    \        return lst[1]\n    end\n    \n    if lst[1] == 0 \n        return -1\n\
    \    end\n    \n    if lst[1] >= length(lst) \n        return -1\n    end\n  \
    \  \n    if lst[lst[1]] == 0 \n        return -1\n    end\n    \n    \n    last\
    \ = lst[end] \n    \n    for i = 2 to length(lst)\n        if lst[i] < last \n\
    \            last = lst[i] \n        end\n    end\n    return last\nend\n    \n\
    # Test cases \nprintln(search([4, 1, 2, 2, 3, 1]))\nprintln(search([1, 2, 2, 3,\
    \ 3, 3, 4, 4, 4]))\nprintln(search([5, 5, 4, 4, 4]))\n</cell>\n<text>\nExercise\
    \ 8\nWrite a function that counts the number of occurrences of each distinct integer\
    \ in the vector lst. For example,", "    \n    if length(lst) == 0 \n        \n\
    \        return -1\n        \n    \n    max = maximum(A[lst])\n    \n    if max\
    \ < 0 \n        return -1\n        \n    \n    \n    else \n        if A[lst]\
    \ == max \n            \n            return max\n            \n        else \n\
    \            if A[lst] == max - 1 \n                return -1\n            else\
    \ \n                return search(lst[1:end-1]) + 1 \nend\n</cell>\n<text>\nSolution\n\
    You can use a binary search. Let start with the largest number. If it does not\
    \ exist, return -1. The binary search will stop at the index where the frequency\
    \ is equal to the value.", "    for x in lst\n        if x > 0\n            i\
    \ = search(x-1)\n            if i == -1\n                return -1\n         \
    \   if x > lst[i]\n                return x\n            elseif i == 0\n     \
    \           return -1\n            else\n                lst[i] = lst[i-1] + 1\n\
    \                return x\n        end\n    end\n    return -1\nend", "    # Write\
    \ your code in Julia 0.5\n    frequency = [counts(lst) .> i ? i : -1 for i in\
    \ unique(lst)]\n    minimum = minimum(frequency)\n    maximum = maximum(frequency)\n\
    \    \n    if minimum == maximum\n        return minimum\n    else\n        return\
    \ -1\n    end\nend\n</cell>\n<code language=julia-0.5>\n\"\"\"\n    You are given\
    \ a non-empty vector of positive integers. \n    Return the greatest integer that\
    \ is greater than or equal to zero \n    and the frequency of the integer is at\
    \ least as great as zero.\n    Examples:\n    >>> search([4, 1, 2, 2, 3, 1])\n\
    \    4\n    >>> search([4, 1, 2, 2, 3, 1])\n    4\n    >>> search([5, 5, 4, 4,\
    \ 4])\n    5\n    \"\"\"", "    flag = 0\n    for x in lst\n        if x == 0\n\
    \            break\n        if flag == 0\n            flag = count_freq(x)\n \
    \       elseif flag >= count_freq(x)\n            flag = count_freq(x)\n     \
    \   else\n            break\n    end\n    if flag >= count_freq(lst[1])\n    \
    \    flag = count_freq(lst[1])\n    else\n        flag = -1\n    end\n    return\
    \ flag\nend", "        \n    # traverse and find the first element\n    for i\
    \ in 1:length(lst)\n        if lst[i] >= 0\n            break\n    end\n    \n\
    \    # if the first element is not found in the list, return -1\n    if i == length(lst)\n\
    \        return -1\n    end\n    \n    # traverse and find the frequency of this\
    \ element in the list\n    j = i + 1\n    for k in 1:length(lst)\n        if lst[k]\
    \ > lst[j]\n            j = k\n        else\n            break\n        end\n\
    \    end\n    \n    # if the frequency of the element is greater than\n    # the\
    \ frequency of the element after it, return this element\n    if lst[j] >= lst[i]\n\
    \        return lst[j]\n    end\n    \n    return -1\nend\n</code>\n<|/ a |>\n\
    <| c |>\nI believe this is incorrect in that it will return -1 for [1,1,1] and\
    \ [1,2,3]\n<|/ c |>\n<| c |>\nGood point (I didn't think about it before posting),\
    \ I changed it.\n<|/ c |>\n<| a |>\nThe answer is given here: http://www.codechef.com/viewsolution/1417494\n\
    <code>", "  \n  if length(lst) == 0 \n    return -1\n  else\n    return max_of(lst)\
    \ \n  end\nend", "    sz=length(lst)\n    for i=1:sz\n        if lst[i]>=0 &&\
    \ count(lst,i)>=lst[i]\n            return i\n        end\n    end\n    return\
    \ -1\nend", "    \n    if lst==nil \n        return -1\n    \n    else \n    \
    \    flag = 0\n        pos = 1\n        while pos <= length(lst) do \n       \
    \     flag = flag + lst[pos-1]\n            pos = pos + 1\n        end\n     \
    \   if flag >= lst[1] \n            return flag\n        else \n            return\
    \ search(lst[1:end])\n        end\n    end\nend\n</cell>\n<text>\nSearch for an\
    \ element in a vector is known as linear search which runs in O(n) time. The above\
    \ function uses a recursive approach which runs time will be O(length (lst)^2).\
    \ Using a hash table is a more elegant approach which runs in O(length (lst)^2)\
    \ time."]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
