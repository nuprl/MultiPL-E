name: HumanEval_128_prod_signs
language: jl
prompt: "\"\"\"\n    You are given a vector arr of integers and you need to return\n\
  \    sum of magnitudes of integers multiplied by product of all signs\n    of each\
  \ number in the vector, represented by 1, -1 or 0.\n    Note: return nothing for\
  \ empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4])\n    9\n    >>>\
  \ prod_signs([0, 1])\n    0\n    >>> prod_signs([])\n    nothing\n    \"\"\"\nfunction\
  \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n"
tests: "using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
  \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
  \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
  \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
  \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
completions: ["    arr == [] ? nothing : prod(signs(arr))\nend\n</cell>\n<text>\n\
    2.5 Find maximum in array", "    if !isempty(arr)\n        ans = 0\n        for\
    \ i in arr\n            ans += sign(i)*i\n        ans\n    else\n        nothing\n\
    \    end\nend", "    return arr !== nothing ? sum(map(_sign , arr)) * prod(map(_sign\
    \ , arr)) : nothing\nend\n</code>\nAnd I got this error when using it:\n<code>\n\
    julia> prod_signs(xs)\nArgumentError: invalid type\n in prod_signs at /Users/maciej/Work/julia/packages/Base/src/Types.jl:574\n\
    \ in (::Atom.##5#6)(::Array{Int64,1}, ::Base.Symbol) at ./IndirectCall.jl:136\n\
    \ in (::Atom.##5#6)(::Array{Int64,1}, ::Base.Symbol) at ./IndirectCall.jl:135\n\
    \ in array at ./Base.jl:301\n in sum at ./sum.jl:57\n in product_signs at /Users/maciej/Work/julia/packages/Base/src/Types.jl:581\n\
    \ in (::Atom.##5#6)(::Array{Int64,1}, ::Base.Symbol) at ./IndirectCall.jl:136\n\
    \ in (::Atom.##5#6)(::Array{Int64,1}, ::Base.Symbol) at ./IndirectCall.jl:135\n\
    \ in array at ./Base.jl:301\n in sum at ./sum.jl:57\n in product_signs at /Users/maciej/Work/julia/packages/Base/src/Types.jl:581\n\
    \ in (::Atom.##5#6)(::Array{Int64,1}, ::Base.Symbol) at ./IndirectCall.jl:136\n\
    \ in (::Atom.##5#6)(::Array{Int64,1}, ::Base.Symbol) at ./IndirectCall.jl:135\n\
    \ in array at ./Base.jl:301\n in sum at ./sum.jl:57\n in product_signs at /Users/maciej/Work/julia/packages/Base/src/Types.jl:581\n\
    \ in (::Atom.##5#6)(::Array{Int64,1}, ::Base.Symbol) at ./IndirectCall.jl:136\n\
    \ in (::Atom.##5#6)(::Array{Int64,1}, ::Base.Symbol) at ./IndirectCall.jl:135\n\
    \ in array at ./Base.jl:301\n in sum at ./sum.jl:57\n in product_signs at /Users/maciej/Work/julia/packages/Base/src/Types.jl:581\n\
    \ in (::Atom.##5#6)(::Array{Int64,1}, ::Base.Symbol) ", "    if arr == []\n  \
    \      nothing\n    else\n        sum_sign = sum_sign(arr)\n        prod_sign\
    \ = prod_sign(arr)\n        sum_sign * prod_sign\n    end\nend", "    if isempty(arr)\
    \ || all(arr==0)\n        return nothing\n    elseif all(arr < 0)\n        return\
    \ sum(abs.(arr))\n    elseif all(arr > 0)\n        acc = 1\n        for i in arr\n\
    \            acc *= sign(i)\n        end\n        return acc\n    else\n     \
    \   return nothing\n    end\nend", "    if arr.is_empty()\n        nothing\n \
    \   else\n        a = arr.last\n        l = length(arr)\n        if l == 0\n \
    \           a\n        else\n            sum_of_signs(sum((sign(el) * a) for el\
    \ in arr))\n        end\n    end\nend\n</cell>\n<code language=julia-1.0>\n@assert\
    \ prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([])\
    \ == nothing\n</cell>\n<code language=julia-1.0>\n@assert prod_signs([-3, -2,\
    \ -1, 0, 1]) == 0\n@assert prod_signs([1, 2, 3]) == 3\n@assert prod_signs([-1,\
    \ 1, -2]) == 1\n</cell>\n<code language=julia-1.0>\n@assert prod_signs([-3, -2,\
    \ -1, 0, 1, 2, 3]) == 3\n@assert prod_signs([1, 2, 3, -4, -5]) == -3\n@assert\
    \ prod_signs([-1, 2, -4, -5, -3, -2]) == 1\n@assert prod_signs([-1, 2, 3, -4,\
    \ -5, -4, -3]) == -3\n@assert prod_signs([-1, 2, -4, -5, -3, -2, -1]) == 1\n@assert\
    \ prod_signs([-1, 2, -4, -5, -3, -2, -1, 1]) == -1\n@assert prod_signs([-1, 2,\
    \ -4, -5, -3, -2, -1, 0, -1]) == -1\n@assert prod_signs([-1, 2, -4, -5, -3, -2,\
    \ -1, 0, -1]) == -1\n@assert prod_signs([-1, 2, -4, -5, -3, -2, -1, 0, 1]) ==\
    \ 1\n@assert prod_signs([-1, 2, -4, -5, -3, -2, -1, 0, -1]) == -1\n@assert prod_signs([-1,\
    \ 2, -4, -5, -3, -2, -1, 0, 1, -1]) == -1\n@assert prod_signs([-1, 2, -4, -5,\
    \ -3, -2, -1, 0, -1, -1]) == -1\n@assert prod_signs([-1, 2, -4, -5, -3, -2, -1,\
    \ 0, -1, -2]) == -1\n@assert prod_signs([-1, 2, -4, -5, -3, -2, -1, 0, -1, -2,\
    \ 1]) == -1\n@assert prod_signs([-1, 2, -4, -5, -3, -2, -1, 0, -1, -2, -1]) ==\
    \ -1\n@assert prod_signs([-1, 2, -4, -5, -3, -2, -1, 0, -1, -2, -1, 1]) == -1\n\
    @assert prod_signs([-1, 2, -4, -5, -3, -2, -1, 0, -1, -2, -1, -1]) == -1\n@assert\
    \ prod_signs([-1, 2, -4, -5, -3, -2, -1, 0, -1, -2, -1, -1, 1]) == -1\n@assert\
    \ prod_signs([-1, 2, -4, -5, -3, -2, -1, 0, -1, -2, -1, -1, -1]) == -1\n@assert\
    \ prod_signs([-1, 2, -4, -5, ", "    if arr.length == 0\n        nothing\n   \
    \ else\n        sum_signs(arr.map(sign))\n    end\nend\n</cell>\n<text>\nLet's\
    \ try it! We have created one additional function sum_signs, \nthat helps us to\
    \ calculate sum of signed magnitudes of a given array:", "    if arr.length ==\
    \ 0 \n        nothing\n    elseif arr.length == 1 \n        arr[1]\n    elseif\
    \ arr.length == 2 \n        arr[1] * arr[1]\n    elseif arr.length == 3 \n   \
    \     arr[1] * arr[1] * arr[1]\n    elseif arr.length > 3 \n        arr[1] * arr[1]\
    \ * arr[1] * arr[1]\n    end\nend", "    sum = 0\n    for i in arr\n        sum\
    \ += i\n    end\n    if sum == 0 \n        nothing\n    else\n        sum\n  \
    \  end\nend\n</cell>\n<code language=julia-1.0>", "    if arr.isEmpty\n      \
    \  return nothing\n    else\n        sum_of_sigs = sum(arr .== sign)\n       \
    \ product = sum(arr .== 1)\n        product *= -1\n        return sum_of_sigs\
    \ + product\n    end\nend\n</code>\n<|/ a tags=julia,arrays dscore=1 |>\n<| a\
    \ tags=julia,arrays dscore=0 |>\n<code>", "    if length(arr)==0\n        nothing\n\
    \    elseif length(arr)==1\n        abs(arr[0])\n    elseif length(arr)>1\n  \
    \      sum(map(i->abs(i)*sign(arr[i]),arr))\n    end\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| c |>\nI tried to solve this question in the same way you answered but\
    \ I couldn't solve the problem.\n<|/ c |>\n<| c |>\n, I have added the solution\
    \ and a link to a benchmark. Hope you find this helpful!\n<|/ c |>\n<| c |>\n\
    Thanks, I checked your code with my array and it worked perfectly. Thanks again\
    \ for your answer.\n<|/ c |>\n<| c |>\nYou are welcome, and thank you for sharing\
    \ your solution, I will try to learn more of Julia language!\n<|/ c |>\n<| a |>\n\
    Here is my answer to your question:\n<code>", "    if length(arr)==0 \n      \
    \  return nothing\n    end\n    arr1 = [sign(x) for x in arr]\n    prod = reduce(vcat,\
    \ arr1)\n    magnitude = prod.^(1/prod(Array{Int,1}(arr1)))\n    summ = sum(magnitude)\n\
    end\n</code>\nThis code works because prod(Array{Int,1}(arr1)) is the product\
    \ of the signs of each number in the vector, thus you just need to sum the products.\n\
    <|/ a |>\n<| c |>\nI find your `@view .` syntax very useful.\n<|/ c |>\n<| c |>\n\
    Thanks for your kind words. I thought about this problem some days and came up\
    \ with this solution (which I call `prod_signs_fast`), which avoids intermediate\
    \ allocations. It works well for a vector with about 4 or 5 elements, where `@view\
    \ .` is slightly faster.\n<|/ c |>\n<| a dscore=2 |>\nSolution\n<code>\nusing\
    \ Base.Product", "    if length(arr)==0 return nothing \n    sum_of_signs = 0\n\
    \    for i in arr\n        sum_of_signs += sign(sqrt(i))\n    end\n    return\
    \ sum_of_signs * prod(map(sign,arr))\nend\n</cell>\n<text>\nAs a final check,\
    \ the product function should work as expected. Check that the product of all\
    \ signs of each number in the given vector is equal to the product of all squares\
    \ of magnitudes of all numbers.", "    if arr.length == 0\n        nothing\n \
    \   else\n        sum(arr.map(sign))*prod(signs(arr))\n    end\nend", "    if\
    \ isempty(arr)\n        return nothing\n    signs = zeros(Int64, length(arr))\n\
    \    for idx in 1:length(arr)\n        signs[idx] = sign(arr[idx])\n    end\n\
    \    return prod(signs)\nend\n</code>\n<|/ a |>\n<| c |>\nThanks for the answer.\
    \ I am going to study this code to understand it.\n<|/ c |>\n<| c |>\nThis seems\
    \ like a great solution. I have a question though: what exactly is the `@noreturn`\
    \ keyword doing? It seems like the function could just be `function prod_signs(arr::Vector{Int64})::Union{Int64,\
    \ Nothing}` instead.\n<|/ c |>\n<| c |>\nyes, that would work too. The idea of\
    \ noreturn is to tell Julia not to execute the body of function if an error is\
    \ risen, which is what is happening here. So Julia will just execute this function,\
    \ as if no error was risen.\n<|/ c |>\n<| c |>\nJust a little clarification: The\
    \ `@noreturn` does not *prevent* Julia from executing the body of the function,\
    \ but to prevent the function from being evaluated at all by Julia itself. If\
    \ Julia encounters an error, Julia will terminate the program without executing\
    \ any code in the body of the function.\n<|/ c |>\n<| a dscore=2 |>\nThe Julia\
    \ way would be to use map to go over the elements and calculate the sign for each,\
    \ than reduce to sum them:\n<code>\nreduce(+, map(sign, a)) \n</code>\n<|/ a tags=julia\
    \ |>\n<| a dscore=1 tags=julia |>\nFor completeness, one possible alternative\
    \ (to those of you who came here looking for a way to vectorize the signing operation\
    \ for a vector) is to use an anonymous function:\n<code>\nsigner = x -> sign(x)\n\
    reduce(+, map(signer, a))\n</code>\n<|/ a |>\n<| c |>\nYou don't need the `map`\
    \ here; `signer` is an anonymous function which takes a single argument `x` and\
    \ returns `sign(x)`.\n<|/ c |>\n<| c |>\n: You are right (thanks!). The `map`\
    \ was redundant, and it would probably be slightly faster if I replaced it with\
    \ `signer`.\n<|/ c |>\n<| a tags=julia |>\nThe solution with the reduce function\
    \ can be even simpler, just using sign\n<code>\nreduce(sign, a)\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThis answer is the correct ", "    arr2 = arr.copy()\
    \ # make a copy to avoid changing original array\n    for i in arr\n        arr2[i]\
    \ = signbit(arr[i])*arr[i]\n    end\n    return summap(arr2, :*) # sum of elements\
    \ with multiplicity * signs\nend\n</cell>\n<code language=julia-1.5>\n@time prod_signs(rand(1000000))\n\
    </cell>\n<text>\nExercise\nProve that this function works with negative numbers,\
    \ what about zero? What about the general case? Implement the function using an\
    \ accumulator and loops and return only a number. You should do this without mutating\
    \ any variables, so you should avoid using push!.", "    if is_empty(arr)\n  \
    \      nothing\n    else\n        prods = products(arr)\n        signs = signs(arr)\n\
    \        mags = map(sum, map(abs, arr))\n        \n        for prod in prods\n\
    \            for sign in signs\n                mag = mags[prod] * sign\n    \
    \            if mag != 0\n                    return mag\n                end\n\
    \            end\n        end\n    end\nend", "    if length(arr)==0 \n      \
    \  return nothing\n    sum::Int64 = 0\n    for i in arr\n        sum = sum + sign(i)\
    \ * i\n    end\n    return sum\nend", "    if length(arr)==0\n        return nothing\n\
    \    else\n        if arr[1] == 0\n            return 0\n        else\n      \
    \      if arr[1] > 0\n                return prod(arr)*prod_signs(arr[1..end])\n\
    \            else\n                return prod(arr)*prod_signs(arr[1:end])\n \
    \           end\n        end\n    end\nend", "    if length!(arr) == 0 \n    \
    \    return sum(abs(x)*prod(sign(x)) for x in arr) \n    else \n        return\
    \ nothing \n    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI think he wants help\
    \ understanding the algorithm as opposed to coding it.\n<|/ c |>\n<| c |>\nThis\
    \ is helpful, but I'm curious, why do we need the 'nothing' return value?\n<|/\
    \ c |>\n<| a dscore=0 |>\n<code>", "    if arr.isempty()\n        nothing\n  \
    \  else\n        sum(map(sign, arr))\n    end\nend\n</cell>\n<text>\nExercise\
    \ 3: Sign Test\nWrite a function that checks whether the array has any signs other\
    \ than -, 1 or 0.", "    if arr.empty\n        return nothing\n    signs = zeros(Int,\
    \ length(arr))\n    signs[1] = 1\n    for i in 2..length(arr)\n        signs[i]\
    \ = signs[i-1] * signs[i - 1]\n    end\n    return sum(arr .* signs)\nend", " \
    \   if length(arr) == 0 \n        return nothing\n    else\n        result = 0\n\
    \        for elem in arr \n            if elem > 0\n                result +=\
    \ 1\n            elseif elem < 0\n                result -= 1\n            elseif\
    \ elem == 0\n                result *= 0\n            end\n        end\n     \
    \   return result\n    end\nend\n</cell>\n<code language=julia-1.5>\n@test prod_signs([-1,\
    \ 2, 2, -4]) == 9\n@test prod_signs([1, 2, 2, -4]) == 0\n@test prod_signs([])\
    \ == nothing\n</cell>\n<text>\nExercise 5.24", "    if !isempty(arr) && arr ~=\
    \ [Int64]\n        prod = 1\n        mags = zeros(Int64)\n        for ele in arr\n\
    \            mags += ele*sign(ele)\n        end\n        mags = abs.(mags)\n \
    \       return sum(mags*prod)\n    end\n    return nothing\nend\n</code>\n<|/\
    \ a |>\n<| a |>\nI have written a solution in Julia, which I believe is pretty\
    \ efficient (O(n) complexity and O(1) extra space):\n<code>", "    \n    sum =\
    \ 0\n    sign = 1", "    if length(a) == 0 \n        return nothing \n    \n \
    \   sum_sign = 0\n    for i in arr \n        sign = sign(i) \n        sum_sign\
    \ = sum_sign + sign * abs(i) \n    \n    prod_sign = prod(map(sign,arr))\n   \
    \ return sum_sign * prod_sign \nend ", "    if all(arr == 0) \n        return\
    \ nothing \n    \n    if length(arr)==1\n        return arr[1]\n    \n    if length(arr)==2\
    \ \n        return arr[1]*arr[2]\n    end", "    if isempty(arr) \n        return\
    \ nothing \n    magnitudes = map(abs, arr) \n    sum_of_magnitudes = reduce(add,\
    \ magnitudes) \n    prod_signs = map(sign.(arr), magnitudes) \n    prod_signs\
    \ = reduce(mul, prod_signs) \n    prod_signs = sum(prod_signs) \n    \n    return\
    \ sum_of_magnitudes * prod_signs \nend ", "    for x in arr \n        @assert\
    \ x >= 0 && x < 4 \n        if x < 0 \n            return -prod_signs(-arr)\n\
    \        end\n    end\n    \n    signs_arr = map(sign, arr)\n    \n    abs_arr\
    \ = map(abs, arr)\n    \n    result = reduce(add, signs_arr) * reduce(mul, abs_arr)\n\
    \    return result \nend\n</cell>\n<text>\nThe final solution\nAll code presented\
    \ above can be rewritten to be compact and efficient. We will use Julia code instead\
    \ of our explicit for loops.", "    if length(arr)==0 return nothing \n    signs\
    \ = map(sign, arr) \n    prod = prod(signs) \n    mag = map(abs, arr) \n    return\
    \ prod * prod(mag)\nend", "    if length(arr)==0\n        return nothing\n   \
    \ else\n        m = arr[1]\n        v = arr[2]\n        s = 0\n        if m !=\
    \ 0\n            s += m\n            if v != 0\n                s += v\n     \
    \   end\n        if v != 0\n            s += v\n        end\n        return s\n\
    \    end\nend", "    if length(arr) == 0 \n        return nothing \n    end\n\
    \    \n    sum_of_signs = 0 \n    for elem in arr \n        sum_of_signs += if\
    \ elem == 0 then 0 else -1 end\n    end\n    \n    multiplied = 1 \n    for elem\
    \ in arr \n        multiplied *= if elem == 0 then 0 else -1 end\n    end\n  \
    \  \n    return sum_of_signs * multiplied\nend", "    length = length(arr)\n \
    \   sum = 0\n    for i in arr \n        if i == 0 \n            sum += i \n  \
    \      else \n            sum += sign(i) * i\n        end\n    end\n    return\
    \ sum\nend\n</cell>\n<text>\nExercise\nWrite a function that accepts an array\
    \ of integers and returns the minimum\nvalue of the array.", "    if arr.length==0\n\
    \        nothing\n    elseif arr.length==1\n        arr.signum*arr[1]\n    else\n\
    \        mul = 1\n        for v in arr\n            mul *= v\n            mul\
    \ *= (v.signum*2)\n        end\n        mul\n    end\nend", "    if isempty(arr)\n\
    \        return nothing\n    \n    s = 0\n    for x in arr\n        s += (x ==\
    \ 1) ? 1 : (x == -1) ? -1 : 0\n    end", "    \n    for i in arr\n        if i\
    \ == Int64(-1)\n            return nothing\n        else if i == Int64(0)\n  \
    \          return 0\n        elseif i == Int64(1)\n            return 1\n    \
    \    else\n            return prod_signs(arr[(index+1):end]) * i // abs(i)\n \
    \   end\nend", "    signs     = zeros(Int64, length(arr))\n    abs_arr   = copy(arr)\n\
    \    for i in eachindex(arr)\n        signs[i]  = (arr[i]<0)*2 +(arr[i]>0)\n \
    \       abs_arr[i] = abs(arr[i])\n    end\n    \n    return sum(signs*abs_arr)\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a |>\nThe simplest is probably the following:\n\
    <code>\n# if array is sorted", "    if isempty(arr)\n        return nothing\n\
    \    end\n    \n    sum_arr = zero(Int64)\n    mult_arr = [1, -1]\n    \n    for\
    \ a in arr\n        sum_arr += abs(a) * mult_arr[sign(a)]\n    end", "    sum\
    \ = 0\n    prod = 1\n    for x in arr\n        sum = sum + abs\n        sign =\
    \ sign(x)\n        sum = sum + sign * prod\n        prod = 0\n    end\n    return\
    \ sum\nend\n</cell>\n<code language=julia-1.6>\n@code_warntype prod_signs([1,\
    \ 2, 2, -4])\n@code_warntype prod_signs([0, 1])\n@code_warntype prod_signs([])\n\
    </cell>\n<text>\nFunction for calculating dot product\nWrite a function that returns\
    \ the dot product of two vectors.", "    if arr == []\n        nothing\n    elseif\
    \ arr == [0]\n        0\n    elseif arr == [1]\n        1\n    else\n        sum(map(sign,arr))\
    \ * prod(map(abs,arr))\n    end\nend\n</code>\nAnd if you have a long vector arr\
    \ you can convert it to array and call function above:\n<code>\narr1 = arr[arr!=0]\n\
    sum(map(prod_signs, arr1))\n</code>\n<|/ a |>\n<| c |>\nI really like this solution,\
    \ because it does not require any external packages. One potential downside is\
    \ that `sum` and `product` are not commutative, so if `a` > `b`, `a*b` may be\
    \ a negative number.\n<|/ c |>\n<| c |>\n, Yes, I think it might happen if `a`\
    \ is greater then `b` but `a` is negative number then `a*b` will be positive.\
    \  So I think `a>b` is OK. I'll check it again.  Thanks.\n<|/ c |>\n<| c |>\n\
    , Yes, I think `a>b` is OK. I've checked it, thanks. I've edited my answer, thanks\
    \ for your comments.\n<|/ c |>\n<| a tags=julia |>\nYou can also use reduce to\
    \ calculate the product of all signs of the numbers in arr:\n<code>\njulia> reduce(x\
    \ -> sign(x) * sign(x), arr)\n9\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n\
    I believe this should be the fastest and least memory consuming solution:\n<code>\n\
    sum(map(sign, arr)) .* prod(map(abs, arr))\n</code>\nAs correctly pointed out\
    \ by Benoit (thanks!) this solution does not work for larger arrays (the multiplication\
    \ overflows).\nIt can be fixed by changing the * operation to .* by introducing\
    \ multiplication by signs() as a pre-factor in the product sum. As pointed out\
    \ by DavidKlaus A. Muller this can be achieved by changing the definition of the\
    \ product to the following:\n<code>\nsum(map(sign, arr)) .* (prod(map(abs, arr))\
    \ .* signs(arr))\n</code>\nThe same approach can be used to calculate the sum\
    \ of the signs:\n<code>\nsum(map(sign, arr)) .* (sum(map(abs, arr)) .* signs(arr))\n\
    </code>\n<|/ a tags=julia |>\n<| c |>\n`prod(map(abs, arr))` is going to overflow\
    \ very quickly for large arrays. You could use a dot product instead\n<|/ c |>\n\
    <| c ", "    if length!(arr)\n        return nothing\n    else\n        return\
    \ reduce(product, map(sign, arr))\n    end\nend\n\"\"\"\n    You are given a vector\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the vector, represented by 1,\
    \ -1 or 0.\n    Note: return nothing for empty arr.", "    if len(arr)==0\n  \
    \      return nothing\n    end\n    \n    if arr[1] <= 0 || arr[1] > 2\n     \
    \   return nothing\n    end", "    if arr.size == 0\n        nothing\n    elseif\
    \ arr.size == 1\n        arr.product * sign(arr.first)\n    else\n        sum_of_signs\
    \ = Vector{Int64}([0])\n        for elem in arr\n            sum_of_signs = add(sum_of_signs,\
    \ signs(elem))\n        return prod(sum_of_signs)\n    end\nend", "    if length(arr)\
    \ == 0 \n        nothing \n    elseif length(arr) == 1 \n        if arr[0] ==\
    \ 0 \n            0 \n        else \n            nothing \n        elseif arr[0]\
    \ == -1 \n            1 \n        else \n            nothing \n    else \n   \
    \     if arr[0] == 0 \n            0 \n        else \n            if arr[1] ==\
    \ 0 \n                0 \n            elseif arr[1] == -1 \n                -1\
    \ \n            elseif arr[1] == 1 \n                1 \n            elseif arr[1]\
    \ == 0 \n                0 \n            elseif arr[1] == 1 \n               \
    \ -1 \n            elseif arr[1] == -1 \n                1 \n            else\
    \ \n                nothing \n        end \n    end \nend \n</code>\nMy results\
    \ from running this through optimised cProfile\n<code>\n% time ./sum_sign.jl\n\
    \    0.561 seconds (42.9 k allocations: 113.1 MB, 7.82 seconds)\n     52.78 \u03BC\
    s (0 allocations: 0 bytes)\n</code>\n<|/ a tags=performance,julia,arrays |>\n\
    <| c |>\nThanks, that's a great improvement on our solution.  For what it's worth,\
    \ in my own benchmarking I actually found this to be slightly faster than the\
    \ other solutions.  I realize this is more of an optimisation that's only worthwhile\
    \ if your problem size can grow large enough.\n<|/ c |>\n<| a tags=performance,julia,arrays\
    \ |>\nYou might want to look into the Statistics library which includes a function\
    \ called sum_of_signs.\n<code>\njulia> using Statistics", "    if isempty(arr)\
    \ \n        return nothing \n    else \n        return sum(abs)*prod(sign.(arr))\n\
    \    end\nend\n</cell>\n<text>\nExercise\nWrite a function that calculates the\
    \ minimum value and the maximum\nvalue of a given vector:", "    if arr.size ==\
    \ 0\n        return nothing\n    prod = 1\n    for i in arr\n        prod *= sign(i)\n\
    \    end\n    return prod\nend\n</code>\nAnd another for summing all magnitudes\
    \ multiplied by product of all signs of each number in the vector\n<code>\n\"\"\
    \"\n    You are given a vector arr of integers and you need to return\n    sum\
    \ of magnitudes of integers multiplied by product of all signs\n    of each number\
    \ in the vector, represented by 1, -1 or 0.\n    Note: return nothing for empty\
    \ arr.", "    sum(map(abs,arr))\nend", "    if arr == [] \n        return nothing\
    \ \n    magnitude = 0 \n    sign = 0 \n    for v in arr \n        if v <= 0 \n\
    \            sign = -sign \n        magnitude += abs(v) \n    magnitude = magnitude\
    \ * sign\n    return magnitude \nend \n</cell>\n<code language=julia-1.2>\n\"\"\
    \"\n    You are given a vector arr of integers and you need to return\n    sum\
    \ of absolute values of integers multiplied by product of all signs\n    of each\
    \ number in the vector, represented by 1, -1 or 0.\n    Note: return nothing for\
    \ empty arr.", "    if isempty(arr)\n        return nothing\n    end", "    if\
    \ isempty(arr) \n        return nothing \n    end", "    if isempty(arr)\n   \
    \     nothing\n    else\n        sum_of_signs(arr.*prod(arr.sign))\n    end\n\
    end", "    n = length(arr)\n    if n == 0\n        return nothing\n    signs =\
    \ zeros(n)\n    for i in 1:n\n        signs[i] = sign(arr[i])\n    end\n    return\
    \ sum(abs2.(signs))\nend\n</code>\nThen the code becomes shorter. \n<code>", " \
    \   arr_signs = vec(signs(arr))\n    sum_signs = sum(arr_signs)\n    prod = 1\n\
    \    for i in arr_signs\n        prod *= i\n    end\n    return (sum_signs * prod)\n\
    end", "    if length(arr) == 0 \n        return nothing \n    \n    prod = 1\n\
    \    for x in arr \n        prod *= sign(x) \n    \n    return prod * sum((abs(x)\
    \ for x in arr))\nend\n</cell>\n<code language=julia-1.5>\nprod_signs([1, 2, 2,\
    \ -4])\n</cell>\n<text>\nExercise 3:\nWrite a function that takes vector of integers\
    \ and returns vector of numbers that follow rule:\n$$ \nsign(x) = -1 \\\nx = 1,\
    \ 2, \\dots, M \\\nsign(x) = 1 \\\n\\textrm{where } \nsign(x) is either +1, 0,\
    \ -1 \\\n\\textrm{where } \nx \\in [-\\infty, \\infty]\n$$", "    if length(a)\
    \ == 0 \n        return nothing\n    elseif length(arr) == 0 \n        return\
    \ 0\n    end\n    \n    s = 0\n    for i in arr\n        s += sign(i) * i\n  \
    \  end\n    return s\nend\n</cell>\n<text>\nExercise 3: Implementation\nWhat is\
    \ the time complexity of our implementation of prod_signs function?\nWhat is the\
    \ time complexity of the following call?", "    if arr.length == 0 \n        return\
    \ nothing \n    signs = Int64.(-arr).^(arr.signs).*(arr)\n    return sum(abs.(signs))\
    \ \nend \n</cell>\n<code language=julia-1.5>", "    if isempty(arr)\n        return\
    \ nothing\n    elseif length(arr) == 1\n        return arr[1] * prod(map(sign,\
    \ arr))\n    elseif length(arr) == 2\n        return arr[1] * (arr[1] * prod(map(sign,\
    \ arr)))\n    else\n        return nothing\n    end\nend", "    if arr.length\
    \ == 0\n        return nothing\n    if arr.length <= 0\n        return 0\n   \
    \ \n    prod = 1\n    for num in arr\n        if num > 0\n            prod = prod\
    \ * num\n        end\n    end\n    return prod\nend", "    if length(arr) == 0,\
    \ return nothing; end;\n    magnitude = 0\n    for x in arr\n        magnitude\
    \ += Abs(x)\n    end\n    sign = 1\n    for x in arr\n        sign *= sign(x)\n\
    \    end\n    magnitude * sign\nend", "    if isempty(arr)\n        return nothing\n\
    \    else\n        return prod(signs(arr))\n    end\nend", "    if length(arr)\
    \ == 0\n        return nothing\n    else\n        sum = 0\n        for element\
    \ in arr\n            sum += element*signs(element)\n        end\n        return\
    \ sum\n    end\nend", "    for n in arr\n        @assert n > 0\n        @assert\
    \ n <= 10000\n        if n<0\n            v = -n\n        elseif n == 0\n    \
    \        v = 1\n        elseif n==1\n            v = 0\n        else\n       \
    \     v = math.sign(n) * math.abs(n)\n        end\n        v *= prod_signs(n-1)\n\
    \        push!(vs, v)\n    end\n    sum(vs)\nend", "    mag, prod = 0, 1\n   \
    \ for i in arr\n        mag += abs(i)\n        prod *= sign(convert(Int64,i))\n\
    \    end\n    return mag * prod\nend\n</code>\n<|/ a |>\n<| a dscore=2 tags=julia\
    \ |>\nA simpler way without comprehensions would be to implement the prod function\
    \ as follows:\n<code>", "    if length(arr) == 0 \n        return nothing \n \
    \   ans = 0 \n    signs = Int64[]\n    for i in arr \n        if i == 0 \n   \
    \         continue \n        sign = i \n        while i > 0 \n            sign\
    \ = sign > 0 ? 1 : sign * -1 \n            i -= 1 \n        push!(signs, sign)\
    \ \n        ans += sign * sum(signs) \n    return ans \nend", "  mx = abs.(arr)\n\
    \  if length(mx) == 0\n    return nothing\n  else\n    prod = 1\n    flag = trues(length(arr))\n\
    \    for elt in mx\n      if elt > 0\n        flag = false\n        break\n  \
    \    end\n    end\n    for i in eachindex(arr)\n      prod *= arr[i]\n    end\n\
    \    return prod * sum(flag)\n  end\nend", "    if isnothing(arr)\n        return\
    \ nothing\n    end\n    sum_sign = zeros(Int, size(arr))\n    for e in arr\n \
    \       sum_sign[e] = sign(e) * sum_sign[e]\n    end\n    return reduce(*, sum_sign)\
    \ \nend", "    sum = 0\n    for a in arr\n        sum += a^sign(a)\n    end\n\
    \    return sum\nend", "    if is_empty(arr)\n        nothing\n    else\n    \
    \    sum_signs(arr) * product((-arr).map(sign))\n    end\nend", "    sum = 0\n\
    \    for i in arr do \n        sum += (i<0) * abs(i) * sign(i)\n    end\n    nothing\n\
    end", "    len = length(arr)\n    if len == 0 \n        nothing\n    elseif len\
    \ == 1 \n        if arr[1] > 0\n            return arr[1] * prod(signs(arr))\n\
    \        elseif arr[1] < 0\n            return -arr[1] * prod(signs(arr))\n  \
    \      elseif arr[1] == 0\n            return 0\n        else\n            return\
    \ nothing\n    else\n        s = 0\n        for a in arr\n            s += a *\
    \ prod(signs(a))\n        return s\n    end\nend\n</code>\n<|/ a dscore=3 |>\n\
    <| a |>\nIf you don't need to return nothing for empty arrays, you could also\
    \ use the sum function.\n<code>", "    signs = 1\n    for i in arr\n        signs\
    \ = signs * i\n    end\n    return signs\nend\n</cell>\n<cell>\n@test prod_signs([])\
    \ == nothing\n@test prod_signs([1, 2, 3]) == 6\n@test prod_signs([1, 2, 3]) ==\
    \ 6\n@test prod_signs([-4, 2, 5]) == -9\n@test prod_signs([-4, 2, -5]) == -9\n\
    </cell>\n<text>\n6. Signed\nWe saw in the previous section how to calculate the\
    \ absolute value of a number", "    if arr.size == 0 return nothing \n    s =\
    \ sum(abs(x)*prod(signs(x)) for x in arr) \n    return s\nend\n</cell>\n<text>\n\
    Task: Write a function that determines whether two integers are relatively prime\
    \ (where relatively prime means that the gcd is 1). If they are relatively prime\
    \ then return 1, otherwise return 0. If the gcd of the integers is 1 then return\
    \ 1.", "    sum=0\n    prod=1;\n    for x in arr\n        sum += abs(x)*prod\n\
    \        prod *= sign(x)\n    end\n    return sum\nend", "    if !arr.any?\n \
    \       return nothing\n    sign = 1\n    sum = 0\n    for i in arr\n        sum\
    \ += sign * i\n        sign = 1 if i < 0 else -1 if i > 0 else 0\n    end\n  \
    \  return sum\nend", "    if !isempty(arr)\n        prod = 1\n        for e in\
    \ arr\n            if e > 0\n                prod *= -1\n            elseif e\
    \ < 0\n                prod *= 1\n            else\n                prod = 0\n\
    \            end\n        end\n        return sum(abs(e)*prod for e in arr)\n\
    \    end\n    return nothing\nend", "    \n    if length(arr)==0\n        return\
    \ nothing\n    \n    sum_mag =  arr * reduce(.^, [sign(arr[i]) for i in 1:length(arr)])\n\
    \    \n    return sum_mag\nend\n</cell>\n<text>\nNow let's make an instance of\
    \ the function and see what happens:", "    sum = 0\n    for i in arr\n      \
    \  sum += abs(i) * prod(sign(i))\n    \n    return sum\nend", "    if isempty(arr)\
    \ \n        return nothing\n    else\n        sum = 0\n        for v in arr\n\
    \            if v < 0\n                sum += (-1)^v\n            elseif v > 0\n\
    \                sum += v\n            else\n                sum += 1\n      \
    \      end\n        end\n        \n        return sum\n    end\nend\n</cell>\n\
    <code language=julia-1.0>\n@testset \"Ex4 Test\" begin\n    @test prod_signs([1,\
    \ 2, 3]) == 6\n    @test prod_signs([-4, 6, 3]) == -9\n    @test prod_signs([-6,\
    \ 6, -3]) == 9\n    @test prod_signs([-6, -3, 6]) == 9\n    @test prod_signs([])\
    \ == 0\nend\n</cell>\n<text>\nExercise 5 (10 points)\nImplement the function sign_magnitude\
    \ which returns a vector of the signs and magnitudes of the integer arguments\
    \ (both passed as arrays of integers).", "    \n    if isempty(arr)\n        nothing\n\
    \    else\n        sum(abs(arr)*prod(signs(arr)))\n    end\nend\n</cell>\n<code\
    \ language=julia-1.3>\ntest_function!(prod_signs)\n</cell>\n<code language=julia-1.3>\n\
    @testset \"product signs\" begin\n    \n    @test_throws AssertionError prod_signs(nothing)\n\
    \    @test_throws AssertionError prod_signs(Int64[])\n    @test_throws AssertionError\
    \ prod_signs(Int64[1, 3])\n    \n    # all signs case\n    @test prod(signs(Int64[1,2,3,4,4]))\
    \ == 4\n    \n    # negative case\n    @test prod(signs(Int64[-1,-5,3,-4,1]))\
    \ == -1\n    @test prod(signs(Int64[-1,-5,3,-4,-1])) == -1\n    @test prod(signs(Int64[-1,-5,3,-4,1,2]))\
    \ == -1\n    \n    # positive case\n    @test prod(signs(Int64[1,2,3,4,1])) ==\
    \ 1\n    @test prod(signs(Int64[1,2,3,4,-1])) == 1\n    @test prod(signs(Int64[1,2,3,4,1,2]))\
    \ == 1\n    \nend\n</cell>\n<text>\n5.2.3 Sum of magnitudes", "    sz = size(arr)\n\
    \    signs = vec(signs(arr))\n    return sum(map(x->x*signs,arr))\nend\n</code>\n\
    <|/ a tags=julia dscore=2 |>\n<| c |>\nThis is a very clever approach. I will\
    \ try to see if I can figure out why it works.\n<|/ c |>\n<| a dscore=0 |>\nIn\
    \ case someone is looking for the simplest approach:\n<code>", "    if length(arr)==0\
    \ \n        return nothing \n    sum = 0\n    for x in arr\n        sign = if\
    \ x<0 then 1 else if x>0 then -1 else 0 \n        sum += sign * x\n    sum \n\
    end", "  \n  if arr.size == 0 \n    return nothing \n  end ", "    if !isnothing(arr)\
    \ && length(arr)>0\n        return sum(arr.map(x -> sign(x)*abs(x)))\n    else\n\
    \        return nothing\n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([])\
    \ == nothing\n</cell>\n<text>\n\u270D\uFE0F Problem 4 (5 Points)\nWrite a function\
    \ called max_signs(arr::Vector{Int64}). It should return\nmaximum value of product\
    \ of all signs in the array.\nExample: arr = [1,2,2,-4], max_signs(arr) = 3.\n\
    You can assume that array will have at least one element.", "    if len(arr) ==\
    \ 0\n        nothing\n    else\n        sum(arr.map(x -> x * sign(x)))\n    end\n\
    end\n\"\"\"\n    You are given an integer n and you need to return\n    n factorial\
    \ where factorial is factorial of n, that is product\n    of n numbers in range\
    \ from 1 to n.\n    Your function must return nothing for negative n.", "    mags\
    \ = map(abs, arr)\n    signs = map(sign, arr)\n    s = prod(signs)\n    if !all(mags..=0)\n\
    \        nothing\n    else\n        signs.*s\n    end\nend\n</cell>\n<text>\n\
    Now let's try the function on the test set and see what happens.", "    if arr.length\
    \ == 0 \n        return nothing \n    product = arr.prod \n    positives = arr.filter(\
    \ x-> x > 0 ) \n    negatives = arr.filter( x-> x < 0 ) \n    return product *\
    \ (positives.sign.*negatives.sign - positives.sign.*positives.sign - negatives.sign.*negatives.sign)\
    \ \nend ", "    \n    if length(arr) < 2 return nothing\n    for a in arr do \n\
    \        \n        if isodd(a) then \n            return a+sign(a)\n        \n\
    \        el = elusive(a)\n        if el == 0 return nothing\n        el = elusive(el)\n\
    \        if el == 0 return nothing\n        if isodd(el) \n            \n    \
    \        sign = sign(a)\n            return sign*a+sign*el\n        end\n    end\n\
    end", "    if arr.length == 0\n        nothing\n    else\n        result = 1\n\
    \        for n in arr\n            sign = n >= 0 ? 1 : -1\n            result\
    \ *= sign\n        end\n        result\n    end\nend", "    if isempty(arr)\n\
    \        nothing\n    elseif length(arr)==1\n        arr[1]*prod(signs(arr))\n\
    \    else\n        return nothing\n    end\nend", "    len = length(arr)\n   \
    \ sign = Vector{Int64}(len); sign[] = 0; \n    sign[1] = -1\n    for a in arr\
    \ \n        sign[a] = a\n    end\n    return sum(sign)\nend", "    if is_empty(arr)\n\
    \        nothing\n    else\n        sum( map(sign,arr) .* (prod(map(sign,arr))\
    \ + prod(map((-),arr)) ))\n    end\nend", "    if arr.length == 1\n        return\
    \ arr[0]\n    arr2 = zeros(Int64, length(arr))\n    for (i,val) in enumerate(arr)\n\
    \        if val < 0\n            arr2[i] = -1\n        elseif val > 0\n      \
    \      arr2[i] = 1\n        else\n            arr2[i] = 0\n        end\n    end\n\
    \    prod = prod(arr2)\n    mags = abs.(arr2)\n    mags2 = zeros(Int64, length(arr))\n\
    \    for (i,val) in enumerate(mags)\n        if val < 0\n            mags2[i]\
    \ = 1\n        elseif val > 0\n            mags2[i] = -1\n        else\n     \
    \       mags2[i] = 0\n        end\n    end\n    return prod*prod(mags2)\nend",
  "    for num in arr do \n        sign = sign(num) \n        if sign == 1 \n    \
    \        sum = sum + num \n        else if sign == -1 \n            sum = sum\
    \ - num \n        else \n            sum = sum \n        end \n    end \n    return\
    \ sum \nend\n</code>\n<|/ a tags=julia,arrays dscore=1 |>\n<| a tags=julia,arrays\
    \ |>\nOne can also use the dot function which can be found in Statistics module\n\
    <code>\nusing Statistics", "    if length(arr) == 0 return nothing \n    if length(arr)\
    \ == 1 \n        if arr[0] == 1 return 1 \n        else return -1 \n    end\n\
    \    sum1 = sum((sign(i) for i in arr))\n    prod = 1\n    for i in arr \n   \
    \     prod = prod * sign(i) \n    end\n    return abs(sum1) * (prod)\nend\n</cell>\n\
    <text>\nWe start by testing our function. Note that we are able to test our function\
    \ with any vector and also with empty vectors. We have tested the function with\
    \ empty vectors already. We will see that this is important for testing functions\
    \ in general. We will discuss more of it in the coming exercises.", "    if length(arr)==0\
    \ \n        return nothing \n    signs = ones(Int, length(arr))\n    signs[arr\
    \ < 0] = -1\n    signs[arr > 0] = 1\n    prod = signs.*arr\n    return prod(prod)\n\
    end", "    if arr == []\n        nothing\n    elseif length(arr) == 0\n      \
    \  0\n    else\n        sum_signs = sum(map(x -> x * sign(arr[x]), 1:length(arr)))\n\
    \        prod_signs = prod(map(x -> x, arr))\n        sum_signs * prod_signs\n\
    \    end\nend", "    if length(a) == 0 return nothing\n    for x in arr \n   \
    \     if x == 0 \n            return 0 \n        else if x == -1 \n          \
    \  return 1 \n        else \n            return -1 \n    end\nend", "    if len(arr)\
    \ == 0 return nothing\n    ans = 1\n    signs = [1]\n    for i in arr\n      \
    \  sign = signs[i]\n        ans = ans * sign\n        signs = [sign; signs]\n\
    \    end\n    return ans\nend\n</code>\n<|/ a tags=julia |>\n<| a |>\nThe question\
    \ asks to return sum of magnitudes of integers multiplied by product of all signs\
    \ of each number in the vector, represented by 1, -1 or 0.\nFor example,\n<code>\n\
    julia> arr = [1, 2, 2, -4]\n4-element Vector{Int64}:\n 1\n 2\n 2\n -4", "    if\
    \ length(arr) == 0 \n        return nothing \n    else \n        arr1 = ones(Int,\
    \ length(arr))\n        signs = signs(arr)\n        signs0 = sum(signs)\n    \
    \    for ii in 1:length(arr) \n            arr1[ii] = sign(arr[ii]) * signs[ii]\
    \ * abs(arr[ii])\n        end\n        \n        sum(arr1)\n    end\nend\n</code>\n\
    <|/ a tags=julia dscore=2 |>\n<| a tags=julia dscore=1 |>\n<code>", "    if arr\
    \ == []\n        nothing\n    else\n        arr[1]*prod_signs(arr[2:end])\n  \
    \  end\nend\n</code>\nThe function above takes linear time and does not require\
    \ to store all numbers before finding the sum.\n<|/ a dscore=2 |>\n<| c |>\nThis\
    \ is probably the most straight-forward solution. It can probably be improved\
    \ further, but this should get you started.\n<|/ c |>\n<| c |>\nNice! I like the\
    \ fact that you used recursion to solve this.\n<|/ c |>\n<| a |>\nIf arr is sorted,\
    \ the time complexity can be reduced to O(n)\n<code>", "    if length(arr) ==\
    \ 0 \n        return nothing\n    end\n    signs = signs(arr)\n    summ = sum(signs)\n\
    \    if summ == 0 \n        return 0\n    end\n    arr2 = map( x -> x*signs[x],\
    \ 1:length(arr) ) \n    return sum( arr2 ) \nend\n\"\"\"\n    You are given a\
    \ vector arr of integers and you need to return\n    product of all signs of numbers\
    \ in the vector, represented by\n    1, -1 or 0.\n    Note: return nothing for\
    \ empty arr.", "    if length(arr)==0 return nothing\n    signs = []\n    for\
    \ i in arr\n        signs.append(i .< 0)\n    end\n    prod = 1\n    for i in\
    \ signs\n        prod = prod * i\n    end\n    return prod\nend", "    if arr\
    \ == []\n        nothing\n    else\n        prod_signs(arr[1:end-1]) * sign(arr[1])\n\
    \    end\nend", "    if length(arr)==0\n        nothing\n    else\n        sum(map(sign,\
    \ arr))\n    end\nend", "    if isempty(arr)\n        nothing\n    else\n    \
    \    # check if positive, negative or zero\n        sign = signbit(arr[end])\n\
    \        prod = 1\n        for n in arr\n            if signbit(n)\n         \
    \       prod *= -1\n            else\n                prod *= 1\n        end\n\
    \        sum(abs.(arr))*prod\n    end\nend", "  if arr.size == 0\n    return nothing\n\
    \  end\n  if arr.size > 0\n    sum_magnitude = 0\n    for n in arr\n      sum_magnitude\
    \ = sum_magnitude + n\n    end\n    product = 1\n    for n in arr\n      product\
    \ = product * sign(n)\n    end\n    return sum_magnitude * product\n  end\n  return\
    \ nothing\nend\n</cell>\n<code language=julia-1.0>\n@assert prod_signs([1, 2,\
    \ 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\n4.2) Fast computation of matrix multiplication\nFor a 3-by-4\
    \ matrix A (m x n), a 3-by-5 matrix B (n x p) and a scalar q, A * B is defined\
    \ as", "    if !isempty(arr)\n        # Sum of magnitudes of integers multiplied\
    \ by product of all signs\n        sum = (sum(abs, arr))\n        # Product of\
    \ all signs \n        prod = prod([sign(i) for i in arr])\n        return sum\
    \ * prod\n    else\n        return nothing\n    end\nend", "    if isempty(arr)\
    \ \n        return nothing \n    \n    mags = zeros(Int64, length(arr))\n    signs\
    \ = zeros(Int64, length(arr))\n    for (i,n) in enumerate(arr) \n        mags[i]\
    \ = abs(n)\n        signs[i] = sign(n)\n    \n    mags = mags * prod(signs)\n\
    \    return sum(mags)\nend\n</cell>\n<text>\nNow you can play with different inputs\
    \ to see the results:", "    if length(arr) < 2\n        return nothing\n    end",
  "    if length(arr)==0 \n        return nothing \n    end", "    # initialize result\
    \ to zero\n    res = zeros(Int64, 1)\n    \n    # looping over arr\n    for i\
    \ in arr\n        # check for sign change and updating res\n        if i>0\n \
    \           if i<0\n                res = -res\n            else\n           \
    \     res = res\n        end\n    end\n    \n    return res\nend", "    return\
    \ nothing\nend", "    if isempty(arr)\n        nothing\n    else\n        1 +\
    \ sum(x*sign(x) for x in arr)\n    end\nend\n</code>\n<|/ a dscore=1 tags=julia\
    \ |>\n<| a dscore=0 |>\n<code>\nsum(x->(x<0 ? x : 1)*sign(x),arr)\n</code>\nIt\
    \ gives:\n<code>\njulia> sum(x->(x<0 ? x : 1)*sign(x),arr)\n9\n</code>\n<|/ a\
    \ tags=julia |>\n<| a dscore=0 |>\nAnother way using reduce:\n<code>\nreduce(v->x*sign(v),arr,1)\n\
    </code>\n<|/ a tags=julia |>\n<| c |>\nYou mean `reduce(v->x*sign(v), arr, 1)`.\n\
    <|/ c |>\n<| c |>\nIt seems like `reduce` will return the sum of all values in\
    \ the array, rather than just the sum of the magnitudes. I believe it should be\
    \ `reduce(v->sign(v)*x, arr, 1)`. But I'm not a julia expert, so YMMV.\n<|/ c\
    \ |>\n<| a dscore=0 |>\nMy answer is similar to one by but using an if-else structure\
    \ to return the sum of the magnitudes, not just the sum of the values:\n<code>",
  "    if length(arr) == 0 \n        return nothing \n    end", "    if isempty(arr)\n\
    \        return nothing\n    end\n    prod = prod(arr)\n    signs = map(sign,\
    \ arr)\n    sum_mag = sum(abs, arr) * prod\n    return signs * sum_mag\nend",
  "    if arr.length == 0 \n        return nothing \n    end\n    signs = zeros(Int64,\
    \ length(arr))\n    signs[1] = 1 \n    for i in 2:length(arr)\n        signs[i]\
    \ = signs[i-1] * arr[i-1] % 2\n    end\n    return sum(abs.(signs)) \nend\n</cell>\n\
    <text>\nLet's now apply our function to the example array.", "    if (length(arr)==0)\n\
    \        return nothing\n    else\n        sum = 0\n        product = 1\n    \
    \    for i in arr\n            sum += abs(i)\n            product *= sign(i)\n\
    \        return sum*product\n    end\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia,function\
    \ dscore=0 |>\nHere's a short and readable way to do it:\n<code>", "    if length(arr)\
    \ == 0 \n        nothing\n    elseif length(arr) == 1 \n        if arr[0] == 1\
    \ \n            0\n        elseif arr[0] == -1 \n            1 \n        else\n\
    \            nothing\n        end\n    else\n        prod(arr.-minus.(arr))\n\
    \    end\nend\n</code>\n<|/ a dscore=1 tags=function,julia |>\n<| a dscore=0 |>\n\
    If you're happy with an arbitrary number of inputs, then you can do something\
    \ like this:\n<code>", "    if isempty(arr)\n        nothing\n    else\n     \
    \   sum(map(sign, arr))\n    end\nend", "    sum_signs = sum(signs(arr))\n   \
    \ prod_signs = prod(arr.sig.==1)\n    if sum_signs == 0 && !isfinite(prod_signs)\n\
    \        return nothing\n    else\n        return sum_signs*prod_signs\n    end\n\
    end\n</cell>\n<code language=julia-0.5>\n@test isnothing(prod_signs([]))\n</cell>\n\
    <code language=julia-0.5>\n@test isnothing(prod_signs([1]))\n</cell>\n<code language=julia-0.5>\n\
    @test prod_signs([1,2,3,-4]) == 9\n</cell>\n<code language=julia-0.5>\n@test prod_signs([-1,-2,-3,-4])\
    \ == 9\n</cell>\n<text>\nProduct of sums\nThis problem might be different than\
    \ the previous ones, it just multiplies each element by its sum.", "    if length(arr)\
    \ == 0 then return nothing end\n    s = 1\n    for x in arr\n        s += 1 *\
    \ sign(x) \n    return s\nend", "    if length(arr)==0\n        nothing\n    elseif\
    \ length(arr)==1\n        if arr[0] == -arr[0]\n            1\n        elseif\
    \ arr[0] == 0\n            0\n        else\n            nothing\n        end\n\
    \    else\n        sum_sign_prod = 1\n        sign_prod = 1\n        for e in\
    \ arr\n            if e==-arr\n                sign_prod*=-1\n            elseif\
    \ e==0\n                sign_prod*=0\n            else\n                sum_sign_prod+=sign_prod\n\
    \                sign_prod = 1\n            end\n        end\n        sum_sign_prod+=sign_prod\n\
    \        sum_sign_prod\n    end\nend\n</cell>\n<code language=julia-0.6>\n\"\"\
    \"\n    You are given a vector arr of integers and you need to return\n    sum\
    \ of magnitudes of integers multiplied by product of all signs\n    of each number\
    \ in the vector, represented by 1, -1 or 0.\n    Note: Use bitwise OR | for OR.\n\
    \    Example:\n    >>> prod_signs([1, 2, 2, -4])\n    9\n    >>> prod_signs([0,\
    \ 1])\n    0\n    >>> prod_signs([])\n    nothing\n    \"\"\"", "    if length(a)\
    \ == 0 return nothing \n    if all(v == 0 | v == 1 or v == -1 for v in arr) then\
    \ \n        if length(a) == 1 \n            return prod(arr) * sign(a[1])\n  \
    \      else \n            return prod(arr) * sign(a[1]) * prod(-sign(v) for v\
    \ in a[1:end-1]) \n        end \n    else \n        arr = arr.sort()\n       \
    \ sign = arr[2:end]\n        arr = arr[1:end-1]\n        sign = sign.sort()\n\
    \        prod = prod(sign)\n        return prod(arr) * prod\n    end\nend \n</code>\n\
    <|/ a tags=julia |>\n<| c |>\nNice answer. Although I cannot see much difference\
    \ to the answer above, I'd be interested to see which one is better, your or mine.\n\
    <|/ c |>\n<| c |>\nThis one is more compact and readable. I will add it to the\
    \ benchmark later when I am near a computer with julia.\n<|/ c |>\n<| c |>\n`Vector{Int64}`\
    \ is deprecated: use `Vector{Int}`.\n<|/ c |>\n<| a dscore=3 |>\nHere is another\
    \ solution using an iterator (basically a for loop), a comprehension and no sort:\n\
    <code>", "    if isempty(arr)\n        return nothing\n    sum = Int64(0)\n  \
    \  for x in arr\n        sum += sign(x)\n    result =prod(arr) * signs(arr)\n\
    \    if result == Int64(1)\n        return result\n    return sum\nend\n</cell>\n\
    <cell>\n\"\"\"\n    You are given a vector arr of integers and you need to return\n\
    \    sum of product of numbers of each element multiplied by product\n    of signs\
    \ of each element in the vector.", "    arr = arr.map(sign)\n    if length(arr)==0\n\
    \        return nothing\n    prod = prod(arr)\n    return sum(map(abs, arr*prod))\n\
    end\n</cell>\n<code language=julia-1.5>\n#export", "    if all(arr.==0)\n    \
    \    nothing\n    else\n        sum(map(sign, arr))\n    end\nend\n</code>\n<|/\
    \ a |>\n<| c |>\n`return nothing for empty arr` is not valid Julia syntax.\n<|/\
    \ c |>\n<| c |>\nAlso note that `nothing` is a reserved keyword, not a type. Some\
    \ people use `Nothing` instead, or just leave it out entirely.\n<|/ c |>\n<| a\
    \ dscore=0 |>\nHere is a solution in Julia without using any functions:\n<code>",
  "    if length(arr) == 0 \n        return nothing \n    end", "    if arr.isEmpty\
    \ \n        return nothing \n    signs = map(sign, arr)\n    signs = prod(signs)\n\
    \    return sum(map(abs, signs)) * signs\nend\n</cell>\n<code language=julia-1.5>\n\
    @time \n@time prod_signs(arr)\n</cell>\n<code language=julia-1.5>\n@time \n@time\
    \ prod(map(sign, arr))\n</cell>\n<code language=julia-1.5>\n@time \n@time sum(map(abs,\
    \ signs)) * signs\n</cell>\n<text>\nLet's now do the same for the sum of the squares\
    \ of the original array", "    nothing\nend", "    if isempty(arr) \n        return\
    \ nothing \n    end\n    magnitude = sum(abs(x) for x in arr)\n    sign = sum(x\
    \ != 0 for x in arr)\n    return magnitude * sign\nend\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes in a list of integers and returns the sum of\
    \ the squares:\n\\begin{equation}\n    Sq{arr} = \\sum_{i=1}^{n}{i}i^2 = \\sum_{i=1}^{n}{i}i^2\n\
    \\end{equation}\nImplement this function in the cell below:", "    arr2 = copy(arr)\n\
    \    length = length(arr)\n    if length == 0 \n        nothing\n    else\n  \
    \      for i = 1:length(arr)\n            arr2[i] = sign(arr[i])\n        end\n\
    \        prod = 0\n        for i = 1:length(arr)\n            prod *= prod(arr2)\n\
    \        end\n    end\n    prod\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\nFor\
    \ Python, using itertools.product\n<code>\nfrom itertools import product\nimport\
    \ numpy as np", "    sum_ = 0\n    for x in arr\n        if x > 0\n          \
    \  sum_ += x\n        end \n    end\n    return sum_ if arr.>0 \n    return nothing\
    \ \nend", "    if length(arr)==0\n        return nothing\n    end\n    return\
    \ sum(map(sign, arr))\nend", "    for e in arr\n        sign = if e < 0\n    \
    \        -1\n        elseif e > 0\n            1\n        else\n            0\n\
    \        end\n        e = e * sign\n    end\n    return e\nend", "    if length(arr)==0\
    \ \n        return nothing\n    signs = [0]*length(arr)\n    \n    for x in arr\
    \ \n        signs[x] =(x>0)\n    end\n    return sum(map(abs, signs)) \nend\n\
    </cell>\n<code language=julia-1.0>\nprod_signs(arr)\n</cell>\n<text>\nFor large\
    \ arrays, this will be faster than the naive algorithm", "    if length(arr) ==\
    \ 0 \n        return nothing \n    end\n    return reduce(*, map(sign, arr)) *\
    \ prod(map(abs, arr)) * prod(map(abs, map(sign, arr))) \nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 tags=julia |>\n<code>", "    sum(map(sign, arr))\nend\n</code>\n\
    <|/ a tags=julia,arrays,function |>\n<| a |>\nUsing reduce function and map function\n\
    <code>", "    if length(arr) == 0 \n        return nothing\n    end\n    mag::Float64\
    \ = 0\n    for x in arr \n        if x > 0\n            mag += sign(x)\n     \
    \   end\n    end\n    prod_signs = prod(arr[1 : (end - 1)])\n    mag * prod_signs\n\
    end\nprod_signs(arr)\n</cell>\n<code language=julia-1.5>\n@time prod_signs(arr)\n\
    </cell>\n<text>\nWrite a function to test whether an array of integers is monotonically\
    \ increasing.", "    if isempty(arr)\n        nothing\n    else\n        sum(arr.*(sign(arr)))\n\
    \    end\nend", "    if length(arr) == 0 \n        return nothing \n    product\
    \ = 1\n    for i in arr \n        product *= sign(i) \n    sum_of_magnitudes =\
    \ sum(map(abs, arr)) * product\n    return sum_of_magnitudes\nend", "    if length(args)\
    \ < 1, return nothing end\n    # compute sum of magnitudes \n    s_magnitudes\
    \ = map(abs, arr)\n    # compute product of sign of elements in arr\n    products\
    \ = map(sign, arr)\n    return sum(s_magnitudes .* products)\nend", "    if isempty(arr)\n\
    \        nothing\n    else\n        sum_of_magnitudes = sum(abs(arr))\n      \
    \  signs = map(sign, arr)\n        signs = reduce(vcat, signs)\n        prod_signs\
    \ = prod(signs)\n        return sum_of_magnitudes * prod_signs\n    end\nend",
  "    if length(arr) == 0 \n        return Nothing \n    else \n        magnitude\
    \ = 0\n        for a in arr \n            if a < 0 \n                magnitude\
    \ += a\n            else \n                magnitude += a\n        mag = sqrt(magnitude)\n\
    \        prod = 0\n        for a in arr \n            prod *= a < 0 ? -1 : 1 \n\
    \            prod *= a < 0 ? 0 : 1 \n            prod *= a < 0 ? a : a * -1\n\
    \        return mag * prod\n    end\nend\n</code>\n<|/ a |>\n<| c |>\nThank you\
    \ so much for the explanation! I couldn't really understand the logic. Really\
    \ appreciate it!\n<|/ c |>\n<| c |>\nI wrote this in Julia 0.5 and got wrong results\
    \ with numbers with negative sign. Fixed it by multiplying by -1 only if the number\
    \ is negative (as I did in the edit). Also added a link to more \"professional\"\
    \ solutions.\n<|/ c |>\n<| c |>\nThank you for the quick response! The professional\
    \ method works perfectly! I didn't understand how we could do the same thing without\
    \ using loops.\n<|/ c |>\n<| a tags=algorithm,julia,math dscore=1 |>\nYou can\
    \ use the following code snippet:\n<code>", "    if length(arr) == 0 \n      \
    \  return nothing\n    \n    sum_signs = 0\n    for i in arr \n        sum_signs\
    \ += sign(i)\n    end\n    \n    return prod(arr) .* sum_signs\nend\n</code>\n\
    This code only works with integers (and does not handle NaN). But it can easily\
    \ be adapted to work with floating point numbers, provided they have the same\
    \ sign (positive and negative).\n<|/ a dscore=3 |>\n<| a |>\nYou asked for a solution\
    \ in O(n) time. The trick is to use two queues. One queue will contain the integers\
    \ to sum the magnitudes of the numbers (as you did). The other queue will contain\
    \ pairs of signs that will signify the magnitudes signify. As long as the first\
    \ queue is non-empty, you will need to pull the front element from the queue.\
    \ The sign of that will be stored as a boolean value in a pair. The other element\
    \ of the pair is the magnitude and will be stored as the value of the element\
    \ at the head of the queue. As you iterate through the elements, you will need\
    \ to add these two pairs together until you have no elements left. The magnitude\
    \ of the resulting sum will then be the value of the element at the head of the\
    \ queue.\nThe code below should do what you need. \n<code>", "    return nothing\
    \ if length(arr)==0 \n    return prod(signs(arr))\nend", "    if arr.is_empty\n\
    \        nothing\n    else\n        sum_products(arr, prod(signs(arr)))\n    end\n\
    end\n</code>\nNow all we need to do is get the function prod_signs to run on our\
    \ array of Integers. We do this by using map(..., prod_signs), which takes a function\
    \ and applies it to every element of an array.\n<code>\njulia> map(prod_signs,\
    \ arr)\n7-element Array{Union{Nothing, Int64},1}:\n nothing\n 0\n -4\n 9\n nothing\n\
    \ nothing\n nothing\n</code>\nWe can see this has done exactly what we want. Now,\
    \ all we need to do is to reorganize the results into a new array that we can\
    \ easily sum using sum.\n<code>\njulia> map(x->[x], map(x->[x], map(prod_signs,\
    \ arr)))\n7-element Array{Array{Int64,1},1}:\n nothing\n 0\n -4\n 9\n nothing\n\
    \ nothing\n nothing\n</code>\nNow we have the results in the form of an array\
    \ of vectors. To sum them we just need to use reduce, passing in +. Finally, we\
    \ can sum our original array by just calling sum.\n<code>\njulia> sum(map(prod_signs,\
    \ arr))\n9\n</code>\n<|/ a dscore=1 |>\n<| a tags=arrays,julia dscore=1 |>\nIn\
    \ case you don't want to use any packages:\n<code>", "    if length(arr) == 0\
    \ \n        return nothing \n    else \n        signs = prod(map(sign, arr))\n\
    \        magnitudes = sum(map(abs, arr))\n        return signs*magnitudes\n  \
    \  end\nend\n</cell>\n<code language=julia-1.1>\nprod_signs([1, 2, 2, -4, 3])\n\
    </cell>\n<code language=julia-1.1>\n# solutions\n@assert prod_signs([1, 2, 2,\
    \ -4, 3]) == 9\n@assert prod_signs([1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\nPart 6: Mathematical Operations\nExercise: Find dot product of\
    \ vectors arr1 and arr2\nNote: The dot product of two vectors $\\mathbf{a}$ and\
    \ $\\mathbf{b}$ is defined as:", "    if length(arr)==0\n        return nothing\n\
    \    end\n    signs = if arr[1]<0 then -1 else 1\n    product = 1\n    for num\
    \ in arr\n        product *= signs*num\n    end\n    return product\nend\n</cell>\n\
    <code language=julia-1.0>", "    if len(arr) == 0 \n        return nothing\n \
    \   prod = prod |> product\n    signs = zeros(Int64, length(arr))\n    for (i,el)\
    \ in enumerate(arr)\n        signs[i] = el > 0 ? 1 : el < 0 ? -1 : 0\n    end\n\
    \    return sum(el * signs * prod for el in arr)\nend", "    for elem in arr\n\
    \        if elem > 0, sign = +1\n        elif elem < 0, sign = -1\n        else,\
    \ sign = 0\n        end\n        mult_sign = sign * elem\n        sum_mag += sign\
    \ * ele * mag(mult_sign)\n    end\n    nothing\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| c |>\nthanks, I'll give this a try. but what is the use of \"nothing\"\
    \ in this case?\n<|/ c |>\n<| c |>\n`nothing` is just the return value for the\
    \ function, so it is needed if you don't return the value you want to return from\
    \ the function. You could also return nothing if you want, it won't do any harm.\n\
    <|/ c |>\n<| a tags=julia |>\nOne way to solve this is by using the map function.\
    \ map can iterate over an iterable of values and return another iterable. For\
    \ example, the following code computes the magnitude of all the numbers in a vector.\n\
    <code>\nusing Statistics", "    \n    if len(arr) == 0 \n        return nothing\n\
    \    end", "    if isempty(arr)\n        return nothing\n    else\n        sum\
    \ = 0\n        sign = 1\n        for val in arr\n            sum += sign * absval(val)\n\
    \            sign *= sign\n        end\n        return sum\n    end\nend", " \
    \   if is_empty(arr) \n        nothing\n    else\n        sum(map(sign, arr))\
    \ * prod(map(sign, arr))\n    end\nend\n</code>\n<|/ a tags=julia,arrays |>\n\
    <| a tags=julia,arrays |>\nHere is a solution that is O(n)\n<code>\njulia> function\
    \ sum_abs_vals(x)\n           return sum(x .* abs.(x)) .* prod(map(sign, x))\n\
    \       end\nsum_abs_vals (generic function with 1 method)", "    if arr.length==0\n\
    \        return nothing\n    end\n    mags = map(abs, arr)\n    signs = map(sign,\
    \ arr)\n    result = mags[1] * signs[1] * signs[2] * signs[3]\n    return result\n\
    end\n</code>\n<|/ a tags=julia |>\n<| c |>\nThanks. I'm a bit confused why you\
    \ used a `Vector` type. Wouldn't it be easier to use a `Array`? The example in\
    \ the question was just an example though.\n<|/ c |>\n<| c |>\nThe `Vector` type\
    \ is very useful when dealing with vectors of different types. For example, when\
    \ working with vectors of integer vectors, it allows the elements to be accessed\
    \ more conveniently, e.g. `arr[1][2]`, which would not be possible with an array.\n\
    <|/ c |>\n<| c |>\n`Vector{Vector{Int}}` should be `Vector{Array{Int,1}}`. And\
    \ `Vector{Array{Int,2}}` should be `Vector{Array{Int,2}}`...\n<|/ c |>\n<| a |>\n\
    Here is another version, using comprehensions:\n<code>\nusing LinearAlgebra",
  "    if length(arr)==0\n        nothing\n    else\n        sum(sqrt(sum(x*x for\
    \ x in arr))) # sum of squares of magnitudes\n    end\nend", "    if length(arr)==0\
    \ \n        return nothing\n    else\n        prod_signs(arr[1:end-1], prod(arr),\
    \ prod([sign(x) for x in arr[1:end-1]]))\n    end\nend\n</cell>\n<text>\nLet's\
    \ now test your function by comparing with the solution:", "    # check if arr\
    \ is empty\n    if !arr\n        return nothing\n    end\n    # check if arr is\
    \ just one item\n    if length(arr)==1\n        return arr[1]*prod(-sign(arr))\n\
    \    end\n    # else loop through arr\n    # initialize prod to 1\n    prod =\
    \ 1\n    # loop through each item of arr\n    for i in arr\n        # update prod\
    \ of current item to prod of current item times sign(item)\n        prod *= sign(i)\n\
    \    end\n    # return product of prod times sign(arr)\n    return prod(prod(-sign(arr)))\
    \ * prod\nend\n</code>\n<|/ a tags=julia,arrays dscore=0 |>\n<| c |>\n`prod(-sign(arr))`\
    \ can be simplified to `sum(-sign(arr))`.\n<|/ c |>\n<| c |>\nThanks so much!\
    \ You saved my life.\n<|/ c |>\n<| a |>\nThis is a recursive solution, which works\
    \ for both integers and vectors:\n<code>", "    sum = 0\n    for x in arr\n  \
    \      sum += sign(x)*x*x\n    return sum\nend\n</cell>\n<code language=julia-1.3>",
  "    if length(arr)==0 return nothing\n    signs=[+1 -1 0]\n    signs=[signs[i]*arr.[i]\
    \ for i in 1:length(arr)]\n    magnitudes=[abs(x) for x in arr]\n    prod(signs)*prod(magnitudes)\n\
    end", "    if length(arr) == 0 \n        return nothing \n    end", "    signs\
    \ = unique(map(sign, arr)) - [-1,1]\n    product_of_signs = prod(signs)\n    signs_product\
    \ = signs.*product_of_signs\n    sum_of_signs_product = sum(signs_product)\n \
    \   nothing\nend\n</cell>\n<text>\nTask 4.5\nImplement a function that calculates\
    \ mean of a vector of floating point numbers. Return nothing for empty vector.",
  "    sum = 0\n    for x in arr\n        sum = sum + abs(x)\n    end\n    prod =\
    \ 1\n    for x in arr\n        prod = prod * x\n    end\n    return sum * prod\n\
    end", "    if arr.is_empty()\n        Nothing\n    else\n        sum(abs.(arr).*prod(signs(arr)))\n\
    \    end\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| a tags=julia,arrays |>\n\
    You can use broadcasting here - which saves you from having to create a separate\
    \ array just to compute the product of all signs.\n<code>\njulia> function prod_signs(arr::Vector{Int64})::Int64\n\
    \           return sum(abs(arr)\xF7prod(signs(arr)))\n       end\nprod_signs (generic\
    \ function with 1 method)", "    if length(arr) == 0 \n        return nothing\
    \ \n    arr1 = arr.clone() \n    for i in arr \n        if i < 0 \n          \
    \  arr1[i] = -arr1[i] \n        end\n    end\n    sum = 0\n    for j in arr1 \n\
    \        if j == 0 \n            sum += 1\n        else \n            sum += 1\
    \ * sign(j)\n        end\n    end\n    return sum\nend", "  if length(arr)==0\
    \ return nothing\n  signs = signs(arr)\n  prod = ones(length(signs))\n  for i\
    \ \u2208 1:length(signs) prod[signs[i]] = prod(prod[signs[i]])\n  return prod(prod(arr))\n\
    end\n</cell>\n<text>\nTests", "    return nothing\n    if !isempty(arr), \n  \
    \      signs = prod(x -> sign(x), arr)\n        return sum(abs(x) * signs) for\
    \ x in arr\n    else\n        return nothing\n    end\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThank you for your answer! I've already solved the problem using your\
    \ function and I agree with your suggestion. I guess I'll remember this in future,\
    \ thanks!\n<|/ c |>\n<| c |>\nThank you for the answer, I just wanted to share\
    \ how I solved it (without using `if...else` statements) in case anyone might\
    \ want to use it in the future. I ended up using `@nj` for vectorization and `@profile`\
    \ for profiling, then used `@time` for timing. It was pretty straightforward!\n\
    <|/ c |>\n<| a tags=julia,performance,arrays,performance |>\nAs has pointed out,\
    \ a very good way to speed up your computation is to use Julia's vectorized operations.\n\
    That being said, if you're using Julia 1.2 or later, the simplest answer is to\
    \ use the function sign:\n<code>\njulia> arr = [1, 2, 2, -4]\n4-element Array{Int64,1}:\n\
    \ 1\n 2\n 2\n -4", "    if all(elem < 0 for elem in arr) # if all elements are\
    \ negative\n        prod(-arr)\n    else\n        sum(abs.(arr)) # if only some\
    \ elements are negative\n    end\nend\n</cell>\n<code language=julia-1.0>", " \
    \   if arr.is_empty\n        return nothing\n    end\n    \n    if sum(arr) ==\
    \ 0\n        return 0\n    end\n    \n    prod = 1\n    for x in arr\n       \
    \ if x > 0\n            prod *= -1\n        elseif x<0\n            prod *= 1\n\
    \        end\n    end\n    \n    return round(sqrt(prod))\nend", "    if length(arr)\
    \ == 0 \n        return nothing\n    \n    sum_sign = 1 + prod(map(sign, arr))\n\
    \    sum_num = sum((x->sign(x) * abs(x)) .- 1)\n    return sum_sign * sum_num\n\
    end", "    if len(arr) == 0\n        nothing\n    else\n        sum((arr[i]^1)*sign((arr[i]))\
    \ for i = 1:length(arr))\n    end\nend", "    if isempty(arr)\n        return\
    \ nothing\n    signs = [sign(x) for x in arr]\n    s = prod(signs)\n    sm = 0\n\
    \    for x in arr\n        sm = sm + (x * sign(x) * s)\n    end\n    return sm\n\
    end", "    if isempty(arr)\n        return nothing\n    prod = 1\n    for i in\
    \ arr\n        sign = sign(i)\n        prod *= sign\n    end\n    return prod\n\
    end", "    if length(arr)==0\n        nothing\n    elseif length(arr)==1\n   \
    \     if arr==0\n            0\n        elseif arr==-1\n            -1\n     \
    \   else\n            1\n        end\n    else\n        sum(map(sign, arr))\n\
    \    end\nend\n</code>\n<|/ a |>\n<| c |>\nThe performance of this should be pretty\
    \ decent given there are only `N` integers in the input. `O(N)` should be fine.\n\
    <|/ c |>\n<| a |>\n<code>", "    arrLen = length(arr)\n    if arrLen < 2\n   \
    \     return nothing\n    \n    positive = arr .>= 0\n    \n    positiveLen =\
    \ length(positive)\n    negative = arr .< 0\n    negativeLen = length(negative)\n\
    \    \n    if positiveLen == 0 && negativeLen == 0\n        \n        return 0\n\
    \    else\n        \n        # product of all positives\n        positiveProd\
    \ = 1 .* prod(positive)\n        \n        # product of all negatives\n      \
    \  negativeProd = 1 .* prod(negative)\n        \n        # sum of magnitudes of\
    \ pos * neg products\n        productMagnitude = positiveProd * negativeProd\n\
    \        \n        # sum of absolute values of pos * neg products\n        productAbs\
    \ = sum(abs(positive) * abs(negative))\n        \n        # sum of the magnitudes\
    \ of all integers multiplied by product of signs\n        sumMagnitude = productMagnitude\
    \ + productAbs\n        \n        return sumMagnitude\n    end\nend\n</cell>\n\
    <text>\nExercise 2: Count the number of positive numbers in arr\nThe function\
    \ count_positives takes arr as an input and returns count\nof positives in arr.",
  "    if isempty(arr)\n        return nothing\n    end\n    arr2 = sort(arr)\n  \
    \  product = prod(arr2)\n    prod = arr2\n    for elem in arr2\n        if elem\
    \ > 0\n            prod = [1 for i in prod]\n        elseif elem < 0\n       \
    \     prod = [-i for i in prod]\n        elseif elem == 0\n            prod =\
    \ [0 for i in prod]\n        end\n    end\n    signs = [-1 for i in prod]\n  \
    \  magn = [0 for i in prod]\n    summa = 0\n    for el in arr\n        summa +=\
    \ el\n    end\n    for el in arr2\n        magn .+= el\n    end\n    for el in\
    \ arr2\n        if signs[el] > 0\n            signs[el] += el * summa\n      \
    \  elseif signs[el] < 0\n            signs[el] -= el * summa\n        elseif signs[el]\
    \ == 0\n            signs[el] = el * summa\n        end\n    end\n    return product\
    \ * prod(signs)\nend\n</cell>\n<code language=julia-1.3>\narr = [1, -1, -2, 3,\
    \ 4, -5, -3]\nprod_signs(arr)\n</cell>\n<code language=julia-1.3>", "    if length(arr)==0\
    \ return nothing\n    sum_sign = zero(Int64)\n    product = 1\n    negated = false(Int64)\n\
    \    for x in arr\n        if iszero(x) || x==-Inf || x==-0 then return nothing\n\
    \        sign = x<0 ? -1 : +1 if x>0 else 1\n        if negated && !negated then\n\
    \            negated = false\n            sign = -sign\n        end\n        product\
    \ *= sign\n        sum_sign += sign * x\n    end\n    return sum_sign * product\n\
    end\n</cell>\n<text>\nExercise 1\nWrite a function sum_sign(arr::Vector{Int64})\
    \ to return the sum of the magnitudes\nof integers multiplied by product of all\
    \ signs of each number in the vector,\nrepresented by 1, -1 or 0.", "    if arr.length\
    \ == 0, nothing\n    else\n        prod_signs_helper(arr)\n    end\nend", "  \
    \  if length(arr) == 0 \n        return nothing\n    end", "    if length(arr)\
    \ == 0\n        return nothing\n    \n    # Compute sign of each number in arr\n\
    \    signs = zeros(Int, length(arr))\n    signs[arr .>= 0] = 1\n    signs[arr\
    \ .< 0] = -1\n    \n    # Compute product of all signs of each number in arr\n\
    \    prod = product(signs)\n    \n    # Return sum of all product magnitudes multiplied\
    \ by product of all signs\n    return prod * sum(signs)\nend", "    if length(arr)\
    \ == 0 \n        nothing \n    else \n        prod_signs(arr[1:end-1]) * prod(-x\
    \ for x in arr) \n    end\nend\n</cell>\n<code language=julia-1.6>\n@doc prod_signs\n\
    </cell>\n<text>\n3.2 Multiply\nYour task is to implement function multiply.",
  "    if isempty(arr)\n        return nothing\n    else\n        prod_signs(reverse(arr))\n\
    \    end\nend", "    if length(arr) == 0 \n        return nothing\n    else\n\
    \        prod_signs = prod(signs(arr))\n        return sum((arr * signs(arr)).^prod_signs)\n\
    \    end\nend", "    if length(arr)==0 return nothing\n    signs = zeros(length(arr))\n\
    \    for x in arr\n        for i=1:length(x)\n            if x[i] < 0 signs[i]\
    \ = signs[i] + sign(x[i])\n            else signs[i] = signs[i] * sign(x[i])\n\
    \        end\n    end\n    return sum(signs)\nend\n</cell>\n<code language=julia-1.6>",
  "    if isnothing(arr)\n        return nothing\n    elseif length(arr) == 0\n  \
    \      return nothing\n    elseif length(arr) == 1\n        return 0 if arr ==\
    \ 0 else arr[0]\n    else\n        sign = if arr[1] < 0 then -1 else 1\n     \
    \   return sign * arr[1] * prod_signs(arr[2:end])\n    end\nend\n\"\"\"\n    You\
    \ are given a vector arr of integers and you need to return\n    sum of magnitudes\
    \ of integers multiplied by product of all signs\n    of each number in the vector,\
    \ represented by -1, 0 or 1.\n    Note: return nothing for empty arr.", "    if\
    \ isempty(arr) \n        return nothing\n    elseif length(arr) == 0 \n      \
    \  return nothing\n    else\n        signs = map(sign, arr)\n        signs_product\
    \ = prod(signs)\n        arr_product = prod(arr)\n        return signs_product\
    \ * arr_product\n    end\nend\n</cell>\n<code language=julia-1.1>\n@assert prod_signs([4,\
    \ 2, -3]) == -9\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nTask\nHow\
    \ many numbers are there in the vector:", "    if arr.size==0\n        return\
    \ nothing\n    else\n        return prod([sign(i) for i in arr]) * sqrt(sum(abs2,arr))\n\
    \    end\nend", "    ans = Int64(0)\n    if !isempty(arr)\n        ans = prod.(map(sign,\
    \ arr))\n    end\n    ans\nend", "    if length(arr)==0\n        return nothing\n\
    \    return sum(map(sign, arr))*product(map(sign, arr))\nend\n</code>\n<|/ a tags=julia\
    \ dscore=1 |>\n<| a tags=julia dscore=1 |>\nMy solution is:\n<code>", "    if\
    \ len(arr)==0 return nothing\n    return sum(map(abs,arr).*prod(map(sign,arr)))\n\
    end\n</code>\nThe function returns nothing when arr is empty, but it will return\
    \ nothing when arr is non-empty.\n<|/ a |>\n<| a tags=vector,functional-programming,julia,arrays\
    \ |>\nHow about this \n<code>\njulia> function prod_signs(arr::Vector{Int64})::Union{Int64,\
    \ Nothing} \n           if length(arr)==0 return nothing\n           return sum(map(abs,arr).*prod(map(sign,arr)))\n\
    \         end\nprod_signs (generic function with 1 method)", "    if length(arr)==0\n\
    \        nothing\n    elseif length(arr)==1\n        abs(arr[1])\n    elseif all(arr[i]\
    \ >= 0 for i in arr) \n        sum(arr) * prod(signs(arr))\n    elseif all(arr[i]\
    \ <= 0 for i in arr)\n        sum(arr) * prod(signs(arr))\n    else\n        nothing\n\
    \    end\nend\n</code>\nThe other possible answer is that it is not even possible,\
    \ i.e. there is no way to tell whether a given number lies between -1 or 1, since\
    \ there are infinitely many numbers between -1 and 1. The only way is checking\
    \ if any of its sign flips:\n<code>", "    if len(arr)==0, return nothing\n  \
    \  s = arr[1]\n    for x in arr[2:end]\n        s = s + (x .* prod([-1,1]))\n\
    \    end\n    return s\nend", "    \n    if length(arr) == 0 return nothing \n\
    \        \n    m = min(arr)\n    \n    for x in arr\n        for y in arr\n  \
    \          if x > y \n                sign = y > m ? 1 : -1\n            else\n\
    \                sign = y > m ? 1 : -1\n            end\n            arr[x] =\
    \ sign\n        end\n    end\n    \n    sum(abs(arr))\nend", "    if arr.is_empty()\
    \ return nothing \n    signs = ones(Int, length(arr))\n    signs.fill(-1) \n \
    \   arr .*= signs\n    return sum(abs2, arr)\nend\n</code>\n<|/ a tags=arrays,julia\
    \ dscore=3 |>\n<| a tags=arrays,julia |>\nMy answer is not as efficient as Dan's,\
    \ but it's still nice to have. I think the following solution is slightly more\
    \ elegant:\n<code>", "    if isempty(arr)\n        nothing\n    else\n       \
    \ prod_signs(tail(arr))*prod(map(sign, arr))\n    end\nend", "    if length(arr)\
    \ == 0\n        return nothing\n    end", "    if arr == []\n        return nothing\n\
    \    end\n    sum = 0\n    for i in arr\n        sum += i\n    end\n    for ele\
    \ in arr\n        if ele != 0\n            sign = ele % 2\n            sum +=\
    \ sign * ele\n        end\n    end\n    sum\nend\n</code>\n<|/ a tags=julia |>\n\
    <| c |>\nNice solution. I had hoped for a solution that didn't require the use\
    \ of two loops.\n<|/ c |>\n<| a |>\nYou can do the job with Julia in a single\
    \ line with broadcasting:\n<code>\njulia> sum(abs.([1 2 -4 -3])) ## sum absolute\
    \ values with broadcasting\n9\n</code>\n<|/ a dscore=1 tags=julia |>\n<| c |>\n\
    Not sure about performance, but `sum(x->abs(x), [1 2 -4 -3])` is even shorter\
    \ :)\n<|/ c |>\n<| c |>\nThat's a nice one. Thank you!\n<|/ c |>\n<| a |>\nAnother\
    \ simple solution using broadcasting and sum:\n<code>\njulia> sum([x for x = 1:3\
    \ if x < 0])\n0", "    if arr == Vector{Int64}(undef) \n        return nothing\
    \ \n    end\n    sign = 1\n    for x in arr\n        if x == 0 \n            continue\
    \ \n        elseif x < 0 \n            sign = -1*sign \n        elseif x > 0 \n\
    \            sign = sign*1\n        end\n    end\n    return sign*sum(abs(arr))\n\
    end", "    signs = map(sign, arr)\n    prod = reduce(*, signs)\n    summag = sum(abs,\
    \ arr)\n    return prod * summag\nend\n</code>\n<|/ a tags=julia,performance |>\n\
    <| c |>\nAwesome answer, thank you very much. I just added a small improvement\
    \ (because I noticed that I was doing it wrong before). You can see the code updated\
    \ here https://gist.github.com/jfelkas/59b27f28dab498abbff54e778af0c641 I also\
    \ added a few tests with other vectors. Again, thank you very much!\n<|/ c |>\n\
    <| c |>\nAwesome, glad it helped. I'm glad you added those tests to your original\
    \ code. I also added an extra `if` statement just to make it clear that `nothing`\
    \ can be returned in a `if` statement.\n<|/ c |>\n<| c |>\nOh, that's interesting,\
    \ I didn't know that you can return `nothing` in a `if` statement. Thanks again!\n\
    <|/ c |>\n<| a tags=julia,performance |>\nI noticed that I was doing it wrong\
    \ before, here is my new code:\n<code>", "    if length(arr) == 0\n        Nothing\n\
    \    elseif length(arr) == 1\n        0\n    else\n        product_signs(arr.map(i->sign(arr[i])).collect{x->-sign(x)*x}\n\
    \                    * arr.map(i->sign(i))\n                    )\n    end\nend",
  "    if length(arr) == 0 return nothing end\n    arr1 = deepcopy(arr)\n    arr2\
    \ = deepcopy(arr)\n    flag = ones(Int64, length(arr))\n    flag = flag .* signs(arr1)\
    \ .* signs(arr2)\n    sum = sum(abs(arr .*flag))\n    nothing\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
