name: HumanEval_153_Strongest_Extension
language: jl
prompt: "\"\"\"You will be given the name of a class (a string) and a vector of extensions.\n\
  \    The extensions are to be used to load additional classes to the class. The\n\
  \    strength of the extension is as follows: Let CAP be the number of the uppercase\n\
  \    letters in the extension's name, and let SM be the number of lowercase letters\
  \ \n    in the extension's name, the strength is given by the fraction CAP - SM.\
  \ \n    You should find the strongest extension and return a string in this \n \
  \   format: ClassName.StrongestExtensionName.\n    If there are two or more extensions\
  \ with the same strength, you should\n    choose the one that comes first in the\
  \ vector.\n    For example, if you are given \"Slices\" as the class and a vector\
  \ of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
  \    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
  \ \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
  , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
  \ extensions::Vector{String})::String \n"
tests: "using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
  Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
  Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
  )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
  , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
  K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
  __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
  YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
  YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"\
  Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"\
  ]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
  )\nend\n"
completions: ["    \n    st=sort(extensions)\n    sm = count(st,lc)\n    cap = count(st,uppercase)\n\
    \    stg=st[1]\n    if sm==cap \n        stg=st[1]\n    elseif sm<cap\n      \
    \  stg=st[end]\n    else \n        stg=st[1]\n    \n    return class_name .\"\
    .\" .stg\n    \nend\n</cell>\n<text>\nWe will now test our extension\nLet's test\
    \ it", "    \n    #TODO: return -1 if the number of extensions is < 2\n    \n\
    \    sorted_extensions = sort(extensions, by = x -> count((x), x), rev=true)\n\
    \    \n    # we get rid of the duplicate extensions, since they will be the strongest\n\
    \    unique, idx = unique(sorted_extensions, by=x -> x)\n    \n    idx = length(sorted_extensions)\
    \ - idx\n    \n    if idx == 0\n        return class_name\n    else\n        return\
    \ class_name .. \".\" .. sorted_extensions[idx] \n    end\n    \nend", "    \n\
    \    if length(extensions)==0 \n        return class_name\n    end\n    \n   \
    \ extensions_sorted = extensions[sortperm(extensions)]\n    \n    strength = -1\
    \ \n    \n    for e in extensions_sorted \n        str = lowerfirst(last(split(e,\"\
    .\")))\n        \n        if strength==-1 || strength>lowerfirst(str) \n     \
    \       strength = lowerfirst(str)\n        end\n    end\n    \n    return join(split(class_name,\
    \ \".\"), [lowercase(class_name), lowercase(strength)]) \nend", "    extensions\
    \ = sort(extensions)\n    \n    number_of_extensions = length(extensions)\n  \
    \  \n    for i=1:number_of_extensions\n        lower_case_extension = lowerCase(extensions[i])\n\
    \        capital_extension_name =  lowerCase(class_name) + capital_letters(lower_case_extension)\n\
    \        \n        if capital_extension_name == class_name\n            \n   \
    \         return capitalize(class_name) + capital_extension_name\n        end\n\
    \    end\n    return capital_extension_name\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test", "    strongest_ext=0\n    for i in extensions \n        if i.isupper()\
    \ && (strongest_ext<0) || (strongest_ext==0 && !i.islower())\n           strongest_ext=i\n\
    \        elseif i.islower() && (strongest_ext>0) || (strongest_ext==0 && !i.isupper())\n\
    \           strongest_ext=i\n        end\n    end\n    return class_name+\".\"\
    +strongest_ext\nend\n</cell>\n<code language=julia-1.5>\n@testset \"Sort extension\
    \ names\" begin\n    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\",\
    \ \"CC\"]) == \"my_class.AA\"\n    @test Strongest_Extension(\"my_class\", [\"\
    Bb\", \"Cc\", \"Dd\"]) == \"my_class.Cc\"\n    @test Strongest_Extension(\"my_class\"\
    , [\"Bb\", \"Dd\", \"Cc\"]) == \"my_class.Dd\"\n    @test Strongest_Extension(\"\
    my_class\", [\"Aa\", \"Be\", \"Cc\"]) == \"my_class.Be\"\n    @test Strongest_Extension(\"\
    my_class\", [\"Aa\", \"Cc\", \"Be\"]) == \"my_class.Be\"\n    @test Strongest_Extension(\"\
    my_class\", [\"aA\", \"Be\", \"Cc\"]) == \"my_class.Be\"\n    @test Strongest_Extension(\"\
    my_class\", [\"aA\", \"Cc\", \"Be\"]) == \"my_class.Be\"\n    @test Strongest_Extension(\"\
    my_class\", [\"Aa\", \"Be\", \"Aa\"]) == \"my_class.Aa\"\n    @test Strongest_Extension(\"\
    my_class\", [\"Aa\", \"Be\", \"Aa\"]) == \"my_class.Aa\"\nend\n</cell>\n<text>\n\
    Part C: Implementing the StrongSort algorithm", "    \n    for i in extensions\
    \ \n        if length(substr_count(i, class_name, 1)) >= 2 \n            return\
    \ class_name*\".\"*take_nth(extensions, min(2, length(substr_count(i, class_name,\
    \ 1))))\n    end\n    return class_name\nend \n</cell>\n<text>\nNow run the cell\
    \ below to test your code. You should be able to pass in any test cases discussed\
    \ in Parts 1 and 2 above.", "    \n    function GetStrongestExtension(class_name,\
    \ extensions)\n        \n        extMap = get_extension_map(class_name)\n    \
    \    \n        strength = [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\n   \
    \     \n        for extension in extensions\n            \n            \n    \
    \        ext = extMap[extension]\n            \n            \n            strength\
    \ = [strength[i] + ext[i] for i in range(len(ext))]\n            \n        end\n\
    \        \n        \n        \n    end\n    \n    \n    if length(strength) ==\
    \ length(extensions)\n    \n        \n        \n        \n        \n        \n\
    \        return join(split(class_name, \".\")[end-1:end], \".\")\n        \n \
    \       \n        \n    end\n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    ", "    if length(\
    \ extensions ) == 0 \n        return class_name\n    extStr = extensions[ findlastindex(extensions)\
    \ ] \n    extCap =  length( split(extStr, '') ) \n    extSm =  length( split(class_name,\
    \ '') ) \n    strength = round( (extCap - extSm) / extCap ) \n    strength = -1\
    \ if strength < 0 else strength \n    \n    if strength == -1 \n        return\
    \ \"$class.$ext\"\n    elseif strength == 1\n        return \"$class.$ext\"\n\
    \    elseif strength == 0 \n        return class_name\n    elseif strength > 1\
    \ \n        extStrs = \"\"\n        for ext in extensions\n            if length(\
    \ split(ext, '') ) == extSm \n                extStrs = \"$class.$ext\"\n    \
    \        end \n        end \n        return extStrs\n    end \nend ", "\"\"\"\
    You will be given the name of a class (a string) and a vector of extensions.\n\
    \    The extensions are to be used to load additional classes to the class. The\n\
    \    strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    \    letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n    in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n    You should find the strongest extension and return a string in this \n\
    \    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions\
    \ with the same strength, you should\n    choose the one that comes first in the\
    \ vector.\n    For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    \    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"", "    \n    \n \
    \   # Initialize variables \n    classname, extensions = lowercase(class_name),\
    \ lowercase(extensions)\n    \n    # Find number of upper case letters in name\
    \ \n    cap_num, cap_sum = 0, 0\n    for i in classname\n        if i.isupper\n\
    \            cap_sum+=1\n        end\n    end", "    \"\"\"Solve the problem!\"\
    \"\"\n    str_ext = \"\"\n    count = 0\n    for ext in extensions\n        if\
    \ lowercase(ext) == lowercase(class_name)\n            count += 1\n          \
    \  str_ext =  str_ext  +  className + \".\"  +  lowercase(ext) \n        end\n\
    \    end\n    if count > 1\n        str_ext = str_ext + \".\" + extensions[count-1]\n\
    \    end\n    return str_ext\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\n\
    \    Strongest_Extension2(class_name::String, extensions::Vector{String})\nReturn\
    \ the strongest extension of class_name and the string in the format\n    ClassName.StrongestExtensionName.\n\
    \    For example, if you are given \"Slices\" as the class and a vector of the\n\
    \    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n \
    \   (its strength is -1).\n    Example:\n    >>> Strongest_Extension2(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    (\"my_class.AA\", \"Slices.SErviNGSliCes\")\n\
    \"\"\"", "    max_length = maximum(extensions)\n    extension = extensions[find(extensions==max_length)[1]]\n\
    \    str = string(\"My\", class_name, \".\", extension)\n    return str\n</code>\n\
    <|/ a tags=sorting,haskell,string,split |>\n<| c |>\nYour solutions work only\
    \ for strings consisting of capital letters and lowercase letters. If you add\
    \ an 'e' at the end of the string you get an exception.\n<|/ c |>\n<| c |>\nOkay,\
    \ thanks. I assumed the requirement was to sort only the capital and lowercase\
    \ letters.\n<|/ c |>\n<| a tags=sorting,haskell,string,split dscore=0 |>\nA simple\
    \ solution:\n<code>\nimport Data.List", "    stength_map =\n        Dict{String,\
    \ Int}()\n    for e in extensions\n        stength_map[e] = length(find(e == uppercase(class_name)))\n\
    \    end", "  strongest_ext=extensions[findfirst(x -> matchall(x->isupper(x),x),extensions)]\n\
    \  if length(strongest_ext)>0\n    strongest_ext=strongest_ext[end]\n  else\n\
    \    strongest_ext=\"\"\n  end\n  return class_name+\".\"+strongest_ext\nend",
  "    \n\"\"\"Write a program that returns the class name and the strongest extension\
    \ if there is a strongest\nextension available. If no extensions are given in\
    \ the arguments and no strongest\nextension is available, return an error message.\n\
    For example, if you are given \"my_class\" as class_name and \"AA\" and \"Be\"\
    \ as extensions, \nthen the program should return \"my_class.AA\", since \"AA\"\
    \ is strongest.\nIf there are two or more extensions with the same strength, you\
    \ should\n    choose the one that comes first in the vector.\n    Example:\n \
    \   >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\
    \n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"BB\"])\n\
    \    \"my_class.BB\"\n    \"\"\"", "  \n    s_extensions = sort(extensions)\n\
    \    s_extension_strength = [length(Char.upper(name)) -length(Char.lower(name))\
    \ for name in s_extensions]\n    \n    idx = (length(s_extensions) - 1) # index\
    \ of strongest extension\n    if s_extension_strength[idx] == 0\n        s_extensions[idx]\
    \ = \"\"\n    end\n    return sprintf(\"%s.%s\",class_name,s_extensions[idx])\n\
    end\n</cell>\n<code language=julia-1.5>\n# Run this cell to test\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"eee\"]) == \"my_class.AA\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"eee\"]) == \"my_class.Be\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.CC\"\n</cell>\n<text>\nSection\
    \ 3: Write a function that takes a vector and finds the maximum element in the\
    \ vector", "    \n    return class_name .+ Base.Strongest(extensions)\nend ",
  "    \n    \n    \n    # write your code in Julia\n    \n    \n    \n    return\
    \ class_name\nend \n</cell>\n<code language=julia-0.6>\n@assert isdefined(main)\
    \ == true\nmain(Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]))\n\
    </cell>\n<text>\n4.3 The Greatest Function", "    return class_name+Strongest_Extension_Name(extensions)\n\
    end\n\"\"\"\nA function that takes two vectors of strings and returns the name\
    \ of the strongest\nextension in each of them. \n\"\"\"", "\t\n\t\n\ts = Strongest_Extension_2(class_name,extensions)\n\
    \tif s==\"\" then return \"no strongest extension\" else return s end\n\t\nend\n\
    \"\"\"\n    Strongest_Extension_2(class_name::String, extensions::Vector{String})\n\
    \    This function returns the name of the strongest extension. The \n    parameter\
    \ <extensions>is assumed to be a vector of string extension \n    names. The function\
    \ returns the name of the strongest extension \n    (the one with the strongest\
    \ strength).\n    \n    @param class_name\n    @param extensions\n    @return\n\
    \    \n    \n    Examples:\n    \n    \n    >>> Strongest_Extension_2(\u201Cmy_class\u201D\
    ,[\u201CAA\u201D, \u201CBe\u201D, \u201CCC\u201D])\n    \u201Cmy_class.AA\u201D\
    \n    \"\"\"", "    \n    extension_count = length(extensions)\n    extension_count\
    \ = find_last(extension_count, extensions => endswith(extension, class_name) ==\
    \ true)\n    extension_count = length(extensions[extension_count])\n    \n   \
    \ strength = 0\n    \n    extname_count = length(extensions)\n    for i = 1:extension_count\n\
    \        extension = extensions[i]\n        ext_count = length(extension)\n  \
    \      strength = strength + (CAP - ext_count) * SM\n    end\n    \n    strength\
    \ = ceil(strength / CAP) * CAP\n    \n    extension_count = find_last(extension_count,\
    \ extensions => endswith(extensions[extension_count], class_name) == true)\n \
    \   extension_count = length(extensions[extension_count])\n    \n    strength\
    \ = strength + (CAP - ext_count) * SM\n    \n    strength = ceil(strength / CAP)\
    \ * CAP\n    \n    extname_count = length(extensions)\n    for i = 1:extension_count\n\
    \        extension = extensions[i]\n        ext_count = length(extension)\n  \
    \      \n        strength = strength + (CAP - ext_count) * SM\n    end\n    \n\
    \    strength = ceil(strength / CAP) * CAP\n    \n    extname_count = length(extensions)\n\
    \    for i = 1:extension_count\n        extension = extensions[i]\n        ext_count\
    \ = length(extension)\n        \n        strength = strength + (CAP - ext_count)\
    \ * SM\n    end\n    \n    strength = ceil(strength / CAP) * CAP\n    \n    extname_count\
    \ = length(extensions)\n    for i = 1:extension_count\n        extension = extensions[i]\n\
    \        ext_count = length(extension)\n        \n        strength = strength\
    \ + (CAP - ext_count) * SM\n    end\n    \n    strength = ceil(strength / CAP)\
    \ * CAP\n    \n    extname_count = length(extensions)\n    for i = 1:extension_count\n\
    \        extension = extensions[i]\n        ext_count = length(extension)\n  \
    \      \n        strength = strength + (CAP - ext_count) * SM\n    end\n    \n\
    \    strength = ceil(strength / CAP) * CAP\n    \n    extname_count = length(extensions)\n\
    \    for i = 1:extension_count\n        extension = extensions[i]\n        ext_count\
    \ = length(extension)\n        \n        strength = strength + (CAP - ext_count)\
    \ * SM\n    end\n    \n    strength = ceil(strength / CAP) * CAP\n    \n    extname_count\
    \ = length(extensions)\n    for i = 1:extension_count\n        extension = extensions[i]\n\
    \        ext_count = length(extension)\n        \n        strength = strength\
    \ + (CAP - ext_count) * SM\n    end\n    \n    strength = ceil(strength / CAP)\
    \ * CAP\n    \n    extname_count = ", "    extensions_strength = Array.fill(length(extensions),\
    \ -1)\n    for i=1:length(extensions)\n        extensions_strength[i] = isUpperCase(extensions[i])-isLowerCase(extensions[i])\n\
    \    end\n    return class_name * Strongest(extensions_strength)[1]\nend\n</cell>\n\
    <code language=julia-0.5>\n@time begin\n    for i=1:100000\n        @time begin\n\
    \            Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n   \
    \     end\n    end\nend\n</cell>\n<text>\nQuestion 3\nThe class function implements\
    \ a simple version of the famous \"Difficulty\" problem. \nThe goal is to decide\
    \ whether a class has \"hard\" or \"easy\" difficulty.\nYou will be given a list\
    \ of difficulty levels and your function should determine \nwhich difficulty level\
    \ is best for the given class.\nThe function should return a string in the following\
    \ format: ClassName.hard, ClassName.easy, ClassName.impossible\nwhere ClassName\
    \ is a string. \nIf the class has no difficulty level, then its return value should\
    \ be \"impossible\".\nExample:\n>>> ClassDifficulty([\"easy\", \"hard\", \"easy\"\
    ])\n    \"my_class.hard\"\n>>> ClassDifficulty([\"easy\", \"hard\", \"easy\",\
    \ \"impossible\"])\n    \"my_class.easy\"\n>>> ClassDifficulty([\"impossible\"\
    , \"easy\", \"hard\", \"easy\"])\n    \"my_class.impossible\"\n>>> ClassDifficulty([\"\
    easy\", \"hard\", \"easy\", \"hard\"])\n    \"my_class.hard\"\n>>> ClassDifficulty([\"\
    easy\", \"hard\", \"easy\", \"easy\"])\n    \"my_class.easy\"\n\"\"\"", "\"\"\"\
    \n    returns the strongest extension (its strength).\n    if there are two or\
    \ more extensions with the same strength, you should\n    choose the one that\
    \ comes first in the vector.\n    For example, if you are given \"Slices\" as\
    \ the class and a vector of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed']\
    \ then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is\
    \ the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"", "  \n\
    \  max_strength = -1\n  best_extension = \"\"", "    strongest_extension=\"\"\n\
    \    for i in 1:length(extensions)\n        capital_letter=extensions[i][1][1]\n\
    \        lower_letter=extensions[i][1][2]\n        strength=-1\n        if isupper(capital_letter)\n\
    \            strength=capital_letter - lower_letter\n        else\n          \
    \  strength=capital_letter - lower_letter + 1\n        end\n        if strength>strongest_extension[1]\n\
    \           strongest_extension=class_name * \".\" * extensions[i][1] * \".\"\
    \ * strongest_extension[1]\n        end\n    end\n    return strongest_extension\n\
    end", "    \n    \n    extension = extensions[findfirst(CAP:SM)(extensions)]\n\
    \    if length(extensions) >1 \n        extension = extensions[findfirst(CAP:SM,\
    \ 2)(extensions)]\n    end\n    \n    return class_name+\".\"+extension\nend",
  "    \n    extensions = sort(extensions) # alphabetical sorting of extensions\n\
    \    \n    Strongest_Extension = extensions[1]\n    \n    Strongest_Extension\
    \ = class_name + Strongest_Extension\n    \n    return Strongest_Extension\n \
    \   \nend\n</cell>\n<code language=julia-1.6>\n@test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n</cell>\n<text>\n(5pt) Finding\
    \ the strongest class by number of extensions\nComplete the function below to\
    \ find the strongest class by number of extensions.\nThis function should return\
    \ the name of the strongest class with maximum number of extensions:\nIf there\
    \ are multiple strongest classes, you should return the one which comes first\n\
    in the vector (for example [\"AA\", \"Be\", \"CC\"]) since 'AA' comes first in\
    \ this\nvector.\nIf the vector is empty, you should return an empty string.\n\
    If there are no strongest classes, you should be returned an empty string.", " \
    \   \n    str_ext = Strongest_Extension(class_name, extensions, 0)\n    if str_ext\
    \ ~= \"\"\n        return class_name._ + str_ext\n    else\n        return str_ext\n\
    \    end\nend\n</cell>\n<text>\nPart III. Challenge\nWrite a Julia function that\
    \ returns the number of characters that should be added to the name of the file\
    \ that you are reading.\nIf the length of the file name is less than or equal\
    \ to the number of characters that should be added to the name of the file, then\
    \ your function should return an empty string.\nIf the length of the file name\
    \ is greater than the number \nof characters that should be added to the name\
    \ of the file, then your function should return a string that contains only characters\
    \ that should be added to the name of the file.\nFor example, if the length of\
    \ the file name is 10, you should return a string containing only the first 5\
    \ characters.\nIf the length of the file name equals the number of characters\
    \ that should be added to the name of the file, then your function should return\
    \ the original file name (no changes).\nIf the length of the file name is not\
    \ equal to the number of characters that should be added to the name of the file,\
    \ then your function should return the first 10 characters of the file name (no\
    \ changes).\nFor a sample run, see the following sample:", "    \n    \nend",
  "        \n    #Your code here\n    strength_map = collect(extensions, (x->(length(x.uppercase)\
    \ - length(x.lowercase))) \n                            |> sort\n            \
    \                |> group_by(&identity)\n                            |> map((x->sort(x)[1]))\
    \ \n                            |> collect)\n    \n    for i in 1:length(extensions)\n\
    \        if strength_map[extensions[i]] == length(extensions[i].lowercase)\n \
    \           return concat(class_name, \".\", extensions[i])\n        end\n   \
    \ end", "  \n    return class_name .. \".\" \n        \n    for extension in extensions\
    \ \n        if length(extension) == length(class_name) - length(extension)\n \
    \           if upper(extension) == upper(class_name)\n                return Strongest_Extension(class_name,\
    \ extensions[1:])\n            else \n                return Strongest_Extension(class_name,\
    \ extensions)\n        end\n    end\nend\n</code>\n<|/ a dscore=0 tags=julia |>\n\
    <| c |>\nThe code you posted doesn't seem to work for the simple test case I used\
    \ (I added it to my original post)\n<|/ c |>\n<| c |>\nI updated my answer with\
    \ your testcase to show that it works. You did not provide an extension for `AA`\
    \ so my code returns the string `my_class.AA`\n<|/ c |>\n<| c |>\nIt works, thank\
    \ you so much! I noticed that the function I posted didn't work for the test case\
    \ I used, so I changed it to work with the new test case I posted (I added it\
    \ to my original post). Do you know why?\n<|/ c |>\n<| c |>\nI have updated the\
    \ answer to take into account your new case\n<|/ c |>\n<| c |>\nThank you so much!\
    \ I noticed that the function I posted didn't work for the test case I used, so\
    \ I changed it to work with the new test case I posted (I added it to my original\
    \ post). Do you know why? I added the new test case to the original post.\n<|/\
    \ c |>\n<| a |>\nHere are two versions (one with regular expressions and one without).\n\
    The regular expression is used to extract the class name and the extension name.\
    \ The extension name is used as the second argument to find the first class with\
    \ the same extension, whose strength is positive. The two classes are then concatenated,\
    \ using the .. operator to concatenate the class name with the extension name.\n\
    The regular expressions also match \"empty\" strings, so the pattern [^.]+.\\\
    2 catches empty extensions as well.\n<code>", "  \n    \n    \"\"\"\n    \n  \
    \  Input: class_name (string), extensions (vector of strings)\n    Output: Strongest\
    \ extension (string)\n    \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    Input:\
    \ class_name (string), extensions (vector of strings)\n    Output: Strongest extension\
    \ (string)\n    \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    Input: class_name\
    \ (string), extensions (vector of strings)\n    Output: Strongest extension (string)\n\
    \    \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    Input: class_name (string),\
    \ extensions (vector of strings)\n    Output: Strongest extension (string)\n \
    \   \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    Input: class_name (string),\
    \ extensions (vector of strings)\n    Output: Strongest extension (string)\n \
    \   \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    Input: class_name (string),\
    \ extensions (vector of strings)\n    Output: Strongest extension (string)\n \
    \   \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    Input: class_name (string),\
    \ extensions (vector of strings)\n    Output: Strongest extension (string)\n \
    \   \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    Input: class_name (string),\
    \ extensions (vector of strings)\n    Output: Strongest extension (string)\n \
    \   \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    Input: class_name (string),\
    \ extensions (vector of strings)\n    Output: Strongest extension (string)\n \
    \   \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    Input: class_name (string),\
    \ extensions (vector of strings)\n    Output: Strongest extension (string)\n \
    \   \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    Input: class_name (string),\
    \ extensions (vector of strings)\n    Output: Strongest extension (string)\n \
    \   \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    Input: class_name (string),\
    \ extensions (vector of strings)\n    Output: Strongest extension (string)\n \
    \   \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    Input: class_name (string),\
    \ extensions (vector of strings)\n    Output: Strongest extension (string)\n \
    \   \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    Input: class_name (string),\
    \ extensions (vector of strings)\n    Output: Strongest extension (string)\n \
    \   \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    Input: class_name (string),\
    \ extensions (vector of strings)\n    Output: Strongest extension (string)\n \
    \   \"\"\"\n    \n    \n", "    \n    if extensions == []\n        return class_name\n\
    \    else\n        idx = 1\n        strength = -1\n        while idx < length(extensions)\n\
    \            uppercase_letters_idx = findall(extensions[idx], uppercase)\n   \
    \         lowercase_letters_idx = findall(extensions[idx], lowercase)\n      \
    \      \n            if (length(uppercase_letters_idx) == 0)\n               \
    \ return strcat(class_name, extensions[idx])\n            elseif (length(lowercase_letters_idx)\
    \ == 0)\n                return strcat(class_name, extensions[idx])\n        \
    \    elseif (length(uppercase_letters_idx) > length(lowercase_letters_idx))\n\
    \                idx = idx + 1\n            else\n                idx = idx -\
    \ 1\n            end\n        end\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\n    Strongest_Extension2(class_name::String, extensions::Vector{String})::String\
    \ \n    \n    More efficient version of Strongest_Extension.\n    \"\"\"", " \
    \   \n    \n    sort!(extensions)\n    \n    strongest = extensions[1]\n    \n\
    \    for e in extensions[2:length(extensions)-1]\n        if strongest < e\n \
    \           strongest = e\n        end\n    end\n    \n    return strongest +\
    \ \".\" + class_name\nend", "    \"\"\"\n    You will be given the name of a class\
    \ (a string) and a vector of extensions.\n    The extensions are to be used to\
    \ load additional classes to the class. The\n    strength of the extension is\
    \ as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"", "    \"\"\"\n    You will be given the name\
    \ of a class (a string) and a vector of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\n    \n    \n    sorted_extensions = sort!(extensions)\
    \ \n    \n    strengths = []\n    for extension in sorted_extensions \n      \
    \  strengths.append(length(extension) - length(filter(x -> x == upper(extension),\
    \ lowers(extension)))) \n    end\n    \n    sort_strengths = sort!(strengths)\n\
    \    \n    Strongest_Extension_name = find_first(x-> x <= sort_strengths[1], SortedNot(sorted_extensions))\n\
    \    return join([\".\", class_name, Strongest_Extension_name])\nend\n</cell>\n\
    <code language=julia-1.5>\n@test Strongest_Extension(\"my_class\", [\"AA\", \"\
    Be\", \"CC\"]) == \"my_class.AA\"\n@test Strongest_Extension(\"my_class\", [\"\
    Be\", \"CC\", \"AA\"]) == \"my_class.Be\"\n</cell>\n<text>\nQuestion 4", "   \
    \ maximum = extensions[length(extensions)]\n    maximum_index = length(extensions)\
    \ \n    for extension in extensions \n        if strongest(extension) == maximum\
    \ \n            maximum = extension \n            maximum_index = length(extensions)\n\
    \        end\n    end\n    return string(class_name, \".\", maximum)\nend", " \
    \   S = sort(extensions)\n    if length(S) > length(extensions)\n        return\
    \ \"\"\n    else\n        return class_name * (length(S) - length(extensions))\n\
    \    end\nend\n</cell>\n<code language=julia-1.6>\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"])\n</cell>\n<text>\nExercise 1\nWrite a function\
    \ that takes a vector of numbers and returns the number of negative elements in\
    \ the vector. Example: \n@test negative_numbers([-1, 1, -2, 3, -4, -5]) == 2",
  "\"\"\"\nYou will be given the name of a class (a string) and a vector of extensions.\
    \ \n    The extensions are to be used to load additional classes to the class.\
    \ \n    The strength of the extension is as follows: Let CAP be the number of\
    \ the \n    uppercase letters in the extension's name, and let SM be the number\
    \ of \n    lowercase letters in the extension's name, the strength is given by\
    \ the \n    fraction CAP - SM. You should find the strongest extension and return\
    \ a string \n    in this format: ClassName.StrongestExtensionName.\n    If there\
    \ are two or more extensions with the same strength, you should\n    choose the\
    \ one that comes first in the vector.\n    For example, if you are given \"Slices\"\
    \ as the class and a vector of the \n    extensions: ['SErviNGSliCes', 'Cheese',\
    \ 'StuFfed'] then you should return \n    'Slices.SErviNGSliCes' since 'SErviNGSliCes'\
    \ is the strongest extension (its \n    strength is -1).\n    Example:\n    >>>\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\
    \n\"\"\"\nend\n</cell>\n<text>\nTest", "    n = length(extensions)\n    Strongest_Extension_str\
    \ = join([\".\", class_name, Strongest_Extension_vec(extensions)[end]], \"\\n\"\
    )\n    return Strongest_Extension_str\nend", "    extensions = sort(extensions)\n\
    \    for e in extensions \n        if e[1...] == class_name\n            return\
    \ sprintf(\"%s.%s\", class_name, e)\n        end\n    end\n    error(\"No extension\
    \ with the class name found.\")\nend ", "    if length( extensions) < 1 then\n\
    \        error(\"You must supply at least one extension\")\n    end", "    if\
    \ extensions.size <= 0\n        error(\"No extensions given for class $class_name\"\
    )\n    end", "    strongest = extensions[findfirst(x -> x.end[1]>x.end[1], extensions)]\n\
    \    idx = findfirst(x -> x.end[1]>x.end[1], extensions)\n    while idx != nothing\n\
    \        idx = findnext(idx -> x.end[1]>x.end[1], extensions)\n        idx = findnext(idx\
    \ -> x.end[1]>x.end[1], extensions, idx)\n        if idx == nothing\n        \
    \    break\n        strongest = extensions.(idx)\n    end\n    return class_name.(strongest)\n\
    end\n</code>\n<|/ a tags=julia dscore=2 |>\n<| c |>\nThanks Dan for your answer.\
    \ Very helpful and useful. Although I did not fully understand how your algorithm\
    \ works, I tried it in my IDE and it works flawlessly. However, I do not understand\
    \ why it works this way. What is the role of the \"findfirst\" function? Why does\
    \ it find the smallest value from the list?\n<|/ c |>\n<| c |>\nI added some comments\
    \ to my answer to explain what each part of the algorithm does.\n<|/ c |>\n<|\
    \ a tags=julia |>\nHere's a very simple way to do it that doesn't require you\
    \ to write any code (apart from the main function), but uses very simple and easy\
    \ to understand syntax.\n<code>", "    sorted_extensions = sort(extensions)\n\
    \    \n    maximum = length(extensions)\n    i = length(sorted_extensions)\n \
    \   while i < maximum do\n        j = maximum - i\n        if maximum == j ||\
    \ length(sorted_extensions) == j\n            i -= 1\n            continue\n \
    \       extension = sorted_extensions[j]\n        if i == 0\n            return\
    \ class_name\n        if length(extension) > length(sorted_extensions[i - 1])\n\
    \            return class_name\n        end\n        i -= 1\n    end\n    return\
    \ class_name\nend", "    \nend\n</cell>\n<text>\nTest your Code", "    \n    #\
    \ create two dictionaries to hold the information of the extension\n    # name\
    \ and the strength of the extension\n    name_extensions_map = Dict()\n    strength_extensions_map\
    \ = Dict()\n    \n    # iterate through the extensions list\n    for extension\
    \ in extensions\n        # get the extension name\n        extension_name = split(extension,\"\
    .\")[1]\n        # check if the extension name is already in the dictionary\n\
    \        if extension_name in name_extensions_map\n            # get the strength\
    \ of the extension\n            strength_extension = split(extension,\".\")[2]\n\
    \            # get the name which has the highest strength\n            max_name_extension\
    \ = max(name_extensions_map[extension_name])\n            # add the strength of\
    \ the extension with the name \n            # which has the highest strength\n\
    \            name_extensions_map[max_name_extension] = strength_extensions_map[extension_name]\
    \ + 1\n        else\n            # add the strength of the extension\n       \
    \     name_extensions_map[extension_name] = 1\n        end\n    end\n    # get\
    \ the key with the maximum strength value\n    max_strength_extension = max(strength_extensions_map.values)\n\
    \    # get the key with the minimum strength value\n    min_strength_extension\
    \ = min(strength_extensions_map.values)\n    # get the key with the highest number\
    \ of letters\n    highest_letters_extension = max(length(name_extensions_map[max_strength_extension]),\
    \ length(name_extensions_map[min_strength_extension]))\n    \n    # return the\
    \ extension\n    return class_name * highest_letters_extension + max_strength_extension\n\
    end\n</cell>\n<text>\nPart C: Extension Methods\nLet's use extension methods to\
    \ create an object that contains all the information of the two classes from before.\
    \ In addition to the methods already defined for the Vectors and Vecors, we have\
    \ defined an add_method method that creates an extension method for the Vectors\
    \ class and one for Vecors.", " \n  extension =  extensions[upper(extensions)\
    \ - lower(extensions)]\n  \n  if length(extensions) > 1\n    strength =  length((upper(extensions)\
    \ - lower(extensions))) / length(extensions)\n    extension = extensions[upper(extensions)\
    \ - lower(extensions)] \n  else\n    strength = -1\n    extension = \"\" \n  end\n\
    \  return \"#{class_name}.#{extension}\" \nend\n</cell>\n<code language=julia-1.5>\n\
    # Test your function", "    strongest_extension = extensions[length(extensions)]\
    \ #pick the last element in the list\n    strongest_extension_strength = strongest_extension.count\
    \ {char(a) in strongest_extension} \n    strongest_extension_strength = strongest_extension_strength\
    \ - 1\n    return strongest_extension + Strongest_Extension(class_name, extensions[2:end])\
    \ #recurse\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\nThe second part of\
    \ this problem is to write a function that returns the extension of a \nstring\
    \ class (given by class_name) with the strongest extension strength. \nInput:\n\
    - class_name: a string containing the name of the class in the format: ClassName.\n\
    - extensions: a vector of strings containing the extensions to the class. \n \
    \ Each extension is in the format: ClassName.ExtensionName.\n  You should return\
    \ in the format: ClassName.StrongestExtensionName.\n- \nOutput:\n- a string containing\
    \ the extension of the class with the strongest extension\n  strength.\n- If there\
    \ are two or more extensions with the same strength, you should\n  choose the\
    \ one that comes first in the vector. \n  For example, if you are given \"Slices\"\
    \ as the class and a vector of\n  the extensions: ['SErviNGSliCes', 'Cheese',\
    \ 'StuFfed'] then you should \n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes'\
    \ is the strongest\n  extension (its strength is -1).\nExample: \n>>> Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"])\n\"my_class.AA\"\n\"\"\"", "    \n    length\
    \ = maximum(map(length, extensions)) + 1\n    \n    strength = -1\n    \n    for\
    \ e in extensions do\n        if e.isupper() then\n            if strength > 0\
    \ \n                strength = -1\n            end\n            if length(class_name)\
    \ - length(e.upper) < strength\n                strength = length(class_name)\
    \ - length(e.upper)\n            end\n        end\n        if e.islower() then\n\
    \            if strength > 0\n                strength = -1\n            end\n\
    \            if length(class_name) - length(e.lower) < strength\n            \
    \    strength = length(class_name) - length(e.lower)\n            end\n      \
    \  end\n    end\n    \n    if strength == -1\n        error(\"Invalid extension\"\
    )\n    else\n        str = class_name .. \".\" .. extensions[findmax(extensions,\
    \ length)]\n    end\n    \n    return str\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\n    Given a vector containing the names of the classes, the vector of\
    \ extensions,\n    and an integer of the number of classes to be chosen, the function\
    \ returns\n    a vector of class names containing the classes with extensions\
    \ that are\n    strongest for the number of classes chosen.\n    For example,\
    \ if you have chosen to choose two classes, the function\n    would return a vector\
    \ of two class names whose extensions are strongest.\n    For example, if you\
    \ have chosen to choose three classes, the function\n    would return a vector\
    \ of three class names whose extensions are strongest.\n    Any other number would\
    \ return a vector of all classes.\n    Example:\n    >>> get_classes_with_farthest_extension(\n\
    \            [\"my_class\", \"my_class\", \"my_class\"], [\"AA\", \"Be\", \"CC\"\
    ],\n            3)\n    [\"my_class.CC\", \"my_class.Be\"]\n    \"\"\"", "   \
    \ \n    \n    \n    \n    ", "    \n    #find strongest extension\n    strength\
    \ = -1\n    for e in extensions\n        if e != \"\"\n            if e[1] ==\
    \ :lower(e[1:2])\n                strength += 1\n            else\n          \
    \      strength -= 1\n        end \n    end\n    return strcat(class_name, \"\
    .\", extensions[strength, 1]) \nend\n</cell>\n<text>\nProblem 4\nWrite a function,\
    \ Strongest_Extensions, that takes as input a vector of strings and returns a\
    \ vector of strings.\nThe function should return an array of strings in the following\
    \ format:\n    StrongestExtension(class_name::String, extensions::Vector{String})::String\n\
    The first string in the return vector should be the name of the class (a string).\
    \ The other \n    strings in the return vector should be the names of the strongest\
    \ extensions \n    (a vector of strings).\n    The function should return an array\
    \ of strings in the following format:\n        [StrongestExtension(class_name::String,\
    \ extensions::Vector{String})::String, ...]\nExamples:\n    >>> Strongest_Extensions([\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]])\n    [\"my_class.AA\", \"my_class.Be\"\
    , \"my_class.CC\"]\n    >>> Strongest_Extensions([\"my_class\", [\"AA\", \"Be\"\
    , \"CC\"], \"my_class\", [\"DD\", \"EE\", \"FF\"]])\n    [\"my_class.AA\", \"\
    my_class.Be\", \"my_class.CC\", \"my_class.DD\", \"my_class.EE\", \"my_class.FF\"\
    ]\n    \"\"\"", "    \n    length = extensions.length\n    strongest_ext = \"\"\
    \n    \n    if length == 1\n        \n        if contains(extensions, class_name)\n\
    \            \n            if length(class_name) == length(extensions[0])\n  \
    \              return class_name\n            else \n                length2 =\
    \ length(extensions[1])\n                if length2 < length\n               \
    \     return class_name\n                else\n                    return class_name\
    \ + \"_\" + extensions[1]\n            end\n        else\n            return class_name\n\
    \        end\n    end\n    \n    \n    for e in extensions \n        \n      \
    \  if length2 == length\n            \n            if contains(extensions, e)\n\
    \                \n                if length(class_name) == length(extensions[0])\n\
    \                    return class_name\n                else \n              \
    \      length2 = length(extensions[1])\n                    if length2 < length\n\
    \                        return class_name\n                    else\n       \
    \                 return class_name + \"_\" + extensions[1]\n                \
    \    end\n                end\n            else\n                return class_name\n\
    \            end\n        else\n            \n            if length2 < length\n\
    \                strongest_ext = class_name + \"_\" + e\n                return\
    \ strongest_ext\n            else\n                length2 = length(extensions[1])\n\
    \                if length2 < length\n                    strongest_ext = class_name\
    \ + \"_\" + e\n                    return strongest_ext\n                else\n\
    \                    strongest_ext = class_name + \"_\" + e + \"_\" + extensions[1]\n\
    \                    return strongest_ext\n                end\n            end\n\
    \        end\n    end\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\nThe extension_strength\
    \ function finds the strongest extension in a class name \nand returns the extension\
    \ name. The strength of an extension is defined by \nthe fraction CAP - SM, where\
    \ CAP is the number of uppercase letters in the \nextension's name, SM is the\
    \ number of lowercase letters in the extension's \nname, and SM is the number\
    \ of lowercase letters in the extension's name. The", "    s = \"\"\n    for ext\
    \ in extensions\n        if Strongest_Extension_Strength(class_name) == Strongest_Extension_Strength(ext)\n\
    \            s = ext # Found a better extension\n        end\n    end\n    \n\
    \    return s\nend", "    n = length(extensions)\n    if n < 2 \n        return\
    \ class_name\n    end\n    \n    s = length(upper(extensions))\n    if s > n\n\
    \        return class_name\n    end\n    \n    \n    for e in extensions\n   \
    \     s = length(lower(e))\n        if s > n\n            return class_name\n\
    \        end\n    end\n    \n    \n    return strcat(class_name, extensions[findfirst(extensions,\
    \ s)])\nend\n</cell>\n<code language=julia-1.5>\n@time Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"])\n</cell>\n<text>\nQuestion 4.2\nWrite a\
    \ function called Load_Class that, given a class name and a vector of extensions\n\
    \    loads the extensions into the class. The name of each extension should be\
    \ \n    given in the following format: extension_name.extension.\n    The function\
    \ should return the newly loaded class.\n    Example:\n    >>> Load_Class(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"", "    \n    Strength_Vector\
    \ = Vector{Int64}()\n    for extension in extensions \n        Strength_Vector[toupper(extension)-tolower(extension)]\
    \ = 1 \n    end\n    \n    Strength_Vector = sort(Strength_Vector)\n    Strength\
    \ = Strength_Vector[1]\n    \n    if length(Strength_Vector) > 1\n        \n \
    \       minimum = min(Strength_Vector)\n        minimum2 = minimum\n        \n\
    \        for element in Strength_Vector\n            if element == minimum\n \
    \               minimum2 =element \n            end\n        end\n        \n \
    \       \n        for element in Strength_Vector\n            if element == minimum2\n\
    \                minimum2 = element \n            end\n        end\n        \n\
    \        \n        Strength_Vector[Strength_Vector .!= minimum2] = minimum2 \n\
    \        \n    end\n    \n    \n    for element in Strength_Vector\n        \n\
    \        if element != minimum2\n            if element != minimum\n         \
    \       return concat!(class_name, \".\", minimum2)\n            else\n      \
    \          return concat!(class_name, \".\", minimum)\n            end\n     \
    \   else\n            return concat!(class_name, \".\", element)\n        end\n\
    \    end\n    \n    return \"no_extension\"\nend\n</cell>\n<text>\nLet's test\
    \ the function by writing a test first:", "    \n    \n    \nend", "    \"\"\"\
    Your task is to find the strongest extension among the given extensions.\"\"\"\
    \n    \n    extensions_set = Set{String}(extensions)\n    \n    strongest_extension\
    \ = extensions_set[argmax(extensions_set)]\n    \n    return strongest_extension\n\
    end", "  \n    str = join(extensions, '.')\n    strength = count(replace(str,\
    \ lowercase(class_name)..., '_'), uppercase(class_name)...)\n    \n    if strength\
    \ == length(extensions)\n        str = class_name\n    else\n        str = class_name\
    \ + Strongest_Extension(lower!(class_name), extensions)\n    end\n    \n    return\
    \ str\nend", "    extensions.sort!() \n    extensions.reverse!()\n    \n    Strongest_Extension\
    \ = class_name \n    for ext in extensions\n        if Strongest_Extension !=\
    \ ext\n            Strongest_Extension = class_name + Strongest_Extension + ext\n\
    \            break\n    end\n    return Strongest_Extension\nend", "    \"\"\"\
    \n    Strongest_Extension(class_name, extensions)", "    \n    # Write your code\
    \ here.\n    \nend\n</cell>\n<code language=julia-1.5>\n@assert @isdefined Strongest_Extension\n\
    </cell>\n<code language=julia-1.5>\n# run this cell to test your code\n@testset\
    \ \"strongest_extension Test\" begin\n    test(Strongest_Extension)\nend\n</cell>\n\
    <text>\n3. Implement a function that will compute the total number of extensions\
    \ (strings) that belong to the class. Write a function extension_count, that takes\
    \ two arguments: a string class name and a list of extensions. You should return\
    \ a vector of integers. Each element of this vector should contain the number\
    \ of extensions that belong to the class represented by the string argument class_name,\
    \ e.g. \"my_class\" will return a vector of [3, 3] because there are 3 extensions\
    \ in the list [\"AA\", \"Be\", \"CC\"], 2 of them are \"AA\" and \"CC\".", " \
    \   # Write your code here\n    # Write your code here\n    \n    return extensions[length(extensions)\
    \ div 2]\nend\n</cell>\n<text>\nTask 3\nFor each of the following strings, return\
    \ the length of the longest extension, starting with the one that comes first.\n\
    Examples:\n    String      Returned value\n    \"abc\"        2\n    \"bcd\" \
    \       1\n    \"abe\"        2\n    \"abc def\"    3\n    \"abc def gh\"   4\n\
    \    \"abcdef\"     5\n    \"aBcDeF\"     5\n    \"abc defg\"   5\n    \"ab def\"\
    \     5\n    \"abc def g\"  5\n    \"abcdefg\"    5\n    \"abcdefg \"   5\n  \
    \  \"abc defg \" 5\n    \"abc def g\" 5\n    \"abc defg \" 5\n    \"abcdefg i\"\
    \ 5\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"\
    abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\"\
    \ 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"\
    abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\"\
    \ 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"\
    abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\"\
    \ 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"\
    abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\"\
    \ 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"\
    abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\"\
    \ 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"\
    abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh ",
  "    \n    \n    Strongest_Extension = extensions[extensions[length] == length(extensions)]\
    \ \nend\n</cell>\n<text>\nQuestion 3\nImplement the method get_class_extension()\
    \ below. It takes a class name (a string) as input and returns the extension that\
    \ is best suited for that class.\nThe extension should be loaded from the extensions\
    \ vector that you have provided in the cell above (it is provided as a vector\
    \ in cell 6).", "\"\"\"\n    Strongest_Extension(class_name, extensions)\n   \
    \ \n    Write a function which returns the strongest extension of a given \n \
    \   class. The name of a class is a string, the extensions are to be used \n \
    \   as strings. The strength of the extension is as follows: Let CAP be \n   \
    \ the number of uppercase letters in the extension's name, and let SM be \n  \
    \  the number of lowercase letters in the extension's name, the strength \n  \
    \  is given by the fraction CAP - SM. You should find the strongest extension\n\
    \    and return a string in this format: ClassName.StrongestExtensionName.\n \
    \   If there are two or more extensions with the same strength, you should \n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the \n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest \n    extension (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n\"\"\"\n    return class_name * Strongest(extensions)\n\
    end ", "    \n    for i in extensions \n        idx = find_first_index(extensions,\
    \ i) \n        if idx != -1 \n            if (extensions[idx] == i) \n       \
    \         extensions[idx] = -1 \n            else \n                extensions[idx]\
    \ = i \n            end \n        end \n    end\n    \n    if extensions.count\
    \ > 0 \n        idx = find_first_index(extensions, -1) \n        if idx != -1\
    \ \n            idx = extensions.count \n            extensions[idx] = \"\" \n\
    \        end \n    end\n    \n    return class_name+\".\"+extensions[find_first_index(extensions,\
    \ -1)]\nend", "    \n    map1=Dict(zip(extensions,map(1:length(extensions),extensions)))\n\
    \    map2=Dict(zip(map1.values,map(1:length(map1.values),map1.values)))\n    \n\
    \    \n    map3=Dict(zip(map1.values,map1.keys))\n    \n    for (k,v) in map3.values()\n\
    \        if map2[v] >map2[k]\n            map2[k]=v\n        else\n          \
    \  map2[v]=k\n        end\n    end\n    \n    \n    \n    map3=Dict(zip(map1.values,map(map2[v],map1.values)))\n\
    \    \n    for (k,v) in map3.values()\n        if map2[v] >map2[k]\n         \
    \   map2[k]=v\n        else\n            map2[v]=k\n        end\n    end\n   \
    \ \n    \n    strongest_extension=map3[max(map2.values())]\n    \n    return class_name+\"\
    .\"+strongest_extension\nend\n</cell>\n<code language=julia-1.5>\n#export\n\"\"\
    \"\n    Strength(name::String)", "    \n    # define the extensions dictionary\n\
    \    extensions_dict = {}\n    for extension in extensions\n        # split the\
    \ extension into its lower and upper case letters\n        lower_extension = extension.toLowerCase()\n\
    \        upper_extension = extension.toUpperCase()\n        # check if the extension\
    \ is in the dictionary already\n        if lower_extension in extensions_dict\n\
    \            # increment the count for the extension\n            extensions_dict[lower_extension]\
    \ += 1\n        else\n            # add the extension to the dictionary\n    \
    \        extensions_dict[lower_extension] = 1\n    end\n    # define the strength\
    \ of a given extension\n    strength = length(extensions_dict)\n    # calculate\
    \ the strongest extension\n    strongest = \"\"\n    for key, value in extensions_dict\n\
    \        if value == strength\n            # save the strongest extension\n  \
    \          strongest = key\n        end\n    end\n    return class_name * \".\"\
    \ .* strongest \nend\n</cell>\n<text>\n3.3 Exercise: Finding Most Probable Errors\n\
    In a previous exercise, you loaded the data into a DataFrame:", "    extensions\
    \ = sort(extensions)\n    extension_strengths = zeros(length(extensions))\n  \
    \  for (i,extension) in enumerate(extensions)\n        extension_strengths[i]\
    \ = length(extension) - length(upper(extension))\n    end\n    \n    index = findall(extension_strengths\
    \ .> 0)[1]\n    extension_strengths[index] = -1\n    \n    return class_name*String(join(extensions,\"\
    .\"))\nend", "\"\"\"\n    Extension name with strongest extension\n\"\"\"\n  \
    \  s_extension = extensions[findmin(extensions)]\n    return strcat(class_name,\
    \ s_extension)\nend\n</cell>\n<code language=julia-1.6>\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]) \u2248 \"my_class.AA\"\n@test Strongest_Extension(\"\
    my_class\", [\"ab\", \"be\", \"cc\"]) \u2248 \"my_class.ab\"\n@test Strongest_Extension(\"\
    my_class\", [\"ab\", \"Be\", \"CC\"]) \u2248 \"my_class.Be\"\n@test Strongest_Extension(\"\
    my_class\", [\"Ab\", \"Be\", \"CC\"]) \u2248 \"my_class.Ab\"\n@test Strongest_Extension(\"\
    my_class\", [\"ab\", \"Be\", \"cc\"]) \u2248 \"my_class.ab\"\n@test Strongest_Extension(\"\
    my_class\", [\"AB\", \"Be\", \"cc\"]) \u2248 \"my_class.AB\"\n@test Strongest_Extension(\"\
    my_class\", [\"ab\", \"be\", \"CC\"]) \u2248 \"my_class.ab\"\n@test Strongest_Extension(\"\
    my_class\", [\"ab\", \"Be\", \"cC\"]) \u2248 \"my_class.ab\"\n@test Strongest_Extension(\"\
    my_class\", [\"ab\", \"Be\", \"CC\"]) \u2248 \"my_class.AB\"\n@test Strongest_Extension(\"\
    my_class\", [\"AB\", \"Be\", \"cC\"]) \u2248 \"my_class.AB\"\n@test Strongest_Extension(\"\
    my_class\", [\"AB\", \"Be\", \"CC\"]) \u2248 \"my_class.AB\"\n@test Strongest_Extension(\"\
    my_class\", [\"Ab\", \"Be\", \"cC\"]) \u2248 \"my_class.AB\"\n@test Strongest_Extension(\"\
    my_class\", [\"ab\", \"Be\", \"CC\"]) \u2248 \"my_class.ab\"\n@test Strongest_Extension(\"\
    my_class\", [\"ab\", \"Be\", \"cC\"]) \u2248 \"my_class.ab\"\n@test Strongest_Extension(\"\
    my_class\", [\"Ab\", \"Be\", \"CC\"]) \u2248 \"my_class.Ab\"\n@test Strongest_Extension(\"\
    my_class\", [\"AB\", \"Be\", \"cC\"]) \u2248 \"my_class.AB\"\n@test Strongest_Extension(\"\
    my_class\", [\"AB\", \"Be\", \"CC\"]) \u2248 \"my_class.AB\"\n@test Strongest_Extension(\"\
    my_class\", [\"ab\", \"Be\", \"CC\"]) \uFFFD", "  \n    strength_map=HashMap{Int,\
    \ String}()\n    for i in 1:length(extensions)\n        strength_map[i+1] = extensions[i]\n\
    \    end\n    \n    for i in 1:length(class_name)\n        strength = strength_map[i+1]\n\
    \        if !(strength in strength_map)\n            strength = -1\n        end\n\
    \        class_name = strcat(class_name, strength_map[i+1] )\n    end\n    \n\
    \    return class_name\nend", "    strongest_extension = extensions[1]\n    for\
    \ extension in extensions[2:length(extensions)]\n        if lowercase(extension)\
    \ == lowercase(strongest_extension)\n            strongest_extension = extension\n\
    \        end\n    end\n    return class_name * \".\" .* strongest_extension\n\
    end\n</cell>\n<text>\nQuestion 4\nNow implement a function called Strongest_Extensions\
    \ that takes a vector of extensions\n    (e.g. [\"AA\", \"Be\", \"CC\"]) and returns\
    \ the strongest extensions (e.g \"AA\")\n    in that order.\n    Example:\n  \
    \  >>> Strongest_Extensions([\"AA\", \"Be\", \"CC\"])\n    [\"AA\"]\n    \"\"\"",
  "    strength_sorted = sort(-extensions)\n    \n    strength_sorted_index = findfirst(x->x.name\
    \ == strength_sorted[1], extensions)\n    return class_name..\".\"..extensions[strength_sorted_index]\n\
    end ", "    StrongExtension(class_name, extensions)[1]\nend", "    \n    \n  \
    \  \n\"\"\"\n    Using the extensions, find the name of the class with the highest\
    \ strength\n\"\"\"", "    \n    ext::String = \"\"\n    \n    for ext in extensions\
    \ \n        if (cap_count (ext) == strongest_count) (ext::String)\n    end\n \
    \   return class_name::String\nend", "  \n    # your code goes here", "    return\
    \ class_name + Strongest_ExtensionName(extensions) \nend ", "    str_score = 0\n\
    \    for e in extensions\n        if e == class_name\n            str_score -=\
    \ 1\n        elseif e == class_name & lowercase(str_score) != lowercase(str_score)\
    \ \n            str_score += 1\n        end\n    end\n    index = findall(extensions,\
    \ e -> e == class_name & lowercase(str_score) == lowercase(str_score))\n    str_score\
    \ > 0 ? extensions[index[1]] : \"\"\nend\n</cell>\n<text>\nQuestion 2.2\nWrite\
    \ a function that returns the class name and extension of any class in the extensions.\
    \ \nThe extensions are to be used to load additional classes to the class. \n\
    The strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    \    letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n    in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n    You should find the strongest extension and return a string in this \n\
    \    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions\
    \ with the same strength, you should\n    choose the one that comes first in the\
    \ vector.\n    For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    \    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"", "    \"\"\"This\
    \ function takes in an extension's class name and vector extensions and returns\
    \ the\n    extension with stronger extension. \n    \"\"\"\n    \n    \n    #\
    \ Initialize variables and set defaults\n    strength = 0\n    strongest_extension\
    \ = \"\"", "    \n    \nend\n</cell>\n<code language=julia-0.6>\n@testset \"Extension\
    \ Tests\" begin\n    \n    @test Strongest_Extension(\"my_class\", [\"AA\", \"\
    Be\", \"CC\"]) \n    == \"my_class.AA\"\n    \n    @test Strongest_Extension(\"\
    my_class\", [\"Be\", \"AA\", \"CC\"]) \n    == \"my_class.Be\"\n    \n    @test\
    \ Strongest_Extension(\"my_class\", [\"CC\", \"AA\", \"Be\"]) \n    == \"my_class.CC\"\
    \n    \n    @test Strongest_Extension(\"my_class\", [\"CC\", \"Be\", \"AA\"])\
    \ \n    == \"my_class.CC\"\n    \n    @test Strongest_Extension(\"my_class\",\
    \ [\"CC\", \"AA\", \"Be\", \"GG\"]) \n    == \"my_class.CC\"\n    \n    @test\
    \ Strongest_Extension(\"my_class\", [\"CC\", \"GG\", \"AA\", \"Be\"]) \n    ==\
    \ \"my_class.CC\"\n    \n    @test Strongest_Extension(\"my_class\", [\"CC\",\
    \ \"GG\", \"Be\", \"AA\"]) \n    == \"my_class.CC\"\n    \n    @test Strongest_Extension(\"\
    my_class\", [\"CC\", \"GG\", \"Be\", \"CC\"]) \n    == \"my_class.CC\"\n    \n\
    \    @test Strongest_Extension(\"my_class\", [\"CC\", \"GG\", \"Be\", \"CC\",\
    \ \"AA\"]) \n    == \"my_class.CC\"\n    \n    @test Strongest_Extension(\"my_class\"\
    , [\"CC\", \"GG\", \"Be\", \"CC\", \"CC\"]) \n    == \"my_class.CC\"\n    \n \
    \   @test Strongest_Extension(\"my_class\", [\"CC\", \"GG\", \"Be\", \"CC\", \"\
    CC\", \"AA\"]) \n    == \"my_class.CC\"\n    \n    @test Strongest_Extension(\"\
    my_class\", [\"CC\", \"GG\", \"Be\", \"CC\", \"CC\", \"CC\"]) \n    == \"my_class.CC\"\
    \n    \n    @test Strongest_Extension(\"my_class\", [\"CC\", \"GG\", \"Be\", \"\
    CC\", \"CC\", \"CC\", \"AA\"]) \n    == \"my_class.CC\"\n    \n    @test Strongest_Extension(\"\
    my_class\", [\"CC\", \"GG\", \"Be\", \"CC\", \"CC\", \"CC\", \"CC\"]) \n    ==\
    \ \"my_class.CC\"\n    \n    @test Strongest_Extension(\"my_class\", [\"CC\",\
    \ \"GG\", \"Be\", \"CC\", \"CC\", \"CC\", \"CC\", \"AA\"]) \n    == \"my_class.CC\"\
    \n    \n    @test Strongest_Extension(\"my_class\", [\"CC\", \"GG\", \"Be\", \"\
    CC\", \"CC\", \"CC\", \"CC\", \"CC", "    \n    \nend\n    \n    \n\"\"\"\n  \
    \  \n    \n    \n    \n\"\"\"\n    \n    \n    \n    \n\"\"\"\n    ", "    # Write\
    \ your code here\n    \n    return \"\"\nend ", "    extension_strength = Vector{Int}(Int[],\
    \ 0)\n    for i in extensions\n        extension_strength[i] = isupper(i) - islower(i)\n\
    \    end", "    \n    if length(extensions) == 0\n        throw(ArgumentError(\"\
    The extensions vector should not be empty\"))\n    end\n    \n    exts = sort(extensions)\n\
    \    \n    ext_count = zeros(length(exts),2)\n    ext_count[:,1] = 1:length(exts)\n\
    \    \n    for i in exts\n        ext_count[i,1] += 1\n    end\n    \n    sorted_extensions\
    \ = sort!(ext_count)\n    \n    sorted_extensions = reverse(sorted_extensions)\n\
    \    \n    sorted_extensions = sorted_extensions[2:end]\n    \n    sorted_exts\
    \ = zeros(length(sorted_extensions),1)\n    \n    for i in 1:length(sorted_extensions)\n\
    \        if sorted_extensions[i,1] == sorted_extensions[i-1,1]\n            sorted_exts[i,1]\
    \ = sorted_extensions[i-1,1]\n        else\n            sorted_exts[i,1] = sorted_extensions[i,1]\n\
    \        end\n    end\n    \n    if length(sorted_exts) > 0\n        extension_strength\
    \ = sorted_exts[length(sorted_exts)]\n    else\n        extension_strength = -1\n\
    \    end\n    \n    \n    strongest_ext = extensions[sorted_extensions[1,1]]\n\
    \    \n    return string(class_name)+\".\"+strongest_ext\nend\n</cell>\n<code\
    \ language=julia-1.5>\nStrongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n</cell>\n<text>\nWrite a function, Strongest_Extensions, that takes two parameters:\
    \ a string name\nand a vector of extensions. The function should return a vector\
    \ containing the\nnames of the strongest extensions in the vector. \nFor instance:\n\
    >>> Strongest_Extensions(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n[\"my_class.AA\"\
    , \"my_class.Be\", \"my_class.CC\"]\n</text>\n<code language=julia-1.5>", "  \
    \  extension_strenght = [len(e) - 1 for e in extensions]\n    extension_strength\
    \ = sum(extension_strenght)\n    if extension_strength > 0 \n        extension_strength\
    \ \n    else\n        extension_strenght[argmax(extension_strenght)]\n    end\n\
    end", "    for e in extensions \n        if uppercase(e) - lowercase(e) < length(class_name)\
    \ - length(replace(e, '_', '')) \n            return stringcat(class_name, e)\
    \ \n        end \n    end\nend\n</cell>\n<code language=julia-1.0>\n@assert @test_cases\
    \ Strongest_Extension(\"Slice\", [\"ABSli\", \"CCSli\", \"DD\"]) \u2248 \"Slices.ABSli\"\
    \n@assert @test_cases Strongest_Extension(\"Slice\", [\"ABSli\", \"CCSli\", \"\
    DD\"]) \u2248 \"Slices.CCSli\"\n@assert @test_cases Strongest_Extension(\"Slice\"\
    , [\"ABSli\", \"CCSli\", \"DD\"]) \u2248 \"Slices.DD\"\n@assert @test_cases Strongest_Extension(\"\
    Slice\", [\"ABSli\", \"CCSli\", \"DD\"]) \u2248 \"Slices.ABSli\"\n@assert @test_cases\
    \ Strongest_Extension(\"Slice\", [\"ABSli\", \"CCSli\", \"DD\"]) \u2248 \"Slices.ABSli\"\
    \n</cell>\n<text>\nPart 6: Implementing The Adjacent Rule", "    for ext in extensions\
    \ \n        if lower(ext) \u2209 lower(class_name) \n            return class_name\
    \ .. \".\" .. ext \n    else \n        return class_name \nend\n</cell>\n<code\
    \ language=julia-1.3>\n# TEST STRONGEST EXTENSION (5) (TO DO: FIND SOME TESTS)\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n</cell>\n<text>\nExercise 4\nWrite a function that returns a vector of tuples\
    \ (class_name, extension_strength).\nThe tuples should be of the form: (class_name,\
    \ extension_strength). For example, if\nthe given class is \"Slices\" and extensions\
    \ are [\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"]\nthen the function should return\
    \ a vector of tuples\n[(\"Slices\", -1), (\"Slices\", 1), (\"Slices\", -1)]\n\
    Example: \n>>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) ==\
    \ [(\"Slices\", -1), (\"Slices\", 1), (\"Slices\", -1)]\n[ (Slices,-1) (Slices,\
    \ 1) (Slices, -1)]\n\"\"\"", "    l = length(extensions)\n    \n    stext=String[]\n\
    \    for i =1:length(extensions)\n        stext[i] = class_name..\".\"..extensions[i]\n\
    \    end", "    strongest_extension = extensions[findfirst(a => a > 0, map(x =>\
    \ toupper(x) - tolower(x), extensions))]\n    \"$class_name.$strongest_extension\"\
    \nend\n</code>\n<|/ a |>\n<| c |>\nThanks for the help. I was looking at the `findfirst`\
    \ method but I was having difficulty finding documentation on how it worked. I\
    \ was confused about the syntax and how the function works. ", "  \n  num_upper\
    \ = length(findall(x -> isupper(x), extensions))\n  num_lower = length(findall(x\
    \ -> islower(x), extensions))\n  \n  if num_upper - num_lower <= 0 \n    # all\
    \ extensions are lower case or all extensions are upper case\n    Strongest_Extension\
    \ = class_name\n  elseif num_upper == 0\n    # all extensions are upper case\n\
    \    Strongest_Extension = class_name \n  else\n    # some extensions are upper\
    \ case, some are lower case\n    Strongest_Extension = strcat(class_name, Strongest_Extension(extensions[num_upper],\
    \ extensions[num_lower]))\n  end\n  return Strongest_Extension\nend\n</cell>\n\
    <text>\nLet's test out our function on the three examples you provided.", "  \
    \  \n    # Write your code here\n    \n    return \"\"\nend\n</cell>\n<text>\n\
    Solution\nRun the cell below to check your solution.", "    \n    strength = zeros(Int,\
    \ length(extensions))\n    for i = 1:length(extensions)\n        pos = findfirst(isupper(extensions[i]),\
    \ tolower(extensions[i]))\n        \n        if pos == nothing\n            error(\"\
    Extension name does not follow the pattern: CAPS\")\n        elseif pos != length(extensions[i])\n\
    \            error(\"Extension name does not follow the pattern: CAPS\")\n   \
    \     end", "    \n    extension_strength = 0\n    \n    for i in 1:length(extensions)\n\
    \        \n        # split the extension in lowercase letters\n        lowercase_extension\
    \ = split(extensions[i])[1]\n        \n        # split the class name\n      \
    \  lowercase_class_name = split(class_name)[1]\n        \n        # obtain the\
    \ number of uppercase letters\n        uppercase_letters = count(lowercase_extension)\n\
    \        \n        # obtain the number of lowercase letters\n        lowercase_letters\
    \ = count(lowercase_extension, lowercase_letters)\n        \n        # obtain\
    \ the number of letters in the extension's name\n        extension_letters = count(lowercase_extension)\n\
    \        \n        # obtain the strength of the extension\n        strength =\
    \ uppercase_letters - lowercase_letters\n        \n        # check if an extension\
    \ is with the same strength\n        if(extension_strength == 0)\n           \
    \ extension_strength = strength\n        elseif(extension_strength != strength)\n\
    \            \n            # find the extension with more letters first\n    \
    \        if(extension_strength > strength)\n                extension_strength\
    \ = extension_strength\n            else\n                extension_strength =\
    \ strength\n        end\n    end\n    \n    # return the class name with the strongest\
    \ extension\n    str = split(class_name)[1]\n    return str .concat(\".\") .concat(extension_strength)\n\
    end", "    \n    \n    \n    if length(extensions)<1\n        error(\"No extensions\
    \ to load to class with name '$class_name'\")\n    end\n    \n    extension_class=join(extensions,\"\
    .\")\n    \n    \n    \n    #Find a Strongest extension", "    Strongest_Extension_Helper(class_name,\
    \ extensions, 0)\nend", "    Strongest_Extension_Helper(class_name, extensions)\n\
    end", "  \n  strongest_extension_index  = argmax( lengths(extensions) )\n  strongest_extension\
    \        = extensions[strongest_extension_index]\n  strongest_extension_strength\
    \ = length(strongest_extension)\n  \n  return \"$class_name.$strongest_extension_strength\"\
    \ \nend\n</cell>\n<code language=julia-1.5>", "    \n    \n    if extensions.is_empty\n\
    \        return class_name\n    end\n    \n    \n    Strength = 0\n    for extn\
    \ in extensions\n        Strength += length(extn)\n    end\n    \n    \n    if\
    \ Strength == 0\n        return class_name\n    end\n    \n    \n    if Strength\
    \ == 1\n        return extensions[1]\n    end\n    \n    \n    if Strength > length(extensions)\n\
    \        return class_name\n    end\n    \n    \n    \n    \n    \n    \n    \n\
    \    for extn in extensions\n        if startswith(extn, class_name)\n       \
    \     return class_name\n        end\n    end\n    \nend", "    \n    strongest,\
    \ strongest_strength = 0, -1 #initialize strongest and strongest_strength to default\
    \ values\n    strongest_strength =  -1\n    for e in extensions #loop through\
    \ all extensions to get strongest strength \n        if e == Strongest(class_name)\
    \ #if the extension is the strongest \n            strongest_strength = Strongest(class_name)\n\
    \            strongest = e\n        else #if extensions strength isn't the strongest\
    \ \n            if Strongest(class_name) != strongest_strength #if the extensions\
    \ strength is strongest \n                strongest_strength = Strongest(class_name)\n\
    \                strongest = e #reset the strongest to its current value\n   \
    \         else #if extensions strength is not the strongest \n               \
    \ if Strongest(class_name) < strongest_strength #if the extensions strength is\
    \ lower \n                    strongest_strength = Strongest(class_name) #set\
    \ the strongest strength to the current extension\n                    strongest\
    \ = e #set the strongest to its current extension\n    end\n    return strongest\
    \ #return string in above format\nend\n</cell>\n<code language=julia-1.0>\n@time\
    \ strongest_extension = Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"\
    CC\"])\n</cell>\n<code language=julia-1.0>\nstrongest_extension\n</cell>\n<code\
    \ language=julia-1.0>", "    \n    str = strcat(name, Strongest_Extension_name(extensions))\
    \ \n    if any(str==x for (x \u2208 extensions)) \n            then  \n      \
    \  str = strcat(class_name, Strongest_Extension_name(extensions)) \n    end",
  " \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    if extensions ==\
    \ []\n        return class_name\n    else\n        sorted = sort(extensions, by\
    \ = x -> length(x)-length(x));\n        sorted_extensions = copy(sorted);\n  \
    \      strength = -1;\n        strength_index = 0;\n        for i in sorted do\
    \ \n            if i == extensions[strength_index] \n                strength\
    \ = strength_index\n            else\n                strength_index = strength_index\
    \ + 1\n            end\n        end\n        return class_name + \".\" + sorted_extensions[strength]\n\
    \    end\nend\n</cell>\n<code language=julia-1.4>\n\"\"\"\n    TestExamples()\n\
    \    Tests the Strongest_Extension function using various test cases\n    \n \
    \   Parameters: \n    None\n    \n    Returns:\n    None\n    \n    Remarks:\n\
    \    Prints the given test cases one-by-one to the screen and verifies the correct\
    \ \n    answer\n    \n    Usage: \n    TestExamples()\n\"\"\"", "    \n    Strongest_Extension(class_name,\
    \ extensions, 0)\nend\n</cell>\n<code language=julia-1.5>\n# TEST STRONGEST EXTENSION\
    \ (188)\nTest.assertEquals(Strongest_Extension(\"my_class\", [\"AA\", \"Be\",\
    \ \"CC\"]), \"my_class.AA\", \"incorrect result\")\nTest.assertEquals(Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]), \"my_class.Be\", \"incorrect result\")\n\
    Test.assertEquals(Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]),\
    \ \"my_class.CC\", \"incorrect result\")\n</cell>\n<text>\nPart III. FINDING STRONGEST\
    \ EXTENSION IN A BLOCK OF EXTENSIONS", "  \n    #Initializing the StrongestExtensions\
    \ vector\n    StrongestExtensions = Set()\n    \n    for Extension in extensions\
    \ \n        \n        #Split the string and take the first letter of the split\
    \ string\n        ExtensionNameSplit = split(Extension,\".\")\n        \n    \
    \    #Get the number of uppercase letters in the Extension Name\n        CAP =\
    \ length( findall(\"[A-Z]\", ExtensionNameSplit) )\n        \n        #Get the\
    \ number of lowercase letters in the Extension Name\n        SM = length( findall(\"\
    [a-z]\", ExtensionNameSplit) )\n        \n        #Get the fraction of the CAP\
    \ - SM\n        StrongestExtension = CAP - SM\n        \n        #If there is\
    \ another extension with the same strongest strength than the new one then \n\
    \        #insert it in the StrongestExtensions vector in the order given by the\
    \ vector\n        if isin(StrongestExtension, StrongestExtensions)\n        \n\
    \            #Insert it at the end\n            StrongestExtensions = StrongestExtensions.insert(length(StrongestExtensions),StrongestExtension)\n\
    \        else\n            #Otherwise insert it at the beginning\n           \
    \ StrongestExtensions = StrongestExtensions.insert(1,StrongestExtension)\n   \
    \     end\n    end\n    \n    #Create the StrongestExtension String using the\
    \ class_name and the StrongestExtensions vector\n    StrongestExtensionString\
    \ = join(class_name, StrongestExtensions)\n    \n    return StrongestExtensionString\n\
    end\n</cell>\n<text>\nExpected Output:", "    \n    s = \"\"\n    cap = 0\n  \
    \  sm = 0\n    \n    for ext in extensions do\n        cap = cap + length(ext)\
    \ - length(lowerfirst(ext))\n        sm = sm + length(ext) - length(lowerfirst(ext))\n\
    \    end\n    \n    if cap == 0 or sm == 0 then\n        return class_name\n \
    \   end\n    \n    strength = (cap - sm) / (cap)\n    for ext in extensions do\n\
    \        if strength >= length(ext) - length(lowerfirst(ext)) then\n         \
    \   return class_name + '.' + ext\n        end\n    end\n    \nend\n</cell>\n\
    <code language=julia-0.4>\n@test Strongest_Extension(\"my_class\", [\"AA\", \"\
    Be\", \"CC\"]) == \"my_class.AA\"\n@test Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\", \"D\"]) == \"my_class.Be\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"D\", \"e\"]) == \"my_class.CC\"\n@test\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"D\", \"e\", \"\
    g\"]) == \"my_class.CC\"\n@test Strongest_Extension(\"my_class\", [\"AA\", \"\
    Be\", \"CC\", \"D\", \"e\", \"g\", \"h\"]) == \"my_class.CC\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"D\", \"e\", \"g\", \"h\", \"i\"]) == \"\
    my_class.CC\"\n@test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    , \"D\", \"e\", \"g\", \"h\", \"i\", \"j\"]) == \"my_class.CC\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"D\", \"e\", \"g\", \"h\", \"i\", \"j\"\
    , \"k\"]) == \"my_class.CC\"\n@test Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"D\", \"e\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\"]) ==\
    \ \"my_class.CC\"\n@test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"\
    CC\", \"D\", \"e\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"]) == \"my_class.CC\"\
    \n@test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"D\", \"e\"\
    , \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"]) == \"my_class.CC\"\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"D\", \"e\"\
    , \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"", "        strengths = Vector{String}(undef,\
    \ length(extensions))\n        for e in extensions\n            pos = filter(x\
    \ -> x.isupper(), e)\n            pos = filter(x -> x.islower(), pos)\n      \
    \      pos = map(x -> toupper(x), pos)\n            strength = length(pos) - length(setdiff(pos,\
    \ lowercase(pos)))\n            strengths[end] = sprintf(\"%s.%s\", class_name,\
    \ e)\n        end\n        \n        pop_idx = sort(collect(1:length(strengths)),\
    \ by = x -> strengths[x])\n        best_strength = pop_idx[end]\n        best_extension\
    \ = extensions[best_strength]\n        return sprintf(\"%s.%s\", class_name, best_extension)\n\
    end\n</cell>\n<code language=julia-1.0>\n@testset \"STRONG EXTENSIONS\" begin\n\
    \    examples = [\n        Strongest_Extension(\"my_class\", [\"AA\", \"Be\",\
    \ \"CC\"]),\n        Strongest_Extension(\"my_class\", [\"aA\", \"Be\", \"CC\"\
    ]),\n        Strongest_Extension(\"my_class\", [\"Aa\", \"Be\", \"CC\"]),\n  \
    \      Strongest_Extension(\"my_class\", [\"Aa\", \"Bb\", \"CC\"])\n    ]\n  \
    \  for e in examples\n        @test Strongest_Extension(\"my_class\", [e...])\
    \ isa String\n    end\nend\n</cell>\n<text>\n3. Implement Strongly_Connected",
  "    \n    len_class = length(class_name)\n    \n    if len_class > length(extensions)\n\
    \        error(\"Class name too long\")\n    end\n    \n    len_extension = length(extensions[1])\n\
    \    \n    if len_extension < 1\n        error(\"No extensions\")\n    end\n \
    \   \n    len_extension = len_extension - 1\n    \n    extension_strength = zeros(len_extension)\n\
    \    \n    for extension in extensions\n        len_extension = length(extension)\n\
    \        \n        if len_extension > len_extension_strength\n            error(\"\
    Extension is too long\")\n        end\n        \n        extension_strength[len_extension]\
    \ = \n            if len_extension == len_extension_strength\n               \
    \ -1\n            else\n                ((len_extension - len_extension_strength)\n\
    \                    / len_extension_strength)\n            end\n    end\n   \
    \ \n    index = findall(extension_strength == max(extension_strength))\n    \n\
    \    str = class_name\n    for index in index\n        str = str.replaceall(extensions[index],\
    \ \"\")\n    end\n    \n    str\nend\n</cell>\n<text>\nProblem 3\nThe method should\
    \ be able to work with any number of classes and extensions.\nYou will be given\
    \ the name of a class (a string) and a vector of extensions as strings. \nThe\
    \ method should return a string in this format: ClassName.StrongestExtensionName.\n\
    For example, if you have the following class name and extensions:\n'my_class'\n\
    'SErviNGSliCes'\n'Cheese'\n'StuFfed'\nand the following extensions:\n'AA'\n'Be'\n\
    'CC'\n'DD'\n'EE'\n'FF'\n'GG'\n'HH'\nthe method should return 'my_class.SErviNGSliCes'.\n\
    You should find the strongest extension and return a string in this \nformat:\
    \ ClassName.StrongestExtensionName.\nFor this problem, you know that there are\
    \ only uppercase letters.\nFor example, the following class name and extensions\
    \ should return a string:\n'Slices'\n'A'\n'B'\n'C'\n'D'\n'E'\n'F'\n'G'\n'H'\n\
    'I'\n'J'\n'K'\n'L'\n'M'\n'N'\n'O'\n'P'\n'Q'\n'R'\n'S'\n'T'\n'U'\n'V'\n'W'\n'X'\n\
    'Y'\n'Z'\nIn this case you should return 'Slices.A'.", "    extension_strength\
    \ = extension_count = max_strength = -1\n    for ext in extensions\n        ext_length\
    \ = length(ext)\n        if ext_length != 0\n            ext_count = lowercase(ext)\n\
    \            ext_count -= 1\n            if ext_strength > max_strength\n    \
    \            max_strength = ext_strength\n            elseif ext_count == 0\n\
    \                extension_count = ext_length\n                extension_strength\
    \ = ext_strength\n            else\n                extension_strength = ext_strength\n\
    \                extension_count = ext_count\n            end\n        end\n \
    \   end\n    strongest_ext = \"\"\n    if max_strength != -1\n        strongest_ext\
    \ = \".\" + uppercase(class_name) + uppercase(String(max_strength - extension_count))\n\
    \    elseif extension_count == 0\n        return class_name\n    else\n      \
    \  return class_name + Strongest_Extension(lowercase(extensions[end]), extensions[end-1:end])\n\
    \    end\nend\n</cell>\n<text>\nProblem 8: Sort By Probability\nImplement function\
    \ sort_by_probability, which sorts a given list of objects, according to a probability.\n\
    The probability of an element appearing in the list should range between [0, 1],\
    \ and is equal to the probability the element appears in the list.\nThe function\
    \ should return the sorted list of objects.\nThe sorting algorithm should go through\
    \ each object, one at a time, and for each element, \nyou should update the probability\
    \ of each element that appears in the list accordingly. \nYou will need to store\
    \ the objects and their corresponding probabilities in a data structure.\nFor\
    \ example, if the list is as follows:\n \n [ Cat(\"Pello\", 0.3), Dog(\"Curly\"\
    , 0.3), Dog(\"Poodle\", 0.3), Cat(\"Curly\", 0.3) ] ", "    \n    extensions =\
    \ sort(extensions)\n    \n    stength = length(extensions)\n    \n    if stength\
    \ == 1 return class_name\n    \n    str = Strongest_Extension(class_name, extensions[1:stength])\n\
    \    \n    if length(extensions[stength+1:]) == 1 \n        return str .. \".\"\
    \ .. extensions[stength+1]\n    else\n        str = str\n        for ix in extensions[stength+1:end]\n\
    \            str = str .. \".\" .. extensions[ix]\n        end\n        return\
    \ str\n    end\nend\n</cell>\n<text>\nLet's test our function with the two examples\
    \ we gave earlier:", "    \n    str_extensions = sort(extensions) |> join\n  \
    \  \n    strengths = countmap(str_extensions) |> collect\n    \n    strongest_ext\
    \ = [x for x in extensions if x in strengths][-1]\n    \n    class_name+\".\"\
    +strongest_ext\nend\n</cell>\n<text>\nNow we will see how to write the main function.\
    \ This function will take as input two strings: class_name and extensions.", " \
    \   if extensions.length == 0 \n        return \"no extensions\"\n    \n    cap\
    \ = sum(map(x -> isupper(x) ? length(x) : 0, extensions))\n    sm = sum(map(x\
    \ -> islower(x) ? length(x) : 0, extensions))\n    strength = cap - sm\n    \n\
    \    if length(extensions) ==1 \n        return \"#{class_name}.#{extensions[0]}\"\
    \n    \n    i = findfirst(isequal(strength), extensions)\n    if isequal(strength,\
    \ -1) || i == length(extensions) \n        return \"#{class_name}.#{extensions[i]}\"\
    \n    elseif i == 1 \n        return \"#{class_name}.#{extensions[1]}\"\n    else\n\
    \        return \"#{class_name}.#{extensions[i]}\"\n    end\nend\n</cell>\n<text>\n\
    (IMPLEMENTATION) Test Your Solution", "    if extensions <= 1 \n        return\
    \ class_name\n    else \n        strength = extension_counts(extensions)[2]/extension_counts(extensions)[1]\n\
    \        i = search(extensions, strength)\n        if i \n            return class_name+\"\
    .\"+extensions[i]\n        else \n            error(\"No strongest extension found\"\
    )\n    end\nend\n</cell>\n<code language=julia-1.5>\n@testset \"Strongest_Extension\"\
    \ begin\n    Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\nend\n\
    </cell>\n<text>\nYou will be given the name of the class and some extensions.\
    \ The main aim of the function is to find the strongest extension and return it\
    \ in the form ClassName.StrongestExtensionName.", "    extensions = sort(extensions)\n\
    \    l = length(extensions)\n    if l <= 1\n        return class_name\n    end",
  "    \"\"\"\n    Strongest_Extension(class_name, extensions)\n    \n    Input: Strings\
    \ class_name and extensions, where extensions is a vector of\n    strings containing\
    \ names of additional classes. Return String in this\n    format: class_name.StrongestExtensionName.\
    \ \n    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\n    \n    extensions_count = length(extensions)\n\
    \    \n    for i=1:extensions_count\n        if length(findall(lowercase(extensions[i]),\
    \ class_name)) > 0 \n            strength = length(findall(lowercase(extensions[i]),\
    \ class_name))/length(extensions[i])\n        else\n            strength = -1\n\
    \        end\n        \n        if strength > max_strength \n            max_strength\
    \ = strength\n            strongest_extension = extensions[i]\n        else\n\
    \            break\n        end\n    end\n    \n    strongest_extension = replace(strongest_extension,\
    \ \" \", \"\")\n    strongest_extension = replace(strongest_extension, \".\",\
    \ \"\")\n    return strongest_extension\nend\n</cell>\n<code language=julia-1.6>\n\
    @assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n</cell>\n<code language=julia-1.6>", "    if length([x for x in extensions if\
    \ length(x.upper) == length(x.lower)]) == 0 \n        return class_name\n    cap_len\
    \ = length([x for x in extensions if length(x.upper) == 1])\n    sm = length([x\
    \ for x in extensions if length(x.lower) == 1])\n    \n    if cap_len == sm\n\
    \        return class_name\n    \n    if cap_len < sm\n        index_of_cap =\
    \ indexOf(cap_len,extensions)\n        return class_name.substring(0,index_of_cap+1)\
    \ + extensions[index_of_cap+1]\n    else\n        index_of_sm = indexOf(sm,extensions)\n\
    \        return class_name.substring(0,index_of_sm+1) + extensions[index_of_sm+1]\n\
    \    end\nend", "  strongest, strength = extension_strength(extensions)\n  \n\
    \  strongest_extension = strongest\n  if strength == -1\n      strongest_extension\
    \ = extension_first(extensions)\n  end\n  return strongest_extension\nend", " \
    \ \n    strengh_ext=0\n    name_with_strengh=\"\"\n    for ext in extensions\n\
    \        name_with_strengh=name_with_strengh+\".\"+ext\n        if str_to_lower(name_with_strengh)==str_to_lower(class_name)\n\
    \            strengh_ext=-1*strengh_ext\n        else\n            strengh_ext=strengh_ext+1\n\
    \        end\n    end\n    for ext in extensions\n        if str_to_lower(name_with_strengh)==str_to_lower(class_name)\n\
    \            name_with_strengh=name_with_strengh+\".\"+ext\n        else\n   \
    \         name_with_strengh=name_with_strengh+\"_\"+ext\n        end\n    end\n\
    \    name_with_strengh=str_to_lower(name_with_strengh)\n    return name_with_strengh\n\
    end", "    extensions_sorted = sort(extensions)\n    strongest_extension = extensions_sorted[1]\n\
    \    \n    for extension in extensions_sorted[2:end]\n        if extensions_sorted[extensions_sorted.index(extension)\
    \ - 1] > strongest_extension\n            strongest_extension = extension\n  \
    \      end\n    end\n    \n    return Str(class_name) + strongest_extension\n\
    end\n</cell>\n<code language=julia-0.6>\nusing Test\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]) \u2248 \"my_class.AA\"\n@test Strongest_Extension(\"\
    my_class\", [\"BB\", \"C\", \"DD\"]) \u2248 \"my_class.BB\"\n@test Strongest_Extension(\"\
    my_class\", [\"AAA\", \"DD\", \"C\"]) \u2248 \"my_class.AAA\"\n@test Strongest_Extension(\"\
    my_class\", [\"C\", \"CC\", \"DD\"]) \u2248 \"my_class.CC\"\n@test Strongest_Extension(\"\
    my_class\", [\"D\", \"D\", \"DD\"]) \u2248 \"my_class.D\"\n@test Strongest_Extension(\"\
    my_class\", [\"D\", \"DD\", \"D\"]) \u2248 \"my_class.D\"\n@test Strongest_Extension(\"\
    my_class\", [\"D\", \"DD\", \"D\"]) \u2248 \"my_class.D\"\n@test Strongest_Extension(\"\
    my_class\", [\"D\", \"DD\", \"D\"]) \u2248 \"my_class.D\"\n@test Strongest_Extension(\"\
    my_class\", [\"D\", \"DD\", \"D\"]) \u2248 \"my_class.D\"\n@test Strongest_Extension(\"\
    my_class\", [\"D\", \"DD\", \"D\"]) \u2248 \"my_class.D\"\n@test Strongest_Extension(\"\
    my_class\", [\"D\", \"DD\", \"D\"]) \u2248 \"my_class.D\"\n@test Strongest_Extension(\"\
    my_class\", [\"D\", \"DD\", \"D\"]) \u2248 \"my_class.D\"\n@test Strongest_Extension(\"\
    my_class\", [\"D\", \"DD\", \"D\"]) \u2248 \"my_class.D\"\n@test Strongest_Extension(\"\
    my_class\", [\"D\", \"DD\", \"D\"]) \u2248 \"my_class.D\"\n@test Strongest_Extension(\"\
    my_class\", [\"D\", \"DD\", \"D\"]) \u2248 \"my_class.D\"\n@test Strongest_Extension(\"\
    my_class\", [\"D\", \"DD\", \"D\"]) \u2248 \"my_class.D\"\n@test Strongest_Extension(\"\
    my_", "    \n    \n    number_of_unique_extensions = length(unique(extensions))\n\
    \    \n    if number_of_unique_extensions > 1 \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        ", "    \n    Extension_Strength =\
    \ []\n    \n    for i in extensions\n        \n        if contains(uppercase(i),\
    \ class_name) == false \n            continue\n            \n        for j in\
    \ uppercase(i)\n            \n            if contains(lowercase(j), class_name)\
    \ == false \n                continue\n            \n            if contains(lowercase(j),\
    \ i) == false \n                continue\n            \n            if strongest(lowercase(j),\
    \ lowercase(i)) > Extension_Strength[length(Extension_Strength)+1]\n         \
    \       Extension_Strength = [lowercase(j), lowercase(i)]\n            end\n \
    \       end\n    end\n    \n    if length(Extension_Strength) == 0 \n        return\
    \ class_name\n    end\n    \n    \n    \n    return strcat(class_name,\".\",join(Extension_Strength))\n\
    end", "    for e in extensions\n        if isupper(e)\n            return class_name\
    \ .. \".\" .. e\n        end\n    end\nend\n</cell>\n<code language=julia-0.6>\n\
    @code_warntype Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n</cell>\n\
    <text>\nQ. Write a function which returns a string in the format ClassName+StrongestExtensionName\n\
    where ClassName is a string in the form class_name.\nFor example:\n    > \"my_class.AA\"\
    \n    > \"my_class.Be\"\n    > \"my_class.CC\"", "    s = \"\"\n    for e in extensions\n\
    \        s = s .. \".\" .. e\n    end\n    \n    \n    if length(extensions)==0\n\
    \        return s\n    end\n    \n    i = 0\n    while i+1<length(extensions)\n\
    \        if s[end] in uppercase(extensions[i])\n            i = i + 1\n      \
    \  elseif s[end] in lowercase(extensions[i])\n            i = i + 1\n        elseif\
    \ s[end] in uppercase(extensions[i])\n            i = i + 1\n        elseif s[end]\
    \ in lowercase(extensions[i])\n            i = i + 1\n        elseif s[end] in\
    \ uppercase(extensions[i])\n            i = i + 1\n        elseif s[end] in lowercase(extensions[i])\n\
    \            i = i + 1\n        end\n    end\n    \n    if i == length(extensions)\n\
    \        return s\n    end\n    \n    \n    \n    if s[end] in uppercase(extensions[i])\n\
    \        return s .. \".\" .. extensions[i]\n    end\n    \n    if s[end] in lowercase(extensions[i])\n\
    \        return s .. \".\" .. extensions[i]\n    end\n    \n    if s[end] in uppercase(extensions[i])\n\
    \        return s .. \".\" .. extensions[i]\n    end\n    \n    if s[end] in lowercase(extensions[i])\n\
    \        return s .. \".\" .. extensions[i]\n    end\n    \n    return s\n   \
    \ \nend", "    \n    extensions = extensions[2:end]\n    \n    \n    cap_len =\
    \ length(extensions[2:end])\n    strongest_extension_strength = -1\n    \n   \
    \ for i in 2:cap_len\n        \n        sm = 0\n        \n        for j in 2:cap_len\n\
    \            \n            if upper(extensions[j])==upper(extensions[j+1])\n \
    \               sm += 1\n            \n        end\n        \n        if strongest_extension_strength\
    \ == -1 || strongest_extension_strength > sm/cap_len\n            strongest_extension_strength\
    \ = sm/cap_len\n        end\n    end\n    \n    return join([\".\",class_name,\"\
    .\",join(extensions[2:end])],\".\")\nend\n</cell>\n<code language=julia-1.0>\n\
    @assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DE\", \"\
    FG\"]) == \"my_class.CC\"\n@assert Strongest_Extension(\"my_class\", [\"AA\",\
    \ \"Be\", \"CC\", \"DE\", \"FG\", \"HI\"]) == \"my_class.FG\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DE\", \"FG\", \"HI\", \"JK\", \"LM\"])\
    \ == \"my_class.HI\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DE\", \"FG\", \"HI\", \"JK\", \"LM\", \"OP\"]) == \"my_class.JK\"\n\
    @assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DE\", \"\
    FG\", \"HI\", \"JK\", \"LM\", \"OP\", \"PP\"]) == \"my_class.LM\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DE\", \"FG\", \"HI\", \"JK\", \"LM\", \"\
    OP\", \"PP\", \"QQ\"]) == \"my_class.OP\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DE\", \"FG\", \"HI\", \"JK\", \"LM\", \"OP\", \"\
    PP\", \"QQ\", \"RR\"]) == \"my_class.PP\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DE\", \"FG\", \"HI\", \"JK\", \"LM\", \"OP\", \"\
    PP\", \"QQ\", \"RR\", \"SS\"]) == \"my_class.QQ\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DE\", \"FG\", \"HI\", \"JK\", \"LM\", \"\
    OP\", \"PP\", \"QQ\", \"RR\", \"SS\", \"TT\"]) == \"my_class.RR\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA", "    str_extensions = Vector{String}()\n    for ext in extensions\
    \ \n        str_extensions.push(StrongestExtension(ext))\n    end\n    idx = findfirst(x\
    \ -> x == class_name, str_extensions)\n    if idx != -1 \n        return class_name[idx\
    \ : length(class_name) + length(extensions[idx])]\n    else\n        error(\"\
    class %s has no extensions named %s!\" % (class_name, extensions))\n    end\n\
    end", "    \n    ext_hash=Dict{String,Int}() #store the extension strength by\
    \ their names\n    for e in extensions\n        ext_hash[e] = length(filter(x\
    \ -> x isupper e,class_name))-length(filter(x -> x islower,e))\n    end\n    \n\
    \    Strongest_Extension_1=find_key(ext_hash,minimum(ext_hash.values)) #find the\
    \ strongest extension\n    return Strongest_Extension_1 #return the strongest\
    \ extension name", "    \n    Strongest = extensions[1..end]\n    Strongest.sort!\n\
    \    Strongest = Strongest[1]\n    \n    return class_name .+ \".\" * string(Strongest)\n\
    end\n</cell>\n<code language=julia-1.3>\n@test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n</cell>\n<text>\nYour next task\
    \ is to rewrite the function with input from STDIN. The input will be a single\
    \ line consisting of the class name followed by a vector of extensions. You can\
    \ assume that the class is correctly spelled and contains at least one extension.\
    \ \nThe function should then return a string in the following format: ClassName.StrongestExtensionName.\
    \ \nThe extensions are to be used to load additional classes to the class. You\
    \ can assume that the class is correctly spelled and contains at least one extension.\n\
    You can assume that the extension is correct.", "    \"\"\"\n    Strongest_Extension\
    \ finds the strongest extension given a string of class \n    name and a vector\
    \ of extensions.\n    The extensions are to be used to load additional classes\
    \ to the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\n  \n# Write your code below this line *******************************************",
  "    s = 1\n    for i in extensions \n        s += 1 if i.end==i.start \n    end\n\
    \    return class_name+\".\"*string(extensions[s])\nend", "    \n    \"\"\"\n\
    \    Strongest_Extension receives a class name and a vector of extensions (Strings).\n\
    \    The function should return the string in the format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ \"\"\"\n    \n    extension_strength = zeros(length(extensions)) \n    \n  \
    \  for e in extensions \n        extension_strength = extension_strength + (e.chars.count(uppercase(substring(e,1,end)))\
    \ - \n                                                e.chars.count(lowercase(substring(e,1,end))))\
    \ \n    \n    extension_strength_sorted = sort(extension_strength, descending\
    \ = true) \n    \n    sorted_extension_strength = extension_strength_sorted[1]\n\
    \    \n    if length(extension_strength_sorted) > 1 \n        \n        for e\
    \ \u2208 extensions \n            \n            if extension_strength_sorted[1]\
    \ == extension_strength_sorted \n                \n                sorted_extension_strength\
    \ = e \n                \n                break \n            \n            end",
  "    extensions_length = length(extensions)\n    extensions_count = count_if(x ->\
    \ contains(x, class_name), extensions)\n    extensions_count_ratio = extensions_count\
    \ / extensions_length\n    \n    # strongest extension\n    extension_strongest\
    \ = extensions[find_first(x -> contains(x, class_name), extensions)]\n    \n \
    \   return class_name..extension_strongest\nend", "    s = -1\n    for e in extensions\
    \ do\n        if levenshtein(class_name, e) < s then\n            s = levenshtein(class_name,\
    \ e)\n        end\n    end\n    \n    \n    return class_name[:length(class_name)\
    \ - length(extensions[1]) - 1] + extensions[1][s]\nend\n</cell>\n<code language=julia-1.0>\n\
    Strongest_Extension(\"Slices\", [\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"])\n\
    </cell>\n<text>\nPart C: Test Cases\nWrite a test case to check that Strongest_Extension\
    \ works correctly for all of the following test cases.", "    if length(extensions)<2\
    \ \n        return class_name\n    end\n    ext=extensions[end]\n    ext=lowercase(ext)\n\
    \    \n    name=class_name\n    \n    for c in lowercase(ext[1:length(ext)-1])\n\
    \        name=name[end-length(c):end]\n    end\n    return name\nend", "    my_strongest_extension\
    \ = get_strongest_extension(class_name, extensions)\n    my_strongest_extension[1:end-1]\n\
    end\n</code>\n<|/ a tags=julia dscore=1 |>\n<| c |>\nHey thanks for the answer!\
    \ I tried running it but I'm getting this error: `UndefVarError: get_strongest_extension\
    \ not defined`. Do I need to define the function first somewhere?\n<|/ c |>\n\
    <| c |>\nYou need to define that function and call it in the same file where you\
    \ defined the `Strongest_Extension` function.\n<|/ c |>\n<| c |>\nHi, I'm new\
    \ to Julia and I really don't know how to do that! I tried to define `get_strongest_extension`\
    \ function and then call it, but I get the error I posted in the original question.\
    \ Would you mind showing me how to do that?\n<|/ c |>\n<| c |>\nI edited the question\
    \ with my attempt of defining the function. Sorry, but I'm really new to Julia\
    \ and don't really know how to do that.\n<|/ c |>\n<| c |>\nThis code works with\
    \ the example I gave, but when I tried it on my own code I got this error: `ERROR:\
    \ LoadError: MethodError: no method matching length(::Bool)\nClosest candidates\
    \ are:\n  length(::DataArray{Bool,N}) at /Users/.../Project.jl:26\nStacktrace:\n\
    \ [1] top-level scope at /Users/.../Project.jl:22\n`\n<|/ c |>\n<| a tags=julia\
    \ |>\nYou have to make a few changes. Here is an example that works for me:\n\
    <code>\nget_strongest_extension(class_name::String, extensions::Vector{String})::String",
  "    extension_count = length(extensions)\n    if extension_count == 0 \n      \
    \  error(\"No extensions\")\n    elseif extension_count == 1\n        return class_name\
    \ + \".\" + extensions[0]\n    end\n    \n    # counts the number of capitals\
    \ in the class name and divides it\n    capitals = count_capitals(class_name) ",
  "    extensions_index = getIndex(extensions)\n    if extensions_index == 0\n   \
    \     return class_name\n    end\n    \n    return Strongest_Extension(class_name,\
    \ extensions[extensions_index])\nend", "    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n", "        \n    return class_name + \".\" + \n        extensions[sort(extensions,\
    \ by=length)][1]\nend", "    \"\"\"\n    You will be given the name of a class\
    \ (a string) and a vector of extensions.\n    The extensions are to be used to\
    \ load additional classes to the class. The\n    strength of the extension is\
    \ as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\n    \n    let num_caps = length(upper(extensions))\n\
    \    let num_sms = length(lower(extensions))\n    \n    if num_caps-num_sms ==\
    \ 0 \n        return \"Unknown\"\n    else \n        return (class_name * \".\"\
    \ * join(extensions,\".\")) \n    end\nend\n</cell>\n<text>\nWrite a function\
    \ called \"load_extensions\" which takes as input a path to a file containing\
    \ extensions and \nreturns a vector of strings. This function should return a\
    \ vector of the extensions in the order they appear\nin the file.\nIn the cell\
    \ below, write a function that takes a string and an optional argument file_name\
    \ \n(default \"extensions.txt\"), and loads the extensions in that file as a vector\
    \ of strings.\nThe optional argument file_name should contain the name of the\
    \ file that you want to load\nthe extensions from. The function should return\
    \ this vector as a result.", "    ext = {}\n    count = 0\n    for e in extensions\n\
    \        if lowercase(e) == lowercase(class_name)\n            count+=1\n    \
    \    elseif lowercase(e) == lowercase(class_name)\n            count+=1\n    \
    \    else\n            ext[lowercase(e)] = count\n            count = 0\n    \
    \    end\n    end\n    \n    sorted = collect(ext) do key, val\n        val \n\
    \    end\n    \n    sorted.reverse\n    \n    for (key, val) in sorted\n     \
    \   if val > 0\n            return key + \".\" + extensions[key]\n        end\n\
    \    end\nend\n</cell>\n<code language=julia-0.6>\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n@assert Strongest_Extension(\"\
    MyClass\", [\"AA\", \"Be\", \"CC\"]) == \"MyClass.AA\"\n@assert Strongest_Extension(\"\
    Myclass\", [\"AA\", \"Be\", \"CC\"]) == \"Myclass.AA\"\n@assert Strongest_Extension(\"\
    My_class\", [\"AA\", \"Be\", \"CC\"]) == \"My_class.AA\"\n</cell>\n<text>\nExercise\
    \ 2.7\nThe function Classname should take a vector of extensions as its first\
    \ argument and returns the name of the class with its extensions appended to it.",
  "    \n    len = length(extensions)\n    \n    if len < 1\n        error(\"Cannot\
    \ have 0 extensions\")\n    end\n    \n    sort(extensions, by = x -> count_occurences(x,\
    \ class_name) - count_occurences(x, \"className\"))\n    \n    ext1 = extensions[end]\n\
    \    if count_occurences(ext1, class_name) != len\n        error(\"Extension not\
    \ found!\")\n    end\n    \n    return String(class_name) + ext1\nend", "    extension\
    \ =  [item for item in extensions \n        if (item in StringChars(class_name)\
    \ and item != String(class_name))]\n    return length(extension) == 0 ? class_name\n\
    \                            : class_name.(extension)\nend\n</cell>\n<code language=julia-1.1>\n\
    ?StringChars\n</cell>\n<code language=julia-1.1>\nStrongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ generates the string class name and the extension for a given \nobject of any\
    \ type (e.g., String, Int, or Vector{String}), with these properties:\n- Every\
    \ object has a class name.\n- Every object has an extension (vector of strings).\n\
    - The extension vector is composed of valid characters of the class name.\n- There\
    \ should be no duplicate extensions.\n- There should be no missing extensions\
    \ in the extensions vector.\n- There should be no missing characters in the extension\
    \ vector.\n- There should be no duplicate class names.\n- There should be no missing\
    \ class names.\nExample: \n>>> make_class_and_extension(MyString(42), \"ABC\"\
    )\n(\"MyString\", \"ABC\")\n>>> make_class_and_extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\"])\n(\"my_class\", \"AA\", \"Be\", \"CC\")\n>>> make_class_and_extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"])\n(\"my_class\", \"AA\", \"Be\", \"CC\")\n\
    >>> make_class_and_extension(42, \"ABC\")\n(42, [\"A\", \"B\", \"C\"])\n>>> make_class_and_extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"])\n(\"my_class\", \"AA\", \"Be\", \"CC\")\n\
    >>> make_class_and_extension(42, \"ABC\")\n(42, [\"A\", \"B\", \"C\"])\n>>> make_class_and_extension(MyString(\"\
    42\"), \"ABC\")\n(\"MyString\", \"ABC\")\n>>> make_class_and_extension(MyString(\"\
    42\"), \"ABC\")\n(\"MyString\", \"ABC\")\n>>> make_class_and_extension(MyString(42),\
    \ \"ABC\")\n(\"MyString\", \"ABC\")\n>>> make_class_and_extension(MyString(42),\
    \ \"ABC\")\n(\"MyString\", \"ABC\")\n>>> make_class_and_extension(MyString(42),\
    \ \"ABC\")\n(\"MyString\", \"ABC\")\n>>> make_class_and_extension(MyString(42),\
    \ \"ABC\")\n(\"MyString\", \"ABC\")\n>>> make_class_and_extension(MyString(\"\
    42\"), \"ABC\")\n(\"MyString\", \"ABC\")\n>>> make_class_and_extension(MyString(\"\
    42\"), \"ABC\")\n(\"MyString\", \"ABC\")\n>>> make_class_and_extension(MyString(\"\
    42\"), \"ABC\")\n(\"", "    str_vec=extensions_strength(extensions)\n    if any(str_vec==-1)\
    \ return class_name\n    # return sort(extensions,by=str_vec,rev=true)[1]\n  \
    \  sort!(extensions,by=str_vec,rev=true)\n    return sort(extensions,by=str_vec,rev=true)[1]\n\
    end\n</code>\n<|/ a tags=julia |>\n<| c |>\nThanks for the solution, It will also\
    \ help other beginner like me.\n<|/ c |>\n<| a tags=julia dscore=0 |>\nMy solution\
    \ for Julia 0.6:\n<code>", "    \n    strength = Dict{String, Int}()\n    for\
    \ e in extensions\n        strength[e] = count(lower(e)) / (count(upper(e)))\n\
    \    end\n    \n    \n    strength_sorted = sort(strength, by=x->x[1], reverse=true)\n\
    \    \n    sorted_extension = \n        if length(strength_sorted) == 0 \n   \
    \     error(\"No extensions given\")\n        else \n            extensions[first(find(strength_sorted\
    \ .== strength_sorted[1],1))]\n        end\n    \n    if length(strength_sorted)\
    \ == 1 \n        error(\"More than one extension found. Choose one from the list.\"\
    )\n    else \n        Strongest_Extension = Stringcat(class_name, \".\", sorted_extension)\n\
    \    end\nend", "    # your code goes here\nend", "  \n  exts = sort(extensions)\n\
    \  \n  if length(exts) > 1\n    s_ext = exts[1]\n  else\n    s_ext = exts[0]\n\
    \  end\n  \n  if length(exts) == 2\n    if length(extensions) > 2\n      c_ext\
    \ = extensions[2]\n    else\n      c_ext = extensions[1]\n    end\n  else\n  \
    \  c_ext = exts[1]\n  end\n  \n  name = class_name.split(\".\") \n  \n  strongest\
    \ = strongest_extension(name)\n  \n  if length(exts) == 2\n    return strongest\
    \ + \".\" + c_ext\n  else\n    return strongest + \".\" + s_ext\n  end\nend\n\
    </cell>\n<text>\nExtensions\nThe extensions feature is now available in the standard\
    \ library! You can now perform operations on classes before they are instantiated.",
  "# this function\n\"\"\"\n    Implement this function in any CSP file.\n    \"\"\
    \"", "    extension = extensions[1]\n    while strpos(extension, class_name) <\
    \ strpos(extension, class_name + \"A\")\n        extension = extensions[-2]\n\
    \    end\n    return join(\".\", class_name, extension)\nend", "    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n", "    strongest = extensions[]\n\
    \    strongest = sort(strongest)\n    strongest = strongest[length(strongest)]\
    \ \n    strongest = strongest.sub(\"^([A-Z]+)\", \"\") \n    strongest = strongest.sub(\"\
    ([A-Z]+)$\", \"\") \n    strongest = strongest.sub(\"([a-z]+)([A-Z])\", \"$1.$2\"\
    )\n    return class_name.concat(strongest) \nend\n</cell>\n<text>\n\_Exercise\
    \ 4\nCreate a function that is used to load a class from a given path, and returns\
    \ a class of it. The class should use the name given in the function argument.\
    \ \nThe function should return an object of type Class, which will contain the\
    \ following attributes: name, extensions, extension_strength. \nThe name attribute\
    \ should contain the name of the class passed in the argument. \nThe extensions\
    \ attribute should contain the extensions of the class passed in the argument.\
    \ \nThe extension_strength attribute should contain the strength of each extension\
    \ used in the class. \nNote that if the extension name is found more than once\
    \ in the vector extensions, the function should choose the one that comes first\
    \ in the vector. \nIf the extension name is not found at all in the vector extensions,\
    \ the function should return an error. \nHint: you can use the function load_class(...)\
    \ defined earlier. \nHint: You may want to use try/catch/else statement.", " \
    \   \n    if length(extensions) <= 0\n        throw(ArgumentError(\"There must\
    \ be at least 1 extension given\"))\n    \n    \n    for ext in extensions \n\
    \        \n        if ext == \"\"\n            throw(ArgumentError(\"There must\
    \ be some extensions given\"))\n        \n        if all(c <= \"Z\" for c in ext)\n\
    \            throw(ArgumentError(\"There must be some extensions given\"))\n \
    \           \n        if all(c <= \"z\" for c in ext)\n            throw(ArgumentError(\"\
    There must be some extensions given\"))\n            \n        \n        if ext\
    \ == \"\"\n            throw(ArgumentError(\"There must be some extensions given\"\
    ))\n        end\n        \n    end\n    \n    \n    if extensions[1] == \"\"\n\
    \        throw(ArgumentError(\"There must be at least 1 extension given\"))\n\
    \    end\n    \n    if extensions[2] != \"\"\n        throw(ArgumentError(\"There\
    \ must be at least 2 extensions given\"))\n    end\n    \n    \n    \n    \n \
    \   \n    \n    \n    if length(extensions)>3\n        throw(ArgumentError(\"\
    There must be at most 3 extensions given\"))\n    end\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    if length(extensions)>3\n     \
    \   throw(ArgumentError(\"There must be at most 3 extensions given\"))\n    end\n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n", "    \n    if length(extensions)\
    \ <= 1\n        return class_name\n    end", "        \n    extensions_ = extensions[1:end]\n\
    \    strength_ = [0 for i in 1:length(extensions_)]\n    \n    for i in 1:length(extensions_)\
    \ \n        \n        cap = match(extensions_[i], \"[A-Z]\")\n        slash =\
    \ match(extensions_[i], \"[A-z]\")\n        \n        strength_[i] = cap - slash\n\
    \    end\n    \n    \n    strength_sum = sum(strength_)\n    \n    sorted_ = sort(zip(extensions_,\
    \ strength_))\n    \n    index_ = argmax(map(x -> x[1],  sorted_))[1]\n    \n\
    \    \n    return class_name .. \".\" .. sorted_[index_][1]\nend\n</cell>\n<text>\n\
    Expected Output:", "    \n    strongest_extension_strength = -1 # initiate the\
    \ strength of the extension\n    for extension in extensions \n        if contains(extension,\
    \ uppercase(class_name)) \n            strongest_extension_strength = length(extension)\
    \ - length(lowercase(extension))\n        end\n    end\n    return class_name*string(strongest_extension_strength)\n\
    end\n</cell>\n<text>\n(2.1) Test your function", "    if extensions.size == 0\n\
    \        return class_name\n    \n    sort_order = extensions.map(x->x.length).max\n\
    \    \n    max_length = extensions.map(x->x.length).max\n    \n    strength =\
    \ extensions.map(x->x.length - sort_order).max\n    \n    if strength == 0\n \
    \       error(\"No extension has the maximum strongest extension\")\n    end",
  "    \n    #Initialize a dictionary to store extensions and strengths. \n    extension_dict\
    \ = {}\n    \n    #Get number of uppercase letters in extension. \n    CAP = count(uppercase(extensions[1]))\n\
    \    \n    #Get number of lowercase letters in extension. \n    SM = count(lowercase(extensions[1]))\n\
    \    \n    #Compute and store the strongest extension. \n    extension_dict[extensions[1]]\
    \ = CAP - SM\n    \n    #Initialize a counter. \n    count = 0\n    \n    #Iterate\
    \ through extensions and see if each of them are in the dictionary. \n    for\
    \ extn in extensions[2:end]\n        \n        #If not, increment count and set\
    \ extension to be the extension with the \n        #strongest strength. If yes,\
    \ increment count and leave it as it is. \n        if !(extn in extension_dict)\n\
    \            count = count+1\n            extension_dict[extn] = count\n     \
    \   else\n            count = extension_dict[extn]\n        end\n    end\n   \
    \ \n    return class_name * \".\" + extension_dict[extensions[1]]\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n@test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n@test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\"]) == \"my_class.DD\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"]) == \"my_class.EE\"\n</cell>\n\
    <text>\nQ21\nWrite a function to compute the total number of words in a document\
    \ that ends with \"ay\". \nFor example in [\"a\", \"be\", \"see\", \"see\", \"\
    see\", \"see\", \"see\", \"see\", \"see\"], \nthe total number of words with ending\
    \ with \"ay\" is 10.", "    \n    extension =  extensions[findall(extensions==class_name,\
    \ extensions)][1]\n    \n    if length(extensions)>1\n        extension = extensions[findall(extensions==class_name,\
    \ extensions)][2]\n    end", "    cap = length(class_name)\n    sm = length(extensions[1])\n\
    \    if cap-sm > 0 \n        str = join([class_name; strcat(extensions[1], extensions[1][cap-sm])],\
    \ \"\")\n    end\n    str\nend\n</cell>\n<code language=julia-1.6>\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Bx\", \"CC\"]) == \"my_class.Aa\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Bx\", \"CC\"]) == \"my_class.Aa\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Bx\", \"CC\", \"DD\"]) == \"my_class.Aa\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Bx\", \"CC\", \"DD\", \"EE\"]) == \"my_class.Aa\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Bx\", \"CC\", \"DD\", \"EE\", \"\
    FF\"]) == \"my_class.Aa\"\n@assert Strongest_Extension(\"my_class\", [\"AA\",\
    \ \"Bx\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\"]) == \"my_class.Aa\"\n</cell>\n\
    <text>\nProblem 3", "    extensions_with_strength = filter( (Extension -> length(Extension)\
    \ == length(class_name)\n                                     && all( is_cap(Ext)\
    \ || is_lower(Ext) \n                                         for Ext in Extension\
    \ ) ) \n                                    , extensions );\n    if length(extensions_with_strength)\
    \ == 0 \n       return class_name\n    else\n       return class_name + String(extensions_with_strength[0])\n\
    \    end\nend", "    \"\"\"\n    STRONGEST EXTENSIONS IN A CLASS \n    \n    You\
    \ will be given the name of a class (a string) and a vector of extensions.\n \
    \   The extensions are to be used to load additional classes to the class. The\n\
    \    strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    \    letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n    in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n    You should find the strongest extension and return a string in this \n\
    \    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions\
    \ with the same strength, you should\n    choose the one that comes first in the\
    \ vector.\n    For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    \    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"\n    return class_name\
    \ + \".\" + extensions[findmin(lengths(extensions))[1]]\nend", "    \n    S =\
    \ extension.(lower) for lower=extension\n    extension.(lower) for lower=extension\n\
    \    A = extension.(lower) for lower=extension\n    B = extension.(lower) for\
    \ lower=extension\n    C = extension.(lower) for lower=extension\n    \n    cap\
    \ = length(A)\n    sm = length(B)\n    \n    if cap > sm\n        return strcat(class_name,\
    \ strcat(A,\".\",B))\n    elseif cap < sm\n        return strcat(class_name, strcat(C,\"\
    .\",B))\n    end\n    \nend\n</cell>\n<code language=julia-1.5>\nStrongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"])\n</cell>\n<text>\nExercise: Implementing\
    \ Strongest_Extension\nThe function strongest() takes three arguments: a vector,\
    \ a string, and a string.\nIt should return the string in the following format:\n\
    ClassName.StrongestExtensionName\nwhere ClassName is the name of the class passed\
    \ in as the first argument and \nStrongestExtensionName is the strongest extension\
    \ name passed in as the second\nargument. Example: \nmy_class.StrongestExtensionName",
  "    len = length(extensions)\n    index_of_max_strength = sort(extensions)[len]\n\
    \    strength = ord(index_of_max_strength) - ord('a')\n    \n    return (class_name+\"\
    .\"+extensions[len-1])::String\nend", "    \n    str_extension = class_name\n\
    \    str_extension_length = len(str_extension)\n    \n    str_extension.= \"[\"\
    \ \n    \n    for extension in extensions \n        \n        if str_extension_length\
    \ < extension.length \n            str_extension = str_extension + extension[str_extension_length..-1]\
    \ \n            break\n        \n        else if str_extension_length == extension.length\n\
    \            str_extension = str_extension + extension \n            break\n \
    \       \n        else\n            str_extension = str_extension + extension[0..str_extension_length\
    \ - 1] \n            break\n        \n    end\n    \n    str_extension.= \"]\"\
    \n    \n    return str_extension\nend\n</cell>\n<code language=julia-1.6>", " \
    \   strongest_extension_index=0\n    for extension in extensions\n        if length(extension)\
    \ > length(class_name)\n            strongest_extension_index = length(class_name)\
    \ - length(extension)\n            break\n        end\n    end\n    return substring(class_name,\
    \ 1, strongest_extension_index + 1) +\n           substring(extension, strongest_extension_index\
    \ + 1, length(extension))\nend", "    strongest_extension = extensions[1]\n  \
    \  for e in extensions[2:length-1]\n        if length(strongest_extension) > length(e)\n\
    \            strongest_extension = e\n        end\n    end\n    return strongest_extension\n\
    end", "    cap_letters = sum(map(&length, extensions))\n    strength_letters =\
    \ cap_letters - sum(map(&length, extensions))\n    \n    if strength_letters ==\
    \ 0\n        return class_name\n    end", "    extensions = sort(extensions)\n\
    \    \n    strength = -1 \n    \n    for ext in extensions\n        if strmatch(class_name,\
    \ ext)\n            strength = round(length(class_name)/length(ext))\n       \
    \     \n            break\n        end\n    end\n    \n    \n    \n    if strength\
    \ == -1\n        error(\"There were no matches for class name $class_name\")\n\
    \    else\n        first(extensions[strength+1:end]).\n    end\nend\n</cell>\n\
    <code language=julia-1.6>\n@test Strongest_Extension(\"my_class\", [\"AA\", \"\
    Be\", \"CC\"]) \u2248 \"my_class.AA\"\n</cell>\n<text>\n6. Write a function that\
    \ takes the name of a class as a string, and a vector of strings as extensions,\
    \ and finds the strongest extension.\n    You should find that extension.\n  \
    \  Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"", "    Strongest_Extension = class_name +\
    \ extensions[length(extensions)];\n    return Strongest_Extension\nend\n</cell>\n\
    <code language=julia-1.0>\n\"\"\"\n    Split_Extension\n    ----------------\n\
    \    Description:\n        This function splits a string into its different components.\n\
    \    Input:\n        Strongest_Extension\n    Output:\n        A vector of strings\
    \ containing the different components.\n    Example:\n    >>> Split_Extension(\"\
    my_class.AA\")\n    [\"my_class\", \"AA\"]\n    \"\"\"", "    sorted_extensions\
    \ = sort!(extensions)\n    strongest_extension = sorted_extensions[end]\n    for\
    \ ext in sorted_extensions[2:end]\n        if StrongestExtension(class_name) ==\
    \ StrongestExtension(ext)\n            strongest_extension = ext\n        end\n\
    \    end\n    class_name+strongest_extension\nend\n</cell>\n<text>\nQuestion 9.\
    \ Complete the function with the comments:", "        \n    n = length(extensions)\n\
    \    \n    # Initialization: \n    bestExtension = extensions[1]\n    bestStrength\
    \ = -1\n    \n    # Looping through the extensions: \n    for i in 2:n\n     \
    \   \n        # Evaluating the strength between the current extension and the\
    \ \n        # current bestExtension (which is the second extension):\n       \
    \ thisStrength = length(extensions[i] - bestExtension)\n        \n        # If\
    \ the strength is better than the best strength, we replace \n        # the bestExtension\
    \ with the current extension:\n        if thisStrength > bestStrength\n      \
    \      bestExtension = extensions[i]\n            bestStrength = thisStrength\n\
    \        end\n    end\n    \n    # Return the best extension: \n    return class_name\
    \ + bestExtension\nend\n</cell>\n<text>\n3.4 A word about loops\nYou will now\
    \ use an extension to implement a word count function. The extension should include\
    \ a loop that runs over all the letters in a string.\nThe loop should start at\
    \ 1 and run until it hits the last letter of the string and add the current letter\
    \ to the running total.\nFinally you should return the total.\nThe code cell below\
    \ should give an example of what this extension might look like.", "    \n   \
    \ s=\"\"\n    for ext in extensions \n        ext=reverse(ext)\n        try\n\
    \            s=sconcat(s.s.ext[1:ext])\n        catch e\n            s=sconcat(s.s.ext)\n\
    \        end\n    end\n    return join(s.s.ext[1:length(s.s.ext)-1],\".\",s.s.ext[length(s.s.ext)-1:1])\n\
    end", "    \n    Strongest_Extension_Helper(class_name, extensions)\nend", " \
    \   \n    #Your Code Here\n    Strongest_Extension_Counter = sort(collect(zip(extensions,\
    \ extensions.map(length))), rev=true)\n    \n    if length(Strongest_Extension_Counter)\
    \ == length(extensions) \n        \n        Strongest_Extension_Counter = Strongest_Extension_Counter[1]\n\
    \        \n    end \n    \n    return string(class_name) + Strongest_Extension_Counter[1]\n\
    end\n</cell>\n<text>\nPart 2: Implementing Extensions and Loaders\nNow that you\
    \ have learned about extension methods and how to implement them, we can implement\
    \ a load method which will load classes specified in the vector extensions. We\
    \ will need to add this load method to all classes in the vector classes.", " \
    \   extensions = sort!(extensions)\n    idx = 1\n    \n    # Loop through extensions\
    \ \n    while idx<=length(extensions)\n        extension = extensions[idx]\n \
    \       uppercase_idx = upper(extension)\n        lowercase_idx = lower(extension)\n\
    \        \n        # Check if the extension is strong\n        strong_extension\
    \ = uppercase_idx-lowercase_idx\n        if strong_extension>0\n            #\
    \ If the extension is strong, return it\n            return class_name . \".\"\
    \ . extension\n        end\n        \n        # Increment idx\n        idx = idx+1\n\
    \    end\nend\n</cell>\n<text>\nProblem 4", "    strengths = map(i->string_length(extensions[i]),\
    \ extensions)\n    idx = argmax(strengths)\n    return class_name + '.' + extensions[idx]\n\
    end", "  strongest_extension = extensions.sorted()[1]\n  strongest_extension =\
    \ strongest_extension.slice(begin, length(extension))\n  return class_name .+\
    \ strongest_extension\nend", "    \"\"\"Solution\n    \"\"\"\n    StrongestExtensionName\
    \ = \"\"\n    StrongestExtension = extensions[end]\n    \n    for extension in\
    \ extensions[2:end]\n        if (StrongestExtension >= extension)\n          \
    \  StrongestExtension = extensions[end]\n        end\n    end\n    \n    for extension\
    \ in extensions[2:end]\n        if (StrongestExtension < extension)\n        \
    \    StrongestExtension = extensions[end]\n        end\n    end\n    \n    StrongestExtensionName\
    \ = class_name .. \".\" .. StrongestExtension\n    return StrongestExtensionName\n\
    end\n</cell>\n<code language=julia-0.6>\n@time Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"]);\n</cell>\n<text>\nQuestion 5\nHow much time did it\
    \ take you to write your own implementation of this problem? If you have not had\
    \ the patience to wait for the right solution, try to come up with a faster solution\
    \ yourself.", "    strongest_extension_index = getindex(extensions, strongest(extensions))\n\
    \    return strongest_extension_index == -1 ? class_name : class_name .. \".\"\
    \ .. \n    extensions[strongest_extension_index]\nend\n</cell>\n<text>\nExercise\
    \ 5\nUsing the above two functions, write a function which takes in a string of\
    \ any length and returns a vector of strings of all possible combinations of the\
    \ given length. This means that if you give your function a string \"ABCD\" and\
    \ a length of 3, then your function should return a vector like this:", "    \n\
    \"\"\"\n    Strongest_Extension(class_name, extensions::Vector{String}, strength::Int)\n\
    \"\"\"", "    \"\"\"\n    You will be given the name of a class (a string) and\
    \ a vector of extensions.\n    The extensions are to be used to load additional\
    \ classes to the class. The\n    strength of the extension is as follows: Let\
    \ CAP be the number of the uppercase\n    letters in the extension's name, and\
    \ let SM be the number of lowercase letters \n    in the extension's name, the\
    \ strength is given by the fraction CAP - SM. \n    You should find the strongest\
    \ extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\n    strongest_extension=extensions[minimum((length(extensions)-extension.(lowercase(extensions))),1)]\n\
    \    return class_name+\".\"+strongest_extension\nend\n</cell>\n<code language=julia-1.5>\n\
    @testset \"strongest_extension\" begin\ntest=Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n@test test == \"my_class.AA\"\n@test test == \"my_class.Be\"\
    \n@test test == \"my_class.CC\"\nend\n</cell>\n<text>\nExtension Example: Loading\
    \ more classes to an existing class\nThe example below demonstrates a class of\
    \ 2 classes that we would like to add to our class named \"my_class\". \nThe first\
    \ class is named \"my_class\" and the second class is named \"Blahblah\". The\
    \ third class is named \"blahblah\". \nWe would like to load the third class to\
    \ the first class named \"my_class\". \nIn other words, we would like to add \"\
    blahblah\" to the class \"my_class\" using the extension \n\"Blahblah\". \nWe\
    \ will call our first class \"my_class\" the \"base\" class and the second class\
    \ \"Blahblah\" the \"extension\" class. \nTo load the third class \"blahblah\"\
    \ to the first class \"my_class\", we will use our extension class \"Blahblah\"\
    .", "    \n    \n    \n    \n    \n    ", "    extension_class = split(class_name)[1]\n\
    \    sorted_extension = sort(extensions, by=length) \n    if length(extensions)\
    \ == 0 \n        return class_name\n    else \n        \n        best_strength\
    \ = Strongest_Extension_Strength(extension_class, extensions)\n        \n    \
    \    best_extension = sorted_extension[Strongest_Extension_Strength(extension_class,\
    \ extensions)] \n        \n        return join((class_name, best_extension)) \n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    Strongest_Extension_Strength(extension_name::String,\
    \ extensions::Vector{String})", "    \n    Strength = length(extensions)\n   \
    \ \n    if Strength == 0 \n        return class_name \n    \n    Extension_Name_Strength\
    \ = Dict{String, Int}()\n    \n    for ext_name in extensions \n        if isuppercase(ext_name)\n\
    \            ext_name = ext_name.toUpperCase()\n        elseif islowercase(ext_name)\n\
    \            ext_name = ext_name.toLowerCase()\n        else\n            continue\n\
    \        \n        \n        if contains(Extension_Name_Strength, ext_name)\n\
    \            Extension_Name_Strength[ext_name] += 1\n        else\n          \
    \  Extension_Name_Strength[ext_name] = 0\n        end\n    end\n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n", "    \n    strongest_extension\
    \ = extensions[1] # We start with the second extension of the class\n    for e\
    \ in extensions[2:length(extensions)] \n        if isupper(e) && islower(strongest_extension)\
    \ \n            strongest_extension = e \n        else if isupper(strongest_extension)\
    \ \n            strongest_extension = strongest_extension\n        else\n    \
    \        break\n    end\n    \n    return string(class_name, strongest_extension)\n\
    end", "    \n    s_extensions = Set(extensions)\n    for s_ext in s_extensions\n\
    \        s_cap = StringLength(s_ext)\n        s_sm = StringLength(class_name)\n\
    \        s_strength = abs(s_cap - s_sm)\n        \n        if s_strength == min(s_strength)\n\
    \            return class_name .+ \".\" + s_ext\n        end\n    end\nend", " \
    \   if extensions.size <= 1\n        return class_name\n    end\n    strength\
    \ = extensions[1] - extensions[1]\n    \n    for e in extensions[2:end]\n    \
    \    strength = strength if e < extension else strength\n    end\n    return join(class_name,\
    \ \".\", Strongest_Extension(class_name, extensions[2:end]))\nend", "    \n  \
    \  extensions_str = join.(extensions, \".\")\n    strongest = extension_strength(extensions_str)\n\
    \    \n    Strongest_Extension_ = join.([class_name, strongest], \".\")\n    \n\
    \    return Strongest_Extension_\nend", "    \n    Strongest_Extension = class_name\
    \ + string(extensions)\n    return Strongest_Extension\nend\n</cell>\n<code language=julia-1.2>\n\
    # test your code\n@code_warntype Strongest_Extension(\"my_class\", [\"AA\", \"\
    Be\", \"CC\"]);\n</cell>\n<text>\nExercise 3\nIn the cell below, define a function\
    \ called is_permutation that takes a character and an alphabet, and checks if\
    \ the character is a permutation of the alphabet.", "    strongest = extensions[1]\n\
    \    for strongest1 in extensions \n        if strongest1 < strongest \n     \
    \       strongest = strongest1\n        end\n    end\n    \n    \"$class_name.$strongest\"\
    \nend\n</cell>\n<code language=julia-1.6>\n# Tests\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]) \u2248 \"my_class.AA\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"]) \u2248 \"my_class.AA\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"ee\", \"ff\", \"gg\"]) \u2248 \"\
    my_class.AA\"\n@test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    , \"DD\", \"ee\", \"ff\", \"gg\", \"hh\"]) \u2248 \"my_class.AA\"\n</cell>\n<text>\n\
    \u25CF Question 12 - Apart from the extension, what is a class?", "    sorted_extensions\
    \ = sort(extensions)\n    strength = 0\n    if length(sorted_extensions) > 1\n\
    \        strength = CAP - SM\n    end", "    extensions_count = count(extensions)\n\
    \    if extensions_count == 0 \n        return class_name\n    elseif extensions_count\
    \ == 1 \n        return class_name + extensions[0]\n    end\n    \n    strongest_extension_strength\
    \ = -1\n    extensions_strongest_strength = [:] #the extensions strongest strength\n\
    \    for e in extensions \n        extension_strength = length(e) - length(lowercase(last(e)))\n\
    \        if extension_strength > strongest_extension_strength\n            strongest_extension_strength\
    \ = extension_strength\n            extensions_strongest_strength = [e]\n    \
    \    else \n            push!(extensions_strongest_strength, e)\n        end\n\
    \    end\n    \n    extensions_strongest_strength = sort(extensions_strongest_strength)\n\
    \    \n    chosen_extension = extensions_strongest_strength[1]\n    chosen_extension\
    \ = lowercase(chosen_extension)\n    \n    return class_name + chosen_extension\n\
    end", "    #your code here\n    return class_name ## add your solution\nend\n\
    </cell>\n<code language=julia-1.5>\n@test Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n</cell>\n<code language=julia-1.5>\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"]) == \"\
    my_class.AA\"\n</cell>\n<code language=julia-1.5>\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"Ee\"]) == \"my_class.AA\"\n</cell>\n\
    <code language=julia-1.5>\n@test Strongest_Extension(\"my_class\", [\"AA\", \"\
    Be\", \"CC\", \"DD\", \"Ee\", \"Ff\"]) == \"my_class.AA\"\n</cell>\n<text>\nWrite\
    \ a function that returns a new instance of the class given its name and extensions\
    \ vector.\n    Example:\n    >>> New(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n\
    \    my_class.AA\n    \"\"\"", "\"\"\"\n@doc strongest_extension\n\"\"\"\n   \
    \ Extension_Names = sort(unique(extensions), by = length) # Get the unique extensions\
    \ and their lengths\n    \n    # Get the number of capital letters in the class\
    \ name and the number of lowercase letters\n    # in the class name\n    CAP_lowercase_letters\
    \ = findall(x->x == x[1], lower(class_name))\n    \n    \n    \n    # Get the\
    \ strongest extension\n    Strength = Inf\n    \n    # Loop over all extensions\
    \ \n    for extension in Extension_Names\n        \n        # Find the number\
    \ of capital letters in extension\n        CAP_extension = findall(x->x == x[1],\
    \ lower(extension))\n        \n        # Find the number of lowercase letters\
    \ in extension\n        SM = length(CAP_extension) - length(CAP_lowercase_letters)\n\
    \        \n        # Compute the strength\n        Strength = min(Strength, CAP_extension.length\
    \ - SM)\n    end\n    \n    # return the class name with the strongest extension\n\
    \    return class_name * \".\" + Strongest_Extension_String(class_name, extensions,\
    \ Strength)\nend\n</cell>\n<code language=julia-1.5>", "    \n    strongest_extension\
    \ = extensions[1]\n    \n    for i in 2:length(extensions)\n        strongest_extension\
    \ = min(strongest_extension, extensions[i])\n    end\n    \n    return class_name\
    \ + \".\" + strongest_extension\nend\n</cell>\n<code language=julia-1.1>\nusing\
    \ Pkg\nPkg.add(\"Plots\")\nPkg.add(\"Interpolations\")\nPkg.add(\"FileIO\")\n\
    Pkg.add(\"Statistics\")\nPkg.add(\"Random\")\nPkg.add(\"RandomMeasurements\")\n\
    Pkg.add(\"CSV\")\nPkg.add(\"DataFrames\")\nPkg.add(\"LinearAlgebra\")\nPkg.add(\"\
    DataFrames\")\n</cell>\n<code language=julia-1.1>\n# Loading the data\ndataframe\
    \ = CSV.read(\"../data/processed.csv\", DataFrame);\n</cell>\n<code language=julia-1.1>",
  "    \n    \n    if length(extensions) == 0 \n        return class_name\n    elseif\
    \ length(extensions) == 1\n        return Strongest_Extension(extensions[0], extensions)\n\
    \    elseif Strongest_Extension(extensions[1], extensions) == \"\" \n        return\
    \ Strongest_Extension(extensions[0], extensions)\n    end\n    \n    strongest_extension\
    \ = extensions[1]\n    for extension in extensions[2:length(extensions)]\n   \
    \     if Strongest_Extension(extension, extensions) == \"\"\n            return\
    \ strongest_extension\n        end\n    end\n    return strongest_extension\n\
    end", "    \"\"\"\n    Strongest_Extension(class_name, extensions)\n    \n   \
    \ Inputs:\n        class_name:  Name of the class we are looking for\n       \
    \ extensions:  Vector containing the extensions name\n        \n    Outputs:\n\
    \        string containing the name of the strongest extension\n    \"\"\"\n \
    \   extension = extensions[minimum(map(x->length(x),extensions))]\n    if length(extension)\
    \ > length(class_name)\n        ext = extension\n    else\n        ext = class_name\n\
    \    end\n    return ext\nend", "    strongest_extension = [extensions[i] for\n\
    \                             i in sortperm(length(extensions))]\n    return String(class_name)\
    \ + strongest_extension[1]\nend", '    ', "    s = 0 \n    for e in extensions\
    \ \n        if toupper(e) .== toupper(class_name) \n            s = s + 1\n  \
    \      end\n    end\n    s = s/length(extensions)\n    for e in extensions \n\
    \        if tolower(e) .== tolower(class_name) \n            s = s + 1\n     \
    \   end\n    end\n    s = s/length(extensions)\n    if s == 0 \n        error(\"\
    no extensions of that class\")\n    end\n    if s == length(extensions) \n   \
    \     error(\"no extensions of that class\")\n    end\n    s = \"%s.%s\"%(class_name,\
    \ extensions[findmin(s)])\n    return s\nend", "    extensions.sort!\n    Strength\
    \ = extensions[1].count() - extensions[0].count()\n    if Strength == -1 \n  \
    \      return class_name\n    elseif Strength == 0 \n        return class_name\n\
    \    else\n        return \"{}.{}{}\".format(class_name, extensions[1], extensions[2])\n\
    \    end\nend\n</code>\n<|/ a |>\n<| c |>\nThis works, however, the method signature\
    \ is incorrect. It should be `Strongest_Extension(class_name::String, extensions::Vector{String})`,\
    \ with one additional `::String` after the `class_name`.\n<|/ c |>\n<| c |>\n\
    Thanks, I have made corrections. And I have also fixed the answer, I misread the\
    \ question and thought you wanted to pass vector of strings as an argument. Thanks\
    \ for pointing this out!\n<|/ c |>\n<| a dscore=1 |>\nThe answer is already given,\
    \ but I will add my 2 cents. \nI find it easier to keep track of the extensions\
    \ separately and then sort them alphabetically later, because sorting them alphabetically\
    \ makes it easier to know which extensions are used the most. \n<code>"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
