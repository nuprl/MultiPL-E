name: HumanEval_11_string_xor
language: jl
prompt: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform\
  \ binary XOR on these inputs and return result also as a string.\n    >>> string_xor(\"\
  010\", \"110\")\n    \"100\"\n    \"\"\"\nfunction string_xor(a::String, b::String)::String\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"\
  111000\", \"101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\
  \t@test(candidate(\"0101\", \"0000\") == \"0101\")\nend\n"
completions: ["    return \"\".join([a [i] ^ b[i] for i in range(min(length(a ),length(b)))])\n\
    end function \"\"\"", "    # check whether a and b are of equal length\n    if\
    \ (length(a) != length(b))\n        throw \"Input strings have to be of same length.\"\
    \n    else\n        xor = zeros(length(a))\n        for i in 1:length(a)\n   \
    \         xor[i] = (a[i] + b[i]) %2\n        end\n        return xor\n    end\n\
    end\n</cell>\n<code language=julia-0.6>", "    string_rep = \"0\"\n    for i in\
    \ each(a):\n        string_rep = string_rep + string_rep[i]\n    for i in each(b):\n\
    \        string_rep = string_rep + string_rep[i]\n    return string_rep\n</code>\n\
    <|/ a |>\n<| a tags=xor,julia dscore=1 |>\nHere's a short solution:\n<code>",
  "    if a==\"\" || b==\"\"\n        return \"\"\n    elseif a==b\n        return\
    \ a\n    else\n        return string_xor(a[1:], b) + a[0]\nend\n</cell>\n<code\
    \ language=julia-1.4>\nstring_xor(\"010\", \"110\")\n</cell>\n<text>\nThe XOR\
    \ operation is a commutative operation. \nThis means we can perform two operations\
    \ on the same string and get the same results.", "    return bin(int(a,2) ^ int(b,2))[2:]\n\
    end\n</cell>\n<code language=julia-1.4>", "        return bin(Int64(a) xor Int64(b))\n\
    \"\"\"", "    if length(a) > length(b) then \n        repeat(b,length(a)-length(b),\"\
    \")\n    else\n        repeat(a,length(b)-length(a),\"\")\n    end\n    for i\
    \ in 1:length(a)\n        replace(b,i,i,a[i])\n    end\n    reverse(b)\n    return\
    \ join(\"\",b)\nend", "    binstr::String = \"0\"*a.len + b\n    binstr.length\
    \ = a.len + b.len\n    binstr[1:a.len] = a[1:a.len]\n    binstr[a.len+1:b.len]\
    \ = b[1:b.len]\n    return binstr\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n\
    In your solution you simply add 2 more chars (0 and 1) at index 0 and 1 of your\
    \ string and then print the string. But the issue is how you will print your result\
    \ string. Since you are using recursion to print the string, the final string\
    \ will be printed by your recursive function and it will print only 2 chars instead\
    \ of the full string length.\nTo solve your problem, I have created 2 helpers\
    \ function print0 and print1 which prints 0 and 1 respectively based on the index\
    \ value.\n<code>", "  \"\"\" Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \"\"\"", " \
    \   if length(a) != length(b) then return \"Invalid inputs\"\n    else return\
    \ chars_to_string(reverse(chars_to_string(a) ^ chars_to_string(b)))\nend", " \
    \   \n    \n    if length(a) > length(b) \n        a, b = b, a # swap strings\
    \ to get lengths\n    \n    return b[(length(a)-length(b)).*.&.(ascii(a) .==.\
    \ ascii(b))]\nend\n\"\"\"\n    \n\"\"\"\n## Part 3: Binary operations on two binary\
    \ strings\n\"\"\"\n\"\"\"\n## Part 4: Binary operations on two binary strings\n\
    \"\"\"\n\"\"\"\n## Part 5: Binary operations on two binary strings: bitwise OR\n\
    \"\"\"\n\"\"\"\n## Part 6: Binary operations on two binary strings: bitwise AND\n\
    \"\"\"\n\"\"\"\n## Part 7: Binary operations on two binary strings: bitwise XOR\n\
    \"\"\"\n\"\"\"\n## Part 8: Binary operations on two binary strings: bitwise NOT\n\
    \"\"\"\n\"\"\"\n## Part 9: Binary operations on two binary strings: bitwise right\
    \ shift\n\"\"\"\n\"\"\"\n## Part 10: Binary operations on two binary strings:\
    \ bitwise left shift\n\"\"\"\n\"\"\"\n## Part 11: Binary operations on two binary\
    \ strings: bitwise AND and bitwise OR\n\"\"\"\n\"\"\"\n## Part 12: Binary operations\
    \ on two binary strings: bitwise XOR and bitwise NOT\n\"\"\"\n\"\"\"\n## Part\
    \ 13: Binary operations on two binary strings: bitwise AND and bitwise XOR\n\"\
    \"\"\n\"\"\"\n## Part 14: Binary operations on two binary strings: bitwise AND\
    \ and bitwise NOT\n\"\"\"\n\"\"\"\n## Part 15: Binary operations on two binary\
    \ strings: bitwise OR and bitwise AND\n\"\"\"\n\"\"\"\n## Part 16: Binary operations\
    \ on two binary strings: bitwise OR and bitwise XOR\n\"\"\"\n\"\"\"\n## Part 17:\
    \ Binary operations on two binary strings: bitwise AND and bitwise NOT\n\"\"\"\
    \n\"\"\"\n## Part 18: Binary operations on two binary strings: bitwise OR and\
    \ bitwise NOT\n\"\"\"\n\"\"\"\n## Part 19: Binary operations on two binary strings:\
    \ bitwise NOT\n\"\"\"\n\"\"\"\n## Part 20: Binary operations on two binary strings:\
    \ bitwise AND and bitwise NOT\n\"\"\"\n\"\"\"\n## Part 21: Binary operations on\
    \ two binary strings: bitwise AND and bitwise NOT\n\"\"\"\n\"\"\"\n## Part 22:\
    \ Binary operations on two binary strings: bitwise XOR and bitwise NOT\n\"\"\"\
    \n\"\"\"\n## Part 23: Binary operations on two binary strings: bit", "    return\
    \ \"\"\nend", "  return a.chars.zip(b).map(|(a,b)| (a ^ b)).collect{|a| a.to_s(2)}\n\
    end\n</cell>\n<code language=julia-0.6>\n@assert string_xor(\"010\", \"110\")\
    \ == \"100\"\n</cell>\n<text>\nExercise 5\nDefine two functions to convert a binary\
    \ string to a decimal integer and the reverse of that.", "    return String(a)\
    \ ^ String(b) \nend \n</cell>\n<code language=julia-1.1>\n\"\"\"\n    binary_iand(A,\
    \ B) -> A bitwise AND B", "    answer = \"\"\n    for ele in a\n        answer\
    \ += ele\n        for ele2 in b\n            answer += ele2\n    end\n    return\
    \ answer\nend", "    if a.length != b.length then \n        throw(ArgumentError(\"\
    a and b must contain same number of characters.\"))\n    \n    res = \"\"\n  \
    \  for i in 0..a.length-1\n        res <- res + tostring(a[i]) ^ tostring(b[i])\n\
    \    return res\nend\n</cell>\n<code language=julia-1.4>\n\"\"\" Input are two\
    \ strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these\
    \ inputs and return result also as a string.\n    >>> string_xor(\"010\", \"110\"\
    )\n    \"100\"\n    \"\"\"", "        \"\"\"\" Perform binary XOR of two strings.\n\
    \        \n        Inputs are two strings a and b consisting only of 1s and 0s.\n\
    \        Return result also as a string.\n        \"\"\"\n    return to_string(\
    \ (string_to_int(a) ^ string_to_int(b)) % 2)\nend", "    # check whether string\
    \ is empty\n    if length(a) == 0 || length(b) == 0 \n        return \"\"\n  \
    \  # convert inputs to char arrays\n    a_c = [ord(x[0]) for x in a.split()]\n\
    \    b_c = [ord(x[0]) for x in b.split()]\n    # init result\n    res = \"\"\n\
    \    # perform XOR\n    for k in range(length(a)):\n        if a_c[k] == b_c[k]:\n\
    \            res += chr((a_c[k] ^ b_c[k]))\n    return res\nend\n</cell>\n<code\
    \ language=julia-0.5>\n# test the function\n@code_warntype string_xor(\"010\"\
    , \"110\")\n</cell>\n<text>\nTask 2: Binary AND\nInputs: two strings a and b consisting\
    \ only of 1s and 0s. Perform binary AND on these inputs and return result also\
    \ as a string.", "    # Convert string to binary array\n    ba = binary.str2binary(a)\n\
    \    bb = binary.str2binary(b)\n    # Perform the XOR\n    return binary.bin2str(binary.xor(ba,\
    \ bb))", "    return a .+ b .+ a .+ b .+ a .+ b .+ a .+ b .+ a .+ b .+ a .+ b\
    \ .+ a .+ b .+ a .+ b .+ a .+ b .+ a .+ b .+ a .+ b .+ a .+ b\nend", "    return\
    \ a.chars.zip b.chars |> List.foldl binary_xor \"\" \nend ", "    if length(a)\
    \ > length(b)\n        a,b = b,a\n    end\n    return join( map(xor, a, b), \"\
    \" )\nend", "    result =\"\"\n    for character in a\n        result = result\
    \ + character.getbit(1) * character.getbit(2)\n    return result\nend", "    if\
    \ length(a) != length(b) then return \"\" else return a ^ b\nend # end of string_xor\n\
    </cell>\n<cell>\n# Tests\nassert(string_xor(\"010\", \"110\") == \"100\")\nassert(not\
    \ string_xor(\"010\", \"101\"))\n</cell>\n<text>\nExercise 5\nWrite a function\
    \ that converts a number to its base 10 representation.\nIt should work for any\
    \ integer input that can fit into memory and return a string representation of\
    \ that number.", "    if is_binary(a) && is_binary(b)\n        return binary_xor(a,\
    \ b)\n    end", "    binary_result = string_to_int_array(string_xor(a::String,\
    \ b::String))\n    return int_array_to_string(binary_result)\nend", "    string_xor\
    \ = a ^ b\n    return string_xor\nend", "    binary_a = binary_string(a)\n   \
    \ binary_b = binary_string(b)\n    res = \"\"\n    for ii in 1:length(binary_a)\n\
    \        res = res + binary_a[(ii-1)*length(binary_a)+ii] ^ binary_b[(ii-1)*length(binary_b)+ii]\n\
    \    end\n    return res\nend\n</code>\n<|/ a tags=binary,xor,string,julia |>\n\
    <| c |>\nNice solution. I am not familiar with the @. syntax.\n<|/ c |>\n<| c\
    \ |>\nNo problem with @. it just makes the function shorter\n<|/ c |>\n<| c |>\n\
    `@` is used to pass function arguments by name instead of position. I use it here\
    \ to reduce the number of times `binary_string` is called and it also makes it\
    \ more readable.\n<|/ c |>\n<| a dscore=2 |>\nI wrote a function that implements\
    \ string_xor and string_xor_naive suggested in previous answers:\n<code>", " \
    \   if is_binary(a) || is_binary(b) then \n        if strcmp(a,b) == 0 then \n\
    \            return \"\"\n        else \n            throw ErrorException(\"invalid\
    \ input\")\n    else if is_number(a) || is_number(b) then \n        return string_number_xor(a,\
    \ b)\n    else \n        throw ErrorException(\"invalid input\")\nend\n</cell>\n\
    <code language=julia-0.5>\n\"\"\"Perform binary XOR on two numbers a and b using\
    \ XOR over all bits in binary representation.\nInput are two numbers a and b consisting\
    \ of only 1s and 0s.\nReturn binary XOR of inputs as string.\n\"\"\"", "    #\
    \ To avoid runtime error when input is an empty string.\n    if isempty(a) ==\
    \ isempty(b)\n       return \"\"\n    end\n    \n    # Binary XOR of two strings\
    \ is the result string formed by the \n    # application of the logical XOR function\
    \ to each element of \n    # the strings, from left to right.\n    return String.(zip(String.(a),String.(b)))\
    \ |> zip |> map do \n        (a,b) -> (xor_of(a[1]) .== xor_of(b[1])) |> Base.all_true\n\
    \    end\nend\n</code>\nYou can now run the function and get the result\n<code>\n\
    # Running StringXor() function\nStringXor(\"010\", \"110\")\n</code>\nThe output\n\
    <code>\n# Output is 100\n\"100\"\n</code>\n<|/ a tags=julia |>\n<| c |>\n`map`\
    \ should be replaced with `filter`.\n<|/ c |>\n<| c |>\n: Nope. The output is\
    \ the same either way.\n<|/ c |>\n<| a tags=julia |>\nHere's another solution:\n\
    <code>\njulia> function string_xor(a::String, b::String)::String \n          \
    \   return map(i -> xor(a[1], i[1]), zip(a, b))\n         end\nstring_xor (generic\
    \ function with 1 method)", "    return string_to_binary(string_to_binary(a) xor\
    \ string_to_binary(b)) \nend\n\"\"\"\n### Sum over an alphabet\n\"\"\"", "   \
    \ if length(a) > length(b) \n        a, b = b, a\n    end\n    # convert to ints\
    \ \n    a, b = map(xor(a[i], b[i]), i, 1, length(a))\n    return convertbits(a,\
    \ length(a), length(b))\nend\n</cell>\n<text>\nExercise 5\nImplement the function\
    \ invert() which takes as input a string containing only 1s and 0s and returns\
    \ the string with all 0s except for 1s.", "    if a && b \n        return b ^\
    \ a\n    end\n    return \"ERROR\"\nend\n</cell>\n<code language=julia-1.5>\n\"\
    \"\"\n    bin2dec\n    convert binary string to decimal number\n    Input:\n \
    \       bin: string\n    Output:\n        dec : decimal number\n\"\"\"", "   \
    \ if (length(bits(a)) != length(bits(b))) \n        raise AssertionError(\"Lengths\
    \ must be equal\")\n    else\n        len = length(bits(a))\n        arr = zeros(len)\n\
    \        arr[(bits(a)==\"1\") & (bits(b)==\"1\")] = 1\n        return arr\n  \
    \  end\nend", "  result =String.empty\n  for elt in a\n    result += \"0\" * (4\
    \ - elt.length) + elt\n  for elt in b\n    result += \"0\" * (4 - elt.length)\
    \ + elt\n  return result", "    s = \"\"\n    for i in each(a) do \n        s\
    \ << i == \"0\"? b : \"1\"\n    end\n    return s\nend\n</cell>\n<code language=julia-1.4>",
  "    if a==b\n        return \"0\"\n    else if a == \"0\"\n        return \"1\"\
    \n    else\n        return \"1\"\n    end\nend\n</cell>\n<code language=julia-0.5>\n\
    @code_warntype string_xor(\"010\", \"110\")\n</cell>\n<code language=julia-0.5>",
  "    if length(a) > length(b) then \n        tmp = a \n        a = b\n        b\
    \ = tmp\n    end\n    # XOR is performed bit by bit \n    xorresult::String =\
    \ String.zeros(length(a))\n    for (i, bit) in enumerate(a) do \n        xorresult[i]\
    \ = xorresult[i]^bit\n    end\n    return xorresult\nend", "    if isempty(a)\
    \ || isempty(b)\n        return emptystring\n    end\n    result = a\n    for\
    \ e in b\n        result = result ^ e\n    end\n    return result\nend\n</cell>\n\
    <code language=julia-0.6>\n# Test the string_xor function\nprintln(string_xor(\"\
    100\", \"010\"))\n</cell>\n<text>\nQuestion 2\nA Python programmer has decided\
    \ to write a new module called string.py. In string.py, define a function called\
    \ string_xor_2 that performs binary XOR on two strings given as arguments.", " \
    \ bin1 = bin(a)\n  bin2 = bin(b)\n  xor_result = bin1 .&. bin2\n  return xor_result[2:length(xor_result)]\n\
    end", "    return binary_xor.(decode_base10(a), decode_base10(b))\n</code>\n<|/\
    \ a dscore=4 |>\n<| a dscore=2 |>\nFor those of you who are curious about the\
    \ performance of solutions proposed here on benchmarks posted in other answers:\n\
    First the setup for the benchmarks:\n<code>\nimport numpy as np\nfrom numba import\
    \ autojit\nfrom numba.types import UniTuple", "    if a != \"\" && b != \"\"\n\
    \        a_int = tonumber(a) \n        b_int = tonumber(b)\n        \n       \
    \ # handle special case\n        if a_int == b_int\n            return string_xor(b,a)\n\
    \            \n        # handle normal case\n        if a_int % 2 == 0 && b_int\
    \ % 2 == 0\n            return string_xor(a ^ b, b)\n        \n        # handle\
    \ special case where a_int % 2 == 0\n        if a_int % 2 == 0\n            return\
    \ string_xor(a ^ string_xor(b,b),b)\n        \n        # handle special case where\
    \ b_int % 2 == 0\n        if b_int % 2 == 0\n            return string_xor(string_xor(a,a),b)\n\
    \        \n    end\n    return \"\"\nend\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"\n    bin2dec(s::String)::Int64", "    l = length(a) \n    ret = String[l\
    \ - 1 : 1 : -1] \n    for j = 0 : -1\n        for i = 2 to l + 1 \n          \
    \  ret[j] = ret[j] ^ a[i-j] \n    endfor \n    return ret \nendfunction \n</cell>\n\
    <code language=julia-1.4>", "    \n\"\"\"\n    Inputs are two integers a and b\
    \ represented as strings.\n    Perform binary OR on these inputs and return result\
    \ also as a string.\n    >>> string_or(\"010\", \"110\")\n    \"110\"\n\"\"\"",
  '    return strcat(a, string(b)) end', "    return ''.join([chr(int(i) ^ int(j))\
    \ for i, j in zip(a,b)])", "  return xor_string(a,b)\nend \n</cell>\n<text>\n\
    Strings and Binary Operations\nYou can do binary operations on strings. For example:",
  "    # check if inputs are all characters or not\n    if sum(b) /= len(b)\n    \
    \    error(\"both strings must be of equal length.\")\n    elseif sum(a) /= len(a)\n\
    \        error(\"both strings must be of equal length.\")\n    elseif sum(a) !=\
    \ sum(b)\n        error(\"the sum of the two strings must equal the length of\
    \ the string.\")\n    # check if all the characters are 1s or not\n    elseif\
    \ all(elem == \"1\" for elem in a)\n        error(\"both strings must consist\
    \ of 0s.\")\n    elseif all(elem == \"0\" for elem in b)\n        error(\"the\
    \ two strings must consist of 1s.\")\n    # convert to binary array\n    array_a\
    \ = dec2bin(a)\n    array_b = dec2bin(b)\n    # XOR them \n    ans = bin2dec(string_xor(array_a,\
    \ array_b))\n    # return to string\n    return dec2str(ans)\nend\n</cell>\n<code\
    \ language=julia-1.0>\n# test string_xor\n@test string_xor(\"010\", \"110\") ==\
    \ \"100\"\n</cell>\n<text>\nProblem 4: Implementing Triangle II \nIn this problem\
    \ we will develop a program to find the smallest triangle (smallest side that\
    \ has all the sides equal) to form a right triangle (all the sides are equal)\
    \ of a given triangle. It is assumed that no triangle has zero sides.", "    return\
    \ bin(a) ^ bin(b)\n</code>\nNow the XOR operation can be performed on binary strings:\n\
    <code>", "    bina = binarize(a)\n    binb = binarize(b)\n    binxored = bina\
    \ ^ binb\n    return binxored.to_string(base=2)\nend\n</cell>\n<code language=julia-1.6>\n\
    string_xor(\"010\", \"110\")\n</cell>\n<text>\n3.1 Write a Julia function called\
    \ string_bit that takes as input a string and a bit, and returns the corresponding\
    \ string.\nFor example, string_bit(\"101\", 1) should return \"01\".", "    if\
    \ length(a) != length(b) \n        error(\"Inputs must consist of same number\
    \ of characters\")\n    end\n    chars = zeros(Int, length(a))\n    for (i,c)\
    \ in enumerate(a)\n        chars[i] = chars[i] || b[i]\n    end\n    return join(chars,\
    \ \"\")\nend\n</cell>\n<code language=julia-1.5>\nstring_xor(\"01101\", \"10101\"\
    )\n</cell>\n<code language=julia-1.5>\nstring_xor(\"00010\", \"10101\")\n</cell>\n\
    <code language=julia-1.5>\nstring_xor(\"00010\", \"101010\")\n</cell>\n<code language=julia-1.5>",
  "    if a == \"0\" and b == \"0\"\n        return \"0\"\n    elseif a == \"1\" and\
    \ b == \"0\"\n        return \"1\"\n    elseif a == \"1\" and b == \"1\"\n   \
    \     return \"1\"\n    else\n        return \"0\"\n    end\nend\n</cell>\n<text>\n\
    Implement the functions string_xor(a::String, b::String) and string_and(a::String,\
    \ b::String) using recursive algorithm, and print the result of both functions.\n\
    Hint: You may use string_xor(a::String, b::String) and string_and(a::String, b::String)\
    \ directly.", "    if length(a) < length(b) || length(a) > length(b) then\n  \
    \      throw(ArgumentError(\"a cannot be longer than b\"))\n    else if length(a)\
    \ == length(b) then\n        \"\"\n    else if a == b then\n        \"\"\n   \
    \ else\n        c = \"\"\n        for i in a:\n            c += i\n          \
    \  c += b\n        return c\n    end\nend\n</cell>\n<code language=julia-0.6>",
  "    s = \"\"\n    for i in a:\n        if i == \"1\":\n            s = s + b[i]\n\
    \    return s\nend", "   \n    # a is string with 1's and 0's only\n    # b is\
    \ string with 1's and 0's only\n    \n    a_str = a\n    b_str = b\n    \n   \
    \ a_length = length(a_str)\n    b_length = length(b_str)\n    \n    # create an\
    \ empty string of the same length\n    # that has all zeros \n    \n    result_str\
    \ = \"\"\n    \n    if a_length == 0 or b_length == 0:\n        return \"\"\n\
    \    else\n        if a_str[0] != b_str[0]:\n            result_str = result_str\
    \ + \"1\"\n            \n        for i in range(1, length(a_str)):\n         \
    \   if a_str[i] != b_str[i]:\n                result_str = result_str + \"0\"\n\
    \            end\n        end\n        \n        return result_str\n    end\n\
    end", "    if length(a) != length(b) \n        error(\"a and b are not of same\
    \ length\")\n    else\n        resString = \"\"\n        for i in eachindex(a)\n\
    \            resString += (a[i] xor b[i]) \n    end\n    return resString\nend\n\
    </cell>\n<code language=julia-0.3>", "    # Your code goes here\n    return \"\
    \"", "    if a == b\n        return a \n    else \n        return xor(a, b)\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\nstring_xor(\"010\", \"110\"\
    )\n</cell>\n<text>\nProblem 2\nGiven a string s, return the number of times the\
    \ character\nappears consecutively (starting with 0) in the string. If there\n\
    are two consecutive characters, return their counts.", "    a = a.decoded \n \
    \   b = b.decoded\n    return \"\".join(i for i in a if not i in b) end\nend\n\
    </cell>\n<code language=julia-1.5>\n# Define XOR function\n\"\"\"\n    string_xor(a::String,\
    \ b::String)::String", "    \"\"\"\n    Input are two strings a and b consisting\
    \ only of 1s and 0s.\n    Perform binary XOR on these inputs and return result\
    \ also as a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \"\
    \"\"\n    return xor_strings(a, b)\n</code>\n<|/ a |>\n<| c |>\nThanks for your\
    \ help. It seems there might be some typo in the code. I tried running it but\
    \ still got the error message: No function matches for string_xor(String{String},\
    \ String{String})\n<|/ c |>\n<| c |>\nI see you've edited the code. I've edited\
    \ my answer. Try it now.\n<|/ c |>\n<| c |>\nThe code works, thanks! However,\
    \ I think there is a typo in the original code: ```xor_strings(a, b)::String```\
    \ should be ```xor_strings(a, b)::String``` and the function should be ```string_xor```\n\
    <|/ c |>\n<| c |>\nIt was a typo in the question. I've edited it now. Thanks for\
    \ letting me know.\n<|/ c |>\n<| c |>\nYour solution is much nicer - I like it.\
    \ Note that `xor_strings` is basically identical to `string_borrow`, so you can\
    \ also write `xor_strings = string_borrow(xor_strings, xor_strings)`.\n<|/ c |>\n\
    <| a dscore=4 |>\nIf you don't mind having to use Pandas, then you can use the\
    \ following:\n<code>\ndef string_borrow(A, B):\n    A = A.to_frame(name='A')\n\
    \    B = B.to_frame(name='B')", "    if a==\"\" or b==\"\" then return \"\"\n\
    \    if a==b then return a\n    if a==\"1\" and b==\"1\" then return \"0\"\n \
    \   if a==\"0\" and b==\"1\" then return \"1\"\n    if a==\"1\" and b==\"0\" then\
    \ return \"0\"\n    if a==\"0\" and b==\"0\" then return \"0\"\n    if a==\"1\"\
    \ and b==\"1\" then return \"1\"\n    if a==\"0\" and b==\"1\" then return \"\
    1\"\n    if a==\"1\" and b==\"0\" then return \"1\"\n    if a==\"0\" and b==\"\
    0\" then return \"1\"\n    return \"\"", "    return a xor b\nend\n</cell>\n<code\
    \ language=julia-1.5>\nstring_xor(\"010\", \"110\")\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\nXOR of a and b\n\"\"\"", "    z = xor(a,b)\n    \n    return z", "   \
    \ return (chars(a) ^ chars(b)).to_string()\nend", "    \n    a_int = unpack(\"\
    Uint128\", a)\n    b_int = unpack(\"Uint128\", b)\n    \n    a_int = a_int^b_int\n\
    \    \n    return pack(\"Uint128\", a_int)\nend", "    a::Int \n    b::Int \n\
    \    answer::String\n    answer::Int", "  return String.replace(String.replace(a,\
    \ \"0\", \"x\"), \"1\", \"y\") \nend\n</code>\n<|/ a |>\n<| a dscore=1 |>\nWe\
    \ can also use Base.decode.\n<code>\njulia> Base.decode(Base.decode(\"01010010\"\
    ))\n\"1010010\"\n</code>\n<|/ a tags=julia,string |>\n<| c |>\nNice, but note\
    \ that `Base.decode` is not limited to strings. You can simply use it to decode\
    \ binary data.\n<|/ c |>\n<| a |>\nI wrote the following function since I needed\
    \ to decode the binary output of a hardware device. My device was an ARM processor\
    \ with firmware that returned binary data. This code should work for you too:\n\
    <code>", "        \n    if strlen(a)!=strlen(b) then \n        error(\"Mismatch\
    \ between strings a and b\") \n    end\n    \n    local res::String\n    local\
    \ count::Int\n    \n    for i=0,strlen(a) do\n        if a[i]==b[i] then\n   \
    \         count+=1\n        else\n            if count>1 then\n              \
    \  res[count-1]=a[count-1]\n            end\n            count=1\n        end\n\
    \    end\n    if count>1 then\n        res[count-1]=a[count-1]\n    end\n    return\
    \ res\nend\n</cell>\n<code language=julia-1.5>", "    a = convert(a)\n    b =\
    \ convert(b)\n    \n    res = \"\"\n    for (i,char) in enumerate(a):\n      \
    \  if char == \"1\" ^ b[i] == \"1\":\n            res += \"1\"\n        else:\n\
    \            res += \"0\"\n    return res", "    if length(a) == length(b) then\
    \ \n        for i in a:\n            yield i ^ (a[i])\n    else \n        return\
    \ \"error\"\nend \n</code>\n<|/ a tags=julia,string dscore=1 |>\n<| c |>\nThe\
    \ function doesn't return anything! It should be returning something other than\
    \ `none`, but even if it did it would be wrong.\n<|/ c |>\n<| c |>\n: Thanks for\
    \ pointing out! I corrected my code accordingly.\n<|/ c |>\n<| c |>\nOkay, now\
    \ it's correct, but still doesn't do what it's supposed to. You need to return\
    \ `b`. And what about your `if` statement?\n<|/ c |>\n<| c |>\n: As mentioned,\
    \ I didn't try to code it (just copy pasted from somewhere). Please let me know\
    \ if you find any problem with my answer.\n<|/ c |>\n<| c |>\n: I have corrected\
    \ my code now. I hope this time it works as expected.\n<|/ c |>\n<| a |>\nHere\
    \ is a one-liner that avoids looping over the strings:\n<code>\njulia> binxor(\"\
    101\", \"0110\")\n\"110\"\n</code>\nThe binxor function is defined in the Base\
    \ package.\n<|/ a dscore=1 tags=julia,string |>\n<| c |>\nThis is very close to\
    \ being an answer but it doesn't solve the problem of not using loops. I think\
    \ you should remove the loop and add an explanation of what's going on here.\n\
    <|/ c |>\n<| a |>\nThis might not be the most elegant solution but it is a solution\
    \ nonetheless:\n<code>", "    \n    string_xor = a\n    string_xor = string_xor\
    \ * \"0\"\n    string_xor = string_xor + b\n    string_xor = string_xor * \"0\"\
    \n    string_xor = string_xor + \"0\"\n    return string_xor", "    if length(A)\
    \ > length(b) \n        return string_xor(b, a)\n    elseif length(a) > length(b)\
    \ \n        return string_xor(a, b)\n    elseif a==b\n        return a\n    elseif\
    \ length(A) == 0 && length(b) == 0 \n        return \"0\"\n    else\n        return\
    \ \"\"\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    string_xor", "  \
    \  if a==\"\" || b==\"\"\n        return \"\"\n    else \n        \n        #\
    \ Concatenating both strings to make long string\n        long_str = a + b", " \
    \   result = \"\"\n    for (ach1, ach2) in zip(a,b):\n        if ach1 != ach2:\n\
    \            result += \"1\"\n        else:\n            result += \"0\"\n   \
    \ return result\n    \n@test string_xor(\"010\", \"110\") == \"100\"\n    \n\"\
    \"\"\n    >>> string_xor(\"0010\", \"0110\") == \"0011\"\n    True\n\"\"\"", " \
    \ \n    if a==\"\" or b==\"\" then\n        return \"\"\n    end", "    charmap\
    \ = [\"\"]\n    for (i,c) in enumerate(a):\n        charmap[c] = b[i]\n    return\
    \ \"\".join(charmap)\nend", "    if length(a) == length(b) then\n        result\
    \ = \"\"\n        for i in a:\n            if(a[i] != b[i]) then\n           \
    \     result += a[i]\n            end\n        end\n        return result\n  \
    \  end\n    return \"\"\nend\n</cell>\n<code language=julia-1.4>\n## @show string_xor(\"\
    010\", \"110\")\n</cell>\n<code language=julia-1.4>\n@testset \"Binary XOR\" begin\n\
    \    \n    # Test 1\n    eq!(string_xor(\"111\", \"010\"), \"\")\n    eq!(string_xor(\"\
    110\", \"010\"), \"010\")\n    \n    # Test 2\n    eq!(string_xor(\"111\", \"\
    010\"), \"010\")\n    eq!(string_xor(\"110\", \"010\"), \"\")\n    \n    # Test\
    \ 3\n    eq!(string_xor(\"111\", \"010\"), \"010\")\n    eq!(string_xor(\"110\"\
    , \"010\"), \"\")\n    \n    # Test 4\n    eq!(string_xor(\"111\", \"010\"), \"\
    010\")\n    eq!(string_xor(\"110\", \"010\"), \"010\")\n    \n    # Test 5\n \
    \   eq!(string_xor(\"111\", \"010\"), \"010\")\n    eq!(string_xor(\"110\", \"\
    010\"), \"010\")\n    \n    # Test 6\n    eq!(string_xor(\"111\", \"010\"), \"\
    010\")\n    eq!(string_xor(\"110\", \"010\"), \"110\")\n    \n    # Test 7\n \
    \   eq!(string_xor(\"111\", \"010\"), \"010\")\n    eq!(string_xor(\"110\", \"\
    010\"), \"110\")\n    \n    # Test 8\n    eq!(string_xor(\"111\", \"010\"), \"\
    010\")\n    eq!(string_xor(\"110\", \"010\"), \"110\")\n    \n    # Test 9\n \
    \   eq!(string_xor(\"111\", \"010\"), \"010\")\n    eq!(string_xor(\"110\", \"\
    010\"), \"110\")\n    \n    # Test 10\n    eq!(string_xor(\"111\", \"010\"), \"\
    010\")\n    eq!(string_xor(\"110\", \"010\"), \"110\")\n    \n    # Test 11\n\
    \    eq!(string_xor(\"111\", \"010\"), \"010\")\n    eq!(string_xor(\"110\", \"\
    010\"), \"110\")\n    \n    # Test 12\n    eq!(string_xor(\"111\", \"010\"), \"\
    010\")\n    eq!(string_xor(\"110\", \"010\"), \"110\")\n    \n    # Test 13\n\
    \    eq!(string_xor(\"111\", \"010\"), \"010\")\n", "    #a xor b is string\n\
    \    \n    #Convert the string a to binary number array of bit positions\n   \
    \ bit_positions = map(bit_position,a)", "    return \"\"\nend", "    if a == \"\
    0\" & b == \"0\" or a==\"1\" && b == \"1\" \n        then \"1\" \n        else\
    \ \"0\"\n    end\nend\n</cell>\n<code language=julia-1.5>\nstring_xor(\"010\"\
    , \"110\")\n</cell>\n<text>\nExercise: Implementation of string_xor\nImplement\
    \ string_xor() function using only single if statement.", "    if a==\"\" then\n\
    \        return b\n    else\n        if b==\"\" then\n            return a\n \
    \       else\n            if a==b then\n                return a\n           \
    \ else\n                return string_xor(sub_string(a, b, 1)+sub_string(b, a,\
    \ 1), b)\n            end\n        end\n    end\nend\n</code>\n<|/ a dscore=1\
    \ tags=string,xor,haskell |>\n<| a dscore=1 |>\nIn Haskell, the type of (==) ::\
    \ Eq a => a -> a -> Bool is only defined for two types that have a compatible\
    \ definition of (==). String and Int are two different types, and you can't give\
    \ == a more restricted type signature.\nThe simple solution would be to just use\
    \ integer operations on the strings:\n<code>\nstringXOR :: String -> String ->\
    \ String\nstringXOR a b = b ++ [a] ++ [b]\n</code>\nHowever, it might be more\
    \ efficient to convert them to lists of characters and then use (==) on the lists.\
    \ In fact, in this case (I think) using (==) will be faster.\n<code>\nstringXOR'\
    \ :: String -> String -> String\nstringXOR' a b = b ++ [a,a] ++ [b]", '    return
    binary_xor(a, reverse_of(b))', "    if a == \"\" || b == \"\" \n        throw(string(\"\
    One or both strings are empty.\"))\n    elseif all(a != \"\" && b != \"\")\n \
    \       throw(string(\"Both the strings are empty.\"))\n    elseif all(c in \"\
    010\" for c in a) && all(c in \"010\" for c in b)\n        return str((a ^ b))\n\
    \    else\n        throw(string(\"Input contains characters that are not 1 or\
    \ 0.\"))\n    end\nend\n</cell>\n<code language=julia-1.2>", "    if ischar(a)\
    \ && ischar(b) then \n        if ischar(a) == ischar(b) then \n            if\
    \ a[0] == b[0] and a[1] == b[1] then return a[2] \n            else return \"\
    0\"\n        else return \"0\"\n    else return \"0\"\nend\n</cell>\n<code language=julia-1.5>\n\
    string_xor(\"010\", \"110\")\n</cell>\n<text>\nWrite a generic function is_palindrome\
    \ that checks if a string is a palindrome.", "    if a==\"\" || b==\"\" then return\
    \ \"\" end\n    \n    if a==b  then return \"0\" end\n    \n    if a==\"1\" &&\
    \ b==\"1\" then return \"1\" end\n    \n    if a==\"1\" && b==\"0\" then return\
    \ \"0\" end\n    \n    if a==\"0\" && b==\"1\" then return \"1\" end\n    \n \
    \   if a==\"0\" && b==\"0\" then return \"0\" end\nend\n</cell>\n<text>\nSolution\n\
    Your solution should use one of the two functions above.", "    return join(a,\
    \ map(xor, a, b))\n</code>\n<|/ a tags=string,haskell |>\n<| a tags=string,haskell\
    \ |>\nYet another possible solution:\n<code>\nimport Data.Char\nimport Data.List\
    \ (intercalate)", "    s_a = '0' == a\n    s_b = '0' == b\n    if s_a || s_b\n\
    \        return '0'\n    elseif s_a\n        return '1'\n    elseif s_b\n    \
    \    return '0'\n    end\nend\n\"\"\"\n    We will need this when doing arithmetic\
    \ operations.\n\"\"\"", "    \n    if length(a) == 0 || length(b) == 0 \n    \
    \    error(\"input length must be > 0\")\n    end\n    \n    # XOR on binary strings\
    \ is same as XOR on decimals\n    # e.g. 101 ^ 100 = 11\n    \n    binstringa\
    \ = bin(a)[2:end-1]\n    binstringb = bin(b)[2:end-1]\n    \n    result = bin(string_to_int(binstringa)\
    \ xor string_to_int(binstringb))[2:end-1]\n    \n    return result\nend\n</cell>\n\
    <code language=julia-1.0>\n# Test case", "    \"\"\" Binary XOR operation on input\
    \ strings \"\"\" \n    a_bin = bin2dec(a)\n    b_bin = bin2dec(b)\n    return\
    \ dec2bin(a_bin ^ b_bin)", "    string_xor = a & b\n    return string_xor\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 tags=julia,bitwise-operators,bit-manipulation,string\
    \ |>\nTo do bitwise operations on string you just need to convert to bits.\n<code>",
  "    a = binary(a)\n    b = binary(b)\n    result = binary(a) ^ binary(b)\nend\n\
    </cell>\n<code language=julia-1.3>", "\tbinstring1 = binstring(a)\n\tbinstring2\
    \ = binstring(b)\n\tbinstring3 = binstring1 .| binstring2 \n\tbinstring4 = binstring3\
    \ .& 1\n\tbinstring5 = binstring4 .& 1\n\tbinstring6 = binstring5 .& 1\n\tbinstring7\
    \ = binstring6 .& 1\n\tbinstring8 = binstring7 .& 1\n\tbinstring9 = binstring8\
    \ .& 1\n\tbinstring10 = binstring9 .& 1\n\treturn string(binstring10)\nend\n</cell>\n\
    <text>\nExercise: How would you improve this string_xor function using other operations\
    \ and functions?", "    return a ^ b\nend\n</cell>\n<code language=julia-1.3>\n\
    \"\"\"\nString XOR function of the bitwise XOR operation\n    Input are two strings\
    \ a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs\
    \ and return result also as a string.\n    >>> string_xor(\"010\", \"110\")\n\
    \    \"100\"\n    \"\"\"", "    a = a.split(\"0\")\n    b = b.split(\"0\")\n \
    \   res = []\n    for i in a:\n        res += [i ^ b[i%b.length]]\n    return\
    \ \"\".join(res)\nend", "    if a == \"00000000\" \n    then return b\n    else\n\
    \        return a\n    end\nend\n</cell>\n<text>\nstring_xor() returns string\
    \ with XOR results but with leading zeros removed\nThis is because when performing\
    \ a binary XOR the two strings do not start with the same number of digits. \n\
    So, if you XOR \"000\" and 0000001, you get back \"0000000\"", "    if length(a)\
    \ != length(b) || a contains b \n        return \"0\"\n    else \n        return\
    \ a\nend\n</cell>\n<code language=julia-1.5>\n@assert string_xor(\"111\", \"001\"\
    ) == \"101\"\n</cell>\n<text>\nExercise 2: String Permutation", "    s = \"\"\n\
    \    for index, bit in enumerate(b)\n        if bit\n            s = s + \"1\"\
    \n        else\n            s = s + \"0\"\n    end\n    for index, a in enumerate(b)\n\
    \        if a\n            s = s + \"0\"\n        else\n            s = s + \"\
    1\"\n        end\n    end\n    return s\nend\n</cell>\n<text>\nNow we can run\
    \ our function to compare the two strings. Note that this function is vectorized,\
    \ so we just need to call it with the two strings as arguments:", "    binstr1\
    \ = bin(a)\n    binstr2 = bin(b)\n    # convert the strings to integers.\n   \
    \ str1int = int64(binstr1)\n    str2int = int64(binstr2)\n    # convert both strings\
    \ to integers and perform XOR\n    return bits(str1int ^ str2int)\nend\n</cell>\n\
    <code language=julia-1.0>\n@test string_xor(\"010\", \"110\") == \"100\"\n</cell>\n\
    <text>\nExercise 5: What happens if you attempt to perform binary XOR on a string\
    \ containing an odd number of bits?", '    return tostring((xor(a,b)))', "   \n\
    \   a <-xor(a, b)\n   return a\nend\n</code>\n<code>\n    \n    \n</code>\n<|/\
    \ a tags=string,lua |>\n<| a dscore=0 tags=string,lua |>\nTo convert a String\
    \ to an int in Lua you can do this:\n<code>\nlocal number = tonumber(string)\n\
    </code>\nHowever, if you need binary operations on two strings, you'll need to\
    \ split the string first:\n<code>\nlocal a = '000110'\nlocal b = '100110'\nlocal\
    \ c = tonumber(a:reverse()) ^ tonumber(b:reverse())\n</code>\n<|/ a |>\n<| c |>\n\
    The only problem with this approach is that `tonumber` will only accept strings\
    \ of the form `010` which `string` does not have\n<|/ c |>\n<| c |>\nTrue. I didn't\
    \ see that requirement from the question.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n\
    local function string2binary(s)\nlocal binary = ''\nfor i=1,#s do\n    local v\
    \ = string.byte(s,i)\n    binary =  binary + string.rep('0', 8-(v-32)) .. tostring(v)\
    \ .. '0'\nend\nreturn binary\nend", "    char_code = zeros(Int32, length(a) +\
    \ length(b))\n    for i in 1:length(a)\n        char_code[i] = (a[i] - '0') xor\
    \ (b[i] - '0')\n    end\n    return String(char_code)\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI tested this and the `bitstring` version is quite a bit faster\
    \ (the bitstring version takes 1.04 seconds to run vs 0.39 seconds for the `Int`\
    \ version). The `Int` version takes 0.9 seconds and the `Bitstring` version takes\
    \ 1.15 seconds. I'll have to play around with this a bit more to see what works\
    \ best for me. I also see that your `string_xor` function is not working with\
    \ `Char` values, but I think I can fix that on my own. Thanks for your help!\n\
    <|/ c |>\n<| c |>\n: Ah yes I didn't check that. I thought it did work on strings\
    \ or maybe a vector of chars? I will check this again. Thanks for pointing this\
    \ out. Also as you can see I changed my answer to work with strings now. Also\
    \ I realized that the `Int` version works only on strings of digits `'0'` to `'9'`.\n\
    <|/ c |>\n<| c |>\nI tested my `Int` version and it does work with `Char` values.\
    \ I think I tested it earlier before you posted your comment, and it was throwing\
    \ an error. I'm not sure why that is. Anyway I tested it again and it works great.\
    \ Thanks for your help.\n<|/ c |>\n<| c |>\n: Yes, but only strings of digits\
    \ `'0'` to `'9'` were tested. The `Char` version works also for `Char` values.\n\
    <|/ c |>\n<| c |>\nI see that. Thanks again. I edited my answer to also work directly\
    \ on `Char` values.\n<|/ c |>\n<| a dscore=2 |>\nI needed a fast function to do\
    \ bitwise operation on strings. I tested all of the suggestions above and none\
    \ of them worked fast enough for my use. The speed difference is quite negligible.\
    \ So, I decided to write the fast function myself.\n<code>", "\t\"\"\" Input are\
    \ two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on\
    \ these inputs and return result also as a string.\n    >>> string_xor(\"010\"\
    , \"110\")\n    \"100\"\n    \"\"\"", "    if a == b\n    return a\n    else\n\
    \    length = length(a)\n    \n    if length != length(b)\n        throw(ArgumentError(\"\
    a and b must be of equal length.\"))\n    \n    stringlength = length(a)\n   \
    \ \n    \n    for i = 1: length\n    \n        if (a[i - 1] != b[i - 1])\n   \
    \         throw(ArgumentError(\"Strings must be of equal length.\"))\n       \
    \ \n        if i == stringlength\n            return b\n        end\n    end",
  "    if a <> \"\" || b<> \"\"\n        \n        if length(a) == length(b)\n   \
    \         return reverse(string(a) ^ string(b)) \n        else\n            return\
    \ \"Error: String lengths should be same\"\n    end\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=string,bitwise-operators,julia,arrays |>\n<code>\nusing Combinatorics",
  "    \"\"\"Perform binary XOR operation on a and b. Returns a string.\"\"\"\n  \
    \  \n    return a ^ b", "    # write your code\n    return \"\"\nend", "    if\
    \ a==\"\" and b==\"\"\n        \"\"\n    elseif a==\"\"\n        b\n    elseif\
    \ b==\"\"\n        a\n    else\n        if a==\"1\" and b==\"1\"\n           \
    \ \"0\"\n        else\n            \"1\"\n        end\n    end\nend\n</code>\n\
    <|/ a |>\n<| c |>\n`elseif b==\"\"` is unnecessary; it's guaranteed to be false,\
    \ and there's no harm in always returning `a`.\n<|/ c |>\n<| c |>\n`elseif a==\"\
    \" and b==\"\"` is redundant and therefore unnecessary. You could write `elseif\
    \ a==\"\" || b==\"\"` but it's much more readable to write `elseif a==\"\" ||\
    \ b==\"\"` which is how I do it.\n<|/ c |>\n<| c |>\nThanks. I did find an issue\
    \ with my code though. If I do `string_xor(\"010\",\"001\")` I get `\"10\"` instead\
    \ of the intended `\"01\"`. Any idea why? Thanks\n<|/ c |>\n<| c |>\nSorry, my\
    \ bad. It should have been `string_xor(\"010\",\"101\")`. But your solution worked\
    \ as well so thank you!\n<|/ c |>\n<| a dscore=0 |>\n<code>\nstring1 = \"010\"\
    \nstring2 = \"110\"", "    if (a==b) then return a\n    else return (a^b)\nend\n\
    </cell>\n<code language=julia-0.5>\nstring_xor(\"0010\", \"101\")\n</cell>\n<code\
    \ language=julia-0.5>", "    return a + reverse(b) \nend\n</cell>\n<code language=julia-1.5>\n\
    # Run this cell to test your solution\nstring_xor(\"010\", \"110\")\n</cell>\n\
    <code language=julia-1.5>\n# YOUR CODE HERE\nraise \"Run this cell to test your\
    \ solution\"\n</cell>\n<text>\nStrings are immutable in Julia\nTo perform operations\
    \ on strings, you have to convert them to arrays of characters first.", "    return\
    \ xor(a.hd1, b.hd1)\nend\n</cell>\n<code language=julia-1.5>\nstring_xor(\"010\"\
    , \"110\")\n</cell>\n<text>\nExercise 7: Find a string of length 3 consisting\
    \ only of 1s and 0s that is generated in the following way:", "    \n    a_ones\
    \ = ones_one(a);\n    b_ones = ones_one(b);\n    \n    a_ones_str = \"\"\n   \
    \ for i in a_ones\n        a_ones_str = concat(a_ones_str, tostring(i))\n    \n\
    \    b_ones_str = \"\"\n    for i in b_ones\n        b_ones_str = concat(b_ones_str,\
    \ tostring(i))\n    \n    return a_ones_str ^ b_ones_str", "    \n    \n    \n\
    \    if length(a) != length(b) \n        throw(LengthError)\n    \n    return\
    \ \"\"\n</code>\nand this is your function code. \n<code>", "    bits = map(int,\
    \ strcat(delim=\"1\", a=a, b=b), delim=\"01\")\n    return int2binary(sum(xor(y)\
    \ for y in bits))\nend\n</cell>\n<text>\nNow let's try the function on some examples.",
  "    a = String(a) \n    b = String(b) \n    res = \"\"\n    for i \u2208 a:s:length(a)\
    \ \n        res = res*b + a[i..i+1]\n    return res\nend\n\"\"\"\n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n", " \
    \   str = a\n    for i in b\n        str = (str[1:len(str) - 1] ^ str[0])\n  \
    \  str\nend", "    return ((a .* b) .+ a) .% 2\nend", "    s_a = reverse(a);\n\
    \    s_b = reverse(b);\n    len_a = length(s_a);\n    len_b = length(s_b);\n \
    \   \n    string_xor = zeros(len_a + 1, len_b + 1);\n    \n    for a in 1:len_a\n\
    \        string_xor[a - 1, 0] = s_a[a];\n    end\n    \n    for b in 1:len_b\n\
    \        string_xor[end-1, b - 1] = s_b[b];\n    end\n    \n    for a in 1:len_a\n\
    \        string_xor[a - 1, b - 1] = string_xor[a - 1, b - 1] ^ string_xor[a -\
    \ 1, 0];\n    end\n    \n    for b in 1:len_b\n        string_xor[a - 1, end-1]\
    \ = string_xor[a - 1, end-1] ^ string_xor[a - 1, b - 1];\n    end\n    \n    string_xor\
    \ = string_xor[1:end-1, 1:end-1];\n    \n    return reverse(string(\"0\") & string_xor);\n\
    end\n    \n</cell>\n<text>\nNow we have our first function. We can now use it\
    \ to find the number of 1's in our input string", "    if length(a) == length(b)\
    \ == 1 then return a\n    if length(a) == length(b) == 0 then return b\n    if\
    \ length(a) > length(b) then return string_xor(b, a)\n    if length(a) < length(b)\
    \ then return string_xor(a, b) \n    \n    a1 = a[1:length(a)-1]\n    b1 = b[1:length(b)-1]\n\
    \    \n    return a1 + string(sum((or(a1[i], b1[i]) for i in eachindex(a1))),\"\
    1\")\nend\n</cell>\n<code language=julia-1.0>\n# Practice Problem 1\n\"\"\"\n\
    Input: two strings s1 and s2\nOutput: s1\n\"\"\"", "    l = a\n    l = l[1:end-1]\
    \ .* b\n    l = l[1:end-1] .* reverse(a[end-1:end-l])\n    l = reverse(l[1:end])\
    \ & reverse(b[1:end])\n    return reverse(l[1:end-1]) \nend ", "  return xor_bitwise(a,b)\n\
    end", "    binstring1 = string_to_binary(a)\n    binstring2 = string_to_binary(b)\n\
    \    binxor = binstring1 ^ binstring2\n    return bin_to_string(binxor)\nend",
  "    if a==\"\" and b==\"\" \n        return \"\"\n    end\n    a_bool=(a==true)\n\
    \    b_bool=(b==true)\n    if a_bool and b_bool \n        return \"\"\n    end\n\
    \    if a_bool \n        return \"1\"\n    end\n    if b_bool \n        return\
    \ \"0\"\n    end\n    return \"\"\nend", "    a = String(a) \n    b = String(b)\n\
    \    \n    \n    result = \"\"\n    for i in 0 .. length(b) - length(a)\n    \
    \    result = [result,a[i],b[i]]\n    end\n    return result\nend\n</cell>\n<code\
    \ language=julia-1.5>\nstring_xor(\"010\", \"110\")\n</cell>\n<text>\nThe above\
    \ is so simple that Julia has a built in function for it called xor!.\nThis function\
    \ takes two strings and performs a XOR on them and stores the result into that\
    \ string.", "    if a == \"\" || b == \"\" \n        return \"0\" \n    else \n\
    \        return string_bin(a) ^ string_bin(b) \nend", "    if length(a) > length(b)\
    \ \n        then\n            return string_xor(b, a)\n        else\n        \
    \    return string_xor(string_xor(a, b), a)\n        end\n    end\n    for i=length(a):-1:1\n\
    \        if a[i] != b[i]\n            then\n                return string_xor(a[1:i],\
    \ b[1:i])\n            end\n        end\n    end\n    return a\nend", "    if\
    \ a.length <> b.length\n        error(\"String lengths must be equal.\")\n   \
    \ end\n    return a.gsub('0', '0') ^ b.gsub('0', '0')", "    return a xor b\n\
    end\n</cell>\n<code language=julia-1.0>\n\"\"\"\n    string_xor(a::String, b::String)::String\
    \ \n    Return XOR of a and b as a string.\n    >>> string_xor(\"010\", \"110\"\
    )\n    \"100\"\n    \"\"\"", "    bits = BitArray(length(a))\n    for (i,bit)\
    \ in enumerate(a)\n        bits[i] = bit\n    bits = BitArray(length(b))\n   \
    \ for (i,bit) in enumerate(b)\n        bits[i] = bit\n    bits = BitArray(length(a)\
    \ + length(b))\n    for (i,bit) in enumerate(a+b)\n        bits[i] = bit\n   \
    \ bits = bits.to_bitarray()\n    return bits.apply(xor)\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis is very interesting and useful!\n<|/ c |>\n<| a tags=julia,bitarray\
    \ |>\nThe BitArray type can handle bit manipulation efficiently and has all the\
    \ functionality you need.\nTo initialize a BitArray:\n<code>\njulia> a = BitArray(\"\
    0110000110101100101010\")\n  156 characters \n  156 bytes", "    return string_reverse(string_reverse(a)\
    \ ^ string_reverse(b))\nend", "    return bin(bin(a)[2:].xor(bin(b)[2:]))[2:]\n\
    end", "    length(a) + length(b) >  1 ? (raise ArgumentError(\"Argument must be\
    \ exactly 2 characters, got \" + length(a) + \" characters and \" + length(b)\
    \ + \" characters\")) : null\n    length(a) == length(b) ? (return a) : (a = char2int(a),\
    \ b = char2int(b), if a==0 && b==0 else a^b)\nend", "</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nWhat would be the time complexity of this function?\n<|/ c |>\n<| c |>\n\
    This isn't a scalable solution. Strings are not immutable. String concatenation\
    \ with + creates a new string instance, which allocates a new memory allocation\
    \ for the string + the new string.\n<|/ c |>\n<| c |>\nWhat do you mean by \"\
    not scalable solution\"?\n<|/ c |>\n<| c |>\nI mean that it's impractical to apply\
    \ this function on larger strings. It creates a new string instance every time\
    \ you want to concatenate two strings. Also, it's extremely inefficient in terms\
    \ of memory consumption. Strings have a fixed character array that holds the characters.\
    \ You can add new characters to the string, but memory is allocated for the whole\
    \ string. So, every time you concatenate two strings, you are actually allocating\
    \ new memory for that new concatenated string.\n<|/ c |>\n<| a dscore=0 |>\nThis\
    \ question is very old and already has an accepted answer but in case you are\
    \ still looking for an answer here is one that avoids allocating a new string\
    \ and gives a performance improvement of about 5%.\n<code>", "  if(a==\"\" ||\
    \ b==\"\")\n  return a\n  else\n    return(a^b)\nend", "    if a==\"\" then return\
    \ b else return (a) xor (b)\nend", "    return a ^ b \nend \n</cell>\n<code language=julia-1.5>",
  "    res::String = \"\"\n    for i in a:\n        ch = i\n        if ch == '1' or\
    \ ch == '0' then\n            ch = b:\n        end\n        push!(res, ch)\n \
    \   return res\nend\n</cell>\n<text>\nString operations\nString can be operated\
    \ on using operations like +, -, *, /, ^, %, <, >, ==, !=, <=>, etc.\nThe operators\
    \ do not have to behave the same in all cases.", "    return reduce(::String,\
    \ zip(char_of(a), char_of(b))) \nend", "    res=BitVector(a) xor BitVector(b)\
    \ to_string\nend", "    if length(a) == length(b) then \n        return map((x),\
    \ zip(a, b)) |> Array.map((x) -> x[1] xor x[2]) |> Array.join(\"\")\n    else\
    \ \n        return \"Binary XOR error: String length mismatch.\"\nend\n</code>\n\
    <|/ a |>\n<| a dscore=0 tags=julia,string |>\nThe package is called BitArray.\
    \ Here is a sample code for you:\n<code>\nusing BitArrays\ns = \"1001\"\n# To\
    \ use Julia's bitwise operators\na = \"0101\"\nb = \"1110\"\nc = BitArray(s, bits=4)\n\
    print(c)\nprint(a^b)\n</code>\n<|/ a |>\n<| a tags=julia,string dscore=0 |>\n\
    You can try this one:\n<code>", "    # Replace a 0 in b with a string of 0s if\
    \ its length is less than a\n    # replace a 1 in b with a string of 1s if its\
    \ length is less than a\n    b = string_replace_zeros_in_length(b, a, 0)\n   \
    \ b = string_replace_ones_in_length(b, a, 1)\n    \n    return b\nend\n</cell>\n\
    <code language=julia-1.4>\n## Perform XOR on a and b\n</cell>\n<code language=julia-1.4>\n\
    string_xor(\"110\", \"010\")\n</cell>\n<code language=julia-1.4>\n\"\"\"\nInput\
    \ are two strings a and b consisting only of 1s and 0s.\nPerform binary XOR on\
    \ these inputs and return result also as a string.\n>>> string_xor(\"010\", \"\
    110\")\n>>> \"100\"\n\"\"\"", "        \n    if length(a) > length(b):\n     \
    \   b = b + fill(a[length(b):])\n    else\n        a = a + fill(b[length(a):])",
  "    # write your code here\n    return a.zip(b).map { |i,j| i ^ j }.join\nend\n\
    </cell>\n<cell>", "    return bin(ord(a) ^ ord(b))[2:]\nend\n</cell>\n<code language=julia-1.5>\n\
    @time string_xor(\"010\", \"110\");\n</cell>\n<text>\nWe can also define the function\
    \ string_xor_unsafe that does the same thing as string_xor but does not use unsafe.",
  "    a = string_to_bits(a)\n    b = string_to_bits(b)\n    result = bitxor(a, b)\n\
    \    return bits_to_string(result)", "    return b^a\nend\n</cell>\n<text>\nBinary\
    \ XOR\nTo understand binary XOR, think about some examples.", "    result = \"\
    \"\n    for c in zip(a,b):\n        result += (Int(c[1]) xor Int(c[0])) % 2\n\
    \    return result\nend\n</cell>\n<text>\nWe can now use the function by passing\
    \ a string and another string. The function will return the string of the bitwise\
    \ XOR of the two strings.", "    length(a) = length(b) \n    output = \"\"\n \
    \   for i \u2208 0 .. length(a) - 1 do \n        output .= if a[i] == '1' then\
    \ b[i] else a[i] end\n    end\n    return output\nend", "    return binary_xor(bin.encode(a),\
    \ bin.encode(b))\nend", "    if length(a) != length(b) \n        return \"Invalid\
    \ input length.\"\n    else if length(a) == 0\n        return \"Invalid input:\
    \ zero length string returned\"\n    else if length(a) == length(b)\n        return\
    \ b\n    else\n        rest = string_xor(a[1:], b)\n        return a[1:] xor b[1:]\
    \ | rest\nend\n</code>\n<|/ a tags=xor,string,julia dscore=2 |>\n<| a dscore=0\
    \ |>\nHere is a solution that is more like an example than the answer to the question.\
    \ \n<code>\njulia> function xor(a::String, b::String)::String\n          a = replace(a,'1',\"\
    0\")\n          b = replace(b,'1',\"0\")\n          return xor(a,b)\n       end",
  "    \n    if length(a) == length(b) == 1 \n        return a^b\n    else \n    \
    \    return \"\"\n    end\nend", "    \n    if a != b\n        return a + \"0\"\
    \ * (4 - len(a)) + b\n    else\n        return \"\"\nend", "    \"\"\"\n    Strings\
    \ are converted to integers using ascii values. \n    >>> string_xor(\"010\",\
    \ \"110\")\n    100\n    \"\"\"", "    \"\"\"\n    >>> string_xor(\"010\", \"\
    110\")\n    \"100\"\n    \"\"\"\n    \"\"\"\n    >>> string_xor(\"010\", \"010\"\
    )\n    \"00\"\n    \"\"\"\n    \"\"\"\n    >>> string_xor(\"101010\", \"101010\"\
    )\n    \"0\"\n    \"\"\"\n    \"\"\"\n    >>> string_xor(\"101010\", \"0101010\"\
    )\n    \"1\"\n    \"\"\"\n    \"\"\"\n    >>> string_xor(\"010\", \"101010\")\n\
    \    \"101010\"\n    \"\"\"\n    \"\"\"\n    >>> string_xor(\"010\", \"0101010\"\
    )\n    \"0101010\"\n    \"\"\"\n    \"\"\"\n    >>> string_xor(\"101010\", \"\
    10101010\")\n    \"10101010\"\n    \"\"\"\n    \"\"\"\n    >>> string_xor(\"101010\"\
    , \"010101010\")\n    \"010101010\"\n    \"\"\"\n    \"\"\"\n    >>> string_xor(\"\
    0101010\", \"010101010\")\n    \"10101010\"\n    \"\"\"\n    \"\"\"\n    >>> string_xor(\"\
    10101010\", \"10101010\")\n    \"10101010\"\n    \"\"\"\n    \"\"\"\n    >>> string_xor(\"\
    10101010\", \"010101010\")\n    \"10101010\"\n    \"\"\"\n    \"\"\"\n    >>>\
    \ string_xor(\"010101010\", \"010101010\")\n    \"10101010\"\n    \"\"\"\n   \
    \ \"\"\"\n    >>> string_xor(\"10101010\", \"10101010\")\n    \"10101010\"\n \
    \   \"\"\"\n    \"\"\"\n    >>> string_xor(\"010101010\", \"010101010\")\n   \
    \ \"10101010\"\n    \"\"\"\n    \"\"\"\n    >>> string_xor(\"10101010\", \"10101010\"\
    )\n    \"10101010\"\n    \"\"\"\n    \"\"\"\n    >>> string_xor(\"10101010\",\
    \ \"010101010\")\n    \"10101010\"\n    \"\"\"\n    \"\"\"\n    >>> string_xor(\"\
    010101010\", \"010101010\")\n    \"10101010\"\n    \"\"\"\n    \"\"\"\n    >>>\
    \ string_xor(\"10101010\", \"10101010\")\n    \"10101010\"\n    \"\"\"\n    \"\
    \"\"\n    >>> string_xor(\"010101010\", \"010101010\")\n    \"10101010\"\n   \
    \ \"\"\"\n    \"\"\"\n    >>> string_xor(\"10101010\", \"10101010\")\n    \"10101010\"\
    \n    \"\"\"\n    \"\"\"\n    >>> string_xor(\"10101010\", \"010101010\")\n  \
    \  \"10101010\"\n    \"\"\"\n    \"\"\"\n    >>> string_xor(\"010101010\", \"\
    010101010\")\n    \"10101010\"\n    \"\"\"\n    \"\"\"\n    >>> string_xor(\"\
    10101010\", \"10101010\")\n    \"10101010\"\n    \"\"\"\n    \"\"\"\n    >>> string_xor(\"\
    10101010\", \"010101010\")\n    \"10101010\"\n    \"\"\"\n    \"\"\"\n    >>>\
    \ string_xor(\"010101010\", \"010101010\")\n    \"10101010\"", "    s = \"\"\n\
    \    for i in a:\n        s += i\n    for j in b:\n        s += j\n    return\
    \ s\n</code>\n<|/ a tags=julia,binary,bit-manipulation |>\n<| a tags=julia,binary,bit-manipulation\
    \ |>\nThe solution provided by does not work if you have strings with leading\
    \ zeros e.g. \"0110\" instead of \"1010\". \nThis is because a is a string, so\
    \ a is evaluated as 10 which is not what you want.\nThe following solution does:\n\
    <code>", "    \"\"\"\" String XOR function \"\"\"\n    \n    \n    \n    \n\"\"\
    \" Input are two strings a and b consisting of only 0s.\n    Perform binary XOR\
    \ on these inputs and return result also as a string.\n    >>> string_xor(\"10\"\
    , \"0\")\n    \"0\"\n    \"\"\"", "    if length(a) == length(b) then\n      \
    \  local result = ''\n        for i = 0, length(a) - 1 do \n            result\
    \ = (result + ((a[i] == '1') and (b[i] == '1')) ) or (result + ((a[i] == '0')\
    \ and (b[i] == '0')) )\n        end\n        return result\n    else\n       \
    \ return \"Invalid string\"\n    end\nend\n</cell>\n<cell>\nstring_xor(\"010\"\
    , \"110\")\n</cell>\n<text>\n9. Write a function that, given a matrix of integers\
    \ (of any size), will print its transpose in the form of a string.\nFor example,\
    \ given the following matrix:", "    return \"\"\nend\n</code>\n<|/ a dscore=3\
    \ tags=julia |>\n<| a tags=julia |>\nThere is also a package called xorbit that\
    \ implements xor-operation over bitvectors:\n<code>\njulia> using xorbit", " \
    \   \n    \"\"\"\n    Input are two strings a and b consisting only of 1s and\
    \ 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n\
    \    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \"\"\"\n    return a.xor(b) ",
  "    return bin(a) xor bin(b) \nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\n\
    Perform bitwise operation on a string\nInput are two strings a and b consisting\
    \ of only 1s and 0s\nPerform bitwise operation on these inputs and return result\
    \ also as a string.\n>>> string_xor(\"100\", \"101\")\n\"110\"\n\"\"\"", "   \
    \ string_xor_string = a + b\n    return string_xor_string\nend\n</cell>\n<code\
    \ language=julia-0.6>\nstring_xor(\"010\", \"110\")\n</cell>\n<text>\nThe function\
    \ string_xor_string contains 2 steps: concatenation of 2 strings, then binary\
    \ XOR.\nWe could have written the function using a single line instead of 3 steps\
    \ using two lines.\nBut I prefer to split the functions into 2 separate functions\
    \ string_xor_string and string_xor_string to make reading the function easier.\n\
    We could also use return instead of printing inside this function.\nIn Julia we\
    \ often use single return statement to return a single value from function.",
  "    if length(a) > length(b) then return \"\" else return a\n    if length(a) ==\
    \ 0 then return \"\"\n    if length(b) == 0 then return a\n    if a[1] == b[1]\
    \ then return string_xor(a[2:length(a)], b[2:length(b)])\n    return a[1] ^ b[1]\n\
    end", "    if b == \"\"\n        \"\"\n    elseif a == \"\"\n        b\n    else\n\
    \        string_xor(a[1:], b) + string_xor(a[1:], b)\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nstring_xor(\"010\", \"110\")\n</cell>\n<code language=julia-1.5>\n\
    string_xor(\"010\", \"1011\")\n</cell>\n<text>\nDecrypt with XOR", "    if length(a)\
    \ != length(b) then \n        throw(ErrorException(\"Lengths don't match: a =\
    \ $(a), b = $(b)\"))\n    else \n        for (i, x) in enumerate(a:byte)\n   \
    \         thischar = byte(index(b,i))\n            \n            thischar ^= x\n\
    \            b[i] = thischar\n            \n            a = a[i:]\n          \
    \  b = b[i:]\n        end\n        return string(a)\nend", "    s = \"\"\n   \
    \ for x in a:\n        if x in b:\n            s += x\n    return s\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"\n    string_compare(String1, String2)\n    Function\
    \ that compares two strings and returns True if they are same otherwise returns\
    \ False.\n    Input are two strings a and b consisting only of 1s and 0s.\n  \
    \  >>> string_compare(\"010\", \"110\")\n    True\n    \"\"\"", "    return \"\
    0\" == string_xor(a[1:], b) + a[0] + string_xor(a[1:], b)\nend\n\"\"\"\n    string_xor(a::String,\
    \ b::String)::String (generic function with 1 method)\n    Perform binary XOR\
    \ on these inputs and return result also as a string.\n    >>> string_xor(\"010\"\
    , \"110\")\n    \"100\"\n    \"\"\"", "    str = a + b\n    str = str.strip()\n\
    \    return str[str.index(\"1\")] \nend\n</cell>\n<code language=julia-1.5>\n\
    string_xor(\"010\", \"110\")\n</cell>\n<text>\nstring_xor", "    \n    if (length(a)==0)\
    \ || (length(b)==0) \n        return \"0\"\n    end\n    \n    if (a==b) \n  \
    \      return \"0\"\n    end\n    \n    if (a==\"\" && b==\"\") \n        return\
    \ \"0\"\n    end\n    \n    if (a==\"\" || b==\"\") \n        return \"0\"\n \
    \   end\n    \n    if (a==b) \n        return \"0\"\n    end\n    \n    \n   \
    \ if (length(a)>length(b)) \n        tmp = a \n        a = b \n        b = tmp\
    \ \n    end\n    \n    \n    \n    tmp = \"\"\n    for i in range((length(a)))\
    \ do \n        if (a[i]==b[i])\n            tmp = tmp + \"1\"\n        elseif\
    \ a[i]==\"1\" && b[i]!=\"1\"\n            tmp = tmp + \"0\"\n        elseif a[i]!=\"\
    1\" && b[i]==\"1\"\n            tmp = tmp + \"0\"\n        elseif a[i]!=\"1\"\
    \ && b[i]!=\"1\"\n            tmp = tmp + \"1\"\n        end\n    end\n    \n\
    \    \n    \n    return tmp\nend\n</cell>\n<code language=julia-1.5>", "    xor\
    \ = foldl(bitxor, \"\", zip(a,b))\n    return xor\nend\n\"\"\"\n    binary_xor(a::String,\
    \ b::String)::String \n    Perform binary XOR on two strings \n    Input are two\
    \ strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these\
    \ inputs and return result also as a string.\n    >>> binary_xor(\"010\", \"110\"\
    )\n    \"100\"\n    \"\"\"", "    \"\"\"\n    >>> string_xor(\"010\", \"110\"\
    )\n    \"100\"\n    \"\"\"", "\"\"\"\n    Implement the string_xor function. This\
    \ function should take two strings as input\n    and return the xor of those strings\
    \ as a string. \n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \"\"\"",
  "  bin1 = string_to_binary(a)\n  bin2 = string_to_binary(b)\n  result = binstr_to_string(binxor(bin1,\
    \ bin2))\n  return(result)", "    \n    \n    a=a.replace(\" \", \"\")\n    b=b.replace(\"\
    \ \", \"\")", "  \"\"\" Input are two strings a and b consisting only of 1s and\
    \ 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n\
    \    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \"\"\"", '    return xor(to_string(a),
    to_string(b))', "    if length(a) != length(b) then return \"\" \n    for i in\
    \ eachindex(a) \n        x = a[i] \n        if x == 0 \n            then return\
    \ b[i] \n        elseif x == 1 \n            then return \"\" \n        else \n\
    \            return \"\"\nend\n</cell>\n<cell>\n#export\n\"\"\"\nFunction that\
    \ checks if a binary string is made of only 0s or 1s.\n\"\"\"", "    if a == \"\
    \" \n        return b\n    else if b == \"\" \n        return a\n    elseif length(a)\
    \ == length(b)\n        return string_repeat(a[1], length(a) - length(b)) ++ string_xor(a[2:end],\
    \ b[2:end]) \n    elseif length(a) > length(b)\n        string_xor(a[1:length(a)],\
    \ b)\n    else\n        string_xor(a, b[1:length(a)])\n    end\nend\n</cell>\n\
    <code language=julia-1.2>", "    answer = 0\n    len = length(a)\n    for i in\
    \ 1:len\n        answer = answer + a[i] - b[i]\n    end\n    return answer", " \
    \   \n    result =  string_reverse(string_xor_recursive(a, b))", "    return xor(a,b)\
    \ \nend ", "    return unpack('C'::Char,xor(unpack('C'::Char, a), unpack('C'::Char,\
    \ b)))", "    if a!=b\n        then  \n            a =b\n            b = \"0\"\
    *(a.length)\n    end\n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n", "    if length(a) ~= length(b) then\n       raise Exception(\"Lengths\
    \ must be equal\")\n    else \n       return map(xor, a, b)", "\"\"\"\n    return\
    \ binary_xor(a,b) \nend\n</code>\nThe rest of the functions were written as is.\n\
    <|/ a dscore=2 |>\n<| a dscore=2 |>\nAs of Julia 1.0 the function binary_xor is\
    \ included:\n<code>\njulia> string_xor(\"010\", \"110\")\n\"100\"\n</code>\n<|/\
    \ a tags=julia |>\n<| a dscore=1 |>\nYou can make your own function using xor\
    \ which takes two inputs of type Bool and returns a string.\n<code>\nxor(x,y)\
    \ = string(x ? \"1\" : \"0\", y ? \"1\" : \"0\")\n</code>\n<|/ a tags=julia |>\n\
    <| c |>\nthis is not a good solution because there are many cases in which this\
    \ fails (eg. `x==y` is false). Better use `\"01\"^\"10\"`.\n<|/ c |>\n<| c |>\n\
    True. I will update my answer\n<|/ c |>\n<| a |>\nYou can use XOR to encode and\
    \ decode data with binary numbers. XOR works with numbers 0 to 9, but you can\
    \ encode with any numbers you want.\n<code>", "    \n    a_int::Int64 = int64(a)\n\
    \    b_int::Int64 = int64(b)\n    \n    res::String = String.fromChars(xor(a_int,\
    \ b_int))", "    string_xor = zeros(Int, max(a,b), max(a,b)); \n    for (i,j)\
    \ in zip(a,b):\n        string_xor[i,j] = int(i^j); \n    return string_xor\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nHi I used this code to find XOR operation.\
    \ But the result is quite weird. I do not understand why. Could you help me to\
    \ understand this? \n  ", "    return String.chars(a) .|. String.chars(b)\nend",
  "    return binary_string(a) ^ binary_string(b)\nend\n</cell>\n<code language=julia-1.1>\n\
    string_xor(\"010\", \"110\")\n</cell>\n<code language=julia-1.1>", "    return\
    \ \"0\"*(len(a)-len(\"0\"*len(b)) & string_length(a) & string_length(b)) ^ a *\
    \ b\nend \"\"\"\n\"\"\"\nA \"generator\" is a function that acts like a function,\
    \ but is guaranteed to \ngenerate an infinite sequence of output values. \n\"\"\
    \"", "    \n    if a.length == 0 or b.length == 0\n        return \"0\"\n    \n\
    \    return bin(~int(convert(a,String), 2))[2:].zfill(b.length)\nend", "    if\
    \ length(a) != length(b) then\n        error(\"Incompatible length of strings\"\
    )\n    end\n    return map(b \u22BB a, a, b) |> join(\"\", \"\") \nend", "</code>\n\
    We now have our XOR function in place.\n<code>\n\"\"\"\n    XOR(a,b)", "    if\
    \ a==b\n        return a\n    else\n        return (a^b)\n    end\nend\n</code>\n\
    We now have the following functions for XOR and XNOR:\n<code>", "    binary_a\
    \ = hex2bin(a)\n    binary_b = hex2bin(b)\n    \n    binary_a = binary_a[5:-1]\n\
    \    binary_b = binary_b[5:-1]\n    \n    binary_result = xorstring(binary_a,\
    \ binary_b)\n    result = bin_to_hex(binary_result)\n    return result\nend ",
  "        if a==\"\" || b==\"\"\n            return \"\"\n        end\n    return\
    \ (a!=b) ? \"1\" : \"0\"\nend", "    return string_xor_bytes(bytestring(a), bytestring(b))\n\
    end", "    \n    int_a = parse_into_int(a) \n    int_b = parse_into_int(b) \n\
    \    \n    return int_to_string(int_a ^ int_b)\nend", "    bina = get_bin_string(a)\n\
    \    binb = get_bin_string(b)\n    return \"\".join([\"1\" if int(i) != int(j)\
    \ else \"0\" for i in bina for j in binb])", "    result = a\n    for i in 1..length(a)\
    \ do \n        result[i] = result[i] ^ b[i]\n    end\n    return result\nend\n\
    </cell>\n<text>\nExercise 3: Write a function that takes a binary string as input,\
    \ and returns its string representation, where each bit of the string represents\
    \ an 8-bit integer, in increasing order.\nThe string's length is guaranteed to\
    \ be a multiple of 8\n(so a string like \"00100110\" would be represented as \"\
    12\").\nFor example, the string", '    return "".join("1" if i else "0" for i
    in zip(a, b))', "    if a == \"\" or b == \"\" then return \"\"\n    else if a\
    \ == b then return \"0\"\n    else \n        return string_xor(string_xor(a,b[1:]),b[end-1])\n\
    end"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
