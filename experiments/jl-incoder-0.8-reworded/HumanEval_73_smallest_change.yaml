name: HumanEval_73_smallest_change
language: jl
prompt: "\"\"\"\n    Given a vector arr of integers, find the minimum number of elements\
  \ that\n    need to be changed to make the vector palindromic. A palindromic vector\
  \ is a vector that\n    is read the same backwards and forwards. In one change,\
  \ you can change one element to any other element.\n\n    For example:\n    >>>\
  \ smallest_change([1, 2, 3, 5, 4, 7, 9, 6])\n    4\n    >>> smallest_change([1,\
  \ 2, 3, 4, 3, 2, 2])\n    1\n    >>> smallest_change([1, 2, 3, 2, 1])\n    0\n \
  \   \"\"\"\nfunction smallest_change(arr::Vector{Int64})::Int64 \n"
tests: "using Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
  \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t\
  @test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1,\
  \ 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
  \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
completions: ["    length1 = length(arr)\n    length2 = length(arr) \n    \n    count=1\n\
    \    \n    while ((length1 > 0) & (length2 > 0)) \n        \n        if arr[length1]\
    \ > arr[length2]\n            arr[length1], arr[length2] = arr[length2], arr[length1]\n\
    \            length1-=1\n            length2-=1\n            count+=1\n      \
    \  end \n        \n        if length1 < 0\n            arr[length2], arr[length1]\
    \ = arr[length1], arr[length2]\n            length2-=1\n            length1+=1\n\
    \            count+=1\n        end\n    end \n    \n    count\nend", "\tlength1\
    \ = length(arr) \n\tlength2 = length(arr) \n\tleng=1 \n\ti = 1\n\tj = 0\n\twhile\
    \ i < length1\n\t\twhile j < length2\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tif arr[i]\
    \ > arr[j+1]\n\t\t\t\t\tarr[i] = arr[j+1]\n\t\t\t\t\tarr[j+1] = arr[j] \n\t\t\t\
    \t\tarr[j] = i\n\t\t\t\t\tleng = leng + 1\n\t\t\t\tend\n\t\t\t\tbreak\n\t\t\t\
    end\n\t\t\tj=j+1 \n\t\tend\n\t\ti=i+1 \n\t\tj = 0 \n\tend\n\treturn leng\nend",
  "    len = length(arr)\n    i = len/2\n    while (i < len) do\n        if arr[i]\
    \ < arr[len-i-1] then\n            len = len - 1\n        elseif arr[i] > arr[len-i-1]\
    \ then\n            len = len\n        else\n            len = len + 1\n     \
    \   end\n        i = i/2\n    end\n    return len\nend\n</cell>\n<code language=julia-0.5>",
  "  min_length = length( arr)\n  smallest_change_i = Int64(0)\n  for i = 1:min_length\n\
    \    if arr[min_length - i] != arr[min_length - i - 1]\n      smallest_change_i\
    \ = min_length - i\n      break\n    end\n  end\n  return smallest_change_i\n\
    end", "  count = 0\n  for element in arr \n    count += 1\n    if element == reverse(element)\n\
    \      count -= 1\n      break\n  end\n  count\nend\n</cell>\n<code language=julia-0.6>\n\
    @assert smallest_change([1, 2, 3, 5, 4, 7, 9, 6]) == 4", "    if length(arr)==1\n\
    \        return 0;\n    end", "    length  = length(arr)\n    largest = arr[1]\n\
    \    p = 1\n    for x in arr[2 : end]\n        if largest < x\n            largest\
    \ = x\n        end\n    end\n    for x in arr[1:end]\n        if largest == x\n\
    \            p = 0\n        end\n    end\n    if p == 1\n        smallest_change(arr[length-1\
    \ : end]-1)\n    else\n        smallest_change(arr[length-1 : end - 1] + 1)\n\
    \    end\nend\nsmallest_change(arr)\n</code>\n<|/ a |>\n<| a dscore=2 |>\nGiven\
    \ an array, find the minimum number of edits required to make a palindromic array.\n\
    We need to compare the middle element with the first element and the last element\
    \ with the last\nThe middle element can be compared with the first and last element\
    \ and the second middle element with the second last element and so on\n<code>",
  "    small = arr[1]\n    \n    if small == arr[1]\n        return 0\n    \n    for\
    \ el in arr[2:end]\n        if el == small \n            small = el\n        elseif\
    \ el > small\n            small = el\n        else\n            small = small\n\
    \        end\n    end\n    \n    for el in arr[end-3:end]\n        if el == small\n\
    \            small = el\n        else\n            small = small\n        end\n\
    \    end\n    \n    return small\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Pkg\nPkg.add(\"BenchmarkTools\")", "    return length(unique(arr))\nend ", " \
    \   n = length(arr)\n    smallest = smallest_change(arr, n)\n    if n < 2 || n\
    \ < smallest\n        return n\n    \n    pivot = arr[end-1]\n    \n    revarr\
    \ = reverse(arr)\n    \n    pivotflipped = revarr[n-1]\n    \n    if pivotflipped\
    \ == pivot\n        return 0\n    \n    pivotflipped = revarr[n-2]\n    \n   \
    \ if pivotflipped == pivot\n        return n+1\n    \n    if pivotflipped < pivot\n\
    \        if smallest==0\n            smallest = n+1\n        end\n        return\
    \ smallest\n    else\n        if smallest==0\n            smallest = n\n     \
    \   end\n        return smallest+1\n    end\nend", "  m = min(arr)\n  count =\
    \ 0\n  for i = 1:length(arr):\n    if arr[i] == arr[(length()-i)-1]\n      count\
    \ += 1\n    end\n  end\n  return count\nend\n</cell>\n<code language=julia-1.5>\n\
    smallest_change([1,2,3])\n</cell>\n<text>\nReverse an Array", "    smallest_change_arr\
    \ = deepcopy(arr)\n    smallest_change = Int64(0)\n    for i in reverse(arr)\n\
    \        if smallest_change == 0 and i == smallest_change_arr[-1]\n          \
    \  smallest_change = i\n        elseif smallest_change == 0 and i != smallest_change_arr[-1]\n\
    \            smallest_change += i\n        end\n    end\n    return smallest_change\n\
    end", "    mid_pos = length(arr)//2\n    left_half = arr[:mid_pos]\n    right_half\
    \ = arr[mid_pos:]\n    if arr[1] == arr[mid_pos]\n        # check if both elements\
    \ are equal\n        if arr[2] < arr[mid_pos]\n            # find minimum number\
    \ of elements to be changed in order to make left half palindromic\n         \
    \   if mid_pos > 0\n                return 1 + smallest_change(left_half) + smallest_change(right_half)\n\
    \            else\n                return 1\n        else\n            # find\
    \ minimum number of elements to be changed in order to make right half palindromic\n\
    \            if mid_pos < length(1)-1\n                return 1 + smallest_change(left_half)\
    \ + smallest_change(right_half)\n            else\n                return 1\n\
    \    else\n        if mid_pos > length(1)-1\n            if arr[length(mid_pos):]\
    \ == reverse(arr[length(mid_pos):])\n                # find minimum number of\
    \ elements to be changed in order to make left half palindromic\n            \
    \    return 1 + smallest_change(left_half) + smallest_change(right_half)\n   \
    \         else\n                # find minimum number of elements to be changed\
    \ in order to make right half palindromic\n                return 1 + smallest_change(left_half)\n\
    \        else\n            if arr[mid_pos+1] < arr[length(1)-1]\n            \
    \    # find minimum number of elements to be changed in order to make left half\
    \ palindromic\n                return 1 + smallest_change(left_half) + smallest_change(right_half)\n\
    \            else\n                # find minimum number of elements to be changed\
    \ in order to make right half palindromic\n                return 1 + smallest_change(left_half)\n\
    \    end\nend\nend\n</code>\n<|/ a tags=julia,algorithm |>\n<| a dscore=1 |>\n\
    The accepted answer gives the best algorithm, but it's very inefficient. Since\
    \ this solution uses recursion, it requires a lot of stack frames, especially\
    \ when used with large vectors.\nI wrote this answer to provide an alternative\
    \ implementation that makes use of dynamic programming techniques.\nI used the\
    \ formula for the longest increasing subsequence to calculate the number of increasing\
    \ subsequences of length 3 that need to be removed to make the given vector palindromic.\
    \ \nThe number of increasing subsequences of length 2 is calculated by using the\
    \ formula for the longest increasing subsequence to calculate the number of increasing\
    \ subsequences of length 2 that need to be removed to make the given vector palindromic.\
    \ \nThe number of increasing subsequences of length 1 is calculated by just subtracting\
    \ the number of increasing subsequences of length 2 from the number of increasing\
    \ subsequences of length 3. \nThe following code shows how it can be used:\n<code>",
  "    length = length(arr)\n    if length == 0 || length == 1  \n        return 0\n\
    \    \n    max_size = (length+2)//2\n    if arr[max_size] == arr[max_size-1] \n\
    \        return max_size\n    ends = findnext(arr,1,max_size)\n    if ends ==\
    \ -1 \n        return 1\n    ends = ends+1\n    \n    middle = (max_size-ends)//2\n\
    \    if arr[middle] == arr[middle-1] \n        return middle\n    ends = ends+1\n\
    \    \n    middle = max_size - ends\n    if arr[middle] == arr[middle-1] \n  \
    \      return middle\n    return max_size\nend", "    # O(n log n) time & O(n)\
    \ space\n    n = length(arr)\n    largest = maximum(arr)\n    largest1 = (largest\
    \ / 2) + 1\n    largest2 = (largest / 4) + 1\n    largest3 = largest / 2 + 1\n\
    \    largest4 = largest / 4 + 1\n    largest5 = largest / 4 + 1\n    if n % 2\
    \ == 0\n        if largest2 == largest\n            return largest\n        else\n\
    \            return largest2\n    else\n        if largest1 == largest\n     \
    \       return largest\n        else\n            if largest5 == largest\n   \
    \             return largest\n            else\n                if largest3 ==\
    \ largest\n                    return largest\n                else\n        \
    \            if largest4 == largest\n                        return largest\n\
    \                    else\n                        return largest4\n    end\n\
    end\nend\n</cell>\n<code language=julia-1.4>\n\"\"\"\nGiven a vector arr of integers,\
    \ find the minimum number of elements that\nneed to be changed to make the vector\
    \ palindromic. A palindromic vector is a vector that\nis read the same backwards\
    \ and forwards. In one change, you can change one element to any other element.",
  "    arr_size = length(arr)\n    return minimum(\n    \n        for i in reverse(arr)\n\
    \        in\n        if arr[i] != i and\n        arr[i] != arr[length(arr)-i]\n\
    \    )\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\n    Given an integer\
    \ vector arr of integers, print all the permutations of the vector\n    in lexicographical\
    \ order except for duplicate entries. For example, if arr = [1,2,3]\n    the expected\
    \ output should be \n    1 2 3 1\n    1 2 3 2\n    1 2 3 3\n    1 2 3 4\n    1\
    \ 2 3 5\n    1 2 3 4\n    1 2 3 5\n    1 2 3 6\n    1 2 3 7\n    1 2 3 8\n   \
    \ 1 2 3 9\n    1 2 3 10\n    1 2 3 11\n    1 2 3 12\n    1 2 3 13\n    1 2 3 14\n\
    \    1 2 3 15\n    1 2 3 16\n    1 2 3 17\n    1 2 3 18\n    1 2 3 19\n    1 2\
    \ 3 20\n    1 2 3 21\n    1 2 3 22\n    1 2 3 23\n    1 2 3 24\n    1 2 3 25\n\
    \    1 2 3 26\n    1 2 3 27\n    1 2 3 28\n    1 2 3 29\n    1 2 3 30\n    1 2\
    \ 3 31\n    1 2 3 32\n    1 2 3 33\n    1 2 3 34\n    1 2 3 35\n    1 2 3 36\n\
    \    1 2 3 37\n    1 2 3 38\n    1 2 3 39\n    1 2 3 40\n    1 2 3 41\n    1 2\
    \ 3 42\n    1 2 3 43\n    1 2 3 44\n    1 2 3 45\n    1 2 3 46\n    1 2 3 47\n\
    \    1 2 3 48\n    1 2 3 49\n    1 2 3 50\n    1 2 3 51\n    1 2 3 52\n    1 2\
    \ 3 53\n    1 2 3 54\n    1 2 3 55\n    1 2 3 56\n    1 2 3 57\n    1 2 3 58\n\
    \    1 2 3 59\n    1 2 3 60\n    1 2 3 61\n    1 2 3 62\n    1 2 3 63\n    1 2\
    \ 3 64\n    1 2 3 65\n    1 2 3 66\n    1 2 3 67\n    1 2 3 68\n    1 2 3 ", " \
    \   n = length(arr)\n    pal = 0\n    for i = 1:n\n        if arr[i] != reverse(i)\n\
    \            pal += 1\n        end\n    end\n    return pal\nend", "    len_arr=length(arr)\n\
    \    len_min=max(arr,len_arr)\n    sum_len=sum_eltype(arr)\n    sum_palin=sum_palindrome(arr)\n\
    \    if len_min==len_arr\n        if sum_len == sum_palin\n            return\
    \ 1\n        end\n    end", "  min_count = 0\n  if length(arr)>2\n    min_count\
    \ = length(arr)-2\n  else\n    min_count = 0\n  end\n  for i=1:length(arr)\n \
    \   if arr[i]<arr[i+1]\n      min_count = min(min_count,length(arr)-2)\n    else\n\
    \      min_count = length(arr)\n    end\n  end\n  return min_count\nend\nsmallest_change()\n\
    </cell>\n<code language=julia-1.5>", "    if length(arr) == 0 \n        return\
    \ 0 \n    \n    #find starting index\n    i = 0 \n    while i >= 0 && arr[i] !=\
    \ reverse(arr[i]) do \n        i = i - 1 \n    end \n    \n    \n    #find ending\
    \ index\n    i = length(arr) - 1 \n    while i >= 0 && arr[i] != reverse(arr[i])\
    \ do \n        i = i - 1 \n    end \n    \n    if i >= 0 \n        return i\n\
    \    else \n        return length(arr) \n    end \nend ", "    if length(arr)==1\n\
    \        return 0\n    if arr[1]<arr[0]\n        return 0\n    i=2\n    while\
    \ i<length(arr)\n        if arr[i-1]>arr[i]\n            break\n        end\n\
    \        if arr[i]>arr[i-1]\n            i-=1\n        else\n            i+=1\n\
    \        end\n    end\n    return i-1\nend\n</cell>\n<code language=julia-1.4>",
  "    min = Inf\n    min = min(smallest_change(a) for a in arr)\n    return min\n\
    end ", "    changes = 0\n    index = Vector{Int64}(arr)\n    while true\n    \
    \    if all(index .== index) \n            return changes\n        end \n    \
    \    length = length(index)\n        if length == 1  \n            index = remove(index,\
    \ index[1])\n        else\n            index = remove(index, arr[1])\n       \
    \     changes += 1\n        end\n    end\nend", "    left,right,smallest=0,len(arr)-1,0\n\
    \    while  left<=right\n        if arr[left]==arr[right]\n            if left==right\n\
    \                return 0\n            else\n                smallest+=1\n   \
    \         end\n        else\n            if arr[left]<arr[right]\n           \
    \     smallest+=arr[left]+1\n            else\n                smallest+=arr[right]+1\n\
    \            end\n        end\n        left+=1\n        right-=1\n    end\n  \
    \  return smallest\nend", "    lenarr = length(arr)\n    largest = 0\n    if lenarr\
    \ > 1\n        for i = 2 to lenarr\n            if arr[i] > largest\n        \
    \        largest = arr[i]\n            else\n                if arr[i] != largest\
    \ && arr[i] != arr[lenarr-i-1]\n                    return 0\n               \
    \ end\n            end\n        end\n        return 1\n    end\n    return 0\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    Given a vector arr of integers,\
    \ find the minimum number of elements that\n    need to be changed to make the\
    \ vector palindromic. A palindromic vector is a vector that\n    is read the same\
    \ backwards and forwards. In one change, you can change one element to any other\
    \ element.", "    l = length(arr)\n    if l == 0 || l == 1\n        return 0\n\
    \    \n    \n    if arr[1] < arr[l]\n        return smallest_change(Array{Int64,2}(arr[2,1],\
    \ arr[2,2]) + arr[2:l,1]) + smallest_change(Array{Int64,2}(arr[2,1], arr[2,2])\
    \ + arr[2:l,2])\n    else\n        return smallest_change(Array{Int64,2}(arr[2,1],\
    \ arr[2,2]) + arr[2:l,1]) + smallest_change(Array{Int64,2}(arr[2,1], arr[2,2])\
    \ + arr[2:l,2])\n    end\nend\n\"\"\"\n    Given a matrix arr of integers, find\
    \ the minimum number of elements that\n    need to be changed to make the matrix\
    \ palindromic. A palindromic matrix is a matrix that is\n    read the same backwards\
    \ and forwards. In one change, you can change one element to any other element.",
  "    min_changes = 0\n    min_changes_count = 0\n    mid_index = (length(arr) -\
    \ 1)/2\n    i = 0\n    while i <= mid_index\n        # get the change and count\n\
    \        change = abs(arr[mid_index] - arr[mid_index - i])\n        change_count\
    \ = abs((length(arr)-i) - length(arr))\n        # get the minimum change\n   \
    \     if change < min_change\n            min_changes = change\n            min_changes_count\
    \ = change_count\n        else\n            break\n        end\n        i += 1\n\
    \    end\n    return min_changes_count\nend", '    if len(arr)<=1 return 0 end',
  "    # O(n log n)\n    arr = sort(arr)", "    # Write your code here.\n    len =\
    \ length(arr)\n    i = 0\n    j = len - 1\n    while i <= j\n        if arr[i]\
    \ > arr[j]\n            swap!(arr, i, j)\n            i += 1\n            j +=\
    \ 1\n        else\n            j -= 1\n        end\n    end\n    \n    if i ==\
    \ j\n        return len - 2\n    elseif i == j + 1 || i == j - 1\n        return\
    \ 1\n    else\n        return 0\n    end\nend\nsmallest_change(a)\n</cell>\n<text>\n\
    Problem 8\nWrite a function which takes a String as a parameter and returns True\
    \ if the String is all lowercase, False otherwise.", "    \n    minimum_change\
    \ = 0\n    for index in range(len(arr))\n        if arr[minimum index] == arr[maximum\
    \ index]\n            minimum_change += 1\n        else\n            minimum_change\
    \ = 0\n        end\n    end\n    return minimum_change\nend", "    #code goes\
    \ here\n    return 0\nend\n</cell>\n<text>\nThe second problem involves the problem\
    \ of finding the largest palindromic number. Fortunately, the answer given is\
    \ O(n log n), which you can see in the following code block.", "    \n    if arr.len\
    \ > 0\n        if issorted(arr)\n            if arr[1] == reverse(arr[1])\n  \
    \              return reverse(arr[2])\n            else \n                return\
    \ reverse(arr[1])\n        end", "    m = min_length(arr)\n    \n    if m == 1\
    \ \n        return 0 \n    end", "    if length(arr) == 0 \n        return 0\n\
    \    else if length(arr) == 1 \n        return length(arr)\n    else if length(arr)\
    \ == 2 \n        return 1 \n    end\n    \n    # find minimum number of elements\
    \ to change to palindrome\n    minimum = 0\n    \n    for i in arr \n        minimum\
    \ = min(minimum, length(arr) - length([reverse(arr)])) \n    end\n    \n    return\
    \ minimum\nend\n</cell>\n<text>\nA test case is included below to ensure that\
    \ the function works as intended.", "    # Write your code here\n    return length(arr)-length(arr)/2\n\
    end\n</cell>\n<code language=julia-1.0>\n@code_warntype smallest_change([1, 2,\
    \ 3, 5, 4, 7, 9, 6])\n@code_warntype smallest_change([1, 2, 3, 4, 3, 2, 2])\n\
    @code_warntype smallest_change([1, 2, 3, 2, 1])\n</cell>\n<text>\nSolution 3",
  "    l = length(arr)\n    if l < 2\n        return 0\n    \n    left = arr[1]\n\
    \    right = arr[l]\n    for index in 2:l\n        if arr[index] < left\n    \
    \        left = arr[index]\n        elseif arr[index] > right\n            right\
    \ = arr[index]\n        end\n    end\n    return min(right - left + 2, l - 1)\n\
    end", "    sz=length(arr)\n    if sz == 0 return 0\n    if sz == 1 return arr[0]\
    \ - arr[1]\n    \n    mid=ceil(sz/2)\n    \n    i=2\n    j=sz\n    \n    count=0\n\
    \    while j < mid\n        \n        while arr[j] < arr[j-1]\n            arr[j]-=1\n\
    \            j-=1\n            count=count+1\n        end\n        while arr[j]\
    \ > arr[j+1]\n            j+=1\n            count=count+1\n        end\n    end\n\
    \    \n    if arr[0] != arr[-1] count=count-1\n    return count\nend\n</cell>\n\
    <text>\nNow let's test the function:", "    changes = 0\n    lenarr = length(arr)\n\
    \    for i in 1:(lenarr - 2)\n        if arr[i] == arr[i+1]\n            changes\
    \ += 1\n            arr[i+1] = arr[i]\n        end\n    end\n    return changes\n\
    end\n</cell>\n<code language=julia-0.5>", "    largest, i = max(arr), 1\n    while\
    \ largest != reverse(arr[i])\n        i += 1\n    end\n    i\nend\n</code>\n<|/\
    \ a tags=julia |>\n<| a dscore=1 tags=julia |>\n<code>", "    length = len(arr)\n\
    \    if length < 2 \n        return length \n    minimum = length(1) \n    for\
    \ i = 2:length\n        if arr[i] != arr[length-i-1]\n            minimum = minimum\
    \ + minimum\n        end\n    end\n    return minimum\nend", "    \"\"\"\n   \
    \ Given a vector arr of integers, find the minimum number of elements that\n \
    \   need to be changed to make the vector palindromic. A palindromic vector is\
    \ a vector that\n    is read the same backwards and forwards. In one change, you\
    \ can change one element to any other element.", "    \"\"\"\n    You can't change\
    \ the number 0, and you can't change it into any other number.\n    \"\"\"\n \
    \   smallest_change = 0\n    for n in arr\n        if n == 0\n            continue\n\
    \        if n != arr[length(arr)-n]\n            smallest_change += 1\n      \
    \  end\n    end\n    return smallest_change\nend\n</cell>\n<text>\nThe smallest_change\
    \ function has a return type of Int64. It will always return an Int64 value. You\
    \ do not need to specify the type here, but you will if you are consistent.",
  "    len = length(arr)\n    if len > 1 \n        for i = len - 1 downto 1 do \n\
    \            if arr[i] > arr[i + 1] \n                swap(arr, i, i + 1)\n  \
    \          end \n        end\n    end\n    len = length(arr)\n    low = 0\n  \
    \  high = len - 1\n    while low < high\n        if arr[low] == arr[high]\n  \
    \          low = low + 1\n            high = high - 1\n        else\n        \
    \    if arr[low] > arr[high]\n                swap(arr, low, high)\n         \
    \       low = low + 1\n                high = high - 1\n            else\n   \
    \             low = low + 1\n            end\n        end\n    end\n    return\
    \ length(arr)\nend\n</cell>\n<code language=julia-1.5>", "    palindron_arr =\
    \ []\n    function isPalindrome(arr::Vector{Int64}, ind::Int64, i::Int64, j::Int64)::Bool\n\
    \        if i == j\n            palindron_arr[ind] = arr[i]\n            return\
    \ true\n        end\n        if arr[i] != arr[j]\n            return false\n \
    \       end\n        return isPalindrome(arr, ind+1, i-1, j-1)\n    end\n    palindron_arr\
    \ = []\n    isPalindrome(arr, 0, arr.size-1, 0)\n    smallest = palindron_arr.length\n\
    \    for i=1:(smallest + 1)\n        if palindron_arr[i] > palindron_arr[i+1]\n\
    \            smallest = i\n            break\n        end\n    end\n    return\
    \ smallest\nend", "    ans = -1\n    for i=length(arr)-1 downto 0 do \n      \
    \  if arr[i] > arr[-i] \n            ans = i\n            break\n        end\n\
    \    end\n    return ans\nend\n</cell>\n<code language=julia-1.4>", "    for i\
    \ in reverse(arr) \n       if arr[i] != i \n           return arr.size - 1 \n\
    \       end\n    \n    return arr.size \nend", "    # Your code here\n    minimum\
    \ = 0\n    for i in 1:length(arr)\n        if arr[minimum] == arr[maximum]\n \
    \           minimum = minimum + 1\n        else\n            minimum = minimum\
    \ + 1\n        end\n    end\n    return minimum", "    len = length(arr)\n   \
    \ arr2 = reverse(arr)\n    flag = 1\n    i = 2\n    while i < len\n        if\
    \ arr[i] > arr2[len-i-1]\n            flag = -1\n            break\n        end\n\
    \        i += 1\n    end\n    return flag\nend\n</cell>\n<code language=julia-1.0>\n\
    smallest_change([1,2,3,4,3,2,1])\n</cell>\n<text>\nProblem 7\nGiven a binary search\
    \ tree and a number 'x' find the node in the search tree where 'x' is in its left\
    \ subtree. If such node doesn't exist, find the node in the search tree where\
    \ 'x' is in its right subtree.", "    if length(arr)==1 return 0\n    \n    min_change\
    \ = 0\n    for i in reverse(arr):\n        if i == reverse(arr[end])\n       \
    \     return min_change\n        elseif min_change == 0 && i == reverse(arr[end])\n\
    \            min_change = i - reverse(arr[end])\n        end\n    end\n    return\
    \ min_change\nend\n</cell>\n<code language=julia-1.5>\nsmallest_change([2, 1,\
    \ 2, 3])\n</cell>\n<code language=julia-1.5>\nsmallest_change([2, 2, 1])\n</cell>\n\
    <code language=julia-1.5>\nsmallest_change([2, 1])\n</cell>\n<code language=julia-1.5>\n\
    smallest_change([2, 1, 2])\n</cell>\n<code language=julia-1.5>\nsmallest_change([2,\
    \ 2])\n</cell>\n<code language=julia-1.5>\nsmallest_change([1, 2])\n</cell>\n\
    <code language=julia-1.5>\nsmallest_change([1, 2])\n</cell>\n<code language=julia-1.5>\n\
    smallest_change([2])\n</cell>\n<code language=julia-1.5>\nsmallest_change([2])\n\
    </cell>\n<code language=julia-1.5>\nsmallest_change([1])\n</cell>\n<code language=julia-1.5>\n\
    smallest_change([1])\n</cell>\n<code language=julia-1.5>\nsmallest_change([])\n\
    </cell>\n<code language=julia-1.5>", "    lenArr = length(arr)\n    largestIndex\
    \ = argmax(arr)\n    largestValue = arr[largestIndex]\n    return 1 if (largestValue\
    \ == arr[1]) \n    else 0 if (largestValue == arr[lenArr]) \n    else (largestIndex\
    \ + 1) + (1 - largestValue) \nend\n</cell>\n<code language=julia-1.5>\nsmallest_change([1,\
    \ 2, 3, 5, 4, 7, 9, 6])\n</cell>\n<code language=julia-1.5>", "    arr = reverse(arr)\n\
    \    return count_change(arr) < length(arr) ? count_change(arr) \n        : count_change(arr)\
    \ - 1\nend", "    # Write your code in Julia 0.6 or later\n    \n    return minimum(length(arr)\
    \ - arr.take(1:length(arr) - 1))\nend\n\"\"\"\n    Given a vector arr of integers,\
    \ find the minimum number of elements that\n    need to be changed to make the\
    \ vector palindromic. A palindromic vector is a vector that\n    is read the same\
    \ backwards and forwards. In one change, you can change one element to any other\
    \ element.", "        arrlength = length(arr)\n        if arrlength <= 1 \n  \
    \          return 0\n        else\n            i = 0\n            while i < arrlength\
    \ \n                j = i\n                while j < arrlength\n             \
    \       if arr[j] != arr[j+1] \n                        break;\n             \
    \       end\n                    j = j + 1\n                end\n            \
    \    j = i\n                while j < arrlength\n                    if arr[j]\
    \ != arr[j-1] \n                        break;\n                    end\n    \
    \                j = j - 1\n                end\n                i = i + 1\n \
    \           end\n        end\n        return i - 2\n    end\n    return 0\nend",
  "    arr_copy = deepcopy(arr)\n    if arr_copy == reverse(arr)\n        return 1\n\
    \    else \n        return 0\n    end\nend", "    smallest = minimum(arr)\n  \
    \  largest = maximum(arr)\n    \n    arr2 = copy(arr)\n    \n    # first loop\
    \ to check for palindromiciy\n    for i in reverse(1:length(arr))\n        if\
    \ arr[i] != arr2[end-1]\n            arr2[end-1] = arr[i]\n            break\n\
    \        end\n    end\n    \n    # second loop to check for smallest change\n\
    \    for i in reverse(1:length(arr))\n        if arr[i] != arr2[end-1]\n     \
    \       if smallest == 0\n                smallest = i\n            end\n    \
    \        break\n        end\n    end\n    \n    # third loop to check for largest\
    \ change\n    for i in reverse(1:length(arr))\n        if arr[i] != arr2[end-1]\n\
    \            if largest == length(arr)-1\n                largest = i\n      \
    \      end\n            break\n        end\n    end\n    \n    if smallest ==\
    \ largest \n        return 0\n    end", "    arr.sort!()\n    start = end - 1\n\
    \    while start > 0 \n        arr[start] == arr[end]\n        start -= 1\n  \
    \      end -= 1\n    end = 0\n    while end < arr.length \n        arr[end] ==\
    \ arr[start]\n        end += 1\n        start += 1\n    return end - 1\nend",
  "    max = maximum(arr)\n    if max < length(arr)\n        return 0\n    end\n \
    \   if isna(arr)\n        return -1\n    end\n    return maximum(arr) + length(arr)\
    \ - 2\nend\nsmallest_change(arr::Array{Int64,1})\nsmallest_change(arr::Array{Int64,2})\n\
    </cell>\n<code language=julia-1.3>", "    len = length(arr)\n    i = len/2\n \
    \   min = abs(len/2 - 1)\n    while i < len\n        if arr[i] != arr[len-i-1]\n\
    \            if arr[i] > arr[len-i-1]\n                min -= 1\n            end\n\
    \        end\n        i += 1\n    end\n    return min\nend\nsmallest_change(vector())\n\
    </cell>\n<text>\nThe function smallest_change returns the smallest number of changes\
    \ you need to make the vector palindromic, starting with the first element. If\
    \ there are no elements left in the vector, return 0.", "    # Write your code\
    \ here\n    i = 0\n    \n    while i < length(arr) - 2\n        if arr[i] != arr[i+1]\n\
    \            i += 2\n        else\n            i += 1\n        end\n    end\n\
    \    \n    if i == length(arr)\n        return 1\n    else\n        return 0\n\
    \    end\nend\nsmallest_change(vec)\n</cell>\n<text>\nQuestion 5.", "    \n  \
    \  \n    smallest_change_vector = Array(Int64, length(arr))\n    for i =1:length(arr)\n\
    \        if arr[i] > length(arr)\n            smallest_change_vector[i] = 0\n\
    \        elseif arr[i] < 0\n            smallest_change_vector[i] = 0\n      \
    \  else\n            smallest_change_vector[i] = 0\n            while arr[i] >\
    \ 0\n                smallest_change_vector[i] += arr[i]\n                arr[i]\
    \ -= 1\n            end\n            while arr[i] < 0\n                smallest_change_vector[i]\
    \ += arr[i]\n                arr[i] += 1 \n            end\n        end\n    end\n\
    \    \n    for i =1:length(arr)\n        if arr[i] > length(arr)\n           \
    \ smallest_change_vector[i] = 0\n        elseif arr[i] < 0\n            smallest_change_vector[i]\
    \ = 0\n        else\n            smallest_change_vector[i] = 0\n            while\
    \ arr[i] > 0\n                smallest_change_vector[i] += arr[i]\n          \
    \      arr[i] -= 1\n            end\n            while arr[i] < 0\n          \
    \      smallest_change_vector[i] += arr[i]\n                arr[i] += 1 \n   \
    \         end\n        end\n    end\n    \n    smallest_change_vector[smallest_change_vector==0]\
    \ = -1\n    if min(smallest_change_vector) == -1\n        return -1\n    elseif\
    \ max(smallest_change_vector) == -1\n        return 1\n    end", "    if arr.size\
    \ == 0\n        return 0\n    arr = sort(arr)\n    mid_idx = length(arr) / 2\n\
    \    left = arr[1..mid_idx]\n    right = arr[mid_idx+1..end]\n    # Check if both\
    \ sides are equal\n    if left == right\n        return 0\n    # Check if left\
    \ side is longer than right side\n    elif left > right\n        diff = left -\
    \ right\n        # Do a recursive call to solve the smaller difference\n     \
    \   change = smallest_change(left) + smallest_change(right)\n        # Return\
    \ the smaller difference\n        if change < diff\n            return diff\n\
    \        else\n            return change\n    # Check if left side is smaller\
    \ than right side\n    else\n        diff = right - left\n        # Do a recursive\
    \ call to solve the smaller difference\n        change = smallest_change(left)\
    \ + smallest_change(right)\n        # Return the smaller difference\n        if\
    \ change < diff\n            return change\n        else\n            return diff\n\
    end", "    arr_len = length(arr)\n    min_num = arr_len\n    for i = 2 to arr_len\n\
    \        if arr[i] == reverse(arr[i-1])\n            min_num = min_num - 1\n \
    \       end\n    end\n    return min_num\nend", "    #We have to reverse the vector\n\
    \    rev_arr = reverse(arr)\n    #The number of changes is equal to the number\
    \ of elements in the vector\n    return count(arr,rev_arr) - count(arr,arr)\n\
    end", "    \"\"\"\n    Given a vector arr of integers, find the minimum number\
    \ of elements that\n    need to be changed to make the vector palindromic. A palindromic\
    \ vector is a vector that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.", "    \"\"\"\n   \
    \ Given a vector arr of integers, find the minimum number of elements that\n \
    \   need to be changed to make the vector palindromic. A palindromic vector is\
    \ a vector that\n    is read the same backwards and forwards. In one change, you\
    \ can change one element to any other element.", "    l = length(arr) \n    minimum\
    \ = l\n    isPalindrome = reverse(arr)\n    \n    for i=1:l\n        if arr[i]\
    \ != isPalindrome[i]\n            minimum += 1\n        end\n    end\n    return\
    \ minimum\nend\nsmallest_change(Int64[])\n</cell>\n<text>\nThe first function\
    \ takes a vector of integers as an input and returns the minimum number of elements\
    \ required to make the vector a palindrome. For example, smallest_change([1, 2,\
    \ 3, 5, 4, 7, 9, 6]) returns 4 since there are 4 numbers that need to be changed\
    \ to make the vector a palindrome, [1, 2, 3, 4, 3, 2, 2] is one such vector which\
    \ has 6 elements that need to be changed to make it a palindrome, while [1, 2,\
    \ 3, 2, 1] is an empty vector which has 5 elements.", "    n = length(arr)\n \
    \   arr0 = arr[end]\n    for i in reverse(1:n)\n        if arr[i] < arr0\n   \
    \         arr0 = arr[i]\n        else\n            break\n        end\n    end\n\
    \    return length(arr[1 : end-1]) == length(arr0)\nend", "    max_length = maximum(arr)\n\
    \    max_length == 1 ? return 0 : -1\n    max_length\n    i = length(arr)\n  \
    \  j = i - 1\n    count = 0\n    while i != j\n        count += 1\n        j =\
    \ i - 1\n        if arr[i] > arr[j]\n            i += 1\n        elseif arr[i]\
    \ < arr[j]\n            j -= 1\n        else\n            i += 1\n           \
    \ j -= 1\n        end\n    end\n    count\nend\nsmallest_change(x)", "    left\
    \ = 0\n    right = (lengthof(arr))-1\n    while left <= right\n        if arr[left]\
    \ == arr[right]\n            left = left + 1 \n            right = right - 1\n\
    \        else\n            left = left + 1\n            right = right - 1\n  \
    \      end\n    end\n    return left\nend", "    # write your code in Julia here\n\
    \    return findlength(arr,1)\nend\n</code>\n<|/ a tags=algorithm,dynamic-programming,julia,arrays\
    \ dscore=0 |>\n<| c |>\nThis algorithm is O(n^2). Try `smallest_change([1,2,2,1])`.\n\
    <|/ c |>\n<| c |>\nThanks, I didn't even know Julia could do recursion. I was\
    \ looking for something that would take O(n).\n<|/ c |>\n<| c |>\nThat's because\
    \ `smallest_change([1,2,2,1])` is `2` and is repeated `2` times. If you could\
    \ give a dynamic programming solution, it'd be better.\n<|/ c |>\n<| c |>\nI've\
    \ edited my answer to include a solution with dynamic programming. Your solution\
    \ was correct for me though.\n<|/ c |>\n<| c |>\nI really appreciate your efforts\
    \ to help me. But, your algorithm fails most of the test cases. Please try on\
    \ some test cases and you will see. I think I have solved this question, but still\
    \ it would be great to have a better solution.\n<|/ c |>\n<| a |>\nIn case anyone\
    \ is still looking for a dynamic programming solution, I came up with:\n<code>",
  "    smallest_num = 0\n    for x in arr\n        if x <= arr[smallest_num]\n   \
    \         smallest_num += 1\n        else\n            return smallest_num\n \
    \       end\n    end\n    return smallest_num\nend\n</cell>\n<text>\nNow we write\
    \ a function that takes two vectors and outputs the element-wise product of them",
  "    return smallest_change(arr, 0)\nend\n</code>\n<|/ a dscore=3 |>\n<| a dscore=2\
    \ |>\nAnother solution would be to count the number of times a number appears\
    \ in an array. For example, if the array is [2, 3, 2, 3, 2], you can count the\
    \ number of 2's in the array, and compare it to the length of the array:\n<code>",
  "    len = length(arr)\n    return smallest_change(arr, 1, len)\nend", "    if arr.length\
    \ == 0 || arr.first != arr.last \n        return 0 \n    end = 0 \n    start =\
    \ length(arr) - 1 \n    while start > end \n        middle = start + trunc(Int,\
    \ length / 2) \n        if arr[middle] < arr[middle-1] \n            start = middle\
    \ + 1 \n        else \n            end = middle - 1 \n        end \n    end \n\
    \    return end - start + 1 \nend ", "    \"\"\"\n    Given a vector arr of integers,\
    \ find the minimum number of elements that\n    need to be changed to make the\
    \ vector palindromic. A palindromic vector is a vector that\n    is read the same\
    \ backwards and forwards. In one change, you can change one element to any other\
    \ element.", "    length::Int64 = length(arr)\n    smallest_change_value::Int64\
    \ = minimum(arr[length-1])\n    smallest_change_count::Int64 = 0\n    for i in\
    \ arr[length-1]:-1:1\n        if i == arr[length-1]\n            smallest_change_count\
    \ = i\n            break\n        if arr[i] < arr[i-1]\n            smallest_change_value\
    \ += i\n            break\n        if arr[i] > arr[i-1]\n            smallest_change_value\
    \ -= i\n            break\n    end\n    return smallest_change_value\nend", " \
    \  pal = copy(arr)\n   for i in reverse(1:length(pal))\n       if pal[i] != reverse(arr[i])\n\
    \           return length(pal) - i\n       end\n   end\n   return 0\nend", " \
    \   n = length(arr)\n    \n    i = 0\n    j = n - 1\n    while i < j\n       \
    \ if arr[i] < arr[j]\n            i -= 1\n        else\n            j -= 1\n \
    \       end\n    end", "    \n    len = length(arr)\n    \n    min = len\n   \
    \ \n    for i = len to 1 by -1\n        if arr[i] != reverse(arr[len-i-1])\n \
    \           min = i - 1\n            break\n        end\n    end\n    \n    return\
    \ min\nend\n</cell>\n<code language=julia-1.0>\nsmallest_change(arr)\n</cell>\n\
    <text>\nGiven an array, rotate the array to the left by k steps, where k is non-negative.",
  "    return smallest_change2(arr)\nend\n</cell>\n<code language=julia-1.0>", " \
    \   return length(arr) - smallest_change(reverse(arr))\nend\n</cell>\n<code language=julia-1.6>",
  "    # Write your code in Julia 0.5 here.\n    plen = length(arr)\n    if (plen\
    \ > 1)\n        min = 0\n        for i in 1:plen - 1\n            if arr[i] !=\
    \ arr[reverse arr[i]]\n                min = min + 1\n            end\n      \
    \  end\n    end\nend\n</cell>\n<text>\nExercise 8: Find the maximum element in\
    \ the array\nGiven a vector arr of integers, find the maximum element in the array.\
    \ We will use the Julia maximum() function for this.", "    if arr.length == 0\n\
    \        return 0\n    if length(arr) <= 1\n        return length(arr)\n    begin\
    \ = 1 \n    end = length(arr)\n    mid = 1\n    while mid <= end/2\n        mid\
    \ = begin + mid \n        if arr[mid-1] != arr[mid]\n            begin = mid\n\
    \        else\n            end = mid\n        end\n    end\n    return end - begin",
  "    len_arr = length(arr)\n    len_arr += 1\n    ans = 1\n    for n in arr[len_arr:-1:1]\n\
    \        if arr[n] < arr[n+len_arr]\n            ans += 1\n        end\n    end\n\
    \    ans\nend\n</cell>\n<text>\nExercise 3\nWrite a Julia function that takes\
    \ a vector arr and returns the number of different pairs of indices i, j in the\
    \ vector arr such that arr[i] > arr[j], with i \u2260 j. The output must be an\
    \ integer greater than or equal to 0.", "    \n    smallest = 1\n    \n    for\
    \ i in arr:\n        smallest=min(smallest, i==reverse(arr)[i])\n    \n    return\
    \ smallest\nend", "    if arr == reverse(arr)\n        return 1\n    else\n  \
    \      return 0\n    end\nend\n</cell>\n<text>\nProblem 5 - Largest Palindromic\
    \ Triplet \nYou will again have an array of integers and you will need to find\
    \ the largest palindromic triplet in it.", "    if arr.length == 1\n        return\
    \ 0\n    end\n    smallest_change(arr[1:end]) + 1 + smallest_change(arr[1:end-1])\
    \ \nend", "    \n    for i in reverse(arr)\n        if (arr[i] < arr[(length(arr)\
    \ - 1)]) && (arr[i] > arr[(length(arr) - 2)])\n            return 1\n        end\n\
    \    end\n    return 0\nend\n</cell>\n<text>\nThe last function you wrote was\
    \ largely the same as smallest_change but with an if statement that checked for\
    \ a palindrome. Write a function called largest_change that has the same functionality\
    \ as smallest_change, but for an $n$ element array.", "    \"\"\"\n    Input:\n\
    \    arr: A vector of integers consisting of only 0's and 1's", "    smaller =\
    \ 0\n    bigger = 0\n    for el in arr\n        if el > arr[smaller]\n       \
    \     smaller += 1\n        elseif el < arr[bigger]\n            bigger += 1\n\
    \        else\n            smaller = bigger\n            bigger += 1\n       \
    \ end\n    end\n    if arr[smaller] < arr[bigger]\n        smaller = bigger\n\
    \        bigger += 1\n    end\n    if arr[smaller] > arr[bigger]\n        smaller\
    \ = bigger\n        bigger -= 1\n    end\n    \n    if arr[bigger] < arr[smaller]\n\
    \        bigger = smaller\n        smaller -= 1\n    end\n    if arr[smaller]\
    \ > arr[bigger]\n        bigger = smaller\n        smaller += 1\n    end\n   \
    \ \n    return (bigger - smaller) + 1\nend", "    if length(arr) < 2 \n      \
    \  return 0 \n    \n    if arr[1] == arr[end] \n        return 1 \n    \n    left\
    \ = 1\n    right = length(arr) \n    while left < right \n        if arr[left]\
    \ != arr[right] \n            break\n        left += 1\n        right -= 1\n \
    \   \n    if right == left \n        return 1 \n    \n    return 1 + smallest_change(arr[left:right-1])\
    \ \nend", "    i = length (arr)-1\n    j = 0\n    while i < j\n        if arr[i]\
    \ > arr[j]\n            arr[i+1] = arr[i]\n            arr[i] = arr[j]\n     \
    \       arr[j] = arr[i]\n            i = i - 1\n        else j = j - 1\n    end\n\
    \    return length(arr)\nend\nsmallest_change(arr::Vector{Int64})\n</cell>\n<code\
    \ language=julia-1.0>", "    for i = 1:length(arr)-1 \n        if arr[i] > arr[i+1]\
    \ \n            arr[i], arr[i+1] = arr[i+1], arr[i] \n        end \n    end \n\
    \    \n    if arr[0] != arr[end] \n        arr[1] = arr[end] \n    end ", "  min\
    \ = 999\n  for num in arr \n    changes = 0\n    for x in arr\n      if x != num\n\
    \        changes += 1\n        if changes < min\n          min = changes\n   \
    \     end\n      end\n    end\n  end\n  return min\nend", "    count = 0\n   \
    \ for i=length(1)-1 downto 0 do\n        if arr[i] > reverse(arr[i])\n       \
    \     count += 1\n        end\n    end\n    return count\nend", "    sum = 0\n\
    \    for i in reverse(arr) \n        if i == reverse(arr[end]) \n            sum\
    \ += 1\n        else\n            break\n    end\n    return sum\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"\n    smallest_change(arr::Array{Int64,1})",
  "    # Write your code here.\n    largest = length(arr)\n    if largest == 1\n \
    \       return 0\n    smallest = largest\n    current = smallest\n    count =\
    \ 0\n    while current < largest\n        arr[current] = arr[current+1]\n    \
    \    current += 1\n        count += 1\n    end\n    count = 0\n    while current\
    \ > 1\n        arr[current] = arr[current-1]\n        current -= 1\n        count\
    \ += 1\n    end\n    largest = length(arr)\n    if largest == 1\n        return\
    \ 0\n    if count == 1\n        return 1\n    else\n        return count\nend\n\
    </cell>\n<text>\nProblem 5\nGiven a non-negative number represented as a string,\
    \ find the length of the longest substring without repeating characters.", " \
    \   n = length(arr)\n    if n>1\n        min = 0\n        for i=1:n\n        \
    \    if arr[i] > arr[n-i-1]\n                min = i\n            else\n     \
    \           if arr[i] != arr[n-i-1]\n                    min = n\n           \
    \     break\n            end\n        end\n        return min if min != n else\
    \ 1\n    else\n        return 1\n    end\nend\n</code>\n<|/ a tags=vector,julia\
    \ dscore=2 |>\n<| c |>\nWhat is the purpose of `min` in `return min if min !=\
    \ n else 1`?\n<|/ c |>\n<| a |>\nThis is my solution using Julia's builtins:\n\
    <code>\nusing LinearAlgebra\nusing Random", "    \n    if length(arr)==0 \n  \
    \      return 0 \n    else \n        if arr[1]<arr[2] \n            return 1+smallest_change(arr[end-1:end])\
    \ \n        else \n            return 1+smallest_change(arr[end-1:end]) \n   \
    \ end\nend\n</cell>\n<cell>\nsmallest_change([])\n</cell>\n<cell>\nsmallest_change([2])\n\
    </cell>\n<cell>\nsmallest_change([2, 3, 5])\n</cell>\n<cell>\nsmallest_change([2,\
    \ 3, 5, 7, 9])\n</cell>\n<cell>\nsmallest_change([2, 3, 5, 7, 9, 11])\n</cell>\n\
    <text>\nProblem 3\nGiven an array of strings (words), find the longest common\
    \ prefix of all strings.", "    min_num_elem = 0\n    for i = length(arr)-1 downto\
    \ 1 \n        if arr[i] < arr[i-1]\n            min_num_elem = 1\n        elseif\
    \ arr[i] > arr[i-1]\n            min_num_elem = 2\n        end\n    end\n    return\
    \ min_num_elem\nend\n</cell>\n<code language=julia-1.5>", "    max_length=0\n\
    \    min_length=0\n    if arr.length == 0\n        return 0\n    for i in arr\n\
    \        if i==reverse(i)\n            max_length+=1\n        else\n         \
    \   min_length+=1\n    end\n    return max_length-min_length\nend", "    arr.reverse\n\
    \    sum = 0\n    for i in arr\n        sum += (i > arr[-1]) | (i < arr[1])\n\
    \    end\n    arr.reverse\n    return sum\nend\n</cell>\n<code language=julia-1.0>\n\
    #=\nA palindromic vector is a vector that is read the same backwards and forwards.\
    \ In one change, you\ncan change one element to any other element. A palindromic\
    \ vector is a vector that is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element. For example:\n    \n    >>>\
    \ smallest_change([1, 2, 3, 5, 4, 7, 9, 6])\n    4\n    >>> smallest_change([1,\
    \ 2, 3, 4, 3, 2, 2])\n    1\n    >>> smallest_change([1, 2, 3, 2, 1])\n    0\n\
    =#\n</cell>\n<code language=julia-1.0>\nsmallest_change([1, 1, 2, 3, 4, 3, 2,\
    \ 1])\n</cell>\n<text>\nQ5.1 Write a function that returns a vector of numbers\
    \ from 1 to n such that each number is a palindromic vector, and that each palindromic\
    \ vector is of length greater than 1.", "    arr_size = length(arr)\n    if arr_size\
    \ == 1\n        return 0\n    mid = arr_size / 2\n    if arr_min == arr[mid]\n\
    \        return 0\n    left_change = smallest_change(arr[mid+1:end])\n    right_change\
    \ = smallest_change(arr[end-mid-1:end])\n    if right_change < left_change \n\
    \        return left_change\n    else\n        return right_change\n    end\n\
    end\n</code>\n<|/ a tags=julia |>\n<| a tags=julia |>\nI needed a solution which\
    \ took into account duplicates and repeated entries. This one should handle duplicates\
    \ and repeated entries, it also handles the case where the array is empty by returning\
    \ the length of the array.\n<code>", "  len_arr = length(arr)\n  if len_arr ==\
    \ 0  \n    return 0\n  else\n    mid = floor(len_arr / 2)\n    if arr[mid] !=\
    \ arr[mid-1]\n      arr[mid] = arr[mid-1]\n      return  1 + smallest_change(arr[mid-1:mid+1])\n\
    \    else\n      return  1 + smallest_change(arr[mid+1:mid+2])\n    end\n  end\n\
    end\n</cell>\n<text>\nProblem 4\nA palindromic number reads the same backwards\
    \ and forwards.\nGiven a number N, check if it is the palindrome of that number.",
  "    largest = maximum(arr)\n    largest, idx = find_idx(arr, largest)\n    return\
    \ 0 if idx == length(arr) - 1 && arr[largest] == largest else 1\nend", "  \n \
    \   return length(arr) > length(arr) ? (length(arr) - length(arr)) : 0\nend",
  "    largest = maximum(arr)\n    minimum = minimum(arr)", "    n = length(arr)\n\
    \    if n < 4\n        return 0\n    end\n    mid = n / 2\n    if arr[mid] ==\
    \ mid\n        return smallest_change(leftmost_index(arr, mid))\n    else\n  \
    \      return min(smallest_change(leftmost_index(arr, mid - 1)), \n          \
    \         smallest_change(rightmost_index(arr, mid + 1)))\n    end\nend", "  \
    \  changes = 1\n    for i = length(arr) - 1 : -1 : 0 \n        last = arr[i]\n\
    \        next = arr[i+1]\n        if last == next\n            changes -= 1\n\
    \        end\n    end\n    changes\nend", "    if arr.length == 0 \n        return\
    \ 0 \n    end", "    smallest_val::Int64 = inf\n    smallest_i = 0\n    smallest_count\
    \ = 0\n    for val in arr\n        if val < smallest_val\n            smallest_val\
    \ = val\n            smallest_i = val\n            smallest_count = 1\n      \
    \  elseif val == smallest_val\n            smallest_count += 1\n        else\n\
    \            if smallest_count > 1\n                smallest_i = val\n       \
    \         smallest_count = smallest_count + 1\n            else\n            \
    \    smallest_count = 0\n            end\n        end\n    end\n    return smallest_i\n\
    end\n</cell>\n<code language=julia-1.0>\nsmallest_change([1,5,2,3,7,5,4])\n</cell>\n\
    <text>\nQuestion 3.2\nWrite a function largest(arr::Vector{Int64})::Int that takes\
    \ an array of integers, and returns the largest element in the array. Your function\
    \ should work for an array of integers and strings. For strings such as \"Hello\
    \ World\", your function should return \"World\".", "        arr2 = Vector{Int64}(arr)\n\
    \        smallest = 100\n        smallest_index = 0\n        for i in 1:length(arr)\n\
    \            current = arr[i]\n            index = i\n            while(index\
    \ != 0)\n                if(current > arr[index-1])\n                    arr[index]\
    \ = arr[index-1]\n                    index = index - 1\n                else\n\
    \                    break\n            arr[index] = current\n            for\
    \ j in i+1:length(arr)\n                current = arr[j]\n                index\
    \ = j\n                while(index != 0)\n                    if(current < arr[index-1])\n\
    \                        arr[index] = arr[index-1]\n                        index\
    \ = index - 1\n                    else\n                        break\n     \
    \           arr[index] = current\n            \n            smallest_change(arr)\n\
    \        end\n        return smallest_index\n    end\n    smallest_change(arr)\n\
    end", "    largest = max(arr)\n    smallest = min(arr)\n    count = 0\n    for\
    \ el in arr\n        if el == largest\n            largest = largest - 1\n   \
    \     elseif el == smallest\n            smallest = smallest + 1\n        else\n\
    \            count += 1\n            if largest == largest-1\n               \
    \ if largest == smallest + 1\n                    largest = largest + 1\n    \
    \                smallest = smallest + 1\n                end\n            end\n\
    \        end\n    end\n    return count\nend\n\"\"\"\n    Write a function that\
    \ takes a string and returns the number of words in it.\n    \n    Suppose you\
    \ have a string \"I like cheeseburgers\" where \"I\" is the first word\n    in\
    \ the string. The function should return 2.", "    \n    # Initialize minimum\
    \ number as 0\n    min_change = 0\n    \n    # Run through the vector\n    for\
    \ idx = 1:length(arr)\n        \n        # Keep track of the current minimum number\n\
    \        current_min = arr[idx]\n        \n        # If current min is the same\
    \ as the one before, no need to change it\n        if arr[idx-1] == current_min\n\
    \            min_change = idx\n            break\n        \n        # Else, check\
    \ if the current min is greater than the one before\n        elseif arr[idx-1]\
    \ > current_min\n            \n            # Update the minimum number as it is\
    \ larger\n            min_change = idx\n            \n            # Run through\
    \ the rest of the vector\n            for idx2 = idx + 1:length(arr)\n       \
    \         \n                # If current min is greater than the one before and\
    \ current min is smaller than or equal to the one before, break\n            \
    \    if arr[idx2] < current_min || arr[idx2] == current_min && arr[idx2-1] >=\
    \ current_min\n                    break\n                else\n             \
    \       # Increment the current min and keep track of the minimum number\n   \
    \                 current_min = arr[idx2]\n                    min_change = idx2\n\
    \                end\n            end\n        end\n    end\n    \n    return\
    \ min_change\nend", "    i = length(arr)\n    if i == 0 return 0\n    if i ==\
    \ 1 return 1\n    j = 0\n    while j < i do\n        if arr[j] != reverse(arr[j])\
    \ \n            return 1 + i - j\n        j += 1\n    end\n    return i\nend",
  "    left_index = 0\n    right_index = length(arr)-1\n    while left_index <= right_index\n\
    \        if arr[left_index] > arr[right_index]\n            left_index += 1\n\
    \        elseif arr[left_index] < arr[right_index]\n            right_index -=\
    \ 1\n        else\n            return length(arr) - length(arr[left_index : right_index+1])\n\
    \        end\n    end\n    return 0\nend", "    minimum=0\n    maximum=length(arr)-1\n\
    \    \n    while (minimum < maximum)\n        minimum = minimum + length(arr)\
    \ - maximum\n        maximum = maximum - length(arr)\n    end\n    \n    return\
    \ minimum\nend\n\"\"\"\n    Given a vector arr of integers, find the first longest\
    \ palindromic subsequence.\n    A longest palindromic subsequence is a sequence\
    \ that reads the same backwards and forwards. \n    For example, [1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9, 1] would be a longest palindromic subsequence. \n    In the example\
    \ [4, 3, 2, 1, 2] the longest palindromic subsequence is [4, 3, 2, 2], which is\
    \ itself a palindromic \n    subsequence, but [4, 3, 2] and [2, 4, 3] are not\
    \ palindromic subsequences since subsequences have different lengths.\n    \n\
    \    We assume that arr is non-empty. ", "    smallest_change_ = 0\n    for x\
    \ in arr\n        min_change = min(min_change, count_change(arr, x))\n    end",
  "    largest = maximum(arr)\n    smallest = minimum(arr)", "  result = 0\n  for\
    \ e in arr\n    if e < 0\n      continue\n    if e > arr.length-1\n      continue\n\
    \    for j in (arr.length-1)::-1:0\n      if arr[j] != e\n        result += abs(e-j-1)\n\
    \        break\n    end\n  end\n  return result\nend", "    low = inf\n    high\
    \ = arr.length - 1\n    while low < high\n        if arr[low] < arr[high]\n  \
    \          low = low + 1\n        elseif arr[low] == arr[high]\n            if\
    \ low == high\n                low = low + 1\n            elseif arr[low] > arr[high]\n\
    \                high = high - 1\n            else\n                low = low\
    \ + 1\n                high = high - 1\n            end\n        else\n      \
    \      low = low + 1\n            high = high - 1\n        end\n    end\n    return\
    \ low\nend\n</cell>\n<code language=julia-1.0>", "    len = length(arr)\n    \n\
    \    if len < 2 \n        return 0 \n    end\n    \n    if is_palindrome(arr)\
    \ \n        return len \n    end\n    \n    i = 2\n    while i < len \n      \
    \  if arr[i] != arr[i-1:i+1] \n            break\n        else \n            i\
    \ += 1\n        end\n    end\n    \n    return i - 1\nend\nsmallest_change([])\
    \ = 0\nsmallest_change([1 ; 2 ; 3]) = 1\nsmallest_change([2 ; 1]) = 2\nsmallest_change([1,\
    \ 2]) = 2\nsmallest_change([2 ; 3]) = 2\nsmallest_change([4 ; 5]) = 3\nsmallest_change([2\
    \ ; 1]) = 1\nsmallest_change([4]) = 3\nsmallest_change([1 ; 5]) = 1\nsmallest_change([2\
    \ ; 6]) = 2\nsmallest_change([4 ; 3]) = 3\nsmallest_change([2 ; 3]) = 2\nsmallest_change([3\
    \ ; 2]) = 2\nsmallest_change([5 ; 3]) = 3\nsmallest_change([1, 3, 5]) = 3\nsmallest_change([1,\
    \ 2, 4]) = 2\nsmallest_change([1, 2]) = 2\nsmallest_change([3, 2, 1]) = 1\nsmallest_change([3,\
    \ 2, 1]) = 1\nsmallest_change([3, 2, 1]) = 1\nsmallest_change([1, 2, 3, 2, 1])\
    \ = 2\nsmallest_change([3, 2, 1]) = 1\nsmallest_change([3, 2, 1]) = 1\nsmallest_change([3,\
    \ 2, 1]) = 1\nsmallest_change([1, 2, 3]) = 2\nsmallest_change([3, 2, 1]) = 1\n\
    smallest_change([1, 2, 3]) = 2\nsmallest_change([3, 2, 1]) = 1\nsmallest_change([1,\
    \ 2, 3]) = 2\nsmallest_change([3, 2, 1]) = 1\nsmallest_change([1, 2, 3]) = 2\n\
    smallest_change([3, 2, 1]) = 1\nsmallest_change([3, 2, 1]) = 1\nsmallest_change([1,\
    \ 2, 3]) = 2\nsmallest_change([3, 2, 1]) = 1\nsmallest_change([3, 2, 1]) = 1\n\
    smallest_change([1, 2, 3]) = 2\nsmallest_change([3, 2, 1]) = 1\nsmallest_change([1,\
    \ 2, 3]) = 2\nsmallest_change([3, 2, 1]) = 1\nsmallest_change([3, 2, 1]) = 1\n\
    smallest_change([1, 2, 3]) = 2\nsmallest_change([3, 2, 1]) = 1\nsmallest_change([3,\
    \ 2, 1]) = 1\nsmallest_change([3, 2, 1]) = 1\nsmallest_change([1, 2, 3]) = 2\n\
    smallest_change([3, 2, 1]) = 1\nsmallest_change([3, 2, 1]) = 1\nsmallest_change([3,\
    \ 2, 1]) = 1\nsmallest_change([1, 2, 3]) = 2\nsmallest_change([3, 2, 1]) = 1\n\
    smallest_change([3, 2, 1]) = 1\nsmallest_change([3, 2, 1]) = 1\nsmallest_change([3,\
    \ 2, 1]) = 1\nsmallest_change([1, 2, 3]) = 2\nsmallest_change", "    if length(arr)==1\n\
    \        return length(arr)\n    end\n    smaller = ones(Int64, length(arr)-1)\n\
    \    smaller[1] = maximum(arr)\n    for i in 2:length(arr)\n        if arr[i-1]\
    \ <= arr[end-1]\n            smaller[i] = smaller[i-1] + 1\n        else\n   \
    \         smaller[i] = maximum(smaller)\n        end\n    end\n    return smaller[end-1]\n\
    end\n</code>\n<|/ a tags=julia,arrays |>\n<| a dscore=1 tags=julia,arrays |>\n\
    I solved this in two steps. \nStep 1: Sort the array\nStep 2: Find the difference\
    \ between the first and the last elements of the sorted array. \n<code>", "  \
    \  if arr==reverse(arr); return 0; end\n    if arr==arr[::-1]; return 1; end\n\
    \    return min(arr.size, smallest_change(reverse(arr)))\nend\n</cell>\n<text>\n\
    Next is longest_change. It takes the length of a vector, checks if it is palindromic,\
    \ and returns the longest palindromic vector.", "    if length(arr) == 1 \n  \
    \      return 0 \n    end\n    min_size = Int64(1)\n    for index in 1:length(arr)\
    \ \n        min_size = min(min_size, \n                        smallest_change(arr[index+1:end])\
    \ + length(arr[index]), \n                        smallest_change(arr[index-1:end])\
    \ + length(arr[index]))\n    end\n    return min_size \nend\nsmallest_change(x::Vector{Int64})\
    \ = smallest_change(x)\nsmallest_change(x::Vector{Int}) = Int64(length(x))\nsmallest_change(x::Vector)\
    \ = Int64(length(x))", "    len = length(arr)\n    if len <= 1 \n        return\
    \ 0\n    if len % 2 == 1 \n        return len / 2\n    i = 1\n    while i < len\
    \ - 1 \n        if arr[i-1] > arr[i] \n            return len\n        i += 1\n\
    \    end\n    return 0\nend", "    smallest_change = Inf \n    for i=1:length(arr)\
    \ \n        if arr[i] == arr[(length(arr)-i)] \n            smallest_change =\
    \ i \n        end\n    end\n    \n    return smallest_change\nend", "    if len(arr)<2\n\
    \        return 0\n    end1 = reverse(arr[2:end-1])\n    begin1 = arr[1:end-1]\n\
    \    return length(find(begin1 .== end1))\nend\n</code>\n<|/ a tags=arrays,julia,linked-list,algorithm,vector\
    \ |>\n<| c |>\nThis is actually the best answer I've found so far. I was considering\
    \ writing my own answer, but this was the only implementation that actually works.\
    \ Thanks!\n<|/ c |>\n<| c |>\nGreat solution. Could you clarify what you mean\
    \ by \"the minimum number of elements that **need to be changed** to make the\
    \ vector palindromic\"? That is, why not just return the number of elements that\
    \ need to be changed to make the vector palindromic?\n<|/ c |>\n<| c |>\nI mean,\
    \ if you reverse the vector `[1,2,3]` then make that `[3,2,1]`, the vector becomes\
    \ `[3,1,2,3]`, so the number of elements that need to be changed is not necessarily\
    \ 3.\n<|/ c |>\n<| a dscore=3 tags=arrays,julia,linked-list,algorithm,vector |>\n\
    If you don't want to use any extra data structures, then here is one in Julia\
    \ using recursion.\n<code>", "    arr.palindrome = true\n    arr.sort()\n    len1\
    \ = length(arr)\n    len2 = len1\n    for x in arr[len2+1:end]\n        if x ==\
    \ arr[len2-1]\n            len2 -= 1\n        end\n    end\n    return len1-len2\n\
    end\n</cell>\n<text>\nProblem 2b\nModify smallest_change to make a second change\
    \ that makes the vector circular.", "    for i in reverse(arr) \n        if i\
    \ == min(arr) \n            return 0 \n        arr[i] = min(arr) \n    end \n\
    \    return 1 \nend \nsmallest_change([1, 2, 3, 5, 4, 7, 9, 6])\nsmallest_change([1,\
    \ 2, 3, 4, 3, 2, 2])\nsmallest_change([1, 2, 3, 2, 1])\n</cell>\n<code language=julia-0.4>\n\
    \"\"\"\n    largest_change\n    Given a vector arr of integers, find the maximum\
    \ number of elements that\n    need to be changed to make the vector palindromic.\
    \ A palindromic vector is a vector that\n    is read the same backwards and forwards.\
    \ In one change, you can change one element to any other element.", "    if len(arr)\
    \ == 1 \n        return 0 \n    \n    let (left::Int64, rest::Int64) = arr[1:end-1]\
    \ \n    let (right::Int64, rest::Int64) = arr[2:end] \n    \n    smallest_change(left)\
    \ + smallest_change(right) + 1 \nend\n</cell>\n<code language=julia-1.4>", " \
    \   min_length = Vector{Int64}([arr[1]])\n    for x in arr[2:end] \n        min_length\
    \ = minimum(min_length, length(palindrome(x, min_length)))\n    end\nend\n</cell>\n\
    <text>\nQuestions\nUsing the palindrome function, describe the most efficient\
    \ way to determine if a number is palindrome. \nWhat are the steps you need to\
    \ take to determine if a number is palindrome? \nWhat are the steps you need to\
    \ take to determine if a number is palindrome? What is your final solution?",
  "    arr_sort = sort(arr)\n    arr_length = len(arr)\n    # First case\n    if arr_length\
    \ == 1 \n        return 0\n    else\n    # Second case\n    if arr_length <= 2\
    \ \n        return arr_length\n    end\n    # Third case\n    minimum = arr_length\n\
    \    for index in 2:(arr_length-1)\n        if arr[index] != arr_sort[index-1]\n\
    \            minimum = minimum + 1\n        end\n    end\n    return minimum\n\
    end\n</cell>\n<code language=julia-1.5>\nsmallest_change([1,3,5,2,4,6,0])\n</cell>\n\
    <text>\nLongest Palindromic Subsequence", "    largest = maximum(arr)\n    smallest\
    \ = minimum(arr)\n    palindrome = reverse(arr)\n    return count_changes_to_make_palindrome(arr,\
    \ largest, smallest, palindrome)\nend\nsmallest_change(arr)\n</cell>\n<code language=julia-1.5>\n\
    @benchmark smallest_change(arr)\n</cell>\n<code language=julia-1.5>\n\"\"\"\n\
    \    Given a vector arr of integers, find the minimum number of elements that\n\
    \    need to be changed to make the vector palindromic. A palindromic vector is\
    \ a vector that\n    is read the same backwards and forwards. In one change, you\
    \ can change one element to any other element.", "    \n    if length(arr) < 2\n\
    \        return 0\n    end\n    \n    arr_ = reverse(arr)\n    arr_ = reverse(arr_)\n\
    \    if arr_ == arr\n        return length(arr_)\n    else\n        return min(length(arr_),\
    \ length(arr))\n    end\nend\nsmallest_change(arr)\n</cell>\n<text>\nThe first\
    \ function here is the same as the one in the previous exercise, but with the\
    \ function signature, and a docstring attached. The second function here is the\
    \ one which gives the smallest number of elements that need to be changed to make\
    \ the array palindromic. Remember, the idea is to swap two elements in the array,\
    \ or to reverse the array.", "    \n    \n    end=length(arr)\n    middle=end\
    \ \xF72\n    \n    while middle \u2260 1\n        \n        head=middle\n    \
    \    \n        tail=end - middle\n        \n        change_head=head-1\n     \
    \   \n        change_tail=tail-1\n        \n        \n        if reverse(arr[change_head:change_tail])\
    \ \u2260 reverse(arr[head:tail]) \n            \n            middle=middle+1\n\
    \            \n        else\n            \n            middle=middle+1\n     \
    \       \n        end\n    end\n    \n    return 0\nend", "    n = length(arr)\n\
    \    res = 0\n    while true\n        res += 1\n        if length(arr) == n\n\
    \            return res\n        if arr[n] == arr[n - 1]\n            arr[n] =\
    \ arr[n - 1]\n            n -= 1\n        else\n            arr[n : end - 1] =\
    \ arr[end - 1 : n]\n            arr[end - 1] = arr[end]\n            n -= 1\n\
    \        end\n    end\nend\n</cell>\n<text>\nProblem 2.1\nWrite a function to\
    \ generate a random vector of integers from a random uniform distribution in the\
    \ range 0-99.", "    l = length(arr)\n    if l==1 return 0\n    mid = floor(l/2)\n\
    \    if arr[mid] == arr[l-1] \n        return l\n    else if arr[mid] == arr[0]\n\
    \        return mid\n    else if arr[mid] < arr[0]\n        return smallest_change(arr[mid+1..l-1])\
    \ + mid\n    else\n        return smallest_change(arr[0..mid - 1]) + mid\n   \
    \ end\nend\n</cell>\n<code language=julia-0.5>\n@code_warntype smallest_change([1,\
    \ 2, 3, 5, 4, 7, 9, 6])\n</cell>\n<code language=julia-0.5>\n@code_warntype smallest_change([1,\
    \ 2, 3, 4, 3, 2, 2])\n</cell>\n<code language=julia-0.5>\n@code_warntype smallest_change([1,\
    \ 2, 3, 2, 1])\n</cell>\n<code language=julia-0.5>\n@code_warntype smallest_change([5,\
    \ 4, 3, 2, 1])\n</cell>\n<code language=julia-0.5>\n@code_warntype smallest_change([1,\
    \ 2, 3, 4, 3, 2, 2])\n</cell>\n<code language=julia-0.5>\n@code_warntype smallest_change([5,\
    \ 4, 3, 2, 1])\n</cell>\n<code language=julia-0.5>\n@code_warntype smallest_change([5,\
    \ 4, 3, 2, 1])\n</cell>\n<code language=julia-0.5>\n@code_warntype smallest_change([5,\
    \ 4, 3, 2, 1])\n</cell>\n<code language=julia-0.5>\n@code_warntype smallest_change([5,\
    \ 4, 3, 2, 1])\n</cell>\n<code language=julia-0.5>\n@code_warntype smallest_change([5,\
    \ 4, 3, 2, 1])\n</cell>\n<code language=julia-0.5>\n@code_warntype smallest_change([5,\
    \ 4, 3, 2, 1])\n</cell>\n<code language=julia-0.5>\n@code_warntype smallest_change([5,\
    \ 4, 3, 2, 1])\n</cell>\n<code language=julia-0.5>\n@code_warntype smallest_change([5,\
    \ 4, 3, 2, 1])\n</cell>\n<code language=julia-0.5>\n@code_warntype smallest_change([5,\
    \ 4, 3, 2, 1])\n</cell>\n<code language=julia-0.5>\n@code_warntype smallest_change([5,\
    \ 4, 3, 2, 1])\n</cell>\n<code language=julia-0.5>\n@code_warntype smallest_change([5,\
    \ 4, 3, 2, 1])\n</cell>\n<code language=julia-0.5>\n@code_warntype smallest_change([5,\
    \ 4, 3, 2, 1])\n</cell>\n<code language=julia-0.5>\n@code_warntype smallest_change([5,\
    \ 4, 3, 2, 1])\n</cell>\n<code language=julia-0.5>\n@code_warntype smallest_change([5,\
    \ 4, 3, 2, 1])\n</cell>\n<code language=juli", "    smaller::Int64 = Int64(ceil(Int64,\
    \ length(arr) - 1))\n    \n    for( i= length(arr)-1; i>=smaller; i--) \n    \
    \    if arr[i] != arr[reverse(i)] \n            return i\n    return smaller\n\
    end ", "    l = length(arr)\n    res = 0\n    for i = 1:l\n        if arr[i] !=\
    \ reverse(arr[i])\n            res += 1\n        end\n    end\n    return res\n\
    end\n\"\"\"\n    Given a vector arr of integers, find the minimum number of elements\
    \ that\n    need to be changed to make the vector palindromic. A palindromic vector\
    \ is a vector that\n    is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.", "    minimum = minimum(arr)\n\
    \    minimum_idx = search(minimum, arr)\n    for idx = minimum_idx + 1 : length(arr)\n\
    \        if arr[idx] != minimum\n            minimum_idx = idx\n            break\n\
    \    end\n    minimum_idx = minimum_idx + 1\n    minimum_idx = minimum_idx % length(arr)\n\
    \    return minimum_idx - minimum_idx\nend", "        count = 0\n        rev_arr\
    \ = reverse(arr)\n        \n        for a in arr\n            count += 1\n   \
    \         if (arr[a] == rev_arr[a])\n                break\n        end\n    \
    \    \n        count\n    end\nend", "    len = length(arr)\n    minimum = 0\n\
    \    for i = length(arr) downto 1 do\n        if arr[i] == arr[len - i - 1]\n\
    \            minimum += 1\n        elseif minimum == 0\n            minimum +=\
    \ 1\n        end\n    end\n    minimum\nend\nsmallest_change(vec)\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"\n    Given a vector arr of integers, find the\
    \ minimum number of elements that\n    need to be changed to make the vector palindromic.\
    \ A palindromic vector is a vector that\n    is read the same backwards and forwards.\
    \ In one change, you can change one element to any other element.\n    \n    For\
    \ example:\n    >>> smallest_change([1, 2, 3, 5, 4, 7, 9, 6])\n    4\n    >>>\
    \ smallest_change([1, 2, 3, 4, 3, 2, 2])\n    1\n    >>> smallest_change([1, 2,\
    \ 3, 2, 1])\n    0\n    \"\"\"", "    n = length(arr)\n    pall = True\n    i\
    \ = 0\n    for elem in arr\n        i+=1\n        if elem != arr[end-i-1]\n  \
    \          pall = false\n        end\n    end\n    if pall\n        return 1\n\
    \    else\n        return 0\n    end\nend\n</cell>\n<code language=julia-0.6>",
  "    largest = maximum(arr)\n    smallest = minimum(arr)\n    diff = largest - smallest\n\
    \    lenx = length(arr)\n    count = 0\n    while diff > 0 do\n        count +=\
    \ 1\n        largest = max(arr[largest-count+1:largest+count])\n        smallest\
    \ = min(arr[smallest-count+1:smallest+count])\n        diff = largest - smallest\n\
    \    end\n    return count\nend\n</cell>\n<code language=julia-1.0>\n@test smallest_change([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n</cell>\n<code language=julia-1.0>\n@test smallest_change([1,\
    \ 2, 3, 4, 3, 2, 2]) == 1\n</cell>\n<code language=julia-1.0>\n@test smallest_change([1,\
    \ 2, 3, 2, 1]) == 0\n</cell>\n<text>\nQuestion 10\nConsider the function below\
    \ which computes $\\sqrt{x}$ with an optional argument $n$. Modify the function\
    \ so that it only calls sqrt if the argument $n$ is not None.", "    # your code\
    \ here\n    if length(arr) == 0 \n        return 0 \n    else if length(arr) ==\
    \ 1 \n        return 1 \n    else \n        smaller = smallest_change(arr[1...end-1])\
    \ \n        greater = smallest_change(arr[end-1...end]) \n        if smaller >\
    \ greater \n            return smaller \n        else \n            return greater\
    \ + 1 \nend ", "    arr = reverse(arr)\n    len_arr = length(arr)\n    i = 0\n\
    \    while i < len_arr\n        diff = arr[i] - arr[-(i+1)]\n        if diff >\
    \ 0 \n            i+=1\n        else\n            len_arr-=1\n        end\n  \
    \  end\n    return lenarr\nend\n</code>\n<|/ a |>\n<| a tags=julia,vector,arrays\
    \ dscore=0 |>\n<code>", "    i = 0\n    j = length(arr) - 1\n    \n    if j >\
    \ length(arr) / 2\n        while i < j\n            if arr[i] > arr[j]\n     \
    \           arr[i] -= 1\n            else\n                arr[j] += 1\n     \
    \       end\n            i += 1\n            j -= 1\n        end\n    end\n  \
    \  return length(arr) - length(arr)\nend", "    # write your code in Julia\n \
    \   \nend\nsmallest_change(Vector{Int64}([1,2,3,2,1]))\n</cell>\n<code language=julia-0.5>\n\
    \"\"\"\n    Given an array arr of integers, check whether it is palindromic or\
    \ not.\n    \n    arr::Vector{Int64}\n    \n    Check:\n    >>> palindromic([1,2,3,2,1])\n\
    \    True\n    >>> palindromic([1,2,3,2,1,0])\n    True\n    >>> palindromic([1,2,3,2])\n\
    \    False\n    >>> palindromic([1,2,3,4,3,2,1])\n    False\n    >>> palindromic([1,2])\n\
    \    False\n    >>> palindromic([1])\n    True\n    >>> palindromic([])\n    True\n\
    \    \"\"\"", "    for i = 1:length(arr)\n        if arr[i] > arr[-i-1]\n    \
    \        return 1\n        end\n    end\n    return 0\nend", "    min_changes\
    \ = 0\n    min_changes = largest(arr, min_changes)\n    for j in reverse(arr)\n\
    \        if j != (j + 1)\n            min_changes = largest(arr, min_changes)\n\
    \            min_changes = 1\n        else\n            min_changes = 1\n    \
    \    end\n    end\n    return min_changes\nend\n\"\"\"\n    Given a vector arr\
    \ of integers, find the maximum value of its smallest and largest elements. ",
  "    minimum=Int64(0)\n    minimum=minimum+sum(arr>minimum)\n    if minimum == 0\
    \ return 0\n    minimum=minimum+sum((arr-minimum)>minimum)\n    return minimum",
  "    i, j, k = 0, length(arr), 0\n    while j > i\n        if arr[i] > arr[j]\n\
    \            k = i - j\n            break\n        elseif arr[j] > arr[i]\n  \
    \          k = j - i\n            break\n        else\n            i += 1\n  \
    \      end\n    end\n    return k\nend\n</cell>\n<text>\nProblem 9 (10 Points)\n\
    The function factorial takes an integer and returns the factorial of that number.\n\
    For example, factorial(0) returns 1, factorial(1) returns 1, factorial(2) returns\
    \ 2, and so on.", "    smallest_change(arr, 1)\nend", "    smallest_change_recursive(arr,\
    \ length(arr))\nend", "    n = length(arr)\n    if n == 0 \n        return 0 \n\
    \    end\n    \n    mid = n \xF72\n    if (arr[mid-1] < arr[mid]) & (arr[mid-1]\
    \ < arr[mid+1])\n        return mid+1 \n    end", "    min_change = Int64(0)\n\
    \    lenarr = length(arr)\n    for i in 0 .. lenarr-1 \n        if arr[i] != arr[-i-1]\n\
    \            if arr[i] > arr[-i-1]\n                min_change = min_change +\
    \ 1\n            else\n                min_change = min_change + 2\n        end\n\
    \    end\n    min_change\nend\n</cell>\n<text>\nThe smallest_change function takes\
    \ one argument, arr. It returns the minimum number of elements we need to change\
    \ arr to make it a palindrome.", "    len = length(arr)\n    if len < 1\n    \
    \    return 0\n    end", "    begin = arr[end]\n    mid = begin\n    end = begin\n\
    \    while begin < end-1 do\n        if arr[begin] == arr[end-1] then \n     \
    \       end -= 1\n        else \n            mid = (begin + end) / 2\n       \
    \     begin += 1\n            end -= 1\n        end\n    end\n    \n    return\
    \ mid - begin + 1\nend\n</cell>\n<text>\n6. Palindrome Permutation\nWrite a Julia\
    \ function that will test whether a given integer is a palindrome. For example,\
    \ 1, 3, 121, 4, 12321, ... should all be palindromes and should return true. Given\
    \ a vector of integers, test whether every integer is a palindrome and return\
    \ a vector of booleans indicating whether each input is a palindrome.", "    smallest\
    \ = 0\n    for i in reverse(arr)\n        smallest = i - 1\n        if smallest\
    \ < 0 \n            break\n        end\n    end\n    return smallest\nend", " \
    \   largest = max(arr)\n    smallest = min(arr)\n    min_change = smallest - largest\n\
    \    return min_change\nend\n</cell>\n<text>\nProblem 7\nWrite a function that\
    \ returns the number of times the vector arr appears in arr2.", "    if arr==reverse(arr)\n\
    \        return 0 \n    ans=1 \n    lenarr=length(arr) \n    for i=lenarr:-1:1\n\
    \        lendiff=i-lenarr \n        if arr[i]<arr[lendiff]\n            ans=lendiff\n\
    \        else if arr[i]>arr[lendiff]\n            ans=max(ans,lendiff)\n     \
    \   end\n    end \n    ans \nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\nHere is\
    \ a O(n) solution\n<code>", "    length = length(arr)\n    i = length/2\n    \n\
    \    if length <= 1\n        return 0", "    \"\"\"Find the smallest change needed\
    \ to make arr a palindromic vector\"\"\"\n    return min(arr.len()) \nend\n</cell>\n\
    <code language=julia-1.4>\n@testset \"palindromic_vector functions\" begin\n@test\
    \ smallest_change([1, 2, 3, 5, 4, 7, 9, 6]) == 4\n@test smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n@test smallest_change([1, 2, 3, 2, 1]) == 0\nend\n</cell>\n\
    <text>\nProblem 3\nA palindromic vector is an integer vector such that for any\
    \ pair of consecutive elements x and y in the vector, x is less than y, and x\
    \ and y have the same parity (i.e. x has a higher parity than y). You may assume\
    \ that no such pair of elements appears twice in the vector.", "    n = length(arr)\n\
    \    smallest = -1\n    largest = n - 1\n    for index in 2:n-1\n        if arr[index]\
    \ != arr[largest]\n            largest = index - 1\n        elseif arr[index]\
    \ != arr[index]\n            if arr[index] < smallest\n                smallest\
    \ = index\n            elseif arr[index] > largest\n                largest =\
    \ index\n        elseif arr[index] == arr[largest]\n            if arr[index]\
    \ < smallest\n                smallest = index\n            elseif arr[index]\
    \ > largest\n                largest = index\n        end\n    end\n    return\
    \ 0 if smallest == -1\n    smallest = largest\n    for index in 2:n-1\n      \
    \  if arr[index] != arr[largest]\n            if smallest == -1\n            \
    \    smallest = index\n            elseif arr[index] != arr[smallest]\n      \
    \          if arr[index] < smallest\n                    smallest = index\n  \
    \              elseif arr[index] > largest\n                    largest = index\n\
    \            end\n        elseif arr[index] == arr[largest]\n            if smallest\
    \ == -1\n                smallest = index\n            elseif arr[index] > largest\n\
    \                largest = index\n        end\n    end\n    largest = n - 1\n\
    \    for index in 2:n-1\n        if arr[index] != arr[largest]\n            if\
    \ smallest == -1\n                smallest = index\n            elseif arr[index]\
    \ != arr[smallest]\n                if arr[index] < smallest\n               \
    \     smallest = index\n                elseif arr[index] > largest\n        \
    \            largest = index\n            end\n        elseif arr[index] == arr[largest]\n\
    \            if smallest == -1\n                smallest = index\n           \
    \ elseif arr[index] > largest\n                largest = index\n        end\n\
    \    end\n    return smallest \nend\n</cell>\n<code language=julia-1.0>\n@time\
    \ smallest_change([1, 2, 3, 5, 4, 7, 9, 6])\n</cell>\n<code language=julia-1.0>\n\
    @time smallest_change([1, 2, 3, 4, 3, 2, 2])\n</cell>\n<code language=julia-1.0>\n\
    @time smallest_change([1, 2, 3, 2, 1])\n</cell>\n<code language=julia-1.0>\nsmallest_change(collect(1:100))\n\
    </cell>\n<code language=julia-1.0>\n@time smallest_change(collect(1:100))\n</cell>\n\
    <text>\nThe function can now be used to calculate the maximum palindromic product\
    \ between two numbers, for example, the product of 13 and 7 is 7*13 = 71*71 =\
    \ 991. This is a classic problem in mathematics and computer science, and a classic\
    \ algorithm to solve it.", "    arr = arr[2:end-1]\n    if arr == reverse(arr)\n\
    \        return arr.size\n    else \n        return reverse(arr).size - arr.size\
    \ + 1\nend\n</code>\n<|/ a |>\n<| c |>\nThis is not an answer to the question.\
    \ It looks like it might be, but it's not a complete solution. Why are you suggesting\
    \ writing a recursive function? What is the base case? It doesn't seem to be the\
    \ case here.\n<|/ c |>\n<| c |>\nI was trying to give him a solution that would\
    \ work, but I guess I misunderstood what he was trying to do. He didn't want to\
    \ just copy and paste the answer. I assumed that he would know what to do, so\
    \ I provided him a starting point. The base case is the fact that if the array\
    \ has one element, it is not a palindrome. ", "    if arr == reverse(arr) #check\
    \ if the vector is a palindrome or not \n        return 1 \n    else \n      \
    \  return 0 \nend", "    \"\"\"\n    Recursive function that finds the smallest\
    \ number of changes required.\n    \n    Parameters\n    ----------\n    arr :\
    \ array of integers\n    \n    Returns\n    -------\n    Int64\n        smallest\
    \ number of changes required\n    \n    Examples\n    --------\n    >>> smallest_change([1,\
    \ 2, 3, 5, 4, 7, 9, 6])\n    4\n    >>> smallest_change([1, 2, 3, 4, 3, 2, 2])\n\
    \    1\n    >>> smallest_change([1, 2, 3, 2, 1])\n    0\n    \"\"\"\n    if length(arr)\
    \ < 2\n        return 0\n    if length(arr) == 2\n        if arr[1] == arr[end-1]\n\
    \            return 1\n        else\n            return 0\n    end1 = end - 1\n\
    \    end2 = end - 1\n    change = change(arr,end1,end2)\n    if change > 0 \n\
    \        return change\n    else\n        return smallest_change(arr[1:end]) +\
    \ change(arr,end2,end1)\n    end\nend", "    if arr == reverse(arr)\n        return\
    \ -1\n    end\n    \n    left = 0\n    right = 0\n    while left < right\n   \
    \     mid = left + (right-left)//2\n        if arr[mid] > arr[mid+1]\n       \
    \     right = mid - 1\n        else\n            left = mid + 1\n        end\n\
    \    end\n    if left < right\n        arr[left] = arr[left+1]\n    end\n    return\
    \ left + 1\nend", "    sorted = sort(arr)\n    if is_palindromic(sorted)\n   \
    \     return length(arr)\n    else\n        return minimum(length(arr)-length(unique(sorted))-1)\n\
    \    end\nend", "    n = length(arr)\n    if n < 2\n        return n\n    arr_p\
    \ = arr.reverse()\n    changes = 0\n    for i = 0:n-1\n        if arr[i] != arr_p[i]\n\
    \            changes += 1\n        end\n    end\n    return changes\nend\n</code>\n\
    <|/ a tags=julia,palindrome,arrays dscore=3 |>\n<| a dscore=2 |>\n<code>", "\"\"\
    \"\n    Function that returns the smallest number of changes that would make an\
    \ array a palindromic vector.\n\"\"\"\n    for i in reverse(arr)\n        arr[i]\
    \ = arr[length(i) - 1 - i]\n    end\n    return length(arr)\nend", "    \"\"\"\
    \n    Given a vector arr of integers, find the minimum number of elements that\n\
    \    need to be changed to make the vector palindromic. A palindromic vector is\
    \ a vector that\n    is read the same backwards and forwards. In one change, you\
    \ can change one element to any other element.", "    sz = length(arr)\n    if\
    \ sz <= 1\n        return 0\n    end\n    if arr[1] > arr[sz-1]\n        largest\
    \ = arr[sz-1]\n    else\n        largest = arr[1]\n    end\n    left = largest\n\
    \    right = largest\n    for i = 2:sz\n        if arr[i] > right\n          \
    \  right = arr[i]\n        elseif arr[i] < left\n            left = arr[i]\n \
    \       end\n    end\n    largest = min(left, right)\n    if largest == left\n\
    \        largest = right - largest \n    end\n    if largest == right\n      \
    \  largest = left - largest \n    end\n    if largest == left\n        largest\
    \ = right - largest \n    end\n    return 1 + largest\nend\n</cell>\n<code language=julia-1.5>",
  "    if length(arr)==0 or length(arr)==1\n        return 0\n    \n    if arr[1]\
    \ > arr[2]\n        return smallest_change(arr[2,:]) - smallest_change(arr[1,:])\n\
    \    else\n        return smallest_change(arr[1,:]) - smallest_change(arr[2,:])\n\
    \    end\nend\n</cell>\n<cell>\nsmallest_change(arr)\n</cell>\n<text>\nQuestion\
    \ 8 (2 points)", "    if length(arr) == 0 \n        return 0 \n    end", "  min_changes\
    \ = 1 #default \n  for index in range(arr.length) \n    #if the current value\
    \ matches the previous value \n    if arr[index] == arr[arr.length-1-index] \n\
    \      min_changes = min_changes + 1 #increments the counter \n    else \n   \
    \   #if the current value does not match the previous value \n      min_changes\
    \ = min_changes - 1 #decrements the counter \n    end \n  end \n  return min_changes\
    \ \nend ", "    n = length(arr)\n    min_change = Int64(0)\n    for i = 1:n\n\
    \        push!(min_change, 1) \n        if i==n\n            continue\n      \
    \  elseif arr[i] != arr[end-i-1]\n            push!(min_change, arr[end-i-1])\n\
    \        end\n    end\n    return min_change[1]\nend\n</cell>\n<code language=julia-1.5>",
  "    if length(arr) <= 1 \n        return 0 \n    else \n        idx = 1\n     \
    \   while idx <= length(arr) - 1 \n            if arr[length(arr) - 1] == arr[length(arr)\
    \ - 2] \n                return 0 \n            else if arr[length(arr) - 1] <\
    \ arr[length(arr) - 2] \n                idx += 1 \n            else \n      \
    \          idx += 1 \n        end\n        return idx \nend\n\"\"\"\n    Write\
    \ a function that takes a string and returns true if the string is a palindrome,\
    \ and false otherwise.\n    Don't worry about edge cases like empty strings or\
    \ strings containing only punctuation characters.\n\"\"\"", "    minimum_palindromic_element\
    \ = find_minimum_palindromic_elements(arr)\n    if minimum_palindromic_element\
    \ == -1\n        return -1\n    maximum_palindromic_element = find_maximum_palindromic_elements(arr)\n\
    \    if maximum_palindromic_element == -1\n        return -1\n    return (maximum_palindromic_element\
    \ - minimum_palindromic_element) + 1\nend", "    # Start with smallest change\n\
    \    min_change::Int64 = 0\n    # Loop through each number in the vector\n   \
    \ for i in arr\n        # Compare it to the half of the array length \n      \
    \  if arr[i] != arr[floor(Int64.length / 2)] \n            # If the current number\
    \ is bigger than the half of the array, \n            # subtract 1 from the current\
    \ minimum change\n            min_change = min(min_change, i - 1)\n        end\n\
    \    end\n    return min_change\nend\n</cell>\n<code language=julia-1.5>\nsmallest_change([1,\
    \ 2, 3, 5, 4, 7, 9, 6])\n</cell>\n<code language=julia-1.5>\nsmallest_change([1,\
    \ 2, 3, 4, 3, 2, 2])\n</cell>\n<code language=julia-1.5>\nsmallest_change([1,\
    \ 2, 3, 2, 1])\n</cell>\n<code language=julia-1.5>\nusing Plots\n</cell>\n<code\
    \ language=julia-1.5>\nx = range(-10, stop = 10, length = 50);\ny = sin.(x);\n\
    </cell>\n<code language=julia-1.5>\nplot(x,y)\n</cell>\n<code language=julia-1.5>",
  "  \n    # Initialize the minimum count of elements to change to\n    count = Int64(Inf)\n\
    \    for i in arr\n        if i<0\n            count = 0\n        else\n     \
    \       count = count+1\n        end\n    end\n    # Initialize the count of elements\
    \ that are less than i to 1\n    less_count = Int64(Inf)\n    for i in arr\n \
    \       if i<0\n            less_count = 0\n        else\n            less_count\
    \ = less_count+1\n        end\n    end\n    # Initialize a variable to store the\
    \ index that has changed the least number of times\n    index = Int64(Inf)\n \
    \   # Initialize the minimum number of elements to change\n    min_count = Int64(Inf)\n\
    \    # Initialize a variable to store the index that is to be changed in each\
    \ iteration\n    i = Int64(0)\n    # Initialize the previous index to store current\
    \ index in arr\n    prev_index = Int64(Inf)\n    # Initialize the previous index\
    \ to store current index in arr\n    next_index = Int64(Inf)\n    \n    # Loop\
    \ till the length of array becomes 1 or count is lesser than or equal to 1\n \
    \   while less_count<1 || (count<min_count and less_count==1)\n        \n    \
    \    # Loop till the length of array is 2 or count is less than or equal to 1\n\
    \        if less_count<1 || (count<min_count and less_count==1)\n            count\
    \ = count+1\n        # Update the count of elements that are less than i to 1\n\
    \        if count<min_count\n            min_count = count\n            \n   \
    \         # Loop till the length of array is 2 or count is less than or equal\
    \ to 1\n            if less_count<1 || (count<min_count and less_count==1)\n \
    \               count = count+1\n            end\n        end\n        \n    \
    \    # Update count of elements that are greater than i to 0\n        if count>min_count\n\
    \            count = count-1\n            \n            # Loop till the length\
    \ of array is 2 or count is less than or equal to 1\n            if less_count<1\
    \ || (count<min_count and less_count==1)\n                count = count+1\n  \
    \          end\n        end\n        \n        # Update the minimum number of\
    \ elements we need to change to arr\n        if count<min_count\n            min_count\
    \ = count\n        end\n        \n        \n        # Loop till the length of\
    \ array is 2 or count is less than or equal to 1\n        if less_count<1 || (count<min_count\
    \ and less_count==1)\n            count = count+1\n        end\n        \n   \
    \     # Update the count of elements that are less than i to 1\n        if count<min_count\n\
    \            min_count = count\n            \n            # Loop till the length\
    \ of array is 2 or count is less than or equal to 1\n            if less_count<1\
    \ || (count<min_count and less_count==1)\n                count = count+1\n  \
    \          end\n", "    l = length(arr)  \n    if l == 0 \n        return 0  \n\
    \    end  \n    \n    # loop through the array from both ends  \n    while l >\
    \ 0 \n        mid = l / 2  \n        if arr[mid] < arr[mid+1] \n            l\
    \ -= 1\n        else \n            l -= 1  \n        end  \n    end  \n    \n\
    \    # compare the middle element of the array to the rest of the array  \n  \
    \  largest = arr[end-1]  \n    for i = end - 2 to -1 \n        current = arr[i]\
    \ \n        if current > largest \n            largest = current \n        else\n\
    \            if current == largest \n                break  \n            end\
    \  \n        end  \n    end  \n  \n    # compare the middle element to the rest\
    \ of the array  \n    smallest = arr[end-1]  \n    for i = end - 2 to -1 \n  \
    \      current = arr[i] \n        if current < smallest \n            smallest\
    \ = current \n        end  \n    end  \n  \n    # if we found a change for the\
    \ smallest element, the array is palindromic  \n    # if it is not palindromic,\
    \ we have to change 1 element  \n    if smallest == largest \n        smallest\
    \ = arr[1]\n    end  \n    return 1  \nend  \nsmallest_change(vec)\n</cell>\n\
    <code language=julia-1.2>\n\"\"\"\nGiven a vector arr of integers, find the minimum\
    \ number of elements that\nneed to be changed to make the vector palindromic.\
    \ A palindromic vector is a vector that\nis read the same backwards and forwards.\
    \ In one change, you can change one element to any other element.", "    # write\
    \ your code in Julia 0.5\n    # ...\n    return 0\nend\n</cell>\n<text>\nAs a\
    \ final challenge, find and print the index of the minimum number of elements\
    \ that need to be changed to make the vector palindromic. For example:", "   \
    \ len = length(arr)\n    min = Int.max\n    pos = 0\n    while pos < len\n   \
    \     if (arr[pos] == arr[len-pos+1])\n            pos += 1\n        elseif arr[pos]\
    \ < arr[len-pos+1]\n            min = min + 1\n            arr[pos] = arr[len-pos+1]\n\
    \            arr[len-pos+1] = arr[pos]\n            pos -= 1\n        end\n  \
    \  end\n    return min\nend\n</cell>\n<text>\nTo implement the solution, let's\
    \ first define a function for calculating the minimum number of changes for a\
    \ vector arr to become a palindromic:", "    largest = max(arr)\n    smallest\
    \ = min(arr)", "    len_arr = length(arr)\n    smallest_change = 0\n    if len_arr\
    \ == 1 \n        return len_arr\n    elseif len_arr == 2 \n        return 0 \n\
    \    elseif len_arr == 3 \n        if arr[1] == arr[2] \n            return 1\n\
    \        else \n            return 0\n    elseif len_arr == 4 \n        if arr[1]\
    \ < arr[2] \n            return smallest_change(arr[1..3]) \n        else \n \
    \           return smallest_change(arr[1..3]) + smallest_change(arr[3..end]) \n\
    \    elseif len_arr == 5 \n        if arr[1] < arr[2] \n            return smallest_change(arr[1..3])\
    \ \n        elseif arr[3] > arr[4] \n            return smallest_change(arr[3..5])\n\
    \        else \n            return smallest_change(arr[3..5]) + smallest_change(arr[5..end])\
    \ \n    elseif len_arr == 6 \n        if arr[1] < arr[2] \n            return\
    \ smallest_change(arr[1..3]) \n        elseif arr[3] > arr[4] \n            return\
    \ smallest_change(arr[3..5]) \n        elseif arr[5] > arr[6] \n            return\
    \ smallest_change(arr[5..7])\n        else \n            return smallest_change(arr[5..7])\
    \ + smallest_change(arr[7..end]) \n    elseif len_arr > 6 \n        smallest_change_val\
    \ = smallest_change(arr[1..len_arr-1])\n        smallest_change_val += smallest_change(arr[len_arr..end])\
    \ + smallest_change(arr[1..len_arr-1])\n        return smallest_change_val \n\
    \    else \n        return 0\nend\n</cell>\n<code language=julia-1.5>", "    arr1\
    \ = copy(arr)\n    arr2 = reverse(arr)\n    \n    if arr1 == arr2\n        return\
    \ length(arr)\n    \n    if arr1 == reverse(arr2)\n        return length(arr)-1\n\
    \    else\n        return length(arr)\n    end\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nPlease don't post \"try this\" answers. Explain how it works. See: [How\
    \ do I write a good answer?](https://stackoverflow.com/help/how-to-answer)\n<|/\
    \ c |>\n<| a |>\nMy code (from comments) based on my understanding of your requirements:\n\
    <code>", "    # write your code in Julia 1.5\n    n = length(arr)\n    min = abs(n\
    \ - 1)\n    for i in range(n-1)\n        if (arr[i]==arr[n-i])\n            min\
    \ = min(min, n-i)\n        end\n    end\n    return min\nend", "    \"\"\"\n \
    \   Given a vector arr of integers, find the minimum number of elements that\n\
    \    need to be changed to make the vector palindromic. A palindromic vector is\
    \ a vector that\n    is read the same backwards and forwards. In one change, you\
    \ can change one element to any other element.\n    \n    For example:\n    >>>\
    \ smallest_change([1, 2, 3, 5, 4, 7, 9, 6])\n    4\n    >>> smallest_change([1,\
    \ 2, 3, 4, 3, 2, 2])\n    1\n    >>> smallest_change([1, 2, 3, 2, 1])\n    0\n\
    \    \"\"\"\n    count = 0\n    for a in arr \n        count += 1\n        for\
    \ b in arr[count-1:end]\n            if a==b\n                return 0\n     \
    \       if a>b\n                return count\n            end\n    end\n    return\
    \ count\nend\n</cell>\n<code language=julia-1.3>\n@assert smallest_change([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n@assert smallest_change([1, 2, 3, 4, 3, 2, 2]) ==\
    \ 1\n@assert smallest_change([1, 2, 3, 2, 1]) == 0\n</cell>\n<text>\nD) The longest\
    \ substring without repeats", "    length = length(arr)\n    if length == 1\n\
    \        return 0\n    end\n    if arr[length] == arr[length-1]\n        largest\
    \ = arr[length-1]\n    else\n        largest = arr[length-1]\n        for i =\
    \ length-2:-1:1\n            if arr[i] > largest\n                largest = arr[i]\n\
    \            elseif arr[i] < largest\n                break\n            end\n\
    \        end\n    end\n    \n    if length == length(largest)\n        arr[length-1]\
    \ = largest\n        return 0\n    end\n    \n    if largest * arr[length] ==\
    \ arr\n        return largest\n    end\n    \n    smallest_change(arr[length+1:end])\n\
    end\nsmallest_change(arr::Vector{Int64})::Int64 = smallest_change(arr)\nsmallest_change([9])\n\
    smallest_change([8, 1])\nsmallest_change([9, 0])\nsmallest_change([7, 3, 1])\n\
    smallest_change([9, 2, 0])\nsmallest_change([2, 1, 9, 1])\nsmallest_change([9,\
    \ 2])\nsmallest_change([8, 1, 2])\nsmallest_change([3, 2, 1])\nsmallest_change([4,\
    \ 9, 3, 1])\nsmallest_change([4, 9, 3, 2])\nsmallest_change([8, 3, 9, 1])\nsmallest_change([4,\
    \ 8, 3, 9, 1])\nsmallest_change([8, 4, 9, 3, 1])\nsmallest_change([4, 8, 3, 9,\
    \ 2])\nsmallest_change([9, 2, 8, 3, 1])\nsmallest_change([9, 2, 8, 4, 3])\nsmallest_change([9,\
    \ 2, 8, 4, 2, 1])\nsmallest_change([9, 2, 8, 3, 2])\nsmallest_change([9, 2, 8,\
    \ 3, 9, 1])\nsmallest_change([9, 2, 8, 3, 9, 2])\nsmallest_change([9, 2, 8, 3,\
    \ 9, 1])\nsmallest_change([9, 2, 8, 4, 3, 1])\nsmallest_change([9, 2, 8, 4, 3,\
    \ 2])\nsmallest_change([9, 2, 8, 4, 3, 9, 1])\nsmallest_change([9, 2, 8, 4, 3,\
    \ 9, 2])\nsmallest_change([9, 2, 8, 4, 3, 9, 1])\nsmallest_change([9, 2, 8, 4,\
    \ 3, 9, 2])\nsmallest_change([9, 2, 8, 4, 3, 9, 1])\nsmallest_change([9, 2, 8,\
    \ 4, 3, 9, 2])\nsmallest_change([9, 2, 8, 4, 3, 9, 1])\nsmallest_change([9, 2,\
    \ 8, 4, 3, 9, 2])\nsmallest_change([9, 2, 8, 4, 3, 9, 1])\nsmallest_change([9,\
    \ 2, 8, 4, 3, 9, 2])\nsmallest_change([9, 2, 8, 4, 3, 9, 1])\nsmallest_change([",
  "    len = length(arr)\n    minimum = zero(Int64)\n    minimum_index = Int64(len\
    \ - 2)\n    # check whether the first element is palindromic\n    if arr[minimum_index]\
    \ == reverse(arr[minimum_index])\n        minimum = minimum_index\n    end\n \
    \   for i in minimum_index:-1:1, minimum_index:-1:1\n        if arr[i] != reverse(arr[i])\n\
    \            minimum = minimum_index\n            break\n        end\n    end\n\
    \    return minimum\nend\n</cell>\n<code language=julia-1.5>\nsmallest_change([1,\
    \ 2, 3, 5, 4, 7, 9, 6])\n</cell>\n<code language=julia-1.5>\nsmallest_change([1,\
    \ 2, 3, 4, 3, 2, 2])\n</cell>\n<code language=julia-1.5>\nsmallest_change([1,\
    \ 2, 3, 2, 1])\n</cell>\n<text>\nGreat! Now you know how to find the smallest\
    \ number of elements to change in order to make the vector palindromic.", "  \
    \  if arr.length == 0\n        return 0\n    if arr == reverse(arr)\n        return\
    \ 1\n    left = 0\n    right = arr.length - 1\n    while (left < right)\n    \
    \    if arr[left] < arr[right]\n            arr[left] += 1\n        else\n   \
    \         arr[right] -= 1\n        end\n        left += 1\n        right -= 1\n\
    \    end\n    return 0\nend\n</cell>\n<text>\nProblem 15\nWrite a function, palindromic_sum,\
    \ that takes in a list of numbers and returns the sum of all numbers that\nare\
    \ palindromic. Numbers are considered to be palindromic if they are equal to the\
    \ reverse\nversion of the number. See below for examples.", "        \n    len\
    \ = length(arr)\n    \n    arr_sorted = sort(arr)\n    \n    if arr_sorted ==\
    \ arr\n        smallest = 0\n    else\n        smallest = arr[len]\n        for\
    \ i = len - 1; i>=0; i--\n            if arr_sorted[i] != arr[len-i-1]\n     \
    \           smallest = min(smallest, len-i)\n                break\n         \
    \   elseif arr_sorted[i] == arr[len-i-1]\n                if i == 0\n        \
    \            smallest = 0\n                else\n                    smallest\
    \ = min(smallest, len-i)\n            elseif arr_sorted[i] != arr[len-i-1]\n \
    \               smallest = min(smallest, len-i)\n                break\n     \
    \       end\n        end\n    end\n    return smallest\nend", "    length = arr.length\n\
    \    smallest_change = length\n    if length < 2\n        return smallest_change\n\
    \    middle = length/2\n    if arr[middle] == arr[middle-1]\n        smallest_change\
    \ = 1\n    else\n        smallest_change = 0\n    end\n    if length%2 == 1\n\
    \        smaller = length/2\n        bigger = length/2\n        while bigger >\
    \ 0 && bigger < length\n            if arr[bigger] == arr[smaller]\n         \
    \       smallest_change += 1\n                bigger -= 1\n                smaller\
    \ -= 1\n            else\n                if arr[bigger] > arr[smaller]\n    \
    \                bigger -= 1\n                else\n                    smaller\
    \ += 1\n                end\n            end\n        end\n    end\n    return\
    \ smallest_change\nend", "    min = Int.max(minimum(arr))\n    count = 0\n   \
    \ for e in arr\n        if e == minimum(arr)\n            count += 1\n       \
    \ end\n        if count >= min\n            return count\n        count = 0\n\
    \    end\n    return 0\nend\n</cell>\n<text>\nLet's try it out!", "    mid=ceil(Int64.polar(length(arr)))\n\
    \    mid=mid if mid < length(arr) else length(arr)\n    for i = mid-1:-1:1\n \
    \       if arr[i] > arr[i+1]\n            return i - mid + 1\n        end\n  \
    \  end\n    return 0\nend\n</cell>\n<code language=julia-1.5>", "    return minimum(abs(arr[2:end-1]\
    \ - reverse(arr[2:end-1])))\nend\n</cell>\n<text>\nQ2.1 Test your code", "   \
    \ if length(arr)==1\n        return length(arr)\n    end\n    if length(arr)==2\n\
    \        if arr[1]==arr[end]\n            return 1\n        end\n        return\
    \ length(arr)\n    end\n    if length(arr)==3\n        if arr[2]==arr[end]\n \
    \           if arr[1]==arr[0]\n                return 1\n            else\n  \
    \              return 2\n            end\n        end\n        return length(arr)\n\
    \    end\n    if length(arr)==4\n        if arr[3]==arr[end]\n            if arr[2]==arr[1]\n\
    \                return 2\n            else\n                return 3\n      \
    \      end\n        end\n        return length(arr)\n    end\n    if length(arr)==5\n\
    \        if arr[4]==arr[end]\n            if arr[3]==arr[2]\n                return\
    \ 3\n            else\n                return 4\n            end\n        end\n\
    \        return length(arr)\n    end\n    if length(arr)==6\n        if arr[5]==arr[end]\n\
    \            if arr[4]==arr[3]\n                if arr[2]==arr[1]\n          \
    \          return 4\n                else\n                    return 5\n    \
    \            end\n            else\n                return 6\n            end\n\
    \        end\n        return length(arr)\n    end\n    if length(arr)==7\n   \
    \     if arr[6]==arr[end]\n            if arr[5]==arr[4]\n                if arr[3]==arr[2]\n\
    \                    if arr[2]==arr[1]\n                        return 5\n   \
    \                 else\n                        return 6\n                   \
    \ end\n                else\n                    return 7\n                end\n\
    \            else\n                return 8\n            end\n        end\n  \
    \      return length(arr)\n    end\n    if length(arr)==8\n        if arr[7]==arr[end]\n\
    \            if arr[6]==arr[5]\n                if arr[4]==arr[3]\n          \
    \          if arr[3]==arr[2]\n                        if arr[2]==arr[1]\n    \
    \                        return 6\n                        else\n            \
    \                return 7\n                        end\n                    else\n\
    \                        return 8\n                    end\n                else\n\
    \                    return 9\n                end\n            else\n       \
    \         return 10\n            end\n        end\n        return length(arr)\n\
    \    end\n    if length(arr)==9\n        if arr[8]==arr[end]\n            if arr[7]==arr[6]\n\
    \                if arr[5]==arr[4]\n                    if arr[4]==arr[3]\n  \
    \                      if arr[3]==arr[2]\n                            if arr[2]==arr[1]\n\
    \                                return 7\n                            else\n\
    \                                return 8\n                            end\n \
    \                       else\n                            return 9\n         \
    \               end\n                    else\n                        return\
    \ 10\n                    end\n                else\n                    return\
    \ 11\n                end\n            else\n                return 12\n     \
    \       end\n        end\n        return length(arr)\n    end\n    if length(arr)==10\n\
    \        if arr[9]==arr[end]\n            if arr[8]==arr[7]\n                if\
    \ arr[6]==arr[5]"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
