name: HumanEval_159_eat
language: jl
prompt: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
  \ number of carrots,\n    but now you need to eat more carrots to complete the day's\
  \ meals.\n    you should return a vector of [ total number of eaten carrots after\
  \ your meals,\n                                    the number of carrots left after\
  \ your meals ]\n    if there are not enough remaining carrots, you will eat all\
  \ remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5,\
  \ 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>> eat(1, 10, 10)\n\
  \    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n    @number\
  \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
  \        the number of carrots that you need to eat.\n    @remaining : integer\n\
  \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
  \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
  \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6,\
  \ 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
  \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
  \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
completions: ["    carrots = zeros(Int64)\n    carrots[1] = number\n    if carrots[1]\
    \ > need\n        carrots[1] = need\n    end\n    while remaining > 0\n      \
    \  carrots[end+1] = remaining\n        remaining -= carrots[end+1]\n    end\n\
    \    \n    \n    return carrots\nend", "    if number == 0 && need == 0 && remaining\
    \ == 0\n        return Vector{Int64}(0)\n    else\n        return Vector{Int64}([number-need,\
    \ remaining])\n    end\nend\n</cell>\n<code language=julia-1.5>\nusing JuMP",
  "    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0\
    \ || remaining > 1000 then \n        throw(ArgumentError(\"invalid input\")) \n\
    \    end\n    \n    # 1. Calculate the number of carrots that you already have.\n\
    \    # 2. Calculate the number of carrots you need to eat\n    # 3. Calculate\
    \ the number of remaining carrots.\n    \n    \n    \n    # Your code here\nend\n\
    </cell>\n<code language=julia-1.6>\n# run this cell to test your function above\n\
    test(eat)\n</cell>\n<text>\nSection 3\nExercise: Calculate the total food items\
    \ eaten and leftover.\nFor each meal, we have\nThe total number of food items\
    \ we have eaten\nThe total number of food items left over after we have eaten\
    \ this meal.\nBased on these numbers, we can determine how much food we have left\
    \ to eat\nand how much food we need to eat.\nFor example, if I eat 2 carrots (2\
    \ meals), we will have eaten 7 food items and left over 1 food item.\nBased on\
    \ the numbers above, we can determine that we need to eat 4 more carrots and\n\
    we eaten 10 food items.", '    # Your code here', "    \"\"\"\n    Your eat function\n\
    \    \n    Variables:\n    @number : integer\n        the number of carrots that\
    \ you have eaten.\n    @need : integer\n        the number of carrots that you\
    \ need to eat.\n    @remaining : integer\n        the number of remaining carrots\
    \ thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    *\
    \ 0 <= need <= 1000\n    * 0 <= remaining <= 1000", "    if remaining < 0  ||\
    \ number > 1000 || need > 1000 || remaining > 1000 \n        error(\"Your meals\
    \ didn't work.\")\n    else\n        left_carrots = remaining - need\n       \
    \ eaten_carrots = number - left_carrots\n        return eaten_carrots, left_carrots\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\neat(5, 5, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 7, 10)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 2)\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 0)\n</cell>\n<code language=julia-1.5>\neat(5, 6, -10)\n</cell>\n<text>\n\
    Task 8: Mutez\nWrite a function that tells you whether a number is positive or\
    \ negative.", "    if number < 0 or number > 1000 or need < 0 or need > 1000 or\
    \ remaining < 0 or remaining > 1000\n        error(\"invalid input\")\n    end",
  "    if number < 0 or number > 1000 \n        error(\"number must be between 0 and\
    \ 1000\")\n    \n    if need < 0 or need > 1000 \n        error(\"need must be\
    \ between 0 and 1000\")\n    \n    if remaining < 0 or remaining > 1000 \n   \
    \     error(\"remaining must be between 0 and 1000\")\n    \n    if number ==\
    \ 0\n        Vector{Int64}([need, remaining])\n    elseif number >= need\n   \
    \     Vector{Int64}([number, remaining])\n    elseif remaining == 0\n        Vector{Int64}([number,\
    \ need])\n    elseif need > remaining\n        Vector{Int64}([remaining, number])\n\
    \    elseif number == remaining\n        Vector{Int64}([number, need])\n    elseif\
    \ number < remaining\n        Vector{Int64}([number, remaining])\n    end\nend\n\
    </cell>\n<code language=julia-1.1>", "    answer = zeros(Int64, remaining)\n \
    \   \n    # write your code here\n    \n    return answer\nend\n</cell>\n<code\
    \ language=julia-1.1>\n#export\n\"\"\"\n    days(start::Int, end::Int)\n    \n\
    \    This function takes two integer arguments, and returns the number of days\
    \ that fall between \n    those two integers.\n    \n    Example:\n    >>> days(1,\
    \ 30)\n    3\n    >>> days(1, 8)\n    0\n    >>> days(0, 0)\n    1\n    \n   \
    \ Variables:\n    @start : integer\n        The beginning of the range of days\
    \ to count from (inclusive)\n    @end : integer\n        The end of the range\
    \ of days to count from (inclusive)\n    \n    Constrain:\n    * 0 <= start <=\
    \ end\n    \n    Have fun :)\n    \"\"\"", "    # Your code here\n    totaleaten\
    \ = number\n    totalleft=remaining\n    carrotspicked = 0\n    \n    while carrotspicked\
    \ < number\n    carrotspicked = number\n    carrotspicked = remaining - carrotspicked\n\
    \    totaleaten += carrotspicked\n    totalleft -= carrotspicked\n    \n    return\
    \ totaleaten,totalleft\nend", "    if number < 0 or need < 0 or remaining < 0\n\
    \        error(\"Invalid input\")\n    end\n    \n    carrots = Vector{Int64}(undef,\
    \ number)\n    meals = Vector{Int64}(undef, number)\n    \n    for m in 1:number\n\
    \        meals[m] = rand(rand.(1:4) + 1)\n    end\n    \n    carrots = meals +\
    \ carrots\n    \n    if meals[need] != 0\n        carrots[meals[need]] = -1\n\
    \    end\n    \n    \n    for m in 1:number\n        if carrots[need] == -1\n\
    \            carrots[need] = remaining\n            carrots[meals[m]] = -1\n \
    \       end\n    end\n    \n    return carrots\nend", "    \n    needs = Vector{Int64}(copy(need))\n\
    \    remaining = Vector{Int64}(copy(remaining))\n    \n    \n    for i = 1:length(needs)\n\
    \        if needs[i] > 0\n            if needs[i] < remaining[i]\n           \
    \     remaining[i] -= needs[i]\n                needs[i] = 0\n            else\n\
    \                needs[i] = 0\n            end\n        elseif needs[i] == 0\n\
    \            if remaining[i] > 0\n                remaining[i] -= 0\n        \
    \    end\n        end\n    end\n    \n    \n    return Vector{Int64}([length(remaining),\
    \ length(remaining)])\nend", "    if number == 0\n        return Vector{Int64}()\n\
    \    if number > remaining\n        return Vector{Int64}()\n    if need == 0\n\
    \        return Vector{Int64}((number, 0), (remaining, 0))\n    end\n    if need\
    \ > remaining\n        return Vector{Int64}()\n    if need > number\n        need\
    \ = number\n        \n    if need == number\n        return Vector{Int64}((need,\
    \ remaining))\n    else\n        return Vector{Int64}()\n    end\nend\n</code>\n\
    Test cases\n<code>\njulia> eat(5, 10, 10)\n10-element Vector{Int64}:\n 15\n 10\n\
    \ 15\n 10\n 10\n 10\n 10\n 10\n 10\n 10\n 10\n 10\n</code>\n<|/ a tags=julia,algorithm\
    \ |>\n<| c |>\nI like your solution! I am not sure about the `if remaining > 0`\
    \ check. It looks like it could also be removed. Also I think there is some typo\
    \ in the last if statement - `if need==number` instead of `if need==remaining`.\n\
    <|/ c |>\n<| a dscore=1 tags=julia,algorithm |>\nI thought about this again and\
    \ came up with the following solution. There might be a better solution though.\n\
    <code>", "    \n    \n    total = Int(0L)\n    for ii in 0:Int(1000 - need)\n\
    \        total += eat(number, ii, remaining)\n    \n    total = Int(total - Int(number))\n\
    \    \n    for ii in 0:Int(1000 - remaining)\n        total += eat(number, need,\
    \ ii)\n    \n    vec = [total - Int(number), total - Int(remaining)]\n    \n \
    \   return vec\nend\n</cell>\n<text>\nProblem: Write a function that computes\
    \ the cost of a meal given the meal's ingredients and desired recipe step.\nThe\
    \ cost of a meal is calculated as :", "    vec1 = Vector{Int64}(undef, number)\n\
    \    vec2 = Vector{Int64}(undef, need)\n    vec3 = Vector{Int64}(undef, remaining)\n\
    \    for num in 1:number\n        if vec1[num] == 0\n            vec1[num] = 1\n\
    \        else\n            vec1[num] += 1\n        end\n    end\n    for num in\
    \ 1:need\n        if vec2[num] == 0\n            vec2[num] = 1\n        else\n\
    \            vec2[num] += 1\n        end\n    end\n    for num in 1:remaining\n\
    \        if vec3[num] == 0\n            vec3[num] = 1\n        else\n        \
    \    vec3[num] += 1\n        end\n    end\n    return vec1[vec2] >= need\nend\n\
    </cell>\n<code language=julia-1.6>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.6>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.6>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.6>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.6>\n@code_warntype\
    \ eat(10, 12, 3)\n</cell>\n<code language=julia-1.6>\n@code_warntype eat(1, 10,\
    \ 10)\n</cell>\n<code language=julia-1.6>\n@code_warntype eat(2, 11, 5)\n</cell>\n\
    <code language=julia-1.6>\n@code_warntype eat(1, 10, 10)\n</cell>\n<code language=julia-1.6>\n\
    @code_warntype eat(1, 10, 10)\n</cell>\n<text>\nExercise 4\nWrite a function that\
    \ simulates the \"rabbit's dream\". In other words, return the number of carrots\
    \ remaining after each day.", "    if number < 0 || need < 0 || remaining < 0\n\
    \        error(\"You must input a positive number\")\n    \n    eat = Vector{Int64}(number,\
    \ 0)\n    while eat != []\n        carry = number\n        if number == remaining\n\
    \            number = need\n            need = 0\n        else\n            need\
    \ = need - 1\n            number = number - remaining\n        end\n        remaining\
    \ = remaining - carry\n        push!(eat, remaining)\n    end\n    eat\nend\n\
    </cell>\n<text>\nSection 2. Write a function that finds a number of a carrots\
    \ that is divisible by 3.", "    \n    if remaining == 0\n        result =[number,\
    \ 0]\n    else\n        result =\n            if remaining < need\n          \
    \      eat(number, need, remaining-number)\n            else\n               \
    \ eat(number-1, need, remaining-1) + [number-1, 0]\n    end\n    \n    return\
    \ result\nend", "    if number > remaining\n        # unhappy case\n        answer\
    \ = [need, remaining]\n    elseif number == 0\n        answer = [0, 0]\n    else\n\
    \        # happy case\n        answer = eat(need - number, remaining - number,\
    \ remaining + 1)\n    end\n    return answer\nend\n</cell>\n<code language=julia-0.5>\n\
    #= @eat definition:\n    you're a hungry rabbit, and you already have eaten a\
    \ certain number of carrots,\n    but now you need to eat more carrots to complete\
    \ the day's meals.\n    you should return a vector of [ total number of eaten\
    \ carrots after your meals,\n                                    the number of\
    \ carrots left after your meals ]\n    if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000", "    if number < 0 || need < 0 || remaining <\
    \ 0\n        return error(\"invalid input for eat\")\n    else if number == 0\
    \ && need == 0 && remaining == 0\n        return Vector{Int64}()\n    elseif remaining\
    \ > number\n        error(\"cannot eat more carrots than exist\")\n    elseif\
    \ number == 0 && need == 0 && remaining > 0\n        error(\"cannot eat carrots\
    \ than exist\")\n    else\n        return Vector{Int64}(remaining, 0)\n    end\n\
    end\n</cell>\n<code language=julia-0.4>\n# Solution: Part 2", "  \n    # initialize\
    \ your meals \n    meals = []\n    \n    # count carrots already eaten and \n\
    \    # store the number of remaining carrots that \n    # are available in the\
    \ eating machine\n    i = number\n    remaining = remaining\n    while i > 0\n\
    \        meals.push(i)\n        i -= 1\n    end\n    \n    # loop through the\
    \ meals to find out \n    # how many carrots do you need to eat.\n    left = 0\n\
    \    for m in meals\n        if remaining > 0\n            left += m\n       \
    \     remaining -= 1\n        else\n            break\n        end\n    end\n\
    \    \n    # return a vector with \n    # the total number of eaten carrots \n\
    \    # and the number of carrots left \n    # after your meals \n    return [left\
    \ + length(meals), remaining]\nend\n</cell>\n<text>\n3.2 Solution", "    if number\
    \ <= 0 || need <= 0 || remaining <= 0\n        return Vector[]\n    \n    else\
    \ \n        carrots = zeros(Int64, 2)\n        carrots[1] = number\n        carrots[2]\
    \ = remaining", "    \n    \n    \"\"\"\n    You're a hungry rabbit, and you already\
    \ have eaten a certain number of carrots,\n    but now you need to eat more carrots\
    \ to complete the day's meals.\n    you should return a vector of [ total number\
    \ of eaten carrots after your meals,\n                                    the\
    \ number of carrots left after your meals ]\n    if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n   \
    \ \n    Example:\n    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n \
    \   [12, 1]\n    >>> eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7,\
    \ 0]\n    \n    Variables:\n    @number : integer\n        the number of carrots\
    \ that you have eaten.\n    @need : integer\n        the number of carrots that\
    \ you need to eat.\n    @remaining : integer\n        the number of remaining\
    \ carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n\
    \    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n    \"\"\"\n    function\
    \ eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}", "    return\
    \ Vector(number, need-number)\nend\n</cell>\n<text>\nProblem 7 - Eat carrots until\
    \ there are no carrots left\nEating carrots until there are no carrots left is\
    \ a common meal recipe\nThe code for this problem is:", '    # Your code here',
  "    \n    if number <= 0 && need <= 0 && remaining <= 0\n        return Vector{Int64}[]\n\
    \    end", "    if number == 0 \n        return zero(Int64)\n    end\n    if number\
    \ > need \n        return repeat(number, needed)\n    end\n    if remaining >\
    \ 0 \n        number[remaining]\n    end\nend\n</cell>\n<text>\nTask 4: Build\
    \ a program that randomly picks a meals from a list of meals, and then randomly\
    \ picks a day and eats some carrot from that day\nThe program should take in a\
    \ list of meals in the format of a Vector{String}, for example: [\"lunch\",\"\
    dinner\",\"breakfast\"]\nThe program should randomly select a meal in the list\
    \ from the list and return a new Vector{String} in the format of the example:\
    \ [\"dinner\",\"lunch\",\"breakfast\"]\nIf the selected meal is not in the list,\
    \ then the program should return a Vector{String} in the format of the example:\
    \ [\"lunch\",\"dinner\"]\nThe program should randomly select a day in the month\
    \ and then randomly select a carrot from that day in the month. The program should\
    \ return a Vector{String} in the format of the example: [\"breakfast\"]\nThe program\
    \ should randomly select a day in the month and then randomly select a carrot\
    \ from that day in the month. The program should return a Vector{String} in the\
    \ format of the example: [\"breakfast\",\"dinner\"]\nThe program should randomly\
    \ select a day in the month and then randomly select a carrot from that day in\
    \ the month. The program should return a Vector{String} in the format of the example:\
    \ [\"breakfast\",\"dinner\",\"lunch\"]\nThe program should randomly select a day\
    \ in the month and then randomly select a carrot from that day in the month. The\
    \ program should return a Vector{String} in the format of the example: [\"breakfast\"\
    ,\"dinner\",\"lunch\",\"breakfast\"]\nThe program should randomly select a day\
    \ in the month and then randomly select a carrot from that day in the month. The\
    \ program should return a Vector{String} in the format of the example: [\"dinner\"\
    ]\nThe program should randomly select a day in the month and then randomly select\
    \ a carrot from that day in the month. The program should return a Vector{String}\
    \ in the format of the example: [\"dinner\",\"lunch\"]\nThe program should randomly\
    \ select a day in the month and then randomly select a carrot from that day in\
    \ the month. The program should return a Vector{String} in the format of the example:\
    \ [\"dinner\",\"lunch\",\"breakfast\"]\nThe program should randomly select a day\
    \ in the month and then randomly select a carrot from that day in the month. The\
    \ program should return a Vector{String} in the format of the example: [\"dinner\"\
    ,\"lunch\",\"breakfast\"]\nThe ", "    number_remaining = remaining - number\n\
    \    if number_remaining < need\n        number = remaining\n        return Vector{Int64}[number,\
    \ 0]\n    end", "    # Your code here\n    \n    return \nend", "    \n    return\
    \ Vector(number+need, remaining)\nend\n</cell>\n<text>\nNow let's look at how\
    \ this problem would be solved using a for loop.", "    if (remaining < 0 || number\
    \ < 0 || need < 0)\n        return [0, 0]\n    else if (number == 0)\n       \
    \ return [need, remaining]\n    elseif (need == 0)\n        return [number, remaining]\n\
    \    else \n        return [number - need, remaining - number]\nend", "    if\
    \ number == 0 || need == 0 || remaining == 0\n        Vector{Int64}([number, 0])\n\
    \    elseif number == 0 || need == 0\n        Vector{Int64}([0, remaining])\n\
    \    elseif remaining < need\n        Vector{Int64}([number, 0])\n    elseif remaining\
    \ == need\n        Vector{Int64}([number, remaining])\n    else\n        Vector{Int64}([number\
    \ - need, remaining - need])\n    end\nend\n</cell>\n<code language=julia-0.4>\n\
    eat(5, 6, 10)\n</cell>\n<text>\n2.3 Exercise\nImplement the function get_max_time::Vector{Int64}\
    \ where you need to return the number of minutes that you spent in the store to\
    \ maximize the profit.", "    if number >= need || number < 0 || number < remaining\n\
    \        error(\"Invalid input\")\n    end\n    return [number-need, remaining-number]\n\
    end", "    # fill in code here\nend\n</cell>\n<code language=julia-0.5>\n## Now\
    \ test your function above:\n</cell>\n<code language=julia-0.5>\neat(5, 6, 10)\n\
    </cell>\n<code language=julia-0.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-0.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-0.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Question 3\nLet me give you a challenge problem. Given an array of integers, find\
    \ the median of the array.", "    # check if there are enough carrots\n    \n\
    \    if number < 0 or need < 0 or remaining < 0\n        return Int64[]\n    else\n\
    \        # eat as much carrots as needed\n        result = []\n        left =\
    \ number\n        number = need\n        remaining = remaining\n        \n   \
    \     while number > 0\n            result = [left + result[end] for end in 1:length(result)][end]\n\
    \            number = number - 1\n        end\n        \n        return Int64[result,\
    \ remaining]\n    end\nend\n</cell>\n<code language=julia-1.3>\n# === Write a\
    \ Julia program to find all the prime numbers between 1 and a given number ===",
  "    \n    left = 0\n    finish = 0\n    \n    while finish != 1\n        if remaining\
    \ == 0\n            left += 1\n            finish = 1\n        else \n       \
    \     need = need - remaining\n            if need > 0\n                left +=\
    \ 1\n            end\n        end\n    end\n    \n    return [number, left]\n\
    end\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<text>\n3. What is the maximum\
    \ number of carrots that you can eat in one hour?", "    \n    \n    ", "    if\
    \ remaining==0\n        Vector(number, need, 0)\n    else\n        Vector(number,\
    \ need, number-remaining)\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    eat(5, 6, 10)\n</cell>\n<text>\n9. Knapsack\nNow you know how to use Vectors and\
    \ matrices. In this notebook, you will learn how to solve a very common problem\
    \ in finance: the knapsack problem. Let's look at how we go about solving this\
    \ problem. Consider the following knapsack problem:\nNone image.png", "    # Your\
    \ code here\n    \nend\n</cell>\n<code language=julia-1.5>\n#test your code\n\
    eat(10, 100, 80)\n</cell>\n<text>\nPart 2. Coding Meals\nFor the second part of\
    \ the problem, you will need to write a function that returns the number of meals\
    \ left.", "    if number <= 0 && need <= 0 && remaining <= 0\n        number =\
    \ need\n        need = remaining\n        remaining = 0\n    end\n    \n    \n\
    \    if number <= 0 && need > 0 && remaining > 0\n        number = need\n    \
    \    need = remaining\n        remaining = 0\n    end\n    \n    \n    if number\
    \ > 0 && need > 0 && remaining > 0\n        needed = number - remaining\n    \
    \    carrots = number\n        number = need\n        need = remaining\n     \
    \   remaining = 0\n    end\n    \n    if number > 0 && need > 0 && remaining <=\
    \ 0\n        number = need\n        need = remaining\n        remaining = 0\n\
    \    end\n    \n    if number > 0 && need <= 0 && remaining > 0\n        number\
    \ = need\n        need = remaining\n        remaining = 0\n    end\n    \n   \
    \ if number > 0 && need <= 0 && remaining <= 0\n        number = need\n      \
    \  need = remaining\n        remaining = 0\n    end\n    \n    if number <= 0\
    \ && need > 0 && remaining > 0 \n        number = need\n        need = remaining\n\
    \        remaining = 0\n    end\n    \n    if number <= 0 && need > 0 && remaining\
    \ <= 0\n        number = need\n        need = remaining\n        remaining = 0\n\
    \    end\n    \n    if number <= 0 && need <= 0 && remaining > 0 \n        number\
    \ = need\n        need = remaining\n        remaining = 0\n    end\n    \n   \
    \ if number <= 0 && need <= 0 && remaining <= 0\n        number = need\n     \
    \   need = remaining\n        remaining = 0\n    end\n    \n    if number > 0\
    \ && need > 0 && remaining > 0 \n        carrots = number\n        number = need\n\
    \        need = remaining\n        remaining = 0\n    end\n    \n    if number\
    \ > 0 && need > 0 && remaining > 0 \n        carrots = number\n        number\
    \ = need\n        need = remaining\n        remaining = 0\n    end\n    \n   \
    \ if number > 0 && need > 0 && remaining <= 0\n        carrots = number\n    \
    \    number = need\n        need = remaining\n        remaining = 0\n    end\n\
    \    \n    if number > 0 && need <= 0 && remaining > 0 \n        carrots = number\n\
    \        number = need\n        need = remaining\n        remaining = 0\n    end\n\
    \    \n    if number > 0 && need <= 0 && remaining <= 0\n        carrots = number\n\
    \        number = need\n        need = remaining\n        remaining = 0\n    end\n\
    \    \n    if number > 0 && need > 0 && remaining <= 0\n        carrots = number\n\
    \        number = need\n        need = remaining\n        remaining = 0\n    end\n",
  "    if remaining == 0\n        Vector{Int64}(number, 0)\n    else\n        Vector{Int64}(remaining\
    \ + 1, number + need - remaining)\n    end\nend\n</cell>\n<code language=julia-1.6>\n\
    # Your Solution", "    answer = Vector{Int64}(number)\n    for i in 1:number\n\
    \        if i==1\n            answer[1] = need\n        else\n            answer[i]\
    \ = answer[i-1]+need\n        end\n    end\n    return answer\nend\n</cell>\n\
    <code language=julia-0.5>", "    if remaining <= 0\n        nothing\n    else\n\
    \        need = need + remaining\n        total = number\n        for i in 1:remaining\n\
    \            total = total + number\n        end\n        need = need - remaining\n\
    \        return [need, total]\n    end\nend\n</cell>\n<text>\nProblem 3\nWrite\
    \ a function that returns a vector with the number of carrots eaten and remaining\
    \ in stock after\na day's meals.\nYou will have to write a function for each day\
    \ of the meals (from Monday to Sunday):\nMonday eat 4 carrots, 1 cup of milk until\
    \ you ran out of carrots,\nTuesday eat 1 cup of milk until you ran out of carrots,\n\
    Wednesday eat 2 cups of milk until you ran out of carrots,\nThursday eat 1 cup\
    \ of milk until you ran out of carrots,\nFriday eat 1 cup of milk until you ran\
    \ out of carrots,\nSaturday eat 1 cup of milk until you ran out of carrots,\n\
    Sunday eat 1 cup of milk until you ran out of carrots,\nThe function will take\
    \ as input the following parameters:\nnumber : the number of cups of milk you\
    \ have eaten during the day's meals.\nremaining : the number of cups of milk that\
    \ still exist in stock.", "    vec=Vector{Int64}(number::Int64) \n    if remaining<=0\n\
    \        vec[1]=0\n        return vec\n    vec[1]=max(need,remaining)\n    vec[2]=0\n\
    \    meal=Vector{Int64}(vec[1])\n    while remaining>0\n        if vec[2]<number\n\
    \            vec[2]=vec[2]+meal[1]\n            meal[1]=number-vec[2]\n      \
    \  else\n            vec[2]=number\n            meal[1]=number\n        end\n\
    \        remaining=remaining-1\n    end\n    vec[1]=meal[1]\n    return vec\n\
    end", "    if number < 0 or number > 1000 \n        error(\"Invalid input: eat()\
    \ received a number outside of the valid range.\")\n    end \n    if need < 0\
    \ or need > 1000 \n        error(\"Invalid input: eat() received a number outside\
    \ of the valid range.\")\n    end \n    if remaining < 0 or remaining > 1000 \n\
    \        error(\"Invalid input: eat() received a number outside of the valid range.\"\
    )\n    end\n    \n    vector = zeros(Int64, 2)\n    \n    vector[1] = number\n\
    \    vector[2] = remaining\n    \n    if remaining == 0\n        vector[1] = number\n\
    \        vector[2] = 0\n        vector = vector[1:2]\n        \n        \n   \
    \ end\n    \n    \nend\n</cell>\n<text>\n2. Eat!\nNow let's test your implementation.\
    \ Run the following cell to check that your eat function matches the specification.",
  "    if number<0 || need < 0 || remaining < 0\n        return Vector{Int64}()\n\
    \    end", "    return Vector{Int64}( [number-need, remaining] )\nend\n</cell>\n\
    <code language=julia-1.4>\n# run code\n@code_warntype eat(5, 6, 10)\n</cell>\n\
    <text>\nEat", "    \n    \n    \"\"\"\n    You're a hungry rabbit, and you already\
    \ have eaten a certain number of carrots,\n    but now you need to eat more carrots\
    \ to complete the day's meals.\n    you should return a vector of [ total number\
    \ of eaten carrots after your meals,\n                                    the\
    \ number of carrots left after your meals ]\n    if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n   \
    \ \n    Example:\n    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n \
    \   [12, 1]\n    >>> eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7,\
    \ 0]\n    \n    Variables:\n    @number : integer\n        the number of carrots\
    \ that you have eaten.\n    @need : integer\n        the number of carrots that\
    \ you need to eat.\n    @remaining : integer\n        the number of remaining\
    \ carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n\
    \    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000", "    # Your code here\n\
    end\n</cell>\n<code language=julia-0.4>", "    if number == 0\n        return\
    \ zeros(2,1)\n    elseif need == 0\n        return ([1,number],[number,0])\n \
    \   elseif number >= remaining\n        return ([number,0],[0,1])\n    elseif\
    \ remaining > 0\n        eaten = eat(number - 1, need - 1, remaining)\n      \
    \  left = number - eaten[1]\n        if eaten[1] == 0\n            return [eaten[1],0]\n\
    \        else\n            return (eaten[1], left + eaten[1])\n    else\n    \
    \    return ([number,0],[0,1])\nend", "    \n    if remaining > 0\n        carrots\
    \ = number\n        carrots_needed = need\n        while carrots_needed > 0\n\
    \            carrots -= remaining\n            carrots_needed -= remaining\n \
    \       end\n        return Vector(carrots, carrots-carrots_needed)\n    end\n\
    \    return Vector{Int64}(number, 0)\nend", "    if number > remaining && number\
    \ > need \n    then \n        Vector{Int64}([number, need-number])\n    else \n\
    \        Vector{Int64}([need, remaining]) \n    end\nend\n</cell>\n<code language=julia-1.1>",
  "    \n    vec(0) = number\n    vec(1) = remaining\n    \n    while number >= need\
    \ do\n        vec(2) = number\n        number = number - need\n        \n    \
    \    vec(3) = remaining\n        remaining = remaining - number\n    end\n   \
    \ \n    vec\nend\n</cell>\n<code language=julia-1.5>\n# Run this cell to verify\
    \ that your code is correct, then run this cell to get a hint of a solution.\n\
    using Test\nsol = @test eat(5, 6, 10) == [11, 4]\n@show sol == true\n</cell>\n\
    <text>\nPart 2\nWe now have all the ingredients and know how to convert a meal\
    \ into a vector of ingredients.\nFor this part we are going to solve an easier\
    \ problem: given a vector of a meal, we wish to find the best way to fit a carrot\
    \ bowl to its contents.\nWe begin by defining a function that will find the best\
    \ place to fit a carrot bowl to a meal.\nThe function is called fit\nOnce we have\
    \ this function, we can find the best way to fit a carrot bowl to the meal!\n\
    To solve this problem, we will need to use an optimization algorithm. \nThe most\
    \ common algorithm used is gradient descent (GD).\nIt is quite a common optimization\
    \ algorithm, so Julia has a built-in implementation called optimize!.", "    \n\
    \    eatable1 = number-need\n    eatable2 = need-remaining\n    \n    return Vector{Int64}([eatable1,\
    \ eatable2])\nend\n</cell>\n<text>\nNow let's run your solution to see what it\
    \ returns:", "    if number == 0 || need == 0 || remaining == 0\n        return\
    \ Vector{Int64}()\n    elseif remaining < need\n        return Vector{Int64}([number])\n\
    \    else\n        if number > remaining\n            ans = number - remaining\n\
    \        else\n            ans = remaining\n        end\n        return Vector{Int64}([ans,\
    \ need-number])\n    end\nend", "    #initialize a vector with zeros\n    answer\
    \ = Vector{Int64}(number, 0)\n    \n    for a in 1:number\n        if need[a]\
    \ > 0\n            answer[a] = need[a]\n        else\n            answer[a] =\
    \ remaining\n        end\n    end\n    \n    return answer\nend\n</cell>\n<code\
    \ language=julia-0.6>\n@test eat(5,6,10)[2] == 11 #answers are 11 and 4\n@test\
    \ eat(4,8,9)[2] == 12\n@test eat(1,10,10)[2] == 11\n@test eat(2, 11, 5)[2] ==\
    \ 7\n</cell>\n<code language=julia-0.6>\neat(5,6,10)[2] == eat(eat(5,6,10)[2],6,10)[2]\
    \ #can we do this?\n</cell>\n<code language=julia-0.6>\neat(5,6,10)[2] == eat(eat(5,6,10)[2],6,10)[2]\
    \ #can we do this?\n</cell>\n<text>\nProblem 3: How many carrots would you eat\
    \ if you had a friend instead of you?\n    \n    In the previous problem, you\
    \ were given a vector of length $n$, and you were told to return the number of\
    \ carrots that could be eaten if you\n    had a friend instead of you. Can you\
    \ do it without using a for loop or any other looping construct?\n    \n    Example:\n\
    \    >>> n = 3\n    >>> eat(n,4,3)\n    6\n    >>> eat(n,2,3)\n    10\n    >>>\
    \ eat(n,6,3)\n    15\n    >>> eat(n,10,3)\n    21\n    \n    Variables:\n    @n\
    \ : integer\n        the number of elements in vector to eat", "    if number\
    \ < 0 or number > 1000 or need < 0 or need > 1000 or remaining < 0 or remaining\
    \ > 1000\n        return zeros(Int, 2)\n    else\n        carrot = zeros(Int,\
    \ 2)\n        carrot[1] = number\n        remaining = remaining - number\n   \
    \     if remaining <= 0\n            carrot[2] = remaining\n            return\
    \ carrot\n        else\n            carrot[1] = need\n            return carrot\n\
    \    end\nend\n\"\"\"\nYou are a rabbit, standing in a race track where there\
    \ are a number of tracks\nto race through.\nYou want to finish the race in a fair,\
    \ straight line, and have all the racers\nfinish their lines before the next one\
    \ begins.\nThe race has three different speeds: fast, medium and slow (slow being\
    \ slowest).\nThe goal is to finish the race in a fair, straight line, and have\
    \ all the racers\nfinish their lines before the next one begins.\nThe race has\
    \ three different speeds: fast, medium and slow (slow being slowest).\nThe goal\
    \ is to finish the race in a fair, straight line, and have all the racers\nfinish\
    \ their lines before the next one begins.\nThe race has three different speeds:\
    \ fast, medium and slow (slow being slowest).\nThe goal is to finish the race\
    \ in a fair, straight line, and have all the racers\nfinish their lines before\
    \ the next one begins.\nThe race has three different speeds: fast, medium and\
    \ slow (slow being slowest).\nThe goal is to finish the race in a fair, straight\
    \ line, and have all the racers\nfinish their lines before the next one begins.\n\
    The race has three different speeds: fast, medium and slow (slow being slowest).\n\
    The goal is to finish the race in a fair, straight line, and have all the racers\n\
    finish their lines before the next one begins.\nThe race has three different speeds:\
    \ fast, medium and slow (slow being slowest).\nThe goal is to finish the race\
    \ in a fair, straight line, and have all the racers\nfinish their lines before\
    \ the next one begins.\nThe race has three different speeds: fast, medium and\
    \ slow (slow being slowest).\nThe goal is to finish the race in a fair, straight\
    \ line, and have all the racers\nfinish their lines before the next one begins.\n\
    The race has three different speeds: fast, medium and slow (slow being slowest).\n\
    The goal is to ", "    if number>=need then\n        \n    else return [number,remaining]",
  "    answer = Vector{Int64}()\n    \n    if number < 0 || need < 0 || remaining\
    \ < 0 || number > 1000 || need > 1000 ||\\\n        remaining > 1000\n       \
    \ error(\"Invalid input, not within range or is negative\")\n    end\n    \n \
    \   # base case\n    if remaining <= 0\n        return answer\n    end\n    \n\
    \    # recursion \n    if number > remaining\n        append!(answer, 0)\n   \
    \ elseif remaining > need\n        append!(answer, number)\n    else\n       \
    \ append!(answer, number)\n        append!(answer, need)\n    end\n    \n    #\
    \ base case\n    if number <= 0\n        return answer\n    end\n    \n    # recursion\n\
    \    if number > remaining\n        append!(answer, 0)\n    elseif remaining >\
    \ need\n        append!(answer, number)\n    else\n        append!(answer, number)\n\
    \        append!(answer, need)\n    end\n    \n    return answer\nend", "    total\
    \ = 0\n    while remaining > 0 && number > 0 \n        total = total + number\
    \ \n        remaining = remaining - number \n        number = number - 1\n   \
    \ end", "    totalCarrotsLeft = (remaining - number) * carrotsPerLunch\n    totalEaten\
    \ = number * carrotsPerMeal\n    totalCarrotsLeft = number * carrotsPerMeal\n\
    \    return Vector{Int64}([totalEaten,totalCarrotsLeft])\nend\n</cell>\n<code\
    \ language=julia-0.4>\n\"\"\"\n    You've been hungry all day, and you still have\
    \ eaten one meal each day.\n    But you're still hungry for a few more days, and\
    \ you really don't want to eat.\n    You will eat as much as you can, but you'll\
    \ be hungry for the rest of your day.\n    \n    You should return a vector of\
    \ [ remaining carrots after your meals,\n                                    how\
    \ many carrots left after your meals ]\n    if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n   \
    \ \n    Example:\n    >>> hungryEat(5, 6, 10)\n    [5, 6]\n    >>> hungryEat(4,\
    \ 8, 9)\n    [12, 1]\n    >>> hungryEat(1, 10, 10)\n    [6, 10]\n    >>> hungryEat(2,\
    \ 11, 5)\n    [5, 5]\n    \n    Variables:\n    @number : integer\n        the\
    \ number of carrots that you have eaten.\n    @need : integer\n        the number\
    \ of carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000", "    return\
    \ Vector(number, need)\nend\n</code>\n<|/ a tags=constraint-programming,julia,cplex\
    \ |>\n<| c |>\nThis isn't working for me - I'm getting an error that says: `ERROR:\
    \ LoadError: MethodError: no method matching getindex(::Int64, ::Array{Int64,1})\n\
    Closest candidates are:\n  getindex(::Function, ::Type{<:Int64}, ::Int64) at /home/dmontagu3/.julia/v0.6/LinearAlgebra/src/src/functions.jl:39\n\
    \  getindex(::Function, ::Type{<:Int64}, ::Int64) at /home/dmontagu3/.julia/v0.6/LinearAlgebra/src/src/functions.jl:39\n\
    \  getindex(::Function, ::Type{<:Int64}, ::Int64) at /home/dmontagu3/.julia/v0.6/LinearAlgebra/src/src/functions.jl:39`\n\
    <|/ c |>\n<| c |>\nSorry for that. I had missed the type declaration and the `getindex`\
    \ was missing. Try it again, please.\n<|/ c |>\n<| c |>\nI've tested it and it\
    \ works. You can see [my code here](https://github.com/alexismarton/SO/tree/master/julia/problem).\
    \ Just in case you want to see the full error message, [here](http://pastebin.com/MqPkD1K9).\n\
    <|/ c |>\n<| c |>\nThat did it. Thanks! I made a couple edits to get it to do\
    \ exactly what I wanted it to: 1. Added a variable for the first meal and the\
    \ first meal cost, and 2. Changed the order of the constraints (so it wouldn't\
    \ start at 0). One last thing: it seems like it doesn't like the function `eat`\
    \ defined outside of the main function (not sure why that is), so I had to move\
    \ it into my main.jl file. Any idea how to solve that?\n<|/ c |>\n<| c |>\nThe\
    \ function `eat` should be defined inside main function. Could you please paste\
    \ the code here or send me a link to the repo? Also, if you need to call `eat`\
    \ from outside the main function, just pass it as a function argument (like `eat(cp,\
    \ 7, 7)`).\n<|/ c |>\n<| a tags=constraint-programming,julia,cplex dscore=1 |>\n\
    I have written another solution based on your original solution, just to provide\
    \ another alternative solution. \nHere is the model:\n<code>\nusing CPLEX\nusing\
    \ LinearAlgebra", "        \n    \n    \n\"\"\"\n    Your rabbit has been attacked\
    \ by a malicious person, and you need to find him back.\n    The attacker has\
    \ decided that he just wants to know the name of the person, and your job is to\
    \ find him.\n    You will receive a string of characters in the form of a name,\
    \ and your job is to find him back.\n    You can only use letters a-z, A-Z, and\
    \ _. \n    You can only use numbers in your name. The name will consist of lowercase\
    \ letters,\n    but cannot contain spaces.\n    You need to find your rabbit back\
    \ from all those who attacked him. \n    After you find the rabbit, return the\
    \ name in the form of a string.\n    \n    Example:\n    >>> findRabbit('rabbit')\n\
    \    'rabbit'\n    >>> findRabbit('Rabbit')\n    'Rabbit'\n    >>> findRabbit('rabbit')\n\
    \    'rabbit'\n    >>> findRabbit('Rabbit1')\n    'Rabbit1'\n    >>> findRabbit('rabbit\
    \ ')\n    'rabbit '\n    >>> findRabbit('rabbit 1')\n    'rabbit 1'\n    \n  \
    \  Variables:\n    @string : string\n        the name you got from a person\n\
    \    \n    Constrain:\n    * string contains only lowercase letters\n    * string\
    \ contains only digits\n    * string contains only symbols a-z, A-Z, _\n\"\"\"",
  "    if need>=0 && need<=1000 && remaining>=0 && remaining<=1000 \n        return\
    \ Vector{Int64}(number, remaining) \n    else \n        error(\"Invalid input\"\
    ) \n    end\nend\n</cell>\n<code language=julia-0.5>\neat(10, 10, 10)\n</cell>\n\
    <text>\n9. eat_meal()\nThis function should return a vector of booleans indicating\
    \ whether you met your needs.\n    You should NOT return a list of booleans.\n\
    \    The vector should have a length equal to the number of people in the household.\n\
    \    Each element should be true if and only if that person has met the requirements.\n\
    \    If the person has not met the requirements, eat_meal should return false.\n\
    \    \n    Example:\n    >>> eat_meal(5, 10, 3)\n    [true, true, true, true,\
    \ true]\n    >>> eat_meal(4, 10, 3)\n    [false, false, false, true, true]\n \
    \   >>> eat_meal(2, 5, 3)\n    [false, false, true, false, false]\n    \n    Variables:\n\
    \    @num_people : integer\n        the number of people in the household.\n \
    \   @meal_required : integer\n        the number of carrots that you need to eat.\n\
    \    @meal_left : integer\n        the number of remaining carrots available for\
    \ meals.\n    \n    Constrain:\n    * 0 <= num_people <= 100\n    * 0 <= meal_required\
    \ <= 1000\n    * 0 <= meal_left <= 1000", "    if number >= need || remaining\
    \ <= 0\n        number = 0\n        remaining = 0\n    else\n        number =\
    \ number - need\n        remaining = remaining - 1\n    end\n    return Vector(number,\
    \ remaining)\nend\n</cell>\n<code language=julia-1.2>\nnumbers = [2, 5, 6]\n</cell>\n\
    <code language=julia-1.2>\n@time [eat(m[2], m[1], m[3]) for m in numbers];\n</cell>\n\
    <text>\nJulia's comprehensions\nJulia's comprehensions construct vectors from\
    \ sequences.  They are similar to Python's list comprehensions, and follow the\
    \ same rules as for Python.", "    if number > 0 && need > 0 && remaining > 0\
    \ && remaining > number \n        then return [number, remaining - number]\n \
    \   else \n        error(\"invalid inputs\")\nend", "  if number == 0 || need\
    \ == 0 || remaining <= 0\n    return Vector{Int64}(number, 0)\n  elseif number\
    \ <= 0 && need > 0\n    return Vector{Int64}(0, remaining)\n  elseif number <=\
    \ 0 && need < 0\n    return Vector{Int64}(remaining, 0)\n  elseif number <= 0\
    \ && need == 0 && remaining <= 0\n    return Vector{Int64}(number, 0)\n  end\n\
    \  \n  # base case\n  if number == 0\n    return Vector{Int64}(number, 0)\n  end",
  "    \n    eat_left = need\n    eat_right = remaining\n    \n    return [eat_left,\
    \ eat_right]\nend", "  if  number > 0 && number <= 1000 && need > 0 && need <=\
    \ 1000 && remaining > 0 && remaining <= 1000\n    return [number, remaining]\n\
    \  else\n    return [0, 0]\n  end\nend\n</cell>\n<code language=julia-0.6>", " \
    \ \n    # Your code here\n    need = math.floor(need)\n    remaining = math.floor(remaining)\n\
    \    carrot = number - need\n    if carrot < 0\n        return Vector{Int64}(number,\
    \ 0)\n    end\n    if remaining == 0\n        return Vector{Int64}(number, need)\n\
    \    end\n    return Vector{Int64}(number, number - need)\nend", "    if number\
    \ < 0 or need < 0 or remaining < 0 return [0,0]\n    else return [number-need,\
    \ remaining]\nend\n</cell>\n<code language=julia-1.6>", "    if number > 1000\
    \ || need > 1000 || remaining > 1000 \n        error(\"Sorry,you can not eat more\
    \ carrots than you have left\")\n    else \n        \n        return Vector{Int64}([need,\
    \ remaining])\n    end\nend", "    ans = zeros(Int, 2)\n    if number > 0 && need\
    \ > 0 && remaining > 0 \n        ans[1] = number - need\n        ans[2] = remaining\
    \ - need\n        return ans\n    else\n        return zeros(Int, 2)\n    end\n\
    end\n</cell>\n<text>\n6. Write a function that simulates the simulation with a\
    \ given parameters. You want to simulate the eat() function with different values\
    \ of parameters for different meal sizes. When you are done, you'll have a table\
    \ of results with each meal size on the column and each result on the row. You\
    \ may want to print the results out in pretty way by using print.", "    \n  \
    \  carrots = zeros(Int64)\n    carrots[number] = need\n    carrots[number+need]\
    \ = 0\n    carrots = carrots[carrots>0]\n    \n    leftover = remaining - sum(collect(1:remaining).-carrots)\
    \ + number\n    \n    if carrots[number+need] == 0\n        leftover = remaining\
    \ - number\n    end\n    \n    return Array{Int64}(carrots, leftover)\nend\n</code>\n\
    The reason I defined a separate function is because it seemed like the best way\
    \ to show how the problem was solved when you're looking at it interactively.\
    \ I also wanted to show how the problem was solved when compiled, and then translated\
    \ into Julia. Here's my version that works:\n<code>\n# eat(number::Int64, need::Int64,\
    \ remaining::Int64)::Vector{Int64}", "    \"\"\"\n    Your task is to complete\
    \ the function eat(...) so that it returns the number of carrots you have\n  \
    \  eaten and carrots left to eat.\n    \n    Variables:\n    @number : integer\n\
    \        the number of carrots that you have eaten.\n    @need : integer\n   \
    \     the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000",
  "    if number-need > remaining \n        return [need, remaining]\n    else\n \
    \       return [number, 0]\nend\n</cell>\n<code language=julia-1.0>\n@assert eat(5,\
    \ 6, 10) == [11, 4]\n@assert eat(4, 8, 9) == [12, 1]\n@assert eat(1, 10, 10) ==\
    \ [11, 0]\n@assert eat(2, 11, 5) == [7, 0]\n</cell>\n<text>\nQuestion 4\nNow that\
    \ you have an eat function, you are ready to write another meal function!", " \
    \   \n    need = need\n    number = number\n    remaining = remaining\n    \n\
    \    if remaining <= 0\n        need = need\n        number = number\n       \
    \ remaining = remaining\n        return [number, 0]\n    else\n        \n    \
    \    if number == 0\n            need = need\n            number = number\n  \
    \          remaining = remaining\n            return [number, 0]\n        end\n\
    \            \n        carrots  = number\n        \n        if remaining == carrots\n\
    \            need = need\n            number = number\n            remaining =\
    \ remaining\n            return [number, carrots]\n        end\n        \n   \
    \     if need+carrots <= remaining\n            \n            if need+carrots\
    \ > remaining\n                carrots = remaining\n            else\n       \
    \         carrots = need+carrots\n            end\n            \n            need\
    \ = need\n            number = number\n            remaining = remaining\n   \
    \         return [number, carrots]\n        end\n        \n        need = need\n\
    \        number = number\n        remaining = remaining\n        return [number,\
    \ 0]\n    end\nend\n</cell>\n<code language=julia-0.4>\neat(10, 100, 200)\n</cell>\n\
    <code language=julia-0.4>\neat(10, 100, 101)\n</cell>\n<text>\n4.1 Test your code\n\
    Run the code cell below to test your code. Note that the test code takes quite\
    \ a while to run, even when it is hidden from the screen.", "    need = convert(Int64,\
    \ need)\n    remaining = convert(Int64, remaining)\n    \n    if number < 0 ||\
    \ need < 0 || remaining < 0\n        error(\"The input data is invalid.\")\n \
    \   elseif number < need\n        error(\"The number of carrots you eat is lower\
    \ than the number of carrots you need to eat.\")\n    elseif number == 0 && remaining\
    \ > 0 \n        error(\"The number of carrots you eat is higher than the number\
    \ of remaining carrots.\")\n    elseif number == 0 && remaining == 0\n       \
    \ []\n    else\n        carrots_left = number - remaining\n        if carrots_left\
    \ < 0\n            carrots_left = 0\n        return [number, carrots_left]\nend\n\
    </cell>\n<text>\nProblem 2b\nComplete the function below, which returns the number\
    \ of carrots you can eat in your meal based on the number of carrots left", " \
    \   eat=zeros(Int64, 2)\n    i=2\n    while i<=number\n        if i==1\n     \
    \       eat[1]=remaining\n        elseif i>=1\n            eat[1]=eat[1]+remaining\n\
    \        end\n        eat[0]=eat[0]+need\n        remaining=remaining-2\n    \
    \    i=i+1\n    end\n    \n    if remaining==0\n        eat[1]=number\n    end\n\
    \    return eat\nend", '    if number <= 0 || need <= 0 || remaining <= 0 return
    Vector{Int64}()', "    \n    \n    if number <= 0 || number > 1000 \n        error(\"\
    There are no carrots left for you. \")\n    end\n    if need <= 0 || need > 1000\
    \ \n        error(\"There are no carrots left for you. \")\n    end\n    if remaining\
    \ <= 0 || remaining > 1000 \n        error(\"There are no carrots left for you.\
    \ \")\n    end\n    \n    vec =  Array{Int64}(undef,2)\n    \n    if number >\
    \ need\n        for i in 1:length(vec)\n            if i==1\n                vec[i]\
    \ = 1\n            elseif i==length(vec)\n                vec[i] = remaining %\
    \ 10\n                remaining =  remaining - vec[i] * 10\n            else\n\
    \                vec[i] = (remaining % 10)\n                remaining =  remaining\
    \ - vec[i] * 10\n            end\n        end\n        \n    elseif number < need\n\
    \        for i in 1:length(vec)\n            if i==1\n                vec[i] =\
    \ 0\n            elseif i==length(vec)\n                vec[i] = number % 10\n\
    \                number =  number - vec[i] * 10\n            else\n          \
    \      vec[i] = (number % 10)\n                number =  number - vec[i] * 10\n\
    \            end\n        end\n        \n    else\n        vec[1] = number % 10\n\
    \        number =  number - vec[1]*10\n        \n        vec[2] = (number % 10)\n\
    \        number =  number - vec[2]*10\n    end\n    return vec\nend\n</code>\n\
    <|/ a tags=algorithm,dynamic-programming |>\n<| a tags=algorithm,dynamic-programming\
    \ |>\nHere is a dynamic programming algorithm that takes the problem from the\
    \ outside in. \nThe basic idea is to construct a table that contains the number\
    \ of remaining carrots for each possible combination of meals and hungry carrot\
    \ left. \nThe base case is the case where no meals or hungry carrots are left.\
    \ \nThe algorithm goes like this : \n<code>\nFor each meal\n    for each hungry\
    \ carrot left\n        update the table with new value\n    \n</code>\nThe time\
    \ complexity is O(n^2) in the worst case.\n<|/ a dscore=2 |>\n<| a tags=algorithm,dynamic-programming\
    \ |>\n<code>\n#include <iostream>\nusing namespace std;", "  \n    vec = [0, 0]\n\
    \    if number == 0\n        vec = [need, remaining]\n    elseif remaining > number\n\
    \        vec = [number, 0]\n    else\n        vec = [number, number]\n    end\n\
    \    \n    return vec\nend\n</cell>\n<code language=julia-0.6>", "    \n    \n\
    \"\"\"\n    You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    but now you need to eat more carrots to complete the day's\
    \ meals.\n    you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n                                    the number of carrots left\
    \ after your meals ]\n    if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n    \n    Example:\n \
    \   >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000", "    if number < 0 || need < 0 || remaining <\
    \ 0 || number > 1000 || need > 1000 || remaining > 1000 else Vector{Int64}()\n\
    \        return Vector{Int64}()\n    end\n    \n    carrots_left = 1000 - number\n\
    \    carrots_taken = 1000 - need\n    \n    if carrots_left == 0\n        return\
    \ Vector{Int64}(number, 0)\n    elseif carrots_taken == 0\n        return Vector{Int64}(0,\
    \ number)\n    end\n    \n    if carrots_taken > carrots_left\n        return\
    \ Vector{Int64}(number, 0)\n    else\n        return Vector{Int64}(number, carrots_left\
    \ - carrots_taken)\n    end\nend\n</cell>\n<code language=julia-1.0>\n# Test your\
    \ code\njulia> eat(4,8,3)\n10-element Array{Int64,1}:\n 7\n 6\n 8\n \njulia> eat(10,10,10)\n\
    10-element Array{Int64,1}:\n 0\n 10\n 10\n \njulia> eat(5, 7, 9)\n10-element Array{Int64,1}:\n\
    \ 11\n 4\n 1\n \njulia> eat(9, 10, 2)\n10-element Array{Int64,1}:\n 11\n 6\n 2\n\
    \ \njulia> eat(9, 3, 2)\n10-element Array{Int64,1}:\n 9\n 3\n 2\n</cell>\n<text>\n\
    C. Given a sequence of strings, find out if there are two distinct substrings\
    \ which have equal lengths and that they can be obtained by deleting some characters\
    \ from the original string without changing the relative positions of the remaining\
    \ characters. Print \"Yes\" if such a pair of strings exists and \"No\" otherwise.",
  "    \n    left = []\n    if remaining == 0\n        left = []\n    else\n     \
    \   left = remaining - 1\n    return Vector(number, left)\nend", "    if number\
    \ > 0 && number <= 1000 && need > 0 && need <= 1000 && remaining > 0 && remaining\
    \ <= 1000 \n        [number, need, remaining]\n    else \n        [0, 0, 0]\n\
    \    end\nend\n</cell>\n<text>\nProblem 8\nThe rabbit resides in a village. It\
    \ has an elevator that can carry only 10 carrots. There are two carrots in the\
    \ elevator that are already full.", "    # your code here\n    \nend\n</cell>\n\
    <text>\nQuestion 4\nHere are 3 functions:", "    if number == 0 && need == 0 &&\
    \ remaining == 0 \n        return zeros(2)\n    elseif number == 0 || need ==\
    \ 0 || remaining == 0 \n        return [number, remaining]\n    elseif need >\
    \ remaining \n        return [0,remaining]\n    elseif number > need \n      \
    \  return [0,remaining]\n    elseif number == need \n        return [0,0]\n  \
    \  end", "    if number <= 0 || need <= 0 || remaining <= 0 \n        error(\"\
    Invalid input: \\nnumber must be > 0\\nneed must be > 0\\nremaining must be >\
    \ 0\")\n    elseif number < need \n        error(\"number must <= need\")\n  \
    \  elseif number > remaining \n        error(\"number must <= remaining\")\n \
    \   else\n        Vector(number, remaining - need)\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\n\"\"\"\n    Calcuate the number of days left after you\
    \ eat all the carrots. \n    \n    Variables:\n    @number : integer\n       \
    \ the number of carrots that you have eaten.\n    @remaining : integer\n     \
    \   the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= remaining <= 1000\n    \n    Have fun :)\n\
    \    \"\"\"", "    \n    Vector{Int64} = [number - need, remaining]\nend", " \
    \   vector = [need, remaining]\n    if remaining == 0\n        vector = [number,\
    \ 0]\n    end\n    return vector\nend", "    if number<=0 && need <= 0 || number\
    \ <= need && remaining <= 0\n        error(\"cannot eat: number of carrots must\
    \ be greater than 0 and number of carrots already eating must be greater than\
    \ 0\")\n    elseif number<=0 && remaining <= 0\n        need = 0\n    end", " \
    \   if number > 1000 or need > 1000 or remaining > 1000\n        error(\"The input\
    \ should be 0 <= number <= 1000 and 0 <= need <= 1000 and 0 <= remaining <= 1000\"\
    )\n    end\n    return Vector{Int64}(number, need, remaining)\nend\n</cell>\n\
    <code language=julia-1.0>\n@assert eat(5, 6, 10) == [11, 4] \"eat(5, 6, 10) incorrect\"\
    \n@assert eat(4, 8, 9) == [12, 1] \"eat(4, 8, 9) incorrect\"\n@assert eat(1, 10,\
    \ 10) == [11, 0] \"eat(1, 10, 10) incorrect\"\n@assert eat(2, 11, 5) == [7, 0]\
    \ \"eat(2, 11, 5) incorrect\"\n</cell>\n<text>\nTask 6: eat(Carrot, Dairy)", " \
    \   # define the return vector\n    \n    # get the number of carrots left\n \
    \   carrots = remaining_carrots(number)", "    \n    number_in_stock = Vector{Int64}()\n\
    \    for i = 1:number\n        number_in_stock[i] = number\n    end\n    \n  \
    \  while number_in_stock[remaining] > 0\n        number_in_stock[remaining] =\
    \ number_in_stock[remaining] - 1\n        \n        if number_in_stock[remaining]\
    \ == 0\n            number_in_stock[remaining] = need\n        end\n        \n\
    \        remaining = remaining - 1\n    end\n    \n    return number_in_stock\n\
    end\n</cell>\n<text>\nExercise 8\n(The one where you get confused) Write a function\
    \ that returns a vector with the cumulative sum of the elements in a vector. For\
    \ example, for the vector [4, 9, 1, 6, 4, 2], the function should return a vector\
    \ [5, 15, 8, 10], where each number is equal to the previous number plus itself.",
  "    if number <= 0 && number <= 0 || need <= 0 && need <= 0 || remaining <= 0 &&\
    \ remaining <= 0\n        error(\"You cannot eat negative numbers.\")\n    else\
    \ if remaining <= 0\n        warning(\"You don't have enough carrots to eat anymore\
    \ carrots.\")\n    elseif number <= need\n        warning(\"You eat all remaining\
    \ carrots already.\")\n    else\n        [ number() - need, remaining() ]\n  \
    \  end\nend", "    if number == 0\n        return Vector{Int64}([need, remaining])\n\
    \    end\n    if need > remaining \n        need, remaining = remaining, need\n\
    \    end\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n", "    \n    # check if there is enough\
    \ carrots left for meals\n    if remaining <= 0\n        return [number, 0]\n\
    \    end", "    # Your code here\n    \nend\n</cell>\n<text>\n\_10. eat_and_count\
    \ API\nAPI\_Description\neat_and_count(number, need) \u2245 Vector{Int64}\nAPI\
    \ Design\nComplete the API design below. You may not use any loop or conditional\
    \ statements.\nYou will not use if statement for checking your need\nYou will\
    \ use while loop for checking your need\nYou will use the function eat() you created\
    \ to complete your API\nYou will create variables and use them to complete your\
    \ API\nYou can get the input parameters and output result by printing the name\
    \ of the variable", "    if number == 0\n        return zeros(0,2)\n    elseif\
    \ number < 0\n        return zeros(-1,2)\n    elseif number == remaining\n   \
    \     return Vector{Int64}([number, 0])\n    elseif need == 0\n        return\
    \ Vector{Int64}([number, remaining])\n    elseif remaining == 0\n        return\
    \ Vector{Int64}([0, remaining])\n    else\n        remaining = remaining - 1\n\
    \        number = number - 1\n        need = need - 1\n        eat(number,need,remaining)\n\
    \    end\nend\n</cell>\n<code language=julia-0.6>\neat(4,6,10)\n</cell>\n<code\
    \ language=julia-0.6>\n\"\"\"\n    Write a function that returns true if there\
    \ exists a path in a graph of connections\n    between nodes that travel between\
    \ time periods t1, t2, t3, ... , tn\n    \n    Variables:\n    @graph : Matrix{Int64}\
    \ \n        the graph of connections between time periods t1...tn\n    @t1 : integer\
    \ \n        time period 1\n    @t2 : integer \n        time period 2\n    @t3\
    \ : integer \n        time period 3\n    ... : integer \n        time periods\
    \ i-1\n    @tn : integer \n        time period n\n    \n    Variables:\n    @visited\
    \ : Vector{Bool} \n        True is node has already been visited\n    @counter\
    \ : Int64 \n        number of nodes that have been visited before\n    \n    Constrain:\n\
    \    * all nodes in graph are integers in the interval [0,N-1]\n    * graph contains\
    \ no negative edges\n    * t1 < t2 < t3 < ... < tn\n    * each edge is bidirectional\
    \ (edges are of the form [t1,t2] where t1 < t2)\n    * graph does not contain\
    \ self-loops\n    * no edge is repeated", "    \n    answer = []\n    \n    if\
    \ remaining >= need == 0\n        answer = [number, remaining ]\n    else\n  \
    \      answer = [number, 0]\n    end\n    \n    return answer \nend\n</cell>\n\
    <text>\nNow try it out on some examples!", "    if number <= 0 && need <= 0 &&\
    \ remaining <= 0\n        return Vector{Int64}()\n    end\n    if number > remaining\n\
    \        return Vector{Int64}(remaining, remaining)\n    end\n    if need > remaining\n\
    \        return Vector{Int64}(number, 0)\n    end\n    if remaining == 0\n   \
    \     return Vector{Int64}(number, number)\n    end\n    return Vector{Int64}(0,\
    \ number - need)\nend\n</cell>\n<text>\nLet's test your implementation on the\
    \ following cases:", "    if number == 0\n        return Vector{Int64}(0, 1)\n\
    \    else\n        return (number - need, remaining + need)\n    end\nend", " \
    \   if remaining < 0 \n        error(\"Number of carrots out of stock.\")\n  \
    \  end", "  if number < 0 or need < 0 or remaining < 0\n    error(\"negative numbers\"\
    )\n  else\n    if remaining < need \n      error(\"need too small\")\n    else\n\
    \      result = Vector{Int64}(length(needed), 0)\n      for i in 1:length(needed)\n\
    \        result[i] = number-needed[i]\n        result[i+1] = need-result[i]\n\
    \      end\n      return result\n    end\n  end\nend\n</cell>\n<text>\nProblem\
    \ 8", "    \n    # Your code here\n    \nend\n</cell>\n<code language=julia-1.5>\n\
    # BEGIN PROBLEM 5", "    if number<=0 || need<=0 || remaining<=0 then return 0\n\
    \    else if number >= need then return [number,0]\n    else if remaining == 0\
    \ then return [number,need]\n    else return [number+need, remaining]\nend\n</code>\n\
    This is how I got it working:", "    return Vector{Int64}( \n            number-need,\
    \ \n            number-remaining)\nend\n</cell>\n<code language=julia-0.6>\neat(5,\
    \ 6, 10)\n</cell>\n<text>\n6. Write a function that returns the product of numbers\
    \ from 1 to 9. \nThe function should return 1 when the numbers are all positive,\
    \ \nand 0 when the numbers are all negative. \nAll numbers from 1 to 9 are positive. ",
  "    if number == 0 || need == 0\n        return Vector{Int64}()\n    elseif remaining\
    \ < 0\n        return Vector{Int64}()\n    elseif remaining > need\n        return\
    \ Vector{Int64}()\n    else\n        Vector{Int64}((number-need, remaining-need))\n\
    \    end\nend\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Problem 3: Coin\nYou now need to write the function coin(number::Int64)\n    which\
    \ returns an integer indicating whether you or your neighbor has collected a coin.\n\
    \    if you or your neighbor has collected a coin, you return one;\n    otherwise,\
    \ you return zero.\n    \n    Variables:\n    @number : integer\n        the amount\
    \ of coins collected by you or your neighbor.\n    \n    Constrain:\n    * 0 <=\
    \ number <= 1000", "    if number == 0 || need == 0 || remaining == 0\n      \
    \  Vector{Int64}()\n    else if remaining <= need\n        Vector{Int64}(0, remaining\
    \ - need)\n    else\n        Vector{Int64}(0, remaining)\n    end\nend", "   \
    \ \n    if need>remaining\n        return zeros(1, 2)\n    end\n    \n    meals\
    \ = fill(0, number)\n    for i=1; i<=number-1\n        if meals[i]==0\n      \
    \      meals[i] = i\n        elseif meals[i]+need>=remaining\n            meals[i]\
    \ = remaining\n            \n            remaining = meals[i] - need\n       \
    \ else\n            meals[i] = meals[i]+need\n            \n            remaining\
    \ = remaining- meals[i]\n        end\n    end\n    \n    return Vector{Int64}(meals)\n\
    end\n</code>\n<|/ a |>\n<| c |>\nI love this answer, but I think it could be made\
    \ a little bit more concise. Could you add some comments to explain what's going\
    \ on? I think this would be very useful for future visitors.\n<|/ c |>\n<| c |>\n\
    Thanks so much! This was really helpful. I appreciate you taking the time to help\
    \ a noob like me out.\n<|/ c |>\n<| a |>\nI remember seeing an algorithm for this\
    \ in a textbook somewhere, but I forget exactly how it worked. Here's my take\
    \ on it:\nLet A[n] be an array of n integers that hold the number of carrots you\
    \ have eaten. Each index can hold either a carrots remaining or 0. If you encounter\
    \ an index that is 0, then you eat a carrot from that index (if that carrot is\
    \ not 0, you eat it from A[i] - 1) and decrement the carrot in the index to 1.\
    \ If it is 0, then you eat the carrot from A[i] and increment the carrot at A[i]\
    \ to 1 as you eat it. If you encounter an index A that is larger than n, then\
    \ you eat the carrots from the last index that is less than A[i], and set A[i]\
    \ to 0 to indicate that you no longer have enough carrots; you leave the last\
    \ index untouched.\nOnce you have finished adding up all the carrots, you can\
    \ go through each index in A and determine if there will be enough carrots left\
    \ to have enough to complete the day's meals. You can then go through each index\
    \ in A again to find out how many carrots there will be left if you have enough\
    \ carrots left.\nYou can go through each index in A only once (but you must have\
    \ enough carrots left to complete the day's meals).\n<|/ a dscore=2 tags=algorithm\
    \ |>\n<| c |>\nI guess you mean a carrot :)\n<|/ c |>\n<| a tags=algorithm |>\n",
  "    if number > remaining\n        push!(result, 0)\n        push!(result, need)\n\
    \    elseif number == 0\n        push!(result, 0)\n        push!(result, 0)\n\
    \    else\n        push!(result, number)\n        push!(result, need-number)\n\
    \    end \nend\n</cell>\n<code language=julia-1.2>\n\"\"\"\n    raffles(number::Int64,\
    \ number::Int64) -> (Int64, Int64) -> Bool\n    \n    Function that checks if\
    \ the raffle is valid by making sure that\n    the sum of all numbers are the\
    \ same.\n    \n    Variables:\n    @number : integer\n    @raffle : integer\n\
    \    \n    \n    \n    \n    Constraints:\n    * 0 <= number <= 1000\n    * 0\
    \ <= raffle <= 1000\n    * sum(number) == sum(raffle)\n    \n    \n    Have fun\
    \ :)\n    \"\"\"", "\"\"\"\n    you're a hungry rabbit, and you already have eaten\
    \ a certain number of carrots,\n    but now you need to eat more carrots to complete\
    \ the day's meals.\n    you should return a vector of [ total number of eaten\
    \ carrots after your meals,\n                                    the number of\
    \ carrots left after your meals ]\n    if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000", "  if number > 0 && need > 0 && remaining > 0\
    \ \n    # your code goes here\n  else \n    Vector{Int64}()\n  end \nend\n</cell>\n\
    <text>\nProblem 3\n(10 points)\nGiven the function eat(), implement a hungryness\
    \ function that takes a number of carrots, a number of meals your rabbit already\
    \ has left, and returns true if your rabbit is hungry and false otherwise.\nThe\
    \ hungryness function should return nothing if your rabbit's carrots are already\
    \ at capacity, or it should return false if your rabbit's carrots are at 0 or\
    \ negative.\nExamples:\nhungry(10, 2, 0)\nhungry(10, 5, 15)\nhungry(10, 5, 15)\n\
    hungry(10, 5, -10)\nhungry(10, 5, -10)\nhungry(-10, 2, 0)\nhungry(-10, 5, 15)\n\
    hungry(-10, 5, 15)\nhungry(-10, 5, -10)\nhungry(-10, 5, -10)", "    if remaining\
    \ == 0\n        return [number, 0]\n    \n    dish, eaten, remaining = dish, number\
    \ - eaten, needed - remaining\n    \n    if remaining > 0\n        dish = eaten\
    \ + dish\n        eaten = dish[end]\n        remaining = dish[end] + remaining\n\
    \    end\n    \n    return [eaten, remaining]\nend", "    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000 else\
    \ Vector{Int64}() \n    else if number > need \n        Vector{Int64}([number,\
    \ need, remaining]) \n    elseif number == need \n        Vector{Int64}([number,\
    \ need, 0]) \n    elseif number < need \n        Vector{Int64}([0, need, remaining])\
    \ \n    else \n        Vector{Int64}([0, 0, remaining]) \nend\n</cell>\n<code\
    \ language=julia-1.5>", "    return ifelse(number<=need, Vector{Int64}([number],\
    \ remaining+[remaining]), Vector{Int64}([need-number, remaining]))\nend", "  \
    \  \n    #Your code here\n    return Vector{Int64}(undef, 0)\nend", "    \n  \
    \  return [0]", "    answer = [0, 0]\n    for i in 1:number\n        remaining\
    \ -= 1\n        if remaining == 0 then\n            answer[1] += need\n      \
    \  else\n            answer[0] += need\n        end\n    end\n    return answer\n\
    end\n</cell>\n<code language=julia-1.0>\neat(5, 5, 5)\n</cell>\n<text>\nQuestion\
    \ 9\nThe function count_carrot_count() takes as its argument a vector of integers\
    \ (the meals you are working on currently) and\nreturns the number of carrots\
    \ you have left. \nThe function also takes three arguments: the minimum amount\
    \ of carrots that you can eat, \nthe maximum amount of carrots that you can eat,\
    \ and a boolean variable that indicates whether \nyou are currently hungry.\n\
    The function should return the number of carrots you have left, and the number\
    \ of carrots you have left\nafter the next meal.\nThe function will stop counting\
    \ carrots once you are no longer hungry, or have eaten the minimum number of carrots.",
  "    a=need\n    b=remaining\n    c=number\n    d=zeros(0,2)\n    while a > 0\n\
    \        if b > 0\n            if c > 0\n                if b <= c\n         \
    \           d=[c,b]\n                    a=0\n                    b=0\n      \
    \              c=0\n                else\n                    a=a-c\n        \
    \            c=c-b\n                    b=0\n                end\n           \
    \ else\n                d=d+[c]\n                c=0\n                b=0\n  \
    \          end\n        else\n            d=d+[c]\n            c=0\n         \
    \   b=0\n        end\n    end\n    return d\nend\n</cell>\n<code language=julia-0.6>\n\
    \"\"\"\n    You should eat a certain number of carrots, and your goal is to find\
    \ out what is the minimum number of\n    carrots required from you to be able\
    \ to finish the meals.\n    \n    Example:\n    >>> minimum_number_of_carrots(5,\
    \ 10, 15)\n    11\n    \n    Variables:\n    @number : integer\n        the number\
    \ of carrots that you have eaten.\n    @need : integer\n        the number of\
    \ carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock", "    return Vector{Int64}[number,\
    \ remaining]\nend\n</cell>\n<code language=julia-1.4>", "    return Vector{Int64}([number,remaining])\n\
    end", "    if number > remaining || need > remaining || number < 0 || need < 0\
    \ || remaining < 0\n        error(\"invalid input\")\n    else\n    need = need\
    \ - number\n    return Vector{Int64}[number, remaining]\nend\n</cell>\n<text>\n\
    Day 16: Largest prime factor\nYou are given an integer $n$. You need to find the\
    \ largest prime factor of $n$. Implement function largestPrimeFactor(n) that returns\
    \ the largest prime factor of $n$. Here are some examples:", "    \n    need =\
    \ need - 1\n    answer = []\n    \n    if number > remaining\n        answer =\
    \ [number - remaining]\n    else\n        answer = [0]\n    \n    return answer\n\
    end", "\"\"\"\n    you're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000", "    if number == 0 || need == 0 || remaining\
    \ == 0 \n        Vector{Int64}( 0, 0)\n    else\n        if remaining > number\
    \ \n            Vector{Int64}(remaining, 0)\n        else\n            Vector{Int64}(0,\
    \ need - remaining)\n        end\n    end\nend\n</cell>\n<code language=julia-1.4>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.4>", "  \n  # Your code here\n\
    \  totalCarrots = number\n  leftover = 0\n  for i in 1:need\n    leftover += i\n\
    \    totalCarrots += leftover\n  end\n  carrotsTaken = totalCarrots - leftover\n\
    \  carrotsTaken\nend\n</cell>\n<text>\nProblem 14: isOpen\nYou have a bag that\
    \ can hold 100 items of $1, 3, 6, or 9 calories.  You have 4 restaurants you can\
    \ eat from.\nYou are given an array items = [1, 3, 6, 9], and the prices of the\
    \ 4 restaurants: $1, 2, 3, 4.", "    vec = zeros(Int, 2)\n    \n    if number\
    \ <= 0 || need <= 0 || remaining <= 0\n        return vec\n    end", "    return\
    \ if number <= 0 || need <= 0 || remaining <= 0 \n        error(\"Eat requires\
    \ number, need, and remaining positive integers\") \n    \n    vector = []\n \
    \   for i in (1:number)\n        vector.append(i)\n    end\n    \n    for i in\
    \ (1:need)\n        vector.append(0)\n    end\n    \n    for i in (1:remaining)\n\
    \        vector[number-i] = 1\n    end\n    \n    return vector\nend", "    if\
    \ number == 0 \n        Vector{Int64}(0)\n    elseif number == need\n        Vector{Int64}(number,\
    \ 0)\n    else\n        Vector{Int64}(remaining, number - need)\n    end\nend\n\
    </cell>\n<code language=julia-0.6>\n@assert eat(5, 6, 10) == [11, 4]\n@assert\
    \ eat(4, 8, 9) == [12, 1]\n@assert eat(1, 10, 10) == [11, 0]\n@assert eat(2, 11,\
    \ 5) == [7, 0]\n</cell>\n<text>\nProblem 4 (Optional)\nRecall that an n-digit\
    \ number is represented as a vector of n 1\u2019s and 0\u2019s:\n$$\n\\begin{align}\n\
    xi & = \\begin{bmatrix}\n1 & 0 & \\cdots & 0 \\\n0 & 1 & \\cdots & 0 \\\n\\vdots\
    \ & \\vdots & \\ddots & \\vdots \\\n0 & 0 & \\cdots & 1\n\\end{bmatrix}\n\\end{align}\n\
    $$\nIn this problem, we will represent the number as if it were a vector of bits\
    \ instead of\na vector of decimal digits. That is, you will represent numbers\
    \ $0$ through $n-1$ as the\ninteger vector\n$$\n\\begin{align}\n\\text{number}\
    \ \\quad & =\\begin{bmatrix}\n0 & 1 & \\cdots & 0 \\\n1 & 0 & \\cdots & 0 \\\n\
    \\vdots & \\vdots & \\ddots & \\vdots \\\n0 & 0 & \\cdots & 1\n\\end{bmatrix}\\\
    quad\n\\text{number} = \\begin{bmatrix}\n0\\b11 \\\n1\\b10 \\\n\\vdots \\\n0\\\
    b1\n\\end{bmatrix} = \\begin{bmatrix}\n0 & 1 & \\cdots & 0 \\\n1 & 0 & \\cdots\
    \ & 0 \\\n\\vdots & \\vdots & \\ddots & \\vdots \\\n0 & 0 & \\cdots & 1\n\\end{bmatrix}\n\
    \\end{align}\n$$", "    if number < 0 || need < 0 || remaining < 0 \n        error(\"\
    Invalid input\") \n    else if number == 0\n        need = 0 \n        remaining\
    \ = 0\n    else if number == remaining\n        need = 0\n        remaining =\
    \ 0\n    else\n        Vector{Int64}([remaining, number-remaining]) \n    end\n\
    end\n</cell>\n<text>\nTask 4\nIn this task, we will use our new function eat to\
    \ find the most efficient day to eat.", "    if number <= 0 \n        or need\
    \ <= 0 \n        or remaining <= 0 \n        then Vector{Int64}(number, 0)\n \
    \   else\n        if remaining > number then Vector{Int64}(number, 0)\n      \
    \  else\n            local meal_count = need\n            local left_count = remaining\n\
    \            local meal_carrots = number\n            local left_carrots = remaining\n\
    \            local new_carrots = left_carrots - meal_carrots\n            if new_carrots\
    \ > 0\n                then meal_carrots = new_carrots\n                    local\
    \ left_carrots = left_carrots - meal_carrots\n                    if left_carrots\
    \ > 0 \n                        then return Vector{Int64}(meal_carrots, left_carrots)\n\
    \                        else\n                            return Vector{Int64}(meal_carrots,\
    \ 0)\n                    end\n                else\n                    if left_carrots\
    \ > 0 \n                        then return Vector{Int64}(meal_carrots, left_carrots)\n\
    \                        else\n                            return Vector{Int64}(meal_carrots,\
    \ 0)\n                    end\n                end\n            else return Vector{Int64}(0,\
    \ 0) end\n        end\n    end\nend", "    if remaining < need \n        Vector{Int64}(\
    \ remaining, remaining )\n    else \n        Vector{Int64}( number - need, remaining\
    \ - need )\n    end\nend\n</cell>\n<code language=julia-0.5>\n@time eat(10, 10,\
    \ 100_000);\n</cell>\n<text>\nQuestion 3.2\nWrite a function named get_price()\
    \ that takes in a dictionary of food pairs and their prices, and returns the total\
    \ price for the meal. \nThis function should include some sort of loop, so that\
    \ if you call it twice, \nthe function does not calculate the same thing twice. ",
  "    \n    if remaining==0 \n        numbers=Vector{Int64}([number])\n    else \n\
    \        numbers=Vector{Int64}()\n        for a in 1:remaining\n            numbers=[numbers...;\
    \ number+need]\n        end\n    end\n    return numbers\nend", "    return Vector(number,need-remaining);\n\
    end", "    if number < 0 || need < 0 || remaining < 0 \n        return Vector{Int64}(undef,\
    \ undef, undef)\n    end", "    number_to_eat::Int64 = 0\n    number_to_eat +=\
    \ number\n    if number_to_eat > need\n        number_to_eat -= need\n    end\n\
    \    carrots_to_eat::Int64 = 0\n    carrots_to_eat += remaining\n    if number_to_eat\
    \ > carrots_to_eat\n        number_to_eat -= carrots_to_eat\n    end\n    carrots_to_eat\n\
    end\n</cell>\n<text>\nTask 5.3 Carnivorous Conjunct", "    answer = [number, need]\n\
    \    if remaining == 0\n        answer[1] = remaining\n    else\n        answer[1]\
    \ += remaining\n    end\n    return answer\nend", "    meals = Vector{Int64}()\n\
    \    meals.push(number)\n    \n    # while eating carrots\n    while meals.size\
    \ > 0\n        # while there are still carrots to eat\n        while meals.size\
    \ > 0 && meals.last > need\n            # remove a carrot from meal\n        \
    \    meals.pop()\n            \n        # while there are still carrots left to\
    \ eat\n        while meals.size > 0 && meals.last < remaining\n            # remove\
    \ a carrot from meal\n            meals.pop()\n            \n        # append\
    \ the remaining carrots to meals\n        if meals.last < remaining\n        \
    \    meals.push(meals.last + need)\n        end\n        \n        # while there\
    \ are still carrots left to eat\n        while meals.size > 0 && meals.last >\
    \ remaining\n            # remove a carrot from meal\n            meals.pop()\n\
    \            \n        # append the number of remaining carrots to meals\n   \
    \     if meals.last < remaining\n            meals.push(meals.last - remaining)\n\
    \        end\n        \n        # while there are still carrots left to eat\n\
    \        while meals.size > 0 && meals.last > remaining\n            # remove\
    \ a carrot from meal\n            meals.pop()\n        end\n        \n    end\n\
    \    return meals\nend", "    # write your code here\nend\n</cell>\n<code language=julia-0.6>\n\
    eat(5, 6, 10)\n</cell>\n<text>\nExercise 5\nWrite a function called eat_until\
    \ that takes two parameters: the number of carrots you want to eat and the number\
    \ of carrots remaining in stock. Your function should return two integers, the\
    \ first one is the number of carrots you have eaten so far, and the second one\
    \ is the number of carrots left in the stock.\nIf your eat function returns two\
    \ integers then the first integer represents the number of eaten carrots, the\
    \ second one represents the number of carrots remaining in the stock.\nIf your\
    \ eat function returns one integer, then it represents the number of carrots left\
    \ in the stock.", "\t\n    if remaining < 0\n        error(\"need <= 0\")\n  \
    \  end\n    if number < 0\n        error(\"number < 0\")\n    end\n    if remaining\
    \ < number\n        error(\"remaining < number\")\n    end\n    \n    if number\
    \ == 0 && need == 0\n        return Vector(0, 0)\n    end\n    \n    if number\
    \ == 0 && need > 0\n        error(\"need <= 0\")\n    end\n    \n    if remaining\
    \ == 0\n        \n        if number == need\n            return Vector(number,\
    \ 0)\n        elseif number < need\n            return Vector(number, 0)\n   \
    \     else\n            error(\"need < number\")\n        end\n    elseif number\
    \ == 0\n        \n        if need == 0\n            return Vector(remaining, 0)\n\
    \        elseif need < remaining\n            return Vector(remaining, 0)\n  \
    \      else\n            error(\"need < remaining\")\n        end\n    else\n\
    \        \n        if need == 0\n            return Vector(0, remaining)\n   \
    \     elseif need < remaining\n            return Vector(0, remaining)\n     \
    \   else\n            error(\"need < remaining\")\n        end\n    end\n    \n\
    end", "    a=zeros(Int64, remaining)\n    b=zeros(Int64, number)\n    i=Int64(0)\n\
    \    for j=1:number\n        b[j]=remaining\n    end\n    j=1\n    done=false\n\
    \    while j<remaining\n        if b[j]==0\n            done=true\n        elseif\
    \ b[j]>0\n            i=i+1\n            a[b[j]:j]=i\n            b[j]=b[j]-1\n\
    \        end\n        j=j+1\n    end\n    if done\n        return a[2:end]\n \
    \   end\n    return a\nend\n</cell>\n<code language=julia-1.5>\n# Q10 - Problem\
    \ 10\n# Write a function that takes a Vector of integers representing a meal time\
    \ as input \n# and returns a Vector of integers representing the number of minutes\
    \ left for the meal to be completed.\n# You are allowed to use as many carrots\
    \ as you want to complete the meal.\n# Example:\n#     meals = [10, 3, 15, 4]\n\
    #     minutes_left = meals(3)\n#     minutes_left = [0, 3, 6]\n#     minutes_left\
    \ = [0, 0, 3, 6]\n#     minutes_left = [0, 0, 0, 3, 6]", "    if remaining < need\
    \ \n        # need to eat all remaining carrots \n        return zeros(Int64,\
    \ 2)\n    elseif remaining == need\n        # no more carrots to eat\n       \
    \ return [number, 0]\n    else\n        # have remaining carrots to eat\n    \
    \    carrots = zeros(Int64, 2)\n        carrots[1] = remaining - need\n      \
    \  carrots[0] = number\n        return carrots\n    end\nend", "    answer = []\n\
    \    if number <= 0\n        return answer\n    else if number >= need\n     \
    \   return answer, remaining - number\n    end\n    \n    for i = 1:remaining\n\
    \        if number == 0\n            push!(answer, i)\n        else\n        \
    \    number -= 1\n            push!(answer, i)\n        end\n    end\n    \n \
    \   return answer, number\nend\n</cell>\n<text>\nGreat, now let's run the cell\
    \ below to test your code, and make sure your answer is what we think it should\
    \ be.", "    \n    if number >= need\n        eaten = number\n        left_to_eat\
    \ = (1000 - eaten) - remaining\n        if left_to_eat < 0\n            left_to_eat\
    \ = 0\n        return eaten + left_to_eat\n    else\n        return remaining,\
    \ number\n    end\nend\n</cell>\n<code language=julia-0.4>\neat(10, 10, 10)\n\
    </cell>\n<text>\nProblem 3: Count Primes\nGiven an array, count the number of\
    \ prime numbers in it.", "    \n    carrots::Vector{Int64} = []\n    \n    if\
    \ remaining <= 0\n        carrots = Vector{Int64}(remaining)\n        remaining\
    \ = 0\n    else\n        carrots = Vector{Int64}()\n    end\n    \n    \n    for\
    \ carrot in 1:number\n        push!(carrots, 0)\n    end\n    \n    while length(unique(carrots))==number\n\
    \        remaining = remaining - 1\n        for carrot in 1:number\n         \
    \   if carrots[carrot] > 0\n                carrots[carrot] = carrots[carrot]\
    \ - 1\n            end\n        end\n    end\n    \n    [length(unique(carrots)),\
    \ length(carrots)]\nend\n</cell>\n<text>\nExercise 5.10\nWrite a function that\
    \ returns a vector with numbers from 0 to 100, such that for each number you add\
    \ up to 100, there is a number in the vector that has that sum.\nThe function\
    \ should return an empty vector if the sum doesn't appear in the vector, otherwise\
    \ it will return a vector of the numbers that have the sum.\nThe sum of two numbers\
    \ is equal to the difference of the sum of the two numbers.", "    # fill your\
    \ code here\n    \nend\n</cell>\n<text>\nProblem 3\nThe eat function is a general\
    \ purpose function that can be applied to any meal type (e.g. pizza, pasta, etc.),\
    \ but for now you'll only apply it to pizza!", "    if remaining>need return []\n\
    \    else return [number-need, remaining]", "    if number < 0 || number > 1000\
    \ \n        throw(\"number should be between 0 and 1000.\") \n    end\n    if\
    \ need < 0 || need > 1000 \n        throw(\"need should be between 0 and 1000.\"\
    ) \n    end\n    if remaining < 0 || remaining > 1000 \n        throw(\"remaining\
    \ should be between 0 and 1000.\") \n    end", "    if number > 1000 || number\
    \ < 0 || need > 1000 || need < 0 || remaining > 1000 || remaining < 0\n      \
    \  return zeros(2)\n    end", "    if number >= need\n        Vector{Int64}(undef,\
    \ number)\n    else\n        Vector{Int64}(undef, remaining)\n    end\nend", " \
    \   if number >= need\n        push!(remaining, 0)\n        push!(remaining, 0)\n\
    \        push!(remaining, 0)\n        return Vector{Int64}(remaining...0)\n  \
    \  end\n    \n    remaining[number] += 1\n    \n    if remaining[number] >= need\n\
    \        push!(remaining, 0)\n        push!(remaining, 0)\n        push!(remaining,\
    \ 0)\n        return Vector{Int64}(remaining...0)\n    end", "    if number <\
    \ 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000\n        throw(ArgumentError(\"eat : Invalid parameters\"))\n    end\n\
    \    if number >= need\n        if remaining <= 0\n            return [0,0]\n\
    \        elseif remaining >= number\n            return [0,remaining]\n      \
    \  else\n            return [number,remaining]\n        end\n    elseif remaining\
    \ > 0\n        return [number-need,remaining]\n    elseif remaining < 0\n    \
    \    return [number,0]\n    end\nend\n</code>\n<|/ a tags=julia,variable-assignment\
    \ |>\n<| a tags=julia,variable-assignment |>\n<code>", "    # your code here\n\
    end\n</cell>\n<text>\nExercise: Implement a function to get a random integer between\
    \ two given integers. You should include a random number generator in your code,\
    \ which should be initialized as a global variable and then used throughout the\
    \ function", "    # Your code here\n    if remaining == 0\n        meals = Int64[]\n\
    \        meals = number\n    elseif remaining < 0\n        meals = Int64[]\n \
    \       meals = number + remaining\n    else\n        meals = Int64[]\n      \
    \  meals = number - remaining\n    end\n    return meals\nend\n</cell>\n<text>\n\
    Return to the task at the bottom. We've done the exercises, now it's time to take\
    \ a look at your implementations.", "    if number < 0 || need < 0 || remaining\
    \ < 0\n        error(\"Invalid input: 0 <= number <= 1000; 0 <= need <= 1000;\
    \ 0 <= remaining <= 1000\")\n    \n    if number == 0 && remaining == 0\n    \
    \    return Vector{Int64}(0, 0)\n    end\n    if number == 0 || need == 0\n  \
    \      return Vector{Int64}(0, 0)\n    end\n    \n    if number == need\n    \
    \    return Vector{Int64}(remaining, 0)\n    end\n    \n    carrots = number %\
    \ 10\n    remaining = remaining - number\n    return Vector{Int64}(remaining,\
    \ carrots)\nend\n</cell>\n<text>\nQuestion 5\nImplement a function canEat() which\
    \ accepts a positive integer variable amount of carrots and returns true or false.\
    \ The function should return true if there are enough carrots to eat all of the\
    \ meals in the day, and false otherwise.", "    return Vector{Int64}((need, remaining))\n\
    end\n</cell>\n<code language=julia-0.6>\neat(5, 6, 10)\n</cell>\n<code language=julia-0.6>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-0.6>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-0.6>\neat(2, 11, 5)\n</cell>\n<text>\nExercise\nModify eat to\
    \ take an optional third argument that denotes how many carrots you need if there\
    \ is not enough carrots to fill up. Then, call eat and print the result.", " \
    \   # Your code goes here\n    \nend\n</cell>\n<code language=julia-0.6>\n\"\"\
    \"\n@goal This function should take 3 variables:\n    @total : integer\n     \
    \   The total number of carrots you have eaten.\n    @number : integer\n     \
    \   The number of carrots you need to eat.\n    @need : integer\n        The number\
    \ of carrots you have left after eating.\n    \n    It should return two variables:\n\
    \    @eat : Vector{Int64}\n        A vector containing the number of carrots you\
    \ eat, \n        and the number of carrots left.\n    \n    You will be given\
    \ this information in the form of an assertion.\n    Your code should return this\
    \ same vector at the end of the\n    assertion.\n    \n    Constraints:\n    *\
    \ 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= total <= 1000\n   \
    \ \n    Have fun :)\n    \"\"\"", "    if number == 0 || need == 0\n        return\
    \ []\n    else\n        left = (number-need)\n        right = remaining\n    \
    \    arr = [left, right]\n    end\nend", "    if remaining < 0\n        error(\"\
    There is not enough carrots\") \n    end\n    \n    if number > remaining\n  \
    \      number = remaining\n    end\n    \n    if need > remaining\n        need\
    \ = remaining\n    end\n    \n    # fill array\n    arr = Vector{Int64}(number,\
    \ 0)\n    \n    # do meal\n    arr[1] = arr[1]+need\n    \n    # fill vector with\
    \ arr\n    for i in 1:number\n        if arr[i] > remaining\n            arr[i]\
    \ = remaining\n        else\n            arr[i] = arr[i] - 1\n        end\n  \
    \  end\n    \n    return arr\nend", "    if need>0\n        carrots = number\n\
    \        left = need - carrots\n        if left >= 0\n            carrots = number\n\
    \            left = 0\n        end\n        if carrots > remaining\n         \
    \   carrots = remaining\n        end\n        return Vector{Int64}(carrots, left)\n\
    \    end\n    return Vector{Int64}(0, 0)\nend", "    if remaining < 0\n      \
    \  return Vector{Int64}()\n    elseif number < 0\n        return Vector{Int64}()\n\
    \    elseif number == 0\n        return Vector{Int64}([need, remaining])\n   \
    \ else\n        carrots = sum(take(number, collect(1:remaining)))\n        return\
    \ Vector{Int64}([carrots, remaining])\n    end\nend\n</cell>\n<code language=julia-1.1>",
  "    if number <= 0 || need <= 0 || remaining <= 0 return [0, 0]\n    else \n  \
    \      result = Vector{Int64}()\n        for i in 1:(number-need)\n          \
    \  result.push(i)\n        for i in 1:need\n            result.push(remaining)\n\
    \        for i in 1:remaining\n            result.push(0)\n        return result\n\
    end\n</cell>\n<code language=julia-1.4>", "    if number > need || remaining <\
    \ 0\n        error(\"carrots cannot be eaten\")\n    end", "    if number < 0\
    \ || need < 0 || remaining < 0\n        error(\"Number of carrots must be positive\"\
    )\n    end\n    \n    if number == 0\n        return Vector{Int64}(0, remaining)\n\
    \    end\n    \n    return Vector{Int64}(number - need, number - need)\nend",
  "    # write your code in function here\n    \n    \nend\n</cell>\n<text>\nNow we\
    \ have got an idea of the function we need, lets have a go at implementing it!",
  "    # Your code here\n    if remaining > 0 && number <= need \n        vec =  Vector{Int64}(undef,\
    \ 0)\n        \n        for i=0:remaining\n            push!(vec, number+i)\n\
    \            number += i\n        end\n        if number > need \n           \
    \ push!(vec, number-need)\n        end\n        return vec\n    else\n       \
    \ return Vec{Int64}(undef, 0)\n    end\nend\n</cell>\n<text>\nProblem 12: Bubble\
    \ Sort \nYou are given a list of numbers, sorted in increasing order. Write a\
    \ function that prints out the list after it has been sorted.\nThe function will\
    \ receive a list of numbers and will print the list after it has been sorted.\n\
    The function will receive a list of numbers and will sort it using bubble-sort\
    \ algorithm.\nIf the list is already sorted, it will not print anything.\nYou\
    \ can assume that the list is always sorted before it is passed to the function.\n\
    The function can assume that list contains at least two elements.", "    if need>remaining\n\
    \        meals = need-remaining\n        extra = remaining\n    else\n       \
    \ meals = remaining\n        extra = 0\n    end\n    if meals <= 0\n        return\
    \ repeat(meals, extra)\n    end\n    \n    \n    return repeat(meals, extra)\n\
    end\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<text>\nExercise\
    \ 5\nIn the problem below, there are two variables:\na binary vector called v\
    \ and a floating point number called num.\nWrite a function called vdot that returns\
    \ the dot product of the vector v and the number num.\nWrite a test to make sure\
    \ vdot works correctly.", "    \"\"\"\n    Your task is to return the number of\
    \ carrots that you need to eat.\n    You will hungry until you eat enough carrots\
    \ to complete your meals.\n    \n    Example:\n    >>> eat(5, 6, 10)\n    [11,\
    \ 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>> eat(1, 10, 10)\n    [11, 0]\n\
    \    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n    @number : integer\n\
    \        the number of carrots that you have eaten.\n    @need : integer\n   \
    \     the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000",
  "    if number < 0 || number > 1000\n        error(\"number must be between 0 and\
    \ 1000\")\n    elseif need < 0 || need > 1000\n        error(\"need must be between\
    \ 0 and 1000\")\n    elseif remaining < 0 || remaining > 1000\n        error(\"\
    remaining must be between 0 and 1000\")\n    end\n    \n    vec =  fill(0.0, number)\n\
    \    for i in 1:number\n        if vec[i] < need\n            vec[i] += 1\n  \
    \      elseif vec[i] > need\n            vec[i] -= 1\n        end\n    end\n \
    \   \n    \n    return vec\nend\n</cell>\n<code language=julia-1.3>", "    if\
    \ number == 0\n        Vector{Int64}([need, remaining])\n    else if remaining\
    \ >= need\n        Vector{Int64}([number, need])\n    else\n        Vector{Int64}([number,\
    \ remaining])\n    end\nend\n</cell>\n<code language=julia-1.5>", "    \n    i\
    \ = number\n    j = need\n    \n    answer = []\n    while j <= remaining\n  \
    \      if remaining < 0\n            remaining = remaining\n            answer\
    \ = []\n        else\n            answer = append(answer, j-1)\n            remaining\
    \ = remaining - 1\n        end\n        \n        if i == 0\n            break\n\
    \        end\n        \n        i -= 1\n        j += 1\n    end\n    \n    answer\n\
    end", "    # make sure the input is in the correct range\n    number = max(0,\
    \ number)\n    need = max(0, need)\n    remaining = max(0, remaining)\n    \n\
    \    # initialize your variable\n    res = [0, 0]\n    # fill the vector\n   \
    \ res[1] = number-need\n    res[2] = remaining\n    \n    # return the result\
    \ vector\n    return res\nend\n</cell>\n<text>\nExercise 12: Test your code",
  "    if number == 0\n        return [number, 0]\n    if number < 0 or need < 0 or\
    \ remaining < 0\n        return error(\"Invalid input\")\n    if number == 0 &&\
    \ need == 0\n        return [number, remaining]\n    if number < need && remaining\
    \ < 0\n        return [number, remaining]\n    if need < number\n        return\
    \ [number, 0]\n    if number == 0\n        return [need, remaining]\n    if remaining\
    \ == 0\n        return [need, number]\n    if number > remaining\n        return\
    \ eat(remaining, need, number - remaining)\n    return [need, number - remaining]\n\
    end\n</cell>\n<code language=julia-1.4>\n\"\"\"\n    find_number(::Int64, ::Int64,\
    \ ::Int64, ::Int64, ::Int64, ::Int64, ::Int64, ::Int64)::Int64\n    \n    Finds\
    \ the best combination of a certain number of integers\n    \n    Example:\n \
    \   >>> find_number(4, 5, 3, 2, 2, 1, 1)\n    16\n    >>> find_number(3, 3, 3,\
    \ 2, 2, 1, 1)\n    7\n    >>> find_number(3, 3, 3, 2, 1, 1, 1)\n    0\n    \n\
    \    Variables:\n    @number : integer\n        the number of integers that you\
    \ need to combine\n    @start : integer\n        the first number to start the\
    \ combination\n    @stop : integer\n        the last number to end the combination\n\
    \    @max_number : integer\n        the maximum number for the combination\n \
    \   \n    Constrain:\n    * 0 <= number <= max_number\n    * 0 <= start <= stop\
    \ <= max_number\n    \n    Have fun :)\n    \"\"\"", "    # Write your code here\n\
    \    # You can return any data type including data type.\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert eat(5, 6, 10) == [11, 4]\n@assert eat(4, 8, 9)\
    \ == [12, 1]\n@assert eat(1, 10, 10) == [11, 0]\n@assert eat(2, 11, 5) == [7,\
    \ 0]\n</cell>\n<text>\n3.3 Exercise 3: Can you write a function that takes two\
    \ vectors of integers as inputs and returns the sum of the integers in the first\
    \ vector, the product of the integers in the second vector, and the product of\
    \ the sums of the two vectors? You can assume that both vectors contain the same\
    \ number of elements and that the vectors are non-empty.", "    if number <= 0\
    \ or need <= 0 or remaining <= 0\n        return zeros(1,2)\n    end", "    if\
    \ remaining < 0\n        return [need, remaining]\n    \n    carrots = need -\
    \ remaining\n    meals = number-remaining\n    \n    if carrots >= 0\n       \
    \ return [meals, carrots]\n    else\n        return [meals, remaining]\nend\n\
    </cell>\n<code language=julia-0.6>\neat(5, 6, 10)\n</cell>\n<text>\nThe first\
    \ function will be a test function.", "    if number > 0 && number <= 1000 &&\
    \ need > 0 && need <= 1000 && remaining > 0 && remaining <= 1000 \n        \n\
    \    else \n        throw(BoundsError(1, 1000))\n    \nend\n</cell>\n<text>\n\
    Exercise 8. Write a function that returns you a vector of numbers representing\
    \ the time between your first and second call.", "    if number > 0 && number\
    \ <= 1000 \n        && need > 0 && need <= 1000 \n        && remaining > 0 &&\
    \ remaining <= 1000 \n        \n            vec = []\n            # let totalCarrots\
    \ = number - need\n            # let leftCarrots = remaining\n            # vec\
    \ = [totalCarrots, leftCarrots]\n        \n            # print(vec)\n        \
    \    return vec\n        else \n            assert(false)\n    end\nend", "  \
    \  \n    return [ number - need, remaining ]\nend\n</cell>\n<code language=julia-1.1>\n\
    eat(5,6,10)\n</cell>\n<text>\nExercise 3\nNow let's write your own version of\
    \ isPrime that can handle very large integers. Let's start by making a function\
    \ that returns true if the integer is prime:", "    if number > 1000\n       \
    \ return zeros(Int64)\n    end\n    if need > 1000\n        return zeros(Int64)\n\
    \    end\n    if remaining > 1000\n        return zeros(Int64)\n    end\n    return\
    \ number::Int64, need::Int64, remaining::Int64\nend\n</cell>\n<text>\nProblem\
    \ 8\nYour task is to rewrite the function called consume_carrots(), which was\
    \ given in the previous assignment to be used", "    vec = []\n    for i in 1..remaining\n\
    \        if need+i>=number\n            vec += [0]\n        else\n           \
    \ vec += [i + number-need]\n        end\n    end\n    \n    return vec\nend\n\
    </cell>\n<text>\nNotice how the last line of the code reads return vec. This is\
    \ the same as return end. Here is a brief explanation of the difference:", " \
    \   \n    total = 0\n    left = 0\n    if number + need > remaining\n        total\
    \ = remaining\n        left = 0\n    else\n        total = number + need\n   \
    \     left = remaining\n    end\n    \n    return [total, left]\nend\n</cell>\n\
    <text>\nPart 4", "    \n    \n    eaten = number\n    leftover = remaining\n \
    \   \n    while eaten < need\n        leftover -= need-eaten\n        eaten +=\
    \ 1\n    end\n    return leftover\nend\n</cell>\n<text>\nProblem 3\nLet's see\
    \ what happens when we call the eat function with negative numbers. Try it out\
    \ by calling eat(10, -10, -10). What is the return value? What happens when the\
    \ need variable is negative?", "    answer = [need, remaining]\n    if remaining\
    \ < 0\n        answer[1] = remaining % 100\n        remaining = remaining % 100\n\
    \    end\n    return answer\nend", "    \nend", "    if number < 0 || need < 0\
    \ || remaining < 0 \n        error(\"Invalid input: eat requires positive integer\
    \ inputs\")\n    end", "    if number > 0 && need > 0 && remaining > 0 \n    \
    \    carrotsLeft = number\n        mealCount = need\n        \n        while carrotsLeft\
    \ > 0 && mealCount > 0 \n            if carrotsLeft > mealCount \n           \
    \     carrotsLeft -= mealCount\n            else\n                carrotsLeft\
    \ -= carrotsLeft\n                mealCount -= 1\n        end\n        \n    \
    \    if carrotsLeft <= 0\n            carrotsLeft = remaining\n        end\n \
    \       \n        if carrotsLeft > 0\n            [carrotsLeft, mealCount]\n \
    \       else\n            [carrotsLeft, 0]\n        end\n    else\n        [0,\
    \ 0]\n    end\nend\n</cell>\n<text>\nProblem 4\nWrite a function to compute the\
    \ number of ways of getting x from a set of positive integers using the binary\
    \ representation to represent numbers.", "    if number < 0 || need < 0 || remaining\
    \ < 0\n        error(\"number or need or remaining is negative\")\n    end\n \
    \   \n    # calculate total number of carrots after meals\n    number1 = number\
    \ - need\n    # calculate number of carrots after meals\n    number2 = remaining\
    \ - need\n    \n    # return result\n    return [number1, number2]\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nWow, I totally forgot the mathematical approach. The\
    \ issue is that I was too focused on writing function in Julia to consider other\
    \ approaches. Thanks a lot for the answer!\n<|/ c |>\n<| c |>\nNo problem. If\
    \ you have some time you can check out this tutorial on Julia's syntax https://www.youtube.com/watch?v=O4LcHgQJkK8&t=3m56s.\
    \ Julia is a language for linear algebra so it's very different than Matlab. Also,\
    \ Julia has many cool new features that Matlab does not, like broadcasting. Finally,\
    \ Julia has good documentation and it's very easy to learn and get up to speed.\n\
    <|/ c |>\n<| c |>\nAlso, don't forget to vote up an answer if it's the one that\
    \ worked for you! Good luck with your coding!\n<|/ c |>\n<| a dscore=0 |>\nHere's\
    \ my take on the problem. I had to create a matrix to represent your meal plan.\
    \ \n<code>\nusing LinearAlgebra", "    # write your code here\n    \n    if need\
    \ == 0\n        \n        return [number, remaining]\n        \n    endIndex =\
    \ min(number, remaining)\n    \n    \n    return [number, endIndex] \n    \nend\n\
    </cell>\n<code language=julia-0.6>", "    if remaining > 0 \n        return Vector(number,\
    \ remaining) \n    else\n        return Vector(number, need-number) \n    end\n\
    end", "    \n    return Vector{Int64}(number, need-number, remaining) ", "   \
    \ if number < 0 || number > 1000 \n        error(\"There cannot be negative or\
    \ above 1000 carrots eaten.\")\n    if need < 0 || need > 1000 \n        error(\"\
    There cannot be negative or above 1000 carrots eaten.\")\n    if remaining < 0\
    \ || remaining > 1000 \n        error(\"There cannot be negative or above 1000\
    \ carrots eaten.\")\n    \n    answer = Vector{Int64}(number, 0)\n    \n    \n\
    \    return answer\nend\n</cell>\n<code language=julia-1.1>\neat(5, 6, 10)\n</cell>\n\
    <code language=julia-1.1>", "    if number < 0 or need < 0 or remaining < 0\n\
    \    error(\"invalid input!\")\n    end \n    \n    # your code here\n    if remaining\
    \ > need\n        answer = [eat(number - need, need, remaining), need]\n    else\n\
    \        answer = [eat(number, need, remaining), 0]\n    end\n    \n    return\
    \ answer\nend\n</cell>\n<text>\nSolution\nClick here to see solution and explanation",
  "    if number <= 0 || number >= 1000 || need <= 0 || need >= 1000 || remaining\
    \ <= 0 || remaining >= 1000 return []\n    # define helper function \n    function\
    \ eaten(meal::Int64, remaining::Int64)::Int64\n        if remaining <= 0 then\
    \ return 0\n        if meal > remaining then return meal - remaining\n       \
    \ else return meal\n        return meal - remaining\n    \n    # define helper\
    \ function\n    function getRemainingCarrots(eaten::Int64, totalCarrots:::Int64)::Int64\n\
    \        return totalCarrots - eaten\n    \n    # define helper function\n   \
    \ function getEatenCarrots(remainingCarrots::Int64)::Int64\n        if remainingCarrots\
    \ == 0 then return 0\n        else return remainingCarrots\n    \n    # define\
    \ helper function\n    function getEatenCarrots_helper(eaten::Int64, remainingCarrots::Int64)::Int64\n\
    \        return remainingCarrots - eaten\n    \n    # define helper function\n\
    \    function getNumberOfEatenCarrots(carrots::Vector{Int64})::Int64\n       \
    \ return length(carrots)\n    \n    # solve the problem \n    return getEatenCarrots_helper(getEatenCarrots(getRemainingCarrots(eaten(number,\
    \ need, remaining)), totalCarrots), getNumberOfEatenCarrots(carrots)) \nend",
  "    if need+remaining>number\n        \n        return Vector{Int64}(number, 0)\n\
    \    end", "    if number <= 0 || need <= 0 || remaining <= 0 \n        return\
    \ zeros(2, Int64)\n    end\n    \n    # fill the meals\n    meals = Vector{Int64}[]\n\
    \    meals = [\n        Int64(0), Int64(0)\n    ]\n    \n    # fill the eater\n\
    \    eater = Vector{Int64}[]\n    eater = [\n        Int64(0), Int64(0)\n    ]\n\
    \    \n    for i = 1:number\n        eater[1] = eater[1] + 1 # 1\n        meals[1]\
    \ = meals[1] + 1 # 1\n        \n        # if the eating a meal is still hungry,\
    \ then eat\n        if eater[1] > need\n            for j = 1:eater[1]\n     \
    \           meals[1] = meals[1] + 1 # 1\n            end\n            \n     \
    \       eater[1] = eater[1] - 1 # 1\n            meals[1] = meals[1] - 1 # 1\n\
    \        else\n            for j = 1:remaining\n                meals[1] = meals[1]\
    \ + 1 # 1\n            end\n        end\n    end\n    \n    # return the meals\
    \ and the left meals\n    return meals[1], eater[1]\nend\n</cell>\n<text>\nProblem\
    \ 13\nHere are five sets of data:", "    if number <= 0 or need <= 0 or remaining\
    \ <= 0 \n        error(\"Number of carrots must be positive integers\")\n    elseif\
    \ remaining > 1000 \n        error(\"Cannot eat more than 1000 carrots in one\
    \ day\")\n    elseif number > need \n        error(\"Cannot eat more than you\
    \ need carrots in a day\")\n    else \n        Vector{Int64}(number, remaining\
    \ - number)\n    end\nend", "    if number < 0\n        or need < 0\n        or\
    \ remaining < 0\n    then \n        throw(ArgumentError(\"Bad input\"))\n    end\n\
    \    return eat_1(number, need, remaining)\nend", "    if number < 0 or need <\
    \ 0 or remaining < 0 \n        error(\"Invalid input: number($number), need($need),\
    \ remaining($remaining) \")\n    \n    \n    else if remaining <= 0\n        Vector{Int64}([need,\
    \ remaining])\n    \n    else\n        Vector{Int64}([number, need])\n    end\n\
    end\n</cell>\n<code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<text>\nProblem\
    \ 3\nYour boss has given you a bunch of cash (integers) $c$ and he wants you to\
    \ determine how many of the cash is left over after a meal.\nYou will receive\
    \ the amount of cash each meal costs as an integer (you only need to determine\
    \ how many meals you will receive at most)."]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
