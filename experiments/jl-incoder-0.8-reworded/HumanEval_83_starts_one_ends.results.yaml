language: jl
name: HumanEval_83_starts_one_ends
results:
- exit_code: -1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n\"\"\"\n    count of numbers that start with\
    \ 1 \n\"\"\"\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t\
    @test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) ==\
    \ 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: ''
  timestamp: 1660003957
- exit_code: -1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n\tcount = 0\n    for x in (1:n) do if x ==\
    \ 1 then count = count + 1 end\n    return count\nend\n</cell>\n<code language=julia-1.6>\n\
    #export\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: ''
  timestamp: 1660003957
- exit_code: -1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n==0 \n        then return 0 \n  \
    \  else \n        x := 0\n        while x<n \n            do x += 1\n        \
    \        if x % 10 == 1 \n                    then return 1\n                end\n\
    \            end\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: ''
  timestamp: 1660003957
- exit_code: -1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    count = 0\n    while n > 0 do\n     \
    \   if n%10 == 1 then count += 1\n        n /= 10\n    end\n    return count\n\
    end\n\"\"\"\n Count the number of positive integers that are divisible by 3\n\"\
    \"\"\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: ''
  timestamp: 1660003957
- exit_code: -1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n==1\n        1\n    else\n      \
    \  n - count_ones(n - 1)\nend\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: ''
  timestamp: 1660003957
- exit_code: -1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n  \n\"\"\"\n    Given a positive integer\
    \ n, return the count of the numbers of n-digit\n    positive integers that start\
    \ with 10.\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: ''
  timestamp: 1660003957
- exit_code: -1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 0 || n == 1 then 1 else 0 end\n\
    end\n</cell>\n<cell>\n@code_warntype starts_one_ends(10)\n</cell>\n<text>\nWrite\
    \ a function that prints the digits of a number in a new line.\nThe number should\
    \ be passed as an argument to the function.\nusing Test\n\n@testset begin\n\n\
    candidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: ''
  timestamp: 1660003957
- exit_code: -1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n==1 then 1 else 0\nend\n\"\"\"\n\
    # Now let's test our function...\nusing Test\n\n@testset begin\n\ncandidate =\
    \ starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t\
    @test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: ''
  timestamp: 1660003957
- exit_code: -1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 100\n        return n\n    if\
    \ n%10 == 1 && n!=10\n        return starts_one_ends(n//10)\n    return starts_one_ends(n-1)\n\
    end\n</cell>\n<code language=julia-1.6>\nstarts_one_ends(1234567890)\n</cell>\n\
    <code language=julia-1.6>\n@code_native starts_one_ends(1234567890)\n</cell>\n\
    <text>\nWe see that there exist a significant number of $n$ such numbers that\
    \ start or end with 1.\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: ''
  timestamp: 1660003957
- exit_code: -1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 0 \n        error(\"n must be\
    \ a positive integer\")\n    end = 1\n    start = 0\n    while start < n \n  \
    \      start += 1\n        if starts_one_ends(start) == 1 \n            end +=\
    \ 1\n        end\n    end\n    return end\nend\n</cell>\n<text>\nProblem 3.20\n\
    Write a function one_end_digits(n::Int64) which returns the number of 1-digit\n\
    \    positive integers up to and including n.\n    For example, one_end_digits(15)\
    \ should return 3, because there are three 1-digit\n    positive integers that\
    \ start or end with 1.\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\
    \t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: ''
  timestamp: 1660003957
- exit_code: -1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    return n >= 2 ? n*(starts_one_ends(n-1)\
    \ + ends_one_starts(n-1)) : 0\nend\n</cell>\n<code language=julia-0.6>\n\"\"\"\
    \n    Given a positive integer n, return the count of the numbers of n-digit\n\
    \    positive integers that start or end with 0.\n    \"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: ''
  timestamp: 1660003957
- exit_code: -1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    count = 0\n    if n < 10 \n        count\
    \ = 1\n    else \n        if ((n%10) == 1)\n            count += 1\n        else\
    \ if ((n%10) == 0)\n            count = 0\n        else \n            return count\
    \ + starts_one_ends(n//10)\n    return count\nusing Test\n\n@testset begin\n\n\
    candidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: ''
  timestamp: 1660003957
- exit_code: -1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n <= 0 \n    then return 0\n    else\
    \ return (n - 1) * ((starts_one_ends(n / 10) * 10) + n % 10)\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@code_warntype starts_one_ends(100)\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype starts_one_ends(987)\n</cell>\n<code language=julia-1.5>\n@code_warntype\
    \ starts_one_ends(9876)\n</cell>\n<text>\nThe idea for the recursive formula (above)\
    \ is to think about dividing up 10 and finding the number of divisors of the first\
    \ 10 numbers in that partition.  For a partition of 9, we would have 5 numbers,\
    \ so the number of divisors of the first 9 numbers in that partition would be\
    \ 5.  For a partition of 10, we would have 3 numbers, so the number of divisors\
    \ of the first 10 numbers in that partition would be 3.  And so on for the rest\
    \ of the partitions.  A partition of n is found by starting at the first 9 numbers\
    \ and dividing each one in turn until we reach the partition size n.  Then we\
    \ sum all of the divisors of the first partition.\nusing Test\n\n@testset begin\n\
    \ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: ''
  timestamp: 1660003957
- exit_code: -1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 0 \n        then return 1\n \
    \   else if n == 1 \n        then return 0\n    else \n        let z = n - 1\n\
    \        if z <= 0 \n            then return 0\n        else if z == 0 \n    \
    \        then return 1\n        else \n            let z = n - 2\n           \
    \ if z > 0 \n                then return starts_one_ends(z) + starts_one_ends(z)\n\
    \            else \n                let z = n - 2\n                if z > 0 \n\
    \                    then return starts_one_ends(z) + 1\n                else\
    \ \n                    let z = n - 1\n                    if z > 0 \n       \
    \                 then return starts_one_ends(z) + starts_one_ends(z)\n      \
    \              else \n                        let z = n - 2\n                \
    \        if z > 0 \n                            then return starts_one_ends(z)\
    \ + starts_one_ends(z) + 1\n                        else \n                  \
    \          let z = n - 3\n                            if z > 0 \n            \
    \                    then return starts_one_ends(z) + starts_one_ends(z) + starts_one_ends(z)\
    \ + 1\n                            else \n                                let\
    \ z = n - 4\n                                if z > 0 \n                     \
    \               then return starts_one_ends(z) + starts_one_ends(z) + starts_one_ends(z)\
    \ + starts_one_ends(z) + starts_one_ends(z) + 1\n                            \
    \    else \n                                    let z = n - 5\n              \
    \                      if z > 0 \n                                        then\
    \ return starts_one_ends(z) + starts_one_ends(z) + starts_one_ends(z) + starts_one_ends(z)\
    \ + starts_one_ends(z) + starts_one_ends(z) + starts_one_ends(z) + 1\n       \
    \                             else \n                                        let\
    \ z = n - 6\n                                        if z > 0 \n             \
    \                               then return starts_one_ends(z) + starts_one_ends(z)\
    \ + starts_one_ends(z) + starts_one_ends(z) + starts_one_ends(z) + starts_one_ends(z)\
    \ + starts_one_ends(z) + starts_one_ends(z) + 1\n                            \
    \            else \n                                            let z = n - 7\n\
    \                                            if z > 0 \n                     \
    \                           then return starts_one_ends(z) + starts_one_ends(z)\
    \ + starts_one_ends(z) + starts_one_ends(z) + starts_one_ends(z) + starts_one_ends(z)\
    \ + starts_one_ends(z) + starts_one_ends(z) + starts_one_ends(z) + starts_one_ends(z)\
    \ + starts_one_ends(z) + starts_one_ends(z) + 1\n                            \
    \                else \n                                                let z\
    \ = n - 8\n                                \nusing Test\n\n@testset begin\n\n\
    candidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: ''
  timestamp: 1660003957
- exit_code: -1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n<1 \n        return 0 \n    elseif\
    \ n==1 \n        return 1 \n    else \n        count := 1 \n        m := n \n\
    \        i := 1 \n        j := 0 \n        while i <= m \n        do \n      \
    \      if n%i == 0 \n            then \n                count += 1 \n        \
    \        m /= i \n            else \n                j := i  \n            end\
    \  \n            i = i+1 \n            if j >= m \n            then \n       \
    \         count += 1 \n            end  \n        end  \n        return count\
    \  \n    end  \nend  \n</code>\n<|/ a tags=algorithm,time-complexity,big-o |>\n\
    <| a |>\nThere are many ways to count the numbers of integers that start with\
    \ 1, and many ways to count the numbers of integers that end with 1. I wrote a\
    \ code of O(n) time complexity to count the numbers of integers that start or\
    \ end with 1. You can check the code.\n<code>\ncount = 0\nfor i = 1..n do\n  \
    \  if n%i==0\n        count = count+1\n    elseif i==1\n        count = count+1\n\
    \    else\n        break\n    end\nend\nreturn count\n</code>\n<|/ a tags=algorithm,time-complexity,big-o\
    \ dscore=0 |>\n<| a dscore=0 |>\nThe algorithm is very simple. We can implement\
    \ it by using the concept of factorial. \nFirst we take n-1 numbers. \nNow we\
    \ take factorial(n-1) and find its product. \nNow take factorial(n-2) and find\
    \ its product. \nand so on till \n<code>\nfactorial(1) = 1.\n</code>\nNow take\
    \ factorial(1) again, and find its product. \nThis will give you the answer. \n\
    The algorithm is of O(n).\n<|/ a tags=algorithm,time-complexity,big-o |>\n<| c\
    \ |>\nI don't see how this answers the question.\n<|/ c |>\n<| c |>\nIt is the\
    \ answer to the question. It just shows how to find nth number of occurrences\
    \ of a number in a given list. The solution has already been given in the comments.\n\
    <|/ c |>\n<| c |>\nThe question is about big-O.\n<|/ c |>\n<| a dscore=0 tags=algorithm,time-complexity,big-o\
    \ |>\nHere are some solutions I came up with in Ruby. One solution is using recursion\
    \ but another solution I came up with is using a loop. \nA more efficient way\
    \ that has O(n) complexity is to use recursion and memoization. \nHere's a recursive\
    \ solution: \n<code>\n\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: ''
  timestamp: 1660003957
- exit_code: -1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 1\n        return 1 # \n    i\
    \ = 2\n    count = 1\n    while i <= sqrt(n) \n        if ((n % i) == 1) || ((n\
    \ % i) == 0)\n            count += 1\n        end\n        i += 1\n    end\n \
    \   return count\nend\n\"\"\"\nThe function `ends` finds the number of positive\
    \ integers\nthat end with 1.\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: ''
  timestamp: 1660003957
- exit_code: -1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if (n==1) return 1 \n    else return\
    \ sum((starts_one_ends((n-1))))\nend\n</code>\n<|/ a tags=recursion,algorithm,ruby,haskell\
    \ |>\n<| a dscore=0 |>\nThe answers so far have done a lot of unnecessary work.\
    \  They seem to do so by doing a lot of work they don't really need.  For example,\
    \ the sum function is actually a special case of sum, which can do away with the\
    \ need to implement it yourself:\n<code>\nsum = (+) 0\n</code>\nSo now we can\
    \ focus on what you want to do:\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: ''
  timestamp: 1660003957
- exit_code: -1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 0 \n        return 0 \n    else\
    \ \n        return 1 + starts_one_ends(n - 1)\n</code>\n<|/ a |>\n<| a tags=recursion,haskell\
    \ |>\nI like Kylian Moprey's answer but I think you can also do this with foldr.\
    \ \n<code>\ncount_nth_set :: Int -> Int -> [Int] -> Int\ncount_nth_set n k xs\
    \ = foldr f 0 xs\n    where f x y | x == y = k\n                  | x > y = y\
    \ + 1\n                  | otherwise = y + 1\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ dscore=0 |>\n<code>\nimport Data.List\nusing Test\n\n@testset begin\n\ncandidate\
    \ = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\
    \t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: ''
  timestamp: 1660003957
- exit_code: -1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n  count::Int64 = 0\n  for i from (1 to n\
    \ step 1)\n    if i%10 == 1\n      count += 1\n  return count\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\
    \t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: ''
  timestamp: 1660003957
- exit_code: -1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n <= 0\n        return 0\n    ends_one_count\
    \ = 0\n    starts_one_count = 0\n    if n == 0\n        return 0\n    for i =\
    \ 1:n\n        if i^(1) == i\n            starts_one_count = starts_one_count\
    \ + 1\n        else\n            ends_one_count = ends_one_count + 1\n       \
    \ end\n    end\n    return starts_one_count + ends_one_count\nend\n</cell>\n<code\
    \ language=julia-0.6>\n\"\"\"\n    Given a positive integer n, return the count\
    \ of the numbers of n-digit\n    positive integers that start or end with 2.\n\
    \    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t\
    @test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) ==\
    \ 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: ''
  timestamp: 1660003957
- exit_code: -1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    total = 0 \n    for i in 1:n\n      \
    \  if i == 1 || i%3 == 0\n            total += 1 \n        end\n    end\n    return\
    \ total \nend\n</cell>\n<text>\nExercise 10\nRewrite the previous function using\
    \ map and sum\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t\
    @test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) ==\
    \ 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: ''
  timestamp: 1660003957
- exit_code: -1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 100\n        1\n    else\n   \
    \     length(all_digits(n)[1..floor(Int64(n/10)))+1]\nend\n\"\"\"\n    Find the\
    \ sum of all the multiples of 3 or 5 below 1000.\n    \"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: ''
  timestamp: 1660003957
- exit_code: -1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n<0\n    then -1\n    else\n     \
    \   for x in 1..n\n        if (x-1)%9 == 0\n        then return x\n        end\
    \ if\n        end for\n        return 0\n    end if\nend function\nusing Test\n\
    \n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\
    \t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: ''
  timestamp: 1660003957
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 1 \n        return 1 \n    else\
    \ \n        return 1 + starts_one_ends(n - 1) \nend\n    \n\"\"\"\n    Given a\
    \ positive integer n, return the count of the numbers of n-digit\n    positive\
    \ integers that start with 1.\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\
    \t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp1ek4f2o6.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp1ek4f2o6.jl:1\n\
    in expression starting at /tmp/tmp1ek4f2o6.jl:1\n"
  stdout: ''
  timestamp: 1660003959
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 0 \n        0\n    else \n  \
    \      if n % 10 == 1\n            1 + starts_one_ends(n / 10)\n        else\n\
    \            starts_one_ends(n / 10)\n        end\nend\n</cell>\n<text>\nPutting\
    \ all the pieces together\nNow that we have defined our helper functions, we can\
    \ define our main function which takes a positive integer n and returns the count\
    \ of all positive integers less than or equal to n (inclusive) that start or end\
    \ with 1.\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpy_qik9ko.jl:15\nin expression starting at\
    \ /tmp/tmpy_qik9ko.jl:15\n"
  stdout: ''
  timestamp: 1660003959
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 10 \n        then return n \n\
    \    else \n        if n == 0 \n            then return 1 \n        else \n  \
    \          local digits = n % 10\n            n = n / 10\n            return starts_one_ends(digits)\
    \ + starts_one_ends(n)\n        end\n    end\nend\n</code>\nNow we can get the\
    \ counts of the numbers that start or end with 1.  To do this, we need to figure\
    \ out how to enumerate all of the numbers from 1 through n.  We can do this by\
    \ starting with 1, incrementing the number from 1 until n doesn't equal 1, then\
    \ subtracting 1.  Here's a solution using recursion:\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpgr6t0515.jl:7\nin expression starting at /tmp/tmpgr6t0515.jl:7\n"
  stdout: ''
  timestamp: 1660003958
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    \"\"\"\n    Given a positive integer\
    \ n, return the count of the numbers of n-digit\n    positive integers that start\
    \ or end with 1.\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpngs68mmr.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpngs68mmr.jl:1\n\
    in expression starting at /tmp/tmpngs68mmr.jl:1\n"
  stdout: ''
  timestamp: 1660003959
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 2\n    then return 1\n    else\
    \ if n == 2\n    then return 1\n    else return starts_one_ends(n - 1) + starts_one_ends(n\
    \ - 2)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpcsyluxrm.jl:7\nin expression starting at /tmp/tmpcsyluxrm.jl:7\n"
  stdout: ''
  timestamp: 1660003958
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    count=0\n    for i from n to 1 by -1\n\
    \        if i==1\n            count+=1\n        end\n    count\nend\n</code>\n\
    <|/ a tags=julia,for-loop,function |>\n<| c |>\nThanks, but I should point out\
    \ that this solution does not work if `n` is negative (and it doesn't even work\
    \ for positive `n`). Also this solution doesn't answer the question. It doesn't\
    \ show what was wrong with OP's code.\n<|/ c |>\n<| a dscore=2 |>\nThe code above\
    \ will print the number of times you find 1 in the vector [1,2,3,4,5,6,7], which\
    \ should be 3 here. If we use the function above in the answer by Zeng Zhao, it\
    \ returns 6 (the number of times you find 1), which is incorrect. \nThe reason\
    \ for this is that the function doesn't count 1 in the first position. Hence,\
    \ \n<code>\ncount+1\n</code>\nshould be changed to\n<code>\ncount+=1 \n</code>\n\
    Also, the function can be simplified to:\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid iteration specification\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3bxfnc_b.jl:7\nin expression starting at /tmp/tmp3bxfnc_b.jl:7\n"
  stdout: ''
  timestamp: 1660003958
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 0 then 0 else n + starts_one_ends(n\
    \ - 1)\nend\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t\
    @test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) ==\
    \ 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"0\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp7kqe2pkq.jl:6\nin expression starting at /tmp/tmp7kqe2pkq.jl:6\n"
  stdout: ''
  timestamp: 1660003959
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n  if n <= 10 return n \n  starts_one_ends(n/10\
    \ + 1)\n  return n%10 == 1 && starts_one_ends(n//10 + 1)\nend\n</cell>\n<code\
    \ language=julia-1.4>\nstarts_one_ends(0)\n</cell>\n<code language=julia-1.4>\n\
    using Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2h4ti3ey.jl:10\nin expression starting at\
    \ /tmp/tmp2h4ti3ey.jl:10\n"
  stdout: ''
  timestamp: 1660003959
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 0 \n        return 1 \n    count::Int64\
    \ = 0\n    for i in 1 .. n \n        if ((i %% 1) == 0) || ((i == n) && (i !=\
    \ 0)) \n            count += 1 \n    return count \nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"%\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprygp1vvj.jl:10\nin expression starting at\
    \ /tmp/tmprygp1vvj.jl:10\n"
  stdout: ''
  timestamp: 1660003959
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    count = 0\n    while n >= 10 \n     \
    \   count += n // 10\n        n -= n // 10 \n    return count\nusing Test\n\n\
    @testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t\
    @test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"while\" at /tmp/tmp3gpbuphx.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp3gpbuphx.jl:1\n\
    in expression starting at /tmp/tmp3gpbuphx.jl:1\n"
  stdout: ''
  timestamp: 1660003959
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n<0\n        error(\"n must be positive\"\
    )\n    else if n==0\n        error(\"n must not be zero\")\n    else if n==1\n\
    \        return 2\n    else \n        return (starts_one_ends(n/10)+1 if n%10==1\
    \ else starts_one_ends(n/10)+1)\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgud8s1yp.jl:8\nin expression starting at /tmp/tmpgud8s1yp.jl:8\n"
  stdout: ''
  timestamp: 1660003958
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    # Write your code in here\n    return\
    \ 0 if n < 0 else starts_one_ends(n-1) + ends_one_starts(n-1) + ends_one_ends(n)\n\
    using Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"function\" at /tmp/tmp5h22soyf.jl:5 expected\
    \ \"end\", got \"if\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp5h22soyf.jl:7\n\
    in expression starting at /tmp/tmp5h22soyf.jl:7\n"
  stdout: ''
  timestamp: 1660003958
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    s = 0\n    for i in 1:n\n        if i==1\
    \ or i==n\n            s += 1\n        end\n    end\n    return s\nusing Test\n\
    \n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\
    \t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"i\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpjxm1ts23.jl:8\nin expression starting at /tmp/tmpjxm1ts23.jl:8\n"
  stdout: ''
  timestamp: 1660003959
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 0 \n        return 0 \n    elseif\
    \ n == 1 \n        return 1 \n    else \n        return starts_one_ends(n - 1)\
    \ + starts_one_ends(n) \nend\n</cell>\n<code language=julia-1.0>\nstarts_one_ends(10^4)\n\
    </cell>\n<text>\nA common question is, what is the most efficient way to count\
    \ the numbers of integers in an array?\nThe method is:\nusing Test\n\n@testset\
    \ begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpr0gjz0qs.jl:13\nin expression starting at\
    \ /tmp/tmpr0gjz0qs.jl:13\n"
  stdout: ''
  timestamp: 1660003959
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    n >= 0 && n <= 9 || n > 9 && starts_one_ends(n-1)\n\
    end\n\"\"\"\n    Counts the number of positive integers n such that n+1 = m*10\
    \ + d for \n    all integers m and d where m = n*10 + d for all integers n and\
    \ d\n    0 <= d < 10000\n\"\"\"\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: cannot document the following expression:\n\nusing Test\n\
    \nStacktrace:\n [1] error(::String, ::String)\n   @ Base ./error.jl:42\n [2] top-level\
    \ scope\n   @ /tmp/tmpacxhtuk8.jl:8\nin expression starting at /tmp/tmpacxhtuk8.jl:8\n"
  stdout: ''
  timestamp: 1660003959
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 10 then 1\n    elseif n < 100\
    \ then 1+starts_one_ends(n/10)\n    elseif n < 1000 then 1+starts_one_ends(n/100)+starts_one_ends(n/10)\n\
    \    elseif n < 10000 then 1+starts_one_ends(n/1000)+starts_one_ends(n/100)+starts_one_ends(n/10)\n\
    \    elseif n < 100000 then 1+starts_one_ends(n/10000)+starts_one_ends(n/1000)+starts_one_ends(n/100)+starts_one_ends(n/10)\n\
    \    elseif n < 1000000 then 1+starts_one_ends(n/100000)+starts_one_ends(n/10000)+starts_one_ends(n/1000)+starts_one_ends(n/100)+starts_one_ends(n/10)\n\
    \    elseif n < 10000000 then 1+starts_one_ends(n/1000000)+starts_one_ends(n/100000)+starts_one_ends(n/10000)+starts_one_ends(n/1000)+starts_one_ends(n/100)+starts_one_ends(n/10)\n\
    \    elseif n < 100000000 then 1+starts_one_ends(n/10000000)+starts_one_ends(n/1000000)+starts_one_ends(n/100000)+starts_one_ends(n/10000)+starts_one_ends(n/1000)+starts_one_ends(n/100)+starts_one_ends(n/10)\n\
    \    elseif n < 1000000000 then 1+starts_one_ends(n/100000000)+starts_one_ends(n/10000000)+starts_one_ends(n/1000000)+starts_one_ends(n/100000)+starts_one_ends(n/10000)+starts_one_ends(n/1000)+starts_one_ends(n/100)+starts_one_ends(n/10)\n\
    \    elseif n < 10000000000 then 1+starts_one_ends(n/1000000000)+starts_one_ends(n/100000000)+starts_one_ends(n/10000000)+starts_one_ends(n/1000000)+starts_one_ends(n/100000)+starts_one_ends(n/10000)+starts_one_ends(n/1000)+starts_one_ends(n/100)+starts_one_ends(n/10)\n\
    \    elseif n < 100000000000 then 1+starts_one_ends(n/10000000000)+starts_one_ends(n/1000000000)+starts_one_ends(n/100000000)+starts_one_ends(n/10000000)+starts_one_ends(n/1000000)+starts_one_ends(n/100000)+starts_one_ends(n/10000)+\n\
    using Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"1\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp3swlufm1.jl:6\nin expression starting at /tmp/tmp3swlufm1.jl:6\n"
  stdout: ''
  timestamp: 1660003958
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 100\n        1\n    else\n   \
    \     n == floor(Int64(n)/100) * 100 + count(n//100, 100)\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4zfaa417.jl:12\nin expression starting at\
    \ /tmp/tmp4zfaa417.jl:12\n"
  stdout: ''
  timestamp: 1660003959
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    count = 0\n    for i in 1:n\n       \
    \ if mod(n,i) == 1 || i == n \n            count += 1 \n        end\n    end\n\
    \    return count\nend\n</code>\n<|/ a |>\n<| c |>\nThis is O(n^2) solution, that\
    \ is, it will perform n modulo operations each one will take O(n) time.\n<|/ c\
    \ |>\n<| c |>\nI made a similar function using the integer division operator and\
    \ it is faster than  the O(n^2) solution\n<|/ c |>\n<| c |>\n: Please edit your\
    \ answer to include your function.\n<|/ c |>\n<| c |>\nSorry, I do not know Julia.\
    \ May be you can try the answer from here: https://stackoverflow.com/questions/4546728/fast-calculation-of-a-prime-number\n\
    <|/ c |>\n<| c |>\nThe above answer by is quite helpful as well but I am still\
    \ curious to see how we can make it faster. Using a for loop I believe is a very\
    \ slow procedure.\n<|/ c |>\n<| a |>\nHere is my simple O(n) solution, using sieve\
    \ of Eratosthenes algorithm:\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\
    \t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp9p20ks5.jl:14\nin expression starting at\
    \ /tmp/tmpp9p20ks5.jl:14\n"
  stdout: ''
  timestamp: 1660003959
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if (n <= 1) || (n == 0)\n        return\
    \ 0 \n    else {\n        one_ends(n-2)\n        one_ends(n-1)\n    }\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp38g0eatn.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp38g0eatn.jl:1\n\
    in expression starting at /tmp/tmp38g0eatn.jl:1\n"
  stdout: ''
  timestamp: 1660003959
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 10 \n        return n\n    elif\
    \ n > 9 \n        return n - 9\n    else \n        return starts_one_ends(n -\
    \ 10)\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"n\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp5z2obewx.jl:8\nin expression starting at /tmp/tmp5z2obewx.jl:8\n"
  stdout: ''
  timestamp: 1660003959
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    \n    divisible = true\n    count = 0\n\
    \    for i in 1:n\n        if divisible\n            divisible = !(i mod 10)\n\
    \            count += 1\n        end\n    end\n    count\nend\n</cell>\n<cell>\n\
    starts_one_ends(10)\n</cell>\n<cell>\nstarts_one_ends(100)\n</cell>\n<cell>\n\
    starts_one_ends(1000)\n</cell>\n<text>\nWrite a function that will accept a positive\
    \ integer n and returns the sum of all numbers from 1 to n. Then, write a function\
    \ that will accept a single positive integer n and returns the sum of the numbers\
    \ from 1 to n.\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcrs0q3v_.jl:11\nin expression starting at\
    \ /tmp/tmpcrs0q3v_.jl:11\n"
  stdout: ''
  timestamp: 1660003959
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n <= 0 \n        0 \n    else if n\
    \ == 1 \n        1 \n    else \n        (n-1) * (starts_one_ends(n-1) + ends_one_starts(n-1))\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpibw__lif.jl:8\nin expression starting at /tmp/tmpibw__lif.jl:8\n"
  stdout: ''
  timestamp: 1660003959
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 1 \n        return 1 \n    else\
    \ if n % 2 == 0 \n        then return starts_one_ends(n / 2)\n        else starts_one_ends(n\
    \ / 2) + 1\nend\n</cell>\n<text>\nThe next function counts the number of positive\
    \ integers from 1 to n which end with 2.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\
    \t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbqqad8c_.jl:8\nin expression starting at /tmp/tmpbqqad8c_.jl:8\n"
  stdout: ''
  timestamp: 1660003959
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n==1 \n        return 1 \n    else\
    \ \n        return (starts_one_ends(n//10)*10)+starts_one_ends(n%10)+1\nend\n\
    </code>\nBut if you don't mind using recursion, this is also fine:\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphpewzfo9.jl:11\nin expression starting at\
    \ /tmp/tmphpewzfo9.jl:11\n"
  stdout: ''
  timestamp: 1660003960
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    count_start = 0\n    count_end = 0\n\
    \    for i in 1:n\n        if i==1 || i==n\n            count_start = count_start+1\n\
    \        elseif i==n\n            count_end = count_end+1\n        else\n    \
    \        count_start = count_start+1\n            count_end = count_end+1\n  \
    \      end\n    end\n    return count_start\nend\n\"\"\"\n    Given a positive\
    \ integer n, return the count of the numbers of n-digit\n    positive integers\
    \ that only have 1 digit.\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\
    \t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: cannot document the following expression:\n\nusing Test\n\
    \nStacktrace:\n [1] error(::String, ::String)\n   @ Base ./error.jl:42\n [2] top-level\
    \ scope\n   @ /tmp/tmp8txdscog.jl:20\nin expression starting at /tmp/tmp8txdscog.jl:20\n"
  stdout: ''
  timestamp: 1660003961
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 0 || n == 1 \n        then return\
    \ 1\n    else \n        begin \n            let\n                nums = [1..n],\n\
    \                count_ones = sum((nums |> elem) |> elems == 1) for nums in nums\n\
    \            in \n                if count_ones == n \n                    then\
    \ 1\n                else starts_one_ends(n - 1)\n        end\nend\n</code>\n\
    <|/ a tags=recursion,haskell,function |>\n<| c |>\nI like your approach to the\
    \ problem. I wasn't thinking of using elems though.\n<|/ c |>\n<| a dscore=1 tags=recursion,haskell,function\
    \ |>\nMy approach would be to first write a function to find all numbers that\
    \ start with an 1, then apply that to the starting number (n) until you have zero\
    \ results. Something like:\n<code>\nisOnes1 :: Int -> Bool\nisOnes1 n = all (\\\
    (n, _) -> n == 1) [1..n]\n</code>\nThen just use it to find all the numbers that\
    \ start with 1:\n<code>\nonesStart :: Int -> [Int]\nonesStart n = filter (isOnes1\
    \ n) [1..n] \n</code>\n<|/ a |>\n<| c |>\n`isOnes1` is wrong. An element can be\
    \ both a pair of `Int`s and an `Int`.\n<|/ c |>\n<| c |>\nMy bad, I didn't notice\
    \ that was part of the question and didn't notice that `elem` can work for that.\n\
    <|/ c |>\n<| a tags=recursion,haskell,function dscore=1 |>\nIn terms of efficiency,\
    \ the solutions provided by others look good \u2014 although it might not be as\
    \ clear as the recursive one. On the other hand, it's also easier to write and\
    \ maintain.\nMy personal solution is this:\n<code>\nnumStartingAt :: Integer ->\
    \ Integer\nnumStartingAt n = (1:) . scanl (\\_ x -> (x*x) + 1) 0 [1..n]\n</code>\n\
    It builds the list of numbers from 1 to n, and for each element it adds the product\
    \ of its square with the current number minus one (since it's starting at 1).\n\
    <|/ a |>\n<| c |>\n`scanl` is not the fastest function on the planet. It looks\
    \ like it can be optimized to `foldr (\\x s -> x+x) (0,1)`, but I have no idea\
    \ how to do that. I'm sure someone more knowledgeable than me can!\n<|/ c |>\n\
    <| c |>\nI thought that `foldr` was \nusing Test\n\n@testset begin\n\ncandidate\
    \ = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\
    \t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpltp1mopd.jl:7\nin expression starting at /tmp/tmpltp1mopd.jl:7\n"
  stdout: ''
  timestamp: 1660003960
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 1 \n        return 1 # 1\n  \
    \  if n > 1 \n        return starts_one_ends(n / 10) * 10 + (n % 10)\n    end\n\
    \    return 0\nend\n</cell>\n<code language=julia-1.4>\nstarts_one_ends(4)\n</cell>\n\
    <code language=julia-1.4>\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphao3o0q4.jl:13\nin expression starting at\
    \ /tmp/tmphao3o0q4.jl:13\n"
  stdout: ''
  timestamp: 1660003960
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    return sum(i >= 10 for i in take(n, 1:end-n))\n\
    end\n</cell>\n<cell>\nstarts_one_ends(100)\n</cell>\n<text>\nExercise 17: Counting\
    \ the number of digits of the factorial\nA factorial is a product of smaller integers.\
    \ For example, the number \n$!$ has factorial number of $1$ and $!{n+1}$. Write\
    \ a function that computes the \nfactorial number of a positive integer $n$ ($n!$).\
    \ Assume that the factorial of \n$n$ can be written as the product of $n-1$ factorials.\n\
    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing last argument in \"1:\" range expression\
    \ \nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpw_kjtpe7.jl:6\nin expression\
    \ starting at /tmp/tmpw_kjtpe7.jl:6\n"
  stdout: ''
  timestamp: 1660003960
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 1 \n        return 1 \n    else\
    \ \n        return (n - 1) * (starts_one_ends(n / 10) + 1) * (ends_one_starts(n\
    \ % 10)) \nend\n</code>\n<code>\njulia> starts_one_ends(10)\n10\nusing Test\n\n\
    @testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t\
    @test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw83ew1vl.jl:11\nin expression starting at\
    \ /tmp/tmpw83ew1vl.jl:11\n"
  stdout: ''
  timestamp: 1660003960
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    count = 0\n    for x in 1..n\n      \
    \  if ((x-1) == n) || (x == 1)\n            count += 1 \n        end\n    return\
    \ count\nend\n</cell>\n<cell>\n@testset \"Find all numbers with one digit\" begin\n\
    \    testcase(starts_one_ends(1))\n    testcase(starts_one_ends(2))\n    testcase(starts_one_ends(3))\n\
    \    testcase(starts_one_ends(4))\n    testcase(starts_one_ends(5))\n    testcase(starts_one_ends(6))\n\
    \    testcase(starts_one_ends(7))\n    testcase(starts_one_ends(8))\n    testcase(starts_one_ends(9))\n\
    \    testcase(starts_one_ends(10))\nend\n</cell>\n<text>\nThe next function count_n_digit()\
    \ takes integer n (a non-negative integer) and returns the number of non-zero\
    \ digits in n. This function is called by count_n_digits() and count_n_digits()\
    \ to count the number of digits in a non-negative integer n.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpd621l2gf.jl:13\nin expression starting at\
    \ /tmp/tmpd621l2gf.jl:13\n"
  stdout: ''
  timestamp: 1660003960
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n\"\"\"\n    Given a positive integer n, return\
    \ the count of the numbers of n-digit\n    positive integers that start with 1.\n\
    \    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t\
    @test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) ==\
    \ 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpr0l__roo.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpr0l__roo.jl:1\n\
    in expression starting at /tmp/tmpr0l__roo.jl:1\n"
  stdout: ''
  timestamp: 1660003960
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 0 \n        return 1 \n    starts\
    \ = 0 \n    count = (starts, starts + n) \n    for i in count[1...] \n       \
    \ if i == 1 \n            starts = 1 + starts else 0 \n    return count[1...]\
    \ \nends_one_starts(n::Int64)::Int64 \n    if n == 0 \n        return 1 \n   \
    \ count = (n, n) \n    for i in count[1...] \n        if i == 1 \n           \
    \ return 0 \n    return count[1...] \n\"\"\"\n## ```julia\n##  julia> starts_one_ends(1023)\n\
    ##  1023\n##  ```\n## ```\n## 1023\n## ```\n## ```julia\n##  julia> starts_one_ends(1)\n\
    ##  0\n##  ```\n## ```\n## 0\n## ```\n## ```\n## ```\n## function starts_one_ends(n::Int64)::Int64\
    \ \n##     if n == 0 \n##         return 1 \n##     starts = 0 \n##     count\
    \ = (starts, starts + n) \n##     for i in count[1...] \n##         if i == 1\
    \ \n##             starts = 1 + starts else 0 \n##         return count[1...]\
    \ \n##     ends_one_starts(n::Int64)::Int64 \n##         if n == 0 \n##      \
    \       return 1 \n##         count = (n, n) \n##         for i in count[1...]\
    \ \n##             if i == 1 \n##                 return 0 \n##             return\
    \ count[1...] \n## ```\n## ```\n## function starts_one_ends(n::Int64)::Int64 \n\
    ##     if n == 0 \n##         return 1 \n##     starts = 0 \n##     count = (starts,\
    \ starts + n) \n##     for i in count[1...] \n##         if i == 1 \n##      \
    \       starts = 1 + starts else 0 \n##         return count[1...] \n##     ends_one_starts(n::Int64)::Int64\
    \ \n##         if n == 0 \n##             return 1 \n##         count = (n, n)\
    \ \n##         for i in count[1...] \n##             if i == 1 \n##          \
    \       return 0 \n##             return count[1...] \n## ```\n## ```julia\n##\
    \  julia> starts_one_ends(1023)\n##  1023\n##  ```\n## ```\n## 1023\n## ```\n\
    ## ```\n##  julia> starts_\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwirrc9x4.jl:1\nin expression starting at /tmp/tmpwirrc9x4.jl:1\n"
  stdout: ''
  timestamp: 1660003960
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 0 || n > 1 \n        error(\"\
    starts_one_ends requires n to be a non-negative integer\")\n    elseif n == 0\n\
    \        0\n    elseif n == 1\n        1\n    else\n        repeat(n - 1) do \n\
    \            i = n + 1 - digits(n)\n            starts_one_ends(i)\n        end\n\
    \    end\nend\n</cell>\n<text>\nExercise 4\nWrite a function that takes two integers\
    \ n and m and returns the number of positive integers less than m which satisfy\
    \ the following inequality:\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphhrk6943.jl:19\nin expression starting at\
    \ /tmp/tmphhrk6943.jl:19\n"
  stdout: ''
  timestamp: 1660003960
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 0 \n        return 0 \n    else\
    \ \n        return starts_one_ends(n/10) + 1 + (n % 10 == 1) \nend\n</cell>\n\
    <code language=julia-1.4>\n\"\"\"\n    Given a positive integer n, return the\
    \ count of the numbers of n-digit\n    positive integers that start or end with\
    \ 0.\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3vycms_4.jl:11\nin expression starting at\
    \ /tmp/tmp3vycms_4.jl:11\n"
  stdout: ''
  timestamp: 1660003960
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    return sum(isone(i) for i in 1..n)\n\
    using Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpygucrn0m.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpygucrn0m.jl:1\n\
    in expression starting at /tmp/tmpygucrn0m.jl:1\n"
  stdout: ''
  timestamp: 1660003960
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    count = 0\n    for x = n..999 \n    \
    \    if x % 10 == 1 \n            count += 1 \n        end\n    end\n    return\
    \ count\nend\n\"\"\"\n    Write a Julia function that accepts a positive integer\
    \ n and computes\n    the number of positive integers that start or end with 1,\
    \ up to and including\n    n.\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\
    \t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: cannot document the following expression:\n\nusing Test\n\
    \nStacktrace:\n [1] error(::String, ::String)\n   @ Base ./error.jl:42\n [2] top-level\
    \ scope\n   @ /tmp/tmpvlr6yzyt.jl:14\nin expression starting at /tmp/tmpvlr6yzyt.jl:14\n"
  stdout: ''
  timestamp: 1660003961
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 1 \n        then return 1 \n\
    \        else \n            count = 1\n            while (n % 10) == 1\n     \
    \           count += starts_one_ends(n / 10)\n                n /= 10\n      \
    \      return count + starts_one_ends(n) \n    end\n</code>\n<|/ a |>\n<| a tags=algorithm,julia\
    \ |>\nThis one is based on a recursive function and I think it is much more efficient\
    \ than the others posted so far:\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\
    \t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp2x69pq3e.jl:7\nin expression starting at /tmp/tmp2x69pq3e.jl:7\n"
  stdout: ''
  timestamp: 1660003960
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    n <= 0 || n >= 1e010 || n % 1 == 0\n\
    end\n\"\"\"\n    Given a positive integer n, return the count of the numbers of\
    \ n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nusing\
    \ Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: cannot document the following expression:\n\nusing Test\n\
    \nStacktrace:\n [1] error(::String, ::String)\n   @ Base ./error.jl:42\n [2] top-level\
    \ scope\n   @ /tmp/tmprgaq0qmj.jl:8\nin expression starting at /tmp/tmprgaq0qmj.jl:8\n"
  stdout: ''
  timestamp: 1660003961
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 100 return n\n    let x = n//10\n\
    \    if x == 0 return 0\n    if n % (x/10) == 0 then return ends_one_ends(n-x*10)\
    \ else return starts_one_ends(x-1)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\
    \t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpbwsw37_t.jl:9\nin expression starting at /tmp/tmpbwsw37_t.jl:9\n"
  stdout: ''
  timestamp: 1660003960
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    for i in (1 to n)\n        if (n%i ==\
    \ 0 || n%(i-1) == 0)\n            i += 1\n        else\n            return i\n\
    \    return 0\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\n    counts_n_digits(n::Int64)::Int64\n\
    Given a positive integer n, return the count of the numbers of n-digit\n    positive\
    \ integers that start or end with 1.\n\"\"\"\nusing Test\n\n@testset begin\n\n\
    candidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6degurj0.jl:6\nin expression starting at /tmp/tmp6degurj0.jl:6\n"
  stdout: ''
  timestamp: 1660003960
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    sum(map((==1).(ndigits(n)), (1:n)))\n\
    end\n\"\"\"\n    Find the number of positive integers that start or end with 1\
    \ given some positive integer n.\n    For example, given a number n, return count\
    \ of the number of positive integers that start or end with 1.\n    \"\"\"\nusing\
    \ Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"==\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpn3tul78r.jl:6\nin expression starting at /tmp/tmpn3tul78r.jl:6\n"
  stdout: ''
  timestamp: 1660003960
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n==1\n        return n\n    else \n\
    \        return starts_one_ends(n-1) + ends_one_starts(n-1)\nusing Test\n\n@testset\
    \ begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmphy73q3cq.jl:6 requires\
    \ end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmphy73q3cq.jl:1\nin expression\
    \ starting at /tmp/tmphy73q3cq.jl:1\n"
  stdout: ''
  timestamp: 1660003960
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    count = 0\n    \n    # Fill the array\n\
    \    arr = [Int64(1)]\n    for i in 1:n\n        push!(arr, arr[i]+1)\n    end\n\
    \    \n    # Count the number of 1 at start and end\n    for i in 1:n-1\n    \
    \    if arr[i] != arr[i+1]\n            count += 1\n        end\n    end\n   \
    \ \n    # Return it\n    return count\nend\n</cell>\n<code language=julia-1.6>\n\
    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n\
    \    positive integers that end with 1.\n    \"\"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpphlzz2r9.jl:24\nin expression starting at\
    \ /tmp/tmpphlzz2r9.jl:24\n"
  stdout: ''
  timestamp: 1660003960
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    x <- 0\n    while (n>0)\n        x <-\
    \ x + 1\n        n <- n - x \n    return x\nends_one_starts(n::Int64)::Int64 \n\
    \    x <- 0\n    while (n>0)\n        x <- x + 1\n        n <- n - x\n    return\
    \ x\nends_one_ends(n::Int64)::Int64\n    n <- n\n    x  <- 0\n    while (n>0)\n\
    \        x <- x + 1\n        n <- n - x\n    return x\nends_one_ends(n::Int64)::Int64\n\
    \    n <- n\n    x  <- 0\n    while (n>0)\n        x <- x + 1\n        n <- n\
    \ - x\n    return x\nends_one_starts(n::Int64)::Int64\n    n <- n\n    x  <- 0\n\
    \    while (n>0)\n        x <- x + 1\n        n <- n - x\n    return x\nends_one_starts(n::Int64)::Int64\n\
    \    n <- n\n    x  <- 0\n    while (n>0)\n        x <- x + 1\n        n <- n\
    \ - x\n    return x\nends_one_starts(n::Int64)::Int64\n    n <- n\n    x  <- 0\n\
    \    while (n>0)\n        x <- x + 1\n        n <- n - x\n    return x\nends_one_starts(n::Int64)::Int64\n\
    \    n <- n\n    x  <- 0\n    while (n>0)\n        x <- x + 1\n        n <- n\
    \ - x\n    return x\nends_one_starts(n::Int64)::Int64\n    n <- n\n    x  <- 0\n\
    \    while (n>0)\n        x <- x + 1\n        n <- n - x\n    return x\nends_one_starts(n::Int64)::Int64\n\
    \    n <- n\n    x  <- 0\n    while (n>0)\n        x <- x + 1\n        n <- n\
    \ - x\n    return x\nends_one_starts(n::Int64)::Int64\n    n <- n\n    x  <- 0\n\
    \    while (n>0)\n        x <- x + 1\n        n <- n - x\n    return x\nends_one_starts(n::Int64)::Int64\n\
    \    n <- n\n    x  <- 0\n    while (n>0)\n        x <- x + 1\n        n <- n\
    \ - x\n    return x\nends_one_starts(n::Int64)::Int64\n    n <- n\n    x\nusing\
    \ Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"while\" at /tmp/tmp9sik8yff.jl:83\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp9sik8yff.jl:1\n\
    in expression starting at /tmp/tmp9sik8yff.jl:1\n"
  stdout: ''
  timestamp: 1660003960
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    match n with\n    | 0 -> 0\n    | i when\
    \ i >= 10 -> 0\n    | i -> 1 + starts_one_ends(i - 1)\nend\n</cell>\n<code language=julia-1.5>\n\
    println(starts_one_ends(0))\nprintln(starts_one_ends(1))\nprintln(starts_one_ends(2))\n\
    println(starts_one_ends(3))\nprintln(starts_one_ends(10))\nprintln(starts_one_ends(100))\n\
    println(starts_one_ends(1000))\nprintln(starts_one_ends(10000))\nprintln(starts_one_ends(100000))\n\
    println(starts_one_ends(1000000))\nprintln(starts_one_ends(10000000))\nprintln(starts_one_ends(100000000))\n\
    </cell>\n<text>\nExercise\nImplement a function is_prime(n::Int64)::Bool that\
    \ returns True if n is a prime and False otherwise. Hint: There are lots of ways\
    \ to do this.\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t\
    @test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) ==\
    \ 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"function\" at /tmp/tmpca81705m.jl:5 expected\
    \ \"end\", got \"n\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpca81705m.jl:6\n\
    in expression starting at /tmp/tmpca81705m.jl:6\n"
  stdout: ''
  timestamp: 1660003960
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 1\n        return 2\n    else\
    \ if n == 2\n        return 3\n    else\n        return starts_one_ends(n-1) +\
    \ ends_one_ends(n-1)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\
    \t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpztk3iogy.jl:8\nin expression starting at /tmp/tmpztk3iogy.jl:8\n"
  stdout: ''
  timestamp: 1660003961
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    count = 0\n    while n > 0\n        if\
    \ n % 10 == 1\n            count += 1\n        end\n        n = n / 10\n    end\n\
    \    return count\nend\n</cell>\n<code language=julia-0.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpy4hdpm_n.jl:15\nin expression starting at\
    \ /tmp/tmpy4hdpm_n.jl:15\n"
  stdout: ''
  timestamp: 1660003962
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    \"\"\"\n    Given a positive integer\
    \ n, return the count of the numbers of n-digit\n    positive integers that start\
    \ or end with 1.\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpngs68mmr.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpngs68mmr.jl:1\n\
    in expression starting at /tmp/tmpngs68mmr.jl:1\n"
  stdout: ''
  timestamp: 1660003959
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n\"\"\"\n    Given a positive integer n, return\
    \ the count of the numbers of n-digit\n    positive integers that start or end\
    \ with 1.\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp9g6ys4mr.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp9g6ys4mr.jl:1\n\
    in expression starting at /tmp/tmp9g6ys4mr.jl:1\n"
  stdout: ''
  timestamp: 1660003962
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n\tif n==0 then return 0 else starts_one_ends(n-1)\n\
    \tif n==1 then return 1 else starts_one_ends(n-1)+n-1\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpey1tho8o.jl:6\nin expression starting at /tmp/tmpey1tho8o.jl:6\n"
  stdout: ''
  timestamp: 1660003962
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n\"\"\"\n    The number of 1s in the number\
    \ n.\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp7sf70hgz.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp7sf70hgz.jl:1\n\
    in expression starting at /tmp/tmp7sf70hgz.jl:1\n"
  stdout: ''
  timestamp: 1660003962
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    \"\"\"\n    Given a positive integer\
    \ n, return the count of the numbers of n-digit\n    positive integers that start\
    \ or end with 1.\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpngs68mmr.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpngs68mmr.jl:1\n\
    in expression starting at /tmp/tmpngs68mmr.jl:1\n"
  stdout: ''
  timestamp: 1660003959
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 0\n    then return 0\n    else\
    \ if n == 1\n    then return 1\n    else if starts_one_ends(n-1) == 0\n    then\
    \ return 1\n    else starts_one_ends(n-1)\nend\n</cell>\n<code language=julia-1.1>\n\
    \"\"\"\n    count_nums! counts the number of nums from 1 to n\n    (or from 2\
    \ to n-1 if n is even)\n    INPUT:\n        n :: a positive integer\n    OUTPUT:\n\
    \        count_nums! returns the count of nums from 1 to n (or from 2 to n-1 if\
    \ n is even)\n\"\"\"\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpejva7g8e.jl:7\nin expression starting at /tmp/tmpejva7g8e.jl:7\n"
  stdout: ''
  timestamp: 1660003962
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    # Replace this with the solution\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_\nusing Test\n\
    \n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\
    \t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpa57n7fyj.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpa57n7fyj.jl:1\n\
    in expression starting at /tmp/tmpa57n7fyj.jl:1\n"
  stdout: ''
  timestamp: 1660003962
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n\"\"\"\n    Given a positive integer n, return\
    \ the count of the numbers of n-digit\n    positive integers that start or end\
    \ with 1.\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp9g6ys4mr.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp9g6ys4mr.jl:1\n\
    in expression starting at /tmp/tmp9g6ys4mr.jl:1\n"
  stdout: ''
  timestamp: 1660003962
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    sum = 0\n    while n >= 10 \n       \
    \ sum += (n%10).==1\n        n = floor(n / 10)\n    return sum\nend\n</cell>\n\
    <code language=julia-1.0>\nstarts_one_ends(1001)\n</cell>\n<text>\nThe sum of\
    \ the first ten natural numbers is\nusing Test\n\n@testset begin\n\ncandidate\
    \ = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\
    \t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpb5u671wd.jl:12\nin expression starting at\
    \ /tmp/tmpb5u671wd.jl:12\n"
  stdout: ''
  timestamp: 1660003962
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n\tif n == 1\n\t\treturn 1\n\telse\n\t\treturn\
    \ starts_one_ends(n - 1) * 10 + ends_one_starts(n)\nusing Test\n\n@testset begin\n\
    \ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmp4hnn5wpa.jl:6 requires\
    \ end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp4hnn5wpa.jl:1\nin expression\
    \ starting at /tmp/tmp4hnn5wpa.jl:1\n"
  stdout: ''
  timestamp: 1660003962
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n<10 return 0 \n    return sum(starts_one_ends(n//10))+1\
    \ if n%10==1 else 0\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"if\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp58lb9vyq.jl:7\nin expression starting at /tmp/tmp58lb9vyq.jl:7\n"
  stdout: ''
  timestamp: 1660003962
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 1\n        return n\n    \n  \
    \  if n % 2 == 0\n        return starts_one_ends(n / 2)\n    \n    return starts_one_ends(n\
    \ / 2) + 1\nend\n</cell>\n<code language=julia-1.5>\n# Check your answer using\
    \ @code_native cell\n@code_native @show starts_one_ends(10)\n@code_native @show\
    \ starts_one_ends(20)\n@code_native @show starts_one_ends(30)\n@code_native @show\
    \ starts_one_ends(60)\n@code_native @show starts_one_ends(100)\n@code_native @show\
    \ starts_one_ends(1000)\n@code_native @show starts_one_ends(10000)\n@code_native\
    \ @show starts_one_ends(100000)\n@code_native @show starts_one_ends(1000000)\n\
    @code_native @show starts_one_ends(10000000)\n</cell>\n<text>\n12. How many numbers\
    \ between 1 and 1,000,000 inclusive are divisible by 3?\nusing Test\n\n@testset\
    \ begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpc12nzrqj.jl:14\nin expression starting at\
    \ /tmp/tmpc12nzrqj.jl:14\n"
  stdout: ''
  timestamp: 1660003962
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 0 \n        0\n    elseif n <\
    \ 0 \n        -1\n    elseif n < 10 \n        1\n    elseif n < 100\n        0\n\
    \    elseif n < 1000\n        0\n    elseif n < 10000\n        0\n    elseif n\
    \ < 100000\n        0\n    elseif n < 1000000\n        0\n    elseif n < 10000000\
    \ \n        0\n    elseif n < 100000000\n        0\n    elseif n < 1000000000\n\
    \        0\n    elseif n < 10000000000\n        0\n    elseif n < 100000000000\
    \ \n        0\n    elseif n < 1000000000000\n        0\n    elseif n < 10000000000000\n\
    \        0\n    elseif n < 100000000000000\n        0\n    elseif n < 1000000000000000\n\
    \        0\n    elseif n < 10000000000000000\n        0\n    elseif n < 100000000000000000\n\
    \        0\n    elseif n < 1000000000000000000\n        0\n    elseif n < 10000000000000000000\n\
    \        0\n    elseif n < 100000000000000000000\n        0\n    elseif n < 1000000000000000000000\n\
    \        0\n    elseif n < 10000000000000000000000\n        0\n    elseif n <\
    \ 100000000000000000000000\n        0\n    elseif n < 1000000000000000000000000\n\
    \        0\n    elseif n < 10000000000000000000000000\n        0\n    elseif n\
    \ < 100000000000000000000000000\n        0\n    elseif n < 1000000000000000000000000000\n\
    \        0\n    elseif n < 10000000000000000000000000000\n        0\n    elseif\
    \ n < 100000000000000000000000000000\n        0\n    elseif n < 1000000000000000000000000000000\n\
    \        0\n    elseif n < 10000000000000000000000000000000\n        0\n    elseif\
    \ n < 100000000000000000000000000000000\n        0\n    elseif n < 1000000000000000000000000000000000\n\
    \        0\n    elseif n < 10000000000000000000000000000000000\n        0\n  \
    \  elseif n < 100000000000000000000000000000000000\n        0\n    elseif n <\
    \ 1000000000000000000000000000000000000\n        0\n    elseif n < 10000000000000000000000000000000000000\n\
    \        0\n    elseif n < 100000000000000000000000000000000000000\n        0\n\
    \    elseif n < 1000000000000000000000000000000000000000\n        0\n    elseif\
    \ n < 10000000000000000000000000000000000000000\n        0\n    elseif n < 100000000000000000000000000000000000000000\n\
    \        0\n    elseif n < 1000000000000000000000000000000000000000000\n     \
    \   0\n    elseif n < 100000000000000000000000000000000000000000\n        0\n\
    \    elseif n < 1000000000000000000000000000000000000000000\n        0\n    elseif\
    \ n < 10000000000000000000000000000000000000000000\n        0\n    elseif n <\
    \ 100000000000000000000000000000000000000000000\n        0\n    elseif n < 1000000000000000000000000000000000000000000000\n\
    \        0\n    elseif n < 10000000000000000000000000000000000000000000000\n \
    \       0\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6ftefw5u.jl:1\nin expression starting at /tmp/tmp6ftefw5u.jl:1\n"
  stdout: ''
  timestamp: 1660003962
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 0 then 0 else 1 \n    else starts_one_ends(n-1)\
    \ + n div div(n)\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"0\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpi6bigmka.jl:6\nin expression starting at /tmp/tmpi6bigmka.jl:6\n"
  stdout: ''
  timestamp: 1660003962
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n <= 0 then 0 else n + starts_one_ends(floor(n/2))\
    \ - 1 end \nend\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"0\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpgdo2y6la.jl:6\nin expression starting at /tmp/tmpgdo2y6la.jl:6\n"
  stdout: ''
  timestamp: 1660003962
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 0 \n        error(\"n must be\
    \ positive\")\n    else if n == 0 \n        error(\"n must be 1 or more\")\n \
    \   else if n == 1 \n        return 1\n    else \n        return starts_one_ends(n-1)\
    \ + ends_one_starts(n-1)\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfiz656vn.jl:8\nin expression starting at /tmp/tmpfiz656vn.jl:8\n"
  stdout: ''
  timestamp: 1660003962
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 0 \n        return 0 \n    if\
    \ n == 1 \n        return 1 \n    if n == 2 \n        return 1 \n    if n < 10\
    \ \n        return starts_one_ends(n-1) + starts_one_ends(n-2) \n    return starts_one_ends(n-1)\
    \ + starts_one_ends(n-2) + starts_one_ends(n-3) \nend\n</cell>\n<code language=julia-1.0>\n\
    using Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptzmclt_r.jl:16\nin expression starting at\
    \ /tmp/tmptzmclt_r.jl:16\n"
  stdout: ''
  timestamp: 1660003962
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n >= 1\n        count_1 = 0\n    \
    \    for i in 1 : n \n            if i == 1\n                count_1 += 1\n  \
    \          elseif i == n\n                count_1 += n \n            else\n  \
    \              count_1 += i + 1\n        end\n    end\n    return count_1\nend\n\
    </cell>\n<code language=julia-1.3>\n# Your starts_one_ends function\n@code_warntype\
    \ starts_one_ends(1000)\n</cell>\n<code language=julia-1.3>\n# Solution\nusing\
    \ Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpe4hi2apo.jl:19\nin expression starting at\
    \ /tmp/tmpe4hi2apo.jl:19\n"
  stdout: ''
  timestamp: 1660003962
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 10 \n        then 1\n        elseif\
    \ n < 100 \n            then n / 10 + starts_one_ends(n / 10)\n            else\
    \ n / 10 + starts_one_ends(n / 10) + 1\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"1\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpsqkh8_by.jl:7\nin expression starting at /tmp/tmpsqkh8_by.jl:7\n"
  stdout: ''
  timestamp: 1660003962
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n<=0\n        error(\"starts_one_ends:\
    \ n is negative\")\n    else if n==1\n        return 2\n    else\n        count(n)\
    \ - count(n-1) \n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpeufrtyps.jl:8\nin expression starting at /tmp/tmpeufrtyps.jl:8\n"
  stdout: ''
  timestamp: 1660003962
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    \n    if n<1\n        return -1\n   \
    \ \n    count::Int64 = 1\n    \n    for i::Int64 in 1..n-1\n        if i==1 ||\
    \ i==n-1\n            count += 1\n        else\n            count += starts_one_ends(n-1)\n\
    \        end\n    end\n    \n    return count\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp4o0qu2_b.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp4o0qu2_b.jl:1\n\
    in expression starting at /tmp/tmp4o0qu2_b.jl:1\n"
  stdout: ''
  timestamp: 1660003962
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 1 \n        0 \n    else \n  \
    \      starts_one_ends(n-1) `seq` ends_one_starts(n-1) `seq` ends_one_starts(n)\n\
    end\n</cell>\n<code language=julia-1.5>\n@time starts_one_ends(10^5);\n</cell>\n\
    <text>\nFor another example of counting consecutive integers, let's count all\
    \ the numbers where the digits are the same or where the digits are different.\n\
    using Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmppo6ujdpr.jl:6 expected \"end\"\
    , got \"`\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmppo6ujdpr.jl:9\nin\
    \ expression starting at /tmp/tmppo6ujdpr.jl:9\n"
  stdout: ''
  timestamp: 1660003963
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    for i in 2...n \n        if n%i == 0\
    \ \n            return 1 + (n//i) * starts_one_ends(i-1) + n // i\n        end\n\
    \    end\n    return 0\nend\n</cell>\n<code language=julia-1.6>\nusing Test\n\n\
    @testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t\
    @test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"...\" expression outside call around /tmp/tmp65xq79wt.jl:6\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp65xq79wt.jl:1\nin expression starting\
    \ at /tmp/tmp65xq79wt.jl:1\n"
  stdout: ''
  timestamp: 1660003963
- exit_code: -1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 1 \n        return 1 \n    else\
    \ \n        return starts_one_ends(n-1) + starts_one_ends(n-2) + starts_one_ends(n-3)\
    \ + starts_one_ends(n-4) + starts_one_ends(n-5) + starts_one_ends(n-6) + starts_one_ends(n-7)\
    \ + starts_one_ends(n-8) + starts_one_ends(n-9) + starts_one_ends(n-10)\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660003967
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    \"\"\"\n    Given a positive integer\
    \ n, return the count of the numbers of n-digit\n    positive integers that start\
    \ or end with 1.\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpngs68mmr.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpngs68mmr.jl:1\n\
    in expression starting at /tmp/tmpngs68mmr.jl:1\n"
  stdout: ''
  timestamp: 1660003959
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    sum(k for k in collect(1:n) \n      \
    \  if k % 10 ==1 && k %% 100!=1 && !(k %% 1000)==1 && !(k %% 10000)==1 )\nend\n\
    </cell>\n<code language=julia-1.6>\nstarts_one_ends(10)\n</cell>\n<text>\nTo find\
    \ the first n positive integers that end with 1, where 1 < n \u2264 100.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"%\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw9dvf9ej.jl:7\nin expression starting at /tmp/tmpw9dvf9ej.jl:7\n"
  stdout: ''
  timestamp: 1660003963
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    # Write your code in Python 3 style\n\
    \    if n > 0 \n        then count_start = count_end = 0\n        while n > 0\n\
    \            count_start += 1\n            if n%10 == 1 \n                then\
    \ count_end += 1\n            n = n/10\n        end\n        return count_end\n\
    \    else\n        return 0\n    end\nend\n</cell>\n<code language=julia-1.4>\n\
    count_starts_ends(1023)\n</cell>\n<text>\nExercise 12. Find first occurence of\
    \ n in a list.\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"count_start\"\nStacktrace:\n [1]\
    \ top-level scope\n   @ /tmp/tmpw4uth_ll.jl:8\nin expression starting at /tmp/tmpw4uth_ll.jl:8\n"
  stdout: ''
  timestamp: 1660003964
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    \n    if n < 10 \n        return n\n\
    \    \n    i = 2\n    \n    while i * i <= n \n        if n % i == 0 \n      \
    \      i := i + 1\n            if i == 10 \n                i := 2\n        else\
    \ \n            i := 2\n    \n    return i \nend\nusing Test\n\n@testset begin\n\
    \ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgony44s2.jl:1\nin expression starting at /tmp/tmpgony44s2.jl:1\n"
  stdout: ''
  timestamp: 1660003964
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 0\n        0\n    elseif n ==\
    \ 1\n        0\n    elseif n % 2 == 1\n        starts_one_ends(n/2)\n    else\n\
    \        starts_one_ends(n-1) + starts_one_ends(n/2)\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpcsej485r.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpcsej485r.jl:1\n\
    in expression starting at /tmp/tmpcsej485r.jl:1\n"
  stdout: ''
  timestamp: 1660003964
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    \"\"\"\n    Given a positive integer\
    \ n, return the count of the numbers of n-digit\n    positive integers that start\
    \ or end with 1.\n    \"\"\"\n    if n < 10 \n        return n \n    else:\n \
    \       return counts_ends_with(n, 10)\n    ends_with_1(n::Int64)::Int64 \n  \
    \  \"\"\"\n    Given a positive integer n, return the count of the numbers of\
    \ n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n    return\
    \ counts_ends_with(n, 10)\nends_with_1(n::Int64)::Int64 \n    \"\"\"\n    Given\
    \ a positive integer n, return the count of the numbers of n-digit\n    positive\
    \ integers that start or end with 1.\n    \"\"\"\n    if n < 10 \n        return\
    \ n \n    else:\n        return counts_ends_with(n, 10)\n    ends_with_1(n::Int64)::Int64\
    \ \n    \"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n  \
    \  if n < 10 \n        return n \n    else:\n        return counts_ends_with(n,\
    \ 10)\n    ends_with_1(n::Int64)::Int64 \n    \"\"\"\n    Given a positive integer\
    \ n, return the count of the numbers of n-digit\n    positive integers that start\
    \ or end with 1.\n    \"\"\"\n    if n < 10 \n        return n \n    else:\n \
    \       return counts_ends_with(n, 10)\n    ends_with_1(n::Int64)::Int64 \n  \
    \  \"\"\"\n    Given a positive integer n, return the count of the numbers of\
    \ n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n    if\
    \ n < 10 \n        return n \n    else:\n        return counts_ends_with(n, 10)\n\
    \    ends_with_1(n::Int64)::Int64 \n    \"\"\"\n    Given a positive integer n,\
    \ return the count of the numbers of n-digit\n    positive integers that start\
    \ or end with 1.\n    \"\"\"\n    if n < 10 \n        return n \n    else:\n \
    \       return counts_ends_with(n, 10)\n    ends_with_1(n::Int64)::Int64 \n  \
    \  \"\"\"\n    Given a positive integer n, return the count of the numbers of\
    \ n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n    if\
    \ n < 10 \n        return n \n    else:\n        return counts_ends_with(n, 10)\n\
    \    ends_with_1(n::Int64)::Int64 \n    \"\"\"\n    Given a positive integer n,\
    \ return the count of the numbers of n-digit\n    positive integers that start\
    \ or end with 1.\n    \"\"\"\n    if n < 10 \n        return n \n    else:\n \
    \       return counts_ends_with(n, 10)\n    ends_with_1(n::Int64)::Int64 \n  \
    \  \"\"\"\n    Given a positive integer n, return the \nusing Test\n\n@testset\
    \ begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: newline not allowed after \":\" used for quoting\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpx0merc_u.jl:13\nin expression\
    \ starting at /tmp/tmpx0merc_u.jl:13\n"
  stdout: ''
  timestamp: 1660003964
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    s = div(n, 10^n)\n    if s > 0 {\n  \
    \      s += 1\n    }\n    \n    \n    return s\nend\n</cell>\n<code language=julia-1.6>\n\
    @code_native native begin\n    using Random\nusing Test\n\n@testset begin\n\n\
    candidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: space before \"{\" not allowed in \"0 {\" at\
    \ /tmp/tmpncnfhiaq.jl:7\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpncnfhiaq.jl:7\n\
    in expression starting at /tmp/tmpncnfhiaq.jl:7\n"
  stdout: ''
  timestamp: 1660003964
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    count = 0\n    for d in 1:10\n      \
    \  if n%d == 0\n            count += 1\n        end\n    end\n    return count\n\
    end\n\"\"\"\n    The number of positive integers that start with 0\n    \"\"\"\
    \nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: cannot document the following expression:\n\nusing Test\n\
    \nStacktrace:\n [1] error(::String, ::String)\n   @ Base ./error.jl:42\n [2] top-level\
    \ scope\n   @ /tmp/tmpun4za7gw.jl:14\nin expression starting at /tmp/tmpun4za7gw.jl:14\n"
  stdout: ''
  timestamp: 1660003964
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 2 then return 1 else return (starts_one_ends(n-1)\
    \ + starts_one_ends(n-2))\nend\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmplri7ow4j.jl:6\nin expression starting at /tmp/tmplri7ow4j.jl:6\n"
  stdout: ''
  timestamp: 1660003964
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n  if n<10 then return n else return n==1\
    \ ? 1 : count_nth_digits(n::Int64) end\nusing Test\n\n@testset begin\n\ncandidate\
    \ = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\
    \t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpwjv17uup.jl:6\nin expression starting at /tmp/tmpwjv17uup.jl:6\n"
  stdout: ''
  timestamp: 1660003964
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 0\n        0\n    else\n    \
    \    1 + starts_one_ends(n-1)\nend\n\"\"\"\n    Given a positive integer n, return\
    \ the count of the numbers of n-digit\n    positive integers that start or end\
    \ with 1 and are less than n.\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\
    \t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2kwazw98.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2kwazw98.jl:1\n\
    in expression starting at /tmp/tmp2kwazw98.jl:1\n"
  stdout: ''
  timestamp: 1660003964
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n <= 0\n        return 0\n    start\
    \ = 1\n    while n > 0\n        if n mod 10 == 0\n            start = start +\
    \ 1\n        end = 1\n        while n > 0\n            if n mod 10 == 1 and n\
    \ mod 10 != start\n                end = end + 1\n            n = n div 10\n \
    \       end\n        start = start + 1\n    end\n    return start\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"10\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpt2i4op5y.jl:10\nin expression starting at /tmp/tmpt2i4op5y.jl:10\n"
  stdout: ''
  timestamp: 1660003964
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if (n == 0)\n    then 0\n    else n %\
    \ 10 == 1 ? 1 + starts_one_ends(n / 10) : (n % 10 >= 2 ? (1 + starts_one_ends(n\
    \ / 10)) : 0)\n    end\nend\n</code>\n(Note that a similar function could be written\
    \ using mod operations and recursion, which would be a bit more efficient but\
    \ also not as terse as this.)\n<|/ a tags=recursion,julia,performance |>\n<| a\
    \ dscore=1 tags=recursion,julia,performance |>\nI like the solutions given by\
    \ and that propose memoization, which they also propose to solve the problem.\
    \ While they do that correctly, they are incomplete. For example, they fail to\
    \ recognize the case of n==0.\nHere is my solution that takes the recursive approach\
    \ and solves the problem by memoizing the result.\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"0\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpjik2j4kt.jl:7\nin expression starting at /tmp/tmpjik2j4kt.jl:7\n"
  stdout: ''
  timestamp: 1660003964
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 1\n        1\n    else\n    \
    \    sum( x -> starts_one_ends(n / x), 1 ) +\n        (n % n == 0)*starts_one_ends(n\
    \ / n)\nend\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t\
    @test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) ==\
    \ 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp7ctdp65w.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp7ctdp65w.jl:1\n\
    in expression starting at /tmp/tmp7ctdp65w.jl:1\n"
  stdout: ''
  timestamp: 1660003964
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n <= 0 \n    then 0\n    else 1\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t\
    @test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) ==\
    \ 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"0\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpolavyaa_.jl:7\nin expression starting at /tmp/tmpolavyaa_.jl:7\n"
  stdout: ''
  timestamp: 1660003964
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    \n    \"\"\"\n    Count the number of\
    \ integers starting or ending with 1\n    \"\"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp0qjyxnp8.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp0qjyxnp8.jl:1\n\
    in expression starting at /tmp/tmp0qjyxnp8.jl:1\n"
  stdout: ''
  timestamp: 1660003964
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 1\n    else n * factorial(n-1)\n\
    end\n</cell>\n<code language=julia-1.0>\nstarts_one_ends(8)\n</cell>\n<text>\n\
    Problem 3: Write a function that will take as input a string of letters and return\
    \ the string with all but the last letter of each word.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpsoigei3g.jl:9\nin expression starting at /tmp/tmpsoigei3g.jl:9\n"
  stdout: ''
  timestamp: 1660003964
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 1 \n        return 1 # 1 means\
    \ only starting 1\n    else \n        return (n - 1)*starts_one_ends(n-1)\n</code>\n\
    Then I used this function to count the numbers that start with 1:\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmgn8yytx.jl:10\nin expression starting at\
    \ /tmp/tmpmgn8yytx.jl:10\n"
  stdout: ''
  timestamp: 1660003964
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n==1 then return 1 else 0\n    else\
    \ if n>1 then starts_one_ends(n-1) + starts_one_ends(n-2) + \n        starts_one_ends(n-3)\n\
    \        else 0\n    end \nend\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpum9h567z.jl:6\nin expression starting at /tmp/tmpum9h567z.jl:6\n"
  stdout: ''
  timestamp: 1660003964
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 0 then 0 else starts_one_ends(n\
    \ // 10) + (n % 10 == 1)\nend\n</cell>\n<code language=julia-1.5>\njulia> starts_one_ends(10)\n\
    30\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\
    \t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"0\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpa5n9wnmj.jl:6\nin expression starting at /tmp/tmpa5n9wnmj.jl:6\n"
  stdout: ''
  timestamp: 1660003964
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    count := 0\n    for x in 1:n\n      \
    \  if x==1 \n            count := count + 1\n        elseif x==n \n          \
    \  count := count + 0\n        end if\n    end for\n    return count\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"for\" at /tmp/tmpd0i6nszh.jl:7 expected \"\
    end\", got \"if\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpd0i6nszh.jl:12\n\
    in expression starting at /tmp/tmpd0i6nszh.jl:12\n"
  stdout: ''
  timestamp: 1660003964
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 0 then 1 else 0\n    if n ==\
    \ 1 then 1\n    else if n % 10 == 1 then (starts_one_ends(n / 10) + 1) \n    else\
    \ starts_one_ends(n / 10)\n    end\nend\n</code>\n<|/ a dscore=0 tags=count,julia\
    \ |>\n<| c |>\nNice, but you missed the case where the input is negative.\n<|/\
    \ c |>\n<| c |>\nthanks. i updated my answer to handle the negative input.\n<|/\
    \ c |>\n<| c |>\nIn Julia the preferred way is to use `+` and `-` instead of `+=`\
    \ and `-=`\n<|/ c |>\n<| c |>\nGood suggestion, thanks\n<|/ c |>\n<| a tags=count,julia\
    \ dscore=0 |>\nHow about this:\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\
    \t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"1\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpdrw8ou9u.jl:6\nin expression starting at /tmp/tmpdrw8ou9u.jl:6\n"
  stdout: ''
  timestamp: 1660003965
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    count = 0\n    while n != 1 do\n    \
    \    n /= 10\n        count += 1\n    end\n    return count\nend\n</cell>\n<code\
    \ language=julia-1.3>\nstarts_one_ends(5)\n</cell>\n<text>\nExercise 4: Write\
    \ a function that takes a string as input and returns the number of times \"1\"\
    \ appears among the digits.\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpfsihs_kt.jl:7\nin expression starting at /tmp/tmpfsihs_kt.jl:7\n"
  stdout: ''
  timestamp: 1660003965
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 1\n        0\n    else\n     \
    \   floor(log2(n))+1\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\
    \t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpoe9hiwf3.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpoe9hiwf3.jl:18\n  Expression: candidate(2)\
    \ == 18\n   Evaluated: 2 == 18\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpoe9hiwf3.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpoe9hiwf3.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpoe9hiwf3.jl:19\n  Expression: candidate(3) == 180\n   Evaluated:\
    \ 2 == 180\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpoe9hiwf3.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpoe9hiwf3.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpoe9hiwf3.jl:20\n  Expression: candidate(4) == 1800\n   Evaluated:\
    \ 3 == 1800\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpoe9hiwf3.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpoe9hiwf3.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpoe9hiwf3.jl:21\n  Expression: candidate(5) == 18000\n   Evaluated:\
    \ 3 == 18000\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpoe9hiwf3.jl:21 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpoe9hiwf3.jl:16\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     4      5\n"
  timestamp: 1660003966
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    # count starts and ends of 1 digits.\n\
    \    return count(n::Int64, (x, y) -> (x || y) & 1)\nusing Test\n\n@testset begin\n\
    \ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpwxmbo2bi.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpwxmbo2bi.jl:1\n\
    in expression starting at /tmp/tmpwxmbo2bi.jl:1\n"
  stdout: ''
  timestamp: 1660003966
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 0 || n == 1 \n        return\
    \ 0 \n    else \n        return starts_one_ends(n - 1) + ends_one_starts(n) \n\
    \    ends_one_starts(n::Int64)::Int64 \n    if n == 1 \n        return 1 \n  \
    \  else \n        return ends_one_starts(n - 1) + 1 \n    ends_one_starts(1) =\
    \ 0\nends_one_starts(1) = 1\nends_one_starts(0) = 1\nends_one_starts(2) = 1\n\
    ends_one_starts(3) = 1\nends_one_starts(4) = 2\nends_one_starts(5) = 2\nends_one_starts(6)\
    \ = 2\nends_one_starts(7) = 2\nends_one_starts(8) = 2\nends_one_starts(9) = 2\n\
    ends_one_starts(10) = 2\nends_one_starts(11) = 3\nends_one_starts(12) = 3\nends_one_starts(13)\
    \ = 3\nends_one_starts(14) = 3\nends_one_starts(15) = 3\nends_one_starts(16) =\
    \ 3\nends_one_starts(17) = 3\nends_one_starts(18) = 3\nends_one_starts(19) = 3\n\
    ends_one_starts(20) = 3\nends_one_starts(21) = 3\nends_one_starts(22) = 3\nends_one_starts(23)\
    \ = 3\nends_one_starts(24) = 3\nends_one_starts(25) = 3\nends_one_starts(26) =\
    \ 3\nends_one_starts(27) = 3\nends_one_starts(28) = 3\nends_one_starts(29) = 3\n\
    ends_one_starts(30) = 3\nends_one_starts(31) = 3\nends_one_starts(32) = 3\nends_one_starts(33)\
    \ = 3\nends_one_starts(34) = 3\nends_one_starts(35) = 3\nends_one_starts(36) =\
    \ 3\nends_one_starts(37) = 3\nends_one_starts(38) = 3\nends_one_starts(39) = 3\n\
    ends_one_starts(40) = 3\nends_one_starts(41) = 3\nends_one_starts(42) = 3\nends_one_starts(43)\
    \ = 3\nends_one_starts(44) = 3\nends_one_starts(45) = 3\nends_one_starts(46) =\
    \ 3\nends_one_starts(47) = 3\nends_one_starts(48) = 3\nends_one_starts(49) = 3\n\
    ends_one_starts(50) = 3\nends_one_starts(51) = 3\nends_one_\nusing Test\n\n@testset\
    \ begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmph6183lxo.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmph6183lxo.jl:1\n\
    in expression starting at /tmp/tmph6183lxo.jl:1\n"
  stdout: ''
  timestamp: 1660003966
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    \"\"\"\n    Given a positive integer\
    \ n, return the count of the numbers of n-digit\n    positive integers that start\
    \ or end with 1.\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpngs68mmr.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpngs68mmr.jl:1\n\
    in expression starting at /tmp/tmpngs68mmr.jl:1\n"
  stdout: ''
  timestamp: 1660003959
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    \"\"\"\n    Given a positive integer\
    \ n, return the count of the numbers of n-digit\n    positive integers that start\
    \ or end with 1.\n    \"\"\"\n    \nusing Test\n\n@testset begin\n\ncandidate\
    \ = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\
    \t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmppknz3ah2.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmppknz3ah2.jl:1\n\
    in expression starting at /tmp/tmppknz3ah2.jl:1\n"
  stdout: ''
  timestamp: 1660003966
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 0 \n        return 0 \n    else\
    \ \n        ones = n - 1\n        starts_ends_n = 0\n        while ones > 0 \n\
    \            if n % 10 == 1 && n % 100 != 11 \n                return starts_ends_n\
    \ \n            ones -= 1\n            starts_ends_n += 1\n        end\n     \
    \   return starts_ends_n\nend\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmpz78kuz0n.jl:6 requires\
    \ end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpz78kuz0n.jl:1\nin expression\
    \ starting at /tmp/tmpz78kuz0n.jl:1\n"
  stdout: ''
  timestamp: 1660003966
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    count = 0\n    for x in 1..n\n      \
    \  if mod(x, 10) == 1\n            count += 1\n        end\n    end\n    count\n\
    end\n</code>\n<|/ a tags=julia,algorithm |>\n<| a |>\nFor this problem, I believe\
    \ that if you can avoid using loops you can make a significant speed-up. The algorithm\
    \ below works by iterating through each digit in the given number in reverse order\
    \ and checking how many times a given digit in the given number starts or ends\
    \ with 1. Once we know how many times each digit appears, we can sum the number\
    \ of times we see a digit that starts with 1 followed by the same number of digits\
    \ that end with 1. \n<code>\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5t1788ka.jl:14\nin expression starting at\
    \ /tmp/tmp5t1788ka.jl:14\n"
  stdout: ''
  timestamp: 1660003966
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n==0 \n        then 0 \n    else if\
    \ n==1 \n        then 1 \n    else if n<0 \n        then -starts_one_ends(-n)\n\
    \    else if n>1 \n        then starts_one_ends(n-1) + starts_one_ends(n-1)\n\
    \    end\nend\n\"\"\"\n    Compute the number of 1's in one number or all integers\
    \ given by the\n    input array. \n    \"\"\"\nusing Test\n\n@testset begin\n\n\
    candidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"0\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpmfdf7uy_.jl:7\nin expression starting at /tmp/tmpmfdf7uy_.jl:7\n"
  stdout: ''
  timestamp: 1660003966
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 0 \n        then error(\"starts_one_ends\
    \ called with n < 0\")\n    else if n == 0 \n        then return 1 \n        else\
    \ if n == 1 \n            then return 1 \n            else \n                let\
    \ l = floor(log(n))\n                let (q, r) = div(n, 10)\n               \
    \ let m = r - l + 1\n                let mut i = 1\n                while i <=\
    \ m \n                    and is_odd(floor(i))\n                    and i <= n\
    \ \n                    and i >= 1 \n                    and i >= n \n       \
    \             and i != q \n                    && i != r \n                  \
    \  && i != l\n                    && is_odd(i)\n                    && (i^q^r^l)\
    \ == 0 \n                    && is_odd(i^q^r^l)\n                    && (i^q^r^l)\
    \ == n\n                    && (i^q^r^l) == (n - 1)\n                    && (i^q^r^l)\
    \ == (n - 2)\n                    && (i^q^r^l) == (n - 3)\n                  \
    \  && (i^q^r^l) == (n - 4)\n                    && (i^q^r^l) == (n - 5)\n    \
    \                && (i^q^r^l) == (n - 6)\n                    && (i^q^r^l) ==\
    \ (n - 7)\n                    && (i^q^r^l) == (n - 8)\n                    &&\
    \ (i^q^r^l) == (n - 9)\n                    && (i^q^r^l) == (n - 10)\n       \
    \             && (i^q^r^l) == (n - 11)\n                    && (i^q^r^l) == (n\
    \ - 12)\n                    && (i^q^r^l) == (n - 13)\n                    &&\
    \ (i^q^r^l) == (n - 14)\n                    && (i^q^r^l) == (n - 15)\n      \
    \              && (i^q^r^l) == (n - 16)\n                    && (i^q^r^l) == (n\
    \ - 17)\n                    && (i^q^r^l) == (n - 18)\n                    &&\
    \ (i^q^r^l) == (n - 19)\n                    && (i^q^r^l) == (n - 20)\n      \
    \              && (i^q^r^l) == (n - 21) \n                    && (i^q^r^l) ==\
    \ (n - 22)\n                    && (i^q^r^l) == (n - 23)\n                   \
    \ && (i^q^r^l) == (n - 24)\n                    && (i^q^r^l) == (n - 25)\nusing\
    \ Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"error\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpsp2vlf74.jl:7\nin expression starting at /tmp/tmpsp2vlf74.jl:7\n"
  stdout: ''
  timestamp: 1660003966
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    \n    count = 0\n    i = 2\n    while\
    \ i <= n do\n        if n%i==0 && i!=n \n            count += 1\n        i +=\
    \ 1\n    end\n    \n    return count\nend\n\"\"\"\n    Given a positive integer\
    \ n, return the count of the numbers of n-digit\n    positive integers that start\
    \ with 2.\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpm5sbbvhe.jl:9\nin expression starting at /tmp/tmpm5sbbvhe.jl:9\n"
  stdout: ''
  timestamp: 1660003966
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    starts = starts_index(n) - 1\n    ends\
    \ = ends_index(n) - 1\n    return n - starts - ends\nend\n</cell>\n<code language=julia-1.2>\n\
    @time starts_one_ends(1_000_000_000);\n</cell>\n<text>\nThe counts_index() function\n\
    The counts_index() function is similar to count(), but returns the number of entries\
    \ with keys that are strictly less than a given value rather than the number of\
    \ keys equal to or greater than a given value. For example, counts_index(1) returns\
    \ the number of keys strictly less than 1, and counts_index(1_000_000_000) returns\
    \ the number of keys strictly less than 1_000_000_000.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwotp3vu_.jl:10\nin expression starting at\
    \ /tmp/tmpwotp3vu_.jl:10\n"
  stdout: ''
  timestamp: 1660003966
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    count = 0\n    for digit in digits(n)\
    \ \n        if digit==1\n            count+=1\n    end\n        \n    return count\n\
    end\n</cell>\n<text>\nSolution\nLet's test our solution:\nusing Test\n\n@testset\
    \ begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpa5m3ze7n.jl:14\nin expression starting at\
    \ /tmp/tmpa5m3ze7n.jl:14\n"
  stdout: ''
  timestamp: 1660003966
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    count = 0\n    while n > 1\n        n\
    \ /= 10\n        count += 1\n    end\n    return count\n</cell>\n<code language=julia-1.6>\n\
    # Solution using `digits` function.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\
    \t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcimbv70d.jl:12\nin expression starting at\
    \ /tmp/tmpcimbv70d.jl:12\n"
  stdout: ''
  timestamp: 1660003966
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 0 \n        0\n    elseif n >\
    \ 0\n        1 + starts_one_ends(n-1)\n    elseif n < 0\n        starts_one_ends(abs(n))\n\
    \    else\n        error(\"bad input\")\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp99zudjb_.jl:18

    '
  stdout: "test set: Test Failed at /tmp/tmp99zudjb_.jl:22\n  Expression: candidate(2)\
    \ == 18\n   Evaluated: 2 == 18\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp99zudjb_.jl:22 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp99zudjb_.jl:20\ntest set: Test\
    \ Failed at /tmp/tmp99zudjb_.jl:23\n  Expression: candidate(3) == 180\n   Evaluated:\
    \ 3 == 180\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp99zudjb_.jl:23 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp99zudjb_.jl:20\ntest set: Test\
    \ Failed at /tmp/tmp99zudjb_.jl:24\n  Expression: candidate(4) == 1800\n   Evaluated:\
    \ 4 == 1800\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp99zudjb_.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp99zudjb_.jl:20\ntest set: Test\
    \ Failed at /tmp/tmp99zudjb_.jl:25\n  Expression: candidate(5) == 18000\n   Evaluated:\
    \ 5 == 18000\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp99zudjb_.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp99zudjb_.jl:20\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     4      5\n"
  timestamp: 1660003967
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n\tif n == 0 \n\t\treturn 0 \n\telse \n\t\t\
    let mut x = 1\n\t\tlet mut y = 1\n\t\twhile x < n {\n\t\t\tif n % x == 0 { \n\t\
    \t\t\tx = x + y \n\t\t\t\ty = 0\n\t\t\t} else \n\t\t\t\ty = y + 1 \n\t\t}\n\t\t\
    x + y\n\tend \nend\n</cell>\n<text>\nWrite a function that takes a list of integers\
    \ l and returns the number of 1s in the list.\nusing Test\n\n@testset begin\n\n\
    candidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: let variables should end in \";\" or newline\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpmh7tf8cr.jl:9\nin expression starting\
    \ at /tmp/tmpmh7tf8cr.jl:9\n"
  stdout: ''
  timestamp: 1660003966
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n\tif n <= 1 \n\t\treturn 0\n\telse if n <\
    \ 10\n\t\treturn 1\n\telse if n == 10\n\t\treturn 2\n\telse if n == 11\n\t\treturn\
    \ 3\n\telse if n == 12\n\t\treturn 4\n\telse if n == 13\n\t\treturn 5\n\telse\
    \ if n == 14\n\t\treturn 6\n\telse if n == 15\n\t\treturn 7\n\telse if n == 16\n\
    \t\treturn 8\n\telse if n == 17\n\t\treturn 9\n\telse if n == 18\n\t\treturn 10\n\
    \telse if n == 19\n\t\treturn 11\n\telse if n == 20\n\t\treturn 12\n\telse if\
    \ n == 21\n\t\treturn 13\n\telse if n == 22\n\t\treturn 14\n\telse if n == 23\n\
    \t\treturn 15\n\telse if n == 24\n\t\treturn 16\n\telse if n == 25\n\t\treturn\
    \ 17\n\telse if n == 26\n\t\treturn 18\n\telse if n == 27\n\t\treturn 19\n\telse\
    \ if n == 28\n\t\treturn 20\n\telse if n == 29\n\t\treturn 21\n\telse if n ==\
    \ 3\n\t\treturn 22\n\telse if n == 4\n\t\treturn 23\n\telse if n == 5\n\t\treturn\
    \ 24\n\telse if n == 6\n\t\treturn 25\n\telse if n == 7\n\t\treturn 26\n\telse\
    \ if n == 8\n\t\treturn 27\n\telse if n == 9\n\t\treturn 28\n\telse if n == 10\n\
    \t\treturn 29\n\telse if n == 11\n\t\treturn 30\n\telse if n == 12\n\t\treturn\
    \ 31\n\telse if n == 13\n\t\treturn 32\n\telse if n == 14\n\t\treturn 33\n\telse\
    \ if n == 15\n\t\treturn 34\n\telse if n == 16\n\t\treturn 35\n\telse if n ==\
    \ 17\n\t\treturn 36\n\telse if n == 18\n\t\treturn 37\n\telse if n == 19\n\t\t\
    return 38\n\telse if n == 20\n\t\treturn 39\n\telse if n == 21\n\t\treturn 40\n\
    \telse if n == 22\n\t\treturn 41\n\telse if n == 23\n\t\treturn 42\n\telse if\
    \ n == 24\n\t\treturn 43\n\telse if n == 25\n\t\treturn 44\n\telse if n == 26\n\
    \t\treturn 45\n\telse if n == 27\n\t\treturn 46\n\telse if n == 28\n\t\treturn\
    \ 47\n\telse if n == 29\n\t\treturn 48\n\telse if n == 3\n\t\treturn 49\n\telse\
    \ if n == 4\n\t\treturn 50\n\telse if n == 5\n\t\treturn 51\n\telse if n == 6\n\
    \t\treturn 52\n\telse if n == 7\n\t\treturn 53\n\telse if n == 8\n\t\treturn 54\n\
    \telse if n == 9\n\t\treturn 55\n\telse if n == 10\n\t\treturn 56\n\nusing Test\n\
    \n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\
    \t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfmebl_zu.jl:8\nin expression starting at /tmp/tmpfmebl_zu.jl:8\n"
  stdout: ''
  timestamp: 1660003966
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 10\n        1\n    else \n   \
    \     for a in 1:10\n            if n == a\n                starts_one_ends(n+1)\n\
    \            else\n                starts_one_ends(n)\n        end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmpl_w6p3il.jl:6 requires\
    \ end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpl_w6p3il.jl:1\nin expression\
    \ starting at /tmp/tmpl_w6p3il.jl:1\n"
  stdout: ''
  timestamp: 1660003966
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    # Write your code here.\n    \"\"\"\n\
    \    This function solves the given problem.\n    \"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk308kv06.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk308kv06.jl:1\n\
    in expression starting at /tmp/tmpk308kv06.jl:1\n"
  stdout: ''
  timestamp: 1660003966
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n <= 10\n        return Int64(1)\n\
    \    \n    count::Int64 = 0\n    i = n\n    \n    while i < n+9\n        count::Int64\
    \ = count + 1\n        i = i + 9\n    end\n    \n    return count\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpq2ea96m_.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpq2ea96m_.jl:1\n\
    in expression starting at /tmp/tmpq2ea96m_.jl:1\n"
  stdout: ''
  timestamp: 1660003966
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n <= 0 \n    then return 0\n    else\
    \ if n == 1 \n    then return 1\n    else \n        let mut count = 0\n      \
    \  let mut counter = 1\n        for i in 1..n \n        do \n            if i\
    \ == counter\n            then \n                count += 1\n            else\n\
    \                counter = 0\n            end \n        end \n        return count\
    \ \n    end \nend \n</code>\n<|/ a |>\n<| c |>\nThat's a nice one-liner. But the\
    \ `for i in 1..n` could be replaced with `for i in 2..n`\n<|/ c |>\n<| c |>\n\
    No, that would result in counting 1-digit numbers instead of only those that start\
    \ or end with 1.\n<|/ c |>\n<| c |>\nThanks for pointing that out, I misread the\
    \ question.\n<|/ c |>\n<| c |>\nI'm guessing you missed the part where you said\
    \ \"(without using any looping)\"\n<|/ c |>\n<| a dscore=2 tags=math,haskell |>\n\
    The other answers are good, but I thought I'd add another approach with foldl\
    \ (which requires building a list of counts for every digit from 0 to 9). I'm\
    \ pretty sure this is asymptotically faster than using length repeatedly because\
    \ building a list is O(n), where as foldl is O(n\xB2).\n<code>\ncount_1 n = foldl\
    \ (\\acc _ -> (acc+1, acc+1)) 0 [1..n]\n</code>\nThe lambda function takes three\
    \ parameters: a counter to accumulate counts from (starting with 0), the current\
    \ digit, and a list of digits. acc is initialized to 0 and each iteration adds\
    \ 1 to it and resets the counter to 0 if the current digit is the same. acc is\
    \ returned after the final iteration. [1..n] is the list of digits to count up\
    \ (from 1 to n), and the starting zero is passed along to foldl.\nThe result is\
    \ this list [1, 3, 6, 10, 15, 21, 28, 36, 45] where you can simply sum those to\
    \ get your count.\n<|/ a |>\n<| c |>\nThis solution is *not* asymptotically faster\
    \ than the other solutions.\n<|/ c |>\n<| c |>\nThanks for pointing that out.\
    \ I added a note about how this might affect asymptotic performance.\n<|/ c |>\n\
    <| a |>\nAnother answer without loops (but still not asymptotically faster):\n\
    <code>\ncount_1 n = sum $ [i | i <- [2..n], n == length [1..i]]\n</code>\n<|/\
    \ a dscore=\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t\
    @test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) ==\
    \ 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpk17ev282.jl:7\nin expression starting at /tmp/tmpk17ev282.jl:7\n"
  stdout: ''
  timestamp: 1660003966
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 0 return 0\n    if n%2 == 0 then\
    \ return starts_one_ends(n/2) else return starts_one_ends(n-1) + starts_one_ends(n+1)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpe9abzteu.jl:7\nin expression starting at /tmp/tmpe9abzteu.jl:7\n"
  stdout: ''
  timestamp: 1660003966
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    \"\"\"count numbers of positive integer\
    \ that start or end with 1\"\"\"\n    count = 0\n    while  n > 1  do\n      \
    \  if n%10 == 1  then\n            n = n/10\n            count = count+1\n   \
    \     else\n            n=n-1\n        end\n    end\n    return count\nend\n</code>\n\
    <|/ a tags=julia |>\n<| a |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\
    \t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp8ae8mf9j.jl:8\nin expression starting at /tmp/tmp8ae8mf9j.jl:8\n"
  stdout: ''
  timestamp: 1660003966
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n==0 \n    then 0 \n    else if n<0\
    \ \n        then starts_one_ends(-n) \n        else (starts_one_ends(n-1)+ends_one_starts(n-1))\
    \ \n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"0\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpr9__4c8w.jl:7\nin expression starting at /tmp/tmpr9__4c8w.jl:7\n"
  stdout: ''
  timestamp: 1660003966
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n  if n < 10 then 1 else n / 10 // starts_one_ends(n\
    \ % 10) + 1\nend\n</code>\nFor large numbers, you can use a more efficient approach\
    \ by keeping a running total of the number of digits you encounter.  In general,\
    \ your algorithm needs to look like this:\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"1\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpyt169j04.jl:6\nin expression starting at /tmp/tmpyt169j04.jl:6\n"
  stdout: ''
  timestamp: 1660003967
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 0 then 0\n    else (starts_one_ends(n-1)*n)/(n-1)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"0\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpgb67x4kj.jl:6\nin expression starting at /tmp/tmpgb67x4kj.jl:6\n"
  stdout: ''
  timestamp: 1660003967
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n\"\"\"\n    Given a positive integer n, return\
    \ the count of the numbers of n-digit\n    positive integers that start or end\
    \ with 1.\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp9g6ys4mr.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp9g6ys4mr.jl:1\n\
    in expression starting at /tmp/tmp9g6ys4mr.jl:1\n"
  stdout: ''
  timestamp: 1660003962
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    \n    if n == 0\n        0\n    else\n\
    \        starts_one_ends(n - 1) + ends_one_starts(n - 1)\n    end\nend\n    \n\
    \"\"\"\n    Calculate the number of positive integers that are divisible by 3.\n\
    \    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t\
    @test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) ==\
    \ 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: cannot document the following expression:\n\nusing Test\n\
    \nStacktrace:\n [1] error(::String, ::String)\n   @ Base ./error.jl:42\n [2] top-level\
    \ scope\n   @ /tmp/tmp7zrofik4.jl:14\nin expression starting at /tmp/tmp7zrofik4.jl:14\n"
  stdout: ''
  timestamp: 1660003968
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 2 \n        return 0 \n    else\
    \ if n == 3 \n        return 1 \n    else if n == 4 \n        return 2 \n    else\
    \ if n == 5 \n        return 3 \n    else if n == 6 \n        return 4 \n    else\
    \ if n == 7 \n        return 5 \n    else if n == 8 \n        return 6 \n    else\
    \ if n == 9\n        return 7 \n    else if n == 10\n        return 8\n    else\
    \ if n == 11\n        return 9\n    else if n == 12\n        return 10\n    else\
    \ if n == 13\n        return 11\n    else if n == 14\n        return 12\n    else\
    \ if n == 15\n        return 13\n    else if n == 16\n        return 14\n    else\
    \ if n == 17\n        return 15\n    else if n == 18\n        return 16\n    else\
    \ if n == 19\n        return 17\n    else if n == 20\n        return 18\n    else\
    \ if n == 21\n        return 19\n    else if n == 22\n        return 20\n    else\
    \ if n == 23\n        return 21\n    else if n == 24\n        return 22\n    else\
    \ if n == 25\n        return 23\n    else if n == 26\n        return 24\n    else\
    \ if n == 27\n        return 25\n    else if n == 28\n        return 26\n    else\
    \ if n == 29\n        return 27\n    else if n == 30 \n        return 28\n   \
    \ else if n == 31 \n        return 29\n    else if n == 32\n        return 30\n\
    \    else if n == 33\n        return 31\n    else if n == 34\n        return 32\n\
    \    else if n == 35\n        return 33\n    else if n == 36\n        return 34\n\
    \    else if n == 37\n        return 35\n    else if n == 38\n        return 36\n\
    \    else if n == 39\n        return 37\n    else if n == 40 \n        return\
    \ 38\n    else if n == 41 \n        return 39\n    else if n == 42 \n        return\
    \ 40\n    else if n == 43 \n        return 41\n    else if n == 44\n        return\
    \ 42\n    else if n == 45\n        return 43\n    else if n == 46\n        return\
    \ 44\n    else if n == 47\n        return 45\n    else if n == 48\n        return\
    \ 46\n    else if n == 49\n        return 47\n    else if n == 50 \n        return\
    \ 48\n    else if n == 51 \n        return 49\n    else if n == 52 \n        return\
    \ 50\n    else if n == 53 \n        return 51\n    else if n == 54\n        return\
    \ 52\n    else if n == 55\n        return 53\n    else if n == 56\n        return\
    \ 54\n    else if n == 57\n        return 55\n    \nusing Test\n\n@testset begin\n\
    \ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkz0ywznp.jl:8\nin expression starting at /tmp/tmpkz0ywznp.jl:8\n"
  stdout: ''
  timestamp: 1660003968
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 0 \n        0\n    else\n    \
    \    1 + count((n-1)::Int64)\n    end\nend\n</code>\n<|/ a tags=julia,performance\
    \ |>\n<| a dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpi2hmp32f.jl:12\nin expression starting at\
    \ /tmp/tmpi2hmp32f.jl:12\n"
  stdout: ''
  timestamp: 1660003968
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 1 then return 0 else starts_one_ends(n-1)\
    \ + ends_one_starts(n-1)\nend\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpslsru8wp.jl:6\nin expression starting at /tmp/tmpslsru8wp.jl:6\n"
  stdout: ''
  timestamp: 1660003967
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 0 || n == 1 \n        then return\
    \ 1\n        else return 0\n</code>\n<|/ a |>\n<| c |>\nPlease give some feed-back\
    \ if you voted down this answer.\n<|/ c |>\n<| a dscore=0 tags=julia,performance,recursion\
    \ |>\nI believe that this is an example of tail recursion optimization.  In Julia,\
    \ you can use the following code to generate a list of Fibonacci numbers:\n<code>\n\
    fibs(n::Int) = fibs(1,n,1) # Base case\nfibs(x::Int,y::Int,z::Int) = (z + (y^2)^2)\
    \ if (y <= 1) # Recursive case\n    else fibs(x,y+1,z)\nfibs(x::Int,y::Int,z::Int)\
    \ = x # Non-recursive case\n</code>\n<|/ a |>\n<| c |>\nI don't understand why\
    \ you think that this is tail recursion, since tail recursion is something that\
    \ is done with the last function call, not with the previous one. I also don't\
    \ understand why this would improve the speed of the function\n<|/ c |>\n<| c\
    \ |>\nYou don't know Julia, so I thought that you could learn from this.  Tail\
    \ recursion optimization is a compiler optimization that can often be done by\
    \ the compiler, but it could also be done by the programmer.  In fact, Julia is\
    \ tail recursive in many cases.  It would be interesting if someone could comment\
    \ on Julia's implementation.\n<|/ c |>\n<| c |>\nOkay, I can see that. Anyway,\
    \ I would expect that this to be tail recursion optimized, because it could easily\
    \ do that if you had the return value instead of returning the function call.\
    \ Also the function itself does not need the last line to be executed after the\
    \ recursive call, it could be executed earlier, so I don't see any advantage to\
    \ doing that.\n<|/ c |>\n<| c |>\nThis answer doesn't make any sense to me. You\
    \ are just making a new recursive call to the same function (with different arguments).\
    \ Tail recursion optimization is the whole point of it.\n<|/ c |>\n<| c |>\nOh,\
    \ okay, sorry about that.  I haven't done tail recursion optimization before in\
    \ other languages.  I thought this was tail recursion in the languages that support\
    \ it.  I suppose it's possible that this is not tail recursion and Julia is smart\
    \ enough to optimize it.  I guess this is an example of tail recursion optimization\
    \ then.  I hope this helps.\n<|/ c |>\n<| a tags=julia,performance,recursion \n\
    using Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp0r5rie2_.jl:7\nin expression starting at /tmp/tmp0r5rie2_.jl:7\n"
  stdout: ''
  timestamp: 1660003968
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n\"\"\"\n    Given a positive integer n, return\
    \ the count of the numbers of n-digit\n    positive integers that end with 1.\n\
    \    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t\
    @test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) ==\
    \ 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp8bv98i34.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp8bv98i34.jl:1\n\
    in expression starting at /tmp/tmp8bv98i34.jl:1\n"
  stdout: ''
  timestamp: 1660003968
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n <= 1 \n        then 0\n        else\
    \ 1 + starts_one_ends(n / 10)\n    end\nend\n\"\"\"\n\"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"0\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpr5b62obq.jl:7\nin expression starting at /tmp/tmpr5b62obq.jl:7\n"
  stdout: ''
  timestamp: 1660003968
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 1 \n        then 1 \n       \
    \ else starts_one_ends(n-1) + starts_one_ends(n-2) \nend\n</cell>\n<cell>\nstarts_one_ends(4)\n\
    </cell>\n<text>\nLet's do one more exercise to test your function.\nusing Test\n\
    \n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\
    \t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"1\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpiyby2f6n.jl:7\nin expression starting at /tmp/tmpiyby2f6n.jl:7\n"
  stdout: ''
  timestamp: 1660003968
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 1 \n        return 0 \n    if\
    \ n == 1 \n        return 1 \n    if n > 1 \n        local start = 1 \n      \
    \  local end = 1 \n        do \n            start = start * 10 \n            end\
    \ = end + 1 \n            while end <= n \n                end *= 10 \n      \
    \  return end - start + 1 \n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\
    \t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"end\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp7iiivrod.jl:12\nin expression starting at /tmp/tmp7iiivrod.jl:12\n"
  stdout: ''
  timestamp: 1660003968
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    start = 0\n    end = n\nusing Test\n\n\
    @testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t\
    @test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid assignment location \"function starts_one_ends(n::Int64)::Int64\n\
    \    # /tmp/tmpanpog7nb.jl, line 5\n    # /tmp/tmpanpog7nb.jl, line 6\n    start\
    \ = 0\nend\" around /tmp/tmpanpog7nb.jl:1\nStacktrace:\n [1] top-level scope\n\
    \   @ /tmp/tmpanpog7nb.jl:1\nin expression starting at /tmp/tmpanpog7nb.jl:1\n"
  stdout: ''
  timestamp: 1660003968
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 10 then return 0\n    if n > 9\
    \ then return 1\n    \n    let i = Int64.(ceil(log10(n)))\n    let count = (i-1)\
    \ * (i-1)\n    \n    count..(n+1-i).filter(|x| x % i == 0).length\nend\n</cell>\n\
    <code language=julia-0.5>\n@time starts_one_ends(1_000_000)\n</cell>\n<code language=julia-0.5>\n\
    @time starts_one_ends(1_000_001)\n</cell>\n<code language=julia-0.5>\n@time starts_one_ends(1_000_002)\n\
    </cell>\n<code language=julia-0.5>\n@time starts_one_ends(1_000_003)\n</cell>\n\
    <code language=julia-0.5>\n@time starts_one_ends(1_000_004)\n</cell>\n<code language=julia-0.5>\n\
    @time starts_one_ends(1_000_005)\n</cell>\n<code language=julia-0.5>\n@time starts_one_ends(1_000_006)\n\
    </cell>\n<code language=julia-0.5>\n@time starts_one_ends(1_000_007)\n</cell>\n\
    <code language=julia-0.5>\n@time starts_one_ends(1_000_008)\n</cell>\n<code language=julia-0.5>\n\
    @time starts_one_ends(1_000_009)\n</cell>\n<code language=julia-0.5>\n@time starts_one_ends(1_000_010)\n\
    </cell>\n<code language=julia-0.5>\n@time starts_one_ends(1_000_011)\n</cell>\n\
    <code language=julia-0.5>\n@time starts_one_ends(1_000_012)\n</cell>\n<code language=julia-0.5>\n\
    @time starts_one_ends(1_000_013)\n</cell>\n<code language=julia-0.5>\n@time starts_one_ends(1_000_014)\n\
    </cell>\n<code language=julia-0.5>\n@time starts_one_ends(1_000_015)\n</cell>\n\
    <code language=julia-0.5>\n@time starts_one_ends(1_000_016)\n</cell>\n<code language=julia-0.5>\n\
    @time starts_one_ends(1_000_017)\n</cell>\n<code language=julia-0.5>\n@time starts_one_ends(1_000_018)\n\
    </cell>\n<code language=julia-0.5>\n@time starts_one_ends(1_\nusing Test\n\n@testset\
    \ begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpw0jjzmde.jl:6\nin expression starting at /tmp/tmpw0jjzmde.jl:6\n"
  stdout: ''
  timestamp: 1660003968
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n<0 \n        error(\"n must be positive\"\
    )\n    else if n == 0\n        0\n    else if n==1 \n        1\n    else\n   \
    \     digits_of(n, true) + starts_one_ends(n - digits_of(n, true))\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpra_t69hn.jl:8\nin expression starting at /tmp/tmpra_t69hn.jl:8\n"
  stdout: ''
  timestamp: 1660003968
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 0\n        return 0\n    if n\
    \ == 1\n        return 1\n    digits = ceil(log2(n))\n    one_starts = [\n   \
    \     0 for _ in 1:digits\n    ]\n    one_starts[1] = 1\n    for i in 2:(digits)\n\
    \        one_starts[i] = one_starts[i-1] + 1\n    for i in 2:digits\n        one_starts[i]\
    \ = one_starts[i-1] + one_starts[i]\n    sum = 0\n    for i in 1:digits\n    \
    \    sum += one_starts[i]\n    sum += n - 1\n    return sum\nusing Test\n\n@testset\
    \ begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"for\" at /tmp/tmp9t1pnvqr.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp9t1pnvqr.jl:1\n\
    in expression starting at /tmp/tmp9t1pnvqr.jl:1\n"
  stdout: ''
  timestamp: 1660003968
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n <= 0 \n    then 0\n    else 1 +\
    \ counts_one_ends_of_n(n-1) \nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t\
    @test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"0\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp851i677_.jl:7\nin expression starting at /tmp/tmp851i677_.jl:7\n"
  stdout: ''
  timestamp: 1660003968
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 0 \n        then 0 \n    else\
    \ \n        if n == 0 \n            then 1 \n        else \n            sum((starts_one_ends(x-1)\
    \ * x) \n            for x in range_of_n(n)) \nend\nusing Test\n\n@testset begin\n\
    \ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"0\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpwm9x9tic.jl:7\nin expression starting at /tmp/tmpwm9x9tic.jl:7\n"
  stdout: ''
  timestamp: 1660003968
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    count = 0\n    for x in 1:n \n      \
    \  if ((x % 10) == 1)\n            count += 1\n        end\n    end\n    return\
    \ count\nend\n</cell>\n<code language=julia-1.4>\nstarts_one_ends(126)\n</cell>\n\
    <code language=julia-1.4>\nstarts_one_ends(1001)\n</cell>\n<code language=julia-1.4>\n\
    starts_one_ends(1002)\n</cell>\n<code language=julia-1.4>\nstarts_one_ends(10000)\n\
    </cell>\n<code language=julia-1.4>\nstarts_one_ends(10990)\n</cell>\n<code language=julia-1.4>\n\
    starts_one_ends(10999)\n</cell>\n<code language=julia-1.4>\nstarts_one_ends(110001)\n\
    </cell>\n<code language=julia-1.4>\nstarts_one_ends(110002)\n</cell>\n<code language=julia-1.4>\n\
    starts_one_ends(110003)\n</cell>\n<code language=julia-1.4>\nstarts_one_ends(110004)\n\
    </cell>\n<code language=julia-1.4>\nstarts_one_ends(110005)\n</cell>\n<code language=julia-1.4>\n\
    starts_one_ends(110006)\n</cell>\n<code language=julia-1.4>\nstarts_one_ends(110007)\n\
    </cell>\n<code language=julia-1.4>\nstarts_one_ends(110009)\n</cell>\n<code language=julia-1.4>\n\
    starts_one_ends(110010)\n</cell>\n<code language=julia-1.4>\nstarts_one_ends(110011)\n\
    </cell>\n<code language=julia-1.4>\nstarts_one_ends(110012)\n</cell>\n<code language=julia-1.4>\n\
    starts_one_ends(110013)\n</cell>\n<code language=julia-1.4>\nstarts_one_ends(110014)\n\
    </cell>\n<code language=julia-1.4>\nstarts_one_ends(110015)\n</cell>\n<code language=julia-1.4>\n\
    starts_one_ends(119999)\n</cell>\n<code language=julia-1.4>\nstarts_one_ends(100000)\n\
    </cell>\n<code language=julia-1.4>\nstarts_one_ends(100001)\n</cell>\n<code language=julia-1.4>\n\
    starts_one_ends(100002)\n</cell>\n<code language=julia-1.4>\nstarts_one_ends(100003)\n\
    </cell>\n<code language=julia-1.4>\nstarts_one_ends(100004)\n</cell>\n<code language=\n\
    using Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp557465qo.jl:14\nin expression starting at\
    \ /tmp/tmp557465qo.jl:14\n"
  stdout: ''
  timestamp: 1660003968
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    \n    \"\"\"\n    Given a positive integer\
    \ n, return the count of the numbers of n-digit\n    positive integers that start\
    \ or end with 1.\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpc850bweq.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpc850bweq.jl:1\n\
    in expression starting at /tmp/tmpc850bweq.jl:1\n"
  stdout: ''
  timestamp: 1660003968
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    count = 0\n    if n <= 1 \n        count\
    \ += 1\n        return count\n    ends = (n-1)/10\n    last = (n-1)%10\n    while\
    \ ends > 0\n        if last == 0\n            count += 1\n        ends -= 1\n\
    \        last -= 1\n    ends = (n-1)/10\n    last = (n-1)%10\n    while ends >\
    \ 0\n        if last == 0\n            count += 1\n        ends -= 1\n       \
    \ last += 1\n    ends = (n-1)/10\n    last = (n-1)%10\n    while ends > 0\n  \
    \      if last == 0\n            count += 1\n        ends += 1\n        last +=\
    \ 1\n    ends = (n-1)/10\n    last = (n-1)%10\n    while ends > 0\n        if\
    \ last == 0\n            count += 1\n        ends -= 1\n        last -= 1\n  \
    \  ends = (n-1)/10\n    last = (n-1)%10\n    while ends > 0\n        if last ==\
    \ 0\n            count += 1\n        ends += 1\n        last -= 1\n    ends =\
    \ (n-1)/10\n    last = (n-1)%10\n    while ends > 0\n        if last == 0\n  \
    \          count += 1\n        ends -= 1\n        last += 1\n    ends = (n-1)/10\n\
    \    last = (n-1)%10\n    while ends > 0\n        if last == 0\n            count\
    \ += 1\n        ends += 1\n        last -= 1\n    ends = (n-1)/10\n    last =\
    \ (n-1)%10\n    while ends > 0\n        if last == 0\n            count += 1\n\
    \        ends -= 1\n        last += 1\n    ends = (n-1)/10\n    last = (n-1)%10\n\
    \    while ends > 0\n        if last == 0\n            count += 1\n        ends\
    \ += 1\n        last -= 1\n    ends = (n-1)/10\n    last = (n-1)%10\n    while\
    \ ends > 0\n        if last == 0\n            count += 1\n        ends -= 1\n\
    \        last += 1\n    ends = (n-1)/10\n    last = (n-1)%10\n    while ends >\
    \ 0\n        if last == 0\n            count += 1\n        ends += 1\n       \
    \ last -= 1\n    ends = (n-1)/10\n    last = (n-1)%10\n    while ends > 0\n  \
    \      if last == 0\n            count += 1\n        ends -= 1\n        last +=\
    \ 1\n    ends = (n-1)/10\n    last = (n-1)%10\n    while ends > 0\n        if\
    \ last == 0\n            count += 1\n        ends += 1\n        last -= 1\n  \
    \  ends = (n-1)/10\n    last = (n-1)%10\n    while ends > 0\n        if last ==\
    \ 0\n            count += 1\n        ends -= 1\n        last += 1\n\nusing Test\n\
    \n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\
    \t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp54o27ii5.jl:1\nin expression starting at /tmp/tmp54o27ii5.jl:1\n"
  stdout: ''
  timestamp: 1660003968
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    \"\"\"\n    Given a positive integer\
    \ n, return the count of the numbers of n-digit\n    positive integers that start\
    \ or end with 1.\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpngs68mmr.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpngs68mmr.jl:1\n\
    in expression starting at /tmp/tmpngs68mmr.jl:1\n"
  stdout: ''
  timestamp: 1660003959
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    \nends_one_starts(n) = 0\nends_one_starts(1)\
    \ = 1\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp1ygt3qts.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp1ygt3qts.jl:1\n\
    in expression starting at /tmp/tmp1ygt3qts.jl:1\n"
  stdout: ''
  timestamp: 1660003968
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if (n <= 0) return 0\n    if (n >= 10)\
    \ return 1\n    else return starts_one_ends(n - 1) + starts_one_ends(n - 10)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpviifl6pl.jl:1\nin expression starting at /tmp/tmpviifl6pl.jl:1\n"
  stdout: ''
  timestamp: 1660003969
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 1 \n        0\n    else\n    \
    \    # compute the number of digits ending in 1\n        digits(n).ends_with(1)\n\
    end\n</cell>\n<code language=julia-1.4>\n# test starts_one_ends\nn = 122\n@time\
    \ starts_one_ends(n)\n</cell>\n<text>\nExercise 1\nGiven a positive integer n,\
    \ compute the number of n-digit positive\nintegers that start or end with 1 and\
    \ whose length is no greater than \nn.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\
    \t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvueu7vnj.jl:12\nin expression starting at\
    \ /tmp/tmpvueu7vnj.jl:12\n"
  stdout: ''
  timestamp: 1660003969
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    \"\"\"\n    returns the number of positive\
    \ integers that start and end with n\n    starting from 1\n    \"\"\"\nusing Test\n\
    \n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\
    \t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp281pnxnv.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp281pnxnv.jl:1\n\
    in expression starting at /tmp/tmp281pnxnv.jl:1\n"
  stdout: ''
  timestamp: 1660003969
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n\"\"\"\n    Given a positive integer n, return\
    \ the count of the numbers of n-digit\n    positive integers that start or end\
    \ with 1.\n\"\"\"\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp1aq4lgdb.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp1aq4lgdb.jl:1\n\
    in expression starting at /tmp/tmp1aq4lgdb.jl:1\n"
  stdout: ''
  timestamp: 1660003969
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 1 \n        return 1\n    else\
    \ if n % 2 == 1 \n        return starts_one_ends(n - 1) + 1\n    else \n     \
    \   return starts_one_ends(n / 2) + 1\n    \n\"\"\"\n    Find the largest number\
    \ of the form 10^n that is a power of n.\n\"\"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4p0bln8z.jl:8\nin expression starting at /tmp/tmp4p0bln8z.jl:8\n"
  stdout: ''
  timestamp: 1660003969
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n<0 return 0\n    if n==1 return 1\n\
    \    if n==2 return 2\n    if n==3 return 3\n    if n==4 return 4\n    if n==5\
    \ return 5\n    if n==6 return 6\n    if n==7 return 7\n    if n==8 return 8\n\
    \    if n==9 return 9\n    if n==10 return 10\n    if n==11 return 11\n    if\
    \ n==12 return 12\n    if n==13 return 13\n    if n==14 return 14\n    if n==15\
    \ return 15\n    if n==16 return 16\n    if n==17 return 17\n    if n==18 return\
    \ 18\n    if n==19 return 19\n    if n==20 return 20\n    if n==21 return 21\n\
    \    if n==22 return 22\n    if n==23 return 23\n    if n==24 return 24\n    if\
    \ n==25 return 25\n    if n==26 return 26\n    if n==27 return 27\n    if n==28\
    \ return 28\n    if n==29 return 29\n    if n==30 return 30\n    if n==31 return\
    \ 31\n    if n==32 return 32\n    if n==33 return 33\n    if n==34 return 34\n\
    \    if n==35 return 35\n    if n==36 return 36\n    if n==37 return 37\n    if\
    \ n==38 return 38\n    if n==39 return 39\n    if n==40 return 40\n    if n==41\
    \ return 41\n    if n==42 return 42\n    if n==43 return 43\n    if n==44 return\
    \ 44\n    if n==45 return 45\n    if n==46 return 46\n    if n==47 return 47\n\
    \    if n==48 return 48\n    if n==49 return 49\n    if n==50 return 50\n    if\
    \ n==51 return 51\n    if n==52 return 52\n    if n==53 return 53\n    if n==54\
    \ return 54\n    if n==55 return 55\n    if n==56 return 56\n    if n==57 return\
    \ 57\n    if n==58 return 58\n    if n==59 return 59\n    if n==60 return 60\n\
    \    if n==61 return 61\n    if n==62 return 62\n    if n==63 return 63\n    if\
    \ n==64 return 64\n    if n==65 return 65\n    if n==66 return 66\n    if n==67\
    \ return 67\n    if n==68 return 68\n    if n==69 return 69\n    if n==70 return\
    \ 70\n    if n==71 \nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6sheeuil.jl:1\nin expression starting at /tmp/tmp6sheeuil.jl:1\n"
  stdout: ''
  timestamp: 1660003970
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    \"\"\"\n    Given a positive integer\
    \ n, return the count of the numbers of n-digit\n    positive integers that start\
    \ or end with 1.\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpngs68mmr.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpngs68mmr.jl:1\n\
    in expression starting at /tmp/tmpngs68mmr.jl:1\n"
  stdout: ''
  timestamp: 1660003959
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n<1 \n        error(\"n must be positive\"\
    ) \n    else if n==1 \n        1\n    else \n        starts_one_ends(n-1)\n  \
    \  ends_one_starts(n-1)\nend\n</code>\nThe reason I say this is that:\n<code>\n\
    starts_one_ends(10) == ends_one_starts(10)\n</code>\nso I wrote a recursive function.\n\
    I hope this helps.\n<|/ a dscore=0 tags=recursion,big-o,time-complexity,julia\
    \ |>\n<| c |>\nThis solution is O(n log n) instead of O(n) like my solution but\
    \ more efficient. Still, it doesn't work in Julia. Perhaps I should post a new\
    \ question about this issue. Thanks for the help.\n<|/ c |>\n<| a dscore=0 |>\n\
    I wrote my own version in Julia, but this is probably more efficient than others\
    \ answers:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpemhy6jdo.jl:8\nin expression starting at /tmp/tmpemhy6jdo.jl:8\n"
  stdout: ''
  timestamp: 1660003969
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 10 \n        then return 1 \n\
    \        else if n < 100 \n            then return 2 \n            else return\
    \ 3 \n    else \n        let  s = starts_one_ends(n/10) + 1 \n        in s if\
    \ n % 10 == 1\n           then s + 1 \n           else s \nend\nusing Test\n\n\
    @testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t\
    @test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpqyo76bbw.jl:7\nin expression starting at /tmp/tmpqyo76bbw.jl:7\n"
  stdout: ''
  timestamp: 1660003970
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    summ = 0\n    for i in 1 .. n do \n \
    \       if i mod i == 1 then \n            summ += 1 \n        end\n    end\n\
    \    return summ\nend\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpm73twski.jl:7\nin expression starting at /tmp/tmpm73twski.jl:7\n"
  stdout: ''
  timestamp: 1660003969
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n <= 0\n        0\n    elseif n <=\
    \ 10\n        n\n    else\n        count(n) - sum(starts_one_ends(x - 10) for\
    \ x in starts_one_ends(10))\n    end\nend\n\"\"\"\nGiven a positive integer n,\
    \ return all the n-digit positive\n    integers that start or end with 1.\n  \
    \  \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: cannot document the following expression:\n\nusing Test\n\
    \nStacktrace:\n [1] error(::String, ::String)\n   @ Base ./error.jl:42\n [2] top-level\
    \ scope\n   @ /tmp/tmpfg9k9eqj.jl:14\nin expression starting at /tmp/tmpfg9k9eqj.jl:14\n"
  stdout: ''
  timestamp: 1660003970
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 1 \n        then 0 \n    else\
    \ \n        counts_one_ends(n-1) \n    end\nend\n\"\"\"\n    We use these functions\
    \ to count the number of numbers from 1 to n\n    which start or end with 1.\n\
    using Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"0\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpn8q5udpq.jl:7\nin expression starting at /tmp/tmpn8q5udpq.jl:7\n"
  stdout: ''
  timestamp: 1660003969
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 0 \n        then 0\n    else\
    \ if n == 1\n        then 1\n    else if n % 10 == 1\n        then 1 + (starts_one_ends(floor(n/10))\
    \ - 1)\n    else if n % 10 == 2\n        then 1 + (starts_one_ends(floor(n/10))\
    \ - 1) + starts_one_ends(floor(n/100))\n    else if n % 10 == 3\n        then\
    \ 1 + (starts_one_ends(floor(n/10)) - 1) + starts_one_ends(floor(n/100)) + (starts_one_ends(floor(n/1000))\
    \ - 1) \n    else \n        1 + (starts_one_ends(floor(n/10)) - 1) + starts_one_ends(floor(n/100))\
    \ + (starts_one_ends(floor(n/1000)) - 1) + starts_one_ends(floor(n/10000)) - 1\
    \ \nend\n</cell>\n<code language=julia-1.6>\n@time starts_one_ends(1_000_000_000);\n\
    </cell>\n<text>\nThe previous result was in seconds, which was about a minute,\
    \ which is certainly not enough to count all prime numbers between 1 and 1,000,000,000.\
    \  We can also do better:\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"0\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpghfcl0vy.jl:7\nin expression starting at /tmp/tmpghfcl0vy.jl:7\n"
  stdout: ''
  timestamp: 1660003969
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n<0 \n        return 0 \n    else\
    \ \n        return (n//100)==(n%100//10)==(n%100%10)==1\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp82zn7kgc.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp82zn7kgc.jl:1\n\
    in expression starting at /tmp/tmp82zn7kgc.jl:1\n"
  stdout: ''
  timestamp: 1660003969
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n  if n < 0 then 0 else countOnes(min(n,1000))\
    \ + 1\nend\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"0\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpsxqghz51.jl:6\nin expression starting at /tmp/tmpsxqghz51.jl:6\n"
  stdout: ''
  timestamp: 1660003969
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 1 \n        return 0 \n    n -=\
    \ 1\n    count = 0\n    while n > 1 \n        count += n \n        n /= 10 \n\
    \    return count\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"while\" at /tmp/tmpthibr1de.jl:10\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpthibr1de.jl:1\n\
    in expression starting at /tmp/tmpthibr1de.jl:1\n"
  stdout: ''
  timestamp: 1660003970
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 10 \n        then return 1 \n\
    \        else return 0\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpbwyd3_tc.jl:7\nin expression starting at /tmp/tmpbwyd3_tc.jl:7\n"
  stdout: ''
  timestamp: 1660003970
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n<0 \n    then 0 \n    else count_digits(n)\
    \ \n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"0\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpyx43aesy.jl:7\nin expression starting at /tmp/tmpyx43aesy.jl:7\n"
  stdout: ''
  timestamp: 1660003970
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n <= 0\n        then return 0\n  \
    \  else \n        sum = 0\n        for i in 1 .. n\n            if i % 10 == 1\n\
    \                then return sum\n            else sum += 1 \n    end\nend\n</cell>\n\
    <code language=julia-0.6>\n@assert starts_one_ends(0) == 0\n@assert starts_one_ends(1)\
    \ == 0\n@assert starts_one_ends(2) == 1\n@assert starts_one_ends(3) == 2\n@assert\
    \ starts_one_ends(4) == 1\n@assert starts_one_ends(5) == 2\n@assert starts_one_ends(10)\
    \ == 3\n@assert starts_one_ends(17) == 4\n@assert starts_one_ends(24) == 3\n@assert\
    \ starts_one_ends(100) == 4\n@assert starts_one_ends(999) == 4\n@assert starts_one_ends(1000)\
    \ == 4\n@assert starts_one_ends(10000) == 5\n@assert starts_one_ends(100000) ==\
    \ 5\n@assert starts_one_ends(1000000) == 5\n@assert starts_one_ends(100000000)\
    \ == 6\n@assert starts_one_ends(1000000000) == 6\n</cell>\n<text>\n12. Counting\
    \ congruences in the Fibonacci sequence\nA common interview question is:\nusing\
    \ Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpkvqv_nwe.jl:7\nin expression starting at /tmp/tmpkvqv_nwe.jl:7\n"
  stdout: ''
  timestamp: 1660003970
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 0 \n        error(\"negative argument\
    \ to starts_one_ends\")\n    ends_one_starts(n)\nend\n</cell>\n<code language=julia-1.1>\n\
    ## now let's test our implementation\nstarts_one_ends(10)\n</cell>\n<text>\nTo\
    \ make our counting function more efficient, we'll memoize it. This will let us\
    \ run it multiple times with different arguments, saving us the overhead of repeatedly\
    \ searching for the same combination in our hash table. Let's write this in Julia\
    \ syntax and then explain what it's doing:\nusing Test\n\n@testset begin\n\ncandidate\
    \ = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\
    \t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpg04_yy2e.jl:10\nin expression starting at\
    \ /tmp/tmpg04_yy2e.jl:10\n"
  stdout: ''
  timestamp: 1660003970
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if (n < 1) \n        return 0\n    if\
    \ (n == 1) \n        return 1\n    return 1 + starts_one_ends(floor((n + 1) /\
    \ 2))\nend\n</cell>\n<code language=julia-1.5>\nstarts_one_ends(1)\n</cell>\n\
    <code language=julia-1.5>\nstarts_one_ends(10)\n</cell>\n<code language=julia-1.5>\n\
    starts_one_ends(100)\n</cell>\n<code language=julia-1.5>\nstarts_one_ends(1000)\n\
    </cell>\n<code language=julia-1.5>\nstarts_one_ends(10000)\n</cell>\n<text>\n\
    Problem 3\nA generator function can easily produce an infinite sequence of numbers.\
    \ For instance, if we use an infinite list of numbers between 1 and 100, we can\
    \ compute the sum of the numbers up to $n$.\nusing Test\n\n@testset begin\n\n\
    candidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0n7qv163.jl:12\nin expression starting at\
    \ /tmp/tmp0n7qv163.jl:12\n"
  stdout: ''
  timestamp: 1660003970
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    \"\"\"\n    Given a positive integer\
    \ n, return the count of the numbers of n-digit\n    positive integers that start\
    \ or end with 1.\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpngs68mmr.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpngs68mmr.jl:1\n\
    in expression starting at /tmp/tmpngs68mmr.jl:1\n"
  stdout: ''
  timestamp: 1660003959
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 0 \n        return 0 \n    else\
    \ if n == 1 \n        return 1 \n    else \n        return starts_one_ends(n-1)\
    \ + ends_one_starts(n-1) \nend\n\"\"\"\n    Given a positive integer n, return\
    \ the count of the numbers of n-digit\n    positive integers that end with 1.\n\
    \    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t\
    @test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) ==\
    \ 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7qhig16g.jl:8\nin expression starting at /tmp/tmp7qhig16g.jl:8\n"
  stdout: ''
  timestamp: 1660003970
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n <= 0 \n        return -1\n    if\
    \ n == 1 \n        return 1\n    return starts_one_ends(n-1) + ends_one_starts(n-1)\n\
    using Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpg89o5oiz.jl:1\nin expression starting at /tmp/tmpg89o5oiz.jl:1\n"
  stdout: ''
  timestamp: 1660003970
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 0 \n        then 1\n        else\
    \ sum(starts_one_ends(i-1) for i in 1 .. n) \nend\n</cell>\n<code language=julia-1.5>\n\
    starts_one_ends(10)\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"1\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpebnjfa6x.jl:7\nin expression starting at /tmp/tmpebnjfa6x.jl:7\n"
  stdout: ''
  timestamp: 1660003970
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n  if n == 0 \n    else \n      if n == 1\
    \ \n        then 1 \n        else starts_one_ends(n-1) + ends_one_starts(n-1)\
    \ \n  else \n    starts_one_ends(n-1) + ends_one_starts(n-1)\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\
    \t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"1\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp9f2n90xo.jl:9\nin expression starting at /tmp/tmp9f2n90xo.jl:9\n"
  stdout: ''
  timestamp: 1660003971
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    count::Int64 = 0\n    for x in 1..n\n\
    \        if x == 1\n            count += 1\n        end\n    end\n    return count\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,
    0 broken.

    in expression starting at /tmp/tmptaxois5n.jl:16

    '
  stdout: "test set: Error During Test at /tmp/tmptaxois5n.jl:19\n  Test threw exception\n\
    \  Expression: candidate(1) == 1\n  UndefVarError: .. not defined\n  Stacktrace:\n\
    \   [1] starts_one_ends(n::Int64)\n     @ Main /tmp/tmptaxois5n.jl:7\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmptaxois5n.jl:19 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmptaxois5n.jl:18\ntest set:\
    \ Error During Test at /tmp/tmptaxois5n.jl:20\n  Test threw exception\n  Expression:\
    \ candidate(2) == 18\n  UndefVarError: .. not defined\n  Stacktrace:\n   [1] starts_one_ends(n::Int64)\n\
    \     @ Main /tmp/tmptaxois5n.jl:7\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmptaxois5n.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmptaxois5n.jl:18\ntest set:\
    \ Error During Test at /tmp/tmptaxois5n.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(3) == 180\n  UndefVarError: .. not defined\n  Stacktrace:\n   [1]\
    \ starts_one_ends(n::Int64)\n     @ Main /tmp/tmptaxois5n.jl:7\n   [2] macro expansion\n\
    \     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \   [3] macro expansion\n     @ /tmp/tmptaxois5n.jl:21 [inlined]\n   [4] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmptaxois5n.jl:18\ntest set:\
    \ Error During Test at /tmp/tmptaxois5n.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(4) == 1800\n  UndefVarError: .. not defined\n  Stacktrace:\n   [1]\
    \ starts_one_ends(n::Int64)\n     @ Main /tmp/tmptaxois5n.jl:7\n   [2] macro expansion\n\
    \     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \   [3] macro expansion\n     @ /tmp/tmptaxois5n."
  timestamp: 1660003972
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 10 \n        then 1 else 0\n \
    \   else if n == 1\n        then starts_one_ends(n-1) else starts_one_ends(n-1)\
    \ + starts_one_ends(n-2)\nend\n\"\"\"\n    Use this function to count all n-digit\
    \ positive integers that start or end\n    with 1.\n    \"\"\"\nusing Test\n\n\
    @testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t\
    @test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"1\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpahg298ui.jl:7\nin expression starting at /tmp/tmpahg298ui.jl:7\n"
  stdout: ''
  timestamp: 1660003971
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n==0\n        then return 0\n    else\
    \ return count((1,n),(1,n))\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t\
    @test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpegik4ljw.jl:7\nin expression starting at /tmp/tmpegik4ljw.jl:7\n"
  stdout: ''
  timestamp: 1660003971
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    return sum(map(lambda x: (x==1) or (x==-(n-1)),\
    \ range(1,n)))\nend\n</cell>\n<cell>\nstarts_one_ends(9::Int64)\n</cell>\n<text>\n\
    The count of fibonacci numbers that start with 1 or end with 1 is $C(F(1) + F(2),\
    \ 2)$.\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpn84sgnef.jl:6\nin expression starting at /tmp/tmpn84sgnef.jl:6\n"
  stdout: ''
  timestamp: 1660003971
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n<=1\n        count = 0\n    else\n\
    \        count = n_digits(n) - 1\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"\n    Given an even integer n, return the count of the numbers of n-digit\n\
    \    positive integers that start or end with 1.\n    \"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmcjv6smk.jl:12\nin expression starting at\
    \ /tmp/tmpmcjv6smk.jl:12\n"
  stdout: ''
  timestamp: 1660003971
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n==1\n    else if n==-1\n    else\
    \ if n==0\n    else if n>0\n    else if n<0\n    else if n==2\n    else if n==-3\n\
    \    else if n==-2\n    else if n==-1\n    else if n==1\n    else if n==2\n  \
    \  else if n==-3\n    else if n==-2\n    else if n==-1\n    else if n==1\n   \
    \ else if n==2\n    else if n==-3\n    else if n==-2\n    else if n==-1\n    else\
    \ if n==1\n    else if n==2\n    else if n==-3\n    else if n==-2\n    else if\
    \ n==-1\n    else if n==1\n    else if n==2\n    else if n==-3\n    else if n==-2\n\
    \    else if n==-1\n    else if n==1\n    else if n==2\n    else if n==-3\n  \
    \  else if n==-2\n    else if n==-1\n    else if n==1\n    else if n==2\n    else\
    \ if n==-3\n    else if n==-2\n    else if n==-1\n    else if n==1\n    else if\
    \ n==2\n    else if n==-3\n    else if n==-2\n    else if n==-1\n    else if n==1\n\
    \    else if n==2\n    else if n==-3\n    else if n==-2\n    else if n==-1\n \
    \   else if n==1\n    else if n==2\n    else if n==-3\n    else if n==-2\n   \
    \ else if n==-1\n    else if n==1\n    else if n==2\n    else if n==-3\n    else\
    \ if n==-2\n    else if n==-1\n    else if n==1\n    else if n==2\n    else if\
    \ n==-3\n    else if n==-2\n    else if n==-1\n    else if n==1\n    else if n==2\n\
    \    else if n==-3\n    else if n==-2\n    else if n==-1\n    else if n==1\n \
    \   else if n==2\n    else if n==-3\n    else if n==-2\n    else if \nusing Test\n\
    \n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\
    \t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpci782s3x.jl:7\nin expression starting at /tmp/tmpci782s3x.jl:7\n"
  stdout: ''
  timestamp: 1660003971
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 0 \n        error(\"n must be\
    \ positive\", ExitCodes.ExitFailure) \n    else \n        return sum( (n % 10)\
    \ == 1 ) \nend\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\
    \t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3)\
    \ == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpn9w6mk3p.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpn9w6mk3p.jl:1\n\
    in expression starting at /tmp/tmpn9w6mk3p.jl:1\n"
  stdout: ''
  timestamp: 1660003971
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n <= 0\n    then return -1\n    else\
    \ return n / 10 + starts_one_ends(n%10)\n    end\nend\n</cell>\n<code language=julia-1.4>\n\
    starts_one_ends(12321)\n</cell>\n<code language=julia-1.4>\nstarts_one_ends(0)\n\
    </cell>\n<code language=julia-1.4>\nstarts_one_ends(10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n\
    using Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpoulodb3j.jl:7\nin expression starting at /tmp/tmpoulodb3j.jl:7\n"
  stdout: ''
  timestamp: 1660003971
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 0 \n        then return 0\n \
    \       else return counts_starts_one_ends(n-1) + counts_starts_one_ends(n+1)\n\
    \    end\nend\n\"\"\"\nGiven a positive integer n, return the count of the numbers\
    \ of n-digit\npositive integers that start with 0.\n\"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2)\
    \ == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5)\
    \ == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpmrkwpjxd.jl:7\nin expression starting at /tmp/tmpmrkwpjxd.jl:7\n"
  stdout: ''
  timestamp: 1660003971
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n == 0 \n        then return 0\n \
    \   else if n % 2 == 1 \n        then return 1\n    else return 1 + starts_one_ends(n\
    \ / 2)\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
    \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp8qqrarvm.jl:7\nin expression starting at /tmp/tmp8qqrarvm.jl:7\n"
  stdout: ''
  timestamp: 1660003971
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
    \ starts_one_ends(n::Int64)::Int64 \n    if n < 1 \n        return 0 \n    else\
    \ \n        return binomial(n.digits(), 1) + starts_one_ends(n.digits() - 1) \n\
    end \n\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start with 1.\n    \"\"\"\nusing Test\n\
    \n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\
    \t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
    \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpd8ycd2_q.jl:5\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpd8ycd2_q.jl:1\n\
    in expression starting at /tmp/tmpd8ycd2_q.jl:1\n"
  stdout: ''
  timestamp: 1660003971
