name: HumanEval_29_filter_by_prefix
language: jl
prompt: "\"\"\" Filter an input vector of strings only for ones that start with a\
  \ given prefix.\n    >>> filter_by_prefix([], \"a\")\n    []\n    >>> filter_by_prefix([\"\
  abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n    \"\"\"\
  \nfunction filter_by_prefix(strings::Vector{String}, prefix::String)::Vector{String}\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = filter_by_prefix;\n\t@test(candidate(Vector{String}([]),\
  \ \"john\") == Vector{String}([]))\n\t@test(candidate([\"xxx\", \"asd\", \"xxy\"\
  , \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"\
  ])\nend\n"
completions: ['"""', "    \n    for s in strings \n        if startswith(prefix, s)\
    \ \n            yield s \nend \n</cell>\n<code language=julia-1.5>", '    """Filter
    a vector of strings keeping only those that start with the prefix.', "    strings\
    \ = strings[2 .. end(strings)]\n    strings = strings[string.starts_with(prefix,\
    \ 1)]\n    return strings\nend", "  res = []\n  for str in strings\n    if startswith(str,\
    \ prefix)\n      push!(res, str)\n    end\n  end\n  return res\nend\n</cell>\n\
    <cell>\nfilter_by_prefix([\"array\", \"abc\", \"bcd\", \"cde\"], \"a\")\n</cell>\n\
    <text>\nExercise\nWrite a function that removes all the elements of a given vector\
    \ that do not start with a given prefix.", "    \n    if strings == []\n     \
    \   return strings\n    \n    pos = findfirst(prefix in strings, 0)\n    if pos\
    \ < 0\n        return strings\n    \n    begin = pos\n    end = pos + length(prefix)\n\
    \    strings = strings[begin..end]\n    \nend\n</cell>\n<code language=julia-1.5>",
  "    \n    for string in strings\n        if string.starts_with(prefix)\n      \
    \      return string\n    end\n    return strings\nend", "    if length(prefix)\
    \ == 0\n        return strings\n    end\n    \n    prefix_idx = string.find(prefix,\
    \ 1)\n    \n    if prefix_idx == 0 # only partial prefix\n        strings_with_prefix\
    \ = filter_by_prefix(strings, prefix[prefix_idx+length(string):end])\n    else\n\
    \        strings_with_prefix = filter_by_prefix(strings[prefix_idx+1:end], prefix)\n\
    \    end\n    \n    return strings_with_prefix\nend\n</cell>\n<code language=julia-1.5>\n\
    filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n</cell>\n<code\
    \ language=julia-1.5>\nfilter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"ab\")\n</cell>\n<code language=julia-1.5>\nfilter_by_prefix([\"abc\", \"\
    bcd\", \"cde\", \"array\"], \"abcd\")\n</cell>\n<code language=julia-1.5>\nfilter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n</cell>\n<code language=julia-1.5>\n\
    filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"ab\")\n</cell>\n<code\
    \ language=julia-1.5>\nfilter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"abcd\")\n</cell>\n<code language=julia-1.5>\nfilter_by_prefix([\"abc\", \"\
    bcd\", \"cde\", \"array\"], \"acde\")\n</cell>\n<code language=julia-1.5>\nfilter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"adc\")\n</cell>\n<code language=julia-1.5>\n\
    filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"acde\")\n</cell>\n\
    <code language=julia-1.5>\nfilter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"abde\")\n</cell>\n<code language=julia-1.5>", "    if strings == []\n   \
    \     error(\"Input is empty!\")\n    end\n    \n    prefix === strings[1] &&\
    \ return [] \n    prefix === strings[end] && return strings \n    \n    idx =\
    \ 0\n    while idx < length(strings)\n        if idx != 1 && prefix == strings[1]\n\
    \            idx == 1 && return []\n        elseif idx != length(strings) && prefix\
    \ == strings[idx]\n            idx == length(strings) && return []\n        end\n\
    \        idx += 1\n    end\n    \n    return strings\nend\n</cell>\n<code language=julia-1.5>\n\
    # test filter_by_prefix\nfilter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"a\")\n</cell>\n<text>\nPart 2 - The filter and map functions\nIn this section,\
    \ we will show how to use the functions filter and map. They are very useful in\
    \ Julia. First, we will see the examples for filter, which takes a predicate function\
    \ and returns a new vector, while map applies a function to all the elements of\
    \ a vector. In Julia, filter will return a new vector, while map will alter the\
    \ original vector.", "    prefix_filter = startswith(strings, prefix)\n    return\
    \ filter(prefix_filter, strings)\nend", "    map(x -> startswith(x, prefix), strings)\n\
    end\n</cell>\n<text>\nThe filter_by_suffix function allows you to filter an input\
    \ vector of strings only for ones that end with a given suffix.", "    if starts_with(prefix,\
    \ strings[1])\n        return strings\n    else\n        return filter_by_prefix(strings,\
    \ prefix)\nend\n</cell>\n<text>\nAnd now we can write our own function and apply\
    \ it to our array of strings. In a previous exercise we had a pretty short array,\
    \ so we were doing something more iterative than we should. We could do this,\
    \ but what if we had a long array of strings and we wanted to find the longest\
    \ prefix? In that case, we should probably use the iterative version!", "    if\
    \ length(strings) == 0\n        return strings\n    \n    idx = 1\n    while idx\
    \ <= length(strings)\n        if strings[idx-1] == prefix\n            idx +=\
    \ 1\n        else\n            idx += 2\n        end\n    end", "    \"\"\"\n\
    \    >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n   \
    \ [\"abc\", \"array\"]\n    \"\"\"\n    strings = map(i->prefix+i, strings)\n\
    \    return filter(x -> starts_with(x, prefix), strings)\nend", "    if length(strings)\
    \ < 1 || length(strings) > 1\n        error(\"Strings must have length at least\
    \ 2\")\n    end", "    matches = filter(x -> startswith(x, prefix), strings)\n\
    \    if length(strings)==length(matches) \n        return matches\n    else \n\
    \        return filter(x -> !startswith(x, prefix), strings)\nend", "    \n  \
    \  answer = []\n    for s in strings \n        if startswith(prefix, s) \n   \
    \         push!(answer, s)\n        end\n    end\n    \n    return answer\nend\n\
    </cell>\n<text>\nExercise\nWrite a version of the filter_by_prefix function that\
    \ takes a keyword argument for the prefix and removes strings that don't start\
    \ with the prefix. For example, calling filter_by_prefix([\"a\", \"b\", \"c\"\
    , \"d\"], \"a\") would return [\"b\", \"c\"].", "    string_len = length(prefix)\n\
    \    vec_of_strings = strings[:]\n    for string in vec_of_strings:\n        if\
    \ startswith(string, prefix)\n            vec_of_strings = remove(vec_of_strings,\
    \ string)\n        else\n            continue\n        end\n    end\n    return\
    \ vec_of_strings\nend", "    filtered = filter(x -> startswith(prefix, x), strings)\n\
    \    if isempty(filtered)\n        return strings\n    else\n        return filtered\n\
    \    end\nend\n</cell>\n<code language=julia-1.4>\n#export", "    strings = map(x\
    \ -> startswith(prefix, x) ? x : [], strings)\n    return strings\nend", "   \
    \ prefix match {\n        case Prefix(prefix, rest) -> filter(startswith(rest,\
    \ prefix), strings)\n        case prefix -> filter(startswith(strings, prefix),\
    \ strings)\n    }\nend\n</cell>\n<text>\n6. String search\n6.1 String search\n\
    There are several built-in functions in Julia for searching strings. Some of these\
    \ are more efficient than others, and we will explore each of these in more detail\
    \ in the next section.", "    if strings.length <= 0\n        return []\n    if\
    \ prefix == \"\"\n        return strings\n    \n    prefix_idx = 0\n    for idx\
    \ in 1:length(strings)\n        if strings[idx][0] == prefix\n            return\
    \ strings[prefix_idx:idx]\n        prefix_idx = idx\n    end\n    return strings",
  "    return filter_by_prefix_helper(strings, prefix, \"\")\nend", "    if length(prefix)\
    \ == 0\n        return strings\n    \n    result = []\n    for s in strings\n\
    \        if startswith(s,prefix)\n            push!(result,s)\n        end\n \
    \   end\n    return result\nend\n</cell>\n<code language=julia-1.2>\nfilter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n</cell>\n<code language=julia-1.2>\n\
    \"\"\"\n    Return a list of all strings that start with the given prefix.\n \
    \   \n    >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n\
    \    [\"abc\", \"array\"]\n    \n    >>> filter_by_prefix([\"a\",\"a\",\"b\"],\
    \ \"a\")\n    []\n    \n    >>> filter_by_prefix([\"array\", \"bcd\", \"cde\"\
    , \"array\"], \"a\")\n    [\"array\"]\n    \n    >>> filter_by_prefix([\"cde\"\
    , \"bcd\", \"array\"], \"a\")\n    []\n    \n    Only the first occurrence is\
    \ kept.\n    \n    If you have duplicate entries, the first one encountered is\
    \ kept.\n    \n    >>> filter_by_prefix([\"bcd\", \"bcd\", \"cde\", \"array\"\
    ], \"a\")\n    [\"bcd\"]\n    \"\"\"", "    if length(prefix) == 0\n        return\
    \ strings\n    else\n        \n        index = find(startswith(strings, prefix),\
    \ 1) # find first substring that starts with prefix\n        if index == 1\n \
    \           return strings\n        else\n            prefix = prefix[1:] # remove\
    \ prefix from substring \n            strings = strings[index+1:end] # remove\
    \ prefix from rest\n            return filter_by_prefix(strings, prefix) # continue\
    \ iteratively applying recursively\n        end\n    end\nend\n</cell>\n<code\
    \ language=julia-1.0>\n# filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"a\") # ERROR!\nfilter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"\
    ab\")\n</cell>\n<text>\nFilter out strings that end with a given suffix", "  \
    \  \"\"\"Filter an input vector of strings only for ones that start with a given\
    \ prefix.\n    >>> filter_by_prefix([], \"a\")\n    []\n    >>> filter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n    \"\"\
    \"\n    prefixes = map(str_to_prefix, strings)\n    prefixes = prefixes |> Set()\n\
    \    return filter(x->startswith(prefix, x), prefixes)\nend", "    \n    if length(strings)\
    \ == 0 || prefix == \"\"\n        return strings\n    ends_with_prefix = ends_with(prefix,\
    \ strings)\n    if ends_with_prefix\n        return filter_by_prefix(drop(ends_with_prefix,\
    \ 1), prefix, strings)\n    ends_with_prefix_in_first_string = ends_with_prefix\
    \ in strings[1 : length(ends_with_prefix)]\n    if ends_with_prefix_in_first_string\n\
    \        return filter_by_prefix(drop(strings[1 : ends_with_prefix_in_first_string\
    \ + 1], 1), prefix, strings)\n    ends_with_prefix_in_all_strings = ends_with_prefix\
    \ in strings\n    if ends_with_prefix_in_all_strings\n        return filter_by_prefix(drop(strings,\
    \ 1), prefix, strings)\n    ends_with_prefix_in_any_string = any(ends_with_prefix\
    \ in string for string in strings)\n    if ends_with_prefix_in_any_string\n  \
    \      return filter_by_prefix(drop(strings, 1), prefix, strings)\n    ends_with_prefix_in_all_strings_or_empty\
    \ = ends_with_prefix_in_all_strings or length(drop(strings, 1)) == 0\n    if ends_with_prefix_in_all_strings_or_empty\n\
    \        return strings\n    ends_with_prefix_in_any_string_or_empty = any(ends_with_prefix\
    \ in string for string in drop(strings, 1))\n    if ends_with_prefix_in_any_string_or_empty\n\
    \        return strings\n    else\n        return strings\n    end\nend", "  \
    \  filtered = filter((x) -> startswith(x, prefix), strings)\n    if length(filtered)\
    \ == 0 \n        throw(ArgumentError(\"String does not start with prefix: $prefix\"\
    ))\n    end\n    return filtered\nend", "    if length(prefix) == 0 || length(prefix)\
    \ > length(prefix[2:end]) || prefix[2:end] ~= prefix\n        throw(ArgumentError(\"\
    invalid prefix: $prefix\"))\n    end\n    filter!(strings, x -> startswith(prefix,\
    \ x))\nend\n</cell>\n<text>\nfilter_by_prefix! accepts an input vector of strings,\
    \ an optional prefix string and a function as the last argument. In the function\
    \ body we call filter! and then return all the strings that match the prefix.",
  "    filtered_strings = filter(x->startswith(x,prefix), strings)\n    if isempty(filtered_strings)\n\
    \        return strings\n    else\n        return filtered_strings\n    end\n\
    end\n</cell>\n<code language=julia-1.5>", "    strings = [\n        i for i in\
    \ strings if \n        startswithprefix(i, prefix)\n    ]\n    return strings\n\
    end\n</cell>\n<code language=julia-0.4>\nfilter_by_prefix([\"abc\", \"bcd\", \"\
    cde\", \"array\"], \"a\")\n</cell>\n<code language=julia-0.4>\nfilter_by_prefix(collect(strings),\
    \ \"a\")\n</cell>\n<code language=julia-0.4>\nfilter_by_prefix(collect(strings),\
    \ \"A\")\n</cell>\n<text>\nThe prefix function will accept a prefix as a String\
    \ or as a vector of Strings. If the prefix is a vector, all strings contained\
    \ in it will be returned.", "    if prefix != \"\" && prefix in strings\n    \
    \    indices_to_keep = findall(str -> str == prefix, strings)\n        new_strings\
    \ = filter!(str -> !indices_to_keep.contains(contains(str, prefix)), strings)\n\
    \        return new_strings\n    end\n    strings\nend", "        \n    for string\
    \ in strings \n        if string.starts_with!(prefix) \n            return string\
    \ \n    end\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\n# Filtering out\
    \ the array elements starting with the character passed as a parameter to the\
    \ function.\n# If the character passed as a parameter is not present in the string\
    \ then the function will return an empty array. ", "    filter!(x -> startswith(prefix,\
    \ x), strings)\nend", "    matches = map(string -> startswith(string, prefix),\
    \ strings)\n    strings = filter(matches -> length(matches) >= 1, strings)\n \
    \   return strings\nend", "    if prefix not in map(str, strings)\n        return\
    \ strings\n    else\n        start = filter(x -> startswith(x, prefix), strings)\n\
    \        return start\n    end\nend\n</cell>\n<code language=julia-0.5>\nfilter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n</cell>\n<text>\nExercise", "   \
    \ # Make sure that the prefix is prepended to each string in the list \n    new_strings\
    \ = map(prepend!(prefix, string), strings)\n    # Return an vector with the filtered\
    \ strings\n    return new_strings\nend", "        prefix = prefix[1:end-1]\n \
    \       filtered_strings = filter(elem -> elem == prefix, strings)\n        return\
    \ filtered_strings\nend", "    for i in (1:length(strings))\n        if strings[i]\
    \ == prefix || strings[i] == '*'\n            delete!(strings, i)\n        else\n\
    \        end\n    end\n    return strings\nend\n</cell>\n<code language=julia-1.0>\n\
    filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n</cell>\n<text>\n\
    We can also add wildcards ('*') to our filters. We will add this functionality\
    \ to a function we will call filter_by_wildcard later.", "    if prefix == \"\"\
    \n        strings\n    else\n        filter(x -> startswith(x, prefix), strings)\n\
    \    end\nend", "    \n    for x in strings \n        if x.startsWith(prefix)\n\
    \            push!(strings, x)\n        end\n    end\n    strings\nend\n</cell>\n\
    <code language=julia-1.5>\nfilter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"a\")\n</cell>\n<code language=julia-1.5>\nfilter_by_prefix([\"a1\", \"bcd\"\
    , \"cde\"], \"a\")\n</cell>\n<text>\nExercise 3\nDefine a function filter_substrings(strings::Vector{String},\
    \ substring::String)::Vector{String} that filters strings by whether they contain\
    \ all of the substring. For example, filter_substrings([\"abc\", \"bcd\", \"cde\"\
    , \"array\"], \"a\") should return [\"abc\", \"array\"]. Note that \"bcd\" is\
    \ not part of the result because \"bcd\" does not contain \"a\".", "    \n   \
    \ if length(strings)<=1\n        return strings\n    end\n    \n    prefix_length\
    \ = length(prefix)\n    \n    filtered = copy(strings)\n    for string in strings\
    \ \n        if string[1:prefix_length] == prefix \n            push!(filtered,\
    \ string)\n        end\n    end\n    \n    return filtered\nend", "    matches\
    \ = filter((x -> starts_with(x, prefix)), strings)\n    lengths = map(length,\
    \ matches)\n    max_index = get_max_index(lengths)\n    substrings = map(x->strings[max_index],\
    \ matches)\n    return substrings\nend\n</cell>\n<text>\n6. Optional Filters\n\
    The optional filter is useful for filtering out unwanted elements. For example,\
    \ we can filter the optional list to exclude any strings that are longer than\
    \ 7 characters. We can use the length() function to get the length of the strings,\
    \ and then filter by selecting only those strings that are longer than 7 characters.",
  "    if prefix == \"\"\n        strings; return strings\n    endpos = size(strings)\n\
    \    i = 1;\n    while i <= endpos\n        if strings[i-1] == prefix\n      \
    \      endpos = i\n        else\n            i += 1\n        end\n    end\n  \
    \  strings[end-2 : end]\nend\n</cell>\n<code language=julia-0.4>\nfilter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n</cell>\n<text>\nChallenge 12 (Optional)\n\
    Given two lists of strings, A and B, write a function that produces the string\
    \ that is the concatenation of A concatenated with B, separated by spaces. Use\
    \ a space character instead of a comma.", "    \n    if isempty(strings) || isempty(prefix)\n\
    \        return strings\n    end", "    if length(strings) == 0\n        return\
    \ strings\n    if prefix != \"\"\n        string = strings[1]\n        if string.startswith(prefix)\n\
    \            string = strings[end-1]\n        else\n            string = strings[1]\n\
    \        end\n        strings[1] = string\n    end\n    return strings\nend\n\
    </cell>\n<text>\nFilter a vector for strings that end with a given suffix.\nThe\
    \ last element of the vector is assumed to be an empty string.", "    \n    return\
    \ ifelse(startswith(prefix, strings), strings, string)\nend", "    filtered =\
    \ filter(x->starts_with(x, prefix), strings)\n    Vector(filtered)\nend", "  strings\
    \ = [i for i in strings if i.startswith(prefix)]\n  return strings\nend", "  \
    \  strings = filter(x -> starts_with(x, prefix), strings)\nend\n</cell>\n<code\
    \ language=julia-1.4>\nfilter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"a\")\n</cell>\n<code language=julia-1.4>\nfilter_by_prefix([\"abc\", \"bcd\"\
    , \"cde\", \"array\"], \"ab\")\n</cell>\n<text>\nExercise 10\nThe function filter_by_suffix\
    \ should only keep elements of a vector that end with a given suffix.", "    filter(x\
    \ -> startswith(x, prefix), strings)\nend\n</cell>\n<text>\nfilter_by_suffix\n\
    Like filter_by_prefix, but for suffixes.", "    idx = starts_with(strings, prefix)\n\
    \    strings = strings[idx]\n    return strings\nend", "    string_prefix = prefix::String\n\
    \    filtered = Vector{String}()\n    for *string in strings\n        if(string_prefix\
    \ != \"\" && !string.startswith(string_prefix))\n            continue\n      \
    \  push!(filtered, string)\n    end\n    return filtered\nend", "    if !all(startsWith(prefix,\
    \ string) for string in strings)\n        return strings\n    \n    for string\
    \ in strings \n        if startsWith(prefix, string) || startsWith(string(length),\
    \ prefix)\n            strings -= [string]\n        end\n    end\n    strings\n\
    end\n</cell>\n<code language=julia-1.3>\nfilter_by_prefix([\"abc\", \"bcd\", \"\
    cde\", \"array\"], \"a\")\n</cell>\n<code language=julia-1.3>\nfilter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n</cell>\n<code language=julia-1.3>\n\
    filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"b\")\n</cell>\n<code\
    \ language=julia-1.3>\nfilter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"a\")\n</cell>\n<code language=julia-1.3>\nusing PyCall\n@pyimport torch\n\
    @pytorch.set_num_threads(1)", "    strings = strings[...]\n    for i in eachindex(strings)\n\
    \        if starts_with(strings[i], prefix)\n            strings[i] = \"\"\n \
    \       end\n    end\n    return strings\nend", "    \"\"\"Filter an input vector\
    \ of strings only for ones that start with a given prefix.\n    \"\"\"\n    return\
    \ filter_by_prefix(strings, prefix, \"\")\nend", "    \n    prefix_length = length(prefix)\n\
    \    \n    strings = [string for string in strings if string.starts_with(prefix)]\n\
    \    \n    if prefix_length > 0\n        strings = filter_by_prefix(strings, prefix[prefix_length+1:end])\n\
    \    end\n    \n    return strings\nend\n</cell>\n<text>\nmap()\nApply a function\
    \ elementwise to a vector/matrix of inputs.", "    if prefix == \"\"\n       \
    \ strings \n    else\n        filter(x -> starts_with(x, prefix), strings)\n \
    \   end\nend\n</cell>\n<code language=julia-1.1>\nfilter_by_prefix([\"abc\", \"\
    bcd\", \"cde\", \"array\"], \"a\")\n</cell>\n<code language=julia-1.1>", "   \
    \ if is_empty(strings) || is_empty(prefix) then return strings \n    else return\
    \ strings[startswith(strings, prefix)]\nend\n</cell>\n<text>\nAnd now we are ready\
    \ to combine it all together to make our own filter_by_prefix function!", "  \
    \  strings = strings.filter(s -> startswith(s, prefix))\n    return strings\n\
    end\n</cell>\n<text>\nThe following cell displays two example strings and the\
    \ new filtered one:", '    # Write your code here.', "    filtered = filter( string\
    \ -> string.startsWith(prefix), strings )\n    if length(filtered) == 0 \n   \
    \     throw(string(\"No string starting with $prefix\"))\n    end\n    return\
    \ filtered\nend", "    strings[begin(prefix) .. end(strings)] \nend\n</cell>\n\
    <text>\n5. Combining multiple filter functions \nWe can combine multiple filter\
    \ functions using the function filter_all that takes a vector of functions as\
    \ an input. This function returns the vector of results for each function call:",
  "    prefixes = Vector{String}()\n    for s in strings\n        if starts_with(s,\
    \ prefix)\n            push!(prefixes, s)\n        end\n    end\n    return prefixes\n\
    end", "    if prefix != \"\" && prefix != prefix[1]\n        prefix = prefix[1]\n\
    \    end\n    for i in 1 : length(strings)\n        if startswith(string(strings[i]),\
    \ prefix)\n            strings[i] = \"\"\n        end\n    end\n    return strings\n\
    end\n</cell>\n<code language=julia-1.5>\nfilter_by_prefix([\"abc\", \"bcd\", \"\
    cde\", \"array\"], \"a\")\n</cell>\n<text>\nThe filter_by_suffix function does\
    \ the opposite: filters all strings ending with given suffix.", "    \n    prefix_len\
    \ = len(prefix)\n    \n    if prefix_len == 0 \n        return strings \n    ends\
    \ = zip(strings[2:end-1], strings[2:end])\n    \n    return filter((x::String)\
    \ => startswith(prefix, x)) \nend\n</cell>\n<code language=julia-1.4>\nfilter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n</cell>\n<code language=julia-1.4>\n\
    filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"c\")\n</cell>\n<code\
    \ language=julia-1.4>\nfilter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"bcd\")\n</cell>\n<text>\n@filter", "    if !isa(strings, Vector{String})\
    \ || length(prefix) == 0 || prefix == \"\"\n        return strings\n    end\n\
    \    prefix_idx = findfirst(isequal(prefix), strings)\n    if prefix_idx != -1\n\
    \        idx = prefix_idx\n        rem = strings[prefix_idx+length(prefix):end]\n\
    \        return filter_by_prefix(rem, prefix)\n    end\n    return strings\nend",
  "    \"\"\"Filter an input vector of strings only for ones that start with a given\
    \ prefix.\n    >>> filter_by_prefix([], \"a\")\n    []\n    >>> filter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n    \"\"\
    \"\n    \n    strings = [s for s in strings if s.startsWith(prefix)]\n    \n \
    \   return strings", "    prefix = lowercase(prefix)\n    result = Vector{String}()\n\
    \    for string in strings\n        if string.startswith(prefix)\n           \
    \ push!(result, string)\n        end\n    end\n    return result\nend\n</cell>\n\
    <text>\nExercise 2\nWrite a filter function that filters two vectors simultaneously.\n\
    The first vector will contain the strings you want to filter, the second vector\
    \ will contain the prefixes of strings you want filtered for (i.e., the vectors\
    \ should have the same length).", "    result = Vector{String}()\n    for s in\
    \ strings \n        if startswith(s, prefix)\n            push!(result, s)\n \
    \       end\n    end\n    return result\nend", "    filtered_strings = Vector{String}()\n\
    \    for string in strings\n        if string.starts_with(prefix)\n          \
    \  push!(filtered_strings, string)\n        end\n    end\n    return filtered_strings\n\
    end", "    filter!(x -> startswith(x, prefix), strings)\nend", "    for i in eachindex(strings)\n\
    \        if prefix == strings[i][1]\n            return strings\n    end\n   \
    \ return []\nend", "    filter(s -> startswith(s,prefix), strings)\nend", "  \
    \  prefix <- String(prefix)\n    result = new_{T}(strings)\n    for elt in strings\n\
    \        if startswith(elt, prefix)\n            push!(result, elt)\n        else\n\
    \            push!(result, elt)\n    end\n    return result\nend\n</cell>\n<code\
    \ language=julia-1.1>\nfilter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"ab\")\n</cell>\n<text>\n2. How many times an element appears in the array?",
  '    return filter(string -> starts_with(string,prefix), strings)', "    filter!(x\
    \ -> startswith(prefix, x), strings)\nend\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that filters an array of numbers by only keeping those which satisfy\
    \ a given condition.\nFor example, the following code filters out numbers that\
    \ do not have 5 digits:", "    to_return = Vector{String}()\n    for s in strings\n\
    \        if startswith(s,prefix) \n            push!(to_return, s)\n        end\n\
    \    end\n    return to_return\nend\n</cell>\n<code language=julia-1.5>\n# Test\
    \ filter_by_prefix()\nprintln(filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"\
    array\"], \"a\"))\nprintln(filter_by_prefix([\"ab\", \"bcd\", \"cde\", \"array\"\
    ], \"a\"))\nprintln(filter_by_prefix([\"ab\", \"abc\", \"cde\", \"array\"], \"\
    a\"))\n</cell>\n<text>\nmap()\nSimilar to an apply function in other languages,\
    \ map() transforms a function on every element of a vector/matrix/array.", " \
    \   filter_strings = map(x->startswith(x,prefix), strings) \n    filter_strings\
    \ = [str for str in filter_strings if str != \"\"]\n    return filter_strings\n\
    end", "    matcher = startswith(prefix)\n    return filter(matcher, strings)\n\
    end", "    \"\"\"Filter a vector of strings only for those that start with a given\
    \ prefix.\n    \"\"\"\nend", "        filtered = filter(x->startswith(prefix,x),\
    \ strings)\n        \n        return collect(filtered)\n    end\nend # filter_by_prefix",
  "    if length(prefix) == 0 \n        return strings \n    else \n        prefix\
    \ = prefix[1:end-1]\n    \n        filter_strings = []\n        for string in\
    \ strings \n            if string.startswith(prefix) \n                filter_strings.push(string)\
    \ \n            end \n        \n        return filter_strings\nend\n</cell>\n\
    <text>\nFilter a matrix for those rows that start with a given prefix.\nThis function\
    \ takes a matrix and a list of strings as parameters. \nIf the given prefix is\
    \ not found, it returns an empty matrix and the error message.\nIf the given prefix\
    \ is found, it filters the matrix by removing all rows that do not start with\
    \ the given prefix.\nFinally, it returns the filtered matrix and the error message.",
  "    # filter_by_prefix(filter(startswith(prefix), \"strings\"), prefix)\n    return\
    \ filter(x->startswith(prefix, x), strings)\nend\n</cell>\n<code language=julia-1.5>\n\
    filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n</cell>\n<text>\n\
    Filter based on a function", "    for s in strings\n        if startswith(s, prefix)\n\
    \            push!(result, s)\n        end\n    end\n    return result\nend\n\
    </cell>\n<text>\nAnd again, a function which takes in a vector of strings and\
    \ a prefix and returns the vectors of strings that are substrings of that prefix,\
    \ in any order.", "    if !strings or !prefix\n        return strings\n    ends_with_prefix\
    \ = true\n    for s in strings\n        if !hasPrefix(s, prefix)\n           \
    \ ends_with_prefix = false\n            break\n        end\n    end\n    if ends_with_prefix\n\
    \        return filter(s -> !hasPrefix(s, prefix), strings)\n    else\n      \
    \  return strings\n    end\nend\n</cell>\n<code language=julia-1.5>\n@test filter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\") === [\"abc\", \"array\"]\n</cell>\n\
    <text>\nfilter_by_prefix!()", "    if isempty(strings)\n        return strings\n\
    \    else\n        return filter(x -> starts_with(x, prefix), strings)\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\nfilter_by_prefix([\"abc\", \"bcd\", \"\
    cde\", \"array\"], \"a\")\n</cell>\n<code language=julia-1.5>", "    filter(x\
    \ -> startswith(x, prefix), strings)\nend", "    strings = [x for x in strings\
    \ if x.startsWith(prefix)]\n    return strings\nend", "    strings = [s for s\
    \ in strings if startswith(s,prefix)]\n    \n    return strings\nend", "    return\
    \ filter(x->startswith(x, prefix), strings)\nend\n</cell>\n<code language=julia-1.5>\n\
    # We will use this later when creating a list of input strings to filter by.\n\
    input_strings = [\n    \"abc\",\n    \"bcd\",\n    \"cde\",\n    \"array\"\n]\n\
    </cell>\n<code language=julia-1.5>\nfilter_by_prefix(input_strings, \"a\")\n</cell>\n\
    <code language=julia-1.5>\nfilter_by_prefix(input_strings, \"array\")\n</cell>\n\
    <code language=julia-1.5>\nfilter_by_prefix(input_strings, \"ab\")\n</cell>\n\
    <code language=julia-1.5>\nfilter_by_prefix(input_strings, \"abd\")\n</cell>\n\
    <code language=julia-1.5>\nfilter_by_prefix(input_strings, \"abde\")\n</cell>\n\
    <text>\nExercise 2\nWrite a function called filter_by_prefix_and_suffix that takes\
    \ an input vector of strings, and a prefix and suffix string, and returns the\
    \ strings in that vector that start with the prefix and end with the suffix. For\
    \ example, filter_by_prefix_and_suffix(input_strings, \"a\", \"e\") should return\
    \ [\"abc\", \"cde\"].", "    strings[prefix === strings[end]] \nend\n</cell>\n\
    <text>\nThe filter function has three outputs. The first is the filtered input\
    \ strings. The second is the unfiltered input strings, and finally, the output\
    \ from the filter function is a tuple with a number of elements (one for each\
    \ input string) that satisfied the filtering criteria.", "    strings = filter(string\
    \ -> startswith(string, prefix), strings)\n    return strings\nend\n</cell>\n\
    <code language=julia-0.5>\n# Example - find all of the strings in \"words\" that\
    \ start with a specific letter ", "    filter!(x -> startswith(x, prefix), strings)\n\
    end", "    strings = [s for s in strings if startswith(s, prefix)]\nend", "  \
    \  \n    prefix = String(prefix)", "    return filter(prefix in strings, strings)\n\
    end\n</cell>\n<code language=julia-1.5>\n# Test your filter_by_prefix function\
    \ below.\n@test filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\"\
    ) === [\"abc\", \"array\"]\n@test filter_by_prefix([\"abc\", \"bcd\", \"cde\"\
    , \"array\"], \"bc\") === []\n@test filter_by_prefix([\"abc\", \"bcd\", \"cde\"\
    , \"array\"], \"array\") === [\"array\"]\n</cell>\n<text>\nFinding all elements\
    \ in a given vector that are divisible by a given number\nTo find all elements\
    \ of vec that are divisible by a given number N, one can use filter with the following\
    \ function which takes two arguments:", "\"\"\"Filter an input vector of strings\
    \ only for ones that start with a given prefix.\n    >>> filter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n\"\"\"",
  "    if is_nil(strings) || is_nil(prefix)\n        return strings\n    end", " \
    \   if length(prefix) == 0\n        return strings\n    if length(strings) ==\
    \ 0\n        return strings\n    ends_with_prefix = false\n    for s in strings\n\
    \        if startswith(s, prefix)\n            return strings\n        ends_with_prefix\
    \ = true\n    end\n    if ends_with_prefix\n        return strings\n    end\n\
    \    return []\nend", "    \"\"\"Filter an input vector of strings only for ones\
    \ that start with a given prefix.\"\"\"\n    \n    for s in strings\n        if\
    \ starts_with(s,prefix)\n            return s\n    end\nend", "    if length(strings)\
    \ < 1 || prefix === \"\"\n        return strings\n    endIdx = find_last_index(prefix,\
    \ strings)\n    \n    # filter out everything before the last index\n    return\
    \ strings[begin:endIdx+1]\nend", "    \"\"\"Filter a string vector of strings\
    \ only for ones that start with a given prefix.\n    >>> filter_by_prefix([],\
    \ \"a\")\n    []\n    >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"a\")\n    [\"abc\", \"array\"]\n    \"\"\"\nend\n</cell>\n<code language=julia-1.5>\n\
    # Create a function that will split a string into its components", "    if length(strings)\
    \ < 1\n        return strings\n    if length(strings) == 1\n        return [strings[0]]\n\
    \    if prefix == \"\"\n        return strings\n    if prefix == strings[1]\n\
    \        return strings[2:end]\n    else\n        return [prefix | strings[1]]\
    \ +  filter_by_prefix(strings[2:end], prefix)\nend\n</cell>\n<text>\nFiltering\
    \ by Suffix:\nFilter an input vector of strings only for ones that end with a\
    \ given suffix.\n>>> filter_by_suffix([], \"a\")\n[]\n>>> filter_by_suffix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n[\"abc\"]\n>>> filter_by_suffix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"cde\")\n[\"abc\", \"array\"]\n>>> filter_by_suffix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"b\")\n[]\n>>> filter_by_suffix([\"abc\"\
    , \"bcd\", \"cde\", \"array\"], \"b\")\n[\"bcd\", \"array\"]\n>>> filter_by_suffix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"array\")\n[\"array\"]\n</text>\n<code language=julia-1.6>",
  "    prefix_length = len(prefix)\n    prefix_strings = filter(x-> length(x) == prefix_length,\
    \ strings)\n    prefix_filtered_strings = filter(x-> startswith(prefix,  x), prefix_strings)\n\
    \    \n    filtered_strings = filter(x-> length(x) != prefix_length, prefix_filtered_strings)\n\
    \    \n    return filtered_strings", "        prefix = lowercase(prefix)\n   \
    \     \n        result = []\n        for s in strings\n            if lowercase(s)\
    \ startswith prefix\n                push!(result, s)\n            end\n     \
    \   end\n        return result\n    end\n    ", "    filter(s -> starts_with(s,\
    \ prefix), strings)\nend", "    filter(strings, function(s)->startswith(s, prefix))\n\
    end", "    return [string for string in strings \n            if string.startswith(prefix)]",
  "    filter(x->startswith(x, prefix), strings)\nend\n</cell>\n<text>\n5.3.3 filter_by_suffix\n\
    Write a function that filters an input vector of strings only for ones that end\
    \ with a given suffix.\n>>> filter_by_suffix([], \"c\")\n[]\n>>> filter_by_suffix([\"\
    abc\", \"bcd\", \"cde\"], \"c\")\n[\"abc\"]\n>>> filter_by_suffix([\"array\",\
    \ \"array\", \"cde\"], \"c\")\n[\"array\"]\n>>> filter_by_suffix([\"cde\", \"\
    bcd\", \"array\"], \"c\")\n[\"cde\"]\n\"\"\"", "    return filter(s -> startswith(s,prefix),\
    \ strings)\nend", "    \n    for str in strings\n        if str.starts_with(prefix)\n\
    \            push!(filter_list, str)\n        end\n    end", "    filtered_strings\
    \ = copy(strings)\n    for str in strings\n        if startswith(str, prefix)\n\
    \            filtered_strings = remove(str, prefix)\n            break\n    end\n\
    \    return filtered_strings\nend", "    return filter(x -> startswith(prefix,\
    \ x), strings) \nend", "    \"\"\" Filter an input vector of strings only for\
    \ ones that start with a given prefix.\n    >>> filter_by_prefix([], \"a\")\n\
    \    []\n    >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\"\
    )\n    [\"abc\", \"array\"]\n    \"\"\"", "    return filter(x->startswith(prefix,\
    \ x), strings)\nend", "    map( s -> s if s.startsWith(prefix), strings )\nend\n\
    </cell>\n<code language=julia-0.4>\nfilter_by_prefix([\"abc\", \"bcd\", \"cde\"\
    , \"array\"], \"a\")\n</cell>\n<text>\nFilter an input vector of strings only\
    \ for ones that contain words that end with the given suffix\nWe will use this\
    \ to remove the last word of a string that does not end with a suffix of our choice",
  "  prefixes = split(prefix, \"\")\n  for s in strings\n    if all(prefix == prefix\
    \ ? true : s.starts_with(?prefix) for prefix in prefixes)\n      yield s\n   \
    \ end\n  end\nend", "    strings = filter(s -> startswith(s, prefix), strings)\n\
    \    return strings\nend", "\tfilter!(e -> e.starts_with(prefix), strings)\nend\n\
    </cell>\n<text>\nPractice with the function filter_by_prefix", "    if prefix\
    \ == \"\"\n        return strings\n    else \n        return filter_by_prefix(filter_by_prefix(strings,\
    \ prefix[1:]), prefix) \nend", "    for s in strings\n        if startswith(s,prefix)\n\
    \            return s\n    end\n    return []\nend", "    if length(strings) ==\
    \ 0 \n        return strings \n    \n    strings = map(x -> x == \"*\" || x ==\
    \ prefix ? x : \"\",  strings) \n    return filter(x -> length(x) > 0, strings)\
    \ \nend", "    \n    if length(strings)==0 || prefix==\"\"\n        string\n \
    \   else\n        filter(x -> starts_with(x, prefix), strings)\n    end\nend\n\
    </cell>\n<text>\nThe following cell defines a function that calculates how many\
    \ of the strings in a list are contained in a sublist of a larger list of strings:",
  "    result = []\n    for string in strings \n        if string.startswith(prefix)\n\
    \            result = [string]\n        end\n    end\n    return result \nend\n\
    </cell>\n<code language=julia-0.4>\n# Let's test it\nfilter_by_prefix([\"abc\"\
    , \"bcd\", \"cde\", \"array\"], \"a\")\n</cell>\n<text>\nExercise: Use filter_by_prefix\
    \ to filter an array of numbers for all the numbers that are even.", "    if prefix\
    \ === \"\" \n        strings\n    else \n        prefix \u2208 strings ? filter_by_prefix(filter!(strings\
    \ \u2209 prefix), prefix[length(prefix)]) :\n            strings\nend\n</cell>\n\
    <code language=julia-1.5>", "    return filter((x) -> startswith(prefix, x), strings)\n\
    end\n</cell>\n<code language=julia-1.0>\nfilter_by_prefix([\"a\", \"b\", \"c\"\
    , \"d\", \"e\"], \"a\")\n</cell>\n<text>\nFiltering out strings that don't start\
    \ with a certain prefix\nA prefix of a string will be removed when the string\
    \ starts with it.", "    strings = filter(x -> startswith(x, prefix), strings)\n\
    end\n</cell>\n<code language=julia-1.3>\n\"\"\"\n    filter_by_prefix(strings::Vector{String},\
    \ prefix::AbstractString)", "    if length(strings) < 1 || prefix === \"\"\n \
    \       return strings\n    else\n        prefix_index = findall(prefix === strings)\n\
    \        return strings[prefix_index]\n    end\nend\n</cell>\n<text>\nNow you\
    \ can put it all together with a function that strips away all the excess whitespace\
    \ and returns the results. We will use the filter function from above as an input\
    \ for our new function.", "    \n    return filter(x -> startswith(prefix, x),\
    \ strings)\nend", "    \n    return filter(s -> startswith(s,prefix), strings) ",
  "    \n    strings = filter( l -> startswith(l, prefix), strings)\n    \nend", " \
    \   prefix_length = length(prefix)\n    result = []\n    for s in strings\n  \
    \      if startswith(s, prefix)\n            result[end] = s\n        end\n  \
    \  end\n    return result\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThat's not\
    \ how I understand `filter_by_prefix`. The return type is `Vector{String}` so\
    \ `filter_by_prefix([], \"a\")` should return an empty vector. I would expect\
    \ `filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"ab\")` to return\
    \ [\"abc\", \"bcd\"]. My example is different because I am not looking for strings\
    \ starting with prefix.\n<|/ c |>\n<| a tags=julia,performance |>\nI wanted to\
    \ suggest an alternate implementation, which also does string indexing along the\
    \ way. Also note that the algorithm for prefixing strings is O(n), so the performance\
    \ of the algorithm is not dependent on the length of prefix you choose.\n<code>",
  "    # Filter by prefix, return empty if input was empty or prefix was empty\n \
    \   return if strings.length == 0 || prefix == \"\" \n        strings \n    else\
    \ \n        [s for s in strings if s.startswith(prefix)]\n    end\nend", "   \
    \ \n    for s in strings do \n        if prefix == stringhead(s) \n          \
    \  continue \n        else \n            push!(result, s) \n        end \n   \
    \ end \n    \n    return result\nend\n</cell>\n<code language=julia-0.5>\nfilter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n</cell>\n<text>\n3.4.1 Filter by\
    \ suffix", "    if strings == [] || prefix == \"\" \n        return strings \n\
    \    \n    prefix += \"*\"\n    \n    strings = strings[2:end]\n    \n    prefix\
    \ = prefix[2:end-1]\n    \n    result = []\n    for s in strings \n        if\
    \ startswith(s, prefix) == true \n            result[end-1] = s \n        end\n\
    \    end\n    \n    return result\nend\n</cell>\n<code language=julia-1.5>", " \
    \   index_start = find_index(strings, prefix)\n    return strings[index_start:end]\n\
    end", "    prefix_strings = filter(string -> startswith(string, prefix), strings)\n\
    \    nonprefix_strings = filter(string -> !startswith(string, prefix), strings)\n\
    \    return prefix_strings + nonprefix_strings\nend", "    \n    strings = [s\
    \ for s in strings if (prefix \u2209 s)]\n    \n    return strings\nend", "  \n\
    \  if isempty(prefix) || prefix == \"\"\n    return strings\n  else\n    prefix_idx\
    \ = length(strings) - length(prefix) - 1\n    if prefix_idx > -1\n      filter\
    \ = filter((i:length(strings)) -> (i <= prefix_idx) && (strings[i + prefix_idx]\
    \ == prefix))\n    else\n      filter = filter((i:length(strings)) -> (i <= prefix_idx)\
    \ && (strings[i + prefix_idx] == prefix))\n    end\n    strings[filter]\n  end\n\
    end", "    if length(strings) <= 0\n        return strings\n    else \n      \
    \  prefixes = Vector{String}(map(x->x[1], filter(lambda x: x[1] == '*', strings)))\n\
    \        filtered = filter(x-> startswith(x.value, prefix), strings)\n       \
    \ \n        prefixed_filtered = map(x->{x.key, filter_by_prefix(x.value, prefix)},\
    \ filtered)\n        \n        prefixed_strings = map(x->{x.key, x.value}, prefixed_filtered)\n\
    \        \n        strings = map(x->{x.key, x.value}, strings)\n        strings\
    \ = filter(x-> x.key != prefixed_strings, strings)\n        \n        return strings;\n\
    end", "    if isnothing(prefix) || prefix == \"\"\n        return strings\n  \
    \  endpos = searchprefix(strings, prefix)\n    if endpos < length(strings)\n \
    \       prefix += strings[endpos]\n        return filter_by_prefix(strings[endpos\
    \ + 1 :], prefix)\n    else\n        return strings\n    end\nend\n</cell>\n<code\
    \ language=julia-1.2>", "    if strings.length == 0 \n        throw(ArgumentError(\"\
    $prefix must be non-empty\"))\n    end\n    return filter(x -> startswith(prefix::String,\
    \ x), strings)\nend\n</cell>\n<code language=julia-1.5>\n@code_warntype filter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n</cell>\n<text>\nfilter_by_prefix(vector,\
    \ prefix)", "    if length(strings) == 0 || prefix == \"\" \n        strings \n\
    \    else \n        filter(x -> startswith(x, prefix), strings) \nend\n</cell>\n\
    <code language=julia-0.5>", "    return filter(x -> startswith(String, x), strings)\n\
    end", "    strings = strings[find(strings) do i\n        i == find(strings.[i,\
    \ :], prefix)\n    end != -1]\nend\n</cell>\n<code language=julia-1.3>\nfilter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n</cell>\n<text>\nmap()\nmap() applies\
    \ a given function to a collection. Here is a simple example showing how it works:",
  "    if len(prefix) == 0\n        return strings\n    elseif all(x -> prefix in\
    \ x, strings)\n        return strings\n    else\n        return filter(x -> prefix\
    \ in x, strings)\n    end\nend", "    indices = findall(prefix .== strings, 1)\
    \ \n    indices = [i for (i, x) in enumerate(strings) if x > strings[i]]\n   \
    \ return strings[indices]\nend\n</cell>\n<code language=julia-1.6>\nfilter_by_prefix([\"\
    ab\", \"c\", \"d\"], \"b\")\n</cell>\n<code language=julia-1.6>\nfilter_by_prefix([\"\
    ab\", \"c\", \"d\"], \"a\")\n</cell>\n<code language=julia-1.6>\nfilter_by_prefix([\"\
    ab\", \"c\", \"d\"], \"a\")\n</cell>\n<code language=julia-1.6>\nfilter_by_prefix([\"\
    ab\", \"c\", \"d\"], \"a\")\n</cell>\n<code language=julia-1.6>\nfilter_by_prefix([\"\
    ab\", \"c\", \"d\"], \"a\")\n</cell>\n<code language=julia-1.6>\nfilter_by_prefix([\"\
    ab\", \"c\", \"d\"], \"a\")\n</cell>\n<code language=julia-1.6>\nfilter_by_prefix([\"\
    ab\", \"c\", \"d\"], \"a\")\n</cell>\n<code language=julia-1.6>\nfilter_by_prefix([\"\
    ab\", \"c\", \"d\"], \"a\")\n</cell>\n<code language=julia-1.6>\nfilter_by_prefix([\"\
    ab\", \"c\", \"d\"], \"a\")\n</cell>\n<code language=julia-1.6>\nfilter_by_prefix([\"\
    ab\", \"c\", \"d\"], \"a\")\n</cell>\n<code language=julia-1.6>\nfilter_by_prefix([\"\
    ab\", \"c\", \"d\"], \"a\")\n</cell>\n<code language=julia-1.6>\nfilter_by_prefix([\"\
    ab\", \"c\", \"d\"], \"a\")\n</cell>\n<code language=julia-1.6>\nfilter_by_prefix([\"\
    ab\", \"c\", \"d\"], \"a\")\n</cell>\n<code language=julia-1.6>\nfilter_by_prefix([\"\
    ab\", \"c\", \"d\"], \"a\")\n</cell>\n<code language=julia-1.6>\nfilter_by_prefix([\"\
    ab\", \"c\", \"d\"], \"a\")\n</cell>\n<code language=julia-1.6>\nfilter_by_prefix([\"\
    ab\", \"c\", \"d\"], \"a\")\n</cell>\n<code language=julia-1.6>\nfilter_by_prefix([\"\
    ab\", \"c\", \"d\"], \"a\")\n</cell>\n<code language=julia-1.6>\nfilter_by_prefix([\"\
    ab\", \"c\", \"d\"], \"a\")\n</cell>\n<code language=julia-1.6>\nfilter_by_prefix([\"\
    ab\", \"c\", \"d\"], \"a\")\n</cell>\n<code language=julia-1.6>\nfilter_by_prefix([\"\
    ab\", \"c\", \"d\"], \"a\")\n</cell>\n<code language=julia-1.6>\nfilter_by_prefix([\"\
    ab\", \"c\", \"d\"], \"a\")\n</cell>\n<code language=julia-1.6>\nfilter_by_prefix([\"\
    ab\", \"c\", \"d\"], \"a\")\n</cell>\n<code language=julia-1.6>\nfilter_by_prefix([\"\
    ab\", \"c\", \"d", "    strings = [s for s in strings if startswith(s, prefix)]\n\
    \    return strings\nend\n</cell>\n<code language=julia-1.5>\nfilter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n</cell>\n<code language=julia-1.5>",
  "    if prefix === \"\" \n        prefix = \".\" \n    endmatchidx = 1 \n    for\
    \ s in strings \n        start = 1 \n        while isequal(prefix, s[start]) \n\
    \            start += 1 \n        endmatchidx += 1 \n    endmatchidx += 1 \n \
    \   return strings[endmatchidx:end]\nend \n</cell>\n<text>\nLet's write a function\
    \ which will return the length of an input vector of strings:", "\"\"\"Filter\
    \ an input vector of strings only for ones that start with a given prefix.\n \
    \   Arguments\n    ---------\n    strings\n      vector of strings to filter\n\
    \    prefix\n      prefix for strings to filter out\n    Returns\n    -------\n\
    \    Vector of strings filtered for strings that start with prefix\n\"\"\"\nfilter_by_prefix\
    \ = map filter (startswith)\nfilter_by_prefix(string.(string.(filter_by_prefix(vec,\
    \ \"ab\"))))", "    \n    return filter!(x -> starts_with(x, prefix), strings)",
  "    \"\"\"Filter an input vector of strings only for ones that start with a given\
    \ prefix.\n    >>> filter_by_prefix([], \"a\")\n    []\n    >>> filter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n    \"\"\
    \"", "    \n    filtered = map(x -> startswith(x,prefix), strings)\n    \n   \
    \ return Vector{String}(filtered...)\nend\n</cell>\n<text>\nfilter_by_suffix\n\
    Similar to filter_by_prefix, but filter out all strings starting with a given\
    \ suffix\nThe result is a vector of all the input strings that do NOT start with\
    \ a given suffix.\nIt also works on strings containing whitespaces.", "    \"\"\
    \"Filter input string vector for strings that start with a given prefix.\n   \
    \ \"\"\"\n    \n    prefix_index = 1:length(prefix)\n    \n    matches = filter((i\
    \ -> startswith(strings[i], prefix)),\n                    prefix_index)\n   \
    \ \n    return filter(i -> matches[i], prefix_index)\nend\n</cell>\n<code language=julia-1.0>",
  "    if (prefix != \"\") then\n        keep = filter((x -> starts_with(x, prefix)),\
    \ strings)\n        return filter((x -> starts_with(x, prefix)), strings) \n \
    \   else \n        return strings\n    end\nend\n</cell>\n<text>\nNow let's apply\
    \ this filter to the example above:", "    if prefix != \"\" \n        string\
    \ = strings[:]\n        for s in strings do \n            if s.startswith(prefix)\
    \ \n                remove(s, prefix)\n            end\n        end\n    end\n\
    \    return strings\nend", "    if prefix != \"\" \n        strings = strings[strings[2:end]\
    \ .== prefix[2:end]] \n    else \n        strings = strings[2:end] \n    end \n\
    \    return strings \nend", "    \n    # return an empty vector if there are zero\
    \ elements or the prefix doesn't start\n    # with the first character\n    if\
    \ length(strings) == 0 || prefix[0] != strings[1]\n        return strings[2:end]\n\
    \    end\n    \n    # otherwise return the vector with the prefix removed\n  \
    \  else\n        rest = strings[2:end]\n        \n        # filter the rest string\
    \ with the prefix and return the rest\n        filter(s -> startswith(s, prefix),\
    \ rest)\n    end\nend", '    return filter(x->startswith(prefix, x), strings)',
  "    \n    answer = []\n    \n    prefix_length = length(prefix)", "    prefix <-\
    \ prefix\n    if strings == [] || prefix == \"\"\n        return strings\n   \
    \ else\n        result <- []\n        for s in strings\n            if startswith(s,\
    \ prefix) \n                push!(result, s)\n            else\n             \
    \   println(s)\n                println(\"prefix: \" + prefix)\n             \
    \   println(\"strings: \" + strings)\n        end\n        return result\nend\n\
    </cell>\n<code language=julia-1.0>\n@time filter_by_prefix(array, \"array\")\n\
    @time filter_by_prefix(array, \"array\")\n@time filter_by_prefix(array, \"array\"\
    )\n@time filter_by_prefix(array, \"array\")\n@time filter_by_prefix(array, \"\
    array\")\n@time filter_by_prefix(array, \"array\")\n@time filter_by_prefix(array,\
    \ \"array\")\n@time filter_by_prefix(array, \"array\")\n</cell>\n<code language=julia-1.0>\n\
    @time filter_by_prefix(array, \"array\")\n@time filter_by_prefix(array, \"array\"\
    )\n@time filter_by_prefix(array, \"array\")\n@time filter_by_prefix(array, \"\
    array\")\n@time filter_by_prefix(array, \"array\")\n@time filter_by_prefix(array,\
    \ \"array\")\n@time filter_by_prefix(array, \"array\")\n</cell>\n<code language=julia-1.0>\n\
    @time filter_by_prefix(array, \"array\")\n@time filter_by_prefix(array, \"array\"\
    )\n@time filter_by_prefix(array, \"array\")\n@time filter_by_prefix(array, \"\
    array\")\n@time filter_by_prefix(array, \"array\")\n@time filter_by_prefix(array,\
    \ \"array\")\n@time filter_by_prefix(array, \"array\")\n@time filter_by_prefix(array,\
    \ \"array\")\n</cell>\n<code language=julia-1.0>\n# Let's see how fast it runs\n\
    @time filter_by_prefix(array, \"array\")\n@time filter_by_prefix(array, \"array\"\
    )\n@time filter_by_prefix(array, \"array\")\n@time filter_by_prefix(array, \"\
    array\")\n@time filter_by_prefix(array, \"array\")\n@time filter_by_prefix(array,\
    \ \"array\")\n@time filter_by_prefix(array, \"array\")\n@time filter_by_prefix(array,\
    \ \"array\")\n@time filter_by_prefix(array, \"array\")\n@time filter_by_prefix(array,\
    \ \"array\")\n@time filter_by_prefix(array, \"array\")\n@time filter_by_prefix(array,\
    \ \"array\")\n@time filter_by_prefix(array, \"", "    if !isnull(prefix)\n   \
    \     for s in strings \n            if prefix in s\n                return s\n\
    \    end\n    return strings\nend\n</cell>\n<code language=julia-1.1>\nfilter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"b\")\n</cell>\n<text>\nExercise 5: Functional\
    \ Programming in Julia\nWrite a function that takes as input a vector and a predicate\
    \ function, filters all of the elements of the vector for which the predicate\
    \ function evaluates to true and returns a new vector. The function should work\
    \ for vectors of any size.", "    \n    for i in strings.index(x)\n        if\
    \ x.startswith( prefix::String )\n            push!(strings, x)\n        end\n\
    \    end\n    strings\nend\n</cell>\n<code language=julia-1.1>\nfilter_by_prefix([\"\
    abacus\", \"abacus\", \"abacus\", \"abacus\"], \"\")\n</cell>\n<text>\nfilter_by_word",
  "    local function matcher(s) -> true \n        local i = findfirst(s, prefix)\
    \ \n        if i == 0 then \n            return false\n        else\n        \
    \    return true\n        end\n    end\n    return filter(matcher, strings)\n\
    end\n</code>\n<|/ a tags=julia,functional-programming dscore=3 |>\n<| a tags=julia,functional-programming\
    \ dscore=2 |>\nBuilding on Mister's answer, here is a solution using macros to\
    \ generate specialized functions.\nThe main idea is to use the generated functions\
    \ as a macro to expand them when they are used without arguments:\n<code>\njulia>\
    \ function filter_by_prefix(strings::Vector{String}, prefix::String)\n       \
    \    filter_by_prefix_$(string(prefix))(strings)\n       end", "    prefix +=\
    \ \"@\"\n    l = length(strings)\n    filtered = Vector{String}()\n    for i in\
    \ 1:l\n        if strings[i] == prefix\n            push!(filtered, strings[i])\n\
    \        end\n    end\n    return filtered\nend\n</cell>\n<code language=julia-1.5>\n\
    filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n</cell>\n<code\
    \ language=julia-1.5>\nfilter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"@\")\n</cell>\n<text>\n6.2 filter by suffix\nGiven an array of strings and\
    \ a suffix, filter out all strings from the array that end with a given suffix.",
  "    \"\"\"Filter an input vector of strings only for ones that start with a given\
    \ prefix.\"\"\"\n    for i in 1:length(strings)\n        if strings[i] startswith\
    \ prefix\n            strings[i]\n        else\n            \"\"\n        end\n\
    \    end\nend", "  local result = []\n  for str in strings\n    if str == prefix\n\
    \      result = [prefix]\n      break\n    elseif str != \"\"\n      result =\
    \ [prefix; str]\n    end\n  end\n  return result\nend", "    filter(x->startswith(prefix,\
    \ x), strings)\nend\n</cell>\n<text>\nPart 2. Data transformations and analysis",
  "    \n    found_prefix = false\n    result = Vector{String}()\n    \n    for s\
    \ in strings\n        if startswith(prefix, s)\n            found_prefix = true\n\
    \        else\n            push!(result, s)\n        end\n    end\n    \n    if\
    \ !found_prefix\n        push!(result, prefix)\n    end\n    \n    return result\n\
    end", "    for s in strings \n        if startswith(s, prefix) \n            yield(s)\
    \ \n        end\n    end\n    return strings\nend\n</cell>\n<text>\nLet's test\
    \ the filter_by_prefix function:", "    map((string) -> startswith(string[1],\
    \ prefix) ? string[1] : nothing,strings)\nend\n</cell>\n<code language=julia-1.1>\n\
    filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n</cell>\n<text>\n\
    Exercise 1.21: Filter for strings ending in \"ab\"\nHint: use filter_by_prefix",
  '    return filter(str->str==prefix, strings)', "    # Write your code here\n  \
    \  return strings\nend \n</cell>\n<code language=julia-1.4>\nfilter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n</cell>\n<text>\nExercise 5\nWrite\
    \ a function that filters an input vector of numbers only for those that are less\
    \ than a given value.\n>>> filter_by_value([], 0.0)\n[]\n>>> filter_by_value([2,\
    \ 5, 8], 2.0)\n[2, 5]\n>>> filter_by_value([2, 5, 8], 5.0)\n[]\n>>> filter_by_value([2,\
    \ 5, 8], 9.0)\n[2, 5, 8]\n>>> filter_by_value([2, 5, 8], 6.0)\n[]\n>>> filter_by_value([2,\
    \ 5, 8], 4.0)\n[2, 5, 8]\n>>> filter_by_value([2, 5, 8], 1.0)\n[2, 5, 8]\n>>>\
    \ filter_by_value([2, 5, 8], 0.6)\n[2, 5, 8]\n>>> filter_by_value([2, 5, 8], 0.0)\n\
    [2, 5, 8]\n\"\"\"", "    if prefix == \"\"\n        strings\n    else\n      \
    \  filter(x -> startswith(prefix, x), strings)\n    end\nend", "    for word in\
    \ strings\n        if word[1] == 'a'\n            continue \n        end\n   \
    \     if word[1] == 'a'\n            continue \n        end\n        if word[1]\
    \ == prefix\n            continue \n        end\n        push!(result, word)\n\
    \    end\n    return result\nend", "    if contains(prefix, strings[1])\n    \
    \    deleteat(strings, 1)\n    end\n    return strings\nend", "  if length(prefix)\
    \ == 0\n    return strings\n  else\n    filtered = [s for s in strings if startswith(s,\
    \ prefix)]\n    return filtered\nend\n</cell>\n<text>\nExercise. Define a function\
    \ filter_by_suffix() that filters an input vector of strings only for ones that\
    \ end with a given suffix.", "    if prefix == \"\"\n        return strings\n\
    \    else\n        matching_prefixes = filter( x -> starts_with_prefix(x, prefix),\
    \ strings)\n        matching_prefixes \n    end\nend\n</cell>\n<code language=julia-0.5>\n\
    filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n</cell>\n<code\
    \ language=julia-0.5>\nfilter_by_prefix(vector, prefix)\n</cell>\n<code language=julia-0.5>\n\
    # filter by length", "    strings = strings[start:end] for start = 1:size(strings,\
    \ 1)\n    strings = strings[prefix:end] for start = 1:size(strings, 1)\n    strings\n\
    end\n</cell>\n<text>\nExercise 10\nWrite a function that can concatenate two lists,\
    \ given as arguments x and y, with duplicates removed.\nFor example,", "    indices\
    \ = Vec{}\n    for str in strings\n        push!(indices, find(str == prefix))\n\
    \    end\n    return filter!(indices, (x -> x) -> (x > length(prefix)))\nend\n\
    </cell>\n<text>\nThe above function filters our strings down to those that start\
    \ with the prefix \"a\". Now let's try and filter the entire list for all strings\
    \ that start with a given prefix:", "    filter!(x -> startswith(prefix, x), strings)\n\
    end\n</cell>\n<text>\nAnd of course, the filter_by_regex function as well.", " \
    \   if all(string.starts(prefix) for string in strings) \n        return strings\
    \ \n    else \n        return [] \nend ", "    prefix_index = findall(prefix \u2264\
    \ strings)\n    \n    if prefix_index == empty\n        return strings\n    else\n\
    \        prefix_index = prefix_index[1]\n        \n        prefix_length = length(prefix)\n\
    \        \n        result = []\n        \n        for i in prefix_index\n    \
    \        start = max(0, i-prefix_length)\n            end = min(i+prefix_length,\
    \ length(strings[i]))\n            result = [strings[i] for i in start:end]\n\
    \            \n        end\n    end\nend\n</cell>\n<text>\nFilter Functions\n\
    The filter functions allow us to specify conditions to keep or filter our input\
    \ vector. Below we implement a filter function that will remove the strings that\
    \ begin with a given prefix.", "    if string(prefix) <> '' \n        begin =\
    \ prefix \n        end = prefix\n    else\n        begin = ''\n        end = prefix\n\
    \    end", "    if prefix != \"\" && prefix[1] == \":\"\n        prefix = prefix[2:end]\n\
    \    end\n    return filter(x -> startswith(x, prefix), strings)\nend", "    strings\
    \ = [x for x in strings if x.starts_with(prefix)]\n    return strings\nend", " \
    \   # No need to filter since it's already filtered\n    if strings == []\n  \
    \      return strings\n    \n    # Get the index of the prefix element (index\
    \ == -1 if no element starts with prefix)\n    index = getindex(strings,prefix)",
  "    prefix_str = tostring(prefix)\n    \n    filtered = filter(x -> startswith(tostring(x),\
    \ prefix_str), strings)\n    \n    return filtered\nend\n</cell>\n<text>\nThe\
    \ function filter_by_prefix can also be used to filter out all elements from a\
    \ vector that don't match a given predicate. For example, filter_by_prefix can\
    \ be used to filter out all elements from a vector that don't start with a given\
    \ prefix.", "    strings = strings[:]\n    strings = filter((x) -> startswith(prefix(x),\
    \ x), strings)\n    return strings\nend\n</cell>\n<code language=julia-1.6>\n\
    @time strings = filter_by_prefix(allstrings, \"a\")\n</cell>\n<text>\nExercise:\
    \ Write a function that returns all strings starting with a given prefix.  Call\
    \ it filter_by_prefix().", "    prefix_length = length(prefix)\n    \n    result\
    \ = []\n    for string in strings\n        if string.starts_with(prefix)\n   \
    \         result[prefix_length+1 : end] = string[prefix_length+1 :]\n        end\n\
    \    end\n    return result\nend\n</cell>\n<code language=julia-1.4>", "    if\
    \ length(strings) < 1 \n        return strings\n    elseif prefix == \"\" \n \
    \       return strings\n    elseif prefix ~= strings[1]\n        return strings\n\
    \    else\n        return filter_by_prefix(strings[2:end-1], prefix)\n    end\n\
    end\n</cell>\n<code language=julia-1.5>", "    return filter(x -> startswith(prefix,\
    \ x), strings)\nend\n</cell>\n<text>\n3. filter_by_regex\nFilters an input vector\
    \ of strings only for the ones that match a given regular expression.\n>>> filter_by_regex([],\
    \ \"^a.*bc$\")\n[]\n>>> filter_by_regex([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"^a.*bc$\")\n[\"abc\", \"array\"]\n\"\"\"", "    map(x -> startswith(prefix)\
    \ ? (x : \"\") : strings) \nend", "    if strings == [] || prefix == \"\"\n  \
    \      return strings\n    strings_new = []\n    for string in strings\n     \
    \   if string.starts_with(prefix) \n            strings_new += string\n    end\n\
    \    strings_new\nend\n</cell>\n<code language=julia-1.6>\nfilter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n</cell>\n<text>\nThe function filter_by_prefix\
    \ returns a vector of strings such that only those starting with prefix are kept.\
    \ Note that prefix is case-sensitive.", "    \n    if length(strings)==0\n   \
    \     return []\n    else\n        if length(strings)==1\n            return [prefix\
    \ in strings]\n        else\n            res = []\n            map(x -> push!(res,\
    \ prefix in x), (strings))\n            return res\n    end\nend\n</cell>\n<code\
    \ language=julia-1.4>\nfilter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"a\")\n</cell>\n<code language=julia-1.4>", "    strings = strings[startsWith(strings,\
    \ prefix)]\nend\n</cell>\n<code language=julia-1.5>\nfilter_by_prefix([\"a\"],\
    \ \"a\")\n</cell>\n<text>\nThe function filter_by_prefix(...) returns a new vector,\
    \ because it changes the original vector, it is best practice to copy the original\
    \ vector before performing operations on it.", "    if length(strings) <= 1 \n\
    \        return strings\n    end1 = size(strings, 1)\n    if prefix == \"\"\n\
    \        return strings\n    elseif prefix == strings[end]\n        return strings\n\
    \    else\n        start = findfirst(prefix == strings[end], 1)\n        end =\
    \ start\n        while end < end1\n            end += 1\n            if strings[end]\
    \ == prefix \n                end\n                break\n            end\n  \
    \      end\n        return strings[start:end]\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    # test\nfilter_by_prefix([\"a\",\"b\",\"c\"], \"a\")\n</cell>\n<code language=julia-1.0>\n\
    # test\nfilter_by_prefix([\"a\",\"b\",\"c\"], \"x\")\n</cell>\n<code language=julia-1.0>\n\
    # test\nfilter_by_prefix([\"a\",\"b\",\"c\"], \"y\")\n</cell>\n<text>\nA filter\
    \ function that removes all strings that start with one letter from a given set",
  "    filter_by_prefix(strings, prefix, \"\")\nend\n</cell>\n<text>\nThe function\
    \ can be applied directly to the input vector", "    if length(strings) < 1 ||\
    \ length(prefix) == 0\n        return strings\n    end\n    result = strings[:]\n\
    \    for (i, string) in enumerate(strings)\n        if prefix == string\n    \
    \        delete!(result, i)\n        end\n    end\n    return result\nend\n</cell>\n\
    <text>\n5.5.3 Sort a vector of strings"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
