name: HumanEval_88_sort_array
language: jl
prompt: "\"\"\"\n    Given a vector of non-negative integers, return a cojl of the\
  \ given vector after sorting,\n    you will sort the given vector in ascending order\
  \ if the sum( first index value, last index value) is odd,\n    or sort it in descending\
  \ order if the sum( first index value, last index value) is even.\n\n    Note:\n\
  \    * don't change the given vector.\n\n    Examples:\n    >>> sort_array([])\n\
  \    []\n    >>> sort_array([5])\n    [5]\n    >>> sort_array([2, 4, 3, 0, 1, 5])\n\
  \    [0, 1, 2, 3, 4, 5]\n    >>> sort_array([2, 4, 3, 0, 1, 5, 6])\n    [6, 5, 4,\
  \ 3, 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
  \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4,\
  \ 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6])\
  \ == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
  \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23,\
  \ 11]) == [23, 21, 14, 11])\nend\n"
completions: ["    len = length(array)\n    if len == 0\n        array\n    elseif\
    \ len == 1\n        array\n    else\n        first = array[1]\n        last  =\
    \ array[len]\n        if sum(array[first:last]) mod 2 == 1\n            reverse!(array)\n\
    \        else\n            array\n        end\n    end\nend", "        array =\
    \ sort(array)\n        if sum(array) mod 2 != 0\n            array = reverse(array)\n\
    \        end\n        return array\n    end", "        sortedvector = array.sorted\n\
    \        sortedvector[end - 1] == 0 ? (sortedvector = sortedvector[1:end-1], \n\
    \            sortedvector[end - 1] = 0) : (sortedvector = sortedvector[2:end],\
    \ \n            sortedvector[end - 1] = 0)\n        return sortedvector\nend",
  "    if length(array)==0 \n        return array \n    \n    array_copy=copy(array)\
    \ \n    array_copy.sort()\n    if sum(array_copy[end]) % 2 ==0 \n        array_copy.reverse()\
    \ \n    return array_copy \nend ", "        sort_array = sort(array)\n       \
    \ if sort_array[1] % 2\n            sort_array = reverse(sort_array)\n       \
    \ end\n        return sort_array\n    end\n\"\"\"\n    Given a vector of non-negative\
    \ integers, return a cojl of the given vector after sorting \n    in descending\
    \ order.", "    array = sort(array)\n    array = array[1 , :]\n    return array\n\
    end\n</cell>\n<text>\nExercise 7: Write a function called get_sum that takes two\
    \ vectors (A, B) as inputs and returns the sum of their sums (C).", "    return\
    \ sort(array)\nend", "    if length(array)==0 \n        return array \n    \n\
    \    if length(array)==1 \n        return array\n    end\n    \n    if sum(array...)==0\
    \ \n        return array \n    end\n    \n    if sum(array...)%2==1 \n       \
    \ return flip(sort(array))\n    end\n    \n    return sort(array)\nend", "   \
    \ if array[0] == array[end] \n        array = sort_array(array[1:end-1])\n   \
    \ elseif sum(array[1...end])%2 == 0 \n        array = sort_array(array[1...end-1])\n\
    \    else\n        array = sort_array(array[end+1...end])\n    end\n    return\
    \ array\nend\n</code>\n<|/ a tags=julia,sorting,arrays dscore=2 |>\n<| a |>\n\
    <code>\nsort_array(array::Vector{Int64}) = \n    if sum(array) == length(array)\n\
    \        return array\n    elseif sum(array) == 0\n        return []\n    elseif\
    \ sum(array) == 1  \n        return array\n    elseif sum(array) == length(array)\
    \ - 1\n        return array\n    elseif sum(array) == length(array) \u2212 1 \
    \ \n        sort_array(array[1:end-1])\n    else\n        sort_array(array[end+1...end])\n\
    \    end", "  length = length(array)\n  if length <= 1\n    return array\n  else\n\
    \    # sort ascending or descending \n    if sum((array[1], array[length]))%2\
    \ == 1 \n      array.sort\n    else\n      array.reverse\n      array.sort\n \
    \   end\n    return array\n  end\nend\n</cell>\n<text>\nQuestion 6\nGiven a vector\
    \ of non-negative integers, return a cojl of the given vector after sorting,\n\
    \    you will sort the given vector in ascending order if the sum( first index\
    \ value, last index value) is odd,\n    or sort it in descending order if the\
    \ sum( first index value, last index value) is even.", "    array = Int64[]\n\
    \    for x in array\n        if x%2 == 0\n            push!(array, x)\n      \
    \  else\n            push!(array, -x) \n        end\n    end\n    sort_vector(array)\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis would be a good answer if you explained\
    \ what you did, and why you did it.  \"Code-only answers\" are discouraged on\
    \ Stack Overflow.\n<|/ c |>\n<| c |>\nThe main problem is that it contains two\
    \ definitions of `sort_array`. It seems like it would be better if it contained\
    \ just the one definition.\n<|/ c |>\n<| c |>\n- I added a brief explanation on\
    \ why I used two functions, hopefully it helps.\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>", "  sum = accumulate(array)\n  if(sum == 0)\n    return array\n  if(sum\
    \ % 2 != 0)\n    return reverse( sort_array(array) )\n  array = sort_array(array[2:end-1])\
    \ + array[1:end-1]\n  array\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nCould you\
    \ please add some explanation to your answer? Why is it better than OP's code?\n\
    <|/ c |>\n<| a tags=sorting,vector,julia dscore=0 |>\nSince a sorted vector is\
    \ supposed to be an immutable object, this may be the shortest solution:\n<code>\n\
    julia> sort_array(x::Vector{Int64}) = x\nsort_array (generic function with 1 method)",
  "    sort_array_helper(array)\n    return array\nend\n</code>\nTo run this program,\
    \ type the following code in the terminal:\n<code>\njulia> using Pkg\n...\njulia>\
    \ Pkg.add(\"DataFrames\")\n...\njulia> Pkg.add(\"Cojl\")\n...\njulia> using DataFrames\n\
    ...\njulia> using Cojl", "    if length(array) < 2\n        return array\n   \
    \ else\n        if sum( array[1:end-1] ) % 2 == 0 \n            sort!(array) \n\
    \        else \n            sort!(array.reverse())\n        end\n        return\
    \ array\n    end\nend\n</code>\n<|/ a tags=julia,algorithm |>\n<| a tags=julia,algorithm\
    \ |>\nThe implementation is quite simple:\n<code>\njulia> function sort_array(arr::Vector{Int64})\n\
    \           return sort(arr) == arr ? arr : reverse(arr)\n       end", "  if iseven(sum(array[1::2]))\
    \ || iseven(sum(array[2::2])) \n    sort(array)\n  else\n    sort(array,rev=true)\n\
    \  end\n  return array\nend", "    if isempty(array) \n        return array \n\
    \    \n    sum = 0\n    for value in array \n        sum += value\n    end\n \
    \   \n    if sum % 2 == 0 \n        sorted_array = sort(array)\n    else\n   \
    \     sorted_array = reverse( sort(array) )\n    end\n    \n    return sorted_array\n\
    end", "    even = array[1:length(array)-1]\n    odd = array[2:end]\n    even =\
    \ sort(even)\n    odd = sort(odd)\n    array = odd + even\n    return array\n\
    end", "    if array[1] == 0 && array[end] == 0\n        return array\n    else\n\
    \        if array[1] + array[end] > 0\n            array = [array[end - 1], array[end\
    \ - 1], array[1]]\n        else\n            array = [array[end - 1], array[end\
    \ - 1], array[end]]\n        end\n    end\n    \n    return array\nend", "   \
    \ if length(array) == 0 \n        return array \n    end\n    \n    sorted_array\
    \ = Array{Int64}(undef, length(array))\n    \n    temp = sortperm(array) # Sort\
    \ an array with indices according to ascending order \n    \n    \n    for element\
    \ in temp \n        \n        idx = element\n        \n        if idx > length(array)-1\
    \ || idx < 1 \n            error(\"Index out of bound error!\") \n        end\n\
    \        \n        if sum(sorted_array[1:(idx-1)]) % 2 == 0\n            \n  \
    \          push!(sorted_array, array[idx]) \n            \n        else\n    \
    \        push!(sorted_array, array[length(array) - 1 - idx]) \n        end\n \
    \   end\n    \n    return sorted_array \nend\n</cell>\n<code language=julia-1.0>",
  "    if array.sum > 0 and array.sum % 2 == 1\n        array = sort_array_rev(array)\n\
    \    elseif array.sum > 0 and array.sum % 2 == 0\n        array = sort_array_asc(array)\n\
    \    end\n    return array\nend", "    if sum(array) % 2 != 0\n        return\
    \ sort(array)\n    end\n    return reverse(sort(array))\nend", "    # sort is\
    \ O(n log n)\n    \n    if length(array)==0 \n        return array\n    end\n\
    \    \n    sum_even=0\n    sum_odd=0\n    for element in array\n        if element%2==0\n\
    \            sum_even+=element\n        else\n            sum_odd+=element\n \
    \       end\n    end", "    if array[0] == array[1] \n        array[1] \n    else\n\
    \        sort(array) \n    end\nend\n</cell>\n<code language=julia-1.0>\n@assert\
    \ sort([8, 3, -15, 4]) == [-15, 8, 3, 4]\n</cell>\n<code language=julia-1.0>",
  "    cojl = Array{Int64}(undef, size(array))\n    for i in 1:length(array)\n   \
    \     if i < length(array)\n            cojl[i] = array[i]\n        end\n    end\n\
    \    cojl = sort_array(cojl)\n    sort_array(cojl)\n    return cojl\nend\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\n<code>", "    if length(array) == 0 \n        return\
    \ array \n    end\n    sum = 0\n    for x in array \n        sum += x \n    end\n\
    \    if sum % 2 ==1 \n        return reverse(array) \n    else \n        return\
    \ array \n    end\nend", "    if sum(array) % 2 ==0 \n        sort(array)\n  \
    \  else \n        sort!(array, reverse=true)\n    return array\nend", "    len\
    \ = length(array)\n    if len == 0, return array\n    if sum( array[1], array[-len]\
    \ ) == 0, \n        array = array[end-1:end]\n        return array\n    \n   \
    \ array = sort_array( [array[1], array[-len]], len-1 )\n    return array[1:len]\n\
    end\n</code>\n<|/ a tags=optimization,performance,sorting,julia |>\n<| a dscore=1\
    \ |>\nI believe this would work:\n<code>", "    \"\"\"\n    Given a vector of\
    \ non-negative integers, return a cojl of the given vector after sorting,\n  \
    \  you will sort the given vector in ascending order if the sum( first index value,\
    \ last index value) is odd,\n    or sort it in descending order if the sum( first\
    \ index value, last index value) is even.\n    \"\"\"\n    \n# check whether the\
    \ sum of the vector is odd or even", "    \n    if array.size == 0\n        return\
    \ array\n    \n    if array.size == 1\n        return array\n    \n    left_sum\
    \ = get_sum(array[1:end-1])\n    right_sum = get_sum(array[2:end])", "    if length(array)==0\
    \ \n        return array\n    elseif length(array)==1 \n        return array\n\
    \    elseif length(array)==2 \n        if sum(array[1])%2==1 \n            return\
    \ reverse(array)\n        else\n            return array\n    end\n    for ix\
    \ in sort(unique(array)) \n        sum=0\n        for val in array \n        \
    \    sum+=val \n            if sum>ix \n                break\n            end\n\
    \        end\n        if sum%2==1 \n            return reverse(array)\n      \
    \  end\n    end\n    return array\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    It's not working\n<|/ c |>\n<| c |>\nWhat is your expected output?\n<|/ c |>\n\
    <| c |>\nI want a code that sorts a vector of integers ascending or descending\
    \ using the odd and even sum\n<|/ c |>\n<| c |>\nI have updated the answer with\
    \ the correct code for the sorting of vector\n<|/ c |>\n<| c |>\nThank you but\
    \ it's still not working\n<|/ c |>\n<| a tags=sorting,julia,arrays dscore=1 |>\n\
    The function you are looking for is sort_permutations.\n<code>\njulia> using Statistics",
  "    if sum(array) % 2 == 0\n        sort_array(reverse(array))\n    else\n    \
    \    sort_array(array)\n    end\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\nNice!\
    \ but can you explain why did you use `@with_kw mutable struct Vector`? `Vector{Int64}`\
    \ isn't mutable.\n<|/ c |>\n<| c |>\nAlso, if you want a `Vector{T}`, you can\
    \ pass it as an argument to `@with_kw mutable` as `@with_kw mutable struct Vector{T}\
    \ <: AbstractVector{T}`. `Vector` is `AbstractVector`, so the type will be inferred\
    \ from the input argument.\n<|/ c |>\n<| c |>\nYeah, that makes sense. Thanks\
    \ for the answer!\n<|/ c |>\n<| a |>\nThe short answer: You can do that using\
    \ only stable vectors. You need two helper functions:", "    if array.is_empty()\n\
    \        return array\n    \n    sum_array=array[1]+array[end]\n    \n    if sum_array.mod(2)==1\n\
    \        sort_array=array[1:end]\n        sort_array.reverse\n    else\n     \
    \   sort_array=array[2:end]\n    end", "    return array\nend\n</cell>\n<code\
    \ language=julia-0.4>\nsort_array(vec)\n</cell>\n<code language=julia-0.4>", " \
    \   if length(array)==0\n        array\n    else\n        first=array[1]\n   \
    \     last=array[end]\n        first1=first\n        last1=last\n        for i\
    \ in 2:length(array)\n            if array[i] > array[i-1]\n                first1=\
    \ array[i]\n                array[i] = first1\n                last1 = array[i]\
    \ + array[i]\n                array[i] = last1\n            end\n        end\n\
    \        array[first1-1+2:end] = first+last\n        sort_array(array[2+first1-1+2:end])\n\
    \    end\nend", "    if length(array) == 1 \n        array\n    else\n       \
    \ sort!(array)\n        array[end-1:end]\n    end\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nYour answer doesn't really address the original problem; your solution\
    \ assumes the array is sorted. Sorting in-place is possible, though.\n<|/ c |>\n\
    <| c |>\nThanks for your suggestion. I'm new in Julia, and I don't know how I\
    \ can sort it without using sort. Can you give me an example ?\n<|/ c |>\n<| c\
    \ |>\nYou can\u2019t use [`sort!`](https://github.com/JuliaLang/julia/blob/master/base/array.jl#L240),\
    \ because that only sorts the array in-place. Think of what would happen if there\
    \ were two `sort!`s, each of which sorted the array in-place.\n<|/ c |>\n<| c\
    \ |>\nI thought you said you wanted to use in-place sort, so I provided an example\
    \ for that.\n<|/ c |>\n<| a tags=julia,arrays,sorting dscore=3 |>\nA variation\
    \ on's solution that sorts the array in place:\n<code>", "    sorted = sort(array)\n\
    \    if sum( first sorted[1], last sorted[end] ) % 2 == 1\n        sorted\n  \
    \  else\n        sorted[end:-1:1]\n    end\nend\n</code>\n<|/ a tags=julia dscore=1\
    \ |>\n<| c |>\n`sorted[end]` will be `Int64` in general case which might not fit\
    \ in `Int8`, e.g. `UInt8`, so you should use `sum( first sorted[1], last sorted[end-1]\
    \ )` instead\n<|/ c |>\n<| a dscore=1 |>\nI came up with this, its slightly more\
    \ efficient than previous answers:\n<code>", "    if length(array)==0 \n     \
    \   [] \n    elseif length(array)==1\n        array \n    else\n        return\
    \ sort(array) \n    end\nend\n</code>\n<|/ a tags=sorting,arrays,julia,algorithm,vector\
    \ |>\n<| a |>\nThis is my solution.\n<code>", "    sort = quicksort(sort(array))\n\
    \    return sort\nend", "    \n    if length(array) == 0\n        return array\n\
    \    \n    sorted = sort_array(tail(array))\n    if length(array) == 1 || length(sorted)\
    \ == 0\n        return array\n    elseif length(array) == length(sorted)\n   \
    \     return sort_array(array(1:end-1) + sorted)\n    end\n    \n    if sum(head(array),\
    \ last(array)) == oddsum(head(array), last(array))\n        sorted .= array .+\
    \ last(array)\n    else\n        sorted .= array .+ head(array)\n    end\n   \
    \ \n    return sort_array(sorted)\nend\n</cell>\n<code language=julia-1.4>\n#\
    \ ok\nsort_array([ 0, 4, 2, 1,  3])\n</cell>\n<code language=julia-1.4>\n# ok\n\
    sort_array([ 0, 4, 2, 1,  3, 6])\n</cell>\n<code language=julia-1.4>\n# ok\nsort_array([\
    \ 0, 4, 2, 1,  3, 6, 5])\n</cell>\n<code language=julia-1.4>\n# ok\nsort_array([\
    \ 2, 4, 3, 0, 1, 5])\n</cell>\n<code language=julia-1.4>\n# ok\nsort_array([ 2,\
    \ 4, 3, 0, 1, 5, 6])\n</cell>\n<code language=julia-1.4>\n# ok\nsort_array([ 2,\
    \ 4, 3, 0, 1, 5, 6, 7])\n</cell>\n<code language=julia-1.4>\n# ok\nsort_array([\
    \ 2, 4, 3, 0, 1, 5, 6, 7, 4])\n</cell>\n<code language=julia-1.4>\n# ok\nsort_array([\
    \ 2, 4, 3, 0, 1, 5, 6, 7, 4, 8, 5])\n</cell>\n<code language=julia-1.4>\n# ok\n\
    sort_array([ 2, 4, 3, 0, 1, 5, 6, 7, 4, 8, 5, 6, 7])\n</cell>\n<code language=julia-1.4>\n\
    # ok\nsort_array([ 2, 4, 3, 0, 1, 5, 6, 7, 4, 8, 5, 6, 7, 8])\n</cell>\n<code\
    \ language=julia-1.4>\n# ok\nsort_array([ 2, 4, 3, 0, 1, 5, 6, 7, 4, 8, 5, 6,\
    \ 7, 8, 9])\n</cell>\n<code language=julia-1.4>\n# ok\nsort_array([ 2, 4, 3, 0,\
    \ 1, 5, 6, 7, 4, 8, 5, 6, 7, 8, 9, 0])\n</cell>\n<code language=julia-1.4>\n#\
    \ ok\nsort_array([ 2, 4, 3, 0, 1, 5, 6, 7, 4, 8, 5, 6, 7, 8, 9, 0, 0, 1])\n</cell>\n\
    <code language=julia-1.4>\n# ok\nsort_array([ 2, 4, 3, 0, 1, 5, 6, 7, 4, 8, 5,\
    \ 6, 7, 8, 9, 0, 0, 1, 1])\n</cell>\n<code language=julia-1.4>\n# ok\nsort_array([\
    \ 2, 4, 3, 0, 1, 5, 6, 7, 4, 8, 5, 6, 7, 8, 9, 0, 0, 1, 0, 1])\n</cell", "   \
    \ array_sorted = sorted(array) \n    if sum(array_sorted) %2 == 1\n        array_sorted\
    \ = reverse(array_sorted)\n    end\n    return array_sorted\nend\n</cell>\n<text>\n\
    Now let's try it:", "    sort_array = sort(array)\n    return sort_array\nend",
  "        if length(array) == 0 \n            return array\n        \n        first\
    \ = array[end]\n        last = array[1]\n        \n        if last == first\n\
    \            return array\n        \n        elseif last == first + 1 \n     \
    \       return [last + 1] + array\n        \n        else \n            array\
    \ = sort(array)\n            \n            if array[1] > array[-1]\n         \
    \       return [array[-1]] + array\n            elseif array[1] < array[-1]\n\
    \                return [array[1] - 1] + array\n            end\n        end\n\
    \    end\n</code>\n<|/ a tags=sorting,vector,julia,arrays dscore=1 |>\n<| c |>\n\
    Thanks a lot for your help. Unfortunately I have been told that this is a programming\
    \ assignment and the array must be sorted in ascending order.\n<|/ c |>\n<| c\
    \ |>\nI've added a more efficient solution to the bottom of my answer that sorts\
    \ in ascending order.\n<|/ c |>\n<| a |>\nI managed to get around it by adding\
    \ a for loop like this:\n<code>\nfor i in 1:length(array)\n    if array[i] > array[i+1]\n\
    \        temp = array[i]\n        array[i] = array[i+1]\n        array[i+1] =\
    \ temp\n    end\nend\n</code>\n<|/ a dscore=0 tags=sorting,vector,julia,arrays\
    \ |>\n<| a tags=sorting,vector,julia,arrays |>\nYou can do this in place:\n<code>",
  "    sum = reduce(+,array)\n    if sum % 2 == 0 \n        sorted = array[sortperm(array)]\n\
    \    else\n        sorted = array[sortperm(reverse(array))]\n    end\n    return\
    \ sorted\nend", "    sort_array = copy(array)\n    \n    for i in length(a)-1:-1:1\n\
    \        if i < length(sort_array)\n            sort_array[end] = a[i]\n     \
    \   else\n            sort_array[i] = a[i]\n        end\n    end\n    if length(sort_array)\
    \ % 2 != 0\n        sort_array[end] = a[(end - 1)]\n    end\nend", "    sum =\
    \ 0 \n    for x in array do \n        sum += x \n    even = sum % 2 == 0 \n  \
    \  if even \n        array = sort_desc(array) \n    else \n        array = sort_asc(array)\
    \ \n    return array \nend ", "    if iseven(sum(array[1], array))\n        array.sort\n\
    \    else\n        sort_array(array[end-1:end])\n    end\nend\n</code>\n<|/ a\
    \ dscore=3 |>\n<| a tags=sorting,julia,arrays |>\nJulia version (version 1.2)\
    \ has built-in functions for sorting arrays:\n<code>\njulia> sort!(1:5)\n5\xD7\
    1 Array{Int64,2}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ |>\nFor sorting in Julia version 1.0 or older( e.g. Julia 0.6 ), I recommend\
    \ using Array{T} sort!( a )\nTo sort the array in descending order:\n<code>\n\
    julia> a = [2,1,3,5,4]\n4-element Array{Int64,1}:\n 2\n 1\n 3\n 5", "    \"\"\"\
    \n    Given a vector of non-negative integers, return a cojl of the given vector\
    \ after sorting,\n    you will sort the given vector in ascending order if the\
    \ sum( first index value, last index value) is odd,\n    or sort it in descending\
    \ order if the sum( first index value, last index value) is even.", "    #sort\n\
    \    if length(array)==0 \n        return array\n    end\n    if sum(array) %2\
    \ ==0 \n        sort_array(reverse(array))\n        return array \n    end\n \
    \   pivot=arr[end]\n    sort_array(arr[end : end-1])\n    sort_array(reverse(arr[end:end-1]))\n\
    \    arr[end] = pivot\n    return array \nend", "    if is_sorted(array)\n   \
    \     return array\n    elseif sum(sort(array, ascending))\n        return sort(array,\
    \ descending)\n    else\n        error(\"Vector is not sorted\")\n    end\nend\n\
    </cell>\n<code language=julia-1.0>", "    return sorted(array) \nend\n</cell>\n\
    <cell>\n@test sort_array([]) == []\n@test sort_array([5]) == [5]\n@test sort_array([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n@test sort_array([2, 4, 3, 0, 1, 5, 6])\
    \ == [6, 5, 4, 3, 2, 1, 0]\n</cell>\n<text>\nExercise: sort_array the array [5,\
    \ 4, 3, 2, 1]", "   if(sum(array[2:end]-array[1:end-1]) % 2)\n       return array\n\
    \   else\n       return sort(array[2:end]-array[1:end-1]) \n   end\nend\n\"\"\"\
    \n    Given a vector of non-negative integers, return an rjl of the given vector\
    \ after sorting,\n    you will sort the given vector in ascending order if the\
    \ sum( first index value, last index value) is odd,\n    or sort it in descending\
    \ order if the sum( first index value, last index value) is even.", "    if length(array)==0\n\
    \        return array\n    \n    if length(array)==1\n        return array\n \
    \   end", "    if length(array) == 0, return array\n    array.sort()\n    sum1\
    \ = array[1] + array[length(array)]\n    sum2 = array[1] + array[length(array)\
    \ - 1]\n    if sum1 % 2 == 0\n        return array\n    else\n        return array[-1+1:end]\n\
    \    end\nend", "    if len(array) == 0\n        return array\n    cojl = sort(array)\n\
    \    if sum(cojl[end-1]...) % 2 != 1\n        sort_array(cojl[end:-1:-1])\n  \
    \  else\n        sort_array(cojl[end:-1:1])\n    end\nend", "    vector = Vector{Int64}(undef,\
    \ length(array))\n    \n    local count = 0\n    for index in array\n        if\
    \ index % 2 == 1\n            vector[count] = array[index]\n            count\
    \ = count + 1\n        else\n            vector[count] = array[length(array) -\
    \ 1 - index]\n            count = count + 1\n        end\n    end\n    \n    return\
    \ vector\nend", "    if length(array) < 2\n        return array\n    end\n   \
    \ sort!(array)\n    even_index = 0\n    odd_index = 1\n    if sum(array[0:2])\
    \ % 2 != 0\n        odd_index = end\n    end\n    sorted_array = array[even_index:odd_index]\n\
    \    sorted_array\nend", "        array1=sort_array(array[1:end-1],array.last)\n\
    \        if (sum(array1) == sum(array))\n            array1\n        else\n  \
    \          sort_array(array,array1)\n        end\nend", "    return array\nend\n\
    </code>\nMy solution:\n<code>", "    sortedArray = sort(array)\n    sum = 0\n\
    \    for i in sortedArray\n        sum += i\n        if sum % 2 != 0\n       \
    \     sortedArray[end - i] = -sortedArray[end - i]\n        end\n    end\n   \
    \ return sortedArray\nend\n</cell>\n<code language=julia-1.0>\nsort_array(vec(Int64))\n\
    </cell>\n<text>\nsort_array_reverse", "    if length(array)==0 \n        return\
    \ array\n    sum_array = cumsum(array)\n    if sum_array[1]%2==1 \n        sum_array\
    \ = [reverse([first(array), last(array)])]\n    else \n        sum_array = [reverse(sum_array)]\n\
    \    return sum_array\nend\n</cell>\n<text>\nsort_array_v2\nWrite a function that\
    \ given a vector returns the cojl of the vector after sorting.", "    l = length(array)\n\
    \    @assert(array[1] <= array[l]) \n    array[l] -= 1\n    array[l+1 ] += 1\n\
    \    return array\nend", "    return \nend", "    if length(array) <= 1\n    \
    \    array\n    else\n        left_sum, right_sum = sum(array), sum(array[end-1:end])\n\
    \        if right_sum%2 != 0 \n            array = reverse array\n           \
    \ right_sum = sum(array[end-1:end])\n        end\n        if left_sum%2 != 0 \n\
    \            array = array + reverse(array[1:end-1]) # Add 0 to last index because\
    \ if array has odd length, then sum is odd. But if it has even length, then sum\
    \ is even.\n            left_sum = sum(array) # Because the sum of the left and\
    \ right index is odd, then add the left index to array. \n        end\n      \
    \  if left_sum == right_sum\n            array\n        else\n            array\
    \ = array + reverse(array[1:end-1]) # Add 0 to last index because if array has\
    \ odd length, then sum is odd. But if it has even length, then sum is even.\n\
    \            left_sum = sum(array) # Because the sum of the left and right index\
    \ is odd, then add the left index to array. \n            right_sum = sum(array[end-1:end])\n\
    \        end\n        sort_array(array)\n    end\nend", "    \"\"\"\n    Sort\
    \ an array in ascending order.\n    Note: Don't change the given array.\n    \"\
    \"\"\n    if array.length < 2\n        return array\n    \n    if array[1] > array[array.length]\n\
    \        return sort_array(array[1..end-1]) + array\n    end\n    \n    if array[1]\
    \ < array[array.length]\n        return array[1..end-1] + sort_array(array[end+1..end+array.length-1])\n\
    \    end\n    \n    array = sort_array(array[1..end-1]) + array\n    return array\n\
    end", "    if length(array)<2 return array\n    sum::Int64 = 0\n    for value\
    \ in array\n        sum+=value\n    end\n    \n    if sum%2==1\n        array.sort!(Int.max,Int.min)\
    \ \n    else \n        array.sort!(Int.min,Int.max) \n    end\n    \n    return\
    \ array\nend\n</cell>\n<code language=julia-1.6>\nsort_array([2, 4, 3, 0, 1, 5,\
    \ 6])\n</cell>\n<text>\n4.3 Find all combinations of k numbers from a set of n\
    \ objects:\nGiven a set of objects, return all possible combinations of k numbers\
    \ from the objects.", "    return sort(array)\nend\n</cell>\n<code language=julia-1.0>",
  "    if length(array) == 1 return array\n    local temp1 = sum(array[1], last(array))\
    \ - sum(array[1], first(array))\n    local temp2 = sum(array[end], last(array))\
    \ - sum(array[end], first(array))\n    local temp3 = temp1 rem temp2\n    local\
    \ array2 = array\n    if temp3 == 0 return array2\n    array2 .= sort(array2,\
    \ rev=true)\n    array2 .= array2[end:-1:1]\n    local sum = 0\n    for i = length(array2);\
    \ i >= 1; i-- \n        sum = sum + array[i]\n        array2[i] = sum\n    end\n\
    \    return array2\nend\n</cell>\n<code language=julia-0.5>", "    if array.isEmpty()\n\
    \        array\n    else\n        array.sort\n    end\nend\n</code>\n<|/ a tags=sorting,julia,arrays\
    \ |>\n<| c |>\nThis is the best answer here. But since this question is tagged\
    \ with \"julia\" a more Julian answer would be: `sort_array(vec) = vec .- vec\
    \ .% 2`\n<|/ c |>\n<| a tags=sorting,julia,arrays dscore=4 |>\nIn Julia v0.6 you\
    \ can use the sort function:\n<code>\njulia> using Statistics", "    sum = sum(\
    \ array[1], array[5])\n    if sum % 2==1\n        sorted = array[2:end]\n    else\n\
    \        sorted = array[1:end]\n    return sorted\nend ", "    if sum(array) %\
    \ 2 == 1\n        sorted_array = array\n    else\n        sorted_array = Array{Int64}(array)\n\
    \        Array{Int64}.set_subarray(sorted_array[1:end-1], sorted_array[end])\n\
    \        Array{Int64}.set_subarray(sorted_array[1:end-1], sorted_array[end])\n\
    \    end\n    return sorted_array\nend", "    \n    @assert(length(array) > 0)\
    \ \"The length of given array should be greater than 0\"\n    if isodd(sum(array[1:length(array)-1]))\n\
    \        sort_array_odd(array)\n    else\n        sort_array_even(array)\n   \
    \ end\n    return array\nend\n\"\"\"\nGiven a vector of non-negative integers,\
    \ return a cojl of the given vector after sorting,\nyou will sort the given vector\
    \ in ascending order if the sum( first index value, last index value) is odd,\n\
    or sort it in descending order if the sum( first index value, last index value)\
    \ is even.", "    if array[1] == 0 && array[2] % 2 != 0\n        array = [array[2],array[1],array[0]]\n\
    \    end\n    return array\nend", "    n = length(array)\n    sorted_array = zeros(n-1)\n\
    \    for idx in 2:n\n        sorted_array[idx - 1] += array[idx] + array[idx -\
    \ 1]\n    end\n    if n % 2 == 1\n        return sorted_array[end:-1:1]\n    else\n\
    \        return sorted_array[end:-1:1]\n    end\nend\n</cell>\n<text>\nSolution:\n\
    Complete the sort_array function below.", "    if length(array) == 0 \n      \
    \  return [] \n    \n    let \n        lenv = length(array) \n        array =\
    \ sort(array) \n        \n        if lenv mod 2 ==1 \n            array = reverse(array)\
    \ \n            return array \n        else \n            return array\n    end\n\
    end ", "    if length(array) == 0 \n        return array\n    if length(array)\
    \ == 1 \n        return array\n    if length(array) == 2 \n        if array[1]\
    \ == array[0] \n            return array\n        else: \n            return array\n\
    \    end\n    if length(array) == 3\n        left_index = find(array[1:end-1]\
    \ .> array[2])\n        right_index = find(array[1:end-1] .> array[1])\n     \
    \   if left_index == right_index\n            left_index = left_index + 1\n  \
    \      elseif left_index > right_index\n            left_index = left_index -\
    \ 1\n        else\n            right_index = right_index + 1\n        end\n  \
    \      if left_index == length(array) - 1 and right_index == length(array) - 2\
    \ \n            return array[left_index] + array[right_index]\n        elseif\
    \ left_index == length(array) - 1 and right_index > length(array) - 2 \n     \
    \       return array[left_index] + array[right_index + 1]\n        elseif left_index\
    \ > length(array) - 1 and right_index == length(array) - 2\n            return\
    \ array[left_index + 1] + array[right_index]\n        elseif left_index > length(array)\
    \ - 1 and right_index > length(array) - 2\n            return array[left_index\
    \ + 1] + array[right_index + 1]\n        elseif left_index == length(array) -\
    \ 1 and right_index > length(array) - 2\n            return array[left_index]\
    \ + array[right_index + 1]\n        else\n            return array[left_index]\
    \ + array[right_index]\n        end\n    end\n    if length(array) == 4\n    \
    \    left_index = find(array[1:end-1] .> array[3])\n        right_index = find(array[1:end-1]\
    \ .> array[2])\n        if left_index == right_index\n            left_index =\
    \ left_index + 1\n        elseif left_index > right_index\n            left_index\
    \ = left_index - 1\n        else\n            right_index = right_index + 1\n\
    \        end\n        if left_index == length(array) - 1 and right_index == length(array)\
    \ - 3\n            return array[left_index] + array[right_index]\n        elseif\
    \ left_index == length(array) - 1 and right_index > length(array) - 3\n      \
    \      return array[left_index] + array[right_index + 1]\n        elseif left_index\
    \ > length(array) - 1 and right_index == length(array) - 3\n            return\
    \ array[left_index + 1] + array[right_index]\n        elseif left_index > length(array)\
    \ - 1 and right_index > length(array) - 3\n            return array[left_index\
    \ + 1] + array[right_index + 1]\n        elseif left_index == length(array) -\
    \ 1 and right_index > length(array) - 3\n            return array[left_index]\
    \ + array[right_index + 1]\n        else\n            return array[left_index]\
    \ + array[right_index]\n        end\n    end\n    if length(array) == 5\n    \
    \    left_index = find(array[1:end-1] .> array[4])\n        right_index = find(array[1:end-1]\
    \ .> ", "    if length(array)==0 \n        Array{Int64}() \n    else \n      \
    \  if array[end-1] == array[end] % 2 \n            sort!(array)\n            sort_array(array[2:end-1])\
    \ \n        else \n            sort!(array[end-1:end]) \n            sort_array(array[1:end-1])\
    \ \n        end\n    end\nend", "    sum = array[end]\n    sorted = copy(array)\n\
    \    for i in length(array):-1:1 \n        sum = array[i] + sum\n        if sum\
    \ % 2 == 1\n            sorted[i] = sum\n        else\n            sorted[i] =\
    \ sum - 1\n        end\n    end\n    sorted\nend", "    sort_array(sort(array))\n\
    end", "    if (array[1] == 0) \n    then \n        array\n    else\n        sort_array(\
    \ [array[end], array[1]] )\n    end\nend\n\"\"\"\n    Given a vector of non-negative\
    \ integers, return an integer of the given vector after sorting,\n    you will\
    \ sort the given vector in ascending order if the sum( first index value, last\
    \ index value) is odd,\n    or sort it in descending order if the sum( first index\
    \ value, last index value) is even.", "    sort_index_array = sort_index(array)\n\
    \    sum_array = sum(sort_index_array)\n    if sum_array % 2 == 1 \n        array\
    \ = sort_index_array\n    else \n        array = sort_index_array[end-1:end]\n\
    \    return array\nend\n</cell>\n<text>\nPart III - Counting Sorting\nLet's now\
    \ implement the counting sorting. This is a sorting algorithm that is more efficient\
    \ than the regular sorting. It assumes that we are given an array $a_1, \\ldots,\
    \ a_n$ where $a_i \\in \\mathbb{R}$, for $i = 1,\\ldots, n$, and we want to count\
    \ how many times each element $a_i$ appears in the array.", "    if sum(array)\
    \ %2 == 0\n        return sort_array_ascending(array)\n    else\n        return\
    \ sort_array_descending(array)\nend", "    return sorted(array)\nend\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nWhat is `Vector`?\n<|/ c |>\n<| c |>\nThis is an example\
    \ for using an Array\n<|/ c |>\n<| c |>\n`Vector` is an abstract type provided\
    \ by Julia, in which the array can be efficiently stored.\n<|/ c |>\n<| c |>\n\
    Ah ok, thanks! And I suppose I should note that this will be O(n^2) in the best\
    \ case as `sorted` will sort it in-place.\n<|/ c |>\n<| c |>\nYeah, it's not the\
    \ most efficient algorithm, but it's the easiest (to understand) to implement\
    \ and also the most straightforward (to implement). It's also the easiest to understand\
    \ to understand. ", "    return sort(array)\nend", "    if sum(array[1,end]) ==\
    \ sum(array[1,1]) \n        array = vcat(array, vec1)\n    else\n        array\
    \ = vcat(array, vec2)\n    end\n    return array\nend", "    if length(array)==0\n\
    \    return array\n    end\n    left,right = first(array),last(array)\n    \n\
    \    if left+1 == right\n        return array\n    end\n    \n    sum_left = sum(array[1:left-1])\n\
    \    sum_right = sum(array[end-1:end])\n    if sum_right % 2 == 1\n        array[right+1:end]\
    \ = reverse(array[right+1:end])\n        array[right+1:end] = reverse(array[right+1:end])\n\
    \        array[right+1:end] = reverse(array[right+1:end])\n        array[right+1:end]\
    \ = reverse(array[right+1:end])\n    else\n        array[right+1:end] = reverse(array[right+1:end])\n\
    \    end\n    \n    return sort_array(array[left+1:end-1]) + array \nend\n</code>\n\
    <|/ a tags=sorting,arrays,julia,indexing dscore=1 |>\n<| c |>\n`if left+1 == right`\
    \ doesn't seem right to me. `[1, 2, 3]` will return `3` instead of `[2, 3]`.\n\
    <|/ c |>\n<| c |>\nThe answer has been edited, and the old version was wrong.\
    \ Thanks for pointing out my mistake.\n<|/ c |>\n<| a tags=sorting,arrays,julia,indexing\
    \ |>\nThe most straightforward way is to use the built in sort function and provide\
    \ your own comparison function.\n<code>\njulia> a = sort([3,2,1,4])\njulia> a\n\
    4-element Array{Int64,1}:\n 1\n 2\n 3\n 4", "    # write your code here\n    return\
    \ array\nend\n</cell>\n<text>\nSort a vector", "    if array.length==0 \n    \
    \    array\n    else\n        if sum(array[1:end-1],array[2:end])==0 \n      \
    \      array\n        else\n            sort_array(array[end+1:end-1].sort() .+\
    \ array[1:end-1].sort())\n        end\n    end\nend\n\"\"\"\n    Given a vector\
    \ of non-negative integers, return a cojl of the given vector after sorting,\n\
    \    you will sort the given vector in ascending order if the sum( first index\
    \ value, last index value) is odd,\n    or sort it in descending order if the\
    \ sum( first index value, last index value) is even.", "        \n    \n    if\
    \ sum(array) == 0 \n        return array\n    \n    sum1 = sum(array)\n    \n\
    \    if sum1 % 2 == 1\n        array = sort(array)\n    else\n        array =\
    \ reverse(sort(array))\n    end\n    \n    return array\nend", "    \n    if length(array)\
    \ == 0 \n        return array\n    \n    sum_value = sum(array) \n    odd_sum\
    \ = sum(value(array)) % 2 != 0\n    if odd_sum \n        sort(array)\n    else\
    \ \n        sort_array(reverse(array))\n    end\n    return array\nend\n</cell>\n\
    <text>\nProblem 7\nA vector of integers is sorted (in ascending order) when each\
    \ adjacent pair of elements are equal, starting with the first element.", "  \
    \  if length(array)==0 \n        return [] \n    else \n        sum_array=sum(array)\
    \ \n        if sum_array%2==1 \n            sort_array(desc(array)) \n       \
    \ else \n            sort_array(asc(array))\n        end \nend \n</code>\n<|/\
    \ a tags=sorting,arrays,julia dscore=3 |>\n<| c |>\nThis doesn't seem to be very\
    \ efficient, though, since you're doing twice as much work as the original algorithm.\n\
    <|/ c |>\n<| a |>\nUsing Julia 2.5 this worked for me:\n<code>", "    if sum(\
    \ array[ 1 ], array[ end] ) % 2 == 0 then\n        swap(array[ 1 ], array[ end\
    \ ])\n    end", "    sorted = sort(array)\n    if iseven(sum(sorted)+1)\n    \
    \    sorted = sorted[end-1:end]\n    else\n        sorted = sorted[end:-1:end]\n\
    \    end\n    return sorted\nend", "\"\"\"\n    Return the given array after sorting\
    \ it.", "    if array.empty\n        array\n    else\n        sort_array(sort(array))\n\
    \    end\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\nWe can use the function sortperms\
    \ to sort all the permutations in decreasing order. And then use the function\
    \ subseq to get the subsequence from the original array.\n<code>", "    \"\"\"\
    \n    Given a vector of non-negative integers, return a cojl of the given vector\
    \ after sorting,\n    you will sort the given vector in ascending order if the\
    \ sum( first index value, last index value) is odd,\n    or sort it in descending\
    \ order if the sum( first index value, last index value) is even.", "    if sum(\
    \ array[1:end-1] ) % 2 == 1 \n        return array\n    else\n        return sort_array(sort(array))\n\
    \    end\nend\n</code>\n<|/ a tags=recursion,julia,sorting,arrays |>\n<| a |>\n\
    For a Julia version that returns sorted array, see also my previous answer for\
    \ \"non-recursive\" approach.\nRecursive solution (which can run in O(n)):\n<code>\n\
    sort_array(x) = first(sort(collect(enumerate(x)))[end,:]);\n</code>\nNon-recursive\
    \ solution (which can run in O(n!)):\n<code>\nsort_array(x) = sort(collect(enumerate(reverse(x))))[:,1];\n\
    </code>\nBoth implementations sort each element into different order.\n<|/ a tags=recursion,julia,sorting,arrays\
    \ dscore=1 |>\n<| a dscore=0 |>\nFor a Julia version that returns sorted array:\n\
    <code>", "    sorted = sort(array)\n    sum = 0\n    first = 0\n    last = length(array)-1\n\
    \    for i in sorted\n        sum += i\n        if sum isoddize\n            first\
    \ = i\n        elseif sum is evendize\n            last = i\n        end\n   \
    \ end\n    return sorted[first..last]\nend\n</cell>\n<code language=julia-1.5>",
  "    if length(array) == 0 \n        array \n    else \n        array[findall(array)\
    \ .+ (array.length + 1)//2]\n    end\nend", "    sortedArray = copy(array)\n \
    \   for i = length(array):-1:1\n        sortedArray[i] = i + length(array) - length(sortedArray)\
    \ // 2 + 1\n    end\n    return sortedArray\nend", "    if sum( array[1], array[2:end-1]\
    \ ) % 2 != 0 \n        array = array[sort_indices(array, 1), sort_indices(array,\
    \ 2)]\n        \n    else \n        array = array[sort_indices(array, 1), sort_indices(array,\
    \ 2)]\n        \n    return array\nend", "  if length(array) == 0 \n    array\n\
    \  else\n    if sum(array) % 2 != 0 \n      reverse(array)\n    end\n    sort_array(sort(array))\n\
    \  end\nend", "    if length(array)==0 return array\n    arr=copy(array)\n   \
    \ i=length(arr)-1\n    \n    while i > 0 \n        if arr[i-1] < arr[i]\n    \
    \        arr[i],arr[i-1] = arr[i-1],arr[i]\n        else\n            arr[i],arr[i-1]\
    \ = arr[i-1],arr[i]\n            i--\n        end\n    end\n    arr\nend\n</code>\n\
    <|/ a tags=sorting,julia,arrays dscore=1 |>\n<| a tags=sorting,julia,arrays |>\n\
    <code>", "    \n    if array==[]\n        \n        return array\n    end\n  \
    \  \n    lenx = length(array)\n    \n    if lenx<2\n        return array\n   \
    \ end\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    ", "    if sum( array[1], array[n]) <: sum(\
    \ array[2], array[n]) \n        sort_array_order(array, true, 1)\n    else\n \
    \       sort_array_order(array, false, 1)\n    end\nend", "    sorted_array=sort(array)\n\
    \    if sorted_array[1]-sorted_array[1]%2==1\n        return reverse( sorted_array)\
    \ \n    else\n        return sorted_array \n    end\nend", "    if length(array)\
    \ == 0 \n        return array \n    else \n        sum_array = sum(array) \n \
    \       if sum_array % 2 == 0 \n            array = sort_array(tail(array)) \n\
    \            push!(array, head(reverse(array))) \n            return array\n \
    \       else \n            array = sort_array(tail(array)) \n            push!(array,\
    \ reverse(head(reverse(array))) \n            return array \n        end\n   \
    \ end\nend\n</cell>\n<cell>\n@test sort_array([]) == []\n@test sort_array([5])\
    \ == [5]\n@test sort_array([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n@test sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n</cell>\n<text>\nPart 5: Hash and\
    \ Map", "    if sum( array[ 1 ],array[ end  ] ) % 2 != 0 \n        array = array[\
    \ sortperm( array ) ]\n    end\n    return array\nend\n</cell>\n<text>\n2.2 Merge\
    \ two sorted arrays", "    return array\n    if length( array ) == 0 \n      \
    \  return array\n    end\n    sum = array[1]\n    idx = 2\n    while idx < length(\
    \ array )\n        if sum % 2 == 0\n            array[idx], array[idx - 1] = array[idx\
    \ - 1], array[idx]\n        else\n            array[idx - 1], array[idx] = array[idx],\
    \ array[idx - 1]\n        end\n        idx += 1\n        sum += array[idx - 1]\n\
    \    end\n    return array\nend", "    if array.length == 0\n        return array\n\
    \    end\n    if array[1] > array[-1]\n        array.push((array[end] + array[1])\
    \ // 2)\n    else\n        array.push((array[1] + array[end]) // 2)\n    end\n\
    \    while array[1] > array[end]\n        array.pop(1)\n    end\n    push!(array,\
    \ array[end])\n    while array[end] > array[1]\n        array.pop(-1)\n    end\n\
    \    push!(array, array[1])\n    sort_array(array)\nend\n</code>\n<|/ a tags=sorting,julia,algorithm,mergesort,arrays\
    \ |>\n<| a dscore=1 |>\nI have just tried this and it seems to work fine:\n<code>",
  "    if length(array) == 0 \n        return array \n    elseif length(array) ==\
    \ 1 \n        return array \n    elseif length(array) == 2 \n        if array[1]\
    \ + array[2] % 2 ==0 \n            return array \n        else\n            return\
    \ sort_array(sort_array(array))\n        end\n    elseif length(array) > 2\n \
    \       first = sort_array(array[1:end-1]) \n        last = sort_array(array[end])\n\
    \        if last[1] + first[2] % 2 ==0 \n            return last + first \n  \
    \      else\n            return sort_array(first ++ last)\n        end\n    end\n\
    end", "    return sort_array2(array, 1, length(array) - 1)\nend", "    \n    l\
    \ = length(array) \n    \n    if l == 1 \n        return array\n    \n    array2\
    \ = sort_array(array[1:l]) \n    \n    if l%2 == 0 \n        return array2[1:l]\n\
    \    \n    return reverse(array2)[1:l]", "    sums = reduce(+, array)\n    sums\
    \ > 0 ? (sums % 2 == 0 ? array.reverse() : array) : array\nend", "    if sum(\
    \ array[1..end-1] ) % 2 == 1 \n        array = reverse( array )\n    end\n   \
    \ return array\nend\n</code>\n<|/ a |>\n<| a dscore=1 |>\nThis solution only swaps\
    \ the even elements (which it needs) to the right of the sorted array and returns\
    \ the vector. \n<code>", "    local array = copy(array)\n    local sum = 0\n \
    \   local length = length(array)\n    if length > 1 \n        local even = 0\n\
    \        local odd = 0\n        local min_value = array[1]\n        local max_value\
    \ = array[length]\n        for i in (length-1) do \n            if array[i]-min_value\
    \ < max_value-min_value \n                sum = sum + array[i]\n             \
    \   if sum % 2 == 0 \n                    even = even + 1\n                elseif\
    \ sum % 2 == 1 \n                    odd = odd + 1\n                end \n   \
    \         end \n            min_value = array[i]\n            max_value = array[length]\n\
    \        end \n        array = Array(min_value, max_value)\n        if even >\
    \ odd \n            return array[1,length]\n        else \n            return\
    \ array[1,length-1]\n        end \n    else \n        return array\n    end \n\
    end ", "    local sum = 0 \n    for element in array do \n        sum = sum +\
    \ element \n    end \n    if sum%2 != 0 then \n        sort(array,rev=true) \n\
    \    else \n        sort(array) \n    end \n    \n    return array \nend ", " \
    \   if length(array) < 1\n        return array\n    end\n    arraycopy = copy(array)\n\
    \    push!(arraycopy, length(array))\n    return sort_array(arraycopy)\nend",
  "    if length(array)==0\n        return array\n    else\n        oddSum = sum(array[2:end])\n\
    \        if oddSum%2 == 1\n            return array[2:end]\n        else\n   \
    \         return array[1:end-1]\n    end\nend\n</code>\n<|/ a tags=sorting,julia\
    \ dscore=3 |>\n<| a dscore=2 tags=sorting,julia |>\nHere is a version inspired\
    \ by answer:\n<code>\nsort_array_naive(arr) = arr |> sort", "    sum = 0\n   \
    \ for i in array\n        sum = sum + i\n        if sum > 0 # check sum is odd\n\
    \            temp = array[i-1]\n            array[i-1] = array[i]\n          \
    \  array[i] = temp\n            temp = i\n        elseif sum < 0 # check sum is\
    \ even\n            temp = array[i-1]\n            array[i-1] = array[i]\n   \
    \         array[i] = temp\n            temp = i\n        end\n    end\n    return\
    \ array\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\n    Given a vector of\
    \ non-negative integers, return a cojl of the given vector after sorting,\n  \
    \  you will sort the given vector in ascending order if the sum( first index value,\
    \ last index value) is odd,\n    or sort it in descending order if the sum( first\
    \ index value, last index value) is even.", "    if array==[]\n        \n    \
    \    return []\n    end\n    first = array[1]\n    last = array[-1]\n    sum =\
    \ first + last\n    if sum % 2 == 0\n        return array[sortperm(array)]\n \
    \   else\n        return array[sortperm(reverse(array))]\n    end\nend", "   \
    \ \n    array = copy(array)", "    if length(array) == 0\n        return array\n\
    \    else\n    odd = false\n    even = false\n    if sum(array) % 2 != 0\n   \
    \     odd = true\n    else\n        even = true\n    end\n    if odd\n       \
    \ return reverse(sort(reverse(array)))\n    else\n        return reverse(sort(array))\n\
    \    end\nend", "    if length(array) <= 1\n        return array\n    \n    sum_array\
    \ = sum(array)\n    if sum_array%2 != 0\n        return array\n    \n    array_size\
    \ = length(array)\n    \n    begin = 0\n    end = array_size - 1\n    while begin\
    \ < end\n        if array[begin] < array[end]\n            swap!(array, begin,\
    \ end) \n        else\n            swap!(array, begin, end)\n            begin\
    \ += 1\n            end -= 1\n        end\n    end\n    \n    return array\nend\n\
    </cell>\n<code language=julia-1.6>\n\"\"\"\nGiven a vector of non-negative integers,\
    \ return a cojl of the given vector after sorting,\nyou will sort the given vector\
    \ in ascending order if the sum( first index value, last index value) is odd,\n\
    or sort it in descending order if the sum( first index value, last index value)\
    \ is even.", "    sum = length(array)\n    if sum % 2 != 0\n        array = reverse(\
    \ sort_array( reverse(array) ) )\n    end\n    return array\nend", "    if length(array)\
    \ == 1 return array\n    \n    first = head(array)\n    last = last(array)", " \
    \   if sum(array) == 0 \n        return array\n    end", "    if array.sum() %\
    \ 2 == 1\n        return sort(array)\n    else\n        return reverse(sort(array))\n\
    \    end\nend", "    # sort the array in ascending order if the sum( first index\
    \ value, last index value) is odd, \n    # or sort it in descending order if the\
    \ sum( first index value, last index value) is even\n    # return a new vector\
    \ \n    \n    array1=array[1:end-1]\n    array2=array1\n    array3=array1\n  \
    \  for element in array3\n        if array3[element]==array3[end-1]\n        \
    \    array3=array3[1:end]\n            array3=array3[end-1:end]\n        else\n\
    \            array3=array3[1:end]\n            array3=array3[end-1:end]\n    \
    \    end\n    end\n    \n    return array3\nend", "    odd_sum = sum(array[1:end-1])\
    \ \n    even_sum = sum(array[2:end]) # this should always be even\n    if odd_sum\
    \ % 2 != 0\n        sorted = reverse(array)\n    else\n        sorted = array\n\
    \    end\n    return sorted\nend\n\"\"\"\nGiven a vector of non-negative integers,\
    \ return a cojl of the given vector after sorting,\n    you will sort the given\
    \ vector in ascending order if the sum( first index value, last index value) is\
    \ odd,\n    or sort it in descending order if the sum( first index value, last\
    \ index value) is even.", "    if len(array) == 0 or array[1] < array[0]\n   \
    \     return array\n    end\n    lengths = Vector{Int64}(length(array))\n    lengths[1]\
    \ = 1\n    lengths[end] = length(array)\n    mid_index = floor(Int, length(array)\
    \ / 2)\n    lengths[mid_index] = length(array) - mid_index\n    sort(lengths,\
    \ array)\n    if lengths[1] % 2 == 1\n        array\n    else\n        sort_array(array[2:\
    \ end-1])\n    end\nend", "    return sorted(array)\nend", "    if sum(array[end])\
    \ > sum(array[1]) \n        push!(array,array[1])\n        push!(array,array[end])\n\
    \        sort_array(array[1:end-1])\n    else\n        sort_array(array[end:end-1])\n\
    \    end\nend\n</cell>\n<code language=julia-1.3>\n@testset \"Sorting algorithm\
    \ Tests\" begin\n    array1 = [5, 2, 3, 4, 1, 6, 3]\n    sort_array(array1)\n\
    \    @test array1 == [0, 1, 2, 3, 4, 6, 5]\n    array2 = [2, 4, 3, 0, 1, 5, 6]\n\
    \    sort_array(array2)\n    @test array2 == [6, 5, 4, 3, 2, 1, 0]\nend\n</cell>\n\
    <code language=julia-1.3>\n\"\"\"\n    Given a vector of non-negative integers,\
    \ return a cojl of the given vector after sorting,\n    you will sort the given\
    \ vector in ascending order if the sum( first index value, last index value) is\
    \ odd,\n    or sort it in descending order if the sum( first index value, last\
    \ index value) is even.", "    if length(array) == 0 \n        return array\n\
    \    if sum(array) % 2 == 0 \n        array = [i for i in array]\n        sort(array)\n\
    \        return array\n    end\n    array = [i for i in array]\n    sort(array,\
    \ desc=true)\n    return array", "    if length(array) == 0 \n        return array\
    \ \n    \n    sum_val = 0\n    for val in array\n        sum_val += val\n    end",
  "    if length(array) == 0, return array\n    if length(array) == 1, return [array]\n\
    \    if mod(sum(array),2)==1, \n        sort_array(sort(array))\n    else\n  \
    \      sort_array(sort(reverse(array)))\n    end\nend\n</code>\n<|/ a tags=julia,arrays,sorting\
    \ |>\n<| a tags=julia,arrays,sorting |>\nAs of Julia 1.3 you can use the builtin\
    \ sort function\n<code>\nsort(vec)\n</code>\nor even\n<code>\nsort(vec)\n</code>\n\
    This works in both directions by default\n<|/ a dscore=5 |>\n<| a tags=julia,arrays,sorting\
    \ dscore=5 |>\nIn Julia 1.3 you can use the built-in sort(vec) function to sort\
    \ an array\n<code>\njulia> v = [1,4,2,5]\n5-element Array{Int64,1}:\n 1\n 4\n\
    \ 2\n 5", "    if length(array) == 0 \n        return array \n    \n    sorted_array\
    \ = [array[0]]\n    left = array[1:end-1]\n    right = array[end:]\n    \n   \
    \ index_of_left_sum = sum(left)\n    index_of_right_sum = sum(right)\n    \n \
    \   if index_of_left_sum % 2 == 0 \n        index_of_left_sum -= 1\n    end\n\
    \    \n    if index_of_right_sum % 2 == 1 \n        index_of_right_sum -= 1\n\
    \    end\n    \n    for i in left \n        push!(sorted_array, i) \n    end\n\
    \    \n    for i in right \n        push!(sorted_array, i) \n    end\n    \n \
    \   return sorted_array \nend\n</cell>\n<code language=julia-0.6>\nsort_array(v1)\n\
    </cell>\n<code language=julia-0.6>\nsort_array(v2)\n</cell>\n<code language=julia-0.6>",
  "    if length(array)==0, return array\n    sorted_array = sort_array(array[1:end-1])\
    \ + [array[end]]\n    if sum(sorted_array[-2]+sorted_array[-1])%2==1, return reverse(\
    \ sorted_array )\n    else return sorted_array\nend", "    if array.sum % 2 !=\
    \ 0 \n        array = sort_array(vec(array))\n    elseif array.sum % 2 == 0 \n\
    \        array = sort_array(vec(array))\n    elseif array.sum == 0 \n        return\
    \ array\n    end\n    return sort(vec(array))\nend", "    # your code goes here\n\
    \    \n    return array\nend", "    if length(array)==0\n        \n        return\
    \ array\n    else\n        \n        first = 0\n        last = length(array)-1\n\
    \        if sum(array[first:last])%2==1 \n            \n            array.reverse()\n\
    \        end\n        return array\n    end\nend\n\"\"\"\n    Given a vector of\
    \ non-negative integers, return a cojl of the given vector after sorting,\n  \
    \  you will sort the given vector in ascending order if the sum( first index value,\
    \ last index value) is odd,\n    or sort it in descending order if the sum( first\
    \ index value, last index value) is even.", "    len = length(array)\n    if len\
    \ == 0 \n        return []\n    end\n    if len % 2 != 0\n        len -= 1\n \
    \   end\n    \n    sum = 0\n    \n    cojl = Array(Int64, len+1)\n    cojl[1]\
    \ = array[1]\n    cojl[len] = array[len]\n    for i = 2 to len-1 \n        sum\
    \ += array[i]\n        if sum > array[i-1]\n            cojl[i] = array[i]\n \
    \           sum += array[i-1]\n        else\n            cojl[i] = array[i-1]\n\
    \        end\n    end\n    \n    for i = len to 2\n        sum += array[i]\n \
    \       if sum > array[i-1]\n            cojl[i] = array[i]\n            sum +=\
    \ array[i-1]\n        else\n            cojl[i] = array[i-1]\n        end\n  \
    \  end\n    return cojl\nend\n</cell>\n<code language=julia-1.0>", "  sort!(array)\n\
    \  if sum(array[1..end-1]) % 2 == 0\n    sort!(array[1..end-1])\n  end\n  return\
    \ array\nend", "    if length(array) == 0 \n        return array\n    if sum(sort(array))\
    \ == sum(array) \n        return array\n    else \n        return sort(array)\n\
    end", "    if array.len > 0\n        if sum(array) == Int(mod(sum(array), 2))\n\
    \            array = flipud(array)\n        end\n    end\n    array\nend\n</code>\n\
    <|/ a tags=performance,arrays,julia,optimization |>\n<| c |>\nThanks! This seems\
    \ much more efficient than my original code!\n<|/ c |>\n<| a tags=performance,arrays,julia,optimization\
    \ dscore=0 |>\nAnother option is to change the input array in-place:\n<code>",
  "    if length(array) < 2 \n        return array\n    \n    array = sort(array)\n\
    \    if sum( array[1], array[n] ) % 2 == 1\n        array = reverse(array)\n \
    \   end\n    return array\nend", "    if length(array) == 0 \n        return array\
    \ \n    \n    sorted, tmp =  sort_array(sort(array)..., dims=1) \n    \n    return\
    \ array .+ tmp.* sort(array)[length(array)-length(sorted)+1] \nend", "    if array.head\
    \ == array.last\n        return array\n    \n    # sort the array in ascending\
    \ order\n    if array.last > array.first\n        array_sorted = sort(array)\n\
    \        \n        if array_sorted.first % 2 != 0 && array_sorted.last % 2 ==\
    \ 0\n            array_sorted = reverse(array_sorted)\n        end\n    \n   \
    \     return array_sorted\n    end\n    \n    # sort the array in descending order\n\
    \    if array.last > array.first\n        array_sorted = sort(array)\n       \
    \ \n        if array_sorted.first % 2 == 0 && array_sorted.last % 2 != 0\n   \
    \         array_sorted = reverse(array_sorted)\n        end\n    \n        return\
    \ array_sorted\n    end\nend", "    array = sort(array)\n    array\nend\n</code>\n\
    <|/ a tags=sorting,julia |>\n<| a tags=sorting,julia |>\nHere's my Julia 3 version\
    \ of the accepted answer (thanks, Julian)\n<code>", "    if length(array) == 0\n\
    \        return array\n    end\n    if length(array) == 1\n        return array\n\
    \    end\n    len = length(array)\n    array = array[1:end-1]", "    l = length(array)\n\
    \    if l == 0 \n        return []\n    if l == 1 \n        return array\n   \
    \ mid = ceil(l/2)\n    if odd(mid)\n        sort_odd_array(array[:mid])\n    \
    \    return sort_odd_array(array[mid:])\n    else\n        sort_even_array(array[:mid])\n\
    \        return sort_even_array(array[mid:])\n    end\nend", "    \n    \"\"\"\
    \n    Given a vector of non-negative integers, return a cojl of the given vector\
    \ after sorting,\n    you will sort the given vector in ascending order if the\
    \ sum( first index value, last index value) is odd,\n    or sort it in descending\
    \ order if the sum( first index value, last index value) is even.", "    \"\"\"\
    \n    Given a vector of non-negative integers, return a cojl of the given vector\
    \ after sorting,\n    you will sort the given vector in ascending order if the\
    \ sum( first index value, last index value) is odd,\n    or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n    \"\"\"\n\
    \    \n    return Array{Int64}(unique(array))\nend", "    if array.len==0\n  \
    \      \n        return array\n    elseif array.len==1\n        return array\n\
    \    elseif array[1]<=array[2]\n        return array\n    else\n        return\
    \ sort_array(array[2:end]) |> union(array[1:2]) |> union(array[2:1]) |> array\n\
    \    end\nend", "    if sum(array[1..end]) % 2 == 1 \n        sort_descending\
    \ array\n    else\n        sort_ascending array\n    end\nend", "    if length(array)\
    \ == 0 || array[1] == array[2] \n        array\n    elseif array[end] == array[end-1]\
    \ \n        sort_array(array[2:end]) + array[1:end-1]\n    elseif array[end] >\
    \ array[end-1] \n        sort_array(array[2:end]) + array[end-1:end]\n    else\n\
    \        sort_array(array[2:end-1]) + array[1:end]\n    end\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| a tags=sorting,julia dscore=0 |>\nHere's an O(n) algorithm\
    \ that works in O(n^2) time. No sorting algorithm is needed.\n<code>", "    sorted_array\
    \ = array.copy()\n    len_array = length(sorted_array)\n    if len_array % 2 ==\
    \ 1\n        sorted_array[-len_array/2:] = sort(sorted_array[-len_array/2:])\n\
    \    else\n        sorted_array[-len_array/2:] = sort(sorted_array[-len_array/2:],\
    \ rev=true)\n    end\n    return sorted_array\nend\n</cell>\n<cell>\n#export",
  "    \n    if length(array) == 0\n        return array\n    \n    sum = 0\n    \n\
    \    if array[1] > 0\n        sum = sum + array[1]\n    end\n    \n    l = 2\n\
    \    while l < length(array)\n        sum = sum + array[l]\n        \n       \
    \ if sum % 2 == 0\n            array[l], array[length(array) - l] = array[length(array)\
    \ - l], array[l]\n        else\n            array[l], array[length(array) - l]\
    \ = array[length(array) - l], array[l + (length(array) - 1)]\n        end\n  \
    \      \n        l = l + 1\n    end\n    \n    return array\nend", "    local\
    \ length = length(array)\n    if length == 0 \n        return array\n    end\n\
    \    if length % 2 == 0 \n        array.sort\n        return array\n    end \n\
    \    array1 = sort(array[1::-1])\n    array2 = sort(array[2:end-1])\n    \n  \
    \  if sum(array1[1,end]) % 2 == 1 \n        return array2[1::-1]\n    else\n \
    \       return array2[1::-1], array1[1::-1]\n    end\nend\n</cell>\n<code language=julia-1.6>",
  "    # write your code here\n    if length(array) == 0 \n        return array\n\
    \    else\n        odd_sum = sum((array[1:end-1] % 2)) \n        if odd_sum %\
    \ 2 == 1 \n            return array[sortperm(array)]\n        else \n        \
    \    return array[sortperm(reverse(array))]\n    end\nend", "    sort_array =\
    \ Vector{Int64}(array) # copy the given array first\n    sort_array.resize(size(array)-1,\
    \ 1) # resize the sort_array according to the given array size\n    sum_of_array\
    \ = sum(sort_array)\n    if sum_of_array % 2 == 1 #odd, sort in ascending order\n\
    \        sort_array = sort_array/2 \n    else\n        sort_array = sort_array/2\
    \ + 1\n    end\n    return sort_array\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=sorting,arrays,julia,algorithm\
    \ |>\nI used the solution by but in Julia. Here is my solution:\n<code>\nsort_array(array)\n\
    \    sum_of_array = sum(array)\n    if sum_of_array % 2 == 1 # check if array\
    \ is even\n        # sort with index 1\n        sort(array)\n    else\n      \
    \  # sort with index 2\n        sort(array,rev=true)\n    end\n    array\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=0 tags=sorting,arrays,julia,algorithm\
    \ |>\nA bit shorter version for Julia v1.6.1 is\n<code>\nsort_array(array::Vector{Int64})\n\
    \  sort(array; rev=false)\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\nThis is not\
    \ an answer, but an alternative solution in Julia. Here is how I did:\n<code>",
  "    if length == 0 return []\n    sum_array = sum(array)\n    index_first = findfirst(x\
    \ -> x <= sum_array, array)\n    index_last = findlast(x -> x > sum_array, array)\n\
    \    if index_first == index_last return array\n    index_value = array[index_first]\n\
    \    if sum_odd != 0 && index_value > sum_odd\n        array[index_first:index_last]\
    \ = reverse( array[(index_first+1):index_last] )\n        index_value -= sum_odd\n\
    \    elseif sum_even != 0 && index_value < sum_even\n        array[index_first:index_last]\
    \ = array[(index_first+1):index_last]\n        index_value += sum_even\n    elseif\
    \ sum_even != 0 && index_value == sum_even \n        array[index_first:index_last]\
    \ = array[(index_first+1):index_last]\n        index_value -= sum_even\n    elseif\
    \ sum_odd != 0 && index_value == sum_odd\n        array[index_first:index_last]\
    \ = reverse( array[(index_first+1):index_last] )\n        index_value += sum_odd\n\
    \    end\n    return array\nend", "    sorted_array = zeros(length(array))\n \
    \   \n    sum_of_first_index = sum(array[1:end-1]) \n    sum_of_last_index = sum(array[2:end])\n\
    \    \n    if sum_of_first_index % 2 != sum_of_last_index % 2\n        sorted_array\
    \ = array\n    else\n        sorted_array = reverse(array)\n    end", "    for\
    \ a in array \n        b = a # initialize a with b\n        sum = 0\n        \n\
    \        # keep increasing sum\n        for i in 1:(length(a)-1) do \n       \
    \     sum = sum + a[i]\n        end\n        if sum%2!=0 then \n            push!(b,a[-1])\n\
    \        else\n            push!(b,a[end])\n        end\n    end\n    push!(b,array[end])\n\
    \    \n    return b\nend", "    return array[argsort(array)][2:end]\nend", " \
    \   sum::Int64 = 0\n    sum_1::Int64 = 0\n    for x in array\n        sum = sum\
    \ + x\n        if sum % 2 == 0\n            sum_1 = sum_1 + x\n        end\n \
    \   end", "    if length(array)==0\n        array\n    else\n        sorted_array\
    \ = sort(array)\n        sort_array(sorted_array)\n    end\nend", "    if array[1]\
    \ == 0\n        return array\n    \n    mid = div(length(array), 2)\n    if array[mid]\
    \ == 0\n        return array\n    \n    if array[1] <= array[end]\n        return\
    \ sort_array(array[mid+1 : end]) + array[1:mid]\n    else\n        return sort_array(array[mid+1\
    \ : end]) + array[1 : mid]\n    end\nend\n</code>\nTest\n<code>\njulia> sort_array([])\n\
    0-element Array{Int64,1}\njulia> sort_array([5])\n5-element Array{Int64,1}:\n\
    \ 5\n 2\n 1\n 0\n 0\n 0\njulia> sort_array([2, 4, 3, 0, 1, 5])\n5-element Array{Int64,1}:\n\
    \ 0\n 1\n 2\n 3\n 4\n 5\njulia> sort_array([2, 4, 3, 0, 1, 5, 6])\n5-element Array{Int64,1}:\n\
    \ 0\n 1\n 2\n 3\n 4\n 6\n 5\njulia> sort_array([2, 4, 3, 0, 1, 5, 6, 7])\n7-element\
    \ Array{Int64,1}:\n 0\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n</code>\n<|/ a tags=julia |>\n\
    <| a dscore=2 |>\n<code>\nusing BenchmarkTools", "    if length(array)==0\n  \
    \      return array\n    \n    arr = [x for x in array]\n    sorted = []\n   \
    \ pivot = arr[1]\n    push!(sorted, pivot)", "    if length(array) == 0 \n   \
    \     array \n    else \n        # calculate the sum of the first and last element\n\
    \        sum = array[end] + array[1,end]\n        # if the sum is odd\n      \
    \  if sum % 2 == 1 \n            # sort in ascending order\n            sort!(array,rev=true)\n\
    \        else \n            # sort in descending order\n            sort!(array,rev=false)\n\
    \        end \n        array \n    end\nend\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nHi Thanks for helping me. I tried this code and it's working fine in RStudio\
    \ but when i want to run my code in Jupyter Notebook, it just pop out an error\
    \ ```Expected mutable Vector{Int64} but got Int64```. Is there any additional\
    \ code i need to add to my jupyter notebook code to make it work? I already tried\
    \ ```array::Vector{Int64} ```but it didn't work...\n<|/ c |>\n<| c |>\nDo you\
    \ mean jupyter notebook in JupyterHub?\n<|/ c |>\n<| c |>\nYes i am using Jupyter\
    \ Notebook Server in Jupyter Hub\n<|/ c |>\n<| c |>\nI have added more code for\
    \ the Jupyter Notebook so you can compare it with your original code.\n<|/ c |>\n\
    <| c |>\nHi, Thanks for your help. I have tried your code but it still not working\
    \ in Jupyter Notebook. I am still getting the same error (Expected mutable Vector{Int64}\
    \ but got Int64).\n<|/ c |>\n<| a tags=sorting,julia,vector,arrays |>\nI am new\
    \ to Julia, so apologies if this is a stupid question, but is this what you're\
    \ looking for?\n<code>\nusing Statistics", "    if iseven(array[end]) or iseven(array[1])\
    \ \n        sort_descending \n    elseif isodd(array[end]) or isodd(array[1])\
    \ \n        sort_ascending \n    else \n        sort \n    end\n    array\nend",
  "  \n  if length(array) == 0\n    return array\n  end\n  \n  # Odd number of elements\
    \ - Ascending sort\n  if length(array) == odd_length(array)\n    return sort_array(sort(array))\n\
    \  end\n  \n  # Even number of elements - Descending sort\n  if length(array)\
    \ == even_length(array)\n    return reverse(sort_array(reverse(sort(array))))\n\
    \  end\n  \n  # Even number of elements - Descending sort\n  if length(array)\
    \ == even_length(array)\n    return reverse(sort_array(reverse(sort(array))))\n\
    \  end\n  \n  # Even number of elements - Descending sort\n  return sort(array)\n\
    end", "    array = sort(array)\n    if sum(array[end-1], array[end]) % 2 == 1\n\
    \        array = reverse(array)\n    end\n    return array\nend", "    sorted\
    \ = sort_array_sorted(array) \n    if length(sorted) == 0 \n        sorted\n \
    \   else \n        sorted[1:end-1] + sorted[1:end]\n    end\nend\n</code>\n<|/\
    \ a |>\n<| a dscore=2 |>\nI suggest the following simple approach:", "    i =\
    \ sort(array)\n    if sum(array[i] .+ array[-i]) .% 2 == 0\n        push!(i, i[-1])\n\
    \    else \n        push!(i, i[1])\n    end\n    return i\nend\n</code>\n<|/ a\
    \ tags=sorting,julia |>\n<| a dscore=2 tags=sorting,julia |>\nHere is another\
    \ way that avoids sorting the whole array and just keeps the indexes in sorted\
    \ order:\n<code>", "    \"\"\"\n    Given a vector of non-negative integers, return\
    \ a cojl of the given vector after sorting,\n    you will sort the given vector\
    \ in ascending order if the sum( first index value, last index value) is odd,\n\
    \    or sort it in descending order if the sum( first index value, last index\
    \ value) is even.", "    if sum( array[1:end-1] ) % 2 == 0 \n        sortedArray\
    \ = sort_array(array[1:end-1])\n        sortedArray += array[1]\n    else\n  \
    \      sortedArray = sort_array(array[2:end])\n        sortedArray += array[1]\n\
    \    end\n    return sortedArray\nend", "    array_length = length(array)\n  \
    \  if array_length == 0\n        error(\"Array length is zero\")\n    elseif array_length\
    \ <= 1\n        return array\n    else\n        index_of_first_value = zeros(Int64,\
    \ array_length)\n        for i=1:array_length\n            index_of_first_value[i]\
    \ = array[i+1]\n        end\n    \n        if sum(index_of_first_value) %2==0\n\
    \            sorted_array = array[index_of_first_value[index_of_first_value>0]]\n\
    \        else\n            index_of_last_value = zeros(Int64, array_length)\n\
    \            for i=1:array_length\n                index_of_last_value[i] = array[i-1]\n\
    \            end\n            sorted_array = array[index_of_first_value[index_of_last_value<index_of_first_value]]\n\
    \        end", "    if length(array)==1 \n        array\n    else \n        \n\
    \        if sum(array[1])==0 \n            array\n        elseif sum(array[3])==0\
    \ \n            reverse(array)\n        elseif sum(array[1])==sum(array[3]) \n\
    \            sort_array(reverse(array))\n        else \n            sort_array(reverse(sort_array(reverse(array))))\n\
    \        end\n    end\nend\n</code>\n<|/ a |>\n<| a |>\nI like the recursive method\
    \ but I am not sure it's the best way to sort a vector.\nHere is a non-recursive\
    \ version. As mentioned in other answers, the vectors being sorted do not need\
    \ to be the same length.\n<code>", "    if iseven(sum([array[1], array[end]]))\n\
    \        array.sort!()\n        sort!(array)\n    else\n        array.sort!(big.downto)\n\
    \    end\n    return array\nend", "    sum = array.sum\n    i = length(array)\n\
    \    if sum == 0 || sum == Int(sum)\n        return array\n    if sum mod 2 ==\
    \ 0\n        array.sort()\n        return array\n    else \n        array.sort(reverse\
    \ = true)\n        return array\n    end\nend", "    if length(array) == 0 \n\
    \        return array\n    end\n    # Sort the array in ascending order if the\
    \ sum of the first and last element is odd,\n    # or sort it in descending order\
    \ if the sum of the first and last element is even.\n    if sum(array[end])%2\
    \ == 0\n        push!(array,pop!(array))\n        push!(array,pop!(array))\n \
    \   else\n        push!(array,pop!(array))\n        push!(array,pop!(array))\n\
    \        push!(array,pop!(array))\n    end\n    return array\nend\n</cell>\n<code\
    \ language=julia-0.5>", "    if sum(array) % 2 == 1\n        return sort_array(reverse(array))\n\
    \    end\n    return array\nend", "    arr=sort(array)\n    arr=arr[(arr.first+1)..(arr.last)]\n\
    \    if arr[1]<arr[0]\n        arr.reverse\n    end\n    arr\nend", "    sum::Int64\
    \ = 0\n    for i in 0..(length(array)-1)\n        sum += array[i]\n    end", " \
    \   if length(array)==0 then return []\n    arr = Array{Int64,1}(undef,length(array))\n\
    \    push!(arr,0)\n    sums = sum(array)\n    if sums mod 2 != 0 \n        push!(arr,sums)\n\
    \    else\n        push!(arr,sums+1)\n    end\n    \n    i=0\n    while i<length(array)\
    \ do \n        j = i\n        while j<length(array) and sum(arr[j:end])==sum(arr[i+1:end])\
    \ do\n            push!(arr,arr[j])\n            push!(arr,arr[i+1])\n       \
    \     i+=1\n            i+=1\n            j+=1\n        end\n    end\n    return\
    \ arr\nend\n</cell>\n<code language=julia-0.6>\nsort_array([])\n</cell>\n<text>\n\
    Challenge Problem #3 : Binary Search Algorithm for Finding K Element in Sorted\
    \ Array", "    if length(array)==0 \n        array \n    else \n        pivot\
    \ = partition(array, 1) \n        sort_array(array[1:pivot-1]) .+ array[pivot+1:end]\
    \ \n    end\nend\n\"\"\"\nGiven a vector of non-negative integers, return a cojl\
    \ of the given vector after sorting,\n    you will sort the given vector in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.",
  "    if length(array) == 0 \n        return array\n    end\n    sorted = sort_array_recursive_sort(array)\n\
    \    if sum((sorted[1], sorted[end])) % 2 != 0\n        sorted[end, end] = sorted[1,\
    \ end]\n        sorted[1, end] = sorted[1, 1]\n    end\n    return sorted\nend",
  "    sorted_array = []\n    sum = 0\n    for el in array\n        sum += el\n  \
    \      if sum % 2 != 0\n            sorted_array[end] = el\n            end -=\
    \ 1\n        else\n            sorted_array[end] = el\n            end += 1\n\
    \        end\n    end\n    return sorted_array\nend\n</code>\n<|/ a |>\n<| a dscore=0\
    \ tags=arrays,sorting,julia |>\nJust to clarify my previous comment as I was struggling\
    \ to understand it: \nThe algorithm to sort a vector of ints is very similar to\
    \ the one to sort a vector of floats, which is just an extension of the same idea.\
    \ \nThe key observation is that once you sort the vector you can find two adjacent\
    \ elements that are equal. So once you find the element you are looking for you\
    \ can do a binary search to find the position to insert it.  \nThe only difference\
    \ is that you need to find the element you are looking for in a binary search,\
    \ which can be done in linear time.\n<|/ a |>\n<| a tags=arrays,sorting,julia\
    \ |>\nI recently came up with a solution based on the idea presented in the other\
    \ answers:\n<code>", "        array = sort!(array)\n        \n        if length(array)\
    \ % 2 == 0\n            array = reverse(array)\n        end\n        \n      \
    \  return array\n    end", "    odd_or_even = if sum( array[1:end-1] ) % 2 ==\
    \ 0 then Descending else Ascending\n    array.sort(odd_or_even)\nend", "    if\
    \ array == []\n        return array\n    \n    sum1 = sum(array[1:end-1])\n  \
    \  sum2 = sum(array[2:end])\n    if sum1 % 2 == 0\n        array = sort_array(array[end-1:end])\
    \ #descending\n    else\n        array = sort_array(array[1:end-1]) #ascending\n\
    \    end\n    \n    array .= sum2 + sum1 #sum of the first and last index\n  \
    \  return array\nend\n</cell>\n<code language=julia-1.5>", "    if length(array)\
    \ == 0 \n        return array \n    \n    even, odd = 0, 0 \n    for e in array\n\
    \        if e % 2 == 0 \n            even += e\n        else\n            odd\
    \ += e\n        end\n    end", "    sort_array = array\n    if sum(sort_array)\
    \ == sum(array[1 .. end-1]) % 2 \n        return sort_array[end-1:end]\n    else\n\
    \        return sort_array[end-1:-1:end]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    sort_array(vec1)\n</cell>\n<code language=julia-1.5>\nsort_array(vec2)\n</cell>\n\
    <code language=julia-1.5>\nsort_array(vec3)\n</cell>\n<code language=julia-1.5>\n\
    sort_array(vec4)\n</cell>\n<text>\n4.6 Merge two sorted arrays\nGiven two sorted\
    \ arrays, merge them into a sorted array. Merge is done by adding elements in\
    \ either of the two sorted arrays.", "    sort_array = sort(array)\n    \n   \
    \ if sum( sort_array[1], sort_array[n] ) % 2 == 0\n        sort_array.reverse\n\
    \    end\n    \n    return sort_array\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\n\
    This is another solution, with two additional functions, a check and a swap function\
    \ that returns the sorted array. \n<code>", "    if length(array) == 0 \n    \
    \    return array\n    end\n    sorted = sortperm(array)\n    evensum = sum(sorted[1:end-1])\
    \ \n    oddsum = sum(sorted[1:end]) # sum( first index value, last index value)\n\
    \    if evensum % 2 != 0 \n        return sorted\n    elseif oddsum % 2 == 0 \n\
    \        return reverse!(sorted)\n    else \n        return sorted\n    end\n\
    end", "    array = sort!(array)\nend", "    if length(array) == 0 \n        return\
    \ array\n    \n    sum = 0\n    for i in array\n        sum=sum+i\n    end\n \
    \   \n    if sum % 2 != 0 \n        return sort_array(reverse(array))\n    else\
    \ \n        return array\nend\n</cell>\n<code language=julia-1.6>", "    if sum(\
    \ array[1:end-1] ) % 2 == 1\n        sort_array(reverse(array))\n    else\n  \
    \      sort_array(array)\n    end\nend", "    if length(array) == 0 \n       \
    \ return array \n    else \n        return sort_array(sort(array)) \n    end\n\
    end\n\"\"\"\n    Given a vector of non-negative integers, return a cojl of the\
    \ given vector after sorting,\n    you will sort the given vector in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.",
  "    if length(array) == 0 \n        return array\n    else\n        sum_num = sum(array[1:end-1])\
    \ \n        if sum_num % 2 != 0 \n            array[1:end-1] = array[1:end-1].sort\n\
    \        else \n            array[1:end-1] = array[1:end-1].sort\n           \
    \ array[1:end-1].reverse\n            end\n        \n        return array\n  \
    \  end\nend\n</cell>\n<text>\nNow the function sort_array is ready to use, let's\
    \ test it."]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
