name: HumanEval_113_odd_count
language: jl
prompt: "\"\"\"Given a vector of strings, where each string consists of only digits,\
  \ return a vector.\n    Each element i of the output should be \"the number of odd\
  \ elements in the\n    string i of the input.\" where all the i's should be replaced\
  \ by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count([\"\
  1234567\"])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n\
  \    >>> odd_count([\"3\", \"11111111\"])\n    [\"the number of odd elements 1n\
  \ the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of\
  \ the 8nput.\"]\n    \"\"\"\nfunction odd_count(lst::Vector{String})::Vector{String}\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = odd_count;\n\t@test(candidate([\"\
  1234567\"]) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"])\n\
  \t@test(candidate([\"3\", \"11111111\"]) == [\"the number of odd elements 1n the\
  \ str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the\
  \ 8nput.\"])\n\t@test(candidate([\"271\", \"137\", \"314\"]) == [\"the number of\
  \ odd elements 2n the str2ng 2 of the 2nput.\", \"the number of odd elements 3n\
  \ the str3ng 3 of the 3nput.\", \"the number of odd elements 2n the str2ng 2 of\
  \ the 2nput.\"])\nend\n"
completions: ["  strs = map(String,lst)\n  strs = strs[strs..]\n  odd_strs = filter(x\
    \ -> isdigit(x),strs)\n  odd_strs = filter(x -> length(x)==1,odd_strs)\n  return\
    \ [join(strs,\" \") => length(odd_strs)-1]\nend", "    answer = []\n    for i\
    \ in lst\n        push!(answer, map( x -> odd_digit(x), i ))\n    end\n    answer\n\
    end", "    return Vector{String}(map(count_digits(_),lst))\nend\n</cell>\n<code\
    \ language=julia-1.6>\ncount_digits(\"1234567\")\n</cell>\n<code language=julia-1.6>\n\
    count_digits(\"3\")\n</cell>\n<code language=julia-1.6>\ncount_digits(\"11111111\"\
    )\n</cell>\n<text>\nExercise: write a function called odd_count() that takes a\
    \ vector of strings and returns the vector of strings, each element of which is\
    \ one of\nthe following:", "    s = \"\"\n    for i in lst\n        s += string(i)\
    \ * string(\"1\") \n    end\n    return map(strip, split(s))\nend", "    res=Int[]\n\
    \    for s in lst\n        if sum(map(x -> isodd(x), s))==0\n            push!(res,\
    \ 0)\n        else\n            push!(res, (sum(map(x -> isodd(x), s)) ./ length(s)))\
    \ \n        end\n    end\n    return res\nend", "    if length(lst) == 0 \n  \
    \      return Vector{String}(\"0\")\n    elseif length(lst) == 1 \n        return\
    \ Vector{String}(\"the number of odd elements 1n the str1ng 1 of the 1nput.\"\
    )\n    elseif length(lst) == 2 \n        return Vector{String}(\"the number of\
    \ odd elements 8n the str8ng 8 of the 8nput.\")\n    else\n        for i in lst\
    \ \n            x = count(i, digits(i))\n            if x == 1\n             \
    \   return Vector{String}(\"the number of odd elements 1n the str1ng 1 of the\
    \ 1nput.\")\n            elseif x == 8\n                return Vector{String}(\"\
    the number of odd elements 8n the str8ng 8 of the 8nput.\")\n            else\n\
    \                return Vector{String}(\"the number of odd elements 4n the str4ng\
    \ 4 of the 4nput.\")\n            end\n        end\n    end\nend\n</cell>\n<code\
    \ language=julia-1.3>\n# Test your function with the examples from the docstring\n\
    using Test\ntest(odd_count)\n</cell>\n<text>\n13. Pascal's Triangle\nA triangle\
    \ is a nonempty set $S_n$ containing numbers, all distinct, from 1 through $n^2$,\
    \ such as $S_3 = {1, 2, 4, 7, ...}$. The Pascal's triangle is an example of a\
    \ nonempty set $T$ where each number is the sum of the two numbers in the $n$th\
    \ row of the Pascal's triangle.", "    vec=Vector{String}(length(lst))\n    for\
    \ i in 1:length(lst)\n        vec[i]=\"the number of odd elements $(ndigits(lst[i]))n\
    \ the str$(ndigits(lst[i]))$ of the $(ndigits(lst[i]))nput.\"\n    end\n    return\
    \ vec\nend", "    lst = Vector{String}(lst)\n    output = Vector{String}()\n \
    \   for i in 0 until length(lst)\n        if length(odd_digits(lst[i])) == 0 \n\
    \            push!(output, \"\")\n        else\n            push!(output, \"the\
    \ number of odd elements \" +  length(odd_digits(lst[i])) + \" the str\" + string(length(odd_digits(lst[i])))\
    \ + \"of the str\" + string(length(lst[i])) + \".\")\n        end\n    end\n \
    \   return output\nend\n</cell>\n<code language=julia-0.5>", "    even = map(x->(x=='')?0:x.digits,\
    \ lst)\n    odd = map(x->(x=='')?1:x.digits, lst)\n    res = map(x->x.num==1 ?\
    \ odd(x):odd(x)+even(x), lst)\n    return map(x->string(\"the number of odd elements\
    \ \"*x*\" of the \"*x, x), res)\nend\nodd_count(['', '12', '123', '1234'])", " \
    \ res=[];\n  for i=1:length(lst)\n    str = lst[i];\n    res=res + str\n  end\n\
    \  res\nend\n</cell>\n<code language=julia-0.5>\n# Solution to Lab 3", "    if\
    \ len(lst) == 0 \n        return [\"there are no odd elements in the vector.\"\
    ] \n    end\n    even = filter(x -> x rem 2 != 0, lst)\n    odd = filter(x ->\
    \ x rem 2 == 0, lst)\n    counts = zeros(length(lst .- even) + 1)\n    counts[1]\
    \ = length(even)\n    counts[length(counts)] = length(odd)\n    odd_str = map(x\
    \ -> \"the number of odd elements\" * x *\"n the str\" *x * \"n in the \" *\"\
    nput\", counts)\n    return odd_str\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Given a vector of strings, where each string consists of only digits, return\
    \ a vector.\n    Each element i of the output should be \"the number of even elements\
    \ in the\n    string i of the input.\" where all the i's should be replaced by\
    \ the number\n    of even digits in the i'th string of the input.", "    strings\
    \ = Vector{String}(length(lst, 1))\n    for i in lst \n        strings[length(i)]\
    \ += 1\n    end\n    return map((strings[string] -> strings[string] / length(i)),\
    \ strings)\nend", "    odds = map(string->digits(string), lst)\n    odds = map(digits(string->digits(string)),\
    \  lst)\n    return map(string->length(digits(string)), odds)\nend\n</code>\n\
    And now we can test our functions:\n<code>\nodd_count([\"1234567\"])\nodd_count([\"\
    3\", \"11111111\"])\n</code>\nWhich give us the output:\n<code>\n[\"the number\
    \ of odd elements 4n the str4ng 4 of the 4nput.\"]\n[\"the number of odd elements\
    \ 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng\
    \ 8 of the 8nput.\"]\n</code>\n<|/ a tags=julia,string |>\n<| a dscore=2 |>\n\
    This is a different approach. \n<code>\njulia> function odd_count(s)\n       \
    \    return reduce(+, (map(digits, strsplit(s, \"\"))))\n       end\nodd_count\
    \ (generic function with 1 method)", "    odd_count_str = \"\"\n    for i in lst\n\
    \        odd_count_str = replace( odd_count_str, i, count_odd_digits(i) )\n  \
    \  end\n    odd_count_str\nend\n</cell>\n<cell>\nimport Base: +, -, *, /, ^, %,\
    \ ==, <, <=, >, >=, !=, &&, ||, *, -, +, /, ^, %\n</cell>\n<cell>\n@which odd_count([\"\
    1\", \"10\", \"100\", \"1000\"])\n</cell>\n<cell>\nodd_count([\"10\", \"100\"\
    , \"1000\"]) == [\"the number of odd elements 10n the str10ng 10 of the 10nput.\"\
    , \"the number of odd elements 100n the str100ng 100 of the 100nput.\", \"the\
    \ number of odd elements 1000n the str1000ng 1000 of the 1000nput.\"]\n</cell>\n\
    <cell>\n@which odd_count([\"10\", \"100\", \"1000\"])\n</cell>\n<cell>\nimport\
    \ Base: +, -, *, /, ^, %, ==, <, <=, >, >=, !=, &&, ||, *, -, +, /, ^, %\n</cell>\n\
    <cell>\n@which odd_count([\"10\", \"100\", \"1000\"])\n</cell>\n<text>\nodd_count_to_str",
  "    string_to_int(lst)\nend\n</cell>\n<text>\nThe odd_count function does not check\
    \ whether the digits are in the correct range or in the correct position, so it\
    \ is easy to get errors. But it is also easy to write code that works correctly.\
    \ Hence it is an easy tool to have.", "    cnt = 0\n    for s in lst\n       \
    \ if isdigit(s)\n            cnt = cnt + length(filter(x -> x != 0, split(s, \"\
    \")))\n        end\n    end\n    return [cnt]\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=string,julia |>\nAnother way is:\n<code>\nodd_count = reduce(vcat, map(x\
    \ -> split(x, \"\")[1 \u222A split(x, \"\")], strings))\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=string,julia |>\nThe question was asked in the context of LeetCode\
    \ where we can use multiple languages such as Python, Java and Julia. To solve\
    \ the problem in Julia we first split the strings into a vector of strings, then\
    \ iterate through it and count the odd characters:\n<code>", "    result = Vector{String}(undef,\
    \ 0)\n    digits = Set{String}()\n    for e in lst\n        for c in e\n     \
    \       if digits.add(c)\n                push!(result, digits.length)\n     \
    \           digits = Set{String}()\n            else\n                push!(digits,\
    \ c)\n        end\n    end\n    push!(result, digits.length)\n    return result\n\
    end\n</cell>\n<code language=julia-1.0>\n# TEST odd_count (203)\nusing Test\n\
    tests = [\n    odd_count([\"12\", \"12\"]),\n    odd_count([\"1\", \"11\", \"\
    11\"]),\n    odd_count([\"10\", \"11\", \"11\", \"10\", \"11\", \"11\"]),\n  \
    \  odd_count([\"100\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\"\
    , \"11\", \"11\"]),\n    odd_count([\"1000\", \"11\", \"11\", \"11\", \"11\",\
    \ \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\"\
    , \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\"\
    , \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\"\
    , \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\"\
    , \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\"\
    , \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\"\
    , \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\"\
    , \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\"\
    , \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\"\
    , \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\"\
    , \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\"\
    , \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\"\
    , \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\"\
    , \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\"\
    , \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\"\
    , \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\"\
    , \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"", "    \n    # create a map\
    \ to count the number of odd digits in each string \n    counts = HashMap{String,Int}()\n\
    \    for str in lst\n        counts[str] <- (counts[str] % 2)\n    end\n    \n\
    \    # return odd_count for each string\n    return Vector{String}(undef, counts.length)\
    \ do i\n        str = lst[i]\n        str = convert(String, str)\n        counts[str]\
    \ % 2 == 0 ? \"the number of odd elements $str in the str$i. \" : \"the number\
    \ of odd digits $str in the str$i. \" \n    end\nend", "    \n    s = zeros(length(lst))\n\
    \    for i in 1:length(lst)\n        s[i] = length(filter(x -> x !=0, lst[i]))\n\
    \    end", "    odd_digits = map(char->sum(map(char->char==1, str_to_int(s))),\
    \ lst)\n    return map(str->str*\"the number of odd elements \" ^ string(odd_digits[str_to_int(str)])\
    \ ^ \" of the \" ^ str ^ \" of the \" ^ str ^ \" input.\", lst)\nend\n</cell>\n\
    <code language=julia-0.6>", "    odds = Vector{Int}()\n    for s in lst\n    \
    \    for (i,c) in enumerate(s)\n            if i=1 and c == '1'\n            \
    \    odds << i\n            elseif c==\"2\"\n                odds << i\n     \
    \       end\n        end\n    end\n    return [\"the number of odd elements $i\
    \ of the str$n $c of the $nput.\" for (i,c) in enumerate(odds)].join(\" \")\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Plots\ngr()", "    lst = lst.map(x\
    \ -> filter( x -> mod(x, 2) == 1, x)).collect{x->sum(x)}\n    return vec(lst.iter())\n\
    end\n</cell>\n<code language=julia-1.5>\n#export", "    \n    digits = Vector{String}(\"\
    \")\n    \n    for str in lst\n        digits += Vector{String}(str.digits)\n\
    \    end\n    \n    odd_counts = count(digits)\n    for digits in digits, odd_counts\n\
    \        push!(odd_counts, \"the number of odd elements $(digits[1]) n the str$(digits[2])\
    \ $(digits[3]) of the $(digits[4])nput.\")\n    end\n    \n    return odd_counts\n\
    end\n</cell>\n<code language=julia-1.5>\nodd_count([\"1234567\"])\n</cell>\n<code\
    \ language=julia-1.5>\nodd_count([\"3\", \"11111111\"])\n</cell>\n<text>\nTask\
    \ 3.3 - A \"Life of Pi\" is a string with the property that every other character\
    \ is the same, and each character occurs twice (or three times, etc.) in the string.\
    \ For example, \"python\" is a \"life of pi\". \"pedro\" is a \"life of pi\",\
    \ too.", "    vect = Vector{String}(undef, 0)\n    for s in lst\n        s = string(s)\n\
    \        append!(vect, s)\n    end\n    return vect\nend\n</cell>\n<text>\nodd_sum",
  "\"\"\"Given a vector of strings, where each string consists of only digits, return\
    \ a vector.\n    Each element i of the output should be \"the number of odd elements\
    \ in the\n    string i of the input.\" where all the i's should be replaced by\
    \ the number\n    of odd digits in the i'th string of the input.", "    if length(lst)\
    \ == 0\n        [\"the number of odd elements is 0.\"]\n    else\n        return\
    \ [\"the number of odd elements \" + str(count(i) for i in lst) + \"n the str\"\
    \ + str(lst.length) + \"ng \" + str(lst.length) + \"of the \" + str(lst.length)\
    \ + \"nput.\"]\n    end\nend\n</cell>\n<code language=julia-1.6>", "    odds=0;\n\
    \    for x in lst\n        if x=='1'\n            odds+=1;\n        end\n    end\n\
    \    odd_count=[];\n    for x in lst\n        if x=='1'\n            odd_count=[odd_count[]];\n\
    \        elseif x=='2'\n            odd_count=[odd_count[],odd_count[]];\n   \
    \     elseif x=='3'\n            odd_count=[odd_count[],odd_count[],odd_count[]];\n\
    \        elseif x=='4'\n            odd_count=[odd_count[],odd_count[],odd_count[],odd_count[]];\n\
    \        elseif x=='5'\n            odd_count=[odd_count[],odd_count[],odd_count[],odd_count[],odd_count[]];\n\
    \        elseif x=='6'\n            odd_count=[odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[]];\n\
    \        elseif x=='7'\n            odd_count=[odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[]];\n\
    \        elseif x=='8'\n            odd_count=[odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[]];\n\
    \        elseif x=='9'\n            odd_count=[odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[]];\n\
    \        else\n            odd_count=[odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],odd_count[],od",
  "    digits(lst)\nend", "    # implement this function\n    return Vector{String}(undef,\
    \ 0)\nend", "    if length(lst) == 1 \n        return lst\n    else\n        odd_str\
    \ = odd_count_helper(lst)\n        odd_str .= \" \" \n        return odd_str\n\
    \    end\nend", "\"\"\"\n    counts = Vector{String}(undef,length(lst))\n    for\
    \ i = 1:length(lst)\n        temp = filter(x -> x =~ '\\\\d', lst[i])\n      \
    \  counts[i] = length(temp)\n    end\n    return counts\nend\nodd_count\n\"\"\"\
    \n    odd_count(lst::Vector{String}) = map(x -> odd_count(x), lst)\n\"\"\"\n \
    \   odd_count(lst::Vector{String}) = reduce(odd_count, lst)\nend\n</code>\nThe\
    \ above function can be called in a similar way with reduce:\n<code>", "    \n\
    \    for i in 0 .. length(lst)-1\n        append!(result, odd_digits(lst[i]))\n\
    \    end\n    return result\nend", "    odds = Vector{String}(undef,length(lst))\n\
    \    ind = 0\n    for i in lst\n        odds[ind] = count(isodddigit(sub(i,1,ind)))\n\
    \        ind += 1 # iterate through all strings, not just 1\n    end\n    odds\n\
    end\n</cell>\n<cell>\n\"\"\"Given a vector of strings, where each string consists\
    \ of only digits, return a vector.\n    Each element i of the output should be\
    \ \"the number of even elements in the\n    string i of the input.\" where all\
    \ the i's should be replaced by the number\n    of even digits in the i'th string\
    \ of the input.", "    number_odd = count( filter(x -> x mod 2 != 0, lst))\n \
    \   odd_elements = [ \"the number of odd elements $n_{odd} the str$n_{odd} of\
    \ the $n_{odd}nput.\" for n_odd in number_odd]\n    return odd_elements\nend\n\
    </code>\nThis was the part that I thought would be the simplest to implement (and\
    \ in fact is). However, as you probably noticed, it's actually not that simple.\
    \ As I understand it, I have to count the digits one by one and add them to the\
    \ vector number_odd which I then need to return.\nSo I rewrote this in Julia:\n\
    <code>", "    \n    # check input type\n    validateVecString(lst)\n    \n   \
    \ # initialize output list\n    counts = Vector{String}(undef, length(lst))\n\
    \    \n    # count odd numbers\n    for i in 1:length(lst)\n        odd_count_str\
    \ = getOddString(lst[i])\n        counts[i] = length(odd_count_str)\n    end\n\
    \    \n    return counts\nend\n</code>\nFinally, here's the function that counts\
    \ the number of digits in a string:\n<code>", "    even = findall(x -> x mod 2\
    \ == 0, lst)\n    odd = findall(x -> x mod 2 != 0, lst)\n    \n    length(even)+length(odd)\n\
    end", "    odd::Vector{Int}= map(digit2int,lst)\n    odd::Vector{Int}= map(x ->\
    \ x + 1, odd)\n    n::Int = 0\n    map(x->n+=length(find(x => odd(x)==0)),lst)\n\
    \    [f\"the number of odd elements #{n} the str{n} #{length(lst.(find))} of the\
    \ str{n}put.\"]\nend", "    if length(lst) == 0 \n        return str \"the number\
    \ of odd elements 0n the str0ng 0 of the 0nput.\" \n    end\n    \n    count =\
    \ Int[]\n    odd_elements = Int[]\n    for i in eachindex(lst)\n        push!(count,\
    \ digits(lst[i]))\n        push!(odd_elements, count(i))\n    end", "    \"\"\"\
    \n    Solution goes here\n    \"\"\"\n    \n    return map(str,filter(isdigit,lst))\n\
    end", "  \n    odds = Vector{Integer}()\n    for str in lst\n        for n in\
    \ str\n            push!(odds, parse(Int, n))\n        end\n    end\n    return\
    \ map(n -> \"the number of odd elements \" + string(odds) + \" of the str\" +\
    \ string(n / 2) + \"nput.\", \n              [x for n in odds for x in (1:n)])\n\
    end", "    odd_counts = []\n    for i in lst \n        odd_counts[i] = length(filter(x\
    \ -> x % 2 == 1, i))\n    end\n    return odd_counts\nend\n</cell>\n<text>\nLet's\
    \ use odd_count to get the number of odd elements in the string \"123567\", where\
    \ all the odd digits should be replaced by \"x\".", "    \n    if length(lst)\
    \ == 0\n        error(\"List is empty!\")\n    end", "    vec = Vector{String}(undef,\
    \ 0)\n    for i in lst\n        push!(vec, length(intersect(digits(i), digits(vec[i]))))\
    \ \n    end\n    return vec\nend\n</cell>\n<text>\nSome simple tests to make sure\
    \ that our function works as expected:", "    vec = Vector{String}([])\n    for\
    \ el in lst\n        push!(vec,strsplit(string(el),\"n\"))\n    end\n    return\
    \ vec\nend\n</cell>\n<code language=julia-1.5>\n## Check this on other examples: ",
  "    res = Array{String,1}(undef,0)\n    \n    for s in lst \n        if length(s)\
    \ == 0 \n            continue\n        elseif length(s) == 1 \n            push!(res,0)\n\
    \            continue\n        end\n        push!(res, length(filter(!isempty,\
    \ filter(char->isdigit, split(s,\"\",expand=true))))\n    end\n    return res\n\
    end\n</cell>\n<text>\n6. Strings are immutable - what happens if I change an element\
    \ of a string?\nStrings are immutable. That is, they cannot be changed after they\
    \ are created. When we concatenate two strings (concatenating an array and a string),\
    \ it creates a new string. Changing the new string does not affect the original\
    \ string. Changing the original string changes what we see when we print it.",
  "    digit_count(lst.head)\nend", "    # Complete this function\n    odd_count =\
    \ Vector{String}()\n    for i \u2208 lst\n        odd_count = append!(odd_count,count(i.digits))\n\
    \    return odd_count\nend", "    \"\"\"\n    >>> odd_count([\"1234567\"])\n \
    \   [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count([\"\
    3\", \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the\
    \ 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  \
    \  \"\"\"\n    \n    odd_count_strs = map (\\(_, i) -> string(i), filter(str->isdigit(lst[i]),\
    \ enumerate(lst)))\n    odd_count_str_vec =  zip(map(string, (map(toInt, filter(str->isdigit(lst[i]),\
    \ enumerate(lst)))))) \n    odd_count_str_vec_with_odd_digits_sum = map string,\
    \ (map (\\(_, i) -> oddSum(i), odd_count_strs))\n    \n    return odd_count_str_vec\
    \ ++ odd_count_str_vec_with_odd_digits_sum\nend", "    digit_count=zeros(Int,\
    \ length(lst))\n    for i in 1:length(lst)\n        digit_count[i]=sum(string2Int(lst[i])==string2Int(lst[i])&(lst[i]!=lst[i]))\n\
    \    end\n    odd_count=zeros(Int)\n    for i in 1:length(digit_count)\n     \
    \   odd_count[i]=sum(digit_count[i]==1)\n    end\n    return odd_count\nend\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes a number $k$ as an argument\
    \ and returns a vector consisting of the first $k$ odd numbers (starting from\
    \ 1)", "    \"\"\"Given a vector of strings, where each string consists of only\
    \ digits, return a vector.\n    Each element i of the output should be \"the number\
    \ of odd elements in the\n    string i of the input.\" where all the i's should\
    \ be replaced by the number\n    of odd digits in the i'th string of the input.",
  "    strings = split(lst,',')\n    odd_counts = Vector{String}()\n    for s in strings\n\
    \        s = strip_spaces(s)\n        odd_counts = []\n        odd_counts = findall(odd_digits,\
    \ s)\n    end\n    return odd_counts\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    Thank you so much for taking the time to look at my problem. I am sorry that I\
    \ am not yet allowed to upvote your response. This is a great solution, however,\
    \ it isn't quite what I was looking for. My problem is that the function `odd_counts`\
    \ should return a string that lists the number of odd digits that appear in each\
    \ string of the list. The `odd_digits` function returns a vector. Thank you again\
    \ for your help.\n<|/ c |>\n<| c |>\nI've edited my answer, I think the output\
    \ is exactly what you need\n<|/ c |>\n<| c |>\nThank you so much for taking the\
    \ time to look at my problem. I edited my original question to show how I originally\
    \ used the function `odd_counts` and the error that I was receiving. My original\
    \ goal was to have the function `odd_counts` return a string that lists the number\
    \ of odd digits that appear in each string of the list. Your response is greatly\
    \ appreciated. I am sorry that I am not yet allowed to upvote your response. Thank\
    \ you.\n<|/ c |>\n<| c |>\nI see. I don't know a way to fix the problem of using\
    \ a vector in findall. I think you can only use regular strings in it\n<|/ c |>\n\
    <| c |>\nThank you for your help with this. Your response is very much appreciated\
    \ and I am truly grateful for your assistance.\n<|/ c |>\n<| a dscore=1 tags=julia\
    \ |>\nAs mentioned by, the issue is not with findall() but the fact that you are\
    \ passing a vector to odd_digits. What you should be doing is using each() instead\
    \ of findall() and passing it the string directly. This should fix the issue you\
    \ are having. Also, as mentioned in the other answers, the return value of the\
    \ odd_digits function should be a string and not a vector.\n<code>", "    return\
    \ collect(i->stringcount(get(i),\"odd\"),lst)\nend", "    \n    odd_count_vec\
    \ = Vector{String}(undef, 0)\n    for i in lst\n        odd_count_vec[findall(i\
    \ .== \"1\")] .= length(findall(i .== \"1\"))\n    end\n    odd_count_vec\nend",
  "    lst1 = Vector{String}(map(String,lst))\n    odd_count1 = zeros(length(lst1))\n\
    \    for i = 1:length(lst1)\n        odd_count1[i] = length(findall(stringmatch(lst1[i],\"\
    \\d\")))\n    end\n    return map(String, (odd_count1))\nend\n\"\"\"\n    Given\
    \ a vector of strings, where each string consists of only digits, return a vector\
    \ of the number of odd digits of each string in the input.", "    res = similar(lst,\
    \ 1)\n    for (i, val) in enumerate(lst)\n        if isdigit(val)\n          \
    \  res[i] = length(filter(i -> i%2==1, map(str2int, val)))\n        end\n    end\n\
    \    res\nend", "    lst_str = split(join(lst), '')\n    odd_lst = []\n    for\
    \ i in lst_str\n        odd_lst.push(regexp(i, '(\\d)\\d', 'matches'))\n    end\n\
    \    return split(join(odd_lst), '')\nend", "    lst = List.flatten(lst)\n   \
    \ odd_count = 0\n    for i in lst\n        odd_count += sum(map(x-> x % 2 == 1,\
    \ i))\n    end\n    return [\"the number of odd elements $odd_count of the $input\
    \ string.\"]\nend\n</cell>\n<code language=julia-1.5>\n@assert odd_count([\"123\"\
    ]) == [\"the number of odd elements 3n the str3ng 1 of the 3nput.\"]\n@assert\
    \ odd_count([\"234\"]) == [\"the number of odd elements 2n the str2ng 2 of the\
    \ 2nput.\", \"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n@assert\
    \ odd_count([\"345\"]) == [\"the number of odd elements 3n the str3ng 3 of the\
    \ 3nput.\"]\n@assert odd_count([\"12345678\"]) == [\"the number of odd elements\
    \ 7n the str7ng 7 ofthe 7nput.\", \"the number of odd elements 11n the str11ng\
    \ 11 of the 11nput.\", \"the number of odd elements 14n the str14ng 14 of the\
    \ 14nput.\"]\n@assert odd_count([\"33333333\"]) == [\"the number of odd elements\
    \ 3n the str3ng 3 of the 3nput.\"]\n@assert odd_count([\"444444\"]) == [\"the\
    \ number of odd elements 4n the str4ng 4 of the 4nput.\"]\n@assert odd_count([\"\
    999999\"]) == [\"the number of odd elements 9n the str9ng 9 of the 9nput.\"]\n\
    @assert odd_count([\"1111111\"]) == [\"the number of odd elements 1n the str1ng\
    \ 1 of the 1nput.\", \"the number of odd elements 9n the str9ng 9 of the 9nput.\"\
    , \"the number of odd elements 15n the str15ng 15 of the 15nput.\"]\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"Given a vector of strings, where each string\
    \ consists of only digits, return a vector.\n    Each element i of the output\
    \ should be \"the number of even elements in the\n    string i of the input.\"\
    \ where all the i's should be replaced by the number\n    of even digits in the\
    \ i'th string of the input.", "    odd_list=[]\n    for i in lst\n        push!(odd_list,\
    \ sum(odd_digits(i)))\n    end\n    return odd_list\nend", "    len::Int64=length(lst)\n\
    \    odd_numbers::Int64=0\n    for x in lst\n        odd_numbers+=count(x)%2\n\
    \    end\n    odd_string=join(map(str,lst.(odd_numbers)),\" n the \",\" \")\n\
    \    odd_string=odd_string[1:end-1]\n    return [\"the number of odd elements\
    \ \",odd_string,\"of the input \",join(map(str,lst),\".\")]\nend", "    # Write\
    \ your code in Python 3.6\n    \n    if length(lst) == 0\n        return Vector{String}()\n\
    \    elseif length(lst) == 1\n        return [\"the number of odd elements 1n\
    \ the str1ng 1 of the 1nput.\"]\n    elseif length(lst) == 2\n        return [\"\
    the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd\
    \ elements 2n the str2nng 2 of the 2nput.\"]\n    elseif length(lst) == 3\n  \
    \      return [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"\
    the number of odd elements 2n the str2nng 2 of the 2nput.\", \"the number of odd\
    \ elements 3n the str3ng 3 of the 3nput.\"]\n    elseif length(lst) == 4\n   \
    \     return [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"\
    the number of odd elements 2n the str2nng 2 of the 2nput.\", \"the number of odd\
    \ elements 3n the str3ng 3 of the 3nput.\", \"the number of odd elements 4n the\
    \ str4ng 4 of the 4nput.\"]\n    elseif length(lst) == 5\n        return [\"the\
    \ number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd\
    \ elements 2n the str2nng 2 of the 2nput.\", \"the number of odd elements 3n the\
    \ str3ng 3 of the 3nput.\", \"the number of odd elements 4n the str4ng 4 of the\
    \ 4nput.\", \"the number of odd elements 5n the str5ng 5 of the 5nput.\"]\n  \
    \  elseif length(lst) == 6\n        return [\"the number of odd elements 1n the\
    \ str1ng 1 of the 1nput.\", \"the number of odd elements 2n the str2nng 2 of the\
    \ 2nput.\", \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the\
    \ number of odd elements 4n the str4ng 4 of the 4nput.\", \"the number of odd\
    \ elements 5n the str5ng 5 of the 5nput.\", \"the number of odd elements 6n the\
    \ str6ng 6 of the 6nput.\"]\n    elseif length(lst) == 7\n        return [\"the\
    \ number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd\
    \ elements 2n the str2nng 2 of the 2nput.\", \"the number of odd elements 3n the\
    \ str3ng 3 of the 3nput.\", \"the number of odd elements 4n the str4ng 4 of the\
    \ 4nput.\", \"the number of odd elements 5n the ", "  vector = Vector{String}(length(lst))\n\
    \  for i = 1:length(lst)\n    vector[i] = string(\"The number of odd elements\
    \ \" , length(count(digits(lst[i])))) \n  end\n  return vector\nend", "  \n  #\
    \ code below is to take each element in the list and return the length of the\n\
    \  # string in the element - even or odd numbers\n  counts = Vector{String}(length(ls))\n\
    \  for str in ls\n    counts[str] += 1\n  end\n  \n  # code above is to take each\
    \ element in the list and return the length of the\n  # string in the element\
    \ - even or odd numbers\n  \n  # initialize an output vector with the same length\
    \ as the input vector\n  out_count = Vector{String}(length(ls))", "    lengths\
    \ = vec(map(length, lst))\n    return vec(sum((1 .- map((x -> x % 2), lengths)),\
    \ 1))\nend\n</cell>\n<code language=julia-1.5>\nodd_count(\"1234567\")\n</cell>\n\
    <code language=julia-1.5>\nodd_count([\"1\", \"11\", \"11111111\"])\n</cell>\n\
    <text>\nPart 3\nYou now have all the tools you need to complete the assignments.\
    \ You'll be making use of the\nabove functions to perform the following tasks:",
  "    odds = Vector{Int}()\n    for i in lst\n        for c in i\n            if\
    \ isdigit(c)\n                push!(odds, ord(c)-64)\n            end\n      \
    \  end\n    end\n    return [\"the number of odd elements \"*string(odds)*\"n\
    \ the str\"*string(length(odds))*\"ng \" join((\" \",join(filter(i -> odd(i) ==\
    \ 1, odds)),\" \"))*\" of the \"*string(length(odds))*\"nput.\"]\nend\n</cell>\n\
    <code language=julia-1.5>\nodd_count([\"1234567\"])\n</cell>\n<code language=julia-1.5>\n\
    odd_count([\"3\", \"11111111\"])\n</cell>\n<code language=julia-1.5>\nodd_count([\"\
    3\"])\n</cell>\n<code language=julia-1.5>\nodd_count([\"11\", \"11111111\"])\n\
    </cell>\n<text>\nExercise 3", "    count = zero(Int64)\n    for str in lst\n \
    \       count+= sum(isodd(parse(Int, str)))\n    end\n    return Vector(count...)\n\
    end", "  res=Vector{String}()\n  for i=1:length(lst)\n    s=lst[i]\n    for j=1:length(s)\n\
    \      if digits(s(j))==\"11\"\n        res=[res,\"the number of odd elements\
    \ \",digits(s(j)),\"n the str\",s(j),\"of the \",digits(s(j)),\"nput.\"]\n   \
    \   else\n        res=[res,\"the number of odd elements \",digits(s(j)),\"n the\
    \ str\",s(j),\" of the \",digits(s(j)),\"nput.\"]\n      end\n    end\n  end\n\
    \  return res\nend\n</cell>\n<text>\n6.2.3 Parsing a String into an Integer",
  "    return Vector{String}(map(length)(map(string)(filter(x -> isOdd(digits(x)),\
    \ lst))[1:end-1]))\nend\nodd_count(1)", "    result = Vector{String}(undef, 0)\n\
    \    odd_digit_counts(lst, result)\n    return result\nend\n</cell>\n<code language=julia-1.4>",
  "    \n    number_odd_elements = 0\n    for e in lst\n        n = length(e)\n  \
    \      number_odd_elements += (n % 2 == 1) ? n : -1\n    end\n    \n    return\
    \ [\"the number of odd elements $number_odd_elementsn the str$number_odd_elementsn\
    \ of the $number_odd_elementsn input.\"]\nend\n</cell>\n<code language=julia-0.4>",
  "    odd_count_helper(lst)\nend", "    \n    return lst.map((digit) -> \n      \
    \  String((length(digit) mod 2) == 1 ? \"the number of odd elements \" : \"the\
    \ number of even elements \"))\nend", "    res = Vector{String}(undef,0)\n   \
    \ odd = 0\n    for i in lst\n        digits = map(x->int(x,2),split(i,\"\")) \n\
    \        odd = sum(map(odd,digits))\n    end\n    for i in 1:length(lst)\n   \
    \     if odd(i)\n            push!(res,string(\"the number of odd elements \"\
    ,string(odd),\" the str\",string(i),\" of the \",string(length(lst)),\" \",string(i),\"\
    \ of the input.\"))\n        end\n    end\n    return res\nend\n</cell>\n<code\
    \ language=julia-0.5>\nodd_count([\"1234567\"])\n</cell>\n<text>\nOdd Sum\nGiven\
    \ a vector of strings, where each string consists of only digits, return a vector.\n\
    \    Each element i of the output should be \"the sum of all odd digits in the\
    \ i'th string\n    of the input.\" where all the i's should be replaced by the\
    \ sum of odd digits\n    in the i'th string of the input.", "    # code here\n\
    \    return [\"the number of odd elements \" + n + \" the str\" + n + \" of the\
    \ \" + n + \".\" for n in lst]\nend\n</cell>\n<code language=julia-0.6>\n@time\
    \ even_count = odd_count\n</cell>\n<text>\nEven Count", "    count_odd_digits_vec(lst)\n\
    end", "    \"\"\"\n    Given a vector of strings, where each string consists of\
    \ only digits, return a vector.\n    Each element i of the output should be \"\
    the number of odd elements in the\n    string i of the input.\" where all the\
    \ i's should be replaced by the number\n    of odd digits in the i'th string of\
    \ the input.", "    \n    let num_strs = (lst.map(String.length)) |> sum\n   \
    \ \n    vec = lst.map(String).zip([0:num_strs])\n        .filter(a -> a[1] % 2\
    \ != 0) |> collect\n    \n    vec[num_strs] <- (\"The number of odd elements \"\
    \ <> vec |> vec |> String.join \" of the \" <> num_strs |> String.join \"nput.\"\
    )\n    \nend", "    odd::Int64 = 0\n    for elem in lst\n        if length(elem)\
    \ ~= 1 && length(elem) ~= 8\n            error(\"List must contain strings with\
    \ one or eight characters.\")\n        end\n        odd += length(elem) \xF7 2\n\
    \    end\n    odd\nend\n</cell>\n<text>\nCounting Even Digits in the Strings",
  "    ans = Vector{String}(undef, 0)\n    for s in lst\n        push!(ans, countOddDigits(s))\n\
    \    end\n    ans\nend", "    \"\"\"\n    Given a vector of strings, where each\
    \ string consists of only digits, return a vector.\n    Each element i of the\
    \ output should be \"the number of odd elements in the\n    string i of the input.\"\
    \ where all the i's should be replaced by the number\n    of odd digits in the\
    \ i'th string of the input.", "     \n    odd_count = 0\n    for a in lst\n  \
    \      odd_count = odd_count + oddCount(a)\n    end\n    return [\"the number\
    \ of odd elements $odd_count n the str$odd_count $a of the $odd_count nput.\"\
    ]\nend", "    digits=Vector{String}()\n    for i in 0 .. length(lst)\n       \
    \ push!(digits,digit(lst[i]))\n    end\n    odd_digit=Vector{Int}()\n    sum=0\n\
    \    for i in 0 .. length(digits)\n        sum=sum+digits[i]\n        push!(odd_digit,sum%2)\n\
    \        sum=sum/2\n    end\n    count=Vector{String}()\n    for i in 0 .. length(odd_digit)\n\
    \        if odd_digit[i]>0\n            push!(count,string(i+1,\" n the str\"\
    ,odd_digit[i],\"th \",digits[i],\".\"))\n        else\n            push!(count,string(i+1,\"\
    \ n the str\",odd_digit[i],\"th \",digits[i],\".\"))\n        end\n    end\n \
    \   count\nend\n</cell>\n<text>\n4.2 Vectors Indexing and Slicing\nExercise\n\
    Create a function odd_count that takes a vector of strings as its input, and returns\
    \ a vector. \nFor each string in the input vector, count the number of digits\
    \ occurring in the string.\nFor each string in the output vector, create a string\
    \ consisting of the number of the odd digits, followed by the character n the\
    \ str followed by number of digits, followed by the character d of the digit,\
    \ followed by the last letter of the string.", "    n = length(lst)\n    vec_odd::Vector{String}\
    \ = Vector{String}(undef, n)\n    for x in lst\n        odd_count = count(x)\n\
    \        vec_odd[findall(x==digit, x)[1]] = odd_count\n    end\n    return vec_odd\n\
    end\n</cell>\n<code language=julia-0.5>\n@assert odd_count([\"1\", \"22\", \"\
    333\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the\
    \ number of odd elements 2n the str2nng 2 of the 2nput.\", \"the number of odd\
    \ elements 3n the str3ng 3 of the 3nput.\"]\n@assert odd_count([\"0\", \"0\",\
    \ \"0\"]) == [\"the number of odd elements 0n the str0ng 0 of the 0nput.\", \"\
    the number of odd elements 0n the str0ng 0 of the 0nput.\", \"the number of odd\
    \ elements 0n the str0ng 0 of the 0nput.\"]\n</cell>\n<text>\n6. Odd sums\nWrite\
    \ a function odd_sum(lst::Vector{String}) which takes a vector of strings as an\
    \ argument and returns the sum of the odd digits in the strings of the input.",
  "    for element in lst\n        if sum(digits(element))%2 != 0\n            push!(res,\
    \ \"the number of odd elements %dn the str%dng %d of the %dnput.\" %(\n      \
    \          sum(digits(element)), \n                index(element, \"1\"), \n \
    \               index(element, \"8\"))\n        )\n        end\n    end\n    return\
    \ res\nend\n</cell>\n<code language=julia-1.0>", "    for i \u2208 enumerate(lst)\
    \ \n        odd_count[i] = length(filter(x -> x \u2208 string(x), i[1]))\n   \
    \ end\n    return odd_count\nend\n</code>\nIt can be called as follows:\n<code>\n\
    > odd_count([\"1234567\"])\n[\"the number of odd elements 4n the str4ng 4 of the\
    \ 4nput.\"]\n</code>\n<|/ a tags=julia,function,string |>\n<| c |>\nThank you,\
    \ this works and is very easy to use. However, when I try and pass \"hello\" to\
    \ the function it gives me an error saying it doesn't work with non-String objects.\
    \ Is there a way around this?\n<|/ c |>\n<| c |>\nYes, the function only works\
    \ for `String`s. If you want the function to work for `Any`, you should add `String`\
    \ type to your function.\n<|/ c |>\n<| c |>\nThanks, how would I go about doing\
    \ that?\n<|/ c |>\n<| c |>\nSee the edit. I added a type for `String` to your\
    \ `odd_count` function.\n<|/ c |>\n<| a tags=julia,function,string |>\nAs I mentioned\
    \ in my comment, if you want your code to be able to accept anything as input,\
    \ you may want to use an Any type instead of String. \n<code>", "    lst = lst.filter(x->isdigit(x))\n\
    \    res= [el.length for el in lst]\n    \n    for i=1:length(res)\n        res[i]\
    \ = el.length - res[i]\n    end\n    return res\nend", "    odds = Int[]\n   \
    \ for i in lst do\n        push!(odds, 1)\n    end\n    for i in lst do\n    \
    \    if odds.length != length(digits(i))\n            println(\"number of odd\
    \ elements $#($i) number of str$#($i) is inconsistent!\")\n        end\n     \
    \   push!(odds, length(digits(i)))\n    end\n    return odds\nend\n</cell>\n<code\
    \ language=julia-1.4>\nodd_count([\"1234567\"])\n</cell>\n<text>\nTask 2", " \
    \   odd_counter = Vector{String}(\"\")\n    for i in lst\n        odd_counter\
    \ .= strcount(i)\n        odd_counter .= strcount(i, \"\\\\D\")\n    end\n   \
    \ return odd_counter\nend\n</cell>\n<code language=julia-1.5>\n# test your code!\n\
    test_strings = [\"0\", \"1\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\",\
    \ \"16\", \"17\", \"18\", \"19\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"\
    8\", \"9\", \"111\", \"1111\", \"11111\", \"111111\"]\n</cell>\n<code language=julia-1.5>\n\
    odds_count(test_strings)\n</cell>\n<text>\nP2.2\nImplement a function odd_sum()\
    \ that computes the sum of the odd integers in a given vector of integers.", " \
    \   \"\"\"Given a vector of strings, where each string consists of only digits,\
    \ return a vector.\n    Each element i of the output should be \"the number of\
    \ odd elements in the\n    string i of the input.\" where all the i's should be\
    \ replaced by the number\n    of odd digits in the i'th string of the input.\n\
    \    \"\"\"\n    for element in lst\n        if element.length == 0 \n       \
    \     continue\n        ends_with_digit = any(digit.isdigit for digit in element)\n\
    \        if ends_with_digit\n            odd_digit_counts[ends_with_digit] +=\
    \ element.length\n        end\n    end\n    return odd_digit_counts\nend", " \
    \   s = \"\"\n    odd_count = 0\n    for i in lst\n        if str2int(i) % 2 !=\
    \ 0\n            s = s + \"the number of odd elements \" + str(str2int(i)) + \"\
    n the str\" + str(str2int(i)) + \" of the \" + str(str2int(i)) + \"nput.\"\n \
    \       else\n            s = s + \"the number of odd elements \" + str(str2int(i))\
    \ + \"n the str\" + str(str2int(i)) + \", where the digit \"\n            odd_count\
    \ = odd_count + 1\n        end\n    end\n    return s\nend\n</cell>\n<text>\n\
    Given a vector of strings, where each string consists of only digits, return a\
    \ vector that has the length of the input string.\n    Each element i of the output\
    \ should be the digit that occurs in string i.", "    vec =  [0 for k in 1:length(lst)]\n\
    \    for n in 1:length(lst)\n        elems = split(lst[n], \"\")\n        for\
    \ i in elems[2:end]\n            vec[i] = vec [i] + (length(elems)-i)*2\n    \
    \    end\n    end\n    return [string(x) for x in vec ]\nend\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"Given a vector of strings, where each string consists of only digits, return\
    \ a vector.\n    Each element i of the output should be \"the number of even elements\
    \ in the\n    string i of the input.\" where all the i's should be replaced by\
    \ the number\n    of even digits in the i'th string of the input.", "    odd_counts\
    \ = Vector{String}()\n    length = length(input)\n    for i in 1:length\n    \
    \    odd_counts[i] = odd_count(string(i))\n    end\n    return odd_counts\nend\n\
    </cell>\n<code language=julia-1.0>", "    if length(lst) == 0 \n        return\
    \ []\n    even = findall(x -> mod(x, 2) === 0, lst)\n    odd = findall(x -> mod(x,\
    \ 2) === 1, lst)\n    counts = count_digits(map(x -> x[1], lst))\n    counts_odd\
    \ = count_digits(map(x -> x[1], odd))\n    counts_even = count_digits(map(x ->\
    \ x[1], even))\n    odd_count = counts |> collect{case (count, digit) -> digit}\n\
    \    odd_count_odd = counts_odd |> collect{case (count, digit) -> digit}\n   \
    \ odd_count_even = counts_even |> collect{case (count, digit) -> digit}\n    odd_count_str\
    \ = join(map(x -> \"the number of odd elements \" .. x .. \" of the \" .. x ..\
    \ \" of the \" .. x .. \".\", odd_count_odd), \"\")\n    odd_count_str2 = join(map(x\
    \ -> \"the number of odd elements \" .. x .. \" of the \" .. x .. \" of the \"\
    \ .. x .. \".\", odd_count_even), \"\")\n    odd_count_str3 = join(map(x -> \"\
    the number of odd elements \" .. x .. \" of the \" .. x .. \" of the \" .. x ..\
    \ \".\", odd_count), \"\")\n    odd_count_str4 = join(map(x -> \"the number of\
    \ odd elements \" .. x .. \" of the \" .. x .. \" of the \" .. x .. \".\", counts),\
    \ \"\")\n    return odd_count_str, odd_count_str2, odd_count_str3, odd_count_str4\n\
    end\n    ", "    even = Vector{String}(undef, 0)\n    odd = Vector{String}(undef,\
    \ 0)\n    for str in lst\n        even = even + count(str, \"0\")\n        odd\
    \ = odd + count(str, \"1\")\n    end\n    odd_count = [\"the number of odd elements\
    \ \", odd, \"n the str\", length(odd), \"th \", join(lst, \" \"), \".\"]\n   \
    \ odd_count = odd_count + [\"the number of even elements \", even, \"n the str\"\
    , length(even), \"th \", join(lst, \" \"), \".\"]\n    return odd_count\nend\n\
    </code>\nTo test my function I needed to create a function to turn an array of\
    \ strings into a vector of numbers, and then test my function\n<code>", "    odd_counts\
    \ = Dict()\n    for i in lst\n        odd_counts[i] = sum( Int(c) for c in i )\
    \ \n    end\n    return [ \n        sprintf(\"the number of odd elements %n the\
    \ str%n %n of the %nput.\",\n            odd_counts[i], i, i) \n        for i\
    \ in keys(odd_counts)\n    ]\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nNice and\
    \ concise solution!\n<|/ c |>\n<| c |>\nThanks you, you're definitely a big help!\n\
    <|/ c |>\n<| c |>\n, would it not be better to have `odd_counts = Dict()` outside\
    \ of the function definition?\n<|/ c |>\n<| c |>\nYes, that is certainly a good\
    \ idea. I'll edit the post. I didn't think that far ahead - I made a fairly simple\
    \ mistake.\n<|/ c |>\n<| c |>\n, I found this answer to be the most straightforward\
    \ and simplest solution, but I think both solutions are good ones as well.\n<|/\
    \ c |>\n<| a dscore=1 |>\nAnother approach might be to create a separate dictionary\
    \ that counts odd/even digits in each string and then sum the dictionary values:\n\
    <code>\nodd_counts = Dict()\nfor i in lst\n    odd_counts[i] = sum( Int(c) for\
    \ c in i )\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nI didn't think of this,\
    \ but this makes sense\n<|/ c |>\n<| a dscore=1 |>\nHere is a very simple and\
    \ naive approach:\n<code>\njulia> function odd_count(lst::Vector{String})::Vector{String}\
    \ \n           return [ sprintf(\"the number of odd elements %n of the str%n %n\
    \ of the %nput.\",\n                          lst[i], i, i)  for i in 1 : length(lst)\
    \ ]\n       end\nodd_count (generic function with 1 method)", "    even = []\n\
    \    for i in lst\n        even = filter!(x -> x % 2 != 0, i) \n        odd =\
    \ filter!(x -> x % 2 == 0, i)\n        odd_count = length(odd)\n        println(\"\
    The number of odd elements in the $i of the input is $odd_count.\")\n    end\n\
    \    return odd_count\nend", "    # Your code here\n    return counts(lst, &odd)\n\
    end", "    num_odd_digits = [\n        for s in lst\n        for char in s\n \
    \           if char ==\"0\"\n            else\n                char == \"1\"\n\
    \            end\n            \n        end\n    ]", "    digits = Vector{UInt8}()\n\
    \    for str in lst\n        for i = 1:length(str) # i = 1, 2, 3\n           \
    \ digits[i] = count_digits(str[i])\n        end\n    end\n    return Vector{String}(digits)\n\
    end", "    \n    odd_count = Vector{String}(undef,length(lst))\n    for i in eachindex(lst)\n\
    \        odd_count[i] = length(findall(string(i)%2==1))\n    end\n    odd_count\n\
    end\n</cell>\n<code language=julia-1.6>", "    str_l = List.of(digits(lst))\n\
    \    for i in str_l\n        str_i = i\n    end\n    return Vector{String}(str_l)\n\
    end", "    ans = Vector{String}()\n    for i in length(lst)\n        push!(ans,\
    \ strcat(\"the number of odd elements \", length(count_digits(lst[i])), \" of\
    \ the str\", length(lst[i]), \" of the \", length(lst[i]), \" input.\")) \n  \
    \  end\n    return ans\nend\n</cell>\n<text>\nTask: odds_even_count\nThis task\
    \ will implement the odds_even_count  function which takes in a\nvector of strings\
    \ and returns a vector of strings. Each element in the output\nshould be the string\
    \ \"the number of odd and even digits in the i'th string of\nthe input.\" where\
    \ all the i's should be replaced by the number of\nodd and even digits in the\
    \ i'th string of the input.", "    for i in lst \n        lst[i] = \"the number\
    \ of odd elements \"\n        odd_num = length(digits(i, digits=1))\n        odd_num\
    \ += length(digits(i, digits=2))\n        odd_num += length(digits(i, digits=3))\n\
    \        odd_num += length(digits(i, digits=4))\n        odd_num += length(digits(i,\
    \ digits=5))\n        odd_num += length(digits(i, digits=6))\n        odd_num\
    \ += length(digits(i, digits=7))\n        odd_num += length(digits(i, digits=8))\n\
    \        odd_num += length(digits(i, digits=9))\n        lst[i] += \" of the \"\
    \n        lst[i] += odd_num\n        lst[i] += \" of the \"\n        lst[i] +=\
    \ length(digits(i))\n        lst[i] += \".\"\n    end\n    return lst\nend", " \
    \   s = split(lst)\n    vec(map(x->length(x)/2, s))\nend", "    ans = Vector{String}()\n\
    \    odd_number_str = \"\"\"the number of odd elements\"\"\"\n    for i in lst\n\
    \        l = i\n        ans.push(l)\n    \n    return ans\nend", "    num_strings\
    \ = []\n    for str in lst\n        num_string = [i for i in str if isdigit(i)]\n\
    \        push!(num_strings, length(filter(isodd, num_string))/2)\n    end\n  \
    \  return num_strings\nend\n</cell>\n<code language=julia-1.0>\nodd_count([\"\
    1234567\"])\n</cell>\n<code language=julia-1.0>\nodd_count([\"3\", \"11111111\"\
    ])\n</cell>\n<text>\n12. counting all substrings\nGiven a string, count the occurence\
    \ of each substring in a list of string.", "    odd_str = \"\"\n    for i in lst\n\
    \        odd_str = odd_str * i \n        odd_str = odd_str[end-2:end]\n    end\n\
    \    odd_str = replace(odd_str,\".\",\"\")\n    odd_str = replace(odd_str,\",\"\
    ,\"\")\n    odd_str = replace(odd_str,\"-\",\"\")\n    odd_str = replace(odd_str,\"\
    +\",\"\")\n    odd_str = replace(odd_str,\"0\",\"\")\n    odd_str = replace(odd_str,\"\
    1\",\"\")\n    odd_str = replace(odd_str,\"2\",\"\")\n    odd_str = replace(odd_str,\"\
    3\",\"\")\n    odd_str = replace(odd_str,\"4\",\"\")\n    odd_str = replace(odd_str,\"\
    5\",\"\")\n    odd_str = replace(odd_str,\"6\",\"\")\n    odd_str = replace(odd_str,\"\
    7\",\"\")\n    odd_str = replace(odd_str,\"8\",\"\")\n    odd_str = replace(odd_str,\"\
    9\",\"\")\n    odd_str = replace(odd_str,\" \",\"\")\n    odd_str = replace(odd_str,\"\
    0\",\"\")\n    odd_str = replace(odd_str,\"1\",\"\")\n    odd_str = replace(odd_str,\"\
    2\",\"\")\n    odd_str = replace(odd_str,\"3\",\"\")\n    odd_str = replace(odd_str,\"\
    4\",\"\")\n    odd_str = replace(odd_str,\"5\",\"\")\n    odd_str = replace(odd_str,\"\
    6\",\"\")\n    odd_str = replace(odd_str,\"7\",\"\")\n    odd_str = replace(odd_str,\"\
    8\",\"\")\n    odd_str = replace(odd_str,\"9\",\"\")\n    odd_str = replace(odd_str,\"\
    \",\"\")\n    odd_str = replace(odd_str,\"x\",\"\")\n    odd_str = replace(odd_str,\"\
    -\",\"\")\n    return odd_str\nend\nodd_count([\"1234567\"])\nodd_count([\"3\"\
    , \"11111111\"])\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    odd_count(string::AbstractString)",
  "    odd_list = []\n    for s in lst\n        odd_list.append(count(odd_digits(s)))\n\
    \    end\n    return odd_list\nend\n    \n\"\"\"\n    odd_digits\n    Find the\
    \ numbers of odd digits in a string\n    \"\"\"", "    return map(x -> count(x,\
    \ pattern(\"[1-9]\")), lst)\nend", "    odds = count_odds(lst)\n    odd_count_str\
    \ = ( length(o) - length(odds) * \"the number of odd elements\" for o in odds\
    \ )\n    return odd_count_str\nend", "    if lst == [] return [] \n    odd_counts\
    \ =  map(lst, counts(lst))\n    odd_counts = vec(odd_counts)\n    odd_counts =\
    \ vec(map(sum, odd_counts)) \n    odd_counts = vec(odd_counts)\n    return [\"\
    the number of odd elements \" + string(odd_counts[n+1]) + \" the str\" + string(odd_counts[n+1])\
    \ + \"of the str\" + string(odd_counts[n+1]) + \" of the str\" + string(odd_counts[n+1])\
    \ + \" of the str\" + string(odd_counts[n+1]) + \".\" for n in 1:length(odd_counts)]\n\
    end\n</cell>\n<cell>\n@doc odd_count\n</cell>\n<text>\nAs with finding and removing\
    \ the odd numbers, let's define a helper function that will do the substitution",
  "    vec =  Vector{String}(undef, 0)\n    for i in lst\n        push!(vec, strcount(i,\
    \ \"1\") + strcount(i, \"8\"))\n    end\n    vec\nend\n</code>\n<|/ a |>\n<| a\
    \ tags=function,julia |>\nA pure functional approach to this problem with one\
    \ pass through your list. \n<code>\njulia> function odd_count(lst)\n         \
    \  s = String{length(lst)}(undef, \"\")\n           for i \u2208 lst\n       \
    \        s[i] = (sum(map(x -> x % 2 == 1, i)))\n           end\n           s\n\
    \       end\nodd_count (generic function with 1 method)", "    \nend\n</cell>\n\
    <text>\nSolution\nClick below for a solution.", "    odd_counts=Vector{String}(undef,\
    \ 0)\n    for str in lst\n        for char in str\n            if isdigit(char)\n\
    \                push!(odd_counts,str)\n            end\n        end\n    end\n\
    \    return odd_counts\nend\n</cell>\n<code language=julia-1.5>", "    sz = length(lst.first)\n\
    \    @assert(length(lst.first) == length(lst))\n    odd_count = 0\n    for i in\
    \ 1:length(lst)\n        odd_count += length(strsplit(lst[i], \"\")[[1]]) %2 \n\
    \    end\n    odd_count::Vector{String} = [string(\"the number of odd elements\
    \ \" * string(odd_count))] \n    return odd_count\nend", "    # check size\n \
    \   if length(lst)==0\n        return \"empty list\"\n    # check type\n    if\
    \ eltype(lst) != String\n        return \"only strings can be counted as an odd\
    \ number\"\n    # check values\n    count_digits(lst)\nend\n</cell>\n<text>\n\
    Exercise 7.1: Define odd_count2 as a function that accepts a vector of strings\
    \ representing integers\nand returns a vector containing strings, where each string\
    \ is the sum of the odd digits of its input strings.", "    \n    even = lst.filter(x\
    \ -> x != \"0\")\n    odd = lst.filter(x -> x != \"1\")\n    \n    return collect(map(\n\
    \                x -> length(x) + length(filter(x -> x != '0', x)), even) +\n\
    \                map(\n                    x -> length(x) + length(filter(x ->\
    \ x != '1', x)), odd))\nend\n</cell>\n<text>\nodd_count([\"1234567\"])", "   \
    \ \"\"\"\n    Given a vector of strings, where each string consists of only digits,\
    \ return a vector.\n    Each element i of the output should be \"the number of\
    \ odd elements in the\n    string i of the input.\" where all the i's should be\
    \ replaced by the number\n    of odd digits in the i'th string of the input.",
  "    \n    count_odd = 0\n    for str in lst\n        count_odd += count(str)\n\
    \    end\n    count_odd = count_odd % 2\n    \n    return [\"the number of odd\
    \ elements \" .. count_odd .. \" of the \" .. join(lst, \" \") .. \".\"]\nend",
  "    sum = \"\"\n    for i in lst\n        n = length(i)\n        sum += string(n)\n\
    \    end\n    odd_count_string = sum\n    odd_count_string = odd_count_string[1\
    \ .. end]\n    return odd_count_string\nend", "    s = \"\"\n    for i in lst\n\
    \        s += \"the number of odd elements \"\n        s += \"of the \"\n    \
    \    s += \"str\"\n        s += \"nng \"\n        s += \"n\"\n        s += \"\
    put.\"\n        s += \"\\n\"\n    end\n    \n    return s\nend\n</cell>\n<code\
    \ language=julia-1.2>\n@doc odd_count\n</cell>\n<text>\nNow try using the odd_count\
    \ function above. Compare it to the output below.", "    ans = Vector{String}(undef,\
    \ 0)\n    for i in 1:length(lst)\n        push!(ans, odd_count(lst[i]))\n    end\n\
    \    return ans\nend", "    lst2 = []\n    for s in lst\n        lst3 = digits(s)\n\
    \        for n in lst3\n            if n%2==1\n                push!(lst2,n)\n\
    \            end\n        end\n    end\n    return lst2\nend\n</cell>\n<cell>\n\
    odd_count([\"1\", \"23\", \"5\"])\n</cell>\n<text>\nExercise: Implement the function\
    \ digit, which takes in a string and returns the number of digits in it. Test\
    \ your function on the following inputs:", "    s = \"\"\n    for i in lst\n \
    \       s += \"the number of odd elements in the str\"\n        s += i\n     \
    \   s += \" of the \"\n        s += i\n        s += \".\"\n    end\n    s\nend\n\
    </code>\n<|/ a dscore=0 tags=string,julia,vector,function |>\n<| c |>\nThis works\
    \ for me - Thanks!\n<|/ c |>\n<| c |>\nI tried to apply this to a longer list\
    \ of strings and am getting an error:", "    \"\"\"\n    odd_count(lst)", "  \
    \  odds = findall(x -> x != \"0\", lst)\n    odd_count(odds)\nend\n</cell>\n<cell>",
  "    \"\"\"\n    >>> odd_count([\"1234567\"])\n    [\"the number of odd elements\
    \ 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count([\"3\", \"11111111\"])\n\
    \    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number\
    \ of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    return collect(enumerate(lst)).map(\
    \ x => odd_count_item(x[1]) )\nend", "    digits = [map(digit, x) -> digit(x)\
    \ for x \u2208 lst]\n    odd_digits = filter(odd, digits)\n    return [x -> \"\
    the number of odd elements \" * length(x) + x \u2208 lst for x in odd_digits]\n\
    end\n</cell>\n<code language=julia-1.5>\n@testset \"Test odd_count function \"\
    \ begin\n    @test odd_count([\"3\", \"11111111\"]) == [\n        \"the number\
    \ of odd elements 1n the str1ng 1 of the 1nput.\",\n        \"the number of odd\
    \ elements 8n the str8ng 8 of the 8nput.\"\n    ]\n    @test odd_count([\"1234567\"\
    ]) == [\n        \"the number of odd elements 4n the str4ng 4 of the 4nput.\"\n\
    \    ]\nend\n</cell>\n<text>\nPart 3: Vectorized String Operations", "    odd::Vector{Int}\
    \ = []\n    for i in lst\n        push!(odd, length(i) .% 2)\n    end\n    odd\
    \ = Int[odd]\n    odd_count = []\n    for i in 1:length(lst)\n        if length(find(isodd,\
    \ lst[i]))==length(lst[i])\n            push!(odd_count, get(iouname(i), :))\n\
    \        end\n    end\n    for i in 1:length(odd)\n        push!(odd_count, odd_count[i])\n\
    \    end\n    return odd_count\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\
    Given a vector of strings, where each string consists of only digits, return a\
    \ vector.\n    Each element i of the output should be \"the number of even elements\
    \ in the\n    string i of the input.\" where all the i's should be replaced by\
    \ the number\n    of even digits in the i'th string of the input.", "    s = Vector{String}(undef,0)\n\
    \    \n    for i in lst\n        if i.length == 1\n            push!(s,\"the number\
    \ of odd elements 1n the str1ng 1 of the 1nput.\")\n        elseif i.length ==\
    \ 2\n            push!(s,\"the number of odd elements 2n the str2ng 2 of the 2nput.\"\
    )\n        elseif i.length == 3\n            push!(s,\"the number of odd elements\
    \ 3n the str3ng 3 of the 3nput.\")\n        elseif i.length == 4\n           \
    \ push!(s,\"the number of odd elements 4n the str4ng 4 of the 4nput.\")\n    \
    \    elseif i.length == 5\n            push!(s,\"the number of odd elements 5n\
    \ the str5ng 5 of the 5nput.\")\n        elseif i.length == 6\n            push!(s,\"\
    the number of odd elements 6n the str6ng 6 of the 6nput.\")\n        elseif i.length\
    \ == 7\n            push!(s,\"the number of odd elements 7n the str7ng 7 of the\
    \ 7nput.\")\n        elseif i.length == 8\n            push!(s,\"the number of\
    \ odd elements 8n the str8ng 8 of the 8nput.\")\n        elseif i.length == 9\n\
    \            push!(s,\"the number of odd elements 9n the str9ng 9 of the 9nput.\"\
    )\n        end\n    end", "    \n    # Your code here\n    n::Vector{Int} = [0]*length(lst)\n\
    \    for i=1:length(lst)\n        push!(n,count(digits(lst[i])))\n    end\n  \
    \  return map(word,map(str,n))\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\
    Given a vector of strings, where each string consists of only digits, return a\
    \ vector.\n    Each element i of the output should be \"the number of even elements\
    \ in the\n    string i of the input.\" where all the i's should be replaced by\
    \ the number\n    of even digits in the i'th string of the input.", "    vec =\
    \ Vector{String}(undef, 0)\n    for str in lst\n        for c in str\n       \
    \     if c == '1'\n                push!(vec, length(str) - 1)\n            end\n\
    \        end\n    end\n    return vec\nend\n</cell>\n<code language=julia-0.5>\n\
    # Test that this function works:\nodd_count([\"3\", \"11111111\"])\n</cell>\n\
    <text>\nPart 2: Problem Analysis\nYou now have the necessary tools to finish the\
    \ problem. As you move through the problem, you will identify observations that\
    \ can help you clarify your answer, and that will prompt you to complete the problem.\
    \ For example, in this problem, you will observe that:", "    cnts = Dict{Int,\
    \ Int}()\n    for i in eachindex(lst)\n        cnts[oddcount(lst[i])] +=1\n  \
    \  end\n    [i*\"number of odd elements \"* cnts[key] for key in cnts]\nend\n\
    </cell>\n<text>\n\u2605 What is the sum of the odd digits of a string?\nComplete\
    \ the function odd_sum. Recall that a string is an array of digits. Write a function\
    \ that takes a string and returns an array of integers representing the sum of\
    \ the odd digits in the string.", "    number_odd_elements = []\n    for i in\
    \ lst do\n        number_odd_elements = append(number_odd_elements, (count(i)%2\
    \ != 0))\n    end\n    number_odd_elements = flatten(number_odd_elements)\n  \
    \  return number_odd_elements\nend", "    vec1 = vec(lst)\n    \n    for j in\
    \ 1:length(lst)\n        vec1[j] = count_digits(vec1[j])\n    end\n    \n    for\
    \ i in 1:length(vec)\n        for j in 1:length(vec)\n            if vec1[j] ==\
    \ 0\n                vec1[j] = 0\n            end\n        end\n        \n   \
    \     vec[i] = string(vec[i])\n    end\n    \n    return vec1\nend", "     n =\
    \ length(lst) \n     odd_digits = filter(isdigit, lst) \n     odd_digits_length\
    \ = size(odd_digits)\n     odd_counts = Vector{String}(undef, n)\n     for index\
    \ in 1:n\n       if odd_digits[index] == \"0\"\n           odd_counts[index] =\
    \ \"0\"\n       else\n           odd_counts[index] = length(filter(x -> x == '1',\
    \ odd_digits[index:end]))\n       end\n     end\n     return odd_counts\nend",
  "    odd_number_str = Vector{String}(undef, 0)\n    for i in lst\n        odds_count\
    \ = sum([i =~ \"[0-9]\" for c in i])\n        odd_number_str = [concat_strings(odd_number_str,\
    \ to_string(odds_count))]\n    end\n    return odd_number_str\nend\n</cell>\n\
    <text>\n3. Exercise\nGiven a list of vectors of numbers, compute the mean of each\
    \ vector. Return the mean as a vector. For example, if the input is [[1, 2, 3],\
    \ [4, 5], [6, 7, 8], [9, 10, 11]] the output should be [5, 7, 9, 11].", "    odd_digits\
    \ = sum([odd(digit) for digit in lst.collect(&isdigit)])\n    odd_digits_str =\
    \ string(odd_digits)\n    odd_digits_str_arr = split(odd_digits_str)\n    odd_digits_str_arr.map(x->string(length(x)))\n\
    \    odd_digits_str_arr.map(x -> if x == \"\" then x else \"the number of\" +\
    \ x + \"odd elements\")\nend", " \n    result = []", "  digits = [i for i in lst]\n\
    \  digits = digits[digits .!= 0]\n  odd_counts = digits[digits .%2 == 0]\n  return(odd_counts)\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThank you! I got it to work. Can you explain\
    \ why your solution is better than the one I came up with?\n<|/ c |>\n<| c |>\n\
    Your solution uses a regular expression, which will run slower on a bigger list.\
    \ The solution I wrote uses vector operations rather than regular expressions.\
    \ This may help you understand the code better: https://www.youtube.com/watch?v=yRbW9wuq4s4\n\
    <|/ c |>\n<| c |>\nI added a more concise solution below that is a bit faster.\
    \ My solution runs in about a second for a vector of length 5000, yours in about\
    \ 1.5 seconds on a vector of length 50000. On a vector of length 5000, your solution\
    \ is twice as fast as mine.\n<|/ c |>\n<| a |>\nHere is another solution:\n<code>\n\
    using Statistics", "    result=Vector{String}(length(lst))\n    for i=1:length(lst)\n\
    \        result[i]=count(lst[i])%2==1?\"the number of odd elements {}n the str{}ng\
    \ {} of the {}nput.\".format(i,i,i,lst[i]):\"the number of odd elements {}n the\
    \ str{}ng {} of the {}nput.\".format(i,i+1,i+1,lst[i])\n    end\n    return result\n\
    end\n</cell>\n<cell>\nodd_count([\"1\", \"1111\", \"10\", \"1234\"])\n</cell>\n\
    <text>\nEven Numbers\nGiven a vector of strings, where each string consists of\
    \ only digits, return a vector.\n    Each element i of the output should be \"\
    the number of even elements in the\n    string i of the input.\" where all the\
    \ i's should be replaced by the number\n    of even digits in the i'th string\
    \ of the input.", "    res = \"\"\n    sum = 0\n    for str in lst\n        sum\
    \ += odd_digits(str)\n        if sum != 0\n            res = res + \"the number\
    \ of odd elements \" + sum + \" the str\" + sum + \"of the \" + str + \"input.\"\
    \n        end\n    end\n    return Vector{String}(res)\nend", "    v = Vector{String}(undef,\
    \ 0)\n    for i in lst\n        v .+= count((i).digits(), \"ODD\")\n    end\n\
    \    v\nend\n</cell>\n<cell>", "    sum::Int64 = 0\n    for i in lst\n       \
    \ sum += length(filter(isodd, i))\n    end\n    return [\"the number of odd elements\
    \ $sumn the str$sum of the $sumnput.\"]\nend\n</cell>\n<code language=julia-1.5>\n\
    odd_count([\"12\", \"1122\", \"222\", \"111\", \"22\", \"333\", \"33\", \"44\"\
    ])\n</cell>\n<code language=julia-1.5>\nodd_count([\"333\", \"44\"])\n</cell>\n\
    <code language=julia-1.5>\nodd_count([\"44\"])\n</cell>\n<text>\n1.12 Finding\
    \ the position of an element in a vector\nGiven a vector of strings, where each\
    \ string consists of only digits, return a vector with the number of times each\
    \ element appears.", "    digits::Vector{Int} = [digit(elem) for elem in lst]\n\
    \    odd::Vector{Bool} = digits[1:end-1] .% 2 == 1\n    vec::Vector{String} =\
    \ copy(digits)\n    vec[!odd] = vec[!odd] .+ digits[!odd]\n    vec\nend\n</cell>\n\
    <text>\nGiven a vector of integers, where each integer is between 1 and 100, return\
    \ a vector.\n    Each element i of the output should be \"the number of even elements\
    \ in the\n    integer i of the input.\" where all the i's should be replaced by\
    \ the number\n    of even digits in the i'th integer of the input.", "    digits\
    \ = [x for x in string(lst)]\n    digits = digits[digits[2] .!= \"0\"]\n    odd_digits\
    \ = digits[digits[2] .== \"0\"]\n    odd_counts = Dict(\"the number of odd elements\"\
    \ => 0)\n    for i in digits\n        if digits[2] .== \"0\"\n            odd_counts[\"\
    the number of odd elements 1n the str1ng 1 of the 1nput.\"] += 1 \n        elseif\
    \ digits[2] .== \"1\"\n            odd_counts[\"the number of odd elements 1n\
    \ the str1ng 1 of the 1nput.\"] += 1 \n        elseif digits[2] .== \"2\"\n  \
    \          odd_counts[\"the number of odd elements 2n the str1ng 2 of the 1nput.\"\
    ] += 1 \n        elseif digits[2] .== \"3\"\n            odd_counts[\"the number\
    \ of odd elements 4n the str1ng 4 of the 1nput.\"] += 1 \n        elseif digits[2]\
    \ .== \"4\"\n            odd_counts[\"the number of odd elements 8n the str1ng\
    \ 8 of the 1nput.\"] += 1 \n        elseif digits[2] .== \"5\"\n            odd_counts[\"\
    the number of odd elements 16n the str1ng 16 of the 1nput.\"] += 1 \n        elseif\
    \ digits[2] .== \"6\"\n            odd_counts[\"the number of odd elements 32n\
    \ the str1ng 32 of the 1nput.\"] += 1 \n        elseif digits[2] .== \"7\"\n \
    \           odd_counts[\"the number of odd elements 64n the str1ng 64 of the 1nput.\"\
    ] += 1 \n        elseif digits[2] .== \"8\"\n            odd_counts[\"the number\
    \ of odd elements 128n the str1ng 128 of the 1nput.\"] += 1 \n        elseif digits[2]\
    \ .== \"9\"\n            odd_counts[\"the number of odd elements 256n the str1ng\
    \ 256 of the 1nput.\"] += 1 \n        elseif digits[2] .== \"10\"\n          \
    \  odd_counts[\"the number of odd elements 512n the str1ng 512 of the 1nput.\"\
    ] += 1 \n        elseif digits[2] .== \"11\"\n            odd_counts[\"the number\
    \ of odd elements 1n the str1ng 1 of the 1nput.\"] += 1 \n        elseif digits[2]\
    \ .== \"12\"\n            odd_counts[\"the number of odd elements 2n the str1ng\
    \ 2 of the 1nput.\"] += 1 \n        elseif digits[2] .== \"13\"\n            ",
  "    return map( (x) -> length(x) - length(regexprep(String(x), r\"\\d\", \"\"))\
    \ , lst)\nend", "  counts = Dict()\n  for s in lst\n    counts[s] = counts[s]\
    \ + count(s, '1n')\n  end\n  \n  new_counts = vcat(reverse(counts.values()), counts.keys)\n\
    \  \n  new_counts = sort_unique(new_counts)\n  \n  return new_counts\nend", " \
    \   res=Vector{String}(undef, length(lst))\n    for i in eachindex(lst)\n    \
    \    res[i]=odd_count(lst[i])\n    end\n    res\nend", "    return Vector{String}(map(count_odd,\
    \ lst))\nend", "    str = join((string.split() for string in lst))\n    for a\
    \ in str\n        num = count(a::String, digits)\n        push!(str, num * div(length(a),\
    \ 2))\n    end\n    return str\nend\n</cell>\n<code language=julia-1.0>\n#export",
  "        number_list = []\n        for string in lst\n            number_list.append(sum(string.chars.map(findwith)[2]))\
    \ \n            number_list = [sum(i) for i in zip(number_list,number_list)]\n\
    \        end\n        return number_list\n    end\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThis is not even an answer!\n<|/ c |>\n<| c |>\nWell, if you have your\
    \ own answer which solves the problem, or if you prefer to keep it all here to\
    \ help others, that's fine. I just thought it might be useful to share since I\
    \ came across a similar question and thought it might be helpful to share the\
    \ solution (since I learned something new myself). But I agree with you, your\
    \ answer does not solve the question, which is why I posted it as a comment.\n\
    <|/ c |>\n<| a |>\n<code>\nimport Data.List\nimport Data.Maybe\nodd_count :: String\
    \ -> String\nodd_count s\n  | length (splitAt 1 (reverse s) /= []) == length (splitAt\
    \ 1 (reverse s)) == length s = (\"The number of odd elements in the\" ++ ((splitAt\
    \ 1 (reverse s) |> length) |> show) ++ \" of the \" ++ ((splitAt 1 (reverse s)\
    \ |> length) |> show) ++ \" of the input.\")\n  | otherwise = (\"The number of\
    \ odd elements in the\" ++ ((splitAt 1 (reverse s) |> length) |> show) ++ \" of\
    \ the \" ++ ((splitAt 1 (reverse s) |> length) |> show) ++ \" of the input.\"\
    ) \n</code>\n<|/ a tags=ocaml,functional-programming dscore=1 |>\n<| a dscore=0\
    \ tags=ocaml,functional-programming |>\nHere's my solution using recursion. I\
    \ did a little bit of code golf so it's easier to understand what's going on,\
    \ but it's really not that much code after all. \n<code>\nlet rec odd_count s\n\
    \    | String.length s = \n        let (odd, even) = String.split s @' ' in\n\
    \        odd_count (String.sub (String.length s) 1 ) \n        |> String.concat\
    \ \"\"\n        |> sprintf \"the number of odd elements %n in the %nstr%n%d of\
    \ the %nstr%n%d of the input.\"\n        |> String.concat [\"odd: \",(odd + even),\"\
    .\"]\n    | otherwise = (sprintf \"the number of odd elements %n in the %nstr%n%d\
    \ of the %nstr%n%d of the input.\" \n            (odd_count (String.sub (String.length\
    \ s) 1) \n", "    \n    len_str = length(lst)\n    odd_nums = zeros(len_str, 1)\n\
    \    for s in lst\n        odd_nums = odd_nums .+ findall(x -> x == '1', s)\n\
    \    end\n    odd_nums = findall(x -> x != 1, odd_nums)\n    return vcat(map(string,\
    \ odd_nums)...)\nend\n</cell>\n<code language=julia-1.6>\n@assert odd_count([\"\
    1234567\"]) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n\
    @assert odd_count([\"3\", \"11111111\"]) == [\"the number of odd elements 1n the\
    \ str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the\
    \ 8nput.\"]\n</cell>\n<text>\n5.3 Find all the odd elements in the second half\
    \ of a vector", "    n = lst.size\n    s = zeros(Int, n)\n    odd_count = 0\n\
    \    for i in lst\n        for j = 1:i\n            if isodd(Int64(lst.[i][1]))\n\
    \                odd_count += 1 \n            end\n        end\n    end\n    for\
    \ i = 1:n\n        s[i] = odd_count\n    end\n    return s\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    \n    #return Vector{String}(\"\",0)\n    \n    #initialize\
    \ variable\n    numOdd = 0\n    \n    #count the odd numbers\n    for num in lst\n\
    \        numOdd += sum(isOdd(i) for i in num)\n        \n    end", "    odd_digits\
    \ = Set(lst)\n    odd_elems = []\n    for s in odd_digits\n        odd_elems =\
    \ union(odd_elems, collect(count(s)) .- s)\n    end\n    return [\"the number\
    \ of odd elements $n the $str$n of the $nput.\" for n in odd_elems]\nend", " \
    \   return map(string -> count1(odds(string)), lst)\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Given a vector of strings, where each string consists of only digits, return\
    \ a vector.\n    Each element i of the output should be \"the number of even elements\
    \ in the\n    string i of the input.\" where all the i's should be replaced by\
    \ the number\n    of even digits in the i'th string of the input.", "    n1 =\
    \ length(lst)\n    odd_elements = Vector{Int}(undef, n1)\n    odd_digits = Vector{Int}(undef,\
    \ n1)\n    for i in 1:n1\n        \n        #print(i)\n        #println(lst[i])\n\
    \        for j in 1:length(lst[i])\n            if length(odd_digits)>0\n    \
    \            odd_digits[end] = odd_digits[end] + 1\n                odd_elements[end]\
    \ = odd_digits[end]\n            else\n                odd_digits = Vector{Int}([length(lst[i])+1])\n\
    \                odd_elements = Vector{Int}([length(lst[i])+1])\n            end\n\
    \        end\n    end\n    \n    return [\"the number of odd elements \", join(map(str,odd_elements)),\
    \ \"n the str\", join(map(str,odd_digits)), \"of the nput.\"]\nend\n</cell>\n\
    <code language=julia-1.5>\nodd_count([\"3\", \"11111111\"])\n</cell>\n<code language=julia-1.5>\n\
    odd_count([\"3\", \"11111111\", \"2345566\"])\n</cell>\n<text>\nodd_digit(s::String)",
  "  odd_chars <- [i for i in lst if i!=\"\"]\n  odd_chars_count <- length(odd_chars)\n\
    \  return [string(odd_chars_count) .. string(reverse(odd_chars_count))]\nend\n\
    </cell>\n<text>\nPutting It All Together\nTo use the functions from above in the\
    \ next cell, just copy and paste them together.", "  \n    for i in 1:length(lst)\n\
    \        \n        odds = length(findall(r\"\\d+\", lst[i]))\n        \n     \
    \   #println(i,lst[i],odds)\n        \n        lst[i] = string(odds)\n       \
    \ \n    end\n    \n    return lst\nend", "    if length(lst) == 0 then return\
    \ [] end\n    odd_count = 0\n    for i in lst\n        odd_count += count_digits(i)\
    \ % 2 != 0\n    end\n    odd_count = length(lst) * [odd_count]\n    return odd_count\n\
    end\n</code>\n<|/ a |>\n<| a |>\nA similar solution using Regexps could be:\n\
    <code>", "    count_odd_in_string(lst, count(string(i) for i in lst))\nend", " \
    \   \n    vector = Vector{String}(undef, 0)\n    for string in lst\n        vector\
    \ = vector.append(odd_count(string))\n    end\n    return vector\nend", "    \n\
    \    sum = 0\n    for i in lst\n        sum = sum + odd_digits(i)\n    end\n \
    \   return [\"the number of odd elements \" + string(sum) + \" the str\" + string(sum)\
    \ + \"n. of the \" + string(i) + \"nput.\"]\nend", "    n = length(lst)\n    s\
    \ = \"\"\n    for (i in 1:n) s *= Int(length(lst[i]))\n    for (i in 1:n) s +=\
    \ \"the number of odd elements \" +\n        str(length(lst[i])) + \"n the str\"\
    \ +\n        string(i, length(lst[i])) + \"of the str\" +\n        string(i, length(lst[i]))\
    \ + \" of the \" + string(i, length(lst[i])) + \"nput.\"\n    return s\nend",
  "    \n    #the length of the vector is the total count of odd digits. \n    count_odd\
    \ = zeros(Int, length(lst))\n    #the list comprehension below loops through each\
    \ string in lst and counts the odd digits. \n    #count_odd stores the number\
    \ of odd digits at each index. \n    for n in lst\n        for i = 1:n\n     \
    \       #count the number of odd digits in the ith element of lst \n         \
    \   count_odd[i] = count_odd[i] + sum(digit2odd(digits(lst[i])) == 1)\n      \
    \  end\n    end\n    \n    odd_strings = Array{String, 1}(undef, count_odd)\n\
    \    for n in 1:length(count_odd)\n        odd_strings[n] = paste(\"the number\
    \ of odd elements\", n, \" the str\", n, \" of the \", n, \" input.\", sep = \"\
    \")\n    end\n    \n    return odd_strings\nend", "    num_list = []\n    count\
    \ = 0\n    for i in lst\n        push!(num_list, length(i))\n    end\n    map(x\
    \ -> count = count + length(x) - length(reverse(x)), num_list)\n    return [\"\
    the number of odd elements \" string(x) \" \" x \" of the \" string(x) \" of input.\"\
    \ for x in num_list]\nend", "    return list(map(even.(oct(a) for a in lst), lst))\n\
    end\n</code>\n<|/ a dscore=3 tags=julia |>\n<| a dscore=2 tags=julia |>\nYou could\
    \ write a recursive function that counts the number of odd digits in a string.\n\
    <code>", "    return Vector{String}(undef, length(lst.first))\n    for i in 1..length(lst.first)\n\
    \        if all(digits(lst[i]) == digits(lst[i-1]))\n            push!(result.last,\
    \ f\"the number of odd elements {i} of the str{i} of the {i}put.\")\n        else\n\
    \            push!(result.last, f\"the number of odd elements {i} of the str{i}\
    \ of the {i}put.\")\n        end\n    end\n    result\nend", "    return vec(map(i->odd_count(i),\
    \ lst))\nend", "    odds = Vector{Int}()\n    for s in lst do \n        for n\
    \ in split(s, \"\") do \n            push!(odds, length(n))\n        end\n   \
    \ end\n    str = join(map(str, odds))\n    return str\nend\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"Return the number of even digits in the string.\"\"\"", "    lst_temp =\
    \ Vector{String}(undef, length(lst.first))\n    for i in eachindex(lst)\n    \
    \    odd_count_str = odd_count_str(lst.first[i])\n        lst_temp[i] = odd_count_str\n\
    \    end\n    return lst_temp\nend ", "    lst == [] || odd_count(lst[1:end])\
    \ == []\n    odd_count = Vector{String}(undef, 0)\n    for i in lst\n        for\
    \ j in String(i)\n            if j == \"1\"\n                odd_count = odd_count\
    \ + 1\n            end\n        end\n    end\n    odd_count\nend\n</cell>\n<code\
    \ language=julia-1.0>\n\"\"\"Find the maximum sum of a vector by summing up all\
    \ elements with the same sign.\n    That is, the maximum sum of all the elements\
    \ in the vector is equal to the sum of\n    the absolute value of those elements.",
  "    \n    # Make sure the input is valid\n    if length(lst) != length(map(x->(x==\"\
    \")? 0:str2double(x),lst))\n        throw(ArgumentError(\"Vector must contain\
    \ only numbers. Found: \",lst))\n    end\n    \n    # Initialize the output to\
    \ zero\n    res = zeros(length(lst))\n    for i=1:length(lst)\n        res[i]\
    \ = sum(map(x->(x==\"\")? 0:str2double(x),lst)[i:])\n    end\n    \n    # Return\
    \ the output\n    return res\nend\n</cell>\n<text>\nodd_count2(lst::Vector{String})",
  "    string_to_int = (digits(x) for x \u2208 lst)\n    map(\u03BB(x) -> oddcount(x),\
    \ string_to_int)\nend", "    answer = []\n    for i in lst\n        push!(answer,\
    \ map(i->count(i, digits::Digits), i:lst))\n    end\n    return answer\nend",
  "    return [\n        \"the number of odd elements \" + \n        odd_count(digits(i))\
    \ \n        for i in lst\n    ]\nend", "    odds = filter(isdigit, lst.elem)\n\
    \    return map(i->string(i), collect(odds))\nend", "    counts = Dict{Char, Int}()\n\
    \    for i in lst\n        counts[length(i)] = counts[length(i)] ? counts[length(i)]\
    \ + 1 : 1 \n    end\n    odd_digits = String[]\n    for k in keys(counts)\n  \
    \      push!(odd_digits, @sprintf(\"the number of odd elements %2n the str%2ng\
    \ %2n of the %2n put.\", counts[k], k, length(k)))\n    end\n    return odd_digits\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\n`odd_count([\"1\", \"11\", \"111\",\
    \ \"111\", \"1111\", \"111111\"])\n([\"the number of odd elements 2n the str2ng\
    \ 2 of the 2nput.\", \"the number of odd elements 2n the str2ng 2 of the 2nput.\"\
    , \"the number of odd elements 6n the str6ng 6 of the 6nput.\", \"the number of\
    \ odd elements 10n the str10ng 10 of the 10nput.\", \"the number of odd elements\
    \ 12n the str12ng 12 of the 12nput.\"])`", "    return sum(map(len, lst)) % 2\
    \ == 0 ?\n    vec(map(i-> \"the number of odd elements $(i) \" .* \n         \
    \   str_repeat(\" \", odd_count(count_digits(i)), \" \") .* \n            str_repeat(\"\
    \ \", count(i), \" \") , \n            lst)) :\n    vec(map(i-> \"the number of\
    \ odd elements $(i) \" .* \n            str_repeat(\" \", odd_count(count_digits(i)),\
    \ \" \") .* \n            str_repeat(\" \", count(i), \" \") , \n            lst))\n\
    end", "    if length(lst) == 0 return []\n    odds = sum(map(char->1 if char==\"\
    1\" else 0, lst))\n    return [\"the number of odd elements $oddn the str$oddn\
    \ of the $oddnput.\" for (oddn,str) in zip(odds..2*odds,lst)]\nend\n</code>\n\
    <|/ a tags=string,julia,vector,performance |>\n<| c |>\nThanks, this is super\
    \ helpful! Do you know how I could adapt this code to only allow certain characters\
    \ to be used in the odd count? I am currently working on a project that requires\
    \ only certain characters to be used, so this would be nice.\n<|/ c |>\n<| c |>\n\
    Yeah, I added an example of the kind of thing I meant\n<|/ c |>\n<| c |>\nIf i\
    \ have a list of lists, like so: `[[[\"1\",\"2\",\"3\",\"4\"],[\"1\",\"2\",\"\
    3\",\"4\"],[\"1\",\"2\",\"3\",\"4\"]]]` how could I modify this code to only count\
    \ the odd elements in each list?\n<|/ c |>\n<| c |>\nThat would be `map(function(lst)map(odd_count,\
    \ lst)...`, which does essentially the same thing, without the intermediate lists.\n\
    <|/ c |>\n<| a dscore=3 |>\nIf your only concern is performance, you can use Julia's\
    \ built-in high-performance \"strings\" package:\n<code>\nusing Strings", "  \
    \  \"\"\"\n    odd_count(lst)", "    odd_count = zeros(0)\n    for i in 0 :- size(lst,\
    \ 2)-1 do\n        odd_count = vcat(vcat(odd_count, sum(map(x -> count(x, \"1\"\
    ) % 2 != 0, lst[i]))), odd_count)\n    end\n    return odd_count\nend\n</cell>\n\
    <code language=julia-1.0>", "    str = reduce(strcat, lst)\n    odd_count_str\
    \ = strsplit(str, splitchar=\"1\")\n    odd_count_str = map(str, odd_count_str)\n\
    \    odd_count_str = filter(str -> !str =~ \"^\\d$\", odd_count_str)\n    odd_count_str\
    \ = map(str->parse(string=str),odd_count_str)\n    odd_count_str = map(x -> string(x),odd_count_str)\n\
    \    return odd_count_str\nend\n    \n\"\"\"\n    odd_count_vect::Vector{Vector{Int}}",
  "    digits = map(x->split(x, digits), lst)\n    odd_count = map(x->filter(x->isOdd(x),\
    \ x), digits)\n    odd_count_str = join(odd_count, \"n\")\n    return [\"the number\
    \ of odd elements $odd_count_str of the $lst string.\"]\nend\n</cell>\n<text>\n\
    Odd-Even Tuples\nThe odd_even function below takes in a list of strings, and outputs\
    \ a list of tuples of strings.\nThe tuple will consist of the count of odd strings\
    \ in the input list, the count of even\nstrings in the input list, and the list\
    \ of odd strings in the input list.", "    res = Vector{String}(undef, 0)\n  \
    \  for i in lst\n        push!(res, length(filter(x -> isdigit(x), i)))\n    end\n\
    \    res\nend", "    odds = Int64[]\n    for str in lst\n        odds = push!(odds,\
    \ sum(str =~ \"1\") .+ 1)\n    end\n    return Vector{String}(odds)\nend", " \
    \   vect_odd = Vector{Int}(length(lst))\n    for i = 1:length(lst)\n        if\
    \ isodd(lst[i])\n            vect_odd[i] += 1\n        end\n    end\n    str_result\
    \ = \"\"\n    for i in vect_odd\n        str_result += \"the number of odd elements\
    \ $i of the str$i of the input\"\n        str_result +=  \", \" \n    end\n  \
    \  return str_result\nend\n</cell>\n<code language=julia-0.4>\n@testset \"Odd\
    \ Count\" begin\n    odd_count([\"1234567\"])\n    odd_count([\"3\", \"11111111\"\
    ])\nend\n</cell>\n<text>\n4.3 String Manipulation", "    if length(lst) == 1\n\
    \        return [\"the number of odd elements 1n the str1ng 1 of the 1nput.\"\
    , \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    elseif length(lst)\
    \ == 0\n        return [\"the number of odd elements 0n the str0ng 0 of the 0nput.\"\
    ]\n    end\n    odd_count = [length(lst[i]) for i in eachindex(lst)]\n    \n \
    \   for idx in eachindex(lst)\n        if odd_count[idx] == 0\n            odd_count[idx]\
    \ = \"the number of odd elements 0n the str0ng 0 of the 0nput.\"\n        elseif\
    \ odd_count[idx] == 1\n            odd_count[idx] = \"the number of odd elements\
    \ 1n the str1ng 1 of the 1nput.\"\n        elseif odd_count[idx] <= 8\n      \
    \      odd_count[idx] = \"the number of odd elements 8n the str8ng 8 of the 8nput.\"\
    \n        end\n    end\n    \n    return odd_count\nend", "  local counts=Vector{String}()\n\
    \  for str in lst\n    local odd=0\n    for c in str\n      if c.digit()%2==1\n\
    \        odd+=1\n      end\n    end\n    push!(counts,\"the number of odd elements\
    \ $odd n the str$str $odd of the $str.\") \n  end\n  return counts\nend\nodd_count(strings)\n\
    </cell>\n<text>\nA simple case for using map", "    return Vector{String}(undef,\
    \ 0)\nend\n</cell>\n<code language=julia-1.4>\nodd_count([\"1234567\"])\n</cell>\n\
    <code language=julia-1.4>\nodd_count([\"3\", \"11111111\"])\n</cell>\n<code language=julia-1.4>",
  "    odd_counts = [length(filter(x -> isodd(x==1), vec)) for x in lst]\n    odd_counts\
    \ = nub.(odd_counts)\n    return [\"the number of odd elements \" <> (odd_counts[i])\
    \ \"n the str$(i) \" <> (odd_counts[i]) <> \" of the $(i) input\"\n        for\
    \ i in 1:length(lst)\n        ]\nend\n</cell>\n<code language=julia-1.0>\nodd_count([\"\
    1234567\"])\n</cell>\n<code language=julia-1.0>\nodd_count([\"3\", \"11111111\"\
    ])\n</cell>\n<text>\nWrite a function that returns a vector of all the integers\
    \ in an input whose square is odd.", "    odd_digit_count(digits(lst))\nend",
  "    if length(lst) == 0 \n        return string(\"the number of odd elements 0n\
    \ the str0ng 0\")\n    end", "    odd_str_count = count!(String[digits(i) for\
    \ i in lst], digits(lst))\n    odd_str_count_str = strcat(odd_str_count...\" \"\
    )\n    return Vector{String}(undef, 0)\nend", "    return Vector{String}(map((i)\
    \ -> length(findall(digits(i), digits(i)) != 1 ), lst))\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| a tags=julia |>\nAs has been pointed out in the comments, you cannot\
    \ use find on a Vector{String}, because find returns an iterator over the elements\
    \ that match the criteria and doesn't work on a Vector{String}. You could use\
    \ something like\n<code>", "    return Vector{String}[length(strsplit(lst, \"\"\
    )[2])...] + [\"the number of odd elements\"]\nend\n</cell>\n<code language=julia-0.6>\n\
    odd_count([\"3\", \"11111111\"])\n</cell>\n<code language=julia-0.6>\nodd_count([\"\
    3\", \"1111111\"])\n</cell>\n<text>\nodd_count2", "    \"The number of odd elements\
    \ in each string in the vector\"\n    lst1 = Vector{String}(map(String,lst))\n\
    \    odds = zeros(length(lst1))\n    for i in eachindex(lst1)\n        l = length(lst1[i])\n\
    \        odds[i] = length( filter(x -> x%2 == 1, lst1[i]) )\n    end\n    return\
    \ [\"the number of odd elements \" + string(i) +\n        \" of the str\" + string(i)\
    \ +\n        \" of the \" + string(i) +\n        \" input.\" for i in eachindex(odds)]\n\
    end\n</cell>\n<code language=julia-1.5>\nodd_count([\"1234567\"])\n</cell>\n<code\
    \ language=julia-1.5>\nodd_count([\"3\", \"11111111\"])\n</cell>\n<text>\nHow\
    \ about counting the number of unique words? We do this with the map function\
    \ and its count method (which is different from the length function and returns\
    \ a single value, instead of a vector):", "    lst.map(length).filter((x -> x%2==1)\
    \ == true).map(x -> \"the number of odd elements \" + string(x) + \" of the str\"\
    \ + string(x) + \" of the \" + string(x) + \"put.\").collect::Vector{String}\n\
    end\n</cell>\n<text>\nNow let's try it:", "    v = Vector{String}(undef, length(lst))\n\
    \    lens = Vector{Int}(length(lst, 2))\n    for i in 1:length(lst)\n        lens[i]\
    \ = length(lst[i])\n    end\n    for i in 1:length(lst)\n        for j in 1:lens[i]\n\
    \            if isdigit(lst[i][j])\n                push!(v, (lst[i][j] - \"0\"\
    ) * 2)\n            else\n                push!(v, \"0\")\n            end\n \
    \       end\n    end\n    return v\nend\n</code>\nThe function is now much simpler\
    \ and readable. The performance is not an issue with the function above. However,\
    \ the solution below is more efficient and easier to read. The function uses only\
    \ one for loop to iterate over the elements and use regular expressions to match\
    \ the numbers and count the odd digits in each element. Using regex is much more\
    \ efficient than splitting a character array and using an isdigit() function to\
    \ count the numbers. \n<code>\n\"\"\"\nGiven a vector of strings, where each string\
    \ consists of only digits, return a vector.\n    Each element i of the output\
    \ should be \"the number of odd elements in the\n    string i of the input.\"\
    \ where all the i's should be replaced by the number\n    of odd digits in the\
    \ i'th string of the input.", "    num_list = []\n    for i in lst\n        num_list.append(length(filter(x\
    \ -> x == \"1\", i)))\n    end\n    return num_list\nend\n</code>\n<|/ a tags=julia,arrays\
    \ dscore=2 |>\n<| a tags=julia,arrays dscore=0 |>\nThis might not be the most\
    \ elegant way to do it, but here is an alternative way using map and filter:\n\
    <code>"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
