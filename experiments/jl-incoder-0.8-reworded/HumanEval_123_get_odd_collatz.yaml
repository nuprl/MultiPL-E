name: HumanEval_123_get_odd_collatz
language: jl
prompt: "\"\"\"\n    Given a positive integer n, return a sorted vector that has the\
  \ odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
  \ in mathematics that concerns a sequence defined\n    as follows: start with any\
  \ positive integer n. Then each term is obtained from the \n    previous term as\
  \ follows: if the previous term is even, the next term is one half of \n    the\
  \ previous term. If the previous term is odd, the next term is 3 times the previous\n\
  \    term plus 1. The conjecture is that no matter what value of n, the sequence\
  \ will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n        2.\
  \ returned vector sorted in increasing order.\n\n    For example:\n    get_odd_collatz(5)\
  \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
  \ numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n    [1, 5]\n    \"\"\"\
  \nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n"
tests: "using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
  \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
  \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
completions: ["    vec = [n]\n    for i in vec\n        if i%2 == 0\n            next\
    \ = i/2\n        else\n            next = i*(3 + 1)\n        push!(vec, next)\n\
    \    end\n    vec\nend\n</cell>\n<code language=julia-1.4>\n\"\"\"\n    Given\
    \ a positive integer n, return a sorted vector that has the even numbers in collatz\
    \ sequence.", "    odd_vec =  Vector{Int64}[]\n    for i = 2:n\n        if isodd(i)\n\
    \            odd_vec = [i for i in odd_vec,i*2] \n        else\n            odd_vec\
    \ = [i for i in odd_vec,3*i+1]\n        end\n    end\n    odd_vec\nend", "   \
    \ if (n == 1) return [1]\n    odd_vec = Vector{Int64}(undef, n - 1)\n    for i\
    \ in 1:n - 1\n        odd_vec[i] = odd_vec[i + 1] * 2 + 1\n    end\n    return\
    \ odd_vec\nend\n</cell>\n<code language=julia-1.5>", "    odd_vector = Vector{Int64}(0)\
    \ # Vector to store the odd numbers\n    for v in 1:n \n        if v%2==0 \n \
    \           odd_vector = push!(odd_vector,v) \n        else \n            odd_vector\
    \ = push!(odd_vector, v*2)\n        end\n    end\n    odd_vector\nend", "    if\
    \ n == 1 \n        return [1]\n    odd = get_odd_collatz(n / 2)\n    even = get_odd_collatz((3\
    \ * n) + 1)\n    odd *= ifelse(n % 2, 1 / (2 ^ n % 2), 1)\n    even *= ifelse(n\
    \ % 2, 1 / (2 ^ n % 2), 1)\n    odd = odd + (n / 2)\n    even = even + (n / 2)\n\
    \    odd.prepend(odd)\n    even.prepend(even)\n    return odd ++ even\nend\n</cell>\n\
    <code language=julia-0.4>\n@time odds = get_odd_collatz(100000);\n</cell>\n<code\
    \ language=julia-0.4>\n@time odds = get_odd_collatz(100000);\n</cell>\n<text>\n\
    Question 1: What is the run time of your get_odd_collatz function? How does it\
    \ scale? What is the expected run time?", "    if n <= 1\n        [1]\n    else\n\
    \        if is_even(n) == true\n            get_odd_collatz(n-1) + [n/2]\n   \
    \     else\n            get_odd_collatz(n-1) + [n*(3*n+1)/2]\n        end\n  \
    \  end\nend\n</code>\nTests\nTest Cases", "    if n == 1 \n        return [1]\
    \ \n    odd = get_odd_collatz(n-1) \n    even = get_even_collatz(n-1)\n    # concatenate\
    \ vectors of odd numbers and even numbers\n    return concat([odd, even]) #TODO:\
    \ check that vectors are sorted\nend\n</cell>\n<code language=julia-1.5>\n# test\
    \ the function\n@assert [5, 16, 8, 4, 2, 1] == get_odd_collatz(5)\n@assert [5,\
    \ 16, 8, 4, 2, 1] == get_odd_collatz(4)\n@assert [5, 16, 8, 4, 2, 1] == get_odd_collatz(2)\n\
    @assert [5, 16, 8, 4, 2, 1] == get_odd_collatz(1)\n</cell>\n<text>\nQuestion 2\n\
    Write a function, get_even_collatz, natural numbers are given as a vector in decreasing\
    \ order, and return this vector. As discussed in the lectures, a natural number\
    \ is given as a vector in decreasing order. \nFor example the natural numbers\
    \ [1,2,3] are given as [3,2,1], as [1, 3, 2].", "    if n==1\n        [1]\n  \
    \  else\n        collatz_seq = get_odd_collatz(n-1)\n        collatz_seq = [x|collatz_seq\
    \ for x in collatz_seq]\n    end\nend\n</cell>\n<text>\nExercise: write a recursive\
    \ function that takes a positive integer n and returns the Collatz sequence up\
    \ to n.", "    odd_vector = Vector{Int64}()\n    while n > 1\n        odd_vector\
    \ += n % 2 == 1 ? n / 2 : 3 * n + 1\n        n /= 2\n    end\n    return odd_vector\n\
    end\n</cell>\n<code language=julia-1.3>\nget_odd_collatz(100)\n</cell>\n<text>\n\
    Exercise: Implement Collatz Conjecture\nImplement a function that determines whether\
    \ a positive integer n is a Collatz conjecture. \nAssume Collatz conjecture is\
    \ always satisfied, i.e. a number greater than 1 will eventually reach 1.", " \
    \   if n == 1\n        Vector{Int64}[1]\n    elseif n <= 0\n        Vector{Int64}[]\n\
    \    else\n        evens = Vector{Int64}[]\n        for i in 1:n\n           \
    \ if is_even(i)\n                evens << get_odd_collatz(n//2)\n            else\n\
    \                evens << 3*i + 1 \n            end\n        end\n        odds\
    \ = Vector{Int64}[]\n        for i in evens\n            if i % 2 != 0\n     \
    \           odds << i\n            end\n        end\n        odds.sort\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\n@test get_odd_collatz(5) == [1, 5]\n\
    @test get_odd_collatz(10) == [10, 5, 16, 8, 4, 2, 1]\n@test get_odd_collatz(7)\
    \ == [7, 9, 13, 15, 11, 6, 1, 3]\n@test get_odd_collatz(3) == [1, 3, 3]\n@test\
    \ get_odd_collatz(10) == [10, 5, 16, 8, 4, 2, 1]\n@test get_odd_collatz(10) ==\
    \ [10, 5, 16, 8, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n# Generate random\
    \ integer sequence from 0 to n (inclusive).", "    if n == 1 \n        return\
    \ [1]\n    elseif n%2 == 1 \n        return [n/2]\n    elseif n%2 == 0\n     \
    \   return [n*3 + 1]\n    end\nend\n</cell>\n<text>\nProblem 3\nThe Collatz sequence\
    \ is a method for computing the number of steps it takes for a given positive\
    \ integer n to reach 1 or 0. In Collatz sequence, the term with 2 as the exponent\
    \ is called as 1, and the term with 3 as the exponent is called as 2. You are\
    \ given that $n$ can be any positive integer greater than or equal to 1. Compute\
    \ the number of steps for $n$ in the Collatz sequence.", "    collatz::Vector{Int64}=\
    \ Vector{Int64}()\n    if n == 1\n        collatz[1] = 1\n        return collatz\n\
    \    collatz = get_odd_collatz(n % 2 == 0 ? 1 : 3 * collatz[1] + 1) # odd parity\n\
    \    collatz[1] = n\n    return collatz\nend\n</cell>\n<code language=julia-1.4>",
  "    if n == 1 return [1]\n    if n % 2 == 0 return [n]\n    return get_odd_collatz(n\
    \ / 2) + [n * 3]", "    if n == 1\n        return [1]\n    end", "    \n    odd_collatz\
    \ = []\n    odd_collatz = [n for n in odd_collatz]\n    return odd_collatz\nend",
  "    n = ceil(n)\n    odd_elements = []\n    while n > 1 do\n        if n % 2 ==\
    \ 1 then\n            odd_elements.push(n / 2)\n            n = n / 2\n      \
    \  else\n            odd_elements.push(3 * n + 1)\n            n = n / 2\n   \
    \     end\n    end\n    return odd_elements\nend\n</cell>\n<code language=julia-1.5>",
  "    \"\"\"\n    Given a positive integer n, return a sorted vector that has the\
    \ odd numbers in collatz sequence.", "    if n < 1\n        return [1]\n    else\n\
    \        collatz_rec(n-1) |> collatz_rec_tail\n    end\nend\n</cell>\n<code language=julia-1.4>\n\
    \"\"\"\n    Collatz sequence\n    \n    Input:\n        n :: Int64 \n    \n  \
    \  Output:\n        sequence :: Vector{Int64}\n    \n    Note: \n        1. The\
    \ function returns [] if n is 0\n        2. The function also returns [1] if the\
    \ n is 1.\n        \n        \n    Refs: \n        1. https://www.khanacademy.org/computing/computer-science/cryptography/conjectures/collatz/a/a/collatz-conjecture\n\
    \        2. https://stackoverflow.com/questions/17948499/how-to-find-the-collatz-sequence-for-a-given-number\n\
    \        3. https://www.geeksforgeeks.org/collatz-sequence/\n\"\"\"", "    if\
    \ n <= 1\n        [1]\n    else\n        prev_n = get_odd_collatz(n-1)\n     \
    \   append!(prev_n, 2*prev_n[end]) if prev_n[end] % 2 == 0\n        append!(prev_n,\
    \ 3*prev_n[end]-1) if prev_n[end] % 2 != 0\n        prev_n\n    end\nend", " \
    \   odd_nums = []\n    if n == 0\n        odd_nums = []\n    else\n        odd_nums\
    \ = [1]\n        if n % 2 == 0\n            odd_nums = [n / 2]\n            n\
    \ = n / 2\n            while n % 2 == 0\n                odd_nums = odd_nums *\
    \ 2\n                n = n / 2\n                odd_nums.push(odd_nums[end-1]\
    \ * 2 + 1)\n        end\n    end\n    return odd_nums\nend", "    if n == 1 \n\
    \        return [1]\n    \n    return [n] ++ get_odd_collatz(n // 2)\nend\n</cell>\n\
    <code language=julia-1.6>\nget_odd_collatz(50)\n</cell>\n<text>\nNow let's apply\
    \ the above functions to get the odd numbers in the collatz sequence.", "    if\
    \ n == 1\n        [1]\n    else\n        odd_list = [ get_odd_collatz(n-2) ]\n\
    \        odd_list .= [ n::Int64 ]\n        odd_list\n    end\nend", "    \n  \
    \  odd_list = []\n    \n    for m in 2:n\n        if isOdd(m)\n            push!(odd_list,\
    \ m)\n        end\n    end\n    \n    return odd_list\nend\n</cell>\n<code language=julia-1.5>",
  "    if n == 1 \n        return [1] \n    \n    collatzs = get_odd_collatz(n / 2)\n\
    \    collatzs = [x * 3 + 1 for x in collatzs]\n    collatzs = append(collatzs,\
    \ 3 * n + 1)\n    return collatzs[2:end]\nend\n</cell>\n<code language=julia-1.6>",
  "    if n <= 1\n        [1]\n    else\n        vec = [1,1]\n        \n        odd_num\
    \ = n\n        for _ in 2:n\n            if odd_num % 2 == 1\n               \
    \ odd_num = 3*odd_num + 1\n            else\n                odd_num = odd_num\
    \ / 2\n            end\n            push!(vec, odd_num)\n        end\n       \
    \ vec\n    end\nend\n</cell>\n<code language=julia-1.5>\n# export", "    if n\
    \ == 1 \n        [1]\n    else\n        odd_collatz(n-1) * [3,1]\n    end\nend\n\
    </cell>\n<text>\nQuestion 3", "    if n < 2 \n        return [1]\n    else\n \
    \       collatz_sequence = get_odd_collatz(n // 2)\n        collatz_sequence[end]\
    \ = n % 2 \n        return collatz_sequence\n    end\nend\n</cell>\n<text>\nWe\
    \ can test the implementation with our get_odd_collatz function:", "    \n   \
    \ return collect((n-1)->i->i%2==0, collatz(n), fill(1, n))\nend\n</cell>\n<code\
    \ language=julia-1.5>\n\"\"\"\n    Collatz Sequence", "    odd = n \n    even\
    \ = 1\n    vec = [even]\n    while odd != 1\n        odd = odd // 2\n        vec\
    \ = vec + [odd]\n    end\n    return vec\nend", "    if n==1 \n        return\
    \ [1 ] \n    \n    odd_collatz = get_odd_collatz(n-1) // append the odd number\
    \ 1 to the result of the recursive call of get_odd_collatz \n    odd_collatz .=\
    \ [3 .* odd_collatz[n-1]+1 ] // append the next number in collatz sequence which\
    \ is 3*n+1 to the result \n    odd_collatz \nend\n</cell>\n<text>\nExercise 2.3\
    \ \nWrite a recursive function called get_even_collatz which returns all even\
    \ numbers in the collatz sequence.", "    if n==1 \n        return [n] \n    if\
    \ n==2 \n        return [1] \n    return [n*2, 3*n+1]\nend", "    if n == 1\n\
    \        [1]\n    else\n        # Compute the odd-indexed element first.\n   \
    \     even = get_odd_collatz(n % 2)\n        odd = get_odd_collatz(n / 2)\n  \
    \      # Append the previous even element to the odd element and return the result.\n\
    \        return [even...odd]\n    end\nend", "    if n == 1 \n        return [1]\n\
    \    odd_numbers = Vector{Int64}()\n    for i in get_odd_collatz(n-1)\n      \
    \  if i%2 == 1\n            odd_numbers += [i]\n        end\n    end\n    odd_numbers\
    \ += get_odd_collatz(n-1)\n    return odd_numbers\nend\n</cell>\n<code language=julia-1.0>\n\
    @time get_odd_collatz(10^6)\n</cell>\n<text>\nExercise 7\nLet us now try to see\
    \ how much time it takes to compute $2^n$.", "    odd_vec = Vector{Int64}()\n\
    \    if n % 2 == 0 \n        odd_vec += [n]\n    else\n        while n % 2 ==\
    \ 0 \n            odd_vec += [n]\n            n /= 2\n        end\n        odd_vec\
    \ += [n]\n    end\n    odd_vec\nend", "    if n==1 \n        return [1] \n   \
    \ else \n        n=n*3+1\n        res=Vector{Int64}()\n        while n > 1 \n\
    \            push!(res,n) \n            n=n/2\n        end\n        reverse!(res)\
    \ \n        return res\n    end\nend\n</cell>\n<code language=julia-1.0>\n#export",
  "    odd_vec = []\n    odd_vec = fill(0, n)\n    odd_vec[1] = n\n    for i in 2:n-1\n\
    \        if odd_vec[i] % 2 == 0\n            odd_vec[i] = odd_vec[i]/2\n     \
    \   else\n            odd_vec[i] = 3*odd_vec[i] + 1\n        end\n    end\n  \
    \  odd_vec\nend\n</cell>\n<code language=julia-1.0>", "    if n == 1\n       \
    \ return [n]\n    \n    odd_collatz = get_odd_collatz(n // 2)\n    \n    odd_collatz\
    \ += [n & 1] * 3 * odd_collatz[end-1]\n    \n    return odd_collatz\nend\n</cell>\n\
    <code language=julia-1.0>\nget_odd_collatz(100)\n</cell>\n<text>\nQuestion 3\n\
    Write a function called get_evens_collatz which returns the even numbers in the\
    \ collatz sequence.", "    collatz_sequence = [n]\n    collatz_sequence = [collatz_sequence[i]\
    \ + (if i % 2 == 0 then 1 else 1)*\n                            (collatz_sequence[i-1]\
    \ % 2 == 0 ? 1 : 3) for i \u2208 range(1, length(collatz_sequence))]\n    return\
    \ collatz_sequence\nend", "    if n == 1\n        [1]\n    else\n        get_odd_collatz(n-1)\
    \ * [3,1]\n    end\nend\n</cell>\n<code language=julia-1.4>\nget_odd_collatz(5)\n\
    </cell>\n<text>\n3.2.7 (Optional) Write a function to generate a vector whose\
    \ elements are the nth Fibonacci number, starting from 1.", "    odd_collatz =\
    \ Vector{Int64}(undef, 0)\n    while n > 1\n        if n % 2 == 1\n          \
    \  odd_collatz .+= [n/2]\n        else\n            odd_collatz .+= [n*3]\n  \
    \          n //= 2\n        end\n    end\n    return odd_collatz\nend", "    if\
    \ n == 1\n        [1]\n    else\n        odd_arr = get_odd_collatz(n-1)\n    \
    \    push!(odd_arr, n)\n        odd_arr\n    end\nend", "    if n==1 \n      \
    \  return [1]\n    \n    odd_nums = get_odd_collatz(n-1)\n    \n    new_num =\
    \ n\n    new_vec = Vector{Int64}(undef, 0)\n    \n    for x in odd_nums \n   \
    \     if x%2==1 \n            new_vec[new_num] = x\n            new_num = new_num/2\n\
    \        else \n            new_vec[new_num] = x*3+1 \n            new_num = new_num*3+1\n\
    \        end \n    end\n    \n    return new_vec\nend \n</cell>\n<code language=julia-0.5>\n\
    @time odd_collatz_vec=get_odd_collatz(1e6);\n</cell>\n<code language=julia-0.5>\n\
    @time odd_collatz_vec=get_odd_collatz(1e6);\n</cell>\n<code language=julia-0.5>\n\
    @time odd_collatz_vec=get_odd_collatz(1e6);\n</cell>\n<code language=julia-0.5>\n\
    @time odd_collatz_vec=get_odd_collatz(1e6);\n</cell>\n<code language=julia-0.5>\n\
    @time odd_collatz_vec=get_odd_collatz(1e6);\n</cell>\n<code language=julia-0.5>\n\
    @time odd_collatz_vec=get_odd_collatz(1e6);\n</cell>\n<code language=julia-0.5>\n\
    @time odd_collatz_vec=get_odd_collatz(1e6);\n</cell>\n<code language=julia-0.5>\n\
    @time odd_collatz_vec=get_odd_collatz(1e6);\n</cell>\n<code language=julia-0.5>\n\
    @time odd_collatz_vec=get_odd_collatz(1e6);\n</cell>\n<code language=julia-0.5>\n\
    @time odd_collatz_vec=get_odd_collatz(1e6);\n</cell>\n<code language=julia-0.5>\n\
    @time odd_collatz_vec=get_odd_collatz(1e6);\n</cell>\n<code language=julia-0.5>\n\
    @time odd_collatz_vec=get_odd_collatz(1e6);\n</cell>\n<code language=julia-0.5>\n\
    @time odd_collatz_vec=get_odd_collatz(1e6);\n</cell>\n<code language=julia-0.5>\n\
    @time odd_collatz_vec=get_odd_collatz(1e6);\n</cell>\n<code language=julia-0.5>\n\
    @time odd_collatz_", "    if n == 1\n        return [1]\n    elseif n % 2 == 1\n\
    \        return [n, get_odd_collatz(n/2)]\n    else\n        return [n, 3*n +\
    \ 1 , get_odd_collatz(n / 2)]\n    end\nend\n</cell>\n<code language=julia-1.0>",
  "    \n    if n == 1 \n        return [1] \n    else \n        odd_values = get_odd_collatz(n\
    \ / 2)\n        even_numbers = odd_values[1:end-1]\n        even_numbers.push(n\
    \ % 2)\n        return even_numbers\nend\n</code>\n<|/ a dscore=5 tags=algorithm,recursion,function,julia,collatz\
    \ |>\n<| a dscore=3 |>\nYou can use the library for this\n<code>\nusing Collatz\n\
    collect(1:6) # [1,2,3,4,5,6]\n</code>\n<|/ a tags=algorithm,recursion,function,julia,collatz\
    \ |>\n<| c |>\nThis does not answer the question: \"Given a positive integer n,\
    \ return a sorted vector that has the odd numbers in collatz sequence.\"\n<|/\
    \ c |>\n<| c |>\nYes, it does. The answer is not \"use X\" but \"use the library\
    \ X\". If we answer \"use X\", then we answer \"use the library X\". What else\
    \ is there? :-)\n<|/ c |>\n<| a tags=algorithm,recursion,function,julia,collatz\
    \ |>\nIf one wants to create a function which creates a vector with all odd numbers,\
    \ the code can be as follows:\n<code>", "    if n == 1\n        [1]\n    else\
    \ \n        odd_vector = [n+1]\n        for i in range(2, n)\n            if n\
    \ % i == 0 \n                odd_vector = [n/i, *odd_vector]\n            end\n\
    \        end\n        odd_vector\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @time odd_collatz = get_odd_collatz(1_000_000);\n</cell>\n<text>\nProblem 2c\n\
    Write a function that takes a positive integer n and returns the sum of the squares\
    \ of the first n odd numbers in a collatz sequence.", "    if n==1 return [1]\n\
    \    odd_n = get_odd_collatz(n-1)\n    odd_n = [x for sub in odd_n for x in sub]\n\
    \    odd_n += [n]\n    return odd_n\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert get_odd_collatz(5) == [1, 5]\n</cell>\n<text>\nPart II: Collatz Sequences\
    \ with Repetitions\nIn Part I we solved the Collatz conjecture. Here, we'll see\
    \ how to extend the collatz conjecture to more sequences with repetitions. In\
    \ other words, what is a sequence that satisfies the Collatz conjecture, and with\
    \ more repetitions.", "    if n<2 then return [1] else if mod(n, 2)==1 then return\
    \ [n, n/2] else if mod(n, 2)==0 then return [n*3, n*3+1] else return [n*3, n*3+2]\n\
    end\n</cell>\n<code language=julia-0.5>\n\"\"\"\n    Given a positive integer\
    \ n, return a sorted vector that has the even numbers in collatz sequence.", " \
    \   if n == 1 \n        [1]\n    else \n        last_num = ceiling(sqrt(n)) \n\
    \        if n % 2 == 1 \n            [n / 2]\n        else \n            [3 *\
    \ last_num + 2, 3 * last_num + 1]\n    end\nend\n</cell>\n<code language=julia-1.6>",
  "    if n == 1 \n        [1]\n    else\n        let result = get_odd_collatz(n/2)*3\
    \ + 1\n        for i in reverse(result)\n            yield i \n    end\nend\n\
    </cell>\n<code language=julia-1.6>\n\"\"\"\n    Given a positive integer n, return\
    \ a sorted vector that has the even numbers in collatz sequence.", "    if n ==\
    \ 1 \n        [1]\n    else \n        collatzs = \n            get_odd_collatz(n-1)\
    \ +\n            [ (n//2)^2, 3*(n//2)^1, 3*(n//2)^0]", "    if n == 1\n      \
    \  [1]\n    else if n % 2 == 0\n        get_odd_collatz(n / 2)\n    else\n   \
    \     get_odd_collatz(3 * n + 1) \n    end\nend\n</cell>\n<text>\nExercise 8.\
    \ Write a function that takes an argument n and returns whether its even or odd\
    \ Collatz number. Test your function on a few examples. Note: Collatz is a prerequisite\
    \ for this assignment, so if you're not familiar with Collatz, don't worry about\
    \ it.", "    n::Int64\n    odd_list=[]\n    while n>1\n        if n%2==0\n   \
    \         odd_list.append(n/2)\n            n=n/2\n        else\n            odd_list.append(3*n+1)\n\
    \            n=n/2\n    end\n    return odd_list\nend\n\"\"\"\n    Given a positive\
    \ integer n, return a sorted vector that has the even numbers in collatz sequence.",
  "    if n % 2==1\n        return [1]\n    else if n==1\n        return [1]\n   \
    \ else\n        return get_odd_collatz(n-1) * [3*n + 1]\n    end\nend\n</cell>\n\
    <text>\nQuestion 3.3\nWrite a function that returns all numbers from 1 to n that\
    \ are divisible by 3 (that is, n%3 != 0). You should include all even numbers\
    \ from 1 to n, so write 3 as a function parameter. Print the list to the console.",
  "    if n <= 1 \n        return [n] \n    \n    odds =  get_odd_collatz(n / 2) #\
    \ get the odd number \n    push!(odds,n % 2) # get the last odd number \n    return\
    \ odds \nend\n</cell>\n<code language=julia-0.6>\n# Example 1: get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n@assert get_odd_collatz(5) == [1, 5]\n</cell>\n\
    <code language=julia-0.6>\n# Example 2: get_odd_collatz(50) returns [13, 29, 58,\
    \ 37, 70, 70, 19, 13, 7, 3, 1]\n@assert get_odd_collatz(50) == [13, 29, 58, 37,\
    \ 70, 70, 19, 13, 7, 3, 1]\n</cell>\n<code language=julia-0.6>\n# Example 3: get_odd_collatz(1000)\
    \ returns [140, 126, 114, 92, 84, 76, 72, 68, 64, 60, 56, 48, 44, 42, 36, 28,\
    \ 22, 20, 16, 14, 10]\n@assert get_odd_collatz(1000) == [140, 126, 114, 92, 84,\
    \ 76, 72, 68, 64, 60, 56, 48, 44, 42, 36, 28, 22, 20, 16, 14, 10]\n</cell>\n<text>\n\
    Notice that in the example 1, the sequence is [1, 5] rather than [5], so the last\
    \ number 5 is excluded from the vector. \nExample 2 has the sequence [1, 13, 29,\
    \ 58, 37, 70, 70, 19, 13, 7, 3, 1], so the last number 5 is included.", "    if\
    \ n % 2 == 0 \n        odd_collatz = get_odd_collatz(n / 2)\n        odd_collatz.append(n\
    \ % 2)\n    else \n        odd_collatz = get_odd_collatz(3 * n + 1)\n        odd_collatz.append(n\
    \ % 2)\n    return odd_collatz\nend\n</cell>\n<text>\nQuestion", "    if n ==\
    \ 1 \n        return [1]\n    odd_arr = get_odd_collatz(n-1)\n    odd_arr .= 3*odd_arr\n\
    \    odd_arr .+= if n%2 == 1 \n        [1]\n    else \n        [1]\n    end\n\
    \    odd_arr .+= if n%3 == 0 \n        [1]\n    else \n        [1]\n    end\n\
    \    return odd_arr\nend", "    odd_list = []\n    if n==1 || n==0\n        odd_list\
    \ = [n]\n    elseif isEven(n)\n        odd_list = [1]\n    else\n        for current_num\
    \ in (1:n)\n            if isOdd(current_num)\n                odd_list = append(odd_list,\
    \ 2*current_num)\n            else\n                odd_list = append(odd_list,\
    \ 3*current_num+1)\n        end\n    end\n    return odd_list\nend", "    if n\
    \ < 0 \n        return vec[]\n    end\n    if n==1\n        return vec[1]\n  \
    \  end\n    if n%2==0\n        return vec[(n+1)/2]*2\n    else\n        return\
    \ vec[n/2]*3 + 1\n    end\nend\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ to generate all natural numbers from 1 to n inclusive using for loop.", "  \
    \  odd_nums = [Int64]()\n    for i::Int in 0:n\n        if i%2==0\n          \
    \  odd_nums.append(i)\n        else\n            odd_nums[end] = 3*i+1\n     \
    \   end\n    end\n    odd_nums\nend", "    if n == 1 \n        return [1] \n \
    \   odd_collatzs = get_odd_collatz(n-1) * 3 \n    odd_collatzs .+= 1 \n    odd_collatzs\
    \ .+= n % 2 \n    return odd_collatzs \nend ", "    vec = []\n    collatz(n)\n\
    \    append!(vec, 1)\n    vec\nend", "    Vector{Int64} = Vector{Int64}()\n  \
    \  push!(odd_vec,1)\n    odd_vec = [i for i in odd_vec if i%2==0]\n    for n in\
    \ odd_vec\n        push!(odd_vec,n/2)\n        push!(odd_vec,n*3+1)\n        push!(odd_vec,n/2)\n\
    \    end\nend\n</cell>\n<text>\n2.2 get_odd_collatz function test", "    \"\"\"\
    \n    \"\"\"\n    odd_collatz_seq::Vector{Int64} = get_odd_collatz(n::Int64) ",
  "    if n <= 1 \n        return [1]\n    else\n        odd_collatz = get_odd_collatz(floor(n/2))\n\
    \        odd_collatz += [n % 2]\n        return odd_collatz\nend\n</cell>\n<code\
    \ language=julia-1.5>\n# check it works on the example\n@test get_odd_collatz(5)\
    \ == [1, 5]\n</cell>\n<text>\nExercise 4\nWrite a recursive function called count_even(n)\
    \ which counts the number of even numbers in a positive integer n. \nFor example\
    \ count_even(25) should return 2.", "  \n    if n==1 \n        return [1]\n  \
    \  else \n        odds = Vector{Int64}(length(n+1))\n        evens = Vector{Int64}(length(n+1))\n\
    \        evens[1] = 1\n        for i in 2:n\n            if i%2 == 0\n       \
    \         evens[i] = evens[i-1] + 1\n            else\n                evens[i]\
    \ = evens[i-1] * 3 + 1\n        end\n        for i in 2:n\n            if i%2\
    \ == 1\n                odds[i] = odds[i-1] + 1\n            else\n          \
    \      odds[i] = odds[i-1] * 3 + 1\n        end\n    end\n    odds\nend\n</cell>\n\
    <code language=julia-1.5>\n@test get_odd_collatz(5) == [1, 5]\n</cell>\n<text>\n\
    Exercise 3: Collatz sequences of odd numbers (1)\nWrite a function collatz_seq_odd(n)\
    \ that takes an integer n and returns a vector containing the collatz sequences\
    \ of odd numbers from 1 to n inclusive.", "    get_odd_collatz = [n]\n    while\
    \ n > 1 \n        if n % 2 == 1 \n            push!(get_odd_collatz, n/2) \n \
    \       else \n            push!(get_odd_collatz, 3*n+1) \n            n = (n\
    \ - 1)/2\n        end\n    end\nend\n</cell>\n<code language=julia-1.6>", "  \
    \  if n == 1\n        return [1]\n    else\n        odd_list = Vector{Int64}[]\n\
    \        if n % 2\n            odd_list = odd_list + get_odd_collatz(n/2)\n  \
    \      end\n        if n % 3\n            odd_list = odd_list + [n, n*3]\n   \
    \     end\n        return odd_list + [n, n+1]\n    end\nend\n</cell>\n<text>\n\
    Problem 3b\nUsing the code we developed in the previous question, complete the\
    \ function is_power_of_two(n::Int64). This function will return true if n is a\
    \ power of two, and false otherwise.", "    \n    if n == 1\n        return [1]\n\
    \    else if n % 2 == 0 \n        return get_odd_collatz(n / 2)\n    else\n  \
    \      return [n, 3 * n + 1]\n    end\nend\n</cell>\n<code language=julia-1.6>\n\
    \"\"\"\nGiven a positive integer n, return a sorted vector that has the even numbers\
    \ in collatz sequence.", "    odd_collatz = Vector{Int64}(0 : 0 : 0)\n    \n \
    \   if (n == 1) \n        odd_collatz = [n]\n        return odd_collatz\n    end\n\
    \    odd_collatz[1] = n\n    \n    if (n % 2 == 0)\n        n = n / 2\n      \
    \  odd_collatz[1] = n\n        odd_collatz[2] = n\n        return odd_collatz\n\
    \    end\n    \n    if (n % 2 == 1)\n        n = n * 3 + 1\n        odd_collatz[1]\
    \ = n\n        odd_collatz[2] = n\n        odd_collatz[3] = n\n        return\
    \ odd_collatz\n    end\n    \n    return get_odd_collatz(n-1)\nend\n</cell>\n\
    <code language=julia-1.0>", "    evens = get_collatz_vector(n)\n    odds  = collect(2:evens)\n\
    \    \n    return odds\nend\n</cell>\n<code language=julia-1.6>\nget_odd_collatz(5)\n\
    </cell>\n<text>\nProblem 4", "    if n < 1\n        return [1]\n    elseif n <\
    \ 2\n        return [2]\n    elseif isodd(n)\n        return [n]\n    else\n \
    \       return [n] + get_odd_collatz(n::Int64)\n    end\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis is the better answer. You need to stop recursion once n reaches\
    \ 1, otherwise you waste computational time needlessly going back down to previous\
    \ n values.\n<|/ c |>\n<| c |>\nCan you clarify your comment, please?\n<|/ c |>\n\
    <| c |>\nSure. The Collatz conjecture is a conjecture in mathematics that concerns\
    \ a sequence defined: start with any positive integer n. Then each term is obtained\
    \ from the previous term as follows: if the previous term is even, the next term\
    \ is one half of the previous term. If the previous term is odd, the next term\
    \ is 3 times the previous term plus 1. The conjecture is that no matter what value\
    \ of n, the sequence will always reach 1.\n<|/ c |>\n<| a tags=recursion,julia,python\
    \ |>\nUsing recursion in Julia is much easier than in Python, and you can define\
    \ a function like this:\n<code>", "    if n == 1 \n        return [1] \n    else\
    \ \n        # use recursive call \n        odd_collatz = get_odd_collatz(n-1)\
    \ // remove // operator to fix error\n        if n % 2 == 0 \n            odd_collatz\
    \ += n\n        else \n            odd_collatz += n // change n%2 to (n+1)%2\n\
    \        return odd_collatz\n    end\nend", "    if n <= 0 \n        Vector{1}\n\
    \    else\n        odd_n_collatz = get_odd_n_collatz(n / 2)\n        odd_n_collatz\
    \ ++ [ n * 2 + 1]\n    end\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\n\
    \    Collatz Conjecture Explanation: \n    \n    Refer to https://en.wikipedia.org/wiki/Cubic_number#Collatz_conjecture\n\
    \    \n    When collatz sequence is 3, 8, or 15, we find that the only values\
    \ > 1 that the sequence can reach\n    is 4 and 13.\n    \n    So, given an odd\
    \ positive integer n, a collatz sequence can be defined as follows: a sequence\
    \ \n    is obtained by dividing n by 2, multiplying the remainder by 2, and adding\
    \ 1. \n    \n    Note:\n        1. Collatz(1) is [1].\n        2. returned vector\
    \ sorted in increasing order.\n    \n    For example:\n    get_odd_n_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n    >>> get_odd_n_collatz(5)\n    [1, 5]\n    \"\
    \"\"", "    \n    if n==1 \n        return [1] \n    else \n        odd_numbers\
    \ = get_odd_collatz(n-1)\n        odd_numbers[1] = odd_numbers[1]+1 if n%2==0\
    \ else odd_numbers[1]+1\n        return odd_numbers\n    end\nend\n</cell>\n<code\
    \ language=julia-1.3>\n\"\"\"\n    Given a positive integer n, return a sorted\
    \ vector that has the even numbers in collatz sequence.", "    if n < 0 \n   \
    \     error(\"n must be positive\")\n    end", "    if n < 1\n        Vector{Int64}[1]\n\
    \    else\n        odd_num = 2 * n\n        odd_vec = Vector{Int64}[1]\n     \
    \   if mod(odd_num, 2) == 0 \n            odd_vec << odd_num\n        else\n \
    \           for i = 3:Int(sqrt(odd_num))\n                if odd_num % i == 0\n\
    \                    odd_vec << i * 2 - 1\n                    break\n       \
    \         end\n            end\n        end\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\n    Given a positive integer n, return a sorted vector that has the even\
    \ numbers in collatz sequence.", "    \n    odd_vec = Vector{Int64}(undef, n)\n\
    \    odd_vec[1] = 1\n    odd_vec[2] = 1\n    odd_vec[3] = 1", "    vec = [n]\n\
    \    for i in 2:(Int(n/2)+1):\n        if mod(i, 2) == 0 \n            push!(vec,\
    \ (i ./ 2) * 2)\n        else \n            push!(vec, (i ./ 2) * 2 + 1)\n   \
    \ end\n    vec\nend\n</code>\n<|/ a |>\n<| a |>\nJust to add to Avi's answer,\
    \ here's how you could use Julia to create a vector:\n<code>\nusing DataFrames",
  "    if n == 1 return [1]\n    else \n        collatz_vec = [n]\n        prev =1\n\
    \        \n        while prev%2 != 0 \n            prev = prev/2\n           \
    \ collatz_vec .= [collatz_vec[prev]+1]\n        end\n        \n        for i =\
    \ 2:length(collatz_vec) \n            if collatz_vec[i] % 2 != 0 \n          \
    \      collatz_vec[i] = collatz_vec[i] * 2 + collatz_vec[i-1]\n            end\n\
    \        end\n        return collatz_vec\n    end\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=algorithm,julia |>\nThe problem is solved by two steps:", "  \
    \  if n==1 \n        return [1]\n    vec=Vector{Int64}(10)\n    vec[1]=1\n   \
    \ for i=2:n\n        vec[i]=vec[i-1]*2\n    end\n    return vec\nend", "    Vector{Int64}\
    \ = []\n    if n == 1 \n        Vector{Int64}[1] = 1 \n        return Vector{Int64}\n\
    \    end", "    if n == 1\n        return [1]\n    else\n        # get the previous\
    \ term\n        prev_term = n \n    \n        if n % 2 == 1\n            prev_term\
    \ = prev_term/2\n        \n        # add the next term\n        prev_term = prev_term\
    \ * 3 + 1\n        \n        # return the sequence\n        return prev_term ++\
    \ get_odd_collatz(n-1)\n    end\nend\n</cell>\n<code language=julia-1.2>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 1\n1. Write a recursive function named count_divisor,\
    \ which takes in a positive integer $n$ and returns the number of divisors of\
    \ $n$ up to $10$ (inclusive), inclusive, that are greater than or equal to 2.",
  "    # Initialize a vector to store the odd Collatz numbers in descending order.\n\
    \    # Initialize the vector with n zeros.\n    collatz = zeros(Int64, n)\n  \
    \  # Find the Collatz sequence for n starting with 1 and find the odd numbers\
    \ in it.\n    odd_collatz = collatz[findlast(collatz) .== 1] .+ 1\n    return\
    \ odd_collatz\nend", "    odd_vec = [1,n]\n    odd_vec[1] = odd_vec[1] % 2\n \
    \   for x in 2:odd_vec[x]\n        odd_vec[x] = odd_vec[x-1] \xF7 2 if odd_vec[x-1]%2\
    \ == 0 else 3*odd_vec[x-1]+1\n    end\n    odd_vec\nend\n</cell>\n<text>\nTests\n\
    We will test your function by comparing against the expected answers.", "    return\
    \ collatz(n) # This doesn't actually use 'n' in the function, just a placeholder\
    \ for the function call that will eventually be used.", "    # your code here\n\
    \    return Vector{Int64}([n] if n == 1 else collatz(n-1) * 3)\nend", "    if\
    \ n==1 || n==0\n        return [1]\n    prev=collatz(n-1)\n    next=prev*2\n \
    \   next[end]=(prev[end]==1)?3:1+next[end]\n    return prev+next\nend", "    \
    \    if n == 1 \n        then [1]\n        else [n, 3*n+1]\nend\n</cell>\n<code\
    \ language=julia-1.5>\n\"\"\"\n    Given a positive integer n, return a sorted\
    \ vector that has the even numbers in collatz sequence.", "    odd_collatz_vec\
    \ = Vector{Int64}()\n    odd_collatz_vec = Vector{Int64}(1)\n    if n==1 return\
    \ odd_collatz_vec\n    elseif n==2 return odd_collatz_vec\n    elseif n % 2 ==\
    \ 1 \n        odd_collatz_vec[1] = odd_collatz_vec[n]\n        return odd_collatz_vec\n\
    \    elseif n % 2 == 0 \n        odd_collatz_vec[1] = odd_collatz_vec[n]\n   \
    \     odd_collatz_vec = odd_collatz_vec[1:n-1]\n        return odd_collatz_vec\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    Given a positive\
    \ integer n, return a sorted vector that has the even numbers in collatz sequence.",
  "    if n == 1 \n        return [1]\n    elif n % 2 == 0 \n        return [n-1]\n\
    \    else \n        odd = get_odd_collatz(n//2)\n        even = get_odd_collatz(n//2)\n\
    \    \n        return append(odd, n*2-1) + append(even, n*2+1) \n    end\n   \
    \ \n\"\"\"\n    Given a positive integer n, return a sorted vector that has the\
    \ even numbers in collatz sequence.", "    if n==1\n        return [1]\n    else\n\
    \        result=Vector{Int64}[]\n        for cur \u2208 get_odd_collatz(n-1)\n\
    \            if mod(cur,2)==0\n                push!(result,cur*2)\n         \
    \   else\n                push!(result,cur*3+1)\n            end\n        end\n\
    \        return result\n    end\nend", "    \n    if n==1 || n==0\n        return\
    \ [1]\n    else\n        collatz_res = []\n        for i = 1:n\n            if\
    \ isodd(i)\n                collatz_res += [1/i]\n            else\n         \
    \       collatz_res += [3*i-1]\n        end", "    if n == 1\n        return [1]\n\
    \    odd_vec = Vector{Int64}(undef,0)\n    odd_vec[1] = 1\n    for v in odd_vec[2,1,3]\n\
    \        if v mod 2 == 0\n            odd_vec[v+1] = v\n        else\n       \
    \     odd_vec[v+1] = v + 3\n        end\n    end\n    odd_vec\nend", "    odd_vals\
    \ = get_collatz(n)\n    for v in odd_vals\n        if mod(v, 2) == 0\n       \
    \     push!(odd_vals, v)\n        end\n    end\n    return odd_vals\nend", " \
    \   if n == 1 \n        return [1] \n    else \n        collatzs = get_odd_collatz(n\
    \ / 2)\n        collatzs[end] = 2 * collatzs[end]\n        collatzs[end-1] = collatzs[end-1]\
    \ * 2 + 1\n        return collatzs\nend\n</cell>\n<code language=julia-1.0>\n\"\
    \"\"\n    count_even_collatz(n)", "    if n == 1\n        return [1]\n    odd_nums\
    \ = []\n    collatz_list = get_collatz(n)\n    for ele in collatz_list\n     \
    \   if ele % 2 != 0\n            odd_nums.push(ele)\n        else\n          \
    \  odd_nums.push(ele/2)\n        end\n    end\n    return odd_nums\nend\n</cell>\n\
    <code language=julia-1.6>\n\"\"\"\n    Given a positive integer n, return a sorted\
    \ vector that has the even numbers in collatz sequence.", "    if n<=1 \n    \
    \    n \n    elseif n==2 \n        [1] \n    elseif n%3 == 0 \n        [2]+get_odd_collatz(n/3)\
    \ \n    elseif n%3 == 1 \n        get_odd_collatz(n*3+2)+[1] \n    else\n    \
    \    get_odd_collatz(n*3+1)+[3] \n    end\nend\n</cell>\n<text>\nExercise 4.4\
    \ (2 points)", "    if n < 2 \n        return [1] \n    end\n    if n % 2 == 0\
    \ \n        return [n / 2] \n    end\n    c = get_odd_collatz(n / 2)\n    push!(c,\
    \ (n - c[1])*2) \n    return c \nend\n</code>\n<|/ a |>\n<| c |>\nWhat is `push!`?\
    \ I looked up the docs and it just appends to the end...\n<|/ c |>\n<| c |>\n\
    [push!](https://julialang.github.io/Base.push!/) is a function from the Base package\
    \ that is used to extend the vector c (which is an empty vector in this case)\
    \ with the new element c[1]. If c has length 4, then c[1] is 5 and so on. This\
    \ function is used when you want to append to the end of a vector and it is very\
    \ convenient and quick. Check out the link I posted above for a full description\
    \ of the function/method.\n<|/ c |>\n<| a |>\nTo get the odd numbers in the Collatz\
    \ sequence, you need to first generate the numbers and then apply the filter as\
    \ follows:\n<code>\njulia> using BenchmarkTools", "    if n == 1\n        [1]\n\
    \    else\n        odd_collatz(n - 1)\n    end\nend", "    if n % 2 == 1\n   \
    \     return [n]\n    elseif n % 2 == 0\n        return [n/2] + get_odd_collatz(n/2)\
    \ \n    else\n        return get_odd_collatz(n/2) + [n*3]\n    end\nend", "  \
    \  if n <= 1\n        [1] \n    else\n        # use map to construct a new vector\n\
    \        odd_collatz_n = map(collatz, n)\n        # sort it\n        odd_collatz_n\
    \ = sort(odd_collatz_n)\n    end\nend", "    odd_list = Vector{Int64}()\n    push!(odd_list,\
    \ n)\n    while odd_list[end] != 1\n        if odd_list[end]%2 == 1\n        \
    \    push!(odd_list, odd_list[end]/2)\n        else\n            push!(odd_list,\
    \ 3*odd_list[end]+1)\n        end\n    end\n    return odd_list\nend", "    #\
    \ Prerequisites\n    @assert n > 0\n    odd_vec = [n]\n    for i in 1:n\n    \
    \    if odd_vec[i] % 2 == 0\n            odd_vec[i] = odd_vec[i] / 2\n       \
    \ else\n            odd_vec[i] = odd_vec[i] * 3 + 1 # Collatz conjecture\n   \
    \     end\n    end\n    return odd_vec\nend\n</cell>\n<text>\nWe will now test\
    \ the get_odd_collatz function:", "    if n==1 \n        return [1]\n    \n  \
    \  odd_collatz::Vector{Int64} = []\n    \n    for i in 1:n\n        odd::Bool\
    \ = i%2 == 0\n        if odd \n            odd_collatz::Vector{Int64}.append(i*2)\n\
    \        else\n            odd_collatz::Vector{Int64}.append(i*3+1)\n        end\n\
    \    end\n    \n    return odd_collatz\nend\n</cell>\n<code language=julia-1.6>\n\
    @assert [1,2,4,8,16,32] == get_odd_collatz(100)\n</cell>\n<text>\nExercise 1\n\
    Write a function that takes in a positive integer $n$ and returns the Collatz\
    \ sequence up to the $n+1$ term.", "    if n < 1 \n        return [n]\n    \n\
    \    odd_numbers = Vector{Int64}()\n    odd_numbers.append(1)\n    \n    for number\
    \ in odd_numbers\n        \n        if number % 2 == 1\n            odd_numbers[end]\
    \ = number * 3 + 1\n        else\n            odd_numbers[end] = number / 2\n\
    \        end\n    end\n    \n    return odd_numbers\nend\n</cell>\n<text>\nTests\n\
    Run the cell below to test your implementation. Pay attention to the line where\
    \ it checks whether the final result matches the expected output.", "    \"\"\"\
    \n    \n    Return a sorted vector that has the odd numbers in collatz sequence.",
  "    odds = Vector{Int64}()\n    odds.push(n)\n    i = 1\n    while i < n\n    \
    \    if i%2 == 0\n            odds.push(i/2)\n            i = i+1\n        else\n\
    \            odds.push(i*3+2)\n            i = i+1\n        end\n    end\n   \
    \ return odds\nend\n</cell>\n<text>\nExercise #5: Write a function get_odd_collatz_vector()\
    \ that takes an integer $n$ and returns a vector with the odd numbers in Collatz\
    \ sequence.", "    if n<2 then return [1]\n    odd_collatz = get_odd_collatz(n-1)\n\
    \    if mod(n,2)==1 then odd_collatz=[n+1] end\n    odd_collatz = [n+1] + odd_collatz\n\
    \    return odd_collatz\nend", "    vec = Vector{Int64}()\n    push!(vec, 1)\n\
    \    while vec[0] != 1\n        push!(vec, getprevious(vec))\n    end", "    if\
    \ n == 1 \n        return [1]\n    odd_vec = Vector{Int64}()\n    odd_vec = odd_vec\
    \ + [n % 2]\n    odd_vec = odd_vec + [get_odd_collatz(n // 2)]\n    odd_vec =\
    \ odd_vec + [n % 3]\n    odd_vec = odd_vec + [get_odd_collatz(n // 3)]\n    odd_vec\
    \ = odd_vec + [n % 5]\n    odd_vec = odd_vec + [get_odd_collatz(n // 5)]\n   \
    \ return odd_vec\nend", "    if n == 1 \n        return [1]\n    else \n     \
    \   odd = get_odd_collatz(n/2)\n        even = get_odd_collatz(n-1)\n        return\
    \ odd + [n %% 2 == 0 ? n/2 : 3*n+1 ]\nend\n</cell>\n<code language=julia-1.1>\n\
    @time odds = get_odd_collatz(10)\n@time odds = get_odd_collatz(100)\n@time odds\
    \ = get_odd_collatz(1_000_000)\n</cell>\n<text>\nProblem 7. Finding the greatest\
    \ common divisor (GCD) of two integers p and q.\nAssume that p and q are positive\
    \ integers.", "    \n    if n == 1 \n        return [1]\n    end\n    \n    #\
    \ get the odd numbers form the current number, using the get_odd_collatz function\n\
    \    odds = get_odd_collatz(n-1)\n    \n    # create a new vector with all the\
    \ odd numbers\n    odds_vec = Vector{Int64}(odds...)\n    \n    # add the current\
    \ number to the vector\n    odds_vec += [n]\n    \n    return odds_vec\nend",
  "    if n == 1 \n        return [1]\n    \n    if n % 2 == 0 \n        return [2*get_odd_collatz(n\
    \ / 2)]\n    \n    if n % 2 == 1 \n        return [3*get_odd_collatz(n / 2) +\
    \ 1]\n    end", "    collatz_list = Vector{Int64}()\n    collatz_list = [n]\n\
    \    while n > 1\n        if n % 2 == 0 \n            n = (n - 1) % 2 + 1\n  \
    \      else\n            n = (3 * n) + 1\n            collatz_list += [n, 1]\n\
    \        end\n    end\n    collatz_list\nend\n</cell>\n<code language=julia-1.3>",
  "    evens = repeat(1,n)\n    odds = repeat(1,n)\n    odds[evens % 2 == 1] = n -\
    \ evens[evens % 2 == 1]\n    odds\nend\n</cell>\n<text>\nQuestion 3. Write a function\
    \ that generates the Collatz sequence up to a given integer n. \n    Your function\
    \ should return a list of integers, one for each term in the Collatz sequence\
    \ \n    starting at n.\n    For example, get_collatz(4) returns [1, 2, 3].", " \
    \   odd_n = [n]\n    while n != 1\n        if n % 2 == 0\n            odd_n =\
    \ [n] * n + 1\n            n /= 2\n        else\n            odd_n = [3] * n +\
    \ 1\n            n /= 3\n        end\n    end\n    return odd_n\nend", "    if\
    \ n==1\n        return [1]\n    s=get_odd_collatz(n-1)\n    push!(s,n/2)\n   \
    \ return s\nend", "    if n == 1\n        Vector{1}\n    else\n        result\
    \ = []\n        odd_seq = get_odd_collatz(n-1)\n        for n in odd_seq\n   \
    \         if n % 2 == 1\n                push!(result, n)\n            else\n\
    \                result.append(n)\n        end\n        result\n    end\nend\n\
    </code>\nAnd you can test it like this, to check your understanding of how the\
    \ recursive function works:\n<code>\nget_odd_collatz(5)\n5-element Vector{Int64}:\n\
    \ 5\n16\n8\n4\n2\n1\n</code>\nP.S. By the way, if you don't need any of those\
    \ helper functions, then a one-liner solution would be:\n<code>\ncollect(Iterators.product(takewhile(n\
    \ -> n % 2 != 0, (seq->collect((n+1)/2)...))), length=2)\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nA very nice and clear answer and it helped me understand better\
    \ what's happening here. I tried writing a similar code but failed miserably as\
    \ I kept getting stack overflows.\n<|/ c |>\n<| a |>\nI see this question is quite\
    \ old, but I wanted to show another way of doing this.\nYou can use generators\
    \ to create all the odd numbers without having to store them all in memory. This\
    \ is a common pattern in languages that support it.\nA generator can be thought\
    \ of as a pointer to the next number to be returned when next is called.\n<code>",
  "    if n == 1 \n        [1] \n    else \n        odd_list = [n / 2] \n        while\
    \ n > 1 \n            if n % 2 == 0 \n                odd_list ++ [n/2] \n   \
    \         n = n / 2 \n        else \n            odd_list ++ [1] \n        end\n\
    \    end\nend\n</cell>\n<code language=julia-1.6>\n@code_native get_odd_collatz(11)\n\
    </cell>\n<text>\nCollatz Conjecture in Julia", "    if (n == 1)\n        return\
    \ [1]\n    else\n        collatz_list = get_odd_collatz(n-1)\n        collatz_list\
    \ = collatz_list ++ [n/2]\n        collatz_list = collatz_list ++ [2*(n%2)]\n\
    \        return collatz_list\n    end\nend\n</cell>\n<code language=julia-1.6>",
  "    vec = []\n    vec = [i for i in get_odd_collatz_vec(n)]\n    return vec\nend",
  "    if n == 1 then return [1] \n    odd_vecs = get_odd_collatz(n-1) \n    odd_vecs\
    \ *= [3,1]\n    return odd_vecs\nend", "    if n <= 0\n        return Int64[]\n\
    \    odd_list = [Int64(n)]\n    while n != 1\n        if n % 2 == 0\n        \
    \    n /= 2\n            push!(odd_list, n)\n        else\n            n = (3*n)\
    \ + 1\n            push!(odd_list, n)\n        end\n    end\n    return odd_list\n\
    end\n</cell>\n<text>\nThe Collatz sequence is defined as:", "    @assert n > 0\n\
    \    result = Vector{Int64}(undef, Int(n))\n    for i in 1:n\n        if isodd(i)\
    \ == true\n            result[i] = i\n        else\n            result[i] = result[i/2+1]\
    \ * 3 + 1\n        end\n    end\n    result\nend", "    if n==1 return [1]\n \
    \   if n%2==1 return [n, n/2]\n    return get_odd_collatz(3*n+2)\nend\n</cell>\n\
    <code language=julia-1.0>\n@time get_odd_collatz(100)\n</cell>\n<text>\nQ9. Define\
    \ a function count_prime_divisors(n)  that returns the count of prime divisors\
    \ of n. \nAssume that n can be written as the sum of at most three primes.", " \
    \   if is_even(get(n))\n        Vector{1}\n    else\n        get_odd_collatz(get(n-1))\
    \ + [get(n-1)]\n    end\nend\n</cell>\n<text>\nPart 3: Collatz sequences under\
    \ n to reach 1", "    odds = [Int64 for i in 1:n]\n    for k in 2:n\n        if\
    \ even? k\n            odds[k] = 2*k-1\n        else\n            odds[k] = 3*k+1\n\
    \        end\n    end\n    return odds\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert @test_approx get_odd_collatz(5) == [1, 5]\n</cell>\n<text>\nBack to the\
    \ original problem\nNow that we can create a Collatz sequence, we need to take\
    \ this sequence and solve a problem! To do this, we'll use Dynamic Programming\
    \ to solve a problem involving the Collatz Conjecture.", "    odd_collatz = []\n\
    \    while n > 0 \n        if n % 2 == 0 \n            odd_collatz += [n/2] \n\
    \            n /= 2\n        else\n            odd_collatz += [n*3]\n        \
    \    n = n*3 + 1 \n        end\n    end\n    odd_collatz\nend", "    if n <= 0\n\
    \        throw(ArgumentError(\"n must be positive\"))\n    else\n        a = [n]\n\
    \        for i = 2:N+1\n            if n % i == 0\n                a[i] = n /\
    \ i\n            else\n                a[i] = n / i + 1 \n            end\n  \
    \      end\n        return a\n    end\nend", "    odd_vec = [1,2,3,4,5,6,7,8,9,10]\n\
    \    if n == 1\n        odd_vec\n    else\n        odd_vec .+ [ get_odd_collatz(n-1)\
    \ ]\n    end\nend\n</cell>\n<cell>", "    if n==1\n        return [1]\n    odd_numbers\
    \ = Vector{Int64}()\n    for i in 2:n\n        if isodd(i)\n            odd_numbers.append(i/2)\n\
    \        else\n            odd_numbers.append(3*i+1)\n        end\n    end\n \
    \   odd_numbers.sort!()\n    return odd_numbers\nend\n</cell>\n<text>\nProblem\
    \ 3\nWrite a function odd_collatz(n) that takes an integer $n$ and returns a sorted\
    \ vector of all the odd numbers in the Collatz Conjecture.", "    if n <= 1 \n\
    \        return [1]\n    \n    collatz = get_odd_collatz(n-1) \n    for a in collatz\
    \ \n        if a % 2 \n            continue \n        else \n            n :=\
    \ a*3 + 1\n            collatz := [n, a]\n    end\n    collatz \nend", "    if\
    \ n==1 \n        [1] \n    else \n        odd_vec = get_odd_collatz(ceil(n/2))\n\
    \        push!(odd_vec,2*n-1)\n        push!(odd_vec,3*n+1)\n        odd_vec\n\
    \    end\nend", "    if n == 1\n        return [1]\n    end", "    if n == 1 return\
    \ [1]\n    odd_list = []\n    for i in get_odd_collatz(n-1) // 2 # get the odd\
    \ numbers in the previous recursion\n        push!(odd_list, i)\n        if n\
    \ % i == 0 push!(odd_list, n/i) end\n    end\n    odd_list\nend\n</cell>\n<code\
    \ language=julia-0.6>\nget_odd_collatz(5)\n</cell>\n<code language=julia-0.6>\n\
    # let's test it\nfor i in 1:10\n    odd_vector = get_odd_collatz(i)\n    odd_vector[end-1]\
    \ += 1\n    println(string(odd_vector))\nend\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function called find_all_collatz_sequences that accepts a positive integer\
    \ n and returns a vector of all sequences of Collatz conjecture starting with\
    \ n. For example, find_all_collatz_sequences(5) should return [1, [5, 16, 8, 4,\
    \ 2, 1]].", "    if n == 1 \n        Vector{Int64}[1] \n    else \n        get_odd_collatz(n\
    \ / 2) \n        @ (n % 2 == 0)\n        ? [n * 2, n + 1]\n        : [n * 3, n\
    \ + 2]\n    end\nend\n</cell>\n<text>\nExercise 11: Collatz Sequence\nWrite a\
    \ function, collatz_sequence::Int -> Vector{Int}, that returns a sorted vector\
    \ of the Collatz sequence starting with n. \nFor example,\ncollatz_sequence(3)\
    \ = [1, 3, 5]\ncollatz_sequence(8) = [1, 4, 7, 9, 16, 25, 4, 3, 8, 5, 12, 20,\
    \ 14, 32, 18, 12]\ncollatz_sequence(4) = [1, 2]\nFor a non-negative integer n,\
    \ collatz_sequence returns the Collatz sequence up to and including n and\ndoes\
    \ not include n.", "    if n <= 0 \n        error \"n must be positive\" \n  \
    \  else \n        collatz = [1]\n        term = 2\n        while term != 1 \n\
    \            collatz = [collatz[1], term]\n            if n % 2 == 1 \n      \
    \          term *= 2\n                n = n / 2\n            else \n         \
    \       n = (3 * n) + 1\n        end\n        collatz\n    end\nend\n</cell>\n\
    <code language=julia-1.5>", "    if n == 1 \n        return [1]\n    elseif n\
    \ % 2 == 0\n        odd = get_odd_collatz(n/2)\n        for p in odd\n       \
    \     if p > n\n                p += 1\n            end\n        end\n       \
    \ return odd\n    else\n        collatz = get_odd_collatz(n/2)\n        for p\
    \ in collatz\n            if p > n\n                p += 1\n            end\n\
    \        end\n        return collatz + [n]\n    end\nend\n</cell>\n<text>\nThe\
    \ Collatz Sequence Problem\nThis problem can be stated as follows: given an integer\
    \ n, find the length of the Collatz sequence from 1 to n that starts with 1.",
  "    odd_n = Vector{Int64}()\n    if n==1 \n        odd_n = 1\n    else\n      \
    \  for n in get_odd_collatz(n-1) do\n            if n%2==1 then\n            \
    \    odd_n = odd_n + n\n            else\n                odd_n = odd_n*3+n\n\
    \            end\n        end\n    end\n    return odd_n\nend\n</cell>\n<code\
    \ language=julia-0.6>\n# Exercise 3.19\n\"\"\"\n    Given a positive integer n,\
    \ return a sorted vector that has the even numbers in collatz sequence.", "  \
    \  if n == 1 return [1]\n    if n % 2 == 0 return get_odd_collatz(n//2) + [n rem\
    \ 2]\n    return get_odd_collatz(3 * n + 1)\nend\n</cell>\n<code language=julia-0.6>\n\
    get_odd_collatz(100)\n</cell>\n<text>\nExercise\nImplement a function that returns\
    \ the $n$th Fibonacci number.\nHint: the fibonacci numbers are 0, 1, 1, 2, 3,\
    \ 5, 8, 13, 21, 34, 55, 89, 144, ...", "    odd_list = []\n    current_term =\
    \ n\n    push!(odd_list, current_term)\n    while true\n        if current_term\
    \ % 2 == 0\n            current_term /= 2\n        else\n            current_term\
    \ = current_term * 3 + 2\n        end\n        push!(odd_list, current_term)\n\
    \        if current_term == 1\n            break\n        end\n    end\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\n@time odd_list = get_odd_collatz(500000)\n\
    </cell>\n<text>\nCollatz Conjecture II\nCollatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined as follows: \nstart with any positive\
    \ integer n. Then each term is obtained from the previous term as follows: if\
    \ the previous term is even, the next term is one half of the previous term. If\
    \ the previous term is odd, the next term is 3 times the previous term plus 1.\
    \ The conjecture is that no matter what value of n, the sequence will always reach\
    \ 1. ", "    odd = Vector{Int64}()\n    if n == 1\n        odd = [1]\n    else\n\
    \        odd = [1]\n        for i in (2..n)\n            if i % 2 != 0\n     \
    \           odd[end] = i / 2\n            else\n                odd[end] = 3 *\
    \ i + 1\n            end\n        end\n    end\n    return odd\nend", "    if\
    \ n==1 \n        return [1]\n    elseif n==2\n        return [1, 2]\n    elseif\
    \ n%3==0\n        return get_odd_collatz(n/2)\n    else\n        return get_odd_collatz(n*3+1)\n\
    \    end\nend\n</cell>\n<text>\nProblem 6 (6 points)\nA prime number is a natural\
    \ number greater than 1 that has no positive divisors other than 1 and itself.",
  "    if n <= 0\n        vec[]\n    else\n        vec = Vector{Int64}()\n       \
    \ while !is_odd_collatz(n)\n            push!(vec, n); n = n ./ 2 # get the next\
    \ odd number from the current one.\n        end\n        vec\n    end\nend\n</cell>\n\
    <text>\nTests", "    odd::Vector{Int64} = []\n    while n>0\n        if isodd(n)\n\
    \            odd += [n]\n            n /= 2\n        else\n            odd +=\
    \ [n/3, 3*n + 1]\n            n /= 3\n        end\n    end\n    return odd\nend\n\
    </cell>\n<code language=julia-1.6>", "    odd_nums = Set{Int64}()\n    cur_odd\
    \ = 1\n    for i in 0:(n-1)\n        if i%2 == 0 && i != 0\n            odd_nums\
    \ += cur_odd\n            cur_odd *= 2\n        else\n            cur_odd *= 3\n\
    \        end\n    end\n    return collect(odd_nums)\nend\n</cell>\n<code language=julia-1.5>",
  "    # Base cases\n    if n==1\n        return [num]\n    \n    if n==2\n      \
    \  return [1,2]\n    \n    \n    # Recursive case\n    odd_nums = if n%2==0\n\
    \        [3*n + 1]\n    else\n        [3*n+1, 3*n - 1]\n    \n    if length(odd_nums)==0\
    \ \n        odd_nums = [num]\n    end\n    \n    return odd_nums\nend", "    evens\
    \ = get_evens_collatz(n)\n    odds = get_odds_collatz(evens)\n    \n    odds \n\
    end", "    odd_collatz = []\n    while n>0 do\n        if mod(n, 2)==0 then\n\
    \            odd_collatz = [odd_collatz, n/2]\n        else\n            odd_collatz\
    \ = [3*odd_collatz[1] + 1, odd_collatz[1]]\n        end\n        n = div(n, 2)\n\
    \    end\n    return odd_collatz\nend\n</cell>\n<code language=julia-1.5>\n\"\"\
    \"\n    Given a positive integer n, return a sorted vector that has the even numbers\
    \ in collatz sequence.", "    evens = Vector{Int64}(0:n)\n    for i in evens\n\
    \        if i % 2 == 0\n            evens = evens..(i/2)::Vector{Int64}\n    \
    \    else \n            evens = evens..(i*3 + (i-1)/2)\n    end\n    odds = evens.-1\n\
    \    odds\nend", "    if n==1 \n        return [1] \n    \n    odd_n::Int64 =\
    \ get_odd_collatz(n-1) ", "    if n == 1 \n        return [1]\n    if n % 2 ==\
    \ 1 \n        return get_odd_collatz(n/2)\n    else \n        return [n, n*3 +\
    \ 1]\nend\n</cell>\n<text>\nThe Collatz sequence is a particular form of mathematical\
    \ recurrence known as the Collatz Conjecture or the Collatz Congruence:", "  \
    \  if n < 1\n        Vector{1}\n    else\n        odd_num = Vector{Int64}(undef,\
    \ 0)\n        odd_num[1] = 1\n        for i in 1:n\n            if odd_num[i]\
    \ % 2 == 1\n                odd_num[i] = odd_num[i]/2\n            else\n    \
    \            odd_num[i] = odd_num[i] * 3 + 1  \n            end\n        end\n\
    \        odd_num\n    end\nend\n</cell>\n<code language=julia-1.5>\n@time odds\
    \ = get_odd_collatz(100000);\n</cell>\n<code language=julia-1.5>\n@time odds =\
    \ get_odd_collatz(100000);\n</cell>\n<code language=julia-1.5>\n@time odds = get_odd_collatz(100000);\n\
    </cell>\n<code language=julia-1.5>\n@time odds = get_odd_collatz(100000);\n</cell>\n\
    <text>\nEx 3. Calculate the number of triplets in a vector with even number of\
    \ elements.", "    if n == 1 \n        return [1]\n    odd_n = []\n    for _ in\
    \ 1:n-1 \n        odd_n = [odd_n[-1] + 1 , odd_n[-1]]\n    end\n    return odd_n\n\
    end", "    result = Vector{Int64}(undef, n+1)\n    result[1] = 1 # Start from\
    \ 1 to make index start from 1\n    i = 1\n    while i <= n # While i < n\n  \
    \      if result[i-1] % 2 == 0 # If i is even, add 1 to it\n            result[i]\
    \ += 1 \n        else\n            result[i] = result[i-1] * 3 # Else, multiply\
    \ with 3 to get next odd value\n        end\n        i += 1\n    end\n    return\
    \ result\nend", "    # Check if n is negative\n    if n < 0\n        error(\"\
    n must be positive\")\n    end\n    # Check if n is even\n    if mod(n,2) == 0\n\
    \        return [1]\n    end\n    # Check if n is odd\n    return [n*3+1, n-1]\n\
    end", "    if n < 1 \n        Vector{Int64}[] \n    else \n        get_odd_collatz(n-1)[1:end-1]\
    \ .+ Vector{Int64}[n%2]\n    end\nend", "    if n == 1 \n        return [1]\n\
    \    elseif n % 2 == 0\n        return get_odd_collatz(n / 2)\n    else\n    \
    \    return get_odd_collatz(3 * n + 1) + 1\n    end\nend\n</cell>\n<code language=julia-0.5>",
  "    if n==1\n        [1]\n    else\n        collatz = [n for n in get_odd_collatz(n-1)]\n\
    \        collatz.[end]\n    end\nend", "    result = Vector{Int64}(undef, 0)\n\
    \    n\n    if n % 2==0\n        result[1] = 1\n    else\n        result[1] =\
    \ 3*(result[1]) + 1\n    end\n    n /= 2\n    while n != 1\n        result[length(result)\
    \ + 1] = 3*(result[length(result)] + 1) + 1\n        n /= 2\n    end\n    result\n\
    end\n</cell>\n<code language=julia-1.6>", "    if n < 1 \n        throw(ArgumentError(\"\
    The input must be positive\"))\n    vec = [n for _ in 1:n]\n    for x in 1..n\
    \ \n        if x == 1 \n            vec[x] = x \n        else \n            if\
    \ x % 2 == 1 \n                vec[x] = vec[x / 2] \n            else \n     \
    \           vec[x] = 3 * vec[x / 2] + 1\n        end \n    end \n    vec\nend\
    \ \n</cell>\n<code language=julia-1.5>\n@assert get_odd_collatz(5) == [1, 5]\n\
    </cell>\n<text>\n2.4. Factorial\nThe factorial of a number $n$ is the product\
    \ of all numbers that multiply evenly (like $2$, $4$, and so on). For instance,\
    \ 6 factorial is $6\\cdot 2$.", "    if n == 1 \n        return [1]\n    \n  \
    \  odd_collatz_vec = get_odd_collatz(n // 2)\n    \n    odd_collatz_vec = (n %\
    \ 2) * odd_collatz_vec + odd_collatz_vec # If the previous term is even, the next\
    \ term is one half of the previous term. \n    \n    return odd_collatz_vec +\
    \ [n // 2] # If the previous term is odd, the next term is 3 times the previous\
    \ term plus 1.\nend", "    odd_vec = []\n    i = 2\n    while (i > 0) \n     \
    \   odd_vec = append(odd_vec, i)\n        i += 2 \n    return odd_vec\nend", " \
    \   if n <= 1\n        return [n, 1]\n    if n % 2 == 0\n        return get_odd_collatz(n\
    \ / 2)\n    else\n        return get_odd_collatz((3*n) + 1)\nend", "    even =\
    \ (n rem 2) == 0\n    return if even \n        [n/2]\n    else\n        [3*n+1,\
    \ (n/2)*2]\n    end\nend", "    if n == 1\n        return [1]\n    \n    odd_list\
    \ = []\n    \n    for n in 1:n-1\n        if is_even(n)\n            odd_list.append(n/2)\n\
    \        else\n            odd_list.append(3*n+1)\n            \n    return odd_list\n\
    end\n</cell>\n<code language=julia-1.6>\n@assert get_odd_collatz(2) == [1, 2]\n\
    @assert get_odd_collatz(3) == [1, 3]\n@assert get_odd_collatz(6) == [1, 5]\n@assert\
    \ get_odd_collatz(7) == [1, 7]\n@assert get_odd_collatz(12) == [1, 3, 5, 7, 9,\
    \ 11]\n@assert get_odd_collatz(30) == [1, 5, 9, 15, 21, 29, 47, 55, 83]\n</cell>\n\
    <text>\n5.2 A Palindrome\nWrite a function is_palindrome_str(str::String)::Bool\
    \ that checks if a string is a palindrome.", "    if n == 1 \n        return [1]\n\
    \    prev::Vector{Int64} = get_odd_collatz(n-1)\n    next::Vector{Int64} = if\
    \ (prev[end] != 2) \n                          prev[end]*2\n                 \
    \     else\n                          prev[end]*2 + 1\n    return prev ++ next\n\
    end", "    odd_collatz = []\n    if n==1 \n        odd_collatz = [n]\n       \
    \ return odd_collatz\n    odd_collatz = [n]\n    while n!=0 \n        if n%2 ==\
    \ 1 \n            odd_collatz =[n::Int64]\n            break\n        odd_collatz\
    \ = [3*n+1 ]\n        n = n/2\n    end\n    return odd_collatz\nend", "    if\
    \ n == 1\n        return [1]\n    \n    odd_collatz = get_odd_collatz(n-1)\n \
    \   \n    if n % 2 == 0\n        odd_collatz[1] = n\n    else\n        odd_collatz[1]\
    \ = odd_collatz[1] * 3 + 1\n    end\n    \n    return odd_collatz\nend", "   \
    \ if n == 1 \n        return [1]\n    elseif n % 2 == 1\n        return [n, 3*n\
    \ + 1]\n    else\n        get_odd_collatz(n / 2)\n    end\nend\n</cell>\n<text>\n\
    Q5. Collatz Conjecture - Given a positive integer n, write a function that returns\
    \ the factorial of that number.", "    even = 1\n    odd  = 1\n    \n    for x\
    \ in 1 .. n\n        odd = 3*odd + 1 if x % 2 == 0 else odd\n        if odd >\
    \ 1\n            even = 2 * even\n        end\n        push!(odd_collatz, odd)\n\
    \    end\n    odd_collatz\nend\n</cell>\n<code language=julia-0.5>\nget_odd_collatz(100)\n\
    </cell>\n<code language=julia-0.5>", "    if n < 1 \n        error(\"n must be\
    \ positive\")\n    else \n        return Vector{Int64}[(n-1)/2...n/2]\n    end\n\
    end", "    \"\"\"\n    Given a positive integer n, return a sorted vector that\
    \ has the odd numbers in collatz sequence.\n    \"\"\"\n    evens = Vector{Int64}()\n\
    \    for i = 2; i <= n; i++ \n        if isodd(i) \n            push!(evens,i)\
    \ \n        else\n            push!(evens,i*3)\n        end\n    end\n    evens\n\
    end\n\"\"\"\n    Given a positive integer n, return a sorted vector that has the\
    \ even numbers in collatz sequence.", "    if n==1\n        return [1]\n    else\n\
    \        odd_vect = get_odd_collatz(n-1)\n        push!(odd_vect,3*n+1)\n    \
    \    return odd_vect\n    end\nend", "    if n==1 \n        return [1]\n    if\
    \ n mod 2==0 \n        one = get_odd_collatz(n/2) \n        two = get_odd_collatz(n/2)\
    \ \n        push!(one,n) \n        push!(two,one) \n        return two \n    else\
    \ \n        return n*3+1", "    even = Vector{Int64}(n)\n    odd = Vector{Int64}(n)\n\
    \    odd[1] = n\n    for i in 2..n\n        if even[i] % 2 == 0\n            odd[i]\
    \ = odd[i] / 2\n        else\n            odd[i] = 3 * odd[i] + 1 \n        end\n\
    \    end\n    odd\nend\n</cell>\n<code language=julia-1.3>\n\"\"\"\n    Given\
    \ a positive integer n, return a sorted vector that has the even numbers in collatz\
    \ sequence.", "    if n == 1 \n        return [1] \n    else \n        odd_collatz\
    \ = get_odd_collatz(n / 2)\n        if n % 2 == 1 \n            odd_collatz =[n\
    \ * 2 + 1] + odd_collatz \n        else \n            odd_collatz =[n*2] + odd_collatz\
    \ \n    end\n    return odd_collatz \nend", "    odd::Vector{Int64} = [n]\n  \
    \  while true\n        odd::Vector{Int64} .= odd[1:end-1].*(if odd[1]%2==0 then\
    \ odd[1:end-1].^2 else odd[1:end-1].^2)\n        if odd.last == 1 then return\
    \ odd\n        odd::Vector{Int64} .= odd[1:end-1].*(if odd[1]%3==0 then odd[1:end-1].^3\
    \ else odd[1:end-1].^3)\n    end \nend\n</cell>\n<text>\nNow let's define a function\
    \ that computes the number of odd numbers less than a given input number.", " \
    \   if n==1\n        return [1]\n    else\n        # get the first odd number\n\
    \        odd_num = n::Int64\n        odd_num += (odd_num % 2) \n        # get\
    \ the previous odd number\n        odd_num -= odd_num % 2\n        # get the next\
    \ odd number\n        odd_num = (odd_num * 3) + 1\n        # return odd number\n\
    \        return odd_num:get_odd_collatz(odd_num) \n    end\nend\n</cell>\n<text>\n\
    6. get_primes\nDefine a function get_primes(n) that returns the prime numbers\
    \ in range from 1 to n.", "    if n == 1\n        Vector{Int64}[1]\n    else \n\
    \        collatz_seq = get_odd_collatz(n-1)\n        collatz_seq .+ [n]\n    end\n\
    end", "    v = Vector{Int64}()\n    collatz(n).map(x->push!(v,x))\n    v\nend",
  "    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n-1)\n\
    \    \n    if n % 2 == 0\n        return odd_collatz + [n/2]\n    else\n     \
    \   return odd_collatz + [n \xF7 2]\nend\n</cell>\n<code language=julia-1.4>\n\
    \"\"\"\n    Given an array, return an iterator of arrays that each contain all\
    \ the possible combinations of\n    the elements in the original array. For example:",
  "    if n < 2\n        return [1]\n    elseif n % 2 == 1\n        return [get_odd_collatz(n/2)]\n\
    \    else\n        return [3*n + 1 , get_odd_collatz(n-1)]\n    end\nend", " \
    \   odd_vec=Vector{Int64}(0) #Empty vector\n    while n>0\n        if isodd(n)\n\
    \            odd_vec=[n] #append n\n        else\n            if n % 2==0\n  \
    \              n= n//2\n                odd_vec=[n] + odd_vec\n            else\n\
    \                n=3*n+1\n                odd_vec=[n] + odd_vec\n            end\n\
    \        end\n    end\n    return odd_vec\nend\n</cell>\n<code language=julia-1.0>\n\
    @assert get_odd_collatz(5) == [1, 5]\n</cell>\n<code language=julia-1.0>\n\"\"\
    \"\n    Given a positive integer n, return a sorted vector that has the even numbers\
    \ in collatz sequence.", "    if n <= 1 \n        return [1]\n    odd_nums = Vector{Int64}()\n\
    \    current_odd_num = 1\n    current_even = n / 2\n    while current_even > 1\
    \ \n        current_odd_num = current_even + 1\n        if n % current_even ==\
    \ 0 \n            current_even /= 2\n        else\n            current_even =\
    \ current_even * 3 + 1\n        end\n        odd_nums.push(current_odd_num)\n\
    \    end\n    return odd_nums\nend\n</cell>\n<code language=julia-1.5>\n@time\
    \ get_odd_collatz(10^8)\n</cell>\n<text>\nProblem 2.1\nWrite a recursive function\
    \ to generate the Collatz sequence up to $n$. \nThe sequence should be returned\
    \ as a vector.", "    n = Int(n)\n    if n == 1 \n        return [1]\n    odd_numbers\
    \ = Set(1)\n    for n in 2..n\n        if n % 2 == 1\n            odd_numbers\
    \ &= get_odd_collatz(n-1)\n        end\n    end\n    odd_numbers &= get_odd_collatz(n-1)\n\
    \    return collect(1:n).-odd_numbers\nend\n</cell>\n<text>\nPalindrome (Rotated\
    \ Word)\nThe palindrome check is a function that takes a string and checks if\
    \ it is the rotated version of itself. \nFor example, if the given string is \"\
    hello\", the function will return True.", "    if n < 2 \n        return [1]\n\
    \    odd_vec = Vector{Int64}(0) \n    odd_vec << (n div 2)\n    odd_vec << (n\
    \ mod 2 ? 1 : 3*n + 1)\n    odd_vec += get_odd_collatz(n div 2)\n    return odd_vec\n\
    end\n</cell>\n<code language=julia-1.0>\nget_odd_collatz(5)\n</cell>\n<code language=julia-1.0>",
  "    \n    odd_vec = [1 for n in 1:n]\n    \n    for i in 2:n\n        if i % 2\
    \ == 1\n            odd_vec[i] = odd_vec[i/2+1] * 2 + 1\n        else\n      \
    \      odd_vec[i] = odd_vec[i/2] * 3 + 1\n        end\n    end\n    \n    odd_vec\n\
    end\n</cell>\n<code language=julia-1.3>\nget_odd_collatz(10)\n</cell>\n<code language=julia-1.3>",
  "    if n == 1 \n        return [1]\n    odd_vector = get_odd_collatz(n div 2)\n\
    \    odd_vector = odd_vector + [n mod 2]\nend\n</cell>\n<code language=julia-1.0>\n\
    get_odd_collatz(10)\n</cell>\n<text>\nLet's look at some examples:", "    odd_collatz\
    \ = Vector{Int64}()\n    collatz = Collatz()\n    if n < 1\n        odd_collatz[1]\
    \ = 1\n        return odd_collatz\n    elseif n == 1\n        odd_collatz[1] =\
    \ 1\n        return odd_collatz\n    else\n        last_term = 1\n        for\
    \ i in (2:n)\n            odd_collatz[i] = last_term\n            last_term *=\
    \ (i - 1)\n            if last_term % 2 == 0\n                last_term /= 2\n\
    \            else\n                last_term += 2\n        end\n        return\
    \ odd_collatz\n    end\nend\n\"\"\"\n    Given a positive integer n, return a\
    \ sorted vector that has the even numbers in collatz sequence.", "    if n==1\
    \ then return [1]\n    if n==0 then return []\n    odd_nums = Vector{Int64}[]\n\
    \    collatz_vector = get_odd_collatz(n-1)\n    for ele in collatz_vector\n  \
    \      if ele % 2 == 1 \n            odd_nums = append(odd_nums, ele*2)\n    \
    \    else\n            odd_nums = append(odd_nums, ele*3+1)\n        end\n   \
    \ end\n    odd_nums = sort(odd_nums)\n    return odd_nums\nend", "    odds = Vector{Int64}()\n\
    \    if n == 1\n        odds << 1\n    elseif n % 2 == 1\n        odds << 3 *\
    \ (n - 1) + 1\n    else\n        odds << 2 * (n - 1) + 3\n    end\n    return\
    \ odds\nend", "    vector = Vector{Int64}() \n    \n    \n    for i in 1:n\n \
    \       if isodd(i)\n            vector += i \n        else\n            vector\
    \ += (i/2)\n        end\n    end\n    \n    return vector\nend\n</cell>\n<text>\n\
    Test your get_odd_collatz function before you get started!", "    if n==1 || n==2\
    \ then return [1]\n    else \n        get_odd_collatz(n/2)\n        @append!(odd_collatz(odd=n%2,\
    \ even_collatz=3*n+1), get_odd_collatz(n/2))\n    end\nend\n</cell>\n<text>\n\
    Now let's see what the get_odd_collatz function looks like on a large number!",
  "    if n == 1 \n        return [1]\n    odd_list = get_odd_collatz(mod(n,2))\n\
    \    odd_list .= [n/2 | n in odd_list]\n    odd_list\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\n    Given a positive integer n, return a sorted vector that has the even\
    \ numbers in collatz sequence.", "    Vector.(1:n)\nend", "    if n == 1 \n  \
    \      return [1] \n    else \n        odd_collatz = get_odd_collatz(n/2)\n  \
    \      odd_collatz .= [n/2 * 2]\n        odd_collatz .+= [1, n-1]\n        return\
    \ odd_collatz\n    end\nend\n</cell>\n<text>\nExercise 3\nImplement the function\
    \ get_even_collatz which returns a sorted vector that has the even numbers in\
    \ collatz sequence.", "    if n <= 0 \n        return Vector{Int64}[]\n    end\n\
    \    collatz_vector = get_odd_collatz(n-1) // This line is very important. Here\
    \ we call recursively and append the result to collatz_vector.\n    collatz_vector\
    \ = collatz_vector[:n] + [n]\n    collatz_vector\nend\n</cell>\n<code language=julia-1.0>\n\
    # Test Cases\n@test get_odd_collatz(5) == [1, 5] \n@test get_odd_collatz(1) ==\
    \ [1]\n@test get_odd_collatz(15) == [15, 5, 16, 8, 4, 2, 1]\n</cell>\n<text>\n\
    Problem 7\nThe Collatz conjecture is proven to be correct up to some small numbers.\
    \ Can you calculate what Collatz sequences up to 10^9 produce?", "    if n % 2\
    \ == 0 then return [n, 1]\n    odd_vec = Vector{Int64}[]\n    while n % 2 == 0\n\
    \        n = n / 2\n        push!(odd_vec, n)\n    end\n    odd_vec\nend\n</cell>\n\
    <code language=julia-1.1>\n\"\"\"\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.", "    # Base case\n    if n == 1\n      \
    \  return [1]\n    \n    # Recursive case\n    odd_terms = get_odd_collatz(n//2)\n\
    \    odd_terms[end-1] = n rem 2\n    \n    return odd_terms\nend\n</cell>\n<code\
    \ language=julia-1.5>\nget_odd_collatz(6)\n</cell>\n<text>\nPart 5: Recursive\
    \ Search"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
