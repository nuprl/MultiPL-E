name: HumanEval_16_count_distinct_characters
language: jl
prompt: "\"\"\" Given a string, find out how many distinct characters (regardless\
  \ of case) does it consist of\n    >>> count_distinct_characters(\"xyzXYZ\")\n \
  \   3\n    >>> count_distinct_characters(\"Jerry\")\n    4\n    \"\"\"\nfunction\
  \ count_distinct_characters(string::String)::Int64 \n"
tests: "using Test\n\n@testset begin\n\ncandidate = count_distinct_characters;\n\t\
  @test(candidate(\"\") == 0)\n\t@test(candidate(\"abcde\") == 5)\n\t@test(candidate(\"\
  abcdecadeCADE\") == 5)\n\t@test(candidate(\"aaaaAAAAaaaa\") == 1)\n\t@test(candidate(\"\
  Jerry jERRY JeRRRY\") == 5)\nend\n"
completions: ["    if string::String == \"\" || string::String == \" \" \n       \
    \ return 0 \n    distinct_characters: Set[String] = Set()\n    \n    for c in\
    \ string.chars \n        distinct_characters(c)\n    \n    distinct_characters.size()\n\
    end\n</code>\n<|/ a |>\n<| a tags=julia,string |>\n<code>", "    distinct::Int64\
    \ = 0\n    for char in string.to_lowercase()\n        if distinct[char] == 0\n\
    \            distinct[char] = 1\n        else \n            distinct[char] +=\
    \ 1\n    return distinct[char]\n</code>\n<|/ a tags=python,language-agnostic,algorithm\
    \ |>\n<| c |>\nOh, I see! I was so focused on the fact that I don't have a dictionary\
    \ and I didn't think of counting each element of \"distinct\" array. Thanks a\
    \ lot\n<|/ c |>\n<| a dscore=1 |>\nHere's my solution:\n<code>\ndef count_distinct_characters(string):\n\
    \    chardict = {}\n    charlist = []\n    for c in string:\n        if c not\
    \ in chardict:\n            chardict[c] = 1\n            charlist.append(c)\n\
    \        else:\n            chardict[c] += 1\n    return len(charlist)\n</code>\n\
    <|/ a tags=python,language-agnostic,algorithm |>\n<| a tags=python,language-agnostic,algorithm\
    \ dscore=1 |>\nUsing list comprehension:\n<code>\ndef count_distinct_characters(string):\n\
    \    return len([x for x in string.lower() if x.isalpha()])\n</code>\n<|/ a |>\n\
    <| a dscore=1 |>\n<code>\ndef count_distinct_characters(string):\n    unique_char\
    \ = \"\"\n    count = 1\n    for i in string:\n        if i not in unique_char:\n\
    \            unique_char = unique_char + i\n            count = count + 1\n  \
    \      else:\n            count = count + 1\n    return count\n</code>\n<|/ a\
    \ tags=python,language-agnostic,algorithm |>\n<| a |>\n<code>\ndef count_distinct_characters(s):\n\
    \    count=0\n    for i in s:\n        if i not in count:\n            count=count+1\n\
    \        else:\n            count=count+1\n    return count\n</code>\n<|/ a dscore=0\
    \ tags=python,language-agnostic,algorithm |>\n<| a |>\n<code>\ndef count_distinct_characters(string):\n\
    \  unique=[]\n  for i in string:\n    if i not in unique:\n      unique.append(i)\n\
    \  return len(unique)\n</code>\n<|/ a tags=python,language-agnostic,algorithm\
    \ dscore=0 |>\n<| a dscore=0 |>\n<code>\ndef count_distinct_characters(string):\n\
    \    distinct_characters = {}\n    for i in string:\n        if i not in distinct_characters:\n\
    \            distinct_characters[i] = 1\n        else:\n            distinct_characters[i]\
    \ += 1\n    return len(distinct_characters)\n</code>\n<|/ a tags=python,language-agnostic,algorithm\
    \ |>\n<| a dscore=0 |>\n<code>\ndef count_distinct_characters(", "    #todo implement\
    \ it using recursion\n    return 0\n</code>\n<|/ q tags=string,haskell dscore=0\
    \ |>\n<| c |>\n`count_distinct_characters = length . group . sort`\n<|/ c |>\n\
    <| c |>\nHonestly, this is more of a \"please do this for me\" type question.\
    \ StackOverflow is for specific programming problems, not \"how should I approach\
    \ this problem\" type questions.\n<|/ c |>\n<| c |>\n- It does seem like a good\
    \ question to me, although there might be a better way to approach it.  As far\
    \ as I can tell, the only thing this question is missing is a problem statement.\n\
    <|/ c |>\n<| c |>\n- Agreed.  I guess I'm just thinking it through and trying\
    \ to work out the answer.  I can't figure out how to come up with a solution.\
    \  I did come up with two possible answers - but I'm sure there are better ways.\
    \  I'm just trying to figure out how to come up with a solution from scratch and\
    \ how to solve a problem like this.\n<|/ c |>\n<| c |>\n- Sorry, I guess I should\
    \ have said this was a homework problem.  I appreciate all the help and I apologize\
    \ for not making my question more specific.  I am just trying to learn and I'm\
    \ just learning recursion.  But thank you for the answer, but please don't be\
    \ too harsh with me - I really want to learn how to approach this type of problem.\n\
    <|/ c |>\n<| a tags=string,haskell |>\nOkay, I'll try to explain how I would approach\
    \ this problem, but first I'll show some more typical Haskell idioms that can\
    \ make solving these types of problems easier.\nTypically, you would have a function\
    \ that counts the number of occurrences of a given character in a list.  So:\n\
    <code>\ncount_a :: Char -> [Char] -> Int\ncount_a c [] = 0\ncount_a c (x:xs) =\
    \ case x of\n                    x -> count_a c xs\n                    _ -> 1\
    \ + count_a c xs\n</code>\nSo far, we've only given this function one argument,\
    \ the character to search for.  But what if we wanted to search for a string?\
    \  Well, we could just change the definition of count_a to take a string, like\
    \ this:\n<code>\ncount_a :: String -> [Char] -> Int\ncount_a s [] = 0\ncount_a\
    \ s (x:xs) = case x of\n                      x -> count_a s xs\n            \
    \          _ -> 1 + count_a s xs\n</code>\nNow we've got a function that's more\
    \ general than before, that ", "    count = 0\n    string_lowercase_string = string.lower()\n\
    \    for i in string_lowercase_string:\n        if string_lowercase_string.count(i)\
    \ >0:\n            count = count+1\n    return count\n</code>\n<|/ a |>\n<| c\
    \ |>\nPlease see my response to Jim. His answer was more concise and more efficient.\
    \ I thought you had to count each character in the string multiple times in order\
    \ to get an accurate result. Did I misunderstand something?\n<|/ c |>\n<| c |>\n\
    Yes, your answer is better.  I didn't notice that when I wrote my answer.  I wrote\
    \ my answer before Jim posted his answer.\n<|/ c |>\n<| a |>\n<code>\nlet rec\
    \ count_distinct n =\n  if n = 0 then 0\n  else if n = 1 then 1\n  else count_distinct\
    \ (n-1) + count_distinct (n-1)\n</code>\n<|/ a dscore=0 tags=algorithm,functional-programming,string,scala\
    \ |>\n<| a tags=algorithm,functional-programming,string,scala |>\n<code>\ndef\
    \ count_distinctChars(string: String): Int = {\n  string.forall(_.toLowerCase\
    \ == _.toLowerCase)\n      ? string.filter(_.toLowerCase == _.toLowerCase).size\n\
    \      : string.length * 2\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease try\
    \ to explain your solution, rather than just posting code. Thanks!\n<|/ c |>\n\
    <| c |>\n`string.forall(_.toLowerCase == _.toLowerCase)` ensures that all characters\
    \ in the string are lowercase.\n`string.filter(_.toLowerCase == _.toLowerCase).size`\
    \ gives the count of unique characters within the string that were lowercase\n\
    <|/ c |>\n<| c |>\nIf `string.forall(_.toLowerCase == _.toLowerCase)` evaluates\
    \ to true, then `string.filter(_.toLowerCase == _.toLowerCase).size` would return\
    \ 0 and would then be multiplied by 2 to give the number of unique characters.\n\
    <|/ c |>\n<| a dscore=0 |>\nYou could just count the occurrences of each character\
    \ in the string, then add the number of occurrences of each letter that was not\
    \ in the string to the total :\n<code>\ndef countDistinctChars(word: String):\
    \ Int = {", "\"\"\"\n``count_distinct_characters(string)``", "    if string ==\
    \ \"\" \n        then 0\n    else count_distinct_characters(substring_before(string,\"\
    \")) \n        + count_distinct_characters(substring_after(string,\"\"))\nend",
  "  | string == \"\" = 1\n  | otherwise = 1 + count_distinct_characters(string.sub(0,\
    \ string.index(\"x\")))\n</code>\n<|/ a tags=algorithm,language-agnostic,combinatorics,recursion,python-3.x\
    \ dscore=3 |>\n<| a dscore=2 |>\nFor any string length of n this works:\n<code>\n\
    def count_distinct_characters(s):\n    seen = set()\n    for x in s:\n       \
    \ if x in seen:\n            seen.remove(x)\n        else:\n            seen.add(x)\n\
    \    return len(seen)\n</code>\n<|/ a tags=algorithm,language-agnostic,combinatorics,recursion,python-3.x\
    \ |>\n<| c |>\nIn most cases, your algorithm is much better than mine. +1\n<|/\
    \ c |>\n<| c |>\nThis works, but if you use recursion you will have a `RuntimeError:\
    \ maximum recursion depth exceeded in comparison` error. This is a good reason\
    \ to prefer iterative versions rather than recursive ones.\n<|/ c |>\n<| a dscore=1\
    \ |>\n<code>\ndef count_distinct_characters(text):\n    if len(text) == 0:\n \
    \       return -1\n    count = 0\n    firstChar = text[0]\n    count = 0\n   \
    \ for letter in text:\n        if letter == firstChar:\n            count += 1\n\
    \        else:\n            count += count_distinct_characters(text[1:])\n   \
    \ return count\n</code>\n<|/ a tags=algorithm,language-agnostic,combinatorics,recursion,python-3.x\
    \ |>\n<| c |>\n`text[1:]` will consume the entire string, so it'll be out of scope\
    \ for subsequent calls.\n<|/ c |>\n<| a |>\nThis is an iterative version in Python:\n\
    <code>\ndef count_distinct_characters(s):\n    seen = set()\n    count = 1\n \
    \   for letter in s:\n        if letter not in seen:\n            count += count_distinct_characters(s[count:])\n\
    \            seen.add(letter)\n    return count\n</code>\n<|/ a dscore=1 tags=algorithm,language-agnostic,combinatorics,recursion,python-3.x\
    \ |>\n<| a tags=algorithm,language-agnostic,combinatorics,recursion,python-3.x\
    \ dscore=1 |>\nI agree with most of the answers above that this is better suited\
    \ for recursion, but if you want an iterative solution that doesn't have the recursion\
    \ problem, this can be done quite simply with the itertools library (python3):\n\
    <code>\nfrom itertools import count\ndef count_distinct_characters(s):\n    return\
    \ sum(1 for _ in count(s, 1))\n</code>\n<|/ a |>\n<| a tags=algorithm,language-",
  "    if string == \"\"\n        return 0\n    var result = 0\n    for(var i = 0;\
    \ i < string.length; i++)\n        result ^= string.charCodeAt(i)\n    return\
    \ result\nend\n</cell>\n<code language=julia-1.5>", "    \"\"\"\n    count_distinct_characters\n\
    \    \"\"\"\n    let chars = string.to_lowercase()\n    let distinct_characters\
    \ = chars.unique().count()\n    return distinct_characters\nend", "    distinct_count\
    \ = 0\n    for character in string:\n        if islower(character):\n        \
    \    distinct_count +=1\n        elif isupper(character):\n            distinct_count\
    \ +=1\n    return distinct_count\n</cell>\n<text>\nSolution\nFill out the function\
    \ below.", "    \n\"\"\"Count the distinct characters in a string\n \n Args: \n\
    \    string: the string whose distinct characters are to be counted\n \n Returns:\
    \ \n    an integer\n \n Raises:\n    ValueError if the string has empty characters\n\
    \ \n Notes: \n    If it encounters an empty character, the function will raise\
    \ a value error\n \n    Example: \n    >>> count_distinct_characters(\"xyz\")\n\
    \    3\n    >>> count_distinct_characters(\"a\")\n    1\n    >>> count_distinct_characters(\"\
    \")\n    Traceback (most recent call last):\n    ...\n    ValueError: empty string\n\
    \ \n    Source: \n    https://stackoverflow.com/questions/2667491/counting-the-distinct-characters-in-a-string\n\
    \"\"\"", "\"\"\"\n    count_distinct_characters(string::String)\n        \n  \
    \  Given a string, find out how many distinct characters (regardless of case)\
    \ does it consist of\n    \n    Parameters\n    ----------\n    string::String\n\
    \        Input string \n    \n    Returns\n    -------\n    Int64\n        Total\
    \ number of distinct characters\n\"\"\"\n    \n    \nif haskey(globals(), \"count_distinct_characters\"\
    )\n    @doc # docstring", "    if string == \"\" \n        return 0 \n    else\
    \ \n        distinct_characters = string.count { \n            char -> char isalpha\
    \ or char isdigit\n        }\n        if string.count(unique_char) == distinct_characters\
    \ \n            then distinct_characters else 0 \n    end\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nThe `count` function actually works with any type that conforms\
    \ to `AbstractString`, so you can replace `if string.count(unique_char) == distinct_characters\
    \ then distinct_characters else 0 end` with `string.count(unique_char) == distinct_characters\
    \ ? distinct_characters : 0`.\n<|/ c |>\n<| a tags=string,julia dscore=2 |>\n\
    One liner\n<code>\njulia> count(collect(strsplit(string, \"x\")), eltype(eltype(string))\
    \ == Char)\n3\n</code>\nHere I am splitting the string \"x\" by \"x\". I then\
    \ collect all of the strings in an array. Finally I use count on the array, which\
    \ looks for only strings that are of type Char (which is what eltype(string) ==\
    \ Char will give you).\n<|/ a |>\n<| c |>\nJust to add a bit more of clarity,\
    \ this only works in version 0.6+\n<|/ c |>\n<| a dscore=1 |>\nA generic solution\
    \ that works for any string:\n<code>\njulia> function count_distinct_characters(string::AbstractString)\n\
    \           return if length(string) == 1 return 1 else string.count { char ->\n\
    \               char isalpha or char isdigit\n           }\n       end\ncount_distinct_characters\
    \ (generic function with 1 method)", "    \n     for i in string.split(\"\"):\n\
    \         \n         return count_distinct_characters(i)\n     \n     return 0\n\
    end \n</cell>\n<code language=julia-1.0>\ncount_distinct_characters(\"xyzXYZ\"\
    )\n</cell>\n<code language=julia-1.0>\ncount_distinct_characters(\"Jerry\")\n\
    </cell>\n<code language=julia-1.0>", "</code>\n<|/ a dscore=4 |>\n<| c |>\nI guess\
    \ I should clarify, the reason I asked the question is that I have seen this solution\
    \ proposed in some solutions on this site and I felt that it wasn't very Pythonic.\
    \ Since it makes use of mutable objects, I was wondering if it would be possible\
    \ to do it in a more Pythonic manner, maybe with list comprehensions.\n<|/ c |>\n\
    <| c |>\nIf you're looking for Pythonic solutions, I think [Martijn's answer](http://stackoverflow.com/a/23324012/82508)\
    \ is the most Pythonic (read: most idiomatic) way to solve your problem. He also\
    \ proposes a more idiomatic implementation using reduce().\n<|/ c |>\n<| a |>\n\
    Here's another one:\n<code>\ndef count_distinct_characters(s):\n    return len(set(s))\n\
    </code>\n<|/ a tags=string,python,duplicates,count dscore=3 |>\n<| c |>\n`set(s)`\
    \ already makes a set out of `s`, so the `len` call is redundant. `set` returns\
    \ a `set` object.\n<|/ c |>\n<| c |>\n`set(s)` doesn't work in python 2.7 - just\
    \ `set(s.split())`\n<|/ c |>\n<| c |>\nAh! I didn't know that. Thanks.\n<|/ c\
    \ |>\n<| a dscore=3 tags=string,python,duplicates,count |>\nYou can use itertools:\n\
    <code>\ndef count_distinct_characters(s):\n    return len(set(s))\n</code>\n<|/\
    \ a |>\n<| c |>\nitertools is good when you need to go through several times,\
    \ but this question was about iterating just once.\n<|/ c |>\n<| c |>\n: Actually\
    \ I was wondering whether one can do the same using `itertools` in `O(1)` time\
    \ where `O(n)` time would have to be done with `set` as shown in other answers.\
    \ `itertools` would have to store already seen characters in a list and check\
    \ for duplicates.\n<|/ c |>\n<| c |>\nItertools is only O(1) if the number of\
    \ strings is small enough to fit in a `set` object. Otherwise the time complexity\
    \ is `O(n)` regardless.\n<|/ c |>\n<| a dscore=3 |>\nYou can do this with regular\
    \ expressions and re.sub:\n<code>\nimport re\ndef count_distinct_characters(s):\n\
    \    return len(re.sub(r'(.)\\1+', r'\\1', s))\n</code>\n<|/ a tags=string,python,",
  "    # Write your code in Julia 1.0\n    sum = 0\n    for c in string.chars\n  \
    \      if !(c in string.lowercase && string.lowercase[string] == c)\n        \
    \    push!(sum, c)\n        end\n    end\n    return sum\nend\n</cell>\n<text>\n\
    Counting number of words", "\"\"\"\n    Count the number of distinct characters\
    \ in a string\n    \"\"\"\n    length::Int64 = string.length()\n    distinct::Int64\
    \ = 0\n    for i in string.characters.indices\n        if string.characters[i]\
    \ == string.characters[i+1]\n            distinct::Int64 += 1\n    return distinct\n\
    </code>\n<|/ a tags=string,haskell,character |>\n<| c |>\n`distinct::Int64 = 0`\
    \ should probably be `distinct::Int64 = 1`\n<|/ c |>\n<| c |>\nThat was a good\
    \ observation, and I have changed it.\n<|/ c |>\n<| a tags=string,haskell,character\
    \ dscore=1 |>\nAs far as I'm concerned, there is no reason to use string concatenation.\
    \ Instead, I'd define a function that returns one distinct character and one distinct\
    \ letter. Then, you can define a function that returns how many distinct characters\
    \ or letters there are in a given string:\n<code>\ncount_distinct :: String ->\
    \ Int\ncount_distinct s = length s\n    where\n        count_distinct (' ') =\
    \ 1\n        count_distinct c = 1 + (count_distinct $ cdup c)\n        count_distinct\
    \ (c : []) = 1\n        count_distinct (_ : cs) = 1 + count_distinct cs", "  \
    \  count_distinct_characters_rec(string)\nend", "    \"\"\"\n    Count number\
    \ of distinct characters (regardless of case) in a string.\n    \n    \n    >>>\
    \ count_distinct_characters(\"xyZZyYz\")\n    3\n    \"\"\"", "    #@title Find\
    \ the number of distinct characters in a string \n    \n    #@markdown This function\
    \ uses @ref count_distinct\n    \n    #@markdown Remember that in Haskell we ignore\
    \ case by default, unless we explicitly provide it\n    \n    #@markdown This\
    \ function can be turned into a `fold` using a helper function @ref unique_characters\n\
    \    \n    #@markdown By default in Python, @ref count_distinct returns `None`\
    \ if the input contains no characters\n    \n    if string == \"\"\n        then\
    \ return 0\n    else unique_characters(string) == \"\"\n        then return 0\n\
    \    else count_distinct(unique_characters(string))\n    \nend\n</cell>\n<text>\n\
    Exercise 7: Write a function to count the number of distinct characters in a string\
    \ ignoring case.", "    \"\"\"Counts how many distinct characters (regardless\
    \ of case) does it consist of\"\"\"\n    unique_characters = string.to_lowercase().distinct()\n\
    \    return length(unique_characters)\nend", "    count::Int64 = 0 \n    for i\
    \ in string:\n        if i !in \"abcdefghijklmnopqrstuvwxyz\":\n            count\
    \ += 1\n    return count\n</code>\n<|/ a tags=count,string,haskell dscore=3 |>\n\
    <| c |>\nThis is so much better than my answer.\n<|/ c |>\n<| c |>\nActually,\
    \ this is still a rather poor solution compared with mine, because it still counts\
    \ characters that are not in the alphabet. For example, a character 'a' counts\
    \ as \"distinct\" in my code, whereas a character 'b' counts as distinct in my\
    \ solution. Better to just use a Counted container. Yes, it's more code, more\
    \ performance, but this difference is irrelevant.\n<|/ c |>\n<| c |>\nI think\
    \ it counts `'a'` as `1`, `'b'` as `1`, and `'c'` as `2`; so that's not really\
    \ a bad thing in practice.\n<|/ c |>\n<| c |>\n: I agree that it's more code (which\
    \ is probably negligible), but the performance difference is significant -- at\
    \ least on my machine.\n<|/ c |>\n<| c |>\n: I agree. My test program also compares\
    \ very poorly to yours even for simple cases.\n<|/ c |>\n<| a tags=count,string,haskell\
    \ |>\nThe code below is about twice as fast as the original code (compiled with\
    \ -O2 on GHCi 6.12.3), and counts all characters that are not in the alphabet\
    \ rather than only characters that are in the alphabet. It counts characters that\
    \ are in different cases, like \"a\" and \"A\".\n<code>\nimport qualified Data.Text\
    \ as T", "    \"Returns a count of distinct characters in a string\"\n    return\
    \ String.length(string) - String.length(distinct(string))\n</code>\n<|/ a tags=string,julia,count\
    \ |>\n<| a |>\nThis is pretty inefficient, but I assume that efficiency is not\
    \ as much a problem as the code being a bit more readable.\n<code>", "    count_distinct\
    \ = 0\n    for i in string\n        count_distinct = count_distinct + 1\n    \n\
    \    return count_distinct\n</code>\n<|/ a dscore=2 tags=string,julia,python |>\n\
    <| c |>\nThis would not work if you input a tuple or list to count_distinct_characters\
    \ like count_distinct_characters([1, 2, 3, 3])\n<|/ c |>\n<| a dscore=0 |>\n<code>\n\
    from collections import Counter\ndef count_distinct_characters(s):\n    s = s.lower()\n\
    \    char_count = Counter(s)\n    distinct_count = sum(char_count[c] for c in\
    \ char_count)\n    return distinct_count\n</code>\n<|/ a tags=string,julia,python\
    \ |>\n<| a tags=string,julia,python |>\nUsing a generator expression and count\
    \ function in Python the code would look like this:\n<code>\ndef count_distinct_characters(s):\n\
    \    return sum(map(s.count,set(s)))\n</code>\nOr, even simpler, if all characters\
    \ are in the lowercase alphabet, then:\n<code>\ndef count_distinct_characters(s):\n\
    \    return len(set(s.lower()))\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=string,julia,python\
    \ |>\n<code>\ndef count_distinct_characters(str1):\n    count = 0\n    for c in\
    \ str1:\n        if str1.count(c) == 0:\n            count += 1\n    return count",
  "    return count_distinct_characters(string,0)\n</code>\n<|/ a dscore=2 tags=string,haskell\
    \ |>\n<| c |>\nI believe you need to include `Data.Char` for the `toLower` to\
    \ be defined.\n<|/ c |>\n<| c |>\nThanks for pointing that out, I've edited the\
    \ answer.\n<|/ c |>\n<| a |>\nHere are some ways:\n<code>\nimport Data.Char",
  "    cdef long long counter = long long(1) # initialize counter to 1\n    for character\
    \ in string:\n        if character not in counter:\n            counter = counter\
    \ + 1\n    return counter", "    cdef Int64 distinct = 0\n    for char in string:\n\
    \        distinct += 1 if char != char.lower() or char != char.upper() else 0\n\
    \    return distinct\n\"\"\"\n</cell>\n<text>\nThis time let's look at the code\
    \ using vectorized operations, which is what NumPy excels at:", "{\n    var c\
    \ = 0\n    for c in string.chars {\n        count++\n    }\n    return count\n\
    }\n\"\"\"", "    \"\"\"\n    Find out how many distinct characters (regardless\
    \ of case) does it consist of\n    >>> count_distinct_characters(\"xyzXYZ\")\n\
    \    3\n    >>> count_distinct_characters(\"Jerry\")\n    4\n    \"\"\"\n  \n\
    \  case string of\n  empty => 0\n  character(_)=> 1\n  otherwise   => count(string)\
    \ - count_distinct_characters(lowercase(string))\n  \nend", "    if string::String\
    \ == \"\" then return 0 \n    mutable count = 1 \n    for c in string.uppercase_ascii\
    \ .. string.lowercase_ascii do count *= (c + 1) \n    return count\n</code>\n\
    <|/ a |>\n<| c |>\nWhy \"mutable count = 1\"?\n<|/ c |>\n<| c |>\n: It ensures\
    \ that `count` is returned from the function, without having been changed inside\
    \ the loop. Since Python is inherently single-threaded, `count` will retain its\
    \ original value during each iteration.\n<|/ c |>\n<| c |>\nThis is very inefficient.\n\
    <|/ c |>\n<| c |>\n: It also ensures that `count` is returned from the function,\
    \ without having been changed inside the loop. Since Python is inherently single-threaded,\
    \ `count` will retain its original value during each iteration.\n<|/ c |>\n<|\
    \ c |>\nThis is actually O(n), not O(1)\n<|/ c |>\n<| a tags=string,python,algorithm\
    \ dscore=5 |>\n<code>\n>>> from collections import Counter\n>>> def count_characters(s):\n\
    ...     return sum(map(len, Counter(s).values()))\n...\n>>> count_characters('abcdefg')\n\
    7\n>>> count_characters('Hello World!')\n10\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ also makes the most sense when dealing with unicode strings, as it's very fast.\n\
    <|/ c |>\n<| c |>\n+1 for Counter being faster than the other answers on this\
    \ page\n<|/ c |>\n<| a dscore=5 |>\nOne liner using map:\n<code>\ndef count_distinct_characters(s):\n\
    \    return sum(map(lambda x: 1 if x.isalnum() else 0, s))\n</code>\n<|/ a tags=string,python,algorithm\
    \ |>\n<| c |>\nThe use of `lambda` here makes this an example of a [highly inefficient\
    \ solution](http://stackoverflow.com/a/41511504/1938798).\n<|/ c |>\n<| c |>\n\
    Agreed. However, the question was about the algorithmic approach, and this solution\
    \ is O(N).\n<|/ c |>\n<| c |>\nAgreed, but it's also an example of a [very inefficient\
    \ solution](http://stackoverflow.com/a/41511504/1938798).\n<|/ c |>\n<| c |>\n\
    Nice solution! And I like that it doesn't require a list comprehension!\n<|/ c\
    \ |>\n<| c |>\nA bit more efficient than `len(set(s))", "    char_counts = HashMap[String,\
    \ Int64](\"\")\n    for c in string:\n        if c.isLower\n            c == c.toUpper()\n\
    \        else\n            c == c.toLower()\n        char_counts[c] <- char_counts[c]\
    \ + 1\n    return char_counts.length\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ |>\nHere's a more concise version using foldr, which makes it easy to understand\
    \ by reading the code:\n<code>\ncount_distinct_characters :: String -> Int\ncount_distinct_characters\
    \ xs = foldl (\\acc (c,i) -> (c,i+1) : acc) [0,0] xs\n</code>\n<|/ a tags=haskell\
    \ |>\n<| a tags=haskell |>\nIn case you just want a pure solution that does not\
    \ use any library functions, here is a simple implementation using Data.Map (thanks\
    \ to for providing this implementation):\n<code>\nimport qualified Data.Map as\
    \ M\nimport Data.Char", "    if string == \"\"\n        return 0 \n    if string\
    \ in string.downcase()\n        return string.downcase().len()\n    return count_distinct_characters(string[1:end-1])\
    \ + count_distinct_characters(string[end])\nend", "    sum=0\n    for c in string:\n\
    \        if c.isUpper():\n            sum+=2\n        elif c.isLower():\n    \
    \        sum+=1\n        else:\n            sum+=1\n    return sum", "    if is_empty(string)\n\
    \        return 0\n    \n    char_count = HashMap[String, Int64](HashMap[String,\
    \ Int64]())", "    if string == \"\"\n        0\n    else\n        1 + count_distinct_characters(string[1..-1])\
    \ + count_distinct_characters(string[1..string.index(string.last)])\nend\n</cell>\n\
    <text>\nAnd we can check our implementation against the benchmarking library to\
    \ see that it performs fairly well on all string inputs:", "    \"\"\"\n    Count\
    \ distinct characters in a string\n    \"\"\"\n    count_distinct_characters =\
    \ string_length(string)\n    for c in string:\n        if string[count_distinct_characters\
    \ - 1] == c:\n            count_distinct_characters = count_distinct_characters\
    \ - 1\n        else:\n            count_distinct_characters = count_distinct_characters\
    \ + 1\n    return count_distinct_characters\nend \"\"\"\n    \"\"\"", "    # Write\
    \ your code here\n    for c in string:\n        if c.isLower():\n            lowerCount\
    \ += 1\n        elif c.isUpper():\n            upperCount += 1\n        else:\n\
    \            otherCount += 1\n    return lowerCount + upperCount + otherCount",
  "    result =0\n    for character in string\n        if character == character ||\
    \ case == character\n            result +=1\n    end\n    return result\nend",
  "    if string == \"\" then 0 else count_distinct_characters(tail(string))\nend",
  "    string |> Char.map char.codepoint |> Set\nend", "    return length(unique(string))\n\
    end \"\"\"\n</cell>\n<code language=julia-1.1>\n# Benchmark\n@time count_distinct_characters(\"\
    abc\")\n@time count_distinct_characters(\"\")\n@time count_distinct_characters(randstring(10_000_000))\n\
    </cell>\n<code language=julia-1.1>", "    \"\"\"\n    Count the distinct characters\
    \ in a string, regardless of case.\n    >>> count_distinct_characters(\"xyzXYZ\"\
    )\n    3\n    >>> count_distinct_characters(\"Jerry\")\n    4\n    \"\"\"", " \
    \   length <- String.length(string)\n    if length == 0 then\n        return 0\n\
    \    else\n        count_distinct_characters(String.tail(string)) + 1\n    end\n\
    end\n</cell>\n<code language=julia-1.5>", "    \"\"\"Given a string, find out\
    \ how many distinct characters (regardless of case) does it consist of\n    \"\
    \"\"\n    \n    return (\n        count(\n            groupby(string.lower(),\
    \ lambda c: c),\n            lambda cs: len(cs)\n        )\n    )\nend", "   \
    \ count_distinct = 0\n    for c in string:\n        count_distinct += 1 if c.isUpper()\
    \ else 0\n    return count_distinct\nend", "    \"\"\"\n    returns the number\
    \ of distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters(\"\
    xyzXYZ\")\n    3\n    >>> count_distinct_characters(\"Jerry\")\n    4\n    \"\"\
    \"", "    count_distinct_characters(\"\")\nend", "    ans = if string.size ==\
    \ 0 then 0 else 1 end \n    for a in string.characters\n        ans = ans + count(a,string.characters)\n\
    \    end\n    return ans\nend\n</cell>\n<code language=julia-1.5>\ncount_distinct_characters(\"\
    Jerry\")\n</cell>\n<text>\nWe now have all the basic building blocks of Julia.\
    \ Let's put them together.", "    count := 0\n    for c in string do \n      \
    \  if isUpper(c) or isLower(c) then \n            count += 1\n        else if\
    \ isDigit(c) then \n            count += 1\n        else if isSymbol(c) then \n\
    \            count += 1\n        else if c == '_' then \n            count +=\
    \ 1\n        else if c == '.' then \n            count += 1\n        else if c\
    \ == '-' then \n            count += 1\n        else if c == '+' then \n     \
    \       count += 1\n        else if c == '/' then \n            count += 1\n \
    \       else if c == '=' then \n            count += 1\n        else if c == '+'\
    \ then \n            count += 1\n        else if c == '-' then \n            count\
    \ += 1\n        else if c == '.' then \n            count += 1\n        else if\
    \ c == '_' then \n            count += 1\n        else if c == '%' then \n   \
    \         count += 1\n        else if c == '+' or c == '-' or c == '.' or c ==\
    \ '/' or c == '_' or c == '%' then \n            count += 1\n        else\n  \
    \          count += 1\n    end\n    return count\nend \n</cell>\n<code language=julia-1.5>\n\
    # Test count_distinct_characters\n@test count_distinct_characters(\"xyzXYZ\")\
    \ == 2\n@test count_distinct_characters(\"Jerry\") == 4\n</cell>\n<text>\n4.4\
    \ Count consecutive duplicate characters\nGiven a string, find out how many consecutive\
    \ duplicate characters (regardless of case) does it consist of\n    >>> count_consecutive_duplicate_characters(\"\
    xyxYxyXxyxy\")\n    4\n    >>> count_consecutive_duplicate_characters(\"Jerry\
    \ Python\")\n    5\n    \"\"\"", "    return (string.foldl(0, (count, character)\
    \ => count + {lowercase => lowercase..string.foldl(1, (count1, character2) =>\
    \ count1 + {uppercase => character2..string.foldl(2, (count2, character3) => count2\
    \ + {_ => count2 + {_ => character3}})})})\nend", "    if string.empty\n     \
    \   0\n    else\n        count_distinct_characters(string.[1..string.last]) +\
    \ count_distinct_characters(string.[1..string.last].lower)\n    end\nend\n</cell>\n\
    <code language=julia-1.6>", "    if string.lenght == 0 then\n        return 0\n\
    \    count = 0\n    for ch in string.characters:\n        if ch.isUppercase or\
    \ ch.isLowercase\n            count = count + 1\n    end\n    return count\nend\n\
    </cell>\n<text>\n2. Count the number of unique characters\nThis one is pretty\
    \ easy since we are just counting the number of characters in the string", " \
    \   if (string.size > 0) then\n        let char_string = string.to_lowercase()\n\
    \        let mut chars_set = Set<char>()\n        for (index, char) in string.chars().enumerated()\
    \ {\n            if char_string[index] != char { chars_set.insert(char) }\n  \
    \      }\n        chars_set.len()\n    else\n        0\n    end\nend\n</code>\n\
    The second function is almost the same as the first, but instead of converting\
    \ everything to lowercase, it just counts how many characters were in the string\
    \ and subtract it from the string length (the function assumes the string only\
    \ contains alphanumeric and underscores).\n<code>", "    letters = string.to_lowercase()\n\
    \    unique_letters = letters.distinct()\n    return unique_letters.length()\n\
    </code>\n<|/ a |>\n<| a dscore=0 tags=string,substring,haskell,string |>\nAn alternative\
    \ to previous answers, in case you don't want to import Data.List. \n<code>\n\
    import Data.List\nmyLength :: String -> Int\nmyLength = length\n</code>\n<|/ a\
    \ |>\n<| a |>\n<code>\nimport Data.List", "\tlet unique_chars = string:split(\"\
    \")\n\tlet result = 1\n\tfor c in unique_chars do\n\t\tlet is_different = not\
    \ (string == c.upcase())\n\t\tif is_different then\n\t\t\tresult += 1\n\treturn\
    \ result\nend\n</cell>\n<text>\nWrite a function which takes a string and outputs\
    \ a string of the same length which contains all the characters in the string\
    \ \nand all the others (the difference between the string and every single character)",
  "    if is_empty(string)\n        return 0 \n    \n    char_count = Int64(0)\n \
    \   for c in string\n        char_count += 1\n    end\n    return char_count\n\
    end\n</cell>\n<code language=julia-1.5>\n# TEST count_distinct_characters (104\
    \ points)\n@test count_distinct_characters(\"xyzXYZ\") == 3\n@test count_distinct_characters(\"\
    Jerry\") == 4\n</cell>\n<text>\n3.2.4 Function that computes the number of digits\
    \ in an integer\nWrite a function that computes the number of digits in an integer\
    \ (without using the function digits). For example, given an integer x, your function\
    \ should return 3 for x = 37 and 0 for x = 0.", "    if length(string)==0 return\
    \ 0\n    let\n        count_chars = 0..<length(string)\n        return count_chars.filter(x->string[x]!=string[find(string,\"\
    xyz\",1)]).length\n    end\nend\n</cell>\n<text>\nExercise 10\nWrite a function\
    \ that counts the number of times a substring occurs in a string and returns a\
    \ list of all substrings in that string. For example: \"xyxy\" has 3 substrings:\
    \ \"x\", \"y\" and \"xy\"", "\tlocal count = -1\n\tfor c in string.lower() do\n\
    \t\tcount += 1\n\tend\n\treturn count\nend\n</cell>\n<code language=julia-1.3>",
  "    \"\"\"This function takes string as input and returns total number of distinct\
    \ characters \"\"\"\n    count = 0\n    for char in string:\n        if char not\
    \ in string:\n            count += 1\n    return count", "    result =0\n    count\
    \ = 1\n    for c in string:\n        result += (c.isUpper) ? count : -count\n\
    \        count *= 2\n    return Int64(result)\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a dscore=0 |>\nI wanted to solve this in O(n) time complexity. The most efficient\
    \ solution I could come up with was O(n) time complexity with the help of the\
    \ HashSet data structure:\n<code>\ndef count_distinct_chars(input_str: str) ->\
    \ int:\n    chars = set()", "    if string == \"\"\n        1\n    elseif string[0]\
    \ != string[1]\n        count_distinct_characters(string[1:end-1])\n    elseif\
    \ string[0] != string[2]\n        count_distinct_characters(string[1:end-1]) +\
    \ 1\n    else\n        count_distinct_characters(string[1:end-1]) + 1\n    end\n\
    end", "    len = length(string)\n    return ifelse(len == 0, 0, len + ifelse(startswith(tolower(string),\
    \ \"j\", 1), 1,\n                                                 ifelse(startswith(tolower(string),\
    \ \"a\", 1), 2,\n                                                        ifelse(startswith(tolower(string),\
    \ \"s\", 1), 3,\n                                                            \
    \    ifelse(startswith(tolower(string), \"z\", 1), 4,\n                      \
    \                                                  ifelse(startswith(tolower(string),\
    \ \"d\", 1), 5,\n                                                            \
    \                    ifelse(startswith(tolower(string), \"b\", 1), 6,\n      \
    \                                                                            \
    \      ifelse(startswith(tolower(string), \"m\", 1), 7,\n                    \
    \                                                                            ifelse(startswith(tolower(string),\
    \ \"c\", 1), 8,\n                                                            \
    \                                            ifelse(startswith(tolower(string),\
    \ \"g\", 1), 9,\n                                                            \
    \                                                    ifelse(startswith(tolower(string),\
    \ \"e\", 1), 10,\n                                                           \
    \                                                             ifelse(startswith(tolower(string),\
    \ \"f\", 1), 11,\n                                                           \
    \                                                                     ifelse(startswith(tolower(string),\
    \ \"i\", 1), 12,\n                                                           \
    \                                                                            \
    \ ifelse(startswith(tolower(string), \"h\", 1), 13,\n                        \
    \                                                                            \
    \                                            ifelse(startswith(tolower(string),\
    \ \"k\", 1), 14,\n                                                           \
    \                                                                            \
    \                 ifelse(startswith(tolower(string), \"l\", 1), 15,\n        \
    \                                                                            \
    \                                                                            ifelse(startswith(tolower(string),\
    \ \"r\", 1), 16,\n                                                           \
    \                                                                            \
    \                                 ifelse(startswith(tolower(string), \"y\", 1),\
    \ 17,\n                                                                      \
    \                                                                            \
    \                              ifelse(startswith(tolower(string), \"p\", 1), 18,\n\
    \                                                                            \
    \                                                                            \
    \                                ifelse(startswith(tolower(string), \"q\", 1),\
    \ 19,\n                                                                      \
    \                                                                            \
    \                                                              ifelse(startswith(tolower(string),\
    \ \"v\", 1), 20,\n                                                           \
    \                                                                            \
    \                                                                            \
    \     ifelse(startswith(tolower(string), \"w\", 1), 21,\n                    \
    \                                                                            \
    \                                                                            \
    \                                                    ifelse(startswith(tolower(string),\
    \ \"x\", 1), 22,\n                                                           \
    \                                                                            \
    \                                                                            \
    \                     ifelse(startswith(tolower(string), \"v\", 1), 23,\n    \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \        ifelse(startswith(tolower(string), \"y\", 1), 24,\n                 \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \   ifelse(startswith(tolower(string), \"m\", 1), 25,\n                      \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                      ifelse(startswith(tolower(string), \"c\", 1), 26,\n   \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \           ifelse(startswith(tolower(string), \"p\", 1), 27,\n              \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \    ifelse(startswith(tolower(string), \"q\", 1), 28,\n                     \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                         ifelse(startswith(tolower(string),\
    \ \"s\", 1), 29,\n                                                           \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                   ifelse(startswith(tolower(string), \"t\",\
    \ 1), 30,\n                                                                  \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                            if", "    \"\"\"count the number of distinct characters\
    \ in the string\n    \n    >>> count_distinct_characters(\"xyzXYZ\")\n    3\n\
    \    >>> count_distinct_characters(\"Jerry\")\n    4\n    \"\"\"", "    if string\
    \ == \"\" \n        return 0 \n    else \n        let first_char = string[1] \n\
    \        count_distinct_characters(string[1 .. end-2]) + count_distinct_characters(string[end..c-1])\n\
    \    end\nend\n</cell>\n<code language=julia-0.5>\ncount_distinct_characters(\"\
    abcABC\")\n</cell>\n<text>\nExercise 15: Find distinct characters in a string\
    \ ignoring case", "    \"\"\"\n    Count the number of distinct characters (regardless\
    \ of case) does it consist of", "    \n    count::Int64 = string.count(\"a\")\n\
    \    \n    for i in string.lowerCase():\n        if i.isUpper():\n           \
    \ count += 1\n    \n    return count\n</code>\n<|/ a tags=string,python,function\
    \ |>\n<| c |>\nThis also works, but I like yours better.\n<|/ c |>\n<| a tags=string,python,function\
    \ |>\nYou can try this:\n<code>\ndef count_distinct_characters(string):\n  letters\
    \ = {i for i in string if i.isalpha()}\n  return len(letters)\n</code>\nIt will\
    \ generate a list of all letters in the string and count the occurence of the\
    \ letters.\n<|/ a dscore=2 |>\n<| c |>\n`count_distinct_characters(\"xaxxax\"\
    )` returns `3`, which is wrong.\n<|/ c |>\n<| c |>\nIt only count letters, not\
    \ numbers.\n<|/ c |>\n<| c |>\nYou should have mentioned that in your question.\
    \ `count_distinct_characters(\"1x2x3\")` should return `3` and not `1`\n<|/ c\
    \ |>\n<| a tags=string,python,function dscore=1 |>\nHere's another option:\n<code>\n\
    len(set(\"\".join(string.split())))\n</code>\n<|/ a |>\n<| c |>\nThis is clever,\
    \ but doesn't generalize well to non-English characters.\n<|/ c |>\n<| a dscore=1\
    \ |>\n<code>\ndef count_distinct_characters(string):\n    count = 0\n    for char\
    \ in string:\n        if char.isalpha():\n            count += 1\n    return count\n\
    </code>\n<|/ a tags=string,python,function |>\n<| a tags=string,python,function\
    \ |>\nI believe this is what you are looking for:\n<code>\ndef count_distinct_characters(string):\n\
    \    count = 0\n    for char in string:\n        if char.isalpha():\n        \
    \    count += 1\n    return count\n</code>\n<|/ a dscore=1 |>\n<| a tags=string,python,function\
    \ |>\nI didn't see your answer so I made it my own, maybe it will help somebody\
    \ else.\n<code>\ndef count_distinct_characters(string):\n    count = 0\n    for\
    \ char in string:\n        if char.isalpha():\n            count += 1\n    return\
    \ count", "    string == \"\" || string == \"\\n\" || string == \"\\t\" || string\
    \ == \"\\r\" ? 0 : string.length\nend\n</cell>\n<code language=julia-1.5>\n# Run\
    \ this cell to test your code\n@test count_distinct_characters(\"abcABC\") ==\
    \ 3\n@test count_distinct_characters(\"xyzXYZ\") == 3\n@test count_distinct_characters(\"\
    Jerry\") == 4\n</cell>\n<text>\n(4 points) Write a function, which given a string,\
    \ returns the number of characters (in their original form) which are not unique\
    \ (case insensitive), e.g. \"Jerry\" -> 4 -> \"Jerry\"", "    |\n    charcount::Int64\
    \ = 1\n    |\n    for c in string\n        |\n        charcount = charcount +\
    \ 1 if charcount < count_distinct_characters(c)\n        |\n        charcount\
    \ = charcount + 1\n    |\n    return charcount\n</code>\n<|/ a tags=haskell |>\n\
    <| c |>\nFor me, this is more intuitive and easier to understand, thanks!\n<|/\
    \ c |>\n<| a |>\nI think it's better to use foldl function instead of fold for\
    \ loop in Haskell.\n<code>\ncount_distinct :: String -> Int\ncount_distinct s\
    \ = foldl (\\x -> (head x) + 1) 0 s\n</code>\nBut I prefer to use foldr, because\
    \ it's more intuitive to me. \n<code>\ncount_distinct :: String -> Int\ncount_distinct\
    \ s = foldl (\\x y -> if (head x) > y) 0 s\n</code>\nThe reason I prefer to use\
    \ foldl instead of fold is because foldl use function as fold function. In Haskell\
    \ we use function as fold function because functional programming paradigm. As\
    \ example foldl function use function as fold function but fold function in Haskell\
    \ is more common to fold function.\n<code>\nfoldl f z [a1,a2,...,am] = a1 + (f\
    \ a2 ... am z)\n</code>\nBut In our case, we use function as fold function and\
    \ foldl is more common to use.\n<|/ a tags=haskell dscore=4 |>\n<| a |>\nFor fun,\
    \ here are a few other ways to do it. This only works as long as the characters\
    \ are all ASCII; it does assume that the string is at least one character long.\n\
    <code>\n-- Using String-length\ncount_distinct :: String -> Int\ncount_distinct\
    \ xs = length (toUpper xs) `div` 2", "\"\"\"\n@doc count_distinct_characters\n\
    \"\"\"\n    return length(unique(string))\nend", "    \"\"\"\n    >>> count_distinct_characters(\"\
    xyzXYZ\")\n    3\n    >>> count_distinct_characters(\"Jerry\")\n    4\n    \"\"\
    \"", "\"\"\"\n    Count the distinct characters (regardless of case) of a string\n\
    \    \"\"\"\n    return count_distinct_chars(string) |> str\nend\n</cell>\n<text>\n\
    4.1 Write a function count_distinct_characters(string::String)::Int64 which returns\
    \ the number of distinct characters in the input string", "    if is_empty(string)\n\
    \        return 0\n    unique_chars = unique(characters(string))\n    return length(unique_chars)\n\
    end\n</cell>\n<code language=julia-0.4>\ncount_distinct_characters(\"abc\")\n\
    </cell>\n<text>\nA quick peek at the string module\nJulia has a bunch of string\
    \ functionality in string module. We will take a look at some of these.", "  \
    \  if string == \"\"\n        return 0\n    \n    let first_character = string[1]\n\
    \    let first_character_upper = first_character.toUpper()\n    \n    let last_character\
    \ = string[string.len()-1]\n    let last_character_lower = last_character.toLowerCase()\n\
    \    \n    if first_character == last_character or first_character == first_character_upper\
    \ or first_character == last_character_lower\n        then 1\n    else count_distinct_characters(string[1:string.len()-1])\n\
    \    \nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\nFor a case insensitive (with\
    \ upper/lowercase) string in Julia 1.2 you can use function countin:\n<code>\n\
    julia> s = \"abc\"\n\"abc\"", "    \n    \n\"\"\"\n# count distinct characters",
  "    string_lowercase = string.lowercase()\n    count_distinct_characters_helper(string_lowercase)\n\
    end\n</cell>\n<text>\nExercise 7: count_distinct_characters(string::String)\n\
    Given a string, find out how many distinct characters (regardless of case) does\
    \ it consist of\n    >>> count_distinct_characters(\"xyzXYZ\")\n    3\n    >>>\
    \ count_distinct_characters(\"Jerry\")\n    4\n    \"\"\"", "    # Write your\
    \ function here\n    count::Int64 = 0\n    for c in string:\n        if c.isUpper()\n\
    \            count += 1\n        elif c.isLower()\n            count += 1\n  \
    \  return count", "count_distinct_characters(string)   = length(distinct(string))\n\
    \"\"\"", "    if string.is_empty() \n    then 0 \n    else if string.head == \"\
    c\"\n    then count_distinct_characters(string.tail)\n    else count_distinct_characters(string.tail)\
    \ + count_distinct_characters(string.head + string.tail)\n    end\nend", "\"\"\
    \"\n    count_distinct_characters(string)", "    if string == \"\" then 0 else\
    \ (string |> String.toLower |> String.count |> UInt64) \nend # count_distinct_characters",
  "    if string.size == 0 \n        0\n    else\n        if string.all_ascii()\n\
    \            string.ascii_lowercase().count\n        else\n            string.ascii_uppercase().count\n\
    \        end\n    end\nend\n</code>\n<|/ a tags=julia |>\n<| a tags=julia |>\n\
    Here is a simple solution using an Enum:\n<code>", "    if string.length == 0\
    \ \n        0\n    else if string.length == 1 \n        1\n    else \n       \
    \ count_distinct_characters(string[1:]) + count_distinct_characters(string[1:],\
    \ string[0])\nend\n</cell>\n<code language=julia-1.5>\nusing BenchmarkTools",
  "    count = 0\n    for char in string:\n        if char.isupper():\n          \
    \  count += 1\n        elif char.islower():\n            count += 1\n    return\
    \ count\nend count_distinct_characters\n</cell>\n<code language=julia-1.1>", " \
    \   \n    string <-tolower(string)\n    unique_character_count <- length(unique(unlist(strsplit(string,\
    \ \"\"))))\n    return unique_character_count\nend\n</cell>\n<text>\nTask 20.\
    \ Compute the number of \"X\" or \"Y\"s across the entire corpus\nHint: You might\
    \ want to use map", "\"\"\"\nCount the number of distinct characters in a string.\
    \ \n\"\"\"\n    mutable count_distinct_characters = string.length\n    for character\
    \ in string\n        count_distinct_characters = count_distinct_characters + 1\n\
    \    end\n    return count_distinct_characters\nend\n</cell>\n<code language=julia-1.0>\n\
    count_distinct_characters(\"xyzXYZ\")\n</cell>\n<code language=julia-1.0>\ncount_distinct_characters(\"\
    Jerry\")\n</cell>\n<code language=julia-1.0>", "\"\"\"\nCalculate the distinct\
    \ number of characters found in a string. ", "\"\"\"\ncount_distinct_characters(string::String)::Int64\
    \ = \n  count_distinct(string.chars)\n\"\"\"", "    if string == \"\"\n      \
    \  return 0\n    \n    char = string[1]\n    count = 1\n    for c in string[2,end-1]\n\
    \        if char != c\n            count = 0\n        else\n            count\
    \ = count + 1\n    end\n    return count\nend\n</cell>\n<text>\nTest your Code",
  "    if string == \"\"\n        0\n    else\n        count_distinct_characters(string[1:])+count_distinct_characters(string[:1])\n\
    end\n</cell>\n<cell>\n#export", "    if string.size == 0 \n        0\n    elseif\
    \ string.size == 1 \n        return 1\n    else \n        unique_chars = unique(string.map(string.char))\n\
    \        return unique_chars.size()\nend", "    if string::String == \"\" then\
    \ return 0\n    val char_to_int =\n        HashMap[Char, Int]()\n    for (ch::Char)\
    \ in string \n        do if char_to_int.contains(ch) then char_to_int += ch else\
    \ char_to_int += ch, char_to_int += 1\n    char_to_int.size\nend\n</code>\n<|/\
    \ a |>\n<| a |>\nYou can use\n<code>\n def distinct_count(str: String): Int =\
    \ {\n     str.distinct.size\n }\n</code>\n<|/ a dscore=1 tags=scala |>\n<| a tags=scala\
    \ |>\n<code>\ndef countDistinct(input: String): Int = {\n  input.foldLeft(0)(\
    \ (a,b) => b + if (a contains b) 1 else 0 )\n}\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a tags=scala |>\nHere's one that just counts the number of times the character\
    \ appears:\n<code>\ndef countDistinctChars(s: String): Int = s.toSet.toSeq.size\n\
    </code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\ndef distinctCount(x: String): Int\
    \ = {\n  x.split('').filter(_.isLetter).size\n}\n</code>\n<|/ a tags=scala dscore=0\
    \ |>\n<| c |>\nWelcome to Stack Overflow! Please don't answer just with source\
    \ code. Try to provide a nice description about how your solution works. See:\
    \ [How do I write a good answer?](https://stackoverflow.com/help/how-to-answer).\
    \ Thanks\n<|/ c |>\n<| a tags=scala |>\n<code>\ndef distinctCount(x: String):\
    \ Int = {\n  x.split('').filterNot(_ == '').size\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nWelcome to Stack Overflow! Please don't answer just with source code.\
    \ Try to provide a nice description about how your solution works. See: [How do\
    \ I write a good answer?](https://stackoverflow.com/help/how-to-answer). Thanks\n\
    <|/ c |>\n<| c |>\nHi, could you please add some explanation to your code? Code-only\
    \ answers are discouraged.\n<|/ c |>\n<| c |>\nThis doesn't answer the question.\
    \ Can you explain how this differs from the other answers?\n<|/ c |>\n<| a dscore=0\
    \ |>\nYou can use fold \n<code>\ndef distinctCount(str: String): Int = {\n   \
    \ str.fold", "    if string == \"\" \n        then return 0\n    else \n     \
    \   let\n        char_table = unique(string)\n        return\n        char_table.count\n\
    \    end\nend\n</cell>\n<text>\nFinally, let's use our function to solve the problem\
    \ of counting the characters in our input string", "    characters_to_count::Int64\
    \ = int64(0)\n    for character in string {\n        if character != character\
    \ {\n            characters_to_count = characters_to_count + 1\n        }\n  \
    \  }\n    return characters_to_count\nend count_distinct_characters", "      \
    \  \n        \n    #find the length of string\n    string_length::Int64 = length(string)\n\
    \    \n    #initialize a counter\n    counter::Int64 = 0\n    \n    #find the\
    \ distinct characters in the string and increment the counter\n    for index in\
    \ (0 .. string_length-1)\n        \n        if(string.charAt(index)==string.charAt(index+1))\n\
    \            counter += 1\n        end\n    end\n    \n    return counter\nend\n\
    </cell>\n<code language=julia-1.5>\n#hide\n\"\"\"\nGiven a string, find out how\
    \ many distinct characters (regardless of case) does it consist of\n\"\"\"", " \
    \   | null string = null\n    | null string =\n    0 \n    | otherwise = \n  \
    \      string |> Seq.length \n        |> Seq.groupBy(_.toChar) \n        |> Seq.length\n\
    </code>\n<|/ a dscore=2 tags=string,f# |>\n<| a tags=string,f# |>\nThis question\
    \ is very old but it was the first result when I googled \"F# count distinct characters\"\
    . The accepted answer doesn't give the correct result. Here is a version that\
    \ does:\n<code>\nopen System.Text.RegularExpressions", "    \"\"\"\n    This function\
    \ counts the distinct characters within a string regardless of case.", "    if\
    \ is_empty(string) then 0\n    else\n        str_length = length(string)\n   \
    \     char_set = set((string[x] for x in range(0, str_length)))\n        char_length\
    \ = length(char_set)\n        if char_length < 2 then 1 else (char_length - 1)\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>", "    count = 0\n    for i\
    \ in string.chars:\n        if string.count(i) > 1 :\n            count += 1\n\
    \    return count", '"""Count distinct characters in string', "    count = 0\n\
    \    for character in string \n        count += 1 if character in string.lower()\
    \ else 0 \n    end\n    return count\nend", "    count_distinct_characters_helper(0,\
    \ \"\", string)\nend\n</cell>\n<text>\nNext, we write a recursive function to\
    \ count the number of distinct characters starting at a given index in a\nstring\
    \ (in Python, we always start counting at 0).", "    length::Int = string.length()\n\
    \    distinctChar::Int64 = 0\n    for i in 0..length-1 do distinctChar += 1 if\
    \ string[i] == string[i+1] else 0\n    return distinctChar", "    if string ==\
    \ \"\"\n    then 0\n    else string.count{char->case char of\n        x when x\
    \ != \"\" then char.asUpper\n        x when x == \"\" then char.asLower\n    \
    \    else char\n    }\nend\n</code>\n<|/ a tags=ocaml |>\n<| a tags=ocaml |>\n\
    <code>\nlet count_distinct_characters(string::String)::Int64 =\n  let rec count_distinct_characters\
    \ (string::String) =\n    match string with\n    | \"\" -> 1\n    | x :: xs ->\
    \ match String.length(x) with\n                | _ when x=String.length(x) ->\
    \ 1 + count_distinct_characters(xs)\n                | _ -> count_distinct_characters(xs)\n\
    \  in\n  count_distinct_characters(string)\n</code>\n<|/ a dscore=0 |>\n<| a tags=ocaml\
    \ |>\nThis function counts the number of distinct characters in a given string.\
    \ Since we know the string has at least one character, we recursively call the\
    \ function with the tail of the string. \n<code>\nlet rec count_distinct_characters\
    \ (string::String)::Int64 = match string.Length 1 with\n    | _ -> 1\n    | x\
    \ -> if x=String.length string.[0] then count_distinct_characters string\n   \
    \           else (count_distinct_characters string.[0]) + 1 ", "    local count::Int64\
    \ = 0\n    for c in string:\n        count = count + 1\n    return count\n</code>\n\
    <|/ a tags=julia dscore=2 |>\n<| c |>\nThis is very elegant, but unfortunately\
    \ for large strings, it allocates many strings internally. As you can see in the\
    \ original question, OP's question is about a large string, not a very long string.\n\
    <|/ c |>\n<| c |>\nYes, but that doesn't change the fact that this solution is\
    \ both memory and speed efficient. Also, I didn't even think of looking up Strings\
    \ in your solution, thanks for teaching me something new!\n<|/ c |>\n<| a tags=julia\
    \ |>\n<code>\njulia> count(x->x \u2208 letters, lowercase(\"zazazaZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZAZ",
  "    if string == \"\"\n        return 0 \n    else \n        return reduce(add,\
    \ map(count_distinct_characters(substring(string, i, i+1)) for i in indices(string)))\n\
    end", "    \"\"\" Given a string, find out how many distinct characters (regardless\
    \ of case) does it consist of\n    >>> count_distinct_characters(\"xyzXYZ\")\n\
    \    3\n    >>> count_distinct_characters(\"Jerry\")\n    4\n    \"\"\"", "  \
    \  if string == \"\"\n        1\n    else\n        count_distinct_characters(tail(string))\
    \ + count_distinct_characters(head(string))\n</code>\nIn a functional language\
    \ like F#, you'd write it like this:\n<code>\nlet count_distinct_characters (string::String)\
    \ = \n    if string = \"\"\n        1\n    else\n        count_distinct_characters\
    \ (tail(string)) + count_distinct_characters (head(string))\n</code>\nIn Rust\
    \ (also functional!), you'd write it like this:\n<code>\nlet count_distinct_characters\
    \ (string: String) = \n    if string == \"\"\n        1\n    else\n        1 +\
    \ count_distinct_characters (tail(string)) + count_distinct_characters (head(string))\n\
    </code>\nIn other functional languages you'd probably use a fold.\n<|/ a tags=recursion,haskell,combinatorics,string,algorithm\
    \ |>\n<| a dscore=2 tags=recursion,haskell,combinatorics,string,algorithm |>\n\
    I think you need to write a recursive function that counts the number of distinct\
    \ characters in a string.  \n<code>\ncountDistinctChars :: String -> Int\ncountDistinctChars\
    \ s = countDistinctChars1 \"\" s\ncountDistinctChars1 s s0 = countDistinctChars2\
    \ s s0 0\ncountDistinctChars2 s s0 count = count + countDistinctChars1 s0 s\n\
    </code>\nThis is pretty inefficient but should work. You'll need to work out the\
    \ base case and recursion.\n<|/ a |>\n<| c |>\n`countDistinctChars1 s s0 = countDistinctChars2\
    \ s s0 0` - should this be `countDistinctChars1 s s0 = countDistinctChars2 s0\
    \ s 0` ? And then countDistinctChars2 is also redundant.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>\ncount :: [Char] -> Int\ncount [] = 0\ncount xs = length xs - length\
    \ $ filter (/='X') xs\n</code>\n<|/ a tags=recursion,haskell,combinatorics,string,algorithm\
    \ |>\n<| c |>\nThis takes care of all characters except 'X'.\n<|/ c |>\n<| a dscore=2\
    \ |>\nHere is how I solved it using recursion:\n<code>\nimport Data.List\ntype\
    \ Char = String", "    distinct = 0\n    for x in string \n        if x != x \n\
    \            distinct+=1 \n            continue \n    \n    return distinct\n\
    </code>\n<|/ a dscore=1 tags=haskell,algorithm |>\n<| c |>\nThis algorithm is\
    \ O(n2), whereas you need a better algorithm. The problem is also the fact that\
    \ `distinct` is a reserved word.\n<|/ c |>\n<| c |>\nOh, I see. Thanks for pointing\
    \ that out, I overlooked the distinct.\n<|/ c |>\n<| a dscore=1 |>\n<code>\nimport\
    \ Data.List\nimport Data.Maybe (fromJust)", "        \n    # Write your code here\n\
    \    unique_char = string.distinct_chars()\n    unique_char = unique_char.len()\n\
    \    return unique_char\nend\n</cell>\n<code language=julia-1.4>\ncount_distinct_characters(\"\
    \")\n</cell>\n<code language=julia-1.4>\ncount_distinct_characters(\"a\")\n</cell>\n\
    <code language=julia-1.4>\ncount_distinct_characters(\"abc\")\n</cell>\n<code\
    \ language=julia-1.4>\ncount_distinct_characters(\"abca\")\n</cell>\n<code language=julia-1.4>\n\
    count_distinct_characters(\"abcaX\")\n</cell>\n<code language=julia-1.4>\ncount_distinct_characters(\"\
    abcaXY\")\n</cell>\n<code language=julia-1.4>\ncount_distinct_characters(\"abcaXYZ\"\
    )\n</cell>\n<code language=julia-1.4>\ncount_distinct_characters(\"ABCA\")\n</cell>\n\
    <code language=julia-1.4>\ncount_distinct_characters(\"ABCAXYZ\")\n</cell>\n<code\
    \ language=julia-1.4>\ncount_distinct_characters(\"AXYZ\")\n</cell>\n<text>\n\
    @which\nThe @which function is a shortcut for writing multiple statements on the\
    \ same line. As it is often useful to check the position of a function call in\
    \ a block of code, @which can be used on multiple statements.", "    \"\"\"\n\
    \    >>> count_distinct_characters(\"xyzXYZ\")\n    3\n    >>> count_distinct_characters(\"\
    Jerry\")\n    4\n    \"\"\"\n    distinct_characters::Set[String] = Set()\n  \
    \  for ch in string:\n        if ch in distinct_characters:\n            distinct_characters.remove(ch)\n\
    \        else:\n            distinct_characters.add(ch)\n    return len(distinct_characters)\n\
    </code>\n<|/ a tags=string,performance,algorithm,python |>\n<| a |>\nAnother simple\
    \ solution without using set is to keep an array, and use while loop to count\
    \ the different characters. Since set takes O(n) time for a lookup and you do\
    \ it in a while loop, total time complexity is O(n)\n<code>\ndef count_distinct_characters(string):\
    \ \n    unique_chars=[] \n    count=0\n    for c in string: \n        if c not\
    \ in unique_chars: \n            unique_chars.append(c) \n        else: \n   \
    \         count += 1 \n    return count \n</code>\n<|/ a dscore=2 tags=string,performance,algorithm,python\
    \ |>\n<| c |>\nThis is O(n^2) time complexity!\n<|/ c |>\n<| a dscore=1 |>\nYou\
    \ can do it this way:\n<code>\ndef count_distinct_characters(string):\n  count=0\n\
    \  chars=[]\n  for c in string:\n    if c in chars:\n      count+=1\n    else:\n\
    \      chars.append(c)\n  return count", "     \"\"\"\n     Given a string, find\
    \ out how many distinct characters (regardless of case) does it consist of\n \
    \   >>> count_distinct_characters(\"xyzXYZ\")\n    3\n    >>> count_distinct_characters(\"\
    Jerry\")\n    4\n    \"\"\"", "    \"\"\"\n    Number of distinct characters in\
    \ the string\n    \n    >>> count_distinct_characters(\"xyzXYZ\")\n    3\n   \
    \ >>> count_distinct_characters(\"Jerry\")\n    4\n    \"\"\"", "    count::Int64\
    \ = 0\n    for c in string:\n        if c.isLower():\n            count += c.isUpper()\n\
    \        elif c.isUpper():\n            count += c.isLower()\n        else:\n\
    \            count += 1\n    return count\n</cell>\n<code language=julia-1.3>\n\
    count_distinct_characters(\"xyzXYZ\")\n</cell>\n<text>\n5.3 Sort an array of characters\n\
    Implement a function that can sort an array of characters", "\"\"\"Return how\
    \ many distinct characters does it consist of \"\"\"\n    \n    \n@test \"count_distinct_characters\
    \ is correct when given correct input\" begin\n    @test count_distinct_characters(\"\
    xyzXYZ\") == 3\n    @test count_distinct_characters(\"Jerry\") == 4\n    @test\
    \ count_distinct_characters(\"Melba\") == 5\n    @test count_distinct_characters(\"\
    Melba is my favorite food\") == 5\n    @test count_distinct_characters(\"Melba\
    \ is my favorite Food.\") == 5\nend", "    if is_empty(string) then return 0\n\
    \    if is_empty(string::String) then return 0\n    \n    let mut num_distinct_characters\
    \ = 1\n    let mut current_char = string.head\n    let mut previous_char = string.head\n\
    \    \n    for next_char in string.tail {\n        if previous_char == current_char\
    \ then\n            num_distinct_characters += 1\n            current_char = next_char\n\
    \        else if is_char_case_insensitive(current_char) then\n            num_distinct_characters\
    \ += 2\n        \n        previous_char = current_char\n    }\n    \n    return\
    \ num_distinct_characters\nend\n</cell>\n<text>\nWhat if we wanted to calculate\
    \ the minimum number of distinct characters in our string?\nThis would make our\
    \ function look like:", "    if string == \"\" then return 0 \n    let chars =\
    \ string.map(fun c -> if isUpper(c) then 1 else if isLower(c) then 2 else 0 end)\
    \ |> List.ofSeq \n    let distinct_chars = List.fold_left( fun (c,i) (c0,c1) ->\
    \ ( c0,c1 + if c0 == c1 then 1 else 0 ) ) chars (0,0) \n    List.fold_left( fun\
    \ acc i -> acc + distinct_chars.[i] ) distinct_chars 0 \nend", "    if string.size\
    \ == 0 \n        return 0 \n    else \n        local total = 0 \n        local\
    \ i = 0 \n        local character = string.sub(1, 1) \n        while i < string.size\
    \ \n            do \n                local char = string.sub(i, i) \n        \
    \        if char == character \n                    then \n                  \
    \      character = string.sub(i, i + 1) \n                    else \n        \
    \                character = char \n                end \n                total\
    \ = total + 1 \n            end \n            i = i + 1 \n        end \n    return\
    \ total \nend\n</cell>\n<code language=julia-1.6>", "  count_distinct_characters\
    \ = String.length(string) - count_distinct_characters(String.replace(string, \"\
    .\", \"\"))\nend function count_distinct_characters\n</cell>\n<code language=julia-1.4>",
  "    \"\"\"\n    Count how many distinct characters (regardless of case) does it\
    \ consist of\n    >>> count_distinct_characters(\"xyzXYZ\")\n    3\n    >>> count_distinct_characters(\"\
    Jerry\")\n    4\n    \"\"\"\n    \n\"\"\"\n    count_distinct_letters(string::String)::Int64 ",
  "    \"\"\"\n    Count distinct characters\n    >>> count_distinct_characters(\"\
    abc\")\n    3\n    >>> count_distinct_characters(\"abA\")\n    1\n    \"\"\"",
  "    string = tostring(string)\n    return sum((string.charAt(i) == string.charAt(i).tolower())\
    \ * (1 + i) for i in range(string.length()))\nend\n</cell>\n<code language=julia-1.6>\n\
    count_distinct_characters(\"xyzXYZ\")\n</cell>\n<text>\nQuestion 3. Write a function\
    \ that given a string, return the length of the longest substring contained in\
    \ the given string, ignoring case.", "    cdef int count = 0\n    cdef int current_char\
    \ = 0\n    cdef char temp", "    let characters = String.map(char->char) string\
    \ in \n    characters.count{ char=>(char.upcase())::char }\nend", "    string\
    \ |> String.toLowerCase |> String.toUpperCase |> String.length |> sum\n</code>\n\
    This is just a simple function but I am a beginner so this is what I did.\nFirst,\
    \ I converted the string into lowercase and uppercase. Then, I converted the length\
    \ of the string into an integer and used sum function on it to find the sum of\
    \ the distinct characters in the string. \nIs this the right way to do it?\n<|/\
    \ q |>\n<| c |>\n\"Is this the right way to do it\" - yes, in fact, this is probably\
    \ the most efficient way to do it. Note that there is nothing wrong with your\
    \ solution. There are other ways to do this as well, but this is definitely the\
    \ simplest.\n<|/ c |>\n<| c |>\n`String.toLowerCase |> String.toUpperCase |> String.length\
    \ |> sum` is equivalent to `string.Length` and is slightly more efficient.\n<|/\
    \ c |>\n<| c |>\nYeah, that makes sense. Thanks for the suggestion.\n<|/ c |>\n\
    <| c |>\nBut why do you use pipe?\n<|/ c |>\n<| c |>\nThe pipe is a short-circuit\
    \ operator, meaning it is only evaluated when absolutely necessary. For more information\
    \ see: https://julialang.org/blog/2017/01/short-circuit-evaluation/\n<|/ c |>\n\
    <| a tags=string,count,julia dscore=3 |>\nIf you want a slightly shorter version,\
    \ this should also work:\n<code>\nstring.(unique.(string.(lowercase(string.(uppercase(string))))))\n\
    </code>\nThe main difference here is that you use unique instead of count. Also,\
    \ it would be nice to avoid the string operations altogether and write something\
    \ like:\n<code>\nstring.(collect.(Int,collect.(Set,unique.(lowercase(uppercase(string)))))\n\
    </code>\nThe only thing that makes this a bit \"cleaner\" is that you can write\
    \ collect.(Set,unique.(lowercase(uppercase(string))) instead of collect.(Set,string.(lowercase(uppercase(string)))).\n\
    <|/ a |>\n<| c |>\nThe `unique` version is probably the most efficient. The `string.(unique.(string.(lowercase(string.(uppercase(string))))))`\
    \ is just ugly.\n<|/ c |>\n<| c |>\nAgreed. I would write `string.(collect.(Int,collect.(Set,unique.(lowercase(uppercase(string)))))`\
    \ myself as it is slightly shorter and easier to understand. I will update my\
    \ answer accordingly.\n<|/ c |>\n<| c |>\n", "    if string == \"\" then 1 else\
    \ 0 \n    else 1 + count_distinct_characters(chars(string))\n</code>\n<|/ a tags=julia\
    \ |>\n<| c |>\nThanks Chris. This is very helpful. BTW I appreciate you mentioning\
    \ how I should avoid mutating state in Julia. I'm new to Julia and trying to get\
    \ my bearings on best practices.\n<|/ c |>\n<| c |>\nAlso I like the concise `chars`\
    \ and `char_counts` functions. I did not know about those in the past. Thanks!\n\
    <|/ c |>\n<| c |>\nGlad I could help! Also for the other functions: you can do\
    \ `isa` and then `all` on the result. Also, you can use the `length` function,\
    \ which can be useful when you want to know how many characters are in a string:\
    \ `length(\"abcd\")`\n<|/ c |>\n<| a dscore=0 |>\nA solution that doesn't use\
    \ recursion:\n<code>\ncount_chars(string::String)::Int64 = length(unique(sort(string.chars)))\n\
    </code>\n<|/ a tags=julia |>\n<| c |>\nYou just reused a method that already existed\
    \ in Python\n<|/ c |>\n<| c |>\nYeah, I guess I should have been more explicit\
    \ about the intention of the answer. You're right, that doesn't necessarily make\
    \ a lot of sense, especially since the original question doesn't have that much\
    \ relevance.\n<|/ c |>\n<| c |>\nHi Thibaud, thanks for this. This is great and\
    \ very clear. Thanks!\n<|/ c |>\n<| c |>\nThe original question doesn't make too\
    \ much sense, either, since Julia is pretty much based on Python.\n<|/ c |>\n\
    <| a tags=julia |>\nIn addition to the other answers provided here, it's worth\
    \ noting that Julia provides a string function countchars that you can use to\
    \ count the number of occurrences of each character in a string.\n<code>\njulia>\
    \ countchars(\"aaaab\")\nDict{ASCIIString,Int64} with 7 entries:\n  \"a\" => 1\n\
    \  \"b\" => 2\n  \"c\" => 1\n  \"A\" => 1\n  \"B\" => 1\n  \"?\" => 1\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nYes, `countchars` is great for counting individual\
    \ characters, but not so great for counting *distinct* characters, which is the\
    \ case here. While `countchars` is also not terribly slow, it is *much", "   \
    \ if string.length()==0 \n        return 0 \n    var num::Int64 = 0\n    var i::Int64\
    \ = 0\n    var ch::Char", "    \n\"\"\"\n    >>> count_distinct_characters(\"\
    Jerry\")\n    4\n    \"\"\"", "    mutable count_distinct = 0\n    for i in string.characters\
    \ {\n        if count_distinct == 0\n            count_distinct += 1\n       \
    \ else\n            count_distinct += count_distinct % 26\n        count_distinct\
    \ %= 26\n    }\n    return count_distinct\nend\n</cell>\n<text>\nNow let's try\
    \ it out!", "    \n    count = 0\n    \n    string.to_lowercase()\n    string.to_uppercase()\n\
    \    \n    for i in string.characters\n        \n        if i.is_uppercase()\n\
    \            count = count + 1\n        \n        if i.is_lowercase()\n      \
    \      count = count + 1\n    \n    return count", "    \"Given a string, find\
    \ out how many distinct characters (regardless of case) does it consist of\"\n\
    \    characters = string.characters\n    chars = characters.filter(|c|c.isUpperCase\
    \ or c.isLowerCase or c.isLetter)\n    chars = chars.map(|c|c.lower)\n    unique_chars\
    \ = chars.distinct\n    unique_chars = unique_chars.reduce(|a, b| a + b)\n   \
    \ return unique_chars\nend", "\t\n\tif string == nil\n\t\treturn 0\n\t\n\tlength\
    \ :: Int64 = string.len()\n\tif length == 0\n\t\treturn 0\n\t\n\tcharCount ::\
    \ Int64 = 0\n\tfor i from 1 to length\n\t\tcharCount += count_distinct_characters_aux(string[i])\n\
    \t\n\treturn charCount\nend count_distinct_characters", "{\n    var char_to_index_map\
    \ = Map[Char,Int64]()\n    for ch in string.chars do\n        char_to_index_map[ch]\
    \ = char_to_index_map[ch] + 1\n    }\n    \n    var distinct = 0\n    for ch in\
    \ string.chars do\n        if char_to_index_map[ch] == 1 then\n            distinct\
    \ += 1\n        }\n    return distinct\n}\n</cell>\n<code language=julia-1.4>\n\
    count_distinct_characters(\"xyzXYZ\")\n</cell>\n<text>\nGiven a string and a character,\
    \ find out how many times that character appears in the string.", "    \n    count_distinct_characters\
    \ <- function(string::String)\n    \n    count_distinct_characters <- length unique(unlist(strsplit(string,\
    \ \"\")))\n    \n    return count_distinct_characters", "    \"\"\"\n    Count\
    \ the distinct characters in a string", "    \n    characters = string.chars()\n\
    \    \n    let mut count = 0;\n    for c in characters do\n        if c == c.toLower()\
    \ || c == c.toUpper() || c == c.toTitle() || c == c.toLower().chars().filter(|c|c=='_').count()\
    \ \n            || c == c.toUpper().chars().filter(|c|c=='_').count() \n     \
    \       || c == c.toTitle().chars().filter(|c|c=='_').count() \n            ||\
    \ c == c.chars().filter(|c|c=='_').count() \n            || c == c.chars().filter(|c|c=='_').count()\
    \ \n            || c == c.chars().filter(|c|c=='_').count() \n            || c\
    \ == c.chars().filter(|c|c=='_').count() \n            || c == c.chars().filter(|c|c=='_').count()\
    \ \n            || c == c.chars().filter(|c|c=='_').count() \n            || c\
    \ == c.chars().filter(|c|c=='_').count() \n            || c == c.chars().filter(|c|c=='_').count()\
    \ \n            || c == c.chars().filter(|c|c=='_').count() \n            || c\
    \ == c.chars().filter(|c|c=='_').count() \n            || c == c.chars().filter(|c|c=='_').count()\
    \ \n            || c == c.chars().filter(|c|c=='_').count() \n            || c\
    \ == c.chars().filter(|c|c=='_').count() \n            || c == c.chars().filter(|c|c=='_').count()\
    \ \n            || c == c.chars().filter(|c|c=='_').count() \n            || c\
    \ == c.chars().filter(|c|c=='_').count() \n            || c == c.chars().filter(|c|c=='_').count()\
    \ \n            || c == c.chars().filter(|c|c=='_').count() \n            || c\
    \ == c.chars().filter(|c|c=='_').count() \n            || c == c.chars().filter(|c|c=='_').count()\
    \ \n            || c == c.chars().filter(|c|c=='_').count() \n            || c\
    \ == c.chars().filter(|c|c=='_').count() \n            || c == c.chars().filter(|c|c=='_').count()\
    \ \n            || c == c.chars().filter(|c|c=='_').count() \n            || c\
    \ == c.chars().", "    count := 0\n    for char::Char in string do\n        count\
    \ += count_distinct_characters_helper(char)\n    return count\nend \"\"\"", " \
    \ \n    \"\"\"Count distinct characters\"\"\"", "    char_map = Dict{Char, Int}()\n\
    \    for c in string.characters\n        if !haskey(char_map, c)\n           \
    \ char_map[c] = 0\n        end\n        char_map[c] += 1\n    return length(keys(char_map))\n\
    end", "    \"\"\"\n    Count the distinct characters of a given string.", "  \
    \  if string.length == 0\n        0\n    elseif string.length == 1\n        1\n\
    \    else\n        string.length * (count_distinct_characters(string[0..length\
    \ -1]) + count_distinct_characters(string[1..]))\nend\n</cell>\n<text>\nExercise\
    \ 1\nThe function count_distinct_characters takes a string as input and returns\
    \ a number (the length of the string) that is equal to the number of distinct\
    \ characters in the string.  Write a function that will do the same thing as the\
    \ count_distinct_characters function above, but will be able to count the unique\
    \ characters in the string.", "</code>\n<|/ a tags=haskell,types,string |>\n<|\
    \ c |>\n`[1..]` should be `1:` and you forgot `:`\n<|/ c |>\n<| c |>\nYeah, `[1..]`\
    \ will give an error, but if you change it to `1:` it will return a list of numbers\
    \ starting from `1`, which is an `Int64`. Thanks for pointing it out, I fixed\
    \ it.\n<|/ c |>\n<| c |>\n`count_distinct_characters = length . filter (not .\
    \ isUppercase) . map toUpper`\n<|/ c |>\n<| c |>\nI think `filter` will always\
    \ return a `Bool`, so you can just remove it. I think it can be done in a single\
    \ line.\n<|/ c |>\n<| a tags=haskell,types,string |>\nI hope this will help you\
    \ understand how you can do it:\n<code>\ncount_distinct_characters :: String ->\
    \ Int\ncount_distinct_characters \"\" = 0\ncount_distinct_characters xs = length\
    \ xs - length $ filter (/=' ') xs\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis works\
    \ very well for me. Thank you very much for the explanation!\n<|/ c |>\n<| a tags=haskell,types,string\
    \ |>\n<code>\nimport Data.Char", "        use CountDistinctCharacters\n      \
    \  if string == \"\"\n            count = 0\n        else\n            count =\
    \ CountDistinctCharacters(string)\n        end\n    return count", "    # O(1)\
    \ time complexity\n    return count(\"[a-mA-M]\", string)\nend", "    distinct_chars\
    \ = \"\"\n    for i in string:\n        if not(i in distinct_chars) then\n   \
    \         distinct_chars = distinct_chars + i\n        end\n    end\n    return\
    \ length(distinct_chars)\nend\n</code>\n<|/ a tags=julia |>\n<| a tags=julia |>\n\
    A solution that uses iterators and functional programming. \n<code>", "    if\
    \ string == \"\"\n        1\n    else\n        let count = count_distinct_characters(tail(string))\n\
    \        if count == 0\n            1\n        else\n            1 + count + 1\n\
    \        end\n    end\nend\n</code>\n<|/ a tags=count,string,julia dscore=2 |>\n\
    <| a dscore=0 tags=count,string,julia |>\n<code>", '    # write your code here',
  "    unique_chars = Set{Char}(Char.('a'))\n    unique_chars |= Set{Char}(Char.('b'))\n\
    \    unique_chars |= Set{Char}(Char.('c'))\n    unique_chars |= Set{Char}(Char.('d'))\n\
    \    unique_chars |= Set{Char}(Char.('e'))\n    unique_chars |= Set{Char}(Char.('f'))\n\
    \    unique_chars |= Set{Char}(Char.('g'))\n    unique_chars |= Set{Char}(Char.('h'))\n\
    \    unique_chars |= Set{Char}(Char.('i'))\n    unique_chars |= Set{Char}(Char.('j'))\n\
    \    unique_chars |= Set{Char}(Char.('k'))\n    unique_chars |= Set{Char}(Char.('l'))\n\
    \    unique_chars |= Set{Char}(Char.('m'))\n    unique_chars |= Set{Char}(Char.('n'))\n\
    \    unique_chars |= Set{Char}(Char.('o'))\n    unique_chars |= Set{Char}(Char.('p'))\n\
    \    unique_chars |= Set{Char}(Char.('q'))\n    unique_chars |= Set{Char}(Char.('r'))\n\
    \    unique_chars |= Set{Char}(Char.('s'))\n    unique_chars |= Set{Char}(Char.('t'))\n\
    \    unique_chars |= Set{Char}(Char.('u'))\n    unique_chars |= Set{Char}(Char.('v'))\n\
    \    unique_chars |= Set{Char}(Char.('w'))\n    unique_chars |= Set{Char}(Char.('x'))\n\
    \    unique_chars |= Set{Char}(Char.('y'))\n    unique_chars |= Set{Char}(Char.('z'))\n\
    \    for c in string\n        unique_chars |= Set{Char}(Char(c))\n    end\n  \
    \  return length(unique_chars)\nend\n</cell>\n<code language=julia-1.6>", "  \
    \  \"\"\"\n    >>> count_distinct_characters(\"xyzXYZ\")\n    3\n    >>> count_distinct_characters(\"\
    Jerry\")\n    4\n    \"\"\"\n</code>\n<|/ a tags=string,python dscore=2 |>\n<|\
    \ a dscore=0 tags=string,python |>\nHere's a solution using itertools. \n<code>\n\
    from itertools import chain\ndef count_distinct_characters(text):\n    \"\"\"\n\
    \    >>> count_distinct_characters('abc')\n    3\n    >>> count_distinct_characters('abcA')\n\
    \    3\n    >>> count_distinct_characters('abcAAA')\n    3\n    >>> count_distinct_characters('abcAAAAB')\n\
    \    3\n    >>> count_distinct_characters('abcAAAABCD')\n    3\n    >>> count_distinct_characters('abcAAAABCD')\n\
    \    3\n    >>> count_distinct_characters('abcAAAABCD')\n    3\n    >>> count_distinct_characters('abcAAAABCD')\n\
    \    3\n    >>> count_distinct_characters('abcAAAABCD')\n    3\n    >>> count_distinct_characters('abcAAAABCD')\n\
    \    3\n    >>> count_distinct_characters('abcAAAABCD')\n    3\n    >>> count_distinct_characters('abcAAAABCD')\n\
    \    3\n    >>> count_distinct_characters('abcAAAABCD')\n    3\n    >>> count_distinct_characters('abcAAAABCD')\n\
    \    3\n    \"\"\"\n    return len(set(chain.from_iterable(text)))", "    count\
    \ = 0\n    for c in string:\n        if string.count(c) == 1 and string.count(c)\
    \ == string.count(c.upcase()) and string.count(c) == string.count(c.downcase())\
    \ then\n            count += 1\n        end \n    end\n    return count\nend\n\
    </cell>\n<text>\n4. Write a function that takes two strings, compares their characters\
    \ and then prints the result on a new line (without any extra spaces)", "  | (string\
    \ == \"\") || count_distinct_characters(string[1:length(string)])\n  | count!(groupby(string))\n\
    \  | count!(groupby(lower))\n  | count!(groupby(upper))\n  | count!(groupby(reverse))\n\
    \  | count!(groupby(string[end]))\n  | count!(groupby(string[end-1:-1:1]))\n \
    \ | count!(groupby(string[end-2:end:1]))\n  | count!(groupby(string[end-3:end:2]))\n\
    \  | count!(groupby(string[end-4:end:2]))\n  | count!(groupby(string[end-6:end:2]))\n\
    \  | count!(groupby(string[end-7:end:2]))\n  | count!(groupby(string[end-9:end:2]))\n\
    \  | count!(groupby(string[end-10:end:2]))\n  | count!(groupby(string[end-11:end:2]))\n\
    \  | count!(groupby(string[end-12:end:2]))\n  | count!(groupby(string[end-5:end:2]))\n\
    \  | count!(groupby(string[end-8:end:2]))\n  | count!(groupby(string[end-13:end:2]))\n\
    \  | count!(groupby(string[end-14:end:2]))\n  | count!(groupby(string[end-21:end:2]))\n\
    \  | count!(groupby(string[end-22:end:2]))\n  | count!(groupby(string[end-23:end:2]))\n\
    \  | count!(groupby(string[end-24:end:2]))\n  | count!(groupby(string[end-25:end:2]))\n\
    \  | count!(groupby(string[end-26:end:2]))\n  | count!(groupby(string[end-27:end:2]))\n\
    \  | count!(groupby(string[end-28:end:2]))\n  | count!(groupby(string[end-31:end:2]))\n\
    \  | count!(groupby(string[end-32:end:2]))\n  | count!(groupby(string[end-33:end:2]))\n\
    \  | count!(groupby(string[end-34:end:2]))\n  | count!(groupby(string[end-35:end:2]))\n\
    \  | count!(groupby(string[end-36:end:2]))\n  | count!(groupby(string[end-37:end:2]))\n\
    \  | count!(groupby(string[end-38:end:2]))\n  | count!(groupby(string[end-39:end:2]))\n\
    \  | count!(groupby(string[end-40:end:2]))\n  | count!(groupby(string[end-56:end:2]))\n\
    \  | count!(groupby(string[end-57:end:2]))\n  | count!(groupby(string[end-58:end:2]))\n\
    \  | count!(groupby(string[end-61:end:2]))\n  | count!(groupby(string[end-62:end:2]))\n\
    \  | count!(groupby(string[end-63:end:2]))\n  | count!(groupby(string[end-64:end:2]))\n\
    \  | ", "    if len(string) <= 1\n        return string.length()\n    \n    chars\
    \ = string.to_lowercase()\n    char_counter = 0\n    \n    for char in chars\n\
    \        if chars.contains(char)\n            char_counter += 1\n            chars\
    \ = chars.drop(chars.index(char))\n            \n    return char_counter\nend",
  "    count::Int64 = 0\n    \n    for c in string:\n        if string[c] >= \"A\"\
    \ and string[c] <= \"Z\":\n            count += 1\n        else:\n           \
    \ count += 1\n    return count\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for\
    \ answering, I think I do need to add an additional case check for the capital\
    \ letters as well (I updated the original post to include that as well).  Does\
    \ that seem feasible?\n<|/ c |>\n<| c |>\nYes, you can add the additional check\
    \ for capital letters (by adding the condition to your `if` statement like so:\
    \ `if string[c] >= \"A\" and string[c] <= \"Z\" or string[c] >= \"a\" and string[c]\
    \ <= \"z\":`). But that means you now have to add an additional check in your\
    \ `else` statement to determine if the letter was upper or lower case. So you\
    \ will have two `if` statements inside of your `else` statement. Not a big deal,\
    \ but I think it might be a bit less clear. Personally, I would just add the additional\
    \ check in the `if` statement.\n<|/ c |>\n<| a dscore=2 |>\nHere's my take on\
    \ this\n<code>\nimport Data.List", "    if string==\"\" then 0 else count_distinct_characters(string[1:])\
    \ + count_distinct_characters(string[:1])\n</code>\n<|/ a tags=count,algorithm,string,python\
    \ |>\n<| a dscore=1 |>\nYou can use collections.Counter:\n<code>\nimport collections\n\
    s = 'xyzABC'\ncounter = collections.Counter(s)\nprint(counter.most_common()) #\
    \ [('B', 2), ('A', 1), ('C', 2)]\n</code>\n<|/ a tags=count,algorithm,string,python\
    \ |>\n<| a tags=count,algorithm,string,python dscore=1 |>\nYou can use this simple\
    \ function without using any library:\n<code>\ndef count_distinct_characters(string):\n\
    \    counter = {}\n    \n    for c in string:\n        if c in counter:\n    \
    \        counter[c] += 1\n        else:\n            counter[c] = 1\n    \n  \
    \  return len(counter)\n</code>\n<|/ a |>\n<| a tags=count,algorithm,string,python\
    \ dscore=1 |>\n<code>\ndef count_distinct_characters(string):\n    count = 0\n\
    \    \n    for i in range(len(string)):\n        \n        for j in range(len(string)):\n\
    \            \n            if i != j and string[i] == string[j]:\n           \
    \     count += 1\n                break\n    \n    return count\n</code>\n<|/\
    \ a |>\n<| a dscore=0 |>\nAnother approach (using itertools.permutations):\n<code>\n\
    from itertools import permutations", "    cdef long count\n    cdef int i\n  \
    \  cdef string character\n    for i in xrange(len(string)):\n        character\
    \ = string[i]\n        if character.isupper():\n            count +=1\n      \
    \  else:\n            count +=2\n    return count\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=0 |>\nA solution using itertools.groupby:\n<code>\ndef count_distinct_characters(s):\n\
    \    return sum(len(list(v)) for k, v in itertools.groupby(s))\n</code>\n<|/ a\
    \ tags=python,algorithm,time-complexity |>\n<| a dscore=0 |>\nI find it more efficient\
    \ using numpy to do this\n<code>\ndef count_distinct_characters(s):\n    chars\
    \ = np.char.lower(s)\n    return len(np.unique(chars))\n</code>\n<|/ a tags=python,algorithm,time-complexity\
    \ |>\n<| a dscore=0 |>\nIn terms of time complexity, the solutions given so far\
    \ have all had O(n2) time complexity. Here's another solution that has linear\
    \ time complexity:\n<code>\ndef count_distinct_characters(s):\n    count_dict\
    \ = {}\n    for c in s:\n        count_dict[c] = count_dict.get(c, 0) + 1", " \
    \   cdef int distinct_characters\n    for character in string:\n        if character\
    \ == character:\n            distinct_characters += 1\n        else:\n       \
    \     distinct_characters = 0\n    return distinct_characters", "    \n    \n\
    \    # Convert to lower case\n    string_lower_case = string.lower()\n    \n \
    \   # Initialize count\n    count = 0\n    \n    # Iterate over characters in\
    \ string\n    for character in string_lower_case:\n        # Increment count if\
    \ this character is not already present\n        if character not in string:\n\
    \            count += 1\n    \n    # Return count\n    return count", "    string\
    \ = string.lower()\n    return sum( x != string[i] for x in string )\nend", "\"\"\
    \"\n    >>> count_distinct_characters(\"Jerry\")\n    4\n    >>> count_distinct_characters(\"\
    abcABC\")\n    5\n    >>> count_distinct_characters(\"A long string with no spaces.\
    \ Yes, with spaces.\")\n    10\n    \"\"\"", "    distinct = 0\n    for i in string.chars\n\
    \        if not(i.is_upper) or not(i.is_lower)\n            distinct+=1\n    return\
    \ distinct\n</code>\n<|/ a dscore=3 |>\n<| a |>\nHere's a recursive solution:\n\
    <code>\nlet count_distinct_characters(string::String)::Int = \n    if String.length\
    \ string <= 1 then 1 else 0", "    if string == \"\" then return 0 else count_distinct_characters(string[1:])\
    \ + 1\n    else if string[1] != string[2] then return 1 \n    else if string[1]\
    \ != string[3] then return 1 \n    else if string[2] != string[3] then return\
    \ 1 \n    else if string[4] != string[5] then return 1 \n    else if string[5]\
    \ != string[6] then return 1 \n    else if string[7] != string[8] then return\
    \ 1 \n    else if string[9] != string[10] then return 1 \n    else return count_distinct_characters(string[1..$])\
    \ + 1\nend", "    if string == \"\" \n        then return 0 \n        else \n\
    \            let mutable count = 0 \n            for c in string:\n          \
    \      if case_insensitive(c) == c \n                    then count = count+1\n\
    \                    else count = count \n            return count \n    end\n\
    end count_distinct_characters\n</code>\n<|/ a dscore=1 tags=string,algorithm,python\
    \ |>\n<| a tags=string,algorithm,python |>\nI like how it works, but I like how\
    \ it does it without loops, using recursion. I think it's easier to understand\
    \ and more efficient.\n<code>\ndef count_distinct_characters(word):\n    distinct_characters\
    \ = 0\n    word_length = len(word)\n    \n    if word_length == 0:\n        return\
    \ distinct_characters\n    elif word_length == 1:\n        distinct_characters\
    \ = 1\n        return distinct_characters\n    else:\n        distinct_characters\
    \ = count_distinct_characters(word[1:]) + 1\n        return distinct_characters",
  "    if string == null \n        0\n    else\n        length(unique(string))\nend\n\
    </code>\n<|/ a |>\n<| a tags=string,julia |>\nThis solution finds the amount of\
    \ characters in a string which are not duplicates in Julia.\n<code>", "    distinct::Int64\
    \ = 0\n    \n    for c in string:\n        if c in string.lowercase():\n     \
    \       distinct += 1 # add 1 to distinct\n        elif c in string.uppercase():\n\
    \            distinct += 2\n        else:\n            distinct += 3\n    \n \
    \   return distinct\nend # count_distinct_characters\n</cell>\n<code language=julia-1.5>\n\
    @test count_distinct_characters(\"xyzXYZ\") == 2\n@test count_distinct_characters(\"\
    Jerry\") == 4\n</cell>\n<code language=julia-1.5>\n@doc count_distinct_characters\n\
    </cell>\n<text>\nExercise 4.21\nWrite a function which takes a string of lowercase\
    \ characters only, and returns how many distinct characters it has.", "    |\n\
    \    if string == \"\"\n        0\n    else\n        1 + count_distinct_characters(string[1:length(string)])\n\
    \    end \nend\n</code>\n<|/ a tags=string,julia,character-encoding,utf-8 |>\n\
    <| a dscore=2 |>\nBased on Michael Feathers answer, this is my solution:\n<code>",
  "    \n    chars = string.to_uppercase().to_lowercase()\n    \n    return length(unique(chars))\n\
    end\n</cell>\n<code language=julia-1.4>", "        \n    # get the number of characters\n\
    \    n::Int64 = length(string)\n    \n    # initialize a count variable\n    count::Int64\
    \ = 0\n    \n    # loop through the string\n    for i in 1:n do\n        # check\
    \ if the character is the same case\n        if lower(char(string[i]))==lower(char(string[i]))\
    \ then\n            count = count + 1\n        end\n    end\n    \n    return\
    \ count\nend\n</cell>\n<code language=julia-1.5>\ncount_distinct_characters(\"\
    xyzXYZ\")\n</cell>\n<code language=julia-1.5>\ncount_distinct_characters(\"Jerry\"\
    )\n</cell>\n<text>\nQuestion 11. Implement a function which takes a string and\
    \ returns the number of distinct letters it is composed of. Note: do not count\
    \ spaces or punctuation. Make sure your function works on strings consisting entirely\
    \ of characters and empty strings.", "    count = 0\n    for c in string:\n  \
    \      if c.isUpperCase():\n            count += 1\n        elif c.isLowerCase():\n\
    \            count += 1\n        elif c.isSpecialChar():\n            count +=\
    \ 1\n    return count\n</code>\n<|/ a tags=string,lowercase,uppercase,python dscore=2\
    \ |>\n<| a dscore=2 |>\nIf you're looking for a quicker solution, one way would\
    \ be to convert the string into an array of characters, then get the length of\
    \ that.\n<code>\ndef count_distinct_characters(string)\n  string.to_a().length\n\
    end\n</code>\nOr you could use a lambda.\n<code>\ndef count_distinct_characters(string)\n\
    \  string.to_a().map(&:casecmp).uniq.count\nend\n</code>\nOr more tersely with\
    \ map + count\n<code>\ndef count_distinct_characters(string)\n  string.to_a().map(&:casecmp).uniq.count\n\
    end\n</code>\nOr more tersely with reduce\n<code>\ndef count_distinct_characters(string)\n\
    \  string.to_a().map(&:casecmp).reduce(0,:+).count\nend\n</code>\n<|/ a tags=string,lowercase,uppercase,python\
    \ |>\n<| a dscore=2 tags=string,lowercase,uppercase,python |>\n<code>\nfrom itertools\
    \ import zip_longest", "    if string == \"\" \n        then return 0 \n    else\n\
    \        let chars = [for x in string]\n        in List.fold_left (+) 0 chars\n\
    \    end\nend", "  if string == \"\" then\n    0\n  else\n    chars = string.characters\n\
    \    (count_distinct_characters(chars.head) + count_distinct_characters(chars.tail))\n\
    \  end\nend\n\"\"\"\ncount_distinct_characters(string::AbstractString)::Int64",
  "    \"Counts how many distinct characters are in string\"\n    return count_characters(string)\
    \ - count_characters(lowercase(string))\nend", "    \n    str = string:to_lowercase()\n\
    \    \n    for i in str:\n        if str.count(i)==1:\n            continue\n\
    \        else:\n            return str.count(i)\n            break\nend", "  \
    \  count_distinct = 0\n    for c in string:\n        if string[count_distinct]\
    \ != c:\n            count_distinct += 1\n        end\n    return count_distinct\n\
    end", "\"\"\"\n    >>> count_distinct_characters(\"xyzXYZ\")\n    3\n    >>> count_distinct_characters(\"\
    Jerry\")\n    4\n    \"\"\"", "    \"\"\"\n    >>> count_distinct_characters(\"\
    xyzXYZ\")\n    3\n    >>> count_distinct_characters(\"Jerry\")\n    4\n    \"\"\
    \"", "    if string == \"\" \n        then 0\n        else 1 + count_distinct_characters(sub_string(string))\
    \ \n    end \nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis does not seem to\
    \ work if the string starts with a vowel or if the string ends with a vowel. Perhaps\
    \ you could explain your algorithm a little bit more?\n<|/ c |>\n<| c |>\nThis\
    \ implementation is actually incorrect. Having said that, it is very similar to\
    \ the answer provided by.\n<|/ c |>\n<| a |>\nHere is my solution to this question\
    \ with some slight modifications from's.\n<code>", "    count_distinct_chars =\
    \ foldl1(\n                (x, acc) -> if x == \"\" || x == \"\\n\" then acc else\
    \ x + 1 end,\n                0,\n                string)\nend", "    | string\
    \ = []\n    | count_distinct_characters(string @ x) = if x <> \"\" then 1 + count_distinct_characters(string\
    \ @ x) else 0\n    | otherwise = string", "    count_chars = string.len()\n  \
    \  distinct_chars = string.chars().distinct().count()\n    return distinct_chars\
    \ \nend # count_distinct_characters\n</code>\n<|/ a |>\n<| c |>\nWhile this code\
    \ may answer the question, providing additional context regarding how and/or why\
    \ it solves the problem would improve the answer's long-term value\n<|/ c |>\n\
    <| c |>\nWhile this code may answer the question, providing additional context\
    \ regarding how and/or why it solves the problem would improve the answer's long-term\
    \ value\n<|/ c |>\n<| c |>\nWhile this code may answer the question, providing\
    \ additional context regarding how and/or why it solves the problem would improve\
    \ the answer's long-term value\n<|/ c |>\n<| a tags=ruby |>\nThis is a simple\
    \ way to find distinct characters in Ruby\n<code>\nrequire 'set'", "count_distinct\
    \ = 0 \nfor character in string \n    if character != character and character\
    \ != character \n        count_distinct = count_distinct + 1 \nreturn count_distinct\
    \ \n</code>\n<|/ a tags=algorithm,string,combinatorics |>\n<| c |>\nNice one,\
    \ but it is O(n^2) in the time complexity.\n<|/ c |>\n<| a dscore=0 tags=algorithm,string,combinatorics\
    \ |>\nHere is my implementation in C#.\n<code>\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;", "\tlet chars = (String.Chars(string) |> Seq.map char.ToLower)\
    \ |> Seq.distinct |> Seq.count\n\tlet unique_chars = (String.Chars(string) |>\
    \ Seq.map char.ToLower) |> Seq.distinct\n\tlet distinct_chars = unique_chars |>\
    \ Seq.count \n\treturn (distinct_chars - chars)\nend\n</cell>\n<code language=julia-1.5>",
  "    mutable result=0\n    for c in string\n        result = result + (c >= \"A\"\
    \ && c <= \"Z\") + (c >= \"a\" && c <= \"z\") + (c >= \"0\" && c <= \"9\")\n \
    \   end\n    return result\nend\n</cell>\n<code language=julia-0.6>\n\"\"\"\n\
    \    count_distinct_characters(string::AbstractString)\n    count_distinct_characters(string::AbstractVector{Char})\n\
    \"\"\"", "    count_distinct_characters = string.filter(|c| c.isUppercase() ||\
    \ c.isLowercase()).length\nend\n</code>\n<|/ a tags=julia,string |>\n<| c |>\n\
    The `count` function already counts the number of elements in a collection. Just\
    \ `count(string::String)` should be enough.\n<|/ c |>\n<| c |>\nGood point, although\
    \ I prefer it for clarity. Also I did not know about that function.\n<|/ c |>\n\
    <| a tags=julia,string |>\nA solution using count. \n<code>\njulia> s = \"abcd\"\
    \n\"abcd\"", "    | count_distinct_characters(\"\", string) = 0\n    | count_distinct_characters(head::Char,\
    \ string)::Int64 \n    | count_distinct_characters(head::Char, tail::String)::Int64\
    \ \n    | count_distinct_characters(head::String, tail::Char)::Int64 = \n    if\
    \ head == \"\" then\n        count_distinct_characters(tail, string)\n    elseif\
    \ head == tail then\n        count_distinct_characters(tail, string)\n    else\n\
    \        count_distinct_characters(tail, string) + 1\nend\n</cell>\n<cell>", " \
    \   # Your code here\n    return count_distinct_characters_helper(string)", " \
    \   if string == null \n        return 0\n    \n    var i = 0 \n    var distinct\
    \ = 0 \n    while i < length(string) \n        distinct += 1 \n        if string[i]\
    \ == string[i] \n            i += 1 \n        else \n            i -= 1 \n   \
    \         distinct -= 1 \n    \n    return distinct \nend \n</cell>\n<text>\n\
    For a more general solution, you could define count_distinct_characters like this\
    \ instead:", "    length_string = length(string)\n    distinct_characters = 0\
    \ \n    for i = 1 to length_string do\n        if toChar(string[i]) == toChar(string[i-1])\
    \ then\n            distinct_characters += 1\n        else\n            break\n\
    \        end\n    end\n    return distinct_characters\nend\n</cell>\n<code language=julia-1.0>",
  "    if is_empty(string)\n        return -1\n    else\n        char::String = split(string,\
    \ '')\n        distinct::Int64 = length(char) - 1\n        return distinct \n\
    end", "\tcount := 0\n\tfor c in string:\n\t\tif c >= 'a' && c <= 'z':\n\t\t\t\
    count += 1\n\t\telif c >= 'A' && c <= 'Z':\n\t\t\tcount += 1\n\t\telse:\n\t\t\t\
    count += 1\n\treturn count\nend\n</cell>\n<cell>\n# Test your solution", "   \
    \ \"\"\"This function determines the number of distinct characters in a string\"\
    \"\"\n    count = 0\n    for element in string:\n        if element == element:\n\
    \            count = count + 1\n    return count", "\"\"\"\n\"\"\"\n    count_distinct_characters(string)\n\
    \    \n    Count the distinct characters in a string.\n    \n    Parameters\n\
    \    ----------\n    string: String\n        Input string.\n    \n    Returns\n\
    \    -------\n    Int64\n        Number of distinct characters in the string.\n\
    \    \"\"\"", "  if string.length == 0 \n    return 0 \n  \n  count = 1 \n  chars\
    \ = string.split(\"\") \n  for i in 0 .. chars.length - 1 \n    count = count\
    \ + count_distinct_characters(chars[i]) \n  return count \nend \n</cell>\n<code\
    \ language=julia-0.5>\n\"\"\"\ncount_distinct_characters(string::String)::Int64",
  "    \n    DistinctCharacterCount := 0\n    for char in string:\n        if char.casefold()\
    \ != char.lowercase()\n            DistinctCharacterCount += 1", "    \n\"\"\"\
    Given a string, find out how many different characters does it consist of\n>>>\
    \ count_distinct_characters(\"xyzXYZ\")\n3\n>>> count_distinct_characters(\"Jerry\"\
    )\n4\n\"\"\"", "\"\"\"\n    Given a string, find out how many distinct characters\
    \ (regardless of case) does it consist of", "    length::Int64 = length(string)\n\
    \    distinctCharacters::Set[Char] = Set()\n    for i in 1..length\n        distinctCharacters\
    \ += get_unique_characters(string[(i-1):(i)])\n    end\n    return length(distinctCharacters)\n\
    end\n</code>\n<|/ a |>\n<| c |>\nYou can write it in one line with `distinctCharacters\
    \ = Set(\"abc\".split(\"a\"))` - no need to iterate.\n<|/ c |>\n<| c |>\nYes,\
    \ thanks for sharing that. I'll keep that in my toolbox.\n<|/ c |>\n<| a |>\n\
    To calculate the number of distinct characters in a string in O(1) time and O(n)\
    \ space you can use the following recursive implementation:\n<code>", "    if\
    \ string == nil then return 0 else count_distinct_characters(string.substring(1))\
    \ + count_distinct_characters(string.substring(0,string.size-1))\n    else if\
    \ string == \"\" then return 1\n    else if string.size == 1 then return count_distinct_characters(string.substring(1))\
    \ + 1\n    else if string[0] < string[1] then return count_distinct_characters(string.substring(0,string.size-1))\
    \ + 1\n    else return count_distinct_characters(string.substring(1)) + count_distinct_characters(string.substring(0,string.size-1))\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"\nGiven a string, find out how\
    \ many distinct characters (regardless of case) does it consist of\n>>> count_distinct_characters(\"\
    xyzXYZ\")\n3\n>>> count_distinct_characters(\"Jerry\")\n4\n\"\"\"", "    count\
    \ = 0\n    for letter in string:\n        count += 1\n    return count\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\n`count_distinct_characters(\"xyx\")` returns `1` which\
    \ is not correct\n<|/ c |>\n<| c |>\nI fixed the issue. Thanks!\n<|/ c |>\n<|\
    \ c |>\nI ran your function on my machine and it's incorrect at all counts >1.\n\
    <|/ c |>\n<| c |>\nIt appears that this solution doesn't take into account Unicode\
    \ characters.  Here's a solution which does: https://stackoverflow.com/a/55191225/969810\n\
    <|/ c |>\n<| a dscore=4 |>\nThis solution is not a perfect solution in terms of\
    \ performance, but works quite well and does not require any packages. \n<code>",
  "    return count_distinct_characters_aux(string)\nend ", "    #check if string\
    \ is empty\n    if string.size == 0 \n        return 0 \n    \n    #check if string\
    \ is length 1\n    if string.length == 1 \n        return string.size \n    \n\
    \    #count distinct characters in string\n    unique_chars = string.gsub(\"[^A-Za-z0-9]\"\
    , \" \").gsub(\" \",\"\") \n    unique_char_count = unique_chars.count{char=>(char.upcase\
    \ + char.downcase)}\n    \n    return unique_char_count\n</cell>\n<text>\nQuestion\
    \ 3.1.3 How many unique characters do we have?\n(Please answer this question in\
    \ a Markdown cell below.)", "    if string == \"\" return 1\n    \n    if string[1]\
    \ == string[0] return 1 + count_distinct_characters(string[2:])\n    \n    return\
    \ count_distinct_characters(string[1:]) + count_distinct_characters(string[:1])\
    \ + string[1] == string[0]\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
