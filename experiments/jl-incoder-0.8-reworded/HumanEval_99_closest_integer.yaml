name: HumanEval_99_closest_integer
language: jl
prompt: "\"\"\"\n    Create a function that takes a value (string) representing a\
  \ number\n    and returns the closest integer to it. If the number is equidistant\n\
  \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
  10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
  \ away from zero means that if the given number is equidistant\n    from two integers,\
  \ the one you should return is the one that is the\n    farthest from zero. For\
  \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
  -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
  10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") ==\
  \ -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
completions: ["\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.", "\"\"\"\n    Create a function\
    \ that takes a value (string) representing a number\n    and returns the closest\
    \ integer to it. If the number is equidistant\n    from two integers, round it\
    \ away from zero.", "    \"\"\"Find the closest integer to the value given\"\"\
    \"\n    var closestInteger = math.floor(math.log(value))\n    if closestInteger\
    \ - int(value) < 0:\n        closestInteger = int(value)\n    return closestInteger\n\
    end\n</cell>\n<text>\nNow we can implement closest_integer just like before:",
  "    closest_int =\n        if isnumeric(value), \n            if isnumeric(value),\
    \ \n                abs(value) \n            else \n                abs(string_to_double(value))\
    \ \n        else \n            error(\"Not a number!\") \n    \n    if isnumeric(value),\
    \ \n        closest_int == value \n    else \n        closest_int == value\nend\n\
    </cell>\n<text>\nA more general version of the above function would be as follows:",
  "    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    closest = value.toInt64()\n\
    \    for i in 0..9 where abs(closest - value.toInt64()) <= 10 \n        closest\
    \ = value.toInt64() + i\n    end\n    return closest\nend", "    if isa(value::String,String)\
    \ \n        then try\n            if value == \"\" || value == \"NaN\" || value\
    \ == \"NaN%\"\n                then throw(ArgumentError(\"The value you provided\
    \ cannot be converted to an integer.\"))\n            end\n            return\
    \ parse_int(value)\n        end\n    else throw(ArgumentError(\"The value you\
    \ provided cannot be converted to an integer.\"))\nend\n\"\"\"\n    Create a function\
    \ that takes a value (string) representing a number\n    and returns the closest\
    \ floating to it. If the number is equidistant\n    from two floats, round it\
    \ away from zero.", "    if value == \"\" || value == \"0\" || value == \"-0\"\
    \ \n        then\n            return 0 \n        else \n            closest =\
    \ 0\n            difference = abs(closest_integer(value[1:end-1]) - closest_integer(value[1:end-1]))\n\
    \            for i in 0:index(value,\".\"):-1 \n                d = abs(closest_integer(value[i+1:end-1])\
    \ - closest_integer(value[i:end]))\n                if d > difference \n     \
    \               then\n                        difference = d\n               \
    \         closest = i\n                end\n            end\n            return\
    \ closest\n        end\n    else\n        return closest\n    end\nend\n</code>\n\
    <|/ a dscore=2 tags=julia |>\n<| c |>\nThis code is very similar to what I have\
    \ written (except that I use `round` and `abs`). Your `closest` function does\
    \ not correctly handle numbers close to zero (I believe the OP wants `closest`\
    \ to return zero).\n<|/ c |>\n<| c |>\nAh, thanks for pointing that out. I just\
    \ edited it (I wrote that code before I saw that `abs` is also needed). Also thanks\
    \ for catching the bug on the `closest` function. I was thinking that it should\
    \ just return the last digit, but obviously the second example fails since `closest`\
    \ never returns zero. My mistake!\n<|/ c |>\n<| a tags=julia |>\nThe following\
    \ method works with floats and Int64 values.\n<code>", "    closest_to_value =\
    \ find_integer_close_to_value(value)\n    if closest_to_value == 0 \n        then\
    \ closest_to_value\n        else closest_to_value+1\nend\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"\n    find_integer_close_to_value(value::String)::Int64", "    \n    \n\
    \    if abs(value)==0 then \n        return 0 \n    elseif abs(value) < 1 then\
    \ \n        return value \n    else \n        nearest_integer = 0 \n        closest_integer\
    \ = 0 \n        int_value = int64(value) \n        float_value = float64(value)\
    \ \n        \n        if int_value < -10 then \n            nearest_integer =\
    \ 0 \n            return 0 \n        elif int_value < 10 then \n            nearest_integer\
    \ = int_value \n            return int_value \n        else \n            if abs(int_value\
    \ - 10) < abs(int_value - -10) then \n                nearest_integer = int_value\
    \ \n                closest_integer = int_value \n            else \n        \
    \        nearest_integer = int_value - 10 \n                closest_integer =\
    \ int_value \n                \n            while abs(float_value) > abs(nearest_integer)\
    \ \n                nearest_integer += 1 \n                if nearest_integer\
    \ > int_value \n                    nearest_integer = int_value \n           \
    \     if nearest_integer < 0 \n                    nearest_integer = int_value\
    \ \n                return closest_integer \n    end\nend\n</cell>\n<text>\nExercise\
    \ 8: Write a function that takes a value (string) representing a number\nand returns\
    \ the closest integer to the decimal equivalent of the number.\nIf the number\
    \ is equidistant from two integers, round it away from zero.", "    if value.is_integer()\
    \ then\n        return value.round()\n    elseif value.is_string() then\n    \
    \    return closest_integer(value.to_string())\n    else\n        return 0\n \
    \   end\nend\n\"\"\"\n    Create a function that takes a string representing the\
    \ name of a variable\n    and returns the number associated with it. For instance,\
    \ if the name of\n    the variable is \"foo\", then get_variable_number(foo) should\
    \ return\n    2.", "    \n    \"\"\"\n    Create the closest integer\n    \"\"\
    \"\n    return round(value.floor())\nend", "    # Begin Solution\n    \n    return\
    \ \n    # End Solution\nend\n</cell>\n<text>\nCall the function with the string\
    \ \"10\" and print the result.", "    \n    closest_value = to_integer(value)\n\
    \    \n    if closest_value < to_integer(value.ceil())\n        closest_value\
    \ = to_integer(value.ceil())\n    elseif closest_value > to_integer(value.floor())\n\
    \        closest_value = to_integer(value.floor())\n    end\n    \n    return\
    \ to_integer(closest_value)\nend", "    if value < \"0\" || value > \"9\" then\
    \ \n        error(\"Expected value to be a number\")\n    end", "    \n\"\"\"\n\
    \    Create a function that takes a value (string) representing a number\n   \
    \ and returns the closest floating to it. If the number is equidistant\n    from\
    \ two floats, round it away from zero.", "    \"\"\"\n    Calculate the closest\
    \ integer to a number.\n    \"\"\"\n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    ", "     let num_str\
    \ = value:sub(1,string.length(value))\n     let parsed_num::Int64 = parse(num_str)\n\
    \     let delta::Int64 = (parsed_num - parsed_num + 1)\n     let closest_number::Int64\
    \ = (parsed_num - delta).abs()\n     return closest_number\nend\n</cell>\n<code\
    \ language=julia-1.4>", "    closest = closest_integer(parse(value))\n    return\
    \ close - closest\nend\n</cell>\n<code language=julia-1.4>\n\"\"\"\nCalculate\
    \ the number of digits in an integer\n\"\"\"", "    \n    #initialize closest\
    \ integer to the first number\n    closest = 1\n    \n    #initialize nearest\
    \ integer to the first number\n    nearest = 1\n    \n    #initialize integer\
    \ counter\n    i = 1\n    \n    #iterate through all the numbers in the list\n\
    \    for number in numbers\n        \n        #add 1 to current iterated number\n\
    \        i = i + 1\n        \n        #if the number is equal to current closest\
    \ number add 1 to closest\n        if i == value\n            \n            #add\
    \ 1 to closest\n            closest = closest + 1\n            \n        #if the\
    \ number is equal to the current nearest number add 1 to nearest\n        elif\
    \ i == value\n            \n            #add 1 to nearest\n            nearest\
    \ = nearest + 1\n            \n        #otherwise\n        else\n            \n\
    \            #add 1 to the number at current iteration\n            i = value\n\
    \            \n            \n            #return closest\n            return closest\n\
    \            \n    #return nearest\n    return nearest\n            \n       \
    \     \n\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the largest integer less than or equal to it.", " \
    \   if isnumeric(value)\n        float(value)\n        closest_integer = Int(value)\n\
    \    elseif isstring(val)\n        closest_integer = Int(val)\n    end\n    return\
    \ closest_integer\nend", "    if value[0] == '-':\n        negated = true\n  \
    \      value = value[1:]\n    else:\n        negated = false", "    # initialize\
    \ variables\n    closest::Int64 = Inf\n    closestIdx::Int64 = -1\n    closestDistance::Int64\
    \ = 0\n    idx::Int64 = 0", "    number::Int64 = value.toInt64()\n    step::Int64\
    \ = 10^int(ceil(log10(abs(number))))\n    \n    if abs(number)<1 then \n     \
    \   return 0\n    else\n        diff = abs(number-step)\n        if diff>abs(number)-1\
    \ then return 0 \n        else return abs(number)\nend", "\"\"\"\n    Define the\
    \ function closest_integer which takes a value (string) \n    representing a number\
    \ and returns the closest integer to it. If the \n    number is equidistant from\
    \ two integers, round it away from zero.\n    \n    Parameters\n    ----------\n\
    \    value : String\n        A number to be rounded away from zero. \n    \"\"\
    \"\n    \n    if value.isnumeric():\n        return int(value)\n    else:\n  \
    \      if value.startswith('-'):\n            return -int(value[1:])\n       \
    \ else:\n            return int(value)\nend", "    if value == \"\"\n        error(\"\
    Expected a non-empty string.\")\n    end\n    float_val = Float64(value)\n   \
    \ nearest_integer = Int(ceiling(float_val))\n    return nearest_integer\nend\n\
    </cell>\n<code language=julia-1.0>", "    if value == \"\" return 0\n    let num\
    \ = Strings.replace(value, \".\", \"\")\n    if num == \"-\" || num == \"+\" then\
    \ return 0\n    if isnumeric(num) and num <= \"9\" then return num.to_int64()\n\
    \    if num == \".\" then\n        let i = value.to_int64()\n        while(i /=\
    \ 10) do return i\n        return i\n    else\n        let i = value.to_int64()\n\
    \        let lower = num.to_int64() - 1\n        while(i <= lower) do i = i*10\
    \ + i\n        return i\n    end\nend\n</cell>\n<text>\nAs a final step we define\
    \ the function closest_integer! That function takes a string representing a number\
    \ and returns the closest integer.", "    value::String = \"value::String = \\\
    \"\" + value + \"\\\"\"\n    return if value == \"-inf\" then -Infinity else if\
    \ value == \"inf\" then Infinity else if isnumeric(value) then Int(value)\n  \
    \      else try\n            if\n                if value == \"0\"\n         \
    \           then 0\n                else if value == \"1\"\n                 \
    \   then 1\n                else if value == \"2\"\n                    then 2\n\
    \                else if value == \"3\"\n                    then 3\n        \
    \        else if value == \"4\"\n                    then 4\n                else\
    \ if value == \"5\"\n                    then 5\n                else if value\
    \ == \"6\"\n                    then 6\n                else if value == \"7\"\
    \n                    then 7\n                else if value == \"8\"\n       \
    \             then 8\n                else if value == \"9\"\n               \
    \     then 9\n                else if value == \"10\"\n                    then\
    \ 10\n                else if value == \"11\"\n                    then 11\n \
    \               else if value == \"12\"\n                    then 12\n       \
    \         else if value == \"13\"\n                    then 13\n             \
    \   else if value == \"14\"\n                    then 14\n                else\
    \ if value == \"15\"\n                    then 15\n                else if value\
    \ == \"16\"\n                    then 16\n                else if value == \"\
    17\"\n                    then 17\n                else if value == \"18\"\n \
    \                   then 18\n                else if value == \"19\"\n       \
    \             then 19\n                else if value == \"20\"\n             \
    \       then 20\n                else if value == \"21\"\n                   \
    \ then 21\n                else if value == \"22\"\n                    then 22\n\
    \                else if value == \"23\"\n                    then 23\n      \
    \          else if value == \"24\"\n                    then 24\n            \
    \    else if value == \"25\"\n                    then 25\n                else\
    \ if value == \"26\"\n                    then 26\n                else if value\
    \ == \"27\"\n                    then 27\n                else if value == \"\
    28\"\n                    then 28\n                else if value == \"29\"\n \
    \                   then 29\n                else if value == \"30\"\n       \
    \             then 30\n                else if value == \"31\"\n             \
    \       then 31\n                else if value == \"32\"\n                   \
    \ then 32\n                else if value == \"33\"\n                    then 33\n\
    \                else if value == \"34\"\n                    then 34\n      \
    \          else if value == \"35\"\n                    then 35\n            \
    \    else if value == \"36\"\n                    then 36\n                else\
    \ if value == \"37\"\n                    then 37\n                else if value\
    \ == \"38\"\n                    then 38\n                else if value == \"\
    39\"\n                    then 39\n                else if value == \"40\"\n \
    \                   then 40\n                else if value == \"41\"\n       \
    \             then 41\n                else if value == \"42\"\n             \
    \       then 42\n", "    if value.isdigit()\n        return parse(value).round().toInt64()\n\
    \    \n    first, last = parse(value).floor(), parse(value).ceil()\n    if first.toInt64()\
    \ == last.toInt64()\n        return first.toInt64()\n    \n    if first < 0 \n\
    \        then return last.toInt64()\n        else return first.toInt64()\n   \
    \ end\nend\n</code>\n<|/ a tags=julia,parsing |>\n<| c |>\nCould you please [edit]\
    \ your answer to explain what your code does?\n<|/ c |>\n<| a dscore=0 |>\nI know\
    \ this is an old question, but here is my solution, inspired by the answers above\
    \ (which all worked for me). I use the first solution to get the first digit of\
    \ any number (or string).\n<code>", "    var x:Int64\n    if value == \"NaN\"\
    \ then\n        x=int64(NaN)\n    elseif value == \"-Infinity\" then\n       \
    \ x=int64(-Inf)\n    elseif value == \"Infinity\" then\n        x=int64(Inf)\n\
    \    elseif value == \"0\" then\n        x=int64(0)\n    else\n        x=int64(round(value))\n\
    \    end\n    return x\nend", "    \"\"\"\n    Create a function that takes a\
    \ value (string) representing a number\n    and returns the closest integer to\
    \ it. If the number is equidistant\n    from two integers, round it away from\
    \ zero.", "    closest = closest_integer_with_abs(value)\n    if closest < 0\n\
    \        closest *= -1\n    return closest\nend", "    if value == \"\"\n    \
    \    return -1\n    \n    if value == \"\" || value == \"-\"\n        return -1\n\
    \    \n    number = value.to_string()\n    int_value = number.to_int()\n    \n\
    \    if number.sign != \"-\"\n        return int_value\n    \n    if int_value\
    \ == 0\n        return int_value\n    \n    nearest = int_value\n    difference\
    \ = 0\n    \n    for i in int_value.digits\n        difference = difference +\
    \ (i * (10^(number.length - 1 - i)))\n    \n    return nearest + difference\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    closest_integers(string::String...)::Vector{Int64}",
  "    \"\"\"Find the closest integer that represents this value.\"\"\"\n    if value\
    \ == \"\"\n        error(\"empty string\", value) ", "    \"\"\"\n    Create a\
    \ function that takes a value (string) representing a number\n    and returns\
    \ the closest integer to it. If the number is equidistant\n    from two integers,\
    \ round it away from zero.", "    let int_value::Int64 = int(value)\n    let num_digits\
    \ = math.log10(int_value)\n    let digits = (int_value).floor()\n    if int_value/digits\
    \ < 0.5\n        then digits\n        else if(int_value/digits == 0.5)\n     \
    \           && (int_value/digits < 1.5)\n                then int_value/digits\
    \ * 10\n                else int_value/digits * 10\n    else\n        digits\n\
    end", "    \"\"\"Find the closest integer to the value\"\"\"\n    if is_close_to_zero(value)\
    \ \n        then \n            error(\"The given value is equidistant from two\
    \ integers\") \n        else \n            round(value)\n    end\nend", "    if\
    \ value >= 0 \n        then ceil(value) \n        else floor(value) \n    end\n\
    end\n</cell>\n<text>\nDefine a function to check if the given number is equidistant\
    \ from two integers", "    local num::Int64\n    if value == \"\" then\n     \
    \   return 0\n    else\n        num = tostring(value)\n    end\n    if num ==\
    \ \"-\" then\n        return -closest_integer(\"-\" * num)\n    elseif num ==\
    \ \"0\" or num == \"1\" then\n        return num\n    else\n        local num_int::Int64\n\
    \        local num_digits::Int64\n        local last_digits::String\n        if\
    \ num == \"+\" then\n            num_int = 1\n        elseif num == \"-\" then\n\
    \            num_int = -1\n        else\n            num_int = tonumber(num)\n\
    \        end\n        num_digits = div(num_int, 10)\n        last_digits = string(num_digits\
    \ - 1)\n        return tonumber(last_digits)\n    end\nend\n</cell>\n<text>\n\
    Exercise\nThe function closest_integer() in the cell below takes a string\nrepresenting\
    \ a number and returns the closest integer to it.\nWhy do you think it returns\
    \ the integer closest to the original number\nand not the number closest to zero?",
  "    \n    # remove all whitespace from the value\n    value = value.replace(\"\
    \ \", \"\")\n    \n    # make sure there is at least one number on the left of\
    \ the decimal\n    if \".\" in value:\n        left, decimal = value[value.index(\"\
    .\")+1:], value[value.index(\".\")+1:].split(\".\") \n    else:\n        left,\
    \ decimal = value[value.index(\".\")+1:], None\n    \n    # make sure there is\
    \ at least one number on the right of the decimal\n    if \".\" in right:\n  \
    \      right, decimal = right[right.index(\".\")+1:], right[right.index(\".\"\
    )+1:].split(\".\") \n    else:\n        right, decimal = right[right.index(\"\
    .\")+1:], None", "    if isinteger(value) == false then \n        error(\"Value\
    \ must be an Integer\")\n    end\n    \n    local num_str = value\n    local num_int\
    \ = tointeger(num_str)\n    \n    if num_int == num_str then \n        return\
    \ num_int\n    elseif num_int == num_int+1 then \n        return num_int \n  \
    \  elseif num_int == num_int-1 then \n        return num_int-1\n    else\n   \
    \     return num_int\n    end\nend\n</cell>\n<text>\nAnd now we can test it",
  "    \n    if isnum(value) == true\n        value = value.as_string\n    \n    \n\
    \    \n    \n\"\"\"\n    Returns the integer closest to `value`.\n    It rounds\
    \ away from zero so that\n    if `value` is equidistant from two integers,\n \
    \   you get the integer that is closest to zero.", "    if value == \"\"\n   \
    \     throw(ArgumentError(\"value must be a non-empty string\"))\n    end\n  \
    \  if value[-1] == '.'\n        throw(ArgumentError(\"value cannot end with a\
    \ decimal point\"))\n    end\n    if value[0] == '-'\n        value = value[1:end-1]\n\
    \    end\n    value = parsefloat(value)\n    if value == 0.0\n        throw(ArgumentError(\"\
    value must be a non-zero number\"))\n    end\n    min = abs(value)\n    max =\
    \ value\n    for i in 2:100\n        test = abs(value - i/10)\n        if test\
    \ < min\n            min = test\n        end\n        test = abs(value - i/10\
    \ + 1.)\n        if test > max\n            max = test\n        end\n    end\n\
    \    if min == max\n        return min\n    end\n    if min == max+0.5\n     \
    \   if value < 0\n            return -value\n        else\n            return\
    \ value\n        end\n    end\n    return min\nend", "    to_return = zero\n \
    \   for num in to_list(value)\n        if num == zero\n            to_return +=\
    \ 1\n        elseif num == (value + 1)\n            to_return -= 1\n        else\n\
    \            to_return = num\n            break\n    return to_return\nend", " \
    \   if is_int(value):\n        return Int(value)\n    else:\n        number =\
    \ Float(value)\n        integers = floor(number)\n        if abs(number - integers)\
    \ <= abs(number - floor(number)):\n            return Int(integers)\n        else:\n\
    \            return Int(floor(number))\nend\n</cell>\n<code language=julia-0.6>\n\
    # Test it!\nclosest_integer(\"10\")\nclosest_integer(\"15.3\")\nclosest_integer(\"\
    14.5\")\nclosest_integer(\"15.99\")\nclosest_integer(\"1.1\")\nclosest_integer(\"\
    0.1\")\nclosest_integer(\"1\")\nclosest_integer(\"-5\")\nclosest_integer(\"0\"\
    )\nclosest_integer(\"-2\")\nclosest_integer(\"-1.1\")\nclosest_integer(\"-3.1415926535897932384626433832795028841971\"\
    )\n</cell>\n<text>\nExercise: Write a function that converts strings to integers\
    \ and returns the sum of the integers it contains.", "    value::String = value::String\n\
    \    if isstring(value) and value.ends_with(\".0\")\n        return tonumber(value.substring(2,\
    \ stringlength(value) - 1))\n    else\n        return tointeger(value)\n    end",
  "    # Write your function here\n    return 0", "    | Int64 \n    | Float64 \n\
    \    | Int32 \n    | Float32 \n    | Int16 \n    | Float16 \n    | Int8 \n   \
    \ | Float8 \n    | String =\n    if value.is_int() \n        or value.is_uint()\
    \ \n        or value.is_float() \n        then value.floor() \n    else value.floor()\
    \ \nend\n\"\"\"\n    Convert a string representing a number to an integer.", " \
    \   if value == \"0\" \n    then 0 \n    elseif value == \"1\" \n    then 1 \n\
    \    elseif value == \"2\" \n    then 2 \n    elseif value == \"3\" \n    then\
    \ 3 \n    elseif value == \"4\" \n    then 4 \n    elseif value == \"5\" \n  \
    \  then 5 \n    elseif value == \"6\" \n    then 6 \n    elseif value == \"7\"\
    \ \n    then 7 \n    elseif value == \"8\" \n    then 8 \n    elseif value ==\
    \ \"9\" \n    then 9 \n    elseif value == \"10\" \n    then 10 \n    elseif value\
    \ == \"11\" \n    then 11 \n    elseif value == \"12\" \n    then 12 \n    elseif\
    \ value == \"13\" \n    then 13 \n    elseif value == \"14\" \n    then 14 \n\
    \    elseif value == \"15\" \n    then 15 \n    elseif value == \"16\" \n    then\
    \ 16 \n    elseif value == \"17\" \n    then 17 \n    elseif value == \"18\" \n\
    \    then 18 \n    elseif value == \"19\" \n    then 19 \n    elseif value ==\
    \ \"20\" \n    then 20 \n    elseif value == \"21\" \n    then 21 \n    elseif\
    \ value == \"22\" \n    then 22 \n    elseif value == \"23\" \n    then 23 \n\
    \    elseif value == \"24\" \n    then 24 \n    elseif value == \"25\" \n    then\
    \ 25 \n    elseif value == \"26\" \n    then 26 \n    elseif value == \"27\" \n\
    \    then 27 \n    elseif value == \"28\" \n    then 28 \n    elseif value ==\
    \ \"29\" \n    then 29 \n    elseif value == \"30\" \n    then 30 \n    elseif\
    \ value == \"31\" \n    then 31 \n    elseif value == \"32\" \n    then 32 \n\
    \    elseif value == \"33\" \n    then 33 \n    elseif value == \"34\" \n    then\
    \ 34 \n    elseif value == \"35\" \n    then 35 \n    elseif value == \"36\" \n\
    \    then 36 \n    elseif value == \"37\" \n    then 37 \n    elseif value ==\
    \ \"38\" \n    then 38 \n    elseif value == \"39\" \n    then 39 \n    elseif\
    \ value == \"40\" \n    then 40 \n    elseif value == \"41\" \n    then 41 \n\
    \    elseif value == \"42\" \n    then 42 \n    elseif value == \"43\" \n    then\
    \ 43 \n    elseif value == \"44\" \n    then 44 \n    elseif value == \"45\" \n\
    \    then 45 \n    elseif value == \"", "    \"\"\"\n    Find the closest integer\
    \ to `value`.", "    if value.is_floating() == true\n        err = abs((value-round(value))*sign(value-round(value)))\n\
    \        return round(round(round(value,digits=digits)+err,digits=digits),digits)\n\
    \    return parse_value(value)\nend", "    \"\"\"\n    Closest integer function\
    \ to value", "    if value != \"\"\n        value = tonum(value) \n        diff\
    \ = value - (value % 1) \n        return diff == 0 ? value : value + diff \n \
    \   else \n        return 0\nend\n</code>\n<|/ a tags=julia dscore=4 |>\n<| c\
    \ |>\nThis is really cool.  I added the following to your definition of closest\
    \ integer: `return floor(abs(value))`\n<|/ c |>\n<| c |>\nI see you changed the\
    \ original code to avoid division by zero, which was what I was referring to.\
    \  That is actually something I didn't consider when writing this answer.  In\
    \ my opinion `floor` is better.  As a side note, if you don't mind rounding to\
    \ the nearest integer instead of floor, I would recommend using the `round` function.\n\
    <|/ c |>\n<| c |>\nI really like the solution, but you should change the first\
    \ line `function closest_integer(value::String)::Int64 ` to `function closest_integer(value::Int64)::Int64`\
    \ to avoid `TypeError` when calling the function.\n<|/ c |>\n<| c |>\nThanks for\
    \ the suggestion.  I've edited my answer to fix that.\n<|/ c |>\n<| a tags=julia\
    \ dscore=4 |>\n<code>\nceil(abs(number))\n</code>\nShould do the trick.  It will\
    \ round up if the number is larger or equal than zero, and down if the number\
    \ is smaller.\n<|/ a |>\n<| a |>\nI like to define things like this myself:\n\
    <code>", "    try\n        result = parse(value)\n    catch e\n        if e.message\
    \ == \"could not parse value as an integer\" \n            throw ErrorMessage(\"\
    could not parse value as an integer\")\n        else\n            raise\n    end\n\
    \    if isinteger(result)\n        return result\n    else\n        # we didn't\
    \ find an integer, try a float\n        try\n            result = parse(value\
    \ + \"0\")\n        catch e\n            if e.message == \"could not parse value\
    \ as a float\"\n                throw ErrorMessage(\"could not parse value as\
    \ a float\")\n            else\n                raise\n        end\n        return\
    \ round(result)\n    end\nend", "    \n\"\"\"\n    Create a function that takes\
    \ a value (string) representing a number\n    and returns the closest float to\
    \ it. If the number is equidistant\n    from two numbers, round it away from zero.",
  "    closest_integer =\n        if value.is_floating_point() \n            then\
    \ (value.round())\n            else if value.is_integer()\n                then\
    \ value\n                else value.round()\n            else error(\"Value must\
    \ be either a floating point or integer\")\n    error(\"This should never happen.\"\
    )\nend\n</cell>\n<code language=julia-1.5>\nclosest_integer(\"14.5\")\n</cell>\n\
    <code language=julia-1.5>\nclosest_integer(\"-10\")\n</cell>\n<code language=julia-1.5>\n\
    closest_integer(\"0\") # 0 should be treated as a special case\n</cell>\n<code\
    \ language=julia-1.5>\nclosest_integer(\"0\")\n</cell>\n<code language=julia-1.5>\n\
    closest_integer(\"10\")\n</cell>\n<code language=julia-1.5>\nclosest_integer(\"\
    -1\")\n</cell>\n<code language=julia-1.5>\nclosest_integer(\"3.141592653589793\"\
    )\n</cell>\n<code language=julia-1.5>\nclosest_integer(\"3.1415926535897938\"\
    )\n</cell>\n<text>\nProblem #2: Sort a list\nWrite a function that will sort the\
    \ following list according to the\nfollowing rules:", "\"\"\"\n    Create a function\
    \ that takes a value (string) representing a number\n    and returns the closest\
    \ integer to it. If the number is equidistant\n    from two integers, round it\
    \ away from zero.", "    num = try(parse_number(value))\n    if num == None\n\
    \        error(\"Cannot parse the number string: \\\"%s\\\"\" % value)\n    else\
    \ \n        val =  num.value\n        if val % 1 != 0\n            return val\
    \ \n        \n        return int(val)", "    if value == \"-inf\" \n        then\
    \ return -Infinity \n    else if value == \"inf\" \n        then return Infinity\
    \ \n    else \n        match Float64.parse(value) \n        | Int64.parse(value)\
    \ -> Int64.parse(value) \n        | _ -> if value == \"-inf\" \n             \
    \      then -Infinity \n                   else Infinity \n    end \nend \n</cell>\n\
    <text>\nQuestion 7\nImplement closest_integer_string().", "    if value == \"\
    -inf\" or value == \"inf\" then\n        return -1\n    end", "    \n    # Your\
    \ code goes here\n    \n    return Int64(math.ceil(float(value)))\nend\n</cell>\n\
    <code language=julia-1.3>\nclosest_integer(4.5)\n</cell>\n<code language=julia-1.3>\n\
    closest_integer(\"-4.5\")\n</cell>\n<text>\nProblem: How would you create a function\
    \ that takes a value (string) representing a date\n    and returns the year in\
    \ which the date is closest?", "    num = value :: Float64\n    if num == math.floor(num)\
    \ && num == math.ceil(num) return num\n    if num < 0 return math.ceil(num)\n\
    \    if num > 0 return math.floor(num)\n    return num\nend\n\"\"\"\n    Create\
    \ a function that takes a value (string) representing a number\n    and returns\
    \ the closest integer to it. If the number is equidistant\n    from two integers,\
    \ round it away from zero.", "    closest_integer = int64(round(value))\n    if\
    \ abs(closest_integer-value)<1e-10\n        closest_integer = int64(0)\n    end\n\
    \    return closest_integer\nend", "    if value == \"0\" || value == \".\" ||\
    \ value == \"-\"\n        || value == \"\"\n        || value.isWhitespace\n  \
    \      || value.isNaN\n        || value.isLetter\n        || value.head == \"\
    -\"\n        || value.head == \".\"\n        || value.head == \"\"\n        return\
    \ NaN\n    else\n        if value.head == \"+\"\n            return value.tail.parseInt64().ceiling()\n\
    \        else\n            return value.tail.parseInt64().floor()\nend", "   \
    \ closest_int_value = math.floor(math.ceil(value))\n    if abs(closest_int_value-value)<abs(closest_int_value-value)+1:\n\
    \        return closest_int_value\n    else\n        return closest_int_value+1\n\
    end", "    value <- string_to_integer(value)\n    closest <- abs(value - 1)\n\
    \    if closest < abs(value - 2)\n        return value\n    else \n        return\
    \ value - closest\nend\n\"\"\"\nCreate a function that takes a number representing\
    \ a time (hours and minutes) and returns the closest time to it. If the time is\
    \ equidistant from two times, round it away from zero.", "    if value == \"0\"\
    \ { return 0 }\n    if value == \"-inf\" || value == \"inf\" { return 0 }\n  \
    \  if value == \"nan\" || value == \"\" { return 0 }", "    closest_val::Int64\
    \ = inf\n    for val in string.digits:\n        curr::Int64 = parse(string(value),\
    \ val)\n        if abs(val - curr) < abs(closest_val - closest_val):\n       \
    \     closest_val = curr\n    return closest_val\n\"\"\"\n    Define the function\
    \ closest_ration(). \n    \n    This function is similar to closest_integer(),\
    \ but returns the rational closest to it.\n    \n    Examples\n    >>> closest_ration(\"\
    0.1\")\n    1/10\n    >>> closest_ration(\"15\")\n    15/10\n    >>> closest_ration(\"\
    14.5\")\n    14/10\n    \"\"\"", "    number = parse(Float64, value)\n    diff\
    \ = abs(number - floor(0.1 * number))\n    if diff > 0.5:\n        return floor(0.1\
    \ * number)\n    return ceil(number)\nend\n</cell>\n<code language=julia-1.6>\n\
    # test your function\njulia_set_output(\"22.5\")\n</cell>\n<code language=julia-1.6>\n\
    # run this code to turn in your work!\nusing JLD", "    if value == \"-Inf\" ||\
    \ value == \"Inf\" \n        error(\"value cannot be Infinity, must use -Inf or\
    \ Inf\")\n    else \n        if value ~= value // 1\n            error(\"value\
    \ must be a whole number\")\n        else\n            closest = (Int, 0)\n  \
    \          for i in (-Inf, -Int):\n                val = (i + value) // 1\n  \
    \              if val == closest[1]\n                    closest = (val, i)\n\
    \            closest[1] = closest[1] // 1\n            return closest[1]\n   \
    \ end\nend\n</code>\n<|/ a |>\n<| a dscore=3 |>\nIn julia:\n<code>\njulia> using\
    \ SymPy", "    if value == \"nan\" \n        then return NAN\n    else if value\
    \ == \"inf\" \n        then return INF\n    else if value == \"-inf\" \n     \
    \   then return -INF\n    else if value == \"0\" \n        then return 0\n   \
    \ else if value == \"-\" \n        then return -INF\n    else \n        local\
    \ x::Float64 = parse(String(x))\n        if x < 0.0 \n            then x = -x\n\
    \        if x > 1.0 \n            then x = 1.0\n        return x\n    end\nend\n\
    </cell>\n<code language=julia-1.5>\n\"\"\"\n    closest_inclusive(number::AbstractString)",
  "  closest := round(value::Float64)\n  closest := math.floor(closest)\n  closest\
    \ := math.abs(closest - value)\n  closest := math.ceil(closest)\n  return closest\n\
    end function", "    if value == \"\"\n    then throw NoSolutions\n    else \n\
    \        local min = value\n        local min_inclusive = value\n        local\
    \ diff = 0\n        local min_index = -1\n        local max_index = -1", "   \
    \ if value == \"\" || value == undefined || value == null \n    then return 0\n\
    \    else \n        number = value.toInt()\n        if number == number\n    \
    \        then return number\n            else \n                lower = number\
    \ - 1\n                if lower > number\n                    then return number\n\
    \                    else return lower\n                else\n               \
    \     upper = number + 1\n                    if upper < number\n            \
    \            then return number\n                        else return upper\n \
    \                   else\n                        if number == 0 || number ==\
    \ 1\n                            then return number\n                        else\
    \ \n                            lower = (number - 1).toInt()\n               \
    \             if lower > number\n                                then return number\n\
    \                                else return lower\n                         \
    \   else\n                                upper = (number + 1).toInt()\n     \
    \                           if upper < number\n                              \
    \      then return number\n                                    else return upper\n\
    \                            end\n                    end\n                end\n\
    \        end\n    end\nend\n</cell>\n<text>\n3.2.5 is_integer\nWrite a function\
    \ that takes in a value (string) representing an integer\nand returns True if\
    \ the value is an integer or False otherwise.", "    var closest_integer_value\
    \ = math.ceil((value.toFloat() - 0.0))\n    closest_integer_value = round(closest_integer_value)\n\
    \    return closest_integer_value \n\"\"\"", "    if (abs(value - parse(value))\
    \ < 1)\n        return value\n    else\n        return round(value::Int64)\n \
    \   end\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nNicely done. But `abs(value-parse(value))`\
    \ is unnecessary in the `if` statement. `abs(value)` and `abs(parse(value))` are\
    \ equivalent.\n<|/ c |>\n<| c |>\nYes, I think you're right. Feel free to edit\
    \ the answer and remove that line. Thank you.\n<|/ c |>\n<| c |>\nThank you so\
    \ much for this! This is really helpful. My use case is that the input is always\
    \ a float or integer but the output will always be an integer so I didn't need\
    \ to parse it into a float first. Just removing the parse() function was all I\
    \ needed. Thanks again!\n<|/ c |>\n<| c |>\nI'm glad this helped!\n<|/ c |>\n\
    <| a dscore=3 |>\n<code>\nusing Revise", "  result = find_closest_integer(value)\n\
    \  if result == -1\n    throw(DomainException, (value, \" is not a number\"))\n\
    \  end\n  return result\nend", "    if value == \"\"\n        0\n    elseif value[1]\
    \ in (\"+\",\"-\")\n        parse(Int64(value))\n    else\n        parse(Int64(floor(value)))\n\
    \    end\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\n    closest(list::Vector{String},\
    \ value::String)::String", "    closest = (0,0)\n    for i in [10, 15, 20, 25,\
    \ 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100]:\n        diff\
    \ = abs(value / i)\n        if (diff > closest[1]):\n            closest = (i,\
    \ diff)\n    return closest[0]", "    if value == \"\" then return 0 else\n  \
    \      try \n            val =  tonumber(value)\n            if val /= 0 then\n\
    \                return round(val)\n            else\n                return round(val\
    \ + 0.5)\n        end\n    catch e\n        end\n    return 0\nend\n</code>\n\
    The function returns zero(0) if the given string does not represent a number.\n\
    <code>\nclosest_integer(\"\")\n0\n</code>\n<|/ a tags=lua,lua-table dscore=1 |>\n\
    <| a |>\nThis answer is a modified version of Mike L's answer\n<code>", "    closest_number\
    \ = value\n    if value == \"\"\n        closest_number = 1000000000000\n    else\n\
    \        closest_number = floor(convert(Float64, value))\n    return closest_number\n\
    end", "    \n    # Return an empty value if the value is not convertible to Int64.\n\
    \    if value == \"NaN\" || value == \"Infinity\" || value == \"-Infinity\"\n\
    \    \n        return -999999999999\n    \n    else\n        return round(value::Int64)\n\
    \    end\nend\n</cell>\n<text>\nNow that we have a function that can convert a\
    \ string to a number, let's use it to find the closest number to zero.", "   \
    \ closest_integer = Int(value[value.find(\".\") + 1:])\n    return ifelse(closest_integer\
    \ > Int64(Int.max), Int64(Int.max), closest_integer)\nend\n</cell>\n<text>\nNext,\
    \ we will define an operator to return the string representation of a number.",
  "    closest := 0\n    if isnumeric(value) && value > 0\n        # convert from\
    \ string to Int64\n        value := Int64(value)\n        # find the closest integer\n\
    \        for i in 0 .. value\n            if abs(value-i) < closest\n        \
    \        closest := abs(value-i)\n            end\n        end\n    elseif isnumeric(value)\
    \ && value <= 0\n        closest := abs(value)\n    else\n        # value is not\
    \ numeric\n        raise ArgumentError(\"The argument must be a string.\")\n \
    \   end\n    # round to nearest integer\n    if closest % 1 == 0\n        return\
    \ closest\n    else\n        return round(closest) + 1\n    end\nend\n</cell>\n\
    <text>\nclosest_integer()", "    if value == \"0\"\n        return Int64(0)\n\
    \    elif value == \"-\"\n        return Int64(-closest_integer(\"0\"))\n    else\n\
    \        return Int64(round(Float64(value)))\n    end\nend\n</cell>\n<text>\n\
    Next write a function to compute the number of days between two dates. Since our\
    \ dates are strings in the format \"YYYY-MM-DD\", you'll need to first convert\
    \ them to Julian Dates.", "    \n    num = parse(value)\n    \n    if num > MAXINT\n\
    \        return MAXINT\n    else if num < MININT\n        return MININT\n    else\
    \ if num == MAXINT and num + 1 == MININT\n        return MININT\n    else\n  \
    \      return num\n    \nend", "    if value == \"\" then return 0\n    if value\
    \ == \"-\" then return 0\n    if value == \"inf\" then return 0\n    if value\
    \ == \"-inf\" then return 0\n    if value == \"nan\" then return 0\n    return\
    \ math.floor((math.ceil(value) - math.floor(value))/2)\nend\n</cell>\n<text>\n\
    Next, we define a function that generates a random variable $Z \\sim \\mathcal{N}(0,\
    \ 1)$.", "    \"\"\"Return a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\"\"\"\n    \n    closest_integer\
    \ = (for s in value.split(\" \") \n                    let number = parse(s)\n\
    \                    let diff = abs(number - closest_integer(strings(number)))\n\
    \                    where diff == number::Int64\n                    select number)",
  "    if (value.head == \"-\") then (\n        return - closest_integer(value.tail)\n\
    \    )\n    if (value == \"0\") then (\n        return 0\n    )\n    if (value\
    \ == \"1\") then (\n        return 1\n    )\n    if (value == \"2\") then (\n\
    \        return 2\n    )\n    if (value == \"3\") then (\n        return 3\n \
    \   )\n    if (value == \"4\") then (\n        return 4\n    )\n    if (value\
    \ == \"5\") then (\n        return 5\n    )\n    if (value == \"6\") then (\n\
    \        return 6\n    )\n    if (value == \"7\") then (\n        return 7\n \
    \   )\n    if (value == \"8\") then (\n        return 8\n    )\n    if (value\
    \ == \"9\") then (\n        return 9\n    )\n    if (value == \"10\") then (\n\
    \        return 10\n    )\n    if (value == \"11\") then (\n        return 11\n\
    \    )\n    if (value == \"12\") then (\n        return 12\n    )\n    if (value\
    \ == \"13\") then (\n        return 13\n    )\n    if (value == \"14\") then (\n\
    \        return 14\n    )\n    if (value == \"15\") then (\n        return 15\n\
    \    )\n    if (value == \"16\") then (\n        return 16\n    )\n    if (value\
    \ == \"17\") then (\n        return 17\n    )\n    if (value == \"18\") then (\n\
    \        return 18\n    )\n    if (value == \"19\") then (\n        return 19\n\
    \    )\n    if (value == \"20\") then (\n        return 20\n    )\n    if (value\
    \ == \"21\") then (\n        return 21\n    )\n    if (value == \"22\") then (\n\
    \        return 22\n    )\n    if (value == \"23\") then (\n        return 23\n\
    \    )\n    if (value == \"24\") then (\n        return 24\n    )\n    if (value\
    \ == \"25\") then (\n        return 25\n    )\n    if (value == \"26\") then (\n\
    \        return 26\n    )\n    if (value == \"27\") then (\n        return 27\n\
    \    )\n    if (value == \"28\") then (\n        return 28\n    )\n    if (value\
    \ == \"29\") then (\n        return 29\n    )\n    if (value == \"30\") then (\n\
    \        return 30\n    )\n    if (value == \"31\") then (\n        return 31\n\
    \    )\n    if (value == \"32\") then (\n        return 32\n    )\n    if (value\
    \ == \"33\") then (\n        return 33\n    )\n    if (value == \"34\") then (\n\
    \        return 34\n    )\n    if (value == \"35\") then (\n        return 35\n\
    \    )\n    if (value == \"36\") then (\n        return 36\n    )\n    if (value\
    \ == \"37\") then (\n        return 37\n    )\n", "    \"Create a function that\
    \ takes a value (string) representing a number\" \\\n    and returns the closest\
    \ integer to it. If the number is equidistant\" \\\n    \" from two integers,\
    \ round it away from zero.\"\n    if value == \"-inf\" or value == \"inf\" then\
    \ return 0 \n    if value == \"\" then return 0\n    if value == \"nan\" then\
    \ return 0\n    \n    let parts = value.split(\".\") |> String.split(\"e\") |>\
    \ Array.map String.to_float \n    \n    if parts.Length > 0 then \n        let\
    \ lower, upper = parts |> Array.min\n        let diff = abs(upper - lower) \n\
    \        if diff < 16 then return lower\n        else return upper\n    else\n\
    \        if value.StartsWith(\"0\") then return value.ToCharArray()\n        else\
    \ return value.ToCharArray() |> Array.min\n    end\nend\n</cell>\n<text>\nTest\
    \ your code\nRun the cell below to test your code.", "    if value.is_empty\n\
    \        error(\"The value you provided is empty\")\n    elseif value.isdigit()\n\
    \        error(\"The value you provided is numeric\")\n    else\n        value.parse::Int64\n\
    \    end\n    return value.ceiling()\nend\n\"\"\"\n    Create a function that\
    \ takes a value (string) representing a number\n    and returns the closest decimal\
    \ number to it. If the number is equidistant\n    from two decimal numbers, round\
    \ it away from zero.", "    number = parse_number(value)\n    if number == 0\n\
    \        error(\"Value is equal to 0\")\n    elseif number == -1\n        error(\"\
    Value is equal to -1\")\n    elseif number >= 1\n        return number\n    else\n\
    \        error(\"Value is less than 1\")\n    end\nend\n</cell>\n<code language=julia-1.6>\n\
    \"\"\"\n    closest_integers(value::Union{Float64, String, Vector{Float64}})",
  "    \"\"\"\n    Create a function that takes a value (string) representing a number\n\
    \    and returns the closest integer to it. If the number is equidistant\n   \
    \ from two integers, round it away from zero.", "    return round(parse(Float64(value),\
    \ default = 0.0))\nend", "    if value == \"\"\n        0\n    else\n        if\
    \ value[-1] == \"+\"\n            value == \"0\" + value\n        else\n     \
    \       if value[-1] == \"-\"\n                value == \"0\" + value\n      \
    \      else\n                if value[-1] == \"*\"\n                    value\
    \ == \"0\" + value\n                else\n                    if value[-1] ==\
    \ \"/\"\n                        value == \"0\" + value\n                    else\n\
    \                        try\n                            float(value)\n     \
    \                   catch\n                            0\n                   \
    \     else\n                            int(x)\n                        end\n\
    \                    end\n                end\n            end\n        end\n\
    \    end\nend", "    \n    # if the input is a float, we need to convert it to\
    \ a string\n    if value.is_float\n        value = value.to_string()\n    end",
  "    if value == \"\"\n        error(\"value cannot be an empty string\")\n    end\n\
    \    let value = parse(Float64(value))\n    if value == 0.0\n        error(\"\
    value cannot be 0.0\")\n    end", "    if value == \"\"\n        0\n    else\n\
    \        if value.ends_with(\".\")\n            value.rstrip(\".\").parse::Int64\n\
    \        else\n            value.parse::Int64\n        end\n    end\nend\n</cell>\n\
    <text>\nWe will now use these functions to define a function which will take a\
    \ number\nas input and return the closest integer to the number when rounded to\n\
    the nearest integer.", '    return (value |> float) |> Math.ceil |> Math.floor
    |> int', "    \"\"\"closest_integer(value::String)::Int64\"\"\"\n    \n    \n\
    \    \ndef closest_integer_or_blank(value::String)::Int64 \n    \"\"\"closest_integer_or_blank(value::String)::Int64\"\
    \"\"\n    \n    \n    \ndef closest_float(value::String)::Float64 \n    \"\"\"\
    closest_float(value::String)::Float64\"\"\"\n    \n    \n    \ndef closest_string(value::String)::String\
    \ \n    \"\"\"closest_string(value::String)::String\"\"\"\n    \n    \n    \n\
    def ceil(value::Real)::Real \n    \"\"\"ceil(value::Real)::Real\"\"\"\n    \n\
    \    \n    \ndef ceiling_function(value::Real)::Real \n    \"\"\"ceiling_function(value::Real)::Real\"\
    \"\"\n    \n    \n    \ndef ceiling_function1(value::Real)::Real \n    \"\"\"\
    ceiling_function1(value::Real)::Real\"\"\"\n    \n    \n    \ndef char(value::Char)::Char\
    \ \n    \"\"\"char(value::Char)::Char\"\"\"\n    \n    \n    \ndef clamp(value::Real)::Real\
    \ \n    \"\"\"clamp(value::Real)::Real\"\"\"\n    \n    \n    \ndef clamp_max_value(value::Real)::Real\
    \ \n    \"\"\"clamp_max_value(value::Real)::Real\"\"\"\n    \n    \n    \ndef\
    \ clamp_min_value(value::Real)::Real \n    \"\"\"clamp_min_value(value::Real)::Real\"\
    \"\"\n    \n    \n    \ndef clamp_range(value::Real)::Real \n    \"\"\"clamp_range(value::Real)::Real\"\
    \"\"\n    \n    \n    \ndef clock()::Int \n    \"\"\"clock()::Int\"\"\"\n    \n\
    \    \n    \ndef ctime()::String \n    \"\"\"ctime()::String\"\"\"\n    \n   \
    \ \n    \ndef ctime2()::String \n    \"\"\"ctime2()::String\"\"\"\n    \n    \n\
    \    \ndef ctime3()::String \n    \"\"\"ctime3()::String\"\"\"\n    \n    \n \
    \   \ndef ctime4()::String \n    \"\"\"ctime4()::String\"\"\"\n    \n    \n  \
    \  \ndef ctime5()::String \n    \"\"\"ctime5()::String\"\"\"\n    \n    \n   \
    \ \ndef ctime6()::String \n    \"\"\"ctime6()::String\"\"\"\n    \n    \n    \n\
    def ctime7()::String \n    \"\"\"ctime7()::String", "    \"\"\"Round a value to\
    \ integer nearest to zero.\"\"\"\n    if value == \"\"\n        return -1\n  \
    \  split_str = value.split('.')\n    if len(split_str) > 1\n        a, b = split_str\n\
    \    else:\n        a, b = split_str[0], \"\"\n    return -int(abs(int(a) - int(b)))",
  "    value |> parseInt\n    |> Math.min\n    |> round\n    |> parseInt\nend", " \
    \   if value == \"0\" \n    then return 0 \n    else \n        if value == \"\
    -\" \n        then return 0 \n        else \n            if value == \".\" \n\
    \            then return 0 \n            else \n                if isnumeric(value)\n\
    \                then \n                    let x = convert(Float64, value)\n\
    \                    let y = floor(x + 0.5)\n                    if y > 0 \n \
    \                   then return y \n                    else \n              \
    \          let z = x + abs(y - x)\n                        if z <= y \n      \
    \                  then return z \n                        else return y \n  \
    \              else \n                    throw(ArgumentError(\"value is not numeric.\"\
    ))\n    endif\nendfunction", "    \"\"\"\n    Create a function that takes a value\
    \ (string) representing a number\n    and returns the closest integer to it. If\
    \ the number is equidistant\n    from two integers, round it away from zero.",
  "    closest_integer = \n        if value < 0 \n            minimum = maximum(value\
    \ - 1, 1)\n            minimum == value \n        else\n            minimum =\
    \ maximum(value, 1)\n            minimum == value + 1\n        return minimum\n\
    end\n</cell>\n<code language=julia-1.0>", "    let integers = values.map(parse)\n\
    \    let index = values.indexOf(value)\n    let (closest) = findclosest(integers,\
    \ index)\n    return closest\nend", "    value::Int64\n    local closest, closest0,\
    \ closest, closest1, closest2\n    local min1, min2, max1, max2, diff, minDiff,\
    \ maxDiff, diff0, diff1, diff2", "    closest = toml_int_to_str(closest_toml_int_of_string(value))\n\
    \    if closest == toml_int_to_str(0)\n        error(\"The given value cannot\
    \ be equidistant from two integers.\")\n    end\n    return toml_int_to_str(closest)\n\
    end\n</code>\n<|/ a |>\n<| a tags=julia,toml,integer,floating-point,type-conversion\
    \ |>\nThe function below converts numbers to strings and then to integers. There\
    \ are a couple of things to note here.\nThe first thing to notice is that in Julia,\
    \ numbers are stored as floating point numbers, not integers. The number 0.1 is\
    \ stored as something like 0.10000000000000001.\nThis means that the string 0.1\
    \ is not equal to 0.1, but rather 0.10000000000000001. Since floating point numbers\
    \ are approximations, this can cause problems with certain operations. For example,\
    \ you can multiply two numbers that differ by one ulp from one that differs by\
    \ 100 ulp. This isn't a problem with integers. However, this can lead to issues\
    \ with floating point numbers.\nThe second thing to notice is that the string\
    \ \"0.2\" is not equal to \"0.20000000000000001, because of the way floating point\
    \ numbers are stored.\nA way to fix this problem would be to convert both strings\
    \ to integers, instead of converting one to a string.\n<code>", "    number =\
    \ parse(Float64, value)\n    digits = digitsBetween(Float64(number), Float64(minimum))\n\
    \    if digits < 2 || digits > 10\n        error(\"The given number does not have\
    \ enough digits.\")\n    end = (digits-1)/2\n    if digits == 2\n        return\
    \ round(number)\n    end\n    \n    return round(number*10**(end))\nend", "  \
    \  if (value[0] == '-') {\n        value = value[1:end]\n    }\n    number = parse(value)\n\
    \    closest = (number - math.fabs(number)) % math.fabs(number)\n    if (closest\
    \ < 0 && number > 0 && math.fabs(number) > math.fabs(closest)) {\n        closest\
    \ = math.fabs(number)\n    }\n    return closest\nend\n</code>\n<|/ a |>\n<| a\
    \ |>\nAnother approach using DataFrames is to convert a DataFrame of strings to\
    \ a DataFrame of numbers by using read_csv and then convert to a DataFrame of\
    \ floats by using DataFrame.astype:\n<code>\ndf = pd.read_csv(\"data/data.csv\"\
    , sep=\" \", header=None)\ndf.columns = df.columns.astype(float, copy=False)\n\
    </code>\nThen you can find the closest integer by calculating the absolute difference\
    \ with the original data column:\n<code>\ndf[\"Closest\"] = abs(df[\"Data\"] -\
    \ df[\"Data\"].round()).idxmin()\n</code>\n<|/ a dscore=1 tags=julia |>\n<| a\
    \ dscore=1 tags=julia |>\nOne solution would be to use a list comprehension to\
    \ iterate through your dataset and return the min value as the index of the list:\n\
    <code>\nusing CSV\ndf = CSV.read(\"data.csv\", DataFrame)\nprintln(df)\n# output\n\
    3\xD73 DataFrame\n Row \u2502 Data     Data     Data \n     \u2502 Int64    Float64\
    \  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253C\u2500\u2500\u2500\u2500\u2500\
    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\
    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1\
    \ \u2502 15.0     15.1     15.05\n   2 \u2502 18.0     17.4     17.04\n   3 \u2502\
    \ 15.0     15.2     15.15\nprintln([x[1] for x in df])\n# output\n15.0\n15.0\n\
    15.0\n</code>\nAlternatively, if you want a more generic solution that works for\
    \ any DataFrame, you can also use the Base.DataTypes.findmin function:\n<code>\n\
    julia> using CSV\njulia> df = CSV.read(\"data.csv\", DataFrame)\n3\xD73 DataFrame\n\
    \ Row \u2502 Data     Data     Data \n     \u2502 Int64    Float64  Float64 \n\
    \u2500\u2500\u2500\u2500\u2500\u253C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\
    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\
    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 15.0\
    \     15.1     15.05\n   2 \u2502 18.0     17.4     17.04\n   3 \u2502 15.0  \
    \   15.2     15.15", "    if value == \"\"\n       return 0\n    try\n       return\
    \ parse(\"$value\", base=10)\n    catch e\n       if e.message == \"invalid input\
    \ '$value': not an integer number\"\n           return 0\n       elseif e.message\
    \ == \"invalid input '$value': number out of range\"\n           return 0\n  \
    \     else\n           throw(Error(e.message))\n       end\n    end", "    \n\
    \    if value==\"\"\n        return -1\n    \n    int::Int64\n    closest::Int64\n\
    \    distance::Int64", "    closest_int::Int64 = Inf\n    closest_int::Int64 =\
    \ Inf\n    for int_ in get_ints(value):\n        if int_ < closest_int and int_\
    \ > -closest_int:\n            closest_int = int_\n    if closest_int == Inf:\n\
    \        closest_int = -Inf # Just to satisfy PyCall convention\n    return closest_int\n\
    end", "    if isapprox(value, \"0\") == true then \n        return 0 \n    else\
    \ \n        return round(Float64(value))\nend", "    int_value = to_int(value)\n\
    \    if int_value < 0\n        int_value *= -1\n    return to_int(floor(value))\n\
    end\n</cell>\n<code language=julia-0.4>", "    \"\"\"Find the nearest integer\
    \ value to `value`\"\"\"\n    \n    if abs(value - round(float(value))) < 0.5:\n\
    \        return round(value)\n    return int(value)\nend", "    return round(Float64(value))\n\
    end", "    if value == \"-inf\" || value == \"inf\" || value == \"nan\" || value\
    \ == \"-nan\"\n        then return value\n    else if value == \"0\"\n       \
    \ then return 0\n    else if value == \"1\"\n        then return 1\n    else if\
    \ value == \"2\"\n        then return 2\n    else if value == \"3\"\n        then\
    \ return 3\n    else if value == \"4\"\n        then return 4\n    else if value\
    \ == \"5\"\n        then return 5\n    else if value == \"6\"\n        then return\
    \ 6\n    else if value == \"7\"\n        then return 7\n    else if value == \"\
    8\"\n        then return 8\n    else if value == \"9\"\n        then return 9\n\
    \    else\n        local num = tonumber(value)\n        local round = rounding(num)\n\
    \        if round\n            then return round\n        else \n            local\
    \ num2 = tonumber(value+\".0\")::Int64\n            if num2 == num\n         \
    \       then return num2\n            else \n                local closestNum\
    \ = num2\n                if num > num2\n                    then closestNum =\
    \ num\n                end\n                if num < num2\n                  \
    \  then closestNum = num2\n                end\n                if closestNum\
    \ == num\n                    then return num2\n                end\n        \
    \        if closestNum == num2\n                    then return num\n        \
    \        end\n            end\n        end\n    end\nend\n</cell>\n<code language=julia-1.4>\n\
    \"\"\"\n    round_down(value::Float64)::Float64\n    round_up(value::Float64)::Float64",
  "    \n    closest = -Inf\n    \n    if value == \"-Inf\" \n        closest = -Inf\n\
    \    elseif value == \"+Inf\" \n        closest = -Inf\n    elseif value == \"\
    -Inf\" \n        closest = Inf\n    elseif value == \"+Inf\" \n        closest\
    \ = Inf\n    else\n        \n        let closest = value.floor()\n        let\
    \ closest = abs(closest)\n    end\n    \n    return closest\nend\n</cell>\n<code\
    \ language=julia-1.0>\n\"\"\"\n    closest_integer(value::Union{String,\"Int64\"\
    })", "    closest_integer := Int64(0)\n    function find_closest_integer(value::String)::Int64\n\
    \        if value == \"\" || value == -\"\"\n            return 0\n        if\
    \ isnumber(value)\n            return value\n        else\n            if value\
    \ == \"-inf\" || value == \"inf\" || value == \"nan\"\n                return\
    \ 0\n            else\n                if value == \"0\"\n                   \
    \ return 0\n                end\n            end\n        end\n    end\n    for\
    \ el in split(value, \".\")\n        if isnumber(el)\n            closest_integer\
    \ = maximum(closest_integer, el)\n        else\n            closest_integer =\
    \ maximum(closest_integer, find_closest_integer(el))\n        end\n    end\n \
    \   return closest_integer\nend", "    # your code here\n    pass\n</code>\n<|/\
    \ a tags=julia dscore=3 |>\n<| a dscore=2 |>\nJust wanted to add that as of Julia\
    \ version 1.4 there is now a built-in function called roundup that does exactly\
    \ what you ask:\n<code>\njulia> roundup(\"15\")\n15\njulia> roundup(\"14.5\")\n\
    15\njulia> roundup(\"14\")\n15\njulia> roundup(\"14.5\")\n15\njulia> roundup(\"\
    14.51\")\n15\njulia> roundup(\"14.52\")\n16\njulia> roundup(\"15.51\")\n16\njulia>\
    \ roundup(\"15.52\")\n16\njulia> roundup(\"15.53\")\n16\n</code>\nSee https://docs.julialang.org/en/stable/stdlib/math/?highlight=roundup#Base.roundup\n\
    <|/ a tags=julia |>\n<| a |>\nIf you don't care about precision, you can get away\
    \ with a simple if statement:\n<code>", "    if value == \"-Inf\" || value ==\
    \ \"Inf\" || value == \"\" || value == \"NaN\" \n        then return value\n \
    \   else if value == \"0\" || value == \"-0\" \n        then return 0\n    else\n\
    \        let closest_number = Int(value)\n        if closest_number > Int.max\n\
    \            then return Int.max\n        else if closest_number < Int.min\n \
    \           then return Int.min\n        else\n            let farthest_number\
    \ = Int.max - closest_number\n            return Int64(farthest_number)\nend\n\
    </cell>\n<text>\nNow we'll create our function to take a single input, and create\
    \ and populate our table of values for each of the values we will be using in\
    \ the program.", "    number_to_round :: Int64 = parse(value) \n    round_num\
    \ :: Int64 = number_to_round - abs(number_to_round)\n    if round_num > 0\n  \
    \      round_num += 1\n    return round_num\n</code>\n<|/ a dscore=5 |>\n<| a\
    \ dscore=4 |>\nHere is my variant of A. Taylor's solution, without using eval:\n\
    <code>\nimport Data.List\nimport Data.Maybe", "    if value == \"\"\n        return\
    \ Int64(0)", "    if value == \"\"\n        throw(ArgumentError(\"Input must not\
    \ be an empty string\"))\n    else\n        if abs(parse_number(value)) == Int.MAX_VALUE\n\
    \            throw(ArgumentError(\"Input must be a valid integer or a float\"\
    ))\n        else\n            if isnumber(value)\n                return round(parse_number(value))\n\
    \            else\n                throw(ArgumentError(\"Input must be a valid\
    \ integer or a float\"))\n        end\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert closest_integer(\"15\") == 15\n@assert closest_integer(\"15.0\") == 15\n\
    @assert closest_integer(\"15.3\") == 15\n@assert closest_integer(\"14.5\") ==\
    \ 15\n@assert closest_integer(\"-15\") == -15\n@assert closest_integer(\"-15.0\"\
    ) == -15\n@assert closest_integer(\"-15.3\") == -15\n@assert closest_integer(\"\
    -14.5\") == -15\n</cell>\n<text>\nNow that you have seen an example of defining\
    \ functions, we will now see how they can help us make our code more concise.\
    \ We will also see how we can write a function that will calculate the value of\
    \ an arithmetic expression that you provide.", "    if value == \"0\" \n    then\
    \ return 0\n    else \n        closest_integer(value.sub(\",\",\".\")) + 0.5\n\
    \    end\nend\n\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the next closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.", "     return round(Int64.parse(value))\n\
    end\n</cell>\n<code language=julia-0.4>\n\"\"\"\n    closest_float(strings)",
  "    if isreal(value) && value >= 0\n    then round(value::Int64)\n    else -1\n\
    \    end\nend\n\"\"\"\n    Create a function that takes an array of numbers and\
    \ returns the smallest\n    value of the numbers, excluding NaN.\n    \"\"\"",
  "    if value.is_integer && value > 0\n        return value\n    \n    let closest_int\
    \ = if value.is_integer\n        value.floor()\n    else if value.is_float\n \
    \       value.floor()\n    else\n        NaN", "    if value == \"NaN\" || value\
    \ == \"Infinity\" || value == \"-Infinity\" || isa(value, \"Float64\")\n    then\n\
    \        return Int64(math.floor(value))\n    elseif isa(value, \"Int64\")\n \
    \   then\n        return value\n    elseif isa(value, \"String\") && isa(toInt(value),\
    \ \"Int64\")\n    then\n        return toInt(value)\n    elseif isa(value, \"\
    Int64\") || isa(value, \"Float64\") || isa(value, \"String\") && isa(toInt(value),\
    \ \"Int64\")\n    then\n        return toInt(value)\n    elseif isa(value, \"\
    Int64\") || isa(value, \"Float64\") || isa(value, \"String\") && isa(toFloat(value),\
    \ \"Int64\")\n    then\n        return toFloat(value)\n    else\n        error(\"\
    can't convert a value $value to an Int64\")\n    end\nend", "    \"\"\"\n    Create\
    \ a function that takes a value (string) representing a number\n    and returns\
    \ the closest integer to it. If the number is equidistant\n    from two integers,\
    \ round it away from zero.", "    # Your code here\n    return 0", "    closest_integer\
    \ = value.to_int()\n    if closest_integer == 0\n    else closest_integer\nend\n\
    </cell>\n<code language=julia-0.6>\n# Let's compare these two functions to make\
    \ sure they do the same thing\nclosest_integer(\"10\")\nclosest_integer(\"15.3\"\
    )\n</cell>\n<text>\nGreat! You've created a function that can return the closest\
    \ integer value to any floating point number. You'll now see if your function\
    \ is efficient.", "    if isnumber(value) == false then \n        error(\"value\
    \ is not a number!\") \n    else if isstring(value) == true then \n        error(\"\
    value is a string!\") \n    else if isinteger(value) == true then \n        return\
    \ value \n    else \n        error(\"value is not a number!\") \nend ", "    \"\
    \"\"\n    Create a function that takes a value (string) representing a number\n\
    \    and returns the closest integer to it. If the number is equidistant\n   \
    \ from two integers, round it away from zero.", "    if value::String == \"-Inf\"\
    \ then \n        return -Inf \n    elif value::String == \"Inf\" then \n     \
    \   return Inf \n    else if value::String == \"NaN\" then \n        return NaN\
    \ \n    else \n        val_str = value::String\n        \n        # Convert string\
    \ to a number\n        val_num = tonumber!(val_str)\n        if val_num == val_str\
    \ then \n            return NaN\n        else if val_num == val_num+1 then \n\
    \            return val_num \n        else \n            if val_num > val_num+1\
    \ then\n                # Find the nearest integer, round away from zero\n   \
    \             int_val::Int64 = round(val_num/2)\n                return int_val\n\
    \            else \n                int_val::Int64 = round(val_num)\n        \
    \        return int_val\n        end\n    end\nend\n\"\"\"\n    Create a function\
    \ that takes a value (string) representing a number\n    and returns the value\
    \ closest to it. If the number is equidistant\n    from two numbers, round it\
    \ away from zero.", "    closest_integer = minimum((value |> toInt |> round))\n\
    end", "    if value.is_integer == true\n        return value\n    else\n     \
    \   closest_int::Int64 = closest_integer(value.to_string())\n        if closest_int\
    \ == 0\n            return ceil(value.value)\n        else\n            return\
    \ floor(value.value)\n    end\nend\n</cell>\n<text>\nThe next function is called\
    \ \"next_integer\" because it returns the next integer. For example, next_integer(\"\
    10\") returns 10 and next_integer(\"12.8\") returns 13.", "    value |> to_int32\
    \ |> to_int32 |> div\nend", "    closest_integer(string_to_int(value))\nend\n\
    </cell>\n<code language=julia-1.3>", "    if value == \"\"\n    then\n       \
    \ return 0\n    else\n        let (\n            float_val = Float64(value)\n\
    \            int_val   = Int64(float_val)\n            abs_diff = abs(float_val\
    \ - int_val)\n            closest_integer = int_val\n        )\n        if abs(closest_integer\
    \ - float_val) < abs_diff\n        then\n            closest_integer\n       \
    \ else\n            closest_integer - 1\n        end\n    end\nend\n</cell>\n\
    <text>\nNow let's use these functions to solve the challenge question!", "   \
    \ i = if value == \"-inf\" then -Infinity else 0\n    j = if value == \"+inf\"\
    \ then Infinity else 0\n    val = Float64(value)\n    if val < i then i else val\n\
    \    i += 1\n    j = j - 1\n    val = if val > j then j else val\n    if val ==\
    \ i then Infinity else i\nend\n</cell>\n<code language=julia-1.0>\n@code_native\
    \ Julia_MathNet.closest_integer\n</cell>\n<text>\nFor a given number $x$, rounding\
    \ away from zero means that the closer an input is\n    to the closest integer,\
    \ the greater the value of $x$. So for example if\n    $x = 15$, $\\lceil x \\\
    cdot 2 \\cdot 10^{-n} = \\lceil 15 \\cdot 2 \\cdot 10^{-5} = 5$", "    \n    value\
    \ = as_string(value)\n    function _closest_integer(value::String)::Int64\n  \
    \      # Find the first digit\n        first_digit, sep, next_digit = value.partition('.')\n\
    \        if sep === \"\"\n            return value\n        # Convert digits into\
    \ integers\n        first_digit, next_digit = parse(first_digit, next_digit)\n\
    \        # Round the distance from zero\n        if first_digit < next_digit\n\
    \            first_digit -= 1\n        \n        second_digit = next_digit\n \
    \       while first_digit < second_digit\n            first_digit += 1\n     \
    \       second_digit += 1\n        end\n        \n        return first_digit\n\
    \    end\n    \n    return _closest_integer(value)\nend\n</cell>\n<code language=julia-1.2>\n\
    # Pkg.add(\"BenchmarkTools\")\n</cell>\n<code language=julia-1.2>\nimport BenchmarkTools:\
    \ @btime closest_integer\n</cell>\n<code language=julia-1.2>\nclosest_integer(\"\
    15.3\")\n</cell>\n<code language=julia-1.2>", "    \"\"\"\n    Create a function\
    \ that takes a value (string) representing a number\n    and returns the closest\
    \ integer to it. If the number is equidistant\n    from two integers, round it\
    \ away from zero.", "  if value == \"0\" { return 0 }\n  if value == \"-\" { return\
    \ 0 }\n  return Int64(floor(value))\nend\n</cell>\n<code language=julia-0.6>\n\
    \"\"\"\n    closest_integer_strictly(value::String)::Int64", "    if value ==\
    \ \"\"\n        error \"value can not be empty\"\n    if value == \".\"\n    \
    \    error \"value can not be a decimal point\"\n    \n    number::Int64 = 0\n\
    \    digits::Int64 = 0\n    if isdigit(value[0])\n        digits = length(value)\n\
    \    else\n        digits = count(value, \".\")\n    \n    if digits == 0\n  \
    \      error \"The given value is not a number\"\n    \n    total::Int64 = 0\n\
    \    for i in 1:digits\n        number::Int64 = parseInt((split(value)[i]))\n\
    \        total = total + number\n        if total == number\n            if abs(total)\
    \ <= abs(number)\n                number = total\n            else\n         \
    \       number = total - abs(number)\n        \n    return number\nend\n</cell>\n\
    <text>\nExercise 6: Convert a string to an array of numbers", "    num = value.toInt()\n\
    \    diff = abs(num - num.round())\n    if diff < 1e-9\n        return num\n \
    \   else\n        diff = abs(num - num.round())\n        if diff < 1e-9\n    \
    \        return num\n        else\n            if num - num.floor() < num - num.round()\
    \ \n                then\n                return num - num.floor()\n         \
    \   else\n                return num - num.round()\n        end\n    end\nend\n\
    </code>\n<|/ a tags=julia |>\n<| c |>\nThis fails for `closest_integer(\"1.5\"\
    )`\n<|/ c |>\n<| a |>\nBased on's solution:\n<code>", "    closest_integer :=\
    \ 0\n    closest_integer := round(Int, value)\n    if closest_integer < 0\n  \
    \      closest_integer := closest_integer + Int64(-1)\n    end\n    return closest_integer\n\
    end\n\"\"\"\n    Create a function that takes a value (string) representing a\
    \ number\n    and returns the closest real number to it. If the number is equidistant\n\
    \    from two real numbers, round it away from zero.", "    rounded_value = round(value)\n\
    \    if abs(rounded_value - value) == (rounded_value - 0):\n        return value\n\
    \    else:\n        return rounded_value", "  \n  # Convert the string to a floating\
    \ point number so that we can use math\n  # functions instead of having to use\
    \ explicit for loops.\n  float_val =  tonumber(value)\n  if isnan(float_val) ||\
    \ isinf(float_val)\n    error(get_position()..\"value is nan/infinity\")\n  end",
  "  if value.isnumeric() \n    value \n  else\n    closest_integer(tostring(value))\n\
    \  end\nend\n</cell>\n<code language=julia-0.5>", "    \"\"\"\n    Function that\
    \ takes a value (string) representing a number\n    and returns the closest integer\
    \ to it. If the number is equidistant\n    from two integers, round it away from\
    \ zero.\n    \"\"\"\n    closest_integer = math.ceil(value)\n    if abs(value-closest_integer)\
    \ < math.pow(10.0, -math.floor(math.log(abs(value), 10))): \n        return closest_integer\n\
    \    else: \n        return value\nend \n</cell>\n<code language=julia-0.4>\n\
    # Test Cases\n@testset \"Closest Integer\" begin\n  assert_approx_equals(closest_integer(\"\
    10\"), 10)\n  assert_approx_equals(closest_integer(\"15.3\"), 15)\nend \n</cell>\n\
    <text>\n3.4.2 is_perfect_square\nWrite a function is_perfect_square(value) that\
    \ takes a value (string)\nrepresenting a number and returns a boolean indicating\
    \ whether or not the\nnumber is also a perfect square.", "    if value == \"0\"\
    \ || value == \"\" || is_nan(value) || is_infinite(value) then return 0\n    \n\
    \    var i::Int64\n    var tmp::Int64\n    var tmp2::Int64", "    \"\"\"\n   \
    \ Create a function that takes a value (string) representing a number\n    and\
    \ returns the closest integer to it. If the number is equidistant\n    from two\
    \ integers, round it away from zero.", "    number_as_int::Int = to_int value\n\
    \    if number_as_int == number_as_int+1 then return number_as_int end\n    if\
    \ number_as_int == number_as_int-1 then return number_as_int end\n    \n    difference::Int64\
    \ = abs(number_as_int-number_as_int+1)\n    if difference < abs(number_as_int-number_as_int-1)\
    \ then return number_as_int+1 end\n    return number_as_int-1\nend", "    \n \
    \   if isa(value, \"Int64\")\n        return value\n    if value == \"\"\n   \
    \     return 0", "    if value == \"\"\n        return -1\n    ends_with_decimal\
    \ = value.endswith(\".\")\n    value_int = tofloat(value)\n    if ends_with_decimal\n\
    \        value = value[..-1]\n    ends_with_decimal = value.endswith(\".\")\n\
    \    value_int = tofloat(value)\n    if ends_with_decimal\n        value = value[..-1]\n\
    \    ends_with_decimal = value.endswith(\".\")\n    value_int = tofloat(value)\n\
    \    if ends_with_decimal\n        value = value[..-1]\n    ends_with_decimal\
    \ = value.endswith(\".\")\n    value_int = tofloat(value)\n    if ends_with_decimal\n\
    \        value = value[..-1]\n    ends_with_decimal = value.endswith(\".\")\n\
    \    value_int = tofloat(value)\n    if ends_with_decimal\n        value = value[..-1]\n\
    \    ends_with_decimal = value.endswith(\".\")\n    value_int = tofloat(value)\n\
    \    if ends_with_decimal\n        value = value[..-1]\n    ends_with_decimal\
    \ = value.endswith(\".\")\n    value_int = tofloat(value)\n    if ends_with_decimal\n\
    \        value = value[..-1]\n    ends_with_decimal = value.endswith(\".\")\n\
    \    value_int = tofloat(value)\n    if ends_with_decimal\n        value = value[..-1]\n\
    \    ends_with_decimal = value.endswith(\".\")\n    value_int = tofloat(value)\n\
    \    if ends_with_decimal\n        value = value[..-1]\n    ends_with_decimal\
    \ = value.endswith(\".\")\n    value_int = tofloat(value)\n    if ends_with_decimal\n\
    \        value = value[..-1]\n    ends_with_decimal = value.endswith(\".\")\n\
    \    value_int = tofloat(value)\n    if ends_with_decimal\n        value = value[..-1]\n\
    \    ends_with_decimal = value.endswith(\".\")\n    value_int = tofloat(value)\n\
    \    if ends_with_decimal\n        value = value[..-1]\n    ends_with_decimal\
    \ = value.endswith(\".\")\n    value_int = tofloat(value)\n    if ends_with_decimal\n\
    \        value = value[..-1]\n    ends_with_decimal = value.endswith(\".\")\n\
    \    value_int = tofloat(value)\n    if ends_with_decimal\n        value = value[..-1]\n\
    \    ends_with_decimal = value.endswith(\".\")\n    value_int = tofloat(value)\n\
    \    if ends_with_decimal\n        value = value[..-1]\n    ends_with_decimal\
    \ = value.endswith(\".\")\n    value_int = tofloat(value)\n    if ends_with_decimal\n\
    \        value = value[..-1]\n    ends_with_decimal = value.endswith(\".", " \
    \   if value == \"\"\n        error(\"The value provided was an empty string\"\
    )\n    elseif value == \"0\"\n        error(\"The value provided was zero\")\n\
    \    else\n        return round(::Int64, value)\nend\n\"\"\"\n    Create a function\
    \ that takes a value (string) representing a number\n    and returns the closest\
    \ real number to it. If the number is equidistant\n    from two numbers, round\
    \ it away from zero.", "    closest_integer = Int(0);\n    for d in digits\n \
    \       if value[d] == value[closest_integer]\n            closest_integer++\n\
    \        else\n            break;\n    return closest_integer;\nend\n</cell>\n\
    <code language=julia-1.5>\n#=\nTesting the above function\n=#\nprintln(closest_integer(\"\
    10\") == 10)\nprintln(closest_integer(\"15\") == 15)\nprintln(closest_integer(\"\
    15.3\") == 15)\nprintln(closest_integer(\"15.5\") == 15)\nprintln(closest_integer(\"\
    14.5\") == 15)\nprintln(closest_integer(\"12.99\") == 12)\nprintln(closest_integer(\"\
    100\") == 100)\nprintln(closest_integer(\"100.5\") == 100)\nprintln(closest_integer(\"\
    14\") == 14)\nprintln(closest_integer(\"14.3\") == 14)\nprintln(closest_integer(\"\
    14.5\") == 14)\nprintln(closest_integer(\"-100\") == 100)\nprintln(closest_integer(\"\
    -100.5\") == 100)\nprintln(closest_integer(\"-0\") == 0)\nprintln(closest_integer(\"\
    -0.3\") == 0)\nprintln(closest_integer(\"-14\") == 14)\nprintln(closest_integer(\"\
    14.99\") == 14)\n</cell>\n<code language=julia-1.5>", "     if value == \"-Infinity\"\
    \ then\n     return -Infinity \n     end", "    \n    value = normalize(value)\n\
    \    \n    if value == \"\"\n        return Int64(\"\")\n    \n    if value ==\
    \ \"0\"\n        return Int64(0)\n    \n    if value == \"1\"\n        return\
    \ Int64(1)\n    \n    if value == \"-1\"\n        return Int64(-1)\n    \n   \
    \ splitted = split(value)\n    \n    if len(splitted) == 1 || (len(splitted) ==\
    \ 2 and splitted[1] == \"0\")\n        return Int64(value)\n    \n    left, _right,\
    \ _distance, _number = extract_numbers(value)\n    \n    if _number == 0\n   \
    \     return 0\n    \n    if _number == 1\n        return Int64(1)\n    \n   \
    \ if _number == -1\n        return Int64(-1)\n    \n    if _number == Int64(\"\
    \")\n        return 0\n    \n    if _number == Int64(\"-0\")\n        return 0\n\
    \    \n    if _number == Int64(\"+0\")\n        return 0\n    \n    if _number\
    \ == Int64(\"1\")\n        return Int64(1)\n    \n    if _number == Int64(\"-1\"\
    )\n        return Int64(-1)\n    \n    if _number == Int64(\"inf\")\n        return\
    \ Int64(0)\n    \n    if _number == Int64(\"-inf\")\n        return Int64(0)\n\
    \    \n    if _number == 0\n        return Int64(0)\n    \n    if _number == -1\n\
    \        return Int64(-1)\n    \n    if _number == Int64(\"inf\")\n        return\
    \ Int64(0)\n    \n    if _number == Int64(\"-inf\")\n        return Int64(0)\n\
    \    \n    if _distance == 1\n        return Int64(0)\n    \n    if _distance\
    \ == 2\n        return Int64(1)\n    \n    if _distance == 3\n        return Int64(2)\n\
    \    \n    if _distance == 4\n        return Int64(3)\n    \n    if _distance\
    \ == 5\n        return Int64(4)\n    \n    if _distance == 6\n        return Int64(5)\n\
    \    \n    if _distance == 7\n        return Int64(6)\n    \n    if _distance\
    \ == 8\n        return Int64(7)\n    \n    if _distance == 9\n        return Int64(8)\n\
    \    \n    if _distance == 10\n        return Int64(9)\n    \n    if _distance\
    \ == 11\n        return Int64(10)\n    \n    if _distance == 12\n        return\
    \ Int64(11)\n    \n    if _distance == 13\n        return Int64(12)\n    \n  \
    \  if _distance == 14\n        return Int64(13)\n    \n    if _distance == 15\n\
    \        return Int64(14)\n    \n    if _distance == 16\n        return Int64(15)\n",
  "    integer = to_integer(value)\n    if integer == 0 \n        error(\"Bad argument\"\
    )\n    elseif integer < 0\n        error(\"Bad argument\")\n    elseif abs(integer)\
    \ < abs(number)\n        number = number-abs(integer) \n    elseif abs(integer)\
    \ > abs(number)\n        number = number+abs(integer) \n    else \n        number\
    \ = integer\n    return to_integer(number)", "    if value < 0\n        throw(DomainError(\"\
    The value $value must be positive.\"))\n    else\n        let x = tofloat(value)\n\
    \        if x < 0\n            throw(DomainError(\"The value $value must be a\
    \ positive real number.\"))\n        elseif x == 0 || (x == -1 && x == -2)\n \
    \           throw(DomainError(\"The value $value must not be zero.\"))\n     \
    \   else\n            let y = ceil(x)\n            if x == y\n               \
    \ throw(DomainError(\"The value $value is equidistant from two integers.\"))\n\
    \            else if y == 0\n                throw(DomainError(\"The value $value\
    \ must not be equidistant from two integers.\"))\n            else if y > 0\n\
    \                y\n            else\n                y-1\n        end\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    closest_int_vector\n    Closest\
    \ integer from a vector of integers\n\"\"\"", "    local closest = value\n   \
    \ local digits = String()\n    local factor = 1\n    local digit = 0\n    \n \
    \   for digit in value:gmatch(\"%d\") do\n        table.insert(digits, digit)\n\
    \    end", "    diff = closest_integer(value) - closest_integer(string_to_float(value))\n\
    \    if abs(diff) < 1.0e-9\n        return closest_integer(string_to_float(value))\n\
    \    else\n        return closest_integer(string_to_float(value))\nend", "   \
    \ \n    if isnumeric(value) == true\n        if value != \"\"\n            if\
    \ value == \"0\" \n                return 0\n            else \n             \
    \   if abs(value.-tostring(value)) < abs(value.-tostring(value) + 0.000001)\n\
    \                    return tostring(value).-tostring(value)\n               \
    \ else\n                    return tostring(value).-tostring(value) + 0.0000001\n\
    \        end\n    end", "    ...\nend\n</cell>\n<text>\nExercise\nLet's now see\
    \ some examples of using the function in Julia.", "    if value == \"-inf\" \n\
    \        then return -Inf\n    if value == \"inf\" \n        then return Inf\n\
    \    if value == \"nan\"\n        then return NaN\n    let x = toFloat64(value)\n\
    \    let y = toFloat64(value)\n    let z = toFloat64(value)\n    let w = toFloat64(value)\n\
    \    let t = toFloat64(value)\n    let m = toFloat64(value)\n    let r = toFloat64(value)\n\
    \    let x = toFloat64(value)\n    let y = toFloat64(value)\n    let z = toFloat64(value)\n\
    \    let w = toFloat64(value)\n    let t = toFloat64(value)\n    let m = toFloat64(value)\n\
    \    let r = toFloat64(value)\n    let x = toFloat64(value)\n    let y = toFloat64(value)\n\
    \    let z = toFloat64(value)\n    let w = toFloat64(value)\n    let t = toFloat64(value)\n\
    \    let m = toFloat64(value)\n    let r = toFloat64(value)\n    let x = toFloat64(value)\n\
    \    let y = toFloat64(value)\n    let z = toFloat64(value)\n    let w = toFloat64(value)\n\
    \    let t = toFloat64(value)\n    let m = toFloat64(value)\n    let r = toFloat64(value)\n\
    \    let x = toFloat64(value)\n    let y = toFloat64(value)\n    let z = toFloat64(value)\n\
    \    let w = toFloat64(value)\n    let t = toFloat64(value)\n    let m = toFloat64(value)\n\
    \    let r = toFloat64(value)\n    let x = toFloat64(value)\n    let y = toFloat64(value)\n\
    \    let z = toFloat64(value)\n    let w = toFloat64(value)\n    let t = toFloat64(value)\n\
    \    let m = toFloat64(value)\n    let r = toFloat64(value)\n    let x = toFloat64(value)\n\
    \    let y = toFloat64(value)\n    let z = toFloat64(value)\n    let w = toFloat64(value)\n\
    \    let t = toFloat64(value)\n    let m = toFloat64(value)\n    let r = toFloat64(value)\n\
    \    let x = toFloat64(value)\n    let y = toFloat64(value)\n    let z = toFloat64(value)\n\
    \    let w = toFloat64(value)\n    let t = toFloat64(value)\n    let m = toFloat64(value)\n\
    \    let r = toFloat64(value)\n    let x = toFloat64(value)\n    let y = toFloat64(value)\n\
    \    let z = toFloat64(value)\n    let w = toFloat64(value)\n    let t = toFloat64(value)\n\
    \    let m = toFloat64(value)\n    let r = toFloat64(value)\n    let x = toFloat64(value)\n\
    \    let y = toFloat64(value)\n    let z = toFloat64(value)\n    let w = toFloat64(value)\n\
    \    let t = toFloat64(value)\n    let ", "    if value == \"\"\n        return\
    \ 0 \n    \n    digits = split(value) |> Array.filter(!_.isDigit)\n    let first\
    \ = digits[0..0]\n    let second = digits[1..1]", "    local closest = math.ceil((fromstring(value,\
    \ \".\")::Float - 0)/2)\n    if closest == 0 then\n        closest = 1\n    end",
  "    closest_integer = ceil(fromstring(value)) \nend\n</cell>\n<code language=julia-1.4>\n\
    julia> closest_integer(\"10\")\n10\njulia> closest_integer(\"15.3\")\n15\njulia>\
    \ closest_integer(\"14.5\")\n14\njulia> closest_integer(\"-14.5\")\n-15\njulia>\
    \ closest_integer(\"-2\")\n-2\n</cell>\n<code language=julia-1.4>", '    """Find
    the closest integer to this value (string).', "    \"\"\"Find the closest integer\
    \ value to the input string\"\"\"\n    function nearest_integer(x::String)::Int64\n\
    \        if x.is_integer()\n            return x\n        else if x == \"\"\n\
    \            return NaN\n        else\n            y, _ = parse(x)\n         \
    \   distance = abs(x - y)\n            if distance < 1e-5\n                return\
    \ x\n            else\n                return y\n    end\n    return nearest_integer(value)\n\
    end", "    let number = to_number (value)\n    if number > 0 then\n        let\
    \ (number, delta) = closest_int_step (number)\n        delta\n    else\n     \
    \   let (number, delta) = closest_int_step (-number)\n        -delta\nend\n\"\"\
    \"\n    Find the closest integer to the given number. If the given number\n  \
    \  is equidistant from two integers, round it away from zero. Returns\n    zero\
    \ if rounding away from zero is not possible.", "    \"\"\"\n    Create a function\
    \ that takes a value (string) representing a number\n    and returns the closest\
    \ integer to it. If the number is equidistant\n    from two integers, round it\
    \ away from zero.", "    if value == \"null\" || value == \"NaN\" || value ==\
    \ \"\" || value == \"nan\"\n    then return null\n    else if value == \"0\"\n\
    \    then return 0\n    else if value == \"-Inf\"\n    then return null\n    else\
    \ if value == \"-\" || value == \"inf\"\n    then return null\n    else\n    \
    \    integer = parse(Int64, value)\n        if !isapprox(integer)\n          \
    \  then return null\n        else return integer\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\n# test the function\nclosest_integer(\"10\")\n</cell>\n\
    <code language=julia-1.5>\nclosest_integer(\"15.3\")\n</cell>\n<code language=julia-1.5>\n\
    closest_integer(\"14.5\")\n</cell>\n<code language=julia-1.5>\nclosest_integer(\"\
    -14.5\")\n</cell>\n<code language=julia-1.5>\nclosest_integer(\"1.23e10\")\n</cell>\n\
    <code language=julia-1.5>\nclosest_integer(\"1.23e-10\")\n</cell>\n<code language=julia-1.5>\n\
    closest_integer(\"Infinity\")\n</cell>\n<text>\nExercise: Write a function that\
    \ takes in an array of numbers and returns a vector of the integers closest to\
    \ each of the numbers in the array. Use this function to solve the assignment\
    \ problem. Your function should accept two arguments, the array of numbers and\
    \ the vector of numbers. Your function should return a vector of numbers that\
    \ are closest to each of the numbers in the array of numbers.", "    \"\"\"\n\
    \    Calculate the closest integer to the given value", "  \n  import Text.Regex.Posix\n\
    \  import Base.Plot\n  import Base.math\n  \n  parse::String -> Maybe [(Int, Int)]\n\
    \  parse = Regex.parse_regex(\"\"\"\n      ^\\s*\n      (?P<integer>-?[0-9.]+)\n\
    \      \\s*\n      (?P<unit>[%|:])\n      \\s*\n      (?P<digits>[0-9]+)\n   \
    \   \\s*$\n  \"\"\")\n  \n  digits = parse(String(pad(value)))\n  if digits ==\
    \ Nothing \n    then return Nothing\n  else if digits == Just [] \n    then return\
    \ Nothing\n  else \n    integer <- digits ^. 1 \n    unit   <- digits ^. 2\n \
    \   digits <- digits ^. 3\n    if unit == \"%\" \n      then return Just([(unit\
    \ <> \"-\", \n                      ((integer + Base.Plot.relative_magnitude(integer))\
    \ * 10.0 /\n                       (Base.Plot.relative_magnitude(integer) + \n\
    \                        Base.Plot.relative_magnitude(integer) + integer))\n \
    \                     )])\n    else if integer <> 0 \n      then return Just([(unit,\
    \ (integer + integer%10))])\n    else if unit == \"\"\n      then return Just([(unit,\
    \ (integer + Base.Plot.relative_magnitude(integer))*\n                       \
    \ 10.0/(Base.Plot.relative_magnitude(integer) + \n                           \
    \    Base.Plot.relative_magnitude(integer) + integer))\n                     \
    \  ])\n    else\n      error(\"Invalid input: not an integral value or a percentage\"\
    )\nend\n</cell>\n<text>\nExercise: Write a function that takes a string representing\
    \ a number and\nreturns the decimal representation of it.", "    closest_int_value\
    \ = math.ceil(value::Float64)\n    if value >= 0 & value <= closest_int_value\
    \ \n        then closest_int_value \n        else value \n    end\nend", "   \
    \ \"\"\"\n    Create a function that takes a value (string) representing a number\n\
    \    and returns the closest integer to it. If the number is equidistant\n   \
    \ from two integers, round it away from zero.", "    if value == \"-inf\" {\n\
    \        return -Float64(inf)\n    }\n    if value == \"inf\" {\n        return\
    \ Float64(inf)\n    }\n    var result::Int64\n    try\n        result = parse(value).get_uint64()\n\
    \    catch e {\n        result = -1\n    }\n    if result == -1 {\n        result\
    \ = -1\n    }\n    if result < 0 {\n        result = -result\n    }\n    return\
    \ result\nend", "\"\"\"\n    Return the closest integer (in the sense of rounding\
    \ away\n    from zero) to the given integer.", "    \"\"\"\n    Create a function\
    \ that takes a value (string) representing a number\n    and returns the closest\
    \ integer to it. If the number is equidistant\n    from two integers, round it\
    \ away from zero.", "    return toInt(toDouble(value))\nend\n</cell>\n<code language=julia-0.6>\n\
    \"\"\"\n    Convert the given number into binary string\n\"\"\"", "    \n    local\
    \ closest = value.tonumber()\n    local closestIndex = 1 -- 0 is closest to nothing\n\
    \    local closestDistance = Float64(math.inf)\n    for i = closestIndex to math.max(1,\
    \ closestIndex + closestIndex end) do \n        local currentDistance = abs(i\
    \ - closest)\n        if currentDistance < closestDistance then\n            closestIndex\
    \ = i\n            closestDistance = currentDistance\n        end\n    end\n \
    \   return closestIndex\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\nThe solution\
    \ using Julia is as below: \n<code>", "\"\"\"\n    Create a function that takes\
    \ a value (string) representing a number\n    and returns the closest integer\
    \ to it. If the number is equidistant\n    from two integers, round it away from\
    \ zero.", "    int_value = value.parse::Int64\n    if abs(int_value - int_value)\
    \ == Int(1)\n        int_value\n    else\n        int_value - int_value % Int(2)\n\
    end\n</code>\n<|/ a |>\n<| a tags=julia |>\n<code>", "    if value == \"-Infinity\"\
    \ || value == \"Infinity\" \n    then return value\n    else\n        val =  tonumber(value)\n\
    \        if val == val \n        then return val\n        else \n            near_integer\
    \ = int(val + 0.5)\n            far_integer = int(val - 0.5)\n            \n \
    \           if abs(near_integer - val) < abs(far_integer - val)\n            then\
    \ return near_integer\n            else return far_integer\n    end\nend\n</cell>\n\
    <text>\nAs a reminder, you can call functions as if they were values. The function\
    \ we wrote earlier closest_integer is just that, a function. Just like a variable,\
    \ functions are first-class values. For example,", "    \"\"\"\n    Find the closest\
    \ integer to the number represented by `value`\n    >>> closest_integer(\"10\"\
    )\n    10\n    >>> closest_integer(\"15.3\")\n    15\n    \"\"\"\n    \n    if\
    \ value == \"0\":\n        return 0\n    elif value == \"-1\":\n        return\
    \ -1\n    \n    digits = value[1..]\n    \n    power = 2\n    \n    for d in digits:\n\
    \        power = power * 10\n        \n    digits = digits-1\n    \n    int_part\
    \ = 0\n    \n    while digits > 0:\n        int_part = int_part * 10 + digits\n\
    \        digits = digits - power\n    \n    int_part = int_part + int_part\n \
    \   \n    if int_part % power:\n        return int_part // power\n    else:\n\
    \        return int_part", "\"\"\"\n    Create a function that takes a value (string)\
    \ representing a number\n    and returns the closest integer to it. If the number\
    \ is equidistant\n    from two integers, round it away from zero.", "    \"\"\"\
    \"\"\"\n    return closest(value, \"Int64\", int)", "    if value == \"\" then\
    \ return 0 \n    if value.isnumeric() then return value\n    if isnumeric(value)\
    \ == false then return 0 \n    if value.isdigit() then return value.toInt64()\
    \ \n    let digits = value.split(\".\") \n    if digits.length == 1 then return\
    \ digits[0].toInt64() \n    let digitsArray = digits[1].toInt64().digits\n   \
    \ digitsArray[1] -= digitsArray[0]\n    digitsArray[0] = -digitsArray[0]\n   \
    \ let firstDigit = digitsArray[0]\n    let lastDigit = digitsArray[digitsArray.length-1]\n\
    \    if abs(firstDigit - lastDigit) < 1e-6 then return digitsArray[0]\n    if\
    \ abs(lastDigit - firstDigit) < 1e-6 then return digitsArray[digitsArray.length-1]\n\
    \    let resultDigit = digitsArray[0]\n    let closestDiff = lastDigit - firstDigit\
    \ \n    for digit in digitsArray[1..digitsArray.length-1] do \n        let currDiff\
    \ = abs(digit - resultDigit)\n        if currDiff < closestDiff then \n      \
    \      resultDigit = digit\n            closestDiff = currDiff\n    return digitsArray[0]\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThanks, I've added a Python version as well.\
    \ I would love to know what's happening with the floating point math.\n<|/ c |>\n\
    <| c |>\nI haven't delved into the details of how it's implemented but if you're\
    \ interested in learning more about it I recommend a book on algorithms, e.g.\
    \ [Introduction to Algorithms](http://introcs.cs.princeton.edu/), by Cormen, Leiserson,\
    \ Rivest, Stein, and Stephens.\n<|/ c |>\n<| c |>\nFor some reason, using your\
    \ code, the closest number to the string \"-1\" isn't \"-1\" but \"0\" instead.\
    \ Also, I used the function \"isdigit\" to avoid a type error. I'm using Julia\
    \ v1.0.5. Could you post the code that generates \"-1\" and \"0\" please? Thanks.\n\
    <|/ c |>\n<| c |>\nOh dear, it seems your Python code is returning the wrong result...\
    \ I've updated it so that it now rounds up instead of down.\n<|/ c |>\n<| a |>\n\
    Here's a solution in Julia:\n<code>", "    \n    number = parse(Int, value)\n\
    \    \n    difference = (number - closest_integer(parse(Int, value)))\n    \n\
    \    if difference < 0\n        return closest_integer(parse(Int, value)) + (difference\
    \ * -1)\n    elseif difference > 0\n        return closest_integer(parse(Int,\
    \ value)) + (difference * -1)\n    else\n        return number\n    end\nend\n\
    \    \n\"\"\"\n    Find the nearest integer to the input value. If the value is\
    \ equidistant \n    from two integers, round it away from zero.", "    \n    \"\
    \"\"\n    Create a function that takes a value (string) representing a number\n\
    \    and returns the closest float to it. If the number is equidistant\n    from\
    \ two floats, round it away from zero.", "    closest_value = find_closest(value,\
    \ 0, 100, 100)\n    return closest_value\nend \n</cell>\n<code language=julia-1.0>\n\
    \"\"\"\n    find_closest(value::String, repr::Int64, repr2::Int64, min::Int64,\
    \ max::Int64)::Int64", "    if value[0] == '-' or value[0] == '+' then\n     \
    \   return if value[0] == '-' then -0 else 0 end\n    else if value[end] == '.'\
    \ then\n        return value[0..end-2]\n    elseif value[end] == 'e' then\n  \
    \      return value[0..end-1]\n    else\n        return parse(value).round().trunc()\n\
    \    end\nend\n</cell>\n<code language=julia-1.6>\n\"\"\"\n    closest_number(num::Float64)",
  "    closest_integer_value = int64(round(float(value)))\n    if closest_integer_value\
    \ == 0:\n        closest_integer_value = int64(round(value))\n    return closest_integer_value\n\
    </code>\n<|/ a |>\n<| c |>\nHi, I appreciate you taking the time to help me. I\
    \ will give this a try.\n<|/ c |>\n<| c |>\nHi, thank you so much for your help.\
    \ This is great. Could you please have a look at the edits and see if that is\
    \ what you meant by \"more complicated\"? Thank you again.\n<|/ c |>\n<| c |>\n\
    Oh, I see where I was wrong. I had thought you were asking for a general way to\
    \ handle any number in one variable, not just the examples in your question. Sorry\
    \ about that.\n<|/ c |>\n<| a tags=julia |>\nI'm adding this answer to an old\
    \ question, that got me here. I don't know what version this was added into, but\
    \ it's very similar to a version I found here: https://gist.github.com/aaronjensen/726d17ca9690ab015c86\n\
    <code>\n# return closest integer less than or equal to a given integer", "   \
    \ if value == \"\"\n        return Int64(0)\n    digits = value.chars().filter(elem\
    \ -> elem >= '0' and elem <= '9')\n    digits_as_ints = digits.map(Int64)\n  \
    \  smallest_num = min(digits_as_ints)\n    largest_num = max(digits_as_ints)\n\
    \    if smallest_num == largest_num\n        return smallest_num\n    if abs(largest_num\
    \ - smallest_num) < 1\n        return smallest_num\n    return smallest_num +\
    \ Int(abs(largest_num - smallest_num) / Int64(2))", "    if isnumeric(value)\n\
    \        if value == Int(value) // value\n            Int(value)\n        else\n\
    \            round(Int64(value) / value)\n    end\nend", "\"\"\"\n    Create a\
    \ function that takes a value (string) representing a number\n    and returns\
    \ the closest integer to it. If the number is equidistant\n    from two integers,\
    \ round it away from zero."]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
