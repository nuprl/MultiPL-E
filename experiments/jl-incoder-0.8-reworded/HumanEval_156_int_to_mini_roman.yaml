name: HumanEval_156_int_to_mini_roman
language: jl
prompt: "\"\"\"\n    Given a positive integer, obtain its roman numeral equivalent\
  \ as a string,\n    and return it in lowercase.\n    Restrictions: 1 <= num <= 1000\n\
  \n    Examples:\n    >>> int_to_mini_roman(19)\n    \"xix\"\n    >>> int_to_mini_roman(152)\n\
  \    \"clii\"\n    >>> int_to_mini_roman(426)\n    \"cdxxvi\"\n    \"\"\"\nfunction\
  \ int_to_mini_roman(number::Int64)::String \n"
tests: "using Test\n\n@testset begin\n\ncandidate = int_to_mini_roman;\n\t@test(candidate(19)\
  \ == \"xix\")\n\t@test(candidate(152) == \"clii\")\n\t@test(candidate(251) == \"\
  ccli\")\n\t@test(candidate(426) == \"cdxxvi\")\n\t@test(candidate(500) == \"d\"\
  )\n\t@test(candidate(1) == \"i\")\n\t@test(candidate(4) == \"iv\")\n\t@test(candidate(43)\
  \ == \"xliii\")\n\t@test(candidate(90) == \"xc\")\n\t@test(candidate(94) == \"xciv\"\
  )\n\t@test(candidate(532) == \"dxxxii\")\n\t@test(candidate(900) == \"cm\")\n\t\
  @test(candidate(994) == \"cmxciv\")\n\t@test(candidate(1000) == \"m\")\nend\n"
completions: ["    if number == 0 \n        return \"0\" \n    if number <= 5000 \n\
    \        return roman_to_mini_roman(number) \n    \n    big = int_to_mini_roman(number\
    \ / 100) \n    small = int_to_mini_roman(number % 100) \n    return big + small\
    \ \nend ", "    if number == 0 then\n        \"0\"\n    elseif number == 1 then\n\
    \        \"x\"\n    elseif number == 2 then\n        \"xx\"\n    elseif number\
    \ == 3 then\n        \"xxx\"\n    elseif number < 4 then\n        \"m\"\n    elseif\
    \ number < 9 then\n        \"mm\"\n    elseif number < 16 then\n        \"cm\"\
    \n    elseif number < 26 then\n        \"cd\"\n    elseif number < 36 then\n \
    \       \"cc\"\n    elseif number < 52 then\n        \"xc\"\n    elseif number\
    \ < 69 then\n        \"xl\"\n    elseif number < 84 then\n        \"l\"\n    elseif\
    \ number < 109 then\n        \"xc\"\n    elseif number < 124 then\n        \"\
    l\"\n    elseif number < 150 then\n        \"xc\"\n    elseif number < 166 then\n\
    \        \"xl\"\n    elseif number < 182 then\n        \"l\"\n    elseif number\
    \ < 197 then\n        \"xc\"\n    elseif number < 214 then\n        \"l\"\n  \
    \  elseif number < 229 then\n        \"xc\"\n    elseif number < 244 then\n  \
    \      \"l\"\n    elseif number < 259 then\n        \"xc\"\n    elseif number\
    \ < 274 then\n        \"l\"\n    elseif number < 289 then\n        \"xc\"\n  \
    \  elseif number < 304 then\n        \"l\"\n    elseif number < 320 then\n   \
    \     \"xc\"\n    elseif number < 336 then\n        \"l\"\n    elseif number <\
    \ 352 then\n        \"xc\"\n    elseif number < 368 then\n        \"l\"\n    elseif\
    \ number < 384 then\n        \"xc\"\n    elseif number < 409 then\n        \"\
    l\"\n    elseif number < 424 then\n        \"xc\"\n    elseif number < 449 then\n\
    \        \"l\"\n    elseif number < 464 then\n        \"xc\"\n    elseif number\
    \ < 489 then\n        \"l\"\n    elseif number < 504 then\n        \"xc\"\n  \
    \  elseif number < 519 then\n        \"l\"\n    elseif number < 544 then\n   \
    \     \"xc\"\n    elseif number < 559 then\n        \"l\"\n    elseif number <\
    \ 574 then\n        \"xc\"\n    elseif number < 589 then\n        \"l\"\n    elseif\
    \ number < 604 then\n        \"xc\"\n    elseif number ", "    if number == 0\n\
    \    then \"0\"\n    else if number < 1\n    then \"0\"\n    else if number <\
    \ 3\n    then \"i\"\n    else if number < 6\n    then \"ii\"\n    else if number\
    \ < 9\n    then \"iii\"\n    else if number < 12\n    then \"iv\"\n    else if\
    \ number < 15\n    then \"v\"\n    else if number < 18\n    then \"vi\"\n    else\
    \ if number < 21\n    then \"vii\"\n    else if number < 24\n    then \"ix\"\n\
    \    else if number < 27\n    then \"x\"\n    else if number < 30\n    then \"\
    xi\"\n    else if number < 33\n    then \"xii\"\n    else if number < 36\n   \
    \ then \"xiii\"\n    else if number < 39\n    then \"xiv\"\n    else if number\
    \ < 42\n    then \"xvi\"\n    else if number < 45\n    then \"xvii\"\n    else\
    \ if number < 48\n    then \"xix\"\n    else if number < 51\n    then \"xx\"\n\
    \    else if number < 54\n    then \"xxi\"\n    else if number < 57\n    then\
    \ \"xxii\"\n    else if number < 60\n    then \"xxiii\"\n    else if number <\
    \ 63\n    then \"xxiv\"\n    else if number < 66\n    then \"xxv\"\n    else if\
    \ number < 69\n    then \"xxvi\"\n    else if number < 72\n    then \"xxvii\"\n\
    \    else if number < 75\n    then \"xxix\"\n    else if number < 78\n    then\
    \ \"xxx\"\n    else if number < 80\n    then \"xxxi\"\n    else if number < 83\n\
    \    then \"xxxii\"\n    else if number < 86\n    then \"xxxiii\"\n    else if\
    \ number < 89\n    then \"xxxiv\"\n    else if number < 92\n    then \"xxxv\"\n\
    \    else if number < 95\n    then \"xxvi\"\n    else if number < 98\n    then\
    \ \"xxvii\"\n    else if number < 101\n    then \"xxix\"\n    else if number <\
    \ 104\n    then \"xxx\"\n    else if number < 107", "    mini_roman = \"\"\n \
    \   \n    if number >= 1000:\n        roman_numeral = \"M\"\n        for ii in\
    \ (1 to 11):\n            roman_numeral = roman_numeral + \"C\"\n            if\
    \ number >= ii+1000:\n                roman_numeral = roman_numeral + \"D\"\n\
    \                for iii in (1 to 11):\n                    roman_numeral = roman_numeral\
    \ + \"C\"\n                    if number >= ii+iii+1000:\n                   \
    \     roman_numeral = roman_numeral + \"D\"\n                        for iv in\
    \ (1 to 11):\n                            roman_numeral = roman_numeral + \"C\"\
    \n                            if number >= ii+iii+iv+1000:\n                 \
    \               roman_numeral = roman_numeral + \"D\"\n                      \
    \          for ivi in (1 to 11):\n                                    roman_numeral\
    \ = roman_numeral + \"C\"\n                                    if number >= ii+iii+iv+ivi+1000:\n\
    \                                        roman_numeral = roman_numeral + \"D\"\
    \n                                        for ivii in (1 to 11):\n           \
    \                                 roman_numeral = roman_numeral + \"C\"\n    \
    \                                        if number >= ii+iii+iv+ivi+ivii+1000:\n\
    \                                                roman_numeral = roman_numeral\
    \ + \"D\"\n                                                for iviii in (1 to\
    \ 11):\n                                                    roman_numeral = roman_numeral\
    \ + \"C\"\n                                                    if number >= ii+iii+iv+ivi+ivii+iviii+1000:\n\
    \                                                        roman_numeral = roman_numeral\
    \ + \"D\"\n                                                        if number >=\
    \ ii+iii+iv+ivi+ivii+iviii+iv+1000:\n                                        \
    \                    roman_numeral = roman_numeral + \"L\"\n                 \
    \                                       else:\n                              \
    \                              roman_numeral = roman_numeral + \"M\"\n       \
    \                                                     \n                     \
    \                   return roman_numeral\n                    else:\n        \
    \                roman_numeral = roman_numeral + \"M\"\n                     \
    \   \n                        \n    \n    \n    \n    if number >= 100:\n    \
    \    roman_numeral = \"C\"\n        for ii in (1 to 11):\n            roman_numeral\
    \ = roman_numeral + \"D\"\n            if number >= ii+100:\n                roman_numeral\
    \ = roman_numeral + \"C\"\n                for iii in (1 to 11):\n           \
    \         roman_numeral = roman_numeral + \"D\"\n                    if number\
    \ >= ii+iii+100:\n                        roman_numeral = roman_numeral + \"C\"\
    \n                        for iv in ", "  int_to_roman(number)\n  roman = \"i\"\
    \n  for m in strings:\n    if m.find(\"i\") < 0 and m.find(\"v\") < 0:\n     \
    \ if m.find(\"x\") < 0 and m.find(\"l\") < 0 and m.find(\"c\") < 0 and m.find(\"\
    d\") < 0 and m.find(\"n\") < 0 and m.find(\"m\") < 0 and\n         m.find(\"p\"\
    ) < 0 and m.find(\"f\") < 0 and m.find(\"s\") < 0 and m.find(\"g\") < 0 and m.find(\"\
    h\") < 0 and m.find(\"v\") < 0:\n        continue\n      if m.find(\"i\") < 0:\n\
    \        roman += \"ii\"\n      if m.find(\"v\") < 0:\n        roman += \"v\"\n\
    \      if m.find(\"x\") < 0:\n        roman += \"x\"\n      if m.find(\"l\") <\
    \ 0:\n        roman += \"l\"\n      if m.find(\"c\") < 0:\n        roman += \"\
    c\"\n      if m.find(\"d\") < 0:\n        roman += \"d\"\n      if m.find(\"n\"\
    ) < 0:\n        roman += \"n\"\n      if m.find(\"m\") < 0:\n        roman +=\
    \ \"m\"\n      if m.find(\"p\") < 0:\n        roman += \"p\"\n      if m.find(\"\
    f\") < 0:\n        roman += \"f\"\n      if m.find(\"s\") < 0:\n        roman\
    \ += \"s\"\n      if m.find(\"g\") < 0:\n        roman += \"g\"\n      if m.find(\"\
    h\") < 0:\n        roman += \"h\"\n      if m.find(\"v\") < 0:\n        roman\
    \ += \"v\"\n  return roman.lower()\nend", "    roman = \"\"\n    for n in [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]\
    \ \n        roman = roman * n\n        return roman\n    end\nend", "    let i\
    \ = number % 100\n    let num = (number - i) // 10\n    if i >= 10 && i <= 35\n\
    \        then mini_roman = mini_roman + roman_nums[i] + mini_roman\n        else\
    \ mini_roman = mini_roman + roman_nums[num]\n    return mini_roman.lower()\nend\n\
    \"\"\"\n    Given a string, return its corresponding positive integer.\n    Restrictions:\
    \ Must contain only digits.\n    \n    Examples:\n    >>> string_to_int(\" -5\
    \ \")\n    -5 \n    >>> string_to_int(\"   42   \")\n    42\n    >>> string_to_int(\"\
    \   -42   \")\n    -42\n    >>> string_to_int(\"  -42.1 \")\n    -42\n    \"\"\
    \"", "    roman_nums:Array{Char, 1} = [\"I\", \"V\", \"X\", \"L\", \"C\", \"D\"\
    , \"M\", \"M\", \"I\", \"V\", \"X\"]\n    roman_nums_rev:Array{Char, 1} = [\"\
    i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\", \"m\", \"i\", \"v\", \"x\"]\n \
    \   if number < 0\n        error(\"negative number\")\n    end\n    if number\
    \ == 0\n        roman_nums_rev = roman_nums\n    else\n        if number < 10\n\
    \            roman_nums_rev[number + 10] = \"m\" + roman_nums_rev[number + 10]\n\
    \        elseif number < 100\n            roman_nums_rev[number - 10] = \"c\"\
    \ + roman_nums_rev[number - 10]\n        else\n            if number < 1000\n\
    \                roman_nums_rev[number - 100] = \"l\" + roman_nums_rev[number\
    \ - 100]\n            else\n                roman_nums_rev[number - 100] = \"\
    x\" + roman_nums_rev[number - 100]\n            end\n        end\n    end\n  \
    \  return join(roman_nums_rev, \"\")\nend\n</cell>\n<code language=julia-0.6>",
  "    # Your code goes here\n    if number <= 0 or number > 1000\n        error(\"\
    invalid input\")\n    end", "    if number == 0 then \"0\"\n    if number == 1\
    \ then \"x\"\n    if number == 2 then \"l\"\n    if number == 3 then \"c\"\n \
    \   if number == 4 then \"lj\"\n    if number == 5 then \"xc\"\n    if number\
    \ == 6 then \"xl\"\n    if number == 7 then \"xc\"\n    if number == 8 then \"\
    xc\"\n    if number == 9 then \"xc\"\n    if number == 10 then \"xc\"\n    if\
    \ number == 11 then \"xc\"\n    if number == 12 then \"xc\"\n    if number ==\
    \ 13 then \"xc\"\n    if number == 14 then \"xc\"\n    if number == 15 then \"\
    xc\"\n    if number == 16 then \"xc\"\n    if number == 17 then \"xc\"\n    if\
    \ number == 18 then \"xc\"\n    if number == 19 then \"xc\"\n    if number ==\
    \ 20 then \"xc\"\n    if number == 21 then \"xc\"\n    if number == 22 then \"\
    xc\"\n    if number == 23 then \"xc\"\n    if number == 24 then \"xc\"\n    if\
    \ number == 25 then \"xc\"\n    if number == 26 then \"xc\"\n    if number ==\
    \ 27 then \"xc\"\n    if number == 28 then \"xc\"\n    if number == 29 then \"\
    xc\"\n    if number == 30 then \"xc\"\n    if number == 31 then \"xc\"\n    if\
    \ number == 32 then \"xc\"\n    if number == 33 then \"xc\"\n    if number ==\
    \ 34 then \"xc\"\n    if number == 35 then \"xc\"\n    if number == 36 then \"\
    xc\"\n    if number == 37 then \"xc\"\n    if number == 38 then \"xc\"\n    if\
    \ number == 39 then \"xc\"\n    if number == 40 then \"xc\"\n    if number ==\
    \ 41 then \"xc\"\n    if number == 42 then \"xc\"\n    if number == 43 then \"\
    xc\"\n    if number == 44 then \"xc\"\n    if number == 45 then \"xc\"\n    if\
    \ number == 46 then \"xc\"\n    if number == 47 then \"xc\"\n    if number ==\
    \ 48 then \"xc\"\n    if number == 49 then \"xc\"\n    if number == 50 then \"\
    xc", "        if number <= 0 || number >= 1000000 \n            raise ArgumentError(\"\
    Not a valid number for int_to_mini_roman\")\n        if number == 0 \n       \
    \     return \"0\"\n        mini_roman = \"\"\n        prev_num = 0\n        for\
    \ i in range(number) \n            mini_roman += int_to_mini_roman(prev_num) +\
    \ int_to_mini_roman_letter(prev_num+1-i)\n            prev_num = i\n        end\n\
    \        return mini_roman\n    end\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\n\
    import Data.List", "    roman = map(x->romanize(x, \"x\"), num2roman(number))\n\
    \    return join(roman, \"\")\nend", "    if number == 0 \n        then return\
    \ \"\"\n    else \n        roman::Array{Char,1} = ['i', 'ii', 'iii', 'iv', 'v',\
    \ 'vi', 'vii']\n        roman_sum::Int64 = number\n        for ii in 1:length(roman)\n\
    \            if roman_sum == 0 \n                then return roman[ii]\n     \
    \       else \n                roman_sum -= roman[ii]\n        end\n        return\
    \ roman[end-1]\n    end\nend\n</code>\nThis code can be further optimized by using\
    \ a hash table to look up the roman numerals instead of an array, and also by\
    \ not using an array for the roman numerals but a hash of functions for the roman\
    \ numerals, for which you would have to make your own Roman class.\n<|/ a dscore=4\
    \ |>\n<| c |>\nThis looks better than my answer\n<|/ c |>\n<| c |>\nThanks! This\
    \ looks better!\n<|/ c |>\n<| c |>\nGreat answer, thanks!\n<|/ c |>\n<| c |>\n\
    I love this answer. However it does not work for negative numbers. `int_to_mini_roman(-10)`\
    \ returns `\"\"` instead of `\"-\"`\n<|/ c |>\n<| c |>\nI fixed the bug. Now it\
    \ works for negative numbers, as well as positive integers.\n<|/ c |>\n<| a tags=julia,language-features,function\
    \ |>\nHere's a solution using macros, a bit like in Python. \n<code>", "    if\
    \ number < 0 || number > 1000\n        return \"\"\n    roman = int_to_roman(number)\n\
    \    mini_roman = reverse(roman)\n    return mini_roman\nend\n</code>\n<|/ a tags=julia,number-formatting\
    \ |>\n<| a tags=julia,number-formatting |>\n<code>", "    roman_numerals = roman_numerals_of(number)\n\
    \    if roman_numerals.is_empty\n        return \"NA\"\n    roman_numerals = roman_numerals.sort\n\
    \    if roman_numerals[1] == \"i\" && roman_numerals[2] == \"i\"\n        return\
    \ \"xix\"\n    roman_numerals = roman_numerals.map {\n        roman_to_int(roman)\
    \ => roman }\n    mini_roman = mini_roman_of(roman_numerals)\n    return mini_roman.lower()",
  "    romans = {\n        1 => \"i\",\n        5 => \"ii\",\n        9 => \"iii\"\
    ,\n        13 => \"iv\",\n        17 => \"v\",\n        20 => \"vi\",\n      \
    \  27 => \"vii\",\n        33 => \"v\",\n        40 => \"vi\",\n        49 =>\
    \ \"vii\",\n        53 => \"v\",\n        60 => \"iii\",\n        67 => \"iv\"\
    ,\n        70 => \"v\",\n        79 => \"vii\",\n        90 => \"vi\",\n     \
    \   99 => \"iii\",\n        100 => \"i\",\n        123 => \"cm\",\n        141\
    \ => \"m\",\n        153 => \"mm\",\n        163 => \"m\",\n        173 => \"\
    mm\",\n        183 => \"cm\",\n        193 => \"cm\",\n        203 => \"cm\",\n\
    \        213 => \"cm\",\n        223 => \"cm\",\n        233 => \"cm\",\n    \
    \    243 => \"cm\",\n        253 => \"cm\",\n        263 => \"cm\",\n        273\
    \ => \"cm\",\n        283 => \"cm\",\n        293 => \"cm\",\n        303 => \"\
    cm\",\n        313 => \"cm\",\n        323 => \"cm\",\n        333 => \"cm\",\n\
    \        343 => \"cm\",\n        353 => \"cm\",\n        363 => \"cm\",\n    \
    \    373 => \"cm\",\n        383 => \"cm\",\n        393 => \"cm\",\n        403\
    \ => \"cm\",\n        413 => \"cm\",\n        423 => \"cm\",\n        431 => \"\
    cm\",\n        441 => \"cm\",\n        451 => \"cm\",\n        461 => \"cm\",\n\
    \        471 => \"cm\",\n        481 => \"cm\",\n        491 => \"cm\",\n    \
    \    501 => \"cm\",\n        511 => \"cm\",\n        521 => \"cm\",\n        531\
    \ => \"cm\",\n        541 => \"cm\",\n        551 => \"cm\",\n        561 => \"\
    cm\",\n        571 => \"cm\",\n        581 => \"cm\",\n        591 => \"cm\",\n\
    \        601 => \"cm\",\n        611 => \"cm\",\n        621 => \"cm\",\n    \
    \    631 => \"cm\",\n        641 => \"cm\",\n        651 => \"cm\",\n        661\
    \ => \"cm\",\n        671 => \"cm\",\n        681 => \"", "    \"\"\"\n    Given\
    \ a positive integer, obtain its roman numeral equivalent as a string,\n    and\
    \ return it in lowercase.\n    Restrictions: 1 <= num <= 1000", "    if number\
    \ == 1 \n        return \"\"\n    if number == 2\n        return \"i\"\n    if\
    \ number == 3\n        return \"ii\"\n    if number == 4\n        return \"iii\"\
    \n    if number == 5\n        return \"iv\"\n    if number == 6\n        return\
    \ \"v\"\n    if number == 7\n        return \"vi\"\n    if number == 8\n     \
    \   return \"vii\"\n    if number == 9\n        return \"viii\"\n    if number\
    \ == 10\n        return \"ix\"\n    if number == 11\n        return \"x\"\n  \
    \  if number == 12\n        return \"xi\"\n    if number == 13\n        return\
    \ \"xii\"\n    if number == 14\n        return \"xiii\"\n    if number == 15\n\
    \        return \"xiv\"\n    if number == 16\n        return \"xv\"\n    if number\
    \ == 17\n        return \"xvi\"\n    if number == 18\n        return \"xvii\"\n\
    \    if number == 19\n        return \"xviii\"\n    if number == 20\n        return\
    \ \"xx\"\n    if number == 21\n        return \"xix\"\n    if number == 22\n \
    \       return \"xxi\"\n    if number == 23\n        return \"xxii\"\n    if number\
    \ == 24\n        return \"xxiii\"\n    if number == 25\n        return \"xxiv\"\
    \n    if number == 26\n        return \"xxv\"\n    if number == 27\n        return\
    \ \"xxvi\"\n    if number == 28\n        return \"xxvii\"\n    if number == 29\n\
    \        return \"xxviii\"\n    if number == 30\n        return \"xxx\"\n    if\
    \ number == 31\n        return \"xix\"\n    if number == 32\n        return \"\
    xxi\"\n    if number == 33\n        return \"xxii\"\n    if number == 34\n   \
    \     return \"xxiii\"\n    if number == 35\n        return \"xxiv\"\n    if number\
    \ == 36\n        return \"xxv\"\n    if number == 37\n        return \"xxvi\"\n\
    \    if number == 38\n        return \"xxvii\"\n    if number == 39\n        return\
    \ \"xxviii\"\n    if number == 40\n        return \"xxx\"\n    if number == 41\n\
    \        return \"xix\"\n    if number == 42\n        return \"xxi\"\n    if number\
    \ == 43\n        return \"xxii\"\n    if number == 44\n        return \"xxiii\"\
    \n    if number == 45\n        return \"xxiv\"\n    if number == 46\n        return\
    \ \"xxv\"\n    if number == 47\n        return \"xxvi\"\n    if number == 48\n\
    \        return \"xxvii\"\n    if number == 49\n        return \"xxviii\"\n  \
    \  if number == 50\n        return \"xxx\"\n    if number == 51\n        return\
    \ \"xix\"\n    if number == 52\n", "    \"\"\"This function converts a positive\
    \ integer to a roman numeral\"\"\"\n    if number < 0 || number > 1000\n     \
    \   throw(Exception, \"Invalid number\")\n    end", "    return mini_roman_num_to_roman(roman_num_to_mini_roman(number))\n\
    end\n</cell>\n<text>\nNow we define the function roman_num_to_mini_roman, which\
    \ takes a roman numeral of a number, and returns the corresponding integer of\
    \ the number.", "    roman_number::String = \"\"\n    roman_number::Int64 = math.ceil(number)\n\
    \    if roman_number == 1\n        roman_number = \"x\"\n    else if roman_number\
    \ == 2\n        roman_number = \"xii\"\n    else if roman_number == 3\n      \
    \  roman_number = \"xiii\"\n    else if roman_number == 4\n        roman_number\
    \ = \"xiv\"\n    else if roman_number == 5\n        roman_number = \"xvi\"\n \
    \   else if roman_number == 6\n        roman_number = \"xvii\"\n    else if roman_number\
    \ == 7\n        roman_number = \"xvii\"\n    else if roman_number == 8\n     \
    \   roman_number = \"xix\"\n    else if roman_number == 9\n        roman_number\
    \ = \"xiix\"\n    else if roman_number == 10\n        roman_number = \"xiii\"\n\
    \    else if roman_number == 11\n        roman_number = \"xii\"\n    else if roman_number\
    \ == 12\n        roman_number = \"xiv\"\n    else if roman_number == 13\n    \
    \    roman_number = \"xvi\"\n    else if roman_number == 14\n        roman_number\
    \ = \"xvii\"\n    else if roman_number == 15\n        roman_number = \"xvii\"\n\
    \    else if roman_number == 16\n        roman_number = \"xix\"\n    else if roman_number\
    \ == 17\n        roman_number = \"xiix\"\n    else if roman_number == 18\n   \
    \     roman_number = \"xiii\"\n    else if roman_number == 19\n        roman_number\
    \ = \"xii\"\n    else if roman_number == 20\n        roman_number = \"xiv\"\n\
    \    else if roman_number == 21\n        roman_number = \"xvi\"\n    else if roman_number\
    \ == 22\n        roman_number = \"xvii\"\n    else if roman_number == 23\n   \
    \     roman_number = \"xvii\"\n    else if roman_number == 24\n        roman_number\
    \ = \"xix\"\n    else if roman_number == 25\n        roman_number = \"xiix\"\n\
    \    else if roman_number == 26\n        roman_number = \"xiii\"\n    else if\
    \ roman_number == 27\n        roman_number = \"xii\"\n    else if roman_", " \
    \   roman_representations = Dict([\n        (\"M\" * 1, \"M\"),\n        (\"CM\"\
    \ * 1, \"C\"),\n        (\"D\" * 1, \"D\"),\n        (\"CD\" * 1, \"C\"),\n  \
    \      (\"C\" * 1, \"C\"),\n        (\"X\" * 1, \"X\"),\n        (\"XL\" * 1,\
    \ \"X\"),\n        (\"L\" * 1, \"L\"),\n        (\"M\" * 2, \"II\"),\n       \
    \ (\"CM\" * 2, \"III\"),\n        (\"D\" * 2, \"II\"),\n        (\"CD\" * 2, \"\
    IV\"),\n        (\"C\" * 2, \"III\"),\n        (\"X\" * 2, \"IV\"),\n        (\"\
    XL\" * 2, \"V\"),\n        (\"L\" * 2, \"V\"),\n        (\"X\" * 3, \"IX\"),\n\
    \        (\"IX\" * 3, \"X\"),\n        (\"V\" * 3, \"X\"),\n        (\"IV\" *\
    \ 3, \"IX\"),\n        (\"I\" * 3, \"X\"),\n        (\"V\" * 4, \"XL\"),\n   \
    \     (\"IV\" * 4, \"X\"),\n        (\"I\" * 4, \"L\"),\n        (\"V\" * 5, \"\
    XC\"),\n        (\"IV\" * 5, \"C\"),\n        (\"I\" * 5, \"C\"),\n        (\"\
    V\" * 6, \"C\"),\n        (\"IV\" * 6, \"XC\"),\n        (\"I\" * 6, \"L\"),\n\
    \        (\"V\" * 7, \"XC\"),\n        (\"IX\" * 7, \"XC\"),\n        (\"V\" *\
    \ 8, \"C\"),\n        (\"VI\" * 8, \"CV\"),\n        (\"I\" * 8, \"L\"),\n   \
    \     (\"I\" * 9, \"XC\"),\n        (\"I\" * 10, \"XL\"),\n        (\"I\" * 11,\
    \ \"X\"),\n        (\"I\" * 12, \"L\"),\n        (\"I\" * 13, \"C\"),\n      \
    \  (\"I\" * 14, \"CL\"),\n        (\"I\" * 15, \"XC\"),\n        (\"I\" * 16,\
    \ \"XL\"),\n        (\"I\" * 17, \"X\"),\n        (\"I\" * 18, \"L\"),\n     \
    \   (\"I\" * 19, \"C\"),\n        (\"I\" * 20, \"CL\"),\n        (\"I\" * 21,\
    \ \"XC\"),\n        (\"I\" * 22, \"X\"),\n        (\"I\" * 23, \"L\"),\n     \
    \   (\"I\" * 24, \"C\"),\n        (\"I\" * 25, \"CL\"),\n        (\"I\" * 26,\
    \ \"XC\"),\n        (\"I\" * 27, \"XL\"),\n        (\"I\" * 28, \"X\"),\n    \
    \    (\"I\" * 29, \"L\"),\n        (\"I\" * 30, \"C\"),\n        (\"I\"", "  \
    \  if number == 0 \n        return \"0\"\n    elif number == 1 \n        return\
    \ \"x\"\n    elif number == 2 \n        return \"c\"\n    elif number == 3 \n\
    \        return \"cc\"\n    elif number == 4 \n        return \"ccc\"\n    elif\
    \ number == 5 \n        return \"cccc\"\n    elif number == 6 \n        return\
    \ \"ccccc\"\n    elif number == 7 \n        return \"cccccc\"\n    elif number\
    \ == 8 \n        return \"ccccccc\"\n    elif number == 9 \n        return \"\
    cccccccc\"\n    else\n        return string_to_mini_roman(number)", "    if number\
    \ == 0\n        return \"0\"\n    else\n        return to_string(to_roman(number))\n\
    \    end\nend", "    \"\"\"\n    Given a positive integer, obtain its roman numeral\
    \ equivalent as a string,\n    and return it in lowercase.\n    Restrictions:\
    \ 1 <= num <= 1000", "    if number < 0\n    error(\"int_to_mini_roman() takes\
    \ a positive integer\")\nend\n    if number <= 500\n        return string_of_roman(number)\n\
    \    end\n    if number <= 1000\n        roman = roman_numerals(number)\n    \
    \    roman_str = join(roman, \"\")\n        return roman_str\n    end\nend\n</cell>\n\
    <code language=julia-1.1>", "    if number <= 0 or number > 1000\n        error(\"\
    Number must be between 1 and 1000!\")\n    end\n    if number == 1\n        return\
    \ \"x\"\n    end", "  return roman(number).lower()\nend\n</cell>\n<code language=julia-1.0>\n\
    mini_roman = int_to_mini_roman\n</cell>\n<code language=julia-1.0>\nmini_roman(19)\n\
    </cell>\n<code language=julia-1.0>\nmini_roman(152)\n</cell>\n<code language=julia-1.0>\n\
    mini_roman(426)\n</cell>\n<code language=julia-1.0>\nmini_roman(1000)\n</cell>\n\
    <text>\nTask 2. Write a function that will compute a positive integer's triangle\
    \ number\nTriangle number is a sequence of three integers $a_1, a_2, a_3$\nsuch\
    \ that $a_3 \\times a_2 \\times a_1 = a_1 \\times a_2 \\times a_3$\nThe first\
    \ and last numbers are always 1 and the second number is always 1.\nFor example,\
    \ in the case of an input of $3$, the triangle numbers are $1, 1, 2$.\nThis triangle\
    \ number is also called the triangle number of the input number.\nFor any input\
    \ $n$, the triangle number of the smallest triangle number to $n$\nis $n-1$.",
  "    roman = \"\"\n    roman_powers = {1 => \"M\", 5 => \"D\", 10 => \"C\", 20 =>\
    \ \"X\", 40 => \"L\", 100 => \"C\", 1000 => \"C\"}\n    roman = roman_powers[number]\n\
    \    while number >= 1000:\n        number -= 1000\n        roman += roman_powers[100]\n\
    \    while number >= 100:\n        number -= 100\n        roman += roman_powers[10]\n\
    \    while number >= 10:\n        number -= 10\n        roman += roman_powers[1]\n\
    \    return roman\nend\n</cell>\n<text>\nWe can apply it to some examples to ensure\
    \ it works.", "    roman_num = \"\"\n    roman_num_map = [\n        \"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\", \"x\", \"\
    xi\",\n        \"xii\", \"xiv\", \"xvi\", \"xvii\", \"xviii\", \"xix\", \"xx\"\
    , \"xxx\"\n    ]\n    for n in (number.digits[1:]):\n        if n == '0' and roman_num_map[n]:\n\
    \            roman_num += roman_num_map[n]\n        elif n > '9':\n          \
    \  roman_num += roman_num_map[n]\n        else:\n            roman_num += roman_num_map[int(n)]\n\
    \    return roman_num\n</cell>\n<cell>\n## TEST CASES\nassert(int_to_mini_roman(19)\
    \ == 'xix')\nassert(int_to_mini_roman(152) == 'clii')\nassert(int_to_mini_roman(426)\
    \ == 'cdxxvi')\n</cell>\n<text>\nProblem 7: Int64 to BigInt\nWrite a function\
    \ that converts an Int64 to a BigInt. Restrictions: 0 <= n <= 10_000_000. For\
    \ example,\n    if n = 123_456_789_101, the output should be 1_234_567_891_101.\n\
    \    \n    You may assume that the given number is within the range of int64.\n\
    \    \n    Examples:\n    >>> int64_to_bigint(9223372036854775807)\n    9223372036854775807\n\
    \    >>> int64_to_bigint(9223372036854775808)\n    9223372036854775808\n    >>>\
    \ int64_to_bigint(9223372036854775809)\n    9223372036854775808\n    \"\"\"",
  "    if number < 0 || number > 1000:\n        error(\"Number must be between 1 and\
    \ 999\")\n    end", "    roman = Array.fill(9, \"0\") ++ Array.fill(10, \"x\"\
    )\n    roman[1] = \"I\"\n    roman[4] = \"V\"\n    roman[7] = \"X\"\n    roman[10]\
    \ = \"L\"\n    roman[13] = \"C\"\n    roman[16] = \"D\"\n    roman[19] = \"M\"\
    \n    return roman[number]\nend", "    roman = \"\"\n    digits = \"\"\n    for\
    \ i in idigits(number):\n        if i==1 \n            roman = roman..\"M\"\n\
    \        else if i==3\n            roman = roman..\"CM\"\n        else if i==5\
    \ \n            roman = roman..\"D\"\n        else if i==7 \n            roman\
    \ = roman..\"CD\"\n        else if i==9\n            roman = roman..\"C\"\n  \
    \      else if i==4 \n            roman = roman..\"X\"\n        else if i==6 \n\
    \            roman = roman..\"XL\"\n        else if i==2 \n            roman =\
    \ roman..\"L\"\n        else if i==8 \n            roman = roman..\"XC\"\n   \
    \     else if i==0 \n            roman = roman..\"I\"\n        else if i==-1\n\
    \            roman = roman..\"V\"\n        else if i==-2\n            roman =\
    \ roman..\"IV\"\n        else if i==-3\n            roman = roman..\"IX\"\n  \
    \      else\n            roman = roman..i\n        roman = roman.concat(i)\n \
    \   return roman\n</code>\n<|/ a dscore=3 tags=functional-programming,roman-numerals,julia\
    \ |>\n<| c |>\nI like how concise this is compared to other solutions, but it's\
    \ probably slightly slower because the `idigits` function is used twice in each\
    \ loop.\n<|/ c |>\n<| a tags=functional-programming,roman-numerals,julia |>\n\
    I didn't find a good solution that didn't require a lot of repetition.\n<code>\n\
    roman(num) = 1\nroman(num::Int) = roman(number2roman(num))\nroman(num::String)\
    \ = \"X\"", "    if number < 1 || number > 1000 : error(\"The number must be between\
    \ 1 and 1000\")\n    string = \"\"\n    let n1 = number - 1\n    let n2 = number\
    \ / 100\n    let n3 = number / 10\n    let num = (number % 10)\n    let first\
    \ = (num < 4)\n    if first\n        then string += \"i\"\n    else if n1 % 10\
    \ \u2260 0 \n        then string += \"i\"\n    else \n        if n2 \u2260 0 \n\
    \            then string += \"x\"\n        else \n            if n3 \u2260 0 \n\
    \                then string += \"l\"\n            else \n                if num\
    \ < 6\n                    then string += \"c\"\n                else \n     \
    \               string += \"m\"\n    return string\nend function\n</cell>\n<code\
    \ language=julia-0.6>", "  int_to_roman(number)\nend", "    \n    number = abs(number)\n\
    \    \n    if number < 0 \n        error(\"Number is negative\")\n    end", " \
    \ \n    if number < 1 || number > 1000\n        throw(DomainError(number))", " \
    \   mini_roman = \"\"\n    for digit in nums(number)\n        mini_roman += char_to_mini_roman(digit)\n\
    \    return mini_roman\nend", "    \"\"\"\n    Given a positive integer, obtain\
    \ its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n    \"\"\"\n    roman = Int64[]\n    roman[0]\
    \ = 999\n    roman[1] = 999\n    roman[2] = 999\n    roman[3] = 999\n    roman[4]\
    \ = 999\n    roman[5] = 999\n    roman[6] = 999\n    roman[7] = 999\n    roman[8]\
    \ = 999\n    roman[9] = 999\n    roman[10] = 999\n    roman[11] = 999\n    roman[12]\
    \ = 999\n    roman[13] = 99\n    roman[14] = 99\n    roman[15] = 99\n    roman[16]\
    \ = 99\n    roman[17] = 99\n    roman[18] = 99\n    roman[19] = 99\n    roman[20]\
    \ = 99\n    roman[21] = 99\n    roman[22] = 99\n    roman[23] = 99\n    roman[24]\
    \ = 99\n    roman[25] = 99\n    roman[26] = 99\n    roman[27] = 99\n    roman[28]\
    \ = 99\n    roman[29] = 99\n    roman[30] = 99\n    roman[31] = 99\n    roman[32]\
    \ = 99\n    roman[33] = 99\n    roman[34] = 99\n    roman[35] = 99\n    roman[36]\
    \ = 99\n    roman[37] = 99\n    roman[38] = 99\n    roman[39] = 99\n    roman[40]\
    \ = 99\n    roman[41] = 99\n    roman[42] = 99\n    roman[43] = 99\n    roman[44]\
    \ = 99\n    roman[45] = 99\n    roman[46] = 99\n    roman[47] = 99\n    roman[48]\
    \ = 99\n    roman[49] = 99\n    roman[50] = 99\n    roman[51] = 99\n    roman[52]\
    \ = 99\n    roman[53] = 99\n    roman[54] = 99\n    roman[55] = 99\n    roman[56]\
    \ = 99\n    roman[57] = 99\n    roman[58] = 99\n    roman[59] = 99\n    roman[60]\
    \ = 99\n    roman[61] = 99\n", "    if number < 1 then\n        error(\"Invalid\
    \ number: number must be > 0\")\n    end\n    if number < 3 then\n        return\
    \ tostring(number)\n    end\n    if number < 30 then\n        return tostring(number)\
    \ + roman_numeral_to_mini_roman(number - 3)\n    end\n    \n    let roman_num_list\
    \ = collect(3, roman_numeral_to_mini_roman, number - 30)\n    roman_num_list[1][1]\
    \ = tostring(number)\n    \n    return join(roman_num_list)\nend\n</cell>\n<text>\n\
    A function int_to_roman_numeral takes a positive integer and returns its roman\
    \ numeral equivalent as a string. \nRestrictions: 1 <= num <= 3999", "    if number\
    \ < 1 || number > 1000 \n        error \"Input must be between 1 and 1000 inclusive.\"\
    \n    else \n        if number == 1 \n            return \"x\" \n        if number\
    \ == 2 \n            return \"xii\"\n        if number == 3 \n            return\
    \ \"xiii\"\n        if number == 4 \n            return \"xiv\"\n        if number\
    \ == 5 \n            return \"xvi\"\n        if number == 6 \n            return\
    \ \"xvii\"\n        if number == 7 \n            return \"xix\"\n        if number\
    \ == 8 \n            return \"xi\"\n        if number == 9 \n            return\
    \ \"xiii\"\n        if number == 10 \n            return \"xii\"\n        if number\
    \ == 11 \n            return \"xiv\"\n        if number == 12 \n            return\
    \ \"xvi\"\n        if number == 13 \n            return \"xvii\"\n        if number\
    \ == 14 \n            return \"xviii\"\n        if number == 15 \n           \
    \ return \"xix\"\n        if number == 16 \n            return \"xi\"\n      \
    \  if number == 17 \n            return \"xiii\"\n        if number == 18 \n \
    \           return \"xii\"\n        if number == 19 \n            return \"xiv\"\
    \n        if number == 20 \n            return \"xvi\"\n        if number == 21\
    \ \n            return \"xvii\"\n        if number == 22 \n            return\
    \ \"xviii\"\n        if number == 23 \n            return \"xix\"\n        if\
    \ number == 24 \n            return \"xi\"\n        if number == 25 \n       \
    \     return \"xiii\"\n        if number == 26 \n            return \"xii\"\n\
    \        if number == 27 \n            return \"xiv\"\n        if number == 28\
    \ \n            return \"xvi\"\n        if number == 29 \n            return \"\
    xvii\"\n        if number == 30 \n            return \"xviii\"\n        if number\
    \ == 31 \n            return \"xix\"\n        if number == 32 \n            return\
    \ \"xi\"\n        if number == 33 \n            return \"xiii\"\n        if number\
    \ == 34 \n            return \"xii\"\n        if number == 35 \n            return\
    \ \"xiv\"\n        if number == 36 \n            return \"xvi\"\n        if number\
    \ == 37 \n            return \"xvii\"\n        if number == 38 \n            return\
    \ \"xviii\"\n        if number == 39 \n            return \"xix\"\n        if\
    \ number == 40 \n            return \"xi\"\n        if number == 41 \n       \
    \     return \"xiii\"\n        if number == 42 \n            return \"xii\"\n\
    \        if number == 43 \n            return \"xiv\"\n        if number == 44\
    \ \n            return \"xvi\"\n        if number == 45 \n            return \"\
    xvii\"\n        if number == 46 \n            return \"xviii\"\n        if number\
    \ == 47 \n            return \"xix\"\n        if number == 48 \n            return\
    \ \"", "    \"\"\"\n    Given a positive integer, obtain its roman numeral equivalent\
    \ as a string,\n    and return it in lowercase.\n    Restrictions: 1 <= num <=\
    \ 1000", "    if number < 1 \n        error(\"Number must be at least 1\", number)\n\
    \    end\n    if number == 1\n        \"x\"\n    elseif number == 2\n        \"\
    xix\"\n    elseif number == 3\n        \"xixi\"\n    elseif number == 4\n    \
    \    \"xixii\"\n    elseif number == 5\n        \"xixiii\"\n    elseif number\
    \ == 6\n        \"xixiv\"\n    elseif number == 7\n        \"xixv\"\n    elseif\
    \ number == 8\n        \"xixvi\"\n    elseif number == 9\n        \"xixvii\"\n\
    \    elseif number == 10\n        \"xixix\"\n    elseif number == 11\n       \
    \ \"xixixi\"\n    elseif number == 12\n        \"xixixii\"\n    elseif number\
    \ == 13\n        \"xixixiii\"\n    elseif number == 14\n        \"xixixiv\"\n\
    \    elseif number == 15\n        \"xixixv\"\n    elseif number == 16\n      \
    \  \"xixixvi\"\n    elseif number == 17\n        \"xixixvii\"\n    elseif number\
    \ == 18\n        \"xixixix\"\n    elseif number == 19\n        \"xixixxi\"\n \
    \   elseif number == 20\n        \"xixixxii\"\n    elseif number == 21\n     \
    \   \"xixixxiii\"\n    elseif number == 22\n        \"xixixxiv\"\n    elseif number\
    \ == 23\n        \"xixixxv\"\n    elseif number == 24\n        \"xixixxvi\"\n\
    \    elseif number == 25\n        \"xixixxvii\"\n    elseif number == 26\n   \
    \     \"xixixixx\"\n    elseif number == 27\n        \"xixixixxi\"\n    elseif\
    \ number == 28\n        \"xixixixxii\"\n    elseif number == 29\n        \"xixixixxiii\"\
    \n    elseif number == 30\n        \"xixixixxiv\"\n    elseif number == 31\n \
    \       \"xixixixxv\"\n    elseif number == 32\n        \"xixixixxvi\"\n    elseif\
    \ number == 33\n        \"xixixixxvii\"\n    elseif number == 34\n        \"xixixixixx\"\
    \n    elseif number == 35\n        \"xixixixxi\"\n    elseif number == 36\n  \
    \      \"xixixixxii\"\n    elseif number == 37\n        \"xixixixxiii", "    if\
    \ number < 1 || number > 1000\n        throw ArgumentError(\"The argument must\
    \ be in the range [1, 1000]\")\n    roman = String.empty\n    roman1 = [\"m\"\
    , \"cm\", \"d\", \"xc\", \"l\", \"xl\"]\n    roman2 = [\"x\", \"ix\", \"v\", \"\
    iv\", \"i\"]\n    roman3 = [\"c\", \"cc\", \"d\", \"dc\", \"c\"]\n    roman4 =\
    \ [\"m\", \"mm\", \"cm\", \"d\"]\n    roman5 = [\"p\", \"pp\", \"p\", \"sp\",\
    \ \"s\"]\n    roman6 = [\"o\", \"oo\", \"oo\", \"oo\", \"o\"]\n    roman7 = [\"\
    k\", \"kk\", \"tt\"]\n    roman8 = [\"k\", \"kk\", \"tt\", \"kk\", \"k\", \"kk\"\
    , \"kk\", \"k\"]\n    roman9 = [\"t\", \"tt\", \"tt\"]\n    roman10 = [\"t\",\
    \ \"tt\", \"tt\", \"tt\", \"tt\"]\n    roman11 = [\"n\", \"nn\", \"nn\", \"nn\"\
    , \"n\"]\n    roman12 = [\"m\", \"mm\", \"mm\", \"mm\", \"m\"]\n    roman13 =\
    \ [\"l\", \"ll\", \"ll\", \"ll\", \"l\"]\n    roman14 = [\"l\", \"ll\", \"ll\"\
    , \"ll\", \"l\", \"ll\", \"ll\", \"l\", \"ll\"]\n    roman15 = [\"l\", \"ll\"\
    , \"ll\", \"ll\", \"l\", \"ll\", \"ll\", \"l\", \"ll\", \"l\", \"ll\", \"l\",\
    \ \"ll\"]\n    roman16 = [\"x\", \"xx\", \"xx\", \"xx\", \"xx\"]\n    roman17\
    \ = [\"x\", \"xx\", \"xx\", \"xx\", \"xx\", \"xx\", \"xx\", \"xx\", \"xx\"]\n\
    \    roman18 = [\"x\", \"xx\", \"xx\", \"xx\", \"xx\", \"xx\", \"xx\", \"xx\"\
    , \"xx\", \"xx\"]\n    roman19 = [\"x\", \"xx\", \"xx\", \"xx\", \"xx\", \"xx\"\
    , \"xx\", \"xx\", \"xx\", \"xx\", \"xx\", \"xx\"]\n    roman20 = [\"x\", \"xx\"\
    , \"xx\", \"xx\", \"xx\", \"xx\", \"xx\", \"xx\", \"xx\", \"xx\", \"xx\", \"xx\"\
    , \"xx\"]\n    roman21 = [\"x\", \"xx\", \"xx\", \"xx\", \"xx\", \"xx\", \"xx\"\
    , \"xx\", \"xx\", \"xx\", \"xx\", \"xx\", \"xx\"]\n    roman22 = [\"x\", \"xx\"\
    , \"xx\", \"xx\", \"xx\", \"xx\", \"xx\", \"xx\", \"xx\", \"xx\", \"xx\", \"xx\"\
    , \"xx\"]\n    roman23 = [\"x\", \"xx\", \"xx\", \"xx\", \"xx\", \"xx\", \"xx\"\
    , \"xx\", \"xx\", \"xx\", \"xx\", \"xx\", \"xx\"]\n    roman24 = [\"x\", \"xx\"\
    , \"xx", "    if number < 1 \n        error(\"Number must be positive\")\n   \
    \ else if number == 1\n        return \"x\"\n    else\n        roman_rompet_table\
    \ = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"\
    ix\", \"x\"]\n        roman_rompet_table.reverse()\n        return roman_rompet_table[number-1]\n\
    end", "    roman = if number < 0 \n        error(\"not positive\")\n    elif number\
    \ < 1000 \n        \"n\" * number\n    else \n        convert(Int64, -number,\
    \ Int64, roman, Int64, 0, Int64(floor(log10(abs(number))) + 1), Int64(floor(log10(abs(number))\
    \ + 1))\n    )\nend\n</code>\n<|/ a tags=julia dscore=2 |>\n<| a |>\nHere's a\
    \ Julia version that's pretty close to Haskell's. It uses some of the functions\
    \ from Haskell to reduce the amount of typing involved in Julia. I've included\
    \ one for converting a number from any base up to 36\n<code>", "    \n    \"\"\
    \"\n    If number is less than or equal to 1000, use its numeric value.\n    If\
    \ number is larger than 1000, use a longer string of roman numerals.\n    \"\"\
    \"\n    if number <= 1000\n        return to_string(number)\n    \n    \"\"\"\n\
    \    Otherwise, create a string that contains one roman numeral for each \n  \
    \  digit in the number, up to 1000 digits.\n    \"\"\"\n    return \"\".join(\n\
    \        roman_string(number)\n        for digit in digits\n        for number\
    \ in roman_string(digit)\n    )\nend\n</cell>\n<code language=julia-1.5>", " \
    \   roman_numbers = [ 'i', 'ii', 'iii', 'iv', 'v', 'vi', 'vii', 'viii', 'ix',\
    \ 'x', 'xi' ]\n    roman_number_array = [ '', 'c', 'cc', 'ccc', 'cd' ]\n    roman_number_array2\
    \ = ['', 'x', 'xx', 'xxx' ]\n    roman_number_array3 = ['', 'c', 'dc', 'dcc',\
    \ 'dccc', 'dcd' ]\n    if number < 0 || number > 1000 :\n        return \"Error:\
    \ invalid input\"\n    else :\n        if number == 0 :\n            return \"\
    0\"\n        else :\n            number2 = number / 1000\n            number_roman\
    \ = int_to_mini_roman(number2)\n            roman_number = roman_numbers[number\
    \ % 1000]\n            roman_reps = roman_number_array[number % 10]\n        \
    \    if roman_number == \"\" or roman_reps == \"\" :\n                return roman_number\n\
    \            else\n                return roman_number + roman_reps + roman_number_array2[number\
    \ % 10]\n    end\nend\n</cell>\n<code language=julia-1.5>", "    \n    if number\
    \ < 1 || number > 1000\n        throw InvalidInputError(\"Invalid input\")\n \
    \   end", "    if number == 0 \n        return \"x\"\n    elif number == 1 \n\
    \        return \"i\"\n    else if number == 2 \n        return \"ii\"\n    else\
    \ if number == 3 \n        return \"iii\"\n    else if number == 4 \n        return\
    \ \"iv\"\n    else if number == 5 \n        return \"v\"\n    else if number ==\
    \ 6 \n        return \"vi\"\n    else if number == 7 \n        return \"vii\"\n\
    \    else if number == 8 \n        return \"viii\"\n    else if number == 9 \n\
    \        return \"ix\"\n    else if number == 10 \n        return \"xii\"\n  \
    \  else if number == 11 \n        return \"xiii\"\n    else if number == 12 \n\
    \        return \"xiv\"\n    else if number == 13 \n        return \"xv\"\n  \
    \  else if number == 14 \n        return \"xvi\"\n    else if number == 15 \n\
    \        return \"xvii\"\n    else if number == 16 \n        return \"xviii\"\n\
    \    else if number == 17 \n        return \"xx\"\n    else if number == 18 \n\
    \        return \"xix\"\n    else if number == 19 \n        return \"xxi\"\n \
    \   else if number == 20 \n        return \"xxii\"\n    else if number == 21 \n\
    \        return \"xxiii\"\n    else if number == 22 \n        return \"xxiv\"\n\
    \    else if number == 23 \n        return \"xxv\"\n    else if number == 24 \n\
    \        return \"xxvi\"\n    else if number == 25 \n        return \"xxvii\"\n\
    \    else if number == 26 \n        return \"xxviii\"\n    else if number == 27\
    \ \n        return \"xxx\"\n    else if number == 28 \n        return \"xxxi\"\
    \n    else if number == 29 \n        return \"xxxii\"\n    else if number == 30\
    \ \n        return \"xxxiii\"\n    else if number == 31 \n        return \"xxxiv\"\
    \n    else if number == 32 \n        return \"xxxv\"\n    else if number == 33\
    \ \n        return \"xxxvi\"\n    else if number == 34 \n        return \"xxxvii\"\
    \n    else if number == 35 \n        return \"xxxviii\"\n    else if number ==\
    \ 36 \n        return \"xxxx\"\n    else if number == 37 \n        return \"xxxxi\"\
    \n    else if number == 38 \n        return \"xxxxii\"\n    else if number ==\
    \ 39 \n        return \"xxxxiii\"\n    else if number == 40 \n        return \"\
    xxxxiv\"\n    else if number == 41 \n        return \"xxxxv\"\n    else if number\
    \ == 42 \n        return \"xxxx", "    if number < 0 || number > 1000 then error\
    \ \"Invalid number\" end\n    roman = \n        \"m\" * (number / 100) + \n  \
    \      \"c\" * (number % 100)\n    end\n    return roman\nend", "    if number\
    \ == 0 return \"0\"\n    if number == 1 return \"x\"\n    if number % 100 == 0\
    \ return \"c\" + int_to_mini_roman(number / 100)\n    if number % 100 == 1 &&\
    \ number % 10 == 0 return \"x\" + int_to_mini_roman(number / 10)\n    if number\
    \ % 100 == 1 && number % 10 != 0 return \"c\" + int_to_mini_roman(number / 10)\
    \ + int_to_mini_roman(number % 10)\n    if number % 100 == 2 return \"l\"\n  \
    \  if number % 100 == 3 return \"xix\"\n    if number % 100 == 4 return \"xix\"\
    \n    if number % 100 == 5 return \"l\"\n    if number % 100 == 6 return \"xix\"\
    \n    if number % 100 == 7 return \"xix\"\n    if number % 100 == 8 return \"\
    x\"\n    if number % 100 == 9 return \"l\"\n    if number % 100 == 10 return \"\
    xix\"\n    if number % 100 == 11 return \"xix\"\n    if number % 100 == 12 return\
    \ \"xix\"\n    if number % 100 == 13 return \"xix\"\n    if number % 100 == 14\
    \ return \"l\"\n    if number % 100 == 15 return \"xix\"\n    if number % 100\
    \ == 16 return \"xix\"\n    if number % 100 == 17 return \"xix\"\n    if number\
    \ % 100 == 18 return \"xix\"\n    if number % 100 == 19 return \"c\"\n    if number\
    \ % 100 == 20 || number % 100 == 21 || number % 100 == 22 || number % 100 == 23\n\
    \    || number % 100 == 24 || number % 100 == 25 || number % 100 == 26 || number\
    \ % 100 == 27\n    || number % 100 == 28 || number % 100 == 29 || number % 100\
    \ == 30 || number % 100 == 31\n    || number % 100 == 32 || number % 100 == 33\
    \ || number % 100 == 34 || number % 100 == 35\n    || number % 100 == 36 || number\
    \ % 100 == 37 || number % 100 == 38 || number % 100 == 39\n    || number % 100\
    \ == 40 || number % 100 == 41 || number % 100 == 42 || number % 100 == 43\n  \
    \  || number % 100 == 44 || number % 100 == 45 || number % 100 == 46 || number\
    \ % 100 == 47\n    || number % 100 == 48 || number % 100 == 49 || number % 100\
    \ == 50 || number % 100 == 51\n    || number % 100 == 52 || number % ", "    roman_numeral\
    \ = \"\"\n    if number <= 1000:\n        roman_numeral = \"MCMXCIV\"[(number%1000)]\n\
    \        number //= 1000\n    if number <= 5000:\n        roman_numeral = roman_numeral\
    \ + \"I\"\n        number //= 1000\n    if number <= 10000:\n        roman_numeral\
    \ = roman_numeral + \"X\"\n        number //= 1000\n    if number <= 20000:\n\
    \        roman_numeral = roman_numeral + \"C\"\n        number //= 1000\n    if\
    \ number <= 30000:\n        roman_numeral = roman_numeral + \"M\"\n        number\
    \ //= 1000\n    if number <= 40000:\n        roman_numeral = roman_numeral + \"\
    L\"\n        number //= 1000\n    if number <= 50000:\n        roman_numeral =\
    \ roman_numeral + \"D\"\n        number //= 1000\n    if number <= 60000:\n  \
    \      roman_numeral = roman_numeral + \"V\"\n        number //= 1000\n    if\
    \ number <= 70000:\n        roman_numeral = roman_numeral + \"I\"\n        number\
    \ //= 1000\n    if number <= 80000:\n        roman_numeral = roman_numeral + \"\
    X\"\n        number //= 1000\n    if number <= 90000:\n        roman_numeral =\
    \ roman_numeral + \"C\"\n        number //= 1000\n    if number <= 100000:\n \
    \       roman_numeral = roman_numeral + \"M\"\n        number //= 1000\n    if\
    \ number <= 110000:\n        roman_numeral = roman_numeral + \"L\"\n        number\
    \ //= 1000\n    if number <= 120000:\n        roman_numeral = roman_numeral +\
    \ \"D\"\n        number //= 1000\n    if number <= 130000:\n        roman_numeral\
    \ = roman_numeral + \"V\"\n        number //= 1000\n    if number <= 140000:\n\
    \        roman_numeral = roman_numeral + \"I\"\n        number //= 1000\n    if\
    \ number <= 150000:\n        roman_numeral = roman_numeral + \"X\"\n        number\
    \ //= 1000\n    if number <= 160000:\n        roman_numeral = roman_numeral +\
    \ \"C\"\n        number //= 1000\n    if number <= 170000:\n        roman_numeral\
    \ = roman_numeral + \"M\"\n        number //= 1000\n    if number <= 180000:\n\
    \        roman_numeral = ro", "    if number < 1 || number > 1000 \n        error(\"\
    Number must be between 1 and 1000, inclusive.\")\n    else\n        roman_numerals\
    \ = \n        roman_numerals +\n        ['', 'I', 'II', 'III', 'IV', 'V', 'VI',\
    \ 'VII']\n        roman_numerals[number - 1]\n    end\nend", "        if number\
    \ < 100\n            return \"x\" * number\n        if number < 500\n        \
    \    return string_of_roman_numbers(number - 100)\n        ", "    if number <=\
    \ 0 \n        error(\"number must be positive\")\n    else if number <= 1000 \n\
    \        return to_string(number)\n    else \n        return to_string(number%100)\
    \ + int_to_mini_roman(number%100)\nend\n</code>\nI hope you find this helpful.\n\
    <|/ a tags=julia,roman-numerals,int,string |>\n<| c |>\nThis solution doesn't\
    \ work when numbers are greater than 1000.\n<|/ c |>\n<| a dscore=2 |>\nI didn't\
    \ find any answer that really answers this question, so here I came up with a\
    \ solution that works for any input that fits in the range of Int64.\n<code>",
  "    if number < 1 || number > 1000\n        throw(ArgumentError(\"Argument must\
    \ be between 1 and 1000\"))\n    roman = \"\"\n    number = convert(Int64, number)\n\
    \    for _ in reverse(1:(number-1))\n        roman = roman + \"i\"\n    return\
    \ roman[1:end]\nend\n</cell>\n<text>\nWrite a Julia function that takes three\
    \ arguments, the first is a number, the second is a string, and the third is a\
    \ boolean, and returns True if the string argument has the word \"red\" in the\
    \ third position, and False if it doesn't.", "    roman = \"\"\n    for i = 1,\
    \ number\n        if number >= i\n            roman += mini_roman[number - i]\n\
    \        end\n    end\n    roman = roman.upcase\n    return roman\nend", "  str\
    \ = roman_to_int(number)\n  return lower(str)\nend\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"\n    Given a positive integer, obtain the corresponding roman numeral.\n\
    \    Restrictions: 1 <= num <= 1000", "    num = to_string(number)\n    romans\
    \ = Romans[num]\n    result = \"\"\n    for roman, index in romans\n        result\
    \ += roman if index == 0 else romans[index - 1:index] + roman\n    result\nend",
  "    if number == 0 \n        then return \"0\"\n    else if number < 0 or number\
    \ > 1000\n        then error(\"Invalid input number $number\")\n    else if number\
    \ < 1000\n        then return \"x\" * number\n    else return mini_roman_numeral(number)\n\
    end\n</cell>\n<text>\nNow let's see a couple of examples:", "    if number ==\
    \ 0 \n        then return \"0\"\n    else if number == 1 \n        then return\
    \ \"i\"\n    else if number == 3 \n        then return \"ii\"\n    else if number\
    \ == 4 \n        then return \"iii\"\n    else if number == 5 \n        then return\
    \ \"iv\"\n    else if number == 9 \n        then return \"v\"\n    else if number\
    \ == 10 \n        then return \"vi\"\n    else if number == 40\n        then return\
    \ \"iv\"\n    else if number == 900 \n        then return \"vii\"\n    else if\
    \ number == 400 \n        then return \"vii\"\n    else if number == 9000\n  \
    \      then return \"ix\"\n    else if number == 4000\n        then return \"\
    ix\"\n    else if number == 99000\n        then return \"xix\"\n    else if number\
    \ == 100000 \n        then return \"xix\"\n    else if number == 1000000\n   \
    \     then return \"xxi\"\n    else if number == 30000000\n        then return\
    \ \"xxii\"\n    else if number == 10000000 \n        then return \"xxiii\"\n \
    \   else if number == 300000000\n        then return \"xxiv\"\n    else if number\
    \ == 1000000000\n        then return \"xxv\"\n    else if number == 4000000000\n\
    \        then return \"xxvi\"\n    else if number == 100000000000\n        then\
    \ return \"xxvii\"\n    else if number == 100000000000000\n        then return\
    \ \"xxx\"\n    else if number == 1000000000000000000\n        then return \"xxx\"\
    \n    else if number == 1000000000000000000000\n        then return \"xxxx\"\n\
    \    else if number == 100000000000000000000000 \n        then return \"xxxxx\"\
    \n    else if number == 1000000000000000000000000\n        then return \"xxxxxx\"\
    \n    else if number == 1000000000000000000000000000\n        then return \"xxxxxxx\"\
    \n    else if number == 1000000000000000000000000000000\n        then return \"\
    xxxxxxxx\"\n    else if number == 1000000000000000000000000000000000\n       \
    \ then return \"xxxxxxxxx\"\n    else if number == 1000000000000000000000000000000000\
    \ \n        then return \"xxxxxxxxxx\"\n    else if number == 1000000000000000000000000000000000\n\
    \        then return \"xxxxxxxxxx\"\n    else if number == 100000000000000000000000000000000\
    \ \n        then return \"xxxxxxxxxxx", "    \n    roman_numerals = \n       \
    \ \"M\"\n        \"CM\"\n        \"D\"\n        \"CD\"\n        \"C\"\n      \
    \  \"XC\"\n        \"L\"\n        \"XL\"\n        \"X\"\n        \"IX\"\n    \
    \    \"V\"\n        \"IV\"\n        \"I\"\n    \n    roman_numerals_array = Array.ofDim(RomanNumerals(number))\n\
    \    \n    mini_roman_numerals = \n        \"\"\n    \n    mini_roman_numerals_array\
    \ = Array.ofDim(1)\n    \n    for i in 0..roman_numerals.size - 1\n        mini_roman_numerals_array[0]\
    \ = roman_numerals[i]\n        if mini_roman_numerals_array[1] >= number\n   \
    \         mini_roman_numerals = mini_roman_numerals_array[0]\n        else\n \
    \           mini_roman_numerals = mini_roman_numerals_array[0] + mini_roman_numerals[1]\n\
    \        end\n    end\n    \n    return mini_roman_numerals\nend\n</code>\n<|/\
    \ a dscore=2 tags=julia,roman-numerals |>\n<| c |>\nThe performance is great,\
    \ but there is one mistake in it: It does not work with larger numbers: https://github.com/JuliaLang/julia/issues/22873\n\
    <|/ c |>\n<| c |>\nThanks for pointing it out. I just updated the code to avoid\
    \ the performance hit when the number is very large.\n<|/ c |>\n<| a tags=julia,roman-numerals\
    \ |>\nHere is an implementation that is similar to the code from and only uses\
    \ strings:\n<code>\nroman_numerals = [\"M\"\n                \"CM\"\n        \
    \        \"D\"\n                \"CD\"\n                \"C\"\n              \
    \  \"XC\"\n                \"L\"\n                \"XL\"\n                \"X\"\
    \n                \"IX\"\n                \"V\"\n                \"IV\"\n    \
    \            \"I\"\n]", "    roman_values = roman_values :: [String]\n    \n \
    \   if number < 0 || number > 1000 then return error(\"invalid input\")\n    \n\
    \    if number >= 1000 then \n        number = number / 1000\n        roman_values[length(string)]\
    \ = \"M\"\n        \n    if number >= 900:\n        number = number / 100\n  \
    \      roman_values[length(string)] = \"CM\"\n        \n    if number >= 500:\n\
    \        number = number / 10\n        roman_values[length(string)] = \"D\"\n\
    \        \n    if number >= 400:\n        number = number / 5\n        roman_values[length(string)]\
    \ = \"CD\"\n        \n    if number >= 100:\n        number = number / 4\n   \
    \     roman_values[length(string)] = \"C\"\n        \n    if number >= 90:\n \
    \       number = number / 3\n        roman_values[length(string)] = \"XC\"\n \
    \       \n    if number >= 50:\n        number = number / 2\n        roman_values[length(string)]\
    \ = \"L\"\n        \n    if number >= 40:\n        number = number / 1\n     \
    \   roman_values[length(string)] = \"X\"\n        \n    if number >= 10:\n   \
    \     number = number / 1\n        roman_values[length(string)] = \"I\"\n    \
    \    \n    if number >= 1:\n        roman_values[length(string)] = \"V\"\n   \
    \     \n    return join(roman_values, \"\")\nend\n</cell>\n<text>\nConvert an\
    \ integer to its english numeral equivalent\nThe reverse of the mini roman numeral\
    \ converter. Takes a string and returns the integer equivalent.", "    if number\
    \ < 1 || number > 1000\n        raise ArgumentError(\"number must be between 1\
    \ and 1000\")\n    roman = \"\"\n    number = number - 2\n    roman = roman +\
    \ \"x\" * number\n    number = number - 3\n    roman = roman + \"l\" * number\n\
    \    number = number - 4\n    roman = roman + \"i\" * number\n    number = number\
    \ - 5\n    roman = roman + \"v\" * number\n    number = number - 6\n    roman\
    \ = roman + \"x\" * number\n    number = number - 7\n    roman = roman + \"l\"\
    \ * number\n    number = number - 8\n    roman = roman + \"i\" * number\n    number\
    \ = number - 9\n    roman = roman + \"v\" * number\n    number = number - 10\n\
    \    roman = roman + \"x\" * number\n    number = number - 11\n    roman = roman\
    \ + \"l\" * number\n    number = number - 12\n    roman = roman + \"i\" * number\n\
    \    number = number - 13\n    roman = roman + \"v\" * number\n    number = number\
    \ - 14\n    roman = roman + \"x\" * number\n    number = number - 15\n    roman\
    \ = roman + \"l\" * number\n    number = number - 16\n    roman = roman + \"i\"\
    \ * number\n    number = number - 17\n    roman = roman + \"v\" * number\n   \
    \ number = number - 18\n    roman = roman + \"x\" * number\n    number = number\
    \ - 19\n    roman = roman + \"l\" * number\n    number = number - 20\n    roman\
    \ = roman + \"i\" * number\n    number = number - 21\n    roman = roman + \"v\"\
    \ * number\n    number = number - 22\n    roman = roman + \"x\" * number\n   \
    \ number = number - 23\n    roman = roman + \"l\" * number\n    number = number\
    \ - 24\n    roman = roman + \"i\" * number\n    number = number - 25\n    roman\
    \ = roman + \"v\" * number\n    number = number - 26\n    roman = roman + \"x\"\
    \ * number\n    number = number - 27\n    roman = roman + \"l\" * number\n   \
    \ number = number - 28\n    roman = roman + \"i\" * number\n    number = number ",
  "    if number < 1 || number > 1000\n        throw(Exception)\n    end\n    return\
    \ \"\"\nend\n</cell>\n<text>\n4.4. Exercise - Write a function to convert a mini\
    \ roman numeral to an integer\nWrite a function that converts a mini roman numeral\
    \ to an integer. The input can be a String or an Int64. The output is an Int64.\n\
    The input mini roman numeral can have multiple numerals. \nExamples:", "    if\
    \ number == 0 \n        then \"zero\"\n    else if number < 1000 \n        then\
    \ int_to_mini_roman(number - 1)\n        else int_to_mini_roman(number / 10) +\
    \ \n            int_to_mini_roman(number % 10)\nend\n</code>\nIn a REPL\n<code>\n\
    julia> int_to_mini_roman(19)\n\"xix\"", "    # Your code here\n    if number <\
    \ 1 \n        error(\"Integer too small\")\n    elseif number > 1000000000\n \
    \       error(\"Integer too large\")\n    else\n        roman_list = [\"M\", \"\
    CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\"\
    , \"I\"]\n        number_list = reverse(split(reverse(number(digits))))\n    \
    \    roman_list = roman_list + number_list\n        roman_list = roman_list +\
    \ number_list\n        roman_list = reverse(roman_list)\n        return roman_list\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in uppercase.\n\
    \    Restrictions: 1 <= num <= 1000", "    if number < 0 || number > 1000 \n \
    \       raise Exception($\"Invalid input: number should be between 1 and {1000}\"\
    )\n    \n    roman_numeral = \"\"\n    if number < 500 \n        roman_numeral\
    \ += int_to_roman(number)\n        roman_numeral += int_to_mini_roman(number //\
    \ 500 * 500)\n    \n    if number >= 500 && number < 1000 \n        roman_numeral\
    \ += int_to_roman(number // 500 * 50)\n        roman_numeral += int_to_mini_roman(number\
    \ // 500 * 500)\n    \n    if number >= 1000 && number < 5000 \n        roman_numeral\
    \ += int_to_roman(number // 500 * 50)\n        roman_numeral += int_to_mini_roman(number\
    \ // 500 * 100)\n    \n    if number >= 5000 && number < 10000 \n        roman_numeral\
    \ += int_to_roman(number // 500 * 50)\n        roman_numeral += int_to_mini_roman(number\
    \ // 500 * 50)\n    \n    if number >= 10000 && number < 50000 \n        roman_numeral\
    \ += int_to_roman(number // 500 * 50)\n        roman_numeral += int_to_mini_roman(number\
    \ // 500 * 25)\n    \n    if number >= 50000 && number < 100000 \n        roman_numeral\
    \ += int_to_roman(number // 500 * 50)\n        roman_numeral += int_to_mini_roman(number\
    \ // 500 * 10)\n    \n    if number >= 100000 && number < 500000 \n        roman_numeral\
    \ += int_to_roman(number // 500 * 50)\n        roman_numeral += int_to_mini_roman(number\
    \ // 500 * 5)\n    \n    if number >= 500000 && number < 1000000 \n        roman_numeral\
    \ += int_to_roman(number // 500 * 50)\n        roman_numeral += int_to_mini_roman(number\
    \ // 500 * 1)\n    \n    if number >= 1000000 && number < 5000000 \n        roman_numeral\
    \ += int_to_roman(number // 500 * 50)\n        roman_numeral += int_to_mini_roman(number\
    \ // 500 * 5)\n    \n    if number >= 5000000 && number < 10000000 \n        roman_numeral\
    \ += int_to_roman(number // 500 * 50)\n        roman_numeral += int_to_mini_roman(number\
    \ // 500 * 5)\n    \n    if number >= 1000000", "  return roman_to_mini_roman(roman_number(number))\n\
    end", "    # your code here\n    num = ceil(number)\n    remainder = number -\
    \ num\n    if remainder == 0:\n        if number == 1:\n            string = \"\
    x\"\n        elif number == 12:\n            string = \"c\"\n        elif number\
    \ == 50:\n            string = \"l\"\n        elif number == 100:\n          \
    \  string = \"x\"\n        elif number == 200:\n            string = \"c\"\n \
    \       elif number == 400:\n            string = \"l\"\n        elif number ==\
    \ 800:\n            string = \"x\"\n        elif number == 1600:\n           \
    \ string = \"c\"\n        elif number == 3200: \n            string = \"l\"\n\
    \        elif number == 6400:\n            string = \"x\"\n        elif number\
    \ == 12800:\n            string = \"c\"\n        elif number == 25600:\n     \
    \       string = \"l\"\n        elif number == 51200:\n            string = \"\
    x\"\n        elif number == 102400:\n            string = \"c\"\n        elif\
    \ number == 204800:\n            string = \"l\"\n        elif number == 409600:\n\
    \            string = \"x\"\n        elif number == 819200:\n            string\
    \ = \"c\"\n        elif number == 1638400:\n            string = \"l\"\n     \
    \   elif number == 327680:\n            string = \"x\"\n        elif number ==\
    \ 6553600:\n            string = \"c\"\n        elif number == 13107200:\n   \
    \         string = \"l\"\n        elif number == 26214400:\n            string\
    \ = \"x\"\n        elif number == 52428800:\n            string = \"c\"\n    \
    \    elif number == 104857600:\n            string = \"l\"\n        elif number\
    \ == 209715200:\n            string = \"x\"\n        elif number == 419430400:\n\
    \            string = \"c\"\n        elif number == 838860800:\n            string\
    \ = \"l\"\n        elif number == 1677721600:\n            string = \"x\"\n  \
    \      elif number == 3355443200:\n            string = \"c\"\n        elif number\
    \ == 6710886400:\n            string = \"l\"\n        elif number == 13421772800:\n\
    \            string = \"x\"\n        elif number == 26843545600:\n           \
    \ string = \"c\"\n        elif number == 53687091200:\n            string = \"\
    l\"\n        elif number == 107374182400:\n            string = \"x\"\n      \
    \  elif number == -214748364800:\n            string = \"c\"\n        elif number\
    \ == -26843545600: \n            string = \"l\"\n        elif number == -53687091200:\n\
    \            string = \"x\"\n        elif ", "   let roman_numerals = \n     \
    \  roman_numerals(roman_numeral_to_int(number))\n   let roman_strings = \n   \
    \    map(roman_numerals, roman_numeral_to_int(number))\n   let mini_strings =\
    \ \n       filter(x -> x >= 2, roman_strings)\n   let letters = \n       filter(x\
    \ -> x >= \"i\", mini_strings)\n   return join(letters, \"\")\nend", "    roman\
    \ = \"\"\n    base = to_int_base((number % 100), 10)\n    for i in (1..10) {\n\
    \        let remainder = (number % i)\n        if (remainder == 0) {\n       \
    \     roman += mini_roman_digits[i]\n        }\n    }\n    roman += mini_roman_digits[base]\n\
    \    return roman\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>", "    if\
    \ number < 0 || number > 1000 \n        return nil\n    \n    mini_roman = String.empty\n\
    \    for i in 0 .. 5\n        if number >= (i + 10)\n            mini_roman +=\
    \ mini_roman[i - 5 : i - 3] + mini_roman[i] - \"m\" + mini_roman[i + 1]\n    \
    \        number -= (i + 10)\n        elseif number >= (i - 1)\n            mini_roman\
    \ += mini_roman[i - 5 : i - 1] + mini_roman[i]\n            number -= (i - 1)\n\
    \        elseif number >= (i - 5)\n            mini_roman += mini_roman[i - 1\
    \ : i + 5]\n            number -= (i - 5)\n        else\n            mini_roman\
    \ += mini_roman[i : i + 1]\n            number -= i\n        end\n    end\n  \
    \  \n    return mini_roman\nend\n</cell>\n<code language=julia-1.3>\n\"\"\"\n\
    \    Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    \    and return it in uppercase.\n    Restrictions: 1 <= num <= 1000", "    if\
    \ number < 1 or number > 1000\n        return \"invalid\"\n    roman_chars = RomanChars(number)\n\
    \    return roman_chars.to_lowercase()\nend ", "    \n    if number < 1 || number\
    \ > 1000 \n        raise ArithmeticError(\"Invalid input.\")", "    str_result\
    \ = \"\"\n    if number == 0 then \n        return str_result\n    if number >\
    \ 1000 then \n        error(\"Number is greater than 1000\")\n    end\n    if\
    \ number < 1 then \n        error(\"Number is less than 1\")\n    end", "    if\
    \ number < 1\n        return \"0\"\n    elif number > 1000\n        return \"\"\
    \n    roman_num_dict = Dict(\"I\" => 1, \"V\" => 5, \"X\" => 10, \"L\" => 50,\"\
    C\" => 100, \"D\" => 500, \"M\" => 1000)\n    roman_string = roman_num_dict[to_string(number)]\n\
    \    mini_roman_str = roman_string\n    for index in (roman_string.length - 1)::-1\
    \ do\n        if roman_string[index] >= \"M\"\n            mini_roman_str = mini_roman_str[:index]\
    \ + roman_string[index+1] + \"x\" + mini_roman_str[index+2:]\n        else\n \
    \           mini_roman_str = mini_roman_str[:index] + roman_string[index+1] +\
    \ mini_roman_str[index+2:]\n        end\n    end\n    return mini_roman_str\n\
    end\n</cell>\n<code language=julia-1.6>\nmini_roman_to_int(mini_roman_str::String)::Int64\n\
    \"\"\"\n    Given a roman numeral, return its integer equivalent.\n    Restrictions:\
    \ I = 1; V = 5; X = 10; L = 50; C = 100; D = 500; M = 1000\n\"\"\"", "    roman_num_list\
    \ = []\n    roman_num_list.append(roman_num_from_digits(get_roman_digits(number)))\n\
    \    roman_num_list.append(((get_roman_digits(number - 1) & 0b11) > 0) ? \"vi\"\
    \ : \"ix\")\n    if number < 1000 or number < 1:\n        return roman_num_list[0]\n\
    \    \n    for i in roman_num_list[1:]:\n        if i == \"ii\" or i == \"i\"\
    :\n            roman_num_list.insert(1, get_roman_digits(number / 2))\n      \
    \  else:\n            roman_num_list.insert(1, i)\n    \n    return \"\".join(roman_num_list)",
  "    if number < 1\n        return \"error\"\n    if number == 1\n        return\
    \ \"x\"\n    if number > 1\n        return int_to_mini_roman(number - 1).+int_to_mini_roman(number%10).\n\
    end", "    roman = Int64.(10).upto(1000).reduce(_ + _) \n    roman.(number).split(\"\
    x\").to_lowercase\nend", "    mini_roman_num = roman[Int(number)]\n    mini_roman_num_arr\
    \ = split(mini_roman_num, '.')\n    mini_roman_num_str = mini_roman_num_arr[1]\n\
    \    mini_roman_num_arr_str = split(mini_roman_num_str, 'x')\n    mini_roman_num_arr_str2\
    \ = split(mini_roman_num_arr_str[1], 'v')\n    mini_roman_num_arr_str3 = split(mini_roman_num_arr_str2[1],\
    \ 'i')\n    mini_roman_num_arr_str4 = split(mini_roman_num_arr_str3[1], 'r')\n\
    \    mini_roman_num_arr_str5 = split(mini_roman_num_arr_str4[1], 'l')\n    mini_roman_num_arr_str6\
    \ = split(mini_roman_num_arr_str5[1], 'w')\n    mini_roman_num_arr_str7 = split(mini_roman_num_arr_str6[1],\
    \ 'h')\n    mini_roman_num_arr_str8 = split(mini_roman_num_arr_str7[1], 'o')\n\
    \    mini_roman_num_arr_str9 = split(mini_roman_num_arr_str8[1], 'e')\n    mini_roman_num_arr_str10\
    \ = split(mini_roman_num_arr_str9[1], 'x')\n    mini_roman_num_arr_str11 = split(mini_roman_num_arr_str10[1],\
    \ 's')\n    mini_roman_num_arr_str12 = split(mini_roman_num_arr_str11[1], 'm')\n\
    \    mini_roman_num_arr_str13 = split(mini_roman_num_arr_str12[1], 'n')\n    mini_roman_num_arr_str14\
    \ = split(mini_roman_num_arr_str13[1], 'x')\n    mini_roman_num_arr_str15 = split(mini_roman_num_arr_str14[1],\
    \ 'd')\n    mini_roman_num_arr_str16 = split(mini_roman_num_arr_str15[1], 'g')\n\
    \    mini_roman_num_arr_str17 = split(mini_roman_num_arr_str16[1], 'f')\n    mini_roman_num_arr_str18\
    \ = split(mini_roman_num_arr_str17[1], 'y')\n    mini_roman_num_arr_str19 = split(mini_roman_num_arr_str18[1],\
    \ 'a')\n    mini_roman_num_arr_str20 = split(mini_roman_num_arr_str19[1], 'q')\n\
    \    mini_roman_num_arr_str21 = split(mini_roman_num_arr_str20[1], 'p')\n    mini_roman_",
  "    num = tostring(number)\n    roman = \"\"\n    function int_to_roman(n::Int64)::String\
    \ \n        str = tostring(floor(n/1000))\n        x = floor(mod(n, 1000))\n \
    \       if x == 0 then\n            return str\n        else\n            return\
    \ str + int_to_roman(x)\n        end\n    end", "    if number > 1000 || number\
    \ == 0 || number == 1 || number == 2 or number == 3 || number == 4 || number ==\
    \ 5 || number == 6 or number == 7 or number == 8 or number == 9 || number == 10\n\
    \        \"unbound\"\n    else\n        roman_digits = \"MCMXC\"\n        roman_numerals\
    \ = (0 .. number % 100).map(&roman_digits[&1 % 3])\n        numerals = roman_numerals.reduce(function(a,b)\
    \ -> a+b)\n        return numerals\nend\n</cell>\n<code language=julia-0.6>\n\
    @assert int_to_mini_roman(19) == \"xix\"\n@assert int_to_mini_roman(152) == \"\
    clii\"\n@assert int_to_mini_roman(426) == \"cdxxvi\"\n</cell>\n<code language=julia-0.6>",
  "    if number <= 0 \n    then error(\"the number must be positive\")\n    else\
    \ if number >= 1000 \n    then error(\"the number must be less than 1000\")\n\
    \    else if number == 1 \n    then \"x\"\n    else roman_to_int::Roman = roman(number)\n\
    \    else int_to_mini_roman::Int64 = int2mini(number)\nend\n</cell>\n<code language=julia-1.5>\n\
    #export\n\"\"\"\n    mini_to_int(s::String)::Int64", "  # write your code in Python\
    \ 3 style\nend", "    roman, integer = to_roman_numeral(number), number\n    if\
    \ integer == 1\n        return roman\n    \n    if roman[0] in \"MCMXCIV\"\n \
    \       roman, integer = to_roman_numeral(integer - 1), integer - 1\n    \n  \
    \  digits = roman.map(&:to_i)\n    roman.map!(&:to_char) \n    \n    return roman.map(&:upcase).join\
    \ + \"x\" + roman.map(&:downcase)", "    \n    roman = \"$\"\n    \n    roman_digits\
    \ = [\"c\", \"l\", \"i\", \"x\", \"vi\", \"vii\"]\n    \n    digits = Int(log10(number))\
    \ + 1 \n    \n    roman_values = Array(Int64, digits)\n    \n    for idx in digits:\n\
    \        roman_values[idx] = roman_digits[idx % 10]\n    \n    # Find the largest\
    \ number in the list of roman numbers\n    # greater than the number entered\n\
    \    largest = roman_values[digits]\n    \n    for idx in (digits)::-1 \n    \
    \    if roman_values[idx] > largest then\n            largest = roman_values[idx]\n\
    \        end\n    end\n    \n    # Find the largest number in the list of roman\
    \ numbers\n    # less than the number entered\n    smallest = roman_values[digits]\n\
    \    \n    for idx in (digits)::-1 \n        if roman_values[idx] < smallest then\n\
    \            smallest = roman_values[idx]\n        end\n    end\n    \n    # if\
    \ the entered number is greater than the largest number in the list \n    # of\
    \ roman numbers, then the entered number is equivalent to the\n    # smallest\
    \ number in the list\n    if number > largest then\n        roman = roman_values[digits]\n\
    \    else\n        roman = roman_values[digits]\n    end\n    return roman\nend",
  "    if is_int(number) == true\n        return to_string(number); \n    else\n \
    \       repeat(\" \", number).split(\"0\").map(int_to_mini_roman).join(\"\")\n\
    \    end\nend", "  if number <= 0\n    \"\"\n  else\n    letters = (\n      \"\
    I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\"\
    , \"CM\"\n    )\n    letters_index = (1, 2, 4, 6, 5, 9, 10, 8, 7, 3, 1)\n    roman\
    \ = (\n      \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\"\
    , \"IX\", \"V\", \"IV\", \"I\"\n    )\n    digits = (\n      \"I\", \"II\", \"\
    III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\"\
    \n    )\n    roman_letter = roman[letters_index[number]]\n    return roman_letter\n\
    \  end\nend\n</cell>\n<code language=julia-1.5>", "    result =\"\"\n    roman_num\
    \ =  get_roman_number(number)\n    for letter in roman_num:\n        result +=\
    \ letter\n    return result\nend \n</code>\n<|/ a dscore=0 |>\n<| a |>\nI created\
    \ this function in Julia:\n<code>", "    # define the base cases\n    if number\
    \ <= 0 or number > 1000: \n        return \"\"\n    elif number < 500:\n     \
    \   return convert_int_to_mini_roman(number)\n    elif number < 100:\n       \
    \ return \"x\"\n    else:\n        # handle the special case\n        thousands\
    \ = number / 1000\n        return convert_int_to_mini_roman(thousands) + \"k\"\
    \ * thousands\nend", "    roman_num = int_to_roman(number)\n    return roman_num.substring(0,roman_num.length-1)\n\
    end function", "    mini_roman = \" \"\n    while number > 1000 do\n        mini_roman\
    \ += \"i\"\n        number -= 1000\n    end\n    \n    roman = \" \"\n    if number\
    \ < 1000 do\n        roman = string(\"x\", number - 1000)\n    elseif number <\
    \ 9000 do\n        roman = string(\"C\", number - 9000)\n    elseif number < 5000\
    \ do\n        roman = string(\"D\", number - 5000)\n    elseif number < 3000 do\n\
    \        roman = string(\"M\", number - 3000)\n    elseif number < 2000 do\n \
    \       roman = string(\"L\", number - 2000)\n    elseif number < 1000 do\n  \
    \      roman = string(\"X\", number - 1000)\n    end\n    \n    return mini_roman\
    \ + roman\nend", "    if number < 1 \n        return \"error\"\n    if number\
    \ < 1000 \n        return mini_roman(number) \n    if number < 1000000 \n    \
    \    return mini_roman(number//1000) + mini_roman(number%1000) \n    if number\
    \ < 1000000000 \n        return mini_roman(number//1000000) + mini_roman(number//1000)\
    \ + mini_roman(number%1000000) + mini_roman(number%1000) \n    if number < 1000000000000\
    \ \n        return mini_roman(number//100000000) + mini_roman(number//10000000)\
    \ + mini_roman(number//10000000) + mini_roman(number%100000000) + mini_roman(number%10000000)\
    \ + mini_roman(number%10000000) + mini_roman(number%1000000) \n    else \n   \
    \     return mini_roman(number//1000000000000) + mini_roman(number//1000000000)\
    \ + mini_roman(number//100000000) + mini_roman(number//10000000) + mini_roman(number//1000000)\
    \ + mini_roman(number//100000) + mini_roman(number//10000) + mini_roman(number//1000)\
    \ + mini_roman(number//100) + mini_roman(number//10) + mini_roman(number//1) +\
    \ mini_roman(number) \nend function\n</code>\n<|/ a |>\n<| a |>\n<code>\nimport\
    \ Data.List.Split (split)\nimport Data.List.Split (splitOn)\nimport Data.Char\
    \ (toUpper)", "    \"Converts a positive integer to a mini-roman numeral\"\n \
    \   \n    if number < 1 || number > 1000\n        raise Exception(\"\"\"Restricts\
    \ the input number to be\n            between 1 and 1000\n        \"\"\")\n  \
    \  if number < 2\n        return \"\"\n    if number == 2\n        return roman_numeral_to_mini_roman(\"\
    I\")\n    \n    roman_numerals = roman_numeral_to_mini_roman(roman_numeral_to_roman(number))\n\
    \    return roman_numerals[number - 2] + roman_numerals[number - 1]", "    if\
    \ number <= 0 \n    then return \"?\"\n    else \n        letters = Array(string,\
    \ Int64((10 * number) - Int64(number)))\n        for i in 0..(Int64(letters.size)\
    \ - 1) \n        do \n            letters[i] = letters[i] / 10\n        end \n\
    \        \n        for i in 0..(Int64(letters.size) - 1) \n        do \n     \
    \       letters[i] += letters[i + 1] * Int64(\"I\")\n        end \n        \n\
    \        return \"\".join(letters)\nend \n\"\"\"\n    Given a roman numeral, obtain\
    \ its integer equivalent as a string,\n    and return it in lowercase.\n    Restrictions:\
    \ \"M\" is only allowed at the start of a Roman numeral, \n    and the sum of\
    \ digits in the numeral is less than 1000.", "\"\"\"\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n    \"\"\"\n    if number < 1 \n    then\
    \ return \"\"\n    if number < 3 \n    then return number::Int64\n    if number\
    \ < 5 \n    then return mini_roman_numeral::String\n    if number < 7 \n    then\
    \ return mini_roman_numeral::String\n    if number < 10 \n    then return mini_roman_numeral::String\n\
    \    if number < 40 \n    then return mini_roman_numeral::String\n    if number\
    \ < 100 \n    then return mini_roman_numeral::String\n    if number < 1000 \n\
    \    then return mini_roman_numeral::String\n    else return mini_roman_numeral::String\n\
    end\n</code>\n<|/ a |>\n<| a |>\nA shorter solution:\n<code>", "    let digits\
    \ = [0; 12]\n    let digits_str = [\n        \"c\", \"c\", \"c\", \"c\", \"l\"\
    , \"l\", \"l\", \"l\", \"l\", \"i\", \"i\", \"i\", \"i\", \"i\", \"i\", \"i\"\
    ,\n        \"xc\", \"xc\", \"xc\", \"xc\", \"xc\", \"l\", \"l\", \"l\", \"l\"\
    , \"l\", \"i\", \"i\", \"i\", \"i\", \"i\",\n        \"i\", \"i\", \"i\", \"i\"\
    , \"i\", \"i\", \"i\", \"i\", \"i\", \"xc\", \"xc\", \"xc\", \"xc\", \"xc\", \"\
    xc\",\n        \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"l\",\
    \ \"l\", \"l\", \"l\", \"l\", \"l\", \"i\",\n        \"i\", \"i\", \"i\", \"i\"\
    , \"i\", \"i\", \"i\", \"i\", \"i\", \"i\", \"i\", \"xc\", \"xc\", \"xc\", \"\
    xc\",\n        \"xc\", \"xc\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\"\
    , \"c\", \"l\", \"l\", \"l\", \"l\", \"l\",\n        \"l\", \"i\", \"i\", \"i\"\
    , \"i\", \"i\", \"i\", \"i\", \"i\", \"i\", \"i\", \"i\", \"xc\", \"xc\", \"xc\"\
    ,\n        \"xc\", \"xc\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"\
    c\", \"l\", \"l\", \"l\", \"l\", \"l\",\n        \"l\", \"i\", \"i\", \"i\", \"\
    i\", \"i\", \"i\", \"i\", \"i\", \"i\", \"i\", \"i\", \"xc\", \"xc\", \"xc\",\n\
    \        \"xc\", \"xc\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\"\
    , \"l\", \"l\", \"l\", \"l\", \"l\",\n        \"l\", \"i\", \"i\", \"i\", \"i\"\
    , \"i\", \"i\", \"i\", \"i\", \"i\", \"i\", \"i\", \"xc\", \"xc\", \"xc\",\n \
    \       \"xc\", \"xc\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\"\
    , \"l\", \"l\", \"l\", \"l\", \"l\",\n        \"l\", \"i\", \"i\", \"i\", \"i\"\
    , \"i\", \"i\", \"i\", \"i\", \"i\", \"i\", \"i\", \"xc\", \"xc\", \"xc\",\n \
    \       \"xc\", \"xc\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\"\
    , \"c\", \"l\", \"l\", \"l\", \"l\",\n        \"l\", \"l\", \"i\", \"i\", \"i\"\
    , \"i\", \"i\", \"i\", \"i\", \"i\", \"i\", \"i\", \"i\", \"xc\", \"xc\",\n  \
    \      \"xc\", \"xc\", \"xc\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\"\
    , \"c\", \"l\", \"l\", \"l\", \"l\",\n        \"l\", \"l\", \"i\", \"i\", \"i\"\
    , \"i\", \"i\", \"i\", \"i\", \"i\", \"i\", \"i\", \"i\", \"xc\", \"xc\",\n  \
    \      \"xc\", \"xc\", \"xc\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\"\
    , \"", "   let roman = \"\"\n   if number < 1000 then \n      roman = int_to_mini_roman(number\
    \ / 100) + int_to_mini_roman((number % 100) + 1)\n   else \n      roman = int_to_mini_roman(number\
    \ / 10) + int_to_mini_roman((number % 10) + 1) + int_to_mini_roman(number % 10)\n\
    \   return roman\nend\n</cell>\n<text>\nExercise 3\nWrite a function that converts\
    \ a positive decimal number to a decimal equivalent in scientific notation, using\
    \ only integers, and\nno floating point arithmetic. Your function should support\
    \ any number of decimal places.", "    if number < 10000000000:\n        roman_num\
    \ = roman(number)\n        if roman_num == \"\":\n            roman_num = \"0\"\
    \n        return roman_num\n    if number < 1000000000:\n        roman_num = roman(number%100000000)\n\
    \        if roman_num == \"\":\n            roman_num = \"0\"\n        return\
    \ roman_num + \"cm\"\n    if number < 1000000:\n        roman_num = roman(number%10000000)\n\
    \        if roman_num == \"\":\n            roman_num = \"0\"\n        return\
    \ roman_num + \"cd\"\n    if number < 10000000:\n        roman_num = roman(number%1000000)\n\
    \        if roman_num == \"\":\n            roman_num = \"0\"\n        return\
    \ roman_num + \"xc\"\n    if number < 1000000000:\n        roman_num = roman(number%10000000)\n\
    \        if roman_num == \"\":\n            roman_num = \"0\"\n        return\
    \ roman_num + \"cc\"\n    if number < 100000000:\n        roman_num = roman(number%1000000)\n\
    \        if roman_num == \"\":\n            roman_num = \"0\"\n        return\
    \ roman_num + \"ix\"\n    if number < 10000000:\n        roman_num = roman(number%10000000)\n\
    \        if roman_num == \"\":\n            roman_num = \"0\"\n        return\
    \ roman_num + \"lv\"\n    if number < 1000000:\n        roman_num = roman(number%1000000)\n\
    \        if roman_num == \"\":\n            roman_num = \"0\"\n        return\
    \ roman_num + \"i\"\n    if number < 1000:\n        roman_num = roman(number%1000)\n\
    \        if roman_num == \"\":\n            roman_num = \"0\"\n        return\
    \ roman_num + \"n\"\n    if number < 100:\n        roman_num = roman(number%100)\n\
    \        if roman_num == \"\":\n            roman_num = \"0\"\n        return\
    \ roman_num + \"m\"\n    return roman(number%10) + \"d\"", "    if number == 0\
    \  \n        return \"zero\" \n    if number == 1  \n        return \"one\"\n\
    \    if number == 2  \n        return \"two\"\n    if number == 3  \n        return\
    \ \"three\"\n    if number == 4  \n        return \"four\"\n    if number == 5\
    \  \n        return \"five\"\n    if number == 6  \n        return \"six\"\n \
    \   if number == 7  \n        return \"seven\"\n    if number == 8  \n       \
    \ return \"eight\"\n    if number == 9  \n        return \"nine\"\n    if number\
    \ < 0  \n        return \"negative\" ", "    if number < 1 || number > 1000 \n\
    \       error(\"Input must be between 1 and 1000\")\n    else if number == 1 \n\
    \       return \"x\"\n    else\n       if number == 2 \n          return \"x\"\
    \n       else\n          roman_num_arr =[\"\",\"i\",\"ii\",\"iii\",\"iv\",\"v\"\
    ,\"vi\",\"vii\",\"viii\",\"ix\",\"x\",\"xi\",\"xii\"]\n          roman_num_arr_cpy\
    \ = roman_num_arr\n          roman_num_arr_cpy[1] = roman_num_arr_cpy[2]\n   \
    \       roman_num_arr_cpy[2] = roman_num_arr_cpy[1]\n          roman_num_arr_cpy[2]\
    \ = roman_num_arr_cpy[2]\n          roman_num_arr_cpy[1] = roman_num_arr_cpy[2]\n\
    \          roman_num_arr_cpy[3] = roman_num_arr_cpy[4]\n          roman_num_arr_cpy[4]\
    \ = roman_num_arr_cpy[3]\n          roman_num_arr_cpy[3] = roman_num_arr_cpy[4]\n\
    \          roman_num_arr_cpy[4] = roman_num_arr_cpy[5]\n          roman_num_arr_cpy[5]\
    \ = roman_num_arr_cpy[6]\n          roman_num_arr_cpy[6] = roman_num_arr_cpy[5]\n\
    \          roman_num_arr_cpy[5] = roman_num_arr_cpy[6]\n          roman_num_arr_cpy[7]\
    \ = roman_num_arr_cpy[8]\n          roman_num_arr_cpy[8] = roman_num_arr_cpy[7]\n\
    \          roman_num_arr_cpy[7] = roman_num_arr_cpy[8]\n          roman_num_arr_cpy[8]\
    \ = roman_num_arr_cpy[9]\n          roman_num_arr_cpy[9] = roman_num_arr_cpy[10]\n\
    \          roman_num_arr_cpy[10] = roman_num_arr_cpy[9]\n          roman_num_arr_cpy[9]\
    \ = roman_num_arr_cpy[10]\n          roman_num_arr_cpy[10] = roman_num_arr_cpy[11]\n\
    \          roman_num_arr_cpy[11] = roman_num_arr_cpy[10]\n          roman_num_arr_cpy[11]\
    \ = roman_num_arr_cpy[12]\n          roman_num_arr_cpy[12] = roman_num_arr_cpy[11]\n\
    \          roman_num_arr_cpy[12] = roman_num_arr_cpy[13]\n          roman_num_arr_cpy[13]\
    \ = ", "    if number < 1\n        error(\"Number is less than 1\")\n    else\
    \ if number > 1000\n        error(\"Number is greater than 1000\")\n    else\n\
    \        if number == 0\n            error(\"Number is 0\")\n        else\n  \
    \          roman = Array{Char}(10)\n            roman[1] = 'I'\n            roman[2]\
    \ = 'V'\n            roman[3] = 'X'\n            roman[4] = 'L'\n            roman[5]\
    \ = 'C'\n            roman[6] = 'D'\n            roman[7] = 'M'\n            roman[8]\
    \ = 'I'\n            roman[9] = 'V'\n            roman[10] = 'X'\n           \
    \ roman[11] = 'L'\n            roman[12] = 'C'\n            roman[13] = 'D'\n\
    \            roman[14] = 'M'\n            roman[15] = 'I'\n            roman[16]\
    \ = 'V'\n            roman[17] = 'X'\n            roman[18] = 'L'\n          \
    \  roman[19] = 'C'\n            roman[20] = 'D'\n            roman[21] = 'M'\n\
    \            roman[22] = 'I'\n            roman[23] = 'V'\n            roman[24]\
    \ = 'X'\n            roman[25] = 'L'\n            roman[26] = 'C'\n          \
    \  roman[27] = 'D'\n            roman[28] = 'M'\n            roman[29] = 'I'\n\
    \            roman[30] = 'V'\n            roman[31] = 'X'\n            roman[32]\
    \ = 'L'\n            roman[33] = 'C'\n            roman[34] = 'D'\n          \
    \  roman[35] = 'M'\n            roman[36] = 'I'\n            roman[37] = 'V'\n\
    \            roman[38] = 'X'\n            roman[39] = 'L'\n            roman[40]\
    \ = 'C'\n            roman[41] = 'D'\n            roman[42] = 'M'\n          \
    \  roman[43] = 'I'\n            roman[44] = 'V'\n            roman[45] = 'X'\n\
    \            roman[46] = 'L'\n            roman[47] = 'C'\n            roman[48]\
    \ = 'D'\n            roman[49] = 'M'\n            roman[50] = 'I'\n          \
    \  roman[51] = 'V'\n            roman[52] = 'X'\n            roman[53] = 'L'\n\
    \            ro", "    number = to_string(number)\n    mini_roman = string(\"\
    xix\",0)\n    for digit in reverse(split(reverse(number),\"\"))\n        mini_roman\
    \ = insert(mini_roman,length(mini_roman)-1,digit)\n    return reverse(mini_roman)\n\
    end", "    if number == 0 \n        then return \"0\"\n    else if number < 0\
    \ \n        then return \"error\"\n    else if number < 100\n        then return\
    \ int_to_mini_roman((number / 10) * 10) + int_to_mini_roman(number % 10)\n   \
    \ else if number < 500 \n        then return int_to_mini_roman((number / 100)\
    \ * 100) + int_to_mini_roman(number % 100)\n    else if number < 1000 \n     \
    \   then return int_to_mini_roman((number / 1000) * 1000) + int_to_mini_roman(number\
    \ % 1000)\n    else return \"error\"\nend\n</cell>\n<text>\n4.  Repeat the problem\
    \ above, but this time use the roman_numeral_to_integer function to convert the\
    \ roman numeral to a corresponding integer.  Print the integer and compare it\
    \ to the original input.", "    # your code here\n    roman = [''] * 13\n    roman[0]\
    \ = tostring(number)\n    while number > 0: \n        if number % 100 >= 9:\n\
    \            roman[1] = roman[0] + tostring(number % 100)\n            number\
    \ /= 100\n        else:\n            roman[2] = roman[0] + tostring(number % 10)\n\
    \            number /= 10\n    roman[3] = roman[0]\n    return \"\".join(roman)\n\
    end\n</code>\n<|/ a |>\n<| a |>\nAn interesting problem and one that would benefit\
    \ from some mathematics. I suspect there is some kind of mathematical relationship\
    \ between the length of a roman number and any integer less than 1000. We need\
    \ to find that relationship. We can start by considering how we can map an integer\
    \ to a roman number. \nWe can map the integer 1 to 100 to roman numerals II, III,\
    \ IV, V and then map 2 to VII, VIII, VIII, IV, V and then map 3 to IIII, IIIII,\
    \ IIIII, IV, V and then map 4 to IV, VI, VII, VIII, III, IV, V and finally map\
    \ 5 to VIII, VIIII, VIIIII, VII, VII and finally map 6 to VII, VI, VIII, VIIII,\
    \ II, III, IV, V and finally map 7 to II, III, IIII, IIIII, IIII, II, III, IV,\
    \ V and finally map 8 to III, IIII, IIIII, IIII, IIIII, II, III, IV, V and finally\
    \ map 9 to I. \nSo we can think of numbers like this:\n<code>\n1   I\n2  II\n\
    3  III\n4  IV\n5  V\n6  VI\n7  VII\n8  VIII\n9  VIIII\n10 VIIIII\n11 VIIIII\n\
    12 VIIIII\n13 VIIIII\n14 VIIIII\n15 VIIIII\n16 VIIIII\n17 VIIIII\n18 VIIIII\n\
    19 VIIIII\n20 VIIIII\n21 VIIIII\n22 VIIIII\n23 VIIIII\n24 VIIIII\n25 VIIIII\n\
    26 VIIIII\n27 VIIIII\n28 VIIIII\n29 VIIIII\n30 VIIIII\n31 VII", "    if number\
    \ < 1 || number > 1000\n        return error(\"The number must be between 1 and\
    \ 1000\")\n    mini_roman_numbers = []\n    if number == 0\n        mini_roman_numbers\
    \ = [\"\"]\n    else\n        mini_roman_numbers = int_to_mini_roman_numbers(number)\n\
    \    mini_roman_numbers = join_numbers(mini_roman_numbers)\n    return mini_roman_numbers[length(mini_roman_numbers)\
    \ - 1]\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\n    Given a positive\
    \ integer, return the sum of its digits.\n    Returns an error (String) if the\
    \ number is negative.\n    Restrictions: 1 <= number <= 10^9", "    if number\
    \ < 1 || number > 1000\n        return \"Invalid input\"\n    roman_numbers =\
    \ []\n    \n    for roman_index in 1..(number-1)\n        roman_numbers.push(roman_index\
    \ * (\"M\" / \"D\" / \"C\") + \n            roman_index * (\"L\" / \"X\" / \"\
    V\"))\n    \n    return roman_numbers.reverse.join\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\n    convert_to_mini_roman(number::Int64)", "    if number == 0 or number\
    \ == 1 or number == 4 \n        return num2roman(number)\n    \n    num = abs(number)\n\
    \    \n    if num == 1000\n        return roman_to_num(\"IV\")\n    \n    if num\
    \ == 100\n        return roman_to_num(\"III\")\n    \n    if num == 50\n     \
    \   return roman_to_num(\"II\")\n    \n    if num == 20\n        return roman_to_num(\"\
    I\")\n    \n    if num == 10\n        return roman_to_num(\"V\")\n    \n    if\
    \ num == 5\n        return roman_to_num(\"V\")\n    \n    if num == 4\n      \
    \  return roman_to_num(\"IV\")\n    \n    if num == 3\n        return roman_to_num(\"\
    III\")\n    \n    if num == 2\n        return roman_to_num(\"II\")\n    \n   \
    \ if num == 1\n        return roman_to_num(\"I\")\n    \n    return roman_to_num(roman_to_num(num))\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    Given a positive integer,\
    \ obtain its decimal equivalent as a string,\n    and return it in uppercase.\n\
    \    Restrictions: 1 <= num <= 1000", "    string = \"\"\n    roman = roman_nums(number)\n\
    \    for n in roman:\n        string += n\n    return string\nend", "    if number\
    \ <= 0\n        error(\"Number must be a positive integer\")\n    else if number\
    \ == 1\n        return \"I\"\n    else if number == 2\n        return \"II\"\n\
    \    else if number == 3\n        return \"III\"\n    else if number == 4\n  \
    \      return \"IV\"\n    else if number == 5\n        return \"V\"\n    else\
    \ if number == 6\n        return \"VI\"\n    else if number == 7\n        return\
    \ \"VII\"\n    else if number == 8\n        return \"VIII\"\n    else if number\
    \ == 9\n        return \"IX\"\n    else if number == 10\n        return \"X\"\n\
    \    else if number == 11\n        return \"XI\"\n    else if number == 12\n \
    \       return \"XII\"\n    else if number == 13\n        return \"XIII\"\n  \
    \  else if number == 14\n        return \"XIV\"\n    else if number == 15\n  \
    \      return \"XV\"\n    else if number == 16\n        return \"XVI\"\n    else\
    \ if number == 17\n        return \"XVII\"\n    else if number == 18\n       \
    \ return \"XVIII\"\n    else if number == 19\n        return \"XIX\"\n    else\
    \ if number == 20\n        return \"XX\"\n    else if number == 21\n        return\
    \ \"XXI\"\n    else if number == 22\n        return \"XXII\"\n    else if number\
    \ == 23\n        return \"XXIII\"\n    else if number == 24\n        return \"\
    XXIV\"\n    else if number == 25\n        return \"XXV\"\n    else if number ==\
    \ 26\n        return \"XXVI\"\n    else if number == 27\n        return \"XXVII\"\
    \n    else if number == 28\n        return \"XXVIII\"\n    else if number == 29\n\
    \        return \"XXIX\"\n    else if number == 30\n        return \"XXX\"\n \
    \   else if number == 31\n        return \"XXXI\"\n    else if number == 32\n\
    \        return \"XXXII\"\n    else if number == 33\n        return \"XXXIII\"\
    \n    else if number == 34\n        return \"XXXIV\"\n    else if number == 35\n\
    \        return \"XXXV\"\n    else if number == 36\n        return \"XXXVI\"\n\
    \    else if number == 37\n        return \"XXXVII\"\n    else if number == 38\n\
    \        return \"XXXVIII\"\n    else if number == 39\n        return \"XXXIX\"\
    \n    else if number == 40\n        return \"XXXXX\"\n    else if number == 41\n\
    \        return \"XXXXXI\"", "    if number < 1 or number > 1000\n        raise\
    \ RomanException(\"Number must be between 1 and 1000\")\n    roman = \"\"\n  \
    \  if number <= 20\n        return roman\n    if number <= 40\n        return\
    \ roman\n    if number <= 60\n        return roman\n    if number <= 80\n    \
    \    roman += \"v\"\n        return roman\n    if number <= 100\n        roman\
    \ += \"c\"\n        return roman\n    if number <= 120\n        roman += \"l\"\
    \n        return roman\n    if number <= 140\n        roman += \"i\"\n       \
    \ return roman\n    if number <= 160\n        roman += \"x\"\n        return roman\n\
    \    if number <= 180\n        roman += \"v\"\n        roman += \"ix\"\n     \
    \   return roman\n    if number <= 200\n        roman += \"c\"\n        roman\
    \ += \"lx\"\n        return roman\n    if number <= 220\n        roman += \"l\"\
    \n        roman += \"ix\"\n        roman += \"v\"\n        return roman\n    if\
    \ number <= 240\n        roman += \"i\"\n        roman += \"x\"\n        roman\
    \ += \"cx\"\n        return roman\n    if number <= 250\n        roman += \"x\"\
    \n        roman += \"lx\"\n        roman += \"ix\"\n        roman += \"v\"\n \
    \       roman += \"ix\"\n        return roman\n    if number <= 260\n        roman\
    \ += \"x\"\n        roman += \"lx\"\n        roman += \"ix\"\n        roman +=\
    \ \"v\"\n        roman += \"i\"\n        roman += \"x\"\n        roman += \"l\"\
    \n        return roman\n    if number <= 280\n        roman += \"l\"\n       \
    \ roman += \"ix\"\n        roman += \"v\"\n        roman += \"i\"\n        roman\
    \ += \"x\"\n        roman += \"l\"\n        roman += \"x\"\n        return roman\n\
    \    if number <= 290\n        roman += \"l\"\n        roman += \"ix\"\n     \
    \   roman += \"v\"\n        roman += \"i\"\n        roman += \"x\"\n        roman\
    \ += \"l\"\n        roman += \"x\"\n        roman += \"x\"\n        return roman\n\
    \    if number <= 300\n        roman += \"l\"\n        roman += \"ix\"\n     \
    \   roman += \"v\"\n        roman += \"i\"\n        roman += \"x\"\n        roman\
    \ += \"l\"\n", "    if number < 1 || number > 1000\n    error(\"invalid argument\"\
    )\n    else\n        roman_number = \"\"\n        roman_number = roman_number\
    \ + int_to_roman(number)\n        roman_number = roman_number + int_to_roman(number\
    \ - 1)\n        roman_number = roman_number[1:len(roman_number)-1]\n        return\
    \ roman_number\n    end\nend\n</cell>\n<text>\nInt64 => Float64", "    roman_num_str\
    \ = \"\"\n    for integer in roman_nums(number):\n        if integer == 0 or integer\
    \ > 1000:\n            roman_num_str += \"M\"\n        elif integer > 9:\n   \
    \         roman_num_str += \"CM\"\n        else:\n            roman_num_str +=\
    \ \"D\"\n    return roman_num_str\n</cell>\n<text>\nExercise 6\nWrite a function\
    \ that converts any positive integer to a roman numeral of any length.", "   \
    \ \"\"\"\n    Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n    and return it in lowercase. \n    Restrictions: 1 <= num <= 1000",
  "    if number < 1\n    then return \"\"\n    else\n        roman = \"\"\n     \
    \   digits = floor(log10(number)) + 1\n        for _ in 0..digits-1\n        \
    \    roman = roman.succ()\n        return roman.substr(1,digits)\n    end\nend",
  "    roman = String.fromCharCode(\n        48,\n        49,\n        50,\n     \
    \   51,\n        52,\n        53,\n        54,\n        55,\n        56,\n   \
    \     57,\n        58,\n        59,\n        60,\n        61,\n        62,\n \
    \       63,\n        64,\n        65,\n        66,\n        67,\n        68,\n\
    \        69,\n        70,\n        71,\n        72,\n        73,\n        74,\n\
    \        75,\n        76,\n        77,\n        78,\n        79,\n        80,\n\
    \        81,\n        82,\n        83,\n        84,\n        85,\n        86,\n\
    \        87,\n        88,\n        89,\n        90,\n        91,\n        92,\n\
    \        93,\n        94,\n        95,\n        96,\n        97,\n        98,\n\
    \        99,\n        100,\n        101,\n        102,\n        103,\n       \
    \ 104,\n        105,\n        106,\n        107,\n        108,\n        109,\n\
    \        110,\n        111,\n        112,\n        113,\n        114,\n      \
    \  115,\n        116,\n        117,\n        118,\n        119,\n        120,\n\
    \        121,\n        122,\n        123,\n        124,\n        125,\n      \
    \  126,\n        127,\n        128,\n        129,\n        130,\n        131,\n\
    \        132,\n        133,\n        134,\n        135,\n        136,\n      \
    \  137,\n        138,\n        139,\n        140,\n        141,\n        142,\n\
    \        143,\n        144,\n        145,\n        146,\n        147,\n      \
    \  148,\n        149,\n        150,\n        151,\n        152,\n        153,\n\
    \        154,\n        155,\n        156,\n        157,\n        158,\n      \
    \  159,\n        160,\n        161,\n        162,\n        163,\n        164,\n\
    \        165,\n        166,\n        167,\n        168,\n        169,\n      \
    \  170,\n        171,\n        172,\n        173,\n        174,\n        175,\n",
  "    if number < 1\n        error(\"Invalid input number: not positive\")\n    elseif\
    \ number == 1\n        return \"x\"\n    elseif number == 2\n        return \"\
    cl\"\n    elseif number == 3\n        return \"ix\"\n    elseif number == 4\n\
    \        return \"lx\"\n    elseif number == 5\n        return \"ix\"\n    elseif\
    \ number == 6\n        return \"lx\"\n    elseif number == 7\n        return \"\
    ix\"\n    elseif number == 8\n        return \"lx\"\n    elseif number == 9\n\
    \        return \"ix\"\n    elseif number == 10\n        return \"lx\"\n    elseif\
    \ number == 11\n        return \"xix\"\n    elseif number == 12\n        return\
    \ \"clx\"\n    elseif number == 13\n        return \"ixl\"\n    elseif number\
    \ == 14\n        return \"lxl\"\n    elseif number == 15\n        return \"ixl\"\
    \n    elseif number == 16\n        return \"lxl\"\n    elseif number == 17\n \
    \       return \"ixl\"\n    elseif number == 18\n        return \"lxix\"\n   \
    \ elseif number == 19\n        return \"xixl\"\n    elseif number == 20\n    \
    \    return \"clix\"\n    elseif number == 21\n        return \"ixlx\"\n    elseif\
    \ number == 22\n        return \"lxlx\"\n    elseif number == 23\n        return\
    \ \"ixlx\"\n    elseif number == 24\n        return \"lxlx\"\n    elseif number\
    \ == 25\n        return \"ixlx\"\n    elseif number == 26\n        return \"lxlx\"\
    \n    elseif number == 27\n        return \"ixlx\"\n    elseif number == 28\n\
    \        return \"lxlx\"\n    elseif number == 29\n        return \"ixlx\"\n \
    \   elseif number == 30\n        return \"lxlx\"\n    elseif number == 31\n  \
    \      return \"ixlx\"\n    elseif number == 32\n        return \"lxlx\"\n   \
    \ elseif number == 33\n        return \"ixlx\"\n    elseif number == 34\n    \
    \    return \"lxlx\"\n    elseif number == 35\n        return \"ixlx\"\n    elseif\
    \ number == 36\n        return \"lxlx\"\n    elseif number == 37\n        return\
    \ \"ixlx\"\n    elseif number == 38\n        return \"lxlx\"\n    elseif number\
    \ == 39\n        return \"ixlx\"\n    elseif number == 40\n        return \"lxlx\"\
    \n    elseif number == 41\n        return \"ixlx\"\n    elseif number == 42\n\
    \        return \"lxlx\"\n    elseif number == 43\n        return \"ixlx\"\n \
    \   elseif number == 44", "\"\"\"\n    Takes a positive integer, and returns its\
    \ roman numeral equivalent as a string.\n    Restrictions: 1 <= num <= 1000",
  "    int_roman = Int64.(number * 100 + 5).div(100) + \n        (\"M\" # only add\
    \ it if the whole number is divisible by 100\n        when number % 100 != 0 else\
    \ \"\")\n    return int_roman.split(\"M\")[1] # only return the remainder if one\
    \ exists\nend", "  \n  if number == 0\n  then \"\"\n  else \n    roman_numerals\
    \ = roman_numerals_from(number)\n    return roman_numerals.map(x->x.to_string()).join(\"\
    x\")\nend\n</cell>\n<code language=julia-1.4>", "    if number <= 0\n        return\
    \ \"0\"\n    if number <= 500\n        return to_string(number)\n    if number\
    \ <= 999\n        return roman_to_mini_roman(number)\n    return roman_to_mini_roman(number)\n\
    end", "    if number < 1 || number > 1000\n        return \"NA\"\n    if number\
    \ == 100\n        return \"M\"\n    if number == 10\n        return \"CM\"\n \
    \   if number == 9\n        return \"D\"\n    if number == 4\n        return \"\
    CD\"\n    if number == 3\n        return \"C\"\n    if number == 2\n        return\
    \ \"XC\"\n    if number == 1\n        return \"XL\"\n    return \"XXX\" + int_to_mini_roman(number\
    \ - 1)\nend\n</cell>\n<code language=julia-1.3>\n\"\"\"\n    mini_roman_to_int(r_string\
    \ :: String)::Int64", "    if number < 1\n        error(\"Int cannot be less than\
    \ 1\")\n    roman_str = mini_roman_to_int(number)\n    string_of_roman_numbers\
    \ = \"\"\n    for char in roman_str:\n        if char == \"0\"\n            string_of_roman_numbers\
    \ = \"0\"\n        else\n            string_of_roman_numbers += char\n    return\
    \ string_of_roman_numbers\nend", "  if number < 0 or number > 1000\n    error(\"\
    Int too large\")\n  roman_numeral_string = string_to_roman_numeral(number)\n \
    \ roman_numeral_lowercase = roman_numeral_string.lower()\n  return roman_numeral_lowercase\n\
    end", "    if (number <= 0) or number > 1000\n        return \"?\"\n    \n   \
    \ roman :: String\n    roman = \"\"\n    \n    while(number > 0)\n        if (number\
    \ % 5 == 0)\n            roman += \"L\"\n        else\n            roman += \"\
    M\"\n        \n        number /= 5\n    end\n    \n    return roman\nend\n</cell>\n\
    <code language=julia-1.3>\n# %load solutions/int_to_mini_roman.jl\n</cell>\n<code\
    \ language=julia-1.3>\n\"\"\"\n    Given a positive integer, obtain its roman\
    \ numeral equivalent as a string,\n    and return it in uppercase.\n    Restrictions:\
    \ 1 <= num <= 1000", "    if number < 0 || number > 1000 then\n        error(\"\
    Invalid argument\")\n    end", "    \"\"\"\n    Int64 to string\n    \"\"\"\n\
    \    if number < 1 \n        error(\"Invalid input\")\n    else if number < 1000\
    \ \n        error(\"Not a roman numeral\")\n    else\n        if number < 5000\
    \ \n            roman = \"X\"\n        elseif number < 10000 \n            roman\
    \ = \"C\"\n        elseif number < 50000 \n            roman = \"D\"\n       \
    \ elseif number < 100000 \n            roman = \"M\"\n        else\n         \
    \   roman = \"D\"\n        end\n    end\n    return roman\nend", "    roman =\
    \ \"\"\n    prev_n = 0\n    while number >= prev_n do\n        roman += mini_romans[number\
    \ - prev_n] \n        number -= prev_n\n        prev_n = roman.length\n    end\n\
    \    roman\nend\n</code>\n<|/ a |>\n<| c |>\nThe answer is fine, but I thought\
    \ the example would make it clear that it's not a good idea to name a variable\
    \ `Int64`.\n<|/ c |>\n<| c |>\n: I didn't, but I reckon that it's better to avoid\
    \ that confusion.\n<|/ c |>\n<| a tags=roman-numerals,julia,algorithm,numbers\
    \ |>\nIf you can assume no leading zeros, then the only thing you really have\
    \ to do is convert the number to a string (or a string to a string).\nHere's a\
    \ possible Julia solution.\n<code>", "    \n    roman = romans[number]\n    \n\
    \    roman_str = roman\n    \n    roman_str = roman_str.replace(\"I\", \"v\")\n\
    \    roman_str = roman_str.replace(\"X\", \"c\")\n    \n    roman_str = roman_str.replace(\"\
    L\", \"i\")\n    roman_str = roman_str.replace(\"C\", \"d\")\n    \n    roman_str\
    \ = roman_str.replace(\"D\", \"c\")\n    \n    roman_str = roman_str.replace(\"\
    M\", \"m\")\n    roman_str = roman_str.replace(\"Q\", \"d\")\n    \n    roman_str\
    \ = roman_str.replace(\"V\", \"b\")\n    roman_str = roman_str.replace(\"B\",\
    \ \"v\")\n    \n    roman_str = roman_str.replace(\"J\", \"a\")\n    roman_str\
    \ = roman_str.replace(\"K\", \"k\")\n    \n    roman_str = roman_str.replace(\"\
    X\", \"b\")\n    roman_str = roman_str.replace(\"Y\", \"m\")\n    \n    roman_str\
    \ = roman_str.replace(\"G\", \"a\")\n    \n    roman_str = roman_str.replace(\"\
    E\", \"v\")\n    roman_str = roman_str.replace(\"G\", \"c\")\n    \n    roman_str\
    \ = roman_str.replace(\"F\", \"b\")\n    roman_str = roman_str.replace(\"H\",\
    \ \"m\")\n    \n    roman_str = roman_str.replace(\"M\", \"m\")\n    \n    roman_str\
    \ = roman_str.replace(\"S\", \"s\")\n    \n    roman_str = roman_str.replace(\"\
    T\", \"d\")\n    roman_str = roman_str.replace(\"R\", \"c\")\n    \n    roman_str\
    \ = roman_str.replace(\"X\", \"c\")\n    roman_str = roman_str.replace(\"Z\",\
    \ \"b\")\n    \n    roman_str = roman_str.replace(\"H\", \"m\")\n    \n    roman_str\
    \ = roman_str.replace(\"V\", \"b\")\n    roman_str = roman_str.replace(\"B\",\
    \ \"v\")\n    \n    roman_str = roman_str.replace(\"D\", \"c\")\n    \n    roman_str\
    \ = roman_str.replace(\"L\", \"i\")\n    \n    roman_str = roman_str.replace(\"\
    M\", \"m\")\n    \n    roman_str = roman_str.replace(\"P\", \"p\")\n    \n   \
    \ roman_str = roman_str.replace(\"S\", \"s\")\n    \n    roman_str = roman_str.replace(\"\
    R\", \"c\")\n    \n    roman_str = roman_str.replace(\"U\", \"m\")\n    \n   \
    \ roman_str = roman_str.replace(\"T\", \"d\")\n    \n    roman_str = roman_",
  "    roman_numerals = {\n        1 => \"I\",\n        2 => \"II\",\n        3 =>\
    \ \"III\",\n        4 => \"IV\",\n        5 => \"V\",\n        6 => \"VI\",\n\
    \        7 => \"VII\",\n        8 => \"VIII\",\n        9 => \"IX\",\n       \
    \ 10 => \"X\",\n        11 => \"XI\",\n        12 => \"XII\",\n        13 => \"\
    XIII\",\n        14 => \"XIV\",\n        15 => \"XV\",\n        16 => \"XVI\"\
    ,\n        17 => \"XVII\",\n        18 => \"XVIII\",\n        19 => \"XIX\",\n\
    \        20 => \"XX\",\n        21 => \"XXI\",\n        22 => \"XXII\",\n    \
    \    23 => \"XXIII\",\n        24 => \"XXIV\",\n        25 => \"XXV\",\n     \
    \   26 => \"XXVI\",\n        27 => \"XXVII\",\n        28 => \"XXVIII\",\n   \
    \     29 => \"XXIX\",\n        30 => \"XXX\",\n        31 => \"XXXI\",\n     \
    \   32 => \"XXXII\",\n        33 => \"XXXIII\",\n        34 => \"XXXIV\",\n  \
    \      35 => \"XXXV\",\n        36 => \"XXXVI\",\n        37 => \"XXXVII\",\n\
    \        38 => \"XXXVIII\",\n        39 => \"XXXIX\",\n        40 => \"XL\",\n\
    \        41 => \"XLI\",\n        42 => \"XLII\",\n        43 => \"XLIII\",\n \
    \       44 => \"XLIIII\",\n        45 => \"XLIIV\",\n        46 => \"XLIV\",\n\
    \        47 => \"XLIVI\",\n        48 => \"XLIVII\",\n        49 => \"XLIVIII\"\
    ,\n        50 => \"XLIIX\",\n        51 => \"L\",\n        52 => \"LI\",\n   \
    \     53 => \"LII\",\n        54 => \"LIII\",\n        55 => \"LIIII\",\n    \
    \    56 => \"LIIV\",\n        57 => \"LIV\",\n        58 => \"LIVI\",\n      \
    \  59 => \"LIVII\",\n        60 => \"LIVIII\",\n        61 => \"LIIX\",\n    \
    \    62 => \"LX\",\n        63 => \"LXI\",\n        64 => \"LXII\",\n        65\
    \ => \"LXIII\",\n        66 => \"", "    roman_num::String = \"\"\n    if number\
    \ < 1 || number > 1000 then\n        error!(\"Invalid integer value\")\n    elseif\
    \ number == 0 then\n        error!(\"Cannot convert 0 to roman numeral\")\n  \
    \  else\n        roman_num = roman_numerals(number)\n    end", "    if number\
    \ <= 1 then return \"0\"\n    if number <= 10 then return roman_num(number)\n\
    \    if number <= 1000 then return roman_num(number)\n    if number <= 10000 then\
    \ return roman_num(number)\n    if number <= 100000 then return roman_num(number)\n\
    \    if number <= 1000000 then return roman_num(number)\n    if number <= 10000000\
    \ then return roman_num(number)\n    if number <= 100000000 then return roman_num(number)\n\
    \    if number <= 1000000000 then return roman_num(number)\n    if number <= 10000000000\
    \ then return roman_num(number)\n    if number <= 100000000000 then return roman_num(number)\n\
    \    if number <= 1000000000000 then return roman_num(number)\n    if number <=\
    \ 10000000000000 then return roman_num(number)\n    if number <= 100000000000000\
    \ then return roman_num(number)\n    if number <= 1000000000000000 then return\
    \ roman_num(number)\n    if number <= 10000000000000000 then return roman_num(number)\n\
    \    if number <= 100000000000000000 then return roman_num(number)\n    if number\
    \ <= 1000000000000000000 then return roman_num(number)\n    if number <= 10000000000000000000\
    \ then return roman_num(number)\n    if number <= 100000000000000000000 then return\
    \ roman_num(number)\n    if number <= 1000000000000000000000 then return roman_num(number)\n\
    \    if number <= 10000000000000000000000 then return roman_num(number)\n    if\
    \ number <= 100000000000000000000000 then return roman_num(number)\n    if number\
    \ <= 1000000000000000000000000 then return roman_num(number)\n    if number <=\
    \ 10000000000000000000000000 then return roman_num(number)\n    if number <= 100000000000000000000000000\
    \ then return roman_num(number)\n    if number <= 1000000000000000000000000000\
    \ then return roman_num(number)\n    if number <= 10000000000000000000000000000\
    \ then return roman_num(number)\n    if number <= 100000000000000000000000000000\
    \ then return roman_num(number)\n    if number <= 1000000000000000000000000000000\
    \ then return roman_num(number)\n    if number <= 10000000000000000000000000000000\
    \ then return roman_num(number)\n    if number <= 100000000000000000000000000000000\
    \ then return roman_num(number)\n    if number <= 1000000000000000000000000000000000\
    \ then return roman_num(number)\n    if number <= 10000000000000000000000000000000000\
    \ then return roman_num(number)\n    if number <= 100000000000000000000000000000000000\
    \ then return roman_num(number)\n    if number <= 1000000000000000000000000000000000000\
    \ then return roman_num(", "    roman = \"\"\n    big = \"\"\n    i = 0\n    while\
    \ number != 0\n        big += string(i::Int64 - 1, digits)\n        i += 1\n \
    \       number %= 1000\n    end\n    \n    if big != \"\"\n        roman = big.substring(1).replace(\"\
    x\", big.substring(2).replace(\"\", \"\").substring(1)) + big.substring(1)\n \
    \   end\n    return roman\nend", "    number_roman = Int64.(number_to_roman(number))\n\
    \    number_roman = replace(number_roman, \",\", \"\")\n    number_roman = replace(number_roman,\
    \ \".\", \"\")\n    number_roman = replace(number_roman, \":\", \"\")\n    number_roman\
    \ = replace(number_roman, \"'\", \"\")\n    number_roman = replace(number_roman,\
    \ \"\\\\\", \"\")\n    number_roman = replace(number_roman, \"-\", \"\")\n   \
    \ number_roman = replace(number_roman, \"^\", \"\")\n    number_roman = replace(number_roman,\
    \ \"~\", \"\")\n    number_roman = replace(number_roman, \"#\", \"\")\n    number_roman\
    \ = replace(number_roman, \" \", \"\")\n    number_roman = replace(number_roman,\
    \ \"*\", \"\")\n    return lowercase(number_roman)\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a |>\nI came up with this as a solution based on my previous answer to\
    \ this question:\n<code>", "    if number <= 0 or number >= 1000:\n        \"\
    oops\"\n    return mini_roman_to_int(roman_numeral_to_mini_roman(to_roman(number)))\n\
    end", "    if number < 1 \n        error(\"Number must be greater than 1\")\n\
    \    if number > 1000\n        error(\"Number must be less than 1000\")\n    roman\
    \ = \"\"\n    i = 0\n    while i < number\n        roman = roman + int_to_mini_roman(number/10)\
    \ + int_to_mini_roman(number%10)\n        i = i + 1\n    return roman\nend", " \
    \   int_to_roman = \n\"\"\"\n    Given a positive integer, obtain its roman numeral\
    \ equivalent as a string,\n    and return it in lowercase.\n    Restrictions:\
    \ 1 <= num <= 1000\n    \"\"\"\n\"\"\"\n    \n\"\"\"\n    \n\"\"\"", "    roman_numbers\
    \ = \n        (\"M\"..\"D\")\n        | (\"C\"..\"X\")\n        | (\"L\"..\"X\"\
    )\n        | (\"X\"..\"XL\")\n        | (\"C\"..\"IV\")\n        | (\"V\"..\"\
    IX\")\n        | (\"I\"..\"II\")\n        | (\"II\"..\"III\")\n        | (\"I\"\
    ..\"IV\")\n        | (\"V\"..\"V\")\n        | (\"IV\"..\"V\")\n        | (\"\
    I\"..\"I\")", "    \n    if number == 0 \n        return \"0\" \n    \n    let\
    \ nums = String[]()\n    \n    let n = math.floor(math.log(number, 1000))\n  \
    \  for j in 0..n do \n        if number >= math.pow(1000, j + 1) then \n     \
    \       push!(nums, mini_roman(math.pow(1000, j + 1) - number)) \n        else\
    \ \n            push!(nums, mini_roman(number / math.pow(1000, j + 1))) \n   \
    \         number = number - math.pow(1000, j + 1) * math.pow(1000, j + 1) \n \
    \   \n    push!(nums, mini_roman(number))\n    \n    return join(nums, \"\")\n\
    end\n</cell>\n<code language=julia-1.0>\n# TEST int_to_mini_roman on TEST CASES",
  "    if number < 1 || number > 1000\n        error(\"Given number must be between\
    \ 1 and 1000\")\n    elseif number == 1\n        return \"x\"\n    elseif number\
    \ == 2\n        return \"i\"\n    elseif number == 3\n        return \"ii\"\n\
    \    elseif number == 4\n        return \"iii\"\n    elseif number == 5\n    \
    \    return \"iv\"\n    elseif number == 6\n        return \"v\"\n    elseif number\
    \ == 7\n        return \"vi\"\n    elseif number == 8\n        return \"vii\"\n\
    \    elseif number == 9\n        return \"ix\"\n    elseif number == 10\n    \
    \    return \"xix\"\n    elseif number == 11\n        return \"xii\"\n    elseif\
    \ number == 12\n        return \"xiii\"\n    elseif number == 13\n        return\
    \ \"xiv\"\n    elseif number == 14\n        return \"xvi\"\n    elseif number\
    \ == 15\n        return \"xvii\"\n    elseif number == 16\n        return \"xix\"\
    \n    elseif number == 17\n        return \"xiii\"\n    elseif number == 18\n\
    \        return \"xiv\"\n    elseif number == 19\n        return \"xvi\"\n   \
    \ elseif number == 20\n        return \"xvii\"\n    elseif number == 21\n    \
    \    return \"xii\"\n    elseif number == 22\n        return \"xiii\"\n    elseif\
    \ number == 23\n        return \"xiv\"\n    elseif number == 24\n        return\
    \ \"xvi\"\n    elseif number == 25\n        return \"xvii\"\n    elseif number\
    \ == 26\n        return \"xii\"\n    elseif number == 27\n        return \"xiii\"\
    \n    elseif number == 28\n        return \"xiv\"\n    elseif number == 29\n \
    \       return \"xvi\"\n    elseif number == 30\n        return \"xvii\"\n   \
    \ elseif number == 31\n        return \"xii\"\n    elseif number == 32\n     \
    \   return \"xiii\"\n    elseif number == 33\n        return \"xiv\"\n    elseif\
    \ number == 34\n        return \"xvi\"\n    elseif number == 35\n        return\
    \ \"xvii\"\n    elseif number == 36\n        return \"xii\"\n    elseif number\
    \ == 37\n        return \"xiii\"\n    elseif number == 38\n        return \"xiv\"\
    \n    elseif number == 39\n        return \"xvi\"\n    elseif number == 40\n \
    \       return \"xvii\"\n    elseif number == 41\n        return \"xii\"\n   \
    \ elseif number == 42\n        return \"xiii\"\n    elseif number == 43\n    \
    \    return \"xiv\"\n    elseif number == 44\n        return \"xvi\"\n    elseif\
    \ number == 45\n        return \"xvii\"", "    if number < 0 then error(\"number\
    \ must be positive\") end\n    roman_number = \"\"\n    while number >= 1000 do\n\
    \        roman_number = (number % 1000) + roman_number\n        number = floor(number\
    \ / 1000) \n    end\n    roman_number = (number % 1000) + roman_number\n    return\
    \ roman_number\nend", "    if number < 1 or number > 1000:\n        raise ArgumentError(\"\
    Integer must be between 1 and 1000\")\n    return roman_to_mini_roman(int_to_roman(number))",
  "    return int_to_roman_numeral(number) |> to_string\n</code>\nAnd that's it. The\
    \ full source code for the function is shown below. Note that you can copy the\
    \ function in to your project directory and import it directly from that file\
    \ without having to use the :: syntax. I've included an example function here\
    \ to help you understand the syntax. Lastly, I included the tests in my unit tests\
    \ so you can see the results.\n<code>\n# int_to_mini_roman.h\n\"\"\"\nGiven a\
    \ positive integer, obtain its roman numeral equivalent as a string,\nand return\
    \ it in lowercase.\nRestrictions: 1 <= num <= 1000", "    mini_roman = int_to_roman(number)\n\
    \    mini_roman = mini_roman[2:]\n    mini_roman = \"i\" + mini_roman \n    return\
    \ mini_roman", "    if number == 0 \n        return \"0\"\n    if number < 0\n\
    \        error(\"negative numbers\")\n    end", "    if number < 0 or number >\
    \ 1000:\n        error(\"Invalid number\")\n    end\n    if number == 1000\n \
    \       return \"M\"\n    end", "    string = \"\"\n    roman_numbers = [1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    for r in roman_numbers\n\
    \        quotient = number / r\n        number = number % r\n        if quotient\
    \ == 0\n            string += roman_numbers[roman_numbers.index(r)]\n        elseif\
    \ quotient == 1\n            string += roman_numbers[roman_numbers.index(r)] +\
    \ \"i\"\n        elseif quotient == 2\n            string += roman_numbers[roman_numbers.index(r)]\
    \ + \"ii\"\n        elseif quotient == 3\n            string += roman_numbers[roman_numbers.index(r)]\
    \ + \"iii\"\n        elseif quotient == 4\n            string += roman_numbers[roman_numbers.index(r)]\
    \ + \"iv\"\n        elseif quotient == 5\n            string += roman_numbers[roman_numbers.index(r)]\
    \ + \"v\"\n        elseif quotient == 6\n            string += roman_numbers[roman_numbers.index(r)]\
    \ + \"vi\"\n        elseif quotient == 7\n            string += roman_numbers[roman_numbers.index(r)]\
    \ + \"vii\"\n        elseif quotient == 8\n            string += roman_numbers[roman_numbers.index(r)]\
    \ + \"viii\"\n        elseif quotient == 9\n            string += roman_numbers[roman_numbers.index(r)]\
    \ + \"ix\"\n        elseif quotient == 10\n            string += roman_numbers[roman_numbers.index(r)]\
    \ + \"x\"\n        elseif quotient == 11\n            string += roman_numbers[roman_numbers.index(r)]\
    \ + \"xii\"\n        elseif quotient == 12\n            string += roman_numbers[roman_numbers.index(r)]\
    \ + \"xiii\"\n        end\n    end\n    return string\nend\n</cell>\n<code language=julia-1.5>",
  "    roman = \"\"\n    roman_numeral = \"\"\n    roman_numerals = Int64[]\n    \n\
    \    while(number > 0)\n        roman_numerals[number] = \"\"\n        \n    \
    \    roman_numeral = Int64[]\n        \n        for i in 1:(number % 10)\n   \
    \         roman_numeral[i] = roman_numerals[number / 10]\n            roman_numeral[number\
    \ % 10] = i\n            number /= 10\n        end\n        \n        for i in\
    \ 1:(roman_numeral.length - 1)\n            roman = roman_numerals[i] + roman\n\
    \        end\n        \n        number -= 1\n    end\n    \n    return roman\n\
    end", "    roman_num = \"\"\n    roman_num_dict = [\"\",\"i\",\"ii\",\"iii\",\"\
    iv\",\"v\",\"vi\",\"vii\",\"viii\",\"ix\",\"x\",\"xi\",\"xii\",\"xiii\",\"xiv\"\
    ,\"xix\",\"xxx\"]\n    \n    if number < 0\n        return nil", "    if number\
    \ == 0\n        return \"0\"\n    roman = \"\"\n    last_digit = 0\n    while\
    \ number > 1\n        last_digit += 1\n        number /= 10\n        if number\
    \ > 1\n            roman += int_to_mini_roman(number).sub(int_to_mini_roman(number).sub!(\"\
    0\"), \"x\")\n        end\n    end\n    roman += int_to_mini_roman(last_digit).sub(int_to_mini_roman(last_digit).sub!(\"\
    0\"), \"x\")\n    return roman\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\
    \n    Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    \    and return it in uppercase.\n    Restrictions: 1 <= num <= 1000", "    if\
    \ number <= 0\n        return \"Error!\"\n    if number > 1000\n        return\
    \ \"Error!\"\n    roman = \"\"\n    if number <= 500\n        roman += \"c\"\n\
    \        number -= 500\n    if number <= 950\n        roman += \"d\"\n       \
    \ number -= 950\n    if number <= 1950\n        roman += \"c\"\n        number\
    \ -= 1950\n    if number <= 999\n        roman += \"x\"\n        number -= 999\n\
    \    if number <= 5000\n        roman += \"l\"\n        number -= 5000\n    if\
    \ number <= 10000\n        roman += \"c\"\n        number -= 10000\n    if number\
    \ <= 19999\n        roman += \"x\"\n        number -= 19999\n    if number <=\
    \ 49999\n        roman += \"l\"\n        number -= 49999\n    if number <= 99999\n\
    \        roman += \"x\"\n        number -= 99999\n    if number <= 999999\n  \
    \      roman += \"l\"\n        number -= 999999\n    if number <= 199999\n   \
    \     roman += \"x\"\n        number -= 199999\n    return roman\nend", "    roman_numerals\
    \ = RomanNumerals()\n    return roman_numerals.to_mini_roman(number)\nend", " \
    \   \n    if number < 1 || number > 1000:\n        return \"Invalid number\"\n\
    \    \n    roman_nums = []\n    \n    for m in range(3, 11, 3):\n        for n\
    \ in range(0, m):\n            roman_nums.append(str(number//m))\n           \
    \ number %= m\n    \n    return \"\".join(roman_nums)\nend", "    num = number\n\
    \    roman = \"\"\n    if num < 1\n        roman = \"X\"\n        return roman\n\
    \    if num < 10\n        roman = \"x\"\n        return roman\n    i = 2\n   \
    \ while i <= num\n        roman = roman + roman_numeral(i + 1).to_lowercase\n\
    \        i = i + 1\n    roman = roman * i\n    return roman\nend\n</code>\n<|/\
    \ a tags=julia,roman-numerals dscore=2 |>\n<| a dscore=2 tags=julia,roman-numerals\
    \ |>\n<code>\nusing Printf", "  if number < 1 \n    return \"\"\n  elseif number\
    \ < 1000\n    return roman_digit_to_string(number)\n  elseif number < 9000\n \
    \   return roman_digit_to_string(number) + mini_roman_digit_to_string(number-1)\n\
    \  elseif number < 90000\n    return roman_digit_to_string(number) + mini_roman_digit_to_string(number-1)\
    \ + mini_roman_digit_to_string(number-2)\n  elseif number < 900000\n    return\
    \ roman_digit_to_string(number) + mini_roman_digit_to_string(number-1) + mini_roman_digit_to_string(number-2)\
    \ + mini_roman_digit_to_string(number-3)\n  elseif number < 9000000\n    return\
    \ roman_digit_to_string(number) + mini_roman_digit_to_string(number-1) + mini_roman_digit_to_string(number-2)\
    \ + mini_roman_digit_to_string(number-3) + mini_roman_digit_to_string(number-4)\n\
    \  elseif number < 90000000\n    return roman_digit_to_string(number) + mini_roman_digit_to_string(number-1)\
    \ + mini_roman_digit_to_string(number-2) + mini_roman_digit_to_string(number-3)\
    \ + mini_roman_digit_to_string(number-4) + mini_roman_digit_to_string(number-5)\n\
    \  else\n    return roman_digit_to_string(number) + mini_roman_digit_to_string(number-1)\
    \ + mini_roman_digit_to_string(number-2) + mini_roman_digit_to_string(number-3)\
    \ + mini_roman_digit_to_string(number-4) + mini_roman_digit_to_string(number-5)\
    \ + mini_roman_digit_to_string(number-6)\n  end\nend\n  \n\"\"\"\n    Given a\
    \ positive integer, obtain its mini roman numeral equivalent as a string,\n  \
    \  and return it in lowercase.\n    Restrictions: 1 <= num <= 1000", "    if number\
    \ < 1 || number > 1000\n        error(\"Invalid input!\")\n    end\n    return\
    \ roman_numerals(number)\nend\n</cell>\n<code language=julia-0.5>\nint_to_mini_roman(19)\n\
    </cell>\n<code language=julia-0.5>\nint_to_mini_roman(152)\n</cell>\n<code language=julia-0.5>\n\
    int_to_mini_roman(426)\n</cell>\n<text>\n9. Palindrome Number\nA palindromic number\
    \ reads the same both ways. The largest palindrome made from the product of two\
    \ 2-digit numbers is 9009 = 91 x 99.", "  if(number == 0)\n    \"0\"\n  else if(number\
    \ < 0)\n    \"-\"\n  else if(number < 10)\n    int_to_mini_roman(number-1) + \"\
    i\"\n  else\n    int_to_mini_roman(number//10) + \"x\" +\n          int_to_mini_roman(number%10)\
    \ + \"i\"\nend\n</cell>\n<text>\nWe can also define a function that returns its\
    \ reverse:", "    roman = Int64(\"II\") \n    num = number \n    roman, num =\
    \ roman.to_string(2), num.to_string(2) \n    while (num.length > 1) \n       \
    \ roman, num = roman.char_insert(roman.index(num.last()), num.last()), num.last()\n\
    \    end\n    return roman\nend\n</cell>\n<code language=julia-1.4>\n\"\"\"\n\
    Given an integer, convert it to its english counterpart,\nand return it in lower\
    \ case.\n\"\"\"", "    if number < 1 || number > 1000\n        error \"invalid\
    \ input\"\n    end\n    if number <= 19\n        return string(\"x\")\n    elseif\
    \ number <= 39\n        return string(\"c\")\n    elseif number <= 59\n      \
    \  return string(\"d\")\n    elseif number <= 90\n        return string(\"m\"\
    )\n    elseif number <= 144\n        return string(\"l\")\n    else\n        return\
    \ string(\"xl\")\n    end\nend", "    \"Converts integer to roman numeral in lowercase\"\
    \n    if number < 1 || number > 1000\n        throw(Exception, \"Invalid number\
    \ for int_to_mini_roman: \" ++ to_string(number))\n    else\n        mini_roman\
    \ = \"\"\n        while number > 0\n            if number % 10 == 0\n        \
    \        mini_roman += \"0\"\n            else\n                mini_roman +=\
    \ chr(number % 10)\n            number = number / 10\n        mini_roman += chr(number)\n\
    \        return mini_roman\nend ", "    roman = \"\"\n    number = convert(number)\n\
    \    while number != 0\n        roman += convert(number % 10)\n        number\
    \ /= 10\n    end\n    roman = convert(roman)\n    return roman\nend\n\"\"\"\n\
    \    Calculate the number of decimal digits in an integer,\n    which is defined\
    \ as the number of decimal places \n    in the largest power of 10 you can get\
    \ away with.", "    roman = roman_numerals(number-1)\n    roman[roman.len()-1]\
    \ = roman[roman.len()-1].to_lower()\n    roman[roman.len()] = roman[roman.len()].to_lower()\
    \ \n    return roman.join(\"\") \nend \n</code>\nAnd here are the functions for\
    \ the other three cases:\n<code>\n\"\"\"\n    Given a positive integer, obtain\
    \ the roman numeral equivalent as a string,\n    and return it in uppercase. Restrictions:\
    \ 1 <= num <= 1000", "    roman = \"i\"\n    num = number\n    while num != 0\n\
    \        if num % 10 == 1\n            roman += \"x\"\n        elseif num % 10\
    \ == 2\n            roman += \"l\"\n        elseif num % 10 == 3\n           \
    \ roman += \"c\"\n        elseif num % 10 == 4\n            roman += \"v\"\n \
    \       elseif num % 10 == 5\n            roman += \"d\"\n        elseif num %\
    \ 10 == 6\n            roman += \"m\"\n        elseif num % 10 == 7\n        \
    \    roman += \"c\"\n        elseif num % 10 == 8\n            roman += \"v\"\n\
    \        elseif num % 10 == 9\n            roman += \"x\"\n        end\n     \
    \   num /= 10\n    return roman\nend\n</cell>\n<code language=julia-1.0>\n\"\"\
    \"\n    Given a positive integer, obtain its numeral equivalent as a string,\n\
    \    and return it in lowercase.\n    Restrictions: 1 <= num <= 1000", "    if\
    \ number < 100\n        mini_roman = \"x\"\n        number\n    else\n       \
    \ if number < 500\n            mini_roman = \"c\"\n            number - 500\n\
    \        else\n            if number < 1000\n                mini_roman = \"m\"\
    \n                number - 1000\n            else\n                if number <\
    \ 5000\n                    mini_roman = \"d\"\n                    number - 5000\n\
    \                else\n                    if number < 10000\n               \
    \         mini_roman = \"l\"\n                        number - 10000\n       \
    \             else\n                        if number < 50000\n              \
    \              mini_roman = \"s\"\n                            number - 50000\n\
    \                        else\n                            if number < 100000\n\
    \                                mini_roman = \"r\"\n                        \
    \        number - 100000\n                            else\n                 \
    \               if number < 500000\n                                    mini_roman\
    \ = \"f\"\n                                    number - 500000\n             \
    \                   else\n                                    if number < 1000000\n\
    \                                        mini_roman = \"v\"\n                \
    \                        number - 1000000\n                                  \
    \  else\n                                        if number < 50000000\n      \
    \                                      mini_roman = \"xl\"\n                 \
    \                           number - 50000000\n                              \
    \          else\n                                            if number < 10000000\n\
    \                                                mini_roman = \"xs\"\n       \
    \                                         number - 10000000\n                \
    \                            else\n                                          \
    \      if number < 50000000\n                                                \
    \    mini_roman = \"s\"\n                                                    number\
    \ - 50000000\n                                                else\n         \
    \                                           mini_roman = \"m\"\n             \
    \                                       number - 1000000\n    end\nend", "   \
    \ if number > 1000 || number < 1 \n        return \"?\"\n    letters = roman_numeral(number)\n\
    \    return lowercase(join(letters, \"\"))\nend\n</code>\n<|/ a |>\n<| c |>\n\
    This would still require that the function `roman_numeral` be modified, which\
    \ is exactly what OP was trying to avoid.\n<|/ c |>\n<| c |>\nIndeed, and that's\
    \ exactly what I'm trying to avoid. The function `roman_numeral` should be modified\
    \ to remove duplicates, but that's what the OP is trying to avoid. Besides, my\
    \ answer is about a generic solution, not an implementation for the specific problem\
    \ (which is why I answered it the way I did). Besides, OP specifically said he\
    \ didn't want any external dependencies in my answer.\n<|/ c |>\n<| c |>\nOP didn't\
    \ explicitly say that he didn't want a dependency on the `roman_numeral` function,\
    \ just that he was trying to avoid it.\n<|/ c |>\n<| c |>\nI believe it's important\
    \ to point out that in my answer I actually provided an implementation to the\
    \ problem you specified. My point is that this is an excellent answer, and I don't\
    \ want to take away my reputation, but I do think it is important to point out\
    \ that it is _not_ an answer to _your_ question. My point is, I don't think that\
    \ you can do what you want without an external dependency.\n<|/ c |>\n<| a |>\n\
    Here's a Julia version using only standard libraries:\n<code>", "  # TODO: implement\
    \ your function here\n  if number < 1 \n  then return \"?\"\n  else \n    roman\
    \ = \"I\"\n    i = 2\n    while number > roman.length + i\n      roman = roman.substring(0,roman.length\
    \ + i) + roman.substring(i)\n      i = i + 1\n    return roman\n  end\nend\n</cell>\n\
    <code language=julia-1.0>", "    if number == 0 \n        error(\"number must\
    \ be positive\")\n    end\n    mini_roman = \"\"\n    current = 1\n    while current\
    \ <= number\n        mini_roman += int_to_roman(current)\n        current += 1\n\
    \    end\n    mini_roman = mini_roman[0..-2]\n    return mini_roman\nend\n</cell>\n\
    <text>\nint_to_roman(number::Int64)", "    if number < 1 \n        or number >\
    \ 1000 \n        then return \"Error\" \n    else if number < 400 \n        then\
    \ return int_to_mini_roman(number//10) * \"c\" + int_to_mini_roman(number%10)\n\
    \        else if number < 500 \n            then return int_to_mini_roman(number//100)\
    \ * \"d\" + int_to_mini_roman(number%100)\n            else if number < 1000 \n\
    \                then return int_to_mini_roman(number//1000) * \"cd\" + int_to_mini_roman(number%1000)\n\
    \                else if number < 10000 \n                    then return int_to_mini_roman(number//10000)\
    \ * \"ccc\" + int_to_mini_roman(number%10000)\n                    else if number\
    \ < 40000 \n                        then return int_to_mini_roman(number//100000)\
    \ * \"ccc\" + int_to_mini_roman(number%100000)\n                        else if\
    \ number < 100000 \n                            then return int_to_mini_roman(number//1000000)\
    \ * \"ccc\" + int_to_mini_roman(number%1000000)\n                            else\
    \ if number < 4000000 \n                                then return int_to_mini_roman(number//10000000)\
    \ * \"ccc\" + int_to_mini_roman(number%10000000)\n                           \
    \     else if number < 10000000 \n                                    then return\
    \ int_to_mini_roman(number//100000000) * \"cccc\" + int_to_mini_roman(number%100000000)\n\
    \                                    else if number < 400000000 \n           \
    \                             then return int_to_mini_roman(number//1000000000)\
    \ * \"cccc\" + int_to_mini_roman(number%1000000000)\n                        \
    \                else if number < 1000000000 \n                              \
    \              then return int_to_mini_roman(number//10000000000) * \"cccc\" +\
    \ int_to_mini_roman(number%10000000000)\n                                    \
    \        else if number < 4000000000 \n                                      \
    \          then return int_to_mini_roman(number//100000000000) * \"ccccc\" + int_to_mini_roman(number%10000000000)\n\
    \                                                else if number < 100000000000\
    \ \n                                                    then return int_to_mini_roman(number//1000000000000)\
    \ * \"ccccc\" + int_to_mini_roman(number%100000000000)\n                     \
    \                               else if number < 400000000000 \n             \
    \                                           then return int_to_mini_roman(number//10000000000000)\
    \ * \"cccccc\" + int_to_mini_ro", "    # Your code here\n    ones  = [\"I\", \"\
    IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\"\
    , \"M\"]\n    teens = [\"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\",\
    \ \"XVIII\", \"XIX\", \"XX\", \"XXX\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"\
    D\", \"CM\", \"M\"]\n    twos  = [\"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\"\
    , \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\"\
    , \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXX\", \"XL\", \"L\", \"XC\", \"C\"\
    , \"CD\", \"D\", \"CM\", \"M\"]\n    threes = [\"IIII\", \"IIIII\", \"IIIV\",\
    \ \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXX\"\
    , \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"]\n    fives = [\"\
    IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\"\
    , \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXX\", \"\
    XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"]\n    sevens = [\"VIIII\"\
    , \"VIIIII\", \"VIIIV\", \"VII\", \"VIII\", \"VIIII\", \"II\", \"III\", \"IIII\"\
    , \"IIIII\", \"IIIV\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"VIIII\", \"\
    VIIIII\", \"VIIIV\", \"VI\", \"VII\", \"VIII\", \"VIIII\", \"VIIIII\", \"VIIIV\"\
    , \"IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIIII\", \"XIIIII\", \"XIIIV\",\
    \ \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XVIIII\", \"XVIIIII\", \"XVIIIV\", \"\
    XIX\", \"XX\", \"XXX\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"\
    M\"]\n    eights = [\"VII", "    if number <= 0 || number > 1000\n        return\
    \ \"Error\"\n    elseif number >= 1000 && number <= 4999\n        return number_to_roman(number::Int64)\n\
    \    else\n        return number_to_mini_roman(number::Int64)\n    end\nend\n\
    </cell>\n<cell>\n#export\n\"\"\"\n    mini_roman_to_int_convert(str::String)",
  "    romanString = \"\"\n    if number >= 1000:\n        raise Exception.new(\"\
    Number must be less than 1000\")", "    roman_numbers = roman_numbers(number)\n\
    \    return roman_numbers[0, :]\nend\n</cell>\n<code language=julia-1.5>", " \
    \   if number == 0\n        \"\"\n    elseif number < 1\n        \"\"\n    else\n\
    \        mini_roman(number)\n    end\nend\n\"\"\"\n    Given a positive integer,\
    \ and an optional number of digits, print its \n    equivalent as a string in\
    \ given number of digits, left-aligned, with \n    commas separating thousands.\
    \ \n    Restrictions: 1 <= num <= 1000, 0 <= digits < 9.", "    if number > 1000\
    \ or number == 0 then return \"\" \n    roman = [\"x\",\"c\",\"l\",\"i\",\"d\"\
    ,\"m\"]\n    temp = \"\"\n    num = number\n    for i in roman\n        if num\
    \ < 1 then return \"invalid\"\n        if num == 1 then return roman[0]\n    \
    \    temp = temp + roman[num % 10]\n        num = num / 10\n    end\n    return\
    \ temp + roman[num]\nend", "    roman_numeral = ''\n    if number < 1\n      \
    \  error(\"invalid input, num should be positive\")\n        return\n    if number\
    \ >= 100\n        error(\"invalid input, num should be less than or equal to 100\"\
    )\n        return\n    for x in roman_numerals\n        if x.first <= number <=\
    \ x.second\n            roman_numeral = roman_numeral + x.third\n        else\n\
    \            return\n    error(\"invalid input\")\n    return roman_numeral.lower()\n\
    end", "    if number == 0: return \"0\"\n    \n    if number <= 3: return \"x\"\
    \n    \n    if number <= 6: return \"x\"\n    \n    if number <= 9: return \"\
    i\"\n    \n    if number <= 14: return \"i\"\n    \n    if number <= 19: return\
    \ \"i\"\n    \n    if number <= 24: return \"i\"\n    \n    if number <= 39: return\
    \ \"i\"\n    \n    if number <= 49: return \"i\"\n    \n    if number <= 59: return\
    \ \"i\"\n    \n    if number <= 69: return \"i\"\n    \n    if number <= 79: return\
    \ \"i\"\n    \n    if number <= 89: return \"i\"\n    \n    if number <= 99: return\
    \ \"i\"\n    \n    if number <= 149: return \"i\"\n    \n    if number <= 199:\
    \ return \"i\"\n    \n    if number <= 249: return \"i\"\n    \n    if number\
    \ <= 399: return \"i\"\n    \n    if number <= 499: return \"i\"\n    \n    if\
    \ number <= 619: return \"i\"\n    \n    if number <= 719: return \"i\"\n    \n\
    \    if number <= 829: return \"i\"\n    \n    if number <= 939: return \"i\"\n\
    \    \n    if number <= 949: return \"i\"\n    \n    if number <= 959: return\
    \ \"i\"\n    \n    if number <= 969: return \"i\"\n    \n    if number <= 979:\
    \ return \"i\"\n    \n    if number <= 979: return \"i\"\n    \n    if number\
    \ <= 979: return \"i\"\n    \n    if number <= 979: return \"i\"\n    \n    if\
    \ number <= 979: return \"i\"\n    \n    if number <= 979: return \"i\"\n    \n\
    \    if number <= 979: return \"i\"\n    \n    if number <= 979: return \"i\"\n\
    \    \n    if number <= 979: return \"i\"\n    \n    if number <= 979: return\
    \ \"i\"\n    \n    if number <= 979: return \"i\"\n    \n    if number <= 979:\
    \ return \"i\"\n    \n    if number <= 979: return \"i\"\n    \n    if number\
    \ <= 979: return \"i\"\n    \n    if number <= 979: return \"i\"\n    \n    if\
    \ number <= 979: return \"i\"\n    \n    if number <= 979: return \"i\"\n    \n\
    \    if number <= 979: return \"i\"\n    \n    if number <= 9", "    if number\
    \ > 1000 || number < 1 \n        error(\"Invalid number\")\n    else\n       \
    \ roman = String.empty\n        roman[Int(0)] = \"I\"\n        roman[Int(1)] =\
    \ \"V\"\n        roman[Int(2)] = \"X\"\n        roman[Int(3)] = \"L\"\n      \
    \  roman[Int(4)] = \"C\"\n        roman[Int(5)] = \"D\"\n        roman[Int(6)]\
    \ = \"M\"\n        roman[Int(7)] = \"M\"\n        roman[Int(8)] = \"C\"\n    \
    \    roman[Int(9)] = \"D\"\n        roman[Int(10)] = \"D\"\n        roman[Int(11)]\
    \ = \"C\"\n        roman[Int(12)] = \"L\"\n        roman[Int(13)] = \"X\"\n  \
    \      roman[Int(14)] = \"V\"\n        roman[Int(15)] = \"I\"\n        roman[Int(16)]\
    \ = \"I\"\n        roman[Int(17)] = \"X\"\n        roman[Int(18)] = \"V\"\n  \
    \      roman[Int(19)] = \"I\"\n        roman[Int(20)] = \"V\"\n        roman[Int(21)]\
    \ = \"X\"\n        roman[Int(22)] = \"L\"\n        roman[Int(23)] = \"C\"\n  \
    \      roman[Int(24)] = \"X\"\n        roman[Int(25)] = \"L\"\n        roman[Int(26)]\
    \ = \"C\"\n        roman[Int(27)] = \"X\"\n        roman[Int(28)] = \"V\"\n  \
    \      roman[Int(29)] = \"I\"\n        roman[Int(30)] = \"V\"\n        roman[Int(31)]\
    \ = \"I\"\n        roman[Int(32)] = \"X\"\n        roman[Int(33)] = \"L\"\n  \
    \      roman[Int(34)] = \"C\"\n        roman[Int(35)] = \"X\"\n        roman[Int(36)]\
    \ = \"V\"\n        roman[Int(37)] = \"I\"\n        roman[Int(38)] = \"V\"\n  \
    \      roman[Int(39)] = \"I\"\n        roman[Int(40)] = \"X\"\n        roman[Int(41)]\
    \ = \"L\"\n        roman[Int(42)] = \"C\"\n        roman[Int(43)] = \"X\"\n  \
    \      roman[Int(44)] = \"L\"\n        roman[Int(45)] = \"C\"\n        roman[Int(46)]\
    \ = \"X\"", "    roman = \"\"\n    if number < 1 || number > 1000\n        return\
    \ roman\n    roman = \"\"\n    if number >= 1000:\n        while number >= 1000\n\
    \            roman = roman + \"c\"\n            number -= 1000\n    if number\
    \ >= 500:\n        while number >= 500\n            roman = roman + \"l\"\n  \
    \          number -= 500\n    if number >= 100:\n        while number >= 100\n\
    \            roman = roman + \"x\"\n            number -= 100\n    if number >=\
    \ 20:\n        while number >= 20\n            roman = roman + \"i\"\n       \
    \     number -= 20\n    if number >= 10:\n        while number >= 10\n       \
    \     roman = roman + \"v\"\n            number -= 10\n    if number >= 5:\n \
    \       while number >= 5\n            roman = roman + \"l\"\n            number\
    \ -= 5\n    if number >= 2:\n        while number >= 2\n            roman = roman\
    \ + \"c\"\n            number -= 2\n    return roman\nend ", "    # Complete the\
    \ function\n    roman_int = [\"m\",\"d\",\"c\",\"l\"]\n    roman_num_dict = [1000,900,500,400,100,90,50,40,10,9,5,4,1]\n\
    \    roman_num_list = [str(x) for x in roman_num_dict]\n    roman_num_list = roman_num_list[roman_int]\n\
    \    roman_num_string = roman_num_list[number%1000]\n    return roman_num_string\n\
    end\n</cell>\n<code language=julia-1.1>\nmini_roman = int_to_mini_roman(19)\n\
    </cell>\n<code language=julia-1.1>\nmini_roman\n</cell>\n<code language=julia-1.1>",
  "    if (number == 0)\n    then \"0\"\n    else \n        string_of_roman_to_string(roman_num_to_string(number,\
    \ true))\n    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n</cell>\n\
    <code language=julia-1.5>\n@test int_to_mini_roman(19) == \"xix\"\n</cell>\n<code\
    \ language=julia-1.5>\n@test int_to_mini_roman(152) == \"clii\"\n</cell>\n<code\
    \ language=julia-1.5>\n@test int_to_mini_roman(426) == \"cdxxvi\"\n</cell>\n<text>\n\
    Part III: Implementing int_to_roman function", "    numstr = \"\"\n    if (number\
    \ >= 1) && (number <= 3999):\n        numstr = int_to_roman_num(number)\n    end\n\
    \    return numstr\nend", "    roman = \"\"\n    # Roman\n    if number <= 0:\
    \ return \"\"\n    roman = roman_conversion[number]\n    return roman\nend\n</cell>\n\
    <text>\nExercise 8\nWrite a function int_to_roman(string::String)::Int64 that\
    \ converts an integer number to a roman numeral, given a string.", "    if (number\
    \ <= 0 || number > 1000) \n        error(\"Number must be in the range of 1 to\
    \ 1000\")\n    mini_roman::String = \"\"\n    if number <= 3\n        mini_roman\
    \ = \"x\"\n    elseif number <= 6\n        mini_roman = \"xx\"\n    elseif number\
    \ <= 9\n        mini_roman = \"xxx\"\n    elseif number <= 12\n        mini_roman\
    \ = \"xl\"\n    elseif number <= 15\n        mini_roman = \"lx\"\n    elseif number\
    \ <= 18\n        mini_roman = \"xc\"\n    elseif number <= 21\n        mini_roman\
    \ = \"lc\"\n    elseif number <= 24\n        mini_roman = \"cc\"\n    elseif number\
    \ <= 27\n        mini_roman = \"ccc\"\n    elseif number <= 30\n        mini_roman\
    \ = \"cd\"\n    elseif number <= 33\n        mini_roman = \"ccd\"\n    elseif\
    \ number <= 36\n        mini_roman = \"cxx\"\n    elseif number <= 39\n      \
    \  mini_roman = \"ccc\"\n    elseif number <= 42\n        mini_roman = \"cdxx\"\
    \n    elseif number <= 45\n        mini_roman = \"ccc\"\n    elseif number <=\
    \ 48\n        mini_roman = \"ccc\"\n    elseif number <= 51 \n        mini_roman\
    \ = \"cdxx\"\n    elseif number <= 54 \n        mini_roman = \"cccd\"\n    elseif\
    \ number <= 57\n        mini_roman = \"ccc\"\n    elseif number <= 60\n      \
    \  mini_roman = \"ccc\"\n    elseif number <= 63\n        mini_roman = \"ccc\"\
    \n    elseif number <= 66\n        mini_roman = \"ccc\"\n    elseif number <=\
    \ 69\n        mini_roman = \"ccc\"\n    elseif number <= 72\n        mini_roman\
    \ = \"ccc\"\n    elseif number <= 75\n        mini_roman = \"ccc\"\n    elseif\
    \ number <= 78\n        mini_roman = \"ccc\"\n    elseif number <= 80\n      \
    \  mini_roman = \"ccc\"\n    elseif number <= 83\n        mini_roman = \"ccc\"\
    \n    elseif number <= 86\n        mini_roman = \"ccc\"\n    elseif number <=\
    \ 89\n        mini_roman = \"ccc\"\n    elseif number <= 92\n        mini_roman",
  "\"\"\"\n    Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    and return it in lowercase.\n    Restrictions: 1 <= num <= 1000",
  "    num2str::Int64 = number\n    let romanStrings::Vector{String} = [\"\",\"M\"\
    ,\"MM\",\"MMM\",\"MMMM\",\"MMMMM\"]\n    let romanStrings2::Vector{String} = [\"\
    \",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\",\"\"]\n  \
    \  let romanStrings3::Vector{String} = [\"\",\"\",\"X\",\"XX\",\"XXX\",\"XL\"\
    ,\"L\",\"LC\",\"LCC\",\"LCCC\",\"XC\",\"\"]\n    let romanStrings4::Vector{String}\
    \ = [\"\",\"\",\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\"\
    ,\"IX\",\"\"]\n    let romanStrings5::Vector{String} = [\"\",\"C\",\"CC\",\"CCC\"\
    ,\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\",\"\",\"\"]\n    let romanStrings6::Vector{String}\
    \ = [\"\",\"\",\"\",\"\",\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\"\
    ,\"VIII\",\"IX\",\"\",\"\"]\n    let romanStrings7::Vector{String} = [\"\",\"\"\
    ,\"\",\"\",\"\",\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\"\
    ,\"IX\",\"\",\"\",\"\"]\n    let romanStrings8::Vector{String} = [\"\",\"\",\"\
    \",\"\",\"\",\"\",\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\"\
    ,\"IX\",\"\",\"\",\"\",\"\"]\n    let romanStrings9::Vector{String} = [\"\",\"\
    \",\"\",\"\",\"\",\"\",\"\",\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\"\
    ,\"VIII\",\"IX\",\"\",\"\",\"\",\"\",\"\"]\n    let romanStrings10::Vector{String}\
    \ = [\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"I\",\"II\",\"III\",\"\
    IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\",\"\",\"\",\"\",\"\",\"\",\"\"]\n   \
    \ let romanStrings11::Vector{String} = [\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"\
    ,\"\",\"\",\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"\
    ,\"\",\"\",\"\",\"\",\"\",\"\",\"\"]\n    let romanStrings12::Vector{String} =\
    \ [\"\",\"\",\"\",\"\",\"\",\"\",", "    return roman_to_mini_roman(int_to_roman(number))\n\
    end", "    \"\"\"\n    \n    Inputs:\n    - number: an integer to convert to a\
    \ roman numeral\n    \n    Returns:\n    - a string representing a roman numeral\
    \ in lowercase\n    \n    Assumptions:\n    0 < number <= 1000\n    \"\"\"\n \
    \   if number == 0 \n        \n        \"0\"\n    else if number < 0 \n      \
    \  \n        \"0\"\n    else if number < 100\n        \n        \"x\"\n    else\
    \ if number < 400\n        \n        \"c\"\n    else if number < 900\n       \
    \ \n        \"m\"\n    else if number < 5000\n        \n        \"l\"\n    else\
    \ if number < 4000\n        \n        \"xl\"\n    else if number < 9000\n    \
    \    \n        \"xc\"\n    else if number < 5000\n        \n        \"xm\"\n \
    \   else if number < 4000\n        \n        \"lc\"\n    else if number < 9000\n\
    \        \n        \"cc\"\n    else if number < 5000\n        \n        \"cm\"\
    \n    else if number < 4000\n        \n        \"lc\"\n    else if number < 9000\n\
    \        \n        \"mcc\"\n    else if number < 5000\n        \n        \"mlc\"\
    \n    else if number < 4000\n        \n        \"xlc\"\n    else if number < 9000\n\
    \        \n        \"xcc\"\n    else if number < 5000\n        \n        \"xcm\"\
    \n    else if number < 4000\n        \n        \"xlc\"\n    else if number < 9000\n\
    \        \n        \"ccc\"\n    else if number < 5000\n        \n        \"cmc\"\
    \n    else if number < 4000\n        \n        \"lcc\"\n    else if number < 9000\n\
    \        \n        \"mccc\"\n    else if number < 5000\n        \n        \"mlcc\"\
    \n    else if number < 4000\n        \n        \"xlcc\"\n    else if number <\
    \ 9000\n        \n        \"xccc\"\n    else if number < 5000\n        \n    \
    \    \"xmcc\"\n    else if number < 4000\n        \n        \"xlcc\"\n    else\
    \ if number < 9000\n        \n        \"xccc\"\n    else if number < 5000\n  \
    \      \n        \"xmcc\"\n    else if number < 4000\n        \n        \"xlcc\"\
    \n    else if number < 9000\n        \n        \"xccc\"\n    else if number <\
    \ 5000\n        \n        \"xmcc\"\n    ", "    str = String(\"\")\n    int::Int64\
    \ = number\n    \n    if int == 0\n        return str\n    \n    if int > 999\n\
    \        str = int_to_mini_roman((int % 1000))\n        \n    else if int > 900\n\
    \        str = int_to_mini_roman((int % 100))\n        \n    else if int > 500\n\
    \        str = int_to_mini_roman((int % 10))\n        \n    else\n        if int\
    \ > 400\n            str = int_to_mini_roman((int % 5))\n            \n      \
    \  else\n            if int > 30\n                str = int_to_mini_roman((int\
    \ % 3))\n                \n            else\n                if int > 20\n   \
    \                 str = int_to_mini_roman((int % 2))\n                    \n \
    \               else\n                    if int > 10\n                      \
    \  str = int_to_mini_roman((int % 1))\n                        \n    str = str.capitalize\
    \ + str\n    return str\nend\n</cell>\n<code language=julia-1.6>", "    if number\
    \ <= 0\n        error(\"This function only takes positive integers.\")\n    else\
    \ if number == 1\n        return \"x\"\n    else if number <= 4\n        return\
    \ \"xix\"\n    else if number <= 9\n        return \"cli\"\n    else if number\
    \ <= 14\n        return \"clin\"\n    else if number <= 19\n        return \"\
    clii\"\n    else if number <= 24\n        return \"cdxx\"\n    else if number\
    \ <= 39\n        return \"cdl\"\n    else if number <= 44\n        return \"cdli\"\
    \n    else if number <= 49\n        return \"cdxxi\"\n    else if number <= 54\n\
    \        return \"cdlx\"\n    else if number <= 59\n        return \"cdlix\"\n\
    \    else if number <= 64\n        return \"cdxxx\"\n    else if number <= 74\n\
    \        return \"cdlxx\"\n    else if number <= 79\n        return \"cdlxix\"\
    \n    else if number <= 84\n        return \"cdxl\"\n    else if number <= 99\n\
    \        return \"cdlvi\"\n    else if number <= 101\n        return \"cdlv\"\n\
    \    else if number <= 121\n        return \"cdlvx\"\n    else if number <= 150\n\
    \        return \"cdlvxx\"\n    else if number <= 199\n        return \"cdlvix\"\
    \n    else if number <= 215\n        return \"cdlvxix\"\n    else if number <=\
    \ 231\n        return \"cdlxvi\"\n    else if number <= 245\n        return \"\
    cdlxvix\"\n    else if number <= 247\n        return \"cdlxxvi\"\n    else if\
    \ number <= 249\n        return \"cdlxxvix\"\n    else if number <= 251\n    \
    \    return \"cdlvixix\"\n    else if number <= 263\n        return \"cdlvxxvi\"\
    \n    else if number <= 265\n        return \"cdlvxxvix\"\n    else if number\
    \ <= 266\n        return \"cdlvvixix\"\n    else if number <= 267\n        return\
    \ \"cdlvxvixix\"\n    else if number <= 268\n        return \"cdlvixxvi\"\n  \
    \  else if number <= 269\n        return \"cdlvixxvix\"\n    else if number <=\
    \ 270\n        return \"cdlvivixix\"\n    else if number <= 271\n        return\
    \ \"cdlvixvixix\"\n    else if number <= 272\n        return \"cdlvixxvix\"\n\
    \    else if number <= 273\n        return \"cdlvixxvix", "    if number <= 0\
    \ || number >= 1000000 then return \"Error\" else\n        if number == 0 then\n\
    \            return \"x\" else \n            if number >= 1000 then\n        \
    \        return \"m\" + int_to_mini_roman(number/1000)\n            else\n   \
    \             ones = Int(math.floor(math.log(number, 1000)))\n               \
    \ tens = Int(number - Int(number/1000)*1000)\n                fives = Int(math.floor(number/1000))\n\
    \                if fives >= 1000 then\n                    return int_to_mini_roman(fives)\
    \ + \"cd\" + int_to_mini_roman(tens-fives)\n                else\n           \
    \         return int_to_mini_roman(fives) + \"c\" + int_to_mini_roman(tens-fives)\n\
    \            end\n        end\n    end\nend", "    if number < 1 || number > 1000\
    \ then \n        raise Exception(Exception.NotValidInput(\n            Messages.number_too_low(number)))\n\
    \    if number == 1 then \n        miniRoman = \"x\"\n    else \n        miniRoman\
    \ = \"\"\n        decToBin = Decimal_to_binary(number)\n        \n        for\
    \ i in decToBin\n            if i <> '0' then \n                miniRoman = miniRoman\
    \ + i\n            else \n                miniRoman = miniRoman + \"i\"\n    \
    \    end", "  num = number\n  if num < 1\n  else\n  case num < 1000 \n  of \n\
    \  1\n  when num == 1 \n  then \"I\" \n  when num == 2 \n  then \"II\" \n  when\
    \ num == 3 \n  then \"III\" \n  when num == 4 \n  then \"IV\" \n  when num ==\
    \ 5 \n  then \"V\" \n  when num == 6 \n  then \"VI\" \n  when num == 7 \n  then\
    \ \"VII\" \n  when num == 8 \n  then \"VIII\" \n  when num == 9 \n  then \"IX\"\
    \ \n  when num == 10 \n  then \"X\" \n  when num == 11 \n  then \"XI\" \n  when\
    \ num == 12 \n  then \"XII\" \n  when num == 13 \n  then \"XIII\" \n  when num\
    \ == 14 \n  then \"XIV\" \n  when num == 15 \n  then \"XV\" \n  when num == 16\
    \ \n  then \"XVI\" \n  when num == 17 \n  then \"XVII\" \n  when num == 18 \n\
    \  then \"XVIII\" \n  when num == 19 \n  then \"XIX\" \n  when num == 20 \n  then\
    \ \"XX\" \n  when num == 21 \n  then \"XXI\" \n  when num == 22 \n  then \"XXII\"\
    \ \n  when num == 23 \n  then \"XXIII\" \n  when num == 24 \n  then \"XXIV\" \n\
    \  when num == 25 \n  then \"XXV\" \n  when num == 26 \n  then \"XXVI\" \n  when\
    \ num == 27 \n  then \"XXVII\" \n  when num == 28 \n  then \"XXVIII\" \n  when\
    \ num == 29 \n  then \"XXIX\" \n  when num == 30 \n  then \"XXX\" \n  when num\
    \ == 31 \n  then \"XXXI\" \n  when num == 32 \n  then \"XXXII\" \n  when num ==\
    \ 33 \n  then \"XXXIII\" \n  when num == 34 \n  then \"XXXIV\" \n  when num ==\
    \ 35\n  then \"XXXV\"\n  when num == 36\n  then \"XXXVI\"\n  when num == 37\n\
    \  then \"XXXVII\"\n  when num == 38\n  then \"XXX", "    if number < 1 \n   \
    \     error \"Number must be positive, got $number\"\n    end", "    if number\
    \ > 1000 then return \"Error\" else \n    \n    roman = \n    \"\"\"\n    \n \
    \      xii  \n       xvi  \n       ci   \n       di   \n       vi   \n       vii\
    \  \n       xii  \n       ixvi  \n       xvii  \n       ixvi  \n       iivi  \n\
    \       iixv  \n       ixvi  \n       viii  \n       viix  \n       ixii  \n \
    \      iivi  \n       iixv  \n       ixvi  \n       iivi  \n       iixv  \n  \
    \     ixvi  \n       viii  \n       viix  \n       ixii  \n       iivi  \n   \
    \    iixv  \n       ixvi  \n       iivi  \n       iixv  \n       ixvi  \n    \
    \   iivi  \n       iixv  \n       ixvi  \n       iivi  \n       iixv  \n     \
    \  ixvi  \n       iivi  \n       iixv  \n       ixvi  \n       iivi  \n      \
    \ iixv  \n       ixvi  \n       iivi  \n       iixv  \n       ixvi  \n       iivi\
    \  \n       iixv  \n       ixvi  \n       iivi  \n       iixv  \n       ixvi \
    \ \n       iivi  \n       iixv  \n       ixvi  \n       iivi  \n       iixv  \n\
    \       ixvi  \n       iivi  \n       iixv  \n       ixvi  \n       iivi  \n \
    \      iixv  \n       ixvi  \n       iivi  \n       iixv  \n       ixvi  \n  \
    \     iivi  \n       iixv  \n       ixvi  \n       iivi  \n       iixv  \n   \
    \    ixvi  \n       iivi  \n       iixv  \n       ixvi  \n       iivi  \n    \
    \   iixv  \n       ixvi  \n       iivi  \n       iixv  \n       ixvi  \n     \
    \  iivi  \n       iixv  \n       ixvi  \n       iivi  \n       iixv  \n      \
    \ ixvi  \n       iivi  \n       iixv  \n       ixvi  \n       iivi  \n       iixv\
    \  \n       ", "    \n    digits = String[]\n    \n    if number == 0: \n    \
    \    return digits[0]\n        \n    digits = digits[:]\n    \n    digits.append(get_roman_number(number\
    \ % 10))\n    \n    return \"\".join(digits)\nend", "    \n    if number == 0\
    \ \n    then return \"0\"\n    else if number == 1 \n    then return \"x\"\n \
    \   else if number == 2 \n    then return \"c\"\n    else if number == 3 \n  \
    \  then return \"cc\"\n    else if number == 4 \n    then return \"ccc\"\n   \
    \ else if number == 5 \n    then return \"cccc\"\n    else if number == 6 \n \
    \   then return \"ccccc\"\n    else if number == 7 \n    then return \"cccccc\"\
    \n    else if number == 8 \n    then return \"cccccccc\"\n    else if number ==\
    \ 9 \n    then return \"ccccccccc\"\n    else if number == 10 \n    then return\
    \ \"cccccccccc\"\n    else if number == 11 \n    then return \"ccccccccccc\"\n\
    \    else if number == 12 \n    then return \"cccccccccccc\"\n    else if number\
    \ == 13 \n    then return \"ccccccccccccc\"\n    else if number == 14 \n    then\
    \ return \"cccccccccccccc\"\n    else if number == 15 \n    then return \"ccccccccccccccc\"\
    \n    else if number == 16 \n    then return \"ccccccccccccccc\"\n    else if\
    \ number == 17 \n    then return \"ccccccccccccccc\"\n    else if number == 18\
    \ \n    then return \"ccccccccccccccc\"\n    else if number == 19 \n    then return\
    \ \"ccccccccccccccc\"\n    else if number == 20 \n    then return \"ccccccccccccccc\"\
    \n    else if number == 21 \n    then return \"ccccccccccccccc\"\n    else if\
    \ number == 22 \n    then return \"ccccccccccccccc\"\n    else if number == 23\
    \ \n    then return \"ccccccccccccccc\"\n    else if number == 24 \n    then return\
    \ \"ccccccccccccccc\"\n    else if number == 25 \n    then return \"ccccccccccccccc\"\
    \n    else if number == 26 \n    then return \"ccccccccccccccc\"\n    else if\
    \ number == 27 \n    then return \"ccccccccccccccc\"\n    else if number == 28\
    \ \n    then return \"ccccccccccccccc\"\n    else if number == 29 \n    then return\
    \ \"ccccccccccccccc\"\n    else if number == 30 \n    then return \"ccccccccccccccc\"\
    \n    else if number == 31 \n    then return \"ccccccccccccccc\"\n    else ",
  "    int_to_mini_roman_helper(number, \"\")\nend", "    roman_numerals = [\"M\"\
    , \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"\
    IV\", \"I\"]\n    return roman_numerals[number%100] + int_to_mini_roman(number//100)\n\
    end\n</cell>\n<text>\nThe same function, written in Julia using the Julia language,\
    \ is as follows:"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
