name: HumanEval_49_modp
language: jl
prompt: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n \
  \   3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
  \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
  \ p::Int64)::Int64 \n"
tests: "using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5)\
  \ == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
  @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
  \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
completions: ["    if n == 0 || p == 0 || n == p || n < 0 || p < 0\n        throw(DomainError(\"\
    modp requires the parameters to be positive\"))\n    else\n        if n == 1\n\
    \            1\n        else\n            modp(n div 2, p) * (p % 2)\nend\n</cell>\n\
    <text>\nQ. How many integer factors of $x$ are less than $x$?\n Write your answer\
    \ as a function below.", "    if n == p then \n        1\n    else if n < p then\n\
    \        modp(divrem(n, p, p), p)\n    else\n        modp(divrem(p, n, n), p)\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Return x with y digits\
    \ after the decimal point.\n    >>> myround(3.141592)\n    3.142\n    >>> myround(3.141592,\
    \ 2)\n    3.14\n    >>> myround(3.141592, 3)\n    3.142\n    >>> myround(3.141592,\
    \ 4)\n    3.1416\n\"\"\"", "    if p == 1\n        1\n    elseif p == 2\n    \
    \    n\n    elseif p < 2\n        modp(div(n, p), p) \n    else\n        modp(div(n,\
    \ p), modp(div(n, p), p))\nend\n</cell>\n<code language=julia-1.6>", "    if n\
    \ <= 0 \n        then throw(ZeroDivisionError(\"integer division or modulo by\
    \ zero\"))\n    else if n == 0\n        then 1\n        else n / p\n    end\n\
    end\n\"\"\"\nModulo p (be aware of numerics).\nReturn n % p. \n\"\"\"", "    if\
    \ n <= 0 return 0 \n    if n>=p return p\n    mult = 1\n    i = p\n    while i\
    \ & 1 do \n        mult = mult*(n-i) \n        i /= 2\n    return mult\n\"\"\"\
    \n<|/ file source=github |>\n<| a |>\nFor large numbers you will need to use BigInt.\
    \ Unfortunately this is not available for Julia 1.0 so you will need to switch\
    \ to Julia 0.7.\nHere is how you do it with Julia 0.7:\n<code>\njulia> using BigInt",
  "    \"\"\"\nReturn the remainder of n modulo p.\n    \"\"\"\n    return n%p\n\"\
    \"\"\n### END HIDDEN CODE\n# END HIDDEN CODE\n\"\"\"\n### BEGIN HIDDEN CODE\n\
    # BEGIN HIDDEN CODE\n\"\"\"\nReturn p^n modulo p (be aware of numerics).\n>>>\
    \ modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n>>> modp(0, 101)\n1\n>>> modp(3, 11)\n\
    8\n>>> modp(100, 101)\n1\n\"\"\"", "    if n <= 0\n        return -1\n    return\
    \ p % n\nend \n</cell>\n<code language=julia-1.0>", "    |n>p && (n%p)==0\n  \
    \  else 0\n    end\n</code>\n<|/ a tags=julia,mod,performance |>\n<| a |>\nIn\
    \ Julia 1.5 you can use Base.mod:\n<code>\njulia> mod(1001, 101)\n1\n</code>\n\
    <|/ a dscore=5 tags=julia,mod,performance |>\n<| a tags=julia,mod,performance\
    \ |>\nIn Julia 1.5 Base.mod has been added as a function:\n<code>\njulia> Base.mod(1001,\
    \ 101)\n1\n</code>\n<|/ a dscore=4 |>\n<| a |>\nIf your \"numbers\" are big, you\
    \ may want to use Julia's BitArray instead of Int64:\n<code>\njulia> using BitArray",
  "    # Write your solution here\n    return 2^n%(p)\nend\n</cell>\n<code language=julia-0.6>\n\
    @test modp(8, 10)\n@test modp(100, 10)\n@test modp(1000, 10)\n@test modp(10000,\
    \ 10)\n@test modp(100000, 10)\n</cell>\n<code language=julia-0.6>\n\"\"\"Return\
    \ 2^(n//p) modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>>\
    \ modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n \
    \   8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "    modnum = ((p) *((p) *\
    \ (n - 1)) % p)\n    return (modnum % p) \nend", "    if p < 2 \n       return\
    \ 0\n    return ((n - 1) * (n - 2)) % (p - 1)\nend\n</cell>\n<text>\nLet's try\
    \ a larger example:", "\tif n < p \n\t\tthen return n \n\t\telse \n\t\t    return\
    \ modp(n-p, p)\n\tend\nend", "    |0> = p mod n\n    |1> = n - p\n    return 0>\n\
    \    end\n\"\"\"\nReturn p^e modulo p.\n    >>> modp(3, 5)\n    3\n    >>> modp(1101,\
    \ 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>>\
    \ modp(100, 101)\n    1\n\"\"\"", "    if p == 0 then return 0 \n    else if n\
    \ == 0 then return p\n    else if p < 0 then return modp(-n, p) \n    else if\
    \ n <= p then return modp(n - p, p) \n    else return modp(n, p % n)\nend \n</code>\n\
    It works for any n, as long as it's positive.\n<|/ a tags=math,recursion,mod,julia\
    \ |>\n<| c |>\nAs of julia 0.7 this will be in the stdlib `Base.mod(x::AbstractFloat,\
    \ modulus)`, but yeah this is more efficient.\n<|/ c |>\n<| c |>\nThanks for the\
    \ update and the solution. Just a quick question though: what is the reason behind\
    \ it returning the result as a `Int64` and not a regular `Int`? In other words,\
    \ why do I need to explicitly convert the result back to a `Int`?\n<|/ c |>\n\
    <| c |>\nBecause the result is going to be an `Int64` because that's what the\
    \ modulus is. It's a way to make it more efficient than `mod(x, modulus)` because\
    \ it doesn't have to do all the division work (it still does `div(modulus)` and\
    \ then truncates it).\n<|/ c |>\n<| c |>\nOh! I see. Thanks again!\n<|/ c |>\n\
    <| c |>\nIn Julia 1.0 you can just do `mod(x, modulus)`\n<|/ c |>\n<| a |>\nThe\
    \ way I did this was:\n<code>", "    if n < 0\n        error(\"modp: negative\
    \ argument\")\n    if n == 0\n        error(\"modp: division by zero\")\n    if\
    \ p == 0\n        error(\"modp: division by zero\")\n    if n % p == 0\n     \
    \   return n\n    return n % p\n\"\"\"", "    if n == 0 \n        then return\
    \ 1\n    else if n <= p \n        then return modp(n - 1, p) + 1 \n    else \n\
    \        modp(n - 1, p) \nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThank you,\
    \ I was trying to figure out why my code didn't work and I guess I forgot I needed\
    \ a base case for my recursive function.\n<|/ c |>\n<| c |>\nThis works, but it\
    \ doesn't do what you described. The `else` clause returns `modp(n - 1, p) + 1`,\
    \ which is wrong.\n<|/ c |>\n<| a tags=julia |>\nYour base case is wrong. It should\
    \ be:\n<code>", "    if n <= 0\n        0\n    elseif n == 1\n        p\n    elseif\
    \ p <= 0\n        modp(n - 1, p + 1)\n    else\n        modp(n - 1, p * 2 % p)\n\
    \    end\nend\n</code>\nAnd now the main function for the rest of the exercise:\n\
    <code>", "    if n < 0\n        error(\"n must be positive\")\n    else if p ==\
    \ 0\n        error(\"p must be non-zero\")\n    else if n < 0\n        error(\"\
    n must be positive\")\n    else if p <= 0\n        error(\"p must be positive\"\
    )\n    else if p <= 0\n        error(\"p must be positive\")\n    else if n <\
    \ 0\n        error(\"n must be positive\")\n    else if p == 0\n        error(\"\
    p must be non-zero\")\n    else if n == 0\n        error(\"n must be non-zero\"\
    )\n    else if n < p\n        error(\"n must be positive\")\n    else if n ==\
    \ 0\n        error(\"n must be non-zero\")\n    else if p <= 0\n        error(\"\
    p must be positive\")\n    else if p == 0\n        error(\"p must be non-zero\"\
    )\n    else if n == 0\n        error(\"n must be non-zero\")\n    else if p ==\
    \ 0\n        error(\"p must be non-zero\")\n    else if p > 0\n        error(\"\
    p must be positive\")\n    else if n == 0\n        error(\"n must be non-zero\"\
    )\n    else if n < p\n        error(\"n must be positive\")\n    else if n ==\
    \ 0\n        error(\"n must be non-zero\")\n    else if p < 0\n        error(\"\
    p must be positive\")\n    else if n == 0\n        error(\"n must be non-zero\"\
    )\n    else if n < p\n        error(\"n must be positive\")\n    else if n ==\
    \ 0\n        error(\"n must be non-zero\")\n    else if p < 0\n        error(\"\
    p must be positive\")\n    else if n == 0\n        error(\"n must be non-zero\"\
    )\n    else if n < p\n        error(\"n must be positive\")\n    else if n ==\
    \ 0\n        error(\"n must be non-zero\")\n    else if p < 0\n        error(\"\
    p must be positive\")\n    else if n == 0\n        error(\"n must be non-zero\"\
    )\n    else if n < p\n        error(\"n must be positive\")\n    else if n ==\
    \ 0\n        error(\"n must be non-zero\")\n    else if p < 0\n        error(\"\
    p must be positive\")\n    else if n == 0\n        error(\"n must be non-zero\"\
    )\n    else if n < p\n        error(\"n must be positive\")\n    else if n ==\
    \ 0\n        error(\"n must be non-zero\")\n    else if p < 0\n        error(\"\
    p must be positive\")\n    else if n == 0\n        error(\"n must be non-zero\"\
    )\n    else if n < p\n        error(\"n must be positive\")\n    else if n ==\
    \ 0\n        ", "    if n == 0 then return 1\n    if p == 0 then return 0\n  \
    \  if n <= p then return 1\n    \n    let div, mod = divmod((p * p + 7) / 3, n)\n\
    \    if mod == 0 then return n % (p * p / 3)\n    if mod > 0 then\n        return\
    \ n % ((p * p + 7) / 3)\n    else\n        return n % ((p * p - 7) / 3)\nend",
  "    | n < 0\n    = 1\n    | n < p\n    = n\n    | n >= p\n    = modp(n / p, p)\n\
    \    | otherwise\n    = modp(n / p, p) * p + n\nend\n</cell>\n<text>\nThe definition\
    \ of the mod2 function can be found here:", "    modind = if n <= p then 1 else\
    \ mod(n-p, p-1)\n    return modind\nend function \n\"\"\"\nmodp(n::Int64, p::Int64)::Int64\
    \ = ifelse(n <= p, 1, mod(n-p, p-1))\n</cell>\n<code language=julia-1.0>\n\"\"\
    \"\nGiven a number n and a prime p, compute all integers p > n\nsuch that p^n\
    \ mod p = 1.\n\"\"\"", "    if n < p then return n \n    return n % p", "    \n\
    \    if n < 0 \n    then return 0 \n    else if n % p == 0 \n    then return p\
    \ \n    else \n        return modp(n/p, p) \n    end\nend", "    if n == 0 \n\
    \        return 0 \n    else if (p < 1) \n        error \"p must be positive\"\
    \ \n    else \n        return ((n % p) + p) % p \n    end\nend\n</cell>\n<code\
    \ language=julia-1.1>\n\"\"\"Return the factorial of the number n.\n    >>> factorial(5)\n\
    \    120\n    >>> factorial(0)\n    1\n    >>> factorial(10)\n    3628800\n  \
    \  >>> factorial(10)^5\n    3628800\n    >>> factorial(7)\n    14\n    \"\"\"",
  "    if n == 0 \n        then return 0\n    else if n % p == 0 \n        then return\
    \ n // p\n        else return modp(n // p, p)\n    end\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 |>\nHere's a solution that is pretty similar to one I wrote.\
    \ The only difference is that I rewrote it using recursion (as I find recursion\
    \ more natural for this sort of problem) and I included some extra features like\
    \ error handling and a test to ensure a positive integer is input. \n<code>",
  "    if n == 0 \n        { return p }\n    else if p == 0 \n        { return 0 }\n\
    \    else if p == 1 \n        { return 1 }\n    else \n        { return n % p\
    \ }\nend\n</cell>\n<code language=julia-1.0>", "    if n <= 0 \n        then error(\"\
    n must be positive\")\n    else if p <= 0 \n        then error(\"p must be positive\"\
    )\n    else if p >= n \n        then error(\"p must be smaller than n\")\n   \
    \ else if n < 0 \n        then error(\"n must be positive\")\n    else if p ==\
    \ 1 \n        then error(\"p is 1\")\n    else if n == 0 \n        then error(\"\
    n is 0\")\n    else if p == 0 \n        then error(\"p is 0\")\n    else if n\
    \ == 1\n        then return 1\n    else if n == p\n        then return 1\n   \
    \ else if n >= p\n        then if n > p\n            then return n % p\n     \
    \       else return p % n\n        else if n < p\n            then return p %\
    \ n\n            else return n % p\n    end\nend", "    if (n > p) then modp(n,\
    \ p) else 1\n</code>\nmodp(100, 101)\n<code>\n101 // 100 = 5 => return 5\n</code>\n\
    modp(3, 11)\n<code>\n11 // 3 = 1 => return 1\n</code>\nmodp(1101, 101)\n<code>\n\
    101 // 1101 = 2 => return 2\n</code>\nmodp(3, 53)\n<code>\n53 // 3 = 0\n</code>\n\
    modp(1101, 100)\n<code>\n100 // 1101 = 2 => return 2\n</code>\nmodp(3, 53)\n<code>\n\
    53 // 3 = 1 => return 1\n</code>\nmodp(1101, 100)\n<code>\n100 // 1101 = 1 =>\
    \ return 1\n</code>\nmodp(3, 53)\n<code>\n53 // 3 = 1 => return 1\n</code>\nmodp(1101,\
    \ 100)\n<code>\n100 // 1101 = 1 => return 1\n</code>\nmodp(3, 53)\n<code>\n53\
    \ // 3 = 1 => return 1\n</code>\nmodp(1101, 100)\n<code>\n100 // 1101 = 1 => return\
    \ 1\n</code>\nmodp(3, 53)\n<code>\n53 // 3 = 1 => return 1\n</code>\nmodp(1101,\
    \ 100)\n<code>\n100 // 1101 = 1 => return 1\n</code>\nmodp(3, 53)\n<code>\n53\
    \ // 3 = 1 => return 1\n</code>\nmodp(1101, 100)\n<code>\n100 // 1101 = 1 => return\
    \ 1\n</code>\nmodp(3, 53)\n<code>\n53 // 3 = 1 => return 1\n</code>\nmodp(1101,\
    \ 100)\n<code>\n100 // 1101 = 1 => return 1\n</code>\nmodp(3, 53)\n<code>\n53\
    \ // 3 = 1 => return 1\n</code>\nmodp(1101, 100)\n<code>\n100 // 1101 = 1 => return\
    \ 1\n</code>\nmodp(3, 53)\n<code>\n53 // 3 = 1 => return 1\n</code>\nmodp(1101,\
    \ 100)\n<code>\n100 // 1101 = 1 => return 1\n</code>\nmodp(3, 53)\n<code>\n53\
    \ // 3 = 1 => return 1\n</code>\nmodp(1101, 100)\n<code>\n100 // 1101 = 1 => return\
    \ 1\n</code>\nmodp(3, 53)\n<code>\n53 // 3 = 1 => return 1\n</code>\nmodp(1101,\
    \ 100)\n<code>\n100 // 1101 = 1 => return 1\n</code>\nmodp(3, 53)\n<code>\n53\
    \ // 3 = 1 => return 1\n</code>\nmodp(1101, 100)\n", "    if p == 0 \n       \
    \ n >= 0 ? p : n % p\n    else\n        modp(n / p, p)\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| a dscore=2 tags=julia |>\n<code>", "    if n <= p || n < 0 || p < 0\n\
    \        error(\"modp($n, $p) bad args\")\n    elseif n < 1\n        return n\n\
    \    else if n % p == 0\n        return p\n    else\n        return n % p\nend\n\
    </cell>\n<text>\nLarge primes\nNow we define primes using this simple algorithm",
  "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "    if n==0\n     \
    \   then return p\n    else if n==1\n        then return 1\n    else \n      \
    \  if p==0\n            then return 0\n        elif n==p\n            then return\
    \ 1\n        else return modp(n-1, p) % p\n    end\nend\n</code>\n<|/ a dscore=2\
    \ tags=julia |>\n<| a dscore=2 |>\nThe question asks about \"modular\" exponentiation\
    \ (where n is always positive), but the answer provided is \"non-modular\" exponentiation\
    \ (where n is always negative).\nAs a general algorithm for modular exponentiation\
    \ in Julia, see the Wikipedia article Modular exponentiation, and see the Wikipedia\
    \ article Non-modular exponentiation.  Julia's BigInteger package has both algorithms.\n\
    In Julia, the BigInt package has a function modpow() that performs a modular exponentiation,\
    \ but unfortunately the function only works for positive exponents.\n<|/ a tags=julia\
    \ |>\n<| a |>\nA similar recursive function that would work on both positive and\
    \ negative exponents.\n<code>", "    if n % p != 0 \n        then return n % p\
    \ \n        else return modp(n/p, p)\n    end\nend\n</code>\n<|/ a tags=math,julia\
    \ dscore=4 |>\n<| c |>\nWhat do you mean? I used the definition of modp that says\
    \ \"return n mod p\", which is modulo division.\n<|/ c |>\n<| c |>\nI think you're\
    \ mixing up modulo and division. In `modp(1101, 101)` 1101 is not divisible by\
    \ 101, so 1101 isn't divisible by any number in [101, 101, 101, ..., 101] (the\
    \ second argument). `modp` returns the remainder of the division.\n<|/ c |>\n\
    <| c |>\nAh, thank you. I was so focused on the definition of modp that I overlooked\
    \ the fact that 1101 % 101 = 9. Still, I'll try to figure out how to implement\
    \ the modular inverse then.\n<|/ c |>\n<| a dscore=3 |>\nThis has already been\
    \ answered, but I thought I would post an answer to this old thread anyway for\
    \ completeness.\nThe package https://github.com/leibom/mod_inverse.jl is a Julia\
    \ package providing the algorithm that OP was interested in.\nHere's an example\
    \ of how to use it:\n<code>\njulia> using ModInverse", "    if n<0\n        error(\"\
    modp: negative number\")\n    else if n==0\n        1\n    else if n>p\n     \
    \   error(\"modp: too large number\")\n    else\n        modp(n - 1, p) % p\n\
    end\n</cell>\n<code language=julia-0.5>\n\"\"\"Return nth prime number for given\
    \ p and n.\"\"\"", "    if n == 0 \n        then return 0\n    else if n%p \n\
    \        then return modp(floor(n/p), p)\n        else return modp(n/p, p)", " \
    \   if n < 0 or n >= p then return n\n    else if n == 0 then return 0\n    else\
    \ if n % p == 0 then return n\n    else return modp(n / p, p)\nend\n</cell>\n\
    <code language=julia-0.6>", "    if p % n == 0\n        return p % n\n    else\n\
    \        return modp(n, p % n)\n    end\nend", "    if n <= p \n        then n\
    \ \n    else if p < 0 \n        then 0 else n % p\n    end \nend\n\"\"\"Return\
    \ n modulo p where n is an Int and p is an Int64 (be aware of numerics)\n    >>>\
    \ modp(100, 2)\n    10\n    >>> modp(100, -2)\n    0\n    >>> modp(101, 2)\n \
    \   1\n    >>> modp(3, 11)\n    8\n    >>> modp(3, -2)\n    3\n    \"\"\"", " \
    \   if n < 0 \n        error(\"modp($n, $p) called with negative integers\")\n\
    \    if n < p\n        error(\"modp($n, $p) called with $n < $p\")\n    return\
    \ p^n - 1", '  modp_(n shl 2, p) ', "if n <= p return n \nelse return modp(n div\
    \ p, p) \nend \n\"\"\"Return n to the power of m (be aware of numerics).\n   \
    \ >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n\"\"\"", " \
    \   if p == 0 \n        then return 0\n    else if n <= p \n        then return\
    \ p\n    else\n        mod p n = p + mod(mod(n-p,p),p)\n    end\nend", "    if\
    \ n%p == 0 || n < 0 || p < 0\n        0\n    elseif p == 0\n        n\n    elseif\
    \ n < p\n        0\n    elseif n > p\n        n\n    else\n        modp(modp(n/p,p),p)\n\
    end\n</cell>\n<code language=julia-1.3>\n\"\"\"Return the least common multiple\
    \ of n and p.\n    >>> modp(100, 101)\n    101\n    >>> modp(100, 102)\n    100\n\
    \    >>> modp(100, 0)\n    0\n    >>> modp(101, 0)\n    1\n    >>> modp(101, -1)\n\
    \    1\n    >>> modp(0, -1)\n    1\n    >>> modp(0, 0)\n    0\n\"\"\"", "    if\
    \ n == 0 \n        then return 1\n    else if p < 0 \n        then return 1\n\
    \        else return modp(n shl 1, p-1)\nend\n</code>\n<|/ a dscore=3 |>\n<| c\
    \ |>\nYou can replace the `if` with a `return modp(n shl 1, p-1)` if you don't\
    \ need the second case anywhere else. Also you don't need to `return 1` at the\
    \ end of the function, since `modp(n shl 1, p-1)` will return a negative number\
    \ if `n` is negative and `modp(n shl 1, p-1)` will return a positive number if\
    \ `n` is positive.\n<|/ c |>\n<| c |>\n: I wouldn't do that.  I was trying to\
    \ give the logic as clearly as possible but that is a good point that I have left\
    \ out in my answer.\n<|/ c |>\n<| c |>\nYour implementation is incorrect: it does\
    \ not handle negative `n` well. Consider `modp(10, 3)`.\n<|/ c |>\n<| c |>\n:\
    \ Thanks for pointing that out.  I believe I have corrected my implementation\
    \ now.\n<|/ c |>\n<| c |>\nI actually think your solution is better than my own,\
    \ but it's missing a small detail that the function should never be called with\
    \ a negative `n`.  Thus the \"else\" branch is missing.  I believe that should\
    \ be \"return modp(n shl 1, p-1)\".  Then it should be fixed in both places.\n\
    <|/ c |>\n<| a |>\nMy answer is based on Ramon's answer. \n<code>", "</code>\n\
    <|/ a |>\n<| c |>\nFor me, the solution is `modp(2**n, p)`.\n<|/ c |>\n<| a |>\n\
    Just to add to the existing answers, I thought I'd share my version since I was\
    \ struggling with the accepted answer for some time before I realized that the\
    \ problem is with Int.\n<code>\nimport Data.List\nimport Data.Maybe", "    if\
    \ p == 0 return 0\n    else if n < 0 return ((modp(-n, p))*(-n))%p\n    else return\
    \ ((mod(n, p))*modp(n, p-1))%p\nend\n</cell>\n<code language=julia-1.0>", "  \
    \  \"\"\"\n    >>> modp(4, 5)\n    3\n    \"\"\"", "    if p == 0\n    then n\n\
    \    elseif p == 1 && n <= 0\n    then 1\n    else\n        modp(n / p, p) % p\n\
    \    end\nend\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3 |>\nWe can use the fact\
    \ that mod operator can be written as follows:\n<code>\nmod a\n</code>\nas\n<code>\n\
    a * ((a - 1) % a)\n</code>\nSo the whole function can be written as simple as\
    \ that:\n<code>", "    if n <= p\n        then return n \n        -- else\n  \
    \      then return modp(p, n-p) \n        -- end if\n    else \n        then return\
    \ modp(p - 1, n) \n        -- end if\n    end if\nend ", "    q = modn(n, p)\n\
    \    if q == p\n        return n\n    else\n        return p^(q*q)\nend\n\"\"\"\
    \n    modn(n::Int64, p::Int64)", "    if n >= p then\n        return n\n    else\n\
    \        return modp(n - p, p)\n    end \nend", "    if n < 0 || p < 0\n    then\
    \ return 0\n    else if n < p\n    then return n % p\n    else return mod(n-p,p)\n\
    end", "    if p < 0 or p > 2147483647\n        throw(DomainError(\"p must be in\
    \ [0, 2^32-1]\"))\n    elseif n <= 0\n        throw(DomainError(\"n must be positive\"\
    ))\n    elseif n == 0\n        throw(DomainError(\"n must be positive\"))\n  \
    \  else\n        return modp(n - 1, p) * (p - 1) ^ (n - 1)", "    if n%p == 0\
    \ && n > 0 && p > 0 \n        then modp(n/p, p)\n        else p\n    end\nend",
  "    if n == 0\n        1\n    else if n <= p\n        n\n    else\n        modp(n\
    \ % p, p) + 1\nend \n</cell>\n<code language=julia-1.5>", "    | n < 0 = throw(DomainError(string(\"\
    modp received negative number\")))\n    | n < p = throw(DomainError(string(\"\
    modp received less than positive number\")))\n    | n >= p = throw(DomainError(string(\"\
    modp received number too large\")))\n    | otherwise = log2p(n::Int64) %% p\n\
    end", "\"\"\"\n    modulus\n    \n\"\"\"\n    modp(n::Int64, p::Int64)::Int64\n\
    \    \nReturn the integer p such that 2**n modulo is p and the remainder is 0\n\
    \"\"\"\n    if n == 1 \n        p \n    else if p == 0 \n        n\n    else \n\
    \        modp(n - 1, p) \nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\n  \
    \  modpow\n    \nMultiply the number n by the number p and return the result modulo\
    \ p.\n\"\"\"", "    if (n <= p) \n        then n \n    else modp(p, n) \nend \n\
    \"\"\"\n\"\"\"\n    mod2(n::Int64, p::Int64)::Int64 \n    Return a mod p of n\
    \ in base 2.\n    >>> mod2(1, 1)\n    1\n    >>> mod2(4, 6)\n    2\n    >>> mod2(-1,\
    \ 6)\n    1\n    >>> mod2(1, -1)\n    1\n    >>> mod2(4, -6)\n    2\n    >>> mod2(-1,\
    \ -6)\n    1\n    >>> mod2(1, 2)\n    2\n    >>> mod2(1, 3)\n    0\n    >>> mod2(4,\
    \ -3)\n    2\n    >>> mod2(7, -1)\n    1\n    >>> mod2(3, -1)\n    0\n    >>>\
    \ mod2(8, 1)\n    2\n    >>> mod2(3, 2)\n    0\n    >>> mod2(3, 4)\n    0\n  \
    \  >>> mod2(8, 3)\n    2\n    >>> mod2(9, 3)\n    0\n    >>> mod2(8, 4)\n    2\n\
    \    >>> mod2(9, 4)\n    0\n    >>> mod2(8, 5)\n    0\n    >>> mod2(8, 6)\n  \
    \  0\n    >>> mod2(-12, 1)\n    1\n    >>> mod2(-11, -2)\n    1\n    >>> mod2(-1,\
    \ -2)\n    1\n    >>> mod2(2, 3)\n    0\n    >>> mod2(-4, 5)\n    -2\n    >>>\
    \ mod2(3, 6)\n    0\n    >>> mod2(3, 7)\n    0\n    >>> mod2(0, 7)\n    1\n  \
    \  >>> mod2(1, 1)\n    0\n    >>> mod2(3, 8)\n    0\n    >>> mod2(4, 8)\n    2\n\
    \    >>> mod2(1, 9)\n    0\n    >>> mod2(2, 9)\n    0\n    >>> mod2(-1, 9)\n \
    \   1\n    >>> mod2(5, 9)\n    2\n    >>> mod2(-3, 9)\n    -2\n    >>> mod2(6,\
    \ 10)\n    0\n    >>> mod2(-5, -9)\n    -2\n    >>> mod2(-6, -9)\n    -2\n   \
    \ >>> mod2(6, -10)\n    0\n    >>> mod2(-1, -10)\n    1\n    >>> mod2(-1, 11)\n\
    \    1\n    >>> mod2(4, 8)\n    0\n    >>> mod2(0, 8)\n    0\n    >>> mod2(3,\
    \ -1)\n    0\n    >>> mod2(-4, -5)\n    2\n    >>> mod2(-5, -3)\n    2\n    >>>\
    \ mod2(6, -6)\n    0\n    >>> mod2(-5, -6)\n    2\n    >>> mod2(-6, -5)\n    2\n\
    \    >>> mod2(-6, 11)\n    2\n    >>> mod2(-6, -9)\n    2\n    >>> mod2(-6, -10)\n\
    \    2\n    >>> mod2(-6, -10)", "    if p == 0 \n        then return n \n    \
    \    else if n == 0 \n            then return 1\n            else if n == p \n\
    \                then return 0\n                else return modp(n - 1, p) + 1\n\
    \    end\nend \n</cell>\n<code language=julia-1.4>", "    if n > p \n        then\
    \ (n - p) \n    else if (n == p) \n        then 1 \n        else (modp(n - p,\
    \ p))\n    else 0\nend\n</cell>\n<text>\nModular exponentiation", "    if (n >=\
    \ p) == true \n        then return n \n        else return n `mod` p \n    end\n\
    \    return 1\nend\n</cell>\n<code language=julia-0.6>", "    return n & (-p)\
    \ \nend\n</cell>\n<text>\nWe can now easily compute the modular power $\\mu^q$\
    \ of the prime $p$ by applying the GMP function (gmp_pow), which takes a nonnegative\
    \ integer $n$ and a prime $p$ and computes $p^n$ modulo p:", "    return (n %\
    \ p == 0 and n or 0) + 1\nend function \n</code>\nand here is code with if/else\
    \ if and recursive function\n<code>", "    if p < 0 then return p else n - (n\
    \ % p) \n    return n % p ", "    if(p == 0)\n        return 0\n    else\n   \
    \     q = n % p\n        if q == 0 && p != 2\n            return 1\n        else\n\
    \            return modp(q, p)\nend\n</cell>\n<text>\nModular Arithmetic", " \
    \   if n%p == 0 \n        return n \n    else \n        return modp(n//p, p) \n\
    end ", "    if n <= p % 2 == 0\n        then return n\n        else return n-p+1\n\
    \    end\nend", "    if p==0 then return 1 else return (n%p)\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"Return 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n\"\"\"", " \
    \   if n == 0 then \n        return 1\n    if n == 1 then \n        if p % 2 ==\
    \ 0 then \n            return 1\n        else \n            return 0\n    else\
    \ \n        if p % 2 == 0 then \n            return modp(n - 1, p) // p\n    \
    \    else \n            return modp((n - 1) % p, p) // p\nend \n</code>\n<|/ a\
    \ tags=math,python,algorithm,modular |>\n<| c |>\nThis does not work. `modp(10,\
    \ 11)` returns 1, when it should return 3.\n<|/ c |>\n<| a tags=math,python,algorithm,modular\
    \ |>\nModular exponentiation: \n<code>\ndef modpow(x, n, p):\n    \"\"\"\n   \
    \ http://en.wikipedia.org/wiki/Modular_exponentiation", "    if n == 0\n     \
    \   return p\n    if n <= p\n        return modp(n - 1, p) % p\n    elseif n <\
    \ p\n        return modp(n + (p - 1), p) % p\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Return n modulo m (be aware of numerics).\n    >>> modm(3, 5)\n    3\n \
    \   >>> modm(1101, 101)\n    2\n    >>> modm(0, 101)\n    1\n    >>> modm(3, 11)\n\
    \    8\n    >>> modm(100, 101)\n    1\n    \"\"\"", "    |= (p%(n::Int64))*(n::Int64)\
    \ \n    |= p%(n::Int64)\n    |= p%((n%p)*(n%p))\n    |= p%(n::Int64) % p\n   \
    \ |= p%(n::Int64) % p\n    |= p%((n%p)*(n%p))\n    |= p%(n::Int64) % p\n    |=\
    \ p%((n%p)*(n%p))\n    |= p%(n::Int64) % p\n    |= p%(n::Int64) % p\n    |= p%((n%p)*(n%p))\n\
    \    |= p%(n::Int64) % p\n    |= p%(n::Int64) % p\n    |= p%((n%p)*(n%p))\n  \
    \  |= p%(n::Int64) % p\n    |= p%(n::Int64) % p\n    |= p%((n%p)*(n%p))\n    |=\
    \ p%(n::Int64) % p\n    |= p%(n::Int64) % p\n    |= p%((n%p)*(n%p))\n    |= p%(n::Int64)\
    \ % p\n    |= p%(n::Int64) % p\n    |= p%((n%p)*(n%p))\n    |= p%(n::Int64) %\
    \ p\n    |= p%(n::Int64) % p\n    |= p%((n%p)*(n%p))\n    |= p%(n::Int64) % p\n\
    \    |= p%(n::Int64) % p\n    |= p%((n%p)*(n%p))\n    |= p%(n::Int64) % p\n  \
    \  |= p%(n::Int64) % p\n    |= p%((n%p)*(n%p))\n    |= p%(n::Int64) % p\n    |=\
    \ p%(n::Int64) % p\n    |= p%((n%p)*(n%p))\n    |= p%(n::Int64) % p\n    |= p%(n::Int64)\
    \ % p\n    |= p%((n%p)*(n%p))\n    |= p%(n::Int64) % p\n    |= p%(n::Int64) %\
    \ p\n    |= p%((n%p)*(n%p))\n    |= p%(n::Int64) % p\n    |= p%(n::Int64) % p\n\
    \    |= p%((n%p)*", "    | n % p != 0::Int64\n    | n==p = 1\n    | n>p = 0\n\
    \    | otherwise = n mod p\nend\n</cell>\n<text>\nThe main purpose of this function\
    \ is to find an approximation of $2^n$ modulo p (be aware of numerics).", "  \
    \  if n < 0 \n        return 0 \n    if n % p > 0 \n        return 0 \n    if\
    \ n % p == 0 \n        return p \n    return p ", "    return ((n - 1) * (n -\
    \ 1)) rem p\nend\n</cell>\n<code language=julia-1.0>", "    if n < p then return\
    \ 1\n    if n > p then return 0\n    if n == p then return n\n    else if n %\
    \ p == 0 then return n / p\n       else return modp(n / p, p)\n</code>\n<|/ a\
    \ tags=primes,algorithm,prime-factoring |>\n<| c |>\nIt's also worth noting that\
    \ this implementation will not find composites up to 2^(n+p) - 1 but rather up\
    \ to 2^(n+p) which may be an issue when you are trying to find the largest number\
    \ that is a power of 2 with primes > 2^(n+p).\n<|/ c |>\n<| a dscore=1 |>\nI think\
    \ this can be done with Sieve of Eratosthenes, this algorithm is a fast Sieve\
    \ of Eratosthenes for finding a prime number until a number smaller than a given\
    \ number. The complexity of this algorithm is O(sqrt(n)), where n is the given\
    \ number less than which we want to find the prime number.\nThe Sieve of Eratosthenes\
    \ works like this: we divide the number n into a number of subsets of prime numbers.\
    \ When n is prime, we add it to the set. When n is not prime, we divide the remaining\
    \ number by all numbers that we know are prime.\nLet's take an example to clarify\
    \ the idea.\nIf n = 10\nWe know that n is prime since it has a factor 2.\nThe\
    \ set consists of {2}, {3,4} and {5}\nThen we divide the remaining number by all\
    \ numbers in the set\nSo (10 / {2, 3,4, 5} = 3)\nNow we have to check if 3 is\
    \ a prime number\nSince 3 is a prime number, we add it to the set\nThe set now\
    \ consists of {2,3,4}, {5,6} and {7}\nWe continue the process until we reach the\
    \ number less than n\nNow the set consists of {2,3,4}, {5,6,7}\nNow, since 10\
    \ is a prime number, we add it to the set\nThe set now consists of {2,3,4}, {5,6,7},\
    \ {8}\nThe process continues until we reach the number less than n\nThe set consists\
    \ of {2,3,4}, {5,6,7}, {8}, {9}\nNow since 10 is a prime number, we add it to\
    \ the set\nThe set now consists of {2,3,4}, {5,6,7}, {8}, {9}, {10}\nSo (10 /\
    \ {2,3,4,5,6,7,8,9} = 3)\nSo the final result is 3.\n<|/ a tags=primes,algorithm,prime-factoring\
    \ |>\n<| a dscore=0 |>\nI assume you are trying to ", "    if n < 0\n    then\
    \ return 1\n    else if n == 0\n    then return 0\n    else return mod(n, p)\n\
    end", "\"\"\"\n    \n# Return 2^n modulo p (be aware of numerics).", "\"\"\"\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"",
  "    local i = n\n    if i < 0 \n        then return 0 \n        else return (p\
    \ - 1) * (n % p) \n    end\nend\n</cell>\n<text>\nTests\nWe are going to test\
    \ the modp function by using the following cases:", "    if n == 0\n        0\n\
    \    else if p == 0\n        n\n    elseif p < 0\n        modp(abs(n), abs(p))\n\
    \    else\n        modp(n/p, p)\nend\n\"\"\"\nReturn the GCD of two numbers\n\
    If both numbers are 0 or both are negative, return zero.\n\"\"\"", "    if n <\
    \ 0 \n        error(\"modp(): n must be nonnegative\")\n    n & (n ^ p)\nend",
  "  if n == 1\n    return p\n  else\n    return (n % p + p) % p", "    if p == 0\
    \ \n        then return n \n        else return modp(n / 2, p) \nend\n</code>\n\
    Note that this implementation is O(log n), which means it scales much better in\
    \ practice.\n<|/ a dscore=3 |>\n<| c |>\nYour implementation is correct, but this\
    \ one is O(1) in Big O Notation.\n<|/ c |>\n<| a tags=algorithm,modulo,math,mathematical-optimization,numbers\
    \ |>\nThe accepted answer works, but it calculates p**n multiple times. We can\
    \ save time by calculating the power once and then using the fact that n! = n\
    \ raised to the power n. \n<code>", "    modval = (mod((p-1)^n+(p-1)^n, p) - 1)\n\
    \    return modval % p\nend", "    if n % p == 0 then return n else return modp(n\
    \ / p, p)\nend\n\"\"\"Return x^2 in base p.\n    >>> modp(3, 5)\n    9\n    >>>\
    \ modp(1101, 101)\n    1010\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n\
    \    18\n    >>> modp(100, 101)\n    1\n    \"\"\"", "    if p*n == 0 \n     \
    \   then 0\n        else modp(p - n + 1, p) \n    end\nend\n</cell>\n<code language=julia-1.0>",
  "    if n == 0 then \n        return 1 \n    else if n % p == 0 \n        then return\
    \ n \n        else return modp(n / p, p) \nend", "    if p < 0 \n        error(\"\
    modp: p is negative\")\n    \n    if n == 0 \n        return n\n    \n    if n\
    \ == 1 \n        return p\n    \n    if n <= p \n        return modp(n - 1, p)\
    \ \n    \n    return (n % p) + p\nend", "    if n == 0\n        return 1 \n  \
    \  else if p == 0\n        return 0 \n    else \n        return (modp(n % p, p))\n\
    end", "    if n == 0 || p == 0 \n        then return 0\n    else if n > 0\n  \
    \      then return ((p + modp(n-1, p))*((modp(n-1, p) + modp(n-2, p))*(modp(n-2,\
    \ p) + modp(n-3, p)))\n    else return 0\nend\n</code>\n<|/ a dscore=3 |>\n<|\
    \ a |>\nThe algorithm is pretty simple.\nFirst we find the greatest common divisor\
    \ of the two numbers then we use the formula to calculate the next power of 2.\n\
    <code>", "    if n % p == 0 then return n\n    else return modp(n//p, p) \nend ",
  "    if n == 0\n    then return p\n    else if n < 0\n    then return mod(n, p)\n\
    \    else if p < 0\n    then return -1 * mod(-n, p)\n    else if p > p * p\n \
    \   then return 0\n    else return (n % p + p - 1) % p\nend\n</cell>\n<code language=julia-0.5>\n\
    \"\"\"\n    modm(n::Int64, m::Int64)", "    if n < 0 | p < 0 \n        error(\"\
    mod: n and p must be positive\")\n    end\n    if n == 0 | p == 0 \n        1\n\
    \    end\n    modpow2 = modpow(n-2, p)\n    return (modpow2 * (modpow2 * p - 1))\
    \ % p\nend\n</cell>\n<code language=julia-0.6>", "    if n == 0\n    then return\
    \ p\n    else return modp(n - 1, p) + p\n    end\n\"\"\"\n``modp``", "    \"\"\
    \"\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0,\
    \ 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n   \
    \ \"\"\"\n    return ((n - 1) * p) % p", "    \"\"\"Modulus of p and 2^n.\n  \
    \  >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    \    if p == 0: return 1\n    if n == 0: return 0\n    if n <= p: \n        return\
    \ modp(n - 1, p) \n    else: \n        return modp((p - 1) * (n >> 1), p) \n\"\
    \"\"\nReturn n / 2^k modulo p.\n>>> modp(4, 3)\n1\n>>> modp(4, 15)\n2\n>>> modp(8,\
    \ 15)\n0\n>>> modp(8, 31)\n1\n\"\"\"", "    \"\"\"modp(n::Int64, p::Int64)::Int64\"\
    \"\"\n    return ((n & (p-1)) ^ n) & p\n</code>\nI decided to use an anonymous\
    \ function so you can see the function name in the traceback. This is the equivalent\
    \ of doing this:\n<code>", "    if n == p then return n \n    if n < p then return\
    \ modp(n - p, p)\n    if n > p then return modp(n, p - n)\nend", '    """Calculate
    mod power of number', "\tif n == 0 then\n\t\t1\n\telse\n\t\tmodp(n mod p, p) +\
    \ 1\n\tend\nend\n\"\"\"Return x^y mod p (be aware of numerics).\n    >>> modp(2,\
    \ 12)\n    6\n    >>> modp(2, 101)\n    1\n    >>> modp(1, 101)\n    1\n    >>>\
    \ modp(-2, 12)\n    -6\n    >>> modp(-2, 101)\n    -1\n    >>> modp(-2, -1)\n\
    \    -2\n    >>> modp(-1, -1)\n    0\n    >>> modp(-2, -2)\n    0\n    \"\"\"",
  "    if p == 0 then\n        1\n    elseif n <= p then\n        n\n    else\n  \
    \      p + modp(n-p,p)\n    end\nend\n</cell>\n<code language=julia-1.5>\n@code_native\
    \ modp(p::Int64, q::Int64)\n</cell>\n<code language=julia-1.5>\n\"\"\"Return the\
    \ greatest common divisor of p and q, i.e. GCD(q, p).\nIf q is 0, then GCD(p,\
    \ q) = 1 (same as q).\nThis function uses Euclid's algorithm. If q is smaller\
    \ than p, then\ngcd(0, p) = p, and gcd(0, q) = 0.\n\"\"\"", "    if n < 0 \n \
    \       error(\"modp expected a positive number\", 2)\n    \n    if n < p \n \
    \       error(\"modp expected a number greater than or equal to the divisor\"\
    , 2)\n    \n    if n == 0\n        1\n    \n    if n < p \n        error(\"modp\
    \ expected a number less than or equal to the divisor\", 2)\n    \n    if n <=\
    \ 0\n        error(\"modp expected a positive number\", 2)", "    if n == 0 \n\
    \        then 1\n    else n % p\n</code>\n<|/ a |>\n<| a tags=modulo,haskell,algorithm\
    \ |>\nThe Haskell solution would be to define a new function:\n<code>\nmod' n\
    \ p = n `mod` p\n</code>\nHowever, this would be more efficient if you had a library\
    \ that had already defined it.\n<|/ a dscore=5 |>\n<| c |>\nNot sure why this\
    \ was downvoted, but `mod` can actually be implemented as a combination of `div`\
    \ and `mod` as well.\n<|/ c |>\n<| c |>\nI guess that would be an improvement...\
    \ but I don't see how that would make it more efficient.\n<|/ c |>\n<| c |>\n\
    : It would be more efficient than `n \\`mod\\` p` because it avoids an integer\
    \ division.\n<|/ c |>\n<| c |>\n: And it also avoids any unnecessary integer arithmetic\
    \ which may occur if you use an explicit `div` with a negative denominator, since\
    \ `div` would then involve rounding down.\n<|/ c |>\n<| c |>\n: I believe I should\
    \ have been clearer: it's not more efficient, it's more correct. With explicit\
    \ `div`, you get `div` with rounding down unless you use `round`.\n<|/ c |>\n\
    <| a tags=modulo,haskell,algorithm |>\nI recommend using div and mod since they\
    \ are both standard and efficient. Using div and mod will make your code more\
    \ readable and easier to understand, since you won't get confused by type annotations.\n\
    <|/ a dscore=4 |>\n<| c |>\nYeah, I didn't think of that!\n<|/ c |>\n<| c |>\n\
    But note that when `n` is a very big number `p`, using `div` will use less memory\
    \ than `mod`. [This benchmark](https://stackoverflow.com/questions/10449111/which-is-faster-div-or-mod)\
    \ shows that `div` uses less memory than `mod`.\n<|/ c |>\n<| a dscore=4 |>\n\
    A lot of people are saying \"use div and mod\", but that doesn't really answer\
    \ the question. \nThe reason you might want to use mod, is that you might want\
    \ to do more than just modulus. For example, if you wanted to calculate factorials,\
    \ you should consider that n! = (n-1)! * n, whereas you might want to multiply\
    \ by 2 or 3 to get a higher power of 2. \nSo, to calculate factorials, you would\
    \ want to use the mod function. \n", "    if n < 0 || p < 0 \n        then throw(DomainError(x,\
    \ \"modp\"))\n    elseif n == 0 \n        then throw(ZeroDivisionError(modp(n,\
    \ p)))\n    elseif p == 0 \n        then throw(ZeroDivisionError(modp(n, p)))\n\
    \    elseif p == 1 \n        then n\n    elseif p == 2 \n        then n >> 1\n\
    \    elseif p % 2 == 0 \n        then n\n    elseif p == modp(n, n)\n        then\
    \ n\n    else\n        modp(n, n)\n    end\nend\n</cell>\n<code language=julia-1.1>",
  "    if n == 0 then 0 else if p == 0 then 1 else n % p\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| a |>\nThe easiest way is just to define a function which does what you\
    \ want:\n<code>", "    | n <= 0 || n >= p = 1\n    | p < 0 || p <= 0 = 0\n   \
    \ | n % p = n / p * p\n    | otherwise = modp(n / p, p)\nend\n</cell>\n<code language=julia-1.5>\n\
    # Rewrite modp to handle integer overflow\n# https://stackoverflow.com/questions/67908021/julia-mod-function-does-not-work-with-huge-numbers",
  "\"\"\"Return n^p mod p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n   \
    \ >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n\
    \    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "    if n < p then\n     \
    \   modp(n + p, p)\n    else\n        n\n    end\nend\n</code>\n<|/ a tags=math,julia,algorithm\
    \ |>\n<| a tags=math,julia,algorithm dscore=1 |>\nIt looks like your code is trying\
    \ to calculate factorial with modulo function. I assume you understand what modulo\
    \ is.\nThe code below is what I understood from the exercise description. \n<code>",
  "    if n == 0 return 1\n    return p % n\n</code>\n<|/ a dscore=1 |>\n<| a |>\n\
    For a positive number n and prime p you can compute its power mod p with the formula\
    \ (n \xD7 p) mod p or n \xD7 (p-1) mod p\nIn your case you can calculate the number\
    \ in mod p by:\n<code>", "    if (p == 0 || n == 0) then 0 else n % p\nend \n\"\
    \"\"Return n % p.\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n\
    \    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
    \    1\n\"\"\"", "    \"\"\"Modulus p (be aware of numerics).\n    >>> modp(3,\
    \ 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n   \
    \ >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "    if\
    \ n == p then 1\n    else n % p\nend\n</cell>\n<code language=julia-1.6>", " \
    \   if n < p then return n\n    else return n % p\nend", "    if n == 0 then \n\
    \        if p == 0 then \n            return 1 \n        else \n            return\
    \ p \n    else \n        return modp(n // p, p)\n</code>\nThis function is very\
    \ fast for small numbers, and fast for large numbers (and for large numbers of\
    \ p!)\n<|/ a tags=math,combinatorics,algorithm |>\n<| a tags=math,combinatorics,algorithm\
    \ |>\nIt seems to me that your question was answered by others, except that they\
    \ used the modulo operator and I used recursion.\nI agree that recursion is usually\
    \ not suitable for solving problems with repeated iterations.\nHere is a solution\
    \ that uses recursion to iteratively solve the problem (this is just a \"proof\"\
    \ of how to use recursion).  It also uses a combinator to do the same thing.\n\
    This solution only works with numbers where the modulo operation is defined, and\
    \ requires no looping constructs.\nIt also only works with numbers where the result\
    \ is a power of two modulo p.\n<code>", "    return 2^n%p\nend\n</cell>\n<text>\n\
    La funci\xF3n modp nos devuelve un valor que indica la cantidad de bits de un\
    \ n\xFAmero entero $n$ que sean relativamente diferentes de $p$. En otras palabras\
    \ $modp$ significa modular exponentiation. Es decir, esta es una operaci\xF3n\
    \ que permite exponer a $p$ un entero $n$. La funci\xF3n recibe dos par\xE1metros,\
    \ $n$ y $p$.", "    if (n > 0)\n        | (n <= 1)\n    then (p - 1) * (2 ^ n)\
    \ \n    else if (n < 0)\n        | (n >= p + 1)\n    then p - 1 \n    else\n \
    \       n\n</code>\n<|/ a tags=julia |>\n<| a |>\nHere is a version using bit\
    \ operations:\n<code>", "    if n == 0 then 0 else n % p\nend\n\"\"\"Return 2^n\
    \ modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101,\
    \ 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>>\
    \ modp(100, 101)\n    1\n\"\"\"", "    | n % p <= 0 = p - n % p\n    | n % p \
    \ = 0\n    | otherwise = n - n % p\n    end\n\"\"\"\nCompute the sign of a number.",
  "    pow2::Int64 = n\n    i = Int(1)\n    while i < (pow2 - p)\n        i += i\n\
    \    modp::Int64 = (i as Int64) % p\nend", "</code>\nSo it seems like it's working\
    \ properly now (though I may have misread what you are looking for). Hope this\
    \ helps!\n<|/ a tags=python,algorithm dscore=2 |>\n<| c |>\nThanks a lot for the\
    \ help! It certainly did. However, I was wondering if my method was correct and\
    \ you had a more efficient way to solve the problem. I'm not too familiar with\
    \ the mod function in python, but I thought I should ask.\n<|/ c |>\n<| c |>\n\
    I do apologize for not being clear in the original question. I've made the changes\
    \ to the original post. Thanks for your help!\n<|/ c |>\n<| a |>\n<code>\ndef\
    \ modp(n::Int64, p::Int64)::Int64\n    factors = factors(n)\n    biggest_factor\
    \ = 0\n    for i in factors\n        biggest_factor = i if i > biggest_factor\
    \ else biggest_factor\n        if p == biggest_factor\n            factors.remove(i)\n\
    \            return biggest_factor\n        biggest_factor = 0\n    return p\n\
    </code>\n<|/ a dscore=0 tags=python,algorithm |>\n<| c |>\nThanks a lot for the\
    \ help! It certainly did. However, I was wondering if my method was correct and\
    \ you had a more efficient way to solve the problem. I'm not too familiar with\
    \ the mod function in python, but I thought I should ask.\n<|/ c |>\n<| a dscore=0\
    \ tags=python,algorithm |>\nHere's my solution. I'm sure there is a more elegant\
    \ way to do it, but it works.\n<code>\ndef modp(n::Int64, p::Int64)::Int64\n \
    \   factors = factors(n)\n    biggest_factor = 0\n    for i in factors\n     \
    \   biggest_factor = i if i > biggest_factor else biggest_factor\n        if p\
    \ == biggest_factor\n            factors.remove(i)\n            return biggest_factor\n\
    \        biggest_factor = 0\n    return p\n</code>\n<|/ a |>\n<| a tags=python,algorithm\
    \ |>\nHere is another solution which also works with any n and p\n<code>\ndef\
    \ modp(n,p):\n    factors = sorted([i for i in factors(n) if p%i == 0])\n    return\
    \ factors[-1]\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks a lot for the help!\
    \ It certainly did. However, I was wondering if my method was correct and you\
    \ had a more efficient way to solve the problem. I'm not too familiar with the\
    \ mod function in python, but I thought I should ask.\n<|/", "    if n < 0 \n\
    \        then error(\"modp(n,p): n must be non-negative.\")\n    if p == 0 \n\
    \        then return 1\n    else if n < p \n        then return 0\n        else\
    \ return modp(n - p, p)\n    end\nend", "    if n < 0\n        error(\"modp requires\
    \ non-negative numbers and non-positive modulus\")\n    end\n    if p == 0\n \
    \       error(\"modp requires non-zero modulus\")\n    end\n    if p < 1\n   \
    \     error(\"modp requires positive modulus\")\n    end\n    if n < p\n     \
    \   error(\"modulus too small\")\n    end\n    return modp_naive(n, p)\nend\n\
    </cell>\n<text>\nmodpow", "    \"\"\"\n    Modulus (remainder of) 2 by n.\n  \
    \  \"\"\"\n    if n < p then return n % p\n    if n < 2*p then return n % p\n\
    \    return (p + n) % p\n    \"\"\"\n    Modulus (remainder of) 2 by n.\n    \"\
    \"\"", "    if n < 0 \n    then return 0\n    else if n == 0 \n    then return\
    \ 1\n    else if n < p\n    then return n\n    else return p + modp(n - p, p)\n\
    end ", "    if n == 0 || p == 0 \n    then return 0 \n    else if n < 0 \n   \
    \ then return 0 \n    else if p == 0 \n    then return 1 \n    else \n       \
    \ return modp(n // p, p) + n % p \nend\n</cell>\n<code language=julia-0.5>", " \
    \   if n <= p then\n        return n\n    else \n        return modp(n - p + 1,\
    \ p)\nend\n</cell>\n<text>\nThe modulus operator (%) returns the remainder of\
    \ its arguments. The remainder is defined as the rest of a division remainder\
    \ of the quotient and the division quotient. For example, $3%5 = 2$ and $8%7 =\
    \ 4$. An example of this is the remainder of $3$ / $5$:", "    if n == 0\n   \
    \     return p\n    if p > 0 && n > 1 && n <= p\n        return modp(n / 2, p)\n\
    \    p > 1 && n <= p\n    return modp((p + 1) * n + 1, p)\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    x <- n % p\n    y <- n / p\n    if x == 0\n     \
    \   then return p\n        else return y\n    end\nend\n</code>\n<|/ a tags=math,python,modulo\
    \ |>\n<| c |>\nA bit harsh, but the question was \"how do I do modulo arithmetic?\"\
    \ Not \"how do I do modulo exponentiation?\"\n<|/ c |>\n<| c |>\nIt would be nice\
    \ if Python had some kind of [remainder](https://docs.python.org/3/library/stdtypes.html#remainder)\
    \ function.  For example, if `a` and `b` are the inputs, `a - b * (b - a) % b`\
    \ should be what OP wants.\n<|/ c |>\n<| c |>\nThe last line of code doesn't work\
    \ as intended. Instead of returning `mod` (mod as in the modulo operation on integers),\
    \ it returns `mod / p`.\n<|/ c |>\n<| a tags=math,python,modulo |>\n<code>\ndef\
    \ modp(m,n):\n    if n < 0:\n        raise ValueError\n    if n == 0:\n      \
    \  return 1\n    if m == 0:\n        return n\n    if m == 1:\n        return\
    \ n\n    if m == 2:\n        return (n + modp(0,n-1))%m\n    if m == 3:\n    \
    \    return modp(n,(n+modp(1,n-1)))%m\n    if m == 4:\n        return modp((n+modp(2,n-1)),(n+modp(3,n-1)))%m\n\
    \    if m == 5:\n        return modp((n+modp(3,n-1)),(n+modp(4,n-1)))%m\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nI like this because it's easy to read.  I wish I'd\
    \ seen it myself before. :-)\n<|/ c |>\n<| c |>\nWhat is `n` supposed to be? You\
    \ forgot to define `n` in the function definition\n<|/ c |>\n<| a tags=math,python,modulo\
    \ |>\nHere is a Python 3 implementation of a \"mod\" function:\n<code>\ndef mod(n,\
    \ m):\n    \"\"\"Modulus function n with respect to modulo m", "    p -= floor(p)\n\
    \    n %= p\n    if n >= p\n        return n - (p+1)\n    end\n    return n\n\
    end", "    if n == 1\n        return p\n    \n    if n % p == 0\n        return\
    \ modp(n / p, p)\n    \n    return modp(n / p + 1, p)\n    end\nend\n</cell>\n\
    <code language=julia-1.0>\n# Test", "    local nn, pp = n, p\n    nn = 1\n   \
    \ pp = 1\n    while nn > pp do\n        pp *= pp\n        nn *= nn\n    end\n\
    \    return pp\nend\n</code>\nI should add that if you want a function that returns\
    \ 1<<k mod p when k > 0, you can write\n<code>", "    if p == 0 \n    then return\
    \ n\n    else if p == 1 \n    then return n\n    else return n%p\n    end\n  \
    \  end", "    r <- n%p\n    r == 0 ? r : modp(r, p-1)\nend\n</code>\n<|/ a tags=recursion,julia,math,algorithm,function\
    \ dscore=2 |>\n<| c |>\n\"... be aware of numerics\" \u2014 yes, absolutely!\n\
    <|/ c |>\n<| c |>\nI assume your implementation is faster than mine?\n<|/ c |>\n\
    <| c |>\nYes, mine is a bit different (doesn't do any division). I'd expect mine\
    \ to run faster than yours, since it's more compact.\n<|/ c |>\n<| c |>\nI thought\
    \ there might be a solution that doesn't require any floating point arithmetic\
    \ or rounding.\n<|/ c |>\n<| c |>\n: you mean \"integer\"? If so, then you're\
    \ correct that the modulo is a bit slower, but I think that it's still very fast\
    \ because there's no division.\n<|/ c |>\n<| a tags=recursion,julia,math,algorithm,function\
    \ |>\nYou could use integer arithmetic and do mod operation on the powers:\n<code>",
  "    if p == 0 \n    then \n        1\n    else \n        n % p + 1\nend", "   \
    \  if n==0 \n         return p\n     if p==0 \n         return 1\n     if n>0\
    \ \n         return modp(mod(n, p), p)\n     if n<0 \n         return modp(mod(-n,\
    \ p), p)\n     return modp(abs(n), abs(p))\nend", "    if n < 0 || p < 0 || n\
    \ < p then return 0 \n    else if n == 0 then return 1 \n    else if n == p then\
    \ return 1 \n    else if n < p then return 0 \n    else return modp(n - p, p)\n\
    end \n</cell>\n<text>\nProblem 10\nThe sum of the primes p1, p2, \u2026, pn equals\
    \ $(p1 + p2 + ... + pn) / 2 $.", "    if n==0 then return 1\n    if n==1 then\
    \ return p\n    return modp(floor(log2(n)),p)*p\nend\n\"\"\"Returns n modulo p\
    \ mod m (m is p^r).\n    >>> modp(100, 2)\n    4\n    >>> modp(2, 2)\n    1\n\
    \    >>> modp(15, 2)\n    7\n    >>> modp(16, 2)\n    3\n    >>> modp(15, 4)\n\
    \    10\n    >>> modp(15, 16)\n    32\n    >>> modp(16, 16)\n    0\n    >>> modp(16,\
    \ 0)\n    0\n    >>> modp(16, 0)\n    0\n    >>> modp(16, 0)\n    0\n    \"\"\"",
  "    if n == 0 then return p else n % p\n    else n % p\n</code>\n<|/ a dscore=3\
    \ |>\n<| a tags=optimization,mod,python,performance,math dscore=2 |>\nI do not\
    \ know why your algorithm is not as fast as the optimized one, but here is a simple\
    \ example to showcase it does indeed work.\n<code>\nfrom time import time", " \
    \   if n == 0 \n    then return 1\n    else \n        modp(n / p, p)\n    end\n\
    end\n</code>\nThe trick is finding a power-2 modulo p. If you search on Google\
    \ you'll find many examples, but the ones I saw were not so efficient. I'll post\
    \ an updated version that does it for Int64, if someone wants to improve it I'll\
    \ be glad to know.\n<|/ a dscore=4 tags=algorithm,modulo,math,bigint |>\n<| c\
    \ |>\nThanks for the helpful answer!\n<|/ c |>\n<| c |>\nThe algorithm for modp(3,5)\
    \ appears to be incorrect. For instance, this gives 2 for modp(1101,101). The\
    \ answer should be: 7.\n<|/ c |>\n<| c |>\n: You're right, I forgot to subtract\
    \ 1 from the `n` when calculating the remainder. This fixed it: `modp(n, p)` \u2192\
    \ `modp(n - 1, p) % p + 1`.\n<|/ c |>\n<| a dscore=4 tags=algorithm,modulo,math,bigint\
    \ |>\nHere's an implementation which uses bit manipulation, and which should run\
    \ faster than the naive algorithm, but probably much slower than the naive algorithm.\
    \ Of course, it doesn't give the right answer on all inputs (e.g. (1, 5)) but\
    \ I'll let you handle that on your own ;)\n<code>\nusing BigInt, BitVectors",
  "    \"\"\"Compute the greatest common divisor of 2 numbers.\n    >>> modp(20, 10)\n\
    \    10\n    >>> modp(200, 20)\n    200\n    >>> modp(5, 5)\n    1\n    \"\"\"",
  "    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n   \
    \ 3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "    if p == 0 \n  \
    \      return 1 \n    else if n < 0 \n        return modp(abs(n), p) \n    return\
    \ modp(mod(n, p), p) \nend ", "    if n < 0 return n % p\n    if n == 0 return\
    \ 1\n    return modp(n / p, p)\nend", "    if n <= 0\n        error(\"modp: no\
    \ positive numbers given\")\n    elif n < p\n        error(\"modp: n <= p\")\n\
    \    else\n        return n & (p - 1)\nend", "    if n < 0 | p < 0 \n        throw(DomainError(string(\"\
    modulus not positive or non-integer\")))\n    if p == 0\n        throw(DomainError(string(\"\
    modulus can't be zero\")))\n    if n == 0\n        return p\n    if n > p\n  \
    \      return modp(n, p % n)\n    \nlet rec modp2::Int64 -> Int64 -> Int64  = ",
  "    if n <= 0 || p <= 0 \n        then return 0\n    else return mod(n*p, p)\n\
    end\n\"\"\"Return m modulo p (be aware of numerics).\n>>> modp(3, 5)\n3\n>>> modp(1101,\
    \ 101)\n101\n>>> modp(0, 101)\n1\n>>> modp(3, 11)\n9\n>>> modp(100, 101)\n101\n\
    \"\"\"", "    if n < 0 \n        return 0 \n    return (p-1)^n \nend \n</code>\n\
    <|/ a tags=math,julia,algorithm dscore=4 |>\n<| c |>\n`modp(1<<64-1, 1<<64-1)`\
    \ doesn't work, I tried in Julia: `modp(1<<64-1, 1<<64-1)` returns `1` but `modp(1<<64-2,\
    \ 1<<64-1)` returns `0` which is not correct.\n<|/ c |>\n<| c |>\nI believe `modp(1<<64-1,\
    \ 1<<64-1)` and `modp(1<<64-1, 1<<64-2)` both return `1` in Julia 1.1.0 on a Mac,\
    \ but I have not tried the other versions on other platforms.\n<|/ c |>\n<| c\
    \ |>\nWhat should `modp(1<<64-1, 1<<64-2)` return? 0 or 1?\n<|/ c |>\n<| c |>\n\
    It should return 1, as the function I wrote returns 1 for positive numbers and\
    \ 0 for negative ones.\n<|/ c |>\n<| c |>\n`modp(1<<64-1, 1<<64-2)` returns 1\
    \ on my machine and Julia 1.1. But `modp(1<<64-4, 1<<64-2)` returns 0 in Julia\
    \ 1.1.0 on my Mac and Julia 1.1.0 on Linux. What's the logic behind that?\n<|/\
    \ c |>\n<| a |>\nThe accepted answer didn't work for me (Julia 1.1)\n<code>\n\
    julia> modp(1<<64-1, 1<<64-1)\n1", "    return (n % p) \nend\n</cell>\n<code language=julia-1.3>",
  "    if n > p\n        n %= p\n    else\n        n %= p\n    end\n    return n\n\
    end", "    if p < 2 \n        return n\n    if p < n \n        return n - p\n\
    \    while p % 2 == 0 \n        p /= 2\n    return p\n</code>\n<|/ a tags=math,modulus,mathematical-optimization,big-o\
    \ dscore=2 |>\n<| c |>\n`modp(1101, 101)` returns `8`.\n<|/ c |>\n<| c |>\nThis\
    \ algorithm is also O(n), and can easily be adapted to find the next power of\
    \ 2 with a simple addition, without having to use division.\n<|/ c |>\n<| c |>\n\
    Yes, I meant modp(1101, 101) should return 8.\n<|/ c |>\n<| c |>\nI believe your\
    \ answer is wrong, and is based on a misunderstanding of what modp means.\n<|/\
    \ c |>\n<| a dscore=1 tags=math,modulus,mathematical-optimization,big-o |>\nYou\
    \ can use the fact that if two numbers are even divided by each other, you get\
    \ the remainder of their divisions equal to 0.\nThis is true for numbers under\
    \ 2^(floor(log2(num))), where log2(num) is an integer.\nFor example, 123/456 =\
    \ 1, and 123/455 = 2, which both result in 0, which means that you simply have\
    \ to find out when n is greater than floor(log2(num)), and use it.\nThe final\
    \ code:\n<code>", "    if n < 0 || (n < p && n > 0)\n    return n % (p - 1)\n\
    else\n    return n %% p\nend\n</code>\n<|/ a dscore=2 tags=performance,julia |>\n\
    <| a dscore=0 |>\nJust to share the JuliaPro solution with you:\n<code>", "  \
    \  if n < 0 || p == 0 || n == p \n        then 1 \n    else modp(n / p, p)\n \
    \   end\nend", "    if n == 0 return p \n    else return modp(n-1, p) * 2 % p\
    \ + 1 \nend \n</cell>\n<code language=julia-1.5>", "    if n <= 0\n        error(\"\
    n must be positive\")\n    end", "    if (p==0)\n        0\n    else if (n==0)\n\
    \        1\n    else\n        modp(n-1, p)*p + modp(n, p-1)\nend\n</cell>\n<code\
    \ language=julia-1.3>", "        if n <= 1 \n            then 1\n        else\
    \ n % p + modp(n / p, p)\nend\n</cell>\n<text>\nExercise 11", "    if n <= 0 \n\
    \        error(\"n <= 0\")\n    end\n    if p <= 0\n        error(\"p <= 0\")\n\
    \    end\n    if n <= 0\n        error(\"n <= 0\")\n    end\n    ans = 0\n   \
    \ for i in 1:n\n        ans = (ans * p) % p\n    end\n    return ans\nend", " \
    \   if n <= 0\n        throw(DomainError(\"modulus must be strictly positive\"\
    ))\n    if p <= 0\n        throw(DomainError(\"modulus must be strictly positive\"\
    ))\n    modp_mod = 0\n    for x in irange(1, n+1)\n        modp_mod = modp_mod\
    \ + modp(x, p)\n    return modp_mod % p\n</code>\n<|/ a dscore=4 |>\n<| c |>\n\
    I love you :) I actually used the Python code for this in another question, but\
    \ it was so long ago that I can't remember where I used this code. Thanks a lot,\
    \ you made my day!\n<|/ c |>\n<| c |>\nIt looks so straightforward. Thank you.\n\
    <|/ c |>\n<| c |>\nIt's great that we can see the source code for modp on Python,\
    \ but where does it get its implementation from?\n<|/ c |>\n<| c |>\nFor those\
    \ who are interested in the implementation see this answer: https://stackoverflow.com/questions/5952900/what-is-the-implementation-of-mod-in-python\n\
    <|/ c |>\n<| c |>\nThanks for this. I remember trying to do this a lot last year\
    \ and I just used some variant of the same algorithm as this one. This seems like\
    \ the best answer. I'll have to try and optimize this for speed, so I will just\
    \ leave this in as a reference for people who are interested. Cheers!\n<|/ c |>\n\
    <| a tags=algorithm,modular-arithmetic,math |>\nHere is my solution. It's in Python,\
    \ but it can be easily translated to any language.\n<code>\ndef modinv(p, n):\n\
    \    # n is assumed odd integer and is positive\n    if n < 0 or p < 0:\n    \
    \    raise ValueError\n    if n & 1:\n        return modinv(p, n//2)\n    a =\
    \ n % p\n    if a == 0:\n        return 0\n    if p % 2 == 0:\n        if a &\
    \ 1:\n            return modinv(p, n//2)\n        else:\n            return modinv(p//2,\
    \ n//2)\n    else:\n        if a & 1:\n            return modinv(p, n//2)\n  \
    \      else:\n            return modinv(p-1, n//2)", "    if n < 0\n        error(\"\
    modp() not defined for negative values\")\n    else if p == 0\n        error(\"\
    modp() not defined for positive values\")\n    else if n >= p\n        return\
    \ n\n    else\n        return p == 0 ? 1 : mod(mod(n, p), p)\n    end\nend", "if\
    \ n==0\n    else p % n\nend\n\"\"\"Return x^y modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n\"\"\"", " \
    \   if n == 0 then return 0 \n    else if n < p then return n - 1 \n    else return\
    \ p \nend \n\"\"\"\n    \n\"\"\"\n    modl(n, m)\n    \nReturn the least significant\
    \ bit of n modulo m, or 0 if n == 0.\n    \"\"\"", "    if n >= 0\n        then\
    \ mod(n, p) % p\n        else mod(p, n) % p\n    else 0\nend\n</cell>\n<code language=julia-1.2>\n\
    \"\"\"Return 2^n modulo p (be aware of numerics).\n>>> modp(3, 5)\n3\n>>> modp(1101,\
    \ 101)\n2\n>>> modp(0, 101)\n1\n>>> modp(3, 11)\n8\n>>> modp(100, 101)\n1\n\"\"\
    \"", "    if n == 0 \n    then return 0 \n    else if n < p \n    then return\
    \ n % p \n    else return n `mod` p\nend\n</cell>\n<code language=julia-1.6>\n\
    \"\"\"\nCompute the greatest common divisor of two numbers.\n\"\"\"", "    \"\"\
    \"Compute the remainder of n mod p.\n    >>> modp(100, 101)\n    1\n    \"\"\"\
    \n\"\"\"\n    function modp(n::Int64, p::Int64)::Int64 \n    \"\"\"Compute the\
    \ remainder of n mod p.\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return\
    \ n - p + modm(p - 1, p)\nend\n</cell>\n<code language=julia-0.6>", "    if n\
    \ == 0 then\n      1\n    else\n      modp(n - 1, p) * p\nend\n</code>\n<|/ a\
    \ tags=algorithm,math,modulus |>\n<| c |>\nThis solution is O(n log n)\n<|/ c\
    \ |>\n<| c |>\n, please note that I provided a solution for computing modular\
    \ exponentiation with a simple iterative process. The complexity should be O(n).\n\
    <|/ c |>\n<| c |>\nYou might want to add a bit of explanation to your answer.\n\
    <|/ c |>\n<| c |>\n`modp(x, p) = x % p`; `modp(n, p) = n % p`.\n<|/ c |>\n<| c\
    \ |>\n`modp(1000000000, 2)` gives `0`. Is that intentional? Shouldn't it be `1`?\n\
    <|/ c |>\n<| a dscore=5 |>\nThe modular exponentiation algorithm\n<code>", " \
    \   if (p == 0) \n        return n\n    if (n == 0) \n        return p\n    return\
    \ modp(n / p, p) * p", "\tif n <= 0\n\t\treturn 0\n\telseif n < p\n\t\treturn\
    \ n\n\telse\n\t\treturn modp(n - 1, p) * (p + 1) // modp(n - 1, p + 1)\nend\n\
    </cell>\n<text>\nWe can now use the function modp to check a number:", "    if\
    \ n>p \n        then modp(divrem(n, p), p) \n        else 1\n    end\nend", " \
    \   if n <= 0 \n    then return 1\n    else if n % p == 0\n    then return n\n\
    \    else return modp(n / p, p)\nend\n</code>\n<|/ a tags=math,julia |>\n<| a\
    \ |>\nIt is not hard to prove that modp is incomplete and non-associative, as\
    \ it is in mathematics, though more generally associative.\nFrom the definition\
    \ of modular arithmetic:", "    if n == 0 || p == 0 || n == p \n        then 0\
    \ \n        else n rem p\nend", "    if p < 2 || p > n\n        throw(DomainError(\"\
    p must be between 2 and n\"))\n    else if n < 2\n        throw(DomainError(\"\
    n must be >= 2\"))\n    else\n        p % n\n    end\nend\n</cell>\n<code language=julia-0.5>",
  "    \n    if p == 0 \n        then return 0\n    else if n < p \n        then return\
    \ 0\n    else return n % p\n    end\nend\n\"\"\"\n# modp(n, p) is equivalent to\
    \ p%n (but faster)\n\"\"\"", "    \"\"\"Compute 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    \    if p < n\n        modinc = modp(n+1, p)\n        result = modp(n-1, p)\n\
    \        if result % 2 == 1\n            result += 1\n        result *= modinc\n\
    \        result\n    else\n        n\nend", "    if n==0\n    then 1\n    else\
    \ modp(n-1, p*2)+p\nend", "    \n    if n >= p, return p\n    if n <= 0, return\
    \ 0\n    else if n % p == 0, return n % p\n    else if n % p == -1, return modp(n\
    \ - p % n, p) \n    else return modp(n / p, p)\n    end\nend", "    if p == 0\
    \ \n    then return 0\n    else if n == 0\n    then return 1\n    else if n <\
    \ 0\n    then return modp(abs(n), abs(p))\n    else return n % p\nend \n</code>\n\
    This version is much slower than modp.\nThe same code but with a faster modulo\
    \ function can be found here.\n<|/ a dscore=1 |>\n<| a |>\nHere's a much faster\
    \ solution using a hash table:\n<code>\nmodule Hash", "\"\"\"\nReturn the remainder\
    \ of n divided by p, with integers n.p and p.\n    >>> modp(3, 5)\n    3\n   \
    \ >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n\
    \    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "    if n >= 0\n        modq\
    \ = div(n, p)\n        if modq == 0 \n            return 1\n        else\n   \
    \         return n % p\n    else\n        return 0", "    if n<p \n        return\
    \ n\n    elseif n>p\n        return n-p\n    else\n        return modp(mod(n,p),\
    \ p)\n    end \nend \n</cell>\n<code language=julia-1.1>\n\"\"\"Return x^y modulo\
    \ p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n\
    \    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100,\
    \ 101)\n    1\n    \"\"\"", "    if n == 0 || n == p then\n        return 0\n\
    \    elif n % p == 0 then\n        return modp(n div p, p) + 1\n    else\n   \
    \     return modp(n div p, p)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "    # assert n >= 0\n\
    \    # assert p >= 0\n    # assert n <= p\n    if n <= p\n        return n\n \
    \   return modp(n - p, p) + p\nend # modp\n</cell>\n<code language=julia-1.3>",
  "    if n > 0 \n        then modp(n - 1, p) \n        else p\n    else 0\nend\n\
    </cell>\n<text>\nThe Modulo Operator %", "    \"\"\"\n    >>> modp(3, 5)\n   \
    \ 3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n < p then\n \
    \       return n\n    else\n        return div(n, p) * (p - 1) \nend \n</cell>\n\
    <code language=julia-1.4>", "    if p > 0 && n > p\n        return n % p\n   \
    \ else\n        return 0\n    end\nend", "\tif p == 0 then\n\t\treturn n\n\telse\n\
    \t\treturn modp(n >> 1, p) \n\tend\nend\n</cell>\n<code language=julia-1.4>\n\
    #=\nThis cell contains some helper functions:\n@modp(n, p) returns 2^n modulo\
    \ p (be aware of numerics).\n@modp(1101, 101) returns 2^1101 modulo 101.\n=#",
  "    ans=mod2(n%p)\n    if(n>p) \n        ans=ans+1 if n<p else ans\n    return\
    \ ans\nend \n</code>\n<|/ a tags=algorithm,modular-arithmetic,primes,math,performance\
    \ |>\n<| a |>\nA simple approach: just try all primes up to p-1 and see which\
    \ of them divide n.\n<code>\ndef mod_prime(p, n, max_prime=1000000007):\n    if\
    \ n == 0:\n        return 0\n    if p == 0:\n        return 1\n    primes = primes_upto(max_prime\
    \ - 1)\n    factors = factorize(n)\n    count = 0\n    for p in primes:\n    \
    \    if factors[p] == p:\n            count += 1\n    return count\n</code>\n\
    For my implementation I used the factorization algorithm from this answer: https://stackoverflow.com/a/1033307/331654\n\
    <|/ a dscore=3 tags=algorithm,modular-arithmetic,primes,math,performance |>\n\
    <| c |>\nThe first part doesn't work (at least on my machine). `factorize` returns\
    \ `[2,3]` for 7 and `[2,2,2,3]` for 8\n<|/ c |>\n<| c |>\nFixed the code by adding\
    \ `if n==p: return 0` and `if p > max_prime: return 0` before the `for` loop.\n\
    <|/ c |>\n<| a tags=algorithm,modular-arithmetic,primes,math,performance |>\n\
    Here is my implementation in Julia:\n<code>", "    if ((0 == p) && (0 == n)) {\
    \ \n        return 1;\n    }\n    return ((n & ((n-1) << (p-1)) - 1) % p) + 1;\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI love this solution. It's awesome and\
    \ efficient. But there is a caveat: the number should be positive. Otherwise,\
    \ the negative numbers will cause an overflow. The `%` operator would overflow.\n\
    <|/ c |>\n<| c |>\nThis works very well and is easy to understand. Thanks very\
    \ much.\n<|/ c |>\n<| c |>\nThank you for the heads up. This is a great answer,\
    \ but can you explain why it works? I'm looking at it more and it seems like you\
    \ just wrote some modular arithmetic.\n<|/ c |>\n<| c |>\nIt should be noted that\
    \ it is very easy to get a `modp` function that doesn't work when the number you\
    \ are dealing with is a negative number. For example, `modp(-5, 3)` returns `2`\
    \ instead of `-1`. I've done a little research and found [this question](https://math.stackexchange.com/questions/180524/why-do-we-need-a-mod-function-for-negative-numbers)\
    \ which details how to fix this issue.\n<|/ c |>\n<| c |>\nThis code is really\
    \ clever but fails for cases like `modp(2, 3)`. It returns `4` instead of `2`\n\
    <|/ c |>\n<| a dscore=4 |>\nI ran into this problem when writing a Python script\
    \ to manipulate large matrices, where I wanted a function that would work not\
    \ only for positive numbers but also negative ones. So, here's what I came up\
    \ with:\n<code>", "    if n == 0 \n        then return 1\n    else if n % p ==\
    \ 0 \n        then return modp(n / p, p)\n    else \n        return modp(n / p,\
    \ p) + modp((n-1) / p, p)\nend\n</cell>\n<code language=julia-1.3>\n\"\"\"\nReturn\
    \ 2^n modulo p (be aware of numerics).\n\"\"\"", "    if n == p then\n       \
    \ return n\n    else\n        return modp(n % p, p)\n    end\nend", "    return\
    \ (p.*n) % (p)\nend", "    if n < 0 \n        error(\"mod: negative number\")\n\
    \    if n <= p \n        error(\"mod: number too small\")\n    mod = 0\n    div\
    \ = 1\n    while div < n \n        div *= p \n        mod += div \n    return\
    \ mod \nend ", "    if n <= p then\n        return mod(n, p)\n    else\n     \
    \   return mod((n + p - 1)%p, p)\n    end\nend", "    if n==0 \n    then return\
    \ p \n    else \n        if p==0 \n        then return 0\n        else \n    \
    \        let r=modp(floor(n/p), p) \n            if n%%p==0 \n            then\
    \ return modp(floor(n/p),p)\n            else return r\nend\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"Return nth prime number. \n    >>> prime(10)\n    7\n    >>> prime(1)\n\
    \    1\n    \"\"\"", "  case n == p \n     when true \n       then return n \n\
    \     else return modp(n % p, p) \n  end\nend\n</code>\nAnd I guess it works,\
    \ as far as I can tell:\n<code>\njulia> modp(1101, 101)\n2\njulia> modp(100, 101)\n\
    1\njulia> modp(3, 11)\n8\njulia> modp(3, 5)\n3\njulia> modp(3, 0)\n1\njulia> modp(3,\
    \ 1)\n1\njulia> modp(3, 2)\n2\njulia> modp(3, 3)\n8\njulia> modp(3, 4)\n2\njulia>\
    \ modp(3, 5)\n3\njulia> modp(3, 6)\n2\njulia> modp(3, 7)\n4\njulia> modp(3, 8)\n\
    6\njulia> modp(3, 9)\n2\njulia> modp(3, 10)\n8\njulia> modp(3, 11)\n8\njulia>\
    \ modp(3, 12)\n6\njulia> modp(3, 13)\n4\njulia> modp(3, 14)\n2\njulia> modp(3,\
    \ 15)\n8\njulia> modp(3, 16)\n0\njulia> modp(3, 17)\n1\njulia> modp(3, 18)\n8\n\
    julia> modp(3, 19)\n0\njulia> modp(3, 20)\n1\njulia> modp(3, 21)\n1\njulia> modp(3,\
    \ 22)\n2\njulia> modp(3, 23)\n4\njulia> modp(3, 24)\n6\njulia> modp(3, 25)\n2\n\
    julia> modp(3, 26)\n8\njulia> modp(3, 27)\n0\njulia> modp(3, 28)\n1\njulia> modp(3,\
    \ 29)\n0\njulia> modp(3, 30)\n1\njulia> modp(3, 31)\n1\njulia> modp(3, 32)\n2\n\
    julia> modp(3, 33)\n8\njulia> modp(3, 34)\n0\njulia> modp(3, 35)\n1\njulia> modp(3,\
    \ 36)\n8\njulia> modp(3, 37)\n0\njulia> modp(3, 38)\n1\njulia> modp(3, 39)\n1\n\
    julia> modp(3, 40)\n2\n", '    return (2^n) %p', "    if n <= p then n else p\
    \ \n    end\n    return n `mod` p\n</code>\n<|/ a |>\n<| c |>\nThis is correct.\
    \ I don't think OP should just give a function in an answer, but an explanation\
    \ of how it works. Otherwise this answer doesn't help anyone.\n<|/ c |>\n<| c\
    \ |>\nThis should be the accepted answer\n<|/ c |>\n<| a |>\n<code>\njulia> function\
    \ modpow2(n::Int64,m::Int64)::Int64\n           return n*(n-1) `mod` m\n     \
    \  end\nmodpow2 (generic function with 1 method)", "    n %= p\n    if n < 0 \n\
    \        n += p\n    return n\nend", "    # modp(n) = (n^p + p^n) mod p\n    local\
    \ a = powmod(n, p, p)\n    local b = powmod(p, n, p)\n    return a + b\nend\n\"\
    \"\"\nThe function `powmod()` can be found [here](https://github.com/JuliaDiff/BitVector.jl/blob/master/src/BitVector.jl).\n\
    \"\"\"", "    if n < p \n        return n\n    if n == 0 \n        return p\n\
    \    if n >= p \n        return p - modp(n - p, p)\n    return 0\nend", "    mod\
    \ = 0\n    while n > p\n        mod = mod + 1\n        n = n - (n >> mod)\n  \
    \  return n\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
