name: HumanEval_151_double_the_difference
language: jl
prompt: "\"\"\"\n    Given a vector of numbers, return the sum of squares of the numbers\n\
  \    in the vector that are odd. Ignore numbers that are negative or not integers.\n\
  \    \n    >>> double_the_difference([1, 3, 2, 0])\n    10\n    >>> double_the_difference([-1,\
  \ -2, 0])\n    0\n    >>> double_the_difference([9, -2])\n    81\n    >>> double_the_difference([0])\n\
  \    0\n   \n    If the input vector is empty, return 0.\n    \"\"\"\nfunction double_the_difference(lst::Vector{Float64})::Int64\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = double_the_difference;\n\t@test(candidate(Vector{Float64}([]))\
  \ == 0)\n\t@test(candidate([5.0, 4.0]) == 25)\n\t@test(candidate([0.1, 0.2, 0.3])\
  \ == 0)\n\t@test(candidate([-10.0, -20.0, -30.0]) == 0)\n\t@test(candidate([-1.0,\
  \ -2.0, 8.0]) == 0)\n\t@test(candidate([0.2, 3.0, 5.0]) == 34)\n\t@test(candidate([-9.0,\
  \ -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]) == 165)\nend\n"
completions: ["    sum = 0\n    for i in lst\n        if i > 0\n            sum +=\
    \ i*i\n        end\n    end\n    return sum\nend\n</code>\n<|/ a |>\n<| c |>\n\
    For some reason, I don't see the function `map` in Julia version 0.6.2, but `map(x->x*x,\
    \ lst)` works fine.\n<|/ c |>\n<| c |>\nIt appears that `map` was added in Julia\
    \ version 0.6.2, but I have not been able to replicate their behavior in 0.6.1.\
    \  It may be something specific to my installation.  I am using Julia version\
    \ 0.6.1\n<|/ c |>\n<| c |>\nThe `map` function was added in version 0.6.0. https://julialang.org/blog/2017/11/05/what-s-new-in-julia-0.6.0#map\n\
    <|/ c |>\n<| a dscore=1 |>\nI ran into the same issue.  I was able to solve it\
    \ by replacing \n<code>\nfor i in vec\n    result += i^2\nend\n</code>\nwith\n\
    <code>\nfor i in vec\n    result +=i*i\nend\n</code>\n<|/ a tags=julia |>\n<|\
    \ a dscore=0 tags=julia |>\nAnother simple option is to apply the ^ operator on\
    \ the elements of the vector rather than the vector:\n<code>\njulia> vec = [-1,\
    \ 0, 2, -4, 8]\n8-element Vector{Int64}:\n -1\n 0\n 2\n -4\n 8", "    sum_of_squares\
    \ = 0.0\n    for x in lst\n        if x > 0 and x % 2 == 1\n            sum_of_squares\
    \ += x*x\n        end\n    end\n    return sum_of_squares\nend\n</cell>\n<code\
    \ language=julia-1.5>\ndouble_the_difference([1, 2, 3])\n</cell>\n<code language=julia-1.5>\n\
    double_the_difference([-1, -2, 0])\n</cell>\n<code language=julia-1.5>\ndouble_the_difference([9,\
    \ -2])\n</cell>\n<code language=julia-1.5>\ndouble_the_difference([0])\n</cell>\n\
    <text>\nExercise: write a function that creates a new vector where each item is\
    \ the product of the vector and the vector itself.", "    if length(lst)==0 return\
    \ 0 \n    sum = 0\n    for i in lst\n        if isinteger(i)\n            sum\
    \ += i\n        else\n            sum += i * i\n    end\n    return sum\nend\n\
    </cell>\n<code language=julia-1.4>\n# Example\ndouble_the_difference([1,3,2,0])\n\
    </cell>\n<code language=julia-1.4>\n# Example\ndouble_the_difference([-1,-2])\n\
    </cell>\n<code language=julia-1.4>\n# Example\ndouble_the_difference([9,-2])\n\
    </cell>\n<code language=julia-1.4>\n# Example\ndouble_the_difference([0])\n</cell>\n\
    <text>\nExercise\nWrite a function that returns the multiplicative difference\
    \ of a vector of numbers. \nFor example, suppose we have\nvector = [1,2,3,4]\n\
    Then the multiplicative difference is\n[1,2,-3,4]", "    sum = 0.0\n    count\
    \ = 0\n    for x in lst\n        if isodd(x) || x > 0.0\n            sum += x\n\
    \            count += 1.0\n        end\n    end\n    return sum * sum / count\n\
    end\n</cell>\n<code language=julia-0.5>\n@assert double_the_difference([-1.1,\
    \ 1.2, 1.3, 1.4, 1.5]) == 2.455\n@assert double_the_difference([]) == 0.0\n</cell>\n\
    <code language=julia-0.5>\n# How about if we do all of this in one function?\n\
    \"\"\"\n    This function takes two vectors and return a new vector that is the\
    \ sum of the square \n    of the numbers in the first vector that are odd and\
    \ the sum of the square of \n    the numbers in the second vector that are even.\n\
    \"\"\"", "  if length(lst) == 0\n    return 0\n  else\n    return sum(lst[i] for\
    \ i=1:length(lst)) \n  end\nend\n</cell>\n<text>\nPart II: Recursion\nRecall:\
    \ in mathematics, a recursive function is a function which calls itself repeatedly\
    \ until some condition is met.  A classic example is a factorial function, which\
    \ calls itself until n is a whole number.", "    if isempty(lst)\n        return\
    \ 0\n    \n    evens = filter(x -> x % 2 == 0, lst)\n    evens = map(x -> x *\
    \ x, evens)\n    \n    summed_evens = reduce(+, evens)\n    \n    return summed_evens\n\
    end\n</cell>\n<code language=julia-1.5>\n# TEST double_the_difference (3b)\n@test\
    \ double_the_difference([-1, -2]) == 0\n@test double_the_difference([0, -3]) ==\
    \ 0\n@test double_the_difference([1, 3, 2, 0]) == 10\n@test double_the_difference([9,\
    \ -2]) == 81\n</cell>\n<text>\nProblem 4: Vectors", "    s = sum(lst)\n    \n\
    \    for i in lst \n        if i%2==1\n            s += i\n        end\n    end\n\
    \    \n    return s\nend\n</cell>\n<text>\nExercise 3: Write a function that takes\
    \ a vector of numbers as an input and returns \nthe sum of squares of the numbers\
    \ in the vector that are odd. Ignore numbers that are negative or not integers.\n\
    For example, if the vector is [1, 2, 3, 4] then your function should return 19\
    \ (1 + 5 + 9 + 13).", "    return sum((x -> x % 2 == 1) .* lst)\nend\n</cell>\n\
    <code language=julia-0.4>\n\"\"\"\n    sum_of_squares(v::Vector{Int}) -> (Int64)\
    \ sum of the squares of the numbers in v\n    \n    Example:\n        \n    >>>\
    \ sum_of_squares([4,5,7,11])\n    49\n    >>> sum_of_squares([1,2,3])\n    9\n\
    \"\"\"", "    if length(lst) == 0\n        return 0\n    else\n        return\
    \ sum(lst) .+ sum(lst) .- sum(lst) .* sum(lst)\n    end\nend\n</cell>\n<text>\n\
    Solution", "    if length(lst) == 0 \n        0\n    elseif length(lst) == 1 \n\
    \        lst[1]\n    else\n        sum(lst[i] for i=2:length(lst) where lst[i]\
    \ % 2 == 1) \n    end\nend\n</cell>\n<text>\nImplement the function is_perfect_square.\
    \ This function should accept a vector of numbers and return a boolean indicating\
    \ if the vector is a perfect square.", "    n = length(lst)\n    s = 0\n    for\
    \ x in lst\n        if x%2 == 1\n            s += x\n        end\n    end\n  \
    \  return s\nend\n</cell>\n<text>\nExercise 4\nUse map() to apply the function\
    \ double_the_difference() to each element of a list of numbers. Then, use sum()\
    \ to return the sum of all the elements in that list.", "    sum = 0.0\n    for\
    \ x in lst\n        if iszero(x)\n            continue\n        if x < 0\n   \
    \         x = 0.0\n        end\n        sum += x*x\n    end\n    return sum\n\
    end\n</code>\nIn your particular case:\n<code>\nmysumsq = sum(sq(filter( x ->\
    \ mod(x,2) == 1, collect(1:50))))\n</code>\nThis avoids unnecessary memory allocations.\n\
    <|/ a tags=performance,julia dscore=3 |>\n<| c |>\nFor a vector of integers, you\
    \ can also do: `sum(x -> x%2==0, x)` for a vector `x`.\n<|/ c |>\n<| a |>\nI haven't\
    \ tried this with other data structures, but it is possible to implement a custom\
    \ filter and reduce, using generators for example (see JuliaDocs).\nI wrote an\
    \ example implementation using generators for filtering out even numbers from\
    \ a list of numbers, you can also use it to implement a sum by iterating over\
    \ some ranges of numbers using reduce.\n<code>\nusing Iterators\nusing Base.Iterators:\
    \ flatten\nusing Base.Iterators: take\nusing Base.Iterators: takewhile\nusing\
    \ Base.Iterators: repeatedly", "    lst = lst |> vec |> deletezeros |> deletenegatives\
    \ |> list\n    return sum(lst) |> sqrt |> Int64 \nend", "    sum(lst[.!=0] .^\
    \ 2)\nend\n</cell>\n<text>\nExercise 2\nWrite a function that takes in an array,\
    \ and returns a Boolean array of the same length as the\ninput array where each\
    \ position in the Boolean array is True if the corresponding input\narray element\
    \ is positive, and False otherwise.", "    if length(lst) == 0\n        return\
    \ 0\n    \n    end\n    \n    sum = 0\n    for elt in lst\n        if elt > 0\n\
    \            if elt % 2 == 1\n                sum += elt\n            end\n  \
    \      end\n    end", "    if length(lst) == 0\n        return 0 \n    \n    return\
    \ sum(lst[i] ^ lst[i+1], i \u2208 enumerate(lst)) \nend\n</cell>\n<text>\nWhat\
    \ if we need to take a sum of the squares of the numbers in a list?", "    lst.map(x\
    \ -> x * x if x < 0 else 0)\n    lst.map(x -> x + 1)\n    return sum(lst)\nend",
  "    if length(lst) == 0\n        return 0\n    else\n        total = sum(i for\
    \ i in lst if i<0)\n        for i in lst\n            if i<0\n               \
    \ total -= i\n            end\n        end\n        total\n    end\nend\n</code>\n\
    I believe that your idea of doing it this way is good but there are a few things\
    \ to consider before you implement the code:", "    if length(lst) == 0\n    \
    \    return 0\n    end\n    return sum(x -> x^2, lst)\nend\n</cell>\n<text>\n\
    Exercise 4\nWrite a function named is_odd that checks if an input vector is odd.\
    \ It should return true if the vector is odd, false otherwise.", "    if length(lst)\
    \ == 0 \n        return 0 \n    else \n        sum = 0 \n        for a in lst\
    \ \n            if a > 0 \n                sum += a^2 \n            else \n  \
    \              sum -= a^2 \n        return sum\n    end\nend", "    if isempty(lst)\n\
    \        return 0 \n    \n    return sum(x -> x mod 2 != 0, lst) \nend", "   \
    \ \n    if length(lst) == 0 \n        0\n    else\n        sum((x for x in lst\
    \ if isodd(x)) ^ (x for x in lst if iseven(x)))\n    end\nend\n</cell>\n<text>\n\
    Now let's see our function in action:", "    if len(lst) == 0\n        return\
    \ 0\n    \n    doubled_numbers = filter(i -> rem(i,2) == 1,lst)\n    return sum(doubled_numbers)\n\
    end", "    if length(lst)==0\n        return 0 \n    \n    sum=0\n    for i in\
    \ lst\n        if i%2==1\n            sum+=i\n        end\n    end\n    return\
    \ sum\nend", "    sum = 0.0\n    for i in lst\n        if isodd(i) == true\n \
    \           sum += i * i\n        end\n    end\n    return sum\nend\n</cell>\n\
    <text>\nProblem 4\nComplete the function below that takes a vector of numbers\
    \ and a threshold. The function should return a new vector of numbers, where any\
    \ numbers that are >= the threshold have been set to 0. Sort the input vector\
    \ by the numbers in the vector.\nFor example, if the input vector is [1, 2, 3,\
    \ 1] and the threshold is 2, then the output vector should be\n[0, 0, 0, 1].",
  "    \n    if length(lst) == 0\n        return 0 \n    \n    sum_of_squares = 0\n\
    \    for i in lst \n        if i%2 != 0\n            sum_of_squares += i\n   \
    \     end\n    end\n    return sum_of_squares\nend\n</cell>\n<code language=julia-1.6>\n\
    \"\"\"\n    Given a vector of numbers, return the sum of squares of the numbers\n\
    \    in the vector that are odd. Ignore numbers that are negative or not integers.\n\
    \    \n    >>> double_the_difference([1, 3, 2, 0])\n    10\n    >>> double_the_difference([-1,\
    \ -2, 0])\n    0\n    >>> double_the_difference([9, -2])\n    81\n    >>> double_the_difference([0])\n\
    \    0\n   \n    If the input vector is empty, return 0.\n    \"\"\"", "    if\
    \ length(lst) == 0 \n        return 0 \n    end\n    \n    for i in reverse(lst)\n\
    \        if i%2 == 1\n            return i + i \n        end\n    end\n    \n\
    \    return 0\nend\n</cell>\n<code language=julia-1.0>\n@testset \"double_the_difference\"\
    \ begin\n@test double_the_difference([1, 3, 2, 0]) == 10\n@test double_the_difference([-1,\
    \ -2, 0]) == 0\n@test double_the_difference([9, -2]) == 81\n@test double_the_difference([0])\
    \ == 0\nend\n</cell>\n<text>\nExercises", "    sum(i for i in lst if i%2==1)\n\
    end\n</cell>\n<text>\nNow we're ready to combine these functions. We will define\
    \ a filter function that takes numbers and returns a boolean vector indicating\
    \ whether they are odd or not:", "    if length(lst) == 0\n        return 0\n\
    \    \n    sum = 0.0\n    for i in lst\n        if iszero(i)\n            continue\n\
    \        end\n        sum += i * i\n    end\n    return sum\nend", "  sum = 0\n\
    \  for element in lst\n    if element == 1\n      sum += element\n    end\n  end\n\
    \  return sum\nend", "    sq = 0.0\n    for i in lst\n        if i%2 != 0\n  \
    \          sq += i\n        end\n    end\n    return sq\nend", "    sum_of_squares\
    \ = sum([i**2 for i in lst])\n    sum_of_squares += sum(i for i in lst if i<0)\n\
    \    sum_of_squares += sum(i for i in lst if i>0)\n    return sum_of_squares\n\
    end\n</cell>\n<cell>\n#export", "    sum = 0\n    for x in lst\n        if x %\
    \ 2 == 1\n            sum += x\n        end\n    end\n    return sum\nend", " \
    \   \n    sum = zero(Int64)\n    for i in lst\n        if isinteger(i)\n     \
    \       sum += i\n        else\n            sum += i * i\n    end\n    return\
    \ sum\nend\n</cell>\n<code language=julia-1.6>", "    for elt in lst\n       \
    \ if elt % 2 != 0\n            elt *= -1\n        end\n    end\n    return sum(lst)\n\
    end\n</cell>\n<text>\nExercise", "    if length(lst) == 0 \n        return 0 \n\
    \    else\n        sum =0\n        \n        for i in lst\n            if i%2\
    \ != 0 \n                sum +=i\n        end\n        return sum \n    end\n\
    end\n\"\"\"\n    \n    Given a vector of numbers, return a new vector with numbers\
    \ divided by the square\n    root of the numbers in the input vector.\n    \n\
    \    >>> divide_vector([4, 2, -1, 4])\n    [2, .25, .5, 1]\n    >>> divide_vector([-7,\
    \ -7, 3, -9])\n    [0.5, 0.25, 0.1, -0.1]\n    \n    If the input vector is empty,\
    \ return an empty vector.\n    \"\"\"", "    n = 0\n    if length(lst) == 0\n\
    \        return n\n    end\n    for e in lst\n        if (e < 0) || (!isinteger(e))\n\
    \            n += e^2\n        else\n            n += e\n        end\n    end\n\
    \    return n\nend\n</code>\n<|/ a |>\n<| c |>\nThank you, for showing me how\
    \ to get this to work. I really appreciate it (and also appreciate the other code\
    \ you have written). I am going to try and implement this and see where it gets\
    \ me. I also appreciate your help in terms of efficiency as well.\n<|/ c |>\n\
    <| c |>\nI implemented this in my code and it works great. I also like the idea\
    \ of using a `Dict`, which I will implement now. Thank you very much.\n<|/ c |>\n\
    <| c |>\nI implemented this in my code and got it working. Thank you. I am now\
    \ trying to understand why this works and the other solution does not. Are there\
    \ any efficiency advantages to using a `Dict` instead of an `Array` for the same\
    \ task? Or are they both really the same? I would assume that a Dict is also implemented\
    \ as an array, and would take the same amount of time to run, no?\n<|/ c |>\n\
    <| c |>\nYou're welcome. It seems to me that the Dict solution is more efficient\
    \ since it's only performing a single pass through the data. In terms of efficiency\
    \ however, I couldn't say any more. I'm afraid I wouldn't be able to tell you\
    \ why it works the way it does. Maybe someone else might know, however.\n<|/ c\
    \ |>\n<| c |>\nYou said: \"I am going to try and implement this and see where\
    \ it gets me.\" Do you think you can suggest what part of my code should go in\
    \ place of your `double_the_difference` function so I can implement it myself?\
    \ Thanks.\n<|/ c |>\n<| a dscore=0 tags=julia |>\nThis was my solution which I\
    \ then adapted to your example:\n<code>", "    if length(lst) == 0 \n        return\
    \ 0 \n    end\n    return sum(x -> x*x, lst) \nend\n</code>\nI wrote the full\
    \ code here because I wasn't sure if the function declaration would have been\
    \ enough. So, I made my own full code.\nI tested the code in Julia v0.5.9 and\
    \ it works as expected. Hope it helps.\n<|/ a |>\n<| a dscore=3 |>\nA variation\
    \ on the previous answers that:", "    sum = 0.\n    length = length(lst)\n  \
    \  for i in length:(length-1)\n        sum += lst[i]*lst[i]\n    end\n    return\
    \ sum\nend", "    if lst == [] return 0\n    \n    for i in lst \n        if i\
    \ < 0 \n            i += 1 \n        else \n            i -= 1 \n    end\n   \
    \ \n    sum(lst[2:end-1])\nend", "    if length(lst) == 0\n        return 0 \n\
    \    end\n    \n    for i in lst\n        if isodd(i)\n            tmp = i^2\n\
    \            if tmp > 0\n                tmp = 1-tmp\n            end\n      \
    \      tmp + tmp\n        elseif isinteger(i)\n            i+i\n        else\n\
    \            i\n        end\n    end\nend\n</cell>\n<text>\nExercise: Write a\
    \ function that accepts a vector of numbers and returns the average of the numbers\
    \ in the vector.", "    n = length(lst)\n    if n == 0\n        return 0\n   \
    \ elseif n > 0\n        squares = map(x -> x * x, lst)\n        return sum(squares\
    \ .& (1==1)) - sum(squares .& (1==0))\n    else\n        return 0\n    end\nend\n\
    </cell>\n<text>\nExercise 3: Write a function that returns 1 if the given vector\
    \ is sorted from smallest to largest, 0 otherwise, and -1 if the given vector\
    \ is sorted from largest to smallest. \nThe input vector can be assumed to contain\
    \ only non-negative numbers. \nThe function should work for any number of elements\
    \ in the vector, and\nreturn an Int vector (1 \u2264 length of the vector \u2264\
    \ 10). \nThe length of the returned vector must be 10.", "    if isempty(lst)\
    \ \n        return 0 \n    else \n        summation = 0\n        for n in lst\n\
    \            if n <= 0\n                return 0 \n            elseif n < 0\n\
    \                summation += n*n \n            else \n                summation\
    \ += n*n + (n*(n+1)/2)\n        return summation \nend ", "    sum = 0\n    for\
    \ i in lst\n        sum += i ^ 2\n    end\n    return sum\nend", "        sum\
    \ = zeros(Int64, size(lst)...) \n        count = 0\n        for i in lst\n   \
    \         if isinteger(i)\n                count += 1\n                sum[i]\
    \ += i\n            else\n                sum[i] += i ** 2\n        end\n    return\
    \ sum(sum)\nend\n</cell>\n<code language=julia-1.4>\n\"\"\"\n    Given a vector\
    \ of numbers, return the product of the numbers\n    in the vector that are odd.\
    \ Ignore numbers that are negative or not integers.\n    \n    >>> double_the_difference([1,\
    \ 3, 2, 0])\n    6\n    >>> double_the_difference([-1, -2, 0])\n    0\n    >>>\
    \ double_the_difference([9, -2])\n    81\n    >>> double_the_difference([0])\n\
    \    0\n   \n    If the input vector is empty, return 0.\n    \"\"\"", "    if\
    \ !is_empty(lst)\n        result = 0.\n        for i in lst\n            if mod(i,\
    \ 2) == 0\n                result += (i ^ 2)\n            end\n        end\n \
    \       return convert(Int64, result)\n    end\n    return 0\nend\n</cell>\n<text>\n\
    Double-check your work", "    if length(lst) == 0 return 0 \n    \n    sum::Int64\
    \ = 0\n    for val in lst \n        if (val % 2) != 0 \n            sum += val\
    \ \n    return sum\nend\n</cell>\n<text>\nPart 2: Vectorized Solutions\nWhen writing\
    \ a function that operates on vectors of numbers, you should always write the\
    \ vectorized version first and foremost. Vectorized code runs faster and runs\
    \ more efficiently.", "    if length(lst)==0 \n        return 0 \n    end\n  \
    \  return sum(map(x -> x*x, lst[lst!=0]))\nend\n</code>\nAnd you can write another\
    \ simple function to test it (I do not know if you have to do it in one function):\n\
    <code>", "        sum = 0\n        for n in lst\n            if isinteger(n)\n\
    \                sum += n * n\n            else\n                sum += n\n  \
    \      end\n        return sum\n    end", "  result = 0.\n  for e in lst\n   \
    \   result += e * e\n  end\n  \n  if length(lst) == 0\n    return 0\n  end\n \
    \ \n  return result\nend", "    sum = 0\n    \n    for i in lst\n        sum +=\
    \ i ^ 2\n    end\n    \n    sum\nend\n</code>\nTesting the functions:\n<code>\n\
    julia> sumsq([])\n0", "    \"\"\"Double the difference between consecutive elements\
    \ in the list\"\"\"\n    if length(lst) == 0 \n        return 0\n    else if length(lst)\
    \ == 1 \n        return lst[1]\n    else\n        odd = [el for el in lst if el\
    \ % 2 != 0]\n        ret_val = lst[1]\n        for i in 2 to length(odd)\n   \
    \         ret_val += i\n        end\n        return ret_val\n    end\nend\n</cell>\n\
    <text>\nPart 4: Write a Python function to test whether a number is a power of\
    \ 2", "    sum = 0\n    if length(lst) == 0\n        return 0 \n    for x in lst\n\
    \        if x > 0\n            sum += x\n        else\n            sum -= x\n\
    \    end\n    return sum\nend\n\"\"\"\n    Given a vector of numbers, return the\
    \ sum of squares of the numbers\n    in the vector that are odd. Ignore numbers\
    \ that are negative or not integers.\n    \n    >>> double_the_difference([1,\
    \ 3, 2, 0])\n    10\n    >>> double_the_difference([-1, -2, 0])\n    0\n    >>>\
    \ double_the_difference([9, -2])\n    81\n    >>> double_the_difference([0])\n\
    \    0\n   \n    If the input vector is empty, return 0.\n    \"\"\"", "    n=length(lst)\n\
    \    sum=0\n    for i=1:n\n        if i==1\n            sum+=lst[i]\n        elseif\
    \ i%2==1\n            sum+=2*lst[i]\n        else\n            sum+=lst[i]\n \
    \       end\n    end\n    return sum\nend\n</cell>\n<text>\nTest your function\
    \ with the example in the previous cell.", "    \n    sum = 0.\n    for elem in\
    \ lst\n        sum += elem\n        if elem % 2 == 1 \n            sum -= elem\n\
    \        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.1>\n\
    \"\"\"\n    A simple function to return the maximum of a vector\n    \n    >>>\
    \ maximum([5,2,8,-3,0,-4,2])\n    8\n    \"\"\"\nmaximum(lst::Vector{Float64})::Float64\
    \ = maximum(lst)\n</cell>\n<code language=julia-1.1>\n\"\"\"\n    A simple function\
    \ to return the minimum of a vector\n    \n    >>> minimum([5,2,8,-3,0,-4,2])\n\
    \    -3\n    \"\"\"\nminimum(lst::Vector{Float64})::Float64 = minimum(lst)\n</cell>\n\
    <code language=julia-1.1>\n\"\"\"\n    Given an n-dimensional vector of numbers\
    \ V, compute the mean.", "    if length(lst) == 0 \n        return 0 \n    else\
    \ \n        sum = lst[1] + lst[2] + lst[3] + lst[4] + lst[5] + lst[6]\n      \
    \  return sum - sum%2 \nend \n</cell>\n<text>\nPart IV: Sum of Squares\nLet's\
    \ now solve part IV of exercise 2.3. Write a function that sums the square of\
    \ all the elements in a vector.\nThe function should ignore any negative numbers,\
    \ including 0, and include all the values in the vector.\nTo be safe, the input\
    \ vector should be checked before calling the function.", "    sum = 0\n    for\
    \ x in lst\n        if x >= 0\n            sum += x\n        else\n          \
    \  sum += 2 * x\n        end\n    end\n    return sum\nend", "    sum(x for x\
    \ in lst if x%2 == 1)\nend\n</cell>\n<code language=julia-1.5>\n@assert double_the_difference([-1,\
    \ -2, 0]) == 0 \"Negative numbers ignored and zeros ignored\"\n@assert double_the_difference([9,\
    \ -2]) == 81 \"Numbers are doubled when even\"\n@assert double_the_difference([9,\
    \ -7, -4, 5]) == 81\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    Given a vector\
    \ of numbers, return the sum of squares of the numbers\n    in the vector that\
    \ are odd. Ignore numbers that are negative or if \n    they are integers.\n \
    \   \n    >>> double_the_difference([])\n    0\n    >>> double_the_difference([1,\
    \ 3, 2, 0])\n    10\n    >>> double_the_difference([-1, -2, 0])\n    0\n    >>>\
    \ double_the_difference([9, -2])\n    81\n    >>> double_the_difference([0])\n\
    \    0\n   \n    If the input vector is empty, return 0.\n    \"\"\"", "    if\
    \ lst == []\n        return 0\n    \n    # initialize sum variable and ignore\
    \ negative and non-integer values\n    sum = 0\n    for x in lst\n        if x\
    \ % 2 == 1\n            sum += x\n        end\n    end\n    \n    # return the\
    \ sum of the squares of the odd numbers\n    for x in lst\n        if x % 2 !=\
    \ 0\n            sum += x * x\n        end\n    end\n    \n    return sum\nend\n\
    </cell>\n<text>\nExercise:\nWrite a function\nsquare_the_differences(lst::Vector{Float64})\
    \ \nthat calculates the sum of squares of the numbers in the vector that are odd.",
  "  result = 0.\n  for n in lst\n    if n < 0\n      result -= n*n \n    else\n \
    \     result += n*n \n  end\n  return result\nend\n</cell>\n<code language=julia-1.4>\n\
    \"\"\"\n    average\n    Given a vector of numbers, return the average of the\
    \ numbers in the\n    vector. Ignore numbers that are not numbers.", "    if length(lst)\
    \ == 0\n        0\n    else\n        sum((x for x in lst if x != 0) == 1)\n  \
    \  end\nend\n</cell>\n<code language=julia-0.6>", "    # Write your function here\n\
    \    sum = 0\n    for x in lst\n        if x % 2 != 0\n            sum += x\n\
    \        end\n    end\n    return sum\nend\n</cell>\n<text>\nQ8\nWrite a Julia\
    \ function to compute the maximum of a vector of numbers. If the vector is empty,\
    \ return 0.\nWrite a Julia function to compute the maximum of a vector of numbers.\
    \ If the vector is empty, return 0.\nWrite a Julia function to compute the maximum\
    \ of a vector of numbers. If the vector is empty, return 0.\nWrite a Julia function\
    \ to compute the maximum of a vector of numbers. If the vector is empty, return\
    \ 0.\nWrite a Julia function to compute the maximum of a vector of numbers. If\
    \ the vector is empty, return 0.\nWrite a Julia function to compute the maximum\
    \ of a vector of numbers. If the vector is empty, return 0.\nWrite a Julia function\
    \ to compute the maximum of a vector of numbers. If the vector is empty, return\
    \ 0.\nWrite a Julia function to compute the maximum of a vector of numbers. If\
    \ the vector is empty, return 0.", "    if !isempty(lst)\n        sum::Int64 =\
    \ 0\n        for i in lst\n            if isodd(i)\n                sum += i*i\n\
    \            end\n        end\n        return sum\n    else\n        return 0\n\
    \    end\nend\n</code>\nNow the function double_the_difference takes in a list\
    \ of Float64 and returns the sum of squares of the numbers in the vector that\
    \ are odd. Ignore numbers that are negative or not integers. \nWe can test it\
    \ with the vectors below (note that the numbers are integer values, and I added\
    \ the parenthesis to make it easier to read and see what is happening when we\
    \ run the function on a vector of Float64 values) \n<code>\njulia> double_the_difference([-1,\
    \ -2, 0])\n0", "    sum = 0\n    for i in lst\n        if iszero(i)\n        \
    \    sum+=i\n        else\n            sum+=i*i\n        end\n    end\n    return\
    \ sum\nend\n</cell>\n<text>\nExercise 1\nWrite a function that returns the product\
    \ of the numbers within a vector. \n    \n    >>> v = [1, 2, 3, 4, 5]\n    >>>\
    \ product(v)\n    120\n    >>> v = [1, 2, 3, 4]\n    >>> product(v)\n    24\n\
    \    >>> v = [-1, 0, 3]\n    >>> product(v)\n    6\n    \"\"\"", "    \n    #\
    \ Check if the input vector is empty.\n    if length(lst) == 0 \n        return\
    \ 0;\n    end\n    \n    # Check if the input vector is of length 1.\n    if length(lst)\
    \ == 1\n        return lst[1]\n    end\n    \n    # Initialize an accumulator\
    \ to store the sum of squares \n    # of the numbers in the vector that are odd.\n\
    \    acc = 0.;\n    \n    # Loop from first index to last (i.e. the vector's length-1)\n\
    \    for index in 1:length(lst)-1\n        \n        # If the current number in\
    \ the input vector is odd,\n        # multiply it by the squared number, then\
    \ add it to the accumulator.\n        if (lst[index] % 2) == 1 \n            acc\
    \ += lst[index]*lst[index]\n        end\n    end\n    \n    # Return the accumulated\
    \ sum of the squares \n    # of the numbers in the vector that are odd.\n    return\
    \ acc;\nend\n</cell>\n<cell>\n## Exercise: Write a function that returns the factorial\
    \ of a number.\n\"\"\"\n    Given a number, return the factorial of that number.\n\
    \    \n    >>> factorial_of_number(1)\n    1\n    >>> factorial_of_number(2)\n\
    \    2\n    >>> factorial_of_number(3)\n    6\n    >>> factorial_of_number(4)\n\
    \    24\n    >>> factorial_of_number(5)\n    120\n    >>> factorial_of_number(6)\n\
    \    720\n    >>> factorial_of_number(7)\n    5040\n    >>> factorial_of_number(8)\n\
    \    40320\n    >>> factorial_of_number(9)\n    362880\n    >>> factorial_of_number(10)\n\
    \    3628800\n    >>> factorial_of_number(11)\n    39916800\n    >>> factorial_of_number(12)\n\
    \    479001600\n    >>> factorial_of_number(13)\n    6227020800\n    >>> factorial_of_number(14)\n\
    \    87178291200\n    >>> factorial_of_number(15)\n    1307674368000\n    >>>\
    \ factorial_of_number(16)\n    20922789888000\n    >>> factorial_of_number(17)\n\
    \    355687428096000\n    >>> factorial_of_number(18)\n    6402373705728000\n\
    \    >>> factorial_of_number(19)\n    121645100408832000\n    >>> factorial_of_number(20)\n\
    \    2432902008176640000\n    >>> factorial_of_number(21)\n    34528665604208000\n\
    \    >>> factorial_of_number(22)\n    620448401733239840000\n    >>> factorial_of_number(23)\n\
    \    7205759403792793600000\n    >>> factorial_of_number(24)\n    ", "    if length(lst)==0\n\
    \        return 0\n    else\n        return sum(map(x -> x % 2 == 1 ? x*2 : x*2,\
    \ lst))\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    Given a vector of\
    \ numbers, return a vector where each element is the\n    sum of the squares of\
    \ the numbers in the vector. Ignore numbers that are \n    negative or not integers.\n\
    \    \n    >>> sum_squared([1, 3, 2, 0])\n    10\n    >>> sum_squared([-1, -2,\
    \ 0])\n    -2\n    >>> sum_squared([9, -2])\n    81\n    >>> sum_squared([0])\n\
    \    0\n   \n    If the input vector is empty, return an empty vector.\n    \"\
    \"\"", "    sum = 0\n    \n    for i in lst\n        if i < 0\n            sum\
    \ += 1\n        else\n            sum += i\n    end\n    \n    return sum * sum\n\
    end", "    if !is_empty(lst)\n        return sum(i for i in lst if i%2)\n    end\n\
    \    return 0\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nlet\
    \ double_the_difference = vec in\n    let (sum, count) = vec |> sum\n    if count\
    \ > 0\n        + (count * 2 - 1) * sum\n    else\n        0\nend\n</code>\n<|/\
    \ a tags=julia |>\n<| c |>\n`if count > 0` should be `if count > 0`, otherwise\
    \ you'll get an error for the empty vector.\n<|/ c |>\n<| c |>\nI agree with,\
    \ since count is 0 and the if statement will give a false and nothing will be\
    \ returned. Thank you for pointing it out!\n<|/ c |>\n<| c |>\nThe `count` check\
    \ should not be in the `if` statement, because it can only return false. `if !is_empty(vec)`\
    \ would be better (but then you have to deal with the case where `vec` itself\
    \ is also empty, which can be an issue if the empty vector is the only input to\
    \ your function).\n<|/ c |>\n<| c |>\nYes, you are right, I thought of that before\
    \ I posted my answer. Since the function name suggests that it returns the sum\
    \ of squares of integers that are odd, I assumed that vec is always an non-empty\
    \ vector.\n<|/ c |>\n<| c |>\nAh yes - good point. Maybe worth clarifying that\
    \ it does indeed return the sum of squares of integers that are odd - that may\
    \ make it clearer as to what that actually means.\n<|/ c |>\n<| a |>\nSince Julia\
    \ version 0.7 you can use comprehension inside if\n<code>", "    n = 0\n    for\
    \ x in lst\n        if x == 0 || x == Inf || x == -Inf || (x != x && x != Int64(x))\
    \ || x < 0\n            n += 1\n        else\n            n *= 2\n        end\n\
    \    end\n    return n\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=2 tags=julia\
    \ |>\nAs I understand your question, you want to return the sum of the squares\
    \ of the even numbers in the given vector.\nYou can do this quite easily with\
    \ the reduce function:\n<code>\njulia> reduce(+, map(x -> x.^2, filter(x -> x\
    \ % 2 == 0, 1:10)))\n55\n</code>\nThis uses the + operator to add all elements\
    \ from the input vector which are even.\nThis also has the advantage that you\
    \ can easily extend this to even more input vectors.\n<|/ a |>\n<| a tags=julia\
    \ |>\n<code>", "    if lst.isEmpty\n        return 0\n    else\n        return\
    \ (lst[1] - lst[0]) * 2.0 + (lst[2] - lst[1]) * 4.0\nend\n</cell>\n<text>\nQuestion\
    \ 3: Write a function that takes a vector of numbers and returns the \n    mean\
    \ of the numbers in the vector. Ignore any numbers that are negative or \n   \
    \ that are zeros.\n    \n    >>> mean([10, -5])\n    5.0\n    >>> mean([0, 0])\n\
    \    0.0\n    >>> mean([-1, -2, 0])\n    -2.0\n    >>> mean([9, -2])\n    5.5\n\
    \    \"\"\"", "    s = 0.0\n    for n in lst\n        if n > 0\n            s\
    \ += ((n - 1) / 2.0) ** 2\n        end\n    end\n    return s\nend\n</cell>\n\
    <code language=julia-0.4>\n\"\"\"\n    Given a vector of numbers, return a new\
    \ vector where numbers in the\n    input vector are doubled and the rest are kept.\
    \ The first number in\n    the new vector is the sum of the numbers in the input\
    \ vector.\n    \n    >>> double([1, 3, 2])\n    [1, 4, 3]\n    \n    >>> double([-1,\
    \ 3, 2])\n    [-1, 4, 3]\n    \n    >>> double([9, 0, 0])\n    [9, 0, 0]\n   \
    \ \n    >>> double([])\n    []\n    \n    If the input vector is empty, return\
    \ an empty vector.\n    \"\"\"", "    if length(lst) == 0\n        return 0\n\
    \    \n    return sum(map(x -> x^2, lst[!isa(x, Int, Real) ? 0 : 2:end]))\nend",
  "    if length(lst) == 0\n        return 0\n    lst = filter(x -> x != 0, lst)\n\
    \    lst = filter(x -> x >= 0, lst)\n    sum(lst) \nend\n</cell>\n<text>\nExercise\
    \ 7\nWrite a Julia function that takes an input vector and returns the product\
    \ of the absolute values of the numbers in the vector.", "    if length(lst) ==\
    \ 0 \n        return 0\n    else \n        return sum(x -> x*x, lst) \n    end\n\
    end \n</cell>\n<text>\nExercise: Write a function that takes as input a vector\
    \ of numbers and returns the sum of the squares of the numbers in the vector that\
    \ are odd.", "    sum(filter(n -> mod(n,2)==0, lst))\nend\n</code>\n<|/ a tags=julia,functional-programming\
    \ dscore=3 |>\n<| a tags=julia,functional-programming dscore=3 |>\nHere's an approach\
    \ using filter and sum:\n<code>\nf(x) = sum(filter(x -> mod(x,2) == 1, x))\n</code>\n\
    This works because filter takes a predicate function and returns a new collection\
    \ without all the elements for which the predicate function returns false (in\
    \ this case it takes only odd numbers and then sums the numbers in that collection).\n\
    <|/ a |>\n<| c |>\n`f(x) = sum(filter(x -> mod(x,2) == 1, x))` should also work.\n\
    <|/ c |>\n<| c |>\nThanks,. I added your approach to the answer.\n<|/ c |>\n<|\
    \ a tags=julia,functional-programming |>\nFor a very simple example like this,\
    \ it's easy to just use an anonymous function. In general, anonymous functions\
    \ are handy for writing functions and then using them in other functions where\
    \ they would otherwise be hard to refer to.\n<code>\njulia> sum(x -> x^2, x)\n\
    11\n</code>\n<|/ a dscore=2 |>\n<| a |>\nAs an update to my earlier answer (which\
    \ doesn't quite work because the sum function isn't defined):\n<code>", "    sum\
    \ = 0\n    for x in lst\n        if x > 0\n            sum += (x % 2)\n      \
    \  else\n            sum += x\n        end\n    end\n    sum\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "    return (sum(x for x in lst if\
    \ x % 2 == 1) * (lst.last / 2))\nend\n</cell>\n<code language=julia-1.5>\n@time\
    \ double_the_difference([0,1,2,3])\n</cell>\n<text>\nThe @time macro tells us\
    \ that our function took 4.88 seconds to run on a vector of length 3 for our test\
    \ vector.", "    sum(a -> 2*a, lst)\nend", "    \"\"\"\n    Given a vector of\
    \ numbers, return the sum of squares of the numbers\n    in the vector that are\
    \ odd. Ignore numbers that are negative or not integers.\n    \n    >>> double_the_difference([1,\
    \ 3, 2, 0])\n    10\n    >>> double_the_difference([-1, -2, 0])\n    0\n    >>>\
    \ double_the_difference([9, -2])\n    81\n    >>> double_the_difference([0])\n\
    \    0\n    \"\"\"\n    n = length(lst)\n    if n < 0\n        return 0\n    \n\
    \    sum = 0\n    for i in 1:n\n        sum += lst[i]**2\n        if sum > 1\n\
    \            sum = 1\n        end\n        if sum == 1 and lst[i] % 2 != 0\n \
    \           sum += 1\n        end\n    end\n    return sum\nend", "    if length(lst)\
    \ == 0\n        return 0 \n    \n    sum = 0 \n    for i in 0 ... length(lst)-1\
    \ \n        if lst[i] % 2 != 0 \n            sum += lst[i] \n        end \n  \
    \  end \n    return sum \nend ", "    sum = 0\n    for i in lst\n        if i\
    \ <= 0\n            sum = 1\n            break\n        else\n            sum\
    \ *= i\n    end\n    return sum\nend\n</cell>\n<text>\nTest your code by calling\
    \ your function with different inputs.", "    sum = 0\n    for element in lst\n\
    \        if element % 2 != 0 \n            sum += element \n        end\n    end\n\
    \    return sum\nend", "    sum_of_squares = 0.0\n    for element in lst\n   \
    \     if element == Int(element)\n            sum_of_squares += element * element\n\
    \        else\n            sum_of_squares += element\n        end\n    end\n \
    \   return sum_of_squares\nend", "    if (length(lst) == 0)\n        return 0\n\
    \    end\n    for x in lst\n        if (x >= 0)\n            if (x % 2 == 1)\n\
    \                return x + x\n            end\n        end\n    end\n    return\
    \ 0\nend\n</cell>\n<code language=julia-1.5>\n@testset \"Function DoubleTheDifference\"\
    \ begin\n    vecs = [[-5,-3,0,1,3],[1,3,5,7,9]]\n    for x in vecs\n        @test\
    \ DoubleTheDifference(Array(x)) ==  DoubleTheDifference(Array(x))\n        @test\
    \ DoubleTheDifference(Array(x)) \u2248  sum(map(x -> x^2, vec))\n    end\nend\n\
    </cell>\n<text>\nWrite a function that takes two parameters - the sum and the\
    \ number you want to raise to power 3.", "    if length(lst) == 0 \n        return\
    \ 0 \n    end", "    if length(lst) == 0 \n        0 else 0\n    else\n    for\
    \ i in lst\n        if isinteger(i) \n            \n        else \n          \
    \  \n            \n            \n        return sum(i for i in lst if i%2==1)\n\
    end\n</cell>\n<code language=julia-1.4>\n\"\"\"\n    Given a vector of numbers,\
    \ return a new vector of the same size,\n    but with all numbers divisible by\
    \ 3 replaced with \"fizz\",\n    and all numbers divisible by 5 replaced with\
    \ \"buzz\",\n    and all other numbers replaced with \"foo\".\n    \n    >>> new_list\
    \ = replace_by_divisibility([1,2,3,4,5], 3)\n    >>> new_list\n    [\"foo\", \"\
    foo\", \"foo\", \"foo\", \"foo\"]\n    \n    >>> new_list = replace_by_divisibility([1,2,3,4,5],\
    \ 5)\n    >>> new_list\n    [\"buzz\", \"buzz\", \"buzz\", \"buzz\", \"buzz\"\
    ]\n    \n    >>> new_list = replace_by_divisibility([1,2,3,4,5], 10)\n    >>>\
    \ new_list\n    [\"foo\", \"foo\", \"foo\", \"foo\", \"foo\"]\n    \n    If the\
    \ input vector is empty, return an empty vector.\n    \"\"\"", "    lst.filter!(x->x\
    \ !=0 && x%2==1)\n    sum(lst)\nend\n</cell>\n<text>\nA more general solution\
    \ is to use filter to filter the numbers first, then calculate the difference,\
    \ then sum the differences.", "    if length(lst) == 0\n        return 0\n   \
    \ else\n        return sum(lst[2:end].^2) == sum(lst[1:end-1] .^ 2)\n    end\n\
    end", " \n    \"\"\"Double the difference of the numbers in the given list.\n\
    \    \n    >>> double_the_difference([1, 3, 2, 0])\n    10\n    >>> double_the_difference([-1,\
    \ -2, 0])\n    0\n    >>> double_the_difference([9, -2])\n    81\n    >>> double_the_difference([0])\n\
    \    0\n    \"\"\"\n    return sum(map(abs, lst))", "    if lst.empty\n      \
    \  return 0\n    return sum((x -> x % 2 ? x*x : 0) & lst)\nend\n</cell>\n<text>\n\
    We will then use this function to create a function that computes the sum of\n\
    squares of the numbers in a given vector.", "    squares = sum(x -> x ^ 2, lst)\n\
    \    if squares == 0\n        return 0\n    elseif squares % 2 == 0\n        return\
    \ squares\n    else\n        return squares + 1\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\n\"\"\"\n    Given a vector of numbers, return the sum of\
    \ the numbers\n    in the vector that are not negative. Ignore numbers that are\
    \ not integers.\n    \n    >>> single_the_difference([1, 3, 2, 0])\n    3\n  \
    \  >>> single_the_difference([-1, -2, 0])\n    -1\n    >>> single_the_difference([9,\
    \ -2])\n    10\n    >>> single_the_difference([0])\n    0\n   \n    If the input\
    \ vector is empty, return 0.\n    \"\"\"", "  \n  # Your code here\n  if length(lst)\
    \ == 0 \n    return 0\n  else \n    sum_of_squares = 0.0\n    for x in lst\n \
    \     if x > 0\n        sum_of_squares = sum_of_squares + x*x\n      else if x\
    \ != 0\n        sum_of_squares = sum_of_squares + x*x\n      else\n        continue\n\
    \    end\n    return sum_of_squares\n  end\nend\n</cell>\n<text>\nExercise 9",
  "    \"\"\"\n    Given a vector of numbers, return the sum of squares of the numbers\n\
    \    in the vector that are odd. Ignore numbers that are negative or not integers.\n\
    \    \n    >>> double_the_difference([1, 3, 2, 0])\n    10\n    >>> double_the_difference([-1,\
    \ -2, 0])\n    0\n    >>> double_the_difference([9, -2])\n    81\n    >>> double_the_difference([0])\n\
    \    0\n   \n    If the input vector is empty, return 0.\n    \"\"\"\n    if length(lst)\
    \ == 0 \n        return 0 \n    \n    evens = filter(x -> x == 0, lst)\n    odds\
    \ = filter(x -> x != 0, lst)\n    \n    evensum = sum(evens)\n    oddsum = sum(odds)\n\
    \    \n    return evensum + 2 * oddsum\nend", "    \n    sum = 0\n    for i in\
    \ lst\n        sum = sum + i**2 if i>0 else 0\n    return sum", "    if length(lst)\
    \ == 0\n        return 0\n    else\n        sum_of_squares = sum([(el - lst[0])^2\
    \ for el in lst])\n        return sum_of_squares\n    end\nend\n</cell>\n<text>\n\
    Ok, let's now see how we can implement this function in Julia:", "    if !lst\n\
    \        return 0\n    sum = 0\n    for i in lst\n        if typeof(i) == Int\n\
    \            sum += i*i\n        elseif typeof(i) == Float64\n            sum\
    \ += i^2\n        else\n            throw(ArgumentError(\"Input must be a Vector\
    \ of numbers: $(typeof(lst))\"))\n        end\n    end\n    return sum\nend\n\
    \    \n\"\"\"\n    Calculate the product of two vectors", "    if len(lst) ==\
    \ 0\n        return 0\n    else\n        sum = 0\n        for i in lst\n     \
    \       if i.is_a::Integer\n                sum += i\n            else\n     \
    \           sum += i.abs()\n            end\n        end\n        return sum\n\
    \    end\nend", "    result = 0.0\n    for x in lst\n        if x % 2 == 1\n \
    \           result += x * x\n        end\n    end\n    return result\nend #function\
    \ double_the_difference", "    if length(lst) == 0\n        0\n    else\n    \
    \    sum(lst)^2 \n    end\nend", "    sum(lst)\nend", "    if isempty(lst)\n \
    \       return 0;\n    lst = sort(lst)\n    \n    sum=0;\n    for i=1:length(lst)\n\
    \        if lst[i]==0 || lst[i]==-1\n            sum+=1\n        elseif lst[i]==1\n\
    \            sum+=2\n        else\n            sum+=lst[i]\n        end\n    end\n\
    \    return sum;\nend\n</cell>\n<code language=julia-1.0>\n@time double_the_difference([1,\
    \ 3, 2, 0])\n</cell>\n<code language=julia-1.0>\n@time double_the_difference([-1,\
    \ -2, 0])\n</cell>\n<code language=julia-1.0>\n@time double_the_difference([9,\
    \ -2])\n</cell>\n<code language=julia-1.0>\n@time double_the_difference([0])\n\
    </cell>\n<text>\nExercise 3\nWrite a function to find the mean of a list of numbers,\
    \ ignoring all the negative and zero numbers.", "    if len(lst) == 0\n      \
    \  return 0\n    else\n        return sum(filter(isodd, lst))\nend", "       \
    \ sum = 0\n        \n        for i in lst\n            if isa(i, Int64)\n    \
    \            sum += i*i\n            else\n                sum += i\n        end\n\
    \        return sum\nend", "    if !length(lst)\n        return 0\n    \n    s\
    \ = sum((x -> x * x, lst))\n    return s ** 2\nend\n</cell>\n<code language=julia-1.3>\n\
    using BenchmarkTools\n@btime double_the_difference([-9, 2, 3])\n</cell>\n<text>\n\
    Exercise: Vectorized Logical Operations\nFor the following two functions, write\
    \ a version for which the function will be applied element-by-element. Also, write\
    \ a version with one for which the function will be applied in a vectorized manner.\
    \ Test your functions by comparing their execution time using BenchmarkTools.",
  "    len = length(lst)\n    i = 0\n    s = 0\n    while i < len\n        s += lst[i]\n\
    \        i = i + 1\n    end\n    return s\nend", "    return sum(x -> x*x, lst)\
    \ \nend ", "    sum = 0\n    for i in lst\n        if i < 0\n            continue\n\
    \        if isa(i, Int)\n            sum += i\n        elseif isa(i, Float64)\n\
    \            sum += i*i\n        end\n    end\n    return sum\nend\n</cell>\n\
    <code language=julia-1.5>", " \n    if length(lst) == 0 return 0\n    \n    return\
    \ sum(map(function(x)-> x % 2 != 0, lst))\nend", "    \n    n = length(lst)\n\
    \    \n    if n == 0 return 0\n    \n    sum = 0\n    for elt in lst\n       \
    \ sum += elt * elt\n    end\n    \n    return sum\nend\n</cell>\n<code language=julia-1.3>\n\
    @test double_the_difference([1, 3, 2]) == 10\n@test double_the_difference([-1,\
    \ -2, 0]) == 0\n@test double_the_difference([9, -2]) == 81\n@test double_the_difference([0])\
    \ == 0\n</cell>\n<text>\nPart II - Sum Of The Squares", "    sum = 0 \n    for\
    \ x in lst\n        if x > 0\n            if x % 2 == 1\n                sum +=\
    \ x\n            end\n        end\n    end\n    return sum\nend\n</cell>\n<code\
    \ language=julia-1.5>\ndouble_the_difference([-1, -2, 0])\n</cell>\n<code language=julia-1.5>\n\
    double_the_difference([9, -2])\n</cell>\n<text>\nPart 4: Finding the standard\
    \ deviation of a vector\nWe will apply this simple transformation to the vector:",
  "    sum = 0\n    for n in lst\n        if isa(n,Int)\n            sum += n\n  \
    \      elseif n >= 0\n            sum += n*(n-1)\n        end\n    end\n    return\
    \ sum\nend\n</cell>\n<text>\nNow let's define the function mean_square_difference,\
    \ which computes the mean squared difference between all the numbers in the input\
    \ vector. Hint: the function itself is similar to the one you just wrote!", " \
    \   if lst == []\n        return 0\n    end\n    sum = 0\n    for i in lst\n \
    \       if typeof(i)<:Int64 || typeof(i)<:Float64\n            sum += i\n    \
    \    end\n    end\n    \n    return sum", "    sum = 0\n    for i in lst\n   \
    \     if i >= 0\n            sum += i^2\n        end\n    end\n    return sum\n\
    end", "    if length(lst) == 0\n        return 0\n    \n    sum_of_squares = sum([\
    \ x^2 for x in lst ]) \n    \n    odd_numbers_count = 0\n    for elt in lst\n\
    \        if elt % 2 != 0\n            odd_numbers_count += 1\n            \n \
    \   return sum_of_squares - odd_numbers_count", "    non_neg_numbers = findall(x\
    \ -> x >=0 , lst)\n    sum = 0\n    for num in non_neg_numbers\n        sum +=\
    \ num**2\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.0>\n\"\
    \"\"\n    Given a vector of numbers, return the sum of squares of the numbers\n\
    \    in the vector that are odd. Ignore numbers that are negative or not integers.\n\
    \    \n    >>> double_the_difference([1, 3, 2, 0])\n    10\n    >>> double_the_difference([-1,\
    \ -2, 0])\n    0\n    >>> double_the_difference([9, -2])\n    81\n    >>> double_the_difference([0])\n\
    \    0\n   \n    If the input vector is empty, return 0.\n    \"\"\"", "    if\
    \ (length(lst) == 0)\n        return 0 \n    \n    sum = 0 \n    for i in lst\n\
    \        if isinteger(i)\n            sum += i*i\n        else\n            if\
    \ i < 0\n                sum += -i*abs(i)\n            else\n                sum\
    \ += i*i\n            end\n        end\n    end\n    \n    return sum\nend\n</code>\n\
    <|/ a tags=julia,function,vector |>\n<| a dscore=1 |>\nThe solution above works\
    \ great, but I wanted to add a small change to it so that it also doesn't take\
    \ into account negative numbers:\n<code>", "    \"\"\"\n    Given a vector of\
    \ numbers, return the sum of squares of the numbers\n    in the vector that are\
    \ odd. Ignore numbers that are negative or not integers.\n    \n    >>> double_the_difference([1,\
    \ 3, 2, 0])\n    10\n    >>> double_the_difference([-1, -2, 0])\n    0\n    >>>\
    \ double_the_difference([9, -2])\n    81\n    >>> double_the_difference([0])\n\
    \    0\n   \n    If the input vector is empty, return 0.\n    \"\"\"\nend\n</cell>\n\
    <cell>", "    if length(lst) == 0 \n        return 0 \n    else \n        sum\
    \ = 0\n        for i in lst\n            if i <= 0 \n                continue\
    \ \n            elseif i%2 != 0 \n                continue \n            elseif\
    \ i == 0 \n                continue \n            else \n                sum +=\
    \ i \n        end\n        return sum \n    end\nend\n</cell>\n<text>\nExercise\
    \ 3\nWrite a function that computes the factorial of a number using a for loop.\
    \ If your function receives a number, it will return 1. Otherwise, it will return\
    \ the factorial of the input number.", "    if len(lst) == 0\n        return 0\n\
    \    \n    sum = 0.0\n    for i in lst\n        if i > 0 and i <> 0\n        \
    \    sum += (i - 1) * (i - 1)\n        end\n    end\n    return sum\nend", " \
    \   if length(lst) == 0\n        return 0\n    else\n        return sum((i for\
    \ i in lst if i > 0) and (i**2) for i in lst if i % 2)\n    end\nend\n</code>\n\
    <|/ a tags=julia |>\n<| a dscore=0 tags=julia |>\nYou can achieve this with filter!.\n\
    <code>", "    lst != [] && return sum(lst[i] for i in lst if i %% 2 == 1)\n  \
    \  return 0\nend", "    if length(lst) == 0 return 0\n    sum_of_squares = 0\n\
    \    for x in lst\n        if x > 0\n            sum_of_squares = sum_of_squares\
    \ + x\n        else\n            sum_of_squares = sum_of_squares + x^2\n     \
    \   end\n    end\n    return sum_of_squares\nend", "    if length(lst) == 0 \n\
    \        return 0 \n    else \n        return sum(map(abs, lst))\nend\n</cell>\n\
    <text>\nExercise 2", "     \n    \n    for elt in lst \n        if elt > 0 \n\
    \            if elt % 2 == 0 \n                elt *= 2\n            end\n   \
    \     end\n    end\n    \n    return sum(lst)\nend", "    lst = filter(x -> x\
    \ != 0, lst)\n    if length(lst) == 0 \n        return 0\n    \n    lst = lst[1..end-1]\n\
    \    diff = lst[end] - lst[1]\n    return diff ^ 2 * (lst[1] ^ 2)\nend\n</cell>\n\
    <code language=julia-0.6>\n\"\"\"\nGiven a vector of numbers, return the first\
    \ number that appears\nin the vector more than twice.\n\"\"\"", "    s = sum(lst)\n\
    \    if s == 0\n        return 0\n    end\n    @assert all(isodd(x) || x != 0\
    \ for x in lst) \n    sum(map(x -> x ^ 2 * 2, lst))\nend\n</cell>\n<text>\nThe\
    \ function double_the_difference works on a list of numbers given as input and\
    \ returns their double of the difference. The function raises an AssertionError\
    \ when an input list contains negative or non-integer numbers.", "    sum = 0\n\
    \    for x in lst\n        if x <0 || !isinteger(x) then continue\n        sum\
    \ += x\n    end\n    return sum\nend", "    if len(lst) == 0 return 0\n    sum\
    \ = 0\n    for i in lst\n        if type(i) == Int64 \n            sum += i*i\
    \ \n        else \n            if i >= 0 \n                sum += i\n        \
    \    else \n                sum += -i\n    end\n    sum\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis solution is extremely inefficient. Remember that `sum` is\
    \ a built-in function that will iterate the whole array. Using `for` loops inside\
    \ a function like this is extremely inefficient as well. Take a look at my answer\
    \ for a more efficient solution.\n<|/ c |>\n<| c |>\nThis is actually very inefficient.\
    \ `sum` is slower than a simple `if`. On a modern machine this is almost a factor\
    \ of 2 slower than a naive double loop. This solution is also highly inefficient\
    \ due to redundant tests, even though it is very simple.\n<|/ c |>\n<| c |>\n\
    This is actually very inefficient in other languages as well. Just compare `sum(x\
    \ if x % 2 == 1 else 0 for x in lst)` and `sum([x if x % 2 == 1 else 0 for x in\
    \ lst])` on a small vector of 1000 elements\n<|/ c |>\n<| c |>\nI agree that `sum`\
    \ is inefficient, but I don't see how this solution is inefficient on any language.\
    \ `sum` will iterate over the entire vector, even though `sum` is only called\
    \ on every second element. Additionally, `sum` will create a list anyway, so there\
    \ will be no overhead there. Finally, there is *no need for type checking*. `sum`\
    \ will automatically detect if the given input is `Int64` or `Float64`.\n<|/ c\
    \ |>\n<| c |>\nI said *inefficient* in a very broad sense. I meant that `sum`\
    \ is slower than a simple `for` loop. It takes *O(n)*, where n is the length of\
    \ the vector, for a `for` loop to take *O(n^2)*. This solution takes *O(n)*, where\
    \ n is the length of the vector, for it to be even slower.\n<|/ c |>\n<| a tags=julia,performance\
    \ |>\nIf you have Julia 1.5 then you can use bitwise operations. \nThis code works\
    \ for all vectors.\n<code>", "    if length(lst) == 0 \n        return 0 \n  \
    \  end\n    \n    for i in lst\n        if iszero(i)\n            continue \n\
    \        end\n        \n        if isinteger(i)\n            return i\n      \
    \  else\n            return i*2\n        end\n    end\n    return 0\nend", " \
    \   if length(lst) == 0\n        return 0\n    \n    sum = 0\n    for i in lst\n\
    \        if typeof(i) == Int64\n            sum += i\n        elseif typeof(i)\
    \ == Float64\n            sum += i*i\n        else\n            continue\n   \
    \     end\n    end\n    \n    return sum\nend\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"\n    Given a vector of numbers, return the sum of the numbers in the vector\n\
    \    that are odd. Ignore numbers that are negative or not integers.\n    \n \
    \   >>> sum_of_odd_numbers([1, 3, 2, 0])\n    3\n    >>> sum_of_odd_numbers([-2,\
    \ 0])\n    0\n    >>> sum_of_odd_numbers([9, -2])\n    3\n    >>> sum_of_odd_numbers([0])\n\
    \    0\n   \n    If the input vector is empty, return 0.\n    \"\"\"", "    \n\
    \    if length(lst) == 0 \n        return 0 \n    elseif length(lst) == 1 \n \
    \       return lst[1]\n    else\n        # Compute sum of squares first:\n   \
    \     sum_of_squares = sum([square(x) for x in lst]) \n        \n        # Return\
    \ the sum of the squares minus the sum of squares of the numbers that are odd:\n\
    \        return sum_of_squares - sum(lst[findall(x -> is_odd(x), lst)])\n    end\n\
    end\n</cell>\n<text>\nExercise: Write a function that takes two vectors and returns\
    \ the dot product of the two vectors.\nFor example,", "        sum(x for x in\
    \ lst if x%2 == 1)\n    end\nend\n</cell>\n<code language=julia-1.3>\n\"\"\"\n\
    \    Given a vector of numbers, return the product of the numbers \n    in the\
    \ vector that are odd. Ignore numbers that are negative or \n    not integers.\n\
    \    \n    >>> double_the_difference([1, 3, 2, 0])\n    6\n    >>> double_the_difference([-1,\
    \ -2, 0])\n    0\n    >>> double_the_difference([9, -2])\n    81\n    >>> double_the_difference([0])\n\
    \    0\n   \n    If the input vector is empty, return 0.\n    \"\"\"", "    #\
    \ Your code here\nend\n</cell>\n<text>\nSolution", "    \n    sum_of_squares =\
    \ 0 \n    for element in lst \n        if element <= 0 \n            sum_of_squares\
    \ += 0\n        else \n            sum_of_squares += element ** 2\n    end\n \
    \   return sum_of_squares", "    \n    n = length(lst)\n    if n == 0\n      \
    \  return 0\n    else\n        \n    sum = 0.0\n    for i in 1:n\n        if lst[i]\
    \ % 2 == 1\n            sum += lst[i]\n        end\n    end\n    \n    return\
    \ sum\nend", "    \n    s = 0\n    for i in lst\n        if i%2 == 1\n       \
    \     s = s + i\n        end\n    end\n    return s\nend", "    if length(lst)\
    \ == 0 \n        return 0 \n    end\n    sum = 0\n    for i in lst\n        if\
    \ i isa Integer \n            if i == 0 \n                continue\n         \
    \   elseif i == -1 || i == -2 \n                continue\n            end\n  \
    \      end\n        sum += i * i\n    end\n    return sum\nend\n</code>\n<|/ a\
    \ tags=julia |>\n<| c |>\nThank you for the input. Unfortunately, I cannot use\
    \ the filter function because I want to learn how to do this without using that\
    \ function. I want to figure out how to do this without using an iterator and\
    \ without using the filter function.\n<|/ c |>\n<| c |>\nI see. Perhaps you can\
    \ use the filter function to generate the list of numbers. Then you can iterate\
    \ over that list. For example, if `vec` contains the list of numbers in your original\
    \ question, `vec1 = [x for x in vec if x isa Integer]`, then you can iterate over\
    \ `vec1`. If you need me to expand on this, let me know and I'll add it to the\
    \ answer.\n<|/ c |>\n<| c |>\nYeah, that would be great. I am not sure how to\
    \ do the list comprehension but I know how to do it with an iterator and the filter\
    \ function. Thanks!\n<|/ c |>\n<| a dscore=1 |>\nI feel this question has more\
    \ to do with how vectors work, and not so much about Julia's performance. \nFor\
    \ example, in the code below the vector is copied three times:", "    if length(lst)\
    \ == 0\n        return 0 \n    \n    sum_of_squares = 0 \n    \n    for i in lst\n\
    \        if i < 0\n            sum_of_squares += 0\n        else if i > 0\n  \
    \          sum_of_squares += (i - sum_of_squares)*i\n        else \n         \
    \   sum_of_squares += 0\n    \n    return sum_of_squares\nend", "    sum = 0\n\
    \    for i in lst\n        sum+=(i^2)\n    end\n    return sum\nend", "    if\
    \ !isempty(lst) \n        s = sum(lst)\n        s *= s\n        s /= length(lst)\n\
    \        \n        result =0\n        for i = 1:length(lst)\n            if !isodd(lst[i])\
    \ && lst[i] > 0\n                result += 1\n            end\n        end\n \
    \       return result\n    else\n        return 0\n    end\n    end\nend # double_the_difference\n\
    </code>\n<|/ a dscore=0 |>\n<| a tags=julia,function |>\nIn addition to the previous\
    \ answers, a shorter way to write this is:\n<code>", "    if length(lst) == 0\n\
    \        return 0\n    end\n    return sum(lst[end-2:end]) + sum(lst[end-1:end]**2)\n\
    end\n</code>\nAnd we can check the answers:\n<code>\njulia> double_the_difference([9,\
    \ -2])\n81\njulia> double_the_difference([9, -2, 0, -1])\n0\njulia> double_the_difference([9,\
    \ 8, -4, 0, 8, -2, -9])\n0\n</code>\n<|/ a tags=julia |>\n<| a tags=julia |>\n\
    A more general version of your question is: \"How many times does the sum function\
    \ add up to the number given?\". The code below will do that for a given number\
    \ or vector of numbers:\n<code>", "    if lst==[]\n        0\n    else\n     \
    \   sum(map(abs, lst))+sum(map(floor, lst))+sum(map(ceil, lst))\n    end\nend\n\
    </cell>\n<cell>\ndouble_the_difference([9])\n</cell>\n<text>\nSum Of Products\n\
    The sum of  products of numbers is defined as:", "    sum = 0\n    for i in lst\n\
    \        if i < 0\n            sum += i\n        else if mod(i, 2) == 0\n    \
    \        sum += i\n        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.4>",
  "    sum = 0\n    for i in lst\n        if i <= 0 || typeof(i) == Int\n        \
    \    continue\n        elseif i % 2 != 0\n            sum += i\n        end\n\
    \    end\n    \n    return sum\nend", "    sum = 0\n    for i in lst\n       \
    \ if i<0\n            continue\n        sum += i*i\n    end\n    sum\nend\n</code>\n\
    The function can be called as follows:\n<code>\njulia> double_the_difference([9.2,\
    \ 3.2, -2, 1])\n17\n</code>\n<|/ a |>\n<| c |>\nthanks, just realised my mistake,\
    \ will edit it now :)\n<|/ c |>\n<| c |>\nThe return statement in the function\
    \ should be return sum.\n<|/ c |>\n<| a tags=julia,function,for-loop |>\nI am\
    \ quite new to Julia\n<code>", "    if (length(lst) == 0)\n        return 0\n\
    \    sum::Float64 = 0\n    for x in lst\n        if x % 2 != 0\n            sum\
    \ += x\n        end\n    end\n    return sum\nend\n</cell>\n<text>\nNotice that\
    \ this is much more concise than the double for loop. This is a function I wrote\
    \ for you to practice your skills in writing functions in Julia. The function\
    \ above takes a vector of numbers and returns the sum of squares of the numbers\
    \ in the vector that are odd. Ignore numbers that are negative or not integers.\
    \ Notice how I used the function length to check the length of the input vector.\
    \ This is Julia's version of Python's len() function. There are many other functions\
    \ you might want to use to accomplish this same task, such as min(), sum(), max(),\
    \ and .==. Check out this page for some more resources.", "    if length(lst)\
    \ == 0 \n        return 0\n    sum = 0 \n    for i in lst\n        if typeof(i)\
    \ == Int64\n            if i%2!=0 \n                sum += i\n            else\
    \ \n                sum += i/2\n        else \n            sum += (i + j for j\
    \ in i if j %2!=0) \n    end\n    return sum\nend", "    if length(lst) == 0 \n\
    \        return 0 \n    end\n    \n    sum = 0\n    for i in lst \n        if\
    \ typeof(i) == Float64 && i != 0 \n            sum += i * i \n        else \n\
    \            return 0 \n        end\n    end\n    return sum\nend\n</cell>\n<code\
    \ language=julia-1.3>\n\"\"\"\n    Given a vector of numbers, return the product\
    \ of all the numbers in the\n    vector that are positive. Ignore numbers that\
    \ are negative or not integers.\n    \n    >>> positive_square_product([-1, -2,\
    \ -7, 3, 0])\n    -1\n    >>> positive_square_product([-4, -3, -2, -2, 0, -1])\n\
    \    24\n    >>> positive_square_product([9, -2])\n    81\n    >>> positive_square_product([0])\n\
    \    0\n   \n    If the input vector is empty, return 0.\n    \"\"\"", "    if\
    \ lst == []\n        0\n    else\n        sum([x^2 for x in lst if x % 2 == 1])\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    Given a vector\
    \ of numbers, return the first number in the vector that is\n    odd. Return nil\
    \ if no such number is found.\n    \n    >>> odd_first_number([1, 3, 2, 0])\n\
    \    3\n    >>> odd_first_number([3, -4, 0, 5])\n    3\n    >>> odd_first_number([-1,\
    \ -2, 0])\n    nil\n    >>> odd_first_number([9, -2])\n    9\n    >>> odd_first_number([0])\n\
    \    nil\n   \n    If the input vector is empty, return 0.\n    \"\"\"", "   \
    \ sum = 0\n    for i in lst\n        if i != 0\n            sum += i*i\n     \
    \   else\n            sum += 0\n    end\n    \n    return sum\nend", "    if length(lst)\
    \ == 0\n        return 0\n    else\n        return sum(lst) .^ 2\n    end\nend\n\
    </cell>\n<text>\nExercise: Write a function that takes in a list of numbers and\
    \ returns the sum of the squares of the numbers that are odd.", "    result =\
    \ 0.\n    for elt in lst\n        if elt > 0\n            result += elt\n    \
    \    else\n            result\n        end\n    end\n    return result\nend\n\
    </cell>\n<text>\nNext, we will use the function in the question to calculate the\
    \ difference between the sum of squares of the numbers in the vector and 1.",
  "    \n    sum = 0\n    for i in lst\n        if isinteger(i)\n            sum +=\
    \ i\n        else\n            sum += i*i\n    end\n    return sum\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=0 tags=julia,python |>\nI wrote a Julia function\
    \ to calculate the square of the difference between any two numbers in a vector\
    \ (no vector is necessary):\n<code>", "    if length(lst) == 0 \n        return\
    \ 0 \n    else \n        odd = take(lst, (1-lst.(lst))) \n        odd.(odd) \n\
    \        sum (odd .^ 2)\nend\n</code>\nThe take() function is used to grab the\
    \ first element of an array given a Boolean array\n<|/ a tags=julia,vector,arrays\
    \ |>\n<| a tags=julia,vector,arrays |>\nYou could use the filter function (Julia\
    \ 1.7+) or the collect function (Julia 0.6+):\n<code>\njulia> collect([1 2 3 4\
    \ 5])\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5", "    if length(lst) ==\
    \ 0 \n        0\n    elseif all(x -> x < 0, lst)\n        0\n    else\n      \
    \  sum(lst)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    Given\
    \ a vector of numbers, return a new vector of numbers that contains\n    all of\
    \ the numbers in the original vector except the number that comes\n    first in\
    \ the original vector.\n    \n    >>> remove_first([1, 3, 2, 0])\n    [1, 3, 2]\n\
    \    >>> remove_first([-1, -2, 0])\n    [-1, -2]\n    >>> remove_first([9, -2])\n\
    \    [9]\n    >>> remove_first([])\n    []\n   \n    If the input vector is empty,\
    \ return an empty vector.\n    \"\"\"", "    sum = 0\n    for n in lst\n     \
    \   if n > 0\n            sum += n*(n+1)/2\n        else\n            sum += n\n\
    \        end\n    end\n    return sum\nend", "    lst = lst .+ 0.0\n    if isempty(lst)\n\
    \        return 0\n    doubled = filter(x -> x .== 0, lst) \n    sum = 0\n   \
    \ for i in doubled\n        sum = sum + i*i\n    end\n    return sum\nend \n</cell>\n\
    <cell>\n# Now try it on a list containing 3 different lists, each list having\
    \ 2 elements. \n# And also try it on an empty list. \n# Notice how in either case\
    \ an empty list is returned. \ndouble_the_difference([[1, 2, 3], [2, 4, 6], [3,\
    \ 6, 9]])\n</cell>\n<text>\nExercise 10\nConsider the following lists:", "   \
    \ if len(lst) == 0\n        return 0\n    else\n        return sum(lst[k] for\
    \ k in lst if k%2 == 1)\n    end\nend", "    nsum::Int64 = 0\n    for i in lst\n\
    \        if i%2==1\n            nsum = nsum + i\n        end\n    end\n    return\
    \ nsum\nend\n</cell>\n<code language=julia-1.6>\n\"\"\"\n    Given a vector of\
    \ numbers, return a vector of the squares of the numbers \n    in the vector.\
    \ Ignore numbers that are negative or not integers.\n    \n    >>> square_the_difference([1,\
    \ 3, 2, 0])\n    [1, 8, 27, 64]\n    >>> square_the_difference([-1, -2, 0])\n\
    \    [-2, 0, 0]\n    >>> square_the_difference([9, -2])\n    [9, 16]\n    >>>\
    \ square_the_difference([0])\n    [0]\n   \n    If the input vector is empty,\
    \ return 0.\n    \"\"\"", "   \n    if length(lst) == 0 \n        return 0 \n\
    \    \n    sum = 0 \n    sum = 0 \n    for x in lst \n        if x >= 1 \n   \
    \         sum += x*x \n        else \n            sum += x\n    return sum \n\
    end \n</cell>\n<text>\nProblem 7\nImplement a function which takes a vector of\
    \ numbers as its only parameter and returns a vector with the negative numbers.\
    \ The vector should not be empty.", "    sum = 0\n    for i in lst\n        if\
    \ i%2==1\n            sum+=i\n        else\n            sum-=i\n        end\n\
    \    end\n    return sum\nend\n</cell>\n<code language=julia-0.6>\n\"\"\"\n  \
    \  Sum all the numbers in a vector of numbers, in any order.\n    \n    >>> sum_of_numbers([1,\
    \ 2, 3])\n    6\n    >>> sum_of_numbers([3, 2, 1])\n    6\n    >>> sum_of_numbers([6,\
    \ 3, 1])\n    21\n    >>> sum_of_numbers([-2, -1, 0, 1, 2])\n    -1\n   \n   \
    \ If the input vector is empty, return 0.\n    \"\"\"", "    if length(lst) ==\
    \ 0 \n        0\n    else\n        res = 0\n        for i in lst\n           \
    \ if mod(i, 2) == 1\n                res += i\n            else\n            \
    \    0\n        end\n    end\nend\n</cell>\n<text>\nThe function double_the_difference\
    \ takes a vector and returns the sum of the square of the numbers that are odd\
    \ in the vector. Ignore numbers that are negative or not integers.", "    \"\"\
    \"\n    Given a vector of numbers, return the sum of squares of the numbers\n\
    \    in the vector that are odd. Ignore numbers that are negative or not integers.\n\
    \    \n    >>> double_the_difference([1, 3, 2, 0])\n    10\n    >>> double_the_difference([-1,\
    \ -2, 0])\n    0\n    >>> double_the_difference([9, -2])\n    81\n    >>> double_the_difference([0])\n\
    \    0\n   \n    If the input vector is empty, return 0.\n    \"\"\"\n    if lst.length==0,\
    \ return 0\n    \n    sum=0\n    for i in lst\n        if i%2==0\n           \
    \ sum+=i\n        end\n    end\n    sum\nend", "    if !length(lst)\n        return\
    \ 0.0\n    s = 0\n    for i in lst\n        if i>0\n            s += i\n    return\
    \ s\nend", "     \n    if lst==[]\n        return 0\n    else\n        return\
    \ sum([(x-floor(x)+0.5)^2 for x in lst])\n    end\nend", "    if is_empty(lst)\n\
    \        return 0\n    elseif is_empty(lst)\n        return 0\n    else\n    \
    \    sum = 0\n        for i in lst\n            if i < 0\n                sum\
    \ -= i\n            else\n                sum += i\n        end\n        return\
    \ sum * sum\n    end\nend\n</cell>\n<code language=julia-1.5>\nusing Random\n\
    Random.seed!(1234)", "    if len(lst) == 0 \n        return 0 \n    else \n  \
    \      result <- sum(map(x -> if x % 2 == 1 then x * 2 else x, lst))\n    end\n\
    \    return result", "    if length(lst) == 0\n        return 0 \n    else\n \
    \       return sum(x for x in lst if x % 2 == 1)\n    end\nend\n</cell>\n<code\
    \ language=julia-1.3>\n\"\"\"\n    fourth_to_last(input_list::Vector{Float64})",
  "    result = 0.\n    if length(lst) > 0 \n        result = sum(lst[2:end])\n  \
    \  end \n    return result\nend\n</cell>\n<code language=julia-1.1>\n\"\"\"\n\
    \    Given a vector of numbers, return all numbers except the one at position\n\
    \    pos\n    \n    >>> odd_except_at([1, 3, 2, 0])\n    [1, 3]\n    >>> odd_except_at([-1,\
    \ -2, 0])\n    [-2]\n    >>> odd_except_at([9, -2])\n    [9]\n    >>> odd_except_at([0])\n\
    \    []\n   \n    If the input vector is empty, return an empty vector.\n    \"\
    \"\"", "    if length(lst) == 0\n        return 0\n    elseif length(lst) == 1\n\
    \        return lst[0] * lst[0]\n    else\n        # Initialize a sum variable\
    \ to 0\n        sum = 0\n        # Iterate through list \n        for i in lst\n\
    \            # Add ith element of the list to sum\n            sum += i\n    \
    \        # If the number is odd\n            if i %% 2 == 1\n                #\
    \ Divide ith element of the list by 2\n                sum /= 2.0\n          \
    \  # Return the sum of the list\n        return sum\nend", "    sum = 0\n    for\
    \ element in lst\n        if element % 2 == 1\n            sum += element\n  \
    \      end\n    end\n    return sum\nend", "    sum_of_squares = 0\n    for i\
    \ in lst\n        if i >= 0\n            sum_of_squares += i^2\n        end\n\
    \    end\n    return sum_of_squares\nend\n</cell>\n<text>\nTask: Write a function\
    \ that takes a list of numbers representing an equation\nand returns the value\
    \ of the equation.", "    if length(lst) == 0\n        return 0\n    else \n \
    \       sum = 0.0\n        for elt in lst\n            if elt % 2 == 1\n     \
    \           sum += elt\n            end\n        end\n        return sum\n   \
    \ end\nend\n</cell>\n<code language=julia-1.5>", "    if lst.length == 0\n   \
    \     return 0 \n    evens_sum = sum(lst[i] for i in 2:length(lst) if lst[i] %\
    \ 2 == 0) \n    odds_sum = sum(lst[i] for i in 2:length(lst) if lst[i] % 2 !=\
    \ 0) \n    double_sum = evens_sum + odds_sum\n    return double_sum\nend", " \
    \   if length(lst) == 0\n        return 0\n    \n    # Initialize sum variable\
    \ and increment it for each number that is\n    # even and odd.\n    sum ::Float64\
    \ = 0\n    for i in lst\n        if i % 2 == 0\n            sum += i\n       \
    \ end\n    end\n    \n    # Return sum of squares.\n    return sum * sum\nend\n\
    </cell>\n<code language=julia-1.0>\n\"\"\"\n    the_product(lst::Vector{Int64})\n\
    \    \n    Return the product of all the numbers in the input list.\n    \n  \
    \  >>> the_product([-1, 2, 3])\n    -1\n    >>> the_product([9, 8, 3])\n    27\n\
    \    >>> the_product([])\n    0\n\"\"\"", "    if length(lst) == 0\n        return\
    \ 0\n    if length(lst) == length(lst[1]) && all(x < 0 for x in lst)\n       \
    \ return 0\n    return sum(x .* x for x in lst)\nend", "    count = 0\n    for\
    \ i in lst\n        count += if i == 1.0 || i == 0.0 || i == NaN \n          \
    \         0.0 \n               else if i < 0.0 || i > 1.0 \n                 \
    \  0.0 \n               else i * i \n    end\n    count\nend\n</cell>\n<code language=julia-1.1>\n\
    # Exercise: Write a function that takes in a vector of numbers and returns the\
    \ product of \n# the numbers in the vector. Ignore numbers that are negative or\
    \ zero.", "    \"\"\"\n    Given a vector of numbers, return the sum of squares\
    \ of the numbers\n    in the vector that are odd. Ignore numbers that are negative\
    \ or not integers.\n    \n    >>> double_the_difference([1, 3, 2, 0])\n    10\n\
    \    >>> double_the_difference([-1, -2, 0])\n    0\n    >>> double_the_difference([9,\
    \ -2])\n    81\n    >>> double_the_difference([0])\n    0\n   \n    If the input\
    \ vector is empty, return 0.\n    \"\"\"\n    \n    sum = 0.0\n    for elt in\
    \ lst\n        if elt != 0 && elt % 2 == 1\n            sum += elt*elt\n     \
    \   end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\ndouble_the_difference(Vector{Float64}[])\n\
    </cell>\n<text>\nExercise: Calculate the sum of the squares of the odd integers\
    \ in a vector", "    if is_empty(lst)\n        return 0\n    \n    sum = 0\n \
    \   for element in lst\n        if is_integer(element)\n            if element\
    \ > 0\n                sum += element * element\n            end\n        else\n\
    \            sum += element\n        end\n    end\n    return sum\nend", "  \n\
    \    if length(lst) == 0 return 0 \n      \n    sum_squares = 0 \n    for n in\
    \ lst \n        sum_squares += n*n \n        if n rem 2 > 0 sum_squares -= n*n\
    \ \n    end\n \n    return sum_squares \nend", "    \"\"\"\n    Given a vector\
    \ of numbers, return the sum of squares of the numbers\n    in the vector that\
    \ are odd. Ignore numbers that are negative or not integers.\n    \n    >>> double_the_difference([1,\
    \ 3, 2, 0])\n    10\n    >>> double_the_difference([-1, -2, 0])\n    0\n    >>>\
    \ double_the_difference([9, -2])\n    81\n    >>> double_the_difference([0])\n\
    \    0\n   \n    If the input vector is empty, return 0.\n    \"\"\"\n    if length(lst)\
    \ == 0 \n        return 0 \n    else\n        return sum((x -> x % 2) == 0 ? (lst[i])\
    \ * (lst[i]) : 0 for i in lst)\n    end\nend\n</code>\nSolution\n<code>", "  \
    \  sum = 0 \n    for i in lst\n        if !isinteger(i) || i<0\n            println(\"\
    Negative value is not allowed in vector.\")\n            return 0\n        else\
    \ \n            sum += i^2 \n    return sum\nend", "    if length(lst) == 0 \n\
    \        0\n    else\n        for i in lst\n            if i == Int(i)\n     \
    \           2*i\n            else\n                i\n            end\n      \
    \  end\n    end\nend\n</cell>\n<code language=julia-1.6>", "    if length(lst)\
    \ == 0 \n        return 0 \n    else \n        sum=0\n        for n in lst \n\
    \            if n > 0\n                sum += (n^2)\n            else \n     \
    \           sum += n \n        return sum \nend \n</cell>\n<code language=julia-1.6>\n\
    \"\"\"\n    sum_squares_of_even_numbers(lst)", "    if length(lst) == 0\n    \
    \    return 0\n    \n    sum_of_squared = 0\n    for i in lst\n        if isa(i::Vector{Float64},\
    \ Array{Float64, 1})\n            sum_of_squared += i.^2\n        else\n     \
    \       sum_of_squared += i\n        end\n    end\n    return sum_of_squared\n\
    end\n</cell>\n<code language=julia-1.6>\n\"\"\"\nGiven a list of numbers, return\
    \ the sum of squares of the numbers\nin the list. Ignore numbers that are negative\
    \ or not integers.\n    \n    >>> double_the_difference([1, 3, 2, 0])\n    10\n\
    \    >>> double_the_difference([-1, -2, 0])\n    0\n    >>> double_the_difference([9,\
    \ -2])\n    81\n    >>> double_the_difference([0])\n    0\n   \n    If the input\
    \ list is empty, return 0.\n\"\"\"", "    total = sum(i for i in lst if i .> 0)\n\
    \    \n    double_the_difference = total - sum(i for i in lst if i .== 0)\n  \
    \  return double_the_difference\nend", "    sum=0\n    for x in lst\n        sum\
    \ += x\n    end\n    return sum\nend", "    sum(x for x in lst if x % 2 != 0)\n\
    end\n</cell>\n<text>\nPart 4\nThe previous function double_the_difference takes\
    \ a vector of numbers and returns the sum of squares of the numbers that are odd.",
  "    if length(lst) == 0 \n        return 0 \n    else \n        return sum(x for\
    \ x in lst if x % 2 == 1) \nend\n\"\"\"\n    Given a vector of numbers, return\
    \ the sum of squares of the numbers\n    in the vector that are even. Ignore numbers\
    \ that are negative or not integers.\n    \n    >>> double_the_difference([1,\
    \ 3, 2, 0])\n    14\n    >>> double_the_difference([-1, -2, 0])\n    0\n    >>>\
    \ double_the_difference([9, -2])\n    161\n    >>> double_the_difference([0])\n\
    \    0\n    \n    If the input vector is empty, return 0.\n    \"\"\"", "    if\
    \ len(lst) == 0 \n        return 0 \n    sum_of_squares = 0 \n    for x in lst\
    \ \n        if x < 0 \n            continue \n        if x % 2 != 0 \n       \
    \     sum_of_squares += x \n        end \n    end \n    return sum_of_squares\
    \ \nend \n</cell>\n<code language=julia-0.6>\n\"\"\"\n    Given a vector of numbers,\
    \ return the sum of squares of the numbers\n    in the vector that are odd. Ignore\
    \ numbers that are negative or not integers.\n    \n    >>> double_the_difference([1,\
    \ 3, 2, 0])\n    10\n    >>> double_the_difference([-1, -2, 0])\n    0\n    >>>\
    \ double_the_difference([9, -2])\n    81\n    >>> double_the_difference([0])\n\
    \    0\n   \n    If the input vector is empty, return 0.\n    \"\"\"", "    #\
    \ initialize counter\n    counter::Int64 = 0 \n    # run through the vector and\
    \ \n    # check for odd and add squared \n    # to counter\n    for i in lst\n\
    \        if isodd(i)\n            counter = counter + i^2 \n        end \n   \
    \ end\n    return counter\nend\n</cell>\n<code language=julia-1.0>\n#tests\ndouble_the_difference([1,\
    \ 3, 2, 0])\n</cell>\n<text>\nExercise 3\nWrite a function that accepts a string\
    \ and returns that string in all lowercase, with all punctuation removed.", " \
    \ if length(lst) == 0, return 0 \n  \n  # The code below is more efficient, and\
    \ it works better with arrays, \n  # since the array doesn't need to be reallocated.\n\
    \  sum = 0\n  for i=1:length(lst)\n    if lst[i] % 2 == 1\n      sum += lst[i]\n\
    \    end\n  end\n  \n  return sum\nend\n</code>\nTo test whether a number is odd,\
    \ we use the mod function, which is defined as follows:\n<code>\nmod(number, modulus)\n\
    </code>\nIf the remainder is non-zero, then the number is odd. Otherwise, the\
    \ number is even.\nThis works because x mod m is x - (x mod m), where m is the\
    \ modulus, and since m is positive, this is always non-negative.\nTherefore, if\
    \ we have:\n<code>\nnumber = 10\nmodulus = 2\n</code>\nthe number mod 2 will be\
    \ 10, because 10 is 10, 10 minus 10 is 0, 0 minus 2 is 2.\nSimilarly, the number\
    \ 8 mod 2 will be 8, because 8 is 8, 8 minus 8 is 0, 0 minus 2 is 0.\nSince 8\
    \ is even, it will be added into the sum.\nTo find out if a number is even, we\
    \ subtract it from the remainder, which is also even. Since we get 0 here, the\
    \ number is even.\n<code>", "    answer = 0.0\n    for number in lst\n       \
    \ if number <= 0 || number % 2 != 0\n            answer += 1\n        else\n \
    \           answer += number\n        end\n    end\n    return answer\nend\n</cell>\n\
    <code language=julia-0.6>", "    if !isdefined(lst)\n        return 0\n    else\n\
    \        odd_elements = lst[findall(x->x%2==1,lst)]\n        sum((x for x in lst\
    \ if x % 2 != 1), 0)\n    end\nend", "    for elt in lst \n        if isa(real(elt),Int)\
    \ \n            if elt % 2 == 1 \n                elt *= 2 \n            end \n\
    \        else \n            elt \n        end \n    end\n    return sum(lst)\n\
    end", "    if length(lst) == 0\n        return 0\n    \n    # Compute the sum\
    \ \n    sum_of_squares = 0.0\n    for elt in lst\n        sum_of_squares += elt^2\n\
    \    end\n    \n    # Compute the square-root of the sum\n    return sqrt(sum_of_squares)\n\
    end\n</cell>\n<text>\nExercise\nCompute the square of the difference of the vector\
    \ \n$$\n    \\begin{bmatrix}\n        1 & 3 & 3 & 3\\\n        2 & -2 & 0 & 0\\\
    \n        9 & -2 & 0 & 0\\\n        0 & 0 & 0 & 0\n    \\end{bmatrix}\n$$", " \
    \   if length(lst) == 0 \n        return 0 \n    end", "    \n    if isempty(lst)\n\
    \        return 0\n    else\n        return sum(map(|x| x^2, lst[lst!=0]))\nend\n\
    </cell>\n<cell>", "    s = 0\n    \n    for n in lst\n        if n > 0\n     \
    \       s += n * n\n        elseif n <= 0\n            s += -n * n\n        else\n\
    \            s += 1\n        end\n    end\n    \n    return s\nend", "    sum\
    \ = 0\n    for num in lst\n        if num > 0\n            sum += num\n      \
    \  end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
