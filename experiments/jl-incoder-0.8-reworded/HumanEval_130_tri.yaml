name: HumanEval_130_tri
language: jl
prompt: "\"\"\"Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
  \ in \n    the last couple centuries. However, what people don't know is Tribonacci\
  \ sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) =\
  \ 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2)\
  \ + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n \
  \   tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 =\
  \ 8 \n    You are given a non-negative integer number n, you have to a return a\
  \ vector of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n\
  \    >>> tri(3)\n    [1, 3, 2, 8]\n    \"\"\"\nfunction tri(n::Int64)::Vector{Int64}\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = tri;\n\t@test(candidate(3) ==\
  \ [1, 3, 2, 8])\n\t@test(candidate(4) == [1, 3, 2, 8, 3])\n\t@test(candidate(5)\
  \ == [1, 3, 2, 8, 3, 15])\n\t@test(candidate(6) == [1, 3, 2, 8, 3, 15, 4])\n\t@test(candidate(7)\
  \ == [1, 3, 2, 8, 3, 15, 4, 24])\n\t@test(candidate(8) == [1, 3, 2, 8, 3, 15, 4,\
  \ 24, 5])\n\t@test(candidate(9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\n\t@test(candidate(20)\
  \ == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\n\
  \t@test(candidate(0) == [1])\n\t@test(candidate(1) == [1, 3])\nend\n"
completions: ["    if n == 0 || n == 1 \n        return Vector{Int64}([]) \n    else\
    \ \n        return tri(n - 1) + tri(n - 2) + tri(n + 1) \n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert tri(7) == [1, 3, 2, 8, 5, 14, 13]\n@assert\
    \ tri(2) == [1, 1, 1]\n@assert tri(1) == [1]\n@assert tri(0) == []\n</cell>\n\
    <text>\nExercise 2: Recursion\nThe Fibonacci sequence is defined recursively as:",
  "    if n == 1\n        return [3]\n    else\n        tri(n-1)+tri(n-2)+tri(n+1)\n\
    \    end\nend", "    if n==0 \n        []\n    elseif n==1 \n        [1]\n   \
    \ elseif n==2 \n        [1,2]\n    elseif n==3 \n        [1,3,2]\n    elseif n==4\
    \ \n        [1,2,3,4]\n    elseif n==5 \n        [1,2,4,3]\n    elseif n==6 \n\
    \        [1,2,3,5]\n    elseif n==7 \n        [1,2,4,5,3]\n    elseif n==8 \n\
    \        [1,2,3,4,5]\n    elseif n==9 \n        [1,2,3,4,5,6]\n    elseif n==10\
    \ \n        [1,2,3,4,5,6,7]\n    elseif n==11 \n        [1,2,3,4,5,6,7,8]\n  \
    \  elseif n==12 \n        [1,2,3,4,5,6,7,8,9]\n    elseif n==13 \n        [1,2,3,4,5,6,7,8,9,10]\n\
    \    elseif n==14 \n        [1,2,3,4,5,6,7,8,9,10,11]\n    elseif n==15 \n   \
    \     [1,2,3,4,5,6,7,8,9,10,11,12]\n    elseif n==16 \n        [1,2,3,4,5,6,7,8,9,10,11,12,13]\n\
    \    elseif n==17 \n        [1,2,3,4,5,6,7,8,9,10,11,12,13,14]\n    elseif n==18\
    \ \n        [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\n    elseif n==19 \n       \
    \ [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]\n    elseif n==20 \n        [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]\n\
    \    elseif n==21 \n        [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18]\n \
    \   elseif n==22 \n        [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]\n\
    \    elseif n==23 \n        [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]\n\
    \    elseif n==24 \n        [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21]\n\
    \    elseif n==25 \n        [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22]\n\
    \    elseif n==26 \n        [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]\n\
    \    elseif n==27 \n        [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]\n\
    \    elseif n==28 \n        [", "    # Write your code in Julia 0.6\n    # Your\
    \ code here\n    if n==1\n        vec=[]\n    else\n        if n==2\n        \
    \    vec=[1,2]\n        else\n            if mod(n,2)==1\n                vec=[tri(n-2),tri(n-1)\
    \ + tri(n)]\n            else\n                vec=[tri(n-2),tri(n-1),tri(n)]\n\
    \            end\n        end\n    end\n    return vec\nend", "    if n == 1\n\
    \        return [3]\n    else if n mod 2==0\n        return [tri(n-1)[1], tri(n-1)[2]+tri(n)]\n\
    \    else\n        return [tri(n-1)[1]+tri(n-1), tri(n-1)[2]+tri(n-2)[1]]\n  \
    \  end\nend\n</code>\n<|/ a |>\n<| a |>\nAnother option is to just use a recursive\
    \ function:\n<code>", "    if n == 0\n        return [3]\n    if n % 2 == 0 \n\
    \        return [1,n+1]\n    else\n        return [tri(n - 1) + tri(n - 2) + tri(n\
    \ + 1), n + 1]\nend\n</cell>\n<text>\nProblem 3.2: Fibonacci numbers - Problem\
    \ 3\nProblem 3.2: Fibonacci numbers - Problem 2\nProblem 3.2: Fibonacci numbers\
    \ - Problem 3\nProblem 3.2: Fibonacci numbers - Problem 4\nProblem 3.2: Fibonacci\
    \ numbers - Problem 5\nProblem 3.2: Fibonacci numbers - Problem 6\nProblem 3.2:\
    \ Fibonacci numbers - Problem 7\nProblem 3.2: Fibonacci numbers - Problem 8\n\
    Problem 3.2: Fibonacci numbers - Problem 9\nProblem 3.2: Fibonacci numbers - Problem\
    \ 10\nProblem 3.2: Fibonacci numbers - Problem 11\nProblem 3.2: Fibonacci numbers\
    \ - Problem 12\nProblem 3.2: Fibonacci numbers - Problem 13\nProblem 3.2: Fibonacci\
    \ numbers - Problem 14\nProblem 3.2: Fibonacci numbers - Problem 15\nProblem 3.2:\
    \ Fibonacci numbers - Problem 16\nProblem 3.2: Fibonacci numbers - Problem 17\n\
    Problem 3.2: Fibonacci numbers - Problem 18\nProblem 3.2: Fibonacci numbers -\
    \ Problem 19\nProblem 3.2: Fibonacci numbers - Problem 20\nProblem 3.2: Fibonacci\
    \ numbers - Problem 21\nProblem 3.2: Fibonacci numbers - Problem 22\nProblem 3.2:\
    \ Fibonacci numbers - Problem 23\nProblem 3.2: Fibonacci numbers - Problem 24\n\
    Problem 3.2: Fibonacci numbers - Problem 25\nProblem 3.2: Fibonacci numbers -\
    \ Problem 26\nProblem 3.2: Fibonacci numbers - Problem 27\nProblem 3.2: Fibonacci\
    \ numbers - Problem 28\nProblem 3.2: Fibonacci numbers - Problem 29\nProblem 3.2:\
    \ Fibonacci numbers - Problem 30\nProblem 3.2: Fibonacci numbers - Problem 31\n\
    Problem 3.2: Fibonacci numbers - Problem 32\nProblem 3.2: Fibonacci numbers -\
    \ Problem 33\nProblem 3.2: Fibonacci numbers - Problem 34\nProblem 3.2: Fibonacci\
    \ numbers - Problem 35\nProblem 3.2: Fibonacci numbers - Problem 36\nProblem ",
  "    tri_res = Vector{Int64}() \n    push!(tri_res, 1) \n    for i = 2:(n-1) \n\
    \        push!(tri_res, tri_res[i-1] + tri_res[i-2] + tri_res[i+1])\n    end\n\
    \    tri_res\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=sequence,algorithm,fibonacci\
    \ |>\nI believe that there is no difference between calculating fib(n) by using\
    \ recursion or by using an iterative method.\nI did some tests on both of the\
    \ methods and they came to the same result.\n<code>\nusing BenchmarkTools", " \
    \   if n==1 || n==2\n        return [1]\n    if n==3\n        return [1, 3]\n\
    \    return tri(n-1) + tri(n-2) + tri(n-3)\nend\n</code>\n<|/ a dscore=4 tags=math,fibonacci,julia\
    \ |>\n<| a tags=math,fibonacci,julia dscore=3 |>\n<code>\nfib(n) = fib(n - 1)\
    \ + fib(n - 2)\n</code>\n<|/ a |>\n<| c |>\n`fib(n)` would not return `n` but\
    \ `n - 1` by default.\n<|/ c |>\n<| c |>\nI agree. It seems I was not paying enough\
    \ attention to the problem as I thought that `n` was supposed to return `n`. I\
    \ fixed it.\n<|/ c |>\n<| a dscore=3 tags=math,fibonacci,julia |>\n<code>\njulia>\
    \ fib = Vector{Int}(1:n+1)\nfib: [1, 1, 2, 3, 5, 8, 13]", "    if n == 0 \n  \
    \      tri([3]) \n    else \n        tri([1] + [n/2]) \n    end\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\nMy version using only recursion:\n<code>",
  "    if n == 1\n        return [1]\n    \n    elif n % 2\n        return tri(n -\
    \ 1) + [n - 1] + tri(n - 2)\n    \n    else\n        return tri(n - 1) + [n -\
    \ 2] + tri(n - 3)\nend", "    \n    if n < 2 return [1]\n    if n == 2 return\
    \ [1, 1, 3]\n    if n == 3 return [1,2,3]\n    tri(n - 1) + tri(n - 2) + tri(n\
    \ - 3)\nend", "  if n == 0\n    return Int64[]\n  else\n    return tri(n - 1)\
    \ + tri(n - 2) + tri(n + 1)\n  end\nend", "  if n==1 \n    return [1] \n  else\
    \ \n    x,y = n,n+1 \n    triArray = Vector{Int64}(undef,n+2)\n    triArray[1]\
    \ = x\n    triArray[2] = y\n    for i = 1:(n-1) \n      triArray[i+3] = triArray[i]\
    \ + triArray[i+1] + triArray[i+2] \n    end\n    return triArray\n  end\nend\n\
    </cell>\n<text>\nQuestion 4\nWrite a function that calculates all odd Fibonacci\
    \ numbers up to the given number n. \nExamples:\ntri(10)\n  [1, 1, 3, 5, 8, 13,\
    \ 21, 34, 55]\nfib(10)\n  [1, 1, 2, 3, 5, 8, 13, 21, 34]", "    ans <- zeros(n+1)\n\
    \    \n    \n    if n <= 1 \n        return ans\n    else \n        ans[1] <-\
    \ 3\n    \n        if mod(n, 2) == 0 \n            ans[2] <- ans[1] + ans[2]\n\
    \        else \n            ans[2] <- tri(n - 1) + tri(n - 2) + tri(n + 1)\n \
    \       \n        end\n        ans\n    end\nend", "    if n == 1 \n        return\
    \ [1]\n    elseif n == 2 \n        return [1, 2]\n    elseif n % 2 == 0 \n   \
    \     return tri(n / 2) + tri(n / 2) + tri(n + 1) \n    else\n        return tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1) \n    end\nend\n</cell>\n<cell>\n\"\"\"\nExercise\
    \ 4.10\nWrite a function that takes a sequence of non-negative numbers and returns\
    \ their arithmetic mean.\nExamples:\n    >>> mean([1.0, 4.0, 3.1])\n    3.2\n\
    \    >>> mean([3.2, 2.7, 6.4])\n    6.5\n    >>> mean([1.0])\n    1.0\n    >>>\
    \ mean([])\n    1.0\n\"\"\"", "    res=Vector{Int64}()\n    if n==0\n        push!(res,1)\n\
    \    elseif n==1\n        push!(res,2)\n    elseif n==2\n        push!(res,3)\n\
    \    else\n        push!(res,tri(n-1)+tri(n-2)+tri(n+1))\n    end\n    \n    return\
    \ res\nend\n</cell>\n<code language=julia-1.5>", "    if n == 0 || n == 1\n  \
    \      return zeros(0)\n    elseif n == 2\n        return ones(1)\n    else\n\
    \        return tri(n-1) + tri(n-2) + tri(n+3)\n    end\nend\n</cell>\n<text>\n\
    Tribonacci sequence is important and used in many math problems. You can solve\
    \ it in O(log n) time complexity and O(1) space complexity.", "    if n == 1 \n\
    \        return [1,2,3] \n    elseif n == 2 \n        return [1] \n    elseif\
    \ n % 2 == 0 \n        return [tri(n - 1) + tri(n - 2) + tri(n - 3)]\n    elseif\
    \ n % 2 == 1 \n        return [tri(n - 1) + tri(n - 2) + tri(n - 3) + tri(n -\
    \ 4)]\n    end\nend\n</cell>\n<text>\nExample: Fibonacci sequence\nWrite a function\
    \ that takes a number $n$ and return $F{n}$.", "  x = zeros(n,1)\n  x[1] = tri(Int(n/2))\n\
    \  x[2] = tri(Int(n/2)) + tri(Int(n/2)+1)\n  x[3] = tri(Int(n/2)) + tri(Int(n/2)+1)\
    \ + tri(Int(n/4)) \n  return x\nend", "    if n == 0\n        return zeros(1,\
    \ 0)\n    if n == 1\n        return ones(1, 0)\n    if n % 2 == 0\n        return\
    \ tri(n - 1) + tri(n - 2) + tri(n + 1)\n    else\n        return tri(n - 1) +\
    \ tri(n - 2) + tri(n - 3)\n    end\nend\n</cell>\n<code language=julia-1.0>\n\"\
    \"\"A fibonacci sequence is just an infinite sequence that start with 0 and ends\
    \ with 1.\nThe first element of the sequence is 0, then 1, then 2, then 3, and\
    \ so on. \nGiven an index, return the element of the sequence that that index\
    \ corresponds to.\nExample:\nindex = 1\nreturn = 2\nGiven an index larger than\
    \ the length of the sequence, the function should return the last element. \n\"\
    \"\"", "    tri(n) = [1]\n    if n <= 1 \n        return tri(n)\n    else if n\
    \ % 2 == 1 \n        tri(n) =  tri(n-1) + tri(n-2) + tri(n+1)\n        return\
    \ tri(n)\n    else \n        tri(n) = tri(n-1) + tri(n-2)\n        return tri(n)\n\
    \    end\nend", "  if n <= 1\n    return [1]\n  elseif n % 2\n    return tri(n-1)\
    \ + tri(n-2)\n  else\n    return tri(n-1) + tri(n-2) + tri(n+1) + tri(n+2)\n \
    \ end \nend\n</cell>\n<code language=julia-1.0>\ntri(10)\n</cell>\n<code language=julia-1.0>",
  "    if n == 0 \n        return Vector{Int64}([3])\n    elseif n ==1\n        return\
    \ Vector{Int64}([1,2])\n    elseif n%2 == 1\n        return tri(n-1) + tri(n-2)\n\
    \    else\n        return tri(n-1) + tri(n-2) + tri(n+1) + tri(n+1)\n    end\n\
    end", "    if n==0 || n==1\n        [1] \n    else if n==2\n        [1] \n   \
    \ else\n        push!(tri(2); tri(2); tri(2))\n        push!(tri(2); tri(2); tri(2))\n\
    \    end\nend", "    if n == 1 \n        return Vector{Int64}[1]\n    elseif n\
    \ == 2 \n        return Vector{Int64}[1, 1]\n    elseif n % 2 == 0 \n        return\
    \ [tri(n - 1) + tri(n - 2)]\n    else\n        return tri(n - 1) + tri(n - 2)\
    \ + tri(n - 1)\n    end\nend", "    if n == 0 \n        ones([1, 1])\n    elseif\
    \ n == 1 \n        ones([1, 1])\n    else\n        tri(n-1) + tri(n-2) + tri(n+1)\n\
    \    end\nend\n</cell>\n<text>\nExercise 5\nThe Fibonacci sequence is defined\
    \ by the recurrence:\n    fibonacci(1) = 1\n    fibonacci(2) = 1\n    fibonacci(n)\
    \ = fibonacci(n-1) + fibonacci(n-2) if n > 2.\n    For example, fibonacci(3) =\
    \ fibonacci(1) + fibonacci(2) = 1 + 1 = 2. \n    You are given an integer n, and\
    \ you have to return a vector of the first n \n    terms of the Fibonacci sequence.\n\
    \    Examples:\n    >>> fibonacci(10)\n    [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n\
    \    \"\"\"", "    if n == 0 \n        Vector{Int64}() \n    else \n        if\
    \ isodd(n) \n            tri(n-1) + tri(n-2) \n        else \n            tri(n-1)\
    \ + tri(n-2) + tri(n+1) \n        end\n    end\nend\n\"\"\"\n    Tribonacci sequence",
  "    if n < 2\n        Vector{Int64}(undef, 2)\n    else\n        first = (tri(n\
    \ - 1) + tri(n - 2))\n        last = (tri(n - 1) + tri(n - 2) + tri(n + 1))\n\
    \        last += 2\n        Vector{Int64}(undef, last + first)\n    end\nend\n\
    </cell>\n<text>\nSolution", "    if n < 2\n        vec = []\n    elseif n % 2\
    \ == 0 \n        vec = [1, n+n/2]\n    else\n        vec = [tri(n - 1) + tri(n\
    \ - 2) + tri(n + 1), tri(n)]\n    end\n    vec\nend\n</cell>\n<text>\nNotice that\
    \ in each recursive call, we append the result to the vector we already have,\
    \ using the cons syntax", "    if n <= 0\n        error(\"Tribonacci sequence\
    \ only accept positive integers.\")\n    elseif n == 2\n        Vector{Int64}[1,\
    \ 2, 1]\n    elseif n % 2 == 1\n        tri(n - 2) + tri(n - 1) + tri(n + 1)\n\
    \    else\n        tri(n - 2) + tri(n + 1)\n    end\nend", "    if n == 1\n  \
    \      [1]\n    else if n == 2\n        [3]\n    elseif n % 2 == 0\n        tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1)\n    else\n        tri(n - 2) + tri(n - 1) +\
    \ tri(n + 1)\n    end\nend\n</cell>\n<cell>\n#export\n\"\"\"\n    Every person\
    \ knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the\
    \ last couple centuries. However, what people don't know is \n    Tribonacci sequence.\
    \ Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n)\
    \ = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n +\
    \ 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4)\
    \ = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n  \
    \  You are given a non-negative integer number n, you have to a return a vector\
    \ of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n\
    \    >>> tri(3)\n    [1, 3, 2, 8]\n\"\"\"", "    if n == 0 || n == 1\n       \
    \ true\n    else\n        tri(n - 1) + tri(n - 2) + tri(n + 1)\n    end\nend\n\
    </code>\n<|/ a tags=fibonacci,recursion,julia |>\n<| a tags=fibonacci,recursion,julia\
    \ |>\nI know this question was already answered, but I thought it might be helpful\
    \ to point out an alternate way of solving this that isn't a recursive solution\
    \ at all.\nThe Fibonacci sequence is defined by two numbers, A and B, and the\
    \ sequence is\ndefined to be the sum of the first two numbers, as so:", "    if\
    \ n == 2\n        Vector{Int64}[3]\n    elseif n == 3\n        Vector{Int64}[1,\
    \ 3, 2]\n    elseif n % 2 == 0\n        tri(n - 1) + tri(n - 2) + tri(n + 1)\n\
    \    else\n        tri(n - 1) + tri(n - 2) + tri(n + 1)\n    end\nend\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nI actually tried this one and I got this error : \n\
    `julia> fib(3)\nERROR: MethodError: no method matching tri(::Int64)`\n<|/ c |>\n\
    <| c |>\nThis won't work for n==0 since that would return an empty vector. The\
    \ Fibonacci sequence starts at 0 and ends at 1.\n<|/ c |>\n<| a dscore=4 |>\n\
    Here is a function which takes any argument and returns an Array:\n<code>", " \
    \   \n    if n == 1 \n        return [1,1]\n    \n    tri_1 = tri(n-1)\n    tri_2\
    \ = tri(n-2) + tri_1 + tri(n-1)\n    \n    return [tri_1, tri_2]\nend", "    if\
    \ n == 0 \n        [] \n    else \n        tri(n - 1) + tri(n - 2) + tri(n + 1)\n\
    \    end\nend\n</cell>\n<code language=julia-1.0>", "    if n==0 || n==1 \n  \
    \      return [1] \n    \n    if n % 2 == 0 \n        return [1] + tri(n-1) +\
    \ tri(n-2)\n    else \n        return [1] + tri(n-1) + tri(n-2) + tri(n+1) + tri(n+2)",
  "    if n==0\n        return [1 ,3 ,3 ,8]\n    if n==1\n        return [1 ,2 ,3\
    \ ,8]\n    if n==2\n        return [2 ,3 ,5 ,8]\n    if n==3\n        return [2\
    \ ,3 ,5 ,8]\n    if n==4\n        return [3 ,5 ,7 ,8]\n    return tri(3-n) + tri(n-3)+tri(n-2)\n\
    end\n</code>\n<|/ a tags=recursion,fibonacci,julia dscore=2 |>\n<| a tags=recursion,fibonacci,julia\
    \ |>\n<code>", "    tri_seq = [3,1]\n    if isodd(n)\n        for i= 2 to n\n\
    \            tri_seq = [tri_seq[end] + tri_seq[end-1] + tri_seq[end-2], tri_seq[end]]\
    \ \n        end\n    end\n    tri_seq\nend", "    if n == 0 \n        Vector{Int64}([3])\n\
    \    else if n == 1\n        Vector{Int64}([1, 3, 2])\n    else\n        tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1)\n    end\nend", "    if n <= 1\n        throw(ArgumentError(\"\
    n must be positive\"))\n    end\n    if mod(n,2) == 0\n        return (tri(n -\
    \ 1) + tri(n - 2) + tri(n + 1))\n    else\n        return (tri(n - 1) + tri(n\
    \ - 2) + tri(n - 3))\n    end\nend\n</cell>\n<code language=julia-0.6>\n@assert\
    \ tri(3) == [1, 3, 2, 8]\n</cell>\n<text>\nExercise 2\nFor the function tri above\
    \ you might want to use Base.Prod.", "    if n==1 \n        return [1]\n    if\
    \ n==2 \n        return [1, 1]\n    if n==3 \n        return [1, 3, 2]\n    return\
    \ tri(n - 1)+tri(n - 2)+tri(n - 3)\nend\n</code>\n<|/ a tags=fibonacci,julia,recursion,performance\
    \ |>\n<| c |>\nThe complexity of this function is O(2^N) instead of O(N). Also,\
    \ you only need to consider the first 3 elements of the sequence instead of all\
    \ elements if n is 3. So you can just do `if n<3 return [1]` instead of `if n==3`\n\
    <|/ c |>\n<| c |>\nThe complexity of the function is actually O(2^n) because each\
    \ call takes the worst case O(2^n) (which can still be made faster by caching)\
    \ where n is the current length of the vector. \nThe complexity of the function\
    \ is O(n^2) because each call is O(2^n) and each recursion is O(n).", "    if\
    \ n == 0\n        Vector{Int64}[1]\n    elseif n == 2\n        Vector{Int64}[3]\n\
    \    elseif n % 2 == 0\n        tri(n - 1) + tri(n - 2) + tri(n - 3)\n    else\n\
    \        tri(n - 1) + tri(n - 2) + tri(n + 1)\n    end\nend", "  if n <= 2 \n\
    \    vec!(n,3) \n  else \n    vec!(tri(n-1), tri(n-2) + tri(n+1), tri(n-2) + tri(n+1)\
    \ + 1) \n  end\nend", "    if n==1 \n        return [1,] \n    end\n    # tri(n-1)\
    \ + tri(n-2) + tri(n+1) + 1 \n    tri(n) = tri(n-1) + tri(n-2) + tri(n+1) + 1\n\
    end\n</code>\n<|/ a tags=fibonacci,julia dscore=1 |>\n<| c |>\nYou need `Int`\
    \ instead of `Int64`. `Int64` is for 64-bit numbers, not for integers.\n<|/ c\
    \ |>\n<| a dscore=1 tags=fibonacci,julia |>\n<code>\n# using fibonacci formula ",
  "    if n == 0 \n        Vector{Int64}(0)\n    else if n==1 \n        Vector{Int64}(1)\n\
    \    else if n==2 \n        Vector{Int64}(1,2)\n    else \n        tri(floor(Int,\
    \ n/2))\n        tri(ceil(Int, n/2))\n        tri(n+1-(floor(Int, n/2)))\n   \
    \     tri(n+1-(ceil(Int, n/2)))\n    end\nend", "    if n==0\n        return Int64[]\n\
    \    end\n    if n==1\n        return Int64[1]\n    end\n    vec = tri(n - 1)\
    \ + tri(n - 2) + tri(n + 1) \n    if n % 2 == 1\n        push!(vec,vec(end))\n\
    \    end\n    vec\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Write a function\
    \ factorial that computes n! where n is an integer.\"\"\"", "    if n == 1\n \
    \       return Vector{Int64}([1,1])\n    else if n <= 4\n        return Vector{Int64}([n,n])\n\
    \    else\n        lo, mid, hi = 1, 3, n\n        while lo < hi\n            mid\
    \ = lo + hi\n            lo = lo + hi\n            hi = mid\n        end\n   \
    \     lo = lo + hi\n        return Vector{Int64}([lo,hi])\n    end\nend", "  \
    \  if n == 1\n        return [1]\n    else\n        return [tri(n - 1) + tri(n\
    \ - 2) + tri(n + 1)]\n    end\nend\n</cell>\n<code language=julia-0.5>\n\"\"\"\
    \n    fib(n)\nReturns the nth element in the Fibonacci sequence\nFibonacci sequence:\
    \ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...\nThe sequence starts with\
    \ 0 and 1, then each subsequent term is the sum of the previous two.\nWe define\
    \ Fibonacci sequence by the recurrence relation:\nfib(0) = 0\nfib(1) = 1\nfib(n)\
    \ = fib(n-2) + fib(n-1)\nFor example:\nfib(2) = 2\nfib(3) = 3 + 1 = 4\nfib(1)\
    \ = 1\nExamples\n>>> fib(0)\n0\n>>> fib(1)\n1\n>>> fib(3)\nfib(n) = fib(n-2) +\
    \ fib(n-1)\n       = 3 + 1 + fib(n-2) = fib(n-3) + fib(n-2)\n       = 3 + 2 +\
    \ fib(n-1) = fib(n-3) + fib(n-3)\n       = 3 + fib(n-2) + fib(n-3)\n       = 3\
    \ + fib(n-3) + fib(n-2)\n       = 3 + fib(n-3)\n      fib(n)\n\"\"\"", "    \n\
    \    # base case\n    if n < 2 \n        return [1] \n    \n    # recursive case\n\
    \    if n == 2 \n        return [3] \n    else\n        return tri(n / 2) + tri(n\
    \ - 1) + tri(n + 1)\nend\n</cell>\n<text>\nProblem 3\nWrite a function that checks\
    \ whether a given year is a leap year.", "    push!(res, 1)\n    if n % 2 == 0\
    \ \n        push!(res, 2)\n    else\n        push!(res, tri(n - 1) + tri(n - 2)\
    \ + tri(n + 1))\n    end\n    res\nend\n</cell>\n<text>\nExercise 5", "    \n\
    \    if n == 0\n        return [1]\n    end\n    \n    tri_1 = tri(n - 1) + tri(n\
    \ - 2)\n    tri_2 = tri(n - 3) + tri(n - 4) + tri(n - 5) + tri(n - 6) + tri(n\
    \ - 7)\n    return tri_1 + tri_2\nend\n</cell>\n<text>\nProblem 9\nThe four adjacent\
    \ digits in the 1000-digit number that have the greatest product are 9 \xD7 9\
    \ \xD7 8 \xD7 9 = 5832.", "    if n==0 || n==1\n        [1]\n    else\n      \
    \  tri(n-1)+tri(n-2) + tri(n+1)\n    end\nend\n</code>\n<|/ a dscore=2 |>\n<|\
    \ a dscore=2 |>\nIn one line:\n<code>", "    if (n <= 0)\n        error(\"n must\
    \ be a positive integer\")\n    end\n    if n == 2\n        return [1,3]\n   \
    \ end\n    if n == 1\n        return [1,1]\n    end\n    return [tri(n - 1) +\
    \ tri(n - 2), tri(n - 1) + tri(n - 2) + tri(n + 1)]\nend\n</cell>\n<text>\nExercise\
    \ 2", "    if n==1 then return [1]\n    if n==2 then return [1,3]\n    if mod(n,2)==1\
    \ then return [3,3]\n    \n    # tri(2n) = 3(2n) + 2(n+1)\n    tri = (tri[2*n-2]\
    \ + tri[2*n-1]) |> add\n    # tri(2n+1) = 3(2n+1) + 2(n+1)\n    tri = (tri[2*n-1]\
    \ + tri[2*n+1]) |> add\n    # tri(2n+2) = 3(2n+1) + 2(2n+1)\n    tri = (tri[2*n+1]\
    \ + tri[2*n]) |> add\n    return tri\nend", "    if n == 0\n        return Vector{Int64}()\n\
    \    end\n    if n % 2 == 0\n        return tri(n - 1) + tri(n - 2) + tri(n +\
    \ 1)\n    end\n    return tri(n - 1) + tri(n - 2) + tri(n - 1) + tri(n - 2) +\
    \ tri(n - 3) + tri(n + 1)\nend\n</cell>\n<text>\nProblem 4.1\nLet us rewrite our\
    \ implementation from before:", "    if n == 1 \n        return [3]\n    else\
    \ \n        tri_new = tri(n - 1) + tri(n - 2) + tri(n + 1) \n        return tri_new\
    \ \n    end\nend", "    if n<0\n        return error(\"The input is non-positive\"\
    )\n    end\n    if n == 0 \n        return Vector{Int64}[1]\n    end\n    \n \
    \   if n%2 == 1\n        return tri(n - 1) + tri(n - 2) + tri(n + 1)\n    end\n\
    \    \n    tri(n - 1) + tri(n - 2) + tri(n + 1)\nend\n</cell>\n<text>\nTribonacci\
    \ sequence", "    if n == 1\n        return [1]\n    end", "    \n    \n    vec\
    \ = [3,1]\n    if n % 2==0 \n        vec[1] = vec[1] + vec[2] + vec[3]\n    else\n\
    \        vec[1] = vec[1] + vec[2] + vec[3]\n        vec[2] = vec[1]\n    end\n\
    \    return vec\nend", "    tri_vec = Vector{Int64}(10)\n    for i = 1:10\n  \
    \      tri_vec[i] = (tri(i-1) + tri(i-2) + tri(i+1))\n    end\n    tri_vec\nend\n\
    </cell>\n<text>\nLet's try the function and see how it works:", "    if n == 1\n\
    \        [1]\n    else\n        tri(n - 1) + tri(n - 2) + tri(n + 1)\n    end\n\
    end\n</code>\n<|/ a tags=recursion,fibonacci,julia |>\n<| a tags=recursion,fibonacci,julia\
    \ |>\n<code>", "    if n == 1\n        vec[1] = 1\n        return vec\n    end\n\
    \    \n    vec[2] = tri(n - 1) + tri(n - 2) + tri(n + 1)\n    return vec\nend",
  "    if n == 0\n        return Vector{Int64}[]\n    elseif n == 1\n        return\
    \ [1]\n    else\n        return tri(n / 2) + [n / 2] + tri(n / 2)\n    end\nend",
  "    if n == 0 \n        return [Int64(3)]\n    elseif n <= 1 \n        return [Int64(n)]\n\
    \    elseif n % 2 == 0 \n        n /= 2\n        return tri(n-1) + tri(n-2)\n\
    \    else\n        n += 1\n        return tri(n-1) + tri(n-2) + tri(n+1) + tri(n+2)\n\
    \    end\nend\n</cell>\n<text>\nLet's run this cell to see what happens.", " \
    \   \n    if n == 0\n        vec[1]=1\n        vec[2]=2\n    elseif n==1\n   \
    \     vec[1]=2\n        vec[2]=1\n    elseif n==2\n        vec[1]=1\n        vec[2]=2\n\
    \    elseif n==3\n        vec[1]=1\n        vec[2]=2\n    elseif n==4\n      \
    \  vec[1]=1\n        vec[2]=3\n    else\n        vec[1]=tri(n-1)+tri(n-2)+tri(n+2)\n\
    \    end\n    return vec\nend", '    return tri_helper(n)', "    if n == 0\n \
    \       return [1,1]\n    elseif n == 2\n        return [3,1]\n    elseif n %\
    \ 2==0\n        a_1 = n-1\n        a_2 = n-2\n        b_1 = 2*a_1 - a_2\n    \
    \    b_2 = 2*a_2 + a_1\n        \n        tri_1 = tri(a_1)\n        tri_2 = tri(b_1)\n\
    \        tri_3 = tri(b_2)\n        \n        return [tri_1 + tri_2 + tri_3]\n\
    \    else\n        a_1 = n-1\n        a_2 = n-2\n        b_1 = 2*a_1 - a_2\n \
    \       b_2 = 2*a_2 + a_1\n        \n        tri_1 = tri(a_1)\n        tri_2 =\
    \ tri(b_1)\n        tri_3 = tri(b_2)\n        \n        tri_4 = tri(a_2)\n   \
    \     tri_5 = tri(b_2)\n        \n        tri_6 = tri(b_1)\n        \n       \
    \ return [tri_1, tri_2 + tri_3 + tri_4, tri_5, tri_6]\n    end\nend\n</cell>\n\
    <code language=julia-1.6>\n@assert tri(3) == [1,3,2,8]\n</cell>\n<text>\nThe Fibonacci\
    \ numbers grow very rapidly and have some interesting properties.\nThey are often\
    \ used in computer science and are defined as:\n$F_{n} = F(n-1) + F(n-2)$, where\
    \ $F(0) = F_1 = 1$.\nThe first few Fibonacci numbers are:\n$F(1) = 1$, $F(2) =\
    \ 1$, $F(3) = 2$, $F(4) = 3$, $F(5) = 5$, $F(6) = 11$, and $F(7) = 89$.\nThe sum\
    \ of the first ten Fibonacci numbers is $F(10) = F(9) + F(8) = F(7) + F(6) + F(5)$,\n\
    and so on. By starting with $F(0) = F_1 = 1$ and $F(1) = F_2 = 0$, $F(2) = 1$\
    \ and \n$F(3) = F(4) = 1$ and $F(4) = F(5) = 1$, $F(5) = F(6) = F(7) = F(8) =\
    \ F(9) = 1$ and \n$F(8) = F(10) = 1$ and $F(10) = F(11) = F(12) = 1$ and $F(11)\
    \ = F(13) = F(14) = 1$.\nThe terms $F_i$ are the first $i$ Fibon", "    result\
    \ =  Vector{Int64}(length(n+1))\n    if n==2\n        result[1]=3\n        return\
    \ result\n    else\n        for i in range(3, n+1)\n            result[i-1] =\
    \ tri(i-1) + tri(i-2) + tri(i-3)\n        end\n    end\n    return result \nend ",
  "    \n    if n == 1 \n        return [1]\n    \n    if n % 2 == 1 \n        return\
    \ tri(n / 2) + [tri(n - 1) + tri(n - 2)]\n    \n    return tri(n / 2) + [tri(n\
    \ - 2) + tri(n - 1)]\nend\n</cell>\n<text>\nProblem 3\nWrite a Julia function\
    \ to find the n-th Fibonacci number.", "    # initialize first 3 elements of the\
    \ vector\n    vec = [3]\n    # add the previous 2 elements of the vector\n   \
    \ for i in 1:3\n        vec[i] = vec[i-1] + vec[i-2] + vec[i-3]\n    end\n   \
    \ return vec\nend\n</cell>\n<text>\n4.2 Write a function called tri2 that has\
    \ the same input and returns different outputs. You can assume the input is positive.",
  "    if n == 1 \n        return Vector{Int64}(1)\n    elseif n % 2 == 1\n      \
    \  n = n / 2\n        tri(n)\n    else \n        n = (n + 1) /2\n        tri(n)\n\
    \    end\nend\n</code>\n<|/ a |>\n<| c |>\nThis was actually very helpful! Thank\
    \ you\n<|/ c |>\n<| c |>\nThanks, it works! One issue though, when n = 3 it gives\
    \ me an error for the line `if n % 2 == 1`. Any idea why this is?\n<|/ c |>\n\
    <| c |>\nit gives an error for the line `if n % 2 == 1` because you didn't add\
    \ `else` before it. So the code just goes to `else` part and there is no `else`\
    \ for the `if`. So, when `n` is 3, it gives error for `n % 2 == 1`. So just add\
    \ `else` before it.\n<|/ c |>\n<| c |>\nAhhh, thanks! I didn't know that. I will\
    \ accept your answer as soon as I can.\n<|/ c |>\n<| a tags=julia |>\nAnother\
    \ Julia way could be as follows:\n<code>", "    if n==0\n        zeros(1,1)\n\
    \    else\n        tup=(n-1)/2\n        tri1=tri(tup)\n        tri2=tri(tup-1)+tri(tup-2)\n\
    \        tup=(n+1)/2\n        tri3=tri(tup)\n        tri4=tri(tup-1)+tri(tup-2)+tri(tup-3)\n\
    \        tup=(n+2)/2\n        tri5=tri(tup)\n        tri6=tri(tup-1)+tri(tup-2)+tri(tup-3)+tri(tup-4)\n\
    \        return tri1,tri2,tri3,tri4,tri5,tri6\n    end\nend", "    if n==1 \n\
    \        return [1,1]\n    elseif n==2 \n        return [1] \n    elseif n==3\
    \ \n        return [3]\n    elseif n%2 == 1 \n        return tri(n-1) + tri(n-2)\
    \ \n    else\n        return tri(n-1) + tri(n-2) + tri(n-3) + tri(n-4)\n    end\n\
    end\n</cell>\n<code language=julia-1.0>\n\"\"\"\n    tri(n::Int64)", "    if n\
    \ == 1\n        vec = []\n    else\n        vec = tri(n - 1) + tri(n - 2) + tri(n\
    \ + 1)\n    end\n    return vec\nend", "    if n < 1 \n        return vec() \n\
    \    \n    elseif n == 1 \n        return vec([3]) \n    \n    elseif n == 2 \n\
    \        return vec([3, 1]) \n    \n    elseif n % 2 == 0 \n        a, b = tri(n\
    \ / 2)\n        c = 1 + n / 2\n        return vec([a,b,c]) \n    \n    else \n\
    \        a, b = tri(n / 2)\n        c = tri(n / 2) + 1 + n / 2\n        return\
    \ vec([a,b,c]) \n    end\nend", "    if n==1 \n        return [1]\n    if n==2\n\
    \        return [3]\n    if n%2==0 \n        return tri(n-1) + tri(n-2)\n    end\n\
    \    return tri(n-1) + tri(n-2) + tri(n+1)\nend\n</cell>\n<text>\nThe function\
    \ tri takes one argument, the number n. tri(n) returns a vector of the first n\
    \ + 1 numbers of the Tribonacci sequence.", "    \n    \n    if n == 1 \n    \
    \    return [1] \n    \n    if n == 2 \n        return [1, 2] \n    \n    if n\
    \ % 2 == 0 \n        n1 = tri(n - 1)\n        n2 = tri(n - 2)\n        return\
    \ [n1[2], n1[1] + n2[1], n2[2], n[1] + n[2]]\n    \n    n1 = tri(n - 1)\n    n2\
    \ = tri(n - 2)\n    n3 = tri(n - 3)\n    return [n1[2], n1[1] + n2[1] + n3[1],\
    \ n2[2] + n3[2], n[3] + n[1]] \n    \nend # end of function tri()", "    if (n<2)\n\
    \        return [1]\n    else\n        return tri(n-1) + tri(n-2) + tri(n+2)\n\
    \    end\nend", "    if n==1\n        return [1]\n    elif n%2 == 0\n        return\
    \ tri(n-1) + tri(n-2)\n    else\n        return tri(n-1) + tri(n-2) + tri(n-3)\n\
    end\n</code>\n<|/ a tags=recursion,julia,dynamic-programming |>\n<| a |>\nThis\
    \ solution uses memoization to speed up the problem. For a detailed explanation\
    \ have a look at the original answer by user3777540 here\n<code>\n#Recurrence\
    \ relation", "    if (n <= 0) \n        error(\"Tribonacci sequence function only\
    \ accepts non-negative integers\")\n    else \n        first = (3 + (2 * n)) /\
    \ 2\n        second = (1 + n) / 2 \n        third = (first+second)\n    end\n\
    \    return Vector{Int64}([first, second, third])\nend", "    if n % 2 == 0\n\
    \        return [tri(n / 2) + tri(n / 2)]\n    else\n        return [tri(n / 2)\
    \ + tri(n / 2) + tri(n / 2)]\n    end\nend\n</cell>\n<text>\nThe task is to find\
    \ the sum of numbers in range $[0,n[,]$ that are divisible by $3$. \nThe function\
    \ below finds the sum of numbers between $0$ and $n$ that are divisible by $3$:",
  "    if n<3\n        Vector{Int64}(1,n)\n    else\n        tri(n-2) + tri(n-1) +\
    \ tri(n-2)\n    end\nend", "    if n < 0\n        error(\"The argument must be\
    \ non-negative\")\n    trivec = []\n    if n==0\n        trivec = [3]\n      \
    \  return trivec\n    if n==1\n        trivec = [3]\n        return trivec\n \
    \   trivec = [tri(n - 1) + tri(n - 2) + tri(n + 1)]\n    return trivec\nend\n\"\
    \"\"\n    sum_of_all_primes(n)\n    Sum all primes up to n.\n    Your code goes\
    \ here.\n    Examples:\n    >>> sum_of_all_primes(5)\n    30\n    \"\"\"", " \
    \   if n == 1 \n        Vector{Int64}(undef, 0) \n    elseif n == 2\n        Vector{Int64}(3,1)\n\
    \    elseif n == 3 \n        Vector{Int64}(1,2,3)\n    elseif n % 2 == 0\n   \
    \     tri(n-1) + tri(n-2) + tri(n+2)\n    else\n        tri(n-1) + tri(n-2) +\
    \ tri(n+1) + tri(n+2)\n    end\nend\n</cell>\n<code language=julia-1.5>", "  \
    \  if n <= 1 \n        error(\"n should be positive\")\n    else\n        vec(n)\
    \ = vec(n-1) + vec(n-2) + vec(n+1)\n    end\nend\n</cell>\n<text>\nExercise 9:\
    \ Recursion ", "    if n==0\n        return Vector{Int64}()\n    if n==1\n   \
    \     return [1]\n    tris = tri(n-1) + tri(n-2) + tri(n+1)\n    return tris\n\
    end\n</cell>\n<text>\nExercise 13. Write a function that returns the value of\
    \ n-th element of a Fibonacci sequence. The function takes an integer $n$ as input\
    \ and outputs an integer as output.\nExamples:\n    >>> fib(3)\n    8\n    >>>\
    \ fib(4)\n    13\n    >>> fib(5)\n    34\n    >>> fib(6)\n    55\n    >>> fib(7)\n\
    \    89\n    >>> fib(8)\n    144\n    >>> fib(9)\n    233\n    >>> fib(10)\n \
    \   377\n    >>> fib(11)\n    610\n    >>> fib(12)\n    987\n    >>> fib(13)\n\
    \    1597\n    >>> fib(14)\n    2584\n    >>> fib(15)\n    4181\n    >>> fib(16)\n\
    \    6765\n    >>> fib(17)\n    10946\n    >>> fib(18)\n    17711\n    >>> fib(19)\n\
    \    28657\n    >>> fib(20)\n    46655\n    >>> fib(21)\n    69607\n    >>> fib(22)\n\
    \    1094657\n    >>> fib(23)\n    1777616\n    >>> fib(24)\n    28657436\n  \
    \  >>> fib(25)\n    46655138\n    >>> fib(26)\n    69607681\n    >>> fib(27)\n\
    \    109465737\n    >>> fib(28)\n    177761651\n    >>> fib(29)\n    286574367\n\
    \    >>> fib(30)\n    466551387\n    >>> fib(31)\n    696076812\n    >>> fib(32)\n\
    \    1094657380\n    >>> fib(33)\n    1777616641\n    >>> fib(34)\n    2865743678\n\
    \    >>> fib(35)\n    4665513879\n    >>> fib(36)\n    6960768123\n    >>> fib(37)\n\
    \    10946573808\n    >>> fib(38)\n    177761664010\n    >>> fib(39)\n    286574368007\n\
    \    >>> fib(40)\n    466551388071\n    >>> fib(41)\n    696076812310\n    >>>\
    \ fib(42)\n    1094657380905\n    >>> fib(43)\n    1777616640110\n", "    if n\
    \ == 0 \n        Vector{Int64}()\n    else if n == 1 \n        Vector{Int64}(1)\n\
    \    else if n == 2 \n        Vector{Int64}(3, 2)\n    else\n        n1 = tri(n\
    \ - 1)\n        n2 = tri(n - 2)\n        n3 = tri(n - 1)\n        push!(n1, n2)\n\
    \        push!(n2, n3)\n        push!(n3, n1)\n        n1\n    end\nend\n</cell>\n\
    <text>\nExercise 2.\nWrite a function that computes factorial of a number. Your\
    \ function should work for non-negative integer and should return Inf if the number\
    \ is 0. The function should work for BigInt as well. The function should work\
    \ for Float64 as well.", "    if n < 2\n        return fill(1.0, n+1)\n    end\n\
    \    tri(n - 2) + tri(n - 1) + tri(n - (n+1)) \nend\n</cell>\n<code language=julia-0.4>\n\
    \"\"\"\n    factorial(n::Int64)\n    Recursively computes factorial of n\n   \
    \ Argument:\n        n -- an integer\n    Returns:\n        factorial -- a number\n\
    \    Examples:\n    >>> factorial(1)\n    1\n    >>> factorial(5)\n    120\n \
    \   \"\"\"", "    if n == 1 \n        return [1]\n    else \n        result =\
    \ []\n        for i in range(n-2)\n            result = [result[i-1]+result[i]+result[i+1]]\n\
    \        return result\n    end\nend\n</cell>\n<text>\nProblem 10\nYou have been\
    \ given a non-negative number n and you have to find the number of digits of its\
    \ \nbinary representation.", "    if n == 0\n        vec = Vector{Int64}()\n \
    \   elseif n == 1\n        vec = [3]\n    else\n        vec = tri(n - 1) + tri(n\
    \ - 2) + tri(n + 1)\n    end\nend\n</code>\n<|/ a tags=performance,julia |>\n\
    <| a |>\nAnother option that is more efficient than others is to use dynamic programming\
    \ (memoization):\n<code>", "    if n == 1\n        [1]\n    else\n        tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1)\n    end\nend\n</cell>\n<text>\nQuestion 4\n\
    Write a function is_palindrome(x::Int64)::Bool that returns whether an integer\
    \ number x is a palindrome.\nExamples:\n    >>> is_palindrome(141)\n    true\n\
    \    >>> is_palindrome(121)\n    false\n    >>> is_palindrome(1212)\n    true\n\
    \    >>> is_palindrome(122)\n    false\n    \"\"\"", "    if n==1\n        return\
    \ [1]\n    \n    if n==2\n        return [1,1]\n    \n    if n%3==0\n        return\
    \ tri(n-1) + tri(n-2) + tri(n+2)\n    end\n    return tri(n-1) + tri(n-2) + tri(n+2)\
    \ + tri(n+1)\nend", "    base = Int64(1)\n    tri = Array{Int64}(undef, n +1)\n\
    \    for i in 1 : n\n        tri[i] = tri[i-1] + base\n        base = base + 2\n\
    \    end\n    return tri\nend", "    if n == 1 then return [1]\n    if n % 2 ==\
    \ 0 then return tri(n-1) + tri(n-2)\n    if n % 2 != 0 then return tri(n-1) +\
    \ tri(n-2) + tri(n-2)\nend ", "    if n==2 \n        tri=[1,3] \n    else \n \
    \       tri=[n,(tri[n-2] + tri[n-1])/2] \n    end\n    return tri\nend\n</code>\n\
    I used the Fibonacci function in my code to solve the Tribonacci sequence, and\
    \ it works well. Here is the code I used:\n<code>", "  \n    if n<2 \n       \
    \ return [1] \n    elseif n==2 \n        return [2]\n    elseif n==3 \n      \
    \  return [1,3] \n    elseif n==4 \n        return [2]\n    elseif n==5 \n   \
    \     return [1,2]\n    elseif n>5 \n        n-=3\n        tri(n) + tri(n-2)+tri(n-4)+tri(n-6)\n\
    \    end\nend\n</cell>\n<cell>", "    if n==0\n        vec=[1,3,2]\n    else\n\
    \        vec=[1,3]\n        vec=[vec[1],vec[2]+vec[1],vec[2],vec[1],vec[2]+vec[1],vec[2]]\n\
    \    end\nend\n\"\"\"\n    \"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\
    \"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\
    \"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\
    \"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\
    \n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\
    \"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\
    \"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\
    \"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\
    \n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\
    \"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\
    \"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\
    \"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\
    \n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\
    \"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\
    \"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\
    \"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\
    \n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\
    \"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\
    \"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\
    \"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\
    \n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\
    \"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\
    \"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\
    \"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\
    \n\"\"\"", "    if n == 1\n        return [1]\n    elseif n == 2\n        return\
    \ [1, 1]\n    else\n        tup = tri(n - 1) + tri(n - 2) + tri(n + 1)\n     \
    \   return tup + tup[2:end]\n    end\nend\n\"\"\"\n    Fibonacci sequence\n  \
    \  What is Fibonacci sequence?\n    A Fibonacci sequence is a sequence of numbers,\
    \ starting with 1, and \n    finishing with the number 1. The sequence starts\
    \ with a 1, \n    then 2, then 3, and so on. For example,\n    1, 3, 8, 13, 21,\
    \ 34, 55 \n    would have appeared as:\n    1, 1, 2, 3, 5, 8, 13, 21, 34 \n  \
    \  Hence, the Fibonacci sequence grows very quickly. \n    You have been tasked\
    \ with finding the first 10 numbers of the \n    Fibonacci sequence that result\
    \ in a Fibonacci number greater than 40000.\n    You will need to store all of\
    \ the numbers in an array and use \n    the function find to find the first 10\
    \ numbers in that array that \n    result in a Fibonacci number greater than 40000.\n\
    \    Input Format:\n    The first line of the input contains T denoting the number\
    \ of test cases. \n    T test cases follow. Each test case contains an integer\
    \ n.\n    Constraints:\n    1 \u2264 T \u2264 500\n    -10\u2264 n \u2264 10\n\
    \    Output Format:\n    For each test case, output one integer which is the first\
    \ 10 numbers of the \n    Fibonacci sequence that result in a Fibonacci number\
    \ greater than 40000.\n    Sample Input:\n    2\n    40000\n    Sample Output:\n\
    \    10 \n    33\n    Explanation: \n    The first 10 numbers of the Fibonacci\
    \ sequence that result in a Fibonacci \n    number greater than 40000 are 1, 1,\
    \ 2, 3, 5, 8, 13, 21, 34\n\"\"\"", "    n = n-2 # since n starts at 1, we subtract\
    \ 2 from n\n    if n == 1\n        return [1]\n    else\n        return tri(n)\
    \ + tri(n-1)\n    end\nend\n</cell>\n<text>\nProblem 7\nThe Fibonacci sequence\
    \ is defined by the recurrence:\nf(n) = 3 if n = 0\nf(n) = f(n-1) + f(n-2), if\
    \ n > 0.\nWrite a Julia function which computes the nth number of the Fibonacci\
    \ sequence. \nExamples:\nf(5) = 5 \nf(1) = 1 \nf(0) = 0 \nf(n) = f(n-1) + f(n-2),\
    \ if n > 0.", "    result =[Int64]() \n    if n==1 \n        result = [Int64](1)\n\
    \    else \n        tri(n-1)=tri(n-1)+tri(n-2) \n        tri(n-1)=tri(n-1)+tri(n-2)\
    \ \n        result=result+[Int64](tri(n-1)) \n    end \n    return result\nend\n\
    </code>\n<|/ a tags=fibonacci,sequence,julia |>\n<| c |>\nI think you might want\
    \ to add some explanation on what the code does and how it solves the question.\
    \ For example, a beginner might think `tri(n) = tri(n-1) + tri(n-2)` means `tri(n)\
    \ = n + tri(n-1)` which would be wrong.\n<|/ c |>\n<| c |>\nI agree. I updated\
    \ the answer. Thanks!\n<|/ c |>\n<| a dscore=2 |>\nUsing Julia 1.0:\n<code>\n\
    f(n, m::Int) = n >= m ? 1 : f(n, m - 1) + f(n, m - 2)\nf(n) = f(n, 5)\n</code>\n\
    <|/ a tags=fibonacci,sequence,julia |>\n<| a tags=fibonacci,sequence,julia |>\n\
    A version without recursive calls:\n<code>\nfib(n) = [1 1; 2 2; 3 3; 4 5; 5 8;\
    \ 6 13; 7 21; 8 34; 9 55; 10 89]\nfibonacci(n) = [fib(n+i) for i=1:5]\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis should be the accepted answer. Recursion can\
    \ get expensive in Julia as it compiles the function every time it is called.\
    \ So if you have a problem with it, try using a different approach (iterative\
    \ or just manually calculating Fibonacci numbers).\n<|/ c |>\n<| a dscore=2 |>\n\
    This should do the job:\n<code>", "    if n<=1\n        return [1]\n    \n   \
    \ if mod(n,2) ==0\n        return [1]+tri(mod(n,2))\n    else\n        return\
    \ [1]+tri(floor(div(n,2))-1)+tri(mod(n,2))", "    if n == 1 \n        return [1]\n\
    \    if n == 2\n        return [1, 1]\n    else\n        return tri(n-1) + tri(n-2)\
    \ + tri(n+1)\nend", "    if n==1 \n        return [3]\n    else\n        tri(ceil(n/2))\
    \ = [tri(ceil(n div 2)) + tri(ceil(n div 2))]\n    end\nend", "    \n    if n\
    \ == 2\n        one = Vector{Int64}([1]) \n        return one\n    elseif n %\
    \ 2 == 0\n        one = Vector{Int64}([3])\n        two = tri(n-1)\n        return\
    \ one + two\n    else\n        one = tri(n - 1)\n        two = tri(n - 2)\n  \
    \      three = tri(n + 1) \n        return one + two + three\n    end\nend\n</cell>\n\
    <cell>\n\"\"\"\n    twos(n::Int64)::Vector{Int64}\n    \n    Return the first\
    \ n + 1 numbers of the Twist sequence.\n    Examples:\n    >>> twos(3)\n    [3,\
    \ 7, 11, 15]\n    \"\"\"", "    trivector = [1,2,3]\n    \n    if n % 2 == 0\n\
    \        trivector = [trivector[1]+trivector[2]+trivector[3]]\n    end\n    \n\
    \    return trivector\nend\n</cell>\n<code language=julia-0.6>\n#Example 3\ntri(3)\n\
    </cell>\n<text>\nTask 8 (1 point)\nDesign a function that generates Fibonacci\
    \ numbers up to a given limit.", "    if n == 0\n        return [3]\n    else\n\
    \        push!(returnArray,3)\n        for i = 1:n\n            if mod(i+2,2)==1\n\
    \                push!(returnArray,i+1)\n            else\n                push!(returnArray,i-1)\n\
    \                push!(returnArray,i+2)\n            end\n        end\n      \
    \  returnArray\n    end\nend\n</cell>\n<code language=julia-1.4>\ntri(10)\n</cell>\n\
    <code language=julia-1.4>\n\"\"\"\n    fib(n::Int64)", "    if n == 1 \n     \
    \   [1]\n    else \n        tri(n - 1) + tri(n - 2) + tri(n + 1)\n    end\nend\n\
    </cell>\n<text>\nImplement fibonacci(n) in Julia", "    if n==0\n        Vector{}\n\
    \    else if n==1\n        [1]\n    elseif n==2\n        [1,2]\n    else\n   \
    \     tri(n-1)+tri(n-2) + tri(n+2)\n    end\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThis doesn't work in Julia, the error you get is:  LoadError: LoadError:\
    \ MethodError: no method matching +(::Int64, ::Int64)\nClosest candidates are:\n\
    \  +(::Any, ::Any) at operators.jl:153\n  +(::Any, ::Any) at abstractarray.jl:1285\n\
    \  ...\n<|/ c |>\n<| c |>\nThis also doesn't work:\n`julia> using LinearAlgebra\n\
    julia> function tri(n::Int64)\n           if n==0\n                Vector{}\n\
    \           else if n==1\n                [1]\n           elseif n==2\n      \
    \          Vector{Int64}[1,2]\n           else\n                tri(n-1)+tri(n-2)\
    \ + tri(n+2)\n           end\n       end\nERROR: LoadError: MethodError: no method\
    \ matching +(::Int64, ::Int64)\nClosest candidates are:\n  +(::Any, ::Any) at\
    \ operators.jl:153\n  +(::Any, ::Any) at abstractarray.jl:1285\n  ...`\n<|/ c\
    \ |>\n<| c |>\nWhat about `julia> tri(3) -> [1, 3, 2, 8]`?\n<|/ c |>\n<| c |>\n\
    Yes, it works. I got confused because I tried to assign the result to a variable\
    \ (I should have used `=` instead of `->`).\n<|/ c |>\n<| c |>\nAnd if anyone\
    \ would like to know how I got it to work in Julia, just add the lines `using\
    \ LinearAlgebra` `using LinearAlgebra.Precison` right before the `function tri(n::Int64)::Vector{Int64}\
    \ ` line.\n<|/ c |>\n<| a tags=julia,functional-programming,recursion dscore=1\
    \ |>\nThis should work:\n<code>\njulia> function tri(n::Int64)::Vector{Int64}\n\
    \           if n < 2\n               Vector{}\n           elseif n == 2\n    \
    \           [1]\n           else\n               tri(n-1)+tri(n-2) + tri(n+2)\n\
    \           end\n       end\n</code>\nThe reason for the error you got is that\
    \ the + operator has type +(a::", "    if n == 1 \n        x =  1 \n    else \n\
    \        x =  tri(n - 1) + tri(n - 2) + tri(n + 1) \n    end\n    return x\nend\n\
    </cell>\n<cell>\n@testset \"Tribonacci tests\" begin\n    @test tri(2) == [1,2,3]\n\
    \    @test tri(3) == [1,2,8]\n    @test tri(6) == [1,1,5,13,21,34,55,89]\n   \
    \ @test tri(7) == [1,1,5,13,21,34,55,89]\n    @test tri(8) == [1,1,5,13,21,34,55,89]\n\
    \    @test tri(10) == [1,1,5,13,21,34,55,89]\n    @test tri(20) == [1,1,5,13,21,34,55,89,157,218,343,556,789,109]\n\
    \    @test tri(100) == [1,1,5,13,21,34,55,89,157,218,343,556,789,109]\nend\n</cell>\n\
    <text>\nProblem 4\nThe four adjacent digits in the 1000-digit number that have\
    \ the greatest product are 9 \xD7 9 \xD7 8 \xD7 9 = 5832.", "    if n == 1\n \
    \       return [1]\n    \n    if isodd?(n) == true \n        push!(ret, tri(n-1))\n\
    \        push!(ret, tri(n-2))\n    else\n        push!(ret, tri(n-1))\n      \
    \  push!(ret, tri(n-2))\n        push!(ret, tri(n))\n    end\n    \nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis answer would be better if you explained what\
    \ you are doing in your code.\n<|/ c |>\n<| c |>\nThis answer is in no way helpful\
    \ to anyone new to Julia. Please don't post answers to questions that are clearly\
    \ answered in tutorials. Also, your answer isn't even valid Julia. Your code has\
    \ syntax errors.\n<|/ c |>\n<| c |>\nThis solution is in no way helpful to anyone\
    \ new to Julia. Please don't post answers to questions that are clearly answered\
    \ in tutorials. Also, your answer isn't even valid Julia. Your code has syntax\
    \ errors.\n<|/ c |>\n<| c |>\nIf you edit your answer and fix these errors, I'll\
    \ gladly remove my downvote.\n<|/ c |>\n<| a tags=julia,recursion,fibonacci dscore=1\
    \ |>\n<code>", "    if n==1 \n        vec = [1,1]\n    elseif n==2\n        vec\
    \ = [1,2]\n    elseif n==3\n        vec = [1,3]\n    elseif n==4\n        vec\
    \ = [2,1,3]\n    else\n        vec = [tri(n-2),tri(n-1),tri(n)+tri(n+1)]\n   \
    \ end\n    return vec\nend", "    if n == 1 \n        return [1,3,2] \n    else\
    \ \n        # recursive case\n        # define tri(n) = fib(n - 1) + fib(n - 2)\
    \ + fib(n - 3), for n > 2\n        tri(n-1) = fib(n - 1) + fib(n - 2) + fib(n\
    \ - 3)\n        # define fib(k) = fib(k - 1) + fib(k - 2) + fib(k - 3), for k\
    \ > 1\n        fib = lambda k::Int64 -> fib(k - 1) + fib(k - 2) + fib(k - 3)\n\
    \        # define fib(0) = 1 and fib(1) = 1\n        fib = lambda k::Int64 ->\
    \ fib(k - 1) + fib(k - 2) + fib(k - 3)\n        # define fib(n) = 3 * fib(n-2)\
    \ + fib(n - 3), for n > 1\n        fib = lambda k::Int64 -> fib(k - 1) + 3 * fib(k\
    \ - 2) + fib(n - 3)\n        # tri(n) =  3 + n / 2\n        tri(n) = tri(n - 1)\
    \ + tri(n - 2) + tri(n - 3)\n    end\nend\n</cell>\n<text>\nExercise 12: Tribonacci\
    \ sequence up to $n$", "    if n == 0\n        return Vector{1}\n    elseif n\
    \ == 1\n        return Vector{2}\n    elseif n % 2 == 0\n        tri_vec = Vector{Int64}(undef,\
    \ n - 1)\n        for i = 1 : n - 1\n            tri_vec[i] = tri_vec[i + 1] +\
    \ tri_vec[i + 2]\n        end\n        tri_vec\n    else\n        tri_vec = Vector{Int64}(undef,\
    \ n - 1)\n        for i = 1 : n - 1\n            tri_vec[i] = tri_vec[i - 1] +\
    \ tri_vec[i - 2] + tri_vec[i]\n        end\n        tri_vec\n    end\nend\n</cell>\n\
    <text>\nQuestion\nNow write a function that accepts an integer and returns the\
    \ first n terms of the \n    Tribonacci sequence as a vector. \n    Examples:\n\
    \    >>> tri(10)\n    [1, 3, 5, 14, 21, 34, 55, 89, 144, 233, 377]\n    \"\"\"",
  "    if n < 1\n        Vector{Int64}()\n    else\n        \n        function two(n::Int64)\n\
    \            return Int(n) + Int(n)/2\n        end\n        \n        Vector{Int64}((two(n)\
    \ for n in 1:n))\n    end\nend\n</cell>\n<text>\nExercise 3: Solution\nWrite the\
    \ function tri which takes n and returns a vector of the first n + 1 numbers of\
    \ the Tribonacci sequence.", "  if n == 0\n    return [0]\n  elseif n == 1\n \
    \   return [1]\n  elseif n == 2\n    return [1, 3]\n  else\n    return tri(n -\
    \ 1) + tri(n - 2) + tri(n + 1)\n  end\nend\n</cell>\n<code language=julia-1.5>",
  "    if n == 1 \n        return [3.0]\n    else if n == 2 \n        return [1.0,\
    \ 2.0]\n    else if n % 2 == 1 \n        return [tri(n - 1) + tri(n - 2)]\n  \
    \  else \n        return [tri(n - 1), tri(n - 2) + tri(n - 3)]\nend\n</cell>\n\
    <text>\nProblem 2.17", "    if n == 1\n        [1]\n    elseif n % 2 == 0\n  \
    \      tri(n - 1) + tri(n - 2)\n    else\n        tri(n - 1) + tri(n - 2) + tri(n\
    \ + 1)\n    end\nend", "    v = Vector{Int64}(undef, (n + 1) * (n + 1) / 2)\n\
    \    v[1] = v[2] = v[3] = v[4] = v[1]\n    for i in 2:(n + 1) \n        v[i] =\
    \ v[i - 1] + v[i - 2] + v[i - 3]\n    end\n    return v\nend", "    if n<2\n \
    \       throw(ArgumentError(\"n must be greater or equal to 2\"))\n    elseif\
    \ n==2\n        Vector{Int64}(3)\n    elseif mod(n,2)==0\n        Vector{Int64}(tri(n-1),tri(n-2),n+tri(n-1))\n\
    \    else\n        Vector{Int64}(n+tri(n-1),tri(n-2),tri(n-1))\n    end\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a |>\nIn Julia, the simplest solution is to use\
    \ the fibs function from Deap.\n<code>\njulia> using Deap", "    if n == 0 \n\
    \        return [1, 2, 3]\n    elseif n == 1 \n        return [1]\n    elseif\
    \ n == 2 \n        return [1, 1]\n    elseif n == 3 \n        return [1, 1, 1]\n\
    \    else \n        z = n-2\n        return [tri(z-1), tri(z), tri(z+1)]\nend",
  "    if n < 1 \n        return Array{Int64}(undef, 0) \n    elsif n % 2 == 0 \n\
    \        return append(tri(n - 1), tri(n - 2)) \n    else \n        return tri(n\
    \ - 1) + tri(n - 2) \nend", "    \n    vec = Vector{Int64}(1)\n    if n <= 1 \n\
    \        push!(vec,1)\n    else \n        if n % 2 == 0 \n            push!(vec,tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1))\n        else \n            push!(vec,tri(n\
    \ - 2) + tri(n + 1))\n        end\n    end\n    return vec\nend", "    if n ==\
    \ 1\n        return Vector{1}\n    elseif n == 2\n        return Vector{2}\n \
    \   elseif n % 2 == 0 \n        return Vector{1, 2}\n    else\n        return\
    \ tri(n - 1) + tri(n - 2) + tri(n + 1)\n    end\nend", "    if n == 0 \n     \
    \   Vector{Int64}() \n    else\n        tri(n-1) + tri(n-2) + tri(n+1), \n   \
    \ end\nend", "    \n    if n==0\n        return []\n    end\n    tri(n)=[tri(n-1)+tri(n-2)+tri(n+1)]\n\
    end", "    if n == 0 \n        return Vector{Int64}() \n    if n == 1 \n     \
    \   return Vector{Int64}(1) \n    if n % 2 == 0 \n        return Vector{Int64}(1..n+1)\n\
    \    else \n        return tri(n - 1) + tri(n - 2) + tri(n - 1)\nend", "    if\
    \ n==0 \n        Vector{Int64}() \n    elseif n==1 \n        [1] \n    elseif\
    \ n==2 \n        [1,1]\n    else\n        tri(n - 1) + tri(n - 2) + tri(n + 1)\
    \ \n    end\nend", "    if n==0 \n        return Vector{Int64}() \n    tri(n-1)\
    \ =  tri(n-2) + tri(n+1) \n    if n%2==1 \n        tri(n) =  tri(n-1)+tri(n-2)+tri(n+1)\
    \ \n    else \n        tri(n) =  tri(n-1)+tri(n-2) \n    end \n    return tri(n)\
    \ \nend \n</cell>\n<code language=julia-1.6>\n\"\"\"\n    fib2(n::Int64)::Vector{Int64}\n\
    Computes the Fibonacci sequence up to n.\n\"\"\"", "    if n < 1 \n        error(\"\
    n should be positive\") \n    elseif n == 1 \n        Vector{Int64}(1) \n    elseif\
    \ n == 2 \n        Vector{Int64}(3, 2) \n    elseif n == 3 \n        Vector{Int64}(1,\
    \ 2, 3) \n    elseif n % 2 == 1 \n        tri(n - 1) + tri(n - 2) + tri(n + 1)\
    \ \n    elseif n % 2 == 0 \n        tri(n - 1) + tri(n + 1) + tri(n / 2) \n  \
    \  else \n        error(\"n is not an integer\") \n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\n\"\"\"\n    fib(n): returns the nth fibonacci number.\n\
    \    fib(0) = fib(1) = 0\n    fib(1) = 1\n    fib(2) = 1\n    ...\n    fib(n)\
    \ = 3 + n/2 - ...\n\"\"\"", "    if n==1 return [1]\n    if mod(n,2)==1 return\
    \ [tri(n-1)+tri(n-2)]\n    return tri(n-1)+tri(n-2)+tri(n+1)\nend", "    if n\
    \ == 0\n        return [1]\n    end\n    tri1 = tri(n - 1) + tri(n - 2)\n    tri2\
    \ = tri(n - 1) + tri(n - 2) + tri(n - 3) + tri(n - 4)\n    return tri1 + tri2\n\
    end", "    if n==1\n        return [1]\n    end\n    return [i + n/2 for i in\
    \ tri(n-1)] + [n for i in tri(n-2)]\nend\n</code>\n<|/ a dscore=5 tags=recursion,julia,fibonacci,fibonacci-heap,algorithm\
    \ |>\n<| a |>\nHere is Julia version:\n<code>\nfibo = Vector{Int}(length(y))",
  "    if n < 3 \n        return Vector{Int64}([], 0)\n    end", "    if n % 2 ==\
    \ 0 \n        return tri(n-1) + tri(n-2)\n    end\n    return tri(n-1)+tri(n-2)+tri(n-1)\n\
    end\n</cell>\n<code language=julia-1.3>\n\"\"\"\n    Fibonacci Series in Julia\n\
    \"\"\"", "    if n == 1 \n        [1]\n    else \n        tri(n-1) + tri(n-2)\
    \ + tri(n-3)\nend\n</cell>\n<text>\nNow we have the two functions to calculate\
    \ the two sequences.", "    if n==1 \n        [1]\n    else \n        # n odd.\
    \ \n        if n%2==0\n            tri(n-1) + tri(n-2) + tri(n+1)\n        else\n\
    \            tri(n-1) + tri(n-2)\n        end\n    end\nend", "    if n<=1\n \
    \       tri(n)\n    else\n        tri(n-1)+tri(n-2)+tri(n+1)\n    end\nend\n</code>\n\
    <|/ a tags=julia,recursion,fibonacci,list |>\n<| a tags=julia,recursion,fibonacci,list\
    \ dscore=2 |>\nYou can try this (just for fun :))\n<code>", "    if n < 0 \n \
    \       error(\"Not valid\")\n    else if n == 2 \n        return [3]\n    else\
    \ if n == 3 \n        return [1, 3, 5]\n    else if n % 2 == 0 \n        tri_seq\
    \ = tri(n - 1) + tri(n - 2)\n    else\n        tri_seq = tri(n - 1) + tri(n -\
    \ 2) + tri(n - 3) + tri(n - 4)\n    end\n    return tri_seq\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| a dscore=1 |>\nI did this in two lines, but not as efficient\
    \ as Mathematica:\n<code>", "    if n==1 \n        return [3] \n    elseif n==2\
    \ \n        return [1, 3] \n    elseif n==3 \n        return [3] \n    else \n\
    \        (a,b) = (tri(n-1) + tri(n-2),tri(n-1) + tri(n-2) + tri(n+1))\n      \
    \  return [a,b] \n    end\nend\n</code>\n<|/ a |>\n<| c |>\nFor anyone else who\
    \ comes across this, the original poster was asking for a solution in Julia. While\
    \ this code is in Julia the original poster was also asking for an explanation.\n\
    <|/ c |>\n<| c |>\nWhat do you mean by \"explanation\"? Do you mean \"how it works\"\
    ? If so, that's a good explanation\n<|/ c |>\n<| a |>\nHere's a Julia version\
    \ that uses the function and map commands to do the work. \n<code>", "    if n\
    \ == 1 \n        return [1]\n    else if n == 2 \n        return [1, 1]\n    else\
    \ \n        tri(n-1) + tri(n-2) + tri(n+1) \n    end\nend\n</cell>\n<code language=julia-0.4>",
  "    if n == 1 \n        return [1] \n    else if n % 2 == 0 \n        tri(n-1)\
    \ = tri(n-1) + tri(n-2) + tri(n+1) \n    else \n        tri(n-1) = tri(n-1) +\
    \ tri(n-2) + tri(n+1) + tri(n+2) \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert tri(3) == [1, 3, 2, 8]\n</cell>\n<code language=julia-1.5>", "    if n==0\
    \ || n==1\n        return Vector{Int64}()\n    elseif n%2 == 0\n        return\
    \ tri(n - 1) + tri(n - 2) + tri(n + 1)\n    else\n        return tri(n - 3) +\
    \ tri(n - 2) + tri(n - 1)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert tri(3) == [1, 3, 2, 8]\n</cell>\n<text>\nExercise 10\nNow you are given\
    \ an integer number n, and you have to find all numbers from 1 to n which have\
    \ the following properties:", "    if n == 1 \n        return [3, 1]\n    else\
    \ \n        a, b = tri(n / 2)\n        c = a[1] + b[2]\n        if n & 1\n   \
    \         return [a, b] + [c]\n        else\n            return a + b + [c]\n\
    \        end\n    end\nend\n</cell>\n<code language=julia-1.0>", "    if n ==\
    \ 0\n        return Vector{Int64}()\n    elseif n % 2 == 0\n        return tri(n\
    \ - 1) + tri(n - 2) + tri(n +1)\n    elseif n > 0\n        return tri(n - 1) +\
    \ tri(n - 2) + tri(n + 1) + tri(n - 3) + tri(n - 4)\n    end\nend\n\"\"\"\n  \
    \  Problem 14\n\"\"\"", "    if n%2 == 0 \n        return tri(n / 2) + tri(n /\
    \ 2) + tri(n / 2) \n    else \n        return tri(n / 2) + tri(n / 2) + tri(n\
    \ / 2) + tri(n / 2) + tri(n / 2) \n    end\nend", "    if n < 1 \n        return\
    \ fill(NaN,n+1)\n    end\n    if n <= 3 \n        return vec[1]\n    end\n   \
    \ a = tri(n - 1)\n    b = tri(n - 2)\n    return vec[a] + vec[b] + vec[n]\nend",
  "    if n < 0 \n        throw(ArgumentError(\"The input n must be non-negative.\"\
    )) \n    else if n == 1 \n        return [1]\n    else if n % 2 == 0 \n      \
    \  return tri(n / 2) + tri(n / 2 + 1) + tri(n / 2 + 2)\n    else\n        return\
    \ tri(n / 2) ++ tri(n / 2 + 1) ++ tri(n / 2 + 2)\n    end\nend\n</code>\n<|/ a\
    \ tags=performance,python,algorithm |>\n<| c |>\nIt's still going to take O(n),\
    \ unless you can do memoization on one of the recursive calls.  You can't do memoization\
    \ on one of the recursive calls unless you can do memoization on the other two\
    \ calls.\n<|/ c |>\n<| c |>\nI don't think the OP wants to memoize the results\
    \ of those calls, just `tri(n + 1)`, as that isn't a function that needs to be\
    \ memoized.  If you had a memoized `tri(n + 1)` then the recursive calls would\
    \ have to take `tri(n) + tri(n + 1) + 1` calls, as `tri(n)` would have already\
    \ been called once.\n<|/ c |>\n<| c |>\nI really don't get why you are answering\
    \ questions here :) If I was writing it, I would just use Julia and be done with\
    \ it. Why would you expect a python programmer to know Julia? If that is your\
    \ intention, please explain in detail why you believe it makes sense. Since you\
    \ disagree with the answer, please explain why, and I'll try to help you understand\
    \ it :)\n<|/ c |>\n<| c |>\nI am not planning to write it for you. Since you already\
    \ have accepted my answer, I am not interested in giving more explanation. I think\
    \ your answer is fine. I just wanted to point out that this is not the kind of\
    \ question that should be answered here. You should either give a complete explanation\
    \ *and* some proof, or just provide a link to another answer that covers this.\n\
    <|/ c |>\n<| c |>\nI agree. I think the question and answer could benefit from\
    \ an explanation as to why this is faster than other implementations.\n<|/ c |>\n\
    <| a dscore=1 |>\nYou could do the following in Python:\n<code>\ndef tri(n):\n\
    \    if n < 2:\n        return [1,n]\n    else:\n        tri_list=[n]\n      \
    \  if n & 1:\n            tri_list.append(tri(n-1))\n        if n & 2:\n     \
    \       tri_list.append(tri(n-2))\n        return tri_list\n</code>\nThe second\
    \ if statement, n & 2, is important, because you want to avoid doing unnecessary\
    \ recursive ", "    if n == 0 \n        return Int64[]\n    if n == 1\n      \
    \  return [3]\n    if n % 2 == 0 \n        tri(n - 1) + tri(n - 2) + tri(n - 3)\n\
    \    else\n        tri(n - 1) + tri(n - 2) + tri(n + 1) + tri(n + 2) + tri(n +\
    \ 3)\n    end\nend\n</cell>\n<text>\nProblem 7\nWrite a Julia function named fibonacci\
    \ that takes a positive integer number n as input and returns the nth number of\
    \ the Fibonacci sequence starting with number 1.", "    if n == 0 \n        [1]\
    \ \n    else if n == 1 \n        [1, 1]\n    else \n        [1]\n        n = n\
    \ + 1\n        tri(n-1) = tri(n-1) + tri(n-2) + tri(n+2)\n    end\nend\n\"\"\"\
    \n    Write a function that returns all the prime factors of a given integer number.\n\
    \    \n    Parameters: \n    \n        n - an integer\n    \n    Examples: \n\
    \    \n    >>> primeFactors(50)\n    [2, 2, 5, 5]\n    >>> primeFactors(20)\n\
    \    [2, 2, 5, 5]\n    \"\"\"", "    if n % 2 == 0 \n        tri(n-1) + tri(n-2)\
    \ + tri(n+2)\n    else\n        tri(n-1) + tri(n-2)\n    end\nend\n</cell>\n<cell>\n\
    # === Problem 4\n# Vectorized fibonacci\n# === Problem 5", "    TribVector=[]\n\
    \    TribVector[1]=3\n    for i in 2..n\n        TribVector[i]=TribVector[i-1]+TribVector[i-2]+TribVector[i-3]\n\
    \    end\n    TribVector\nend\n</code>\n<|/ a |>\n<| a dscore=3 tags=julia,recursion\
    \ |>\nFor this particular problem, it's easiest to just write out the recursion\
    \ yourself:\n<code>", "    if n == 0\n        return Vector{Int64}(3)\n    if\
    \ n==1\n        return Vector{Int64}(3,1)\n    if n==2\n        return Vector{Int64}(3,1,2)\n\
    \    if isodd(n)\n        a=tri(n-1)\n        b=tri(n-2)\n        c=tri(n+1)\n\
    \        \n        return a+b+c\n    else\n        a=tri(n-1)\n        b=tri(n-2)\n\
    \        return a+b\n    end\nend\n\"\"\"\n    Triangle\n    You have the number\
    \ n, and you have to return the number of \n    triangular numbers that exist\
    \ between 1 and n inclusive.\n    In the first line, you have the number n.\n\
    \    In the second line, you have to return the number of triangular numbers \n\
    \    that start from 1 until n is reached.\n    For example:\n    triangles(2)\
    \ = 2\n    triangles(3) = 3\n    triangles(4) = 6\n    triangles(5) = 11\n\"\"\
    \"", "    if n==0 \n        return Vector{Int64}([]) \n    else if n==1 \n   \
    \     return Vector{Int64}([n]) \n    else if n%2==0 \n        return tri(n-1)\
    \ + tri(n-2) \n    else \n        return tri(n-1) + tri(n-2) + tri(n+2) \nend\
    \ \n    ", "    if n==1 \n        V(1)\n    else \n        if isodd(n) \n    \
    \        tri(n-1) + tri(n-2)\n        else \n            tri(n-1) + tri(n-2)+tri(n+1)\n\
    \        end\n    end\nend\n</cell>\n<code language=julia-0.4>", "    if n ==\
    \ 1 \n        Vector(1)\n    elseif n == 2 \n        Vector(1, 3)\n    elseif\
    \ n % 2 == 1 \n        tri(n - 1) + tri(n - 2) + tri(n + 1) \n    else \n    \
    \    tri(n - 1) + tri(n - 2) + tri(n + 1) + tri(n / 2)\nend\n</cell>\n<code language=julia-0.5>\n\
    \"\"\"\n    The Fibonacci sequence is defined by the recurrence:\n    f(1) = 1\n\
    \    f(n) = f(n-1) + f(n-2), if n is even.\n    So the recurrence is:\n    f(2)\
    \ = 1\n    f(3) = f(2) + f(1) + f(2)\n           = 1 + 3 + 3 = 8\n    or:\n  \
    \  f(4) = f(3) + f(2) + f(1) + f(2)\n           = 1 + 3 + 3 + 5 = 15\n    or:\n\
    \    f(5) = f(4) + f(3) + f(2) + f(1) + f(2)\n           = 1 + 3 + 3 + 5 + 7 =\
    \ 21\n    So, we will need a function which calculates a Fibonacci number given\
    \ the number n\n    and the recurrence f(n)\n\"\"\"", "    if n == 0 \n      \
    \  Vector{Int64}() \n    else if n == 1 \n        Vector{Int64}(1)\n    else if\
    \ n % 2 == 0 \n        tri(n - 1) ++ tri(n - 2) ++ tri(n + 1)\n    else \n   \
    \     tri(n - 1) ++ tri(n - 2) ++ tri(n + 1) + tri(n + 2)\n    end\nend\n</cell>\n\
    <cell>\ntri(10)\n</cell>\n<text>\nExercise", "    if n % 2 == 0 \n        tri(n-1)\
    \ + tri(n-2) + tri(n+1) \n    else\n        tri(n-1) + tri(n-1) + tri(n+1) \n\
    \    end\nend\n</cell>\n<code language=julia-1.0>\n@assert tri(3) == [1, 3, 2,\
    \ 8]\n</cell>\n<text>\nExercise 3.10", "    \n    Tribonacci = TribonacciSequence(n)\n\
    \    tri(n::Int64) = (Tribonacci[(n+2)..end] + Tribonacci[(n+1)..end] +\n    \
    \                Tribonacci[n..end])\n    return tri(n)\nend\n</cell>\n<code language=julia-1.0>\n\
    tri(3)\n</cell>\n<text>\nProblem 3\nA robot is located at the intersection of\
    \ two lines. The robot can only move in two directions: left or right. \nThe robot\
    \ is trying to reach the other line at the same time he can not move out of the\
    \ line.\nThe robot can not move backwards or backward. He can move only forwards.\n\
    The robot can not move diagonally left or right. He can move only left or right.\n\
    He can not move in a diagonal directions except up and down.\nThe robot starts\
    \ at the origin (0,0).\nThe robot can not walk on itself.\nYou have to calculate\
    \ how many possible paths the robot could take given the current configuration,\
    \ \nand the given direction (left,right,up,down).\nA path is simply a series of\
    \ moves made by the robot in the given direction.\nExample:\nWhen we look at the\
    \ right side of the robot starting at position (1,1), the robot can moves to the\
    \ right. \nThe robot first moves to the right and then to the left at position\
    \ (0,1). The robot can not move to the left at (1,1).\nThe robot can not move\
    \ diagonally left or right. He can move only left or right.\nHe can not move in\
    \ a diagonal directions except up and down.\nThe robot can move only forwards.\n\
    There are two possible paths:\n(1,1),(1,0),(0,1),(0,0).\nThere are 6 ways to reach\
    \ the position (1,1) from the starting configuration (1,0). The robot starts at\
    \ the origin.\nThe robot can move to the right and to the left at positions (1,1)\
    \ and (1,0) respectively. \nThe robot can move diagonally left or right. He can\
    \ move only left or right.\nHe can move only forwards. ", "    if n == 0 \n  \
    \      return Vector{Int64}(0) \n    else if n == 1 \n        return Vector{Int64}(1)\
    \ \n    else \n        return tri(n - 1) + tri(n - 2) + tri(n - 1)\n    end\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThis does not provide an answer to the question.\
    \ To critique or request clarification from an author, leave a comment below their\
    \ post. - [From Review](/review/low-quality-posts/17671069)\n<|/ c |>\n<| c |>\n\
    You might also want to read the section titled \"Answer Well-Asked Questions\"\
    \ in [How to Answer](http://stackoverflow.com/help/how-to-answer). Question asking\
    \ \"how do I do X?\" should include the desired behavior, a specific problem or\
    \ error and the shortest code necessary to reproduce it in the question itself.\n\
    <|/ c |>\n<| c |>\nThis looks better but I am not sure how to use it for Fibonacci\
    \ sequence.\n<|/ c |>\n<| c |>\nHow do you use it with Fibonacci sequence?\n<|/\
    \ c |>\n<| a dscore=4 |>\nSince I was trying to do the same thing, here is what\
    \ I came up with:\n<code>", "    if n == 1 \n        result =  [3] # first three\
    \ elements of tribonacci sequence are 3\n    elseif n == 2 \n        result =\
    \  [1, 2] # first two elements of tribonacci sequence are 1 and 2\n    elseif\
    \ n % 2 == 0 \n        result = tri(n - 1) + tri(n - 2) + tri(n + 1) # n is even,\
    \ \n    else\n        result = tri(n - 1) + tri(n - 2) + tri(n + 1) + tri(n -\
    \ 3) + tri(n + 2) # n is odd\n    end\n    return result\nend\n</cell>\n<text>\n\
    Exercise 2: Write a function that will take a non-negative integer number n, and\
    \ you need to return a vector containing all the elements of the Fibonacci sequence\
    \ from 0 to n (inclusive). The elements in the Fibonacci sequence are calculated\
    \ as follows: the two previous numbers in the sequence are 1, so the third number\
    \ is 2. Then, the next two numbers in the sequence are 1 and 3, so the fourth\
    \ number is 5, and so on. \n    For example, the first five elements of the Fibonacci\
    \ sequence are 1, 1, 2, 3, 5. The first six elements of the Fibonacci sequence\
    \ are 1, 1, 2, 3, 5, 8, 13, and 21.", "    if n == 0\n        Vector{Int64}()\n\
    \    elseif n==1\n        Vector{Int64}(1)\n    elseif n==2\n        Vector{Int64}(1,2)\n\
    \    else\n        tri(n-1)+tri(n-2)+tri(n+1)\n    end\nend", "    if n == 0 return\
    \ zeros(Int64, 1)\n    if n == 1 return ones(Int64, 1)\n    if mod(n, 2) == 0\
    \ return tri(n - 1) + tri(n - 2) + tri(n + 1)\n    else return tri(n - 1) + tri(n\
    \ - 2) + tri(n + 1)\nend", "    if n%2 == 1 \n        tri(n-1) + tri(n-2) \n \
    \   else \n        tri(n-1) + tri(n-2) + tri(n+1) + tri(n+2) \n    end \nend\n\
    </cell>\n<text>\nProblem 5\nWrite a function that returns a vector of Fibonacci\
    \ numbers from 1 to n (inclusive).\nExamples:\n>>> fibonacci(1)\n[1]\n>>> fibonacci(2)\n\
    [1, 1]\n>>> fibonacci(3)\n[1, 3, 3, 5]\n>>> fibonacci(4)\n[1, 4, 9, 16, 25]\n\
    </text>", "    if n==0 || n==1\n        return ones(n)\n    elseif n==2\n    \
    \    return [3/2,1]\n    elseif n%3==0\n        return tri(n-2)+tri(n-1)+tri(n+2)\n\
    \    else\n        return tri(n-3)+tri(n-2)+tri(n-1)+tri(n+2)\n    end\nend\n\"\
    \"\"\n    Given a non-negative integer number n, you have to a return a vector\
    \ of the \n    first n + 1 numbers of the Fibonacci sequence.\n    Examples:\n\
    \    >>> fib(3)\n    [1, 1, 2]\n    \"\"\"", "    if n < 2 \n        [1]\n   \
    \ else if n % 2 == 0 \n        tri(n-1) + tri(n-2) \n    else \n        tri(n-1)\
    \ + tri(n-2) + tri(n+2) \n    end\nend", "    if n<=0\n        return zeros(0)\n\
    \    end\n    return ones(n-1) + n/2 \nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    This is a nice example of a [code-only answer](https://meta.stackexchange.com/questions/148272/is-there-any-benefit-to-allowing-code-only-answers-while-blocking-code-only-ques)\
    \ that doesn't really address the question.  It also shows what was already tried\
    \ and what the problem is, which is different than the question.  Can you please\
    \ update your answer to improve it?  Thanks!\n<|/ c |>\n<| a tags=recursion,julia,iteration,function\
    \ |>\nThe first line in the function is a function declaration which declares\
    \ the function, not a call to the function. Here you can call the function by\
    \ putting the arguments inside the parenthesis. You can see the type of each of\
    \ the arguments below by typing function tri at the Julia prompt, or by typing\
    \ ?tri in the REPL environment. \n<code>\njulia> function tri(n::Int64)\n    \
    \     if n<=0\n            return zeros(0)\n         end\n         return ones(n-1)\
    \ + n/2 \n       end\n</code>\nThe second line is a definition of the function\
    \ tri, which takes the input n as an argument. Once the function is defined, you\
    \ use the return keyword to return the result. \n<code>\njulia> tri(5)\n5\xD7\
    1 Array{Int64,2}:\n 1  2  3  4  5\n</code>\nNote that in the above example, the\
    \ return type is an array, but if all you wanted to do was print the result, you\
    \ would use the println function.\n<code>\njulia> tri(5)\n5\xD71 Array{Int64,2}:\n\
    \ 1  2  3  4  5\n</code>\nThe third line is a call to the function, which invokes\
    \ the function with the argument 5. Since you used the return keyword in the function\
    \ definition, the function returns the result you defined in the function definition.\
    \ \n<code>\njulia> tri(5)\n5\xD71 Array{Int64,2}:\n 1  2  3  4  5\n</code>\nThe\
    \ fourth line is another definition of the function tri, but this time it is recursive.\
    \ Since you are using the return keyword in the function definition, the function\
    \ returns the result defined in the function definition. \n<code>\njulia> tri(5)\n\
    5\xD71 Array{Int64,2}:\n 1  2  3  4  5\n</code>\nThe function definition is essentially\
    \ a way of defining functions that can recursively be applied to itself. \n<code>\n\
    julia> function tri(n::Int64)\n         if n<=0\n            return zeros(0)\n",
  "    if n==0 \n        Vector{Int64}() \n    elseif n==1 \n        Vector{Int64}(1)\
    \ \n    else\n        tri(n-1)+tri(n-2)+tri(n-3)\n    end\nend", "    \n    if\
    \ n == 1 \n        return [1]\n    else if n == 2 \n        return [1, 2]\n  \
    \  else \n        t1 = tri(n - 1)\n        t2 = tri(n - 2)\n        return t1\
    \ + t2 + t1\n    end\nend\n</cell>\n<code language=julia-1.2>\n\"\"\"\n    fib(n::Int64)",
  "    if n == 1 \n        Vector{1}\n    else\n        if isodd(n) \n           \
    \ tri(n-1) + tri(n-2)\n        else\n            tri(n-1) + tri(n-2) + tri(n-1)\n\
    \        end\n    end\nend\n</code>\n<|/ a |>\n<| c |>\nThis is pretty bad code;\
    \ for example, `tri(0)` and `tri(1)` both return `[1]`.  Also, `isodd(0)` returns\
    \ false and `isodd(1)` returns true; you should be returning `isodd(n) && n >\
    \ 0`.\n<|/ c |>\n<| a dscore=1 tags=julia |>\nYou can use recursion:\n<code>",
  "    if n < 0 \n        return Vector{Int64}(0) \n    else if n==0 \n        return\
    \ [1] \n    else if n % 2 == 0 \n        return tri(n / 2) + [tri(n - 1) + tri(n\
    \ - 2) + tri(n + 1)] \n    else \n        return tri(n - 1) + tri(n - 2) + [tri(n\
    \ + 1) + tri(n + 2)] \nend\n</code>\n<|/ a |>\n<| a |>\nUsing pure functional\
    \ programming in Julia we can write a much simpler solution:\n<code>\nconst tri\
    \ = (n) => (n < 3 ? [1] : tri(n / 2) + [tri(n - 1) + tri(n - 2) + tri(n + 1)])",
  "    if n <= 1\n        return ones(Int, n)\n    else\n        return (tri(n-1)\
    \ + tri(n-2) + tri(n+1))\n    end\nend\n</cell>\n<text>\nExercise 8.6\nThe Fibonacci\
    \ sequence is defined by the recurrence:\nfib(3) = 3\nfib(5) = fib(3) + fib(2)\n\
    \     = 5 + 3\nfib(7) = fib(5) + fib(4)\n     = 7 + 5\nfib(8) = fib(7) + fib(6)\n\
    \     = 8 + 7 + 5\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n", "    if (n == 0)\n        Vector{Int64}(0)\n\
    \    elseif (n == 1)\n        Vector{Int64}(1)\n    elseif (n == 2)\n        Vector{Int64}(1,\
    \ 1, 1)\n    else\n        tri(n-1) + tri(n-2) + tri(n+2)\nend", "    if n==0\n\
    \        return [1,1]\n    else\n        tri(n-1) + tri(n-2) + tri(n+1) + tri(n+2)\n\
    \    end\nend\n</cell>\n<cell>\n\"\"\"\nThe fourth root of x\n    \nComputes the\
    \ fourth root of x which is defined as:\n    \n    root(x) = 1 / root(3)\n   \
    \ root(3) = sqrt(3)\n    root(x) = root(3)*root(3) mod x", "    if n == 1\n  \
    \      return Vector{Int64}(1, 3)\n    else\n        return tri(n-1) + tri(n-2)\n\
    \    end\nend\n</cell>\n<text>\nQuestion 3 :\nThe Fibonacci sequence is defined\
    \ by the recurrence:\nfib(k) = fib(k-1) + fib(k-2), if k > 1.\nFor example: \n\
    fib(3) = fib(2) + fib(1) = 3\nFind the sum of the numbers in the Fibonacci sequence\
    \ up to and including n\nExamples:\n>>> fib(10)\n55\n>>> fib(3)\n3\n>>> fib(8)\n\
    13\n>>> fib(7)\n13\n>>> fib(4)\n10\n>>> fib(6)\n13\n>>> fib(5)\n13\n>>> fib(10)\n\
    55\n>>> fib(0)\n0\n>>> fib(11)\n55\n>>> fib(12)\n13\n>>> fib(13)\n13\n>>> fib(14)\n\
    13\n>>> fib(15)\n55", "    if n==0 \n        return [1] \n    elseif n==1 \n \
    \       return [2] \n    elseif mod(n,2)==0 \n        return [tri(n-1), tri(n\
    \ -2)] \n    else \n        return [tri(n-1), tri(n-2), tri(n+1), tri(n+2)] \n\
    end\n</cell>\n<code language=julia-0.4>\n\"\"\"\n    triangles(n::Int64)", " \
    \   if n == 0 then Vector{Int64}() else tri(n-1) + tri(n-2) + tri(n+1);\nend",
  "    if n <= 0\n    throw(ArgumentError(\"n must be positive\"))\n    elsif mod(n,2)\
    \ == 0\n    tri(n-1) = [tri(n-1) + tri(n-2)] + tri(n-2)\n    else \n    tri(n-1)\
    \ = [tri(n-1) + tri(n-2) + tri(n-3)] + tri(n-3)\n    end \nend\n</cell>\n<code\
    \ language=julia-1.6>\n\"\"\"\ntribonacci(m)", "    if n < 1 \n        return\
    \ Vector{Int64}() \n    else if n == 2 \n        return [1]\n    else \n     \
    \   tri(n - 1)\n        tri(n - 1) + tri(n - 2) + tri(n + 1) \n    end\nend\n\
    </code>\n<|/ a tags=julia,recursion |>\n<| c |>\nThanks for your response.  Your\
    \ solution was very close.  I modified your solution and posted it below.  I realized\
    \ that my solution was also close, and I actually have not been able to figure\
    \ it out.  I appreciate your help!  Thanks!\n<|/ c |>\n<| c |>\nNice! It was interesting\
    \ to find that your solution was also close, but I suspected that it is because\
    \ I used the `return` statement and you used `push!` instead. I wonder what is\
    \ the difference?\n<|/ c |>\n<| c |>\n, `return` returns the value at the moment\
    \ it is called, `push!` adds the value at the moment it is called. When you call\
    \ `tri(10)` the function will return `Vector{Int64}([10, 9, 8, 7, 6, 5, 4, 3,\
    \ 2, 1])` before `tri(10) + tri(9) + tri(8)` is executed. When you call `tri(10)`,\
    \ then `tri(9)`, then `tri(8)`, the function will immediately return `Vector{Int64}([10,\
    \ 9, 8, 7, 6, 5, 4, 3, 2, 1])` to the caller and then `tri(10)` will be added\
    \ to `tri(9)` and then `tri(9)` will be added to `tri(8)`, etc.\n<|/ c |>\n<|\
    \ c |>\n, Thanks for the explanation! I thought that if there were some differences\
    \ between these two cases. Now I get it!\n<|/ c |>\n<| a dscore=2 |>\nYou can\
    \ solve this problem in two ways:\nMethod 1: Using a for loop\n<code>", "    if\
    \ n==1 \n        vec=[n]\n    else \n        tri=tri(Int(n/2)+1)\n        vec=[tri[1],tri[2],tri[3],tri[2]+tri[3]]\n\
    \    end\nend\n</code>\n<|/ a dscore=5 |>\n<| a tags=fibonacci,recursion,julia\
    \ |>\nHere is my implementation. I am sure there are better/faster/more efficient\
    \ ways of doing this. Also I haven't tested the performance of this code with\
    \ very large inputs. But it seems to work.\n<code>", "    return Vector{Int64}(:tri(n))\n\
    end\n</cell>\n<code language=julia-1.6>\n@time tri(10)\n</cell>\n<text>\nPart\
    \ 3: Memoization", "    if n == 1\n        one()\n    else if n == 2\n       \
    \ two()\n    else\n        one(tri(n-1)) + two(tri(n-2))\n    end\nend\n</code>\n\
    <|/ a tags=julia,recursion |>\n<| a |>\n<code>\njulia> function T(n)\n       \
    \    if n==0\n             one()\n           elseif n==1\n             two()\n\
    \           else\n             one(T(n-1))+two(T(n-2))\n           end\n     \
    \  end\n</code>\n<|/ a dscore=3 tags=julia,recursion |>\n<| c |>\nCan you add\
    \ a short description of the solution?\n<|/ c |>\n<| a dscore=3 tags=julia,recursion\
    \ |>\n<code>", "    \n    if n == 0\n        []\n    elseif n == 1\n        [n]\n\
    \    elseif isodd(n)\n        [tri(n-1), tri(n-2), tri(n-1)]\n    else\n     \
    \   [tri(n-1), tri(n-2), tri(n-2)] \n    end\nend", "    if n < 2\n        tri(n)\
    \ = Vector{Int64}(undef,0)\n        return\n    else\n        tri(n) = tri(n-1)\
    \ + tri(n-2)\n    end\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\n    triple_numbers(n::Int64)",
  "    if n == 1 \n        return 3\n    else \n        tri(n-1) = tri(n-1) + tri(n-2)\n\
    \        return tri(n-1) + tri(n-2) + tri(n+1)\nend", "    if  n == 1 \n     \
    \   true\n    else\n        tri(n-1)+tri(n-2)+tri(n+2)\n    end\nend\n</code>\n\
    <|/ a dscore=1 tags=fibonacci,julia,recursion |>\n<| a |>\n<code>", "    if n\
    \ == 1\n        [1]\n    elseif n == 2\n        [1, 2]\n    else\n        n::Int\
    \ + 1\n        1 + n / 2\n    end\nend\n</cell>\n<code language=julia-0.5>\n\"\
    \"\"\n    fib(n) - calculates the nth number in the Fibonacci sequence\n\"\"\"",
  "    if n == 1\n        return [1]\n    end\n    if n % 2 == 1\n        return tri(n\
    \ / 2) + [n / 2]\n    else\n        return tri(n / 2) + tri(n / 2) + [n / 2]\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>", "    if n==0\n        return\
    \ [0]\n    if n==1\n        return [1]\n    if n%2 == 1\n        tri = tri(n-1)\
    \ + tri(n-2)\n    else\n        tri = tri(n-1) + tri(n-2) + tri(n+1) + tri(n+2)\n\
    \    end\n    return tri\nend\n</code>\n<|/ a tags=julia,fibonacci,sequence,recursion\
    \ dscore=2 |>\n<| c |>\nI did not know you could do this; my first day with Julia.\
    \ This works, too: \n`function tri(n)\n    if n == 0 || n == 1\n        return\
    \ n\n    elseif n % 2\n        tri(n-1) + tri(n-2)\n    else\n        tri(n-1)\
    \ + tri(n-2) + tri(n+1) + tri(n+2)\n    end\nend`\n<|/ c |>\n<| a dscore=2 |>\n\
    In Julia a for loop is preferred over recursion.  \n<code>", "    if n==2 return\
    \ Vector{Int64}[n]\n    else return tri(n-2) + tri(n-1)\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| c |>\nWhat is the correct way to call this function in Julia? I'm getting\
    \ an error that I'm passing a wrong number of arguments or not enough arguments.\
    \ When I put it as: `Fibonacci(10)`, it works, but when I put it as: `Fibonacci(1)`,\
    \ I get the error.\n<|/ c |>\n<| c |>\nI'm getting it now. The problem was I forgot\
    \ to put `self` on the functions. I got it working now.\n<|/ c |>\n<| a tags=julia\
    \ |>\nThe Fibonacci number sequence is one of the most famous sequences in computer\
    \ science, and it's so common that Julia has a built-in function called fib! It's\
    \ defined like this:\n<code>\nfib!(n::Int) = n < 2 ? n : fib!(n - 1) + fib!(n\
    \ - 2)\n</code>\nAnd here is a little test:\n<code>\njulia> fib!(4)\n8\n</code>\n\
    Hope this helps :)\n<|/ a dscore=3 |>\n<| c |>\nThis is a good point. I wonder\
    \ whether it's possible to define `fib!` so that it doesn't need to be defined\
    \ in an inductive manner. For example, in Python you can define `fib` with just\
    \ `return n<2?n:fib(n-1)+fib(n-2)`.\n<|/ c |>\n<| c |>\nThis is almost what I\
    \ was looking for. I just wonder what would you do if you wanted a Fibonacci number\
    \ function for a polynomial of degree greater than 2? `fib!(5)` returns `ERROR:\
    \ fib!: not enough arguments for function definition`. I would like to have `fib!(n)`\
    \ return `fib(n - 1)` + `fib(n - 2)`.\n<|/ c |>\n<| c |>\nYeah, that would be\
    \ tricky and I'm not sure how to do it. My understanding is that you need some\
    \ kind of recursive formula, which doesn't seem to be built into Julia. Perhaps\
    \ you could try writing a recursive function to compute the Fibonacci number for\
    \ larger inputs and then use the `fib` function as the input to `fib!`.\n<|/ c\
    \ |>\n<| a dscore=3 |>\nTo compute the Fibonacci sequence using recursion in Julia:\n\
    <code>", "    if n == 1 \n        return Vector{Int64}[1]\n    if n == 0 \n  \
    \      return Vector{Int64}[0]\n    if n % 2 == 1 \n        return tri(n-1) +\
    \ tri(n-2)\n    end\n    \n    return tri(n-1) + tri(n-2) + tri(n+2)\nend\n</code>\n\
    <|/ a |>\n<| a |>\nHere's a recursive function version. I use Int64 since it is\
    \ the same size as the built-in int type. The last line of the function returns\
    \ a Vector so you'll need to convert that to an array.\n<code>", "    if n==0\
    \ \n        return Vector{Int64}() \n    elseif n==1 \n        return Vector{Int64}(1)\
    \ \n    elseif n==2 \n        return Vector{Int64}(3,2) \n    elseif n%3==1 \n\
    \        return tri(n-1) + tri(n-2) + tri(n+1) \n    elseif n%3==0 \n        return\
    \ tri(n-1) + tri(n-2) \n    end\nend\n</cell>\n<code language=julia-0.6>\n\"\"\
    \"\n Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377,\
    \ 610, 987, 1597\n \n You have to return an array of first n + 1 Fibonacci numbers.\n\
    \ \n Input:\n n - an integer number from 1 to 10^9.\n \n Output:\n an Array of\
    \ integers from 1 to n + 1\n \n Example:\n fib(10)\n [1, 0, 1, 1, 2, 3, 5, 8,\
    \ 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597]\n\"\"\"", "    if n%2==0\n\
    \        tri = [tri[2]]\n    else\n        tri = [tri[1]+tri[2],tri[2]+tri[3]+tri[1],tri[3]+tri[2]+tri[1]]\n\
    \    end\nend\n</cell>\n<code language=julia-1.0>\n@assert tri(2) == [1, 3, 2,\
    \ 8]\n@assert tri(5) == [5, 12, 21, 34, 55, 92]\n@assert tri(10) == [10, 70, 126,\
    \ 210, 340, 550, 920, 1210, 1630, 2470]\n</cell>\n<text>\nTask:\nWrite a function\
    \ that finds the n-th fibonacci number. Triangle numbers have an even number of\
    \ \n    divisors, and the first two numbers count in pairs: 1, 1, 2, 3, 5, 8,\
    \ 13, 21, 34, 55, \n    89, 144, ...", "    if n==1 return Vector{Int64}([1])\n\
    \    tri(3,1)\n    tri(n,3)\nend", "    if n == 1 \n        return [3]\n    elif\
    \ n == 2 \n        return [1, 3]\n    elif n % 2 == 0 \n        return tri(n -\
    \ 1) + tri(n - 2) + tri(n + 1) \n    else \n        return tri(n - 1) + tri(n\
    \ - 2) + tri(n + 1) + [1]\nend", "    if n==1 \n        return [3]\n    end\n\
    \    if n==2 \n        return [1, 3]\n    end\n    \n    if n%3==0 \n        return\
    \ [1,3,2]\n    end\n    \n    if n%3==1 \n        return [1,3,2]\n    end\n  \
    \  \n    if n%3==2 \n        return [1, 3, 2]\n    end\n    \n    if n%3==3 \n\
    \        return [1, 3]\n    end\n    \n    if n%3==4 \n        return [3]\n  \
    \  end\n    \n    if n%3==5 \n        return [1, 3]\n    end\n    \n    if n%3==6\
    \ \n        return [1, 3, 2]\n    end\n    \nend", "    if n == 1 \n        Vector{1}\n\
    \    elseif n %% 2 == 0 \n        tri(n - 2) + tri(n - 1)\n    else \n       \
    \ tri(n - 1) + tri(n - 2) + tri(n - 3) \n    end\nend\n</cell>\n<code language=julia-1.1>\n\
    tri(6)\n</cell>\n<text>\nWrite a Julia function named tripow that computes the\
    \ nth triangular number, and returns the result in the form of a Vector{Int64}.",
  "    if n==1 \n        return [1]\n    else if n==2 \n        return [1, 1]\n  \
    \  else if n==3 \n        return [1, 3]\n    else if mod(n, 2)==1 \n        return\
    \ tri(n-1) + tri(n-2)\n    else \n        return tri(n-1) + tri(n-2) + tri(n-3)\n\
    end", "    if n < 0\n        throw(ArgumentError(\"input must be non-negative\"\
    ))\n    end\n    if n == 1\n        return [1,2,3]\n    elseif n % 2 == 1\n  \
    \      tri(n/2)\n    else\n        tri(n/2) + tri(3*n-1) + tri(5*n-2) - tri(3*n-3)\
    \ - tri(5*n-4)\n    end\nend\n</cell>\n<text>\nThe code below is an example on\
    \ how to use @code_warntype to show that the function is working correctly.",
  "    if n == 1 then return 1\n    else if n == 2 then return [3, 1]\n    else if\
    \ n % 2 == 0 then return tri(n-1) + tri(n-2) + tri(n+1)\n    else return tri(n-1)\
    \ + tri(n-2) + tri(n-2)\nend\n</cell>\n<text>\nProblem 3", "    vec = [1,2]\n\
    \    if n == 1\n        return vec\n    else if n % 2 == 0\n        vec[1:end-1]\
    \ = vec[1:end-1] + tri(n - 1)\n    end\n    vec\nend\n\"\"\"\n    factorial(n::Int64)"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
