name: HumanEval_136_largest_smallest_integers
language: jl
prompt: "\"\"\"\n    Create a function that returns a tuple (a, b), where 'a' is\n\
  \    the largest of negative integers, and 'b' is the smallest\n    of positive\
  \ integers in a vector.\n    If there is no negative or positive integers, return\
  \ them as nothing.\n\n    Examples:\n    >>> largest_smallest_integers([2, 4, 1,\
  \ 3, 5, 7])\n    (nothing, 1)\n    >>> largest_smallest_integers([])\n    (nothing,\
  \ nothing)\n    >>> largest_smallest_integers([0])\n    (nothing, nothing)\n   \
  \ \"\"\"\nfunction largest_smallest_integers(lst::Vector{Int64})::Tuple{Union{Int64,\
  \ Nothing}, Union{Int64, Nothing}} \n"
tests: "using Test\n\n@testset begin\n\ncandidate = largest_smallest_integers;\n\t\
  @test(candidate([2, 4, 1, 3, 5, 7]) == (nothing, 1))\n\t@test(candidate([2, 4, 1,\
  \ 3, 5, 7, 0]) == (nothing, 1))\n\t@test(candidate([1, 3, 2, 4, 5, 6, -2]) == (-2,\
  \ 1))\n\t@test(candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2))\n\t@test(candidate([7,\
  \ 3, 8, 4, 9, 2, 5, -9]) == (-9, 2))\n\t@test(candidate(Vector{Int64}([])) == (nothing,\
  \ nothing))\n\t@test(candidate([0]) == (nothing, nothing))\n\t@test(candidate([-1,\
  \ -3, -5, -6]) == (-1, nothing))\n\t@test(candidate([-1, -3, -5, -6, 0]) == (-1,\
  \ nothing))\n\t@test(candidate([-6, -4, -4, -3, 1]) == (-3, 1))\n\t@test(candidate([-6,\
  \ -4, -4, -3, -100, 1]) == (-3, 1))\nend\n"
completions: ["    if all(isnothing(Int64(i)) for i in lst)\n        return nothing,\
    \ nothing\n    return max(Int64(lst)), min(Int64(lst))\nend\n</cell>\n<text>\n\
    Returning tuples\nJulia has a useful set of functions that return tuples.  For\
    \ example, one such function is zip.  It takes a vector and returns a new vector\
    \ containing tuples corresponding to elements in the original vector with the\
    \ same index.", "    if length(lst) == 0 || all(isnothing(lst))\n        return\
    \ nothing, nothing\n    else\n        idx = length(lst)\n        while idx > 2\n\
    \            if lst[idx - 1] < lst[idx] - 1\n                idx = 3\n       \
    \     elseif lst[idx - 2] < lst[idx - 1] - 1\n                idx = 2\n      \
    \      else\n                idx = 1\n            end\n        end\n        return\
    \ lst[idx - 2], lst[idx - 1]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @test largest_smallest_integers([2, 3, 5, 7, 9] == (3, 7))\n@test largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7] == (1, 4))\n@test largest_smallest_integers([1, 2, 3] == nothing)\n\
    @test largest_smallest_integers([1, 2, 3, 0] == nothing)\n@test largest_smallest_integers([1,\
    \ 2, 3] == nothing)\n@test largest_smallest_integers([1, 2, 3, 0] == nothing)\n\
    @test largest_smallest_integers([1, 2, 3, 0] == nothing)\n@test largest_smallest_integers([1,\
    \ 3, 5] == nothing)\n@test largest_smallest_integers([2, 3, 4, 56, 789] == (2,\
    \ 5))\n@test largest_smallest_integers([3, 2, 1] == nothing)\n@test largest_smallest_integers([3,\
    \ 2, 1, 1, 1] == nothing)\n@test largest_smallest_integers([1, 1, 1, 2, 3, 4]\
    \ == nothing)\n</cell>\n<text>\nThe median\nThe median is the value separating\
    \ the higher half of a set of numbers from the lower half. If there are an odd\
    \ number of elements, then it is the average of the two middle values. For example,\
    \ the median of [1,2,3] and [4,5,6] would be 3. If there are an even number of\
    \ elements, then the median would be the average of the two middle values. For\
    \ example, the median of [1,2,3] and [4,5] is 3.5", "    if any((x<0) for x \u2208\
    \ lst)\n        (a, b) = (nothing,nothing)\n    else\n        (a, b) = (findfirst(x<0,\
    \ lst), findfirst(x>=lst, lst))\n    end\n    return (a, b)\nend\n</cell>\n<text>\n\
    largest_integer", "    \"\"\"\n    Create a function that returns a tuple (a,\
    \ b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n\
    \    of positive integers in a vector.\n    If there is no negative or positive\
    \ integers, return them as nothing.", "    # Initialize our results to nothing.\n\
    \    if isempty(lst)\n        return nothing, nothing\n    # Find the largest\
    \ integer.\n    largest = lst[1]\n    # Iterate over everything but the first\
    \ element\n    for i in lst[2:end]\n        # Is the current element bigger than\
    \ the largest?\n        if i > largest\n            # Update the largest element\n\
    \            largest = i\n        # Or are we at the end of the list?\n      \
    \  else\n            # Do nothing\n        end\n    end\n    return (largest,\
    \ nothing)\nend", "    \n    if length(lst) == 0\n        return (nothing, nothing)\n\
    \    end", "    if any(lst==0)\n        return nothing\n    elseif any(lst<0)\n\
    \        return largest_smallest_integers(lst[lst<0]), min(lst[lst<0])\n    else\n\
    \        return largest_smallest_integers(lst[lst>0]), max(lst[lst>0])\n    end\n\
    end", "    if !isnothing(lst)\n        smallest_negative_number = maximum([x for\
    \ x in lst if x < 0])\n        biggest_positive_number = minimum([x for x in lst\
    \ if x > 0])\n        return (smallest_negative_number, biggest_positive_number)\n\
    \    else\n        return (nothing, nothing)\n    end\nend", "    if length(lst)\
    \ <= 0\n        return (nothing, nothing)\n    maximum = minimum(lst)\n    for\
    \ number in lst\n        if number < 0\n            return (nothing, maximum(number))\n\
    \        end\n        if number > maximum\n            return (maximum(number),\
    \ nothing)\n        end\n    end\n    return (maximum, nothing)\nend\n</cell>\n\
    <text>\nThe function largest_smallest_integers takes a vector, and returns the\
    \ largest and smallest numbers as a tuple. For example:", "    largest = nothing\n\
    \    smallest = nothing\n    for i in lst\n        if i < 0\n            if !largest\n\
    \                largest = i\n            elseif largest < i\n               \
    \ largest = nothing\n            end\n        elseif !smallest\n            smallest\
    \ = i\n        elseif smallest > i\n            smallest = nothing\n        end\n\
    \    end\n    return (largest, smallest)\nend\n</cell>\n<code language=julia-1.5>",
  "    largest = -minimum(lst)\n    smallest = maximum(lst)\n    (largest, smallest)\n\
    end\n</cell>\n<text>\nQuestion 4: Given the code cell below, write code to test\
    \ whether a number is even.", "    if length(lst == 0)\n        return (nothing,\
    \ nothing)\n    elseif any(lst==Int64(0), lst == Int64(0))\n        return (nothing,\
    \ nothing)\n    else\n        return maximum((-lst),lst), minimum((-lst), lst)\n\
    \    end\nend", "    if isnothing(lst)\n        return (nothing, nothing)\n  \
    \  elseif length(lst) < 2\n        return (nothing, nothing)\n    else\n     \
    \   sorted = sort(lst)\n        largest = sorted[end-1]\n        smallest = sorted[1]\n\
    \        return (largest, smallest)\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    largest_smallest_integers([2, 4, 1, 3, 5, 7])\n</cell>\n<code language=julia-1.0>\n\
    largest_smallest_integers([])\n</cell>\n<code language=julia-1.0>\nlargest_smallest_integers([0])\n\
    </cell>\n<text>\nFind the largest and smallest numbers in a dictionary where the\
    \ keys are ordered from largest to smallest:", "    if !all(isnothing(lst))\n\
    \        largest = minimum(lst)\n        smallest = maximum(lst)\n        return\
    \ (largest, smallest)\n    else\n        return (nothing, nothing)\n    end\n\
    end\n</cell>\n<text>\nlargest_largest\nThis function returns the largest integer\
    \ in a vector.", "    if length(lst) == 0 \n        (a, nothing)\n    elseif all(x\
    \ < 0 for x in lst) \n        (nothing, a)\n    elseif all(x > 0 for x in lst)\
    \ \n        (nothing, b)\n    else\n        (a, b) = sort(lst)\n        (nothing)\n\
    \    end\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nI thought this might work\
    \ but I was getting errors.  I ended up going with the original answer because\
    \ it didn't require importing any libraries.\n<|/ c |>\n<| c |>\nI added a more\
    \ Julia solution using broadcasting / higher-order functions. I hope it works\
    \ for you!\n<|/ c |>\n<| a |>\nI ran into a similar problem and ended up using\
    \ a combination of map and filter.  map iterates over the vector and creates a\
    \ vector of booleans to indicate the conditional values.  filter is then used\
    \ to eliminate the false entries.\n<code>", "    if !is_sorted!(lst)\n       \
    \ sort(lst)\n    end\n    pos = 0\n    neg = 0\n    for i in lst\n        if i\
    \ <= 0\n            neg += 1\n        elseif i > 0\n            pos += 1\n   \
    \     end\n    end\n    return nothing if(neg == 0 && pos == 0)\n    biggest,\
    \ smallest = pos, neg\n    \n    while biggest > 0 && smallest < 0\n        biggest\
    \ -= 1\n        smallest += 1\n    end\n    return (biggest, smallest) \nend\n\
    </cell>\n<code language=julia-1.5>", "    if length(lst) == 0\n        return\
    \ (nothing, nothing)\n    elseif any(filter(iszero, lst))\n        return (0,\
    \ nothing)\n    elseif any(filter(isinf, lst))\n        return (nothing, 0)\n\
    \    else\n        min_inf = minimum(filter(isinf, lst))\n        max_inf = maximum(filter(isinf,\
    \ lst))\n        min_inf = min_inf != nothing ? min_inf : 0\n        max_inf =\
    \ max_inf != nothing ? max_inf : 0\n        return (max_inf, min_inf)\n    end\n\
    end", "    if length(lst) == 0 \n        return (nothing, nothing) \n    end",
  "    if all(lst.>0) \n        (a, b) = sorted(lst)\n        return (b, a) \n   \
    \ else \n        return (nothing, nothing)\n    end\nend", "    \"\"\"\n    Given\
    \ a list of integers, return the largest and smallest of them.\n    If there are\
    \ no integers in the list, return nothing.", "    \n    if all(isnothing(elem)\
    \ || elem <= 0 for elem in lst) \n        (a, b, c) = (nothing, nothing, nothing)\n\
    \    elseif all(isnothing(elem) || elem >= 0 for elem in lst) \n        (a, b,\
    \ c) = (nothing, nothing, nothing)\n    else\n        (a, b) = min(x for x in\
    \ lst if x > 0), max(x for x in lst if x <= 0)\n        c = nothing\n    end\n\
    \    \n    return (a, b, c)\nend", "    if all(x<0 for x in lst)\n        return\
    \ (nothing,nothing)\n    else\n        (largest = min(lst), smallest = max(lst))\n\
    \        return (largest,smallest)\n    end\nend\n</code>\nThen you can use it\
    \ by calling:\n<code>\nlargest_smallest_integers([2, 4, 1, 3, 5, 7])\n</code>\n\
    This outputs:\n<code>\n(2, 1)\n</code>\nHope this helps!\n<|/ a dscore=2 tags=function,max,julia,arrays\
    \ |>\n<| a |>\nHere's an approach that relies on the fact that maximum and minimum\
    \ only work on scalars:\n<code>", "    if length(lst) == 0\n        return nothing,\
    \ nothing\n    elseif length(lst) == 1\n        if lst[1] >= 0\n            return\
    \ lst[1], nothing\n        else\n            return nothing, lst[1]\n    elseif\
    \ lst[1] <= 0\n        return nothing, nothing\n    else\n        if lst[2] >=\
    \ 0\n            return largest_smallest_integers(lst[2:end]), (lst[1], nothing)\n\
    \        elseif lst[2] <= 0\n            return largest_smallest_integers(lst[1:end-1]),\
    \ (nothing, lst[2])\n        else\n            return largest_smallest_integers(lst[1:end-1]),\
    \ largest_smallest_integers(lst[2:end])\n    end\nend\n</cell>\n<text>\nWrite\
    \ a function called largest_largest_integers(lst) that returns a tuple (a, b),\
    \ where 'a' is the largest of all integers in a vector, and 'b' is the smallest\
    \ of all integers in a vector. If there is no integer in the vector return (nothing,\
    \ nothing).", "    if length(lst) == 0\n        return (nothing, nothing)\n  \
    \  elseif length(lst) == 1\n        return (lst[0], nothing)\n    elseif length(lst)\
    \ == 2\n        return (lst[1], lst[0])\n    end", "    if all(isnothing(i) ||\
    \ i < 0 for i in lst)\n        return ()\n    if all(i < 0 for i in lst)\n   \
    \     return (0, nothing)\n    if all(i >= 0 for i in lst)\n        return (1,\
    \ nothing)\n    # both sides non-empty\n    smallest::Union{Int64, Nothing} =\
    \ nothing\n    largest::Union{Int64, Nothing} = nothing\n    for i in lst\n  \
    \      if i < smallest\n            smallest = i\n        elseif i > largest\n\
    \            largest = i\n        end\n    end\n    return (largest, smallest)\n\
    end\n</cell>\n<text>\nlargest_integer", "    if length(lst) < 2\n        return\
    \ (nothing, nothing)\n    biggest, smallest = nothing\n    for i in lst\n    \
    \    if i < 0\n            if biggest == nothing\n                biggest = i\n\
    \            else\n                smallest = i\n        else\n            if\
    \ smallest == nothing\n                smallest = i\n            else\n      \
    \          biggest = i\n    end\n    if biggest == nothing\n        return (nothing,\
    \ nothing)\n    elseif smallest == nothing\n        return (smallest, biggest)\n\
    \    else\n        return (biggest, smallest)\n    end\nend", "    largest = nothing\n\
    \    smallest = nothing\n    if !lst.empty()\n        largest = maximum(lst.take(end-lst.first))\n\
    \        smallest = minimum(lst.take(start-lst.first))\n    end\n    return largest,\
    \ smallest\nend", "    largest, smallest = nothing\n    \n    for x in lst\n \
    \       if x < 0 && (largest == nothing || x > largest)\n            largest =\
    \ x\n        else if x > 0 && smallest == nothing || x < smallest\n          \
    \  smallest = x\n        end\n    end", "    if isempty(lst)\n        return (nothing,\
    \ nothing)\n    elseif isempty(lst[1])\n        return (nothing,lst[1])\n    elseif\
    \ lst[1] < lst[2]\n        return (nothing,lst[1])\n    else\n        return (lst[1],nothing)\n\
    \    end\nend\n</cell>\n<text>\nPart 3: Solve the problem", "    if lst.size <=\
    \ 0\n    nothing\n    else if lst.size > 0\n        largest = max(lst, key=lambda\
    \ x: (x < 0, x))\n        smallest = min(lst, key=lambda x: (x > 0, x))\n    \
    \    return largest, smallest\n    else\n        nothing\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Random\nRandom.seed!(1234);\n</cell>\n<code language=julia-1.5>\n\
    largest_smallest_integers(randn(1000))\n</cell>\n<code language=julia-1.5>\nlargest_smallest_integers(randn(2))\n\
    </cell>\n<code language=julia-1.5>\nlargest_smallest_integers(randn(1))\n</cell>\n\
    <text>\nSort function", "    if lst==nothing\n        (nothing, nothing)\n   \
    \ else\n        maximum = minimum = nothing\n        maximum = minimum = nothing\n\
    \        for n in lst\n            if n < minimum\n                minimum = n\n\
    \            elseif n > maximum\n                maximum = n\n        end\n  \
    \      (minimum, maximum)\n    end\nend", "    if any(x < 0 for x in lst)\n  \
    \      a, b = sort(lst)\n        return (b, (a > 0 ? a : nothing))\n    end\n\
    \    return nothing\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis approach seems\
    \ to be more efficient than the others mentioned because it is more straightforward\
    \ and doesn't involve a temporary copy of the data.\n<|/ c |>\n<| a dscore=2 |>\n\
    I wrote my own solution that only creates one array of Bool values. As the size\
    \ of the array grows, you only have to fill up half of the array, while the other\
    \ half can be ignored. As soon as you reach the middle of the array and find a\
    \ False value, the other half of the array is filled up with True. \n<code>",
  "    if length(lst) == 0 return (nothing, nothing)\n    largest = Nothing\n    smallest\
    \ = nothing\n    for i in lst\n        if i < 0\n            if largest == nothing\
    \ || (largest != nothing && largest < i)\n                largest = i\n      \
    \      else\n                break\n        else\n            if smallest == nothing\
    \ || (smallest != nothing && smallest > i)\n                smallest = i\n   \
    \         else\n                break\n    end\n    (largest, smallest)\nend\n\
    </code>\n<|/ a tags=julia,max |>\n<| a tags=julia,max |>\nThe other answers all\
    \ show how to implement a function that returns \"the largest integer in the list\"\
    , but none show how to implement the function that returns the smallest integer\
    \ in the list, or how to implement it efficiently (O(1) time).\nA simple way to\
    \ do that is to reverse the list, and find the minimum in the original order:\n\
    <code>\njulia> function smallest_in_list(lst::Vector{Int64})::Int64\n        \
    \   return min(reverse(lst, true))\n       end", "    if length(lst) == 0\n  \
    \      (a, b) = (nothing, nothing)\n    elseif min(lst) < 0\n        (a, b) =\
    \ (minimum(lst), nothing)\n    else\n        (a, b) = (maximum(lst), minimum(lst))\n\
    \    end\n    return (a, b)\nend", "    \n    largest = nothing\n    smallest\
    \ = nothing\n    \n    largest = nothing\n    smallest = nothing\n    \n    largest\
    \ = nothing\n    smallest = nothing\n    \n    largest = nothing\n    smallest\
    \ = nothing\n    \n    largest = nothing\n    smallest = nothing\n    \n    largest\
    \ = nothing\n    smallest = nothing\n    \n    largest = nothing\n    smallest\
    \ = nothing\n    \n    largest = nothing\n    smallest = nothing\n    \n    largest\
    \ = nothing\n    smallest = nothing\n    \n    largest = nothing\n    smallest\
    \ = nothing\n    \n    largest = nothing\n    smallest = nothing\n    \n    largest\
    \ = nothing\n    smallest = nothing\n    \n    largest = nothing\n    smallest\
    \ = nothing\n    \n    largest = nothing\n    smallest = nothing\n    \n    largest\
    \ = nothing\n    smallest = nothing\n    \n    largest = nothing\n    smallest\
    \ = nothing\n    \n    largest = nothing\n    smallest = nothing\n    \n    largest\
    \ = nothing\n    smallest = nothing\n    \n    largest = nothing\n    smallest\
    \ = nothing\n    \n    largest = nothing\n    smallest = nothing\n    \n    largest\
    \ = nothing\n    smallest = nothing\n    \n    largest = nothing\n    smallest\
    \ = nothing\n    \n    largest = nothing\n    smallest = nothing\n    \n    largest\
    \ = nothing\n    smallest = nothing\n    \n    largest = nothing\n    smallest\
    \ = nothing\n    \n    largest = nothing\n    smallest = nothing\n    \n    largest\
    \ = nothing\n    smallest = nothing\n    \n    largest = nothing\n    smallest\
    \ = nothing\n    \n    largest = nothing\n    smallest = nothing\n    \n    largest\
    \ = nothing\n    smallest = nothing\n    \n    largest = nothing\n    smallest\
    \ = nothing\n    \n    largest = nothing\n    smallest = nothing\n    \n    largest\
    \ = nothing\n    smallest = nothing\n    \n    largest = nothing\n    smallest\
    \ = nothing\n    \n    largest = nothing\n    smallest = nothing\n    \n    largest\
    \ = nothing\n    smallest = nothing\n    \n    largest = nothing\n    smallest\
    \ = nothing\n    \n    largest = nothing\n    smallest = nothing\n    \n    largest\
    \ = nothing\n    smallest = nothing\n    \n    largest", "    if length(lst) ==\
    \ 0 \n        return nothing, nothing\n    elseif length(lst) == 1\n        return\
    \ (1, lst[0])\n    elseif any(v < 0 for v in lst)\n        largest_smallest_integers.(lst[findfirst(v\
    \ < 0)+1:end])\n    elseif any(v > 0 for v in lst)\n        largest_smallest_integers.(lst[1:findfirst(v\
    \ > 0)])\n    else\n        largest_smallest_integers.(lst)\n    end\nend", " \
    \   if isnothing(lst)\n        return (nothing, nothing)\n    elseif all(lst <\
    \ 0)\n        return (nothing, nothing)\n    elseif all(lst > 0)\n        return\
    \ (lst.min(), lst.max())\n    else\n        error(\"This function doesn't accept\
    \ negative or positive integers.\")\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (1, 7)\n@assert largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7, 9, 10, 12]) == (1, 12)\n@assert largest_smallest_integers([1,\
    \ 3, 5]) == (nothing, nothing)\n@assert largest_smallest_integers([nothing, nothing])\
    \ == (nothing, nothing)\n</cell>\n<text>\nQuestion 6\nWrite a function named largest_smallest_integers.",
  "    (a, b) = Nothing, (nothing)\n    if length(lst) == 0\n        (a, b) = (Nothing,\
    \ nothing)\n    elseif all(x < 0 for x in lst)\n        (a, b) = (Nothing, nothing)\n\
    \    elseif all(x == 0 for x in lst)\n        (a, b) = (Nothing, nothing)\n  \
    \  elseif all(x > 0 for x in lst)\n        (a, b) = (max(lst), min(lst))\n   \
    \ end\n    return a, b\nend", "    if any(lst==nothing)\n        return nothing,\
    \ nothing\n    elseif any(lst==0)\n        return nothing, nothing\n    else\n\
    \        return maximum.(lst), minimum.(lst)\n    end\nend\n</cell>\n<text>\n\
    Question 16. How many pairs of numbers have the largest and smallest sum?\nFor\
    \ example, if we have $[12, -4, -16, -6, -13, -2, 6, 7]$, the result should be\
    \ $2$ because we only need to sum $12$ and $-2$.", "    if length(lst) == 0 \n\
    \        error(\"List must not be empty\")\n    end\n    (if any(x <= 0 for x\
    \ \u2208 lst) \n        Nothing\n    else\n        minimum(lst),\n        maximum(lst)\n\
    \    end\n    )\nend\n</cell>\n<code language=julia-1.1>\nlargest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7])\n</cell>\n<code language=julia-1.1>\nlargest_smallest_integers([])\n\
    </cell>\n<code language=julia-1.1>\nlargest_smallest_integers([0])\n</cell>\n\
    <text>\nThe maximum and minimum functions", "    if all(lst.>=0) \n        return\
    \ (nothing,nothing) \n    end\n    min_int = minimum(lst)\n    max_int = maximum(lst)\n\
    \    return (min_int, max_int)", "    if all(x<0 for x in lst)\n        (a,b)\
    \ = (nothing,nothing)\n    elseif all(x>0 for x in lst)\n        (a,b) = (nothing,nothing)\n\
    \    else\n        (a,b) = (argmax(lst),smallest_index(lst))\n    end\n    return\
    \ a,b\nend", "    largest = nothing\n    smallest = nothing\n    for i in lst\n\
    \        if i < 0\n            largest = i\n        elseif i == 0\n          \
    \  smallest = nothing\n        elseif i > largest\n            largest = i\n \
    \       elseif smallest == nothing or i < smallest\n            smallest = i\n\
    \        end\n    end\n    (largest, smallest)\nend\n</cell>\n<code language=julia-1.4>\n\
    @test largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (nothing, 1)\n@test largest_smallest_integers([])\
    \ == (nothing, nothing)\n@test largest_smallest_integers([0]) == (nothing, nothing)\n\
    </cell>\n<text>\nCreate a function that takes a vector of numbers as an argument\
    \ and returns a vector of all numbers, except for one that occurs more than twice:",
  "    if all(is_nothing, lst)\n    (a, b) = (nothing, nothing)\n    elseif lst ==\
    \ []\n    (a, b) = (nothing, nothing)\n    else\n        largest_smaller_smallest_integer(lst)\n\
    \    end\nend", "    if lst==[]\n        nothing\n    elseif lst==[nothing]\n\
    \        (nothing, nothing)\n    else\n        largest_smallest_integers(lst[1:end-1]);\n\
    \        smallest_largest_integers(lst[1:end-1]);\n    end\nend\nlargest_smallest_integers(lst::Vector{Int64})\
    \ = largest_smallest_integers(lst);\nlargest_smallest_integers(_::Vector{Int64})\
    \ = nothing\n</code>\nThe answer by is also an approach to solving the problem.\n\
    <|/ a dscore=1 |>\n<| c |>\nThis is really useful.  Thank you.\n<|/ c |>\n<| c\
    \ |>\nActually, I thought that `@if` will give an error if the condition is not\
    \ met (I guess I missed that in the manual). Now I realized that `@if` works on\
    \ booleans, and the condition needs to be a boolean. So I guess I should edit\
    \ my answer to use `@if`.\n<|/ c |>\n<| a tags=julia dscore=0 |>\nI did something\
    \ similar to this (although I used Dicts.jl). \n<code>", "    if !is_sorted(lst)\n\
    \        return nothing, nothing\n    lst = sort!(lst)\n    i, j = lastindex(lst),\
    \ firstindex(lst)\n    if i == j\n        return nothing, nothing\n    \n    if\
    \ lst[i] < 0\n        return largest_smallest_integers(lst[i:]), (lst[i], nothing)\n\
    \    elseif lst[j] > 0\n        return (nothing,largest_smallest_integers(lst[j:]))\n\
    \    else\n        return largest_smallest_integers(lst[i:]), (lst[i], largest_smallest_integers(lst[j:]))\n\
    \    end\nend\n</cell>\n<text>\nFunction to find all combinations of k elements\
    \ from a given iterable collection\nThis function is similar to the function combinations\
    \ from the itertools module, but it doesn't use an iterator.", "    if isempty(lst)\n\
    \        return (nothing, nothing)\n    end", "    # Write your function code\
    \ here.\n    if lst.empty()\n        return Nothing, nothing\n    largest = minimum(lst)\n\
    \    smallest = maximum(lst)\n    if largest == minimum(lst)\n        return largest,\
    \ smallest\n    return largest, nothing\nend\n</code>\nAnd finally, test it:\n\
    <code>\njulia> largest_smallest_integers([2, 4, 1, 3, 5, 7])\n(nothing, 1)", " \
    \   if null lst\n        return nothing, nothing\n    a, b = minimum(lst), maximum(lst)\n\
    \    if a < 0\n        a, b = 0, b\n    end\n    if b < 0\n        a, b = b, a\n\
    \    end\n    return a, b\nend\n</cell>\n<code language=julia-1.5>", "    idx\
    \ = 0\n    smallest = nothing\n    largest = nothing\n    while (idx < length(lst))\n\
    \        if lst[idx] < smallest\n            smallest = lst[idx]\n        elseif\
    \ lst[idx] > largest\n            largest = lst[idx]\n        end\n        idx\
    \ += 1\n    end\n    return smallest, largest\nend", "    if isempty(lst)\n  \
    \      return nothing\n    elseif any(lst < 0)\n        return nothing\n    elseif\
    \ any(lst > 0)\n        return lst, nothing\n    else\n        largest, smallest\
    \ = nothing\n        for i in lst\n            if i > largest\n              \
    \  largest = i\n            elseif i < smallest\n                smallest = i\n\
    \        return (largest, smallest)\n    end\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a dscore=2 tags=julia,function,if-statement |>\nThere is also a similar problem\
    \ to solve using foldl:\n<code>\njulia> function smallest_last(lst)\n        \
    \   foldl(lt->lt, lst, last(lst, 0)[1])\n       end\nsmallest_last (generic function\
    \ with 1 method)", "    if isempty(lst)\n        return (nothing, nothing)\n \
    \   elseif max(lst) < 0\n        return (nothing, max(lst))\n    else\n      \
    \  return (min(lst), 0)\n    end\nend", "    if !all(isfinite(lst))\n        return\
    \ nothing, nothing\n    end", "    if all(lst.>0)\n        return (max(lst),min(lst))\n\
    \    elseif lst.==[]\n        return (nothing,nothing)\n    else\n        return\
    \ (nothing,nothing)\n    end\nend\n</cell>\n<text>\nExercise 3", "    if length(lst)\
    \ == 0 return (nothing, nothing)\n    if all(elem < 0 for elem in lst) return\
    \ (nothing, nothing)\n    if all(elem > 0 for elem in lst) return (nothing, nothing)\n\
    \    maximum = minimum(elt for elt in lst)\n    return (maximum, minimum(elt for\
    \ elt in lst))\nend\n</cell>\n<text>\nNow let's apply the function to the data\
    \ set.", "    if !isnothing(lst)\n        a = maximum.(lst)\n        b = minimum.(lst)\n\
    \        return (a, b)\n    end\n    return nothing, nothing\nend\n</cell>\n<text>\n\
    Largest of Any Number of Integers\nLet's now see how we can apply largest_smallest_integers\
    \ to a single value.", "    if length(lst) == 0\n        return (), nothing\n\
    \    largest = minimum(lst)\n    smallest = maximum(lst)\n    nothing\nend\n</cell>\n\
    <text>\nProblem 7\nImplement a function, smallest_largest, that takes a vector\
    \ of ints and returns\nthe smallest and largest of the vector. Use the largest\
    \ and smallest functions\nyou created in the previous problem.", "    if length(lst)\
    \ == 0\n        return (nothing, nothing)\n    elseif length(lst) == 1\n     \
    \   return (lst[1], nothing)\n    else\n        minimum, max = nothing\n     \
    \   for el in lst\n            if el < 0\n                if min == nothing\n\
    \                    minimum = el\n                else\n                    minimum\
    \ = min(minimum, el)\n            elseif el > 0\n                if max == nothing\n\
    \                    max = el\n                else\n                    max =\
    \ max(max, el)\n            else\n                if min == nothing\n        \
    \            minimum = el\n                else\n                    minimum =\
    \ min(minimum, el)\n                if max == nothing\n                    max\
    \ = el\n                else\n                    max = max(max, el)\n       \
    \     end\n        end\n        return (minimum, max)\n    end\nend\n</code>\n\
    The function largest_smallest_integers returns a tuple with two elements (a, b).\
    \ a is the largest of negative integers, and b is the smallest of positive integers\
    \ in a vector. If there is no negative or positive integers, return them as nothing.\n\
    <|/ a |>\n<| c |>\nThe only thing is I love this answer the most. As I said, I\
    \ understand this perfectly, I just couldn't get the math to work out. Thank you!\
    \ However, this is only a partial answer, because I still don't understand why\
    \ you need a nested function/closure. The reason why I didn't use this is because\
    \ it was my idea of what to do, and not knowing how to do it, I didn't know how\
    \ to write it. I was looking for a way to solve this problem without using a nested\
    \ function/closure.\n<|/ c |>\n<| c |>\nThe first function I wrote is the nested\
    \ function. The second function uses nested function, but it is simpler.\n<|/\
    \ c |>\n<| c |>\nWhy do I need a nested function/closure? Because I don't know\
    \ how to write it. I can't even do my own nested function/closure. I know that\
    \ I need a nested function/closure because I'm not writing a function/closure\
    \ for the first time ever.\n<|/ c |>\n<| c |>\nI wrote a nested function/closure\
    \ because I knew that if I knew how to write it I would just do it normally. However,\
    \ I couldn't think of how to write it without using a nested function/closure.\
    \ I understand that I don't know how to write it, but I don't understand why I\
    \ would need nested function/closure.\n<|/ c |>\n<| c |>\nI see your point. In\
    \ fact, I don't think it's a nested function/closure but just a function definition.\
    \ Nested function/closures are used in Julia to store functions and variables\
    \ in the outer scope so that they are accessible in the inner scope. I found this\
    \ question interesting and was surprised to see an ", "    if length(lst) == 0\
    \ \n        return nothing, nothing \n    else if min(lst) == -Inf \n        return\
    \ nothing, nothing\n    else if max(lst) == Inf \n        return nothing, nothing\
    \ \n    else \n        return lst[findall(lst .< -Inf)[1]], lst[findall(lst .>=\
    \ Inf)[1]]\nend\n</cell>\n<code language=julia-1.2>\n\"\"\"\n    largest_positive_integers",
  "    if length(lst) == 0 \n        return (nothing, nothing) \n    maximum = minimum\
    \ = nothing \n    if length(lst) == 1 \n        return (lst[1], lst[1]) \n   \
    \ for n in lst\n        if n < minimum \n            minimum = n\n        else\
    \ if n > maximum \n            maximum = n\n        end\n    end\n    return (minimum,\
    \ maximum)\nend", "  if lst.is_empty\n    return nothing, nothing\n  end", " \
    \   if length(lst.) == 0 then return (nothing, nothing) else \n        largest\
    \ = max(lst)\n        smallest = min(lst)\n        if largest < smallest then\
    \ return (nothing, nothing) else return (largest, smallest)\n    end\nend\n</cell>\n\
    <text>\nExample: Create a function which will determine if a list has a prime\
    \ factor", "    largest = nothing\n    smallest = nothing\n    for elt in lst\n\
    \        if elt < 0\n            if smallest == nothing\n                smallest\
    \ = elt\n            elseif elt < smallest\n                smallest = elt\n \
    \       elseif elt > largest\n            largest = elt\n        end\n    end\n\
    \    if smallest == nothing\n        return (nothing,nothing)\n    elseif smallest\
    \ > largest\n        return (smallest,largest)\n    elseif smallest < largest\n\
    \        return (largest,smallest)\n    end\n    return (largest, nothing)\nend\n\
    </cell>\n<code language=julia-1.5>\nlargest_smallest_integers([2, 4, 4, 4, 4,\
    \ 4, 6, 8, 9])\n</cell>\n<code language=julia-1.5>\nlargest_smallest_integers([1])\n\
    </cell>\n<text>\nIn Julia, a function is like an object, with its own memory space,\
    \ and methods (functions, methods, functions as variables) that are part of the\
    \ object. We can have different methods for different types of functions. In Julia,\
    \ we can use the function syntax to define the function.", "    if all(x < 0 for\
    \ x in lst)\n    (a, b) = (nothing, nothing)\nelse\n    (a, b) = maximum(lst),\
    \ minimum(lst)\nend\nreturn a, b\nend\n</cell>\n<text>\nNow we can call the function\
    \ and see the results. We can see that this function returns nothing if the input\
    \ is empty.", "    if length(lst) == 0 \n        return (nothing, nothing) \n\
    \    \n    largest = nothing\n    smallest = nothing\n    largest = min(lst)\n\
    \    smallest = max(lst)", "    if isnothing(lst)\n        return nothing, nothing\n\
    \    else\n        sort!(lst)\n        return first(lst), last(lst)\n    end\n\
    end\n</cell>\n<text>\nPart 5: Practice with map", "    if length(lst) == 0\n \
    \       return (nothing, nothing)\n    end\n    maximum = min(lst)\n    minimum\
    \ = max(lst)\n    if maximum < minimum\n        return (nothing, minimum)\n  \
    \  else\n        return (minimum, nothing)\n    end\nend\n</code>\n<|/ a dscore=2\
    \ tags=julia |>\n<| c |>\nWhile a nice and simple solution, it doesn't work with\
    \ very large vectors (as you noticed yourself). My suggestion would be to use\
    \ `findfirst` to find the index of the maximum element and use that index later\
    \ to slice `lst`.\n<|/ c |>\n<| c |>\n`findfirst` does work just fine with very\
    \ large vectors. If you want it to be efficient, you should use `findlast`, which\
    \ goes through the vector in reverse order, and therefore is faster for large\
    \ vectors.\n<|/ c |>\n<| c |>\nYes, that's a good point. I'll correct my answer.\
    \ Thank you.\n<|/ c |>\n<| c |>\nThanks! But this only works when I have a collection\
    \ of numbers to sort. And I'm doing something else. Let me reformulate: Is there\
    \ a way to use the `sort` function on a variable of type `Union{Nothing, Vector{Int64}}`,\
    \ where `nothing` represents no elements, and `Vector{Int64}` the elements to\
    \ sort?\n<|/ c |>\n<| a dscore=2 |>\n<code>", "    if lst.length() == 0\n    \
    \    return (nothing, nothing)\n    else\n        pos = minimum.(lst)\n      \
    \  neg = maximum.(lst)\n        return (pos, neg)\n    end\nend", "    if length(lst)\
    \ < 2 \n        return (nothing, nothing) \n    largest, smallest = Inf, -Inf\
    \ \n    for i in lst \n        if i < smallest \n            smallest = i\n  \
    \      else if i > largest \n            largest = i \n    return (largest, smallest)\
    \ \nend", "        if any(x < 0 for x in lst)\n            smallest_integer_index\
    \ =  findmin(lst)[1]\n            return nothing , (smallest_integer_index)\n\
    \        else\n            largest_integer_index =  findmax(lst)[1]\n        \
    \    return nothing , (largest_integer_index)\n        end\nend\n</code>\n<|/\
    \ a |>\n<| a dscore=0 |>\nA simple recursive function could do the job:\n<code>",
  "    if all(elem < 0 for elem in lst)\n        return nothing, nothing\n    if all(elem\
    \ > 0 for elem in lst)\n        return nothing, nothing\n    (largest, smallest)\
    \ = (nothing,nothing)\n    largest = max(largest, min(lst))\n    smallest = min(smallest,\
    \ max(lst))\n    return (largest, smallest)\nend\n</cell>\n<code language=julia-1.5>\n\
    @test largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (nothing, 1)\n@test largest_smallest_integers([])\
    \ == (nothing, nothing)\n@test largest_smallest_integers([0]) == (nothing, nothing)\n\
    </cell>\n<text>\n\u26A0 Exercise: Write a function that finds the smallest element\
    \ of a vector, and returns nothing if the vector is empty.", "    if length(lst)\
    \ == 0 \n        return (nothing, nothing) \n    end", "    (a,b) = (nothing ,nothing)\n\
    \    for i in lst\n        if i < 0\n            a = i\n        elseif i > 0 \n\
    \            b = i\n        else\n            (a ,b) = (i,j)\n            break\n\
    \        end\n    end\n    return (a,b)\nend\n</cell>\n<code language=julia-0.6>\n\
    a,b = largest_smallest_integers(numbers)\n</cell>\n<text>\nExercise: Write a function\
    \ that takes in an array of numbers and returns the sum of the numbers (both positive\
    \ and negative). You can do this by using the + function and summing the results.",
  "    if isempty(lst)\n        return nothing, nothing\n    elseif head(lst) == min(lst)\
    \ || tail(lst) == min(lst)\n        return nothing, nothing\n    else\n      \
    \  return maximum(lst), minimum(lst)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @testset \"largest_smallest_integers\" begin\n    largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7])\n    largest_smallest_integers([])\n    largest_smallest_integers([0])\n\
    end\n</cell>\n<text>\nExercise 3", "    if isempty(lst)\n        return nothing,\
    \ nothing\n    elseif all(x->x < 0, lst)\n        return nothing, nothing\n  \
    \  elseif all(x->x > 0, lst)\n        return lst[end], lst[end]\n    else\n  \
    \      positives = filter(x->x>0, lst)\n        negatives = filter(x->x<0, lst)\n\
    \        return maximum(positives), minimum(negatives)\n    end\nend\n</code>\n\
    <|/ a tags=julia,function |>\n<| c |>\nIf you're doing this a lot, you can get\
    \ this down to `maximum(filter(x < 0, xs))` which should be faster than `maximum(xs)\
    \ - minimum(xs)` since it's one subtraction and one addition.\n<|/ c |>\n<| c\
    \ |>\nIn fact, `maximum()` *is* faster, and it's about 2.5 times faster on my\
    \ computer.\n<|/ c |>\n<| a tags=julia,function |>\nTo expand on Dan's excellent\
    \ answer, you could also use .indexmax:\n<code>", "    if length(lst) == 0\n \
    \       return (nothing, nothing)\n    elseif length(lst) == 1\n        return\
    \ (0, lst[0])\n    elseif all(v < 0 for v in lst)\n        return (nothing, nothing)\n\
    \    elseif all(v > 0 for v in lst)\n        (a, largest) = largest(lst)\n   \
    \     (b, smallest) = smallest(lst)\n        if largest == smallest\n        \
    \    return (nothing, largest)\n        else\n            return (a, b)\n    end\n\
    end", "    if length(lst) == 0 \n        (a,b) = (nothing,nothing)\n    elseif\
    \ length(lst) > 1 \n        (a,b) = (nothing,nothing) \n    elseif all(isnothing,\
    \ lst) \n        (a,b) = (nothing,nothing) \n    elseif all(isnothing, reverse(lst))\
    \ \n        (a,b) = (nothing,nothing) \n    elseif all(lst .< 0)\n        (a,b)\
    \ = (maximum.(lst),minimum.(lst))\n    elseif all(lst .> 0)\n        (a,b) = (minimum.(lst),maximum.(lst))\n\
    \    elseif all(lst == 0)\n        (a,b) = (nothing,nothing)\n    else\n     \
    \   (a,b) = (nothing,nothing)\n    end\n    return (a,b)\nend\n</cell>\n<code\
    \ language=julia-1.5>\nlargest_smallest_integers([2,4,1,3,5,7])\n</cell>\n<text>\n\
    Notice how it returned (nothing, 1), because that is the smallest and largest\
    \ integer in the list. Let's see what happens when we pass in an empty list.",
  "    \n    \n    smallest = (minimum(lst),nothing)\n    largest = (maximum(lst),nothing)\n\
    \    \n    if smallest == nothing\n        return largest\n    else\n        return\
    \ largest\n    end\nend", "    (a, b) = if min(lst) == -Inf || max(lst) == Inf\
    \ \n        (a, nothing) \n    elseif min(lst) == -Inf \n        (b, Inf) \n \
    \   elseif max(lst) == Inf \n        (a, Inf) \n    elseif min(lst) == Inf &&\
    \ max(lst) == Inf \n        (nothing) \n    else\n        (largest_smallest_integers(lst[a\
    \ < b ? a : b]), \n            largest_smallest_integers(lst[b < a ? b : a]))\
    \ \n    end\n    (a, b)\nend\n</cell>\n<code language=julia-1.5>\nlargest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7])\n</cell>\n<text>\nGreedy Knapsack Problem\nThe greedy knapsack\
    \ problem asks us to find the maximum value of", "    if len(lst) == 0\n     \
    \   return (nothing, nothing)\n    elseif length(lst) == 1\n        return (0,\
    \ lst[1])\n    elseif length(lst) == length(unique(lst))\n        return (min(lst),\
    \ max(lst))\n    else\n        lst = sort(lst)\n        first = lst[1]\n     \
    \   last = lastindex(lst)\n        second = first\n        if first > last\n \
    \           first, second = second, first\n        return first, (second-last)\n\
    \    end\nend\n</cell>\n<text>\nThis function is called largest_smallest_integers\
    \ when you pass in a Vector{Int64}.", "    if lst.is_empty\n        return Nothing,\
    \ nothing\n    \n    max_elem = max(lst)\n    min_elem = min(lst)\n    \n    if\
    \ max_elem == min_elem\n        return max_elem, min_elem\n    \n    return max_elem,\
    \ min_elem\nend", "    neg, pos = nothing,nothing\n    for x in lst\n        if\
    \ x < 0 \n            neg <- x\n        else\n            if x > pos\n       \
    \         pos <- x\n            else\n                nothing\n        end\n \
    \   end\n    (neg, pos)\nend\n</cell>\n<text>\nNotice that largest_smallest_integers\
    \ uses local mutable variables. In Julia, you should try to avoid using them.",
  "    if lst.is_empty \n        (x, y) = (nothing, nothing) \n    else \n       \
    \ (x, y) = (if is_sorted(lst) then lst[end] else nothing,\n                 if\
    \ is_sorted(lst) then lst[1] else nothing)\n    end\n    return (x, y)\nend\n\
    </code>\n<|/ a tags=julia dscore=3 |>\n<| a |>\nThe answer from Ethan Gill is\
    \ correct, but a more concise and efficient way is to use findmax.\n<code>", " \
    \   if lst == []\n        return (nothing,nothing)\n    largest = 0\n    smallest\
    \ = nothing\n    for i in lst \n        if i < 0\n            largest = i\n  \
    \      else\n            smallest = i\n    return (largest, smallest)\nend ",
  "    if all(x < 0 for x in lst) == false && all(x > 0 for x in lst) == false \n\
    \    then \n        (nothing,nothing)\n    else \n        (min(lst), max(lst))\n\
    \    end\nend\n</cell>\n<cell>\nlargest_smallest_integers([2, 4, 1, 3, 5, 7])\n\
    </cell>\n<cell>\nlargest_smallest_integers([])\n</cell>\n<cell>\nlargest_smallest_integers([0])\n\
    </cell>\n<text>\nA function to find the number of positive integers in a vector\n\
    Write a function that returns the number of positive integers in a vector,\nwhere\
    \ 0 is considered a positive integer and everything else is considered a negative\
    \ integer.\nIf there are no positive integers, return 0.\nExamples:\n>>> count_positive_integers([1,\
    \ 2, 3, 4])\n3\n>>> count_positive_integers([1, 2, -1])\n0\n>>> count_positive_integers([1,\
    \ 2, 1])\n1\n\"\"\"", "    if isempty(lst)\n        return (nothing, nothing)\n\
    \    if all(rem(lst, Int64(1)) == 0)\n        return (0, 0)\n    if all(lst .>\
    \ 0)\n        return (max(lst), min(lst))\n    return (max(lst .- Int64(1)), min(lst\
    \ .- Int64(1)))\nend\n</cell>\n<code language=julia-1.5>\n@code_warntype largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7])\n</cell>\n<text>\nThe @code_warntype macro tells Julia to issue\
    \ a warning whenever we call a function with a type that is inconsistent or inprecise.\
    \ For example, if we call largest_smallest_integers with a vector of Int64, but\
    \ it is passed an Int8, the compiler will issue a warning that tells us that we\
    \ are doing something wrong.", "    neg_integers = findfirst(isequal(-int64),\
    \ lst)\n    pos_integers = findfirst(isequal(int64), lst)\n    if neg_integers\
    \ isnothing && pos_integers isnothing\n        return (nothing, nothing)\n   \
    \ elseif neg_integers isnothing\n        return (pos_integers, nothing)\n    elseif\
    \ pos_integers isnothing\n        return (neg_integers, nothing)\n    elseif neg_integers\
    \ < pos_integers\n        return (neg_integers, pos_integers)\n    else\n    \
    \    return (pos_integers, neg_integers)\n    end\nend\n</cell>\n<text>\nTask:\
    \ Use largest_smallest_integers to write a function which returns the largest\
    \ and smallest elements of a list of integers. Test it by comparing it with max.",
  "    if !isnothing(lst[1])\n        smallest = lst[1]\n    else\n        smallest\
    \ = nothing\n    end\n    if isnothing(lst[1])\n        largest = nothing\n  \
    \  else\n        largest = lst[1]\n    end\n    for elt in lst[2:end]\n      \
    \  if isnothing(largest)\n            largest = elt\n        elseif elt < smallest\n\
    \            largest = elt\n        elseif elt > largest\n            smallest\
    \ = elt\n        end\n    end\n    return (smallest, largest)\nend", "    if !all(isfinite(lst))\
    \ || all(lst.==0)\n        return (nothing,nothing)\n    end\n    largest = nothing\n\
    \    smallest = nothing\n    for x in lst\n        if x < 0\n            push!(largest,\
    \ x)\n        elseif x > 0\n            push!(smallest, x)\n        end\n    end\n\
    \    (smallest,largest)\nend\n</cell>\n<code language=julia-1.1>\ntest_largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7])\n</cell>\n<text>\nWe now define a function which returns true\
    \ if the given number is an even number\nand false if it is a odd number.", " \
    \   pos, neg = minimum(lst), maximum(lst)\n    if pos == nothing || neg == nothing\n\
    \        return nothing, nothing\n    elseif neg < pos\n        return neg, pos\n\
    \    elseif pos < neg\n        return pos, neg\n    else\n        return pos <\
    \ neg ? neg : pos\n    end\nend", "    if lst == []\n        (a, b) = (nothing,nothing)\n\
    \    else \n        (a, b) = max_min(lst)\n    end\n    return a, b\nend\n</cell>\n\
    <text>\nlargest_smallest_integers(lst::Vector{Int64})", "    if all(isnothing(lst))\n\
    \        nothing\n    else\n        min(lst), max(lst)\n    end\nend", "    if\
    \ length(lst)==0 \n        return nothing, nothing \n    else \n        min_val\
    \ = minimum(lst)\n        max_val = maximum(lst)\n        return min_val, max_val\
    \ \nend \n</code>\nTest:\n<code>\njulia> largest_smallest_integers([2, 4, 1, 3,\
    \ 5, 7])\n(7,5)", "    if isempty(lst)\n        return (nothing, nothing)\n  \
    \  end\n    \n    lst = sort(lst)\n    \n    if lst[1] < 0\n        return (nothing,nothing)\n\
    \    end", "    if len(lst) == 0\n        return nothing, nothing\n    max = minimum(lst)\n\
    \    min = maximum(lst)\n    if max < min\n        return max, min\n    else\n\
    \        return nothing, min\nend", "    if all(x isnothing for x in lst)\n  \
    \      throw(ArgumentError(\"All elements of 'lst' must be Nothing\"))\n    else\n\
    \        if all(x isnothing for x in lst .- 1:-1:1)\n            return nothing\n\
    \        else\n            a, b = nothing,nothing\n            for i in lst .-\
    \ 1:-1:1\n                if isnothing(a)\n                    if i< 0\n     \
    \                   a = i\n                    elseif i > 0\n                \
    \        b = i\n                else\n                    if i > b\n         \
    \               b = i\n                    elif i < a\n                      \
    \  a = i\n            return a,b\n        end\n    end\nend\n</cell>\n<text>\n\
    Now let's see how we can use this to write a function that returns the minimum\
    \ and maximum values in an array:", "  if length(lst) == 0 then return nothing,\
    \ nothing\n  \n  largest = nothing\n  smallest = nothing\n  for val in lst\n \
    \   if val < 0\n      if largest == nothing then largest = val\n      else smallest\
    \ = val\n    end\n  end\n  if largest == nothing then return smallest, nothing\n\
    \  if smallest == nothing then return largest, nothing\n  return largest, smallest\n\
    end", "    # Handle empty list\n    if isempty(lst)\n        return (nothing,\
    \ nothing)\n    # Handle all integers\n    if all(isinteger(x) for x in lst)\n\
    \        return (max(lst), min(lst))\n    # Handle mixed integers and floats\n\
    \    if any(~isinteger(x) for x in lst)\n        return (nothing, nothing)\n \
    \   # Handle negative integers\n    if all(x <= 0 for x in lst)\n        return\
    \ (max(lst), min(lst))\n    # Handle positive integers\n    if all(x >= 0 for\
    \ x in lst)\n        return (max(lst), min(lst))\n    # Handle all floats\n  \
    \  if all(isrational(x) for x in lst)\n        return (max(lst), min(lst))\n \
    \   # Handle mixed integers and floats\n    if any(~isrational(x) for x in lst)\n\
    \        return (nothing, nothing)\n    # Handle mixed integers and floats\n \
    \   if any(isrational(x) or isinteger(x) for x in lst)\n        return (max(lst),\
    \ min(lst))\n    # Handle mixed integers and floats\n    return (nothing, nothing)\n\
    end", "    if isnothing(lst)\n        return (nothing, nothing)\n    elseif length(lst)\
    \ == 0\n        return (nothing, nothing)\n    elseif all(elem < 0 for elem in\
    \ lst)\n        return (nothing, 0)\n    elseif all(elem > 0 for elem in lst)\n\
    \        return (0, nothing)\n    end\n    \n    largest = -inf\n    smallest\
    \ = inf\n    for elem in lst\n        if elem < 0 \n            smallest = min(elem,smallest)\n\
    \        elseif elem > 0 \n            largest = max(elem,largest)\n        end\n\
    \    end\n    return (largest,smallest)\nend", "    if any(v < 0 for v in lst)\n\
    \        return (Nothing, nothing)\n    elseif any(v > 0 for v in lst)\n     \
    \   return (nothing, nothing)\n    else\n        return lst[findfirst(l -> l >\
    \ 0, lst)], lst[findfirst(l -> l < 0, lst)]\n    end\nend\n</cell>\n<text>\nPart\
    \ 4: Using an optimizing compiler\nIn this part of the exercise, you will optimize\
    \ your code. You will learn more about this in the next exercises. In order to\
    \ optimize your code, you will use the  Julia language to write your function.\
    \ You will use a \"code optimizer\" that takes in a function and returns a function,\
    \ which is a bit like \"code generation\" but for Julia code rather than Python\
    \ code. Code optimizers are different from code generators in that they can do\
    \ type inference and generate efficient machine code. Code optimizers are also\
    \ called \"compilers\" in other programming languages. You will use a code optimizer\
    \ when you want to compile your function at runtime rather than when you write\
    \ your function. Code optimizers also have different optimizing options available\
    \ that you can pass to the optimizer. Most of these options are compiler specific,\
    \ and we will use only a few options that are compiler specific. You will use\
    \ the @code_native Julia macro to help you write a good Julia function optimizer.\
    \ This macro takes a function and returns a function optimized by your compiler.",
  "    largest = nothing\n    smallest = nothing\n    for i in lst\n        if i <\
    \ 0\n            if largest == nothing\n                largest = i\n        \
    \    elseif largest != nothing\n                largest = nothing\n          \
    \  end\n        elseif i > largest\n            largest = i\n        end\n   \
    \ end\n    if largest != nothing\n        smallest = nothing\n        for i in\
    \ lst\n            if i < 0\n                if smallest == nothing\n        \
    \            smallest = i\n                elseif smallest != nothing\n      \
    \              smallest = nothing\n                end\n            elseif i >\
    \ smallest\n                smallest = i\n            end\n        end\n    end\n\
    \    return smallest, largest\nend\n</cell>\n<code language=julia-1.5>\n@time\
    \ largest_smallest_integers([0,1,2,3,4])\n</cell>\n<code language=julia-1.5>\n\
    @time largest_smallest_integers([0,0])\n</cell>\n<text>\n2.4 A better version\
    \ of largest_smallest_integers", "    if isempty(lst)\n        return (nothing,\
    \ nothing)\n    elseif any(x > 0 for x in lst)\n        return (highest_integer(lst),\
    \ lowest_integer(lst))\n    else\n        return (nothing, nothing)\n    end\n\
    end\n</cell>\n<code language=julia-1.6>\n\"\"\"\n    largest_integer_faster(lst)",
  "    if lst.size < 2\n        nothing\n    elseif lst.size == 1\n        (1, lst[0])\n\
    \    elseif lst.size == 2\n        (lst[0], lst[1])\n    elseif lst.size == 3\n\
    \        smallest_int_greater_than_or_equal_to(lst[1], lst[2])\n    elseif lst.size\
    \ == 4\n        smallest_int_greater_than_or_equal_to(lst[1], lst[2]), smallest_int_greater_than_or_equal_to(lst[3],\
    \ lst[4])\n    elseif lst.size == 5\n        smallest_int_greater_than_or_equal_to(lst[1],\
    \ lst[2]), smallest_int_greater_than_or_equal_to(lst[3], lst[4]), smallest_int_greater_than_or_equal_to(lst[5],\
    \ lst[6])\n    elseif lst.size == 6\n        smallest_int_greater_than_or_equal_to(lst[1],\
    \ lst[2]), smallest_int_greater_than_or_equal_to(lst[3], lst[4]), smallest_int_greater_than_or_equal_to(lst[5],\
    \ lst[6]), smallest_int_greater_than_or_equal_to(lst[7], lst[8])\n    elseif lst.size\
    \ == 7\n        smallest_int_greater_than_or_equal_to(lst[1], lst[2]), smallest_int_greater_than_or_equal_to(lst[3],\
    \ lst[4]), smallest_int_greater_than_or_equal_to(lst[5], lst[6]), smallest_int_greater_than_or_equal_to(lst[7],\
    \ lst[8]), smallest_int_greater_than_or_equal_to(lst[9], lst[10])\n    elseif\
    \ lst.size == 8\n        smallest_int_greater_than_or_equal_to(lst[1], lst[2]),\
    \ smallest_int_greater_than_or_equal_to(lst[3], lst[4]), smallest_int_greater_than_or_equal_to(lst[5],\
    \ lst[6]), smallest_int_greater_than_or_equal_to(lst[7], lst[8]), smallest_int_greater_than_or_equal_to(lst[9],\
    \ lst[10]), smallest_int_greater_than_or_equal_to(lst[11], lst[12])\n    elseif\
    \ lst.size == 9\n        smallest_int_greater_than_or_equal_to(lst[1], lst[2]),\
    \ smallest_int_greater_than_or_equal_to(lst[3], lst[4]), smallest_int_greater_than_or_equal_to(lst[5],\
    \ lst[6]), smallest_int_greater_than_or_equal_to(lst[7], lst[8]), smallest_int_greater_than_or_equal_to(lst[9],\
    \ lst[10]), smallest_int_greater_than_or_equal_to(lst[11", "    if lst == []\n\
    \        return nothing\n    \n    smallest, largest = nothing\n    \n    for\
    \ n in lst\n        if n < 0\n            if smallest == nothing\n           \
    \     smallest = n\n            elseif n < smallest\n                smallest\
    \ = n\n        elseif n > largest\n            largest = n\n        end\n    end\n\
    \    return smallest, largest\nend\n</cell>\n<text>\nlargest_smallest_integer()\
    \ function implementation", "    largest_negative_integer = nothing\n    largest_positive_integer\
    \ = nothing\n    for (i, el) in enumerate(lst)\n        if el > 0\n          \
    \  if el < largest_positive_integer\n                largest_positive_integer\
    \ = el\n            elseif el > largest_negative_integer\n                largest_negative_integer\
    \ = el\n            end\n        end\n    end\n    return largest_positive_integer,\
    \ largest_negative_integer\nend", "    if lst.is_empty() \n        return (nothing,\
    \ nothing)\n    \n    smaller_than_zero = falses(Int64)\n    larger_than_zero\
    \ = falses(Int64)", "    if length(lst)==0 \n        return (nothing, nothing)\
    \ \n    end", "        if all(x < 0 for x in lst) then\n            (nothing,\
    \ (max(x for x in lst if x < 0)))\n        elseif all(x > 0 for x in lst) then\n\
    \            (nothing, (min(x for x in lst if x > 0)))\n        else\n       \
    \     (nothing, (nothing))\n        end\n    end\n</cell>\n<text>\nThe function\
    \ largest_smallest_integers returns a tuple that contains two values:", "    a_max::Nothing\
    \ = nothing\n    b_min::Nothing = nothing", "    if length(lst) == 0 \n      \
    \  return nothing, nothing \n    \n    max_val, min_val = maximum(lst, nothing),\
    \ minimum(lst, nothing)\n    if min_val == nothing \n        return nothing, nothing\n\
    \    \n    if min_val < 0 \n        return (min_val, nothing) \n    \n    if max_val\
    \ > 0 \n        return (max_val, min_val) \n    \n    return (nothing, nothing)\n\
    </code>\n<|/ a dscore=4 |>\n<| a dscore=2 |>\nThis question is a little old but\
    \ I thought I would add my two cents on it.  I wanted to see how well the function\
    \ would scale for big arrays (millions of elements) and a simple test proved that\
    \ using if statements scales way better than using arrayfun.  The function is\
    \ about 100 times faster.\nHere is my code:\n<code>", "    # Find the maximum\
    \ in each element of the list\n    largest_negative = maximum(lst)\n    largest_positive\
    \ = minimum(lst)\n    # If the largest negative is nothing, the function should\
    \ return nothing\n    if largest_negative == nothing\n        return nothing,\
    \ nothing\n    else\n        # If the largest positive is nothing, the function\
    \ should return nothing\n        if largest_positive == nothing\n            return\
    \ nothing, nothing\n        else\n            return largest_negative, largest_positive\n\
    \        end\n    end\nend\n</cell>\n<text>\nQuestion: Given a vector with positive\
    \ and negative integers, return which of those integers are the largest, and the\
    \ smallest of the rest.", "    if is_sorted!(lst)\n        return (nothing,nothing)\n\
    \    end", "    if length(lst) == 0 \n        (a, b) = (nothing, nothing)\n  \
    \  elseif length(lst) == 1 \n        (a, b) = (lst[0], nothing)\n    elseif all(x\
    \ >= 0 for x in lst) \n        (a, b) = (lst[end], nothing)\n    else \n     \
    \   (a, b) = (lst[end], lst[end-1])\n    end\nend", "    if all(isnothing(lst))\n\
    \        return Nothing, Nothing\n    end\n    maximum = minimum = nothing\n \
    \   for x in lst\n        if x < minimum\n            minimum = x\n        end\n\
    \        if x > maximum\n            maximum = x\n        end\n    end\n    return\
    \ minimum, maximum\nend", "    if length(lst) == 0 \n        return (nothing,\
    \ nothing) \n    else \n        # sort ascending\n        sorted_list = sort(lst)\n\
    \        # find first negative and positive number in the list\n        negative_first_index\
    \ = findfirst(lt -> lt == -Inf, sorted_list)\n        if negative_first_index\
    \ != nothing \n            negative_first_index = negative_first_index - 1\n \
    \       else \n            negative_first_index = nothing \n        positive_first_index\
    \ = findfirst(lt -> lt == Inf, sorted_list)\n        if positive_first_index !=\
    \ nothing \n            positive_first_index = positive_first_index + 1\n    \
    \    else \n            positive_first_index = nothing \n        return (sorted_list[negative_first_index],\
    \ sorted_list[positive_first_index])\n    end\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=julia,list |>\nThis answer doesn't use any prepackaged functions but\
    \ rather uses the reduce function and some tricky code on the index functions\
    \ to find the min and max values.\n<code>", "    # find the largest number in\
    \ lst\n    if lst.is_empty\n        return (nothing, nothing)\n    largest = lst[1]\n\
    \    for i in lst[2:end]\n        if i > largest\n            largest = i\n  \
    \      end\n    end\n    return (largest, nothing)\nend\n</cell>\n<text>\nExercise:\
    \ Write a function called largest_integers() that returns all the largest integer\
    \ in a vector.", "    if !is_sorted!(lst)\n        error(\"Input must be sorted!\"\
    )\n    end\n    \n    max_min = (nothing => nothing)\n    for elt in lst\n   \
    \     if elt < 0 && elt > max_min.first\n            max_min = (elt => nothing)\n\
    \        elseif elt > 0 && elt > max_min.second\n            max_min = (elt =>\
    \ nothing)\n        end\n    end\n    return max_min\nend\n</cell>\n<text>\nA\
    \ function that finds the largest element in a vector.", "    if length(lst) ==\
    \ 0 then return (nothing, nothing) else \n        if any(x < 0 for x in lst) then\
    \ \n            return (nothing, nothing) else\n        if any(x > 0 for x in\
    \ lst) then \n            return (min(lst), nothing) else\n        return (min(lst),\
    \ max(lst))\n    else return (nothing, nothing)\nend", "    if lst == nothing,\
    \ \n        return nothing,nothing\n    else if all(x -> x < 0, lst), \n     \
    \   return nothing, nothing\n    else if all(x -> x > 0, lst), \n        return\
    \ lst, nothing\n    else\n        largest, smallest := max(lst), min(lst)\n  \
    \      if largest < smallest, \n            return largest,smallest\n        else\n\
    \            return largest,nothing\n    end\nend\n</cell>\n<text>\nPS - Don't\
    \ forget to run each of the cells above before proceeding onto the next one.",
  "    if isnothing(lst)\n        return nothing, nothing\n    elseif !length(lst)\n\
    \        return nothing, nothing\n    end\n    \n    largest = 0\n    smallest\
    \ = nothing\n    for i in 1:length(lst)\n        if lst[i] > largest\n       \
    \     largest = lst[i]\n        end\n        if lst[i] < smallest\n          \
    \  smallest = lst[i]\n        end\n    end\n    return largest, smallest\nend",
  "    if lst == []\n        return (nothing, nothing)\n    elseif lst == [0]\n  \
    \      return (nothing, nothing)\n    elseif lst == [nothing]\n        return\
    \ (nothing, nothing)\n    else\n        a_max, a_min = nothing,nothing\n     \
    \   b_max, b_min = nothing,nothing\n        for a in lst\n            if a > a_max\n\
    \                a_max = a\n            elseif a == a_max\n                a_max\
    \ = nothing\n            end\n            if a < b_min\n                b_min\
    \ = a\n            elseif a == b_min\n                b_min = nothing\n      \
    \      end\n        end\n        return (a_max, b_min)\n    end\nend\n</cell>\n\
    <text>\nExercise\nWrite a function that takes two vectors as input and returns\
    \ a vector where every element is equal to the product of the corresponding elements\
    \ of the input vectors.", "    if lst[1] == nothing\n        return Tuple{Union{Int64,\
    \ Nothing}, Union{Int64, Nothing}}(nothing, nothing)\n    end\n    a, b = minimum(lst),\
    \ maximum(lst)\n    return Tuple{Union{Int64, Nothing}, Union{Int64, Nothing}}(a,\
    \ nothing)\nend", "    if !length(lst)\n        return (), nothing\n        \n\
    \    largest = minimum(i for i in lst if i < 0)\n    smallest = maximum(i for\
    \ i in lst if i >= 0)", "    if all(x <=> nothing for x in lst)\n        return\
    \ nothing, nothing\n    end\n    \n    largest = nothing\n    smallest = nothing\n\
    \    for i in Int64(lst)\n        if i < largest\n            largest = i\n  \
    \      elseif i > smallest\n            smallest = i\n        end\n    end\n \
    \   return largest, smallest\nend\n</cell>\n<text>\nQuestion 4\nWrite a function\
    \ that returns the number of even numbers in an array.", "    largest_negative,\
    \ largest_positive = Nothing, Nothing\n    for x in lst\n        if x < 0\n  \
    \          largest_negative <-  x\n        else\n            largest_positive\
    \ <-  x\n        end\n    end\n    if largest_negative == Nothing && largest_positive\
    \ == Nothing\n        return (nothing, nothing)\n    else\n        return (largest_negative,\
    \ largest_positive)\n    end\nend", "    if isnothing(lst)\n        return (nothing,nothing)\n\
    \    else\n        return (max(lst), min(lst))\nend\n</cell>\n<code language=julia-1.5>\n\
    @code_llvm largest_smallest_integers([2, 4, 1, 3, 5, 7])\n</cell>\n<text>\nRecall\
    \ the definition of largest_smallest_integers:", "    if all(Int.(lst)<0) && all(Int.(lst)>0)\
    \ \n        nothing\n    elseif all(Int.(lst)<0) \n        nothing\n    elseif\
    \ all(Int.(lst)>0) \n        nothing\n    elseif all(Int.(lst)==0) \n        (0,\
    \ 0)\n    else\n        largest(lst), smallest(lst)\n    end\nend", "    if all(map(x\
    \ -> x < 0, lst))\n        nothing\n    elseif all(map(x -> x > 0, lst))\n   \
    \     nothing\n    else\n        (maximum(lst), minimum(lst))\nend", "    if isnothing(lst)\n\
    \        return nothing, nothing\n    elseif length(lst) == 0\n        return\
    \ nothing, nothing\n    elseif all(isnothing(el) || el < 0 for el in lst)\n  \
    \      return nothing, nothing\n    elseif all(isnothing(el) || el > 0 for el\
    \ in lst)\n        return nothing, nothing\n    elseif min(lst) < 0\n        smallest\
    \ = min(lst)\n        smallest_idx = lst.index(smallest)\n        return smallest,\
    \ smallest_idx\n    else\n        largest_idx = maximum(lst)\n        largest_val\
    \ = lst[largest_idx]\n        return largest_val, largest_idx\n    end\nend\n\
    </cell>\n<code language=julia-1.5>", "    if lst.empty() \n        return (nothing,\
    \ nothing) \n    if any(lst < 0)\n        return (lst.min(), lst.max()) \n   \
    \ if any(lst > 0)\n        return (nothing, lst.max()) \n    return lst.min(),\
    \ lst.max() \nend\n</cell>\n<text>\nRemember that this code will only work for\
    \ vectors that are not empty.", "    if null lst\n        return (nothing, nothing)\n\
    \    else\n        sorted_list = sort(lst)\n        small = head(sorted_list)\n\
    \        large = last(sorted_list)\n        if small < 0\n            return (small,\
    \ nothing)\n        elseif large > 0\n            return (nothing, large)\n  \
    \      else\n            return (nothing, nothing)\n        end\n    end\nend\n\
    \"\"\"\n    Get the indices of elements in a vector that are in a given set.",
  "    if all(x < 0 for x in lst)\n    else (nothing ,min(x for x in lst))\n    end\n\
    end", "    if isnothing(lst)\n        return ()\n    end\n    \n    pos = filter(x\
    \ -> x < 0, lst)\n    neg = filter(x -> x >= 0, lst)", "    largest = nothing\n\
    \    smallest = nothing\n    for i in lst\n        if i > largest\n          \
    \  largest = i\n        end\n        if i < smallest\n            smallest = i\n\
    \        end\n    end\n    return (largest, smallest)\nend\n</cell>\n<code language=julia-1.0>",
  "    if length(lst) == 0 \n        (a, nothing)\n    elseif all(lst < 0) \n    \
    \    (nothing, 0)\n    else\n        idx = findmax(lst)\n        (idx, idx ==\
    \ length(lst)-1 ? nothing : idx)\n    end\nend", "    if lst == []\n        return\
    \ (nothing, nothing)\n    elseif lst == [nothing]\n        return (nothing,nothing)\n\
    \    else\n        if any(map(lst.>=0, _))\n            return (lst.max,lst.min)\n\
    \        else\n            return (nothing,nothing)\n    end\nend\n</cell>\n<text>\n\
    The next function computes the mean of a vector, ignoring NaN and Inf", "    if\
    \ length(lst) == 0 \n        return (nothing, nothing) \n    else \n        largest_num\
    \ = maximum(lst)\n        smallest_num = minimum(lst)\n        return (largest_num,\
    \ smallest_num)\n    end\nend\n</cell>\n<code language=julia-1.5>\n@testset \"\
    largest_smallest_integers\" begin\n    @test largest_smallest_integers([2, 4,\
    \ 1, 3, 5, 7]) == (nothing, 1)\n    @test largest_smallest_integers([]) == (nothing,\
    \ nothing)\n    @test largest_smallest_integers([0]) == (nothing, nothing)\nend\n\
    </cell>\n<text>\nProblem 7\nA permutation is an ordered arrangement of objects.\
    \ For example, 3124 is one possible permutation of the digits 1, 2, 3 and 4. If\
    \ all of the permutations are listed numerically or alphabetically, we call it\
    \ lexicographic order. The lexicographic permutations of 0, 1 and 2 are:", " \
    \   if any(x < 0 for x in lst)\n        return Nothing, nothing\n    elseif any(x\
    \ > 0 for x in lst)\n        return nothing, nothing\n    else\n        return\
    \ minimum(lst), maximum(lst)\n    end\nend\n</cell>\n<text>\nThe following cell\
    \ contains the implementation of largest_smallest_integers_vector(...). You will\
    \ need to complete this function to return a Vector{Int64}.", "    if length(lst)\
    \ == 0 return (nothing, nothing)\n    smallest_neg = smallest_integer(-x for x\
    \ in lst)\n    if smallest_neg == nothing \n        smallest_neg = lst[1]\n  \
    \  largest_pos = largest_integer(x for x in lst)\n    if largest_pos == nothing\
    \ \n        largest_pos = lst[1]\n    return (smallest_neg, largest_pos)\nend\n\
    </cell>\n<text>\nNext we define our own function that takes a vector of integers\
    \ as input, and returns a vector of tuples representing the largest and smallest\
    \ integers.", "    if length(lst) == 0 return nothing\n    if lst[1] <= lst[0]\
    \ return nothing\n    return (1, lst[1])\nend\n</cell>\n<text>\nNow let's test\
    \ this new function.", "    if isempty(lst) \n        return (nothing, nothing)\n\
    \    largest_value = maximum(lst, Inf)\n    smallest_value = minimum(lst, -Inf)\n\
    \    return (largest_value, smallest_value)\nend", "    if lst.empty()\n     \
    \   return (nothing,nothing)\n    elseif length(lst) == 1\n        return (lst[1],nothing)\n\
    \    elseif maximum(lst) < 0\n        return (nothing, maximum(lst))\n    elseif\
    \ minimum(lst) > 0\n        return (nothing,minimum(lst))\n    else\n        return\
    \ (nothing,nothing)\n    end\nend\n</code>\n<|/ a |>\n<| c |>\nThis code is quite\
    \ inefficient, since it makes a lot of allocations.\n<|/ c |>\n<| a dscore=3 tags=algorithm,julia\
    \ |>\n<code>", "    if any(lst.==0)\n        return nothing, nothing\n    else\
    \ if any(lst.<0)\n        (a,b) = minimum.(lst)\n        return b, a\n    else\n\
    \        (a,b) = maximum.(lst)\n        return a, b \n    end\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=math,max,julia |>\nA little bit different approach\
    \ based on \"minimum value from the array\" approach by Ant\xF3nio Pereira.\n\
    <code>", "    if all(x > 0 for x in lst)\n        (a, b) = (min(lst), max(lst))\n\
    \    else\n        (a, b) = (Nothing, Nothing)\n    end\n    return (a, b)\nend\n\
    </cell>\n<text>\nExercise 5\nRewrite largest_smallest_integers as a function with\
    \ two optional arguments: smallest_first and largest:", "    if sum(filter(x ->\
    \ x < 0, lst)) > sum(filter(x -> x > 0, lst))\n        return nothing, nothing\n\
    \    else\n        return max(filter(x -> x < 0, lst)), min(filter(x -> x > 0,\
    \ lst))\n    end\nend", "    if length(lst) == 0\n        return nothing, nothing\n\
    \    if length(lst) == 1\n        return (lst[1], lst[1])\n    else\n        x\
    \ = maximum.(lst)\n        y = minimum.(lst)\n        return (y, x)\nend", " \
    \   if isnothing(lst) \n        return nothing, nothing\n    end", "    if isempty(lst)\n\
    \        return (nothing, nothing)\n    elseif lst == [0]\n        return (nothing,\
    \ nothing)\n    elseif any(x -> x < 0, lst)\n        return (0, min(lst))\n  \
    \  elseif any(x -> x > 0, lst)\n        return (0, max(lst))\n    else\n     \
    \   return (0, nothing)\n    end\nend\n</cell>\n<code language=julia-0.5>\nlargest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7])\n</cell>\n<code language=julia-0.5>\nlargest_smallest_integers([])\n\
    </cell>\n<code language=julia-0.5>\nlargest_smallest_integers([0])\n</cell>\n\
    <text>\nExercise", "    if all(isnothing(lst))\n        (nothing, nothing)\n \
    \   else\n        (max(Int64, min(lst)), min(lst))\n    end\nend\n</cell>\n<text>\n\
    Recall that a function with signature", "    if any(x <= 0 for x in lst)\n   \
    \     return nothing, nothing\n    end", "    if all(x<0 for x in lst)\n     \
    \   return nothing\n    \n    largest, smallest = nothing\n    largest = minimum(lst)\n\
    \    smallest = maximum(lst)\n    \n    return (largest, smallest)\nend", "  \
    \  if lst.is_empty()\n        return (nothing, nothing)\n    smallest_i = 1\n\
    \    largest_i = #lst\n    if smallest_i == largest_i\n        return (nothing,\
    \ nothing)\n    \n    while smallest_i < largest_i\n        largest_i = (lst .==\
    \ Int64[largest_i]).argmax().toInt\n        smallest_i += 1 \n    end\n    return\
    \ (lst .== Int64[smallest_i]), lst .== Int64[largest_i]\nend\n</cell>\n<code language=julia-1.5>\n\
    largest_smallest_integers([2, 4, 1, 3, 5, 7])\n</cell>\n<text>\nIn Julia, the\
    \ isnothing function can be used to check if a value is a Nothing type. For example,\
    \ we can use the if statement to check if a value is a Nothing type, as follows:",
  "    if lst.length() == 0\n        return (nothing, nothing)\n    elseif length(lst)\
    \ == 1 \n        return (lst[0], nothing)\n    end\n    low = minimum(lst)\n \
    \   high = maximum(lst)\n    return (low, high)\nend\n</code>\n<|/ a tags=function,julia\
    \ dscore=3 |>\n<| a |>\nBased on answer using macro, it is possible to implement\
    \ function like \"isless\" with only 3 lines of code:\n<code>\nisless(x::Vector{Int},\
    \ y::Vector{Int}) = x < y || x == y && x < length(y)", "    if any(x -> x < 0,\
    \ lst)\n        return nothing\n    if any(x -> x > 0, lst)\n        return nothing\n\
    \    a, b = max((elt for elt in lst if elt > 0), default = 0), min((elt for elt\
    \ in lst if elt < 0), default = 0)\n    return a, b\nend\n</code>\n<|/ a |>\n\
    <| a |>\nThe accepted answer by Jorge is good, but in Julia it would be easier\
    \ to do:\n<code>", "    if all(Int.(Int64, x) == x for x in lst)\n        return\
    \ nothing, (min(Int64, x), max(Int64, x))\n    \n    smallest_num = min(Int64,\
    \ lst)\n    largest_num = max(Int64, lst)\n    \n    return (smallest_num, largest_num)\n\
    end", "    if isnothing(lst) || all(isnothing(lst))\n        return nothing, nothing\n\
    \    else\n        return max((x for x in lst if x < 0), nothing => (x for x in\
    \ lst if x > 0))\n    end\nend\n\"\"\"\n    Get the indices of the elements of\
    \ a vector that are greater than a\n    specified value.", "    if any(lst.<(Int64)0)\
    \ == true\n        nothing\n    else\n        if all(lst.>(Int64)0) == true\n\
    \            smallest(lst)\n        else\n            largest(lst)\n        end\n\
    \    end\nend\n</cell>\n<code language=julia-1.0>\n# Task 1\n# Your first task\
    \ is to implement the largest() function which returns the largest element in\
    \ a list.", "    if !all(isfinite(lst))\n        return nothing, nothing\n   \
    \ small, large = Int64, Int64\n    for elt in lst\n        if elt < small\n  \
    \          small = elt\n        elseif elt > large\n            large = elt\n\
    \        end\n    end\n    return (large, small)\nend", "    local max = 0 \n\
    \    local min = Int.max\n    for x in lst\n        if x < min then\n        \
    \    min = x\n        elseif x == max then\n            nothing\n        else\n\
    \            max = x\n        end\n    end\n    return (min, max)\nend", "   \
    \ \"\"\"\n    Create a function that returns a tuple (a, b), where 'a' is\n  \
    \  the largest of negative integers, and 'b' is the smallest\n    of positive\
    \ integers in a vector.\n    If there is no negative or positive integers, return\
    \ them as nothing.\n    \"\"\"\n    if length(lst) == 0\n        return (nothing,\
    \ nothing)\n    largest = nothing\n    smallest = nothing\n    for i in lst\n\
    \        if i < 0\n            if largest == nothing\n                largest\
    \ = -i\n            else\n                if largest < -i\n                  \
    \  largest = -i\n                end\n            end\n        elseif i >= 0\n\
    \            if smallest == nothing\n                smallest = i\n          \
    \  else\n                if smallest > i\n                    smallest = i\n \
    \               end\n            end\n        end\n    end\n    return (largest,\
    \ smallest)\nend\n</code>\n<|/ a tags=julia,math,functional-programming,function\
    \ |>\n<| c |>\n`largest_smallest_integers([0])` yields `(nothing, nothing)` instead\
    \ of `(nothing,nothing)`.\n<|/ c |>\n<| a |>\nHere is one way doing it that might\
    \ not be as efficient as other solutions.\n<code>", "    if is_empty(lst)\n  \
    \      return ()\n    largest = minimum(lst)\n    smallest = maximum(lst)\n  \
    \  return (largest, smallest)\nend\n</code>\n<|/ a dscore=4 tags=julia |>\n<|\
    \ a dscore=4 |>\nYou can get the maximum and minimum of any collection, whether\
    \ it is numbers or ranges, using the following code snippet\n<code>\nmaximum([3,\
    \ 5, 7, 9, 10])\nmaximum(collect(3:10))\nmaximum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\
    maximum(collect(2:10))\n</code>\nand you can get the minimum and maximum of any\
    \ collection, whether it is numbers or ranges, using the following code snippet\n\
    <code>\nminimum([3, 5, 7, 9, 10])\nminimum(collect(3:10))\nminimum([1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9, 10])\nminimum(collect(2:10))\n</code>\nI hope this helps.\n<|/\
    \ a tags=julia |>\n<| c |>\nThe question is asking about `Vector`s, not `Array`s.\n\
    <|/ c |>\n<| a dscore=2 tags=julia |>\nYou can find the minimum and maximum values\
    \ of a vector using max and min:\n<code>\njulia> v=[2,4,1,3,5,7]\n7-element Array{Int64,1}:\n\
    \ 2\n 4\n 1\n 3\n 5\n 7", "    if length(lst.data) == 0 \n        return nothing,\
    \ nothing \n    else \n        max_value = max(lst.data) \n        min_value =\
    \ min(lst.data) \n        if max_value == min_value \n            return nothing,\
    \ nothing \n        else \n            return max_value, min_value \nend\n</cell>\n\
    <text>\nlargest_product", "    if isempty(lst) \n        return (nothing, nothing)\n\
    \    elt = lst[1]\n    if elt < 0 \n        return largest_smallest_integers(lst[2:end-1])\
    \ \n    else \n        return largest_smallest_integers(lst[end-1:end-2]) \nend\n\
    </cell>\n<code language=julia-1.3>\n\"\"\"\n    Given a sorted vector, return\
    \ a pair of integers \n    that represent the largest and smallest of the vector,\n\
    \    respectively. The largest number in the vector will \n    be the index of\
    \ the highest element and the smallest will \n    be the index of the lowest element.\n\
    \    \n    Examples:\n    >>> largest_smallest_integers([2, 4, 1, 3, 5, 7])\n\
    \    (7, 1)\n    >>> largest_smallest_integers([])\n    (nothing,nothing)\n  \
    \  >>> largest_smallest_integers([1])\n    (nothing,nothing)\n    \"\"\"", " \
    \   if lst.empty()\n        return (nothing, nothing)\n    largest_value = min(lst)\n\
    \    smallest_value = max(lst)\n    if smallest_value >= largest_value\n     \
    \   return (nothing, smallest_value)\n    else\n        return (smallest_value,\
    \ nothing)\n    end\nend\n</cell>\n<code language=julia-1.5>\nlargest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7])\n</cell>\n<code language=julia-1.5>\nlargest_smallest_integers([])\n\
    </cell>\n<code language=julia-1.5>\nlargest_smallest_integers([0])\n</cell>\n\
    <code language=julia-1.5>\nlargest_smallest_integers([Int64(0), Int64(1), Int64(2)])\n\
    </cell>\n<text>\n3.5 Exercises", "    if isnothing(lst)\n        return (nothing,\
    \ nothing)\n    else\n        return if all(x < 0 for x in lst)\n            \
    \   else\n                   if all(x > 0 for x in lst)\n                    \
    \   return (lst, 0)\n                   else\n                       return (nothing,\
    \ nothing)\n               end\n    end\nend\n</cell>\n<text>\nFunction to find\
    \ largest number in a given range", "    if isempty(lst)\n        return nothing,\
    \ nothing\n    elseif lst[0] == 0\n        return nothing, nothing\n    else\n\
    \        return (max(lst) - min(lst) + 1, min(lst))\n    end\nend", "    if length(lst)\
    \ < 1\n        (a, b) = (nothing, nothing)\n    elseif all(x < 0 for x in lst)\n\
    \        (a, b) = (nothing,min(lst))\n    else\n        (a, b) = (min(lst), nothing)\n\
    \    end\n    return (a, b)\nend", "    if isempty(lst)\n        return (nothing,\
    \ nothing)\n    elseif all(x < 0 for x in lst)\n        return (nothing, nothing)\n\
    \    else\n        minima = min(lst)\n        maxima = max(lst)\n        return\
    \ (maxima, minima)\n    end\nend", "    if all(x >= 0 for x in lst)\n        (a,\
    \ b) = (max(lst), min(lst))\n    else\n        (a, b) = (nothing, nothing)\n \
    \   end\n    return (a, b)", "    largest, smallest = nothing, nothing\n    for\
    \ x in lst\n        if x >= 0 && (largest == nothing || x > largest)\n       \
    \     largest = x\n        elseif (smallest == nothing || x < smallest)\n    \
    \        smallest = x\n        else\n            return largest, smallest\n  \
    \  end\n    return largest, smallest\nend\n</cell>\n<text>\nLargest integer",
  "    if lst == [] \n        (a, b) = (nothing, nothing) \n    else \n        (a,\
    \ b) = if min(lst) < -Inf \n            (b, nothing) \n            (a, nothing)\
    \ \n            else \n            (a, max(lst)) \n        end \n    end \n  \
    \  return (a, b)\nend ", "    if all(isnothing(lst)); \n        return (nothing,\
    \ nothing)\n    end\n    \n    if all(lst < 0) || all(lst > 0)\n        return\
    \ (nothing,nothing)\n    end", "    if length(lst) <= 0\n        return nothing,\
    \ nothing\n    else\n        largest = minimum(lst)\n        smallest = maximum(lst)\n\
    \        return largest, smallest\n    end\nend", "    if length(lst) == 0\n \
    \       return nothing, nothing\n    (a, b) = max((x for x in lst if x < 0), min((x\
    \ for x in lst if x > 0), key=lambda x: (x > 0, x < 0)))\n    return a, b", " \
    \   \n    for i in eachindex(lst)\n        if lst[i] < 0\n            return nothing\n\
    \        end\n    end", "    if !any(x < 0 for x in lst)\n        return nothing,\
    \ nothing\n    elseif !any(x > 0 for x in lst)\n        return nothing, nothing\n\
    \    else\n        largest_positive = minimum(x for x in lst if x > 0)\n     \
    \   smallest_negative = maximum(lst - largest_positive)\n        return largest_positive,\
    \ smallest_negative\n    end\nend", "    if all(x -> x < 0, lst)\n        return\
    \ (nothing, nothing)\n    else\n        return (maximum(lst), minimum(lst))\n\
    \    end\nend", "    if lst.min() < 0 and lst.max() < 0\n    (a, b) = (nothing)\n\
    \    else if lst.min() >= 0\n        (a, b) = (lst.min(), lst.min())\n    else\n\
    \        (a, b) = (lst.max(), lst.max())\n    end\n    return a, b\nend\n</cell>\n\
    <text>\nThe return statement returns a tuple of two values - the first a union{Int64,\
    \ Nothing} and the second a union{Int64, Nothing}. In order to make life easier\
    \ in the subsequent cells, I have chosen to name these variables $a$ and $b$ (for\
    \ \"largest of negative integers\" and \"smallest of positive integers\").", " \
    \   if all(x == nothing for x in lst)\n        return (nothing, nothing)\n   \
    \ elseif all(x < nothing for x in lst)\n        return (nothing, nothing)\n  \
    \  else\n        return (maximum(lst), minimum(lst))\n    end\nend\n</cell>\n\
    <text>\nExercise 4", "    if !is_sorted(lst)\n        smallest_positive = nothing\n\
    \        largest_negative = nothing\n        for i in lst\n            if i <\
    \ smallest_positive\n                smallest_positive = i\n            elseif\
    \ i > largest_negative\n                largest_negative = i\n            end\n\
    \        end\n        return (smallest_positive, largest_negative)\n    else\n\
    \        return nothing\n    end\nend\n</cell>\n<text>\nExercise: Write a function\
    \ that returns an approximation of the area of a triangle. The input triangle\
    \ consists of 3 points in the form:\n$$\n\\begin{align}\np_1 &= (x, y)\\\\\np_2\
    \ &= (x + a, y + b)\\\\\np_3 &= (x + a, y + b)\n\\end{align}\n$$\nwhere $a \\\
    approx b$, $b > a$ and $x,y \\in \\mathbb{R}^+$. This function should take an\
    \ $a$ and $a$ and return the area of the triangle:\n$$\n\\begin{align}\na &= (x\
    \ - p_1)(y - p_2) \\\\\n&= (x - p_1)(p_2 - p_3)\n\\end{align}\n$$\nwhere $p_1$,\
    \ $p_2$ and $p_3$ are known. The area is defined as:\n$$\n\\begin{align}\nA =\
    \ (x2 - x1)(y2 + y1) - x2(y1 + y2)\n\\end{align}\n$$\nThe first term is the area\
    \ of the $x$ axis.\nThe second term is the area of the $y$ axis.", "    if length(lst)\
    \ == 0\n        return ()\n    else\n        largest = minimum(lst)\n        smallest\
    \ = maximum(lst)\n        return (largest, smallest)\n    end\nend\n</cell>\n\
    <code language=julia-1.6>", "    (a, b) = if any(x < 0 for x in lst)\n       \
    \         (a, b) = nothing\n                else\n                    (x, max(x-1,\
    \ 0), min(x+1, length(lst))) for x in lst\n    end\n    (a, b)\nend\n</cell>\n\
    <text>\nNow we can write a function that takes a function and a vector of integers,\
    \ and returns another function which will take a vector and return the result\
    \ of applying the function to each integer in the vector.", "    if Vector{Int64}(lst)\
    \ == Int64[]\n        return (nothing, nothing)\n    elseif Vector{Int64}(lst)\
    \ == Vector{Int64}[]\n        largest_value = Int64(minimum(map(Int, lst)))\n\
    \        smallest_value = Int64(maximum(map(Int, lst)))\n        return (largest_value,\
    \ smallest_value)\n    end\n    largest_value = Int64(minimum(map(Int, lst)))\n\
    \    smallest_value = Int64(maximum(map(Int, lst)))\n    return (largest_value,\
    \ smallest_value)\nend\n</cell>\n<code language=julia-1.5>\n@code_warntype largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7])\n</cell>\n<code language=julia-1.5>\n@code_warntype largest_smallest_integers([])\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype largest_smallest_integers([0])\n\
    </cell>\n<text>\n3.4.5 maximum and minimum", "    if !lst.is_sorted()\n      \
    \  error(\"The list must be sorted\")\n    end\n    \n    smallest_idx = 1\n \
    \   largest_idx = 1\n    \n    for idx in 2:length(lst)-1\n        if lst[idx]\
    \ >= lst[smallest_idx]\n            smallest_idx = idx\n        elseif lst[idx]\
    \ <= lst[largest_idx]\n            largest_idx = idx\n        else\n         \
    \   return (lst[smallest_idx], lst[largest_idx])\n        end\n    end\n    return\
    \ (nothing, nothing)\nend\n</cell>\n<text>\nFind the largest and smallest values\
    \ in a vector\nLet's now implement a function that returns two values, the largest\
    \ and smallest values in a given vector.", "    if !all(Int64, lst) == nothing\n\
    \        largest = nothing\n        smallest = nothing\n        for i in lst\n\
    \            if i < 0 && largest == nothing\n                largest = i\n   \
    \         elseif i > 0 && smallest == nothing\n                smallest = i\n\
    \            else\n                if largest < i\n                    largest\
    \ = i\n                elseif smallest > i\n                    smallest = i\n\
    \                end\n            end\n        end\n        return (largest, smallest)\n\
    \    else\n        return (nothing, nothing)\n    end\nend", "    if lst == []\
    \ \n        (a, b) = (Nothing, Nothing) \n    else \n        (a, b) = sort(lst)\
    \ \n        (a, b) = (if a<0 \n                   b\n                   a\n  \
    \               end, \n                 if a>0 \n                   a\n      \
    \             b\n                 end)\n    end \nend \n</cell>\n<code language=julia-1.0>\n\
    # Checkpoint\n\"\"\"\n    Create an array of integers between 0 and 10.\n    Your\
    \ output should look like this: \n    [0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4,\
    \ 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9]\n\"\"\"", "    if\
    \ is_empty(lst)\n        return (nothing, nothing)\n    if is_empty(lst[1]) ||\
    \ is_empty(lst[2])\n        return (nothing, nothing)\n    elseif length(lst)\
    \ > length(lst[1])\n        (largest_i, smallest_i) = (lst[1], lst[2])\n    else\n\
    \        (largest_i, smallest_i) = (lst[2], lst[1])\n    end\n    (largest_x,\
    \ smallest_x) = largest_smallest_integers([largest_i, smallest_i])\n    (largest_y,\
    \ smallest_y) = largest_smallest_integers([largest_x, smallest_i])\n    (largest_z,\
    \ smallest_z) = largest_smallest_integers([largest_y, smallest_i])\n    (largest_i,\
    \ smallest_i) = (largest_i, smallest_i)\n    (largest_x, smallest_x) = (largest_x,\
    \ smallest_x)\n    (largest_y, smallest_y) = (largest_y, smallest_y)\n    (largest_z,\
    \ smallest_z) = (largest_z, smallest_z)\n    \n    i = Int64(min(largest_i, smallest_i))\n\
    \    x = Int64(min(largest_x, smallest_x))\n    y = Int64(min(largest_y, smallest_y))\n\
    \    z = Int64(min(largest_z, smallest_z))\n    return (i, x)\nend\n</cell>\n\
    <text>\n\u270C\uFE0F What is the largest integer among the integers given by the\
    \ following list of integers?", "    lst = sort(lst)\n    return Tuple{Union{Int64,\
    \ Nothing}, Union{Int64, Nothing}}(nothing,nothing) \n    for x in lst\n     \
    \   if x < 0\n            return (x, nothing)\n        else if x==0\n        \
    \    return (nothing, x)\n        end\n    end\nend\n</cell>\n<text>\nProblem\
    \ 3\nWrite a function that returns the unique elements of a vector", "    if isnothing(lst)\n\
    \        return nothing, nothing\n    elseif length(lst) == 0\n        return\
    \ nothing, nothing\n    elseif lst.min < 0\n        return nothing, nothing\n\
    \    end\n    i = Int64(lst.min)\n    j = Int64(lst.max)\n    while true\n   \
    \     tmp = lst[i]\n        if tmp < i\n            if j < i\n               \
    \ j = tmp\n            else\n                return i, j\n            end\n  \
    \      elseif tmp > j\n            if i < j\n                i = tmp\n       \
    \     else\n                return i, j\n            end\n        else\n     \
    \       break\n        end\n    end\nend\n</cell>\n<code language=julia-1.1>\n\
    largest_smallest_integers(lst)\n</cell>\n<code language=julia-1.1>", "       \
    \ if lst.length == 1\n        then return (nothing, lst[1])\n        elseif lst.length\
    \ == 0\n        then return (nothing, nothing)\n        else\n            a =\
    \ maximum((x for x in lst if x < 0))\n            b = minimum((x for x in lst\
    \ if x >= 0))\n            return (sort(a, b), sort(b, a))\n        end\nend\n\
    </code>\n<|/ a |>\n<| a dscore=0 tags=julia |>\nI think the fastest solution is\
    \ to use findmax on vector of numbers:\n<code>\nusing StatsBase\nusing BenchmarkTools",
  "    if length(lst) == 0\n        return (nothing, nothing)\n    end\n    if sort(lst)\
    \ == sort(reverse(lst))\n        return (nothing, rev(lst))[1]\n    end\n    return\
    \ (maximum(lst) - minimum(lst), minimum(lst))\nend", "    if !isscalar(lst)\n\
    \        return nothing\n    end\n    if lst.min() > 0 && lst.max() < 0\n    \
    \    return lst, nothing\n    elseif lst.max() > 0 && lst.min() < 0\n        return\
    \ nothing, lst \n    end\n    largest = max(lst, lt=ltmaxint)\n    smallest =\
    \ min(lst, lt=ltmaxint)\n    return largest, smallest\nend", "    if lst == []\n\
    \        return (nothing, nothing)\n    if min(lst) < 0\n        return (nothing,\
    \ nothing)\n    if max(lst) > 0\n        return (min(lst), max(lst))\n    largest\
    \ = minimum(lst)\n    smallest = maximum(lst)\n    if largest < 0\n        return\
    \ (largest, nothing)\n    if smallest > 0\n        return (nothing, smallest)\n\
    \    return (nothing, nothing)\nend", "    if isnothing(lst) || isempty(lst) \n\
    \        nothing\n    else\n        if all(x -> x < 0, lst)\n            nothing\n\
    \        else\n            if all(x -> x > 0, lst)\n                (min(lst),\
    \ max(lst))\n            else\n                nothing\n        end\n    end\n\
    end", "    if length(lst) == 0 return (nothing, nothing)\n    \n    largest, smallest\
    \ =lst[1], lst[1]\n    for elem in lst[2:end]\n        if elem > largest then\
    \ largest = elem end\n        if elem < smallest then smallest = elem end\n  \
    \  end\n    (largest, smallest)\nend\n</cell>\n<code language=julia-1.5>\nlargest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7])\n</cell>\n<text>\nExercise 4: Largest and smallest numbers\n\
    Write a function that returns the first n items of a vector in sorted order. You\
    \ should use the function largest_smallest_integers, and also a conditional to\
    \ check if the first n items of the vector are positive.", "    if lst.is_empty\n\
    \        return ()\n    smallest = nothing\n    largest = nothing\n    for i in\
    \ lst\n        if i < 0\n            if smallest != nothing\n                largest\
    \ = i\n            else\n                smallest = i\n        elseif i > largest\n\
    \            largest = i\n        end\n    end\n    return (smallest, largest)\n\
    end\n</cell>\n<text>\nTo get started with Julia, make sure you have at least version\
    \ 0.5.0, the latest release at the time of this writing. You can run the following\
    \ cell to update your julia installation:", "    if length(lst.filter(x->x >=0\
    \ )) == 0 \n    then (nothing, nothing) \n    else (max(lst.filter(x->x >=0 )),\
    \ min(lst.filter(x->x >=0 )))\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nWhat\
    \ are `largest_smallest_integers(lst::Vector{Int64})` and `largest_smallest_integers(lst::Vector{Int})`\
    \ supposed to do? And why are they not `largest_smallest_integers(lst::Vector{Int})`?\n\
    <|/ c |>\n<| c |>\nThe `Vector{Int}` example was a typo. Corrected now. It should\
    \ have been `Vector{Int64}`. Thank you.\n<|/ c |>\n<| a |>\nThere are many answers\
    \ already. Just another one that is less efficient, but might help someone looking\
    \ for an alternative to ismember function:\n<code>\njulia> using DataStructures",
  "    if isempty(lst)\n        return (nothing, nothing)\n    end\n    first, rest\
    \ = firstn(lst, 2)\n    if second >= first\n        return (first, second)\n \
    \   elseif second < first\n        return nothing\n    else\n        return (nothing,\
    \ first)\n    end\nend\n</cell>\n<code language=julia-1.5>\nusing StatsBase\n\
    </cell>\n<code language=julia-1.5>", "    if all(x >= 0 for x in lst)\n      \
    \  (a, min_) = sort(lst)\n        return (a, min_)\n    (a, b) = (nothing, nothing)\n\
    \    if length(lst) == 0\n        return (a, b)\n    if length(lst) == 1\n   \
    \     if lst[0] == 0\n            return (a, b)\n        else\n            return\
    \ (b, a)\n    end", "    largest = nothing\n    smallest = nothing\n    for el\
    \ in lst\n        if el < 0\n            if smallest == nothing\n            \
    \    largest = el\n                smallest = el\n            else\n         \
    \       largest = max(largest, el)\n                smallest = min(smallest, el)\n\
    \        else smallest = nothing\n    end\n    return largest, smallest\nend "]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
