language: jl
name: HumanEval_49_modp
results:
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 || p == 0 || n == p || n < 0 || p < 0\n   \
    \     throw(DomainError(\"modp requires the parameters to be positive\"))\n  \
    \  else\n        if n == 1\n            1\n        else\n            modp(n div\
    \ 2, p) * (p % 2)\nend\n</cell>\n<text>\nQ. How many integer factors of $x$ are\
    \ less than $x$?\n Write your answer as a function below.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5hjmti9o.jl:20\nin expression starting at\
    \ /tmp/tmp5hjmti9o.jl:20\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == p then \n        1\n    else if n < p then\n\
    \        modp(divrem(n, p, p), p)\n    else\n        modp(divrem(p, n, n), p)\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Return x with y digits\
    \ after the decimal point.\n    >>> myround(3.141592)\n    3.142\n    >>> myround(3.141592,\
    \ 2)\n    3.14\n    >>> myround(3.141592, 3)\n    3.142\n    >>> myround(3.141592,\
    \ 4)\n    3.1416\n\"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t\
    @test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphmxxtvs6.jl:16\nin expression starting at\
    \ /tmp/tmphmxxtvs6.jl:16\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 1\n        1\n    elseif p == 2\n        n\n\
    \    elseif p < 2\n        modp(div(n, p), p) \n    else\n        modp(div(n,\
    \ p), modp(div(n, p), p))\nend\n</cell>\n<code language=julia-1.6>\nusing Test\n\
    \n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpughqixyk.jl:23\nin expression starting at\
    \ /tmp/tmpughqixyk.jl:23\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0 \n        then throw(ZeroDivisionError(\"integer\
    \ division or modulo by zero\"))\n    else if n == 0\n        then 1\n       \
    \ else n / p\n    end\nend\n\"\"\"\nModulo p (be aware of numerics).\nReturn n\
    \ % p. \n\"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"throw\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpzhin94po.jl:15\nin expression starting at /tmp/tmpzhin94po.jl:15\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0 return 0 \n    if n>=p return p\n    mult =\
    \ 1\n    i = p\n    while i & 1 do \n        mult = mult*(n-i) \n        i /=\
    \ 2\n    return mult\n\"\"\"\n<|/ file source=github |>\n<| a |>\nFor large numbers\
    \ you will need to use BigInt. Unfortunately this is not available for Julia 1.0\
    \ so you will need to switch to Julia 0.7.\nHere is how you do it with Julia 0.7:\n\
    <code>\njulia> using BigInt\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp4t9ip2jl.jl:18\nin expression starting at /tmp/tmp4t9ip2jl.jl:18\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    \"\"\"\nReturn the remainder of n modulo p.\n    \"\"\
    \"\n    return n%p\n\"\"\"\n### END HIDDEN CODE\n# END HIDDEN CODE\n\"\"\"\n###\
    \ BEGIN HIDDEN CODE\n# BEGIN HIDDEN CODE\n\"\"\"\nReturn p^n modulo p (be aware\
    \ of numerics).\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n>>> modp(0, 101)\n\
    1\n>>> modp(3, 11)\n8\n>>> modp(100, 101)\n1\n\"\"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpz8vi_3lh.jl:13\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpz8vi_3lh.jl:1\n\
    in expression starting at /tmp/tmpz8vi_3lh.jl:1\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0\n        return -1\n    return p % n\nend \n\
    </cell>\n<code language=julia-1.0>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjjnn6n4p.jl:18\nin expression starting at\
    \ /tmp/tmpjjnn6n4p.jl:18\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    |n>p && (n%p)==0\n    else 0\n    end\n</code>\n<|/ a\
    \ tags=julia,mod,performance |>\n<| a |>\nIn Julia 1.5 you can use Base.mod:\n\
    <code>\njulia> mod(1001, 101)\n1\n</code>\n<|/ a dscore=5 tags=julia,mod,performance\
    \ |>\n<| a tags=julia,mod,performance |>\nIn Julia 1.5 Base.mod has been added\
    \ as a function:\n<code>\njulia> Base.mod(1001, 101)\n1\n</code>\n<|/ a dscore=4\
    \ |>\n<| a |>\nIf your \"numbers\" are big, you may want to use Julia's BitArray\
    \ instead of Int64:\n<code>\njulia> using BitArray\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"|\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7g6c0ui_.jl:14\nin expression starting at\
    \ /tmp/tmp7g6c0ui_.jl:14\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    # Write your solution here\n    return 2^n%(p)\nend\n\
    </cell>\n<code language=julia-0.6>\n@test modp(8, 10)\n@test modp(100, 10)\n@test\
    \ modp(1000, 10)\n@test modp(10000, 10)\n@test modp(100000, 10)\n</cell>\n<code\
    \ language=julia-0.6>\n\"\"\"Return 2^(n//p) modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3svnimto.jl:17\nin expression starting at\
    \ /tmp/tmp3svnimto.jl:17\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    modnum = ((p) *((p) * (n - 1)) % p)\n    return (modnum\
    \ % p) \nend\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 7 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpsgyk26je.jl:19

    '
  stdout: "test set: Test Failed at /tmp/tmpsgyk26je.jl:22\n  Expression: candidate(3,\
    \ 5) == 3\n   Evaluated: 0 == 3\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpsgyk26je.jl:22 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpsgyk26je.jl:21\ntest set: Test\
    \ Failed at /tmp/tmpsgyk26je.jl:23\n  Expression: candidate(1101, 101) == 2\n\
    \   Evaluated: 0 == 2\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpsgyk26je.jl:23 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpsgyk26je.jl:21\ntest set: Test\
    \ Failed at /tmp/tmpsgyk26je.jl:24\n  Expression: candidate(0, 101) == 1\n   Evaluated:\
    \ 0 == 1\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpsgyk26je.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpsgyk26je.jl:21\ntest set: Test\
    \ Failed at /tmp/tmpsgyk26je.jl:25\n  Expression: candidate(3, 11) == 8\n   Evaluated:\
    \ 0 == 8\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpsgyk26je.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpsgyk26je.jl:21\ntest set: Test\
    \ Failed at /tmp/tmpsgyk26je.jl:26\n  Expression: candidate(100, 101) == 1\n \
    \  Evaluated: 0 == 1\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpsgyk26je.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @"
  timestamp: 1660009102
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p < 2 \n       return 0\n    return ((n - 1) * (n\
    \ - 2)) % (p - 1)\nend\n</cell>\n<text>\nLet's try a larger example:\nusing Test\n\
    \n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8ot9io7c.jl:18\nin expression starting at\
    \ /tmp/tmp8ot9io7c.jl:18\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n\tif n < p \n\t\tthen return n \n\t\telse \n\t\t    return\
    \ modp(n-p, p)\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpv1gkwvn_.jl:15\nin expression starting at /tmp/tmpv1gkwvn_.jl:15\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    |0> = p mod n\n    |1> = n - p\n    return 0>\n    end\n\
    \"\"\"\nReturn p^e modulo p.\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n\
    \    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100,\
    \ 101)\n    1\n\"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"|\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpajlhaw6t.jl:14\nin expression starting at\
    \ /tmp/tmpajlhaw6t.jl:14\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 then return 0 \n    else if n == 0 then return\
    \ p\n    else if p < 0 then return modp(-n, p) \n    else if n <= p then return\
    \ modp(n - p, p) \n    else return modp(n, p % n)\nend \n</code>\nIt works for\
    \ any n, as long as it's positive.\n<|/ a tags=math,recursion,mod,julia |>\n<|\
    \ c |>\nAs of julia 0.7 this will be in the stdlib `Base.mod(x::AbstractFloat,\
    \ modulus)`, but yeah this is more efficient.\n<|/ c |>\n<| c |>\nThanks for the\
    \ update and the solution. Just a quick question though: what is the reason behind\
    \ it returning the result as a `Int64` and not a regular `Int`? In other words,\
    \ why do I need to explicitly convert the result back to a `Int`?\n<|/ c |>\n\
    <| c |>\nBecause the result is going to be an `Int64` because that's what the\
    \ modulus is. It's a way to make it more efficient than `mod(x, modulus)` because\
    \ it doesn't have to do all the division work (it still does `div(modulus)` and\
    \ then truncates it).\n<|/ c |>\n<| c |>\nOh! I see. Thanks again!\n<|/ c |>\n\
    <| c |>\nIn Julia 1.0 you can just do `mod(x, modulus)`\n<|/ c |>\n<| a |>\nThe\
    \ way I did this was:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp66o0s1kn.jl:14\nin expression starting at /tmp/tmp66o0s1kn.jl:14\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0\n        error(\"modp: negative argument\")\n\
    \    if n == 0\n        error(\"modp: division by zero\")\n    if p == 0\n   \
    \     error(\"modp: division by zero\")\n    if n % p == 0\n        return n\n\
    \    return n % p\n\"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpx3sel7wm.jl:1\nin expression starting at /tmp/tmpx3sel7wm.jl:1\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if n <= p\
    \ \n        then return modp(n - 1, p) + 1 \n    else \n        modp(n - 1, p)\
    \ \nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThank you, I was trying to figure\
    \ out why my code didn't work and I guess I forgot I needed a base case for my\
    \ recursive function.\n<|/ c |>\n<| c |>\nThis works, but it doesn't do what you\
    \ described. The `else` clause returns `modp(n - 1, p) + 1`, which is wrong.\n\
    <|/ c |>\n<| a tags=julia |>\nYour base case is wrong. It should be:\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp4wmjnn4r.jl:15\nin expression starting at /tmp/tmp4wmjnn4r.jl:15\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0\n        0\n    elseif n == 1\n        p\n\
    \    elseif p <= 0\n        modp(n - 1, p + 1)\n    else\n        modp(n - 1,\
    \ p * 2 % p)\n    end\nend\n</code>\nAnd now the main function for the rest of\
    \ the exercise:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t\
    @test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp26dm59sx.jl:24\nin expression starting at\
    \ /tmp/tmp26dm59sx.jl:24\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0\n        error(\"n must be positive\")\n   \
    \ else if p == 0\n        error(\"p must be non-zero\")\n    else if n < 0\n \
    \       error(\"n must be positive\")\n    else if p <= 0\n        error(\"p must\
    \ be positive\")\n    else if p <= 0\n        error(\"p must be positive\")\n\
    \    else if n < 0\n        error(\"n must be positive\")\n    else if p == 0\n\
    \        error(\"p must be non-zero\")\n    else if n == 0\n        error(\"n\
    \ must be non-zero\")\n    else if n < p\n        error(\"n must be positive\"\
    )\n    else if n == 0\n        error(\"n must be non-zero\")\n    else if p <=\
    \ 0\n        error(\"p must be positive\")\n    else if p == 0\n        error(\"\
    p must be non-zero\")\n    else if n == 0\n        error(\"n must be non-zero\"\
    )\n    else if p == 0\n        error(\"p must be non-zero\")\n    else if p >\
    \ 0\n        error(\"p must be positive\")\n    else if n == 0\n        error(\"\
    n must be non-zero\")\n    else if n < p\n        error(\"n must be positive\"\
    )\n    else if n == 0\n        error(\"n must be non-zero\")\n    else if p <\
    \ 0\n        error(\"p must be positive\")\n    else if n == 0\n        error(\"\
    n must be non-zero\")\n    else if n < p\n        error(\"n must be positive\"\
    )\n    else if n == 0\n        error(\"n must be non-zero\")\n    else if p <\
    \ 0\n        error(\"p must be positive\")\n    else if n == 0\n        error(\"\
    n must be non-zero\")\n    else if n < p\n        error(\"n must be positive\"\
    )\n    else if n == 0\n        error(\"n must be non-zero\")\n    else if p <\
    \ 0\n        error(\"p must be positive\")\n    else if n == 0\n        error(\"\
    n must be non-zero\")\n    else if n < p\n        error(\"n must be positive\"\
    )\n    else if n == 0\n        error(\"n must be non-zero\")\n    else if p <\
    \ 0\n        error(\"p must be positive\")\n    else if n == 0\n        error(\"\
    n must be non-zero\")\n    else if n < p\n        error(\"n must be positive\"\
    )\n    else if n == 0\n        error(\"n must be non-zero\")\n    else if p <\
    \ 0\n        error(\"p must be positive\")\n    else if n == 0\n        error(\"\
    n must be non-zero\")\n    else if n < p\n        error(\"n must be positive\"\
    )\n    else if n == 0\n        \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyj58vrc4.jl:16\nin expression starting at\
    \ /tmp/tmpyj58vrc4.jl:16\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if n <= p then return 1\n    \n    let div, mod = divmod((p * p + 7) / 3,\
    \ n)\n    if mod == 0 then return n % (p * p / 3)\n    if mod > 0 then\n     \
    \   return n % ((p * p + 7) / 3)\n    else\n        return n % ((p * p - 7) /\
    \ 3)\nend\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp5v7as05n.jl:14\nin expression starting at /tmp/tmp5v7as05n.jl:14\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    | n < 0\n    = 1\n    | n < p\n    = n\n    | n >= p\n\
    \    = modp(n / p, p)\n    | otherwise\n    = modp(n / p, p) * p + n\nend\n</cell>\n\
    <text>\nThe definition of the mod2 function can be found here:\nusing Test\n\n\
    @testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"|\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp61aav3n.jl:14\nin expression starting at\
    \ /tmp/tmpp61aav3n.jl:14\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    modind = if n <= p then 1 else mod(n-p, p-1)\n    return\
    \ modind\nend function \n\"\"\"\nmodp(n::Int64, p::Int64)::Int64 = ifelse(n <=\
    \ p, 1, mod(n-p, p-1))\n</cell>\n<code language=julia-1.0>\n\"\"\"\nGiven a number\
    \ n and a prime p, compute all integers p > n\nsuch that p^n mod p = 1.\n\"\"\"\
    \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"1\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp5_zrzon6.jl:14\nin expression starting at /tmp/tmp5_zrzon6.jl:14\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < p then return n \n    return n % p\nusing Test\n\
    \n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpcslfz1ju.jl:14\nin expression starting at /tmp/tmpcslfz1ju.jl:14\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    \n    if n < 0 \n    then return 0 \n    else if n %\
    \ p == 0 \n    then return p \n    else \n        return modp(n/p, p) \n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5)\
    \ == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpm3q2vhsd.jl:16\nin expression starting at /tmp/tmpm3q2vhsd.jl:16\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        return 0 \n    else if (p < 1) \n\
    \        error \"p must be positive\" \n    else \n        return ((n % p) + p)\
    \ % p \n    end\nend\n</cell>\n<code language=julia-1.1>\n\"\"\"Return the factorial\
    \ of the number n.\n    >>> factorial(5)\n    120\n    >>> factorial(0)\n    1\n\
    \    >>> factorial(10)\n    3628800\n    >>> factorial(10)^5\n    3628800\n  \
    \  >>> factorial(7)\n    14\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbucsi2v7.jl:16\nin expression starting at\
    \ /tmp/tmpbucsi2v7.jl:16\n"
  stdout: ''
  timestamp: 1660009103
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 0\n    else if n % p\
    \ == 0 \n        then return n // p\n        else return modp(n // p, p)\n   \
    \ end\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nHere's a solution that\
    \ is pretty similar to one I wrote. The only difference is that I rewrote it using\
    \ recursion (as I find recursion more natural for this sort of problem) and I\
    \ included some extra features like error handling and a test to ensure a positive\
    \ integer is input. \n<code>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpvop858rc.jl:15\nin expression starting at /tmp/tmpvop858rc.jl:15\n"
  stdout: ''
  timestamp: 1660009103
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        { return p }\n    else if p == 0\
    \ \n        { return 0 }\n    else if p == 1 \n        { return 1 }\n    else\
    \ \n        { return n % p }\nend\n</cell>\n<code language=julia-1.0>\nusing Test\n\
    \n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpv9barn2j.jl:16\nin expression starting at\
    \ /tmp/tmpv9barn2j.jl:16\n"
  stdout: ''
  timestamp: 1660009103
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0 \n        then error(\"n must be positive\"\
    )\n    else if p <= 0 \n        then error(\"p must be positive\")\n    else if\
    \ p >= n \n        then error(\"p must be smaller than n\")\n    else if n < 0\
    \ \n        then error(\"n must be positive\")\n    else if p == 1 \n        then\
    \ error(\"p is 1\")\n    else if n == 0 \n        then error(\"n is 0\")\n   \
    \ else if p == 0 \n        then error(\"p is 0\")\n    else if n == 1\n      \
    \  then return 1\n    else if n == p\n        then return 1\n    else if n >=\
    \ p\n        then if n > p\n            then return n % p\n            else return\
    \ p % n\n        else if n < p\n            then return p % n\n            else\
    \ return n % p\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"error\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpk5uta5ui.jl:15\nin expression starting at /tmp/tmpk5uta5ui.jl:15\n"
  stdout: ''
  timestamp: 1660009103
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if (n > p) then modp(n, p) else 1\n</code>\nmodp(100,\
    \ 101)\n<code>\n101 // 100 = 5 => return 5\n</code>\nmodp(3, 11)\n<code>\n11 //\
    \ 3 = 1 => return 1\n</code>\nmodp(1101, 101)\n<code>\n101 // 1101 = 2 => return\
    \ 2\n</code>\nmodp(3, 53)\n<code>\n53 // 3 = 0\n</code>\nmodp(1101, 100)\n<code>\n\
    100 // 1101 = 2 => return 2\n</code>\nmodp(3, 53)\n<code>\n53 // 3 = 1 => return\
    \ 1\n</code>\nmodp(1101, 100)\n<code>\n100 // 1101 = 1 => return 1\n</code>\n\
    modp(3, 53)\n<code>\n53 // 3 = 1 => return 1\n</code>\nmodp(1101, 100)\n<code>\n\
    100 // 1101 = 1 => return 1\n</code>\nmodp(3, 53)\n<code>\n53 // 3 = 1 => return\
    \ 1\n</code>\nmodp(1101, 100)\n<code>\n100 // 1101 = 1 => return 1\n</code>\n\
    modp(3, 53)\n<code>\n53 // 3 = 1 => return 1\n</code>\nmodp(1101, 100)\n<code>\n\
    100 // 1101 = 1 => return 1\n</code>\nmodp(3, 53)\n<code>\n53 // 3 = 1 => return\
    \ 1\n</code>\nmodp(1101, 100)\n<code>\n100 // 1101 = 1 => return 1\n</code>\n\
    modp(3, 53)\n<code>\n53 // 3 = 1 => return 1\n</code>\nmodp(1101, 100)\n<code>\n\
    100 // 1101 = 1 => return 1\n</code>\nmodp(3, 53)\n<code>\n53 // 3 = 1 => return\
    \ 1\n</code>\nmodp(1101, 100)\n<code>\n100 // 1101 = 1 => return 1\n</code>\n\
    modp(3, 53)\n<code>\n53 // 3 = 1 => return 1\n</code>\nmodp(1101, 100)\n<code>\n\
    100 // 1101 = 1 => return 1\n</code>\nmodp(3, 53)\n<code>\n53 // 3 = 1 => return\
    \ 1\n</code>\nmodp(1101, 100)\n<code>\n100 // 1101 = 1 => return 1\n</code>\n\
    modp(3, 53)\n<code>\n53 // 3 = 1 => return 1\n</code>\nmodp(1101, 100)\n<code>\n\
    100 // 1101 = 1 => return 1\n</code>\nmodp(3, 53)\n<code>\n53 // 3 = 1 => return\
    \ 1\n</code>\nmodp(1101, 100)\n\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"modp\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpf6l7cihn.jl:14\nin expression starting at /tmp/tmpf6l7cihn.jl:14\n"
  stdout: ''
  timestamp: 1660009103
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n        n >= 0 ? p : n % p\n    else\n  \
    \      modp(n / p, p)\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=2 tags=julia\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgjjdc08k.jl:19\nin expression starting at\
    \ /tmp/tmpgjjdc08k.jl:19\n"
  stdout: ''
  timestamp: 1660009103
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= p || n < 0 || p < 0\n        error(\"modp($n,\
    \ $p) bad args\")\n    elseif n < 1\n        return n\n    else if n % p == 0\n\
    \        return p\n    else\n        return n % p\nend\n</cell>\n<text>\nLarge\
    \ primes\nNow we define primes using this simple algorithm\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0b8lar8y.jl:18\nin expression starting at\
    \ /tmp/tmp0b8lar8y.jl:18\n"
  stdout: ''
  timestamp: 1660009103
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>>\
    \ modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n  \
    \  1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp4ymb7iwm.jl:13\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp4ymb7iwm.jl:1\n\
    in expression starting at /tmp/tmp4ymb7iwm.jl:1\n"
  stdout: ''
  timestamp: 1660009103
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0\n        then return p\n    else if n==1\n  \
    \      then return 1\n    else \n        if p==0\n            then return 0\n\
    \        elif n==p\n            then return 1\n        else return modp(n-1, p)\
    \ % p\n    end\nend\n</code>\n<|/ a dscore=2 tags=julia |>\n<| a dscore=2 |>\n\
    The question asks about \"modular\" exponentiation (where n is always positive),\
    \ but the answer provided is \"non-modular\" exponentiation (where n is always\
    \ negative).\nAs a general algorithm for modular exponentiation in Julia, see\
    \ the Wikipedia article Modular exponentiation, and see the Wikipedia article\
    \ Non-modular exponentiation.  Julia's BigInteger package has both algorithms.\n\
    In Julia, the BigInt package has a function modpow() that performs a modular exponentiation,\
    \ but unfortunately the function only works for positive exponents.\n<|/ a tags=julia\
    \ |>\n<| a |>\nA similar recursive function that would work on both positive and\
    \ negative exponents.\n<code>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp4r3qk1hf.jl:15\nin expression starting at /tmp/tmp4r3qk1hf.jl:15\n"
  stdout: ''
  timestamp: 1660009103
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n % p != 0 \n        then return n % p \n        else\
    \ return modp(n/p, p)\n    end\nend\n</code>\n<|/ a tags=math,julia dscore=4 |>\n\
    <| c |>\nWhat do you mean? I used the definition of modp that says \"return n\
    \ mod p\", which is modulo division.\n<|/ c |>\n<| c |>\nI think you're mixing\
    \ up modulo and division. In `modp(1101, 101)` 1101 is not divisible by 101, so\
    \ 1101 isn't divisible by any number in [101, 101, 101, ..., 101] (the second\
    \ argument). `modp` returns the remainder of the division.\n<|/ c |>\n<| c |>\n\
    Ah, thank you. I was so focused on the definition of modp that I overlooked the\
    \ fact that 1101 % 101 = 9. Still, I'll try to figure out how to implement the\
    \ modular inverse then.\n<|/ c |>\n<| a dscore=3 |>\nThis has already been answered,\
    \ but I thought I would post an answer to this old thread anyway for completeness.\n\
    The package https://github.com/leibom/mod_inverse.jl is a Julia package providing\
    \ the algorithm that OP was interested in.\nHere's an example of how to use it:\n\
    <code>\njulia> using ModInverse\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpcu8dehrw.jl:15\nin expression starting at /tmp/tmpcu8dehrw.jl:15\n"
  stdout: ''
  timestamp: 1660009103
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n<0\n        error(\"modp: negative number\")\n  \
    \  else if n==0\n        1\n    else if n>p\n        error(\"modp: too large number\"\
    )\n    else\n        modp(n - 1, p) % p\nend\n</cell>\n<code language=julia-0.5>\n\
    \"\"\"Return nth prime number for given p and n.\"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_6m0upff.jl:16\nin expression starting at\
    \ /tmp/tmp_6m0upff.jl:16\n"
  stdout: ''
  timestamp: 1660009103
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 0\n    else if n%p \n\
    \        then return modp(floor(n/p), p)\n        else return modp(n/p, p)\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpxmkgjz8y.jl:15\nin expression starting at /tmp/tmpxmkgjz8y.jl:15\n"
  stdout: ''
  timestamp: 1660009103
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 or n >= p then return n\n    else if n == 0\
    \ then return 0\n    else if n % p == 0 then return n\n    else return modp(n\
    \ / p, p)\nend\n</cell>\n<code language=julia-0.6>\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"n\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpn__4t6zc.jl:14\nin expression starting at /tmp/tmpn__4t6zc.jl:14\n"
  stdout: ''
  timestamp: 1660009103
- exit_code: -1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p % n == 0\n        return p % n\n    else\n     \
    \   return modp(n, p % n)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660009106
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= p \n        then n \n    else if p < 0 \n   \
    \     then 0 else n % p\n    end \nend\n\"\"\"Return n modulo p where n is an\
    \ Int and p is an Int64 (be aware of numerics)\n    >>> modp(100, 2)\n    10\n\
    \    >>> modp(100, -2)\n    0\n    >>> modp(101, 2)\n    1\n    >>> modp(3, 11)\n\
    \    8\n    >>> modp(3, -2)\n    3\n    \"\"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"n\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmps1244dro.jl:15\nin expression starting at /tmp/tmps1244dro.jl:15\n"
  stdout: ''
  timestamp: 1660009103
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"modp($n, $p) called with negative\
    \ integers\")\n    if n < p\n        error(\"modp($n, $p) called with $n < $p\"\
    )\n    return p^n - 1\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo6ju3jzx.jl:1\nin expression starting at /tmp/tmpo6ju3jzx.jl:1\n"
  stdout: ''
  timestamp: 1660009103
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n  modp_(n shl 2, p) \nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxm9n5pvm.jl:14\nin expression starting at\
    \ /tmp/tmpxm9n5pvm.jl:14\n"
  stdout: ''
  timestamp: 1660009103
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \nif n <= p return n \nelse return modp(n div p, p) \nend \n\
    \"\"\"Return n to the power of m (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n\"\"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3m8ezbqn.jl:15\nin expression starting at\
    \ /tmp/tmp3m8ezbqn.jl:15\n"
  stdout: ''
  timestamp: 1660009103
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n        then return 0\n    else if n <= p\
    \ \n        then return p\n    else\n        mod p n = p + mod(mod(n-p,p),p)\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpz7ou1hv3.jl:15\nin expression starting at /tmp/tmpz7ou1hv3.jl:15\n"
  stdout: ''
  timestamp: 1660009103
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n%p == 0 || n < 0 || p < 0\n        0\n    elseif\
    \ p == 0\n        n\n    elseif n < p\n        0\n    elseif n > p\n        n\n\
    \    else\n        modp(modp(n/p,p),p)\nend\n</cell>\n<code language=julia-1.3>\n\
    \"\"\"Return the least common multiple of n and p.\n    >>> modp(100, 101)\n \
    \   101\n    >>> modp(100, 102)\n    100\n    >>> modp(100, 0)\n    0\n    >>>\
    \ modp(101, 0)\n    1\n    >>> modp(101, -1)\n    1\n    >>> modp(0, -1)\n   \
    \ 1\n    >>> modp(0, 0)\n    0\n\"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphlbmoa3f.jl:25\nin expression starting at\
    \ /tmp/tmphlbmoa3f.jl:25\n"
  stdout: ''
  timestamp: 1660009103
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p < 0\
    \ \n        then return 1\n        else return modp(n shl 1, p-1)\nend\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nYou can replace the `if` with a `return modp(n shl\
    \ 1, p-1)` if you don't need the second case anywhere else. Also you don't need\
    \ to `return 1` at the end of the function, since `modp(n shl 1, p-1)` will return\
    \ a negative number if `n` is negative and `modp(n shl 1, p-1)` will return a\
    \ positive number if `n` is positive.\n<|/ c |>\n<| c |>\n: I wouldn't do that.\
    \  I was trying to give the logic as clearly as possible but that is a good point\
    \ that I have left out in my answer.\n<|/ c |>\n<| c |>\nYour implementation is\
    \ incorrect: it does not handle negative `n` well. Consider `modp(10, 3)`.\n<|/\
    \ c |>\n<| c |>\n: Thanks for pointing that out.  I believe I have corrected my\
    \ implementation now.\n<|/ c |>\n<| c |>\nI actually think your solution is better\
    \ than my own, but it's missing a small detail that the function should never\
    \ be called with a negative `n`.  Thus the \"else\" branch is missing.  I believe\
    \ that should be \"return modp(n shl 1, p-1)\".  Then it should be fixed in both\
    \ places.\n<|/ c |>\n<| a |>\nMy answer is based on Ramon's answer. \n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp0drjj6mx.jl:15\nin expression starting at /tmp/tmp0drjj6mx.jl:15\n"
  stdout: ''
  timestamp: 1660009103
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n</code>\n<|/ a |>\n<| c |>\nFor me, the solution is `modp(2**n,\
    \ p)`.\n<|/ c |>\n<| a |>\nJust to add to the existing answers, I thought I'd\
    \ share my version since I was struggling with the accepted answer for some time\
    \ before I realized that the problem is with Int.\n<code>\nimport Data.List\n\
    import Data.Maybe\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpf1wq27ts.jl:14\nin expression starting at\
    \ /tmp/tmpf1wq27ts.jl:14\n"
  stdout: ''
  timestamp: 1660009103
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 return 0\n    else if n < 0 return ((modp(-n,\
    \ p))*(-n))%p\n    else return ((mod(n, p))*modp(n, p-1))%p\nend\n</cell>\n<code\
    \ language=julia-1.0>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvtwfj_5j.jl:15\nin expression starting at\
    \ /tmp/tmpvtwfj_5j.jl:15\n"
  stdout: ''
  timestamp: 1660009105
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    \"\"\"\n    >>> modp(4, 5)\n    3\n    \"\"\"\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp5i_jmscn.jl:13\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp5i_jmscn.jl:1\n\
    in expression starting at /tmp/tmp5i_jmscn.jl:1\n"
  stdout: ''
  timestamp: 1660009106
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0\n    then n\n    elseif p == 1 && n <= 0\n\
    \    then 1\n    else\n        modp(n / p, p) % p\n    end\nend\n</code>\n<|/\
    \ a dscore=3 |>\n<| a dscore=3 |>\nWe can use the fact that mod operator can be\
    \ written as follows:\n<code>\nmod a\n</code>\nas\n<code>\na * ((a - 1) % a)\n\
    </code>\nSo the whole function can be written as simple as that:\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"n\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp5b5_2wwm.jl:15\nin expression starting at /tmp/tmp5b5_2wwm.jl:15\n"
  stdout: ''
  timestamp: 1660009106
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= p\n        then return n \n        -- else\n\
    \        then return modp(p, n-p) \n        -- end if\n    else \n        then\
    \ return modp(p - 1, n) \n        -- end if\n    end if\nend \nusing Test\n\n\
    @testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpk7xf2t0b.jl:15\nin expression starting at /tmp/tmpk7xf2t0b.jl:15\n"
  stdout: ''
  timestamp: 1660009106
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    q = modn(n, p)\n    if q == p\n        return n\n   \
    \ else\n        return p^(q*q)\nend\n\"\"\"\n    modn(n::Int64, p::Int64)\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo7l6jl5a.jl:1\nin expression starting at /tmp/tmpo7l6jl5a.jl:1\n"
  stdout: ''
  timestamp: 1660009106
- exit_code: -1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n >= p then\n        return n\n    else\n        return\
    \ modp(n - p, p)\n    end \nend\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660009109
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 || p < 0\n    then return 0\n    else if n <\
    \ p\n    then return n % p\n    else return mod(n-p,p)\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp_n0pwwry.jl:15\nin expression starting at /tmp/tmp_n0pwwry.jl:15\n"
  stdout: ''
  timestamp: 1660009106
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p < 0 or p > 2147483647\n        throw(DomainError(\"\
    p must be in [0, 2^32-1]\"))\n    elseif n <= 0\n        throw(DomainError(\"\
    n must be positive\"))\n    elseif n == 0\n        throw(DomainError(\"n must\
    \ be positive\"))\n    else\n        return modp(n - 1, p) * (p - 1) ^ (n - 1)\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"p\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp50yjkowl.jl:14\nin expression starting at /tmp/tmp50yjkowl.jl:14\n"
  stdout: ''
  timestamp: 1660009106
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n%p == 0 && n > 0 && p > 0 \n        then modp(n/p,\
    \ p)\n        else p\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"modp\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmplchs7m7x.jl:15\nin expression starting at /tmp/tmplchs7m7x.jl:15\n"
  stdout: ''
  timestamp: 1660009106
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0\n        1\n    else if n <= p\n        n\n\
    \    else\n        modp(n % p, p) + 1\nend \n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp308luwhs.jl:16\nin expression starting at\
    \ /tmp/tmp308luwhs.jl:16\n"
  stdout: ''
  timestamp: 1660009106
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    | n < 0 = throw(DomainError(string(\"modp received negative\
    \ number\")))\n    | n < p = throw(DomainError(string(\"modp received less than\
    \ positive number\")))\n    | n >= p = throw(DomainError(string(\"modp received\
    \ number too large\")))\n    | otherwise = log2p(n::Int64) %% p\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"|\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2w62w8ey.jl:14\nin expression starting at\
    \ /tmp/tmp2w62w8ey.jl:14\n"
  stdout: ''
  timestamp: 1660009106
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n\"\"\"\n    modulus\n    \n\"\"\"\n    modp(n::Int64, p::Int64)::Int64\n\
    \    \nReturn the integer p such that 2**n modulo is p and the remainder is 0\n\
    \"\"\"\n    if n == 1 \n        p \n    else if p == 0 \n        n\n    else \n\
    \        modp(n - 1, p) \nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\n  \
    \  modpow\n    \nMultiply the number n by the number p and return the result modulo\
    \ p.\n\"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"function\" at /tmp/tmp7i7zq9q0.jl:13 expected\
    \ \"end\", got \"the\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp7i7zq9q0.jl:20\n\
    in expression starting at /tmp/tmp7i7zq9q0.jl:20\n"
  stdout: ''
  timestamp: 1660009106
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if (n <= p) \n        then n \n    else modp(p, n) \n\
    end \n\"\"\"\n\"\"\"\n    mod2(n::Int64, p::Int64)::Int64 \n    Return a mod p\
    \ of n in base 2.\n    >>> mod2(1, 1)\n    1\n    >>> mod2(4, 6)\n    2\n    >>>\
    \ mod2(-1, 6)\n    1\n    >>> mod2(1, -1)\n    1\n    >>> mod2(4, -6)\n    2\n\
    \    >>> mod2(-1, -6)\n    1\n    >>> mod2(1, 2)\n    2\n    >>> mod2(1, 3)\n\
    \    0\n    >>> mod2(4, -3)\n    2\n    >>> mod2(7, -1)\n    1\n    >>> mod2(3,\
    \ -1)\n    0\n    >>> mod2(8, 1)\n    2\n    >>> mod2(3, 2)\n    0\n    >>> mod2(3,\
    \ 4)\n    0\n    >>> mod2(8, 3)\n    2\n    >>> mod2(9, 3)\n    0\n    >>> mod2(8,\
    \ 4)\n    2\n    >>> mod2(9, 4)\n    0\n    >>> mod2(8, 5)\n    0\n    >>> mod2(8,\
    \ 6)\n    0\n    >>> mod2(-12, 1)\n    1\n    >>> mod2(-11, -2)\n    1\n    >>>\
    \ mod2(-1, -2)\n    1\n    >>> mod2(2, 3)\n    0\n    >>> mod2(-4, 5)\n    -2\n\
    \    >>> mod2(3, 6)\n    0\n    >>> mod2(3, 7)\n    0\n    >>> mod2(0, 7)\n  \
    \  1\n    >>> mod2(1, 1)\n    0\n    >>> mod2(3, 8)\n    0\n    >>> mod2(4, 8)\n\
    \    2\n    >>> mod2(1, 9)\n    0\n    >>> mod2(2, 9)\n    0\n    >>> mod2(-1,\
    \ 9)\n    1\n    >>> mod2(5, 9)\n    2\n    >>> mod2(-3, 9)\n    -2\n    >>> mod2(6,\
    \ 10)\n    0\n    >>> mod2(-5, -9)\n    -2\n    >>> mod2(-6, -9)\n    -2\n   \
    \ >>> mod2(6, -10)\n    0\n    >>> mod2(-1, -10)\n    1\n    >>> mod2(-1, 11)\n\
    \    1\n    >>> mod2(4, 8)\n    0\n    >>> mod2(0, 8)\n    0\n    >>> mod2(3,\
    \ -1)\n    0\n    >>> mod2(-4, -5)\n    2\n    >>> mod2(-5, -3)\n    2\n    >>>\
    \ mod2(6, -6)\n    0\n    >>> mod2(-5, -6)\n    2\n    >>> mod2(-6, -5)\n    2\n\
    \    >>> mod2(-6, 11)\n    2\n    >>> mod2(-6, -9)\n    2\n    >>> mod2(-6, -10)\n\
    \    2\n    >>> mod2(-6, -10)\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"n\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpolh2bq6n.jl:15\nin expression starting at /tmp/tmpolh2bq6n.jl:15\n"
  stdout: ''
  timestamp: 1660009106
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n        then return n \n        else if n\
    \ == 0 \n            then return 1\n            else if n == p \n            \
    \    then return 0\n                else return modp(n - 1, p) + 1\n    end\n\
    end \n</cell>\n<code language=julia-1.4>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp0c5nr6d1.jl:15\nin expression starting at /tmp/tmp0c5nr6d1.jl:15\n"
  stdout: ''
  timestamp: 1660009106
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n > p \n        then (n - p) \n    else if (n == p)\
    \ \n        then 1 \n        else (modp(n - p, p))\n    else 0\nend\n</cell>\n\
    <text>\nModular exponentiation\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: space before \"(\" not allowed in \"then (\"\
    \ at /tmp/tmpin0z92cm.jl:15\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpin0z92cm.jl:15\n\
    in expression starting at /tmp/tmpin0z92cm.jl:15\n"
  stdout: ''
  timestamp: 1660009106
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if (n >= p) == true \n        then return n \n      \
    \  else return n `mod` p \n    end\n    return 1\nend\n</cell>\n<code language=julia-0.6>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpajkd7yvc.jl:15\nin expression starting at /tmp/tmpajkd7yvc.jl:15\n"
  stdout: ''
  timestamp: 1660009106
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    return n & (-p) \nend\n</cell>\n<text>\nWe can now easily\
    \ compute the modular power $\\mu^q$ of the prime $p$ by applying the GMP function\
    \ (gmp_pow), which takes a nonnegative integer $n$ and a prime $p$ and computes\
    \ $p^n$ modulo p:\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpk3au2coy.jl:16\nin expression starting at\
    \ /tmp/tmpk3au2coy.jl:16\n"
  stdout: ''
  timestamp: 1660009106
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    return (n % p == 0 and n or 0) + 1\nend function \n</code>\n\
    and here is code with if/else if and recursive function\n<code>\nusing Test\n\n\
    @testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0_6qklpk.jl:14\nin expression starting at\
    \ /tmp/tmp0_6qklpk.jl:14\n"
  stdout: ''
  timestamp: 1660009106
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p < 0 then return p else n - (n % p) \n    return\
    \ n % p \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmplaa63wnz.jl:14\nin expression starting at /tmp/tmplaa63wnz.jl:14\n"
  stdout: ''
  timestamp: 1660009106
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if(p == 0)\n        return 0\n    else\n        q = n\
    \ % p\n        if q == 0 && p != 2\n            return 1\n        else\n     \
    \       return modp(q, p)\nend\n</cell>\n<text>\nModular Arithmetic\nusing Test\n\
    \n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw72pww4m.jl:23\nin expression starting at\
    \ /tmp/tmpw72pww4m.jl:23\n"
  stdout: ''
  timestamp: 1660009106
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n%p == 0 \n        return n \n    else \n        return\
    \ modp(n//p, p) \nend \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t\
    @test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpb4tnhf3o.jl:13\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpb4tnhf3o.jl:1\n\
    in expression starting at /tmp/tmpb4tnhf3o.jl:1\n"
  stdout: ''
  timestamp: 1660009106
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= p % 2 == 0\n        then return n\n        else\
    \ return n-p+1\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpnrg2_tx3.jl:15\nin expression starting at /tmp/tmpnrg2_tx3.jl:15\n"
  stdout: ''
  timestamp: 1660009106
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p==0 then return 1 else return (n%p)\n    end\nend\n\
    </cell>\n<code language=julia-1.5>\n\"\"\"Return 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n\"\"\"\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp6z2fxrn5.jl:14\nin expression starting at /tmp/tmp6z2fxrn5.jl:14\n"
  stdout: ''
  timestamp: 1660009108
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then \n        return 1\n    if n == 1 then\
    \ \n        if p % 2 == 0 then \n            return 1\n        else \n       \
    \     return 0\n    else \n        if p % 2 == 0 then \n            return modp(n\
    \ - 1, p) // p\n        else \n            return modp((n - 1) % p, p) // p\n\
    end \n</code>\n<|/ a tags=math,python,algorithm,modular |>\n<| c |>\nThis does\
    \ not work. `modp(10, 11)` returns 1, when it should return 3.\n<|/ c |>\n<| a\
    \ tags=math,python,algorithm,modular |>\nModular exponentiation: \n<code>\ndef\
    \ modpow(x, n, p):\n    \"\"\"\n    http://en.wikipedia.org/wiki/Modular_exponentiation\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmpe4l726ay.jl:17 expected \"\
    end\", got \"else\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpe4l726ay.jl:21\n\
    in expression starting at /tmp/tmpe4l726ay.jl:21\n"
  stdout: ''
  timestamp: 1660009108
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0\n        return p\n    if n <= p\n        return\
    \ modp(n - 1, p) % p\n    elseif n < p\n        return modp(n + (p - 1), p) %\
    \ p\n    end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Return n modulo m\
    \ (be aware of numerics).\n    >>> modm(3, 5)\n    3\n    >>> modm(1101, 101)\n\
    \    2\n    >>> modm(0, 101)\n    1\n    >>> modm(3, 11)\n    8\n    >>> modm(100,\
    \ 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0j0ch13z.jl:22\nin expression starting at\
    \ /tmp/tmp0j0ch13z.jl:22\n"
  stdout: ''
  timestamp: 1660009108
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    |= (p%(n::Int64))*(n::Int64) \n    |= p%(n::Int64)\n\
    \    |= p%((n%p)*(n%p))\n    |= p%(n::Int64) % p\n    |= p%(n::Int64) % p\n  \
    \  |= p%((n%p)*(n%p))\n    |= p%(n::Int64) % p\n    |= p%((n%p)*(n%p))\n    |=\
    \ p%(n::Int64) % p\n    |= p%(n::Int64) % p\n    |= p%((n%p)*(n%p))\n    |= p%(n::Int64)\
    \ % p\n    |= p%(n::Int64) % p\n    |= p%((n%p)*(n%p))\n    |= p%(n::Int64) %\
    \ p\n    |= p%(n::Int64) % p\n    |= p%((n%p)*(n%p))\n    |= p%(n::Int64) % p\n\
    \    |= p%(n::Int64) % p\n    |= p%((n%p)*(n%p))\n    |= p%(n::Int64) % p\n  \
    \  |= p%(n::Int64) % p\n    |= p%((n%p)*(n%p))\n    |= p%(n::Int64) % p\n    |=\
    \ p%(n::Int64) % p\n    |= p%((n%p)*(n%p))\n    |= p%(n::Int64) % p\n    |= p%(n::Int64)\
    \ % p\n    |= p%((n%p)*(n%p))\n    |= p%(n::Int64) % p\n    |= p%(n::Int64) %\
    \ p\n    |= p%((n%p)*(n%p))\n    |= p%(n::Int64) % p\n    |= p%(n::Int64) % p\n\
    \    |= p%((n%p)*(n%p))\n    |= p%(n::Int64) % p\n    |= p%(n::Int64) % p\n  \
    \  |= p%((n%p)*(n%p))\n    |= p%(n::Int64) % p\n    |= p%(n::Int64) % p\n    |=\
    \ p%((n%p)*(n%p))\n    |= p%(n::Int64) % p\n    |= p%(n::Int64) % p\n    |= p%((n%p)*\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid identifier name \"|=\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp52_ffnk4.jl:14\nin expression starting at\
    \ /tmp/tmp52_ffnk4.jl:14\n"
  stdout: ''
  timestamp: 1660009109
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    | n % p != 0::Int64\n    | n==p = 1\n    | n>p = 0\n\
    \    | otherwise = n mod p\nend\n</cell>\n<text>\nThe main purpose of this function\
    \ is to find an approximation of $2^n$ modulo p (be aware of numerics).\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"|\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpx66ul7q2.jl:14\nin expression starting at\
    \ /tmp/tmpx66ul7q2.jl:14\n"
  stdout: ''
  timestamp: 1660009109
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        return 0 \n    if n % p > 0 \n   \
    \     return 0 \n    if n % p == 0 \n        return p \n    return p \nusing Test\n\
    \n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmph2huvumb.jl:1\nin expression starting at /tmp/tmph2huvumb.jl:1\n"
  stdout: ''
  timestamp: 1660009108
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    return ((n - 1) * (n - 1)) rem p\nend\n</cell>\n<code\
    \ language=julia-1.0>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"function\" at /tmp/tmp51s0y9fp.jl:13 expected\
    \ \"end\", got \"rem\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp51s0y9fp.jl:14\n\
    in expression starting at /tmp/tmp51s0y9fp.jl:14\n"
  stdout: ''
  timestamp: 1660009109
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < p then return 1\n    if n > p then return 0\n\
    \    if n == p then return n\n    else if n % p == 0 then return n / p\n     \
    \  else return modp(n / p, p)\n</code>\n<|/ a tags=primes,algorithm,prime-factoring\
    \ |>\n<| c |>\nIt's also worth noting that this implementation will not find composites\
    \ up to 2^(n+p) - 1 but rather up to 2^(n+p) which may be an issue when you are\
    \ trying to find the largest number that is a power of 2 with primes > 2^(n+p).\n\
    <|/ c |>\n<| a dscore=1 |>\nI think this can be done with Sieve of Eratosthenes,\
    \ this algorithm is a fast Sieve of Eratosthenes for finding a prime number until\
    \ a number smaller than a given number. The complexity of this algorithm is O(sqrt(n)),\
    \ where n is the given number less than which we want to find the prime number.\n\
    The Sieve of Eratosthenes works like this: we divide the number n into a number\
    \ of subsets of prime numbers. When n is prime, we add it to the set. When n is\
    \ not prime, we divide the remaining number by all numbers that we know are prime.\n\
    Let's take an example to clarify the idea.\nIf n = 10\nWe know that n is prime\
    \ since it has a factor 2.\nThe set consists of {2}, {3,4} and {5}\nThen we divide\
    \ the remaining number by all numbers in the set\nSo (10 / {2, 3,4, 5} = 3)\n\
    Now we have to check if 3 is a prime number\nSince 3 is a prime number, we add\
    \ it to the set\nThe set now consists of {2,3,4}, {5,6} and {7}\nWe continue the\
    \ process until we reach the number less than n\nNow the set consists of {2,3,4},\
    \ {5,6,7}\nNow, since 10 is a prime number, we add it to the set\nThe set now\
    \ consists of {2,3,4}, {5,6,7}, {8}\nThe process continues until we reach the\
    \ number less than n\nThe set consists of {2,3,4}, {5,6,7}, {8}, {9}\nNow since\
    \ 10 is a prime number, we add it to the set\nThe set now consists of {2,3,4},\
    \ {5,6,7}, {8}, {9}, {10}\nSo (10 / {2,3,4,5,6,7,8,9} = 3)\nSo the final result\
    \ is 3.\n<|/ a tags=primes,algorithm,prime-factoring |>\n<| a dscore=0 |>\nI assume\
    \ you are trying to \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmps2vbg54p.jl:14\nin expression starting at /tmp/tmps2vbg54p.jl:14\n"
  stdout: ''
  timestamp: 1660009109
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0\n    then return 1\n    else if n == 0\n   \
    \ then return 0\n    else return mod(n, p)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp4du58mx1.jl:15\nin expression starting at /tmp/tmp4du58mx1.jl:15\n"
  stdout: ''
  timestamp: 1660009108
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n\"\"\"\n    \n# Return 2^n modulo p (be aware of numerics).\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzjt0wwq4.jl:1\nin expression starting at /tmp/tmpzjt0wwq4.jl:1\n"
  stdout: ''
  timestamp: 1660009109
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n\"\"\"\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n\
    \    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100,\
    \ 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpvhqdflf0.jl:13\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpvhqdflf0.jl:1\n\
    in expression starting at /tmp/tmpvhqdflf0.jl:1\n"
  stdout: ''
  timestamp: 1660009109
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    local i = n\n    if i < 0 \n        then return 0 \n\
    \        else return (p - 1) * (n % p) \n    end\nend\n</cell>\n<text>\nTests\n\
    We are going to test the modp function by using the following cases:\nusing Test\n\
    \n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp1gqlnad8.jl:16\nin expression starting at /tmp/tmp1gqlnad8.jl:16\n"
  stdout: ''
  timestamp: 1660009109
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0\n        0\n    else if p == 0\n        n\n\
    \    elseif p < 0\n        modp(abs(n), abs(p))\n    else\n        modp(n/p, p)\n\
    end\n\"\"\"\nReturn the GCD of two numbers\nIf both numbers are 0 or both are\
    \ negative, return zero.\n\"\"\"\nusing Test\n\n@testset begin\n\ncandidate =\
    \ modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t\
    @test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpm5lwe83v.jl:16\nin expression starting at\
    \ /tmp/tmpm5lwe83v.jl:16\n"
  stdout: ''
  timestamp: 1660009109
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"modp(): n must be nonnegative\"\
    )\n    n & (n ^ p)\nend\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t\
    @test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpifz7glpa.jl:13\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpifz7glpa.jl:1\n\
    in expression starting at /tmp/tmpifz7glpa.jl:1\n"
  stdout: ''
  timestamp: 1660009109
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n  if n == 1\n    return p\n  else\n    return (n % p + p)\
    \ % p\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmpdemoeton.jl:14\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpdemoeton.jl:1\n\
    in expression starting at /tmp/tmpdemoeton.jl:1\n"
  stdout: ''
  timestamp: 1660009109
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n        then return n \n        else return\
    \ modp(n / 2, p) \nend\n</code>\nNote that this implementation is O(log n), which\
    \ means it scales much better in practice.\n<|/ a dscore=3 |>\n<| c |>\nYour implementation\
    \ is correct, but this one is O(1) in Big O Notation.\n<|/ c |>\n<| a tags=algorithm,modulo,math,mathematical-optimization,numbers\
    \ |>\nThe accepted answer works, but it calculates p**n multiple times. We can\
    \ save time by calculating the power once and then using the fact that n! = n\
    \ raised to the power n. \n<code>\nusing Test\n\n@testset begin\n\ncandidate =\
    \ modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t\
    @test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpj05gr2tj.jl:15\nin expression starting at /tmp/tmpj05gr2tj.jl:15\n"
  stdout: ''
  timestamp: 1660009109
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    modval = (mod((p-1)^n+(p-1)^n, p) - 1)\n    return modval\
    \ % p\nend\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 5 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpo1ku1ics.jl:19

    '
  stdout: "test set: Test Failed at /tmp/tmpo1ku1ics.jl:22\n  Expression: candidate(3,\
    \ 5) == 3\n   Evaluated: 2 == 3\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpo1ku1ics.jl:22 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpo1ku1ics.jl:21\ntest set: Test\
    \ Failed at /tmp/tmpo1ku1ics.jl:23\n  Expression: candidate(1101, 101) == 2\n\
    \   Evaluated: -1 == 2\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpo1ku1ics.jl:23 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpo1ku1ics.jl:21\ntest set: Test\
    \ Failed at /tmp/tmpo1ku1ics.jl:26\n  Expression: candidate(100, 101) == 1\n \
    \  Evaluated: -1 == 1\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpo1ku1ics.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpo1ku1ics.jl:21\ntest set: Test\
    \ Failed at /tmp/tmpo1ku1ics.jl:27\n  Expression: candidate(30, 5) == 4\n   Evaluated:\
    \ 1 == 4\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpo1ku1ics.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpo1ku1ics.jl:21\ntest set: Test\
    \ Failed at /tmp/tmpo1ku1ics.jl:28\n  Expression: candidate(31, 5) == 3\n   Evaluated:\
    \ 1 == 3\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpo1ku1ics.jl:28 [inlined]\n [3]\
    \ macro expansion\n   "
  timestamp: 1660009111
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n % p == 0 then return n else return modp(n / p, p)\n\
    end\n\"\"\"Return x^2 in base p.\n    >>> modp(3, 5)\n    9\n    >>> modp(1101,\
    \ 101)\n    1010\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    18\n \
    \   >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpkd7tp0h7.jl:14\nin expression starting at /tmp/tmpkd7tp0h7.jl:14\n"
  stdout: ''
  timestamp: 1660009109
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p*n == 0 \n        then 0\n        else modp(p - n\
    \ + 1, p) \n    end\nend\n</cell>\n<code language=julia-1.0>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"0\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmphc1axj99.jl:15\nin expression starting at /tmp/tmphc1axj99.jl:15\n"
  stdout: ''
  timestamp: 1660009109
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then \n        return 1 \n    else if n % p\
    \ == 0 \n        then return n \n        else return modp(n / p, p) \nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprkqii_fv.jl:16\nin expression starting at\
    \ /tmp/tmprkqii_fv.jl:16\n"
  stdout: ''
  timestamp: 1660009109
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p < 0 \n        error(\"modp: p is negative\")\n \
    \   \n    if n == 0 \n        return n\n    \n    if n == 1 \n        return p\n\
    \    \n    if n <= p \n        return modp(n - 1, p) \n    \n    return (n % p)\
    \ + p\nend\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdfzh9g2t.jl:1\nin expression starting at /tmp/tmpdfzh9g2t.jl:1\n"
  stdout: ''
  timestamp: 1660009109
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0\n        return 1 \n    else if p == 0\n  \
    \      return 0 \n    else \n        return (modp(n % p, p))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppudv7zlq.jl:16\nin expression starting at\
    \ /tmp/tmppudv7zlq.jl:16\n"
  stdout: ''
  timestamp: 1660009109
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 || p == 0 \n        then return 0\n    else\
    \ if n > 0\n        then return ((p + modp(n-1, p))*((modp(n-1, p) + modp(n-2,\
    \ p))*(modp(n-2, p) + modp(n-3, p)))\n    else return 0\nend\n</code>\n<|/ a dscore=3\
    \ |>\n<| a |>\nThe algorithm is pretty simple.\nFirst we find the greatest common\
    \ divisor of the two numbers then we use the formula to calculate the next power\
    \ of 2.\n<code>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpc9wfggzl.jl:15\nin expression starting at /tmp/tmpc9wfggzl.jl:15\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n % p == 0 then return n\n    else return modp(n//p,\
    \ p) \nend \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpctr6oke4.jl:14\nin expression starting at /tmp/tmpctr6oke4.jl:14\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0\n    then return p\n    else if n < 0\n   \
    \ then return mod(n, p)\n    else if p < 0\n    then return -1 * mod(-n, p)\n\
    \    else if p > p * p\n    then return 0\n    else return (n % p + p - 1) % p\n\
    end\n</cell>\n<code language=julia-0.5>\n\"\"\"\n    modm(n::Int64, m::Int64)\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpvh2h7_2y.jl:15\nin expression starting at /tmp/tmpvh2h7_2y.jl:15\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 | p < 0 \n        error(\"mod: n and p must\
    \ be positive\")\n    end\n    if n == 0 | p == 0 \n        1\n    end\n    modpow2\
    \ = modpow(n-2, p)\n    return (modpow2 * (modpow2 * p - 1)) % p\nend\n</cell>\n\
    <code language=julia-0.6>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpuxffuec2.jl:23\nin expression starting at\
    \ /tmp/tmpuxffuec2.jl:23\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0\n    then return p\n    else return modp(n\
    \ - 1, p) + p\n    end\n\"\"\"\n``modp``\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpfj9v_xf5.jl:15\nin expression starting at /tmp/tmpfj9v_xf5.jl:15\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    \"\"\"\n    >>> modp(3, 5)\n    3\n    >>> modp(1101,\
    \ 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>>\
    \ modp(100, 101)\n    1\n    \"\"\"\n    return ((n - 1) * p) % p\nusing Test\n\
    \n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpvk0d8ejb.jl:13\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpvk0d8ejb.jl:1\n\
    in expression starting at /tmp/tmpvk0d8ejb.jl:1\n"
  stdout: ''
  timestamp: 1660009112
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    \"\"\"Modulus of p and 2^n.\n    >>> modp(3, 5)\n   \
    \ 3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p == 0: return\
    \ 1\n    if n == 0: return 0\n    if n <= p: \n        return modp(n - 1, p) \n\
    \    else: \n        return modp((p - 1) * (n >> 1), p) \n\"\"\"\nReturn n / 2^k\
    \ modulo p.\n>>> modp(4, 3)\n1\n>>> modp(4, 15)\n2\n>>> modp(8, 15)\n0\n>>> modp(8,\
    \ 31)\n1\n\"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1mlrwpyw.jl:29\nin expression starting at\
    \ /tmp/tmp1mlrwpyw.jl:29\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    \"\"\"modp(n::Int64, p::Int64)::Int64\"\"\"\n    return\
    \ ((n & (p-1)) ^ n) & p\n</code>\nI decided to use an anonymous function so you\
    \ can see the function name in the traceback. This is the equivalent of doing\
    \ this:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfb643pva.jl:16\nin expression starting at\
    \ /tmp/tmpfb643pva.jl:16\n"
  stdout: ''
  timestamp: 1660009112
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == p then return n \n    if n < p then return modp(n\
    \ - p, p)\n    if n > p then return modp(n, p - n)\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp1tqne79b.jl:14\nin expression starting at /tmp/tmp1tqne79b.jl:14\n"
  stdout: ''
  timestamp: 1660009112
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    \"\"\"Calculate mod power of number\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplot_2f4b.jl:1\nin expression starting at /tmp/tmplot_2f4b.jl:1\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n\tif n == 0 then\n\t\t1\n\telse\n\t\tmodp(n mod p, p) + 1\n\
    \tend\nend\n\"\"\"Return x^y mod p (be aware of numerics).\n    >>> modp(2, 12)\n\
    \    6\n    >>> modp(2, 101)\n    1\n    >>> modp(1, 101)\n    1\n    >>> modp(-2,\
    \ 12)\n    -6\n    >>> modp(-2, 101)\n    -1\n    >>> modp(-2, -1)\n    -2\n \
    \   >>> modp(-1, -1)\n    0\n    >>> modp(-2, -2)\n    0\n    \"\"\"\nusing Test\n\
    \n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdpseky7l.jl:17\nin expression starting at\
    \ /tmp/tmpdpseky7l.jl:17\n"
  stdout: ''
  timestamp: 1660009112
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 then\n        1\n    elseif n <= p then\n \
    \       n\n    else\n        p + modp(n-p,p)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @code_native modp(p::Int64, q::Int64)\n</cell>\n<code language=julia-1.5>\n\"\"\
    \"Return the greatest common divisor of p and q, i.e. GCD(q, p).\nIf q is 0, then\
    \ GCD(p, q) = 1 (same as q).\nThis function uses Euclid's algorithm. If q is smaller\
    \ than p, then\ngcd(0, p) = p, and gcd(0, q) = 0.\n\"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpm42pvxon.jl:22\nin expression starting at\
    \ /tmp/tmpm42pvxon.jl:22\n"
  stdout: ''
  timestamp: 1660009112
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"modp expected a positive number\"\
    , 2)\n    \n    if n < p \n        error(\"modp expected a number greater than\
    \ or equal to the divisor\", 2)\n    \n    if n == 0\n        1\n    \n    if\
    \ n < p \n        error(\"modp expected a number less than or equal to the divisor\"\
    , 2)\n    \n    if n <= 0\n        error(\"modp expected a positive number\",\
    \ 2)\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpx0__bs59.jl:1\nin expression starting at /tmp/tmpx0__bs59.jl:1\n"
  stdout: ''
  timestamp: 1660009112
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then 1\n    else n % p\n</code>\n\
    <|/ a |>\n<| a tags=modulo,haskell,algorithm |>\nThe Haskell solution would be\
    \ to define a new function:\n<code>\nmod' n p = n `mod` p\n</code>\nHowever, this\
    \ would be more efficient if you had a library that had already defined it.\n\
    <|/ a dscore=5 |>\n<| c |>\nNot sure why this was downvoted, but `mod` can actually\
    \ be implemented as a combination of `div` and `mod` as well.\n<|/ c |>\n<| c\
    \ |>\nI guess that would be an improvement... but I don't see how that would make\
    \ it more efficient.\n<|/ c |>\n<| c |>\n: It would be more efficient than `n\
    \ \\`mod\\` p` because it avoids an integer division.\n<|/ c |>\n<| c |>\n: And\
    \ it also avoids any unnecessary integer arithmetic which may occur if you use\
    \ an explicit `div` with a negative denominator, since `div` would then involve\
    \ rounding down.\n<|/ c |>\n<| c |>\n: I believe I should have been clearer: it's\
    \ not more efficient, it's more correct. With explicit `div`, you get `div` with\
    \ rounding down unless you use `round`.\n<|/ c |>\n<| a tags=modulo,haskell,algorithm\
    \ |>\nI recommend using div and mod since they are both standard and efficient.\
    \ Using div and mod will make your code more readable and easier to understand,\
    \ since you won't get confused by type annotations.\n<|/ a dscore=4 |>\n<| c |>\n\
    Yeah, I didn't think of that!\n<|/ c |>\n<| c |>\nBut note that when `n` is a\
    \ very big number `p`, using `div` will use less memory than `mod`. [This benchmark](https://stackoverflow.com/questions/10449111/which-is-faster-div-or-mod)\
    \ shows that `div` uses less memory than `mod`.\n<|/ c |>\n<| a dscore=4 |>\n\
    A lot of people are saying \"use div and mod\", but that doesn't really answer\
    \ the question. \nThe reason you might want to use mod, is that you might want\
    \ to do more than just modulus. For example, if you wanted to calculate factorials,\
    \ you should consider that n! = (n-1)! * n, whereas you might want to multiply\
    \ by 2 or 3 to get a higher power of 2. \nSo, to calculate factorials, you would\
    \ want to use the mod function. \n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"1\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpq6kq8qim.jl:15\nin expression starting at /tmp/tmpq6kq8qim.jl:15\n"
  stdout: ''
  timestamp: 1660009112
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 || p < 0 \n        then throw(DomainError(x,\
    \ \"modp\"))\n    elseif n == 0 \n        then throw(ZeroDivisionError(modp(n,\
    \ p)))\n    elseif p == 0 \n        then throw(ZeroDivisionError(modp(n, p)))\n\
    \    elseif p == 1 \n        then n\n    elseif p == 2 \n        then n >> 1\n\
    \    elseif p % 2 == 0 \n        then n\n    elseif p == modp(n, n)\n        then\
    \ n\n    else\n        modp(n, n)\n    end\nend\n</cell>\n<code language=julia-1.1>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"throw\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpcyb5yioo.jl:15\nin expression starting at /tmp/tmpcyb5yioo.jl:15\n"
  stdout: ''
  timestamp: 1660009112
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then 0 else if p == 0 then 1 else n % p\nend\n\
    </code>\n<|/ a tags=julia |>\n<| a |>\nThe easiest way is just to define a function\
    \ which does what you want:\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"0\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmporpp5toe.jl:14\nin expression starting at /tmp/tmporpp5toe.jl:14\n"
  stdout: ''
  timestamp: 1660009112
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    | n <= 0 || n >= p = 1\n    | p < 0 || p <= 0 = 0\n \
    \   | n % p = n / p * p\n    | otherwise = modp(n / p, p)\nend\n</cell>\n<code\
    \ language=julia-1.5>\n# Rewrite modp to handle integer overflow\n# https://stackoverflow.com/questions/67908021/julia-mod-function-does-not-work-with-huge-numbers\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"|\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9e2dcu3b.jl:14\nin expression starting at\
    \ /tmp/tmp9e2dcu3b.jl:14\n"
  stdout: ''
  timestamp: 1660009112
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n\"\"\"Return n^p mod p (be aware of numerics).\n    >>> modp(3,\
    \ 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n   \
    \ >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\
    \n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp924zc5hj.jl:13\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp924zc5hj.jl:1\n\
    in expression starting at /tmp/tmp924zc5hj.jl:1\n"
  stdout: ''
  timestamp: 1660009112
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < p then\n        modp(n + p, p)\n    else\n   \
    \     n\n    end\nend\n</code>\n<|/ a tags=math,julia,algorithm |>\n<| a tags=math,julia,algorithm\
    \ dscore=1 |>\nIt looks like your code is trying to calculate factorial with modulo\
    \ function. I assume you understand what modulo is.\nThe code below is what I\
    \ understood from the exercise description. \n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpi2vmyjui.jl:20\nin expression starting at\
    \ /tmp/tmpi2vmyjui.jl:20\n"
  stdout: ''
  timestamp: 1660009112
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 return 1\n    return p % n\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a |>\nFor a positive number n and prime p you can compute its\
    \ power mod p with the formula (n \xD7 p) mod p or n \xD7 (p-1) mod p\nIn your\
    \ case you can calculate the number in mod p by:\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfm6020jq.jl:16\nin expression starting at\
    \ /tmp/tmpfm6020jq.jl:16\n"
  stdout: ''
  timestamp: 1660009112
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if (p == 0 || n == 0) then 0 else n % p\nend \n\"\"\"\
    Return n % p.\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n   \
    \ >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
    \    1\n\"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"0\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpn1iin7_t.jl:14\nin expression starting at /tmp/tmpn1iin7_t.jl:14\n"
  stdout: ''
  timestamp: 1660009112
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    \"\"\"Modulus p (be aware of numerics).\n    >>> modp(3,\
    \ 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n   \
    \ >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\
    \n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp3l6cxh1e.jl:13\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp3l6cxh1e.jl:1\n\
    in expression starting at /tmp/tmp3l6cxh1e.jl:1\n"
  stdout: ''
  timestamp: 1660009112
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == p then 1\n    else n % p\nend\n</cell>\n<code\
    \ language=julia-1.6>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"1\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpw8uo70bj.jl:14\nin expression starting at /tmp/tmpw8uo70bj.jl:14\n"
  stdout: ''
  timestamp: 1660009114
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < p then return n\n    else return n % p\nend\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpd0sllaie.jl:14\nin expression starting at /tmp/tmpd0sllaie.jl:14\n"
  stdout: ''
  timestamp: 1660009114
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then \n        if p == 0 then \n          \
    \  return 1 \n        else \n            return p \n    else \n        return\
    \ modp(n // p, p)\n</code>\nThis function is very fast for small numbers, and\
    \ fast for large numbers (and for large numbers of p!)\n<|/ a tags=math,combinatorics,algorithm\
    \ |>\n<| a tags=math,combinatorics,algorithm |>\nIt seems to me that your question\
    \ was answered by others, except that they used the modulo operator and I used\
    \ recursion.\nI agree that recursion is usually not suitable for solving problems\
    \ with repeated iterations.\nHere is a solution that uses recursion to iteratively\
    \ solve the problem (this is just a \"proof\" of how to use recursion).  It also\
    \ uses a combinator to do the same thing.\nThis solution only works with numbers\
    \ where the modulo operation is defined, and requires no looping constructs.\n\
    It also only works with numbers where the result is a power of two modulo p.\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmpfy8ze329.jl:15 expected \"\
    end\", got \"else\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpfy8ze329.jl:19\n\
    in expression starting at /tmp/tmpfy8ze329.jl:19\n"
  stdout: ''
  timestamp: 1660009114
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    return 2^n%p\nend\n</cell>\n<text>\nLa funci\xF3n modp\
    \ nos devuelve un valor que indica la cantidad de bits de un n\xFAmero entero\
    \ $n$ que sean relativamente diferentes de $p$. En otras palabras $modp$ significa\
    \ modular exponentiation. Es decir, esta es una operaci\xF3n que permite exponer\
    \ a $p$ un entero $n$. La funci\xF3n recibe dos par\xE1metros, $n$ y $p$.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpief6ka_z.jl:16\nin expression starting at\
    \ /tmp/tmpief6ka_z.jl:16\n"
  stdout: ''
  timestamp: 1660009114
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if (n > 0)\n        | (n <= 1)\n    then (p - 1) * (2\
    \ ^ n) \n    else if (n < 0)\n        | (n >= p + 1)\n    then p - 1 \n    else\n\
    \        n\n</code>\n<|/ a tags=julia |>\n<| a |>\nHere is a version using bit\
    \ operations:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: space before \"(\" not allowed in \"| (\" at\
    \ /tmp/tmp2v8w75j_.jl:15\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2v8w75j_.jl:15\n\
    in expression starting at /tmp/tmp2v8w75j_.jl:15\n"
  stdout: ''
  timestamp: 1660009114
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then 0 else n % p\nend\n\"\"\"Return 2^n modulo\
    \ p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n\
    \    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100,\
    \ 101)\n    1\n\"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"0\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp96z0yoqb.jl:14\nin expression starting at /tmp/tmp96z0yoqb.jl:14\n"
  stdout: ''
  timestamp: 1660009114
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    | n % p <= 0 = p - n % p\n    | n % p  = 0\n    | otherwise\
    \ = n - n % p\n    end\n\"\"\"\nCompute the sign of a number.\nusing Test\n\n\
    @testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"|\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3chd0h75.jl:14\nin expression starting at\
    \ /tmp/tmp3chd0h75.jl:14\n"
  stdout: ''
  timestamp: 1660009114
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    pow2::Int64 = n\n    i = Int(1)\n    while i < (pow2\
    \ - p)\n        i += i\n    modp::Int64 = (i as Int64) % p\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyx07fsbl.jl:18\nin expression starting at\
    \ /tmp/tmpyx07fsbl.jl:18\n"
  stdout: ''
  timestamp: 1660009114
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n</code>\nSo it seems like it's working properly now (though\
    \ I may have misread what you are looking for). Hope this helps!\n<|/ a tags=python,algorithm\
    \ dscore=2 |>\n<| c |>\nThanks a lot for the help! It certainly did. However,\
    \ I was wondering if my method was correct and you had a more efficient way to\
    \ solve the problem. I'm not too familiar with the mod function in python, but\
    \ I thought I should ask.\n<|/ c |>\n<| c |>\nI do apologize for not being clear\
    \ in the original question. I've made the changes to the original post. Thanks\
    \ for your help!\n<|/ c |>\n<| a |>\n<code>\ndef modp(n::Int64, p::Int64)::Int64\n\
    \    factors = factors(n)\n    biggest_factor = 0\n    for i in factors\n    \
    \    biggest_factor = i if i > biggest_factor else biggest_factor\n        if\
    \ p == biggest_factor\n            factors.remove(i)\n            return biggest_factor\n\
    \        biggest_factor = 0\n    return p\n</code>\n<|/ a dscore=0 tags=python,algorithm\
    \ |>\n<| c |>\nThanks a lot for the help! It certainly did. However, I was wondering\
    \ if my method was correct and you had a more efficient way to solve the problem.\
    \ I'm not too familiar with the mod function in python, but I thought I should\
    \ ask.\n<|/ c |>\n<| a dscore=0 tags=python,algorithm |>\nHere's my solution.\
    \ I'm sure there is a more elegant way to do it, but it works.\n<code>\ndef modp(n::Int64,\
    \ p::Int64)::Int64\n    factors = factors(n)\n    biggest_factor = 0\n    for\
    \ i in factors\n        biggest_factor = i if i > biggest_factor else biggest_factor\n\
    \        if p == biggest_factor\n            factors.remove(i)\n            return\
    \ biggest_factor\n        biggest_factor = 0\n    return p\n</code>\n<|/ a |>\n\
    <| a tags=python,algorithm |>\nHere is another solution which also works with\
    \ any n and p\n<code>\ndef modp(n,p):\n    factors = sorted([i for i in factors(n)\
    \ if p%i == 0])\n    return factors[-1]\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    Thanks a lot for the help! It certainly did. However, I was wondering if my method\
    \ was correct and you had a more efficient way to solve the problem. I'm not too\
    \ familiar with the mod function in python, but I thought I should ask.\n<|/\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbo2udhqz.jl:14\nin expression starting at\
    \ /tmp/tmpbo2udhqz.jl:14\n"
  stdout: ''
  timestamp: 1660009114
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        then error(\"modp(n,p): n must be\
    \ non-negative.\")\n    if p == 0 \n        then return 1\n    else if n < p \n\
    \        then return 0\n        else return modp(n - p, p)\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"error\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpn60pbm3h.jl:15\nin expression starting at /tmp/tmpn60pbm3h.jl:15\n"
  stdout: ''
  timestamp: 1660009114
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0\n        error(\"modp requires non-negative\
    \ numbers and non-positive modulus\")\n    end\n    if p == 0\n        error(\"\
    modp requires non-zero modulus\")\n    end\n    if p < 1\n        error(\"modp\
    \ requires positive modulus\")\n    end\n    if n < p\n        error(\"modulus\
    \ too small\")\n    end\n    return modp_naive(n, p)\nend\n</cell>\n<text>\nmodpow\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbu9pjo8d.jl:28\nin expression starting at\
    \ /tmp/tmpbu9pjo8d.jl:28\n"
  stdout: ''
  timestamp: 1660009114
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    \"\"\"\n    Modulus (remainder of) 2 by n.\n    \"\"\"\
    \n    if n < p then return n % p\n    if n < 2*p then return n % p\n    return\
    \ (p + n) % p\n    \"\"\"\n    Modulus (remainder of) 2 by n.\n    \"\"\"\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpi_eh2f_9.jl:17\nin expression starting at /tmp/tmpi_eh2f_9.jl:17\n"
  stdout: ''
  timestamp: 1660009114
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n    then return 0\n    else if n == 0 \n \
    \   then return 1\n    else if n < p\n    then return n\n    else return p + modp(n\
    \ - p, p)\nend \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp67i3ui8_.jl:15\nin expression starting at /tmp/tmp67i3ui8_.jl:15\n"
  stdout: ''
  timestamp: 1660009114
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 || p == 0 \n    then return 0 \n    else if\
    \ n < 0 \n    then return 0 \n    else if p == 0 \n    then return 1 \n    else\
    \ \n        return modp(n // p, p) + n % p \nend\n</cell>\n<code language=julia-0.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmprdvwyzav.jl:15\nin expression starting at /tmp/tmprdvwyzav.jl:15\n"
  stdout: ''
  timestamp: 1660009115
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= p then\n        return n\n    else \n       \
    \ return modp(n - p + 1, p)\nend\n</cell>\n<text>\nThe modulus operator (%) returns\
    \ the remainder of its arguments. The remainder is defined as the rest of a division\
    \ remainder of the quotient and the division quotient. For example, $3%5 = 2$\
    \ and $8%7 = 4$. An example of this is the remainder of $3$ / $5$:\nusing Test\n\
    \n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdn377opc.jl:19\nin expression starting at\
    \ /tmp/tmpdn377opc.jl:19\n"
  stdout: ''
  timestamp: 1660009114
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0\n        return p\n    if p > 0 && n > 1 &&\
    \ n <= p\n        return modp(n / 2, p)\n    p > 1 && n <= p\n    return modp((p\
    \ + 1) * n + 1, p)\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpplz16n3l.jl:21\nin expression starting at\
    \ /tmp/tmpplz16n3l.jl:21\n"
  stdout: ''
  timestamp: 1660009115
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    x <- n % p\n    y <- n / p\n    if x == 0\n        then\
    \ return p\n        else return y\n    end\nend\n</code>\n<|/ a tags=math,python,modulo\
    \ |>\n<| c |>\nA bit harsh, but the question was \"how do I do modulo arithmetic?\"\
    \ Not \"how do I do modulo exponentiation?\"\n<|/ c |>\n<| c |>\nIt would be nice\
    \ if Python had some kind of [remainder](https://docs.python.org/3/library/stdtypes.html#remainder)\
    \ function.  For example, if `a` and `b` are the inputs, `a - b * (b - a) % b`\
    \ should be what OP wants.\n<|/ c |>\n<| c |>\nThe last line of code doesn't work\
    \ as intended. Instead of returning `mod` (mod as in the modulo operation on integers),\
    \ it returns `mod / p`.\n<|/ c |>\n<| a tags=math,python,modulo |>\n<code>\ndef\
    \ modp(m,n):\n    if n < 0:\n        raise ValueError\n    if n == 0:\n      \
    \  return 1\n    if m == 0:\n        return n\n    if m == 1:\n        return\
    \ n\n    if m == 2:\n        return (n + modp(0,n-1))%m\n    if m == 3:\n    \
    \    return modp(n,(n+modp(1,n-1)))%m\n    if m == 4:\n        return modp((n+modp(2,n-1)),(n+modp(3,n-1)))%m\n\
    \    if m == 5:\n        return modp((n+modp(3,n-1)),(n+modp(4,n-1)))%m\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nI like this because it's easy to read.  I wish I'd\
    \ seen it myself before. :-)\n<|/ c |>\n<| c |>\nWhat is `n` supposed to be? You\
    \ forgot to define `n` in the function definition\n<|/ c |>\n<| a tags=math,python,modulo\
    \ |>\nHere is a Python 3 implementation of a \"mod\" function:\n<code>\ndef mod(n,\
    \ m):\n    \"\"\"Modulus function n with respect to modulo m\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmppwz46g30.jl:17\nin expression starting at /tmp/tmppwz46g30.jl:17\n"
  stdout: ''
  timestamp: 1660009115
- exit_code: -1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    p -= floor(p)\n    n %= p\n    if n >= p\n        return\
    \ n - (p+1)\n    end\n    return n\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: Timeout
  stderr: ''
  stdout: "test set: Error During Test at /tmp/tmpiqs76qfj.jl:26\n  Test threw exception\n\
    \  Expression: candidate(3, 5) == 3\n  DivideError: integer division error\n \
    \ Stacktrace:\n   [1] rem\n     @ ./int.jl:285 [inlined]\n   [2] modp(n::Int64,\
    \ p::Int64)\n     @ Main /tmp/tmpiqs76qfj.jl:15\n   [3] macro expansion\n    \
    \ @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \   [4] macro expansion\n     @ /tmp/tmpiqs76qfj.jl:26 [inlined]\n   [5] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpiqs76qfj.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpiqs76qfj.jl:27\n  Test threw exception\n  Expression:\
    \ candidate(1101, 101) == 2\n  DivideError: integer division error\n  Stacktrace:\n\
    \   [1] rem\n     @ ./int.jl:285 [inlined]\n   [2] modp(n::Int64, p::Int64)\n\
    \     @ Main /tmp/tmpiqs76qfj.jl:15\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpiqs76qfj.jl:27 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpiqs76qfj.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpiqs76qfj.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(0, 101) == 1\n  DivideError: integer division error\n  Stacktrace:\n\
    \   [1] rem\n     @ ./int.jl:285 [inlined]\n   [2] modp(n::Int64, p::Int64)\n\
    \     @ Main /tmp/tmpiqs76qfj.jl:15\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpiqs76qfj.jl:28 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpiqs76qfj.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpiqs76qfj.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(3, 11) == 8\n  DivideError: integer division error\n  Stacktrace:\n\
    \   [1] rem\n     @ ./int.jl:285 [inlined]\n   [2] modp(n::Int64"
  timestamp: 1660009117
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 1\n        return p\n    \n    if n % p == 0\n\
    \        return modp(n / p, p)\n    \n    return modp(n / p + 1, p)\n    end\n\
    end\n</cell>\n<code language=julia-1.0>\n# Test\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpke9i3fq_.jl:23\nin expression starting at\
    \ /tmp/tmpke9i3fq_.jl:23\n"
  stdout: ''
  timestamp: 1660009114
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    local nn, pp = n, p\n    nn = 1\n    pp = 1\n    while\
    \ nn > pp do\n        pp *= pp\n        nn *= nn\n    end\n    return pp\nend\n\
    </code>\nI should add that if you want a function that returns 1<<k mod p when\
    \ k > 0, you can write\n<code>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp8q454pw8.jl:17\nin expression starting at /tmp/tmp8q454pw8.jl:17\n"
  stdout: ''
  timestamp: 1660009115
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n    then return n\n    else if p == 1 \n\
    \    then return n\n    else return n%p\n    end\n    end\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpsfpjuo1q.jl:15\nin expression starting at /tmp/tmpsfpjuo1q.jl:15\n"
  stdout: ''
  timestamp: 1660009115
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    r <- n%p\n    r == 0 ? r : modp(r, p-1)\nend\n</code>\n\
    <|/ a tags=recursion,julia,math,algorithm,function dscore=2 |>\n<| c |>\n\"...\
    \ be aware of numerics\" \u2014 yes, absolutely!\n<|/ c |>\n<| c |>\nI assume\
    \ your implementation is faster than mine?\n<|/ c |>\n<| c |>\nYes, mine is a\
    \ bit different (doesn't do any division). I'd expect mine to run faster than\
    \ yours, since it's more compact.\n<|/ c |>\n<| c |>\nI thought there might be\
    \ a solution that doesn't require any floating point arithmetic or rounding.\n\
    <|/ c |>\n<| c |>\n: you mean \"integer\"? If so, then you're correct that the\
    \ modulo is a bit slower, but I think that it's still very fast because there's\
    \ no division.\n<|/ c |>\n<| a tags=recursion,julia,math,algorithm,function |>\n\
    You could use integer arithmetic and do mod operation on the powers:\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpc824v7e2.jl:17\nin expression starting at\
    \ /tmp/tmpc824v7e2.jl:17\n"
  stdout: ''
  timestamp: 1660009115
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n    then \n        1\n    else \n       \
    \ n % p + 1\nend\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp3efgslcy.jl:13\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp3efgslcy.jl:1\n\
    in expression starting at /tmp/tmp3efgslcy.jl:1\n"
  stdout: ''
  timestamp: 1660009115
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n     if n==0 \n         return p\n     if p==0 \n       \
    \  return 1\n     if n>0 \n         return modp(mod(n, p), p)\n     if n<0 \n\
    \         return modp(mod(-n, p), p)\n     return modp(abs(n), abs(p))\nend\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpre_dd37r.jl:1\nin expression starting at /tmp/tmpre_dd37r.jl:1\n"
  stdout: ''
  timestamp: 1660009116
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 || p < 0 || n < p then return 0 \n    else if\
    \ n == 0 then return 1 \n    else if n == p then return 1 \n    else if n < p\
    \ then return 0 \n    else return modp(n - p, p)\nend \n</cell>\n<text>\nProblem\
    \ 10\nThe sum of the primes p1, p2, \u2026, pn equals $(p1 + p2 + ... + pn) /\
    \ 2 $.\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpuknr_vwz.jl:14\nin expression starting at /tmp/tmpuknr_vwz.jl:14\n"
  stdout: ''
  timestamp: 1660009117
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  return modp(floor(log2(n)),p)*p\nend\n\"\"\"Returns n modulo p mod m (m is\
    \ p^r).\n    >>> modp(100, 2)\n    4\n    >>> modp(2, 2)\n    1\n    >>> modp(15,\
    \ 2)\n    7\n    >>> modp(16, 2)\n    3\n    >>> modp(15, 4)\n    10\n    >>>\
    \ modp(15, 16)\n    32\n    >>> modp(16, 16)\n    0\n    >>> modp(16, 0)\n   \
    \ 0\n    >>> modp(16, 0)\n    0\n    >>> modp(16, 0)\n    0\n    \"\"\"\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpsqeae14b.jl:14\nin expression starting at /tmp/tmpsqeae14b.jl:14\n"
  stdout: ''
  timestamp: 1660009117
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return p else n % p\n    else n % p\n\
    </code>\n<|/ a dscore=3 |>\n<| a tags=optimization,mod,python,performance,math\
    \ dscore=2 |>\nI do not know why your algorithm is not as fast as the optimized\
    \ one, but here is a simple example to showcase it does indeed work.\n<code>\n\
    from time import time\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpil7d232_.jl:14\nin expression starting at /tmp/tmpil7d232_.jl:14\n"
  stdout: ''
  timestamp: 1660009117
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n    then return 1\n    else \n        modp(n\
    \ / p, p)\n    end\nend\n</code>\nThe trick is finding a power-2 modulo p. If\
    \ you search on Google you'll find many examples, but the ones I saw were not\
    \ so efficient. I'll post an updated version that does it for Int64, if someone\
    \ wants to improve it I'll be glad to know.\n<|/ a dscore=4 tags=algorithm,modulo,math,bigint\
    \ |>\n<| c |>\nThanks for the helpful answer!\n<|/ c |>\n<| c |>\nThe algorithm\
    \ for modp(3,5) appears to be incorrect. For instance, this gives 2 for modp(1101,101).\
    \ The answer should be: 7.\n<|/ c |>\n<| c |>\n: You're right, I forgot to subtract\
    \ 1 from the `n` when calculating the remainder. This fixed it: `modp(n, p)` \u2192\
    \ `modp(n - 1, p) % p + 1`.\n<|/ c |>\n<| a dscore=4 tags=algorithm,modulo,math,bigint\
    \ |>\nHere's an implementation which uses bit manipulation, and which should run\
    \ faster than the naive algorithm, but probably much slower than the naive algorithm.\
    \ Of course, it doesn't give the right answer on all inputs (e.g. (1, 5)) but\
    \ I'll let you handle that on your own ;)\n<code>\nusing BigInt, BitVectors\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp2il62dm0.jl:15\nin expression starting at /tmp/tmp2il62dm0.jl:15\n"
  stdout: ''
  timestamp: 1660009117
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    \"\"\"Compute the greatest common divisor of 2 numbers.\n\
    \    >>> modp(20, 10)\n    10\n    >>> modp(200, 20)\n    200\n    >>> modp(5,\
    \ 5)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t\
    @test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpu0j55ntr.jl:13\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpu0j55ntr.jl:1\n\
    in expression starting at /tmp/tmpu0j55ntr.jl:1\n"
  stdout: ''
  timestamp: 1660009117
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    \"\"\"Return 2^n modulo p (be aware of numerics).\n \
    \   >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmptguoe6z9.jl:13\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmptguoe6z9.jl:1\n\
    in expression starting at /tmp/tmptguoe6z9.jl:1\n"
  stdout: ''
  timestamp: 1660009117
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n        return 1 \n    else if n < 0 \n \
    \       return modp(abs(n), p) \n    return modp(mod(n, p), p) \nend \nusing Test\n\
    \n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0rv8zfb7.jl:16\nin expression starting at\
    \ /tmp/tmp0rv8zfb7.jl:16\n"
  stdout: ''
  timestamp: 1660009117
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 return n % p\n    if n == 0 return 1\n    return\
    \ modp(n / p, p)\nend\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvasis8xz.jl:1\nin expression starting at /tmp/tmpvasis8xz.jl:1\n"
  stdout: ''
  timestamp: 1660009117
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0\n        error(\"modp: no positive numbers\
    \ given\")\n    elif n < p\n        error(\"modp: n <= p\")\n    else\n      \
    \  return n & (p - 1)\nend\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"n\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpg1mviozr.jl:16\nin expression starting at /tmp/tmpg1mviozr.jl:16\n"
  stdout: ''
  timestamp: 1660009117
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 | p < 0 \n        throw(DomainError(string(\"\
    modulus not positive or non-integer\")))\n    if p == 0\n        throw(DomainError(string(\"\
    modulus can't be zero\")))\n    if n == 0\n        return p\n    if n > p\n  \
    \      return modp(n, p % n)\n    \nlet rec modp2::Int64 -> Int64 -> Int64  =\
    \ \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5)\
    \ == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: let variables should end in \";\" or newline\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp_taz_8ex.jl:23\nin expression\
    \ starting at /tmp/tmp_taz_8ex.jl:23\n"
  stdout: ''
  timestamp: 1660009117
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0 || p <= 0 \n        then return 0\n    else\
    \ return mod(n*p, p)\nend\n\"\"\"Return m modulo p (be aware of numerics).\n>>>\
    \ modp(3, 5)\n3\n>>> modp(1101, 101)\n101\n>>> modp(0, 101)\n1\n>>> modp(3, 11)\n\
    9\n>>> modp(100, 101)\n101\n\"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp4urf6ndh.jl:15\nin expression starting at /tmp/tmp4urf6ndh.jl:15\n"
  stdout: ''
  timestamp: 1660009117
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        return 0 \n    return (p-1)^n \nend\
    \ \n</code>\n<|/ a tags=math,julia,algorithm dscore=4 |>\n<| c |>\n`modp(1<<64-1,\
    \ 1<<64-1)` doesn't work, I tried in Julia: `modp(1<<64-1, 1<<64-1)` returns `1`\
    \ but `modp(1<<64-2, 1<<64-1)` returns `0` which is not correct.\n<|/ c |>\n<|\
    \ c |>\nI believe `modp(1<<64-1, 1<<64-1)` and `modp(1<<64-1, 1<<64-2)` both return\
    \ `1` in Julia 1.1.0 on a Mac, but I have not tried the other versions on other\
    \ platforms.\n<|/ c |>\n<| c |>\nWhat should `modp(1<<64-1, 1<<64-2)` return?\
    \ 0 or 1?\n<|/ c |>\n<| c |>\nIt should return 1, as the function I wrote returns\
    \ 1 for positive numbers and 0 for negative ones.\n<|/ c |>\n<| c |>\n`modp(1<<64-1,\
    \ 1<<64-2)` returns 1 on my machine and Julia 1.1. But `modp(1<<64-4, 1<<64-2)`\
    \ returns 0 in Julia 1.1.0 on my Mac and Julia 1.1.0 on Linux. What's the logic\
    \ behind that?\n<|/ c |>\n<| a |>\nThe accepted answer didn't work for me (Julia\
    \ 1.1)\n<code>\njulia> modp(1<<64-1, 1<<64-1)\n1\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcpwd4bnt.jl:18\nin expression starting at\
    \ /tmp/tmpcpwd4bnt.jl:18\n"
  stdout: ''
  timestamp: 1660009117
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    return (n % p) \nend\n</cell>\n<code language=julia-1.3>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppxfzp6q7.jl:16\nin expression starting at\
    \ /tmp/tmppxfzp6q7.jl:16\n"
  stdout: ''
  timestamp: 1660009117
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n > p\n        n %= p\n    else\n        n %= p\n\
    \    end\n    return n\nend\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp6b5r5qpf.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmp6b5r5qpf.jl:27\n  Expression: candidate(1101,\
    \ 101) == 2\n   Evaluated: 91 == 2\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6b5r5qpf.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6b5r5qpf.jl:25\ntest set: Test\
    \ Failed at /tmp/tmp6b5r5qpf.jl:28\n  Expression: candidate(0, 101) == 1\n   Evaluated:\
    \ 0 == 1\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6b5r5qpf.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6b5r5qpf.jl:25\ntest set: Test\
    \ Failed at /tmp/tmp6b5r5qpf.jl:29\n  Expression: candidate(3, 11) == 8\n   Evaluated:\
    \ 3 == 8\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6b5r5qpf.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6b5r5qpf.jl:25\ntest set: Test\
    \ Failed at /tmp/tmp6b5r5qpf.jl:30\n  Expression: candidate(100, 101) == 1\n \
    \  Evaluated: 100 == 1\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6b5r5qpf.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6b5r5qpf.jl:25\ntest set: Test\
    \ Failed at /tmp/tmp6b5r5qpf.jl:31\n  Expression: candidate(30, 5) == 4\n   Evaluated:\
    \ 0 == 4\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6b5r5qpf.jl:31 [inlined]\n [3]\
    \ macro expansion\n"
  timestamp: 1660009119
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p < 2 \n        return n\n    if p < n \n        return\
    \ n - p\n    while p % 2 == 0 \n        p /= 2\n    return p\n</code>\n<|/ a tags=math,modulus,mathematical-optimization,big-o\
    \ dscore=2 |>\n<| c |>\n`modp(1101, 101)` returns `8`.\n<|/ c |>\n<| c |>\nThis\
    \ algorithm is also O(n), and can easily be adapted to find the next power of\
    \ 2 with a simple addition, without having to use division.\n<|/ c |>\n<| c |>\n\
    Yes, I meant modp(1101, 101) should return 8.\n<|/ c |>\n<| c |>\nI believe your\
    \ answer is wrong, and is based on a misunderstanding of what modp means.\n<|/\
    \ c |>\n<| a dscore=1 tags=math,modulus,mathematical-optimization,big-o |>\nYou\
    \ can use the fact that if two numbers are even divided by each other, you get\
    \ the remainder of their divisions equal to 0.\nThis is true for numbers under\
    \ 2^(floor(log2(num))), where log2(num) is an integer.\nFor example, 123/456 =\
    \ 1, and 123/455 = 2, which both result in 0, which means that you simply have\
    \ to find out when n is greater than floor(log2(num)), and use it.\nThe final\
    \ code:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkal4ja7o.jl:21\nin expression starting at\
    \ /tmp/tmpkal4ja7o.jl:21\n"
  stdout: ''
  timestamp: 1660009117
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 || (n < p && n > 0)\n    return n % (p - 1)\n\
    else\n    return n %% p\nend\n</code>\n<|/ a dscore=2 tags=performance,julia |>\n\
    <| a dscore=0 |>\nJust to share the JuliaPro solution with you:\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"%\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbom07osl.jl:17\nin expression starting at\
    \ /tmp/tmpbom07osl.jl:17\n"
  stdout: ''
  timestamp: 1660009117
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 || p == 0 || n == p \n        then 1 \n    else\
    \ modp(n / p, p)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"1\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpbpa5q1o2.jl:15\nin expression starting at /tmp/tmpbpa5q1o2.jl:15\n"
  stdout: ''
  timestamp: 1660009117
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 return p \n    else return modp(n-1, p) * 2\
    \ % p + 1 \nend \n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqtsnxyju.jl:17\nin expression starting at\
    \ /tmp/tmpqtsnxyju.jl:17\n"
  stdout: ''
  timestamp: 1660009117
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0\n        error(\"n must be positive\")\n  \
    \  end\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpmjd31_f7.jl:13\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpmjd31_f7.jl:1\n\
    in expression starting at /tmp/tmpmjd31_f7.jl:1\n"
  stdout: ''
  timestamp: 1660009117
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if (p==0)\n        0\n    else if (n==0)\n        1\n\
    \    else\n        modp(n-1, p)*p + modp(n, p-1)\nend\n</cell>\n<code language=julia-1.3>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpd8pvsfrq.jl:16\nin expression starting at\
    \ /tmp/tmpd8pvsfrq.jl:16\n"
  stdout: ''
  timestamp: 1660009118
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n        if n <= 1 \n            then 1\n        else n %\
    \ p + modp(n / p, p)\nend\n</cell>\n<text>\nExercise 11\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"1\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpnra6rf8a.jl:15\nin expression starting at /tmp/tmpnra6rf8a.jl:15\n"
  stdout: ''
  timestamp: 1660009118
- exit_code: -1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0 \n        error(\"n <= 0\")\n    end\n    if\
    \ p <= 0\n        error(\"p <= 0\")\n    end\n    if n <= 0\n        error(\"\
    n <= 0\")\n    end\n    ans = 0\n    for i in 1:n\n        ans = (ans * p) % p\n\
    \    end\n    return ans\nend\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: Timeout
  stderr: ''
  stdout: "test set: Test Failed at /tmp/tmp_8_jcgpk.jl:34\n  Expression: candidate(3,\
    \ 5) == 3\n   Evaluated: 0 == 3\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_8_jcgpk.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_8_jcgpk.jl:33\ntest set: Test\
    \ Failed at /tmp/tmp_8_jcgpk.jl:35\n  Expression: candidate(1101, 101) == 2\n\
    \   Evaluated: 0 == 2\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_8_jcgpk.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_8_jcgpk.jl:33\n"
  timestamp: 1660009121
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0\n        throw(DomainError(\"modulus must be\
    \ strictly positive\"))\n    if p <= 0\n        throw(DomainError(\"modulus must\
    \ be strictly positive\"))\n    modp_mod = 0\n    for x in irange(1, n+1)\n  \
    \      modp_mod = modp_mod + modp(x, p)\n    return modp_mod % p\n</code>\n<|/\
    \ a dscore=4 |>\n<| c |>\nI love you :) I actually used the Python code for this\
    \ in another question, but it was so long ago that I can't remember where I used\
    \ this code. Thanks a lot, you made my day!\n<|/ c |>\n<| c |>\nIt looks so straightforward.\
    \ Thank you.\n<|/ c |>\n<| c |>\nIt's great that we can see the source code for\
    \ modp on Python, but where does it get its implementation from?\n<|/ c |>\n<|\
    \ c |>\nFor those who are interested in the implementation see this answer: https://stackoverflow.com/questions/5952900/what-is-the-implementation-of-mod-in-python\n\
    <|/ c |>\n<| c |>\nThanks for this. I remember trying to do this a lot last year\
    \ and I just used some variant of the same algorithm as this one. This seems like\
    \ the best answer. I'll have to try and optimize this for speed, so I will just\
    \ leave this in as a reference for people who are interested. Cheers!\n<|/ c |>\n\
    <| a tags=algorithm,modular-arithmetic,math |>\nHere is my solution. It's in Python,\
    \ but it can be easily translated to any language.\n<code>\ndef modinv(p, n):\n\
    \    # n is assumed odd integer and is positive\n    if n < 0 or p < 0:\n    \
    \    raise ValueError\n    if n & 1:\n        return modinv(p, n//2)\n    a =\
    \ n % p\n    if a == 0:\n        return 0\n    if p % 2 == 0:\n        if a &\
    \ 1:\n            return modinv(p, n//2)\n        else:\n            return modinv(p//2,\
    \ n//2)\n    else:\n        if a & 1:\n            return modinv(p, n//2)\n  \
    \      else:\n            return modinv(p-1, n//2)\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpf5v99kw3.jl:22\nin expression starting at\
    \ /tmp/tmpf5v99kw3.jl:22\n"
  stdout: ''
  timestamp: 1660009119
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0\n        error(\"modp() not defined for negative\
    \ values\")\n    else if p == 0\n        error(\"modp() not defined for positive\
    \ values\")\n    else if n >= p\n        return n\n    else\n        return p\
    \ == 0 ? 1 : mod(mod(n, p), p)\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdc4j9jqu.jl:16\nin expression starting at\
    \ /tmp/tmpdc4j9jqu.jl:16\n"
  stdout: ''
  timestamp: 1660009120
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \nif n==0\n    else p % n\nend\n\"\"\"Return x^y modulo p (be\
    \ aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n  \
    \  2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100,\
    \ 101)\n    1\n\"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpexc9b2hv.jl:13\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpexc9b2hv.jl:1\n\
    in expression starting at /tmp/tmpexc9b2hv.jl:1\n"
  stdout: ''
  timestamp: 1660009120
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 0 \n    else if n < p then return\
    \ n - 1 \n    else return p \nend \n\"\"\"\n    \n\"\"\"\n    modl(n, m)\n   \
    \ \nReturn the least significant bit of n modulo m, or 0 if n == 0.\n    \"\"\"\
    \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpg6w2fv4b.jl:14\nin expression starting at /tmp/tmpg6w2fv4b.jl:14\n"
  stdout: ''
  timestamp: 1660009120
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n >= 0\n        then mod(n, p) % p\n        else mod(p,\
    \ n) % p\n    else 0\nend\n</cell>\n<code language=julia-1.2>\n\"\"\"Return 2^n\
    \ modulo p (be aware of numerics).\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n\
    >>> modp(0, 101)\n1\n>>> modp(3, 11)\n8\n>>> modp(100, 101)\n1\n\"\"\"\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"mod\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp5d6seqs_.jl:15\nin expression starting at /tmp/tmp5d6seqs_.jl:15\n"
  stdout: ''
  timestamp: 1660009120
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n    then return 0 \n    else if n < p \n\
    \    then return n % p \n    else return n `mod` p\nend\n</cell>\n<code language=julia-1.6>\n\
    \"\"\"\nCompute the greatest common divisor of two numbers.\n\"\"\"\nusing Test\n\
    \n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp9nfehd98.jl:15\nin expression starting at /tmp/tmp9nfehd98.jl:15\n"
  stdout: ''
  timestamp: 1660009120
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    \"\"\"Compute the remainder of n mod p.\n    >>> modp(100,\
    \ 101)\n    1\n    \"\"\"\n\"\"\"\n    function modp(n::Int64, p::Int64)::Int64\
    \ \n    \"\"\"Compute the remainder of n mod p.\n    >>> modp(100, 101)\n    1\n\
    \    \"\"\"\n    return n - p + modm(p - 1, p)\nend\n</cell>\n<code language=julia-0.6>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: cannot juxtapose string literal\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw2mdua6n.jl:20\nin expression starting at\
    \ /tmp/tmpw2mdua6n.jl:20\n"
  stdout: ''
  timestamp: 1660009120
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then\n      1\n    else\n      modp(n - 1,\
    \ p) * p\nend\n</code>\n<|/ a tags=algorithm,math,modulus |>\n<| c |>\nThis solution\
    \ is O(n log n)\n<|/ c |>\n<| c |>\n, please note that I provided a solution for\
    \ computing modular exponentiation with a simple iterative process. The complexity\
    \ should be O(n).\n<|/ c |>\n<| c |>\nYou might want to add a bit of explanation\
    \ to your answer.\n<|/ c |>\n<| c |>\n`modp(x, p) = x % p`; `modp(n, p) = n %\
    \ p`.\n<|/ c |>\n<| c |>\n`modp(1000000000, 2)` gives `0`. Is that intentional?\
    \ Shouldn't it be `1`?\n<|/ c |>\n<| a dscore=5 |>\nThe modular exponentiation\
    \ algorithm\n<code>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphg62xd63.jl:19\nin expression starting at\
    \ /tmp/tmphg62xd63.jl:19\n"
  stdout: ''
  timestamp: 1660009120
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if (p == 0) \n        return n\n    if (n == 0) \n  \
    \      return p\n    return modp(n / p, p) * p\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1kgeyhem.jl:1\nin expression starting at /tmp/tmp1kgeyhem.jl:1\n"
  stdout: ''
  timestamp: 1660009120
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n\tif n <= 0\n\t\treturn 0\n\telseif n < p\n\t\treturn n\n\
    \telse\n\t\treturn modp(n - 1, p) * (p + 1) // modp(n - 1, p + 1)\nend\n</cell>\n\
    <text>\nWe can now use the function modp to check a number:\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3feca54g.jl:21\nin expression starting at\
    \ /tmp/tmp3feca54g.jl:21\n"
  stdout: ''
  timestamp: 1660009120
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n>p \n        then modp(divrem(n, p), p) \n      \
    \  else 1\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t\
    @test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"modp\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpzx3rb1pn.jl:15\nin expression starting at /tmp/tmpzx3rb1pn.jl:15\n"
  stdout: ''
  timestamp: 1660009120
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0 \n    then return 1\n    else if n % p == 0\n\
    \    then return n\n    else return modp(n / p, p)\nend\n</code>\n<|/ a tags=math,julia\
    \ |>\n<| a |>\nIt is not hard to prove that modp is incomplete and non-associative,\
    \ as it is in mathematics, though more generally associative.\nFrom the definition\
    \ of modular arithmetic:\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t\
    @test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp5q90tyhb.jl:15\nin expression starting at /tmp/tmp5q90tyhb.jl:15\n"
  stdout: ''
  timestamp: 1660009120
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 || p == 0 || n == p \n        then 0 \n   \
    \     else n rem p\nend\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t\
    @test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"0\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpsfhoshle.jl:15\nin expression starting at /tmp/tmpsfhoshle.jl:15\n"
  stdout: ''
  timestamp: 1660009120
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p < 2 || p > n\n        throw(DomainError(\"p must\
    \ be between 2 and n\"))\n    else if n < 2\n        throw(DomainError(\"n must\
    \ be >= 2\"))\n    else\n        p % n\n    end\nend\n</cell>\n<code language=julia-0.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpn8do5218.jl:16\nin expression starting at\
    \ /tmp/tmpn8do5218.jl:16\n"
  stdout: ''
  timestamp: 1660009120
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    \n    if p == 0 \n        then return 0\n    else if\
    \ n < p \n        then return 0\n    else return n % p\n    end\nend\n\"\"\"\n\
    # modp(n, p) is equivalent to p%n (but faster)\n\"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpmgppv26n.jl:16\nin expression starting at /tmp/tmpmgppv26n.jl:16\n"
  stdout: ''
  timestamp: 1660009120
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    \"\"\"Compute 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    \    if p < n\n        modinc = modp(n+1, p)\n        result = modp(n-1, p)\n\
    \        if result % 2 == 1\n            result += 1\n        result *= modinc\n\
    \        result\n    else\n        n\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpog0sb_i_.jl:1\nin expression starting at /tmp/tmpog0sb_i_.jl:1\n"
  stdout: ''
  timestamp: 1660009120
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0\n    then 1\n    else modp(n-1, p*2)+p\nend\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"1\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpgtjowjmy.jl:15\nin expression starting at /tmp/tmpgtjowjmy.jl:15\n"
  stdout: ''
  timestamp: 1660009120
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    \n    if n >= p, return p\n    if n <= 0, return 0\n\
    \    else if n % p == 0, return n % p\n    else if n % p == -1, return modp(n\
    \ - p % n, p) \n    else return modp(n / p, p)\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \",\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpqt_x2wp2.jl:15\nin expression starting at /tmp/tmpqt_x2wp2.jl:15\n"
  stdout: ''
  timestamp: 1660009120
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n    then return 0\n    else if n == 0\n \
    \   then return 1\n    else if n < 0\n    then return modp(abs(n), abs(p))\n \
    \   else return n % p\nend \n</code>\nThis version is much slower than modp.\n\
    The same code but with a faster modulo function can be found here.\n<|/ a dscore=1\
    \ |>\n<| a |>\nHere's a much faster solution using a hash table:\n<code>\nmodule\
    \ Hash\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpy_cj_9rc.jl:15\nin expression starting at /tmp/tmpy_cj_9rc.jl:15\n"
  stdout: ''
  timestamp: 1660009120
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n\"\"\"\nReturn the remainder of n divided by p, with integers\
    \ n.p and p.\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>>\
    \ modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n  \
    \  1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpoa_cpx_5.jl:13\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpoa_cpx_5.jl:1\n\
    in expression starting at /tmp/tmpoa_cpx_5.jl:1\n"
  stdout: ''
  timestamp: 1660009120
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n >= 0\n        modq = div(n, p)\n        if modq\
    \ == 0 \n            return 1\n        else\n            return n % p\n    else\n\
    \        return 0\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmp9libub4i.jl:16 expected \"\
    end\", got \"else\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp9libub4i.jl:20\n\
    in expression starting at /tmp/tmp9libub4i.jl:20\n"
  stdout: ''
  timestamp: 1660009120
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n<p \n        return n\n    elseif n>p\n        return\
    \ n-p\n    else\n        return modp(mod(n,p), p)\n    end \nend \n</cell>\n<code\
    \ language=julia-1.1>\n\"\"\"Return x^y modulo p (be aware of numerics).\n   \
    \ >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpszh4e6ys.jl:22\nin expression starting at\
    \ /tmp/tmpszh4e6ys.jl:22\n"
  stdout: ''
  timestamp: 1660009122
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 || n == p then\n        return 0\n    elif\
    \ n % p == 0 then\n        return modp(n div p, p) + 1\n    else\n        return\
    \ modp(n div p, p)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Return\
    \ 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101,\
    \ 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>>\
    \ modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"n\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpddauvufn.jl:16\nin expression starting at /tmp/tmpddauvufn.jl:16\n"
  stdout: ''
  timestamp: 1660009122
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    # assert n >= 0\n    # assert p >= 0\n    # assert n\
    \ <= p\n    if n <= p\n        return n\n    return modp(n - p, p) + p\nend #\
    \ modp\n</cell>\n<code language=julia-1.3>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjxx6k3ja.jl:21\nin expression starting at\
    \ /tmp/tmpjxx6k3ja.jl:21\n"
  stdout: ''
  timestamp: 1660009123
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n > 0 \n        then modp(n - 1, p) \n        else\
    \ p\n    else 0\nend\n</cell>\n<text>\nThe Modulo Operator %\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"modp\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpdz6nc6ab.jl:15\nin expression starting at /tmp/tmpdz6nc6ab.jl:15\n"
  stdout: ''
  timestamp: 1660009123
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    \"\"\"\n    >>> modp(3, 5)\n    3\n    >>> modp(1101,\
    \ 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>>\
    \ modp(100, 101)\n    1\n    \"\"\"\n    if n < p then\n        return n\n   \
    \ else\n        return div(n, p) * (p - 1) \nend \n</cell>\n<code language=julia-1.4>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpz2iypn0n.jl:31\nin expression starting at\
    \ /tmp/tmpz2iypn0n.jl:31\n"
  stdout: ''
  timestamp: 1660009123
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p > 0 && n > p\n        return n % p\n    else\n \
    \       return 0\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 7 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp8hftk91n.jl:22

    '
  stdout: "test set: Test Failed at /tmp/tmp8hftk91n.jl:25\n  Expression: candidate(3,\
    \ 5) == 3\n   Evaluated: 0 == 3\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8hftk91n.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8hftk91n.jl:24\ntest set: Test\
    \ Failed at /tmp/tmp8hftk91n.jl:26\n  Expression: candidate(1101, 101) == 2\n\
    \   Evaluated: 91 == 2\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8hftk91n.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8hftk91n.jl:24\ntest set: Test\
    \ Failed at /tmp/tmp8hftk91n.jl:27\n  Expression: candidate(0, 101) == 1\n   Evaluated:\
    \ 0 == 1\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8hftk91n.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8hftk91n.jl:24\ntest set: Test\
    \ Failed at /tmp/tmp8hftk91n.jl:28\n  Expression: candidate(3, 11) == 8\n   Evaluated:\
    \ 0 == 8\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8hftk91n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8hftk91n.jl:24\ntest set: Test\
    \ Failed at /tmp/tmp8hftk91n.jl:29\n  Expression: candidate(100, 101) == 1\n \
    \  Evaluated: 0 == 1\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8hftk91n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   "
  timestamp: 1660009124
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n\tif p == 0 then\n\t\treturn n\n\telse\n\t\treturn modp(n\
    \ >> 1, p) \n\tend\nend\n</cell>\n<code language=julia-1.4>\n#=\nThis cell contains\
    \ some helper functions:\n@modp(n, p) returns 2^n modulo p (be aware of numerics).\n\
    @modp(1101, 101) returns 2^1101 modulo 101.\n=#\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpanwk3j4s.jl:20\nin expression starting at\
    \ /tmp/tmpanwk3j4s.jl:20\n"
  stdout: ''
  timestamp: 1660009123
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    ans=mod2(n%p)\n    if(n>p) \n        ans=ans+1 if n<p\
    \ else ans\n    return ans\nend \n</code>\n<|/ a tags=algorithm,modular-arithmetic,primes,math,performance\
    \ |>\n<| a |>\nA simple approach: just try all primes up to p-1 and see which\
    \ of them divide n.\n<code>\ndef mod_prime(p, n, max_prime=1000000007):\n    if\
    \ n == 0:\n        return 0\n    if p == 0:\n        return 1\n    primes = primes_upto(max_prime\
    \ - 1)\n    factors = factorize(n)\n    count = 0\n    for p in primes:\n    \
    \    if factors[p] == p:\n            count += 1\n    return count\n</code>\n\
    For my implementation I used the factorization algorithm from this answer: https://stackoverflow.com/a/1033307/331654\n\
    <|/ a dscore=3 tags=algorithm,modular-arithmetic,primes,math,performance |>\n\
    <| c |>\nThe first part doesn't work (at least on my machine). `factorize` returns\
    \ `[2,3]` for 7 and `[2,2,2,3]` for 8\n<|/ c |>\n<| c |>\nFixed the code by adding\
    \ `if n==p: return 0` and `if p > max_prime: return 0` before the `for` loop.\n\
    <|/ c |>\n<| a tags=algorithm,modular-arithmetic,primes,math,performance |>\n\
    Here is my implementation in Julia:\n<code>\nusing Test\n\n@testset begin\n\n\
    candidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"if\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmps733mzbz.jl:16\nin expression starting at /tmp/tmps733mzbz.jl:16\n"
  stdout: ''
  timestamp: 1660009123
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if ((0 == p) && (0 == n)) { \n        return 1;\n   \
    \ }\n    return ((n & ((n-1) << (p-1)) - 1) % p) + 1;\nend\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nI love this solution. It's awesome and efficient. But there is\
    \ a caveat: the number should be positive. Otherwise, the negative numbers will\
    \ cause an overflow. The `%` operator would overflow.\n<|/ c |>\n<| c |>\nThis\
    \ works very well and is easy to understand. Thanks very much.\n<|/ c |>\n<| c\
    \ |>\nThank you for the heads up. This is a great answer, but can you explain\
    \ why it works? I'm looking at it more and it seems like you just wrote some modular\
    \ arithmetic.\n<|/ c |>\n<| c |>\nIt should be noted that it is very easy to get\
    \ a `modp` function that doesn't work when the number you are dealing with is\
    \ a negative number. For example, `modp(-5, 3)` returns `2` instead of `-1`. I've\
    \ done a little research and found [this question](https://math.stackexchange.com/questions/180524/why-do-we-need-a-mod-function-for-negative-numbers)\
    \ which details how to fix this issue.\n<|/ c |>\n<| c |>\nThis code is really\
    \ clever but fails for cases like `modp(2, 3)`. It returns `4` instead of `2`\n\
    <|/ c |>\n<| a dscore=4 |>\nI ran into this problem when writing a Python script\
    \ to manipulate large matrices, where I wanted a function that would work not\
    \ only for positive numbers but also negative ones. So, here's what I came up\
    \ with:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: space before \"{\" not allowed in \"(0 == p)\
    \ && (0 == n) {\" at /tmp/tmpq7dtsqqm.jl:14\nStacktrace:\n [1] top-level scope\n\
    \   @ /tmp/tmpq7dtsqqm.jl:14\nin expression starting at /tmp/tmpq7dtsqqm.jl:14\n"
  stdout: ''
  timestamp: 1660009123
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if n % p\
    \ == 0 \n        then return modp(n / p, p)\n    else \n        return modp(n\
    \ / p, p) + modp((n-1) / p, p)\nend\n</cell>\n<code language=julia-1.3>\n\"\"\"\
    \nReturn 2^n modulo p (be aware of numerics).\n\"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpym594pxf.jl:15\nin expression starting at /tmp/tmpym594pxf.jl:15\n"
  stdout: ''
  timestamp: 1660009123
- exit_code: -1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == p then\n        return n\n    else\n        return\
    \ modp(n % p, p)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660009126
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    return (p.*n) % (p)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 7 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7b7j9n67.jl:18

    '
  stdout: "test set: Test Failed at /tmp/tmp7b7j9n67.jl:21\n  Expression: candidate(3,\
    \ 5) == 3\n   Evaluated: 0 == 3\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7b7j9n67.jl:21 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7b7j9n67.jl:20\ntest set: Test\
    \ Failed at /tmp/tmp7b7j9n67.jl:22\n  Expression: candidate(1101, 101) == 2\n\
    \   Evaluated: 0 == 2\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7b7j9n67.jl:22 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7b7j9n67.jl:20\ntest set: Test\
    \ Failed at /tmp/tmp7b7j9n67.jl:23\n  Expression: candidate(0, 101) == 1\n   Evaluated:\
    \ 0 == 1\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7b7j9n67.jl:23 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7b7j9n67.jl:20\ntest set: Test\
    \ Failed at /tmp/tmp7b7j9n67.jl:24\n  Expression: candidate(3, 11) == 8\n   Evaluated:\
    \ 0 == 8\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7b7j9n67.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7b7j9n67.jl:20\ntest set: Test\
    \ Failed at /tmp/tmp7b7j9n67.jl:25\n  Expression: candidate(100, 101) == 1\n \
    \  Evaluated: 0 == 1\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7b7j9n67.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @"
  timestamp: 1660009124
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"mod: negative number\")\n\
    \    if n <= p \n        error(\"mod: number too small\")\n    mod = 0\n    div\
    \ = 1\n    while div < n \n        div *= p \n        mod += div \n    return\
    \ mod \nend \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpr_r1h99m.jl:1\nin expression starting at /tmp/tmpr_r1h99m.jl:1\n"
  stdout: ''
  timestamp: 1660009123
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= p then\n        return mod(n, p)\n    else\n\
    \        return mod((n + p - 1)%p, p)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 2 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmps97ef28n.jl:22

    '
  stdout: "test set: Error During Test at /tmp/tmps97ef28n.jl:25\n  Test threw exception\n\
    \  Expression: candidate(3, 5) == 3\n  UndefVarError: then not defined\n  Stacktrace:\n\
    \   [1] modp(n::Int64, p::Int64)\n     @ Main /tmp/tmps97ef28n.jl:14\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmps97ef28n.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmps97ef28n.jl:24\ntest set:\
    \ Test Failed at /tmp/tmps97ef28n.jl:26\n  Expression: candidate(1101, 101) ==\
    \ 2\n   Evaluated: 90 == 2\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmps97ef28n.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmps97ef28n.jl:24\ntest set: Error\
    \ During Test at /tmp/tmps97ef28n.jl:27\n  Test threw exception\n  Expression:\
    \ candidate(0, 101) == 1\n  UndefVarError: then not defined\n  Stacktrace:\n \
    \  [1] modp(n::Int64, p::Int64)\n     @ Main /tmp/tmps97ef28n.jl:14\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmps97ef28n.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmps97ef28n.jl:24\ntest set:\
    \ Error During Test at /tmp/tmps97ef28n.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(3, 11) == 8\n  UndefVarError: then not defined\n  Stacktrace:\n  \
    \ [1] modp(n::Int64, p::Int64)\n     @ Main /tmp/tmps97ef28n.jl:14\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmps97ef28n.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Te"
  timestamp: 1660009125
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 \n    then return p \n    else \n        if p==0\
    \ \n        then return 0\n        else \n            let r=modp(floor(n/p), p)\
    \ \n            if n%%p==0 \n            then return modp(floor(n/p),p)\n    \
    \        else return r\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"Return\
    \ nth prime number. \n    >>> prime(10)\n    7\n    >>> prime(1)\n    1\n    \"\
    \"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpdpgoyiqe.jl:15\nin expression starting at /tmp/tmpdpgoyiqe.jl:15\n"
  stdout: ''
  timestamp: 1660009123
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n  case n == p \n     when true \n       then return n \n\
    \     else return modp(n % p, p) \n  end\nend\n</code>\nAnd I guess it works,\
    \ as far as I can tell:\n<code>\njulia> modp(1101, 101)\n2\njulia> modp(100, 101)\n\
    1\njulia> modp(3, 11)\n8\njulia> modp(3, 5)\n3\njulia> modp(3, 0)\n1\njulia> modp(3,\
    \ 1)\n1\njulia> modp(3, 2)\n2\njulia> modp(3, 3)\n8\njulia> modp(3, 4)\n2\njulia>\
    \ modp(3, 5)\n3\njulia> modp(3, 6)\n2\njulia> modp(3, 7)\n4\njulia> modp(3, 8)\n\
    6\njulia> modp(3, 9)\n2\njulia> modp(3, 10)\n8\njulia> modp(3, 11)\n8\njulia>\
    \ modp(3, 12)\n6\njulia> modp(3, 13)\n4\njulia> modp(3, 14)\n2\njulia> modp(3,\
    \ 15)\n8\njulia> modp(3, 16)\n0\njulia> modp(3, 17)\n1\njulia> modp(3, 18)\n8\n\
    julia> modp(3, 19)\n0\njulia> modp(3, 20)\n1\njulia> modp(3, 21)\n1\njulia> modp(3,\
    \ 22)\n2\njulia> modp(3, 23)\n4\njulia> modp(3, 24)\n6\njulia> modp(3, 25)\n2\n\
    julia> modp(3, 26)\n8\njulia> modp(3, 27)\n0\njulia> modp(3, 28)\n1\njulia> modp(3,\
    \ 29)\n0\njulia> modp(3, 30)\n1\njulia> modp(3, 31)\n1\njulia> modp(3, 32)\n2\n\
    julia> modp(3, 33)\n8\njulia> modp(3, 34)\n0\njulia> modp(3, 35)\n1\njulia> modp(3,\
    \ 36)\n8\njulia> modp(3, 37)\n0\njulia> modp(3, 38)\n1\njulia> modp(3, 39)\n1\n\
    julia> modp(3, 40)\n2\n\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t\
    @test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"function\" at /tmp/tmp7ikka028.jl:13 expected\
    \ \"end\", got \"n\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp7ikka028.jl:14\n\
    in expression starting at /tmp/tmp7ikka028.jl:14\n"
  stdout: ''
  timestamp: 1660009123
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    return (2^n) %p\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpqex0op8l.jl:13\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpqex0op8l.jl:1\n\
    in expression starting at /tmp/tmpqex0op8l.jl:1\n"
  stdout: ''
  timestamp: 1660009123
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= p then n else p \n    end\n    return n `mod`\
    \ p\n</code>\n<|/ a |>\n<| c |>\nThis is correct. I don't think OP should just\
    \ give a function in an answer, but an explanation of how it works. Otherwise\
    \ this answer doesn't help anyone.\n<|/ c |>\n<| c |>\nThis should be the accepted\
    \ answer\n<|/ c |>\n<| a |>\n<code>\njulia> function modpow2(n::Int64,m::Int64)::Int64\n\
    \           return n*(n-1) `mod` m\n       end\nmodpow2 (generic function with\
    \ 1 method)\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"n\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpccp7rp9t.jl:14\nin expression starting at /tmp/tmpccp7rp9t.jl:14\n"
  stdout: ''
  timestamp: 1660009123
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    n %= p\n    if n < 0 \n        n += p\n    return n\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5)\
    \ == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpevwgqdgp.jl:13\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpevwgqdgp.jl:1\n\
    in expression starting at /tmp/tmpevwgqdgp.jl:1\n"
  stdout: ''
  timestamp: 1660009123
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    # modp(n) = (n^p + p^n) mod p\n    local a = powmod(n,\
    \ p, p)\n    local b = powmod(p, n, p)\n    return a + b\nend\n\"\"\"\nThe function\
    \ `powmod()` can be found [here](https://github.com/JuliaDiff/BitVector.jl/blob/master/src/BitVector.jl).\n\
    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: cannot document the following expression:\n\nusing Test\n\
    \nStacktrace:\n [1] error(::String, ::String)\n   @ Base ./error.jl:42\n [2] top-level\
    \ scope\n   @ /tmp/tmp1nkou505.jl:19\nin expression starting at /tmp/tmp1nkou505.jl:19\n"
  stdout: ''
  timestamp: 1660009123
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < p \n        return n\n    if n == 0 \n       \
    \ return p\n    if n >= p \n        return p - modp(n - p, p)\n    return 0\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5)\
    \ == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpebody5tn.jl:1\nin expression starting at /tmp/tmpebody5tn.jl:1\n"
  stdout: ''
  timestamp: 1660009123
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    mod = 0\n    while n > p\n        mod = mod + 1\n   \
    \     n = n - (n >> mod)\n    return n\nend\nusing Test\n\n@testset begin\n\n\
    candidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpopmwu7pg.jl:13\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpopmwu7pg.jl:1\n\
    in expression starting at /tmp/tmpopmwu7pg.jl:1\n"
  stdout: ''
  timestamp: 1660009123
