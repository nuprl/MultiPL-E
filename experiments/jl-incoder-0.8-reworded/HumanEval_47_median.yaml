name: HumanEval_47_median
language: jl
prompt: "\"\"\"Return median of elements in the vector l.\n    >>> median([3, 1, 2,\
  \ 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\
  \nfunction median(l::Vector{Int64})::Float64 \n"
tests: "using Test\n\n@testset begin\n\ncandidate = median;\n\t@test(candidate([3,\
  \ 1, 2, 4, 5]) == 3)\n\t@test(candidate([-10, 4, 6, 1000, 10, 20]) == 8.0)\n\t@test(candidate([5])\
  \ == 5)\n\t@test(candidate([6, 5]) == 5.5)\n\t@test(candidate([8, 1, 3, 9, 9, 2,\
  \ 7]) == 7)\nend\n"
completions: ["    return sort(l)[end]\nend\n</cell>\n<code language=julia-1.4>",
  "    return sort(l)[1]\nend\n</cell>\n<code language=julia-1.0>\nmedian([3, 1, 2,\
    \ 4, 5])\n</cell>\n<code language=julia-1.0>", "    if (length(l) < 0)\n     \
    \   throw(DomainError(\"\"))\n    end", "    half = floor(length(l) / 2)\n   \
    \ if isodd(length(l))\n        return median(l[half])\n    end\n    left = median(l[1\
    \ : half])\n    right = median(l[half + 1 : end])\n    return (left + right) /\
    \ 2\nend\n</cell>\n<text>\nExercise. Compute median of vectors with different\
    \ lengths.", "    return sort(l)[end-1]\nend\n</cell>\n<text>\nmedian is faster\
    \ than mean and std if there are few elements:", "    n = length(l); if n < 2\
    \ return l[1]\n    sort!(l)\n    l = l .- minimum(l)\n    return median(l[(n+1)/2-1:-1:2])\
    \ \nend\n</cell>\n<code language=julia-1.5>", "    \"\"\"If length of l is odd,\
    \ return l[l/2] else return l[l/2+1]\"\"\"\n    length::Int64 = length(l)\n  \
    \  if length%2==1\n        return (l[length/2] + l[length/2])/2\n    else\n  \
    \      return l[length/2]\nend", "    center = length(l)\n    if center % 2 ==\
    \ 0 \n        return median(l[begin:end-1]) + median(l[end-center+1:end-1]) \n\
    \    else \n        return median(l[begin:end-center]) + median(l[end-center+1:end])\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI'm new to julia and want to add median\
    \ to the code above. Could you please point me to which file should I add it to?\n\
    <|/ c |>\n<| c |>\nIt depends. If you have a single function and want to reuse\
    \ it, you can just add it directly to the top of the file, or if you have a `julia-0.6`\
    \ package, you can add the function to the file `Packages/Julia/statistics.jl`\n\
    <|/ c |>\n<| c |>\nCould you please tell me why median isn't in statistics.jl?\n\
    <|/ c |>\n<| c |>\nIf you're using julia-0.6, it won't be there yet. There was\
    \ a PR to add it to the stats package that wasn't merged into master yet (https://github.com/JuliaLang/julia/pull/14373)\n\
    <|/ c |>\n<| c |>\nThank you! I added the function to the file Packages/Julia/statistics.jl,\
    \ but I get the following error when I run julia:", "    sort!(l)\n    l = sort(l)\n\
    \    length(l) > 1 ? middle = l[length(l)/2] : middle = sort(l[1])\n    middle\n\
    end\nmedian(collect(1:10));\n</cell>\n<code language=julia-1.3>\nmedian([3, 1,\
    \ 2, 4, 5]); \n</cell>\n<text>\nReturn median of elements in the vector l if they\
    \ are greater than median; otherwise, return l.", "    return (sort(l))[end]\n\
    end", "    n = length(l) \n    return sort(l)[n div 2] \nend", "    if isempty(l)\n\
    \        return 0\n    median = sum(l)\n    if median % 2 != 0\n        median\
    \ = median + 1\n    end\n    return median/2", "    sorted_list = sort(l)\n  \
    \  mid = (length(sorted_list) + 1)/2\n    return sorted_list[mid]\nend", "   \
    \ return sort(l) |> ceil |> ceil\nend", "    if len(l) \u2264 2 \n        return\
    \ l[1] \n    \n    pivot = l[(length(l)-1)/2]\n    \n    for x in l[1..length(l)-1]\n\
    \        if x < pivot \n            return x\n        \n    return pivot\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThanks, I thought there was a simpler solution\n\
    <|/ c |>\n<| a |>\nYou could use sort! to do this in O(n) time.\n<code>\nmedian\
    \ = median = sort(l)[1]\n</code>\nOr just return the sorted list\n<code>\nmedian\
    \ = sort(l)[1]\n</code>\n<|/ a dscore=0 tags=julia,statistics |>\n<| a |>\nAs\
    \ others stated, you can use the median function provided in the Statistics package.\
    \ This should perform well on sorted lists. Another option is to convert it into\
    \ a vector and get the first element:\n<code>\nmedian([3, 1, 2, 4, 5])\n</code>\n\
    <|/ a dscore=0 tags=julia,statistics |>\n<| c |>\nThat is true, but the question\
    \ is *not* about performance.\n<|/ c |>\n<| c |>\nYes you are right, I missed\
    \ that. However, my answer was meant as an alternative to the answer provided\
    \ by Andrew.\n<|/ c |>\n<| c |>\nNo, Andrew's answer is not correct because it\
    \ does not return the median of the vector (at least with Julia 1.5.0).\n<|/ c\
    \ |>\n<| a dscore=0 tags=julia,statistics |>\nIf you'd like to implement this\
    \ yourself, you can do it in O(n) by doing two loops and comparing each element\
    \ to the median of the previous elements in the loop. Here's the code for the\
    \ function:\n<code>", "    \n    sort(l)\n    middle = length(l)\n    if middle\
    \ % 2 == 0\n        return median(l[middle/2]) + median(l[(middle/2) + 1 .. middle])/2\n\
    \    else\n        return median(l[middle/2])\nend\n</code>\n<|/ a tags=median,julia,bubble-sort\
    \ dscore=0 |>\n<| a |>\nI agree with Anthony's answer, but I would add an improvement:\
    \ the median should be computed using the first element as the median value, and\
    \ the last element as the median value if the length of the vector is odd:\n<code>",
  "    return mean(l)\nend\nmedian()", "    sort(l)\n    \n    return l[floor(Int,\
    \ length(l)/2)]\nend", "    \"\"\"Calculate the median of a vector.\n    \"\"\"",
  "    \"\"\"\n    Compute median of elements in the vector l.\n    \"\"\"\n    \n\
    \    n = length(l)\n    \n    if n==0 \n        error(\"median requires at least\
    \ one non-empty vector\")\n    end\n    \n    n = n <= length(medians)? length(medians)\
    \ : n\n    \n    medians[i] = median(l); push!(medians, medians[i])\n    \n  \
    \  if n < length(medians)\n        medians[i] = median(medians[2:end])\n    end\n\
    \    \n    return medians[i]\nend\nmedian(l)\n</cell>\n<code language=julia-0.6>",
  "    n = length(l)\n    \n    if n == 0\n        return nan\n    end\n    \n   \
    \ if n <= 1\n        return l[1]\n    end\n    \n    idx = findall(l) # indices\
    \ of non-NaN elements\n    \n    median_idx = length(idx)/2\n    \n    med = nanmean(l[idx[median_idx]])\
    \ # median of non-NaN elements\n    \n    return med\nend\n</cell>\n<code language=julia-1.6>\n\
    median([3, 1, 2, 4, 5])\n</cell>\n<text>\nThe median of a finite set is the number\
    \ of the set in which \nthe arithmetic mean is closest to the middle of the set.",
  "\"\"\"Return the median of elements in the vector l.\"\"\"\n    sort(l)\n    length(l)\
    \ / 2\n    return l[end]\nend", "     \n    sortedL = sort(l)\n    \n    if length(sortedL)\
    \ >= 2 \n        mid = ceil(length(sortedL)/2) \n        median = median(sortedL[mid-1:end])\n\
    \    elseif length(sortedL) >= 1 \n        median = sortedL[1]\n    else \n  \
    \      median = 0\n    end\n    return median\nend\n</cell>\n<cell>\nmedian([10,\
    \ 1, 2, 4, 50])\n</cell>\n<text>\n4.2.4 Other operations\nA function to create\
    \ a vector containing the squared values of all elements in a given vector.\n\
    The function should work on both real and complex vectors.", "    return median(l)\n\
    end", "    pos = findfirst(l==0)\n    if pos==nothing\n        return mean(l)\n\
    \    end\n    \n    median = Int64(ceil(l[pos]/2.))\n    for i in  pos-1:-1:1\n\
    \        if l[i]==0\n            median = (median < Int64(ceil(min(l[pos:pos+2]))))\
    \ ? median+1 : median\n        elseif l[i]>median\n            median = (median\
    \ < Int64(ceil(min(l[pos:pos+2])))) ? median+1 : median\n        end\n    end\n\
    \    return median\nend", "    # median - return the median of the elements of\
    \ vector l\n    nbins = length(l)\n    binsum = 0.0\n    binsum2 = 0\n    l =\
    \ sort(l)\n    \n    for i in 2:nbins-1\n        if l[i] > l[i-1]\n          \
    \  break\n        else\n            binsum += l[i-1]\n            binsum2 += (i-1)*l[i-1]\n\
    \    end\n    \n    if nbins % 2\n        return ((binsum2 + binsum)/2.0 + binsum)\n\
    \    else\n        return (binsum2 + binsum)/2.0\n    end\nend", "    \"\"\"\n\
    \    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10,\
    \ 20])\n    15.0\n    \"\"\"\n    return sort(l).median\nend\n</cell>\n<code language=julia-1.5>\n\
    median([3, 1, 2, 4, 5])\n</cell>\n<text>\nExercise 5", "    sort(l)\n    return\
    \ l[end]\nend\n</cell>\n<code language=julia-1.0>\nmedian([3, 1, 2, 4, 5])\n</cell>\n\
    <code language=julia-1.0>\nmedian([-10, 4, 6, 1000, 10, 20])\n</cell>\n<text>\n\
    The second function which returns the element of vector l at position i. if i\
    \ == length(l) then return missingvalue. Note that this function is missing a\
    \ return statement if l is empty or if i is not in the range of 1 to length(l)",
  "\tmedian = sort(l)[2]\nend", "    sort(l)\n    m = length(l) / 2\n    return l[m]\n\
    end", "    len <- length(l) \n    if (len == 0) \n        throw(ZeroDivisionError(\"\
    median called with an empty vector\"))\n    elif (len == 1) \n        return l[0]\
    \ \n    \n    center = (len/2) - 1\n    if center%2 == 0 \n        return (median(l[center:len]))\
    \ \n    else \n        return (median(l[center:center+1])) + (median(l[center+1:len]))\
    \ \nend ", "    l.sort()\n    n = length(l)\n    @assert n >= 2\n    return (l[n-1]+l[n])/2\n\
    end\n</cell>\n<code language=julia-0.6>\nmedian([3, 1, 2, 4, 5])\n</cell>\n<code\
    \ language=julia-0.6>\nmedian([-10, 4, 6, 1000, 10, 20])\n</cell>\n<text>\nMedian\
    \ Absolute Deviation\nCalculate the median absolute deviation", "    l = sort(l)\n\
    \    mid_idx = length(l)\n    if mid_idx % 2 == 0\n        return l[mid_idx//2]\n\
    \    else\n        return (l[mid_idx//2] + l[mid_idx//2-1])/2.0\n    end\nend",
  "    s = sort(l)\n    return s[1]\nend\n\"\"\"Return median of elements in the vector\
    \ l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000,\
    \ 10, 20])\n    15.0\n    \"\"\"", "    sort(l)\n    return l[(length(l)-1)/2]\n\
    end\n</cell>\n<code language=julia-1.5>\n# median of vector\n@assert median([3,\
    \ 4, 5]) == 3\n@assert median([-10, 4, 6, 1000, 10, 20]) == 15\n</cell>\n<text>\n\
    Median Absolute Deviation\nCalculate median absolute deviation (MAD) of the numbers\
    \ in the given array using Median-Moving Absolute Deviation (MMAAD).", "    if\
    \ length(l) == 0\n        error(\"median requires at least one element in the\
    \ vector\")\n    end\n    @assert length(l)==1 \"median requires a vector of length\
    \ one\"\n    @assert !all(isinf(x) | isnan(x) for x in l) \"median only works\
    \ on real numbers\"\n    @assert !any(isnan(x) | isinf(x) | x<0 for x in l) \"\
    median only works on non-negative numbers\"\n    if l[1] > 0\n        @assert\
    \ l[1] < l[2] \"median does not handle a zero element correctly\"\n        median\
    \ = l[1]\n    else\n        @assert l[2] > l[1] \"median does not handle a zero\
    \ element correctly\"\n        median = l[2]\n    end\n    return median\nend",
  "    sortedVec = sort(l)\n    if length(sortedVec) == 0 \n        throw(NoSolutionException())\n\
    \    end\n    middleIdx = (length(l)+1)//2\n    return sortedVec[middleIdx]\n\
    end\n</cell>\n<code language=julia-1.5>\nmedian([3, 1, 2, 4, 5])\n</cell>\n<code\
    \ language=julia-1.5>\nmedian([-10, 4, 6, 1000, 10, 20])\n</cell>\n<text>\nExercise\
    \ 1: Write a function to determine whether one vector is a permutation of another\
    \ vector.\nInputs:", "    n = 0\n    for i in l \n        n = n + 1\n    end\n\
    \    m = 0.0\n    for i = 1:n\n        m = (m * i) + l[(i-1)%n]\n    end\n   \
    \ return m/(Float64(n))\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI added the\
    \ median function to the original post\n<|/ c |>\n<| c |>\nI added the median\
    \ function to the original post\n<|/ c |>\n<| c |>\n, `median(l)` already returns\
    \ the median. You don't need to call `median` in your `if` blocks. `if (length(l)==1)\
    \ return l[1]; ...`.\n<|/ c |>\n<| c |>\nOk I added my own median function to\
    \ the original post. Is there something wrong with it?\n<|/ c |>\n<| c |>\n, no,\
    \ your code looks fine.\n<|/ c |>\n<| a dscore=2 |>\nYou want to use median in\
    \ R for this\n<code>\nmedian(vec)\n</code>\nmedian returns the median of a vector.\
    \ You can use it to find the median of a given number in an array without looping.\n\
    <|/ a tags=median,julia,arrays,performance |>\n<| a dscore=1 |>\nThe median of\
    \ N numbers is basically the number that is halfway between all numbers:\n<code>\n\
    median([1,2,3,4,5]) = 1.5\n</code>\nThis means if you have an array of N numbers,\
    \ you just need to find the average of the first, last and middle numbers in the\
    \ array to get the median.\n<|/ a tags=median,julia,arrays,performance |>\n<|\
    \ a |>\nJust for reference, median function in Julia is implemented as:\n<code>\n\
    # median([1,4,6,7])\n# 6\n# median([2,4,5,6])\n# 5\n# median([3,5,7,9])\n# 5\n\
    # median([2,4,5,6])\n# 5\n# median([1,1,2,1])\n# 1\n# median([1,2,2,1])\n# 2\n\
    # median([1,1,2,1])\n# 1\n</code>\nand more generally:\n<code>\n# median([1,2,3,4,5,6,7,8,9])\n\
    # 5.5\n# median([1,2,3,4,5,6,7,8,9,10])\n# 5.5\n# median([1,2,3,4,5,6,7,8,9,10])\n\
    # 5.5\n# median([1,2,3,4,5,6,7,8,9,10])\n# 5.5\n# median([1,2,3,4,5,6,7,8,9,10])\n\
    # 5.5\n# median([1,2,3,4,5,6,7,8,9,10])\n", "    mid = ceil(l/2)\n    if mid ==\
    \ l\n        return 0.5\n    if mid % 2\n        return l[mid - 1]\n    else\n\
    \        return l[mid - 1] + median(l[mid : end - 1]) \n    end\nend\nmedian(l)\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"Return median of elements in the\
    \ vector l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6,\
    \ 1000, 10, 20])\n    15.0\n    \"\"\"", "  \n  n = length(l)\n  \n  if n < 2\
    \ \n    throw(DomainError(1, \n      \"median requires at least one value to compare\"\
    ))\n  end\n  \n  sort(l)\n  \n  if n <= 1 \n    return l[1]\n  end\n  \n  pivot\
    \ = floor(n/2)\n  \n  begin\n    if l[pivot] == l[pivot-1] \n      return l[pivot-1]\n\
    \    end\n  \n    if l[pivot] == l[pivot+1] \n      return l[pivot+1]\n    end\n\
    \  \n    if l[pivot] > l[pivot-1] \n      return l[pivot]\n    end\n  \n    return\
    \ l[pivot-1]\n  end \nend\n</cell>\n<text>\n6. Finding Mode", "    return sort(l)[((length(l)+1)/2)]\n\
    end\n</cell>\n<code language=julia-0.5>\nmedian([3, 1, 2, 4, 5])\n</cell>\n<text>\n\
    Exercises", "    sort(l)\n    lenL = length(l)\n    if lenL % 2 == 1\n       \
    \ lenL -= 1\n    end\n    return mean(cast(l, Float64) / lenL)\nend", "    sort!(l);\
    \ \n    med = l[floor((length(l)-1)/2)] \n    i = 1 \n    while i < length(l)-1\
    \ \n        if l[i] == l[(i+1)%length(l)] \n            i += 1 \n        else\
    \ \n            med = l[floor((length(l)-2)/2)] + l[floor((length(l)-1)/2)] \n\
    \            i = 1 \n        end\n    end\n    return med\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert median([3, 1, 2, 4, 5]) == 3\n@assert median([-10,\
    \ 4, 6, 1000, 10, 20]) == 15.0\n@assert median([-4, 3, 2, 1]) == 2.0\n</cell>\n\
    <text>\nQuickselect algorithm\nThis function takes a vector l and returns the\
    \ element at position i in the array after selecting all elements with indices\
    \ in partition(l,i,j). The function returns the median element of l if l has more\
    \ than one median element.", "  if issorted(l) == true\n    return l[(length(l)+1)/2-1]\n\
    \  else\n    return mean(l)\n  end\nend\n</cell>\n<cell>\n\"\"\"\n    mean(l::Vector{T})\
    \ where T <: AbstractFloat\n    Computes the mean of elements.", "    return quantile(Vector{Float64}(sort(l)))\n\
    end\n</cell>\n<text>\nThe median function is really useful for working with groups\
    \ of numbers that are similar in some way.", "  median_val = 0.0\n  n_elements\
    \ = 0.0\n  for elt in l\n    median_val += elt\n    n_elements += 1\n  end\n \
    \ median_val/n_elements\nend\n</cell>\n<code language=julia-1.0>\n@code_native\n\
    median([3, 1, 2, 4, 5])\n</cell>\n<code language=julia-1.0>\n@code_native\nmedian([-10,\
    \ 4, 6, 1000, 10, 20])\n</cell>\n<text>\nMedian Absolute Deviation\nThe median\
    \ absolute deviation (MAD) is a measure of statistical dispersion that is a more\
    \ robust version of the standard deviation. MAD compares the median value of data\
    \ points to the distribution of data points, using an alternative measure of deviation\
    \ called the median absolute deviation.", "    \n    sorted = sort(l)\n    sortedlen\
    \ = length(sorted)\n    midpoint = sortedlen/2\n    if sortedlen % 2 == 0\n  \
    \      return sorted[midpoint]\n    else\n        return 0.5 * (sorted[midpoint-1]\
    \ + sorted[midpoint])\n    end\nend\n</cell>\n<code language=julia-1.5>\nmedian([3,\
    \ 1, 2, 4, 5])\n</cell>\n<code language=julia-1.5>\nmedian([-10, 4, 6, 1000, 10,\
    \ 20])\n</cell>\n<text>\nFunctions length", "    return mean(l)\nend\n</cell>\n\
    <code language=julia-1.3>\n\"\"\"Return a random permutation of the elements of\
    \ l.\n    >>> randperm([1,2,3])\n    3-element Array{Int64,1}:\n     4\n     5\n\
    \     2\n\"\"\"", "\tl = sort(l)\n\th = (length(l)+1)/2\n\tif (length(l)+1)%2\
    \ == 1\n\t\treturn ((l[h]+l[h-1])/2)\n\telse\n\t\treturn l[h]\n\tend\nend\n\"\"\
    \"Return mean of elements in the vector l.\"\"\"", "    s = length(l); \n    sort!(l)\n\
    \    if s == 0 or s <= 2 \n        return 0 \n    \n    middle = s/2\n    if s[middle]\
    \ == s[middle-1] \n        return median(l[middle-1:middle+1]) \n    else \n \
    \       return median(l[middle:middle+2]) \nend", "    return median(l)\nend\n\
    </cell>\n<text>\nExercise 3\nWrite median function with multiple arguments median(m::Vector{Float64},\
    \ n::Int64)::Float64. Recall that median is defined as: median(l) = (l[end] +\
    \ l[end - 1])/2.", "    if isempty(l) \n        return NaN\n    l = sort(l)\n\
    \    len = length(l)\n    return len ? l[len//2] : NaN\nend", "    n = length(l)\n\
    \    sort(l)\n    return (n/2-1).*median(l[n/2:end]) + l[floor(n/2-1)] \nend\n\
    </cell>\n<code language=julia-1.5>\n# median([3, 1, 2, 4, 5])\n# median([-10,\
    \ 4, 6, 1000, 10, 20])\n</cell>\n<text>\nExercise\nWrite a function that generates\
    \ two vectors containing all even and odd numbers between 0 and N (where N is\
    \ a given argument) and then calculates the mean of each vector.\nPrint the mean\
    \ of every vector to the screen using println()", "    sort(l)\n    \n    if l.length\
    \ == 0\n        throw(ArgumentError(\"median requires at least one element\"))\n\
    \    end\n    \n    return l[length(l)//2]\nend\n</cell>\n<code language=julia-1.3>\n\
    median([3, 1, 2, 4, 5])\n</cell>\n<code language=julia-1.3>\nmedian([-10, 4, 6,\
    \ 1000, 10, 20])\n</cell>\n<text>\nmedian!", "    median(l)/2\nend", "    sorted\
    \ = sort(l)\n    length= length(sorted)\n    if length <= 1\n        throw ErrorException(\"\
    Vector too small\")\n    end\n    return sorted[(length-1)/2]\nend", "    return\
    \ sort(l)[end-1]\nend", "    sortedIndices = sort(l)\n    length = length(l)\n\
    \    if length == 0 || length == 1\n        return sortedIndices[1]\n    end\n\
    \    halfway = (length(sortedIndices) + 1)/2\n    return sortedIndices[halfway]\
    \ \nend\nmedian\n</cell>\n<code language=julia-0.4>\nmedian([3, 1, 2, 4, 5])\n\
    </cell>\n<code language=julia-0.4>\nmedian([-10, 4, 6, 1000, 10, 20])\n</cell>\n\
    <text>\n4.2 Mean of a vector\nExercise: Write a function that returns the mean\
    \ of a vector.", "    l = sorted(l)\n    if length(l)==0 \n        return NaN\n\
    \    median = l[(length(l)/2)-1]\n    others = l[1:(length(l)/2)]\n    median\
    \ = medianmedian(median, others)\n    return median\nend", "    \n    n = 0\n\
    \    for x in l\n        n += x\n    end\n    \n    n /= length(l)\n    return\
    \ n\nend", "  \n  l = sort(l)\n  return l[end-1]\nend", "    sort(l)\n    return\
    \ l[(length(l)/2)]\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\nmedian(x\
    \ :: Vector{Int64}) returns a vector of medians.\n\"\"\"", "    \n    if length(l)==0\
    \ \n        return 0 \n    \n    l.sort()\n    median = (length(l)-1)/2\n    \n\
    \    return l[median]", "    l.sort()\n    n = length(l)\n    (k+2k)/2\nend",
  "    sort(l)\n    return l[length(l)]/2\nend", "    return mean(l) \nend\n\"\"\"\
    \nReturn the median of the given list l.\n\"\"\"", "    sort!(l)\n    n = length(l)\n\
    \    if n > 0\n        l[ceil(n)-1]\n    else\n        error(\"median requires\
    \ at least one element to compute\")\n    end\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nNice job! I love that `ceil` is used.\n<|/ c |>\n<| c |>\nYes, `ceil`\
    \ is really elegant.\n<|/ c |>\n<| c |>\nNice solution. Just a note about `ceil`:\
    \ it seems `ceil` doesn't work the same way as `round`. E.g. for Vector{Int64}\
    \ `[2,4,4,4]`, it will return `4` instead of `2`.\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>\nmedian = (l) -> (length(l)==0) ?\n    (error(\"median requires at least\
    \ one element to compute\")) :\n    (sort(l).last)\n</code>\n<|/ a tags=julia,arrays\
    \ |>\n<| c |>\nWhile this code may solve the question, [including an explanation](//meta.stackexchange.com/q/114762)\
    \ of how and why this solves the problem would really help to improve the quality\
    \ of your post, and probably result in more up-votes. Remember that you are answering\
    \ the question for readers in the future, not just the person asking now. Please\
    \ [edit] your answer to add explanations and give an indication of what limitations\
    \ and assumptions apply.\n<|/ c |>\n<| c |>\nThank you for this code snippet,\
    \ which may provide some immediate help.  A proper explanation [would greatly\
    \ improve](//meta.stackexchange.com/q/114762) its educational value by showing\
    \ *why* this is a good solution to the problem, and would make it more useful\
    \ to future readers with similar, but not identical, questions.  Please [edit]\
    \ your answer to add explanation, and give an indication of what limitations and\
    \ assumptions apply.\n<|/ c |>\n<| c |>\nThe comment was intended to be more of\
    \ an explanation for why your post was voted down, and a note about how this solution\
    \ will give an error instead of giving `NaN` when the number of elements in the\
    \ vector is 0.\n<|/ c |>\n<| c |>\nGood point - it didn't occur to me to check\
    \ for zero length. I'll update my answer.\n<|/ c |>\n<| a |>\nYou could use nth\
    \ from Statistics.jl:\n<code>\nusing Statistics", "    return sort(l).mid\nend",
  "    if length(l) == 0 \n        return NaN\n    return median(sort(l))\nend\n</cell>\n\
    <code language=julia-1.3>\nmedian([3,1])\n</cell>\n<text>\nStandard Deviation",
  "    l.sort()\n    return l[floor(Int, length(l)-1)/2] \nend\n</cell>\n<text>\n\
    median", "    sort(l)\n    return l[(length(l)-1)//2]\nend", "    n = length(l)\n\
    \    if n == 0 \n        return Inf \n    \n    \n    # calculate the sum of all\
    \ elements smaller than the median\n    leftSum = 0.0\n    for i = 1:n-1 \n  \
    \      if l[i] < l[n/2] \n            leftSum += l[i] \n        else \n      \
    \      break\n    \n    # calculate the sum of all elements bigger than the median\n\
    \    rightSum = 0.0\n    for i = n+1:n+n \n        if l[i] < l[n/2] \n       \
    \     rightSum += l[i] \n        else \n            break\n            \n    #\
    \ find the median\n    if leftSum < rightSum \n        median = (l[floor(Int64,\
    \ n/2)] + l[ceil(Int64, n/2)]) \n    else \n        median = (l[ceil(Int64, n/2)]\
    \ + l[floor(Int64, n/2)])\n    end", "    idx = sort(l, by=identity)\n    if idx[length(idx)//2]\
    \ > length(l)/2\n        return idx[length(idx)//2]\n    else\n        return\
    \ idx[length(idx)//2]\n    end\nend", "    return findmedian(l)\nend\n</cell>\n\
    <code language=julia-0.6>", "    l = sort(l)\n    l = median(l)\n    return l\n\
    end", "    center = median(l)\n    l = sort(l)\n    if isfinite(center)\n    \
    \    return (l[end]-l[begin])/2\n    endindex = length(l)\n    if endindex==0\
    \ || endindex==1\n        return mid(l) \n    end\n    lowerbound = l[endindex-1]\n\
    \    upperbound = l[end]\n    if upperbound-lowerbound < 2\n        return median(l)\n\
    \    end\n    if lowerbound <= lowerbound # only one point\n        middle = middle(l,1,endindex)\n\
    \    else\n        middle = middle(l,endindex,1)\n    end\n    return middle \n\
    end", "    half = floor(Int, length(l)/2)\n    sort(l); l = l[(half+1):end]\n\
    \    mid = length(l)\n    if length(l)%2==0 \n        half = half+1\n        return\
    \ 0.5 * (l[half] + l[half-1]) \n    else \n        return l[half]\n    end\nend",
  "    if length(l) == 0 \n        error(\"median requires the vector to be non-empty.\"\
    )\n    end", "    return sort(l).median\nend", "    if length(l) == 0 \n     \
    \   throw(ErrorException(\"Cannot calculate median for an empty vector\"))\n \
    \   end\n    \n    # sort and return the middle element (index 1)\n    return\
    \ mean(sort(l)[2:end])\nend\n</cell>\n<code language=julia-1.5>", "    \"\"\"\
    return median of elements in the vector l\"\"\"\n    sort(l)\n    return l[end]\n\
    end\n</cell>\n<code language=julia-1.0>\n\"\"\"Return a new vector where all elements\
    \ match the given predicate p\"\"\"", "    lmedian = median(l)\n    if lmedian\
    \ == 0\n        return Float64(1.0)\n    end\n    llength = length(l)\n    if\
    \ llength % 2 == 0\n        llength = llength /2\n    end\n    lmedian = (l[end]\
    \ + l[end-1]) / 2\nend", "    sort(l)\n    mid_idx = length(l)//2\n    if length(l)%2==0\n\
    \        return ((l[mid_idx]+l[mid_idx-1])/2)\n    else\n        return l[mid_idx]\n\
    \    end\nend", "    if len(l) <= 0\n        throw(ArgumentError(\"median requires\
    \ at least one element\"))\n    end\n    sorted = sort(l)\n    return sorted[end/2-1]\n\
    end\n</cell>\n<code language=julia-1.5>\nmedian([3, 1, 2, 4, 5])\n</cell>\n<text>\n\
    Part 2: Deviation", "    z = sort(l)\n    len = length(z)\n    mid = len/2\n \
    \   if len%2 != 0\n        return z[mid]\n    else\n        return (z[mid-1] +\
    \ z[mid])/2\n    end\nend\n</code>\n<|/ a dscore=3 |>\n<| a |>\nYou can use mean,\
    \ which has special handling for the case of empty vectors:\n<code>\nmean([])\n\
    </code>\ngives an error, but \n<code>\nmean([1])\n</code>\ngives an answer of\
    \ 1.\n<|/ a tags=julia,statistics dscore=2 |>\n<| a |>\nJust for completeness,\
    \ one can also use the following for non-scalars:\n<code>\njulia> mean([3, 1,\
    \ 2, 4, 5])\n3.0", "    l = sort(l)\n    n = length(l)/2\n    if n < 2\n     \
    \   error(\"median requires at least two elements\")\n    end\n    median = l[n]\n\
    \    for i in 1:n-1\n        median = l[(i + n + 1)/2] + median\n    end\n   \
    \ median\nend", "    n=length(l)\n    if n==0\n        throw(ArgumentError(\"\
    median requires at least one element\"))\n    end", "    if len(l) == 0 \n   \
    \     return Float64(0)\n    \n    return median(sort(l))\nend", "    l.sort()\n\
    \    sort(l)\n    return l[round(Int64, floor(Int64, length(l)/2)-1)]\nend", " \
    \   if length(l)>0 then \n        sort(l) \n        return median(l) \n    else\
    \ \n        return Float64(NaN) \n    end\nend\n\"\"\"\nReturn the largest element\
    \ in the vector l.\n    >>> largest([3, 1, 2, 4, 5])\n    5\n    >>> largest([-10,\
    \ 4, 6, 1000, 10, 20])\n    1000\n\"\"\"", "\tn = length(l) \n\tif n < 2 \n\t\t\
    return 0 \n\telse \n\t\tmed  = median(l[1:(n-1)/2]) \n\t\tfor i in 1:(n-1)/2-1\
    \ \n\t\t\tmed = (med+l[i])/2\n\t\tend \n\t\treturn med\n\tend\nend\n</cell>\n\
    <code language=julia-1.5>\n@time median([3, 5, 7, 4, 6, 8])\n</cell>\n<text>\n\
    4.3 Function to sort a vector of integers\nWrite a function that takes a vector\
    \ of integers and sorts them in ascending order.", "    sort(l)\n    return l[end]\n\
    end\n</cell>\n<code language=julia-1.5>\n# median()\n</cell>\n<text>\nFinding\
    \ outliers\nWe could calculate the median manually, but Julia provides outlier\
    \ detection:", "    return sort(l)[length(l)//2]\nend", "\t\n\tsort!(l)", "  \
    \  return Statistics.median(l)\nend", "    if len(l) < 1\n        throw(ZeroDivisionError(\"\
    median of an empty vector\"))\n    end", "    return (sort(l)[end-1]+sort(l)[end])/2\n\
    end\n</cell>\n<text>\nmedian() in Julia's built-in Math module returns the median\
    \ of a vector", "  sort(l)\n  d = floor(Int, length(l)/2)\n  if length(l)%2 ==0\
    \  \n    return median(l[d:end])\n  else\n    return median(l[d:end-1]) + median(l[end-1:end])\n\
    \  end\nend\n\"\"\"\nReturns the average of the numbers in the vector\n\"\"\"",
  "    l = sort(l)\n    mid = (length(l)+1)/2\n    if mid % 2 == 1 \n        return\
    \ mid\n    else \n        return (l[mid-1]+l[mid])/2\nend", "    sort(l)\n   \
    \ l = Vector{Int64}(l)\n    l = l[end-1]\n    l./=2\n    return l\nend", "   \
    \ return Statistics.mean(l)\nend", "    if len(l) ==0 \n        return Float64(0)\n\
    \    indx = findfirst(a -> a<(length(l)-1), l) \n    if indx == -1 \n        return\
    \ Float64(l[indx])\n    indx = indx + 1\n    \n    l = l .- indx \n    \n    indx\
    \ = findlast(a -> a<(length(l)-1), l) \n    if indx == -1 \n        return Float64(l[indx])\n\
    \    indx = indx - 1\n    \n    return ((l[indx] + l[indx+1])/2)\nend", "    if\
    \ l==[] \n        return Float64(\"nan\") \n    \n    count = length(l) \n   \
    \ \n    if count == 0 \n        return Float64(\"nan\") \n    \n    if count ==\
    \ 1 \n        return l[1] \n    \n    mid = (count-1)/2\n    \n    if l[mid] <\
    \ l[mid+1] \n        return l[mid]\n    \n    return l[mid]\nend\n</cell>\n<text>\n\
    A few more functions for the notebook", "        len= length(l);\n        if (len==0)\
    \ \n            return nan \n        else \n            return sort(l)[len/2]\n\
    end", "    len::Int64 = length(l)\n    if len%2 == 1\n        return median(sort(l)[len/2:end])\n\
    \    else\n        return median(sort(l)[ceil(len/2):floor(len/2)])\n    end\n\
    end", "    return median(l, 0, length(l)-1)\nend", "    if length(l)==0 \n   \
    \     throw(ZeroDivisionError(\"cannot compute median for an empty vector\"))\n\
    \    end\n    sort(l)\n    return l[end-1]\nend\n</cell>\n<code language=julia-1.4>\n\
    ## Let's try it out!\nmedian([3, 1, 2, 4, 5])\n</cell>\n<code language=julia-1.4>\n\
    median([-10, 4, 6, 1000, 10, 20])\n</cell>\n<text>\nThe next function computes\
    \ the arithmetic mean of elements in vector l. Recall that the arithmetic mean\
    \ is $\\langle x \\rangle / n$, where $n$ is the number of elements in the vector.\
    \ For instance, the mean of the numbers $1, 2, 3, 4$ is\n$$\\langle 1 \\rangle\
    \ / 2 = \\frac{1 + 2+ 3 + 4}{4} = \\frac{4}{4} = 2$$\nThe arithmetic mean is sometimes\
    \ called the geometric mean. The geometric mean is a popular measure of the average.",
  "    leng = length(l)\n    if leng == 0 \n        error(\"median requires at least\
    \ one element\")\n    elseif leng == 1\n        l[1]\n    else\n        median1D(l)\n\
    \    end\nend", "    l = sort(l)\n    return median(l)\nend", "    l = sort(l)\n\
    \    if length(l) == 1\n        return l[0]\n    else\n        return l[length(l)\
    \ div 2]\n    end\nend", "    l = sort(l)\n    return median(l)\nend\n\"\"\"Return\
    \ median of elements in the vector l sorted in ascending order.\n    >>> median([4,\
    \ 3, 2, 1])\n    3.0\n    >>> median([6, 3, 4, 1])\n    3.0\n\"\"\"", "    if\
    \ len(l) == 0 \n        return \n    median_value = median(l)\n    for val in\
    \ l:\n        if val <= median_value\n            return median_value\n      \
    \  median_value = median(l)\n    return median_value", "    m = sort(l)\n    if\
    \ length(m) < 2 \n        return m[1] \n    else \n        return (m[2] - m[1])/2\
    \ \nend\n</code>\nAnd here is the solution in Julia:\n<code>", "  if length(l)\
    \ == 0 \n  else median(sort!(l)) \n  end\nend # median", "    return sort(l)[findfirst(l)]\n\
    end\n</cell>\n<text>\nExercise 7.1\nWrite a Julia function that takes two arguments,\
    \ a list of numbers and a positive integer k, and returns a list of the elements\
    \ in the list whose absolute value is closest to k.", "    return sort(l)[end]\n\
    end", "    len = length(l);\n    if len < 2\n        throw(DomainError(\"Input\
    \ vector l must have at least 2 elements\"))\n    end\n    sort(l)\n    median\
    \ = l[ceil(Int(len/2))]\nend", "    s = sort(l)\n    n = length(s)\n    return\
    \ ifelse(n % 2 == 0, median(s[1,end-1]), median(s[end,1])) \nend", "    l = l[1:end]\n\
    \    median = medianfilter(l)\n    return median\nend\n</cell>\n<text>\nMedian\
    \ Absolute Deviation", "    sortedL = sort(l)\n    size = length(l)\n    return\
    \ (sortedL[size/2]+sortedL[size/2]+sortedL[size/2])/2\nend\n</cell>\n<code language=julia-1.6>\n\
    # median() on real numbers\nmedian([3, 1, 2, 4, 5])\n</cell>\n<code language=julia-1.6>\n\
    median([-10, 4, 6, 1000, 10, 20])\n</cell>\n<text>\nThe median is defined as the\
    \ point in the sorted sequence where the middle of the three values is placed.\
    \ Note that if there are an odd number of elements in the sequence, one middle\
    \ element is returned.", "    sort(l)\n    @where l<0\n    error(\"Median is not\
    \ defined for negative values\") \n    @where l==0\n    return l[(end-1)/2+1]\n\
    end\n</code>\n<|/ a tags=julia dscore=2 |>\n<| a dscore=0 |>\nIn case anyone is\
    \ looking for a function returning the median of an array of the type:\n<code>\n\
    type MyArray\n     x ::Vector{Int64}\nend\n</code>\nHere is a compact implementation\
    \ using median function (inspired by this question):\n<code>\nmedian(x::MyArray)\
    \ = (length(x)==0) ? (NaN) : (median(x.x))\n</code>\nor even shorter:\n<code>\n\
    median(x::MyArray) = (length(x)==0) ? (NaN) : (median(x.x))\n</code>\nor even\
    \ shorter:\n<code>\nmedian(x::MyArray) = median(x.x)\n</code>\n<|/ a tags=julia\
    \ |>\n<| a |>\nIf you want to find the median by yourself and want to avoid having\
    \ to type the function, you can simply write:\n<code>", "    return sort(l)[floor(length(l)+1)/2]\n\
    end", "    # @assert length(l) == length(unique(sort(l)))\n    # @assert all(d\
    \ > 0 for d in diff(l))\n    med = median(l)\n    i = 0\n    count = 0\n    while\
    \  i < length(l)\n        if l[i] > med\n            count += 1\n            med\
    \ = l[i]\n            i = i + 1\n        else\n            i = i + 1\n       \
    \ end\n    end\n    return med\nend", "    \n    \"\"\"\n    Find the median in\
    \ l\n    \"\"\"\n    \n    sortedx = sort(l)\n    return (sortedx[(length(l)-1)/2])\
    \ \nend", "    return median(sort(l))\nend\n\"\"\"Return median of elements in\
    \ the vector l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10,\
    \ 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"", "    medianval = sort(l)[1]\nend",
  "    if l.size == 0\n        throw(ArgumentError(\"Empty vector\"))\n    end\n \
    \   sort(l)\n    median_idx = ceil(Int, length(l) / 2)\n    if median_idx < 1\n\
    \        throw(ArgumentError(\"Cannot calculate median of an empty vector\"))\n\
    \    end\n    if median_idx == 1\n        throw(ArgumentError(\"Cannot calculate\
    \ median of an empty vector\"))\n    end\n    return l[median_idx]\nend\n</cell>\n\
    <code language=julia-0.6>\nmedian([3, 1, 2, 4, 5])\n</cell>\n<code language=julia-0.6>\n\
    median([-10, 4, 6, 1000, 10, 20])\n</cell>\n<code language=julia-0.6>\nmedian([-1000.0,\
    \ 1.0, 2.0, 2000.0, 3.0, 4.0, 5.0, 6.0])\n</cell>\n<code language=julia-0.6>\n\
    median([1.0, 2.0, 3.0, 4.0, 5.0])\n</cell>\n<code language=julia-0.6>\nmedian([1.0,\
    \ 2.0, 3.0])\n</cell>\n<code language=julia-0.6>\nmedian([1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n</cell>\n<code language=julia-0.6>\nmedian([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 6.0, 7.0])\n</cell>\n<code language=julia-0.6>\nmedian([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 6.0, 7.0, 8.0, 9.0])\n</cell>\n<code language=julia-0.6>\nmedian([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0])\n</cell>\n<code language=julia-0.6>\n\
    median([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0])\n\
    </cell>\n<code language=julia-0.6>\nmedian([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0,\
    \ 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0])\n</cell>\n<code language=julia-0.6>\n\
    median([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0,\
    \ 15.0, 16.0])\n</cell>\n<code language=julia-0.6>\nmedian([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0])\n\
    </cell>\n<code language=julia-0.6>\nmedian([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0,\
    \ 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0])\n</cell>\n\
    <code language=julia-0.6>\nmedian([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0,\
    \ 10.0, 11.0, ", "    sorted=sort(l)\n    median=sorted[(length(sorted)-1)/2];\n\
    \    return median;\nend\n</cell>\n<text>\nMedian and Median-of-Medians\nA median\
    \ is a number for which each item in the set is closer to it. For example, the\
    \ median of a set of integers is defined to be the number that exists in the set\
    \ that is closest to the middle of the list of numbers.", "    median = sort(l)[0]\n\
    \    for i in l:\n        if i > median\n            return i\n        else \n\
    \            return median\nend\n</cell>\n<code language=julia-1.5>\nmedian([3,\
    \ 1, 2, 4, 5])\n</cell>\n<code language=julia-1.5>\nmedian([-10, 4, 6, 1000, 10,\
    \ 20])\n</cell>\n<text>\n4. Interquartile Range\nWe can calculate the interquartile\
    \ range using the Percentiles function as shown below.", "    \"\"\"\nReturn the\
    \ median of the elements of vector l.\n    >>> median([1, 6, 4, 9, 5, 1])\n  \
    \  6.0\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    10.0\n    \"\"\"", "  \
    \  n = length(l)\n    idx = floor((n-1)/2)\n    return mean(l[idx:n])\nend", " \
    \   sortedL = sort(l)\n    return Float64(median(sortedL))\nend\n</cell>\n<text>\n\
    Exercise: Write median function, which is similar to the one we already wrote,\
    \ but uses median function from Statistics module. Try this for different inputs:\
    \ median([-10, -6, -4, -12, 4, 6, 12, 20]). What is median of [-10, -6, -4, -12,\
    \ 4, 6, 12, 20]?", "    return (l.length / 2) == 0 || l.length == 1 ? (l.last/2)\n\
    \                                            : maximum(l)\nend\n</cell>\n<code\
    \ language=julia-1.1>\n@testset \"median\" begin\n    l = rand(1:100)\n    median(l)\n\
    end\n</cell>\n<text>\nMaximum", "    sort(l)\n    return l[end]\nend\n</code>\n\
    <|/ a tags=julia |>\n<| c |>\nThis solution doesn't allow to apply a filter to\
    \ the input vector. Also it has the drawback that it sorts the vector twice which\
    \ is not a good thing in general case. Sorting has linear complexity in general\
    \ case and O(nlogn) complexity if the vector is sorted in increasing order.\n\
    <|/ c |>\n<| c |>\nIt allows to apply a filter to the input vector by using a\
    \ filter function instead of a anonymous function.\n<|/ c |>\n<| c |>\nCan you\
    \ add an example of how you'd use this? And maybe add some benchmarks?\n<|/ c\
    \ |>\n<| c |>\nThis is just another solution of mine with an additional filter,\
    \ so it is just more readable and has exactly the same complexity.\n<|/ c |>\n\
    <| c |>\nYes, that is true. However I thought the function should be faster and\
    \ this solution is faster since it does not involve sorting the input vector twice.\
    \ However, if you care about performance of sorting twice then this solution is\
    \ of course more efficient.\n<|/ c |>\n<| a tags=julia |>\n<code>\nusing Statistics",
  "    sorted_list = sort(l)\n    return sorted_list[end-1] \nend # median\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nTo get it working on julia, we need to add the following\
    \ line to the top of the file:\n`using Statistics`\n<|/ c |>\n<| c |>\nI added\
    \ that to my answer, and thank you. Although it's not needed in general, Julia\
    \ is known to be sensitive to the order in which you import packages.\n<|/ c |>\n\
    <| c |>\nTo get median in Julia, I do: `median([3,1, 2, 4,5])` which returns:\
    \ 3.5`\n<|/ c |>\n<| c |>\n`@everywhere using Statistics` will also work\n<|/\
    \ c |>\n<| c |>\nI like this one very much for its simplicity. Also works for\
    \ `Vector{Any}` and for any other collection type, e.g. `Vector{Dict}`\n<|/ c\
    \ |>\n<| a tags=julia,median,statistics dscore=5 |>\nI suggest to use StatsBase.jl:\n\
    <code>\njulia> using StatsBase", "    return round(median(collect(l)))\nend",
  "    length=length(l)\n    if length==0\n        return Float64[]\n    end=ceil(Int64,\
    \ length/2)\n    pivot=partition(l, end)[1]\n    return pivot\nend\n</cell>\n\
    <code language=julia-1.1>\n# median of array \nmedian([3, 1, 2, 4, 5])\n</cell>\n\
    <code language=julia-1.1>\n# median of vector \nmedian([3, 1, 2, 4, 5])\n</cell>\n\
    <code language=julia-1.1>\nmedian([3, 1, 2, 4, 5])\n</cell>\n<code language=julia-1.1>\n\
    median([-10, 4, 6, 1000, 10, 20])\n</cell>\n<text>\n1.5.3 Intersection\nFind the\
    \ intersection of two vectors.\nIn Julia, it is often useful to find intersection\
    \ of two vectors via the in-built function intersect.", "    return quantile(l,\
    \ (1/2)) \nend", "  sorted = sort(l)\n  \n  if length(sorted)==1\n    return sorted[1]\n\
    \  \n  index = searchsorted(l, sorted[floor(length(sorted)/2)], ordered = true)\n\
    \  return sorted[index]\nend", "    if length(l) == 0 \n        throw(DomainError(string(\"\
    empty list \", l, \" is not in range 0 to \", length(l))))\n    end\n    l = sort(l)\n\
    \    return l[Int(round(Int, length(l) / 2))]\nend", "    return sort(l)[end]\n\
    end\n</cell>\n<code language=julia-1.1>\nmedian([3, 1, 2, 4, 5])\n</cell>\n<text>\n\
    Exercise 3\nWrite a function median_sd(l::Vector{Int64})  that returns the median\
    \ of the elements in l and its standard deviation, as a tuple of two numbers.\n\
    For example, median_sd([3, 1, 2, 4, 5]) should return (3.0, 2.8284271247461903).",
  "\tm = mean(l)\n\tfor e in l\n\t\tif e > m\n\t\t\tm = e\n\t\tend\n\tend\n\treturn\
    \ m\nend\n</cell>\n<code language=julia-1.3>\nmedian([3, 1, 2, 4, 5])\n</cell>\n\
    <code language=julia-1.3>\nmedian([-10, 4, 6, 1000, 10, 20])\n</cell>\n<text>\n\
    3. Statistical Functions\n4.1 Mean\nThe function mean returns the mean of a vector.",
  "    s = sort(l)\n    \n    if length(l) > 1\n        return s\n    end", "    sorted\
    \ = sort(l)\n    half = length(sorted)/2\n    if length(sorted) %2 ==0\n     \
    \   return sorted[half]\n    else\n        return (sorted[half-1] + sorted[half])/2\n\
    \    end\nend", "    if length(l) == 0 \n        return nan \n    median_idx =\
    \ argmax(l)\n    median_val = l[median_idx]\n    if median_val < median \n   \
    \     median = median_val \n    end\n    return median_val\nend", "  n = length(l)\n\
    \  if n <= 1\n    l[1]\n  elseif n % 2 == 1\n    l[ceil(n/2)]\n  elseif n % 2\
    \ == 0\n    median(subset(l, 1:(floor(n/2))))\n  else\n    median(subset(l, 1:(floor(n/2))))+median(subset(l,\
    \ (ceil(n/2)+1):end))\n  end\nend", "    return stats::median(l); \nend\n</cell>\n\
    <code language=julia-1.3>", "\treturn sort(l).median\nend\n</cell>\n<code language=julia-1.5>",
  "    if length(l) == 0 \n        error(\"median requires at least one input element\"\
    )\n    end\n    n = length(l)\n    l = sort(l)\n    return l[(n+1)/2-1]\nend\n\
    </cell>\n<code language=julia-1.0>\n@assert median([1, 3]) == 1.5\n@assert median([3,\
    \ 1, 2, 4, 5]) == 3.0\n@assert median([-10, 4, 6, 1000, 10, 20]) == 15.0\n</cell>\n\
    <text>\nExercise 9\nImplement median() and its relatives. That is, to find the\
    \ median of an ordered vector of numbers, how do you find the median of the five\
    \ smallest numbers in the vector? What about the following vectors?", "    return\
    \ sort(l)[end - 1]\nend\n</cell>\n<code language=julia-1.6>", "    return find_median(l)\n\
    end", "    \n    if length(l) < 2\n        return NaN\n    end\n    mid = floor(Int64,\
    \ length(l)/2)\n    return mean((sort(l)[mid]:sort(l)[end-mid+1]))\nend", "  \
    \  return median(l)\nend\n\"\"\"\nReturn median of elements in the vector l.\n\
    \    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10,\
    \ 20])\n    15.0\n    \"\"\"", "    if (length(l)>0)\n        return mean(l)\n\
    \    else\n        return NaN\nend\n</cell>\n<code language=julia-0.5>\nmedian([3,\
    \ 1, 2, 4, 5])\n</cell>\n<text>\nExercise 9\nDefine a function that outputs the\
    \ number of positive entries in a vector. Use the mean function in order to compute\
    \ the mean.", "    return reduce(median, l)\nend \n\"\"\"\nReturn the median of\
    \ the array x, where x is assumed to be non-empty.", "     median(sort(l))\nend",
  "    return sort(l)[1]\nend\n</cell>\n<text>\nA median is the value that separates\
    \ the higher half of a data set from the lower half of a data set. This is often\
    \ called the \"typical\" or \"middle\" of the data set, and it is also called\
    \ the \"typical\" number for a population. If you do not know what median is,\
    \ you can just google it :)", "\tresult = sort(l)[1]\n\treturn result \nend ",
  "    if length(l) == 0 \n        throw(DomainError())\n    end\n    return reduce(median,\
    \ l, Float64(NaN))\nend\n</cell>\n<code language=julia-1.2>\n\"\"\"Return median\
    \ of elements in the vector l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>>\
    \ median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"", "    sorted_l = sort(l)\n\
    \    med = sorted_l[floor(length(sorted_l)/2)]\n    \n    return med\nend", " \
    \   return quantile(collect(l), 0.5, 1)[1]\nend", "  n = length(l)\n  m = median_index(l)\
    \ \n  \n  if n <= m\n    return 0.0\n  end\n  \n  l = sort(l); \n  return l[m+1]\n\
    end\n</cell>\n<text>\n3.4 Bins", "    l.sort()\n    middle = length(l)\n    if\
    \ middle == 1\n        return l[0]\n    \n    if middle % 2 == 1\n        return\
    \ l[middle / 2]\n    \n    return median(l[middle - 1 : middle / 2]) + median(l[middle\
    \ : middle / 2 - 1])\nend\n</cell>\n<code language=julia-1.5>\n@assert median([3,\
    \ 1, 2, 4, 5]) == 3\n@assert median([-10, 4, 6, 1000, 10, 20]) == 15.0\n</cell>\n\
    <code language=julia-1.5>\nmedian([2, 5, 4, 3, 2, 1])\n</cell>\n<text>\n4.5 \u041A\
    \u043E\u0440\u0442\u0435\u0436\u0438", "    median_idx = (length(l)+1)/2 # ceil\
    \ function\n    sort!(l)\n    return l[median_idx]\nend", "    \n    sortedList\
    \ = sort(l)\n    if length(l) % 2 == 0 \n        return sortedList[length(l) /\
    \ 2]\n    else\n        return (sortedList[length(l) / 2] + sortedList[length(l)\
    \ / 2 - 1]) / 2\n    end\nend", "    if length(l) == 0 \n        error(\"Vector\
    \ is empty\") \n    else \n        return (l[1:end-1] + l[end])/2\n    end\nend",
  "\t\n\tn = length(l)\n\tif n == 0 \n\t\treturn 0\n\tend\n\t\n\tm = sort(l)[Int(n/2)-1]\n\
    \treturn m\nend\n\t\n\"\"\"Return mode (most frequent element) of the vector.\"\
    \"\"", "    return sort(l) ./ length(l)\nend\n</cell>\n<code language=julia-1.0>\n\
    @assert median([3, 1, 2, 4, 5]) == 3\n@assert median([-10, 4, 6, 1000, 10, 20])\
    \ == 15.0\n</cell>\n<text>\nMedian of a sorted array is the value at which this\
    \ array was sorted.\nIf median is even, the value that should be in the middle\
    \ of the array\nIf median is odd, the value that should be at the very end of\
    \ the array", "    length(l) >=2 && throw(ErrorException(\"Cannot compute median\
    \ of empty list\"))\n    l = sorted(l)\n    half = length(l) / 2\n    if half\
    \ == 0\n        return throw(ArithmeticException(\"Cannot compute median of empty\
    \ list\"))\n    if length(l) % 2 == 0\n        median = l[half]\n    else\n  \
    \      median = l[half - 1] + (l[half] - l[half - 1]) / 2\n    return median\n\
    end", "    return sort(l).median\nend", "    sorted(l)[1]\nend\n</cell>\n<code\
    \ language=julia-1.0>\nmedian([3,1,2,4,5])\n</cell>\n<text>\n3. Write a function\
    \ to return the mode of a vector. \nThe mode is the most frequently occurring\
    \ value in the vector, and should only appear once. \nThe function should return\
    \ the value itself.", "    sort!(l)\n    return l[end]/2\nend\n</cell>\n<code\
    \ language=julia-0.5>\n@benchmark median($nums);\n</cell>\n<text>\n6. Bincount\n\
    bincount will count the number of elements in each bin. The result is a vector\
    \ of the same size as the input vector. The bins argument must be specified and\
    \ is a vector of integers from 1 to length(vec)+1 inclusive. Thus bincount operates\
    \ similarly to the Matlab function histcounts", "    if length(l) == 0 \n    \
    \    return 0.0\n    sort!(l)\n    return l[length(l)/2] \nend", "  length = length(l);\
    \ \n  if length <= 1 \n    throw(DomainError())\n  elseif length == length \n\
    \    return median(sort(l))\n  elseif length % 2 \n    return (median(l[floor(length/2)])\
    \ + median(l[floor(length/2)+1]))/2\n  else \n    return (median(l[floor(length/2)-1])\
    \ + median(l[floor(length/2)]))/2\nend", "    return sort(l)[(length(l)+1)/2]\n\
    end", "    sorted = sort(l)\n    if length(sorted) == 0 || length(sorted) == 1\
    \ \n        sorted[1] \n    elseif length(sorted) == 2 \n        sorted[floor(Int64,\
    \ length(sorted)/2)]\n    elseif length(sorted) == 3 \n        sorted[floor(Int64,\
    \ length(sorted)/2)]\n    elseif length(sorted) == 4 \n        sorted[floor(Int64,\
    \ length(sorted)/2)]\n    elseif length(sorted) == 5 \n        sorted[floor(Int64,\
    \ length(sorted)/2)]\n    elseif length(sorted) == 6 \n        sorted[floor(Int64,\
    \ length(sorted)/2)]\n    elseif length(sorted) == 7 \n        sorted[floor(Int64,\
    \ length(sorted)/2)]\n    elseif length(sorted) == 8 \n        sorted[floor(Int64,\
    \ length(sorted)/2)]\n    elseif length(sorted) == 9 \n        sorted[floor(Int64,\
    \ length(sorted)/2)]\n    end\nend\n</cell>\n<code language=julia-1.5>\nmedian([3,\
    \ 1, 2, 4, 5])\n</cell>\n<code language=julia-1.5>\nmedian([-10, 4, 6, 1000, 10,\
    \ 20])\n</cell>\n<code language=julia-1.5>", "\tn = length(l)\n    if n == 0\n\
    \    \treturn 0\n    end\n    \n\tmiddle = n/2\n\t\n\tpivot = median(l)", "  \
    \  sort(l)\n    l = l[begin:end-1]\n    mid = length(l) / 2\n    return (l[mid]\
    \ + l[end-1]) / 2\nend", "    \n    \"\"\"Return median of elements of l.\"\"\"\
    \n    \n    \n    n = length(l); m = floor(n/2)\n    if n%2==1 \n        return\
    \ median(l[m-1:m+1])\n    else\n        return median(l[m-1:m])\n    end\nend",
  "  sort(l)\n  mid = length(l)//2\n  if length(l)%2 == 1\n    return l[mid]\n  else\n\
    \    return .5 * (l[mid-1] + l[mid])\nend", "    l = sort(l)\n    if length(l)==0\
    \ \n        return 0 \n    return l[floor(Int64, length(l)+1)/2] \nend\n</cell>\n\
    <code language=julia-1.4>", "    if length(l)<2\n        throw(DomainError(Int,\
    \ length(l)))\n    end\n    sort(l)\n    return median(l[1..end])\nend\n</cell>\n\
    <code language=julia-1.2>\n@doc median\n</cell>\n<code language=julia-1.2>\nmedian([3,\
    \ 1, 2, 4, 5])\n</cell>\n<code language=julia-1.2>\nmedian([-10, 4, 6, 1000, 10,\
    \ 20])\n</cell>\n<text>\nDemonstrate that median is working as expected:", " \
    \   count = count(l)\n    if count % 2 ==0 \n        median1 = median(count/2,\
    \ l[1:(count/2)])\n        median2 = median(count/2, l[(count/2):count])\n   \
    \     return (median1 + median2)/2\n    else\n        median1 = median(count/2,\
    \ l[1:count])\n        return median1\n    end\nend", "  n = length(l) \n  m =\
    \ n/2\n  if n < 2\n    return m # handle empty lists\n  elseif n % 2 == 1 \n \
    \   return l[m]\n  else\n    return (l[m] + l[m+1]) / 2\nend", "    length = length(l)\n\
    \    sorted = sort(l)\n    middle = length / 2\n    if length > 1\n        return\
    \ sorted[middle]\n    else\n        return 0.0\n    end\nend\n\"\"\"\n    Return\
    \ a new vector sorted according to a given order vector. The \n    vector elements\
    \ must be of a numeric type.\n    \"\"\"", "    s = Vector{Float64}[]\n    for\
    \ x in l\n        push!(s, x)\n    end\n    sort!(s)\n    return s[end]\nend",
  "    n = length(l)\n    if n == 0\n        throw(ZeroDivisionError(\"median(): empty\
    \ collection\"))\n    end\n    if n % 2 == 0\n        return (l[(n+1)/2] + l[n/2])\
    \ / 2\n    else\n        return l[(n-1)/2]\n    end\nend", "    n = length(l)\n\
    \    @assert n >= 2 \"Not enough numbers in array (need at least 2)\"\n    @assert\
    \ n <= length(l) / 2, \"Not enough numbers in array (need at most half the size)\"\
    \n    \n    # Find median\n    l = sort(l)\n    return l[ceil(n/2)]\nend", " \
    \   return median(l)\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"Return median\
    \ of elements in the vector l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>>\
    \ median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"", "    return median(l.to_a)\n\
    end", "    return (sort(l)[end-1]+sort(l)[end])/2\nend\n</cell>\n<text>\nA median\
    \ is the value separating the higher half of a data set from the lower half. Of\
    \ course, there is always a better way. The median is the value that separates\
    \ even higher numbers from the even lower numbers, and the median of a set of\
    \ n numbers is the number that separates n - 1 evens from n evens.", "    n =\
    \ length(l)\n    if n % 2 == 0 \n        return (l[floor(Int, n/2+1)] + l[ceil(Int,\
    \ n/2-1)]) / 2\n    else \n        return (l[floor(Int, n/2+1)] + l[ceil(Int,\
    \ n/2+1)]) / 2\n    end\nend\n</cell>\n<text>\nmedian", "    l = sort(l)\n   \
    \ m = (length(l)/2)\n    return l[m]\nend\n</cell>\n<code language=julia-1.0>\n\
    median([3, 1, 2, 4, 5])\n</cell>\n<code language=julia-1.0>\nmedian([-10, 4, 6,\
    \ 1000, 10, 20])\n</cell>\n<text>\nExercises", "    sortedVec = sort(l)\n    len\
    \ = length(sortedVec)\n    if len % 2 == 1 \n        return sortedVec[(len - 1)\
    \ / 2]\n    end1 = len / 2\n    end2 = len\n    return (sortedVec[end1] + sortedVec[end2])\
    \ / 2\nend\n</cell>\n<code language=julia-1.6>\nmedian([3, 1, 2, 4, 5])\n</cell>\n\
    <text>\nWrite median and mode functions in the same file", "    return quantile(l,0.5)\n\
    end\n\"\"\"Return median of elements in the vector l.\n    >>> median([3, 1, 2,\
    \ 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\
    \"", "    return median(l)\nend", "    if len(l) == 0 \n    else median(l[1])\n\
    end\n    \n\"\"\"Return median of elements in the list l. \n    The median is\
    \ defined as the value separating the higher half of \n    a sorted list of length\
    \ n from the lower half of a sorted list of length n, \n    for a randomly chosen\
    \ element x from the list. \n    I.e. it is the value x for which (list > x)[floor(length(list)/2)]\
    \ \n    is true.", "    sort(l)\n    l = l[end]\n    middle = length(l)/2\n  \
    \  if l % 2 == 0\n        median = ((l+middle)-middle)/2\n    else\n        median\
    \ = (middle+middle)/2\n    end\nend\n\"\"\"Return the median of the elements in\
    \ a vector (sorted)\"\"\"", "    if length(l) < 2 \n        throw(Exception, \"\
    Cannot determine median of an empty vector.\") \n    \n    median_of_vector =\
    \ median(l)\n    if median_of_vector == 0 \n        throw(Exception, \"Cannot\
    \ determine median of an empty vector.\") \n    return median_of_vector\nend",
  "    \"\"\"Calculate the median of l elements.\"\"\"\n    sort(l)\n    n = length(l)\n\
    \    if n < 2 \n        return l[1]\n    \n    i = floor((n - 1) / 2)\n    return\
    \ l[i]\nend\n</cell>\n<text>\nTo calculate the median of a vector l, we will need\
    \ to sort the vector. This sorting takes O(n log n) time. We'll use a sorting\
    \ algorithm known as Insertion Sort which will take O(n) time."]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
