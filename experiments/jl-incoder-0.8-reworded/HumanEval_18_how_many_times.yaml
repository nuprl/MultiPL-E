name: HumanEval_18_how_many_times
language: jl
prompt: "\"\"\" Find how many times a given substring can be found in the original\
  \ string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0\n\
  \    >>> how_many_times(\"aaa\", \"a\")\n    3\n    >>> how_many_times(\"aaaa\"\
  , \"aa\")\n    3\n    \"\"\"\nfunction how_many_times(string::String, substring::String)::Int64\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = how_many_times;\n\t@test(candidate(\"\
  \", \"x\") == 0)\n\t@test(candidate(\"xyxyxyx\", \"x\") == 4)\n\t@test(candidate(\"\
  cacacacac\", \"cac\") == 4)\n\t@test(candidate(\"john doe\", \"john\") == 1)\nend\n"
completions: ["    if string == \"\"\n        return 0 \n    if substring == \"\"\n\
    \        return 1 \n    \n    return how_many_times(string-1, substring) + how_many_times(string,\
    \ substring-1) \nend ", "    if string == substring\n        return 0\n    end\
    \ = 0\n    index_of_substring = 0\n    while index_of_substring < length(string)\n\
    \        if substring(end) == substring(index_of_substring)\n            index_of_substring\
    \ += 1\n            end += 1\n        else\n            if substring(end) < substring(index_of_substring)\n\
    \                return index_of_substring + how_many_times(substring(end+1),\
    \ substring)\n            else\n                return end + how_many_times(substring(end+1),\
    \ substring(index_of_substring))\n            end\n        end\n    end\n    return\
    \ 0\nend", "    \n    count = 0\n    \n    # search for the first occurrence of\
    \ substring in the string\n    pos = string.find(substring)\n    while pos > -1\
    \ \n        # increment the count if the occurrence was found\n        count =\
    \ count + 1\n        # find the next occurrence of the substring and repeat the\
    \ process\n        pos = string.find(substring, pos + 1)\n    end\n    \n    return\
    \ count\nend", "    if string.contains(substring) \n        then string.count(substring)\
    \ + 1 \n        else 0 \n    end\nend\n</cell>\n<code language=julia-1.5>\nhow_many_times(\"\
    abcde\", \"a\")\n</cell>\n<code language=julia-1.5>\nhow_many_times(\"abcde\"\
    , \"b\")\n</cell>\n<code language=julia-1.5>\nhow_many_times(\"abcde\", \"c\"\
    )\n</cell>\n<code language=julia-1.5>\nhow_many_times(\"abcde\", \"z\")\n</cell>\n\
    <text>\nExercise 2\nWrite a function that will check if a number is even.", " \
    \   if is_empty(substring)\n        return 0 \n    \n    length::Int64 = length(substring)\n\
    \    if length == 0\n        return 0 \n    \n    count::Int64 = 0 \n    \n  \
    \  for index::Int64 in 0..length\n        if is_substring(substring, string[index..index\
    \ + length])\n            count += 1\n        end\n    end\n    return count\n\
    end\n</cell>\n<code language=julia-1.3>\nhow_many_times(\"\", \"a\")\n</cell>\n\
    <code language=julia-1.3>\nhow_many_times(\"aaa\", \"a\")\n</cell>\n<code language=julia-1.3>\n\
    how_many_times(\"aaaa\", \"aa\")\n</cell>\n<text>\n\u26A0\uFE0F Note: If the given\
    \ substring is shorter than our input string, it is padded with spaces so that\
    \ it ends with the given string.", "    substringLength := length(substring)\n\
    \    lengthString := length(string)\n    if substringLength == lengthString then\n\
    \        return substringLength\n    elif substringLength > lengthString then\n\
    \        return 0\n    else \n        i := 0\n        j := 0\n        while i\
    \ < lengthString do\n            if string[i] == substring[j] then\n         \
    \       j += 1\n            else\n                j := 0\n                i +=\
    \ 1\n            end\n        end\n        return lengthString - i + 1\nend\n\
    </code>\n<|/ a tags=string,julia,algorithm |>\n<| a |>\nThe answer of is quite\
    \ straight forward and elegant.\nI wanted to provide an alternative approach that\
    \ could be faster if repeated searches are acceptable. \nIn Julia a more efficient\
    \ solution exists if we can use two string allocations.\nAs we want to find the\
    \ \"count\" for each substring we do not really need to allocate a copy of the\
    \ original string for each substring - we can just allocate a buffer for the substrings\
    \ and store the count there. With this solution we can directly find the count\
    \ for a given substring without iterating over the entire string.\n<code>", " \
    \   \"\"\"Count how many times the substring is in the given string\n    >>> how_many_times(\"\
    \", \"a\")\n    0\n    >>> how_many_times(\"aaa\", \"a\")\n    3\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3\n    \"\"\"", "    index_start = 0\n    index_end = string.length\n\
    \    while index_start < index_end\n        if string.substring(index_start, index_end)\
    \ == substring\n            index_start = index_end + 1\n        else\n      \
    \      return index_end - index_start + 1\n    end\n    return 0\nend\n</cell>\n\
    <code language=julia-1.5>\nhow_many_times(how_many_times(how_many_times(\"asdf\"\
    , \"as\"), \"as\"), \"s\")\n</cell>\n<code language=julia-1.5>\nhow_many_times(how_many_times(how_many_times(\"\
    asdf\", \"as\"), \"as\"), \"s\").==how_many_times(\"asdf\", \"as\")\n</cell>\n\
    <text>\nString", "    if string == \"\" or substring == \"\"\n        return 0\n\
    \    if string==substring\n        return 1\n    pos = string.find(substring)\n\
    \    if pos >= 0\n        return how_many_times(string[pos + 1 .. end], substring)\
    \ + how_many_times(string[1 .. pos], substring)\n    else\n        return how_many_times(string[1\
    \ .. end], substring)\nend\n</cell>\n<code language=julia-1.5>", "    if string.contains(substring)\
    \ == false\n        return 0\n    else\n        pos = string.find(substring)\n\
    \        if string.contains(substring) == false\n            return 0\n      \
    \  else\n            count <- 0\n            while pos != -1\n               \
    \ if string.substring(pos) != substring\n                    pos <- string.find(substring,\
    \ pos)\n                else\n                    count += 1\n               \
    \ end\n            end\n            return count\n        end\n    end\nend\n\
    </code>\n<|/ a |>\n<| a dscore=0 |>\nThis would be my approach.\n<code>", "  \
    \  str = string.len()\n    str2 = substring.len()\n    count = 0\n    i = 0\n\
    \    while i < str\n        if string[i..str].len()==str2\n            count+=1\n\
    \        end\n        i+=1\n    end\n    return count\nend", "    if string.contains(substring)\
    \ \n    then return string.count(substring)\n    else return 0\n    end \n</code>\n\
    <|/ a tags=string,functional-programming,julia |>\n<| a |>\nI see several answers\
    \ here and I wanted to add my approach, that I think might be useful as well.\n\
    <code>", "    if substring == \"\" then\n        0\n    else\n        (string\
    \ == \"\") ? 0 : 1 + how_many_times(string[end], substring)\n    end\nend", " \
    \   if string == \"\" and substring == \"\" \n    then return 0\n    else if string\
    \ == \"\" or substring == \"\"\n    then return 0\n    else return 1 + how_many_times(string[1:],\
    \ substring[1:])\nend\n</cell>\n<code language=julia-1.0>\nhow_many_times(\"\"\
    , \"\")\n</cell>\n<code language=julia-1.0>\nhow_many_times(\"abc\", \"a\")\n\
    </cell>\n<code language=julia-1.0>\nhow_many_times(\"aaaa\", \"a\")\n</cell>\n\
    <code language=julia-1.0>\nhow_many_times(\"aaaaa\", \"a\")\n</cell>\n<code language=julia-1.0>\n\
    how_many_times(\"aaaaaaa\", \"a\")\n</cell>\n<code language=julia-1.0>\nhow_many_times(\"\
    aaaa\", \"a\")\n</cell>\n<code language=julia-1.0>\nhow_many_times(\"aaaa\", \"\
    b\")\n</cell>\n<text>\nHowManyTimes\nHowManyTimes returns the number of times\
    \ that a substring can be found given a string.", "  result = 0\n  for character\
    \ in string:\n    if character == substring[0]:\n      result = result + 1\n \
    \     for char_next in string:\n        if char_next == substring[1]:\n      \
    \    result = result + 1\n  return result\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    How does this answer the question? It does not tell you how often a substring\
    \ appears in a string. Also, this is O(n^2). A better solution would be to compare\
    \ each character against the entire substring.\n<|/ c |>\n<| a tags=string,haskell\
    \ |>\nI wrote a simple solution, which is pretty much the same as David's answer,\
    \ but with more simplicity. I used a map to count characters in substrings, and\
    \ use a foldl to count occurrences of each substring in a given string.\n<code>\n\
    import Data.Map (fromList)", "    pos = find(string, substring)\n    if pos ==\
    \ StringLength(string)\n        return 0\n    \n    ans = 1\n    while pos > 0\n\
    \        ans = ans * substringLen(substring)\n        pos = find(string, substring,\
    \ pos + 1)\n    end", "    if string == \"\" || substring == \"\"\n        return\
    \ 0\n    \n    count::Int64 = 0\n    for c in string\n        if c == substring\n\
    \            count += 1\n    \n    return count", "    if substring = \"\" then\
    \ return 0 \n    else \n        if substring in string then \n            return\
    \ (string.count(substring) + 1) \n        else \n            return how_many_times(substring(string),\
    \ substring)\nend\n</cell>\n<text>\nHow many characters are in substring\nThis\
    \ function is a recursive function that counts the number of characters in a given\
    \ string.", "    return (string == substring) ? 0 : 1 + how_many_times(substring,\
    \ string(substring, 1,end))\nend\n</cell>\n<text>\nExercise 3\nWrite a function\
    \ which takes a vector of strings as an argument and returns an ordered vector\
    \ of strings with the same length as the input.\nThe new vector should contain\
    \ the count of how many times each substring occurs in the original vector, ordered\
    \ from the most frequent to the less frequent. If there is no substring, then\
    \ the count should be 0.\nIf the count of a substring exceeds the length of the\
    \ original vector, then the remaining count should be appended to the end of the\
    \ vector.\nFor example if there are three strings in the input, then the new vector\
    \ should look like: [\"a\", \"b\", \"c\", 3, \"d\", \"e\", \"f\"]", "    count\
    \ = 0\n    for char in string:\n        if char == substring[1]:\n           \
    \ if substring[1] != substring[0]:\n                count += 1 \n            else:\n\
    \                count += 0 \n    return count\nend \n</cell>\n<text>\nExercise\
    \ 10\nUsing the previous function how_many_times find the count of how many times\
    \ a substring appears in a string.", "    sum = 0\n    pos = -1\n    for x in\
    \ string.chars():\n        if x == substring[pos]:\n            sum += 1\n   \
    \     else:\n            pos = -1\n    if sum == 0:\n        return 0\n    return\
    \ sum\nend", "    if string.size == 0 or substring.size == 0\n        return 0\n\
    \    \n    i = 0\n    j = 0\n    while i < (string.size - 1) && j < (substring.size\
    \ - 1) \n        if string.chars[i] == substring.chars[j]\n            i += 1\n\
    \            j += 1\n        elseif string.chars[i] == substring.chars[j] \n \
    \           i += 1\n        else\n            j++\n    end\n    return j - i\n\
    end", "    if substring == string return 0 \n    else \n        return 1 + how_many_times(string,\
    \ substring(1), substring(2))\n</code>\n<|/ a dscore=0 |>\n<| a tags=string,haskell\
    \ |>\nThe code below uses foldr to count the occurrences of an item in a list.\
    \ \n<code>\nimport Data.List", "  result = string.count(substring)\n  return result\
    \ if result > 1 else 0\nend", "    if string == \"\" or substring == \"\"\n  \
    \      return 0 \n    \n    substring_index = 0\n    count = 0\n    while substring_index\
    \ < length(substring)\n        if substring(substring_index) == substring(substring_index\
    \ + 1)\n            substring_index += 1\n        else \n            count = count\
    \ + substring(substring_index)\n            substring_index += 1\n    end\n  \
    \  \n    return count\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nHi, welcome to\
    \ Stack Overflow! While this might be a valuable hint to solve the problem, a\
    \ good answer also demonstrates the solution. Please read [How to Answer](http://stackoverflow.com/questions/how-to-answer).\n\
    <|/ c |>\n<| a tags=string,julia,pattern-matching |>\nYou can do it using a regex\
    \ and translating it to a function. \n<code>\nusing Regex", "    if string ==\
    \ \"\" || substring==\"\" then return 0 \n    else if substring(0,1) == substring(1,1)\
    \ then return 1 + how_many_times(substring(1,1), string) \n    else return how_many_times(substring(1,1),\
    \ string) + how_many_times(substring(1,length(string)-1), string) \nend \nhow_many_times(\"\
    \", \"a\")\n</cell>\n<code language=julia-1.0>", "    if string == \"\" && substring\
    \ == \"\"\n        return 0\n    if substring == \"\"\n        return 1 + how_many_times(string,\
    \ substring)\n    if substring in string\n        return 1 + how_many_times(string.sub(string.indexOf(substring),\
    \ string.Length(substring)), substring)\n    return 0", "    if string == \"\"\
    \ && substring == \"\" \n    then 0\n    else if string == \"\" \n    then 1\n\
    \    else if substring == \"\" \n    then 0\n    else if length(substring) >=\
    \ length(string) \n    then 0\n    else if substring(0,length(string)) < string\
    \ \n    then 0\n    else if substring(length(string),length(substring)) > string\
    \ \n    then 0\n    else if substring(0,length(string)) > string \n    then length(substring)\
    \ - length(string)\n    else if substring(length(string),length(substring)) <\
    \ string \n    then length(substring) - length(string)\n    else if substring(length(string),length(substring))\
    \ == string \n    then 1\n    else length(substring) - length(string)\n    end\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a |>\nI took Kelly's answer and expanded on\
    \ it with a recursive function for getting the longest substring of a given string.\
    \ \n<code>\n# Given a string and a substring\n# returns the number of times the\
    \ substring can be found in the string\n# and returns the longest substring of\
    \ that given string that can be found.\n# Returns 0 if string and substring are\
    \ either empty or if string and substring are \n# of the same length", "    if\
    \ substring == \"\"\n    then return 0 \n    elseif string==substring\n    then\
    \ return 1 \n    elseif string==substring(1,length(substring))\n    then return\
    \ 1 + how_many_times(substring(length(substring),length(string)),substring)\n\
    \    else \n        if substring(1,length(substring))==substring(length(substring),length(string))\n\
    \        then return how_many_times(substring(length(substring),length(string)),substring(1,length(substring)))\n\
    \        else return how_many_times(substring(1,length(substring)),substring)\n\
    \    end\nend", "    if string == \"\"\n        0\n    else if substring == string\n\
    \        1\n    else\n        how_many_times(string[1..end-1], substring) + how_many_times(string[end],\
    \ substring)\nend", "    if !string.contains(substring)\n        return 0\n  \
    \  else:\n        search_index = 0\n        search_len = substring.length()\n\
    \        match_len = 0\n        while search_index <= search_len\n           \
    \ search_index += 1\n            if string.substring(search_index) == substring\n\
    \                match_len += 1\n            end\n        end\n        return\
    \ match_len\n    end\nend\n\"\"\"\nReturn True if string ends with substring,\
    \ else False.", "    #return 0 if string == substring\n    if string == substring\n\
    \        return 0\n    endpos = string.find(substring)\n    beginpos = string.find(substring,\
    \ endpos+1)\n    #return 0 if substring is not found\n    if beginpos == -1\n\
    \        return 0\n    \n    count = 1\n    while beginpos != -1\n        count\
    \ = (count-1)*(beginpos+1)+endpos+1\n        beginpos = string.find(substring,\
    \ beginpos+1)\n    end\n    return count\nend", "    if string == \"\" || substring\
    \ == \"\"\n        return 0\n    \n    local i = start = 0\n    local j = end\
    \ = 0", "    if substring == \"\"\n        return 0\n    if substring in string\n\
    \        return 1 + how_many_times(string[string.index(substring):], substring)\n\
    \    else\n        return how_many_times(string, substring[1:end])\nend\n</cell>\n\
    <text>\nCount the number of times \"aaa\" occurs in the original string.", " \
    \   if substring == \"\" then 0 else count(string, substring)\n</code>\nThe function\
    \ counts the occurrences of substring in string. It has two arguments, a string\
    \ and a substring. The function returns 0 if string is empty or if the substring\
    \ is not found. In case of a substring being found twice or more times, it returns\
    \ 1.\nThis solution is similar to the solution in OCaml and Scala:\n<code>\ndef\
    \ how_many_times(s: String, sub: String): Int = {\n  if (s == \"\") 0 else s.toLowerCase.count(sub.toLowerCase)\n\
    }\n</code>\nA bit longer but probably faster. This solution has two advantages\
    \ over the previous ones:", "    if string == \"\" || substring == \"\"\n    \
    \    0\n    else\n        if string.substring(0,substring.length) == substring\n\
    \            1\n        else\n            how_many_times(string.substring(substring.length),substring)\
    \ + 1\n    end\nend\n</cell>\n<text>\nTask 3", "  | (string == substring) ? 1\
    \ : 0\nend", "    if string == substring \n        then 1 else 0 \n    end", " \
    \   if length(string) <= length(substring)\n        return 0\n    else if substring(0,length(substring))==string(0,length(substring))\n\
    \        then how_many_times(substring,substring(length(substring)))\n       \
    \ else 0\n    else if substring(0,length(substring))==string(0,length(substring))\n\
    \        then how_many_times(substring(length(substring)),substring(length(substring)))\n\
    \        else 0\nend \n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis is a great solution.\
    \  It doesn't use `fold` which is much more efficient than recursion and doesn't\
    \ require the original string to be the same length as the substring.\n<|/ c |>\n\
    <| a |>\n<code>\n# Solution using recursion", "    if substring == \"\"\n    \
    \    return 0\n    else if string.length == substring.length\n        return 0\n\
    \    else if string.ends_with(substring)\n        return string.length\n    else\
    \ if substring.starts_with(string)\n        return substring.length\n    else\n\
    \        return how_many_times(string.substring(1), substring) + how_many_times(string,\
    \ substring.substring(1)) + 1\nend\n</cell>\n<code language=julia-1.5>\nhow_many_times(\"\
    abcd\", \"ab\")\n</cell>\n<text>\nChallenge\nModify how_many_times to return number\
    \ of times substring can be found in string", "    count = 0\n    for i in substring:\n\
    \        if string[i] == substring[i]\n        count = count + 1\n    return(count)",
  "    if string.len() == 0 || substring.len() == 0\n        return 0;\n    if string.find(substring)\
    \ == 0 \n        return 1;\n    if string.find(substring) == string.len() - substring.len()\n\
    \        return string.count(substring);\n    if string.substring_count(substring)\
    \ == 1 \n        return string.count(substring);\n    return how_many_times(string.drop(1),\
    \ substring) + how_many_times(string, substring.drop(1));\nend\n</cell>\n<code\
    \ language=julia-1.0>", "    if string.contains(substring) == false \n       \
    \ then return 0\n    else \n        s <- string.find(substring)\n        e <-\
    \ string.index(substring, s+1)\n        substring.length()\n        if e > 0 \n\
    \            then return e-s\n        else return 0\n    end \nend\n</cell>\n\
    <text>\nExercise 2: Find out whether a substring is contained in the string",
  "|\n    # If the string is empty or there is nothing to find\n    if string == \"\
    \" || substring == \"\"\n        |\n        return 0\n    |\n    # If the string\
    \ is small enough, return its length without considering overlapping characters\n\
    \    if string.length <= substring.length\n        |\n        return string.length\n\
    \    |\n    # Initialize a counter\n    i = 0\n    |\n    # Start counting from\
    \ the beginning of the string\n    while i < string.length\n        |\n      \
    \  # Stop searching if the substring becomes empty\n        if i >= substring.length\n\
    \            |\n            return i\n        |\n        # Count the current character\
    \ and compare with the next one\n        if string.charAt(i) == substring.charAt(i)\n\
    \            |\n            i += 1\n            |\n            continue # Don't\
    \ count overlapping characters\n        |\n        # Increment the counter\n \
    \       i += 1\n    |\n    # Return -1 in case of an error\n    return -1\nend\n\
    </cell>\n<code language=julia-1.2>", "    if string == \"\" then return 0\n  \
    \  if substring == \"\" then return 1\n    \n    var times_substring::Int64 =\
    \ 0\n    \n    var start::Int64 = string.find(substring)\n    var end::Int64 =\
    \ start\n    while end > 0 do\n        times_substring = times_substring + 1\n\
    \        \n        end -= 1\n        \n        if string.charAt(end) == substring.charAt(0)\
    \ then \n            string = string.substring(end + 1)\n            end -= 1\n\
    \            \n            if end == start then \n                times_substring\
    \ = times_substring + 1\n            end\n        end\n    end\n    return times_substring\n\
    end\n</cell>\n<code language=julia-0.5>\nhow_many_times(\"\", \"a\")\n</cell>\n\
    <code language=julia-0.5>\nhow_many_times(\"aaa\", \"a\")\n</cell>\n<code language=julia-0.5>\n\
    how_many_times(\"aaaa\", \"aa\")\n</cell>\n<text>\nString manipulation", "   \
    \ if string.length < substring.length then return 0 # base case\n    else if string.starts_with(substring)\
    \ then # base case\n        return 1\n    else return 1 + how_many_times(string.drop(1),\
    \ substring)\nend\n</cell>\n<text>\nExercise: What is the time complexity of how_many_times?\
    \ Write a function to print out a time complexity table, or a plot of time complexity\
    \ against size of string and substring.", "  count_string = 0\n  count_substring\
    \ = 0\n  for character in string\n    if character == substring\n      count_substring\
    \ += 1\n    elseif character == substring or count_substring > 0\n      count_string\
    \ += 1\n      count_substring = 0\n    end\n  end\n  return count_string\nend",
  "    how_many = 1\n    string_len = len(string)\n    substring_len = len(substring)\n\
    \    for i::Int64 in 0..(string_len-substring_len+1) do \n        if string[i+substring_len]\
    \ == substring then \n            how_many += 1\n        \n    return how_many\n\
    </cell>\n<code language=julia-1.0>\nhow_many_times(\"aaa\", \"aa\")\n</cell>\n\
    <code language=julia-1.0>\nhow_many_times(\"aaa\", \"a\")\n</cell>\n<text>\nFinding\
    \ overlapping substrings", "    if string.find(substring) == -1\n        return\
    \ 0\n    else\n        return string.count(substring)\n    end\nend\n</cell>\n\
    <text>\nExercise: Write a function that removes all occurrences of a substring\
    \ from a string.", "    if string==\"\" || substring==\"\" \n        then\n  \
    \          return 0\n        else if substring in string \n            then\n\
    \                return string.count(substring)\n            else \n         \
    \       return 0\n    end\n    \n\"\"\"\n    \n    count_consecutive_duplicates(string)",
  "  \"\"\" Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases. \"\"\"\n  len_string::Int64 = length(string)\n  len_substring::Int64\
    \ = length(substring)\n  cnt::Int64 = 0\n  for i in 0 .. len_string - len_substring\n\
    \    if (string[i+len_substring] == substring)\n      cnt += 1\n  end\n  return\
    \ cnt\nend\n</cell>\n<code language=julia-1.0>", "    if string == \"\" || substring\
    \ == \"\"\n    then return 0\n    else if string[length(string)-1] == substring\n\
    \    then return 1\n    else if substring[1] == string[length(string)-1]\n   \
    \ then return how_many_times(string[1:length(string)-1], substring) + 1 \n   \
    \ else return how_many_times(string[1:length(string)-1], substring)\nend\n</cell>\n\
    <cell>\n\"\"\" Convert string to list of substrings\n>>> s = \"abcd\"\n>>> substring_list_to_string(s)\n\
    [\"a\", \"b\", \"c\", \"d\"]\n\"\"\"", "    if string == \"\" || substring ==\
    \ \"\" || substring == string\n    then 0\n    else if string[1] == substring[0]\n\
    \    then 1\n    else if how_many_times(string[1:], substring[1:])\n    then 1\
    \ + how_many_times(string[end], substring)\n    else how_many_times(string[1:],\
    \ substring)\nend\n</cell>\n<text>\nExercise:\nImplement a function count_letters\
    \ that takes a string and returns the number of times each letter appears in the\
    \ string. Ignore letter case.\nThe count_letters function should only count characters\
    \ from the alphabet (upper and lower case).", "    \n    count = 0\n    \n   \
    \ for char in string:\n        if char in substring && substring[char] == char\
    \ && substring.endsWith(char)\n            count += 1\n        end\n    \n   \
    \ return count\n\"\"\"", "    if string == substring \n        then 1 else 0\n\
    \    else if string == \"\"\n        then 0 \n        else 1 + how_many_times(string[1:end],\
    \ substring)\n    end\nend\n</cell>\n<text>\nThis function is actually a fold\
    \ operation! But remember, you cannot use fold for in-place mutations. We will\
    \ have to make a copy first!", "    length::Int64 = string.length()\n    substring_index::Int64\
    \ = string.index(substring)\n    if substring_index < length\n        return substring_index\n\
    \    else\n        substring_index::Int64 = length - 1\n        if substring_index\
    \ < 0\n            return 0\n        else\n            return how_many_times(string.substring(substring_index\
    \ + 1), substring)\n    end \nend\n</cell>\n<text>\nExercise 1.2: Finding the\
    \ substring with longest length", "    if string.contains(substring) == true &&\
    \ substring.contains(string) == true \n        then count ++ \n    else \n   \
    \     count = 0\n    return count\n</code>\n<|/ a |>\n<| c |>\nWhile this link\
    \ may answer the question, it is better to include the essential parts of the\
    \ answer here and provide the link for reference.  Link-only answers can become\
    \ invalid if the linked page changes. - [From Review](/review/low-quality-posts/21461538)\n\
    <|/ c |>\n<| c |>\nThank you for your comment. I will modify my answer according\
    \ to your comments.\n<|/ c |>\n<| c |>\nThis still has issues with overlapping\
    \ matches.\n<|/ c |>\n<| c |>\nThis answer is correct. While the other answers\
    \ fail to take overlapping matches into the account, they only work when both\
    \ strings contain the same characters (which seems unlikely given the OP's description\
    \ of the problem and examples).\n<|/ c |>\n<| a |>\n<code>\ndef how_many_times(string,\
    \ substring):\n    count = 0\n    i = 0\n    while i < len(string) and count <\
    \ len(substring):\n        if string[i] == substring[i]:\n            count +=\
    \ 1\n        i += 1\n    return count\n</code>\n<|/ a tags=string,haskell dscore=4\
    \ |>\n<| c |>\nYou don't need the while loop. Just check whether `string[i] &&\
    \ substring[i]` in the condition.\n<|/ c |>\n<| c |>\nWhile this might answer\
    \ the question it's better to include the essential parts of the answer here and\
    \ provide the link for reference.  Link-only answers can become invalid if the\
    \ linked page changes. - [From Review](/review/low-quality-posts/21461538)\n<|/\
    \ c |>\n<| a tags=string,haskell dscore=4 |>\nA simple way would be to use the\
    \ 'find' function to find the index of the first occurrence of a substring and\
    \ then, get the string from the index until the end of the string and check whether\
    \ substring occurs in that string.\n<code>\nhow_many_times :: String -> String\
    \ -> Int\nhow_many_times string substring = \n       find (substring `elem`) string\
    \ + 1\n</code>\nIf you don't want to use 'find', you can write this in two steps:\
    \ first find the index of the first occurrence of substring and then get the string\
    \ from the index until the end of string.\n<code>\nhow_many_times string substring\
    \ = \n      let index = find (substring `elem`) string in \n      if index < length\
    \ string then\n         length string - index + 1\n      ", "    | substring ==\
    \ \"\" = 1 \n    | substring(0,1) == substring = 1\n    | substring(1,string.length)\
    \ == substring = how_many_times(string, substring[1:])\n    | substring.length\
    \ == 1 = how_many_times(substring(1,string.length), substring)\n    | substring.length\
    \ == 0 = 1 + how_many_times(substring(1,string.length), substring)\n    | substring(1,substring.length)\
    \ == substring = how_many_times(substring(1,string.length), substring[1:])\n \
    \   | substring.length == substring.length = how_many_times(substring(1,string.length),\
    \ substring)\n    | substring(1,substring.length) == substring(substring.length,string.length)\
    \ = how_many_times(substring(1,string.length), substring)\n    | otherwise = how_many_times(substring(1,string.length),\
    \ substring) + how_many_times(substring(substring.length,string.length), substring)",
  "    if string == substring then return 1 else return 0 \n    var counter::Int64\
    \ = 0 \n    for char in string \n        if substring in char \n            then\
    \ counter += 1 \n            else \n                counter += 0 \n        end\
    \ \n    end \n    return counter \nend \n\"\"\"\n</cell>\n<code language=julia-0.6>\n\
    # Benchmark", "    str = string.findFirst(substring)\n    if str == Nothing \n\
    \        count = 0 \n    else \n        count = str.end - str.start \n    return\
    \ count\nend\n</cell>\n<code language=julia-1.4>\nhow_many_times(\"\"\"the door\
    \ was closed on the third of january 2017.\"\"\", \"close\") \n</cell>\n<text>\n\
    HowManyTimes\nThe HowManyTimes function counts the number of times a given substring\
    \ can be found in the original string. Count overlaping cases.\nHowManyTimes(string,\
    \ substring) \u2192 Int64", "    if string == \"\" || substring == \"\"\n    \
    \    return 0 \n    else \n        let (left_index, right_index) = string.find(substring)\n\
    \        if left_index == -1 && right_index == -1\n            return 0 \n   \
    \     else \n            left_index == -1 ? right_index : left_index\n    end\n\
    end", "    if string.len() == 0 || substring.len() == 0\n        return 0\n  \
    \  let lgth = string.len()\n    let mut count = 0\n    for start in 0..lgth-1\
    \ {\n        if string.charAt(start) == substring.charAt(0){\n            count\
    \ += 1\n            if substring.len() > 1{\n                for rest in 1..substring.len()\
    \ - 1 {\n                    count += 1\n                    if string.charAt(start\
    \ + rest) == substring.charAt(start + substring.len() - rest){\n             \
    \           count += 1\n                    }\n                }\n           \
    \ }\n        }\n    }\n    return count", "\"\"\"\n\"\"\"\n    \"\"\"\n    ",
  "    cdef long long x = 0\n    cdef long long count = 0\n    if substring in string:\n\
    \        count = 0\n    else:\n        for i in string:\n            if substring\
    \ in i:\n                count += 1\n                break\n            else:\n\
    \                x += 1\n    return count\n</code>\n<|/ a dscore=2 tags=python-3.x,python\
    \ |>\n<| a tags=python-3.x,python |>\nFor finding number of occurrences of a substring\
    \ in a string you can use:\n<code>\ndef count_substring(text, substring):\n  \
    \  count = 0\n    for index in range(len(text)):\n        if text[index] == substring[0]:\n\
    \            if substring in text[index+1:]:\n                count += 1\n   \
    \         else:\n                count += text[index+1] != substring[0]\n    \
    \    else:\n            count += text[index] != substring[0]\n    return count\n\
    </code>\n<|/ a dscore=1 |>\n<| a |>\nIn Python 3.8 you can use the built-in string\
    \ method count():\n<code>\n>>> s = 'abcdefghijklmnopqrstuvwxyz'\n>>> s.count('a')\n\
    2\n</code>\nThis method works even when the substring is not found.\n<|/ a tags=python-3.x,python\
    \ dscore=1 |>\n<| a dscore=0 tags=python-3.x,python |>\nThis isn't necessarily\
    \ the most efficient implementation, but it was a fun one. \n<code>\ndef countOccurrences(text,\
    \ substring):\n    count=0\n    length = len(text)\n    for x in range(0,length):\n\
    \        if substring==text[x]:\n            count+=1\n            if length==x:\n\
    \                break\n        else:\n            count+=1\n    return count\n\
    </code>\n<|/ a |>\n<| a tags=python-3.x,python |>\nHere's my solution. First I\
    \ check if my text string is empty, if it is I return 0. If it is not empty I\
    \ loop through each character and check if that character matches my substring.\n\
    <code>\ndef count_substring(text, substring):\n    if text == '':\n        return\
    \ 0\n    else:\n        count = 0\n        for char in text:\n            if char\
    \ == substring:\n                count = count + 1\n                break\n  \
    \      return count\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\ndef count_substring(text,\
    \ substring):\n    if not text:\n        return 0\n    if substring not in text:\n\
    \        return 1\n    count = 0\n    for i in range(len(text)):\n        if text[i]\
    \ == substring[0]:\n            if substring not in text[i + 1:]:\n          \
    \      count += 1\n            else:\n                count += text[i + 1] !=\
    \ substring[0]\n        else:\n            count += text[i] != substring[0]\n\
    \    return count\n</code>\n<|/ a dscore=0 tags=python-3.x,python |>\n<| a tags=python-3.x,python\
    \ |>\n<code>\ndef count(", "    if string == \"\" \n        0\n    else\n    \
    \    length(findall(substring, string))\nend\n</cell>\n<text>\nExercise 6: Create\
    \ a function named how_many_times_overlapping which takes a string and substring\
    \ as arguments and returns the number of times the substring appears anywhere\
    \ in the string and also counts overlapping cases. For example, how_many_times_overlapping(\"\
    abba\",\"ab\") should return 4 (4 appearances of ab, 1 appearance of b, and 0\
    \ appearances of a).\nHint: You may want to use the built-in count function.",
  "    match substring with\n    | x when x=\"\" => 0\n    | x when x=substring =>\
    \ 1\n    | x => how_many_times(substring[1:], x) + 1\n    end\nend\n</cell>\n\
    <text>\nFinding characters in strings\nExercise: Write a function that will count\
    \ how many times a given character appears in a string", "    if string == substring\
    \ \n        1 \n    elif string.substring(0,substring.length) == substring\n \
    \       1 + how_many_times(string.substring(substring.length), substring)\n  \
    \  else\n        how_many_times(string.substring(1), substring)\nend\n</cell>\n\
    <text>\nStrings with more and less words. Use regex. How? Let's take a look",
  "    \n    if string == \"\" then return 0 \n    else if substring == \"\" then\
    \ return 0 \n    else return count(string, substring) + 1", "    if string ==\
    \ \"\" || substring == \"\" return 0\n    if substring.length() > string.length()\
    \ return 0\n    let mut count = 0\n    let substring = substring.lower()\n   \
    \ let mut s = string.chars().collect::<String>()\n    let mut schar = s.next()\n\
    \    while schar != \"\" {\n        if schar == substring[count] {\n         \
    \   count += 1\n            if count >= substring.length() {\n               \
    \ count = 1\n            }\n        } else {\n            count = 0\n        }\n\
    \        schar = s.next()\n    }\n    count\nend\n</cell>\n<code language=julia-1.2>\n\
    \"\"\" Check if the two strings are anagrams, return True if they are anagrams.\
    \ Otherwise return False.\n    >>> is_anagram(\"\", \"aa\")\n    True\n    >>>\
    \ is_anagram(\"abc\", \"ab\")\n    True\n    >>> is_anagram(\"abc\", \"acb\")\n\
    \    False\n    \"\"\"", "    if string == \"\" || substring == \"\"\n       \
    \ return 0\n    elseif string[0] != substring[0]\n        return how_many_times(string[1:],\
    \ substring[1:])\n    elseif string[0] == substring[0]\n        return 1 + how_many_times(string[1:],\
    \ substring[1:])\n    else\n        return 1 + how_many_times(string[1:], substring[1:])\n\
    end\n</cell>\n<code language=julia-1.0>\n# TEST HOW MANY TIMES (72)\n@test how_many_times(\"\
    \", \"\") == 0\n@test how_many_times(\"a\", \"a\") == 0\n@test how_many_times(\"\
    aaa\", \"a\") == 3\n@test how_many_times(\"aaaa\", \"aa\") == 3\n</cell>\n<text>\n\
    6. Optional packages", "    if string == \"\" || substring==\"\"\n        return\
    \ 0\n    if string==substring\n        return 3\n    if string.length > substring.length\n\
    \        return how_many_times(string[length(string)..],substring)\n    return\
    \ how_many_times(string[..length(substring)],substring)\nend\n</cell>\n<code language=julia-1.5>\n\
    how_many_times(a, \"a\")\n</cell>\n<text>\nThe most common pattern in Julia is\
    \ to use recursion whenever possible. While Julia's recursion is faster than Python's\
    \ recursion, it is also slower than languages like C++. Recursion in Julia is\
    \ also not memory efficient in Julia since it allocates lots of variables. Therefore\
    \ recursion is not a good candidate in Julia when we need to perform some iterative\
    \ calculations or looping.", "    if string == \"\" || substring == \"\" \n  \
    \      return 0 \n    else \n        if substring[0] < string[0] \n          \
    \  return how_many_times(string[1:], substring) \n        else \n            if\
    \ substring[1] == string[1] \n                return how_many_times(string[2:],\
    \ substring) \n            else\n                if substring[2] < string[2] \n\
    \                    return how_many_times(string[3:], substring) \n         \
    \       else \n                    if substring[3] == string[3] \n           \
    \             return how_many_times(string[4:], substring) \n                \
    \    else \n                        if substring[4] < string[4]\n            \
    \                return how_many_times(string[5:], substring) \n             \
    \           else \n                            if substring[5] == string[5] \n\
    \                                return how_many_times(string[6:], substring)\
    \ \n                            else \n                                if substring[6]\
    \ < string[6] \n                                    return how_many_times(string[7:],\
    \ substring) \n                                else \n                       \
    \             if substring[7] == string[7]\n                                 \
    \       return how_many_times(string[8:], substring) \n                      \
    \              else \n                                        if substring[8]\
    \ < string[8]\n                                            return how_many_times(string[9:],\
    \ substring) \n                                        else \n               \
    \                             if substring[9] == string[9]\n                 \
    \                               return how_many_times(string[10:], substring)\
    \ \n                                            else \n                      \
    \                          if substring[10] < string[10] \n                  \
    \                                  return how_many_times(string[11:], substring)\
    \ \n                                                else \n                  \
    \                                  if substring[11] == string[11] \n         \
    \                                               return how_many_times(string[12:],\
    \ substring) \n                                                    else \n   \
    \                                                     if substring[12] < string[12]\n\
    \                                                            return how_many_times(string[13:],\
    \ substring) \n                                                        else \n\
    \                                                            return how_many_times(string[13:],\
    \ substring) \n        else \n            return how_many_times(string[1:], substring)\
    \ \nend ", "    if string.is_empty or substring.is_empty then return 0 \n    else\
    \ if string.starts_with(substring) then return 1 \n    else if substring.ends_with(String)\
    \ then return 0 \n    else if substring.contains(string) then return how_many_times(substring[length(string):],\
    \ substring) \n    else return how_many_times(string[length(string):], substring)\
    \ \nend\n</cell>\n<code language=julia-1.3>\n\"\"\"\n    how_many_times2(string::String,\
    \ substring::String)::Int64 \n    how_many_times2(string::String, substring::String)::Int64\
    \ \n    how_many_times2(string::String, substring::String)::Int64 \n    \n   \
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    how_many_times2(\"\", \"a\")\n    0\n    how_many_times2(\"\
    aaa\", \"a\")\n    3\n    how_many_times2(\"aaaa\", \"aa\")\n    3\n    how_many_times2(\"\
    a\", \"a\")\n    1\n    how_many_times2(\"aa\", \"a\")\n    1\n    how_many_times2(\"\
    aaa\", \"aa\")\n    2\n    how_many_times2(\"aaaa\", \"aaa\")\n    2\n    how_many_times2(\"\
    aaaaa\", \"aaaa\")\n    4\n    how_many_times2(\"aaaaa\", \"aaaaa\")\n    4\n\
    \    how_many_times2(\"aaaaaaaaaaaaaaaa\", \"aaaaaaaa\")\n    1\n    how_many_times2(\"\
    aaaaaaaaaaaaaaaa\", \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\")\n    2\n   \
    \ how_many_times2(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    , \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
  "    count = 0\n    for pos in substring.string.enumerated() {\n        count =\
    \ count + 1 if string.string.substring(pos) == substring.string else count\n \
    \   }\n    return count", "    | string == \"\" = 0\n    | substring == \"\" =\
    \ 0\n    | string[-1] != substring[-1] = how_many_times(string[1..-1], substring)\n\
    \    | substring[-1] != string[-substring.length-1] = how_many_times(string[1..-1],\
    \ substring)\n    | substring.length <= 1 = how_many_times(string[1..-1], substring)\n\
    \    | substring.length > 1 = how_many_times(string[1..string.length-1], substring[1..substring.length-1])\n\
    \    | substring.length = string.length = how_many_times(string[1..string.length-1],\
    \ substring[1..substring.length-1])\n    | substring.length <= string.length =\
    \ how_many_times(string[1..string.length-1], substring[1..substring.length-1])\n\
    \    | otherwise = how_many_times(string[1..string.length-1], substring) + 1\n\
    end\n</cell>\n<code language=julia-1.5>\nhow_many_times(\"a\",\"a\")\n</cell>\n\
    <text>\n\u23F1", "    if string == substring\n        return 0\n    \n    if string.startswith(substring)\n\
    \        return 1 + how_many_times(string[end-1..end], substring)\n    \n    if\
    \ string.endswith(substring)\n        return 1 + how_many_times(string[start-1..start],\
    \ substring)\n        \n    return 0\n</code>\n<|/ a tags=algorithm,string,search,substring\
    \ |>\n<| a dscore=1 |>\nFor searching strings within a string, you always need\
    \ to start with the longest one. That is, if you need to find the first occurrence\
    \ of \"ABC\" within \"ABC\", the longest possible string is \"ABC\", and you need\
    \ to start searching from \"C\". Once you find \"C\", you need to then search\
    \ the remaining part of the string, and keep doing this until you either find\
    \ a match or the string is exhausted.\n<code>\n#include <string.h>\n#include <stdio.h>",
  "  result=0\n  for i in 1 .. string.len()\n    if substring[i]==string[i-1]\n  \
    \    result+=1\n    else\n      break\n  return result", "    if string.indexOf(substring)\
    \ == -1\n        return 0\n    else\n        return 1 + how_many_times(string.drop(string.indexOf(substring)),substring)\n\
    end\n</cell>\n<text>\nTask 2.1\nWrite a recursive function named count_times that\
    \ takes a string and a substring and counts how many times the substring appears\
    \ in the string. Count overlaping cases.\nTest your function with different values\
    \ of substring.", "    if string.contains(substring) == true then\n        string.count(substring)\n\
    \    else\n        return 0\n    end\nend\n</cell>\n<code language=julia-0.6>",
  "\tlet start = string.find(substring)\n\tlet end = start+1\n\tlet overlap = string.count(substring[start..end])\n\
    \t\n\tif end > string.len\n\t\treturn 0\n\telseif overlap == 0\n\t\treturn string.count(substring)\n\
    \telse\n\t\treturn overlap + 1\nend", "    if is_empty(string)\n        0\n  \
    \  elseif is_empty(substring)\n        0\n    else\n        let (lower, upper)\
    \ = (len(string) - length(substring), length(substring))\n        let (low, sub)\
    \ = (1, length(substring))\n        let mut result = 1\n        for i in 0 ..\
    \ lower\n            if substring(i, sub) == string(i)\n            then\n   \
    \             result++\n            sub = sub + 1\n            if sub == upper\n\
    \            then\n                sub = 0\n        result \nend", "    \n   \
    \ if substring==\"\"\n        return 0\n    if substring==string\n        return\
    \ 1\n    if string==\"\"\n        return 1\n    if substring(0,1)==substring(1,length(string))\n\
    \        how_many_times(substring(2,length(string)),string)\n    else\n      \
    \  how_many_times(substring(1,length(string)),string)", "    \"\"\"\n    Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    \"\"\"\n    count = 0\n    for i in string.gmatch(\"\
    (.*){(.*){(.*){(.*){(.*){(.*){(.*){(.*){(.*){(.*)}}}}}}}}\")\n        if i ==\
    \ substring\n            count += 1\n            \n    count\nend\n</cell>\n<text>\n\
    how_many_times2\nSimilar to how_many_times but returns only the number of the\
    \ given substring which occurs in the original string.", "    if string == \"\"\
    \ || substring == \"\"\n        return 0\n    else\n        count = 0\n      \
    \  for i in string\n            if i == substring\n                count += 1\n\
    \        return count\nend", "    if string.ends_with(substring)\n        return\
    \ 0\n    return string.count(substring) + how_many_times(string[string.end..],\
    \ substring)", "    mutable cnt := 0\n    for c in string:\n        if substring\
    \ in c:\n            cnt += 1\n    return cnt\n</code>\n<|/ a tags=string,search,algorithm,haskell,replace\
    \ |>\n<| a dscore=1 tags=string,search,algorithm,haskell,replace |>\nI did it\
    \ for fun, but I didn't expect to gain anything from it, except for showing my\
    \ thought process & a fun exercise. \n<code>\nimport Data.List\nimport qualified\
    \ Data.Map as M\nimport Data.Maybe\nimport qualified Data.Text.IO as T", "   \
    \ count_string = 0\n    for c in string:\n        if substring == c:\n       \
    \     count_string += 1\n    end\n    return count_string\n</code>\nHopefully\
    \ this helps! It's a very simple function that you can implement however you like.\n\
    <|/ a tags=string,haskell,algorithm |>\n<| c |>\nAh yes, I didn't consider that\
    \ overlapping case either. I will edit my answer to take that into account.\n\
    <|/ c |>\n<| c |>\nOh wow, I completely missed that one. It would be a lot more\
    \ efficient if that wasn't the case, and I'm guessing that isn't the case :)\n\
    <|/ c |>\n<| c |>\nThis algorithm is extremely inefficient. There are a lot of\
    \ useless checks inside the loop. Here is an improved version: https://gist.github.com/anonymous/845fa41869a70eda14a57\n\
    <|/ c |>\n<| a |>\nThe question was already answered but this solution may be\
    \ a bit more optimized.\nThe idea is to have a Map with each letter as the key\
    \ and a list of indices as value so that we can search it later.\n<code>\nimport\
    \ Data.Map (empty, insert, insert-if)", "    if string == \"\" || substring ==\
    \ \"\"\n        return 0\n    if string[0] == substring[0]\n        return how_many_times(string[1:],\
    \ substring[1:])\n    return how_many_times(substring[1:], string) + 1", "   \
    \ if string == substring return 0\n    if substring == \"\" then return 1\n  \
    \  let count::Int64 = 1\n    match string.find(substring) with\n    | None ->\
    \ return 0\n    | Some idx -> if idx < count then return 0\n                 \
    \ else if substring.length < string.length then return 0\n                   \
    \      else count := idx + 1\n    | _ -> count := how_many_times(string.substring(1),\
    \ substring)\n    return count\n</code>\n<|/ a tags=algorithm,python,string,python-3.x\
    \ |>\n<| c |>\nThank you very much for your solution! It works in my case. I am\
    \ accepting Gary S's answer because it contains more explanation and more code.\n\
    <|/ c |>\n<| c |>\n: I see. His solution seems to be much faster, though. Do you\
    \ have the timeit results?\n<|/ c |>\n<| c |>\n: I did run them, and he took ~0.49\
    \ s while you took ~0.24 s. His solution seems to be faster by about 1/5th of\
    \ the time taken by this solution.\n<|/ c |>\n<| c |>\n`how_many_times` is not\
    \ tail recursive, so it really doesn't do anything.\n<|/ c |>\n<| a dscore=0 tags=algorithm,python,string,python-3.x\
    \ |>\nI took your original code and made it tail recursive by replacing return\
    \ with recurse. The last two lines of the function became:\n<code>\ndef how_many_times(string::String,\
    \ substring::String)::Int64 \n  if string == substring return 0\n  if substring\
    \ == \"\" then return 1\n  let count::Int64 = 1\n  match string.find(substring)\
    \ with\n  | None -> return 0\n  | Some idx -> if idx < count then return 0\n \
    \                 else if substring.length < string.length then return 0\n   \
    \                      else count := idx + 1\n  | _ -> count := how_many_times(string.substring(1),\
    \ substring)\n  recurse(count::Int64, string::String)\n  return count\n</code>\n\
    I also made it a little more concise:\n<code>\ndef how_many_times(string::String,\
    \ substring::String)::Int64 \n  if string == substring return 0\n  if substring\
    \ == \"\" then return 1\n  let count::Int64 = 1\n  match string.find(substring)\
    \ with\n  | None -> 0\n  | Some idx -> if idx < count then 0\n               \
    \   else if substring.length < string.length then ", "    count = 0\n    string::String\
    \ = string.lowercase()\n    substring::String = substring.lowercase()\n    for\
    \ c in string:\n        if substring in substring:\n            count += 1\n \
    \   return count\nend\n</cell>\n<code language=julia-1.4>\nhow_many_times(\"\"\
    , \"a\")\n</cell>\n<code language=julia-1.4>\nhow_many_times(\"aaa\", \"a\")\n\
    </cell>\n<code language=julia-1.4>\nhow_many_times(\"aaaa\", \"aa\")\n</cell>\n\
    <text>\nExercise\nWrite a function that takes a string and a list of words, and\
    \ checks if the words can be found in the string.", "    if string == \"\"\n \
    \       return 0 \n    \n    # Count overlaping cases \n    count = 0\n    \n\
    \    for i <- string.index(substring)\n        count += 1\n    \n    return count\n\
    end\n</cell>\n<code language=julia-0.6>\nhow_many_times(\"\", \"a\")\n</cell>\n\
    <code language=julia-0.6>\nhow_many_times(\"aaa\", \"a\")\n</cell>\n<code language=julia-0.6>\n\
    how_many_times(\"aaaa\", \"aa\")\n</cell>\n<text>\nConsistency check\nA more general\
    \ approach is to check that a substring is present exactly once in the original\
    \ string.", "    if string == \"\" then return 0 \n    else if substring == \"\
    \" then return 1 \n    else \n        let  left_index = 1 \n        let  right_index\
    \ = 1 \n        let result = 0 \n        while left_index < length(substring)\
    \ and right_index < length(string) do \n            if substring(left_index) ==\
    \ string(right_index) then result += 1 \n            left_index += 1\n       \
    \     right_index += 1\n        return result \n    end\nend\n</cell>\n<code language=julia-1.5>",
  "    if string == \"\" && substring == \"\" then return 0 \n    if substring ==\
    \ \"\" then return 1 \n    return 1 + how_many_times(string.[1:], substring) \n\
    end\n</code>\n<|/ a tags=recursion,julia |>\n<| a |>\nIn your question, you are\
    \ looking for a way to count the occurrences of characters in a string. So, if\
    \ you want all occurrences of character x in a string, you can do something like\n\
    <code>\njulia> count_occurences(string::String, x::Char) = [string.count(x) for\
    \ x in string.chars]\ncount_occurences (generic function with 1 method)", "  \
    \  if string == substring \n        1 \n    else \n        how_many_times(substring[end-1],\
    \ string) \nend\n</cell>\n<text>\nWe can test it with the example below:", " \
    \   count = 0\n    for c in string:\n        if c == substring:\n            count\
    \ += 1\n    return count\n</cell>\n<text>\nExercise\nWrite a function, called\
    \ count_occurrences, that takes a string and substring and counts how many times\
    \ substring occurs in string. Your function should return the number of times\
    \ a given substring occurs in string.", "    | substring.length <= string.length\
    \ = 0\n    | substring.length <= string.length = 1\n    | substring.length <=\
    \ string.length = 2 \n    | substring.length <= string.length = 3\n    | substring.length\
    \ <= string.length = 4\n    | substring.length <= string.length = 5\n    | substring.length\
    \ <= string.length = 6\n    | substring.length <= string.length = 7\n    | substring.length\
    \ <= string.length = 8\n    | substring.length <= string.length = 9\n    | substring.length\
    \ <= string.length = 10\n    | substring.length <= string.length = 11\n    | substring.length\
    \ <= string.length = 12\n    | substring.length <= string.length = 13\n    | substring.length\
    \ <= string.length = 14\n    | substring.length <= string.length = 15\n    | substring.length\
    \ <= string.length = 16\n    | substring.length <= string.length = 17\n    | substring.length\
    \ <= string.length = 18\n    | substring.length <= string.length = 19\n    | substring.length\
    \ <= string.length = 20\n    | substring.length <= string.length = 21\n    | substring.length\
    \ <= string.length = 22\n    | substring.length <= string.length = 23\n    | substring.length\
    \ <= string.length = 24\n    | substring.length <= string.length = 25\n    | substring.length\
    \ <= string.length = 26\n    | substring.length <= string.length = 27\n    | substring.length\
    \ <= string.length = 28\n    | substring.length <= string.length = 29\n    | substring.length\
    \ <= string.length = 30\n    | substring.length <= string.length = 31\n    | substring.length\
    \ <= string.length = 32\n    | substring.length <= string.length = 33\n    | substring.length\
    \ <= string.length = 34\n    | substring.length <= string.length = 35\n    | substring.length\
    \ <= string.length = 36\n    | substring.length <= string.length = 37\n    | substring.length\
    \ <= string.length = 38\n    | substring.length <= string.length = 39\n    | substring.length\
    \ <= string.length = 40\n    | substring.length <= string.length = 41\n    | substring.length\
    \ <= string.length = 42\n    | substring.length <= string.length = 43\n    | substring.length\
    \ <= string.length = 44\n    | substring.length <= string.length = 45\n    | substring.length\
    \ <= string.length = 46\n    | substring.length <= string.length = 47\n    | substring.length\
    \ <= string.length = 48\n    | substring.length <= string.length = 49\n    | substring.length\
    \ <= string.length = 50\n    | substring.length <= string.length = 51\n    | substring.length\
    \ <= string.length = 52\n    | substring.length <= string.length = 53\n    | substring.length\
    \ <= string.length = 54\n    | substring.length <= string.length = 55\n    | substring.length\
    \ <= string.length = 56\n    | substring.length <= string.length = 57\n    | substring.length\
    \ <= string.length = 58", "    if string == \"\" \n        return 0 \n    else\
    \ \n        return (string.find(substring) != string.length) ? (1 + how_many_times(string.substr(0,\
    \ string.find(substring)),substring) + how_many_times(string.substr(string.find(substring)+1),\
    \ substring)) : (how_many_times(string.substr(0, string.find(substring)),substring)\
    \ + 1) ", "    if string == \"\"\n        then 0\n    else\n        let\n    \
    \        substring_index = string.index(substring)\n            if substring_index\
    \ == -1\n                then 0\n            else 1 + how_many_times(string.substring_at(substring_index\
    \ + substring.length(), string.length()), substring)\n        end\n    end\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThanks for the code but I'm afraid that it doesn't\
    \ really answer my question :-/ I'm trying to find a way to do this without using\
    \ any libraries.\n<|/ c |>\n<| a tags=string,julia |>\nHere's a recursive solution.\n\
    <code>", "    count = 0 \n    for i in string.substring_prefix(substring)\n  \
    \      count += how_many_times(string.substring(i), substring) \n    count +=\
    \ how_many_times(string.substring(string.size() - substring.length()), substring)\
    \ \n    return count \nend\n</cell>\n<text>\nAnd there you have it. Now we've\
    \ seen a couple ways we can solve this problem, but it's important to note that\
    \ there are many others.", "    \n    if string == \"\" || substring == \"\" \n\
    \        then\n            return 0\n    \n    pos_start = string.find(substring)\n\
    \    if pos_start == -1\n        then\n            return 0\n    \n    pos_end\
    \ = pos_start + substring.length - 1\n    \n    string_length = string.length\n\
    \    substringLength = substring.length\n    \n    if pos_start < substring.length\
    \ && pos_end < substring.length\n        then\n            if string.substring(pos_start,\
    \ pos_end) == substring \n                then\n                    return pos_end\
    \ - pos_start + 1\n    \n            if string.substring(pos_start, pos_end -\
    \ substring.length) == substring\n                then\n                    return\
    \ pos_end - pos_start + substring.length\n    \n            if string.substring(pos_start,\
    \ pos_end - substring.length) == string.substring(pos_start + substring.length,\
    \ substring.length)\n                then\n                    return pos_end\
    \ - pos_start + substring.length\n    \n            if string.substring(pos_start,\
    \ pos_end - substring.length) == string.substring(pos_start + substring.length,\
    \ substring.length + 1)\n                then\n                    return pos_end\
    \ - pos_start + substring.length + 1\n    \n            if string.substring(pos_start,\
    \ pos_end - substring.length) == string.substring(pos_start + substring.length\
    \ + 1, pos_end)\n                then\n                    return pos_end - pos_start\
    \ + substring.length + 1\n    \n            if string.substring(pos_start, pos_end\
    \ - substring.length) == string.substring(pos_start + substring.length + substring.length,\
    \ string_length)\n                then\n                    return pos_end - pos_start\
    \ + substring.length + substring.length\n    \n            if string.substring(pos_start,\
    \ pos_end - substring.length) == string.substring(pos_start + substring.length\
    \ + substring.length + 1, string_length)\n                then\n             \
    \       return pos_end - pos_start + substring.length + substring.length + 1\n\
    \    \n            if string.substring(pos_start, pos_end - substring.length)\
    \ == string.substring(pos_start + substring.length + substring.length + substring.length,\
    \ string_length)\n                then\n                    return pos_end - pos_start\
    \ + substring.length + substring.length + substring.length\n    \n           \
    \ if string.substring(pos_start, pos_end - substring.length) == string.substring(pos_start\
    \ + substring.length + substring.length + substring.length + substring.length,\
    \ string_length)\n                then\n                    return pos_end - pos_start\
    \ + substring.length + substring.length + substring.length + substring.length\n\
    \    \n    if pos_start < substring.length && pos_end >= substring.length\n  \
    \      then\n            if string.substring(pos_start, pos_end - substring.length)\
    \ == substring \n                then\n                    return pos_end - pos_start\
    \ + 1\n    \n            if string.substring(pos_start, pos_end - substring.length)\
    \ == string.substring(pos_start + substring.length, substring.length)\n      \
    \          then\n                    return pos_end - pos_start + substring.length\n\
    \    \n            if string.substring(pos_start, pos_end - substring.length)\
    \ == string.substring(pos_start + substring.length, substring.length + 1)\n  \
    \              then\n                    return pos_end - pos_start + substring",
  "    if string.startswith(substring) == true \n        return 1 + how_many_times(substring(1),\
    \ string) - how_many_times(substring(1), substring(1))\n    else \n        return\
    \ 0\nend\n</cell>\n<code language=julia-0.5>\nhow_many_times(\"\", \"a\")\n</cell>\n\
    <code language=julia-0.5>\nhow_many_times(\"aaa\", \"a\")\n</cell>\n<code language=julia-0.5>\n\
    how_many_times(\"aaaa\", \"aa\")\n</cell>\n<text>\nRecursion", "    \n    if string\
    \ == \"\" || substring == \"\"\n        return 0\n    \n    substring_index =\
    \ 0\n    string_length = len(string)\n    \n    for index in 0..(string_length-1)\n\
    \        \n        if string[index] == substring[substring_index]\n        \n\
    \            if substring_index + 1 < length(substring)\n                substring_index\
    \ += 1\n            else\n                return substring_index\n           \
    \ end\n        end\n    end\n    \n    return substring_index\nend\n</cell>\n\
    <code language=julia-1.0>\nhow_many_times(\"\", \"a\")\n</cell>\n<code language=julia-1.0>\n\
    how_many_times(\"aaa\", \"a\")\n</cell>\n<code language=julia-1.0>\nhow_many_times(\"\
    aaaa\", \"aa\")\n</cell>\n<text>\nImplement the longest_sub_string function which\
    \ takes a string and a substring as arguments and returns the length of the longest\
    \ substring in string. Longest substring is defined as longest prefix where all\
    \ characters in substring are in string. Examples:", "    if string==\"\" || substring==\"\
    \" then \n        return 0 \n    else \n        return count_overlaping(string,\
    \ substring) \nend ", "    if string == \"\" && substring == \"\" \n        return\
    \ 0 \n    else if string == \"\" && substring != \"\"\n        return -1 \n  \
    \  else if string != \"\" && substring == \"\"\n        return 1 \n    else \n\
    \        if substr(string, 1, substring.length) == substring\n            how_many_times(substr(string,\
    \ 2, substring.length - 1), substring)\n            else \n            how_many_times(substr(string,\
    \ 1, substring.length), substring)\n        end", "  \n    \"\"\"\n    Count how\
    \ many times a given substring can be found in the original string. \n    Count\
    \ overlapping cases.\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3\n    \"\"\
    \"", "    \n    let substr = substring_with_index(string,substring)\n    let count\
    \ = count(substring,string)\n    let new_count = count + 1\n    if new_count <\
    \ length(substring) \n        then how_many_times(substring(new_count,string),substring)\n\
    \        else new_count\nend", '    #Your code here', "    if substring.length()\
    \ == 0 \n        return 0 \n    else if substring.length() <= string.length()\
    \ \n        return substring.length() \n    else \n        count_sub = 0\n   \
    \     for index in 1..string.length() - substring.length() \n            if string.substring(index,\
    \ substring.length()) == substring \n                count_sub += 1\n        return\
    \ count_sub + how_many_times(string.substring(1), substring) ", "    if string==\"\
    \" and substring==\"\" then return 0\n    else if string==\"\" then return 0\n\
    \    else if substring==\"\" then return 1\n    else if string==substring then\
    \ return 1\n    else if substring(1,string.length)==string then return 1 + how_many_times(substring(2,string.length),substring)\n\
    \    else if substring(1,string.length)<string then return how_many_times(substring(2,string.length),substring)\n\
    \    else return how_many_times(substring(1,string.length),substring)\nend\n</code>\n\
    This solution makes use of recursion to solve the problem of finding how many\
    \ times a given substring can be found in a string. The function is called recursively\
    \ until it finds a solution, then the result is added to the running total to\
    \ find the solution for all substrings.\n<|/ a tags=substring,string,julia,algorithm\
    \ |>\n<| a dscore=1 |>\nThis is an answer to the question \"How to find the number\
    \ of times a given substring occurs in a string\", which was asked on AskUbuntu,\
    \ but unfortunately there is no \"accepted answer\" for this.\nI thought I would\
    \ provide a Julia implementation of the algorithm described here:\n<code>", " \
    \   if string==substring or substring(1,end-1)==string then return 0 else return\
    \ 1 else return how_many_times(substring(1,end-1),string) + how_many_times(substring(end,length(string)),\
    \ substring) \nend", "    if string == \"\" or substring == \"\" return 0\n  \
    \  \n    len1 = length(substring)\n    len2 = length(substring)\n    if len2 <=\
    \ 0 { return 0 }\n    \n    let substr_length = len(substring)\n    let start\
    \ = string\n    for i in 1..len2 do\n        if substring(len1-i) != substring(len1-i-1)\n\
    \            { start = substring(len1-i)\n                return start + len1\
    \ - 1\n            }\n        end\n    end\n    return start + len1 - len2\nend\
    \ \"\"\"", "    | string.length <= substring.length = String.length(string)\n\
    \    | otherwise = how_many_times_aux(string,substring,0,string.length,substring.length,0)\n\
    \    where\n        how_many_times_aux(string::String, substring::String, start::Int64,\
    \ end::Int64, length::Int64, found::Int64)::Int64 \n        | length <= 0 = 0\n\
    \        | otherwise =\n            how_many_times_aux(string, substring, start,\
    \ min(end, length), found + 1 if string.starts_with!(substring, start) else found,\
    \ length)\n        | otherwise = how_many_times_aux(string, substring, start,\
    \ max(end, length), found + 1 if string.ends_with!(substring, end) else found,\
    \ length)\n</code>\n<|/ a tags=string,julia,algorithm dscore=2 |>\n<| c |>\nI\
    \ ran your script on a large file (5GB) and it ended up with an out of memory\
    \ error. Did you test this on a file that you have previously loaded into memory?\n\
    <|/ c |>\n<| c |>\nI ran it on a file that I have previously loaded into memory.\
    \ If my memory serves me correctly, I ran it in about 5 minutes. And that's also\
    \ the time it took to load it into memory. It's not the fastest way to get it\
    \ done.\n<|/ c |>\n<| a |>\nThis might work for you:\n<code>", "\"\"\"Return the\
    \ number of times that substring appears in string.\"\"\"\n    count = 0\n   \
    \ for ch in string:\n        if ch == substring:\n            count += 1\n   \
    \ return count", "    local count = 0\n    for i in string:gmatch('(.-)'):gmatch('\\\
    \\1'):gmatch('\\\\2'):gmatch('\\\\3'):gmatch('\\\\4'):gmatch('\\\\5'):gmatch('\\\
    \\6'):gmatch('\\\\7'):gmatch('\\\\8'):gmatch('\\\\9'):gmatch('\\\\0'):gmatch('\\\
    \\A'):gmatch('\\\\B'):gmatch('\\\\C'):gmatch('\\\\D'):gmatch('\\\\E'):gmatch('\\\
    \\F'):gmatch('\\\\G'):gmatch('\\\\H'):gmatch('\\\\I'):gmatch('\\\\J'):gmatch('\\\
    \\K'):gmatch('\\\\L'):gmatch('\\\\M'):gmatch('\\\\N'):gmatch('\\\\O'):gmatch('\\\
    \\P'):gmatch('\\\\Q'):gmatch('\\\\R'):gmatch('\\\\S'):gmatch('\\\\T'):gmatch('\\\
    \\U'):gmatch('\\\\V'):gmatch('\\\\W'):gmatch('\\\\X'):gmatch('\\\\Y'):gmatch('\\\
    \\Z'):gmatch('\\\\0'):gmatch('\\\\n'):gmatch('\\\\r'):gmatch('\\\\t'):gmatch('\\\
    \\v'):gmatch('\\\\b'):gmatch('\\\\f'):gmatch('\\\\e'):gmatch('\\\\'):gmatch(\"\
    \\\\-\"):gmatch(\"\\\\+\"):gmatch(\"\\\\=\"):gmatch(\"\\\\?\"):gmatch(\"\\\\!\"\
    ):gmatch(\"\\\\<\"):gmatch(\"\\\\>\"):gmatch(\"\\\\~\"):gmatch(\"\\\\:\"):gmatch(\"\
    \\\\;\"):gmatch(\"\\\\,\"):gmatch(\"\\\\\\\"\"):gmatch(\"\\\\'\"):gmatch(\"\\\\\
    :\"):gmatch(\"\\\\;\"):gmatch(\"\\\\,\"):gmatch(\"\\\\\\\"\"):gmatch(\"\\\\'\"\
    ):gmatch(\"\\\\:\"):gmatch(\"\\\\;\"):gmatch(\"\\\\,\"):gmatch(\"\\\\\\\"\"):gmatch(\"\
    \\\\'\"):gmatch(\"\\\\;\"):gmatch(\"\\\\,\"):gmatch(\"\\\\\\\"\"):gmatch(\"\\\\\
    '\"):gmatch(\"\\\\;\"):gmatch(\"\\\\,\"):gmatch(\"\\\\\\\"\"):gmatch(\"\\\\'\"\
    ):gmatch(\"\\\\;\"):gmatch(\"\\\\,\"):gmatch(\"\\\\\\\"\"):gmatch(\"\\\\'\"):gmatch(\"\
    \\\\;\"):gmatch(\"\\\\,\"):gmatch(\"\\\\\\\"\"):gmatch(\"\\\\", "    if string\
    \ == substring\n        return 0\n    if string == \"\"\n        return 1\n  \
    \  if string == substring[:-1]\n        return 1 + how_many_times(string[end],\
    \ substring)\n    else\n        return how_many_times(string[end - 1] + string[end],\
    \ substring) + how_many_times(string[end - 1] + string[end - 1], substring)\n\
    end", "    |0 \n    |string.find(substring) == -1\n    |\n    string.count(substring)\
    \ \nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nJust a small improvement, I think\
    \ you meant to write `-1 != string.find(substring)`\n<|/ c |>\n<| a dscore=2 |>\n\
    I made this function based off of the answer from and thought I'd share in case\
    \ it helps anyone in the future.\nI added some comments in the code to explain\
    \ how it works.\n<code>", "    if substring==\"\"\n        return 0\n    return\
    \ string==\"\" ? 0 : count(substring,string) + how_many_times(substring(1),string)\n\
    end\n</cell>\n<code language=julia-1.0>\n\"\"\"\n    count_overlaps(string::String,\
    \ substring::String)\n    Count how many times a substring appears in an original\
    \ string\n    >>> count_overlaps(\"\", \"a\")\n    0\n    >>> count_overlaps(\"\
    aaa\", \"a\")\n    3\n    >>> count_overlaps(\"aaaa\", \"aa\")\n    3\n    \"\"\
    \"", "    count = 0\n    for char in string:\n        if char == substring:\n\
    \            count += 1\n    return count", "    if string == \"\" || substring==\"\
    \"\n        return 0\n    elseif substring == string\n        return 1 \n    elseif\
    \ substring[0] == string[0]\n        return 1 + how_many_times(substring[1:],\
    \ string[1:])\n    else\n        return 1 + how_many_times(substring[1:], string[1:])\n\
    \    end\nend\n</cell>\n<text>\nFinding the most frequent substring\nNext we will\
    \ define a function most_frequent() that takes as input a String and a substring\
    \ and returns the index of the most frequent substring found in the original string.\
    \ The function should return -1 if the string or the substring cannot be found.",
  "    if string.find(substring) == -1 then return 0 else 1 + how_many_times(string.substring(string.find(substring))::String,\
    \ substring)\n</code>\nAnd that's it! It doesn't even have to return a value,\
    \ as long as you return a number. \n<code>\nhow_many_times(\"aaaa\", \"aa\")\n\
    </code>\nGives us 3, because there's 3 times of \"aa\" in the string \"aaaa\"\
    . \n<code>\nhow_many_times(\"aaaa\", \"aaa\")\n</code>\nGives us 4, because there's\
    \ 4 times of \"aaa\" in the string \"aaaa\". \nTo find the biggest possible number\
    \ of occurences of a substring you can use the following code (that I've been\
    \ using for quite a while actually):\n<code>\n\"\"\"\nFind how many times a given\
    \ substring can be found in the original string.", "    if substring == \"\" then\
    \ return 0\n    else if string == \"\" then return 0\n    elseif substring(string)\
    \ == \"\" then return 0\n    else return 1 + (if substring(string) < substring(string)\
    \ then 1 else 0)\n    end\nend\n</code>\n<|/ a tags=algorithm,string,string-search,haskell\
    \ dscore=1 |>\n<| c |>\nThis does not answer the question.\n<|/ c |>\n<| c |>\n\
    I agree with, this is basically a homework question, so your answer would not\
    \ help them learn.\n<|/ c |>\n<| c |>\n, it is an answer to the question, which\
    \ the OP can use as a basis for their own homework.\n<|/ c |>\n<| a tags=algorithm,string,string-search,haskell\
    \ |>\nHere's a function that does the same thing as the accepted answer, but is\
    \ significantly faster:\n<code>\nimport Data.List", "    #If string is None or\
    \ substring is None then return 0\n    if string == None or substring == None\
    \ \n        return 0 ", "    string::String \n    substring::String\n    Int64\
    \ \n    sum::Int64 = 0\n    for a in string\n        sum::Int64 = 0\n        for\
    \ b in substring\n            sum::Int64 = sum + 1\n            if a == b\n  \
    \              break\n            end\n        end\n    end\n    return sum\n\
    end\n</cell>\n<code language=julia-1.1>\n# find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\nhow_many_times(\"\
    \", \"a\")\nhow_many_times(\"aaa\", \"a\")\nhow_many_times(\"aaaa\", \"aa\")\n\
    </cell>\n<code language=julia-1.1>\nhow_many_times(\"\", \"c\")\nhow_many_times(\"\
    aaa\", \"a\")\nhow_many_times(\"aaaa\", \"aa\")\nhow_many_times(\"cccc\", \"c\"\
    )\nhow_many_times(\"ccc\", \"c\")\nhow_many_times(\"ccc\", \"cc\")\nhow_many_times(\"\
    ccc\", \"cca\")\nhow_many_times(\"ccc\", \"ccc\")\nhow_many_times(\"ccc\", \"\
    ccca\")\nhow_many_times(\"ccc\", \"cccaa\")\n</cell>\n<text>\nfind how many times\
    \ a given substring can be found in the original string. Count overlaping cases.",
  "    if string == \"\" || substring==\"\"\n        0\n    else\n        how_many_times(string,\
    \ substring[1:]) + 1 \n            + (if substring[0] in string\n            \
    \    then how_many_times(string[1:], substring)\n                else 0)\nend",
  "| string == \"\" && substring == \"a\" || substring == \"\" && string == \"a\"\
    \ && how_many_times(string[1:], substring[1:])::Int64\n| otherwise = how_many_times(string[1:],\
    \ substring[1:])::Int64 + 1 // how_many_times(string[1:], substring)\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis was my first solution, and it's nice and short.\
    \ But it does a linear scan of the string for each character, whereas `String.find`\
    \ does it in constant time. I guess the `String.find` method was a nice and fast\
    \ solution to a simple problem. `String.find` was a very good example to illustrate\
    \ how fast `String.find` is, because it was implemented efficiently.\n<|/ c |>\n\
    <| c |>\nThanks for the feedback! It would be interesting to have a better solution.\
    \ Perhaps some kind of binary search? But that would probably require an `Array`\
    \ of length `String` for the prefix sums, so not really worth the extra effort.\n\
    <|/ c |>\n<| a dscore=1 |>\nI wrote a short program that does this in constant\
    \ time. Here it is:\n<code>\nimport Data.List", "    if string == \"\" || substring\
    \ == \"\" then \n        return 0\n    elseif string.StartsWith(substring) then\
    \ \n        return 1 + how_many_times(string.[string.Length - substring.length..],\
    \ substring)\n    else\n        return how_many_times(string.[1..], substring)\n\
    \    end\nend\n\"\"\"\nCalculate the number of times a character occurs in a string.",
  "    if string.length == 0 || substring.length == 0\n        return 0\n    else\
    \ if string == substring\n        return string.length\n    elif string.startswith(substring)\n\
    \        return 1 + how_many_times(string[string.length..], substring)\n    else\n\
    \        return 1 + how_many_times(string[1..], substring)\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nhow_many_times(\"\", \"a\")\n</cell>\n<code language=julia-1.5>\n\
    how_many_times(\"aaa\", \"a\")\n</cell>\n<code language=julia-1.5>\nhow_many_times(\"\
    aaaa\", \"aa\")\n</cell>\n<code language=julia-1.5>\nhow_many_times(\"abcd\",\
    \ \"bc\")\n</cell>\n<code language=julia-1.5>\nhow_many_times(\"aaaa\", \"aa\"\
    )\n</cell>\n<text>\nThe longest common substring problem\nIn combinatorics, a\
    \ longest common subsequence (LCS) problem is a problem of finding the longest\
    \ subsequence (LCS) of a given string $X$, which is another given string $Y$.\
    \ An example is the longest subsequence of alphabetically ordered words. Given\
    \ strings $X$ and $Y$, LCS is the subsequence in which the two words share, e.g.\
    \ \"cat\" and \"hat\"", "    |=> length(filter(x-> x == substring, string)) +\
    \ 1\n</code>\nThe function length will compute the length of the string (the number\
    \ of characters) and filter will remove all the elements that are not equal to\
    \ the substring.\n<|/ a tags=julia |>\n<| a |>\nUsing regex match on pattern .*\
    \ is almost equivalent to indexing in string. \n<code>\njulia> using Regex", " \
    \   if string == \"\" then 0 else 1 + how_many_times(string[1:end], substring)\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThank you! This works well and very simple\n\
    <|/ c |>\n<| a dscore=0 |>\nHere's a recursive solution:\n<code>\nusing Fenix",
  "    count = 0\n    found = false\n    for char in string\n        if char == substring\n\
    \            count = count + 1\n        else\n            if char == substring[1]\n\
    \                if found == false\n                    found = true\n       \
    \             count = count + 1\n            end\n        end\n    end\n    return\
    \ count\nend\n</cell>\n<cell>\nhow_many_times(\"\", \"a\")\n</cell>\n<cell>\n\
    how_many_times(\"aaa\", \"a\")\n</cell>\n<cell>\nhow_many_times(\"aaaa\", \"aa\"\
    )\n</cell>\n<text>\nExercise: Write a function that finds and returns the index\
    \ of the first occurrence of the substring in the string.\nHint: Use a for loop.\n\
    Example: When finding the index of an element in a given array, use the index()\
    \ function and print the index.", "    if string == \"\" \n        then 0 \n \
    \       else if string.contains(substring) \n            then string.count(substring)\
    \ + 1 \n            else 0 \n    end\nend", "    length :: Int64 = length(substring)\n\
    \    string :: String = string(substring)\n    \n    count :: Int64 = 0\n    \n\
    \    length :: Int64 = length(substring)\n    for i :: Int64 = 1:length(string)\n\
    \        if string[i]==substring[1]\n            if string[i+1] == substring[2]\
    \ \n                count += 1\n            else\n                break\n    \
    \    end\n    end\n    return count\nend\n</cell>\n<code language=julia-1.1>\n\
    how_many_times(\"aaaa\", \"aa\")\n</cell>\n<text>\nHowManyTimes()", "    if substring\
    \ == \"\"\n        return 0\n    end = 0\n    found = 0\n    for p in string.string.findall(substring)\n\
    \        found = 1\n        end = p\n    end\n    found -= 1\n    return found\n\
    end", "    return (string.count(substring)\n           - string.count(substring[1:string.index(substring)])\n\
    \           + string.count(substring[:string.index(substring)]))", "    if !string.contains(substring)\
    \ then\n        return 0\n    else if substring.length == 1 then\n        return\
    \ 1\n    else if substring.length == 0 then\n        return string.length\n  \
    \  else\n        return string.length - string.index(substring) + 1\n    end\n\
    end\n</cell>\n<cell>\n@test how_many_times(\"aaa\", \"a\") \u2248 3\n</cell>\n\
    <text>\nCombining Functional Programming with Python\nCombining functional programming\
    \ with Python is done in a similar way as it is done with Julia or R. Python is\
    \ an imperative language and thus we must always think differently when designing\
    \ and implementing code. One of the main strengths of functional programming is\
    \ the composability of code. Combining functional programming with Python allows\
    \ us to solve problems in a much more efficient and readable way. Let's start\
    \ by taking a look at functional composition.", "  result <- 0\n  for _ in 0..string.len()-substring.len()+1\
    \ do \n    if substring in string.substring(0,_) then\n      result <- result\
    \ + 1\n      break\n  result\nend\n</cell>\n<code language=julia-1.0>", "    \"\
    \"\"Counts the number of times a given substring can be found in the original\
    \ string. Count overlaping cases.\"\"\"\n    \"\"\"return number of times the\
    \ substring can be found in the original string.\"\"\"\n    if string.index(substring)==-1\n\
    \        return 0\n    return 1 + how_many_times(string[string.index(substring)+1:],\
    \ substring)\n\"\"\"Count the number of times the substring can be found in the\
    \ original string. Count overlaping cases.\"\"\"\n    return how_many_times(string,\
    \ substring)", "    if string.startswith(substring)\n        return 1 + how_many_times(string.substring(substring.length),\
    \ substring)\n    else\n        return 0\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    how_many_times(\"aaaa\", \"aa\")\n</cell>\n<code language=julia-1.0>\n# Find how\
    \ many times each substring can be found in the original string", "    if string\
    \ == substring then\n        return 1\n    elseif string.startswith(substring)\
    \ then\n        len = substring.length()\n        return 1 + how_many_times(string[len..],\
    \ substring)\n    else\n        return 0\nend\n</cell>\n<text>\nExercise 8\nImplement\
    \ is_palindrome which checks whether the given string is a palindrome. For example,\
    \ is_palindrome(\"abba\") should return true, while is_palindrome(\"aba\") should\
    \ return false.", "    if string == \"\"\n        0\n    else if substring.length()\
    \ == 0\n        1\n    else if substring.length() <= string.length()\n       \
    \ how_many_times(string, substring[1:]) + 1\n    else if substring.substring(0,\
    \ substring.length() - string.length()) == string\n        how_many_times(string,\
    \ substring[substring.length() - string.length():]) + 1\n    else\n        how_many_times(string,\
    \ substring) + 0\nend\n</cell>\n<code language=julia-1.3>", "    if string.length\
    \ < substring.length { return 0 }\n    var count::Int64 = 0\n    for i <- 1 to\
    \ substring.length do \n        if string.substring(i) == substring then \n  \
    \          count += 1\n        else\n            break\n    return count\n\"\"\
    \"\n# We can do similar things for patterns\n\"\"\"\n# Lets see how to use pattern\
    \ matching\n\"\"\"", "    # Your code goes here\n    return string.count(substring)\n\
    </code>\n<|/ a tags=string,arrays,count,ocaml,count |>\n<| c |>\nWhat if string\
    \ and substring are very large strings?\n<|/ c |>\n<| c |>\nIn that case you might\
    \ want to use `string_of_inplace_modification ` to change your string in-place\n\
    <|/ c |>\n<| a dscore=4 |>\nA simple way would be:\n<code>\nList.fold_left (fun\
    \ _ i c -> (i+=1) if (String.mem c string) > 0 then i else 0) 0 string\n</code>\n\
    I used List.top_while to count the number of occurences, it works well even for\
    \ very long strings.\n<|/ a tags=string,arrays,count,ocaml,count |>\n<| c |>\n\
    The above code will work but it is extremely inefficient. String.mem does a linear\
    \ search, therefore it is O(n).\n<|/ c |>\n<| c |>\nHow about using String.mem\
    \ to check whether the character is present, as opposed to checking its existence?\n\
    <|/ c |>\n<| a tags=string,arrays,count,ocaml,count |>\nHere's a little helper\
    \ function I wrote to solve this problem (it just returns the length of the substring,\
    \ so you might want to adjust it to return an int that tells you the number of\
    \ occurrences)\n<code>\nlet rec countSubstring substr str =\n  match str with\n\
    \  | [] -> 0\n  | head :: tail ->\n    match sub with\n    | [] -> 0\n    | _\
    \ when String.mem sub str -> 1 + (countSubstring sub tail)\n    | _ -> 0\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nThis code can be improved, but it works and it's elegant!\n\
    <|/ c |>\n<| c |>\nString.mem is O(n) operation. How do you count it in O(n) ?\n\
    <|/ c |>\n<| a tags=string,arrays,count,ocaml,count |>\nThis doesn't seem to be\
    \ the best way to go about this in OCaml, but this was the only thing I could\
    \ come up with:\n<code>\nopen Core.Std", "if string == \"\" then return 0\nelse\
    \ if substring in string then return 1 + how_many_times(string[end-1], substring)\n\
    else return how_many_times(string[1:end-1], substring)\nend \n\"\"\"\nCount how\
    \ many times a given substring can be found in the original string. Count overlaping\
    \ cases.", "    if string == \"\" || substring == \"\" \n        0\n    else\n\
    \        str_len := string length\n        substr_len := substring length\n  \
    \      result := 0\n        for i = 0 to str_len - substr_len \n            if\
    \ substring(i, substr_len) == string[i:i+substr_len]\n                result :=\
    \ result + 1\n            else\n                result := result \n        end\n\
    \        result\n    end\nend\n</code>\n<|/ a tags=lua,string |>\n<| a dscore=2\
    \ |>\nYou can try this function which is taken from Lua reference manual (the\
    \ second code block in the section \"2.5.1 Functions\"): \n<code>", "    if string==\"\
    \" \n        0\n    elseif substring==\"\" \n        string.length\n    else\n\
    \        string.length + how_many_times(substring(1,string.length),substring(0,string.length))\n\
    end", "    string_length = len(string)\n    substring_length = len(substring)\n\
    \    result_count = 0\n    for char in string:\n        if char == substring[0]:\n\
    \            result_count += how_many_times(string[1:string_length], substring[1:])\n\
    \        else:\n            result_count += how_many_times(string[1:string_length],\
    \ substring)\n    return result_count\nend\n</cell>\n<code language=julia-1.0>\n\
    how_many_times(\"\", \"a\")\n</cell>\n<code language=julia-1.0>\nhow_many_times(\"\
    aaa\", \"a\")\n</cell>\n<code language=julia-1.0>\nhow_many_times(\"aaaa\", \"\
    aa\")\n</cell>\n<text>\nExercise 3\nImplement the function count_substrings that\
    \ takes a String as input and returns a Vector containing the number of times\
    \ the given substring is found in the original string.\nThe substring should be\
    \ the same length as the original string.\nUse regular expressions to search and\
    \ replace for the substring in the original string.", "    i = 0\n    while i\
    \ <= length(string) - length(substring) - 1 do\n        if substring(i, length(substring))\
    \ in string then i := i + 1 else i := i - 1\n        i := i + 1\n    end\n   \
    \ return i\nend\n</cell>\n<code language=julia-0.6>\nhow_many_times(\"\", \"a\"\
    )\n</cell>\n<code language=julia-0.6>\nhow_many_times(\"aaa\", \"a\")\n</cell>\n\
    <code language=julia-0.6>\nhow_many_times(\"aaaa\", \"aa\")\n</cell>\n<text>\n\
    Exercise: Word counting\nWrite a function which returns the number of unique words\
    \ in a given text.", "    if string == \"\"\n        return 0\n    else if substring\
    \ == \"\"\n        return 1\n    else if substring == string\n        return string.length()\n\
    \    else \n        string_start = string.find(substring)\n        string_end\
    \ = string_start + substring.length()\n        string_middle = string[string_start..string_end]\n\
    \        return how_many_times(string.slice(string_start, string_end), substring)\n\
    \    end\nend\n</cell>\n<text>\nExercise 1\nWrite a function that prints the reverse\
    \ of a string.", "    if substring == \"\"\n        return 0 \n    else \n   \
    \     return 1 if string.endswith(substring) else how_many_times(string[1:], substring)",
  "    count = 0\n    for i <- 0 until string.length()\n        if string.sub(i, i)\
    \ == substring\n            count += 1\n        end\n    end\n    return count\n\
    end\n</cell>\n<code language=julia-1.0>\nhow_many_times(\"\", \"a\")\n</cell>\n\
    <code language=julia-1.0>\nhow_many_times(\"aaa\", \"a\")\n</cell>\n<code language=julia-1.0>\n\
    how_many_times(\"aaaa\", \"aa\")\n</cell>\n<text>\nExercise 8.4.6: Repeating substrings\n\
    Write a function which finds how many times a given substring can be found in\
    \ the original string.", "    if string.is_empty() || substring.is_empty() ||\
    \ substring.head == string.head \n        then 0 \n        else 1 + how_many_times(string.tail,\
    \ substring.tail)\n    end\nend", "    let count_of_substring = 0\n    if string\
    \ == \"\" then return 0\n    else if string[1..] == substring then count_of_substring\
    \ += 1 \n    else for sub_str in substring[1..] do count_of_substring = how_many_times(string[1..],\
    \ sub_str)\n    return count_of_substring\n\"\"\"", "    if string == \"\" ||\
    \ substring == \"\" then 0 else count sub string in string\n</code>\nThis is just\
    \ pseudocode, but the idea is the same.\n<|/ a |>\n<| a tags=string,count,haskell\
    \ dscore=2 |>\nJust use \n<code>\nhow_many_times :: String -> String -> Int\n\
    </code>\n<|/ a |>\n<| c |>\nHmm. How can you use a function on strings? Maybe\
    \ you meant that for you?\n<|/ c |>\n<| c |>\nOh, I'm sorry, I got confused and\
    \ thought that the question was about a function that takes a string and substring\
    \ as parameters, like `how_many_times(\"foobar\", \"o\")` would return 3.\n<|/\
    \ c |>\n<| c |>\nI thought that too, but I didn't know if that were the answer\
    \ to the question... anyway, you can just use `how_many_times = length . filter\
    \ (=='o') . filter (=='b')` :)\n<|/ c |>\n<| c |>\nI know, I was just adding it\
    \ as an alternative to his solution, since he was already using some function\
    \ from standard libraries. Btw, your solution doesn't work if `substring == \"\
    oo\"` (it would return 2, which should be 1).\n<|/ c |>\n<| c |>\nOh, I see what\
    \ you mean now, thanks.\n<|/ c |>\n<| a dscore=2 |>\nI would have done it using\
    \ list comprehensions.\n<code>\nhow_many_times :: String -> String -> Int\nhow_many_times\
    \ str substr = length [i | i <- substr, str == i]\n</code>\n<|/ a tags=string,count,haskell\
    \ |>\n<| a tags=string,count,haskell |>\nJust use length or foldl. length is a\
    \ predefined function for lists.\n<code>\nhow_many_times = foldr (\\l s -> (length\
    \ l + 1) + (s == [])) 0\n</code>\nfoldl is essentially foldl but for function\
    \ application. length returns a single number so you just add 1\n<code>\nhow_many_times\
    \ = foldr (\\l s -> (length l + 1) + (s == [])) 0\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\n`length` is defined on the list class already. Using an additional function\
    \ here is redundant (and inefficient).\n<|/ c |>\n<| c |>\nI agree that `length`\
    \ is defined on `[]` already. However `foldl` ", "    if !is_empty(string) \n\
    \        if string.contains(substring) \n            return count(string) - count(substring)\
    \ \n        else \n            return 0 \n    else \n        return 1 \nend",
  "    \"\"\"Count how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3\n    >>> how_many_times(\"aaaa\", \"aa\"\
    )\n    3\n    \"\"\"\n    return sum(substring in string for i in 1:string.len)\n\
    end", "    if string == \"\" || substring == \"\" \n        0\n    else\n    \
    \    string.count(substring)\nend", "    if substring==\"\"\n        return 0\
    \ \n    else if substring.length() == 0\n        return 1 \n    else if string.length()\
    \ == 0\n        return 0 \n    else if string.charAt(0) == substring.charAt(0)\n\
    \        return how_many_times(string.substring(1), substring) \n    else \n \
    \       return how_many_times(string.substring(1), substring) + 1 \nend\n</cell>\n\
    <text>\nExercise\nWrite a function that takes a string and returns all occurences\
    \ of the substring in the string. \nRemember that the string may be empty", " \
    \   string |> find_all(substring) |> length |> return\nend", "    if string ==\
    \ \"\" || substring.length() == 0\n        return 0\n    \n    # initialize starting\
    \ index\n    let startIndex = 0\n    \n    # start iterating from the right side\
    \ of the string\n    for char <- (string.length - substring.length)..length(string)\n\
    \        do\n            if string[char] == substring[0 .. substring.length -\
    \ 1]\n            then \n                startIndex = char\n            elseif\
    \ char == length(substring) - 1\n            then\n                return startIndex\
    \ - substring.length - 1\n        end\n    end\n    \n    return 0\nend\n</cell>\n\
    <text>\nThe count_characters function is very similar to how_many_times except\
    \ it uses a counter to keep track of how many times a substring has been found\
    \ in the original string.", "    count <- 0\n    \n    for _str in string:\n \
    \       if substring==_str:\n            count <- count + 1\n        else\n  \
    \          count <- count + how_many_times(string, _str)\n        \n    return\
    \ count\nend #how_many_times", "| \n    0 <= \n        length(substring) < \n\
    \        length(\n            string\n        ) || \n        substring.length\
    \ > string ||\n        substring.length < 0\n    ->\n        -1", "    count =\
    \ 0\n    for c in string:\n        if c == substring:\n            count += 1\n\
    \    return count\nend how_many_times\n</cell>\n<code language=julia-0.5>", "\"\"\
    \"\nFind the total number of times a given substring can be found in the original\
    \ string.\n\"\"\" \n  \n  function how_many_times(string::String, n::Int64)::Int64\
    \ \n\"\"\"\nFind the total number of times a given integer can be found in the\
    \ original string.\n\"\"\" ", "    return sum(substring in string for i in 1:length(string))\n\
    </code>\n<|/ a dscore=2 |>\n<| a tags=string,count,python,python-3.x |>\nHere's\
    \ another solution:\n<code>\ndef count_substring(s, sub):\n    n = 0\n    for\
    \ i in range(len(s)):\n        if s[i:i+len(sub)] == sub:\n            n += 1\n\
    \    return n\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nThis was the shortest\
    \ I could get:\n<code>\ndef count_substring(s, sub):\n    return s.count(sub)\n\
    </code>\n<|/ a tags=string,count,python,python-3.x |>\n<| a |>\nAs another user\
    \ said, a generator function would work well here. \n<code>\ndef count_substring(s,sub):\n\
    \  i=0\n  while True:\n    i = s.find(sub,i)\n    if i == -1:\n       return 0\n\
    \    i = i+len(sub)\n    yield i\n</code>\nThis function is an example of the\
    \ \"generator function\" philosophy, and is a nice way to implement the functionality\
    \ you desire. It will continue iterating over your string until it runs out of\
    \ matches. \nThe function will return a generator object, which is an iterator\
    \ that generates the indexes at which your sub string was found. \nFor instance:\n\
    <code>\nfor x in count_substring(string,'aa'):\n  print(x)\n</code>\nwill print\
    \ 0,4,7\n<|/ a dscore=0 tags=string,count,python,python-3.x |>\n<| c |>\nIn your\
    \ first example `sub` should be `'aaa'` and `string` should be `\"aaaa\"`\n<|/\
    \ c |>\n<| c |>\ngood catch. Yeah I noticed that after I posted the comment. I\
    \ fixed it\n<|/ c |>\n<| a tags=string,count,python,python-3.x |>\nI think you\
    \ can use this function as simple as that:\n<code>\ndef count_substring(s,sub):\n\
    \    count = 0\n    i = 0\n    while i < len(s) and i < len(s):\n        if s[i]\
    \ == sub[0]:\n            count += 1\n            i += len(sub)\n            continue\n\
    \        if s[i:i+len(sub)] == sub:\n            count += 1\n            i +=\
    \ len(sub)\n            continue\n        if s[i:i+len(sub)] != sub:\n       \
    \     i += 1\n    return count\n</code>\n<|/ a dscore=0 |>\n<| a tags=string,count,python,python-3.x\
    \ dscore=0 |>\n<code>\ndef count_substring(s, sub):\n    i = 0\n    count = 0\n\
    \    while True:\n        i = s.find(sub, i)\n        if i == -1:\n          \
    \  return ", "    if substring == \"\"\n        return 1\n    else if substring[0]\
    \ == string[1]\n        how_many_times(string, substring[1:])\n    else\n    \
    \    how_many_times(string[1:], substring)\nend\n</cell>\n<code language=julia-0.5>\n\
    how_many_times(\"\", \"a\")\n</cell>\n<code language=julia-0.5>\nhow_many_times(\"\
    aaa\", \"a\")\n</cell>\n<code language=julia-0.5>\nhow_many_times(\"aaaa\", \"\
    aa\")\n</cell>\n<text>\nPart B: Finding all the matches of one substring in another\
    \ substring", "    string_length = len(string)\n    substring_index = string.index(substring)\n\
    \    count = 0\n    for index in 1:string_length-1\n        if substring_index\
    \ == index || substring_index + index == string_length\n            count += 1\n\
    \            substring_index += 1\n        end\n    end\n    return count\nend",
  "    | substring == \"\" = length(string)\n    | string.length <= substring.length\
    \ = how_many_times(string.substring(string.length - substring.length), substring)\n\
    \    | otherwise = how_many_times(string.substring(0,string.index(substring)),\
    \ \"a\") + how_many_times(string.substring(string.index(substring) + substring.length),\
    \ substring)", "    if substring == \"\" then return 0 \n    else \n        ans\
    \ = 0 \n        n = length(substring) \n        for i = 1 to n do \n         \
    \   ch = substring(i, n) \n            if string == ch then \n               \
    \ ans += 1 \n            else \n                ans -= 1 \n        end \n    \
    \    ans /= length(substring) \n        return ans \nend \"\"\"\n</cell>\n<code\
    \ language=julia-1.6>\n# Some more examples:", "    if (string == \"\" || substring\
    \ == \"\") then 0\n    if (length(substring) == 0) then return 0\n    else if\
    \ substring(string) == substring then 1 else 1 + how_many_times(substring(string),\
    \ substring)\nend", "|\n  if string.starts_with(substring) \n  |\n    string.ends_with(substring)\
    \ \n  |\n    string.contains(\"$substring$\") \n  |\n    string.contains(substring)\n\
    \  then \n    1\n  else\n    0 \n  fi\nend\n\"\"\"", "    if string == \"\" ||\
    \ substring == \"\"\n        return 0\n    else if string[0] == substring[0]\n\
    \        return 1 + how_many_times(string[1:], substring[1:])\n    else\n    \
    \    return 1 + how_many_times(string[1:], substring)\n    end\nend\n</cell>\n\
    <text>\nQuestion 5\nHow many times is each character in the string repeated? \n\
    For example, how many times each character appears in \"python\"?\n(Note: for\
    \ bonus points: how many times each character appears in the whole string)", " \
    \ how_many_times_result = 0\n  i = 0\n  j = 0\n  while i < length(string)\n  \
    \  if string(j) == substring\n      how_many_times_result += 1\n      j += 1 #\
    \ j needs to move by 1 because we want to check every char after this one\n  \
    \    while j < length(string)\n        if string(j) == substring\n          how_many_times_result\
    \ += 1\n          j += 1\n        end\n      end\n      i += 1\n    else\n   \
    \   i += 1\n    end\n  end\n  return how_many_times_result\nend\n</cell>\n<code\
    \ language=julia-1.5>\nhow_many_times(\"\", \"\")\n</cell>\n<code language=julia-1.5>\n\
    how_many_times(\"aaaa\", \"a\")\n</cell>\n<code language=julia-1.5>\nhow_many_times(\"\
    aaaa\", \"aa\")\n</cell>\n<code language=julia-1.5>\nhow_many_times(\"aaaa\",\
    \ \"aaaa\")\n</cell>\n<code language=julia-1.5>\nhow_many_times(\"a\", \"a\")\n\
    </cell>\n<code language=julia-1.5>\nhow_many_times(\"a\", \"aa\")\n</cell>\n<code\
    \ language=julia-1.5>\nhow_many_times(\"a\", \"aaaa\")\n</cell>\n<code language=julia-1.5>\n\
    how_many_times(\"aaa\", \"a\")\n</cell>\n<code language=julia-1.5>\nhow_many_times(\"\
    aaa\", \"aa\")\n</cell>\n<code language=julia-1.5>\nhow_many_times(\"aaa\", \"\
    aaaa\")\n</cell>\n<code language=julia-1.5>\nhow_many_times(\"aaaabc\", \"a\"\
    )\n</cell>\n<code language=julia-1.5>\nhow_many_times(\"aaaabc\", \"aa\")\n</cell>\n\
    <code language=julia-1.5>\nhow_many_times(\"aaaabc\", \"aaaa\")\n</cell>\n<code\
    \ language=julia-1.5>\nhow_many_times(\"aaaabc\", \"aab\")\n</cell>\n<code language=julia-1.5>\n\
    how_many_times(\"aaaabc\", \"aaab\")\n</cell>\n<code language=julia-1.5>\nhow_many_times(\"\
    aaaabc\", \"aaabc\")\n</cell>\n<code language=julia-1.5>\nhow_many_times(\"aaaabc\"\
    , \"aaaabc\")\n</cell>\n<code language=julia-1.5>\nhow_many_times(\"aaaabc\",\
    \ \"aaaabcde\")\n</cell>\n<code language=julia-", "    if string == substring\n\
    \        1\n    else\n        sum(1 for c in string if c in substring)\n    end\n\
    end\n</cell>\n<code language=julia-0.4>", "    let substring = substring.toLower()\n\
    \    let mut count = 1\n    for i in 0..string.len - substring.len + 1 do\n  \
    \      if string.sub(i, substring.len) == substring \n            count += 1 \n\
    \        else \n            count += 0\n    return count \nend", "    \"\"\"\n\
    \    Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3\n    >>> how_many_times(\"aaaa\", \"aa\"\
    )\n    3\n    \"\"\"\nend\n</cell>\n<text>\nString Functions and Operators", " \
    \ | string::String == \"\" = return 0\n  | substring == \"\" = return string::String.length()\n\
    \  | string::String.substr(0, substring::String.length()) == substring = return\
    \ 1\n  | string::String.substr(0, substring::String.length()) > substring = return\
    \ how_many_times(string::String.substr(substring::String.length()),substring)\n\
    \  | otherwise = return how_many_times(string::String.substr(substring::String.length()),substring)",
  "    if !substring.includes(string) then \n        return 0 \n    else if string.includes(substring)\
    \ then \n        count_a := 0\n        count_a += string.find(substring)\n   \
    \     return count_a\n    else \n        count_b := 0\n        count_b += string.find(substring)\n\
    \        count_b += 1\n        return count_b\n    end\nend", "    if is_empty(string)\n\
    \        return 0\n    if is_empty(substring)\n        return 1\n    if string[1]\
    \ == substring[1]\n        return how_many_times(string[2:], substring[2:])\n\
    \    \n    count = 1\n    i = 2\n    \n    while (i < length(substring)-1) do\n\
    \        if string[i] != substring[i] then\n            if string[i-1] == substring[i-1]\
    \ then\n                count += 1\n            else\n                return count\n\
    \        end\n        i = i + 1\n    end", "    count = 0\n    for i in string\n\
    \        if i == substring\n            count += 1\n        \n    return count\n\
    </cell>\n<cell>\nhow_many_times(\"\", \"a\")\nhow_many_times(\"aaa\", \"a\")\n\
    how_many_times(\"aaaa\", \"aa\")\n</cell>\n<text>\nFinding Substrings in a given\
    \ String\nGiven a string, find out how many times the given substring appears\
    \ in the string. Return a vector of zeros if there is no such substring.\nWe are\
    \ provided with two functions:", "    if string == \"\" || substring == \"\"\n\
    \        return 0\n    \n    if substring(string) == substring(substring)\n  \
    \      return 1 + how_many_times(string[1:], substring[1:])\n    \n    ans = how_many_times(string[1:],\
    \ substring)\n    \n    if substring(string) < substring(substring)\n        ans\
    \ += 1\n    \n    return ans\n</cell>\n<code language=julia-1.5>\nhow_many_times(\"\
    \", \"\")\n</cell>\n<text>\nExercise: Design an algorithm that checks if a given\
    \ string is Palindrome. Your function should ignore numbers and punctuation marks\
    \ and should ignore uppercase and lowercase letters.", "    if string.len() ==\
    \ 0 || substring.len() == 0 \n        return 0 \n    \n    n := 0\n    idx :=\
    \ string.find(substring)\n    while idx != -1 \n        n += 1 \n        idx :=\
    \ string.find(substring, idx + 1) \n    \n    return n \nend \n</cell>\n<code\
    \ language=julia-0.6>\nhow_many_times(\"aaaaa\", \"aa\")\n</cell>\n<code language=julia-0.6>\n\
    how_many_times(\"aaaaa\", \"bb\")\n</cell>\n<code language=julia-0.6>\nhow_many_times(\"\
    aaaaa\", \"c\")\n</cell>\n<code language=julia-0.6>\nhow_many_times(\"aaaaa\"\
    , \"a\")\n</cell>\n<code language=julia-0.6>\nhow_many_times(\"aaaa\", \"a\")\n\
    </cell>\n<code language=julia-0.6>\nhow_many_times(\"aaaa\", \"b\")\n</cell>\n\
    <text>\nThe longest common substring", "    if is_equal(string, substring):\n\
    \        return 1\n    if is_equal(string, substring[1..$]):\n        return 1\
    \ + how_many_times(substring[1..$], substring)\n    if is_equal(substring[1..$],\
    \ substring):\n        return 1 + how_many_times(string, substring[1..$])\n  \
    \  if is_equal(substring[1..$], substring[1..$]):\n        return how_many_times(substring[1..$],\
    \ substring)\n    return how_many_times(substring[1..$], substring[1..$])\nend\n\
    \"\"\"\nWrite an efficient function to return the number of times a substring\
    \ appears in a string. Your function should have a runtime complexity of O(n).\n\
    \"\"\"", "    if string == \"\" then \n        return 0\n    if substring == \"\
    \" then \n        return 1\n    if substring(1,length(string)) == string then\
    \ \n        return 1 + how_many_times(substring(2,length(string)), substring)\n\
    \    return how_many_times(substring(1,length(string)), substring) + 1\nend how_many_times\n\
    </cell>\n<text>\nWe can now use these functions to count how many times substrings\
    \ occur in the original string.", "    if string == \"\" || substring == \"\"\
    \ { return 0 }\n    count::Int64 = 0\n    if substring in string{\n        count\
    \ += 1\n        for char in string\n            if substring in char\n       \
    \         count += how_many_times(char, substring)\n        }\n    }\n    return\
    \ count\nend\n</cell>\n<code language=julia-1.5>", "    if string == substring\
    \ \n        1 \n    else \n        if string.startswith (substring) \n       \
    \     string.lenght - string.index (substring) \n        else \n            0\
    \ \nend\n</cell>\n<text>\nAnd another version, which does the same, but doesn't\
    \ make any checks", "\"\"\"\n    Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0\n    >>> how_many_times(\"aaa\", \"a\")\n    3\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3\n    \"\"\"", "    if string == \"\" || substring == \"\
    \"\n        return 0 \n    \n    index_start = string.findFirst(substring) \n\
    \    if index_start == -1\n        return 0 \n    \n    index_end = string.findFirst(substring,\
    \ index_start + 1) \n    if index_end == -1\n        return 0 \n    \n    return\
    \ index_end - index_start + 1 \nend\n</cell>\n<code language=julia-1.5>\nhow_many_times(\"\
    \", \"a\")\n</cell>\n<code language=julia-1.5>\nhow_many_times(\"aaa\", \"a\"\
    )\n</cell>\n<code language=julia-1.5>\nhow_many_times(\"aaaa\", \"aa\")\n</cell>\n\
    <text>\nExercise 7\nImplement a function that returns true if a given string ends\
    \ with a given substring.", "    if substring == \"\" || string == \"\"\n    \
    \    return 0\n    else if string[0] == substring[0]\n        return 1 + how_many_times(string[1:],\
    \ substring[1:])\n    else\n        return how_many_times(string[1:], substring)\
    \ + how_many_times(string[1:], substring[1:])\nend\n</code>\nThis version is also\
    \ a lot faster than the other ones, but still not good enough. Here are some of\
    \ the benchmark results:\n<code>\njulia> how_many_times(\"\", \"a\")\n  1.188\
    \ ns (0 allocations: 0 bytes)\n0", "    | substring.length <= 0 -> 0\n    | substring.length\
    \ > string.length -> 0\n    | substring.length == string.length -> (substring\
    \ == string) ? (1) : 0\n    | substring.length < string.length ->\n        let\
    \ (first, last) = string.split_at(substring.length)\n        in how_many_times(first,\
    \ substring) + how_many_times(last, substring)", "    | substring.length != string.length\
    \ = NaN\n    | otherwise = if string.length == substring.length \n           \
    \         then string.length \n                else if substring(0,1) == substring(1,1)\
    \ \n                    then how_many_times(substring(1,string.length), substring(2,string.length))\n\
    \                    else how_many_times(substring(1,string.length), substring(1,string.length))\n\
    </code>\n<|/ a dscore=1 tags=recursion,haskell,big-o,performance |>\n<| a tags=recursion,haskell,big-o,performance\
    \ |>\nTo find all occurrences of substring in a string, we can use regular expressions:\n\
    <code>\nimport Data.List (isInfixOf)", "    if string == \"\" || substring ==\
    \ \"\" then\n        return 0\n    if string.startswith(substring) then\n    \
    \    return 1 + how_many_times(string.substring(1), substring)\n    return how_many_times(string.substring(1),\
    \ substring)\nend \n</cell>\n<text>\nExercise\nThe count_substrings function takes\
    \ two strings (string1 and string2) and returns a count of the number of times\
    \ string2 occurs in string1.", "    sum = 0\n    string_length = string.length()\n\
    \    for char in substring\n        if string.starts_with(char)\n            sum\
    \ += 1\n    \n    return sum\n</code>\n<|/ a dscore=2 |>\n<| a tags=haskell |>\n\
    <code>\ncountChars :: String -> String -> Int\ncountChars a b = (length b) - (length\
    \ a) - (length [x | x <- a, b == x]) \n</code>\n<|/ a dscore=1 |>\n<| a tags=haskell\
    \ |>\n<code>\nimport Data.List", "    if string == \"\" && substring == \"\"\n\
    \        return 0\n    if substring == \"\"\n        return 1 + how_many_times(string,\
    \ substring[1:end-1])\n    if string == \"\"\n        return how_many_times(substring[1:end-1],\
    \ substring)\n    if string[end-1] == substring\n        return how_many_times(string[1:end-1],\
    \ substring)\n    return how_many_times(string[1:end-1], substring) + how_many_times(string,\
    \ substring[1:end-1])", "    substring = substring(string) #remove whitespace\n\
    \    i = 0\n    while i < length(string) - length(substring) + 1 do \n       \
    \ j = substring.length\n        while j > 0 do \n            if (string.substring(i,\
    \ j) == substring) then return 1 \n            j := j - 1\n        i := i + 1\n\
    \    return 0\nend\n</cell>\n<code language=julia-0.6>", "    local i = 0\n  \
    \  local j = string\n    while i <= j do\n        if string[i] == substring[j]\
    \ then\n            i = i + 1\n            j = j - 1\n        else\n         \
    \   i = i + 1\n        end\n    end\n    return i\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\n    how_many_times(string::String, substring::String)\n    Count overlaping\
    \ cases. Works only for Strings\n    \n    Arguments\n    ---------\n    string::String\n\
    \    substring::String\n    \n    Returns\n    -------\n    Int64\n        Number\
    \ of times a substring appears in the string\n    \n    Notes\n    -----\n   \
    \ Uses how_many_times() for more optimal case\n    \"\"\"", "    #Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    #\n    # Compute the number of times substring appears in the string.\n\
    \    count = 0\n    index = string.find(substring)\n    while index != -1 do\n\
    \        count = count + 1\n        index = string.find(substring, index+1)\n\
    \    end\n    return count\nend", "        if string == \"\" \n            0\n\
    \        else if substring == \"\"\n            string\n        else\n       \
    \     count(string, substring) \n    end\nend", "    result := 0\n    i := 0\n\
    \    j := 0\n    while (i < string.length) && (j < substring.length)\n       \
    \ if (string[i] == substring[j])\n            result += 1\n            i += 1\n\
    \            j += 1\n        else\n            i += 1\n            j += 1\n  \
    \  \n    if (j == substring.length)\n        result += 1\n    \n    return result\n\
    </cell>\n<code language=julia-1.4>\nhow_many_times(\"\", \"a\")\n</cell>\n<code\
    \ language=julia-1.4>\nhow_many_times(\"aaa\", \"a\")\n</cell>\n<code language=julia-1.4>\n\
    how_many_times(\"aaaa\", \"aa\")\n</cell>\n<text>\nQuestion 2", "    if substring\
    \ == \"\" then return 0 else 1\n    \n    if string.len > substring.length then\
    \ return 0\n    \n    if string.sub(substring, 0, substring.length) == string\
    \ then return 1\n    else return how_many_times(string.sub(substring, substring.length\
    \ + 1, substring.length + substring.length), substring)\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\n    how_many_times(string::String, substring::String)::Int64\n    Finds\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n\"\"\"", "    if string == \"\" \n        return 0 \n   \
    \ else: \n        rec <- how_many_times(string.substring(1), substring) \n   \
    \     return if string.substring(1) == substring then rec + 1 else rec \nend \n\
    </code>\n<|/ a |>\n<| a dscore=1 |>\nAs an extension to previous answers here\
    \ is a generic function which accepts an arbitrary number of strings and returns\
    \ an integer value indicating the number of times any substring occurs in the\
    \ strings.\n<code>\ncount(string, substring)\n</code>\nExample:\n<code>\n> count(string1,\
    \ string2)\n2\n</code>\nor\n<code>\n> count(string1, string2, string3, string4)\n\
    4\n</code>\nor\n<code>\n> count(string1, string2, string3, string4, string5)\n\
    6\n</code>\nor\n<code>\n> count(string1, string2, string3, string4, string5, string6)\n\
    8\n</code>\nHere is the function:\n<code>"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
