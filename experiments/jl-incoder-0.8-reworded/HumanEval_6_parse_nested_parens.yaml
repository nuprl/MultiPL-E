name: HumanEval_6_parse_nested_parens
language: jl
prompt: "\"\"\" Input to this function is a string represented multiple groups for\
  \ nested parentheses separated by spaces.\n    For each of the group, output the\
  \ deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels\
  \ of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"(()()) ((()))\
  \ () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
  (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
  \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
  end\n"
completions: ["    parsed_parens = parse(paren_string)\n    parsed_parens = sort(parsed_parens)\n\
    \    parsed_parens = parsed_parens[2:end]\n    return parsed_parens\nend", " \
    \   paren_string = paren_string.strip\n    if paren_string.head == \"(\" # parentheses\n\
    \        paren_string = paren_string.tail\n        nest_count = 1\n    elseif\
    \ paren_string.head == \"(\" # outer parentheses\n        nest_count = 1\n   \
    \ elseif paren_string.head == \")\" # inner parentheses\n        nest_count +=\
    \ 1\n    else\n        nest_count = 0\n    end\n    return paren_string.split(\"\
    )\")[1].split(\" \").map(x -> convert(Int64, nest_count)) |> maximum\nend\n</cell>\n\
    <text>\nThe function above will return the deepest level of nesting for a group\
    \ of parentheses string where paren_string is a string represented multiple groups\
    \ for nested parentheses separated by spaces.", '    #TODO: Implement parsing
    algorithms', "    \n    # initialize a vector of size 4\n    nest_levels = Vector{Int64}(4)\n\
    \    # set all elements to zero\n    for i in 1:length(nest_levels)\n        nest_levels[i]\
    \ = 0\n    end\n    # split the input string into groups of parenthesis\n    parent_groups\
    \ = paren_string.split(\"\\\\)\")\n    # loop over all groups and update corresponding\
    \ element\n    for paren_group in parent_groups\n        if length(paren_group)\
    \ == 1  \n            nest_levels[length(nest_levels)] += 1\n        else\n  \
    \          for i in 1:length(paren_group)\n                # check if this parenthesis\
    \ group is a sub-group of others\n                if paren_group[i] == \"(\"\n\
    \                    nest_levels[length(nest_levels) - 1] += 1\n             \
    \   # if this parenthesis group is a sub-group of others\n                else\n\
    \                    # check if this parenthesis group is a sub-group of other\
    \ \n                    # sub-group \n                    if paren_group[(i+1):length(string)]\
    \ == \"(\"\n                        nest_levels[length(nest_levels) - 2] += 1\n\
    \                    end\n                end\n            end\n        end\n\
    \    end\n    return nest_levels\nend", "    #Parse nested parens and return the\
    \ maximum level\n    nested_level = 0\n    paren_stack = Vector{Int64}(0) #Stack\
    \ of paren level\n    paren_stack_length = length(paren_stack)\n    #Iterate over\
    \ all the characters\n    for paren in paren_string\n        if paren == \"(\"\
    \n            nested_level += 1\n        else if paren == \")\"\n            nested_level\
    \ -= 1\n            \n            if nested_level == 0\n                paren_stack\
    \ = paren_stack[paren_stack_length-1:paren_stack_length]\n            elseif nested_level\
    \ < 0\n                paren_stack = paren_stack[paren_stack_length+nested_level]\n\
    \            end\n        end\n        paren_stack = paren_stack[paren_stack_length+nested_level]\n\
    \    end\n    \n    return paren_stack\nend", "    stack = Vector{Int64}()\n \
    \   opening = paren_string.match(OPENING_PARENS)\n    closing = paren_string.match(CLOSING_PARENS)\n\
    \    \n    if opening != nothing\n        stack.append(1)\n    end", "    input\
    \ = paren_string\n    inputs = split(input, \" \")\n    \n    stack = []\n   \
    \ deepest = 0\n    for parens in inputs\n        begin = parens\n        opens\
    \ = parens == begin\n        if opens\n            stack = stack + [parens]\n\
    \        else\n            deepest = 0\n            for level in stack\n     \
    \           deepest += level\n                if deepest > parens\n          \
    \          break\n            if deepest > parens\n                deepest = parens\n\
    \            stack = [parens]\n    end = 0\n    if !isempty(stack)\n        deepest\
    \ += 1\n        for level in stack\n            deepest += level\n           \
    \ if deepest > parens\n                break\n    end\n    return stack\nend",
  "    \n    paren_string \\\n        |> String.split_whitespace() \\\n        |>\
    \ Array.filter(x->x != \"()\") \\\n        |> Array.sort_by(x->x.length) \\\n\
    \        |> Array.map(x->paren_paran(x)) \\\n        |> Array.toArray\nend\n</cell>\n\
    <text>\nTest Your Solution", "    parens = paren_string.split;\n    stack = []\n\
    \    for paren in parens\n        if paren == \"(\"\n            push!(stack,\
    \ 1);\n        elseif paren == \")\"\n            pop!(stack)\n        end\n \
    \   end\n    return stack\nend\n</code>\n<|/ a tags=parsing,julia,regex |>\n<|\
    \ c |>\nThanks so much for this answer. The code is definitely the simplest and\
    \ fastest way to do what I want (and it also produces the correct output!). I\
    \ have two questions about your code:\n1) Why is the return value a Vector{Int64}?\
    \ If I leave it as Vector{Int} I get an error saying \"no matching function call\
    \ mapslices (in module Main) at line 16\" when I attempt to run the code.\n2)\
    \ Do you know of any way to do this for nested parentheses such as \"(())\" with\
    \ only one level of nested parentheses, e.g. \"()()\"? My code only works with\
    \ one nested parentheses level. Thanks!\n<|/ c |>\n<| c |>\n1) Vector{Int64} is\
    \ just the output type of my function parse_nested_parens. You should use whatever\
    \ your function needs as output. 2) This works with nested parens like you mentioned;\
    \ if you have trouble, feel free to edit your question to include more detail.\n\
    <|/ c |>\n<| c |>\nThanks for helping me with this - I still have some issues\
    \ implementing it but will work on my own and let you know if I have any more\
    \ questions. Thanks!\n<|/ c |>\n<| c |>\nI edited my answer to reflect your changes\
    \ to the question. Btw, if you could accept my answer as the accepted answer,\
    \ I would appreciate it.\n<|/ c |>\n<| c |>\nOkay cool, sorry I am fairly new\
    \ to Stack Overflow so I wasn't sure how to do that. Thanks again for your help!\n\
    <|/ c |>\n<| a dscore=2 |>\nAn other answer using Regexp's \\G and positive look-behind:\n\
    <code>\njulia> parens_re = Regex(\"(?<=\\()\\(?(?=(\\()|\\))\\)))+\") \nparens_re\
    \ = Regex(\"(?<=\\\\()\\\\(?(?=(\\\\()|\\\\))\\\\)))+\") ", "    paren_arr = paren_string.split(\"\
    \ \")\n    level = 0\n    nest_parens_arr = []\n    for paren_str in paren_arr\
    \ \n        if paren_str == \"(\"\n            nest_parens_arr = []\n        \
    \    level += 1\n        else if paren_str == \")\"\n            level += 1\n\
    \            else \n                nest_parens_arr = [level] + nest_parens_arr\n\
    \    end\n    nest_parens_arr\nend\n</cell>\n<text>\nTask 2.2. Write a function\
    \ that checks if a number is a valid palindrome or not.", "    \"\"\"\n    Recursively\
    \ parse a string to find the number of levels of nesting of parenthesis", "  \
    \  open_paren::Int64 = 1\n    open_paren_count::Int64 = 1\n    open_paren_max::Int64\
    \ = 1\n    open_paren_max::Int64 = 1\n    closed_paren::Int64 = 1\n    closed_paren_count::Int64\
    \ = 1\n    open_parens_level::Int64 = 1\n    closed_parens_level::Int64 = 1\n\
    \    open_parens_level_arr::Int64[] = []\n    closed_parens_level_arr::Int64[]\
    \ = []\n    level::Int64 = 0\n    level::Int64 = 0\n    level_arr::Int64[] = []\n\
    \    for c in paren_string\n        if c == '('\n            if open_paren_count\
    \ == open_paren_max\n                open_paren_max = open_paren_max + open_paren_max\n\
    \                level_arr[open_paren_max+1] = open_parens_level\n           \
    \     open_parens_level_arr[open_paren_max+1] = open_parens_level\n          \
    \      open_parens_level = open_paren_max + 1\n            open_paren_count =\
    \ open_paren_count + 1\n        elseif c == ')'\n            open_paren_count\
    \ = open_paren_count - 1\n            if open_paren_count == 0\n             \
    \   open_paren_max = open_paren_max - open_paren_max\n                closed_paren_max\
    \ = closed_paren_max + closed_paren_max\n                level_arr[closed_paren_max+1]\
    \ = closed_parens_level\n                closed_parens_level_arr[closed_paren_max+1]\
    \ = closed_parens_level\n                closed_parens_level = closed_paren_max\
    \ + 1\n            elseif closed_paren_count <= open_paren_count\n           \
    \     closed_parens_level = closed_paren_max\n            elseif open_paren_count\
    \ == open_paren_max\n                open_paren_max = open_paren_max + open_paren_max\n\
    \                level_arr[open_paren_max+1] = open_parens_level\n           \
    \     open_parens_level_arr[open_paren_max+1] = open_parens_level\n          \
    \      open_parens_level = open_paren_max + 1\n            else\n            \
    \    open_paren_count = open_paren_count + 1\n        end\n    end\n    level_arr[closed_paren_max]\
    \ = closed_parens_level\n    closed_parens_level_arr[closed_paren_max] = closed_parens_level\n\
    \    return level_arr\nend\n</cell>\n<code language=julia-1.5>", "    paren_tokens\
    \ = paren_string.split(\" \")\n    paren_tokens = [token for token in paren_tokens\
    \ if token !~ \"[)]\"\n                     and token !~ \"[]\"]\n    num_parens\
    \ = 0\n    level = 0\n    level_array = []\n    for paren in paren_tokens\n  \
    \      if paren ~= \"(\" and paren !~ \"(()\"\n            num_parens += 1\n \
    \       elseif paren == \"(\" and num_parens > 0\n            num_parens -= 1\n\
    \            level += 1\n        else\n            num_parens = 0\n        end\n\
    \        push!(level_array, level)\n    end\n    return level_array\nend\n</cell>\n\
    <text>\nTask 4\nWrite a function that takes as input a multiline string and returns\
    \ a multiline string where each line is wrapped with three spaces. For example,\
    \ if the input string is \"Hello world!\" then the output string should be \"\
    Hello  world!\" with three spaces between each word.", "    paren_string = strip(paren_string)\n\
    \    paren_string = regex_replace(paren_string, \"\\s+\", \"\")\n    paren_string\
    \ = regex_replace(paren_string, \"()\", \"\")\n    paren_string = regex_replace(paren_string,\
    \ \"\\)\", \"\")\n    paren_string = regex_replace(paren_string, \"\\)()\", \"\
    \")\n    paren_string = regex_replace(paren_string, \"\\)()\\)\", \"\")\n    paren_string\
    \ = regex_replace(paren_string, \"\\)()\\)()\", \"\")\n    paren_string = regex_replace(paren_string,\
    \ \"\\)()\\)()\\)\", \"\")\n    paren_string = regex_replace(paren_string, \"\\\
    )()\\)()\\)()\", \"\")\n    paren_string = regex_replace(paren_string, \"\\)()\\\
    )()\\)()\\)\", \"\")\n    paren_string = regex_replace(paren_string, \"\\)()\\\
    )()\\)()\\)()\", \"\")\n    paren_string = regex_replace(paren_string, \"\\)()\\\
    )()\\)()\\)()\\)\", \"\")\n    paren_string = regex_replace(paren_string, \"\\\
    )()\\)()\\)()\\)()\\)()\", \"\")\n    paren_string = regex_replace(paren_string,\
    \ \"\\)()\\)()\\)()\\)()\\)()\\)\", \"\")\n    paren_string = regex_replace(paren_string,\
    \ \"\\)()\\)()\\)()\\)()\\)()\\)()\", \"\")\n    paren_string = regex_replace(paren_string,\
    \ \"\\)()\\)()\\)()\\)()\\)()\\)()\", \"\")\n    paren_string = regex_replace(paren_string,\
    \ \"\\)()\\)()\\)()\\)()\\)()\\)()\\)\", \"\")\n    paren_string = regex_replace(paren_string,\
    \ \"\\)()\\)()\\)()\\)()\\)()\\)()\\)()\", \"\")\n    paren_string = regex_replace(paren_string,\
    \ \"\\)()\\)()\\)()\\)()\\)()\\)()\\)()\", \"\")\n    paren_string = regex_replace(paren_string,\
    \ \"\\)()\\)()\\)()\\)()\\)()\\)()\\)()\", \"\")\n    paren_string = regex_replace(paren_string,\
    \ \"\\)()\\)()\\)()\\)()\\)()\\)()\\)()\\)\", \"\")\n    paren_string = regex_replace(paren_string,\
    \ \"\\)()\\)()\\)()\\)()\\)()\\)()\\)()\\)()\", \"\")\n    ", "\"\"\"\n    Parse\
    \ a string of multiple groups of nested parentheses separated by spaces.\n   \
    \ For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.", " \
    \   if paren_string == \"\" || paren_string==\"(\" || paren_string==\"(()\" \n\
    \        return [1]\n    paren_string = paren_string.strip\n    nest = 1\n   \
    \ paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    ()\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\"(\")\n    paren_string = paren_string.rstrip(\"\
    ()\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    (\")\n    paren_string = paren_string.rstrip(\"()\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")\n    paren_string = paren_string.rstrip(\"\
    )\")\n    paren_string = paren_string.rstrip(\")\")", "    paren_array = paren_string.split(\"\
    \ \") |> collect\n    paren_array = []\n    for i in paren_array\n        if i\
    \ =~ /^\\((.+)\\)$/\n            paren_array += $1\n        else paren_array +=\
    \ i\n    end\n    return paren_array\nend", "    paren_string = paren_string.trim()\
    \ \n    parens_open = []\n    parens_closed = []\n    for c in paren_string\n\
    \        if c == \"(\"\n            parens_open.append(c)\n        elseif c ==\
    \ \")\"\n            parens_closed = parens_closed\n            parens_closed\
    \ = parens_closed[1:] \n            parens_closed = parens_closed + [parens_open]\n\
    \            parens_open = []\n        else\n            parens_open = []\n  \
    \      end\n    end\n    return parens_closed\nend", "    parse_parens = parse_parens(paren_string)\n\
    \    stack = Stack()\n    stack.push(length(parse_parens))\n    while stack.size()\
    \ > 1\n        top = stack.pop()\n        bottom = stack.pop()\n        if parse_parens[top]\
    \ == parse_parens[bottom]\n            if top != bottom\n                stack.push(top)\n\
    \            end\n        end\n    end\n    return parse_parens[stack.pop()]\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    depth(paren_string::String)::Int64",
  "    levels::Vector{Int64} = []\n    for i in paren_string:\n        if i == \"\
    (\"\n            push!(levels, length(levels))\n        else\n            pop!(levels)\n\
    \        end\n    end\n    return levels\nend", "    # Initialize maxLevel to\
    \ 1.\n    maxLevel = 1\n    paren_string = paren_string.strip()\n    \n    # Iterate\
    \ through input string.\n    for char in paren_string\n        if char == ')'\n\
    \            if maxLevel > 1\n                maxLevel -= 1\n            else\n\
    \                maxLevel = 1\n        elseif char == '('\n            maxLevel\
    \ += 1\n        end\n    end\n    \n    return paren_string.length + maxLevel\n\
    end", "    paren_array = split(paren_string, \" \")\n    paren_array\n    level::Int64\
    \ = 0\n    paren_stack::Vector{Int64} = Vector{Int64}(length( paren_array) - 1)\n\
    \    for paren in paren_array\n        if paren == \"(\" or paren == \"{\" \n\
    \            paren_stack[paren_stack.length - 1] += 1\n        elseif paren ==\
    \ \")\" or paren == \"}\" \n            paren_stack[paren_stack.length - 1] -=\
    \ 1\n            if paren_stack[paren_stack.length - 1] == 0 \n              \
    \  push!(paren_stack, paren_stack.length)\n            end\n        end\n    end\n\
    \    paren_stack\n    pop!(paren_stack, paren_stack.length)\n    for paren in\
    \ paren_stack\n        push!(paren_stack, paren)\n    end\n    paren_stack\nend\n\
    \"\"\"\nThis function converts a string of parenthesis into a nested vector\n\
    of length 'n' where each element represents the level of nested parentheses.\n\
    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\"\"\"",
  "    \"\"\"\n    >>> parse_nested_parens(\"((()))\")\n    [5]\n    \"\"\"\n    function\
    \ parse_nested_parens(paren_string::String)::Vector{Int64} \n        level::Int64\
    \ = 0\n        paren_levels::Vector{Int64} = [0]\n        paren_levels::Vector{Int64}\
    \ = paren_string.count(\"(\") - paren_string.count(\")\")\n        while paren_levels[level]\
    \ > 0 do\n            paren_levels[level] -= 1\n            level += 1\n     \
    \   end\n        return paren_levels\n    end", "    # Your code here\nend", " \
    \   stack::Vector{Int64} = Vector{Int64}()\n    paren_stack::Vector{Int64} = Vector{Int64}()\n\
    \    level::Int64 = 0\n    parens = paren_string.split(\" \")", "    paren_stack\
    \ = Vector{Int64}(0)\n    paren_stack = paren_string.strip(\"()\").strip(\"(\"\
    )\n    paren_stack = paren_stack.split(\")\")\n    paren_stack = paren_stack[1].split(\"\
    )\")\n    paren_stack = paren_stack[1].split(\")\")\n    return paren_stack\n\
    end\n</code>\n<|/ a tags=haskell,string,parentheses dscore=0 |>\n<| a |>\nHere's\
    \ a recursive solution.\n<code>\ndata Paren = L Int | R Int | Nesting Parent (Paren,\
    \ Paren)", "</code>\n<|/ a dscore=2 |>\n<| a dscore=0 |>\n<code>", "    if paren_string\
    \ == \"\"\n        return Vector{Int64}()\n    end\n    parens = [paren]\n   \
    \ for paren in paren_string\n        if paren == \"(\"\n            parens <<\
    \ paren\n        elseif paren == \")\"\n            parens.pop()\n        else\n\
    \            parens << paren\n        end\n    end\n    \n    return parens\n\
    end\n</code>\n<|/ a dscore=0 tags=string,julia |>\n<| a tags=string,julia |>\n\
    An answer in one line using regular expressions, though it probably won't be very\
    \ fast.\n<code>\njulia> s = \"(()())()((()())()(()())())()\"\n\"(()())()((()())()(()())())()\"",
  "    # Initialize a list to return\n    ans = Vector{Int64}()", "     paren_group::Vector{Int64}\n\
    \     paren_nest::Int64 = 0\n     paren_level::Int64 = 0\n     paren_index::Int64\
    \ = 0\n     for item in split(paren_string) do\n       if item == \"(\" then paren_nest\
    \ = 1\n       else if paren_nest == 0 then paren_group[paren_index] = paren_level\n\
    \       else paren_nest - 1\n       paren_index += 1\n       if item == \")\"\
    \ then paren_nest = 0\n       paren_level += 1\n     end\n     return paren_level\n\
    end\n</code>\n<|/ a |>\n<| a |>\nTo solve this problem without using regular expressions,\
    \ I wrote a recursive function that does the job. Below is the recursive function\
    \ which takes one string as input. Here is the function code:\n<code>", "    paren_string\
    \ = paren_string.replace(\" \", \"\")\n    paren_string = \"(\" + paren_string\
    \ + \")\"\n    \n    paren_count = Dict(\"()\" => 0, \"(\" => 0, \"()()\" => 0,\
    \ \"((\" => 0)\n    \n    for ch in paren_string\n        paren_count[ch] += 1\
    \ \n    end\n    \n    parent_count = Dict(\"()\" => 0, \"(\" => 0, \"()()\" =>\
    \ 0, \"((\" => 0)\n    \n    for ch in paren_string\n        if paren_count[ch]\
    \ > 0\n            parent_count[ch] = paren_count[ch]\n        else\n        \
    \    parent_count[ch] = paren_count[\"()\"]\n        end\n    end\n    \n    depths\
    \ = Vector{Int64}(length(pparent_count))\n    for paren in paren_count\n     \
    \   depths[paren] = parent_count[paren]\n    end\n    \n    return depths\nend",
  "</code>\nI believe it can be easily converted into a for loop, if needed, since\
    \ this is really just an implementation of the depth first search algorithm.\n\
    <|/ a tags=python,algorithm |>\n<| c |>\nI'm guessing that the OP is looking for\
    \ a recursive solution.\n<|/ c |>\n<| c |>\nI assumed this was a homework assignment\
    \ and I gave a recursive solution.\n<|/ c |>\n<| a dscore=0 |>\nMy answer is not\
    \ optimal, but it will work. Here is a recursive solution using python's recursion\
    \ features. \n<code>\ndef max_nested_levels(parens):\n    opening = []\n    for\
    \ i in range(0, len(parens)-1):\n        if (parens[i] == '('):\n            opening.append(parens[i+1])\n\
    \        if (parens[i] == ')'):\n            opening.pop()\n    if not opening:\n\
    \        return 0\n    else:\n        return 1 + max(max_nested_levels(opening),\
    \ max_nested_levels(parens[(i+1):]))", "    \"\"\"\n    Parse nested parentheses\
    \ and return an ordered list of levels of nested parentheses.", "    \"\"\"\n\
    \    Takes in a string and returns a vector with the deepest levels of nesting\
    \ for each set of parentheses.\n    The input string should have the format of\
    \ (()()) where each set of parentheses is a separate \n    string and should follow\
    \ the format of ()().\n    The return vector should have the format [2, 1, 1,\
    \ 3] since ()() has maximum two levels of nesting.", "</code>\nAnd now you can\
    \ use this function in an apply call:\n<code>\napply_nested_parens(paren_string,\
    \ \"((()))\")\n</code>\n<|/ a tags=ocaml,recursion,algorithm |>\n<| c |>\nThanks\
    \ for your help. Unfortunately the problem does not have a solution as it is stated\
    \ in the problem description.\n<|/ c |>\n<| c |>\nI see, I thought maybe some\
    \ kind person would have come up with a solution in OCaml :)\n<|/ c |>\n<| c |>\n\
    You might want to take a look at OCaml's `List.fold_left` function; it's a simple\
    \ recursive function in `OCaml` that can do this.\n<|/ c |>\n<| a |>\nI do not\
    \ know if there is a way to do this in a single recursive function, but here is\
    \ one way of doing it. \n<code>\n# let rec parse input =\n    match input with\n\
    \    | \"\" -> ([], \"\")\n    | \"'\" -> ([], \"\")\n    | c :: cs -> \n    \
    \    match c with\n        | \"(\" -> \n            (parse (String.replace c \"\
    (\" \"\" \"\" in\n                String.replace c \")\" \"\" \"\" in\n      \
    \          String.split (String.replace c \" \" \"\" \"\")) in\n            parse\
    \ (String.replace c \")\" \"\" \"\" in\n            String.replace c \"(\" \"\"\
    \ \"\" in\n            String.split cs))\n        | c :: cs -> parse cs;;", " \
    \   if paren_string == \"\" then return []\n    group_start = find_first_char_index(paren_string,\
    \ \" \")\n    if group_start == 0 then return []\n    group_end   = find_last_char_index(paren_string,\
    \ \" \")\n    \n    levels_string    = paren_string[group_start+1 : group_end]\n\
    \    levels_vector   = split(levels_string, \" \")\n    \n    levels_vector =\
    \ [Int64(l) for l in levels_vector if l != \"\"]\n    \n    level_max       =\
    \ maximum(levels_vector)\n    \n    if level_max == 1 then return [level_max]\n\
    \    \n    level_array     = Array(Int, length(levels_vector))\n    level_array[1]\
    \  = level_max\n    \n    for l in range(2, length(levels_vector)) do\n      \
    \  level_array[l] = levels_vector[l] - levels_vector[l - 1]\n    end\n    \n \
    \   levels_vector = levels_vector[1 : (end - 1)]\n    \n    for l in range(1,\
    \ length(levels_vector)) do\n        if level_array[l] > 0 then\n            levels_vector[l\
    \ - 1] = level_array[l]\n        else\n            levels_vector[l] = levels_vector[l\
    \ - 1]\n        end\n    end\n    \n    return levels_vector\nend\n</cell>\n<text>\n\
    The function takes in a string representing the parenthetical expression and outputs\
    \ the deepest level of nesting.", "    \"\"\"\n    Input to this function is a\
    \ string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.", " \
    \   input::Vector{Int64} = paren_string.split(\" \")\n    cur_level = 0\n    for\
    \ el in input\n        cur_level += el == '(' ? 1 : el == ')' ? -1 : 0\n    end\n\
    \    cur_level + cur_level\nend\n</cell>\n<text>\nLet's see how it works on some\
    \ test cases. First, let's test it on a string with no nested parentheses:", " \
    \   if paren_string == \"\" \n        Vector{Int64}(0) \n    else \n        stack\
    \ = Vector{Int64}()\n        paren_count = 0\n        paren_depth = 0\n      \
    \  for c in paren_string \n            if c == '(' \n                paren_depth\
    \ += 1\n                push!(stack, paren_count)\n            end\n         \
    \   if c == '(' \n                paren_count += 1\n                if paren_depth\
    \ > stack[paren_count]\n                    push!(stack, paren_count)\n      \
    \          end\n            end\n            if c == ')' \n                paren_count\
    \ -= 1\n                if paren_depth > stack[paren_count]\n                \
    \    push!(stack, paren_count)\n                end\n            end\n       \
    \ end\n        stack\n    end\nend", "    paren_arr = split(paren_string)\n  \
    \  level = 0\n    for paren in paren_arr\n        if paren ~= '('\n          \
    \  level += 1\n        end\n        if paren == ')'\n            level -= 1\n\
    \        end\n    end\n    return Vector{Int64}(paren_arr, level)\nend", "   \
    \ paren_stack = []\n    levels = []\n    paren_len = length(paren_string)\n  \
    \  paren_count = paren_len - 1\n    paren_stack_size = paren_count + 1\n    for\
    \ paren_idx in range(paren_count)\n        paren_stack_size:=paren_stack_size-1\n\
    \        push!(paren_stack,paren_stack_size)\n    end", "    paren_stack = Vector{Int64}()\n\
    \    level = 0\n    levels = Vector{Int64}()\n    for c in paren_string\n    \
    \    if c == '('\n            if paren_stack.length == 0\n                paren_stack\
    \ push (0)\n            else\n                paren_stack[paren_stack.length -\
    \ 1] += 1\n            end \n        elseif c == ')'\n            paren_stack[paren_stack.length\
    \ - 1] -= 1\n            if paren_stack[paren_stack.length - 1] == 0\n       \
    \         paren_stack.pop()\n                level = paren_stack.length\n    \
    \            levels push level\n            else\n                paren_stack[paren_stack.length\
    \ - 1] -= 1\n            end\n        else\n            paren_stack[paren_stack.length]\
    \ = paren_stack[paren_stack.length - 1]\n        end\n    end\n    return levels\n\
    end", "    paren_str = paren_string.strip()\n    level_of_parentheses = 0\n  \
    \  while !isempty(paren_str)\n        # count the opening parens\n        opening_parens\
    \ = count_paren(paren_str)\n        if opening_parens == level_of_parentheses\n\
    \            # if the opening parentheses is the same level as the previous level\
    \ of nesting then skip to the next group\n            continue\n        level_of_parentheses\
    \ = opening_parens\n        # count the closing parens\n        closing_parens\
    \ = count_paren(paren_str, closing_parens)\n        if closing_parens == level_of_parentheses\n\
    \            # if the closing parentheses is the same level as the previous level\
    \ of nesting then stop\n            break\n        level_of_parentheses = closing_parens\n\
    \        paren_str = paren_str[(closing_parens+1):end]\n    end\n    # return\
    \ a Vector of the level of nesting\n    return Vector{Int64}(level_of_parentheses)\n\
    end\n</cell>\n<code language=julia-1.0>\n# test parse_nested_parens\nparse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n</cell>\n<text>\nNext we write a function to count\
    \ the number of opening and closing parens.", "    stack = Vector{Int64}(paren_string)\n\
    \    paren_count = length(stack)\n    paren_stack = Vector{Int64}()", "    paren_string\
    \ = paren_string.strip\n    levels_stack = Vector{Int64}()\n    stack = Vector{Int64}()\n\
    \    parens = 0\n    for char in paren_string\n        if char == '('\n      \
    \      parens += 1\n            push!(stack, parens)\n        else if char ==\
    \ ')'\n            if parens > 0\n                pop!(levels_stack)\n       \
    \     else\n                error(\"expected closing parens but found none\")\n\
    \        else\n            push!(stack, char)\n        end\n    end\n    stack\n\
    end\n</cell>\n<code language=julia-1.5>", "    stack = Vector{Int64}()\n    \n\
    \    push!(stack, paren_string)\n    while length(stack) > 0\n        paren_string\
    \ = pop!(stack)\n        \n        if paren_string == \"\"\n            break\n\
    \        end", "    if paren_string == \"\" then \n        throw(ArgumentError(\"\
    invalid parenthesis string\"))\n    end", "    paren_string = paren_string.replace(\"\
    ()\", \"\") # get rid of outer parentheses\n    paren_string = paren_string.replace(\"\
    )\", \"\") # get rid of inner parentheses\n    \n    if paren_string.length <=\
    \ 1 \n        return paren_string.length\n    else \n        return parse(paren_string)\
    \ \n    end\nend\n</code>\n<|/ a tags=string,regex,parsing,julia,recursion |>\n\
    <| c |>\nPlease provide some explanation to your code. As it's currently written,\
    \ it's hard to understand your solution.\n<|/ c |>\n<| c |>\nThanks. I agree with\
    \ you that the code can be improved, but I thought I would first give it a try.\n\
    <|/ c |>\n<| a dscore=0 |>\nAn alternative solution:\n<code>\njulia> function\
    \ parse(paren_string)\n           paren_string = paren_string.replace(\"()\",\
    \ \"\")\n           paren_string = paren_string.replace(\")\", \"\")\n       \
    \    if (paren_string == \"\")\n               return 0\n           end\n    \
    \       begin\n               level = 0\n               for i in paren_string\n\
    \                   level += parse(paren_string[i])\n               end\n    \
    \       end\n       end\nparse (generic function with 1 method)", "    paren_list\
    \ = split(paren_string, \" \")\n    paren_level = zeros(length(paren_list) + 1)\n\
    \    paren_level[1] = 1\n    for paren_index in 2:length(paren_list)\n       \
    \ paren_level[paren_index] = paren_level[paren_index-1] + paren_list[paren_index-1]\
    \ == \"()\"\n    end\n    return paren_level\nend\n</cell>\n<text>\n3. Parenthesizing\
    \ a function argument", "    paren_groups = paren_string.split(\" \")\n    parsed_groups\
    \ = []\n    parsed_group = 0\n    parsing_group = 0\n    parsing_paren = 0\n \
    \   parsing_paren_count = 0\n    for paren in paren_groups\n        parsed_paren\
    \ = 0\n        parsing_paren = 0\n        for paren_char in paren\n          \
    \  parsing_paren_count += 1\n            if paren_char == \"(\"\n            \
    \    parsing_paren += 1\n            if paren_char == \")\"\n                parsing_paren\
    \ -= 1\n            parsed_paren += parsing_paren\n        end\n        parsed_group\
    \ += parsed_paren\n        parsed_groups += parsed_paren\n    end\n    parsed_groups\
    \ += parsing_paren_count\n    return parsed_groups\nend", "    \"\"\"\n    Parse\
    \ nested parentheses and return a list of maximum level of nesting.", "    paren_stack\
    \ = Vector{Int64}()\n    current_level = 0\n    paren_group_count = 0\n    for\
    \ c in paren_string\n        if c == '('\n            if paren_stack[paren_group_count]\
    \ == 0\n                paren_stack[paren_group_count] = 1\n                current_level\
    \ += 1\n            else\n                current_level = paren_stack[paren_group_count]\n\
    \            end\n        else \n            if c == '('\n                if paren_stack[paren_group_count]\
    \ != 0\n                    current_level = paren_stack[paren_group_count]\n \
    \               end\n            end\n            paren_stack[paren_group_count]\
    \ = current_level\n            paren_group_count += 1\n        end\n    end\n\
    \    return paren_stack\nend\n</code>\n<|/ a tags=parentheses,string,julia dscore=0\
    \ |>\n<| c |>\nIt is not clear how this works. What is `c`? What is `paren_string`?\
    \ What is `paren_stack`? What is `current_level`? What is `paren_group_count`?\
    \ Why are there empty parenthesis in `paren_string`?\n<|/ c |>\n<| c |>\nI updated\
    \ my answer and added comments. Hope this helps.\n<|/ c |>\n<| c |>\nThanks so\
    \ much for the answer. One thing that seems odd to me though is that your answer\
    \ is recursive, while mine is not. Is one more efficient than the other in terms\
    \ of speed or resource usage?\n<|/ c |>\n<| c |>\nIt seems that one version is\
    \ more efficient than the other. This recursive algorithm uses stack but it is\
    \ faster to just remember what level you are at and check if you went back up\
    \ without going through all characters again. I am not sure how much faster it\
    \ could be but you can always profile it.\n<|/ c |>\n<| a tags=parentheses,string,julia\
    \ |>\n<code>", "    paren_pairs = paren_string.scan(/(\\(\\()|\\(\\))/)\n    paren_pairs\
    \ = paren_pairs[2:end]\n    paren_pairs = paren_pairs[2:end]\n    paren_pairs\
    \ = paren_pairs[2:end]\n    paren_pairs = paren_pairs[2:end]\n    return paren_pairs\n\
    end", "\"\"\"\nThis function takes in a string of parentheses as input, and returns\
    \ a vector where each element corresponds to \nthe maximum level of nesting for\
    \ each of the groups.", "    if paren_string.lenght() <= 0\n        return Vector{1}\n\
    \    ends_closed = paren_string[0..-2] === \"()\"\n    opening = paren_string[0..-1]\n\
    \    closing = paren_string[ends_closed ? 1 : end]\n    if opening == closing\n\
    \        return Vector{paren_string.lenght()}\n    ends_open = paren_string[0..-1]\
    \ === \"()\"\n    if ends_open\n        opening = paren_string[0..-2]\n      \
    \  closing = paren_string[ends_open ? 1 : end]\n    ends_closed = paren_string[0..-2]\
    \ === \"()\"\n    if opening == closing\n        return Vector{paren_string.lenght()}\n\
    \    if opening == \"()\" && closing == \"()\"\n        return parse_nested_parens(paren_string)\n\
    \    ends_open = paren_string[0..-1] === \"()\"\n    if ends_open\n        opening\
    \ = paren_string[0..-2]\n        closing = paren_string[ends_open ? 1 : end]\n\
    \    ends_closed = paren_string[0..-2] === \"()\"\n    if opening == closing\n\
    \        return Vector{paren_string.lenght()}\n    if opening == \"()\" && closing\
    \ != \"()\"\n        return parse_nested_parens(paren_string)\n    ends_open =\
    \ paren_string[0..-1] === \"()\"\n    if ends_open\n        opening = paren_string[0..-2]\n\
    \        closing = paren_string[ends_open ? 1 : end]\n    ends_closed = paren_string[0..-2]\
    \ === \"()\"\n    if opening == closing\n        return Vector{paren_string.lenght()}\n\
    \    if opening != \"()\" && closing != \"()\"\n        return parse_nested_parens(paren_string)\n\
    \    ends_open = paren_string[0..-1] === \"()\"\n    if ends_open\n        opening\
    \ = paren_string[0..-2]\n        closing = paren_string[ends_open ? 1 : end]\n\
    \    ends_closed = paren_string[0..-2] === \"()\"\n    if opening == closing\n\
    \        return Vector{paren_string.lenght()}\n    if opening != \"()\" && closing\
    \ == \"()\"\n        return parse_nested_parens(paren_string)\n    ends_open =\
    \ paren_string[0..-1] === \"()\"\n    if ends_open\n        opening = paren_string[0..-2]\n\
    \        closing = paren_string[ends_open ? 1 : end]\n    ends_closed = paren_string[0..-2]\
    \ === \"()\"\n    if opening == closing\n        return Vector{paren_string.lenght()}\n\
    \    if opening != \"()\" && closing != \"()\"\n        return parse_nested_parens(paren_string)\n\
    \    ends_open = paren_string[0.", "    parens = paren_string.split(\" \")\n \
    \   parens = parens[2:end]\n    return Array{Int64}(parens)\nend", "    if !paren_string.starts_with('(')\
    \ || paren_string.ends_with(')')\n        error(\"Input string is not well formed\"\
    )\n    end\n    stack::Vector{Int64} = [0]\n    cur_lvl = 1\n    push!(stack,\
    \ cur_lvl)\n    paren_position::Int64 = 0\n    for char in paren_string\n    \
    \    if char == '('\n            push!(stack, cur_lvl)\n            paren_position\
    \ += 1\n        elseif char == ')'\n            pop!(stack)\n            if paren_position\
    \ == length(stack)\n                error(\"Unbalanced parentheses\")\n      \
    \      else\n                cur_lvl = stack[paren_position]\n            end\n\
    \        else\n            push!(stack, cur_lvl + 1)\n        end\n    end\n \
    \   stack\nend\n</cell>\n<text>\nExercise 7\nTo compute the height of the given\
    \ parenthesis string, first we will split the string into substrings of equal\
    \ length and then apply the function above on the substrings:", "    stack = Vector{Int64}()\n\
    \    paren_count = count_parentheses(paren_string)\n    for paren_level in paren_count.keys\n\
    \        stack = []\n        for (parentheses, brackets) in paren_count[paren_level]\n\
    \            while parentheses > 0 && brackets > 0\n                if parentheses\
    \ > brackets\n                    paren_brace = parentheses - brackets\n     \
    \           else\n                    paren_brace = brackets\n               \
    \ paren_closed = paren_count[paren_level][paren_level + 1][1][paren_brace]\n \
    \               paren_open = paren_count[paren_level][paren_level + 1][2][paren_brace]\n\
    \                if paren_closed > 0 && paren_closed < paren_open\n          \
    \          stack += [(parentheses, paren_brace)]\n                    paren_brace\
    \ += 1\n                    parentheses -= paren_closed\n                elseif\
    \ paren_open > 0 && paren_open < paren_closed\n                    paren_brace\
    \ -= 1\n                    parentheses -= paren_open\n                else\n\
    \                    parentheses -= paren_closed\n                    brackets\
    \ -= paren_open\n                end\n            end\n        end\n        stack\
    \ += [(paren_count[paren_level][1], paren_count[paren_level][2])]\n        if\
    \ paren_count[paren_level][1] > paren_count[paren_level][2]\n            stack\
    \ = [(paren_count[paren_level][1], paren_count[paren_level][2])] + stack\n   \
    \     end\n        paren_count[paren_level] = stack\n    end\n    return paren_count\n\
    end", "    if paren_string==\"\" then return [] end\n    paren_string = string(paren_string)\n\
    \    paren_index = 0\n    levels = []\n    \n    while paren_index < length(paren_string)\n\
    \        if paren_string[paren_index]==\"(\"\n            paren_index += length(paren_string)\n\
    \            levels << paren_index\n        elseif paren_string[paren_index]==\"\
    )\" \n            paren_index += length(paren_string)\n            levels << paren_index\
    \ - length(paren_string)\n        elseif paren_string[paren_index]==\" \"\n  \
    \          paren_index += length(paren_string)\n        elseif paren_string[paren_index]==\"\
    \ \"\n            paren_index += length(paren_string)\n            levels << paren_index\
    \ - length(paren_string)\n        elseif paren_string[paren_index]==\")\"\n  \
    \          if paren_index <= length(paren_string)\n                if paren_string[paren_index+1]==\"\
    (\"\n                    paren_index += length(paren_string)\n               \
    \     levels << paren_index\n                else\n                    paren_index\
    \ += length(paren_string)\n                    levels << paren_index - length(paren_string)\n\
    \                end\n            else\n                paren_index += 1\n   \
    \             levels << paren_index - length(paren_string)\n            end\n\
    \        else\n            paren_index += 1\n        end\n    end\n    return\
    \ levels\nend", "    \"\"\"\n    Parse a string of nested parentheses.\n    \"\
    \"\"", "  paren_string = strip(paren_string)\n  paren_string = trim!(paren_string)\n\
    \  paren_string = paren_string |> paren_group\n  paren_string = paren_string |>\
    \ paren_group_count\n  paren_string = paren_string |> paren_max_level\n  return\
    \ paren_string\nend", "</code>\n<|/ a dscore=3 |>\n<| c |>\nYeah, this solution\
    \ also works for nested parentheses. Just replace `paren_string` with your input\
    \ string.\n<|/ c |>\n<| c |>\nI added the recursive call as an additional parameter\
    \ to the main function.\n<|/ c |>\n<| c |>\nYou might also try https://github.com/nkzawa/Tokenize.jl\
    \ (https://github.com/nkzawa/Tokenize.jl/blob/master/Tokenize.jl).\n<|/ c |>\n\
    <| a tags=recursion,julia,nested-parentheses |>\nA more efficient solution can\
    \ be found in this answer, by Mr. Tulvi, I just modified it a bit to work with\
    \ Vectors instead of Strings.\n<code>", "    stack = Vector{Int64}()\n    for\
    \ x in split(paren_string) do \n        if x == '(' || x == '{' \n           \
    \ push!(stack, 1);\n        else if x == ')' || x == '}' \n            if isempty(stack)\
    \ || pop!(stack) == 1 \n                push!(stack, 0); return stack\n      \
    \      else\n                push!(stack, 0);\n            end\n        end\n\
    \    end\n    push!(stack, 0);\nend\n</code>\n<|/ a |>\n<| a dscore=2 |>\nHere\
    \ is a recursive algorithm that can handle any level of nesting, not just nested\
    \ parenthesis. I tested it against the other answers here and found it to be extremely\
    \ fast (although the other algorithms might work just as well, I didn't run any\
    \ benchmarks on this).\n<code>", "    paren_depths::Vector{Int64}=Vector{Int64}(paren_string)\n\
    \    paren_depths::Vector{Int64} = paren_depths[2:end-1]\n    paren_depths = paren_depths.*(-1)\n\
    \    paren_depths\nend\n</code>\n<|/ a |>\n<| a tags=string,parsing,haskell,algorithm\
    \ dscore=3 |>\nHere is another solution without recursion:\n<code>\nimport qualified\
    \ Data.Map as M\nimport Data.Maybe (fromJust, isJust)\nimport Data.Vector (Vector)",
  '    # write your code here', "    paren_depths = Vector{Int64}()\n    current_depth\
    \ = 1\n    paren_depth = 1\n    for ch in paren_string\n        if ch == '('\n\
    \            paren_depth = paren_depth + 1\n            paren_depths.push(paren_depth)\n\
    \            current_depth = paren_depth\n        elseif ch == ')'\n         \
    \   paren_depth = paren_depth - 1\n            if paren_depth <= 0\n         \
    \       paren_depths.push(current_depth)\n            else\n                paren_depths.push(paren_depth)\n\
    \                current_depth = paren_depths[end]\n            end\n        else\n\
    \            current_depth = current_depth + 1\n        end\n    end", "</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nI have edited my question. My question now is how\
    \ to output the actual value rather than the index of the value in the vector.\n\
    <|/ c |>\n<| c |>\nI have modified the code such that it returns the actual value\
    \ rather than the index. Check it out and let me know if it works for you.\n<|/\
    \ c |>\n<| c |>\nIt still outputs the same output for both cases. Could you please\
    \ try it on your own?\n<|/ c |>\n<| c |>\nIt outputs `[2, 3, 1, 3]` for the first\
    \ case and `[2, 1, 3, 3]` for the second case. I am not getting any error for\
    \ these cases since it works completely fine.\n<|/ c |>\n<| c |>\nYou are right\
    \ but the first output should be `[2,3,1]` and second `[2,1,3]`. It seems like\
    \ it is printing different outputs on your end.\n<|/ c |>\n<| a dscore=0 |>\n\
    I agree with that your question is not very clear, but maybe you can work from\
    \ here and come up with a solution.\nIf I understand your problem correctly, then\
    \ you have a string of the form\n<code>\n\"(())() ()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()",
  "    \"\"\"\n    Parse the given string into its deepest level nesting parentheses.\n\
    \    \"\"\"\n    levels = Vector{Int64}()\n    paren_level = 0\n    paren_level_prev\
    \ = -1\n    for paren in paren_string\n        if paren == '('\n            paren_level\
    \ += 1\n            paren_level_prev = paren_level\n        elseif paren == ')'\n\
    \            paren_level -= 1\n            if paren_level == paren_level_prev\n\
    \                levels << (paren_level + 1) // 2 + 1\n                paren_level_prev\
    \ = -1\n            else\n                paren_level_prev = paren_level\n   \
    \             paren_level = -1\n            end\n        else\n            paren_level_prev\
    \ = paren_level\n            paren_level = -1\n        end\n    end\n    return\
    \ levels\nend\n</cell>\n<code language=julia-1.5>", "    paren_string = paren_string\n\
    \    nesting_levels = Vector{Int64}()\n    nesting_level = 1\n    paren_count\
    \ = 0\n    paren_stack = []\n    \n    push!(paren_stack, 0)\n    \n    while\
    \ length(paren_stack) > 0\n        nest_level += 1\n        nest_level = paren_stack[nest_level]\n\
    \        \n        if nest_level > length(paren_stack)\n            # Paranthesis\
    \ was unbalanced (nest_level longer than length of paren_stack)\n            nesting_levels\
    \ = paren_stack\n            break\n        end", "    # Split the string on spaces\
    \ and parens\n    paren_chars = string.split(paren_string, \" \")\n    parens_stack\
    \ = Vector{Int64}()\n    current_level = 1\n    \n    parsed_levels = Vector{Int64}()\n\
    \    for i in paren_chars\n        if i==\"(\"\n            parens_stack .= 1\n\
    \        elseif i==\")\" \n            parens_stack .= -1\n        elseif i==\"\
    )\" \n            if parens_stack .== 0\n                parens_stack .= 1\n \
    \           else\n                parens_stack .= -1\n            end\n      \
    \  elseif i==\"(\" \n            if parens_stack .== 1\n                current_level\
    \ .= 1\n            elseif parens_stack .== -1\n                parsed_levels\
    \ .= current_level\n                current_level .= 0\n            else\n   \
    \             error(\"Found parentheses mismatch.\")\n            end\n      \
    \  elseif i==\")\" \n            current_level .= -parens_stack\n        end\n\
    \    end\n    \n    return parsed_levels\nend", "    stack = Vector{Int64}()\n\
    \    level = 0\n    paren_level = 0\n    for char in paren_string\n        if\
    \ char == \"(\"\n            push!(stack, level)\n            paren_level += 1\n\
    \        elseif char == \")\"\n            level = pop!(stack)\n            paren_level\
    \ -= 1\n        end\n    end\n    level\nend\n</cell>\n<code language=julia-1.0>\n\
    using FileIO", "# parse parenthesized strings and store nested level of parentheses\n\
    \    parsed_string = paren_string\n    parsed_string_chars = paren_string\n  \
    \  parsed_string_chars = replace(parsed_string_chars, \" \", \"\") # remove extra\
    \ spaces to make parenthesized string", "    parsed_brackets = []\n    opening\
    \ = paren_string[1]\n    closing = paren_string[-1]\n    opening_length = len(opening)\n\
    \    for bracket in paren_string[2:length(paren_string)-2]\n        if bracket[1]\
    \ != closing\n            parsed_brackets = parsed_brackets + [bracket[1]:bracket[2]]\n\
    \        else\n            break\n    end\n    parsed_brackets = parsed_brackets\
    \ + [bracket[2:length(paren_string)-1]]\n    return parsed_brackets", "    paren_string\
    \ = paren_string.trim()\n    \n    # Get the string with all nested parentheses\
    \ removed by using regex\n    paren_regex = r\"\\([^\\(\\)]*\\)\"\n    paren_res\
    \ = paren_string.match(paren_regex)\n    \n    # Return an empty vector if the\
    \ parenthesis cannot be found\n    if paren_res == nothing\n        return []\n\
    \    \n    # Convert the resulting regex match into a list\n    nested_parens_list\
    \ = paren_res[1].findall\n    \n    # Initialize a vector to store current level\
    \ of nesting\n    current_level_of_nesting = Int64[]\n    \n    # Loop through\
    \ each of the nested parentheses\n    for parens in nested_parens_list\n     \
    \   \n        # Initialize a counter to keep track of the current number of levels\
    \ of nesting\n        count_of_current_level_of_nesting = 1\n        \n      \
    \  # Find all parentheses in the string and find the last index\n        last_index\
    \ = parens.search(r\"\\)\")\n        \n        # Loop through all the characters\
    \ in the string\n        for index in parens.chars\n            \n           \
    \ # Increment the count of current level of nesting for the parenthesis\n    \
    \        count_of_current_level_of_nesting += 1\n            \n            # If\
    \ there are no more nested parenthesis left, stop looping\n            if count_of_current_level_of_nesting\
    \ == 1\n                break\n            \n            # If there are some more\
    \ nested parentheses left, decrement the count of current level of nesting\n \
    \           elif count_of_current_level_of_nesting > 1\n                count_of_current_level_of_nesting\
    \ -= 1\n            \n            # If the current character is right after the\
    \ last left parenthesis, increment the count of current level of nesting\n   \
    \         if parens.chars[index] == parens.chars[last_index]\n               \
    \ count_of_current_level_of_nesting += 1\n            \n            # If current\
    \ character is right after the last left parenthesis, decrement the count of current\
    \ level of nesting\n            if parens.chars[index] == parens.chars[last_index\
    \ + 1]\n                count_of_current_level_of_nesting -= 1\n            \n\
    \            # If the last character is right after the last left parenthesis,\
    \ set the current level of nesting to 1\n            if parens.chars[index - 1]\
    \ == parens.chars[last_index]\n                count_of_current_level_of_nesting\
    \ = 1\n            \n            # If the last character is right after the last\
    \ left parenthesis, set the current level of nesting to 2\n            if parens.chars[index\
    \ - 1] == parens.chars[last_index + 1]\n                count_of_current_level_of_nesting\
    \ = 2\n            \n            # Append the count of current level of nesting\
    \ to the current level of nesting\n            current_level_of_nesting += count_of_current_",
  "    paren_string = normalize_string(paren_string)\n    paren_string = strip(paren_string)\n\
    \    paren_string = strip(paren_string, \"()\")\n    paren_string = strip(paren_string,\
    \ \"()\")\n    paren_string = strip(paren_string, \"()\")\n    paren_string =\
    \ strip(paren_string, \"()\")\n    paren_string = strip(paren_string, \"()\")\n\
    \    paren_string = strip(paren_string, \"()\")\n    paren_string = strip(paren_string,\
    \ \"()\")\n    paren_string = strip(paren_string, \"()\")\n    paren_string =\
    \ strip(paren_string, \"()\")\n    paren_string = strip(paren_string, \"()\")\n\
    \    paren_string = strip(paren_string, \"()\")\n    paren_string = strip(paren_string,\
    \ \"()\")\n    paren_string = strip(paren_string, \"()\")\n    paren_string =\
    \ strip(paren_string, \"()\")\n    paren_string = strip(paren_string, \"()\")\n\
    \    paren_string = strip(paren_string, \"()\")\n    paren_string = strip(paren_string,\
    \ \"()\")\n    paren_string = strip(paren_string, \"()\")\n    paren_string =\
    \ strip(paren_string, \"()\")\n    paren_string = strip(paren_string, \"()\")\n\
    \    paren_string = strip(paren_string, \"()\")\n    paren_string = strip(paren_string,\
    \ \"()\")\n    paren_string = strip(paren_string, \"()\")\n    paren_string =\
    \ strip(paren_string, \"()\")\n    paren_string = strip(paren_string, \"()\")\n\
    \    paren_string = strip(paren_string, \"()\")\n    paren_string = strip(paren_string,\
    \ \"()\")\n    paren_string = strip(paren_string, \"()\")\n    paren_string =\
    \ strip(paren_string, \"()\")\n    paren_string = strip(paren_string, \"()\")\n\
    \    paren_string = strip(paren_string, \"()\")\n    paren_string = strip(paren_string,\
    \ \"()\")\n    paren_string = strip(paren_string, \"()\")\n    paren_string =\
    \ strip(paren_string, \"()\")\n    paren_string = strip(paren_string, \"()\")\n\
    \    paren_string = strip(paren_string, \"()\")\n    paren_string = strip(paren_string,\
    \ \"()\")\n    paren_string = strip(paren_string, \"()\")\n    paren_string =\
    \ strip(paren_string, \"()\")\n    paren_string = strip(paren_string, \"()\")\n\
    \    paren_string = strip(paren_string, \"()\")", "        \n    stack = Vector{Int64}()\n\
    \    num_open = 0", "    nesting_levels::Vector{Int64} = []\n    \n    for parens\
    \ in split(paren_string, \" \")\n        push!(nesting_levels, length(parens))\n\
    \    end\n    \n    return nesting_levels\nend\n</cell>\n<code language=julia-1.5>\n\
    # Test your function\n\"\"\"\n    parse_nested_parens(paren_string::String)",
  "    paren_stacks = paren_string.split(' ')\n    paren_levels = Array{Int64}(lengths(paren_stacks))\n\
    \    paren_levels[1] = 0\n    for paren_stack in paren_stacks\n        push!(paren_levels,\
    \ paren_stack.count('('))\n    end\n    paren_levels = paren_levels[2:end]\n \
    \   return paren_levels\nend", "  paren_levels = Vector{Int64}()\n  paren_levels[0]\
    \ = 0\n  paren_levels[1] = 0\n  paren_levels[2] = 0\n  paren_levels[3] = 2\n \
    \ for paren in paren_string\n    if paren == '('\n      paren_levels[paren_levels[2]]\
    \ += 1\n    else if paren == ')'\n      if paren_levels[paren_levels[3]] == 0\n\
    \        paren_levels[paren_levels[2]] -= 1\n      else\n        paren_levels[paren_levels[3]]\
    \ -= 1\n    end\n  end\n  paren_levels\nend\n</code>\n<|/ a |>\n<| c |>\nThanks\
    \ for your help. I made a quick fix that I think will work. Maybe it's not as\
    \ robust as your example but this works for the example I gave.", "    # Create\
    \ a stack of lists (of parentheses) so we can check each level of parentheses\n\
    \    paren_string = string.replace(paren_string,\" \",\"\")\n    parenstack =\
    \ [string.replace(paren_string,\"(\",\"\"),string.replace(paren_string,\")\",\"\
    \")]\n    parenstackmax = 2 # Maximum level we allow for nesting", "    stack\
    \ = Stack()\n    depth = 1\n    parencount = 0\n    for pos in paren_string:\n\
    \        if pos=='('\n            parencount += 1\n            stack.push(pos)\n\
    \        else if pos==')'\n            parencount -= 1\n            if parencount==0\n\
    \                popped_pos = stack.pop()\n                depth += 1\n      \
    \          if depth==0\n                    push!(depth, popped_pos)\n       \
    \         end\n            end\n        else\n            nothing\n        end\n\
    \    end\n    depth\nend\n</cell>\n<text>\nExercise 4:\nWrite a function which\
    \ takes string as input and returns the number of opening parentheses (')') in\
    \ the string.", "    paren_count=0\n    stack=[]\n    for paren in paren_string\n\
    \        if paren == \"(\"\n            push!(stack,paren_count)\n           \
    \ paren_count+=1\n        elseif paren == \")\"\n            pop!(stack)\n   \
    \         paren_count-=1\n        end\n    end\n    return stack\nend", "    paren_list\
    \ = paren_string.split(\" \").\n    depth = zeros(Int, length(paren_list))\n \
    \   for i \u2208 1:length(paren_list)\n        if paren_list[i] == '('\n     \
    \       depth[i] = 0\n        else\n            depth[i] = 1\n        end\n  \
    \  end\n    max_depth = maximum(depth)\n    depth_of_parens = [i for i in paren_list\
    \ if depth[i] == max_depth]\n    deepest_parens = [i for i in depth_of_parens\
    \ if i == '(']\n    return deepest_parens\nend \"\"\"\n## A simple function that\
    \ returns the number of times a character appears in a string.\n## @param str\
    \ The string that needs to be searched.\n## @param ch The character to be searched\
    \ for.\n## @return The number of the occurrences of the character.", "    paren_string\
    \ = paren_string.strip\n    nested_parens = [parse_parens(paren_string)]\n   \
    \ while nested_parens[end-1] == []\n        nested_parens = nested_parens[end-1:]\n\
    \    end\n    return nested_parens\nend\n</cell>\n<text>\nThe function parse_nested_parens\
    \ takes each group of parentheses in the string and stores it as a list of nested\
    \ parentheses.", "        depth::Int64 = 0\n        nest_level::Int64 = 0\n  \
    \      nest_stack::Vector{Int64} = Vector{Int64}()\n        paren_stack::Vector{Int64}\
    \ = Vector{Int64}()", "    if paren_string == \"\"\n        return []\n    else\n\
    \        parens = split(paren_string, \" \")\n        parsed_parens = parse_nested_parens(parens[end-1])\n\
    \        push!(parsed_parens, length(parens) - 1)\n        return parsed_parens\n\
    \    end\nend\n</cell>\n<cell>", "        stack::Vector{Int64} = []\n        paren_counts::Vector{Int64}\
    \ = []\n        stack_size = length(paren_string)\n        paren_count = 1\n \
    \       for c in paren_string\n            if c == '('\n                push!(stack,\
    \ paren_count)\n                paren_count = paren_count + 1\n            elseif\
    \ c == ')'\n                pop!(stack)\n                paren_count = paren_count\
    \ - 1\n                if paren_count == 0\n                    paren_counts =\
    \ paren_counts\n                    stack_size = length(paren_string)\n      \
    \          elseif paren_count == 0\n                    paren_counts = paren_counts\n\
    \                    stack_size = paren_counts + 1\n                end\n    \
    \        else\n                paren_count = paren_count + 1\n            end\n\
    \        end\n        return paren_counts\n    end\n</code>\n<|/ a tags=depth,parsing,string,parentheses,r\
    \ |>\n<| c |>\nThis solution only works if the parentheses always have the same\
    \ depth. I wanted to expand this to handle different depths by extending it with\
    \ another function call.\n<|/ c |>\n<| a tags=depth,parsing,string,parentheses,r\
    \ dscore=2 |>\n<code>\n# Function for printing the number of parentheses (depth)\
    \ in a string\n# Function returns -1 if the parentheses don't exist\nget_depth\
    \ = function(str)\n{\n  for(i in 1:length(str))\n  {\n    if(str[i] == '(')\n\
    \    {\n      depth = i - 1\n      return(depth)\n    }\n  }\n  return(-1)\n}",
  "    paren_count = 0\n    paren_level = 0\n    paren_stack = []\n    \n    for i\
    \ in paren_string\n        if i == \"(\"\n            paren_count += 1\n     \
    \       paren_stack.append(paren_count)\n        elseif i == \")\"\n         \
    \   paren_count = paren_stack.pop()\n        elseif i == \" \"\n            if\
    \ paren_level == 0\n                paren_level += 1\n            else\n     \
    \           paren_level -= 1\n        end\n    end", "    input = paren_string.split('\
    \ ').map(parseInt)\n    result = []\n    for i in input\n        result = push!(result,\
    \ maximum_nested_parens(i))\n    return result\nend\n</cell>\n<code language=julia-0.6>",
  "    depth::Int64 = 0 \n    parens = paren_string.split(\" \") \n    for i in parens[1:]\
    \ \n        if i.starts_with(\"(\") then \n            depth += 1 \n        else\
    \ if i.ends_with(\")\") then \n            depth -= 1 \n            if depth <=\
    \ 0 \n            then \n                return parens.size - 1 \n           \
    \ else \n                continue \n            else \n                depth +=\
    \ 1 \n        else \n            continue \n    endfor \n    return -1\nendfunction\
    \ \n</cell>\n<code language=julia-1.0>\n# Test ", "    \"\"\" Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.", " \
    \   # Store the group in a string list\n    group_str::String = \"\"\n    # Loop\
    \ through the string and check whether they are nested\n    for char in paren_string\n\
    \        if char == \"(\" then\n            # If the group is not empty, then\
    \ add the group to group_str\n            if group_str != \"\"\n             \
    \   group_str << \"(\" \n            end\n            # Append the char to the\
    \ group\n            group_str << char\n        elseif char == \")\" then\n  \
    \          # If the group is not empty \n            if group_str != \"\"\n  \
    \              # Add this char to the group\n                group_str << char\n\
    \            # If the group is empty\n            else\n                # add\
    \ it to the output\n                output << parse(Int64, group_str)\n      \
    \          # Clear the group\n                group_str = \"\"\n            end\n\
    \        end\n    end\n    # if the group is not empty \n    if group_str != \"\
    \"\n        # add it to the output\n        output << parse(Int64, group_str)\n\
    \    end\n    return output\nend", "    stack = Vector{Int64}(paren_string.length())\n\
    \    for i in paren_string.indices()\n        if paren_string[i] == '('\n    \
    \        push!(stack, i)\n        else if paren_string[i] == ')'\n           \
    \ while length(stack) > 0\n                pop!(stack)\n            end\n    \
    \    end\n    end\n    return stack\nend", "\"\"\"\nParse string representation\
    \ of groups for nested parentheses separated by spaces.", "    # parse all groups\
    \ in paren_string\n    groups = split(paren_string, r\"\\(\")\n    # groups[i]\
    \ will be the set of parentheses\n    groups = group(groups)\n    # initialize\
    \ result to 0\n    result = Vector{Int64}(length(groups))\n    # parse groups\
    \ and add their depth to result\n    for i,g in enumerate(groups) do \n      \
    \  result[i] = maximum(parse(g), result[i])\n    end\n    return result\nend\n\
    </code>\n<|/ a tags=julia,parentheses |>\n<| c |>\nThe code is not very robust:\
    \ It doesn't handle a very complicated expression (as is given in the example\
    \ given) correctly.\n<|/ c |>\n<| c |>\nYou are right, i fixed the code\n<|/ c\
    \ |>\n<| a dscore=2 |>\nHere's a solution using recursive functions. I tested\
    \ it against another solution (this one) and found it to be about 3 times faster.\n\
    <code>", "    parentheses = paren_string.split(\" \").map(x -> x.endsWith(\")\"\
    )) - 1 \n    nested = Vector{Int64}()\n    for paren in parentheses\n        if\
    \ paren == 0\n            nested -= 1\n        else\n            if paren < parens[paren-1]\n\
    \                nested += 1\n            else\n                nested -= 1\n\
    \            end\n        end\n    end\n    return nested\nend\n</cell>\n<code\
    \ language=julia-0.5>\n\"\"\"\nThe algorithm for finding longest common subsequence\
    \ of two strings L1 and L2.\nThis is recursive and doesn't check whether the L1\
    \ and L2 are equal\n\"\"\"", "    # initialize a empty list of integers\n    levels::Vector{Int64}\
    \ = Int64[]", "\t\n\tparen_string = paren_string.trim()\n\tparen_string = paren_string.strip(\"\
    () \")\n\tparen_string = paren_string.strip(\"( )\")\n\tparen_string = paren_string.strip(\"\
    () \")\n\tparen_string = paren_string.strip(\"( )\")\n\tparen_string = paren_string.strip(\"\
    ()\")\n\tparen_string = paren_string.strip(\"() \")\n\tparen_string = paren_string.strip(\"\
    \")\n\t\n\tparen_string = paren_string.split(\") \")\n\t\n\tlevels = Dict{Int64,\
    \ Int64}()\n\tfor paren in paren_string\n\t\tparen = paren.strip()\n\t\t\n\t\t\
    paren = paren.strip(\"( )\")\n\t\t\n\t\tif paren == \"\"\n\t\t\tcontinue\n\t\t\
    \n\t\tif paren in levels\n\t\t\tlevels[paren] += 1\n\t\telse\n\t\t\tlevels[paren]\
    \ = 1\n\t\tend", "    \"\"\"\n    >>> parse_nested_parens(\"((())()) (((()())())())\"\
    )\n    [0, 1, 1, 2, 2, 3, 3, 5, 8, 8, 8, 8]\n    \"\"\"", "    \"\"\"\n    Input\
    \ to this function is a string represented multiple groups for nested parentheses\
    \ separated by spaces.\n    For each of the group, output the deepest level of\
    \ nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while\
    \ ((())) has three.", "# return vector of nested level of parentheses\n    s =\
    \ paren_string\n    paren_array = split(s, \")\")\n    levels = []\n    for paren\
    \ in paren_array\n        level = length(regexfindall(r\"\\((.*?)\\)\", paren))\n\
    \        push!(levels, level)\n    end\n    pop!(levels)\n    pop!(levels)\n \
    \   pop!(levels)\n    return levels\nend\n</code>\n<|/ a |>\n<| a |>\n<code>",
  "    parse_nested_parens(paren_string,0,0)\nend", '"""', "    paren_string_split\
    \ = split(paren_string, \" \")\n    paren_string_length = length(paren_string_split)\n\
    \    paren_string_level = 1\n    paren_string_counter = 0\n    nest_levels = []\n\
    \    \n    for paren_string_el in paren_string_split\n        if paren_string_el\
    \ == \"(\"\n            paren_string_counter += 1\n        elseif paren_string_el\
    \ == \")\"\n            paren_string_counter -= 1\n            if paren_string_counter\
    \ == 0\n                nest_levels[paren_string_level - 1] = paren_string_counter\n\
    \            end\n        end\n        paren_string_level += 1\n    end\n    return\
    \ nest_levels\nend\n</cell>\n<text>\n3.2 Evaluation of Parentheses\nThe task is\
    \ to write a function paren_eval that evaluates a parenthetical expression.\n\
    The function should take in a string represented a parenthetical expression and\
    \ returns the result of the expression.\nAs a bonus, if you do not have a solution\
    \ please try to come up with your own algorithm that can solve this problem and\
    \ that can run within under 1 second.", "    stack = Vector{Int64}(0)\n    ind_paren\
    \ = paren_string == \"()\" ? 0 : 1\n    for ch in paren_string\n        if ch\
    \ == \"(\" || ch == \"[\"\n            push!(stack, ind_paren)\n        elseif\
    \ ch == \")\"\n            pop!(stack)\n        elseif ch == \"]\"\n         \
    \   pop!(stack)\n        end\n    end\n    length(stack)\nend\n</cell>\n<code\
    \ language=julia-1.6>", "    paren_array=paren_string.split(\" \")\n    paren_levels=Vector{Int64}()\n\
    \    for (index, paren_string) in enumerate(paren_array)\n        paren_levels[index]=parse_nested_parens(paren_string)\n\
    \    end\n    return paren_levels", "    if paren_string.empty()\n        return\
    \ Vector{Int64}(0)\n    else\n        stack = Vector{Int64}()\n        current_level\
    \ = paren_string.length()\n        push!(stack, paren_string)\n        max_length\
    \ = 0\n        while length(stack) > 0\n            pop_level = stack[end]\n \
    \           pop!(stack)\n            if pop_level == current_level\n         \
    \       max_length = maximum(max_length, length(stack))\n            else\n  \
    \              max_length = maximum(max_length, length(stack))\n             \
    \   push!(stack, pop_level)\n                current_level = pop_level\n     \
    \       end\n        end\n        max_length\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @doc parse_nested_parens\n</cell>\n<code language=julia-1.5>\nparsed_nested_parens\
    \ = Vector{Int64}(parse(Int, string))\n</cell>\n<code language=julia-1.5>\nparsed_nested_parens\n\
    </cell>\n<code language=julia-1.5>", "    stack = Vector{Int64}()\n    paren_group::Vector{Int64}\
    \ = []\n    \n    for s in paren_string.split(' ')\n        if s == '(' || s ==\
    \ '[' || s == '{'\n            push!(stack, pop!(paren_group))\n        end\n\
    \        push!(paren_group, parse(Int, s))\n    end\n    \n    return paren_group\n\
    end", "    tokens = split(paren_string, \" \")\n    stack = []\n    level = 0\n\
    \    for i in tokens\n        push!(stack, ifelse(tokens[i]==\"(\", level+1, level))\n\
    \    end", "    if paren_string==\"()\" || paren_string==\"(()\" || paren_string==\"\
    ()()\"\n        return [0]\n    ends_with_left_parantheses = paren_string[-1]==\"\
    (\"\n    starts_with_right_parantheses = paren_string[1]==\")\"\n    if ends_with_left_parantheses\
    \ && !starts_with_right_parantheses \n        return [-1]\n    ends_without_left_parantheses\
    \ = paren_string[-1]==\")\"\n    contains_only_right_parantheses = paren_string[1:ends_with_left_parantheses-1]==\"\
    ()\"\n    if ends_without_left_parantheses && !contains_only_right_parantheses\
    \ \n        return [1]\n    \n    ends_with_left_parantheses_inside_right_parantheses\
    \ = paren_string[1]==\"(\" && paren_string[-1]==\")\"\n    if ends_with_left_parantheses_inside_right_parantheses\
    \ \n        left_parantheses_count = paren_string.count(\"(\")\n        right_parens_count\
    \ = paren_string.count(\")\")\n        left_parantheses_count = left_parantheses_count\
    \ - left_parantheses_count%2\n        right_parens_count = right_parens_count\
    \ - right_parens_count%2\n        left_parantheses_count +=1\n        right_parens_count\
    \ +=1\n        return [2]*left_parantheses_count + [right_parens_count]*left_parantheses_count\n\
    \    ends_with_left_parantheses_inside_left_parantheses = paren_string[1]==\"\
    (\" && paren_string[-1]==\"(\"\n    if ends_with_left_parantheses_inside_left_parantheses\
    \ \n        left_parantheses_count = paren_string.count(\"(\")\n        right_parens_count\
    \ = paren_string.count(\")\")\n        left_parantheses_count = left_parantheses_count\
    \ - left_parantheses_count%2\n        right_parens_count = right_parens_count\
    \ - right_parens_count%2\n        left_parantheses_count +=1\n        right_parens_count\
    \ +=1\n        return [-2]*left_parantheses_count + [left_parantheses_count]*right_parens_count\n\
    \    else\n        return [-1]\n    end\nend\n</cell>\n<text>\nParse a list of\
    \ strings\nInput to this function is a list of strings to be parsed. E.g.\n[\"\
    \ a \", \" b \", \" c \", \" d \"]\nwill result in the output [\"a\", \"b\", \"\
    c\", \"d\"]", "        parse_nested_parens_loop(paren_string, [])\nend", "   \
    \ paren_stack = Vector{Int64}()\n    current_level = 0\n    paren_stack[current_level]\
    \ = 0\n    for paren in paren_string\n        paren_stack[current_level] = current_level\
    \ + 1\n        if paren == '('\n            current_level += 1\n        if paren\
    \ == ')'\n            current_level -= 1\n            if current_level < 0\n \
    \               error(\"Too many nested parentheses\")\n        end\n    end\n\
    \    return paren_stack\nend", "        parse_parens = regex(r\"\\((.*?)\\)\"\
    )\n        paren_string_list = paren_string.split(\"\\n\")\n        paren_string_list\
    \ = paren_string_list[2:end]\n        paren_string_list = paren_string_list[1:end]\n\
    \        paren_string_list = paren_string_list[1:end]\n        paren_string_list\
    \ = paren_string_list[1:end]\n        paren_string_list = paren_string_list[1:end]\n\
    \        paren_string_list = paren_string_list[1:end]\n        paren_string_list\
    \ = paren_string_list[1:end]\n        paren_string_list = paren_string_list[1:end]\n\
    \        paren_string_list = paren_string_list[1:end]\n        paren_string_list\
    \ = paren_string_list[1:end]\n        paren_string_list = paren_string_list[1:end]\n\
    \        paren_string_list = paren_string_list[1:end]\n        paren_string_list\
    \ = paren_string_list[1:end]\n        paren_string_list = paren_string_list[1:end]\n\
    \        paren_string_list = paren_string_list[1:end]\n        paren_string_list\
    \ = paren_string_list[1:end]\n        paren_string_list = paren_string_list[1:end]\n\
    \        paren_string_list = paren_string_list[1:end]\n        paren_string_list\
    \ = paren_string_list[1:end]\n        paren_string_list = paren_string_list[1:end]\n\
    \        paren_string_list = paren_string_list[1:end]\n        paren_string_list\
    \ = paren_string_list[1:end]\n        paren_string_list = paren_string_list[1:end]\n\
    \        paren_string_list = paren_string_list[1:end]\n        paren_string_list\
    \ = paren_string_list[1:end]\n        paren_string_list = paren_string_list[1:end]\n\
    \        paren_string_list = paren_string_list[1:end]\n        paren_string_list\
    \ = paren_string_list[1:end]\n        paren_string_list = paren_string_list[1:end]\n\
    \        paren_string_list = paren_string_list[1:end]\n        paren_string_list\
    \ = paren_string_list[1:end]\n        paren_string_list = paren_string_list[1:end]\n\
    \        paren_string_list = paren_string_list[1:end]\n        paren_string_list\
    \ = paren_string_list[1:end]\n        paren_string_list = paren_string_list[1:end]\n\
    \        paren_string_list = paren_string_list[1:end]\n        paren_string_list\
    \ = paren_string_list[1:end]\n        paren_string_list = paren_string_list[1:end]\n\
    \        paren_string_list = paren_string_list[1:end]\n        paren_string_list\
    \ = paren_string_list[1:end]\n        paren_string_list = paren_string_list[1:end]\n\
    \        paren_string_list = paren_string_list[1:end]\n        paren_string_list\
    \ = paren_string_list[1:end]\n        paren_string_list = paren_string_list[1:end]\n\
    \        paren_string_list = paren_string_list[1:end]\n        paren_string_list\
    \ = paren_string_list[1:end]\n        paren_string_list = paren_string_list[1:end]\n\
    \        paren_string_list = paren_string_list[1:end]\n        paren_string_list\
    \ = paren_string_list[1:end]\n", "    paren_string = paren_string.strip() # Strip\
    \ white space\n    paren_string.trim() # Remove leading and trailing white space\n\
    \    paren_array = paren_string.split(' ') # Split by space\n    level = 0\n \
    \   result = []\n    for paren in paren_array\n        if paren == '('\n     \
    \       level += 1\n        elif paren == ')'\n            level -= 1\n      \
    \      result.push(level)\n        end\n    end\n    return result \nend", " \
    \   paren_vec = paren_string.split(\" \")\n    return parse_in_parens(paren_vec,\
    \ 0)\nend ", "    stack = Vector{Int64}()\n    open_bracket = paren_string.find(r\"\
    (\")\n    close_bracket = paren_string.find(r\")\")\n    open_paran = paren_string.find(r\"\
    \\(\")\n    close_paran = paren_string.find(r\"\\)\")\n    \n    if open_bracket\
    \ == -1 || close_bracket == -1\n        return Vector{Int64}()\n    end\n    \n\
    \    push!(stack, open_paran)\n    push!(stack, close_bracket)\n    while !isempty(stack)\n\
    \        push!(stack, paren_string[pop!(stack):pop!(stack)])\n    end\n    push!(stack,\
    \ close_bracket)\n    push!(stack, open_paran)\n    \n    deepest_level = 0\n\
    \    for parens in stack\n        deepest_level = max(deepest_level, parens -\
    \ open_bracket)\n    end\n    \n    return stack\nend\n</cell>\n<text>\nWe will\
    \ now use this function to extract the most deepest level of nested parentheses\
    \ given the string.", "    if paren_string==\"\"\n        []\n    else\n     \
    \   stack=[]\n        open_brackets_level=1 \n        parens_level=1 \n      \
    \  for character in paren_string\n            if character==\"(\"\n          \
    \      push!(stack, parens_level)\n                parens_level+=1\n         \
    \   elif character==\")\"\n                if parens_level==stack[end]\n     \
    \               parens_level=pop!(stack)\n                else\n             \
    \       parens_level=pop!(stack)\n                end\n                push!(stack,\
    \ parens_level)\n            else\n                push!(stack, parens_level)\n\
    \                parens_level+=1\n            end\n        end\n        return\
    \ stack\n    end\nend\n</cell>\n<code language=julia-1.2>\n# Test this function ",
  "    \"\"\"\n    Parse the parenthesis string into nested parentheses levels.",
  "    parse_into_arrays(paren_string)\nend", "  stack = Set()\n  max = 0\n  for parens\
    \ in paren_string.split(' '): \n    current = 1\n    push!(stack, parens)\n  \
    \  push!(stack, parens)\n    while true\n      pop!(stack)\n      pop!(stack)\n\
    \      if isempty(stack)\n        break\n      pop!(stack)\n      current += 1\n\
    \      push!(stack, parens)\n      push!(stack, parens)\n    end\n    push!(stack,\
    \ parens)\n    if current > max \n      max = current \n    end\n  end\n  max\n\
    end\n</cell>\n<code language=julia-1.3>\n# test code", "    paren_string = paren_string\n\
    \    paren_string = paren_string[1:length(paren_string)-1]\n    paren_string =\
    \ replace(paren_string,\"(\",\"\")\n    paren_string = replace(paren_string,\"\
    )\",\"\")\n    paren_string = split(paren_string)\n    paren_string = sort(paren_string,function(a::Int64,\
    \ b::Int64) -> (b) < (a)) -- sort in reverse order\n    max_level = 0\n    for\
    \ i = 1:length(paren_string)\n        paren_string[i] = paren_string[i] + 1 \n\
    \        if (paren_string[i] > max_level)\n            max_level = paren_string[i]\n\
    \    end", "    # Split the string into individual groups separated by spaces.\n\
    \    splitted_str = split(paren_string, \" \")", "    paren_string = strip(paren_string)\n\
    \    stacks = paren_string.split((\" \"))\n    nest_levels = []\n    for stack\
    \ in stacks\n        if stack == \"\"\n            nest_levels.append{-1}\n  \
    \      else\n            # find out how many parentheses are in each stack\n \
    \           paren_count = length(stack) - length(split(stack, \"()\"))\n     \
    \       if paren_count > length(nest_levels)\n                nest_levels{paren_count}\
    \ = -1\n            else\n                nest_levels{paren_count} = nest_levels{paren_count}\
    \ + 1\n            end\n        end\n    end\n    return nest_levels\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert [2,2,-1,-1] == parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n</cell>\n<text>\nTask 2 - Evaluating Symbolic Expressions",
  "    \"\"\"\n    Parse a string to find the level of nesting of parenthesis.\n \
    \   \"\"\"\n    paren_string = strip_brackets(paren_string)\n    depth = 0\n \
    \   paren_level = length(paren_string)\n    paren_groups = []\n    for paren in\
    \ paren_string\n        if paren == '('\n            depth += 1\n        elseif\
    \ paren == ')'\n            if depth > 0\n                depth -= 1\n       \
    \         paren_groups[end] = paren_level\n            else\n                error(\"\
    Mismatched parentheses at index: $paren_level\")\n            end\n        elseif\
    \ paren == '\\n'\n            paren_groups[end] = paren_level\n        end\n \
    \   end\n    return paren_groups\nend\n</code>\n<|/ a |>\n<| c |>\nThis solution\
    \ fails if the input is \"(()())\" instead of \"((())\")\n<|/ c |>\n<| a |>\n\
    Building on Szymon's answer:\n<code>", '    := paren_string.split(" ").map(x =>
    parens(x))', "    stack = Vector{Int64}(length(paren_string))\n    paren_counts\
    \ = Dict{Char,Int64}(paren_string)\n    function is_balanced(paren_counts::Dict{Char,Int64})\n\
    \        for (key,value) in paren_counts\n            if paren_counts[key] % value\
    \ != 0\n                return false\n        end\n        return true\n    end\n\
    \    for (index,char) in enumerate(paren_string)\n        if is_balanced(paren_counts)\n\
    \            stack[index] += 1\n        elseif paren_counts[char] > 0\n      \
    \      paren_counts[char] -= 1\n            while stack[index] > 0\n         \
    \       stack[index] = stack[index] - 1\n            end\n            stack[index]\
    \ += 1\n        end\n    end\n    return stack\nend", "    stack::Vector{Int64}\
    \ = Stack([0])\n    function get_level(paren::Int64, stack::Vector{Int64})::Int64\n\
    \        if paren > 0\n            stack[paren] = paren\n            return paren\n\
    \        elseif paren == 0 \n            return length(stack)\n        else\n\
    \            return get_level(paren - 1, stack)\n        end\n    end\n    level::Int64\
    \ = get_level(length(paren_string) - 1, stack)\n    if level < 0 \n        return\
    \ -1\n    end\n    level\nend\n</code>\nThe function returns a vector of depth\
    \ of nesting for each group of parentheses.\n<|/ a |>\n<| c |>\nI like the use\
    \ of recursion for this problem. I tried using it, but it doesn't seem to be working.\
    \ I'm working on it but any help would be great! Thanks :)\n<|/ c |>\n<| a |>\n\
    Here is a different solution to this problem that doesn't require a recursive\
    \ function.\n<code>\ns = \"(())\"\nd = Dict(\"(())\" => 0, \"(())()\" => 1, \"\
    (()())\" => 2, \"()()()\" => 3)\nmax = 0\nfor i in eachindex(s)\n    if s[i] ==\
    \ \"(\"\n        max = max(max, d[i])\n    elseif s[i] == \")\"\n        d[i]\
    \ = d[i] - max\n        max = 0\n    elseif s[i] == \")\" and d[i] > 0 \n    \
    \    d[i] = d[i] - max\n        max = 0\n    end\nend", "    if paren_string ==\
    \ \"\" \n        then return Vector{Int64}()\n    else \n        paren_string\
    \ = paren_string[1:end]\n        levels = paren_string.scan(parens_re) #re.findall(parens_re,\
    \ paren_string)\n        levels = map(level -> Int64(level), levels)\n       \
    \ levels = reverse(levels)\n        levels = map(level -> level - 1, levels)\n\
    \        levels = reverse(levels)\n        levels = map(level -> level + 1, levels)\n\
    \        levels = reverse(levels)\n        return levels\n    end\nend\n</code>\n\
    <|/ a tags=string,julia,recursion,parsing |>\n<| a dscore=1 |>\nHere's a non-regex\
    \ solution that may or may not be faster:\n<code>", "\"\"\"\n    Parsing of nested\
    \ parentheses separated by spaces.\n    E.g. \"(()()) ((())) () ((())()())\" returns\
    \ [2, 3, 1, 3].", "    #Parse the input string into nested parentheses\n    paren_chars\
    \ = split(paren_string) ", "    stack = Vector{Int64}(0)\n    for i in paren_string.split\n\
    \        if i == '('\n            push!(stack, pop!)\n        elseif i == ')'\n\
    \            push!(stack, pop!)\n            push!(stack, pop!)\n        elseif\
    \ i == '\\\\)'\n            push!(stack, pop!)\n        else\n            push!(stack,\
    \ 1)\n        end\n    end\n    return stack\nend", "    stack = Vector{Int64}()\n\
    \    idx = 0\n    opening_brackets = 0\n    closing_brackets = 0\n    for el in\
    \ paren_string\n        if el == '('\n            push!(stack,idx)\n         \
    \   opening_brackets += 1\n        elseif el == ')'\n            closing_brackets\
    \ -= 1\n            if closing_brackets == 0 && opening_brackets == 0\n      \
    \          push!(stack,idx)\n            end\n        elseif el == ' '\n     \
    \       push!(stack,idx)\n        end\n        idx += 1\n    end\n    length!(stack)\n\
    \    maximum!(stack)\nend\n</cell>\n<text>\nStep 2\nThe second task is to write\
    \ a function to compute the number of pairs of parentheses. For example, the string\
    \ \"(()())()()\" has six pairs of parentheses. Write a function to do this efficiently.",
  "  \n    ans = Vector{Int64}()", "    parse_paren_recursive(paren_string, 1, 0)\n\
    end\n</cell>\n<code language=julia-1.0>", "    \"\"\"Given a string, parse out\
    \ the nested parentheses into a vector.\"\"\"\n    function stack::Stack{Int64}\n\
    \        stack.push(-1)\n        paren_string = paren_string.strip\n        if\
    \ paren_string.length == 0 \n            return stack\n        else\n        \
    \    paren_string = paren_string[1:end-1]\n            for i in paren_string\n\
    \                if i == \"(\"\n                    stack.push(-1)\n         \
    \       elseif i == \")\"\n                    top = stack.pop\n             \
    \       if top != -1\n                        if top == -1\n                 \
    \           push!(stack, -1)\n                        else\n                 \
    \           push!(stack, top + 1)\n                    else\n                \
    \        push!(stack, -1)\n                end\n            end\n        end\n\
    \    end\n    return stack\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n\
    \    find_nested_parens(paren_string::String)", '# write your function here',
  "    parse_nested_parens = rep(parse_nested_parens, paren_string.length())\n   \
    \ parse_nested_parens[paren_string] \nend\n</cell>\n<code language=julia-0.5>\n\
    \"\"\" Parse an expression and return the number of nested parentheses \"\"\"",
  "    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    if paren_string ==\
    \ \"\"\n        return Vector{Int64}()\n    \n    paren_array = split(paren_string,\
    \ \" \")\n    paren_array_size = length(paren_array)\n    \n    paren_array_max_levels\
    \ = Vector{Int64}()\n    for paren_index in 1:paren_array_size\n        current_paren_array\
    \ = paren_array[paren_index]\n        \n        current_paren_array_size = length(current_paren_array)\n\
    \        current_paren_array_max_levels = Vector{Int64}()\n        for current_paren_index\
    \ in 1:current_paren_array_size\n            current_paren_max_level = max(current_paren_array[current_paren_index])\n\
    \            current_paren_array_max_levels.append(current_paren_max_level)\n\
    \        end\n        \n        paren_array_max_levels = maximum(paren_array_max_levels,\
    \ current_paren_array_max_levels)\n    end\n    \n    return paren_array_max_levels\n\
    end", "\tparen_string = paren_string[2,end]\n\tnesting = 0\n\tstack = []\n\tfor\
    \ char in paren_string\n\t\tif char == '('\n\t\t\tnesting += 1\n\t\t\tpush!(stack,nesting)\n\
    \t\telsif char == ')'\n\t\t\tpop!(stack)\n\t\t\tnesting -= 1\n\t\t\tif nesting\
    \ == 0\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\tpush!(stack,nesting)\n\treturn\
    \ stack\nend", "    stack = Array{Int, 1}(undef, 0)\n    level = 0\n    pos =\
    \ 0\n    while pos < length(paren_string)\n        if paren_string[pos] == \"\
    )\"\n            level = stack[end]\n            stack[end] = -1\n        end\n\
    \        if paren_string[pos] == \"(\"\n            push!(stack, level)\n    \
    \    end\n        if paren_string[pos] == \" \"\n            level += 1\n    \
    \        pos += 1\n        end\n        pos += 1\n    end\n    return stack\n\
    end\n</cell>\n<code language=julia-1.5>", "    # Split the string and create a\
    \ list of lists representing groups\n    paren_string_list = split(paren_string,\
    \ \"\")\n    \n    # Iterate over each group and find the deepest level of parentheses\n\
    \    level = 0\n    for paren_string in paren_string_list\n        # Iterate over\
    \ each group of parentheses\n        for i in paren_string\n            if i ==\
    \ \"(\"\n                level += 1\n            elseif i == \")\"\n         \
    \       level -= 1\n                if level < 0\n                    error(\"\
    Found invalid number of parentheses in string\")\n                end\n      \
    \      end\n        end\n    end", "    stack = Vector{Int64}()\n    parens =\
    \ Vector{Int64}()\n    for ch in paren_string\n        if ch == '('\n        \
    \    push!(stack, 1)\n        elseif ch == ')'\n            pop!(stack)\n    \
    \        while length(stack) > 0\n                push!(parens, pop!(stack)-1)\n\
    \            end\n        elseif ch == '['\n            push!(stack, -1)\n   \
    \     elseif ch == ']'\n            while length(stack) > 0\n                if\
    \ stack[length(stack)-1] == -1\n                    break\n                else\n\
    \                    pop!(stack)\n                end\n            end\n     \
    \   else\n            push!(parens, -1)\n        end\n    end\n    return parens\n\
    end", "    \"\"\"\n    Takes a string that represents multiple groups of parentheses\
    \ separated by spaces and parses them into a vector of integers representing the\
    \ levels.\n    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n \
    \   \"\"\"\n    parsed_parens = paren_string.split(' ')\n    result = Int64[length(parsed_parens)]\n\
    \    for paren in parsed_parens\n        paren = paren.strip\n        if paren.length\
    \ == 1\n            result[parens] = 1\n        else\n            result[parens]\
    \ += 1\n        end\n    end\n    return result\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nFor me this does not work since it returns 0 for string like \"\
    ()()()()()\". Can you check it out please?\n<|/ c |>\n<| a tags=julia |>\nThe\
    \ accepted solution above does not work for me. \nThe following does however:\n\
    <code>", "    \"\"\"\n    A function to parse string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"", "    inputString::String\
    \ = paren_string\n    open_bracket::Int64 = 0\n    close_bracket::Int64 = 0\n\
    \    stack::Vector{Int64} = [0]\n    stack_length::Int64 = 0\n    \n    for c\
    \ in inputString\n        if c == '('\n            if open_bracket == 0\n    \
    \            push!(stack, open_bracket)\n                stack_length += 1\n \
    \           else\n                push!(stack, stack[open_bracket])\n        \
    \        stack_length += 1\n            end\n            open_bracket += 1\n \
    \       elseif c == ')'\n            if close_bracket == 0\n                throw(ParseError(string(\"\
    Unbalanced Parentheses \")+\n                    string(inputString)))\n     \
    \       else\n                push!(stack, stack[close_bracket])\n           \
    \     stack_length += 1\n            end\n            close_bracket += 1\n   \
    \     else\n            push!(stack, c)\n        end\n    end\n    if open_bracket\
    \ == 0\n        throw(ParseError(string(\"Unbalanced Parentheses \")+\n      \
    \      string(inputString)))\n    elseif close_bracket == 0\n        throw(ParseError(string(\"\
    Unbalanced Parentheses \")+\n            string(inputString)))\n    end", "  \
    \  # Write your code here\n    return Vector{Int64}(paren_string, parse(\"()\"\
    ) do parens, i ->\n        if parens[i] == \"(\" \n            parse_nested_parens(parens[i+1:i+parens[i+1]==\"\
    )\".size+1]\n        else\n            parens[i+1] == \"()\".size\n        end)\n\
    end\n</cell>\n<text>\nPart 2: Write a recursive function to calculate n-th Fibonacci\
    \ number using Dynamic Programming with memoization.", "    paren_string = strip(paren_string)\n\
    \    paren_string_split = split(paren_string, \" \")\n    levels = Vector{Int64}()\n\
    \    for (i, paren_string) in paren_string_split\n        if paren_string == \"\
    (\"\n            push!(levels, 1)\n        elseif paren_string == \")\"\n    \
    \        pop!(levels)\n        else\n            push!(levels, length(levels)\
    \ + 1)\n        end\n    end\n    return levels\nend", '    """Parse the nested
    parenthesis string.', "    if paren_string == \"\" \n        return Vector{Int64}()\n\
    \    opening_parens = []\n    closing_braces = []\n    num_opening_braces = 0\n\
    \    num_closing_parentheses = 0\n    opening_parens_stack = Vector{Int64}()\n\
    \    close_braces_stack = Vector{Int64}()\n    level = 0\n    for char in paren_string\n\
    \        push!(opening_parens_stack, 0)\n        if char == \"(\"\n          \
    \  opening_parens_stack[end] = level + 1\n            num_opening_braces += 1\n\
    \        elseif char == \")\"\n            num_opening_braces -= 1\n         \
    \   if num_opening_braces == 0 && length(opening_parens_stack) > 0\n         \
    \       level = opening_parens_stack[end]\n            elseif num_opening_braces\
    \ == 0\n                push!(closing_braces, level)\n            end\n      \
    \  else\n            push!(close_braces_stack, level)\n        end\n    end\n\
    \    level = max(level, maximum(opening_parens_stack))\n    level = max(level,\
    \ maximum(closing_braces_stack))\n    \n    levels = Vector{Int64}(level + 1)\n\
    \    levels[1:level] = opening_parens_stack\n    levels[level+1:end] = closing_braces_stack\n\
    \    return levels\nend", "    paren_array = paren_string.split(\" \")\n    paren_array2\
    \ = paren_array.map(x -> parse(Vector{Int64}(x), 0))\n    paren_array3 = paren_array2.map(x\
    \ -> maximum(x.map(x -> x)))\n    paren_array4 = paren_array3.map(x -> x.last)\n\
    \    return paren_array4\nend", "    depths = Vector{Int64}()\n    parens = 0\n\
    \    current_depth = 0\n    for c in paren_string\n        if c == '('\n     \
    \       parens += 1\n            current_depth += 1\n            push!(depths,\
    \ current_depth)\n        if c == ')'\n            pop!(depths)\n            current_depth\
    \ -= 1\n        end \n    end\n    return depths\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\n    paren_string_to_string(paren_string::String)::String", "    stack\
    \ = Vector{Int64}()\n    paren_len = paren_string.length\n    opening_parentheses\
    \ = 0\n    \n    for (i, char) in paren_string\n        if char == \"(\"\n   \
    \         opening_parentheses += 1\n        else if char == \")\"\n          \
    \  if opening_parentheses == 0\n                stack = stack[end - 1: end]\n\
    \            opening_parentheses -= 1\n        end\n    end", "    # Handle empty\
    \ string\n    if paren_string == \"\" \n        return Vector{Int64}()\n    end",
  "    paren_string |> \n    chars::Vector{String} = (paren_string)\n    \n    function\
    \ pop_paren_level(stack::Vector{Int64}, paren_count::Int64)\n        while stack.length\
    \ > 0\n            if paren_count == 0\n                stack.pop()\n        \
    \    elseif paren_count == stack[length(stack)-1]\n                stack.pop()\n\
    \            else\n                stack[paren_count] = stack[paren_count-1]\n\
    \                paren_count -= 1\n            end\n        end\n    end\n   \
    \ \n    paren_levels::Vector{Int64} = Vector{Int64}(length(paren_string))\n  \
    \  \n    for paren_count in 1:length(paren_string)\n        if paren_count ==\
    \ 1\n            paren_levels[paren_count] = 1\n        else\n            pop_paren_level(paren_levels,\
    \ paren_count)\n        end\n    end", "    #create an empty vector to store results\
    \ \n    stack=Vector{Int64}()\n    stack_length=0", "    \"\"\"\n    Parses a\
    \ parenthesized string, counting the number of nested parens.", "    paren_str_arr\
    \ = paren_string.split(\" \")\n    levels_of_paren_nestings = parse_nested_parens(paren_str_arr[1])\n\
    \    levels_of_paren_nestings[paren_str_arr[2]-1] += 1\n    return levels_of_paren_nestings\n\
    end \n</cell>\n<code language=julia-1.5>\n@time parse_nested_parens(\"(()()) ((()))\
    \ () ((())()())\")\n</cell>\n<text>\nWe can now write a parser that can parse\
    \ a string of valid mathematical expressions, including nested parentheses.\n\
    The following code is inspired by this article:", "    paren_string = remove_non_nested_parens(paren_string)\n\
    \    paren_string = remove_non_nested_spaces(paren_string)\n    paren_string =\
    \ remove_non_nested_parentheses(paren_string)\n    paren_string = remove_non_nested_comma(paren_string)\n\
    \    paren_string = remove_non_nested_double_quotes(paren_string)\n    paren_string\
    \ = remove_non_nested_single_quotes(paren_string)\n    paren_string = remove_non_nested_dashes(paren_string)\n\
    \    paren_string = remove_non_nested_periods(paren_string)\n    paren_string\
    \ = remove_non_nested_comma(paren_string)", "    parentheses = paren_string.split(\"\
    \ \");\n    \n    parse_nested_parens_helper(\"\", parentheses)\nend", "\"\"\"\
    \nParse a string containing multiple groups of nested parentheses separated by\
    \ spaces.", "    parens = paren_string.split(' ')\n    levels = 0\n    stack =\
    \ Vector{Int64}(parens)\n    while length(stack) > 0\n        elem = pop!(stack)\n\
    \        if elem == \"(\"\n            push!(stack, elem)\n            levels\
    \ += 1\n        elseif elem == \")\"\n            levels -= 1\n            push!(stack,\
    \ elem)\n        else\n            if levels > 0\n                push!(stack,\
    \ elem)\n            else\n                push!(stack, elem)\n            end\n\
    \        end\n    end\n    stack\nend\n</cell>\n<code language=julia-1.3>\n@test\
    \ parse_nested_parens(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n</cell>\n\
    <code language=julia-1.3>", "    paren_string = paren_string.trim()\n    opening_braces\
    \ = paren_string.rfind(\"(\")\n    closing_braces = paren_string.rfind(\")\")\n\
    \    if opening_braces > closing_braces\n        nesting_level = closing_braces\
    \ + 1\n        paren_string = paren_string[nesting_level:]\n    else\n       \
    \ nesting_level = opening_braces + 1\n        paren_string = paren_string[nesting_level:]\n\
    \    end\n    paren_string.split(\"()\")\n    paren_string.split(\"()()\")\n \
    \   paren_string.split(\"()()()\")\n    paren_string.split(\"()()()()\")\nend\n\
    </cell>\n<code language=julia-1.2>", "    \"\"\"\n    >>> parse_nested_parens(\"\
    ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"", "    if paren_string==\"\
    \" then return [] end\n    stack = Vector{Int64}()\n    ind_stack = Vector{Int64}()\n\
    \    stack_size = paren_string.length()\n    \n    for i = 1:stack_size\n    \
    \    if paren_string[i]==\"(\" && paren_string[i+1]!=\"(\" \n            stack\
    \ = push!(stack,ind_stack[stack])\n            ind_stack = Vector{Int64}()\n \
    \           stack_size = stack_size + 1\n        end\n        if paren_string[i]==\"\
    )\" && paren_string[i+1]!=\")\" \n            ind_stack = pop!(stack)\n      \
    \      push!(ind_stack,stack_size-1)\n            stack_size = stack_size - 1\n\
    \        end\n        if paren_string[i]==\" \" \n            if paren_string[i+1]==\"\
    (\" || paren_string[i+1]==\")\" || paren_string[i+1]==\" \" \n               \
    \ stack = pop!(stack)\n                stack_size = stack_size - 1\n         \
    \       ind_stack = Vector{Int64}()\n            end\n        end\n        if\
    \ paren_string[i]==\" \" \n            stack = pop!(stack)\n            stack_size\
    \ = stack_size - 1\n            ind_stack = Vector{Int64}()\n        end\n   \
    \ end\n    \n    return stack\nend", "    stack=Vector{Int64}()\n    paren_count=0\n\
    \    \n    for x in paren_string\n        if x=='('\n            paren_count+=1\n\
    \        elseif x==')'\n            paren_count-=1\n        else\n           \
    \ if paren_count==0\n                push!(stack,1)\n            else\n      \
    \          push!(stack,stack[end]-1)\n            end\n        end\n    end\n\
    \    push!(stack,1)\n    return stack\nend", "    paren_string = paren_string.split(\"\
    ()\")\n    groups = parse_parens(paren_string)\n    return parse(groups)\nend",
  "    paren_array = []\n    paren_stack = []\n    paren_levels = []\n    \n    for\
    \ c in paren_string\n        if c == '('\n            paren_stack = paren_stack:push(c)\n\
    \            if paren_stack\n                paren_array:push(paren_stack)\n \
    \           else\n                paren_levels:push(length(paren_array))\n   \
    \             paren_array:push(0)\n            end\n        elseif c == ')'\n\
    \            levels = pop(paren_stack)\n            if paren_stack == []\n   \
    \             paren_levels:pop(paren_levels)\n            else\n             \
    \   paren_levels:pop(paren_array):pop(paren_levels)\n            end\n       \
    \     paren_stack = paren_stack:pop(levels)\n        else\n            push(c)\n\
    \        end\n    end\n    \n    \n    if paren_stack\n        paren_array:pop(paren_levels)\n\
    \    end\n    \n    return paren_array\nend\n</cell>\n<text>\nWrite a function\
    \ that converts a string that has all numbers represented with parentheses to\
    \ an integer array that contains all the numbers. If the parentheses are unbalanced,\
    \ raise an error. If the string is an invalid input (no numbers), raise an error.",
  "    ...\n</code>\nI do not claim this code is optimal, but it is pretty clear.\n\
    <|/ a dscore=2 tags=string,algorithm,parentheses,python |>\n<| c |>\nThank you\
    \ so much for the help! I implemented this in Python, and the result was \"[2,\
    \ 3, 1, 3]\". It's a great algorithm, and I definitely appreciate it!\n<|/ c |>\n\
    <| a tags=string,algorithm,parentheses,python dscore=1 |>\nI would use two stacks,\
    \ one for parens opened and one for parens closed.\n<code>\ndef count_parantheses(text):\n\
    \    opened_parantheses = []\n    closed_parantheses = []\n    index = 0\n   \
    \ for c in text:\n        if c == '(':\n            opened_parantheses.append(index)\n\
    \        elif c == ')':\n            index = opened_parantheses.pop()\n      \
    \  else:\n            closed_parantheses.append(index)\n            index = index\
    \ + 1", "    paren_stack = Vector{Int64}()\n    paren_stack = parse_brackets(paren_string)\n\
    \    max_length = 0\n    for i in paren_stack\n        if i > max_length\n   \
    \         max_length = i\n    end\n    return paren_stack[max_length:]\nend",
  "  result::Vector{Int64} = Vector{Int64}()\n  paren_string = paren_string.split('\
    \ ')\n  paren_string.iterate(function(elt)\n    push!(result, (paren_string.index(elt)\
    \ + 1))\n  end)\n  return result\nend\n</cell>\n<text>\nWe now implement our function",
  "    (chars, nesting_level) \n    => paren_chars = paren_string.chars()\n    =>\
    \ paren_chars\n    => paren_chars.takewhile(char -> char == ')').drop(1)\n   \
    \ => paren_chars\n    => paren_chars.takewhile(char -> char == '(').drop(1)\n\
    \    => paren_chars\n    => paren_chars.takewhile(char -> char == ')')\n    =>\
    \ paren_chars.takewhile(char -> char == '(').drop(1)\n    => paren_chars\n   \
    \ => paren_chars.takewhile(char -> char == '(').drop(1)\n    => paren_chars\n\
    \    => paren_chars.takewhile(char -> char == ')')\n    => paren_chars.takewhile(char\
    \ -> char == '(').drop(1)\n    => paren_chars.takewhile(char -> char == ')')\n\
    \    => paren_chars.takewhile(char -> char == '(').drop(1)\n    => paren_chars.takewhile(char\
    \ -> char == ')')\n    => paren_chars.takewhile(char -> char == '(').drop(1)\n\
    \    => paren_chars.takewhile(char -> char == ')')\n    => paren_chars.takewhile(char\
    \ -> char == '(').drop(1)\n    => paren_chars\n    => paren_chars.takewhile(char\
    \ -> char == '(').drop(1)\n    => paren_chars\n    => paren_chars\n    => paren_chars\n\
    \    => paren_chars\n    => paren_chars\n    => paren_chars\n    => paren_chars\n\
    \    => paren_chars\n    => paren_chars\n    => paren_chars\n    => paren_chars\n\
    \    => paren_chars\n    => paren_chars\n    => paren_chars\n    => paren_chars\n\
    \    => paren_chars\n    => paren_chars\n    => paren_chars\n    => paren_chars\n\
    \    => paren_chars\n    => paren_chars\n    => paren_chars\n    => paren_chars\n\
    \    => paren_chars\n    => paren_chars\n    => paren_chars\n    => paren_chars\n\
    \    => paren_chars\n    => paren_chars\n    => paren_chars\n    => paren_chars\n\
    \    => paren_char", "    paren_levels::Vector{Int64} = Vector{Int64}()\n    for\
    \ paren in paren_string\n        if paren == \"(\"\n            paren_levels.push(0)\n\
    \        else if paren == \")\"\n            paren_levels.pop()\n        else\n\
    \            if paren_levels.length == 0\n                paren_levels.push(paren)\n\
    \            else\n                paren_levels[paren_levels.length-1] += 1\n\
    \        end\n    end", "    stack = Vector{Int64}()\n    paren_depth = Vector{Int64}()\n\
    \    paren_open = Vector{Int64}()\n    paren_close = Vector{Int64}()\n    open_count\
    \ = 0\n    close_count = 0\n    paren_open_count = 0\n    paren_close_count =\
    \ 0\n    for ch in paren_string\n        if ch == '('\n            push!(stack,\
    \ open_count)\n            paren_open_count += 1\n        elseif ch == ')'\n \
    \           push!(stack, close_count + stack[length(stack)])\n            paren_close_count\
    \ += 1\n        else\n            if ch == '{'\n                push!(paren_depth,\
    \ open_count)\n            elseif ch == '}'\n                push!(paren_depth,\
    \ close_count + paren_depth[length(paren_depth)])\n            else\n        \
    \        push!(paren_open, open_count)\n                open_count += 1\n    \
    \            push!(paren_close, close_count + paren_open[length(paren_open)])\n\
    \                close_count += 1\n            end\n        end\n    end\n   \
    \ return paren_depth\nend\n</code>\nAnd then we can compute the answer in O(N)\
    \ time\n<code>", "    return parse_nested_parens_helper(paren_string, 0)\nend",
  "    paren_stack = Vector{Int64}(paren_string)\n    paren_stack = remove_trailing_char(paren_stack)\n\
    \    paren_stack = remove_leading_char(paren_stack)\n    \n    for i in paren_stack\n\
    \        paren_stack = remove_parens(paren_stack)\n        if paren_stack != paren_string\n\
    \            paren_stack = remove_trailing_char(paren_stack)\n            paren_stack\
    \ = remove_leading_char(paren_stack)\n        end\n    end\n    \n    paren_stack\
    \ = remove_trailing_char(paren_stack)\n    paren_stack = remove_leading_char(paren_stack)",
  "  paren_string = paren_string.strip\n  stack = Vector{Int64}(paren_string)\n  stack_size\
    \ = length(stack)\n  \n  while stack_size > 0\n    stack_size -= 1\n    last_element\
    \ = stack[stack_size]\n    if last_element == ')'\n      stack_size = stack_size\
    \ - 1\n    elseif last_element == '('\n      stack_size += 1\n      stack[stack_size]\
    \ = stack[stack_size - 1]\n    end\n  end\n  \n  return stack\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"\nInput: paren_string - string represented multiple\
    \ groups for nested parentheses separated by spaces\nOutput: deepest level of\
    \ nesting of parentheses\nE.g. (()()) has maximum two levels of nesting while\
    \ ((())) has three.\n\"\"\"", "  result=[]\n  for paren_group in split(paren_string,\
    \ \" \") do\n    paren_group_split = split(paren_group, \")\")\n    paren_group_flat\
    \ = paren_group_split[1..end]\n    parent_level_length = 1 + max(map(len, paren_group_flat))\n\
    \    parent_level_level_lengths = paren_group_flat.map do paren_group_element\n\
    \      parent_level_length = 1 + length(paren_group_element)\n    end\n    parent_level_level_lengths\n\
    \    parent_level_level_lengths |> zip |> map do parent_level_level_length, paren_group_element\
    \ -> \n      parent_level_length / parent_level_level_length\n    end\n  end\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    count_parens(paren_string::String)",
  "    \"\"\"\n    Takes a parenthesis string and return a list of all the levels\
    \ \n    of nested parentheses.\n    \"\"\"\n    function parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n        paren_list = paren_string.split(\" \")\n        level_list = Vector{Int64}()\n\
    \        for i in paren_list\n            if i == '('\n                push!(level_list,\
    \ length(level_list))\n            elif i == ')'\n                level_list =\
    \ get!(level_list, length(level_list))\n            else\n                level_list\
    \ = get!(level_list, -1)\n            end\n        end\n        return level_list\n\
    \    end\nend\n</code>\n<|/ a |>\n<| c |>\nThis is a more elegant and efficient\
    \ solution that is both more efficient and easier to understand than the other\
    \ answers. Thank you for sharing it.\n<|/ c |>\n<| a tags=string,julia,algorithm\
    \ |>\nBased on answer by MichaelChen. I will post my own solution based on his\
    \ answer:\n<code>", "    \"\"\"Input to this function is a string represented\
    \ multiple groups for nested parentheses separated by spaces.\n    For each of\
    \ the group, output the deepest level of nesting of parentheses.\n    E.g. (()())\
    \ has maximum two levels of nesting while ((())) has three.\n    \"\"\"\nend",
  "    parens = paren_string.chars().filter(x -> x in \" ()\")\n    paren_count =\
    \ 0\n    paren_level = 0\n    current_level = 0\n    result = []\n    for paren\
    \ in parens\n        if paren == '('\n            paren_count += 1\n         \
    \   current_level += 1\n        elseif paren == ')'\n            paren_count -=\
    \ 1\n            current_level -= 1\n        elseif paren == ' '\n           \
    \ current_level += 1\n        else\n            paren_level = 0\n        end",
  "    parsed_depths = [0 for i in 0:get_depth(paren_string)]\n    for depth in parsed_depths\n\
    \        paren_depth = get_paren_depth(paren_string, depth)\n        if paren_depth\
    \ == depth\n            parsed_depths[depth] += 1\n        else\n            parsed_depths[paren_depth]\
    \ -= 1\n        end\n    end\n    return parsed_depths\nend", "</code>\nand call\
    \ this function like this\n<code>\nparen_string ~= StringReplace(paren_string,\
    \ \"()\", \"()()\", All)\nparen_string ~= StringReplace(paren_string, \"()\",\
    \ \"()()\", Regexp)\nparen_string ~= StringReplace(paren_string, \"()\", \"()()\"\
    , Replace)\nparen_string = paren_string.strip\nparsed_levels <- parse_nested_parens(paren_string)\n\
    </code>\nI hope this helps.\n<|/ a tags=parsing,string,regex,julia |>\n<| a |>\n\
    Another approach with StringScanner from the FlexibleRegex package:\n<code>\n\
    using StringScanners\nusing FlexibleRegex\ns = \"( ( () ( ()()()) ( ( () ) )(\
    \ ()()() ) ( ) )\"\ns2 =  r\"\\(\\s*\\((?i:(?:\\(\\))?)*\\)\\s*\\)\"", "    stack\
    \ = Vector{Int64}()\n    level = 0\n    last_index = length(paren_string) - 1\n\
    \    for index in 1:length(paren_string)\n        if paren_string[index] == '('\n\
    \            push!(stack, level)\n            level += 1\n        elseif paren_string[index]\
    \ == ')'\n            if length(stack) > 0\n                level = pop!(stack)\n\
    \            else\n                push!(stack, level)\n            end\n    \
    \    elseif paren_string[index] == ' '\n            if length(stack) > 0\n   \
    \             level = pop!(stack)\n            else\n                push!(stack,\
    \ level)\n            end\n        else\n            if length(stack) > 0\n  \
    \              level = pop!(stack)\n            else\n                push!(stack,\
    \ level)\n            end\n        end\n    end\n    return stack\nend\n</code>\n\
    <|/ a dscore=1 tags=data-structures,algorithm,parsing,python |>\n<| c |>\nI did\
    \ this, but I find it quite a difficult to implement it in python.\n<|/ c |>\n\
    <| c |>\nI added my python code for this task. Hope it helps.\n<|/ c |>\n<| a\
    \ dscore=0 tags=data-structures,algorithm,parsing,python |>\nYou can use a stack\
    \ to track the depth of nested parentheses.\n<code>\nclass Parser:\n    nesting\
    \ = 0", "        \n    # If the string is empty, return an empty list\n    if\
    \ paren_string.length() == 0\n        return []", "    parsed_paran = []\n   \
    \ # we get string with nested parentheses\n    # we start parsing with the last\
    \ opening parentheses\n    paren_count = 0\n    for character in paren_string\n\
    \        if character == ')'\n            # if we have enougth parentheses, we\
    \ continue with closing one\n            if paren_count > 0\n                #\
    \ if we have left parentheses, we decrease the paren_count\n                #\
    \ if we have right parentheses, we increase the paren_count\n                paren_count\
    \ -= 1\n                if paren_count == 0\n                    parsed_paran\
    \ += paren_count\n                    paren_count = 1\n            else\n    \
    \            paren_count = 1\n        elseif character == '('\n            paren_count\
    \ += 1\n            parsed_paran += paren_count\n            paren_count = 0\n\
    \        end\n    end\n    parsed_paran += paren_count\n    # we remove the last\
    \ parentheses with count\n    parsed_paran = parsed_paran[1:end]\n    return parsed_paran\n\
    end", "    parse_nested_parens_helper(paren_string, 0, 0)\nend\n\"\"\"\n    Parsing\
    \ function for the multiple groups representing the nested parenthesis.\n    The\
    \ input to this function is a string represented multiple groups for nested parentheses\
    \ separated by spaces.\n    For each of the group, output the deepest level of\
    \ nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while\
    \ ((())) has three.", "    \"\"\"\n    Parses a string containing groups of nested\
    \ parentheses separated by spaces.\n    Returns the deepest level of nesting of\
    \ parentheses for each group.", "    paren_string = paren_string[1..end-2]\n \
    \   stack = [1]\n    for ch in paren_string\n        if ch == ')'\n          \
    \  stack = stack[length(stack)-1]\n        elseif ch == '('\n            push!(stack,\
    \ stack[length(stack)-1]+1)\n        end\n    end\n    return stack\nend", "</code>\n\
    <|/ a dscore=2 |>\n<| a tags=recursion,string,python,stack,parsing |>\n<code>\n\
    def paren_count(s):\n    l=s.split()\n    stack=l\n    count=0\n    while len(stack)>0:\n\
    \        top=stack.pop(0)\n        if top =='(':\n            stack.append(')')\n\
    \            count+=1\n        elif top=='':\n            count+=1\n        else:\
    \ #'[' or '{'\n            count-=1\n            stack.append(top)\n    return\
    \ count\n</code>\n<|/ a dscore=1 |>\n<| c |>\nA little explanation would be helpful.\n\
    <|/ c |>\n<| c |>\nThis doesn't work with strings such as '(()())' because 'stack.append(top)'\
    \ doesn't work when 'top' has nothing but spaces.\n<|/ c |>\n<| a tags=recursion,string,python,stack,parsing\
    \ |>\n<code>\ndef paren_count(s):\n    l=s.split()\n    stack=l\n    count=0\n\
    \    while len(stack)>0:\n        top=stack.pop(0)\n        if top =='(':\n  \
    \          stack.append(')')\n            count+=1\n        elif top=='':\n  \
    \          count+=1\n        else: #'[' or '{'\n            count-=1\n       \
    \     stack.append(top)\n    return count\n</code>\n<|/ a dscore=0 |>\n<| a tags=recursion,string,python,stack,parsing\
    \ |>\n<code>\ndef paren_count(s):\n    paren = 0\n    for i in s:\n        if\
    \ i == '(':\n            paren += 1\n        elif i == ')':\n            paren\
    \ -= 1\n    return paren\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\n\
    def paren_count(s):\n    l=s.split()\n    stack=l\n    count=0\n    while len(stack)>0:\n\
    \        top=stack.pop(0)\n        if top!='':\n            count+=1\n       \
    \ else:\n            count+=1\n            if top=='(':\n                stack.append(')')\n\
    \            else:\n                stack.append(top)\n    return count\n</code>\n\
    <|/ a tags=recursion,string,python,stack,parsing |>\n<| c |>\nThis doesn't work\
    \ with strings such as '(()())' because 'stack.append(top)' doesn't work when\
    \ 'top' has nothing but spaces.\n<|/ c |>\n<| c |>\nThis only works for (()())\
    \ since it will count the amount of '(''s in the parenthesis.\n<|/ c |>\n<| c\
    \ |>\nHi ", "    paren_array = paren_string.split(\" \")\n    depth = 0\n    array\
    \ = []\n    for paren in paren_array\n        if paren == \"(\"\n            depth\
    \ += 1\n        else if paren == \")\"\n            depth -= 1\n        else if\
    \ depth == 0\n            array = [array,paren]\n        end\n    end\n    return\
    \ array\nend\n</cell>\n<code language=julia-1.5>\n@code_native parse_nested_parens(\"\
    (()())\")\n</cell>\n<text>\n6.4 Remove Parentheses\nWrite a function that removes\
    \ parentheses from the given string. Return output if the string does not contain\
    \ parentheses.", "        \n        parsable_parens = paren_string.split(' ')\n\
    \        nest_levels = Vector{Int64}(undef, length(parsable_parens))\n       \
    \ \n        # iterate through the string to parse parsable_parens\n        for\
    \ i in eachindex(parsable_parens)\n            if parsable_parens[i] == '('\n\
    \                nest_levels[i] = 1\n            elseif parsable_parens[i] ==\
    \ ')'\n                nest_levels[i] = 0\n            else\n                #\
    \ parse parsable_parens recursively\n                nest_levels[i] = 1 + max(nest_levels[i-1],\
    \ parse_nested_parens(paren_string.substring(i+1))) \n            end\n      \
    \  end\n        \n        # return the deepest level of nesting of parentheses\n\
    \        return nest_levels\n    end\n    \nend\n</cell>\n<text>\nExercise 1\n\
    Write a function that takes in an expression as an argument and returns the maximum\
    \ depth of any nested parentheses in the expression.", "  parens = paren_string.split()\n\
    \  levels = Dict{Char,Int64}()\n  for paren in parens\n    level = parens[parens.index(paren)-1]\
    \ == '(' ? 0 : parens[parens.index(paren)-1] == '{' ? 1 : parens[parens.index(paren)-1]\
    \ == '[' ? 2 : parens[parens.index(paren)-1] == '<' ? 3 : parens[parens.index(paren)-1]\
    \ == '>' ? 4 : parens[parens.index(paren)-1] == '{' ? 5 : parens[parens.index(paren)-1]\
    \ == '<' ? 6 : parens[parens.index(paren)-1] == '>' ? 7 : 0\n    if level in levels\n\
    \      levels[level] += 1\n    else\n      levels[level] = 1\n  end\n  return\
    \ collect(levels)\nend\n</cell>\n<code language=julia-1.5>\nusing Pkg\nPkg.add(\"\
    Test\")\n</cell>\n<code language=julia-1.5>\n@test parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3]\n</cell>\n<text>\nThe function below\
    \ will parse a series of nested parentheses and return their level count (integer).\n\
    \    E.g. input \"(()()) ((())) () ((())()())\" returns [2, 3, 1, 3]\n    \n \
    \   >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n\
    \    \"\"\"", "    paren_string = paren_string[1:end] // strip left paren and\
    \ newline\n    paren_string = replace(paren_string, \"\\n\", \"\") // strip newline",
  "    stack = Vector{Int64}(0)\n    \n    for paren in paren_string\n        if paren\
    \ != \"(\"\n            push!(stack, paren)\n        else \n            while\
    \ length( stack ) > 0\n                pop!(stack)\n            end\n        \
    \    push!(stack, -1)\n        end\n    end\n    \n    stack\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert parse_nested_parens(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3]\n</cell>\n<text>\nExercise: Implement the function count_nested_parens(paren_string::String)::Int\
    \ that takes input a string of parenthesis groups and returns the number of nested\
    \ parentheses. You should use a recursive function.", "\"\"\"\nParse a parenthesis\
    \ string to a vector of integers representing \ndeepest levels of parenthesis\
    \ nesting.", "     paren_string <- (\"(\" <:< \")\")\n     max_depth = 0\n   \
    \  paren_depth = 0\n     stack = []\n     for char in paren_string\n         if\
    \ char in paren_string \n             if paren_string =~ \"[()](\\s)\"\n     \
    \            paren_depth += 1\n                 if paren_depth > max_depth\n \
    \                    max_depth = paren_depth\n             else\n            \
    \     paren_depth = 0\n         elseif char in paren_string\n             paren_depth\
    \ += 1\n             if paren_depth > max_depth\n                 max_depth =\
    \ paren_depth\n         elseif char == \"(\"\n             stack = []\n      \
    \       paren_depth += 1\n             if paren_depth > max_depth\n          \
    \       max_depth = paren_depth\n         elseif char == \")\"\n             paren_depth\
    \ -= 1\n             if paren_depth < 0\n                 error(\"Unbalanced parentheses\"\
    )\n         else\n             error(\"Unexpected character: \" <: char)", " \
    \   # Parsing the string and extracting the nested parens count.\n    # If the\
    \ string does not contain any nested parens, return 0 as nesting depth.\n    #\
    \ If a string contain nested parens but is not balanced, return 0.\n    # If the\
    \ string contain nested parens but are balanced, return depth of nesting.\n  \
    \  # e.g Input: (()())\n    # Output: [1, 1, 0]\n    paren_array = [0 for _ in\
    \ paren_string]\n    function is_balanced(paren_array::Vector{Int64})::Bool\n\
    \        stack = Vector{Int64}()\n        for paren_pos in paren_array\n     \
    \       push!(stack, paren_pos)\n            while isempty(stack) || paren_array[stack.last()]\
    \ != paren_pos\n                pop!(stack)\n                if isempty(stack)\n\
    \                    return true\n                end\n            end\n     \
    \       pop!(stack)\n        end\n        return false\n    end\n    while !isempty(paren_string)\n\
    \        paren_pos = paren_string.findfirst(\" \")\n        if paren_pos == nothing\n\
    \            return paren_array\n        end\n        paren_end = paren_string.find(\"\
    \ \", paren_pos + 1)\n        if paren_end == nothing\n            paren_array[1]\
    \ = paren_pos - 1\n            return paren_array\n        end\n        paren_array[2]\
    \ = paren_pos - 1\n        paren_array[paren_pos - 1] = paren_end\n        paren_string\
    \ = paren_string[paren_end + 1 :]\n    end\n    if is_balanced(paren_array)\n\
    \        return paren_array\n    else\n        return paren_array\n    end\nend\n\
    \"\"\"\n    parse_paren_string(string::String)::Vector{Int64}\n    \"\"\"\n  \
    \  Parens_depth::Int64 = parse_nested_parens(string)\n    # Creating a dictionary\
    \ that maps parentheses position to nested parens depth.\n    # e.g Input: (()())\n\
    \    # Output: [1, 1, 0]\n    parens_dict = Dict{Int, Int}(parens_depth...=>1)\n\
    \    while parens_dict.length>0\n        key = parens_dict.keys[end]\n       \
    \ parens_dict[key] += 1\n        parens_dict[key] += 1\n        parens_dict[key]\
    \ -= 1\n        if parens_dict[key] == 0\n            parens_dict.pop(key) \n\
    \        end\n    end\n    return parens_dict\nend\n</cell>\n<code language=julia-1.6>",
  "    paren_str::String = paren_string\n    paren_str::Char = \"()\"\n    parens\
    \ = paren_string.chars\n    opening_parens = findall(parens, paren_str) \n   \
    \ max_length = maximum(lengths(opening_parens))\n    levels = [0 for i in 0:max_length]\n\
    \    for paren in parens\n        if paren == paren_str\n            levels[parens.index(paren)]\
    \ += 1\n        else if paren == \"(\"\n            levels[parens.index(paren)]\
    \ -= 1\n        else if paren == \")\"\n            levels[parens.index(paren)]\
    \ += 1\n        end\n    end\n    return levels\nend\n</cell>\n<text>\nTest cases",
  "        parse_nested_parens(paren_string, Vector{Int64}())\nend\n</code>\n<|/ a\
    \ |>\n<| a tags=string,julia |>\nOne liner using regex:\n<code>\njulia> using\
    \ Regex, BenchmarkTools", "    stack = 0\n    open_bracket_levels = Int64[]\n\
    \    close_bracket_levels = Int64[]\n    for ch in paren_string\n        if ch\
    \ == '('\n            stack += 1\n            open_bracket_levels.push(stack)\n\
    \        elseif ch == ')'\n            stack -= 1\n            close_bracket_levels.push(stack)\n\
    \        elseif ch == '()'\n            if stack == 0\n                push!(open_bracket_levels,\
    \ -1)\n                push!(close_bracket_levels, -1)\n            elseif stack\
    \ == 1\n                push!(open_bracket_levels, stack)\n                push!(close_bracket_levels,\
    \ stack)\n            else\n                push!(open_bracket_levels, stack)\n\
    \            end\n        end\n    end\n    \n    open_bracket_levels_max_value\
    \ = maximum(open_bracket_levels)\n    close_bracket_levels_max_value = maximum(close_bracket_levels)\n\
    \    \n    num_open_bracket_levels = open_bracket_levels_max_value + 1\n    num_close_bracket_levels\
    \ = close_bracket_levels_max_value + 1\n    \n    stack_count = zeros(Int64, num_open_bracket_levels)\n\
    \    stack = open_bracket_levels\n    \n    push_open_bracket_levels = 0\n   \
    \ push_close_bracket_levels = 0\n    for ii = num_open_bracket_levels:-1:1\n \
    \       stack_count[stack[ii]]+=1\n        if stack[ii] == 1\n            push_open_bracket_levels\
    \ += 1\n        else\n            push_open_bracket_levels -= 1\n        end\n\
    \        stack[ii] = stack_count[stack[ii]]\n    end\n    for ii = num_close_bracket_levels:-1:1\n\
    \        stack_count[stack[ii]]+=1\n        if stack[ii] == 0\n            push_close_bracket_levels\
    \ += 1\n        else\n            push_close_bracket_levels -= 1\n        end\n\
    \        stack[ii] = stack_count[stack[ii]]\n    end\n    \n    open_parens =\
    \ zeros(Int64, num_open_bracket_levels + num_close_bracket_levels)\n    close_parens\
    \ = zeros(Int64, num_open_bracket_levels + num_close_bracket_levels)\n    \n \
    \   push_close_bracket_levels = 0\n    push_open_bracket_levels = 0\n    for ii\
    \ = num_open_bracket_levels:-1:1\n        open_parens[push_open_bracket_levels:push!(open_parens,\
    \ stack[ii]), ii] = 1\n"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
