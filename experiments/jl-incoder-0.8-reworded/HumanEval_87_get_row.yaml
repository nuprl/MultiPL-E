name: HumanEval_87_get_row
language: jl
prompt: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n  \
  \  which is similar to matrix, however, unlike matrices,\n    each row may contain\
  \ a different number of columns.\n    Given lst, and integer x, find integers x\
  \ in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
  \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort\
  \ coordinates initially by rows in ascending order.\n    Also, sort coordinates\
  \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
  \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
  \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
  \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
  \ x::Int64)::Vector{Tuple{Int64, Int64}} \n"
tests: "using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
  \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
  \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
  \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
  \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
  \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
  \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0),\
  \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
  \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
  \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
  \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
completions: ["    return sortperm(sortperm(lst...), x) == x ? lst[sortperm(lst)]\
    \ : [((sortperm(lst)[x],sortperm(lst)[x+1]),(x,sortperm(lst)[x+1])...)]\nend",
  "    if lst.length ==0\n        return []\n    else\n        res = []\n        \n\
    \        for index in 1:length(lst.last)\n            if lst[index][x] == x\n\
    \                push!(res, Tuple(x, index))\n            end\n        end\n \
    \       \n        res\n    end\nend", "    if length(lst.[x .+ 1]) > length(lst.[x\
    \ - 1])\n        append!(result, get_row(lst[x], x))\n    else\n        append!(result,\
    \ get_row(lst[x], x - 1))\n    end", "    sortedInt = sort(Int64, lst)\n    for\
    \ i = 1:length(sortedInt)\n        row = i\n        column = 0\n        while\
    \ row > 0 && sortedInt[row][column] != x\n            column = column + 1\n  \
    \          row = row - 1\n        end\n        push!(result, (row, column))\n\
    \    end\n    \n    sortedRow = sort(Int64, result)\n    sortedCol = sort(Int64,\
    \ map(pair->pair[1], sortedRow))\n    \n    \n    \n    \n    for i =1:length(sortedCol)\n\
    \        row = sortedRow[i][1]\n        column = sortedCol[i]\n        push!(result,\
    \ (row, column))\n    end\n    \n    return result\nend", "    \n    if length(lst,\
    \ 1) < x\n        return ()\n    \n    rows = Vector{Tuple{Int64, Int64}}()\n\
    \    \n    for row in 1:size(lst, 1)\n        if lst[row][x]==x\n            push!(rows,\
    \ (x-row, row-1))\n        end\n    end", "    if !lst\n    else \n        indx\
    \ = searchsorted(lst[1], x) #find first index of x\n        sorted = sort(sortrows(lst),\
    \ rev=true) #sort by columns\n        if indx < length(sorted)\n            ((indx,\
    \ x), (indx, sorted[indx]))\n        else\n            []\n        end\n    end\n\
    end", "    ans = Vector{Tuple{Int64, Int64}}()\n    for r in lst\n        if r\
    \ contains x\n            append!(ans, (r[1], r[2]))\n        end\n    end\n \
    \   sort!(ans, by=first)\n    sort!(ans, by=last)\n    return ans\nend\n</cell>\n\
    <text>\nExercise 5\nWrite a function get_col(lst::Vector{Vector{Int64}}, x::Int64)::Vector{Tuple{Int64,\
    \ Int64}} that takes in a 2 dimensional data and returns the coordinate of x (a\
    \ tuple) in a vector as a tuple of tuples.", "    \"\"\"\n    get row\n    >>>\
    \ get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n \
    \   [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n\
    \    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    \n  \
    \  function get_row(lst::Vector{Vector{Int64}}, x::Int64)::Vector{Tuple{Int64,\
    \ Int64}} \n        if !length(lst) || x < 0 || x >= length(lst[1]) \n       \
    \     return [] \n        elseif x == length(lst[1])\n            return lst \n\
    \        else \n            get_row(lst[x, :], x-1) \n        end\n    end\n \
    \   \n    function get_row(lst::Vector{Vector{Int64}}, x::Int64)::Vector{Tuple{Int64,\
    \ Int64}} \n        if !length(lst) || x < 0 || x >= length(lst[1]) \n       \
    \     return [] \n        elseif x == length(lst[1])\n            return lst \n\
    \        else \n            get_row(lst[x, :], x-1) \n        end\n    end\n \
    \   \n    function get_row(lst::Vector{Vector{Int64}}, x::Int64)::Vector{Tuple{Int64,\
    \ Int64}} \n        if !length(lst) || x < 0 || x >= length(lst[1]) \n       \
    \     return [] \n        elseif x == length(lst[1])\n            return lst \n\
    \        else \n            get_row(lst[x, :], x-1) \n        end\n    end\n \
    \   \n    function get_row(lst::Vector{Vector{Int64}}, x::Int64)::Vector{Tuple{Int64,\
    \ Int64}} \n        if !length(lst) || x < 0 || x >= length(lst[1]) \n       \
    \     return [] \n        elseif x == length(lst[1])\n            return lst \n\
    \        else \n            get_row(lst[x, :], x-1) \n        end\n    end\n \
    \   \n    function get_row(lst::Vector{Vector{Int64}}, x::Int64)::Vector{Tuple{Int64,\
    \ Int64}} \n        if !length(lst) || x < 0 || x >= length(lst[1]) \n       \
    \     return [] \n        elseif x == length(lst[1])\n            return lst \n\
    \        else \n            get_row(lst[x, :], x-1) \n        end\n    end\n \
    \   \n    function get_row(lst::Vector{Vector{Int64}}, x::Int64)::Vector{Tuple{Int64,\
    \ Int64}} \n        if !length(lst) || x < 0 || x >= length(lst[1]) \n       \
    \     return [] \n        elseif x == length(lst[1])\n            return lst \n\
    \        else \n            get_row(lst[x, :], x-1) \n        end\n    end\n \
    \   \n    function get_row(lst::Vector{Vector", "    sorted_lst = sort(lst, by=\"\
    row\")\n    sorted_lst = reverse(sorted_lst, by=\"column\")\n    \n    index =\
    \ find_index(sorted_lst, x)\n    index_tuple = Tuple{Int64, Int64}(index, index)\n\
    \    \n    index_tuples = sort(index_tuple, by=\"row\")\n    index_tuples = reverse(index_tuples,\
    \ by=\"column\")\n    \n    return index_tuples\nend", "        where {Int64,\
    \ Vector{Int64}} = lst\n    \n        lst = sort(lst, by = x => descending(x)[1],\
    \ by = x => descending(x)[2])\n        \n        return collect(zip(0:size(x)-1,\
    \ x)) \n            \nend\n    ", "    \n    return Vector{Tuple{Int64, Int64}}(\n\
    \        Tuple{Int64, Int64}((i, length(lst[i]) - find(x => x == lst[i][i], 0,\
    \ length(lst[i])))) for i=1:length(lst)\n    )\nend", "    lst1 = lst.sort! \n\
    \    lst2 = sort(lst1, desc=true)\n    \n    zipped_list = zip(lst1, lst2) \n\
    \    row = get_row(zipped_list, x) \n    \n    return row(0) \nend\nget_row([],\
    \ x) = empty(x==0 ? 0 : error(\"not defined!\"))", "    if x == 1\n        return\
    \ [(i, 0) for i in lst]\n    end\n    \n    rows, cols = get_row(lst[1:end-1],\
    \ x-1) \n    \n    for (i, _) in cols\n        x = lst[i]\n        y = 0\n   \
    \     for j in cols\n            if j == i\n                y += x\n         \
    \   end\n        end\n        rows[i] = (i, y)\n    end\n    return rows\nend",
  "    if length(lst.ndims) != 2\n        throw(DimensionMismatch(\"Given vector is\
    \ not 2D, expect len(lst) to be 2\"))\n    end\n    rows, cols = lst\n    \n \
    \   # Sorting rows by rows in ascending order.\n    rows = sort(rows)\n    \n\
    \    # Sorting columns by columns in descending order.\n    cols = sort(cols,\
    \ rev=true)\n    \n    # Finding x by comparing rows with x from rows[1..end]\
    \ with x from rows[end+1..end]\n    idx = findfirst(x->x === rows[end], x::Int64)\n\
    \    if idx == 0\n        # x is found at 0th row \n        return [Tuple(rows[i],\
    \ cols[i]) for i in Iterators.reverse(1:end)]\n    elseif idx == length(rows)\n\
    \        # x is found at the last row \n        return [Tuple(rows[i], cols[i])\
    \ for i in Iterators.reverse(1:end)]\n    else\n        # x is found somewhere\
    \ in the middle\n        start = end - 1\n        stop = findfirst(x->x === rows[end],\
    \ x::Int64) - 1\n        return [Tuple(rows[i], cols[i]) for i in Iterators.range(start,\
    \ stop)]\n    end\nend\n</cell>\n<text>\nImplement the is_row_sorted function\
    \ in Julia to verify your results.", "    rows, cols = size(lst)\n    coord_lst\
    \ = []\n    for row in 1:rows\n        for col in 1:cols\n            if lst[row,\
    \ col] == x\n                push!(coord_lst, (0, row, col))\n            end\n\
    \        end\n    end\n    coord_lst = sort(coord_lst, by=(a, b) -> b[2] <=> a[2])\n\
    \    coord_lst = reverse(coord_lst)\n    return coord_lst\nend\n</cell>\n<text>\n\
    Expected Output:", "    if length(lst)==0 \n        return [] \n    end\n    rows\
    \ = sort(unique(reduce(hcat, lst))) # sort rows in ascending order\n    col =\
    \ sort(unique(reduce(hcat, reduce(vcat, lst)))) # sort columns in descending order\n\
    \    \n    rows = Array{Int64, 1}(undef, length(lst)) \n    for j in rows \n \
    \       rows[findall(j <= col,j)] = j \n    end\n    \n    return vcat( map( x\
    \ -> x, (rows,cols) ) )\nend", "    \n    if length(lst) == 0 || x == 0 || x >=\
    \ length(lst[1])\n        return Vector{Tuple{Int64, Int64}}()\n    else\n   \
    \     indices = Vector{Int64}()\n        indices[] = x\n        \n        index_of_x\
    \ = Vector{Int64}()\n        index_of_x[] = 1\n        \n        number_of_rows_lst\
    \ = length(lst)\n        \n        lst1 = lst[1:number_of_rows_lst, :]\n     \
    \   for i = 2:number_of_rows_lst\n            for j = (1:length(lst[i]))\n   \
    \             if lst[i][j] == x\n                    index_of_x[i] = j\n     \
    \           end\n            end\n        end\n        \n        row_indices =\
    \ index_of_x\n        column_indices = indices[index_of_x]\n        \n       \
    \ return [(row_indices, column_indices)]\n    end\nend", "    if x == 0\n    \
    \    return Vector{Tuple{Int64, Int64}}()\n    else if x < 0\n        error(ArgumentError(\"\
    x must be non-negative\"))\n    end\n    \n    if length(lst) == 0 \n        return\
    \ Vector{Tuple{Int64, Int64}}()\n    else\n        row = Vector{Tuple{Int64, Int64}}()\n\
    \        \n        if x > 0\n            for (i, col) in enumerate(reverse(lst))\n\
    \                if col[x] == x\n                    push!(row, (i, col[x]))\n\
    \                end\n            end\n        else\n            for (i, col)\
    \ in enumerate(lst)\n                if col[x] == x\n                    push!(row,\
    \ (i, col[x]))\n                end\n            end\n        end\n        \n\
    \        row\n    end\nend\n</cell>\n<text>\nPart 2\nTask 2.1:\nGiven a nested\
    \ vector, determine if it is a convex hull.\nThe convex hull of a point is a set\
    \ of points separated by no other points in the set.\nFor example, a convex hull\
    \ of a point {1, 2} is a point {1, 2}, {2, 1}, {1, 3}, {2, 3}, {3, 1}.", "   \
    \ \n    lst = sort(lst)\n    \n    result = Vector{Tuple{Int64, Int64}}()\n  \
    \  \n    for r1 in 1:size(lst, 1)\n        for c1 in 1:size(lst[r1], 1)\n    \
    \        \n            if lst[r1][c1] == x\n                push!(result, (1 +\
    \ r1, 1 + c1))\n            end\n        end\n    end\n    \n    result = sort(result,\
    \ reverse=true)\n    \n    return result\nend", "    vecs = [(r, c) for r in lst[:,\
    \ 1] for c in lst[:, 2] if r==x]\n    vecs = [(r, c) for r in sort(vecs) collect((r,\
    \ c)) |> sortperm]\n    \n    vecs = vecs[vecs ~= [(0,0)]] \n    vecs = [(r, c)\
    \ for (r, c) in vecs]\n    vecs = [(r, c) for (r, c) in sort(vecs) collect((r,\
    \ c)) |> sortperm]\n    \n    return vecs\nend\n</code>\n<|/ a tags=vectorization,julia,matrix\
    \ |>\n<| a |>\nYou can use filter! for this. The idea is to iterate through all\
    \ columns of the matrix and check if the element at the row index is equal to\
    \ the given value then it is added to the new matrix. Here is an example:\n<code>",
  "    # your code\nend\n</cell>\n<code language=julia-0.6>", "    if lst.length ==\
    \ 0\n        return Vector{Tuple{Int64, Int64}}([])\n    else\n        coordinates\
    \ = zeros(Int64, 2, 2)\n        coordinates[1] = sort_by_column(sort_by_row(lst),\
    \ x, ascending=true)\n        coordinates[2] = sort_by_column(sort_by_row(lst),\
    \ x, ascending=false)\n        return coordinates\n    end\nend\n\"\"\"\n    You\
    \ are given a two dimensional data, as a nested vectors,\n    which is similar\
    \ to matrix, however, unlike matrices,\n    each column may contain a different\
    \ number of rows.\n    Given lst, and integer x, find integers x in the vector,\n\
    \    and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n    each\
    \ tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates\
    \ initially by columns in descending order.\n    Also, sort coordinates of the\
    \ column by rows in ascending order.\n    \n    Examples:\n    >>> get_col([[1,\
    \ 2], [], [3, 4, 5]], 3)\n    [(0, 0), (0, 2), (2, 0), (2, 1)]\n    >>> get_col([[],\
    \ [], []], 2)\n    [(0, 0), (1, 1)]\n    >>> get_col([[1, 2], [], [3, 4, 5]],\
    \ 0)\n    [(0, 0), (0, 2), (2, 0), (2, 1)]\n    >>> get_col([[]], 0)\n    []\n\
    \    \"\"\"", "    v = zeros(Int, length(lst))\n    for ix in ind2subv(size(lst),\
    \ x)\n        v[ix] = (x == ix) ? 1 : 0\n    end\n    # row = [i for i in eachindex(lst)\
    \ if v[i] == 1]\n    row = [i for i in eachindex(lst) if v[i] == 1]\n    coordinates\
    \ = [i for i in eachindex(lst) if v[i] == 1]\n    # sort!(row, by=desc)\n    sort!(coordinates,\
    \ by=desc)\n    return coordinates\nend", "    rows = sort(unique(transpose(x)).+0)\n\
    \    cols = sort(unique(transpose(x))[2:end-2]); cols = reverse(cols);\n    result\
    \ = []\n    for i in rows\n        js = find(x .== i);\n        push!(result,\
    \ (i,js[js..end]))\n    end\n    result\nend\n</code>\n<|/ a tags=tuples,vector,arrays,julia\
    \ |>\n<| c |>\nThanks! I got stuck when thinking about it. However, I tested this\
    \ with two more examples (`get_row([[1], [1, 2], [1, 2, 3]], 1)` and `get_row([[1],\
    \ [1, 2, 3], [2, 3]], 1)` ), and it's also wrong. Can you fix it?\n<|/ c |>\n\
    <| c |>\nIt seems that `unique(x[2:end-2])` only returns unique elements. For\
    \ example, for `[[1], [1, 2, 3], [2, 3]]`, the output would only be `[2]`, but\
    \ I think it should return `[1, 2]`.\n<|/ c |>\n<| a dscore=2 |>\nThis answer\
    \ uses mapslices and a comprehension (rather than filter).\n<code>\njulia> x =\
    \ Vector{Vector{Int}}([Vector{Int}([1, 2, 3, 4]), Vector{Int}([1, 2]), Vector{Int}([3,\
    \ 4, 5])])\n3-element Vector{Vector{Int64}}:\n [1, 2, 3, 4]\n [  1,     2]\n [\
    \  3,     4]\njulia> mapslices(i -> [i .!= last(i), i], last, x, 1)\n2-element\
    \ Array{Array{Bool,1},1}:\n [true false]\n [true  true]", "    \n    rows = zeros(Int64,\
    \ size(lst, 1), 0)\n    rows = sort(rows, 1)\n    rows = reverse(rows)\n    \n\
    \    columns = zeros(Int64, size(lst, 0), 0)\n    columns = sort(columns, 2)\n\
    \    columns = reverse(columns)\n    \n    indices = findall(x .== rows[:, 1])\n\
    \    \n    return collect(zip(repeat(x), map((y) -> (rows[:, 2], y), indices)))\n\
    end", "    if length(lst) == 0\n        []\n    elseif length(lst) == 1\n    \
    \    [(x, 0)]\n    elseif x > length(lst[1])\n        [(x, 1)]\n    else\n   \
    \     inds = findfirst(x->x==x, lst[1])\n        if inds == 1\n            tuples\
    \ = get_row(lst[2], x-inds)\n            tuples_sorted = sort(tuples, by=(2, 1),\
    \ rev=true)\n            return tuples_sorted\n        else\n            tuples\
    \ = get_row(lst[2], inds-1) + [(inds, x)]\n            tuples_sorted = sort(tuples,\
    \ by=(2, 1), rev=true)\n            return tuples_sorted\n        end\n    end\n\
    end\nget_row(x::Vector{Vector{Int64}}) = \n    get_row(x, length(sort(collect(eachrow(typeof(x))),\
    \ by=last)))", "    i = -1\n    result = []\n    for el in lst\n        i += 1\n\
    \        if i == x\n            result = [(el[1], el[2])]\n        end\n    end\n\
    \    return result\nend\n</cell>\n<code language=julia-1.5>", "    i, j = 0, 0\n\
    \    answer = []\n    while j < length(lst[i])\n        if x == lst[i][j]\n  \
    \          push!(answer, (i, j))\n        end\n        j += 1\n    end\n    for\
    \ m in range(length(answer)-1)\n        answer[m] = answer[m], answer[m+1]\n \
    \   end\n    answer = sort(answer)\n    return answer\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\n    Problem 2 \n    \n    Find the smallest matrix such that when added\n\
    \    to another matrix, the result of addition equals k\n    \n    INPUT:\n  \
    \  \u2022   A matrix\n    \u2022   A number k\n    \n    OUTPUT:\n    \u2022 \
    \  The smallest matrix such that\n    \u2022   when added to another matrix,\n\
    \    \u2022   the result of addition equals k\n    \n    Examples:\n    >>> get_smal_matrix([[6,\
    \ 8], [2, 4]], 6)\n    [[6, 8], [2, 4]]\n    >>> get_smal_matrix([[], [1], [2,\
    \ 3]], 3)\n    [[2, 2]]\n\"\"\"", "    row = Vector{Tuple{Int64, Int64}}()\n \
    \   \n    # sort by rows\n    idx = findfirst(x->x==x, lst)\n    if idx == ntuple(row;\
    \ ndims=1) \n        row\n    else\n        for r in lst[idx+1:end]\n        \
    \    if r == x\n                push!(row, (r[1], idx))\n            end\n   \
    \     end\n    end\nend\n</code>\n<|/ a |>\n<| c |>\nThanks, I added the function\
    \ `get_row` which returns the desired result.\n<|/ c |>\n<| c |>\nYour solution\
    \ was very helpful in finding my bug. :)\n<|/ c |>\n<| a dscore=1 |>\nI figured\
    \ out this solution from another StackOverflow post that suggested using mapslices.\
    \ I'm posting it here for future reference. \n<code>", "    # check if input is\
    \ empty\n    if length(lst) == 0 \n        return [] \n    \n    # check if input\
    \ contains one row only\n    if length(lst) == 1\n        return lst[[1]][[findfirst(x\
    \ == lst[[1]], 1)]] \n    end", "    if lst.length == 0\n        return Vector{Tuple{Int64,\
    \ Int64}}()\n    end\n    \n    rows = sort(unique(reduce(vcat, map(x -> get(lst,\
    \ x), range(0, lst.length)))))\n    cols = sort(unique(reduce(vcat, map(x -> get(lst,\
    \ x), range(lst.length, length(lst)))))) \n    \n    row2col = vcat(rows, cols)\n\
    \    col2row = vcat(cols, rows)\n    \n    result = Vector{Tuple{Int64, Int64}}()\n\
    \    for i in rows\n        row = vcat(get(lst, row2col[i]), get(lst, row2col[i]))\n\
    \        for j in cols\n            if getindex(row, j) == x\n               \
    \ push!(result, (i2j(row2col[i], j), i2j(row2col[i], j)))\n                break\n\
    \            end\n        end\n    end\n    return result\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    z = sort(lst)\n    if length(z[end]) <= x\n     \
    \   z = z[1:end]\n    end\n    z = sort(z, desc=true)\n    z = z[:, end:-1:1]\n\
    \    return collect(zip(z, range(size(z)[2]))) # to make sure each coordinate\
    \ is starting with 0\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    You\
    \ are given a 2 dimensional data, as a nested vectors,\n    which is similar to\
    \ matrix, however, unlike matrices,\n    each row may contain a different number\
    \ of columns.\n    Given lst, and integer x, find integers x in the vector,\n\
    \    and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n    each\
    \ tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates\
    \ initially by rows in ascending order.\n    Also, sort coordinates of the row\
    \ by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"", "    n = length(lst)\n    \n\
    \    coords = Vector{Tuple{Int64, Int64}}()\n    \n    for i = 0:n-1\n       \
    \ append!(coords, (i, get_col(lst[i], x)))\n    end\n    \n    coords = sort!(coords)\n\
    \    coords = reverse(coords)\n    \n    return coords\nend", "    if lst.size\
    \ == 0\n        []\n    elseif lst.size < x\n        error(\"get_row: x is larger\
    \ than number of elements in lst\")\n    elseif x <= 0\n        error(\"get_row:\
    \ x is negative\")\n    elseif x > lst.size\n        error(\"get_row: x is too\
    \ big for lst\")\n    else\n        sort_by_row(lst, x, y)\n        sort_by_col(lst,\
    \ x, y)\n    end\nend", "    rows, cols = size(lst)\n    res = []\n    for row\
    \ in 1:rows\n        row_coord = Tuple(row(cols-1)+1, cols-1+row(cols-1)>x)\n\
    \        res.append(row_coord)\n    end\n    sort(res)\n    return res\nend",
  "    # write your code here\n    \n    return []\nend\n</cell>\n<text>\nSolution\n\
    Solution", "    lst = lst.sort!\n    idx = 1\n    \n    row = Vector{Tuple{Int64,\
    \ Int64}}()\n    \n    for col in lst \n        if col .== x \n            row\
    \ = [Tuple(row[1], col[1])]\n        else\n            row = [(idx, idx)] + row\n\
    \            idx += 1\n        end\n    end\n    row\nend\n</cell>\n<text>\nLet's\
    \ check our function with examples.", "    ans = [(0,0)]\n    for row in lst\n\
    \        for col in row\n            if col == x\n                push!(ans, (row(row),\
    \ col))\n            end\n        end\n    end\n    ans\nend", "    if lst==[]\
    \ || lst==[[]]\n        return Vector{Tuple{Int64, Int64}}()\n    \n    rows=\
    \ length(lst)\n    col = length(lst[1])\n    \n    idx = Int64(0)\n    res = []\n\
    \    \n    for  i \u2208 1:rows\n        if lst[i] \u2260 []\n            idx\
    \ = idx + 1\n            lst = lst[i]\n            break\n        end\n    end\n\
    \    \n    for i \u2208 1:col\n        if lst[idx] == x\n            push!(res,\
    \ (i,idx))\n            idx+=1\n        end\n    end\n    \n    return res\nend\n\
    </cell>\n<code language=julia-1.5>\n\"\"\"\n    You are given an arbitrary matrix\
    \ A.\n    Find all elements of A that satisfy a condition, \n    and return their\
    \ indices.\n    For example, given A = [0 1 0; 1 0 0], [1, 0], [2], return [2,\
    \ 0]\n\"\"\"", "    return sort(map(x -> (x, x), filter(x -> x > 0, lst)))\nend",
  "    for r = 0:length(lst)-1\n        for c = 0:length(lst[r])-1\n            if\
    \ lst[r][c] == x\n                tup = (r, c)\n                return tup\n \
    \           end\n        end\n    end\n    return []\nend\n</code>\n<|/ a dscore=1\
    \ tags=julia |>\n<| a tags=julia |>\nThe code below does the same thing as Josh's\
    \ answer. \n<code>", "    # O(n^2), n is length of list\n    # O(n), n times number\
    \ of columns in each row\n    # O(logn), n log n\n    # O(n), n is length of list\n\
    \    row = Int64[]\n    col = 0\n    for x in lst\n        if x==x\n         \
    \   push!(row, col)\n        else\n            push!(row, -1)\n        end\n \
    \       col += 1\n    end\n    return sort([row], by=x->x[2], rev=true)\nend\n\
    </code>\nAnd here's one that sorts the coordinates initially by columns in descending\
    \ order, using zip() to transpose the input:\n<code>", "    lst = sort(lst)\n\
    \    idxs = get_idxs(lst, x)\n    lst = lst[idxs]\n    lst = sort(lst)\n    idxs\
    \ = fliplr([idxs; idxs + size(lst)[2]])\n    return lst[idxs]\nend", "    lst\
    \ = sort(lst)\n    col = length(lst[1])\n    idx = findfirst(x -> x == lst[1][i],\
    \ 1:col)\n    lst = sort(lst)\n    \n    idx = length(lst[2]) + idx\n    lst =\
    \ sort(lst)\n    \n    idx = length(lst[1]) + idx\n    \n    lst = sort(lst)\n\
    \    \n    idx = length(lst[1]) + idx\n    \n    lst = sort(lst)\n    \n    idx\
    \ = length(lst[1]) + idx\n    \n    lst = sort(lst)\n    \n    idx = length(lst[1])\
    \ + idx\n    \n    lst = sort(lst)\n    \n    idx = length(lst[1]) + idx\n   \
    \ \n    lst = sort(lst)\n    \n    idx = length(lst[1]) + idx\n    \n    lst =\
    \ sort(lst)\n    \n    idx = length(lst[1]) + idx\n    \n    lst = sort(lst)\n\
    \    \n    idx = length(lst[1]) + idx\n    \n    lst = sort(lst)\n    \n    idx\
    \ = length(lst[1]) + idx\n    \n    lst = sort(lst)\n    \n    idx = length(lst[1])\
    \ + idx\n    \n    lst = sort(lst)\n    \n    idx = length(lst[1]) + idx\n   \
    \ \n    lst = sort(lst)\n    \n    idx = length(lst[1]) + idx\n    \n    lst =\
    \ sort(lst)\n    \n    idx = length(lst[1]) + idx\n    \n    lst = sort(lst)\n\
    \    \n    idx = length(lst[1]) + idx\n    \n    lst = sort(lst)\n    \n    idx\
    \ = length(lst[1]) + idx\n    \n    lst = sort(lst)\n    \n    idx = length(lst[1])\
    \ + idx\n    \n    lst = sort(lst)\n    \n    idx = length(lst[1]) + idx\n   \
    \ \n    lst = sort(lst)\n    \n    idx = length(lst[1]) + idx\n    \n    lst =\
    \ sort(lst)\n    \n    idx = length(lst[1]) + idx\n    \n    lst = sort(lst)\n\
    \    \n    idx = length(lst[1]) + idx\n    \n    lst = sort(lst)\n    \n    idx\
    \ = length(lst[1]) + idx\n    \n    lst = sort(lst)\n    \n    idx = length(lst[1])\
    \ + idx\n    \n    lst = sort(lst)\n    \n    idx = length(lst[1]) + idx\n   \
    \ \n    lst = sort(lst)\n    \n    idx = length(lst[1]) + idx\n    \n    lst =\
    \ sort(lst)\n    \n    idx = length(", "  \n    if length(lst) == 0 || x < 0 ||\
    \ x >= length(lst[1])\n        return Tuple[]\n    end\n    \n    coords = Vector{Tuple{Int64,\
    \ Int64}}[]\n    i = 2\n    append!(coords, (0, 0))\n    while i <= length(lst)\n\
    \        if lst[i] >= x && lst[i] < x\n            append!(coords, (i,))\n   \
    \     end\n        i += 1\n    end\n    \n    sort!(coords, rev=true)\n    sort!(coords,\
    \ rev=false)\n    \n    return coords\nend", "    lst = copy(lst)\n    if length(lst\
    \ .- x[1]) > length(lst) - x[1] \n        return sort(Tuple(x[1], 0))\n    else\
    \ \n        return sort(Tuple(x[1], 0))\nend", "    \n    \"\"\" Returns a row,\
    \ starting from 0, of x, which starts with 0 in each row \"\"\"\n    \n    \n\"\
    \"\" \n    Returns a column of x, starting from 0, of lst, which starts with 0\
    \ in each column \n    \n    Time complexity O(len(lst))\n    \"\"\"", "    row\
    \ = Vector{Tuple{Int64, Int64}}(undef, 0)\n    \n    for i in length(lst, 1)\n\
    \        push!(row, (x[i], i)) # column index i and row index x[i]\n    end\n\
    \    \n    # Sort coordinate initially by rows in ascending order.\n    sort_by(row\
    \ -> row[1], lst)\n    \n    # Sort coordinates of the row by columns in descending\
    \ order.\n    sort_by(row -> row[2], reverse(lst))\n    \n    return row\nend\n\
    </cell>\n<text>\nThe get_col() function\nThe get_col() function takes two arguments:\
    \ a nested vector as input and an integer as input.\nThe function must return\
    \ a list of tuples, [(col_1, row_1), (col_2, row_2) ...], such that the tuples\
    \ represent the coordinates of each column.\nThe columns are sorted in ascending\
    \ order initially, and then descending order in each row.\nThe function should\
    \ work for both 1D and 2D nested vectors.\nFor 1D vectors, the first index is\
    \ the column and the second index is the row.\nFor 2D vectors, the first index\
    \ is the column and the second index is the row.\nIf any of the coordinates are\
    \ out of range, the function should return an empty list.", "    \n    if length(lst)\
    \ == 0 || x == 0\n        return []\n    end\n    \n    A = Array{Tuple{Int64,\
    \ Int64}}(undef, length(lst), length(lst[1]))\n    for r = 0:length(lst) - 1\n\
    \        for c = 0:length(lst[r]) - 1\n            A[r, c] = (lst[r][c], c)\n\
    \        end\n    end\n    \n    idx = findall(x -> x == A[:, 2], A[:, 2])\n \
    \   idx = sort(idx, by = x -> -x[1])\n    idx = idx[length(idx)]\n    \n    idx\
    \ = sort(idx, by = x -> x[1]) \n    \n    ans = [(i, j) for i in idx, j in idx[idx,\
    \ 1:end-1]]\n    \n    return ans\nend\n</cell>\n<code language=julia-1.5>", " \
    \   # Your code here\n    # lst contains rows and each row contains columns. \n\
    \    # Each row may contain different number of columns. \n    \n    # Sort each\
    \ row initially by columns in descending order\n    \n    # Sort the row by columns\
    \ in ascending order\n    \n    # Sort the coordinates initially by rows in ascending\
    \ order\n    \n    # Sort the coordinates initially by columns in descending order\n\
    \    \n    # Your code here\n    return coordinates\nend\n</cell>\n<text>\nPart\
    \ 2: Find the Index of a Given Point\nLet's consider a function which finds the\
    \ index of each element in a vector. We'll call this function in part 5.", " \
    \   result = []\n    for row in lst\n        if row[x] == 1\n            (x, y)\
    \ = findfirst(x -> x == 1, row)\n            push!(result, (x - 1, y))\n     \
    \   end\n    end\n    return result\nend\n</code>\n<|/ a |>\n<| c |>\nThis works\
    \ for the case you provided. But not for `get_row([], 1)` because there is no\
    \ row that satisfies the condition. `findfirst(x -> x == 1, row)` returns `nothing`\
    \ which causes an error when attempting to subtract 1 from the `x` value.\n<|/\
    \ c |>\n<| c |>\nThank you for pointing that out. I've fixed that bug (which was\
    \ really stupid...)\n<|/ c |>\n<| c |>\nYour solution works really well for the\
    \ case I provided. But when I tested it against the other solutions, I got an\
    \ answer of `[]`, which is incorrect. Could you help me to understand why? Here\
    \ is the link to the code: https://repl.it/repls/AvivialPragmaticMacrolanguage\n\
    <|/ c |>\n<| c |>\nI don't understand, if you run my code as is, you get the correct\
    \ answer of `[(0, 3), (1, 4), (2, 0), (3, 1), (4, 0), (5, 2)]`. If this doesn't\
    \ work for you, you should state your requirement more precisely.\n<|/ c |>\n\
    <| c |>\nI've added the link to the code. Please, run it if you can.\n<|/ c |>\n\
    <| a dscore=1 |>\nAs far as I understand from your question and code, you have\
    \ a two-dimensional array and you want to find the rows where the value of a certain\
    \ element satisfies the given condition. The following code does this:\n<code>\n\
    rows = []\nfor row in M\n  if row[x] == 1\n    push!(rows, x)\n  end\nend\n</code>\n\
    <|/ a tags=julia |>\n<| c |>\nThank you for your answer. Could you explain why\
    \ you use `push!(rows, x)` instead of `push!(rows, (x, y))`?\n<|/ c |>\n<| c |>\n\
    , `push!` will insert a pair to the array and return the new length of the array.\
    \ In this case, x is the index of the element that you are searching for. If you\
    \ do `push!(rows, (x, y))` you will push pairs of rows and columns that satisfy\
    \ the condition. But in this case, you only want the columns that are satisfied.\n\
    <|/ c |>\n<| c |>\nOh I see. I thought I should push it because my answer was\
    \ like `result = []; for x in xs; push!(result", "    if lst == [] return [] \n\
    \    \n    sorted_rows = get_row(sort(lst), 1)\n    \n    if x not in sorted_rows[end][1]\
    \ \n        \n        idx = end\n        while sorted_rows[idx][1][x] != x \n\
    \            idx -= 1\n            \n        return [(sorted_rows[idx][1], x)]\
    \ \n        \n    else \n        \n        idx = end\n        while sorted_rows[idx][1][x]\
    \ < x \n            idx -= 1\n            \n        return [(sorted_rows[idx][1],\
    \ x)] + get_row(sort(lst[idx]), x) \n    end\nend\n</cell>\n<code language=julia-0.6>",
  "    \n    \"\"\" Get a list of coordinates (row, columns) of integer x in the matrix\"\
    \"\"\n    \n    function get_row(lst::Vector{Vector{Int64}}, x::Int64)::Vector{Tuple{Int64,\
    \ Int64}} \n    \n        if length(lst) == 0\n            \n            if x\
    \ == 1\n                return []\n            else\n                return [(x,\
    \ 0)]\n            end\n        \n        elseif x == 1\n        \n          \
    \  row = 0\n            \n            sortedCoordinates = getrowsorted(lst)\n\
    \            \n            if sortedCoordinates == []\n                \n    \
    \            return [(row, 0)]\n            else\n                \n         \
    \       return [(row, x) for x in sortedCoordinates[row]]\n            end\n \
    \           \n        else\n            \n            row = 0\n            \n\
    \            sortedCoordinates = getrowsorted(lst)\n            \n           \
    \ if sortedCoordinates == []\n                \n                return [(row,\
    \ x) for x in sortedCoordinates[row]]\n            else\n                \n  \
    \              column = 0\n                \n                for coordinate in\
    \ sortedCoordinates[row]\n                    \n                    if coordinate\
    \ == x\n                        \n                        row = (row + 1)\n  \
    \                      \n                        column = (column + 1)\n     \
    \               \n                    else\n                        \n       \
    \                 row = (row + 1)\n                        \n                \
    \        column = (column + 1)\n                    \n                    end\n\
    \                \n                end\n                \n                return\
    \ [(row, column)]\n            end\n        end\n    end\n    \n    \"\"\" Get\
    \ a list of coordinates (row, columns) of integer x in the matrix\"\"\"\n    \n\
    \    function get_rowsorted(lst::Vector{Vector{Int64}})\n    \n        sortedCoordinates\
    \ = Int[]\n        \n        for row in lst\n            \n            sortedCoordinates\
    \ = vcat(sortedCoordinates, row)\n            \n        end\n        \n      \
    \  sortedCoordinates = sort!(sortedCoordinates, by=length(lst[end])) \n      \
    \  \n        return sortedCoordinates\n    end\n    \nend", "    \n    nr = size(lst)[1]\n\
    \    \n    if nr == 0 return []\n    if x == 0 return []", "    \n    result =\
    \ Vector{Tuple{Int64, Int64}}([])\n    for row in lst\n        if row.==x\n  \
    \          result.push((row.last+1, row.first+1))\n        end\n    end\n    \n\
    \    result.sort!((a, b) -> b[1][a[1]] <=> a[1][b[1]]) \n    \n    for row in\
    \ result\n        result.push((row.last+1, row.first+1))\n    end\n    \n    return\
    \ result\nend\n</cell>\n<code language=julia-1.2>", "    row = findfirst(x->x\
    \ in lst, x)\n    if row == -1\n        []\n    else\n        sorted_row = sort(row,\
    \ 1)\n        sorted_col = sort(sort(row), 1)\n        coord_lst = enumerate(zip(sorted_row,\
    \ sorted_col))\n        for (i, j) in coord_lst\n            sorted((i, j))\n\
    \        end\n    end\nend\n</cell>\n<text>\nProblem 6. Get column of a matrix",
  "    \n    # init empty list\n    ret = Vector{Tuple{Int64, Int64}}()", "    lst_sorted\
    \ = sort(lst)\n    row, col = 0, 0\n    \n    while row < lst_sorted[row].length\
    \ && lst_sorted[row][col] < x\n        row += 1\n    \n    while row < lst_sorted[row].length\
    \ && lst_sorted[row][col] == x\n        col += 1\n    \n    row = row-1\n    col\
    \ = col-1 \n    \n    result = []\n    while row > 0 && col < lst_sorted[row].length\n\
    \        result.push((row, col))\n        row -= 1\n        col += 1\n       \
    \ \n    sort(result)\n    return result\nend\n</cell>\n<code language=julia-1.0>",
  "    result = []\n    for element in lst \n        if element[x] == x\n        \
    \    push!(result, ((element[1], element[2]), (element[3], element[4])))\n   \
    \     end\n    end\n    sort(result) #sort by row\n    sort(result, by=last) #if\
    \ you want to sort by column\n    return result\nend\n</cell>\n<code language=julia-1.5>\n\
    get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n</cell>\n\
    <code language=julia-1.5>\nget_row([], 1)\n</cell>\n<code language=julia-1.5>\n\
    get_row([[], [1], [1, 2, 3]], 3)\n</cell>\n<text>\nProblem 4: Sum all values greater\
    \ than x in a matrix / Vector", "    coords = map(x -> Tuple(x, x), lst)\n   \
    \ coords.sort!(dims=2)\n    return coords\nend\n</cell>\n<code language=julia-1.4>\n\
    using Plots", "    if isa(x, Int64)\n        if x < 0\n            if x == 0\n\
    \                return []\n            else\n                return []\n    \
    \    end\n        \n        if x == 2\n            return [(1,length(lst)+1)]\n\
    \        end", "    \n    # Sorting rows initially by columns in ascending order\n\
    \    rows = sort_rows_first_by_columns(lst)\n    \n    # Sorting rows by columns\
    \ in descending order\n    rows = reverse!(rows)\n    \n    coords = Vector{Tuple{Int64,\
    \ Int64}}()\n    for row in rows\n        cols = get_columns(row, x)\n       \
    \ for col in cols\n            push!(coords, Tuple(row-1, col-1))\n        end\n\
    \    end\n    \n    sort_rows_second_by_columns(coords)\n    \nend\n</cell>\n\
    <code language=julia-1.5>", "    if length(lst) == 0, return Vector{Tuple{Int64,\
    \ Int64}}() else\n        rows = zeros(Int, length(lst))\n        columns = 0\n\
    \        for row in lst\n            columns = columns + row[x]\n            rows\
    \ = rows + 1\n        end\n        rows = rows + 1 \n        columns = columns\
    \ - 1\n        sort_rows_columns(lst, rows, columns)\n        index = find_index(lst,\
    \ rows, columns)\n        return collect(zip([(rows[index], columns[index]) for\
    \ row in lst], 0:length(rows)))\n    end", "    \"\"\"\n    Gets a row from the\
    \ given vector containing x and returns the coordinate\n    of each of the integers\
    \ in the row, starting from 0 in ascending order.\n    \n    Examples:\n    >>>\
    \ get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n \
    \   [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n\
    \    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    function\
    \ get_row(lst::Vector{Vector{Int64}}, x::Int64)::Vector{Tuple{Int64, Int64}} \n\
    \        inds = sort(unique(x))\n        row = []\n        for ii in inds \n \
    \           append!(row, zip(lst, ii))\n        end\n        return sort(row)\n\
    \    end\nend", "    l = length(lst) \n    \n    if l==0 \n        return [] \n\
    \    else \n        # sort rows and columns by rows in ascending order\n     \
    \   slst = sort(lst) \n        \n        # sort rows by columns in descending\
    \ order \n        slst2 = reverse(sort(sort(slst))) \n        \n        # find\
    \ first row  \n        idx = searchsorted(slst2[x], 0, less) \n        \n    \
    \    # find coordinates \n        coords = Tuple{Int64, Int64}[]\n        for\
    \ i=1:l \n            if x==slst[i][idx]  \n                coords = push!(coords,\
    \ (xi, yi)) \n                yi = yi + 1 \n            end \n            xi =\
    \ xi + 1 \n        end \n        \n        sort!(coords, reverse) \n        return\
    \ coords \nend ", "    if length(lst) < x\n        error(\"len(lst) should be\
    \ greater or equal to x\")\n    end\n    \n    a = zeros(Int64, length(lst, 1))\n\
    \    for i, v in enumerate(lst)\n        if v == x\n            a[i] = 1\n   \
    \     end\n    end\n    \n    b = reverse(reverse(a))\n    return zip(b, b)\n\
    end", "    tuples = [(x,i) for i=1:length(lst)] # tuples = [(row_index, column_index)]\n\
    \    tuples = filter((x)->(x[1] == x), tuples) # remove elements with same row\n\
    \    tuples = sortperm(tuples, rev=true) # sort by columns in descending order\n\
    \    tuples = sortperm(tuples) # sort by rows in ascending order\n    tuples =\
    \ filter((x)->(x[1] <= x), tuples) # remove elements with same row\n    tuples\
    \ = map((x)->(x[1], x[0]), tuples) # extract column and row index\n    return\
    \ tuples\nend\n</cell>\n<code language=julia-1.4>", "    i, j = 0, 0\n    row_index\
    \ = Vector{Tuple{Int64, Int64}}(undef, 0)\n    while j < length(lst[i])\n    \
    \    if lst[i][j] == x\n            row_index << Tuple{i, j}(i .. i, j .. j)\n\
    \            i += 1\n            j += 1\n        else\n            j += 1\n  \
    \      end\n    end\n    row_index\nend\n</cell>\n<code language=julia-1.5>",
  "    if lst == [] || x == 0\n    []\n    elseif lst == [[]] && (x == 0 || x == 1)\n\
    \    []\n    elseif lst == [[]]\n    []\n    elseif lst == [[1]]\n    []\n   \
    \ elseif lst == [[1, 2]]\n    [(0, 0)]\n    elseif lst == [[1, 2, 3]]\n    [(1,\
    \ 0), (2, 0), (3, 3)]\n    elseif lst == [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]]\n    if x > 0\n        sort!(lst)\n        sort!(lst)\n\
    \        rows = sort(lst[1], by=max)\n        cols = sort(lst[2], by=max)\n  \
    \  elseif x > 0\n        sort!(lst)\n        sort!(lst)\n        rows = sort(lst[1],\
    \ by=min)\n        cols = sort(lst[2], by=max)\n    elseif x > 0\n        sort!(lst)\n\
    \        sort!(lst)\n        rows = sort(lst[1], by=min)\n        cols = sort(lst[2],\
    \ by=min)\n    elseif x < 0\n        sort!(lst)\n        sort!(lst)\n        rows\
    \ = sort(lst[1], by=max)\n        cols = sort(lst[2], by=min)\n    elseif x <\
    \ 0\n        sort!(lst)\n        sort!(lst)\n        rows = sort(lst[1], by=max)\n\
    \        cols = sort(lst[2], by=min)\n    else\n        rows = sort(lst[1], by=max)\n\
    \        cols = sort(lst[2], by=min)\n    end\n    for r in rows\n        append!(rows,\
    \ (r,))\n        append!(cols, (x - r))\n    end\n    return rows\nend", "   \
    \ if lst == []\n        []\n    elseif x == 1\n        Tuple(0, length(lst))\n\
    \    else\n        tuple(x == 1 ? (x, y) : get_row(lst[x+1:end], x-1) for y in\
    \ reverse(0:(length(lst[x])-1)))\n    end\nend\n</cell>\n<code language=julia-1.6>\n\
    \"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n    which\
    \ is similar to matrix, however, unlike matrices,\n    each row may contain a\
    \ different number of columns.\n    Given lst, and integer x, find integers x\
    \ in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_col([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 5), (2, 0), (3, 0), (4, 5)]\n    >>> get_col([], 1)\n    []\n    >>> get_col([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n\"\"\"", "    \n    rows = sort(collect(range(size(lst)))).'\
    \ \n    columns = sort(collect(collect(lst)))\n    \n    # Sorting rows according\
    \ to the number of columns\n    rows = sort(rows.-x, lt=(x->rows[x]<x, reverse=true))\
    \ \n    \n    # Sorting rows according to the number of columns\n    columns =\
    \ sort(columns.-x,  lt=(x->columns[x]<x, reverse=true))\n    \n    return [(i,\
    \ x-columns[i]) for i in rows]\nend\n</cell>\n<text>\nPart II - Solution", " \
    \   n = length(lst)\n    if n < x\n        return Vector{Tuple{Int64, Int64}}()\n\
    \    lst = sort(lst)\n    rows = Array{Int64,1}(collect(1:n)) \n    cols = Array{Int64,1}(collect(1:n))\n\
    \    for idx in x\n        row = findfirst(i -> i == idx, rows)\n        if row\
    \ == n\n            return Vector{Tuple{Int64, Int64}}()\n        cols = sort!(collect((cols[row],cols[row+1]):1:n))\n\
    \    end\n    return Vector{Tuple{Int64, Int64}}(collect(zip(rows, cols)))\nend",
  "    \n    \"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    \n    \n    rows = length(lst)\n\
    \    columns = length(lst[1])\n    \n    if x < 0 || x > rows || y < 0 || y >\
    \ columns\n        return [];\n    end\n    \n    \n    sortedx = sort(lst[1])\n\
    \    \n    sortedy = reverse(sort(reverse(lst[2])))\n    \n    \n    if x == 0\n\
    \        return [(0,0)];\n    end\n    \n    \n    rowindex = findfirst(x->x==x,\
    \ sortedx);\n    colindex = findfirst(x->x==x, sortedy);\n    \n    \n    if rowindex\
    \ < 0 || colindex < 0\n        return [];\n    end\n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n", "    \n    if length(lst) == 0\n\
    \        return Vector{Tuple{Int64, Int64}}()\n    end\n    if x == 1\n      \
    \  return Vector{Tuple{Int64, Int64}}([(0, 0)])\n    end", "    \n    \"\"\"\n\
    \    Finding all coordinates of x in a vector \n    \"\"\"\n    if !isdefined(lst)\n\
    \        return Vec([])\n    end\n    \n    nrows = length(lst)\n    if nrows\
    \ == 0\n        return Vec([])\n    end\n    \n    ind1 = findfirst(x->x==x, lst)\n\
    \    if ind1 == nothing\n        return Vec([])\n    end\n    \n    ind2 = ind1\n\
    \    \n    for i in 1:nrows\n        if !isdefined(lst[i])\n            lst[i]\
    \ = [Int64]\n        end\n        \n        if lst[ind1] == x || x == lst[ind2]\n\
    \            lst[ind2] = (ind1, ind2)\n        end\n        \n        ind2 +=\
    \ 1\n    end\n    \n    return Vec(map(i -> Tuple(i, findfirst(x->x==x, lst[i])),\
    \ 0:nrows))\nend\n    \n\"\"\"\n    You are given a list of lists. Each of the\
    \ sublists has same number of elements.\n    Each sublist represents an edge in\
    \ the graph. \n    Each edge is a pair of adjacent nodes.\n    You have to find\
    \ the shortest path from source node to destination node.\n    \n    Input:\n\
    \    List of list of integers\n    \n    Examples:\n    >>> shortestpath([[1,2],[3,4],[1,3]])\n\
    \    [(1,3),(1,2)]\n    >>> shortestpath([[1], [2], [3], [4], [5]])\n    [(1,\
    \ 5)]\n\"\"\"", "    \"\"\"\n    get row \n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    \n    function get_row(lst::Vector{Vector{Int64}})::Vector{Tuple{Int64,\
    \ Int64}}\n    \n        if length(lst) == 0\n            return Vector{Tuple{Int64,\
    \ Int64}}[]\n        end\n    \n        # sort coordinates by rows in ascending\
    \ order\n        coords_asc = sort(lst, by=(x -> row(x)))\n        \n        #\
    \ sort coordinates of row by columns in descending order\n        coords_desc\
    \ = reverse(sort(lst, by=(x -> col(x))))\n    \n        coords_asc_rows = Vector{Tuple{Int64,\
    \ Int64}}[]\n        coords_asc_cols = Vector{Tuple{Int64, Int64}}[]\n       \
    \ for a in coords_asc\n            coords_asc_rows = append(coords_asc_rows, (row(a),\
    \ a))\n            coords_asc_cols = append(coords_asc_cols, (col(a), a))\n  \
    \      end\n    \n        coords_desc_rows = Vector{Tuple{Int64, Int64}}[]\n \
    \       coords_desc_cols = Vector{Tuple{Int64, Int64}}[]\n        for a in coords_desc\n\
    \            coords_desc_rows = append(coords_desc_rows, (row(a), a))\n      \
    \      coords_desc_cols = append(coords_desc_cols, (col(a), a))\n        end\n\
    \    \n        coords_asc_rows = coords_asc_rows[begin:end]\n        coords_asc_cols\
    \ = coords_asc_cols[begin:end]\n    \n        coords_desc_rows = coords_desc_rows[begin:end]\n\
    \        coords_desc_cols = coords_desc_cols[begin:end]\n    \n        return\
    \ [coords_asc_rows, coords_desc_rows, coords_asc_cols, coords_desc_cols]\n   \
    \ end\nend", "    \"\"\"\n    Gets row with coordinates of x, if it exists\n \
    \   \n    Examples:\n    >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    >>>\
    \ get_row([], 1)\n    []\n    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n\
    \    \"\"\"\nend\n</cell>\n<text>\nPart II. Matrices and Vectors\nIn this part\
    \ of the exercises, we discuss matrices and vectors. A matrix is a two-dimensional\
    \ array of numbers, a vector is a one-dimensional array of numbers. We will work\
    \ with matrices and vectors mainly in the exercise related to them.", "      \
    \  \n    row = find(lst,x)\n    \n    coords = zip(1:length(row),row)\n    \n\
    \    coords = sort!(coords,by=<)\n    coords = sort!(coords,by=<)\n    \n    coords\
    \ = reverse(coords)\n    \n    return coords\nend", "    \"\"\" \n    Find integers\
    \ x in the vector, and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nend\n</cell>\n<code language=julia-1.5>",
  "    \n    coords = map(x->(x[1], x[0]), (sort_rows(lst), sort_cols(lst)))\n   \
    \ coords = map(x->(x[1], x[0]), coords)\n    \n    if length(coords) > 1\n   \
    \     return coords\n    else\n        return coords\n    end\nend", "    if length(lst.ndims)\
    \ == 1\n        return Vector{Tuple{Int64, Int64}}(undef, 0);\n    end\n    lst_i\
    \ = lst[x, :]\n    lst_j = lst[:, x]\n    tuples = []\n    for i=1:length(lst_i)\n\
    \        tuple = [(i, j) for j in reverse(sort(lst_j[:,i])) ]\n        tuples\
    \ = [tuples..., tuple]\n    end\n    return tuples;\nend\n</code>\n<|/ a tags=julia,matrix,arrays\
    \ |>\n<| a |>\nHere is a solution using the map function from the IterTools package:\n\
    <code>\nusing IterTools\nimport Base.Iterators: map", "    \"\"\" \n    You are\
    \ given a two dimensional data, as a nested vectors,\n    which is similar to\
    \ matrix, however, unlike matrices,\n    each row may contain a different number\
    \ of columns.\n    Given lst, and integer x, find integers x in the vector,\n\
    \    and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n    each\
    \ tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates\
    \ initially by rows in ascending order.\n    Also, sort coordinates of the row\
    \ by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"", "    \n    ans = Vector{Tuple{Int64,\
    \ Int64}}()\n    \n    for row in lst\n        for col in row\n            if\
    \ col == x\n                push!(ans, (0, row(end)))\n            else\n    \
    \            break\n        end\n    end\n    \n    sort.(ans, by = ->(aa, bb)->(aa\
    \ < bb ? -1 : 1))\n    \n    return ans\nend", "    rows = sort(unique(lst.row))\n\
    \    \n    columns = sort(unique(lst.col))\n    \n    rows = Array{Int64,1}(rows)\n\
    \    columns = Array{Int64,1}(columns)\n    \n    # sort the row by columns in\
    \ descending order\n    rows = sort(rows, by = x -> -length(x))\n    \n    # sort\
    \ the column by rows in ascending order\n    columns = sort(columns, by = x ->\
    \ length(x))\n    \n    return zip(rows, columns)\nend\n</cell>\n<code language=julia-1.5>\n\
    get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n</cell>\n\
    <text>\n5.5 Get column index\nWe can use function get_column() to find column\
    \ index, given row index and column index.", "    lst = sort(lst)\n    lst = reverse(lst)\n\
    \    lst = sort_rows_cols(lst)\n    lst = reverse(lst)\n    lst = sort_rows_cols(lst)\n\
    \    lst = reverse(lst)\n    \n    \n        \nend", "    \n    row = find(x \u2208\
    \ lst)\n    \n    if row == nothing\n        []\n    else\n        coord = get_row_coord(lst,\
    \ row)\n        \n        coords = sort(coord, reverse=true)\n    \n        sortedrow\
    \ = sort(row, reverse=true)\n    \n        coords = zipmap(sortedrow, coords)\n\
    \        \n        coords = sort(coords)\n        \n        return coords\n  \
    \  end\nend", "    len = length(lst)\n    pos = 0\n    row = 0\n    column = 0\n\
    \    while pos < len\n        if lst[pos] == x\n            push!(res, Tuple{row,\
    \ column}) # append to res\n            row = row + 1\n            column = column\
    \ + 1\n            pos = pos + 1\n        else\n            pos = pos + 1\n  \
    \      end\n    end\n    res\nend\n</cell>\n<text>\nThe next function should check\
    \ if a list of tuples are equal or not,\nand should return a bool.", "    if x\
    \ < 0 || x > length(lst)\n        return Vector{Tuple{Int64, Int64}}()\n    else\n\
    \        n = length(lst[1])\n        \n        xr = Array{Int64, 2}(undef, x,\
    \ n) # initialize rows\n        for j in 1:n\n            if lst[1][j] == x\n\
    \                xr[j] = (1, j)\n            elseif lst[1][j] > x\n          \
    \      i = find(lst[1][j:end] .== x, 1) # find first element in vector\n     \
    \           for k in xr[j,1:i]\n                    xr[k,i] = (xr[k,i], k)\n \
    \               end\n            elseif lst[1][j] < x\n                i = find(lst[1][j:end]\
    \ .== x, 1) # find first element in vector\n                for k in xr[j:end,1:i]\n\
    \                    xr[k,i] = (xr[k,i], k)\n                end\n           \
    \ end\n        end\n        \n        yr = Array{Int64, 2}(undef, x, n) # initialize\
    \ columns\n        for j in 1:n\n            yr[j,1] = j\n        end\n      \
    \  \n        for j in 1:n\n            if lst[1][j] == x\n                yr =\
    \ sort_column(yr, lst[1][j+1:end])\n            elseif lst[1][j] > x\n       \
    \         i = find(lst[1][j:end] .== x, 1) # find first element in vector\n  \
    \              for k in yr[j,1:i]\n                    yr[k,i] = (xr[k,i], k)\n\
    \                end\n            elseif lst[1][j] < x\n                i = find(lst[1][j:end]\
    \ .== x, 1) # find first element in vector\n                for k in yr[j:end,1:i]\n\
    \                    yr[k,i] = (xr[k,i], k)\n                end\n           \
    \ end\n        end\n        \n        return (xr, yr)\n    end\nend\n</cell>\n\
    <code language=julia-1.5>", "    if length(lst) < x \n        return Vector{Tuple{Int64,\
    \ Int64}}() \n    else \n        rows = Vector{Int64}()\n        cols = Vector{Int64}()\n\
    \        for i in 1:length(lst)\n            if lst[i]==x\n                push!(rows,\
    \ i)\n                push!(cols, length(lst)-i)\n            end\n        end\n\
    \        if length(rows) == 0 \n            return Vector{Tuple{Int64, Int64}}()\
    \ \n        else \n            cols = cols[sortperm(cols)]\n            rows =\
    \ rows[sortperm(rows)]\n            final = zeros(length(x)-length(rows)+1, length(cols)+1)\n\
    \            for (k,v) in zip(rows, cols)\n                final[k, v] = 1\n \
    \           end\n            return Vector{Tuple{Int64, Int64}}(final)\n     \
    \   end\n    end\nend", "    if lst.n == 0 && x == 0\n        return Vector{Tuple{Int64,\
    \ Int64}}[]\n    end\n    \n    l = copy(lst)\n    for row in l\n        push!(row,\
    \ x)\n    end\n    l = sort(l)\n    for row in l\n        push!(row, -1)\n   \
    \ end\n    l = sort(l, by=x->x[2], rev=true)\n    res = Vector{Tuple{Int64, Int64}}[]\n\
    \    \n    for row in l\n        for col in row\n            push!(res, ((row[1],\
    \ col[1]), (row[2], col[2])))\n        end\n    end\n    \n    return res\nend",
  "    \n    sortedrows = sort(lst)\n    sortedcols  = sort(sort(sort(sortedrows)))\n\
    \    \n    rowcoords = Tuple{Int64, Int64}[]\n    for i in 1:length(sortedrows)\n\
    \        rowcoords = append!(rowcoords, get_row_coords(sortedrows, i, sortedcols,\
    \ x))\n    end\n    return rowcoords\nend", "    return \n        map(x -> Tuple(x..-1,\
    \ x-1), \n            filter(y -> y==x, lst))\nend\n</cell>\n<code language=julia-1.3>\n\
    \"\"\"\n    You are given a vector, where each element in the vector is a\n  \
    \  vector of integers. Return the index of max element in each\n    row of the\
    \ matrix\n    \n    Examples:\n    >>> get_matrix([[1, 2, 3], [4, 5], [6, 7]])\n\
    \    [[2, 4], [1, 1], [2, 0]]\n    >>> get_matrix([])\n    []\n    \"\"\"", " \
    \   # Write your code in Julia here\n    first = get_row(lst[1], lst[1][x])\n\
    \    second = get_row(lst[2], lst[2][x])\n    third = get_row(lst[3], lst[3][x])\n\
    \    return first + second + third\nend\n</cell>\n<cell>", "    result = []\n\
    \    for r in lst\n        if length(set(r)) < x\n            push!(result, (r[end],\
    \ r[end]))\n        else\n            push!(result, (r[end - x], r[end - x]))\n\
    \        end\n    end\n    sort(result)\nend", "    rows = sort(unique(map(i ->\
    \ lst[i], 1:size(lst))))\n    cols = sort(unique(map(j -> j-1, rows:reverse(rows))))\n\
    \    \n    rows = sort((i, rows[i]) for i \u2208 rows)\n    cols = sort((j, cols[j])\
    \ for j \u2208 cols)\n    \n    tuples = filter(x->(x[1] in rows[i]) && (x[1]\
    \ in cols[j]), enumerate(lst))\n    \n    sort((tuples[i][1], tuples[j][1]) for\
    \ i in 1:length(tuples)\n        for j in 1:length(tuples)\n            if tuples[i][1]\
    \ < tuples[j][1]\n                tuples[i][1] += 1\n                tuples[j][1]\
    \ -= 1\n            else\n                tuples[j][1] -= 1\n                tuples[i][1]\
    \ += 1\n        end\n    )\n    \n    return tuples\nend\n</cell>\n<code language=julia-1.0>",
  "    \"\"\"\n    You are given an n x 1 matrix, where each row may be empty,\n \
    \   where each row contains at least 2 columns.\n    Given a list of lists, and\
    \ an integer x,\n    find an index of a row such that each element in the row\
    \ is equal\n    to x, and return a list of the form [(x1, y1), (x2, y2) ...],\n\
    \    where each tuple is a coordinate - (row, columns), starting with 0.\n   \
    \ Also sort coordinates initially by rows in ascending order.\n    Also, sort\
    \ coordinates of the row by columns in descending order.\n    \"\"\"\n    \n \
    \   # Your code here\n    \nend", "    idx = 1:size(lst)[1]\n    i = idx-1\n \
    \   while (i > -1 && lst[i] == x)\n        i -= 1\n    end\n    if i > -1\n  \
    \      # move i to first element\n        lst[i] = lst[i + 1]\n        lst[i +\
    \ 1] = x\n        # sort by rows\n        lst[idx, :] = sort(lst[idx, :], rev=true)\n\
    \        # sort by columns\n        lst[i, :] = sort(lst[i, :], rev=false)\n \
    \       # convert back to tuple\n        res = Vec{Tuple{Int64, Int64}}(lst[i,\
    \ :])\n    else\n        res = Vec{Tuple{Int64, Int64}}()\n    end\n    return\
    \ res\nend\n</cell>\n<code language=julia-1.0>", "    rows = Vector{Tuple{Int64,\
    \ Int64}}([]) # Row vectors\n    cols = Vector{Int64}[]              # Column\
    \ vectors\n    for row in lst\n        push!(rows, Tuple{Int64, Int64}(row, findfirst(x\
    \ .== row, cols)))\n        push!(cols, length(row))\n    end\n    sort(rows)\
    \ # sort rows by rows\n    sort(rows) # sort rows by cols\n    return rows\nend\n\
    </cell>\n<code language=julia-1.0>", "    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n", "    lst_copy = copy(lst)\n    \n    # sort coordinates\
    \ by row\n    for i=1:length(lst)\n        lst[i] = sort(lst[i], lt=lt) # sort\
    \ by rows\n    end\n    \n    # sort coordinates by columns\n    for i=1:length(lst[i])\n\
    \        lst[i][end] = sort(lst[i][end], gt=gt) # sort by columns\n    end", " \
    \   result = []\n    for vector in lst\n        append!(result, getindex.(vector,\
    \ x))\n    end\n    @assert length(result) == length(lst)\n    return sort(result,\
    \ dims=2)\nend", "    sz = size(lst)\n    if sz == 1\n        return []\n    lst\
    \ = lst[1:end-1]\n    res = []\n    for row in lst\n        idx = 1\n        for\
    \ a in row\n            if a < x\n                break\n            idx += 1\n\
    \        end\n        res = [(row, idx)] + res\n    end\n    res\nend", "    vector\
    \ = Vector{Tuple{Int64, Int64}}(undef, 0)\n    \n    for row in lst\n        if\
    \ row[x] == x\n            push!(vector, (row[x], row[1]))\n        end\n    end\n\
    \    \n    vector = sort(vector, by = x => first(vector))\n    \n    for row in\
    \ vector\n        if row[x] < x\n            push!(vector, (row[x], row[x+1]))\n\
    \        end\n    end\n    \n    vector = sort(vector, by = x => -first(vector))\n\
    \    return vector\nend\n</cell>\n<code language=julia-1.5>", "    if length(lst)\
    \ == 0 \n        return [] \n    \n    # create initial coordinates by sorting\
    \ rows by ascending order of rows\n    coordinates_by_rows = zip(lst, 0:length(lst))\n\
    \    coordinates_by_rows = sort!(coordinates_by_rows) \n    \n    # create initial\
    \ coordinates by sorting columns by descending order of columns\n    coordinates_by_columns\
    \ = zip(0:length(lst), lst) \n    coordinates_by_columns = sort!(coordinates_by_columns)\
    \ \n    \n    # create final coordinates by sorting rows by descending order of\
    \ rows\n    coordinates = zip(coordinates_by_rows[2:end-1], coordinates_by_columns)\
    \ \n    coordinates = sort!(coordinates) \n    \n    row = findfirst(c -> c[1]\
    \ == x, coordinates) \n    coordinates = [(coordinates_by_rows[row], coordinates_by_columns[row])\
    \ for row = row + 1 : end]\n    \n    return coordinates\nend", "    if length(lst.data)\
    \ != length(lst.data[x]) \n        return [] \n    else \n        inds = Vector{Tuple{Int64,\
    \ Int64}}([]) \n        for i in 1:length(lst) \n            inds = append!(inds,\
    \ [i, length(lst[i])]) \n        end\n        \n        sortedinds = sortperm(inds,\
    \ rev=true)\n        return [(sortedinds[i], inds[i]) for i = 1:length(inds)]\n\
    \    end\nend # get_row()", "    z = Vector{Tuple{Int64, Int64}}()\n    for m\
    \ in lst\n        if m.length == 1\n            push!(z, Tuple{Int64, Int64}(m,\
    \ x))\n        elseif m.length == x.length\n            for n in 1:size(m, 1)\n\
    \                if m[n] == x\n                    push!(z, Tuple{Int64, Int64}(m,\
    \ n))\n                end\n            end\n        else\n            error(\"\
    Invalid data\")\n        end\n    end\n    sort(z)\n    z\nend\n</cell>\n<code\
    \ language=julia-1.3>\nget_row(lst1, 3)\n</cell>\n<code language=julia-1.3>\n\
    get_row(lst1, 4)\n</cell>\n<text>\n6. How much memory is required for the following\
    \ operation? Please provide a function solution().", "    lst[[end+1], end] =\
    \ nothing\n    lst[end, end] = x\n    lst = sort(lst)\n    lst = reverse(lst)\n\
    \    lst = sort(lst)\n    lst = reverse(lst)\n    return lst\nend", "    if is_empty(lst)\n\
    \        []\n    else\n        sort_row(lst, x)\n        sort_col(lst, x)\nend",
  "    coords = get_column_coords(lst)\n    coords = coords[coords[1, :] .< x] + 1\n\
    \    coords = coords[reverse(coords[1, :])]\n    coords = coords[coords[1, :]\
    \ .>= x, :]\n    return coords\nend\n</cell>\n<code language=julia-0.6>", "  \
    \  return lst[get_index(lst, x)]\nend", "    lst.sort!\n    i = -1\n    \n   \
    \ while i != length(lst, 1)\n        i = i+1\n        while (i == length(lst,\
    \ 1)) || lst[i][1] == x\n            i = i+1\n        end\n        if (i == length(lst,\
    \ 1)) || (lst[i][1] != x)\n            error(\"invalid input\")\n        end\n\
    \    end\n    \n    i = 1\n    j = 1\n    \n    while i <= length(lst, 1)\n  \
    \      if lst[i][1] == x\n            return [(lst[i][1], (j-1)) ; (i-1, j)]\n\
    \        end\n        i = i+1\n    end\nend", "    \n    ret = Vector{Tuple{Int64,\
    \ Int64}}()\n    n = 0\n    for row in lst\n        n = n + 1\n        if n ==\
    \ x\n            ret.push!(Tuple{Int64, Int64}(row, 0))\n        elseif n <= x\n\
    \            ret.push!(Tuple{Int64, Int64}(row, row - 1))\n        else\n    \
    \        break\n        end\n    end\n    \n    ret.sort!( by = x -> x[1], descending\
    \ = true)\n    \n    return ret\nend", "    lst = sort(lst)\n    \n    tuples_lst\
    \ = []\n    for i in eachindex(lst)\n        if lst[i][1] == x\n            tuples_lst\
    \ = [i for i in eachindex(lst) if i != i]\n            break\n        end\n  \
    \  end\n    \n    tuples_lst = sort(tuples_lst, reverse = true)\n    return tuples_lst\n\
    end", "    rows = map(length) do lst\n        zip(lst, 1:length(lst))\n    end\n\
    \    sorted = sort(zip(rows, cols), lt=:>)\n    indices = findfirst(x->x[1] ==\
    \ x, sorted)\n    indices = indices[1:end-1]\n    return Vector{Tuple{Int64, Int64}}([(sorted[i][2],\
    \ i) for i in indices])\nend", "    lst = sort(lst)\n    tuples = []\n    for\
    \ i in eachrow(lst)\n        tuples.append((x==i[1]) ? getindex(i) : [x, y])\n\
    \    end\n    return tuples\nend\n</cell>\n<code language=julia-1.3>\nget_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n</cell>\n<text>\n\
    4.4 get_column\nGiven a matrix, return vector of tuples,\n    [[x1, y1], [x2,\
    \ y2], ... , [xn, yn]],\n    such that\n    each tuple is a coordinate - (row,\
    \ columns), starting with 0.\n    Sort coordinates initially by columns in descending\
    \ order.\n    Also, sort coordinates of the row by rows in ascending order.\n\
    \    \n    Examples:\n    >>> get_column([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(1, 0), (2, 5), (3, 0), (4, 1), (5, 0), (6,\
    \ 6)]\n    >>> get_column([], 1)\n    []\n    >>> get_column([[], [1], [1, 2,\
    \ 3]], 3)\n    []\n    \"\"\"", "    \n    pos = find(lst, x)\n    if pos == -1\n\
    \        return []\n    else\n        col = pos[end]\n        row = pos:(end-1)\n\
    \        sortedRows = get_row(sort(row), row)\n        return sortedRows + [(row,\
    \ col)]\n    end\nend", "    if length(lst.nrow) == 0 || (x != length(lst[1])\
    \ && x != -1)\n        Vector{Tuple{Int64, Int64}}([], [])\n    else\n       \
    \ rows = sort(collect(eachrow(lst)))\n        cols = sort(collect(eachcol(lst)))\n\
    \        res = []\n        for (i,j) in zip(cols,rows)\n            if i == x\n\
    \                res = [(j,i)]\n                break\n            end\n     \
    \   end\n        res.sort()\n        return res\n    end\nend", "  \n    for v\
    \ in lst\n        if (@view v[1] <= @view v[2]) && (@view v[1] <= @view v[3])\n\
    \                push!(res, Tuple(@view v[1], @view v[3]))\n        end\n    end\n\
    \    return res\nend", "    \n    l = lst_to_tuples(lst)\n    sorted = sort(l)\n\
    \    \n    function get_row(tuples::Vector{Tuple{Int64, Int64}})::Vector{Tuple{Int64,\
    \ Int64}} \n        \n        indices = findall(x -> x == tuples[1], sorted)\n\
    \        if length(indices) == 0\n            return Vector{Tuple{Int64, Int64}}([])\n\
    \        end", "    vec = Vector{Tuple{Int64, Int64}}([])\n    for row in lst\n\
    \        if row[x] == 1\n            push!(vec, (length(vec) + 1, 0))\n      \
    \  else\n            push!(vec, (0, length(vec) + 1))\n        end\n    end\n\
    \    vec\nend\n</code>\n<|/ a dscore=0 tags=algorithm,sorting,python,matrix,arrays\
    \ |>\n<| a |>\nThis answer is a slight variation from Amadan's. Basically, it\
    \ finds the first x that satisfies the condition of being less than or equal to\
    \ y, and then finds the index of the first y that satisfies the condition of being\
    \ greater than or equal to x. Then, it finds the index position of the x that\
    \ satisfies the condition of being greater than the y value minus 1. Lastly, it\
    \ subtracts 1 from the index to account for the first y value greater than or\
    \ equal to x.\n<code>\ndef firstIndex(arr, n=-1, m=-1.0):\n    \"\"\"\n    Finds\
    \ the first index with the specified condition that \n    meets the criteria of\
    \ being greater than or equal to the \n    specified value.", "    if lst == []\
    \ \n        return [] \n    else \n        rows = length(lst) \n        columns\
    \ = length(lst[1]) \n        ans = [(0,0)] \n    \n        for i in 1:rows \n\
    \            if lst[i][x] == x \n                push!(ans, (i,x)) \n        \
    \    end \n        end\n    \n        for i in 1:columns \n            if lst[x][i]\
    \ == x \n                push!(ans, (x,i)) \n            end \n        end\n \
    \   \n        return ans\n    end\n\"\"\"\n    You are given a 2D matrix, as a\
    \ vector of vectors,\n    which is similar to array, however, unlike arrays,\n\
    \    each row may contain a different number of columns.\n    Given array, return\
    \ array of tuples, where each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_2d([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]])\n\
    \    [[(0, 0), (1, 4), (1, 0)], [(2, 5), (2, 0)], [(3, 6), (3, 1)]]\n    >>> get_2d([])\n\
    \    []\n    >>> get_2d([[[], [1], [1, 2, 3]]])\n    [[(2, 2)]]\n    \"\"\"",
  "    if lst == []\n        return Vector{Tuple{Int64, Int64}}()\n    end\n    \n\
    \    row = get_row(lst[1:end-1], x)\n    \n    \n    \n    if row == Vector{Tuple{Int64,\
    \ Int64}}()\n        return row\n    end\n    \n    \n    \n    col = get_col(lst[1:end-1],\
    \ x)\n    \n    if col == Vector{Tuple{Int64, Int64}}()\n        return col\n\
    \    end\n    \n    row = Vector{Tuple{Int64, Int64}}(undef, 0)\n    \n    \n\
    \    for k in 1:length(row)\n        if row[k] == nil\n            push!(row,\
    \ Tuple{Int64, Int64}(getindex(row, k), x))\n        end\n    end\n    \n    if\
    \ length(row) == length(lst)\n        push!(row, Tuple{Int64, Int64}(getindex(row,\
    \ length(row)), x))\n    end\n    \n    \n    sort!(row, 1, length(row), desc=true)\n\
    \    \n    \n    \n    cols = Vector{Tuple{Int64, Int64}}(undef, 0)\n    \n  \
    \  \n    for k in 1:length(col)\n        if col[k] == nil\n            push!(cols,\
    \ Tuple{Int64, Int64}(getindex(col, k), getindex(row, k)))\n        end\n    end\n\
    \    \n    \n    sort!(cols, 1, length(col), desc=true)\n    \n    \n    cols\
    \ = cols[2:end]\n    \n    return cols\nend\n    \n\"\"\"\n    You are given a\
    \ 2 dimensional data, as a nested vectors,\n    which is similar to matrix, however,\
    \ unlike matrices,\n    each row may contain a different number of columns.\n\
    \    Given lst, and integer x, find integers x in the vector,\n    and return\
    \ vector of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate\
    \ - (row, columns), starting with 0.\n    Sort coordinates initially by rows in\
    \ ascending order.\n    Also, sort coordinates of the row by columns in descending\
    \ order.\n    \n    Examples:\n    >>> get_col([[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (0, 5), (2, 6), (2, 0)]\n  \
    \  >>> get_col([], 1)\n    []\n    >>> get_col([[], [1], [1, 2, 3]], 3)\n    [(1,\
    \ 4)]\n    \"\"\"", "    \"\"\"\n    >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)]\n    \"\"\"\nend", "    \n    rows = sort(collect(1:length(lst)))\n    cols\
    \ = sort(collect(1:max(lst)))\n    rows = sort_rows(rows, cols) \n    cols = sort_cols(cols,\
    \ rows)\n    rows = sort_rows(rows, cols)\n    cols = sort_cols(cols, rows)\n\
    \    \n    lst = vec2mat(lst)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    rows = sort_rows(rows, cols)\n    cols = sort_cols(cols, rows)\n  \
    \  \n    \n    rows = sort_rows(rows, cols)\n    cols = sort_cols(cols, rows)\n\
    \    \n    \n    \n    result = vec([0 for i in cols], lst[[rows[i], cols[i]]])\n\
    \    \n    return result\nend\n</cell>\n<code language=julia-1.0>\n@assert size([1,2,3,4,5,6],\
    \ 2) == (6, 2)\n@assert size(vec2mat([1,2,3,4,5,6]), 6) == (6, 2)\n</cell>\n<text>\n\
    Exercise 5: write an algorithm which takes O(log(n)) time.", "    \"\"\"\n   \
    \ Given a 2 dimensional data, as a nested vectors,\n    which is similar to matrix,\
    \ however, unlike matrices,\n    each row may contain a different number of columns.\n\
    \    Given lst, and integer x, find integers x in the vector,\n    and return\
    \ vector of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate\
    \ - (row, columns), starting with 0.\n    Sort coordinates initially by rows in\
    \ ascending order.\n    Also, sort coordinates of the row by columns in descending\
    \ order.\n    \"\"\"\n    return sort(get_row(sort(lst), x), desc=true)", "  \
    \  return Vector{Tuple{Int64, Int64}}(undef, 0)\nend", "    if isEmpty(lst)\n\
    \        []\n    elseif x > 0\n        return get_row(lst[1:end-1], x) + [(lst[1],\
    \ x)] + get_row(lst[end-1:end], x-1)\n    else\n        return get_row(lst[1:end-1],\
    \ x-1)\n    end\nend\n\"\"\"\n    You have a 2D array represented by a list of\
    \ lists.\n    Each list is a row of the array,\n    and each row is a list of\
    \ integers representing row values.\n    Write a function to remove a row of the\
    \ array.\n    Each row is a list of integers.\n    The row can be anywhere in\
    \ the array,\n    and the order of rows can be random.\n    \n    Examples:\n\
    \    >>> arr = [\n    ... [1, 4, 7, 2, 5],\n    ... [2, 6, 3, 4, 2],\n    ...\
    \ [7, 8, 5, 7, 4]\n    ... ]\n    >>> remove_row(arr, [1])\n    [\n    ... [4,\
    \ 7, 2, 5],\n    ... [2, 6, 3, 4],\n    ... [7, 8, 5, 7]\n    ... ]\n    >>> remove_row(arr,\
    \ [0, 2])\n    [\n    ... [1, 4, 7],\n    ... [2, 6, 3],\n    ... [7, 8, 5]\n\
    \    ... ]\n    \"\"\"", "    row = findfirst(x-> x in lst, x)\n    if row ==\
    \ nothing\n        return Vector{Tuple{Int64, Int64}}()\n    else\n        \n\
    \        coord = Tuple{Int64, Int64}(row, 0)\n        row_coords = get_row(lst[row],\
    \ 0)\n        \n        for col in reverse(1:length(lst[row]))\n            if\
    \ lst[row][col] == x\n                coord = Tuple{Int64, Int64}(row, col)\n\
    \                break\n            elseif lst[row][col] < x\n               \
    \ row_coords = Vector{Tuple{Int64, Int64}}(row_coords)\n                coord\
    \ = Tuple{Int64, Int64}(row, 0)\n                break\n            else\n   \
    \             row_coords = Vector{Tuple{Int64, Int64}}(row_coords)\n         \
    \       coord = Tuple{Int64, Int64}(row, col)\n            end\n        end\n\
    \        \n        return row_coords + [coord]\n    end\nend", "    l = length(lst)\n\
    \    if x<1 || x>l\n        error(\"Index out of bounds: x=\", x)\n    end", " \
    \   if length(lst.) == 0 \n        Vector{Tuple{Int64, Int64}}() \n    else \n\
    \        row_idx = findfirst(x->x > x, lst)\n        col_idx = length(lst[row_idx])\n\
    \        \n        lst[row_idx][col_idx:(col_idx+1)] = Vector{Tuple{Int64, Int64}}()\n\
    \        if row_idx == length(lst) \n            lst[row_idx] = Vector{Int64}([x])\n\
    \        else \n            lst[row_idx][-1] = (row_idx+1, col_idx)\n        \
    \    lst[row_idx] = sort(lst[row_idx], rev=true)\n        end\n    end\nend\n\
    </cell>\n<text>\n3. Find All Coordinates\nThe function find(lst::Vector{Vector{Int64}},\
    \ x::Int64) finds all the coordinates of x in the 2d vector lst.\nIf there exists\
    \ more than one coordinate of x in lst, the function returns all the coordinates\
    \ in the order they are encountered.\nThe function returns an empty vector if\
    \ x is not found in the vector.\nThe function does not sort the returned vector.",
  "    if lst == []\n        []\n    elseif x < 0 || x > length(lst)\n        []\n\
    \    else\n        lst[1:x-1] |> sort\n        lst[x] |> sort \n        get_row(lst[(x+1):end],\
    \ x) \n    end\nend\n\"\"\"\n    You are given a list of vectors,\n    each vector\
    \ is represented as a list of integers.\n    You are asked to find if there is\
    \ a vector in the list which has sum equal to the given integer x.\n    \n   \
    \ Examples:\n    >>> find_sum([1], [2], [1]) == true\n    true\n    >>> find_sum([1,\
    \ 2, 3], [2, 3], [1, 4, 6]) == false\n    false\n    \"\"\"", "    if lst == []\
    \ || x > 0\n        return Vector{Tuple{Int64, Int64}}()\n    elseif x < 0\n \
    \       return get_row(-x..-1, -x) + get_row(lst[-lst[1]:end], -x)\n    elseif\
    \ lst == []\n        return Vector{Tuple{Int64, Int64}}()\n    else\n        rows\
    \ = length(lst)\n        cols = length(lst[1])\n        coord = []\n        for\
    \ i = -rows+cols...-1\n            for j = cols...-1\n                if i + j\
    \ == x\n                    push!(coord, (i + cols, j))\n                end\n\
    \            end\n        end\n        coord = sort!(coord, by=first, by=last)\n\
    \        coord = sort!(coord, by=second, reverse=true)\n        return coord\n\
    \    end\nend", "    \n    vec = vec2d(lst)\n    \n    if any(elem == x for elem\
    \ in vec)\n        \n        rows = sort(vec)\n        \n        cols = sort(vec[:,\
    \ 1:end-1])\n        \n        return zip((i for i = 1:length(rows)), (j for j\
    \ = 1:length(cols)))\n    end\n    \n    return []\nend", "    n=length(lst)\n\
    \    if x<0 || x>n\n        return Vector{Tuple{Int64, Int64}}[]\n    end\n  \
    \  \n    arr=sort(lst,by=length) \n    \n    arr1=arr[x-1:n+x-1]\n    arr2=arr[1:x-1]\n\
    \    \n    arr3=arr2[x-1:n+x-1]\n    \n    arr4=arr3[1:x-1]\n    \n    arr5=arr4[x-1:n+x-1]\n\
    \    \n    arr6=arr5[1:x-1]\n    \n    arr7=arr6[x-1:n+x-1]\n    \n    arr8=arr7[1:x-1]\n\
    \    \n    arr9=arr8[x-1:n+x-1]\n    \n    arr10=arr9[1:x-1]\n    \n    arr11=arr10[x-1:n+x-1]\n\
    \    \n    arr12=arr11[1:x-1]\n    \n    arr13=arr12[x-1:n+x-1]\n    \n    arr14=arr13[1:x-1]\n\
    \    \n    arr15=arr14[x-1:n+x-1]\n    \n    arr16=arr15[1:x-1]\n    \n    arr17=arr16[x-1:n+x-1]\n\
    \    \n    arr18=arr17[1:x-1]\n    \n    arr19=arr18[x-1:n+x-1]\n    \n    arr20=arr19[1:x-1]\n\
    \    \n    arr21=arr20[x-1:n+x-1]\n    \n    arr22=arr21[1:x-1]\n    \n    arr23=arr22[x-1:n+x-1]\n\
    \    \n    arr24=arr23[1:x-1]\n    \n    arr25=arr24[x-1:n+x-1]\n    \n    arr26=arr25[1:x-1]\n\
    \    \n    arr27=arr26[x-1:n+x-1]\n    \n    arr28=arr27[1:x-1]\n    \n    arr29=arr28[x-1:n+x-1]\n\
    \    \n    arr30=arr29[1:x-1]\n    \n    arr31=arr30[x-1:n+x-1]\n    \n    arr32=arr31[1:x-1]\n\
    \    \n    arr33=arr32[x-1:n+x-1]\n    \n    arr34=arr33[1:x-1]\n    \n    arr35=arr34[x-1:n+x-1]\n\
    \    \n    arr36=arr35[1:x-1]\n    \n    arr37=arr36[x-1:", "    if lst == []\n\
    \        []\n    elseif x != 0 && x > 0 && x < length(lst)\n        row = get_row(lst[(x-1)..end],\
    \ x-1)\n        column = find_column(lst, x-1)\n        if column == -1\n    \
    \        row\n        else\n            row = (row[1], column[1])\n          \
    \  row\n        end\n    else\n        []\n    end\nend\n</cell>\n<text>\nThe\
    \ next cell defines another function find_column.\nIt takes in a list of vectors,\
    \ and an integer,\nand returns the column position of x or -1 if x is out of the\
    \ vectors' range.", "    \"\"\"Find row\"\"\"\n    \n    return \nend\n</cell>\n\
    <code language=julia-1.5>", "    \n    lst1 = sort(lst)\n    \n    sortedCoords\
    \ = Vector{Tuple{Int64, Int64}}[]\n    \n    for row in lst1\n        for col\
    \ in row:\n            if col == x\n                sortedCoords = push!(sortedCoords,\
    \ (0, row))\n            end\n        end\n    end\n    \n    sortedCoords = reverse(sort(sortedCoords,\
    \ by=reverse))\n    \n    return sortedCoords\nend", "    \n\"\"\"\n    You are\
    \ given a 2 dimensional data, as a nested vectors,\n    which is similar to matrix,\
    \ however, unlike matrices,\n    each row may contain a different number of columns.\n\
    \    Given lst and integer x, find integers x in the vector,\n    and return vector\
    \ of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate\
    \ - (row, columns), starting with 0.\n    Sort coordinates initially by rows in\
    \ ascending order.\n    Also, sort coordinates of the row by columns in descending\
    \ order.\n    \n    Examples:\n    >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[], [1], [1, 2, 3]], 3)\n\
    \    [(2, 2)]\n    \"\"\"", "    lst = sort(lst)\n    pos = find(x .== lst)\n\
    \    if pos == 0\n        empty_list()\n    else\n        row = pos[0]\n     \
    \   cols = pos[1]-pos[1]+1\n        rows = length(lst)-pos-1\n        \n     \
    \   rows = sort(rows, reverse = true)\n        cols = sort(cols, reverse = true)\n\
    \        \n        return [(row-1, col-1)...]\n    end\nend\n</cell>\n<code language=julia-1.5>",
  "    if length(lst) == 0\n        return Vector{Tuple{Int64, Int64}}[]\n    else\n\
    \        return get_row(lst[findfirst(x == lst)[1]:end], x)\n    end\nend\n</cell>\n\
    <code language=julia-1.4>\n\"\"\"\n    You are given a 2 dimensional data, as\
    \ a nested vectors,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the vector,\n    and return vector of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by columns in descending order.\n  \
    \  Also, sort coordinates of the row by rows in ascending order.\n    \n    Examples:\n\
    \    >>> get_col([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1)\n    [(0, 0), (1, 4), (2, 5), (2, 0), (3, 1)]\n    >>> get_col([], 1)\n \
    \   []\n    >>> get_col([[], [1], [1, 2, 3]], 3)\n    [(3, 1)]\n    \"\"\"", " \
    \   rows, cols = size(lst)\n    coords = [(i,j) for i in 1:rows, j in 1:cols]\n\
    \    coords = sortperm(coords)\n    coords = coords[2:end]\n    rows = coords[1]\n\
    \    cols = coords[2]\n    coords_lst = []\n    for (r, c) in coords\n       \
    \ coords_lst = append(coords_lst, Tuple{Int64, Int64}(r, c))\n    end\n    if\
    \ x == 1\n        return coords_lst\n    elseif x == rows\n        coords_lst\
    \ = sortperm(coords_lst)\n        coords_lst = coords_lst[2:end]\n        return\
    \ coords_lst\n    elseif x == cols\n        coords_lst = sortperm(coords_lst)\n\
    \        coords_lst = coords_lst[2:end]\n        return coords_lst\n    elseif\
    \ x <= 1 || x > rows\n        return coords_lst\n    elseif x <= rows || x > cols\n\
    \        throw(DomainError(\"Coordinate not present\"))\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"\n    count_occurrences(lst)", "    if is_empty(lst)\n\
    \        return Vector{Tuple{Int64, Int64}}[]\n    row = find_row(lst, x)\n  \
    \  if row == -1\n        return get_row(Vector{Int64}(lst), x)\n    \n    lst\
    \ = lst[row:]\n    column = find_column(lst, x)\n    if column == -1\n       \
    \ return get_row(Vector{Int64}(lst), x)\n    \n    sorted = sort(lst[row], lst[column])\n\
    \    sorted = sort(lst[row], -sorted)\n    \n    answer = Vector{Tuple{Int64,\
    \ Int64}}[]\n    for i in 1:length(sorted)\n        answer.push((i, sorted[i]))\n\
    \    end\n    return answer\nend\n</cell>\n<code language=julia-1.5>", "\"\"\"\
    \n    You are given a 2 dimensional data, as a nested vectors,\n    which is similar\
    \ to matrix, however, unlike matrices,\n    each row may contain a different number\
    \ of columns.\n    Given lst, and integer x, find integers x in the vector,\n\
    \    and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n    each\
    \ tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates\
    \ initially by rows in ascending order.\n    Also, sort coordinates of the row\
    \ by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n\"\"\"", "    \n    rows = sort(map(i ->\
    \ (i[1], i), enumerate(lst)))\n    cols = sort(map(i -> (i[2], i), enumerate(lst)))\n\
    \    \n    rows = filter(i -> i[1] > x, rows)\n    cols = filter(i -> i[2] > x,\
    \ cols)\n    \n    rows = map(i -> (i[1], i[2]), rows)\n    cols = map(i -> (i[2],\
    \ i[1]), cols)\n    \n    return rows[reverse(indsort(rows))] ++ cols[reverse(indsort(cols))]\n\
    end", "    \n    if lst == [] || x == 0\n        return []\n    elseif x == 1\n\
    \        return [(0, lst.size)]\n    elseif x == lst.size\n        return [(lst.size\
    \ - 1, 0)]\n    end", "    sortedRows = getSortedRows(lst)\n    rowIdx = findRowIdx(sortedRows,\
    \ x)\n    colIdx = findColIdx(sortedRows[rowIdx], x)\n    return getRowCoords(sortedRows,\
    \ rowIdx, colIdx)\nend\n</cell>\n<code language=julia-1.5>\nget_row([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 2)\n</cell>\n<code language=julia-1.5>\n\
    sort!([1, 2, 3, 4, 5, 6], 1, lt=lt); sort!([8, 1, 2, 3, 4, 6], 1, lt=lt)\n</cell>\n\
    <code language=julia-1.5>", "    lst = sort(lst)\n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(2:length(lst)))\n    if x < 1 \n        return ()\n \
    \   else \n        idx = find(x .== lst)\n        if idx == length(lst)\n    \
    \        idx = find(x .== lst, 1, length(lst + 1))\n            if idx == length(lst)\n\
    \                return ()\n            end\n        end\n        return (rows[idx],\
    \ cols[idx])\n    end\nend\n</cell>\n<text>\nProblem 9\nImplement a function to_dict\
    \ that converts lists into a dictionary of lists. The keys are the elements of\
    \ lists in the same order as their index in the input list. ", "    \n    if length(lst)\
    \ == 0\n        []\n    elseif x == length(lst[1])\n        ([0, x], [0, x])\n\
    \    else\n        sorted1 = sortrows(lst)\n        sorted2 = sortrows(lst)\n\
    \        row1pos = find(sorted1[:, 1] == x)[1]\n        col1pos = length(sorted1[row1pos,\
    \ :]) - x\n        \n        sorted2[row1pos, col1pos] = sorted1[row1pos, col1pos]\n\
    \        sorted2[row1pos, col1pos + 1] = x\n        \n        sorted1[:, col1pos]\
    \ = sorted2[:, 1]\n        sorted1[:, col1pos + 1] = sorted2[:, 2]\n        \n\
    \        sorted1 = sortrows(sorted1)\n        return [(sorted1[row1pos, 0], sorted1[row1pos,\
    \ 1]),\n                (sorted1[row1pos + 1, 0], sorted1[row1pos + 1, 1])] \n\
    \    end\nend", "    \n    result = Vector{Tuple{Int64, Int64}}()\n    row = 0\n\
    \    col = 0\n    \n    while row < length(lst)\n        while col < lst[row].length\n\
    \            if lst[row][col] == x\n                result = [(result[1], row),\
    \ (result[2], col)]\n            end \n            col += 1\n        end\n   \
    \     row += 1\n        col = 0\n    end\n    \n    return result\nend \n\"\"\"\
    \n    You are given a nested vectors, and an integer x,\n    which finds the indices\
    \ of the row which contains x.\n    \n    Examples:\n    >>> get_indices([1, 2,\
    \ 3, 4, 5, 6], [1, 3])\n    [2, 3]\n    >>> get_indices([], 0)\n    []\n    >>>\
    \ get_indices([2, 3, 4, 1, 2, 3, 4, 5, 6], 2)\n    []\n    \"\"\"", "    if !isVector(lst)\
    \ || x == 0\n        return [] \n    end\n    lst_row = getIndex(lst, x)\n   \
    \ return [(x, y) for (y, lst_col) in enumerate(lst_row) for (x, y) in enumerate(lst_col)\
    \ if lst_col[x] == x] \nend\n</cell>\n<code language=julia-1.4>", "    \n    \n\
    \    rows = sort(collect(zip(1:length(lst), lst)))\n    rows = rows[2:end]\n \
    \   \n    cols = sort(collect(zip(1:length(lst[1]), lst)))\n    cols = cols[2:end]\n\
    \    \n    rx = 0\n    col = 0\n    \n    ans = []\n    \n    for r in rows\n\
    \        if r[1] <= x && x <= r[1]\n            if col == length(r[1])\n     \
    \           push!(ans, (rx, col))\n            else\n                push!(ans,\
    \ (rx, col+1))\n            end\n            rx = rx + 1\n        end\n      \
    \  col = col + 1\n    end\n    \n    ans\nend", "    if lst == []\n        return\
    \ Vector{Tuple{Int64, Int64}}()\n    if x < 0\n        error(\"x cannot be less\
    \ than 0\")\n    end\n    \n    row = Vector{Tuple{Int64, Int64}}()\n    for idx\
    \ in 1:length(lst)\n        if lst[idx][end] == x\n            push!(row, idx)\n\
    \        end\n    end\n    \n    \n    for i in reverse(row)\n        push!(row,\
    \ (i+1, length(lst_sorted[i])))\n    end\n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n", "    \n    tuples = []\n \
    \   \n    for row in lst\n        for column in row\n            if column ==\
    \ x\n                tuples += [(row, column)]\n                break\n      \
    \  end\n    end\n    \n    tuples = sort_tuples(tuples)\n    \n    if length(tuples)\
    \ == 0\n        return tuples \n    end\n    \n    tuples = sort_tuples_col(tuples)\n\
    \    \n    return tuples\nend\n</cell>\n<code language=julia-1.3>\nget_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n</cell>\n<code\
    \ language=julia-1.3>\nget_row([], 1)\n</cell>\n<code language=julia-1.3>", " \
    \   if lst.len == 0 || x < 0 || x >= length(lst[1])\n        return Vector{Tuple{Int64,\
    \ Int64}}()\n    end\n    \n    idx1 = find(lst[1] >= x, dims = 1)\n    idx2 =\
    \ findmax(lst[1] -> x, dims = 1)\n    \n    lst1 = lst[1][idx1:idx2]\n    lst2\
    \ = lst[1][idx2:end]\n    \n    lst21 = [x for (ix,x) in enumerate(lst2) if x\
    \ < lst1[ix]]\n    lst22 = [x for (ix,x) in enumerate(lst2) if x > lst1[ix]]\n\
    \    \n    lst3 = lst[1][end-1:end]\n    \n    lst = [lst1 .+ ([ix for (ix,x)\
    \ in enumerate(lst1) if x > lst[ix]]),\n           reverse(lst3; dims = 1)]\n\
    \    \n    sorted = sort!(lst; dims = 2)\n    sorted2 = sort!(sorted; dims = 2)\n\
    \    sorted21 = sort!(sorted2; dims = 2)\n    sorted22 = sort!(sorted21; dims\
    \ = 2)\n    \n    return [sorted21[1:end-1], sorted22]\nend\n</cell>\n<code language=julia-1.6>\n\
    x = 5\nget_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x)\n\
    </cell>\n<code language=julia-1.6>", "    lst = Vector{Vector{Int64}}(lst)\n \
    \   sort(lst) \n    m = length(lst, 2)\n    if m == 0\n        return Vector{Tuple{Int64,\
    \ Int64}}()\n    end\n    \n    for i = 1:m\n        \n        if lst[i][1] ==\
    \ x\n            row = (i, lst[i][1])\n            break\n        end\n    end\n\
    \    \n    if length(row) == 0 || row[1] < 1 || row[1] > length(lst)\n       \
    \ return Vector{Tuple{Int64, Int64}}()\n    end\n    \n    lst = Vector{Int64}(undef,\
    \ length(lst) - 1)\n    lst[row[1]] = x\n    \n    for i = row[1]+1:m\n      \
    \  lst[i] = lst[i-1]\n    end\n    \n    sort(lst, by = x -> reverse(sort(lst[i],\
    \ by = x -> reverse(sort(lst[i-1], by = x -> reverse(sort(lst[i+1], by = x ->\
    \ reverse(sort(lst[i], by = x -> reverse(lst[i]))))))))\n    return sort(lst,\
    \ by = x -> reverse(sort(lst[0], by = x -> reverse(sort(lst[1], by = x -> reverse(sort(lst[2],\
    \ by = x -> reverse(lst[3])))))))\nend\n    \n\"\"\"\n    Find columns in an nxn\
    \ matrix,\n    where n is the number of columns\n    \n    Examples:\n    >>>\
    \ find_column([[1, 2, 3], [1, 2, 3], [1, 2, 3]], 1)\n    [0, 1]\n    >>> find_column([],\
    \ 1)\n    []\n    >>> find_column([[], [1, 2, 3], [], [1, 2]], 2)\n    [0, 3]\n\
    \"\"\"", "    \"\"\"\n    Given a nested vector, find integers x in the vector,\
    \ and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple\
    \ is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially\
    \ by rows in ascending order.\n    Also, sort coordinates of the row by columns\
    \ in descending order.\n    \n    Examples:\n    >>> get_row([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[], [1], [1,\
    \ 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    \n    \n    lst = sort(lst,x,0)\n\
    \    row = 0\n    res = []\n    for (j,v) in lst\n        if j==x\n          \
    \  push!(res,(i,row))\n            i=i+1\n        else\n            row+=v\n \
    \       end\n    end\n    \n    return res\nend\n</cell>\n<text>\nNotice how we\
    \ return an empty list [] if there is no such integer in the input.", "    ans\
    \ = [(0, 0)]\n    for i = 1:length(lst)\n        append!(ans, Tuple{Int64, Int64}((i,\
    \ x - lst[i][1]), (x, i)))\n    end\n    sort(ans)\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n    which\
    \ is similar to matrix, however, unlike matrices,\n    each row may contain a\
    \ different number of columns.\n    Given lst and row number, find integers x\
    \ in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_col([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (2, 1), (3, 6)]\n    >>> get_col([], 1)\n    []\n    >>> get_col([[], [1],\
    \ [1, 2, 3]], 3)\n    [(2, 2), (3, 3)]\n    \"\"\"", "    \n    rows = sort(lst)\n\
    \    row_index = Dict{Int64, Int64}()\n    \n    for row in rows\n        \n \
    \       if x != 0\n            column = find(row, 1, x - 1)\n        else\n  \
    \          column = -1\n        end", "    lst = sort(lst)\n    lst = reverse(lst)\n\
    \    lst = get_row2(lst, x)\n    lst = sort(lst)\n    return lst\nend\n</cell>\n\
    <code language=julia-1.4>", "    if lst==[] || x==0\n        return []\n    if\
    \ x in lst[1]\n        lst = lst[2:end]\n        lst = sort(lst)\n        return\
    \ [(lst[1], lst[3])]\n    if lst[1]==[]\n        return get_row(lst[2:end], x)\n\
    \    \n    lst = lst[2:end]\n    lst = sort(lst)\n    \n    lst = reverse(lst)\n\
    \    \n    lst = sort(lst)\n    \n    lst = reverse(lst)\n    \n    lst = sort(lst)\n\
    \    \n    \n    lst = reverse(lst)\n    \n    return [(lst[1], lst[3])]\nend",
  "    rows, cols = get_size(lst)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    lst = sort(lst)\n    \n    index_list = []\n    for i=1:rows,\n   \
    \     for j=1:cols,\n            if lst[i][j] == x\n                index_list\
    \ += [(i, j)]\n            end\n        end\n    end\n    \n    index_list = sort(index_list)\n\
    \    \n    coords = [index_list[i][1] for i=1:length(index_list)]\n    \n    coords\
    \ = sort(coords)\n    \n    coords = [(coords[i], coords[j]) for i=1:length(coords),\
    \ j=i+1:length(coords)]\n    \n    coords = sort(coords)\n    \n    coords = [(coords[i],\
    \ coords[j]) for i=1:length(coords), j=i+1:length(coords)]\n    \n    return coords\n\
    end\n\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n  \
    \  which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, row, and column, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1, 3)\n    [(1, 0),\
    \ (2, 0), (2, 4)]\n    >>> get_row([], 1, 3)\n    []\n    >>> get_row([[], [1],\
    \ [1, 2, 3]], 3, 3)\n    [(3, 1)]\n    \"\"\"", "    return sort([(i, lst[i])\
    \ for i in lst if i == x], lt=lt) \nend", "    if any(x != i | i <- eachrow(lst))\n\
    \        return Vector{Tuple{Int64, Int64}}()\n    \n    coordinates = Vector{Tuple{Int64,\
    \ Int64}}()\n    \n    for row in eachrow(lst)\n        \n        for col in eachrow(row)\n\
    \            coordinate = Tuple{Int64, Int64}(0, col)\n            if col <= x\n\
    \                coordinate = coordinate + 1\n            end\n            push!(coordinates,\
    \ coordinate)\n        end\n    end\n    \n    # sort coordinates by rows in ascending\
    \ order\n    coordinates = sort(coordinates, by = fst)\n    \n    # sort coordinates\
    \ by columns in descending order\n    coordinates = sort(coordinates, by = snd)\n\
    \    \n    return coordinates\nend", "    sorted = sort(lst, by = rows(lst))\n\
    \    sorted = sort(sorted, by = columns(sorted))\n    \n    selected = collect(zip(selected(sorted),\
    \ selected(sorted)..(length(lst, 1) + 1)))\n    return collect(zip(selected, selected(sorted)..(length(lst,\
    \ 1) + 1)))\nend\n</cell>\n<code language=julia-1.5>\nget_row([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n</cell>\n<code language=julia-1.5>",
  "    \n    @assert length(lst) == length(lst[1])\n    \n    rows = sort(unique(reduce(hcat,\
    \ lst, [])))\n    cols = sort(unique(reduce(hcat, map(reverse, lst), [])))\n \
    \   \n    zipped_coords = zip(rows, cols)\n    \n    return filter(x->x[1] ==\
    \ x, zipped_coords)\n    \nend\n</cell>\n<code language=julia-1.0>\n#=\n    You\
    \ are given a matrix and a vector,\n    which are both vectors of integers,\n\
    \    each row may contain a different number of columns.\n    Given lst and x,\
    \ find integers x in the row,\n    and return vector of tuples [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by columns in ascending order.\n   \
    \ Also, sort coordinates of the column by rows in descending order.\n    \n  \
    \  Examples:\n    >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([],\
    \ 1)\n    []\n    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n=#", " \
    \   if lst.isa Vector && x > 0\n        lst1 = lst.map(row -> row[x], axes(lst))\n\
    \        lst2 = transpose(lst1)\n        \n        # sort lst1 in ascending order\n\
    \        lst3 = sort(lst1, ascending=true)\n        \n        # sort lst2 in descending\
    \ order\n        lst4 = sort(lst2, descending= true)\n        \n        # combine\
    \ the sorted lists\n        rows = zip(lst3..., lst4...)\n        return rows\n\
    \    else\n        return []\n    end\nend", "    rows = sort(collect(enumerate(lst)))\n\
    \    values = collect(zip(lst, rows))\n    row = filter((x->x[1] == x), values)\n\
    \    column = filter((x->x[1] == x[1]), values)\n    coords = map((x->(x[1], x[1])),\
    \ zip(row, column))\n    coords.sort!(by=identity, x->x[1]<=>x[1]) \n    coords.sort!(by=identity,\
    \ x->x[1]>=>x[1])\n    coords = filter(!iszero, x->(x[1] == 0))\n    return coords\n\
    end\n</cell>\n<code language=julia-1.5>\nget_row([[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n</cell>\n<code language=julia-1.5>\nget_row([],\
    \ 1)\n</cell>\n<code language=julia-1.5>\nget_row([[], [1], [1, 2, 3]], 3)\n</cell>\n\
    <code language=julia-1.5>\nget_row([[1], [2], [3], [4], [5]], 3)\n</cell>\n<code\
    \ language=julia-1.5>\nget_row([[1], [2], [3], [4], [5]], 10)\n</cell>\n<code\
    \ language=julia-1.5>\nget_row([[1], [2], [3], [4], [5]], 1)\n</cell>\n<code language=julia-1.5>\n\
    get_row([[1], [2], [3], [4], [5]], 4)\n</cell>\n<code language=julia-1.5>\nget_row([[1],\
    \ [2], [3], [4], [5]], 1)\n</cell>\n<text>\nWe also have the ability to find all\
    \ indices in the matrix where a specific value is present, without actually returning\
    \ the row or column number:", "    if lst==[]\n        []\n    elseif length(lst.last)==1\n\
    \        [(length(lst)+x, length(lst)+x)]\n    else\n        x = length(lst)+x\n\
    \        y = 0\n        while x>0\n            y+=1\n            x = x - length(lst[y])\n\
    \        end\n        x = 0\n        y = 0\n        while y<length(lst)\n    \
    \        x+=1\n            y = y + length(lst[y])\n        end\n        [(x, y)]\n\
    \    end\nend\nget_row(lst::Vector{Vector{Int64}}, x::Int64) = \n    sort(get_row(lst,x),\
    \ rev=true)\n    get_row(lst,x)\nend\n\"\"\"\n    You are given a 2 dimensional\
    \ data, as a nested vectors,\n    which is similar to matrix, however, unlike\
    \ matrices,\n    each row may contain a different number of columns.\n    Given\
    \ lst, return vector of tuples, where each tuple is a\n    coordinate - (row,\
    \ columns), starting with 0.\n    Sort coordinates initially by rows in ascending\
    \ order.\n    Also, sort coordinates of the row by columns in descending order.\n\
    \    \n    Examples:\n    >>> get_col([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (0, 6), (6, 6), (6, 0)]\n    >>> get_col([],\
    \ 1)\n    []\n    >>> get_col([[], [1], [1, 2, 3]], 3)\n    [(0, 0), (2, 2), (3,\
    \ 3)]\n    \"\"\"", "    result = Vector{Tuple{Int64, Int64}}()\n    for row in\
    \ lst\n       if length(result) == 0 || result[].1 < row[x]\n          push!(result,\
    \ Tuple{Int64, Int64}(row[x], length(result) + 1))\n       end\n    end\n    sort_row!(result)\n\
    \    sort_col!(result)\n    return result\nend", "    \n    \n    \n    \n   \
    \ if lst == []\n        return []\n    else\n        \n        \n        \n  \
    \      if length(lst) == x\n            \n            \n            \n       \
    \     #print(lst)\n            #print(lst[x])\n            #print(lst[x][x])\n\
    \            \n            \n            \n            #print(x)\n           \
    \ #print(y)\n            \n            \n            return [(i, x) for (i, y)\
    \ in enumerate(sort(lst[x][x], rev=true))] \n        else\n            \n    \
    \        \n            \n            \n            #print(lst)\n            #print(lst[x])\n\
    \            #print(lst[x][x])\n            \n            \n            \n   \
    \         #print(x)\n            #print(y)\n            \n            \n     \
    \       \n            \n            \n            return get_row(lst[x], x) +\
    \ get_row(lst[x][1:end], x)\n        end\n    end\n    \n    \nend\n</cell>\n\
    <code language=julia-1.4>\n\"\"\"\n    Get a submatrix of given length and width,\
    \ starting at given row,\n    all columns in descending order.\n    \n    Examples:\n\
    \    >>> get_submatrix(4, 1, 2)\n    [[3, 3, 3], [4, 5, 4], [6, 6, 6]]\n    >>>\
    \ get_submatrix(4, 1, 3)\n    [[3, 3, 3], [4, 5, 4], [6, 6, 6]]\n    >>> get_submatrix(4,\
    \ 2, 3)\n    [[3, 3, 3], [4, 5, 4], [6, 6, 6]]\n    >>> get_submatrix(4, 2, 3)\n\
    \    [[3, 3, 3], [4, 5, 4], [6, 6, 6]]\n    >>> get_submatrix(4, 3, 3)\n    [[3,\
    \ 3, 3], [4, 5, 4], [6, 6, 6]]\n    \"\"\"", "    if isa(lst[0], Vector{Int64})\
    \ == false \n        return Vector{Tuple{Int64, Int64}}() \n    else \n      \
    \  rows, cols = get_row_cols(lst) \n        \n        rows_sorted = sort(rows)\n\
    \        cols_sorted = sort(cols)\n        \n        result = []\n        for\
    \ r in rows_sorted\n            for c in cols_sorted\n                if c ==\
    \ x \n                    push!(result, (r, c))\n                end\n       \
    \     end\n        end\n        \n        return result\n    end\nend\n\"\"\"\n\
    \    You are given a 2 dimensional data, as a nested vectors,\n    which is similar\
    \ to matrix, however, unlike matrices,\n    each row may contain a different number\
    \ of columns.\n    Given lst, return the columns in descending order.\n    \n\
    \    Examples:\n    >>> get_col([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1)\n    [(4, 5), (3, 1), (2, 0), (3, 2), (4, 2)]\n    >>> get_col([],\
    \ 1)\n    []\n    >>> get_col([[], [1], [1, 2, 3]], 3)\n    [(6, 2), (5, 1)]\n\
    \    \"\"\"", "    \n    if length(lst) == 0 \n        return Vector{Tuple{Int64,\
    \ Int64}}([]) \n    end \n    \n    # sort the coordinates initially by rows in\
    \ ascending order \n    lst = sort(lst) \n    \n    # sort the coordinates of\
    \ the row by columns in descending order \n    lst = reverse(sort(lst)) \n   \
    \ \n    coords = Tuple{Int64, Int64}[] \n    \n    for i in 1:size(lst)[1] \n\
    \        # iterate over the rows of data \n        rows = Vector{Int64}(lst[i])\
    \ \n        \n        # if the coordinate is found, append it to the coords \n\
    \        if x \u2208 rows \n            push!(coords, (x[i], i)) \n        end\
    \ \n    end \n    \n    return sort(coords) \nend ", "    \n    z = Vector{Tuple{Int64,\
    \ Int64}}()\n    \n    for i in eachindex(lst)\n        if lst[i] == x\n     \
    \       push!(z, (0, i))\n        end\n    end\n    \n    for i in eachindex(z)\n\
    \        z[i] = reverse(z[i])\n    end\n    \n    sort(z)\n    \n    return z\n\
    end\n</cell>\n<code language=julia-0.6>\n# export", "    if length(lst.[1]) <\
    \ x\n        return list()\n    elseif x < length(lst.[1])\n        return map(i\
    \ -> (x, i), lst.[1])\n    else\n        return sort(lst.[1], by=x->-x[1])\n \
    \   end\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\n    You are given an\
    \ n x n matrix mat, and a list of length n,\n    say lst, and integer x, find\
    \ integers x in the matrix, and return\n    matrix of tuples, where each tuple\
    \ is coordinate - (row, column),\n    starting with 0\n    \n    Examples:\n \
    \   >>> get_mat([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6], [4, 5, 6, 7]], 3)\n\
    \    [(0, 0), (1, 0), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7)]\n    >>>\
    \ get_mat([[], [], []], 3)\n    []\n    >>> get_mat([], 3)\n    []\n    \"\"\"",
  "    \n    rows = sort(collect(0:length(lst)))\n    \n    indices = find(lst ==\
    \ x)\n    \n    tuples = []\n    for i in rows\n        tuples.append((i, indices[-length(i):]))\n\
    \    end\n    \n    tuples = sort(tuples, by=x->x[1])\n    \n    return tuples\n\
    end", "    # check if x is valid coordinate in lst, if so \n    # add coordinate\
    \ to result\n    if x >= 0 && x < size(lst)[1] \n        if !isempty(lst[x]) \n\
    \            return [(x, x) for x in lst[x]]\n        else \n            return\
    \ []\n    else \n        return []\n    end\nend", "    if length(lst) == 0 \n\
    \        return [] \n    \n    # sort rows in ascending order\n    rows = sort(lst)\
    \ \n    \n    # sort columns in descending order\n    cols = reverse(sort(vec(lst),\
    \ dims=2))\n    \n    # initialize result vector\n    result = Array{Tuple{Int64,\
    \ Int64}, 1}(undef, length(rows))\n    \n    for r = 1:length(rows) \n       \
    \ col_index = 0\n        for c = 1:length(cols) \n            if cols[c] < x \n\
    \                col_index += 1\n                break\n            else \n  \
    \              col_index += 1\n        end\n        result[r] = Tuple{Int64, Int64}(rows[r],\
    \ col_index)\n    end\n    \n    # sort result by rows in ascending order\n  \
    \  rows = sort(result)\n    \n    # sort result by columns in descending order\n\
    \    cols = reverse(sort(cols, dims=2))\n    \n    # return vector\n    return\
    \ rows\nend", "    \n    # sort coordinates initially by rows in ascending order\n\
    \    lst = deepcopy(lst)\n    lst = sort(lst, by=function(x) -> x[1])\n    \n\
    \    # get row indices\n    idx = find(lst, (x, x-1))\n    \n    # get all coordinates\
    \ in that row\n    coords = [(x, idx[i]) for i = 1:length(idx)]\n    \n    # sort\
    \ coordinates by columns in descending order\n    coords = sort(coords, by=function(c)\
    \ -> c[end])\n    \n    return coords\nend\n</code>\n<|/ a |>\n<| a tags=arrays,sorting,matrix,julia\
    \ dscore=0 |>\nI made a modification to Javier Dorado's answer to deal with the\
    \ problem of non-consecutive rows. I thought about this issue a while ago and\
    \ found the solution to be too easy.\n<code>", "    \n    vec = Vector{Tuple{Int64,\
    \ Int64}}()\n    for ii in 1:length(lst)\n        for jj in 1:length(lst[ii])\n\
    \            if (lst[ii][jj] == x) \n            \n                push!(vec,\
    \ (ii, jj))\n            \n            end\n        end\n    end\n    vec\nend",
  "    \n    if isempty(lst)\n        return Vector{Tuple{Int64, Int64}}()\n    end",
  "    if length(lst, 1) <= x \n        return [] \n    \n    col_sums = sum(lst[:,col]\
    \ for col in 1:size(lst, 2))\n    \n    rows = sort(vec(lst))\n    \n    indices\
    \ = (\n        findall(x -> x == rows[row, col], 0:size(rows, 2)) \n        for\
    \ row in rows\n    )\n    \n    coords = sort!(collect(zip(rows, indices), Tuple))\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>", "    if isnothing(lst.sub(1,\
    \ x))\n        return Vector{Tuple{Int64, Int64}}()\n    else\n        lst = sort(lst)\n\
    \        # @assert all(isnothing(lst[[i]]) for i=1:x)\n        indices = [i for\
    \ i=1:length(lst) where lst[[i]] <= x]\n        rows = zip(indices[1:end-1], indices[1:end])\n\
    \        cols = reverse(indices)\n        return rows ++ cols\n    end\nend\n\
    </cell>\n<code language=julia-1.3>", "    \"\"\"\n    get row with given x and\
    \ sort by columns in descending order\n    \"\"\"\n    \n    function get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n        sortedrow = sort(lst[x, :],\
    \ rev=true)\n        sortedcolumn = sort(lst[:, x], rev=true)\n        \n    \
    \    return zip(sortedrow, sortedcolumn)\n    end\nend", "    \"\"\" Returns the\
    \ row of nested vector lst, starting from 0\n    >>> get_row([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[], [1], [1,\
    \ 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    ", "    \n    #sort coordinates initially\
    \ by rows in ascending order\n    idx_sort = sortperm(1:length(lst))\n    idx_asc\
    \ = idx_sort[1:end-1]\n    idx_desc= idx_sort[1:end-1]\n    \n    coords_asc =\
    \ zeros(length(lst), 2)\n    coords_desc = zeros(length(lst), 2)\n    \n    for\
    \ i in idx_asc\n        coords_asc[i] = lst[i]\n    end", "    vec = lst[x]\n\
    \    col_ord = sort(vec)\n    row_ord = sort(vec |> transpose |> flatten)\n  \
    \  coords = zip(row_ord, col_ord)\n    \n    return coords\nend", "    if lst\
    \ == []\n        []\n    else\n        tuplesort(zip(eachindex(lst), eachindex(lst)))\n\
    \        tuplesort(zip(eachindex(lst), eachindex(lst)))\n        filter(row ->\
    \ row[1] == x, lst)\nend", "    \n    lst.sort()\n    \n    indices = Array{Int64}(1:lst.size)\n\
    \    for i = 1:size(lst)[1]\n        indices[i] = find(lst[i, :] .== x)[1]\n \
    \   end\n    \n    coordinates = Array{Tuple{Int64, Int64}}(undef, lst.size)\n\
    \    \n    for i = 1:size(lst)[1]\n        coordinates[indices[i]] = ((i - 1)\
    \ \xF7 size(lst)[1], indices[i])\n    end\n    \n    coordinates.sort!((i, j)\
    \ -> cmp(rows(lst[[i, j]], 1), rows(lst[[i, j + 1]], 1)), (1, length(lst) - 1))\n\
    \    coordinates.sort!((i, j) -> cmp(columns(lst[[i, j]], 1), columns(lst[[i,\
    \ j + 1]], 1)), (1, length(lst) - 1))\n    \n    \n    return coordinates\nend\n\
    </cell>\n<code language=julia-1.5>\nget_row([], 1)\n</cell>\n<code language=julia-1.5>\n\
    get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n</cell>\n\
    <code language=julia-1.5>", "    lst_x = lst.[x]\n    coord_lst = []\n    for\
    \ y in sort(collect(1:length(lst_x))) \n        push!(coord_lst, (x, y))\n   \
    \ end\n    return coord_lst\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n\
    \    You are given a 2 dimensional data, as a nested vectors,\n    which is similar\
    \ to matrix, however, unlike matrices,\n    each row may contain a different number\
    \ of columns.\n    Given lst, and integer x, find integers x in the vector,\n\
    \    and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n    each\
    \ tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates\
    \ initially by columns in ascending order.\n    Also, sort coordinates of the\
    \ row by rows in descending order.\n    \n    Examples:\n    >>> get_col([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 0), (2, 0), (2, 1), (1, 4)]\n    >>> get_col([], 1)\n    []\n    >>> get_col([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"", "    lst_size = length(lst)\n\
    \    rows = zeros(Int, lst_size)\n    cols = zeros(Int, lst_size)\n    \n    for\
    \ i = 1:lst_size\n        if lst[i] .< x\n            rows[i] = i\n          \
    \  cols[i] = 0\n        elseif lst[i] .== x\n            rows[i] = i\n       \
    \     cols[i] = 1\n        end\n    end\n    \n    return Tuple{Int64, Int64}(sort(rows),\
    \ reverse(sort(cols))) \nend\n</code>\n<|/ a tags=matrix,arrays,julia dscore=0\
    \ |>\n<| a dscore=0 |>\nIf your vectors are all sorted and your x is a scalar\
    \ you can use this function\n<code>", "    lst = sort(lst, dims=1)\n    pos =\
    \ find(lst[[x]]==x, 1)\n    pos = pos - 1 #start from 0\n    \n    if pos>0 \n\
    \        return [(pos, i) for i in 1:lst[x, pos]]\n    else\n        return []\n\
    \    end\nend", "    sort!(lst, by = x -> (-x, x)) \n    sort!(lst, by = x ->\
    \ x) \n    rows = length(lst)\n    \n    result = []\n    for row in 1:rows\n\
    \        cols = lst[row]\n        index = find(x -> x == cols, cols, 0)\n    \
    \    if index == length(cols)\n            result = [(x, 0) for x in result]\n\
    \        else\n            result = [(index, index + 1)]\n        end\n    end\n\
    \    \n    return result\nend", "    if lst == [] || x == 0\n    else (get_row(lst[end],\
    \ x-1), (get_row(lst[end-1], x), get_row(lst[end-1], x)[1]))\n    end\nend\n</cell>\n\
    <text>\nPart C\nLet's start with the \"main\" function and our input data (nested\
    \ vectors).", "    if length(lst)==0 || x==0 || x==length(lst[1])\n        return\
    \ Vector{Tuple{Int64, Int64}}()\n    elseif length(lst[1])==1\n        coordinates\
    \ = sort([(i, sort(last(i)) ) for i in lst])\n    else\n        coordinates =\
    \ sort([(i, sort(last(i))) for i in lst[1:end-1]])\n    end\n    \n    rows =\
    \ Vector{Tuple{Int64, Int64}}[]\n    for i in coordinates[1:length(coordinates)-1]\n\
    \        append!(rows, (coordinates[i][1], x-1))\n    end\n    append!(rows, (coordinates[length(coordinates)-1][1],\
    \ x))\n    return rows\nend\n    \n</cell>\n<text>\nProblem 9 - get_column\nWrite\
    \ a function that given a data matrix returns a column vector.\nThe column is\
    \ formed by flattening each row of the matrix and removing duplicate elements.\n\
    The function should return a list of tuples, each tuple containing the index of\
    \ the element in the column.\nThe function should return the empty list if the\
    \ input matrix is empty.\nFor any input matrix where each row has different number\
    \ of elements, return the empty list.\nThe result should be returned in the same\
    \ order as in input matrix.\nFor example, for the input matrix:", "    rows =\
    \ zeros(Int64, length(lst))\n    for k in 0:(length(lst) - 1) \n        rows =\
    \ k + rows\n    end\n    columns = zeros(Int64, size(lst, 1))\n    for i in (length(lst)\
    \ - 1):-1:1\n        for j in 0:(size(lst, 1) - 1)\n            if lst[i][j] ==\
    \ x\n                columns[j] = i\n                break\n            end\n\
    \        end\n    end\n    return Tuple{Int64, Int64}(rows, columns)\nend\n</cell>\n\
    <text>\nQ: Find the x coordinate (x, y) in lst where y is minimum.", "    res=[];\n\
    \    for e in lst do\n        if e in x\n            push!(res, Tuple(row(e),\
    \ col(e)))\n        end\n    end\n    sort(res)\nend\n</cell>\n<code language=julia-1.0>",
  "    if lst == [] || x == 0\n        return Vector{Tuple{Int64, Int64}}()\n    end\n\
    \    if x > 0\n        return get_row(lst[1..end-1], x-1)\n    else\n        lst[end]\
    \ = zeros(length(lst[end]),1)\n        return get_row(lst[1:end-1], x)\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\n# function get_row!(x::Vector{Vector{Int64}},\
    \ row::Int64, col::Int64)\n#     if row > length(row) || col > length(row[1])\n\
    #         push!(row, col)\n#         return\n#     end\n#     \n#     row[1] =\
    \ col\n#     \n#     get_row!(row[2], col+1)\n# end\n</cell>\n<code language=julia-1.5>",
  "    row = -1\n    while row < length(lst)\n        if lst[row][x] == x\n      \
    \      return [(row, x)]\n        else\n            row += 1\n        end\n  \
    \  end\n    return []\nend", "    for row in range(0, size(lst)[1]) do \n    \
    \    for column in range (0, size(lst)[2]) do \n            if lst[row, column]\
    \ == x \n                return (row, column)\n            end\n        end\n\
    \    end\n    return []\nend", "    \"\"\"\n    Given a 2 dimensional data as\
    \ a nested vectors,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the vector,\n    and return vector of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n \
    \   []\n    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\""]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
