name: HumanEval_80_is_happy
language: jl
prompt: "\"\"\"You are given a string s.\n    Your task is to check if the string\
  \ is hapjl or not.\n    A string is hapjl if its length is at least 3 and every\
  \ 3 consecutive letters are distinct\n    For example:\n    >>> is_happy(a)\n  \
  \  false\n    >>> is_happy(aa)\n    false\n    >>> is_happy(abcd)\n    true\n  \
  \  >>> is_happy(aabb)\n    false\n    >>> is_happy(adb)\n    true\n    >>> is_happy(xyy)\n\
  \    false\n    \"\"\"\nfunction is_happy(s::String)::Bool \n"
tests: "using Test\n\n@testset begin\n\ncandidate = is_happy;\n\t@test(candidate(\"\
  a\") == false)\n\t@test(candidate(\"aa\") == false)\n\t@test(candidate(\"abcd\"\
  ) == true)\n\t@test(candidate(\"aabb\") == false)\n\t@test(candidate(\"adb\") ==\
  \ true)\n\t@test(candidate(\"xyy\") == false)\n\t@test(candidate(\"iopaxpoi\") ==\
  \ true)\n\t@test(candidate(\"iopaxioi\") == false)\nend\n"
completions: ["    | s == [] = False\n    | s == [\"\"] = False\n    | s == [\"\"\
    , \"a\"] = False\n    | s == [\"\", \"a\", \"a\"] = False\n    | s == [\"\", \"\
    a\", \"a\", \"a\"] = False\n    | s == [\"\", \"a\", \"a\", \"a\", \"a\"] = False\n\
    \    | s == [\"\", \"a\", \"a\", \"a\", \"a\", \"a\"] = False\n    | s == [\"\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"] = False\n    | s == [\"\", \"a\",\
    \ \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"] = False\n    | s == [\"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"] = False\n    | s == [\"a\"\
    , \"\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"] = False\n    |\
    \ s == [\"a\", \"\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"] =\
    \ False\n    | s == [\"a\", \"\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"\
    a\", \"a\", \"a\"] = False\n    | s == [\"a\", \"\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"] = False\n    | s == [\"a\", \"\",\
    \ \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"] = False\n\
    \    | s == [\"a\", \"\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"\
    a\", \"a\", \"a\"] = False\n    | s == [\"a\", \"\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"] = False\n    | s == [\"a\", \"\",\
    \ \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    ] = False\n    | s == [\"a\", \"\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\",\
    \ \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"] = False\n    | s == [\"a\", \"\",\
    \ \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\"] = False\n    | s == [\"a\", \"\", \"a\", \"a\", \"a\", \"a\", \"a\",\
    \ \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"] = False\n    | s == [\"a\"\
    , \"\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\",\
    \ \"a\", \"a\"] = False\n    | s == [\"a\", \"\", \"a\", \"a\", \"a\", \"a\",\
    \ \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"] = False\n    | s ==\
    \ [\"a\", \"\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\"] = False\n    | s == [\"a\", \"\", \"a\", \"a\",\
    \ \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    ] = False\n    | s == [\"a\", \"\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\",\
    \ \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"] = False\n    | s == [\"a\"\
    , \"\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\",\
    \ \"a\", \"a\", \"a\"] = False\n    | s == [\"a\", \"\", \"a\", \"a\", \"a\",\
    \ \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"] = False\n\
    \    | s == [\"a\", \"\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"\
    a\", \"a\", \"a\", \"a\", \"a\", \"a\"] = False\n    | s == [\"a\", \"\", \"a\"\
    , \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"\
    , \"a\"] = False\n    | s == [\"a\", \"\", \"a\", \"a\", \"a\", \"a\", \"a\",\
    \ \"a\", \"a\", \"a\", \"a\", \"", "    |[Char] <- s\n    |length s <= 0 || length\
    \ s % 3 != 0\n    |s == replicate(3 \u2217 0, x)\n    |let x::Int = 0 \n    |for\
    \ i \u2208 [1..(length s - 1)] \n    |\u2217 x \u2190 x \u2217 + 1 \n    |\u2217\
    \ i \u2190 i \u2217 + 1 \n    |\u2217 x \u2208 [i, i + 1, i + 2, i + 3]\n    |\u2217\
    \ x \u2208 [i, i + 1, i + 2, i + 3] \n    |\u2217 x \u2208 [i, i + 2, i + 3, i\
    \ + 1]\n    |\u2217 x \u2208 [i, i + 1, i + 2, i + 3] \n    |\u2217 x \u2208 [i,\
    \ i + 2, i + 3, i + 1] \n    |\u2217 x \u2208 [i, i + 1, i + 3, i + 2]\n    |\u2217\
    \ x \u2208 [i, i + 1, i + 2, i + 3] \n    |\u2217 x \u2208 [i, i + 2, i + 3, i\
    \ + 1] \n    |\u2217 x \u2208 [i, i + 1, i + 3, i + 2]\n    |\u2217 x \u2208 [i,\
    \ i + 1, i + 2, i + 3] \n    |\u2217 x \u2208 [i, i + 2, i + 3, i + 1]\n    |\u2217\
    \ x \u2208 [i, i + 1, i + 3, i + 2]\n    |\u2217 x \u2208 [i, i + 1, i + 2, i\
    \ + 3] \n    |\u2217 x \u2208 [i, i + 2, i + 3, i + 1]\n    |\u2217 x \u2208 [i,\
    \ i + 1, i + 3, i + 2]\n    |\u2217 x \u2208 [i, i + 1, i + 2, i + 3] \n    |\u2217\
    \ x \u2208 [i, i + 2, i + 3, i + 1]\n    |\u2217 x \u2208 [i, i + 1, i + 3, i\
    \ + 2]\n    |\u2217 x \u2208 [i, i + 1, i + 2, i + 3]\n    |\u2217 x \u2208 [i,\
    \ i + 2, i + 3, i + 1]\n    |\u2217 x \u2208 [i, i + 1, i + 3, i + 2]\n    |\u2217\
    \ x \u2208 [i, i + 1, i + 2, i + 3]\n    |\u2217 x \u2208 [i, i + 2, i + 3, i\
    \ + 1]\n    |\u2217 x \u2208 [i, i + 1, i + 3, i + 2]\n    |\u2217 x \u2208 [i,\
    \ i + 1, i + 2, i + 3]\n    |\u2217 x \u2208 [i, i + 2, i + 3, i + 1]\n    |\u2217\
    \ x \u2208 [i, i + 1, i + 3, i + 2]\n    |", "    if is_empty(s):\n        return\
    \ true\n    let char_count = count(s,\"\")\n    if char_count < 3 || char_count\
    \ % 3 != 0\n        return false\n    for c in s[1..-1]\n        if count(s,c)\
    \ >= 3 && count(s,c) != char_count\n            return false\n    return true\n\
    </code>\n<|/ a tags=string,haskell,algorithm,functional-programming |>\n<| a |>\n\
    I suggest you a recursive function\n<code>\nisHappy :: String -> Bool\nisHappy\
    \ [] = True\nisHappy (x:xs) =\n    if length x < 3 || length xs /= 3\n       \
    \ then False\n        else if xs == x\n                then True\n           \
    \     else if x `elem` xs /= False\n                      then False\n       \
    \               else isHappy xs\n</code>\n<|/ a tags=string,haskell,algorithm,functional-programming\
    \ dscore=0 |>\n<| a tags=string,haskell,algorithm,functional-programming |>\n\
    Here is a solution using the built-in function filter:\n<code>\nimport Data.List",
  "    is_happy_s <- count_happy(s) == 3\n    return is_happy_s && is_happy_s &&\n\
    \           for i \u2208 0..length(s-1)\n           and is_happy_s &&\n      \
    \     s[i .. i+3] == s[i .. (i+3)]\n           end", "    if is_null(s) or length(s)\
    \ < 3 \n        false\n    elseif is_happy_helper(s) \n        true\n    else\n\
    \        false\n    end\nend\n</code>\nAnd then we define our \"helper function\"\
    \n<code>", "    if is_nil(s)\n        false\n    else if length(s) >= 3\n    \
    \    is_all_distinct(a[2:length(s)-2], s[2:length(s)-2]) || is_all_distinct(a[2:length(s)-1],\
    \ s[2:length(s)-1]) \n    else\n        is_all_distinct(a[1:length(s)-1], s[1:length(s)-1])\n\
    end\n</cell>\n<code language=julia-1.0>\nis_happy(\"A\")\n</cell>\n<code language=julia-1.0>\n\
    is_happy(\"aa\")\n</cell>\n<code language=julia-1.0>\nis_happy(\"abbc\")\n</cell>\n\
    <code language=julia-1.0>\nis_happy(\"aabbb\")\n</cell>\n<code language=julia-1.0>\n\
    is_happy(\"ababab\")\n</cell>\n<code language=julia-1.0>\nis_happy(\"adb\")\n\
    </cell>\n<code language=julia-1.0>\nis_happy(\"xyy\")\n</cell>\n<text>\nProblem\
    \ 6. Write a function, is_happy(s::String), that returns true if the string s\
    \ is hapjl and false otherwise.\n    You may assume that is_happy_str(s) returns\
    \ true for strings of length 3, 4, and 5, and false otherwise.", "    if is_happy(string)\
    \ == true then return true else return false\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ dscore=0 tags=sml,smlnj |>\n<code>\nfun is_happy(str : string) =\n    if String.length(str)\
    \ = 3 then true\n    else if String.exists(h::t => String.find(h,str,1) = -1 and\
    \ String.find(t,str,2) = -1 and\n                   String.find(h,str,2) = -1\
    \ and String.find(t,str,1) = -1) then false\n    else true\n</code>\n<|/ a |>\n\
    <| a |>\nI know I'm late but just wanted to add this as an alternative answer,\
    \ if using List.nth is allowed then you could do:\n<code>\nfun is_happy(str :\
    \ string)  = \n   let\n      fun is_happy_aux(str : string)  = \n        if List.length(str)\
    \ =  3\n         and List.exists (fn x => x = List.nth(str, 2))\n         and\
    \ List.exists (fn x => x = List.nth(str, 1)) \n         and List.exists (fn x\
    \ => x = List.nth(str, 0))\n         then true\n         else false\n   in\n \
    \     is_happy_aux(str);\n   end;\n</code>\n<|/ a tags=sml,smlnj dscore=0 |>\n\
    <| a dscore=0 |>\nI suggest the following solution, based on your code:\n<code>\n\
    fun is_happy (str : 'a list) = \n    if String.length(str) >= 3 \n    then\n \
    \       if String.chars(str) \n            |> String.map Char.toLower \n     \
    \       |> String.equals \"abc\"\n        then true\n        else false\n    else\
    \ false\n</code>\nIt uses the String.map function and String.equals function.\
    \ It splits the input string into characters and lower cases them, then checks\
    \ if all the characters are equal.\n<|/ a tags=sml,smlnj |>\n<| c |>\nThis solution\
    \ doesn't work either. `String.chars(str)` returns `nil` if the string is empty.\n\
    <|/ c |>\n<| c |>\nYes, I didn't notice that in my testing. I added a test for\
    \ `String.length(str) >= 3` to my answer.\n<|/ c |>\n<| a |>\n<code>\nfun happy\
    \ (str : string) = (String.length str >= 3) and (String.find \"abc\" str = -1)\
    \ and\n    (String.find \"abb\" str = -1) and (String.find \"aba\" str = -1) and\
    \ (String.find \"aba\" str = -1) \n    and String.find \"ab\" str = -1 and String.find\
    \ \"a\" str = -1;\n</code>\n<|/", "    return s.length >= 3 && ! is_happed(s)\
    \ && ( s.slice(0,3).zip( s.slice(3,6).zip(s.slice(6,9)) ).map { case (x1,x2,x3)\
    \ => x1 != x2 }.forall(_ == true) ) \nend\n</cell>\n<code language=julia-1.1>\n\
    println(is_happy(a))\nprintln(is_happy(aa))\nprintln(is_happy(abcd))\nprintln(is_happy(aabb))\n\
    println(is_happy(adb))\nprintln(is_happy(xyy))\n</cell>\n<code language=julia-1.1>\n\
    \"\"\"You are given a matrix mat of size m x n.\nYour task is to check whether\
    \ it is a rectangular matrix or not.\nA matrix is rectangular if its size is nxn\
    \ and every element is distinct.\nFor example: \n[[1,2,3,4],[5,6,7,8]] is a rectangular\
    \ matrix but [[1,1,1],[2,2,2]] is not a rectangular matrix.\n\"\"\"", "    if\
    \ is_happy_helper(s) == true\n    true\n    else false\nend\n</cell>\n<code language=julia-0.5>\n\
    is_happy(a) \u2260 is_happy(aa)\n</cell>\n<code language=julia-0.5>\nis_happy(a)\
    \ \u2260 is_happy(abcd)\n</cell>\n<code language=julia-0.5>\nis_happy(a) \u2260\
    \ is_happy(aabb)\n</cell>\n<code language=julia-0.5>\nis_happy(a) \u2260 is_happy(adb)\n\
    </cell>\n<code language=julia-0.5>\nis_happy(a) \u2260 is_happy(xyy)\n</cell>\n\
    <text>\nTask", "    if length(s)==0 || strlength(s) < 3 || strlength(s) != strlength(s)\
    \ div 3 \n    then false \n    else if strlength(s) < 3 || strlength(s) > strlength(s)\
    \ div 3 \n    then true \n    else if length(s)==3 \n    then true \n    else\
    \ false\n</code>\n<|/ a dscore=1 tags=string,happy,haskell |>\n<| c |>\nIt will\
    \ still return true when given `a`, which I guess is what the OP wants. I think\
    \ you need to change `strlength(s) > strlength(s) div 3` to `strlength(s) < strlength(s)\
    \ div 3`\n<|/ c |>\n<| c |>\nThanks, fixed.\n<|/ c |>\n<| a tags=string,happy,haskell\
    \ |>\nIn case someone is trying to learn from scratch here is a code with basic\
    \ algorithms only\n<code>\nhappyString :: String -> Bool\nhappyString s = length\
    \ s >= 3 \n            && length s3 >= 3\n            && check s == s3\n  where\n\
    \    check s = tail s == heads s\n    heads s = head s\n    tail s = tail s\n\
    \    s3 = take 3 s\n</code>\nAnd here are two more implementations for checking\
    \ if a given string is happy or not, but they are far from efficient\n<code>\n\
    happy :: String -> Bool\nhappy s = happy s == tail s", "    \"\"\"\n    # Solution\
    \ starts here\n    \"\"\"\n    \n    \n    if s.length < 3 return false\n    \n\
    \    i <- 1\n    j <- 2\n    \n    while j + i < s.length\n        if s[i] ==\
    \ s[j] return false\n        i <- i + 1\n        j <- j + 1\n        \n    i <-\
    \ 2\n    j <- 3\n    \n    while j + i < s.length\n        if s[i] == s[j] return\
    \ false\n        i <- i + 1\n        j <- j + 1\n    \n    return true\n    \n\
    \    \"\"\"\n    # Solution ends here\n    \n\"\"\"\nDifficulty level: easy\n\
    Time usage: < 1ms\nMemory usage: < 1MB\n\"\"\"\n</cell>\n<cell>\n@test is_happy(abaca)\n\
    </cell>\n<text>\nQ6. (4 points)\nGiven a string s, you need to find the longest\
    \ common prefix among the strings in s.\nFor example, for s = \"abab\", the longest\
    \ common prefix is \"ab\". The longest common prefix of s is \"ab\".\nWrite a\
    \ function\ndef common_prefix(words::Vector[String]): String\nthat returns the\
    \ longest common prefix among the words in words.\nFor example, common_prefix([\"\
    a\", \"b\", \"ab\", \"c\"]) should return \"ab\".\nGiven an empty list, return\
    \ the empty string.\nIf the length of the list is zero, return \"\".", "    if\
    \ is_happy(s) == true \n    then true\n    else false\n    end\nend\n</code>\n\
    <|/ a dscore=0 tags=julia |>\n<| c |>\nHow does `is_happy` work? `is_happy` will\
    \ always return `true` no matter what `s` is.\n<|/ c |>\n<| c |>\nthank you for\
    \ your comment, I have already corrected the code, but I didn't test the code\
    \ before, thanks for the heads up.\n<|/ c |>\n<| a dscore=0 tags=julia |>\nWe\
    \ can also use recursive algorithms \n<code>\nis_happy(s:String) = (s == \"\"\
    ) || (length(s) == 3 && setdiff(s.chars(), collect(1:3)).length == 0)\n</code>\n\
    or\n<code>\nis_happy(s:String) = (s == \"\") || (length(s) == 3 && map((x) ->\
    \ x != 1, collect(1:3)).length == 0)\n</code>\nIn a more general case where we\
    \ can not use setdiff or map\n<code>\nis_happy(s:String) = (s == \"\") || (length(s)\
    \ == 3 && map((x) -> x != 1, collect(1:3)).length == 0 || is_happy(sub(\"(?=(.)(?!.*\\\
    1)).\", \"\",s))) \n</code>\nIn order to make this a tail recursive algorithm,\
    \ we can create a helper function \n<code>\nis_happy(s:String)::Bool = helper(s,\
    \ \"\")", "    let l=length(s) \n    l >= 3 && (map is_distinct [0..(l/3-1)..(l/3)]\
    \ s)\nend", "    if is_nil(s) then false \n    else if length(s) < 3 then false\
    \ \n    else if all((not isperm(s[i..i+3],s)) for i in 0..length(s))\n    then\
    \ false \n    else true \n    end\nend\n\"\"\"\n## 2. Nice Day\n\"\"\"\nThe function\
    \ niceday returns a list of days (strings) of which the given day is a nice\n\
    day.\nFor example:\n>>> niceday(6)\n[\"Monday\", \"Wednesday\", \"Friday\"]\n\"\
    \"\"", "    length(s)>3 && all(isDistinct(s[3:i:3]) || i==2 for i in [1..(length(s)-2)])\n\
    end\n</cell>\n<code language=julia-1.1>\n@assert is_happy(\"aba\")=false \"is_happy\
    \ test failed\"\n@assert is_happy(\"ada\")=false \"is_happy test failed\"\n@assert\
    \ is_happy(\"abx\")=false \"is_happy test failed\"\n@assert is_happy(\"abba\"\
    )=true \"is_happy test failed\"\n@assert is_happy(\"abc\")=true \"is_happy test\
    \ failed\"\n@assert is_happy(\"abcd\")=true \"is_happy test failed\"\n@assert\
    \ is_happy(\"abbbb\")=true \"is_happy test failed\"\n</cell>\n<text>\n5.2.3 Longest\
    \ palindromic substring", "    \"\"\"\n    use is_happy_helper with s\n    \"\"\
    \"\nis_happy_helper(\"\", s)", "    \n    is_happy = s \u2208 [\"\", \"\", \"\"\
    , \"a\", \"aa\", \"b\", \"c\", \"cd\", \"d\", \"dcd\", \"e\", \"ef\", \"f\", \"\
    f\", \"fg\", \"g\", \"gh\", \"h\", \"h\", \"hi\", \"i\", \"ij\", \"j\", \"jj\"\
    , \"k\", \"kl\", \"l\", \"lm\", \"m\", \"mm\", \"n\", \"nn\", \"o\", \"oo\", \"\
    p\", \"pp\", \"q\", \"qq\", \"r\", \"rr\", \"rs\", \"s\", \"sd\", \"sd\", \"sd\"\
    , \"sd\", \"se\", \"sf\", \"sg\", \"sh\", \"si\", \"sj\", \"sj\", \"sk\", \"sl\"\
    , \"sm\", \"sn\", \"so\", \"sp\", \"sq\", \"sr\", \"ss\", \"ss\", \"ss\", \"st\"\
    , \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\"\
    , \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\"\
    , \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\"\
    , \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\"\
    , \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\"\
    , \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\"\
    , \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\"\
    , \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\"\
    , \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\"\
    , \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\"\
    , \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\"\
    , \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\"\
    , \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\"\
    , \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\"\
    , \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\"\
    , \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\"\
    , \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\"\
    , \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\"\
    , \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st\", \"st",
  "  \n    if length(s) < 3 return false \n    for i in  [0..(length(s)-2)]\n    \
    \  if hs[[i]] /= 1 then return false \n    return true\nend ", "    \n    length\
    \ := length(s) \n    if length < 3 \n        return false \n    \n    result :=\
    \ (true) \n    for i from 1 to length(s)-1 do \n        if s[i] == s[i-1] && s[i]\
    \ == s[i+1] \n            then result := false \n        else result := true \n\
    \    \n    result := result && (length == length(unique(s[2:length]))) \n    \n\
    \    return result", "    if is_happy(s,[]) == true\n        return true\n   \
    \ end", "    if is_empty(s) then return false\n    if s.length == 0 then return\
    \ false\n    if s.length == 3 then return true", "    str_length::Int \n    letter::Char",
  "    if is_happy(\"\",s) = true then return true else return false end\n    length(s)\
    \ = size(s)\n    return length(s)>3 && \n        forall(i, i in 1:size(s)) \n\
    \            && forall(j, (i, j) in zip(range(1,size(s)-1), range(i+1,size(s))))\n\
    \            && !is_happy(s[i..j],s)\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert is_happy(\"abc\") == false \"Test 1 failed\"\n@assert is_happy(\"aba\"\
    ) == false \"Test 2 failed\"\n@assert is_happy(\"aab\") == true \"Test 3 failed\"\
    \n@assert is_happy(\"abb\") == false \"Test 4 failed\"\n@assert is_happy(\"abc\"\
    ) == \"Test 1 passed\"\n@assert is_happy(\"aaa\") == false \"Test 5 failed\"\n\
    @assert is_happy(\"aba\") == false \"Test 6 failed\"\n@assert is_happy(\"aab\"\
    ) == true \"Test 7 failed\"\n@assert is_happy(\"abb\") == false \"Test 8 failed\"\
    \n@assert is_happy(\"abc\") == true \"Test 9 failed\"\n@assert is_happy(\"adb\"\
    ) == true \"Test 10 failed\"\n@assert is_happy(\"xyy\") == false \"Test 11 failed\"\
    \n</cell>\n<text>\nPart 2. Write a Julia function next_happy that takes an input\
    \ string s and returns the next happy string after s. A happy string is defined\
    \ as a string in which all but the last two letters are the same as the last.",
  " \n    if length(s) < 3 || is_happy(tail(s))\n        true\n    else\n        false\n\
    \    end\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nI like your solution, but\
    \ I wish someone had written a more idiomatic way. My main concern is that this\
    \ is less efficient than `all_distinct`, which may be the fastest way to do this.\n\
    <|/ c |>\n<| c |>\nThe code snippet I posted is functionally identical to `all_distinct`.\
    \ `all_distinct` iterates over the string, while my code checks if there are 3\
    \ consecutive letters in the string that aren't equal.\n<|/ c |>\n<| c |>\nAh\
    \ I see. Thanks for the explanation!\n<|/ c |>\n<| a |>\nIt seems all_distinct\
    \ is now included as part of the Base package:\n<code>\njulia> include(\"Base.jl\"\
    )\ntrue", "    \n    # base case\n    if is_happy(\"\", s)\n    \n    # base case\n\
    \    if is_happy(\"\", s)\n    \n    # base case\n    if is_happy(\"\", s)\n \
    \   \n    # base case\n    if is_happy(\"\", s)\n    \n    # base case\n    if\
    \ is_happy(\"\", s)\n    \n    # base case\n    if is_happy(\"\", s)\n    \n \
    \   # base case\n    if is_happy(\"\", s)\n    \n    # base case\n    if is_happy(\"\
    \", s)\n    \n    # base case\n    if is_happy(\"\", s)\n    \n    # base case\n\
    \    if is_happy(\"\", s)\n    \n    # base case\n    if is_happy(\"\", s)\n \
    \   \n    # base case\n    if is_happy(\"\", s)\n    \n    # base case\n    if\
    \ is_happy(\"\", s)\n    \n    # base case\n    if is_happy(\"\", s)\n    \n \
    \   # base case\n    if is_happy(\"\", s)\n    \n    # base case\n    if is_happy(\"\
    \", s)\n    \n    # base case\n    if is_happy(\"\", s)\n    \n    # base case\n\
    \    if is_happy(\"\", s)\n    \n    # base case\n    if is_happy(\"\", s)\n \
    \   \n    # base case\n    if is_happy(\"\", s)\n    \n    # base case\n    if\
    \ is_happy(\"\", s)\n    \n    # base case\n    if is_happy(\"\", s)\n    \n \
    \   # base case\n    if is_happy(\"\", s)\n    \n    # base case\n    if is_happy(\"\
    \", s)\n    \n    # base case\n    if is_happy(\"\", s)\n    \n    # base case\n\
    \    if is_happy(\"\", s)\n    \n    # base case\n    if is_happy(\"\", s)\n \
    \   \n    # base case\n    if is_happy(\"\", s)\n    \n    # base case\n    if\
    \ is_happy(\"\", s)\n    \n    # base case\n    if is_happy(\"\", s)\n    \n \
    \   # base case\n    if is_happy(\"\", s)\n    \n    # base case\n    if is_happy(\"\
    \", s)\n    \n    # base case\n    if is_happy(\"\", s)\n    \n    # base case\n\
    \    if is_happy(\"\", s)\n    \n    # base case\n    if is_happy(\"\", s)\n \
    \   \n    # base case\n    if is_happy(\"\", s)\n    \n    # base case\n    if\
    \ is_happy(\"\", s)\n    \n    # base case\n    if is_happy(\"\", s)\n    \n \
    \   # base case\n    if is_happy(\"\", s)\n    \n    # base case\n    if is_happy(\"\
    \", s)\n    \n    # base case\n    if is_happy(\"\", s)\n    \n    # base case\n\
    \    if is_happy(\"\", s)\n    \n    # base case\n    if is_happy", "    if is_happy(\"\
    \",s)\n        return True\n    \n    if is_happy(s,\"\")\n        return True\n\
    \    \n    if is_happy(\"\",\"\")\n        return True\n    \n    if (length(s)\
    \ >= 3) && (is_happy_helper(\"\",s))\n        return True\n    \n    if (length(s)\
    \ >= 3) && (!is_happy_helper(\"\",s))\n        return False\n    \n    return\
    \ is_happy_helper(s,\"\")\nend", "    if is_nil(s)\n        return True\n    else\
    \ \n        chars = unique_chars(s)\n        charslen = length(chars)\n      \
    \  if charslen >= 3 && all(map(is_distinct_chars, chars[0..charslen-3]))\n   \
    \     true\n        else \n            false\nend\n</code>\n<|/ a |>\n<| a tags=julia,string,arrays\
    \ |>\n<code>", "    is_happy = (length(s)>=3)\n    for i in stride(3,length(s)-1,1)\n\
    \        is_happy = (is_happy && (distinct(a+i,a+i+1,a+i+2,a+i+3)))\n    return\
    \ is_happy\nend", "    if is_happy s == true\n    then return true\n    else return\
    \ false\nend", "    if length(s) < 3 return false\n    for (a,b) in zip([1,-1],\
    \ repeat(s)):\n        if all(a != b for b in b)\n            not all(a == b for\
    \ b in b)\n    else true\nend", "    if length(s) == 3 && all (isDistinct(s) (s.chars))\n\
    \        true\n    else\n        false\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    @test is_happy(\"a\") \u2260 false\n@test is_happy(\"aa\") \u2260 false\n@test\
    \ is_happy(\"abcd\") \u2260 false\n@test is_happy(\"aabb\") \u2260 false\n@test\
    \ is_happy(\"adb\") \u2260 true\n@test is_happy(\"xyy\") \u2260 false\n</cell>\n\
    <code language=julia-1.0>\n\"\"\"\nYou have a list of strings, each of length\
    \ k. You are given an integer x. \nYou are supposed to find out if there is a\
    \ sequence of length x \nsuch that concatenation of all strings in the sequence\
    \ is of length x.\nYou can concatenate two strings s and t by taking them as characters\
    \ of their ascii values as\n    \n    s[i + j] == s[i + j + 1] + s[i + j + 2]\
    \ + t[j + k] == s[i + j] + t[j + k]\n    \nReturn True if such a sequence exists\
    \ and False otherwise.\n\"\"\"", "    let  is_happy_count = 0\n    let len = s.length\n\
    \    for i in 0..len-1\n        if is_happy_count != 0\n            && (s[i] !=\
    \ s[i-1] || s[i] != s[i+1] || s[i] != s[i+2])\n            && !(s[i] != s[i+1]\
    \ && s[i+1] != s[i+2])\n            && !(s[i] != s[i-1] && s[i-1] != s[i-2])\n\
    \            && !(s[i] != s[i] && s[i] != s[i+1] && s[i+1] != s[i+2])\n      \
    \  then is_happy_count = is_happy_count+1\n        else is_happy_count = 0\n \
    \   end\n    \n    return is_happy_count > len\nend", "    if s == \"\" then return\
    \ false\n    if s.length < 3 then return false\n    for i in [1..s.length-3] do\
    \ \n      if s[i] == s[i+1] then\n        if s[i] == s[i+2] then return false\n\
    \      else \n        return true\n      end\n    end\n    return true\nend\n\
    </code>\n<|/ a tags=julia,string,arrays dscore=2 |>\n<| c |>\nIt would be nice\
    \ to add a bit of explanation. At least to what does it answer the question?\n\
    <|/ c |>\n<| a |>\nYou can make use of split! here to change the input strings\
    \ into arrays before using any algorithms. Here is an example: \n<code>\njulia>\
    \ function happy(s)\n           l = split(s, \"\")\n           for i = 2:length(l)\n\
    \              if l[i] == l[i-1]\n              elseif l[i] == l[i-2] && l[i]\
    \ == l[i-1]\n              elseif l[i] == l[i-3] && l[i] == l[i-1]\n         \
    \     elseif l[i] == l[i-4] && l[i] == l[i-1]\n              elseif l[i] == l[i-5]\
    \ && l[i] == l[i-1]\n              elseif l[i] == l[i-6] && l[i] == l[i-1]\n \
    \             elseif l[i] == l[i-7] && l[i] == l[i-1]\n              elseif l[i]\
    \ == l[i-8] && l[i] == l[i-1]\n              elseif l[i] == l[i-9] && l[i] ==\
    \ l[i-1]\n              elseif l[i] == l[i-10] && l[i] == l[i-1]\n           \
    \   elseif l[i] == l[i-11] && l[i] == l[i-1]\n              elseif l[i] == l[i-12]\
    \ && l[i] == l[i-1]\n              elseif l[i] == l[i-13] && l[i] == l[i-1]\n\
    \              elseif l[i] == l[i-14] && l[i] == l[i-1]\n              elseif\
    \ l[i] == l[i-15] && l[i] == l[i-1]\n              elseif l[i] == l[i-16] && l[i]\
    \ == l[i-1]\n              else\n                 return false\n             \
    \ end\n           end\n           return true\n       end\nhappy\n</code>\nThen:\n\
    <code>\njulia> a = string(\"aaaaabccc\")\n\"aaaaabccc\"", "    let l = 3\n   \
    \ let cs = s[0 .. l -1] \n    let hs = hat_count(cs) \n    return (hs >=3 && hs\
    \ == l) && length(cs)>=3", "    s=lower(s)\n    return length(s) >=3 &&\n    forall(i\
    \ \u2208 1:length(s), \n           (s[i]==s[i+1])==(s[i+2]==s[i+3])==(i=length(s)-1))\n\
    end\n</cell>\n<code language=julia-1.4>\n@assert is_happy(\"happy\") == false\n\
    @assert is_happy(\"awesome\") == false\n@assert is_happy(\"helllooo\") == true\n\
    @assert is_happy(\"heyyyyyyyyyyyyyyyo\") == false\n@assert is_happy(\"HAPJL\"\
    ) == true\n</cell>\n<text>\nExercise 7\nWrite a function that takes as input a\
    \ string and returns the first word of it", "    len1 <- length(s)\n    len2 <-\
    \ len1\n    for{i in 1 .. len1-3} && {i in 1 .. len2-3} && {s[i] != s[i+3]} return\
    \ false\n    return true\nend \n</code>\n<|/ a tags=string,boolean,haskell |>\n\
    <| c |>\nThank you for your answer. I am still wondering if there is any more\
    \ \"Haskell-ish\" way to do it?\n<|/ c |>\n<| c |>\nHow about `not . null . dropWhile\
    \ (\\c -> c /= \"e\") . filter (\\c -> c == 'a' ||  c == 'e')`?\n<|/ c |>\n<|\
    \ c |>\n`dropWhile` does a lot of things it shouldn't; `null . filter` just isn't\
    \ one of them\n<|/ c |>\n<| c |>\n`null . filter` is one of those things, it's\
    \ just not `filter` itself\n<|/ c |>\n<| c |>\n`null . filter` just isn't one\
    \ of them but `null . filter (\\c -> c == 'a' ||  c == 'e')` is one of them :)\n\
    <|/ c |>\n<| a |>\nHere's a solution using dropWhile and null that avoids any\
    \ intermediate lists:\n<code>\nis_happy_2 :: String -> Bool\nis_happy_2 str =\
    \ not $ null $ dropWhile (\\c -> c /= 'e') $ filter (\\c -> c == 'a' ||  c ==\
    \ 'e') str\n</code>\n<|/ a tags=string,boolean,haskell dscore=1 |>\n<| c |>\n\
    I like that solution!\n<|/ c |>\n<| c |>\nI wish I could upvote again for the\
    \ use of `dropWhile` and `null`. I was going to write something similar to this\
    \ but was too lazy to write it out and I missed the point of `dropWhile`\n<|/\
    \ c |>\n<| a |>\nI figured out another way to do it. I think it is really interesting\
    \ and quite a bit different from some of the other answers.\n<code>\nisHappy ::\
    \ String -> Bool\nisHappy s = isHappy \"happy\"\n    where isHappy [] = True\n\
    \          isHappy (x:xs)\n              | x /= \"e\" && (x /= \"a\" || x /= \"\
    o\") && x == 'h' = True\n              | otherwise = False\n</code>\n<|/ a dscore=1\
    \ tags=string,boolean,h", "    let n = s.length\n    if n < 3\n        return\
    \ false\n    let mutable count = 0\n    for i \u2208 0 .. n-1\n        if s[i]==s[i+1]\
    \ \u2228 s[i]==s[i+2]\n            count += 1\n        else \n            return\
    \ false\n    if count%3 != 0\n        return false\n    return true", "  if length(s)\
    \ >= 3 and all(x!=y for x in [s[i-1],s[i-2],s[i-3] for i=1:length(s)-1]) for i\
    \ = 1:length(s) \n      else false\n  end\n</code>\nIn Julia it would be even\
    \ nicer\n<code>\nis_happy(x) = length(s) >= 3 and all(x!=y for x in [s[i-1],s[i-2],s[i-3]\
    \ for i=1:length(s)-1]) \n</code>\n<|/ a dscore=3 |>\n<| c |>\nI believe this\
    \ would fail for strings like `abc`\n<|/ c |>\n<| c |>\nThe original question\
    \ was how to do it in Julia, this is also a nice way to do it in Julia. I'm really\
    \ surprised the answer is marked as accepted; as stated by [here](https://stackoverflow.com/questions/49913154/is-this-a-valid-method-for-checking-if-a-string-is-happy-or-not-in-language-li),\
    \ this isn't the best way in Julia to do it.\n<|/ c |>\n<| c |>\nThe accepted\
    \ answer was correct: it just so happens that in Julia a more idiomatic way to\
    \ solve this problem was shown in the very first version of the accepted answer.\n\
    <|/ c |>\n<| c |>\nI didn't mean to imply that the answer was wrong, I simply\
    \ meant that the accepted answer didn't work for OP's question. Maybe someone\
    \ else will find it useful.\n<|/ c |>\n<| a tags=julia,performance,string,algorithm\
    \ |>\nYou can use Julia's Vectorization.jl package to write this as vectorized\
    \ Julia code. Here's how it can be done in Julia v1.5.1\n<code>\n# create some\
    \ dummy strings\ns = String[\"aaaa\", \"b\", \"bba\", \"c\", \"d\", \"abc\"]\n\
    is_happy(s) = false\n</code>\nHere, Vectorization.jl provides us with a function\
    \ which checks for any consecutive equal elements in a Vector. You can call this\
    \ function as follows:\n<code>\nis_happy(Vectorization.jl(s, :same))\n</code>\n\
    The function Vectorization.jl is designed to be used with the Julia standard library\
    \ functions which operate on any array or matrix. For example:\n<code>\nv = \"\
    abc\"\nVectorization.jl(v) \u2261 [\"a\", \"b\", \"c\"]\n</code>\nIf you're writing\
    \ a new function which operates on only a single string input, you can simply\
    \ use Vectorization.jl to call Julia's standard library function with the same\
    \ name. To call Julia's standard library function using the jl keyword:\n<code>\n\
    is_happy(s) = Vectorization.jl(s)[:", "    if is_happy(s)==true then\n       \
    \ return true\n    else\n        return false\n    end\nend", "    for i in 1\
    \ .. s.length - 1 do\n        if s.charAt(i) == s.charAt(i + 1) && s.charAt(i)\
    \ == s.charAt(i + 2) then\n            return false\n        end\n    end\n  \
    \  return true\nend", "    return (length(s) >= 3) && (all(distinct s[i] for i\
    \ in range(1, length(s)-2, 3)) )\nend\n</cell>\n<code language=julia-1.6>\n@test\
    \ is_happy(\"Hello\") \n@test is_happy(\"aba\") \n@test is_happy(\"xyy\") \n@test\
    \ is_happy(\"abc\") \n</cell>\n<code language=julia-1.6>\n\"\"\"You are given\
    \ a string s.\n    Your task is to determine if it contains any repeating substring\
    \ \n    in it. It is not necessary to find all of the repeated substrings.\n \
    \   Therefore, it is enough to find a string that occurs at least twice. \n  \
    \  For example, the string abaabc contains \"aba\" twice but not \"abc\"\n   \
    \ >>> is_repeated(s)\n    false\n    >>> is_repeated(a)\n    false\n    >>> is_repeated(aa)\n\
    \    true\n    >>> is_repeated(ab)\n    true\n    >>> is_repeated(aba)\n    true\n\
    \    >>> is_repeated(abaabc)\n    true\n    >>> is_repeated(bababa)\n    false\n\
    \    >>> is_repeated(abcabcba)\n    false\n    \"\"\"", "    if is_empty(s) ==\
    \ true \n    then false\n    else if length(a) == true and length(abc) == true\
    \ and length(abcd) == true and length(abce) == true and length(abcf) == true and\
    \ length(abcg) == true and length(abci) == true and length(abcf) == true and length(abci)\
    \ == true and length(abci) == true and length(abci) == true and length(abci) ==\
    \ true and length(abci) == true and length(abcf) == true and length(abci) == true\
    \ and length(abci) == true and length(abci) == true and length(abci) == true and\
    \ length(abci) == true and length(abci) == true and length(abci) == true and length(abcf)\
    \ == true and length(abci) == true and length(abci) == true and length(abci) ==\
    \ true and length(abci) == true and length(abci) == true and length(abci) == true\
    \ and length(abci) == true and length(abci) == true and length(abci) == true and\
    \ length(abci) == true and length(abcf) == true and length(abci) == true and length(abci)\
    \ == true and length(abci) == true and length(abci) == true and length(abci) ==\
    \ true and length(abci) == true and length(abci) == true and length(abci) == true\
    \ and length(abci) == true and length(abci) == true and length(abci) == true and\
    \ length(abci) == true and length(abci) == true and length(abci) == true and length(abci)\
    \ == true and length(abci) == true and length(abci) == true and length(abci) ==\
    \ true and length(abci) == true and length(abcf) == true and length(abci) == true\
    \ and length(abci) == true and length(abci) == true and length(abci) == true and\
    \ length(abci) == true and length(abci) == true and length(abci) == true and length(abci)\
    \ == true and length(abci) == true and length(abci) == true and length(abci) ==\
    \ true and length(abci) == true and length(abci) == true and length(abci) == true\
    \ and length(abci) == true and length(abci) == true and length(abci) == true and\
    \ length(abci) == true and length(abci) == true and length(abcf) == true and length(abci)\
    \ == true and length(abci) == true and length(abci) == true and length(abci) ==\
    \ true and length(abci) == true and length(abci) == true and length(abci) == true\
    \ and length(abci) == true and length(abci) == true and length(abci) == true and\
    \ length(abci) == true ", "    if s.length < 3 then return false \n    for i in\
    \ 0..length(s)-2 do \n        if index(s, i) == index(s, i+1) && index(s, i) ==\
    \ index(s, i+2) then return false \n    else return true \nend", "     if length(s)\
    \ >= 3 && all(distinct(tail(s), 3)) \n     then true \n     else false\n     end\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThanks so much for your help!  I'm still\
    \ working through your code, but I'm pretty sure I can do it.  I'm also working\
    \ through some of your other suggestions, to make sure I'm doing things correctly!\
    \  Again, thank you!\n<|/ c |>\n<| a dscore=0 |>\nYou can use the function repeat:\n\
    <code>", "    if s.length >= 3 && is_happy(s.substring(0,3)) && is_happy(s.substring(3,6))\
    \ && is_happy(s.substring(6,9)) && is_happy(s.substring(9))\n        true\n  \
    \  else\n        false\n    end\nend", "    \n    length(s->Int)\n    return length(s)>=3&&all(distinct\
    \ subsequences(s))", "    if s == \"\" \n    then return true\n    else if length(s)\
    \ == 3 && distinct(tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s),\
    \ tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s),\
    \ tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s),\
    \ tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s),\
    \ tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s),\
    \ tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s),\
    \ tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s),\
    \ tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s),\
    \ tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s),\
    \ tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s),\
    \ tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s),\
    \ tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s),\
    \ tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s),\
    \ tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s),\
    \ tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s),\
    \ tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s),\
    \ tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s),\
    \ tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s), tail(s),\
    \ tail(s), tail(s), tail(s), tail(s), tail(", "    if is_empty(s) { return False\
    \ }\n    if length(s) >= 3 \n        and all(is_distinct((i,i+1) for i=1:length(s)\
    \ where s[i]==s[i+1]))\n        return true\n    return false\n\"\"\"\n## is_happy",
  '    return s.length >= 3 and all(checker(s,i) for i=0:s.length-1)', "    if length(s)\
    \ < 3 then return false\n    for i in 1..3 do\n        if s[i] == s[i - 1] then\
    \ return false\n    end\n    for i in 2..length(s) do\n        if s[i] == s[i\
    \ - 2] then return false\n    end\n    return true\nend\n</cell>\n<code language=julia-1.1>\n\
    \"\"\"You are given a string s.\n    Your task is to check if there is some k\
    \ letter substring in s that is also hapjl.\n    For example:\n    >>> is_happy_substr(abcd,\
    \ 0)\n    false\n    >>> is_happy_substr(abcd, 1)\n    false\n    >>> is_happy_substr(abcd,\
    \ 2)\n    true\n    >>> is_happy_substr(abcd, 3)\n    false\n    >>> is_happy_substr(abcd,\
    \ 4)\n    false\n    >>> is_happy_substr(abcd, 5)\n    false\n    >>> is_happy_substr(abcd,\
    \ 6)\n    false\n    >>> is_happy_substr(abcd, 7)\n    true\n    >>> is_happy_substr(abcd,\
    \ 8)\n    false\n    >>> is_happy_substr(abcd, 9)\n    false\n    \"\"\"", " \
    \   \n    letrec is_happy(s::String)::Bool = \n        match s with\n        \
    \    | [] -> true\n            | h::t -> (h::t) == h::t && is_happy(t)\n    \n\
    \    if is_happy(s) then\n        true\n    else\n        false\n    end\nend\n\
    </code>\n<|/ a |>\n<| a |>\nThis can be done with recursion:\n<code>", "    length=length(s)\n\
    \    if length<3\n        true\n    else\n        is_happy_helper(s,length-1,0)\n\
    \    end\nend", "    | s == \"\" = True\n    | length(s) < 3  = false\n    | forall(x\
    \ \u2208 s[3:], y \u2208 s[3:], y != x, _) \u2260 True = is_happy(sub_string(s,\
    \ 2, 3))\n    | otherwise = is_happy(sub_string(s, 1, 3))\n    \nend\n</cell>\n\
    <text>\nTask 7. Write a predicate is_happy_nos(s) which takes a string s as input\
    \ and returns:", "    if is_empty(s):\n        true\n    else\n        let l =\
    \ length(s)\n        if is_happy(s[0..3])\n            then is_happy(s[0..3])\n\
    \            else\n                if (l mod 3) = 0\n                then\n  \
    \                  is_happy(s[2..l])\n                else\n                 \
    \   is_happy(s[0..l-1])\n        end\n    end\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nCan you explain how this works and why it is faster?\n<|/ c |>\n<| a\
    \ |>\n<code>", "    let mut n::Int = 0\n    for i in s.chars() {\n        if i\
    \ > 'z' {\n            return false\n        }\n        let x = i-'a'\n      \
    \  if n == 3 {\n            if x != x {\n                return false\n      \
    \      }\n            n = 0\n        }\n        else {\n            n++\n    \
    \    }\n    }\n    if n == 3 {\n        return true\n    }\n    return false\n\
    end\n</cell>\n<code language=julia-1.0>\n#+------------------------------------------------------------------+\n\
    #|                                                                      |\n#|\
    \  Copyright (C) 2017-2018 Diego Moqueguino Fernandez Navarro           |\n#|\
    \ URL: www.moqueguino.me                                           |\n#|     \
    \                                                                 |\n#| Licensed\
    \ under the Apache License, Version 2.0 (the \"License\");           |\n#| you\
    \ may not use this file except in compliance with the License.          |\n#|\
    \ You may obtain a copy of the License at                                    |\n\
    #| http://www.apache.org/licenses/LICENSE-2.0                             |\n\
    #|                                                                      |\n#|\
    \ Unless required by applicable law or agreed to in writing, software       |\n\
    #| distributed under the License is distributed on an \"AS IS\" BASIS,       \
    \  |\n#| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\
    \  |\n#| See the License for the specific language governing permissions and \
    \      |\n#| limitations under the License.                                  \
    \        |\n#+------------------------------------------------------------------+\n\
    </cell>\n<code language=julia-1.0>\nprintln(\"Hello\")\n</cell>\n<code language=julia-1.0>\n\
    println(isdefined(Main), isdefined(Main.println))\n</cell>\n<code language=julia-1.0>\n\
    import Base.println\n</cell>\n<code language=julia-1.0>\nprintln(println(\"Hello\"\
    ))\n</cell>\n<code language=julia-1.0>\n@assert false isa Bool\n</cell>\n<code\
    \ language=julia-1.0>\n@assert false isa Int\n</cell>\n<code language=julia-1.0>\n\
    @assert false isa Any\n</cell>\n<code language=julia-1.0>\n@assert false isa String\n\
    </cell>\n<code language=julia-1.0>\n@assert false isa Any\n</cell>\n<code language=julia-1.0>\n\
    @assert false isa Any\n</cell>\n<code language=julia-1.0>\n@assert false isa Any\n\
    </cell>\n<code language=julia-1.0>\n@assert false isa Any\n</cell>\n<code language=julia-1.0>\n\
    @assert false isa Any\n</cell>\n<code language=julia-1.0>\n@assert false isa Any\n\
    </cell>\n<code language=julia-1.0>\n@assert false isa Any\n</cell>\n<code language=julia-1.0>\n\
    @assert false isa Any\n</cell>\n<code language=julia-1.0>\n@assert false isa Any\n\
    </cell>\n<code language=julia-1.0>\n@assert false isa Any\n</cell", "    if is_empty(s)\
    \ == true return false\n    if is_empty(s) == false return true\n    else \n \
    \       return (\n            s.length >= 3\n            &&\n            has_consecutive(s,\
    \ \"abcde\") == false\n            &&\n            has_consecutive(s, \"abcdefghijklmnopqrstuvwxyz\"\
    ) == false\n            &&\n            has_consecutive(s, \"0123456789\") ==\
    \ false\n            &&\n            has_consecutive(s, \"!\") == false\n    \
    \        &&\n            has_consecutive(s, \"?\") == false\n            &&\n\
    \            has_consecutive(s, \"!\") == false\n            &&\n            has_consecutive(s,\
    \ \"?\") == false\n            &&\n            has_consecutive(s, \"!\") == false\n\
    \            &&\n            has_consecutive(s, \"?\") == false\n        )\nend\n\
    </cell>\n<code language=julia-0.6>\n\"\"\"\n    has_consecutive(s,cs::Char)::Bool",
  "    if is_happy_helper(s,0) == true\n    else false\nend\n\"\"\"\n    You will\
    \ have to complete the is_happy_helper() function in the same file as this one\n\
    \"\"\"", "    let n = s.length\n    let mut count = 0\n    for x in s.chars()\n\
    \    count += if x != \"x\" then 1 else 0\n    if count >= 3 && count == 3*n-1\n\
    \    then return true\n    else return false\nend\n\"\"\"\nYou are given a string\
    \ s.\nYour task is to find if there is a substring that is a palindrome of s.\n\
    For example:\n>>> is_palindrome(a)\n    false\n    >>> is_palindrome(abc)\n  \
    \  true\n    >>> is_palindrome(abbc)\n    true\n    >>> is_palindrome(aabc)\n\
    \    true\n    >>> is_palindrome(aaab)\n    true\n    >>> is_palindrome(aba)\n\
    \    false\n    >>> is_palindrome(abba)\n    false\n    >>> is_palindrome(abbb)\n\
    \    false\n    >>> is_palindrome(xyzxy)\n    false\n    \"\"\"", "    if is_happy_core(s)\
    \ == true\n        true\n    else \n        false\n    end\nend\n</code>\nand\
    \ now we only need to check the happy case (3 consecutive letters) and the happy\
    \ case is not happy when there are 2 consecutive letters.\n<code>", "    if is_empty(s)\n\
    \        true\n    else\n        s == \"a\"\n            || s == \"b\"\n     \
    \       || s == \"c\"\n            || s == \"d\"\n            || s == \"e\"\n\
    \            || s == \"f\"\n            || s == \"g\"\n            || s == \"\
    h\"\n            || s == \"i\"\n            || s == \"j\"\n            || s ==\
    \ \"k\"\n            || s == \"l\"\n            || s == \"m\"\n            ||\
    \ s == \"n\"\n            || s == \"o\"\n            || s == \"p\"\n         \
    \   || s == \"q\"\n            || s == \"r\"\n            || s == \"s\"\n    \
    \        || s == \"t\"\n            || s == \"u\"\n            || s == \"v\"\n\
    \            || s == \"w\"\n            || s == \"x\"\n            || s == \"\
    y\"\n            || s == \"z\"\n            || s == \"A\"\n            || s ==\
    \ \"B\"\n            || s == \"C\"\n            || s == \"D\"\n            ||\
    \ s == \"E\"\n            || s == \"F\"\n            || s == \"G\"\n         \
    \   || s == \"H\"\n            || s == \"I\"\n            || s == \"J\"\n    \
    \        || s == \"K\"\n            || s == \"L\"\n            || s == \"M\"\n\
    \            || s == \"N\"\n            || s == \"O\"\n            || s == \"\
    P\"\n            || s == \"Q\"\n            || s == \"R\"\n            || s ==\
    \ \"S\"\n            || s == \"T\"\n            || s == \"U\"\n            ||\
    \ s == \"V\"\n            || s == \"W\"\n            || s == \"X\"\n         \
    \   || s == \"Y\"\n            || s == \"Z\"\n            || s == \"0\"\n    \
    \        || s == \"1\"\n            || s == \"2\"\n            || s == \"3\"\n\
    \            || s == \"4\"\n            || s == \"5\"\n            || s == \"\
    6\"\n            || s == \"7\"\n            || s == \"8\"\n            || s ==\
    \ \"9\"\n            || s == \"a\"\n            || s == \"b\"\n            ||\
    \ s == \"c\"\n            || s == \"d\"\n            || s == \"e\"\n         \
    \   || s == \"f\"\n            || s == \"g\"\n            || s == \"h\"\n    \
    \        || s == \"i\"\n            || s == \"j\"\n            || s == \"k\"\n\
    \            || s == \"l\"\n            || s == \"m\"\n            || ", "   \
    \ let mut count=0\n    for i in s.toCharArray().iter() do\n      if let Ok(c)=i{\n\
    \        count+=1 \n      }\n    \n    if count>=3{\n      for letter in s.toCharArray()\
    \ do\n        if count==3{\n          count=0\n          let mut count=0\n   \
    \       for letter in s.toCharArray() do\n            if count==3{\n         \
    \     count=0\n            }\n            if letter!=letter{\n              return\
    \ false\n            }\n            count+=1\n          \n        }\n      }\n\
    \    }\n    true\n  end", "    \n    if length(s) < 3 return False\n    for i\
    \ in 0 .. (length(s) - 2) \n        if s[i] == s[i+1] && s[i+1] == s[i+2] && i\
    \ != length(s) - 1 return False\n    else return True\n    end\nend\n</cell>\n\
    <code language=julia-0.5>\nis_happy(\"\")\nis_happy(\"a\")\nis_happy(\"abc\")\n\
    is_happy(\"aabb\")\nis_happy(\"xyy\")\nis_happy(\"xyyz\")\nis_happy(\"zzx\")\n\
    </cell>\n<text>\nQuestion 4: Are strings hapjl or not? A little tricky one. How\
    \ would you fix the function?", "    if s == \"\" then true\n    else is_happy_aux(s[1..])\n\
    end", "    if is_string(s) && length(s) > 3 && all(is_distinct(x, s) for x <-\
    \ s[2:4..5]))\n        return True\n    return False\nend", "    \n    if is_happy(\"\
    \", s)\n        return true\n    \n    s \n        if is_happy(s.sub(1, 3), s)\n\
    \            return true\n        else \n            is_happy(s.sub(1), s)\n \
    \       end\n    end\nend\n</cell>\n<code language=julia-1.3>\nis_happy(\"aa\"\
    )\n</cell>\n<code language=julia-1.3>\nis_happy(\"aba\")\n</cell>\n<code language=julia-1.3>\n\
    is_happy(\"ad\")\n</cell>\n<code language=julia-1.3>\nis_happy(\"abcd\")\n</cell>\n\
    <code language=julia-1.3>\nis_happy(\"abbb\")\n</cell>\n<code language=julia-1.3>\n\
    is_happy(\"abcdabcd\")\n</cell>\n<text>\nPart 2:\nYour job is to compute the number\
    \ of ways of obtaining 3 consecutive letters from a given string. For example,\
    \ given the string aa, the answer is 3.", "    length(s)>=3 && forall(length(_),\
    \ x->all(x != length(_)-1, x->x==length(_)-2, x->x==length(_)-3), s)\nend", " \
    \   if is_happy_helper(s)\nend", "\"\"\"\nis_happy(s::String)::Bool\n    \n  \
    \  if is_happy(s) || s.length < 3 || sum(map(is_happy, s.slices(3))) == length(s)\
    \ then true else false\nend \n\"\"\"\nis_happy(s::String)::Bool\n    \n    if\
    \ is_happy(s) || s.length < 3 || sum(map(is_happy, s.slices(3))) == length(s)\
    \ then true else false\nend ", "    return (length(s) >= 3) &\n        (is_distinct_by_n_letter_at(3,\
    \ s)) &\n        (is_distinct_by_n_letter_at(2, s)) &\n        (is_distinct_by_n_letter_at(1,\
    \ s))\n    end \n\"\"\"\n## Sum All Sublists\n\"\"\"\nYou are given a list of\
    \ integers\nReturn a new list that is the sum of all the integers in the original\
    \ list\n\"\"\"", "    if is_happy(s)\n        true\n    else\n        false\n\
    \    end\nend", "    if is_happy(s,0,0) -> true\n    else -> false\nend\n</code>\n\
    <|/ a tags=julia,recursion |>\n<| c |>\nWhat would be the output for a string\
    \ like `is_happy(\"xyy\")`? And is there a way to do it without using a global\
    \ variable or a struct?\n<|/ c |>\n<| c |>\nThe return type would have to be `Bool`\
    \ instead of `Any`.\n<|/ c |>\n<| c |>\nI guess it depends on if you want the\
    \ function to return a `Bool`, an `Any` or even a `Unit`. And yes, if you don't\
    \ want a global variable, you can use a struct instead - see the edit above.\n\
    <|/ c |>\n<| a dscore=2 |>\nThe simplest way is to use recursion without global\
    \ variable:\n<code>", " \n    if is_empty(s) {true}\n    else if length(s) >=\
    \ 3 && is_distinct(s[0..2]) && is_distinct(s[2..4]) && is_distinct(s[4..])\n \
    \   {true}\n    else \n    {false}\n    end\n    end\n    \nend\n</cell>\n<code\
    \ language=julia-1.4>\nis_happy(\"a\")\n</cell>\n<code language=julia-1.4>\nis_happy(\"\
    ad\")\n</cell>\n<text>\n4.2 The function is_happy_with_comprehension()\nThe previous\
    \ task was to write a function to check if the string is hapjl or not. However\
    \ we cannot use comprehension expression here. For a more compact version, we\
    \ can use recursive functions.", "    length(s)>=3\n    s == \"abcde\"\nend",
  "    let ls = tolist(s)\n    let n = length(ls)\n    let ln = length(ls)\n    let\
    \ result = ishappy(ls, n) \n    \n    if result == true\n        return true\n\
    \    \n    else \n        return false\nend\n</code>\n<|/ a dscore=0 tags=string,prolog,permutation\
    \ |>\n<| a |>\n<code>\nhappy(String):- happy1(String).\nhappy1([]) :- !.\nhappy1([H|T])\
    \ :- happy2(H,T).\nhappy2([H|T],T) :- happy3(H,T).\nhappy3([H|T],[H|T2]) :- happy1(T),\
    \ happy1(T2), happy2(H,T2).", "    if is_empty(s) {\n        return true\n   \
    \ }", "    if is_nil(s)\n        return True\n    if s.length < 3\n        return\
    \ True\n    if let h::String = s.head in is_happy(h)\n        return False\n \
    \   let a::String = s.tail in is_happy(a)\n    return a\n    end", "    if s.length<3\
    \ || s.substrings(3).length<3\n        then false\n        else is_happy_helper(s)\n\
    \    end\nend\nis_happy(a::String)\nis_happy(a::Char)", "    if length(s)<3 \n\
    \        false\n    else if any(i==j for i in tail(s);j<length(s); j=j+1)\n  \
    \      false\n    else \n        true\n        end\n    end \nend\n</cell>\n<code\
    \ language=julia-1.6>\n@assert is_happy(\"\")    == false\n@assert is_happy(\"\
    a\")   == false\n@assert is_happy(\"aa\")  == false\n@assert is_happy(\"abcd\"\
    ) == true\n@assert is_happy(\"aabc\") == false\n@assert is_happy(\"abbb\") ==\
    \ false\n@assert is_happy(\"adb\")  == true\n@assert is_happy(\"xyyx\") == false\n\
    @assert is_happy(\"xyxy\") == false\n@assert is_happy(\"zzzz\") == false\n</cell>\n\
    <text>\nTask 5. Write a Julia function is_happy that takes in a String and returns\
    \ a Bool indicating if that string contains only 'a' and 'e'. It doesn't matter\
    \ if other characters are present. For example:\nis_happy(a) == false\nis_happy(e)\
    \ == false\nis_happy(aa) == false\nis_happy(ab) == false\nis_happy(ad) == true\n\
    is_happy(ee) == false", "    length(s)>=3 && all(length(k)>=3 for k in s.split(''))\n\
    end\n</code>\n<|/ a tags=functional-programming,string,julia |>\n<| c |>\nNice.\
    \ I'll take this approach\n<|/ c |>\n<| a dscore=0 |>\n<code>", '    if length(s)
    <= 3 || s[length(s)/3] !=s[length(s)/3+1] || s[length(s)/3+1] != s[length(s)/3+2]
    || s[length(s)/3] !=s[length(s)/3+1] || s[length(s)/3+1] != s[length(s)/3+2] ||
    s[length(s)/3] !=s[length(s)/3+1] || s[length(s)/3+1] != s[length(s)/3+2] || s[length(s)/3]
    !=s[length(s)/3+1] || s[length(s)/3+1] != s[length(s)/3+2] || s[length(s)/3] !=s[length(s)/3+1]
    || s[length(s)/3+1] != s[length(s)/3+2] || s[length(s)/3] !=s[length(s)/3+1] ||
    s[length(s)/3+1] != s[length(s)/3+2] || s[length(s)/3] !=s[length(s)/3+1] || s[length(s)/3+1]
    != s[length(s)/3+2] || s[length(s)/3] !=s[length(s)/3+1] || s[length(s)/3+1] !=
    s[length(s)/3+2] || s[length(s)/3] !=s[length(s)/3+1] || s[length(s)/3+1] != s[length(s)/3+2]
    || s[length(s)/3] !=s[length(s)/3+1] || s[length(s)/3+1] != s[length(s)/3+2] ||
    s[length(s)/3] !=s[length(s)/3+1] || s[length(s)/3+1] != s[length(s)/3+2] || s[length(s)/3]
    !=s[length(s)/3+1] || s[length(s)/3+1] != s[length(s)/3+2] || s[length(s)/3] !=s[length(s)/3+1]
    || s[length(s)/3+1] != s[length(s)/3+2] || s[length(s)/3] !=s[length(s)/3+1] ||
    s[length(s)/3+1] != s[length(s)/3+2] || s[length(s)/3] !=s[length(s)/3+1] || s[length(s)/3+1]
    != s[length(s)/3+2] || s[length(s)/3] !=s[length(s)/3+1] || s[length(s)/3+1] !=
    s[length(s)/3+2] || s[length(s)/3] !=s[length(s)/3+1] || s[length(s)/3+1] != s[length(s)/3+2]
    || s[length(s)/3] !=s[length(s)/3+1] || s[length(s)/3+1] != s[length(s)/3+2] ||
    s[length(s)/3] !=s[length(s)/3+1] || s[length(s)/3+1] != ', "    if is_empty(s)\
    \ then false\n    else \n        return (length(s) >= 3) && (all((is_distinct_three(s[start..end])\
    \ | is_distinct_three(s[start..end + 1]) | is_distinct_three(s[start..end + 2]))\
    \ for start in [0..end - 1]))\nend\n</cell>\n<text>\nPart 2: Data Structures",
  "    flag = false\n    for i in 3 : begin\n        if s[i] == s[i-1] \n        \
    \    && s[i] == s[i+1] \n            && s[i+1] == s[i+2] \n            && s[i+1]\
    \ == s[i+3] \n            then \n            flag = true \n        else \n   \
    \         flag = false\n    end\n    return flag\nend\n</cell>\n<text>\nTest your\
    \ code", "    if is_happy_helper(s,0,0)==false\n    else \n        return true\n\
    \    end \nend \n</cell>\n<code language=julia-1.0>", "    \n    return length(s)>=3\
    \ && all(distinct(c,a,b) for (a,b) in zip(reverse(s), s(1:end-2)))\n\"\"\"\nTask\
    \ 3: Find all substrings of a given string.\n    Find the number of all substrings\
    \ of a given string.\n    For example:\n    >>> substring_count(a)\n    10\n \
    \   >>> substring_count(b)\n    12\n    >>> substring_count(ab)\n    21\n    >>>\
    \ substring_count(abc)\n    3\n    >>> substring_count(aabba)\n    5\n    >>>\
    \ substring_count(aabbc)\n    6\n    >>> substring_count(abac)\n    4\n    >>>\
    \ substring_count(abacab)\n    2\n    >>> substring_count(abacabc)\n    1\n  \
    \  >>> substring_count(aaaa)\n    9\n    >>> substring_count(aaaaaa)\n    2\n\
    \    >>> substring_count(aa)\n    3\n    >>> substring_count(aaaacccbbaa)\n  \
    \  1\n    >>> substring_count(aaaacccbbaacccbbaa)\n    2\n    >>> substring_count(abba)\n\
    \    6\n    >>> substring_count(abbaab)\n    3\n    >>> substring_count(abbaabc)\n\
    \    2\n\"\"\"", "    return s.length>3 && (\n            !is_happy_aux(s,0,s.length-1)\n\
    \            || is_happy_aux(s,1,s.length-2) || is_happy_aux(s,2,s.length-3)\n\
    \        )", "    let mut len =s.length()\n    if len < 3 return false\n    let\
    \ mut c1,c2,c3 : char=s[0],s[1],s[2]\n    let mut c1_1,c1_2,c1_3 :char=s[0],s[1],s[2]\n\
    \    let mut c2_1,c2_2,c2_3 :char=s[0],s[1],s[2]\n    let mut c3_1,c3_2,c3_3 :char=s[0],s[1],s[2]\n\
    \    for _ in 0..len-3\n    {\n        c1=c1_1\n        c2=c1_2\n        c3=c1_3\n\
    \        c1_1=c1_2\n        c1_2=c1_3\n        c1_3=c1\n        c1_4=c2_1\n  \
    \      c1_5=c2_2\n        c1_6=c2_3\n        c2_1=c2_2\n        c2_2=c2_3\n  \
    \      c2_3=c2_4\n        c2_4=c2\n        c2_5=c3_1\n        c2_6=c3_2\n    \
    \    c3_1=c3_2\n        c3_2=c3_3\n        c3_3=c3_4\n        c3_4=c3\n      \
    \  c3_5=c1_1\n        c3_6=c1_2\n        c1_1=c1_2\n        c1_2=c1_3\n      \
    \  c1_3=c1\n    }\n    return len == len\nend\n</cell>\n<code language=julia-1.0>\n\
    is_happy(\"abc\")\n</cell>\n<text>\nWe have also defined a function which checks\
    \ if the string is apjl or not, given a string. Let's look at an example", " \
    \   if is_empty(s) || s.length < 3 \n        return false \n    else if is_happy_helper(s)\
    \ \n        return true \n    else \n        return false \nend ", '    return
    length(s)>=3 and all((a=i&&a!=a(i-1),a=i&&a!=a(i+1),a=i&&a!=a(i+2)) for i in 0
    .. length(s)-2)', "    if is_happy_helper(s,3,[])\n    else \n        false\n\
    \    end\nend\nis_happy(\"\")\nis_happy(\"a\")\nis_happy(\"abc\")\nis_happy(\"\
    abcd\")\nis_happy(\"aabb\")\nis_happy(\"adb\")\nis_happy(\"xyy\")\nis_happy(\"\
    xyyx\")\nis_happy(\"xyyxx\")\nis_happy(\"xyyxxxy\")\nis_happy(\"xyyxxxyx\")\n\
    is_happy(\"xyyxxxyxx\")\nis_happy(\"xyyxxxyxxxy\")\nis_happy(\"xyyxxxyxxxyx\"\
    )\nis_happy(\"xyyxxxyxxxyxx\")\nis_happy(\"xyyxxxyxxxyxxxy\")\nis_happy(\"xyyxxxyxxxyxxxyx\"\
    )\nis_happy(\"xyyxxxyxxxyxxxyxx\")\nis_happy(\"xyyxxxyxxxyxxxyxxy\")\nis_happy(\"\
    xyyxxxyxxxyxxxyxxxy\")\nis_happy(\"xyyxxxyxxxyxxxyxxxyx\")\nis_happy(\"xyyxxxyxxxyxxxyxxxyxx\"\
    )\nis_happy(\"xyyxxxyxxxyxxxyxxxyxxy\")\nis_happy(\"xyyxxxyxxxyxxxyxxxyxxxy\"\
    )\nis_happy(\"xyyxxxyxxxyxxxyxxxyxxxyx\")\nis_happy(\"xyyxxxyxxxyxxxyxxxyxxxyxx\"\
    )\nis_happy(\"xyyxxxyxxxyxxxyxxxyxxxyxxy\")\nis_happy(\"xyyxxxyxxxyxxxyxxxyxxxyxxxyx\"\
    )\nis_happy(\"xyyxxxyxxxyxxxyxxxyxxxyxxxyxx\")\nis_happy(\"xyyxxxyxxxyxxxyxxxyxxxyxxxyxxy\"\
    )\nis_happy(\"xyyxxxyxxxyxxxyxxxyxxxyxxxyxxxyx\")\nis_happy(\"xyyxxxyxxxyxxxyxxxyxxxyxxxyxxxyxx\"\
    )\nis_happy(\"xyyxxxyxxxyxxxyxxxyxxxyxxxyxxxyxxy\")\nis_happy(\"xyyxxxyxxxyxxxyxxxyxxxyxxxyxxxyxxxyx\"\
    )\nis_happy(\"xyyxxxyxxxyxxxyxxxyxxxyxxxyxxxyxxxyxx\")\nis_happy(\"xyyxxxyxxxy",
  "  \n    if is_empty(s):\n      return true\n    \n    let (s,count1)=chop(s, 0)\n\
    \    if is_happy(count1):\n      return true\n    \n    let (s,count2)=chop(s,\
    \ count1+3)\n    if is_happy(count2):\n      return true\n    \n    let (s,count3)=chop(s,\
    \ count2+3)\n    if is_happy(count3):\n      return true\n    \n    return false\n\
    \"\"\"\nis_happy(a)\n\"\"\"", "    if is_null(s)\n        return True\n    else\
    \ \n        if length(s) >= 3\n            false\n        else\n            if\
    \ is_hapjl(s)\n                true\n            else\n                is_happy(tail(s))\n\
    \        end\nend", "    if is_happy(StringLen(s)) || StringLen(s) == 0 then return\
    \ true\n    local a::String = \"\"\n    local n::Int = 0\n    for i = 1, StringLen(s)\
    \ do\n        local c = s[i]\n        if i == 1 then\n            if c == s[0]\
    \ then return false\n            else a = c + a\n            end\n        elseif\
    \ c == s[n-1] then return false\n        else a = c + a\n        end\n       \
    \ n += 1\n    end\n    return true\nend", "    if s.isEmpty || s.length == 0 ||\
    \ s.length >= 3\n        return true\n    let chars = unique(split(s))\n    for\
    \ (c,i) \u2208 enumerate(chars)\n        if i == 0 || i == 1\n            then\
    \ return false\n        else if c == chars[i-1]\n            then return false\n\
    \        else if c == chars[i-2]\n            then return false\n        else\
    \ if c == chars[i-3]\n            then return false\n    return true\n</code>\n\
    It took me a while to think of the solution but this one works!\n<|/ a dscore=0\
    \ tags=string,functional-programming,algorithm,haskell,scala |>\n<| a dscore=0\
    \ |>\n<code>\ndef isHappy(s:String):Boolean = s.length >= 3 && all ((c,i) <- (zip\
    \ s [0..])) ( (c1,i1)<- (zip s [0..])  (c2,i2)<- (zip s [0..]) (\n  c3,i3)<- (zip\
    \ s [0..]) (\n    c4,i4)<- (zip s [0..])  (\n      c5,i5)<- (zip s [0..]) (c6,i6)<-\
    \ (zip s [0..]) (c7,i7)<- (zip s [0..]) (c8,i8)<- (zip s [0..]) (c9,i9)<- (zip\
    \ s [0..])\n      (c10,i10)<- (zip s [0..]) (c11,i11)<- (zip s [0..]) (c12,i12)<-\
    \ (zip s [0..]) (c13,i13)<- (zip s [0..]) (c14,i14)<- (zip s [0..]) (c15,i15)<-\
    \ (zip s [0..])\n      (c16,i16)<- (zip s [0..]) (c17,i17)<- (zip s [0..]) (c18,i18)<-\
    \ (zip s [0..]) (c19,i19)<- (zip s [0..]) (c20,i21)<- (zip s [0..]) (c21,i22)<-\
    \ (zip s [0..])\n      (c22,i23)<- (zip s [0..]) (c23,i24)<- (zip s [0..]) (c24,i25)<-\
    \ (zip s [0..]) (c25,i26)<- (zip s [0..]) (c26,i27)<- (zip s [0..]) (c27,i28)<-\
    \ (zip s [0..]) (c28,i29)<- (zip s [0..])\n      (c30,i31)<- (zip s [0..]) (c31,i32)<-\
    \ (zip ", "</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nThis works also:\n<code>\n\
    is_happy(s) = s == \"xy\" || s == \"yx\" || s == \"y\" || s == \"x\"\n</code>\n\
    <|/ a tags=julia,string |>\n<| a tags=julia,string |>\nYou can use the ishappy()\
    \ function in Julia as following\n<code>\nishappy(s) = length(s) >= 3 && all(x->x\
    \ != s[1], s[2:end])\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=julia,string\
    \ |>\n<code>", "    if is_happy_(s,1) then true else false\nend \n</cell>\n<code\
    \ language=julia-1.0>\nis_happy_(\"abcdefg\")\n</cell>\n<text>\nExercise 1\nWrite\
    \ a function that will take as input a String s and will output the characters\
    \ that are not present in the string s.\nWe will compare the output with the original\
    \ string and we will print the result to the user if they differ.", "    if len(s)<3\
    \ || length(s)<3\n        return false\n    \n    s=s.toLower\n    let (h:t) =findh(a:t)\
    \ s\n    \n    for i in0 0 h-1 t \n        if a[i] != s[i+h]\n            return\
    \ false\n    end\n    return true\nend\n</code>\n<|/ a tags=julia dscore=3 |>\n\
    <| a dscore=3 |>\nHere's a version that uses Iterators and IteratorTools.jl.\n\
    <code>", "    # write your code in here\n    if is_happy(s) == true\n        true\n\
    \    else\n        false\n    end \nend", "\"\"\"\n## @title [Predefined]", " \
    \   is_happy = True\n    \n    if length(s) == 3 && is_distinct(s,0,3) == false\
    \ && is_distinct(s,2,3) == false && is_distinct(s,3,3) == false\n    \n    else\
    \ \n        is_happy = false\n    \n    return\n    \nend\n</cell>\n<text>\nTest\
    \ cases:\nLet the string be \"Aabbccd\"\nCase 1: length == 3 and all letters are\
    \ distinct\nCase 2: length == 3 and all letters are distinct\nCase 3: length ==\
    \ 3 and all letters are distinct\nCase 4: length == 3 and all letters are distinct",
  "    \n    if is_nil(s) \n        return true\n    if is_nil(s)\n        return\
    \ false\n    \n    if s.length < 3\n        return false\n    \n    let i = 2\n\
    \    let j = s.length - 1 \n    \n    while i < j\n        let char = s.charAt(i)\n\
    \        let char2 = s.charAt(j)\n        if char == char2\n            let char3\
    \ = s.charAt(i + 1)\n            if char3 == char2\n                let char4\
    \ = s.charAt(j + 1)\n                if char4 == char2\n                    i\
    \ += 1\n                    j -= 1\n                else \n                  \
    \  j -= 1\n                else \n                    i -= 1\n        else \n\
    \            i -= 1\n            j += 1\n    \n    return true\n    \n    \n#\
    \ val is_happy: String -> bool\nis_happy(a::String)", "    if is_happy(s.length)\n\
    \        true\n    else\n        false\n    end\nend", "    is_happy_str= length\
    \ s >= 3 && all(distinct take 3 s)\n    return is_happy_str\n</code>\n<|/ a dscore=1\
    \ tags=ocaml,string,functional-programming |>\n<| c |>\nHappy to help. Since it\
    \ solved your problem, could you accept this answer by clicking on the tick button\
    \ to make it green?\n<|/ c |>\n<| a tags=ocaml,string,functional-programming |>\n\
    You can use the following code (if you don't want to use List.fold_left):\n<code>\n\
    open Core.Std", "    \n    let n = length(s)\n    if n < 3 || n > 100 { return\
    \ false }\n    let arr = String[]\n    for i in 0..n step 3 do \n        if arr[i]\
    \ != s[i-3]\n        { arr <- arr ++ s[i] }\n        else { arr <- arr ++ s[i-3]\
    \ }\n    end\n    for i in 0..n do \n        if arr[i] != s[i] \n        { return\
    \ false }\n    end\n    return true\nend", "    if is_happy(s,0) == true \n  \
    \  then true \n    else false \n    end\nend\n</code>\nAnd now for the last piece\
    \ which is to write a function which counts the number of characters in a string:\n\
    <code>\n\"\"\"You are given a string s.\n    Your task is to return the length\
    \ of s.\n    For example:\n    >>> length(a)\n    3\n    >>> length(a)\n    3\n\
    \    >>> length(abcd) # returns 0\n    0\n    >>> length(abc)\n    2\n    >>>\
    \ length(x)\n    1\n    >>> length(x)\n    1\n\"\"\"", "    let is_happy(s::String)\
    \ = (length(s)>=3) && ( length(s)%3 == 0 && ( s == (s.[0..2]) || s == (s.[3..5])\
    \ || s == (s.[6..8])  || s == (s.[9..12])  ))\n    is_happy(s)\nend\n</cell>\n\
    <code language=julia-1.5>", "    \n    if is_happy_rec(s)==True && is_happy_rec(reverse(s))==True\n\
    \    \n    else \n    \n        if is_happy_rec(s)==True && is_happy_rec(reverse(s))==False\n\
    \            \n            \n        else \n            \n            if is_happy_rec(s)==False\
    \ && is_happy_rec(reverse(s))==True\n                \n            else \n   \
    \             \n                if is_happy_rec(s)==False && is_happy_rec(reverse(s))==False\n\
    \                    \n                else\n                    \n          \
    \          \n                        \n                \n                    \n\
    \    return true\n</code>\n<|/ a tags=recursion,string,haskell |>\n<| c |>\nI\
    \ appreciate your help but the question is about how to do this recursively\n\
    <|/ c |>\n<| c |>\nHi sorry, I didn't realise there was a restriction to recursively.\
    \ I've added a non-recursive version that should hopefully be helpful.\n<|/ c\
    \ |>\n<| c |>\nSadly this still doesn't answer the question as it is about recursion,\
    \ rather than recursion in general\n<|/ c |>\n<| a tags=recursion,string,haskell\
    \ |>\n<code>\nis_happy_re :: String -> Bool\nis_happy_re [] = True\nis_happy_re\
    \ s\n    | length s < 3 = False\n    | otherwise = all (`elem` s) (reverse s)\
    \ && is_happy_re (init s)\n</code>\n<|/ a dscore=1 |>\n<| a tags=recursion,string,haskell\
    \ |>\nYou could define a helper function with type signature\n<code>\n is_happy_helper\
    \ :: String -> Bool\n</code>\nwhich takes an argument and checks if the string\
    \ is happy-ish, if so returns True and otherwise returns False.  If the argument\
    \ is not happy, the function recursively calls itself with tail of the string.\
    \  For example:\n<code>\nis_happy_helper s = is_happy_helper s\n</code>\nwould\
    \ work perfectly.\nNow if you want is_happy_helper s to be recursive, just call\
    \ it at the head of the function body, just like you would in a regular non-recursive\
    \ function.\n<code>\nis_happy_helper = is_happy_helper []\n</code>\nThis would\
    \ be the equivalent of is_happy_helper s = True and is_happy_helper s = False\
    \ in your original code.\n<|/ a dscore=0 |>\n<| c |>\nThanks for your answer but\
    \ this isnt what I was looking for I really want to know how to do this recursively\n\
    <|/ c |>\n<| c |>\nIn that case, you don't need a helper function.  You can just\
    \ do: `is_happy_helper = is_happy_helper ", "    if is_null(s) then false else\
    \ s.length >= 3 &&\n        has_distinct_chars(s.subsequences(3)) \nend\n</cell>\n\
    <text>\nExercise 2", "    if length(s) < 3 then return false\n    let rec is_happy_helper(l::Int,\
    \ c::Char, cs::[Char])::Bool\n        if c =/= 'a' then return false\n       \
    \ if l > 3 then return false\n        let (cs, l) = if (c =/= 'z') then ([c],\
    \ l + 1) else\n            (if cs == [] then [c] else cs, l + 1)\n        in is_happy_helper(l,\
    \ c, cs)\n    in is_happy_helper(0, 'a', [])\nend", "    if s.length < 3 || s.length\
    \ % 3 != 0 || s.head != s.tail\n        false\n    else\n        for c in s.tail\n\
    \            if c != s.head && s.head.value == c\n                false\n    \
    \        else\n                true\n        end\n    end\nend\n</cell>\n<code\
    \ language=julia-0.5>", "   let strs = split(s)\n   let rec helper s = strs ==>\
    \ \n      if length(strs) == 3 \n      and all(distinct strs[2:4]) \n      and\
    \ all strs[2:4] in(strs[2:4])\n      and all(distinct strs[4:6])\n      and all\
    \ strs[4:6] in(strs[4:6])\n      and all strs[6:8]\n      and all strs[8:10]\n\
    \      then true\n      else helper(s++strs)\n   helper(\"\")\nend", "    if is_happy(\"\
    \",s)\n        else False\n    else is_happy(s,s)", "    if s.length < 3 \n  \
    \      return false\n    for i = 3, i = 1; i < s.length; i++\n        if s[i]\
    \ == s[i-1]\n            false\n        else\n            true\n    end\nend\n\
    </code>\n<|/ a dscore=0 tags=string,haskell,functional-programming,recursion |>\n\
    <| a dscore=0 |>\n<code>\nhappy = is_happy_ \"\"\nis_happy_ \"\" = True\nis_happy_\
    \ (x:xs) = is_happy_ (xs++x) \n</code>\n<|/ a tags=string,haskell,functional-programming,recursion\
    \ |>\n<| a dscore=0 tags=string,haskell,functional-programming,recursion |>\n\
    Here is a recursive and tail-recursive solution using Data.List.NonEmpty.\n<code>\n\
    import qualified Data.List.NonEmpty as NE\nimport Data.Char (toLower)", "    \n\
    \    if s.length >= 3\n        and count(s, 0, 2) == 3\n        and count(s, 1,\
    \ 2) == 3\n        and count(s, 2, 2) == 3\n    then\n        true\n    else\n\
    \        false\n    end\nend\n</cell>\n<text>\nTest your code", "    let mut x\
    \ = 3\n    for ch in s{\n        if x >= s.len()|| ch != s[x-3]{\n           \
    \ return false\n        }\n        x += 1\n    }\n    return true\n</code>\n<|/\
    \ a tags=swift,string,algorithm,python |>\n<| a dscore=0 |>\nThe Swift version\
    \ is:\n<code>\nfunc checkHappyString(_ string:String) -> Bool {", "  x <- length(s)\n\
    \  if x > 3\n    then false\n    else let \n        y <- 3\n        z <- 1\n \
    \       while z <= y do \n          let h <- take(s,z)\n          if h != h &&\
    \ h != h+h && h != h+h+h \n            then false\n            elseif h == h+h+h\n\
    \            then z += 1\n            else z += 1\n        in true\n    end\n\
    </code>\n<|/ a tags=string,prolog |>\n<| a dscore=2 tags=string,prolog |>\nMy\
    \ Prolog code is like this:\n<code>\n/* check if string HAPPENS to HAPPY */\n\
    happy(X) :- happy2(X).", "    \n    flag = s.length >= 3\n    \n    if flag\n\
    \        \n        for i in 0 .. flag - 2\n            if s[i] == s[i+1] && s[i+1]\
    \ == s[i+2]\n                flag = false\n            else\n                flag\
    \ = true\n        end\n    end\n    \n    return flag\nend\n</cell>\n<code language=julia-1.6>\n\
    \"\"\"\n    lengths(s)\n    \n    Input a string, output a list of its length\
    \ \n    \n    lengths(s) return a list with all the length of s\n    \n    lengths(\"\
    bab\") --> [2, 1, 2, 2, 1]\n    \n    lengths(\"abcabc\") --> [4, 3]\n    \n \
    \   lengths(\"aa\") --> [1, 1]\n    \n    lengths(\"\") --> [0, 0, 0, 0, 0]\n\
    \    \"\"\"", "    if length(s) >= 3 && is_distinct(tail(s), tail(tail(s))) ==\
    \ false\n        return true\n    return false\n</code>\n<|/ a tags=string,recursion,haskell,list\
    \ |>\n<| c |>\n`is_happy_ = (length s >= 3 && all (== 'a' || == 'b' || == 'c')\
    \ $ take 3 (tail s))`\n<|/ c |>\n<| c |>\nThis solution only checks the length\
    \ of the string, not the contents. `is_happy_ = 'aa' -> False`\n<|/ c |>\n<| a\
    \ dscore=1 |>\nTry this:\n<code>\nisHappy = length s >= 3 && all (== 'a' || 'b'\
    \ || 'c') $ take 3 (tail s)\n</code>\n<|/ a tags=string,recursion,haskell,list\
    \ |>\n<| a |>\nI would just do it like this using functional programming\n<code>\n\
    isHappy = foldr (&&) True (map (=='a') ['b'..'c'])\n</code>\n<|/ a tags=string,recursion,haskell,list\
    \ dscore=0 |>\n<| c |>\nThe fold doesn't work if the string starts with one of\
    \ the characters. Try it with `\"abc\"`.\n<|/ c |>\n<| c |>\n`foldr (&&) True\
    \ (map (=='a') \"abc\")` is `False`\n<|/ c |>\n<| c |>\nI like it, but it would\
    \ be better to `foldr (&&) True (map even \"abc\")`, otherwise it's `False`.\n\
    <|/ c |>\n<| c |>\nTrue. But I think it's better to just call `length s >= 3 &&\
    \ all even ['b'..'c']` instead of doing `all even $ take 3 s`.\n<|/ c |>\n<| c\
    \ |>\nAgreed. It's only \"better\" because it uses functional programming.\n<|/\
    \ c |>\n<| a tags=string,recursion,haskell,list |>\nAnother version:\n<code>\n\
    import Data.List", "    if (length(s) <= 3) || length(s)==0\n        return false\n\
    \    end\n    mutable mutable counter = 0\n    for i in s\n        if i == i\n\
    \            counter += 1\n        elseif counter == 3\n            counter =\
    \ 0\n        else\n            counter = 0\n        end\n    end\n    return true\n\
    end", "    if length(s) >= 3 \n        s == hyped\n        false\n    return length(s)\
    \ == 3 \nend \n</cell>\n<text>\nProblem 4 (1 point)\nWrite a function that takes\
    \ a string as input and counts the number of characters that are spaces.", "\"\"\
    \"\n    This is a recursive function that checks if a String is hapjl or not.\n\
    \"\"\"\n    if length(s) == 1 \n        True \n    else \n        not is_happy(drop(1,\
    \ s)) or is_happy(drop(2, s))", "    local i :: Int \n    local j :: Int \n  \
    \  local k :: Int \n    local l :: Int \n    local m :: Int \n    local n :: Int\
    \ \n    local p :: Int \n    local q :: Int \n    local r :: Int \n    local s\
    \ :: Int \n    local t :: Int \n    local u :: Int \n    local v :: Int \n   \
    \ local w :: Int \n    local x :: Int \n    local y :: Int \n    local z :: Int ",
  "    \n    let rec is_happy_helper(s::String)::Bool = \n        if length(s)>3 &&\
    \ all((c==s[1]|c==s[2]|c==s[3]) for c in s[1:3]) == true\n        then is_happy_helper(s[3:])\n\
    \        else \n            s == happy(s).s\n    is_happy_helper(s)\nend", " \
    \   if is_happy(s)==True then true else false \nend ", "    \n    if is_happy(s)==True\
    \ && is_happy(s[2:])==False\n    \n        if is_happy(s)==False\n           \
    \ else\n                return false\n    \n    if is_happy(s)==True\n       \
    \ \n        if length(s[2:])==3\n            if count((s[2:]).distinct) == length(s[2:])\n\
    \                \n                \n                if count((s[2:]).distinct)==\
    \ length(s[2:])\n                    \n                    \n                \
    \    if s[0]=='a'\n                        else\n                            return\
    \ false\n    \n                if s[0]=='a'\n                    else\n      \
    \                  return false\n        \n        if length(s[2:])!=3\n     \
    \       if s[0]=='a'\n                else\n                    return false\n\
    \        end\n    end\nend\n</cell>\n<text>\nPart 3: Stringing together your code\n\
    Before you start writing your function, let's review what we've done, and how\
    \ each part will work before we get to writing our very own function.", "    \n\
    \    \n    if s.length < 3 return False\n    let count = 0\n    for i in 0..length(s)-3\n\
    \        count += if s[i] == s[i+1] && s[i+1] == s[i+2] then 1 else 0\n    count\
    \ == s.length % 3 && count == 3\nend\n</cell>\n<text>\nExercise 3: Write a recursive\
    \ function is_happy(x) that takes a string as its argument and returns a boolean\
    \ indicating whether the given string is a happy string.", "    if is_happy(s)\n\
    \    then true\n    else false\nend", "    if is_happy(s) \n        then return\
    \ True \n        else return False \n    end \n    if is_happy(\"\")\n       \
    \ then return True \n        else return False \n    end \n    if is_happy(\"\
    aa\")\n        then return True \n        else return False \n    end \n    if\
    \ is_happy(\"ad\")\n        then return True \n        else return False \n  \
    \  end \n    if is_happy(\"adc\")\n        then return True \n        else return\
    \ False \n    end \n    if is_happy(\"aad\")\n        then return True \n    \
    \    else return False \n    end \n    if is_happy(\"adca\")\n        then return\
    \ True \n        else return False \n    end \n    if is_happy(\"dca\")\n    \
    \    then return True \n        else return False \n    end \n    if is_happy(\"\
    acdca\")\n        then return True \n        else return False \n    end \n  \
    \  if is_happy(\"ddccb\")\n        then return True \n        else return False\
    \ \n    end \n    if is_happy(\"ddcb\")\n        then return True \n        else\
    \ return False \n    end \n    if is_happy(\"ccdcb\")\n        then return True\
    \ \n        else return False \n    end \n    if is_happy(\"cddcc\")\n       \
    \ then return True \n        else return False \n    end \n    if is_happy(\"\
    cddccb\")\n        then return True \n        else return False \n    end \n \
    \   if is_happy(\"ddcccb\")\n        then return True \n        else return False\
    \ \n    end \n    if is_happy(\"bcbcdd\")\n        then return True \n       \
    \ else return False \n    end \n    if is_happy(\"bbbddd\")\n        then return\
    \ True \n        else return False \n    end \n    if is_happy(\"bbddd\")\n  \
    \      then return True \n        else return False \n    end \n    if is_happy(\"\
    ddddbb\")\n        then return True \n        else return False \n    end \n \
    \   if is_happy(\"dddbbb\")\n        then return True \n        else return False\
    \ \n    end \n    if is_happy(\"bbbbdd\")\n        then return True \n       \
    \ else return False \n    end \n    if is_happy(\"dddddbb\")\n        then return\
    \ True \n        else return False \n    end \n    if is_happy(\"dddbbbb\")\n\
    \        then return True \n        else return False \n    end \n    if is_happy(\"\
    bbbbddd\")\n        then return True \n        else return False \n    end \n\
    \    if is_happy(\"bbbbddd\")\n        then return True \n        else return\
    \ False \n    end \n    if is_happy(\"ccccccb\")\n        then return True \n\
    \        else return False \n    end \n    if is_happy(\"cccccc\")\n        then\
    \ return True \n        else return False ", "    count::Int = 0\n    for c in\
    \ s\n        count++\n    \n    return count >= 3 && all( c!=count+c for c in\
    \ s[1..] )\nend\n</cell>\n<text>\nExercise 10", "    if len(s) >= 3 && all(distinct(s[i\
    \ : i + 3]) for i in 0..length(s - \"a\"))\n    return True\nend", "    \n   \
    \ if is_empty(s) then return true\n    else if length(s) < 3 || length(s) > 5\
    \ then return false\n    else if occurs_at_three(s,1)=false or occurs_at_three(s,2)=false\
    \ or occurs_at_three(s,3)=false then return false\n    else if occurs_at_three(s,3)=false\
    \ and occurs_at_three(s,4)=false and occurs_at_three(s,5)=false then return true\n\
    \    else return false\nend", "    if is_empty(s) == false then \n        p <-\
    \ get_index(s, 'a')\n        if is_happy(s[p .. p+3]) == false then\n        \
    \    return false\n        else \n            p <- get_index(s, 'b')\n       \
    \     if is_happy(s[p .. p+3]) == false then\n                return false\n \
    \           else \n                p <- get_index(s, 'c')\n                if\
    \ is_happy(s[p .. p+3]) == false then\n                    return false\n    \
    \            else \n                    p <- get_index(s, 'd')\n             \
    \       if is_happy(s[p .. p+3]) == false then\n                        return\
    \ false\n                    else \n                        p <- get_index(s,\
    \ 'e')\n                        if is_happy(s[p .. p+3]) == false then\n     \
    \                       return false\n                        else \n        \
    \                    p <- get_index(s, 'f')\n                            if is_happy(s[p\
    \ .. p+3]) == false then\n                                return false\n     \
    \                       else \n                                p <- get_index(s,\
    \ 'g')\n                                if is_happy(s[p .. p+3]) == false then\n\
    \                                    return false\n                          \
    \      else \n                                    p <- get_index(s, 'h')\n   \
    \                                 if is_happy(s[p .. p+3]) == false then\n   \
    \                                     return false\n                         \
    \           else \n                                        p <- get_index(s, 'j')\n\
    \                                        if is_happy(s[p .. p+3]) == false then\n\
    \                                            return false\n                  \
    \                      else \n                                            p <-\
    \ get_index(s, 'k')\n                                            if is_happy(s[p\
    \ .. p+3]) == false then\n                                                return\
    \ false\n                                            else \n                 \
    \                               p <- get_index(s, 'l')\n                     \
    \                           if is_happy(s[p .. p+3]) == false then\n         \
    \                                           return false\n                   \
    \                             else \n                                        \
    \            p <- get_index(s, 'm')\n                                        \
    \            if is_happy(s[p .. p+3]) == false then\n                        \
    \                                return false\n                              \
    \                      else \n                                               \
    \         p <- get_index(s, 'n')\n                                           \
    \             if is_happy(s[p .. p+3]) == false then\n                       \
    \                                     return false\n                         \
    \                               else \n                                      \
    \                      p <- get_index(s, 'o')\n                              \
    \                              is_happy(s[p .. p+3])\n    else \n        return\
    \ true\n    end\n    return true\nend\n</code>\nThis code works as intended but\
    \ only when the alphabet is small.  When the alphabet is huge, say about 1000\
    \ letters, it runs out of memory.  Is there an issue with my code or is this an\
    \ issue with my algorithm?\n<|/ q tags=string,julia,out-of-memory dscore=1 |>\n\
    <| c |>\nYou could have written the code with less `if` statements, by taking\
    \ advantage of short-circuit evaluation - ", "    \n    if is_empty(s) == true\n\
    \        true\n    else\n        let\n            count = 0\n            len =\
    \ length(s)\n            for i in 0..len\n                if s[i] == s[i+1]\n\
    \                    count++\n                else\n                    if count\
    \ == 3\n                        return true\n                    else\n      \
    \                  count = 0\n        false\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @test is_happy(\"\")", "    if is_happy(s)\n    then return true\n    else return\
    \ false\nend\n</code>\n<|/ a tags=functional-programming,haskell |>\n<| a dscore=1\
    \ |>\n<code>\nimport Data.List", "    return (length(s) >= 3) && (all(c not in\
    \ set(s[-3..-1]) for c in s[0..2]))\n</code>\nYou can test it yourself using this\
    \ snippet:\n<code>\njulia> is_happy(\"\")\nfalse", "    if is_empty(s) { return\
    \ True }\n    let len=length(s);\n    if len < 3 { return True }\n    \n    let\
    \ mut count = 1;\n    for idx in 0..len-2 {\n        if s[idx] == s[idx+1] &&\
    \ s[idx+1] == s[idx+2] && s[idx+2] != s[idx+1] { count++ }\n    }\n    return\
    \ count >= 3 && is_distinct(s)\nend\n</cell>\n<code language=julia-0.6>\na = fill(Any,\
    \ 50)\n</cell>\n<code language=julia-0.6>\n@time is_happy(a)\n</cell>\n<code language=julia-0.6>\n\
    @time is_happy(a)\n</cell>\n<code language=julia-0.6>\n@time is_happy(aa)\n</cell>\n\
    <code language=julia-0.6>\n@time is_happy(aabb)\n</cell>\n<code language=julia-0.6>\n\
    @time is_happy(adb)\n</cell>\n<code language=julia-0.6>\n@time is_happy(xyy)\n\
    </cell>\n<code language=julia-0.6>\n@time is_happy(abc)\n</cell>\n<code language=julia-0.6>\n\
    @time is_happy(ad)\n</cell>\n<code language=julia-0.6>\n@time is_happy(adb)\n\
    </cell>\n<code language=julia-0.6>\n@time is_happy(ab)\n</cell>\n<code language=julia-0.6>\n\
    @time is_happy(abcb)\n</cell>\n<code language=julia-0.6>\n@time is_happy(abbb)\n\
    </cell>\n<code language=julia-0.6>\n@time is_happy(abbbbbb)\n</cell>\n<code language=julia-0.6>\n\
    @time is_happy(abbbbbbb)\n</cell>\n<code language=julia-0.6>\n@time is_happy(abbbbbbbbb)\n\
    </cell>\n<code language=julia-0.6>\n@time is_happy(abbbbbbbbbb)\n</cell>\n<code\
    \ language=julia-0.6>\n@time is_happy(abbbbbbbbbbb)\n</cell>\n<code language=julia-0.6>\n\
    @time is_happy(abbbbbbbbbbbbb)\n</cell>\n<code language=julia-0.6>\n@time is_happy(abbbbbbbbbbbbbbb)\n\
    </cell>\n<code language=julia-0.6>\n@time is_happy(abbbbbbbbbbbbbbbbbb)\n</cell>\n\
    <code language=julia-0.6>\n@time is_happy(abbbbbbbbbbbbbbbbbbb)\n</cell>\n<code\
    \ language=julia-0.6>\n@time is_happy(abbbbbbbbbbbbbbbbbbbbb", "    if s.length\
    \ >= 3 && true\n            else\n                false\n    return true\nend\
    \ \n</cell>\n<code language=julia-1.3>\n#export\n\"\"\"\n    main(arg::AbstractString)",
  "    if is_empty(s) {\n        return true\n    }\n    let len = length(s)\n   \
    \ let mut hapjl = true\n    for i in 0..len {\n        if is_happy_2(s.slice(0,i+1))\
    \ {\n            hapjl = false\n        }\n    }\n    hapjl\nend", "    if is_happy_string(s)\
    \ == true then \n       return true\n    else \n       return false\nend\n\"\"\
    \"\nYour task is to check if the string is happy\n    A string is happy if its\
    \ length is at least 3 and every 3 consecutive letters are distinct\n    For example:\n\
    \    >>> is_happy(a)\n    false\n    >>> is_happy(aa)\n    false\n    >>> is_happy(abcd)\n\
    \    true\n    >>> is_happy(aabb)\n    false\n    >>> is_happy(adb)\n    true\n\
    \    >>> is_happy(xyy)\n    false\n    \"\"\"", "    len1 = length(s)\n    if\
    \ len1 < 3\n        true\n    else\n        for i from 3 to len1\n           \
    \ if i == 1\n                false\n            else\n                if s[i]\
    \ == s[i-1]\n                    false\n                else\n               \
    \     if s[i] == s[i-2]\n                        false\n                    else\n\
    \                        if s[i] == s[i-3]\n                            false\n\
    \                    else\n                        true\n    return true\n</code>\n\
    <|/ a |>\n<| c |>\nWhile this code may answer the question, it would be better\
    \ to include some context, explaining how it works and when to use it. Code-only\
    \ answers are not useful in the long run.\n<|/ c |>\n<| c |>\n, thanks for your\
    \ comment, I added some explanation, hope it helps.\n<|/ c |>\n<| c |>\nI see,\
    \ I thought it was a good answer but did not want to get downvoted. Thanks again\
    \ for adding some more explanation.\n<|/ c |>\n<| c |>\n, thanks for your comment,\
    \ it helps.\n<|/ c |>\n<| c |>\nThis is really nice code. I'm wondering why it's\
    \ considered \"bad\", i.e. why it's \"bad\" from a mathematical point of view...\n\
    <|/ c |>\n<| a |>\nThe most intuitive way to do this would be to start by sorting\
    \ the string and seeing if that produces a palindrome, then see if the sorted\
    \ string is a palindrome. Here is one way to do it (this example uses strings,\
    \ but you could do more or less with other types):\n<code>\nif is_palindrome(s:string)\n\
    \  result = is_palindrome(sort_string(s))\nend\n</code>\n<|/ a tags=string,haskell\
    \ dscore=1 |>\n<| c |>\nI like this solution as it requires no recursion. Since\
    \ both `is_palindrome` and `sort_string` will probably be quite simple, this should\
    \ be fast.\n<|/ c |>\n<| c |>\nOh yeah, `is_palindrome` would be pretty easy and\
    \ `sort_string` should be pretty straightforward.\n<|/ c |>\n<| c |>\nThe other\
    \ commenters are correct. The most intuitive answer will be `sort` followed by\
    \ `==`.\n<|/ c |>\n<| a tags=string,haskell dscore=1 |>\n<code>\nis_hapjl :: String\
    \ -> Bool\nis_hapjl xs = not (isPalindrome xs) || (length xs == 3 && all (\\c->\
    \ xs == reverse x", "    if is_happy_helper(s,0,1)\n    true\n    else false\n\
    end", "    if length(s) < 3 || substring(s, 1, 3) != substring(s, 4, 6) || substring(s,\
    \ 6, 9) != substring(s, 11, 13) || substring(s, 13, 15) != substring(s, 17, 19)\n\
    \    then false\n    else true\n    end \nend\n\"\"\"\nThis function checks if\
    \ a string has only capital letters, \nit returns false if it has some non capital\
    \ letters \nIt also works on strings with length < 3 \n\"\"\"", "    if s == \"\
    \" \n    then return true\n    elif is_happy_(s[1..]) \n    then return true\n\
    \    else return false\nend\nis_happy_(s::String)::Bool = \n    let rec aux s\
    \ = if s == \"\" \n    then [] \n    else if is_happy_(s[1..]) \n    then aux\
    \ s\n    else [s[0]] == aux s[1..] \n    end \n    aux s\n</cell>\n<cell>\n@test\
    \ is_happy(\"abcde\") == false\n@test is_happy(\"abcabc\") == false\n@test is_happy(\"\
    adb\") == true\n@test is_happy(\"xyy\") == false\n</cell>\n<text>\nTask 9. Implement\
    \ is_happy(string, word::String)\nInputs:\n  string: a string\n  word: a string\n\
    Outputs:\n  is_happy(string, word):\n    True if string is a happy-happy string\
    \ if and only if word is the same as its happy-happy prefix\n    False otherwise.\n\
    Examples:\n  >>> is_happy(\"abcde\", \"abcde\")\n  true\n  >>> is_happy(\"abcde\"\
    , \"abca\")\n  false\n  >>> is_happy(\"abcde\", \"abcdea\")\n  false\n  >>> is_happy(\"\
    abcde\", \"abcdee\")\n  true\n  >>> is_happy(\"abcde\", \"abcde\")\n  true\n \
    \ >>> is_happy(\"ab\", \"ab\")\n  true\n  >>> is_happy(\"\", \"\")\n  true\n \
    \ >>> is_happy(\"a\", \"a\")\n  true\n  >>> is_happy(\"ab\", \"a\")\n  false\n\
    \  >>> is_happy(\"ab\", \"ba\")\n  false\n  >>> is_happy(\"ab\", \"ab\")\n  true\n\
    \  >>> is_happy(\"a\", \"\") == \"a\"\n  true\n  >>> is_happy(\"\", \"\") == \"\
    \"\n  true\n  >>> is_happy(\"a\", \"a\") == \"a\"\n  true\n  >>> is_happy(\"ab\"\
    , \"a\") == \"a\"\n  false\n  >>> is_happy(\"ab\", \"ba\") == \"a\"\n  false\n\
    \  >>> is_happy(\"ab\", \"ab\") == \"a\"\n  true\n  >>> is_happy(\"a\", \"\")\
    \ == \"a\"\n  true\n  >>> is_happy(\"\", \"\") == \"\"\n  true\n  >>> is_happy(\"\
    a\", \"a\") == \"a\"\n  true\n  >>> is_happy(\"ab\", \"a\") == \"a\"\n  false\n\
    \  >>> is_happy(\"ab\", \"ba\") == \"a\"\n  false\n", "    if is_happy_string(s)\
    \ then return true else return false\nend", "    if is_happy(s) == True\n    else\
    \ return False\n    \n</code>\n<|/ a dscore=0 |>\n<| c |>\nYou can improve your\
    \ answer by adding some explanation about what your code does and how it does\
    \ it.\n<|/ c |>\n<| c |>\nThis is definitely not the answer. Please don't post\
    \ just code, explain what you're doing.\n<|/ c |>\n<| a |>\nTry this:\n<code>\n\
    let s = \"Happy\"\nlet res = String.fromCharCode(s.split(\"\").map(String.codePoint).filter(codePoint\
    \ => ![(97,65),(97,90)..(122,125)].contains(codePoint)).collect{|e| e.to_s(16)})\n\
    print(res)\n</code>\n<|/ a tags=string,swift dscore=0 |>\n<| c |>\nThis does not\
    \ produce the expected output for `happy`, which has 3 letters and a bunch of\
    \ numbers.\n<|/ c |>\n<| c |>\nI guess, It is not what the OP wants, since he\
    \ said \"every 3 consecutive letters are distinct\"\n<|/ c |>\n<| c |>\nThe question\
    \ says \"every 3 consecutive letters are distinct\".\n<|/ c |>\n<| a |>\nYou can\
    \ use below function too,\n<code>\nfunc isHappy(myString:String) -> Bool {\n \
    \   let charsArray = Array(myString)\n    return charsArray.count >= 3 && charsArray.filter({\
    \ Character($0).isNumber }).count >= 3\n}\n</code>\n<|/ a tags=string,swift dscore=0\
    \ |>\n<| a tags=string,swift |>\nA function like this should work.\n<code>\nfunc\
    \ isHappy(myString:String) -> Bool{\n    var result = false\n    for index in\
    \ 0..<myString.characters.count{\n        let char = String(myString.characters[index])\n\
    \        if (char.characters.count > 2){\n            if char.characters.filter({\
    \ $0.isNumber }).count < 2{\n                result = true\n                break\n\
    \            }\n        }\n    }\n    return result\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\nThis code works in swift\n<code>\nfunc checkString(string:\
    \ String) -> Bool{\n    let characters = Array(string)\n    return characters.count\
    \ >= 3 && characters.filter({ $0.isNumber }).count >= 3\n}\n</code>\n<|/ a tags=string,swift\
    \ |>\n<| a dscore=0 |>\nYou can use this one liner:\n", "    if is_happy(s) ==\
    \ true then true else false\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\n\
    \    find_substr_len()\n    \n    Inputs: \n        s::string \n        ::string\
    \ \n    \n    Output:\n        ::Int \n    \n    Description:\n        Finds the\
    \ lenght of the given substring in the string s\n        \n    Example:\n    \
    \    find_substr_len(\"abcd\",\"b\")\n    \"\"\"", "    let len = s.length\n \
    \   if len < 3 \n        then false\n    else \n        let\n            arr1\
    \ = Array.fill(len){(s.charAt(i) - 'a')::Int}\n            arr2 = Array.fill(len){(s.charAt(i\
    \ + 1) - 'a')::Int}\n            let ishap1 = arr1 == arr2\n            in \n\
    \                len == 3 && ishap1\n        end\n    end\nend\n</cell>\n<code\
    \ language=julia-0.6>", "     if length(s) <= 3 return True \n     let cs = [0,0,0]\n\
    \     for c in s do cs[ord(c)-97]+= 1\n     if cs[0]==3 && cs[1]==3 && cs[2]==3\
    \ return False \n     if cs[0]==3 && cs[1]==3 && cs[2]==2 return False \n    \
    \ if cs[0]==2 && cs[1]==3 && cs[2]==2 return False \n     if cs[0]==2 && cs[1]==3\
    \ && cs[2]==1 return False \n     if cs[0]==2 && cs[1]==2 && cs[2]==2 return False\
    \ \n     if cs[0]==2 && cs[1]==1 && cs[2]==2 return False \n     if cs[0]==2 &&\
    \ cs[1]==2 && cs[2]==1 return False \n     if cs[0]==1 && cs[1]==2 && cs[2]==2\
    \ return False \n     if cs[0]==1 && cs[1]==2 && cs[2]==1 return False \n    \
    \ if cs[0]==1 && cs[1]==1 && cs[2]==2 return False \n     if cs[0]==1 && cs[1]==1\
    \ && cs[2]==1 return False \n     return True \nend", "    \n    if is_happy1(s)\n\
    \    \n    return true\n    \nend", "    len=s.length\n    if len<3 \n       \
    \ return false\n    \n    for i in stride(3,len-3,3)\n    \n        s=tolower(s.substr(0,i)+tolower(s.substr(i+1))+tolower(s.substr(0,i))\n\
    \        if s.count(\"a\")>s.count(\"e\")>s.count(\"i\")>s.count(\"o\")>s.count(\"\
    u\")\n            return false\n        end\n    end\n    return true\nend", " \
    \   length=length(s)\n    if length>3 && all(length>3,is_distinct(a:Char,s[i:i+3]!=[]\
    \ for i in 0:length-1)) then return true else return false\nend\n</cell>\n<code\
    \ language=julia-1.0>\n@assert is_happy(abba) == \"true\"\n@assert is_happy(abbb)\
    \ == \"false\"\n@assert is_happy(ab) == \"true\"\n@assert is_happy(aa) == \"false\"\
    \n@assert is_happy(a) == \"true\"\n@assert is_happy(abbaa) == \"false\"\n@assert\
    \ is_happy(abb) == \"false\"\n@assert is_happy(abba) == \"true\"\n@assert is_happy(\"\
    a\") == \"true\"\n@assert is_happy(\"abc\") == \"true\"\n@assert is_happy(\"ab\"\
    ) == \"true\"\n@assert is_happy(\"aaaaa\") == \"true\"\n@assert is_happy(\"aaaaab\"\
    ) == \"false\"\n@assert is_happy(\"aaab\") == \"true\"\n@assert is_happy(\"a\"\
    \ * 100 + \"b\" * 100) == \"true\"\n@assert is_happy(\"aaaa\" * 100 + \"b\" *\
    \ 100) == \"false\"\n</cell>\n<text>\nPart III: Sum function", "    length <=\
    \ 0 || length >=3\n    is_happy_helper(s, 0, length-1)\nend", "    s match {\n\
    \        case h::t where h.length >= 3 && all(is_distinct(h.h[j+3]) | is_distinct(h.h[j+2])\
    \ | is_distinct(h.h[j+1]) | is_distinct(h.h[j+0])) => true\n        case _ =>\
    \ false\n    }\n</code>\n<|/ a |>\n<| c |>\nI believe you are wrong. `is_happy(\"\
    abbcccd\")` returns `true`, which is wrong. Your solution returns `false` while\
    \ your solution should return `true`\n<|/ c |>\n<| c |>\nI updated my answer to\
    \ make your solution work. Thanks for your attention\n<|/ c |>\n<| c |>\nThanks\
    \ for taking time to write a solution to my question. The question is about haskell,\
    \ and your solution does not solve the problem correctly for some test cases.\
    \ I edited my question to include a test case that fails your solution\n<|/ c\
    \ |>\n<| c |>\nOh, sorry about that. I've just realized that the string \"abbcccd\"\
    \ is a valid string... That's so funny. How come I thought it shouldn't work.\
    \ Anyway, I've edited my answer, and it now works. I really appreciate your attention\
    \ :)\n<|/ c |>\n<| a dscore=0 tags=algorithm,string,haskell,string |>\nHere is\
    \ my solution:\n<code>\nimport Data.List (inits)\nimport Data.Maybe (fromJust)",
  "    if is_empty(s) return False\n    s == \"a\"\n    s == \"b\"\n    s == \"c\"\
    \n    s == \"d\"\n    s == \"e\"\n    s == \"f\"\n    s == \"g\"\n    s == \"\
    h\"\n    s == \"i\"\n    s == \"j\"\n    s == \"k\"\n    s == \"l\"\n    s ==\
    \ \"m\"\n    s == \"n\"\n    s == \"o\"\n    s == \"p\"\n    s == \"q\"\n    s\
    \ == \"r\"\n    s == \"s\"\n    s == \"t\"\n    s == \"u\"\n    s == \"v\"\n \
    \   s == \"w\"\n    s == \"x\"\n    s == \"y\"\n    s == \"z\"\n    s == \"A\"\
    \n    s == \"B\"\n    s == \"C\"\n    s == \"D\"\n    s == \"E\"\n    s == \"\
    F\"\n    s == \"G\"\n    s == \"H\"\n    s == \"I\"\n    s == \"J\"\n    s ==\
    \ \"K\"\n    s == \"L\"\n    s == \"M\"\n    s == \"N\"\n    s == \"O\"\n    s\
    \ == \"P\"\n    s == \"Q\"\n    s == \"R\"\n    s == \"S\"\n    s == \"T\"\n \
    \   s == \"U\"\n    s == \"V\"\n    s == \"W\"\n    s == \"X\"\n    s == \"Y\"\
    \n    s == \"Z\"\n    s == \"0\"\n    s == \"1\"\n    s == \"2\"\n    s == \"\
    3\"\n    s == \"4\"\n    s == \"5\"\n    s == \"6\"\n    s == \"7\"\n    s ==\
    \ \"8\"\n    s == \"9\"\n    s == \"!\"\n    s == \"?\"\n    s == \".\"\n    s\
    \ == \"!\"\n    s == \"?\"\n    s == \".\"\n    s == \"!\"\n    s == \"?\"\n \
    \   s == \".\"\n    s == \"!\"\n    s == \"?\"\n    s == \".\"\n    s == \"!\"\
    \n    s == \"?\"\n    s == \".\"\n    s == \"!\"\n    s == \"?\"\n    s == \"\
    .\"\n    s == \"!\"\n    s == \"?\"\n    s == \".\"\n    s == \"!\"\n    s ==\
    \ \"?\"\n    s == \".\"\n    s == \"!\"\n    s == \"?\"\n    s == \".\"\n    s\
    \ == \"!\"\n    s == \"?\"\n    s == \".\"\n", "    return (s.length >= 3)\n \
    \       && ((s[0..2].length == 3) && ((s[2..5] != s[2..5]))\n          || (s[2..5].length\
    \ == 3) && ((s[0..2].length != 3))) \n</code>\n<|/ a |>\n<| c |>\n`s[2..5] !=\
    \ s[2..5]` is true for strings such as `ab` and `ba`\n<|/ c |>\n<| c |>\nI fixed\
    \ that\n<|/ c |>\n<| a dscore=1 tags=haskell |>\nTry this way\n<code>\nimport\
    \ Data.List", "    if s == \"\"\n    true\n    else\n    map (\\(x::String) ->\
    \ x != s[length(x)-1], drop(3, zip (s, tail s, tail s)))\n    |> foldl (&&)\n\
    \    true\nend\n</code>\nThe first function checks if the string is empty or not.\
    \ The second function checks every 3 consecutive letters are distinct or not.\
    \ The third function checks whether the string is hapjl or not.\n<|/ a tags=string,julia\
    \ dscore=1 |>\n<| a |>\nA short and sweet solution that does not require an external\
    \ library:\n<code>", "   let mut length = 0 \n   let mut count = 3 \n   for c\
    \ in s do \n      if c == c then count += 1 \n   else \n      length += 1 \n \
    \  if length >=3 and count >=3 then \n      false \n   else \n      true \n</code>\n\
    <|/ a |>\n<| c |>\nI think this can be optimized a little bit, since we do not\
    \ need to loop over every single character in s and count their occurrences, we\
    \ can just check whether there are any three consecutive unique letters in s in\
    \ O(n).\n<|/ c |>\n<| c |>\nYes, I agree with you and I updated my answer.\n<|/\
    \ c |>\n<| a |>\nFor those of you looking to solve this problem in Scala, here\
    \ is a solution:\n<code>\ndef isHappy(input: String) = {\n  val letters = input.split(\"\
    \").filter(_.toLowerCase != \"x\").distinct", "    if length(s) >= 3 && sum(distinct\
    \ s[2:i] in (s[i], s[i]) for i in 2:length(s)) == length(s) \n    then true\n\
    \    else false\n    end\nend", "    if is_happy1(s) == True\n    return True\
    \ \nend ", "    if is_happy(s, 1, 3)\n    else false\nend", '"""', "    let len\
    \ = length(s)\n    if len >= 3\n        then let hap = is_hap(s[1..len])\n   \
    \     if hap\n            then return hap\n            else return false\n   \
    \     else return false\n    else return false\nend\n</code>\n<|/ a |>\n<| c |>\n\
    Please explain your answer, not just giving the solution, thanks.\n<|/ c |>\n\
    <| c |>\nThank you for answering but I don't think this works.\n<|/ c |>\n<| c\
    \ |>\nPlease elaborate, and show an example where it fails.\n<|/ c |>\n<| a |>\n\
    <code>", "    length <- length(s) \n    is_happy <- length >= 3 \n    for i in\
    \ 1 .. length/3\n        if (s[i .. i + 3] == s[i .. i + 3])\n            is_happy\
    \ = false\n    return is_happy", "    if is_happy(s[2]){\n    if is_happy(s[3]){\n\
    \    if is_happy(s[4]){\n    if is_happy(s[5]){\n    if is_happy(s[6]){\n    if\
    \ is_happy(s[7]){\n    if is_happy(s[8]){\n    if is_happy(s[9]){\n    if is_happy(s[10]){\n\
    \    if is_happy(s[11]){\n    if is_happy(s[12]){\n    if is_happy(s[13]){\n \
    \   if is_happy(s[14]){\n    if is_happy(s[15]){\n    if is_happy(s[16]){\n  \
    \  if is_happy(s[17]){\n    if is_happy(s[18]){\n    if is_happy(s[19]){\n   \
    \ if is_happy(s[20]){\n    if is_happy(s[21]){\n    if is_happy(s[22]){\n    if\
    \ is_happy(s[23]){\n    if is_happy(s[24]){\n    if is_happy(s[25]){\n    if is_happy(s[26]){\n\
    \    if is_happy(s[27]){\n    if is_happy(s[28]){\n    if is_happy(s[29]){\n \
    \   if is_happy(s[30]){\n    if is_happy(s[31]){\n    if is_happy(s[32]){\n  \
    \  if is_happy(s[33]){\n    if is_happy(s[34]){\n    if is_happy(s[35]){\n   \
    \ if is_happy(s[36]){\n    if is_happy(s[37]){\n    if is_happy(s[38]){\n    if\
    \ is_happy(s[39]){\n    if is_happy(s[40]){\n    if is_happy(s[41]){\n    if is_happy(s[42]){\n\
    \    if is_happy(s[43]){\n    if is_happy(s[44]){\n    if is_happy(s[45]){\n \
    \   if is_happy(s[46]){\n    if is_happy(s[47]){\n    if is_happy(s[48]){\n  \
    \  if is_happy(s[49]){\n    if is_happy(s[50]){\n    if is_happy(s[51]){\n   \
    \ if is_happy(s[52])){\n    if is_happy(s[53]){\n    if is_happy(s[54]){\n   \
    \ if is_happy(s[55]){\n    if is_happy(s[56]){\n    if is_happy(s[57]){\n    if\
    \ is_happy(s[58]){\n    if is_happy(s[59]){\n    if is_happy(s[60]){\n    if is_happy(s[61]){\n\
    \    if is_happy(s[62])){\n    if is_happy(s[63]){\n    if is_happy(s[64]){\n\
    \    if is_happy(s[65]){\n    if is_happy(s[66]){\n    if is_", "    if is_happy(s)\n\
    \    else false\nend\n</cell>\n<code language=julia-1.6>\n@test is_happy(\"\"\
    )\n@test is_happy(\"a\")\n@test is_happy(\"ab\")\n@test is_happy(\"abc\")\n@test\
    \ is_happy(\"abcd\")\n@test is_happy(\"aa\")\n@test is_happy(\"abb\")\n@test is_happy(\"\
    abbb\")\n@test is_happy(\"abbbc\")\n@test is_happy(\"abbbcd\")\n@test is_happy(\"\
    ad\")\n@test is_happy(\"adb\")\n@test is_happy(\"adbc\")\n@test is_happy(\"adbcd\"\
    )\n@test is_happy(\"adbb\")\n@test is_happy(\"adbbc\")\n@test is_happy(\"adbbcd\"\
    )\n@test is_happy(\"xyy\")\n</cell>\n<text>\nSolution", "    if is_happy_string(s)\n\
    \        true\n    else\n        false\nend", "    if s.length < 3\n        return\
    \ true\n    else if distinct3(s, 3) == 0\n        return true\n    else\n    \
    \    return false\n    end\nend", "    length(a)<3 || length(a)==3 && all(uniq(a[i\
    \ : i + 3])<3 | uniq(a[i : i + 3])>1 for i \u2208 [0..(length(a)-2) - 1])\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a |>\nMy Solution\n<code>", "    if is_empty(s)\
    \ != true \n    then return true\n    else \n        is_happy(rev([(s[i],i) for\
    \ i in 1:length(s)])) == true\nend", "    if is_empty(s) != true\n        false\n\
    \    else\n        true\n        \n        \nlet happy_test(s::String)::Bool \n\
    \    is_happy(s)\n    \nlet happyTest(s::String)::Bool \n    happy_test(s)\n \
    \   \n        \nlet is_happy_str(s::String)::Bool \n    is_happy(s)\n    \nlet\
    \ happyStrTest(s::String)::Bool \n    happy_test(s)\n    \n        \nlet is_happy_str(s::String)::Bool\
    \ \n    is_happy(s)\n    \nlet happyStrTest(s::String)::Bool \n    happy_test(s)\n\
    \    \n        \nlet is_happy_str(s::String)::Bool \n    is_happy(s)\n    \nlet\
    \ happyStrTest(s::String)::Bool \n    happy_test(s)\n    \n        \nlet is_happy_str(s::String)::Bool\
    \ \n    is_happy(s)\n    \nlet happyStrTest(s::String)::Bool \n    happy_test(s)\n\
    \    \n        \nlet is_happy_str(s::String)::Bool \n    is_happy(s)\n    \nlet\
    \ happyStrTest(s::String)::Bool \n    happy_test(s)\n    \n        \nlet is_happy_str(s::String)::Bool\
    \ \n    is_happy(s)\n    \nlet happyStrTest(s::String)::Bool \n    happy_test(s)\n\
    \    \n        \nlet is_happy_str(s::String)::Bool \n    is_happy(s)\n    \nlet\
    \ happyStrTest(s::String)::Bool \n    happy_test(s)\n    \n        \nlet is_happy_str(s::String)::Bool\
    \ \n    is_happy(s)\n    \nlet happyStrTest(s::String)::Bool \n    happy_test(s)\n\
    \    \n        \nlet is_happy_str(s::String)::Bool \n    is_happy(s)\n    \nlet\
    \ happyStrTest(s::String)::Bool \n    happy_test(s)\n    \n        \nlet is_happy_str(s::String)::Bool\
    \ \n    is_happy(s)\n    \nlet happyStrTest(s::String)::Bool \n    happy_test(s)\n\
    \    \n        \nlet is_happy_str(s::String)::Bool \n    is_happy(s)\n    \nlet\
    \ happyStrTest(s::String)::Bool \n    happy_test(s)\n    \n        \nlet is_happy_str(s::String)::Bool\
    \ \n    is_happy(s)\n    \nlet happyStrTest(s::String)::Bool \n", "    return\
    \ (length(s) > 2) and (is_hapjl(s, true))\nend", "    if is_happy(s) == true\n\
    \    else \n        if is_happy(s[1..2]) == true and is_happy(s[2..3]) == true\n\
    \        else \n            if s[1..2] == s[2..3]\n                then is_happy(s[3..end])\
    \ == true\n                else is_happy(s[1..3]) == true\n            else \n\
    \                is_happy(s[1..3]) == true\n            else \n              \
    \  is_happy(s[1..2]) == true\n        end \n    end \nend \n</cell>\n<code language=julia-1.0>\n\
    is_happy(a) \n</cell>\n<code language=julia-1.0>\nis_happy(abc)\n</cell>\n<code\
    \ language=julia-1.0>\nis_happy(bac)\n</cell>\n<code language=julia-1.0>\nis_happy(bcd)\n\
    </cell>\n<code language=julia-1.0>\nis_happy(abcd) \n</cell>\n<code language=julia-1.0>\n\
    is_happy(xyz) \n</cell>\n<text>\nTask 7. Guess the word\nThe guess function checks\
    \ whether the input string is correct or not according to the following rules:",
  "    if length(a) < 3 || length(a) > 3 || length(a-s[end-1]-s[end-2]-s[end-3]) <\
    \ 3 then \n        false\n    else \n        true\n    end\nend", "    if is_happy(s)\
    \ == true \n    else \n        if is_happy_2(s) == true \n        else false\n\
    </code>\nThe second function is_happy_2 is the same, with some additional conditions\
    \ to eliminate duplicate letters. You have to create two functions to solve the\
    \ problem, but it is easier to read and debug if you solve them together because\
    \ each one is doing one thing only and are isolated from each other. You can try\
    \ and solve them at the same time with these two functions and see what happens.\n\
    <|/ a tags=algorithm,functional-programming,haskell dscore=0 |>\n<| c |>\n`is_happy`\
    \ is the same as `is_happy_2` except that it has some additional conditions to\
    \ eliminate duplicate letters. You can try to solve them at the same time with\
    \ these two functions. I hope that this clarifies my question.\n<|/ c |>\n<| c\
    \ |>\nI tried to solve the problem with your code, with my own code but I can't\
    \ get it to work. I keep getting this error message: \"Parse error in pattern:\
    \ is_happy_2\". Can you please help me out with this?\n<|/ c |>\n<| c |>\nYes,\
    \ I changed my answer because I missed that the first two functions had the same\
    \ name. I edited my answer to fix it.\n<|/ c |>\n<| c |>\nThank you very much\
    \ for helping me out. I fixed my code as you wrote it above, but I keep getting\
    \ this error message when I try to run it: \"parse error in pattern: is_happy_2\"\
    . Can you please help me?\n<|/ c |>\n<| c |>\nI don't understand why this is happening.\
    \ Is it because of the type declaration that I use? I use \"is_happy_2 :: String\
    \ -> Bool\" instead of \"is_happy_2 :: String -> Bool\". Can you please help me\
    \ out?\n<|/ c |>\n<| a tags=algorithm,functional-programming,haskell |>\nYou can\
    \ use the function [(a,Int)] to store the positions of every character. Then using\
    \ those positions, you only have to check if the characters repeat and are adjacent,\
    \ like:\n<code>\nimport Data.List\nimport Data.Function (on)", "    len_s=s.length()\n\
    \    if len_s<3 return false else \n        all (_==s[1..(i+1)] for i=1:len_s-1\
    \ for _ in unique(happy(s[1..(i-1)]))) else true\n    end\n</code>\n<|/ a |>\n\
    <| a dscore=0 |>\n<code>", "    m <- (String.length(s)>0)\n    l <- (String.length(s)\
    \ >= 3)\n    if m && l && String.is_permutation(String.slice(s,0,3)) == true\n\
    \    then\n    true\n    else \n    false\n    end\nend", "    if is_happy(s.length,0)\n\
    \        true\n    else\n        if s.is_empty\n            true\n        else\n\
    \            if is_happy(s.length - 3,0)\n                is_happy(s.substring(1,s.length\
    \ - 3),1)\n            else\n                false\n    end\nend", "    if is_happy(s.len())\n\
    \    else \n        false\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    ## Test it\n</cell>\n<code language=julia-1.5>\n@test is_happy(\"adb\")\n@test\
    \ is_happy(\"xyy\")\n@test is_happy(\"abc\")\n</cell>\n<text>\nTask\nWrite a function\
    \ that removes duplicates in a given string.\nThe function should remove the duplicates\
    \ if they are adjacent to each other. \nFor example, given a string s, you should\
    \ remove \"aabbcc\". The final string should be \"abc\".", "    if is_happy_impl(s)\n\
    \    end\nend", "    length := length(s);\n    if length >= 3\n    then \n   \
    \     for x in (s |> subseq 0 3 |> unique |> sort) do return false; end ;\n  \
    \  else return true;\n    end ;\n    \nis_happy(\"\");\n</code>\n<|/ a |>\n<|\
    \ a |>\nYou can use the function mapcat:\n<code>\nis_happy(s:string):bool:bool\
    \ = length(s)>=3 && all (\\(c) in s -> not (contains(c,s))) (mapcat (\\(c) ->\
    \ [c]) (cat(s)))\n</code>\nThe above function takes three parameters:", "    if\
    \ is_nil(s) then false else is_happy(head s) + is_happy(tail s)\n</code>\n<|/\
    \ a tags=haskell dscore=0 |>\n<| c |>\nThis is not the definition of `is_happy`.\n\
    <|/ c |>\n<| a dscore=0 |>\nThe simplest solution is to use pattern matching and\
    \ a helper function:\n<code>\nimport Data.List\nimport Data.Maybe", "    if is_happy(s.length)\
    \ == False then\n    true\nelse\n    if is_happy(s.length) == True then\n    for\
    \ i in\n        if s[i] != s[i+1] && s[i] != s[i+2] && s[i] != s[i+3] then\n \
    \           true\n        else\n            false\n        end\n    end\nend\n\
    end\n</cell>\n<text>\nDay 13: Binary Trees\nAdvent of code Day 13: Binary Trees\n\
    Part 1", "    let mut happy_count = 0 \n    let happy_chars_set = Set(\"aa\",\
    \ \"ab\", \"ac\", \"ad\", \"ae\", \"af\", \"ag\", \"ah\", \"ai\", \"aj\", \"ak\"\
    , \"am\", \"an\", \"ao\", \"ap\", \"aq\", \"ar\", \"as\", \"at\", \"au\", \"av\"\
    , \"aw\", \"ax\", \"ay\", \"az\")\n    for ch in s do \n        if happy_chars_set.contains(ch)\
    \ then\n            happy_count += 1 \n        end \n    end\n    if happy_count\
    \ >= 3 then true else false \nend\n</code>\n<|/ a |>\n<| c |>\nYes, this is correct,\
    \ but it's slow. My solution also works but is way slower.\n<|/ c |>\n<| c |>\n\
    Sorry for my misunderstanding. Do you have an example of string which is slower\
    \ than yours?\n<|/ c |>\n<| c |>\nYes, I added it above.\n<|/ c |>\n<| c |>\n\
    I don't think this is an example of string which is slower than yours. The problem\
    \ is string searching itself is slow. I am looking for an efficient way to check\
    \ if a string is hapjl. Not a method to check if a string is hapjl. I am looking\
    \ for an efficient way to count consecutive letters in a string which are distinct.\
    \ The efficient method should only search the first 3 characters. This is an example\
    \ of string which would be slower.\n<|/ c |>\n<| c |>\nAh... Sorry, I think I\
    \ got your point. Please check the new version of the answer.\n<|/ c |>\n<| a\
    \ dscore=0 |>\nThis is my solution using only base julia that doesn't require\
    \ installing any package:\n<code>", "    length=length(s)\n    if length>=3 &&\
    \ is_distinct(s) && length>=3 && is_distinct(substr(s,1,3)) && length>=3 && is_distinct(substr(s,4,length))\n\
    \    then true\n    else false\n    end\nend\n</code>\n<|/ a tags=string,julia,performance\
    \ |>\n<| a |>\nThis can be done in O(n) time by sorting the string in reverse\
    \ order and checking if the first three characters are the same as the last three\
    \ characters.  I used the code below to test it:\n<code>\njulia> function is_happy(s::String)\n\
    \         if length(s) < 3\n           return false\n         end\n         let\
    \ a = [sort(s, rev=true)]\n           if a[1] == a[2]\n             return a[3]\
    \ == a[4]\n           else\n             return false\n           end\n      \
    \   end\n       end\nis_happy (generic function with 1 method)", "    n <- length(s)\n\
    \    if n == 0 then\n        true\n    else \n        if n == 3 then\n       \
    \     for i in (2..n-1) do \n                if s[i] == s[i+1] then\n        \
    \            false\n                else\n                    true\n        end\n\
    \    end\nend", "    if is_empty(s)\n        true\n    else if length(s)<3 ||\
    \ sum((length(s)-i)%3 for i in 0..length(s))\n        false\n    else if !all(c\
    \ in string::alphabets for c in s)\n        false\n    else\n        true\n  \
    \  end\nend", "    if is_empty(s) \n        return false\n    x <- strslice(s,\
    \ 0)\n    if is_empty(x) \n        return false\n    hapjl <- is_happy(drop(s))\n\
    \    if hapjl \n        return true\n    y <- strslice(s, 1)\n    if is_empty(y)\
    \ \n        return false\n    hapjl <- is_happy(drop(s))\n    if hapjl \n    \
    \    return true\n    y <- strslice(s, 2)\n    if is_empty(y) \n        return\
    \ false\n    y <- strslice(s, 3)\n    if is_empty(y) \n        return false\n\
    \    x <- strslice(s, 4)\n    if is_empty(x) \n        return false\n    hapjl\
    \ <- is_happy(drop(s))\n    if hapjl \n        return true\n    y <- strslice(s,\
    \ 5)\n    if is_empty(y) \n        return false\n    y <- strslice(s, 6)\n   \
    \ if is_empty(y) \n        return false\n    x <- strslice(s, 7)\n    if is_empty(x)\
    \ \n        return false\n    hapjl <- is_happy(drop(s))\n    if hapjl \n    \
    \    return true\n    y <- strslice(s, 8)\n    if is_empty(y) \n        return\
    \ false\n    y <- strslice(s, 9)\n    if is_empty(y) \n        return false\n\
    \    x <- strslice(s, 10)\n    if is_empty(x) \n        return false\n    hapjl\
    \ <- is_happy(drop(s))\n    if hapjl \n        return true\n    y <- strslice(s,\
    \ 11)\n    if is_empty(y) \n        return false\n    y <- strslice(s, 12)\n \
    \   if is_empty(y) \n        return false\n    x <- strslice(s, 13)\n    if is_empty(x)\
    \ \n        return false\n    hapjl <- is_happy(drop(s))\n    if hapjl \n    \
    \    return true\n    y <- strslice(s, 14)\n    if is_empty(y) \n        return\
    \ false\n    y <- strslice(s, 15)\n    if is_empty(y) \n        return false\n\
    \    x <- strslice(s, 16)\n    if is_empty(x) \n        return false\n    hapjl\
    \ <- is_happy(drop(s))\n    if hapjl \n        return true\n    y <- strslice(s,\
    \ 17)\n    if is_empty(y) \n        return false\n    y <- strslice(s, 18)\n \
    \   if is_empty(y) \n        return false\n    x <- strslice(s, 19)\n    if is_empty(x)\
    \ \n        return false\n    hapjl <- is_happy(drop(s))\n    if hapjl \n    \
    \    return true\n    y <- strslice(s, 20)\n    if is_empty(y) \n        return\
    \ false\n    y <- strslice(s, 21)\n    if is_empty(y) \n        return ", "  \
    \  return length(s) >= 3 and (is_distinct_3(xs)) == True\nend", "    if is_happy(s.length())\
    \ == true \n    then \n    for i in s.substring(1,s.length()-1) \n    if is_happy(i)\
    \ == true\n    then return true \n    else return false \n    else return false\
    \ \n    else return false \nend \nend \n</cell>\n<text>\nWrite a function named\
    \ count_happy that takes in one parameter s: the string s (a string) and returns\
    \ the number of happy substrings.\nThe happy substring of a string is the longest\
    \ substring that contains exactly 3 distinct letters.", "    \n    # your code\
    \ here\n    \n    return true", "    if (length(s)<3) || (length(s)==length(s)/3)\
    \ then\n        return False\n    for i in [0..(length(s-1)/3)-1] do\n       \
    \ !(is_distinct(take(s,i*3), take(s,i*3+1), take(s,i*3+2)))\n    end\nend\n</cell>\n\
    <text>\nTask 4: Is given string a palindrome?", "    if is_happy len(s) >= 3\n\
    \    and\n        for (i,j) in zip(s[0..2],s[2..])\n            == j\n       \
    \     or\n        end for\n    then \n        true\n    else\n        false\n\
    \    end if\nend function", "    length::Int64 = length(s)\n    return length\
    \ >= 3 and all ((x in set((i,i+1,i+2)) | set( (i,i+2,i-1) for i in [1..length])\
    \ )for x in s)\nend", "    if s.length < 3\n        return false\n    if length(s)\
    \ == 3\n        return is_happy_at_3(s)\n    else\n        return true\nend\n\"\
    \"\"\n    Your task is to return a list of all possible hapjls with 3 letters.\n\
    \    For example:\n    >>> all_happy_threes(a)\n    [abc, abd, abe, abf, abg,\
    \ abh, abj, abk, abl, abm, abn, abo, abp, abq, abr, abs, abt, abu, abv, abw, abx,\
    \ aby, abz]\n    >>> all_happy_threes(ab)\n    [ab, ba, aa, ab, ba, aa, ab]\n\
    \    \"\"\"", "    if len(s) < 3 return False\n    for i in s\n        return\
    \ false\n    else return True\n</code>\n<|/ a tags=recursion,string,haskell,boolean\
    \ |>\n<| a dscore=0 |>\n<code>\nhappyString :: String -> Bool\nhappyString = length\
    \ `elem` [\"a\", \"e\", \"i\", \"o\", \"u\"]\n</code>\n<|/ a tags=recursion,string,haskell,boolean\
    \ |>\n<| c |>\nIt's good to also provide an explanation of your code so that the\
    \ OP and future readers will be able to learn from your answer.\n<|/ c |>\n<|\
    \ a |>\nI wrote this in python a while ago:\n<code>\ndef isHappy(s):\n    s =\
    \ s.lower()\n    if len(s) >= 3:\n        for i in range(0,len(s)-3):\n      \
    \      if( s.count(s[i:i+3])!= 3 ): \n                return False\n    return\
    \ True\n</code>\n<|/ a dscore=0 tags=recursion,string,haskell,boolean |>\n<| a\
    \ tags=recursion,string,haskell,boolean |>\nA solution in python would be like:\n\
    <code>\ndef isHappy(s):\n    return len(s) >= 3 and all(x in ['a', 'e', 'i', 'o',\
    \ 'u'] for x in set(s[3:]))\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis only works\
    \ if `s[3:4]` is a `str`; `s[3:4]` here will always be `'o'`.\n<|/ c |>\n<| a\
    \ dscore=0 tags=recursion,string,haskell,boolean |>\n<code>\nhappyString :: String\
    \ -> Bool\nhappyString x =\n  x `elem` [ \"a\", \"e\", \"i\", \"o\", \"u\" ] ||\
    \ (length x >= 3 && all (\\x -> x `elem` ['a','e','i','o','u']) $ tail x)\n</code>\n\
    <|/ a |>\n<| a tags=recursion,string,haskell,boolean |>\nHere is another solution:\n\
    <code>\nhappyString :: String -> Bool\nhappyString x = all (\\x -> x `elem` [a,e,i,o,u])\
    \ x\n    where \n        a = ['a']\n        e = ['e']\n        i = ['i']\n   \
    \     o = ['o']\n        u = ['u']\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis\
    \ only works if `x == \"\"`; `x == \"\"` here will always be `False`.\n<|/ c |>\n\
    <| a |>\n<code>\nhappyString :: String -> Bool\nhappyString x\n | length x < 3 ",
  '    if is_happy_(0) then True else False end', "    \n    \"\"\"\n    \n    Your\
    \ code here\n    \n    \"\"\"\n    \n    true\n    return length(s)>3 and all(unique([s[i:i+3]\
    \ for i in range(3,length(s)-3,3)]))\n    \n    \n    \n\"\"\"\n### Q4 [spoiler]\n\
    \"\"\"", "    \n    length::Int = length(s)\n    \n    if (length < 3)\n     \
    \   return false\n    endIndex = 3 + 3\n    \n    for index in 1:(endIndex - 4)\n\
    \        \n        if (index(s, index, index + 1) == index(s, index, index + 2)\
    \ && index(s, index, index + 1) != index(s, index, index + 3))\n            return\
    \ false\n        end\n    end\n    \n    return true\nend\n</cell>\n<code language=julia-1.0>\n\
    is_happy(a)\n</cell>\n<code language=julia-1.0>\nis_happy(aa)\n</cell>\n<code\
    \ language=julia-1.0>\nis_happy(abcd)\n</cell>\n<code language=julia-1.0>\nis_happy(aabb)\n\
    </cell>\n<code language=julia-1.0>\nis_happy(adb)\n</cell>\n<code language=julia-1.0>\n\
    is_happy(xyy)\n</cell>\n<text>\nProblem 7", "    if is_empty(s) then false else\
    \ s \n    |> is_happy\n    |> is_happy_length\n    |> is_happy_distinct\nend\n\
    </cell>\n<code language=julia-1.5>\na = String[\"a\"]\n</cell>\n<code language=julia-1.5>\n\
    is_happy(a)\n</cell>\n<code language=julia-1.5>\nb = String[\"b\"]\n</cell>\n\
    <code language=julia-1.5>\nis_happy(b)\n</cell>\n<code language=julia-1.5>\nc\
    \ = String[\"c\"]\n</cell>\n<code language=julia-1.5>\nis_happy(c)\n</cell>\n\
    <code language=julia-1.5>\nd = String[\"d\"]\n</cell>\n<code language=julia-1.5>\n\
    is_happy(d)\n</cell>\n<text>\nExercise 3\nWrite a predicate is_happy2(str::String)\
    \ which checks if a String is happy given as argument", "    return (s == hapjl)\n\
    </code>\nThe above implementation is very inefficient so let's rewrite it in more\
    \ functional style.\n<code>\n# We will use the fact that \"abc\" is equivalent\
    \ to \"abcabc\" so we only need to check this once\nhappiness :: String -> Bool\n\
    happiness s = all (== hapjl) $ [take 3 s | _ <- splitAt 3 s]\n</code>\nOr more\
    \ functional:\n<code>\nhappiness :: String -> Bool\nhappiness = all (== hapjl)\
    \ . map take . splitAt 3\n</code>\nAnd now we can test our implementation against\
    \ your implementation:\n<code>\nhappiness \"abc\"\n> False\nhappiness \"abcabc\"\
    \n> False\nhappiness \"abcd\"\n> True\nhappiness \"abbbbb\"\n> False\n</code>\n\
    As you can see, our implementation is about 3 times faster than the OP's implementation.\n\
    <|/ a dscore=4 tags=string,haskell,boolean,performance,algorithm |>\n<| a dscore=2\
    \ tags=string,haskell,boolean,performance,algorithm |>\nHere's another solution,\
    \ which is essentially the same as the one by. \nIt's based on the fact that Strings\
    \ in Haskell are actually linked lists, and we could simply scan the list in O(1)\
    \ to find out whether or not a character is unique. The benefit of this solution\
    \ is that the performance is independent of the input length as it scans the list\
    \ in O(1).\n<code>\nisHappy :: String -> Bool\nisHappy \"abc\" =  False\nisHappy\
    \ \"abcabc\" = False\nisHappy \"abcd\" = True\nisHappy \"abbbbb\" = False\n</code>\n\
    To improve the performance, we can use the fact that Strings in Haskell are actually\
    \ linked lists, and we could simply scan the list in O(1) to find out whether\
    \ or not a character is unique. \n<code>\nisHappy :: String -> Bool\nisHappy str\
    \ = isHappyHelper str \"\"\n    where isHappyHelper str last\n               \
    \     | last == str = True\n                    | last == \"\" = False\n     \
    \               | otherwise = head str `elem` last\n</code>\n<|/ a |>\n<| c |>\n\
    Note that this solution has a time complexity of O(n^2) for the general case (where\
    \ n is the number of characters in the string). For this specific example, it\
    \ only makes a difference if the string contains only \"a\". Unless the goal is\
    \ simply to learn Haskell, you ", "    check length of s == 3 && length in {3,4}\n\
    \    check whether all 3 consecutive letters are not distinct\n    \n\"\"\""]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
