name: HumanEval_158_find_max
language: jl
prompt: "\"\"\"Write a function that accepts a vector of strings.\n    The vector\
  \ contains different words. Return the word with maximum number\n    of unique characters.\
  \ If multiple strings have maximum number of unique\n    characters, return the\
  \ one which comes first in lexicographical order.\n\n    >>> find_max([\"name\"\
  , \"of\", \"string\"])\n    \"string\"\n    >>> find_max([\"name\", \"enam\", \"\
  game\"])\n    \"enam\"\n    >>> find_max([\"aaaaaaa\", \"bb\", \"cc\"])\n    \"\
  aaaaaaa\"\n    \"\"\"\nfunction find_max(words::Vector{String})::String \n"
tests: "using Test\n\n@testset begin\n\ncandidate = find_max;\n\t@test(candidate([\"\
  name\", \"of\", \"string\"]) == \"string\")\n\t@test(candidate([\"name\", \"enam\"\
  , \"game\"]) == \"enam\")\n\t@test(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"\
  aaaaaaa\")\n\t@test(candidate([\"abc\", \"cba\"]) == \"abc\")\n\t@test(candidate([\"\
  play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\n\t@test(candidate([\"\
  we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\n\t@test(candidate([\"we\", \"\
  are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\n\t@test(candidate([\"this\"\
  , \"is\", \"a\", \"prrk\"]) == \"this\")\n\t@test(candidate([\"b\"]) == \"b\")\n\
  \t@test(candidate([\"play\", \"play\", \"play\"]) == \"play\")\nend\n"
completions: ["    word_count = Dict()\n    for word in words \n        if word in\
    \ word_count \n            word_count[word] += 1 \n        else \n           \
    \ word_count[word] = 1\n    end", '"""', "    let num_unique = unique(words)\n\
    \    let num_unique_sorted = num_unique.sort\n    if num_unique_sorted[1] == length(words)\
    \ \n        then num_unique_sorted[1] \n    else num_unique_sorted[1][1]\nend\n\
    </cell>\n<text>\nExercise 1\nWrite a function that accepts a vector of strings.\n\
    \    The vector contains different words. Return the word with minimum number\n\
    \    of unique characters. If multiple strings have minimum number of unique\n\
    \    characters, return the one which comes first in lexicographical order.",
  "    lengths = map(length, words)\n    maxLength = max(lengths)\n    \n    \n  \
    \  sortedWords = sort(words) # Sort the words lexicographically\n    return sortedWords[1,2]\n\
    end\n</cell>\n<text>\nExercise 2\nWrite a function that accepts a vector of strings.\
    \ The vector contains different words. Write a function that accepts a vector\
    \ of strings. The vector contains different words. Return the word with minimum\
    \ number of unique characters. If multiple strings have maximum number of unique\
    \ characters, return the one which comes first in lexicographical order.", " \
    \   word = words[argmax(length.(words))]\n    while haskey(dict, word)\n     \
    \   word = words[argmax(length.(words))]\n    end\n    return word\n</code>\n\
    <|/ a dscore=0 |>\n<| a |>\nThis question is very similar to another one that\
    \ was posted earlier. This is an approach to solve the problem. It is similar\
    \ to Nelson's solution, but does it in a more straightforward manner.\n<code>\n\
    findmax(x::Vector{String}) = findmax(x, Dict())", "    uniques = Set()\n    unique_word_count\
    \ = HashMap{String,Int64}()\n    for word in words\n        uniques.union!(word.unique())\n\
    \        unique_word_count[word] = length(uniques)\n    end\n    for word in words\n\
    \        if unique_word_count[word] > 0\n            return word\n        end\n\
    \    end\nend\n</cell>\n<text>\nExercise: Write a function which accepts a vector\
    \ of integers and returns the maximum number.", "    unique_set = set()\n    words_with_unique_count\
    \ = Map[String, Int]()\n    for (word) in words\n        if word in unique_set\
    \ \n            words_with_unique_count[word] += 1\n        else\n           \
    \ unique_set.add(word)\n            words_with_unique_count[word] = 1\n      \
    \      \n    max_unique_char = max(words_with_unique_count.keys, key=lambda key:\
    \ words_with_unique_count[key])\n    for word in unique_set \n        if words_with_unique_count[word]\
    \ == words_with_unique_count[max_unique_char] \n            return word\n    else\
    \ \n        return max_unique_char\nend", "    lengths = map(length, words)\n\
    \    return words[argmax([length(words) - length(uniques) | uniques for uniques\
    \ in zip(words,lengths)])]\nend\n</cell>\n<text>\nExercise: Write a function that\
    \ accepts a string and returns true if it contains only the letters 'a' and 'e'",
  "    if len(words) == 0\n        return \"\"\n    return find_max(words[1 .. end],\
    \ words)\nend ", "    unique_characters = Set()\n    word_with_max = \"\"\n  \
    \  \n    for word in words\n        unique_characters_word = Set()\n        for\
    \ character in word\n            unique_characters_word.add(character)\n     \
    \   end\n        unique_characters.merge(unique_characters_word)\n    end\n  \
    \  \n    word_with_max = words[word_index(unique_characters, word_with_max)]\n\
    end", "    unique_chars = Set{String}()\n    \n    char_counts = Dict{String,\
    \ Int}()", "    unique_chars = Dict{Char,Int}()\n    for w in words\n        for\
    \ c in w\n            unique_chars[c] = unique_chars[c] + 1 if c in unique_chars\
    \ \n        end\n    end\n    sorted_unique_chars = sort_by(unique_chars, by =\
    \ :value)\n    return sorted_unique_chars[end][1]\nend\n</cell>\n<text>\n3.2.\
    \ Write a function that accepts a vector of strings and returns a vector containing\
    \ all the unique characters from all strings.", "    # Your code here\n    #words\
    \ = sort(words)\n    max_count = 0\n    word = \"\"\n    for w in words\n    \
    \    word_count = length(w)\n        if word_count > max_count\n            max_count\
    \ = word_count\n            word = w\n        end\n    end\n    return word\n\
    end", '    chars = unique(words) |> collect', "    \n    \"\"\"Given a vector\
    \ of words, return the word which appears most frequently in the given vector\"\
    \"\"\n    \n    function find_max (words:Vector{String})::String \n    \"\"\"\
    Count the number of unique characters in a word and store the result in a dictionary\"\
    \"\"\n    \n    \"\"\"Convert the word to a string, then use map to map each character\
    \ to an integer\"\"\"\n    \n    \"\"\"Sort the dictionary by key, returning the\
    \ key with the highest value\"\"\"\n    \n    \n    \"\"\"Return the first key\
    \ that appears more than once\"\"\"\n    \nend", "    unique_chars = Set()\n \
    \   for word in words\n        unique_chars = unique_chars | Set(word)\n    end\n\
    \    unique_chars\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nI don't think this\
    \ is correct. `unique_chars` should be the length of the longest string, not the\
    \ length of the set of unique characters in all strings.\n<|/ c |>\n<| c |>\n\
    I updated my answer to include the correct version of the function. Thanks for\
    \ pointing that out.\n<|/ c |>\n<| c |>\nAh, I see. I hadn't considered the case\
    \ where there are repeating characters. In that case, the set of unique characters\
    \ would include the entire string. In any case, I think it would be a good idea\
    \ to return the original string instead of the one that came first in the lexicographical\
    \ order.\n<|/ c |>\n<| a dscore=2 |>\nJust for fun, here is a version that iterates\
    \ over the word vector:\n<code>\njulia> function find_max(words::Vector{String})\n\
    \           unique_chars = Set()\n           for word in words\n             \
    \  for char in word\n                   if !in(char, unique_chars)\n         \
    \              unique_chars = unique_chars | Set(char)\n                   end\n\
    \               end\n           end\n           unique_chars\n       end\nfind_max\
    \ (generic function with 1 method)", "    \n    # Write your code here\n    ",
  "    unique_characters = count_unique(words)\n    smallest_value = smallest_key(unique_characters)\n\
    \    if smallest_value == unique_characters[smallest_value] \n        return smallest_value\n\
    \    else \n        return find_max(unique_characters)", "    n = length(words)\n\
    \    if n == 0\n        return \"\"\n    if length(unique(words)) == n\n     \
    \   return words[1]\n    i = 2\n    while i < n\n        if length(unique(words[i-1:i-1:-1]))\
    \ > length(unique(words[i-1:i-1:-1]))\n            words[i-1:i-1:-1]\n       \
    \ else\n            words[i-1:i-1:-1]\n        end\n        i += 1\n    end\n\
    end", "    unique_char_counts = Vector{Int64}()\n    for word in words \n    \
    \    char_counts = count_chars(word)\n        for char_count, char_name in char_counts\n\
    \            if char_count > unique_char_counts[char_name]\n                unique_char_counts[char_name]\
    \ = char_count\n                best_char = char_name\n            end\n     \
    \   end\n    end\n    return best_char\nend", "    max_length = length(words)\n\
    \    unique_chars = count(words, \"a\")\n    \n    if unique_chars > max_length\n\
    \        word = words[1]\n    else\n        word = words[unique_chars]\n    end\n\
    \    \nend\n</cell>\n<code language=julia-1.5>\nfind_max([\"name\", \"of\", \"\
    string\"])\n</cell>\n<text>\nProblem 8\nWrite a function that accepts a vector\
    \ of vectors. In each vector, each element is a word. \n    Your function must\
    \ return the word with maximum number of unique characters. If multiple strings\
    \ have \n    maximum number of unique characters, return the one which comes first\
    \ in lexicographical order.", "    if len(words) ==  0\n        return \"\"\n\
    \    char_count = count_char(words[1])\n    max_count = 0\n    max_word = words[1]\n\
    \    for w in words\n        count =count_char(w);\n        if count > max_count\n\
    \            max_count = count\n            max_word = w\n        end\n    end\n\
    \    return max_word\nend", "\"\"\"Write a function that accepts a vector of strings.\n\
    \    The vector contains different words. Return the word with maximum number\n\
    \    of unique characters. If multiple strings have maximum number of unique\n\
    \    characters, return the one which comes first in lexicographical order.",
  "  \n    \"\"\"\n    Using a map to store the occurance of the words in input vector\
    \ and then \n    using sort function sort the vector of words in alphabetical\
    \ order \n    \"\"\"\n    word_map = Map[String, Int]()\n    for word in words\
    \ \n        if !isinkey(word_map, word) \n            word_map[word] = 0 \n  \
    \      end\n        word_map[word] += 1\n    end\n    word_map = [x for x in word_map\
    \ sort((x, y) -> length(x.1) < length(y.1) ? -1 : 1)]\n    \n    word_with_max_count\
    \ = word_map[end][1]\n    \n    if word_with_max_count > 1\n        return word_map[end].1\n\
    \    else\n        return word_map[end]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @test find_max([\"name\", \"enam\", \"game\"]) \u2248 \"enam\"\n@test find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"]) \u2248 \"aaaaaaa\"\n@test find_max([\"aaaaaaa\", \"\
    bb\", \"cc\", \"de\"]) \u2248 \"aaaaaaa\"\n@test find_max([\"aaaaaaa\", \"bb\"\
    , \"cc\", \"de\", \"gg\"]) \u2248 \"aaaaaaa\"\n@test find_max([\"aaaaaaa\", \"\
    bb\", \"cc\", \"de\", \"gg\", \"hh\"]) \u2248 \"aaaaaaa\"\n@test find_max([\"\
    aaaaaaa\", \"bb\", \"cc\", \"de\", \"gg\", \"hh\", \"ii\"]) \u2248 \"aaaaaaa\"\
    \n@test find_max([\"aaaaaaa\", \"bb\", \"cc\", \"de\", \"gg\", \"hh\", \"ii\"\
    , \"jj\"]) \u2248 \"aaaaaaa\"\n@test find_max([\"aaaaaaa\", \"bb\", \"cc\", \"\
    de\", \"gg\", \"hh\", \"ii\", \"jj\", \"kk\"]) \u2248 \"aaaaaaa\"\n</cell>\n<text>\n\
    Exercise 1\nWrite a function that accepts a vector of strings and returns a vector\n\
    containing integers indicating the number of unique characters in each\nstring.",
  "    if words.empty\n        \"\"\n    else\n        word = words[1]\n        unique\
    \ = reduce(+, map(length, words))\n        if unique == length(words)\n      \
    \      word\n        else\n            if unique == length(words[1])\n       \
    \         words[1]\n            else\n                words[1][1]\n        end\n\
    \    end\nend\n</cell>\n<text>\nAs the function is implemented, it can accept\
    \ a vector of strings or a vector of arrays (matrices or tensors). The function\
    \ returns a string.", "    \n    chars_map::Dict{Char,Int} = Dict{Char,Int}()\n\
    \    word_chars_map::Dict{String, Char} = Dict{String, Char}()\n    \n    for\
    \ w in words\n        for c in w\n            if chars_map[c] < chars_map[c] +\
    \ 1\n                chars_map[c] += 1\n            else\n                chars_map[c]\
    \ = 1\n        end\n    end\n    \n    \n    for w in words\n        if word_chars_map[w]\
    \ == nothing\n            word_chars_map[w] = words[findfirstindex(w, words)]\n\
    \        end\n    end\n    \n    \n    word = nothing\n    count = 0\n    for\
    \ w \u2208 words\n        if word_chars_map[w] == nothing\n            word_chars_map[w]\
    \ = words[findfirstindex(w, words)]\n        end\n    end\n    \n    \n    if\
    \ length(chars_map) == length(word_chars_map)\n        word = nothing\n    else\n\
    \        word_with_max_count = nothing\n        count_of_w = nothing\n       \
    \ count_of_c = nothing\n        for w \u2208 words\n            if word_chars_map[w]\
    \ == nothing\n                word_chars_map[w] = words[findfirstindex(w, words)]\n\
    \            end\n            \n            if chars_map[w] > count_of_c\n   \
    \             count_of_w = w\n                count_of_c = chars_map[w]\n    \
    \        else\n                count_of_c = chars_map[w]\n            end\n  \
    \      end\n        \n        if count_of_c > count_of_w\n            word = word_with_max_count\n\
    \        else\n            word = count_of_w\n        end\n    end\n    \n   \
    \ return word\nend\n</cell>\n<code language=julia-1.6>\nfind_max([\"name\", \"\
    enam\", \"game\"])\n</cell>\n<code language=julia-1.6>\nfind_max([\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n</cell>\n<code language=julia-1.6>\nfind_max([\"aaaaaaa\"\
    , \"bb\", \"cc\", \"d\"])\n</cell>\n<code language=julia-1.6>\nfind_max([\"aaaaaaa\"\
    , \"bb\", \"cc\", \"d\", \"ee\"])\n</cell>\n<code language=julia-1.6>\nfind_max([\"\
    aaaaaaa\", \"bb\", \"cc\", \"d\", \"ee\", \"f\"])\n</cell>\n<code language=julia-1.6>\n\
    find_max([\"aaaaaaa\", \"bb\", \"cc\", \"d\", \"ee\", \"f\", \"g\"])\n</cell>\n\
    <code language=julia-1.6>\nfind_max([\"aaaaaaa\", \"bb\", \"cc\", \"d\", \"ee\"\
    , \"f\", \"g\", \"h\"])\n</cell>\n<code language=julia-1.6>\nfind_max([\"aaaaaaa\"\
    , \"bb\", \"cc\", \"d\", \"ee\", \"f\", \"g\", \"h\", \"i\"])", "    sorted_list\
    \ = sort(words)\n    unique_chars = count(sorted_list).keys\n    return unique_chars[end][1]",
  "    maximum = length(words.sort())\n    for string in words \n        length =\
    \ length(string.sort())\n        if length > maximum\n            maximum = length\
    \ \n        end\n    end\n    return maximum == length(words.sort()) ? words[length(words.sort())]\
    \ : words[maximum(words.sort())]\nend\n</cell>\n<text>\nA more efficient way to\
    \ solve the problem using map function", "  \"\"\" Return the word with maximum\
    \ number of unique characters. If multiple strings have maximum number of unique\
    \ characters, return the one which comes first in lexicographical order.\n  \"\
    \"\"\n  let maxCount = 0\n  let maxWord = \"\"\n  for word in words\n    let count\
    \ = countUniqueChars(word)\n    if count > maxCount\n      maxCount = count\n\
    \      maxWord = word\n  end\n  return maxWord\nend", "    counts::Dict{String,\
    \ Int}\n    counts = Dict()\n    for i in words\n        word::String = i\n  \
    \      if counts[word] == nil\n            counts[word] = 1\n        else\n  \
    \          counts[word] += 1\n        end\n    end\n    keys::Array{String} =\
    \ collect(counts)\n    index = findfirst(x -> x[2] >= keys[2], keys(keys(counts)))\n\
    \    if index == nothing\n        return words[end]\n    else\n        return\
    \ words[index[2]]\n    end\nend", "    #O(n) complexity\n    #O(1) \n    \n  \
    \  if len(words) <= 0\n        return words[1]\n    \n    max_length = 0\n   \
    \ max_word = words[1]\n    for i in 2\n        if length(max_word) >  length(words[i])\n\
    \            max_length = length(max_word)\n            max_word = words[i]\n\
    \        else\n            max_word = words[i]\n        end\n    end\n    return\
    \ max_word\nend", "\"\"\"\n    find the word with maximum number of unique characters,\
    \ return it\n    in lexicographical order\n    \"\"\"\n    ans = words[1]\n  \
    \  for w in words[2:]\n        if length(collect(count(c) for c in w)) > length(collect(count(c)\
    \ for c in ans))\n            ans = w\n        end\n    end\n    return ans\n\
    end", "    count::Dict{String, Int}= Dict{String, Int}()\n    for word in words\
    \ \n        for char in word\n            count[char] = get(count, char, 0) +\
    \ 1\n    end\n    println(count)\n    for word in words\n        if count[word]\
    \ == get(count, word, 0) + 1\n            return word\n        end\n    end\n\
    end\n</code>\n<|/ a tags=function,julia |>\n<| c |>\nThis is great! But I wonder\
    \ if there is a way to just return the word itself instead of an index. I tried\
    \ just replacing \"return i\" with \"return word\" but that doesn't work. Any\
    \ suggestions?\n<|/ c |>\n<| c |>\nI guess you meant `return word` in the second\
    \ loop.\n<|/ c |>\n<| c |>\nYes, sorry about that! Thanks for the help.\n<|/ c\
    \ |>\n<| a tags=function,julia |>\n<code>", "    chars_set = Set[String]()\n \
    \   chars_set = chars_set.join(map(x -> x, words))\n    chars_set = chars_set\
    \ - chars_set\n    chars_set = chars_set - chars_set\n    chars_set = chars_set\
    \ - chars_set\n    chars_set = chars_set - chars_set\n    chars_set = chars_set\
    \ - chars_set\n    chars_set = chars_set - chars_set\n    chars_set = chars_set\
    \ - chars_set\n    chars_set = chars_set - chars_set\n    chars_set = chars_set\
    \ - chars_set\n    chars_set = chars_set - chars_set\n    chars_set = chars_set\
    \ - chars_set\n    chars_set = chars_set - chars_set\n    chars_set = chars_set\
    \ - chars_set\n    chars_set = chars_set - chars_set\n    chars_set = chars_set\
    \ - chars_set\n    chars_set = chars_set - chars_set\n    chars_set = chars_set\
    \ - chars_set\n    chars_set = chars_set - chars_set\n    chars_set = chars_set\
    \ - chars_set\n    chars_set = chars_set - chars_set\n    chars_set = chars_set\
    \ - chars_set\n    chars_set = chars_set - chars_set\n    chars_set = chars_set\
    \ - chars_set\n    chars_set = chars_set - chars_set\n    chars_set = chars_set\
    \ - chars_set\n    chars_set = chars_set - chars_set\n    chars_set = chars_set\
    \ - chars_set\n    chars_set = chars_set - chars_set\n    chars_set = chars_set\
    \ - chars_set\n    chars_set = chars_set - chars_set\n    chars_set = chars_set\
    \ - chars_set\n    chars_set = chars_set - chars_set\n    chars_set = chars_set\
    \ - chars_set\n    chars_set = chars_set - chars_set\n    chars_set = chars_set\
    \ - chars_set\n    chars_set = chars_set - chars_set\n    chars_set = chars_set\
    \ - chars_set\n    chars_set = chars_set - chars_set\n    chars_set = chars_set\
    \ - chars_set\n    chars_set = chars_set - chars_set\n    chars_set = chars_set\
    \ - chars_set\n    chars_set = chars_set - chars_set\n    chars_set = chars_set\
    \ - chars_set\n    chars_set = chars_set - chars_set\n    chars_set = chars_set\
    \ - chars_set\n    chars_set = chars_set - chars_set\n    chars_set = chars_set\
    \ - chars_set\n    chars_set = chars_set - chars_set\n    chars_set = chars_set\
    \ - chars_set\n    chars_set = chars_set - chars_set\n    chars_set = chars_set\
    \ - chars_set\n    chars_set = chars_set - chars_set\n    chars_set = chars_set\
    \ - chars_set\n    chars_set = chars_set - chars_set\n    chars_set = chars_",
  "  local word = words[1]\n  for i = 2:length(words) do\n    local unique_char_count\
    \ = 0\n    for c in words[i] do\n      unique_char_count += c[end]\n    end\n\
    \    if unique_char_count > word[end] then\n      word = words[i]\n    end\n \
    \ end\n  return word\nend\n</cell>\n<text>\nLet's test the implementation with\
    \ some inputs:", "    for i in words\n        if length(i) == length(unique(words))\n\
    \            return i\n        end\n    end\nend", "    return words[argmax(count.(words))]\n\
    end\n</cell>\n<text>\nTest your function:", "    \"\"\"Find the word with maximum\
    \ number of unique characters.\n    Return null if all words have maximum number\
    \ of unique characters.\n    \"\"\"\n    unique_words::Vector{String} = Vector{String}()\n\
    \    unique_word_counts::Vector{Int} = Vector{Int}()\n    for word in words do\
    \ unique_word_counts[word] <- unique_word_counts[word] + 1\n    for word in unique_word_counts\
    \ do if unique_word_counts[word] > 1 then\n        unique_words::Vector{String}\
    \ = [word]\n        break\n    else\n        unique_words::Vector{String} = word\n\
    \    end\n    for word in unique_words do return word end\n    return null\nend",
  "    word = words[end]\n    unique = sort(collect(words))\n    return unique[end]\n\
    end", "    # your code here\n    word_dict = Dict()\n    for w in words\n    \
    \    word_dict[w] = get(word_dict, w, 0) + 1\n        \n    res = word_dict[maximum(word_dict)]\n\
    \    for (k,v) in word_dict\n        word_dict[k] = v - v \n    end\n    \n  \
    \  for (k,v) in word_dict\n        if v > res\n            res = k\n        end\n\
    \    end\n    \n    return res\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ find_max([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\n@assert find_max([\"\
    a\", \"b\"]) == \"a\"\n@assert find_max([\"a\", \"a\", \"b\"]) == \"b\"\n@assert\
    \ find_max([\"a\", \"a\", \"b\", \"c\", \"d\"]) == \"c\"\n</cell>\n<text>\n12.\
    \ Write a Julia function to find all unique words in a given string.\nInput: A\
    \ string containing a sentence\nOutput: All unique words in the sentence", " \
    \   counts = Dict{String,Int}()\n    for w in words\n        counts[w] = get(counts,w,0)+1\n\
    \    end\n    sort(counts,by=x->length(x),rev=true)\n    lasts = reverse(sort(counts,by=x->counts[x],rev=true))\n\
    \    return lasts[1]\nend", "    unique_char_count = 0\n    for word in words\n\
    \        unique_char_count += length(word)\n    end", "    if length(strings.sort.(words))\
    \ == length(words)\n        return words.max\n    \n    unique_chars = Vector{Int}(0\
    \ :: Int)\n    max_unique_chars = -1\n    max_index = 0\n    for w in words\n\
    \        for c in w\n            unique_chars[c] = 1 + unique_chars[c]\n     \
    \       if unique_chars[c] > max_unique_chars\n                max_unique_chars\
    \ = unique_chars[c]\n                max_index = i\n            end\n        end\n\
    \    end\n    \n    return words[max_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    find_max([\"aaaaaaa\", \"bb\", \"cc\"])\n</cell>\n<text>\nExercise: Write a function\
    \ that returns number of unique characters in a string.", "    unique_chars =\
    \ HashSet()\n    for word in words \n        for c in word \n            unique_chars[c]\
    \ <- unique_chars[c] + 1\n            if unique_chars[c] > 1\n               \
    \ return word\n            end\n        end\n    end\n    return \"\"\nend", " \
    \   for i in 1:length(words)\n        if length(unique(words[i])) > length(words[i])\n\
    \            return words[i]\n        end\n    end\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 tags=arrays,julia,sorting |>\nYou can use sortfirst to sort\
    \ an array in descending order based on the return value of the function.\n<code>",
  "    let max_len = maximum(map(lengths, words)) \n    for i in 1:max_len\n     \
    \   if count(words[words == i])==1\n            return words[i]\n        end\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\nfind_max([\"name\", \"of\"\
    , \"string\"])\n</cell>\n<code language=julia-1.5>\nfind_max([\"name\", \"enam\"\
    , \"game\"])\n</cell>\n<code language=julia-1.5>\nfind_max([\"aaaaaaa\", \"bb\"\
    , \"cc\"])\n</cell>\n<text>\nExercise 1.\nWrite a function that accepts a vector\
    \ of strings.\n    The vector contains different words. Return the word with maximum\
    \ number\n    of unique characters. If multiple strings have maximum number of\
    \ unique\n    characters, return the one which comes first in lexicographical\
    \ order.", "    unique_chars = unique(words)\n    max_length = length(unique_chars)\n\
    \    max_length_word = words[max_length]\n    for word in words\n        if length(word)\
    \ > max_length \n            return word\n    return max_length_word\n</code>\n\
    You can find the unique character with unique in Julia. \nHowever, here you have\
    \ a problem: What should you do when multiple strings have a maximum number of\
    \ unique characters?\n<|/ a |>\n<| c |>\nHi there, I think you forgot to indent\
    \ your code. It seems that you have a `for` statement outside the `function` block,\
    \ which is not valid in Julia. In your `if` block, it does not seem that the `for`\
    \ statement is supposed to run. Can you fix that please?\n<|/ c |>\n<| a dscore=3\
    \ |>\nTo avoid the problem of the if statement, you could do this:\n<code>", " \
    \   word = words[1]\n    for w in words[2:end]\n        if length(unique(w)) ==\
    \ length(w)\n            if w > word\n                word = w\n            else\n\
    \                break\n        end\n    end\n    return word\nend\n</cell>\n\
    <text>\n6. Write a function that reads a text file and returns the number of lines\n\
    in the file. You can read the text file line by line and count its number by the\n\
    help of count() function. The text file contains only lower-case letters and\n\
    spaces.", "    word_to_count = Map{String, Int}()\n    for word in words do\n\
    \        word_to_count[word] = count(word)\n    end\n    word_to_count = Dict{String,\
    \ Int}(word_to_count)\n    function find_max(word::String)\n        if count(word)\
    \ > word_to_count[word]\n            word\n        else \n            find_max(words[1:])\n\
    \        end\n    end\nend\n</cell>\n<text>\nQuestion 1: Implementing count function",
  "    unique_chars = Set{String}()\n    for i in words \n        for j in words\n\
    \            if i != j && j.length <= i.length \n                unique_chars.insert(i.substr(1,\
    \ i.length))\n                break\n        end\n    end\n    \n    biggest_word\
    \ = words[end][1]\n    for i in unique_chars\n        if biggest_word == i\n \
    \           return i\n        end\n    end\n    return biggest_word\nend\n</cell>\n\
    <code language=julia-1.0>\nfind_max([\"name\", \"of\", \"string\"])\n</cell>\n\
    <text>\nTask 6: Implement a function that accepts a vector of strings and returns\
    \ all unique words that are longer than 4 characters in length.", "    counts\
    \ = Dict()\n    for w in words \n        if counts[w] == Nil\n            counts[w]\
    \ = 1\n        else\n            counts[w] += 1\n    end\n    \n    sortedCounts\
    \ = collect(counts)\n    return sortedCounts.keys.first\nend", "    \"\"\"\n \
    \   Write your code in here\n    \"\"\"\n    return \n</cell>\n<text>\nQuestion\
    \ 7: Given a list of words, return the word that comes first in\n    lexicographical\
    \ order among all words in the list. Order first by alphabet\n    then by length\n\
    \    >>> find_max_in_lexicographical([\"string\", \"game\", \"game\"])\n    \"\
    string\"\n    >>> find_max_in_lexicographical([\"ab\", \"c\"])\n    \"ab\"\n \
    \   >>> find_max_in_lexicographical([\"string\", \"aa\", \"abc\"])\n    \"string\"\
    \n    >>> find_max_in_lexicographical([\"a\", \"ab\", \"abc\"])\n    \"ab\"\n\
    \    \"\"\"", "    max_counter = HashSet()\n    for word in words do\n       \
    \ for char in word \n            counter = max_counter[char]\n            max_counter[char]\
    \ = counter + 1\n        end\n    end\n    max_char = max_counter[]\n    return\
    \ max_char\nend", "    word_vec = Dict{String, Int}()\n    for w in words\n  \
    \      word_vec[w] <-count(w)\n    end\n    top_word = words[findall(word_vec\
    \ .>maximum(word_vec.values()))]\n    return top_word\nend\n</cell>\n<code language=julia-1.4>\n\
    find_max([\"name\", \"enam\", \"game\"])\n</cell>\n<text>\n6.\nWrite a Julia function\
    \ count_letters that accepts a vector of strings as an argument and return\na\
    \ vector of the numbers of letters for each string. For example:", "    if len(words)\
    \ < 2 \n        return words[1]\n    char_counts = Dict{Char, Int}()\n    for\
    \ w in words \n        for c in w \n            if c in char_counts \n       \
    \         char_counts[c] += 1\n            else \n                char_counts[c]\
    \ = 1\n    return max_key(char_counts)\nend\n</cell>\n<text>\n3.2 Exercise", " \
    \   \"\"\"\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \"\"\"", "    word_counts =\
    \ Dict()\n    for w in words\n        if w in word_counts\n            word_counts[w]\
    \ += 1\n        else\n            word_counts[w] = 1\n    end\n    max_count =\
    \ maximum(word_counts.values)\n    top_words = filter(!in, word_counts.keys, word_counts.values)\n\
    \    if length(top_words) == 0\n        error(\"No words with max character count\"\
    )\n    end\n    top_word = top_words[end]\n    return top_word\nend", "    wordcount\
    \ = count(words) \n    if wordcount == 1\n        words[1]\n    else\n       \
    \ word = words[1]\n        count = 1\n        for i in 2..wordcount\n        \
    \    if words[i] == word\n                count += 1\n            elseif count\
    \ > wordcount\n                word = words[i]\n                count = 1\n  \
    \          else\n                count += 1\n        end\n        word\n    end\n\
    end\n</cell>\n<text>\nExercise 2:", "    for word in words \n        count_chars(word)\n\
    \        words = sort(words)\n        if length(words) >1\n            return\
    \ words[1]\n        else \n            return words[0] \n    end\nend\n\"\"\"\
    Write a function that accepts a vector of words.\n    The vector contains different\
    \ words. Return the word with maximum number\n    of unique characters. If multiple\
    \ strings have maximum number of unique\n    characters, return the one which\
    \ comes first in lexicographical order.\n    The word with maximum number of unique\
    \ characters should be the first one\n    in the vector.", "    word_count::Dict{String,\
    \ Int} = Dict{String, Int}()\n    for word in words \n        if !haskey(word_count,\
    \ word) \n            word_count[word] = 1\n        else \n            word_count[word]\
    \ += 1\n    end\n    largest::Int = 1\n    word_count::Dict{String, Int} = Dict{String,\
    \ Int}()\n    for word in words\n        if haskey(word_count, word) && word_count[word]\
    \ > largest\n            largest = word_count[word]\n            word_count::Dict{String,\
    \ Int} = Dict{String, Int}()\n            word_count[word] = 1\n        end\n\
    \    end\n    if !haskey(word_count, largest)\n        largest = 0\n    end\n\
    \    return largest\nend\n</cell>\n<code language=julia-1.4>\nfind_max([\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n</cell>\n<text>\nPart 4: Write a function to find all permutations\
    \ of a given string.", "    # write your function here\n    \nend\n</cell>\n<code\
    \ language=julia-1.5>\nfind_max([\"name\", \"enam\", \"game\"])\n</cell>\n<text>\n\
    2. Longest Common Prefix", "    unique = Set()\n    unique_chars = 0\n    max\
    \ = 0\n    found_max = false\n    for w in words\n        for c in w\n       \
    \     if !unique.contains(c)\n                unique.add(c)\n                unique_chars\
    \ += 1\n                if unique_chars > max\n                    max  = unique_chars\n\
    \                    found_max = true\n            end\n        end\n    end",
  "    unique_chars = Set{Char}()\n    max_unique = 0\n    max_index = 0\n    for\
    \ word in words\n        for char in word\n            unique_chars = unique_chars\
    \ union{char}\n            if unique_chars.length() > max_unique\n           \
    \     max_unique = unique_chars.length()\n                max_index = unique_chars.indexOf(char)\
    \ + 1\n        end\n    end\n    return words[max_index]\nend\n</cell>\n<code\
    \ language=julia-1.1>\nfind_max([\"name\", \"of\", \"string\"])\n</cell>\n<text>\n\
    Exercise: Write a function that accepts a vector of strings and a dictionary that\
    \ maps strings to integers\nand returns the word with maximum number of unique\
    \ characters. If multiple strings have maximum number of unique characters, return\
    \ the one which comes first in lexicographical order.", "    \n    # Write your\
    \ code in here\n    \nend", "    unique_chars::Set{String} = get!(Set{String}(),\
    \ \"\")\n    for word in words \n        get!(unique_chars, \"\")++ word\n   \
    \ end\n    unique_chars.max_by!{|char_count, word|\n        if char_count > length(word)\n\
    \            length(word)\n        else\n            char_count\n        end\n\
    \    }\nend\n</code>\n<|/ a |>\n<| a |>\nSolution using sort:\n<code>", "    unique_chars\
    \ = Set{String}([])\n    for word in words\n        unique_chars = union(unique_chars,\
    \ Set(word))\n    end\n    if length(unique_chars) == 1\n        return string(unique_chars)\n\
    \    else\n        sort(unique_chars) |> unique_chars |> unique_chars[1]\n   \
    \ end\nend", "    word_counts = Dict()\n    for word in words\n        word_counts[word]\
    \ =\n            if word_counts[word] == 0\n                word_counts[word]\
    \ = 1\n            else\n                word_counts[word] += 1\n        end\n\
    \    end\n    \n    for word in word_counts\n        if word_counts[word] > 1\n\
    \            return word\n        end\n    end\nend\n</cell>\n<code language=julia-1.3>\n\
    find_max([\"name\", \"of\", \"string\"])\n</cell>\n<code language=julia-1.3>\n\
    find_max([\"name\", \"enam\", \"game\"])\n</cell>\n<code language=julia-1.3>\n\
    find_max([\"aaaaaaa\", \"bb\", \"cc\"])\n</cell>\n<text>\nExercise\nWrite a function\
    \ that accepts a vector as parameter and returns the number of characters in a\
    \ word.", "    wordcounts = HashSet()\n    for w in words\n        wordcounts[w]\
    \ = wordcounts[w] + 1\n    end\n    return findmax(wordcounts)\nend", "    max\
    \ = words[end]\n    for w in words\n        uniques = uniq(w)\n        if length(uniques)\
    \ > length(max)\n            max = uniques\n        end\n    end\n    return max\n\
    end", "        words = sort(words)\n        m = 1\n        for i in 1:length(words)\n\
    \            if length( uniq(words[i]) )>m\n                m= length( uniq(words[i])\
    \ )\n            end\n        end\n        words[m]\n    end\n</code>\n<|/ a |>\n\
    <| c |>\nThe question was about finding the word with the highest number of unique\
    \ letters.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "   local word_count::Dict{String,Int}\n\
    \   for word in words \n      if word_count[word] <= 0 \n         word_count[word]\
    \ = 1 \n      else \n         word_count[word] = word_count[word] + 1 \n     \
    \ end \n   end \n   highest_count = -1\n   highest_word = nil\n   for word in\
    \ words \n      if word_count[word] > highest_count \n         highest_count =\
    \ word_count[word]\n         highest_word = word\n      end \n   end \n   return\
    \ highest_word\nend", "  local maxword = \"\"\n  local wordcount::Int = 0\n  for\
    \ word in words do\n    if !wordcount[word] then\n      wordcount[word] = 1\n\
    \    else\n      wordcount[word] = wordcount[word] + 1\n    end\n    if wordcount[word]\
    \ > wordcount[maxword] then\n      maxword = word\n    end\n  end\n  return maxword\n\
    end\n</cell>\n<text>\nWe have solved the challenge! With only two lines of code,\
    \ we can\nget the answer to the challenge!", "    word_count = Dict{String,Int}()\n\
    \    for w in words\n        word_count[w] = get(word_count, w, 0)+1\n    end\n\
    \    max = nothing\n    for (key, value) in word_count\n        if value > length(max)\n\
    \            max = key\n        end\n    end\n    return max\nend", "\"\"\"\n\
    \    words_sorted = sort(words)\n    \n    # find the maximum length of the words\
    \ in words_sorted\n    max_word_length = 0\n    for word in words_sorted\n   \
    \     word_length = len(word)\n        if word_length > max_word_length\n    \
    \        max_word_length = word_length\n    end\n    \n    # create an array of\
    \ 0s for storing the unique characters in the words\n    unique_chars_array =\
    \ zeros(max_word_length)\n    \n    # loop through the words and calculate the\
    \ unique characters\n    for word in words_sorted\n        unique_chars_array\
    \ += length(word)\n    end\n    \n    # find the word with maximum number of unique\
    \ characters\n    index_of_max_word = argmax(unique_chars_array)\n    return words_sorted[index_of_max_word]\n\
    end\n</cell>\n<text>\nExercise 2: Write a function that accepts a vector of words\
    \ and returns a vector of strings.\n    The vector contains different words. Return\
    \ a vector of strings where each string has a maximum\n    number of unique characters.\
    \ If the number of unique characters is less than the maximum number\n    of unique\
    \ characters, then replace it with the minimum number of unique characters.",
  "    if length (words) == 1 \n        return words \n    else \n        words_copy\
    \ = words\n        # sort by length\n        words_copy:sort(|a, b| length(a)\
    \ <=> length(b)) \n        # return first one \n        return words_copy[1] \n\
    \    end\nend\n</cell>\n<text>\nExercise 4\nWrite a function that accepts a string\
    \ and an integer.\nThe function should return a boolean indicating whether the\
    \ string has a substring\nof the given length contained in the string. The substring\
    \ is a character of a word\nthat appears after the length of the string.", " \
    \   \"\"\"\n    Find the word with the maximum number of unique characters in\
    \ a given string.\n    \n    Arguments\n    ---------\n    words: Vector{String}\n\
    \    \n    Returns\n    ------\n    String\n    \n    Notes\n    -----\n    You\
    \ may assume that the given string contains only lower case letters.\n    \n \
    \   This function consumes O(n) time.\n    \n    Examples\n    --------\n    >>>\
    \ find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n    >>> find_max([\"\
    name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"aaaaaaa\", \"\
    bb\", \"cc\"])\n    \"aaaaaaa\"\n    \"\"\"\n    \nend\n</code>\n<|/ q dscore=0\
    \ |>\n<| c |>\nThis looks like an assignment. Have you tried anything yourself?\n\
    <|/ c |>\n<| c |>\nIt's an online exercise.\n<|/ c |>\n<| c |>\nThat's unlikely.\
    \ Think of how you would approach this problem if there was no online exercise.\
    \ How would you approach this problem when it was a real assignment? What have\
    \ you tried? Where are you stuck?\n<|/ c |>\n<| a tags=string,sorting,julia,vector\
    \ |>\nHere is one possible solution, although there may be more elegant solutions\
    \ possible.\n<code>", "    unique_char::Int64 = 0\n    \n    for x in words\n\
    \        for c in x\n            if !ischar(c)\n                continue \n  \
    \          if unique_char < length(c)\n                unique_char = length(c)\n\
    \            end\n        end\n    end\n    if unique_char < length(words[1])\n\
    \        unique_char = length(words[1])\n    end\n    for x in words\n       \
    \ if length(x) == unique_char\n            return x\n        end\n    end\n  \
    \  return words[1]\nend\n</cell>\n<code language=julia-1.3>\nfind_max([\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n</cell>\n<code language=julia-1.3>\nfind_max([\"string\",\
    \ \"name\", \"of\", \"enam\", \"game\"])\n</cell>\n<text>\nExercise 1\nWrite a\
    \ function which accepts a vector of numbers, and returns the maximum number in\
    \ the vector.", "\"\"\"Write a function that accepts a vector of strings.\n  \
    \  The vector contains different words. Return the word with maximum number\n\
    \    of unique characters. If multiple strings have maximum number of unique\n\
    \    characters, return the one which comes first in lexicographical order.",
  "    words.sort() \n    return words[end][end+1]\nend", "    \n    words = copy(words)\
    \ # Make copy of vector \n    maximum = 0 \n    word_with_max_count = 0 \n   \
    \ words_with_max_count = 0 \n    \n    for w in words \n        word_count = get(w,0)\n\
    \        \n        if word_count > maximum\n            maximum = word_count\n\
    \            word_with_max_count = w\n            words_with_max_count = words_with_max_count\
    \ + 1\n        \n        end\n    end\n    \n    if maximum == 0 \n        return\
    \ words[end]\n    end\n    \n    for w in words\n        word_count = get(w,0)\n\
    \        \n        if word_count > maximum\n            maximum = word_count\n\
    \            word_with_max_count = w\n        end\n    end\n    \n    return word_with_max_count\n\
    end\n</cell>\n<code language=julia-1.5>", "    counts = Dict{String, Int}()\n\
    \    for word in words\n        counts[word] = get(counts, word, 0) + 1\n    end\n\
    \    minimum = minimum(counts)\n    minimum == nothing && return nothing\n   \
    \ for key in keys(counts)\n        counts[key] == minimum && (return key)\n  \
    \  end\n    return nothing\nend\n</cell>\n<text>\nFinding words with a maximum\
    \ length of 6", "    if length(words) == 0\n        return \"\"\n    if length(words)\
    \ == 1 \n        return words[0]\n    counts = Dict{String,Int}(words)\n    counts[\"\
    \"] = 0\n    for key in keys(counts)\n        counts[key] = maximum(counts[key])\
    \ + 1\n    counts[\"\"] = maximum(counts[\"\"]) + 1\n    counts = sort!(counts)\n\
    \    return words[find(counts == max(counts)[1], 1)]\nend\n</cell>\n<text>\nPractice\n\
    Write a function that accepts a vector of words and returns the most common word.\
    \ \nThe function should find the most common word in the vector and ignore the\
    \ rest.", "    \"\"\"\n    Work out the word with maximum number of unique characters.\n\
    \    \n    Parameters\n    ----------\n    words : Vector{String}\n        Vector\
    \ of strings.", "    unique_chars = Set.Set()\n    for w in words\n        for\
    \ c in w\n            if !contains(unique_chars, c)\n                unique_chars.add(c)\n\
    \            end\n        end\n    end\n    word_with_max = 0\n    for w in words\n\
    \        if length(unique_chars) >= word_with_max\n            word_with_max =\
    \ length(unique_chars)\n        end\n    end\n    for w in words\n        if length(unique_chars)\
    \ == word_with_max\n            break\n        end\n    end\n    unique_chars\n\
    end", "    unique, counts = unique(words), Dict{String, Int}()\n    minimum =\
    \ maximum = 0\n    for (word) in words\n        if word == \"\"\n        else\
    \ if counts[word] < minimum \n            then minimum = counts[word]\n      \
    \  else if counts[word] > maximum \n            then maximum = counts[word]\n\
    \        end\n        counts[word] += 1\n    end\n    return minimum == maximum\n\
    end", "    words=words[!isna(words)]\n    return words[findmax(words)]\nend",
  "    count_chars(words)\n    word_to_key(words)\n    map_keys(keys(word_counts))[1]\n\
    end \n</cell>\n<code language=julia-1.5>\nfind_max([\"name\", \"of\", \"string\"\
    ])\n</cell>\n<code language=julia-1.5>\nfind_max([\"name\", \"enam\", \"game\"\
    ])\n</cell>\n<code language=julia-1.5>\nfind_max([\"aaaaaaa\", \"bb\", \"cc\"\
    ])\n</cell>\n<code language=julia-1.5>\nfind_max([\"aaaaaaa\", \"bb\", \"ccc\"\
    , \"dddddd\"])\n</cell>\n<text>\nFunction to find minimum of a vector", "    word\
    \ = find_max(Vector{String}(words))\n    \n    for w in words\n        word =\
    \ find_max(w, word)\n    end\n    return word\nend\n</cell>\n<code language=julia-1.6>\n\
    find_max([\"name\", \"of\", \"string\"])\n</cell>\n<code language=julia-1.6>\n\
    find_max([\"name\", \"enam\", \"game\"])\n</cell>\n<code language=julia-1.6>\n\
    find_max([\"aaaaaaa\", \"bb\", \"cc\"])\n</cell>\n<text>\nSolution", "    unique_words\
    \ = Set()\n    for word in words \n        for c in word\n            unique_words\
    \ <- unique_words | c\n        end\n    end\n    if unique_words == Set()\n  \
    \      return \"No words with unique character\"\n    end\n    \n    max_element\
    \ = unique_words[1]\n    for element in unique_words\n        if element > max_element\n\
    \            max_element = element\n        end\n    end\n    return max_element\n\
    end\n</cell>\n<code language=julia-1.5>\nfind_max([\"aaaaaaa\", \"bb\", \"cc\"\
    ])\n</cell>\n<code language=julia-1.5>\nfind_max([\"name\", \"enam\", \"game\"\
    ])\n</cell>\n<text>\nExercise 3\nWrite a function that accepts a vector of strings\
    \ and returns their length in characters.\nThe vector contains different words.\
    \ Return the word with minimum number\n    of unique characters. If multiple strings\
    \ have minimum number of unique\n    characters, return the one which comes first\
    \ in lexicographical order.", "    word = max(words, length==length(unique(word)))\n\
    \    index = words.index(word,1) # Find the first index in the list that has word\
    \ \n    return words[index]\nend\n</cell>\n<text>\nNow that we have defined a\
    \ function to find the word with maximum number of unique characters, we are going\
    \ to apply this on all the words in the vector. Let's do it.", "    \n    unique_words=Vector{String}()\n\
    \    for word in words\n        if !contains(unique_words, word)\n           \
    \ unique_words[length(unique_words)+1]=word\n        end\n    end\n    \n    maximum=0\n\
    \    for i=1:length(unique_words)\n        if length(unique_words[i])>maximum\n\
    \            maximum=length(unique_words[i])\n        end\n    end\n    \n   \
    \ for i=1:length(unique_words)\n        if length(unique_words[i])==maximum\n\
    \            return unique_words[i]\n        end\n    end\n    \n    return words[end]\n\
    end\n</cell>\n<code language=julia-0.5>\n# run this cell to load the test cases,\
    \ otherwise they will not be included in the resulting notebook\ninclude(\"testcases.jl\"\
    )\n</cell>\n<code language=julia-0.5>", "    unique_word::String = \"\"\n    word_with_max_unique_characters::String\
    \ = \"\"\n    for w in words\n        unique_word = unique_word + w\n        count_unique_characters::Int\
    \ =  unique_word.length\n        if count_unique_characters > word_with_max_unique_characters\n\
    \            word_with_max_unique_characters = unique_word\n        end\n    end\n\
    \    return word_with_max_unique_characters\nend", "    maximum = max( length(words),\
    \ length(uniq(words)))\n    for word in words \n        if length(uniq(word))\
    \ == maximum \n            return word \n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    find_max([\"name\", \"enam\", \"game\"])\n</cell>\n<text>\nWrite a function that\
    \ returns a vector of a word that starts with 'a'.", "    word_counts = Dict()\n\
    \    for word in words \n        word_counts[word] = get(word_counts, word, 0)\
    \ + 1\n    end\n    return word_counts.key(word_counts.values.max)\nend ", " \
    \   counts = Dict{String, Int}()\n    for word in words \n        for c in word\n\
    \            if !haskey(counts, c)\n                counts[c] = 0\n          \
    \  counts[c] += 1\n    end\n    sort!(counts, by = counts, rev=true)\n    key\
    \ = first(keys(counts))\n    return words[key]\nend\n</cell>\n<code language=julia-0.5>\n\
    find_max([\"aaaaaaa\", \"bb\", \"cc\"])\n</cell>\n<text>\nQ6.\nWrite a function\
    \ that accepts a vector of vectors of integers. Each vector \ncontains integers.\
    \ Return the sum of the elements of the vectors. If no vector \ncontains any element,\
    \ return zero.", "    word_count = count(words);\n    return word_count.max_by(identity)\n\
    end", "    char_table = countmap(unique(words))\n    \n    for w in words\n  \
    \      word_count = get_max_count(char_table, w)\n        \n        if word_count\
    \ > get_max_count(char_table, w)\n            return w\n        end\n    end\n\
    \    \n    return \"no word\"\nend\n</cell>\n<code language=julia-1.3>\nfind_max([\"\
    name\", \"of\", \"string\"])\n</cell>\n<code language=julia-1.3>\nfind_max([\"\
    name\", \"enam\", \"game\"])\n</cell>\n<code language=julia-1.3>\nfind_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n</cell>\n<text>\nPart 2: Build a Reverse Word Index\
    \ Dict\nWrite a function that accepts a vector of strings. It should return a\
    \ dictionary\nthat assigns each unique string to a unique integer index.", " \
    \   unique = Vector{String}(uniq(words))\n    max_word = \"\"\n    max_index =\
    \ -1\n    words.eachindex(w) do i\n        if unique.count(w) == unique.count(max_word)\
    \ || i > max_index\n            max_word = w\n            max_index = i\n    \
    \    end\n    end\n    return max_word\nend\n</cell>\n<text>\nSolution\nNote that\
    \ since unique() returns a vector and uniq() returns an array we can do the same\
    \ thing we did above with words using map() and reduce(). Let's see how it works.",
  "    sort!(words);\n    return words[end]\nend\n</cell>\n<text>\nSolution\nThe function\
    \ above will sort all the words alphabetically, which is unnecessary. Instead,\
    \ we can find the word which comes first in lexicographical order - that is, the\
    \ one with maximum number of unique characters. To solve this problem, we can\
    \ use a counter to keep track of how many characters have already been seen:",
  "    local counter\n    local max_char\n    local max_index\n    local max_char_in_word\n\
    \    for word in words\n        do\n            counter += 1\n            local\
    \ num_unique_chars = length(unique(word))\n            if num_unique_chars > max_char\n\
    \            then \n                max_char = num_unique_chars\n            \
    \    max_char_in_word = word\n                max_index = counter\n          \
    \  end\n        end\n    end\n    return max_char_in_word\nend\n</cell>\n<text>\n\
    Q3\nWrite a function that accepts a vector of integers and returns the vector\
    \ with its elements multiplied by 2. Then write another function that accepts\
    \ a vector and returns the element with maximum value multiplied by 2.", "   \
    \ if len(words) <= 1\n        return words[1]\n    else\n        words = sort_uniq_words(words)\n\
    \        return words[1]\nend\n</cell>\n<code language=julia-1.4>\nfind_max([\"\
    string\", \"enam\", \"game\", \"name\"])\n</cell>\n<code language=julia-1.4>\n\
    find_max([\"name\", \"enam\", \"game\"])\n</cell>\n<text>\nThe find_max function\n\
    The find_max function is more complex, and should be written using loops.\nThis\
    \ will be used later to write count_word_length", "    unique = Set()\n    unique_max\
    \ = words[words.length-1].length()\n    for i in words:\n        for j in i:\n\
    \            unique.add(j)\n            if unique.count(j) > unique_max:\n   \
    \             unique_max = unique.count(j)\n                unique_max_word =\
    \ i\n    return unique_max_word\n</code>\n<|/ a |>\n<| c |>\nThis answer should\
    \ be added to the wiki to make it easy to find it.\n<|/ c |>\n<| a dscore=1 |>\n\
    This solution works with strings that have numbers as well. I don't know why it\
    \ is so slow. At least this is faster for strings with numbers. I do not know\
    \ why it takes more time when tested on large strings.\n<code>", "        unique_chars\
    \ = countmap(words)\n        most_unique = unique_chars.keys[end]\n        counts\
    \ = unique_chars.values[end]\n        for (i, (count, word)) in most_unique\n\
    \            if counts[i] > count\n                most_unique = unique_chars.keys[i\
    \ - 1]\n                counts = unique_chars.values[i - 1]\n            end\n\
    \        end\n        most_unique\nend\n\"\"\"\n    Write a function that accepts\
    \ a vector of vectors of strings. Return the\n    word with maximum number of\
    \ unique characters. If multiple vectors have\n    maximum number of unique characters,\
    \ return the one which comes first\n    in lexicographical order.", "    \"\"\"\
    \n    Your code here\n    \"\"\"\n# Check whether a given vector contains only\
    \ unique elements or not\n    unique_word::Set{String}=Set()\n    for i in words\n\
    \        unique_word += Set(i)\n    end\n    if length(unique_word)==length(words)\n\
    \        return words[end]\n    else\n        minimum=length(words)\n        for\
    \ i in words\n            if length(Set(i))<minimum\n                minimum=length(Set(i))\n\
    \            end\n        end\n        return minimum==length(unique_word) ? \"\
    No words\" : words[minimum]\n    end\nend\n</cell>\n<code language=julia-1.4>\n\
    @test find_max([\"name\", \"of\", \"string\"])==\"string\"\n@test find_max([\"\
    name\", \"enam\", \"game\"])==\"enam\"\n@test find_max([\"aaaaaaa\", \"bb\", \"\
    cc\"])==\"aaaaaaa\"\n</cell>\n<code language=julia-1.4>\n\"\"\"\nWrite a function\
    \ that accepts a vector of characters and returns a vector of strings. \nIf there\
    \ are no strings, return an empty vector. If all strings have same length,\nthen\
    \ just return the first string in the vector.\n\"\"\"", "    \"\"\"\n    Find\
    \ the word with maximum number of unique characters. \n    \"\"\"\n    uniqueChars\
    \ = Dict(zip(words, [0 for i in eachindex(words)])) \n    for i in words\n   \
    \     uniqueChars[i] += 1\n    endword = min(uniqueChars, key=lambda pair: pair[1])\n\
    \    return endword\n</code>\n<|/ a |>\n<| a |>\nThis was the code I came up with.\
    \ It works by counting the number of characters in a string and sorting the strings\
    \ by the number of unique characters. \n<code>", '    # write your code', '    """Find
    the word with maximum number of unique characters in given vector."""', "    max_length\
    \ = 0\n    word = \"\"\n    for i in words\n        if length(i) > max_length\n\
    \            word = i\n            max_length = length(i)\n        end\n    end\n\
    \    return word\nend\n</cell>\n<code language=julia-0.4>\nfind_max([\"name\"\
    , \"of\", \"string\"])\n</cell>\n<text>\nFind the index of a word in a vector",
  "    counts = Dict{Char,Int}()\n    max_length = 0\n    max_length_word = \"\"\n\
    \    for word in words\n        for char in word\n            counts[char] = get(counts,char,0)\
    \ + 1\n            max_length = if counts[char] > max_length then counts[char]\
    \ else max_length\n        \n        if max_length > max_length_word\n       \
    \     max_length_word = word\n        end\n    end\n    max_length_word\nend\n\
    </cell>\n<text>\nExercise 11\nWrite a function find_max(x::Vector{String})->String\
    \ which returns the word with maximum number \nof unique characters in lexicographical\
    \ order. The function should accept one vector\nof strings.", "    count = length(words)\n\
    \    word = words[count]\n    for w in words[1 : (count - 1)] \n        count\
    \ = 0\n        for i in 1:length(w)\n            if w.[i] == w[i]\n          \
    \      count+=1\n            elseif count > length(w)\n                word =\
    \ w\n                break\n            end\n        end\n    end\n    return\
    \ word\nend\n</cell>\n<text>\nTest your function", "    \n    sorted_words = sort(words)\n\
    \    \n    \n    \n    ", "    unique_char_count = Dict{Char, Int}()\n    for\
    \ word in words\n        unique_char_count += Dict{Char, Int}(word)\n    \n  \
    \  max_count = -1\n    max_word = \"\"\n    for char, count in unique_char_count.items()\n\
    \        if count > max_count\n            max_count = count\n            max_word\
    \ = char\n        end\n    end\n    return max_word\nend\n</cell>\n<text>\nExercise:\
    \ Write a function that accepts a vector of strings and returns a vector with\
    \ words that are common to all the strings.\n    \n    >>> find_common([\"name\"\
    , \"of\", \"string\", \"enam\", \"game\"])\n    [\"string\", \"enam\"]\n    \"\
    \"\"", "        \n    if length(words) < 1 then return end\n    \n    counts =\
    \ Dict()\n    for w in words\n        counts[w] = counts[w] ? counts[w] + 1 :\
    \ 1 \n    end\n    \n    maxcount = max(counts.values())\n    \n    for w in counts\n\
    \        if counts[w] == maxcount\n            if w > counts[maxcount]\n     \
    \           return w\n            elseif w == counts[maxcount]\n             \
    \   return maxcount\n            end\n        end\n    end", "\"\"\"\n    local\
    \ counter = HashSet()\n    local max_counter = length\n    local max_word = \"\
    \"\n    for w in words\n        counter[w] = counter[w] + 1\n        if counter[w]\
    \ > max_counter\n            max_counter = counter[w]\n            max_word =\
    \ w\n        end\n    end\n    return max_word\nend\n</cell>\n<code language=julia-0.6>\n\
    find_max([\"name\", \"of\", \"string\"])\n</cell>\n<code language=julia-0.6>\n\
    find_max([\"name\", \"enam\", \"game\"])\n</cell>\n<code language=julia-0.6>\n\
    find_max([\"aaaaaaa\", \"bb\", \"cc\"])\n</cell>\n<text>\nExercise 3\nWrite a\
    \ function that accepts a vector of strings. The vector contains different words.\
    \ Return the longest word among all the words. If multiple words have the same\
    \ length, return the first one alphabetically. Make sure the longest word is returned\
    \ in case all words have the same length.", "    unique_char_count = Set()\n \
    \   for w in words\n        unique_char_count += Set(w)\n    end\n    unique_char_count\
    \ = length(unique_char_count)\n    for w in words\n        if length(Set(w)) >\
    \ unique_char_count\n            return w\n        end\n    end\n    return words[1]\n\
    end\n</cell>\n<code language=julia-0.4>\nfind_max([\"name\", \"of\", \"string\"\
    ])\n</cell>\n<code language=julia-0.4>\nfind_max([\"name\", \"enam\", \"game\"\
    ])\n</cell>\n<code language=julia-0.4>\nfind_max([\"aaaaaaa\", \"bb\", \"cc\"\
    ])\n</cell>\n<text>\nPart 3: Simplify a sentence using Julia\nNow that you have\
    \ the function that will find the word with maximum number of unique characters\
    \ in a vector of strings, you can simplify the sentence using Julia. First, we\
    \ will write a function which accepts a sentence as input and returns the simplified\
    \ sentence. The simplified sentence should contain the word with the maximum number\
    \ of unique characters.", "    # Write your code in Python 3.6\n    pass\nend\n\
    </cell>\n<code language=julia-0.6>\n@assert find_max([\"name\", \"of\", \"string\"\
    ]) == \"string\"\n@assert find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\
    \n@assert find_max([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\n</cell>\n<code\
    \ language=julia-0.6>\nfind_max([\"bobcat\", \"bobcats\", \"dogcat\"])\n</cell>\n\
    <text>\n4.3 Write a function that accepts a vector of strings, \n    and return\
    \ the vector with the shortest length.\n    \n    >>> find_min([\"\", \"\", \"\
    \"])\n    \"\"\n    >>> find_min([\"bobcat\", \"bobcats\", \"dogcat\"])\n    \"\
    bobcat\"\n    >>> find_min([\"a\", \"a\", \"\"])\n    \"a\"\n    \"\"\"", "  \
    \  \n    unique_chars = {}\n    word = nothing\n    count = nothing\n    for word\
    \ in words \n        \n        \n        for char in word\n            if char\
    \ in unique_chars\n                unique_chars[char] += 1 \n            else\n\
    \                unique_chars[char] = 1 \n        end\n        \n        if length(unique_chars)\
    \ >  length(count)\n            count = unique_chars\n            word = nothing\n\
    \        elseif length(unique_chars) == length(count)\n            if count[sort(sort(keys(count)))[1]]\
    \ > count[sort(sort(keys(count)))[2]]\n                word = sort(sort(keys(count)))[1]\n\
    \            else\n                word = sort(sort(keys(count)))[2]\n       \
    \     end\n        end\n    end\n    return word\nend\n</cell>\n<text>\nFind the\
    \ length of a string", "    wordcount::Int64 = sum(w == \"_\" for w in words)\n\
    \    if wordcount > 1\n        return find_max(words[wordcount+1:])\n    endword\
    \ = words[end]\n    letters = Set(words[end-1:end])\n    if letters % {\"_\"}\
    \ == 0\n        return endword\n    endwordcount::Int64 = sum(w == \"_\" for w\
    \ in words[end:end-1])\n    if endwordcount > 1\n        return find_max(words[end-1:end])\n\
    \    endletters = Set(words[end-1:end-1])\n    if endletters % {\"_\"} == 0\n\
    \        return endword\n    endwordcount::Int64 = sum(w == \"_\" for w in words[end-1:end])\n\
    \    if endwordcount > 1\n        return find_max(words[end-1:end-1])\n    endletters\
    \ = Set(words[end-1:end])\n    if endletters % {\"_\"} == 0\n        return endword\n\
    \    endwordcount::Int64 = sum(w == \"_\" for w in words[end-1:end+1])\n    if\
    \ endwordcount > 1\n        return find_max(words[end-1:end+1])\n    endletters\
    \ = Set(words[end-1:end+1])\n    if endletters % {\"_\"} == 0\n        return\
    \ endword\n    endwordcount::Int64 = sum(w == \"_\" for w in words[end-1:end+2])\n\
    \    if endwordcount > 1\n        return find_max(words[end-1:end+2])\n    endletters\
    \ = Set(words[end-1:end+2])\n    if endletters % {\"_\"} == 0\n        return\
    \ endword\n    endwordcount::Int64 = sum(w == \"_\" for w in words[end-1:end+3])\n\
    \    if endwordcount > 1\n        return find_max(words[end-1:end+3])\n    endletters\
    \ = Set(words[end-1:end+3])\n    if endletters % {\"_\"} == 0\n        return\
    \ endword\n    endwordcount::Int64 = sum(w == \"_\" for w in words[end-1:end+4])\n\
    \    if endwordcount > 1\n        return find_max(words[end-1:end+4])\n    endletters\
    \ = Set(words[end-1:end+4])\n    if endletters % {\"_\"} == 0\n        return\
    \ endword\n    endwordcount::Int64 = sum(w == \"_\" for w in words[end-1:end+5])\n\
    \    if endwordcount > 1\n        return find_max(words[end-1:end+5])\n    endletters\
    \ = Set(words[end-1:end+5])\n    if endletters % {\"_\"} == 0\n        return\
    \ endword\n    endword", "    uniq = Set()\n    for w in words \n        uniq\
    \ = union(uniq, w)\n    end\n    max_word = uniq.elems[end]\n    for w in words\n\
    \        if w == max_word\n            return w\n    end\n    return max_word\n\
    end", "    words = sort(words)\n    unique_chars = Vector{Int64}(undef, 0)\n \
    \   word_counts = Map[String, Int64]()\n    for (i, word) in enumerate(words)\n\
    \        word_counts[word] <- count(word, words)\n    end\n    \n    for (word,\
    \ count) in word_counts\n        unique_chars[count] <- count\n    end\n    \n\
    \    unique_chars_sorted = sort(unique_chars)\n    return unique_chars_sorted[1]\n\
    end\n</code>\nAnd finally, let's write a short test:\n<code>", "    if length(words)\
    \ <= 1 \n        return words[1]\n    unique_chars = Set()\n    for word in words\
    \ \n        unique_chars = union(unique_chars, Set(word))\n    max_chars = length(unique_chars)\n\
    \    unique_chars = Set()\n    word_chars = Set()\n    for word in words \n  \
    \      word_chars = union(word_chars, Set(word))\n        unique_chars = union(unique_chars,\
    \ Set(word))\n        unique_chars = union(unique_chars, Set(word_chars))\n  \
    \  ordered_unique_chars = Vector{String}(undef, 0)\n    for unique_char in unique_chars\n\
    \        if ordered_unique_chars[end] == unique_char \n            ordered_unique_chars[end+1]\
    \ = unique_char\n        else\n            ordered_unique_chars[end+1] = unique_char\n\
    \            ordered_unique_chars[end] = unique_char\n        end\n    end\n \
    \   max_word = words[end] if ordered_unique_chars[end] == unique_chars[end]\n\
    \    for word in words\n        if ordered_unique_chars[end] == unique_chars[end]\n\
    \            if word > max_word\n                max_word = word\n           \
    \ end\n        end\n    end\n    max_word\nend\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a tags=string,julia |>\n<code>", "\tunique_chars = Set()\n\tmax_len = -1\n\t\
    for word in words\n\t\tunique_chars += Set(word)\n\t\tlen = length(word)\n\t\t\
    if max_len == -1 || len > max_len\n\t\t\tmax_len = len\n\t\tend\n\tend\n\tfor\
    \ char in unique_chars\n\t\tif length(char) == max_len\n\t\t\treturn char\n\t\t\
    end\n\tend\n\treturn \"\"\nend", "    unique_words=Set{String}()\n    for word\
    \ in words \n      unique_words.add(word)\n    end\n    for word in unique_words\n\
    \      if length(word)>length(unique(word))\n        return word\n      else\n\
    \        continue\n      end\n    end\n  end\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Write a function that accepts a vector of strings.\n    The vector contains\
    \ different words. Return the word with maximum number\n    of unique characters.\
    \ If multiple strings have maximum number of unique\n    characters, return the\
    \ one which comes first in lexicographical order.", "    unique_count::Vector{Int}\
    \ = []\n    for word in words\n        for c in word\n            unique_count\
    \ += counts[c] if counts[c] > 0 else 0\n        end\n    end\n    word_with_max_count\
    \ = words[argmax(unique_count)]\n    return word_with_max_count if length(unique_count)\
    \ == 1 && unique_count == 1 else word_with_max_count \nend\n</cell>\n<text>\n\
    Problem 3\nWrite a function that accepts a vector of strings and a positive integer.\
    \ Return true if the sum of the integers in the vector is equal to the integer.",
  "\"\"\"Write a function that accepts a vector of strings.\n    The vector contains\
    \ different words. Return the word with maximum number\n    of unique characters.\
    \ If multiple strings have maximum number of unique\n    characters, return the\
    \ one which comes first in lexicographical order.", "    uniq = unique(words)\n\
    \    return uniq |> sort |> uniq[1] |> sort\nend\n</cell>\n<text>\nQuestion 10:\
    \ Write a function that takes a matrix as input and returns the matrix where all\
    \ entries are in ascending order.", "    chars_counts = Dict()\n    for w in words\n\
    \        chars_counts[length(w)]= chars_counts[length(w)] + 1 if length(w) in\
    \ chars_counts else  1\n    end\n    \n    for key in chars_counts\n        if\
    \ chars_counts[key] > chars_counts[maximum(keys(chars_counts))]\n            return\
    \ key\n        end\n    end\n    return length(words[1])\nend\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that accepts a string and returns the number of characters\
    \ in it.", "    word_counts = Dict()\n    for word in words \n        if isdefined(word_counts,\
    \ word)\n        word_counts[word] = get(word_counts, word, 0) + 1\n        else\
    \ word_counts[word] = 1\n    end\n    for key, val in word_counts\n        if\
    \ val > 1\n            return key\n        end\n    end\n    return words[1]\n\
    end\n</code>\n<|/ a tags=function,julia |>\n<| c |>\nThis code is not working\
    \ as expected. `find_max([\"aaaaaaa\", \"bb\", \"cc\"])` return  `aaaaaaa` instead\
    \ of the expected `\"cc\"`\n<|/ c |>\n<| a |>\nI think it would be easier to understand\
    \ and easier to code if you had a function that accepted a single word, and returned\
    \ a count of the number of times that word appeared in the original text. Since\
    \ you don't actually care about the number of times a word appears, you can just\
    \ return the count as a single number.\n<code>\ncount_of_appearance_of_a_word(word::String)::Int64\n\
    \    counts = Dict()\n    for character in word\n        if !isdefined(counts,\
    \ character)\n            counts[character] = Dict()\n        end\n        push!(counts[character],\
    \ word)\n    end\n    counts = sort!(counts, by=x->length(x), rev=true)\n    return\
    \ counts[first(counts)]\nend\n</code>\nThen, if you need to find out what word\
    \ has the most appearances, just find the maximum of the output of count_of_appearance_of_a_word().\n\
    <code>\nmax_count = maximum(count_of_appearance_of_a_word(word) for word in words)\n\
    </code>\nIf you really need a function that returns the word with the greatest\
    \ number of appearances you can do this instead (which could be the most efficient,\
    \ since you do not need to sort the entire dictionary by length).\n<code>", " \
    \ max = \"\"\n  i = 1\n  for word in words\n    if length(word)==length(max) &&\
    \ length(word)>1\n      return(word)\n    else \n      if length(word)>length(max)\
    \ \n        max=(word)\n      end\n    end\n  end\n  return(max)\nend", "    if\
    \ words.length==0 \n        return \"\"\n    local i\n    if length(words)==1\
    \ \n        return words[0]\n    local s=0\n    local c=0\n    for i=1,length(words)\
    \ do \n        if words[i]~=words[i-1] then \n            c=c+1\n            s=s+1\n\
    \        else \n            c=c\n        end\n    end\n    if c>s then\n     \
    \   return words[i-1]\n    else\n        return words[length(words)]\n    end\n\
    end\n</cell>\n<text>\nExercise 4\nWrite a function that accepts a string as an\
    \ input. It should split the string into substrings of length 3 or less, and remove\
    \ the last element of the resulting list. Return the final list of strings. The\
    \ last element of the list should always be a shorter version of the original\
    \ string.", "    if length(words) < 1 \n        return \"\"\n    end\n    counts\
    \ = Dict()\n    for i in words\n        haskey(counts, i) ? (counts[i] = counts[i]\
    \ + 1) : ( counts[i] = 1)\n    end\n    minimum = min(counts)\n    for i in counts\n\
    \        if counts[i] == minimum\n            return i\n        end\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\nfind_max([\"name\", \"enam\", \"game\"\
    ])\n</cell>\n<code language=julia-1.5>\nfind_max([\"aaaaaaa\", \"bb\", \"cc\"\
    ])\n</cell>\n<code language=julia-1.5>\nfind_max([\"aaaaaaa\", \"b\", \"c\", \"\
    d\", \"e\"])\n</cell>\n<code language=julia-1.5>\nfind_max([\"aaaaaaa\", \"b\"\
    , \"c\", \"d\"])\n</cell>\n<text>\nWrite a function that accepts a vector of strings.\n\
    \    The vector contains same words. Return the word with minimum number\n   \
    \ of unique characters. If multiple strings have minimum number of unique\n  \
    \  characters, return the one which comes first in lexicographical order.", " \
    \   for i in words\n        n = count(i)\n        if n > max(i)\n            max\
    \ = i\n        end\n    end\n    return max\nend\n</cell>\n<text>\nThe next cell\
    \ shows what the result of the cell above looks like.", "    unique_chars = Set()\n\
    \    words_with_unique_chars = []\n    for w in words\n        unique_chars =\
    \ unique_chars | Set(w)\n        words_with_unique_chars << w if unique_chars.size\
    \ == w.length \n    end\n    return words_with_unique_chars[1] if words_with_unique_chars.size\
    \ > 1 \n    return words[words_with_unique_chars.index(1)]\nend\n</cell>\n<cell>\n\
    @test find_max([\"name\", \"of\", \"string\"]) == \"string\"\n@test find_max([\"\
    name\", \"enam\", \"game\"]) == \"enam\"\n@test find_max([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\"\n</cell>\n<text>\nBonus: Using maps in Julia", "   \
    \ ans = \"\"\n    seen = Set()\n    for w in words\n        if !seen.contains(w)\n\
    \            seen.add(w)\n            ans = ans..find(w)\n        end\n    end\n\
    \    return ans\nend", "\"\"\"\n    word = words[words.size-1]\n    word.count(\"\
    a\")\n    word.count(\"b\")\n    word.count(\"c\")\n    word.count(\"d\")\n  \
    \  word.count(\"e\")\n    word.count(\"f\")\n    word.count(\"g\")\n    word.count(\"\
    h\")\n    word.count(\"i\")\n    word.count(\"j\")\n    word.count(\"k\")\n  \
    \  word.count(\"l\")\n    word.count(\"m\")\n    word.count(\"n\")\n    word.count(\"\
    o\")\n    word.count(\"p\")\n    word.count(\"q\")\n    word.count(\"r\")\n  \
    \  word.count(\"s\")\n    word.count(\"t\")\n    word.count(\"u\")\n    word.count(\"\
    v\")\n    word.count(\"w\")\n    word.count(\"x\")\n    word.count(\"y\")\n  \
    \  word.count(\"z\")\n    word.count(\"0\")\n    word.count(\"1\")\n    word.count(\"\
    2\")\n    word.count(\"3\")\n    word.count(\"4\")\n    word.count(\"5\")\n  \
    \  word.count(\"6\")\n    word.count(\"7\")\n    word.count(\"8\")\n    word.count(\"\
    9\")\n    word.count(\".\")\n    word.count(\",\")\n    word.count(\"!\")\n  \
    \  word.count(\"?\")\n    word.count(\"!\")\n    word.count(\"?\")\n    word.count(\"\
    `\")\n    word.count(\"\\\"\")\n    word.count(\":\")\n    word.count(\";\")\n\
    \    word.count(\":\")\n    word.count(\",\")\n    word.count(\":\")\n    word.count(\"\
    ;\")\n    word.count(\":\")\n    word.count(\";\")\n    word.count(\":\")\n  \
    \  word.count(\":\")\n    word.count(\":\")\n    word.count(\":\")\n    word.count(\"\
    :\")\n    word.count(\":\")\n    word.count(\":\")\n    word.count(\":\")\n  \
    \  word.count(\":\")\n    word.count(\":\")\n    word.count(\":\")\n    word.count(\"\
    :\")\n    word.count(\":\")\n    word.count(\":\")\n    word.count(\":\")\n  \
    \  word.count(\":\")\n    word.count(\":\")\n    word.count(\":\")\n    word.count(\"\
    :\")\n    word.count(\":\")\n    word.count(\":\")\n    word.count(\":\")\n  \
    \  word.count(\":\")\n    word.count(\":\")\n    word.count(\":\")\n    word.count(\"\
    :\")\n    word.count(\":\")", "    words = copy(words)\n    max_word = words[end]\n\
    \    words.drop(end)\n    for i in words[end]\n        if max_word == words[i]\n\
    \            words.drop(end)\n        else\n            max_word = words[i]\n\
    \        end\n    end\n    words = copy(words)\n    max_word = words[end]\n  \
    \  words.drop(end)\n    for i in words[end]\n        if max_word < words[i]\n\
    \            words.drop(end)\n        else\n            max_word = words[i]\n\
    \        end\n    end\n    return max_word\nend\n</code>\n<|/ a |>\n<| c |>\n\
    This does not provide an answer to the question. To critique or request clarification\
    \ from an author, leave a comment below their post. - [From Review](/review/low-quality-posts/11506873)\n\
    <|/ c |>\n<| c |>\nThe code gives a direct answer. It does not require an explanation\
    \ of how it works but a direct answer. As I mentioned in the answer, a direct\
    \ answer is not required but it is much more valuable for people to see a direct\
    \ answer.\n<|/ c |>\n<| c |>\nThis code doesn't work - `find_max` returns `\"\
    aaaaaaa\"` for input `[\"aaaaaaa\", \"bb\", \"cc\"]`\n<|/ c |>\n<| c |>\nYes you\
    \ are correct but the OP asked for the most common word which is not the most\
    \ common alphabet letter. It works if you change it to a word that has more letters\
    \ like \"hello\".\n<|/ c |>\n<| c |>\nSure, but if you change `word_to_num` to\
    \ `word_to_num_lowercase` then it doesn't work. Try it - `find_max([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) returns \"aaaaaaa\"`\n<|/ c |>\n<| a dscore=5 tags=algorithm,julia\
    \ |>\nThe word \"string\" has 7 unique characters.  You can define a new type\
    \ to store a vector of characters:\n<code>\ntype Word\n   chars\nend\n</code>\n\
    You can define an instance for that type:\n<code>", "    local max_cnt = 0 \n\
    \    local max_word = words[1] \n    local min_cnt = words[1] \n    for w in words[2:]\
    \ \n        if w == words[1] \n            continue \n        elseif w in words[2]\
    \ \n            continue \n        elseif w in words[3] \n            continue\
    \ \n        else \n            if w[1] > max_cnt[1] \n                max_cnt\
    \ = w[1] \n                max_word = w \n            else \n                if\
    \ w[1] < min_cnt[1] \n                    min_cnt = w[1] \n                  \
    \  min_word = w \n                else \n                    if w[1] == max_cnt[1]\
    \ and w[1] < min_cnt[1] \n                        max_cnt = w[1] \n          \
    \              max_word = w \n                    else \n                    \
    \    if w[1] == max_cnt[1] and w[1] > min_cnt[1] \n                          \
    \  max_cnt = w[1] \n                            max_word = w \n              \
    \          end  \n                    end \n                end \n           \
    \ end \n        end \n    end \n    return max_word \nend ", "  \nend", "    #\
    \ Your code here\n    # Your code here\n    # Your code here\n    # Your code\
    \ here\n    # Your code here\n    # Your code here\n    # Your code here\n   \
    \ # Your code here\n    # Your code here\n    # Your code here\n    # Your code\
    \ here\n    # Your code here\n    # Your code here\n    # Your code here\n   \
    \ # Your code here\n    return words[end]\nend", "  maximum = words[1]\n  for\
    \ i in 3:length(words) \n    letters = words[i]\n    if length(unique(letters))\
    \ > maximum(length(letters))\n      maximum = length(letters)\n    end\n  end\n\
    \  return maximum(words)\nend\n</cell>\n<text>\nTask 2: Implement find_min function",
  "    \"\"\"Write a function that accepts a vector of strings.\n    The vector contains\
    \ different words. Return the word with maximum number\n    of unique characters.\
    \ If multiple strings have maximum number of unique\n    characters, return the\
    \ one which comes first in lexicographical order.", "  \n  unique_chars = Set()\n\
    \  max_word_length = words[1].length\n  for word in words\n    for char in word\n\
    \      unique_chars = unique_chars + char\n      break\n  end\n  \n  if length(unique_chars)\
    \ > max_word_length\n    return words[1]\n  elseif length(unique_chars) == max_word_length\n\
    \    return words[1][1]\n  else\n    for word in words\n      for char in word\n\
    \        if char != word[1]\n          if char < word[1]\n            return word[1]\n\
    \          end\n        end\n      end\n    end\n  end\nend\n</cell>\n<code language=julia-1.5>\n\
    find_max([\"name\", \"of\", \"string\"])\n</cell>\n<text>\nExercise 1:\nWrite\
    \ a function that accepts a string and returns the number of times each character\
    \ occurs in the string.", "    unique_chars = Vector{String}(undef, 0)\n    for\
    \ word in words\n        unique_chars = [...\n        push!(unique_chars, length(unique_chars))\n\
    \        push!(unique_chars, unique_chars[end-1] ++ word)\n    end\n    return\
    \ words[argmax(unique_chars)]\nend\n</code>\n<|/ a tags=julia |>\n<| a tags=julia\
    \ dscore=0 |>\nHere is an alternative way of doing it using sort!.\n<code>\nusing\
    \ Statistics", "    word_count::Map[String, Int] = Dict()\n    for w in words\n\
    \        word_count[w] = word_count[w] + 1 if w in word_count else 1\n    end\n\
    \    return join(sort(collect(word_count), by=ntuple((ntuple(i->j, length(word_count)));\
    \ rev = true), \" \"), \" \") \nend", "    unique_char = Vector{Int64}()\n   \
    \ for w in words\n        for c in w\n            if !isin(c, unique_char)\n \
    \               unique_char += [c]\n    end\n    unique_char = unique_char.==0.0\
    \ ? [] : unique_char.argmin()\n    for w in words\n        if findfirst(w == unique_char)\
    \ == w\n            return w\n    end\n    return words[1]\nend", "\"\"\"Write\
    \ a function that accepts a vector of strings. \n    The vector contains different\
    \ words. Return the word with maximum number\n    of unique characters. If multiple\
    \ strings have maximum number of unique\n    characters, return the one which\
    \ comes first in lexicographical order.", "    len = length(words)\n    if len\
    \ == 0\n        return nothing\n    word_count = zeros(Int, len)\n    for word\
    \ in words\n        for c in word\n            word_count[c] = word_count[c] +\
    \ 1\n    end\n    index_max = argmax(word_count)\n    word = words[index_max]\n\
    \    return word\nend", "    max_char::String = \"\"\n    curr_count = count_unique(words)\n\
    \    for w in words \n        if count_unique(words) == curr_count then\n    \
    \        curr_count = count_unique(w) \n            max_char = w\n        end\n\
    \    end\n    \n    curr_count = count_unique(words)\n    for w in words \n  \
    \      if count_unique(words) == curr_count then\n            curr_count = count_unique(w)\
    \ \n            if w > max_char \n                max_char = w\n            end\n\
    \        end\n    end", "    max_length = maximum([length(word) for word in words])\n\
    \    word_with_max_length = [word for word in words if length(word) == max_length]\n\
    \    word_with_max_length = word_with_max_length[1]\n    words_with_max_length\
    \ = [word for word in words if length(word) == max_length]\n    if length(words_with_max_length)\
    \ == length(word_with_max_length)\n        return word_with_max_length\n    else\n\
    \        return find_max(words_with_max_length)\n    end\nend\n</code>\n<|/ a\
    \ tags=julia,arrays dscore=3 |>\n<| c |>\nThanks for your response. Your solution\
    \ works, but it is not very elegant, and you miss the case where all words have\
    \ the same length. Also, it does not answer the question, as I specifically asked\
    \ about a solution that takes advantage of the fact that all words in the vector\
    \ are the same length. Your solution does not do that, since it uses a loop, which\
    \ takes more time than vectorized solutions.\n<|/ c |>\n<| c |>\nYes, I agree.\
    \ I was trying to do it in different ways and couldn't figure it out. Sorry for\
    \ bothering you and thank you for help!\n<|/ c |>\n<| a tags=julia,arrays |>\n\
    Here is a more efficient solution that doesn't require the creation of a new array\
    \ of strings.  It only uses length comparisons instead of strings of length comparisons.\
    \  (Although it still creates a new array just to find the max.)\n<code>", " \
    \ \n    #Initialize max to 0, \n    #and max to first word\n    max = -1\n   \
    \ first = 0\n    \n    #Iterate through the vector and compare the counts\n  \
    \  for i in words\n        if i > max\n            max = i\n            first\
    \ = i\n        end\n    end\n    \n    #return the string with max count\n   \
    \ return max\nend", "    \"\"\"\n    Find the maximum word that has maximum number\
    \ of unique characters\n    in lexicographical order\n    \"\"\"\n    unique_char_count\
    \ = Dict{String, Int}()\n    for word in words\n        unique_char_count[word]\
    \ = length(unique_char_count, word)\n    end\n    return head(sort(unique_char_count.keys))\n\
    end\n</cell>\n<code language=julia-1.0>\nfind_max([\"name\", \"of\", \"string\"\
    ])\n</cell>\n<code language=julia-1.0>\nfind_max([\"name\", \"enam\", \"game\"\
    ])\n</cell>\n<code language=julia-1.0>\nfind_max([\"aaaaaaa\", \"bb\", \"cc\"\
    ])\n</cell>\n<code language=julia-1.0>\nfind_max([\"one\", \"two\", \"three\"\
    ])\n</cell>\n<code language=julia-1.0>\nfind_max([\"one\", \"two\", \"three\"\
    , \"four\", \"five\"])\n</cell>\n<code language=julia-1.0>", "    \n    return\
    \ words[findmax(words)]\nend", "    unique_chars=Set(String[])\n    for w in words\
    \ \n        unique_chars=union(unique_chars,keys(w))\n    return w[argmax(lengths(unique_chars))]\n\
    end\n</cell>\n<text>\nQuestion 13\nImplement a function that accepts a vector\
    \ of words and a delimiter as input and returns the list of distinct words separated\
    \ only by the given delimiter.", "    word_counts::HashSet{String} = HashSet{String}()\n\
    \    for i in words\n        word_counts[i] = word_counts[i] + 1 || 1\n      \
    \  word_counts.sort_by(&:length)\n    end\n    word_counts.max_by(&:length)\n\
    end\n</cell>\n<code language=julia-1.3>\nfind_max([\"aaaaaaa\", \"bb\", \"cc\"\
    ])\n</cell>\n<text>\nExercise 2\nWrite a function that accepts a vector of strings.\n\
    \    The vector contains different words. Return the word with maximum number\n\
    \    of unique characters. If multiple strings have maximum number of unique\n\
    \    characters, return the one which comes first in lexicographical order.",
  "    let word = words[end]\n    word = collect(word)\n    word = sort(word)\n  \
    \  word = word[1:end-1]\n    word = filter(w->w==word,word)\n    word = collect(word)\n\
    \    word = sort(word)\n    word = word[1:end-1]\n    word = collect(word)\n \
    \   word = sort(word)\n    word = word[1:end]\n    return word\nend\n\"\"\"\n\
    \    >>> find_max([\"apple\", \"banana\", \"orange\"])\n    \"orange\"\n    >>>\
    \ find_max([\"apple\", \"banana\", \"orange\", \"mango\"])\n    \"mango\"\n  \
    \  \"\"\"", "    # Write your function here\n    \n    wordcounts=Dict{String,\
    \ Int}()\n    for w in words\n        if wordcounts[w]==0\n            wordcounts[w]=length(w)\n\
    \        else\n            if wordcounts[w]>length(w)\n                wordcounts[w]=length(w)\n\
    \            end\n        end\n    end\n    \n    sortedwords=sort(collect(wordcounts),\
    \ by=x->x)\n    \n    wordwithmax=sortedwords[end]\n    \nend\n</cell>\n<text>\n\
    Q8. Write a function that accepts a vector of strings and a target word. Print\
    \ out all the strings that contain the target word. If target word is not found,\
    \ print out \"not found\".", "    \n    \n    for word in words \n        \n \
    \       length(word)\n        \n    end\n    \nend\n</cell>\n<text>\nExercise:\
    \ Write a function that accepts a matrix of strings. The matrix contains different\
    \ words. \n    Output the word with maximum number of unique characters. \n  \
    \  If multiple strings have maximum number of unique characters, return the one\
    \ \n    which comes first in lexicographical order.", "    if length(words) ==\
    \ 0\n        return \"\"\n    \n    # Create a set of all characters in all words\n\
    \    char_set = Set()\n    for word in words\n        for c in word\n        \
    \    push!(char_set, c)\n    \n    # Get the number of unique characters and largest\
    \ word\n    max_char_n = length(char_set)\n    most_word = \"\"\n    for word\
    \ in words\n        if length(word) == max_char_n\n            most_word = word\n\
    \        end\n    end\n    \n    # Return the one with maximum number of unique\
    \ characters\n    return most_word\nend\n</cell>\n<text>\nQuestion 5\nWrite a\
    \ function that accepts a vector (of vectors), and, for each element of the vector,\
    \ \nreturns a vector of strings (of characters). For example, given a vector of\
    \ vectors\n[[\"and\", \"or\"], [\"the\", \"and\", \"the\"]], the function should\
    \ return a vector of\nstrings [\"and\", \"the\"].", "    word_dict = {}\n    for\
    \ word in words \n        if !haskey(word_dict, length(word_dict)) \n        \
    \    word_dict[length(word_dict)] = word \n        else \n            if length(word_dict[length(word_dict)])\
    \ < length(word) \n                word_dict[length(word_dict)] = word \n    \
    \        end\n        end\n    end\n    max_length = 0\n    max_length_word =\
    \ \"\"\n    for key, value in word_dict\n        if length(value) > max_length\n\
    \            max_length = length(word_dict)\n            max_length_word = key\n\
    \        end\n    end\n    \n    return max_length_word\nend", "    word_count_map\
    \ = Dict(reverse(word)) |> count\n    word_count_map.values.sort\n        word_count_map[word_count_map.values.last]\n\
    end", '"""', "        \n    let uc = Dict{Char,Int}(uniqueChars(words))\n    let\
    \ mc = Dict{Char,Int}()\n    let result = words[words.size]\n    for i in words[2:end]\
    \ \n        uc[i] <- (uc[i]+1) % length(uc)\n        for j in words[3:end]\n \
    \           mc[j] <- (mc[j]+1) % length(mc)\n            if mc[j] >= uc[i] \n\
    \                result <- (uc[i] + mc[words[i]]) % length(uc)\n            elseif\
    \ mc[j] >= uc[i+1]\n                result <- (uc[i+1] + mc[j]) % length(uc)\n\
    \            else\n                result <- (uc[i] + mc[j]) % length(uc)\n  \
    \          end\n        end\n    end\n    return result\nend\n</cell>\n<code language=julia-1.5>\n\
    find_max([\"name\", \"of\", \"string\"])\n</cell>\n<code language=julia-1.5>\n\
    find_max([\"name\", \"enam\", \"game\"])\n</cell>\n<code language=julia-1.5>\n\
    find_max([\"aaaaaaa\", \"bb\", \"cc\"])\n</cell>\n<code language=julia-1.5>\n\
    find_max([\"aaaaaaa\", \"bb\", \"cc\", \"dddd\"])\n</cell>\n<code language=julia-1.5>\n\
    find_max([\"aaaaaaa\", \"bb\", \"cc\", \"dddd\", \"eeee\"])\n</cell>\n<text>\n\
    Write a function that accepts a matrix of characters as input and return the word\
    \ with maximum number of unique characters.", "    for word in words\n       \
    \ if count(word) > count(words[1])\n            return words[1]\n    return words[1]\n\
    end\n</cell>\n<cell>\nfind_max([\"aaaaaaa\", \"bb\", \"cc\"])\n</cell>\n<text>\n\
    Problem 7", "    words = sort(words)\n    counts = Dict()\n    for word in words\n\
    \        counts[word] = get(counts, word, 0) + 1\n    end\n    \n    minimum =\
    \ counts[1]\n    for key in counts\n        if counts[key] < minimum\n       \
    \     minimum = counts[key]\n        end\n    end\n    return minimum\nend", " \
    \   word_counter = Dict()\n    for word in words\n        word_counter[word] =\
    \ get(word_counter, word, 0) + 1\n    end", "    wordcounts = Dict{String,Int64}()\n\
    \    for word in words\n        for c in word\n            if c not in wordcounts\n\
    \                wordcounts[c] = 0\n            wordcounts[c] += 1\n    end\n\
    \    wordcounts[\"a\"] = 2\n    wordcounts[\"aa\"] = 1\n    wordcounts[\"ab\"\
    ] = 2\n    wordcounts[\"ac\"] = 1\n    wordcounts[\"ca\"] = 1\n    wordcounts[\"\
    oa\"] = 2\n    wordcounts[\"ob\"] = 1\n    wordcounts[\"oc\"] = 1\n    wordcounts[\"\
    oo\"] = 1\n    wordcounts[\"ooo\"] = 2\n    wordcounts[\"e\"] = 2\n    wordcounts[\"\
    eh\"] = 2\n    wordcounts[\"ah\"] = 1\n    wordcounts[\"ahs\"] = 2\n    wordcounts[\"\
    ahsh\"] = 2\n    wordcounts[\"er\"] = 2\n    wordcounts[\"erh\"] = 2\n    wordcounts[\"\
    erhs\"] = 2\n    wordcounts[\"erhsh\"] = 2\n    wordcounts[\"h\"] = 2\n    wordcounts[\"\
    hs\"] = 2\n    wordcounts[\"hsh\"] = 2\n    wordcounts[\"ers\"] = 2\n    wordcounts[\"\
    ersh\"] = 2\n    wordcounts[\"ershs\"] = 2\n    wordcounts[\"ershsh\"] = 2\n \
    \   wordcounts[\"hsh\"] = 2\n    wordcounts[\"hshs\"] = 2\n    wordcounts[\"hshsh\"\
    ] = 2\n    wordcounts[\"ers\"] = 2\n    wordcounts[\"ersh\"] = 2\n    wordcounts[\"\
    ershs\"] = 2\n    wordcounts[\"ershsh\"] = 2\n    wordcounts[\"ershshs\"] = 2\n\
    \    wordcounts[\"ershshsh\"] = 2\n    wordcounts[\"ershshshs\"] = 2\n    wordcounts[\"\
    ershshshsh\"] = 2\n    wordcounts[\"ershshshshs\"] = 2\n    wordcounts[\"ershshshshsh\"\
    ] = 2\n    wordcounts[\"ershshshshshs\"] = 2\n    wordcounts[\"ershshshshshsh\"\
    ] = 2\n    wordcounts[\"ershshshshshshs\"] = 2\n    wordcounts[\"ershshshshshshsh\"\
    ] = 2\n    wordcounts[\"ershshshshshshshs\"] = 2\n    wordcounts[\"ershshshshshshshsh\"\
    ] = 2\n    wordcounts[\"ershshshshshshshshs\"] = 2\n    wordcounts[\"ershshshshshshsh",
  "  max_length = 0\n  result::String = \"\"\n  for word in words \n    count = length(unique(word))\n\
    \    \n    if count > max_length \n      result = word\n      max_length = count\
    \ \n    end\n  end\n  return result\nend\n</cell>\n<code language=julia-1.4>\n\
    find_max([\"hello\", \"hello\", \"world\"])\n</cell>\n<text>\nReturning the element\
    \ from a function\nA function returns a value when it is called. The value is\
    \ returned only if the function is called. But sometimes a function doesn't return\
    \ a value, and in that case, the function returns nothing. You can use return\
    \ to return an element from the function to the calling program.", "    word_set\
    \ = Set()\n    for word in words\n        word_set += Set(word)\n    end\n   \
    \ word_set = sort(collect(word_set), by=length) # sorts by the number of unique\
    \ characters\n    word_set = word_set[1]\n    return word_set\nend", "    \n \
    \   for word in words\n        char_unique = sum([1 for i in word if i != \"a\"\
    ])\n        if char_unique >= max_unique\n            max_unique = char_unique\n\
    \            best_word = word\n        end\n    end", "    unique=unique(words)\n\
    \    maximum=maximum((length(unique)))\n    for i in maximum\n        unique[i]\n\
    \    end\nend\n</cell>\n<text>\nExercise 8\nWrite a function that accepts a vector\
    \ of integers and returns the sum of the integers. If the sum equals the maximum\
    \ value, then the function should return \"Max Value\". Otherwise it should return\
    \ the sum of the integers. Test your function by passing in some random integers\
    \ and checking if it returns \"Max Value\".", "    return find_max(words,0)\n\
    end", "    sorted_words = sort(words)\n    max_element = sorted_words[end]\n \
    \   if length(sorted_words) == 1 || length(sorted_words) == 0 \n        findmax_string\
    \ = max_element\n    else\n        findmax_string = \"\"\n        for element\
    \ in sorted_words \n            if length(element) > length(findmax_string)\n\
    \                findmax_string = element\n            end\n        end\n    end\n\
    \    return findmax_string\nend\n</code>\n<|/ a tags=julia,function,string,unique,arrays\
    \ |>\n<| c |>\nThanks, this looks neat! However, I get the following error when\
    \ trying to run it:\n`ERROR: LoadError: LoadError: MethodError: no method matching\
    \ length(::Int64)`\n<|/ c |>\n<| c |>\nI have edited my answer to include a sample\
    \ code snippet which you can run\n<|/ c |>\n<| a dscore=1 |>\n<code>", "    local\
    \ counter = Dict{String, Int}()\n    for word in words \n        counter[word]\
    \ = counter[word] + 1\n    end\n    \n    local i = 1\n    \n    for word in words\n\
    \        if counter[word] > i\n            return word\n        end\n        i\
    \ += 1\n    end\n    return words[1]\nend\n\"\"\"\nWrite a function that accepts\
    \ a string and returns the last word in the string.\nIf the string has less than\
    \ one word, return \"nothing\".", "    words_hash = Set{String}()\n    for w in\
    \ words\n        if w <> \"\"\n            words_hash += w\n    end\n    words_hash.sort()\n\
    \    ans = \"\"\n    for i in words_hash\n        if i <> ans\n            ans\
    \ = i\n        end\n    end\n    return ans\nend\n</cell>\n<text>\nExercise 4:",
  "\"\"\"\nWrite a function that accepts a vector of strings and a character as input.\
    \ \nReturn the word with maximum number of unique characters. If multiple strings\n\
    have maximum number of unique characters, return the one which comes first in\n\
    lexicographical order.", "    \n    unique = Set()\n    \n    for word in words\n\
    \        unique = union(unique, length(unique(word)))\n    end\n    \n    if length(unique)\
    \ == length(words)\n        return words[end]\n    end", "    words_str = Vector{String}(words)\n\
    \    words_str_sorted = sort(words_str)\n    words_str_sorted_unique = unique(words_str_sorted)\n\
    \    words_str_sorted_unique_sorted = sort(words_str_sorted_unique)\n    return\
    \ words_str_sorted_unique_sorted[1] \nend\n</cell>\n<text>\nChallenge 5\nWrite\
    \ a function that accepts an integer and returns a string made of digits from\
    \ 1 to this integer.", "    sorted_by_uniq = sort(uniq(words))\n    uniq_word_counts\
    \ = countmap(sort(uniq(words)))\n    sorted_by_uniq.uniq_count > uniq_word_counts.uniq_count\
    \ && return sorted_by_uniq.words[1]\n    return sorted_by_uniq.words[end]\nend",
  "\"\"\"\n    \n    max_length = 0\n    \n    words_with_max_length = 0\n    \n \
    \   for w in words\n        \n        if length(unique(word)) > max_length\n \
    \           max_length = length(unique(word))\n            words_with_max_length\
    \ = 1\n        else\n            words_with_max_length += 1\n        end\n   \
    \ end\n    \n    if words_with_max_length > 1\n        \n        sorted_words\
    \ = [w for (w, count) in sort(collect(zip(words, counts)))]\n        \n      \
    \  if length(unique(sorted_words)) > max_length\n            max_length = length(unique(sorted_words))\n\
    \            words_with_max_length = 1\n        else\n            words_with_max_length\
    \ += 1\n        end\n        \n        sorted_words[words_with_max_length]\n \
    \   else\n        sorted_words[1]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    find_max([\"a\", \"b\", \"c\", \"d\", \"e\"])\n</cell>\n<code language=julia-1.5>\n\
    find_max([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"])\n</cell>\n<text>\nExercise:\
    \ Find Maximum in Vector\nWrite a function that accepts a vector of integers and\
    \ returns the element which has the maximum value.\nHint: Use maximum and find",
  "    sort_and_count(words)\n    find_max(sorted_words[length(sorted_words) - 1])\n\
    end\n</cell>\n<text>\nProblem 3\nWrite a function that finds the number of unique\
    \ characters in a string. The function should only accept strings that consist\
    \ of characters from English alphabets.", "   \n    word = words[end]\n    if\
    \ length(word) == 0 \n        return word \n    counts = Vector{Int}()\n    for\
    \ i in word\n        counts[i] = counts[i] + 1 \n    end\n    word = words[findfirst(isequal(word),\
    \ counts)]\n    return word\nend ", "  \n  if length(words) == 0\n    return \"\
    \"\n  \n  wordlist = words\n  \n  maxcount = 0\n  maxword = \"\"\n  \n  for word\
    \ in wordlist\n    if length(unique(strings(word))) == maxcount\n      maxword\
    \ = word\n      break\n    end\n    maxcount = length(unique(strings(word)))\n\
    \  end\n  \n  return maxword\nend", "    word_counts = HashSet[String]()\n   \
    \ for word in words\n        word_counts[word] = get(word_counts, word, 0) + 1\n\
    \    end\n    \n    word_counts.max_by(&identity)\nend\n</cell>\n<code language=julia-1.5>\n\
    find_max([\"aaaaaaa\", \"bb\", \"cc\"])\n</cell>\n<text>\n3.3 Exercise\nDefine\
    \ a function called find_max_word that accepts a vector of strings and\nreturns\
    \ the word with maximum number of unique characters.", "    word_count = map(length,\
    \ words)\n    word_count = sort(word_count)\n    word_count = word_count[1:end-1]\n\
    \    word = words[argmax(word_count)]\n    return word\nend\n</code>\n<|/ a tags=julia\
    \ dscore=1 |>\n<| c |>\nThanks so much! How would you modify the solution so that\
    \ the function returns the first word that is the most frequent in a vector? i.e.\
    \ for find_max([a,b,b,b,c]) it would return b, rather than c, right?\n<|/ c |>\n\
    <| c |>\nHi Yuram! I have edited the answer to return the first word that appears\
    \ most frequently. Hope it helps.\n<|/ c |>\n<| a dscore=1 |>\nHere's another\
    \ possible solution:\n<code>", "    unique_char::Int64 = 0\n    for word in words\
    \ \n        unique_char += length(word)\n    end\n    if unique_char > length(words[1])\n\
    \        return words[1]\n    else\n        for word in words\n            if\
    \ length(word) > unique_char\n                return word\n            end\n \
    \       end\n    end\n    return \"\"\nend\n</cell>\n<code language=julia-1.0>",
  "  if words == []\n    return \"\"\n  max_count = length(unique(words))\n  for word\
    \ in words\n    if length(unique(word)) > max_count\n      max_count = length(unique(word))\n\
    \      \n  return words[max_count]\nend\n</cell>\n<text>\nBonus question: Write\
    \ a function that returns a string with a given word repeated N times. For example,\
    \ a word = 'cat' should be repeated N times. Return an empty string if there is\
    \ no such word.", "    sorted_indices = sort(indices)\n    max_word = words[sorted_indices[-1]]\n\
    \    for index in sorted_indices[1:length(words)]\n        if words[index] ==\
    \ max_word\n            return words[index]\n        end\n    end\nend", "  \n\
    \  max_count = -1\n  max_word = \"\"\n  \n  for word in words \n    count = count(word)\n\
    \    if count > max_count \n      max_count = count\n      max_word = word\n \
    \   end\n  end\n  return max_word\nend\n</cell>\n<text>\nSolution\nClick below\
    \ for one possible solution.", "    word_count=Dict{String,Int}()\n    for word\
    \ in words\n        if get(word_count,word)==0\n            word_count[word]=1\n\
    \        else\n            word_count[word]+=1\n    end\n    return word_count[word_count.keys[end]];\n\
    end\n</cell>\n<code language=julia-0.4>\nfind_max([\"name\", \"of\", \"string\"\
    ])\n</cell>\n<code language=julia-0.4>\nfind_max([\"name\", \"enam\", \"game\"\
    ])\n</cell>\n<code language=julia-0.4>\nfind_max([\"aaaaaaa\", \"bb\", \"cc\"\
    ])\n</cell>\n<code language=julia-0.4>\nfind_max([\"aaaaaaa\", \"bb\", \"cc\"\
    ])\n</cell>\n<text>\nProblem 3. Find the maximum of a vector with string\nImplement\
    \ the find_max function using a for loop:", "    word_counts = Dict{String, Int}()\n\
    \    for word in words do\n        if !haskey(word_counts, word)\n           \
    \ word_counts[word] = 0\n        end\n        word_counts[word] +=1\n    end\n\
    \    for word, count in word_counts do\n        if count > max_count\n       \
    \     max_count = count\n            max_word = word\n        end\n    end\n \
    \   return max_word\nend\n</cell>\n<text>\nSolutions", "    letters = words[1]\n\
    \    for i in words[2:length(words)]\n        letters = letters + i\n    end\n\
    \    letters = unique(letters)\n    letters = letters[2:end-1]\n    letters =\
    \ letters[findall(letters == \"a\", \"a\")]\n    letters = letters[findall(letters\
    \ == \"b\", \"b\")]\n    letters = letters[findall(letters == \"c\", \"c\")]\n\
    \    letters = letters[findall(letters == \"d\", \"d\")]\n    letters = letters[findall(letters\
    \ == \"e\", \"e\")]\n    letters = letters[findall(letters == \"f\", \"f\")]\n\
    \    letters = letters[findall(letters == \"g\", \"g\")]\n    letters = letters[findall(letters\
    \ == \"h\", \"h\")]\n    letters = letters[findall(letters == \"i\", \"i\")]\n\
    \    letters = letters[findall(letters == \"j\", \"j\")]\n    letters = letters[findall(letters\
    \ == \"k\", \"k\")]\n    letters = letters[findall(letters == \"l\", \"l\")]\n\
    \    letters = letters[findall(letters == \"m\", \"m\")]\n    letters = letters[findall(letters\
    \ == \"n\", \"n\")]\n    letters = letters[findall(letters == \"o\", \"o\")]\n\
    \    letters = letters[findall(letters == \"p\", \"p\")]\n    letters = letters[findall(letters\
    \ == \"q\", \"q\")]\n    letters = letters[findall(letters == \"r\", \"r\")]\n\
    \    letters = letters[findall(letters == \"s\", \"s\")]\n    letters = letters[findall(letters\
    \ == \"t\", \"t\")]\n    letters = letters[findall(letters == \"u\", \"u\")]\n\
    \    letters = letters[findall(letters == \"v\", \"v\")]\n    letters = letters[findall(letters\
    \ == \"w\", \"w\")]\n    letters = letters[findall(letters == \"x\", \"x\")]\n\
    \    letters = letters[findall(letters == \"y\", \"y\")]\n    letters = letters[findall(letters\
    \ == \"z\", \"z\")]\n    letters = letters[findall(letters == \"a\", \"a\")]\n\
    \    letters = letters[findall(letters == \"b\", \"b\")]\n    letters = letters[findall(letters\
    \ == \"c\", \"c\")]\n    letters = letters[findall(letters == \"d\", \"d\")]\n\
    \    letters = letters[findall(letters == \"e\", \"e\")]\n    letters = letters[findall(letters\
    \ == \"f\", \"f\")]\n    letters = letters[findall(letters == \"g\", \"g\")]\n\
    \    letters = letters[findall(letters == \"h\", \"h\")]\n    letters = letters[findall(letters\
    \ == \"i\", \"i", "    # Write your solution here\n    \nend\n</cell>\n<text>\n\
    Question 5\nThe function find_max has returned the maximum string in the given\
    \ vector. Implement a function that takes a vector as input and returns the number\
    \ of unique elements in the vector. For example, find_max([\"hello\", \"hello\"\
    ]) returns 2. Make sure your function works correctly for all other types of inputs.\
    \ You can use map() to write this function.", "\"\"\"\n    words_count = Dict{Char,Int}()\n\
    \    for w in words\n        counts[w] += 1\n    end\n    maximum = maximum_key(words_count,\
    \ count)\n    for key in keys(words_count)\n        words_count[key] == maximum\
    \ && return key\n    error(\"All words have same number of unique chars\")\nend\n\
    </cell>\n<code language=julia-1.5>\nfind_max(names)\n</cell>\n<text>\nExercise",
  "    n = length (words)\n    seen = Set()\n    max = words[1]\n    for word in words[2:end]\n\
    \        if length(seen) == 0 or length(seen) == length(word) || length(seen)\
    \ == length(word) + 1 \n            seen = union(seen, word)\n            if length(seen)\
    \ > length(max)\n                max = seen\n        end\n    end\n    return\
    \ max\nend\n</cell>\n<cell>\nfind_max [\"name\", \"of\", \"string\"]\n</cell>\n\
    <cell>\nfind_max [\"name\", \"enam\", \"game\"]\n</cell>\n<cell>\nfind_max [\"\
    aaaaaaa\", \"bb\", \"cc\"]\n</cell>\n<cell>\nfind_max [\"hello\", \"world\"]\n\
    </cell>\n<text>\n3.8 Exercise: Write a function that will perform a linear search\
    \ on a given\n    vector. You'll be given two vectors \u2013 one for the search\
    \ key and another\n    for the search value. The function should return the index\
    \ of the\n    search value when the search key is found. Otherwise, return -1.",
  "\"\"\"Write a function that accepts a vector of strings.\n    The vector contains\
    \ different words. Return the word with maximum number\n    of unique characters.\
    \ If multiple strings have maximum number of unique\n    characters, return the\
    \ one which comes first in lexicographical order.", "  unique_chars = Set()\n\
    \  res = \"\"\n  for w in words\n    unique_chars = unique_chars + Set(w)\n  end\n\
    \  for c in unique_chars\n    if unique_chars.count(c) > words.index(res)\n  \
    \    res = c\n    end\n  end\n  return res\nend", "    \n    unique_chars = unique.(collect.(words))\n\
    \    \n    # If the vector has more than one word, repeat the function on the\
    \ list of strings\n    if size(unique_chars) > 1\n        best_string = find_max(words[1])\n\
    \        best_unique_chars = unique.(collect.(words[1]))\n    else\n        best_string\
    \ = \"\"\n        best_unique_chars = unique_chars[1]\n    end\n    \n    # Iterate\
    \ over the vector of unique characters and return the word with maximum\n    #\
    \ number of unique characters\n    for unique_char in unique_chars\n        if\
    \ length(best_string) < length(unique_char)\n            best_string = unique_char\n\
    \        end\n        if length(best_string) == length(unique_char)\n        \
    \    if best_unique_chars > length(unique_char)\n                best_string =\
    \ unique_char\n                best_unique_chars = length(best_string)\n     \
    \       end\n        end\n    end\n    return best_string\nend\n</cell>\n<code\
    \ language=julia-0.5>\nfind_max([\"a\", \"b\", \"c\", \"c\", \"d\"])\n</cell>\n\
    <text>\nWrite a function that accepts a vector of strings. The vector contains\
    \ words separated by a space.\n    Print the first word of the string. If there\
    \ are no words in the string, then print an informative message. \n    If multiple\
    \ words have maximum unique characters, return one word which comes first in lexicographical\
    \ order.", "    word_with_count = {}\n    for w in words\n        if !haskey(word_with_count,\
    \ w)\n            word_with_count[w] = 0\n        end\n        word_with_count[w]\
    \ += 1\n    end", "    \n# fill code here\n    \nend", "\"\"\"\n    "]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
