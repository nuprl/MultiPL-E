name: HumanEval_134_check_if_last_char_is_a_letter
language: jl
prompt: "\"\"\"\n    Create a function that returns true if the last character\n \
  \   of a given string is an alphabetical character and is not\n    a part of a word,\
  \ and false otherwise.\n    Note: \"word\" is a group of characters separated by\
  \ space.\n\n    Examples:\n    >>> check_if_last_char_is_a_letter(\"apple pie\"\
  )\n    false\n    >>> check_if_last_char_is_a_letter(\"apple pi e\")\n    true\n\
  \    >>> check_if_last_char_is_a_letter(\"apple pi e \")\n    false\n    >>> check_if_last_char_is_a_letter(\"\
  \")\n    false\n    \"\"\"\nfunction check_if_last_char_is_a_letter(txt::String)::Bool\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = check_if_last_char_is_a_letter;\n\
  \t@test(candidate(\"apple\") == false)\n\t@test(candidate(\"apple pi e\") == true)\n\
  \t@test(candidate(\"eeeee\") == false)\n\t@test(candidate(\"A\") == true)\n\t@test(candidate(\"\
  Pumpkin pie \") == false)\n\t@test(candidate(\"Pumpkin pie 1\") == false)\n\t@test(candidate(\"\
  \") == false)\n\t@test(candidate(\"eeeee e \") == false)\n\t@test(candidate(\"apple\
  \ pie\") == false)\n\t@test(candidate(\"apple pi e \") == false)\nend\n"
completions: ["    if txt == \"\"\n        false\n    elseif txt.chars.last.is_alpha\n\
    \        true\n    else\n        false\nend", "    if txt.length == 0\n      \
    \  false\n    elseif txt.length == 1\n        txt[0] in \"abcdefghijklmnopqrstuvwxyz\"\
    \n    else\n        txt[txt.length-1] in \"abcdefghijklmnopqrstuvwxyz\"\n    end\n\
    end\n</cell>\n<code language=julia-1.2>\n\"\"\"\n    Create a function that returns\
    \ true if the last\n    character of a given string is an alphabetical character\n\
    \    and is not a part of a word and false otherwise.\n    Note: \"word\" is a\
    \ group of characters separated by space.", "    \n    if txt != \"\"\n      \
    \  lets_cnt::Int = txt.count(\"a\")\n        letters_cnt::Int = txt.count(\"A\"\
    )\n        if lets_cnt > 0 and letters_cnt > 0\n            true\n        else\n\
    \            false\n        end\n    else\n        false\n    end\nend", "   \
    \ letter::String = \"abcdefghijklmnopqrstuvwxyz\"\n    return !(txt.ends_with?(letter))\n\
    end\n\"\"\"\n    Create a function that returns true if the last character\n \
    \   of a given string is an alphabetical character and is not\n    a part of a\
    \ word, and false otherwise.\n    Note: \"word\" is a group of characters separated\
    \ by space.", "        \" returns true if last char is alphabetical character\
    \ and is not part of a word. Otherwise returns false \"\n    return txt[length(txt)-1]\
    \ in string.ascii_letters or txt[length(txt)-1] in string.whitespace\nend", " \
    \   \"\"\"\n    Create a function that returns true if the last character\n  \
    \  of a given string is an alphabetical character and is not\n    a part of a\
    \ word, and false otherwise.\n    Note: \"word\" is a group of characters separated\
    \ by space.", "    local i\n    for i in reverse(txt) do\n        if i ~= ' '\
    \ and (i % 32 < 33 or i % 32 > 47) \n        return false\n    end\n    return\
    \ true\nend\n    \"\"\"\n    check = j.tools.jython_platform.check\n    cmd =\
    \ '''\nfrom java.lang import Math\ndef isLetter(txt):\n    '''\n    lines = txt.split(\"\
    \\n\")\n    lines = [i.strip() for i in lines]\n    lines = [i for i in lines\
    \ if i]\n    lines = [i for i in lines if i]\n    txt = ' '.join(lines)\n    txt\
    \ = txt.strip()\n    cmd = '''\ndef isLetter(txt):\n    '''\n    lines = txt.split(\"\
    \\n\")\n    lines = [i.strip() for i in lines]\n    lines = [i for i in lines\
    \ if i]\n    lines = [i for i in lines if i]\n    txt = ' '.join(lines)\n    txt\
    \ = txt.strip()\n    cmd = '''\ndef isLetter(txt):\n    '''\n    lines = txt.split(\"\
    \\n\")\n    lines = [i.strip() for i in lines]\n    lines = [i for i in lines\
    \ if i]\n    lines = [i for i in lines if i]\n    txt = ' '.join(lines)\n    txt\
    \ = txt.strip()\n    return not (j.data.types.string.check(txt) and not j.data.types.string.check(txt[0:-1]))\n\
    \    '''\n    txt = txt.strip()\n    lines = txt.split(\"\\n\")\n    lines = [i.strip()\
    \ for i in lines]\n    lines = [i for i in lines if i]\n    lines = [i for i in\
    \ lines if i]\n    txt = ' '.join(lines)\n    txt = txt.strip()\n    result =\
    \ check(text=txt, cmd=cmd)\n    return result\n</code>\n<|/ a dscore=2 |>\n<|\
    \ c |>\nIt's not going to work in general.  For example, `\"foobar\"` is an invalid\
    \ string.\n<|/ c |>\n<| c |>\nOh sorry I missed that. I have edited my answer.\n\
    <|/ c |>\n<| c |>\nThe second function doesn't work in my case because I'm checking\
    \ if certain characters are in the string and only those characters.\n<|/ c |>\n\
    <| c |>\nSorry I'm not an expert in regular expressions, I don't know what that\
    \ regex means.\n<|/ c |>\n<| c |>\nI added a Python script that does that\n<|/\
    \ c |>\n<| a |>\nThis question got me interested, so I went looking. I couldn't\
    \ find a way to do it in jython. Luckily, in ruby there is String#scan:\n<code>\n\
    def isLetter(txt)\n  return txt.scan(/[a-z]/).length != 1\nend", "  match = re.search(r\"\
    \"\"^[^\\w]$\"\"\", txt)\n  if match == nil\n    return false\n  else \n    letter\
    \ = txt[end-1]\n    return letter != \"a\" && letter != \"A\" && letter != \"\
    e\" && letter != \"E\" && letter != \"i\" && letter != \"I\" && letter != \"o\"\
    \ && letter != \"O\" && letter != \"u\" && letter != \"U\" && letter != \"n\"\
    \ && letter != \"N\"\n    end\nend\n</cell>\n<text>\nExercise", "    if txt.size\
    \ == 0\n        false\n    elseif txt.size > 0\n        txt endswith \" \" or\
    \ txt endswith \".\" or txt endswith \",\"\n        or txt endswith \"!\" or txt\
    \ endswith \"?\" or txt endswith \"\"\n        or txt endswith \".\" or txt endswith\
    \ \"/\" or txt endswith \"-\"\n        or txt endswith \"/\" or txt endswith \"\
    .\"\n        false\n    else\n        true\n    end\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nHi, this code is perfect for the first example given in the question.\
    \ The second one fails because it contains spaces after the last character. I\
    \ am not sure how this would translate to the problem stated in the question -\
    \ do you have a solution? Thanks\n<|/ c |>\n<| c |>\nI have edited the answer.\
    \ Hope it solves the problem.\n<|/ c |>\n<| c |>\nThanks Ray, this works perfectly!\
    \ However, in my case I need it to be case-insensitive, so I replaced `endswith\
    \ \" \"` to `endswith \" .\"`. Would you know how to make it case-insensitive\
    \ too? Also, do you know if there are any performance issues with this code? Thanks\
    \ so much.\n<|/ c |>\n<| c |>\n, I have edited the answer to include a case insensitive\
    \ version.\n<|/ c |>\n<| c |>\nThanks Ray, this works perfectly too and also works\
    \ for my requirements!\n<|/ c |>\n<| a tags=julia,string,function dscore=2 |>\n\
    Here is a more efficient implementation:\n<code>", "    # Your code here\n   \
    \ if txt.length() == 0 \n        or txt.chars().last().is_alpha() \n    then true\
    \ \n    else false\n    end", "    txt = txt[end]\n    if txt.isalpha() \n   \
    \     txt = txt.rstrip()\n    end", "    txt.length >= 2 && txt[txt.length - 1].isalpha()\n\
    end\n</cell>\n<code language=julia-0.6>\n\"\"\"\n    Create an empty dictionary\
    \ to store words (keys) and number of times they\n    appear in a given text (values).\n\
    \    Note: to store only words appearing at least two times, use a Dict{String,Int}.",
  "    txt <- gsub(pattern=\"^\\\\s+\", repl=\"\", txt)\n    # return true if txt\
    \ is empty string or the first character\n    # is alphabetical and is not a part\
    \ of a word\n    return (length(txt)==1 && ichar(txt |> first) == isalpha(txt))\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nthank you. Your answer looks great! I'll\
    \ try to run it on the text and see if I get the same result as you did. I appreciate\
    \ the help!\n<|/ c |>\n<| c |>\nIt works pretty well on the sample text. On my\
    \ real text I got this error `type mismatch in value from field \"txt\" in statement\
    \ \"txt <- gsub(pattern=\"^\\\\s+\", repl=\"\", txt)\"`\n<|/ c |>\n<| c |>\nI\
    \ found the error in my real text. The code works as well on the text you provided.\
    \ I was still using the wrong variable names for the function. I appreciate the\
    \ help!\n<|/ c |>\n<| c |>\nNo worries. Glad to help.\n<|/ c |>\n<| a tags=string,r,split\
    \ |>\nA simple solution would be to check if the character at the last index is\
    \ not a space \" \" followed by an \"r\". We can do that by using gregexpr and\
    \ checking if the last index has two elements in it (the number of characters\
    \ + 1) using lengths:\n<code>\ngrepl(\" r\", strsplit(x, \" \") [[1]][lengths(strsplit(x,\
    \ \" \")[[1]])])\n# [1] FALSE  TRUE  TRUE  TRUE FALSE\n</code>\nIf we wish to\
    \ return the words that match we can use str_subset:\n<code>\nlibrary(stringr)\n\
    str_subset(x, \" r\")\n</code>\n<|/ a dscore=0 |>\n<| a tags=string,r,split |>\n\
    <code>\nlibrary(stringr)\nlibrary(dplyr)", "    return txt[txt.length - 1] \u2209\
    \ \" \" \u2227 txt[txt.length - 1] \u2208 \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    \nend\n</cell>\n<code language=julia-0.6>\ncheck_if_last_char_is_a_letter(\"apple\
    \ pie \")\n</cell>\n<text>\nExercise 1\nWrite a function that returns the number\
    \ of times a substring appears in a given string.", "    \"\"\"\n    Create a\
    \ function that returns true if the last character\n    of a given string is an\
    \ alphabetical character and is not\n    a part of a word, and false otherwise.\n\
    \    Note: \"word\" is a group of characters separated by space.", "    if txt.length\
    \ == 0\n        return false\n    \n    chars = txt.split(' ')\n    \n    last_char\
    \ = chars[txt.length-1]\n    if last_char == chars[txt.length-1] && chars[txt.length-1]\
    \ != \" \" \n        return true\n    else if last_char == chars[txt.length-1]\
    \ && chars[txt.length-1] == \" \"\n        return false\n    end\nend", "    \n\
    \    if txt.length == 1\n        false\n    else\n        val :: String = txt.last\n\
    \        val contains \"A\"\n        val contains \"B\"\n        val contains\
    \ \"C\"\n        val contains \"D\"\n        val contains \"E\"\n        val contains\
    \ \"F\"\n        val contains \"G\"\n        val contains \"H\"\n        val contains\
    \ \"I\"\n        val contains \"J\"\n        val contains \"K\"\n        val contains\
    \ \"L\"\n        val contains \"M\"\n        val contains \"N\"\n        val contains\
    \ \"O\"\n        val contains \"P\"\n        val contains \"Q\"\n        val contains\
    \ \"R\"\n        val contains \"S\"\n        val contains \"T\"\n        val contains\
    \ \"U\"\n        val contains \"V\"\n        val contains \"W\"\n        val contains\
    \ \"X\"\n        val contains \"Y\"\n        val contains \"Z\"\n        true\n\
    end\n</cell>\n<text>\nWrite a function named has_multiple_letters that takes a\
    \ string and returns true if that string has more than one alphabetical character\
    \ and returns false if that string has only one alphabetical character. Note:\
    \ this function is not case sensitive.", "    if txt.length == 0\n        false\n\
    \    else\n        txt.lastchar isLetter\nend", '    return check_if_last_char_is_a_letter(txt.split("
    ")[txt.count(" ")-1])', "    if len(txt) == 0 \n        return false \n    else\
    \ \n        txt[end-1] in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" \n        return false\
    \ \nend", "    return (last(txt) >= 'a' && last(txt) <= 'z')\nend\n</code>\nThis\
    \ function checks wether or not the last character of the string is a letter.\
    \ Obviously, it can be extended to check for capital letters.\n<|/ a tags=string,julia\
    \ |>\n<| c |>\nThat is not true for non-English alphabets. Try `last(\"\u044F\u0431\
    \u043B\u043E\u043A\u043E\")`\n<|/ c |>\n<| c |>\nThanks, I missed that. Corrected\
    \ the answer.\n<|/ c |>\n<| a tags=string,julia dscore=2 |>\nFor completeness\
    \ and completeness, the solution using string processing functions:\n<code>",
  "    txt != \"\" && txt[length(txt) - 1] == \" \" && length(txt) >= 2 && txt[length(txt)\
    \ - 2] != \" \" \nend\n</cell>\n<text>\nExercise 2\nWrite a function that removes\
    \ repeated characters from a string. The function will take in a string of letters\
    \ (lower case only) and return the string with repeated characters removed (e.g.,\
    \ \"apple\" would become \"ple\").", "    if is_empty(txt)\n        return false\n\
    \    txt.sub!(\" \", \"\")\n    return txt.ends_with_char(\"A\") || txt.ends_with_char(\"\
    B\") || txt.ends_with_char(\"C\") || txt.ends_with_char(\"D\") || txt.ends_with_char(\"\
    E\") || txt.ends_with_char(\"F\") || txt.ends_with_char(\"G\") || txt.ends_with_char(\"\
    H\") || txt.ends_with_char(\"I\") || txt.ends_with_char(\"J\") || txt.ends_with_char(\"\
    K\") || txt.ends_with_char(\"L\") || txt.ends_with_char(\"M\") || txt.ends_with_char(\"\
    N\") || txt.ends_with_char(\"O\") || txt.ends_with_char(\"P\") || txt.ends_with_char(\"\
    Q\") || txt.ends_with_char(\"R\") || txt.ends_with_char(\"S\") || txt.ends_with_char(\"\
    T\") || txt.ends_with_char(\"U\") || txt.ends_with_char(\"V\") || txt.ends_with_char(\"\
    W\") || txt.ends_with_char(\"X\") || txt.ends_with_char(\"Y\") || txt.ends_with_char(\"\
    Z\")\nend", "    lastChar = txt[length(txt)-1]\n    isLetter = (lastChar >= 'a'\
    \ && lastChar <= 'z') || (lastChar >= 'A' && lastChar <= 'Z')\n    return !(isLetter)\n\
    end # check_if_last_char_is_a_letter()\n</cell>\n<cell>", "    if txt[txt.length\
    \ -1] == 'e'\n            || txt[txt.length -1] == 'a'\n            || txt[txt.length\
    \ -1] == 'o'\n            || txt[txt.length -1] == 'i'\n            || txt[txt.length\
    \ -1] == 'n'\n            || txt[txt.length -1] == 'P'\n            || txt[txt.length\
    \ -1] == 'p'\n            || txt[txt.length -1] == 'G'\n            || txt[txt.length\
    \ -1] == 'G'\n            || txt[txt.length -1] == 'S'\n            || txt[txt.length\
    \ -1] == 's'\n            || txt[txt.length -1] == 'B'\n            || txt[txt.length\
    \ -1] == 'b'\n            || txt[txt.length -1] == 'I'\n            || txt[txt.length\
    \ -1] == 'i'\n            || txt[txt.length -1] == 'O'\n            || txt[txt.length\
    \ -1] == 'o'\n            || txt[txt.length -1] == 'R'\n            || txt[txt.length\
    \ -1] == 'r'\n            || txt[txt.length -1] == 'S'\n            || txt[txt.length\
    \ -1] == 's'\n            || txt[txt.length -1] == 'T'\n            || txt[txt.length\
    \ -1] == 't'\n            || txt[txt.length -1] == 'U'\n            || txt[txt.length\
    \ -1] == 'u'\n            || txt[txt.length -1] == 'V'\n            || txt[txt.length\
    \ -1] == 'v'\n            || txt[txt.length -1] == 'D'\n            || txt[txt.length\
    \ -1] == 'd'\n            || txt[txt.length -1] == 'T'\n            || txt[txt.length\
    \ -1] == 't'\n            || txt[txt.length -1] == 'C'\n            || txt[txt.length\
    \ -1] == 'c'\n            || txt[txt.length -1] == 'M'\n            || txt[txt.length\
    \ -1] == 'm'\n            || txt[txt.length -1] == 'P'\n            || txt[txt.length\
    \ -1] == 'p'\n            || txt[txt.length -1] == 'G'\n            || txt[txt.length\
    \ -1] == 'g'\n            || txt[txt.length -1] == 'H'\n            || txt[txt.length\
    \ -1] == 'h'\n            || txt[txt.length -1] == 'M'\n            || txt[txt.length\
    \ -1] == 'm'\n            || txt[txt.length -1] == 'H'", "    if txt == \"\"\n\
    \        return false\n    else\n        return (txt.split(\" \")[length(txt |>\
    \ split(\" \"))] |> last() |> is_letter) != true\n    end\nend", "    \n    txt.split(\"\
    \ \")[end-1].match('[a-zA-Z]')\nend\n</cell>\n<code language=julia-1.0>", "  \
    \  str = txt\n    if str == \"\" || str == \" \" || str == \"\\t\"\n        return\
    \ false\n    ends_with_letter = str[end-1] == ' ' || str[end-1] == ',' || str[end-1]\
    \ == '.' || str[end-1] == '?' || str[end-1] == '!' || str[end-1] == '$' || str[end-1]\
    \ == '%' || str[end-1] == '^' || str[end-1] == '&' || str[end-1] == '*' || str[end-1]\
    \ == '(' || str[end-1] == ')' || str[end-1] == '+' || str[end-1] == '-' || str[end-1]\
    \ == '=' || str[end-1] == '|' || str[end-1] == '[' || str[end-1] == ']' || str[end-1]\
    \ == '{' || str[end-1] == '}' || str[end-1] == '~' || str[end-1] == ':'\n    if\
    \ ends_with_letter\n        return true\n    ends_with_letter = str[end-1] ==\
    \ ' ' || str[end-1] == ',' || str[end-1] == '.' || str[end-1] == '?' || str[end-1]\
    \ == '!' || str[end-1] == '$' || str[end-1] == '%' || str[end-1] == '^' || str[end-1]\
    \ == '&' || str[end-1] == '*' || str[end-1] == '(' || str[end-1] == ')' || str[end-1]\
    \ == '+' || str[end-1] == '-' || str[end-1] == '=' || str[end-1] == '|' || str[end-1]\
    \ == '[' || str[end-1] == ']' || str[end-1] == '{' || str[end-1] == '}' || str[end-1]\
    \ == '~'\n    if ends_with_letter\n        return true\n    ends_with_letter =\
    \ str[end-1] == ' ' || str[end-1] == ',' || str[end-1] == '.' || str[end-1] ==\
    \ '?' || str[end-1] == '!' || str[end-1] == '$' || str[end-1] == '%' || str[end-1]\
    \ == '^' || str[end-1] == '&' || str[end-1] == '*' || str[end-1] == '(' || str[end-1]\
    \ == ')' || str[end-1] == '+' || str[end-1] == '-' || str[end-1] == '=' || str[end-1]\
    \ == '|' || str[end-1] == '[' || str[end-1] == ']' || str[end-1] == '{' || str[end-1]\
    \ == '}' || str[end-1] == '~'\n    if ends_with_letter\n        return true\n\
    \    ends_with_letter = str", "    \n    if txt.length() <= 1\n        return\
    \ false\n    end1 = txt.length()-1\n    txt = txt.slice(end1)\n    for i in \"\
    abcdefghijklmnopqrstuvwxyz\" \n        if i==txt.last \n            return false\n\
    \    end2 = txt.length()-1\n    txt = txt.slice(end2)\n    for i in \"abcdefghijklmnopqrstuvwxyz\"\
    \ \n        if i==txt.last \n            return false\n    end3 = txt.length()-1\n\
    \    txt = txt.slice(end3)\n    for i in \"abcdefghijklmnopqrstuvwxyz\" \n   \
    \     if i==txt.last \n            return false\n    return true\nend\n</cell>\n\
    <code language=julia-1.0>", "    \n    if txt.is_empty() \n        then return\
    \ false\n    \n    txt |> txt |> txt.chars |> List.length |> is_last |> not",
  "    if txt == \"\" || txt == \"\\n\" \n    then return false\n    else \n     \
    \   return (txt.endswith \" $\") || (txt.endswith \" !\") || (txt.endswith \"\
    \ .\")\n    end\nend\n\"\"\"\n    Create a function that returns true if the last\
    \ character \n    of a given string is a number and is NOT a part of a word, and\
    \ false otherwise.\n    Note: \"word\" is a group of characters separated by space.",
  "    \"\"\"\n    Create a function that returns true if the last character\n   \
    \ of a given string is an alphabetical character and is not\n    a part of a word,\
    \ and false otherwise.\n    Note: \"word\" is a group of characters separated\
    \ by space.", "    return (txt[length(txt)-1] \u2208 letters) and not( txt[length(txt)-1]\
    \ \u2208 word)\nend\n</code>\n<|/ a |>\n<| a dscore=0 tags=julia,string |>\nThis\
    \ can be achieved using regex. Here's the code:\n<code>\nusing Regex", "    txt\
    \ = txt[end]\n    if txt.isalpha()\n        false\n    else\n        true\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\nI didn't want to have to import anything;\
    \ this is my solution. \n<code>\ndef last_char_is_a_letter(string: str) -> bool:\n\
    \    return string[-1].isalpha()\n</code>\n<|/ a tags=julia,string |>\n<| a dscore=0\
    \ |>\nTo add to Jakub's answer:\n<code>\njulia> function last_char_is_a_letter(s)\n\
    \           return s[end] == 'a'\n       end\nlast_char_is_a_letter (generic function\
    \ with 1 method)", "    local result=false\n    for w in word(txt)\n        do\n\
    \            local w=word(w)\n            local l=length(w)-1\n            if\
    \ w[l]==txt[l] \n                and w[l]!=\" \" \n                and w[l]!=\"\
    \"\n                and w[l]!=\"_\" \n            then\n                true\n\
    \            else\n                result=true\n                break\n      \
    \      end\n        end\n    end\n    return result\nend\n</code>\nThe function\
    \ works well for single words but when it is used on whole paragraph, it returns\
    \ false, and not true as I want.\nCould you please help me?\n<|/ q tags=julia,regex\
    \ dscore=2 |>\n<| a dscore=1 |>\nThe regex can be modified as\n<code>\nr\"\\b[A-Za-z][A-Za-z]$\"\
    \n</code>\nThe \\b makes sure there is a word boundary in front and $ is end of\
    \ string. [A-Za-z] matches 1 char A-Za-z and + matches 1 or more of them in one\
    \ go.\nYou may also use \\w (word characters) instead of [A-Za-z]. \\w does not\
    \ match underscores (_), you may add them to the character class like\n<code>\n\
    r\"\\b[A-Za-z\\w_]+$\"\n</code>\n<|/ a tags=julia,regex |>\n<| a tags=julia,regex\
    \ |>\nIf your text is in a file, you can use readline for that as well.\n<code>\n\
    julia> readline(open(\"filename.txt\"))\n\"Apple pie is good\"\n</code>\nOr if\
    \ your text is in a string variable:\n<code>\njulia> txt = \"Apple pie is good\"\
    \n\"Apple pie is good\"", "    if txt.is_empty\n        false\n    elseif txt.length\
    \ == 1\n        true\n    else\n        txt[txt.length-1] == txt[txt.length-2]\n\
    \    end\nend", "    \n    if is_empty(txt)\n        false\n    else\n       \
    \ txt[length(txt - 1)] \u2209 ' a-z'\n    end\nend\n</cell>\n<text>\nExercise:\
    \ Write a function that takes a string and returns true if the last character\
    \ is a letter or is a number", "    if txt == \"\"\n        false\n    else\n\
    \        txt.ends_with?(\" \")\n    end\nend\n\"\"\"\n    Create a function that\
    \ returns true if the last character\n    of a given string is a digit, and false\
    \ otherwise.\n    Note: \"digit\" is a group of characters separated by space.",
  "    local txt = txt\n    return txt[txt.length - 1] ~= \" \" &&\n        check_if_last_char_is_a_letter(txt.sub(txt.length\
    \ - 1, 1))\nend\n</cell>\n<cell>\n\"\"\"\n    Create a function that returns true\
    \ if the last character\n    of a given string is a letter or a part of a word,\
    \ and false\n    otherwise.", "    txt.length >= 1 && txt[txt.length-1] == \"\
    \ \"\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    Create a function that\
    \ returns true if the last character\n    of a given string is a vowel and is\
    \ not part of a word,\n    and false otherwise.\n    Note: \"word\" is a group\
    \ of characters separated by space.", "    return txt[txt.length()-1] !~ /^[a-zA-Z]+$/\n\
    end", "    txt = txt\n    letters = split(txt, \" \")\n    last_letter = letters[end]\n\
    \    is_a_letter = is_letter(last_letter)\n    return !is_a_letter\nend\n</cell>\n\
    <code language=julia-1.4>\n\"\"\"\n    Create a function that returns a string\
    \ \"x\" repeated \"n\" times,\n    if n is positive, or \"y\" repeated \"n\" times\
    \ otherwise.\n    Examples:\n    >>> repeat_if_positive(3, \"x\")\n    \"xxx\"\
    \n    >>> repeat_if_positive(-2, \"x\")\n    \"xxxx\"\n    >>> repeat_if_positive(3,\
    \ \"y\")\n    \"yyy\"\n    >>> repeat_if_positive(0, \"y\")\n    \"y\"\n    \"\
    \"\"", "    if txt.length == 0\n        false\n    else if txt.lastchar.isalpha\n\
    \        false\n    else if txt.lastchar.isspace\n        true\n    else\n   \
    \     false\nend", "        \n    word = txt[length(txt - 1)]\n    return (isalpha(word)\
    \ == true) and (word !~= \" \")\nend", "    \n    if txt !=\"\"\n    then txt[end-1]==\"\
    \ \" || txt[end-1]==\"\\n\"\n    else false\n    end\nend\n</cell>\n<cell>\n\"\
    \"\"\n    Create a function that counts the number of times a given word\n   \
    \ occurs in a given string.\n    Ignore letter case.\n    Examples:\n    >>> count_words_in_string(\"\
    apple pi e apple pie applepie\", \"apple\")\n    2\n    >>> count_words_in_string(\"\
    apple pie applepie\", \"apple\")\n    1\n    >>> count_words_in_string(\"apple\
    \ pie applepie\", \"pie\")\n    0\n    \"\"\"", "    txt = txt.strip(\"_\")\n\
    \    if txt.ends_with(_)\n        true\n    else\n        false\n    end\nend",
  "    word_split::Array{String} = split(txt)\n    len::Int = length(word_split)\n\
    \    if len == 0\n        return false\n    word::String = word_split[len-1]\n\
    \    word_split[len] = \"\"\n    for letter in word\n        if letter !=\"a\"\
    \n            return false\n    end\n    return true\nend", "\"\"\"\n    Create\
    \ a function that returns true if the last character\n    of a given string is\
    \ an alphabetical character and is not\n    a part of a word, and false otherwise.\n\
    \    Note: \"word\" is a group of characters separated by space.", "    txt =txt.split(\"\
    \ \")\n    let lastChar = txt[length(txt)-1]\n    for char in lastChar\n     \
    \   if (char isalpha) == false\n            return false\n    return true\nend\n\
    </cell>\n<text>\ncheck_if_last_char_is_a_letter(\"apple pie\")\nfalse", "    if\
    \ txt == \"\"\n        false\n    else\n        if txt[length(txt)] != \" \"\n\
    \            false\n        else\n            if has_letter?(txt[length(txt) -\
    \ 1])\n                true\n            else\n                false\n       \
    \ end\n    end\nend\n</cell>\n<code language=julia-1.6>\n\"\"\"\n    Create a\
    \ function that returns a new string with\n    all spaces removed, and then returns\
    \ true if\n    the string length is 0, or false otherwise.\n    \n    Examples:\n\
    \    >>> remove_spaces_function(\"\")\n    \"\"\n    >>> remove_spaces_function(\"\
    \     \")\n    \"  \"\n    \"\"\"", '    return txt[-1].isalpha() == true', " \
    \   for char in txt[txt.length()-1,txt.length()-1:txt.length()]\n        if char\
    \ !~ /\\pL/ && char !~ /\\pM/ && char !~ /\\pN/ && char !~ /\\pP/ && char !~ /\\\
    pC/ && char !~ /\\pZ/\n            return false\n        end\n    return true\n\
    end\n\"\"\"\n    Create a function that returns true if the first character\n\
    \    of a given string is an alphabetical character and is not\n    a part of\
    \ a word, and false otherwise.\n    Note: \"word\" is a group of characters separated\
    \ by space.", "    lastChar = txt[length(txt)-1]\n    if lastChar !~ regex_alphabet\n\
    \       return false\n    end\n    return true\nend\n</cell>\n<text>\nWrite a\
    \ function that returns true if the last character is whitespace, and false otherwise.\n\
    Examples:\ncheck_if_last_char_is whitespace(\"apple pi e \")\nfalse\ncheck_if_last_char_is\
    \ whitespace(\"apple pi e \")\ntrue", "    if txt.ends_with?(\" \")\n        false\n\
    \    else\n        txt.ends_with?(\" a\") || txt.ends_with?(\" e\") || txt.ends_with?(\"\
    \ i\") || txt.ends_with?(\" o\") || txt.ends_with?(\" u\")\n    end\nend\n</cell>\n\
    <cell>\ntest_str = \"apple pie e pie\"\ncheck_if_last_char_is_a_letter(test_str)\n\
    </cell>\n<text>\n3.10 Checking for digits\nCreate a function that returns true\
    \ if the last character of a given string is a digit, and false otherwise.", " \
    \   return txt.end.characters[txt.end.length-1] != \" \"\nend", "    if !is_last_char_in_a_word(txt)\n\
    \        return false\n    else\n        return txt[length(txt)] != \" \"\n  \
    \  end\nend\n</cell>\n<code language=julia-1.6>", "    \"\"\"\n    Create a function\
    \ that returns true if the last character\n    of a given string is an alphabetical\
    \ character and is not\n    a part of a word, and false otherwise.\n    Note:\
    \ \"word\" is a group of characters separated by space.", "    txt_len = length(txt)\n\
    \    if txt_len == 0\n        false\n    elseif txt[txt_len-1] in [\"A\", \"B\"\
    , \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\"\
    , \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\"\
    , \"Y\", \"Z\"]\n        true\n    else\n        false\n    end\nend", "    if\
    \ is_empty(txt)\n        return false\n    else if txt.length == 1 && isalpha(txt[0])\n\
    \        return false\n    else\n        return true\nend\n</cell>\n<code language=julia-1.5>",
  "    return txt[-1].isalpha()\nend # end of check_if_last_char_is_a_letter", " \
    \   \n    if txt.length == 0 || txt.chars().last().is_alphabetic()\n        false\n\
    \    else\n        true\n    end\nend\n</code>\nThis function works just fine.\n\
    I then wanted to make a list of all the words in the string, so I rewrote the\
    \ function to use map to turn the text into a list of words:\n<code>", "   let\
    \ words = txt.split(' ')\n   let lastword = words[words.length-1]\n   let lastchar::String\
    \ = lastword[lastword.length-1]\n   return (lastchar.isUppercase || lastchar.isLowercase)\
    \ && (lastchar.isAlpha || lastchar.isDigit)\nend\n</cell>\n<text>\nExercise 6:\
    \ Write a function that will return a boolean value if the last character of a\
    \ given string is a capital letter, and false otherwise.", "    words = split(txt,\
    \ \" \")\n    last_word = words[end]\n    if last_char /= last_word\n        false\n\
    \    else\n        true\n</code>\n<|/ a tags=string,julia |>\n<| c |>\nThanks\
    \ for the help! I was able to adapt your solution to my code and it works great!\
    \ One question: why do you recommend `@inbounds` and `@inbounds`?\n<|/ c |>\n\
    <| c |>\nI read about `@inbounds` and `@inbounds` in the Julia Documentation,\
    \ but it looks like they only affect functions in the same scope. Thus we can't\
    \ use `@inbounds` with methods. Is that true?\n<|/ c |>\n<| c |>\n`@inbounds`\
    \ allows us to make `begin` blocks work with methods as well; for example, using\
    \ `@inbounds` with `@inbounds` inside a `begin` block would allow us to define\
    \ `f(x, y) = x + y` and `g(x, y, z) begin return f(x, y); end` to define `g` using\
    \ methods and `begin` blocks.\n<|/ c |>\n<| a |>\nFor Julia 1.6, a more concise\
    \ method of doing this is:\n<code>", "    \n    txt = txt.split(\" \")\n    \n\
    \    letter = txt.last()\n    \n    \n    if letter.isalpha() == True:\n     \
    \   return letter.isalpha()\n    else:\n        return False\nend\n</cell>\n<code\
    \ language=julia-1.6>", "    if txt.length==0 \n        false\n    else \n   \
    \     txt[length(txt)-1] \u2209 \" ,.;:!-?/ \" \nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\n    Create a function that returns true if the last character\n    of\
    \ a given string is a vowel and is NOT a part of a word,\n    and false otherwise.\n\
    \    Note: \"word\" is a group of characters separated by space.", "\"\"\"\n \
    \   Creates a function that checks whether the last character of a string\n  \
    \  is an alphabetical character and not a part of a word.\n    Note: \"word\"\
    \ is a group of characters separated by space.", "    local i=txt:len()\n    while\
    \ i > 0 do\n        if txt:sub(i-1,i)==\" \" then\n            i=txt:len()\n \
    \       else\n            return true\n        end\n    end\n    return false\n\
    end\n</cell>\n<cell>\n\"\"\"\n    Create a function that returns true if the last\
    \ character\n    of a given string is a number and is not\n    a part of a word,\
    \ and false otherwise.\n    Note: \"word\" is a group of characters separated\
    \ by space.", "    txt=txt.rstrip()\n    let=txt.rpartition(\" \")[2]\n    let=let.rpartition(\"\
    \ \")[2]\n    let=let.split(\" \")[1]\n    let=let.replace(\"\\n\",\"\")\n   \
    \ if let in letters:\n        return false\n    else:\n        return true\n\"\
    \"\"\n    Create a function that removes punctuation marks and converts the words\
    \ to lower case.\n    \n    Examples:\n    >>> remove_symbols(\"apple, pie, apple,\
    \ pi, e\")\n    apple, pie, applepi, e\n    >>> remove_symbols(\"apple pie applepi\
    \ e\")\n    apple pie applepie e\n    \"\"\"", "    if txt.length == 0 || txt.is_empty()\n\
    \        return false\n    last_char = txt.last()\n    return last_char !~ /\\\
    w$/\nend\n</cell>\n<text>\nNext, let's take a look at another function that you\
    \ might want to use: count_words.", "    \"\"\"\n    \"\"\"\n    if txt.len ==\
    \ 0 then \n        false\n    else\n        if txt[txt.len - 1] in \"aeiouAEIOU\"\
    \ \n        then \n            true\n        else\n            false\n       \
    \ end\n    end\nend\n</cell>\n<cell>", "    true\nend", "    \"\"\"Check if last\
    \ character of string is a letter and is not part of a word\"\"\"\n    if (txt.len\
    \ > 0) and (txt.last.is_alpha) and (txt.last.isalnum()) and (not txt.ends_with(\"\
    \ \"))\n        return true\n    else \n        return false\nend\n</cell>\n<code\
    \ language=julia-1.0>\n\"\"\"\n    Create a function that returns true if the\
    \ last character\n    of a given string is a decimal digit and is not\n    a part\
    \ of a word, and false otherwise.\n    Note: \"word\" is a group of characters\
    \ separated by space.", "    if length(txt) == 0 || length(txt) > length(txt[-1])\n\
    \        return false\n    else\n        return txt[length(txt)-1] \u2209 [\"\
    A\",\"a\",\"B\",\"b\",\"C\",\"c\",\"D\",\"d\",\"E\",\"e\",\"F\",\"f\",\"G\",\"\
    g\",\"H\",\"h\",\n            \"I\",\"i\",\"J\",\"j\",\"K\",\"k\",\"L\",\"l\"\
    ,\"M\",\"m\",\"N\",\"n\",\"O\",\"o\",\"P\",\"p\",\"Q\",\"q\",\"R\",\"r\",\"S\"\
    ,\n            \"s\",\"T\",\"t\",\"U\",\"u\",\"V\",\"v\",\"W\",\"w\",\"X\",\"\
    x\",\"Y\",\"y\",\"Z\",\"z\",\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\n\
    \            \"8\",\"9\",\"_\"]\nend", "  local last_char = txt:match(\"(.-)$\"\
    )[1]\n  return last_char:match(\"^[a-z]+$\")\nend", "    txt.last.chars.last.is_letter\
    \ != true || txt.last.chars.length != 1\nend\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"\n    Create a function that returns true if the last character\n    of\
    \ a given string is a numeric character and is not\n    a part of a word, and\
    \ false otherwise.\n    Note: \"word\" is a group of characters separated by space.",
  "    txt.chars().last() |> to_string()\n    |> String.is_letter\n    |> Bool\nend",
  "    let words = split(txt, \" \")\n    if length(words) > 0 && last(words) ~= \"\
    \ \" \n        && words[length(words) - 1] != \" \" \n        && last(words) !~\
    \ /^[A-Z]/\n    then true \n    else false\nend\n</code>\nThe split(txt, \" \"\
    ) splits the string by spaces, and last(words) is equivalent to words[length(words)\
    \ - 1]. last(words) !~ /^[A-Z]/ checks that last character is not an upper case,\
    \ and words[length(words) - 1] != \" \" checks that last character is not space.\
    \ \nYou can then use these to build a new function:\n<code>", "    let splits\
    \ = split(txt, \" \")\n    let lastChar = splits.last()\n    \n    if lastChar\
    \ != \"\" && !ends_with(lastChar, \"a\") && !ends_with(lastChar, \"e\") && !ends_with(lastChar,\
    \ \"i\") && !ends_with(lastChar, \"o\") && !ends_with(lastChar, \"u\") && !ends_with(lastChar,\
    \ \"y\")\n        return true\n    else\n        return false\n    end\nend\n\
    </code>\n<|/ a dscore=1 tags=julia,string |>\n<| a |>\nAnother simple function\
    \ using regex:\n<code>\nusing Test\nusing RegexpFunctions", "    \" Return True\
    \ if the last character of a given string is an alphabetical character and is\
    \ not\"\n    return txt != \"\" && txt.chars.last != \" \" && txt.chars.last !~\
    \ /\\w/\nend \n</cell>\n<code language=julia-1.5>\n\"\"\"\n    Create a function\
    \ that returns a list of words from a given\n    string.\n    Note: This code\
    \ will remove all the punctuation marks from the \n    string first.\n    \"\"\
    \"", "    local i::Int64 = txt.length - 1\n    while i > 0 and txt[i] == '' do\
    \ i=i-1 end\n    local last::String = txt[i]\n    i = i-1\n    while i > 0 and\
    \ txt[i] ~= '' do i=i-1 end\n    local lastChar::String = txt[i]\n    local isLetter::Bool\
    \ = lastChar ~= '' && !lastChar ~= '\\n'\n    return isLetter\nend\n\"\"\"\n \
    \   Create a function that returns true if the last character\n    of a given\
    \ string is a number and is not\n    a part of a word, and false otherwise.\n\
    \    Note: \"word\" is a group of characters separated by space.", "    \n   \
    \ if txt.head == \"\"\n        return false\n    else if txt.head[length-1] in\
    \ string.ascii_lowercase\n        false\n    else if txt.head[length-1] in string.ascii_uppercase\n\
    \        false\n    else\n        true\nend\n</cell>\n<text>\nExercise 9\nCreate\
    \ a function called check_if_last_char_is_digit() that returns true if the last\
    \ character of a given string is a digit, and false otherwise.", "    return (last(txt)\
    \ == letters(txt))\nend\n</cell>\n<code language=julia-0.6>\n\"\"\"\n    Create\
    \ a function that returns true if the last character\n    of a given string is\
    \ a number, and is not\n    a part of a word, and false otherwise.\n    Note:\
    \ \"word\" is a group of characters separated by space.", "    return (txt[length\
    \ (txt) - 1] \u2209 [\"a\", \"e\", \"i\", \"o\", \"u\"]) == false\nend\n</cell>\n\
    <code language=julia-1.0>\n\"\"\"\n    Create a function that returns true if\
    \ the last character\n    of a given string is an alphabetical character and is\
    \ not\n    a part of a word, and false otherwise.\n    Note: \"word\" is a group\
    \ of characters separated by space.", "    \"\"\"\n    Create a function that\
    \ returns true if the last character\n    of a given string is an alphabetical\
    \ character and is not\n    a part of a word, and false otherwise.\n    Note:\
    \ \"word\" is a group of characters separated by space.", "    \n    # your code\
    \ here\n    \nend", "    txt = txt.split(\" \")\n    txt[end-1].isalpha()\n  \
    \  txt[end-1]!=\" \"\nend\n</code>\n<|/ a |>\n<| a |>\nMy solution\n<code>", " \
    \       !check_if_last_char_is_a_letter(txt[1:end-1]) # return false if first\
    \ char is non letter\n        (isalpha(txt[end]) and !(isspace(txt[end]))) # return\
    \ true if last char is a letter or space but not the first char\nend\n</cell>\n\
    <code language=julia-1.5>", "    txt match {\n        case \"\" => false\n   \
    \     case letter | Nil => letter >= 'a' && letter <= 'z'\n        case txt =>\
    \ false\n    }\nend\n</code>\n<|/ a dscore=2 tags=julia,string |>\n<| c |>\nYou\
    \ can avoid using string slicing in your function by using `chars` and then checking\
    \ if the last character is `! = #` using `last` instead: `! = last(string.chars)`.\n\
    <|/ c |>\n<| c |>\nThat's a nice improvement!\n<|/ c |>\n<| a dscore=2 tags=julia,string\
    \ |>\nUse a pattern that matches the rest of the string:\n<code>\njulia> function\
    \ check_if_last_char_is_a_letter(txt::String)\n       txt[end-1] >= 'a' && txt[end-1]\
    \ <= 'z'\n       end\ncheck_if_last_char_is_a_letter (generic function with 1\
    \ method)", "    if len(txt) < 1 \n        return false\n    letter = txt[end]\n\
    \    return !is_letter(letter)\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis\
    \ would not work for \"Mary had a little lamb Little lamb\"\n<|/ c |>\n<| c |>\n\
    I see what you meant now, I'll edit my answer to include this\n<|/ c |>\n<| a\
    \ tags=julia,string |>\nHere is a short and efficient solution, using regular\
    \ expressions.\nThe idea is to first convert your input string to lower case (since\
    \ you want to allow the user to input strings starting and ending with different\
    \ case characters), then to replace all non-alphabetic characters with empty strings,\
    \ then to remove the space at the end of the string (if necessary).\nThe result\
    \ then is the remaining string minus the space at the end (if there is one).\n\
    <code>\njulia> s = \"apple pi e\"\n\"apple pi e\"", "        if txt == \"\" ||\
    \ txt[-1] != \" \" || txt[length(txt - 1)] != \" \" \n        then return false\n\
    \        else return true\n        end\nend\n</code>\n<|/ a dscore=2 tags=julia,string,split\
    \ |>\n<| a tags=julia,string,split |>\nOne approach is to use regular expressions\
    \ to split the string into words and test if the last element of the resulting\
    \ vector is a letter:\n<code>\njulia> str=\"a b c d\";\n\"a b c d\"", "      \
    \  char_last_char = txt[txt.length -1]\n        word_last_char = txt.split(\"\
    \ \")[txt.split.length-1]\n        return char_last_char.isalpha() == true and\
    \ char_last_char !~ word_last_char \nend\n</cell>\n<code language=julia-0.5>",
  "    return txt[txt.length-1] != ' ' && txt[txt.length-1] != '.' \nend\n</cell>\n\
    <code language=julia-1.6>", "    return txt[length(txt)-1] \u2209 \"aeiouAEIOU\"\
    \nend function\n</code>\n<|/ a dscore=1 |>\n<| c |>\nNote that `iot` is `Int`,\
    \ while `length` is `Int`, so you probably meant `if txt[length(txt - 1)] \u2209\
    \ \"aeiouAEIOU\"`.\n<|/ c |>\n<| c |>\nI didn't know that Int is a subset of String.\
    \ Thanks!\n<|/ c |>\n<| a tags=julia |>\nOne more solution:\n<code>\njulia> function\
    \ is_alpha(x::String)\n         return !isempty(regexprep(Regex(\"\\p{L}+$\"),\
    \ \"$\", \"_\"))\n       end\nis_alpha (generic function with 1 method)", "  \
    \  return txt.last_char() in ('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\
    \ 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z')\n\
    end\n</cell>\n<code language=julia-0.6>\n\"\"\"\n    Create a function that returns\
    \ the first character of a given string.", "    if txt==\"\"\n        return false\n\
    \    else\n        let txtLen = length(txt)\n        if txt[txtLen] in alphabet\n\
    \            and (txtLen != 1 || txt[txtLen-1] in alphabet ~= true)\n        return\
    \ true\n    end\nend\n</cell>\n<code language=julia-1.5>\n# Test it\n@time for\
    \ _ in 1:10^5\n        txt=\"apple pie\"\n        txtLen = length(txt)\n     \
    \   if txt[txtLen] in alphabet\n            and (txtLen != 1 || txt[txtLen-1]\
    \ in alphabet ~= true)\n        end\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\n    Create a function that returns true if the last character\n    of\
    \ a given string is an alphabetical character and is not\n    a part of a word,\
    \ and false otherwise.\n    Note: \"word\" is a group of characters separated\
    \ by space.", "    if txt == \"\"\n        return false\n    \n    if txt.length\
    \ == 1\n        return true\n    \n    lastchar::String = txt.last\n    if lastchar\
    \ == \" \" \n        return false\n    \n    if lastchar !~ Regex(\"^[a-z]+$\"\
    )\n        return false\n    \n    return true\n    \nend", "    return txt.ends_with?(\"\
    \ \") && txt.chars.last.matches(\"[A-Za-z]\")\nend", "    if txt.length==0 \n\
    \        false\n    else\n        if txt.last==\" \" \n            false\n   \
    \     else\n            char::String = txt.last\n            if isalpha(char)\
    \ \n                true\n            else\n                false\n        end\n\
    \    end\nend\n</code>\n<|/ a tags=julia |>\n<| a tags=julia |>\nThe easiest solution\
    \ is to use a regular expression:\n<code>\njulia> string = \"apple pie\"\n\"apple\
    \ pie\"", "    split_by_space = txt.split(\" \")\n    if split_by_space[split_by_space.length-1].is_letter\n\
    \        else false\n    end\nend\n</code>\n<|/ a |>\n<| c |>\nThanks! This is\
    \ exactly what I was looking for!\n<|/ c |>\n<| c |>\nHi, I was wondering if you\
    \ could help me understand this piece of code? ", "    if txt.length == 0 return\
    \ false\n    \n    let first_char::Char = txt[txt.length-1]\n    \n    // is this\
    \ the first character of a word\n    if first_char.isLetter() return true\n  \
    \  \n    // is this the first character of a word\n    if first_char.isSpace()\
    \ return false\n    \n    return false\n    \"\"\"", "    if txt.is_empty() \n\
    \        false\n    else \n        let l = txt.len()-1\n        let x = txt.chars(l).last\n\
    \        if x in ['A'..'Z']\n            true\n        else\n            false\n\
    end", "    \" function to check last character is alphabet and not a part of a\
    \ word \"\n    if txt == \"\" \n        true\n    else\n        if txt.ends_with?\
    \ \" \" and txt.slice(-1, 1) == 'a'\n            true\n        else\n        \
    \    false\n        end\n    end\nend\n</cell>\n<code language=julia-1.4>\n\"\"\
    \"\n    Create a function that returns true if the last character\n    of a given\
    \ string is an alphabetical character and is not\n    a part of a word, and false\
    \ otherwise.\n    Note: \"word\" is a group of characters separated by space.",
  "    if txt.last == \" \" || txt.last == \"\"\n    else txt.last.isalpha\nend",
  "    words = txt.split(\" \")\n    for w in words\n        if w[end-1] in \"abcdefghijklmnopqrstuvwxyz\"\
    \ \n            return false\n        end\n    return true\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThanks, this looks like a good solution. I'll look into\
    \ implementing it. My first time using Julia, so it's still a little confusing.\n\
    <|/ c |>\n<| c |>\nI took your code and updated it to allow any number of words,\
    \ it took me a little while, but I've gotten it working and updated my original\
    \ question with the final code. Thanks!\n<|/ c |>\n<| a tags=julia |>\nHere is\
    \ another solution using string functions and regular expressions (as you said\
    \ in the comment that you are very new to Julia).\n<code>", "    last <- txt\n\
    \    length(last) == 1 && last in string.letters\nend\n</code>\n<|/ a |>\n<| c\
    \ |>\nHi Anthony, I have done a quick edit to your answer to improve it a bit\
    \ - feel free to roll it back if you don't like it! :)\n<|/ c |>\n<| a |>\nHere\
    \ are some solutions (I'm also using Julia 1.0.1) using Iterators.jl package (thanks\
    \ to for the pointer):\n<code>\nusing Iterators\nusing Printf", "\"\"\"\n    Create\
    \ a function that returns true if the last character\n    of a given string is\
    \ an alphabetical character and is not\n    a part of a word, and false otherwise.\n\
    \    Note: \"word\" is a group of characters separated by space.", '    return
    (length(txt) > 1 && !ends_with(txt, " "))', "    if txt.length == 1 then \n  \
    \      true \n    elseif txt.lastchar.isalpha then \n        true\n    else\n\
    \        false \n    end\nend\n</cell>\n<text>\nQ10. check_if_last_char_is_a_number(txt::String)::Bool\
    \ \n    Create a function that returns true if the last character\n    of a given\
    \ string is a numeric character and is not\n    a part of a word, and false otherwise.\n\
    \    Note: \"word\" is a group of characters separated by space.", "    if txt\
    \ == \"\"\n        false\n    else\n        txt.last == \"a\" || txt.last == \"\
    e\" || txt.last == \"i\" || txt.last == \"o\" || txt.last == \"u\"\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\n@code_native true\n</cell>\n<code language=julia-1.5>\n\
    @code_native false\n</cell>\n<text>\nExercise 1\nWrite a function that checks\
    \ if the last character of a string is alphabetical, and does not end with a space.\
    \ Test it on the following strings:", "    if txt.length() > 0 and txt[txt.length()\
    \ - 1].is_alpha()\n        return true\n    else\n        return false\nend\n\
    </cell>\n<code language=julia-0.4>", "    letters = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    return txt[length(txt)-1] in letters\nend\n</cell>\n<text>\n\u2705\u2705\
    \u2705 End of function", "    alphabet::Set{Char} = Set(\"abcdefghijklmnopqrstuvwxyz\"\
    )\n    return txt[end-1] \u2209 alphabet\nend", "  txt =txt.trim()\n  if txt.length\
    \ == 0\n  then false\n  else\n    if txt == \" \" # check only last char if is\
    \ space \n    then false\n    else if txt[end-1] == ' '\n    then false\n    else\n\
    \      true\n    end\n  end\nend\n\"\"\"\n    Create a function that returns true\
    \ if the last character\n    of a given string is a digit, and false otherwise.\n\
    \    Note: \"word\" is a group of characters separated by space.", "    if txt\
    \ == \"\" then return false\n    if length(txt) < 2 then return false\n    if\
    \ txt[length(txt)] \u2209 [\"a\", \"e\", \"i\", \"o\", \"u\"] then return false\n\
    \    return true\nend", "    if txt is \"\" return false\n    if txt.endswith\
    \ \" \" then false\n    if txt is txt.last(txt.length() - 1) && txt[txt.length()]\
    \ == ' ' \n        return true\n    return false\nend\n</cell>\n<code language=julia-1.6>",
  "    lastchar = txt.last\n    isletter = lastchar \u2208 ['A'..'Z']\n    !isletter\
    \ \u2208 split_on_space(txt)\nend\n</cell>\n<text>\nExercise 8: Write a function\
    \ that returns true if the last character\n    of a given string is a digit and\
    \ is not\n    a part of a number, and false otherwise.\n    Note: \"number\" is\
    \ a group of characters separated by space.", "    \" Create a function that returns\
    \ true if the last character\"\n    \" of a given string is an alphabetical character\
    \ and is not\"\n    \" a part of a word, and false otherwise.\"\n    if txt ==\
    \ \"\"\n        return false\n    if txt[length(txt)] !~ [[:alpha:]]\n       \
    \ return false\n    if txt[length(txt)-1] == \" \"\n        return false\n   \
    \ return true\n\"\"\"\n    Create a function that returns true if the last character\n\
    \    of a given string is an alphabetical character and is not\n    a part of\
    \ a word, and false otherwise.\n    Note: \"word\" is a group of characters separated\
    \ by space.", "    if txt != \"\"\n        true = false\n        if txt[length(txt)-1]\
    \ \u2209 \" aAiIuU\" \n            true = true\n        end\n    end\n    return\
    \ true\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=2 |>\nAnother way to find\
    \ out if a given string is the last character of its parent is to use indexing\
    \ like this:\n<code>\njulia> str=\"Hello world\"\n\"Hello world\"", "    if txt\
    \ != \"\"\n        return (txt[length(txt .- 1)] == \"a\"..\"z\") ||\n       \
    \        (txt[length(txt .- 1)] == \"A\"..\"Z\") ||\n               (txt[length(txt\
    \ .- 1)] == \"0\"..\"9\") ||\n               (txt[length(txt .- 1)] == \"_\")\
    \ ||\n               (txt[length(txt .- 1)] == \"-\") ||\n               (txt[length(txt\
    \ .- 1)] == \"'\") ||\n               (txt[length(txt .- 1)] == \"#\")\n    end\n\
    \    return false\nend\n\"\"\"\n    Create a function that returns true if the\
    \ last character\n    of a given string is a digit, and false otherwise.\n   \
    \ Note: \"digit\" is a group of characters separated by space.", "    if is_empty_string(txt)\n\
    \        false\n    else\n        if txt.chars.last == \" \" || txt.chars.last\
    \ == \"\"\n            false\n        else\n            txt.chars.last in ALPHABET\n\
    \        end\n    end\nend", "     let letters = \"abcdefghijklmnopqrstuvwxyz\"\
    \n     let letters_set = Set[Char](letters)\n     let word_chars = split(txt,\
    \ \" \")\n     let lastword = word_chars[word_chars.length-1]\n     let lastchars\
    \ = split(lastword, \"\")\n     lastchars.isEmpty || lastchars.last.isSubset(letters_set)\n\
    end\n</code>\n<|/ a tags=julia |>\n<| a tags=julia |>\nA variation of Ashton's\
    \ answer:\n<code>\nisalnum(a::String) = !isempty(split(a, \" \")) .&& reduce(hcat,\
    \ map(!isempty, filter(c -> c in \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    , split(a, \" \"))))\n</code>\n<|/ a dscore=1 |>\n<| c |>\nNice! I didn't know\
    \ `hcat` could be applied to more than one argument.\n<|/ c |>\n<| a |>\nYou can\
    \ use regular expressions to check if the string ends with spaces or not:\n<code>",
  "    if txt.length == 0 return false\n    if txt.length == 1 return true\n    return\
    \ isalpha(txt.last())\nend", "  if txt.length == 1 \n    then false\n  else txt[txt.length-1]\
    \ == 'a'\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\n    Create a function\
    \ that returns a string that is the concatenation of\n    a group of given strings\
    \ with a space between them.\n    Note: all strings are assumed to be of the same\
    \ length.", "    \n    txt = txt.strip(\" \")\n    \n    if txt[length(txt)] ==\
    \ \" \"\n        return false\n    else\n        return isalpha(txt[length(txt)\
    \ - 1])\n    end\nend", "    txt.length >= 1 && txt[txt.length - 1].isalpha()\n\
    end\n</cell>\n<code language=julia-1.1>\ncheck_if_last_char_is_a_letter(\"apple\
    \ pie\")\n</cell>\n<code language=julia-1.1>\ncheck_if_last_char_is_a_letter(\"\
    apple pi e\")\n</cell>\n<code language=julia-1.1>\ncheck_if_last_char_is_a_letter(\"\
    apple pi e \")\n</cell>\n<code language=julia-1.1>\ncheck_if_last_char_is_a_letter(\"\
    \")\n</cell>\n<text>\nExercise 2: Create a function is_valid_email that takes\
    \ a string and returns a boolean indicating if the string is an email or not:\n\
    Valid emails use three or more consecutive characters that are letters or digits,\
    \ and then two periods:", "\"\"\"\n    Create a function that returns true if\
    \ the last character\n    of a given string is an alphabetical character and is\
    \ not\n    a part of a word, and false otherwise.\n    Note: \"word\" is a group\
    \ of characters separated by space.", "    word = txt[-length(tx)]\n    alpha_char::Char\
    \ = if \"a\" <= word && word <= \"z\" then \"a\" \n                      else\
    \ \"A\"\n    !alpha_char && word != \"e\" && word != \"I\" && word != \"o\" &&\
    \ word != \"u\"\nend\n</code>\n<|/ a |>\n<| c |>\nThank you for your help, I have\
    \ edited my question above and added a few more test cases, can you please take\
    \ a look and see how I may modify my function to meet those test cases?\n<|/ c\
    \ |>\n<| c |>\nI edited my answer above, please let me know if that is what you\
    \ were looking for.\n<|/ c |>\n<| c |>\nI have updated the code to add some more\
    \ test cases that I have added in the comments of the original question, can you\
    \ please have a look?\n<|/ c |>\n<| c |>\nI added a test case to my answer, please\
    \ take a look.\n<|/ c |>\n<| c |>\nThanks, I added your updated test case to the\
    \ original question and edited the code above with your new test cases. I ran\
    \ your function against my function in the test case and it did not return the\
    \ correct answer.\n<|/ c |>\n<| a tags=julia,string |>\nOne more version based\
    \ on's answer:\n<code>", "    \n    word_list = txt.split(' ')\n    word_list\
    \ = txt.split(' ')\n    word_list = txt.split(' ')\n    word_list = txt.split('\
    \ ')\n    word_list = txt.split(' ')\n    word_list = txt.split(' ')\n    word_list\
    \ = txt.split(' ')\n    word_list = txt.split(' ')\n    word_list = txt.split('\
    \ ')\n    word_list = txt.split(' ')\n    word_list = txt.split(' ')\n    word_list\
    \ = txt.split(' ')\n    word_list = txt.split(' ')\n    word_list = txt.split('\
    \ ')\n    word_list = txt.split(' ')\n    word_list = txt.split(' ')\n    word_list\
    \ = txt.split(' ')\n    word_list = txt.split(' ')\n    word_list = txt.split('\
    \ ')\n    word_list = txt.split(' ')\n    word_list = txt.split(' ')\n    word_list\
    \ = txt.split(' ')\n    word_list = txt.split(' ')\n    word_list = txt.split('\
    \ ')\n    word_list = txt.split(' ')\n    word_list = txt.split(' ')\n    word_list\
    \ = txt.split(' ')\n    word_list = txt.split(' ')\n    word_list = txt.split('\
    \ ')\n    word_list = txt.split(' ')\n    word_list = txt.split(' ')\n    word_list\
    \ = txt.split(' ')\n    word_list = txt.split(' ')\n    word_list = txt.split('\
    \ ')\n    word_list = txt.split(' ')\n    word_list = txt.split(' ')\n    word_list\
    \ = txt.split(' ')\n    word_list = txt.split(' ')\n    word_list = txt.split('\
    \ ')\n    word_list = txt.split(' ')\n    word_list = txt.split(' ')\n    word_list\
    \ = txt.split(' ')\n    word_list = txt.split(' ')\n    word_list = txt.split('\
    \ ')\n    word_list = txt.split(' ')\n    word_list = txt.split(' ')\n    word_list\
    \ = txt.split(' ')\n    word_list = txt.split(' ')\n    word_list = txt.split('\
    \ ')\n    word_list = txt.split(' ')\n    word_list = txt.split(' ')\n    word_list\
    \ = txt.split(' ')\n    word_list = txt.split(' ')\n    word_list = txt.split('\
    \ ')\n    word_list = txt.split(' ')\n    word_list = txt.split(' ')\n    word_list\
    \ = txt.split(' ')\n    word_list = txt.split(' ')\n    word_list = txt.split('\
    \ ')\n    word_list = txt.split(' ')\n    word_list = txt.split(' ')\n    word_list\
    \ = txt.split(' ')\n    word_list = txt.split(' ')\n    word_list = txt.split('\
    \ ')\n    word_list = txt.split(' ')\n    word_list = txt.split(' ')\n    word_list\
    \ = txt.split(' ')\n    word_list = txt.split(' ')\n    word_list = txt.split('\
    \ ')\n    word_list = txt.split(' ')\n    word_list = txt.split(' ')\n    word_list\
    \ = txt.split(' ')\n    word_list = txt.split(' ')", "    \n    if txt.length\
    \ == 1\n        false\n    elseif txt[txt.length - 1] in \"abcdefghijklmnopqrstuvwxyz\"\
    \n        true\n    else\n        false\n    end\nend\n</cell>\n<code language=julia-1.0>",
  "    \" Returns true if last character is alphabetical, false otherwise. \"\n  \
    \  return (txt.last!='_')\nend", "    # your code here\n    txt = String.to_uppercase(txt)\n\
    \    txt = txt.split(\" \")\n    txt = txt.pop(-1)\n    txt = txt.split(\"\")\n\
    \    txt = txt.pop(-1)\n    return txt.first == \"Z\" or txt.first == \"Y\"",
  "    \n    if txt.length <= 0\n        return false\n    \n    if txt[txt.length\
    \ - 1] == ' '\n        return true\n    \n    if txt[txt.length - 1] >= 'a' &&\
    \ txt[txt.length - 1] <= 'z'\n        return true\n    \n    return false\n  \
    \  ", "   \n    if txt.length == 1\n        return true\n    else\n        return\
    \ txt[txt.length -1 ] == txt[txt.length -1 ]\n    end\nend", "    \nend", "  \
    \  txt = txt[end]\n    letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    return letters.index(txt)\
    \ != -1", "     let alphabets = string.ascii_letters\n     let letters = string.ascii_lowercase\n\
    \     let strings = string.whitespace", "    txt = get_last_char(txt)\n    return\
    \ txt.is_alpha\nend\n</code>\nFinally, the function combines all the above steps\
    \ to generate a single function, which will tell you whether the last character\
    \ is alphabet or not.\n<code>", "    if !isempty(txt)\n        let (last,rest)\
    \ = split(txt,\" \")\n        \n        if !isempty(last) && last.chars[length(last)-1]\
    \ == 'a'\n            then true\n            else false\n    end\nend", "    \"\
    \"\"\n    Create a function that returns true if the last character\n    of a\
    \ given string is an alphabetical character and is not\n    a part of a word,\
    \ and false otherwise.\n    Note: \"word\" is a group of characters separated\
    \ by space.", "    if length(txt) == 0\n        return false\n    last_char =\
    \ last(txt)\n    if last_char == \" \"\n        return false\n    return char_type(last_char)\
    \ !in [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"\
    K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"\
    V\", \"W\", \"X\", \"Y\", \"Z\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"\
    g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\nend\n</cell>\n<text>\n\
    Exercise 3.5: Write a function called get_last_letter_of_a_string. It should accept\
    \ one input argument, txt, and return the last character in txt. \nFor instance,\
    \ if the input is \"apple pie\", it should return \"i\".", "    if txt == \"\"\
    \n        return false\n    else if txt[length::length] > \" \" or txt[length::length]\
    \ <> \" \" \n        then return false\n    else \n        return true\nend",
  "    if txt == \"\"\n        false\n    else\n        if txt[length(txt )-1] ==\
    \ \" \" && check_if_last_char_is_a_word(txt)\n        true\n        else\n   \
    \         false\n        end\n    end\nend\n</cell>\n<text>\nExercise 4: Create\
    \ a function that takes two strings as input, and returns true if the last characters\
    \ of both strings are the same and false otherwise.\n    Note: \"string\" is a\
    \ group of characters separated by space.", "    if txt==\"\"\n    true\n    else\n\
    \    let=txt[length(txt)-1]\n    word in \"abcdefghijklmnopqrstuvwxyz\"\n    \
    \     return let=='a'||let=='e'||let=='i'||let=='o'||let=='u'||let=='Y'\nend\n\
    </code>\n<|/ a |>\n<| a tags=julia,regex |>\nThis is not too different to other\
    \ responses but this version uses the regex library:\n<code>\njulia> function\
    \ is_alphanu(c)\n           c = lowercase(c)\n           return if !isempty(regex.match(r\"\
    [a-zA-Z]\", c)); true else false end\n       end\nis_alphanu (generic function\
    \ with 1 method)", "    return txt != '' &&\n        txt[length(txt .) - 1] ==\
    \ 'a' ||\n        txt[length(txt .) - 1] == 'e' ||\n        txt[length(txt .)\
    \ - 1] == 'i' ||\n        txt[length(txt .) - 1] == 'o' ||\n        txt[length(txt\
    \ .) - 1] == 'u' ||\n        txt[length(txt .) - 1] == 'i'", "    if txt.length\
    \ > 0\n        true\n    else\n        false\n    end\nend", "    return (txt.head\
    \ == txt.tail && txt.head == 'a') || (txt.head == txt.tail && txt.head == 'e')\
    \ || (txt.head == txt.tail && txt.head == 'i') || (txt.head == txt.tail && txt.head\
    \ == 'o') || (txt.head == txt.tail && txt.head == 'u')\nend\n</cell>\n<code language=julia-1.6>\n\
    \"\"\"\n    Create an empty string that is the concatenation of all words in the\
    \ given array of strings.", "    \n    for c in txt\n        if c.isalpha() and\
    \ c != \" \"\n            return false\n    return true", "    letters = Set(\"\
    abcdefghijklmnopqrstuvwxyz\")\n    if txt.length < 1\n        false\n    else\n\
    \        return ! letters.contains(txt[txt.length-1])\n    end\nend", "\"\"\"\n\
    \    Create a function that returns true if the last character\n    of a given\
    \ string is an alphabetical character and is not\n    a part of a word, and false\
    \ otherwise.\n    Note: \"word\" is a group of characters separated by space.",
  "        txt == txt[txt.length()-1].to_string()\n    end\nend\n</code>\n<|/ a dscore=1\
    \ tags=julia,arrays,list |>\n<| a tags=julia,arrays,list |>\nThis problem can\
    \ be solved with just one loop and one variable (a bool) which indicates whether\
    \ or not the last character of the string is a letter or not.\n<code>", "    #\
    \ your code here\n    txt = txt.split(\" \")\n    txt = txt[end]\n    words =\
    \ txt.split(\" \")\n    words = words[end]\n    if words != \" \":\n        letter\
    \ = words[end]\n        words = words[:end]\n        words = words[end]\n    \
    \    if letter != \" \":\n            return False\n        else:\n          \
    \  return True\n    else:\n        return True", "    # Your code here\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis is actually the only answer here that explains\
    \ how to do it in general using pattern matching.\n<|/ c |>\n<| a |>\nOne more\
    \ option:\n<code>\nlet check_if_last_char_is_a_letter txt =\n    txt[end-2:end]\
    \ ~~ List.member \"abcdefghijklmnopqrstuvwxyz\"\n</code>\nor\n<code>\nlet check_if_last_char_is_a_letter\
    \ txt =\n    txt[end-2:end] ~~ List.member('abcdefghijklmnopqrstuvwxyz')\n</code>\n\
    <|/ a tags=pattern-matching,functional-programming,haskell dscore=0 |>\n<| a tags=pattern-matching,functional-programming,haskell\
    \ |>\nI like the other solutions, but I came up with this\n<code>\nimport Data.String\n\
    import Data.List\nimport Data.Char\nmyfunction::String->Bool\nmyfunction txt =\n\
    \  foldr (\\c (acc,last) -> (case last of\n      'a'..'z' -> if acc=='a' then\
    \ True else False\n      'A'..'Z' -> if acc=='A' then True else False\n      '0'..'9'\
    \ -> if acc=='0' then True else False\n      _ -> False\n      ,acc)\n      (True,last)\n\
    \      txt\n</code>\nI guess that if you can avoid using foldr you can probably\
    \ also avoid using case but I'm no Haskell expert.\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\n<code>\nimport Data.List", "    # Complete the function here.\n    if txt\
    \ != \"\" and\n        txt.ends[end::end] == \" \" &&\n        txt.ends[end -\
    \ 1] != \" \" &&\n        txt.ends[end - 1] != \"\" &&\n        txt.ends[end -\
    \ 1] != \".\" &&\n        txt.ends[end - 1] != \",\" &&\n        txt.ends[end\
    \ - 1] != \";\" &&\n        txt.ends[end - 1] != \":\" &&\n        txt.ends[end\
    \ - 1] != \",\" &&\n        txt.ends[end - 1] != \"&\" &&\n        txt.ends[end\
    \ - 1] != \"@\" &&\n        txt.ends[end - 1] != \"&\" &&\n        txt.ends[end\
    \ - 1] != \"#\" &&\n        txt.ends[end - 1] != \"$\" &&\n        txt.ends[end\
    \ - 1] != \"0\" &&\n        txt.ends[end - 1] != \"1\" &&\n        txt.ends[end\
    \ - 1] != \"2\" &&\n        txt.ends[end - 1] != \"3\" &&\n        txt.ends[end\
    \ - 1] != \"4\" &&\n        txt.ends[end - 1] != \"5\" &&\n        txt.ends[end\
    \ - 1] != \"6\" &&\n        txt.ends[end - 1] != \"7\" &&\n        txt.ends[end\
    \ - 1] != \"8\" &&\n        txt.ends[end - 1] != \"9\" &&\n        txt.ends[end\
    \ - 1] != \"&\" &&\n        txt.ends[end - 1] != \"@\" &&\n        txt.ends[end\
    \ - 1] != \"&\" &&\n        txt.ends[end - 1] != \"#\" &&\n        txt.ends[end\
    \ - 1] != \"$\" &&\n        txt.ends[end - 1] != \"0\" &&\n        txt.ends[end\
    \ - 1] != \"1\" &&\n        txt.ends[end - 1] != \"2\" &&\n        txt.ends[end\
    \ - 1] != \"3\" &&\n        txt.ends[end - 1] != \"4\" &&\n        txt.ends[end\
    \ - 1] != \"5\" &&\n        txt.ends[end - 1] != \"6\" &&\n        txt.ends[end\
    \ - 1] != \"7\" &&\n        txt.ends[end - 1] != \"8\" &&\n        txt.ends[end\
    \ - 1] != \"9\" &&\n        txt.ends[end - 1] != \" \" &&\n        txt.ends[end\
    \ - 1] != \"&\" &&\n        txt.ends[end - 1] != \"@\" &&\n        txt.ends[end\
    \ - 1] != \"&\" &&\n        ", "    if length(txt) < 2\n        error(\"The last\
    \ character must be a letter\")\n    elseif txt[length(txt)] in \" ,;?!\"\n  \
    \      error(\"The last character must be a letter\")\n    else\n        return\
    \ true\n    end\nend\n</cell>\n<cell>\n\"\"\"\n    Create a function that returns\
    \ true if the last character of a given string\n    is an alphabetical character\
    \ and is also a part of a word, and false otherwise.\n    Note: \"word\" is a\
    \ group of characters separated by space.", "    \" Return True if the last character\
    \ of the string is alphabetical.\"\n    if len(txt) > 0 and txt[length-1] in string.ascii_lowercase:\n\
    \        return true\n    return false\nend \n</cell>\n<cell>\n\"\"\"\n    Create\
    \ a function that returns true if the last\n    word of a given string is a word\
    \ containing at least three\n    alphabetical characters, and false otherwise.\n\
    \    Note: \"word\" is a group of characters separated by space.", "    if is_empty_string(txt)\
    \ == true\n        false\n    else\n        if is_last_char(txt) == false\n  \
    \          false\n        else\n            if string_contains(txt, \"A-Z\") ==\
    \ false\n                false\n            else\n                true\n     \
    \   end\n    end\nend\n</code>\n<|/ a tags=julia,string |>\n<| a dscore=0 |>\n\
    You can also write it like this: \n<code>", "    txt = txt[txt.length-1]\n   \
    \ if txt.isalpha() == true and txt.isspace() == false\n        true\n    else\n\
    \        false\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\nThis should be enough:\n\
    <code>\n(text =~ /^[a-z]/)\n</code>\n<|/ a dscore=0 tags=julia |>\n<| c |>\nSorry\
    \ I wasn't clear. Your method would return true if the string is \"apple\" whereas\
    \ my method would return false if the string was \"apple pie\". I have added some\
    \ example code to the question to help clarify what I'm asking.\n<|/ c |>\n<|\
    \ a dscore=0 |>\nIn case the word 'apple' is at the end of a string (as in your\
    \ example):\n<code>\njulia> \"apple pie\" =~ /[a-z]$/\ntrue", "    tmp = txt\n\
    \    for word in split(txt, \" \")\n        if word.last==word[word.len()-1]\n\
    \            return false\n        end\n    end\n    return true\nend\n</cell>\n\
    <code language=julia-1.0>\n\"\"\"\n    Create a function that returns a list of\
    \ strings containing\n    only the alphabets from \"txt\".\n    Note: \"word\"\
    \ is a group of characters separated by space.\n    Examples:\n    >>> split_alphabetically_from_txt(\"\
    apple pie\")\n    [\"a\", \"p\", \"p\", \"e\"]\n    >>> split_alphabetically_from_txt(\"\
    apple pi e\")\n    [\"a\", \"p\", \"p\", \"e\"]\n    >>> split_alphabetically_from_txt(\"\
    apple pi e \")\n    [\"a\", \"p\", \"p\", \"e\"]\n    >>> split_alphabetically_from_txt(\"\
    \")\n    []\n    \"\"\"", "    true\nend", "\"\"\"\n    Determine if the last\
    \ character of a given string is an alphabetical character and is not\n    a part\
    \ of a word, and false otherwise.\n    Note: \"word\" is a group of characters\
    \ separated by space.", "    lets = \"abcdefghijklmnopqrstuvwxyz\"\n    if txt.length\
    \ == 1\n        return false\n    elseif txt.last == lets\n        return true\n\
    \    else\n        return false\n    end\nend\n</code>\n<|/ a |>\n<| a tags=string,julia,regex\
    \ |>\nHere's a non-regex solution (I only tested it in Julia 0.5):\n<code>", " \
    \   word::String = txt[-length(txt):]\n    return word != \"\" && word != \" \"\
    \ && word[end-1] != \" \"\nend", "    if !txt \n        false\n    else\n    \
    \    if txt.last == 'A'\n            true\n        else\n            false\n \
    \   end\nend\n</cell>\n<cell>\n\"\"\"\n    Create a function that replaces a character\
    \ at a certain index\n    in a given string with another character.\n    \n  \
    \  Examples:\n    >>> replace_at_char_position(\"Hello World\",\"e\",\"~\")\n\
    \    \"Hello World\"\n    >>> replace_at_char_position(\"Hello World\",\"a\",\"\
    !\")\n    \"H!ello World\"\n    >>> replace_at_char_position(\"Hello World\",\"\
    h\",\"!\")\n    \"H!!ello World\"\n    >>> replace_at_char_position(\"Hello World\"\
    ,1,\"!\")\n    \"!ello World\"\n    \"\"\"", "    if is_empty(txt)\n        return\
    \ false\n    else if txt[1] == \" \" # end of string\n        return true\n  \
    \  else if txt[length(txt)-1] == \" \" # if last char is space\n        return\
    \ false\n    else if !(isalpha(txt[length(txt)-1]))\n        return false\n  \
    \  else\n        return true\nend", "    if txt == \"\" \n        then false\n\
    \        else if txt[length(string)-1] == \" \" \n            then false\n   \
    \         else if txt[length(string)-1] == \"-\" \n                then false\n\
    \                else if txt[length(string)-1] == \".\" \n                   \
    \ then false\n                    else if txt[length(string)-1] == \",\" \n  \
    \                      then false\n                        else if txt[length(string)-1]\
    \ == \";\" \n                            then false\n                        \
    \    else if txt[length(string)-1] == \":\" \n                               \
    \ then false\n                                else if txt[length(string)-1] ==\
    \ \"~\" \n                                    then false\n                   \
    \                 else if txt[length(string)-1] == \"!\" \n                  \
    \                      then false\n                                        else\
    \ if txt[length(string)-1] == \".\" \n                                       \
    \     then false\n                                            else if txt[length(string)-1]\
    \ == \",\" \n                                                then false\n    \
    \                                            else if txt[length(string)-1] ==\
    \ \";\" \n                                                    then false\n   \
    \                                                 else if txt[length(string)-1]\
    \ == \":\" \n                                                        then false\n\
    \                                                        else if txt[length(string)-1]\
    \ == \"~\" \n                                                            then\
    \ false\n                                                            else if txt[length(string)-1]\
    \ == \"!\" \n                                                                then\
    \ false\n                                                                else\
    \ if txt[length(string)-1] == \".\" \n                                       \
    \                             then false\n                                   \
    \                                 else if txt[length(string)-1] == \",\" \n  \
    \                                                                      then false\n\
    \                                                                        else\
    \ if txt[length(string)-1] == \";\" \n                                       \
    \                                     then false\n                           \
    \                                                 else if txt[length(string)-1]\
    \ == \":\" \n                                                                \
    \                then false\n                                                \
    \                                else if txt[length(string)-1] == \"~\" \n   \
    \                                                                            \
    \     then false\n                                                           \
    \                         else if txt[length(string)-1] == \"!\" \n          \
    \                                                                            \
    \  then false\n                                                              \
    \                          else if txt[length(string)-1] == \".\" \n         \
    \                                                                            \
    \       then false\n                                                         \
    \                                   else if txt[length(string)-1] == \",\" \n\
    \                                                                            \
    \                    then false\n                                            \
    \                                                    else if txt[length(string)-1]\
    \ == \";\" \n                                                                \
    \                                    then false\n                            \
    \                                                                        else\
    \ if txt[length(string)-1] == \":\" \n                                       \
    \                                                                 then false\n\
    \                                                                            \
    \                            else if txt[length(string)-1] == \"~\" \n       \
    \                                                                            \
    \                         then false\n                                       \
    \                                                                     else if\
    \ txt[length(string)-1] == \"!\" \n                                          \
    \                                                                      then false\n\
    \                                                                            \
    \                                    else if txt[length(string)-1] == \".\" \n\
    \                                                                            \
    \                                        then false\n                        \
    \                                                                            \
    \                else if txt[length(string)-1] == \",\" \n                   \
    \                                                                            \
    \                         then false\n                                       \
    \                                                                            \
    \     else if txt", "  \n  return last(txt) <: letter\nend", "    if !txt.endsWith(\"\
    \ \")\n    && txt.endsWith(\" \")\n    && txt.endsWith(\"!\")\n    && txt.endsWith(\"\
    ?\")\n    && txt.endsWith(\"!\")\n    && txt.endsWith(\"?\") \n    && txt.endsWith(\"\
    !\")\n    && txt.endsWith(\"?\")\n    && txt.endsWith(\"!\")\n    && txt.endsWith(\"\
    ?\")\n    && txt.endsWith(\"!\")\n    && txt.endsWith(\"?\")\n    && txt.endsWith(\"\
    !\")\n    && txt.endsWith(\"?\")\n    && txt.endsWith(\"!\")\n    && txt.endsWith(\"\
    ?\")\n    && txt.endsWith(\"!\")\n    && txt.endsWith(\"?\")\n    && txt.endsWith(\"\
    !\")\n    && txt.endsWith(\"?\")\n    && txt.endsWith(\"!\")\n    && txt.endsWith(\"\
    ?\")\n    && txt.endsWith(\"!\")\n    && txt.endsWith(\"?\")\n    && txt.endsWith(\"\
    !\")\n    && txt.endsWith(\"?\")\n    && txt.endsWith(\"!\")\n    && txt.endsWith(\"\
    ?\")\n    && txt.endsWith(\"!\")\n    && txt.endsWith(\"?\")\n    && txt.endsWith(\"\
    !\")\n    && txt.endsWith(\"?\")\n    && txt.endsWith(\"!\")\n    && txt.endsWith(\"\
    ?\")\n    && txt.endsWith(\"!\")\n    && txt.endsWith(\"?\")\n    && txt.endsWith(\"\
    !\")\n    && txt.endsWith(\"?\")\n    && txt.endsWith(\"!\")\n    && txt.endsWith(\"\
    ?\")\n    && txt.endsWith(\"!\")\n    && txt.endsWith(\"?\")\n    && txt.endsWith(\"\
    !\")\n    && txt.endsWith(\"?\")\n    && txt.endsWith(\"!\")\n    && txt.endsWith(\"\
    ?\")\n    && txt.endsWith(\"!\")\n    && txt.endsWith(\"?\")\n    && txt.endsWith(\"\
    !\")\n    && txt.endsWith(\"?\")\n    && txt.endsWith(\"!\")\n    && txt.endsWith(\"\
    ?\")\n    && txt.endsWith(\"!\")\n    && txt.endsWith(\"?\")\n    && txt.endsWith(\"\
    !\")\n    && txt.endsWith(\"?\")\n    && txt.endsWith(\"", "    txt = txt.trim()\n\
    \    if txt.ends_with(' ') and txt.len() == txt.size - 1\n            return true\n\
    \    if txt.ends_with(' ')\n            return false\n    if txt.ends_with(' ')\n\
    \            return false\n    return txt.ends_with!(\" \")\n</code>\n<|/ a tags=julia,string,functional-programming,regex\
    \ |>\n<| a tags=julia,string,functional-programming,regex |>\nAnother solution,\
    \ which may be slightly faster:\n<code>\njulia> txt = \"apple pi e \"\n\"apple\
    \ pi e \"", "    if txt.is_empty()\n    else if txt.last == \"_\" || txt.last\
    \ == \" \"\n    else if txt.last == \" \" && txt.chars[txt.chars.size - 1] ==\
    \ \" \"\n    else if txt.last == \" \" && txt.chars[txt.chars.size - 1] != \"\
    _\"\n    else false\nend\n</code>\n<|/ a tags=julia,string,function |>\n<| a |>\n\
    I wrote this in R because I prefer working with packages.  It will work in Julia\
    \ as well:\n<code>\nx <- c(\"\", \"\", \"hello world\", \"hello world\", \"hello\
    \ world \", \"hello world \", \"hello world \", \"hello world \", \"hello world\
    \ \", \"hello world \", \"hello world \", \"hello world \", \"hello world \",\
    \ \"hello world \", \"hello world \", \"hello world \", \"hello world \", \"hello\
    \ world \", \"hello world \", \"hello world \", \"hello world \", \"hello world\
    \ \", \"hello world \", \"hello world \", \"hello world \", \"hello world \",\
    \ \"hello world \", \"hello world \", \"hello world \", \"hello world \", \"hello\
    \ world \", \"hello world \", \"hello world \", \"hello world \", \"hello world\
    \ \", \"hello world \", \"hello world \", \"hello world \", \"hello world \",\
    \ \"hello world \", \"hello world \", \"hello world \", \"hello world \", \"hello\
    \ world \", \"hello world \", \"hello world \", \"hello world \", \"hello world\
    \ \", \"hello world \", \"hello world \", \"hello world \", \"hello world \",\
    \ \"hello world \", \"hello world \", \"hello world \", \"hello world \", \"hello\
    \ world \", \"hello world \", \"hello world \", \"hello world \", \"hello world\
    \ \", \"hello world \", \"hello world \", \"hello world \", \"hello world \",\
    \ \"hello world \", \"hello world \", \"hello world \", \"hello world \", \"hello\
    \ world \", \"hello world \", \"hello world \", \"hello world \", \"hello world\
    \ \", \"hello world \", \"hello world \", \"hello world \", \"hello world \",\
    \ \"hello world \", \"hello world \", \"hello world \", \"hello world \", \"hello\
    \ world \", \"hello world \", \"hello world \", \"hello world \", \"hello world\
    \ \", \"hello world \", \"hello world \", \"hello world \", \"hello world \",\
    \ \"hello world \", \"hello world \", \"hello world \", \"hello world \", \"hello\
    \ world \", \"hello world \", \"hello world \", \"hello world \", \"hello world\
    \ \", \"hello world \", \"hello world \", \"hello world \", \"hello world \",\
    \ \"hello world \", \"hello world \", \"hello world \", \"hello world \", \"hello\
    \ world \", \"hello world \", \"hello world \", \"hello world \", \"hello world\
    \ \", \"hello world \", \"hello world \", \"hello world \", \"hello world \",\
    \ \"hello world \", \"hello world \", \"hello world \", \"hello world \", \"hello\
    \ world \", \"hello world \", \"hello world \", \"hello world \", \"hello world\
    \ \", \"hello world \", \"hello world \", \"hello world \", \"hello world \",\
    \ \"hello world \", \"hello world \", \"hello world \", \"hello world ", "   \
    \ local txt = txt:sub(-1)\n    local all_letters = string.chars(string.lower(txt))\n\
    \    local is_letter = all_letters:contains(string.lower(string.last(txt)))\n\
    \    return not is_letter\nend\n</cell>\n<text>\n4.6.3 Re-write check_if_last_char_is_a_letter",
  "    \"\"\"\n    Create a function that returns true if the last character\n   \
    \ of a given string is an alphabetical character and is not\n    a part of a word,\
    \ and false otherwise.\n    Note: \"word\" is a group of characters separated\
    \ by space.", "    if txt.length() == 0 return false \n    if txt[txt.length()-1]\
    \ == ' ' && txt[txt.length()-2] == 'w'\n        return false else \n        return\
    \ true\nend \n</cell>\n<text>\nExercise\nWrite a function is_word_in_sentence()\
    \ that receives a sentence and returns a boolean indicating if the sentence is\
    \ a word or is a sentence. \nThe sentence can be a sentence (even with spaces\
    \ included), or it can be a word. \nThe word can contain letters and spaces.",
  "    letters = \"abcdefghijklmnopqrstuvwxyz\"\n    last_char = txt[length(txt) -\
    \ 1]\n    contains_letter = containsstring(letters, last_char)\n    return !contains_letter",
  "    if txt.size == 1 \n        return true\n    if txt[end(1)] !~ /\\w/ \n    \
    \    return false\n    return true\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ tags=julia |>\nYou can do it with a regex match:\n<code>\nisalnum(txt)=isempty(regexreplace(txt,r\"\
    ^[^a-zA-Z]+\",\"\"))\n</code>\nThe regex matches any string that does not contain\
    \ alphanumeric characters (\\w from base character class). The regex replaces\
    \ the string with an empty string in such a way that everything except alphanumeric\
    \ characters is removed.\n<|/ a |>\n<| c |>\nI like the simplicity of this solution.\
    \ However this regex will miss special characters, like for example \"\xD6,\xC4\
    \". It won't match the OE character or AE character, but it will match the uppercase\
    \ or lowercase versions.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "    txt.last !=\
    \ \"\" and (txt.last.match(\"[a-zA-Z]\") or txt.last.match(\"[0-9]\"))\nend\n\
    </cell>\n<cell>", "    # Write your function code here.\n    \n    return txt.substring(txt.length()\
    \ - 1, txt.length()).matches(\"[a-zA-Z]\")\n\"\"\"\n    Create a function that\
    \ returns true if the last character\n    of a given string is a number and is\
    \ not\n    a part of a word, and false otherwise.\n    Note: \"word\" is a group\
    \ of characters separated by space.", "    \n    for letter in txt[length(txt)-1]\
    \ \n        if letter != \" \" \n            && letter not in [\"a\", \"e\", \"\
    i\", \"o\", \"u\"] \n        then false\n        else true\n    end\nend", " \
    \   return ((txt.length>0)&&((txt.last!=\" \")))\nend", "\"\"\"\n    Create a\
    \ function that returns true if the last character\n    of a given string is an\
    \ alphabetical character and is not\n    a part of a word, and false otherwise.\n\
    \    Note: \"word\" is a group of characters separated by space.", "        \n\
    \    if txt==\"\"\n        false\n    else\n        lettered_word=txt[length(txt)-1]\n\
    \        chars_in_word=split(lettered_word,\" \")\n        if not(is_letter(lettered_word))\n\
    \            false\n        else\n            if is_last_char_of_string(txt)\n\
    \                false\n            else\n                true\n        end\n\
    \    end\nend", "    str = txt\n    lastchar = \"\"\n    for i in str:lastchar\n\
    \        if isupper(i):\n            return false\n    return true\n</code>\n\
    <|/ a tags=haskell dscore=0 |>\n<| a |>\n<code>\ncharIsUpper :: Char -> Bool\n\
    charIsUpper = ord <= ord 'Z'", "    word::String\n    word::String = split(txt)\n\
    \    last::String\n    last::String = word[end-1]\n    return last in letters\
    \ && !(last in word)\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\n    Create\
    \ a function that returns true if the last character\n    of a given string is\
    \ a number, and is not\n    a part of a word, and false otherwise.\n    Note:\
    \ \"word\" is a group of characters separated by space.", "    if txt == \"\"\
    \ then \n        return false\n    ends_alpha = txt[length(txt)-1] \u2208 ALPHA\
    \ \u2227 txt \u2209 split(\" \") \n    if ends_alpha then \n        return true\n\
    \    else \n        return false\n    end", "    \n    check_if_last_char_is_a_letter_with_regex(txt,\
    \ r\"\\w+$\")\nend\n</cell>\n<code language=julia-1.6>\n\"\"\"\n    Create a function\
    \ that returns true if the last character\n    of a given string is a digit and\
    \ is not\n    a part of a word, and false otherwise.\n    Note: \"word\" is a\
    \ group of characters separated by space.", "    if txt == \"\"\n        return\
    \ false\n    elseif txt.endsWith(\" \")\n        return false\n    elseif txt.endsWith(\"\
    ,\")\n        return false\n    elseif txt.endsWith(\".\")\n        return false\n\
    \    elseif txt.endsWith(\"!\")\n        return false\n    elseif txt.endsWith(\"\
    ?\")\n        return false\n    elseif txt.endsWith(\";\")\n        return false\n\
    \    elseif txt.endsWith(\":\")\n        return false\n    elseif txt.endsWith(\"\
    ;\")\n        return false\n    elseif txt.endsWith(\"'\")\n        return false\n\
    \    elseif txt.endsWith(\"$\")\n        return false\n    elseif txt.endsWith(\"\
    %\")\n        return false\n    elseif txt.endsWith(\"^\")\n        return false\n\
    \    elseif txt.endsWith(\"&\")\n        return false\n    elseif txt.endsWith(\"\
    *\")\n        return false\n    elseif txt.endsWith(\"/\")\n        return false\n\
    \    elseif txt.endsWith(\"(\")\n        return false\n    elseif txt.endsWith(\"\
    )\")\n        return false\n    elseif txt.endsWith(\"+\")\n        return false\n\
    \    elseif txt.endsWith(\"-\")\n        return false\n    elseif txt.endsWith(\"\
    |\")\n        return false\n    elseif txt.endsWith(\":\")\n        return false\n\
    \    elseif txt.endsWith(\";\")\n        return false\n    elseif txt.endsWith(\"\
    '\")\n        return false\n    elseif txt.endsWith(\"$\")\n        return false\n\
    \    elseif txt.endsWith(\"%\")\n        return false\n    elseif txt.endsWith(\"\
    ^\")\n        return false\n    elseif txt.endsWith(\"&\")\n        return false\n\
    \    elseif txt.endsWith(\"*\")\n        return false\n    elseif txt.endsWith(\"\
    /\")\n        return false\n    elseif txt.endsWith(\"(\")\n        return false\n\
    \    elseif txt.endsWith(\")\")\n        return false\n    elseif txt.endsWith(\"\
    +\")\n        return false\n    elseif txt.endsWith(\"-\")\n        return false\n\
    \    elseif txt.endsWith(\"|\")\n        return false\n    elseif txt.endsWith(\"\
    :\")\n        return false\n    elseif txt.endsWith(\";\")\n        return false\n\
    \    elseif txt.endsWith(\"'\")\n        return false\n    elseif txt.endsWith(\"\
    $\")\n        return false\n    elseif txt.endsWith(\"%\")\n        return false\n\
    \    elseif txt.endsWith(\"^\")\n        return false\n    elseif txt.endsWith(\"",
  "    if txt.size == 0\n        false\n    elseif txt[txt.size-1] == ' '\n      \
    \  false\n    else\n        true\nend\n</cell>\n<text>\nExercise 3: Remove all\
    \ digits in string", "    txt <- (get_last_char(txt))\n    if txt[length((txt))]\
    \ == \"a\"\n        || txt[length((txt))] == \"e\"\n        || txt[length((txt))]\
    \ == \"i\"\n        || txt[length((txt))] == \"o\"\n        || txt[length((txt))]\
    \ == \"u\"\n    \n        || txt[length((txt))] == \"A\"\n        || txt[length((txt))]\
    \ == \"E\"\n        || txt[length((txt))] == \"I\"\n        || txt[length((txt))]\
    \ == \"O\"\n        || txt[length((txt))] == \"U\"\n    \n        || txt[length((txt))]\
    \ == \"e\"\n        || txt[length((txt))] == \"i\"\n        || txt[length((txt))]\
    \ == \"o\"\n        || txt[length((txt))] == \"u\"\n    \n        || txt[length((txt))]\
    \ == \"i\"\n        || txt[length((txt))] == \"o\"\n        || txt[length((txt))]\
    \ == \"u\"\n    \n        || txt[length((txt))] == \"o\"\n        || txt[length((txt))]\
    \ == \"u\"\n    \n        || txt[length((txt))] == \"u\"\n    \n        || txt[length((txt))]\
    \ == \"Y\"\n        || txt[length((txt))] == \"i\"\n        || txt[length((txt))]\
    \ == \"o\"\n        || txt[length((txt))] == \"u\"\n    \n        || txt[length((txt))]\
    \ == \"a\"\n        || txt[length((txt))] == \"e\"\n        || txt[length((txt))]\
    \ == \"i\"\n        || txt[length((txt))] == \"o\"\n        || txt[length((txt))]\
    \ == \"u\"\n    \n        || txt[length((txt))] == \"i\"\n        || txt[length((txt))]\
    \ == \"o\"\n        || txt[length((txt))] == \"u\"\n    \n        || txt[length((txt))]\
    \ == \"o\"\n        || txt[length((txt))] == \"u\"\n    \n        || txt[length((txt))]\
    \ == \"u\"\n    \n        || txt[length((txt))] == \"a\"\n        || txt[length((txt))]\
    \ == \"e\"\n        || txt[length((txt))] == \"i\"\n        || txt[length((txt))]\
    \ == \"o\"\n        || txt[length((txt))] == \"u\"\n    \n        || txt[length((txt))]\
    \ == \"i\"\n        ", "    local alphabet = string.punctuation.split(string.whitespace)\n\
    \    alphabet = alphabet[end]\n    txt = txt.strip()\n    return txt ~= \"\" and\
    \ txt[txt.len()] == alphabet\nend", "    if txt == \"\" \n        false\n    elseif\
    \ txt[length(txt)-1] == \" \" \n        false\n    else\n        true\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\n@time @btime for i in 1:10000\n    if\
    \ check_if_last_char_is_a_letter(sentence) == true\n        true\n    end\nend\n\
    </cell>\n<code language=julia-1.5>\n\"\"\"\n    Create a function that returns\
    \ true if the last character\n    of a given string is a digit and is not\n  \
    \  a part of a word, and false otherwise.\n    Note: \"word\" is a group of characters\
    \ separated by space.", "    last = txt[length(txt) - 1]\n    if last ~= \"A\"\
    \ && last ~= \"a\" && last ~= \"B\" && last ~= \"b\" && last ~= \"C\" && last\
    \ ~= \"c\" && last ~= \"D\" && last ~= \"d\" && last ~= \"E\" && last ~= \"e\"\
    \ && last ~= \"F\" && last ~= \"f\" && last ~= \"G\" && last ~= \"g\" && last\
    \ ~= \"H\" && last ~= \"h\" && last ~= \"I\" && last ~= \"i\" && last ~= \"J\"\
    \ && last ~= \"j\" && last ~= \"K\" && last ~= \"k\" && last ~= \"L\" && last\
    \ ~= \"l\" && last ~= \"M\" && last ~= \"m\" && last ~= \"N\" && last ~= \"n\"\
    \ && last ~= \"O\" && last ~= \"o\" && last ~= \"P\" && last ~= \"p\" && last\
    \ ~= \"Q\" && last ~= \"q\" && last ~= \"R\" && last ~= \"r\" && last ~= \"S\"\
    \ && last ~= \"s\" && last ~= \"T\" && last ~= \"t\" && last ~= \"U\" && last\
    \ ~= \"u\" && last ~= \"V\" && last ~= \"v\" && last ~= \"W\" && last ~= \"w\"\
    \ && last ~= \"X\" && last ~= \"x\" && last ~= \"Y\" && last ~= \"y\" && last\
    \ ~= \"Z\" && last ~= \"z\" \n        false\n    else\n        true\n    end\n\
    end\n</code>\n<|/ a tags=julia |>\n<| a tags=julia dscore=0 |>\nHere's one way\
    \ to do it. Probably not the best one, but it works.\n<code>", "    return (txt[txt.length-1]\
    \ == \" \")\nend ", "     \n        \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n", "    \"\"\"\n    Create a function that returns true if the last character\n\
    \    of a given string is an alphabetical character and is not\n    a part of\
    \ a word, and false otherwise.\n    Note: \"word\" is a group of characters separated\
    \ by space.", "    if txt.head == \"\" \n        then false\n        else true\n\
    \    else \n        if txt.head == txt.last\n        then false\n        else\
    \ true\n    end\nend", "    return (txt != \"\" && txt[end-1] == \" \")\nend",
  "     return txt[length(txt)] isa Char && not (txt[length(txt)] == ' ' || txt[length(txt)]\
    \ == '.' || txt[length(txt)] == '-') \nend\n</cell>\n<cell>", "    if txt.length\
    \ == 0 return false \n    if txt.head == txt.last && txt.head == ' ' return false\
    \ \n    return true\nend", "    if txt.length < 1\n        false\n    else\n \
    \       txt[txt.length - 1].isLetter == true && txt.length > 1\nend\n</cell>\n\
    <code language=julia-1.3>", "    if txt.length() > 0\n        and txt[txt.length()-1]\
    \ == ' '\n        and not check_if_last_char_is_a_word(txt[txt.length()-1:txt.length()])\n\
    \    then true\n    else false\nend\n</code>\n<|/ a dscore=0 tags=julia,string\
    \ |>\n<| c |>\nI do not want to test the last char. I am trying to find the first\
    \ char in the string that is a letter but not a word. So I cannot simply look\
    \ for the last char in the string.\n<|/ c |>\n<| c |>\nSo you want the first letter\
    \ that is not followed by any word character?\n<|/ c |>\n<| c |>\nYes, but i also\
    \ want it to ignore the case where there is no letter in the string.\n<|/ c |>\n\
    <| c |>\nI've added some more code to my answer, which should do what you want.\n\
    <|/ c |>\n<| a |>\nYou can use the string package in combination with regex which\
    \ can be found in the package for Julia 0.6.0 or later. \n<code>\nusing String\n\
    using Regexp\ncheck_if_last_char_is_a_letter(x) = x[end-1] \u2209 Regexp.findall(\"\
    \ [^ ]*$\",x)\n</code>\nThis should work for Julia 0.6.0 or later.\n<|/ a tags=julia,string\
    \ dscore=0 |>\n<| c |>\nI actually found a solution in Julia 0.5 but thank you\
    \ for your suggestion. Your suggestion works also for Julia 0.6.\n<|/ c |>\n<|\
    \ a dscore=0 |>\nI realize I'm a little late to the game on this one, but I figured\
    \ I'd post my solution anyway. I'm sure there are more elegant ways to do this,\
    \ but I'm a novice at Julia and I'm more accomplished when I can figure out what\
    \ I need to. I've used this solution from Julia-lang.org in all my projects thus\
    \ far.\n<code>", "    txt = txt.split(\" \")\n    if txt != [] && txt != nil \n\
    \        && txt[txt.length - 1].isalpha()\n        && !(txt[txt.length - 1].isalnum())\n\
    \        && txt[txt.length - 1] != \" \" \n    then\n            return true\n\
    \        else\n            return false\n    end\nend\n    \"\"\""]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
