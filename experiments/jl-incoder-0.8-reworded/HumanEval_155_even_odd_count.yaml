name: HumanEval_155_even_odd_count
language: jl
prompt: "\"\"\"Given an integer. return a tuple that has the number of even and odd\
  \ digits respectively.\n\n     Example:\n    >>> even_odd_count(-12)\n    (1, 1)\n\
  \    >>> even_odd_count(123)\n    (1, 2)\n    \"\"\"\nfunction even_odd_count(num::Int64)::Tuple{Int64,\
  \ Int64} \n"
tests: "using Test\n\n@testset begin\n\ncandidate = even_odd_count;\n\t@test(candidate(7)\
  \ == (0, 1))\n\t@test(candidate(-78) == (1, 1))\n\t@test(candidate(3452) == (2,\
  \ 2))\n\t@test(candidate(346211) == (3, 3))\n\t@test(candidate(-345821) == (3, 3))\n\
  \t@test(candidate(-2) == (1, 0))\n\t@test(candidate(-45347) == (2, 3))\n\t@test(candidate(0)\
  \ == (1, 0))\nend\n"
completions: ["    if num < 0\n        error(\"Need a positive/zero number\")\n  \
    \  elseif num == 0\n        return (0, 0)\n    elseif num % 2 == 0\n        return\
    \ (0, num-1)\n    else\n        return (num-1, num/2)\n    end\nend", "    if\
    \ num < 0 \n        error(\"negative numbers are not allowed\") \n    else if\
    \ num >  0 \n        return (1,1) \n    else \n        return (0, 1) \nend ",
  "    if num == 0 \n        return (1, 0) \n    else if num < 0 \n        return\
    \ (even_odd_count(-num), 1) \n    else if num % 2 == 0\n        return even_odd_count(num\
    \ / 2) + 1, 1 \n    else \n        return even_odd_count(num / 2), 1 ", "    if\
    \ num == 0 \n        (1, 0) \n    else \n        if num < 0 \n            (even_odd_count(-num),\
    \ 0) \n        else \n            (even_odd_count(num%2), 1) \n    end\nend\n\
    </cell>\n<code language=julia-0.5>\n@time even_odd_count(-123)\n@time even_odd_count(123)\n\
    </cell>\n<text>\n3.2.2 Exercise\nCalculate the number of odd digits in 123 using\
    \ recursion.", "    num::Int64\n    even::Int64 = num\n    odd::Int64 = 1\n  \
    \  for num in Int64(ceil(num))\n        even::Int64 = even + num\n        odd::Int64\
    \ = odd + num\n    end\n    return even, odd\nend\n</cell>\n<code language=julia-1.5>\n\
    # Check your function\n@code_warntype even_odd_count(-12)\n@code_warntype even_odd_count(123)\n\
    </cell>\n<text>\nTask: Compute a list that contains integers from 1 to 100 inclusive\
    \ that contain two digits:", "    if num < 0 \n        error(\"Not a number. Given\
    \ number: \", num)\n    \n    # base case\n    if num == 0\n        return (1,0)\n\
    \    \n    # recursion step\n    even, odd = even_odd_count(num/10)\n    \n  \
    \  if num % 10 == 0\n        return (even, even+1)\n    else\n        return (even,\
    \ odd+1)", "    odd = 0\n    even = 0\n    \n    for c in str(num)\n        if\
    \ c == '1'\n            even += 1\n        elseif c == '0'\n            odd +=\
    \ 1\n        end\n    end\n    return (even, odd)\nend\n</cell>\n<code language=julia-1.5>\n\
    even_odd_count(-12)\n</cell>\n<text>\nExercise 3: Tuples\nWrite a function that\
    \ computes and returns the sum of two tuples. For example,", "    if num < 0\n\
    \        error(\"The given number is not valid.\")\n    \n    let result = (0,\
    \ 0) \n    let digit = num % 10\n    \n    if digit == 0 \n        return result\n\
    \    elseif digit % 2 == 1\n        result.one = result.one + 1\n    else \n \
    \       result.two = result.two + 1\n    \n    even_odd_count(num / 10)\nend\n\
    </code>\nAs far as the function itself goes I don't think it needs any explanation\
    \ other than that it returns a tuple containing the number of even and odd digits.\
    \ Hope this helps\n<|/ a tags=julia dscore=2 |>\n<| a |>\nHere is a Julia solution\
    \ that is very similar to one I did before:\n<code>", "    if num == 0\n     \
    \   (1, 1)\n    else if num < 0\n        (1, -1)\n    else\n        odd, even\
    \ = 0, 1\n        n <- num\n        while n > 0\n            odd += n % 2 == 0\n\
    \            even += n /= 2 == 0\n            (even, odd) = (odd, even)\n    \
    \    end\n        return (even, odd)\n    end\nend\n</cell>\n<code language=julia-1.5>",
  "    if num < 0\n        error(\"The integer has to be a positive value.\")\n  \
    \  odd_count = 0\n    even_count = 0\n    for i in reverse(digits(num))\n    \
    \    if i % 2 == 1\n            even_count += 1\n        elseif i % 2 == 0\n \
    \           odd_count += 1\n        else\n            error(\"Invalid Input.\"\
    )\n    return (odd_count, even_count)\nend", "    digits = digits(num)\n    even_index\
    \ = 1\n    odd_index = length(digits) + 1\n    for i in digits\n        if i %\
    \ 2 == 0\n            even_index += 1\n        else\n            odd_index +=\
    \ 1\n    return (even_index, odd_index)\nend", "    if num < 0\n    then (0, -1)\n\
    \    else if num == 0\n    then (0, 1)\n    else\n        even, odd = 0, 0\n \
    \       while num > 0\n            num, x = div_rem(num, 10)\n            even\
    \ += 1 if x % 2 == 0 else 0\n            odd += 1 if x % 2 == 1 else 0\n     \
    \   end\n        return (even, odd)\n    end\nend\n</cell>\n<code language=julia-1.4>",
  "    if num<0 \n        error(\"num can not be negative\")\n    end\n    even::Int64\
    \ = 0\n    odd::Int64 = 0\n    for x in digits(num) \n        if x%2 == 0 \n \
    \           even+=1 \n        else \n            odd+=1 \n        end \n    \n\
    \    return even,odd\nend \n</cell>\n<code language=julia-1.6>\n@assert even_odd_count(0)==(0,\
    \ 0) \n@assert even_odd_count(1)==(1, 0) \n@assert even_odd_count(5)==(1, 1) \n\
    @assert even_odd_count(5)==(1, 1) \n@assert even_odd_count(99)==(2, 1) \n@assert\
    \ even_odd_count(99)==(2, 1) \n@assert even_odd_count(101)==(3, 1) \n@assert even_odd_count(101)==(3,\
    \ 1) \n@assert even_odd_count(10123)==(4, 1) \n@assert even_odd_count(10123)==(4,\
    \ 1) \n@assert even_odd_count(101233)==(5, 1) \n@assert even_odd_count(101233)==(5,\
    \ 1) \n@assert even_odd_count(101234)==(6, 1) \n@assert even_odd_count(101234)==(6,\
    \ 1) \n@assert even_odd_count(1012345)==(7, 1) \n@assert even_odd_count(1012345)==(7,\
    \ 1) \n@assert even_odd_count(10123457)==(8, 1) \n@assert even_odd_count(10123457)==(8,\
    \ 1) \n@assert even_odd_count(101234567)==(9, 1) \n@assert even_odd_count(101234567)==(9,\
    \ 1) \n@assert even_odd_count(1012345678)==(10, 1) \n@assert even_odd_count(1012345678)==(10,\
    \ 1) \n@assert even_odd_count(10123456788)==(11, 1) \n@assert even_odd_count(10123456788)==(11,\
    \ 1) \n@assert even_odd_count(101234567889)==(12, 1) \n@assert even_odd_count(101234567889)==(12,\
    \ 1) \n@assert even_odd_count(101234567891)==(13, 1) \n@assert even_odd_count(101234567891)==(13,\
    \ 1) \n@assert even_odd_count(1012345678910)==(14, 1) \n@assert even_odd_count(1012345678910)==",
  "    \"\"\"\n    Odd even\n    \"\"\"\n    let res = (num, num%2)\n    \n    return\
    \ res\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Given an integer. return\
    \ a tuple that has the number of even and odd digits respectively.", "    if num\
    \ >= 0\n        oddNum = ceil(num/10)\n        evenNum = num - oddNum * 10\n \
    \       return (evenNum, oddNum)\n    else\n        oddNum = ceil(num/10)\n  \
    \      evenNum = num - oddNum * 10\n        return (evenNum, oddNum)\n    end\n\
    end\n</cell>\n<code language=julia-1.3>\neven_odd_count(-22)\n</cell>\n<text>\n\
    Write a function that takes two integers and a number between -100 and 100. Return\
    \ a tuple that contains two integers. Each integer represents the absolute value\
    \ of the difference between the two numbers. In other words, return the absolute\
    \ value of the difference between the two numbers. Your function should only take\
    \ two integers and a number between -100 and 100", "    digits = num % 10\n  \
    \  (even, odd) = (0, 0)\n    if digits < 2 \n        return (0, 0)\n    elseif\
    \ digits == 2 \n        return (even+1, odd+1)\n    elseif digits % 2 == 0 \n\
    \        return even+1, odd+1\n    else\n        even, odd = even_odd_count(num/10)\n\
    \        return (even+1, odd+1)\n    end\nend", "    if num < 0\n    then (even_odd_count(-num),\
    \ 1) else\n        odd_count = even_count = 0\n        while num != 0\n      \
    \      odd_count = odd_count + 1\n            num = num // 10\n            even_count\
    \ = even_count + 1\n        end\n        return (odd_count, even_count)\nend",
  "    odd::Int64 = num % 10\n    even::Int64 = num / 10\n    (even, odd)\nend\n</cell>\n\
    <text>\nO(N)", "    even = num/10\n    odd = num%10\n    return (even, odd)\n\
    end ", "    if num == 0 then return (1, 0)\n    even, odd = 0, 1\n    pos = 1\n\
    \    while num > 0\n        if num % 2 == 0 then\n            even = even * pos\
    \ + num % 2\n            pos += 1\n        else \n            odd = odd * pos\
    \ + num % 2\n            pos += 1\n        num = num / 2\n    return (even, odd)\n\
    end\n</cell>\n<code language=julia-1.3>\n@time even_odd_count(-123)\n@time even_odd_count(1234567890)\n\
    </cell>\n<text>\nLet's look at performance!\nNow let's compare the performance\
    \ of the functions we wrote above.", "    count = (0,0)\n    number = num\n  \
    \  while number > 0\n        quotient, remainder = divmod(number, 10)\n      \
    \  odd_count = (quotient - 1, remainder % 2)\n        even_count = (quotient,\
    \ remainder % 2)\n        count = odd_count + even_count\n        number = remainder\n\
    \    end\n    return count\nend", "    even_odd_count_digits = 0\n    even_odd_count_digits_even\
    \ = 0\n    even_odd_count_digits_odd = 0\n    even = 0\n    odd = 0\n    if num\
    \ > 0\n        num, digits = num % 10, floor(log10(num))\n        while digits\
    \ > 0\n            if num % 2 == 0\n                even = even+1\n          \
    \  else\n                odd = odd+1\n            num = num/10\n            digits\
    \ = digits-1 \n        end\n        return even, odd\n    else\n        return\
    \ 1, 1\n    end\nend\n</cell>\n<text>\nExercise 4\nWrite a function that calculates\
    \ how many digits of a positive integer are greater or less than a specified digit.\
    \ For example, a function that calculates how many digits are greater than 1 of\
    \ a number 12345678 would be called as even_more_digits(12345678, 2).", "    if\
    \ num < 0 \n        error(\"Argument must be positive\")\n    elseif num == 0\n\
    \        (1, 1)\n    elseif num % 2 == 0\n        even_odd_count(num / 2)\n  \
    \  else\n        even_odd_count(num / 2) + 1\n    end\nend\n</cell>\n<code language=julia-1.0>",
  "    if num == 0\n        (1, 1)\n    elif num < 0\n        (1, 0)\n    else\n \
    \       num == abs(num)\n        odd_count = 0\n        even_count = 0\n     \
    \   \n        for i in num\n            if i%2 == 0\n                even_count\
    \ = even_count + 1\n            elseif i%2 == 1\n                odd_count = odd_count\
    \ + 1\n            else\n                println(\"Error - input must be non-negative.\"\
    )\n        end\n        return (odd_count, even_count)\n    end\n    return (0,\
    \ 0)\nend", "    evens = Int(0)\n    odds = Int(0)\n    digit = Int(0)\n    #\
    \ even = Int(0)\n    # odd = Int(0)\n    while num != 0\n        digit = num %\
    \ 10\n        if digit % 2 == 0\n            evens += digit\n        else\n  \
    \          odds += digit\n        num = num / 10\n    # return (evens, odds)\n\
    \    return (evens, odds)\nend\n</cell>\n<code language=julia-1.5>", "    if num\
    \ == 0 \n        (1, 0) \n    else if num < 0 \n        (-1, 0) \n    else if\
    \ num % 2 == 0 \n        (even_odd_count(num / 2), 1) \n    else \n        (even_odd_count(num\
    \ / 2), 0) \n    end\nend\n</cell>\n<code language=julia-1.4>\n@doc even_odd_count(123)\n\
    </cell>\n<text>\nPutting it all together", "    if num<0\n        error(\"Argument\
    \ must be positive\",num)\n    end", "    if num > 0 \n        count_even = 0\
    \ \n        count_odd = 0 \n        while num > 0 \n            digit = num %\
    \ 10 \n            num = num / 10 \n            if digit % 2 == 0 \n         \
    \       count_even += 1 \n            elseif digit % 2 == 1 \n               \
    \ count_odd += 1 \n            end\n        end\n        return (count_even, count_odd)\n\
    \    elseif num < 0 \n        return (0,0) \n    else\n        print(\"Input must\
    \ be a positive integer.\")\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    even_odd_count(-12)\n</cell>\n<text>\nWrite a julia function called even_odd_count_recursive.\
    \ This function has one parameter num. num will be an Int64 number. Your function\
    \ should return the tuple (count_even, count_odd) where count_evenis the number\
    \ of even digits and count_oddis the number of odd digits in num.", "    if num\
    \ < 0 \n        error(\"This function only works when num >= 0\")\n    end\n \
    \   odd = num % 10\n    even = (num//10)%10\n    return (even, odd)\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=0 |>\nI do not know Julia but this is a simple\
    \ solution in python.\n<code>\ndef even_odd_count(x):\n    even = x % 10\n   \
    \ odd = (x % 10) + 10\n    if even % 2 != 0 and odd % 2 != 0:\n        return\
    \ odd, even\n    elif even % 2 != 0 and odd % 2 == 0:\n        return odd, even\n\
    \    elif even % 2 == 0 and odd % 2 != 0:\n        return odd, even\n    elif\
    \ even % 2 == 0 and odd % 2 == 0:\n        return odd, even\n    else:\n     \
    \   return odd, odd\n</code>\n<|/ a tags=julia,algorithm,function |>\n<| a dscore=0\
    \ |>\nHere is my implementation in Python, which works fast on integers up to\
    \ 10**9.\n<code>\ndef even_odd_count(x):\n    if x < 0:\n        raise ValueError(\"\
    Negative number\")", "    if num == 0 \n        return (1, 1)\n    else if num\
    \ % 2 == 0\n        even, odd = 0, 0\n    else\n        even, odd = 1, 0\n   \
    \ for i in reverse(split(num))\n        if i % 2 == 0\n            even += 1\n\
    \        else\n            odd += 1\n    return (even, odd)\nend", "    if num\
    \ < 0 \n        error(\"Parameter must be positive\")\n    end", "    even_count\
    \ = 0\n    odd_count = 0\n    for i in num:\n        if(i%2==0)\n            even_count+=1\n\
    \        else\n            odd_count+=1\n    return (even_count, odd_count)\n\
    end\n</cell>\n<code language=julia-0.5>\n@time even_odd_count(-2)\n</cell>\n<text>\n\
    Exercise\nUse the function above to count how many times a number is divisible\
    \ by 2.", "    if num < 0\n    then return (1,0)\n    else\n        count_even_odd(num)\n\
    \    end\nend", "    # To get the odd and even digits, we add two numbers. \n\
    \    # One is the numerator and the other is the denominator. \n    # If the numerator\
    \ is odd, the even-digits count is 1. If it is even, the odd-digits count is 1.\
    \ \n    even_digits = num % 10 \n    odd_digits = num / 10 \n    count = 1 if\
    \ even_digits % 2 == 1 else 2 \n    return count, odd_digits\nend\n</cell>\n<code\
    \ language=julia-0.5>\neven_odd_count(-12)\n</cell>\n<code language=julia-0.5>\n\
    even_odd_count(123)\n</cell>\n<text>\nPart 2: Count the number of times each digit\
    \ appears in a number\nHere you will write a function that counts the number of\
    \ times each digit appears in an integer. The digits appear twice if they are\
    \ 0 and twice if they are 1. If the number does not have a digit at all, then\
    \ zero digits are considered to be a count as well.", "    \n    even, odd = 0,\
    \ 0\n    while num != 0\n        even, odd = num % 10 % 2, num % 10\n        num\
    \ = num / 10\n    end\n    return (even, odd)\nend\n</cell>\n<code language=julia-1.0>\n\
    @assert even_odd_count(-12) == (1, 1)\n@assert even_odd_count(123) == (1, 2)\n\
    </cell>\n<code language=julia-1.0>\nusing BenchmarkTools", "    if num < 0\n \
    \       error(\"Argument must be positive\")\n    \n    if num <= 0\n        return\
    \ (0,0)\n    \n    sumEven = 1\n    sumOdd = 1\n    \n    while num > 0\n    \
    \    if num mod 2 == 0\n            sumEven *= 2\n            num /= 2\n     \
    \   else\n            sumOdd *= 2\n            num /= 2\n    end\n    return (sumEven,\
    \ sumOdd)\nend\n</cell>\n<code language=julia-1.0>\n@test even_odd_count(-12)\
    \ == (1, 1)\n</cell>\n<code language=julia-1.0>\n@test even_odd_count(123) ==\
    \ (1, 2)\n</cell>\n<text>\nExercise\nWrite a function named count_n_digits_even,\
    \ that has one argument named n and returns the number of digits in n, that is,\
    \ the number of times you need to multiply a number to make it to an integer.",
  "    if num < 0 \n        error(\"Argument is negative\")\n    end", "  if num <=\
    \ 0 \n    return (0, 0)\n  \n  even, odd = 0, 1\n  for i in 2..num\n    if num\
    \ % i == 0\n      even += 1\n    else\n      odd += 1\n    end\n  end\n  return\
    \ (even, odd)\nend", "    even=num%2==0\n    odd=num%2!=0\n    if even==true\n\
    \        even+=odd\n        odd=0\n    \n    (even, odd)\n    end\nend\n</cell>\n\
    <code language=julia-0.4>\n@code_warntype even_odd_count(-12)\n</cell>\n<code\
    \ language=julia-0.4>\n@code_warntype even_odd_count(123)\n</cell>\n<text>\nPractice\n\
    Write a function to find the largest palindrome made from the product of two 3\
    \ digit numbers.\nExample: For a palindrome to be considered a palindrome, it\
    \ should have the form \u201C99999\u201D. \n(Examples: 999(9) 999(9) 999(9) 999(9)\
    \ 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9)\
    \ 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9)\
    \ 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9)\
    \ 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9)\
    \ 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9)\
    \ 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9)\
    \ 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9)\
    \ 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) 999(9) ",
  "    if num < 0 then throw(ArgumentError(\"The value of num must be positive.\"\
    ))\n    even_digit, odd_digit = 0, 0\n    sum_digit = 0\n    while num != 0\n\
    \        sum_digit = sum_digit + num % 10\n        num = num // 10\n    end\n\
    \    \n    if sum_digit == 0 then throw(ArgumentError(\"The sum of the digits\
    \ should be zero.\"))\n    if sum_digit == 1 then return (1, 1)\n    \n    while\
    \ sum_digit > 9\n        sum_digit = sum_digit - 10\n        even_digit = even_digit\
    \ + 1\n    end", "    if num<0\n        error(\"not implemented\")\n    end\n\
    \    if num==0\n        return (1, 1)\n    end\n    odd_count = 0\n    even_count\
    \ = 0\n    while num>0\n        if num%2==0\n            even_count += 1\n   \
    \         num /= 2\n        else\n            odd_count += 1\n            num\
    \ = (num-1)/2\n        end\n    end\n    return even_count, odd_count\nend\n</cell>\n\
    <cell>\n@doc test_even_odd_count\n</cell>\n<text>\nWe will now implement the function\
    \ is_palindrome(), which should take in a string and check if it is a palindrome.\
    \ It takes in an integer and returns the palindrome if it is or else prints \"\
    Not a palindrome\".", "    odd_count::Int64 = 0\n    even_count::Int64 = 0\n \
    \   if num == 0\n        return (1, 1)\n    if num < 0\n        return (-1, 0)\n\
    \    \n    for i in num\n        if i % 2 == 0\n            even_count += 1\n\
    \        else\n            odd_count += 1\n    return (even_count, odd_count)\n\
    end\n</cell>\n<code language=julia-1.5>\n@code_warntype even_odd_count(-12)\n\
    </cell>\n<text>\nExercise 3\nWrite a function to calculate the number of prime\
    \ factors for a given number.", "    if num < 0 \n        throw(ArgumentError(\"\
    The number can not be negative\"))\n    even = 0\n    odd = 0\n    for ele in\
    \ num\n        if ele < 0\n            throw(ArgumentError(\"The element can not\
    \ be negative\"))\n        if ele % 2 == 0\n            even += 1\n        else\n\
    \            odd += 1\n    return (even, odd)\nend\n</cell>\n<code language=julia-1.2>",
  "    if num < 0 \n    then return (1, 0) \n    else \n        odd_count = floor(sqrt(num));\
    \ \n        if odd_count == 1 \n        then return (1, 1) \n        else return\
    \ (odd_count, odd_count-1) \n    end\nend\n</cell>\n<code language=julia-1.3>",
  "    if num < 0\n    (1, 0)\n    end\n    function even_odd_count(num::Int64)\n\
    \        even = num % 2 == 0\n        odd = !even\n        return (even + odd,\
    \ odd)\n    end\nend", "    if num < 0 \n        throw(DomainError(`num`, \" not\
    \ allowed for even or odd count\"))\n    else if num < 10\n        return (num,\
    \ 1)\n    else\n        \n        # find all even numbers less than 10\n     \
    \   even = findall(x->x%2 == 0, num.digits)\n        \n        # find the number\
    \ of odd digits\n        odd = length(filter(x -> x == 2, num.digits)) \n    \
    \    \n        return (length(even), odd)\nend\n</cell>\n<code language=julia-1.0>\n\
    # find number of even and odd digits\neven_odd_count(-12)\n</cell>\n<text>\nReview\
    \ of Challenges\nIn this last chapter we will review our very first challenge.\
    \ This challenge is all about solving the problem at hand. We will look at what\
    \ we learned in the last chapter and then see if we can answer the question from\
    \ the first chapter. From the time we learned the solution to the first challenge\
    \ we will have a good chance of revisiting the problem at hand in the future.\
    \ So, to begin let's look at the problem again from the first chapter. Consider\
    \ the question: What is the largest even integer that is smaller than $10^9$?",
  "    if num < 0\n        error(\"Input must be greater than 0\")\n    else if num\
    \ == 0\n        return (0, 0)\n    elseif num == 1\n        return (1, 0)\n  \
    \  elseif num % 2 == 0\n        return (num / 2, num % 2)\n    else\n        return\
    \ (num / 2 + 1, num % 2)\n    end\nend\n</cell>\n<code language=julia-1.5>\neven_odd_count(-12)\n\
    </cell>\n<code language=julia-1.5>", "  if num >= 0\n    return (even_odd_count(num/10),\
    \ num%10) end\n  return (-1, 0)\nend\n</cell>\n<cell>\n@time even_odd_count(123)\n\
    </cell>\n<text>\nProblem 3: Find the sum of all the numbers from 1 to 20 that\
    \ are divisible by 7 and are not a multiple of 3", "    if num == 0 \n       \
    \ (1, 0) \n    else if num < 0 \n        (0, 0) \n    elseif num < 10 \n     \
    \   (0, 1) \n    else if num < 100 \n        (1, 1) \n    elseif num < 1000 \n\
    \        (2, 1) \n    elseif num < 10000 \n        (3, 2) \n    elseif num < 100000\
    \ \n        (4, 3) \n    elseif num < 1000000 \n        (5, 4) \n    elseif num\
    \ < 10000000 \n        (6, 5) \n    elseif num < 100000000 \n        (7, 6) \n\
    \    elseif num < 1000000000 \n        (8, 7) \n    elseif num < 10000000000 \n\
    \        (9, 8) \n    elseif num < 100000000000 \n        (10, 9) \n    elseif\
    \ num < 1000000000000 \n        (11, 10) \n    elseif num < 10000000000000 \n\
    \        (12, 11) \n    elseif num < 100000000000000 \n        (13, 12) \n   \
    \ elseif num < 1000000000000000 \n        (14, 13) \n    elseif num < 10000000000000000\
    \ \n        (15, 14) \n    elseif num < 100000000000000000 \n        (16, 15)\
    \ \n    elseif num < 1000000000000000000 \n        (17, 16) \n    elseif num <\
    \ 10000000000000000000 \n        (18, 17) \n    elseif num < 100000000000000000000\
    \ \n        (19, 18) \n    elseif num < 1000000000000000000000 \n        (20,\
    \ 19) \n    elseif num < 10000000000000000000000 \n        (21, 20) \n    elseif\
    \ num < 100000000000000000000000 \n        (22, 21) \n    elseif num < 1000000000000000000000000\
    \ \n        (23, 22) \n    elseif num < 10000000000000000000000000 \n        (24,\
    \ 23) \n    elseif num < 100000000000000000000000000 \n        (25, 24) \n   \
    \ elseif num < 1000000000000000000000000000 \n        (26, 25) \n    elseif num\
    \ < 10000000000000000000000000000 \n        (27, 26) \n    elseif num < 100000000000000000000000000000\
    \ \n        (28, 27) \n    elseif num < 1000000000000000000000000000000 \n   \
    \     (29, 28) \n    elseif num < 10000000000000000000000000000000 \n        (30,\
    \ 29) \n    elseif num < 100000000000000000000000000000000 \n        (31, 30)\
    \ \n    elseif num < 1000000000000000000000000000000000 \n        (32, 31) \n\
    \    elseif num < 10000000000000000000000000000000000 \n        (33, 32) \n  \
    \  elseif num < 100000000000000000000000000000000000 \n        (34, 33) \n   \
    \ elseif num < 1000000000000000000000000000000000000 \n        (35, 34) \n   \
    \ elseif num < 10000000000000000000000000000000000000 \n        (36, 35) \n  \
    \  elseif num < 1000000000000000000", "    if num < 0 then return (1, 1) end\n\
    \    if num == 0 then return (0, 0) end\n    even = 0\n    odd = 0\n    for x\
    \ in digits(num) do \n        if x == \"0\" then even += 1 else odd += 1 end\n\
    \    end\n    return (even, odd)\nend\n</cell>\n<cell>\n# test your function\n\
    @testset \"even_odd_count tests\" begin\n    @test even_odd_count(-12) == (1,\
    \ 1)\n    @test even_odd_count(123) == (1, 2)\n    @test even_odd_count(0) ==\
    \ 0\nend\n</cell>\n<text>\nExercise 7: Odd Even Sum\nIn this exercise, given an\
    \ integer $n$ find the sum of the numbers that have the property of being odd\
    \ and even.", "    even, odd = 0, 0\n    while num > 0\n        push!(even, num\
    \ % 10)\n        num /= 10\n        push!(odd, num % 10)\n        num /= 10\n\
    \    end\n    return even, odd\nend\n</cell>\n<code language=julia-1.6>\neven_odd_count(-10)\n\
    </cell>\n<code language=julia-1.6>", "    if num == 0\n        return (1,0)\n\
    \    if num == 1\n        return (0, 1)\n    odd_count = 0\n    even_count = 0\n\
    \    for digit in num\n        if digit % 2 == 0\n            even_count += 1\n\
    \        else\n            odd_count += 1\n    return (even_count, odd_count)\n\
    end\n</cell>\n<code language=julia-1.5>", "    if num<0\n    then (0, -1)\n  \
    \  else\n        odd_count_helper(num, 0)\n    end\nend", "    if num == 0\n \
    \       return (0,0)\n    elseif num < 0\n        return (1,1)\n    elseif num\
    \ < 100\n        return (1,0)\n    else\n        digits = num % 10\n        odd_count\
    \ = num / 10\n        return (even_odd_count(odd_count),even_odd_count(digits))\n\
    end\n</cell>\n<cell>", "    if num < 0\n    then (0, 1)\n    elseif num == 0\n\
    \    then (0, 1)\n    else\n        odd_digits = count_digits(num)\n        even_digits\
    \ = length(num) - odd_digits\n        return (even_digits, odd_digits)\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\n#=\nGiven an integer. return a tuple\
    \ that has the number of even and odd digits respectively.", "  local even, odd\
    \ = 0, 0\n  for _ in pairs(digits(num)) do\n    digit = digit(_)\n    if digit\
    \ % 2 == 0 then even += 1 else odd += 1\n  end\n  return even, odd\nend\n</cell>\n\
    <text>\nExercise 17", "    if num < 0\n        error(\"The number should be non-negative!\"\
    )\n    else\n        even_odd_count_helper(num)\n    end\nend", "    even, odd\
    \ = 0, 0\n    for digit in num % 10\n        even = even + 1 if digit % 2 == 0\
    \ else 0\n        odd = odd + 1 if digit % 2 == 1 else 0\n    return (odd, even)",
  "    even = 0\n    odd = 0\n    for digit in num:\n        if digit % 2 == 0:\n\
    \            even += 1\n        else:\n            odd += 1\n    return even,\
    \ odd\nend\n</cell>\n<code language=julia-1.6>", "    even_count = 0\n    odd_count\
    \ = 0\n    if num < 0\n        error(\"negative number\")\n    elseif num == 0\n\
    \        even_count = 1\n        odd_count = 1\n    else\n        while num !=\
    \ 0\n            if num % 2 == 0\n                even_count += 1\n          \
    \      num /= 2\n            else\n                odd_count += 1\n          \
    \      num /= 2\n        end\n    end\n    return (even_count, odd_count)\nend\n\
    </cell>\n<code language=julia-1.5>\n# Testing even_odd_count\neven_odd_count(-12)\n\
    </cell>\n<code language=julia-1.5>", "    if num < 0 \n        return 0, 0\n \
    \   ans = floor(log10(abs(num))) + 1, floor((log2(num))/3)\n    even = sum((num\
    \ / pow(10, i)).*(pow(2, i)) for i in ans[2:2:end])\n    odd = sum((num / pow(10,\
    \ i)).*(pow(2, i)) for i in ans[2:2:end]) - even\n    return even, odd\nend\n\
    </cell>\n<code language=julia-1.6>\neven_odd_count(-12)\n</cell>\n<code language=julia-1.6>\n\
    even_odd_count(123)\n</cell>\n<code language=julia-1.6>", "    if is_even(num)\n\
    \        return (1, 0)\n    else \n        return (0,1)\n    end\nend\n</cell>\n\
    <text>\nExercise 18\nWrite a function count_even_odd_digits(num::Int64)::Int64\
    \ which given a number, returns the number of even and odd digits.", "    if num\
    \ < 0 \n        error(\"$num must be positive\")\n    end\n    evens = Int(0)\n\
    \    odds = Int(0)\n    for n in reverse(sort(digits(num))) \n        if n%2==0\n\
    \            evens += 1 \n        end\n        if n%3==0 \n            odds +=\
    \ 1 \n        end\n    end\n    return (evens, odds)\nend\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"Write a function which can compute a factorial. \nIt should take in one\
    \ argument, which is the number to compute factorial of.\nThe function should\
    \ return factorial of number as Int64.", "if num < 0\n    error(\"This is not\
    \ an Int64 number\")\nelse\n    return even_odd_count_(num, 1, 0)\nend", "   \
    \ if num < 0 then \n        (1,0)\n    elseif num==0 then\n        (0, 1)\n  \
    \  else\n        (even_odd_count(num/10), even_odd_count(num%10))\n    end\nend\n\
    </cell>\n<code language=julia-1.3>\neven_odd_count(0)\n</cell>\n<code language=julia-1.3>\n\
    even_odd_count(-1)\n</cell>\n<text>\nIn Julia 1.0 you do not need to include this\
    \ package. Julia 1.0 will automatically find this package for you. In Julia 1.0\
    \ we now have two ways of defining functions: by explicitly writing out the function\
    \ and explicitly calling it, or by defining them in a package. In the first case\
    \ we would call the function directly by writing out the function name and arguments\
    \ after it. In the second case we would define a function in a package by writing\
    \ out the function name and arguments and the package name and then defining the\
    \ function with the function keyword.", "    digits = num % 10\n    num = num\
    \ / 10\n    if num > 0\n        return (1, digits)\n    else\n        return (2,\
    \ digits)\nend\n</cell>\n<code language=julia-1.6>\neven_odd_count(123)\n</cell>\n\
    <text>\nExercise (2) (Optional)", "    if num<0\n        throw(ArgumentError(\"\
    only positive numbers can be count\"))\n    else if num<10\n        return (1,\
    \ 1)\n    else if num%2 == 0\n        return (1, 0)\n    else if num%2 != 0\n\
    \        return (0, 1)\n    end\n    even_odd_count(num/2)\nend\n</cell>\n<text>\n\
    Exercise 1: Test for even and odd numbers separately\nTo test if a number is even\
    \ or odd, we use the even_odd_count() function you wrote earlier. Let's try it:",
  "    if num < 0\n        return 0, 0\n    even_sum = 0\n    odd_sum = 0\n    while\
    \ num >= 1\n        if num % 2 > 0\n            odd_sum += num % 2\n         \
    \   num /= 2\n        else\n            even_sum += num % 2\n            num /=\
    \ 2\n    end\n    return even_sum, odd_sum\nend", "    if num < 0\n        (1,\
    \ 0)\n    elseif num == 0\n        (0, 1)\n    else\n        num_even = 0\n  \
    \      num_odd = 0\n        digits = to_string(num)\n        for d in digits\n\
    \            digit = digits[d]\n            if digit == 0\n                num_even\
    \ += 1\n            elseif digit == 1\n                num_odd += 1\n        end\n\
    \        (num_even, num_odd)\n    end\nend\n</cell>\n<code language=julia-1.5>",
  "    if num < 0\n        error(\"The input must be positive\", throw=true)\n   \
    \ if num == 0\n        return (0, 1)\n    # Even number case\n    if num % 2 ==\
    \ 0\n        return (num / 2, 1)\n    # Odd number case\n    num2 = num % 2\n\
    \    # Get the number of even digits in the num2\n    even_count = 0\n    while\
    \ num2 != 0\n        even_count = even_count+1\n        num2 = num2 div 2\n  \
    \  # Get the number of odd digits in the num2\n    odd_count = num2 - even_count\n\
    \    return (even_count, odd_count)\nend\n</cell>\n<code language=julia-1.0>",
  "    if num < 0\n        error(\"The given number should be non-negative\")\n  \
    \  end\n    if num == 0\n        return (0, 0)\n    end\n    (even, odd) = (0,\
    \ 1)\n    for i in 2:num\n        if i % 2 != 0\n            even = even * i\n\
    \        else\n            odd = odd * i\n        end\n    end\n    return (even,\
    \ odd)\nend", "    if num < 0\n        error(\"Not a number\")\n    elseif num\
    \ == 0\n        (1, 1)\n    else\n        if num < 0\n            error(\"Not\
    \ a number\")\n        else\n            even_odd_count(floor(div(num, 2)))\n\
    \        end\n    end\nend\n</code>\n<|/ a tags=julia dscore=2 |>\n<| a tags=julia\
    \ |>\nHere are two functions which use tail recursion to compute the number of\
    \ even and odd digits in an Int64:\n<code>", "    if num < 0\n    error(\"The\
    \ input is negative\")\n    else if num ==0\n    (1, 1)\n    else \n        if\
    \ num % 2 == 0\n            even = num // 2\n            odd = (num -1) // 2\n\
    \            return (even, odd)\n        else\n            even = (num -1) //\
    \ 2\n            odd = num // 2\n            return (even, odd)\n        end\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>", "    if num < 0 \n       \
    \ error(\"Bad argument\")\n    end\n    if num == 0\n        return (1, 0)\n \
    \   elseif num % 2 == 0\n        return (num / 2, 1)\n    else\n        return\
    \ (num / 2 + 1, num % 2)\n    end\nend\n</cell>\n<text>\nNow let's create a function\
    \ that takes an array of integers and return the number of even and odd digits\
    \ in the array.", "    even::Int64 = 1\n    odd::Int64 = 1\n    for n in num\n\
    \        even += n rem 2 == 0\n        odd += n rem 2 != 0\n    return (even,\
    \ odd)\nend\n</cell>\n<code language=julia-1.4>\n\"\"\"Given an integer. return\
    \ two numbers that sum to the integer.", "    if num==0 \n        return (0, 0)\n\
    \    \n    count1 =0\n    count2 =0\n    while num > 0 do\n        digit = num%10\n\
    \        num = (num - digit)/10\n        if digit%2 ==0 \n            count1+=1\n\
    \        else \n            count2+=1\n    end\n    return (count1, count2)\n\
    end", "    if num<0\n        error(\"Input must be positive. \")\n    else\n \
    \       if num == 0\n            tuple = (1, 1)\n        else\n            tuple\
    \ = (0, 1)\n            digit = num\n            while digit > 0\n           \
    \     digit = digit/2\n                tuple = (tuple[1] + 1, tuple[1] if tuple[1]\
    \ % 2 == 1 else tuple[1])\n            end\n        end\n    end\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThank you for your answer which gives me the correct results\
    \ for integers greater than 0.\n<|/ c |>\n<| a |>\n<code>", "    if num == 0\n\
    \        return (0, 2)\n    if num < 0\n        throw(ArgumentError(\"The input\
    \ should be positive\"))\n    elseif num % 2 == 0\n        return (1, num/2)\n\
    \    else\n        odd_count = num/2 + 1\n        return odd_count, odd_count\n\
    end\n</cell>\n<code language=julia-1.4>\n# run this cell to test your code\n@code_warntype\
    \ even_odd_count(-12)\n@code_warntype even_odd_count(123)\n</cell>\n<text>\nWrite\
    \ a function that accepts two positive integers and returns the sum of the squares\
    \ of their digits.\nExample: \nIf the input number is 15. the output should be\
    \ 3125. \nIf the input number is -12 the output should be -84.\nHint: Use your\
    \ existing function even_odd_count that you created earlier to get started with\
    \ this problem.", "    if num<0 \n        error(\"num<0\")\n    end\n    \n  \
    \  even=0\n    odd=0\n    for i in reverse(map(Int64, digits(num))) \n       \
    \ if i%2==0 \n            even+=1 \n        elseif i%2 != 0 \n            odd+=1\
    \ \n        end \n    end\n    return (even, odd)\nend", "    if num < 0 \n  \
    \      return (0, 0)\n    else \n        return (sum(x == 1 for x in take_while(bool,\
    \ num_digits(num))), (sum(x != 1 for x in take_while(bool, num_digits(num))))\
    \ ) \nend", "    even::Int64 = 0\n    odd::Int64 = 0\n    for n in num\n     \
    \   if n % 2 == 0\n            even += 2\n        else \n            odd += 2\n\
    \    end", "    if num<0\n        return (1,0)\n    if num==0\n        return\
    \ (1,0)\n    if num==1\n        return (0,1)\n    if num%2==0\n        return\
    \ (num+1,1)\n    else\n        return (num-1,0)\n    end\nend", "    if num <\
    \ 0\n        throw(ArgumentError(\"`num` must be positive.\"))\n    end\n    even,\
    \ odd = 0, 0\n    for i in reverse(split(str(num),\"\"))\n        if i % 2 ==\
    \ 0\n            even += 1\n        else\n            odd += 1\n        end\n\
    \    end\n    return even, odd\nend\n</cell>\n<text>\nExercise 14 - even_odd_count\n\
    Write a function even_odd_count(num::Int64) which takes in an integer and returns\
    \ a tuple that has the number of even and odd digits respectively.", "    even,\
    \ odd = 0, 0\n    while num > 0\n        digit = num % 10\n        if digit %\
    \ 2 == 0\n            even += digit\n        else\n            odd += digit\n\
    \        num /= 10\n    return (even, odd)\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert @even_odd_count(-12) == (1, 1)\n@assert @even_odd_count(123) == (1, 2)\n\
    </cell>\n<text>\n3.4.4 Other types of numbers", "    if num == 0 || (num > 0 &&\
    \ num < 0)\n        return (0,0)\n    else if num < 0\n        num = -num\n  \
    \      odd, even = 1, -1\n    elseif num > 0\n        even, odd = 0, 0\n     \
    \   for i in 2 to ceil(num/2) \n            if num % i == 0\n                even\
    \ = even + 1\n            else \n                odd = odd + 1\n    return ((even,\
    \ odd))\nend", "    if num == 0\n    (1, 0)\n    else if num % 2 == 0\n    (2,\
    \ 0)\n    else\n    (even_odd_count(floor(num / 2)) + 1, 1 + even_odd_count(ceil(num\
    \ / 2)))\nend", "    if num < 0\n        error(\"Invalid argument\")\n    end",
  "    count = 0\n    for d in num%10 where num%10 != 0 {\n        count += num%10\
    \ == 0\n        num//= 10\n    }\n    return (count,count)\nend ", "    if num\
    \ < 0\n        error(\"The input must be positive\")\n    elseif num == 0\n  \
    \      (1, 1)\n    else\n        even_odd_count(floor(sqrt(num))) + {num % 2 ==\
    \ 0, num % 2 != 0}\nend\n</cell>\n<code language=julia-1.3>", "        if num\
    \ < 0\n        then (1, 0) \n        else\n            even_count = (num % 2 ==\
    \ 0)\n            odd_count = !(even_count)\n            (even_count, odd_count)\n\
    \        end\nend\n</cell>\n<code language=julia-1.0>", "    if num < 0\n    \
    \    return (1, 1)\n    even = 0\n    odd = 0\n    while num > 0\n        num,\
    \ rem = divmod(num, 10)\n        if rem == 0\n            even += 1 if num ==\
    \ 0 else 0\n            odd += 1 if num != 0 else 0\n        end\n    return even,\
    \ odd\nend", "    if num < 0 \n        error(\"negative number\")\n    \n    even_count\
    \ = 0\n    odd_count = 0\n    while num != 0\n        dig = num % 10\n       \
    \ if dig == 0 \n            odd_count += 1\n        else \n            even_count\
    \ += 1\n        num /= 10\n    return (even_count, odd_count)", "    even::Int64\
    \ = 0\n    odd::Int64 = 0\n    for x in num\n        local temp = x - int(x)\n\
    \        if temp % 2 == 0\n            even = even + 1\n        else\n       \
    \     odd = odd + 1 \n        end\n    end\n    return (even, odd)\nend\n</cell>\n\
    <text>\nThe next cell contains the function which takes an array as input and\
    \ returns the product of all the elements of the array. The function should raise\
    \ an error if the given array is empty.", "    if num < 0 return (-1, -1) \n \
    \   even, odd = 0, 0\n    while num > 0 \n        num = num mod 10 \n        if\
    \ num == 0 \n            even += 1 \n        else \n            odd += 1 \n  \
    \  return (even, odd) \n</code>\n<|/ a tags=python,algorithm,performance,math\
    \ |>\n<| a tags=python,algorithm,performance,math |>\nThe fastest solution I found\
    \ so far:\n<code>\ndef count_digits(n):\n    return len([d for d in str(n) if\
    \ d == '0'])\n</code>\n<|/ a dscore=0 |>\n<| a |>\nI tried to compare the speed\
    \ of code with previous answers, I found that using 'num//10' is faster than using\
    \ mod, because the mod operator is slower than division(//). So I tried the code\
    \ on different systems(ubuntu and windows) and found the speed of using \"num//10\"\
    \ faster than using mod, on ubuntu 16.04 python 2.7.13. I know this is not a very\
    \ accurate speed comparison, because it does not account for the time spent on\
    \ IO and other processes. But it can be considered as faster than using mod, because\
    \ its result only contains '0's.\n<code>\nimport time\nimport numpy as np\na =\
    \ np.arange(100000)\nb = a//10\nprint(a)\nprint(b)\nstart_time = time.time()\n\
    for i in range(10000):\n    c = np.mod(a,10)\nend_time = time.time()\nprint('time\
    \ spent on mod is', end_time - start_time)\nstart_time = time.time()\nfor i in\
    \ range(10000):\n    c = np.floor_divide(a,10)\nend_time = time.time()\nprint('time\
    \ spent on floor_divide is', end_time - start_time)\nstart_time = time.time()\n\
    for i in range(10000):\n    c = np.floor_divide(a,10)\nend_time = time.time()\n\
    print('time spent on floor_divide is', end_time - start_time)\nstart_time = time.time()\n\
    for i in range(10000):\n    c = (a//10).astype(int)  \nend_time = time.time()\n\
    print('time spent on floor_divide is', end_time - start_time)\nstart_time = time.time()\n\
    for i in range(10000):\n    c = (a//10).astype(int)  \nend_time = time.time()\n\
    print('time spent on floor_divide is', end_time - start_time)\nstart_time = time.time()\n\
    for i in range(10000):\n    c = (a//10).astype(int)  \nend_time = time.time()\n\
    print('time spent on floor_divide is', end_time - start_time)\n</code>\nThe results\
    \ are as follows\nubuntu 16.04 python3.6\n<code>\n[   0   1   2   3   4   5  \
    \ 6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  ", "    if num\
    \ < 0\n    error(\"negative number\")\n    endif\n    if num == 0\n    (1, 1)\n\
    \    endif", "    if num < 0 then return (1, 0)\n    if num < 10 then return (1,\
    \ 1)\n    if num < 100 then return (1, 2)\n    if num < 1000 then return (1, 3)\n\
    \    if num < 10000 then return (1, 4)\n    if num < 100000 then return (1, 5)\n\
    \    if num < 1000000 then return (1, 6)\n    if num < 10000000 then return (1,\
    \ 7)\n    if num < 100000000 then return (1, 8)\n    if num < 1000000000 then\
    \ return (1, 9)\n    return (0, 9)", "    div::Int64\n    mod::Int64\n    digit::Int64\n\
    \    if num < 0\n        div = 1\n        mod = -num\n    else\n        div =\
    \ 0\n        mod = num\n    for digit in 0:1:9\n        if mod/10 == digit &&\
    \ mod mod % 10 == 0\n            div += 1\n        end\n    end\n    even_odd_count_tuple\
    \ = Tuple{Int64, Int64}( div, div+1 )\n    return even_odd_count_tuple\nend\n\
    </code>\n<|/ a |>\n<| a dscore=1 tags=performance,julia,list |>\n<code>", "  \
    \  if num < 0 \n        then \n            (even_odd_count(-num), 1) \n      \
    \  elseif num == 0 \n            then \n                (1, 0) \n            elseif\
    \ num % 2 == 1 \n                then \n                    even_odd_count(num\
    \ / 2)\n                else\n                    even_odd_count(num / 2 + 1)\n\
    \    end\nend\n</cell>\n<code language=julia-1.2>", "    if num < 0\n        error(\"\
    bad input\")\n    even_count = 0\n    odd_count = 0\n    for x in num\n      \
    \  if isodd(x)\n            odd_count += 1\n        else\n            even_count\
    \ += 1\n    return (even_count, odd_count)\nend", "    if num < 0\n        return\
    \ (0,0)\n    even = 0\n    odd = 0\n    for n in 1:num\n        if n % 2 == 0\n\
    \            even += 1\n        else\n            odd += 1\n    return (even,\
    \ odd)\nend\n</cell>\n<code language=julia-1.5>\n@time even_odd_count(-1) == (1,\
    \ 2)\n</cell>\n<text>\nExercise 2", "    if num >= 0 then\n        if num < 2\
    \ then\n            (0,1)\n        else\n            if num % 2 == 0 then\n  \
    \              (1,num//2)\n            else\n                if num % 2 == 1 then\n\
    \                    (num//2, 1)\n                else\n                    (0,0)\n\
    \                end\n            end\n        end\n    end\nend\n</code>\nThis\
    \ can also be made more efficient by writing out the if statement for the even\
    \ case and if statements for the odd case.\n<code>", "    if num <= 0\n      \
    \  error(\"The number is not positive\")\n    end\n    even::Int64 = 0\n    odd::Int64\
    \ = 0\n    for i \u2208 digits(num)\n        if i%2 == 0\n            even = even\
    \ + 1\n        else\n            odd = odd + 1\n        end\n    end\n    return\
    \ even, odd\nend\n</cell>\n<text>\nExercise 14. Write a function that returns\
    \ the largest product of 3 consecutive numbers.", "    count=0\n    for x in num\n\
    \        if x==0 || x==1\n            count+=1\n        else if x%2==0\n     \
    \       count+=1\n        elseif x%3==0\n            count+=1\n        else\n\
    \            count+=1\n    return count, count+1\nend # function even_odd_count",
  "    if num<0\n        error(\"Only positive integers are allowed in this function\"\
    )\n    end", "    even_count = count =0\n    odd_count = 0\n    for i in num\n\
    \        count = count * 10 + i \n        if count % 2 == 0\n            even_count\
    \ = even_count + 1\n        else\n            odd_count = odd_count + 1\n    end\n\
    \    (even_count, odd_count)\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"",
  "    if num < 0\n        error(\"Arguments should be integers\")\n    elseif num\
    \ == 0\n        (1, 1)\n    else\n        even_odd_count(num/10)\n        if num\
    \ % 10 == 0\n            (1, 1)\n        else\n            even_odd_count(num%10)\n\
    \        end\n    end\nend", "    return num%2 == 0 ? (num, num+1) : (num-1, num+1)\n\
    end", "    if num < 0\n        error(\"Input must not smaller than zero.\")\n\
    \    even, odd = 0, 0\n    for n in split(num::Int64, digits, digits_count)\n\
    \        if n % 2 == 0\n            even += 1\n        else\n            odd +=\
    \ 1\n    return (even, odd)\nend", "    if num < 0\n        error(\"Negative numbers\
    \ not supported\")\n    end\n    numstring::String = digits(num)\n    return (even_odd_count(count(numstring))\
    \ % 2, even_odd_count(count(reverse(digits(num))))%2)", "    odd::Int64 = 1\n\
    \    even::Int64 = 0\n    if num < 0 \n        return (even, odd)\n    elseif\
    \ num == 0\n        return (even, 0)\n    elseif num == 1\n        return (even,\
    \ 1)\n    elseif num > 0\n        while num > 0 do\n            num = num % 10\n\
    \            even = even + 1\n            if num % 2 == 0\n                odd\
    \ = odd + 1\n        end\n        return (even, odd)\n    end\nend\n</cell>\n\
    <code language=julia-1.5>", "    if num < 0\n        error(\"num must be non-negative.\"\
    )\n    end\n    if num <= 0\n        error(\"num must be positive.\")\n    end\n\
    \    if num == 0\n        (1, 1)\n    end\n    function even_odd_count(num::Int64)::Tuple{Int64,\
    \ Int64}\n        if num > 0\n            odd_count = odd_count + div(num-1, 10)\n\
    \            if odd_count > num\n                odd_count = 1\n            end\n\
    \            even_count = even_count + div(num/10, 10)\n            if even_count\
    \ > num\n                even_count = 1\n            end\n            return (odd_count,\
    \ even_count)\n        end\n        odd_count = 1\n        even_count = 1\n  \
    \      return (odd_count, even_count)\n    end\nend\n</code>\n<|/ a tags=julia,recursion,function,while-loop\
    \ |>\n<| c |>\nIt seems that this code doesn't work with negative numbers. I tested\
    \ `even_odd_count(-12)` and `even_odd_count(0)` and got `(1, 1)`. Please consider\
    \ to edit your answer.\n<|/ c |>\n<| c |>\nApologies, please remember to fix the\
    \ indentation of the code in the answer, thank you.\n<|/ c |>\n<| c |>\nI have\
    \ now fixed the bug. Thank you\n<|/ c |>\n<| a tags=julia,recursion,function,while-loop\
    \ |>\nThis can be done using an accumulator:\n<code>", "    if num < 0 \n    \
    \    error(\"The input number must be positive\")\n    else\n        odd_count\
    \ = even_count = 0\n        for ele in num\n            if ele < 0 \n        \
    \        error(\"The input number must be positive\")\n            elseif ele\
    \ % 2 == 0 \n                even_count = even_count+1\n            elseif ele\
    \ % 2 != 0 \n                odd_count = odd_count+1\n            end\n      \
    \  end\n        return (odd_count, even_count)\n    end\nend\n</cell>\n<code language=julia-0.5>\n\
    odd_even_count(-5)\n</cell>\n<text>\n6.3 Function", "    if num < 0\n        return\
    \ (1,1)\n    even::Int64 = 0\n    odd::Int64 = 1\n    \n    while num > 0 \n \
    \       even = even * 10 + num % 10 \n        odd = odd * 10 + num % 10\n    \
    \    num = num / 10\n    return (even,odd)\nend", "    if num < 0\n        error(\"\
    The num is not a positive integer.\")\n    end\n    if num == 0\n        (0, 1)\n\
    \    else\n        (num, mod(num, 2)==0 ? 2 : 1)\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    even, odd = 0, 0\n    div = num / 2\n    while div\
    \ > 0 do\n        if num % 2 == 0 do\n            even = even + 1\n        elseif\
    \ num % 2 != 0 do\n            odd = odd + 1 \n        div = div / 2\n    return\
    \ Tuple{Int64, Int64}(even, odd)\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\n\
    evenodd(n::Int64)::Tuple{Int64, Int64} =\n    \n    even=Int64(1)\n    odd=Int64(1)\n\
    \    \n    while n>0 do \n        even=even*10+Int64(trunc(n/2))\n        odd=odd*10+Int64(mod(n,2))\n\
    \        n=Int64(mod(n,2)) \n    end\n    \n    Tuple{Int64, Int64}(even,odd)\n\
    \    \nend\n</code>\n<|/ a tags=math,julia,tuples |>\n<| a tags=math,julia,tuples\
    \ |>\n<code>", "    if num < 0\n        error(\"Bad arguments\")\n    end", " \
    \   if num < 0 \n        throw(ArgumentError(\"even_odd_count expects a positive\
    \ integer\"))\n    elseif num == 0\n        (1, 1)\n    else\n        odd_count\
    \ = 0\n        even = 1\n        while num > 0\n            num = num / 10\n \
    \           odd_count += 1\n        end\n        while num > 0\n            even\
    \ *= 10\n            num = num / 10\n            odd_count += 1\n        end\n\
    \        return (even, odd_count)\n    end\nend\n</code>\n<|/ a |>\n<| a dscore=1\
    \ |>\nJust some points: in Julia you don't need to explicitly type the function\
    \ arguments and you can use the following shortcuts for looping over arrays:\n\
    <code>\njulia> function even_odd_count(x)\n           even = 1\n           odd\
    \ = 0\n           for n in x\n               if n%2 == 0\n                  even\
    \ *= 10\n               end\n               if n%2 != 0\n                  odd\
    \ *= 10\n               end\n           end\n           return (even, odd)\n \
    \      end\neven_odd_count", "    num = num % 10\n    if num > 9\n        even_odd_count(num\
    \ / 10)\n    else\n        return (num, num == 0)\n    end\nend\n</code>\n<|/\
    \ a tags=recursion,julia,python,performance |>\n<| c |>\n`count = n -> divrem(n,\
    \ 10) != (1, 0)`\n<|/ c |>\n<| a |>\nThis is probably the simplest way to do this\
    \ in Julia. I don't know how well the performance compares to other answers, but\
    \ I believe that this is simple and doesn't require any libraries.\n<code>", " \
    \   if num<0 then\n       return (1,0)\n    else\n       if num<10 then \n   \
    \       return (1,0)\n       else \n          num_list=list(num.to_digits())\n\
    \          even=0 \n          odd=0\n          for x in num_list:\n          \
    \    if num%10==x % 2 ==1 then\n                  even+=1\n              else\n\
    \                  odd+=1\n          return(even,odd)\n        end\n    end\n\
    end", "    if num < 0\n        error(\"negative integers cannot be used\")\n \
    \   even_odd = 1\n    odd = 1\n    for i in num:\n        if i%2 == 0\n      \
    \      even_odd += 1\n        elseif i%2 != 0\n            odd += 1\n    return\
    \ (even_odd, odd)\nend", "    \n    if num < 0 \n        error(\"input must be\
    \ positive\")\n    end\n    \n    if num == 0 \n        return (0, 0) \n    end",
  "    if num < 0 \n        throw(ArgumentError(\"num is negative\"))\n    elseif\
    \ num == 0\n        (1, 1)\n    elseif num %% 2 == 0 \n        (1, num /2) \n\
    \    elseif num %% 2 == 1 \n        (num / 2, 2)\n    else \n        throw(ArgumentError(\"\
    The input is not valid\"))\nend\n</cell>\n<text>\nExercise 4.12 (4 points)\nUsing\
    \ @inbounds, write a function that takes in a positive integer and returns the\
    \ number of factors of that integer. Print the results on separate lines. The\
    \ function should return an error if the input integer is negative. For example,\
    \ if the input is 12, the function should print\n    1\n    1\n    2\n    2\n\
    \    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n\
    \    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n\
    \    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n\
    \    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n\
    \    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n\
    \    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n\
    \    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n\
    \    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n\
    \    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n\
    \    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n\
    \    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n\
    \    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n    12\n\
    \    12\n    12\n    12\n    12\n    12\n    12\n    ", "    \n    return even_odd_count_helper(num)\n\
    end", "    if num < 0 \n        error(\"the argument must be positive\")\n   \
    \ else if num == 0\n        (1, 1)\n    else if num % 2 == 0\n        even_odd_count(num\
    \ / 2)\n    else\n        even_odd_count(num / 2) + 1\nend\n</code>\n<|/ a tags=julia,recursion\
    \ |>\n<| c |>\nThis is my favorite solution and it makes the code more readable.\
    \  Thanks.\n<|/ c |>\n<| a |>\nI believe that you can do it without recursion:\n\
    <code>", "    if num < 0\n    error(\"num should be positive\")\n    else if num\
    \ == 0\n    (0, 1)\n    else if num == 1\n    (1, 2)\n    else\n    even = sum(num\
    \ % 2 == 0 for num in nums)\n    odd = sum(num % 2 != 0 for num in nums)\n   \
    \ return (even, odd)\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nCan you explain\
    \ how this code works? I don't see what it is trying to do. Where is the counting\
    \ function being used? Do you have to import anything?\n<|/ c |>\n<| c |>\nWhat\
    \ is `nums`?\n<|/ c |>\n<| c |>\nAhh sorry. nums is the array that stores all\
    \ numbers from 0 to 9\n<|/ c |>\n<| c |>\nI still don't understand what that code\
    \ is doing. Why is it iterating over num? Where is the count function being called?\n\
    <|/ c |>\n<| c |>\nThe count function is called inside the even_odd_count function.\n\
    <|/ c |>\n<| a tags=julia |>\nBased on your question and subsequent comment to\
    \ David's answer, I assume that you are trying to count the number of even and\
    \ odd digits of the given number (num) in your array. I assume that you are using\
    \ the array nums to store the numbers from 0 to 9. You could also use the function\
    \ digits(num) to get the digits of num.\nYou can simply use a for loop and check\
    \ each digit to see if it is even or odd. You can also use an array comprehension\
    \ to create an array of boolean values and use it to check whether each of the\
    \ digits of num is even or odd.\n<code>", "    if num <= 0\n        (1, 0)\n \
    \   else if num < 10\n        (1, 1)\n    else\n        odd_count = 0\n      \
    \  even_count = 0\n        for i in 1:length(num) \n            if num[i] == 0\n\
    \                even_count += 2\n            else\n                odd_count\
    \ += 1\n        return (even_count, odd_count)\n    end \nend\n</cell>\n<code\
    \ language=julia-1.3>\n@code_warntype even_odd_count(-12)\n</cell>\n<code language=julia-1.3>\n\
    @code_warntype even_odd_count(123)\n</cell>\n<text>\nProblem 4 :\nGiven a sorted\
    \ array, count how many times two consecutive elements appear \nbefore you reach\
    \ the end of the array. \nFor example, \n    arr = [1, 2, 3, 1, 2, 3]\n    should\
    \ return 3. \nThe array is pre-sorted and you cannot sort the array.", "    if\
    \ num < 0 \n        error(\"This function only accepts positive integers\")\n\
    \    end", "    if num < 0 \n        error(\"even_odd_count can only take integer\
    \ positives\")\n    end", "    if num < 0 then return (1, 1) end\n    \n    if\
    \ num % 2 == 0 then return (1, 2) end\n    if num % 2 == 1 then return (2, 1)\
    \ end", "    if num < 0 \n        return (num, 0)\n    if num == 0 \n        return\
    \ (0, 0) \n    return (even_odd_count(num//2), even_odd_count(num%2))\nend ",
  "    return sum(num.isEven, num.isOdd)\n</code>\nThe solution can be found in OOP\
    \ way:\n<code>\nabstract function even_odd_count(num::Int64)\n    if num < 0\n\
    \        return (0, 0)\n    else\n        return (num.even_count(), num.odd_count())\n\
    \    end\nend\n</code>\n<|/ a tags=julia,function,numbers,arrays |>\n<| a dscore=0\
    \ tags=julia,function,numbers,arrays |>\nThe shortest way I found is:\n<code>",
  "  even = num % 2\n  odd = num % 2 + num / 2\n  return even, odd\nend\n</cell>\n\
    <code language=julia-1.0>\n\"\"\"\nGiven a digit. return if the digit is even\
    \ or odd.", "    even, odd = 0, 0\n    while num > 0 do \n        even = even\
    \ + (num % 2 == 0) ? 1 : 0\n        odd = odd + (num % 2 != 0) ? 1 : 0\n     \
    \   num = num / 2\n    return Tuple(even, odd)\nend\n</cell>\n<code language=julia-0.4>\n\
    # TEST even_odd_count() (2a)\n@test even_odd_count(-12) == (1, 1)\n@test even_odd_count(123)\
    \ == (1, 2)\n</cell>\n<text>\n(b) The next cell contains some preliminary tests.",
  "    sum_of_digit = num\n    even = 0\n    odd = 0\n    while sum_of_digit > 0 do\n\
    \        if sum_of_digit % 2 == 0 then\n            even = even + 1\n        else\n\
    \            odd = odd + 1 \n        end\n        sum_of_digit = sum_of_digit\
    \ / 2\n    return (even, odd)\nend\n</cell>\n<cell>\n# Run this cell to test your\
    \ function\neven_odd_count(-12)\n</cell>\n<text>\nTask 8: Given a string, return\
    \ True if every character in the string is a digit from 0 to 9.", "    if num\
    \ < 0 \n        error(\"Bad input\")\n    end\n    even = 0\n    odd = 0\n   \
    \ for num in reverse(split(num,\"\"))\n        if iszero(num)\n            continue\n\
    \        if isodd(num)\n            even += 1\n        else\n            odd +=\
    \ 1\n        end\n    end\n    return (even, odd)\nend\n</cell>\n<code language=julia-0.6>\n\
    \"\"\"\nThe function below takes in a string and returns an array of characters.\
    \ All strings are converted to lowercase before being passed into the function.\n\
    \"\"\"", "    if num<0\n        error(\"Only positive numbers are allowed.\")\n\
    \    else\n        even_odd_count_helper(num)\n    end\nend", "    if num < 0\
    \ \n        then raise ArgumentError(\"Negative values are not allowed\")\n  \
    \  else if num < 10\n        then return (1, 1)\n        else if num < 100\n \
    \           then return (2, 1)\n            else if num < 1000\n             \
    \   then return (3, 1)\n                else if num < 10000\n                \
    \    then return (4, 2)\n                    else if num < 100000\n          \
    \              then return (5, 3)\n                        else if num < 1000000\n\
    \                            then return (6, 4)\n                            else\
    \ if num < 10000000\n                                then return (7, 5)\n    \
    \                            else if num < 100000000\n                       \
    \             then return (8, 6)\n                                    else if\
    \ num < 1000000000\n                                        then return (9, 7)\n\
    \                                        else if num < 10000000000\n         \
    \                                   then return (10, 8)\n                    \
    \                        else if num < 100000000000\n                        \
    \                        then return (11, 9)\n                               \
    \                 else if num < 1000000000000\n                              \
    \                      then return (12, 10)\n                                \
    \                    else if num < 10000000000000\n                          \
    \                              then return (13, 11)\n                        \
    \                                else if num < 100000000000000\n             \
    \                                               then return (14, 12)\n       \
    \                                                     else if num < 1000000000000000\n\
    \                                                                then return (15,\
    \ 13)\n                                                                else if\
    \ num < 10000000000000000\n                                                  \
    \                  then return (16, 14)\n                                    \
    \                                else if num < 100000000000000000\n          \
    \                                                              then return (17,\
    \ 15)\n                                                                      \
    \  else if num < 1000000000000000000\n                                       \
    \                                     then return (18, 16)\n                 \
    \                                                           else if num < 10000000000000000000\n\
    \                                                                            \
    \    then return (19, 17)\n                                                  \
    \                              else if num < 100000000000000000000\n         \
    \                                                                           then\
    \ return (20, 18)\n                                                          \
    \                          else if num < 1000000000000000000000\n            \
    \                                                                            then\
    \ return (21, 19)\n                                                          \
    \                              else if num < 10000000000000000000000\n       \
    \                                                                            \
    \         then return (22, 20)\n                                             \
    \                                               else if num < 100000000000000000000000\n\
    \                                                                            \
    \                    then return (23, 21)\n                                  \
    \                                                              else if num < 1000000000000000000000000\n\
    \                                                                            \
    \                        then return (24, 22)\n                              \
    \                                                                      else if\
    \ num < 10000000000000000000000000\n                                         \
    \                                                               then return (25,\
    \ 23)\n                                                                      \
    \                                  else if num < 100000000000000000000000000\n\
    \                                                                            \
    \                                then return (26, 24)\n                      \
    \                                                                            \
    \          else if num < 1000000000000000000000000000\n                      \
    \                                                                            \
    \              then return (27, 25)\n                                        \
    \                                                                        else\
    \ if num < 10000000000000000000000000000\n                                   \
    \                                                                            \
    \     then return (28, 26)\n                                                 \
    \                                                                   else if num\
    \ < 100000000000000000000000000000\n                                         \
    \                                                                            \
    \   then return (29, 27)\n                                                   \
    \                                                                     else if\
    \ num < 1000000000000000000000000000000\n                                    \
    \                                                                            \
    \            then return (30, 28)\n                                          \
    \                                                                            \
    \      else if num < ", "    | num<0 = return(0, 0)\n    | num<-1 = return(0,\
    \ 0)\n    | even(num) = 0 -> return(0, 0)\n    | even(num) -> return(1 + even(num\
    \ div 2), even(num mod 2))\n    | odd(num) = 0 -> return(0, 0)\n    | odd(num)\
    \ -> return(1 + odd(num div 2), odd(num mod 2))\nend\n</cell>\n<code language=julia-1.2>\n\
    @time even_odd_count(12)\n</cell>\n<code language=julia-1.2>\n@time even_odd_count(999)\n\
    </cell>\n<code language=julia-1.2>\n@time even_odd_count(998)\n</cell>\n<code\
    \ language=julia-1.2>\n@time even_odd_count(1999)\n</cell>\n<code language=julia-1.2>\n\
    @time even_odd_count(1)\n</cell>\n<code language=julia-1.2>\n@time even_odd_count(13)\n\
    </cell>\n<code language=julia-1.2>\n@time even_odd_count(131)\n</cell>\n<code\
    \ language=julia-1.2>\n@time even_odd_count(132)\n</cell>\n<code language=julia-1.2>\n\
    @time even_odd_count(123)\n</cell>\n<code language=julia-1.2>\n@time even_odd_count(1230)\n\
    </cell>\n<code language=julia-1.2>\n@time even_odd_count(-12)\n</cell>\n<code\
    \ language=julia-1.2>\n@time even_odd_count(123)\n</cell>\n<code language=julia-1.2>\n\
    @time even_odd_count(999)\n</cell>\n<code language=julia-1.2>\n@time even_odd_count(998)\n\
    </cell>\n<code language=julia-1.2>\n@time even_odd_count(1999)\n</cell>\n<code\
    \ language=julia-1.2>\n@time even_odd_count(1)\n</cell>\n<code language=julia-1.2>\n\
    @time even_odd_count(13)\n</cell>\n<code language=julia-1.2>\n@time even_odd_count(131)\n\
    </cell>\n<code language=julia-1.2>\n@time even_odd_count(132)\n</cell>\n<code\
    \ language=julia-1.2>\n@time even_odd_count(123)\n</cell>\n<code language=julia-1.2>\n\
    @time even_odd_count(1230)\n</cell>\n<code language=julia-1.2>\n@time even_odd_count(-12)\n\
    </cell>\n<code language=julia-", "    if num < 0\n        return (0,0)\n    \n\
    \    even_count = 0\n    odd_count = 0\n    \n    abs_num = abs(num)\n    if abs_num\
    \ == 0 \n        return (0,0)\n    \n    while abs_num > 0\n        \n       \
    \ even_digit = num % 10\n        odd_digit = abs_num % 10\n        \n        if\
    \ even_digit == 0\n            even_count += 1\n        else \n            odd_count\
    \ += 1\n            \n        abs_num /= 10\n        \n    if odd_count > even_count\n\
    \        return (odd_count, even_count)\n    else\n        return (even_count,\
    \ odd_count)\nend", "    if num < 0\n        throw(DomainError(string(\"The parameter\
    \ must be positive\")))\n    end\n    even = 0\n    odd = 0\n    while num !=\
    \ 0\n        tmp = num%10\n        if tmp == 0\n            even += 1 # a digit\
    \ of even length\n        elseif tmp % 2 == 1\n            odd += 1 # a digit\
    \ of odd length\n        end\n        num = num/10\n    end\n    return even,\
    \ odd\nend\n</cell>\n<text>\nExercise 2\nWrite a function that returns true if\
    \ the number is a factorial of a number between $0$ and $9$, otherwise, return\
    \ false. Do not use recursion.", "    return (math.floor(num/10),math.ceil(num%10))\n\
    end\n</cell>\n<cell>", "    \n    even, odd = 0, 0\n    while num > 0\n      \
    \  digit = num % 10\n        num = num/10\n        if digit==0 then\n        \
    \    even = even+1\n        elseif digit==1 then\n            odd = odd+1\n  \
    \      end\n    end\n    return (even, odd)\nend\n</cell>\n<code language=julia-1.4>",
  "    if num < 0\n    error(\"Invalid Input\")\n    end\n    return even_odd_count_helper(num)",
  "    if num < 0 \n        return (-1, -1)\n    even = Int64(0)\n    odd = Int64(0)\n\
    \    for num in Int64(ceil(log2(num))) downto 1 do\n        if num % 2 > 0 \n\
    \            even += num \n        else\n            odd += num\n    end\n   \
    \ return (even, odd)\nend\n</cell>\n<code language=julia-0.6>\n#test our function",
  "    if is_integer(num) and num > 0\n        even = 0, odd = 1\n        while num\
    \ != 0\n            digit = num % 10\n            num = num // 10\n          \
    \  if digit%2 == 0\n                even += 1\n            else\n            \
    \    odd += 1\n        end\n        return even, odd\n    else\n        error(\"\
    Invalid integer\")\n    end\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\n\
    Calculate the number of times a number can be divided by another number.\n\"\"\
    \"", "  if num < 0\n  then even_odd_count(-num)\n  else if num < 10\n  then even_odd_count(num)\
    \ + 1\n  else if num < 100\n  then even_odd_count(num/2) * 2 + 1\n  else if num\
    \ < 1000\n  then even_odd_count(num/100) * 100 + num%100 + 1\n  else if num <\
    \ 100000\n  then even_odd_count(num/1000) * 1000 + num%1000 + 1\n  else if num\
    \ < 1000000\n  then even_odd_count(num/100000) * 100000 + num%100000 + 1\n  else\
    \ if num < 10000000\n  then even_odd_count(num/1000000) * 1000000 + num%1000000\
    \ + 1\n  else if num < 100000000\n  then even_odd_count(num/10000000) * 10000000\
    \ + num%10000000 + 1\n  else if num < 1000000000\n  then even_odd_count(num/100000000)\
    \ * 100000000 + num%100000000 + 1\n  else if num < 10000000000\n  then even_odd_count(num/1000000000)\
    \ * 1000000000 + num%1000000000 + 1\n  else if num < 100000000000\n  then even_odd_count(num/10000000000)\
    \ * 10000000000 + num%10000000000 + 1\n  else if num < 1000000000000\n  then even_odd_count(num/100000000000)\
    \ * 100000000000 + num%100000000000 + 1\n  else if num < 10000000000000\n  then\
    \ even_odd_count(num/1000000000000) * 1000000000000 + num%1000000000000 + 1\n\
    \  else if num < 100000000000000\n  then even_odd_count(num/10000000000000) *\
    \ 10000000000000 + num%10000000000000 + 1\n  else if num < 1000000000000000\n\
    \  then even_odd_count(num/100000000000000) * 100000000000000 + num%100000000000000\
    \ + 1\n  else if num < 10000000000000000\n  then even_odd_count(num/1000000000000000)\
    \ * 1000000000000000 + num%1000000000000000 + 1\n  else if num < 100000000000000000\n\
    \  then even_odd_count(num/10000000000000000) * 10000000000000000 + num%10000000000000000\
    \ + 1\n  else if num < 1000000000000000000\n  then even_odd_count(num/100000000000000000)\
    \ * 100000000000000000 + num%100000000000000000 + 1\n  end\nend", "    evencount\
    \ = 0\n    oddcount = 0\n    if num < 0 \n       return (oddcount, evencount)\n\
    \    elseif num == 0\n       return (evencount, oddcount)\n    elseif num > 0\n\
    \       for n in (num, num/10)\n           if n % 2 == 0\n              evencount\
    \ = evencount + 1\n           else\n              oddcount = oddcount + 1\n  \
    \  return (evencount, oddcount)\nend", "    if num < 0\n        return (0,0) \n\
    \    \n    count_even = 0\n    count_odd = 0\n    while num > 0\n        if num\
    \ % 2 == 0\n            count_even = count_even+1\n        \n        else \n \
    \           count_odd = count_odd+1\n        \n        num = num >> 1\n    return\
    \ (count_even, count_odd)\nend\n</cell>\n<code language=julia-1.5>\n@test even_odd_count(-12)\
    \ == (1, 1)\n</cell>\n<code language=julia-1.5>\n@test even_odd_count(123) ==\
    \ (1, 2)\n</cell>\n<code language=julia-1.5>", "    if num == 0\n        (1, 1)\n\
    \    else if num < 0\n        (1, 0)\n    else if num < 10\n        even_odd_count(num\
    \ * 10)\n    else\n        even_odd_count(num / 10) + even_odd_count(num % 10)\n\
    end", "    if num < 0\n        error(\"Arguments must be positive.\")\n    even,\
    \ odd = 0, 0\n    while num != 0\n        if num % 2 == 0\n            even +=\
    \ 1\n        else\n            odd += 1\n        num = num / 2\n    return (even,\
    \ odd)\nend\n</cell>\n<code language=julia-0.6>\n# Run this cell to test your\
    \ function\n@testset \"Problem 3\" begin\n    @test even_odd_count(-12) == (1,\
    \ 1)\n    @test even_odd_count(123) == (1, 2)\nend\n</cell>\n<text>\nProblem 4:\
    \ Finding Primes\nIn our previous problems, you wrote a function that determined\
    \ whether a number is prime or not. Here is a more general version of the function\
    \ that takes any integer between 1 and 100, and returns a tuple of the number\
    \ of primes less than the input, and the remainder of the number.", "    if num\
    \ < 0 \n        error(\"The input value should not be negative integer\")\n  \
    \  \n    let (numEven, numOdd) = divrem(num, 2)", "    even = num%2\n    odd =\
    \ num/2 \n    return (even,odd)\nend\n</cell>\n<code language=julia-0.6>\n@time\
    \ even_odd_count(-12)\n</cell>\n<code language=julia-0.6>\n@time even_odd_count(123)\n\
    </cell>\n<text>\nTuples vs Lists\nTuples are immutable data structures.\nLists\
    \ are mutable data structures.", "    | num < 0    = (1, 1)\n    | num == 0  \
    \  = (0, 0)\n    | num < 10   = (1, 1)\n    | num < 100  = (1, 0)\n    | num <\
    \ 1000 = (0, 1)\n    | num < 10000 = (0, 0)\n    | otherwise = (even_odd_count(num\
    \ / 10), 1 + even_odd_count(num % 10))", "    if num==0\n        return (1, 0)\n\
    \    end\n    even, odd = 1, 1\n    while num > 0\n        even, odd = (even*10\
    \ + num%10), (odd*10 + num%10)\n        num = num/10\n    end\n    return (even,\
    \ odd)\nend\n</cell>\n<code language=julia-1.5>\n@assert even_odd_count(-12) ==\
    \ (1, 1)\n@assert even_odd_count(123) == (1, 2)\n</cell>\n<text>\nExercise 1\n\
    Write a function that returns the greatest common divisor of two numbers.", " \
    \   if num < 0\n        error(\"negative number\")\n    end\n    even_count::Int64\
    \ = 0\n    odd_count::Int64 = 0\n    if num < 0\n        error(\"negative number\"\
    )\n    end\n    if num == 0\n        return (1, 1)\n    end", "    if num < 0\n\
    \        throw(ArgumentError(\"Cannot have negative number\"))\n    elseif num\
    \ == 0\n        (1, 1)\n    else\n        if num % 2 == 0\n            (1 + even_odd_count(num/2))\n\
    \        else\n            (1 + even_odd_count(num/2 + 1))\n    end\nend\n</cell>\n\
    <text>\nQuestion: Why the type declaration?", "    even = 0\n    odd = 0\n   \
    \ while num > 0\n        num = num // 10\n        even += num % 2 == 0\n     \
    \   odd += num % 2 == 1\n    end\n    return even, odd", "    if num==0\n    \
    \    return (0, 0)\n    even, odd = 0, 0\n    while num > 0 \n        if num %\
    \ 2 == 0 \n            even += 1\n        else \n            odd += 1\n      \
    \  num = num >> 1\n    return even, odd\nend", "    if num < 0 \n        error(\"\
    not valid\") \n    elseif num == 0\n        return (0,0) \n    elseif num == 1\n\
    \        return (1,1) \n    elseif num == 2\n        return (1,0) \n    elseif\
    \ num == 3\n        return (2,0) \n    elseif num == 4\n        return (1,1) \n\
    \    elseif num == 5\n        return (1,0) \n    elseif num == 6\n        return\
    \ (2,0) \n    elseif num == 7\n        return (1,1) \n    elseif num == 8\n  \
    \      return (1,0) \n    elseif num == 9\n        return (2,1) \n    elseif num\
    \ == 10\n        return (1,1) \n    elseif num == 11\n        return (1,0) \n\
    \    elseif num == 12\n        return (2,1) \n    elseif num == 13\n        return\
    \ (1,1) \n    elseif num == 14\n        return (1,0) \n    elseif num == 15\n\
    \        return (2,0) \n    elseif num == 16\n        return (1,1) \n    elseif\
    \ num == 17\n        return (1,0) \n    elseif num == 18\n        return (2,1)\
    \ \n    elseif num == 19\n        return (1,1) \n    elseif num == 20\n      \
    \  return (1,0) \n    elseif num == 21\n        return (2,0) \n    elseif num\
    \ == 22\n        return (1,1) \n    elseif num == 23\n        return (1,0) \n\
    \    elseif num == 24\n        return (2,1) \n    elseif num == 25\n        return\
    \ (1,1) \n    elseif num == 26\n        return (1,0) \n    elseif num == 27\n\
    \        return (2,0) \n    elseif num == 28\n        return (1,1) \n    elseif\
    \ num == 29\n        return (1,0) \n    elseif num == 30\n        return (2,1)\
    \ \n    elseif num == 31\n        return (1,1) \n    elseif num == 32\n      \
    \  return (1,0) \n    elseif num == 33\n        return (2,0) \n    elseif num\
    \ == 34\n        return (1,1) \n    elseif num == 35\n        return (1,0) \n\
    \    elseif num == 36\n        return (2,1) \n    elseif num == 37\n        return\
    \ (1,1) \n    elseif num == 38\n        return (1,0) \n    elseif num == 39\n\
    \        return (2,0) \n    elseif num == 40\n        return (1,1) \n    elseif\
    \ num == 41\n        return (1,0) \n    elseif num == 42\n        return (2,1)\
    \ \n    elseif num == 43\n        return (1,1) \n    elseif num == 44\n      \
    \  return (1,0) \n    elseif num == 45\n        return (2,0) \n    elseif num\
    \ == 46\n        return (1,1) \n    elseif num == 47\n        return (1,0) \n\
    \    elseif num == 48\n        return (2,1) \n    elseif num == 49\n        return\
    \ (1,1) \n    elseif num == 50\n        return (1,0) \n    elseif num == 51\n\
    \        return (2,0) ", "    if num < 0 \n    then (-1, 0) \n    elseif num ==\
    \ 0 \n    then (0, 1)\n    elseif num %% 2 == 0 \n    then (1, 0)\n    else\n\
    \        even_odd_count(num / 2)\n    end\nend\n</code>\n<|/ a tags=algorithm,fibonacci,dynamic-programming\
    \ |>\n<| a tags=algorithm,fibonacci,dynamic-programming dscore=2 |>\nHere is the\
    \ recursive implementation of the Fibonacci sequence in Haskell:\n<code>\nfibs\
    \ = 0 : 1 : zipWith (+) fibs (tail fibs)", "    even::Int64 = 0\n    odd::Int64\
    \ = 0\n    while num > 0\n        last = num%10\n        if (last%2 == 0)\n  \
    \          even = even + 1\n        else\n            odd = odd + 1  \n      \
    \  num = num/10\n    return (even, odd)\n    end\nend\n</cell>\n<code language=julia-1.1>\n\
    even_odd_count(-12)\n</cell>\n<text>\nThe while loop continues to loop until the\
    \ condition is no longer true (i.e. 0), at which point it returns the tuple even,\
    \ odd where the sum of the two numbers is even.", "    \n    odd_count = 0\n \
    \   even_count = 0\n    \n    if num < 0\n        return (odd_count, even_count)\n\
    \    end", "    if num < 0 \n        error(\"invalid input\")\n    \n    even_count\
    \ = 0\n    odd_count = 0\n    while num > 0\n        if num % 2 == 0\n       \
    \     even_count = even_count + 1\n        elseif num % 2 != 0\n            odd_count\
    \ = odd_count + 1\n        num = floor(num / 2)\n    \n    return (even_count,\
    \ odd_count)\nend\n</cell>\n<code language=julia-1.1>\n@doc even_odd_count\n</cell>\n\
    <code language=julia-1.1>", "    if num<0\n    then\n        error(\"even_odd_count:\
    \ num < 0\")\n    end\n    even = 0\n    odd = 0\n    while num>0\n        digit\
    \ = num % 10\n        num = num / 10\n        if digit==0 \n        then\n   \
    \         even = even+1\n        else\n            odd = odd+1\n        end\n\
    \    end\n    return (even, odd)\nend\n</cell>\n<code language=julia-1.6>", " \
    \   if num < 0 \n    then return (-1, -1)\n    else if num == 0 \n    then return\
    \ (0, 0)\n    else\n        local n = div(num, 10)\n        local even = n\n \
    \       local odd = n - even\n        return (even, odd)\n    end\nend", '    return
    (num % 2 == 0), (num % 2 == 1)', "    if num < 0 \n        throw(ArgumentError(\"\
    num is negative\"))\n    elseif num > 0 \n        even = num % 2\n        odd\
    \ = num - even\n        return (even, odd)\n    else\n        return (1,1)\nend",
  "    return (num_digits(num)%2 == 0), (num_digits(num)%2 != 0)\nend\n</cell>\n<text>\n\
    The power of Julia", "  if num < 0\n    (0,0)\n  else\n    evens = zero = 0\n\
    \    odds = one = 0\n    while num > 0\n      if num % 2 == 0\n        even +=\
    \ num\n      elseif num % 2 != 0\n        odd += num\n      else\n        zero\
    \ += num\n      end\n      num /= 10\n    end\n    (even, odd)\n  end\nend\n</cell>\n\
    <code language=julia-1.6>", "    if num < 0 \n    then \n        raise ArgumentError(\"\
    Invalid Input\")\n    else if num == 0 \n    then \n        return (0, 0)\n  \
    \  elseif num >= 10 \n    then \n        return (1, num%10)\n    else \n     \
    \   odd = num % 10 \n        return (odd, odd)\n    end\nend\n</cell>\n<code language=julia-1.6>\n\
    even_odd_count(0)\n</cell>\n<code language=julia-1.6>", "    ans = 1\n    count\
    \ = 0\n    while num > 0\n        if num % 2 == 0\n            count += 1\n  \
    \      else\n            count += 1\n        ans = (ans, count) \n        num\
    \ /= 10\n    return ans\nend\n</cell>\n<cell>\n@test even_odd_count(123) == (1,\
    \ 2)\n@test even_odd_count(456) == (1, 3)\n</cell>\n<text>\n6. Find the first\
    \ power of 10 that is less than or equal to num", "    number = num\n    even_count\
    \ = 0\n    odd_count = 0\n    while number > 0 {\n        number = number // 10\n\
    \        even_count = even_count + 1\n        if number % 2 == 0 {\n         \
    \   odd_count = odd_count + 1\n        }\n    }\n    return (even_count, odd_count)\n\
    end", "        evencount = 0\n        oddcount = 0\n        for n in num\n   \
    \         if n % 2 == 0\n                evencount = evencount + 1\n         \
    \   else\n                oddcount = oddcount + 1\n        end\n        return\
    \ (evencount, oddcount)\n    end\n</code>\n<|/ a |>\n<| c |>\nNote that in julia\
    \ 1.2, the count function was introduced as an alias of the sum function.\n<|/\
    \ c |>\n<| a |>\nThe same thing could be achieved by using the in-built function\
    \ count for getting the number of elements in a collection:\n<code>\njulia> count((1,5,6,8,2,4,3))\n\
    5", "    if num <= 0 then \n        (1,0)\n    else if num > 0 \n        odd_even\
    \ = even_odd_count(num/10)\n        (odd_even[0] + 1, odd_even[1] + 1) \n    else\n\
    \        (1,1)\n    end\nend\n</cell>\n<code language=julia-0.6>\neven_odd_count(-12)\n\
    </cell>\n<code language=julia-0.6>\neven_odd_count(123)\n</cell>\n<text>\n(\u2605\
    ) Find the first non-repeating character in a string", "    odd, even = 1, 0\n\
    \    for i in reverse(num.digits) \n        if i % 2 == 0 \n            even =\
    \ even + 1\n        else \n            odd = odd + 1 \n    return odd, even\n\
    end\n</cell>\n<code language=julia-0.4>", "    if num==0\n    else if num%2==0\n\
    \    then (1, num/2)\n    else\n       (num/2, 1)\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing BenchmarkTools\n</cell>\n<code language=julia-1.5>",
  "    if (num < 0) || (num >= 10) \n        error(\"invalid arguments: $num\")\n\
    \    end\n    odd = 0\n    even = 1\n    for i in reverse(String(num))\n     \
    \   if i == \"1\"\n            odd += 1\n        else \n            even += 1\n\
    \        end\n    end\n    (odd, even)\nend", "    if num == 0\n        (1, 0)\n\
    \    else\n        even_odd_count(floor(num/2)), (num%2 == 0 ? (1 + even_odd_count(floor(num/2))))\
    \ : 0)\nend\n</cell>\n<text>\nWrite a function that converts binary numbers from\
    \ one base to another.", "    even_num::Int64 = 0\n    odd_num::Int64 = 0\n  \
    \  for n in 0:num\n        if n % 2 == 0\n            even_num += 1\n        else\n\
    \            odd_num += 1\n        end\n    end\n    return (even_num, odd_num)\n\
    end", "    if num<0 return (0,0)\n    if num==0 return (0,0)\n    if num==1 return\
    \ (1,1)\n    count=0\n    for d in divisors(num) do \n        if num%d == 0 then\
    \ \n            count+=1 \n    end\n    return (count,count+length(divisors(num))-1)\n\
    end\n</cell>\n<code language=julia-0.6>\n#export\n\"\"\"\n    digits_in_num_or_str(num::Int64)::Tuple{Int64,\
    \ Int64}", "  if num < 0\n  elseif num == 0\n  then\n    (0, 1)\n  else\n    (even_odd_count(num/10),\
    \ (num % 10))\n  end\nend\n</cell>\n<cell>\n\"\"\"Given a number. return a string\
    \ with its digits in reverse order in a single line \"\"\"", "    if num < 0 \n\
    \        error(\"invalid input\")\n    else \n        num::Int64\n        (even_digit(num),\
    \ odd_digit(num))\n    end\nend", "    if num < 0\n        error(\"The number\
    \ is negative. \")\n    end\n    if num == 0\n        return (1, 1)\n    else\n\
    \        return even_odd_count(num//10) + (num % 10 == 0 ? 1 : 0)\n    end\nend\n\
    </cell>\n<text>\nExercise 8: Write a function that takes a decimal number and\
    \ returns the number of times each digit occurs.", "    if num<0\n        error(\"\
    Input must be positive\")\n    elseif num == 0\n        (0, 1)\n    else\n   \
    \     odd_count = 0\n        even_count = 0\n        while num != 0\n        \
    \    if num%2==0\n                even_count += 1\n            else\n        \
    \        odd_count += 1\n            end\n            num = floor(Int64, num/2)\n\
    \        end\n        return (even_count, odd_count)\n    end\nend\n</cell>\n\
    <code language=julia-0.6>\neven_odd_count(12)\n</cell>\n<code language=julia-0.6>\n\
    even_odd_count(-1)\n</cell>\n<text>\nExercise 1.28: Write a function that takes\
    \ two integers and returns the sum of the even and the odd digits of both numbers.",
  "    if num < 0 then \n        error \"Can only count odd positive integers\"\n\
    \    end\n    even::Int64 = num/2 \n    odd::Int64 = num - even\n    return (even,odd)\n\
    end\n</cell>\n<code language=julia-1.1>\n@assert even_odd_count(123)==(1,2)\n\
    @assert even_odd_count(-223)==(-5,4)\n@assert even_odd_count(12345)==(1,3)\n@assert\
    \ even_odd_count(-10) == (0,0)\n@assert even_odd_count(-102) == (0,0)\n@assert\
    \ even_odd_count(-1025) == (0,0)\n@assert even_odd_count(-9999) == (0,0)\n@assert\
    \ even_odd_count(-1000) == (0,1)\n</cell>\n<text>\nProblem 1\nWrite a function\
    \ called even_odd_sum which takes in a single integer $n$ and returns $n$ if $n$\
    \ is even and $n+n$ if $n$ is odd. Your function should work correctly for negative\
    \ integers and should work for positive and negative values of $n$.", "    if\
    \ num < 0\n        error(\"Negative integers are not allowed\")\n    end", " \
    \   if num < 0\n        error(\"num is negative\")\n    elseif num == 0\n    \
    \    (1, 0)\n    else\n        num::Int64 = 0\n        even::Int64 = 1\n     \
    \   odd::Int64 = 2\n        while num != 0\n            if num % 2 == 0\n    \
    \            num = num div 2\n                even += 1\n            else\n  \
    \              num = num div 2\n                odd += 1\n        end\n      \
    \  (even, odd)\n    end\nend\n</cell>\n<code language=julia-1.2>", "    if num<0\
    \ return (1,1)\n    if num<0 return (1,1)\n    if num<10 return (1,0)\n    if\
    \ num<10 return (1,0)\n    if num%10==0 return (1,0)\n    if num%10==1 return\
    \ (0,1)\n    return even_odd_count(num/10)\nend ", "    if num < 0 return (1,0)\
    \ end\n    if num == 0 return (1,0) end\n    if num < 10 return (1,0) end\n  \
    \  if num < 100 return (1,1) end\n    if num < 1000 return (1,2) end\n    if num\
    \ < 10000 \n        if num < 100000 return (2,1) \n        else return (2,2) \n\
    \        end\n    end\n    if num < 100000\n        if num < 1000000\n       \
    \     if num < 10000000 return (3,1) \n            else return (3,2) \n      \
    \      end\n        else return (3,2) \n        end\n    end\n    if num < 10000000\
    \ \n        if num < 100000000 \n            if num < 1000000000 return (4,1)\
    \ \n            else return (4,2) \n            end\n        else return (4,2)\
    \ \n        end\n    end\n    if num < 1000000000 \n        if num < 10000000000\
    \ \n            if num < 100000000000 \n                if num < 1000000000000\
    \ \n                    if num < 10000000000000 \n                        if num\
    \ < 100000000000000\n                            if num < 1000000000000000 \n\
    \                                if num < 10000000000000000 \n               \
    \                     if num < 100000000000000000 \n                         \
    \               if num < 1000000000000000010 \n                              \
    \              return (5, 1) \n                                            else\
    \ return (5, 2) \n                                            end\n          \
    \                              else return (5, 2) \n                         \
    \               end\n                                    else return (5, 2) \n\
    \                                    end\n                                else\
    \ return (5, 2) \n                                end\n                      \
    \      else return (5, 2) \n                            end\n                \
    \        else return (5, 2) \n                        end\n                  \
    \  else return (5, 2) \n                    end\n                end\n       \
    \     else return (5, 2) \n            end\n        else return (5, 2) \n    \
    \    end\n    end\n    if num < 100000000000 \n        if num < 1000000000000\
    \ \n            if num < 10000000000000\n                if num < 100000000000000\n\
    \                    if num < 1000000000000000 \n                        if num\
    \ < 10000000000000000 \n                            if num < 100000000000000000\
    \ \n                                if num < 1000000000000000010 \n          \
    \                          return (6, 1) \n                                  \
    \  else return (6, 2) \n                                    end\n            \
    \                    else return (6, 2) \n                                end\n\
    \                            else return (6, 2) \n                           \
    \ end\n                        else return (6, 2) \n                        end\n\
    \                    else return (6, 2) \n                    end\n          \
    \      else return (6, 2) \n                end\n            else return (6, 2)\
    \ \n            end\n        else return (6, 2) \n        end\n    end\n    if\
    \ num < 1000000000000 \n        if num < 10000000000000 \n            if num <\
    \ 100000000000000 \n                if num < 1000000000000000 \n             \
    \       if num < 10000000000000000 \n                        if num < 100000000000000000\
    \ \n                            if num < 1000000000000000010 \n", "    if num\
    \ < 0\n        error(\"Invalid input: even_odd_count only accepts positive/negative\
    \ integers\")\n    else\n        # write your code here\n        odd_count = 0\n\
    \        even_count = 0\n        for n in num\n            if n % 2 == 0\n   \
    \             even_count += n\n            else \n                odd_count +=\
    \ n\n        return (even_count, odd_count)", "    if num<0\n        error(\"\
    Input must be positive\")\n    elseif num==0\n        return (1, 0)\n    else\n\
    \        if num > 2^(log_2 num)\n            return (1, num)\n        else\n \
    \           sumEven::Int64 = 0\n            sumOdd::Int64 = 0\n            for\
    \ i in 1:num\n                if mod(num, 2) == 0 \n                    sumEven\
    \ = sumEven + 1\n                else\n                    sumOdd = sumOdd + 1\n\
    \            end\n            return (sumEven, sumOdd)\n        end\n    end\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| a tags=julia,performance |>\nThe fastest way\
    \ I found to count the number of even and odd numbers, is to use bit-hacks. Here\
    \ is how it can be done.\n<code>", "    if num == 0\n        return (1,1)\n  \
    \  else\n        odd = num % 10\n        even = num - odd\n        return (even,\
    \ odd)\n    end\nend", "    if num < 0\n    then (0, 1)\n    else\n        even_odd_count(num\
    \ / 2)\n        + (num % 2 == 0 ? 1 : 0)\n    end\nend\n</cell>\n<code language=julia-1.1>\n\
    @time even_odd_count(-5)\n</cell>\n<code language=julia-1.1>\n@time even_odd_count(5)\n\
    </cell>\n<text>\nJulia's macros\nJulia macros are powerful and useful. But sometimes\
    \ you need to write some code manually and you just cannot figure out how to make\
    \ it work efficiently. This section is dedicated to macros.", "    if num < 0\n\
    \        error(\"Input must be a positive integer\")\n    else\n        return\
    \ (num%2 == 0,num%2 == 1)\n    end", "    even, odd = 0, 1\n    while num > 0\n\
    \        if num % 2 == 0\n            even += 1 # num is even\n        else \n\
    \            odd += 1 # num is odd\n        num /= 2\n    return even, odd\n</cell>\n\
    <code language=julia-1.4>\n@time even_odd_count(123456789);\n</cell>\n<text>\n\
    How long does it take to find the sum of all numbers from 0 to 1,000,000?", " \
    \   if num < 0 then (1, 1) else if isodd(num) then (2, 1) else (1, 0)\nend", " \
    \   even, odd = 0, 0\n    for i in 1:num\n        i % 2 == 0 ? even+=i : odd+=i\n\
    \    end\n    return even, odd\nend\n</cell>\n<text>\nExercise: Write a function\
    \ that returns the greatest common denominator of two integers.", "    if num\
    \ == 0 \n        return (0,0) \n    odd = num % 2 \n    even = num - odd \n  \
    \  return (even, odd) \nend", "    even, odd = 0, 0\n    for i in 0...num\n  \
    \      digit = num % 10\n        if (digit == 0)\n            even = even+1\n\
    \        else\n            odd = odd+1\n    end\n    return even, odd\nend", " \
    \   if num<0\n    error(\"even_odd_count needs positive integers\")\n    end\n\
    \    even_sum = 0\n    odd_sum = 0\n    while num>0\n        digit = num % 10\n\
    \        if digit==0\n            even_sum+=1\n        else\n            odd_sum+=1\n\
    \        end\n        num = num / 10\n    end\n    return (even_sum, odd_sum)\n\
    end\n</cell>\n<text>\nSandwich \nProblem 4 \nGiven an array, determine if a subset\
    \ of that array is sandwiched."]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
