name: HumanEval_36_fizz_buzz
language: jl
prompt: "\"\"\"Return the number of times the digit 7 appears in integers less than\
  \ n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n\
  \    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\nfunction fizz_buzz(n::Int64)::Int64\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = fizz_buzz;\n\t@test(candidate(50)\
  \ == 0)\n\t@test(candidate(78) == 2)\n\t@test(candidate(79) == 3)\n\t@test(candidate(100)\
  \ == 3)\n\t@test(candidate(200) == 6)\n\t@test(candidate(4000) == 192)\n\t@test(candidate(10000)\
  \ == 639)\n\t@test(candidate(100000) == 8026)\nend\n"
completions: ["    if n<11 || (n<13 && n%11==0)\n        return 0\n    elif n<19 ||\
    \ (n<20 && n%13==0)\n        return 1\n    else \n        return 2\nend\n</cell>\n\
    <code language=julia-1.0>\n@time fizz_buzz(10)\n</cell>\n<code language=julia-1.0>\n\
    @time fizz_buzz(100)\n</cell>\n<code language=julia-1.0>\n@time fizz_buzz(200000000)\n\
    </cell>\n<code language=julia-1.0>\n@time fizz_buzz(2000000000)\n</cell>\n<text>\n\
    We can write this function as a macro.", "    if n%11==0 || n%13==0\n        then\
    \ return n\n        elseif n%3==0 && n%5==0 && n%7==0\n        then return n\n\
    \        elseif n%3==0 && n%5==0\n        then return n%7\n        elseif n%3==0\n\
    \        then return n%5\n        elseif n%5==0\n        then return n%7\n   \
    \     elseif n%7==0\n        then return n%3\n        else return n", "    if\
    \ n % 11 == 0 || n % 13 == 0 \n        then 0 \n        else (n / 11) * 13 + 7\n\
    \    else 0\nend\n</code>\nThis returns 0 if n is divisible by 11 or 13, otherwise\
    \ it will return an Integer that represents how many times 7 appears in numbers\
    \ less than n.\nThe return 0 is written like this to avoid confusion about what\
    \ it does when n is divisible by both.\n<|/ a |>\n<| a dscore=0 |>\nHere's another\
    \ solution, for fun.\n<code>", "    if n <= 0 then 1 else fizz_buzz(n - 1)\n \
    \   if n <= 1 then 1 else fizz_buzz(n - 2)\n    if n % 11 == 7 && n % 13 == 7\
    \ then return 1 + fizz_buzz(n / 11) + fizz_buzz(n / 13)\n    if n % 11 == 7 then\
    \ return 1 + fizz_buzz(n / 11)\n    if n % 13 == 7 then return 1 + fizz_buzz(n\
    \ / 13)\n    else return 0", "    if n % 11 == 0 or n % 13 == 0\n        return\
    \ n mod 11\n    else \n        return 1\n    end\nend", "    if n%11 == 0 \n \
    \       then return 0\n    else if n%13 == 0 \n        then return 2\n    else\
    \ return 1\nend", "    if n<0 \n        error(\"fizz_buzz(n): n must be a positive\
    \ integer\")\n    elseif n<7\n        n \n    elseif n<11\n        n\n    elseif\
    \ n<13\n        n+1\n    else\n        n \n    fizz_buzz \nend", "    if n % 11\
    \ == 0 || n % 13 == 0 \n    then 1 else 0\n    end\nend\n</code>\n<|/ a tags=fizzbuzz,julia\
    \ |>\n<| a dscore=0 |>\n<code>\njulia> function fizz_buzz(n)\n           if n%3\
    \ == 0\n              return \"Fizz\"\n           elseif n%5 == 0\n          \
    \    return \"Buzz\"\n           elseif n%15 == 0\n              return \"FizzBuzz\"\
    \n           else\n              return \"FizzBuzz\"\n           end\n       end",
  "    digits = num2str(n)\n    \n    for i in digits \n        if i == '7'\n    \
    \        return fizz_buzz(n // 10) + fizz_buzz(n // 100) + fizz_buzz(n // 1000)\n\
    \    return 0\nend", "    if n==0 or n==1 \n        then 1\n    else if ((n%3==0\
    \ or n%3==1)) && (n%7==0) \n        then fizz_buzz(n/3+1)\n    else fizz_buzz(n/3+1)\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a tags=fizzbuzz,julia,recursion |>\nThis question\
    \ doesn't really have anything to do with FizzBuzz, but rather how to calculate\
    \ numbers iteratively without recursion. I'll point out that there are a number\
    \ of ways to calculate Fibonacci numbers and many other numbers. This is just\
    \ one example of a simple and clear way to calculate Fibonacci numbers iteratively.\n\
    <code>", "    if n==0\n    then return 0\n    else if n==11\n    then return 1\n\
    \    else if n==13\n    then return 2\n    else \n        return fizz_buzz(n-11)+fizz_buzz(n-13)\n\
    \    end\nend\n</cell>\n<code language=julia-1.0>\n# solution using loops", " \
    \   if n >= 0\n    && n%11 == 0\n    && n%13 == 0\n    then return 0\n    else\
    \ if n >= 0\n    && n%11 == 0\n    && n%13 != 0\n    then return 1\n    else if\
    \ n >= 0\n    && n%11 !=0\n    && n%13 !=0\n    then return 2\n    else if n >=\
    \ 0\n    && n%11 !=0\n    && n%13 == 0\n    then return 3\n    else if n >= 0\n\
    \    && n%11 !=0\n    && n%13 != 0\n    then return 4\n    else return 5\n   \
    \ end \nend", "    \"\"\"\n    Function fizz_buzz, input: Int n, the number whose\
    \ fizzbuzz is desired.\n    Output: Int , the number of times the digit 7 appears\
    \ in integers less than n which are divisible by 11 or 13. \n    >>> fizz_buzz(50)\n\
    \    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\
    \n    if n % 11 == 0 or n % 13 == 0:\n        return 1\n    else:\n        return\
    \ 0\n    \"\"\"\n    Function fizz_buzz, input: Int n, the number whose fizzbuzz\
    \ is desired.\n    Output: Int , the number of times the digit 7 appears in integers\
    \ less than n which are divisible by 11 or 13. \n    >>> fizz_buzz(50)\n    0\n\
    \    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"", "  \
    \  if n <= 0\n        return n\n    if n % 11 == 0 or n % 13 == 0\n        return\
    \ n\n    return fizz_buzz(n - 1)\nend", "    if n==0 then return 0 else if n==1\
    \ then return 1 else return fizz_buzz(n-1)\n    return if n%11==0 or n%13==0 then\
    \ 1 else 0", "    if n%11==0 && n%13==0 \n        then 1 else 0\n    fizz_buzz(n\
    \ - 10)\nend\n</code>\n<|/ a tags=fizzbuzz,julia dscore=1 |>\n<| a dscore=1 tags=fizzbuzz,julia\
    \ |>\nHere is a solution which uses only conditionals and no loops:\n<code>",
  "    if (n==0) return 0\n    if (n%3==0) && (n%7==0) then return 1\n    if (n%3==0)\
    \ && (n%5==0) then return 2\n    if (n%3==0) && (n%7==0) then return 3\n    if\
    \ (n%3==0) && (n%5==0) then return 4\n    if (n%3==0) && (n%7==0) then return\
    \ 5\n    if (n%3==0) && (n%5==0) then return 6\n    if (n%3==0) && (n%7==0) then\
    \ return 7\n    if (n%3==0) && (n%5==0) then return 8\n    if (n%3==0) && (n%7==0)\
    \ then return 9\n    if (n%3==0) && (n%5==0) then return 10\n    if (n%3==0) &&\
    \ (n%7==0) then return 11\n    if (n%3==0) && (n%5==0) then return 12\n    if\
    \ (n%3==0) && (n%7==0) then return 13\n    if n mod 3 == 0 then return fizz_buzz((n\
    \ div 3))\n    if n mod 5 == 0 then return fizz_buzz((n div 5))\n    if n mod\
    \ 7 == 0 then return fizz_buzz((n div 7))\n    if n mod 11 == 0 then return fizz_buzz((n\
    \ div 11))\n    if n mod 13 == 0 then return fizz_buzz((n div 13))\n    return\
    \ n\nend\n\"\"\"\nReturn the sum of all the numbers from 1 to n which are divisible\
    \ by 11 or 13.\n>>> fizz_buzz(50)\n2\n>>> fizz_buzz(78)\n8\n>>> fizz_buzz(79)\n\
    16\n\"\"\"", "    if n==7\n        0\n    else \n        if n % 11 == 0\n    \
    \        2 fizz_buzz(n/11)\n        elif n % 13 == 0\n            3 fizz_buzz(n/13)\n\
    \        else\n            fizz_buzz(n-11) fizz_buzz(n-13)\n        end\n    end\n\
    end\n</cell>\n<code language=julia-0.6>", "    if n%3 == 0\n        n /= 3\n \
    \       if n%3 == 0\n            n /= 3\n            if n%3 == 0\n           \
    \     n /= 3\n                return n\n            else\n                return\
    \ n\n        end \n    elseif n%11 == 0\n        n /= 11\n        if n%11 == 0\n\
    \            n /= 11\n            if n%11 == 0\n                n /= 11\n    \
    \            return n\n            else\n                return n\n          \
    \  end \n        else\n            return n\n        end \n    elseif n%13 ==\
    \ 0\n        n /= 13\n        if n%13 == 0\n            n /= 13\n            if\
    \ n%13 == 0\n                n /= 13\n                return n\n            else\n\
    \                return n\n            end \n        else\n            return\
    \ n\n        end \n    else\n        return n\n    end \nend ", "    if n % 11\
    \ == 0 and n % 13 == 0:\n        return 0\n    elif n % 11 == 0:\n        return\
    \ 1\n    elif n % 13 == 0:\n        return 2\n    else:\n        return -1\n \
    \   end\n</cell>\n<code language=julia-1.5>\nfizz_buzz(50)\n</cell>\n<code language=julia-1.5>\n\
    fizz_buzz(78)\n</cell>\n<code language=julia-1.5>\nfizz_buzz(79)\n</cell>\n<text>\n\
    Exercise: Write a function to return the number of times digit 7 appears in integers\
    \ less than n which are divisible by 31 or 31.", "    if n == 0 \n        0 \n\
    \    elif n == 1\n        1 \n    elif n == 2\n        3 \n    elif n % 11 ==\
    \ 0\n        n / 11\n    elseif n % 13 == 0\n        n / 13\n    else\n      \
    \  n\n    end\nend\n</code>\n<|/ a tags=julia,numbers,fizzbuzz dscore=2 |>\n<|\
    \ a |>\n<code>\nusing Printf", "    if n%11==0 or n%13==0:\n        return 0\n\
    \    if n%11==0 and n%13!=0:\n        return 1\n    if n%11!=0 and n%13==0:\n\
    \        return 2\n    return 3", "    if n % 11 == 0 and n % 13 == 0:\n     \
    \   return 1\n    if n % 11 != 0 and n % 13 != 0:\n        return 2\n    return\
    \ 0", "    if n % 11 == 0 and n % 13 == 0 then return 0 else n % 11\n    return\
    \ n % 13 + fizz_buzz(n % 11)\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ocaml,fizzbuzz\
    \ dscore=2 |>\n<code>\nlet rec fizz_buzz n = \n    if n < 1 then \n        []\
    \ \n    else if n%3 == 0 then \n        [3; 4; 5; 6; 7; 8]@(fizz_buzz(n/3))\n\
    \    else \n        [3; 4; 5; 6; 7; 8; 9; 10; 11]@(fizz_buzz(n/3)+[3; 4; 5; 6;\
    \ 7; 8; 9; 10; 11]@(fizz_buzz(n/3)))\n</code>\n<|/ a |>\n<| a |>\nI made a version\
    \ that works with tuples and returns them instead of lists. You can make it do\
    \ different things, but this seems to be the most efficient way to do it without\
    \ recursion at all. \n<code>\nlet rec fizz_buzz n =\n  if n = 0 then \n    0 \n\
    \  else \n    let (digits, rest) = n / 10 in\n    if n%10 = 0 then \n      if\
    \ digits = 0 then \n        (0,0)\n      else \n        (0,1)\n    else \n   \
    \   if digits > 0 then \n        (digits,0)\n      else \n        (digits,1)\n\
    \      (*\n        digit 2 will be 1 if the rest of the division is even. \n \
    \       So we divide by 2, add the result of the division to the \n        previous\
    \ results and add the result of the division to the \n        previous result\
    \ and so on\n      *)\n    in\n    let digits = digits + rest in\n    let digits\
    \ = digits/10 in\n    if digits > 0 then \n      (*\n        digit 2 will be 1\
    \ if the rest of division is even.\n        So we divide by 2, add the result\
    \ of the division to the \n        previous result and add the result of the division\
    \ to the \n        previous result and so on\n      *)\n      fizz_buzz (digits,\
    \ 1)\n    else \n      fizz_buzz (digits, 0)\n</code>\n<|/ a tags=ocaml,fizzbuzz\
    \ dscore=1 |>\n<| a dscore=1 |>\nHere is a solution that is a bit simpler and\
    \ faster for the case when n is a multiple of 3:\n<code>\nlet rec fizz_buzz n\
    \ =\n  match n with\n  | 0 -> []\n", "    if n % 11 == 0 or n % 13 == 0 \n   \
    \     then 0 else 1\n    end\nend\n</cell>\n<code language=julia-1.3>\nfizz_buzz(100)\n\
    </cell>\n<code language=julia-1.3>", "    if n%11==0 and n%13==0 then \n     \
    \   return fizz_buzz(n/11) + 1\n    else \n        return fizz_buzz(n/13)\n</code>\n\
    <|/ a |>\n<| c |>\nAs an additional solution, `function fizz_buzz(n::Int64) =\
    \ (if n%11==0 and n%13==0 then fizz_buzz(n/11) + 1 else fizz_buzz(n/13))` might\
    \ be better - you get to keep it all in one line.\n<|/ c |>\n<| c |>\nThis one\
    \ is also awesome.  I learned something here.  I didn't know you couldn't have\
    \ multiple line returns in a function like that.\n<|/ c |>\n<| c |>\nA recursive\
    \ function with multiple returns in it is possible in Rust (but not in C++). The\
    \ first return ends the function, the second one returns from the enclosing function\n\
    <|/ c |>\n<| a |>\nHere's a solution using fold\n<code>\nlet fizz_buzz n = (\n\
    \    fn loop i \n        | i < n -> Some((\n            match i % 11\n       \
    \     | 0 -> Some(i)\n            | _ -> \n                match i % 13\n    \
    \            | 0 -> Some(i)\n                | _ -> None\n            )\n    \
    \        |> Option.fold (fun (a, b) -> a + 1) 0)\n        | _ -> None\n    )\n\
    </code>\nor perhaps more readable (as suggested by):\n<code>\nlet fizz_buzz n\
    \ = (\n    fn loop i \n        | i < n -> Some((\n            i % 11\n       \
    \     |> Option.fold (fun (a, b) -> a + 1) 0)\n            |> Option.fold (fun\
    \ (a, b) -> a + 1) 0)\n        | _ -> None\n    )\n</code>\n<|/ a tags=tail-recursion,fold,fizzbuzz,rust\
    \ dscore=2 |>\n<| c |>\nI think that `Option.fold` can be written as `|0 -> Some(i)|_\
    \ -> Some(i)`. And that `Option.fold` can be written as `Option.fold_left`.\n\
    <|/ c |>\n<| c |>\nthat's a much more readable version. I updated the answer.\
    \ Thanks!\n<|/ c |>\n<| a tags=tail-recursion,fold,fizzbuzz,rust |>\nHere is an\
    \ iterative version using fold:\n<code>\nfn fizz_buzz(n: usize) -> Option<usize>\
    \ {\n    Some(n % 11).or_else", "  if n <= 13\n    then return n\n  else if n\
    \ % 11 == 0 or n % 13 == 0\n    then return n\n  else if n % 11 > 0 and n % 13\
    \ == 0\n    then return n / 11 + 1\n  else if n % 11 == 0 and n % 13 > 0\n   \
    \ then return n / 13 + 1\n  else \n    then return 0\nend", "    if n % 11 ==\
    \ 0\n        then return 0\n    else if n % 13 == 0\n        then return 0\n \
    \   else\n        return n", "    if isMultipleOf(n,11)\n    then \n        0\n\
    \    elseif isMultipleOf(n,13)\n    then \n        2\n    else\n        fizz_buzz(n-2)\n\
    \    end\nend\n</code>\n<|/ a tags=fizzbuzz,recursion,julia |>\n<| a |>\nI tried\
    \ to improve the code and wrote a function that computes the number of fizzbuzz\
    \ patterns within a given number :\n<code>", "    if n < 13\n        \n      \
    \  else\n            if  n % 13 == 0\n                then return 0\n        \
    \    elseif n % 11 == 0\n                then return 2\n            elseif n %\
    \ 7 == 0\n                then return 3\n            else\n                fizz_buzz(n\
    \ - 13)\n            end\n    end\nend", "    if n<7 return 0 \n    if n%11==0\
    \ and n%13==0 return n \n    else if n%11==0 return fizz_buzz(n/11)+1 \n    else\
    \ if n%13==0 return fizz_buzz(n/13)+1 \n    else return fizz_buzz((n+1)/11)+fizz_buzz((n+1)/13)\n\
    end\n</cell>\n<code language=julia-1.2>\nfizz_buzz(50)\n</cell>\n<text>\nRecursion\n\
    Many functions have recursive definitions. This means they call themselves from\
    \ inside themselves and return a result. One example of this is the fibonacci\
    \ sequence.", "    \"\"\"Return a string representing a number n that is divisible\
    \ by 11 or 13.\n    >>> fizz_buzz(80)\n    '80'\n    >>> fizz_buzz(81)\n    '81'\n\
    \    >>> fizz_buzz(82)\n    '82'\n    >>> fizz_buzz(88)\n    '88'\n    >>> fizz_buzz(89)\n\
    \    '89'\n    \"\"\"", "    if (n%11)==0\n    then return 0\n    else if (n%13)==0\n\
    \    then return 2\n    else\n        if (n%17)==0\n        then return 3\n  \
    \      else return fizz_buzz(n-1)\nend\n</code>\n<|/ a tags=fizzbuzz,recursion,julia\
    \ |>\n<| a tags=fizzbuzz,recursion,julia dscore=1 |>\n<code>", "    if n < 10\
    \ && n % 11 == 0 && n % 13 == 0 \n    then return 0 else \n    if n < 10 && n\
    \ % 11 == 0 \n    then return 1 \n    if n < 10 && n % 13 == 0 \n    then return\
    \ 2 \n    else return 0\nend\n</cell>\n<text>\nExercise 3\nUse the FizzBuzz function\
    \ defined above to find the number of times the digit 2 appears in integers less\
    \ than n which are divisible by 3 and 5.", "    if n==0 then return 0 else if\
    \ n % 11==0 or n % 13==0 then 1 else fizz_buzz(n / 11) + 1\nfizz_buzz(1000)",
  "    if n % 11 == 0 \n        then return 0\n    if n % 13 == 0 \n        then return\
    \ 0\n    return 1\nend", "    \n    \"\"\"\n    check if number is divisible by\
    \ 11 or 13\n    \"\"\"\n    if n%11==0 or n%13==0 then\n        return 0\n   \
    \ else\n        return \n\"\"\"", "    if n==0 || n==1\n        return 0\n   \
    \ if n==2 || n==7 || n==11 || n==13\n        return 1\n    if n%3==0 || n%3==1\n\
    \        return fizz_buzz(n/3)\n    if n%5==0 || n%5==2\n        return fizz_buzz(n/5)\n\
    \    if n%7==0\n        return fizz_buzz(n/7)\n    fizz_buzz(3*n+1)\nend\n</cell>\n\
    <text>\nAs a final example, let's do some timing to compare the performance of\
    \ fizz_buzz.", "    if n < 10\n        fizzbuzz = n\n    else\n        if n %\
    \ 11 == 0\n            fizzbuzz = fizzbuzz + 0\n        elseif n % 13 == 0\n \
    \           fizzbuzz = fizzbuzz + 1\n        else\n            fizzbuzz = fizzbuzz\
    \ + 2\n    return fizzbuzz\nend", "    \n    if n %% 11 == 0\n        n /= 11\n\
    \        n %= 13\n    \n    if n %% 13 == 0\n        n /= 13\n        n %= 11\n\
    \    \n    n\nend\n</code>\n<|/ a dscore=2 tags=fizzbuzz,julia,fizz,performance,numbers\
    \ |>\n<| c |>\nThis code doesn't work for n=100, I get \"ERROR: Method '*' not\
    \ implemented for type Int64\"\n<|/ c |>\n<| c |>\nI didn't test it but I don't\
    \ think you have to change `n` to `n::Int64` in line 8.\n<|/ c |>\n<| c |>\nI\
    \ tested this on Julia 1.0: I get \"ERROR: LoadError: ArgumentError: invalid literal\
    \ for Int64(100 % 11): 100 % 11\".  Are you sure this is right?\n<|/ c |>\n<|\
    \ c |>\nYes, I tested it too. That's because `n` must be `Int64`, but here it\
    \ is `Int`.\n<|/ c |>\n<| c |>\nJust to clarify: this code does work for small\
    \ values of `n`, e.g. `fizz_buzz(10)` returns `1`, while for `fizz_buzz(100)`\
    \ it throws an error because `n` is too large.\n<|/ c |>\n<| a dscore=1 |>\nOne\
    \ could also use the following formula:\n<code>", "    if n==0 || n==1 || n==2\
    \ || n%3==0 || n%3==1 || n%3==2\n        0\n    elseif n%3==0\n        1\n   \
    \ elseif n%3==1\n        fizz_buzz(n/3)\n    else\n        fizz_buzz((n-1)/3)+1\n\
    end", "    if n<13\n        then return 0\n    else if n%11==0\n        then return\
    \ n//11\n    else if n%13==0\n        then return n//13\n    else return n//11\
    \ + n//13\n    end\nend\n</code>\nHere you see how to call a function (and how\
    \ to write in julia). To call this function, you have to import it: using .\n\
    In your case, you have a function called fizz_buzz. So, you write using . to import\
    \ it. And then you call fizz_buzz like that fizz_buzz(n)\nA little tip: If you\
    \ would like to define many functions in a single julia file, you can do that\
    \ with modules. In your case, a file named fizz_buzz.jl contains just the definition\
    \ of fizz_buzz. To load it into julia, you can use:\n<code>\ninclude(\"fizz_buzz.jl\"\
    )\n</code>\nNow, you can call fizz_buzz like that fizz_buzz(n)\n<|/ a dscore=2\
    \ |>\n<| c |>\nGreat answer, but please read [how to write a good answer](http://stackoverflow.com/help/how-to-answer).\
    \ I recommend that you summarize the main points so others can benefit from your\
    \ answer in the future.\n<|/ c |>\n<| c |>\nI hope I did that in the right way.\n\
    <|/ c |>\n<| a tags=julia |>\nThis question might already have an answer but just\
    \ in case someone is new to Julia like me, here is a short answer. Let's assume\
    \ you have a function and you want to use it\n<code>", "    if n==0 then return\
    \ 0 else \n        fizz_buzz(n-1)\n        if mod(n,13)==0 then return 0 else\
    \ \n            if mod(n,11)==0 then return 0 else return 1\n        end\nend\n\
    </code>\n<|/ a |>\n<| c |>\nJust a note - this will take up huge amounts of memory\
    \ on a large number. Consider what happens if the number is 10000000000000.\n\
    <|/ c |>\n<| c |>\nThe above code does not use recursion - it uses iteration.\
    \ Although a recursive function would require a lot of memory, an iterative approach\
    \ uses much less memory. So this code is probably more memory efficient on large\
    \ numbers, but would not be very memory efficient on smaller numbers.\n<|/ c |>\n\
    <| c |>\nYes, I agree that iteration is more memory efficient, but it is also\
    \ more readable and easier to understand. My reason for not using recursion, was\
    \ that I wanted to learn how to do it with recursion.\n<|/ c |>\n<| a dscore=1\
    \ |>\nI see two problems with your code:\nProblem 1:\nYou are iterating over the\
    \ whole list twice here:\n<code>\nfizz_buzz = for n in numbers\n             \
    \    fizz_buzz(n - 1)\n                 if mod(n, 13)==0 \n                  \
    \   then return 0 else \n                     return 1\n                 end\n\
    \             end\n</code>\nYou should be iterating over the list once, and inside\
    \ of the loop, you should compare the number and the previous number:\n<code>\n\
    fizz_buzz = for n in numbers\n                 if n == n-1 \n                \
    \     then return 0 else \n                     return 1\n                 end\n\
    \             end\n</code>\nProblem 2:\nYou are redefining fizz_buzz inside of\
    \ the loop:\n<code>\nfizz_buzz = for n in numbers\n                 fizz_buzz(n\
    \ - 1)\n                 if mod(n, 13)==0 \n                     then return 0\
    \ else \n                     return 1\n                 end\n             end\n\
    </code>\nInstead, you should return from the function after each iteration:\n\
    <code>\nfizz_buzz = for n in numbers\n                 if n == n-1 \n        \
    \             then return 0 else \n                 end\n             end\n</code>\n\
    <|/ a tags=fizzbuzz,julia,performance |>\n<| c |>\nThanks for the response! It\
    \ seems I was missing a step - I didn't realize that redefining a function inside\
    \ the function definition would cause the function to be redefined each time the\
    \ loop iterates. When I remove my fizz_buzz function definition and replace it\
    \ with fizz_buzz inside of the loop, does that fix things?", "    if n < 13\n\
    \        return n\n    elif (n % 11 == 0)\n        return fizz_buzz(div(n, 11))\n\
    \    else\n        return fizz_buzz(div(n, 13))\n    end\nend", "    if n % 11\
    \ == 0 || n % 13 == 0 \n        then return 0\n    else return 1+fizz_buzz((n/10)*10+(n%10))\n\
    </code>\n<|/ a tags=fizzbuzz,haskell |>\n<| a tags=fizzbuzz,haskell |>\nAs others\
    \ have already explained, the solution is already given in other answers. However,\
    \ I'm going to try to provide some explanation as to why your original code doesn't\
    \ work. It has to do with the fact that you're using recursion to find the \"\
    next number in the sequence\". But when working with recursion it's important\
    \ to keep in mind that the \"next number\" being returned is really the next number\
    \ in the sequence after it has been processed.\nFor example say you're working\
    \ with a fizzbuzz sequence. Let's say the starting number is 20. Your function\
    \ will take 20, divide by 10 to get 10, then multiply it by 10 to get 100. You\
    \ then add 10 to it to get 100 + 10 = 1010. Then the function will take 1010 again,\
    \ divide it by 10 to get 10, then multiply it by 10 to get 1000. You then add\
    \ 10 to it to get 1000 + 10 = 1100. So now that your function has worked it's\
    \ going to move onto the second number: 1010. Again, you divide it by 10 to get\
    \ 10, then multiply it by 10 to get 1000. Again, you add 10 to it to get 1100\
    \ + 10 = 1110. You now move onto the third number: 1110.\nBut this is where things\
    \ get a little confusing. How did we get to 1110 at the end of the sequence? Well\
    \ we used the same function that we already used to get to 1010. Let's rewrite\
    \ it a little bit to make it more clear:\n<code>\nfizzbuzz n = fizzbuzz 10 * n\n\
    </code>\nWhen you call this function you pass it 10 as an argument. But what is\
    \ the value of n? It starts out as 20 and since it starts out with a value of\
    \ 20 the value of n will get progressively larger until we reach the number 11.\
    \ The value of n will be 11 (1010) before we get to the number 11. \nSo what happened\
    \ here? We multiplied the value of n by 10 before it got to 11. Now our value\
    \ of n is 1110. At this point we know what we need to do to turn it into a fizzbuzz\
    \ sequence. But where do we get the value? We multiplied the value of n by 10\
    \ again. We then divide it by 10 so we end up with 1000, then we multiply that\
    \ by 10 again. So our sequence becomes:\n<code>\n20 - 10 - 100 - 1000 - 1100",
  "    if n <= 0 \n    then 0 \n    else if  (n % 11) == 0 || \n            (n % 13)\
    \ == 0 \n    then n \n    else fizz_buzz(n - 1) \n    end\nend", "    if n ==\
    \ 0 then return 0\n    if n % 11 == 0 then return 1\n    if n % 13 == 0 then return\
    \ 2\n    return 0\n</code>\n<|/ a |>\n<| a |>\nAs you probably already know FizzBuzz\
    \ is something like this:\n<code>\nIf num % 15 == 0 then \n    Return Fizz\nelse\
    \ if num % 3 == 0 then \n    Return Fizz\nelse if num % 5 == 0 then \n    Return\
    \ Fizz\nelse \n    Return Buzz\n</code>\nBut you can also do this:\n<code>\nIf\
    \ num % 15 == 0 then \n    Return Fizz\nReturn Buzz\n</code>\nOr this:\n<code>\n\
    If num % 15 == 0 then \n    Return Fizz\nelse\n    Return Buzz\n</code>\nAnd you\
    \ can also do this:\n<code>\nIf num % 3 == 0 then \n    Return Fizz\nelse if num\
    \ % 5 == 0 then \n    Return Fizz\nelse\n    Return Buzz\n</code>\nBut you can\
    \ also do this:\n<code>\nIf num % 3 == 0 then \n    Return Fizz\nelse \n    Return\
    \ Buzz\n</code>\nOr this:\n<code>\nIf num % 3 == 0 then \n    Return Fizz\nelse\n\
    \    Return Buzz\n</code>\nAnd so on...\nSo this means that you can use the same\
    \ method to solve FizzBuzz:\n<code>\nIf num % 15 == 0 then \n    Return Fizz\n\
    else if num % 3 == 0 then \n    Return Fizz\nelse if num % 5 == 0 then \n    Return\
    \ Fizz\nelse \n    Return Buzz\n</code>\nWhich is what you are trying to do in\
    \ OCaml. \nNow that you know this, you can apply the same logic to other similar\
    \ problems as well.\n<|/ a tags=ocaml,fizzbuzz dscore=2 |>\n<| c |>\nThe first\
    \ two are exactly the same as `if num % 3 == 0 then Return Fizz; else Return Buzz`.\
    \ The third is exactly the same as `if num % 3 == 0 then Return Fizz; else if\
    \ num % 5 == 0 then Return Fizz; else Return Buzz`.\n<|/ c |>\n<| c |>\nYes, and\
    \ I just noticed that there are 3 examples with exactly that (well, exactly the\
    \ same) conditions, but I did that to show that it can be applied in other cases\
    \ too :)\n<|/ c |>\n<| a tags=ocaml,fizzbuzz |>\nHere is how you can do it with\
    \ Ocaml\n<code>\nlet rec fizz_buzz n =\n  match n with\n  0 -> \"FizzBuzz\"",
  "    if n<10\n    then return n\n    if n%11==0\n    then return n\n    if n%13==0\n\
    \    then return n\n    else\n        return -1\nend\n</cell>\n<text>\nReturn\
    \ an array with the first n Fibonacci numbers. fibs(4) should return [1, 1, 2,\
    \ 3, 5].", "    if n==7 then return 0 else if n==10 then return 1 else if n==13\
    \ then return 2 else fizz_buzz(n-1)\nend", "    if n % 11 == 0 and n % 13 == 0:\n\
    \        return 0\n    elif n % 11 == 0 and n % 13 != 0:\n        return 1\n \
    \   elif n % 11 != 0 and n % 13 == 0:\n        return 2\n    else:\n        return\
    \ 3\nend\n</cell>\n<code language=julia-0.6>\n@assert fizz_buzz(50) == 0 \n@assert\
    \ fizz_buzz(78) == 2 \n@assert fizz_buzz(79) == 3 \n</cell>\n<text>\nExercise:\
    \ What is the fastest way to determine the number of times the digit 7 appears\
    \ in integers less than n which are divisible by 11 or 13?", "    if n < 10\n\
    \        return n\n    else if n % 11 == 0 or n % 13 == 0\n        return n\n\
    \    else\n        return fizz_buzz(n/10) + n % 10\nend", "    \n    if n <= 1\
    \ \n        1\n    elif n % 11 == 0\n        fizz_buzz(n / 11)\n    else\n   \
    \     fizz_buzz(n / 13)\nend\n    \nend\n</cell>\n<code language=julia-0.6>\n\
    fizz_buzz(50)\n</cell>\n<code language=julia-0.6>\nfizz_buzz(78)\n</cell>\n<code\
    \ language=julia-0.6>\nfizz_buzz(79)\n</cell>\n<code language=julia-0.6>\nfizz_buzz(100)\n\
    </cell>\n<code language=julia-0.6>\nfizz_buzz(100)\n</cell>\n<code language=julia-0.6>\n\
    fizz_buzz(101)\n</cell>\n<code language=julia-0.6>\nfizz_buzz(102)\n</cell>\n\
    <code language=julia-0.6>\nfizz_buzz(103)\n</cell>\n<code language=julia-0.6>\n\
    fizz_buzz(104)\n</cell>\n<code language=julia-0.6>\nfizz_buzz(105)\n</cell>\n\
    <code language=julia-0.6>\nfizz_buzz(106)\n</cell>\n<code language=julia-0.6>\n\
    fizz_buzz(107)\n</cell>\n<code language=julia-0.6>\nfizz_buzz(108)\n</cell>\n\
    <code language=julia-0.6>\nfizz_buzz(109)\n</cell>\n<code language=julia-0.6>\n\
    fizz_buzz(119)\n</cell>\n<code language=julia-0.6>\nfizz_buzz(12)\n</cell>\n<code\
    \ language=julia-0.6>\nfizz_buzz(13)\n</cell>\n<code language=julia-0.6>\nfizz_buzz(13)\n\
    </cell>\n<code language=julia-0.6>\nfizz_buzz(15)\n</cell>\n<code language=julia-0.6>\n\
    fizz_buzz(21)\n</cell>\n<code language=julia-0.6>\nfizz_buzz(25)\n</cell>\n<code\
    \ language=julia-0.6>\nfizz_buzz(55)\n</cell>\n<code language=julia-0.6>\nfizz_buzz(55)\n\
    </cell>\n<code language=julia-0.6>\nfizz_buzz(75)\n</cell>\n<code language=julia-0.6>\n\
    fizz_buzz(100)\n</cell>", "    if n >= 11 || n <= 13\n        0\n    else\n  \
    \      if n % 11 == 0 && n % 13 == 0\n            2\n        else\n          \
    \  if n % 13 == 0\n                3\n            else\n                if n %\
    \ 11 == 0\n                    1\n                else\n                    0\n\
    \    end\nend\n</cell>\n<cell>\nfizz_buzz(50)\n</cell>\n<text>\nWrite a function\
    \ that returns the number of times the digit 3 appears in integers less than n\
    \ which are divisible by 7 or 9.", "if n % 11 == 0 \n    return fizz_buzz(n /\
    \ 11)\nelse \n    return fizz_buzz(n / 13) + 1 ", "    if n < 11 then\n      \
    \  return n\n    else\n        if n % 11 == 0 then\n            return fizz_buzz(n\
    \ / 11)\n        elseif n % 13 == 0 then\n            return fizz_buzz(n / 13)\n\
    \        else\n            return fizz_buzz(n / 11) + fizz_buzz(n / 13)\n    \
    \    end\n    end\nend\n</code>\n<|/ a tags=fizzbuzz,recursion dscore=1 |>\n<|\
    \ a dscore=1 tags=fizzbuzz,recursion |>\n<code>\nlet fizz_buzz :: Int -> Int\n\
    let fizz_buzz n\n     | n==0 = 0\n     | n==1 = 1\n     | n==2 = 1\n     | n%3==0\
    \ = 3\n     | n%5==0 = 3\n     | n%7==0 = 3\n     | otherwise = fizz_buzz (n-1)\n\
    </code>\n<|/ a |>\n<| a tags=fizzbuzz,recursion dscore=1 |>\nThe easiest way to\
    \ get a fizz buzz is to use modulus. That way, you can have it return the value\
    \ if it is divisible by 3, 5, or 7. Below is some code to return fizz buzz for\
    \ a number.\n<code>\nlet fizzbuzz x = \n   if x % 3 == 0 then\n      printfn \"\
    FizzBuzz\"\n   elif x % 5 == 0 then\n      printfn \"FizzBuzz\"\n   elif x % 7\
    \ == 0 then\n      printfn \"FizzBuzz\"\n   else\n      printfn \"Fizz\"\n</code>\n\
    <|/ a |>\n<| a tags=fizzbuzz,recursion |>\nI got this working by writing an addition\
    \ function which returns an integer value from its sum:\n<code>", "    if n%11==0\
    \ || n%13==0 \n        then return n\n    else return fizz_buzz(div(n,11)+div(n,13))\n\
    end", "    if n==0 || n==1\n        then return n\n    if n%11==0 && n%13==0\n\
    \        then return n\n    if n%11==0\n        then return 3*n+1\n    if n%13==0\n\
    \        then return 3*n+3\n</code>\n<|/ a |>\n<| a |>\nThe following code will\
    \ calculate fizzbuzz number\n<code>", "    if n%3==0 || n%7==0 then 0 else fizz_buzz(n-3)+1\n\
    end", "    if n % 13 == 0 \n        then return 0\n    else if n % 11 == 0 \n\
    \        then return 1\n    else\n        fizz_buzz(n % 11) + fizz_buzz(n % 13)\n\
    end\n</code>\n<|/ a dscore=4 tags=fizzbuzz,julia,recursion |>\n<| a tags=fizzbuzz,julia,recursion\
    \ |>\nUsing map function\n<code>\nmap(x -> x % 11 ? x % 13 == 0 ? \"FizzBuzz\"\
    \ : x == 0 ? \"Fizz\" : x % 3 == 0 ? \"Buzz\" : x : \"Fizz\" ,1:100)\n</code>\n\
    <|/ a dscore=4 |>\n<| a tags=fizzbuzz,julia,recursion |>\n<code>", "    if n<0\
    \ || n>50\n    then return 0\n    else if n % 11 == 0\n    then return n\n   \
    \ else if n % 13 == 0\n    then return n\n    else return fizz_buzz(n/11) + fizz_buzz(n/13)\n\
    end\n</cell>\n<cell>\n@time fizz_buzz(1_000_000)\n</cell>\n<text>\nA more efficient\
    \ solution can be written which avoids redundant computations of fizz_buzz recursively.\
    \ The idea is to use successive digits of n as input to the function and output\
    \ the number of times 7 appears in the input digits.", "    if n%11==0 || n%13==0\n\
    \        then return 0\n    else\n        if n%11==7\n            then return\
    \ 1\n        elseif n%13==7\n            then return 2\n        else\n       \
    \     return 3\n    end\nend", "    if n <= 0\n        0\n    else if n % 11 ==\
    \ 0\n        n\n    elseif n % 13 == 0\n        n - 10\n    else\n        n -\
    \ 11\n    end\nend", "    if n % 11 == 0\n        then return 0\n    elif n %\
    \ 13 == 0 \n        then return 1\n    else \n        then return 2\n    end\n\
    end", "    if n<10\n    then return n\n    else \n        if n%11==0\n       \
    \ then return fizz_buzz(n/11)\n        else return fizz_buzz(n/13) + fizz_buzz(n%13)\n\
    end\n</code>\n<|/ a dscore=4 |>\n<| c |>\nWhat if I have the case where n = 10?\n\
    <|/ c |>\n<| a tags=fizzbuzz,julia,recursion |>\nHere is the answer using the\
    \ package FizzBuzz.\n<code>\nusing FizzBuzz\nfizz_buzz(10)\n</code>\n<|/ a dscore=3\
    \ |>\n<| a |>\nHere's an answer, written in a slightly different style, using\
    \ pattern matching in Julia. The key is to remember that functions are first-class\
    \ citizens in Julia, and that you can put your conditions in an if statement in\
    \ any place where a Boolean expression is allowed. \n<code>", "    if n < 11 ||\
    \ n > 1000 || n % 11 == 0 || n % 13 == 0 \n        return n \n    else \n    \
    \    return fizz_buzz(n/10) * 10 + fizz_buzz(n%10)\nend", "    if n%11==0 && n%13==0\n\
    \        then return 0\n    else if n%11==0 \n        then return 1\n    else\
    \ if n%13==0\n        then return 2\n    else if n%11==0 && n%13==0 \n       \
    \ then return 3\n    else if n%11==0 && n%13!=0 \n        then return 4\n    else\
    \ return 5", "    if n % 11 == 0\n        then return n / 11\n    else if n %\
    \ 13 == 0\n        then return n / 13\n    else return 0", "    if (n >= 0 &&\
    \ n % 11 == 0) || (n >= 0 && n % 13 == 0)\n        then return (n - n % 11) /\
    \ 2\n    else\n        return 0\nend\n</cell>\n<code language=julia-0.4>", " \
    \   if n<0 || n>100 || mod(n,11)==0 || mod(n,13)==0 then return 0 else return\
    \ 1\n    else if n==7 or n==11 then return 0 else return fizz_buzz(n-1)+1\nend\
    \ \n</code>\n<|/ a tags=recursion,fizzbuzz,fizzbuzz-puzzle,haskell,list |>\n<|\
    \ c |>\nThanks for this, I really appreciate it. It didn't occur to me that there\
    \ were two ways to solve this problem. I'm really new to Haskell, so I'm still\
    \ wrapping my head around some of the basic concepts.\n<|/ c |>\n<| a tags=recursion,fizzbuzz,fizzbuzz-puzzle,haskell,list\
    \ |>\nThe simplest way to solve this problem is by making a recursive function\
    \ which solves it. Let's make an example function to understand it better:\n<code>\n\
    fizzbuzz :: Int -> String\nfizzbuzz n\n  | n < 10      = \"fizzbuzz \"++show n\n\
    \  | n == 0       = \"fizzbuzz \"++show n\n  | n % 3       = 0\n  | n % 5    \
    \   = 0\n  | otherwise  = \"fizzbuzz \"++show n\n</code>\nThis function returns\
    \ a string with all the numbers divisible by 3 or 5 being replaced with \"fizzbuzz\
    \ \", followed by the number itself.\nNow the tricky part: how do you make a function\
    \ which makes an infinite list out of an infinite list of numbers?\nWell, the\
    \ best way I can think of would be to create a list and then reverse it.\n<code>\n\
    fizzbuzz :: Int -> [String]\nfizzbuzz n\n  | n < 10      = \"fizzbuzz \"++show\
    \ n\n  | n == 0       = [n]\n  | n % 3       = 0 : fizzbuzz (n-1)\n  | n % 5 \
    \      = 0 : fizzbuzz (n-1)\n  | otherwise   = [n] ++ fizzbuzz (n-1)\n</code>\n\
    The function takes the number n and makes a list with the strings \"fizzbuzz \"\
    \ and then the number itself. The numbers will be put in the list from left to\
    \ right, so the last number in the list is the number we were given.\nNow we can\
    \ use map to map this list to another list:\n<code>\nfizzbuzz n = map fizzbuzz\
    \ n\n</code>\nThis will give us a list with the strings \"fizzbuzz \" and then\
    \ the numbers in the correct order.\nNow we can join the list together with the\
    \ string \"fizzbu", "    if n%11==0 && n%13==0\n        0\n    else\n        fizz_buzz(n/13)\n\
    \        fizz_buzz(n/11)\nend\n</cell>\n<code language=julia-1.6>", "    return\
    \ ifelse(n%3==0, 1+fizz_buzz(n/3), fizz_buzz(n/3))\nend", "    count=0\n    for\
    \ x in Int64.range(1,n)\n        if x%11==0 \n            count +=1\n        if\
    \ x%13==0\n            count+=1\n    return count\nend", "    if n%11==0 and n%13==0\
    \ then return 0\n    if n%11==0 then return 1\n    if n%13==0 then return 2\n\
    \    return 3", "    if n<11 || n>13 then return 0 else if n==11 then 1 else 2\
    \ end \n    fizz_buzz(floor((n-1)/11))\nend\n\"\"\"\n    time complexity: O(1)\n\
    \    \"\"\"", "    if n < 11 || n > 14\n        then return n\n    elseif n %\
    \ 11 == 0 || n % 13 == 0 \n        then return n + fizz_buzz(n div 11)\n     \
    \   else return fizz_buzz(n div 13)\nend\n</code>\n<|/ a tags=fizzbuzz,julia,recursion\
    \ dscore=3 |>\n<| a dscore=2 |>\nThe other answers didn't help me, I'm still looking\
    \ for a way to implement this using recursion.\nI came up with the following solution:\n\
    <code>", "    if n % 11 == 0 and n % 13 == 0:\n        return 0\n    elif n %\
    \ 11 != 0 or n % 13 != 0:\n        return 1\n</code>\n<|/ a |>\n<| a tags=haskell\
    \ |>\n<code>\nfizzbuzz :: Int -> String\nfizzbuzz n = map (\\x -> if x == '1'\
    \ then \"fizz\" else \"buzz\") (fizzbuzz' n)\n    where fizzbuzz' n = if n `mod`\
    \ 3 == 0 || n `mod` 5 == 0 then [n `mod` 3, n] else \n            map (\\x ->\
    \ if x == 0 || x == 3 then \"fizz\" else if x == 5 then \"buzz\" else x)\n   \
    \            (fizzbuzz' (n `div` 3))\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ |>\nHere's a slightly more elegant solution than those that have been presented:\n\
    <code>\nfizzbuzz x = case x `div` 3 of\n    0 -> [x, x+1]\n    1 -> [x, x, x+1]\n\
    \    2 -> [x, x, x, x+1]\n    _ -> [x, x, x, x, x+1, x+1]\n</code>\n<|/ a tags=haskell\
    \ |>\n<| c |>\nWhat about `fizzbuzz n = map (\\x -> if x == 0 || x == 3 then \"\
    fizz\" else if x == 5 then \"buzz\" else x) $ fizzbuzz' (n-1)`? :P\n<|/ c |>\n\
    <| c |>\n`map (\\x -> if x == 0 || x == 3 then \"fizz\" else if x == 5 then \"\
    buzz\" else x) . fizzbuzz` (or `map . fizzbuzz . (-1)`). But I agree, that solution\
    \ is very clever.\n<|/ c |>\n<| a |>\nI tried to make it as general as possible\
    \ by using the same \"divisibility\" conditions as in the original answer.\n<code>\n\
    fizzbuzz :: Int -> String\nfizzbuzz n = map (\\x -> if x == '1' then \"fizz\"\
    \ else \"buzz\") (fizzbuzz' n)\n    where fizzbuzz' n = if n `mod` 3 == 0 || n\
    \ `mod` 5 == 0 then [n `mod` 3, n] else \n            map (\\x -> if x == 0 ||\
    \ x == 3 then \"fizz\" else if x == 5 then \"buzz\" else x)\n               (fizzbuzz'\
    \ (n `div` ", "    if n % 11 == 0 or n % 13 == 0 \n        then return 0\n   \
    \     else return \n            fizz_buzz(n/10) +\n            fizz_buzz(n%10)\
    \ +\n            fizz_buzz((n+1)/10)\n    end\n</code>\n<|/ a tags=haskell,fizzbuzz\
    \ |>\n<| a tags=haskell,fizzbuzz dscore=0 |>\n<code>\nfizBuzz x = \nif x `mod`\
    \ 3 == 0 && x `mod` 5 == 0\n    then \"FizzBuzz\"\n    else if x `mod` 3 == 0\
    \ \n        then \"Fizz\"\n    else if x `mod` 5 == 0\n        then \"Buzz\"\n\
    \    else \"\"", "    if n % 11 == 0 and n % 13 == 0:\n        return 0\n    if\
    \ n % 11 == 0:\n        return 1\n    if n % 13 == 0:\n        return 2\n</code>\n\
    <|/ a |>\n<| c |>\nWhy do you use a `return` in the last line?\n<|/ c |>\n<| c\
    \ |>\nI used it for my first example when I had a return statement in the `if-else`\
    \ statements. I left it out when I wrote this answer. I'll edit my answer to remove\
    \ it.\n<|/ c |>\n<| c |>\nThanks for the comment! I appreciate it.\n<|/ c |>\n\
    <| a tags=fizzbuzz,haskell dscore=0 |>\nA function called 'fizzbuzz' takes argument\
    \ and returns nothing. \n<code>\nfizzbuzz :: Int -> IO ()\nfizzbuzz n = putStrLn\
    \ (show n)\n</code>\nThe function above is simple, but it prints something. The\
    \ following function takes a number n and returns fizzbuzz n (if n is a multiple\
    \ of 10, fizzbuzz n (if n is a multiple of 5, fizzbuzz n (if n is a multiple of\
    \ 3, fizzbuzz n (if n is a multiple of 1, ...))))\n<code>\nfizzbuzz' :: Int ->\
    \ IO (String)\nfizzbuzz' n = if mod n 10 == 0\n               then fizzbuzz (n\
    \ `div` 10)\n               else if mod n 5 == 0\n                then fizzbuzz\
    \ (n `div` 5)\n                else if mod n 3 == 0\n                 then fizzbuzz\
    \ (n `div` 3)\n                 else if mod n 1 == 0\n                   then\
    \ fizzbuzz n\n                   else if mod n 7 == 0\n                     then\
    \ fizzbuzz (n `div` 7)\n                     else \"\"", "    if n%11==0 or n%13==0\
    \ \n        return 0\n    else\n        if n%11>0\n            return 1\n    \
    \    else\n            return fizz_buzz(n-1)\nend\n</cell>\n<text>\nPart 2: Solve\
    \ the problem", "    if n % 11 == 0 && n % 13 == 0\n        fizz_buzz(n * 11 +\
    \ 1)\n    else\n        n\nend\n</cell>\n<text>\nThe if statement will only be\
    \ executed when n is divisible by 11 and 13. This means that the function will\
    \ return n if n is divisible by 11 or 13.", "    if n % 11 == 0 or n % 13 == 0\
    \ \n        then n / 11\n        else n / 13\n    end\nend\n</cell>\n<code language=julia-1.3>\n\
    fizz_buzz(50)\n</cell>\n<code language=julia-1.3>\nfizz_buzz(78)\n</cell>\n<code\
    \ language=julia-1.3>\nfizz_buzz(79)\n</cell>\n<code language=julia-1.3>\n\"\"\
    \"Return the number of times the digit 7 appears in integers less than n which\
    \ are divisible by 11 and are divisible by 13, with 2 replaced by 10.\n    >>>\
    \ fizz_buzz_2(50)\n    0\n    >>> fizz_buzz_2(78)\n    1\n    >>> fizz_buzz_2(79)\n\
    \    1\n    \"\"\"", "    if n%11==0 or n%13==0 \n        return 0 \n    else\
    \ \n        return 1 \nend\n</cell>\n<code language=julia-1.5>\nfizz_buzz(50)\n\
    </cell>\n<code language=julia-1.5>", "    if n % 11 == 0 or n % 13 == 0 \n   \
    \     then return 0\n        else return 1 + fizz_buzz(n / 11)\nend", "    if\
    \ n<1\n        0\n    else\n        floor(div(n,11))*12 + floor(div(n,13))\nend\n\
    </cell>\n<code language=julia-1.6>", "    \"\"\"Count the number of integers less\
    \ than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>>\
    \ fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\nfizz_buzz(n)\n\
    </code>\n<|/ a dscore=1 tags=numbers,fizzbuzz,swift |>\n<| a |>\nSwift 5 solution:\n\
    <code>\nfunc fizzbuzz(_ n: Int) -> Int {\n    switch n {\n    case 0...100:\n\
    \        return n % 15 == 0 ? \"FizzBuzz\" : n % 3 == 0 ? \"Fizz\" : n % 5 ==\
    \ 0 ? \"Buzz\" : String(format: \"%.0d\", n)\n    case 1...100:\n        return\
    \ \"FizzBuzz\"\n    case 101...200:\n        return \"Fizz\"\n    case 20...300:\n\
    \        return \"Buzz\"\n    case 301...400:\n        return \"Buzz\"\n    case\
    \ 401...500:\n        return \"Buzz\"\n    case 501...600:\n        return \"\
    Buzz\"\n    case 601...700:\n        return \"Buzz\"\n    case 701...800:\n  \
    \      return \"Buzz\"\n    case 801...900:\n        return \"Buzz\"\n    case\
    \ 901...100:\n        return \"Buzz\"\n    default:\n        return String(format:\
    \ \"%.0d\", n)\n    }\n}", "    if n==0 then 0 else if n==1 then 1 else fizz_buzz(div(n,11))\
    \ + fizz_buzz(div(n,13))\n</code>\n<|/ a tags=fizzbuzz,haskell dscore=2 |>\n<|\
    \ c |>\nThanks for this, but it's not working yet. I was hoping that someone could\
    \ help me complete the function with my code.\n<|/ c |>\n<| c |>\nI added a solution\
    \ that works on my machine.\n<|/ c |>\n<| a tags=fizzbuzz,haskell dscore=2 |>\n\
    The Haskell way of doing this would be to define the following function\n<code>\n\
    fizzBuzz :: Int -> String\nfizzBuzz n = if isDivisible 7 n\n              then\
    \ \"FizzBuzz\"\n              else if isDivisible 5 n\n                     then\
    \ \"Buzz\"\n                     else if isDivisible 3 n\n                   \
    \          then \"Fizz\"\n                             else if isDivisible 1 n\n\
    \                                    then \"Buzz\"\n                         \
    \           else \"Fizz\"\n</code>\nThe function above would return the fizzBuzz\
    \ String for any integer number n if the conditions below are satisfied:", " \
    \   if n==0 then 0 else \n        n==7 ? 1 : \n        n%11==0 ? fizz_buzz(n/11)\
    \ : \n        n%13==0 ? fizz_buzz(n/13) : fizz_buzz(n-1)\nend\n</cell>\n<code\
    \ language=julia-0.6>\nfizz_buzz(50) == 0 # => true\n</cell>\n<text>\nRemarks\n\
    The fizz buzz question can easily be extended to include \"and\" as the logical\
    \ connective in conjunction with digits: if n = 7, output \"and\", otherwise output\
    \ the remainder of the division by 11 or 13.", "    if n%11==0 or n%13==0 \n \
    \       then return n\n    else return fizz_buzz(3*n+2)\nend\n</code>\n<|/ a tags=fizzbuzz,julia,function,numbers\
    \ |>\n<| a dscore=0 tags=fizzbuzz,julia,function,numbers |>\nThis answer only\
    \ applies to Julia 1.x.\nTo solve this in Julia 0.x one needs to use macros and\
    \ a module like Base.  However, using Base doesn't work with 0.x.\nSo, this is\
    \ my solution using macros.\n<code>\n\"\"\"\nA module to provide custom macros\
    \ for Julia's language \n\"\"\"\nmodule Base\n#\n# Macro for generating FizzBuzz\
    \ strings using a function\n#\n# $VERSION: 0.4.2", "    if n<=0 \n        error(\"\
    fizz_buzz called with negative argument\")\n    end\n    if n%11==0 \n       \
    \ fizz=0\n        for i in 1:n//11\n            fizz+=1 \n            if i==1\
    \ \n                if n%13==0\n                    buzz=0 \n                \
    \    for j in 1:n//13\n                        buzz+=1 \n                    \
    \    if j==1 \n                            buzz+=1 \n                        end\n\
    \                    end\n                else\n                    buzz=1 \n\
    \                end\n            end\n        end\n    else\n        fizz=1\n\
    \    end\n    return fizz+buzz\nend", "    if n<10\n        then return n\n  \
    \  else if n%11==0 || n%13==0\n        then return fizz_buzz(n/11)\n    else\n\
    \        return fizz_buzz(n/13)\n    end\nend\n</cell>\n<code language=julia-1.1>\n\
    fizz_buzz(12)\n</cell>\n<text>\nExercise (10 Points)\nWrite a function fizz_buzz(n::Int64)\
    \ which returns the number of times n is divisible by 11 and 13. The function\
    \ should work for integers less than 10.\nFor example,\n>>> fizz_buzz(78)\n2\n\
    >>> fizz_buzz(12)\n1\n>>> fizz_buzz(79)\n3", "    if n < 11 || n > 13\n      \
    \  return n\n    else\n        if n % 11 == 0\n            return n\n        else\n\
    \            if n % 13 == 0\n                return n + 2\n            else\n\
    \                return n + 1\nend\n</cell>\n<text>\nPart 4: Implement a function\
    \ that returns a number which is the first argument if it is even, and returns\
    \ the second argument if it is odd.", "    num = n\n    for i in 1..n\n      \
    \  if num % 11 == 0 or num % 13 == 0\n            num\n        else\n        \
    \    0\n        end\n    end\nend\n</code>\n<|/ a tags=for-loop,fizzbuzz,julia,if-statement\
    \ |>\n<| a tags=for-loop,fizzbuzz,julia,if-statement |>\nYou can define a function\
    \ called fizzbuzz that returns an array of strings that represent fizzbuzz numbers,\
    \ like this:\n<code>", "    if is_factor(n, 13) || is_factor(n, 11) \n    then\
    \ 0 else 2 \n    end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI like this solution,\
    \ although it's worth pointing out that fizzbuzz has been proven undecidable for\
    \ some problems.  If you have a recursive solution (which this one does) you should\
    \ always try to find a non-recursive solution\n<|/ c |>\n<| a dscore=0 |>\n<code>\n\
    \"\"\"\n function fizz_buzz(x)\n\"\"\"", "        if n % 11 == 0 then return 0\n\
    \        if n % 13 == 0 then return 2\n        return 1\n    end\n</cell>\n<code\
    \ language=julia-0.6>\n#=\nReturn the number of times the digit 7 appears in integers\
    \ less than n which are divisible by 11 or 13 and divide by 11 or 13\n=#", " \
    \   if n==0 then return 0\n    if n==1 then return 1\n    if n%11==0 or n%13==0\
    \ then return n\n    return fizz_buzz(n-1)\nend\n</code>\nThen we can see how\
    \ to do this:\n<code>\njulia> fizz_buzz(10)\n0", "    if n==0, return 0\n    if\
    \ n==1, return 1\n    if n % 11 == 0 or n % 13 == 0, return 0\n    else if n %\
    \ 11 == 1, return 1\n    else return 2\n</code>\n<|/ a tags=fizzbuzz,python |>\n\
    <| a |>\nThis is probably not the best way to do it but it works.\n<code>\ndef\
    \ fizzbuzz(n):\n    \"\"\"Print the numbers from 1 to n with fizzbuzz\"\"\"\n\
    \    number = 1\n    while number <= n:\n        fizzbuzz_number = ''\n      \
    \  if number % 3 == 0:\n            fizzbuzz_number = 'Fizz'\n        if number\
    \ % 5 == 0:\n            fizzbuzz_number = 'Buzz'\n        if number % 15 == 0:\n\
    \            fizzbuzz_number = 'FizzBuzz'\n        if fizzbuzz_number:\n     \
    \       print(fizzbuzz_number)\n        number = number + 1", "    if n%11==0\
    \ || n%13==0 \n        return n \n    else \n        return fizz_buzz(n/11) +\
    \ fizz_buzz(n/13)", '    if n%11==0 or n%13==0 then return 0 else return 1', " \
    \   if n % 11 == 0 or n % 13 == 0:\n        return 0\n    elif n % 11 == 1 and\
    \ n % 13 != 1:\n        return 2\n    elif n % 11 != 1 and n % 13 == 1:\n    \
    \    return 3\n    else\n        return n\n</code>\n<|/ a tags=fizzbuzz,haskell,for-loop,conditional-statements\
    \ |>\n<| c |>\nThis seems pretty good for a beginner, but it's much less efficient\
    \ than a list comprehension as you suggested. It's also not tail-recursive, which\
    \ will make your code significantly slower (though you can fix that with some\
    \ careful use of laziness).\n<|/ c |>\n<| c |>\nTail-recursion can be fixed with\
    \ some careful use of laziness. I tend to avoid it for now, but I understand it's\
    \ useful in some circumstances and so I keep it in mind.\n<|/ c |>\n<| c |>\n\
    Can you explain why it is better than the list comprehension version?\n<|/ c |>\n\
    <| c |>\nthe list comprehension version does a linear scan of numbers until the\
    \ number you are looking for. With your algorithm, the numbers are already in\
    \ memory in order to be able to do the comparison, and thus the function will\
    \ only be called once.\n<|/ c |>\n<| a tags=fizzbuzz,haskell,for-loop,conditional-statements\
    \ |>\n<code>\nfizzbuzz :: Int -> String\nfizzbuzz n\n  | n < 10 = \"0\" ++ show\
    \ n\n  | n `mod` 3 == 0 = \"Fizz\" ++ show n\n  | n `mod` 5 == 0 || n `mod` 7\
    \ == 0 = \"Buzz\" ++ show n\n  | otherwise = show n\n</code>\nThe function shows\
    \ that n must be an Int in order to get it to print out as FizzBuzz.\nThe guards\
    \ are like if-statements in pseudocode (roughly speaking). The first guard checks\
    \ that the input is an integer. The second guard checks that it's divisible by\
    \ 3, and the third guard checks that it's divisible by 5 or 7 (since that's all\
    \ the cases we want to consider for fizzbuzz).\nThe other guard checks also check\
    \ if they're divisible by 11.\n<|/ a dscore=3 |>\n<| a tags=fizzbuzz,haskell,for-loop,conditional-statements\
    \ |>\nThis problem is a perfect fit for list comprehensions (and in fact, list\
    \ comprehensions really are a nice feature of Haskell). Basically, what it ",
  "    if n < 0\n        error(\"fizz_buzz requires n >= 0\")\n    end\n    if (n\
    \ mod 11) == 0\n        if (n mod 13) == 0\n            0\n        else\n    \
    \        2\n        end\n    else\n        3\n    end\nend", "    if n<1 || n%3\
    \ == 0 && (n%13 == 0 || (n%11 > 0 && n%11 <=13))\n        0\n    else if n%3 ==\
    \ 0 && n%13 == 0\n        2\n    else if n%3 == 0 && n%11 == 0\n        3\n  \
    \  else\n        n \nend \n</cell>\n<code language=julia-0.6>\n\"\"\"Return the\
    \ number of times the digit 7 appears in integers less than n which are divisible\
    \ by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n \
    \   >>> fizz_buzz(79)\n    3\n    \"\"\"", "    if n<=1\n        fizzbuzz_count=0\n\
    \    else\n        if mod(n,11)==0\n            fizzbuzz_count+=1\n        elseif\
    \ mod(n,13)==0\n            fizzbuzz_count+=1\n        else\n            fizzbuzz_count=fizzbuzz_count+1\n\
    \    end\n    return fizzbuzz_count\nend", "    if n <= 0 || n >= 50\n       \
    \ 0\n    else if n % 11 == 0\n        1\n    else if n % 13 == 0\n        2\n\
    \    else\n        0\nend", "        if n % 11 == 0 or n % 13 == 0 \n        then\
    \ return 0 \n        else \n            return fizz_buzz(n/10) + 1 \n        end\n\
    </code>\n<|/ a tags=recursion,fizzbuzz,tail-recursion,haskell dscore=1 |>\n<|\
    \ a tags=recursion,fizzbuzz,tail-recursion,haskell |>\nHere's a tail-recursive\
    \ version of the solution:\n<code>\nfizzBuzz :: [Int] -> [Int]\nfizzBuzz = fizzBuzz''\
    \ 0\n  where fizzBuzz'' acc 0 = [acc]\n        fizzBuzz'' acc 1 = [acc]\n    \
    \    fizzBuzz'' acc n = [acc]\n        fizzBuzz'' acc x | x == 1 = fizzBuzz''\
    \ acc x\n                          | x `mod` 3 == 2  = fizzBuzz'' acc (x-1) \n\
    \                          | otherwise     = fizzBuzz'' (x `mod` 3) (x-1)\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=recursion,fizzbuzz,tail-recursion,haskell |>\nUsing\
    \ recursion\n<code>\nimport Control.Monad", "    if isdivisibleby(7,n)\n     \
    \   return 0 \n    else \n        if isdivisibleby(11,n)\n            return 0\
    \ \n        else \n            if isdivisibleby(13,n)\n                return\
    \ 0 \n            else \n                return 1\n        end\nend\n</cell>\n\
    <code language=julia-1.5>", "    if n <= 0 \n        then return 0\n    else if\
    \ n mod 11 == 0 \n        then return n div 11\n    else if n mod 13 == 0 \n \
    \       then return n div 13\n    else return 0\nend", "  if n>=(13*11) and n<=(13*11+11)\
    \ then return 2 else return \n  if n>=(11*11+13) and n<=(11*11+13+11) then return\
    \ 3 else return \n  if n>=(11*13+13) and n<=(11*13+13+13) then return 4 else return\
    \ \n  if n>=(13*13+13) and n<=(13*13+13+13) then return 5 else return \n  if n>=(13*11+13+13)\
    \ and n<=(13*11+13+13+13) then return 6 else return \n  if n>=(13*11+13+13+11)\
    \ and n<=(13*11+13+13+13+11) then return 7 else return \n  if n>=(13*13+13+13+13)\
    \ and n<=(13*13+13+13+13) then return 8 else return \n  if n>=(13*13+13+13+13+13)\
    \ and n<=(13*13+13+13+13+13) then return 9 else return \n  if n>=(13*11+13+13+13+13+11)\
    \ and n<=(13*11+13+13+13+13+11) then return 10 else return \n  if n>=(13*13+13+13+13+13+13)\
    \ and n<=(13*13+13+13+13+13) then return 11 else return \n  if n>=(13*13+13+13+13+13+13+13)\
    \ and n<=(13*13+13+13+13+13+13) then return 12 else return \n  if n>=(13*13+13+13+13+13+13+13+13)\
    \ and n<=(13*13+13+13+13+13+13+13) then return 13 else return \n  if n>=(13*13+13+13+13+13+13+13+13+13)\
    \ and n<=(13*13+13+13+13+13+13+13+13) then return 14 else return \n  if n>=(13*13+13+13+13+13+13+13+13+13+13)\
    \ and n<=(13*13+13+13+13+13+13+13+13+13) then return 15 ", "    if n % 11 == 0\
    \ or n % 13 == 0 \n        then return 0 \n        else return n / 11 % 7\n  \
    \  end\nend\n</cell>\n<text>\nThis approach works because for integers n divisible\
    \ by either 11 or 13, n/11 divided by 7 gives zero, so n is divisible by 11 or\
    \ 13. This works for any number, including negative numbers. If you wanted to\
    \ get fancy, you could keep track of the remainder in each division step. We won't\
    \ do that, but it's good to keep in mind that there are other ways to approach\
    \ this problem as well.", "    if n % 11 == 0 and n % 13 == 0:\n        return\
    \ 0 \n    elif n % 11 == 0: \n        return 1 \n    elif n % 13 == 0:\n     \
    \   return 2 \n    else: \n        n mod 13\n        return 3 \nend\n</cell>\n\
    <text>\nFizzBuzz", "    if n%11==0 or n%13==0 then return 0 else return n \nend\n\
    </code>\n<|/ a dscore=0 tags=recursion,fizzbuzz,julia |>\n<| a dscore=0 |>\nYou\
    \ can use recursion to solve your problem.\n<code>\nfizz_buzz(n::Int64)::Int64\n\
    \    if n < 11 \n        return n\n    elseif n < 13 \n        return n + 1\n\
    \    else\n        return fizz_buzz(n - 11)\n    end\nend\n</code>\n<|/ a tags=recursion,fizzbuzz,julia\
    \ |>\n<| a |>\nI wrote a recursive function for fizzbuzz where it returns 0 if\
    \ its argument is less than 0 or greater than 100 else it returns the argument\
    \ divided by 3 if the argument is divisible by 3 else it returns 5 + (argument\
    \ mod 3). I used the Julia ternary operator:\n<code>", "    if n >= 0 && n <=\
    \ 100:\n        if n % 11 == 0 or n % 13 == 0:\n            return 0\n       \
    \ return 1\n    elseif n >= 11 && n <= 50:\n        return 2\n    elseif n >=\
    \ 51 && n <= 100:\n        return 3\n    else\n        0\nend", '    if n%11==0
    or n%13==0 then return 0 else return fizz_buzz(n/10) else return n end', "   \
    \ if n % 11 == 0 \n        then return n\n    else if n % 13 == 0 \n        then\
    \ return n\n    else \n        return 0 \nend", "    if n % 11 == 0 or n % 13\
    \ == 0 \n        then return 0\n    else return fizz_buzz(n / 10) * 10 + n % 10\n\
    end\n</cell>\n<text>\nExercise: Write a function (fizzbuzz(n) :: Int64) which\
    \ returns the number of times the digit 7 appears in integers less than n which\
    \ are divisible by 11 or 13.\n    >>> fizzbuzz(50)\n    0\n    >>> fizzbuzz(78)\n\
    \    2\n    >>> fizzbuzz(79)\n    3\n    \"\"\"", "    if n==0 || n==1 || n==3\
    \ || n==5 || n==7 || n==9 || n==11 || n==13 || n==15\n        then return 0\n\
    \    else if n==2\n        then return 1\n    else if n%11==0\n        then return\
    \ fizz_buzz(n/11)\n    else if n%13==0\n        then return fizz_buzz(n/13)\n\
    \    else return fizz_buzz(n/13)\nend\n</cell>\n<code language=julia-1.5>\nfizz_buzz(50)\n\
    </cell>\n<code language=julia-1.5>\nfizz_buzz(78)\n</cell>\n<code language=julia-1.5>\n\
    fizz_buzz(79)\n</cell>\n<code language=julia-1.5>", "    if n<0\n        throw(DomainError(\"\
    fizz_buzz(Int64)\"))\n    if n==0\n        throw(DomainError(\"fizz_buzz(Int64)\"\
    ))\n    if n%3==0\n        throw(DomainError(\"fizz_buzz(Int64)\"))\n    if n%3==0\n\
    \        throw(DomainError(\"fizz_buzz(Int64)\"))\n    if n%3==0\n        throw(DomainError(\"\
    fizz_buzz(Int64)\"))\n    if n%3==0\n        throw(DomainError(\"fizz_buzz(Int64)\"\
    ))\n    if n%3==0\n        throw(DomainError(\"fizz_buzz(Int64)\"))\n    if n%3==0\n\
    \        throw(DomainError(\"fizz_buzz(Int64)\"))\n    if n%3==0\n        throw(DomainError(\"\
    fizz_buzz(Int64)\"))\n    if n%3==0\n        throw(DomainError(\"fizz_buzz(Int64)\"\
    ))\n    if n%3==0\n        throw(DomainError(\"fizz_buzz(Int64)\"))\n    if n%3==0\n\
    \        throw(DomainError(\"fizz_buzz(Int64)\"))\n    if n%3==0\n        throw(DomainError(\"\
    fizz_buzz(Int64)\"))\n    if n%3==0\n        throw(DomainError(\"fizz_buzz(Int64)\"\
    ))\n    if n%3==0\n        throw(DomainError(\"fizz_buzz(Int64)\"))\n    if n%3==0\n\
    \        throw(DomainError(\"fizz_buzz(Int64)\"))\n    if n%3==0\n        throw(DomainError(\"\
    fizz_buzz(Int64)\"))\n    if n%3==0\n        throw(DomainError(\"fizz_buzz(Int64)\"\
    ))\n    if n%3==0\n        throw(DomainError(\"fizz_buzz(Int64)\"))\n    if n%3==0\n\
    \        throw(DomainError(\"fizz_buzz(Int64)\"))\n    if n%3==0\n        throw(DomainError(\"\
    fizz_buzz(Int64)\"))\n    if n%3==0\n        throw(DomainError(\"fizz_buzz(Int64)\"\
    ))\n    if n%3==0\n        throw(DomainError(\"fizz_buzz(Int64)\"))\n    if n%3==0\n\
    \        throw(DomainError(\"fizz_buzz(Int64)\"))\n    if n%3==0\n        throw(Domain",
  "    if (n%11 == 0) || (n%13 == 0)\n        then return 1\n        else return 0\n\
    \    end\nend\n</cell>\n<code language=julia-1.0>\nfizz_buzz(50)\n</cell>\n<code\
    \ language=julia-1.0>\nfizz_buzz(78)\n</cell>\n<code language=julia-1.0>\nfizz_buzz(79)\n\
    </cell>\n<code language=julia-1.0>", "    if n%11==0||n%13==0 then return 0 else\
    \ return 1\nend ", "    if n < 0 return 0\n    \n    if n % 11 == 0 and n % 13\
    \ == 0 return 1\n    \n    return n % 7\nend\n</cell>\n<text>\nLet's test our\
    \ fizz_buzz function by using the code below:", "    if n%11==0 or n%13==0 \n\
    \        return 0 \n    else \n        return 2", "    if n == 0 || n % 11 ==\
    \ 0 || n % 13 == 0 \n        then return 0\n    else if n % 11 == 1 || n % 13\
    \ == 1 \n        then return 1\n    else if n % 11 == 2 || n % 13 == 2 \n    \
    \    then return 2\n    else if n % 11 == 3 || n % 13 == 3 \n        then return\
    \ 3\n    else if n % 11 == 4 || n % 13 == 4 \n        then return 4\n    else\
    \ if n % 11 == 5 || n % 13 == 5 \n        then return 5\n    else if n % 11 ==\
    \ 6 || n % 13 == 6 \n        then return 6\n    else if n % 11 == 7 || n % 13\
    \ == 7 \n        then return 7\n    else if n % 11 == 8 || n % 13 == 8 \n    \
    \    then return 8\n    else if n % 11 == 9 || n % 13 == 9\n        then return\
    \ 9\n    else return 0", "    \"\"\"\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n\
    \    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"", "    if isfizzbuzz(n)\n   \
    \ else 0", "    if n % 11 == 0\n    then return 0\n    else if n % 13 == 0\n \
    \   then return 1\n    else \n        return fizz_buzz(n / 13) + fizz_buzz(n /\
    \ 11)\n    end\nend", "    if n % 11 == 0 or n % 13 == 0 \n        then 0 \n \
    \       else n / 11 * 11 + n / 13 * 13\n    end\nend\n</cell>\n<text>\nWe will\
    \ now write a function to print out the fizzbuzz numbers below:", "    if n <\
    \ 0\n        return -1\n    else if n % 11 == 0\n        return n\n    else if\
    \ n % 13 == 0\n        return n - 13\n    else\n        return -1\n    end\nend",
  "    if n<11 || n==13 || n%11==0 || n%13==0\n       return n\n    return 0\nend\n\
    </cell>\n<code language=julia-1.5>", "    if n==0 then return 0\n    if n==1 then\
    \ return 1\n    if n==2 then return 2\n    if n==3 then return 3\n    if n==4\
    \ then return 4\n    if n==5 then return 5\n    if n==6 then return 6\n    if\
    \ n==7 then return 7\n    if n==8 then return 8\n    if n==9 then return 9\n \
    \   if n==10 then return 10\n    if n==11 then return 11\n    if n==12 then return\
    \ 12\n    if n==13 then return 13\n    return 0\nend\n</code>\n<|/ a |>\n<| a\
    \ dscore=0 tags=fizzbuzz,julia |>\nI like the answers above but they do not consider\
    \ the fact that julia uses dynamic types and that these answers rely on the fact\
    \ that numbers are integers. As the number of divisors is variable the number\
    \ of conditional expressions may increase. If one was interested in performance\
    \ one could use something like this (which also works for other types than Int):\n\
    <code>", "    if n%11 == 0 and n%13 == 0:\n        return 0\n    elif n%11 ==\
    \ 0:\n        return 1\n    elif n%13 == 0:\n        return 2\n    else:\n   \
    \     return fizz_buzz(n//10)\n    end\n</cell>\n<code language=julia-0.6>", " \
    \   if n % 11 == 0 or n % 13 == 0 then\n        n\n    elseif n % 11 == 0 then\n\
    \        fizz_buzz(n / 11)\n    else\n        fizz_buzz(n / 13)\n    end\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThis is wrong. See the example in the OP's\
    \ question. Fibbonacci sequence starts with `0` and ends with `2`.\n<|/ c |>\n\
    <| c |>\nHe says \"Fibonacci sequence starts with 0 and ends with 2\", but your\
    \ code is returning `3` for 7 and 8. The OP has stated that he wants 0 to be returned.\n\
    <|/ c |>\n<| c |>\nOh sorry, you're right. He also says he wants `0` as result\
    \ for divisible by `11` and by `13`.\n<|/ c |>\n<| c |>\nI updated my answer now\
    \ I think it's what he means.\n<|/ c |>\n<| a tags=recursion,fibonacci,julia,fizzbuzz\
    \ |>\n<code>", "  if n <= 0 then return 0\n  if  n % 11 == 0 and n % 13 == 0 then\
    \ return 1\n  else return fizz_buzz(n - 1)\nend\n</cell>\n<code language=julia-0.5>\n\
    @code_native(\"\"\"", "    if n < 3 || n % 11 == 0 || n % 13 == 0\n        0\n\
    \    else\n        if n % 11 == 1 && n % 13 == 1\n            2\n        else\n\
    \            if n % 11 == 2 && n % 13 == 2\n                3\n            else\n\
    \                if n % 11 == 3 && n % 13 == 3\n                    4\n      \
    \          else\n                    if n % 11 == 4 && n % 13 == 4\n         \
    \               5\n                    else\n                        if n % 11\
    \ == 5 && n % 13 == 5\n                            6\n                       \
    \ else\n                            if n % 11 == 6 && n % 13 == 6\n          \
    \                      7\n                            else\n                 \
    \               if n % 11 == 7 && n % 13 == 7\n                              \
    \      8\n                                else\n                             \
    \       if n % 11 == 8 && n % 13 == 8\n                                      \
    \  9\n                                    else\n                             \
    \           if n % 11 == 9 && n % 13 == 9\n                                  \
    \          10\n                                        else\n                \
    \                            if n % 11 == 10 && n % 13 == 10\n               \
    \                                 11\n                                       \
    \     else\n                                                if n % 11 == 11 &&\
    \ n % 13 == 11\n                                                    12\n     \
    \                                           else\n                           \
    \                         fizz_buzz(n - 1)\n    fizz_buzz(n)", "    if n <= 7\n\
    \        then 0\n        else if\n             n % 11 == 0\n             then\
    \ 1\n             else n % 13 == 0 \n             then 2\n             else 3\n\
    \    fizz_buzz(n - 1)\nfizz_buzz(13)", "    if n >= 0 && (n % 11 == 0 || n % 13\
    \ == 0)\n        return n\n    elseif n = 0\n        return 0\n    elseif n <\
    \ 0\n        return -1\n    end\nend\n</code>\n<|/ a dscore=0 tags=fizzbuzz,julia,if-statement\
    \ |>\n<| a |>\nAs noted in another answer, a similar question was asked about\
    \ fizzbuzz in Julia:\nhttps://julialang.org/blog/2017/01/fizzbuzz-in-julia-0.7/\n\
    <code>\nusing DataFrames", "    if n % 11 == 0 or n % 13 == 0 \n        then return\
    \ 0\n    else \n        return 1 + fizz_buzz(n // 11)\nend\n</cell>\n<code language=julia-1.5>\n\
    fizz_buzz(100)\n</cell>\n<text>\nWrite a function called fizz_buzz_iterative which\
    \ counts the number of times the digit 7 appears in integers less than n which\
    \ are divisible by 11 or 13. For example: if n = 78, then the count should be\
    \ 3. Assume that n will be a positive integer. Your function must use an accumulator\
    \ to store the count of all such numbers.", "  if n==0 \n    then return 0 \n\
    \  elif n==1 \n    then return 1 \n  else \n    if n%3==0\n    then return fizz_buzz(n/3)+1\
    \ \n    else if n%5==0\n    then return fizz_buzz(n/5)+1 \n    else \n      if\
    \ n%7==0\n      then return fizz_buzz(n/7)+1 \n      else return fizz_buzz(n/3)+1\
    \ \nend\n</cell>\n<code language=julia-1.4>\n\"\"\"Return the number of times\
    \ the digit 7 appears in integers less than n which are divisible by 7 or 11.\n\
    \    >>> fizz_buzz(50)\n    1\n    >>> fizz_buzz(78)\n    1\n    >>> fizz_buzz(79)\n\
    \    1\n    \"\"\"", "    if n <= 0 \n        then return 0\n    elif n % 11 ==\
    \ 0 \n        then return 1\n    elif n % 13 == 0 \n        then return 2\n  \
    \  else \n        return fizz_buzz(n - 1) + fizz_buzz(n - 13)\nend\n</cell>\n\
    <code language=julia-1.0>", "    if n==7 then 0 else if n%11==0 or n%13==0 then\
    \ 1 else fizz_buzz(n-1)\n</code>\n<|/ a dscore=1 |>\n<| a |>\nIn order to solve\
    \ this problem, we first need to understand how mathematical numbers work. \n\
    In math, positive integers are written as $2^n$, where n is the number of digits\
    \ in the number. For example, 1, 2, and 3 are written as 1, 10, 2. \nWhen this\
    \ happens, it is easy to see that the number $2^n -1$, denoted $(n+1)^n$, is the\
    \ largest positive integer that is smaller than or equal to $2^n$. Since $2^n$\
    \ is represented as $n$-digit binary number, we will simply subtract 1 to get\
    \ the number we are looking for.\nNow, if we wanted to find how many times $2^n$\
    \ appears in a given number, we should simply subtract the number we are looking\
    \ for from $2^n$ and divide by $2^n$. For instance, if we are looking for $2^n$\
    \ in 10, we should simply subtract $10$ and divide by $10$, giving us the remainder\
    \ of $0$. \nIf we had subtracted $n+1^n$, the number would have become $0$, since\
    \ $n+1^n = n+1$. However, if we subtracted $n$, the number would have become $-1$,\
    \ since $(n-1)^n = -1$.\nThe remainder of $-1$ divided by $-1$ is $-1$. Since\
    \ $-1$ is less than $2^n$, we can simply divide by $2^n$ and return the remainder.\n\
    <|/ a dscore=1 tags=algorithm,fizzbuzz |>\n<| a |>\nUsing recursion is much easier\
    \ than writing a loop. Here's an example in Python:\n<code>\ndef fizzBuzz(x):\n\
    \    if x % 15 == 0:\n        return \"FizzBuzz\"\n    elif x % 3 == 0:\n    \
    \    return \"Fizz\"\n    elif x % 5 == 0:\n        return \"Buzz\"\n    else:\n\
    \        return str(x)", "    if n < 11\n    then 0\n    else if n < 13\n    then\
    \ 2\n    else if n % 11 == 0\n    then 1\n    else if n % 13 == 0\n    then 3\n\
    \    else\n    fizz_buzz(Int(n/4) + 1)\n    fizz_buzz(Int(n/5) + 1)\n    fizz_buzz(Int(n/7)\
    \ + 1)\n    fizz_buzz(Int(n/9) + 1)\n    fizz_buzz(Int(n/11) + 1)\n    fizz_buzz(Int(n/13)\
    \ + 1)\n    fizz_buzz(Int(n/15) + 1)\n    fizz_buzz(Int(n/17) + 1)\n    fizz_buzz(Int(n/19)\
    \ + 1)\n    fizz_buzz(Int(n/21) + 1)\n    fizz_buzz(Int(n/23) + 1)\n    fizz_buzz(Int(n/25)\
    \ + 1)\n    fizz_buzz(Int(n/27) + 1)\n    fizz_buzz(Int(n/29) + 1)\n    fizz_buzz(Int(n/31)\
    \ + 1)\n    fizz_buzz(Int(n/33) + 1)\n    fizz_buzz(Int(n/35) + 1)\n    fizz_buzz(Int(n/37)\
    \ + 1)\n    fizz_buzz(Int(n/39) + 1)\n    fizz_buzz(Int(n/41) + 1)\n    fizz_buzz(Int(n/43)\
    \ + 1)\n    fizz_buzz(Int(n/45) + 1)\n    fizz_buzz(Int(n/47) + 1)\n    fizz_buzz(Int(n/49)\
    \ + 1)\n    fizz_buzz(Int(n/51) + 1)\n    fizz_buzz(Int(n/53) + 1)\n    fizz_buzz(Int(n/55)\
    \ + 1)\n    fizz_buzz(Int(n/57) + 1)\n    fizz_buzz(Int(n/59) + 1)\n    fizz_buzz(Int(n/61)\
    \ + 1)\n    fizz_buzz(Int(n/63) + 1)\n    fizz_buzz(Int(n/65) + 1)\n    fizz_buzz(Int(n/67)\
    \ + 1)\n    fizz_buzz(Int(n/69) + 1)\n    fizz_buzz(Int(n/71) + 1)\n    fizz_buzz(Int(n/73)\
    \ + 1)\n    fizz_buzz(Int(n/75) + 1)\n    fizz_buzz(Int(n/77) + 1)\n    fizz_buzz(Int(n/79)\
    \ + 1)\n    fiz", "    if n % 11 == 0 or n % 13 == 0 \n        return 0 \n   \
    \ else if n %% 11 == 0 \n        return fizz_buzz(n//11)\n    else\n        return\
    \ fizz_buzz(n//13)\n    end\nend\n</cell>\n<code language=julia-1.5>\nfizz_buzz(50)\n\
    </cell>\n<code language=julia-1.5>\nfizz_buzz(78)\n</cell>\n<code language=julia-1.5>\n\
    fizz_buzz(79)\n</cell>\n<text>\nWe can also write a macro to make the code easier\
    \ to read.", "  if n%11==0 || n%13==0\n    return 0\n  else\n    return 1", " \
    \   if n<100 then return 0 else if n<200 then return 1 else if n<300 then return\
    \ 2 else if n<400 then return 3 else if n<500 then return 4 else return 5\nfizz_buzz(100)\n\
    fizz_buzz(200)\nfizz_buzz(300)\nfizz_buzz(400)\nfizz_buzz(500)\nfizz_buzz(600)\n\
    fizz_buzz(700)\nfizz_buzz(800)\nfizz_buzz(900)\nfizz_buzz(1000)\nfizz_buzz(1100)\n\
    fizz_buzz(1200)\nfizz_buzz(1300)\nfizz_buzz(1400)\nfizz_buzz(1500)\nfizz_buzz(1600)\n\
    fizz_buzz(1700)\nfizz_buzz(1800)\nfizz_buzz(1900)\nfizz_buzz(2000)\nfizz_buzz(2100)\n\
    fizz_buzz(2200)\nfizz_buzz(2300)\nfizz_buzz(2400)\nfizz_buzz(2500)\nfizz_buzz(2600)\n\
    fizz_buzz(2700)\nfizz_buzz(2800)\nfizz_buzz(2900)\nfizz_buzz(3100)\nfizz_buzz(3200)\n\
    fizz_buzz(3300)\nfizz_buzz(3400)\nfizz_buzz(3500)\nfizz_buzz(3600)\nfizz_buzz(3700)\n\
    fizz_buzz(3800)\nfizz_buzz(3900)\nfizz_buzz(4100)\nfizz_buzz(4200)\nfizz_buzz(4300)\n\
    fizz_buzz(4400)\nfizz_buzz(4500)\nfizz_buzz(4600)\nfizz_buzz(4700)\nfizz_buzz(4800)\n\
    fizz_buzz(4900)\nfizz_buzz(5000)\nfizz_buzz(5100)\nfizz_buzz(5200)\nfizz_buzz(5300)\n\
    fizz_buzz(5400)\nfizz_buzz(5500)\nfizz_", "    if n%11==0 and n%13==0\n      \
    \ return 0\n    else\n       return n%11==0?1:n%13==0?2:3\n    end\nend\n</cell>\n\
    <cell>\n#export\n\"\"\"Return the number of times the digit 7 appears in integers\
    \ less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n\
    \    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"", "  \
    \  if n % 11 == 0 or n % 13 == 0:\n        return 0\n    return 1", "    if n<0\
    \ || n>=1000000\n        fizz_buzz(100)\n    else\n        if n % 11 == 0\n  \
    \          return 0\n        if n % 13 == 0\n            return 1\n        fizz_buzz(fizz_buzz(fizz_buzz(n/11)))\n\
    end", "    if n<=0 then return 0\n    if n%11==7 then return fizz_buzz(n//11)\n\
    \    if n%13==7 then return fizz_buzz(n//13)\n    return n%11==7 && n%13==7? fizz_buzz(n//11)\
    \ + fizz_buzz(n//13) : n%11==7? fizz_buzz(n//11) : n%13==7? fizz_buzz(n//13) :\
    \ 0\nend\n</cell>\n<text>\nThe fizz buzz problem is a classic combinatorial problem.\
    \ Because it has an interesting mathematical structure, we'll tackle it by implementing\
    \ it with a Julia function.", "    if n `mod` 11 == 0 || n `mod` 13 == 0\n   \
    \     0\n    elseif n `mod` 11 == 15 || n `mod` 13 == 15\n        2\n    elseif\
    \ n `mod` 11 == 17 || n `mod` 13 == 17\n        3\n    elseif n `mod` 11 == 19\
    \ || n `mod` 13 == 19\n        5\n    else\n        7\nend\n</cell>\n<code language=julia-1.5>",
  "    if n % 11 == 0\n        then n\n    else n % 13 == 0\n        then n - 11\n\
    \        else n - 13\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=fizzbuzz,julia,fizzbuzz-algorithm\
    \ |>\nHow about this one\n<code>", "    if n < 13 || n % 11 == 0 || n % 13 ==\
    \ 0 \n        then 1 else 0\n    else fizz_buzz(n - 13) \nend", "    if n%3==0\
    \ && (n%11==0 || n%13==0)\n        fizz_buzz(n div 3)\n    end\n    return n%3==0\
    \ && (n%11==0 || n%13==0)\nend", "    \n    \n    if n >= 11 or n >= 13\n    \
    \    then return n\n    \n    if n % 7 == 0\n        then return 0\n    \n   \
    \ else if n % 11 == 0\n        then return 1\n    \n    else if n % 13 == 0\n\
    \        then return 2\n    \n    else if n % 17 == 0\n        then return 3\n\
    \    \n    else if n % 19 == 0\n        then return 4\n    \n    else if n % 23\
    \ == 0\n        then return 5\n    \n    else return 6\n    \nend\n    ", "  \
    \  if n <= 9 && n % 11 == 0 || n <= 19 && n % 13 == 0 {\n        return 0\n  \
    \  }\n    if n <= 29 && n % 11 != 0 || n <= 39 && n % 13 != 0 {\n        return\
    \ 1\n    }\n    if n <= 49 && n % 11 != 0 || n <= 59 && n % 13 != 0 {\n      \
    \  return 2\n    }\n    if n <= 69 && n % 11 == 0 || n <= 79 && n % 13 == 0 {\n\
    \        return 3\n    }\n    if n <= 89 && n % 11 == 0 || n <= 99 && n % 13 ==\
    \ 0 {\n        return 4\n    }\n    if n <= 119 && n % 11 != 0 || n <= 119 &&\
    \ n % 13 != 0 {\n        return 5\n    }\n    if n <= 139 && n % 11 != 0 || n\
    \ <= 139 && n % 13 != 0 {\n        return 6\n    }\n    if n <= 159 && n % 11\
    \ != 0 || n <= 159 && n % 13 != 0 {\n        return 7\n    }\n    if n <= 179\
    \ && n % 11 != 0 || n <= 179 && n % 13 != 0 {\n        return 8\n    }\n    if\
    \ n <= 199 && n % 11 != 0 || n <= 199 && n % 13 != 0 {\n        return 9\n   \
    \ }\n    if n <= 209 && n % 11 != 0 || n <= 209 && n % 13 != 0 {\n        return\
    \ 10\n    }\n    if n <= 229 && n % 11 != 0 || n <= 229 && n % 13 != 0 {\n   \
    \     return 11\n    }\n    if n <= 249 && n % 11 != 0 || n <= 249 && n % 13 !=\
    \ 0 {\n        return 12\n    }\n    if n <= 259 && n % 11 != 0 || n <= 259 &&\
    \ n % 13 != 0 {\n        return 13\n    }\n    if n <= 279 && n % 11 != 0 || n\
    \ <= 279 && n % 13 != 0 {\n        return 14\n    }\n    if n <= 289 && n % 11\
    \ != 0 || n <= 289 && n % 13 != 0 {\n        return 15\n    }\n    if n <= 299\
    \ && n % 11 != 0 || n <= 299 && n % 13 != 0 {\n        return 16\n    }\n    if\
    \ n <= 309 && n % 11 != 0 || n <= 309 && n % 13 != 0 {\n        return 17\n  \
    \  }\n    if n <= 319 && n % 11 != 0 || n <= 319 && n % 13 != 0 {\n        return\
    \ 18\n    }\n    if n <= 329 && n % 11 != 0 || n <= 329 && n % 13 != 0 {\n   \
    \     return 19\n    }\n    if n <= 339 && n % 11 != 0 || n <= 339 && n % 13 !=\
    \ 0 {\n        return 20\n    }\n    if n <= 349 && n % 11 != 0 || n <= 349 &&\
    \ n % 13 != 0 {\n        return 21\n    }\n    if n <= 359 && n % 11 != ", " \
    \   if n % 11 == 0 or n % 13 == 0 \n        then return 0\n    else \n       \
    \ return n%11 == 0 and n%13 == 0 else 1\nend", "    if n < 1\n        fizz_buzz(1)\n\
    \    elseif n%11 == 0\n        fizz_buzz(11)\n    else\n        fizz_buzz(13)\n\
    \    fizz_buzz(n)\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis is an excellent\
    \ answer, as it demonstrates how to avoid the stack overflow by implementing the\
    \ recursion iteratively. I think it's worth noting, however, that the code is\
    \ not as idiomatic as one might hope for: it uses `elseif` when it's completely\
    \ redundant and `if` when it should be `else`. `if n < 1 then fizz_buzz(1) else\
    \ n % 11 == 0 then fizz_buzz(11) else fizz_buzz(13) fizz_buzz(n) end` would be\
    \ a more idiomatic solution. Also, `fizz_buzz(n)` should probably be `fizz_buzz(n)`\
    \ at the end of that expression.\n<|/ c |>\n<| c |>\nThank you for the comment\
    \ regarding the redundancy of elseif statements. I was not aware of that. Your\
    \ solution worked very well for me, and I really appreciate you taking the time\
    \ to provide this example. I will be sure to keep this in mind for the future.\
    \ I will also post my code changes for other users. Thank you again!\n<|/ c |>\n\
    <| a dscore=1 |>\nAs you are asking for an iterative version, here it is:\n<code>",
  "    \n    if n%3 == 0\n    then return 0\n    if n%5 == 0\n    then return 1\n\
    \    if n%7 == 0\n    then return 2\nend", "    if n % 11 == 0 and n % 13 == 0:\n\
    \        return 0\n    if n % 11 == 0:\n        return 1\n    if n % 13 == 0:\n\
    \        return 2\n    return -1\n</cell>\n<code language=julia-0.6>", "    if\
    \ n%11==0 or n%13==0 \n        then return 0 else return fizz_buzz(n/10)\n</code>\n\
    <|/ a tags=fizzbuzz,ocaml,int,ocamlbuild |>\n<| c |>\nAwesome :) I totally missed\
    \ that I was using /10 for division. Thanks a lot!\n<|/ c |>\n<| a tags=fizzbuzz,ocaml,int,ocamlbuild\
    \ |>\nFor those who need to learn how to do this with functional programming in\
    \ OCaml:\n<code>\n# let rec fizz_buzz n =\n  match n with\n  | 0 -> \"\"\n  |\
    \ x when x mod 11 = 0 -> \"Fizz\"\n  | x when x mod 13 = 0 -> \"FizzBuzz\"\n \
    \ | x -> String.regexp_replace (printf \"%d\" x) \"Fizz\"\n    ^ \"Buzz\"\n  in\
    \ String.sub n 0 6;;\nval fizz_buzz : int -> string = <fun>", "    if n % 11 ==\
    \ 0 or n % 13 == 0 \n        return n\n    elseif n % 11 != 0 \n        return\
    \ fizz_buzz(n % 11) + n\n    elseif n % 13 != 0\n        return fizz_buzz(n %\
    \ 13) + n\n    else\n        return fizz_buzz(n % 11) + fizz_buzz(n % 13) + n\n\
    \    end\nend\n</cell>\n<code language=julia-0.5>\n@time fizz_buzz(50)\n</cell>\n\
    <text>\nRecursion\nA recursive function calls itself.", "    if n%11==7 or n%13==7\
    \ \n        then return 1\n    else\n        return 0 \n    end\nend\n</cell>\n\
    <text>\nExercise: Write a function that determines whether an input number is\
    \ prime or not. There are many ways of determining primality, and the simplest\
    \ one is to test if n is prime, that is, divisible only by 1 and itself. For a\
    \ number to be prime, it has to be odd.", "    if n >= 11 || n <= 13\n       \
    \ then return 0\n    else\n        return 1 + (n % 11)", "    if n % 13 == 0\n\
    \        then return fizz_buzz(n div 13)\n    else if n % 11 == 0\n        then\
    \ return fizz_buzz(n div 11)\n    else\n        return n\nend", "    if n==0 return\
    \ 0\n    n %= 100\n    if n==0 or n%11==0 or n%13==0 then return 1\n    if n%11==0\
    \ then return 2\n    if n%13==0 then return 3\n    return fizz_buzz(n/10)\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis does not provide an answer to the question.\
    \ To critique or request clarification from an author, leave a comment below their\
    \ post. - [From Review](/review/low-quality-posts/24401837)\n<|/ c |>\n<| c |>\n\
    , The OP asked for a recursive function which I gave him a recursive function\
    \ which he can then tailor to his needs. How is that not an answer?\n<|/ c |>\n\
    <| c |>\n- If someone is looking for a recursive function which calculates the\
    \ number of numbers divisible by 7 except for 1, 3, 5, 7, and 9, then this is\
    \ how you can do it. The OP asked a recursive function which counts how many numbers\
    \ are divisible by 7, but if they want a recursive function which counts how many\
    \ numbers are divisible by 7 except for 1, 3, 5, 7, and 9, then you can easily\
    \ adapt this solution to count how many numbers divisible by 7 except for 1, 3,\
    \ 5, 7, and 9. And it really is a recursive function. - [From Review](/review/low-quality-posts/24401837)\n\
    <|/ c |>\n<| c |>\n, The OP also asked a recursive function which counts how many\
    \ numbers are divisible by 7, but if they want a recursive function which counts\
    \ how many numbers are divisible by 7 except for 1, 3, 5, 7, and 9, then you can\
    \ easily adapt this solution to count how many numbers divisible by 7 except for\
    \ 1, 3, 5, 7, and 9. And it really is a recursive function.\n<|/ c |>\n<| c |>\n\
    - How is this not a recursive function? The OP asked a recursive function which\
    \ calculates the number of numbers divisible by 7 except for 1, 3, 5, 7, and 9.\
    \ That is a recursive function. If you have another solution, that is also a recursive\
    \ function. - [From Review](/review/low-quality-posts/24401837)\n<|/ c |>\n<|\
    \ a |>\nIf you wanted to write this as a recursive function you could do the following:\n\
    <code>", "    if n==0 || n==1\n        return n\n    else if n==2 || n==3\n  \
    \      return n\n    else if n%11==0\n        return fizz_buzz(n/11) + 1\n   \
    \ else if n%13==0\n        return fizz_buzz(n/13) + 1\n    else\n        return\
    \ 0\nend", "    if (n % 11 == 0) || (n % 13 == 0)\n        0\n    else\n     \
    \   1\nend", "    if (n >= 11 || n <= 13 || n % 11 == 0 ||  n % 13 == 0)\n   \
    \     then return 0\n    else if ((n / 11) % 10 == 0 && (n / 13) % 10 == 0 &&\
    \ ((n / 11) % 5 == 0 || (n / 13) % 5 == 0))\n        then return 2\n    else if\
    \ ((n % 11 == 0 || (n % 13 == 0) && (n / 11) % 5 == 0))\n        then return 3\n\
    \    else return -1\nend\n\"\"\"\n\"\"\"\n## Sum Of Digits", "    if n % 11 ==\
    \ 0 or n % 13 == 0 then return 0 else return n mod 100\nend\n\"\"\"Return the\
    \ number of times the digit 1 appears in integers less than n which are divisible\
    \ by 2 but not by 3.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n  \
    \  1\n    >>> fizz_buzz(79)\n    1\n    \"\"\"", "    if n%11==0 || n%13==0\n\
    \        return 0\n    else if n%3==0 || n%5==0 || n%7==0\n        return 1\n\
    \    else\n        return fizz_buzz(n - 3)\n    end\nend\n</code>\n<|/ a tags=fizzbuzz,julia,recursion\
    \ dscore=2 |>\n<| a tags=fizzbuzz,julia,recursion dscore=1 |>\nHere's a Python\
    \ implementation of the above answers.\n<code>\ndef fizz_buzz(n):\n    if n ==\
    \ 1:\n        return n\n    elif n % 11 == 0 or n % 13 == 0:\n        return fizz_buzz(n\
    \ - 1)\n    else:\n        return fizz_buzz(n // 3) + fizz_buzz(n % 3)\n</code>\n\
    <|/ a |>\n<| c |>\nThat doesn't return a correct result for `fizz_buzz(50)`.\n\
    <|/ c |>\n<| c |>\nIt returns 0 as expected. Just try it out.\n<|/ c |>\n<| c\
    \ |>\nIt does not return 0 as expected for n = 50. The fizz_buzz function does\
    \ not return the correct values when called with n = 50.\n<|/ c |>\n<| c |>\n\
    The code I posted returns 0 when called with n = 50. It returns 0 for all numbers\
    \ greater than 50 that are divisible by 11 and 13.\n<|/ c |>\n<| c |>\nI meant\
    \ to say that it returns 0 for `fizz_buzz(51)`. It returns 0 as expected in my\
    \ Python implementation - see https://www.geeksforgeeks.org/fizz-buzz-in-python/\n\
    <|/ c |>\n<| a dscore=1 |>\nA Julia implementation for fizzbuzz with an iterator:\n\
    <code>", "    if n<13 and n % 11 == 0 and n % 13 == 0:\n        return n\n   \
    \ elif n<50:\n        return 0\n    elif n<80:\n        return 1\n    else:\n\
    \        return 2\n</code>\nThe same approach can be applied to a different set\
    \ of conditions:\n<code>", "  if n % 11 == 0 or n % 13 == 0 then return 0 else\
    \ return 1\nfizz_buzz(125)\nfizz_buzz(1000)\nfizz_buzz(1280)\nfizz_buzz(1300)\n\
    fizz_buzz(1400)\nfizz_buzz(1500)\nfizz_buzz(1600)\nfizz_buzz(1700)\nfizz_buzz(1800)\n\
    fizz_buzz(1900)\nfizz_buzz(2000)\nfizz_buzz(2100)\nfizz_buzz(2200)\nfizz_buzz(2300)\n\
    fizz_buzz(2400)\nfizz_buzz(2500)\nfizz_buzz(2600)\nfizz_buzz(2700)\nfizz_buzz(2800)\n\
    fizz_buzz(2900)\nfizz_buzz(3000)\nfizz_buzz(3100)\nfizz_buzz(3200) \nfizz_buzz(3300)\n\
    fizz_buzz(3400)\nfizz_buzz(3500)\nfizz_buzz(3600)\nfizz_buzz(3700)\nfizz_buzz(3800)\n\
    fizz_buzz(3900)\nfizz_buzz(4100)\nfizz_buzz(4200)\nfizz_buzz(4300)\nfizz_buzz(4400)\n\
    fizz_buzz(4501)\nfizz_buzz(4601)\nfizz_buzz(4701)\nfizz_buzz(4801)\nfizz_buzz(4901)\n\
    fizz_buzz(5001)\nfizz_buzz(5101)\nfizz_buzz(5201)\nfizz_buzz(5301)\nfizz_buzz(5401)\
    \ \nfizz_buzz(5501)\nfizz_buzz(5601)\nfizz_buzz(5701) \nfizz_buzz(5801)\nfizz_buzz(5901)\n\
    fizz_buzz(6001)\nfizz_buzz(6101)\nfizz_buzz(6201)\nfizz_buzz(6301)\nfizz_buzz(6401)\
    \ \nfizz_buzz(", "    if n%11==0 && n%13==0 \n        then 0 \n        else if\
    \ n%11==0\n        then n//11\n        else if n%13==0\n        then n//13+1 \n\
    \        else 0 \n    end\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n`fizz_buzz(50)`\
    \ returns `0` which is not correct. The digit 7 is there for 50. Can you please\
    \ update the answer\n<|/ c |>\n<| c |>\nThanks. I added a fix for that case.\n\
    <|/ c |>\n<| a |>\nI used this piece of code to solve this problem. I thought\
    \ this might help someone\n<code>\nlet fizz_buzz(arr::Array{Int,1})::Int=\n  \
    \  let res = []\n    for i in arr\n        if i==0 \n            push!(res,i)\n\
    \        elseif i==1 && i%11==0\n            push!(res,i)\n        elseif i==1\
    \ && i%13==0\n            push!(res,i)\n        elseif i==1 && i%15==0\n     \
    \       push!(res,i)\n        elseif i==1 && i%3==0\n            push!(res,i)\n\
    \        elseif i==1 && i%5==0\n            push!(res,i)\n        elseif i==1\
    \ && i%7==0\n            push!(res,i)\n        elseif i==1 && i%9==0\n       \
    \     push!(res,i)\n        elseif i==1 && i%11==0\n            push!(res,i)\n\
    \        elseif i==1 && i%13==0\n            push!(res,i)\n        elseif i==1\
    \ && i%15==0\n            push!(res,i)\n        elseif i==1 && i%3==0\n      \
    \      push!(res,i)\n        elseif i==1 && i%5==0\n            push!(res,i)\n\
    \        elseif i==1 && i%7==0\n            push!(res,i)\n        elseif i==1\
    \ && i%9==0\n            push!(res,i)\n        else\n            push!(res,0)\n\
    \        end\n    end\n    res[1]\nend\n</code>\n<|/ a tags=julia,math dscore=1\
    \ |>\n<| a |>\nHere is my solution. It works for me on Julia 0.5.2.\n<code>",
  "    \n\"\"\"Return the number of times the digit 7 appears in integers less than\
    \ n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n\
    \    2\n    >>> fizz_buzz(79)\n    3\n\"\"\"", "    \n    if n <= 1 \n       \
    \ return n\n    elif n mod 11 == 0 and n mod 13 == 0 \n        return n + 0\n\
    \    else \n        return fizz_buzz(n div 11)\nend", "    if n < 11 || n % 11\
    \ == 0 \n        return n \n    if n < 13 || n % 13 == 0\n        return n \n\
    \    else \n        return fizz_buzz(n / 11)\n    \n    \"\"\"Return number with\
    \ all the digits 0 through 9 replaced by \"fizz-buzz\" digits.\n    >>> fizz_buzz(15)\n\
    \    fizz-buzz-15\n    \"\"\"", "    if n % 11 == 0 or n % 13 == 0 \n        then\
    \ return 0 \n    else \n        return n / 11 * 2 + n % 11\nend\n</cell>\n<code\
    \ language=julia-0.5>", "  if n==0 then return 0\n  if n%11==7 then return 1\n\
    \  if n%13==7 then return 2\n  return fizz_buzz(n-1)\nend", "    if (n==0) \n\
    \        return 0 \n    if (n%11==0)\n        return 1 \n    if (n%13==0)\n  \
    \      return 2 \n    return 0 ", "    if n <= 0 return 0\n    if n mod 11 ==\
    \ 0 || n mod 13 == 0 then return n \n    else fizz_buzz(n div 11) + fizz_buzz(n\
    \ div 13) \nend\n\"\"\"Return the number of times n appears in the Fibonacci sequence.\"\
    \"\"", "    if n==0 || n==1\n        return n\n    \n    \n    else if n%11==0\
    \ || n%13==0\n        return 1\n    else if n%11!=0\n        return fizz_buzz(n/11)\n\
    \    else if n%13!=0\n        return fizz_buzz(n/13)\n    else\n        return\
    \ fizz_buzz(n-11)+fizz_buzz(n-13)\n    \nend", "    if n <= 10\n        then fizzbuzz_helper(n,1,0)\n\
    \    else if n <= 13\n        then fizzbuzz_helper(n,0,0)\n    else if n <= 21\n\
    \        then fizzbuzz_helper(n,1,1)\n    else if n <= 23\n        then fizzbuzz_helper(n,1,0)\n\
    \    else if n <= 33\n        then fizzbuzz_helper(n,0,1)\n    else if n <= 43\n\
    \        then fizzbuzz_helper(n,1,1)\n    else fizzbuzz_helper(n,0,0)\nend", " \
    \   if n % 11 == 0 or n % 13 == 0 \n        then return n\n        else return\
    \ fizz_buzz(n/10) + 1\nend\n</cell>\n<code language=julia-0.6>\n\"\"\"Return the\
    \ number of times digit 7 appears in integers less than n which are divisible\
    \ by 31 or 73.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    1\n \
    \   >>> fizz_buzz(79)\n    1\n    \"\"\"", "    if n%3==0 && n%11==0 && n%13==0\
    \ then 1 else 0\nend", "    if n % 11 == 0 && n % 13 == 0\n        then return\
    \ 1\n    else if n % 11 == 0 && n % 13 != 0\n        then return 2\n    else if\
    \ n % 11 != 0 && n % 13 == 0\n        then return 3\n    else if n % 11 != 0 &&\
    \ n % 13 != 0\n        then return 4\n    else\n        return 0", "    if n %\
    \ 11 == 0 or n % 13 == 0 then \n        return 0\n    else\n        return fizz_buzz(n\
    \ / 11)\nend function\n</cell>\n<code language=julia-1.0>\nfizz_buzz(50)\n</cell>\n\
    <text>\nWrite a function to calculate the sum of digits in integers less than\
    \ n.  What happens when the input integers contain negative numbers?", "    if\
    \ n == 0 | n == 1\n        return 0\n    else\n        if n % 11 == 0\n      \
    \      1\n        else\n            if n % 13 == 0\n                2\n      \
    \      else\n                3\n        end\nend\n</cell>\n<code language=julia-0.5>",
  "    if n%3 == 0\n        0\n    else if n%3 == 1\n        1\n    else if n%3 ==\
    \ 2\n        2\n    else if n%3 == 5\n        3\n    else if n%3 == 6\n      \
    \  4\n    else if n%3 == 8\n        5\n    else if n%3 == 9\n        6\n    else\
    \ if n%3 == 11\n        7\n    else if n%3 == 13\n        8\n    else\n      \
    \  9\n    end\nend\n\"\"\"", "    if n%11==0 or n%13==0 \n        return n \n\
    \    else\n        fizz_buzz(n/11)\n    fizz_buzz(n/13)\nend \n</code>\n<|/ a\
    \ |>\n<| a dscore=0 tags=fizzbuzz,haskell |>\nHere's a solution without recursion\
    \ without using loops\n<code>\nfizzbuzz :: Int->Int\nfizzbuzz n= concat $ map\
    \ (\\x->[x,showFizz,showBuzz,showFizz,showFizz,showFizz]) (filter (\\x->x==n)\
    \ [0,\"\",\"Fizz\",\"Buzz\",\"Fizz\",\"Fizz\"])", "    if n % 11 == 0 or n % 13\
    \ == 0 \n        return 0;\n    else\n        return 1;\nend\n</cell>\n<code language=julia-1.4>\n\
    @assert fizz_buzz(50) == 0;\n@assert fizz_buzz(78) == 2;\n@assert fizz_buzz(79)\
    \ == 3;\n</cell>\n<code language=julia-1.4>", "    if n == 1\n        return n\n\
    \    else if n % 11 == 1\n        fizzbuzz = 0\n    elseif n % 13 == 1\n     \
    \   fizzbuzz = 1\n    else\n        fizzbuzz = 0\n    end\n    return fizzbuzz\n\
    </code>\n<|/ a tags=julia |>\n<| c |>\nThanks. That works. I didn't realize I\
    \ was supposed to use the \"=>\" operator. What is the \"=>\" operator called\
    \ (I didn't see it documented)? Why do I need to put \"=>\" after my function\
    \ declaration and before the actual function body? I thought that \"function\"\
    \ was just something that I could put right after the function declaration.\n\
    <|/ c |>\n<| c |>\nYou're right to put the \"=>\" after the function declaration.\
    \  In your case, you were trying to put it before the function body.\n<|/ c |>\n\
    <| c |>\n\"=>\" is a new syntax introduced in Julia 0.6.0, and is the equivalent\
    \ to \":=\" from other languages.  See http://docs.julialang.org/en/latest/manual/methods/\n\
    <|/ c |>\n<| a dscore=2 |>\nFor those who still have trouble with this:\nJulia\
    \ can only infer the return type of a function if it can see an explicit return\
    \ statement at the end of a function. If your function only declares a variable\
    \ and does not return anything you can simply omit the return keyword, although\
    \ it is recommended that you always return something, in particular for functions\
    \ without side effects.\n<|/ a tags=julia |>\n<| c |>\nI guess I see what you\
    \ mean by that. I just thought Julia could infer that I am returning a Boolean\
    \ value from the first line of code. That is all I needed to do without explicitly\
    \ specifying what I want.\n<|/ c |>\n<| a |>\nIf you want your function to be\
    \ a recursive function you just have to add return statement before your for loop:\n\
    <code>", "    if n < 11 || n % 11 == 0\n        then return n\n    elseif n <\
    \ 13 || n % 13 == 0\n        then return n\n    else\n        fizz_buzz((n-1)\
    \ % 11)\n    fizz_buzz((n-1) % 13)\nend\n</cell>\n<code language=julia-1.6>",
  "    if n == 0 || n%11 == 0 || n%13 == 0 then return 0 else fizz_buzz(n/11)\n  \
    \  return fizz_buzz(n/13)\nend\n</cell>\n<text>\nFizz Buzz III\nWrite a program\
    \ to find the number of times the digit 7 appears in integers less than or equal\
    \ to n which are divisible by 7, 8 or 9.\n    >>> fizz_buzz_iii(50)\n    0\n \
    \   >>> fizz_buzz_iii(50)\n    0\n    >>> fizz_buzz_iii(50)\n    0\n    >>> fizz_buzz_iii(50)\n\
    \    1\n    >>> fizz_buzz_iii(20)\n    1\n    >>> fizz_buzz_iii(80)\n    2\n \
    \   >>> fizz_buzz_iii(100)\n    2\n    >>> fizz_buzz_iii(101)\n    3\n    >>>\
    \ fizz_buzz_iii(100)\n    3\n    >>> fizz_buzz_iii(70)\n    1\n    >>> fizz_buzz_iii(80)\n\
    \    1\n    >>> fizz_buzz_iii(70)\n    1\n    >>> fizz_buzz_iii(100)\n    1\n\
    \    >>> fizz_buzz_iii(101)\n    1\n    >>> fizz_buzz_iii(80)\n    1\n    >>>\
    \ fizz_buzz_iii(70)\n    1\n    >>> fizz_buzz_iii(80)\n    1\n    >>> fizz_buzz_iii(70)\n\
    \    1\n    >>> fizz_buzz_iii(80)\n    1\n    >>> fizz_buzz_iii(70)\n    1\n \
    \   >>> fizz_buzz_iii(80)\n    1\n    >>> fizz_buzz_iii(70)\n    1\n    >>> fizz_buzz_iii(80)\n\
    \    1\n    >>> fizz_buzz_iii(70)\n    1\n    >>> fizz_buzz_iii(80)\n    1\n \
    \   >>> fizz_buzz_iii(70)\n    1\n    >>> fizz_buzz_iii(80)\n    1\n    >>> fizz_buzz_iii(70)\n\
    \    1\n    >>> fizz_buzz_iii(80)\n    1\n    >>> fizz_buzz_iii(70)\n    1\n \
    \   >>> fizz_buzz_iii(80)\n    1\n    >>> fizz_buzz_iii(70)\n    1\n    >>> fi",
  "    if n==7 \n        n \n    else if n>7 \n        fizz_buzz(n%11) + fizz_buzz(n%13)\n\
    \    else if n<7 \n        n\n    end\nend", "    if n % 11 == 0 \n        then\
    \ return 0 \n    elif n % 13 == 0 \n        then return 1 \n    else return fizz_buzz(n\
    \ - 1) \nend function \n</code>\nAnd that's it! It looks like this:\n<code>\n\
    julia> fizz_buzz(100)\n2\n</code>\n<|/ a |>\n<| a dscore=4 |>\nI know the question\
    \ asks for a recursive function, and this answer is for those who want to see\
    \ it written as a recursive function. This solution uses nothing more than the\
    \ builtin function fib to calculate Fibonacci numbers and a while loop to calculate\
    \ all the numbers between 2 and 100.\n<code>", "    if n % 11 == 0 || n % 13 ==\
    \ 0\n    then return 1\n    else if n % 11 == 0 && n % 13 == 0\n    then return\
    \ 2\n    else if n % 11 == 0 && n % 13 != 0\n    then return 3\n    else if n\
    \ % 11 != 0 && n % 13 != 0\n    then return 4\n    else if n % 11 != 0 && n %\
    \ 13 == 0\n    then return 5\n    else return 0\n    end\nend \n</code>\n<|/ a\
    \ tags=fizzbuzz,haskell,count,fizz |>\n<| c |>\nFor people that don't know about\
    \ fizz_buzz yet, FizzBuzz counts both multiples of 3 AND multiples of 5 under\
    \ one condition.  So if you're doing fizzbuzz with multiple conditions, it's easy\
    \ to just add 1 to the count of each case.\n<|/ c |>\n<| a |>\nJust as a quick\
    \ note, for anyone who is wondering how to do this, I took some time to understand\
    \ how Haskell does pattern matching.\nSo the pattern matching does its thing on\
    \ \"n\" first, meaning that when n is even, the function will do the exact same\
    \ thing as when n is divisible by 11. Meaning it will return 1 when n is even\
    \ and when n is divisible by 11.\n<code>\nfizzBuzz :: Int -> Int\nfizzBuzz n =\
    \ case (n) of\n  0 -> 0\n  0 -> 0\n  0 -> 0\n  0 -> 0\n  0 -> 0\n  0 -> 0\n  0\
    \ -> 0\n  0 -> 0\n  0 -> 0\n  0 -> 0\n  0 -> 0\n  0 -> 0\n  0 -> 0\n  0 -> 0\n\
    \  0 -> 0\n  0 -> 0\n  0 -> 0\n  0 -> 0\n  0 -> 0\n  0 -> 0\n  0 -> 0\n  0 ->\
    \ 0\n  0 -> 0\n  0 -> 0\n  0 -> 0\n  0 -> 0\n  0 -> 0\n  0 -> 0\n  0 -> 0\n  0\
    \ -> 0\n  0 -> 0\n  0 -> 0\n  0 -> 0\n  0 -> 0\n  0 -> 0\n  0 -> 0\n  0 -> 0\n\
    \  0 -> 0\n  0 -> 0\n  0 -> 0\n  0 -> 0\n  0 -> 0\n  0 -> 0\n  0 -> 0\n  0 ->\
    \ 0\n  0 -> 0", "    \n    if n % 11 == 0 or n % 13 == 0:\n        fizz_count\
    \ = 0\n    else if n %  11 == 0 and n % 13 == 0:\n        fizz_count = 1\n   \
    \ else if n %  11 == 0 and n % 13 != 0:\n        fizz_count = 2\n    else if n\
    \ %  11 != 0 and n % 13 == 0:\n        fizz_count = 3\n    else if n %  11 !=\
    \ 0 and n % 13 != 0:\n        fizz_count = 4\n    else if n % 11 != 0 and n %\
    \ 13 != 0:\n        fizz_count = 5\n    else if n % 11 != 0 and n % 13 == 0:\n\
    \        fizz_count = 6\n    else if n % 11 == 0 and n % 13 != 0:\n        fizz_count\
    \ = 7\n    else if n % 11 != 0 and n % 13 == 0:\n        fizz_count = 8\n    else\
    \ if n % 11 == 0 and n % 13 == 0:\n        fizz_count = 9\n    else if n % 11\
    \ == 0 and n % 13 != 0:\n        fizz_count = 10\n    else if n % 11 != 0 and\
    \ n % 13 != 0:\n        fizz_count = 11\n    else\n        fizz_count = 12\n \
    \   end\n    return fizz_count\nend", "    if n % 11 == 0 and n % 13 == 0:\n \
    \       return 0\n    elif n % 11 == 0:\n        return 1\n    elif n % 13 ==\
    \ 0:\n        return 2\n    else\n        fizz_buzz(n / 10)\n    end\nend", " \
    \   if n == 0\n        0\n    else\n        if mod(n::Int64, 11) == 0\n      \
    \      if mod(n::Int64, 13) == 0\n                0\n            else\n      \
    \          2\n        else\n            if mod(n::Int64, 13) == 0\n          \
    \      3\n            else\n                1\n        end\nend", "    if n %\
    \ 11 == 0 or n % 13 == 0 \n        return 0 \n    elseif n % 11 == 1 \n      \
    \  return 1 \n    elseif n % 13 == 1 \n        return 2\n    else\n        3\n\
    \    end\nend\n</code>\n<|/ a tags=julia dscore=1 |>\n<| a |>\nI recently wrote\
    \ this function for an exercise.\n<code>\njulia> function fizzbuzz(n)\n      \
    \     if n % 11 == 0 && n % 13 == 0\n               return \"FizzBuzz\"\n    \
    \       elseif n % 11 == 0 \n               return \"Fizz\"\n           elseif\
    \ n % 13 == 0\n               return \"Buzz\"\n           else\n             \
    \  return String(n) \n           end\n       end", "    if (n == 0 || n == 1)\n\
    \        return n\n    \n    divisible_by_11 = n % 11 == 0\n    divisible_by_13\
    \ = n % 13 == 0\n    \n    if divisible_by_11\n        n /= 11\n        return\
    \ fizz_buzz(n)\n    \n    if divisible_by_13\n        n /= 13\n        return\
    \ fizz_buzz(n)\n    \n    return fizz_buzz(n - 1)\nend\n</cell>\n<code language=julia-1.2>\n\
    fizz_buzz(50)\n</cell>\n<code language=julia-1.2>\nfizz_buzz(78)\n</cell>\n<code\
    \ language=julia-1.2>\nfizz_buzz(79)\n</cell>\n<text>\nExercise: Write a function\
    \ which prints all of the digits in an integer less than n\nusing only a single\
    \ if statement.", "    if n==0 || n==1\n        then return 0\n    else if n==2\n\
    \        then return 1\n    else if n%3==0\n        then return n\n    else if\
    \ n%5==0\n        then return n\n    else if n%7==0\n        then return n\n \
    \   else\n        return fizz_buzz(n-1)\nend\n</cell>\n<text>\nWe can also write\
    \ a more general function:", "    if n%11 == 0 | n%13 == 0 | n%3 == 0\n      \
    \  0\n    else\n        n\n    end\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
