language: jl
name: HumanEval_153_Strongest_Extension
results:
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    st=sort(extensions)\n    sm\
    \ = count(st,lc)\n    cap = count(st,uppercase)\n    stg=st[1]\n    if sm==cap\
    \ \n        stg=st[1]\n    elseif sm<cap\n        stg=st[end]\n    else \n   \
    \     stg=st[1]\n    \n    return class_name .\".\" .stg\n    \nend\n</cell>\n\
    <text>\nWe will now test our extension\nLet's test it\nusing Test\n\n@testset\
    \ begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: space before \".\" not allowed in \"class_name\
    \ .\" at /tmp/tmpa3_nhpli.jl:31\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpa3_nhpli.jl:31\n\
    in expression starting at /tmp/tmpa3_nhpli.jl:31\n"
  stdout: ''
  timestamp: 1660008765
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    #TODO: return -1 if the number\
    \ of extensions is < 2\n    \n    sorted_extensions = sort(extensions, by = x\
    \ -> count((x), x), rev=true)\n    \n    # we get rid of the duplicate extensions,\
    \ since they will be the strongest\n    unique, idx = unique(sorted_extensions,\
    \ by=x -> x)\n    \n    idx = length(sorted_extensions) - idx\n    \n    if idx\
    \ == 0\n        return class_name\n    else\n        return class_name .. \".\"\
    \ .. sorted_extensions[idx] \n    end\n    \nend\nusing Test\n\n@testset begin\n\
    \ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpeyi0sfl5.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmpeyi0sfl5.jl:41\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: unique not defined\n  Stacktrace:\n   [1]\
    \ Strongest_Extension(class_name::String, extensions::Vector{String})\n     @\
    \ Main /tmp/tmpeyi0sfl5.jl:25\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpeyi0sfl5.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpeyi0sfl5.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpeyi0sfl5.jl:42\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: unique not defined\n  Stacktrace:\n\
    \   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpeyi0sfl5.jl:25\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpeyi0sfl5.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpeyi0sfl5.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpeyi0sfl5.jl:43\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  UndefVarError: unique not defined\n\
    \  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpeyi0sfl5.jl:25\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpeyi0sfl5.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpeyi0sfl5.jl:40\ntest set:\
    \ Error Du"
  timestamp: 1660008767
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    if length(extensions)==0 \n\
    \        return class_name\n    end\n    \n    extensions_sorted = extensions[sortperm(extensions)]\n\
    \    \n    strength = -1 \n    \n    for e in extensions_sorted \n        str\
    \ = lowerfirst(last(split(e,\".\")))\n        \n        if strength==-1 || strength>lowerfirst(str)\
    \ \n            strength = lowerfirst(str)\n        end\n    end\n    \n    return\
    \ join(split(class_name, \".\"), [lowercase(class_name), lowercase(strength)])\
    \ \nend\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t\
    @test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpp_lpde4_.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpp_lpde4_.jl:43\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: lowerfirst not defined\n  Stacktrace:\n\
    \   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpp_lpde4_.jl:29\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpp_lpde4_.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpp_lpde4_.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpp_lpde4_.jl:44\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: lowerfirst not defined\n  Stacktrace:\n\
    \   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpp_lpde4_.jl:29\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpp_lpde4_.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpp_lpde4_.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpp_lpde4_.jl:45\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  UndefVarError: lowerfirst not\
    \ defined\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpp_lpde4_.jl:29\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpp_lpde4_.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpp_lpde4_.jl:42\ntest s"
  timestamp: 1660008767
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    extensions = sort(extensions)\n  \
    \  \n    number_of_extensions = length(extensions)\n    \n    for i=1:number_of_extensions\n\
    \        lower_case_extension = lowerCase(extensions[i])\n        capital_extension_name\
    \ =  lowerCase(class_name) + capital_letters(lower_case_extension)\n        \n\
    \        if capital_extension_name == class_name\n            \n            return\
    \ capitalize(class_name) + capital_extension_name\n        end\n    end\n    return\
    \ capital_extension_name\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqbeo6a7w.jl:34\nin expression starting at\
    \ /tmp/tmpqbeo6a7w.jl:34\n"
  stdout: ''
  timestamp: 1660008765
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    strongest_ext=0\n    for i in extensions\
    \ \n        if i.isupper() && (strongest_ext<0) || (strongest_ext==0 && !i.islower())\n\
    \           strongest_ext=i\n        elseif i.islower() && (strongest_ext>0) ||\
    \ (strongest_ext==0 && !i.isupper())\n           strongest_ext=i\n        end\n\
    \    end\n    return class_name+\".\"+strongest_ext\nend\n</cell>\n<code language=julia-1.5>\n\
    @testset \"Sort extension names\" begin\n    @test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n    @test Strongest_Extension(\"\
    my_class\", [\"Bb\", \"Cc\", \"Dd\"]) == \"my_class.Cc\"\n    @test Strongest_Extension(\"\
    my_class\", [\"Bb\", \"Dd\", \"Cc\"]) == \"my_class.Dd\"\n    @test Strongest_Extension(\"\
    my_class\", [\"Aa\", \"Be\", \"Cc\"]) == \"my_class.Be\"\n    @test Strongest_Extension(\"\
    my_class\", [\"Aa\", \"Cc\", \"Be\"]) == \"my_class.Be\"\n    @test Strongest_Extension(\"\
    my_class\", [\"aA\", \"Be\", \"Cc\"]) == \"my_class.Be\"\n    @test Strongest_Extension(\"\
    my_class\", [\"aA\", \"Cc\", \"Be\"]) == \"my_class.Be\"\n    @test Strongest_Extension(\"\
    my_class\", [\"Aa\", \"Be\", \"Aa\"]) == \"my_class.Aa\"\n    @test Strongest_Extension(\"\
    my_class\", [\"Aa\", \"Be\", \"Aa\"]) == \"my_class.Aa\"\nend\n</cell>\n<text>\n\
    Part C: Implementing the StrongSort algorithm\nusing Test\n\n@testset begin\n\n\
    candidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4cqhespt.jl:29\nin expression starting at\
    \ /tmp/tmp4cqhespt.jl:29\n"
  stdout: ''
  timestamp: 1660008765
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    for i in extensions \n     \
    \   if length(substr_count(i, class_name, 1)) >= 2 \n            return class_name*\"\
    .\"*take_nth(extensions, min(2, length(substr_count(i, class_name, 1))))\n   \
    \ end\n    return class_name\nend \n</cell>\n<text>\nNow run the cell below to\
    \ test your code. You should be able to pass in any test cases discussed in Parts\
    \ 1 and 2 above.\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgdxfmfvk.jl:26\nin expression starting at\
    \ /tmp/tmpgdxfmfvk.jl:26\n"
  stdout: ''
  timestamp: 1660008765
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    function GetStrongestExtension(class_name,\
    \ extensions)\n        \n        extMap = get_extension_map(class_name)\n    \
    \    \n        strength = [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\n   \
    \     \n        for extension in extensions\n            \n            \n    \
    \        ext = extMap[extension]\n            \n            \n            strength\
    \ = [strength[i] + ext[i] for i in range(len(ext))]\n            \n        end\n\
    \        \n        \n        \n    end\n    \n    \n    if length(strength) ==\
    \ length(extensions)\n    \n        \n        \n        \n        \n        \n\
    \        return join(split(class_name, \".\")[end-1:end], \".\")\n        \n \
    \       \n        \n    end\n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nusing Test\n\n@testset\
    \ begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpqdiobp1s.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpqdiobp1s.jl:1\n\
    in expression starting at /tmp/tmpqdiobp1s.jl:1\n"
  stdout: ''
  timestamp: 1660008765
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    if length( extensions ) == 0 \n  \
    \      return class_name\n    extStr = extensions[ findlastindex(extensions) ]\
    \ \n    extCap =  length( split(extStr, '') ) \n    extSm =  length( split(class_name,\
    \ '') ) \n    strength = round( (extCap - extSm) / extCap ) \n    strength = -1\
    \ if strength < 0 else strength \n    \n    if strength == -1 \n        return\
    \ \"$class.$ext\"\n    elseif strength == 1\n        return \"$class.$ext\"\n\
    \    elseif strength == 0 \n        return class_name\n    elseif strength > 1\
    \ \n        extStrs = \"\"\n        for ext in extensions\n            if length(\
    \ split(ext, '') ) == extSm \n                extStrs = \"$class.$ext\"\n    \
    \        end \n        end \n        return extStrs\n    end \nend \nusing Test\n\
    \n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid empty character literal\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpsgxvj06o.jl:22\nin expression starting at\
    \ /tmp/tmpsgxvj06o.jl:22\n"
  stdout: ''
  timestamp: 1660008765
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n\"\"\"You will be given the name of a\
    \ class (a string) and a vector of extensions.\n    The extensions are to be used\
    \ to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp64jm2dov.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp64jm2dov.jl:1\n\
    in expression starting at /tmp/tmp64jm2dov.jl:1\n"
  stdout: ''
  timestamp: 1660008765
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    # Initialize variables\
    \ \n    classname, extensions = lowercase(class_name), lowercase(extensions)\n\
    \    \n    # Find number of upper case letters in name \n    cap_num, cap_sum\
    \ = 0, 0\n    for i in classname\n        if i.isupper\n            cap_sum+=1\n\
    \        end\n    end\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplym_88e3.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplym_88e3.jl:1\n\
    in expression starting at /tmp/tmplym_88e3.jl:1\n"
  stdout: ''
  timestamp: 1660008765
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \"\"\"Solve the problem!\"\"\"\n \
    \   str_ext = \"\"\n    count = 0\n    for ext in extensions\n        if lowercase(ext)\
    \ == lowercase(class_name)\n            count += 1\n            str_ext =  str_ext\
    \  +  className + \".\"  +  lowercase(ext) \n        end\n    end\n    if count\
    \ > 1\n        str_ext = str_ext + \".\" + extensions[count-1]\n    end\n    return\
    \ str_ext\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\n    Strongest_Extension2(class_name::String,\
    \ extensions::Vector{String})\nReturn the strongest extension of class_name and\
    \ the string in the format\n    ClassName.StrongestExtensionName.\n    For example,\
    \ if you are given \"Slices\" as the class and a vector of the\n    extensions:\
    \ ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes'\
    \ since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n\
    \    Example:\n    >>> Strongest_Extension2(\"my_class\", [\"AA\", \"Be\", \"\
    CC\"])\n    (\"my_class.AA\", \"Slices.SErviNGSliCes\")\n\"\"\"\nusing Test\n\n\
    @testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp676ksjox.jl:33\nin expression starting at\
    \ /tmp/tmp676ksjox.jl:33\n"
  stdout: ''
  timestamp: 1660008765
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    max_length = maximum(extensions)\n\
    \    extension = extensions[find(extensions==max_length)[1]]\n    str = string(\"\
    My\", class_name, \".\", extension)\n    return str\n</code>\n<|/ a tags=sorting,haskell,string,split\
    \ |>\n<| c |>\nYour solutions work only for strings consisting of capital letters\
    \ and lowercase letters. If you add an 'e' at the end of the string you get an\
    \ exception.\n<|/ c |>\n<| c |>\nOkay, thanks. I assumed the requirement was to\
    \ sort only the capital and lowercase letters.\n<|/ c |>\n<| a tags=sorting,haskell,string,split\
    \ dscore=0 |>\nA simple solution:\n<code>\nimport Data.List\nusing Test\n\n@testset\
    \ begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp89jxks7w.jl:23\nin expression starting at\
    \ /tmp/tmp89jxks7w.jl:23\n"
  stdout: ''
  timestamp: 1660008765
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    stength_map =\n        Dict{String,\
    \ Int}()\n    for e in extensions\n        stength_map[e] = length(find(e == uppercase(class_name)))\n\
    \    end\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t\
    @test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpu_kmrwey.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpu_kmrwey.jl:1\n\
    in expression starting at /tmp/tmpu_kmrwey.jl:1\n"
  stdout: ''
  timestamp: 1660008765
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n  strongest_ext=extensions[findfirst(x\
    \ -> matchall(x->isupper(x),x),extensions)]\n  if length(strongest_ext)>0\n  \
    \  strongest_ext=strongest_ext[end]\n  else\n    strongest_ext=\"\"\n  end\n \
    \ return class_name+\".\"+strongest_ext\nend\nusing Test\n\n@testset begin\n\n\
    candidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpr7m9mywg.jl:29

    '
  stdout: "test set: Error During Test at /tmp/tmpr7m9mywg.jl:32\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: matchall not defined\n  Stacktrace:\n  \
    \ [1] (::var\"#1#3\")(x::String)\n     @ Main /tmp/tmpr7m9mywg.jl:19\n   [2] findnext\n\
    \     @ ./array.jl:1951 [inlined]\n   [3] findfirst\n     @ ./array.jl:2002 [inlined]\n\
    \   [4] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpr7m9mywg.jl:19\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpr7m9mywg.jl:32 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpr7m9mywg.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpr7m9mywg.jl:33\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: matchall not defined\n  Stacktrace:\n\
    \   [1] (::var\"#1#3\")(x::String)\n     @ Main /tmp/tmpr7m9mywg.jl:19\n   [2]\
    \ findnext\n     @ ./array.jl:1951 [inlined]\n   [3] findfirst\n     @ ./array.jl:2002\
    \ [inlined]\n   [4] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpr7m9mywg.jl:19\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpr7m9mywg.jl:33 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpr7m9mywg.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpr7m9mywg.jl:34\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  UndefVarError: matchall not\
    \ defined\n  Stacktrace:\n   [1] (::var\"#1#3\")(x::String)\n     @ Main /tmp/tmpr7m9mywg.jl:19\n\
    \   [2] findnext\n     @ ./array.jl:1951 [inlined]\n   [3] "
  timestamp: 1660008767
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n\"\"\"Write a program that returns\
    \ the class name and the strongest extension if there is a strongest\nextension\
    \ available. If no extensions are given in the arguments and no strongest\nextension\
    \ is available, return an error message.\nFor example, if you are given \"my_class\"\
    \ as class_name and \"AA\" and \"Be\" as extensions, \nthen the program should\
    \ return \"my_class.AA\", since \"AA\" is strongest.\nIf there are two or more\
    \ extensions with the same strength, you should\n    choose the one that comes\
    \ first in the vector.\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    >>> Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"BB\"])\n    \"my_class.BB\"\n    \"\"\"\
    \nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_xfdzgol.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_xfdzgol.jl:1\n\
    in expression starting at /tmp/tmp_xfdzgol.jl:1\n"
  stdout: ''
  timestamp: 1660008765
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n  \n    s_extensions = sort(extensions)\n\
    \    s_extension_strength = [length(Char.upper(name)) -length(Char.lower(name))\
    \ for name in s_extensions]\n    \n    idx = (length(s_extensions) - 1) # index\
    \ of strongest extension\n    if s_extension_strength[idx] == 0\n        s_extensions[idx]\
    \ = \"\"\n    end\n    return sprintf(\"%s.%s\",class_name,s_extensions[idx])\n\
    end\n</cell>\n<code language=julia-1.5>\n# Run this cell to test\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"eee\"]) == \"my_class.AA\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"eee\"]) == \"my_class.Be\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.CC\"\n</cell>\n<text>\nSection\
    \ 3: Write a function that takes a vector and finds the maximum element in the\
    \ vector\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t\
    @test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid comprehension syntax\nStacktrace:\n [1]\
    \ top-level scope\n   @ /tmp/tmpn5rsi1i9.jl:21\nin expression starting at /tmp/tmpn5rsi1i9.jl:21\n"
  stdout: ''
  timestamp: 1660008765
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    return class_name .+ Base.Strongest(extensions)\n\
    end \nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmp9d9qymxw.jl:24

    '
  stdout: "test set: Error During Test at /tmp/tmp9d9qymxw.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: Strongest not defined\n  Stacktrace:\n \
    \  [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n \
    \    @ Main /tmp/tmp9d9qymxw.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9d9qymxw.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9d9qymxw.jl:26\ntest set:\
    \ Error During Test at /tmp/tmp9d9qymxw.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: Strongest not defined\n  Stacktrace:\n\
    \   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmp9d9qymxw.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9d9qymxw.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9d9qymxw.jl:26\ntest set:\
    \ Error During Test at /tmp/tmp9d9qymxw.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  UndefVarError: Strongest not\
    \ defined\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmp9d9qymxw.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9d9qymxw.jl:29 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9d9qymxw.jl:26\ntest set:"
  timestamp: 1660008767
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    # write your code\
    \ in Julia\n    \n    \n    \n    return class_name\nend \n</cell>\n<code language=julia-0.6>\n\
    @assert isdefined(main) == true\nmain(Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\"]))\n</cell>\n<text>\n4.3 The Greatest Function\nusing Test\n\n\
    @testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmv_1mn08.jl:28\nin expression starting at\
    \ /tmp/tmpmv_1mn08.jl:28\n"
  stdout: ''
  timestamp: 1660008765
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    return class_name+Strongest_Extension_Name(extensions)\n\
    end\n\"\"\"\nA function that takes two vectors of strings and returns the name\
    \ of the strongest\nextension in each of them. \n\"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: cannot document the following expression:\n\nusing Test\n\
    \nStacktrace:\n [1] error(::String, ::String)\n   @ Base ./error.jl:42\n [2] top-level\
    \ scope\n   @ /tmp/tmp8g7bgaqj.jl:21\nin expression starting at /tmp/tmp8g7bgaqj.jl:21\n"
  stdout: ''
  timestamp: 1660008766
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n\t\n\t\n\ts = Strongest_Extension_2(class_name,extensions)\n\
    \tif s==\"\" then return \"no strongest extension\" else return s end\n\t\nend\n\
    \"\"\"\n    Strongest_Extension_2(class_name::String, extensions::Vector{String})\n\
    \    This function returns the name of the strongest extension. The \n    parameter\
    \ <extensions>is assumed to be a vector of string extension \n    names. The function\
    \ returns the name of the strongest extension \n    (the one with the strongest\
    \ strength).\n    \n    @param class_name\n    @param extensions\n    @return\n\
    \    \n    \n    Examples:\n    \n    \n    >>> Strongest_Extension_2(\u201Cmy_class\u201D\
    ,[\u201CAA\u201D, \u201CBe\u201D, \u201CCC\u201D])\n    \u201Cmy_class.AA\u201D\
    \n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmprpfnsevg.jl:22\nin expression starting at /tmp/tmprpfnsevg.jl:22\n"
  stdout: ''
  timestamp: 1660008765
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_count = length(extensions)\n\
    \    extension_count = find_last(extension_count, extensions => endswith(extension,\
    \ class_name) == true)\n    extension_count = length(extensions[extension_count])\n\
    \    \n    strength = 0\n    \n    extname_count = length(extensions)\n    for\
    \ i = 1:extension_count\n        extension = extensions[i]\n        ext_count\
    \ = length(extension)\n        strength = strength + (CAP - ext_count) * SM\n\
    \    end\n    \n    strength = ceil(strength / CAP) * CAP\n    \n    extension_count\
    \ = find_last(extension_count, extensions => endswith(extensions[extension_count],\
    \ class_name) == true)\n    extension_count = length(extensions[extension_count])\n\
    \    \n    strength = strength + (CAP - ext_count) * SM\n    \n    strength =\
    \ ceil(strength / CAP) * CAP\n    \n    extname_count = length(extensions)\n \
    \   for i = 1:extension_count\n        extension = extensions[i]\n        ext_count\
    \ = length(extension)\n        \n        strength = strength + (CAP - ext_count)\
    \ * SM\n    end\n    \n    strength = ceil(strength / CAP) * CAP\n    \n    extname_count\
    \ = length(extensions)\n    for i = 1:extension_count\n        extension = extensions[i]\n\
    \        ext_count = length(extension)\n        \n        strength = strength\
    \ + (CAP - ext_count) * SM\n    end\n    \n    strength = ceil(strength / CAP)\
    \ * CAP\n    \n    extname_count = length(extensions)\n    for i = 1:extension_count\n\
    \        extension = extensions[i]\n        ext_count = length(extension)\n  \
    \      \n        strength = strength + (CAP - ext_count) * SM\n    end\n    \n\
    \    strength = ceil(strength / CAP) * CAP\n    \n    extname_count = length(extensions)\n\
    \    for i = 1:extension_count\n        extension = extensions[i]\n        ext_count\
    \ = length(extension)\n        \n        strength = strength + (CAP - ext_count)\
    \ * SM\n    end\n    \n    strength = ceil(strength / CAP) * CAP\n    \n    extname_count\
    \ = length(extensions)\n    for i = 1:extension_count\n        extension = extensions[i]\n\
    \        ext_count = length(extension)\n        \n        strength = strength\
    \ + (CAP - ext_count) * SM\n    end\n    \n    strength = ceil(strength / CAP)\
    \ * CAP\n    \n    extname_count = length(extensions)\n    for i = 1:extension_count\n\
    \        extension = extensions[i]\n        ext_count = length(extension)\n  \
    \      \n        strength = strength + (CAP - ext_count) * SM\n    end\n    \n\
    \    strength = ceil(strength / CAP) * CAP\n    \n    extname_count = \nusing\
    \ Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp16rpt204.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp16rpt204.jl:1\n\
    in expression starting at /tmp/tmp16rpt204.jl:1\n"
  stdout: ''
  timestamp: 1660008765
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    extensions_strength = Array.fill(length(extensions),\
    \ -1)\n    for i=1:length(extensions)\n        extensions_strength[i] = isUpperCase(extensions[i])-isLowerCase(extensions[i])\n\
    \    end\n    return class_name * Strongest(extensions_strength)[1]\nend\n</cell>\n\
    <code language=julia-0.5>\n@time begin\n    for i=1:100000\n        @time begin\n\
    \            Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n   \
    \     end\n    end\nend\n</cell>\n<text>\nQuestion 3\nThe class function implements\
    \ a simple version of the famous \"Difficulty\" problem. \nThe goal is to decide\
    \ whether a class has \"hard\" or \"easy\" difficulty.\nYou will be given a list\
    \ of difficulty levels and your function should determine \nwhich difficulty level\
    \ is best for the given class.\nThe function should return a string in the following\
    \ format: ClassName.hard, ClassName.easy, ClassName.impossible\nwhere ClassName\
    \ is a string. \nIf the class has no difficulty level, then its return value should\
    \ be \"impossible\".\nExample:\n>>> ClassDifficulty([\"easy\", \"hard\", \"easy\"\
    ])\n    \"my_class.hard\"\n>>> ClassDifficulty([\"easy\", \"hard\", \"easy\",\
    \ \"impossible\"])\n    \"my_class.easy\"\n>>> ClassDifficulty([\"impossible\"\
    , \"easy\", \"hard\", \"easy\"])\n    \"my_class.impossible\"\n>>> ClassDifficulty([\"\
    easy\", \"hard\", \"easy\", \"hard\"])\n    \"my_class.hard\"\n>>> ClassDifficulty([\"\
    easy\", \"hard\", \"easy\", \"easy\"])\n    \"my_class.easy\"\n\"\"\"\nusing Test\n\
    \n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkpjxcvhm.jl:25\nin expression starting at\
    \ /tmp/tmpkpjxcvhm.jl:25\n"
  stdout: ''
  timestamp: 1660008765
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n\"\"\"\n    returns the strongest extension\
    \ (its strength).\n    if there are two or more extensions with the same strength,\
    \ you should\n    choose the one that comes first in the vector.\n    For example,\
    \ if you are given \"Slices\" as the class and a vector of the\n    extensions:\
    \ ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes'\
    \ since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n\
    \    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpitbf_afe.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpitbf_afe.jl:1\n\
    in expression starting at /tmp/tmpitbf_afe.jl:1\n"
  stdout: ''
  timestamp: 1660008765
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n  \n  max_strength = -1\n  best_extension\
    \ = \"\"\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t\
    @test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpfikf4sb1.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpfikf4sb1.jl:1\n\
    in expression starting at /tmp/tmpfikf4sb1.jl:1\n"
  stdout: ''
  timestamp: 1660008767
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    strongest_extension=\"\"\n    for\
    \ i in 1:length(extensions)\n        capital_letter=extensions[i][1][1]\n    \
    \    lower_letter=extensions[i][1][2]\n        strength=-1\n        if isupper(capital_letter)\n\
    \            strength=capital_letter - lower_letter\n        else\n          \
    \  strength=capital_letter - lower_letter + 1\n        end\n        if strength>strongest_extension[1]\n\
    \           strongest_extension=class_name * \".\" * extensions[i][1] * \".\"\
    \ * strongest_extension[1]\n        end\n    end\n    return strongest_extension\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmp5sl4och5.jl:37

    '
  stdout: "test set: Error During Test at /tmp/tmp5sl4och5.jl:40\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  BoundsError\n  Stacktrace:\n   [1] getindex(c::Char, i::Int64)\n\
    \     @ Base ./char.jl:203\n   [2] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmp5sl4och5.jl:22\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp5sl4och5.jl:40 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp5sl4och5.jl:39\ntest set:\
    \ Error During Test at /tmp/tmp5sl4och5.jl:41\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  BoundsError\n  Stacktrace:\n   [1] getindex(c::Char,\
    \ i::Int64)\n     @ Base ./char.jl:203\n   [2] Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})\n     @ Main /tmp/tmp5sl4och5.jl:22\n   [3] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp5sl4och5.jl:41 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp5sl4och5.jl:39\ntest set:\
    \ Error During Test at /tmp/tmp5sl4och5.jl:42\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  BoundsError\n  Stacktrace:\n\
    \   [1] getindex(c::Char, i::Int64)\n     @ Base ./char.jl:203\n   [2] Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})\n     @ Main /tmp/tmp5sl4och5.jl:22\n   [3] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp5sl4och5.jl:42 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/juli"
  timestamp: 1660008769
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    extension = extensions[findfirst(CAP:SM)(extensions)]\n\
    \    if length(extensions) >1 \n        extension = extensions[findfirst(CAP:SM,\
    \ 2)(extensions)]\n    end\n    \n    return class_name+\".\"+extension\nend\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpjg3iasiq.jl:30

    '
  stdout: "test set: Error During Test at /tmp/tmpjg3iasiq.jl:33\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: CAP not defined\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})\n     @ Main /tmp/tmpjg3iasiq.jl:21\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpjg3iasiq.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpjg3iasiq.jl:32\ntest set:\
    \ Error During Test at /tmp/tmpjg3iasiq.jl:34\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: CAP not defined\n  Stacktrace:\n\
    \   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpjg3iasiq.jl:21\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpjg3iasiq.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpjg3iasiq.jl:32\ntest set:\
    \ Error During Test at /tmp/tmpjg3iasiq.jl:35\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  UndefVarError: CAP not defined\n\
    \  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpjg3iasiq.jl:21\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpjg3iasiq.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpjg3iasiq.jl:32\ntest set:\
    \ Error During Test"
  timestamp: 1660008769
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions = sort(extensions)\
    \ # alphabetical sorting of extensions\n    \n    Strongest_Extension = extensions[1]\n\
    \    \n    Strongest_Extension = class_name + Strongest_Extension\n    \n    return\
    \ Strongest_Extension\n    \nend\n</cell>\n<code language=julia-1.6>\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n</cell>\n<text>\n(5pt)\
    \ Finding the strongest class by number of extensions\nComplete the function below\
    \ to find the strongest class by number of extensions.\nThis function should return\
    \ the name of the strongest class with maximum number of extensions:\nIf there\
    \ are multiple strongest classes, you should return the one which comes first\n\
    in the vector (for example [\"AA\", \"Be\", \"CC\"]) since 'AA' comes first in\
    \ this\nvector.\nIf the vector is empty, you should return an empty string.\n\
    If there are no strongest classes, you should be returned an empty string.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbuvonpei.jl:29\nin expression starting at\
    \ /tmp/tmpbuvonpei.jl:29\n"
  stdout: ''
  timestamp: 1660008767
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    str_ext = Strongest_Extension(class_name,\
    \ extensions, 0)\n    if str_ext ~= \"\"\n        return class_name._ + str_ext\n\
    \    else\n        return str_ext\n    end\nend\n</cell>\n<text>\nPart III. Challenge\n\
    Write a Julia function that returns the number of characters that should be added\
    \ to the name of the file that you are reading.\nIf the length of the file name\
    \ is less than or equal to the number of characters that should be added to the\
    \ name of the file, then your function should return an empty string.\nIf the\
    \ length of the file name is greater than the number \nof characters that should\
    \ be added to the name of the file, then your function should return a string\
    \ that contains only characters that should be added to the name of the file.\n\
    For example, if the length of the file name is 10, you should return a string\
    \ containing only the first 5 characters.\nIf the length of the file name equals\
    \ the number of characters that should be added to the name of the file, then\
    \ your function should return the original file name (no changes).\nIf the length\
    \ of the file name is not equal to the number of characters that should be added\
    \ to the name of the file, then your function should return the first 10 characters\
    \ of the file name (no changes).\nFor a sample run, see the following sample:\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8hwwl7ac.jl:27\nin expression starting at\
    \ /tmp/tmp8hwwl7ac.jl:27\n"
  stdout: ''
  timestamp: 1660008767
- exit_code: -1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: "test set: Error During Test at /tmp/tmpoaxqmzxp.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{String},\
    \ !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpoaxqmzxp.jl:21\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpoaxqmzxp.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpoaxqmzxp.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpoaxqmzxp.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{String},\
    \ !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpoaxqmzxp.jl:21\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/"
  timestamp: 1660008770
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n        \n    #Your code here\n    strength_map\
    \ = collect(extensions, (x->(length(x.uppercase) - length(x.lowercase))) \n  \
    \                          |> sort\n                            |> group_by(&identity)\n\
    \                            |> map((x->sort(x)[1])) \n                      \
    \      |> collect)\n    \n    for i in 1:length(extensions)\n        if strength_map[extensions[i]]\
    \ == length(extensions[i].lowercase)\n            return concat(class_name, \"\
    .\", extensions[i])\n        end\n    end\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpy3wc5v1m.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpy3wc5v1m.jl:1\n\
    in expression starting at /tmp/tmpy3wc5v1m.jl:1\n"
  stdout: ''
  timestamp: 1660008767
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n  \n    return class_name .. \".\" \n\
    \        \n    for extension in extensions \n        if length(extension) == length(class_name)\
    \ - length(extension)\n            if upper(extension) == upper(class_name)\n\
    \                return Strongest_Extension(class_name, extensions[1:])\n    \
    \        else \n                return Strongest_Extension(class_name, extensions)\n\
    \        end\n    end\nend\n</code>\n<|/ a dscore=0 tags=julia |>\n<| c |>\nThe\
    \ code you posted doesn't seem to work for the simple test case I used (I added\
    \ it to my original post)\n<|/ c |>\n<| c |>\nI updated my answer with your testcase\
    \ to show that it works. You did not provide an extension for `AA` so my code\
    \ returns the string `my_class.AA`\n<|/ c |>\n<| c |>\nIt works, thank you so\
    \ much! I noticed that the function I posted didn't work for the test case I used,\
    \ so I changed it to work with the new test case I posted (I added it to my original\
    \ post). Do you know why?\n<|/ c |>\n<| c |>\nI have updated the answer to take\
    \ into account your new case\n<|/ c |>\n<| c |>\nThank you so much! I noticed\
    \ that the function I posted didn't work for the test case I used, so I changed\
    \ it to work with the new test case I posted (I added it to my original post).\
    \ Do you know why? I added the new test case to the original post.\n<|/ c |>\n\
    <| a |>\nHere are two versions (one with regular expressions and one without).\n\
    The regular expression is used to extract the class name and the extension name.\
    \ The extension name is used as the second argument to find the first class with\
    \ the same extension, whose strength is positive. The two classes are then concatenated,\
    \ using the .. operator to concatenate the class name with the extension name.\n\
    The regular expressions also match \"empty\" strings, so the pattern [^.]+.\\\
    2 catches empty extensions as well.\n<code>\nusing Test\n\n@testset begin\n\n\
    candidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing last argument in \"1:\" range expression\
    \ \nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpz1l34usi.jl:25\nin expression\
    \ starting at /tmp/tmpz1l34usi.jl:25\n"
  stdout: ''
  timestamp: 1660008767
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n  \n    \n    \"\"\"\n    \n    Input:\
    \ class_name (string), extensions (vector of strings)\n    Output: Strongest extension\
    \ (string)\n    \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    Input: class_name\
    \ (string), extensions (vector of strings)\n    Output: Strongest extension (string)\n\
    \    \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    Input: class_name (string),\
    \ extensions (vector of strings)\n    Output: Strongest extension (string)\n \
    \   \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    Input: class_name (string),\
    \ extensions (vector of strings)\n    Output: Strongest extension (string)\n \
    \   \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    Input: class_name (string),\
    \ extensions (vector of strings)\n    Output: Strongest extension (string)\n \
    \   \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    Input: class_name (string),\
    \ extensions (vector of strings)\n    Output: Strongest extension (string)\n \
    \   \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    Input: class_name (string),\
    \ extensions (vector of strings)\n    Output: Strongest extension (string)\n \
    \   \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    Input: class_name (string),\
    \ extensions (vector of strings)\n    Output: Strongest extension (string)\n \
    \   \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    Input: class_name (string),\
    \ extensions (vector of strings)\n    Output: Strongest extension (string)\n \
    \   \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    Input: class_name (string),\
    \ extensions (vector of strings)\n    Output: Strongest extension (string)\n \
    \   \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    Input: class_name (string),\
    \ extensions (vector of strings)\n    Output: Strongest extension (string)\n \
    \   \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    Input: class_name (string),\
    \ extensions (vector of strings)\n    Output: Strongest extension (string)\n \
    \   \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    Input: class_name (string),\
    \ extensions (vector of strings)\n    Output: Strongest extension (string)\n \
    \   \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    Input: class_name (string),\
    \ extensions (vector of strings)\n    Output: Strongest extension (string)\n \
    \   \"\"\"\n    \n    \n    \n    \"\"\"\n    \n    Input: class_name (string),\
    \ extensions (vector of strings)\n    Output: Strongest extension (string)\n \
    \   \"\"\"\n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp9092ohdm.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp9092ohdm.jl:1\n\
    in expression starting at /tmp/tmp9092ohdm.jl:1\n"
  stdout: ''
  timestamp: 1660008767
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    if extensions == []\n      \
    \  return class_name\n    else\n        idx = 1\n        strength = -1\n     \
    \   while idx < length(extensions)\n            uppercase_letters_idx = findall(extensions[idx],\
    \ uppercase)\n            lowercase_letters_idx = findall(extensions[idx], lowercase)\n\
    \            \n            if (length(uppercase_letters_idx) == 0)\n         \
    \       return strcat(class_name, extensions[idx])\n            elseif (length(lowercase_letters_idx)\
    \ == 0)\n                return strcat(class_name, extensions[idx])\n        \
    \    elseif (length(uppercase_letters_idx) > length(lowercase_letters_idx))\n\
    \                idx = idx + 1\n            else\n                idx = idx -\
    \ 1\n            end\n        end\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\n    Strongest_Extension2(class_name::String, extensions::Vector{String})::String\
    \ \n    \n    More efficient version of Strongest_Extension.\n    \"\"\"\nusing\
    \ Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfr4dw0wa.jl:41\nin expression starting at\
    \ /tmp/tmpfr4dw0wa.jl:41\n"
  stdout: ''
  timestamp: 1660008767
- exit_code: -1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    sort!(extensions)\n  \
    \  \n    strongest = extensions[1]\n    \n    for e in extensions[2:length(extensions)-1]\n\
    \        if strongest < e\n            strongest = e\n        end\n    end\n \
    \   \n    return strongest + \".\" + class_name\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: Timeout
  stderr: ''
  stdout: "test set: Error During Test at /tmp/tmpdhsou2u5.jl:38\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  MethodError: no method matching +(::String, ::String)\n\
    \  Closest candidates are:\n    +(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n  Stacktrace:\n\
    \   [1] +(::String, ::String, ::String)\n     @ Base ./operators.jl:655\n   [2]\
    \ Strongest_Extension(class_name::String, extensions::Vector{String})\n     @\
    \ Main /tmp/tmpdhsou2u5.jl:31\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpdhsou2u5.jl:38 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpdhsou2u5.jl:37\ntest set:\
    \ Error During Test at /tmp/tmpdhsou2u5.jl:39\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  MethodError: no method matching +(::String, ::String)\n\
    \  Closest candidates are:\n    +(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n  Stacktrace:\n\
    \   [1] +(::String, ::String, ::String)\n     @ Base ./operators.jl:655\n   [2]\
    \ Strongest_Extension(class_name::String, extensions::Vector{String})\n     @\
    \ Main /tmp/tmpdhsou2u5.jl:31\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpdhsou2u5.jl:39 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpdhsou2u5.jl:37\ntest set:\
    \ Error During Test at /tmp/tmpdhsou2u5.jl:40\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  MethodError: no method matching\
    \ +(::String, ::Strin"
  timestamp: 1660008770
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \"\"\"\n    You will be given the\
    \ name of a class (a string) and a vector of extensions.\n    The extensions are\
    \ to be used to load additional classes to the class. The\n    strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n    letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n  \
    \  in the extension's name, the strength is given by the fraction CAP - SM. \n\
    \    You should find the strongest extension and return a string in this \n  \
    \  format: ClassName.StrongestExtensionName.\n    If there are two or more extensions\
    \ with the same strength, you should\n    choose the one that comes first in the\
    \ vector.\n    For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    \    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplhkiarym.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplhkiarym.jl:1\n\
    in expression starting at /tmp/tmplhkiarym.jl:1\n"
  stdout: ''
  timestamp: 1660008767
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \"\"\"\n    You will be given the\
    \ name of a class (a string) and a vector of extensions.\n    The extensions are\
    \ to be used to load additional classes to the class. The\n    strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n    letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n  \
    \  in the extension's name, the strength is given by the fraction CAP - SM. \n\
    \    You should find the strongest extension and return a string in this \n  \
    \  format: ClassName.StrongestExtensionName.\n    If there are two or more extensions\
    \ with the same strength, you should\n    choose the one that comes first in the\
    \ vector.\n    For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    \    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"\n    \n    \n   \
    \ sorted_extensions = sort!(extensions) \n    \n    strengths = []\n    for extension\
    \ in sorted_extensions \n        strengths.append(length(extension) - length(filter(x\
    \ -> x == upper(extension), lowers(extension)))) \n    end\n    \n    sort_strengths\
    \ = sort!(strengths)\n    \n    Strongest_Extension_name = find_first(x-> x <=\
    \ sort_strengths[1], SortedNot(sorted_extensions))\n    return join([\".\", class_name,\
    \ Strongest_Extension_name])\nend\n</cell>\n<code language=julia-1.5>\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n@test Strongest_Extension(\"\
    my_class\", [\"Be\", \"CC\", \"AA\"]) == \"my_class.Be\"\n</cell>\n<text>\nQuestion\
    \ 4\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpe2jv16l4.jl:51\nin expression starting at\
    \ /tmp/tmpe2jv16l4.jl:51\n"
  stdout: ''
  timestamp: 1660008767
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    maximum = extensions[length(extensions)]\n\
    \    maximum_index = length(extensions) \n    for extension in extensions \n \
    \       if strongest(extension) == maximum \n            maximum = extension \n\
    \            maximum_index = length(extensions)\n        end\n    end\n    return\
    \ string(class_name, \".\", maximum)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpqrp8lzq0.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpqrp8lzq0.jl:34\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: strongest not defined\n  Stacktrace:\n \
    \  [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n \
    \    @ Main /tmp/tmpqrp8lzq0.jl:22\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqrp8lzq0.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqrp8lzq0.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpqrp8lzq0.jl:35\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: strongest not defined\n  Stacktrace:\n\
    \   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpqrp8lzq0.jl:22\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqrp8lzq0.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqrp8lzq0.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpqrp8lzq0.jl:36\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  UndefVarError: strongest not\
    \ defined\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpqrp8lzq0.jl:22\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqrp8lzq0.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqrp8lzq0.jl:33\ntest set:"
  timestamp: 1660008769
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    S = sort(extensions)\n    if length(S)\
    \ > length(extensions)\n        return \"\"\n    else\n        return class_name\
    \ * (length(S) - length(extensions))\n    end\nend\n</cell>\n<code language=julia-1.6>\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n</cell>\n<text>\n\
    Exercise 1\nWrite a function that takes a vector of numbers and returns the number\
    \ of negative elements in the vector. Example: \n@test negative_numbers([-1, 1,\
    \ -2, 3, -4, -5]) == 2\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyuub464a.jl:26\nin expression starting at\
    \ /tmp/tmpyuub464a.jl:26\n"
  stdout: ''
  timestamp: 1660008767
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n\"\"\"\nYou will be given the name of\
    \ a class (a string) and a vector of extensions. \n    The extensions are to be\
    \ used to load additional classes to the class. \n    The strength of the extension\
    \ is as follows: Let CAP be the number of the \n    uppercase letters in the extension's\
    \ name, and let SM be the number of \n    lowercase letters in the extension's\
    \ name, the strength is given by the \n    fraction CAP - SM. You should find\
    \ the strongest extension and return a string \n    in this format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the \n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should return \n    'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension (its \n    strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n\"\"\"\nend\n</cell>\n<text>\nTest\nusing Test\n\n@testset\
    \ begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpsppm85dm.jl:38\nin expression starting at\
    \ /tmp/tmpsppm85dm.jl:38\n"
  stdout: ''
  timestamp: 1660008767
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    n = length(extensions)\n    Strongest_Extension_str\
    \ = join([\".\", class_name, Strongest_Extension_vec(extensions)[end]], \"\\n\"\
    )\n    return Strongest_Extension_str\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmppzy6z4dk.jl:25

    '
  stdout: "test set: Error During Test at /tmp/tmppzy6z4dk.jl:28\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: Strongest_Extension_vec not defined\n  Stacktrace:\n\
    \   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmppzy6z4dk.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmppzy6z4dk.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmppzy6z4dk.jl:27\ntest set:\
    \ Error During Test at /tmp/tmppzy6z4dk.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: Strongest_Extension_vec not defined\n\
    \  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmppzy6z4dk.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmppzy6z4dk.jl:29 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmppzy6z4dk.jl:27\ntest set:\
    \ Error During Test at /tmp/tmppzy6z4dk.jl:30\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  UndefVarError: Strongest_Extension_vec\
    \ not defined\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmppzy6z4dk.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmppzy6z4dk.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level sco"
  timestamp: 1660008769
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    extensions = sort(extensions)\n  \
    \  for e in extensions \n        if e[1...] == class_name\n            return\
    \ sprintf(\"%s.%s\", class_name, e)\n        end\n    end\n    error(\"No extension\
    \ with the class name found.\")\nend \nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpmub7465d.jl:29

    '
  stdout: "test set: Error During Test at /tmp/tmpmub7465d.jl:32\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  No extension with the class name found.\n  Stacktrace:\n\
    \   [1] error(s::String)\n     @ Base ./error.jl:33\n   [2] Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})\n     @ Main /tmp/tmpmub7465d.jl:25\n   [3] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpmub7465d.jl:32 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpmub7465d.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpmub7465d.jl:33\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  No extension with the class name found.\n  Stacktrace:\n\
    \   [1] error(s::String)\n     @ Base ./error.jl:33\n   [2] Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})\n     @ Main /tmp/tmpmub7465d.jl:25\n   [3] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpmub7465d.jl:33 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpmub7465d.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpmub7465d.jl:34\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  No extension with the class\
    \ name found.\n  Stacktrace:\n   [1] error(s::String)\n     @ Base ./error.jl:33\n\
    \   [2] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpmub7465d.jl:25\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpmub7465d.jl:34 [inlined]\n\
    \   [5] macro"
  timestamp: 1660008769
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    if length( extensions) < 1 then\n\
    \        error(\"You must supply at least one extension\")\n    end\nusing Test\n\
    \n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpgjbazaah.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpgjbazaah.jl:1\n\
    in expression starting at /tmp/tmpgjbazaah.jl:1\n"
  stdout: ''
  timestamp: 1660008767
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    if extensions.size <= 0\n        error(\"\
    No extensions given for class $class_name\")\n    end\nusing Test\n\n@testset\
    \ begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp9g55727h.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp9g55727h.jl:1\n\
    in expression starting at /tmp/tmp9g55727h.jl:1\n"
  stdout: ''
  timestamp: 1660008768
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    strongest = extensions[findfirst(x\
    \ -> x.end[1]>x.end[1], extensions)]\n    idx = findfirst(x -> x.end[1]>x.end[1],\
    \ extensions)\n    while idx != nothing\n        idx = findnext(idx -> x.end[1]>x.end[1],\
    \ extensions)\n        idx = findnext(idx -> x.end[1]>x.end[1], extensions, idx)\n\
    \        if idx == nothing\n            break\n        strongest = extensions.(idx)\n\
    \    end\n    return class_name.(strongest)\nend\n</code>\n<|/ a tags=julia dscore=2\
    \ |>\n<| c |>\nThanks Dan for your answer. Very helpful and useful. Although I\
    \ did not fully understand how your algorithm works, I tried it in my IDE and\
    \ it works flawlessly. However, I do not understand why it works this way. What\
    \ is the role of the \"findfirst\" function? Why does it find the smallest value\
    \ from the list?\n<|/ c |>\n<| c |>\nI added some comments to my answer to explain\
    \ what each part of the algorithm does.\n<|/ c |>\n<| a tags=julia |>\nHere's\
    \ a very simple way to do it that doesn't require you to write any code (apart\
    \ from the main function), but uses very simple and easy to understand syntax.\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3je9hhvm.jl:30\nin expression starting at\
    \ /tmp/tmp3je9hhvm.jl:30\n"
  stdout: ''
  timestamp: 1660008768
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    sorted_extensions = sort(extensions)\n\
    \    \n    maximum = length(extensions)\n    i = length(sorted_extensions)\n \
    \   while i < maximum do\n        j = maximum - i\n        if maximum == j ||\
    \ length(sorted_extensions) == j\n            i -= 1\n            continue\n \
    \       extension = sorted_extensions[j]\n        if i == 0\n            return\
    \ class_name\n        if length(extension) > length(sorted_extensions[i - 1])\n\
    \            return class_name\n        end\n        i -= 1\n    end\n    return\
    \ class_name\nend\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpn1coyiem.jl:23\nin expression starting at /tmp/tmpn1coyiem.jl:23\n"
  stdout: ''
  timestamp: 1660008768
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \nend\n</cell>\n<text>\nTest your\
    \ Code\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9ny49kqh.jl:21\nin expression starting at\
    \ /tmp/tmp9ny49kqh.jl:21\n"
  stdout: ''
  timestamp: 1660008768
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    # create two dictionaries to\
    \ hold the information of the extension\n    # name and the strength of the extension\n\
    \    name_extensions_map = Dict()\n    strength_extensions_map = Dict()\n    \n\
    \    # iterate through the extensions list\n    for extension in extensions\n\
    \        # get the extension name\n        extension_name = split(extension,\"\
    .\")[1]\n        # check if the extension name is already in the dictionary\n\
    \        if extension_name in name_extensions_map\n            # get the strength\
    \ of the extension\n            strength_extension = split(extension,\".\")[2]\n\
    \            # get the name which has the highest strength\n            max_name_extension\
    \ = max(name_extensions_map[extension_name])\n            # add the strength of\
    \ the extension with the name \n            # which has the highest strength\n\
    \            name_extensions_map[max_name_extension] = strength_extensions_map[extension_name]\
    \ + 1\n        else\n            # add the strength of the extension\n       \
    \     name_extensions_map[extension_name] = 1\n        end\n    end\n    # get\
    \ the key with the maximum strength value\n    max_strength_extension = max(strength_extensions_map.values)\n\
    \    # get the key with the minimum strength value\n    min_strength_extension\
    \ = min(strength_extensions_map.values)\n    # get the key with the highest number\
    \ of letters\n    highest_letters_extension = max(length(name_extensions_map[max_strength_extension]),\
    \ length(name_extensions_map[min_strength_extension]))\n    \n    # return the\
    \ extension\n    return class_name * highest_letters_extension + max_strength_extension\n\
    end\n</cell>\n<text>\nPart C: Extension Methods\nLet's use extension methods to\
    \ create an object that contains all the information of the two classes from before.\
    \ In addition to the methods already defined for the Vectors and Vecors, we have\
    \ defined an add_method method that creates an extension method for the Vectors\
    \ class and one for Vecors.\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_rvia0ua.jl:53\nin expression starting at\
    \ /tmp/tmp_rvia0ua.jl:53\n"
  stdout: ''
  timestamp: 1660008768
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n \n  extension =  extensions[upper(extensions)\
    \ - lower(extensions)]\n  \n  if length(extensions) > 1\n    strength =  length((upper(extensions)\
    \ - lower(extensions))) / length(extensions)\n    extension = extensions[upper(extensions)\
    \ - lower(extensions)] \n  else\n    strength = -1\n    extension = \"\" \n  end\n\
    \  return \"#{class_name}.#{extension}\" \nend\n</cell>\n<code language=julia-1.5>\n\
    # Test your function\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2yfc67xe.jl:31\nin expression starting at\
    \ /tmp/tmp2yfc67xe.jl:31\n"
  stdout: ''
  timestamp: 1660008768
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    strongest_extension = extensions[length(extensions)]\
    \ #pick the last element in the list\n    strongest_extension_strength = strongest_extension.count\
    \ {char(a) in strongest_extension} \n    strongest_extension_strength = strongest_extension_strength\
    \ - 1\n    return strongest_extension + Strongest_Extension(class_name, extensions[2:end])\
    \ #recurse\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\nThe second part of\
    \ this problem is to write a function that returns the extension of a \nstring\
    \ class (given by class_name) with the strongest extension strength. \nInput:\n\
    - class_name: a string containing the name of the class in the format: ClassName.\n\
    - extensions: a vector of strings containing the extensions to the class. \n \
    \ Each extension is in the format: ClassName.ExtensionName.\n  You should return\
    \ in the format: ClassName.StrongestExtensionName.\n- \nOutput:\n- a string containing\
    \ the extension of the class with the strongest extension\n  strength.\n- If there\
    \ are two or more extensions with the same strength, you should\n  choose the\
    \ one that comes first in the vector. \n  For example, if you are given \"Slices\"\
    \ as the class and a vector of\n  the extensions: ['SErviNGSliCes', 'Cheese',\
    \ 'StuFfed'] then you should \n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes'\
    \ is the strongest\n  extension (its strength is -1).\nExample: \n>>> Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"])\n\"my_class.AA\"\n\"\"\"\nusing Test\n\n\
    @testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: space before \"{\" not allowed in \"strongest_extension.count\
    \ {\" at /tmp/tmpjsa1rh63.jl:20\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpjsa1rh63.jl:20\n\
    in expression starting at /tmp/tmpjsa1rh63.jl:20\n"
  stdout: ''
  timestamp: 1660008768
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    length = maximum(map(length,\
    \ extensions)) + 1\n    \n    strength = -1\n    \n    for e in extensions do\n\
    \        if e.isupper() then\n            if strength > 0 \n                strength\
    \ = -1\n            end\n            if length(class_name) - length(e.upper) <\
    \ strength\n                strength = length(class_name) - length(e.upper)\n\
    \            end\n        end\n        if e.islower() then\n            if strength\
    \ > 0\n                strength = -1\n            end\n            if length(class_name)\
    \ - length(e.lower) < strength\n                strength = length(class_name)\
    \ - length(e.lower)\n            end\n        end\n    end\n    \n    if strength\
    \ == -1\n        error(\"Invalid extension\")\n    else\n        str = class_name\
    \ .. \".\" .. extensions[findmax(extensions, length)]\n    end\n    \n    return\
    \ str\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    Given a vector containing\
    \ the names of the classes, the vector of extensions,\n    and an integer of the\
    \ number of classes to be chosen, the function returns\n    a vector of class\
    \ names containing the classes with extensions that are\n    strongest for the\
    \ number of classes chosen.\n    For example, if you have chosen to choose two\
    \ classes, the function\n    would return a vector of two class names whose extensions\
    \ are strongest.\n    For example, if you have chosen to choose three classes,\
    \ the function\n    would return a vector of three class names whose extensions\
    \ are strongest.\n    Any other number would return a vector of all classes.\n\
    \    Example:\n    >>> get_classes_with_farthest_extension(\n            [\"my_class\"\
    , \"my_class\", \"my_class\"], [\"AA\", \"Be\", \"CC\"],\n            3)\n   \
    \ [\"my_class.CC\", \"my_class.Be\"]\n    \"\"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpe0w_f4vs.jl:24\nin expression starting at /tmp/tmpe0w_f4vs.jl:24\n"
  stdout: ''
  timestamp: 1660008768
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \nusing Test\n\
    \n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp6imtyqzf.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp6imtyqzf.jl:1\n\
    in expression starting at /tmp/tmp6imtyqzf.jl:1\n"
  stdout: ''
  timestamp: 1660008768
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    #find strongest extension\n\
    \    strength = -1\n    for e in extensions\n        if e != \"\"\n          \
    \  if e[1] == :lower(e[1:2])\n                strength += 1\n            else\n\
    \                strength -= 1\n        end \n    end\n    return strcat(class_name,\
    \ \".\", extensions[strength, 1]) \nend\n</cell>\n<text>\nProblem 4\nWrite a function,\
    \ Strongest_Extensions, that takes as input a vector of strings and returns a\
    \ vector of strings.\nThe function should return an array of strings in the following\
    \ format:\n    StrongestExtension(class_name::String, extensions::Vector{String})::String\n\
    The first string in the return vector should be the name of the class (a string).\
    \ The other \n    strings in the return vector should be the names of the strongest\
    \ extensions \n    (a vector of strings).\n    The function should return an array\
    \ of strings in the following format:\n        [StrongestExtension(class_name::String,\
    \ extensions::Vector{String})::String, ...]\nExamples:\n    >>> Strongest_Extensions([\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]])\n    [\"my_class.AA\", \"my_class.Be\"\
    , \"my_class.CC\"]\n    >>> Strongest_Extensions([\"my_class\", [\"AA\", \"Be\"\
    , \"CC\"], \"my_class\", [\"DD\", \"EE\", \"FF\"]])\n    [\"my_class.AA\", \"\
    my_class.Be\", \"my_class.CC\", \"my_class.DD\", \"my_class.EE\", \"my_class.FF\"\
    ]\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpavrqp3sz.jl:32\nin expression starting at\
    \ /tmp/tmpavrqp3sz.jl:32\n"
  stdout: ''
  timestamp: 1660008768
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    length = extensions.length\n\
    \    strongest_ext = \"\"\n    \n    if length == 1\n        \n        if contains(extensions,\
    \ class_name)\n            \n            if length(class_name) == length(extensions[0])\n\
    \                return class_name\n            else \n                length2\
    \ = length(extensions[1])\n                if length2 < length\n             \
    \       return class_name\n                else\n                    return class_name\
    \ + \"_\" + extensions[1]\n            end\n        else\n            return class_name\n\
    \        end\n    end\n    \n    \n    for e in extensions \n        \n      \
    \  if length2 == length\n            \n            if contains(extensions, e)\n\
    \                \n                if length(class_name) == length(extensions[0])\n\
    \                    return class_name\n                else \n              \
    \      length2 = length(extensions[1])\n                    if length2 < length\n\
    \                        return class_name\n                    else\n       \
    \                 return class_name + \"_\" + extensions[1]\n                \
    \    end\n                end\n            else\n                return class_name\n\
    \            end\n        else\n            \n            if length2 < length\n\
    \                strongest_ext = class_name + \"_\" + e\n                return\
    \ strongest_ext\n            else\n                length2 = length(extensions[1])\n\
    \                if length2 < length\n                    strongest_ext = class_name\
    \ + \"_\" + e\n                    return strongest_ext\n                else\n\
    \                    strongest_ext = class_name + \"_\" + e + \"_\" + extensions[1]\n\
    \                    return strongest_ext\n                end\n            end\n\
    \        end\n    end\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\nThe extension_strength\
    \ function finds the strongest extension in a class name \nand returns the extension\
    \ name. The strength of an extension is defined by \nthe fraction CAP - SM, where\
    \ CAP is the number of uppercase letters in the \nextension's name, SM is the\
    \ number of lowercase letters in the extension's \nname, and SM is the number\
    \ of lowercase letters in the extension's name. The\nusing Test\n\n@testset begin\n\
    \ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmptwolbef3.jl:27 expected \"\
    end\", got \"else\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmptwolbef3.jl:36\n\
    in expression starting at /tmp/tmptwolbef3.jl:36\n"
  stdout: ''
  timestamp: 1660008769
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    s = \"\"\n    for ext in extensions\n\
    \        if Strongest_Extension_Strength(class_name) == Strongest_Extension_Strength(ext)\n\
    \            s = ext # Found a better extension\n        end\n    end\n    \n\
    \    return s\nend\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpp7z9ykq6.jl:30

    '
  stdout: "test set: Error During Test at /tmp/tmpp7z9ykq6.jl:33\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: Strongest_Extension_Strength not defined\n\
    \  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpp7z9ykq6.jl:21\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpp7z9ykq6.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpp7z9ykq6.jl:32\ntest set:\
    \ Error During Test at /tmp/tmpp7z9ykq6.jl:34\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: Strongest_Extension_Strength not\
    \ defined\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpp7z9ykq6.jl:21\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpp7z9ykq6.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpp7z9ykq6.jl:32\ntest set:\
    \ Error During Test at /tmp/tmpp7z9ykq6.jl:35\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  UndefVarError: Strongest_Extension_Strength\
    \ not defined\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpp7z9ykq6.jl:21\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpp7z9ykq6.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5"
  timestamp: 1660008771
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    n = length(extensions)\n    if n <\
    \ 2 \n        return class_name\n    end\n    \n    s = length(upper(extensions))\n\
    \    if s > n\n        return class_name\n    end\n    \n    \n    for e in extensions\n\
    \        s = length(lower(e))\n        if s > n\n            return class_name\n\
    \        end\n    end\n    \n    \n    return strcat(class_name, extensions[findfirst(extensions,\
    \ s)])\nend\n</cell>\n<code language=julia-1.5>\n@time Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"])\n</cell>\n<text>\nQuestion 4.2\nWrite a\
    \ function called Load_Class that, given a class name and a vector of extensions\n\
    \    loads the extensions into the class. The name of each extension should be\
    \ \n    given in the following format: extension_name.extension.\n    The function\
    \ should return the newly loaded class.\n    Example:\n    >>> Load_Class(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0uxhq6ty.jl:40\nin expression starting at\
    \ /tmp/tmp0uxhq6ty.jl:40\n"
  stdout: ''
  timestamp: 1660008769
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    Strength_Vector = Vector{Int64}()\n\
    \    for extension in extensions \n        Strength_Vector[toupper(extension)-tolower(extension)]\
    \ = 1 \n    end\n    \n    Strength_Vector = sort(Strength_Vector)\n    Strength\
    \ = Strength_Vector[1]\n    \n    if length(Strength_Vector) > 1\n        \n \
    \       minimum = min(Strength_Vector)\n        minimum2 = minimum\n        \n\
    \        for element in Strength_Vector\n            if element == minimum\n \
    \               minimum2 =element \n            end\n        end\n        \n \
    \       \n        for element in Strength_Vector\n            if element == minimum2\n\
    \                minimum2 = element \n            end\n        end\n        \n\
    \        \n        Strength_Vector[Strength_Vector .!= minimum2] = minimum2 \n\
    \        \n    end\n    \n    \n    for element in Strength_Vector\n        \n\
    \        if element != minimum2\n            if element != minimum\n         \
    \       return concat!(class_name, \".\", minimum2)\n            else\n      \
    \          return concat!(class_name, \".\", minimum)\n            end\n     \
    \   else\n            return concat!(class_name, \".\", element)\n        end\n\
    \    end\n    \n    return \"no_extension\"\nend\n</cell>\n<text>\nLet's test\
    \ the function by writing a test first:\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7iuup93r.jl:67\nin expression starting at\
    \ /tmp/tmp7iuup93r.jl:67\n"
  stdout: ''
  timestamp: 1660008769
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \nend\nusing Test\n\n\
    @testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpgtd4vcom.jl:25

    '
  stdout: "test set: Error During Test at /tmp/tmpgtd4vcom.jl:28\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{String},\
    \ !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpgtd4vcom.jl:22\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpgtd4vcom.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpgtd4vcom.jl:27\ntest set:\
    \ Error During Test at /tmp/tmpgtd4vcom.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{String},\
    \ !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpgtd4vcom.jl:22\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/"
  timestamp: 1660008772
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \"\"\"Your task is to find the strongest\
    \ extension among the given extensions.\"\"\"\n    \n    extensions_set = Set{String}(extensions)\n\
    \    \n    strongest_extension = extensions_set[argmax(extensions_set)]\n    \n\
    \    return strongest_extension\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpoqv24tuz.jl:29

    '
  stdout: "test set: Error During Test at /tmp/tmpoqv24tuz.jl:32\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  MethodError: no method matching keys(::Set{String})\n \
    \ Closest candidates are:\n    keys(!Matched::GenericArray) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1823\n\
    \    keys(!Matched::Tuple) at ~/.conda/envs/polyglot/share/julia/base/tuple.jl:72\n\
    \    keys(!Matched::Tuple, !Matched::Tuple...) at ~/.conda/envs/polyglot/share/julia/base/tuple.jl:77\n\
    \    ...\n  Stacktrace:\n    [1] pairs(collection::Set{String})\n      @ Base\
    \ ./abstractdict.jl:138\n    [2] findmax(f::typeof(identity), domain::Set{String})\n\
    \      @ Base ./reduce.jl:803\n    [3] _findmax(a::Set{String}, #unused#::Colon)\n\
    \      @ Base ./reduce.jl:829\n    [4] findmax(itr::Set{String})\n      @ Base\
    \ ./reduce.jl:828\n    [5] argmax(itr::Set{String})\n      @ Base ./reduce.jl:938\n\
    \    [6] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \      @ Main /tmp/tmpoqv24tuz.jl:23\n    [7] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [8] macro expansion\n      @ /tmp/tmpoqv24tuz.jl:32 [inlined]\n\
    \    [9] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [10] top-level scope\n      @ /tmp/tmpoqv24tuz.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpoqv24tuz.jl:33\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  MethodError: no method matching keys(::Set{String})\n\
    \  Closest candidates are:\n    keys(!Matched::GenericArray) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1823\n\
    \    keys(!Matched::Tuple) at ~/.conda/envs/polyglot/share/julia/base/tuple.jl:72\n\
    \    keys(!Matched::Tuple, !Matched::Tuple...) at ~/.conda/envs/polyglot/share/julia/base/tuple.jl:77\n\
    \    ...\n  Stacktrace:\n    [1] pairs(collection::Set{String})\n      @ Base\
    \ ./abstractdict.jl:138\n    [2] findmax(f::typeof(iden"
  timestamp: 1660008772
- exit_code: -1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n  \n    str = join(extensions, '.')\n\
    \    strength = count(replace(str, lowercase(class_name)..., '_'), uppercase(class_name)...)\n\
    \    \n    if strength == length(extensions)\n        str = class_name\n    else\n\
    \        str = class_name + Strongest_Extension(lower!(class_name), extensions)\n\
    \    end\n    \n    return str\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: Timeout
  stderr: 'ERROR: '
  stdout: "test set: Error During Test at /tmp/tmp0cphfh7w.jl:36\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  MethodError: no method matching replace(::String, ::Char,\
    \ ::Char, ::Char, ::Char, ::Char, ::Char, ::Char, ::Char)\n  Closest candidates\
    \ are:\n    replace(!Matched::Union{Function, Type}, ::Any; count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmp0cphfh7w.jl:21\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0cphfh7w.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0cphfh7w.jl:35\ntest set:\
    \ Error During Test at /tmp/tmp0cphfh7w.jl:37\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  MethodError: no method matching replace(::String,\
    \ ::Char, ::Char, ::Char, ::Char, ::Char, ::Char, ::Char, ::Char)\n  Closest candidates\
    \ are:\n    replace(!Matched::Union{Function, Type}, ::Any; count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmp0cphfh7w.jl:21\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] ma"
  timestamp: 1660008773
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    extensions.sort!() \n    extensions.reverse!()\n\
    \    \n    Strongest_Extension = class_name \n    for ext in extensions\n    \
    \    if Strongest_Extension != ext\n            Strongest_Extension = class_name\
    \ + Strongest_Extension + ext\n            break\n    end\n    return Strongest_Extension\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpajz9bkp0.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpajz9bkp0.jl:1\n\
    in expression starting at /tmp/tmpajz9bkp0.jl:1\n"
  stdout: ''
  timestamp: 1660008770
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \"\"\"\n    Strongest_Extension(class_name,\
    \ extensions)\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp34jufnsc.jl:1\nin expression starting at /tmp/tmp34jufnsc.jl:1\n"
  stdout: ''
  timestamp: 1660008770
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    # Write your code here.\n  \
    \  \nend\n</cell>\n<code language=julia-1.5>\n@assert @isdefined Strongest_Extension\n\
    </cell>\n<code language=julia-1.5>\n# run this cell to test your code\n@testset\
    \ \"strongest_extension Test\" begin\n    test(Strongest_Extension)\nend\n</cell>\n\
    <text>\n3. Implement a function that will compute the total number of extensions\
    \ (strings) that belong to the class. Write a function extension_count, that takes\
    \ two arguments: a string class name and a list of extensions. You should return\
    \ a vector of integers. Each element of this vector should contain the number\
    \ of extensions that belong to the class represented by the string argument class_name,\
    \ e.g. \"my_class\" will return a vector of [3, 3] because there are 3 extensions\
    \ in the list [\"AA\", \"Be\", \"CC\"], 2 of them are \"AA\" and \"CC\".\nusing\
    \ Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqza44vrl.jl:23\nin expression starting at\
    \ /tmp/tmpqza44vrl.jl:23\n"
  stdout: ''
  timestamp: 1660008770
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    # Write your code here\n    # Write\
    \ your code here\n    \n    return extensions[length(extensions) div 2]\nend\n\
    </cell>\n<text>\nTask 3\nFor each of the following strings, return the length\
    \ of the longest extension, starting with the one that comes first.\nExamples:\n\
    \    String      Returned value\n    \"abc\"        2\n    \"bcd\"        1\n\
    \    \"abe\"        2\n    \"abc def\"    3\n    \"abc def gh\"   4\n    \"abcdef\"\
    \     5\n    \"aBcDeF\"     5\n    \"abc defg\"   5\n    \"ab def\"     5\n  \
    \  \"abc def g\"  5\n    \"abcdefg\"    5\n    \"abcdefg \"   5\n    \"abc defg\
    \ \" 5\n    \"abc def g\" 5\n    \"abc defg \" 5\n    \"abcdefg i\" 5\n    \"\
    abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\"\
    \ 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"\
    abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\"\
    \ 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"\
    abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\"\
    \ 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"\
    abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\"\
    \ 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"\
    abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\"\
    \ 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"\
    abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\"\
    \ 6\n    \"abcdefgh I\" 6\n    \"abcdefgh I\" 6\n    \"abcdefgh \nusing Test\n\
    \n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprxmndt3x.jl:24\nin expression starting at\
    \ /tmp/tmprxmndt3x.jl:24\n"
  stdout: ''
  timestamp: 1660008770
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    Strongest_Extension =\
    \ extensions[extensions[length] == length(extensions)] \nend\n</cell>\n<text>\n\
    Question 3\nImplement the method get_class_extension() below. It takes a class\
    \ name (a string) as input and returns the extension that is best suited for that\
    \ class.\nThe extension should be loaded from the extensions vector that you have\
    \ provided in the cell above (it is provided as a vector in cell 6).\nusing Test\n\
    \n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwb1sne0n.jl:23\nin expression starting at\
    \ /tmp/tmpwb1sne0n.jl:23\n"
  stdout: ''
  timestamp: 1660008770
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n\"\"\"\n    Strongest_Extension(class_name,\
    \ extensions)\n    \n    Write a function which returns the strongest extension\
    \ of a given \n    class. The name of a class is a string, the extensions are\
    \ to be used \n    as strings. The strength of the extension is as follows: Let\
    \ CAP be \n    the number of uppercase letters in the extension's name, and let\
    \ SM be \n    the number of lowercase letters in the extension's name, the strength\
    \ \n    is given by the fraction CAP - SM. You should find the strongest extension\n\
    \    and return a string in this format: ClassName.StrongestExtensionName.\n \
    \   If there are two or more extensions with the same strength, you should \n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the \n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest \n    extension (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n\"\"\"\n    return class_name * Strongest(extensions)\n\
    end \nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmp4nnacxzi.jl:43

    '
  stdout: "test set: Error During Test at /tmp/tmp4nnacxzi.jl:46\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: Strongest not defined\n  Stacktrace:\n \
    \  [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n \
    \    @ Main /tmp/tmp4nnacxzi.jl:39\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4nnacxzi.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4nnacxzi.jl:45\ntest set:\
    \ Error During Test at /tmp/tmp4nnacxzi.jl:47\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: Strongest not defined\n  Stacktrace:\n\
    \   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmp4nnacxzi.jl:39\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4nnacxzi.jl:47 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4nnacxzi.jl:45\ntest set:\
    \ Error During Test at /tmp/tmp4nnacxzi.jl:48\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  UndefVarError: Strongest not\
    \ defined\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmp4nnacxzi.jl:39\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4nnacxzi.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4nnacxzi.jl:45\ntest set:"
  timestamp: 1660008772
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    for i in extensions \n     \
    \   idx = find_first_index(extensions, i) \n        if idx != -1 \n          \
    \  if (extensions[idx] == i) \n                extensions[idx] = -1 \n       \
    \     else \n                extensions[idx] = i \n            end \n        end\
    \ \n    end\n    \n    if extensions.count > 0 \n        idx = find_first_index(extensions,\
    \ -1) \n        if idx != -1 \n            idx = extensions.count \n         \
    \   extensions[idx] = \"\" \n        end \n    end\n    \n    return class_name+\"\
    .\"+extensions[find_first_index(extensions, -1)]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmp04n9rqyz.jl:43

    '
  stdout: "test set: Error During Test at /tmp/tmp04n9rqyz.jl:46\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: find_first_index not defined\n  Stacktrace:\n\
    \   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmp04n9rqyz.jl:21\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp04n9rqyz.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp04n9rqyz.jl:45\ntest set:\
    \ Error During Test at /tmp/tmp04n9rqyz.jl:47\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: find_first_index not defined\n\
    \  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmp04n9rqyz.jl:21\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp04n9rqyz.jl:47 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp04n9rqyz.jl:45\ntest set:\
    \ Error During Test at /tmp/tmp04n9rqyz.jl:48\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  UndefVarError: find_first_index\
    \ not defined\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmp04n9rqyz.jl:21\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp04n9rqyz.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp04n"
  timestamp: 1660008772
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    map1=Dict(zip(extensions,map(1:length(extensions),extensions)))\n\
    \    map2=Dict(zip(map1.values,map(1:length(map1.values),map1.values)))\n    \n\
    \    \n    map3=Dict(zip(map1.values,map1.keys))\n    \n    for (k,v) in map3.values()\n\
    \        if map2[v] >map2[k]\n            map2[k]=v\n        else\n          \
    \  map2[v]=k\n        end\n    end\n    \n    \n    \n    map3=Dict(zip(map1.values,map(map2[v],map1.values)))\n\
    \    \n    for (k,v) in map3.values()\n        if map2[v] >map2[k]\n         \
    \   map2[k]=v\n        else\n            map2[v]=k\n        end\n    end\n   \
    \ \n    \n    strongest_extension=map3[max(map2.values())]\n    \n    return class_name+\"\
    .\"+strongest_extension\nend\n</cell>\n<code language=julia-1.5>\n#export\n\"\"\
    \"\n    Strength(name::String)\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnpy0f2nc.jl:51\nin expression starting at\
    \ /tmp/tmpnpy0f2nc.jl:51\n"
  stdout: ''
  timestamp: 1660008770
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    # define the extensions dictionary\n\
    \    extensions_dict = {}\n    for extension in extensions\n        # split the\
    \ extension into its lower and upper case letters\n        lower_extension = extension.toLowerCase()\n\
    \        upper_extension = extension.toUpperCase()\n        # check if the extension\
    \ is in the dictionary already\n        if lower_extension in extensions_dict\n\
    \            # increment the count for the extension\n            extensions_dict[lower_extension]\
    \ += 1\n        else\n            # add the extension to the dictionary\n    \
    \        extensions_dict[lower_extension] = 1\n    end\n    # define the strength\
    \ of a given extension\n    strength = length(extensions_dict)\n    # calculate\
    \ the strongest extension\n    strongest = \"\"\n    for key, value in extensions_dict\n\
    \        if value == strength\n            # save the strongest extension\n  \
    \          strongest = key\n        end\n    end\n    return class_name * \".\"\
    \ .* strongest \nend\n</cell>\n<text>\n3.3 Exercise: Finding Most Probable Errors\n\
    In a previous exercise, you loaded the data into a DataFrame:\nusing Test\n\n\
    @testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid iteration specification\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzcohn09u.jl:38\nin expression starting at\
    \ /tmp/tmpzcohn09u.jl:38\n"
  stdout: ''
  timestamp: 1660008770
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    extensions = sort(extensions)\n  \
    \  extension_strengths = zeros(length(extensions))\n    for (i,extension) in enumerate(extensions)\n\
    \        extension_strengths[i] = length(extension) - length(upper(extension))\n\
    \    end\n    \n    index = findall(extension_strengths .> 0)[1]\n    extension_strengths[index]\
    \ = -1\n    \n    return class_name*String(join(extensions,\".\"))\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpvf8pxs2k.jl:32

    '
  stdout: "test set: Error During Test at /tmp/tmpvf8pxs2k.jl:35\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: upper not defined\n  Stacktrace:\n   [1]\
    \ Strongest_Extension(class_name::String, extensions::Vector{String})\n     @\
    \ Main /tmp/tmpvf8pxs2k.jl:22\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvf8pxs2k.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvf8pxs2k.jl:34\ntest set:\
    \ Error During Test at /tmp/tmpvf8pxs2k.jl:36\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: upper not defined\n  Stacktrace:\n\
    \   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpvf8pxs2k.jl:22\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvf8pxs2k.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvf8pxs2k.jl:34\ntest set:\
    \ Error During Test at /tmp/tmpvf8pxs2k.jl:37\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  UndefVarError: upper not defined\n\
    \  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpvf8pxs2k.jl:22\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvf8pxs2k.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvf8pxs2k.jl:34\ntest set:\
    \ Error Durin"
  timestamp: 1660008773
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n\"\"\"\n    Extension name with strongest\
    \ extension\n\"\"\"\n    s_extension = extensions[findmin(extensions)]\n    return\
    \ strcat(class_name, s_extension)\nend\n</cell>\n<code language=julia-1.6>\n@test\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) \u2248 \"my_class.AA\"\
    \n@test Strongest_Extension(\"my_class\", [\"ab\", \"be\", \"cc\"]) \u2248 \"\
    my_class.ab\"\n@test Strongest_Extension(\"my_class\", [\"ab\", \"Be\", \"CC\"\
    ]) \u2248 \"my_class.Be\"\n@test Strongest_Extension(\"my_class\", [\"Ab\", \"\
    Be\", \"CC\"]) \u2248 \"my_class.Ab\"\n@test Strongest_Extension(\"my_class\"\
    , [\"ab\", \"Be\", \"cc\"]) \u2248 \"my_class.ab\"\n@test Strongest_Extension(\"\
    my_class\", [\"AB\", \"Be\", \"cc\"]) \u2248 \"my_class.AB\"\n@test Strongest_Extension(\"\
    my_class\", [\"ab\", \"be\", \"CC\"]) \u2248 \"my_class.ab\"\n@test Strongest_Extension(\"\
    my_class\", [\"ab\", \"Be\", \"cC\"]) \u2248 \"my_class.ab\"\n@test Strongest_Extension(\"\
    my_class\", [\"ab\", \"Be\", \"CC\"]) \u2248 \"my_class.AB\"\n@test Strongest_Extension(\"\
    my_class\", [\"AB\", \"Be\", \"cC\"]) \u2248 \"my_class.AB\"\n@test Strongest_Extension(\"\
    my_class\", [\"AB\", \"Be\", \"CC\"]) \u2248 \"my_class.AB\"\n@test Strongest_Extension(\"\
    my_class\", [\"Ab\", \"Be\", \"cC\"]) \u2248 \"my_class.AB\"\n@test Strongest_Extension(\"\
    my_class\", [\"ab\", \"Be\", \"CC\"]) \u2248 \"my_class.ab\"\n@test Strongest_Extension(\"\
    my_class\", [\"ab\", \"Be\", \"cC\"]) \u2248 \"my_class.ab\"\n@test Strongest_Extension(\"\
    my_class\", [\"Ab\", \"Be\", \"CC\"]) \u2248 \"my_class.Ab\"\n@test Strongest_Extension(\"\
    my_class\", [\"AB\", \"Be\", \"cC\"]) \u2248 \"my_class.AB\"\n@test Strongest_Extension(\"\
    my_class\", [\"AB\", \"Be\", \"CC\"]) \u2248 \"my_class.AB\"\n@test Strongest_Extension(\"\
    my_class\", [\"ab\", \"Be\", \"CC\"]) \uFFFD\nusing Test\n\n@testset begin\n\n\
    candidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppysva413.jl:25\nin expression starting at\
    \ /tmp/tmppysva413.jl:25\n"
  stdout: ''
  timestamp: 1660008771
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n  \n    strength_map=HashMap{Int, String}()\n\
    \    for i in 1:length(extensions)\n        strength_map[i+1] = extensions[i]\n\
    \    end\n    \n    for i in 1:length(class_name)\n        strength = strength_map[i+1]\n\
    \        if !(strength in strength_map)\n            strength = -1\n        end\n\
    \        class_name = strcat(class_name, strength_map[i+1] )\n    end\n    \n\
    \    return class_name\nend\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmp4bc_a7l7.jl:37

    '
  stdout: "test set: Error During Test at /tmp/tmp4bc_a7l7.jl:40\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: HashMap not defined\n  Stacktrace:\n   [1]\
    \ Strongest_Extension(class_name::String, extensions::Vector{String})\n     @\
    \ Main /tmp/tmp4bc_a7l7.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4bc_a7l7.jl:40 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4bc_a7l7.jl:39\ntest set:\
    \ Error During Test at /tmp/tmp4bc_a7l7.jl:41\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: HashMap not defined\n  Stacktrace:\n\
    \   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmp4bc_a7l7.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4bc_a7l7.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4bc_a7l7.jl:39\ntest set:\
    \ Error During Test at /tmp/tmp4bc_a7l7.jl:42\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  UndefVarError: HashMap not\
    \ defined\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmp4bc_a7l7.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4bc_a7l7.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4bc_a7l7.jl:39\ntest set:\
    \ Error"
  timestamp: 1660008773
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    strongest_extension = extensions[1]\n\
    \    for extension in extensions[2:length(extensions)]\n        if lowercase(extension)\
    \ == lowercase(strongest_extension)\n            strongest_extension = extension\n\
    \        end\n    end\n    return class_name * \".\" .* strongest_extension\n\
    end\n</cell>\n<text>\nQuestion 4\nNow implement a function called Strongest_Extensions\
    \ that takes a vector of extensions\n    (e.g. [\"AA\", \"Be\", \"CC\"]) and returns\
    \ the strongest extensions (e.g \"AA\")\n    in that order.\n    Example:\n  \
    \  >>> Strongest_Extensions([\"AA\", \"Be\", \"CC\"])\n    [\"AA\"]\n    \"\"\"\
    \nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6jh8v2w_.jl:27\nin expression starting at\
    \ /tmp/tmp6jh8v2w_.jl:27\n"
  stdout: ''
  timestamp: 1660008771
- exit_code: -1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    strength_sorted = sort(-extensions)\n\
    \    \n    strength_sorted_index = findfirst(x->x.name == strength_sorted[1],\
    \ extensions)\n    return class_name..\".\"..extensions[strength_sorted_index]\n\
    end \nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: Timeout
  stderr: ''
  stdout: "test set: Error During Test at /tmp/tmpa2xt0b2h.jl:29\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  MethodError: no method matching -(::String)\n  Closest\
    \ candidates are:\n    -(!Matched::Union{Int128, Int16, Int32, Int64, Int8, UInt128,\
    \ UInt16, UInt32, UInt64, UInt8}) at ~/.conda/envs/polyglot/share/julia/base/int.jl:85\n\
    \    -(!Matched::T, !Matched::T) where T<:Union{Int128, Int16, Int32, Int64, Int8,\
    \ UInt128, UInt16, UInt32, UInt64, UInt8} at ~/.conda/envs/polyglot/share/julia/base/int.jl:86\n\
    \    -(!Matched::Union{UInt16, UInt32, UInt64, UInt8}, !Matched::BigInt) at ~/.conda/envs/polyglot/share/julia/base/gmp.jl:532\n\
    \    ...\n  Stacktrace:\n    [1] _broadcast_getindex_evalf\n      @ ./broadcast.jl:670\
    \ [inlined]\n    [2] _broadcast_getindex\n      @ ./broadcast.jl:643 [inlined]\n\
    \    [3] getindex\n      @ ./broadcast.jl:597 [inlined]\n    [4] copy\n      @\
    \ ./broadcast.jl:899 [inlined]\n    [5] materialize\n      @ ./broadcast.jl:860\
    \ [inlined]\n    [6] broadcast_preserving_zero_d\n      @ ./broadcast.jl:849 [inlined]\n\
    \    [7] -\n      @ ./arraymath.jl:30 [inlined]\n    [8] Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})\n      @ Main /tmp/tmpa2xt0b2h.jl:19\n    [9] macro\
    \ expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [10] macro expansion\n      @ /tmp/tmpa2xt0b2h.jl:29 [inlined]\n\
    \   [11] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [12] top-level scope\n      @ /tmp/tmpa2xt0b2h.jl:28\ntest set:\
    \ Error During Test at /tmp/tmpa2xt0b2h.jl:30\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  MethodError: no method matching -(::String)\n\
    \  Closest candidates are:\n    -(!Matched::Union{Int128, Int16, Int32, Int64,\
    \ Int8, UInt128, UInt16, UInt32, UInt64, UInt8}) at ~/.conda/envs/polyglot/share/julia/base/int.jl:85\n\
    \    -(!Matched::T, !Matched::T) where T<:Union{Int128, Int16, "
  timestamp: 1660008774
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    StrongExtension(class_name, extensions)[1]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmp0l6xc7uy.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmp0l6xc7uy.jl:26\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: StrongExtension not defined\n  Stacktrace:\n\
    \   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmp0l6xc7uy.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0l6xc7uy.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0l6xc7uy.jl:25\ntest set:\
    \ Error During Test at /tmp/tmp0l6xc7uy.jl:27\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: StrongExtension not defined\n \
    \ Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmp0l6xc7uy.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0l6xc7uy.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0l6xc7uy.jl:25\ntest set:\
    \ Error During Test at /tmp/tmp0l6xc7uy.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  UndefVarError: StrongExtension\
    \ not defined\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmp0l6xc7uy.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0l6xc7uy.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0l6xc7"
  timestamp: 1660008773
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n\"\"\"\n    Using the\
    \ extensions, find the name of the class with the highest strength\n\"\"\"\nusing\
    \ Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpqhykmpm1.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpqhykmpm1.jl:1\n\
    in expression starting at /tmp/tmpqhykmpm1.jl:1\n"
  stdout: ''
  timestamp: 1660008771
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    ext::String = \"\"\n    \n \
    \   for ext in extensions \n        if (cap_count (ext) == strongest_count) (ext::String)\n\
    \    end\n    return class_name::String\nend\nusing Test\n\n@testset begin\n\n\
    candidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: space before \"(\" not allowed in \"cap_count\
    \ (\" at /tmp/tmpqaxyd15b.jl:23\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpqaxyd15b.jl:23\n\
    in expression starting at /tmp/tmpqaxyd15b.jl:23\n"
  stdout: ''
  timestamp: 1660008771
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n  \n    # your code goes here\nusing Test\n\
    \n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpn17ah4xg.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpn17ah4xg.jl:1\n\
    in expression starting at /tmp/tmpn17ah4xg.jl:1\n"
  stdout: ''
  timestamp: 1660008772
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    return class_name + Strongest_ExtensionName(extensions)\
    \ \nend \nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t\
    @test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpxx6kxpqo.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpxx6kxpqo.jl:26\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: Strongest_ExtensionName not defined\n  Stacktrace:\n\
    \   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpxx6kxpqo.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxx6kxpqo.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxx6kxpqo.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpxx6kxpqo.jl:27\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: Strongest_ExtensionName not defined\n\
    \  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpxx6kxpqo.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxx6kxpqo.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxx6kxpqo.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpxx6kxpqo.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  UndefVarError: Strongest_ExtensionName\
    \ not defined\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpxx6kxpqo.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxx6kxpqo.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level sco"
  timestamp: 1660008774
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    str_score = 0\n    for e in extensions\n\
    \        if e == class_name\n            str_score -= 1\n        elseif e == class_name\
    \ & lowercase(str_score) != lowercase(str_score) \n            str_score += 1\n\
    \        end\n    end\n    index = findall(extensions, e -> e == class_name &\
    \ lowercase(str_score) == lowercase(str_score))\n    str_score > 0 ? extensions[index[1]]\
    \ : \"\"\nend\n</cell>\n<text>\nQuestion 2.2\nWrite a function that returns the\
    \ class name and extension of any class in the extensions. \nThe extensions are\
    \ to be used to load additional classes to the class. \nThe strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp98lf2b0g.jl:30\nin expression starting at\
    \ /tmp/tmp98lf2b0g.jl:30\n"
  stdout: ''
  timestamp: 1660008772
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \"\"\"This function takes in an extension's\
    \ class name and vector extensions and returns the\n    extension with stronger\
    \ extension. \n    \"\"\"\n    \n    \n    # Initialize variables and set defaults\n\
    \    strength = 0\n    strongest_extension = \"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmptz1sckzt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmptz1sckzt.jl:1\n\
    in expression starting at /tmp/tmptz1sckzt.jl:1\n"
  stdout: ''
  timestamp: 1660008772
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \nend\n</cell>\n<code language=julia-0.6>\n\
    @testset \"Extension Tests\" begin\n    \n    @test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"]) \n    == \"my_class.AA\"\n    \n    @test Strongest_Extension(\"\
    my_class\", [\"Be\", \"AA\", \"CC\"]) \n    == \"my_class.Be\"\n    \n    @test\
    \ Strongest_Extension(\"my_class\", [\"CC\", \"AA\", \"Be\"]) \n    == \"my_class.CC\"\
    \n    \n    @test Strongest_Extension(\"my_class\", [\"CC\", \"Be\", \"AA\"])\
    \ \n    == \"my_class.CC\"\n    \n    @test Strongest_Extension(\"my_class\",\
    \ [\"CC\", \"AA\", \"Be\", \"GG\"]) \n    == \"my_class.CC\"\n    \n    @test\
    \ Strongest_Extension(\"my_class\", [\"CC\", \"GG\", \"AA\", \"Be\"]) \n    ==\
    \ \"my_class.CC\"\n    \n    @test Strongest_Extension(\"my_class\", [\"CC\",\
    \ \"GG\", \"Be\", \"AA\"]) \n    == \"my_class.CC\"\n    \n    @test Strongest_Extension(\"\
    my_class\", [\"CC\", \"GG\", \"Be\", \"CC\"]) \n    == \"my_class.CC\"\n    \n\
    \    @test Strongest_Extension(\"my_class\", [\"CC\", \"GG\", \"Be\", \"CC\",\
    \ \"AA\"]) \n    == \"my_class.CC\"\n    \n    @test Strongest_Extension(\"my_class\"\
    , [\"CC\", \"GG\", \"Be\", \"CC\", \"CC\"]) \n    == \"my_class.CC\"\n    \n \
    \   @test Strongest_Extension(\"my_class\", [\"CC\", \"GG\", \"Be\", \"CC\", \"\
    CC\", \"AA\"]) \n    == \"my_class.CC\"\n    \n    @test Strongest_Extension(\"\
    my_class\", [\"CC\", \"GG\", \"Be\", \"CC\", \"CC\", \"CC\"]) \n    == \"my_class.CC\"\
    \n    \n    @test Strongest_Extension(\"my_class\", [\"CC\", \"GG\", \"Be\", \"\
    CC\", \"CC\", \"CC\", \"AA\"]) \n    == \"my_class.CC\"\n    \n    @test Strongest_Extension(\"\
    my_class\", [\"CC\", \"GG\", \"Be\", \"CC\", \"CC\", \"CC\", \"CC\"]) \n    ==\
    \ \"my_class.CC\"\n    \n    @test Strongest_Extension(\"my_class\", [\"CC\",\
    \ \"GG\", \"Be\", \"CC\", \"CC\", \"CC\", \"CC\", \"AA\"]) \n    == \"my_class.CC\"\
    \n    \n    @test Strongest_Extension(\"my_class\", [\"CC\", \"GG\", \"Be\", \"\
    CC\", \"CC\", \"CC\", \"CC\", \"CC\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp354f18xt.jl:22\nin expression starting at\
    \ /tmp/tmp354f18xt.jl:22\n"
  stdout: ''
  timestamp: 1660008772
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \nend\n    \n    \n\"\"\"\n\
    \    \n    \n    \n    \n\"\"\"\n    \n    \n    \n    \n\"\"\"\n    \nusing Test\n\
    \n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmcaofuai.jl:34\nin expression starting at\
    \ /tmp/tmpmcaofuai.jl:34\n"
  stdout: ''
  timestamp: 1660008772
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    # Write your code here\n    \n   \
    \ return \"\"\nend \nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 9 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpwfycfdpm.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpwfycfdpm.jl:28\n  Expression: candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\n   Evaluated:\
    \ \"\" == \"Watashi.eIGHt8OKe\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwfycfdpm.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwfycfdpm.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpwfycfdpm.jl:29\n  Expression: candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\n   Evaluated:\
    \ \"\" == \"Boku123.YEs.WeCaNe\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwfycfdpm.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwfycfdpm.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpwfycfdpm.jl:30\n  Expression: candidate(\"__YESIMHERE\", [\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"\
    __YESIMHERE.NuLl__\"\n   Evaluated: \"\" == \"__YESIMHERE.NuLl__\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwfycfdpm.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwfycfdpm.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpwfycfdpm.jl:31\n  Expression: candidate(\"K\", [\"Ta\", \"\
    TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\n   Evaluated: \"\" == \"K.TAR\"\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwfycfdpm.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwfycfdpm.jl"
  timestamp: 1660008773
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    extension_strength = Vector{Int}(Int[],\
    \ 0)\n    for i in extensions\n        extension_strength[i] = isupper(i) - islower(i)\n\
    \    end\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t\
    @test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmphqd767sp.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmphqd767sp.jl:1\n\
    in expression starting at /tmp/tmphqd767sp.jl:1\n"
  stdout: ''
  timestamp: 1660008772
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    if length(extensions) == 0\n\
    \        throw(ArgumentError(\"The extensions vector should not be empty\"))\n\
    \    end\n    \n    exts = sort(extensions)\n    \n    ext_count = zeros(length(exts),2)\n\
    \    ext_count[:,1] = 1:length(exts)\n    \n    for i in exts\n        ext_count[i,1]\
    \ += 1\n    end\n    \n    sorted_extensions = sort!(ext_count)\n    \n    sorted_extensions\
    \ = reverse(sorted_extensions)\n    \n    sorted_extensions = sorted_extensions[2:end]\n\
    \    \n    sorted_exts = zeros(length(sorted_extensions),1)\n    \n    for i in\
    \ 1:length(sorted_extensions)\n        if sorted_extensions[i,1] == sorted_extensions[i-1,1]\n\
    \            sorted_exts[i,1] = sorted_extensions[i-1,1]\n        else\n     \
    \       sorted_exts[i,1] = sorted_extensions[i,1]\n        end\n    end\n    \n\
    \    if length(sorted_exts) > 0\n        extension_strength = sorted_exts[length(sorted_exts)]\n\
    \    else\n        extension_strength = -1\n    end\n    \n    \n    strongest_ext\
    \ = extensions[sorted_extensions[1,1]]\n    \n    return string(class_name)+\"\
    .\"+strongest_ext\nend\n</cell>\n<code language=julia-1.5>\nStrongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"])\n</cell>\n<text>\nWrite a function, Strongest_Extensions,\
    \ that takes two parameters: a string name\nand a vector of extensions. The function\
    \ should return a vector containing the\nnames of the strongest extensions in\
    \ the vector. \nFor instance:\n>>> Strongest_Extensions(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\"])\n[\"my_class.AA\", \"my_class.Be\", \"my_class.CC\"]\n</text>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcpn0ihns.jl:60\nin expression starting at\
    \ /tmp/tmpcpn0ihns.jl:60\n"
  stdout: ''
  timestamp: 1660008772
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    extension_strenght = [len(e) - 1 for\
    \ e in extensions]\n    extension_strength = sum(extension_strenght)\n    if extension_strength\
    \ > 0 \n        extension_strength \n    else\n        extension_strenght[argmax(extension_strenght)]\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpkc0cp6ze.jl:29

    '
  stdout: "test set: Error During Test at /tmp/tmpkc0cp6ze.jl:32\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: len not defined\n  Stacktrace:\n   [1] (::var\"\
    #1#2\")(e::String)\n     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47\
    \ [inlined]\n   [3] collect(itr::Base.Generator{Vector{String}, var\"#1#2\"})\n\
    \     @ Base ./array.jl:724\n   [4] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpkc0cp6ze.jl:19\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpkc0cp6ze.jl:32 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpkc0cp6ze.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpkc0cp6ze.jl:33\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: len not defined\n  Stacktrace:\n\
    \   [1] (::var\"#1#2\")(e::String)\n     @ Main ./none:0\n   [2] iterate\n   \
    \  @ ./generator.jl:47 [inlined]\n   [3] collect(itr::Base.Generator{Vector{String},\
    \ var\"#1#2\"})\n     @ Base ./array.jl:724\n   [4] Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})\n     @ Main /tmp/tmpkc0cp6ze.jl:19\n   [5] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpkc0cp6ze.jl:33 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpkc0cp6ze.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpkc0cp6ze.jl:34\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  UndefVarError: len not defined\n\
    \  Stacktrace:\n   [1] (::var\"#1#2\")(e::String)\n     @ Main ./none:0\n   [2]\
    \ iterate\n     @ ./generat"
  timestamp: 1660008775
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    for e in extensions \n        if uppercase(e)\
    \ - lowercase(e) < length(class_name) - length(replace(e, '_', '')) \n       \
    \     return stringcat(class_name, e) \n        end \n    end\nend\n</cell>\n\
    <code language=julia-1.0>\n@assert @test_cases Strongest_Extension(\"Slice\",\
    \ [\"ABSli\", \"CCSli\", \"DD\"]) \u2248 \"Slices.ABSli\"\n@assert @test_cases\
    \ Strongest_Extension(\"Slice\", [\"ABSli\", \"CCSli\", \"DD\"]) \u2248 \"Slices.CCSli\"\
    \n@assert @test_cases Strongest_Extension(\"Slice\", [\"ABSli\", \"CCSli\", \"\
    DD\"]) \u2248 \"Slices.DD\"\n@assert @test_cases Strongest_Extension(\"Slice\"\
    , [\"ABSli\", \"CCSli\", \"DD\"]) \u2248 \"Slices.ABSli\"\n@assert @test_cases\
    \ Strongest_Extension(\"Slice\", [\"ABSli\", \"CCSli\", \"DD\"]) \u2248 \"Slices.ABSli\"\
    \n</cell>\n<text>\nPart 6: Implementing The Adjacent Rule\nusing Test\n\n@testset\
    \ begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid empty character literal\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5em4lpaw.jl:20\nin expression starting at\
    \ /tmp/tmp5em4lpaw.jl:20\n"
  stdout: ''
  timestamp: 1660008772
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    for ext in extensions \n        if\
    \ lower(ext) \u2209 lower(class_name) \n            return class_name .. \".\"\
    \ .. ext \n    else \n        return class_name \nend\n</cell>\n<code language=julia-1.3>\n\
    # TEST STRONGEST EXTENSION (5) (TO DO: FIND SOME TESTS)\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n</cell>\n<text>\nExercise\
    \ 4\nWrite a function that returns a vector of tuples (class_name, extension_strength).\n\
    The tuples should be of the form: (class_name, extension_strength). For example,\
    \ if\nthe given class is \"Slices\" and extensions are [\"SErviNGSliCes\", \"\
    Cheese\", \"StuFfed\"]\nthen the function should return a vector of tuples\n[(\"\
    Slices\", -1), (\"Slices\", 1), (\"Slices\", -1)]\nExample: \n>>> Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]) == [(\"Slices\", -1), (\"Slices\", 1), (\"\
    Slices\", -1)]\n[ (Slices,-1) (Slices, 1) (Slices, -1)]\n\"\"\"\nusing Test\n\n\
    @testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9g_ocfv5.jl:25\nin expression starting at\
    \ /tmp/tmp9g_ocfv5.jl:25\n"
  stdout: ''
  timestamp: 1660008772
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    l = length(extensions)\n    \n   \
    \ stext=String[]\n    for i =1:length(extensions)\n        stext[i] = class_name..\"\
    .\"..extensions[i]\n    end\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"for\" at /tmp/tmpo4z7jnh0.jl:22 expected \"\
    end\", got \"..\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpo4z7jnh0.jl:23\n\
    in expression starting at /tmp/tmpo4z7jnh0.jl:23\n"
  stdout: ''
  timestamp: 1660008773
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    strongest_extension = extensions[findfirst(a\
    \ => a > 0, map(x => toupper(x) - tolower(x), extensions))]\n    \"$class_name.$strongest_extension\"\
    \nend\n</code>\n<|/ a |>\n<| c |>\nThanks for the help. I was looking at the `findfirst`\
    \ method but I was having difficulty finding documentation on how it worked. I\
    \ was confused about the syntax and how the function works. \nusing Test\n\n@testset\
    \ begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzktrx9z_.jl:22\nin expression starting at\
    \ /tmp/tmpzktrx9z_.jl:22\n"
  stdout: ''
  timestamp: 1660008773
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n  \n  num_upper = length(findall(x ->\
    \ isupper(x), extensions))\n  num_lower = length(findall(x -> islower(x), extensions))\n\
    \  \n  if num_upper - num_lower <= 0 \n    # all extensions are lower case or\
    \ all extensions are upper case\n    Strongest_Extension = class_name\n  elseif\
    \ num_upper == 0\n    # all extensions are upper case\n    Strongest_Extension\
    \ = class_name \n  else\n    # some extensions are upper case, some are lower\
    \ case\n    Strongest_Extension = strcat(class_name, Strongest_Extension(extensions[num_upper],\
    \ extensions[num_lower]))\n  end\n  return Strongest_Extension\nend\n</cell>\n\
    <text>\nLet's test out our function on the three examples you provided.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9xp6q2op.jl:35\nin expression starting at\
    \ /tmp/tmp9xp6q2op.jl:35\n"
  stdout: ''
  timestamp: 1660008774
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    # Write your code here\n   \
    \ \n    return \"\"\nend\n</cell>\n<text>\nSolution\nRun the cell below to check\
    \ your solution.\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbxvmhs7g.jl:24\nin expression starting at\
    \ /tmp/tmpbxvmhs7g.jl:24\n"
  stdout: ''
  timestamp: 1660008774
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    strength = zeros(Int, length(extensions))\n\
    \    for i = 1:length(extensions)\n        pos = findfirst(isupper(extensions[i]),\
    \ tolower(extensions[i]))\n        \n        if pos == nothing\n            error(\"\
    Extension name does not follow the pattern: CAPS\")\n        elseif pos != length(extensions[i])\n\
    \            error(\"Extension name does not follow the pattern: CAPS\")\n   \
    \     end\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t\
    @test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"for\" at /tmp/tmpcij73s88.jl:21\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpcij73s88.jl:1\n\
    in expression starting at /tmp/tmpcij73s88.jl:1\n"
  stdout: ''
  timestamp: 1660008774
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = 0\n   \
    \ \n    for i in 1:length(extensions)\n        \n        # split the extension\
    \ in lowercase letters\n        lowercase_extension = split(extensions[i])[1]\n\
    \        \n        # split the class name\n        lowercase_class_name = split(class_name)[1]\n\
    \        \n        # obtain the number of uppercase letters\n        uppercase_letters\
    \ = count(lowercase_extension)\n        \n        # obtain the number of lowercase\
    \ letters\n        lowercase_letters = count(lowercase_extension, lowercase_letters)\n\
    \        \n        # obtain the number of letters in the extension's name\n  \
    \      extension_letters = count(lowercase_extension)\n        \n        # obtain\
    \ the strength of the extension\n        strength = uppercase_letters - lowercase_letters\n\
    \        \n        # check if an extension is with the same strength\n       \
    \ if(extension_strength == 0)\n            extension_strength = strength\n   \
    \     elseif(extension_strength != strength)\n            \n            # find\
    \ the extension with more letters first\n            if(extension_strength > strength)\n\
    \                extension_strength = extension_strength\n            else\n \
    \               extension_strength = strength\n        end\n    end\n    \n  \
    \  # return the class name with the strongest extension\n    str = split(class_name)[1]\n\
    \    return str .concat(\".\") .concat(extension_strength)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: space before \".\" not allowed in \"str .\" at\
    \ /tmp/tmp50oetx05.jl:57\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp50oetx05.jl:57\n\
    in expression starting at /tmp/tmp50oetx05.jl:57\n"
  stdout: ''
  timestamp: 1660008774
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    if length(extensions)<1\n\
    \        error(\"No extensions to load to class with name '$class_name'\")\n \
    \   end\n    \n    extension_class=join(extensions,\".\")\n    \n    \n    \n\
    \    #Find a Strongest extension\nusing Test\n\n@testset begin\n\ncandidate =\
    \ Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpzif_479i.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpzif_479i.jl:1\n\
    in expression starting at /tmp/tmpzif_479i.jl:1\n"
  stdout: ''
  timestamp: 1660008774
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    Strongest_Extension_Helper(class_name,\
    \ extensions, 0)\nend\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpm01n7xm1.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpm01n7xm1.jl:26\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: Strongest_Extension_Helper not defined\n\
    \  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpm01n7xm1.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpm01n7xm1.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpm01n7xm1.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpm01n7xm1.jl:27\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: Strongest_Extension_Helper not\
    \ defined\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpm01n7xm1.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpm01n7xm1.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpm01n7xm1.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpm01n7xm1.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  UndefVarError: Strongest_Extension_Helper\
    \ not defined\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpm01n7xm1.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpm01n7xm1.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-"
  timestamp: 1660008776
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    Strongest_Extension_Helper(class_name,\
    \ extensions)\nend\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpchtnu8s2.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpchtnu8s2.jl:26\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: Strongest_Extension_Helper not defined\n\
    \  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpchtnu8s2.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpchtnu8s2.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpchtnu8s2.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpchtnu8s2.jl:27\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: Strongest_Extension_Helper not\
    \ defined\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpchtnu8s2.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpchtnu8s2.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpchtnu8s2.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpchtnu8s2.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  UndefVarError: Strongest_Extension_Helper\
    \ not defined\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpchtnu8s2.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpchtnu8s2.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-"
  timestamp: 1660008776
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n  \n  strongest_extension_index  = argmax(\
    \ lengths(extensions) )\n  strongest_extension        = extensions[strongest_extension_index]\n\
    \  strongest_extension_strength = length(strongest_extension)\n  \n  return \"\
    $class_name.$strongest_extension_strength\" \nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpatgxd6qk.jl:26\nin expression starting at\
    \ /tmp/tmpatgxd6qk.jl:26\n"
  stdout: ''
  timestamp: 1660008774
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    if extensions.is_empty\n\
    \        return class_name\n    end\n    \n    \n    Strength = 0\n    for extn\
    \ in extensions\n        Strength += length(extn)\n    end\n    \n    \n    if\
    \ Strength == 0\n        return class_name\n    end\n    \n    \n    if Strength\
    \ == 1\n        return extensions[1]\n    end\n    \n    \n    if Strength > length(extensions)\n\
    \        return class_name\n    end\n    \n    \n    \n    \n    \n    \n    \n\
    \    for extn in extensions\n        if startswith(extn, class_name)\n       \
    \     return class_name\n        end\n    end\n    \nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmp_qs_tpb0.jl:61

    '
  stdout: "test set: Error During Test at /tmp/tmp_qs_tpb0.jl:64\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  type Array has no field is_empty\n  Stacktrace:\n   [1]\
    \ getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})\n     @ Main /tmp/tmp_qs_tpb0.jl:21\n   [3] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp_qs_tpb0.jl:64 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp_qs_tpb0.jl:63\ntest set:\
    \ Error During Test at /tmp/tmp_qs_tpb0.jl:65\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  type Array has no field is_empty\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})\n     @ Main /tmp/tmp_qs_tpb0.jl:21\n   [3] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp_qs_tpb0.jl:65 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp_qs_tpb0.jl:63\ntest set:\
    \ Error During Test at /tmp/tmp_qs_tpb0.jl:66\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  type Array has no field is_empty\n\
    \  Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})\n     @ Main /tmp/tmp_qs_tpb0.jl:21\n   [3] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp_qs_tpb0.jl:66 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.con"
  timestamp: 1660008776
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    strongest, strongest_strength\
    \ = 0, -1 #initialize strongest and strongest_strength to default values\n   \
    \ strongest_strength =  -1\n    for e in extensions #loop through all extensions\
    \ to get strongest strength \n        if e == Strongest(class_name) #if the extension\
    \ is the strongest \n            strongest_strength = Strongest(class_name)\n\
    \            strongest = e\n        else #if extensions strength isn't the strongest\
    \ \n            if Strongest(class_name) != strongest_strength #if the extensions\
    \ strength is strongest \n                strongest_strength = Strongest(class_name)\n\
    \                strongest = e #reset the strongest to its current value\n   \
    \         else #if extensions strength is not the strongest \n               \
    \ if Strongest(class_name) < strongest_strength #if the extensions strength is\
    \ lower \n                    strongest_strength = Strongest(class_name) #set\
    \ the strongest strength to the current extension\n                    strongest\
    \ = e #set the strongest to its current extension\n    end\n    return strongest\
    \ #return string in above format\nend\n</cell>\n<code language=julia-1.0>\n@time\
    \ strongest_extension = Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"\
    CC\"])\n</cell>\n<code language=julia-1.0>\nstrongest_extension\n</cell>\n<code\
    \ language=julia-1.0>\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpe6dhxur2.jl:37\nin expression starting at\
    \ /tmp/tmpe6dhxur2.jl:37\n"
  stdout: ''
  timestamp: 1660008774
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    str = strcat(name, Strongest_Extension_name(extensions))\
    \ \n    if any(str==x for (x \u2208 extensions)) \n            then  \n      \
    \  str = strcat(class_name, Strongest_Extension_name(extensions)) \n    end\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid iteration specification\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9qzw_uj1.jl:21\nin expression starting at\
    \ /tmp/tmp9qzw_uj1.jl:21\n"
  stdout: ''
  timestamp: 1660008774
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp0iuay14a.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp0iuay14a.jl:1\n\
    in expression starting at /tmp/tmp0iuay14a.jl:1\n"
  stdout: ''
  timestamp: 1660008774
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    if extensions == []\n        return\
    \ class_name\n    else\n        sorted = sort(extensions, by = x -> length(x)-length(x));\n\
    \        sorted_extensions = copy(sorted);\n        strength = -1;\n        strength_index\
    \ = 0;\n        for i in sorted do \n            if i == extensions[strength_index]\
    \ \n                strength = strength_index\n            else\n            \
    \    strength_index = strength_index + 1\n            end\n        end\n     \
    \   return class_name + \".\" + sorted_extensions[strength]\n    end\nend\n</cell>\n\
    <code language=julia-1.4>\n\"\"\"\n    TestExamples()\n    Tests the Strongest_Extension\
    \ function using various test cases\n    \n    Parameters: \n    None\n    \n\
    \    Returns:\n    None\n    \n    Remarks:\n    Prints the given test cases one-by-one\
    \ to the screen and verifies the correct \n    answer\n    \n    Usage: \n   \
    \ TestExamples()\n\"\"\"\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp_duq3z65.jl:26\nin expression starting at /tmp/tmp_duq3z65.jl:26\n"
  stdout: ''
  timestamp: 1660008774
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    Strongest_Extension(class_name,\
    \ extensions, 0)\nend\n</cell>\n<code language=julia-1.5>\n# TEST STRONGEST EXTENSION\
    \ (188)\nTest.assertEquals(Strongest_Extension(\"my_class\", [\"AA\", \"Be\",\
    \ \"CC\"]), \"my_class.AA\", \"incorrect result\")\nTest.assertEquals(Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]), \"my_class.Be\", \"incorrect result\")\n\
    Test.assertEquals(Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]),\
    \ \"my_class.CC\", \"incorrect result\")\n</cell>\n<text>\nPart III. FINDING STRONGEST\
    \ EXTENSION IN A BLOCK OF EXTENSIONS\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvst_ylno.jl:22\nin expression starting at\
    \ /tmp/tmpvst_ylno.jl:22\n"
  stdout: ''
  timestamp: 1660008774
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n  \n    #Initializing the StrongestExtensions\
    \ vector\n    StrongestExtensions = Set()\n    \n    for Extension in extensions\
    \ \n        \n        #Split the string and take the first letter of the split\
    \ string\n        ExtensionNameSplit = split(Extension,\".\")\n        \n    \
    \    #Get the number of uppercase letters in the Extension Name\n        CAP =\
    \ length( findall(\"[A-Z]\", ExtensionNameSplit) )\n        \n        #Get the\
    \ number of lowercase letters in the Extension Name\n        SM = length( findall(\"\
    [a-z]\", ExtensionNameSplit) )\n        \n        #Get the fraction of the CAP\
    \ - SM\n        StrongestExtension = CAP - SM\n        \n        #If there is\
    \ another extension with the same strongest strength than the new one then \n\
    \        #insert it in the StrongestExtensions vector in the order given by the\
    \ vector\n        if isin(StrongestExtension, StrongestExtensions)\n        \n\
    \            #Insert it at the end\n            StrongestExtensions = StrongestExtensions.insert(length(StrongestExtensions),StrongestExtension)\n\
    \        else\n            #Otherwise insert it at the beginning\n           \
    \ StrongestExtensions = StrongestExtensions.insert(1,StrongestExtension)\n   \
    \     end\n    end\n    \n    #Create the StrongestExtension String using the\
    \ class_name and the StrongestExtensions vector\n    StrongestExtensionString\
    \ = join(class_name, StrongestExtensions)\n    \n    return StrongestExtensionString\n\
    end\n</cell>\n<text>\nExpected Output:\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcztcaxxp.jl:54\nin expression starting at\
    \ /tmp/tmpcztcaxxp.jl:54\n"
  stdout: ''
  timestamp: 1660008775
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    s = \"\"\n    cap = 0\n    sm\
    \ = 0\n    \n    for ext in extensions do\n        cap = cap + length(ext) - length(lowerfirst(ext))\n\
    \        sm = sm + length(ext) - length(lowerfirst(ext))\n    end\n    \n    if\
    \ cap == 0 or sm == 0 then\n        return class_name\n    end\n    \n    strength\
    \ = (cap - sm) / (cap)\n    for ext in extensions do\n        if strength >= length(ext)\
    \ - length(lowerfirst(ext)) then\n            return class_name + '.' + ext\n\
    \        end\n    end\n    \nend\n</cell>\n<code language=julia-0.4>\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"D\"]) == \"my_class.Be\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"D\", \"e\"]) == \"my_class.CC\"\n@test\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"D\", \"e\", \"\
    g\"]) == \"my_class.CC\"\n@test Strongest_Extension(\"my_class\", [\"AA\", \"\
    Be\", \"CC\", \"D\", \"e\", \"g\", \"h\"]) == \"my_class.CC\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"D\", \"e\", \"g\", \"h\", \"i\"]) == \"\
    my_class.CC\"\n@test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    , \"D\", \"e\", \"g\", \"h\", \"i\", \"j\"]) == \"my_class.CC\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"D\", \"e\", \"g\", \"h\", \"i\", \"j\"\
    , \"k\"]) == \"my_class.CC\"\n@test Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"D\", \"e\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\"]) ==\
    \ \"my_class.CC\"\n@test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"\
    CC\", \"D\", \"e\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"]) == \"my_class.CC\"\
    \n@test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"D\", \"e\"\
    , \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"]) == \"my_class.CC\"\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"D\", \"e\"\
    , \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"\nusing Test\n\n@testset begin\n\
    \ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp_swgs4h7.jl:24\nin expression starting at /tmp/tmp_swgs4h7.jl:24\n"
  stdout: ''
  timestamp: 1660008775
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n        strengths = Vector{String}(undef,\
    \ length(extensions))\n        for e in extensions\n            pos = filter(x\
    \ -> x.isupper(), e)\n            pos = filter(x -> x.islower(), pos)\n      \
    \      pos = map(x -> toupper(x), pos)\n            strength = length(pos) - length(setdiff(pos,\
    \ lowercase(pos)))\n            strengths[end] = sprintf(\"%s.%s\", class_name,\
    \ e)\n        end\n        \n        pop_idx = sort(collect(1:length(strengths)),\
    \ by = x -> strengths[x])\n        best_strength = pop_idx[end]\n        best_extension\
    \ = extensions[best_strength]\n        return sprintf(\"%s.%s\", class_name, best_extension)\n\
    end\n</cell>\n<code language=julia-1.0>\n@testset \"STRONG EXTENSIONS\" begin\n\
    \    examples = [\n        Strongest_Extension(\"my_class\", [\"AA\", \"Be\",\
    \ \"CC\"]),\n        Strongest_Extension(\"my_class\", [\"aA\", \"Be\", \"CC\"\
    ]),\n        Strongest_Extension(\"my_class\", [\"Aa\", \"Be\", \"CC\"]),\n  \
    \      Strongest_Extension(\"my_class\", [\"Aa\", \"Bb\", \"CC\"])\n    ]\n  \
    \  for e in examples\n        @test Strongest_Extension(\"my_class\", [e...])\
    \ isa String\n    end\nend\n</cell>\n<text>\n3. Implement Strongly_Connected\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpczws3u12.jl:33\nin expression starting at\
    \ /tmp/tmpczws3u12.jl:33\n"
  stdout: ''
  timestamp: 1660008775
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    len_class = length(class_name)\n\
    \    \n    if len_class > length(extensions)\n        error(\"Class name too long\"\
    )\n    end\n    \n    len_extension = length(extensions[1])\n    \n    if len_extension\
    \ < 1\n        error(\"No extensions\")\n    end\n    \n    len_extension = len_extension\
    \ - 1\n    \n    extension_strength = zeros(len_extension)\n    \n    for extension\
    \ in extensions\n        len_extension = length(extension)\n        \n       \
    \ if len_extension > len_extension_strength\n            error(\"Extension is\
    \ too long\")\n        end\n        \n        extension_strength[len_extension]\
    \ = \n            if len_extension == len_extension_strength\n               \
    \ -1\n            else\n                ((len_extension - len_extension_strength)\n\
    \                    / len_extension_strength)\n            end\n    end\n   \
    \ \n    index = findall(extension_strength == max(extension_strength))\n    \n\
    \    str = class_name\n    for index in index\n        str = str.replaceall(extensions[index],\
    \ \"\")\n    end\n    \n    str\nend\n</cell>\n<text>\nProblem 3\nThe method should\
    \ be able to work with any number of classes and extensions.\nYou will be given\
    \ the name of a class (a string) and a vector of extensions as strings. \nThe\
    \ method should return a string in this format: ClassName.StrongestExtensionName.\n\
    For example, if you have the following class name and extensions:\n'my_class'\n\
    'SErviNGSliCes'\n'Cheese'\n'StuFfed'\nand the following extensions:\n'AA'\n'Be'\n\
    'CC'\n'DD'\n'EE'\n'FF'\n'GG'\n'HH'\nthe method should return 'my_class.SErviNGSliCes'.\n\
    You should find the strongest extension and return a string in this \nformat:\
    \ ClassName.StrongestExtensionName.\nFor this problem, you know that there are\
    \ only uppercase letters.\nFor example, the following class name and extensions\
    \ should return a string:\n'Slices'\n'A'\n'B'\n'C'\n'D'\n'E'\n'F'\n'G'\n'H'\n\
    'I'\n'J'\n'K'\n'L'\n'M'\n'N'\n'O'\n'P'\n'Q'\n'R'\n'S'\n'T'\n'U'\n'V'\n'W'\n'X'\n\
    'Y'\n'Z'\nIn this case you should return 'Slices.A'.\nusing Test\n\n@testset begin\n\
    \ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptjwnud6p.jl:61\nin expression starting at\
    \ /tmp/tmptjwnud6p.jl:61\n"
  stdout: ''
  timestamp: 1660008775
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    extension_strength = extension_count\
    \ = max_strength = -1\n    for ext in extensions\n        ext_length = length(ext)\n\
    \        if ext_length != 0\n            ext_count = lowercase(ext)\n        \
    \    ext_count -= 1\n            if ext_strength > max_strength\n            \
    \    max_strength = ext_strength\n            elseif ext_count == 0\n        \
    \        extension_count = ext_length\n                extension_strength = ext_strength\n\
    \            else\n                extension_strength = ext_strength\n       \
    \         extension_count = ext_count\n            end\n        end\n    end\n\
    \    strongest_ext = \"\"\n    if max_strength != -1\n        strongest_ext =\
    \ \".\" + uppercase(class_name) + uppercase(String(max_strength - extension_count))\n\
    \    elseif extension_count == 0\n        return class_name\n    else\n      \
    \  return class_name + Strongest_Extension(lowercase(extensions[end]), extensions[end-1:end])\n\
    \    end\nend\n</cell>\n<text>\nProblem 8: Sort By Probability\nImplement function\
    \ sort_by_probability, which sorts a given list of objects, according to a probability.\n\
    The probability of an element appearing in the list should range between [0, 1],\
    \ and is equal to the probability the element appears in the list.\nThe function\
    \ should return the sorted list of objects.\nThe sorting algorithm should go through\
    \ each object, one at a time, and for each element, \nyou should update the probability\
    \ of each element that appears in the list accordingly. \nYou will need to store\
    \ the objects and their corresponding probabilities in a data structure.\nFor\
    \ example, if the list is as follows:\n \n [ Cat(\"Pello\", 0.3), Dog(\"Curly\"\
    , 0.3), Dog(\"Poodle\", 0.3), Cat(\"Curly\", 0.3) ] \nusing Test\n\n@testset begin\n\
    \ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpl1agawjr.jl:45\nin expression starting at\
    \ /tmp/tmpl1agawjr.jl:45\n"
  stdout: ''
  timestamp: 1660008775
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions = sort(extensions)\n\
    \    \n    stength = length(extensions)\n    \n    if stength == 1 return class_name\n\
    \    \n    str = Strongest_Extension(class_name, extensions[1:stength])\n    \n\
    \    if length(extensions[stength+1:]) == 1 \n        return str .. \".\" .. extensions[stength+1]\n\
    \    else\n        str = str\n        for ix in extensions[stength+1:end]\n  \
    \          str = str .. \".\" .. extensions[ix]\n        end\n        return str\n\
    \    end\nend\n</cell>\n<text>\nLet's test our function with the two examples\
    \ we gave earlier:\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing last argument in \"(stength + 1):\" range\
    \ expression \nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp42lovz7z.jl:28\n\
    in expression starting at /tmp/tmp42lovz7z.jl:28\n"
  stdout: ''
  timestamp: 1660008775
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    str_extensions = sort(extensions)\
    \ |> join\n    \n    strengths = countmap(str_extensions) |> collect\n    \n \
    \   strongest_ext = [x for x in extensions if x in strengths][-1]\n    \n    class_name+\"\
    .\"+strongest_ext\nend\n</cell>\n<text>\nNow we will see how to write the main\
    \ function. This function will take as input two strings: class_name and extensions.\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvskq2w7w.jl:28\nin expression starting at\
    \ /tmp/tmpvskq2w7w.jl:28\n"
  stdout: ''
  timestamp: 1660008775
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    if extensions.length == 0 \n     \
    \   return \"no extensions\"\n    \n    cap = sum(map(x -> isupper(x) ? length(x)\
    \ : 0, extensions))\n    sm = sum(map(x -> islower(x) ? length(x) : 0, extensions))\n\
    \    strength = cap - sm\n    \n    if length(extensions) ==1 \n        return\
    \ \"#{class_name}.#{extensions[0]}\"\n    \n    i = findfirst(isequal(strength),\
    \ extensions)\n    if isequal(strength, -1) || i == length(extensions) \n    \
    \    return \"#{class_name}.#{extensions[i]}\"\n    elseif i == 1 \n        return\
    \ \"#{class_name}.#{extensions[1]}\"\n    else\n        return \"#{class_name}.#{extensions[i]}\"\
    \n    end\nend\n</cell>\n<text>\n(IMPLEMENTATION) Test Your Solution\nusing Test\n\
    \n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvrficy_b.jl:38\nin expression starting at\
    \ /tmp/tmpvrficy_b.jl:38\n"
  stdout: ''
  timestamp: 1660008776
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    if extensions <= 1 \n        return\
    \ class_name\n    else \n        strength = extension_counts(extensions)[2]/extension_counts(extensions)[1]\n\
    \        i = search(extensions, strength)\n        if i \n            return class_name+\"\
    .\"+extensions[i]\n        else \n            error(\"No strongest extension found\"\
    )\n    end\nend\n</cell>\n<code language=julia-1.5>\n@testset \"Strongest_Extension\"\
    \ begin\n    Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\nend\n\
    </cell>\n<text>\nYou will be given the name of the class and some extensions.\
    \ The main aim of the function is to find the strongest extension and return it\
    \ in the form ClassName.StrongestExtensionName.\nusing Test\n\n@testset begin\n\
    \ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7emtdeum.jl:30\nin expression starting at\
    \ /tmp/tmp7emtdeum.jl:30\n"
  stdout: ''
  timestamp: 1660008775
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    extensions = sort(extensions)\n  \
    \  l = length(extensions)\n    if l <= 1\n        return class_name\n    end\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpsr73vahf.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpsr73vahf.jl:1\n\
    in expression starting at /tmp/tmpsr73vahf.jl:1\n"
  stdout: ''
  timestamp: 1660008776
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \"\"\"\n    Strongest_Extension(class_name,\
    \ extensions)\n    \n    Input: Strings class_name and extensions, where extensions\
    \ is a vector of\n    strings containing names of additional classes. Return String\
    \ in this\n    format: class_name.StrongestExtensionName. \n    If there are two\
    \ or more extensions with the same strength, you should\n    choose the one that\
    \ comes first in the vector.\n    For example, if you are given \"Slices\" as\
    \ the class and a vector of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed']\
    \ then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is\
    \ the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"\n    \n\
    \    extensions_count = length(extensions)\n    \n    for i=1:extensions_count\n\
    \        if length(findall(lowercase(extensions[i]), class_name)) > 0 \n     \
    \       strength = length(findall(lowercase(extensions[i]), class_name))/length(extensions[i])\n\
    \        else\n            strength = -1\n        end\n        \n        if strength\
    \ > max_strength \n            max_strength = strength\n            strongest_extension\
    \ = extensions[i]\n        else\n            break\n        end\n    end\n   \
    \ \n    strongest_extension = replace(strongest_extension, \" \", \"\")\n    strongest_extension\
    \ = replace(strongest_extension, \".\", \"\")\n    return strongest_extension\n\
    end\n</cell>\n<code language=julia-1.6>\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n</cell>\n<code language=julia-1.6>\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbmqshkmz.jl:57\nin expression starting at\
    \ /tmp/tmpbmqshkmz.jl:57\n"
  stdout: ''
  timestamp: 1660008776
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    if length([x for x in extensions if\
    \ length(x.upper) == length(x.lower)]) == 0 \n        return class_name\n    cap_len\
    \ = length([x for x in extensions if length(x.upper) == 1])\n    sm = length([x\
    \ for x in extensions if length(x.lower) == 1])\n    \n    if cap_len == sm\n\
    \        return class_name\n    \n    if cap_len < sm\n        index_of_cap =\
    \ indexOf(cap_len,extensions)\n        return class_name.substring(0,index_of_cap+1)\
    \ + extensions[index_of_cap+1]\n    else\n        index_of_sm = indexOf(sm,extensions)\n\
    \        return class_name.substring(0,index_of_sm+1) + extensions[index_of_sm+1]\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptfekjrfh.jl:1\nin expression starting at /tmp/tmptfekjrfh.jl:1\n"
  stdout: ''
  timestamp: 1660008776
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n  strongest, strength = extension_strength(extensions)\n\
    \  \n  strongest_extension = strongest\n  if strength == -1\n      strongest_extension\
    \ = extension_first(extensions)\n  end\n  return strongest_extension\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmp6bzvqcpu.jl:29

    '
  stdout: "test set: Error During Test at /tmp/tmp6bzvqcpu.jl:32\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: extension_strength not defined\n  Stacktrace:\n\
    \   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmp6bzvqcpu.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6bzvqcpu.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6bzvqcpu.jl:31\ntest set:\
    \ Error During Test at /tmp/tmp6bzvqcpu.jl:33\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: extension_strength not defined\n\
    \  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmp6bzvqcpu.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6bzvqcpu.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6bzvqcpu.jl:31\ntest set:\
    \ Error During Test at /tmp/tmp6bzvqcpu.jl:34\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  UndefVarError: extension_strength\
    \ not defined\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmp6bzvqcpu.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6bzvqcpu.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/"
  timestamp: 1660008778
- exit_code: -1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n  \n    strengh_ext=0\n    name_with_strengh=\"\
    \"\n    for ext in extensions\n        name_with_strengh=name_with_strengh+\"\
    .\"+ext\n        if str_to_lower(name_with_strengh)==str_to_lower(class_name)\n\
    \            strengh_ext=-1*strengh_ext\n        else\n            strengh_ext=strengh_ext+1\n\
    \        end\n    end\n    for ext in extensions\n        if str_to_lower(name_with_strengh)==str_to_lower(class_name)\n\
    \            name_with_strengh=name_with_strengh+\".\"+ext\n        else\n   \
    \         name_with_strengh=name_with_strengh+\"_\"+ext\n        end\n    end\n\
    \    name_with_strengh=str_to_lower(name_with_strengh)\n    return name_with_strengh\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: Timeout
  stderr: ''
  stdout: "test set: Error During Test at /tmp/tmpn4pymu2b.jl:45\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  MethodError: no method matching +(::String, ::String)\n\
    \  Closest candidates are:\n    +(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n  Stacktrace:\n\
    \   [1] +(::String, ::String, ::String)\n     @ Base ./operators.jl:655\n   [2]\
    \ Strongest_Extension(class_name::String, extensions::Vector{String})\n     @\
    \ Main /tmp/tmpn4pymu2b.jl:23\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpn4pymu2b.jl:45 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpn4pymu2b.jl:44\ntest set:\
    \ Error During Test at /tmp/tmpn4pymu2b.jl:46\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  MethodError: no method matching +(::String, ::String)\n\
    \  Closest candidates are:\n    +(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n  Stacktrace:\n\
    \   [1] +(::String, ::String, ::String)\n     @ Base ./operators.jl:655\n   [2]\
    \ Strongest_Extension(class_name::String, extensions::Vector{String})\n     @\
    \ Main /tmp/tmpn4pymu2b.jl:23\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpn4pymu2b.jl:46 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpn4pymu2b.jl:44\ntest set:\
    \ Error During Test at /tmp/tmpn4pymu2b.jl:47\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  MethodError: no method matching\
    \ +(::String, ::Strin"
  timestamp: 1660008779
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    extensions_sorted = sort(extensions)\n\
    \    strongest_extension = extensions_sorted[1]\n    \n    for extension in extensions_sorted[2:end]\n\
    \        if extensions_sorted[extensions_sorted.index(extension) - 1] > strongest_extension\n\
    \            strongest_extension = extension\n        end\n    end\n    \n   \
    \ return Str(class_name) + strongest_extension\nend\n</cell>\n<code language=julia-0.6>\n\
    using Test\n@test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\
    \ \u2248 \"my_class.AA\"\n@test Strongest_Extension(\"my_class\", [\"BB\", \"\
    C\", \"DD\"]) \u2248 \"my_class.BB\"\n@test Strongest_Extension(\"my_class\",\
    \ [\"AAA\", \"DD\", \"C\"]) \u2248 \"my_class.AAA\"\n@test Strongest_Extension(\"\
    my_class\", [\"C\", \"CC\", \"DD\"]) \u2248 \"my_class.CC\"\n@test Strongest_Extension(\"\
    my_class\", [\"D\", \"D\", \"DD\"]) \u2248 \"my_class.D\"\n@test Strongest_Extension(\"\
    my_class\", [\"D\", \"DD\", \"D\"]) \u2248 \"my_class.D\"\n@test Strongest_Extension(\"\
    my_class\", [\"D\", \"DD\", \"D\"]) \u2248 \"my_class.D\"\n@test Strongest_Extension(\"\
    my_class\", [\"D\", \"DD\", \"D\"]) \u2248 \"my_class.D\"\n@test Strongest_Extension(\"\
    my_class\", [\"D\", \"DD\", \"D\"]) \u2248 \"my_class.D\"\n@test Strongest_Extension(\"\
    my_class\", [\"D\", \"DD\", \"D\"]) \u2248 \"my_class.D\"\n@test Strongest_Extension(\"\
    my_class\", [\"D\", \"DD\", \"D\"]) \u2248 \"my_class.D\"\n@test Strongest_Extension(\"\
    my_class\", [\"D\", \"DD\", \"D\"]) \u2248 \"my_class.D\"\n@test Strongest_Extension(\"\
    my_class\", [\"D\", \"DD\", \"D\"]) \u2248 \"my_class.D\"\n@test Strongest_Extension(\"\
    my_class\", [\"D\", \"DD\", \"D\"]) \u2248 \"my_class.D\"\n@test Strongest_Extension(\"\
    my_class\", [\"D\", \"DD\", \"D\"]) \u2248 \"my_class.D\"\n@test Strongest_Extension(\"\
    my_class\", [\"D\", \"DD\", \"D\"]) \u2248 \"my_class.D\"\n@test Strongest_Extension(\"\
    my_\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6n6ujud6.jl:30\nin expression starting at\
    \ /tmp/tmp6n6ujud6.jl:30\n"
  stdout: ''
  timestamp: 1660008776
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    number_of_unique_extensions\
    \ = length(unique(extensions))\n    \n    if number_of_unique_extensions > 1 \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \nusing\
    \ Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpv0ko9fjo.jl:1\nin expression starting at /tmp/tmpv0ko9fjo.jl:1\n"
  stdout: ''
  timestamp: 1660008776
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    Extension_Strength = []\n  \
    \  \n    for i in extensions\n        \n        if contains(uppercase(i), class_name)\
    \ == false \n            continue\n            \n        for j in uppercase(i)\n\
    \            \n            if contains(lowercase(j), class_name) == false \n \
    \               continue\n            \n            if contains(lowercase(j),\
    \ i) == false \n                continue\n            \n            if strongest(lowercase(j),\
    \ lowercase(i)) > Extension_Strength[length(Extension_Strength)+1]\n         \
    \       Extension_Strength = [lowercase(j), lowercase(i)]\n            end\n \
    \       end\n    end\n    \n    if length(Extension_Strength) == 0 \n        return\
    \ class_name\n    end\n    \n    \n    \n    return strcat(class_name,\".\",join(Extension_Strength))\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjyuy20yx.jl:1\nin expression starting at /tmp/tmpjyuy20yx.jl:1\n"
  stdout: ''
  timestamp: 1660008776
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    for e in extensions\n        if isupper(e)\n\
    \            return class_name .. \".\" .. e\n        end\n    end\nend\n</cell>\n\
    <code language=julia-0.6>\n@code_warntype Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\"])\n</cell>\n<text>\nQ. Write a function which returns a string\
    \ in the format ClassName+StrongestExtensionName\nwhere ClassName is a string\
    \ in the form class_name.\nFor example:\n    > \"my_class.AA\"\n    > \"my_class.Be\"\
    \n    > \"my_class.CC\"\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmputen8lxt.jl:25\nin expression starting at\
    \ /tmp/tmputen8lxt.jl:25\n"
  stdout: ''
  timestamp: 1660008776
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    s = \"\"\n    for e in extensions\n\
    \        s = s .. \".\" .. e\n    end\n    \n    \n    if length(extensions)==0\n\
    \        return s\n    end\n    \n    i = 0\n    while i+1<length(extensions)\n\
    \        if s[end] in uppercase(extensions[i])\n            i = i + 1\n      \
    \  elseif s[end] in lowercase(extensions[i])\n            i = i + 1\n        elseif\
    \ s[end] in uppercase(extensions[i])\n            i = i + 1\n        elseif s[end]\
    \ in lowercase(extensions[i])\n            i = i + 1\n        elseif s[end] in\
    \ uppercase(extensions[i])\n            i = i + 1\n        elseif s[end] in lowercase(extensions[i])\n\
    \            i = i + 1\n        end\n    end\n    \n    if i == length(extensions)\n\
    \        return s\n    end\n    \n    \n    \n    if s[end] in uppercase(extensions[i])\n\
    \        return s .. \".\" .. extensions[i]\n    end\n    \n    if s[end] in lowercase(extensions[i])\n\
    \        return s .. \".\" .. extensions[i]\n    end\n    \n    if s[end] in uppercase(extensions[i])\n\
    \        return s .. \".\" .. extensions[i]\n    end\n    \n    if s[end] in lowercase(extensions[i])\n\
    \        return s .. \".\" .. extensions[i]\n    end\n    \n    return s\n   \
    \ \nend\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t\
    @test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"for\" at /tmp/tmp7y7fm3n9.jl:20 expected \"\
    end\", got \"..\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp7y7fm3n9.jl:21\n\
    in expression starting at /tmp/tmp7y7fm3n9.jl:21\n"
  stdout: ''
  timestamp: 1660008776
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions = extensions[2:end]\n\
    \    \n    \n    cap_len = length(extensions[2:end])\n    strongest_extension_strength\
    \ = -1\n    \n    for i in 2:cap_len\n        \n        sm = 0\n        \n   \
    \     for j in 2:cap_len\n            \n            if upper(extensions[j])==upper(extensions[j+1])\n\
    \                sm += 1\n            \n        end\n        \n        if strongest_extension_strength\
    \ == -1 || strongest_extension_strength > sm/cap_len\n            strongest_extension_strength\
    \ = sm/cap_len\n        end\n    end\n    \n    return join([\".\",class_name,\"\
    .\",join(extensions[2:end])],\".\")\nend\n</cell>\n<code language=julia-1.0>\n\
    @assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DE\", \"\
    FG\"]) == \"my_class.CC\"\n@assert Strongest_Extension(\"my_class\", [\"AA\",\
    \ \"Be\", \"CC\", \"DE\", \"FG\", \"HI\"]) == \"my_class.FG\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DE\", \"FG\", \"HI\", \"JK\", \"LM\"])\
    \ == \"my_class.HI\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DE\", \"FG\", \"HI\", \"JK\", \"LM\", \"OP\"]) == \"my_class.JK\"\n\
    @assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DE\", \"\
    FG\", \"HI\", \"JK\", \"LM\", \"OP\", \"PP\"]) == \"my_class.LM\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DE\", \"FG\", \"HI\", \"JK\", \"LM\", \"\
    OP\", \"PP\", \"QQ\"]) == \"my_class.OP\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DE\", \"FG\", \"HI\", \"JK\", \"LM\", \"OP\", \"\
    PP\", \"QQ\", \"RR\"]) == \"my_class.PP\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DE\", \"FG\", \"HI\", \"JK\", \"LM\", \"OP\", \"\
    PP\", \"QQ\", \"RR\", \"SS\"]) == \"my_class.QQ\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DE\", \"FG\", \"HI\", \"JK\", \"LM\", \"\
    OP\", \"PP\", \"QQ\", \"RR\", \"SS\", \"TT\"]) == \"my_class.RR\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5sxe2k33.jl:44\nin expression starting at\
    \ /tmp/tmp5sxe2k33.jl:44\n"
  stdout: ''
  timestamp: 1660008776
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    str_extensions = Vector{String}()\n\
    \    for ext in extensions \n        str_extensions.push(StrongestExtension(ext))\n\
    \    end\n    idx = findfirst(x -> x == class_name, str_extensions)\n    if idx\
    \ != -1 \n        return class_name[idx : length(class_name) + length(extensions[idx])]\n\
    \    else\n        error(\"class %s has no extensions named %s!\" % (class_name,\
    \ extensions))\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmp34r5ok7u.jl:32

    '
  stdout: "test set: Error During Test at /tmp/tmp34r5ok7u.jl:35\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  type Array has no field push\n  Stacktrace:\n   [1] getproperty\n\
    \     @ ./Base.jl:42 [inlined]\n   [2] Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})\n     @ Main /tmp/tmp34r5ok7u.jl:21\n   [3] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp34r5ok7u.jl:35 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp34r5ok7u.jl:34\ntest set:\
    \ Error During Test at /tmp/tmp34r5ok7u.jl:36\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  type Array has no field push\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})\n     @ Main /tmp/tmp34r5ok7u.jl:21\n   [3] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp34r5ok7u.jl:36 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp34r5ok7u.jl:34\ntest set:\
    \ Error During Test at /tmp/tmp34r5ok7u.jl:37\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  type Array has no field push\n\
    \  Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})\n     @ Main /tmp/tmp34r5ok7u.jl:21\n   [3] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp34r5ok7u.jl:37 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/poly"
  timestamp: 1660008779
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    ext_hash=Dict{String,Int}()\
    \ #store the extension strength by their names\n    for e in extensions\n    \
    \    ext_hash[e] = length(filter(x -> x isupper e,class_name))-length(filter(x\
    \ -> x islower,e))\n    end\n    \n    Strongest_Extension_1=find_key(ext_hash,minimum(ext_hash.values))\
    \ #find the strongest extension\n    return Strongest_Extension_1 #return the\
    \ strongest extension name\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqfqrj06d.jl:22\nin expression starting at\
    \ /tmp/tmpqfqrj06d.jl:22\n"
  stdout: ''
  timestamp: 1660008777
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    Strongest = extensions[1..end]\n\
    \    Strongest.sort!\n    Strongest = Strongest[1]\n    \n    return class_name\
    \ .+ \".\" * string(Strongest)\nend\n</cell>\n<code language=julia-1.3>\n@test\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n</cell>\n<text>\nYour next task is to rewrite the function with input from STDIN.\
    \ The input will be a single line consisting of the class name followed by a vector\
    \ of extensions. You can assume that the class is correctly spelled and contains\
    \ at least one extension. \nThe function should then return a string in the following\
    \ format: ClassName.StrongestExtensionName. \nThe extensions are to be used to\
    \ load additional classes to the class. You can assume that the class is correctly\
    \ spelled and contains at least one extension.\nYou can assume that the extension\
    \ is correct.\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpseucls6t.jl:26\nin expression starting at\
    \ /tmp/tmpseucls6t.jl:26\n"
  stdout: ''
  timestamp: 1660008777
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \"\"\"\n    Strongest_Extension finds\
    \ the strongest extension given a string of class \n    name and a vector of extensions.\n\
    \    The extensions are to be used to load additional classes to the class. The\n\
    \    strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    \    letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n    in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n    You should find the strongest extension and return a string in this \n\
    \    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions\
    \ with the same strength, you should\n    choose the one that comes first in the\
    \ vector.\n    For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    \    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"\n  \n# Write your\
    \ code below this line *******************************************\nusing Test\n\
    \n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpzcho_4ub.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpzcho_4ub.jl:1\n\
    in expression starting at /tmp/tmpzcho_4ub.jl:1\n"
  stdout: ''
  timestamp: 1660008776
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    s = 1\n    for i in extensions \n\
    \        s += 1 if i.end==i.start \n    end\n    return class_name+\".\"*string(extensions[s])\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"for\" at /tmp/tmpxwu64kje.jl:20 expected \"\
    end\", got \"if\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpxwu64kje.jl:21\n\
    in expression starting at /tmp/tmpxwu64kje.jl:21\n"
  stdout: ''
  timestamp: 1660008777
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \"\"\"\n    Strongest_Extension\
    \ receives a class name and a vector of extensions (Strings).\n    The function\
    \ should return the string in the format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ \"\"\"\n    \n    extension_strength = zeros(length(extensions)) \n    \n  \
    \  for e in extensions \n        extension_strength = extension_strength + (e.chars.count(uppercase(substring(e,1,end)))\
    \ - \n                                                e.chars.count(lowercase(substring(e,1,end))))\
    \ \n    \n    extension_strength_sorted = sort(extension_strength, descending\
    \ = true) \n    \n    sorted_extension_strength = extension_strength_sorted[1]\n\
    \    \n    if length(extension_strength_sorted) > 1 \n        \n        for e\
    \ \u2208 extensions \n            \n            if extension_strength_sorted[1]\
    \ == extension_strength_sorted \n                \n                sorted_extension_strength\
    \ = e \n                \n                break \n            \n            end\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"end\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpcur4n76p.jl:34\nin expression starting at /tmp/tmpcur4n76p.jl:34\n"
  stdout: ''
  timestamp: 1660008777
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    extensions_length = length(extensions)\n\
    \    extensions_count = count_if(x -> contains(x, class_name), extensions)\n \
    \   extensions_count_ratio = extensions_count / extensions_length\n    \n    #\
    \ strongest extension\n    extension_strongest = extensions[find_first(x -> contains(x,\
    \ class_name), extensions)]\n    \n    return class_name..extension_strongest\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmp_503xzwu.jl:30

    '
  stdout: "test set: Error During Test at /tmp/tmp_503xzwu.jl:33\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: count_if not defined\n  Stacktrace:\n  \
    \ [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n  \
    \   @ Main /tmp/tmp_503xzwu.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_503xzwu.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_503xzwu.jl:32\ntest set:\
    \ Error During Test at /tmp/tmp_503xzwu.jl:34\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: count_if not defined\n  Stacktrace:\n\
    \   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmp_503xzwu.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_503xzwu.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_503xzwu.jl:32\ntest set:\
    \ Error During Test at /tmp/tmp_503xzwu.jl:35\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  UndefVarError: count_if not\
    \ defined\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmp_503xzwu.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_503xzwu.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_503xzwu.jl:32\ntest set:\
    \ Er"
  timestamp: 1660008779
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    s = -1\n    for e in extensions do\n\
    \        if levenshtein(class_name, e) < s then\n            s = levenshtein(class_name,\
    \ e)\n        end\n    end\n    \n    \n    return class_name[:length(class_name)\
    \ - length(extensions[1]) - 1] + extensions[1][s]\nend\n</cell>\n<code language=julia-1.0>\n\
    Strongest_Extension(\"Slices\", [\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"])\n\
    </cell>\n<text>\nPart C: Test Cases\nWrite a test case to check that Strongest_Extension\
    \ works correctly for all of the following test cases.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp23rsnz6c.jl:20\nin expression starting at /tmp/tmp23rsnz6c.jl:20\n"
  stdout: ''
  timestamp: 1660008777
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    if length(extensions)<2 \n       \
    \ return class_name\n    end\n    ext=extensions[end]\n    ext=lowercase(ext)\n\
    \    \n    name=class_name\n    \n    for c in lowercase(ext[1:length(ext)-1])\n\
    \        name=name[end-length(c):end]\n    end\n    return name\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 7 failed, 2 errored,
    0 broken.

    in expression starting at /tmp/tmptqudxi7n.jl:34

    '
  stdout: "test set: Test Failed at /tmp/tmptqudxi7n.jl:37\n  Expression: candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\n   Evaluated:\
    \ \"hi\" == \"Watashi.eIGHt8OKe\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptqudxi7n.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptqudxi7n.jl:36\ntest set: Test\
    \ Failed at /tmp/tmptqudxi7n.jl:38\n  Expression: candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\n   Evaluated:\
    \ \"23\" == \"Boku123.YEs.WeCaNe\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptqudxi7n.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptqudxi7n.jl:36\ntest set: Test\
    \ Failed at /tmp/tmptqudxi7n.jl:39\n  Expression: candidate(\"__YESIMHERE\", [\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"\
    __YESIMHERE.NuLl__\"\n   Evaluated: \"RE\" == \"__YESIMHERE.NuLl__\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptqudxi7n.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptqudxi7n.jl:36\ntest set: Error\
    \ During Test at /tmp/tmptqudxi7n.jl:40\n  Test threw exception\n  Expression:\
    \ candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\n  BoundsError:\
    \ attempt to access 1-codeunit String at index [0:1]\n  Stacktrace:\n   [1] checkbounds\n\
    \     @ ./strings/basic.jl:216 [inlined]\n   [2] getindex\n     @ ./strings/string.jl:261\
    \ [inlined]\n   [3] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmptqudxi7n.jl:28\n   [4] macro"
  timestamp: 1660008780
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    my_strongest_extension = get_strongest_extension(class_name,\
    \ extensions)\n    my_strongest_extension[1:end-1]\nend\n</code>\n<|/ a tags=julia\
    \ dscore=1 |>\n<| c |>\nHey thanks for the answer! I tried running it but I'm\
    \ getting this error: `UndefVarError: get_strongest_extension not defined`. Do\
    \ I need to define the function first somewhere?\n<|/ c |>\n<| c |>\nYou need\
    \ to define that function and call it in the same file where you defined the `Strongest_Extension`\
    \ function.\n<|/ c |>\n<| c |>\nHi, I'm new to Julia and I really don't know how\
    \ to do that! I tried to define `get_strongest_extension` function and then call\
    \ it, but I get the error I posted in the original question. Would you mind showing\
    \ me how to do that?\n<|/ c |>\n<| c |>\nI edited the question with my attempt\
    \ of defining the function. Sorry, but I'm really new to Julia and don't really\
    \ know how to do that.\n<|/ c |>\n<| c |>\nThis code works with the example I\
    \ gave, but when I tried it on my own code I got this error: `ERROR: LoadError:\
    \ MethodError: no method matching length(::Bool)\nClosest candidates are:\n  length(::DataArray{Bool,N})\
    \ at /Users/.../Project.jl:26\nStacktrace:\n [1] top-level scope at /Users/.../Project.jl:22\n\
    `\n<|/ c |>\n<| a tags=julia |>\nYou have to make a few changes. Here is an example\
    \ that works for me:\n<code>\nget_strongest_extension(class_name::String, extensions::Vector{String})::String\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpsvutel1b.jl:22\nin expression starting at\
    \ /tmp/tmpsvutel1b.jl:22\n"
  stdout: ''
  timestamp: 1660008777
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    extension_count = length(extensions)\n\
    \    if extension_count == 0 \n        error(\"No extensions\")\n    elseif extension_count\
    \ == 1\n        return class_name + \".\" + extensions[0]\n    end\n    \n   \
    \ # counts the number of capitals in the class name and divides it\n    capitals\
    \ = count_capitals(class_name) \nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpj3dzk6l9.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpj3dzk6l9.jl:1\n\
    in expression starting at /tmp/tmpj3dzk6l9.jl:1\n"
  stdout: ''
  timestamp: 1660008777
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    extensions_index = getIndex(extensions)\n\
    \    if extensions_index == 0\n        return class_name\n    end\n    \n    return\
    \ Strongest_Extension(class_name, extensions[extensions_index])\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmp126s3e9o.jl:28

    '
  stdout: "test set: Error During Test at /tmp/tmp126s3e9o.jl:31\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: getIndex not defined\n  Stacktrace:\n  \
    \ [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n  \
    \   @ Main /tmp/tmp126s3e9o.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp126s3e9o.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp126s3e9o.jl:30\ntest set:\
    \ Error During Test at /tmp/tmp126s3e9o.jl:32\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: getIndex not defined\n  Stacktrace:\n\
    \   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmp126s3e9o.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp126s3e9o.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp126s3e9o.jl:30\ntest set:\
    \ Error During Test at /tmp/tmp126s3e9o.jl:33\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  UndefVarError: getIndex not\
    \ defined\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmp126s3e9o.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp126s3e9o.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp126s3e9o.jl:30\ntest set:\
    \ Er"
  timestamp: 1660008780
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpzl486e0r.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpzl486e0r.jl:1\n\
    in expression starting at /tmp/tmpzl486e0r.jl:1\n"
  stdout: ''
  timestamp: 1660008778
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n        \n    return class_name + \".\"\
    \ + \n        extensions[sort(extensions, by=length)][1]\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmp9x0zqbo7.jl:25

    '
  stdout: "test set: Error During Test at /tmp/tmp9x0zqbo7.jl:28\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  ArgumentError: unable to check bounds for indices of type\
    \ String\n  Stacktrace:\n    [1] checkindex(#unused#::Type{Bool}, inds::Base.OneTo{Int64},\
    \ i::String)\n      @ Base ./abstractarray.jl:713\n    [2] checkindex\n      @\
    \ ./abstractarray.jl:728 [inlined]\n    [3] checkbounds\n      @ ./abstractarray.jl:641\
    \ [inlined]\n    [4] checkbounds\n      @ ./abstractarray.jl:656 [inlined]\n \
    \   [5] _getindex\n      @ ./multidimensional.jl:838 [inlined]\n    [6] getindex\n\
    \      @ ./abstractarray.jl:1218 [inlined]\n    [7] Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})\n      @ Main /tmp/tmp9x0zqbo7.jl:20\n    [8] macro\
    \ expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [9] macro expansion\n      @ /tmp/tmp9x0zqbo7.jl:28 [inlined]\n\
    \   [10] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [11] top-level scope\n      @ /tmp/tmp9x0zqbo7.jl:27\ntest set:\
    \ Error During Test at /tmp/tmp9x0zqbo7.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  ArgumentError: unable to check bounds for indices\
    \ of type String\n  Stacktrace:\n    [1] checkindex(#unused#::Type{Bool}, inds::Base.OneTo{Int64},\
    \ i::String)\n      @ Base ./abstractarray.jl:713\n    [2] checkindex\n      @\
    \ ./abstractarray.jl:728 [inlined]\n    [3] checkbounds\n      @ ./abstractarray.jl:641\
    \ [inlined]\n    [4] checkbounds\n      @ ./abstractarray.jl:656 [inlined]\n \
    \   [5] _getindex\n      @ ./multidimensional.jl:838 [inlined]\n    [6] getindex\n\
    \      @ ./abstractarray.jl:1218 [inlined]\n    [7] Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})\n      @ Main /tmp/tmp9x0zqbo7.jl:20\n    [8] macro\
    \ expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [9] macro expansion\n      @"
  timestamp: 1660008780
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \"\"\"\n    You will be given the\
    \ name of a class (a string) and a vector of extensions.\n    The extensions are\
    \ to be used to load additional classes to the class. The\n    strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n    letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n  \
    \  in the extension's name, the strength is given by the fraction CAP - SM. \n\
    \    You should find the strongest extension and return a string in this \n  \
    \  format: ClassName.StrongestExtensionName.\n    If there are two or more extensions\
    \ with the same strength, you should\n    choose the one that comes first in the\
    \ vector.\n    For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    \    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"\n    \n    let num_caps\
    \ = length(upper(extensions))\n    let num_sms = length(lower(extensions))\n \
    \   \n    if num_caps-num_sms == 0 \n        return \"Unknown\"\n    else \n \
    \       return (class_name * \".\" * join(extensions,\".\")) \n    end\nend\n\
    </cell>\n<text>\nWrite a function called \"load_extensions\" which takes as input\
    \ a path to a file containing extensions and \nreturns a vector of strings. This\
    \ function should return a vector of the extensions in the order they appear\n\
    in the file.\nIn the cell below, write a function that takes a string and an optional\
    \ argument file_name \n(default \"extensions.txt\"), and loads the extensions\
    \ in that file as a vector of strings.\nThe optional argument file_name should\
    \ contain the name of the file that you want to load\nthe extensions from. The\
    \ function should return this vector as a result.\nusing Test\n\n@testset begin\n\
    \ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8nmvpfar.jl:47\nin expression starting at\
    \ /tmp/tmp8nmvpfar.jl:47\n"
  stdout: ''
  timestamp: 1660008778
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    ext = {}\n    count = 0\n    for e\
    \ in extensions\n        if lowercase(e) == lowercase(class_name)\n          \
    \  count+=1\n        elseif lowercase(e) == lowercase(class_name)\n          \
    \  count+=1\n        else\n            ext[lowercase(e)] = count\n           \
    \ count = 0\n        end\n    end\n    \n    sorted = collect(ext) do key, val\n\
    \        val \n    end\n    \n    sorted.reverse\n    \n    for (key, val) in\
    \ sorted\n        if val > 0\n            return key + \".\" + extensions[key]\n\
    \        end\n    end\nend\n</cell>\n<code language=julia-0.6>\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n@assert Strongest_Extension(\"\
    MyClass\", [\"AA\", \"Be\", \"CC\"]) == \"MyClass.AA\"\n@assert Strongest_Extension(\"\
    Myclass\", [\"AA\", \"Be\", \"CC\"]) == \"Myclass.AA\"\n@assert Strongest_Extension(\"\
    My_class\", [\"AA\", \"Be\", \"CC\"]) == \"My_class.AA\"\n</cell>\n<text>\nExercise\
    \ 2.7\nThe function Classname should take a vector of extensions as its first\
    \ argument and returns the name of the class with its extensions appended to it.\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: { } vector syntax is discontinued around /tmp/tmpbm4awdeg.jl:19\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpbm4awdeg.jl:1\nin expression starting\
    \ at /tmp/tmpbm4awdeg.jl:1\n"
  stdout: ''
  timestamp: 1660008778
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    len = length(extensions)\n \
    \   \n    if len < 1\n        error(\"Cannot have 0 extensions\")\n    end\n \
    \   \n    sort(extensions, by = x -> count_occurences(x, class_name) - count_occurences(x,\
    \ \"className\"))\n    \n    ext1 = extensions[end]\n    if count_occurences(ext1,\
    \ class_name) != len\n        error(\"Extension not found!\")\n    end\n    \n\
    \    return String(class_name) + ext1\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmprq96rd06.jl:37

    '
  stdout: "test set: Error During Test at /tmp/tmprq96rd06.jl:40\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: count_occurences not defined\n  Stacktrace:\n\
    \    [1] (::var\"#1#2\"{String})(x::String)\n      @ Main /tmp/tmprq96rd06.jl:26\n\
    \    [2] lt(o::Base.Order.By{var\"#1#2\"{String}, Base.Order.ForwardOrdering},\
    \ a::String, b::String)\n      @ Base.Order ./ordering.jl:111\n    [3] sort!(v::Vector{String},\
    \ lo::Int64, hi::Int64, #unused#::Base.Sort.InsertionSortAlg, o::Base.Order.By{var\"\
    #1#2\"{String}, Base.Order.ForwardOrdering})\n      @ Base.Sort ./sort.jl:507\n\
    \    [4] sort!(v::Vector{String}, lo::Int64, hi::Int64, a::Base.Sort.MergeSortAlg,\
    \ o::Base.Order.By{var\"#1#2\"{String}, Base.Order.ForwardOrdering}, t::Vector{String})\n\
    \      @ Base.Sort ./sort.jl:592\n    [5] sort!\n      @ ./sort.jl:591 [inlined]\n\
    \    [6] sort!\n      @ ./sort.jl:664 [inlined]\n    [7] #sort!#8\n      @ ./sort.jl:725\
    \ [inlined]\n    [8] #sort#9\n      @ ./sort.jl:772 [inlined]\n    [9] Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})\n      @ Main /tmp/tmprq96rd06.jl:26\n   [10] macro\
    \ expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [11] macro expansion\n      @ /tmp/tmprq96rd06.jl:40 [inlined]\n\
    \   [12] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [13] top-level scope\n      @ /tmp/tmprq96rd06.jl:39\ntest set:\
    \ Error During Test at /tmp/tmprq96rd06.jl:41\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: count_occurences not defined\n\
    \  Stacktrace:\n    [1] (::var\"#1#2\"{String})(x::String)\n      @ Main /tmp/tmprq96rd06.jl:26\n\
    \    [2] lt(o::Base.Order.By{var\"#1#2\"{String}, Base.Order.ForwardOrdering},\
    \ a::String, b::String)\n      @ Base.Order ./ordering.jl:111\n    [3] sort!(v::Vector{String},\
    \ lo::Int64, hi::Int64, #unused#::Base.Sort.InsertionSortAlg, o::Base.Order.By{var\"\
    #1#2\"{String"
  timestamp: 1660008780
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    extension =  [item for item in extensions\
    \ \n        if (item in StringChars(class_name) and item != String(class_name))]\n\
    \    return length(extension) == 0 ? class_name\n                            :\
    \ class_name.(extension)\nend\n</cell>\n<code language=julia-1.1>\n?StringChars\n\
    </cell>\n<code language=julia-1.1>\nStrongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\"])\n</cell>\n<text>\nExercise 3\nWrite a function that generates\
    \ the string class name and the extension for a given \nobject of any type (e.g.,\
    \ String, Int, or Vector{String}), with these properties:\n- Every object has\
    \ a class name.\n- Every object has an extension (vector of strings).\n- The extension\
    \ vector is composed of valid characters of the class name.\n- There should be\
    \ no duplicate extensions.\n- There should be no missing extensions in the extensions\
    \ vector.\n- There should be no missing characters in the extension vector.\n\
    - There should be no duplicate class names.\n- There should be no missing class\
    \ names.\nExample: \n>>> make_class_and_extension(MyString(42), \"ABC\")\n(\"\
    MyString\", \"ABC\")\n>>> make_class_and_extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\"])\n(\"my_class\", \"AA\", \"Be\", \"CC\")\n>>> make_class_and_extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"])\n(\"my_class\", \"AA\", \"Be\", \"CC\")\n\
    >>> make_class_and_extension(42, \"ABC\")\n(42, [\"A\", \"B\", \"C\"])\n>>> make_class_and_extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"])\n(\"my_class\", \"AA\", \"Be\", \"CC\")\n\
    >>> make_class_and_extension(42, \"ABC\")\n(42, [\"A\", \"B\", \"C\"])\n>>> make_class_and_extension(MyString(\"\
    42\"), \"ABC\")\n(\"MyString\", \"ABC\")\n>>> make_class_and_extension(MyString(\"\
    42\"), \"ABC\")\n(\"MyString\", \"ABC\")\n>>> make_class_and_extension(MyString(42),\
    \ \"ABC\")\n(\"MyString\", \"ABC\")\n>>> make_class_and_extension(MyString(42),\
    \ \"ABC\")\n(\"MyString\", \"ABC\")\n>>> make_class_and_extension(MyString(42),\
    \ \"ABC\")\n(\"MyString\", \"ABC\")\n>>> make_class_and_extension(MyString(42),\
    \ \"ABC\")\n(\"MyString\", \"ABC\")\n>>> make_class_and_extension(MyString(\"\
    42\"), \"ABC\")\n(\"MyString\", \"ABC\")\n>>> make_class_and_extension(MyString(\"\
    42\"), \"ABC\")\n(\"MyString\", \"ABC\")\n>>> make_class_and_extension(MyString(\"\
    42\"), \"ABC\")\n(\"\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpm5zonbx1.jl:20\nin expression starting at\
    \ /tmp/tmpm5zonbx1.jl:20\n"
  stdout: ''
  timestamp: 1660008778
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    str_vec=extensions_strength(extensions)\n\
    \    if any(str_vec==-1) return class_name\n    # return sort(extensions,by=str_vec,rev=true)[1]\n\
    \    sort!(extensions,by=str_vec,rev=true)\n    return sort(extensions,by=str_vec,rev=true)[1]\n\
    end\n</code>\n<|/ a tags=julia |>\n<| c |>\nThanks for the solution, It will also\
    \ help other beginner like me.\n<|/ c |>\n<| a tags=julia dscore=0 |>\nMy solution\
    \ for Julia 0.6:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp1kt9_6j.jl:25\nin expression starting at\
    \ /tmp/tmpp1kt9_6j.jl:25\n"
  stdout: ''
  timestamp: 1660008778
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    strength = Dict{String, Int}()\n\
    \    for e in extensions\n        strength[e] = count(lower(e)) / (count(upper(e)))\n\
    \    end\n    \n    \n    strength_sorted = sort(strength, by=x->x[1], reverse=true)\n\
    \    \n    sorted_extension = \n        if length(strength_sorted) == 0 \n   \
    \     error(\"No extensions given\")\n        else \n            extensions[first(find(strength_sorted\
    \ .== strength_sorted[1],1))]\n        end\n    \n    if length(strength_sorted)\
    \ == 1 \n        error(\"More than one extension found. Choose one from the list.\"\
    )\n    else \n        Strongest_Extension = Stringcat(class_name, \".\", sorted_extension)\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpy16max4l.jl:43

    '
  stdout: "test set: Error During Test at /tmp/tmpy16max4l.jl:46\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: lower not defined\n  Stacktrace:\n   [1]\
    \ Strongest_Extension(class_name::String, extensions::Vector{String})\n     @\
    \ Main /tmp/tmpy16max4l.jl:22\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpy16max4l.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpy16max4l.jl:45\ntest set:\
    \ Error During Test at /tmp/tmpy16max4l.jl:47\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: lower not defined\n  Stacktrace:\n\
    \   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpy16max4l.jl:22\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpy16max4l.jl:47 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpy16max4l.jl:45\ntest set:\
    \ Error During Test at /tmp/tmpy16max4l.jl:48\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  UndefVarError: lower not defined\n\
    \  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpy16max4l.jl:22\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpy16max4l.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpy16max4l.jl:45\ntest set:\
    \ Error Durin"
  timestamp: 1660008780
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    # your code goes here\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpgmokcq77.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpgmokcq77.jl:26\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{String},\
    \ !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpgmokcq77.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpgmokcq77.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpgmokcq77.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpgmokcq77.jl:27\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{String},\
    \ !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpgmokcq77.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/"
  timestamp: 1660008781
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n  \n  exts = sort(extensions)\n  \n  if\
    \ length(exts) > 1\n    s_ext = exts[1]\n  else\n    s_ext = exts[0]\n  end\n\
    \  \n  if length(exts) == 2\n    if length(extensions) > 2\n      c_ext = extensions[2]\n\
    \    else\n      c_ext = extensions[1]\n    end\n  else\n    c_ext = exts[1]\n\
    \  end\n  \n  name = class_name.split(\".\") \n  \n  strongest = strongest_extension(name)\n\
    \  \n  if length(exts) == 2\n    return strongest + \".\" + c_ext\n  else\n  \
    \  return strongest + \".\" + s_ext\n  end\nend\n</cell>\n<text>\nExtensions\n\
    The extensions feature is now available in the standard library! You can now perform\
    \ operations on classes before they are instantiated.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpu3rdoh1w.jl:48\nin expression starting at\
    \ /tmp/tmpu3rdoh1w.jl:48\n"
  stdout: ''
  timestamp: 1660008778
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n# this function\n\"\"\"\n    Implement\
    \ this function in any CSP file.\n    \"\"\"\nusing Test\n\n@testset begin\n\n\
    candidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpf0856olq.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpf0856olq.jl:1\n\
    in expression starting at /tmp/tmpf0856olq.jl:1\n"
  stdout: ''
  timestamp: 1660008778
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    extension = extensions[1]\n    while\
    \ strpos(extension, class_name) < strpos(extension, class_name + \"A\")\n    \
    \    extension = extensions[-2]\n    end\n    return join(\".\", class_name, extension)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpnnjyxoz_.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmpnnjyxoz_.jl:30\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: strpos not defined\n  Stacktrace:\n   [1]\
    \ Strongest_Extension(class_name::String, extensions::Vector{String})\n     @\
    \ Main /tmp/tmpnnjyxoz_.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnnjyxoz_.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnnjyxoz_.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpnnjyxoz_.jl:31\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: strpos not defined\n  Stacktrace:\n\
    \   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpnnjyxoz_.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnnjyxoz_.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnnjyxoz_.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpnnjyxoz_.jl:32\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  UndefVarError: strpos not defined\n\
    \  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpnnjyxoz_.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnnjyxoz_.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnnjyxoz_.jl:29\ntest set:\
    \ Error Du"
  timestamp: 1660008781
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpzl486e0r.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpzl486e0r.jl:1\n\
    in expression starting at /tmp/tmpzl486e0r.jl:1\n"
  stdout: ''
  timestamp: 1660008778
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    strongest = extensions[]\n    strongest\
    \ = sort(strongest)\n    strongest = strongest[length(strongest)] \n    strongest\
    \ = strongest.sub(\"^([A-Z]+)\", \"\") \n    strongest = strongest.sub(\"([A-Z]+)$\"\
    , \"\") \n    strongest = strongest.sub(\"([a-z]+)([A-Z])\", \"$1.$2\")\n    return\
    \ class_name.concat(strongest) \nend\n</cell>\n<text>\n\_Exercise 4\nCreate a\
    \ function that is used to load a class from a given path, and returns a class\
    \ of it. The class should use the name given in the function argument. \nThe function\
    \ should return an object of type Class, which will contain the following attributes:\
    \ name, extensions, extension_strength. \nThe name attribute should contain the\
    \ name of the class passed in the argument. \nThe extensions attribute should\
    \ contain the extensions of the class passed in the argument. \nThe extension_strength\
    \ attribute should contain the strength of each extension used in the class. \n\
    Note that if the extension name is found more than once in the vector extensions,\
    \ the function should choose the one that comes first in the vector. \nIf the\
    \ extension name is not found at all in the vector extensions, the function should\
    \ return an error. \nHint: you can use the function load_class(...) defined earlier.\
    \ \nHint: You may want to use try/catch/else statement.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid interpolation syntax: \"$\"\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpsc18u4zb.jl:23\nin expression starting at\
    \ /tmp/tmpsc18u4zb.jl:23\n"
  stdout: ''
  timestamp: 1660008778
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    if length(extensions) <= 0\n\
    \        throw(ArgumentError(\"There must be at least 1 extension given\"))\n\
    \    \n    \n    for ext in extensions \n        \n        if ext == \"\"\n  \
    \          throw(ArgumentError(\"There must be some extensions given\"))\n   \
    \     \n        if all(c <= \"Z\" for c in ext)\n            throw(ArgumentError(\"\
    There must be some extensions given\"))\n            \n        if all(c <= \"\
    z\" for c in ext)\n            throw(ArgumentError(\"There must be some extensions\
    \ given\"))\n            \n        \n        if ext == \"\"\n            throw(ArgumentError(\"\
    There must be some extensions given\"))\n        end\n        \n    end\n    \n\
    \    \n    if extensions[1] == \"\"\n        throw(ArgumentError(\"There must\
    \ be at least 1 extension given\"))\n    end\n    \n    if extensions[2] != \"\
    \"\n        throw(ArgumentError(\"There must be at least 2 extensions given\"\
    ))\n    end\n    \n    \n    \n    \n    \n    \n    \n    if length(extensions)>3\n\
    \        throw(ArgumentError(\"There must be at most 3 extensions given\"))\n\
    \    end\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   if length(extensions)>3\n        throw(ArgumentError(\"There must be at most\
    \ 3 extensions given\"))\n    end\n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9hs5dlyd.jl:1\nin expression starting at /tmp/tmp9hs5dlyd.jl:1\n"
  stdout: ''
  timestamp: 1660008779
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    if length(extensions) <= 1\n\
    \        return class_name\n    end\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpuvm2u9so.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpuvm2u9so.jl:1\n\
    in expression starting at /tmp/tmpuvm2u9so.jl:1\n"
  stdout: ''
  timestamp: 1660008779
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n        \n    extensions_ = extensions[1:end]\n\
    \    strength_ = [0 for i in 1:length(extensions_)]\n    \n    for i in 1:length(extensions_)\
    \ \n        \n        cap = match(extensions_[i], \"[A-Z]\")\n        slash =\
    \ match(extensions_[i], \"[A-z]\")\n        \n        strength_[i] = cap - slash\n\
    \    end\n    \n    \n    strength_sum = sum(strength_)\n    \n    sorted_ = sort(zip(extensions_,\
    \ strength_))\n    \n    index_ = argmax(map(x -> x[1],  sorted_))[1]\n    \n\
    \    \n    return class_name .. \".\" .. sorted_[index_][1]\nend\n</cell>\n<text>\n\
    Expected Output:\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpx2bf9ibk.jl:41\nin expression starting at\
    \ /tmp/tmpx2bf9ibk.jl:41\n"
  stdout: ''
  timestamp: 1660008779
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    strongest_extension_strength\
    \ = -1 # initiate the strength of the extension\n    for extension in extensions\
    \ \n        if contains(extension, uppercase(class_name)) \n            strongest_extension_strength\
    \ = length(extension) - length(lowercase(extension))\n        end\n    end\n \
    \   return class_name*string(strongest_extension_strength)\nend\n</cell>\n<text>\n\
    (2.1) Test your function\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpumfk4df8.jl:28\nin expression starting at\
    \ /tmp/tmpumfk4df8.jl:28\n"
  stdout: ''
  timestamp: 1660008779
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    if extensions.size == 0\n        return\
    \ class_name\n    \n    sort_order = extensions.map(x->x.length).max\n    \n \
    \   max_length = extensions.map(x->x.length).max\n    \n    strength = extensions.map(x->x.length\
    \ - sort_order).max\n    \n    if strength == 0\n        error(\"No extension\
    \ has the maximum strongest extension\")\n    end\nusing Test\n\n@testset begin\n\
    \ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzjfn385d.jl:1\nin expression starting at /tmp/tmpzjfn385d.jl:1\n"
  stdout: ''
  timestamp: 1660008779
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    #Initialize a dictionary to\
    \ store extensions and strengths. \n    extension_dict = {}\n    \n    #Get number\
    \ of uppercase letters in extension. \n    CAP = count(uppercase(extensions[1]))\n\
    \    \n    #Get number of lowercase letters in extension. \n    SM = count(lowercase(extensions[1]))\n\
    \    \n    #Compute and store the strongest extension. \n    extension_dict[extensions[1]]\
    \ = CAP - SM\n    \n    #Initialize a counter. \n    count = 0\n    \n    #Iterate\
    \ through extensions and see if each of them are in the dictionary. \n    for\
    \ extn in extensions[2:end]\n        \n        #If not, increment count and set\
    \ extension to be the extension with the \n        #strongest strength. If yes,\
    \ increment count and leave it as it is. \n        if !(extn in extension_dict)\n\
    \            count = count+1\n            extension_dict[extn] = count\n     \
    \   else\n            count = extension_dict[extn]\n        end\n    end\n   \
    \ \n    return class_name * \".\" + extension_dict[extensions[1]]\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n@test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n@test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\"]) == \"my_class.DD\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"]) == \"my_class.EE\"\n</cell>\n\
    <text>\nQ21\nWrite a function to compute the total number of words in a document\
    \ that ends with \"ay\". \nFor example in [\"a\", \"be\", \"see\", \"see\", \"\
    see\", \"see\", \"see\", \"see\", \"see\"], \nthe total number of words with ending\
    \ with \"ay\" is 10.\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: { } vector syntax is discontinued around /tmp/tmpe6rfyp99.jl:21\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpe6rfyp99.jl:1\nin expression starting\
    \ at /tmp/tmpe6rfyp99.jl:1\n"
  stdout: ''
  timestamp: 1660008779
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension =  extensions[findall(extensions==class_name,\
    \ extensions)][1]\n    \n    if length(extensions)>1\n        extension = extensions[findall(extensions==class_name,\
    \ extensions)][2]\n    end\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpqqyv477v.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpqqyv477v.jl:1\n\
    in expression starting at /tmp/tmpqqyv477v.jl:1\n"
  stdout: ''
  timestamp: 1660008779
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    cap = length(class_name)\n    sm =\
    \ length(extensions[1])\n    if cap-sm > 0 \n        str = join([class_name; strcat(extensions[1],\
    \ extensions[1][cap-sm])], \"\")\n    end\n    str\nend\n</cell>\n<code language=julia-1.6>\n\
    @assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Bx\", \"CC\"]) == \"my_class.Aa\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Bx\", \"CC\"]) == \"my_class.Aa\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Bx\", \"CC\", \"DD\"])\
    \ == \"my_class.Aa\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Bx\"\
    , \"CC\", \"DD\", \"EE\"]) == \"my_class.Aa\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Bx\", \"CC\", \"DD\", \"EE\", \"FF\"]) == \"my_class.Aa\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Bx\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\"]) == \"my_class.Aa\"\n</cell>\n<text>\nProblem 3\nusing Test\n\
    \n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpknusgapf.jl:26\nin expression starting at\
    \ /tmp/tmpknusgapf.jl:26\n"
  stdout: ''
  timestamp: 1660008779
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    extensions_with_strength = filter(\
    \ (Extension -> length(Extension) == length(class_name)\n                    \
    \                 && all( is_cap(Ext) || is_lower(Ext) \n                    \
    \                     for Ext in Extension ) ) \n                            \
    \        , extensions );\n    if length(extensions_with_strength) == 0 \n    \
    \   return class_name\n    else\n       return class_name + String(extensions_with_strength[0])\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 7 failed, 2 errored,
    0 broken.

    in expression starting at /tmp/tmpqilv7c5i.jl:31

    '
  stdout: "test set: Test Failed at /tmp/tmpqilv7c5i.jl:34\n  Expression: candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\n   Evaluated:\
    \ \"Watashi\" == \"Watashi.eIGHt8OKe\"\nStacktrace:\n [1] macro expansion\n  \
    \ @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqilv7c5i.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpqilv7c5i.jl:33\ntest set: Test Failed at /tmp/tmpqilv7c5i.jl:35\n\
    \  Expression: candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\n   Evaluated: \"Boku123\" == \"Boku123.YEs.WeCaNe\"\
    \nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqilv7c5i.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqilv7c5i.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpqilv7c5i.jl:36\n  Expression: candidate(\"__YESIMHERE\", [\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"\
    __YESIMHERE.NuLl__\"\n   Evaluated: \"__YESIMHERE\" == \"__YESIMHERE.NuLl__\"\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqilv7c5i.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqilv7c5i.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpqilv7c5i.jl:37\n  Expression: candidate(\"K\", [\"Ta\", \"\
    TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\n   Evaluated: \"K\" == \"K.TAR\"\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqilv7c5i.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scop"
  timestamp: 1660008782
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \"\"\"\n    STRONGEST EXTENSIONS IN\
    \ A CLASS \n    \n    You will be given the name of a class (a string) and a vector\
    \ of extensions.\n    The extensions are to be used to load additional classes\
    \ to the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\n    return class_name + \".\" + extensions[findmin(lengths(extensions))[1]]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpkwdpaq1l.jl:43

    '
  stdout: "test set: Error During Test at /tmp/tmpkwdpaq1l.jl:46\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: lengths not defined\n  Stacktrace:\n   [1]\
    \ Strongest_Extension(class_name::String, extensions::Vector{String})\n     @\
    \ Main /tmp/tmpkwdpaq1l.jl:39\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkwdpaq1l.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkwdpaq1l.jl:45\ntest set:\
    \ Error During Test at /tmp/tmpkwdpaq1l.jl:47\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: lengths not defined\n  Stacktrace:\n\
    \   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpkwdpaq1l.jl:39\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkwdpaq1l.jl:47 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkwdpaq1l.jl:45\ntest set:\
    \ Error During Test at /tmp/tmpkwdpaq1l.jl:48\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  UndefVarError: lengths not\
    \ defined\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpkwdpaq1l.jl:39\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkwdpaq1l.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkwdpaq1l.jl:45\ntest set:\
    \ Error"
  timestamp: 1660008782
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    S = extension.(lower) for lower=extension\n\
    \    extension.(lower) for lower=extension\n    A = extension.(lower) for lower=extension\n\
    \    B = extension.(lower) for lower=extension\n    C = extension.(lower) for\
    \ lower=extension\n    \n    cap = length(A)\n    sm = length(B)\n    \n    if\
    \ cap > sm\n        return strcat(class_name, strcat(A,\".\",B))\n    elseif cap\
    \ < sm\n        return strcat(class_name, strcat(C,\".\",B))\n    end\n    \n\
    end\n</cell>\n<code language=julia-1.5>\nStrongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\"])\n</cell>\n<text>\nExercise: Implementing Strongest_Extension\n\
    The function strongest() takes three arguments: a vector, a string, and a string.\n\
    It should return the string in the following format:\nClassName.StrongestExtensionName\n\
    where ClassName is the name of the class passed in as the first argument and \n\
    StrongestExtensionName is the strongest extension name passed in as the second\n\
    argument. Example: \nmy_class.StrongestExtensionName\nusing Test\n\n@testset begin\n\
    \ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"function\" at /tmp/tmp9nzlc8fv.jl:18 expected\
    \ \"end\", got \"for\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp9nzlc8fv.jl:20\n\
    in expression starting at /tmp/tmp9nzlc8fv.jl:20\n"
  stdout: ''
  timestamp: 1660008780
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    len = length(extensions)\n    index_of_max_strength\
    \ = sort(extensions)[len]\n    strength = ord(index_of_max_strength) - ord('a')\n\
    \    \n    return (class_name+\".\"+extensions[len-1])::String\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpsuqptzqq.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmpsuqptzqq.jl:30\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: ord not defined\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})\n     @ Main /tmp/tmpsuqptzqq.jl:21\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpsuqptzqq.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpsuqptzqq.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpsuqptzqq.jl:31\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: ord not defined\n  Stacktrace:\n\
    \   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpsuqptzqq.jl:21\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpsuqptzqq.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpsuqptzqq.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpsuqptzqq.jl:32\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  UndefVarError: ord not defined\n\
    \  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpsuqptzqq.jl:21\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpsuqptzqq.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpsuqptzqq.jl:29\ntest set:\
    \ Error During Test"
  timestamp: 1660008783
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    str_extension = class_name\n\
    \    str_extension_length = len(str_extension)\n    \n    str_extension.= \"[\"\
    \ \n    \n    for extension in extensions \n        \n        if str_extension_length\
    \ < extension.length \n            str_extension = str_extension + extension[str_extension_length..-1]\
    \ \n            break\n        \n        else if str_extension_length == extension.length\n\
    \            str_extension = str_extension + extension \n            break\n \
    \       \n        else\n            str_extension = str_extension + extension[0..str_extension_length\
    \ - 1] \n            break\n        \n    end\n    \n    str_extension.= \"]\"\
    \n    \n    return str_extension\nend\n</cell>\n<code language=julia-1.6>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid operator \"..-\" near column 76\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxpmbamy3.jl:28\nin expression starting at\
    \ /tmp/tmpxpmbamy3.jl:28\n"
  stdout: ''
  timestamp: 1660008780
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    strongest_extension_index=0\n    for\
    \ extension in extensions\n        if length(extension) > length(class_name)\n\
    \            strongest_extension_index = length(class_name) - length(extension)\n\
    \            break\n        end\n    end\n    return substring(class_name, 1,\
    \ strongest_extension_index + 1) +\n           substring(extension, strongest_extension_index\
    \ + 1, length(extension))\nend\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpvxdip_e9.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpvxdip_e9.jl:34\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: substring not defined\n  Stacktrace:\n \
    \  [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n \
    \    @ Main /tmp/tmpvxdip_e9.jl:26\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvxdip_e9.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvxdip_e9.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpvxdip_e9.jl:35\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: substring not defined\n  Stacktrace:\n\
    \   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpvxdip_e9.jl:26\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvxdip_e9.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvxdip_e9.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpvxdip_e9.jl:36\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  UndefVarError: substring not\
    \ defined\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpvxdip_e9.jl:26\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvxdip_e9.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvxdip_e9.jl:33\ntest set:"
  timestamp: 1660008782
- exit_code: -1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    strongest_extension = extensions[1]\n\
    \    for e in extensions[2:length-1]\n        if length(strongest_extension) >\
    \ length(e)\n            strongest_extension = e\n        end\n    end\n    return\
    \ strongest_extension\nend\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: Timeout
  stderr: ''
  stdout: "test set: Error During Test at /tmp/tmpajo4oanu.jl:32\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  MethodError: no method matching -(::typeof(length), ::Int64)\n\
    \  Closest candidates are:\n    -(!Matched::T, ::T) where T<:Union{Int128, Int16,\
    \ Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8} at ~/.conda/envs/polyglot/share/julia/base/int.jl:86\n\
    \    -(!Matched::LinearAlgebra.UniformScaling, ::Number) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:147\n\
    \    -(!Matched::Base.TwicePrecision, ::Number) at ~/.conda/envs/polyglot/share/julia/base/twiceprecision.jl:293\n\
    \    ...\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpajo4oanu.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpajo4oanu.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpajo4oanu.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpajo4oanu.jl:33\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  MethodError: no method matching -(::typeof(length),\
    \ ::Int64)\n  Closest candidates are:\n    -(!Matched::T, ::T) where T<:Union{Int128,\
    \ Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8} at ~/.conda/envs/polyglot/share/julia/base/int.jl:86\n\
    \    -(!Matched::LinearAlgebra.UniformScaling, ::Number) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:147\n\
    \    -(!Matched::Base.TwicePrecision, ::Number) at ~/.conda/envs/polyglot/share/julia/base/twiceprecision.jl:293\n\
    \    ...\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpajo4oanu.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1."
  timestamp: 1660008784
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    cap_letters = sum(map(&length, extensions))\n\
    \    strength_letters = cap_letters - sum(map(&length, extensions))\n    \n  \
    \  if strength_letters == 0\n        return class_name\n    end\nusing Test\n\n\
    @testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpa0tfaoh_.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpa0tfaoh_.jl:1\n\
    in expression starting at /tmp/tmpa0tfaoh_.jl:1\n"
  stdout: ''
  timestamp: 1660008781
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    extensions = sort(extensions)\n  \
    \  \n    strength = -1 \n    \n    for ext in extensions\n        if strmatch(class_name,\
    \ ext)\n            strength = round(length(class_name)/length(ext))\n       \
    \     \n            break\n        end\n    end\n    \n    \n    \n    if strength\
    \ == -1\n        error(\"There were no matches for class name $class_name\")\n\
    \    else\n        first(extensions[strength+1:end]).\n    end\nend\n</cell>\n\
    <code language=julia-1.6>\n@test Strongest_Extension(\"my_class\", [\"AA\", \"\
    Be\", \"CC\"]) \u2248 \"my_class.AA\"\n</cell>\n<text>\n6. Write a function that\
    \ takes the name of a class as a string, and a vector of strings as extensions,\
    \ and finds the strongest extension.\n    You should find that extension.\n  \
    \  Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzrzusu4d.jl:39\nin expression starting at\
    \ /tmp/tmpzrzusu4d.jl:39\n"
  stdout: ''
  timestamp: 1660008781
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    Strongest_Extension = class_name +\
    \ extensions[length(extensions)];\n    return Strongest_Extension\nend\n</cell>\n\
    <code language=julia-1.0>\n\"\"\"\n    Split_Extension\n    ----------------\n\
    \    Description:\n        This function splits a string into its different components.\n\
    \    Input:\n        Strongest_Extension\n    Output:\n        A vector of strings\
    \ containing the different components.\n    Example:\n    >>> Split_Extension(\"\
    my_class.AA\")\n    [\"my_class\", \"AA\"]\n    \"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpiml4m3ky.jl:22\nin expression starting at\
    \ /tmp/tmpiml4m3ky.jl:22\n"
  stdout: ''
  timestamp: 1660008781
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    sorted_extensions = sort!(extensions)\n\
    \    strongest_extension = sorted_extensions[end]\n    for ext in sorted_extensions[2:end]\n\
    \        if StrongestExtension(class_name) == StrongestExtension(ext)\n      \
    \      strongest_extension = ext\n        end\n    end\n    class_name+strongest_extension\n\
    end\n</cell>\n<text>\nQuestion 9. Complete the function with the comments:\nusing\
    \ Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmcsd2jrs.jl:28\nin expression starting at\
    \ /tmp/tmpmcsd2jrs.jl:28\n"
  stdout: ''
  timestamp: 1660008781
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n        \n    n = length(extensions)\n\
    \    \n    # Initialization: \n    bestExtension = extensions[1]\n    bestStrength\
    \ = -1\n    \n    # Looping through the extensions: \n    for i in 2:n\n     \
    \   \n        # Evaluating the strength between the current extension and the\
    \ \n        # current bestExtension (which is the second extension):\n       \
    \ thisStrength = length(extensions[i] - bestExtension)\n        \n        # If\
    \ the strength is better than the best strength, we replace \n        # the bestExtension\
    \ with the current extension:\n        if thisStrength > bestStrength\n      \
    \      bestExtension = extensions[i]\n            bestStrength = thisStrength\n\
    \        end\n    end\n    \n    # Return the best extension: \n    return class_name\
    \ + bestExtension\nend\n</cell>\n<text>\n3.4 A word about loops\nYou will now\
    \ use an extension to implement a word count function. The extension should include\
    \ a loop that runs over all the letters in a string.\nThe loop should start at\
    \ 1 and run until it hits the last letter of the string and add the current letter\
    \ to the running total.\nFinally you should return the total.\nThe code cell below\
    \ should give an example of what this extension might look like.\nusing Test\n\
    \n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqrp6oaje.jl:44\nin expression starting at\
    \ /tmp/tmpqrp6oaje.jl:44\n"
  stdout: ''
  timestamp: 1660008781
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    s=\"\"\n    for ext in extensions\
    \ \n        ext=reverse(ext)\n        try\n            s=sconcat(s.s.ext[1:ext])\n\
    \        catch e\n            s=sconcat(s.s.ext)\n        end\n    end\n    return\
    \ join(s.s.ext[1:length(s.s.ext)-1],\".\",s.s.ext[length(s.s.ext)-1:1])\nend\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpkc1pizqf.jl:33

    '
  stdout: "test set: Error During Test at /tmp/tmpkc1pizqf.jl:36\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  type String has no field s\n  Stacktrace:\n   [1] getproperty\n\
    \     @ ./Base.jl:42 [inlined]\n   [2] Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})\n     @ Main /tmp/tmpkc1pizqf.jl:26\n   [3] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpkc1pizqf.jl:36 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpkc1pizqf.jl:35\n  \n  caused\
    \ by: type String has no field s\n  Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42\
    \ [inlined]\n   [2] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpkc1pizqf.jl:24\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpkc1pizqf.jl:36 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpkc1pizqf.jl:35\ntest set:\
    \ Error During Test at /tmp/tmpkc1pizqf.jl:37\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  type String has no field s\n  Stacktrace:\n  \
    \ [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})\n     @ Main /tmp/tmpkc1pizqf.jl:26\n   [3] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpkc1pizqf.jl:37 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpkc1pizqf.jl:35\n  \n  caused\
    \ by: type String has no field s\n  Stacktrace:\n   [1] getproperty\n     "
  timestamp: 1660008784
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    Strongest_Extension_Helper(class_name,\
    \ extensions)\nend\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmp1l9bxfyc.jl:24

    '
  stdout: "test set: Error During Test at /tmp/tmp1l9bxfyc.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: Strongest_Extension_Helper not defined\n\
    \  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmp1l9bxfyc.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1l9bxfyc.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1l9bxfyc.jl:26\ntest set:\
    \ Error During Test at /tmp/tmp1l9bxfyc.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: Strongest_Extension_Helper not\
    \ defined\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmp1l9bxfyc.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1l9bxfyc.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1l9bxfyc.jl:26\ntest set:\
    \ Error During Test at /tmp/tmp1l9bxfyc.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  UndefVarError: Strongest_Extension_Helper\
    \ not defined\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmp1l9bxfyc.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1l9bxfyc.jl:29 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-"
  timestamp: 1660008783
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    #Your Code Here\n    Strongest_Extension_Counter\
    \ = sort(collect(zip(extensions, extensions.map(length))), rev=true)\n    \n \
    \   if length(Strongest_Extension_Counter) == length(extensions) \n        \n\
    \        Strongest_Extension_Counter = Strongest_Extension_Counter[1]\n      \
    \  \n    end \n    \n    return string(class_name) + Strongest_Extension_Counter[1]\n\
    end\n</cell>\n<text>\nPart 2: Implementing Extensions and Loaders\nNow that you\
    \ have learned about extension methods and how to implement them, we can implement\
    \ a load method which will load classes specified in the vector extensions. We\
    \ will need to add this load method to all classes in the vector classes.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpi01p1jhr.jl:31\nin expression starting at\
    \ /tmp/tmpi01p1jhr.jl:31\n"
  stdout: ''
  timestamp: 1660008781
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    extensions = sort!(extensions)\n \
    \   idx = 1\n    \n    # Loop through extensions \n    while idx<=length(extensions)\n\
    \        extension = extensions[idx]\n        uppercase_idx = upper(extension)\n\
    \        lowercase_idx = lower(extension)\n        \n        # Check if the extension\
    \ is strong\n        strong_extension = uppercase_idx-lowercase_idx\n        if\
    \ strong_extension>0\n            # If the extension is strong, return it\n  \
    \          return class_name . \".\" . extension\n        end\n        \n    \
    \    # Increment idx\n        idx = idx+1\n    end\nend\n</cell>\n<text>\nProblem\
    \ 4\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: space before \".\" not allowed in \"class_name\
    \ .\" at /tmp/tmpu7ijaa92.jl:32\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpu7ijaa92.jl:32\n\
    in expression starting at /tmp/tmpu7ijaa92.jl:32\n"
  stdout: ''
  timestamp: 1660008781
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    strengths = map(i->string_length(extensions[i]),\
    \ extensions)\n    idx = argmax(strengths)\n    return class_name + '.' + extensions[idx]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmp1d7a6u5a.jl:25

    '
  stdout: "test set: Error During Test at /tmp/tmp1d7a6u5a.jl:28\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  ArgumentError: invalid index: \"tEN\" of type String\n\
    \  Stacktrace:\n    [1] to_index(i::String)\n      @ Base ./indices.jl:300\n \
    \   [2] to_index(A::Vector{String}, i::String)\n      @ Base ./indices.jl:277\n\
    \    [3] to_indices\n      @ ./indices.jl:333 [inlined]\n    [4] to_indices\n\
    \      @ ./indices.jl:325 [inlined]\n    [5] getindex\n      @ ./abstractarray.jl:1218\
    \ [inlined]\n    [6] (::var\"#1#2\"{Vector{String}})(i::String)\n      @ Main\
    \ /tmp/tmp1d7a6u5a.jl:19\n    [7] iterate\n      @ ./generator.jl:47 [inlined]\n\
    \    [8] _collect\n      @ ./array.jl:744 [inlined]\n    [9] collect_similar\n\
    \      @ ./array.jl:653 [inlined]\n   [10] map\n      @ ./abstractarray.jl:2867\
    \ [inlined]\n   [11] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \      @ Main /tmp/tmp1d7a6u5a.jl:19\n   [12] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [13] macro expansion\n      @ /tmp/tmp1d7a6u5a.jl:28 [inlined]\n\
    \   [14] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [15] top-level scope\n      @ /tmp/tmp1d7a6u5a.jl:27\ntest set:\
    \ Error During Test at /tmp/tmp1d7a6u5a.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  ArgumentError: invalid index: \"nani\" of type\
    \ String\n  Stacktrace:\n    [1] to_index(i::String)\n      @ Base ./indices.jl:300\n\
    \    [2] to_index(A::Vector{String}, i::String)\n      @ Base ./indices.jl:277\n\
    \    [3] to_indices\n      @ ./indices.jl:333 [inlined]\n    [4] to_indices\n\
    \      @ ./indices.jl:325 [inlined]\n    [5] getindex\n      @ ./abstractarray.jl:1218\
    \ [inlined]\n    [6] (::var\"#1#2\"{Vector{String}})(i::String)\n      @ Main\
    \ /tmp/tmp1d7a6u5a.jl:19\n    [7] iterate\n      @ ./generator.jl:47 [inlined]\n\
    \    [8] _collect\n      @ ./array.jl:744 [inlined]\n    [9] collect_similar"
  timestamp: 1660008784
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n  strongest_extension = extensions.sorted()[1]\n\
    \  strongest_extension = strongest_extension.slice(begin, length(extension))\n\
    \  return class_name .+ strongest_extension\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \",\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpztz9t2bb.jl:20\nin expression starting at /tmp/tmpztz9t2bb.jl:20\n"
  stdout: ''
  timestamp: 1660008782
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \"\"\"Solution\n    \"\"\"\n    StrongestExtensionName\
    \ = \"\"\n    StrongestExtension = extensions[end]\n    \n    for extension in\
    \ extensions[2:end]\n        if (StrongestExtension >= extension)\n          \
    \  StrongestExtension = extensions[end]\n        end\n    end\n    \n    for extension\
    \ in extensions[2:end]\n        if (StrongestExtension < extension)\n        \
    \    StrongestExtension = extensions[end]\n        end\n    end\n    \n    StrongestExtensionName\
    \ = class_name .. \".\" .. StrongestExtension\n    return StrongestExtensionName\n\
    end\n</cell>\n<code language=julia-0.6>\n@time Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"]);\n</cell>\n<text>\nQuestion 5\nHow much time did it\
    \ take you to write your own implementation of this problem? If you have not had\
    \ the patience to wait for the right solution, try to come up with a faster solution\
    \ yourself.\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"function\" at /tmp/tmpcgar3asd.jl:18 expected\
    \ \"end\", got \"..\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpcgar3asd.jl:36\n\
    in expression starting at /tmp/tmpcgar3asd.jl:36\n"
  stdout: ''
  timestamp: 1660008782
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    strongest_extension_index = getindex(extensions,\
    \ strongest(extensions))\n    return strongest_extension_index == -1 ? class_name\
    \ : class_name .. \".\" .. \n    extensions[strongest_extension_index]\nend\n\
    </cell>\n<text>\nExercise 5\nUsing the above two functions, write a function which\
    \ takes in a string of any length and returns a vector of strings of all possible\
    \ combinations of the given length. This means that if you give your function\
    \ a string \"ABCD\" and a length of 3, then your function should return a vector\
    \ like this:\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplxqwfe57.jl:23\nin expression starting at\
    \ /tmp/tmplxqwfe57.jl:23\n"
  stdout: ''
  timestamp: 1660008782
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n\"\"\"\n    Strongest_Extension(class_name,\
    \ extensions::Vector{String}, strength::Int)\n\"\"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpqtm8ofh3.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpqtm8ofh3.jl:1\n\
    in expression starting at /tmp/tmpqtm8ofh3.jl:1\n"
  stdout: ''
  timestamp: 1660008782
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \"\"\"\n    You will be given the\
    \ name of a class (a string) and a vector of extensions.\n    The extensions are\
    \ to be used to load additional classes to the class. The\n    strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n    letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n  \
    \  in the extension's name, the strength is given by the fraction CAP - SM. \n\
    \    You should find the strongest extension and return a string in this \n  \
    \  format: ClassName.StrongestExtensionName.\n    If there are two or more extensions\
    \ with the same strength, you should\n    choose the one that comes first in the\
    \ vector.\n    For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    \    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"\n    strongest_extension=extensions[minimum((length(extensions)-extension.(lowercase(extensions))),1)]\n\
    \    return class_name+\".\"+strongest_extension\nend\n</cell>\n<code language=julia-1.5>\n\
    @testset \"strongest_extension\" begin\ntest=Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n@test test == \"my_class.AA\"\n@test test == \"my_class.Be\"\
    \n@test test == \"my_class.CC\"\nend\n</cell>\n<text>\nExtension Example: Loading\
    \ more classes to an existing class\nThe example below demonstrates a class of\
    \ 2 classes that we would like to add to our class named \"my_class\". \nThe first\
    \ class is named \"my_class\" and the second class is named \"Blahblah\". The\
    \ third class is named \"blahblah\". \nWe would like to load the third class to\
    \ the first class named \"my_class\". \nIn other words, we would like to add \"\
    blahblah\" to the class \"my_class\" using the extension \n\"Blahblah\". \nWe\
    \ will call our first class \"my_class\" the \"base\" class and the second class\
    \ \"Blahblah\" the \"extension\" class. \nTo load the third class \"blahblah\"\
    \ to the first class \"my_class\", we will use our extension class \"Blahblah\"\
    .\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptr200c3u.jl:40\nin expression starting at\
    \ /tmp/tmptr200c3u.jl:40\n"
  stdout: ''
  timestamp: 1660008782
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \nusing\
    \ Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpazc53kw0.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpazc53kw0.jl:1\n\
    in expression starting at /tmp/tmpazc53kw0.jl:1\n"
  stdout: ''
  timestamp: 1660008782
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    extension_class = split(class_name)[1]\n\
    \    sorted_extension = sort(extensions, by=length) \n    if length(extensions)\
    \ == 0 \n        return class_name\n    else \n        \n        best_strength\
    \ = Strongest_Extension_Strength(extension_class, extensions)\n        \n    \
    \    best_extension = sorted_extension[Strongest_Extension_Strength(extension_class,\
    \ extensions)] \n        \n        return join((class_name, best_extension)) \n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    Strongest_Extension_Strength(extension_name::String,\
    \ extensions::Vector{String})\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_jwrwwy0.jl:32\nin expression starting at\
    \ /tmp/tmp_jwrwwy0.jl:32\n"
  stdout: ''
  timestamp: 1660008782
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    Strength = length(extensions)\n\
    \    \n    if Strength == 0 \n        return class_name \n    \n    Extension_Name_Strength\
    \ = Dict{String, Int}()\n    \n    for ext_name in extensions \n        if isuppercase(ext_name)\n\
    \            ext_name = ext_name.toUpperCase()\n        elseif islowercase(ext_name)\n\
    \            ext_name = ext_name.toLowerCase()\n        else\n            continue\n\
    \        \n        \n        if contains(Extension_Name_Strength, ext_name)\n\
    \            Extension_Name_Strength[ext_name] += 1\n        else\n          \
    \  Extension_Name_Strength[ext_name] = 0\n        end\n    end\n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\
    \ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"for\" at /tmp/tmpfom2lklo.jl:27\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpfom2lklo.jl:1\n\
    in expression starting at /tmp/tmpfom2lklo.jl:1\n"
  stdout: ''
  timestamp: 1660008782
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    strongest_extension = extensions[1]\
    \ # We start with the second extension of the class\n    for e in extensions[2:length(extensions)]\
    \ \n        if isupper(e) && islower(strongest_extension) \n            strongest_extension\
    \ = e \n        else if isupper(strongest_extension) \n            strongest_extension\
    \ = strongest_extension\n        else\n            break\n    end\n    \n    return\
    \ string(class_name, strongest_extension)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpboewc_xp.jl:24\nin expression starting at\
    \ /tmp/tmpboewc_xp.jl:24\n"
  stdout: ''
  timestamp: 1660008782
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    s_extensions = Set(extensions)\n\
    \    for s_ext in s_extensions\n        s_cap = StringLength(s_ext)\n        s_sm\
    \ = StringLength(class_name)\n        s_strength = abs(s_cap - s_sm)\n       \
    \ \n        if s_strength == min(s_strength)\n            return class_name .+\
    \ \".\" + s_ext\n        end\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpjo_tiiit.jl:33

    '
  stdout: "test set: Error During Test at /tmp/tmpjo_tiiit.jl:36\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: StringLength not defined\n  Stacktrace:\n\
    \   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpjo_tiiit.jl:22\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpjo_tiiit.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpjo_tiiit.jl:35\ntest set:\
    \ Error During Test at /tmp/tmpjo_tiiit.jl:37\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: StringLength not defined\n  Stacktrace:\n\
    \   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpjo_tiiit.jl:22\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpjo_tiiit.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpjo_tiiit.jl:35\ntest set:\
    \ Error During Test at /tmp/tmpjo_tiiit.jl:38\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  UndefVarError: StringLength\
    \ not defined\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpjo_tiiit.jl:22\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpjo_tiiit.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpjo_tiiit.jl:35\n"
  timestamp: 1660008785
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    if extensions.size <= 1\n        return\
    \ class_name\n    end\n    strength = extensions[1] - extensions[1]\n    \n  \
    \  for e in extensions[2:end]\n        strength = strength if e < extension else\
    \ strength\n    end\n    return join(class_name, \".\", Strongest_Extension(class_name,\
    \ extensions[2:end]))\nend\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"for\" at /tmp/tmpqc56hdhp.jl:24 expected \"\
    end\", got \"if\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpqc56hdhp.jl:25\n\
    in expression starting at /tmp/tmpqc56hdhp.jl:25\n"
  stdout: ''
  timestamp: 1660008783
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_str = join.(extensions,\
    \ \".\")\n    strongest = extension_strength(extensions_str)\n    \n    Strongest_Extension_\
    \ = join.([class_name, strongest], \".\")\n    \n    return Strongest_Extension_\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpmbumob6t.jl:29

    '
  stdout: "test set: Error During Test at /tmp/tmpmbumob6t.jl:32\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: extension_strength not defined\n  Stacktrace:\n\
    \   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpmbumob6t.jl:21\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpmbumob6t.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpmbumob6t.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpmbumob6t.jl:33\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: extension_strength not defined\n\
    \  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpmbumob6t.jl:21\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpmbumob6t.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpmbumob6t.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpmbumob6t.jl:34\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  UndefVarError: extension_strength\
    \ not defined\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpmbumob6t.jl:21\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpmbumob6t.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/"
  timestamp: 1660008785
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    Strongest_Extension = class_name\
    \ + string(extensions)\n    return Strongest_Extension\nend\n</cell>\n<code language=julia-1.2>\n\
    # test your code\n@code_warntype Strongest_Extension(\"my_class\", [\"AA\", \"\
    Be\", \"CC\"]);\n</cell>\n<text>\nExercise 3\nIn the cell below, define a function\
    \ called is_permutation that takes a character and an alphabet, and checks if\
    \ the character is a permutation of the alphabet.\nusing Test\n\n@testset begin\n\
    \ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp82lxlqcp.jl:23\nin expression starting at\
    \ /tmp/tmp82lxlqcp.jl:23\n"
  stdout: ''
  timestamp: 1660008783
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    strongest = extensions[1]\n    for\
    \ strongest1 in extensions \n        if strongest1 < strongest \n            strongest\
    \ = strongest1\n        end\n    end\n    \n    \"$class_name.$strongest\"\nend\n\
    </cell>\n<code language=julia-1.6>\n# Tests\n@test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"]) \u2248 \"my_class.AA\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"]) \u2248 \"my_class.AA\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"ee\", \"ff\", \"gg\"]) \u2248 \"\
    my_class.AA\"\n@test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    , \"DD\", \"ee\", \"ff\", \"gg\", \"hh\"]) \u2248 \"my_class.AA\"\n</cell>\n<text>\n\
    \u25CF Question 12 - Apart from the extension, what is a class?\nusing Test\n\n\
    @testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxeomzg6s.jl:28\nin expression starting at\
    \ /tmp/tmpxeomzg6s.jl:28\n"
  stdout: ''
  timestamp: 1660008783
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    sorted_extensions = sort(extensions)\n\
    \    strength = 0\n    if length(sorted_extensions) > 1\n        strength = CAP\
    \ - SM\n    end\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpn_vvbku7.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpn_vvbku7.jl:1\n\
    in expression starting at /tmp/tmpn_vvbku7.jl:1\n"
  stdout: ''
  timestamp: 1660008783
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    extensions_count = count(extensions)\n\
    \    if extensions_count == 0 \n        return class_name\n    elseif extensions_count\
    \ == 1 \n        return class_name + extensions[0]\n    end\n    \n    strongest_extension_strength\
    \ = -1\n    extensions_strongest_strength = [:] #the extensions strongest strength\n\
    \    for e in extensions \n        extension_strength = length(e) - length(lowercase(last(e)))\n\
    \        if extension_strength > strongest_extension_strength\n            strongest_extension_strength\
    \ = extension_strength\n            extensions_strongest_strength = [e]\n    \
    \    else \n            push!(extensions_strongest_strength, e)\n        end\n\
    \    end\n    \n    extensions_strongest_strength = sort(extensions_strongest_strength)\n\
    \    \n    chosen_extension = extensions_strongest_strength[1]\n    chosen_extension\
    \ = lowercase(chosen_extension)\n    \n    return class_name + chosen_extension\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpx7ha31at.jl:47

    '
  stdout: "test set: Error During Test at /tmp/tmpx7ha31at.jl:50\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  TypeError: non-boolean (String) used in boolean context\n\
    \  Stacktrace:\n    [1] _simple_count\n      @ ./reduce.jl:1206 [inlined]\n  \
    \  [2] _count\n      @ ./reducedim.jl:407 [inlined]\n    [3] #count#735\n    \
    \  @ ./reducedim.jl:405 [inlined]\n    [4] #count#734\n      @ ./reducedim.jl:404\
    \ [inlined]\n    [5] count\n      @ ./reducedim.jl:404 [inlined]\n    [6] Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})\n      @ Main /tmp/tmpx7ha31at.jl:19\n    [7] macro\
    \ expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [8] macro expansion\n      @ /tmp/tmpx7ha31at.jl:50 [inlined]\n\
    \    [9] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [10] top-level scope\n      @ /tmp/tmpx7ha31at.jl:49\ntest set:\
    \ Error During Test at /tmp/tmpx7ha31at.jl:51\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  TypeError: non-boolean (String) used in boolean\
    \ context\n  Stacktrace:\n    [1] _simple_count\n      @ ./reduce.jl:1206 [inlined]\n\
    \    [2] _count\n      @ ./reducedim.jl:407 [inlined]\n    [3] #count#735\n  \
    \    @ ./reducedim.jl:405 [inlined]\n    [4] #count#734\n      @ ./reducedim.jl:404\
    \ [inlined]\n    [5] count\n      @ ./reducedim.jl:404 [inlined]\n    [6] Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})\n      @ Main /tmp/tmpx7ha31at.jl:19\n    [7] macro\
    \ expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [8] macro expansion\n      @ /tmp/tmpx7ha31at.jl:51 [inlined]\n\
    \    [9] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [10] top-level scope\n      @ /tmp/tmpx7ha31at.jl:49\ntest set:\
    \ Error During Test at /tmp/tmpx7ha31at.jl:52\n  Test threw exception\n  Expression:\
    \ candidate(\"__YE"
  timestamp: 1660008785
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    #your code here\n    return class_name\
    \ ## add your solution\nend\n</cell>\n<code language=julia-1.5>\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n</cell>\n<code language=julia-1.5>\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"]) == \"\
    my_class.AA\"\n</cell>\n<code language=julia-1.5>\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"Ee\"]) == \"my_class.AA\"\n</cell>\n\
    <code language=julia-1.5>\n@test Strongest_Extension(\"my_class\", [\"AA\", \"\
    Be\", \"CC\", \"DD\", \"Ee\", \"Ff\"]) == \"my_class.AA\"\n</cell>\n<text>\nWrite\
    \ a function that returns a new instance of the class given its name and extensions\
    \ vector.\n    Example:\n    >>> New(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n\
    \    my_class.AA\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjh3gc90y.jl:22\nin expression starting at\
    \ /tmp/tmpjh3gc90y.jl:22\n"
  stdout: ''
  timestamp: 1660008783
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n\"\"\"\n@doc strongest_extension\n\"\"\
    \"\n    Extension_Names = sort(unique(extensions), by = length) # Get the unique\
    \ extensions and their lengths\n    \n    # Get the number of capital letters\
    \ in the class name and the number of lowercase letters\n    # in the class name\n\
    \    CAP_lowercase_letters = findall(x->x == x[1], lower(class_name))\n    \n\
    \    \n    \n    # Get the strongest extension\n    Strength = Inf\n    \n   \
    \ # Loop over all extensions \n    for extension in Extension_Names\n        \n\
    \        # Find the number of capital letters in extension\n        CAP_extension\
    \ = findall(x->x == x[1], lower(extension))\n        \n        # Find the number\
    \ of lowercase letters in extension\n        SM = length(CAP_extension) - length(CAP_lowercase_letters)\n\
    \        \n        # Compute the strength\n        Strength = min(Strength, CAP_extension.length\
    \ - SM)\n    end\n    \n    # return the class name with the strongest extension\n\
    \    return class_name * \".\" + Strongest_Extension_String(class_name, extensions,\
    \ Strength)\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptrqz1_4l.jl:49\nin expression starting at\
    \ /tmp/tmptrqz1_4l.jl:49\n"
  stdout: ''
  timestamp: 1660008784
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    strongest_extension = extensions[1]\n\
    \    \n    for i in 2:length(extensions)\n        strongest_extension = min(strongest_extension,\
    \ extensions[i])\n    end\n    \n    return class_name + \".\" + strongest_extension\n\
    end\n</cell>\n<code language=julia-1.1>\nusing Pkg\nPkg.add(\"Plots\")\nPkg.add(\"\
    Interpolations\")\nPkg.add(\"FileIO\")\nPkg.add(\"Statistics\")\nPkg.add(\"Random\"\
    )\nPkg.add(\"RandomMeasurements\")\nPkg.add(\"CSV\")\nPkg.add(\"DataFrames\")\n\
    Pkg.add(\"LinearAlgebra\")\nPkg.add(\"DataFrames\")\n</cell>\n<code language=julia-1.1>\n\
    # Loading the data\ndataframe = CSV.read(\"../data/processed.csv\", DataFrame);\n\
    </cell>\n<code language=julia-1.1>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpk1jucy8w.jl:28\nin expression starting at\
    \ /tmp/tmpk1jucy8w.jl:28\n"
  stdout: ''
  timestamp: 1660008783
- exit_code: -1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    if length(extensions)\
    \ == 0 \n        return class_name\n    elseif length(extensions) == 1\n     \
    \   return Strongest_Extension(extensions[0], extensions)\n    elseif Strongest_Extension(extensions[1],\
    \ extensions) == \"\" \n        return Strongest_Extension(extensions[0], extensions)\n\
    \    end\n    \n    strongest_extension = extensions[1]\n    for extension in\
    \ extensions[2:length(extensions)]\n        if Strongest_Extension(extension,\
    \ extensions) == \"\"\n            return strongest_extension\n        end\n \
    \   end\n    return strongest_extension\nend\nusing Test\n\n@testset begin\n\n\
    candidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660008788
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \"\"\"\n    Strongest_Extension(class_name,\
    \ extensions)\n    \n    Inputs:\n        class_name:  Name of the class we are\
    \ looking for\n        extensions:  Vector containing the extensions name\n  \
    \      \n    Outputs:\n        string containing the name of the strongest extension\n\
    \    \"\"\"\n    extension = extensions[minimum(map(x->length(x),extensions))]\n\
    \    if length(extension) > length(class_name)\n        ext = extension\n    else\n\
    \        ext = class_name\n    end\n    return ext\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 9 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmxu__rdg.jl:39

    '
  stdout: "test set: Test Failed at /tmp/tmpmxu__rdg.jl:42\n  Expression: candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\n   Evaluated:\
    \ \"eIGHt8OKe\" == \"Watashi.eIGHt8OKe\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpmxu__rdg.jl:42 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpmxu__rdg.jl:41\ntest set: Test Failed at /tmp/tmpmxu__rdg.jl:43\n\
    \  Expression: candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\n   Evaluated: \"32145tggg\" == \"Boku123.YEs.WeCaNe\"\
    \nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmxu__rdg.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmxu__rdg.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpmxu__rdg.jl:44\n  Expression: candidate(\"__YESIMHERE\", [\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"\
    __YESIMHERE.NuLl__\"\n   Evaluated: \"__YESIMHERE\" == \"__YESIMHERE.NuLl__\"\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmxu__rdg.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmxu__rdg.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpmxu__rdg.jl:45\n  Expression: candidate(\"K\", [\"Ta\", \"\
    TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\n   Evaluated: \"TAR\" == \"K.TAR\"\
    \nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmxu__rdg.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-leve"
  timestamp: 1660008785
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    strongest_extension = [extensions[i]\
    \ for\n                             i in sortperm(length(extensions))]\n    return\
    \ String(class_name) + strongest_extension[1]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmph288zgz8.jl:25

    '
  stdout: "test set: Error During Test at /tmp/tmph288zgz8.jl:28\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  MethodError: no method matching sortperm(::Int64)\n  Closest\
    \ candidates are:\n    sortperm(!Matched::AbstractUnitRange) at ~/.conda/envs/polyglot/share/julia/base/range.jl:1309\n\
    \    sortperm(!Matched::AbstractRange) at ~/.conda/envs/polyglot/share/julia/base/range.jl:1310\n\
    \    sortperm(!Matched::AbstractVector; alg, lt, by, rev, order) at ~/.conda/envs/polyglot/share/julia/base/sort.jl:907\n\
    \  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmph288zgz8.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmph288zgz8.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmph288zgz8.jl:27\ntest set:\
    \ Error During Test at /tmp/tmph288zgz8.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  MethodError: no method matching sortperm(::Int64)\n\
    \  Closest candidates are:\n    sortperm(!Matched::AbstractUnitRange) at ~/.conda/envs/polyglot/share/julia/base/range.jl:1309\n\
    \    sortperm(!Matched::AbstractRange) at ~/.conda/envs/polyglot/share/julia/base/range.jl:1310\n\
    \    sortperm(!Matched::AbstractVector; alg, lt, by, rev, order) at ~/.conda/envs/polyglot/share/julia/base/sort.jl:907\n\
    \  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmph288zgz8.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmph288zgz8.jl:29 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmph288zgz8.jl:27\ntest"
  timestamp: 1660008786
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \nusing Test\n\n@testset begin\n\n\
    candidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_e6urwoq.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_e6urwoq.jl:1\n\
    in expression starting at /tmp/tmp_e6urwoq.jl:1\n"
  stdout: ''
  timestamp: 1660008784
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    s = 0 \n    for e in extensions \n\
    \        if toupper(e) .== toupper(class_name) \n            s = s + 1\n     \
    \   end\n    end\n    s = s/length(extensions)\n    for e in extensions \n   \
    \     if tolower(e) .== tolower(class_name) \n            s = s + 1\n        end\n\
    \    end\n    s = s/length(extensions)\n    if s == 0 \n        error(\"no extensions\
    \ of that class\")\n    end\n    if s == length(extensions) \n        error(\"\
    no extensions of that class\")\n    end\n    s = \"%s.%s\"%(class_name, extensions[findmin(s)])\n\
    \    return s\nend\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpntgdgav0.jl:43

    '
  stdout: "test set: Error During Test at /tmp/tmpntgdgav0.jl:46\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: toupper not defined\n  Stacktrace:\n   [1]\
    \ Strongest_Extension(class_name::String, extensions::Vector{String})\n     @\
    \ Main /tmp/tmpntgdgav0.jl:21\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpntgdgav0.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpntgdgav0.jl:45\ntest set:\
    \ Error During Test at /tmp/tmpntgdgav0.jl:47\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: toupper not defined\n  Stacktrace:\n\
    \   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpntgdgav0.jl:21\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpntgdgav0.jl:47 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpntgdgav0.jl:45\ntest set:\
    \ Error During Test at /tmp/tmpntgdgav0.jl:48\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  UndefVarError: toupper not\
    \ defined\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpntgdgav0.jl:21\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpntgdgav0.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpntgdgav0.jl:45\ntest set:\
    \ Error"
  timestamp: 1660008786
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    extensions.sort!\n    Strength = extensions[1].count()\
    \ - extensions[0].count()\n    if Strength == -1 \n        return class_name\n\
    \    elseif Strength == 0 \n        return class_name\n    else\n        return\
    \ \"{}.{}{}\".format(class_name, extensions[1], extensions[2])\n    end\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThis works, however, the method signature is incorrect.\
    \ It should be `Strongest_Extension(class_name::String, extensions::Vector{String})`,\
    \ with one additional `::String` after the `class_name`.\n<|/ c |>\n<| c |>\n\
    Thanks, I have made corrections. And I have also fixed the answer, I misread the\
    \ question and thought you wanted to pass vector of strings as an argument. Thanks\
    \ for pointing this out!\n<|/ c |>\n<| a dscore=1 |>\nThe answer is already given,\
    \ but I will add my 2 cents. \nI find it easier to keep track of the extensions\
    \ separately and then sort them alphabetically later, because sorting them alphabetically\
    \ makes it easier to know which extensions are used the most. \n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxu5yfdo2.jl:29\nin expression starting at\
    \ /tmp/tmpxu5yfdo2.jl:29\n"
  stdout: ''
  timestamp: 1660008784
