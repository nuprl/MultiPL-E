name: HumanEval_104_unique_digits
language: jl
prompt: "\"\"\"Given a vector of positive integers x. return a sorted vector of all\
  \ \n    elements that hasn't any even digit.\n\n    Note: Returned vector should\
  \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
  \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
  \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n"
tests: "using Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
  \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
  \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
  \ 103, 31]) == [31, 135])\nend\n"
completions: ["    if length(x) ==0\n        return Vector{Int64}()\n    end\n   \
    \ flag = x[1]\n    flag2 = flag^2\n    \n    unique = Vector{Int64}()\n    unique_digit(x[1:end-1],\
    \ flag2, unique)\n    unique_digit(x[2:end], flag2, unique)\n    unique\nend",
  "    \n    sorted_digits = sort(x)\n    unique_digits = Set()\n    for k in sorted_digits\n\
    \        unique_digits += find_unique_digits(k)\n    end", "    unique_vals =\
    \ Set()\n    for val in x\n        if val%2 == 0\n            unique_vals.add(val)\n\
    \        end\n    end\n    return unique_vals\nend", "    if length(x) == 0 then\
    \ return [] end\n    flag = x.!=0::Vector{Int64}\n    count = count_elem(divrem(x\
    \ .- flag, 2))::Vector{Int64}\n    \n    count_unique_digits(flag, count, x)\n\
    end", "    digits = unique(x.collect{|x| x % 10})\n    \n    for d in digits[2:end]\n\
    \        if x == 0\n            return x\n        elseif x == d % 10\n       \
    \     return x\n        else\n            return x + d % 10\n        end\n   \
    \ end\n    return x\nend", "    unique = Set()\n    \n    for i in x\n       \
    \ if unique.contains(i)\n            continue\n        push!(unique, i)\n    end\n\
    \    return unique\nend\n</cell>\n<code language=julia-1.4>\nunique_digits([15,\
    \ 33, 1422, 1])\n</cell>\n<text>\nProblem 9\nGiven a vector of positive integers\
    \ x. return a sorted vector of all elements that hasn't any even digit from x.",
  "    unique_digits = Vector{Int64}()\n    for elem in x\n        if elem % 2 ==\
    \ 0\n            unique_digits = [elem | unique_digits]\n        end\n    end\n\
    \    unique_digits\nend\n</cell>\n<text>\nExercise 5: Unique Letters\nWrite a\
    \ function that returns a sorted vector of all elements that hasn't \nany duplicate\
    \ letters.", "    \n\"\"\"\nGiven a vector of positive integers x. return a sorted\
    \ vector of all \n    elements that hasn't any odd digit.", "    return sorted(\
    \ x[findfirst(x->x==0)==0] )\nend", "    \n    sorted_digits = sort(x)\n    \n\
    \    new_digits = []\n    for i in x\n        if i mod 2 == 0\n            new_digits.push(i)\n\
    \        end\n    end", "    \n    unique = Set()\n    result = Vector{Int64}()\n\
    \    for x in x\n        push!(unique, mod(x, 10))\n    end\n    for i in unique\n\
    \        push!(result, i)\n    end\n    sort(unique, by = x->x)\n    result\n\
    end\n</cell>\n<cell>\n\"\"\"Given a vector of positive integers, return the first\
    \ and last unique elements.", "    if length(x)==0 \n        return [] \n    \n\
    \    digits = unique(digits(x))\n    \n    unique_digits = Set{Int64}()\n    unique_digits\
    \ = unique_digits + digits\n    \n    unique_digits = unique_digits - digits\n\
    \    \n    unique_digits = Vector{Int64}(unique_digits)\n    \n    unique_digits\n\
    end\n</cell>\n<code language=julia-1.6>", "    \n    unique_digits = Vector{Int64}(undef,\
    \ length(x))\n    for ii in eachindex(x)\n        if ii > 0 && mod(x[ii], 10)\
    \ == 0 \n            push!(unique_digits, x[ii])\n        end\n    end\n    return\
    \ unique_digits\nend\n</cell>\n<text>\nQuestion 6. How many digits (from 1 to\
    \ 20) in the vector below?", "    if length(x)==0 \n        return x \n    \n\
    \    # Initialize a flag and an auxiliary vector\n    flag=trues(length(x))\n\
    \    aux=zeros(Int, length(x))", "    if length(x) == 0 \n        return Vector{Int64}()\
    \ \n    else \n        result = []\n        for i in 1:length(x) \n          \
    \  if x[i] % 2 != 0 \n                push!(result, x[i]) \n            end \n\
    \        end \n    end \n    unique_digits2(result)\nend \n</cell>\n<code language=julia-1.5>\n\
    # Preparing data for modeling\ndf = CSV.read(\"../data/german_credit_data.csv\"\
    )\nx = convert(Vector{Int64}, df.Creditability)\n</cell>\n<code language=julia-1.5>\n\
    # Splitting data into training and test data\nx_train, x_test, y_train, y_test\
    \ = train_test_split(x, df.default,\n                                        \
    \            test_size=0.2, shuffle=true);\n</cell>\n<code language=julia-1.5>\n\
    # Fitting Naive Bayes model\n# clf = NaiveBayes(BayesClassifier)\nclf = NaiveBayes(MultinomialClassifier)\n\
    clf.fit(x_train, y_train);\n</cell>\n<code language=julia-1.5>\n# Testing the\
    \ model\ny_pred = clf.predict(x_test)\n</cell>\n<code language=julia-1.5>\n# Creating\
    \ confusion matrix \ncm = confusion_matrix_plot([y_test, y_pred], [\"true\", \"\
    pred\"]);\n</cell>\n<code language=julia-1.5>\n# Testing model\naccuracy = accuracy_score(y_test,\
    \ y_pred);\nprecision = precision_score(y_test, y_pred);\nrecall = recall_score(y_test,\
    \ y_pred);\nf1 = f1_score(y_test, y_pred);\n</cell>\n<code language=julia-1.5>\n\
    # Plotting ROC curve\n# Plotting ROC curve\nroc = roc_curve(y_test, clf.predict_proba(x_test)[:,\
    \ 1]);\nplot(roc[1], roc[2])\n</cell>\n<code language=julia-1.5>\n# Predicting\
    \ probabilities\nprobabilities = clf.predict_proba(x_test)[:, 1]\n</cell>\n<code\
    \ language=julia-1.5>\n# Predicting probabilities\nprobabilities = clf.predict_proba(x_test)[:,\
    \ 1]\n</cell>\n<code language=julia-1.5>\n# Predicting probabilities\nprobabilities\
    \ = clf.predict_proba(x_test)[:, 1]\n</cell>\n<code language=julia-1.5>\n# Getting\
    \ y_score\ny_score = clf.predict_proba(x_test)[:, 1]\n</cell>\n<code language=julia-1.5>\n\
    # Getting class with max probability\nprediction = argmax(y_score);\nprediction\n\
    </cell>\n<code language=julia-1.5>\n# Getting class with max probability\nprediction\
    \ = argmax(y_score);\nprediction\n</cell>\n<code language=julia-1.5>\n# ", " \
    \   for i in eachindex(x)\n        digit = mod(x[i], 10)\n        if digit ==\
    \ 0 \n            continue\n        x[i] = x[i] // 10\n        if x[i] % 2 ==\
    \ 0\n            x = append(x, x[i])\n        else\n            x = x[1:end]\n\
    \        end\n    end\n    return x\nend\n</cell>\n<cell>\nunique_digits([15,\
    \ 33, 1422, 1])\n</cell>\n<text>\nExercise: \nWrite a function to count the number\
    \ of unique digits within a vector.", "    \n    \n    for i in x\n        even_index\
    \ = (rem(x, 10)%2) == 0\n        push!(unique_digits, x[i]) if(even_index)\n \
    \   end\n    return x\nend\n</cell>\n<code language=julia-1.3>\n@testset \"unique_digits\"\
    \ begin\n    vector1 = [15, 33, 1422, 1]\n    vector2 = [152, 323, 1422, 10]\n\
    \    \n    ans1 = [1, 15, 33]\n    ans2 = []\n    @test unique_digits(vector1)\
    \ isa Vector{Int64} && @test unique_digits(vector2) isa Vector{Int64}\n    @test\
    \ unique_digits(ans1) isa Vector{Int64} && @test unique_digits(ans2) isa Vector{Int64}\n\
    \    @test unique_digits(vector1) === ans1 && @test unique_digits(vector2) ===\
    \ ans2\nend\n</cell>\n<text>\nProblem 4.5 Finding unique characters in string\
    \ and their count\nGiven a string s, find the number of unique characters and\
    \ the count of each character. Return the sorted vector [ (unique characters,\
    \ count of characters) ] sorted. Sorted is descending. \nIf the character occurs\
    \ more than once, count only once.", " \n    for i in x:\n        \n        if\
    \ x[i] == 0\n            \n            continue\n            \n        elseif\
    \ i%2 == 0\n            \n            return x\n            \n        else\n \
    \           \n            x[i] = x[i]/2\n            \n            return unique_digits(x)\n\
    \            \n        end\n        \n    end\n    return unique(x)\nend\n</cell>\n\
    <text>\nWrite a function that given two positive integers x and y, will return\
    \ whether or not they are palindrome.", "    for i in x\n        !iszero(i % 10)\
    \ ? (push!(res, i) : nothing) \n    end\n    res\nend", "    \n    for i in 1..length(x)\n\
    \        push!(x, x[i]) \n    end\n    x\nend\n    \n\"\"\"\n    Solution to question\
    \ 2\n\"\"\"", "    sorted=sort(x)\n    sorted\n    last=sorted[1]\n    for i in\
    \ last:\n        sorted=sorted[findfirst(x .== i) == 1]\n    end\n    last\nend",
  "    if length(x) == 0\n        []\n    else\n        [i for i in x if !(i % 2)]\n\
    \    end\nend\n</cell>\n<code language=julia-0.4>\n@test unique_digits([1,3])\
    \ == [1,3]\n@test unique_digits([1]) == [1]\n@test unique_digits([1,2,3]) == [1,3,2]\n\
    @test unique_digits([2,7,9]) == [2,3,7,9]\n@test unique_digits([12,2,3,4]) ==\
    \ [1,2,3,4,12]\n@test unique_digits([1, 3]) == [1, 3]\n</cell>\n<text>\n4. Sort\
    \ a vector of positive integers", "    uniques = Set{Int64}() \n    for i in x\n\
    \        if i in uniques\n            continue \n        push!(uniques, i) \n\
    \    end\n    uniques\nend\n</cell>\n<code language=julia-1.3>", "  \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n", "    \n    unique_digits = Vector{Int64}()\n\
    \    \n    for n in x\n        if n % 2 == 0\n            push!(unique_digits,\
    \ n)\n        end\n    end", "    \n    answer = Vector{Int64}()\n    \n    for\
    \ i in x\n        \n        local found = false\n        \n        for j in answer\n\
    \            if i % 10 == j % 10\n                found = true\n             \
    \   break\n            end\n        end\n        \n        if found == false\n\
    \            push!(answer, i)\n        end\n    end\n    return answer\nend\n\
    </cell>\n<code language=julia-1.5>", "    y=sort(x)\n    map(x->push!(y[x],Int64(0)),2:end-1)\n\
    \    y\nend\n</cell>\n<text>\n2.8 Sorting by descending order and increasing order\n\
    Given a vector of positive integers x. return a sorted vector of all \n    elements\
    \ that hasn't any odd digit and all elements that hasn't any even digit.", " \
    \   unique_digits = Vector{Int64}[]\n    for n in x\n        if n % 2 == 0 &&\
    \ length(unique_digits) < length(unique_digits) + 1 \n            push!(unique_digits,\
    \ n) \n        else\n            unique_digits = [] \n        end\n    end\n \
    \   unique_digits\nend", "    if length(x)==0 \n        return x \n    \n    #\
    \ Initialize result vector\n    res = Vector{Int64}() \n    \n    # Sort x first\n\
    \    sort(x) \n    \n    # Initialize a variable to store the last element of\
    \ x\n    # Since x is sorted, the last element must be the first element of x\
    \ \n    last = x[1]\n    \n    # Iterate through the vector\n    for element in\
    \ x \n        \n        # If element is even, remove it from the vector\n    \
    \    if (element % 2) == 0 \n            res = delete(res, first(res, last)) \n\
    \        end\n        \n        # Update last \n        last = element\n    end\n\
    \    \n    # Return result\n    res\nend\n</cell>\n<code language=julia-1.3>\n\
    @testset \"Test unique_digits\" begin\n    vector1 = [15, 33, 1422, 1]\n    \n\
    \    @test unique_digits(vector1) === [1, 1, 15, 33]\n    @test unique_digits(Vector{Int}())\
    \ === []\nend\n</cell>\n<text>\nPart 6: Palindrome number check\nWrite a function\
    \ that checks if a number is a palindrome. Your function should accept a vector\
    \ of any integers, and should return a vector of booleans.", "    \n    n=length(x)\n\
    \    y=Vector{Int64}()\n    \n    for k=1:n\n        \n        if mod(x,k)==0\
    \ \n            push!(y,x)\n        end\n    end", "    \n\"\"\"\nGiven a vector\
    \ of positive integers x. return a sorted vector of all \n    elements that hasn't\
    \ any even digit and all elements that hasn't any \n    odd digit.", "   for i\
    \ in eachindex(x) do \n    if x[i] % 2 == 0 then \n        push!(x, x[i]) \n \
    \   end \n   end\n   return x \nend\n</cell>\n<code language=julia-1.0>", "  \
    \  unique_digits_helper(x)\nend", "    digits = unique(x) // filter using no even\
    \ numbers\n    \n    return sort(filter(x->x % 2 != 0, digits)) \nend\n</cell>\n\
    <code language=julia-1.4>\n@code_warntype unique_digits([15, 33, 1422, 1])\n</cell>\n\
    <code language=julia-1.4>\n@code_warntype unique_digits([152, 323, 1422, 10])\n\
    </cell>\n<text>\nExercise: Create a function that can return all the prime numbers\
    \ that less than or equal to given number.\nThis function is similar to unique_digits().\
    \ Try to use filter function in filter function", "    unique_numbers = Vector{Int64}()\n\
    \    for i in x\n        if i mod 2 eq 0\n            push!(unique_numbers, i)\n\
    \        end\n    end\n    return unique_numbers\nend\n</cell>\n<text>\nExercise",
  "    \n    return x[x>0] \nend\n</cell>\n<code language=julia-1.3>", "    for i\
    \ in x:\n        if i mod 2 ==0\n            x.push(i)\n        end\n    end\n\
    \    return x\nend", "    \n    local res\n    local i\n    for i = 1:length(x)\
    \ do\n        if x[i] mod 2 == 0 then\n            if !contains(res, x[i]) then\n\
    \                push!(res, x[i])\n            end\n        end\n    end\n   \
    \ return res\nend", "    \n    if isnothing(x) || x == []\n        return Vector{Int64}()\n\
    \    end", "    \n    unique_digits=[]\n    \n    local u=0\n    local j=0\n \
    \   \n    for i in length(x)\n        \n        if x[i]%2==0\n            u=u+(x[i]/2)\n\
    \        else\n            j=j+1\n            \n            while x[j]%2==0\n\
    \                j=j+1\n            end\n            \n            unique_digits=[u,i,j]\
    \ \n            \n            if j==length(x)\n                \n            \
    \    unique_digits=[x[1],x[2],u]\n            end\n        end\n    end\n    \n\
    \    return unique_digits\nend\nunique_digits([15,33,1422,1])\n</cell>\n<code\
    \ language=julia-0.6>\n@assert unique_digits([15,33,1422,1]) == [1, 15, 33]\n\
    @assert unique_digits([152,323,1422,10]) == []\n</cell>\n<text>\nProblem 3\nWrite\
    \ a function that counts how many times a given value is repeated in the given\
    \ array. \nFor example, if the given array is [14, 11, 10, 8, 8, 7, 11, 15] it\
    \ should return that 11 appears 3 times and 10 appears 2 times.", "    len = length(x)\n\
    \    even = findall(x .== 0)\n    odd = findall(x  mod 2 .!= 0)\n    return setdiff(unique(x),\
    \ even)\nend\n</cell>\n<code language=julia-0.6>\nunique_digits(x)\n</cell>\n\
    <code language=julia-0.6>\ny = rand(10)\nunique_digits(y)\n</cell>\n<code language=julia-0.6>\n\
    using PyPlot\nx = 1:10\ny = rand(10)\np = plot(x,y)\n</cell>\n<code language=julia-0.6>\n\
    unique_digits(y)\n</cell>\n<code language=julia-0.6>\np = plot(x,unique_digits(y))\n\
    </cell>\n<code language=julia-0.6>\n# find the unique digits of the numbers in\
    \ x using PyPlot\nusing PyPlot\nx = rand(10)\ny = rand(10)\np = plot(x,y)\n</cell>\n\
    <code language=julia-0.6>\nunique_digits(y)\n</cell>\n<code language=julia-0.6>\n\
    p = plot(x,unique_digits(y))\n</cell>\n<code language=julia-0.6>\nusing PyPlot\n\
    x = 1:10\ny = rand(10)\np = plot(x,y)\n</cell>\n<code language=julia-0.6>\nunique_digits(y)\n\
    </cell>\n<code language=julia-0.6>\np = plot(x,unique_digits(y))\n</cell>\n<code\
    \ language=julia-0.6>\nusing PyPlot\nx = 1:10\ny = rand(10)\np = plot(x,y)\n</cell>\n\
    <code language=julia-0.6>\nunique_digits(y)\n</cell>\n<code language=julia-0.6>\n\
    p = plot(x,unique_digits(y))\n</cell>\n<code language=julia-0.6>\nusing PyPlot\n\
    x = 1:10\ny = rand(10)\np = plot(x,y)\n</cell>\n<code language=julia-0.6>\nunique_digits(y)\n\
    </cell>\n<code language=julia-0.6>\np = plot(x,unique_digits(y))\n</cell>\n<code\
    \ language=julia-0.6>\nusing PyPlot\nx = 1:10\ny = rand(10)\np = plot(x,y)\n</cell>\n\
    <code language=julia-0.6>\nunique_digits(y)\n</cell>\n<code language=julia-0.6>\n\
    p = plot(x,unique_digits(y))\n</cell>\n<code language=julia-0.6>\nusing PyPlot\n\
    x = 1:10\ny = rand(10)\np = plot(x,y)\n</cell>\n<code language=julia-0.6>\nunique_digits(y)\n\
    </cell>\n<code language=julia-0.6>\np = plot(x,unique_digits(y))\n</", "    digits\
    \ = map(x % 10, x)\n    uniq_digits = filter(x -> all(x != digits), x)\n    uniq_digits.sort\n\
    end", "    unique_digits_ = Set()\n    unique_digits_ = [i for i in x if i not\
    \ in unique_digits_] \n    return unique_digits_\nend \n    \n\"\"\"\n    Solution\
    \ of the problem is more or less same as before.\n    We add 'x' to the vector\
    \ of all digits and then sort the vector.", "    y = Vector{Int64}()\n    for\
    \ i in x\n        if i mod 2 == 0\n            push!(y, i)\n        end\n    end\n\
    \    y\nend\n</cell>\n<text>\nQ. Implement function unique_digits_v2() that does\
    \ the same thing as unique_digits() but returns indices of the elements that hasn't\
    \ any even digit.", "    \n    sz = length(x)\n    seen = Set()\n    \n    # sort\
    \ x\n    sorted = sort(x)\n    \n    # traverse x to check if it has a seen digit\n\
    \    for i in 1:sz\n        if !seen[x[i]]\n            x[i] = Int64(-1)\n   \
    \         seen[x[i]] = true\n        end\n    end", "    digits_not_even = filter(x->mod(x,2)\
    \ ~= 0, x)\n    return sort(unique(digits_not_even))\nend", "    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n", "  unique = Set{Int64}()\n  for e in x\
    \ \n    if unique[e % 10] == 0 \n      unique[e % 10] = e\n    else\n      return\
    \ []\n    end\n  end\n  return sort(unique)\nend", "    for n in x do \n     \
    \   if n%2 == 0 \n            push!(results,n) \n        end\n    end\n    sort(results)\
    \ \nend\n</cell>\n<code language=julia-1.1>\n#1\n\"\"\"\n    unique_digits(x::Vector{Int})",
  "    l = length(x)\n    if l == 0\n        return []\n    unique_digit_set = Set()\n\
    \    for i in x\n        unique_digit_set.add(i)\n    end\n    unique_digit_set\n\
    end\n</cell>\n<code language=julia-1.5>\nunique_digits([10, 2, 11, 3, 3])\n</cell>\n\
    <text>\nProblem 9: Find all possible combinations of sums of numbers in vector",
  "    uniques = Set()\n    for i in x\n        uniques += digits(i)\n    end\n  \
    \  return collect(uniques)\nend\n</cell>\n<code language=julia-1.4>\n\"\"\"\n\
    Given a vector of positive integers x. return a sorted vector of all \n    elements\
    \ that hasn't any odd digit.", "    \n    # Create a dictionary to store the sorted\
    \ unique elements\n    unique_digits = Dict()\n    \n    for i in x\n        unique_digits[i]\
    \ = i \n    end\n    \n    return collect(keys(unique_digits))\nend\n</code>\n\
    And this one is the solution of the problem in Python:\n<code>\ndef unique_digits(x):\n\
    \    \n    # create a dictionary to store a unique elements \n    unique_digits\
    \ = dict()\n    \n    for i in x:\n        unique_digits[i] = i\n    \n    return\
    \ list(unique_digits.keys())", "    \n    digits = [i for i in x if i > 0]\n \
    \   \n    seen = Set()\n    output = Vector{Int64}()\n    \n    for digit in digits\n\
    \        if digit in seen\n            continue\n        \n        seen = union(seen,\
    \ digit)\n        push!(output, digit)\n    end\n    \n    return output\nend",
  "    ans=[]\n    for i in x \n        if rem(i,10)==0 \n            push!(ans, i)\n\
    \        end\n    end\n    ans\nend", "    flag = zeros(Int, length(x))\n    flag[x]\
    \ = true\n    z = zeros(Int, length(x))\n    for (i in 1:length(x))\n        if\
    \ i==1 || flag[i-1]\n            continue\n        j = 1\n        z = z + x[i]\n\
    \        while x[j] <= z && j < length(x)\n            if flag[j-1]\n        \
    \        flag[j] = false\n            end\n            z = z + x[j]\n        \
    \    j = j + 1\n        end\n        if z == x[i]\n            flag[i] = false\n\
    \        end\n    end\n    return unique(x[flag])\nend\n\"\"\"\nGiven a vector\
    \ of positive integers x. return a sorted vector of all \n    elements that hasn't\
    \ any odd digit.", "    unique_digits= Vector{Int64}[]\n    for i in x\n     \
    \   if i.rem == 0\n            if i not in unique_digits\n                push!(unique_digits,i)\n\
    \            end\n        end\n    end\n    return unique_digits\nend", "    unique_digits_rec([],\
    \ x)\nend", "    # implement here\nend", "    x = sort(x)\n    \n    for i in\
    \ 2:length(unique(x))\n        if iseven(x[i])\n            push!(unique(x), x[i])\n\
    \        end\n    end\n    return unique(x)\nend\n</cell>\n<code language=julia-0.5>\n\
    unique_digits([15,33,1422,1])\n</cell>\n<code language=julia-0.5>\nunique_digits([152,\
    \ 323, 1422, 10])\n</cell>\n<text>\n2.3 The first 500 odd numbers", "    # write\
    \ your code in Julia 0.6 or later\n    # Solution 2\n    return sort(unique(x))\
    \ \nend", "    for n in unique(x) do if div(n,10) == 0 then push!(x, n) else break\
    \ end end\n    x\nend", "    if length(x)==0 \n        return [] \n    else \n\
    \        sorted_x = sort(x) \n        no_even_digit = sorted_x[findall(x .%2 ==\
    \ 0)] \n        unique_digits = unique_digits(no_even_digit) \n        unique_digits\
    \ += x \n        return unique_digits \nend", "    vec = Vector{Int64}[]\n   \
    \ vec_copy=Vector{Int64}(x)\n    vec_copy[1]=NaN\n    vec_copy.sort\n    for i\
    \ in 2:length(vec_copy)\n        if isnan(vec_copy[i])\n            continue \n\
    \        end\n        if vec_copy[i]%2==0\n            push!(vec,vec_copy[i])\n\
    \        end\n    end\n    sort(vec)\nend\n</code>\n<|/ a |>\n<| a tags=function,sorting,algorithm,vector,julia\
    \ |>\n<code>\nusing BenchmarkTools", "    \n    ans = Vector{Int64}()\n    for\
    \ i in x\n        for j in 1:length(ans)\n            if (ans[j] == 0)\n     \
    \           ans[j] = i\n            end\n        end\n    end\n    ans\nend\n\
    </cell>\n<code language=julia-1.4>\n\"\"\"\nGiven a vector of positive integers,\
    \ sort them into increasing order and \nremove duplicates. If the original vector\
    \ has duplicates, keep the first \none.\n\"\"\"", "    unique_x = Vector{Int64}()\n\
    \    for i in x\n        if i %% 2 == 0\n            unique_x << i\n        end\n\
    \    end\n    return unique_x\nend", "    digits = []\n    for i in x\n      \
    \  push!(digits, digits(i))\n    end\n    digits = sort(digits)\n    return digits[2:end]\n\
    end", "    digits = Vector{Int64}()\n    for i in x\n        push!(digits, floor(i))\n\
    \    end\n    filter!((x -> x % 2 != 0), (digits))\nend\n</cell>\n<code language=julia-1.3>\n\
    unique_digits([15, 33, 1422, 1])\n</cell>\n<text>\nPart 5: Problem Solving - Q10\n\
    Given a vector of numbers, return a new vector where each element is the product\
    \ of all the numbers before it.", " \n    if length(x) == 0 \n        return x\
    \ \n    end", "    if length(x)==0 \n        x \n    else \n        unique_digits([x[0]]\
    \ + unique_digits(filter(x->x %% 2 ==0, x:(last(x))))) \n    end\nend", "    v\
    \ = Vector{Int64}()\n    push!(v, 0)\n    for i in x\n        if mod(i, 10) ==\
    \ 0 && i > 0\n            if !contains(v, i-10)\n                push!(v, i-10)\n\
    \            end\n        end\n    end\n    return v\nend\n</cell>\n<code language=julia-1.6>\n\
    @assert unique_digits([15, 33, 1422, 1]) == [1 ; 15 ; 33]\n@assert unique_digits([152,\
    \ 323, 1422, 10]) == []\n</cell>\n<code language=julia-1.6>\n\"\"\"Find out all\
    \ prime factor of given number\"\"\"", " \n    if sum(x) == 0 \n        Vector{Int64}()\
    \ \n    else\n        Vector{Int64}(x[x .!= 0]) \n    end\nend", "    unique_digits_1\
    \ = Vector{Int64}()\n    for i in x:\n        if i mod 2 == 0 && i !=0 \n    \
    \        push!(unique_digits_1, i)\n        end\n    end\n    return unique_digits_1\n\
    end\n</cell>\n<text>\nExercise 4\nDefine a function called digits that takes a\
    \ positive integer and returns a Vector containing its digits.  For example digits(15)\
    \ should return [1, 1, 3].  It should work even if x is negative.", "    if x.sum()\
    \ == 0 return []\n    v = x[find(x) != x] \n    if length(v) == 1 \n        return\
    \ v\n    else \n        return [v[1]] + unique_digits(v[2:end])\nend\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nThis is a nice recursive solution. However, the complexity\
    \ is `O(N^2)` where N is the number of elements in the original vector.\n<|/ c\
    \ |>\n<| a dscore=4 |>\nTo expand on answer, this solution will work with an arbitrary\
    \ set of elements, not just Int64. \n<code>\nusing Sets", "    for i in sort(x)\n\
    \        if even(i) == false\n            return Vector{Int64}([i])\n        end\n\
    \    end\n    return Vector{Int64}[]\nend\n</cell>\n<code language=julia-1.4>\n\
    unique_digits([15, 33, 1422, 1])\n</cell>\n<code language=julia-1.4>", "    if\
    \ length(x) == 0 \n        return x \n    \n    unique_digits_tmp = x\n    for\
    \ i = 2:length(x) \n        flag = trues(length(x))\n        for j = 1:length(x)\
    \ \n            if x[j] % i == 0 \n                flag[j] = 0\n            else\
    \ \n                break\n        end\n        if any(flag)\n            unique_digits_tmp\
    \ = setdiff(unique_digits_tmp, x)\n            break\n        else\n         \
    \   push!(unique_digits_tmp, i)\n        end\n    end\n    \n    unique_digits_tmp\n\
    end\n</cell>\n<code language=julia-1.5>\nunique_digits([1, 12])\n</cell>\n<code\
    \ language=julia-1.5>\nunique_digits([1])\n</cell>\n<code language=julia-1.5>\n\
    unique_digits([1, 2])\n</cell>\n<code language=julia-1.5>\nunique_digits([1, 2,\
    \ 3])\n</cell>\n<code language=julia-1.5>\nunique_digits([1, 2, 3, 5])\n</cell>\n\
    <code language=julia-1.5>\nunique_digits([1, 2, 3, 5])\n</cell>\n<code language=julia-1.5>\n\
    unique_digits([1, 2, 3, 5])\n</cell>\n<code language=julia-1.5>\nunique_digits([1,\
    \ 2, 3, 5])\n</cell>\n<code language=julia-1.5>\nunique_digits([1, 2, 3, 5])\n\
    </cell>\n<code language=julia-1.5>\nunique_digits([1, 2, 3, 5])\n</cell>\n<code\
    \ language=julia-1.5>\nunique_digits([1, 2, 3, 5])\n</cell>\n<code language=julia-1.5>\n\
    unique_digits([1, 2, 3, 5])\n</cell>\n<code language=julia-1.5>\nunique_digits([1,\
    \ 2, 3, 5])\n</cell>\n<code language=julia-1.5>\nunique_digits([1, 2, 3, 5])\n\
    </cell>\n<code language=julia-1.5>\nunique_digits([1, 2, 3, 5])\n</cell>\n<code\
    \ language=julia-1.5>\nunique_digits([1, 2, 3, 5])\n</cell>\n<code language=julia-1.5>\n\
    unique_digits([1, 2, 3, 5])\n</cell>\n<code language=julia-1.5>\nunique_digits([1,\
    \ 2, 3, 5])\n</cell>\n<code language=julia-1.5>\nunique_digits([1, 2, 3, 5])\n\
    </cell>\n<code language=julia-1.5>\nunique_digits([1, 2, 3, 5])\n</cell>\n<code\
    \ language=julia-1.5>\nunique_digits([1, 2, 3, 5])\n</cell>\n<code language=julia-1.5>\n\
    unique_digits([1, 2, 3, 5])\n</cell>\n<code language=julia-1.5>\nunique_digits([1,\
    \ 2, 3, 5])\n</cell>\n<code language=julia-1.5>\nunique_digits([1, 2, 3, 5])\n\
    </cell>\n<code language=", "    \"\"\"\n    >>> unique_digits([15, 33, 1422, 1])\n\
    \    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\
    \"\n    return [xx for xx in x if ! (xx % 2)]\nend", "    for x in unique_digits(x)\n\
    \        if x % 2 == 0\n        else append(x, x)\n    end\n    return x\nend\n\
    </code>\n<|/ a tags=functional-programming,julia,recursion dscore=1 |>\n<| a dscore=1\
    \ |>\nA very basic functional approach could look like this:\n<code>", "    #\
    \ Your code here\nend\n</cell>\n<code language=julia-0.6>\n# Test Your Code",
  "    digits = unique(sort(x))\n    evens = filter(x -> rem(x, 10) == 0, x)\n   \
    \ return evens\nend", "    unique_digits = Set{Int64}()\n    for i in x \n   \
    \     if i%2 == 0 \n            unique_digits += [i] \n        end \n    end \n\
    \    return unique_digits[end]\nend ", "    \n    result = Vector{Int64}()\n \
    \   for i in x\n        if i > 0 && mod(i, 10) == 0\n            push!(result,\
    \ i)\n        end\n    end\n    sort!(result)\n    return result\nend\n</cell>\n\
    <text>\nQuestion 1.\nGiven a vector of positive integers x. return a sorted vector\
    \ of all elements that hasn't any even digit and also contains some negative integer\
    \ y.", "\"\"\"\n    \n\"\"\"\n    Vector: unique_digits(x::Vector)\n    \n   \
    \ Function that return unique integers inside vector\n    \n    x -- vector of\
    \ numbers\n    \n    For example:\n    >>> unique_digits([0, 1, 2, 5])\n    [0,\
    \ 2, 5]\n    >>> unique_digits([152, 323, 1422, 10])\n    [10, 1422, 323]\n\"\"\
    \"", "    if length(x) == 0\n        return []\n    else if length(x) == 1\n \
    \       if x % 2 == 0\n            return [x]\n        else\n            return\
    \ []\n    end\n    digits = sort(x, by = x->mod(x, 10))\n    return digits[2:end-1]\n\
    end\n</cell>\n<text>\nSolution:", "    \n    unique_digits = Int64[]\n    \n \
    \   for i = 1:length(x)\n        if x[i] % 2 != 0\n            push!(unique_digits,\
    \ x[i])\n        end\n    end\n    \n    return sort(unique_digits)\nend", " \
    \   unique = Set()\n    for el in x \n        if el%2 == 0 \n            if !has(unique,\
    \ el) \n                insert(unique, el)\n            end\n        end\n   \
    \ end\n    unique\nend\n</cell>\n<code language=julia-1.4>\nunique_digits(1:10)\n\
    </cell>\n<text>\nWrite a program that returns all permutations of the given string.",
  "    for i in x\n        dig = log10(i)\n        if dig > 0\n            digit =\
    \ div(digit, 10)\n            if digit == 0\n                push!(result, i)\n\
    \            end\n        end\n    end\n    return result\nend", "    length =\
    \ length(x)\n    unique_digits = Vector{Int64}()\n    for i = 1:length\n     \
    \   if x[i] % 2 != 0\n            push!(unique_digits, x[i])\n        end\n  \
    \  end\n    return sort(unique_digits)\nend\n</cell>\n<text>\nExercise 9\nWrite\
    \ a Julia code to compute the following function:\n$$\n\\begin{equation}\n   \
    \ \\begin{cases}\n    \\dot{x} & = \\begin{cases}\n    1 & \\text{if } x \\gt\
    \ 0 \\\\\n    0 & \\text{if } x \\leq 0 \n    \\end{cases} \\\\\n    \\dot{x}\
    \ & = \\begin{cases}\n    -1 & \\text{if } x \\gt 0 \\\\\n    0 & \\text{if }\
    \ x \\leq 0 \n    \\end{cases}\n    \\end{cases}\n\\end{equation}\n$$", "    #\
    \ write your code in here\nend\n</cell>\n<text>\nProblem 3.2\nWrite a function\
    \ to get all positive integers less than a certain number n.", "    if length(x)\
    \ == 0 \n        return Vector{Int64}() \n    else if length(x) == 1 \n      \
    \  return x \n    end\n    evens = filter(x->mod(x, 2) == 0, x) \n    return unique_digits(filter(x->!iszero(x),\
    \ x)) \nend", "    unique_digits = Set()\n    for i in x\n        push!(unique_digits,\
    \ Int(i))\n    end\n    unique_digits\nend", "    if x.isEmpty || x.size < 2 \n\
    \        return x \n    \n    \n        digits = [Int64[] for _ in 1:x.size]\n\
    \        for e in x \n            digits[e % 10] <- (digits[e % 10] .+ [e])\n\
    \        end\n        for d in digits\n            push!(d, 0) \n        end\n\
    \        \n        for i in 1:x.size-1\n            if digits[i][1] != digits[i+1][1]\
    \ && digits[i][1] == 0 \n                push!(digits[i], digits[i+1][1])\n  \
    \          end\n        end\n        \n        \n    \n        return Vector{Int64}(digits)\n\
    \    end\nend", "    for i in x\n        if i%2==0 \n            continue\n  \
    \      push!(result, i)\n    end\n    return result\nend\n</cell>\n<text>\nQuestion\
    \ 13\nLet us write a function that checks if a number is a palindrome or not.",
  "    if length(x) == 0\n        []\n    elseif length(x) == 1\n        [1]\n   \
    \ else\n        unique(sort(x)) .+ unique_digits(map(x -> mod(x, 10), x))\nend",
  "    if length(x) == 0 \n        return Vector{Int64}()\n    \n    let m = minimum(x)\n\
    \    \n    if m % 2 == 0 \n        push!(result, m)\n    \n    for i in x\n  \
    \      if i % 2 == 0\n            push!(result, i)\n        end\n    end\n   \
    \ \n    return result\nend\n</cell>\n<code language=julia-1.5>\n@assert length(unique_digits([15,\
    \ 33, 1422, 1])) == 3\n@assert length(unique_digits([152, 323, 1422, 10])) ==\
    \ 0\n</cell>\n<text>\n4.3 The maximum product of given three integers\nDefine\
    \ a function that takes three integers and returns the product of the three given\
    \ integers, also return the maximum product of the three given integers.", " \
    \   for i in sort(x)\n        if i mod 2 == 0 && i > 0\n            return filter(x->x!=i,\
    \ x)\n        end\n    end\n    return x\nend\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"\n    unique_evens(x)", "    return unique_digits(x)\nend", "    return\
    \ sort(unique(x)) \nend", "    for i in 1:length(x)\n        if even(x[i]) ==\
    \ false && x[i] % 2 == 0\n            push!(ys, x[i])\n        end\n    end\n\
    \    return ys\nend", "    unique_digits = []\n    for i in x\n        append!(unique_digits,\
    \ findall(x->x==i, 1:i))\n    end\n    return unique_digits\nend\n</cell>\n<code\
    \ language=julia-1.5>\nunique_digits([15, 33, 1422, 1])\n</cell>\n<text>\n4.8\
    \ Find all the numbers in an interval with given range", "    N = length(x)\n\
    \    digit_vector = Vector{Int64}(undef, N)\n    \n    for i in 1:N\n        digit_vector[i]\
    \ = digits(x[i])\n    end\n    \n    unique_digit_vector = Array{Int64}(undef,\
    \ N-1)\n    unique_digit_vector[1] = Set{Int64}(digit_vector[1])\n    unique_digit_vector[2]\
    \ = Set{Int64}(digit_vector[2])\n    for i in 3:N-1\n        if !has_even_digit(digit_vector[i])\n\
    \            unique_digit_vector[i] = Set{Int64}(digit_vector[i])\n        else\n\
    \            unique_digit_vector[i+1] = union(unique_digit_vector[i], digit_vector[i])\n\
    \        end\n    end\n    unique_digit_vector[N] = Set{Int64}(digit_vector[N])\n\
    \    \n    return unique_digit_vector\nend", "    unique_digits = Vector{Int64}()\n\
    \    for i in x\n        if mod(i,2) == 0\n            push!(unique_digits, i)\n\
    \        end\n    end\n    return unique_digits\nend\n</cell>\n<text>\n4.2.4 Solution",
  "    x = [i for i in x]\n    for i in eachindex(x) do \n        if x[i] % 2 == 0\
    \ then \n            removeat(x,i) \n        end\n    end\n    return x\nend\n\
    </cell>\n<code language=julia-1.4>\n\"\"\"\nGiven a vector of positive integers\
    \ x. return a sorted vector of all \nelements that haven't any odd digit.", " \
    \   for i in eachindex(x)\n        push!(v,x[i])\n    end\n    return v\nend",
  "    if x.iszero() || x.size < 2\n        return [x]\n    end\n    unique_digits_aux(x,\
    \ [], 0)\nend", "    \n    \n    \n    for i in eachindex(x)\n        for j in\
    \ i:i:x\n            if j mod 2 == 0\n                push!(unique, j)\n     \
    \           \n            else\n                continue \n            end\n \
    \       end\n    end\n    return unique\nend", "\"\"\"\n    Given a vector of\
    \ positive integers x. return a sorted vector of all \n    elements that hasn't\
    \ any even digit.", "    sorted = sort(x)\n    even = filter(x -> x % 2 == 0,\
    \ sorted)\n    return sorted(filter(x -> x != 0, even))\nend", "    unique_digits\
    \ = Set()\n    unique_digits = unique_digits + Set(x[i] for i = 1:length(x))\n\
    \    unique_digits\nend\n</cell>\n<text>\nSort the Vector of unique digits and\
    \ return it.", "    if x == []\n        Vector{Int64}()\n    else\n        unique_digits_helper(x)\n\
    \    end\nend", "    \n    for i in 1:length(nums)\n        if nums[i]%2 == 0\n\
    \            push!(unique_digits, nums[i])\n        end\n    end\n    return unique_digits\n\
    end", "   \n    for i in 1:length(x)-1\n        if x[i]%2 == 0\n            push!(x,x[i])\n\
    \        end\n    end", "    if length(x) < 1 then return [] end\n    unique_set\
    \ = Set{Int64}()\n    unique_result = Vector{Int64}()\n    for element in x do\n\
    \        if element % 2 == 0 \n            push!(unique_set, element)\n      \
    \  elseif length(unique_set) > 0\n            if element in unique_set\n     \
    \           push!(unique_result, element)\n            end\n        else\n   \
    \         push!(unique_result, element)\n        end\n    end\n    return unique_result\n\
    end", "    if length(x) == 0 || sum(x) == 0\n        []\n    else\n        x =\
    \ sort(x)\n        result = [x[1] for i = 2:length(x)]\n        remove!(result,\
    \ 1)\n    end\n    result\nend\n</cell>\n<cell>\n## @title ## Testing `unique_digits`\
    \ function\n\"\"\"\n    >>> x = [1, 2, 3, 5]\n    >>> unique_digits(x)\n    [1,\
    \ 3, 5]\n    >>> x = [1, 5, 5]\n    >>> unique_digits(x)\n    []\n\"\"\"\n</cell>\n\
    <text>\nNo. of unique digits", "    # Write your function description here\n \
    \   \n    return x \nend", "    uniq_x = Set()\n    for elem in x\n        if\
    \ elem < 10 \n            uniq_x << elem\n        end\n    end\n    uniq_x --#\
    \ {x for x \u2208 uniq_x if all(x mod 2 .== 0)}\n    uniq_x --# {x for x \u2208\
    \ uniq_x if all(x mod 2 .!= 0)}\nend\nunique_digits(x::Vector{Int64}) = sort(x)\n\
    end\n</cell>\n<code language=julia-0.5>\n@assert unique_digits([15, 33, 1422,\
    \ 1]) == [1, 15, 33]\n@assert unique_digits([152, 323, 1422, 10]) == []\n</cell>\n\
    <text>\nPart 2: Problem Solving\nOnce you've tested your code, run the code cell\
    \ below to run your performance test suite.", "    unique_digit = Set()\n    digits\
    \ = Set()\n    unique_digits = Set()\n    \n    for i in x\n        if !digits.contains(i)\
    \ && i >= 10\n            digits.add(i)\n        else\n            unique_digit.add(i)\n\
    \        end\n    end\n    unique_digits += unique_digit\n    return unique_digits\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert unique_digits([3, 7, 9, 6, 4,\
    \ 10]) == [3, 6, 9, 10]\n@assert unique_digits([152, 323, 1422, 10]) == []\n</cell>\n\
    <text>\n\u0422\u0435\u043E\u0440\u0435\u043C\u0430 B. \u041A\u043E\u043F\u0438\
    \u0440\u043E\u0432\u0430\u043D\u0438\u0435 \u043C\u043D\u043E\u0436\u0435\u0441\
    \u0442\u0432\n\u0414\u0430\u043D \u043D\u0430\u0431\u043E\u0440 \u0442\u0440\u0438\
    \ \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0439. \u041D\u0430\u043F\u0438\u0441\
    \u0430\u0442\u044C \u043D\u0430\u0438\u0431\u043E\u043B\u0435\u0435 \u0443\u0441\
    \u043F\u0435\u0448\u043D\u044B\u0439 \u043A\u043E\u0434, \u043A\u043E\u0442\u043E\
    \u0440\u044B\u0439 \u0432\u044B\u0432\u043E\u0434\u0438\u0442 \n\u0441\u0430\u043C\
    \u044B\u0439 \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u0438\u0439 \u0438\u0437\
    \ \u043D\u0438\u0445. \u0412\u044B\u0432\u043E\u0434\u0438\u0442\u044C \u043D\u0443\
    \u043C\u0435\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0439 \u0432 \u0441\u0442\
    \u0430\u0442\u044C\u0435 \u043F\u0440\u043E \u0442\u0435\u043E\u0440\u0435\u043C\
    \u0443 A", "    unique_digits = sort(unique(x))\n    if length(unique_digits)\
    \ <= 0\n        return unique_digits\n    else\n        unique_digits[end] = unique_digits[end]\
    \ - 1\n    end", "    even_idx = find(x==0)\n    return x[even_idx].>=0? x : unique_digits(x[x!=0]+x[x==0])\n\
    end", "    for i in x\n        if i % 2 == 0\n            return Int64[i | 0]\n\
    \        end\n    end\n    return x\nend\n</cell>\n<code language=julia-1.5>\n\
    unique_digits([15, 33, 1422, 1])\n</cell>\n<text>\nProblem 7. Unique characters\n\
    Given a vector of strings, return a sorted vector of all characters in all strings\
    \ \n    that hasn't any duplicate.", "    unique_digits_result = []\n    \n  \
    \  for i in x : \n        if i%2 == 0 \n            unique_digits_result += [i]\
    \ \n        else \n            unique_digits_result += [i] \n            \n  \
    \  unique_digits_result\nend\n</cell>\n<text>\nExercise: Define a function unique\
    \ that takes a vector of integers and returns the vector with all unique integers\
    \ removed, i.e., \ngiven [1, 1, 2, 3] the function should return [1, 2, 3]. \n\
    Write a test case for this function.", "    \n    xsort = sort(x)\n    \n    for\
    \ i in 1 : (length(x) - length(unique(xsort)))\n        if rem(x[i], 10) == 0\n\
    \            xsort = [xsort[i] | xsort[i - 1]]\n        end\n    end", "    if\
    \ length(x) == 0 \n        return []\n    unique_vec=copy(unique_digits_aux(x,0))\n\
    \    append!(unique_vec,0)\n    return unique_vec\nend", "   \n    digit = zeros(Int64,\
    \ length(x));\n    for i = 1:length(digit)\n        digit[i] = 0\n    end\n  \
    \  for i = 1:length(digit)\n        digit[i] = (x[i]//10)%10\n    end\n    return\
    \ digit\nend\n\"\"\"\n    \n    Given a vector of positive integers x. return\
    \ a sorted vector of all \n    elements that hasn't any even digit.", "    unique_digits(x.filter(x\
    \ -> x % 2 != 0))\nend\nunique_digits(x)", "    ans = unique(x)\n    for n in\
    \ ans\n        pos = find(x .== n)\n        if pos == 1\n            delete!(ans,\
    \ pos)\n        end\n    end\n    ans\nend", "    x = sort(x)\n    x = x[end-1:end]\n\
    \    x = x./10\n    x = x .- mod(x,2)\n    x = unique(x)\n    return x\nend\n\
    </cell>\n<code language=julia-1.1>", "    return sort(unique(x)) # Sort then filter\
    \ out duplicates\nend\n</cell>\n<text>\nQuestion 6: Print the unique digits of\
    \ vector [152,323,1422,10]", "    digits::Set{Int64} = Set()\n    for i in x\n\
    \        digits.add(Int(i))\n    end\n    return filter( x -> x rem 2 != 0, digits)\n\
    end\n</cell>\n<code language=julia-1.3>", "    if length(x) ==0\n        return\
    \ []\n    \n    for i in x:\n        \n        \n        if i==0\n           \
    \ continue\n            \n        for j in x:\n            if j%i>0\n        \
    \        j+=1\n                break\n            if j==i\n                continue\n\
    \            push!(ret, j)\n            break\n    end\n    \n    ret\nend", " \
    \   @assert x == sort(x) \n    @assert all(xx <=> 0 for xx in x) \n    @assert\
    \ all(xx <=> 9 for xx in x) \n    x = x[findall(x .== x .%10) .!= 0] \n    @assert\
    \ length(x) == 1 \n    return x \nend\n</cell>\n<text>\nProblem 7.7\nGiven the\
    \ vector [4, 8, 4, 12, 16, 16, 20], write a function that returns another vector\
    \ with all the unique integers from 0 to 2^n-1.", "    \n    evens = x .% 2 ==\
    \ 0 .% 2\n    \n    x.sort! \n    \n    if evens\n        x[evens]\n    else\n\
    \        x[x .!= 0]\n    end\nend\n</cell>\n<code language=julia-1.0>", "    \n\
    \    \n    return sort(unique(digits(x)))\nend", "    #x = [15, 33, 1422, 10]\n\
    \    unique_digit_count = 0\n    for i in x\n        unique_digit_count = unique_digit_count+1\
    \ if i%2 == 0 \n    end", "    \"\"\"\n    Author: Junjie\n    \n    Sorted Unique\
    \ digit vector.\n    \"\"\"\n    \n    unique_digits_vector = []\n    for number\
    \ in x\n        for each in unique(number)\n            if length(number) == length(each)\n\
    \                unique_digits_vector = [each, number]\n                break\n\
    \            end\n        end\n    end\n    \n    return unique_digits_vector\n\
    end\n</cell>\n<code language=julia-1.5>\n@time unique_digits([15, 33, 1422, 1])\n\
    </cell>\n<code language=julia-1.5>\n@time unique_digits([152, 323, 1422, 10])\n\
    </cell>\n<text>\nExercise: Remove Duplicates", "    \"\"\"Given a vector of positive\
    \ integers x. return a sorted vector of all \n    elements that hasn't any even\
    \ digit.", "    x .= filter( x -> x==0, x)\n    x .= sort(x)\n    x .= filter(\
    \ x -> x!=0 ,x)\n    return x\nend", "    \n    unique_digits = Vector{Int64}()\n\
    \    for i in x : push!(unique_digits, i)\n    unique_digits\nend\n</cell>\n<text>\n\
    Notice that there are two new variables declared, unique_digits, which stores\
    \ the unique digits and unique_digits2 to store the unique odd digits. Now let's\
    \ see how unique_digits work:", "    unique_digits_result = []\n    for digit\
    \ in x\n        if iszero(digit)\n            unique_digits_result = []\n    \
    \    else\n            if length(unique_digits_result) == 0\n                unique_digits_result\
    \ = [digit]\n            else\n                if digit==unique_digits_result[1]\n\
    \                    push!(unique_digits_result,digit)\n                else\n\
    \                    push!(unique_digits_result,0)\n                    push!(unique_digits_result,digit)\n\
    \                end\n            end\n        end\n    end\n    unique_digits_result\n\
    end\n</cell>\n<code language=julia-0.6>\n\"\"\"\nGiven an integer x, write an\
    \ efficient function that returns the number of \ntimes x appears in the integer\
    \ range 0 to x. \n\"\"\"", "    vector=Vector{Int64}()\n    for i in x \n    \
    \    if i.even? \n            push!(vector,i) \n        end\n    end\n    vector\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"Given a vector of positive integers\
    \ x. return a sorted vector of all \n    elements that has one even digit and\
    \ another one odd digit.", "    if length(x)==0 then return [] end\n    \n   \
    \ y=copy(unique(x) )\n    map!(deleteat, y) \n    return y\nend\n</cell>\n<code\
    \ language=julia-1.6>\n\"\"\"Given a vector of positive integers x. return a sorted\
    \ vector of all \n    elements that has only unique digits.", "    # write your\
    \ code here\n    n = length(x)\n    digits = {}\n    for i in x \n        if digits[i]\
    \ == 0 \n            digits[i] = 1\n        else\n            digits[i] = digits[i]\
    \ + 1\n        end\n    end", " \n    for n in x: \n        if n rem 2 == 0 \n\
    \            push!(res, n) \n        end\n \n    return res \nend", "    return\
    \ sort(set(x))\nend", "    # remove any empty element\n    x.remove!((0,0))\n\
    \    # sort the vector\n    x.sort!\n    # add zeros to the end \n    x += (zeros(0,x.size),)\n\
    \    # remove any element that is not odd\n    x = filter(x->!(x%2),x)\n    #\
    \ remove any element that has only 1 digit\n    x = filter(x->x[1]==1,x)\n   \
    \ return x\nend\n</cell>\n<code language=julia-1.1>\nusing LinearAlgebra\n</cell>\n\
    <text>\n3. Vectorized Matrix Operation\nNow you know about vectorization and matrix\
    \ multiplication, let's explore the performance of vectorized matrix operation.",
  "    \n    # Initialization\n    unique_digits::Vector{Int64} = []\n    \n    #\
    \ Traverse and check \n    for i in x\n        if i %% 2 == 0\n            if\
    \ i not in unique_digits\n                unique_digits += [i]\n            else\n\
    \                continue # Do not append\n            end\n        end\n    end\n\
    \    return unique_digits\nend\n</cell>\n<code language=julia-1.5>", "    unique_digits_vec\
    \ = []\n    for elem in x \n        if elem % 2 == 0 \n            unique_digits_vec[end+1]\
    \ = elem \n        end\n    end\n    unique_digits_vec\nend", "    if length(x)\
    \ == 0 \n        return x \n    else \n        unique_digits(x[1:end-1]) \n  \
    \  end\nend \n    \n\"\"\"Given a vector of positive integers x. return a sorted\
    \ vector of all \n    elements that hasn't any odd digit.", "    #using filter\
    \ function\n    filter((i) -> not isdigit(i), x)\nend", "    digits = x.map(x->mod(x,\
    \ 10)).filter(x->x==0)\n    unique_digits = sort!(unique(digits)) # sort is necessary\
    \ in case \n                                          # x contains duplicates\
    \ \n                                          # (which we do not want to remove)\
    \ \n    return unique_digits\nend", "    xset = Set(x)\n    return filter(x ->\
    \ !(xset==Set(x.digits(2))), x)\nend\n</cell>\n<text>\nProblem 9: Permutation\
    \ Function", "    unique_digits_array = []\n    unique_digits_array2 = []\n  \
    \  unique_digits_array3 = []\n    for i in x\n        if i%2 == 0\n          \
    \  unique_digits_array += [i]\n        elseif length(unique_digits_array) == 0\n\
    \            unique_digits_array2 += [i]\n        else\n            unique_digits_array3\
    \ += [i]\n        end\n    end\n    unique_digits_array = [i for i in unique_digits_array\
    \ if isdigit(i)]\n    unique_digits_array2 = [i for i in unique_digits_array2\
    \ if isdigit(i)]\n    unique_digits_array3 = [i for i in unique_digits_array3\
    \ if isdigit(i)]\n    \n    unique_digits_array = unique_digits_array[2:end]\n\
    \    unique_digits_array2 = unique_digits_array2[2:end]\n    unique_digits_array3\
    \ = unique_digits_array3[2:end]\n    \n    unique_digits_array = sort(unique_digits_array)\n\
    \    unique_digits_array2 = sort(unique_digits_array2)\n    unique_digits_array3\
    \ = sort(unique_digits_array3)\n    \n    unique_digits_array = [i for i in unique_digits_array\
    \ if !isdigit(i)]\n    unique_digits_array2 = [i for i in unique_digits_array2\
    \ if !isdigit(i)]\n    unique_digits_array3 = [i for i in unique_digits_array3\
    \ if !isdigit(i)]\n    \n    unique_digits_array = sort(unique_digits_array)\n\
    \    unique_digits_array2 = sort(unique_digits_array2)\n    unique_digits_array3\
    \ = sort(unique_digits_array3)\n    \n    unique_digits_array = unique_digits_array[2:end]\n\
    \    unique_digits_array2 = unique_digits_array2[2:end]\n    unique_digits_array3\
    \ = unique_digits_array3[2:end]\n    \n    unique_digits_array = sort(unique_digits_array)\n\
    \    unique_digits_array2 = sort(unique_digits_array2)\n    unique_digits_array3\
    \ = sort(unique_digits_array3)\n    \n    unique_digits_array = unique_digits_array[2:end]\n\
    \    unique_digits_array2 = unique_digits_array2[2:end]\n    unique_digits_array3\
    \ = unique_digits_array3[2:end]\n    \n    unique_digits_array = sort(unique_digits_array)\n\
    \    unique_digits_array2 = sort(unique_digits_array2)\n    unique_digits_array3\
    \ = sort(unique_digits_array3)\n    \n    unique_digits_array = unique_digits_array[2:end]\n\
    \    unique_digits_array2 = unique_digits_array2[2:end]\n    unique_digits_array3\
    \ = unique_digits_array3[2:end]\n    \n", "    if isa(x[1],Int64)\n        return\
    \ unique_digits(drop(x,1))\n    elseif x<0 || length(x) == 0\n        return Vector{Int64}()\n\
    \    elseif x%2 == 0 && length(x) == 2\n        push!(x,0)\n    else\n       \
    \ push!(x,1)\n        unique_digits(drop(x,1))\n    end\n    return x\nend", " \
    \    ans = Set()\n     for i in x\n         if iszero(i)\n             continue\n\
    \         elseif ans.contains(i) == false && digit(i) == 0\n             push!(ans,\
    \ i)\n         end\n     end\n    return ans \nend", "    if length(x) == 0 return\
    \ []\n    q = sort(x)\n    return filter(x->x%2 == 0, q)\nend\n</cell>\n<cell>\n\
    @doc rawview(A::Vector{Int64}; b::AbstractVector=nothing)::Vector{Int64}\n\"\"\
    \"Given a vector of positive integers x. return a sorted vector of all \n    elements\
    \ that hasn't any even digit.", "    for i in 1:length(x)\n        if mod(i, 2)\
    \ == 0 \n            continue\n        else\n            push!(xs, i)\n      \
    \  end\n    end\n    return xs\nend\n</cell>\n<code language=julia-1.0>\nunique_digits(x)\n\
    </cell>\n<code language=julia-1.0>\nunique_digits([1,3,5,7,5,3])\n</cell>\n<text>\n\
    Question 4 (5 Points)\nWe have seen above how to get the unique elements in an\
    \ array.  Now we would like to get the unique elements in an array that only has\
    \ even digits.  That is, we need to find all those numbers in the array that only\
    \ have even digits.  We want to do this without using any built-in function. \
    \ For example, we can write a function to do this:", "    \"\"\"Given a vector\
    \ of positive integers x. return a sorted vector of all \n    elements that hasn't\
    \ any even digit.", "        unique_digit_list = Vector{Int64}()\n        for\
    \ i in x\n            if mod (i,10) == 0 \n                unique_digit_list +=\
    \ i\n            end\n        end\n        unique_digit_list\n    end", "    x.sort!()\n\
    \    unique_elements = Set{Int64}()\n    for i in x\n        unique_elements |=\
    \ Set(i.digits)\n    end\n    return unique_elements - set(x...)\nend\n</cell>\n\
    <text>\nProblem 10\nGiven an array, write a function that returns true if the\
    \ array contains any duplicate elements. \nFor example, given [5, 7, 7, 9, 7]\
    \ it should return true. The array size could be up to 1,000,000 elements. \n\
    It is guaranteed the array does not contain nil or any other value.", "    if\
    \ length(x) == 0\n        return Vector{Int64}()\n    \n    unique_digits(x)\n\
    \    \n    function uniq(x)\n        local seen = Set{Int64}()\n        local\
    \ result = Set{Int64}()\n        for x in x\n            if seen[x] == 0\n   \
    \             result.insert(x)\n                seen[x] = 1\n            end\n\
    \        end\n        return result\n    end\n    \n    unique_digits(x) = sort(unique(unique(sort(x))...))\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThank you for your answer. Yes, this code is\
    \ working correctly. But, unfortunately, I couldn't make it work in Julia.\n<|/\
    \ c |>\n<| a |>\nHere's a vectorized solution:\n<code>", "    for i in x: \n \
    \       if i%2 == 0 \n            push!(unique, i)\n        else\n           \
    \ continue\n    end\n    return unique\nend", "    \"\"\"\n    Idea: use sort\
    \ to sort and then remove all even digit\n    \"\"\"\n    @assert x.max <= 360\
    \ \"x should contains 360 at most digits\"\n    digits = sort(x)\n    even_removed\
    \ = filter(i -> i mod 2 ==0, digits)\n    return even_removed\nend", "    if x.isEmpty\
    \ return x else unique_digits(x[1:end-1]) \n    \n    local a = unique(sort(x))\n\
    \    if length(a) == 0 return a\n    local b = []\n    for k in a \n        if\
    \ mod(k, 10) == 0 then push!(b, k) end\n    end\n    return b\nend\n\"\"\"Given\
    \ a vector of positive integers x. return a sorted vector of all \n    elements\
    \ that has only odd digit.", "    non_even_res = x\n    for i in n\u220Asort(unique(x))\
    \ \n        push!(non_even_res, i)\n    end\n    return non_even_res\nend", " \
    \   digit_count = zeros(Int, 0)\n    for i in x\n        if i < 10\n         \
    \   digit_count[i] = digit_count[i] + 1\n        else\n            digit_count[i]\
    \ = digit_count[i] + 1\n            if digit_count[i] % 2 == 0\n             \
    \   push!(digit_count, 0)\n            end\n        end\n    end", "    \n   \
    \ # find all the even digits in x\n    evens = filter( x -> x % 2 == 0, x)\n \
    \   # sort by odd digits\n    odd = sort!(evens)\n    # return only odd digits\n\
    \    vec = (evens - odd)\n    # return sorted odd vector\n    vec\nend\n\"\"\"\
    Given a vector of positive integers x. return a sorted vector of all \n    elements\
    \ that hasn't any even digit.", "    \n    @assert all(digits(x) == Int64)", " \
    \   if is_empty(x) \n        return x \n    unique_digits = unique_digits(tail(x))\
    \ \n    unique_digits.push(head(x)) \n    unique_digits \nend ", "    ans = zeros(Int,\
    \ length(unique(x)))\n    for a in x\n        for b in ans[2:end]\n          \
    \  if mod(a, b) == 0 && b != 0\n                ans = vcat(ans, b)\n         \
    \       break\n        end\n    end\n    ans\nend", "    \n    # Your code here\n\
    \    \n    return [] \nend \n</cell>\n<code language=julia-0.6>\n@assert unique_digits([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n@assert unique_digits([152, 323, 1422, 10]) ==\
    \ []\n</cell>\n<text>\n3. Sort all elements by ascending order", "    result =\
    \ []\n    for i in x\n        if iseven(i)\n            result = []\n        else\n\
    \            push!(result, i)\n        end\n    end\n    return result\nend\n\
    </cell>\n<code language=julia-0.6>\nunique_digits([152, 323, 1422, 10])\n</cell>\n\
    <text>\nProblem #2\nGiven a vector x, return a vector where each element is the\
    \ product of all the numbers in x.", "  usetd = Set{Int64}()\n  for i in x\n \
    \   if i mod 2 == 0 && !usetd.contains(i)\n      usetd += i\n    end\n  end\n\
    \  usetd\nend", "    result = []\n    for i in x \n        if iszero(i) == true\n\
    \            continue\n        else \n            push!(result, i)\n        end\n\
    \    end\n    return result\nend\n</cell>\n<text>\nQ9. Write a function that removes\
    \ all the numbers that has zero digit from a list of numbers. ", "    if length(x)\
    \ == 0 return x\n    \n    sorted_x = sort(x)\n    sorted_x0 = zeros(0)\n    unique_digits_idxs\
    \ = Vector{Int64}[]\n    \n    for i in sorted_x\n        if i % 2 == 0\n    \
    \        push!(unique_digits_idxs, i)\n        else\n            push!(sorted_x0,\
    \ i)\n        end\n    end\n    \n    unique_digits = SortedVector(unique_digits_idxs)\n\
    \    push!(unique_digits, sorted_x0[end])\n    \n    return unique_digits\nend\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype unique_digits([15, 33, 1422,\
    \ 1])\n</cell>\n<code language=julia-1.5>\n@code_warntype unique_digits([152,\
    \ 323, 1422, 10])\n</cell>\n<text>\n2.3 Palindrome Number", "    if length(x)\
    \ == 0 || sum(x) == 0\n        return vec()\n    \n    x = sort(x)\n    \n   \
    \ l = length(x)\n    \n    i = 2\n    while i < l\n        if x[i] == 0\n    \
    \        x = delete(x, i)\n        elseif x[i-1] != 0 && (x[i]%10) == x[i-1]%10\n\
    \            x = delete(x, i)\n        else\n            i += 1\n        end\n\
    \    end\n    \n    return x\nend\n\"\"\"\n    \n    Given a vector of positive\
    \ integers x. return a sorted vector of all \n    elements that hasn't any non-negative\
    \ integer digit.", "    ans = Vector{Int64}()\n    for n in x\n        idx = find(x\
    \ .== n)\n        if idx == length(x)\n            push!(ans, n)\n        else\n\
    \            ans1 = unique_digits(x[idx+1:end])\n            if any(x .== n .&\
    \ x == 1 .& x .== 1 .& x .== 1)\n                push!(ans1, n)\n            end\n\
    \        end\n    end\n    return ans\nend", "    unique_digits = Set()\n    for\
    \ n in x\n        if iszero(n) == true\n            unique_digits += n\n     \
    \   else\n            if unique_digits == Set(n)\n                unique_digits\
    \ += n\n            else\n                unique_digits += Set(n)\n          \
    \  end\n        end\n    end\n    return unique_digits\nend\n\"\"\"\n    Given\
    \ a vector of positive integers x. return a sorted vector of all \n    elements\
    \ that hasn't any odd digit.", "    result = x.copy()\n    \n    for (i, value)\
    \ in enumerate(result)\n        \n        if value == 0 \n            continue\n\
    \            \n        if iszero(value % 10) == 0\n            result[i] = 0\n\
    \        end\n    end\n    \n    return result\nend\n</cell>\n<code language=julia-1.0>\n\
    # TASKS\n# TASK - Part 1", "    res=[]\n    for i in x:\n        if iseven(i)==0\n\
    \            push!(res, i)\n        end\n    end\n    return res\nend", "    return\
    \ sort(x) == unique_digits_impl(x)\nend\n</cell>\n<code language=julia-0.6>\n\
    @code_warntype unique_digits([15, 33, 1422, 1])\n</cell>\n<code language=julia-0.6>\n\
    @code_warntype unique_digits(1:100)\n</cell>\n<code language=julia-0.6>\n@code_warntype\
    \ unique_digits([152, 323, 1422, 10])\n</cell>\n<code language=julia-0.6>\n@code_warntype\
    \ unique_digits([-1, 0, 1, 2, 4, 9, 18])\n</cell>\n<code language=julia-0.6>\n\
    @code_warntype unique_digits([-100, 100, 0, 0])\n</cell>\n<code language=julia-0.6>\n\
    @code_warntype unique_digits(zeros(3))\n</cell>\n<code language=julia-0.6>\n@code_warntype\
    \ unique_digits(zeros(3, 5))\n</cell>\n<text>\nGiven a vector of positive integers\
    \ x. return a sorted vector of all \n    elements that hasn't any odd digit.",
  "    \"\"\"\n    Code by Daniel Lambert\n    \"\"\"\n    unique_digits_ = Set()\n\
    \    for i in x\n        if i mod 2 == 0\n            if !contains(unique_digits_,\
    \ i)\n                unique_digits_ += i\n            end\n        end\n    end\n\
    \    unique_digits= unique_digits_\n    unique_digits_ = sort(unique_digits)\n\
    \    \n    return unique_digits_\nend", "    \n    if length(x) == 0  \n     \
    \   \n        return Vector{Int64}()\n    end\n    \n    unique_digits = Vector{Int64}()\n\
    \    \n    for x in x\n        if x % 2 == 0 \n            push!(unique_digits,\
    \ x)\n        end\n    end\n    return unique_digits\nend", "    \n    unique_digits\
    \ = Vector{Int64}(undef, length(x))\n    unique_digits[1] = x[1]\n    unique_digits[2]\
    \ = x[end]\n    for i in 3:length(x)\n        if x[i] % 2 != 0\n            unique_digits[i]\
    \ = x[i]\n        end\n    end\n    \n    return unique_digits\nend\n</cell>\n\
    <code language=julia-1.5>", "    \n    unique_digits_list = Vector{Int64}()\n\
    \    unique_digits_list_new = []\n    \n    for element in x \n        if element\
    \ mod 2 != 0 \n            push!(unique_digits_list, element)\n        end\n \
    \   end\n    \n    for i in unique_digits_list\n        push!(unique_digits_list_new,\
    \ i)\n    end\n    \n    push!(unique_digits_list_new, 10)\n    \n    return unique_digits_list_new\n\
    end\n</cell>\n<code language=julia-1.5>\nunique_digits([1, 15, 33, 1422, 1])\n\
    </cell>\n<code language=julia-1.5>\n# test unique_digits\nunique_digits(Vector{Int64}([1,\
    \ 15, 33, 1422, 1]))\n</cell>\n<text>\nThe function digits(x) takes a vector of\
    \ integers and returns back a vector of integers \ncontaining all the digits in\
    \ the number. Here is an example:", "    \"\"\"\n    Implement unique_digits(x)\
    \ here\n    \"\"\"\n    unique_digits([]) = []\n    unique_digits([x]) | unique_digits(filter(x->x\
    \ % 2 != 0, x)) = x\nend\n</cell>\n<code language=julia-1.3>", "    \n    # your\
    \ code goes here \n    return x\nend\n</cell>\n<code language=julia-1.4>", " \
    \   answer = Vector{Int64}()\n    for i in x\n        if i %% 2 == 0\n       \
    \     push!(answer, i)\n        end\n    end\n    answer\nend", "    if length(x)\
    \ == 0\n        return x \n    else\n        ys = x .% 10\n        z = y .< 10\
    \ ? ys : ys .== 0 ? x : x.*10 + (10 - ys)\n        z = unique_digits(z)\n    \
    \    z = z ++ unique_digits(z .- y)\n    end\n    return z \nend\n</code>\n<|/\
    \ a |>\n<| c |>\nA few issues with this one.  You don't need the `unique` since\
    \ you only have a vector.  Also `y` shouldn't be changed.  `y` should remain the\
    \ same.  Also, in case `x` is empty this will be a infinite loop.  Finally, the\
    \ function isn't a true unique (it returns `x` if the vector is empty).  It also\
    \ isn't the most efficient.\n<|/ c |>\n<| a |>\nYou can use a combination of filter\
    \ and uniq.\n<code>\nusing Base.Iterators", '    # write your code in Python 3
    or Python 2 code style and press Run button', "    # Create a vector to store\
    \ unique digits.\n    unique_digits=Vector{Int64}()\n    \n    # Iterate the vector\
    \ and check for even digit.\n    for i in x\n        if i%2==0\n            if\
    \ !contains(unique_digits,i) \n                push!(unique_digits,i)\n      \
    \      end\n        end\n    end\n    return unique_digits\nend", "\"\"\"\n  \
    \  A function that remove all duplicate numbers from a vector.", "    if len(x)==0\n\
    \        error(\"empty vector\")\n    end\n    vec =[]\n    for i in x\n     \
    \   if i mod 2 != 0\n            push!(vec, i)\n        end\n    end\n    vec\n\
    end\n</cell>\n<code language=julia-1.5>\n# Tests\n@testset \"unique_digits\" begin\n\
    @test unique_digits([15, 33, 1422, 1]) == [1, 15, 33]\n@test unique_digits([152,\
    \ 323, 1422, 10]) == []\nend\n</cell>\n<text>\nExercise: find number of digits\
    \ in each number", "    return sort(x)[findall(x .% == 0)]\nend\n</cell>\n<code\
    \ language=julia-1.1>\n\"\"\"\n    unique_words_of_length(word, length)\n    \n\
    \    Input: word (String), length (Int64)\n    Output: Vector of words with given\
    \ length\n\"\"\"", "    if length(x) < 1\n        return Vector{Int64}()\n   \
    \ else\n        aux = sort(x)\n        aux[1::2] = 0\n    end\n    return aux\n\
    end\n</cell>\n<cell>\n# export", "    \n    len = length(x)\n    seen = Set{Int64}()\n\
    \    answer = Vector{Int64}()\n    \n    for i in 1:len\n        if !seen[get(i)]\n\
    \            push!(answer, get(i))\n            seen[get(i)] = true\n        else\n\
    \            continue\n        end\n    end\n    answer\nend\n</cell>\n<code language=julia-1.5>\n\
    unique_digits([15, 33, 1422, 1])\n</cell>\n<text>\n\u0417\u0430\u0434\u0430\u0447\
    \u0430. \u0423\u043C\u0435\u043D\u044C\u0448\u0438\u0442\u044C \u043E\u0431\u0449\
    \u0438\u0439 \u0442\u0435\u043A\u0443\u0449\u0443\u044E \u0447\u0438\u0441\u043B\
    \u043E \u0438\u0437 \u0441\u043F\u0438\u0441\u043A\u0430 \u0447\u0438\u0441\u0435\
    \u043B \u0432 \u043F\u0440\u043E\u0438\u0437\u0432\u043E\u043B\u044C\u043D\u043E\
    \u0435 \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u0438\u0437\
    \ \u0434\u0432\u0443\u0445 \u0442\u0440\u0435\u0445 \u0447\u0438\u0441\u0435\u043B\
    .", "    \n    unique_digits_vec = Vector{Int64}()\n    unique_digits_vec = sort(unique_digits_vec)\n\
    \    \n    unique_digits_vec_size = length(unique_digits_vec)\n    \n    unique_digits_vec_sort\
    \ = Vector{Int64}()\n    \n    \n    for digits in unique_digits_vec\n       \
    \ if digits == 0 \n            unique_digits_vec_sort[unique_digits_vec_size]\
    \ = 0 \n        else \n            unique_digits_vec_sort[unique_digits_vec_size]\
    \ = digits\n        end\n        unique_digits_vec_size += 1 \n    end\n    \n\
    \    for digits in unique_digits_vec_sort\n        if digits_remainder == 0 \n\
    \            return unique_digits_vec\n        else \n            if digits_remainder\
    \ == 1\n                unique_digits_vec[digits] = 0 \n            end\n    \
    \        digits_remainder = digits_remainder - 1 \n        end\n    end\n    return\
    \ unique_digits_vec\nend\n</cell>\n<code language=julia-1.5>", "    unique_digits\
    \ = x.==0\n    unique_digits = [i for i=1:length(unique_digits) if x[i]==0]\n\
    \    return unique_digits\nend\n</cell>\n<code language=julia-1.0>\nunique_digits([15,\
    \ 33, 1422, 1])\n</cell>\n<code language=julia-1.0>\nunique_digits([152, 323,\
    \ 1422, 10])\n</cell>\n<text>\nQuestion 9\nLet's redefine the problem with a different\
    \ set of digits. We want to get rid of even numbers. \nYou might be tempted to\
    \ use unique_digits to get rid of the even numbers. But what if instead of numbers,\
    \ we had some letters (strings?)? This approach will not work!", "    len = length(x)\n\
    \    digits = Int64[i for i in 1:len]\n    evens = digits[digits[digits]%2 ==\
    \ 0]\n    unique_digits = x.-evens\n    unique_digits\nend\n</cell>\n<text>\n\
    Exercise. How can we improve the performance of unique_digits using parallel?",
  "    if length(x) == 0 \n        x \n    else \n        x \n        |> sort() \n\
    \        |> unique_digits(x) \n        |> sort() \n    end\nend\n</cell>\n<code\
    \ language=julia-0.5>", "    x .= unique(x) \n    x .= sort(x) \n    \n    if\
    \ length(x) == 0 \n        return x \n    \n    for i \u2208 x \n        if mod(i,\
    \ 2) == 0 \n            x[findall(x == i)] .= [] \n        else \n           \
    \ x[findall(x == i)] .= i \n    endfor \n    x \nendfunction \n</cell>\n<text>\n\
    2. Find all subsets of given set with given cardinality ", "    \n    @assert(x\
    \ >= 0, \"x must be non-negative\")\n    \n    unique_digits = Set()\n    \n \
    \   for el in x\n        \n        if mod(el, 2) == 0 \n            unique_digits.add(el)\n\
    \        end\n    end\n    \n    return unique_digits\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
