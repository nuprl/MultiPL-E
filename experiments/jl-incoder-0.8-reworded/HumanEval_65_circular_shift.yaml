name: HumanEval_65_circular_shift
language: jl
prompt: "\"\"\"Circular shift the digits of the integer x, shift the digits right\
  \ by shift\n    and return the result as a string.\n    If shift > number of digits,\
  \ return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12,\
  \ 2)\n    \"12\"\n    \"\"\"\nfunction circular_shift(x::Int64, shift::Int64)::String\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = circular_shift;\n\t@test(candidate(100,\
  \ 2) == \"001\")\n\t@test(candidate(12, 2) == \"12\")\n\t@test(candidate(97, 8)\
  \ == \"79\")\n\t@test(candidate(12, 1) == \"21\")\n\t@test(candidate(11, 101) ==\
  \ \"11\")\nend\n"
completions: ["    digits = split(to_string(abs(x)), \".\")\n    circ = digits[end]\n\
    \    if shift > length(circ)\n        shift %= length(circ)\n    digits[end] =\
    \ digits[shift]\n    digits[shift] = circ\n    return join(digits[0..end-1], \"\
    .\")\nend\n</cell>\n<code language=julia-1.0>\n@assert circular_shift(123, 1)\
    \ == 45\n@assert circular_shift(123, 2) == 34\n</cell>\n<text>\nConsecutive squaring\n\
    For a number to have three consecutive squarings, it must be a prime number.",
  "    # check if shift is out of bounds\n    if shift > length(digits(x)) || shift\
    \ < 0\n        return \"Error: shift must be in [0, \" ++ length(digits(x)) ++\
    \ \"]\"\n    else\n        s = \"\"\n        digits = digits(x)\n        # iterate\
    \ over each digit\n        for i in reverse(digits)\n            # shift each\
    \ digit by shift and append it to the string\n            s = s ++ digits[i] *\
    \ shift(i)\n        end\n        return s\n    end\nend\n</cell>\n<text>\nCircular\
    \ Shift", "    if shift > length(x) \n        shift = length(x) \n    else \n\
    \        shift <= 0\n        shift = shift - length(x)\n        shift = shift\
    \ % length(x)\n        \n        digits = split(x,\"\")\n        \n        # remove\
    \ leading zeros and add one to the new length\n        digits = digits.drop(1)\n\
    \        digits = digits.prepend(0)\n        \n        for i in 1:shift \n   \
    \         digits = digits[1:end-1].prepend(digits[end-2])\n        end\n     \
    \   \n        return join(digits, \"\")\n    \nend\n</cell>\n<text>\nA Simple\
    \ String", "    if shift > length(x) || shift < 1\n        error(\"shift: shift\
    \ must be in range [1,length(x)]\")\n    else\n        let (digits, rest) = divrem(x,\
    \ 10^shift)\n        return string(digits) * circular_shift(rest, shift-1)\nend\n\
    </cell>\n<text>\nLet's test the function circular_shift.", "    if shift > length(x)\n\
    \        return reverse(x)\n    else\n        return join(reverse(x), circular_shift(shift(x),\
    \ shift-length(x)))\nend\n</cell>\n<code language=julia-1.5>", "    \"\"\"Circular\
    \ shift the digits of the integer x, shift the digits right by shift\n    and\
    \ return the result as a string.\n    If shift > number of digits, return digits\
    \ reversed.\n    \"\"\"\n    digit_str = toString(x::Int64)\n    let digits =\
    \ String.split(digit_str, \"\")\n    let digits_right = digits[digits.length -\
    \ shift]\n    let digits_left = digits[0..digits.length - shift]\n    digits_left\
    \ + digits_right\nend", "    if shift == 0\n        shift\n    else\n        circular_shift(shift_digits(x,\
    \ shift-1), shift)\nend\n\"\"\"\n    circular_shift(x::Int64, shift::Int64)::String",
  "    if shift < 0\n        error(\"shift must be non-negative\")\n    else if shift\
    \ > length(x)\n        error(\"shift must be less than number of digits\")\n \
    \   else if shift > 0 \n        return x\n    else\n        return x[(length(x)-shift):end]\
    \ .+ circular_shift(x,shift-1)\nend\n</cell>\n<code language=julia-1.5>", "  \
    \  if shift > digits(x) # checks if shift is bigger than number of digits\n  \
    \      # returns digits reversed\n        return reverse(x::Int64)\n    else\n\
    \        digits = digits(x)\n        digits0 = digits[1:] # extracts digits before\
    \ shift\n        rest = digits[shift:] # extracts digits after shift\n       \
    \ digits1 = reverse(digits0) # reverses digits before shift\n        return digits0...rest...\
    \ digits1 # combines digits before and after shift\nend", "    digits = toCharArray(x)\n\
    \    for i in 0..shift-1\n        digits[i] = digits[i+1]\n    end\n    return\
    \ join(digits, \"\")\nend\n</cell>\n<code language=julia-0.6>\njulia_0.6.2\n</cell>\n\
    <text>\nExercise\nWrite a function that takes as input a list of integers, and\
    \ returns a dictionary with the frequencies of the numbers in the list.", "  \
    \  if shift > length(x) return \"\"\n    digits = digits(x)\n    shift = shift\
    \ % length(digits)\n    for i in 0..length(x)\n        result = digits[(i+shift)%length(digits)]\n\
    \        push!(digits, result)\n    end\n    return join(digits)\nend", "    if\
    \ shift==0 || shift==floor(x/10) \n        then return x*10+(x%10) \n    else\
    \ return circular_shift(x/10, shift-1)*10+(x%10)\nend\n</cell>\n<text>\nNow let's\
    \ see how this works on some sample inputs:", "    if shift < 0 || shift > 64\n\
    \    \"\"\n    else\n        # get the last digit of x\n        digit = x%10\n\
    \        # get the last two digits of x\n        x = x/10\n        # get the last\
    \ digit of x\n        carry = (x-digit*10)%10\n        # put the carry in between\
    \ the last two digits\n        digit = digit+carry\n        # add the last digit\
    \ and shift the digits right by shift\n        return digit*shift + digit\n  \
    \  end\nend", "    if shift == 0 \n        then return x.to_string\n    elseif\
    \ shift == 1 \n        then return String(x)\n    elseif shift == -1\n       \
    \ then return String(x[::-1])\n    else \n        digits = divrem(x, 10)\n   \
    \     shifted_digits = circular_shift(digits, shift + 1)\n        shifted_digits[1]\
    \ = digits[1] + shifted_digits[1]\n        shifted_digits[2] = digits[2] + shifted_digits[2]\n\
    \        return join(shifted_digits)\nend\n</cell>\n<code language=julia-1.4>",
  "    if shift > length(x)\n        return reverse(x)\n    else\n        shift\n\
    \        digits = str_split(x)\n        new_digits = str_split(digits[shift..end])\n\
    \        return reverse(join(new_digits)\n    end\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=julia,function,string |>\nHere is one way to do it:\n<code>\n\
    digits(x) = split(digits(x),\"\")", "    if shift > length(x) + 1 \n        return\
    \ reverse(x)\n    else \n        return x[1:shift-1] + reverse(sub(x[1:shift-1],\
    \ x[shift]))\nend\n</code>\n<|/ a tags=string,julia,function |>\n<| c |>\nFor\
    \ this kind of thing there are tools like `circshift`. So don't reimplement them\
    \ yourself. You also don't need `sub` for this. Just use `circshift(x, shift)`\
    \ (or `circshift(x, -shift)` if you want it from the other end).\n<|/ c |>\n<|\
    \ c |>\nAlso, this approach isn't faster than yours or mine. If it's slow, it's\
    \ probably the fault of the way you implemented it. If you use `circshift` from\
    \ Julia itself, it will be faster than yours because it won't have to go through\
    \ an extra function call as your function does.\n<|/ c |>\n<| a dscore=0 |>\n\
    You can use:\n<code>", "    digits_reverse = digits[shift]\n    return join(reverse(digits_reverse),\
    \ digits[shift], digits[x])\nend", "    if shift > length(x) - 1 then return reverse(x)\n\
    \    else return substring(reverse(x),(length(x)-shift),(length(x)-shift))\nend\n\
    \"\"\"\nRotate digits right by shift number of digits and return the result as\
    \ a string.\nIf shift > number of digits, return digits reversed.\n>>> rotate(12,\
    \ 1)\n\"21\"\n>>> rotate(12, 2)\n\"12\"\n\"\"\"", "    if shift == 0\n       \
    \ String(x) # If shift == 0, then shift x by 0\n    else\n        shift\n    \
    \    digits = str(x)\n        shift\n        digits[(length(digits) - shift)..end]\
    \ \n    end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Circular shift the\
    \ digits of the integer x, shift the digits right by shift\n    and return the\
    \ result as a string.\n    If shift > number of digits, return digits reversed.\n\
    \    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n  \
    \  \"12\"\n    \"\"\"", "    x = abs(x)\n    if shift > length(x)\n        return\
    \ str(reverse(x))\n    else\n        return x[0 .. shift..0] * circular_shift(shift(x),shift)\n\
    end", "    if shift == 0\n        return \"\"\n    digits = string(x)\n    shift\
    \ = abs(shift)\n    if shift > length(digits)\n        digits = reverse(digits)\n\
    \        return circular_shift(digits, shift-length(digits))\n    shift_digits\
    \ = digits[0..(length(digits)-shift)]\n    shift_digits = reverse(shift_digits)\n\
    \    return shift_digits + circular_shift(digits, shift-1)\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| a dscore=1 |>\nHere is my version:\n<code>", "    if (shift\
    \ < 0)\n        shift += length(x)\n    xs = split(x, \"\")\n    leftdigit = xs[1]\n\
    \    rightdigit = xs[2]\n    digits = [leftdigit, rightdigit]\n    for d in digits[2..-1]\n\
    \        digits[2] = digits[1]\n        digits[1] = d\n    digits[1] = leftdigit\
    \ + circular_shift(rightdigit, shift)\n    return join(digits, \"\")\nend\n</cell>\n\
    <code language=julia-1.5>\ntest_circular_shift(1, 0)\n</cell>\n<code language=julia-1.5>\n\
    test_circular_shift(2, 0)\n</cell>\n<code language=julia-1.5>\ntest_circular_shift(3,\
    \ 0)\n</cell>\n<code language=julia-1.5>\ntest_circular_shift(4, 2)\n</cell>\n\
    <code language=julia-1.5>\ntest_circular_shift(4, 1)\n</cell>\n<code language=julia-1.5>\n\
    test_circular_shift(8, 2)\n</cell>\n<code language=julia-1.5>\ntest_circular_shift(8,\
    \ 1)\n</cell>\n<code language=julia-1.5>\ntest_circular_shift(10, 2)\n</cell>\n\
    <code language=julia-1.5>\ntest_circular_shift(10, 1)\n</cell>\n<code language=julia-1.5>\n\
    test_circular_shift(122, 2)\n</cell>\n<code language=julia-1.5>\ntest_circular_shift(122,\
    \ 1)\n</cell>\n<code language=julia-1.5>\ntest_circular_shift(122, 3)\n</cell>\n\
    <code language=julia-1.5>\ntest_circular_shift(122, 4)\n</cell>\n<code language=julia-1.5>\n\
    test_circular_shift(122, 5)\n</cell>\n<code language=julia-1.5>\ntest_circular_shift(122,\
    \ 6)\n</cell>\n<code language=julia-1.5>\ntest_circular_shift(122, 7)\n</cell>\n\
    <code language=julia-1.5>\ntest_circular_shift(122, 8)\n</cell>\n<code language=julia-1.5>\n\
    test_circular_shift(122, 9)\n</cell>\n<code language=julia-1.5>\ntest_circular_shift(122,\
    \ 10)\n</cell>\n<code language=julia-1.5>\ntest_circular_shift(122, 11)\n</cell>\n\
    <code language=julia-1.5>\ntest_circular_shift(122, 12)\n</cell>\n<code language=julia-1.5>\n\
    test_circular_shift(122, 13)\n</cell>\n<code language=julia-1.5>\ntest_circular_shift(122,\
    \ 14)\n</cell>\n<code language=julia-1.5>\ntest_circular_shift(122, 15)\n</cell>\n\
    <code language=juli", "  if shift > Int64(Int64(length(digits(x))+1)) \n    shift\
    \ %= Int64(Int64(length(digits(x))+1))\n  else \n    shift %= Int64(Int64(length(digits(x))))\n\
    \  \n  x = floor(x)\n  new_digits = Int64[]\n  for d in digits(x) \n    new_digits\
    \ = cons(d, new_digits)\n  return join(reverse(digits(x)[1:shift]), new_digits)",
  "    \nend\n    \nend\n</cell>\n<text>\nWrite a function which takes a number as\
    \ an argument, and returns the sum of the digits of that number.", "    if shift\
    \ == 0\n        return String.sub(x, '0')\n    if shift > length(x)\n        return\
    \ reverse x.digits\n    end\n    z = digits(x)\n    shift -= 1\n    for i in z\n\
    \        x /= 10\n        x %= 10\n        x += digit digits(x)\n    return x\
    \ % 10 + x[end]\nend", "    if shift == 0\n        return x\n    else if shift\
    \ >= 0\n        digits = string(digits(x, 0, -1) + digits(x, -1, 0))\n       \
    \ digits = reverse(digits)\n    else\n        digits = string(digits(x, 0, -1)\
    \ + digits(x, 0, shift))\n    end\n    return digits\nend", "    if shift > math.floor(x/10)*10\n\
    \        then\n            let s = math.ceil(x/10)*10\n        else \n       \
    \     let s = math.floor(x/10)*10\n    end\n    if s == x\n        then \n   \
    \         return reverse(x, s)\n        else \n            return reverse(x, s-x)\n\
    \    end\nend\n</cell>\n<cell>", "    if shift==0\n        return Int64(x)\n \
    \   elseif shift<0\n        return circular_shift(x, -shift)\n    else\n     \
    \   return x[(shift*2)+1::(shift*2)+2]\nend\n</cell>\n<code language=julia-1.5>",
  "    if (shift > get(x, digits(x))) then\n        get(x, digits(x))[shift, digits(x)]\
    \ = get(x, digits(x))[1:get(x, digits(x))]\n    else\n        get(x, digits(x))[1:get(x,\
    \ digits(x))] = get(x, digits(x))[shift, digits(x)]\n    end\n    return String(get(x,\
    \ digits(x)))\nend\n</cell>\n<text>\nDigital root function\nA digital root function\
    \ returns the integer $r$ of a number $x$, i.e. $x$'s integer square root.", " \
    \   div = divrem(x, shift)\n    shift = shift - div[1]\n    digits = div[2]\n\
    \    \n    if shift > digits:\n        return div[2] * toString(div[2], digits)\n\
    \    \n    return div[2] * toString(div[2], shift)\nend", "    # check input type\n\
    \    if ( isInt(x) == False ) \n        error(\"Invalid input type. Expected integer\
    \ but got $(typeof(x))\")\n    # check shift type\n    if ( isInt(shift) == False\
    \ ) \n        error(\"Invalid shift type. Expected integer but got $(typeof(shift))\"\
    )\n    # check shift type\n    if ( shift > length(x) ) \n        error(\"Invalid\
    \ shift type. Shift must be less than the number of digits in the integer.\")\n\
    \    # check shift type\n    if ( shift < 0 ) \n        error(\"Invalid shift\
    \ type. Shift cannot be negative.\")\n    # calculate output size\n    return\
    \ strjoin(reverse(strdigits(x), digits=shift))\nend", "    \"\"\"Shift digits\
    \ right and return the result as a string. If shift > \n    number of digits,\
    \ digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12,\
    \ 2)\n    \"12\"\n    \"\"\"\n    if shift > max(x%10, length(digits(x))) \n \
    \       shift -= length(x%10)\n        return x\n    elseif shift < 1\n      \
    \  shift += length(x%10)\n        if shift == 0\n            return x\n      \
    \  end\n    end\n    return x[(end - shift):end]\nend\n</cell>\n<code language=julia-0.6>",
  "    if shift == 0 || shift == -1 || x == 0\n        error(\"shift must be a positive\
    \ integer\")\n    elseif shift > length(x)\n        error(\"shift must be less\
    \ than length of x\")\n    elseif shift == length(x)\n        String(x)\n    else\n\
    \        String(x) + circular_shift(shift(length(x)-shift), shift-1)\nend\n</cell>\n\
    <text>\nNow let's use circular_shift on a string, which should work as before:",
  "    str = string(x::Int64)\n    for n in str:\n        str = string(n)\n      \
    \  str = str[shift:end]\n        str = str + str[end-1:end]\n        str = str[1:shift]\n\
    \        str = string(int)\n        str = str + str[shift:end]\n    return str",
  "    if shift < 0 \n        shift *= -1\n    if shift > 0\n        return reverse(digits(x)[shift:]\
    \ + digits(x)[1:shift])\n    else\n        return reverse(digits(x)[1:shift])\n\
    end\n</cell>\n<code language=julia-0.5>\ncircular_shift(12, 1)\n</cell>\n<code\
    \ language=julia-0.5>\ncircular_shift(12, 2)\n</cell>\n<text>\nPretty print a\
    \ vector of numbers\nThe pretty() function is a wrapper for the println() function.\
    \ It prints values as a vector, by adding commas between the numbers. If the elements\
    \ are of type Number, pretty() prints them with precision. Otherwise, it prints\
    \ the elements as strings. We can create a vector of numbers and see how the function\
    \ pretty() renders them:", "    digits = digits(x)\n    if shift > length(x) ||\
    \ shift < 0\n        digits[shift] = 0\n    else\n        digits[shift] = digits[shift\
    \ - 1]\nend\n\"\"\"\nCalculate the digits of a number.\n\"\"\"", "    if shift\
    \ > length(x)\n        return reverse(x::Int64)\n    else\n        return x\n\
    \    end\nend\n</cell>\n<code language=julia-1.4>\nx = 12\ncircular_shift(x, 2)\n\
    </cell>\n<text>\nThe function reverse_string reverses the characters of a string.\
    \  It works by converting the string to a list of characters, then taking the\
    \ characters one by one and putting them in the list from back to front.", " \
    \   \"\"\"Circular shift the digits of the integer x, shift the digits right by\
    \ shift\n    and return the result as a string.\n    If shift > number of digits,\
    \ return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>>\
    \ circular_shift(12, 2)\n    \"12\"\n    \"\"\"\nif shift > length(x) return reverse(digits(x))\
    \ else reverse(digits(x)[shift:])\n</code>\n<|/ a dscore=0 |>\n<| c |>\nWelcome\
    \ to Stack Overflow! Code-only answers are not particularly helpful. Please include\
    \ a brief description of how this code solves the problem at hand. Thanks!\n<|/\
    \ c |>\n<| a dscore=0 |>\n<code>\nlet digits = function \n    |0::Int64 -> \"\
    0\" \n    |1::Int64 -> \"1\" \n    |2::Int64 -> \"2\" \n    |3::Int64 -> \"3\"\
    \ \n    |4::Int64 -> \"4\" \n    |5::Int64 -> \"5\" \n    |6::Int64 -> \"6\" \n\
    \    |7::Int64 -> \"7\" \n    |8::Int64 -> \"8\" \n    |9::Int64 -> \"9\" \n \
    \   |x::Int64  -> x%10\n;;\n</code>\n<|/ a tags=string,haskell,digit,math |>\n\
    <| c |>\nWelcome to Stack Overflow! Code-only answers are not particularly helpful.\
    \ Please include a brief description of how this code solves the problem at hand.\
    \ Thanks!\n<|/ c |>\n<| a |>\n<code>\ndigits = \\case\n        0 -> \"0\" \n \
    \       1 -> \"1\" \n        2 -> \"2\" \n        3 -> \"3\" \n        4 -> \"\
    4\" \n        5 -> \"5\" \n        6 -> \"6\" \n        7 -> \"7\" \n        8\
    \ -> \"8\" \n        9 -> \"9\" \n        _ -> \"?\"\n</code>\n<|/ a dscore=0\
    \ tags=string,haskell,digit,math |>\n<| c |>\nWelcome to Stack Overflow! Code-only\
    \ answers are not particularly helpful. Please include a brief description of\
    \ how this code solves the problem at hand. Thanks!\n<|/ c |>\n<| c |>\nThis code\
    \ does not make sense. First off, `digits :: (Int->Int) -> Int->Int` is not valid\
    \ Haskell syntax, and the first argument should be `Int` not `Int -> Int`; and\
    \ secondly, `Int -> Int` implies ", "    if shift < length(x) && length(x) >=\
    \ shift\n        digits = chars[x]\n        circular_shift(digits, shift-1)\n\
    \        circular_shift(digits, shift+length(x))\n    else\n        digits\nend",
  "    if shift < 0\n        error(\"Negative shift\")\n    else if shift > length(x)\n\
    \        error(\"Too large shift\")\n    else\n        binary = bit_repr(x) +\
    \ str_rev(x) # prepend binary representation with leading zeroes\n        return\
    \ (shift(bits(binary[shift-1..-1], 2), length(binary[shift-1..-1]))) // 2\nend",
  "        \n    if shift > length(x) && shift > -length(x)\n        # Shift past\
    \ the end\n        digits = reverse(x)\n    else\n        # Shift by less than\
    \ zero\n        digits = substring(x, 1, shift)\n    end", "    if shift <= length(x)\n\
    \        reverse(x)\n        result = \"\"\n        for digit in x\n         \
    \   result += digit\n            result += '0' * (shift - length(result))\n  \
    \      return result\n    else\n        return x\nend\n</code>\n<|/ a |>\n<| c\
    \ |>\nHow does this work with the `digits` package from the Julia project?\n<|/\
    \ c |>\n<| c |>\nI've updated the answer to include a `digits` package solution.\n\
    <|/ c |>\n<| c |>\nI tried to implement `circular_shift`, but `digits` seems to\
    \ have trouble with the `Int64` type. For example, `circular_shift(12, 2)` gives\
    \ `\"1234\"`, which has length `5`, which is greater than the original `12`. I\
    \ wonder if this is still the case.\n<|/ c |>\n<| c |>\nLooks like it's working\
    \ now. I forgot that I had changed it from `length` to `lengths` earlier, and\
    \ I thought it was still using `length`. Thanks!\n<|/ c |>\n<| c |>\nNice solution,\
    \ thanks! I wonder if there's some Julia package that already does this, or whether\
    \ I should submit a PR?\n<|/ c |>\n<| a tags=julia,string,arrays,slice |>\nHow\
    \ about using String's split and join, as follows:\n<code>\njulia> str = \"12345\"\
    \n\"12345\"", "    digits = split(toString(x))\n    shifts = split(toString(shift))\n\
    \    \n    return join(shifts[digits.length-1], digits)", "    if shift > log10(abs\
    \ x)\n        return int(x)\n    else\n        return sprintf(\"%s%d\", reverse(digits(x)),\
    \ shift)\nend", "    ans = \"\"\n    while (shift > 0 && x > 0)\n        ans =\
    \ digits[x%10] + ans \n        x = x div 10\n        shift -= 1\n    shift < 0\
    \ && shift > -length ans = digits[x] + ans \n    return ans\nend", "    # check\
    \ that x is a number\n    if x == 0\n    then return \"\"\n    else if x < 0\n\
    \    then return (x mod 10) * 10^(-shift - 1) + circular_shift(x, shift + 1)\n\
    \    else \n        reversed_str = reverse(circular_shift(reverse(floor(x / 10^(-shift))),\
    \ shift))\n        return reversed_str * 10^shift\n    end\nend\n</code>\n<|/\
    \ a dscore=2 |>\n<| a |>\nThis problem was asked in my Interview, and I solved\
    \ it using only a single line. Here's the code:\n<code>", "    let digits = length(x)\n\
    \    let n = digits-shift \n    \n    if (n == 0) then return x \n    elif (n\
    \ < 0) then return reverse(digits_to_string(x, n)) \n    else return reverse(digits_to_string(x,\
    \ n-1))\nend", "    if shift == 0\n        digits = list(x == 0 ? digits(0) :\
    \ digits(abs(x))) \n    else if shift > abs(length(x))\n        digits = list(x\
    \ == 0 ? digits(0) : digits(abs(x))) \n    else\n        digits = circular_shift(digits(x),\
    \ shift - 1)\n    return ''.join(reversed(digits)) \nend\n</code>\n<|/ a tags=julia,string,recursion,algorithm,arrays\
    \ |>\n<| a dscore=0 |>\nYou can do it like this:\n<code>", "    if shift > floor(log(x,2))\
    \ || shift > Int64(length(x)) - floor(log(x,2))\n        return \"0\"\n    else\n\
    \        return (x*sign(x))%(Int64(floor(Int64(x) - shift)))\n    end\nend", " \
    \   if shift > digits(x)\n        return x::String\n    else if shift < 0\n  \
    \      return circular_shift(x, -shift)\n    else\n        let (left, right) =\
    \ divrem(x, 10)\n        circular_shift(left, shift + 1) + right\nend\n</code>\n\
    <|/ a |>\n<| a dscore=1 tags=julia,string |>\nIn case someone is interested, there\
    \ is a package that does exactly what it claims to do:\nhttps://github.com/dario-t/JuliaStrings\n\
    This package is a simple wrapper around the native strings, which adds two methods\
    \ (joining and splitting) for splitting and joining strings. As the official docs\
    \ state:", "    \"Circular shift the digits of the integer x, shift the digits\
    \ right by shift and return the result as a string.\"\n    if shift == 0 then\
    \ return string \"0\"\n    if shift == 1 then return string \"1\"\n    if shift\
    \ > 64 then return string \"0\"\n    let digits = \"0123456789abcdefghijklmnopqrstuvwxyz\"\
    \n    digits = digits[-shift .. -1]\n    let nums = String[]\n    for i in digits\
    \ do push i nums\n    let nums = nums[-shift .. -1]\n    return \"\".join(nums)\n\
    end \n</cell>\n<code language=julia-1.3>", "    \n    if shift > length(x)\n \
    \       return reverse(x)\n    if shift < 0\n        return reverse(digits(x))\n\
    \    \n    digits = digits(x)\n    return reverse(digits[shift:] + digits[:shift])\n\
    end\n</cell>\n<text>\n4.2 String slicing", "    if shift < 0\n    error(\"shift\
    \ must be positive integer\")\n    if shift > size(x)\n    error(\"shift must\
    \ be smaller than the length of the array\")\n    else \n    digits = reverse(x:digits())\n\
    \    shift(digits, shift, digits)\nend", "    if shift == 0\n        \"\"\n  \
    \  else\n        circular_shift(x.digits, shift.digits)\n    end\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=1 |>\nI tried to create a more generic function\
    \ that can work on any type of number (i.e. complex numbers, rational numbers,\
    \ etc).\nI made several improvements including one that calculates the gcd of\
    \ 2 integers efficiently (thanks to and for your hints).\nThe code bellow only\
    \ works on integers, but it could be easily adapted to work on more types of numbers.\
    \ \n<code>\nimport Data.List (foldl')\nimport Data.Maybe (fromJust)\nimport Data.Maybe\
    \ (fromJust)", "    if shift > length(x)\n        return reverse(x)\n    else\n\
    \        return sub(x, shift(x), length(x))\nend", '    return string(x:shift
    % x) # use modulo operator (:) to get the remainder of the division', "    if\
    \ shift > length(x) - 1 then return reverse(x) else return str(x)\nend\n</cell>\n\
    <text>\n\u2714 Circular shifts digits of a number x by shift, but this time the\
    \ string is reversed.", "  \n    if shift > length(x)\n        shift = length(x)\n\
    \    end\n    reverse(x[1:shift-1], x[1:shift-1])\n    return x[shift]\nend\n\
    </cell>\n<code language=julia-0.5>\n\"\"\"\n    circular_shift(x::Vector{String},\
    \ shift::Int64)::Vector{String}\n    \n    Given a string x, rotate x by shift\
    \ positions to its right. \n    \n    shift: amount to shift\n    \n    circular_shift(x::Vector{String},\
    \ shift::Int64)::Vector{String}\n    \n    Given a string x, rotate x by shift\
    \ positions to its right. \n    \n    shift: amount to shift\n    \n    circular_shift(x::Vector{String},\
    \ shift::Int64)::Vector{String}\n    \n    Given a string x, rotate x by shift\
    \ positions to its right. \n    \n    shift: amount to shift\n    \n    circular_shift(x::Vector{String},\
    \ shift::Int64)::Vector{String}\n    \n    Given a string x, rotate x by shift\
    \ positions to its right. \n    \n    shift: amount to shift\n    \n    circular_shift(x::Vector{String},\
    \ shift::Int64)::Vector{String}\n    \n    Given a string x, rotate x by shift\
    \ positions to its right. \n    \n    shift: amount to shift\n    \n    circular_shift(x::Vector{String},\
    \ shift::Int64)::Vector{String}\n    \n    Given a string x, rotate x by shift\
    \ positions to its right. \n    \n    shift: amount to shift\n    \n    circular_shift(x::Vector{String},\
    \ shift::Int64)::Vector{String}\n    \n    Given a string x, rotate x by shift\
    \ positions to its right. \n    \n    shift: amount to shift\n    \n    circular_shift(x::Vector{String},\
    \ shift::Int64)::Vector{String}\n    \n    Given a string x, rotate x by shift\
    \ positions to its right. \n    \n    shift: amount to shift\n    \n    circular_shift(x::Vector{String},\
    \ shift::Int64)::Vector{String}\n    \n    Given a string x, rotate x by shift\
    \ positions to its right. \n    \n    shift: amount to shift\n    \n    circular_shift(x::Vector{String},\
    \ shift::Int64)::Vector{String}\n    \n    Given a string x, rotate x by shift\
    \ positions to its right. \n    \n    shift: amount to shift", "</code>\n<|/ a\
    \ tags=julia,string |>\n<| c |>\nI like the approach, but I think this is better:\
    \ `circular_shift(x, shift) = join.(string.(digits(x)[end:-1:shift]))` since it\
    \ avoids the unnecessary array construction\n<|/ c |>\n<| c |>\nThe only problem\
    \ with this approach is that it does not work for negative integers (as I assume\
    \ your function does). `circular_shift(-12, 2)` returns \"-12\"\n<|/ c |>\n<|\
    \ c |>\nThis doesn't work for negative numbers, but `circular_shift(-12, 2)` returns\
    \ `12\"`\n<|/ c |>\n<| c |>\nActually, this does work. For negative integers,\
    \ it just reverses the order of the digits.\n<|/ c |>\n<| c |>\nI see, that's\
    \ why I added the last bit to `string.(digits(x)[end:-1:shift])`. Thank you for\
    \ noticing!\n<|/ c |>\n<| a tags=julia,string |>\nJust for fun :\n<code>\njulia>\
    \ function circular_shift(s::Int,n::Int):String\n           return join(map(digits,\
    \ collect(digits(s)[(n+1):end]))[end-n+1:end])\n       end", "     x = string(x)\n\
    \     len = length(x)\n     if shift == 0 || (shift > len || shift < -len)\n \
    \        return x\n     elif shift < 0\n         return reverse(circular_shift(reverse(x),\
    \ abs(shift)))\n     else\n         return circular_shift(reverse(x), -abs(shift))\n\
    end\n</cell>\n<code language=julia-1.0>\nreverse(circular_shift(12, 1))\n</cell>\n\
    <code language=julia-1.0>\ncircular_shift(12, 2)\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"Reverse the digits of the integer x, return the result as a string.\n  \
    \  >>> reverse_reverse_reverse(123)\n    \"321\"\n    >>> reverse_reverse_reverse(123)\n\
    \    \"321\"\n    \"\"\"", "    if shift == 0:\n        return x\n    reversed\
    \ = \"0\" * shift + strrep(x.digits, \"0\", \"9\")\n    return reversed.reverse\
    \ \nend\n</cell>\n<code language=julia-1.0>", "    digits = tostring(digits(x))\n\
    \    if shift > length(x) || shift < 0\n        error(\"Shift out of bounds\"\
    )\n    end\n    digits[end - shift] = digits[end - shift - shift]\n    return\
    \ join(digits[end - shift .. end + shift - 1 .. -1], \"\")\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nI like how this does something totally different from the other\
    \ answers, but I believe this one is the best answer to this question.\n<|/ c\
    \ |>\n<| c |>\nHmm it seems wrong to me, why are you adding 1 to the string in\
    \ the end? Shouldn't it be `digits[end - shift .. end]`?\n<|/ c |>\n<| c |>\n\
    The `digits` function returns a `Vec<UInt8>`. `end` gives us the index at the\
    \ end of the string.\n<|/ c |>\n<| c |>\nAh I see what you mean, I was thinking\
    \ that the \"digits\" function was returning a `String` since it's supposed to\
    \ return the digits of an Int64. Good answer! I think you should add that the\
    \ first line should be `digits = tostring(digits(x))`\n<|/ c |>\n<| c |>\nThanks\
    \ for the heads up. I've updated the code.\n<|/ c |>\n<| a dscore=4 tags=julia\
    \ |>\n<code>\njulia> x = 123456\n123456", "    if shift < 0 \n        return reverse(digits(x))\n\
    \    return digits(x)[1..end].reverse.take(shift)\nend\n</code>\n<|/ a tags=julia,type-conversion\
    \ dscore=1 |>\n<| a |>\nJust a small edit on the previous answers\n<code>", " \
    \   \"\"\"Circular shift the digits of the integer x, shift the digits right by\
    \ shift\n    and return the result as a string.\n    If shift > number of digits,\
    \ return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>>\
    \ circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n    if shift > digits(x):\n \
    \       shift = 0 - shift\n    return \"\".join([str(x%10 + int(digits(x)/10)\
    \ + shift) for i in range(digits(x))])\nend\n</cell>\n<code language=julia-0.5>",
  "  if shift > length(x) - 1\n    \"\"\n  else\n    slice(x, 0, shift+1) + slice(x,\
    \ 1, length(slice(x)-1))\n  end\nend", "    digits = tostring(x)\n    digits =\
    \ digits[reverse(digits)[shift::]]\n    digits = reverse(digits)\n    return digits\n\
    end", "    \"\"\"Circular shift the digits of the integer x, shift the digits\
    \ right by shift\n    and return the result as a string.\n    If shift > number\
    \ of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\
    \n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n    \n    if shift >\
    \ Int(digits(x))\n        circular_shift(reverse(digits(x)), shift)\n    else\n\
    \        digits(shift(digits(x), -shift))\nend", "    if shift > length(x) \n\
    \        return reverse(x) else \n        String[shift, x] \n    end\n</code>\n\
    <|/ a tags=julia,string |>\n<| c |>\nPlease edit the answer to include an explanation\
    \ of how your code works and how it solves the problem.\n<|/ c |>\n<| c |>\nI've\
    \ added a link to the original post which explains the code.\n<|/ c |>\n<| a tags=julia,string\
    \ |>\nThe answer from Patrick Artner (and the other answers) is definitely the\
    \ most elegant solution so far, however I wanted to share a Julia 1.x solution\
    \ for people who use Julia 1.x for some reason:\n<code>", "    # Write your code\
    \ in Julia 1.0\n    # Code you write here is hidden from grading and grading sessions,\
    \ but is accessible for debugging and self-assessment\n    return x<0 ? \"\" :\
    \ string(circular_shift_helper(x,shift))\nend", "    digits = to_digits(x)\n \
    \   new_digits = digits[shift::shift]\n    return join(new_digits, digits[(shift\
    \ + 1):length(x)])\nend", "    string = \"\"\n    for i in x:\n        string\
    \ = string + (i * shift)\n        shift = shift - 1\n    return string\n</code>\n\
    The algorithm I used to find the answer is described below:", "    if shift <\
    \ 0\n        return reverse (digits(x))\n    else\n        return digits(x)[(size(x)\
    \ + shift)..end]\nend\n</cell>\n<text>\nAs a function:", "    digits::Vector{String}\
    \ = getdigits(x)\n    circular_shift::String = \"\"\n    \n    if shift > length(x)\n\
    \        for i in digits[shift:end]\n            circular_shift = circular_shift\
    \ * i + digits[i]\n        end\n        return circular_shift\n        \n    else\n\
    \        for i in digits[1:shift-1]\n            circular_shift = circular_shift\
    \ * i + digits[i]\n        end\n        return circular_shift\n    end\nend\n\
    </cell>\n<code language=julia-1.4>\ntest_circular_shift()\n</cell>\n<text>\nExercise:\
    \ Circular shift the digits of a number with a given step size (shift)", "   \
    \ \"\"\"Circular shift the digits of the integer x, shift the digits right by\
    \ shift and return the result as a string.\n    If shift > number of digits, return\
    \ digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12,\
    \ 2)\n    \"12\"\n    \"\"\"\n    \n    # shift the digits right by shift - shift\
    \ > number of digits\n    if shift > length(x)\n        return reverse(x)\n  \
    \  \n    else # shift <= number of digits\n        return x * pow(10, shift)\n\
    end\n</cell>\n<code language=julia-1.3>", "    if shift < length(x) \n       \
    \ return reverse(join(reverse(slice(x,shift,length(x)))))\n    else\n        return\
    \ join(reverse(slice(x,shift,length(x)))) \nend\n</cell>\n<code language=julia-1.6>\n\
    circular_shift(123456789, 4)\n</cell>\n<code language=julia-1.6>", "    if shift\
    \ >= length(x) || shift < 1\n        error(\"shift must be in range [1,length(x)]\"\
    )\n    else\n        String(x)[shift-1, :]\n    end\nend\n</cell>\n<text>\n4.2.\
    \ Reverse the digits of x\nThis is done by multiplying x by 10, 10^k, 10^(k+1),\
    \ ..., 10^1, then dividing by 10^k.", "    if shift>length(x)\n        return\
    \ reverse(digits(x))\n    digits = reverse(reverse(x))\n    digits = digits[0..-shift]\n\
    \    return reverse(digits)\nend\n</cell>\n<code language=julia-1.3>", "    digits\
    \ = digits(x)\n    digits = [digits[i] for i in 1:length(digits) - shift + 1]\n\
    \    digits[length(digits) - shift] = digits[length(digits) - shift - 1]\n   \
    \ digits = reverse(digits)\n    return join(digits, \"\")\nend", "    if shift\
    \ < 0\n        error(\"Shift must be positive\")\n    end\n    if shift >= length(x)\
    \ || shift > length(x)\n        error(\"Shift out of bounds: \" + string(x))\n\
    \    end\n    return string(x, start = 1, stop = shift)\nend\n</cell>\n<text>\n\
    Ceil\nFind the first integer greater than or equal to x.", "    if shift > size(x)\
    \ || shift < 0\n        error(\"Invalid shift $shift\")\n    elseif shift == 0\n\
    \        return string(x)\n    else \n        return string(x[end]) + circular_shift(x[1:end-1],\
    \ shift-1)\nend", "    if shift < 0\n        shift = 0\n        if shift > 0\n\
    \            shift = 0\n        else\n            shift = 0\n    end", "    if\
    \ shift > length(x)\n        return reverse(x)\n    else if shift < 0\n      \
    \  return circular_shift(x, abs(shift))\n    else\n        return substr(x, 1,\
    \ (length(x)-shift))\nend\n\"\"\"\n    Chi-squared test of non-parametric univariate\
    \ data.\n    The null hypothesis is that the data has a normal distribution. \
    \ The\n    degrees of freedom (N) of this test are equal to the number of samples.\n\
    \    \n    When there are more observations than the degrees of freedom, the test\
    \ will\n    fail, indicating that the data has an unequal distribution.  When\
    \ there are\n    less observations than the degrees of freedom, the test will\
    \ pass \n    indicating that the data has a normal distribution.\n    \"\"\"",
  "\"\"\"\n    \n    let digits = string(x)\n    let ndigits = length(digits)\n  \
    \  \n    if shift >= ndigits, digits\n    if shift < 0, return digits[0..ndigits\
    \ + shift - 1] + digits[0..shift - 1]\n    \n    let start = digits[0..(shift\
    \ - 1)]\n    let end = digits[0..ndigits - shift]\n    let result = start + end\n\
    \    \n    return result\nend\n</cell>\n<code language=julia-0.6>\ntest_circular_shift(12);\n\
    test_circular_shift(12);\ntest_circular_shift(12);\n</cell>\n<code language=julia-0.6>\n\
    # Odd length strings", "    if shift > length(x)\n        return reverse(x)\n\
    \    else\n        digits = digits(x)\n        shiftDigits = circular_shift(digits,\
    \ shift)\n        return digits[0..shiftDigits] |> String.reverse |> to_string\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    circular_shift(x, digits)",
  "    if shift < 0 then return x\n    if shift > floor(log2(x)) + 1\n         return\
    \ circular_shift(x, shift + ceiling(log2(x)))\n    result::String = string(x)\n\
    \    digit::String = result[end]\n    for i = end - shift + 1 downto 0 do result[i]\
    \ = digit\n    for i = end - shift -1 downto 0 do result[end - 1 + i] = digit\n\
    \    result[end - 1] = digit\n    return string((reverse(result)[1:]))\nend",
  "    if shift > length(x) || shift < 0\n       error(\"Shift must be >= 0 & < #\
    \ of digits in input\")\n       end\n    return reverse(reverse(x)[Int64(1):Int64(length(x)):Int64(shift):1])\n\
    end", "    return String(digits(x)[length(digits(x)) - shift, shift, length(x)\
    \ - shift : end - shift])\nend", "    str = strtonumstr(x)\n    str2 = str\n \
    \   for i in str2\n        str2 = str2.insert(i, \" \")\n    return str2.reverse\n\
    end\n</cell>\n<code language=julia-1.0>\n\"\"\"\nFind the maximum value in a list\
    \ of integers, starting from the right\nand moving left through the list as necessary.\n\
    \"\"\"", "    # Your code here\n        if shift > length(x)\n            shift=length(x)\n\
    \        end\n        \n        if shift < 0\n            shift=0\n        end\n\
    \        \n        if shift > length(x)\n            shift=length(x)\n       \
    \ end\n        \n        \n        digits=[String(digit) for digit in string.digits]\n\
    \        \n        shifted_digits=digits[shift::]\n        reversed_shifted_digits=reverse.(shifted_digits)\n\
    \        \n        \n        reversed_shifted_digits=[String(digit) for digit\
    \ in reversed_shifted_digits]\n        return join(reversed_shifted_digits)\n\
    end", "    if shift > length(x) then \n        digits = reverse(x) \n    else\
    \ \n        digits = x\nend\n</cell>\n<text>\nExercise 17", "    if shift > length(digits(x))\n\
    \        digits(x) = reverse(digits(x))\n        shift = (length(digits(x)) -\
    \ (shift - 1))\n    \"'\" .++(take(digits(x), shift)) <> \"'\"\nend", "    if\
    \ shift<=length(digits(x))\n        return digits(x)[length(x):length(x)-shift]\n\
    \    else\n        return reverse(digits(x)[length(x):length(x)-shift])\nend\n\
    </code>\n<|/ a dscore=3 tags=julia |>\n<| a |>\nThis might be helpful for someone:\n\
    <code>\njulia> function digits(n)\n           div(n)\n       end", "    x=string(x);\
    \ shift=string(shift); \n    length=length(x)\n    if length<shift then \n   \
    \     reverse(x.chars)\n        shift=length\n    end\n    digits=[]\n    for\
    \ i in range((shift):(shift+length))\n        push!(digits,x[end-i])\n    end\n\
    \    digits = reverse(digits)\n    \"\".(digits)\nend\n</cell>\n<code language=julia-0.5>\n\
    circular_shift(12, 1)\n</cell>\n<text>\nWe can also use recursion in Julia to\
    \ implement the circular shift (which can be reused for other circular shifts)",
  "    if shift > log10(x+1) - log10(x+1)\n    \n    else \n        return round(Float64(x/x)*pow(10,\
    \ shift)*pow(10, (log10(x+1) - log10(log10(x+1))) - shift))\nend\n</code>\n<|/\
    \ a tags=julia dscore=1 |>\n<| a tags=julia |>\nHere's my take on a solution for\
    \ Julia:\n<code>", "    if x == 0\n        throw(ZeroDivisionError, Msg(\"Cannot\
    \ perform a circular shift on 0, try using zerofill\"))\n    else\n        return\
    \ to_string(x::Int64, shift)\nend\n</code>\n<|/ a tags=julia |>\n<| a tags=julia\
    \ dscore=1 |>\nHere's a version that works for both signed and unsigned integers:\n\
    <code>", "    if shift < -x.digits || shift > x.digits\n        error(\"Circular\
    \ shift out of bounds\")\n    elseif shift > 0\n        return reverse(digits(x))[end\
    \ - shift..end]\n    else\n        return reverse(digits(x))[0..end]\nend", " \
    \   digits = \"\"\n    digits = (digits:reverse)\n    return digits\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nI recommend you add an explanation for your answer.\n\
    <|/ c |>\n<| c |>\nHi Randy, I edited the post to include some explanation. I\
    \ am new to this and trying to learn as I go.\n<|/ c |>\n<| a tags=number-theory,julia,arrays,integer,binary\
    \ dscore=0 |>\nHere is a simple and elegant answer to the question, where the\
    \ array is of size n:\n<code>", "    \"circular_shift(12, 1)\"\n    return \"\
    nothing\"\nend\n</cell>\n<text>\nCircular shifting a number x by k places means\
    \ shifting by (k mod x) digits.", "    # define the max size of the string and\
    \ initialize it with zeros\n    digit_len::Int = math.ceil(math.log(abs(x), 10))\n\
    \    ret_str::String = String(repeat 0, digit_len)\n    # shift right by shift,\
    \ then append new digits to ret_str\n    for i in 0..digit_len - shift\n     \
    \   ret_str[i] = ret_str[i + shift]\n        # set new digit to be zero for all\
    \ digits to the left of i + 1\n        ret_str[i + shift] = String(0, digits_to_int(math.abs((x\
    \ % 10^i)))) \n    return ret_str\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ tags=algorithm,recursion,julia,performance |>\nAs others have noted, the algorithm\
    \ you describe is a very difficult one, and it is unlikely that any of them is\
    \ going to be fast enough in practice. You could try some variations on the classic\
    \ \"binary chop\" algorithm: break it into chunks of four digits each, and multiply\
    \ the chunks together in that way, but that won't necessarily be faster than your\
    \ current implementation. Another approach might be to look at different ways\
    \ of preprocessing the input: pre-calculating an exponentiation of each digit\
    \ or shifting each digit left or right, or something along those lines.\nBut there's\
    \ another possibility: since you're in Julia, you can use its native BigInt type\
    \ to store your integers, so that you can do arithmetic in a way that has some\
    \ speedup:\n<code>\njulia> x = big(\"123456789012345\")\nbig \"123456789012345\"",
  "    if shift > length(x) \n        return reverse(digits(x))\n    \n    res = reverse(string(x)\
    \ % string(x))\n    return reverse(res)\nend\n</cell>\n<code language=julia-1.6>\n\
    # Example: 12 is shifted 1 place to left \n# Circularly shifting the digits is\
    \ like rotating the digits. \n# 12 is 102, shifted 1 place left is 101 and so\
    \ on...", "    if shift < 0  or shift > Int64(Int.max)/2\n        error(\"shift\
    \ must be in 0..half of Int64\")\n    else\n        if shift == 0\n          \
    \  digits(x)\n        else\n            digits(circshift(Int64(x), Int64(shift)))\n\
    end", "    if shift < 0\n        error(\"shift must be positive\")\n    digits\
    \ = toChars(x)\n    if shift > length(x)\n        return digits[-shift]\n    else\
    \ if shift > 0\n        return digits[shift:end-x+shift]\n    else\n        return\
    \ digits[end:end-x+shift]\nend\n</cell>\n<code language=julia-0.6>", "    if (shift\
    \ > length(x)) \n        shift <- length(x)\n    else \n        shift <- 0\n \
    \   x %= MODULO \n    x .== 0 && return \"\"\n    x .== 0 && return \"0\"\n  \
    \  digits_left <- digits(x)\n    digits_right <- digits_left\n    for i in reverse(digits_right)\
    \ \n        digits_right <- digits_right[1:0] + digits_right[3:2] + digits_right[5:4]\
    \ + digits_right[7:6] + digits_right[9:8] + digits_right[11:10] + digits_right[13:12]\
    \ + digits_right[15:14] + digits_right[17:16] + digits_right[19:18] + digits_right[21:20]\
    \ + digits_right[23:24] + digits_right[25:26] + digits_right[27:28] + digits_right[29:30]\
    \ + digits_right[31:30]\n    digits_left <- digits_left[1:shift] + digits_left\
    \ + digits_right\n    x <- x * 10 + digits_left[shift]\n    return sprintf(\"\
    %0*d\", length(digits_left), x)\nend", "    if shift > Int64(length(x))\n    \
    \    shift = Int64(length(x))\n        shift_reversed = shift - 1\n        shift_reversed\
    \ = shift_reversed + 1\n        return reverse(digits(x), shift_reversed)\n  \
    \  else\n        return digits(x, shift)\nend\n</cell>\n<code language=julia-0.3>\n\
    \"\"\"Compute the number of digits in a number.\"\"\"", "    if shift <= 0\n \
    \       error(ArgumentError(\"shift must be > 0\"))\n    end\n    if shift > length(x::Int64)\n\
    \        error(ArgumentError(\"shift must be <= number of digits in x\"))\n  \
    \  end\n    digits = split(x::Int64)\n    result = digits[end-1]\n    for j =\
    \ length(digits) - 2; j >= shift(end - 1)\n        result[j], result[j+1] = result[j+1],\
    \ result[j]\n    end\n    return join(result)\nend\n</cell>\n<text>\nNow we can\
    \ use circular_shift to complete the problem. First we define an example string\
    \ $x$:", "    digits = string(x)\n    if shift > length(digits)\n        return\
    \ digits\n    digits[1:shift] = digits[shift:end-1]\n    return join(digits[shift-1:-1:1],\
    \ digits[end-1:shift-1:-1])\nend", "    digits = show(x::Int64)\n    if digits\
    \ < 1\n        return \"0\"\n    end", "    if shift > length(x) return string(x)\n\
    \    if shift == 0 return \"\"\n    shift /= 2\n    reverse = \"\"\n    digits\
    \ = reverse\n    for n in digits[shift+1:length(digits)]:\n        reverse = reverse(digits[shift]\
    \ + n)\n    return reverse(digits)", "    if shift > length(x)\n        return\
    \ reverse(x)\n    else if shift < 0\n        return \"\"\n    else if shift ==\
    \ 0\n        return x\n    return circular_shift(shift(x, 0), shift - 1)\nend\n\
    </cell>\n<text>\nAnd now let's do some tests.", "    \"Circular shift the digits\
    \ of the integer x, shift the digits right by shift and return the result as a\
    \ string\"\n    if shift == 1 \n        digits = [x.digits[i] + x.digits[i+1]\
    \ for x in digits]\n        digits = digits[end-1]..digits[end]\n    else \n \
    \       digits = [x.digits[i] for i in (-shift):end]\n        digits = digits[-shift:]..digits[end]\n\
    \    return string(digits)\nend", "    if shift == 0\n        \n        return\
    \ \"\"\n    \n    else if shift > length(x)\n    \n        shift = shift - length(x)\n\
    \        \n        return reverse(circular_shift(x, shift))\n    \n    else\n\
    \    \n        shift = (shift)-1\n        \n        return reverse( circular_shift(x,shift)\
    \ + circular_shift(x,shift-1)  )\nend \n</code>\n<|/ a dscore=2 |>\n<| a tags=julia\
    \ dscore=2 |>\nI wanted to add something to the existing answers about what happens\
    \ when a shift value is negative. \nSince we are shifting digits, I assume that\
    \ we are shifting by powers of 10.\nThus, shifting by -5 would not do anything,\
    \ since the number 12 is equivalent to 12 * 100. \nFor negative shifts, we could\
    \ either shift by -digits+1 or simply use the builtin reverse(x) function, which\
    \ reverses the string representation of its argument: \n<code>\njulia> reverse(1234)\n\
    \"4321\"\njulia> reverse(-1234)\n\"4321\"\njulia> reverse(12345)\n\"6543\"\njulia>\
    \ reverse(-12345)\n\"6543\"\njulia> reverse(1234567890)\n\"98765321\"\njulia>\
    \ reverse(-1234567890)\n\"98765321\"\njulia> reverse(0)\n\"\"\njulia> reverse(-1)\n\
    \"1\"\njulia> reverse(1)\n\"1\"\njulia> reverse(10)\n\"10\"\njulia> reverse(100)\n\
    \"100\"\n</code>\nIf we want to shift by -digits, we can shift by -digits + 1:\
    \ \n<code>\njulia> reverse(1234, 5)\n\"3412\"\njulia> reverse(1234, -1)\n\"4321\"\
    \njulia> reverse(1234, 4)\n\"1234\"\njulia> reverse(1234, 3)\n\"1234\"\njulia>\
    \ reverse(1234, 2)\n\"1234\"\njulia> reverse(1234, 1)\n\"1234\"\njulia> reverse(1234,\
    \ 0)\n\"\"\njulia> reverse(1234, -1)\n\"4321\"\njulia> reverse(1234, -2) \n\"\
    4321\"\njulia> reverse(1234, -3)\n\"4321\"\njulia> reverse(1234, -4)\n\"4321\"\
    \njulia> reverse(1234, -5)\n\"4321\"\n</code>\n<|/ a |>\n<| a tags=julia dscore=1\
    \ |>\nI do not think there is any built-in function for this, but you can easily\
    \ implement your own function using recursion:\n<code>", "    if shift > digits(x)\
    \ \n        return reverse(digits(x))\n    else\n        reverse(digits(x))\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert circular_shift(1, 1)\
    \ == 1 \n@assert circular_shift(1, 2) == 2 \n@assert circular_shift(1, 3) == 3\
    \ \n@assert circular_shift(1, 4) == 4 \n@assert circular_shift(1, 5) == 5 \n@assert\
    \ circular_shift(1, 6) == 6 \n@assert circular_shift(1, 7) == 7 \n@assert circular_shift(1,\
    \ 8) == 8 \n@assert circular_shift(1, 9) == 9 \n@assert circular_shift(2, 1) ==\
    \ 2 \n@assert circular_shift(2, 2) == 4 \n@assert circular_shift(2, 3) == 6 \n\
    @assert circular_shift(2, 4) == 8 \n@assert circular_shift(2, 5) == 10 \n@assert\
    \ circular_shift(2, 6) == 12 \n@assert circular_shift(2, 7) == 14 \n@assert circular_shift(2,\
    \ 8) == 16 \n@assert circular_shift(2, 9) == 18 \n@assert circular_shift(3, 1)\
    \ == 3 \n@assert circular_shift(3, 2) == 6 \n@assert circular_shift(3, 3) == 9\
    \ \n@assert circular_shift(3, 4) == 12 \n@assert circular_shift(3, 5) == 15 \n\
    @assert circular_shift(3, 6) == 18 \n@assert circular_shift(3, 7) == 21 \n@assert\
    \ circular_shift(3, 8) == 24 \n@assert circular_shift(3, 9) == 27 \n@assert circular_shift(4,\
    \ 1) == 4 \n@assert circular_shift(4, 2) == 8 \n@assert circular_shift(4, 3) ==\
    \ 12 \n@assert circular_shift(4, 4) == 16 \n@assert circular_shift(4, 5) == 20\
    \ \n@assert circular_shift(4, 6) == 24 \n@assert circular_shift(4, 7) == 28 \n\
    @assert circular_shift(4, 8) == 32 \n@assert circular_shift(4, 9) == 36 \n@assert\
    \ circular_shift(5, 1) == 5 \n@assert circular_shift(5, 2) == 10 \n@assert circular_shift(5,\
    \ 3) == 15 \n@assert circular_shift(5, 4) == 20 \n@assert circular_shift(5, 5)\
    \ == 25 \n@assert circular_shift(5, 6) == 30 \n@assert circular_shift(5, 7) ==\
    \ 35 \n@assert circular_shift(5, 8) == 40 \n@assert circular_shift(5, 9) == 45\
    \ \n@assert circular_shift(6, 1) == 6 \n@assert circular_shift(6, 2) == 12 \n\
    @assert circular_shift(6, 3) == 18 \n@assert cir", "    str = String(x)\n    len\
    \ = length(str)\n    i = 2\n    while i < len\n        str = str[(i + shift)..(i\
    \ + 1)]\n        i += 1\n    end\n    str = reverse(str)\n    return str\nend",
  "    if shift > Int64(Int64, digits(x))\n        shift = Int64(Int64, digits(x))\n\
    \    \n    var s = x.to_string()\n    for i in 0..(shift - 1) - 1 \n        s\
    \ = insert(s, String(i), String(i))\n    return s\nend", "    if x < 0 \n    \
    \    return \"\" \n    digits = math.ceil(math.log(abs(x), 10))\n    return format(x,\
    \ digits, digits = digits)\nend\n</cell>\n<code language=julia-1.5>\n@test circular_shift(12,\
    \ 1) == circular_shift(12, 2)\n</cell>\n<code language=julia-1.5>\n\"\"\"Return\
    \ the digit of a number as a string.\n    >>> tostring(1)\n    \"1\"\n    >>>\
    \ tostring(0)\n    \"0\"\n    >>> tostring(-1)\n    \"-1\"\n    >>> tostring(-10)\n\
    \    \"-10\"\n    >>> tostring(123456789)\n    \"123456789\"\n    >>> tostring(-123456789)\n\
    \    \"-123456789\"\n    \"\"\"", "    x % 2 == 0 && return \"0\" + circular_shift(x\
    \ >> 1, shift + 1)\n    x % 2 != 0 && return \"1\" + circular_shift(x >> 1, shift\
    \ + 1)\nend\n</code>\n<|/ a dscore=0 tags=recursion,julia,string |>\n<| c |>\n\
    This doesn't seem to work for large integers. Try `circular_shift(1234567890123456,\
    \ 4)`. You will get `1234567890123456`\n<|/ c |>\n<| a dscore=0 |>\nApart from\
    \ using strings there are other options such as binary representation and bit\
    \ shifting in Julia to generate a string of length given by shift. This will work\
    \ in cases where only 1 digit has to be incremented and for integer number of\
    \ digits in string as per your example. \n<code>", "    if shift < 0 || (shift\
    \ % 2 == 0)\n        error(\"shift must be non-negative\")\n    elseif shift >\
    \ length(x)\n        error(\"shift cannot be larger than number of digits in x\"\
    )\n    elseif shift == 0\n        return x.digits\n    else\n        digits =\
    \ reverse(x.digits)\n        for _ in 0..shift\n            digits = shift(digits)\n\
    \        return reverse(digits)\n    end\nend\n</code>\n<|/ a |>\n<| c |>\nWhy\
    \ would you use `.digits` and `.slice`?\n<|/ c |>\n<| c |>\nthe original question\
    \ uses digits and slice, so I took that as an example.\n<|/ c |>\n<| a tags=julia\
    \ |>\nUsing base 10\n<code>", "    if shift <= 0 \n        return \"\" \n    elseif\
    \ shift == 0 \n        return x\n    else \n        digits = digits(x) \n    \
    \    return reverse(digits[0, shift, shift:end])\nend", "    if shift < 0 || shift\
    \ > 64 then \n        error \"Shift must be between -64 and 64\"\n    end\n  \
    \  digit_str = digits(x)\n    digits_str = join(reverse(split(digit_str, \"\"\
    )), \"\")\n    if shift > 64 then\n        digits_str = reverse(digits_str)\n\
    \    end\n    return join(reverse(split(digits_str, \"\")), \"\")\nend\n</code>\n\
    <|/ a tags=digits,numbers,julia |>\n<| c |>\nFor `digits(0)` this throws `ERROR:\
    \ ArgumentError: attempt to index with non-positive index 1`.\n<|/ c |>\n<| c\
    \ |>\nthanks for the catch! I've updated the answer accordingly and also added\
    \ the check for the case of `digits(0)` so that it will return the empty string\
    \ instead\n<|/ c |>\n<| a tags=digits,numbers,julia |>\nA short solution:\n<code>\n\
    julia> function digits(x::Int64)\n           return join(reverse(split(digits(x::Int64),\
    \ \"\")), \"\")\n       end\ndigits (generic function with 1 method)", "    \"\
    \"\"\n    >>> circular_shift(121, 2)\n    \"11\"\n    >>> circular_shift(121,\
    \ 3)\n    \"21\"\n    >>> circular_shift(121, 5)\n    \"211\"\n    >>> circular_shift(121,\
    \ 10)\n    \"2112\"\n    \"\"\"", "    if shift <= length(digits(x))\n       \
    \ return circular_shift(digits(x), shift-1)\n    else return reverse(digits(x))\n\
    end\n</cell>\n<text>\nThe function will return a string of the given integer x\
    \ circularly shifted by shift places.", "    if shift > length(x)\n        return\
    \ reverse(x)\n    else\n        digits = reverse(digits(x))\n        shifted =\
    \ shift(digits)\n        digits_shifted = 0\n        for i in shifted\n      \
    \      digits_shifted += digits(i)\n        end\n        return reverse(digits_shifted)\n\
    end", "\"\"\"\n    if shift >= size(x)\n        return string(x::Int64)\n    digits\
    \ = string(x::Int64)\n    digits[1..(shift - 1)] = \"\"\n    digits[-(shift)..]\
    \ = \"\"\n    return digits\nend\n\"\"\"\n    string(x::Int64) = \"0\" * size(x)\
    \ + string(x::Int64)\n\"\"\"\n    string(x::Int64) = string(x::Int64)[1..size(x)]\n\
    end", "    if shift == 0\n        return \"0\"\n    digits = string(x)\n    if\
    \ digits == \"0\"\n        return digits\n    shift1 = shift - 1\n    shift2 =\
    \ shift - digits.length\n    digits1 = digits[0..digits.length - shift1]\n   \
    \ digits2 = digits[shift1..digits.length]\n    return digits + digits1 + circular_shift(digits2,\
    \ shift2)\nend\n</cell>\n<code language=julia-1.6>\n?circular_shift\n</cell>\n\
    <code language=julia-1.6>\n@code_warntype circular_shift(12, 2)\n</cell>\n<code\
    \ language=julia-1.6>\n?string\n</cell>\n<code language=julia-1.6>", "    if shift\
    \ == 0\n        return \"\"\n    digits = toInt(digits(x))\n    shift = toInt(digits[shift,\
    \ :])\n    digits *= shift\n    return toStr(digits)\nend\n</cell>\n<code language=julia-0.4>\n\
    \"\"\"Reverse a string\"\"\"", "    if shift > log10(x)\n        return reverse(x.digits)\n\
    \    else\n        return reverse(x.digits[-shift:])\nend\n</code>\n<|/ a |>\n\
    <| c |>\nthank you very much for all the useful information. I want to ask this\
    \ question to understand it clearly: is `digits` a built-in function?\n<|/ c |>\n\
    <| c |>\nI guess `digits` might be a method of [`AbstractFloat`](http://www.julialang.org/docs/latest/stdlib/abstractfloat/#Base.digits).\
    \ But you can also define it yourself.\n<|/ c |>\n<| a |>\n<code>", "\"\"\"Circular\
    \ shift the digits of the integer x, shift the digits right by shift\n    and\
    \ return the result as a string.\n    If shift > number of digits, return digits\
    \ reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12,\
    \ 2)\n    \"12\"\n    \"\"\"\nend\n</cell>\n<code language=julia-1.6>", "    if\
    \ shift > length(digits(x)) \n        digits(x) = reverse(digits(x))[1:shift]\n\
    \    else\n        digits(x) = reverse(digits(x))[1:shift]\n    return digits(x)\n\
    end\n</cell>\n<code language=julia-1.0>", "    return reverse(take(length(x),\
    \ x, shift + 1))\nend", "    if shift > length(x) then\n        digits = digits(x)\n\
    \        digits[shift+1:-shift] = digits[-shift-1:-1]\n        return join(digits)\n\
    \    end\n    return x\nend\n</cell>\n<text>\nStrings\nStrings are arrays of characters.\
    \ In Julia they are immutable and they can be defined with square brackets. However,\
    \ in Julia strings are also mutable. You can assign new characters to strings\
    \ and you can concatenate strings together. Here are some examples.", "    \"\"\
    \"Circular shift the digits of the integer x, shift the digits right by shift\
    \ \n    and return the result as a string.\n    If shift > number of digits, return\
    \ digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12,\
    \ 2)\n    \"12\"\n    \"\"\"\n    digits = digits(x)\n    if shift > length(digits)\n\
    \        return reverse(digits)\n    digits = digits[-(shift - length(digits))..-1]\n\
    \    return reverse(digits)\nend", "    digits = reverse(x::Int64)\n    return\
    \ join(reverse(digits[shift:]), reverse(digits[:shift]))\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert circular_shift(12, 1) == circular_shift(12, 2)\n\
    @assert circular_shift(12, 3) == circular_shift(12, 2)\n@assert circular_shift(12,\
    \ 4) == circular_shift(12, 3)\n@assert circular_shift(12, 5) == circular_shift(12,\
    \ 4)\n@assert circular_shift(12, 6) == circular_shift(12, 5)\n@assert circular_shift(12,\
    \ 7) == circular_shift(12, 6)\n@assert circular_shift(12, 8) == circular_shift(12,\
    \ 7)\n@assert circular_shift(12, 9) == circular_shift(12, 8)\n</cell>\n<text>\n\
    Implement the method get_digits, which:", "    \"Circular shift the digits of\
    \ the integer x, shift the digits right by shift and return the result as a string.\"\
    \n    if shift == 0\n        return string(x)\n    \n    \n    if shift > length(x)\n\
    \        return reverse(string(shift(x,shift-length(x))))\n    \n    \n    \n\
    \    digits = string(x)\n    digits_len = length(digits)\n    \n    if shift >\
    \ digits_len\n        digits = digits[digits_len-shift:digits_len]\n    elseif\
    \ shift < 0\n        digits = reverse(digits)\n        digits = shift(digits,\
    \ -shift)\n        digits = reverse(digits)\n    \n    return digits\nend\n</cell>\n\
    <text>\nExercise 2.3\nWrite the function shift_digits_right(x, shift) which takes\
    \ the integer x and an integer shift. The function shifts the digits right by\
    \ shift, shifts the digits right by shift and returns the result as a string.",
  "    if shift == 0\n        return \"\"\n    if shift == -1\n        return reverse(x.digits)\n\
    \    if shift > x.digits.length\n        shift = x.digits.length - 1\n    res\
    \ = \"\"\n    for i in 0..shift\n        res *= 10\n        res <- x.digits[i]\n\
    \    end\n    return res\nend\n</code>\n<|/ a tags=julia dscore=2 |>\n<| c |>\n\
    This doesn't really answer the question, which is how to avoid the loop here.\n\
    <|/ c |>\n<| c |>\nIt doesn't answer the question. But it solves my problem. Thank\
    \ you very much!\n<|/ c |>\n<| c |>\nOk, I read it again and I see that your answer\
    \ is more general. It solves my problem, and I realized that's the best way to\
    \ do it. But it doesn't work for me because I need the result as a string not\
    \ an Int64 or the reverse() function is not defined for strings. Maybe I can change\
    \ your code to fit my needs?\n<|/ c |>\n<| c |>\nI updated the answer to make\
    \ it work for both Int64 and String\n<|/ c |>\n<| a tags=julia |>\n<code>", " \
    \   if shift == 1\n        digits(x)\n    else\n        digits(x) - circular_shift(digits(x),\
    \ shift - 1)\nend", "    # check shift is non-negative\n    if shift < 0 \n  \
    \      error(\"shift must be non-negative\") \n    else \n        if shift > int64(digits(x))\n\
    \            error(\"shift must be less than or equal to number of digits\") \n\
    \        else \n            return string(digits(x) - shift % int64(digits(x)),\
    \ digits(x))\n    end\nend\n</cell>\n<text>\nA better way is to define an efficient\
    \ circular_shift function, which does not require to calculate the digit count.\
    \ This function may look like this:", "    if shift > length(x)\n        return\
    \ reverse(split(reverse(x), \" \"))[1]\n    else\n        return reverse(split(reverse(x),\
    \ \" \")) |> first\nend", "    if shift <= 0\n        throw \"shift must be positive\"\
    \n    if shift > length(x)\n        shift %= length(x)\n    return String(x[1:shift],\
    \ x[shift+1:length(x)]) \nend", "    digits = digits(x)\n    \n    if (shift >\
    \ length(digits))\n        digits = reverse(digits)\n    \n    shift = shift %\
    \ length(digits)\n    \n    digits = digits[0..shift]\n    \n    return digits::String\n\
    end\n</cell>\n<code language=julia-1.5>", "    if x<0\n        throw(ArgumentError(\"\
    Cannot shift negative number\"))\n    else\n        x %= (10^shift)\n        result\
    \ = \"\"\n        for n in 1:shift\n            result = digits(x) + result\n\
    \            x >>= 10\n        end\n        return result\n    end\nend\n</code>\n\
    <|/ a tags=julia,string |>\n<| a dscore=0 |>\nIf you want a solution using only\
    \ string operations you can do something like this:\n<code>", "        if shift\
    \ > Int64(digits(x)) - 1 \n        then return reverse(x, shift-Int64(digits(x))\
    \ - 1)\n        else return reverse(x, Int64(digits(x)) - shift)\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis is just awesome. Thank you!\n<|/ c |>\n<| a dscore=4 |>\n\
    I have created this function which works for positive and negative integers \n\
    <code>", "    if shift < 0\n        error(\"shift must be at least zero\")\n \
    \   end\n    if shift > max(x)\n        error(\"shift cannot be greater than $(x)\"\
    )\n    end\n    if x > 0\n        result = to_string((x // shift) * shift)\n \
    \       result += string(tostring(x % shift), shift)\n    end\n    return result\n\
    end\n</cell>\n<code language=julia-1.5>", "    return (parseInt((x + shift) %\
    \ (10^shift))) \nend\n</cell>\n<text>\nThe function above works well to shift\
    \ by any number you like.\nThe function below shifts a string left by shift digits.\n\
    It takes a string as its argument and returns a string.\nIt uses a regular expression\
    \ to find all the digits in the string and shifts them left by shift.\nThe length\
    \ of the string must be at least shift.", "    if shift <= length(x) - length(reverse(x))\n\
    \    else x\nend\n</cell>\n<code language=julia-1.2>", "    if shift > length(digits(x))\n\
    \        shift = (length(digits(x)) -shift)\n    return \"0\" ++ reverse(reverse(x))[1..shift]\n\
    end\n</code>\n<|/ a |>\n<| a dscore=0 |>\nHere's one that uses lists:\n<code>",
  "    if x == 0 || x == 1 || x == -1\n    else if shift >= (digits(x))\n    then\
    \ return reverse(x)\n    else return x .- circular_shift(x, shift+1-(digits(x)))\n\
    end", "    if shift > length(x) || shift <= 0\n        return digits(x)[length(x)-shift:end]\n\
    \    else\n        return digits(x)[shift:end]\n    end\nend", "    \"Circular\
    \ shift the digits of the integer x, shift the digits right by shift and return\
    \ the result as a string\"\n    if shift > Int(ceil(log2(x))) then \n        reverse(x)\n\
    \    end\n    for i = 0:1\n        digit = Int(bits(x)[i]) shr shift\n       \
    \ if bits(x)[i] <> 0\n            x = x .- bits(x)\n            x = x .- bits(x)\n\
    \        else\n            x = x .- digit\n        end\n        x = x .- digit\n\
    \        x = x .+ digit\n    end\n    \n    return convert(Int, x)\nend\n</cell>\n\
    <code language=julia-1.0>\n\"\"\"Reverse the digits of the integer x, return as\
    \ a string.\n    >>> reverse(12345)\n    \"54321\"\n    \"\"\"", "  if x < 0\n\
    \    error(\"negative integers cannot be shifted in\")\n  else\n    digits = String(x)\n\
    \    digits_len = len(digits)\n    if digits_len > shift\n      digits_len = shift\n\
    \      digits.reverse()\n    shift_digits = String(x::Int64)\n    if shift > 0\n\
    \      shift_digits <<= shift\n    shift_digits = shift_digits + digits\n    shift_digits\
    \ = shift_digits.reverse()\n    return shift_digits\n</code>\n<|/ a tags=julia,python,julia-jump\
    \ |>\n<| c |>\nThis does not work for negative numbers. If you run it on `circular_shift(-12,\
    \ 1)` it gives `\"-21\"`, which is incorrect as `-12` is `21`\n<|/ c |>\n<| c\
    \ |>\nIt works for negative numbers: `circular_shift(-12, 2)` gives `\"-21\"`\
    \ as expected. Are you using another implementation of `circular_shift`?\n<|/\
    \ c |>\n<| a dscore=2 |>\nThis might work:\n<code>\ncircular_shift(x::Int64, shift::Int64)::String",
  "        digits = digits(x)\n        return reverse(digits[shift(digits)])\n   \
    \ end\nend\n</cell>\n<code language=julia-1.6>\n# Test cases:", "    if shift<0\n\
    \        return reverse(reverse(x))\n    x = (x .- digits(x)[shift])./digits(x)[shift]\n\
    \    y = x.*digits(x)\n    z = (x .+ digits(x)[shift])./digits(x)[shift]\n   \
    \ return toString(z) + toString(y)\nend\n</cell>\n<text>\n3.4.2 Digits multiplication",
  "    if shift < -len(digits(x)) || shift > length(digits(x)) then \"Out of range\"\
    \n    else str((todigits(x) % 10^-shift) % 10^shift) end\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nThis doesn't seem to be working. I tried circular_shift(123, -1)\
    \ but got \"Out of range\"\n<|/ c |>\n<| c |>\nIt should work, check my code,\
    \ I tested with julia 0.4.3\n<|/ c |>\n<| c |>\nWorks! Thank you so much! And\
    \ thanks for making it more efficient! :)\n<|/ c |>\n<| a dscore=2 tags=julia\
    \ |>\nFor those who are still looking for a solution, here is the one I implemented\
    \ using the Julia language. It uses Julia Base to convert numbers to string and\
    \ then reverse the string. \n<code>", "    digits = digits(x)\n    digits_reversed\
    \ = digits[0..length(x)-shift:]\n    return digits_reversed[0..length(x)-shift:]+digits[0..length(x)]\n\
    end\n</code>\n<|/ a tags=julia dscore=3 |>\n<| c |>\nI didn't say \"more efficient\"\
    ... ;)\n<|/ c |>\n<| c |>\nAh, I see that now. My comment was directed at the\
    \ OP, who made this as a puzzle (I did). I guess the answer should have been edited\
    \ to include the `digits` function from the first part of the question...\n<|/\
    \ c |>\n<| a dscore=2 |>\nOne way:\n<code>\ndigits(x) = (x, \"\")[digits(x)[2]\
    \ == \".\"]\n</code>\nIt's not pretty but it works.\n<|/ a tags=julia |>\n<| c\
    \ |>\nI like this one the most. I'm going to wait a bit to see if anyone else\
    \ comes up with a solution that is more efficient. But it might be the way to\
    \ go.\n<|/ c |>\n<| c |>\nIt's not possible to do much better, since you can't\
    \ optimize it better than O(n). However, if you want something more efficient,\
    \ you could convert the decimal to binary and use [this algorithm](https://en.wikipedia.org/wiki/Binary_numeral_system#Incremental_method).\
    \ It's pretty fast too.\n<|/ c |>\n<| c |>\nIt seems to me that `digits` will\
    \ actually return `2` if you pass in `0`.\n<|/ c |>\n<| a tags=julia dscore=2\
    \ |>\nHere is a solution which uses a recursive function:\n<code>", "    if shift\
    \ >= length(digits(x)) \n        return x \n    else \n        return x * 10 ^\
    \ shift \nend \n</cell>\n<code language=julia-1.6>\n@code_native circular_shift(12,\
    \ 1)\n</cell>\n<text>\nModulus\nThe modulus operator % returns the remainder of\
    \ a / b when b is positive.", "     if shift < 0\n     then return \"error\"\n\
    \     else if shift <= length(x)\n     then return circular_shift(circular_shift(x,\
    \ -shift), shift)\n     else return reverse(x)\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    circular_shift(12, 0)\n</cell>\n<code language=julia-1.0>\ncircular_shift(12,\
    \ 1)\n</cell>\n<code language=julia-1.0>\ncircular_shift(12, 2)\n</cell>\n<code\
    \ language=julia-1.0>\ncircular_shift(12, 3)\n</cell>\n<code language=julia-1.0>\n\
    circular_shift(12, 4)\n</cell>\n<text>\nExercise 3\nWrite a function that returns\
    \ the sum of all digits in an integer in reverse order.\nFor example, 123 returns\
    \ 3 + 2 + 1 = 6.\nNote that you should take into account that the length of the\
    \ integer can vary depending on the input data.", "    # Your code here\n    if\
    \ shift > size(x) or shift < 0\n        throw(DomainError(ErrorTag(ErrorTag.ERR_OUT_OF_BOUNDS)))\n\
    \    end\n    if x < 0\n        throw(DomainError(ErrorTag(ErrorTag.ERR_OUT_OF_BOUNDS)))\n\
    \    end\n    return to_string(string(shift(x, shift)))\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI believe this is an interesting implementation but I don't think\
    \ it answers the question (how to use circular_shift). Can you add some explanation\
    \ or perhaps point to a source?\n<|/ c |>\n<| a dscore=1 |>\nI needed the same\
    \ thing. I found a nice article that explains how to write a function and how\
    \ it works. \nhttps://julialang.github.io/2017/09/30/the-right-way-to-do-math-with-strings/\n\
    <|/ a tags=julia,string,algorithm,numbers |>\n<| a dscore=1 |>\nAnother simple\
    \ solution is:\n<code>", "    if shift > length(x) \n        error(\"shift must\
    \ be smaller than length(x)\")\n    return reverse (digits(x), shift)\nend", " \
    \   if (x < 0) || (shift < 0)\n        error(\"input error\")\n    end\n    if\
    \ shift == 0\n        return str(x)\n    else\n        x = x + shift\n       \
    \ digits = String[]\n        digits = reverse(digits)\n        while x > 0\n \
    \           digits[digits.length-1] = x % 10\n            x = floor(x/10)\n  \
    \      end\n        reverse(digits)\n        return join(digits, \"\")\n    end\n\
    end\n    \"\"\"\n    )\n    assert circular_shift(10, 2) == \"21\"\n    assert\
    \ circular_shift(10, 3) == \"21\"\n    assert circular_shift(10, 4) == \"121\"",
  "    if shift > size(x)\n        circular_shift(reverse(toInt(x)), shift - size(x))\n\
    \    else\n        reverse(toInt(x))[end - shift .. end]\nend\n</cell>\n<code\
    \ language=julia-1.3>\ncircular_shift(6, 1)\n</cell>\n<code language=julia-1.3>\n\
    circular_shift(6, 2)\n</cell>\n<code language=julia-1.3>\ncircular_shift(6, 3)\n\
    </cell>\n<code language=julia-1.3>\ncircular_shift(6, 4)\n</cell>\n<code language=julia-1.3>\n\
    circular_shift(6, 5)\n</cell>\n<code language=julia-1.3>\ncircular_shift(6, 6)\n\
    </cell>\n<code language=julia-1.3>", "    if shift > length(x) - 1 then return\
    \ \"\"\n    else return reverse(reverse(x))[1:shift]\nend", "    # Make sure shift\
    \ is non-negative\n    if shift < 0 \n        return \"\" \n    \n    # Base case\n\
    \    if shift == 0 \n        return to_string(x) # Base case\n    \n    # Recursive\
    \ case\n    x %= 10\n    digits = to_string(x) # Get digits to left of x\n   \
    \ digits_reversed = circular_shift(digits, shift - 1) # Circular shift\n    return\
    \ digits + digits_reversed # Combine digits from left and right shift\nend", " \
    \   if shift==0 \n        then return x \n    else \n        let (digits, exponent)\
    \ = floor_digits(x)\n        circular = digits[1..exponent]\n        circular_right\
    \ = digits[exponent+1..end]\n        let shift = shift - 1\n        let right\
    \ = circular_shift(circular_right, shift)\n        digits[1..exponent] = circular\n\
    \        digits[exponent+1..end] = right\n        return digits.reverse()\nend\n\
    </cell>\n<code language=julia-1.2>\n#export", "    length::Int64 = length(x)\n\
    \    if shift > length || shift < 0\n        throw(DomainError(string(\"shift\
    \ must not be \", length, \"+\", shift)))\n    else\n        reversed::String\
    \ =\n            reverse(reverse(digits(x)))[1..shift]\n        digits_reversed::String\
    \ =\n            reverse(digits(x))\n        return (digits_reversed)[1..shift]\
    \ .+ reversed\nend", "    if shift > length(x) * 2 \n        shift = length(x)\
    \ * 2 - shift end", "    if shift < 0 || shift > length(x) || shift > length(tostring(x))\
    \ || shift > length(tostring(tostring(x)))\n        return \"Invalid shift\"\n\
    \    elseif shift == 0 \n        return tostring(x)\n    else\n        z = zero(Int64)\n\
    \        z = x >> shift\n        z = x - (x << shift)\n        return tostring(z)\n\
    end\n</code>\n<|/ a |>\n<| c |>\nI made a mistake in the second line and edited\
    \ my answer, now it should be ok\n<|/ c |>\n<| a dscore=0 |>\n<code>\nusing DrJava",
  "    if shift==0 \n        shift=length(x)\n    if shift < 0 \n        shift=shift+length(x)\n\
    \    digits=digits(x)\n    length=length(digits)\n    digits[1:length]\n    digits=reverse(digits[1:length])\n\
    \    digits=reverse(digits)\n    digits=digits[shift-1:]\n    digits=reverse(digits)\n\
    \    digits=digits[1..length]\n    digits=reverse(digits)\n    return digits\n\
    end\n</cell>\n<text>\nNow the function looks good.", "    # Return digits reversed\n\
    \    if shift > length(x)\n        shift := length(x)\n        return circular_shift(shift(x),\
    \ shift)\n    \n    digits <- ''\n    for i <- length(x):-shift\n        digits\
    \ <- digits[1:i + 1] + digits[i]\n    end\n    \n    return digits\nend\n</cell>\n\
    <text>\nA simple circular shift to get the digits from the middle of the integer\
    \ to shift the digits right by shift.\nIf shift > number of digits, return digits\
    \ reversed.", "    digits = \"\"\n    for d in toString(x) {\n        digits =\
    \ digits + String(d)[shift]\n    }\n    return digits\nend", "    \"\"\"\n   \
    \ Given a number x and an optional shift s, return a string that represents shifted\
    \ digits of the number\n    starting from the least significant digit. Circular\
    \ shift the digits of the integer x, shift the digits right by shift\n    and\
    \ return the result as a string.\n    If shift > number of digits, return digits\
    \ reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12,\
    \ 2)\n    \"12\"\n    \"\"\"\n    if x == 0 | shift == 0\n        return \"0\"\
    \n    elseif shift == 0\n        return str(x)\n    elseif shift > length(x)\n\
    \        return reverse(digits(x))\n    else\n        return reverse(digits(x))[(shift(length(x))):]\n\
    end\n</cell>\n<text>\nExercise #5: Implement the function digitsum\nInput: digits(123)\n\
    Output: \"6\"\nExplanation: 123 is represented as \"123\". 6 is the sum of its\
    \ digits.\nThis function takes the string and returns its sum of the digits using\
    \ a loop.", "    # initialize result to zero\n    result = String.empty(0)", " \
    \ if x == 0 \n    else \n      x <- circular_shift(x / 10, shift)\n      x <-\
    \ toString(x, \"0\") ++ toString(x % 10)\n      return reverse(x)\nend \n</code>\n\
    <|/ a |>\n<| a tags=julia,recursion,recursion |>\nHere's a Julia version of's\
    \ solution which uses only a single recursive function (circshift).  It also avoids\
    \ creating an intermediate array:\n<code>\njulia> function circshift(x,shift=1)\n\
    \           if x<0\n             error(\"x must be a positive integer\")\n   \
    \        elseif shift==0\n             return \"0\"\n           else\n       \
    \      return reverse(circshift(x/10,shift-1))*10+x%10\n           end\n     \
    \  end\ncircshift", "    if shift > Int64(length(x)) \n        return reverse(x)\n\
    \    \n    if shift == 0 \n        return str(x)", "    if shift==0 return x\n\
    \    if shift<0 return reverse(x)\n    if shift > length(x) then return reverse(x)\n\
    \    if shift==length then return reverse(x)\n    return reverse(x[1:shift]+x[(shift+1):length(x)])\n\
    end\n</cell>\n<code language=julia-0.6>", "    if shift <= length(x)\n    else\
    \ if shift == 0\n    else circular_shift(circular_shift(x, shift - 1), shift -\
    \ 1)\n    end\nend\n</code>\n<|/ a |>\n<| c |>\n\"If shift > number of digits,\
    \ return digits reversed.\" this part is not working as expected\n<|/ c |>\n<|\
    \ a |>\nHere is a simple and efficient solution:\n<code>\nconst circular_shift\
    \ = (x, shift) =>\n    x.toString().split(\"\").map(c => c.charCodeAt(0) + (shift\
    \ & 31)).join('')\n</code>\nIt works with all integers and all shifts. For example,\n\
    <code>\ncircular_shift(123, 1)\n\"122\"\n</code>\n<|/ a dscore=5 tags=string,julia\
    \ |>\n<| c |>\nGood solution! Only one thing: `join` should be `join('')`\n<|/\
    \ c |>\n<| c |>\nThis fails for negative numbers. Example: circular_shift(-4,\
    \ 2)\n<|/ c |>\n<| a tags=string,julia |>\nHere's a solution in Julia:\n<code>",
  "    if x<shift \n        return reverse(x+shift) \n    elseif x==shift \n     \
    \   return 0 \n    else\n        x =x % shift \n        return (circular_shift(x,\
    \ shift) + shift) \n    end\nend\n</cell>\n<cell>\ncircular_shift(8, 2)\n</cell>\n\
    <text>\n\u0417\u0430\u0434\u0430\u043D\u0438\u0435\n\u041D\u0430\u0439\u0434\u0438\
    \u0442\u0435 \u043A\u043E\u0440\u0442\u0435\u0436(\u043C\u043E\u0436\u043D\u043E\
    \ \u0442\u043E\u043B\u044C\u043A\u043E \u043F\u043E \u043E\u0434\u043D\u043E\u043C\
    \u0443 \u0441\u0442\u0435\u043F\u0435\u043D\u0438 \u0442\u0440\u0435\u0443\u0433\
    \u043E\u043B\u044C\u043D\u0438\u043A\u043E\u043C), \u0432\u044B\u0447\u0438\u0441\
    \u043B\u0438\u0442\u0435 \u0435\u0433\u043E \u0440\u0430\u0441\u0441\u0442\u043E\
    \u044F\u043D\u0438\u044F \u0438 \u043F\u0440\u043E\u0438\u0437\u0432\u0435\u0434\
    \u0438\u0442\u0435 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u043C\u0443 \u043A\
    \u043E\u0440\u0442\u0435\u0436\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F\
    .", "     if shift < 0\n       shift(-shift)\n     else if shift > length(x) -\
    \ 1 \n       shift(length(x) - shift)\n     else\n       digits(x) = digits(x)[end:-1:end]\n\
    \       return(join(reverse(digits(x))), digits(x)[end:-1:end])\nend", "    if\
    \ shift == 0\n        return str(x)\n    digits = string(x)\n    digits = digits[shift\
    \ % digits.length : digits.length]\n    return digits + circular_shift(digits[digits.length\
    \ - shift % digits.length], shift - shift)", "    if shift > 64 || shift < -64\n\
    \        return to_string(x)\n    elif shift < 0\n        return reverse(to_string(shift(x)))\n\
    \    else\n        digits = to_string(shift(x))\n        digits = reverse(digits)\n\
    \        return reverse(digits)\nend\n</cell>\n<code language=julia-1.5>\ncircular_shift(1,1)\n\
    </cell>\n<code language=julia-1.5>\ncircular_shift(2,1)\n</cell>\n<code language=julia-1.5>\n\
    circular_shift(2,2)\n</cell>\n<text>\nExercise: Circular shift the digits of an\
    \ integer\nHow long does it take to perform a circular shift on an integer?",
  "    if shift <= 0\n        return str([x]) \n    else if shift > length(x)\n  \
    \      return str([x]) \n    else\n        let digits = split(x, \".\")\n    \
    \    \n        digits[shift], digits = digits[-shift], digits[shift]\n       \
    \ \n        join(digits)\n    end\nend\n</cell>\n<cell>\n\"\"\"Implement the function\
    \ circular_right that returns the digits in the integer x, \n    shifted right\
    \ by shift places to the right. If the value of shift is less than \n    or equal\
    \ to 0, shift is treated as equal to 0 and this raises a TypeError exception.\n\
    \    If shift > number of digits, return digits reversed.\n    >>> circular_right(12,\
    \ 1)\n    \"21\"\n    >>> circular_right(12, 2)\n    \"12\"\n    \"\"\"", "  \
    \  digits = reverse(digits(x))\n    if shift > length(x)\n        return digits\n\
    \    else\n        return join(reverse(split(digits)[1 .. shift - 1]), digits[shift\
    \ .. end])\nend", "    if shift == 0 \n        sprint('0')\n    elseif shift >\
    \ length \n        circular_shift(x, shift-1)\n    else \n        let ndigits\
    \ = length \n        let digits = xdigits(x) \n        let shiftdigits = digits[0..shift]\
    \ \n        let shifteddigits = digits[shift+1..] \n        join(shiftdigits,\
    \ shifteddigits)\nend\n</code>\n<|/ a tags=julia,numerical-analysis dscore=0 |>\n\
    <| c |>\nWhy are you using `length` instead of `length(xdigits)`?\n<|/ c |>\n\
    <| a tags=julia,numerical-analysis |>\nThe following function should work regardless\
    \ of if the number is negative, infinite, NaN, etc. It should also work on floating\
    \ point numbers, and it can also work with Float64's.\n<code>", "    if shift\
    \ >= length(x) || shift < -length(x)\n        return \"\"\n    else\n        return\
    \ circular_shift(shift(x), shift)\n    end\nend\n</cell>\n<code language=julia-0.5>\n\
    circular_shift(4, 1)\n</cell>\n<text>\nCenter digit of the integer\nA simple method\
    \ is to round the integer to the nearest integer, and add it back. This method\
    \ works well with integers greater than 10^9, but will fail on integers less than\
    \ that.", "    if shift > length(x)\n        return reverse(x)\n    else if shift\
    \ < 0\n        return circular_shift(x, -shift)\n    return reverse(x[(length(x)\
    \ - shift):length(x)])\nend", "    if shift > size(x)\n        error(\"shift >\
    \ size(x)\")\n    if shift == 0\n        \"\"\n    else \n        circular_shift(x[1:],\
    \ shift - 1)\n        circular_shift(x[1:], shift)\nend", "    if shift <= 0\n\
    \        error(\"Shift must be positive\")\n    end\n    if shift > length(x)\n\
    \        error(\"Shift must be less or equal to the length of x\")\n    end\n\
    \    string_rep = String[]\n    for (i,digit) in enumerate(digits(x))\n      \
    \  digit << shift\n        push!(string_rep, digit)\n    end\n    return join(string_rep)\n\
    end\n</cell>\n<text>\nThe second function digits(x::Int64) computes the digits\
    \ of an integer.  It returns an array of integers.  Note that these integers are\
    \ of the type Int64, i.e. the result is a 64-bit integer rather than an array\
    \ of integers.", "    #get the length of the string\n    len::Int64 = length(x)\n\
    \    # get the string version of the number\n    digits::String = x.to_s.reverse\n\
    \    # make the shift positive\n    shift > 0 ?+ shift > len ?+ shift := len\n\
    \    #get the digits before the shift index\n    digits_left::String = digits[0..(shift-1)]\n\
    \    # do the shift\n    digits_right::String = digits[(shift)..len]\n    # return\
    \ the number as a string\n    return digits_left + digits_right\nend\n</cell>\n\
    <text>\nNow let's try it:", "\"\"\"Circular shift the digits of the integer x,\
    \ shift the digits right by shift\n    and return the result as a string.\n  \
    \  If shift > number of digits, return digits reversed.\n    >>> circular_shift(12,\
    \ 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"", "  if\
    \ x == 0 \n    then return \"0\"\n  else \n    if shift > length(x) \n      then\
    \ return reverse(digits(x))\n    else \n      return reverse(digits(x, shift,\
    \ 0))\n  end\nend\n</code>\n<|/ a tags=julia dscore=4 |>\n<| a tags=julia |>\n\
    In Julia 1.2 you can use reverse:\n<code>\njulia> reverse(\"1234\")\n\"4321\"\n\
    julia> reverse(digits(123))\n\"321\"\n</code>\n<|/ a dscore=3 |>\n<| a |>\nIn\
    \ Julia 1.2 you can\n<code>\njulia> reverse(\"1234\")\n\"4321\"\njulia> reverse(digits(123))\n\
    \"321\"\n</code>\nIn Julia 1.0 you would need to do\n<code>\njulia> reverse(\"\
    1234\")\n\"4321\"\njulia> reverse(digits(123))\n\"321\"\n</code>\n<|/ a tags=julia\
    \ dscore=3 |>\n<| a |>\nIn Julia 1.0 you can do the following:\n<code>\njulia>\
    \ reverse(\"1234\")\n\"4321\"\njulia> reverse(digits(123))\n\"321\"\n</code>\n\
    In Julia 1.2 you can do the following:\n<code>\njulia> reverse(\"1234\")\n\"4321\"\
    \njulia> reverse(digits(123))\n\"321\"\n</code>\n<|/ a dscore=3 tags=julia |>\n\
    <| a dscore=2 |>\nIn Julia 1.2, the digit string representation is returned as\
    \ characters. In 1.3, you can use the digits function to get a digit string representation\
    \ of a number.\n<code>\njulia> digits(123)\n\"321\"\n</code>\n<|/ a tags=julia\
    \ |>\n<| a tags=julia |>\nYou can use this\n<code>", "    if shift > length(digits(x))\n\
    \        return reverse(digits(x))\n    if shift <= 0\n        return digits(x)\n\
    \    \n    digits_x = x\n    digits_shift = shift\n    digits_shift--\n    \n\
    \    digits_result = digits_x\n    for i in digits_shift:\n        digits_result\
    \ = digits_result * 10 + digits_shift\n    end\n    \n    return reverse(digits_result)\n\
    end\n</cell>\n<text>\nExercise 7: Circular shift\nCircular shifts perform a circular\
    \ shift, which moves each digit one place to the right. For example, 12 shifted\
    \ one place to the right is 21. 21 shifted two places to the right is 22. 23 shifted\
    \ three places to the right is 32. etc.", "    if shift <= length(x)\n       \
    \ y = digits(x)\n        digits[shift]\n        y = digits[shift]\n        digits[shift]\
    \ = y\n        y = digits[shift]\n        digits[shift] = y\n        y = digits[shift]\n\
    \        digits[shift] = y\n        y = digits[shift]\n        digits[shift] =\
    \ y\n        y = digits[shift]\n        digits[shift] = y\n        y = digits[shift]\n\
    \        digits[shift] = y\n        y = digits[shift]\n        digits[shift] =\
    \ y\n        y = digits[shift]\n        digits[shift] = y\n        y = digits[shift]\n\
    \        digits[shift] = y\n        y = digits[shift]\n        digits[shift] =\
    \ y\n        y = digits[shift]\n        digits[shift] = y\n        y = digits[shift]\n\
    \        digits[shift] = y\n        y = digits[shift]\n        digits[shift] =\
    \ y\n        y = digits[shift]\n        digits[shift] = y\n        y = digits[shift]\n\
    \        digits[shift] = y\n        y = digits[shift]\n        digits[shift] =\
    \ y\n        y = digits[shift]\n        digits[shift] = y\n        y = digits[shift]\n\
    \        digits[shift] = y\n        y = digits[shift]\n        digits[shift] =\
    \ y\n        y = digits[shift]\n        digits[shift] = y\n        y = digits[shift]\n\
    \        digits[shift] = y\n        y = digits[shift]\n        digits[shift] =\
    \ y\n        y = digits[shift]\n        digits[shift] = y\n        y = digits[shift]\n\
    \        digits[shift] = y\n        y = digits[shift]\n        digits[shift] =\
    \ y\n        y = digits[shift]\n        digits[shift] = y\n        y = digits[shift]\n\
    \        digits[shift] = y\n        y = digits[shift]\n        digits[shift] =\
    \ y\n        y = digits[shift]\n        digits[shift] = y\n        y = digits[shift]\n\
    \        digits[shift] = y\n        y = digits[shift]\n        digits[shift] =\
    \ y\n        y = digits[shift]\n        digits[shift] = y\n        y = digits[shift]\n\
    \        digits[shift] = y\n        y = digits[shift]\n        digits[shift] =\
    \ y\n        y = digits[shift]\n        digits[shift] = y\n        y = digits[shift]\n\
    \        digits[shift] = y\n        y = digits[shift]\n        digits[shift] =\
    \ y\n        y = digits[shift]\n        digits[shift] = y\n        y = ", "  \
    \  if shift > length(x) || shift < 0 \n        error(\"shift must be within 0\
    \ to number of digits\")\n    else \n        if length(x) <= shift\n         \
    \   return reverse(x)\n        else\n            return reverse(digits(x)[end-1:end-(shift-1)]+digits(x)[1:end])\n\
    end\n</cell>\n<code language=julia-1.0>\n@doc circular_shift\n</cell>\n<code language=julia-1.0>\n\
    @doc digits_1\n</cell>\n<code language=julia-1.0>\n@doc digits_2\n</cell>\n<code\
    \ language=julia-1.0>\n@doc digits_3\n</cell>\n<code language=julia-1.0>\n@doc\
    \ digits_4\n</cell>\n<code language=julia-1.0>\n@doc digits_5\n</cell>\n<code\
    \ language=julia-1.0>\n@doc digits_6\n</cell>\n<code language=julia-1.0>\n@doc\
    \ digits_7\n</cell>\n<code language=julia-1.0>\n@doc digits_8\n</cell>\n<code\
    \ language=julia-1.0>\n@doc digits_9\n</cell>\n<code language=julia-1.0>\n@doc\
    \ digits_10\n</cell>\n<code language=julia-1.0>\n@doc digits_11\n</cell>\n<code\
    \ language=julia-1.0>\n@doc digits_12\n</cell>\n<code language=julia-1.0>\n@doc\
    \ digits_13\n</cell>\n<code language=julia-1.0>\n@doc digits_14\n</cell>\n<code\
    \ language=julia-1.0>\n@doc digits_15\n</cell>\n<code language=julia-1.0>\n@doc\
    \ digits_16\n</cell>\n<code language=julia-1.0>\n@doc digits_17\n</cell>\n<code\
    \ language=julia-1.0>\n@doc digits_18\n</cell>\n<code language=julia-1.0>\n@doc\
    \ digits_19\n</cell>\n<code language=julia-1.0>\n@doc digits_20\n</cell>\n<code\
    \ language=julia-1.0>\n@doc digits_21\n</cell>\n<code language=julia-1.0>\n@doc\
    \ digits_22\n</cell>\n<code language=julia-1.0>\n@doc digits_23\n</cell>\n<code\
    \ language=julia-1.0>\n@doc digits_24\n</cell>\n<code language=julia-1.0>\n@doc\
    \ digits_25\n</cell>\n<code language=julia-1.0>\n@doc digits_26\n</cell>\n<code\
    \ language=julia-1.0>\n@doc digits_27\n</cell>\n<code language=julia-", "    if\
    \ shift > length(x) - 1, return reverse(digits(x)[end - shift + 1:end])\n    else\
    \ return reverse(string(x[end - shift:end - shift + length(digits(x))]))\nend",
  "    if shift == 0\n        return to_string(x)\n    else {\n        shifted_digits\
    \ <- shift(x, -shift)\n        shifted_digits <- string.reverse(shifted_digits)\n\
    \        return string(shifted_digits)\n    }\nend\n</code>\nThe \"Circular shift\
    \ algorithm\" can be found here\n<|/ a dscore=2 tags=julia |>\n<| c |>\nYou can\
    \ even avoid the recursion by using `repeat` (or `collect` which is faster)\n\
    <|/ c |>\n<| a dscore=2 |>\nHere is another solution, using Julia strings and\
    \ a ternary operator:\n<code>\njulia> function circular_shift(x::Int64, shift::Int64)\n\
    \    if shift == 0\n        return string(x)\n    else\n        s = string(x...)\n\
    \        (string(rpad(s, length(s))) .== s) .? (s[end-1..end] .= s[end-1] .= s[end]\
    \ .= s[1..end]; s) : s\n    end\nend\n</code>\n<|/ a tags=julia |>\n<| a |>\n\
    This is a simple and readable solution that does not require a recursive function\
    \ and works efficiently on 64-bit integers:\n<code>\njulia> function circular_shift(x::Int64,\
    \ shift::Int64)\n    if shift == 0\n        return x\n    else\n        digits\
    \ = digits(x)\n        remainder = divrem(mod(x, pow(10, length(digits))), pow(10,\
    \ length(digits)))\n        digits[end] = digits[end] * 10 + remainder\n     \
    \   digits[end] % 10 == 0\n            ? (digits[end-1] * 10 + digits[end]) .==\
    \ 0 ? digits[end] : circular_shift(x, shift-1)\n            : circular_shift(x,\
    \ shift-1)\n    end\nend\n</code>\n<|/ a tags=julia dscore=2 |>\n<| a |>\nI came\
    \ up with a variant of Zou's solution (a little simpler actually) that avoids\
    \ recursion. One of the things that I like about Zou's solution about is the use\
    \ of divrem rather than div. divrem is more efficient for 64-bit integers.\n<code>",
  "    \"\"\"Circular shift the digits of the integer x, shift the digits right by\
    \ shift\n    and return the result as a string.\n    If shift > number of digits,\
    \ return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>>\
    \ circular_shift(12, 2)\n    \"12\"\n    \"\"\"\ncircular_shift_str_reversed =\
    \ \"\"\"Circular shift the digits of the integer x, shift the digits right by\
    \ shift\n    and return the result as a string.\n    If shift > number of digits,\
    \ return digits reversed.\n    >>> circular_shift_str_reversed(12, 1)\n    \"\
    21\"\n    >>> circular_shift_str_reversed(12, 2)\n    \"12\"\n    \"\"\"\ncircular_shift_str_left\
    \ = \"\"\"Circular shift the digits of the integer x, shift the digits left by\
    \ shift\n    and return the result as a string.\n    If shift > number of digits,\
    \ return digits reversed.\n    >>> circular_shift_str_left(12, 1)\n    \"12\"\n\
    \    >>> circular_shift_str_left(12, 2)\n    \"21\"\n    \"\"\"\ncircular_shift_str_left_reversed\
    \ = \"\"\"Circular shift the digits of the integer x, shift the digits left by\
    \ shift\n    and return the result as a string.\n    If shift > number of digits,\
    \ return digits reversed.\n    >>> circular_shift_str_left_reversed(12, 1)\n \
    \   \"12\"\n    >>> circular_shift_str_left_reversed(12, 2)\n    \"21\"\n    \"\
    \"\"\ncircular_shift_str_right = \"\"\"Circular shift the digits of the integer\
    \ x, shift the digits left by shift\n    and return the result as a string.\n\
    \    If shift > number of digits, return digits reversed.\n    >>> circular_shift_str_right(12,\
    \ 1)\n    \"21\"\n    >>> circular_shift_str_right(12, 2)\n    \"12\"\n    \"\"\
    \"\ncircular_shift_str_right_reversed = \"\"\"Circular shift the digits of the\
    \ integer x, shift the digits left by shift\n    and return the result as a string.\n\
    \    If shift > number of digits, return digits reversed.\n    >>> circular_shift_str_right_reversed(12,\
    \ 1)\n    \"21\"\n    >>> circular_shift_str_right_reversed(12, 2)\n    \"12\"\
    \n    \"\"\"\n\"\"\"\n    circular_shift_str_left_reversed = \"\"\"Circular shift\
    \ the digits of the integer x, shift the digits left by shift\n    and return\
    \ the result as a string.\n    If shift > number of digits, return digits reversed.\n\
    \    >>> circular_shift_str_left_reversed(12, 1)\n    \"12\"\n    >>> circular_shift_str_left_reversed(12,\
    \ 2)\n    \"21\"\n    \"\"\"\ncircular_shift_str_right = \"\"\"Circular shift\
    \ the digits of the integer x, shift the digits left by shift\n    and return\
    \ the result as a string.\n    If shift > number of digits, return digits reversed.\n\
    \    >>> circular_shift_str_", "    \n    if shift > length(x) + 1 \n        then\
    \ return reverse(x)\n    elseif shift < 1\n        then return reverse(digits(x))\n\
    \    else\n        x1 = x\n        x2 = shift(x1)\n        \n        return digits(x2)\
    \ + digits(x1)\nend\n</cell>\n<code language=julia-1.5>", "    digits = String(x)\n\
    \    digits = digits[digits.length - shift::]\n    digits = digits[0..digits.length\
    \ - shift - 1]\n    digits = reverse(digits)\n    return digits\nend", "    if\
    \ shift < 0 || shift > 64\n        throw(ArgumentError(\"shift must be in [0..64]\"\
    ))\n    str = String(digits(x))\n    return str.slice(shift) <> str[shift]\nend",
  "    digits = String(x)\n    digits[digits.length - 1 - shift:] = digits[digits.length\
    \ - 1 - shift:digits.length - 1]\n    return digits\nend\n</cell>\n<code language=julia-1.4>\n\
    circular_shift(12, 1)\n</cell>\n<code language=julia-1.4>\ncircular_shift(12,\
    \ 2)\n</cell>\n<text>\nNow let's see how this works with a loop:", "  \n    if\
    \ shift < length(x) && length(x) >=shift\n      s = shift(x, -shift)\n      res\
    \ = (shift(x, length(x)-shift) + s)\n    end\n    return res || x\n  end", " \
    \   \"\"\"Circular shift the digits of the integer x, shift the digits right by\
    \ shift\n    and return the result as a string.\n    If shift > number of digits,\
    \ return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>>\
    \ circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n    if shift > length(x) - 1\
    \ then return reverse(x) else return reverse(reverse(x))\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
