name: HumanEval_41_car_race_collision
language: jl
prompt: "\"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n\
  \    n cars are driving left to right;  simultaneously, a different set of n cars\n\
  \    are driving right to left.   The two sets of cars start out being very far\
  \ from\n    each other.  All cars move in the same speed.  Two cars are said to\
  \ collide\n    when a car that's moving left to right hits a car that's moving right\
  \ to left.\n    However, the cars are infinitely sturdy and strong; as a result,\
  \ they continue moving\n    in their trajectory as if they did not collide.\n\n\
  \    This function outputs the number of such collisions.\n    \"\"\"\nfunction\
  \ car_race_collision(n::Int64)::Int64 \n"
tests: "using Test\n\n@testset begin\n\ncandidate = car_race_collision;\n\t@test(candidate(2)\
  \ == 4)\n\t@test(candidate(3) == 9)\n\t@test(candidate(4) == 16)\n\t@test(candidate(8)\
  \ == 64)\n\t@test(candidate(10) == 100)\nend\n"
completions: ["    \"\"\"\"Return the total number of race collisions.\"\"\"\n   \
    \ # Your code here", "    \"\"\"\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.", "    l = zeros(Int64, n)\n    for i = 1:n\n  \
    \      l[i] = i\n    end\n    race_count = 0\n    while l != l\n        race_count\
    \ = race_count + 1\n        for i = 1:n\n            j = i+1\n            while\
    \ j < n\n                if car_race_collision_check(l[i], l[j]) == true\n   \
    \                 race_count = race_count + 1\n                    l[i] = l[i]\
    \ + car_speed\n                    l[j] = l[j] - car_speed\n                 \
    \   break\n                end\n                j = j + 1\n            end\n \
    \       end\n    end\n    return race_count\nend\n\"\"\"\n    We use our collision\
    \ function when we're going to count how many times a car\n    collides with another\
    \ car.  To count the number of collisions, we first find the\n    minimum distance\
    \ between the two cars, and then start counting collisions until we\n    have\
    \ gone through the entire set of n cars without a collision.  (Note that if\n\
    \    the cars collide, the minimum distance is still the distance between both\
    \ cars.)\n    \"\"\"", "\tcdef int i\n\tcdef int j\n\tcdef int collisions = 0\n\
    \tcdef int m\n\tcdef int colliding = 0\n\tcdef int collided = False\n\tcdef int\
    \ colliding_pairs[]\n\tcdef int max_i\n\tcdef int max_j", "    \"\"\"\"\n    Imagine\
    \ a road that's a perfectly straight infinitely long line.\n    n cars are driving\
    \ left to right;  simultaneously, a different set of n cars\n    are driving right\
    \ to left.   The two sets of cars start out being very far from\n    each other.\
    \  All cars move in the same speed.  Two cars are said to collide\n    when a\
    \ car that's moving left to right hits a car that's moving right to left.\n  \
    \  However, the cars are infinitely sturdy and strong; as a result, they continue\
    \ moving\n    in their trajectory as if they did not collide.", "    \n    if\
    \ n<=0 \n        return 0 \n    \n    if n==1 \n        return 1 \n    \n    collision_count\
    \ = 0 \n    \n    collision_count += car_race_collision(n - 1) \n    collision_count\
    \ += car_race_collision(n - 1) \n    \n    return collision_count\nend", "\"\"\
    \"\n    Imagine a road that's a perfectly straight infinitely long line.\n   \
    \ n cars are driving left to right;  simultaneously, a different set of n cars\n\
    \    are driving right to left.   The two sets of cars start out being very far\
    \ from\n    each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n    when a car that's moving left to right hits a car that's moving\
    \ right to left.\n    However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n    in their trajectory as if they did not collide.",
  "    cars  = [Car(Vector(-10, 0), Vector(10, 0), i) for i in 1:n]\n    collide =\
    \ [Car(Vector(-10, 0), Vector(10, 0), i) for i in 1:n]\n    collide[rand(1:n)]\
    \ = cars[rand(1:n)]\n    collide", "\"\"\"\n    function car_race_collision(n::Int64)::Int64",
  "  \"\"\" \n  car_race_collision(n::Int64)::Int64", "  \n  # Input and Output\n\
    \  car_width = 0.01\n  car_length = 0.01\n  car_distance = 0.01", "    # O(n)\n\
    \    for i in 1:n\n        for j in 1:n\n            if (i != j) && abs(i+j) ==\
    \ n\n                c = car_race_collide(i+j, i+j+n)\n                return\
    \ c\n        end\n    end\n    return 0\nend\n</cell>\n<code language=julia-1.6>\n\
    println(car_race_collision(100))\n</cell>\n<code language=julia-1.6>", "    collisions=0;\n\
    \    for car_i in 1:n\n        for car_j in 1:n\n            if abs(car_j-car_i)\
    \ > 1\n                collisions+=1\n            end \n        end \n    end\
    \ \n    return collisions\nend \n</cell>\n<code language=julia-1.5>\n@time car_race_collision(10)\n\
    </cell>\n<text>\nThe next cell takes a little longer to run.  This is because\
    \ of the function call overhead.", "    \"\"\"\n    Imagine a road that's a perfectly\
    \ straight infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.", "    left_road_length = 50.0  \n    right_road_length\
    \ = 50.0 \n    left_lanes = n / 2\n    right_lanes = n - left_lanes\n    \n  \
    \  intersection_distance = 0.0\n    \n    for lane in 1:left_lanes \n        for\
    \ lane in 1:right_lanes \n            intersection_distance = sqrt((road_lanes_positions[lane,1]\
    \ - road_lanes_positions[lane,2])^2 +\n                    (road_lanes_positions[lane,2]\
    \ - road_lanes_positions[lane,3])^2)\n            if intersection_distance <=\
    \ left_road_length + right_road_length \n                road_lanes_positions[lane,4]\
    \ = road_lanes_positions[lane,4] - intersection_distance/10\n            else\n\
    \                road_lanes_positions[lane,4] = road_lanes_positions[lane,4] +\
    \ intersection_distance/10\n            end\n        end\n    end\n    \n    for\
    \ lane in 1:left_lanes \n        for lane in 1:right_lanes \n            collision\
    \ = road_lanes_positions[lane,4] - road_lanes_positions[lane,3]\n            if\
    \ collision > 0.0 \n                road_lanes_positions[lane,4] = 0.0 \n    \
    \        end\n        end\n    end\n    \n    for lane in 1:left_lanes \n    \
    \    for lane in 1:right_lanes \n            collision = road_lanes_positions[lane,4]\
    \ - road_lanes_positions[lane,2]\n            if collision > 0.0 \n          \
    \      road_lanes_positions[lane,4] = 0.0 \n            end\n        end\n   \
    \ end\n    \n    for lane in 1:left_lanes \n        for lane in 1:right_lanes\
    \ \n            collision = road_lanes_positions[lane,4] - road_lanes_positions[lane,1]\n\
    \            if collision > 0.0 \n                road_lanes_positions[lane,4]\
    \ = 0.0 \n            end\n        end\n    end\n    \n    for lane in 1:left_lanes\
    \ \n        for lane in 1:right_lanes \n            collision = road_lanes_positions[lane,4]\
    \ - road_lanes_positions[lane,0]\n            if collision > 0.0 \n          \
    \      road_lanes_positions[lane,4] = 0.0 \n            end\n        end\n   \
    \ end\n    \n    intersection_distance = 0.0\n    \n    for lane in 1:left_lanes\
    \ \n        for lane in 1:right_lanes \n            intersection_distance = sqrt((road_lanes_positions[lane,1]\
    \ - road_lanes_positions[lane,2])^2 +\n                    (road_lane", "    if\
    \ n > 0 \n        for j in i+1:n\n            colliding = get_car_colliding(i,j)\n\
    \            if colliding == 1 \n                return n", "    collide = 0\n\
    \    for i = 1:n\n        if car_collide(i - 1) == car_collide(i)\n          \
    \  collide = collide + 1\n        end\n    end\n    return collide\nend\n</cell>\n\
    <code language=julia-1.4>\n@time car_race_collision(10000);\n</cell>\n<code language=julia-1.4>",
  "    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n\
    \    n cars are driving left to right;  simultaneously, a different set of n cars\n\
    \    are driving right to left.   The two sets of cars start out being very far\
    \ from\n    each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n    when a car that's moving left to right hits a car that's moving\
    \ right to left.\n    However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n    in their trajectory as if they did not collide.",
  "    collisions::Int64 = 0\n    for c in 1:n\n        for r in 1:n\n           \
    \ if ((c == r) xor ((c+r) <= n and (c+r) >= 1))\n                collisions +=\
    \ 1\n    \n    return collisions\nend", "\"\"\"\n    Imagine a road that's a perfectly\
    \ straight infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.", "    \"\"\"Simulates cars racing through each\
    \ other in a perfect straight line.\n    \n    Returns the number of cars colliding.\n\
    \    \"\"\"\n</cell>\n<cell>\n@njit\ndef car_race_collision_1(n::Int64)::Int64\
    \ \n    \"\"\"Simulates cars racing through each other in a perfect straight line.\n\
    \    \n    Returns the number of cars colliding.\n    \"\"\"\n    return n ",
  "    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n\
    \    n cars are driving left to right;  simultaneously, a different set of n cars\n\
    \    are driving right to left.   The two sets of cars start out being very far\
    \ from\n    each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n    when a car that's moving left to right hits a car that's moving\
    \ right to left.\n    However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n    in their trajectory as if they did not collide.",
  "    n=n+1 \n    return car_collision(n)*car_collision(n-1) \nend\n</cell>\n<code\
    \ language=julia-1.0>\n#P(simultaneous collisions)", "  c::Int64 = 0\n  for d\
    \ in 1:n\n    if cars_colliding(d)\n      c += 1\n  end\n  return c\nend\n</cell>\n\
    <text>\nAnd we see that this function works:", "    # O(n), but no worse than\
    \ quadratic time in most practical cases (when n is large)\n    collisions = 0\n\
    \    \n    # for each car, check which other car is closest to it\n    for car\
    \ in 1:n\n        other_car = 0\n        \n        # for each car in the other\
    \ lane, check which other car is closest to it\n        for other_car in 1:n\n\
    \            \n            # find the distance between the cars\n            dist\
    \ = hypot(car.x - other_car.x, car.y - other_car.y)\n            \n          \
    \  # if this is less that the smallest distance seen so far, keep it\n       \
    \     if dist < min_dist\n                other_car = min_dist\n            #\
    \ otherwise, update it\n            else \n                min_dist = dist\n \
    \       \n        # if there is a collison, increment the counter\n        if\
    \ other_car != 0\n            collisions += 1\n        end\n    end", "    # your\
    \ code here\nend\n</cell>\n<text>\nQuestion 9\nThe code cell below demonstrates\
    \ how to use the car_race_collision function you've just defined.  You will need\
    \ to specify the value for n.", "    if n == 0 return 0\n    else if n < 2 return\
    \ 0\n    elseif n == 1 return 1\n    else \n        collision::Int64 = 1\n   \
    \     for i in 1:n-1\n            for j in i+1:n\n                if car_race_collision(n-2)+car_race_collision(n-1)+car_race_collision(j-1)\
    \ + car_race_collision(j-2) == 4\n                    collision::Int64 = collision\
    \ + car_race_collision(j-1) + car_race_collision(j-2) + car_race_collision(n-1)\
    \ + car_race_collision(n-2)\n                end\n            end\n        end\n\
    \        collision::Int64 = collision + car_race_collision(n-1) + car_race_collision(n-2)\n\
    \    end\nend\nprintln(car_race_collision(10))\n</cell>\n<text>\nExercise 3",
  "    # Complete the code for this function\n    return ", "    # Initialize a counter.\n\
    \    car_race_counter = 1\n    for i in 1:n\n        # Keep track of all cars\
    \ whose trajectories collide.\n        car_collide = false(Int64, 10)\n      \
    \  for j in 1:n\n            # Ignore cars whose trajectories do not intersect.\n\
    \            if i != j\n                if sqrt((car_x_position(i,j) - car_x_position(i,n))**2\
    \ +\n                         (car_y_position(i,j) - car_y_position(i,n))**2)\
    \ < 10\n                    car_collide[car_race_counter] = true\n           \
    \ end\n        end\n        car_race_counter += sum(car_collide)\n    end\n  \
    \  car_race_counter\nend\n</cell>\n<code language=julia-1.2>", "    car_race_collision\
    \ = \n        count_car_collisions(n) \n        for i \u2208 1:n\n           \
    \ car_race_collision + \n                count_car_collisions(n - i)\n    return\
    \ car_race_collision\nend function car_race_collision", "    s = Int64(0)\n  \
    \  for i = 1 to n\n        for j = i+1 to n\n            if (cars_collide(vehicles[i],vehicles[j]))\n\
    \                s += Int64(1)\n            end\n        end\n    end\n    return\
    \ s\nend\n</cell>\n<code language=julia-1.0>\ncar_race_collision(100)\n</cell>\n\
    <text>\nThis should output the number of cars that collided in the 100-vehicle\
    \ race.", "    collisions = 0\n    for i = 1:n\n        if abs(car_move_left_to_right(i)\
    \ - car_move_right_to_left(i)) < max_car_distance\n            collisions += 1\n\
    \        end\n    end\n    return collisions\nend\n</cell>\n<code language=julia-0.6>",
  "    local i::Int64 = 1\n    local j::Int64 = 1\n    local total::Int64 = 0\n  \
    \  \n    while i <= n do\n        while j <= n do\n            local coll = car_race_collision_helper(i,\
    \ j)\n            if coll == 1 then\n                total = total + 1\n     \
    \       end\n            j = j + 1\n        end\n        i = i + 1\n    end\n\
    \    return total\nend\n\"\"\"\n</cell>\n<code language=julia-1.2>", '    # Write
    your code here.', "    collide::Int64 = 0\n    for i in 1..n\n        for j in\
    \ (i-1)..n\n            dist = sqrt((car_pos(i,1)-car_pos(j,1))^2+(car_pos(i,2)-car_pos(j,2))^2)\n\
    \            if dist<1\n                collide = collide+1\n    return collide",
  "    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n\
    \    n cars are driving left to right;  simultaneously, a different set of n cars\n\
    \    are driving right to left.   The two sets of cars start out being very far\
    \ from\n    each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n    when a car that's moving left to right hits a car that's moving\
    \ right to left.\n    However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n    in their trajectory as if they did not collide.",
  "    colliding = 0\n    for i in 1:n \n        for j in 1:n \n            if i !=\
    \ j \n                if (distance(i::Int64, j::Int64) <= car_speed_limit) \n\
    \                    && (collision(i::Int64, j::Int64)) \n                   \
    \ && (car_movement_limit[j] == car_movement_limit[i]) \n                    &&\
    \ (car_movement_limit[i] == 0) \n                    && (car_speed_limit/car_movement_limit[i]*car_movement_limit[j])\
    \ \n                    <= car_speed_limit\n                    && !colliding\n\
    \                then\n                    colliding += 1\n                end\n\
    \            end\n        end\n    end\n    return colliding\nend", "    \"\"\"\
    \n    Imagine a road that's a perfectly straight infinitely long line.\n    n\
    \ cars are driving left to right;  simultaneously, a different set of n cars\n\
    \    are driving right to left.   The two sets of cars start out being very far\
    \ from\n    each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n    when a car that's moving left to right hits a car that's moving\
    \ right to left.\n    However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n    in their trajectory as if they did not collide.",
  "    collide_left = true\n    collide_right = true\n    for i in 1:n\n        collision_left\
    \ = false\n        collision_right = false\n        \n        #for both cars going\
    \ left to right\n        for j in 1:i\n            if collide_left == true &&\
    \ collide_right == false\n            collide_left = false\n            if car_race_collision(j)\
    \ == true && car_race_collision(i) == false\n            collide_right = false\n\
    \            collide_left = true\n            if collide_left == false && collide_right\
    \ == true\n            collide_left = false\n            if car_race_collision(j)\
    \ == true && car_race_collision(i) == false\n            collide_right = false\n\
    \            end\n        end\n    end\n    return collide_left == true && collide_right\
    \ == true\nend\n</cell>\n<text>\nLet's test the car_race_collision function:",
  "    sum_x = 0\n    sum_y = 0\n    sum_x_right = 0\n    sum_y_right = 0\n    sum_x_left\
    \ = 0\n    sum_y_left = 0\n    for j in 1:n\n        sum_x += car[j].x\n     \
    \   sum_y += car[j].y\n        sum_x_right += car[j].x_right\n        sum_y_right\
    \ += car[j].y_right\n        sum_x_left += car[j].x_left\n        sum_y_left +=\
    \ car[j].y_left\n    end\n    if sum_x_right + sum_x_left < sum_x and sum_y_right\
    \ + sum_y_left < sum_y \n        then return 1\n        else return 0\n    end\n\
    end\n</cell>\n<code language=julia-1.5>", "    if n == 0\n        return 0\n \
    \   else\n        return car_race_collision(n-1)\n    end\nend", "    if n ==\
    \ 1 \n        return 0 \n    n -= 1\n    collisions = 0\n    for i::Int64 in 1\
    \ .. n \n        if car_race(i)==car_race(i+1) \n            collisions += 1 \n\
    \        else \n            break \n    return collisions \nend \n@benchmarkable\
    \ function car_race_collision(n::Int64)::Int64 \n    if n == 1 \n        return\
    \ 0 \n    n -= 1\n    collisions = 0\n    for i::Int64 in 1 .. n \n        if\
    \ car_race(i)==car_race(i+1) \n            collisions += 1 \n        else \n \
    \           break \n    return collisions \nend \n</cell>\n<code language=julia-1.6>\n\
    # car_race_collision(10)\n</cell>\n<text>\ncar_race(i)\nWe want to define a function\
    \ car_race(i) that outputs the id of the car whose race is i.", "    # your code\
    \ here\n    pass\n</code>\nThe only thing you need to do here is to make sure\
    \ your two functions have the same input and have the same output.  You can do\
    \ this by writing both your functions as functions that take and return Int64\
    \ (64-bit integers).  When you do this, your two functions will both be of the\
    \ type car_race_collision(n::Int64) -> Int64.  This means that the return type\
    \ and the input type are the same, and that the function name is the same (which\
    \ means both functions can be called with the same input).\n<|/ a dscore=1 tags=julia\
    \ |>\n<| c |>\nI'm new to Julia so forgive me if I ask some questions but I have\
    \ no idea how to code this in Julia. How do I write one function that takes one\
    \ argument and outputs two functions? Would it be easier to do it in Python?\n\
    <|/ c |>\n<| c |>\nI've updated my answer to be more in line with your questions.\
    \  Note that you can also do multiple return values from a single function (which\
    \ is useful in some cases) by doing `return (f1, f2)`.  In this case, `f1` and\
    \ `f2` have the same type.\n<|/ c |>\n<| c |>\nThis was really helpful. Thank\
    \ you.\n<|/ c |>\n<| a dscore=0 tags=julia |>\nThe answer by Dan Garcia is great.\
    \  Here's a version where you can have multiple return statements, and the function\
    \ will accept a vector instead of a scalar n.\n<code>", "\"\"\"\n    Imagine a\
    \ road that's a perfectly straight infinitely long line.\n    n cars are driving\
    \ left to right;  simultaneously, a different set of n cars\n    are driving right\
    \ to left.   The two sets of cars start out being very far from\n    each other.\
    \  All cars move in the same speed.  Two cars are said to collide\n    when a\
    \ car that's moving left to right hits a car that's moving right to left.\n  \
    \  However, the cars are infinitely sturdy and strong; as a result, they continue\
    \ moving\n    in their trajectory as if they did not collide.", "    n <- 64\n\
    \    n <- n*(-1) + 6*n\n    n <- n + 2*n*((n^2 - 4)/6 + n/2)^2\n    n <- n*(n\
    \ + 1) + 2*n*(n^2 - 1)\n    return n", "    collision_count = 0\n    for i = 1:n\n\
    \        if (car(x = i, y = 1) == car(x = n - 1 - i, y = 1)) || (car(x = i, y\
    \ = 2) == car(x = n - 1 - i, y = 2)) \n            collision_count += 1\n    \
    \    end\n    end\n    collision_count\nend\n</cell>\n<code language=julia-0.4>\n\
    #=\nThe function car_race_collision takes as input a number n (number of cars)\
    \ and\nreturns how many collisions there are in that number of cars.", "  # Your\
    \ code goes here\n    return 0\nend\n</cell>\n<code language=julia-1.0>\nusing\
    \ Random", "    car_race_collision_sum = 0\n    collision_counter = 0\n    \n\
    \    # loop over all possible directions\n    for direction in Enum{Direction}\n\
    \        collision_counter += is_collision(direction, n, car_race_array)\n   \
    \ end\n    \n    return collision_counter\nend", "    race_cars = @time collision_avoidance_solutions(n)\
    \ \n    @time race_car_collisions(race_cars) \n    return length(race_cars)",
  "    cars = Array{Int64}(undef,n)\n    for i=1:n\n        cars[i] = i\n    end\n\
    \    for i=1:n\n        for j=1:n\n            if cars[i]==cars[j]\n         \
    \       cars[i] = 2\n                cars[j] = 1\n            end\n        end\n\
    \    end\n    return n-c[2]\nend", "    if n > 0\n        collisions = 0\n   \
    \     for _ in 1:n-1\n            collisions += car_race_collision(n-1)\n    \
    \    end\n    end\n    \n    return collisions\nend\n</cell>\n<code language=julia-1.5>",
  "    collision_count = 0\n    \n    for i=1:n\n        collision_count = collision_count\
    \ + car_race_collision(i)\n    \n    return collision_count\nend\n</cell>\n<code\
    \ language=julia-1.0>", "  collisions = 0\n  for i in 1:n\n    for j in i+1:n\n\
    \      if(straight_line_collision(i, j)==0)\n        collisions += 1\n       \
    \ break\n    end\n  end\n  collisions\nend", "    #Write your code here\n    return\
    \ 0\nend\n</code>\n<|/ q tags=julia |>\n<| c |>\nDo you know how to use a profiler\
    \ to see what portions of your code are slow? If you don't then I suggest looking\
    \ at a profiler first. Julia has an excellent [profiler](http://julialang.org/blog/2013/12/13/profiling-julia-code-with-the-profiler/).\
    \ There are many tools out there to help with code profiling.\n<|/ c |>\n<| c\
    \ |>\nA quick search reveals [this answer](http://stackoverflow.com/questions/41637693/how-to-find-the-function-that-is-consuming-more-memory-in-julia/41638595#41638595)\
    \ to a related question. It may be of use.\n<|/ c |>\n<| c |>\nThanks. I will\
    \ give it a try.\n<|/ c |>\n<| a tags=julia dscore=2 |>\nIt looks to me like the\
    \ reason you are having trouble is because you are trying to compare a vector\
    \ (of numbers) to an integer (n) without explicitly converting the vector to an\
    \ integer. \nFor example:\n<code>\njulia> a = [1,2,3];\njulia> a == 3\ntrue\n\
    </code>\nBut if the numbers are floating point values then it won't match:\n<code>\n\
    julia> a = [1.0,2.0,3.0];\njulia> a == 3\nfalse\n</code>\nIt looks like you are\
    \ doing the same thing with your loop counter. I am not sure how big your problem\
    \ is, but you might want to do something like this:\n<code>", "    # your code\
    \ here\n    collisions = 0\n    for a in 1:n\n        for b in 1:n\n         \
    \   if ((a > b) xor abs(a-b) == (n-1)) then \n                collisions = collisions\
    \ + 1\n    return(collisions)\nend \n</cell>\n<text>\nSolution\nRun the cell below\
    \ to test your solution.", "    \"\"\"\n    Imagine a road that's a perfectly\
    \ straight infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.", "    collisions = 0\n    for _i in 1:n\n     \
    \   for _j in 1:n\n            # find distance between cars\n            dx =\
    \ abs(xs[i] - xs[j])\n            dy = abs(ys[i] - ys[j])\n            # find\
    \ distances to each other car\n            d_i = sqrt((dx^2)+(dy^2))\n       \
    \     d_j = sqrt((dx^2)+(dy^2))\n            # find angles\n            angle_i\
    \ = atan2(dy, dx)\n            angle_j = atan2(dy, dx)\n            # find which\
    \ direction they need to go in order to hit the other car\n            if angle_i\
    \ < angle_j\n                direction = +1\n            else\n              \
    \  direction = -1\n            # check which direction has the shortest distance\
    \ to both cars\n            if d_i < d_j\n                distance_left = d_i\n\
    \                distance_right = d_j\n            else\n                distance_left\
    \ = d_j\n                distance_right = d_i\n            # check which of the\
    \ two cars is closer to the center of the line and where in the line they are\n\
    \            if dx < dy\n                if distance_left < distance_right\n \
    \                   if direction > 0\n                        collisions += 1\n\
    \                else\n                    if direction < 0\n                \
    \        collisions += 1\n            else\n                if distance_left >\
    \ distance_right\n                    if direction > 0\n                     \
    \   collisions += 1\n                else\n                    if direction <\
    \ 0\n                        collisions += 1\n    return collisions\nend\n</cell>\n\
    <code language=julia-1.0>", "    \"\"\"Car race collisions\"\"\"\n    if n < 2\
    \ \n        return 0 \n    \n    left = 2 * n - 1 \n    right = 2 * n - 1 \n \
    \   \n    for i = 1:n \n        if i == n - 1 \n            for j = 1:n \n   \
    \             if j == n - 1 \n                    continue \n                \n\
    \                right_to_left = i * n ^ j\n                \n               \
    \ if left_to_right == right_to_left \n                    continue \n        \
    \        \n                left_to_left = i * n  ^ j\n                \n     \
    \           if left_to_right == left_to_left \n                    continue \n\
    \                \n                collision = i  ^ j\n                \n    \
    \            let collide_count = left_to_right - right_to_left \n            \
    \    \n                let collision_count = collision_count + collide_count\n\
    \                \n                return collision_count\n        \n        else\
    \ \n            for j = i + 1:n \n                if j == n - 1 \n           \
    \         continue \n                \n                left_to_right = i * n \
    \ ^ j\n                \n                if left_to_right == left_to_left \n \
    \                   continue \n                \n                collision = i\
    \  ^ j\n                \n                let collide_count = right_to_left -\
    \ left_to_left\n                \n                let collision_count = collision_count\
    \ + collide_count\n                \n                return collision_count\n\
    \        \n    else \n        for j = i + 1:n \n            if j == n - 1 \n \
    \               continue \n            \n            right_to_left = i * n  ^\
    \ j\n            \n            if right_to_left == left_to_left \n           \
    \     continue \n            \n            collision = i  ^ j\n            \n\
    \            let collide_count = left_to_right - right_to_left\n            \n\
    \            let collision_count = collision_count + collide_count\n         \
    \   \n            return collision_count", '    """Determine if two cars collide
    when they are moving at nearly the same speed.', "    # Input validation \n  \
    \  if n <= 0 \n    then return \"Sorry! n must be a positive integer.\" \n   \
    \ else return n \n    end", "    collided = 0 \n    for j = 1 : n-1\n        for\
    \ i = j+1 : n\n            if car_collision(i,j)\n                collided = 1\
    \ \n                break\n        end\n    end\n    return collided\nend\n</cell>\n\
    <code language=julia-1.0>", "\"\"\"\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.", "    car_race_collision_count = 0\n    for i::Int64\
    \ in 1:n\n        for j::Int64 in i+1:n\n            if i != j && car_race_collision(i,\
    \ j) == true\n                car_race_collision_count += 1\n            end\n\
    \        end\n    end\n    return car_race_collision_count\nend", '    """Simulation
    function for the collision of a car against itself.', "    \n    car_movement_x\
    \ = zeros(Int64,n)\n    car_movement_y = zeros(Int64,n)\n    \n    car_collisions\
    \ = zeros(Int64,n)\n    \n    for j=1:n\n        car_movement_x[j] = 1\n     \
    \   car_movement_y[j] = 1\n    end\n    \n    for i in 1:n\n        for j=1:n\n\
    \            \n            car_collisions[j] = car_collisions[j] + 1 \n      \
    \      \n            if car_collisions[j] > 0 \n                \n           \
    \     if car_movement_x[i] * car_movement_y[j] == -1\n                    car_movement_x[i]\
    \ = -1\n                end\n                \n                if car_movement_x[i]\
    \ * car_movement_y[j] == 1\n                    car_movement_x[i] = 1\n      \
    \          end\n            end\n        end\n    end\n    \n    collides = zeros(Int64,n)\n\
    \    for j=1:n\n        \n        if car_collisions[j] > 0\n            collides[j]\
    \ = car_collisions[j]\n        end\n    end\n    return sum(collides)\nend\n</cell>\n\
    <code language=julia-1.5>\n# Test your code", "    if n==0\n        return 0 \n\
    \    left=rand(1)\n    right=rand(1)\n    if left<0.5\n        return car_race_collision(n\
    \ - 1)\n    else\n        return car_race_collision(n-1)\nend", "    if n==1\n\
    \        return 0\n    if n==2\n        return 1\n    colliding = 0\n    collisions\
    \ = 0\n    # Move left and right independently while colliding at every position\n\
    \    for k in 0:n-1\n        for l in 0:n-1\n            colliding = 1\n     \
    \       collisions = collisions+1\n            for m in 0:n-1\n              \
    \  for n in 0:n-1\n                    if abs(k*n - i*l)==(abs(k*n - i*l)+abs(n*m\
    \ - j*k))\n                        colliding = 0\n                        break\n\
    \                if colliding\n                    break\n            if colliding\n\
    \                break\n    return collisions\nend\n\"\"\"\n## Problem 2", " \
    \   collisions::Int64 = 0\n    for i = 1 to n \n        for j = i + 1 to n \n\
    \            collisions += car_race_collision(j)*car_race_collision(i)*car_race_collision(j)\n\
    \    end\n    collisions\nend", "    \"\"\"\n    Imagine a road that's a perfectly\
    \ straight infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.", "    if (n <= 1)\n        return 1\n    else\n\
    \        return (car_race_collision(n - 1) + (n - 1)^2)\n    end\nend", "    #\
    \ initialize count\n    count = 0\n    # iterate through possible combinations\
    \ of cars\n    for i in 1:n\n        for j in (n+1):1:i\n            for k in\
    \ (i+1):1:j\n                # iterate through possible combinations of directions\n\
    \                for direction in {-1,1}\n                    if direction !=\
    \ 0\n                    count += count(i::Int64,j::Int64,k::Int64,direction)\n\
    \        end\n    end\n    return count", "    collisions = 0\n    for i = 1 to\
    \ n\n        for j = i+1 to n\n            collisions += car_race_collisions(i,\
    \ j) \n    end\n    return collisions", "\"\"\"\n    Imagine a road that's a perfectly\
    \ straight infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.", "\"\"\"\nImagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.", "    # Write your code here\n    # A car will\
    \ collide with itself only when it is travelling in the same direction\n    #\
    \ If the cars are going in the same direction, then there is a collision\n   \
    \ collisions = 0\n    for car1 = 0:(n - 1)\n        for car2 = car1 + 1:(n - 1)\n\
    \            if car1[car2] < car2[car1]\n                # The first car will\
    \ collide with the second car\n                collisions += 1\n            end\n\
    \        end\n    end\n    return collisions\nend\n</cell>\n<code language=julia-1.5>\n\
    car_race_collision(10)\n</cell>\n<text>\nQuestion 4. Write a function which returns\
    \ the number of cars that collide in a straight line.\nInput: Two lists of cars\n\
    Output: Number of cars that collide\nThe cars are represented as lists of length\
    \ 2.", "    collide::Int64 = 0\n    for i \u2208 1:n\n        for j \u2208 i+1:n\n\
    \            if ((car_position(i, 0) \u2264 car_position(j, 0) - car_speed) \u2227\
    \n                (car_position(i, 1) \u2264 car_position(j, 1) - car_speed))\n\
    \                collide += 1\n                println(collide)\nend\n</cell>\n\
    <code language=julia-1.3>\ncar_race_collision(5)\n</cell>\n<code language=julia-1.3>\n\
    #export", "\"\"\"\n    Imagine a road that's a perfectly straight infinitely long\
    \ line.\n    n cars are driving left to right;  simultaneously, a different set\
    \ of n cars\n    are driving right to left.   The two sets of cars start out being\
    \ very far from\n    each other.  All cars move in the same speed.  Two cars are\
    \ said to collide\n    when a car that's moving left to right hits a car that's\
    \ moving right to left.\n    However, the cars are infinitely sturdy and strong;\
    \ as a result, they continue moving\n    in their trajectory as if they did not\
    \ collide.", "    collisions = 0\n    \n    for k in 1:n\n        for l in 1:n\n\
    \            if (( abs(k*2 - n) == 0) & ( abs(l*2 - n) == 0) )\n            collisions\
    \ += 1\n        end\n    end", "    # your code here\nend\n</cell>\n<code language=julia-1.5>\n\
    car_race_collision(10)\n</cell>\n<text>\nExercise: Explain what this means.",
  "  \n    # number of cars colliding with each other car\n    collisions = 0\n  \n\
    \    \n    # loop over all cars to check for collisions with others\n    for car\
    \ in 1:n\n        if car_collide(car,n)\n          collisions = collisions + 1\n\
    \        end\n    end\n    \n    return collisions\nend\n</cell>\n<code language=julia-1.5>\n\
    car_race_collision(100)\n</cell>\n<code language=julia-1.5>\n# how many cars collide?",
  "    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n\
    \    n cars are driving left to right;  simultaneously, a different set of n cars\n\
    \    are driving right to left.   The two sets of cars start out being very far\
    \ from\n    each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n    when a car that's moving left to right hits a car that's moving\
    \ right to left.\n    However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n    in their trajectory as if they did not collide.",
  "    # Write your code here\n    function collides(a::Int, b::Int)\n        if (a==0\
    \ || b==0) return false\n        a_dist = (a-1)/a\n        b_dist = (b-1)/b\n\
    \        return (a_dist * a_dist + b_dist * b_dist) <= 1\n    end\n    function\
    \ collides_between(a::Int, b::Int)\n        if (a==0 || b==0) return false\n \
    \       a_dist = (a-1)/a\n        b_dist = (b-1)/b\n        return (a_dist + b_dist)\
    \ <= 1\n    end\n    function collides_with(a::Int64, b::Int64)\n        a_dist\
    \ = (a-1)/a\n        b_dist = (b-1)/b\n        return (a_dist * a_dist + b_dist\
    \ * b_dist) <= 1\n    end\n    count = 0\n    for i in 1:n\n        for j in i+1:n\n\
    \            for k in j+1:n\n                if collides(i,j) && collides_between(i,k)\
    \ && collides(j,k)\n                    count += 1\n                end\n    \
    \        end\n        end\n    end\n    return count\nend\n</cell>\n<text>\nLet's\
    \ use it to solve the problem of detecting cars in a race at intersections between\
    \ roads.  Here are the results of testing all possible pairs of cars:", "    \"\
    \"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n \
    \   n cars are driving left to right;  simultaneously, a different set of n cars\n\
    \    are driving right to left.   The two sets of cars start out being very far\
    \ from\n    each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n    when a car that's moving left to right hits a car that's moving\
    \ right to left.\n    However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n    in their trajectory as if they did not collide.",
  "    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n\
    \    n cars are driving left to right;  simultaneously, a different set of n cars\n\
    \    are driving right to left.   The two sets of cars start out being very far\
    \ from\n    each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n    when a car that's moving left to right hits a car that's moving\
    \ right to left.\n    However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n    in their trajectory as if they did not collide.",
  "    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n\
    \    n cars are driving left to right;  simultaneously, a different set of n cars\n\
    \    are driving right to left.   The two sets of cars start out being very far\
    \ from\n    each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n    when a car that's moving left to right hits a car that's moving\
    \ right to left.\n    However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n    in their trajectory as if they did not collide.",
  "    if n == 0 \n        return 0 \n    return car_race_collision(n-1) + car_race_collision(n-2)\
    \ + car_race_collision(n-3) + car_race_collision(n-4) + car_race_collision(n-5)\
    \ \nend \n</cell>\n<code language=julia-1.5>", "\"\"\"\n    CarRace - Determine\
    \ if there is a collision between any two cars", "    \"\"\"This function returns\
    \ how many car_race_collision collisions there are\"\"\"\n    car_race_collision_count\
    \ = 0\n    for i = 1:n\n        for j = i+1:n\n            if car_race(i,j) \n\
    \                car_race_collision_count = car_race_collision_count + 1\n   \
    \         end\n        end\n    end\n    return car_race_collision_count\nend",
  "    collisions = 0\n    for i = 1:n \n        if car_race_collision(i) ~= 0 \n\
    \            collisions += car_race_collision(i)\n        end\n    end\n    collisions\n\
    end\n</cell>\n<code language=julia-1.5>", "    if (n < 3)\n        n = 0\n   \
    \ else\n        n = n - 2\n    return n\nend", "    collides = 0\n    for i =\
    \ 1:n\n        for j = i+1:n\n            if car_race_collision_test(cars[i][1],\
    \ cars[j][1]) == true\n                collides += 1\n            end\n      \
    \  end\n    end\n    return collides\nend", "# n is the number of cars to simulate,\
    \ where\n#    n is \u2264 \u212F\n# Output: The number of cars that collided during\
    \ their simulation.\n#    If no collision occurs, this number should be 0", " \
    \   \"Return the number of car_race collisions\"\n    let n = (n mod 2) in 0..n+1\n\
    end", "    collide_cars_right\n    collide_cars_left\n    return collide_cars_right+collide_cars_left",
  "    mutable i = 1;\n    mutable collisions = 0;\n    while (i <> n)\n        i\
    \ <- (i + 1) mod n\n        if (i > 1 && (i-1) % n == 0)\n            collisions\
    \ <- collisions + 1\n        i <- i - 1\n    return collisions\nend\n\"\"\"\n\
    \    How many rock climbers need to run their race before a man of higher value\
    \ runs faster?\n    \n    Parameters\n    ----------\n    n : Int64\n        The\
    \ number of rock climbers to run their race for.  \n    many_to_run : Int64\n\
    \        The number of man of higher value that need to run their race before\
    \ they will run faster\n    \n    Returns\n    -------\n    int\n        The number\
    \ of rock climbers need to run their race before a man of higher value runs faster\n\
    \"\"\"", "    if n==1 \n        return 1 \n    else \n        car_race_collision(n-1)\
    \ \n        car_race_collision(n-1) \n        return 2 * car_race_collision(n-1)\
    \ \nend", "    if n == 0\n        return 0\n    local sum::Int64 = 0\n    for\
    \ i = 1 to n do\n        local collide::Bool = true\n        for j = 1 to n do\n\
    \            if ((j - i) <= 1 or abs(i - j) <= 1) then\n                collide\
    \ = false\n                break\n            end\n        end\n        if collide\
    \ == true then\n            sum::Int64 = sum + 1\n        end\n    end\n    return\
    \ sum\nend", "    collides = 0\n    for i=1:n\n        for j=1:n\n           \
    \ if i == j \n                continue\n            collides = collides + car_collision(i-1,j-1)\n\
    \        end\n    end\n    return collides", "    n \nend", "    collisions =\
    \ 0\n    \n    # Loop through all combinations of n cars\n    for i = 1:n\n  \
    \      for j = i+1:n\n            # Check to see if the cars actually collide\n\
    \            if collision_test(car_positions(i, :), car_positions(j, :)):\n  \
    \              collisions += 1\n    return collisions\nend", "    \"\"\"\n   \
    \ Imagine a road that's a perfectly straight infinitely long line.\n    n cars\
    \ are driving left to right;  simultaneously, a different set of n cars\n    are\
    \ driving right to left.   The two sets of cars start out being very far from\n\
    \    each other.  All cars move in the same speed.  Two cars are said to collide\n\
    \    when a car that's moving left to right hits a car that's moving right to\
    \ left.\n    However, the cars are infinitely sturdy and strong; as a result,\
    \ they continue moving\n    in their trajectory as if they did not collide.",
  "    collisions = 0\n    for i = 1:n\n        for j = 1:n\n            if (i!=j)\
    \ & (car_distance(i, j)==car_distance(i,n)) &\n               (car_distance(n,\
    \ j)==car_distance(n,n)) &\n               (car_distance(n, i) == car_distance(n,\
    \ (n-1)))\n                collisions += 1\n        end\n    end\n    return collisions\n\
    end\n</cell>\n<code language=julia-1.5>\n@time car_race_collision(n=10)\n</cell>\n\
    <text>\nQuestion 2.3 : Simulate some race-related collisions using @simd and @parallel",
  "    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n\
    \    n cars are driving left to right;  simultaneously, a different set of n cars\n\
    \    are driving right to left.   The two sets of cars start out being very far\
    \ from\n    each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n    when a car that's moving left to right hits a car that's moving\
    \ right to left.\n    However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n    in their trajectory as if they did not collide.",
  "    collide::Int64 = 0\n    if n == 1 \n        collide = 1\n        return collide\n\
    \    for j in (1 .. n-1)\n        for i in (1 .. n-1) \n            if i != j\
    \ \n                if distance(car1[i], car2[j]) < distance(car2[i], car1[j])\
    \ \n                    collide = collide + 1\n                    \n    return\
    \ collide\nend", "    # your code here\n    return 0\nend", "    collided_cars\
    \ = 0\n    \n    for i = 1:n\n        for j = 1:n\n            if i!=j && car_collision(i,j)\n\
    \                collided_cars = collided_cars + 1\n            end\n        end\n\
    \    end\n    return collided_cars\nend\n</cell>\n<code language=julia-0.6>",
  "    \"The number of cars colliding with themselves right to left.\"\n    cars_right(n)\
    \ = n - 1\n    cars_left(n) = 1\n    colliding = 0\n    for i=0:n\n        for\
    \ j=0:n\n            if i != j && cars_right(i) > 0 && cars_left(j) > 0 && (cars_right(i)\
    \ < cars_left(j)) \n                colliding = colliding + 1\n    return colliding\n\
    end", "    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long\
    \ line.\n    n cars are driving left to right;  simultaneously, a different set\
    \ of n cars\n    are driving right to left.   The two sets of cars start out being\
    \ very far from\n    each other.  All cars move in the same speed.  Two cars are\
    \ said to collide\n    when a car that's moving left to right hits a car that's\
    \ moving right to left.\n    However, the cars are infinitely sturdy and strong;\
    \ as a result, they continue moving\n    in their trajectory as if they did not\
    \ collide.", "\"\"\"\n    Imagine a road that's a perfectly straight infinitely\
    \ long line.\n    n cars are driving left to right;  simultaneously, a different\
    \ set of n cars\n    are driving right to left.   The two sets of cars start out\
    \ being very far from\n    each other.  All cars move in the same speed.  Two\
    \ cars are said to collide\n    when a car that's moving left to right hits a\
    \ car that's moving right to left.\n    However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    in their trajectory as if\
    \ they did not collide.", "\"\"\"\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.", "    collisions = 0\n    i = 0\n    car_left =\
    \ 1\n    car_right = n - 1\n    while i != car_left && i != car_right\n      \
    \  j = i + 1\n        while (j != car_left && j != car_right)\n            if\
    \ (car_race(i) == car_race(j))\n                collisions = collisions + 1\n\
    \            j = j + 1\n        i = i + 1\n    end\n    return collisions\nend\n\
    </cell>\n<code language=julia-1.0>\ncar_race_collision(100)\n</cell>\n<text>\n\
    Exercise 3\nWrite a function count_intersections::Int -> Int -> Int\nthat, given\
    \ a number of cars, a race car, and a number of race cars,\nreturns the number\
    \ of intersections between the race car and each car.", "\"\"\"\n    Imagine a\
    \ road that's a perfectly straight infinitely long line.\n    n cars are driving\
    \ left to right;  simultaneously, a different set of n cars\n    are driving right\
    \ to left.   The two sets of cars start out being very far from\n    each other.\
    \  All cars move in the same speed.  Two cars are said to collide\n    when a\
    \ car that's moving left to right hits a car that's moving right to left.\n  \
    \  However, the cars are infinitely sturdy and strong; as a result, they continue\
    \ moving\n    in their trajectory as if they did not collide.", "\"\"\"\n    Imagine\
    \ a road that's a perfectly straight infinitely long line.\n    n cars are driving\
    \ left to right;  simultaneously, a different set of n cars\n    are driving right\
    \ to left.   The two sets of cars start out being very far from\n    each other.\
    \  All cars move in the same speed.  Two cars are said to collide\n    when a\
    \ car that's moving left to right hits a car that's moving right to left.\n  \
    \  However, the cars are infinitely sturdy and strong; as a result, they continue\
    \ moving\n    in their trajectory as if they did not collide.", '    # Write your
    solution here', "    if n <= 0\n        return 0;\n    end\n    collisions = 1;\n\
    \    for i = 1 to n-1\n        collisions = collisions * car_race_collision(n-1);\n\
    \    end\n    return collisions;\nend", "    # your code here\n    left_roads\
    \ = sum(is_left_road(x) for x in range(n))\n    right_roads = sum(is_right_road(x)\
    \ for x in range(n))\n    return left_roads + right_roads", "    \n    collisions\
    \ = 0\n    \n    # initialize an array\n    car_1 = []\n    car_2 = []\n    \n\
    \    # Initialize the first and second cars\n    for i in 1:n\n        car_1.push(i)\n\
    \    end", "\"\"\"\n    Imagine a road that's a perfectly straight infinitely\
    \ long line.\n    n cars are driving left to right;  simultaneously, a different\
    \ set of n cars\n    are driving right to left.   The two sets of cars start out\
    \ being very far from\n    each other.  All cars move in the same speed.  Two\
    \ cars are said to collide\n    when a car that's moving left to right hits a\
    \ car that's moving right to left.\n    However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    in their trajectory as if\
    \ they did not collide.", "    collisions = 0\n    for (i in 1:n) \n        if\
    \ car_race_right(i, i+1) <= 0 \n            collisions += 1\n        end\n   \
    \ end\n    return collisions\nend", "    \"\"\"\n    Write a function that takes\
    \ in a positive integer n and returns the number\n    of cars that have collided\
    \ with another car.", "    # Your code here\n    return 0\nend", "\tlocal car_race_collisions\
    \ := 0\n\tfor i in 1:n do \n\t\tlocal a = 0 \n\t\tfor j in i+1:n do \n\t\t\tlocal\
    \ b = i - j + 1 \n\t\t\tlocal c = car_distance(a:=i, j:=j) \n\t\t\tlocal d = car_distance(b:=i,\
    \ j:=j) \n\t\t\tif c < d then \n\t\t\t\ta = i \n\t\t\t\tbreak\n\t\t\tend\n\t\t\
    end\n\t\tcar_race_collisions = car_race_collisions + 1 \n\tend\n\treturn car_race_collisions\
    \ \nend\n</cell>\n<code language=julia-0.3>\ncar_race_collisions(101)\n</cell>\n\
    <code language=julia-0.3>\ncar_race_collisions(31)\n</cell>\n<code language=julia-0.3>\n\
    car_race_collisions(91)\n</cell>\n<code language=julia-0.3>\ncar_race_collisions(100)\n\
    </cell>\n<code language=julia-0.3>", "    \"\"\"\n    Imagine a road that's a\
    \ perfectly straight infinitely long line.\n    n cars are driving left to right;\
    \  simultaneously, a different set of n cars\n    are driving right to left. \
    \  The two sets of cars start out being very far from\n    each other.  All cars\
    \ move in the same speed.  Two cars are said to collide\n    when a car that's\
    \ moving left to right hits a car that's moving right to left.\n    However, the\
    \ cars are infinitely sturdy and strong; as a result, they continue moving\n \
    \   in their trajectory as if they did not collide.", "    if n==1 \n        return\
    \ 0 \n    \n    collisions:Int64 = 0\n    cars = Int64[n]\n    for i=1:n\n   \
    \     for j=i+1:n\n            if cars[j]>0 \n                collide:Bool\n \
    \               if cars[j] == cars[i] \n                    collide = false\n\
    \                else \n                    collide = true\n                end\
    \ \n            elseif cars[i] > 0 \n                collide:Bool\n          \
    \      if cars[i] == cars[j] \n                    collide = false\n         \
    \       else \n                    collide = true\n                end \n    \
    \        end\n            if collide \n                collisions = collisions\
    \ + 1 \n            end\n        end\n    end\n    return collisions\nend\n\"\"\
    \"\n    \"\"\"\n    Outputs number of cars that collide when running on a grid\n\
    \    \"\"\"", "    if n==0 \n        return 0 \n    collided::Int64 = 0\n    for\
    \ i=1:(n-1) \n        for j=i+1:n \n            if car_collided(i,j) \n      \
    \          collided = collided + 1\n            end\n        end\n    end\n  \
    \  return collided\nend", "    # your code here\n    if n==0\n        return 0\n\
    \    elseif n==1\n        return 1\n    elseif n>1\n        car_race_collision(ceil(n/2)-1)\n\
    \        car_race_collision(ceil(n/2))\nend\n</cell>\n<text>\nThe function car_race_collision\
    \ takes a positive integer $n$ and returns an integer with the number of collisions.\
    \  You will write this function in an iPython notebook, but it's good practice\
    \ to test your function before you run it in the notebook.", "    \n    let c\
    \ = zeros(Int64, length(cars0))\n    \n    for ii in 1:length(cars0)\n       \
    \ for jj in 1:length(cars1)\n            if collide(cars0[ii], cars1[jj])\n  \
    \              c[ii] = c[ii] + 1\n            end\n        end\n    end", "  \
    \  collisions = 0\n    for i = n\n        j = i - 1\n        collisions += if\
    \ car_left_to_right(j) then 1 else 0\n        collisions += if car_right_to_left(i)\
    \ then 1 else 0\n    return collisions\n</cell>\n<code language=julia-1.0>\ncar_race_collision(n=10)\n\
    </cell>\n<text>\nPart 3: Bringing the Cars\nThese two functions will bring the\
    \ cars back to the original positions.", "    # your code here\n    return 0\n\
    end", "  # Input:\n  # n - number of cars, each of which has its own velocity\
    \ vector\n  # Output:\n  # n - number of collisions", "    count = 0 \n    for\
    \ i in 1:n \n        for j in 1:n \n            if i != j \n                if\
    \ abs(car_x_position(i) - car_x_position(j)) < car_radius && abs(car_y_position(i)\
    \ - car_y_position(j)) < car_radius \n                    count++ \n    end \n\
    \    return count", "    \"\"\"\n    Calculate the number of car-race collisions\
    \ using brute-force search", "\"\"\"\n    Idea from https://www.youtube.com/watch?v=yO5UG0P5zD4\n\
    \"\"\"\n    distances :: Vector Float64 = generate_vectors(n)\n    distance_sum\
    \ :: Float64 = 0\n    for distance in distances\n        distance_sum += distance^2\n\
    \    end", "    collisions = 0\n    for ii in 1:n\n        collisions += car_race_collision_helper(ii)\n\
    \    return collisions\nend", "    \"\"\"\n    Cars race against one another in\
    \ perfect straight line\n    \"\"\"", "    # Return the number of times the road\
    \ collided \n    # with itself.\n    return 0\nend\n\"\"\"\n    Exercise\n   \
    \ \n    \n    \n\"\"\"", "    #\n    # YOUR CODE HERE\n    #\n    return 0", " \
    \   \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n\
    \    n cars are driving left to right;  simultaneously, a different set of n cars\n\
    \    are driving right to left.   The two sets of cars start out being very far\
    \ from\n    each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n    when a car that's moving left to right hits a car that's moving\
    \ right to left.\n    However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n    in their trajectory as if they did not collide.",
  "    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n\
    \    n cars are driving left to right;  simultaneously, a different set of n cars\n\
    \    are driving right to left.   The two sets of cars start out being very far\
    \ from\n    each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n    when a car that's moving left to right hits a car that's moving\
    \ right to left.\n    However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n    in their trajectory as if they did not collide.",
  "    \n    # Write a function that, given the number of cars in the race, returns\
    \ the number of cars\n    # that collide with the other cars.  Your code should\
    \ use a for loop to iterate over all the cars\n    # in the race.  For each iteration,\
    \ you should test whether the i-th car in the race collides\n    # with the j-th\
    \ car in the race.  If the cars collide, you should add one to num_collisions.\
    \  \n    #\n    # For example, suppose you have 3 cars arranged in a straight\
    \ line, starting at [1, 2], and you\n    # want to find the number of cars that\
    \ collide with the others.  Your output should be\n    # 3", "    \"\"\"\n   \
    \ Imagine a road that's a perfectly straight infinitely long line.\n    n cars\
    \ are driving left to right;  simultaneously, a different set of n cars\n    are\
    \ driving right to left.   The two sets of cars start out being very far from\n\
    \    each other.  All cars move in the same speed.  Two cars are said to collide\n\
    \    when a car that's moving left to right hits a car that's moving right to\
    \ left.\n    However, the cars are infinitely sturdy and strong; as a result,\
    \ they continue moving\n    in their trajectory as if they did not collide.",
  '    """(Int64)', "    collisions = 0\n    for i = 1:n-1\n        for j = i+1:n\n\
    \            if car_distance(i, j) < car_distance(j, i)\n                collisions\
    \ += 1\n            end\n        end\n    end\n    return collisions\nend", " \
    \   if n == 0 \n        return 0\n    else \n        return car_race_collision(n-1)\
    \ + car_race_collision(n-1)", "    \"\"\"\n    Imagine a road that's a perfectly\
    \ straight infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.", "    n,i,j,k = @where(car_race_data)\n    n,i,j,k\
    \ = convert(Int64,n),convert(Int64,i),convert(Int64,j),convert(Int64,k)\n    \n\
    \    if i > 0\n        tmp = n\n        n = i\n        i = tmp\n    end\n    \n\
    \    if j > 0\n        tmp = n\n        n = j\n        j = tmp\n    end\n    \n\
    \    if k > 0\n        tmp = n\n        n = k\n        k = tmp\n    end\n    \n\
    \    a,b,c = @car_race_data[(n,i,j,k)]\n    \n    if a > b\n        return n\n\
    \    elseif b > c\n        return i\n    elseif c > a\n        return j\n    else\n\
    \        return k\n    end\nend", "    collisions = 0\n    for i in 1:n\n    \
    \    for j in (i+1):n\n            if car_collisions(i,j)\n                collisions\
    \ += 1\n    return(collisions)\nend", "    \"\"\"\n    Imagine a road that's a\
    \ perfectly straight infinitely long line.\n    n cars are driving left to right;\
    \  simultaneously, a different set of n cars\n    are driving right to left. \
    \  The two sets of cars start out being very far from\n    each other.  All cars\
    \ move in the same speed.  Two cars are said to collide\n    when a car that's\
    \ moving left to right hits a car that's moving right to left.\n    However, the\
    \ cars are infinitely sturdy and strong; as a result, they continue moving\n \
    \   in their trajectory as if they did not collide.", "    car_left_1 = car_left_0\n\
    \    car_right_1 = car_right_0", "    \"\"\"\n    Imagine a road that's a perfectly\
    \ straight infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.", "    \"\"\"\n    Imagine a road that's a perfectly\
    \ straight infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.", "    collides = 0\n    for i = 0:n-1\n       \
    \ for j = (i+1):n\n            if car_race_collision_check(i, j)\n           \
    \     collides += 1\n    return collides\nend", "    \"\"\"\n    Imagine a road\
    \ that's a perfectly straight infinitely long line.\n    n cars are driving left\
    \ to right;  simultaneously, a different set of n cars\n    are driving right\
    \ to left.   The two sets of cars start out being very far from\n    each other.\
    \  All cars move in the same speed.  Two cars are said to collide\n    when a\
    \ car that's moving left to right hits a car that's moving right to left.\n  \
    \  However, the cars are infinitely sturdy and strong; as a result, they continue\
    \ moving\n    in their trajectory as if they did not collide.", "    \"\"\"\n\
    \    Imagine a road that's a perfectly straight infinitely long line.\n    n cars\
    \ are driving left to right;  simultaneously, a different set of n cars\n    are\
    \ driving right to left.   The two sets of cars start out being very far from\n\
    \    each other.  All cars move in the same speed.  Two cars are said to collide\n\
    \    when a car that's moving left to right hits a car that's moving right to\
    \ left.\n    However, the cars are infinitely sturdy and strong; as a result,\
    \ they continue moving\n    in their trajectory as if they did not collide.",
  "    collisions::Int64 = 0\n    for i in 1:n\n        for j in i+1:n\n         \
    \   if dist(i,j) < 100\n                collisions += 1\n    return collisions\n\
    \    \n</cell>\n<cell>\n# TEST car_race_collision (5) (499 ms)\ncar_race_collision(5)\n\
    </cell>\n<text>\nThe race car car collides with itself?  What about a race car\
    \ colliding with a non-race car?", "    collision::Int64 = 0\n    for i in 1:n\n\
    \        if car_i_is_racing(i) == true && car_i_is_not_colliding(i) == false &&\
    \ car_i_is_not_colliding(i + 1) == false\n            collision = collision +\
    \ 1\n        end\n    end\n    return collision\nend", "\"\"\"\n    Imagine a\
    \ road that's a perfectly straight infinitely long line.\n    n cars are driving\
    \ left to right;  simultaneously, a different set of n cars\n    are driving right\
    \ to left.   The two sets of cars start out being very far from\n    each other.\
    \  All cars move in the same speed.  Two cars are said to collide\n    when a\
    \ car that's moving left to right hits a car that's moving right to left.\n  \
    \  However, the cars are infinitely sturdy and strong; as a result, they continue\
    \ moving\n    in their trajectory as if they did not collide.", "  # Your code\
    \ here\n  collide_count = 0\n  for c in cars\n    if c.left > n || c.right < 0\n\
    \      collide_count = collide_count + 1\n    end\n  end\n  return collide_count\n\
    end", "    car_race_array = []\n    race_count = 0\n    for i in 1:n\n       \
    \ for j in (i+1):n\n            if car_race_array[i] == car_race_array[j]\n  \
    \              race_count += 1\n        end\n    end\n    return race_count\n\
    end\n</cell>\n<code language=julia-1.1>\nusing DataFrames, Colors\ndf = DataFrame(collision_length\
    \ = 1:10^6)\nfor n in 1:10^5\n    push!(df, DataFrame(\n        n_cars = 10,\n\
    \        collisions = car_race_collision(n),\n        remaining = $(n * (n-1)),\n\
    \    ))\nend\ndf[:race_time] = df[:collisions] ./ df[:remaining]\ndf[:race_time]\
    \ = round(df[:race_time])\n</cell>\n<code language=julia-1.1>\nplot(x=df[:collisions],\
    \ y=df[:race_time], marker=:square, \n    color=:lightblue, label=\"Race time\"\
    , \n    xlabel=\"Number of cars to race\", ylabel=\"Race time (s)\")\n</cell>\n\
    <text>\nCarRace problem solution 2 (Python)", "    # O(n^2)\n    collides = 0\n\
    \    for i = 1:n\n        for j = 1:n\n            if i != j\n               \
    \ if is_car_colliding(i, j) == true\n                    collides += 1\n    end\n\
    \    return collides\nend\n</cell>\n<code language=julia-1.0>", "    collide_counts\
    \ = zeros(Int, n)\n    for i = 1:n\n        for j = 1:n\n            collide_counts[i]\
    \ += 1\n            if i != j\n                collide_counts[j] += 1\n    return\
    \ collide_counts\nend", "    # Your code here\n    \nend\n</cell>\n<code language=julia-1.6>\n\
    @time car_race_collision(100);\n</cell>\n<text>\nExercises\nExercise: Write a\
    \ function which returns true if the two cars collide and false if they do not.",
  "    # Your code here\n    return 0 \nend\n</cell>\n<code language=julia-1.3>\n\
    n = 100\ntimes = zeros(n, n) # to save a lot of computation.\nfor i in 1:n\n \
    \   for j in 1:n\n        collisions = car_race_collision(n)\n        if collisions\
    \ > 0\n            times[i, j] = collisions\n        end\n    end\nend\n</cell>\n\
    <text>\nThe above code ran for almost 2 hours (I stopped it after about 12 hours).\
    \  But let me be fast...  Here is a faster version, which stops after some number\
    \ of collisions:", "    return sum( (car_racing_collision(n - 1)) * (n - 1) )\n\
    end\n</cell>\n<text>\nWrite a Julia function that tells us how many possible sets\
    \ of n cars are colliding with each other?  Here are a few simple examples.",
  "    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n\
    \    n cars are driving left to right;  simultaneously, a different set of n cars\n\
    \    are driving right to left.   The two sets of cars start out being very far\
    \ from\n    each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n    when a car that's moving left to right hits a car that's moving\
    \ right to left.\n    However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n    in their trajectory as if they did not collide.",
  "  ncars = n+1\n  collisions = zeros(Int64,ncars)\n  for i = 1:ncars\n    collisions[i]\
    \ = 1\n    for j = i+1:ncars\n      if i==j\n        continue\n      collides\
    \ = true\n      collides[car_distance(mycar_pos[i,:],mycar_pos[j,:])>1.0]= false\n\
    \      collisions[j] = collides\n    end\n  end\n  ix = argmax!(collisions)\n\
    \  collisions[ix]\nend", "    collisions = 0\n    for a in 1:n\n        for b\
    \ in 1:n\n            if a[b] == 0\n            collisions += 1\n        end\n\
    \    end\n    return collisions\nend\n</cell>\n<code language=julia-1.3>\nusing\
    \ Test\n@test car_race_collision(10) == 55\n</cell>\n<text>\nProblem 9: Test for\
    \ Two Cars Colliding in Race 4\nA series of n cars begin racing against each other.\
    \  Among all the cars in the race,\nthere is one that has left the race and is\
    \ about to collide.  The one that's about to\ncollide has initially taken 1 second\
    \ to collide, then 2 seconds, then 3 seconds, then\n4 seconds, then 5 seconds,\
    \ then 6 seconds, then 7 seconds, then 8 seconds, then 9 seconds, and\nthen 10\
    \ seconds.", "    if n < 2 then return n\n    \n    #\n    # The solution is simply\
    \ the sum of number of collisions occurring for each\n    # pair of consecutive\
    \ cars; e.g. (1,2), (2,3)...\n    # \n    car_race_collision = 0\n    for i in\
    \ 1..n-1 do\n        for j in i+1..n do\n            car_race_collision = car_race_collision\
    \ + car_race_collision(j-i)\n        end\n    end\n    return car_race_collision\n\
    end\n</cell>\n<code language=julia-0.4>\ncar_race_collision(6)\n</cell>\n<text>\n\
    A faster solution\nThe following is a faster solution. It runs in $O(n^2)$.",
  "    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n\
    \    n cars are driving left to right;  simultaneously, a different set of n cars\n\
    \    are driving right to left.   The two sets of cars start out being very far\
    \ from\n    each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n    when a car that's moving left to right hits a car that's moving\
    \ right to left.\n    However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n    in their trajectory as if they did not collide.",
  "  collisions = 0\n  for i in 0 .. n-1 \n    for j in i+1 .. n\n      if abs(x[i,j]-x[j,i])\
    \ > race_size\n        collisions += 1\n        break\n    end\n  end\n  return\
    \ collisions\nend\n</cell>\n<code language=julia-0.6>\nprintln(\"number of collisions\
    \ is: \", car_race_collision(1000))\n</cell>\n<text>\nNow that we've implemented\
    \ collision detection, how do we simulate it?  We want to find out how many cars\
    \ collide between two cars moving at different speeds.", "    return 0\nend",
  "    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n\
    \    n cars are driving left to right;  simultaneously, a different set of n cars\n\
    \    are driving right to left.   The two sets of cars start out being very far\
    \ from\n    each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n    when a car that's moving left to right hits a car that's moving\
    \ right to left.\n    However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n    in their trajectory as if they did not collide.",
  "    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n\
    \    n cars are driving left to right;  simultaneously, a different set of n cars\n\
    \    are driving right to left.   The two sets of cars start out being very far\
    \ from\n    each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n    when a car that's moving left to right hits a car that's moving\
    \ right to left.\n    However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n    in their trajectory as if they did not collide.",
  "    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n\
    \    n cars are driving left to right;  simultaneously, a different set of n cars\n\
    \    are driving right to left.   The two sets of cars start out being very far\
    \ from\n    each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n    when a car that's moving left to right hits a car that's moving\
    \ right to left.\n    However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n    in their trajectory as if they did not collide.",
  "    return 0\nend ", "    if n==0 \n        return 0\n    if n==1 \n        return\
    \ 1\n    else \n        return car_race_collision(n-1)+car_race_collision(n-1)",
  "    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n\
    \    n cars are driving left to right;  simultaneously, a different set of n cars\n\
    \    are driving right to left.   The two sets of cars start out being very far\
    \ from\n    each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n    when a car that's moving left to right hits a car that's moving\
    \ right to left.\n    However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n    in their trajectory as if they did not collide.",
  "\"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n\
    \    n cars are driving left to right;  simultaneously, a different set of n cars\n\
    \    are driving right to left.   The two sets of cars start out being very far\
    \ from\n    each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n    when a car that's moving left to right hits a car that's moving\
    \ right to left.\n    However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n    in their trajectory as if they did not collide.",
  "    sum = 0 \n    for _ in 1:n do\n        for _ in 1:n do \n            if !(car_race_collide(car_x_start,\
    \ car_y_start)==false) \n                sum += 1 \n    return sum \nend", "#@markdown\
    \ Make sure to run this cell after completing previous cell\n    \n#@markdown\
    \ ---\n    ", "    if n==1 \n        return 1\n    else \n        return car_race_collision(n-1)\
    \ + car_race_collision(n-2)\nend\n</cell>\n<code language=julia-1.3>\n\"\"\"\n\
    \    car_race_collision_number(n::Int64)::Int64", "    \n    \"\"\"\n    \n  \
    \  Input:\n    - n - the length of the line segment\n    \n    Output:\n    -\
    \ the number of cars colliding with each other\n    \"\"\"", "    collides = 0\n\
    \    for i in 1:n\n        cars_at_same_x_at_diff_speed_and_directions = false\n\
    \        for j in 1:n\n            if i != j\n                if (\n         \
    \           cars_at_same_x_at_diff_speed_and_directions and\n                \
    \    abs(x_at(i)-x_at(j)) < 1\n                )\n                    collides\
    \ += 1\n                    cars_at_same_x_at_diff_speed_and_directions = false\n\
    \                    \n                else\n                    cars_at_same_x_at_diff_speed_and_directions\
    \ |= (\n                        abs(x_at(i)-x_at(j))\n                       \
    \ < car_speed_difference_at_diff_speed\n                    )\n              \
    \      \n            end\n        end\n    end\n    return collides", "    colliding\
    \ = 0 \n    for i in 1:n\n        car_left = Car(i, 1, xc[i])\n        car_right\
    \ = Car(i+1, 1, xc[i+1])\n        for j in i+1:n\n            car_center = Car(j,\
    \ 1, xc[j])\n            if car_center.collides(car_left, car_right) == true\n\
    \                colliding += 1\n            end\n        end\n    end\n    return\
    \ colliding\nend\n\"\"\"\n    Write a function that takes a vector of cars xc,\
    \ a vector of the lengths of each segment of the road l, and a car that you are\
    \ trying to find a collision for, and returns the index of the car that colides\
    \ with your car.", "    collisions::Int64 = 0\n    for i in 1:(n-1)\n        for\
    \ j in (i+1):n\n            if abs(i) == abs(j)\n                collisions +=\
    \ 1\n    \n    return collisions\n</cell>\n<code language=julia-1.6>\ncar_race_collision(10)\n\
    </cell>\n<text>\n5.  A car is running forward, what happens to the number of collisions?\n\
    Input: An integer n that represents the number of cars running forward.", "  \
    \  \"\"\"\"\n    Drive n cars simultaneously and see how many cars collide.",
  "    car_1 = Car(0,0,10,1)\n    car_2 = Car(10,0,10,1)\n    car_3 = Car(20,0,10,1)\n\
    \    car_4 = Car(10,10,10,1)\n    car_5 = Car(20,10,10,1)\n    car_6 = Car(10,20,10,1)\n\
    \    car_7 = Car(20,20,10,1)\n    car_8 = Car(10,10,20,1)\n    car_9 = Car(20,10,20,1)\n\
    \    car_10 = Car(10,20,20,1)\n    car_11 = Car(20,20,20,1)\n    car_12 = Car(10,10,10,10)\n\
    \    car_13 = Car(20,10,10,10)\n    car_14 = Car(10,20,10,10)\n    car_15 = Car(20,20,10,10)\n\
    \    car_16 = Car(10,10,20,10)\n    car_17 = Car(20,10,20,10)\n    car_18 = Car(10,20,20,10)\n\
    \    car_19 = Car(20,20,20,10)\n    car_20 = Car(10,10,10,20)\n    car_21 = Car(20,10,10,20)\n\
    \    car_22 = Car(10,20,10,20)\n    car_23 = Car(20,20,10,20)\n    car_24 = Car(10,10,20,20)\n\
    \    car_25 = Car(20,10,20,20)\n    car_26 = Car(10,20,20,20)\n    car_27 = Car(20,20,20,20)\n\
    \    car_28 = Car(10,10,10,10)\n    car_29 = Car(20,10,10,10)\n    car_30 = Car(10,20,10,10)\n\
    \    car_31 = Car(20,20,10,10)\n    car_32 = Car(10,10,20,10)\n    car_33 = Car(20,10,20,10)\n\
    \    car_34 = Car(10,20,20,10)\n    car_35 = Car(20,20,20,10)\n    car_36 = Car(10,10,10,20)\n\
    \    car_37 = Car(20,10,10,20)\n    car_38 = Car(10,20,10,20)\n    car_39 = Car(20,20,10,20)\n\
    \    car_40 = Car(10,10,20,20)\n    car_41 = Car(20,10,20,20)\n    car_42 = Car(10,20,20,20)\n\
    \    car_43 = Car(20,20,20,20)\n    car_44 = Car(10,10,10,10)\n    car", "   \
    \ \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n\
    \    n cars are driving left to right;  simultaneously, a different set of n cars\n\
    \    are driving right to left.   The two sets of cars start out being very far\
    \ from\n    each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n    when a car that's moving left to right hits a car that's moving\
    \ right to left.\n    However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n    in their trajectory as if they did not collide.",
  "    # O(n^2)\n    # O(n^2)\n    # O(n^2)\n    # O(n)\n    # O(n)\n    # O(n)\n\
    \    # O(n^2)\n    # O(n)\n    collisions = 0\n    cars = generate_cars(n)\n \
    \   for car1 in cars:\n        for car2 in cars:\n            if car1 != car2\
    \ and car1.speed == car2.speed and car1.position == car2.position:\n         \
    \       collisions += 1\n    return collisions\nend\n</cell>\n<code language=julia-1.0>\n\
    car_race_collision(10)\n</cell>\n<text>\nExercise: Implement the function car_collision\
    \ that finds the number of cars that have collided with the first car.  Your function\
    \ should use a single loop and should not use a nested loop.", '    collisions
    = 0', "    if n < 3 \n        n := 0\n    else if n == 3 \n        n := 1\n  \
    \  else \n        n := car_race_collision(n - 2) + car_race_collision(n - 1)\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThank you very much. Can you please\
    \ let me know if this is a right way to find the number of possible combinations\
    \ (i.e. in other words, the number of possible combinations of cars being on one\
    \ side)?\n<|/ c |>\n<| c |>\nSorry, but I fail to understand how exactly one would\
    \ go about implementing this solution, i.e. how to actually run it?  Should I\
    \ simply put everything in a function and call that function when necessary, or\
    \ is there a way to actually run these algorithms within a program?  Thank you\
    \ so much.\n<|/ c |>\n<| c |>\nThe question was \"How to find the number of possible\
    \ combinations of cars being on one side\"\n<|/ c |>\n<| c |>\nI hope that makes\
    \ sense.\n<|/ c |>\n<| c |>\nOk, this might not be what you are looking for, but\
    \ I wrote it anyway :)\n<|/ c |>\n<| a |>\nYou can count the number of possible\
    \ combinations (i.e. the count of pairs of cars) in O(n^2).\nFor each pair of\
    \ cars, you can count the number of pairs of cars whose distance from that pair\
    \ is less than or equal to the distance from any other pair of cars. In general,\
    \ we can count the number of pairs of cars whose distance from that pair is less\
    \ than or equal to the sum of distances from all other pairs of cars. \nThe above\
    \ formula can be simplified and be written as\n<code>\nC(n - 1) = C(n - 2) + C(n\
    \ - 1)\n</code>\nThe above can be rewritten as\n<code>\nC(n - 2) = C(n - 3) +\
    \ C(n - 2)\n</code>\nThen, by substituting the sum formula above, we get \n<code>\n\
    C(n - 3) = C(n - 4) + C(n - 3)\n</code>\nand so on. This gives a formula for C(n\
    \ - n) which can be easily implemented in O(n^2) time complexity.\nThe formula\
    \ for the sum can be derived as\n<code>\nC(n) = C(n-1) + C(n-2)\n</code>\nThis\
    \ can be rewritten as\n<code>\nC(n) = C(n-1) + C(n-2)\nC(n) = C(n-1) + C(n-2)\n\
    C(n) = C(n-1) + C(n-2)\nC(n) = C(n-1) + C(n-2) + C(n-1) + C(n-2)\nC(n) = C(n",
  "    collided = false\n    if n < 3 || n > 20\n        return collided\n    end\n\
    \    collided = true\n    collisions = 0\n    \n    for j in 1:n\n        i =\
    \ j + 1\n        while i < n && collided\n            collided = car_race_collision(i)\n\
    \            if collided\n                collisions += 1\n                i +=\
    \ n\n            end\n        end\n    end\n    return collisions\nend\n</cell>\n\
    <code language=julia-1.0>", "    left_right = rand(1:n-1) == 1;\n    left_cars_colliding\
    \ = 0;\n    right_cars_colliding = 0;\n    for i = 1:n\n        if left_right\
    \ \n            cars_colliding = car_race_collision(n - 1)\n            if cars_colliding\
    \ > 0\n                left_cars_colliding += cars_colliding\n            else\n\
    \                return left_cars_colliding\n            end\n        end\n  \
    \      if car_race(i) == left_cars_colliding + right_cars_colliding\n        \
    \    right_cars_colliding += 1\n        end\n    end\n    return left_cars_colliding\
    \ + right_cars_colliding\nend", "    collisions = 0\n    for j in 1:n\n      \
    \  for i in 1:n\n            if (dist(car_coord(i,1), car_coord(j,1), x) == 0)\
    \ &&\n                (dist(car_coord(i,2), car_coord(j,2), x) == 0) &&\n    \
    \            (dist(car_coord(i,3), car_coord(j,3), x) == 0)\n            collisions\
    \ += 1\n        end\n    end\n    return collisions\nend", "    if n < 2\n   \
    \     return 0 \n    else \n        collisions = 0 \n        while n >= 2 \n \
    \           collisions += 1\n            n -= 1 \n            n += 1 \n      \
    \  n -= 1 \n        n += 1 \n        while n > 1 \n            collisions += 1\n\
    \            n -= 1 \n        n -= 1 \n        return collisions\n    end\nend",
  "    if n == 0\n        return 0\n    \n    h::Int64 = 1\n    while (h < n) && car_collision_left[h]\
    \ == car_collision_right[h]\n        h += 1\n    h -= 1\n    return h + 1\nend\n\
    </cell>\n<text>\nQuestion 2.2\nWrite a function that calculates the number of\
    \ cars that collide with the left lane of any given car.  For example, if a car\
    \ has lane 0, and lane 1 has two cars in its path, then lane 0 has three cars\
    \ in its path, and lane 1 has four cars in its path.  A car is colliding with\
    \ itself is considered a collision.", "    collision_counter = 0\n    speed_1\
    \ = speed\n    speed_2 = speed\n    while speed_1 > 0 && speed_2 > 0\n       \
    \ if car_1 collide(car_2)\n            collision_counter = collision_counter +\
    \ 1\n            speed_1 = speed_1-1\n            speed_2 = speed_2-1\n      \
    \  else\n            speed_1 = speed_1-1\n            speed_2 = speed_2-1\n  \
    \  end\n    return collision_counter\nend\n\"\"\"\n    car_race_collision(10)\n\
    end", "    \"\"\"\n    Inputs:\n        - n: the number of cars to simulate, \n\
    \    Outputs:\n        - the number of cars who collide\n    \"\"\"", "    car_collisions::Int64\
    \ = 0\n    for i::Int64 in 1:n\n        if car_race_car_collision(i)\n       \
    \     car_collisions += 1\n        end\n    end\n    return car_collisions\nend",
  "    #Calculate the collision between cars 0 and n-1 \n    #(excluding the final\
    \ car)\n    #Assume that if cars 0 and n-1 collide, then they will never collide\
    \ \n    #again (in other words, cars 0 and n will never collide)\n    #Therefore,\
    \ cars 0 and n will never collide\n    #If they do collide, then cars 0 and n-1\
    \ will also collide\n    #Therefore, the collision between cars 0 and n-1 is the\
    \ number of cars 0 and n-1 \n    #that collide\n    if n < 0 \n        return\
    \ 0 \n    \n    left_to_right_collisions = 0\n    right_to_left_collisions = 0\n\
    \    \n    left_to_right_collisions = 0 \n    right_to_left_collisions = 0 \n\
    \    \n    #For each car, calculate the distance between itself and cars 0 and\
    \ n-1\n    #Then, divide each distance by the length of the segment between the\
    \ cars (in units of m)\n    #Then add these distances together to get \n    #the\
    \ number of cars 0 and n-1 that collide\n    \n    #Left cars\n    left_car_distances\
    \ = calculate_distances(0, 0)\n    left_car_distances = left_car_distances / length(left_car_distances)\n\
    \    left_car_distances = sum(left_car_distances)\n    \n    #Right cars\n   \
    \ right_car_distances = calculate_distances(n-1, n-1)\n    right_car_distances\
    \ = right_car_distances / length(right_car_distances)\n    right_car_distances\
    \ = sum(right_car_distances)\n    \n    left_to_right_collisions = left_car_distances\
    \ + right_car_distances\n    \n    \n    \n    return left_to_right_collisions"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
