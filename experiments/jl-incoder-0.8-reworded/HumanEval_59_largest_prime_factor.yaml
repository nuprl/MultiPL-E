name: HumanEval_59_largest_prime_factor
language: jl
prompt: "\"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
  \    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n\
  \    2\n    \"\"\"\nfunction largest_prime_factor(n::Int64)::Int64 \n"
tests: "using Test\n\n@testset begin\n\ncandidate = largest_prime_factor;\n\t@test(candidate(15)\
  \ == 5)\n\t@test(candidate(27) == 3)\n\t@test(candidate(63) == 7)\n\t@test(candidate(330)\
  \ == 11)\n\t@test(candidate(13195) == 29)\nend\n"
completions: ["    if n % 2 == 0 then return n \n    else return (largest_prime_factor(n/2)\
    \ + n // 2)\n</code>\n<|/ a |>\n<| c |>\nNice solution, but this would overflow\
    \ the recursion depth. Have you tried using BigInt for large numbers?\n<|/ c |>\n\
    <| a |>\nYou could use tail recursion, for example:\n<code>\nlargestPrimeFactor(n::Int64)::Int\
    \ =\n    if n < 1 then 1 else largestPrimeFactor(n-1) + 1\n</code>\nThe recursion\
    \ will go until it hits a number which divides n without a remainder.\n<|/ a tags=primes,recursion,functional-programming,ocaml,algorithm\
    \ dscore=2 |>\n<| a |>\n<code>\nlet largestPrimeFactor n =\n    let rec loop i\
    \ primes = \n        if i < n then\n            if n rem i = 1 then loop i primes\n\
    \            else largestPrimeFactor i primes\n        else\n            i;\n\
    \    loop (2::n) [] in loop n [2; 3 .. ]\n</code>\n<|/ a tags=primes,recursion,functional-programming,ocaml,algorithm\
    \ dscore=2 |>\n<| a dscore=1 tags=primes,recursion,functional-programming,ocaml,algorithm\
    \ |>\nI wrote this a while back, just in case someone else finds it useful. \n\
    <code>\nlet rec maxp n =\n  if n < 2 then n\n  else if n%2 = 0 then maxp(n/2)\
    \ \n  else if n%3 <> 0 then maxp(n/3)\n  else maxp(n/3)\n</code>\n<|/ a |>\n<|\
    \ c |>\nThis does not answer the question - it does not find the largest prime\
    \ factor of a number.\n<|/ c |>\n<| c |>\nIt should find the largest prime factor\
    \ of a number.\n<|/ c |>\n<| c |>\nIt doesn't, see OP's example in his question:\
    \ it returns 2, not 5.\n<|/ c |>\n<| c |>\n`maxp` doesn't actually find the largest\
    \ prime factor, but rather finds the largest factor of n.\n<|/ c |>\n<| c |>\n\
    Yes, I'm pretty sure it does find the largest prime factor. I just tested it for\
    \ myself.\n<|/ c |>\n<| a tags=primes,recursion,functional-programming,ocaml,algorithm\
    \ |>\nHere is my solution that works in OCaml and finds the largest prime factor\
    \ in a given number.\n<code>\n(* returns ", "    if n==1 \n        return n \n\
    \    else \n        return largest_prime_factor(sqrt(n)) \nend \n</cell>\n<code\
    \ language=julia-1.6>\nlargest_prime_factor(13195)\n</cell>\n<text>\nExercise:\
    \ Write a function primes that returns an Array{Int64, 1} of all the prime numbers\
    \ less than a particular number (n).\nExercise: Write a function composite that\
    \ returns true if the argument is a number that is a square.\nExercise: Write\
    \ a function is_prime that returns true if the argument is prime, and false otherwise.\n\
    Exercise: Write a function that finds the greatest common divisor (GCD) of two\
    \ numbers.\nExercise: Write a function that returns the greatest common divisor\
    \ of the sum of two numbers. \nExercise: Write a function that returns the smallest\
    \ prime factor of the sum of two numbers. \nExercise: Write a function that returns\
    \ the product of two numbers as a single Int64.\nExercise: Write a function that\
    \ returns the sum of the squares of two numbers. \nExercise: Write a function\
    \ that returns the sum of the products of two numbers as a single Int64.\nExercise:\
    \ Write a function that returns the sum of all numbers that are multiples of both\
    \ 5 and 7.\nExercise: Write a function that returns the sum of all numbers that\
    \ are multiples of both 5 and 7, up to and including n.\nExercise: Write a function\
    \ that returns the sum of all numbers that are multiples of either 5 or 7, up\
    \ to and including n.\nExercise: Write a function that returns the sum of all\
    \ numbers that are multiples of either 5 or 7, but not both. \nExercise: Write\
    \ a function that returns the product of all numbers that are multiples of either\
    \ 5 or 7, but not both.", "    if n < 2 \n        return n\n    if n <= 1 \n \
    \       return n\n    \n    largest = 2\n    for ps in prime_factors(n) \n   \
    \     if ps > largest\n            largest = ps \n    return largest\n</cell>\n\
    <text>\nWrite a function that checks whether a number is prime. It should take\
    \ in a positive integer and return True if n is prime and False if n is not prime.",
  "    if n < 2 then return n\n    return 2\n    \nend\n</cell>\n<code language=julia-1.6>\n\
    largest_prime_factor(1313)\n</cell>\n<text>\nExercises\nExercise 1\nThe Fibonacci\
    \ sequence $F{n}=\\begin{bmatrix}0\\ 1\\end{bmatrix}^{n-1}$ has an interesting\
    \ property: $\\text{Fibonacci}(n)=\\begin{bmatrix}0\\ 1\\end{bmatrix}^{n-2}+\\\
    begin{bmatrix}1\\ 0\\end{bmatrix}^{n-1}$. Therefore, the next few exercises will\
    \ verify this property.", "    if n <= 1\n        return 1\n    return largest_prime_factor(n\
    \ / 2) if n % 2 == 0 else 2 * largest_prime_factor(n / 2)\nend", "    # O(1)\n\
    \    if n<2:\n        return n\n    if n==2:\n        return 1\n    # O(log log\
    \ n)\n    if n % 2 == 0:\n        return largest_prime_factor(n / 2)\n    # O(n)\n\
    \    factors = []\n    i = 3\n    while i <= n:\n        if n % i == 0:\n    \
    \        factors.append(i)\n            n = n // i\n        else:\n          \
    \  i += 2\n    if n == 1:\n        factors.append(n)\n    return max(factors)",
  "    if n == 1\n        return n\n    factors = factor(n) |> List.filter (fun e\
    \ -> e > 1)\n    if List.null? factors\n        n\n    else\n        list_reduce(factor,\
    \ factors, maximum)\n    end\nend\n</cell>\n<code language=julia-1.3>", "    if\
    \ n == 0 \n        0\n    elseif n == 1 \n        n\n    elseif n % 2 == 0 \n\
    \        largest_prime_factor(n / 2)\n    else\n        if smallest_prime_factor(n)\
    \ == 1\n            2\n        else\n            if n >= 3\n                smallest_prime_factor(n\
    \ / 2)\n            else\n                largest_prime_factor(n / 2)\nend\n</code>\n\
    <|/ a dscore=1 tags=function,primes,julia,math,performance |>\n<| a dscore=0 tags=function,primes,julia,math,performance\
    \ |>\n<code>", "    if (n <= 1) \n        1\n    else\n        if ((n % 2) ==\
    \ 0) \n            largest_prime_factor(n / 2)\n        else\n            if ((n\
    \ % 3) == 0) \n                largest_prime_factor(n / 3)\n            else\n\
    \                if ((n % 5) == 0) \n                    largest_prime_factor(n\
    \ / 5)\n                else \n                    if ((n % 7) == 0) \n      \
    \                  largest_prime_factor(n / 7)\n                    else \n  \
    \                      if ((n % 11) == 0) \n                            largest_prime_factor(n\
    \ / 11)\n                        else\n                            if ((n % 13)\
    \ == 0) \n                                largest_prime_factor(n / 13)\n     \
    \                       else\n                                if ((n % 17) ==\
    \ 0) \n                                    largest_prime_factor(n / 17)\n    \
    \                            else\n                                    largest_prime_factor(n\
    \ / 17)\n</code>\n<|/ a dscore=5 |>\n<| c |>\n`largest_prime_factor` is extremely\
    \ inefficient. Even for a small number it will take O(n) to calculate the factors.\n\
    <|/ c |>\n<| c |>\nThis implementation is correct, it just doesn't return prime\
    \ factors.\n<|/ c |>\n<| c |>\nHow about this: \n`function largest_prime_factor(n::Int64)::Int64\
    \ \n    if (n <= 1) \n        1\n    else\n        if ((n % 2) == 0) \n      \
    \      largest_prime_factor(n / 2)\n        else\n            if ((n % 3) == 0)\
    \ \n                largest_prime_factor(n / 3)\n            else\n          \
    \      if ((n % 5) == 0) \n                    largest_prime_factor(n / 5)\n \
    \               else \n                    if ((n % 7) == 0) \n              \
    \          largest_prime_factor(n / 7)\n                    else \n          \
    \              if ((n % 11) == 0) \n                            largest_prime_factor(n\
    \ / 11)\n                        else\n                            if ((n % 13)\
    \ == 0) \n                                largest_prime_factor(n / 13)\n     \
    \                       else\n                                if ((n % 17) ==\
    \ 0) \n                                    largest_prime_factor(n / 17)\n    \
    \                            else\n                                    largest_prime_factor(n\
    \ / 17)\nend`\n<|/ c |>\n<| c |>\nYou mean this one? `largest_prime_factor(n::Int64)::Int64\n\
    \    if (n <= 1) \n        1\n    else\n        if ((n % 2) == 0) \n         \
    \   largest_prime_factor(n / 2)\n        else\n            if ((n % 3) == 0) \n\
    \                largest_prime_factor(n / 3)\n            else\n             \
    \   if ((n % 5) == 0) \n                    largest_prime_factor(n / 5)\n    \
    \            else \n                    if ((n % 7", "    if n < 2 then return\
    \ n\n    var max_factor :: Int64 = \n        if isPrime(n) then 1\n        else\
    \ n % largest_prime_factor(quot(n,2))\n    i :: Int64 = 1\n    while (i <= max_factor)\
    \ \n        i :: Int64 = i * 2\n    while (i < n) \n        if isPrime(i) then\
    \ max_factor := i\n        i :: Int64 = i + 1\n    max_factor\nend", "    \n \
    \   if n <= 1 \n        \n        return n\n    elseif n % 2 != 0 \n        \n\
    \        return largest_prime_factor(n/2)\n    elseif n % 3 == 0 \n        \n\
    \        return largest_prime_factor(n/3)\n    else\n        \n        if n %\
    \ 5 == 0 \n        \n            return largest_prime_factor(n/5)\n        else\n\
    \            \n            return largest_prime_factor(3*n+2)\n    \nend", " \
    \   if n == 1 \n        1\n    else if n % 2 == 0\n        largest_prime_factor(n/2)\n\
    \    else \n        largest_prime_factor(3*n+1)\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\nlargest_prime_factor(542)\n</cell>\n<text>\nExercise 2.2\n\
    For small numbers, use trial division. Try to come up with a formula for $n!$.",
  "    if (n == 1) \n        1 \n    else\n        let n2 = n * n \n        if n2\
    \ > n \n            n \n        else \n            if (n2 % n == 0) \n       \
    \         n2 / n \n            else \n                largest_prime_factor(n2)\
    \ \n        end\nend\n</cell>\n<code language=julia-1.5>\n@time largest_prime_factor(100);\n\
    </cell>\n<text>\nWrite a function prime_factors that takes in a list of numbers\
    \ and returns the prime factors in that list. You may assume that all elements\
    \ of the input list are non-negative integers.", "    if n<2 return 1\n    x :=\
    \ n\n    i := 2\n    while i*i<=x do\n        if x%i==0 return i\n        i :=\
    \ i+1\n    return x \n</code>\n<|/ a tags=python,functional-programming,primes\
    \ |>\n<| c |>\nA bit too slow. Also it seems you don't take into account the fact\
    \ that 2 is the only even prime number.\n<|/ c |>\n<| c |>\nNope, it's fast. Test\
    \ for yourself: http://ideone.com/NtKxGk\n<|/ c |>\n<| c |>\nI did this in C and\
    \ it took me about 5 seconds for 13195 and about 2 seconds for 2048. I checked\
    \ in Python (2.7) and found it about 5 seconds faster. The difference is still\
    \ small though. :)\n<|/ c |>\n<| c |>\nSorry to bother you. I found an online\
    \ compiler that gave me this result: http://ideone.com/mBj5yH and it said it was\
    \ too slow for my purposes.\n<|/ c |>\n<| c |>\nThanks for the input. I updated\
    \ my post to include a function that returns prime factors.\n<|/ c |>\n<| a tags=python,functional-programming,primes\
    \ |>\nThe easiest way to find out if n is a prime is to check whether it can be\
    \ divided by all prime numbers from 2 to sqrt(n). To implement that, you can use\
    \ the Sieve of Eratosthenes. It's straightforward to implement in Python:\n<code>\n\
    import math\ndef isprime(n):\n    # http://en.wikipedia.org/wiki/Primality_test#Deterministic_tests\n\
    \    if n < 2:\n        return False\n    if n == 2:\n        return True\n  \
    \  if n == 3:\n        return True\n    if n % 2 == 0:\n        return False\n\
    \    i = 5\n    while i * i <= n:\n        if n % i == 0:\n            return\
    \ False\n        i += 6\n    return True", "    if n == 1 \n        1\n    else\
    \ \n        max_factor = 1\n        for factor in prime_factors(n) \n        \
    \    if factor > max_factor \n                max_factor = factor \n        return\
    \ max_factor", "    \n    if n==2 || n==3\n        return n\n    \n    i=2\n \
    \   fac=1\n    while i<n && fac*(i+1)<=n\n        fac*=i\n        i+=1\n    end\n\
    \    return fac\nend\n</cell>\n<code language=julia-0.6>\n@time largest_prime_factor(13195)\n\
    </cell>\n<code language=julia-0.6>\n@time largest_prime_factor(2048)\n</cell>\n\
    <text>\nThe Sieve of Atkin: Sieve of Eratosthenes is an algorithm to compute all\
    \ primes up to $2^{\\sqrt{n}}$, where $n$ is the number of numbers up to which\
    \ you wish to check whether they are prime. It is based on the fact that the prime\
    \ numbers are all positive integers other than 2 and 3, and all prime numbers\
    \ except 2 and 3 are of the form 6n\xB11. The following code implements the Sieve\
    \ of Atkin, and also implements a function to check if a number is prime.", " \
    \   if n < 2\n        1\n    else\n        largest_prime_factor(n / 2)\n     \
    \   if n % 2 == 0\n            largest_prime_factor(n / 2)\n        end\n    end\n\
    end\n</cell>\n<code language=julia-1.0>\n@show largest_prime_factor(13195)\n@show\
    \ largest_prime_factor(2048)\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ tests if a given number is prime. Test with both 5 and a larger number to exercise\
    \ all cases.", "    if n==1 then 1\n    else largest_prime_factor(sqrt(n)) * (n/largest_prime_factor(sqrt(n)))\n\
    end\n</code>\n<|/ a dscore=1 tags=julia,math,primes |>\n<| c |>\nNote that this\
    \ approach will blow up for large numbers, since all primes will need to be evaluated\
    \ up to sqrt(n).\n<|/ c |>\n<| a tags=julia,math,primes dscore=1 |>\nI came up\
    \ with this code based on a similar algorithm to find the first n prime numbers\
    \ and it seems pretty efficient to me:\n<code>", "    if isPrime(n) == false then\n\
    \        return n\n    \n    var i:Int64 = 1\n    var max_prime:Int64 = n", " \
    \   if n == 1 \n        then return n\n    else if n % 2 == 0 \n        then return\
    \ largest_prime_factor(n/2)\n    else if n % 3 != 0 \n        then return largest_prime_factor(3*n)\n\
    \    else \n        return largest_prime_factor((3*n)-2)\n    end\nend\n</cell>\n\
    <code language=julia-1.0>\nlargest_prime_factor(139)\n</cell>\n<code language=julia-1.0>",
  "    if n <= 2 \n        then return n \n    elseif n % 2 == 1 \n        then return\
    \ largest_prime_factor(n/2) \n    else\n        let m = (n-1) >> 1 \n        if\
    \ m == 0 \n            then return n \n        elseif n % m == 0 \n          \
    \  then return largest_prime_factor(m) * largest_prime_factor(n/m) \n        else\
    \ \n            return largest_prime_factor(m) \nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=python,primes |>\nIt seems that there is a bug in your code -\
    \ you're doing wrong calculations. To find biggest prime factors we shall use\
    \ following algorithm:\n<code>\ndef largest_prime_factor(n): \n    if n == 1:\
    \ \n        return 1 \n    else: \n        prime_number = 3 \n        counter\
    \ = 3 \n        while counter < n//prime_number: \n            if n % prime_number\
    \ == 0: \n                counter = counter + (n//prime_number) \n           \
    \ else: \n                counter += 2 \n                if counter == n: \n \
    \                   return counter \n                else: \n                \
    \    prime_number += 1 \n    return n \n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    This is almost certainly the worst way to implement the algorithm, since it's\
    \ quadratic time. Even if you remove the quadratic time complexity, you still\
    \ have to check every number to find out the highest prime factor, so it's a O(n^2)\
    \ algorithm, which could take even longer. Also, your algorithm doesn't handle\
    \ even numbers correctly.\n<|/ c |>\n<| c |>\nYes, your algorithm is correct.\
    \ However, this algorithm is also a linear algorithm, so I think it is OK to keep\
    \ it.\n<|/ c |>\n<| a tags=python,primes |>\nThe simplest and most efficient algorithm\
    \ to find the largest prime factor of a number is the Sieve of Eratosthenes (link\
    \ to Wikipedia). You have to store the prime factors as they are discovered. \n\
    <code>\ndef primeFactors(n): \n    factors = [] \n    number = 2 \n    while n\
    \ > 1: \n        while number < n: \n            number = 2 * number \n      \
    \      if number > n: \n                break \n        factors.append(number)\
    \ \n        n-=number \n    return factors", "    if n <= 1 \n        1\n    else\n\
    \        n%2==0 ? largest_prime_factor(n/2) : largest_prime_factor(3*n+1)\n  \
    \  end\nend", "    if n == 2 \n        1 \n    else if n % 2 == 0 \n        n\
    \ \n    else \n        largest_prime_factor(n/2) * 3\nend\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nWhile this code may answer the question, providing additional context\
    \ regarding why and/or how this code answers the question improves its long-term\
    \ value.\n<|/ c |>\n<| c |>\nWelcome to Stack Overflow! While this code snippet\
    \ may solve the question, [including an explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion. Please also try not to crowd your code with\
    \ explanatory comments, this reduces the readability of both the code and the\
    \ explanations!\n<|/ c |>\n<| a tags=primes,julia,algorithm |>\nThe most efficient\
    \ way I found was to use the sieve of Eratosthenes algorithm (https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes).\
    \ The basic idea is that you store all the numbers that you are going to test\
    \ as being prime and that you are going to test only those numbers already stored.\n\
    The python code looks something like this:\n<code>\ndef checkPrime(n):\n    l\
    \ = 2\n    while l < math.sqrt(n):\n        if n%l == 0:\n            return False\n\
    \        l += 1\n    return True", "    if n == 0 \n        then return 1\n  \
    \  else \n        primes! <- factor(n) \n        max_prime <- primes[length(primes)]\
    \ \n        repeat \n            max_prime <- max_prime / 2 \n        until max_prime\
    \ > n \n        return max_prime \n    end\nend\n</cell>\n<code language=julia-0.6>\n\
    largest_prime_factor(13195)\n</cell>\n<text>\nLet's now write a function that\
    \ returns the smallest prime factor of n. Assume n > 1 and is not a prime.\n$$\n\
    \\begin{align}\n    f_n(a) &= a\\left{\\begin{array}{c} 1 \\ a^{n-1} \\ a^{n-2}\
    \ \\ \\ldots \\ a^{2k} \\end{array}\\right.\n\\end{align}\n$$", "    if n <= 1\n\
    \        error \"n must be > 1\"\n    end\n    \n    if n % 2 == 0\n        largest_prime_factor(n\
    \ / 2)\n    else\n        largest_prime_factor(3*n+2)\n    end\nend\n</cell>\n\
    <code language=julia-1.0>\n@time largest_prime_factor(1000000000*1000000000*1000000000)\n\
    </cell>\n<text>\nPutting it all together\nHere we will combine what we have learned\
    \ from previous chapters to solve the problems we face in real life as well as\
    \ to understand the concepts of Julia. Our goal is to implement the function largest_prime_factor()\
    \ so that we do not have to worry about premature optimization. We are also going\
    \ to use Julia's built-in tools to perform the computation.", "    if n <= 1 {\n\
    \        return n\n    }\n    let max_p = 2\n    for i in 2..n-1 {\n        if\
    \ n mod i == 0 {\n            let p = i / max_p\n            loop {\n        \
    \        if n % (p * p) == 0 {\n                    return p\n               \
    \ }\n                if p > max_p {\n                    max_p = p\n         \
    \       }\n                p = p + 2\n            }\n        }\n    }\n    return\
    \ max_p\nend\n</cell>\n<text>\nTest your Code", "    if n == 1 \n        1\n \
    \   else\n        for p in PrimeFactors(n)\n            if  p > 1\n          \
    \      if  n `mod` p == 0 \n                    smaller_p\n                else\n\
    \                    smaller_p = p\n                break\n        end\n    end\n\
    end\n</cell>\n<code language=julia-0.6>\n@time largest_prime_factor(20000000)\n\
    </cell>\n<text>\n5.4 Factorization\nExercise: Write a function that factors integers.\
    \ You may want to reuse some code you wrote for 5.3. A complete function should\
    \ take an input n and return the list of factors, including a list containing\
    \ the number itself.", "    if n <= 1 \n        then return n\n    else \n   \
    \     return largest_prime_factor(n - 1) \nend\n</cell>\n<code language=julia-1.4>\n\
    largest_prime_factor(10^8)\n</cell>\n<text>\nTests\nWhat is the largest prime\
    \ factor of the number 1?", "    \n    \"\"\"\n    \n    We use the Miller-Rabin\
    \ test (Miller 1981) to test for the primality of a number.\n    Here we use a\
    \ random value p > 1 as the probability of being composite (p-1) is:\n    \n \
    \   p^k*(1-p)^k = 1-p^k\n    \n    Using this formula, a number is said to be\
    \ composite if and only if both p and \n    (p-1) have some non-trivial factors.\n\
    \    \n    Here we use the random generator to select a random non-trivial factor\
    \ of n \n    and compare it to the other prime factors p.\n    \n    \"\"\"\n\
    \    \n    \n    \n    if n < 2:\n        return n\n    else:\n        for prime\
    \ in primes():\n            while n % prime == 0:\n                n /= prime\n\
    \                if n == 1:\n                    return prime\n    \n    raise\
    \ Exception\n    \n</cell>\n<text>\nThe Miller-Rabin test", "    if n==1\n   \
    \     1\n    else\n        let p=2\n        while p*p<=n \n            do \n \
    \               let q=(p*p)\n                while (q*q)<=n\n                \
    \    do \n                        let r=q/2\n                        while r%p==0\n\
    \                            do \n                                let p=p+1\n\
    \                                q=q+1\n                        r=r+1\n      \
    \          let p=p+1\n        largest_prime_factor(p)\n    end\nend\n</cell>\n\
    <code language=julia-1.0>\nlargest_prime_factor(2::Int64)\n</cell>\n<text>\nExercise\
    \ (optional)\nImplement a function that counts the number of prime factors of\
    \ n and returns the result in a variable named p.\nThe function should only use\
    \ while loops.", "    if n == 0 \n        then return 1\n    else if is_prime(n)\
    \ \n        then return n\n    else return largest_prime_factor(predecessor(n))\n\
    end", "    if n < 2\n        return n\n    fib_fib_primes_sieve(1)\n    for p\
    \ in fib_fib_primes_sieve(n-1)\n        if n % p == 1\n            return p\n\
    \    return n\nend\n</cell>\n<text>\nExercise: Write a function that accepts an\
    \ array of numbers as input and return an array of their prime factors (not counting\
    \ the numbers itself).", "    if n < 2\n        return n\n    else \n        if\
    \ n == 2 \n            return 1\n        elif n % 2 == 0\n            return n\n\
    \        else\n            factor = 2\n            while (factor <= n)\n     \
    \       do \n                factor = factor * 2\n                while factor\
    \ <= n \n                    do\n                        factor = factor * 2\n\
    \                    done\n            done\n            return factor\n     \
    \   end\n    end\nend\n</cell>\n<text>\nA more concise way to implement the algorithm\
    \ is to write a recursive function.  A recursive function calls itself (more on\
    \ recursion) until a base case is reached.  For example, let's write a function\
    \ that returns the factorial of n which is defined recursively as follows:", " \
    \   if n < 2\n        2\n    else\n        let max_factor::Int64 = prime_factors(n)[-1]\n\
    \        if max_factor < n\n            max_factor\n        else\n           \
    \ let i::Int64 = n - max_factor\n            largest_prime_factor(i)\n       \
    \ end\nend\n</cell>\n<code language=julia-1.4>", "    n >= 2 && return n / largest_prime_factor(floor(sqrt(n)))\n\
    </code>\n<|/ a dscore=1 |>\n<| a |>\nWe can use the following solution. \nThe\
    \ idea is to use the recursive function which checks if a given number is prime\
    \ or not. Once we have determined whether a given number is prime or not, we can\
    \ call this function to find its largest prime factor.\nWe begin by passing the\
    \ number to the function is_prime(number). \nThe function checks if a given number\
    \ is prime or not by checking if all factors are smaller than the given number.\n\
    If all factors are greater than or equal to the given number, then it returns\
    \ true. Else it returns false.\nIf we have determined that the given number is\
    \ prime, we can now call is_prime_fac(n-1) which would return the largest prime\
    \ factor of n. \n<code>", "    if n <= 1 \n        error(\"n must be > 1 and >\
    \ 2 but it is \" .. n)\n    end\n    if n <= 3\n        return n\n    end\n  \
    \  d = 2\n    while d <= sqrt(n)\n        d, i = div(n, d)\n        if d == 1\
    \ \n            return i\n        end\n    end\n    return n\nend\n</cell>\n<code\
    \ language=julia-0.5>\n@show largest_prime_factor(1000)\n</cell>\n<text>\nThe\
    \ next function computes the product of a list of numbers. Since it's only a couple\
    \ of lines, we can define a custom function instead.", "    if n <= 1 \n     \
    \   then 1\n    else if prime_numbers(n)\n        then n\n        else largest_prime_factor(n-1)\
    \ * prime_numbers(n-1)\nend\n</cell>\n<code language=julia-1.1>", "    if n <=\
    \ 2 \n        return n\n    p :: Int64 = 2\n    while p < n\n        if n % p\
    \ == 0 \n            return p\n        p += 1\n    return n", "    largest_factor::Int64\
    \ = 1\n    for prime in prime_factors_generator(n):\n        if prime > largest_factor\n\
    \            largest_factor = prime\n    return largest_factor", "    if isPrime(n)\n\
    \        \n        if n==1\n            return 1\n        else\n            return\
    \ n\n    \n    if isPrime(n-1)\n        \n        if n==1\n            return\
    \ 2\n        else\n            return (n-1)\n    \n    if isPrime(n-2)\n     \
    \   \n        if n==1\n            return 3\n        else\n            return\
    \ (n-2)\n    \n    if isPrime(n-3)\n        \n        if n==1\n            return\
    \ 4\n        else\n            return (n-3)\n    \n    if isPrime(n-4)\n     \
    \   \n        if n==1\n            return 5\n        else\n            return\
    \ (n-4)\n    \n    if isPrime(n-5)\n        \n        if n==1\n            return\
    \ 6\n        else\n            return (n-5)\n    \n    if isPrime(n-6)\n     \
    \   \n        if n==1\n            return 7\n        else\n            return\
    \ (n-6)\n    \n    if isPrime(n-7)\n        \n        if n==1\n            return\
    \ 8\n        else\n            return (n-7)\n    \n    if isPrime(n-8)\n     \
    \   \n        if n==1\n            return 9\n        else\n            return\
    \ (n-8)\n    \n    if isPrime(n-9)\n        \n        if n==1\n            return\
    \ 10\n        else\n            return (n-9)\n    \n    if isPrime(n-10)\n   \
    \     \n        if n==1\n            return 11\n        else\n            return\
    \ (n-10)\n    \n    if isPrime(n-11)\n        \n        if n==1\n            return\
    \ 12\n        else\n            return (n-11)\n    \n    if isPrime(n-12)\n  \
    \      \n        if n==1\n            return 13\n        else\n            return\
    \ (n-12)\n    \n    if isPrime(n-13)\n        \n        if n==1\n            return\
    \ 14\n        else\n            return (n-13)\n    \n    if isPrime(n-14)\n  \
    \      \n        if n==1\n            return 15\n        else\n            return\
    \ (n-14)\n    \n    if isPrime(n-15)\n        \n        if n==1\n            return\
    \ 16\n        else\n            return (n-15)\n    \n    if isPrime(n-16)\n  \
    \      \n        if n==1\n            return 17\n        else\n            return\
    \ (n-16)\n    \n    if isPrime(n-17)\n        \n        if n==1\n            return\
    \ 18\n        else\n            return (n-17)\n    \n    if isPrime(n-18)\n  \
    \      \n        if n==1\n            return 19\n        else\n            return\
    \ (n-18)\n    \n    if isPrime(n", "    if n == 0\n        return 0\n    if n\
    \ > 1\n        a = largest_prime_factor(n/2)\n        if n % a == 0\n        \
    \    return a\n    return n", "    if n < 2 then return 1\n    \n    if primes(n)\
    \ == [2] then return 2\n    \n    largest = 1\n    for i in 2..n-1 do \n     \
    \   if primes(i) == [] then continue\n        if primes(i) > [] then continue\n\
    \        \n        if largest == 1 then largest = i\n        else\n          \
    \  if largest < i then largest = i\n    \n    return largest", "    if n == 1\n\
    \        0\n    else\n        m <- largest_prime_factor(n/2)\n        if m > n\n\
    \            m\n        else\n            m\n        end\n    end\nend\n</cell>\n\
    <code language=julia-1.0>\n\"\"\"Return the smallest prime factor of n. Assume\
    \ n > 1 and is not a prime.\n    >>> smallest_prime_factor(13195)\n    3\n   \
    \ >>> smallest_prime_factor(2048)\n    3\n    \"\"\"", "    if n % 2 == 0\n  \
    \      return n\n    \n    let i = 3\n    let j = 2\n    \n    while j * j <=\
    \ n\n        do if n % j == 0\n            then return j\n            else\n \
    \               let new_i = i + 2\n                while new_i * j <= n\n    \
    \                do j = new_i\n                let new_i = i - 1\n           \
    \     while new_i * j <= n\n                    do j = new_i\n        i = i +\
    \ 1\n    return j\nend", "    if n < 3 then\n        n\n    else\n        largest\
    \ = n\n        for i = 3 to n do\n            largest = i * largest\n        end\n\
    \        largest\n    end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nHmm - this\
    \ is great, thank you. I don't really know anything about julia syntax though,\
    \ can you help me understand this a bit better? Where is the largest prime factor\
    \ of 13195 coming from ? and how does that fit into the code you wrote ?\n<|/\
    \ c |>\n<| c |>\nWhat I mean is - I know this function is working but I don't\
    \ understand why it works. And if that means I understand this correctly then\
    \ the answer is  that it is because we get the largest prime factor from 3 to\
    \ n and then multiply them together. Is this correct ?\n<|/ c |>\n<| c |>\nThe\
    \ answer is correct - this function is working but you are right about the algorithm\
    \ - it uses trial division.\n<|/ c |>\n<| c |>\nI see, thank you. I'm learning\
    \ Julia and I thought it would be interesting to see how this code could be written\
    \ in Julia.\n<|/ c |>\n<| a dscore=1 tags=julia |>\nThis was inspired by Eliot's\
    \ answer. In Julia this is as simple as:\n<code>\njulia> primes = [2,3,5,7,11]\n\
    3-element Vector{Int64}:\n 2\n 3\n 11", '    return max(prime_factors(n), key
    = fun(x -> length(x)-1))', "    if n==1 \n        1 \n    else \n        let d=(n-1)//2\
    \ \n        if prime_factors(d)==1 \n            d \n        else \n         \
    \   largest_prime_factor(d)\n    end\nend\n</cell>\n<code language=julia-1.6>\n\
    largest_prime_factor(2::Int64)\n</cell>\n<code language=julia-1.6>\nlargest_prime_factor(7::Int64)\n\
    </cell>\n<code language=julia-1.6>\nlargest_prime_factor(10::Int64)\n</cell>\n\
    <code language=julia-1.6>\nlargest_prime_factor(12::Int64)\n</cell>\n<code language=julia-1.6>\n\
    largest_prime_factor(13::Int64)\n</cell>\n<code language=julia-1.6>\nlargest_prime_factor(14::Int64)\n\
    </cell>\n<code language=julia-1.6>\nlargest_prime_factor(15::Int64)\n</cell>\n\
    <code language=julia-1.6>\nlargest_prime_factor(16::Int64)\n</cell>\n<code language=julia-1.6>\n\
    largest_prime_factor(17::Int64)\n</cell>\n<code language=julia-1.6>\nlargest_prime_factor(19::Int64)\n\
    </cell>\n<code language=julia-1.6>\nlargest_prime_factor(20::Int64)\n</cell>\n\
    <text>\nRemark: Julia has a built-in function primes? that checks whether a given\
    \ number is prime:", "    if n < 2\n        throw(DomainError())\n    end\n  \
    \  largest = 1\n    largest = 2\n    while isPrime(n)\n        if largest > n\n\
    \            largest = n\n        elseif n > largest * largest\n            largest\
    \ = n\n        end\n        n *= 2\n    end\n    return largest\nend\n</cell>\n\
    <text>\nWe can use this to find the largest prime factor of a number:", "    if\
    \ n < 4 then return 1\n    if n <= 1 then return 1\n    \n    factor::Int64 =\
    \ 1\n    for prime in prime_divisors(n) do \n        if prime > factor then factor\
    \ = prime\n    \n    return factor", "    if n==2 return 1\n    if n<2 return\
    \ 0\n    if factors(n) == [1] return n\n    else if factors(n)==[2,3] return largest_prime_factor(sqrt(n))\n\
    \    else return largest_prime_factor(n//2)\nend\n</cell>\n<code language=julia-1.5>",
  "    if n < 2\n        return n\n    else if isqrt(n) == n\n        return n \n\
    \    else \n        return largest_prime_factor(n//2::Int64) \nend", "    prime_numbers\
    \ = prime_generator_range(n, 2)\n    prime_factors = prime_factors(prime_numbers)\n\
    \    return max(prime_factors)\nend\n</cell>\n<code language=julia-1.1>\nlargest_prime_factor(13195)\n\
    </cell>\n<code language=julia-1.1>", "    \"\"\"Return the largest prime factor\
    \ of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n\
    \    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"", "    largest\
    \ = 2\n    while n > largest \n        largest = lcm(largest, n)\n    return largest\n\
    end", "    for i in 2..sqrt_of_n(n) do \n        if n % i == 0 then \n       \
    \     return i \n    return n \nend\n</cell>\n<code language=julia-1.0>\nlargest_prime_factor(2468)\n\
    </cell>\n<text>\nExercise 3", "    if n == 0\n        error(\"n cannot be 0\"\
    ) \n    end\n    largest = 1\n    for i in 2 to sqrt(n)\n        if n % i == 0\n\
    \            largest = i\n            break\n        end\n    end\n    if largest\
    \ * largest > n\n        error(\"n is composite\") \n    end\n    return largest\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI thought about this but I was afraid\
    \ of looping\n<|/ c |>\n<| c |>\nthe problem is with the input for largest_prime_factor(n::Int64)::Int64\
    \ n is Int not Int64\n<|/ c |>\n<| c |>\nThe function already takes Int64 types\
    \ as input. Just type `n::Int64` into the REPL.\n<|/ c |>\n<| a |>\nA brute force\
    \ method which would take a very long time.\n<code>", "    \n    # your code here\n\
    \    \n    if n < 2 : return 1\n    \n    i = 2\n    while i <= n : \n       \
    \ if n % i == 0 :\n            if isprime(i) : return i \n            i += 1 \n\
    \        else : \n            i += 1\n    return i\n</cell>\n<code language=julia-1.3>\n\
    largest_prime_factor(13195)\n</cell>\n<code language=julia-1.3>\nlargest_prime_factor(2048)\n\
    </cell>\n<text>\nProblem 4", "    if n % 2 == 0 then return 2\n    else \n   \
    \     largest = i\n        for p in (3,5,7,11,13,17,19,23,29,31) do \n       \
    \     if n%p == 0 then\n                if p > largest then largest = p\n    \
    \    end\n        return largest\n    end\nend\n</cell>\n<text>\nExercise 2: Write\
    \ a Julia function that generates all prime factors of a number in a vector.",
  "    if n < 2 \n        return n\n    elif n < 3 \n        return n\n    else \n\
    \        return largest_prime_factor(n-1) // largest_prime_factor(n-2) \n    end\n\
    end\n</cell>\n<code language=julia-1.4>\n@time largest_prime_factor(10000);\n\
    @time largest_prime_factor(100000);\n@time largest_prime_factor(1000000);\n@time\
    \ largest_prime_factor(10000000);\n@time largest_prime_factor(100000000);\n</cell>\n\
    <text>\nExercise 2:\nUse @code_native to write a native Julia function that can\
    \ find the greatest prime factor of a number.", "    if n == 0 then return 1 \n\
    \    else if n == 1 then return n \n    else if n % 2 == 0 then return largest_prime_factor(n/2)\
    \ \n    else if n % 3 == 0 then return largest_prime_factor(n/3) \n    else if\
    \ n % 5 == 0 then return largest_prime_factor(n/5) \n    else return n \nend\n\
    </cell>\n<code language=julia-1.3>\nlargest_prime_factor(25)\n</cell>\n<text>\n\
    Exercise 2: Finding the Prime Factors of an Integer\nWrite a function prime_factors(n)\
    \ that returns a list of prime factors of n.", "    for i = 2::Int64 in 2..Int.sqrt(n)\n\
    \        if n % i == 0\n            largest = n\n            n /= i\n        else\n\
    \            break\n    end\n    return largest\nend", "    if n < 2:\n      \
    \  1\n    else if n % 2 == 0:\n        largest_prime_factor(n / 2)\n    else:\n\
    \        largest_prime_factor(3 * n + 1)\nend\n</cell>\n<code language=julia-0.6>\n\
    @time largest_prime_factor(100)\n</cell>\n<text>\nThe factors we got are a little\
    \ bit smaller than what we expected.", "    if n < 2 \n    then return 2\n   \
    \ else if n < 4 \n    then return n\n    else if n % 2 == 0\n    then return n\n\
    \    else \n        p := 2\n        s := 3\n        while s <= n/2\n        do\
    \ \n            p := (p + s)/2\n            s := 2 * s\n            if n % p ==\
    \ 0\n            then return p\n        end\n        return n\nend\n</cell>\n\
    <code language=julia-1.3>\n@time largest_prime_factor(50)\n</cell>\n<text>\nProblem\
    \ 7\nLet's verify that our code is correct. We'll generate primes, and then use\
    \ them to find factors. Verify that your code returns the correct value for any\
    \ given number.", "    if n<2\n        throw(DomainError(\"\"\"n is a prime number\"\
    \"\"))\n    if n == 1\n        throw(DomainError(\"\"\"n is a prime number\"\"\
    \"))\n    if n == 2\n        throw(DomainError(\"\"\"n is a prime number\"\"\"\
    ))\n    if n % 2 == 0\n        throw(DomainError(\"\"\"n is a prime number\"\"\
    \"))\n    p :: Int64 = 1\n    while p < n\n        p = p*(p+1)//2\n    return\
    \ p\nend\n</cell>\n<code language=julia-1.3>", "    if isPrime(n) == False \n\
    \        return n \n    \n    candidates = primeFactors(n) \n    \n    largest\
    \ = candidates[length(candidates)-1] \n    \n    for prime in candidates \n  \
    \      if prime > largest \n            largest = prime \n            \n    return\
    \ largest \nend\n</cell>\n<code language=julia-0.5>", "    if n < 1 \n       \
    \ error(\"n must be greater than 1\")\n    else if n % 2 == 0 \n        error(\"\
    n must be odd\")\n    elseif n % 3 == 0 \n        error(\"n must be divisible\
    \ by 3\")\n    elseif n % 5 == 0 \n        error(\"n must be divisible by 5\"\
    )\n    else\n        for factor in [2, 3, 4, 5]\n            if n % factor ==\
    \ 0\n                n /= factor\n                break\n    return n\n</code>\n\
    <|/ a tags=primes,haskell,factors |>\n<| a tags=primes,haskell,factors |>\nThis\
    \ is more a comment than an answer but I do not have enough reputation to add\
    \ comments yet.\nYour code returns False positives. You assume that any number\
    \ n that is divisible by 2 or 3 has a prime factor.\nBut this is only true for\
    \ numbers that are divisible by 4 and 5. \nThere are many numbers that are divisible\
    \ by both 2 and 3 and they are not prime numbers.\nFor example 1434 is not divisible\
    \ by 3 but is divisible by 5 and 4 so it is not a prime number.\n<|/ a dscore=3\
    \ |>\n<| c |>\nYour first sentence is wrong. As you stated, a number is not divisible\
    \ by 2, 3 or 5 is prime.\n<|/ c |>\n<| c |>\nAh, that makes a lot of sense. Thank\
    \ you. I didn't realize that even numbers were not primes.\n<|/ c |>\n<| a tags=primes,haskell,factors\
    \ |>\nThis is my simple functional approach. I'm sure it can be optimized, but\
    \ since I'm a beginner I just used a naive approach. \n<code>\nimport Data.List",
  "    if n == 0\n        0\n    else\n        largest_prime_factor(n - 1)\n    end\n\
    end", "if isPrime(n) then\n    return n\nelse\n    m <- largest_prime_factor(floor(n/2))\n\
    \    if isPrime(m) then\n        return m\n    else\n        return n\nend\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThis seems like a great solution, but I believe `isPrime`\
    \ would be more accurately named `isPrimeSquared`.\n<|/ c |>\n<| a tags=primes,julia,factors,performance\
    \ |>\n<code>", "    if n < 2 || n % 2 == 1\n        return n\n    \n    # check\
    \ upto n = floor(sqrt(n))\n    for d in range(3, floor(sqrt(n))+1, 2)\n      \
    \  if n % d == 0\n            return n\n        \n    # check upto n = ceil(sqrt(n))\n\
    \    for d in range(3, ceil(sqrt(n))-1, 2)\n        if n % d == 0\n          \
    \  return n\n        \n    # check  upto n = sqrt(n) \n    for d in range(3, round(sqrt(n))+1,\
    \ 2)\n        if n % d == 0\n            return n\n    end\nend", "    if (n==1\
    \ || n==2)\n        return n\n    p :: Int64 = 2\n    while p*p <= n\n       \
    \ p :: Int64 = p*p\n    end\n    return p\nend", "    if n < 2 || n % 2 == 0 \n\
    \        then return 2\n    else if n % 3 == 0 \n        then return 3\n    else\
    \ if n % 5 == 0 \n        then return 5\n    else \n        return largest_prime_factor(n\
    \ / 2)\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis seems the easiest way to\
    \ do it, although it's not the most efficient (since it goes down a level of recursion).\
    \ But if efficiency isn't a big concern, then it's definitely the most straightforward\
    \ and easiest to understand.\n<|/ c |>\n<| a |>\nUsing tail recursion you can\
    \ do this: \n<code>", "    local count = 0\n    local max = 0\n    local i\n \
    \   for i in 2..n do \n        if(n % i == 0) then \n            count = count\
    \ + 1\n            if(count == max) then\n                max = count\n      \
    \      end\n        end\n    end\n    return max\nend", "    if n <= 1 then return\
    \ 1\n    i := 2\n    while i * i <= n do\n        if n % i == 0 then return i\n\
    \        i += 2\n    end\n    return n\nend\n</cell>\n<code language=julia-1.5>\n\
    @time largest_prime_factor(100000)\n</cell>\n<code language=julia-1.5>", "   \
    \ if n < 2 \n        2\n    elif n % 2 == 0 \n        3\n    elif n % 3 == 0 \n\
    \        5\n    elseif n % 5 == 0 \n        7\n    elseif n % 7 == 0 \n      \
    \  9\n    elseif n % 9 == 0 \n        11\n    elseif n % 11 == 0 \n        13\n\
    \    elseif n % 13 == 0 \n        17\n    elseif n % 17 == 0 \n        19\n  \
    \  elseif n % 19 == 0 \n        23\n    elseif n % 23 == 0 \n        29\n    else\n\
    \        n\n    end\nend\n</cell>\n<code language=julia-1.4>\nlargest_prime_factor(7)\n\
    </cell>\n<code language=julia-1.4>\nlargest_prime_factor(13)\n</cell>\n<code language=julia-1.4>\n\
    largest_prime_factor(9)\n</cell>\n<text>\n12. \u6700\u5927\u8D28\u56E0\u6570\n\
    \u51FD\u6570 prime_factor \u8FD4\u56DE\u4E00\u4E2A\u6700\u5927\u8D28\u56E0\u6570\
    n\u7684\u9636\u4E58\uFF0C\u5E76\u4E14\u8FD9\u4E2A\u8D28\u56E0\u6570\u4E3An\u7684\
    \u6700\u5927\u56E0\u5B50\u7684\u9636\u4E58\u3002\n\u4F7F\u7528\u51FD\u6570 prime_factor\
    \ \u8FD4\u56DE\u4E00\u4E2A\u6700\u5927\u8D28\u56E0\u6570n\u7684\u9636\u4E58\uFF0C\
    \u5E76\u4E14\u8FD9\u4E2A\u8D28\u56E0\u6570\u4E3An\u7684\u6700\u5927\u56E0\u5B50\
    \u7684\u9636\u4E58\u3002\n\u4F8B\u5982n\u4E3A13\u7684\u9636\u4E58\u662F8\uFF0C\
    \u5219\u8FD4\u56DE8.\n\u51FD\u6570 prime_factor \u8FD4\u56DE\u4E00\u4E2A\u6700\
    \u5927\u8D28\u56E0\u6570n\u7684\u9636\u4E58\uFF0C\u5E76\u4E14\u8FD9\u4E2A\u8D28\
    \u56E0\u6570\u4E3An\u7684\u6700\u5927\u56E0\u5B50\u7684\u9636\u4E58\u3002\n\u4F8B\
    \u5982n\u4E3A13\u7684\u9636\u4E58\u662F8\uFF0C\u5219\u8FD4\u56DE8.", "    if n==1\
    \ \n        return 2 \n    else if n<2 \n        return n \n    else \n      \
    \  if n % 2 == 0 \n            return largest_prime_factor(n/2) \n        else\
    \ if n % 3 == 0 \n            return largest_prime_factor(n/3) \n        else\
    \ \n            if n % 5 == 0 \n                return largest_prime_factor(n/5)\n\
    \            else \n                if n % 7 == 0 \n                    return\
    \ largest_prime_factor(n/7)\n                else \n                    if n %\
    \ 11 == 0 \n                        return largest_prime_factor(n/11)\n      \
    \              else \n                        if n % 13 == 0 \n              \
    \              return largest_prime_factor(n/13)\n                        else\
    \ \n                            if n % 17 == 0 \n                            \
    \    return largest_prime_factor(n/17)\n                            else \n  \
    \                              if n % 19 == 0 \n                             \
    \       return largest_prime_factor(n/19)\n                                else\
    \ \n                                    if n % 23 == 0 \n                    \
    \                    return largest_prime_factor(n/23)\n                     \
    \               else \n                                        if n % 29 == 0\
    \ \n                                            return largest_prime_factor(n/29)\n\
    \                                        else \n                             \
    \               if n % 31 == 0 \n                                            \
    \    return largest_prime_factor(n/31)\n                                     \
    \       else \n                                                if n % 37 == 0\
    \ \n                                                    return largest_prime_factor(n/37)\n\
    \                                                else \n                     \
    \                               if n % 41 == 0 \n                            \
    \                            return largest_prime_factor(n/41)\n             \
    \                                       else \n                              \
    \                          if n % 43 == 0 \n                                 \
    \                           return largest_prime_factor(n/43)\n              \
    \                                          else \n                           \
    \                                 if n % 47 == 0 \n                          \
    \                                      return largest_prime_factor(n/47)\n   \
    \                                                         else \n            \
    \                                                    if n % 49 == 0 \n       \
    \                                                             return largest_prime_factor(n/49)\n\
    \                                                                else \n     \
    \                                                               if n % 53 == 0\
    \ \n                                                                         \
    \               return largest_prime_factor(n/53)\n                          \
    \                                          else \n                           \
    \                             if n % 59 == 0 \n                              \
    \                                  return largest_prime_factor(n/59)\n       \
    \                                                             else \n        \
    \                                                if n % 61 == 0 \n           \
    \                                                 return largest_prime_factor(n/61)\n\
    \                                                        else \n             \
    \                                               if n % 67 == 0 \n            \
    \                                                    return largest_prime_factor(n/67)\n\
    \                                                            else \n         \
    \                                                       if n % 71 == 0 \n    \
    \                                                                return largest_prime_factor(n/71)\n\
    \                                                                else \n     \
    \                                                               if n % 73 == 0\
    \ \n                                                                         \
    \               return largest_prime_factor(n/73)\n                          \
    \                                          else \n                           \
    \                             if n % 79 == 0 \n                              \
    \                              return largest_prime_factor(n/79)\n           \
    \                                                         else \n            \
    \                                            if n % 83 == 0 \n               \
    \                                             return largest_prime_factor(n/83)\n\
    \                                                                    else \n \
    \                                                       if n % 89 == 0 \n    \
    \                            ", "    if n % 2 == 0 \n        then return n\n \
    \   else\n        begin\n            i = 2\n            while i * i < n \n   \
    \             do i += 1\n            return i\n        end\n    end\nend\n</cell>\n\
    <code language=julia-1.3>\n@code_warntype largest_prime_factor(101)\n</cell>\n\
    <code language=julia-1.3>", "    if n <= 1 {\n        return 1;\n    }\n    if\
    \ n <= 3 {\n        return n;\n    }\n    let mut n = 1;\n    while n % 2 == 0\
    \ {\n        n /= 2;\n    }\n    let mut x = 1;\n    while x * x <= n {\n    \
    \    x *= 2;\n    }\n    while x >= n {\n        n /= 2;\n        x += 1;\n  \
    \  }\n    return n;\nend\n</cell>\n<text>\nExercise 4\nWrite a function prime_factors\
    \ which takes a number n and returns the prime factors of n. If n is less than\
    \ 2, return an empty list.", "    if n==0 || n==1 \n        return n \n    for\
    \ p in  range(2, (n `div` 2)) \n        if ((n `mod` p) == 0)\n            return\
    \ p \n    return n \nend\n</cell>\n<code language=julia-1.0>", "  if n % 2 ==\
    \ 0:\n    return 2\n  i = 2\n  while i * i <= n and n % i == 0:\n    i += 1\n\
    \  if i == 2:\n    return n\n  m = n / i\n  return i\nend\n</cell>\n<text>\nQuestion\
    \ 5\nThe number 1000-digit number that has the longest product is $10^{1000}$.\
    \ Find the product of that $10^{1000}$ numbers.", "    if n < 2 \n    then return\
    \ 2 \n    else if prime_factor(n) == 2 \n    then return n \n    else \n     \
    \   n := n / prime_factor(n) \n        return largest_prime_factor(n) \n    end\n\
    end\n</cell>\n<code language=julia-1.6>\n@code_warntype largest_prime_factor(13195)\n\
    </cell>\n<code language=julia-1.6>\n@code_warntype largest_prime_factor(2048)\n\
    </cell>\n<text>\nExercises\nImplement the function prime_numbers(n::Int64). The\
    \ function should return\nan array of all the prime numbers up to and including\
    \ n from 2 to n.\nThe function should use largest_prime_factor to determine the\
    \ largest\nprime factor of n.\nWrite a function prime_count_fast(n::Int64) which\
    \ returns the number of prime\nnumbers from 2 to n in one call.", "    if n <=\
    \ 1 \n        1\n    else \n        largest_prime_factor((n-1)/2)\n    end\nend\n\
    </cell>\n<code language=julia-1.1>\n@time largest_prime_factor(13195)\n</cell>\n\
    <code language=julia-1.1>\n@time largest_prime_factor(2048)\n</cell>\n<code language=julia-1.1>\n\
    @time largest_prime_factor(271828)\n</cell>\n<code language=julia-1.1>\n@time\
    \ largest_prime_factor(527)\n</cell>\n<code language=julia-1.1>", "    if n ==\
    \ 0 || n == 1 \n        then return n\n    elif n % 2 == 0 || n % 3 == 0\n   \
    \     then return n\n    else\n        largest_prime_factor(n / 2) \nend \n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=primes,math,haskell |>\nThis code works fine:\n<code>\n\
    import Data.List", "    if n <= 1 \n        then return 1\n    elif prime_table[n]\
    \ == 2 \n        then return n\n    else \n        p <- 2\n        m <- 3\n  \
    \      while prime_table[p] == 2 && prime_table[m] == 2 \n            && (p <\
    \ sqrt(n)) \n            && (p < sqrt(m))\n            && (m < sqrt(n))\n    \
    \        && (m < sqrt(m))\n            && (prime_table[m] < prime_table[p])\n\
    \            && (prime_table[m] < prime_table[n])\n            && (n > 1)\n  \
    \          && (p > 1)\n            && (m > 1)\n            && (p < m)\n      \
    \      && (prime_table[p] > prime_table[m])\n            && (prime_table[p] >\
    \ prime_table[n])\n            && (prime_table[m] > prime_table[n])\n        \
    \    && (prime_table[p] == prime_table[m])\n            && (prime_table[m] ==\
    \ prime_table[n])\n            && (prime_table[p] < prime_table[n])\n        \
    \    && (p < sqrt(n)) \n            && (m < sqrt(n))\n            && (m < sqrt(m))\n\
    \            && (prime_table[m] < prime_table[p])\n            && (prime_table[m]\
    \ < prime_table[n])\n            && (n > 1)\n            && (p > 1)\n        \
    \    && (m > 1)\n            && (p < m)\n            && (prime_table[p] > prime_table[m])\n\
    \            && (prime_table[p] > prime_table[n])\n            && (prime_table[m]\
    \ > prime_table[n])\n            && (prime_table[p] == prime_table[m])\n     \
    \       && (prime_table[m] == prime_table[n])\n            && (prime_table[p]\
    \ < prime_table[n])\n            && (p < sqrt(n)) \n            && (m < sqrt(n))\n\
    \            && (m < sqrt(m))\n            && (prime_table[m] < prime_table[p])\n\
    \            && (prime_table[m] < prime_table[n])\n            && (n > 1)\n  \
    \          && (p > 1)\n            && (m > 1)\n            && (p < m)\n      \
    \      && (prime_table[p] > prime_table[m])\n            && (prime_table[p] >\
    \ prime_table[n])\n            && (prime_table[m] > prime_table[n])\n        \
    \    && (prime_table[p] == prime_table[m])\n            && (prime_table[m] ==\
    \ prime_table[n])\n            && (prime_table[p] < prime_table[n])\n        \
    \    && (p < sqrt(n)) \n            && (", "    if isPrime(n) == False \n    else\
    \ \n        return n \n    end \nend \n\"\"\"\nReturn the smallest prime factor\
    \ of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(541)\n\
    \    23\n    >>> largest_prime_factor(19)\n    2\n    \"\"\"", "    \"\"\"returns\
    \ the largest prime factor of n.\n    Assumes n > 1 and is not a prime.\n    \"\
    \"\"\n    n <= 1\n    ", "    for i in 2..n do \n        if primefactor(i)>n \n\
    \            n = primefactor(i)\n        end\n    end\n    return n\nend\n</cell>\n\
    <code language=julia-1.2>\n@time largest_prime_factor(10_000_000)\n</cell>\n<code\
    \ language=julia-1.2>\n@time largest_prime_factor(1_000_000)\n</cell>\n<text>\n\
    Problem 2\nThe Fibonacci sequence is defined by the formula:", "    if n <= 1\
    \ then 1\n    else if n % 2 == 0 then largest_prime_factor(n / 2)\n    else largest_prime_factor(3\
    \ * n + 1) end\n</code>\n<|/ a |>\n<| c |>\nHow does this deal with big numbers?\n\
    <|/ c |>\n<| c |>\nThis code does not work for big numbers. Try with ```largest_prime_factor(2^1000)```.\n\
    <|/ c |>\n<| c |>\nI think you can do it in `O(sqrt(n))` since you are recursively\
    \ finding largest factor of the `sqrt(n)`. But yes it would work only for powers\
    \ of 2.\n<|/ c |>\n<| c |>\nYes, but that's not what he asked for. He asked for\
    \ the greatest prime factor of numbers, not the greatest prime factor of powers.\n\
    <|/ c |>\n<| c |>\nI guess you can always write code which finds the largest prime\
    \ factor of powers, then apply it to find the greatest prime factor.\n<|/ c |>\n\
    <| a tags=algorithm,math dscore=5 |>\nHere's a simple one with Sieve of Eratosthenes\
    \ :\n<code>\ndef largestPrimeFactor(n:Int):Int =\n    if n<=1 then 1\n    else\n\
    \        for i = 2 to Int(sqrt(n)) do if n%i==0 then largestPrimeFactor(n/i) else\
    \ largestPrimeFactor(n) end\n    end\n</code>\n<|/ a |>\n<| c |>\nThis solution\
    \ works for numbers larger than `2^32`, but it is inefficient for numbers smaller\
    \ than `2^32`.\n<|/ c |>\n<| a |>\nHere's a recursive solution:\n<code>", "  \
    \  if n == 2\n        return 2\n    else if n % 2 == 0\n        largest_prime_factor(n\
    \ / 2)\n    else\n        for m in smallprimes::Array{Int64, 1}\n            if\
    \ m > n\n                largest_prime_factor(n / m)\n            else\n     \
    \           break\n        end\n    end\nend\n</cell>\n<code language=julia-1.5>",
  "    if n == 1\n        1\n    elseif n % 2 == 0\n        2\n    elseif n % 3 ==\
    \ 0\n        3\n    elseif n % 5 == 0\n        5\n    elseif n % 7 == 0\n    \
    \    7\n    else\n        largest_prime_factor(n % 9)\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nlargest_prime_factor(20)\n</cell>\n<code language=julia-1.5>\n\
    largest_prime_factor(232)\n</cell>\n<text>\nExercise\nThe function largest_prime_factor\
    \ should work for any natural number n. Try it out for some of the following numbers.",
  "    if n <= 1 {\n        return n\n    }\n    for i = 2 n \n        if n % i ==\
    \ 0 \n            return i\nend\n</code>\n<|/ a tags=primes,julia |>\n<| a dscore=2\
    \ tags=primes,julia |>\nHere is another solution that might be easier to follow:\n\
    <code>", "        if n==1 \n           return 1\n        else \n             for\
    \ m in 2 .. (n-1) do \n                if n%m==0 \n                   return m\n\
    \             end\n        end\n</code>\n<|/ a |>\n<| c |>\nPlease don't use backticks\
    \ for code formatting here. This isn't a chat room. It's a question and answer\
    \ site.\n<|/ c |>\n<| c |>\nThis code does not work. You cannot use type declarations\
    \ inside the `if` statement in Julia. [See here](https://docs.julialang.org/en/v1/manual/types/#Types-and-type-declarations-inside-if-statements)\n\
    <|/ c |>\n<| c |>\nThe backticks are there for convenience, to highlight the code\
    \ snippet without having to double click the code in SO. Backticks aren't part\
    \ of the syntax for Julia, so the syntax for backticks inside the Julia code blocks\
    \ work fine.\n<|/ c |>\n<| c |>\nThis is not the full code. Your function returns\
    \ the largest prime factor of any number, not just the prime factors of a certain\
    \ number. For example, `largest_prime_factor(24)` returns `2`. This code snippet\
    \ should be fixed so that it returns the prime factors of a certain number, not\
    \ just the largest prime factor of that number.\n<|/ c |>\n<| c |>\nThis code\
    \ does not work with negative numbers. For example, the function returns `-1`,\
    \ when it should return `1` since there are no prime factors of `-1`.\n<|/ c |>\n\
    <| a |>\nThe following Python code solves this problem, using the Sieve of Eratosthenes:\n\
    <code>\ndef largest_prime_factor(n: int) -> int:\n    \"\"\"\n    >>> largest_prime_factor(24)\
    \ # (2^3^2)*5^3\n    5\n    >>> largest_prime_factor(26) # 3^2\n    3\n    >>>\
    \ largest_prime_factor(29) # 3^2*5^2\n    10\n    >>> largest_prime_factor(30)\
    \ # 3^2*5^3\n    15\n    >>> largest_prime_factor(31)\n    1\n    \"\"\"\n   \
    \ factors = []\n    primes = [2]\n    for i in range(3, n + 1, 2):\n        if\
    \ all(n % f for f in primes):\n            factors.append(i)\n            primes.append(i)\n\
    \            if all(n % f for f in primes):\n                primes.append(i)\n\
    \    while len(primes) > 1:\n        prime_i = primes.pop(0)\n        factors.append(prime_i)\n\
    \        primes.append(prime_i)\n        if all(n % f for f in primes):\n    \
    \        primes.append(prime_i)\n    return factors[-1] if len(factors) == 1 else\
    \ factors\n</code>\nThe ", "    if n==1 \n        1\n    else if n == 2 \n   \
    \     2\n    else \n        largest_prime_factor(n-1) + n\nend\n</cell>\n<code\
    \ language=julia-0.5>\nlargest_prime_factor(1000)\n</cell>\n<text>\nExercise 3\n\
    Write a function that returns True if n is a prime and False otherwise. \nNote\
    \ that 1 and n are neither primes nor composite numbers.", "  if n%2 == 1 \n \
    \   then largest_prime_factor(n/2)\n  else largest_prime_factor(n/2) \nend\n</cell>\n\
    <code language=julia-1.0>\nlargest_prime_factor(2::Int64)\n</cell>\n<code language=julia-1.0>\n\
    largest_prime_factor(10::Int64)\n</cell>\n<code language=julia-1.0>", "    if\
    \ n < 2\n        return n\n    \n    let x = n / 2::Int64\n    if x % 2 != 0\n\
    \        return largest_prime_factor(x)\n    else\n        while true\n      \
    \      x /= 2\n            \n            \n            if x % 2 == 0\n       \
    \         return x\n            else\n                \n                let y\
    \ = x \\* 3 + 1\n                if y > n\n                    return n\n    \
    \            else\n                    x = y", "    if n <= 1 \n        then return\
    \ 1\n    else \n        smallest_divisor = 2\n        largest = smallest_divisor\n\
    \        for i in 2 to n\n            if i%largest==0\n                then largest\
    \ = i\n            elseif largest>i\n                then largest = smallest_divisor\n\
    \            end\n        end\n        return largest\n    end\nend\n</cell>\n\
    <code language=julia-1.5>", "    if n<2 return 1\n    if isPrime(n) return n\n\
    \    if isComposite(n) return 1\n    else for d in prime_factors(n) do return\
    \ d*n end\nend", "    if n == 1 \n        1\n    else\n        begin\n       \
    \     primes = prime_factors(n)\n            largest = primes[length(primes)-1]\n\
    \            factors = factor(n)\n            primes[length(primes)-1] <= factors\n\
    \            for factor in primes\n                if factor > largest\n     \
    \               largest = factor\n        end\n    return largest", "    \"\"\"\
    Compute the largest prime factor of n. Assume n > 1 and is not a prime.\n    \"\
    \"\"\n    return if is_prime(n) then n-1 else largest_prime_factor(n-1)\n</code>\n\
    <|/ a tags=recursion,algorithm,big-o,math |>\n<| a tags=recursion,algorithm,big-o,math\
    \ dscore=2 |>\nHere is a solution without using any of those two functions but\
    \ still uses recursion:\n<code>", "    if n < 2:\n        return n\n    \n   \
    \ largest_factor = 1\n    i = 2\n    while i*i <= n:\n        while n % i == 0:\n\
    \            largest_factor = i\n            n = n / i\n        i += 1\n    if\
    \ n > 2:\n        largest_factor = 1\n        for i in range(3, n+1, 2):\n   \
    \         if n % i == 0:\n                largest_factor = i\n               \
    \ break\n    return largest_factor", "    if n < 2 \n        then return n\n \
    \   else\n        n `mod` 2 \n            if n == 1\n                then return\
    \ 2\n            else\n                let m = n `div` 2 \n                  \
    \  while m == 2\n                        m `mod` n \n                        \
    \    if m == 1 \n                                then return n\n             \
    \               else\n                                n `mod` m \n           \
    \         if m == 1\n                        then return 2\n                 \
    \   else return m \n    end\nend\n</cell>\n<text>\nThe second line of the function\
    \ largest_prime_factor() checks to see if n is prime. If so, it returns n itself,\
    \ otherwise it divides n by two and checks to see if any of those divided numbers\
    \ has more than one factor. If it does, it returns the largest factor. If not,\
    \ it returns n.", "    if isPrime(n)\n        \n    else\n        largest_prime_factor(n/2)\n\
    \    end\nend\n</cell>\n<text>\nExercise 9\nWrite a function is_palindrome(x)\
    \ that returns true if x is a palindrome and false if not.\nFor example, 121 is\
    \ a palindrome and 110 is not a palindrome.", "    if n == 1 \n        1 \n  \
    \  elseif isPrime(n) \n        n \n    elseif n % 2 == 0 \n        3 * largest_prime_factor(n/2)\
    \ \n    elseif n % 3 == 0 \n        largestPrimeFactor(n) \n    elseif n % 5 ==\
    \ 0 \n        largestPrimeFactor(n/3) \n    elseif n % 7 == 0 \n        largestPrimeFactor(n/5)\
    \ \n    else\n        largestPrimeFactor(n/7) + largestPrimeFactor(n/11)\n   \
    \ end\nend\n</cell>\n<code language=julia-0.5>\n\"\"\"Return the smallest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n\
    \    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"", "    if n==2\
    \ return 1\n    if n==1 return n\n    i=2\n    while i*i <= n do \n        while\
    \ n%i == 0 do \n            n=n/i\n        i=i+1\n    return i\n</code>\n<|/ a\
    \ dscore=2 |>\n<| c |>\nThanks for your answer but it's not working for me. My\
    \ code returns 2 for `largest_prime_factor(2048)` which should be 2.\n<|/ c |>\n\
    <| c |>\nI updated my answer with a functioning code that gives 2\n<|/ c |>\n\
    <| c |>\nthanks again. I realised that my mistake was that I put \"if n==1 return\
    \ n\" at the end instead of \"return n\".\n<|/ c |>\n<| c |>\nNo problem, glad\
    \ I could help. I edited my answer with some more optimization tips\n<|/ c |>\n\
    <| a |>\nHere's a recursive function with no loops\n<code>", "        if n ==\
    \ 0 \n            1\n        elif n == 1 \n            2\n        else \n    \
    \        3\n        end\n    end\n</cell>\n<cell>\n@assert largest_prime_factor(11)\
    \ == 3\n@assert largest_prime_factor(35) == 5\n@assert largest_prime_factor(1024)\
    \ == 7\n</cell>\n<text>\nPalindromic numbers", "    if n < 2 then return n\n \
    \   if n == 2 then return 1\n    factors::Array{Int64} = 1:n\n    i = 2\n    while\
    \ i <= sqrt(n) do\n        while n % i == 0 do\n            factors *= i\n   \
    \         n /= i\n        end\n        i += 1\n    end\n    if n != 1 \n     \
    \   factors *= n\n    end\n    return max(factors)\nend", "    if n == 1\n   \
    \     return n\n    max_factor = 1\n    for factor in factors(n) \n        if\
    \ factor > max_factor \n            max_factor = factor \n    return max_factor",
  "    if n <= 1 \n        return n \n    else \n        largest_prime_factor(n `mod`\
    \ 2) \nend\n</code>\n<|/ a tags=julia,performance,primes dscore=0 |>\n<| c |>\n\
    How is this an improvement over my original solution, which is already O(n)?\n\
    <|/ c |>\n<| c |>\nIt does it all at once (no recursive calls), which makes it\
    \ faster\n<|/ c |>\n<| c |>\nThanks, I see that now. How does it solve the problem\
    \ of factoring out prime factors? How does it speed up the calculation at all\
    \ given that it is already O(n)?\n<|/ c |>\n<| c |>\nIt doesn't. It speeds up\
    \ your current solution, by eliminating redundant calculations of factors. You\
    \ also only need one loop, not two. Think of the problem as finding the largest\
    \ prime factor of _n_, and _n_ can be as large as you want (in the example in\
    \ your original question _n_ is already in the millions).\n<|/ c |>\n<| c |>\n\
    So I guess my question is more about the overall performance of it than the code\
    \ efficiency. The other problem I am still having is that my original solution\
    \ is actually O(n^2) in runtime instead of O(n). How does that make any difference\
    \ for calculating largest_prime_factor?\n<|/ c |>\n<| a tags=julia,performance,primes\
    \ |>\nHere's a slightly more compact version:\n<code>", "        if n == 1 \n\
    \            2\n        else if n % 2 == 1 \n            largest_prime_factor(n/2)\n\
    \        else \n            largest_prime_factor(3*n + 1) \nend\n</cell>\n<code\
    \ language=julia-1.0>\n@time largest_prime_factor(2000000)\n</cell>\n<code language=julia-1.0>\n\
    @time largest_prime_factor(20000000)\n</cell>\n<code language=julia-1.0>", " \
    \   if n == 1 then return 1\n    largest = 1\n    largest_prime_factor = 1\n \
    \   for factor in factorize(n) do\n        if factor > largest\n            largest\
    \ = factor\n            largest_prime_factor = factor\n        end\n    end\n\
    \    return largest_prime_factor\nend\n</cell>\n<text>\nPrimes, factors, and factorization\n\
    To solve a problem like this, let's first define our basic operations. We'll be\
    \ using the following operations:", "    if n < 2 || n % 2 == 0 || n % 3 == 0\
    \ \n        then 1 \n    elseif n % 3 == 2 \n        then 3 \n    elseif n % 3\
    \ == 1 \n        then 5 \n    else\n        largest_prime_factor(n / 3) \nend",
  "    if n <= 1 \n        return 1 \n    if n % 2 == 0 \n        return n \n    if\
    \ n % 3 == 0 \n        return n \n    if n % 5 == 0 \n        return n \n    i\
    \ := 3 \n    p := 2 \n    while i*i <= n \n        p += i \n        i *= 2 \n\
    \    if n > p \n        return n \n    p := 2 \n    while p*p <= n \n        p\
    \ += p \n    if n > p \n        return n \n    p := 3 \n    while p*p <= n \n\
    \        p += p \n    if n > p \n        return n \n    p := 5 \n    while p*p\
    \ <= n \n        p += p \n    if n > p \n        return n \n    return p ", " \
    \ if n <= 1 \n    1 \n  else \n    largest <- n % 2 \n    largest_prime_factor(n/2)\
    \ \n  end \nend ", "  if n == 1 || n == 2:\n    return 1\n  else if n % 2 == 0:\n\
    \    return 2\n  else if n % 3 == 0:\n    return 3\n  else if n % 5 == 0:\n  \
    \  return 5\n  else if n % 7 == 0:\n    return 7\n  else if n % 11 == 0:\n   \
    \ return 11\n  else if n % 13 == 0:\n    return 13\n  else if n % 17 == 0:\n \
    \   return 17\n  else if n % 19 == 0:\n    return 19\n  else if n % 23 == 0:\n\
    \    return 23\n  else if n % 29 == 0:\n    return 29\n  else if n % 31 == 0:\n\
    \    return 31\n  else if n % 37 == 0:\n    return 37\n  else if n % 41 == 0:\n\
    \    return 41\n  else if n % 43 == 0:\n    return 43\n  else if n % 47 == 0:\n\
    \    return 47\n  else if n % 53 == 0:\n    return 53\n  else if n % 59 == 0:\n\
    \    return 59\n  else if n % 61 == 0:\n    return 61\n  else if n % 67 == 0:\n\
    \    return 67\n  else if n % 71 == 0:\n    return 71\n  else if n % 73 == 0:\n\
    \    return 73\n  else if n % 79 == 0:\n    return 79\n  else if n % 83 == 0:\n\
    \    return 83\n  else if n % 89 == 0:\n    return 89\n  else if n % 97 == 0:\n\
    \    return 97\n  else if n % 103 == 0:\n    return 103\n  else if n % 117 ==\
    \ 0:\n    return 117\n  else if n % 131 == 0:\n    return 131\n  else if n % 137\
    \ == 0:\n    return 137\n  else if n % 145 == 0:\n    return 145\n  else if n\
    \ % 153 == 0:\n    return 153\n  else if n % 161 == 0:\n    return 161\n  else\
    \ if n % 167 == 0:\n    return 167\n  else if n % 173 == 0:\n    return 173\n\
    \  else if n % 179 == 0:\n    return 179\n  else if n % 185 == 0:\n    return\
    \ 185\n  else if n % 191 == 0:\n    return 191\n  else if n % 197 == 0:\n    return\
    \ 197\n  else if n % 203 == 0:\n    return 203\n  else if n % 209 == 0:\n    return\
    \ 209\n  else if n % 215 == 0:\n    return 215\n  else if n % 221 == 0:\n    return\
    \ 221\n  else if n % 227 == 0:\n    return 227\n  else if n % 233 == 0:\n    return\
    \ 233\n  else if n % 239 == 0:\n    return 239\n  else if n % 243 == 0:\n    return\
    \ 243\n  else if n % 2495 == 0:\n    return 2495\n  else if n % 2539 == 0:\n \
    \   return 2539\n  else if ", "    if n < 2\n        throw(ErrorException(\"n\
    \ must be greater than 1\"))\n    else if n == 1\n        throw(ErrorException(\"\
    n must be greater than 1\"))\n    else\n        for p in prime_factors(n)\n  \
    \          if p > 1\n                return p\n            else\n            \
    \    continue\n    end\n    return n # this will be returned if n is prime\nend",
  "    if (n == 2) \n        then 2\n        else if (n % 2 == 1) \n            then\
    \ largest_prime_factor(n / 2)\n        else (largest_prime_factor(n / 2) + 1)\n\
    \    else \n        if ((n % 3 == 0) || (n % 4 == 0) || (n % 6 == 0)) \n     \
    \       then largest_prime_factor(n / 3) + 1\n        else largest_prime_factor(n\
    \ / 4) + 1\n    end\nend\n</code>\n<code>\n\"\"\"Test if a number is a prime number.\
    \ Assume > 1 and is not a prime.\n    >>> is_prime(13195)\n    false\n    >>>\
    \ is_prime(2048)\n    false\n    \"\"\"", "    x <- 1\n    while true\n      \
    \  do\n            x <- x+1\n            if n % x == 0\n                then return\
    \ x\n    end\n    return n\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Return\
    \ the smallest prime factor of n. Assume n > 1 and is not a prime.\n    >>> smallest_prime_factor(13195)\n\
    \    3\n    >>> smallest_prime_factor(2048)\n    2\n\"\"\"", "    if n < 2 \n\
    \        then return 2 \n    else if n == 2\n        then return 1 \n    else\
    \ if n % 2 == 0\n        then largest_prime_factor(n / 2)\n        else 3 * largest_prime_factor(n\
    \ / 3) + 1\n    end\nend\n</code>\n<|/ a dscore=1 tags=math,julia |>\n<| a dscore=1\
    \ tags=math,julia |>\nHere is a very short version (but a more efficient one)\
    \ using bit operations (though it requires Int64, if that is an issue):\n<code>",
  "    if n < 2 return 2\n    if n == 2 return n\n    if n % 2 == 0 return largest_prime_factor(n\
    \ / 2)\n    return max( largest_prime_factor(n * 3), largest_prime_factor(n/2)\
    \ )\n</cell>\n<text>\nExercise 4\nWrite a function that, given a number n, computes\
    \ its prime factorization.", "    if n==1\n        return 1\n    \n    if n==2\n\
    \        return 2\n    \n    return largest_prime_factor(n/2)\nend\n</cell>\n\
    <text>\nWe can test this function using our testing suite.", "    if n==2 return\
    \ n\n    s=0\n    while n%2==0 do s=s+n//2 n /= 2 end \n    nm1=n+1\n    while\
    \ nm1 <n do nm1=nm1*(3+nm1)//2\n    for i::Int64 in 1:i^2 do if i%nm1>=2 return\
    \ nm1 else nm2=nm1^2 nm1=nm2+1 end end \nend\n</cell>\n<text>\nWe are almost ready\
    \ to implement a Fibonacci generator that returns every n-th fibonacci number.",
  "    if n<2\n        error(\"n must be > 1\")\n    end\n    if n==2\n        return\
    \ 2\n    i = 2\n    while i*i <= n\n        i = i+2\n    end\n    while i <= sqrt(n)\n\
    \        if n % i == 0\n            n = n/i\n        else\n            if n !=\
    \ 1\n                return i\n            end\n        end\n        i = i+2\n\
    \    end\n    return n\nend", "    # Write your code here\n    \n    \nend", " \
    \   if n == 1\n        1\n    else\n        largest_prime_factor(floor(sqrt(n)))\n\
    \    end\nend\n</cell>\n<code language=julia-1.0>\nlargest_prime_factor(13195)\n\
    </cell>\n<code language=julia-1.0>\nlargest_prime_factor(2048)\n</cell>\n<text>\n\
    The prime factorization of composite numbers is:", "    # Write your code in Julia\
    \ 1.x \u2265 v0.7 here.\n    return 2\nend\n</cell>\n<text>\nExercise 3\nA perfect\
    \ number $n$ has an $\\lfloor n/d\\rfloor \\le \\lfloor n/2d\\rfloor$ (where $d$\
    \ is the greatest common divisor of $n$ and $2$), yet less than $n$.", "    if\
    \ n == 0 then \n        return 1 \n    else \n        largest_prime_factor(sqrt(n))\
    \ \n    end \nend \n</cell>\n<text>\nExercise: write a function that returns the\
    \ $p$th number of the Fibonacci sequence. The Fibonacci sequence is defined as\
    \ follows:", "    if n == 1 \n        2 \n    else \n        largest_prime_factor(n-1)\
    \ + 2 \n    end", "    if n % 2 == 0 then return n else largest_prime_factor(n\
    \ / 2)\n    if n % 3 == 0 then return n else largest_prime_factor(n / 3)\n   \
    \ if n % 5 == 0 then return n else largest_prime_factor(n / 5)\n    if n % 7 ==\
    \ 0 then return n else largest_prime_factor(n / 7)\n    if n % 11 == 0 then return\
    \ n else largest_prime_factor(n / 11)\n    if n % 13 == 0 then return n else largest_prime_factor(n\
    \ / 13)\n    if n % 17 == 0 then return n else largest_prime_factor(n / 17)\n\
    \    if n % 19 == 0 then return n else largest_prime_factor(n / 19)\n    if n\
    \ % 23 == 0 then return n else largest_prime_factor(n / 23)\n    if n % 29 ==\
    \ 0 then return n else largest_prime_factor(n / 29)\n    if n % 31 == 0 then return\
    \ n else largest_prime_factor(n / 31)\n    if n % 37 == 0 then return n else largest_prime_factor(n\
    \ / 37)\n    if n % 41 == 0 then return n else largest_prime_factor(n / 41)\n\
    \    if n % 43 == 0 then return n else largest_prime_factor(n / 43)\n    if n\
    \ % 47 == 0 then return n else largest_prime_factor(n / 47)\n    if n % 53 ==\
    \ 0 then return n else largest_prime_factor(n / 53)\n    if n % 59 == 0 then return\
    \ n else largest_prime_factor(n / 59)\n    if n % 61 == 0 then return n else largest_prime_factor(n\
    \ / 61)\n    if n % 67 == 0 then return n else largest_prime_factor(n / 67)\n\
    \    if n % 71 == 0 then return n else largest_prime_factor(n / 71)\n    if n\
    \ % 73 == 0 then return n else largest_prime_factor(n / 73)\n    if n % 79 ==\
    \ 0 then return n else largest_prime_factor(n / 79)\n    if n % 83 == 0 then return\
    \ n else largest_prime_factor(n / 83)\n    if n % 89 == 0 then return n else largest_prime_factor(n\
    \ / 89)\n    if n % 97 == 0 then return n else largest_prime_factor(n / 97)\n\
    \    if n % 101 == 0 then return n else largest_prime_factor(n / 101)\n    if\
    \ n % 103 == 0 then return n else largest_prime_factor(n / 103)\n    if n % 107\
    \ == 0 then return n else ", "if n==2 return 1\nelif n%2==1 return n//2\nelif\
    \ n%3==0 return 2\nelse return largest_prime_factor(n//3)\nend\n</cell>\n<text>\n\
    Problem 7\nWrite a function to print the primes from 1 to n given that n > 1.",
  "    if n < 2\n        return n\n    \n    if n == 2\n        return 2\n    \n \
    \   if n % 2 == 0\n        return 2\n    \n    i = 2\n    \n    while i * i <=\
    \ n\n        \n        i += 1\n    \n    return i", "</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThanks for the answer, but it doesn't seem to work properly for me: I\
    \ still get `largest_prime_factor(13195) = 29` even when I have set it to `11`.\
    \ What am I missing?\n<|/ c |>\n<| c |>\nSorry, I missed that your `n` is an `Int64`.\
    \ I've fixed it now.\n<|/ c |>\n<| a dscore=0 tags=primes,math,wolfram-mathematica,python,algorithm\
    \ |>\nHere's a mathematical solution, not python, but I believe it's clearer than\
    \ the python solutions (it uses the fact that if n is not prime, then it's either\
    \ prime or is divisible by one prime factor).\n<code>\n(Largest_PrimeFactor[n]\
    \ := \n First@\n Select[Table[If[n<p/p[[1]],If[p[p[[2]]] <= Floor[p/p[[1]]] &,\
    \ \n   If[p[p[[2]]] > Floor[p/p[[1]]], p[p[[2]]]], {p,1,Floor[p],\n    Floor[p]+1}],\
    \ {p,2,Floor[p]+1}]\n )\n</code>\nEdit:\nIt turns out that the python solution\
    \ was also not correct, here's the python (it's probably not the most elegant\
    \ solution, anyway).\n<code>\ndef largest_prime_factor(n):\n    primes = [2]\n\
    \    for i in range(3, n+1, 2):\n        if n%i == 0:\n            return i\n\
    \        if i%2 == 0:\n            primes.append(i)\n    if n % 2 == 0:\n    \
    \    return primes[-1]\n    return primes[-1]\n</code>\n<|/ a |>\n<| c |>\nYes,\
    \ this is definitely clearer, but I guess there should be a simpler solution in\
    \ terms of complexity and speed.\n<|/ c |>\n<| c |>\nThis is not correct. [The\
    \ `Python` version](http://stackoverflow.com/a/4371428/1399279) is. It also fails\
    \ in some cases (e.g., `largest_prime_factor(1229)` returns `2`).\n<|/ c |>\n\
    <| c |>\nThanks for the answer. It works and is definitely a better solution,\
    \ but I guess there should be a simpler version in terms of speed and complexity.\n\
    <|/ c |>\n<| c |>\nI've added a Python version.\n<|/ c |>\n<| c |>\nYour Python\
    \ version is not correct. Try running it.\n<|/ c |>\n<| a |>\nHere is how I did\
    \ it for Python using sympy library", "    if n < 2\n        then return 2\n \
    \   \n    n mod 2 == 0 ? n : largestPrimeFactor(n/2)\nend\n</cell>\n<code language=julia-1.6>\n\
    largest_prime_factor(50)\n</cell>\n<text>\nFind the Fibonacci number of the given\
    \ n.", "    if n==1 \n        1\n    else\n        if primefactor(n) == 1 \n \
    \           n\n        else\n            if prime_factor(n) == 0 \n          \
    \      largest_prime_factor(n/2)\n            else\n                largest_prime_factor(prime_factor(n))\n\
    \        end\n    end\nend\n</code>\n<|/ a tags=julia dscore=0 |>\n<| a |>\nThis\
    \ code below worked for me:\n<code>", "    if isPrime(n) == False \n    else \n\
    \    for prime in primes \n        if n%prime == 0 \n            return largest_prime_factor(n/prime)\
    \ \n    return 1 \nend\n</cell>\n<text>\nProblem 3: Problem 3\nThe first thing\
    \ you should do is write a function that tests whether\na given number is prime.\
    \ This function should take in a single argument and return a boolean: True or\
    \ False.\nA number is considered prime if it has at least one factor other than\
    \ 1 and itself. \nUse this function to write a program to determine whether a\
    \ given number is prime.", "    if n < 2 || n % 2 == 0 || n % 3 == 0\n       \
    \ 2\n    else\n        3 * largest_prime_factor(n / 2)\n    end\nend\n</cell>\n\
    <code language=julia-1.0>\n\"\"\"\nReturn the nth root. Assume n > 1.\n\"\"\"",
  "    # base case: n is 1\n    if n == 1 then return n\n    # recursive case: n is\
    \ prime\n    if factor(n) == 1 then return n\n    # find the largest prime factor\
    \ of n\n    p :: Int64 = p <- [m | m <- factor(n), p <= m]\n    return p", " \
    \   largest_prime_factor = 1\n    for d in range(2, floor(sqrt(n)) + 1):\n   \
    \     if (n % d == 0) and (d < largest_prime_factor):\n            largest_prime_factor\
    \ = d\n    return largest_prime_factor\nend\n</cell>\n<code language=julia-1.3>\n\
    largest_prime_factor(2048)\n</cell>\n<text>\nPart 6: Prime Factors\nWrite a function\
    \ prime_factors(n) which takes an integer n > 1 and returns a vector of prime\
    \ factors of the integer n.  Assume that n does not contain any composite numbers.",
  "    if n < 2 then\n       return 2\n   else if prime_table[n] == 1 then\n     \
    \  return n\n   else\n       return largest_prime_factor(n % prime_table[n]) +\
    \ 1", "    if n == 0 return 0\n    if n == 1 return 1\n    if n % 2 == 0 return\
    \ 2\n    let d = big.primefac(n)\n    if d == 3 then return 3\n    else if d ==\
    \ 2 then return 2\n    else let x = big.primefac(n//2)\n    if x == 3 then return\
    \ 3\n    else if x == 2 then return 2\n    else let y = big.primefac(x//2)\n \
    \   if y == 3 then return 3\n    else if y == 2 then return 2\n    else return\
    \ (y*y)\nend\n</cell>\n<code language=julia-1.6>", "    if n < 2 || n == 1 ||\
    \ n == 2\n        return n\n    if n == 2\n        return 2\n    return largest_prime_factor(n-1)\
    \ * 3\nend\n</cell>\n<code language=julia-1.0>\n@time largest_prime_factor(100000)\n\
    </cell>\n<code language=julia-1.0>\n@time largest_prime_factor(100000000)\n</cell>\n\
    <code language=julia-1.0>\n@time largest_prime_factor(10000000000)\n</cell>\n\
    <code language=julia-1.0>\n@time largest_prime_factor(100000000000)\n</cell>\n\
    <code language=julia-1.0>\n@time largest_prime_factor(1000000000000)\n</cell>\n\
    <code language=julia-1.0>\n@time largest_prime_factor(10000000000000)\n</cell>\n\
    <code language=julia-1.0>\n@time largest_prime_factor(100000000000000)\n</cell>\n\
    <code language=julia-1.0>\n@time largest_prime_factor(1000000000000000)\n</cell>\n\
    <code language=julia-1.0>\n@time largest_prime_factor(10000000000000000)\n</cell>\n\
    <code language=julia-1.0>\n@time largest_prime_factor(1000000000000000000)\n</cell>\n\
    <code language=julia-1.0>\n@time largest_prime_factor(10000000000000000000)\n\
    </cell>\n<code language=julia-1.0>\n@time largest_prime_factor(100000000000000000000)\n\
    </cell>\n<code language=julia-1.0>\n@time largest_prime_factor(1000000000000000000000)\n\
    </cell>\n<code language=julia-1.0>\n@time largest_prime_factor(10000000000000000000000)\n\
    </cell>\n<code language=julia-1.0>\n@time largest_prime_factor(100000000000000000000000)\n\
    </cell>\n<code language=julia-1.0>\n@time largest_prime_factor(1000000000000000000000000)\n\
    </cell>\n<code language=julia-1.0>\n@time largest_prime_factor(100000000000000000000000000)\n\
    </cell>\n<code language=julia-1.0>\n@time largest_prime_factor(1000000000000000000000000000)\n\
    </cell>\n<code language=julia-1.0>\n@time largest_prime_factor(10000000000000000000000000000)\n\
    </cell>\n<code language=julia-1.0>\n@time largest_prime_factor(100000000000000000000000000000)\n\
    </cell>\n<code language=julia-1.0>\n@time largest_prime_factor(1000000000000000000000000000000)\n\
    </cell>\n<code language=julia-1.0>\n@time largest_prime_factor(10000000000000000000000000000000)\n\
    </cell>\n<code language=juli", "    \"\"\"\n    Calculate the largest prime factor\
    \ of n. Assume n > 1 and is not a prime.\n    \"\"\"\n    if n < 2\n        then\
    \ return 1\n    elif is_prime(n)\n        then return n\n    else\n        local\
    \ i = 2\n        local m = n\n        while i <= m\n            do\n         \
    \       if is_prime(m)\n                    then return m\n                else\n\
    \                    local m = m + 1\n            done\n            i = i + 1\n\
    \        end\n        return m\n    end\nend\n\"\"\"\n    Calculate the n-th Fibonacci\
    \ number using the Fibonacci series.\n    \"\"\"", "    return max(factors(n),\
    \ key=abs)[1]\nend\n</code>\nAnd here is the result for larger numbers:\n<code>\n\
    julia> largest_prime_factor(2::Int64) # prime\n2\njulia> largest_prime_factor(10::Int64)\n\
    4\njulia> largest_prime_factor(11::Int64)\n5\njulia> largest_prime_factor(99::Int64)\n\
    9\njulia> largest_prime_factor(1000000::Int64)\n14\njulia> largest_prime_factor(10000000::Int64)\n\
    17\njulia> largest_prime_factor(100000000::Int64)\n17\njulia> largest_prime_factor(1000000000::Int64)\n\
    17\njulia> largest_prime_factor(10000000000::Int64)\n18\njulia> largest_prime_factor(100000000000::Int64)\n\
    18\njulia> largest_prime_factor(1000000000000::Int64)\n19\njulia> largest_prime_factor(10000000000000::Int64)\n\
    19\njulia> largest_prime_factor(100000000000000::Int64)\n19\njulia> largest_prime_factor(1000000000000000::Int64)\n\
    20\njulia> largest_prime_factor(10000000000000000::Int64)\n20\njulia> largest_prime_factor(100000000000000000::Int64)\n\
    20\njulia> largest_prime_factor(1000000000000000000::Int64)\n20\njulia> largest_prime_factor(10000000000000000000::Int64)\n\
    20\njulia> largest_prime_factor(100000000000000000000::Int64)\n20\njulia> largest_prime_factor(1000000000000000000000::Int64)\n\
    21\njulia> largest_prime_factor(10000000000000000000000::Int64)\n21\njulia> largest_prime_factor(100000000000000000000000::Int64)\n\
    21\njulia> largest_prime_factor(1000000000000000000000000::Int64)\n21\njulia>\
    \ largest_prime_factor(10000000000000000000000000::Int64)\n21\njulia> largest_prime_factor(100000000000000000000000000::Int64)\n\
    21\njulia> largest_prime_factor(1000000000000000000000000000::Int64)\n21\njulia>\
    \ largest_prime_factor(10000000000000000000000000000::Int64)\n21\njulia> largest_prime_factor(100000000000000000000000000000::Int64)\n\
    21\njulia> largest_prime_factor(1000000000000000000000000000000::Int64)\n21\n\
    julia", "    if n == 1 return 1\n    if n % 2 == 0 return n % prime_factors_of(n)[1]\n\
    \    return max(n % prime_factors_of(n), largest_prime_factor(n/2))\n</cell>\n\
    <code language=julia-1.3>\nlargest_prime_factor(131)\n</cell>\n<code language=julia-1.3>\n\
    @code_native largest_prime_factor(131)\n</cell>\n<text>\nQuestion 6: Which of\
    \ the following is faster, computing the largest prime factor by hand, or using\
    \ largest_prime_factor?", "    if n==2 return 1\n    let d=(2::Int64)::Int64\n\
    \    if n<2 return n\n    for i in (3,6)::Int64 do\n        if i*n==d return i\n\
    \        let d=n*d\n    end\nend\n</code>\n<|/ a dscore=3 |>\n<| a |>\nHere is\
    \ a more efficient solution that avoids using recursion.\n<code>", "  \n    if\
    \ n == 2 then \n        return 1\n    else if n < 2 then\n        return nil\n\
    \    else \n        # initialize np as next perfect square\n        np := next_prime(n+1)\n\
    \        \n        # check if np is prime\n        if np < n then\n          \
    \  return 1\n        else \n            # find largest factor of np - n\n    \
    \        x := largest_factor(np, n)\n            if x <> nil then\n          \
    \      return x\n            else \n                # find largest factor of np\
    \ - n - 1\n                y := largest_factor(np, n - 1)\n                if\
    \ y <> nil then\n                    return y\n                else \n       \
    \             # np > n - 1 or n is prime, return n\n                    return\
    \ np\n        end\nend", "    if n <= 1 \n        error \"n must be > 1 \"\n \
    \   elseif prime_number(n)\n        n \n    else \n        largest_prime_factor(n-1)\n\
    end", "    p := floor(sqrt(n)) \n    i := 2\n    s := 2\n    while(s <= p) do\
    \ \n        p := floor((p + i) / 2)\n        i += 2\n        s := 2 * p + 1\n\
    \    return p", "    if n == 1 \n        1\n    else \n        largest_prime_factor(sqrt(n))\
    \ \n    end\nend\n</cell>\n<code language=julia-1.6>\n\"\"\"A function to return\
    \ the factorial of n. Assume n > 1 and is not a prime.\n    >>> factorial(5)\n\
    \    120\n    >>> factorial(100)\n    3628800\n    \"\"\"", "    \n    prime_number\
    \ = 2\n    while prime_number <= n && prime_number < n\n        prime_number +=\
    \ 1\n    end", "    if n == 0 then\n        return 0\n    else if n == 1 then\n\
    \        return 1\n    else\n        return ceiling((sqrt(n) - 1) * (sqrt(n) +\
    \ 1))\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n`Int64` is unnecessary here.\
    \ `Int` will do just fine.\n<|/ c |>\n<| a |>\nThe naive prime sieves start with\
    \ 2, 3, 5 and 7 (the sieve of Eratosthenes starts with 1 and ends with sqrt(n)).\n\
    If all you need is the largest prime factor, then the sieve is all you need.\n\
    If efficiency is important, you can use a more advanced algorithm that starts\
    \ with the prime factors 1 and 3, and adds other primes one at a time until a\
    \ factor is found. This is called a sieve of Eratosthenes.\n<|/ a tags=primes,algorithm,prime-factoring,sieve-of-eratosthenes\
    \ dscore=0 |>\n<| c |>\nWhile this is a good answer, this would not be my first\
    \ choice for the Sieve of Eratosthenes as it is quite inefficient. There are a\
    \ number of other algorithms based on prime factors though, e.g. the one presented\
    \ at http://people.sc.fsu.edu/~jburkardt/py_src/primes4.html\n<|/ c |>\n<| c |>\n\
    I agree with you. My point is that the sieve is not all that necessary if the\
    \ OP only wants the largest prime factor. Eratosthenes is really a good algorithm\
    \ if you really want a better algorithm.\n<|/ c |>\n<| c |>\nEratosthenes is actually\
    \ pretty well optimized if you can reuse some of the work it does. That said,\
    \ there are better algorithms for finding the largest prime factor of large numbers.\
    \ However, I don't think the sieve is inefficient, it's just the worst case complexity.\n\
    <|/ c |>\n<| c |>\n: Eratosthenes is much better than trial division with multiple\
    \ threads and a lot of modulo operations, but a lot worse than most people think.\
    \  For small numbers, trial division is a very bad idea; for large numbers, trial\
    \ division is very, very slow.  For small numbers, trial division is slow, but\
    \ for larger numbers, it can be *much* slower.\n<|/ c |>\n<| a dscore=0 |>\nIf\
    \ your algorithm is working well and you need the maximum number, you can simply\
    \ use a counter variable that will hold the max number found.\nHere is your algorithm:",
  "    if n == 0 || n == 1 \n        return n \n    p :: Int64 = 1 \n    while p*p\
    \ <= n \n        p += 1 \n    p += 1 \n    while n % p == 0 \n        p += 1 \n\
    \    if n == p \n        return n \n    while p*p <= n \n        p += 1 \n   \
    \ if p*p > n \n        return n \n    while n % p == 0 \n        p += 1 \n   \
    \ return p \nend\n</cell>\n<code language=julia-1.6>\n@code_warntype largest_prime_factor(13195)\n\
    </cell>\n<text>\nExercise 7.02\nWrite a function prime_factors that accepts a\
    \ number, n, as an argument and returns an array containing the largest prime\
    \ factors of n.", "    if n <= 1 \n        2\n    else\n        largest = 2 \n\
    \        for factor in factors(n)\n            if factor > largest\n         \
    \       largest = factor \n            end\n        end\n        largest\n   \
    \ end\nend", "    ans = 1\n    if n == 1 \n        return ans \n    factor = 2\n\
    \    while factor <= sqrt(n) \n        test := n % factor\n        if test ==\
    \ 0 \n            factor *= factor \n        else \n            factor *= test\
    \ \n        ans = max(ans, factor)\n    return ans \nend\n</cell>\n<code language=julia-1.1>",
  "    if n % 2 == 1 \n        p := n // 2\n        while p*p <= n \n            p\
    \ := p + 1\n        return p\n    p := 3\n    while p * p <= n \n        p :=\
    \ p + 3\n    return p\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThe while loop should\
    \ probably be `p := n + 3`.\n<|/ c |>\n<| c |>\nThanks, it works. But I have another\
    \ question, how to make the program faster, I mean how to make it faster the code\
    \ that I wrote to find the largest prime factor of numbers?\n<|/ c |>\n<| c |>\n\
    It won't be faster, but you can try a different algorithm. Maybe this one: https://stackoverflow.com/a/56499141/2559297\n\
    <|/ c |>\n<| c |>\nIf performance is an issue, consider using Julia. There are\
    \ many algorithms readily available.\n<|/ c |>\n<| a |>\nThis answer is based\
    \ on a comment by on the question How to find out whether a given number is prime\
    \ or not. \nThe function is_prime(n::Int64) returns true if the n is prime. It\
    \ uses trial division which is a slow algorithm.\nThe function prime_factors(n::Int64)\
    \ returns a list with the prime factors of the number. It uses simple prime factorization\
    \ which takes linear time.\n<code>\n\"\"\"\nprime_factors(n::Int64)", "    if\
    \ n == 1 \n        1\n    else\n        if n % 2 == 0\n            largest_prime_factor(n/2)\n\
    \        else\n            largest = 2\n            for i in 3::Int64\n      \
    \          if  n % i == 0\n                    largest = i\n                 \
    \   break\n            end\n            largest * largest_prime_factor(n/largest)\n\
    \        end\n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert largest_prime_factor(55)\
    \ == 2\n@assert largest_prime_factor(29) == 29\n@assert largest_prime_factor(100)\
    \ == 7\n@assert largest_prime_factor(10**2) == 5\n@assert largest_prime_factor(20**2)\
    \ == 5\n@assert largest_prime_factor(20) == 5\n@assert largest_prime_factor(13)\
    \ == 13\n@assert largest_prime_factor(30) == 29\n@assert largest_prime_factor(27)\
    \ == 7\n</cell>\n<code language=julia-1.5>\n@assert largest_prime_factor(3) ==\
    \ 3\n@assert largest_prime_factor(10) == 3\n@assert largest_prime_factor(14) ==\
    \ 7\n@assert largest_prime_factor(30) == 3\n</cell>\n<text>\nFactoring out factors",
  "    p :: Int64 = 2\n    while p <= n && n % p == 0 do \n        p :: Int64 = p\
    \ + 2\n    end\n    return p", "    \"\"\"Helper function for largest_prime_factor\"\
    \"\"\n    if n <= 1\n        return 0\n    if n == 2\n        return 1\n    if\
    \ n % 2 == 0\n        return 2\n    if n % 3 == 0\n        return 3\n    smaller\
    \ = largest_prime_factor(n / 2)\n    if n % smaller == 0\n        return smaller\n\
    \    if n % smaller == 1\n        return smaller + 1\n    return smaller", "if\
    \ n == 0\n    throw(ZeroDivisionError)\nelseif n==1\n    return 1\nelse\n    if\
    \ n%2==0\n        return n\n    else\n        candidate = 2\n        while candidate*candidate<=n\n\
    \            candidate += 1\n        end\n        prime_factor = n//candidate\n\
    \        while prime_factor>1\n            prime_factor = prime_factor/2\n   \
    \     end\n        return candidate\n    end\nend\n\"\"\"", "    if n <= 1 \n\
    \    then return 1\n    if n <= 2 \n    then return 2\n    if n % 2 != 0 \n  \
    \  then return 3\n    if n % 3 == 0 \n    then return 3\n    if n % 5 != 0 \n\
    \    then return 5\n    if n % 7 != 0 \n    then return 7\n    return n \n   \
    \ end\n</code>\n<|/ a tags=performance,primes,julia dscore=0 |>\n<| c |>\nHi Jesse\
    \ -- could you please edit this with some explanation, rather than just dumping\
    \ code? That would help people understand what you've done and how it works.\n\
    <|/ c |>\n<| a tags=performance,primes,julia dscore=0 |>\nI wanted to add an alternative\
    \ solution, since my original one was pretty slow for the same reason:\n<code>",
  "    if n <= 1 \n        return n\n    else \n        if n % 2 == 0 \n         \
    \   return largest_prime_factor(n/2)\n        \n        \n        else if n %\
    \ 3 == 0 \n            return largest_prime_factor(n/3)\n        else \n     \
    \       return 3*(largest_prime_factor(n/3)) % n", "    for i in 2..n do \n  \
    \      if isprime(i) == false then \n            return i \n    return n \nend ",
  "    if n == 2\n        return 2\n    factor = 2\n    while factor < n\n       \
    \ if n % factor == 0\n            factor = factor + 1\n        else\n        \
    \    break\n    return factor\n</code>\n<|/ a dscore=0 |>\n<| a tags=primes,haskell,algorithm\
    \ |>\n<code>\nprimeFactors n = \n  filter (\\n -> n > 1) (takeWhile (<= n) (iterate\
    \ (+1) 2))\n</code>\n<|/ a dscore=0 |>\n<| c |>\nWhile this code may answer the\
    \ question, providing additional context regarding *how* and/or *why* it solves\
    \ the problem would improve the answer's long-term value.\n<|/ c |>\n<| a |>\n\
    A simple way to get prime factors up to a number is to use prime number sieve.\n\
    A prime number is a natural number greater than one which has no positive divisors\
    \ other than 1 and itself. A prime number sieve is a data structure that keeps\
    \ track of all natural numbers less than one which are not divisible by any prime\
    \ numbers. \nFor example if all prime factors of 30 are 3,5,7,11,13,17,19,23,29\
    \ then all prime factors of 30 are 2,3,4,6,9,12,18,30.\nTo get a list of the prime\
    \ factors of a number n we need to check if all prime factors are less than n.\
    \ If they are, they can be divided by n. \nThe prime number sieve is much more\
    \ efficient than the sieve of Eratosthenes. Here are some useful functions which\
    \ can help with building the sieve: primeFactors, isPrime, primesGreaterThan.\
    \ \nThe sieveOfEratosthenes function first creates the sieve of Eratosthenes and\
    \ then returns a list of the prime factors for numbers between 1 and n. \n<code>\n\
    import Data.List\nimport Data.Ord (comparing)", "if n < 2 \n    1 \nelseif n <\
    \ 3 \n    2 \nelse\n    largest_prime_factor(n % 6) + largest_prime_factor(n %\
    \ n % 6) + 1 \nend\nend\n</code>\n<|/ a dscore=4 |>\n<| a |>\n<code>\n#!/usr/bin/julia",
  "    if n == 1 \n        n \n    else if n % 2 == 0 \n        largest_prime_factor(n\
    \ / 2) \n    else \n        if n % 3 == 0 \n            largest_prime_factor(n\
    \ / 3) \n        else \n            if n % 5 == 0 \n                largest_prime_factor(n\
    \ / 5) \n            else \n                if n % 7 == 0 \n                 \
    \   largest_prime_factor(n / 7) \n                else \n                    if\
    \ n % 11 == 0 \n                        largest_prime_factor(n / 11) \n      \
    \              else \n                        if n % 13 == 0 \n              \
    \              largest_prime_factor(n / 13) \n                        else \n\
    \                            if n % 17 == 0 \n                               \
    \ largest_prime_factor(n / 17) \n                        else \n             \
    \               if n % 19 == 0 \n                                largest_prime_factor(n\
    \ / 19) \n                        else \n                            if n % 23\
    \ == 0 \n                                largest_prime_factor(n / 23) \n     \
    \                   else \n                            if n % 29 == 0 \n     \
    \                           largest_prime_factor(n / 29) \n                  \
    \      else \n                            if n % 37 == 0 \n                  \
    \              largest_prime_factor(n / 37) \n                        else \n\
    \                            if n % 47 == 0 \n                               \
    \ largest_prime_factor(n / 47) \n                        else \n             \
    \               if n % 59 == 0 \n                                largest_prime_factor(n\
    \ / 59) \n                        else \n                            if n % 71\
    \ == 0 \n                                largest_prime_factor(n / 71) \n     \
    \                   else \n                            if n % 73 == 0 \n     \
    \                           largest_prime_factor(n / 73) \n                  \
    \      else \n                            if n % 79 == 0 \n                  \
    \              largest_prime_factor(n / 79) \n                        else \n\
    \                            if n % 89 == 0 \n                               \
    \ largest_prime_factor(n / 89) \n                        else \n             \
    \               if n % 97 == 0 \n                                largest_prime_factor(n\
    \ / 97) \n                        else \n                            if n % 103\
    \ == 0 \n                                largest_prime_factor(n / 103) \n    \
    \                    else \n                            if n % 111 == 0 \n   \
    \                             largest_prime_factor(n / 111) \n               \
    \         else \n                            if n % 121 == 0 \n              \
    \                  largest_prime_factor(n / 121) \n                        else\
    \ \n                            if n % 131 == 0 \n                           \
    \     largest_prime_factor(n / 131) \n                        else \n        \
    \                    if n % 141 == 0 \n                                largest_prime_factor(n\
    \ / 141) \n                        else \n                            if n % 151\
    \ == 0 \n                                largest_prime_factor(n / 151) \n    \
    \                    else \n                            if n % 161 == 0 \n   \
    \                             largest_prime_factor(n / 161) \n               \
    \         else \n                            if n % 171 == 0 \n              \
    \                  largest_prime_factor(", "\tif n <= 1 \n\t\tthen return 1 \n\
    \telse if n % 2 == 0 \n\t\tthen return n \n\telse \n\t\tsmaller_n = n \n\t\twhile\
    \ smaller_n >= 2 \n\t\t\tdo smaller_n /= 2 \n\t\tlargest_prime_factor_2 = largest_prime_factor(smaller_n)\
    \ \n\t\tlargest_prime_factor_1 = largest_prime_factor(smaller_n-1) \n\t\tif largest_prime_factor_1\
    \ < largest_prime_factor_2 \n\t\t\tthen return largest_prime_factor_1 \n\t\telse\
    \ return largest_prime_factor_2 \nend\n</cell>\n<text>\nPrime Factors of a Number\n\
    Next, let's find all the prime factors of a given number. We'll write a function\
    \ to do this, then we can use it in our next exercise.", "    if n % 2 == 0 \n\
    \        then return 2\n        else return n % largest_prime_factor(n / 2)\n\
    </code>\nThe other part of the proposed algorithm can be translated to Julia as\
    \ follows:\n<code>", "  if n==1 then return 1\n  for i in 1..n do \n    if sieve[i]\
    \ == 1 then return i else return i\n  end \nend \n</cell>\n<text>\nWrite a function\
    \ prime_factors(n) that returns the prime factors of n as a list.\nFor example,\
    \ prime_factors(12) should return [2, 3].", "    for d in 2:(n-1)\n        if\
    \ isPrime(d)\n            return d \n</code>\nThe function largest_prime_factor(n)\
    \ returns the largest prime factor of n.\n<|/ a dscore=1 tags=python-3.x |>\n\
    <| c |>\nThank you so much! It has really helped me!\n<|/ c |>\n<| c |>\nWelcome.\
    \ Don't forget to accept my answer, if it helped you.\n<|/ c |>\n<| a dscore=0\
    \ |>\nThe algorithm you've implemented is more of a brute force one. Here's the\
    \ solution of Karatsuba multiplication, which was proven to be a very efficient\
    \ way of multiplication.\n<code>\ndef karatsuba_multiplication(n, m):\n    if\
    \ (n <= 0 or m <= 0):\n        return None\n    \n    if m == 0:\n        return\
    \ n\n    \n    if n == 1:\n        return m\n    \n    if (n < 5):\n        return\
    \ karatsuba_multiplication(n - 1, m * m) + m\n    \n    else:\n        a = karatsuba_multiplication(n\
    \ - 1, m)\n        b = karatsuba_multiplication(n - 2, m)\n        return karatsuba_multiplication(n\
    \ - 3, m * m) + a * b\n</code>\n<|/ a tags=python-3.x |>\n<| c |>\nThank you!\
    \ I will try it!\n<|/ c |>\n<| c |>\nI did it! Thanks for your help!\n<|/ c |>\n\
    <| a dscore=0 |>\nI wrote a Python 3 solution which I believe to be optimal. The\
    \ code below generates the prime factors of a given number. As you may notice\
    \ from the output below, there are factors larger than a million (the maximum\
    \ of a 64-bit int).\n<code>\ndef factors(n):\n    import math\n    factors = []\n\
    \    \n    while n > 1:\n        factors.append(int(math.sqrt(n)))\n        n\
    \ //= factors[-1]\n        \n        if n % factors[-1] == 0:\n            factors[-1]\
    \ += 1\n            break\n    \n    return factors", "    if n < 2 \n       \
    \ then return n\n    else if n % 2 == 0 \n        then return largest_prime_factor(n/2)\n\
    \    else \n        f := largest_prime_factor(n/3)\n        if f > n \n      \
    \      then return f \n        else return n\nend\n\"\"\"Return the smallest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n    >>> smallest_prime_factor(13195)\n\
    \    3\n    >>> smallest_prime_factor(2048)\n    3\n    \"\"\"", "    if n ==\
    \ 1 \n        1\n    else if n % 2\n        largest_prime_factor(n / 2)\n    else\
    \ \n        if n < 13\n            n \n        else\n            largest_prime_factor(n\
    \ / 2)\n        end\n    end\nend\n</cell>\n<code language=julia-0.4>\nlargest_prime_factor(8)\n\
    </cell>\n<text>\nProblem 9: Fibonacci numbers\nGiven the function fib(n) that\
    \ calculates the n-th term of the Fibonacci sequence and returns the result as\
    \ an integer, write a Julia function to find the n-th term of the Fibonacci sequence.",
  "    if n<2\n    then return 1\n    else if n%3 == 0\n    then return n\n    else\
    \ if n % 2 == 0\n    then return 3\n    else if n % 3 == 0\n    then return n\n\
    \    else if n % 5 == 0\n    then return 5\n    else if n % 7 == 0\n    then return\
    \ 7\n    else return largest_prime_factor(n/3) + 1\nend\n</cell>\n<code language=julia-1.2>",
  "    if n<2 return n\n    let candidates=prime_factors(n)\n    let largest=candidates[1]\n\
    \    for factor in candidates[2..] do\n        if largest*factor>n then\n    \
    \        largest=factor\n    return largest", "    n <= 1 && return 1\n    n <=\
    \ 2 && return 2\n    n <= 3 && return 3\n    \n    if primes_sieve[n] == 1 \n\
    \        return n", "    largest_prime_factor <- 0 \n    for factor in prime_factors(n)\
    \ do \n        if factor > largest_prime_factor then \n            largest_prime_factor\
    \ <- factor \n        end\n    end\n    largest_prime_factor\nend\n</cell>\n<text>\n\
    Problem 4", "    return ceiling(log(n, 2))\nend\n</cell>\n<code language=julia-1.3>\n\
    @time largest_prime_factor(2^(10^9))\n</cell>\n<text>\nQ2. Write a function that\
    \ finds the largest prime factor of n that is less than or equal to n.\n    >>>\
    \ largest_prime_factorless_than(100)\n    7\n    >>> largest_prime_factorless_than(1000)\n\
    \    7\n    >>> largest_prime_factorless_than(1001)\n    8\n    \"\"\"", "  if\
    \ n % 2 == 0 \n    then \n      return(largest_prime_factor(n / 2))\n  else \n\
    \    if n % 3 == 0 \n    then \n      return(largest_prime_factor(n / 3))\n  \
    \  else \n      return(largest_prime_factor(n / 5))", "    if n % 2 == 0 \n  \
    \      then return n \n    elseif n % 3 == 0 \n        then return n \n    elseif\
    \ n % 5 ==0 \n        then return n \n    elseif n % 7 == 0 \n        then return\
    \ n \n    elseif n % 11 ==0 \n        then return n \n    else \n        largest_prime_factor(floor(sqrt(n)))\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@time largest_prime_factor(1_000_000);\n\
    </cell>\n<text>\nEx 2: What is the smallest prime factor of the number 600851475143?",
  "    if n==1 \n        1\n    else if n==2\n        2 \n    else\n        largest_prime_factor(n/2)\n\
    \    end\nend\n</cell>\n<code language=julia-1.4>\nlargest_prime_factor(10000)\n\
    </cell>\n<text>\nThe above function works but we can make it much more efficient\
    \ by using a sieve", "    if n < 2\n        return n\n    factors = prime_divisors(n)\n\
    \    largest = factors[1]\n    for factor in factors[2:]\n        if factor >\
    \ largest\n            largest = factor\n    return largest", "    if n <= 2 \n\
    \        return 1 \n    else if n % 2 == 0 \n        return largest_prime_factor(n/2)\
    \ \n    else \n        return (largest_prime_factor(sqrt(n)) \n              \
    \  * largest_prime_factor(sqrt(n) - 1))", "    if n == 1 \n        2 \n    else\
    \ if n == 2 \n        1 \n    else if n % 2 == 0 \n        largest_prime_factor(n\
    \ / 2)\n    elseif n == 3 \n        1 \n    else if n % 3 == 0 \n        largest_prime_factor(n\
    \ / 3)\n    elseif n % 6 == 0 \n        largest_prime_factor(n / 6)\n    else\n\
    \        largest_prime_factor(n / 6) + largest_prime_factor(n / 3)\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    prime_factor(n)", "    if\
    \ n == 1 \n        return 2\n    factor = 2\n    factor = 1\n    while factor\
    \ < n \n        if n % factor  == 0  \n            factor = factor * 2\n     \
    \   else \n            factor = factor + 1\n    end\n    return factor", "   \
    \ flag=0\n    factor=1;\n    while flag==0 \n        factor=factor+1 \n      \
    \  flag=isPrime(factor) \n    end\n    return factor \nend\n</code>\n<|/ a |>\n\
    <| a dscore=2 |>\nThis should work:\n<code>", "    if n==1 \n        1\n    else\n\
    \        (3::Int64)^((n-1)::Int64)\n    end\nend\n</cell>\n<text>\nProblem 5\n\
    Using the previous functions, write a function called smallest_prime_factor(largest_prime_factor(n::Int64)).\
    \ This function should return the smallest prime factor of n. Assume n > 1 and\
    \ is not a prime.\n    >>> smallest_prime_factor(29)\n    3\n    >>> smallest_prime_factor(2)\n\
    \    1\n    \"\"\"", "    if n < 2 return n\n    if n == 2 return 1\n    \n  \
    \  m := 2\n    p := n\n    factor := 1\n    while p*p <= m do\n        if p %\
    \ m == 0 then\n            p := p / m\n            factor := factor * m\n    \
    \    else\n            p := p * m\n            factor := factor * m\n        end\n\
    \        m += 2\n    end\n    return factor\nend\n</cell>\n<code language=julia-1.0>",
  "    largest = 1\n    factor = 2\n    while factor <= n do\n        if n % factor\
    \ == 0 then\n            largest = factor\n        else\n            factor +=\
    \ 1\n    end\n    return largest", "    largest_prime = 1\n    while (n > largest_prime)\n\
    \        largest_prime *= 2\n    while (n > largest_prime)\n        largest_prime\
    \ += 1\n    return largest_prime\n</code>\n<|/ a dscore=0 tags=sieve-of-eratosthenes,primes,performance,haskell,optimization\
    \ |>\n<| a dscore=0 tags=sieve-of-eratosthenes,primes,performance,haskell,optimization\
    \ |>\nI'm assuming that you do not have to worry about non-primes.\n<code>\nimport\
    \ Data.List (isPrefixOf, sortBy, snoc)", "    # write your code in Julia 1.0\n\
    \    prime_factor = 2\n    while n % prime_factor == 0\n        prime_factor *=\
    \ 2\n    end\n    return prime_factor\nend \n</code>\n<|/ a tags=julia,primes,factors\
    \ |>\n<| c |>\nWhat is the advantage of using Int over Int64 here?\n<|/ c |>\n\
    <| c |>\nInt is the default type. Int64 is the more general type. It can be useful\
    \ when working with really big integers or in other contexts. Julia 1.0 was released\
    \ some time ago, while Int was still the default type. Int64 has become default\
    \ in later versions.\n<|/ c |>\n<| a |>\nA Julian solution:\n<code>\njulia> function\
    \ primes(n::Int)\n           n == 2 || n % 2 != 0       && return n\n        \
    \   n == 3 || n % 3 != 0       && return n\n           n == 4 || n % 4 != 0  \
    \     && return n\n           n > 5                        && return n\n     \
    \      n = 6 + 11 * (n - 2)         && return n\n           i = 2\n          \
    \ while i <= sqrt(n)\n               if n % i == 0\n                  return false\n\
    \               end\n               i += 2\n           end\n           return\
    \ true\n       end", "    if n < 2 then\n        2\n    else\n        let max_number\
    \ = n / 2\n        largest_prime_factor(max_number)\n        if n % max_number\
    \ == 0 then\n            largest_prime_factor(n+1)\n        else\n           \
    \ n \n        end\n    end\nend\n</cell>\n<text>\nConsider the following code:",
  "    | n % 2 == 0 && n < 3 -> n \n    | n % 2 == 0 && n > 3 -> largest(2, n) \n\
    \    | n % 2 == 1 -> largest(3, n) \n    | n % 2 == 0 -> largest(3, largest(2,\
    \ n-1)) \n    | n <= 1 -> n\n    | n <= 2 -> 2\n    | n <= 4 -> largest(largest(3,largest(2,\
    \ n-2)), 2)\n    | n <= 9 -> largest(largest(3,largest(2, n-3)), 2)\n    | n <=\
    \ 16 -> largest(largest(3,largest(2, n-4)), 2)\n    | n <= 25 -> largest(largest(3,largest(2,\
    \ n-5)), 2)\n    | n <= 36 -> largest(largest(3,largest(2, n-6)), 2)\n    | n\
    \ <= 49 -> largest(largest(3,largest(2, n-7)), 2)\n    | n <= 64 -> largest(largest(3,largest(2,\
    \ n-8)), 2)\n    | n <= 81 -> largest(largest(3,largest(2, n-9)), 2)\n    | n\
    \ <= 100 -> largest(largest(3,largest(2, n-10)), 2)\n    | n <= 125 -> largest(largest(3,largest(2,\
    \ n-11)), 2)\n    | n <= 150 -> largest(largest(3,largest(2, n-12)), 2)\n    |\
    \ n <= 175 -> largest(largest(3,largest(2, n-13)), 2)\n    | n <= 200 -> largest(largest(3,largest(2,\
    \ n-14)), 2)\n    | n <= 225 -> largest(largest(3,largest(2, n-15)), 2)\n    |\
    \ n <= 250 -> largest(largest(3,largest(2, n-16)), 2)\n    | n <= 275 -> largest(largest(3,largest(2,\
    \ n-17)), 2)\n    | n <= 300 -> largest(largest(3,largest(2, n-18)), 2)\n    |\
    \ n <= 325 -> largest(largest(3,largest(2, n-19)), 2)\n    | n <= 360 -> largest(largest(3,largest(2,\
    \ n-20)), 2)\n    | n <= 395 -> largest(largest(3,largest(2, n-21)), 2)\n    |\
    \ n <= 420 -> largest(largest(3,largest(2, n-22)), 2)\n    | n <= 455 -> largest(largest(3,largest(2,\
    \ n-23)), 2)", "    if n < 2\n        1\n    else \n        if n == 2\n      \
    \      1\n        else\n            if n % 2 == 0\n                largest = 2\n\
    \            else\n                largest = largest_prime_factor(n/2)\n     \
    \       return largest * largest\nend\n</cell>\n<text>\nNow we can get the largest\
    \ prime factor of $n$ by calling the function:", "    if n <= 1 \n        1\n\
    \    else \n        largest_prime_factor(n-1) + 2\n    end\nend\n</code>\n<|/\
    \ a tags=julia |>\n<| a dscore=0 |>\nThis is how I implemented the function in\
    \ Julia that returns the largest prime factor:\n<code>", "    if (n <= 1) || (n\
    \ % 2 == 0) \n    then 1\n    else if (n % 3 == 0) \n    then (largest_prime_factor(n\
    \ / 3))\n    else (largest_prime_factor(n / 2))\nend", "    primes = [3,5,7,11,13,17]\n\
    \    for p in primes\n        if n % p == 0\n            return p\n    return\
    \ n \nend\n</cell>\n<code language=julia-1.1>\nlargest_prime_factor(13195)\n</cell>\n\
    <text>\nRecall that $\\sqrt{n}$ is the square root of $n$:", "    if n<2\n   \
    \     throw(DomainError(\"n must be >= 2\"))\n    end", "    # your code here\n\
    \    if n < 2 then return 1\n    if n == 1 then return 1\n    if n > 1 then\n\
    \        largest = 1\n        for i in 2..n do\n            if n % i == 0 then\n\
    \                if largest * i > n then\n                    largest = i\n  \
    \              else\n                    largest = largest * i\n            end\n\
    \        end\n    end\n    return largest\nend\n</cell>\n<code language=julia-1.0>\n\
    largest_prime_factor(13195)\n</cell>\n<code language=julia-1.0>\nlargest_prime_factor(2048)\n\
    </cell>\n<code language=julia-1.0>\n\"\"\"Return the smallest prime factor of\
    \ n. Assume n > 1 and is not a prime.\n    >>> smallest_prime_factor(13195)\n\
    \    3\n    >>> smallest_prime_factor(2048)\n    2\n    \"\"\"", "    if n < 2\
    \ return 1\n    n -= 2\n    i = 1\n    while i < n \n        i += 1\n        if\
    \ n % i == 0 \n            return i\n    return n \nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Return the smallest prime factor of n. Assume n > 1 and is not a prime.\n\
    \    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n\
    \    2\n    \"\"\"", "    mutable largest = 1\n    for p in primes_upto(n) do\
    \ \n        if n % p == 0 then largest = p\n    end\n    return largest\nend\n\
    </cell>\n<text>\nWhat is a prime number?", "    if n < 2 || n % 2 == 0 \n    \
    \    then return 2\n    else \n        (p1,p2) = (2,n)//2\n        while p2 >\
    \ 1\n            do\n                (p,p2) = (p2,(p*p2)%n)\n            done\n\
    \        return p\nend\n</cell>\n<code language=julia-1.5>\n@time largest_prime_factor(10000)\n\
    </cell>\n<code language=julia-1.5>\n@time largest_prime_factor(100000)\n</cell>\n\
    <code language=julia-1.5>\n@time largest_prime_factor(1000000)\n</cell>\n<text>\n\
    Q: What is the largest prime factor of 100000000000000?", "    if n==1 return\
    \ 1\n    factor::Int64 = 1\n    factor::Int64 = 2 \n    while factor < n \n  \
    \      if n%factor == 0 \n            factor += 1\n        else\n            factor\
    \ = 1\n        end \n    end \n    largest_prime_factor = factor \nend \n</cell>\n\
    <cell>\n\"\"\"Given a positive integer n, count the number of the largest prime\
    \ factors.\n    Implement a function to return the number of factors of n that\
    \ are smaller than n.\n    >>> largest_prime_factors(10)\n    1\n    >>> largest_prime_factors(5)\n\
    \    3\n    \"\"\"", "    largest = 1\n    for prime in prime_factors(n) do \n\
    \        if n > prime \n            largest = prime\n            break\n    return\
    \ largest\n</code>\n<|/ a |>\n<| c |>\nPlease don't use backticks for formatting\
    \ code fragments. It doesn't add anything and it just makes it harder to read.\
    \ Also, the `else` statement after the `for` loop will never be executed if the\
    \ `for` loop finished normally. Finally, the code you posted doesn't even work\
    \ because you've got an extra `}` before the `end`.\n<|/ c |>\n<| c |>\nThanks\
    \ for your comment. "]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
