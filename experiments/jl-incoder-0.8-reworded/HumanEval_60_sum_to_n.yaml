name: HumanEval_60_sum_to_n
language: jl
prompt: "\"\"\"sum_to_n is a function that sums numbers from 1 to n.\n    >>> sum_to_n(30)\n\
  \    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>>\
  \ sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\nfunction sum_to_n(n::Int64)::Int64\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = sum_to_n;\n\t@test(candidate(1)\
  \ == 1)\n\t@test(candidate(6) == 21)\n\t@test(candidate(11) == 66)\n\t@test(candidate(30)\
  \ == 465)\n\t@test(candidate(100) == 5050)\nend\n"
completions: ["    return (fromIntegral(1)..fromIntegral(n)).foldl(+, 0)\nend ", " \
    \   if n < 1\n        error(\"n must be a positive integer and greater than 0\"\
    )\n    else if n == 0\n        0\n    else if n == 1\n        n\n    else\n  \
    \      sum_to_n(n - 1) + n\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    sum_to_n(50)\n</cell>\n<text>\n(4) Factorials\nThe factorial function computes\
    \ factorials. A factorial $n$ is a number such as $1$, that has all positive divisors\
    \ such as $2$, $3$, $5$, and so on.", "    if n<=1\n        1\n    else\n    \
    \    n*sum_to_n(n-1)\nend", "    if n == 0\n        1\n    else\n        sum(1\
    \ to n) + sum_to_n(n-1)\nend\n</cell>\n<text>\nFunctional Programming\nWhen you\
    \ write a program in languages like Haskell, Scala, Clojure or ML, that uses pattern\
    \ matching to execute code based on a certain data structure, it can also be considered\
    \ functional. A function is a procedure that takes data as input and gives some\
    \ output. Functional programming is a style of programming in which you write\
    \ functions in terms of other functions. The \"higher order function\" approach\
    \ to programming is very common and an important paradigm in functional programming.",
  "    if n <= 0\n        error(\"Sum to n not implemented for negative numbers\"\
    )\n    end\n    if n <= 1\n        return n\n    else\n        return n-1+sum_to_n(n-1)\n\
    \    end\nend\n\"\"\"\n    sum_to_n(100)", "    if n < 0 \n        error(\"n must\
    \ be >= 0\")\n    else if n < 10 \n        return n\n    else if n < 20 \n   \
    \     return n*10\n    else if n < 100 \n        return n*100\n    else if n <\
    \ 1000 \n        return n*1000\n    else if n < 10000 \n        return n*10000\n\
    \    else if n < 100000 \n        return n*100000\n    else if n < 1000000 \n\
    \        return n*1000000\n    else if n < 10000000 \n        return n*10000000\n\
    \    else if n < 100000000 \n        return n*100000000\n    else if n < 1000000000\
    \ \n        return n*1000000000\n    else if n < 10000000000 \n        return\
    \ n*10000000000\n    else if n < 100000000000 \n        return n*100000000000\n\
    \    else if n < 1000000000000 \n        return n*1000000000000\n    else if n\
    \ < 10000000000000 \n        return n*10000000000000\n    else if n < 100000000000000\n\
    \        return n*100000000000000\n    else if n < 1000000000000000 \n       \
    \ return n*1000000000000000\n    else if n < 10000000000000000 \n        return\
    \ n*10000000000000000\n    else if n < 100000000000000000 \n        return n*100000000000000000\n\
    \    else if n < 1000000000000000000 \n        return n*1000000000000000000\n\
    \    else if n < 10000000000000000000 \n        return n*10000000000000000000\n\
    \    else if n < 100000000000000000000 \n        return n*100000000000000000000\n\
    \    else if n < 1000000000000000000000 \n        return n*1000000000000000000000\n\
    \    else if n < 10000000000000000000000\n        return n*10000000000000000000000\n\
    \    else if n < 100000000000000000000000 \n        return n*100000000000000000000000\n\
    \    else if n < 1000000000000000000000000 \n        return n*1000000000000000000000000\n\
    \    else if n < 10000000000000000000000000 \n        return n*10000000000000000000000000\n\
    \    else if n < 100000000000000000000000000 \n        return n*100000000000000000000000000\n\
    \    else if n < 1000000000000000000000000000 \n        return n*1000000000000000000000000000\n\
    \    else if n < 10000000000000000000000000000 \n        return n*10000000000000000000000000000\n\
    \    else if n < 100000000000000000000000000000 \n        return n*100000000000000000000000000000\n\
    \    else if n < 1000000000000000000000000000000 \n        return n*1000000000000000000000000000000\n\
    \    else if n < 10000000000000000000000000000000 \n        return n*10000000000000000000000000000000\n\
    \    else if n < 100000000000000000000000000000000 \n        return n*100000000000000000000000000000000\n\
    \    else if n < 1000000000000000000000000000000000 \n        return n*1000000000000000000000000000000000\n\
    \    else if n < 10000000000000000000000000000000000 \n        return n*10000000000000000000000000000000000\n\
    \    else if n < 100000000000000000000000000000000000 \n        return n*10000000000000000000000000000000000",
  "if n < 1\n    error(\"n must be positive integer\") \nelse if n < 4\n    10\nelse\
    \ if n < 13\n    16\nelse if n < 28\n    19\nelse if n < 55\n    20\nelse\n  \
    \  30\nend\nend\n</cell>\n<text>\nOk, let's put it all together. As you can see,\
    \ our function looks quite a lot like a math equation!", "    if n <= 0\n    then\
    \ return 0\n    else return n*(n+1)/2\nend \n</cell>\n<code language=julia-1.6>\n\
    sum_to_n(10)\n</cell>\n<code language=julia-1.6>\nsum_to_n(100)\n</cell>\n<code\
    \ language=julia-1.6>\nsum_to_n(50)\n</cell>\n<code language=julia-1.6>\nsum_to_n(10)\n\
    </cell>\n<code language=julia-1.6>\nsum_to_n(15)\n</cell>\n<code language=julia-1.6>\n\
    sum_to_n(20)\n</cell>\n<code language=julia-1.6>\nsum_to_n(30)\n</cell>\n<code\
    \ language=julia-1.6>\nsum_to_n(500)\n</cell>\n<code language=julia-1.6>\nsum_to_n(600)\n\
    </cell>\n<code language=julia-1.6>\nsum_to_n(700)\n</cell>\n<code language=julia-1.6>\n\
    sum_to_n(800)\n</cell>\n<code language=julia-1.6>\nsum_to_n(900)\n</cell>\n<code\
    \ language=julia-1.6>\nsum_to_n(1000)\n</cell>\n<code language=julia-1.6>\nsum_to_n(1500)\n\
    </cell>\n<code language=julia-1.6>\nsum_to_n(1800)\n</cell>\n<code language=julia-1.6>\n\
    sum_to_n(3000)\n</cell>\n<code language=julia-1.6>\nsum_to_n(5000)\n</cell>\n\
    <code language=julia-1.6>\nsum_to_n(6000)\n</cell>\n<code language=julia-1.6>\n\
    sum_to_n(7000)\n</cell>\n<code language=julia-1.6>\nsum_to_n(8000)\n</cell>\n\
    <code language=julia-1.6>\nsum_to_n(9000)\n</cell>\n<code language=julia-1.6>\n\
    sum_to_n(10000)\n</cell>\n<code language=julia-1.6>\nsum_to_n(11500)\n</cell>\n\
    <code language=julia-1.6>\nsum_to_n(12000)\n</cell>\n<code language=julia-1.6>\n\
    sum_to_n(14500)\n</cell>\n<code language=julia-1.6>\nsum_to_n(16000)\n</cell>\n\
    <code language=julia-1.6>\nsum_to_n(18000)\n</cell>\n<code language=julia-1.6>\n\
    sum_to_n(20000);\n</cell>\n<code language=julia-1.6>\nsum_to_n(22000);\n</cell>\n\
    <code language=julia-1.6>\nsum_to_n(24000);\n</cell>\n<code language=julia-1.6>\n\
    sum_to_n(25000);\n</cell", "    if n==0 then return 0\n    if n==1 then return\
    \ 1\n    else return n*(n+1)/2\nend", "    if n == 1\n        1\n    else\n  \
    \      sum_to_n(n - 1) + 1", "    if n == 0 \n        1\n    else\n        sum_to_n(n-1)+n\n\
    \    end\nend\n</cell>\n<code language=julia-1.0>\nsum_to_n(3)\n</cell>\n<code\
    \ language=julia-1.0>\n\"\"\"counting_sum is a function that returns counting\
    \ sum of numbers from 1 to n.\n    \n    >>> counting_sum(30)\n    45\n    >>>\
    \ counting_sum(100)\n    5050\n    >>> counting_sum(5)\n    15\n    >>> counting_sum(10)\n\
    \    55\n    >>> counting_sum(1)\n    1\n\"\"\"", "    if n <= 0\n        error(\"\
    n must be positive\")\n    else if n == 1\n        return 1\n    else\n      \
    \  return sum_to_n(n - 1) + 1\nend", "    if n == 0\n        0\n    elseif n ==\
    \ 1\n        1\n    else\n        (n * (n+1)) / 2\n    end\nend", "    if n<0\n\
    \        error(\"Sum to negative numbers not supported\",n)\n    else\n      \
    \  return (n-1)*(n-2)/2+(n-3)/3\n    end\nend\n\"\"\"\n    sum_to_n!(n::Int64)\
    \ = sum_to_n(n)\nend", "    if n == 1 \n        then n \n    else n + sum_to_n(n-1)\
    \ \nend\n</cell>\n<code language=julia-1.5>\nsum_to_n(50)\n</cell>\n<code language=julia-1.5>\n\
    sum_to_n(10)\n</cell>\n<code language=julia-1.5>\nsum_to_n(1)\n</cell>\n<code\
    \ language=julia-1.5>", "\"\"\"\n\"\"\"\n# Exercise 8.4\n\"\"\"\n    >>> sum_to_n(-1)\n\
    \    Traceback (most recent call last):\n    ...\n    ArgumentError: Negative\
    \ numbers do not make sense\n    >>> sum_to_n(0)\n    Traceback (most recent call\
    \ last):\n    ...\n    ArgumentError: Zero numbers do not make sense\n    \"\"\
    \"", "    if n == 1 \n        1 \n    else \n        sum_to_n(n - 1) + n\n   \
    \ end\nend\n</cell>\n<code language=julia-1.0>\nsum_to_n(10)\n</cell>\n<code language=julia-1.0>\n\
    sum_to_n(50)\n</cell>\n<code language=julia-1.0>\nsum_to_n(100)\n</cell>\n<code\
    \ language=julia-1.0>\nsum_to_n(200)\n</cell>\n<code language=julia-1.0>\nsum_to_n(50)\n\
    </cell>\n<code language=julia-1.0>\nsum_to_n(5)\n</cell>\n<code language=julia-1.0>\n\
    sum_to_n(1)\n</cell>\n<code language=julia-1.0>", "    if (n < 1)\n        error(\"\
    n must be > 0\")\n    else\n        sum_to_n(n - 1)\nend\n</cell>\n<code language=julia-0.5>\n\
    sum_to_n(30)\n</cell>\n<code language=julia-0.5>\nsum_to_n(100)\n</cell>\n<code\
    \ language=julia-0.5>\nsum_to_n(5)\n</cell>\n<code language=julia-0.5>\nsum_to_n(10)\n\
    </cell>\n<code language=julia-0.5>\nsum_to_n(1)\n</cell>\n<code language=julia-0.5>",
  "    if n < 1 \n        error(\"n must be positive\")\n    else if n == 1\n    \
    \    1\n    else if n % 2 == 0\n        n * (sum_to_n(n / 2)) + 1\n    else\n\
    \        n * (sum_to_n(n / 2) + sum_to_n(n-1))\nend", "    if n == 0 \n      \
    \  then return 0\n    else \n        sum_to_n(n - 1) + (n - 1)\nend\n</cell>\n\
    <code language=julia-1.4>\nsum_to_n(10)\n</cell>\n<code language=julia-1.4>\n\
    sum_to_n(20)\n</cell>\n<text>\nProblem 4\nWrite a Julia function called sum_to_n_recursive\
    \ that sums numbers from 1 to n.\nThis function should use a while loop and call\
    \ the sum_to_n function.\nThe function should return an error if the user inputs\
    \ a number less than 1 or greater than n.", "    if n<0\n    then return -1\n\
    \    else return n*(n+1)/2", "    if n < 0 \n        error(\"n must be positive\"\
    )\n    else if n < 1 \n        error(\"n must be greater than 1\")\n    else \n\
    \        if n % 2 == 0 \n            error(\"n must be an even number\")\n   \
    \     else \n            return n*(n+1)/2", "    sum_num = 1\n    for i in 1:n\n\
    \        sum_num += i\n    return sum_num\nend", "    if n < 0\n    then return\
    \ error(\"Invalid input\")\n    else if n < 1\n    then return n\n    else if\
    \ n == 1\n    then return 1\n    else return n*(sum_to_n(n-1)) + 1\nend\n</cell>\n\
    <text>\nExercise #4\nWrite a function which prints the numbers from 0 to $n$,\
    \ one per line.\nThe $i^{th}$ number should begin at $i$.", "    if n < 2\n  \
    \  then\n        1\n    else\n        sum_to_n(n - 1) + 1\n    end\nend", "  \
    \  if n<0\n        error(\"n must be positive\")\n    end\n    return n*(n+1)/2",
  "    if n <= 0\n        error(\"sum_to_n : n must be positive\")\n    else\n   \
    \     sum = 1\n        for i in 1 .. n\n            sum = sum + i\n    end\n \
    \   return sum\nend\n</cell>\n<code language=julia-1.4>\nsum_to_n(3)\n</cell>\n\
    <code language=julia-1.4>", "    if n==0 \n        then return 1\n    else if\
    \ n<0 \n        then return 0\n    else \n        return sum_to_n(n - 1) + 1\n\
    end \n\"\"\"\nThe function count_to_n is a function that counts numbers from 1\
    \ to n.\n    >>> count_to_n(30)\n    465\n    >>> count_to_n(100)\n    5050\n\
    \    >>> count_to_n(5)\n    15\n    >>> count_to_n(10)\n    55\n    >>> count_to_n(1)\n\
    \    1\n    \"\"\"", "    if n < 1\n        error(\"The sum must be at least 1.\"\
    )\n    end\n    return sum(1 for i in 1 .. n-1)", "    if n <= 0\n    then return\
    \ 0\n    else if n < 10\n    then return n\n    else return sum_to_n(n - 1) +\
    \ n\nend\n</cell>\n<code language=julia-1.0>\nsum_to_n(10)\n</cell>\n<code language=julia-1.0>\n\
    sum_to_n(50)\n</cell>\n<code language=julia-1.0>", "    if n <= 0\n    then return\
    \ 0\n    else return n `mod` 2 `+` sum_to_n (n - 1)\nend\n</code>\n<|/ a tags=julia,recursion\
    \ dscore=3 |>\n<| a tags=julia,recursion |>\nJust for kicks, I wanted to take\
    \ a crack at this.  I used two global variables to keep track of which number\
    \ we are currently looking at, and how many we have seen.  I use a global variable\
    \ because I wanted to be able to call this function from other functions.  Here's\
    \ the code:\n<code>", "    if n == 0 \n    then \n        return 0 \n    else\
    \ \n        return n + sum_to_n(n - 1)\nend", "    if n <= 1\n        then 1\n\
    \        else n * sum_to_n(n-1)\nend\n\"\"\"\n    sum_to_n(n::Float64)::Float64\n\
    \    \nThe sum of all numbers from 1 to n.\n    \n    >>> sum_to_n(10)\n    55\n\
    \    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(30)\n\
    \    465\n    >>> sum_to_n(1)\n    1\n    \"\"\"", "    if n < 0 \n        error(\"\
    The argument must be a positive number.\")\n    else if n == 0 \n        0\n \
    \   else \n        sum_to_n(n - 1) + 1\nend\n</cell>\n<text>\nWhat is happening\
    \ above? Well, when we call sum_to_n with argument 10, the function recursively\
    \ calls itself again and again and again and again until it reaches the base case.\
    \ At that point, it's done! The function returns 11. Clearly that's not what we\
    \ want. We want it to sum numbers from 1 to n. So that's what we need to do:",
  "    return (if n <= 0 then 0 else n) + (if n > 0 then sum_to_n(n-1)) else 0\nend",
  "    if (n < 1)\n        error(\"sum_to_n is only defined for n>=1\")\n    return\
    \ n + (n-1)*(n - 2)*(n-3) ", "    if n == 0\n        0\n    else\n        n +\
    \ sum_to_n(n - 1)\nend # sum_to_n", "    if n == 0 \n        then return 1\n \
    \   else \n        sum_to_n(n - 1) + 1\nend", "    if n <= 0\n        error(\"\
    n must be positive\")\n    end\n    return sum(range(1,n))", "    if (n < 1) ||\
    \ (n > Int64(1)) \n        error(\"Input must be positive integer\")\n    \n \
    \   sum::Int64 = 0\n    for i in 1:n\n        sum += i\n    end\n    return sum\n\
    end\n</cell>\n<code language=julia-1.0>\nsum_to_n(30)\n</cell>\n<code language=julia-1.0>\n\
    sum_to_n(100)\n</cell>\n<code language=julia-1.0>\nsum_to_n(5)\n</cell>\n<code\
    \ language=julia-1.0>\nsum_to_n(10)\n</cell>\n<code language=julia-1.0>\nsum_to_n(1)\n\
    </cell>\n<text>\nTask 2\nWrite a function that returns the minimum number from\
    \ a given array.", "    if n <= 0 \n    then n\n    else n + sum_to_n(n - 1)\n\
    \    end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease explain what your code\
    \ does and how it works.\n<|/ c |>\n<| c |>\nWhat is the difference between `n\
    \ <= 0` and `n <= 1`?\n<|/ c |>\n<| a dscore=0 |>\nHere is the code you might\
    \ want to use to solve your problem. I am providing you two ways of solving your\
    \ problem one using tail recursion and other using iteration.\nCode for using\
    \ tail recursion\n<code>", "    if n <= 0\n        error(\"n must be positive\"\
    )\n    elseif n < 1\n        error(\"n must be greater than 1\")\n    else\n \
    \       return n * sum_to_n(n-1)\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    sum_to_n(30)\n</cell>\n<code language=julia-1.0>\nsum_to_n(100)\n</cell>\n<code\
    \ language=julia-1.0>\nsum_to_n(5)\n</cell>\n<code language=julia-1.0>\nsum_to_n(10)\n\
    </cell>\n<code language=julia-1.0>\nsum_to_n(1)\n</cell>\n<text>\nExercise 4\n\
    Write a function that takes an array of numbers and a positive integer $k$ as\
    \ arguments, and return a new array with the numbers from the array that are divisible\
    \ by $k$.", "    if n==1\n        return n\n    if n==0\n        return 1\n  \
    \  return n*sum_to_n(n-1)\n</cell>\n<code language=julia-1.1>\nsum_to_n(1000)\n\
    </cell>\n<text>\nWe can verify that the function works:", "    if n < 1 \n   \
    \     error(\"n must be >= 1\")\n    sum_to_n_helper(n, 1)\nend\n\"\"\"", "  \
    \  if n == 0 \n        then return 1\n    elseif n > 0\n        then return n*(n\
    \ + 1)\n        else return 0\n    end\nend\n</code>\n<|/ a tags=haskell dscore=0\
    \ |>\n<| a dscore=0 |>\nI assume you also want to count the number of the different\
    \ prime numbers. \nThe idea is to check if the number is prime by dividing all\
    \ numbers between 2 until sqrt(n) by this number. If this does not give a remainder\
    \ then this number is not a prime. If there is a remainder then this number is\
    \ a prime. After this we check if any number between 2 and the square root of\
    \ n is a divisor of the number we are checking. If that is the case then the number\
    \ is not a prime. \nNow lets look at the code. \n<code>\nimport Data.List (foldl',\
    \ isInfixOf', foldl')\nimport Data.Maybe (fromJust)", "    if n <= 0\n       \
    \ error(\"sum_to_n is only defined for n > 0\")\n    else\n        sum_to_n(n\
    \ - 1) + n\n    end\nend", "        if n == 0\n            1\n        else\n \
    \           sum_to_n(n - 1) + 1\n    end\n    return sum_to_n(n::Int64) + 1\n\
    end\n</cell>\n<code language=julia-0.4>\nsum_to_n(10)\n</cell>\n<text>\nExercise\
    \ 2: write a function that returns the factorial of a given number\n    \u2714\
    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    ", "    sum_ = 0::Int64\n    for i in 1 .. n do\n        sum_ += i\n\
    \    return sum_", "    if n == 1 \n        then n \n    else\n        n * sum_to_n(n-1)\
    \ \nend ", "    if n < 1\n        return 0 \n    else \n        return n + sum_to_n(n\
    \ - 1)\n</code>\nAnd then:\n<code>\n> sum_to_n(20)\n> 5050\n</code>\n<|/ a tags=recursion,haskell\
    \ |>\n<| c |>\nThe recursive call should be `sum_to_n (n-1)`.\n<|/ c |>\n<| c\
    \ |>\nYour solution seems very clever. I thought of it too, but decided against\
    \ it. My solution would have involved using a tail recursive `while` loop, but\
    \ this doesn't seem like the most elegant solution. Could you please comment on\
    \ that?\n<|/ c |>\n<| a dscore=3 tags=recursion,haskell |>\nI like the way you\
    \ did it. One thing I noticed is that you have an if statement that does not do\
    \ anything in the case of the base case, but you also have an else statement that\
    \ returns the value. This will always return the value from else, even if it is\
    \ just 0, which is what you want in this case. As it stands, if n < 1 then your\
    \ else statement will always return the value from else, which will always be\
    \ 0. The following code will do what you want it to do\n<code>\nsum_to_n :: Int\
    \ -> Int\nsum_to_n n = \n    if n == 1 then 1\n    else (sum_to_n (n-1)) + (n-1)\n\
    </code>\n<|/ a |>\n<| c |>\nIn fact, the `if` statement is redundant. The value\
    \ 1 will always be returned anyways.\n<|/ c |>\n<| c |>\nI like this. It avoids\
    \ all the conditionals in the recursive definition.\n<|/ c |>\n<| c |>\nI like\
    \ it too. I would have used `foldr` but you used an `if` statement.\n<|/ c |>\n\
    <| a dscore=2 tags=recursion,haskell |>\nSince nobody has pointed this out, here\
    \ is the Haskell equivalent of the C program below:\n<code>\n#include <stdio.h>",
  "    \n    \"\"\"\n    function sum_to_n", "    if n == 0 \n        then 0\n   \
    \     else n * sum_to_n(n - 1) \n    end\nend", "    if n == 0 \n        return\
    \ 0 else \n        sum_to_n(n-1) + \n        n - 1", "    if n<=0\n    then 1\n\
    \    else n*sum_to_n(n-1)\nend", "    if n < 0 \n        error(\"n must be non-negative\"\
    ) \n    else \n        sum_to_n_impl(n, n, 0)\nend ", "    if n==0 then return\
    \ 1\n    else return n+sum_to_n(n-1)\nend \n</cell>\n<code language=julia-1.5>\n\
    sum_to_n(30)\n</cell>\n<code language=julia-1.5>", "    if n == 1\n        1\n\
    \    else\n        n*sum_to_n(n-1)\nend\n</code>\nand similarly for sum_to_10\n\
    <|/ a tags=julia dscore=3 |>\n<| a |>\nThis can be done recursively.\n<code>\n\
    sum_to_10(n) = (10*(n-1)+(n/10)*sum_to_10(n/10))/10\n</code>\n<|/ a dscore=3 tags=julia\
    \ |>\n<| a tags=julia |>\n<code>", "    if n == 0 \n        0\n    else \n   \
    \     n + sum_to_n(n - 1)\nend\n</cell>\n<code language=julia-1.3>\nsum_to_n(10)\n\
    </cell>\n<text>\nFunctions with multiple outputs", "    if n == 1 \n        result\
    \ := 1\n    else\n        result := n + sum_to_n(n-1)\n    end\n    return result\n\
    end\n</cell>\n<code language=julia-1.5>\nsum_to_n(30)\n</cell>\n<text>\nLet's\
    \ write a function that takes a function f that takes as input a number and that\
    \ outputs a number, and returns the derivative of f at that point. For example,\
    \ the derivative of f at 0 is 1, the derivative of f at 1 is $\\frac{2}{3}$, the\
    \ derivative of f at 2 is $\\frac{3}{4}$, and so on. Here's a function that does\
    \ this:", "    if n == 0 return 0\n    else if n < 1 return n\n    else if n %\
    \ 2 == 1 return n + sum_to_n(n / 2)\n    else return n * sum_to_n(n / 2) + sum_to_n(n\
    \ / 2)\n</code>\n<|/ a tags=prolog |>\n<| c |>\n`sum_to_n(10)` should be `55`\
    \ not `110`.\n<|/ c |>\n<| c |>\nAh, thanks, I was looking at the wrong line.\
    \  I've corrected it now.\n<|/ c |>\n<| c |>\nIf you're going to use recursion,\
    \ you might as well use tail-recursion.\n<|/ c |>\n<| c |>\nThis works very well\
    \ and now I understand how tail recursions work.  Thanks for the help.  I do however\
    \ like the way you wrote the function and it is very clever.  I didn't know you\
    \ can return conditionally without writing out all the conditionals.  That is\
    \ very nice.\n<|/ c |>\n<| c |>\nJust because it's tail-recursion, doesn't mean\
    \ it's tail-call-optimized.  A tail call is one where the target is another function\
    \ (the calling function can't just jump back to the calling function after calling\
    \ it).  It's still not necessarily faster than a non-tail recursive version --\
    \ the benefit is that the compiler can perform constant propagation on the target\
    \ of the call, and optimize away the extra stack frames.\n<|/ c |>\n<| a dscore=2\
    \ |>\nHere's a pure Prolog solution with no recursion:\n<code>\n:- use_module(library(clpfd)).\n\
    :- use_module(library(lambda)).", "    if n==0\n    then return 1\n    else return\
    \ n*sum_to_n(n-1)\n    end\nend\n</cell>\n<text>\nExercise 10\nUse @code_warntype\
    \ to propose a type signature for sum_to_n", "    return sum(range(1, n+1))\n\
    </code>\n<|/ a tags=recursion,scala,tail-recursion |>\n<| a dscore=1 |>\nHere's\
    \ a solution using a tail-recursive function - \n<code>\ndef sum(n: Int): Int\
    \ = {\n  def sumToN(n: Int, acc: Int): Int = {\n    if (n == 0) acc\n    else\
    \ if (n > 0) && (n % 2 == 0) {\n      sumToN(n - 1, acc + n)\n    } else {\n \
    \     sumToN(n - 1, acc)\n    }\n  }", "    if n>0 \n        then sum_to_n(n -\
    \ 1) \n        else 0\n    end\nend\n</cell>\n<code language=julia-1.0>\nsum_to_n(30)\n\
    </cell>\n<text>\nTask 1: Practice\nWrite a function that takes two numbers (a\
    \ and b) and returns, \n(a+b)*(a+b+c+...+b)\nHint: the last term of the series\
    \ is (b+1)!.", "    if n <= 0\n    then return n\n    else return n*sum_to_n(n-1)",
  "    if n < 1 \n        error(\"n must be positive\")\n    elseif n == 1 \n    \
    \    1\n    elseif n == 2 \n        2\n    elseif n == 3 \n        3\n    elseif\
    \ n == 4 \n        4\n    elseif n == 5 \n        5\n    elseif n == 6 \n    \
    \    6\n    elseif n == 7 \n        7\n    elseif n == 8 \n        8\n    elseif\
    \ n == 9 \n        9\n    elseif n == 10 \n        10\n    elseif n == 11 \n \
    \       11\n    elseif n == 12 \n        12\n    elseif n == 13 \n        13\n\
    \    elseif n == 14 \n        14\n    elseif n == 15 \n        15\n    elseif\
    \ n == 16 \n        16\n    elseif n == 17 \n        17\n    elseif n == 18 \n\
    \        18\n    elseif n == 19 \n        19\n    elseif n == 20 \n        20\n\
    \    elseif n == 21 \n        21\n    elseif n == 22 \n        22\n    elseif\
    \ n == 23 \n        23\n    elseif n == 24 \n        24\n    elseif n == 25 \n\
    \        25\n    elseif n == 26 \n        26\n    elseif n == 27 \n        27\n\
    \    elseif n == 28 \n        28\n    elseif n == 29 \n        29\n    elseif\
    \ n == 30 \n        30\n    elseif n == 31 \n        31\n    elseif n == 32 \n\
    \        32\n    elseif n == 33 \n        33\n    elseif n == 34 \n        34\n\
    \    elseif n == 35 \n        35\n    elseif n == 36 \n        36\n    elseif\
    \ n == 37 \n        37\n    elseif n == 38 \n        38\n    elseif n == 39 \n\
    \        39\n    elseif n == 40 \n        40\n    elseif n == 41 \n        41\n\
    \    elseif n == 42 \n        42\n    elseif n == 43 \n        43\n    elseif\
    \ n == 44 \n        44\n    elseif n == 45 \n        45\n    elseif n == 46 \n\
    \        46\n    elseif n == 47 \n        47\n    elseif n == 48 \n        48\n\
    \    elseif n == 49 \n        49\n    elseif n == 50 \n        50\n    elseif\
    \ n == 51 \n        51\n    elseif n == 52 \n        52\n    elseif n == 53 \n\
    \        53\n    elseif n == 54 \n        54\n    elseif n == 55 \n        55\n\
    \    elseif n == 56 \n        56\n    elseif n == 57 \n        57\n    elseif\
    \ n == 58 \n        58\n    elseif n == 59 \n        59\n    elseif n == 60 \n",
  "    if n==0\n        1\n    else\n        n+sum_to_n(n-1)\nend\n</cell>\n<text>\n\
    This implementation is actually quite simple:", "    if n < 1\n        error(\"\
    The sum_to_n function is defined only for n > 0\")\n    elseif n < 0\n       \
    \ error(\"The sum_to_n function is defined only for n >= 0\")\n    else\n    \
    \    return n*(2*n+1)/2 \nend\n</cell>\n<code language=julia-1.6>\nsum_to_n(30)\n\
    </cell>\n<code language=julia-1.6>\nsum_to_n(100)\n</cell>\n<code language=julia-1.6>\n\
    sum_to_n(5)\n</cell>\n<code language=julia-1.6>\nsum_to_n(10)\n</cell>\n<code\
    \ language=julia-1.6>\nsum_to_n(1)\n</cell>\n<text>\nLet's define our own function\
    \ and test it!", "if n <= 2 \nthen 1 \nelse n + sum_to_n(n-1) \nend \nend \n\"\
    \"\"\n## Exercise 1\n\"\"\"\nImplement a function that takes two lists x and y\
    \ as arguments and returns a list of all elements in x that are not present in\
    \ y.\n    >>> x = [1, 2, 3, 4]\n    >>> y = [1, 3, 4, 5]\n    >>> differences(x,\
    \ y)\n    [2, 5]\n    >>> x = [1, 2, 3, 4]\n    >>> y = [3, 4, 5]\n    >>> differences(x,\
    \ y)\n    []\n    >>> x = [1, 2, 3, 4]\n    >>> y = [4]\n    >>> differences(x,\
    \ y)\n    []\n    >>> x = [1, 2, 3, 4]\n    >>> y = [3, 4, 5]\n    >>> differences(x,\
    \ y)\n    [1, 2]\n    >>> x = [1, 2, 3, 4]\n    >>> y = [3, 4, 5]\n    >>> differences(x,\
    \ y)\n    []\n    >>> x = [1, 2, 3, 4]\n    >>> y = [4]\n    >>> differences(x,\
    \ y)\n    []\n    >>> x = [1, 2, 3, 4]\n    >>> y = [1, 2]\n    >>> differences(x,\
    \ y)\n    [3]\n    \"\"\"", "    if n == 0\n        1\n    else \n        (n *\
    \ (n + 1)) / 2\n    end\nend\n</cell>\n<code language=julia-0.6>\nsum_to_n(30)\n\
    </cell>\n<code language=julia-0.6>\nsum_to_n(100)\n</cell>\n<code language=julia-0.6>\n\
    sum_to_n(5)\n</cell>\n<code language=julia-0.6>\nsum_to_n(10)\n</cell>\n<code\
    \ language=julia-0.6>\nsum_to_n(1)\n</cell>\n<text>\nExercises", "    if (n <=\
    \ 2)\n        1\n    else\n        sum_to_n(n-1) + n\n</code>\nA solution that\
    \ is easier to read:\n<code>\nsum_to_n(n::Int64)::Int64 = if n <= 2 \n       \
    \                     1\n                        else\n                      \
    \      1 + sum_to_n(n-1)\n</code>\n<|/ a dscore=1 |>\n<| a tags=recursion,haskell\
    \ |>\nThere are a number of ways to write this function. I would do it like this:\n\
    <code>\nsumToN :: Int -> Int\nsumToN n = go (1,n) where\n  go !acc 0 = 0\n  go\
    \ !acc (x1,x2) = acc + x1 + x2 - 1", "    if n == 1\n        return n\n    return\
    \ n * (n+1)/2\n</code>\n<|/ a tags=math,python,integer,python-3.x |>\n<| c |>\n\
    Your recursive `sum_to_n` method doesn't handle negative numbers, and you're not\
    \ handling `n > 1` properly either. Also, the `return` statement isn't in the\
    \ right place. Also, why are you using the `div` function? This is for dividing\
    \ by 2, not dividing by `n`...\n<|/ c |>\n<| c |>\nThis is why I said \"naive\"\
    , I didn't say it's good or efficient.\n<|/ c |>\n<| c |>\nOh, and you're not\
    \ using the `div` function. It should be `div(n,2)`.\n<|/ c |>\n<| a dscore=4\
    \ tags=math,python,integer,python-3.x |>\nHere is a slightly more pythonic way:\n\
    <code>\ndef sum_to_n(n):\n    return reduce(lambda x, y: x+y, range(1, n+1))\n\
    </code>\n<|/ a |>\n<| c |>\nThat is definitely more elegant, but I'm looking for\
    \ a non-recursive solution.\n<|/ c |>\n<| c |>\nThis is very elegant, but I'm\
    \ looking for a non-recursive solution. The recursive solution was just the first\
    \ thing that came to mind.\n<|/ c |>\n<| c |>\nI guess you could use the fact\
    \ that `reduce` is implemented by converting to a list before doing anything.\n\
    <|/ c |>\n<| c |>\nA nice implementation of a reduce function. It's quite interesting\
    \ :-)\n<|/ c |>\n<| c |>\n: It's not that interesting. It's just a recursive function.\
    \ It's a bad idea to use reduce for looping over lists, because reduce has quadratic\
    \ runtime.\n<|/ c |>\n<| a dscore=4 |>\n<code>\n>>> sum(range(1,100+1))\n5050\n\
    </code>\n<|/ a tags=math,python,integer,python-3.x |>\n<| c |>\nThat's not recursive,\
    \ though, is it?\n<|/ c |>\n<| c |>\nNope. That's a clever one-liner! Thanks!\n\
    <|/ c |>\n<| a dscore=4 |>\n<code>\ndef sum_to_n(n):\n  s = 0\n  for i in range(1,\
    \ n+1):\n    s += i\n  return s\n</code>\n<|/ a tags=math,python,integer,python-3.x\
    \ |>\n<| a dscore=3 tags=math,python,integer,python-3.x |>\nThe nai", "    if\
    \ n<=1\n        return n\n    else \n        summation = 1\n        for ii in\
    \ 1..n-1\n            summation = summation + ii\n        end\n        return\
    \ summation\nend\n</cell>\n<code language=julia-1.4>\n\"\"\"The function count_to_n\
    \ is a function that counts numbers from 1 to n.\n    >>> count_to_n(3)\n    2\n\
    \    >>> count_to_n(100)\n    5050\n    >>> count_to_n(5)\n    15\n    >>> count_to_n(10)\n\
    \    55\n    >>> count_to_n(1)\n    1\n    \"\"\"", "    if n < 5 then\n     \
    \   return 1\n    elif n < 10 then\n        return n\n    elif n < 100 then\n\
    \        return n * 10 + 5\n    else\n        return n * 10 + 5 + sum_to_n(n -\
    \ 5)\nend\n</cell>\n<code language=julia-1.3>\nsum_to_n(31)\n</cell>\n<code language=julia-1.3>\n\
    sum_to_n(100)\n</cell>\n<code language=julia-1.3>\nsum_to_n(5)\n</cell>\n<code\
    \ language=julia-1.3>\nsum_to_n(10)\n</cell>\n<code language=julia-1.3>\nsum_to_n(1)\n\
    </cell>\n<text>\nThe fibonacci sequence\nThe fibonacci sequence is a sequence\
    \ of numbers that grow from 0, 1, 1, 2, 3,\n4, and so on until it reaches n. \
    \ It can be computed using the following function,", "    if n<0\n        error(\"\
    `n` must be positive.\", 2)\n    end\n    return n==0 ? 1 : (n==1 ? 0 : (1+sum_to_n(n-1)))",
  "    sum = 0\n    sum = sum + n\n    if sum < n\n        sum += n\n    end\n   \
    \ return sum\nend", "    if n < 0\n        error(\"Invalid Argument: n < 0\")\n\
    \    return 1\nend", "    # your code goes here\n    sum = 0\n    for x in 1..n\n\
    \        sum += x\n    end\n    return sum\nend\n</cell>\n<text>\nExercise 4.10\n\
    Now write a function that takes in a list of integers and returns the sum of the\
    \ even numbers in the list. Use the sum_to_n function you defined earlier.", " \
    \   if (n < 1) \n        error(\"n must be greater than 1\")\n    end\n    sum_\
    \ = 1 + n\n    for i in 2..n \n        sum_ = sum_ * i\n    end\n    return sum_\n\
    end\n</cell>\n<text>\nExercise 3\nWrite a function that computes the factorial\
    \ of a number.", "    if n < 0\n    then failwith \"n must be positive\"\n   \
    \ end\n    if n == 0\n    then 1\n    else\n        return n + sum_to_n(n - 1)\n\
    \    end\nend\nsum_to_n(_) = 0\n</code>\nThe inner function sum_to_n calls itself\
    \ recursively (it\u2019s recursive!) until it hits the base case, and returns\
    \ that sum. At the end, the top-level function sum_to_n is defined simply to return\
    \ the final sum.\n<|/ a dscore=3 |>\n<| a dscore=2 |>\nThis looks like a job for\
    \ Iterators.product!. For example:\n<code>\njulia> using Iterators", "    if n<=1\n\
    \        1\n    else\n        sum_to_n(n - 1) + 1", "    if n == 0 return 0 \n\
    \    else return n + (sum_to_n(n-1)) \nend", "    if n <= 0 \n    then return\
    \ 0\n    else sum_to_n(n - 1)\n    end\nend ", "    n <= 1 ? 1 : sum_to_n(n -\
    \ 1) + 1\nend\n</cell>\n<code language=julia-0.6>\nsum_to_n(10)\n</cell>\n<code\
    \ language=julia-0.6>\nsum_to_n(1)\n</cell>\n<text>\nWe can see that this function\
    \ is recursive. The call to the function sum_to_n returns the value of n and then\
    \ the function is called again with the value of n - 1. The function sum_to_n\
    \ is called with n = 10, so the initial call returns 10 and the next call returns\
    \ 9. In the last call we get to n = 1. The final call returns 1, which we then\
    \ add 1 to, giving us the final value of 10.", "    if n <= 1 then n else n *\
    \ sum_to_n(n - 1)\nend\n</cell>\n<text>\nThe recursive function sum_to_n works\
    \ with any $n$. Let's check its output:", "    if n<0\n        error(\"sum_to_n\
    \ called with n < 0\")\n    else\n        return n * n + sum_to_n(n-1)\n    end\n\
    end\n</cell>\n<text>\nThe above function is pretty straightforward. It sums the\
    \ numbers 1 to $n$, and calls itself recursively with the new $n$ until $n = 1$.",
  "    if n == 1 \n        1\n    else \n        n + sum_to_n(n - 1)\nend\n</cell>\n\
    <text>\nExercise 11: Write a function that converts degrees to radians and back.\n\
    Hint: use \u03C0 and \u03C0/2", "if n <= 0\n    error(\"n must be positive\")\n\
    elseif n < 10\n    return n\nelseif n <= 100\n    return n * n\nelse\n    n =\
    \ sum_to_n(n / 10)\n    return n + sum_to_n(n % 10)\nend\nend\n</cell>\n<code\
    \ language=julia-1.1>\nsum_to_n(30)\n</cell>\n<code language=julia-1.1>\nsum_to_n(100)\n\
    </cell>\n<code language=julia-1.1>\nsum_to_n(5)\n</cell>\n<code language=julia-1.1>\n\
    sum_to_n(10)\n</cell>\n<code language=julia-1.1>\nsum_to_n(1)\n</cell>\n<code\
    \ language=julia-1.1>\nsum_to_n(-1)\n</cell>\n<code language=julia-1.1>\nsum_to_n(13)\n\
    </cell>\n<code language=julia-1.1>\nsum_to_n(1000)\n</cell>\n<code language=julia-1.1>\n\
    sum_to_n(200)\n</cell>\n<code language=julia-1.1>\nsum_to_n(500)\n</cell>\n<text>\n\
    Exercises", "    if n <= 0\n        0\n    else\n        Int(n) * sum(1:Int(n))\
    \ end\nend\n</code>\n<|/ a tags=julia,recursion |>\n<| a dscore=2 |>\n<code>\n\
    sum_to_n(n) = sum(1:n)\n</code>\n<|/ a tags=julia,recursion |>\n<| c |>\nThis\
    \ is an extremely inefficient way to do this.\n<|/ c |>\n<| c |>\nThis answer\
    \ may be incorrect, but it is not as uninspiring as some of the other answers,\
    \ especially when you are summing up natural numbers.\n<|/ c |>\n<| c |>\nThe\
    \ only issue with this is that `sum_to_n(1)` returns `1` instead of `1+0`. You\
    \ might also consider adding a `+` in front of `sum_to_n`.\n<|/ c |>\n<| c |>\n\
    It might be useful to mention that `sum_to_n(1)` returns `1` rather than `1+0`,\
    \ because it makes it clear that you want an integer result.\n<|/ c |>\n<| a |>\n\
    Here's a tail recursion function using a mutable accumulator and without an explicit\
    \ loop:\n<code>\njulia> function sum_to_n(n)\n           if n < 0\n          \
    \     0\n           else\n               s = n\n               for i = 2:n\n \
    \                  s += i\n               end\n               s\n           end\n\
    \       end\nsum_to_n (generic function with 1 method)", "    if n < 0\n     \
    \   return sum_to_n(-n)\n    else\n        return n + sum_to_n(n-1)\n    end\n\
    end\n</cell>\n<code language=julia-0.5>\nsum_to_n(30)\n</cell>\n<text>\nA recursive\
    \ function with some patterns", "    if n==1 return 1\n    else return sum_to_n(n-1)\
    \ + n\nend\n</cell>\n<code language=julia-1.4>\n@time sum_to_n(10^6)\n</cell>\n\
    <text>\nThe fastest Julia is likely to be the one that compiles C code.  A Julia\
    \ program with loops and if/else statements are compiled down to machine instructions.\
    \  If performance matters, a compiled version of Julia will be faster than a interpreted\
    \ version.", "    if n <= 0\n    then return 0\n    else sum_to_n(n-1)\n    end\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=recursion,julia |>\n<code>",
  "    if n<0 then error(\"sum_to_n(n::Int64) expects a positive integer but got \"\
    \ .. show(n) ) \n    sum_to_n = 0\n    \n    for n in 0 .. n do \n        sum_to_n\
    \ += n\n    end", "    \n    if n == 1 \n        then return 1 \n    else if n\
    \ < 1 \n        then return 0 \n        else \n            sum_to_n(n - 1) + 1\
    \ \n    end\nend\n</cell>\n<code language=julia-1.0>\nsum_to_n(4)\n</cell>\n<code\
    \ language=julia-1.0>\n@code_native sum_to_n(n = 4)\n</cell>\n<code language=julia-1.0>",
  "    if n == 0 then\n        return 0\n    elseif n == 1 then\n        return 1\n\
    \    else\n        return n + sum_to_n(n-1)\n    end\nend\n</code>\n<|/ a dscore=2\
    \ tags=recursion,julia,memoization |>\n<| c |>\nThis is quite a nice and elegant\
    \ solution. I've tried it out, and it worked well. I was surprised that I couldn't\
    \ find the original example code on the wiki but it's actually not that complicated.\
    \ It's really great to see Julia code that I could learn from!\n<|/ c |>\n<| c\
    \ |>\nThe code in the wiki link you provided is for the memoizing version.  It's\
    \ easy to adapt it to your version.\n<|/ c |>\n<| c |>\nI see, thanks. Yeah I\
    \ realized after posting that I should have used `Base.memoize` instead of my\
    \ own memoized version of the function, just out of laziness I forgot. I've learned\
    \ a lot about the memoization function now, thanks! :) The wiki was a bit confusing\
    \ in my opinion, and I guess I might have missed the part that they included memoizing\
    \ as an example, but they clearly had code snippets with it so I thought that\
    \ was it. I'll definitely keep that in mind.\n<|/ c |>\n<| a tags=recursion,julia,memoization\
    \ |>\nI wrote a package for memoization using Julia's Base.memoize. I am sure\
    \ the answer is already accepted but this is what I'm doing in my package for\
    \ memoization.\n<code>\nusing Base.memoize", "    if n<=0\n        error(\"sum\
    \ numbers less than 0\") \n    else \n        return n*(n+1)/2\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\n`sum_to_n` function takes any numbers and return sum\
    \ of the numbers from 1 to it, so it can't handle negative numbers.\n<|/ c |>\n\
    <| c |>\n: you missed `if n<=0` check on top\n<|/ c |>\n<| c |>\nYeah, I forgot\
    \ it. Thanks\n<|/ c |>\n<| c |>\n`if n<=0 error(\"sum numbers less than 0\")`\
    \ this should be `if n<=0; error(\"sum numbers less than 0\"); end`\n<|/ c |>\n\
    <| a |>\n<code>\njulia> n::Int64\n       n::Int64", "    if n<1 \n        error(\"\
    n is not positive\")\n    else \n        sum=1\n        for i in 1:n\n       \
    \     sum=sum+i\n    end\n    return sum\nend", "    if n < 0\n        error(\"\
    n must be positive\", AbortException)\n    end\n    return sum_to(1,n)", "   \
    \ if n < 0 \n        error(\"sum_to_n requires a non-negative integer\")\n   \
    \ else if n == 0\n        1\n    else if n == 1 \n        1\n    else \n     \
    \   sum_to_n(n - 1)*(1 + n)\nend \n</cell>\n<code language=julia-1.2>\nsum_to_n(31)\n\
    </cell>\n<text>\nAnd a much more efficient implementation.", "    if n==1\n  \
    \      1\n    else \n        1+sum_to_n(n-1)\nend\n</code>\n<code>", "    if n\
    \ < 0\n        error(\"Invalid input\")\n    if n == 1\n        1\n    else\n\
    \        sum_to_n(n-1) + n\nend\n</cell>\n<code language=julia-1.6>\nsum_to_n(100)\n\
    </cell>\n<text>\nWrite a function sum_to_n_recursive that sums numbers from 1\
    \ to n recursively.", "    if n == 1 \n        then return 1 \n    else if n <\
    \ 1 \n        then return 0 \n    else \n        return n + sum_to_n(n-1::Int64)\
    \ \nend\n</cell>\n<text>\nFinally, here's our function that will count from 1\
    \ to $n$, and return the sum. Here we have an else clause which does nothing (it\
    \ just returns what would have been the sum if n is greater than 1).", "    if\
    \ n==1\n        1\n    else\n        n*sum_to_n(n-1)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time sum_to_n(100000)\n</cell>\n<text>\nThe function above sums numbers from\
    \ 1 to $n$.  (But note the way it's written, it's actually recursive.)", "   \
    \ if n == 0\n        1\n    else\n        sum_to_n(n - 1) + n", "    return sum([i\
    \ for i in range((n+1))])\nend\n</cell>\n<code language=julia-1.6>\n\"\"\"\n sum_range(n::Int64)::Int64\n\
    \    Sum numbers from 1 to n\n    \n    Example:\n    >>> sum_range(5)\n    15\n\
    \    >>> sum_range(10)\n    55\n    >>> sum_range(1)\n    1\n    \"\"\"", "  \
    \  if n < 0\n        error(\"Argument `n` must be a non-negative integer.\")\n\
    \    else\n        return reduce(op.add, range(n+1))\nend ", "    if n < 1 \n\
    \        throw(\"n must be >= 1\")\n    end\n    return n + sum_to_n(n-1)\nend",
  "    if n==1 \n        1\n    else\n        n*sum_to_n(n-1)\n    end\nend\n</cell>\n\
    <text>\nNow we'll define the function factorial_to_n(). factorial_to_n() works\
    \ by first defining a function factorial_to_n(n::Int64)::Int64. factorial_to_n()\
    \ returns a new function which when called with any number n will return the factorial\
    \ of n. For example:", "    count = 0\n    while count < n\n        count += 1\n\
    \    return count\n</code>\n<|/ a dscore=1 |>\n<| a |>\nI wanted to see if a different\
    \ approach would be more efficient, and I came up with this (still only using\
    \ 1 loop).\n<code>\nlet f n = if n <= 10 then 1 else 10\nlet g n = if n < 10 then\
    \ 1 else 10 * f(n-1)\nlet h n = if n < 10 then 1 else 10 * g(n-1)", "    if n\
    \ < 1\n    then return 0\n    elif n == 1\n    then return n\n    else\n     \
    \   sum = sum_to_n(n-1)\n        return sum + n\n    end\nend\n</cell>\n<text>\n\
    We are going to use a function that sums numbers until it reaches a certain number:",
  "    if n<=0\n    then return 0\n    else\n        let new_n=n\n        sum=0\n\
    \        while new_n>0\n        do sum+=new_n\n           new_n-=1\n        return\
    \ sum\n    end\nend\n</cell>\n<text>\nExercise 2\nWrite a function to compute\
    \ the binomial coefficient $n!$, $n$-factorial, and $n$-factorial (the latter\
    \ two are simply products of the former). What does this have to do with factorial?\
    \ Check out the Wikipedia page for more information.", "    if n == 0\n      \
    \  1\n    else\n        n * sum_to_n(n - 1)\nend", "    if n == 1\n        1\n\
    \    else\n        sum_to_n(n - 1) + 1", "    if n == 1\n        1\n    else if\
    \ n == 0\n        0\n    else if n % 2 == 1\n        sum_to_n(n - 1) + 1\n   \
    \ else\n        sum_to_n(n - 1) + sum_to_n(n - 2)\n    end\nend\n</code>\n<|/\
    \ a tags=julia,recursion |>\n<| a |>\nAnother Julia version (not using any function\
    \ definition):\n<code>", "    if n == 0 \n        then return 0 \n    else \n\
    \        sum_to_n_aux(n-1, n) \n    end\nend", "    sum_to_n_impl(n :: Int64)\n\
    end", "    sum = 0\n    for x in 1..n\n        sum = sum + x\n    return sum\n\
    </code>\nThis is much faster than your original code.\n<|/ a tags=python-3.x |>\n\
    <| c |>\nThe for loop is so much faster than the while loop, thanks!\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>\na = [1,3,5,7,9]\ndef sum_to_n(n:Int64):Int64\n    sum\
    \ = 0\n    while n > 0\n        sum = sum + n\n        n,r = n % 10,n/10\n   \
    \ return sum", "    if n <= 0\n        0\n    else \n        n + (sum_to_n(n-1))\n\
    end", "    if n==0 \n        sum \n    else \n        sum_to_n(n \\- 1) + n",
  "    if n == 1 \n        1\n    else\n        n*(n+1)/2\nend\n</cell>\n<code language=julia-0.5>\n\
    sum_to_n\n</cell>\n<code language=julia-0.5>\nsum_to_n(30)\n</cell>\n<code language=julia-0.5>\n\
    sum_to_n(100)\n</cell>\n<code language=julia-0.5>\nsum_to_n(5)\n</cell>\n<code\
    \ language=julia-0.5>\nsum_to_n(10)\n</cell>\n<code language=julia-0.5>\nsum_to_n(1)\n\
    </cell>\n<text>\nExercise\nWrite a function that takes a vector and returns the\
    \ sum of the absolute values of each element.", "    if n == 1 \n        then\
    \ 1\n    else\n        n+sum_to_n(n-1)\nend", "    if n == 0 then\n        1\n\
    \    elseif n == 1 then\n        n\n    elseif n == 2 then\n        n + 1\n  \
    \  elseif n == 3 then\n        n + 2\n    elseif n == 4 then\n        n + 3\n\
    \    elseif n == 5 then\n        n + 4\n    elseif n == 6 then\n        n + 5\n\
    \    elseif n == 7 then\n        n + 6\n    elseif n == 8 then\n        n + 7\n\
    \    elseif n == 9 then\n        n + 8\n    elseif n == 10\n        n + 9\n  \
    \  else\n        n + 10\n    end \nend # sum_to_n\nsum_to_n(20)\n</cell>\n<code\
    \ language=julia-1.6>\n\"\"\"\nsum_to_n!(n::Int64, nsum::Int64)\nThis function\
    \ sums numbers n to nsum.\nThe sum starts at nsum.\nThe function stops when the\
    \ sum equals nsum or when the number n becomes 0.\n\"\"\"", "    if n==0 \n  \
    \      then return 0\n    else if n <= 1 \n        then return n\n        else\
    \ return n + sum_to_n(n-1)\nend\n</code>\nThe code looks pretty straight forward\
    \ to me. Except for the line which says return n + sum_to_n(n-1). Remember that\
    \ in our recursive function, we need to add 1 to the return of our recursive function,\
    \ and not simply the number that is passed in to it.\n<|/ a dscore=0 |>\n<| c\
    \ |>\nThe code is fine, it only needs a fix. Your code doesn't take negative numbers.\
    \ If you pass `sum_to_n(-7)`, it returns `0`, which should return `-7`.\n<|/ c\
    \ |>\n<| c |>\nThe code you gave isn't wrong in any way - it works. It's a good\
    \ example of how to add up numbers from 1 to n (inclusive) with recursion. Just\
    \ that it's wrong for negative numbers.\n<|/ c |>\n<| c |>\nYou didn't say that.\
    \ `sum_to_n(-7)` returns `-7`, so your function should return `-7`. `sum_to_n(-7)`\
    \ is `sum_to_n(7)`, which returns `10`. Therefore, `sum_to_n(-7)` is `sum_to_n(10)`,\
    \ which returns `55`.\n<|/ c |>\n<| c |>\nYes, that's the point. `sum_to_n(-7)`\
    \ returns `-7`, which should be `sum_to_n(7)`, which returns `10`. Therefore,\
    \ `sum_to_n(-7)` is `sum_to_n(10)`, which returns `55`. We should return `55`,\
    \ not `10`\n<|/ c |>\n<| c |>\nHmmm... I don't think I made that point clear.\
    \ `sum_to_n(7)` is `10`. `sum_to_n(7)` is `sum_to_n(10)`, which returns `55`.\
    \ So `sum_to_n(-7)` is `sum_to_n(55)`, which returns `-7`.\n<|/ c |>\n<| a tags=recursion,julia\
    \ |>\nI thought about this question and was inspired by the following two posts.\
    \ My idea is to implement a function that takes a number n and returns the sum\
    \ from 1 to n by recusively summing and returning the result of the call. Additionally,\
    \ I noticed that n^2 = n*n, and that n^2 + 1 = n, so I decided to use the fact\
    \ that n^2 = n*n + 1 for a positive n. \nHere is a possible implementation: \n\
    <code>", "    if n < 0 \n        error(\"sum_to_n requires a positive integer,\
    \ got \" * string(n))\n    elseif n < 0\n        error(\"sum_to_n requires a positive\
    \ integer, got \" * string(n))\n    elseif n == 0 \n        0\n    elseif n <\
    \ 10\n        n\n    else\n        10*(n-1)+(n-1)\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\nsum_to_n(10)\n</cell>\n<text>\nThe first two functions\
    \ are the ones that we usually associate with the factorial function. The factorial\
    \ function takes any positive integer and returns the factorial of it. This function\
    \ will eventually be replaced with a function that will compute the factorial\
    \ of any positive integer given we know its factorial as a preprocessing step.\
    \ In Julia it can be done as follows:", "    if (n<=0)\n        sum_to_n(1)\n\
    \    else\n        (n :: Int64)*(n :: Int64 + 1)\n    end\nend\nsum_to_n(20)\n\
    </cell>\n<text>\nExercise: Define a function primes_less_than(limit) which returns\
    \ the number of prime numbers less than limit. For example, primes_less_than(15)\
    \ should return 3 (since 4 and 5 are prime).", "    if n<1\n        throw(ArgumentError(\"\
    n must be positive\"))\n    return sum((i-1)*i for i in 1 .. n)\nend\n</cell>\n\
    <code language=julia-1.5>\n@doc sum_to_n\n</cell>\n<code language=julia-1.5>\n\
    sum_to_n(2)\n</cell>\n<code language=julia-1.5>\nsum_to_n(-2)\n</cell>\n<code\
    \ language=julia-1.5>\nsum_to_n(1)\n</cell>\n<code language=julia-1.5>\nsum_to_n(2)\n\
    </cell>\n<code language=julia-1.5>\nsum_to_n(100)\n</cell>\n<code language=julia-1.5>\n\
    sum_to_n(10)\n</cell>\n<code language=julia-1.5>\nsum_to_n(11)\n</cell>\n<code\
    \ language=julia-1.5>\nsum_to_n(100)\n</cell>\n<code language=julia-1.5>\nsum_to_n(10)\n\
    </cell>\n<code language=julia-1.5>\nsum_to_n(11)\n</cell>\n<code language=julia-1.5>\n\
    sum_to_n(100)\n</cell>\n<code language=julia-1.5>\nsum_to_n(10)\n</cell>\n<code\
    \ language=julia-1.5>\nsum_to_n(11)\n</cell>\n<code language=julia-1.5>\nsum_to_n(100)\n\
    </cell>\n<code language=julia-1.5>\nsum_to_n(10)\n</cell>\n<code language=julia-1.5>\n\
    sum_to_n(11)\n</cell>\n<code language=julia-1.5>\nsum_to_n(100)\n</cell>\n<code\
    \ language=julia-1.5>\nsum_to_n(10)\n</cell>\n<code language=julia-1.5>\nsum_to_n(11)\n\
    </cell>\n<code language=julia-1.5>\nsum_to_n(100)\n</cell>\n<code language=julia-1.5>\n\
    sum_to_n(10)\n</cell>\n<code language=julia-1.5>\nsum_to_n(11)\n</cell>\n<code\
    \ language=julia-1.5>\nsum_to_n(100)\n</cell>\n<code language=julia-1.5>\nsum_to_n(10)\n\
    </cell>\n<code language=julia-1.5>\nsum_to_n(11)\n</cell>\n<code language=julia-1.5>\n\
    sum_to_n(100)\n</cell>\n<code language=julia-1.5>\nsum_to_n(10)\n</cell>\n<code\
    \ language=julia-1.5>\nsum_to_n(11)\n</cell>\n<code language=julia-1.5>\nsum_to_n(100)\n\
    </cell>\n<code language=julia-1.5>\nsum_to_n(10)\n</cell>\n<code language=julia-1.5>\n\
    sum_to_n(11)\n</cell>", "    if n == 1 then return n\n    else return n + sum_to_n(n-1)\n\
    end", "    \"\"\"\n    sum_to_n is a function that sums numbers from 1 to n.\n\
    \    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n\
    \    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n\
    \  return sum(range(n+1))", "    if n < 1 \n        error ArgumentError(\"n must\
    \ be a positive integer\") \n    else \n        sum_to_n_impl(n)\n    end\nend",
  "    if n<=0\n    then return 0\n    else return n\n    end\nend \n\"\"\"\n\"\"\"\
    \n    sum_to_n_opt is a version of sum_to_n that optimizes its result for numbers\
    \ that are less than\n    or equal to n.\n    >>> sum_to_n_opt(5)\n    4\n   \
    \ >>> sum_to_n_opt(30)\n    465\n    >>> sum_to_n_opt(100)\n    5050\n    >>>\
    \ sum_to_n_opt(10)\n    55\n    >>> sum_to_n_opt(1)\n    1\n\"\"\"", "    if n\
    \ == 0\n        0\n    else\n        n * sum_to_n(n-1) + n\nend\n</cell>\n<text>\n\
    This is known as the factorial function. What is the value of the following expression\
    \ raised to the power 2?", "    if n < 1 \n    then 0\n    else (n+1)*sum_to_n(n-1)\n\
    end\n</cell>\n<code language=julia-1.6>\nsum_to_n(n=1)\n</cell>\n<code language=julia-1.6>\n\
    sum_to_n(n=2)\n</cell>\n<code language=julia-1.6>\nsum_to_n(n=3)\n</cell>\n<code\
    \ language=julia-1.6>\nsum_to_n(n=5)\n</cell>\n<code language=julia-1.6>\nsum_to_n(n=10)\n\
    </cell>\n<code language=julia-1.6>\nsum_to_n(n=100)\n</cell>\n<code language=julia-1.6>\n\
    sum_to_n(n=300)\n</cell>\n<code language=julia-1.6>\nsum_to_n(n=5000)\n</cell>\n\
    <code language=julia-1.6>\nsum_to_n(n=100000)\n</cell>\n<code language=julia-1.6>\n\
    sum_to_n(n=1000000)\n</cell>\n<code language=julia-1.6>", "    if n == 0 then\
    \ 0 else n + sum_to_n(n - 1)\nend\n\"\"\"\n    sum_to_n(5)\n    # 1\n    # 2\n\
    \    # 3\n    # 4\n    # 5\n    # 6\n    # 7\n    # 8\n    # 9\n    # 10\n   \
    \ # 11\n    # 12\n    # 13\n    # 14\n    # 15\n    # 16\n    # 17\n    # 18\n\
    \    # 19\n    # 20\n    # 21\n    # 22\n    # 23\n    # 24\n    # 25\n    # 26\n\
    \    # 27\n    # 28\n    # 29\n    # 30\n    # 31\n    # 32\n    # 33\n    # 34\n\
    \    # 35\n    # 36\n    # 37\n    # 38\n    # 39\n    # 40\n    # 41\n    # 42\n\
    \    # 43\n    # 44\n    # 45\n    # 46\n    # 47\n    # 48\n    # 49\n    # 50\n\
    \    # 51\n    # 52\n    # 53\n    # 54\n    # 55\n    # 56\n    # 57\n    # 58\n\
    \    # 59\n    # 60\n    # 61\n    # 62\n    # 63\n    # 64\n    # 65\n    # 66\n\
    \    # 67\n    # 68\n    # 69\n    # 70\n    # 71\n    # 72\n    # 73\n    # 74\n\
    \    # 75\n    # 76\n    # 77\n    # 78\n    # 79\n    # 80\n    # 81\n    # 82\n\
    \    # 83\n    # 84\n    # 85\n    # 86\n    # 87\n    # 88\n    # 89\n    # 90\n\
    \    # 91\n    # 92\n    # 93\n    # 94\n    # 95\n    # 96\n    # 97\n    # 98\n\
    \    # 99\n    # 100\n    # 101\n    # 102\n    # 103\n    # 104\n    # 105\n\
    \    # 106\n    # 107\n    # 108\n    # 109\n    # 110\n    # 111\n    # 112\n\
    \    # 113\n    # 114\n    # 115\n    # 116\n    # 117\n    # 118\n    # 119\n\
    \    # 120\n    # 121\n    # 122\n    # 123\n    # 124\n    # 125\n    # 126\n\
    \    # 127\n    # 128\n    # 129\n    # 130\n    # 131\n    # 132\n    # 133\n\
    \    # 134\n    # 135\n    # 136\n    # 137\n    # 138\n    # 139\n    # 140\n\
    \    # 141\n    # 142\n    # 143\n    # 144\n    # 145\n    # 146\n    # 147\n\
    \    # 148\n    # 149\n    # 150\n    # 151\n    # 152\n    # 153\n    # 154\n\
    \    # 155\n    # 156\n    # 157\n    # 158\n    # 159\n    # 160\n    # 16",
  "    if n <= 0 \n        then throw(BoundsError(error=\"n must be positive\"))\n\
    \    elseif n < 1\n        then throw(BoundsError(error=\"n must be greater than\
    \ 0\"))\n    else\n        sum_to_n(n-1)\n    end\nend\n</code>\nFinally, sum_to_n(n)\
    \ is the function that will sum to n.  It takes a single parameter, which tells\
    \ it how many to sum.\nAs you can see from sum_to_n(n), if n is less than or equal\
    \ to 1, it returns 1 immediately.  If n is equal to or greater than 1, then it\
    \ recursively sums to n-1.\n<|/ a dscore=2 |>\n<| c |>\nI understand that but\
    \ I am looking for a recursive function like the one above that takes n as an\
    \ argument, does that make sense?\n<|/ c |>\n<| c |>\nYes.  I have added a little\
    \ more detail to the answer.\n<|/ c |>\n<| c |>\nNice.  I like it. :)\n<|/ c |>\n\
    <| a dscore=0 |>\nTo sum all the numbers in an array, you can simply use reduce(+,myArray)\
    \ like so\n<code>\nmyArray = [1, 2, 3, 4, 5]\nreduce(+, myArray) // returns 15\n\
    </code>\n<|/ a tags=julia,recursion,arrays |>\n<| c |>\nI'm looking for an efficient\
    \ implementation though, rather than having to go through each element in my array.\n\
    <|/ c |>\n<| c |>\nSo this isn't the efficient way to do this.\n<|/ c |>\n<| c\
    \ |>\nWhat about using the `+` operator to sum the array elements and then `reduce`\
    \ it? Something like `reduce(+, myArray)`?\n<|/ c |>\n<| c |>\nThis works, except\
    \ it creates a new array and doesn't modify the original one. I'm looking for\
    \ a recursive implementation that modifies my original array. Like the one I posted\
    \ above.\n<|/ c |>\n<| c |>\nThis has nothing to do with efficiency. There are\
    \ no efficiency issues with this solution. If you want a non-recursive solution,\
    \ just use a loop.\n<|/ c |>\n<| a tags=julia,recursion,arrays |>\nHere's a recursive\
    \ approach that does mutate the input array:\n<code>\njulia> function sum_to_n(arr::Array{Int,1})::Int\n\
    \           if length(arr)==0 \n               return 0\n           end\n    \
    \       return arr[1] + sum_to_n(arr[end-1:end])\n       end\nsum_to_n (generic\
    \ function with 1 method)", "    if n < 0\n        error(\"sum_to_n is defined\
    \ for n >= 0\")\n    sum=0\n    if n==0\n        sum=1\n    else\n        for\
    \ n in n .. 1\n            sum=sum+n\n    return sum\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=0 |>\nIn python3, it is possible to use sum as a function without\
    \ importing anything:\n<code>\n>>> sum(range(1, 12))\n21\n</code>\n<|/ a tags=python-3.x,python,python-2.7\
    \ |>\n<| a tags=python-3.x,python,python-2.7 |>\n<code>\nfrom sys import argv\n\
    script, filename = argv", "    if n < 0 \n        throw(RangeError(String[\"n\
    \ is negative!\"]))\n    else\n        return n `div` 2 `+` sum_to_n(n`div` 2)\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\nsum_to_n(30::Int64)\n</cell>\n\
    <text>\n\u2713", "    if n == 0\n        then 1\n    else n * sum_to_n(n - 1)\n\
    end\n</cell>\n<code language=julia-1.2>", "    if n<=1\n        then 1\n    else\n\
    \        sum_to_n(n-1)+(n-1)\nend \n</code>\n<|/ a dscore=2 |>\n<| c |>\nPlease\
    \ post code as text not screenshots, otherwise external links may not always be\
    \ available (thanks SO policy)\n<|/ c |>\n<| a tags=recursion,fibonacci,haskell\
    \ |>\nThis answer focuses on performance and avoids recursion in favor of memoization.\
    \ This also uses recursion rather than tail recursion which can be very useful.\n\
    <code>\nfibs = 0 : 1 : zipWith (+) fibs (tail fibs)\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThe performance is terrible for large inputs. If you really need performance\
    \ and your input is not too large, please see the other answers.\n<|/ c |>\n<|\
    \ c |>\nActually, I disagree - it does perform very well in ghci. I tested for\
    \ 300 million numbers before and after running on my machine.\n<|/ c |>\n<| c\
    \ |>\nIt performs very well on Haskell Platform 2010 (GHC 7.10.3) on my machine.\
    \ But as said in the other answer, it's also terrible for large inputs. I posted\
    \ a question on SO recently - https://stackoverflow.com/questions/46757778/why-does-haskell-not-optimize-tail-recursion-by-itself-on-my-machine\n\
    <|/ c |>\n<| c |>\nI wonder if that benchmark is valid with GHC. I ran [this program](https://gist.github.com/sethur/f64c14d998e3bbd25b8b044b15e54f89)\
    \ in GHC 7.10.3, and got \"No more memory is available\" immediately after running\
    \ for around 60 minutes.\n<|/ c |>\n<| c |>\nThe \"No more memory is available\"\
    \ error is an out-of-memory error from the Operating System. There are many many\
    \ resources on the net explaining how OSes handle OOM, so I won't explain it here.\
    \ If your program uses more memory than Haskell can handle, Haskell will throw\
    \ a OOM. Not that it is necessarily a problem with Haskell, but a problem with\
    \ the OS.\n<|/ c |>\n<| a tags=recursion,fibonacci,haskell dscore=2 |>\nI did\
    \ a small benchmark on my machine and it seems that recursive solution doesn't\
    \ really out", "    if n <= 0 \n    then return -1\n    else return n + sum_to_n(n-1)\n\
    end\n\"\"\"\nWe define an auxiliary function called sum_to_n_aux. Here we sum\
    \ from the first argument to the second, by calling the function sum_to_n (which\
    \ calls sum_to_n-1 recursively until we reach a base case)\n\"\"\"", "    if n<=0\n\
    \        error(\"The number can not be less than or equal to zero\")\n    else\
    \ if n >= 50\n        error(\"The number can not be greater than 50\")\n    else\n\
    \        return (10*(n+1)+(n+1))\nend\n</cell>\n<text>\nQuestions 3\nWrite a function\
    \ that creates a vector of a length from 1 to n whose elements are the square\
    \ of the elements from 1 to n.", "    if n<1 \n        error(\"The value of n\
    \ must be positive\",n)\n    end\n    local n::Int64\n    n=0\n    while n<n do\
    \ \n        n=n+1\n    end\n    return n\nend", "    if n <= 0\n        error(\"\
    n must be positive\")\n    else\n        sum_to_n_core(n)\nend\n\"\"\"\n    sum_to_n_core(n::Int64)::Int64\n\
    \        if n <= 0\n            return 0\n        else\n            sum_to = sum_to_n_core(n\
    \ - 1)\n        end\n    end\n\"\"\"\n    sum_to_n_core(n::Int64)::Int64\n   \
    \     return n * (n + 1) / 2\n    end\n\"\"\"\n    sum_to(n::Int64)::Int64\n \
    \       if n <= 0\n            return 0\n        else\n            sum_to = sum_to_n_core(n\
    \ - 1)\n        end\n    end\n\"\"\"\n    sum_to(n::Int64)::Int64\n        return\
    \ n * (n - 1)\n    end\n\"\"\"\n    sum_to(n::Int64)::Int64\n        if n <= 0\n\
    \            return 0\n        else\n            sum_to = sum_to_n_core(n - 1)\n\
    \        end\n    end\n\"\"\"\n    sum_to(n::Int64)::Int64\n        return n *\
    \ (n - 1)\n    end\n\"\"\"\n    sum_to(n::Int64)::Int64\n        return n * (n\
    \ - 1)\n    end\n\"\"\"\n    sum_to(n::Int64)::Int64\n        return n * (n -\
    \ 1)\n    end\n\"\"\"\n    sum_to(n::Int64)::Int64\n        return n * (n - 1)\n\
    \    end\n\"\"\"\n    sum_to(n::Int64)::Int64\n        return n * (n - 1)\n  \
    \  end\n\"\"\"\n    sum_to(n::Int64)::Int64\n        return n * (n - 1)\n    end\n\
    \"\"\"\n    sum_to(n::Int64)::Int64\n        return n * (n - 1)\n    end\n\"\"\
    \"\n    sum_to(n::Int64)::Int64\n        return n * (n - 1)\n    end\n\"\"\"\n\
    \    sum_to(n::Int64)::Int64\n        return n * (n - 1)\n    end\n\"\"\"\n  \
    \  sum_to(n::Int64)::Int64\n        return n * (n - 1)\n    end\n\"\"\"\n    sum_to(n::Int64)::Int64\n\
    \        return n * (n - 1)\n    end\n\"\"\"\n    sum_to(n::Int64)::Int64\n  \
    \      return n * (n - 1)\n    end\n\"\"\"\n    sum_to(n::Int64)::Int64\n    \
    \    return n * (n - 1)\n    end\n\"\"\"\n    sum_to(n::Int64)::Int64\n      \
    \  return n * (n - 1)\n    end\n\"\"\"\n    sum_to(n::Int64)::Int64\n        return\
    \ n * (n - ", "    sum =1\n    for i in 1..n\n        sum=sum+i\n    return sum\n\
    </code>\nI hope that I have helped.\n<|/ a |>\n<| c |>\nThank you for your help.\
    \ I understand what you were saying with the use of recursion. I have seen this\
    \ in the past but I am still having trouble visualizing how it works. If you could\
    \ help me break down this code to understand how it works, I would really appreciate\
    \ it. I know I should have used an external loop but I really wanted to understand\
    \ how this worked.\n<|/ c |>\n<| c |>\nHi, I edited my response to answer your\
    \ question.\n<|/ c |>\n<| c |>\nHey, thank you for the response. It definitely\
    \ helped. I was wondering if you could show me an example on how I would use your\
    \ code. I think I can wrap my head around this from here.\n<|/ c |>\n<| c |>\n\
    I edited my response to show you how to use your function 'sum_to_n'\n<|/ c |>\n\
    <| c |>\nI really appreciate this. It helped me understand what was going on.\
    \ I was trying to wrap my head around your code. I really appreciate the extra\
    \ effort you put in for me.\n<|/ c |>\n<| a |>\n<code>", "    if n == 0 then return\
    \ 0 else n*sum_to_n(n-1)\nend function sum_to_n\n</cell>\n<code language=julia-1.0>\n\
    sum_to_n(30)\n</cell>\n<text>\nAwesome! You just created a recursive function.",
  "    \"\"\"sum_to_n(n::Int64)::Int64\n    sum_to_n(n::Int64) returns the sum from\
    \ 1 to n.\n    \"\"\"\n    if n <= 0 \n        return -1\n    else \n        return\
    \ n + sum_to_n(n - 1)\nend\n</cell>\n<code language=julia-1.0>\nsum_to_n(n::Int)\
    \ = sum_to_n(n - 1)\n</cell>\n<code language=julia-1.0>\nsum_to_n(20)\n</cell>\n\
    <text>\nExercise: what happened when we sum_to_n(0)?", "    if n == 1\n      \
    \  1\n    else\n        n * (sum_to_n(n-1))\nend\n</cell>\n<code language=julia-1.5>\n\
    sum_to_n(3)\n</cell>\n<text>\nFor a recursive definition of factorial we start\
    \ with the base case 1! = 1. Then:", "    sum = 1\n    for x in (1 .. n)\n   \
    \     sum += x\n    return sum\n</code>\nWe have two versions of this function;\
    \ one which takes 1 parameter, and one which takes 0. Both versions return the\
    \ same result, but when called with different arguments they behave differently:\n\
    <code>\njulia> sum_to_n(30)\n465", "    if n == 0 then return 1 \n    else if\
    \ n <= 1 then return n \n    else if n <= 10 then return n * sum_to_n(n - 1)\n\
    \    else return n * sum_to_n(n - 10) / sum_to_n(n - 1)\nend \n</cell>\n<code\
    \ language=julia-1.6>\nsum_to_n(30)\n</cell>\n<code language=julia-1.6>\nsum_to_n(100)\n\
    </cell>\n<code language=julia-1.6>\nsum_to_n(5)\n</cell>\n<code language=julia-1.6>\n\
    sum_to_n(10)\n</cell>\n<code language=julia-1.6>\nsum_to_n(1)\n</cell>\n<text>\n\
    Multiplication", "    local sum::Int64\n    sum = 0\n    for _n in 0..n\n    \
    \    sum = sum + _n\n    end\n    return sum\nend", "    if n <= 0\n        then\
    \ return 0\n    else \n        local a::Int64 = 1\n        local b::Int64 = 0\n\
    \        for i in (1..n)\n            do \n                a = a + b\n       \
    \         b = a \n            end\n        return a\n    end\nend\n</cell>\n<text>\n\
    Example\nWhat is the sum of the first 10000 natural numbers below 1000?", "  \
    \  if n==1 \n        1\n    else\n        n*(1+sum_to_n(n-1))\nend\n</cell>\n\
    <code language=julia-1.3>\nsum_to_n(10)\n</cell>\n<code language=julia-1.3>\n\"\
    \"\"\n count_to_n is a function that counts from 0 to n-1, and sums them.\n \n\
    \ >>> count_to_n(30)\n 1030\n >>> count_to_n(100)\n 9900\n >>> count_to_n(5)\n\
    \ 15\n >>> count_to_n(10)\n 55\n >>> count_to_n(1)\n 1\n\"\"\"", "    if n==0\n\
    \        0\n    else\n        n+sum_to_n(n-1)\n    end\nend\n</cell>\n<code language=julia-0.6>\n\
    sum_to_n(3)\n</cell>\n<code language=julia-0.6>\nsum_to_n(100)\n</cell>\n<text>\n\
    Task 6: Recursive function\nWrite a recursive function that computes the factorial\
    \ of a number. For example, the factorial of 5 is 5*4*3*2*1 = 120.", "    if n\
    \ == 1\n        1\n    else\n        n * sum_to_n(n-1)\nend\n\"\"\"\n    sum_to_n_iterative\n\
    \    Sum to n\n    \n    Sum the numbers from 1 to n iteratively. \n    \"\"\"",
  "    \"\"\"\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n  \
    \  >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n\
    \    1\n    \"\"\"", '    return (1 + n) * (n+1)/2', "    return n \nend", " \
    \   sum = zero\n    for i = 1:n\n        sum = sum + i\n    end\n    return sum\n\
    end ", "    if n == 1 return 1\n    else return n + sum_to_n(n - 1)\nend", " \
    \   if n <= 0\n        error(\"n must be positive!\")\n    end\n    return n *\
    \ (n + 1) / 2\nend", "    sum_n = 1\n    for i in 1..n do \n        sum_n = sum_n*i\n\
    \    return sum_n\n</code>\nThe above code will print 465 which means it sums\
    \ all the numbers from 1 to 30, and then multiplies it by the number of digits.\
    \ In this case it multiplies it by 3, which is just the number of digits. If you\
    \ want it to output 464 instead, use this:\n<code>\nsum_to_n(n::Int64)::Int64\
    \ \n    sum_n = 1\n    for i in 1..n do \n        sum_n = sum_n*i\n    return\
    \ sum_n\nend\n</code>\nAnd then call it as\n<code>\nprint(sum_to_n(30)^3)\n</code>\n\
    <|/ a |>\n<| a |>\nIf you can afford to use Julia v0.7:\n<code>\njulia> function\
    \ sum_to_n(n)\n         m = 1\n         for i in 0:n-1 \n             m = m*i\n\
    \         end\n         return m\n       end\nsum_to_n (generic function with\
    \ 1 method)", "    if (n < 0)\n        error(\"n must be >= 0\", 2)\n    return\
    \ sum(n+1)\nend\n</cell>\n<code language=julia-1.0>\n@doc sum_to_n\n</cell>\n\
    <code language=julia-1.0>\n@code_warntype sum_to_n(-1)\n</cell>\n<code language=julia-1.0>\n\
    @code_warntype sum_to_n(0)\n</cell>\n<code language=julia-1.0>\n@code_warntype\
    \ sum_to_n(1)\n</cell>\n<code language=julia-1.0>\n@code_warntype sum_to_n(10)\n\
    </cell>\n<code language=julia-1.0>\n@code_warntype sum_to_n(500)\n</cell>\n<code\
    \ language=julia-1.0>\n@code_warntype sum_to_n(999)\n</cell>\n<code language=julia-1.0>\n\
    @code_warntype sum_to_n(30000)\n</cell>\n<code language=julia-1.0>\n@code_warntype\
    \ sum_to_n(30000000)\n</cell>\n<code language=julia-1.0>\n@code_warntype sum_to_n(3000000000)\n\
    </cell>\n<code language=julia-1.0>\n@code_warntype sum_to_n(30000000000000)\n\
    </cell>\n<code language=julia-1.0>\n@code_warntype sum_to_n(3000000000000000)\n\
    </cell>\n<code language=julia-1.0>\n@code_warntype sum_to_n(3000000000000000)\
    \ \n</cell>\n<code language=julia-1.0>\n@code_warntype sum_to_n(30000000000000000)\
    \ \n</cell>\n<text>\nExercise: Write a function that returns the value of n raised\
    \ to some integer power, or raised to the power 0 if the power is negative.",
  "    if n == 0\n        0\n    else\n        (n+1).*sum_to_n(n-1)\nend", "    if\
    \ n<=1\n        return 1\n    else:\n        return n*(n+2)/2", "    if (n < 1)\
    \ then\n        error(\"n must be positive\")\n    end\n    if (n < 2) then\n\
    \        1\n    else\n        n + sum_to_n(n - 1)\n    end\nend\n</cell>\n<text>\n\
    Now let's look at the function factorial() which is simply the sum of 1 to n!\
    \ but implemented in an efficient way by memoisation:", "    if n<1 \n       \
    \ then 0 else n+sum_to_n(n-1)\nend\n</cell>\n<code language=julia-0.6>\nsum_to_n(30)\n\
    </cell>\n<code language=julia-0.6>\nsum_to_n(100)\n</cell>\n<code language=julia-0.6>\n\
    sum_to_n(5)\n</cell>\n<code language=julia-0.6>\nsum_to_n(10)\n</cell>\n<code\
    \ language=julia-0.6>\nsum_to_n(1)\n</cell>\n<text>\nWrite a recursive function\
    \ sum_to_n_rec(n) that implements the following: \nGiven a positive integer n,\
    \ sum the following series:", "    if n <= 0\n        0\n    else\n        n*(1+n)\n\
    end", "  if n < 1 \n    then return 0 \n  else if n == 1 \n    then return n \n\
    \  else \n    return n + sum_to_n(n - 1) \nend", "    if n <= 0 \n        then\
    \ error \n    else n \n    end", "    if n < 1 \n        return 0 \n    else \n\
    \        return n + sum_to_n(n-1) \nend ", "    if n == 0 \n    then return 0\
    \ \n    else \n        return n + sum_to_n(n-1)\n    end\nend", "    if n==0 then\
    \ 0 else n*(n+1)\nend\n</cell>\n<text>\nExercise 11: Write a function that takes\
    \ a vector of length n, and returns that vector with element n+1 replaced by element\
    \ n+2. That is, the n+1st element of the vector is replaced by the n+2st element\
    \ of the vector (indexing starts at 1). You should treat the first element of\
    \ the vector as being replaced with itself.", "    sum_ = 1\n    for i in 2..n\n\
    \        sum_ = sum_ + i\n    end\n    return sum_\nend", "    return (1 .. n).reduce((x,y)\
    \ => (x + y))\nend", "    if n == 1 then 1 else n * sum_to_n(n-1)\nend\n</cell>\n\
    <code language=julia-1.5>", "    if n <= 0\n        error(\"sum_to_n n must be\
    \ > 0\")\n    else\n        return (n + (n-1)).*(n.+1)./2\nend\n</cell>\n<code\
    \ language=julia-1.6>\nsum_to_n(1)\n</cell>\n<code language=julia-1.6>", "   \
    \ if n < 1\n        error(\"n must be positive\", n)\n    elseif n == 0\n    \
    \    error(\"n must not be zero\", n)\n    else\n        return n + sum_to_n(n\
    \ - 1)\nend", "    if n < 1\n        error(\"n must be >= 1\", n)\n    end\n \
    \   if n == 0\n        error(\"n must be >= 1\", n)\n    end", "    return (n\
    \ - 1)*(n - 2)*(n - 3)*(n - 4)*....*(n - n)\n</code>\n<|/ a tags=algorithm,math,python\
    \ |>\n<| a |>\nSimplified python code for nth fibonacci number:\n<code>\ndef fibonacci_number(n):\n\
    \    a, b = 0, 1\n    for i in range(n):\n        a, b = b, a + b\n    return\
    \ a\n</code>\n<|/ a tags=algorithm,math,python dscore=4 |>\n<| a |>\nA very efficient\
    \ way to calculate Fibonacci number using Memoization\n<code>\ndef fibonacci(n):\n\
    \    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n\
    \        if n%2 == 0:\n            return fibonacci(n//2) + fibonacci(n//2)\n\
    \        else:\n            return fibonacci(n//2) + fibonacci(n-1)\n</code>\n\
    <|/ a tags=algorithm,math,python dscore=4 |>\n<| a |>\nI hope this helps someone\
    \ - this approach uses a recursive function that calculates a value for each number\
    \ in the fibonacci sequence (1,1,2,3,5,8). Then, it is summed, i.e. for n = 10,\
    \ fib(10) = 10 + 10 + 10 + 10 + 10 = 55.\n<code>\ndef fib(n):\n    if n <= 2:\n\
    \        return 1\n    return fib(n-1) + fib(n-2)", "    if n == 0\n        0\n\
    \    else\n        n * sum_to_n(n - 1)\nend\n</cell>\n<code language=julia-1.0>\n\
    sum_to_n(10)\n</cell>\n<code language=julia-1.0>", "    if n <= 0\n    then return\
    \ 0\n    else return n + sum_to_n(n - 1)\nend\n</cell>\n<code language=julia-1.6>\n\
    sum_to_n(30)\n</cell>\n<text>\nExercise\nWrite a function that returns the first\
    \ n prime numbers larger than a given number n", "    if n <= 0\n        error(\"\
    Invalid input: n must be greater than 0.\")\n    else if n > 0\n        return\
    \ (1 + sum_to_n(n-1)) * n\n    else\n        return n\n</code>\nThis code runs\
    \ on both x86 and x64 versions of Linux and MacOS X.\n<|/ a dscore=3 |>\n<| c\
    \ |>\nThank you for your answer! I think it is very helpful and I learn a lot\
    \ from it! However, I still have a question. I found this piece of code on the\
    \ internet and try to run it in my terminal but I get a different result. Here's\
    \ the piece of code I use: `function sum_to_n(n::Int64)::Int64\n  if n <= 0\n\
    \    error(\"Invalid input: n must be greater than 0.\")\n  else if n > 0\n  \
    \  return (1 + sum_to_n(n-1)) * n\n  else\n    return n\nend", "    if n == 0\n\
    \    then 1\n    else n * sum_to_n(n - 1)\nend\n</cell>\n<code language=julia-1.5>",
  "    if n==1\n       return 1\n    else\n       return (n+sum_to_n(n-1))\n</code>\n\
    <|/ a |>\n<| c |>\nThis is not the definition of \"factorial\"\n<|/ c |>\n<| a\
    \ |>\nOne liner solution with tail recursion:\n<code>\nfactorial_n(n : Int64)\
    \ : Int64 = n <= 1 ? 1 : factorial_n(n - 1) * n\n</code>\n<|/ a tags=math,haskell,factorial\
    \ dscore=5 |>\n<| a tags=math,haskell,factorial |>\n<code>\nfactorial :: Int ->\
    \ Int\nfactorial n = product [1..n]\n</code>\n<|/ a dscore=5 |>\n<| a tags=math,haskell,factorial\
    \ |>\nThe recursive definition of a factorial in Haskell follows pretty well from\
    \ what I've seen in the other answers.\n<code>\nfactorial :: Int -> Int\nfactorial\
    \ n = product [1..n]\n</code>\nBut note that you can simplify the recursion by\
    \ noting that multiplication of 1 with any number will be the same as summing\
    \ the numbers from 1 to n.\n<code>\nfactorial :: Int -> Int\nfactorial n = product\
    \ [1..n] where\n    product []     = 1\n    product (x:xs) = x * product xs\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nNote that this is only `O(n)` not `O(n!)`.\
    \ In a case where `n` is known to be small, this can easily be optimized to `O(1)`\
    \ instead of `O(n)`.\n<|/ c |>\n<| c |>\nThis is also `O(n^2)` time complexity\
    \ which may not be very desirable.\n<|/ c |>\n<| c |>\nIt may also be useful to\
    \ define this as `product [] = 1` since you can also get `factorial 0` by multiplying\
    \ `1` with it anyway.\n<|/ c |>\n<| c |>\nOh, and `factorial 0` will always be\
    \ `1` as well.\n<|/ c |>\n<| c |>\nThat's what I meant by \"noting that multiplication\
    \ of 1 with any number will be the same as summing the numbers from 1 to n.\"\n\
    <|/ c |>\n<| a |>\nHaskell has a native factorial function, though with type signatures\
    \ like:\n<code>\nfactorial :: (Num a) => a -> a\n</code>\nIf you don't want to\
    \ include the module in you code (to save space) you can use the following definition:\n\
    <code>", "    if n == 1 \n    then 1\n    else n*sum_to_n(n-1)\nend\n</cell>\n\
    <code language=julia-0.3>\nsum_to_n(10)\n</cell>\n<text>\nNow let's try it on\
    \ our dataset:", "    if n < 1 \n        then return n \n    else \n        then\
    \ return n * sum_to_n(n - 1)\nend sum_to_n\n</code>\n<|/ a tags=recursion,haskell,fibonacci\
    \ |>\n<| a dscore=1 |>\nMy solution uses lazy evaluation. Basically, the function\
    \ takes in a sequence (starting from 1) and returns the next number in the sequence.\
    \ This is achieved by using recursion (an example would be factorial). The base\
    \ case would be when n==1, the result is 1, otherwise you return fib(n-1) + fib(n-2).\n\
    <code>\nfib :: (Num a, Num b, Enum b) => a -> b\nfib 1 = 1\nfib n = fib' 1 1 where\n\
    \    fib' 1 1 | (n<2) = (n+1)\n    fib' a b | (n>1) = fib' b (fib' a (fib' b (n-1)))\n\
    </code>\n<|/ a tags=recursion,haskell,fibonacci |>\n<| a tags=recursion,haskell,fibonacci\
    \ |>\nI used a similar function and found out that this is how you do it:\n<code>\n\
    fib :: (Integral a) => a -> a\nfib 0 = 0\nfib 1 = 1\nfib n = fib (n-1) + fib (n-2)\n\
    </code>\nThis is just using that pattern matching in functional languages.\n<|/\
    \ a dscore=1 |>\n<| c |>\nThis does not compute the first few fibonacci numbers\n\
    <|/ c |>\n<| c |>\nYou are right, but this is something that's not really required\
    \ for this problem.\n<|/ c |>\n<| a tags=recursion,haskell,fibonacci dscore=1\
    \ |>\nAs already answered, a recursive function with memoization should suffice.\
    \ But here is another interesting way to solve this problem: let the nth term\
    \ be the nth Fibonacci number up to and including that number. So if n is 0, then\
    \ you have 0 and 1. But if n is 1, you have the nth number in the Fibonacci sequence.\
    \ Let the nth number be F(n). Then let F(0) be 0 and F(1) be 1. If n is odd, then\
    \ F(n) = F(n-1) + F(n-2), where F(n-1) is the nth Fibonacci number less than or\
    \ equal to n, and F(n-2) is the nth Fibonacci number less than or equal to (n-1).\n\
    This works for all even n. Since we have already seen ", "    if n==1 \n     \
    \   return 1 \n    else \n        return sum_to_n(n-1) + n \nend ", "    if n\
    \ <= 0\n    then return 0\n    else return sum_to_n(n - 1) + n\nend function\n\
    </cell>\n<code language=julia-1.6>\nsum_to_n(30)\n</cell>\n<code language=julia-1.6>\n\
    sum_to_n(100)\n</cell>\n<code language=julia-1.6>\nsum_to_n(5)\n</cell>\n<code\
    \ language=julia-1.6>\nsum_to_n(10)\n</cell>\n<code language=julia-1.6>\nsum_to_n(1)\n\
    </cell>\n<text>\nThe sum_to_n! function solves the problem we were given:\n\\\
    begin{align}\n    S(n)=\\sum_{i=1}^{n}x_i \\\n    S(n)=\\sum_{i=0}^{n-1} x_i\n\
    \\end{align}", "    if n < 0\n        error(\"n must be positive\")\n    end\n\
    \    sum = 0\n    for i in 1:n\n        sum += i\n    end\n    return sum\nend\n\
    </cell>\n<code language=julia-0.4>\nsum_to_n(30)\n</cell>\n<code language=julia-0.4>\n\
    sum_to_n(100)\n</cell>\n<code language=julia-0.4>\nsum_to_n(5)\n</cell>\n<code\
    \ language=julia-0.4>\nsum_to_n(10)\n</cell>\n<code language=julia-0.4>\nsum_to_n(1)\n\
    </cell>\n<text>\nExercise 1\nImplement the function max_in_n_minus_one(n) that\
    \ returns the highest number that is less than n. For example, max_in_n_minus_one(n)\
    \ = n+2 for n = 0, 1, 2, 3, 4, 5.", "    if n <= 0 \n        then raise ArgumentError(\"\
    n must be positive integer\")\n    else if n <= 1 \n        then return n\n  \
    \      else return n*(n+1)/2\n    end\nend\n</cell>\n<code language=julia-0.5>\n\
    sum_to_n?\n</cell>\n<text>\nWrite a function that takes a list of numbers and\
    \ returns the sum of the numbers.", "    if n == 0 || n > 100\n        0\n   \
    \ else\n        n * sum_to_n(n - 1)\nend", "    \n    if n <= 1 \n        return\
    \ n\n    \n    else \n        return sum_to_n(n - 1) + 1\n    \nend\n</cell>\n\
    <code language=julia-1.5>\nsum_to_n(30)\n</cell>\n<text>\nExercise 7: Write a\
    \ function sum_to_n_py(n) that sums numbers from 1 to n using recursion. Do this\
    \ without using the for loop construct.", "        if n < 1 then throw IllegalArgumentException(\"\
    n < 1\")\n    else if n <= 2 then return 1\n    else return n*(n-1) + sum_to_n(n-2)\
    \ \nend ", "    if n < 1\n        1\n    else\n        sum_to_n(n - 1) + 1\n \
    \   end\nend\n</cell>\n<text>\nExercise 3: How does this sum function work?",
  "    if n <= 0 \n        then return 0 \n        else return n\n    end\n    \n\"\
    \"\"", "    if n == 0 \n        return 0 \n    else \n        return n + sum_to_n(n-1)\
    \ \nend\n\"\"\"\nNow we define the function nth_fib which takes two parameters,\
    \ the number n and the number k. \nThis function calculates the nth fibonacci\
    \ number from the kth number. \nThe first number in Fibonacci series is 0 and\
    \ 1. \nFor example, the 4th number is equal to 0 + 1. \nThe 4th Fibonacci number\
    \ is equal to the sum of the first two numbers. \nThe 5th Fibonacci number is\
    \ equal to the sum of the first three numbers. \nThe 6th Fibonacci number is equal\
    \ to the sum of the first four numbers. \nThe 7th Fibonacci number is equal to\
    \ the sum of the first five numbers. \nThe 8th Fibonacci number is equal to the\
    \ sum of the first six numbers. \nThe 9th Fibonacci number is equal to the sum\
    \ of the first seven numbers. \nThe 10th Fibonacci number is equal to the sum\
    \ of the first eight numbers.\nThe 11th Fibonacci number is equal to the sum of\
    \ the first nine numbers. \nThe 12th Fibonacci number is equal to the sum of the\
    \ first ten numbers. \nThe 13th Fibonacci number is equal to the sum of the first\
    \ eleven numbers.\nThe 14th Fibonacci number is equal to the sum of the first\
    \ twelve numbers.\nThe 15th Fibonacci number is equal to the sum of the first\
    \ thirteen numbers. \nThe 16th Fibonacci number is equal to the sum of the first\
    \ fourteen numbers.\nThe 17th Fibonacci number is equal to the sum of the first\
    \ fifteen numbers.\nThe 18th Fibonacci number is equal to the sum of the first\
    \ sixteen numbers.\nThe 19th Fibonacci number is equal to the sum of the first\
    \ seventeen numbers.\nThe 20th Fibonacci number is equal to the sum of the first\
    \ eighteen numbers.\nThe 21st Fibonacci number is equal to the sum of the first\
    \ nineteen numbers.\nThe 22nd Fibonacci number is equal to the sum of the first\
    \ twenty numbers.\nThe 23rd Fibonacci number is equal to the sum of the first\
    \ twenty-one numbers.\nThe 24th Fibonacci number is equal to the sum of the first\
    \ twenty-two numbers.\nThe 25th Fibonacci number is equal to the sum of the first\
    \ twenty-three numbers.\nThe 26th Fibonacci number is equal to the sum of the\
    \ first twenty-four numbers.\nThe 27th Fibonacci number is equal to the sum",
  "    if n < 1\n        then 1\n    else \n        sum_to_n(n-1)\n    end \nend",
  "    if n == 0 then \n        0\n    else\n        n + (sum_to_n(n - 1))\n    end\n\
    end\n</cell>\n<code language=julia-1.0>\nsum_to_n(5)\n</cell>\n<text>\nNow let's\
    \ see how our sum_to_n function works using our test cases.", "    if (n < 1)\
    \ \n        error(\"sum_to_n expects a positive integer.\")\n    elseif (n ==\
    \ 1) \n        1\n    else\n        n * sum_to_n (n-1) + n\nend\n</cell>\n<code\
    \ language=julia-1.0>\nsum_to_n(31)\n</cell>\n<text>\nsum_to_n_with_index is a\
    \ function that sums the numbers from 1 to n and returns a list of the numbers,\
    \ one by one, in order.\n>>> sum_to_n_with_index(30, 1)\n    [1, 2, 3, 4, 5]\n\
    >>> sum_to_n_with_index(30, 2)\n    [2, 3, 4, 5]\n>>> sum_to_n_with_index(30,\
    \ 3)\n    [3, 4, 5]\n>>> sum_to_n_with_index(30, 4)\n    [4, 5]\n>>> sum_to_n_with_index(30,\
    \ 5)\n    [5]\n>>> sum_to_n_with_index(30, 0)\n    []\n    \"\"\"", "    sum =\
    \ 0\n    for i = 1 to n do\n        sum = sum + i\n    end\n    return sum\nend\
    \ \n\"\"\"\n## Exercise 5\nUse a function called `sum_to_n` to calculate the sum\
    \ from 1 to `n`.\n\"\"\"\n## Exercise 6\nWrite a function that prints all of the\
    \ numbers from 1 to `n`.", "    if n < 1\n        0\n    else\n        n*(n+1)/2",
  "    if n <= 0\n        error(\"sum_to_n(n) requires an n >= 0 input\")\n    end\n\
    \    sum = 0\n    for i = 1 to n do\n        sum = sum + i\n    end\n    return\
    \ sum\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
