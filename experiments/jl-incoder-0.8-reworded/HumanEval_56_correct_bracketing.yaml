name: HumanEval_56_correct_bracketing
language: jl
prompt: "\"\"\" brackets is a string of \"<\" and \">\".\n    return true if every\
  \ opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"\
  <\")\n    false\n    >>> correct_bracketing(\"<>\")\n    true\n    >>> correct_bracketing(\"\
  <<><>>\")\n    true\n    >>> correct_bracketing(\"><<>\")\n    false\n    \"\"\"\
  \nfunction correct_bracketing(brackets::String)::Bool \n"
tests: "using Test\n\n@testset begin\n\ncandidate = correct_bracketing;\n\t@test(candidate(\"\
  <>\") == true)\n\t@test(candidate(\"<<><>>\") == true)\n\t@test(candidate(\"<><><<><>><>\"\
  ) == true)\n\t@test(candidate(\"<><><<<><><>><>><<><><<>>>\") == true)\n\t@test(candidate(\"\
  <<<><>>>>\") == false)\n\t@test(candidate(\"><<>\") == false)\n\t@test(candidate(\"\
  <\") == false)\n\t@test(candidate(\"<<<<\") == false)\n\t@test(candidate(\">\")\
  \ == false)\n\t@test(candidate(\"<<>\") == false)\n\t@test(candidate(\"<><><<><>><>><<>\"\
  ) == false)\n\t@test(candidate(\"<><><<><>><>>><>\") == false)\nend\n"
completions: ["    \"\"\"\n    CorrectBracketing : string -> bool\n    \n    Returns\
    \ true if brackets is correctly braced.\n    \n    >>> correct_bracketing(\"<\"\
    )\n    false\n    >>> correct_bracketing(\"<>\")\n    true\n    >>> correct_bracketing(\"\
    <<><>>\")\n    true\n    >>> correct_bracketing(\"><<>\")\n    false\n    \"\"\
    \"\n    \n    if brackets == \"\" then return false\n    else if brackets == \"\
    <\" then return true\n    elif brackets == \"<>\" then return true\n    elif brackets\
    \ == \"<>...\" then return false\n    else if brackets == \"><\" then return true\n\
    \    else if brackets == \">>\" then return true\n    else if brackets == \">>...\"\
    \ then return false\n    else if brackets == \">>>\" then return true\n    else\
    \ if brackets == \">>...\" then return false\n    else if brackets == \">>>...\"\
    \ then return false\n    else if brackets == \">>>...\" then return false\n  \
    \  else return false\nend", "    \"\"\"\n    correct_bracketing corrects bracketing\
    \ in a string. ", "    true\nend\n</cell>\n<text>\nExercise 3\nWrite a function\
    \ that takes a String of any length and returns the number of times a single character\
    \ appears.", "    \"\"\"returns true if brackets is a string of \"<\" and \">\"\
    .\n    return true if every opening bracket has a corresponding closing bracket.",
  "    for bracket in brackets do\n        if bracket.head != bracket.tail then\n\
    \            false\n        else\n            true\n        end\n    end\nend",
  "    brackets = brackets\n    for i in brackets.indices:\n        if brackets[i]\
    \ != brackets[i+1]:\n            return False\n    return True\nend", "    \"\
    \ brackets is a string of \"<\" and \">\".\n    bracket_table = {'<':'&lt;', '>':'&gt;'}\n\
    \    for c in brackets:\n        if c in bracket_table:\n            return true\n\
    \    return false\n</code>\n<|/ a tags=julia,brackets,string |>\n<| a tags=julia,brackets,string\
    \ |>\nI like the accepted answer. It works, but it's inefficient because it creates\
    \ a string for every character in the string. Here's a version that's slightly\
    \ more efficient as it only does it once:\n<code>", "    if brackets == \"\" then\
    \ \n        true\n    elseif brackets == \"<\" then \n        false\n    elseif\
    \ brackets == \"<?>\" then \n        true\n    elseif brackets == \"<*>\" then\
    \ \n        true\n    elseif brackets == \"<??>\" then \n        false\n    elseif\
    \ brackets == \"<<>>\" then \n        false\n    elseif brackets == \"<?>\" then\
    \ \n        true\n    elseif brackets == \"<*?>\" then \n        true\n    elseif\
    \ brackets == \"<?>?>\" then \n        false\n    elseif brackets == \"<???>\"\
    \ then \n        true\n    elseif brackets == \"<*?>?\" then \n        false\n\
    \    elseif brackets == \"<?>*\" then \n        true\n    elseif brackets == \"\
    <?>?\" then \n        true\n    elseif brackets == \"<*>?\" then \n        false\n\
    \    elseif brackets == \"<*?>?\" then \n        false\n    elseif brackets ==\
    \ \"<?>*?>\" then \n        true\n    elseif brackets == \"<*?>??>\" then \n \
    \       true\n    elseif brackets == \"<??>*?>\" then \n        false\n    elseif\
    \ brackets == \"<?>?*\" then \n        true\n    elseif brackets == \"<?>*<?\"\
    \ then \n        false\n    elseif brackets == \"<?>*<*\" then \n        true\n\
    \    elseif brackets == \"<?>?>*\" then \n        false\n    elseif brackets ==\
    \ \"<?>?*<?\" then \n        true\n    elseif brackets == \"<?>?*<*\" then \n\
    \        false\n    elseif brackets == \"<?>*<??\" then \n        true\n    elseif\
    \ brackets == \"<?>*<?*\" then \n        true\n    elseif brackets == \"<?>*<*?>\"\
    \ then \n        true\n    elseif brackets == \"<?>?*<?*\" then \n        false\n\
    \    elseif brackets == \"<?>?*<*?>\" then \n        true\n    elseif brackets\
    \ == \"<??>*<?*\" then \n        false\n    elseif brackets == \"<?>?*<*?>\" then\
    \ \n        false\n    elseif brackets == \"<??>*<?*?>\" then \n        true\n\
    \    elseif brackets == \"<??>*<*?>?\" then \n        true\n    elseif brackets\
    \ == \"<?>?*<?*?>\" then \n        true\n    else", "    ...\n    loop:\n    \
    \    for s in brackets\n            if s == \"<\"\n                if brackets[brackets.index(s)+1]\
    \ == \"<\"\n                    return true\n                if brackets[brackets.index(s)+1]\
    \ == \">\"\n                    return true\n                continue loop\n \
    \           if s == \">\"\n                if brackets[brackets.index(s)-1] ==\
    \ \"<\"\n                    return true\n                if brackets[brackets.index(s)-1]\
    \ == \">\"\n                    return true\n                continue loop\n \
    \           return false\n</code>\nNow it's just a matter of using map to loop\
    \ over each string in the list brackets, and replace each \"< >\" with \"< > >\"\
    , then using reduce to concatenate all the results.\n<code>\nbracketing_corrected\
    \ = reduce(concat, map(correct_bracketing, [\"<><\", \"<><>\", \"<<><>>\"]))\n\
    </code>\n<|/ a |>\n<| a tags=haskell,string,list dscore=1 |>\n<code>\nimport Data.List\
    \ (intercalate)", "    \n    \"\"\"\n    Corrects bracketing if brackets are not\
    \ correct.", "    if brackets == \"\" \n        then return true\n    else \n\
    \        if brackets[0] == \"<\"\n            then return false\n        else\
    \ if brackets[0] == \">\"\n            then return true\n        else return correct_bracketing(brackets[1:end])\n\
    \    end\nend\n</cell>\n<cell>", "\"\"\"\n    Checks brackets for validity. Input\
    \ is a string of \"<\" and \">\"\n    brackets is a string of \"<\" and \">\"\
    .\n    return true if every opening bracket has a corresponding closing bracket.",
  "    |\n    if brackets == \"\"\n        false\n    elseif brackets == \"<>\"\n\
    \        true\n    else\n        correct_bracketing(brackets[0..1]) && correct_bracketing(brackets[2..length(brackets)])\n\
    \    end\nend\n</cell>\n<text>\n\u25CB What is the largest number smaller than\
    \ 20 that is divisible by 5?", "    brackets = brackets.split(\"<\")\n    brackets\
    \ = filter( \\\n        lambda x:x.count(\"<\") ==1 and not x.endswith(\">\"),\n\
    \        brackets)\n    brackets = filter( \\\n        lambda x:x.count(\"<\"\
    ) == 0 and x.endswith(\">\"),\n        brackets)\n    brackets = filter( \\\n\
    \        lambda x:x.endswith(\">>\"),\n        brackets)\n    brackets = filter(\
    \ \\\n        lambda x:x.count(\"<\") == 0   and  x.endswith(\">>\"),\n      \
    \  brackets)\n    brackets = filter( \\\n        lambda x:x.count(\"<\") == 0\
    \   and  x.endswith(\"<<\"),\n        brackets)\n    brackets = filter( \\\n \
    \       lambda x:x.count(\"<\") == 0   and  x.endswith(\">><<\"),\n        brackets)\n\
    \    brackets = filter( \\\n        lambda x:x.count(\"<\") == 0   and  x.endswith(\"\
    >>>\"),\n        brackets)\n    brackets = filter( \\\n        lambda x:x.count(\"\
    <\") == 0 and x.endswith(\"<<<\"),\n        brackets)\n    return all( brackets\
    \ )\n</code>\n<|/ a tags=string,regex,python |>\n<| c |>\nI think your brackets\
    \ are off. Shouldn't it be `[<>]`? Also, why don't you test `<<<<>`? It's not\
    \ even valid code.\n<|/ c |>\n<| c |>\nThe brackets here are actually [regex character\
    \ classes](https://docs.python.org/2/howto/regex.html?highlight=regex%20character%20classes#regular-expression-syntax-character-classes).\
    \ Also, the example is obviously a typo, but I can't edit it anymore without making\
    \ some edits.\n<|/ c |>\n<| c |>\n`[<>]` doesn't match `<<<` nor any other valid\
    \ bracketing.\n<|/ c |>\n<| c |>\nYes, it does. [<>] matches any of the four brackets.\n\
    <|/ c |>\n<| c |>\n`<<<<` is valid code, and is even valid with some editors (specifically\
    \ sublime). But it isn't valid Python.\n<|/ c |>\n<| a dscore=1 tags=string,regex,python\
    \ |>\nHow about:\n<code>\n>>> '<><><>'.count('<><>')\n4\n</code>\n<|/ a |>\n<|\
    \ a tags=string,regex,python dscore=1 |>\nThis regex should do what you want:\n\
    <code>\n>>> import re\n>>> def check_brackets(s):\n...     return ", "    bracket_count\
    \ = 0\n    for c in brackets\n        if c == \"<\"\n            bracket_count\
    \ += 1\n        elseif c == \">\"\n            bracket_count -= 1\n        elseif\
    \ c == \"<>\"\n            bracket_count = -bracket_count\n        elseif c ==\
    \ \"<<\"\n            bracket_count += 1\n        elseif c == \"<>>\"\n      \
    \      bracket_count -= 1\n        else\n            assert(false)\n    end\n\
    \    return bracket_count == 0\nend\n</cell>\n<text>\nExercise 4\nUse the function\
    \ correct_bracketing above to test the correctness of brackets.", "    brackets\
    \ = brackets[2:end-1]\n    open_brackets = findall(r\">\", brackets)\n    closed_brackets\
    \ = findall(r\"<\", brackets)\n    return length(open_brackets) == length(closed_brackets)\n\
    end", "    correct_bracketing <- is_bracketed(brackets) &&\n        all(bracketed\
    \ -> is_bracketed(bracketed, true) && bracketed != brackets,\n            zip(brackets,\
    \ tail(brackets)))\nend\n</cell>\n<code language=julia-1.0>\n# test function",
  "    if brackets.length() == 1 then return brackets.length() == 1\n    else if brackets.length()\
    \ < 2 then return false\n    else if brackets.length() == 2 then return brackets.head\
    \ == brackets.last && brackets.head == \"<\"\n    else if brackets.head == \"\
    <\" && brackets.last == \">\" then return correct_bracketing(brackets.tail)\n\
    \    else if brackets.head == brackets.last then return correct_bracketing(brackets.tail)\n\
    \    else return false\nend\n</cell>\n<text>\nTask 3 : Bracketing\nIn this task\
    \ we will work with a problem of bracketing and we will implement the bracket\
    \ method of our BST class to handle it. Note that the bracketing problem is stated\
    \ in the beginning of this notebook.", "    \n    open_brackets = [brackets[i]\
    \ for i in range(0, length(brackets)) if brackets[i] == \"<\"]\n    close_brackets\
    \ = [brackets[i] for i in range(0, length(brackets)) if brackets[i] == \">\"]\n\
    \    \n    return length(open_brackets) == length(close_brackets)", "    return\
    \ brackets == '<' or brackets == '>' or brackets == '<>>' or brackets == '<<<'\
    \ or brackets == '<<' or brackets == '<><>'", "    \n\"\"\"\n    Your solution\
    \ to Exercise 6 should call correct_bracketing.\n    It should return a Bool indicating\
    \ whether or not the bracketing \n    structure is correct.", "    local brackets\
    \ = brackets:gsub(\"<<>>\",\">>\"):gsub(\"<>\",\"><\"):gsub(\"<\",\"><>\")\n \
    \   brackets = brackets:gsub(\"<<\",\"><\")\n    brackets = brackets:gsub(\">>\"\
    ,\"<\")\n    brackets = brackets:gsub(\"<<\",\"<\")\n    brackets = brackets:gsub(\"\
    >>\",\"<\")\n    brackets = brackets:gsub(\"<<\",\"<\")\n    brackets = brackets:gsub(\"\
    >>\",\"<\")\n    return brackets:find(\"<>\") == 0\nend", "    \"\"\"\n    Write\
    \ a function that takes bracketing text and checks if it's correct bracketing.",
  "\"\"\"\n    Function that takes in a string of brackets and returns true if the\
    \ brackets are balanced and false if not. Brackets is a string of \"<\" and \"\
    >\".\n    return true if every opening bracket has a corresponding closing bracket.",
  "    brackets = brackets.trim()\n    return brackets.all(fun x -> \n      x in \"\
    ()<>\"\n    )", "  brackets = brackets\n  for i in 1 .. (length(brackets) - 1)\n\
    \    do\n      if brackets[i] != brackets[i + 1]\n        return false;\n    end\n\
    \    return true\nend\n</code>\nThis can be done more efficiently if we first\
    \ split the string into groups of brackets, then we process each group, using\
    \ a stack to determine if the parentheses match (which requires remembering the\
    \ order in which the opening brackets were encountered). Finally, we join the\
    \ resulting groups back together.\n<code>", "    if brackets.head == brackets.last\
    \ \n        and brackets.head == brackets.head \n            then true \n    \
    \        else false\n        end\n    end\nend\n</cell>\n<text>\nQuestion 8. Complete\
    \ the function correct_bracketing below so that it returns true if brackets has\
    \ correct pairs of brackets. Otherwise, return false.", "    brackets_length =\
    \ length(brackets)\n    if brackets_length == 1\n        return true\n    elseif\
    \ brackets_length == 0 \n        return false\n    elseif brackets_length == 1\n\
    \        return false\n    else\n        for i in 1..brackets_length\n       \
    \     if brackets[i] != brackets[brackets_length+i]\n                true\n  \
    \          else\n                false\n        end\n    end\nend\n</cell>\n<text>\n\
    Exercise: Implement the correct bracketing function\nWrite a function that checks\
    \ if the given bracket string is valid or not.", "    if brackets == \"<\"\n \
    \       true\n    elseif brackets == \"<>\"\n        true\n    else\n        false\n\
    \    end\nend\n</cell>\n<text>\nAs a reminder, the following code snippet creates\
    \ a new function correct_bracketing in the global namespace. The first argument\
    \ to the function must be the string \"<\" or the string \"<>\". The function\
    \ returns true if the bracketing is correct, and false if not.", "    # check\
    \ if brackets is an open or close bracket\n    if brackets[1] == brackets[2:]\n\
    \        true\n    else\n        false\nend\n</code>\nFor your question on splitting\
    \ strings, look at this post from another StackOverflow post:\nHow can I split\
    \ a string with multiple delimiters in Julia?\n<|/ a dscore=1 tags=julia,regex,string\
    \ |>\n<| c |>\nThank you very much for your answer, but the `split` function returns\
    \ a `Vector`, so how do I convert it to a `String`? Because the split function\
    \ returns a `Vector`\n<|/ c |>\n<| c |>\nHi, I'm confused about what you mean\
    \ by \"convert the vector to a string\". Could you give a specific example? Maybe\
    \ you could also try rephrasing your question in the form of a question so that\
    \ more people can see it and try to answer.\n<|/ c |>\n<| a |>\nHere is a simpler\
    \ way to achieve your desired output:\n<code>\njulia> string(\">><<>>><><\")\n\
    \">>>>>><>\"", "    # Implement this!\nend\n</cell>\n<text>\nExercise 9\nImplement\
    \ the function count_bracketings (for full marks) that takes in a list of brackets\
    \ (in quotes) and returns the number of brackets represented by those strings.\
    \ \nFor example, suppose we had the following string:", "    brackets = brackets.replace(\"\
    <<\", \">>\").lower()\n    brackets = brackets.replace(\"<\", \">\").lower()\n\
    \    brackets = brackets.replace(\"<\", \"\").replace(\"</>\", \"\").replace(\"\
    <<<\", \">>\").lower()\n    brackets = brackets.replace(\"<<<\", \"\").replace(\"\
    <<\", \"\").replace(\"<>>\", \"\").replace(\">>\", \"\").lower()\n    brackets\
    \ = brackets.replace(\"<<<\", \"\").replace(\"<<\", \"\").replace(\"<>>\", \"\"\
    ).replace(\">>\", \"\").lower()\n    brackets = brackets.replace(\"<<\", \"\"\
    ).replace(\"<<\", \"\").replace(\"<>>\", \"\").replace(\">>\", \"\").lower()\n\
    \    brackets = brackets.replace(\"<<\", \"\").replace(\"<<\", \"\").replace(\"\
    <>>\", \"\").replace(\">>\", \"\").lower()\n    brackets = brackets.replace(\"\
    <<\", \"\").replace(\"<<\", \"\").replace(\"<>>\", \"\").replace(\">>\", \"\"\
    ).lower()\n    brackets = brackets.replace(\"<<\", \"\").replace(\"<<\", \"\"\
    ).replace(\"<>>\", \"\").replace(\">>\", \"\").lower()\n    brackets = brackets.replace(\"\
    <<\", \"\").replace(\"<<\", \"\").replace(\"<>>\", \"\").replace(\">>\", \"\"\
    ).lower()\n    brackets = brackets.replace(\"<<\", \"\").replace(\"<<\", \"\"\
    ).replace(\"<>>\", \"\").replace(\">>\", \"\").lower()\n    brackets = brackets.replace(\"\
    <<\", \"\").replace(\"<<\", \"\").replace(\"<>>\", \"\").replace(\">>\", \"\"\
    ).lower()\n    brackets = brackets.replace(\"<<\", \"\").replace(\"<<\", \"\"\
    ).replace(\"<>>\", \"\").replace(\">>\", \"\").lower()\n    brackets = brackets.replace(\"\
    <<\", \"\").replace(\"<<\", \"\").replace(\"<>>\", \"\").replace(\">>\", \"\"\
    ).lower()\n    brackets = brackets.replace(\"<<\", \"\").replace(\"<<\", \"\"\
    ).replace(\"<>>\", \"\").replace(\">>\", \"\").lower()\n    brackets = brackets.replace(\"\
    <<\", \"\").replace(\"<<\", \"\").replace(\"<>>\", \"\").replace(\">>\", \"\"\
    ).lower()\n    brackets = brackets.replace(\"<<\", \"\").replace(\"<<\", \"\"\
    ).replace(\"<>>\", \"\").replace(\">>\", \"\").lower()\n    brackets = brackets.replace(\"\
    <<\", \"\").replace(\"<<\", \"\").replace(\"<>>\", \"\").replace(\">>\", \"\"\
    ).lower()\n    brackets = brackets.replace(\"<<\", \"\").replace(\"<<\", \"\"\
    ).replace(\"<>>\", \"\").replace(\">>\", \"\").lower()\n    brackets = brackets.replace(\"\
    <<\", \"\").replace(\"<<\", \"\").replace(\"<>>\", \"\").replace(\">>\", \"\"\
    ).lower()\n    brackets = brackets.replace(\"<<\", \"\").replace(\"<<\", \"\"\
    ).replace(\"<>>\", \"\").replace(\">>\", \"\").lower()\n    brackets = brackets.replace(\"\
    <<\", \"\").replace(\"<<\", \"\").replace(\"<>>\", \"\").replace(\">>\", \"\"\
    ).lower()\n    brackets = brackets.replace(\"<<\", \"\").replace(\"<<\", \"\"\
    ).replace(\"<>>\", \"\").replace(\">>\", \"\").lower()\n    brackets = brackets.replace(\"\
    <<\", \"\").replace(\"<<\", \"\").replace(\"<>>\", \"\").replace(\">>\", \"\"\
    ).lower()\n    brackets = brackets.replace(\"<<\", \"\").replace(\"<<\", \"\"\
    ).replace(\"<>>\", \"\").replace(\">>\", \"\").lower()\n    bracket", "    local\
    \ opening_brackets = brackets\n        local closed_brackets = \"\"\n        for\
    \ c in opening_brackets do \n            closed_brackets = closed_brackets..\"\
    <\"\n        end\n        return closed_brackets == \"\"\n    end\nend\n</cell>\n\
    <text>\nWe can apply this procedure to any problem in addition to bracketing.",
  "    if brackets == \"\" then return true\n    if brackets == \"<>\" then return\
    \ true\n    if brackets == \"<<><>>\" then return true\n    if brackets == \"\
    <>\" then return true\n    return false\nend correct_bracketing\n</cell>\n<code\
    \ language=julia-1.0>\n\"\"\"\nFunction to determine whether a string is of valid\
    \ brackets", "    brackets = brackets .split(\"<\")\n    for i in 0 .. length(brackets)\
    \ - 1\n        if brackets[i+1] /= brackets[i]\n            return false\n   \
    \ return true\n\"\"\"", "    \"\"\"This function checks if brackets are correctly\
    \ enclosed in brackets.\"\"\"\n    return brackets != \"<>\" &&\n        brackets\
    \ != \"<>\" &&\n        brackets != \"<<><>>\" &&\n        brackets != \"<<><>>\"\
    \ &&\n        brackets != \"<>\" &&\n        brackets != \"<<><>>\" &&\n     \
    \   brackets != \"<<><>>\"\nend", "    \"\"\"\n    Implement this function.\n\
    \    \"\"\"\nend correct_bracketing\n</cell>\n<code language=julia-1.5>\n\"\"\"\
    \nImplement this function.\n\"\"\"", "    \n    # Return true if brackets is an\
    \ empty string.\n    if brackets == \"\" \n    then return true", "    \"\"\"\n\
    \    correct_bracketing(\n      brackets::String\n    )::Bool", "    bracket_opens\
    \ = brackets.count(\"<\")\n    bracket_closes = brackets.count(\">\")\n    return\
    \ bracket_opens == bracket_closes - 1\nend\n</cell>\n<text>\nExercise 8\nWrite\
    \ a function brackets_to_parens that:", "    brackets_ = brackets::String\n  \
    \  open_opens = brackets_.count(\"<\")\n    open_closes = brackets_.count(\"<<\"\
    )\n    close_closes = brackets_.count(\"->>\")\n    return open_opens == open_closes\
    \ and close_closes == open_opens\nend\n</cell>\n<text>\nWe will now try to use\
    \ this function to count the number of matching brackets for any given input:",
  "    \"\"\"\n    correct_bracketing(s::String)::Bool\n    \"\"\"\n    for bracket\
    \ in brackets\n        if opening bracket != closing bracket\n            return\
    \ false\n    end\n    return true\nend", "    if brackets == \"\" then return\
    \ true\n    let brackets = brackets.replace(\"<<<\",\"\").replace(\">>>\",\"\"\
    ).replace(\"--\",\"\").replace(\">>--\",\"\").replace(\">--\",\"\")\n    let open_brackets\
    \ = brackets.split(\"<\").filter(elem => elem != \"\").map(x => x.replace(\"<<<\"\
    ,\"\").replace(\">>>\",\"\").replace(\"--\",\"\").replace(\">>--\",\"\").replace(\"\
    >--\",\"\"))\n    let close_brackets = brackets.split(\">\").filter(elem => elem\
    \ != \"\").map(x => x.replace(\"<<<\",\"\").replace(\">>>\",\"\").replace(\"--\"\
    ,\"\").replace(\">>--\",\"\").replace(\">--\",\"\"))\n    if open_brackets /=\
    \ close_brackets then return false\n    let open_brackets = open_brackets.filter(x\
    \ => x !=\"\").map(x => x.replace(\"<<<\",\"\").replace(\">>>\",\"\").replace(\"\
    --\",\"\").replace(\">>--\",\"\").replace(\">--\",\"\"))\n    let close_brackets\
    \ = close_brackets.filter(x => x !=\"\").map(x => x.replace(\"<<<\",\"\").replace(\"\
    >>>\",\"\").replace(\"--\",\"\").replace(\">>--\",\"\").replace(\">--\",\"\"))\n\
    \    if open_brackets /= close_brackets then return false\n    return true\nend\n\
    </cell>\n<text>\nPart 2\nWrite a function correct_bracketing_with_counting that\
    \ will return a tuple of the form (true/false_count, correct_bracketing).", " \
    \   \"\"\"\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \"\"\"\n\"\"\"\n###\nSolution\n###\n\"\"\"", "\"\"\"\n\
    \    correct_bracketing(brackets::String)", "    \"\"\"\n    Check whether the\
    \ given bracketing string is correct or incorrect.", "    \" brackets is a string\
    \ of \"<\" and \">\".\n    let opening_brackets = brackets |> String.split(\"\
    \ \") |> Array.filter(fun x-> x = \"<\") |> Array.map(fun x->x.[1])\n    let closing_brackets\
    \ = brackets |> String.split(\" \") |> Array.filter(fun x-> x = \">\") |> Array.map(fun\
    \ x->x.[1])\n    if opening_brackets.Length <> closing_brackets.Length\n     \
    \   || opening_brackets |> Array.contains(fun x-> not (List.contains(closing_brackets,\
    \ x)))\n        || closing_brackets |> Array.contains(fun x-> not (List.contains(opening_brackets,\
    \ x)))\n        || opening_brackets.Length > 1\n        || closing_brackets.Length\
    \ > 1\n        || opening_brackets.Length > 2\n        || closing_brackets.Length\
    \ > 2\n        || opening_brackets.Length < 3\n        || closing_brackets.Length\
    \ < 3\n        || (opening_brackets.Length <> 4 && closing_brackets.Length <>\
    \ 4)\n        || (opening_brackets.Length <> 2 && closing_brackets.Length <> 2)\n\
    \        || (opening_brackets.Length <> 3 && closing_brackets.Length <> 3)\n \
    \       || (opening_brackets.Length <> 4 && closing_brackets.Length <> 2)\n  \
    \      || (opening_brackets.Length <> 2 && closing_brackets.Length <> 4)\n   \
    \     || (opening_brackets.Length <> 3 && closing_brackets.Length <> 4)\n    \
    \    || (opening_brackets.Length <> 4 && closing_brackets.Length <> 3)\n     \
    \   || (opening_brackets.Length <> 2 && closing_brackets.Length <> 3)\n      \
    \  || (opening_brackets.Length <> 3 && closing_brackets.Length <> 4)\n       \
    \ || (opening_brackets.Length <> 4 && closing_brackets.Length <> 4)\n    then\
    \ false\n    else true\nend", "    # Write your solution here\n    return brackets\
    \ contains \"<\"", '    """ Return true if brackets is of the correct form "<<"
    and ">>".', "    # YOUR CODE HERE\n    \n    \n# Do not delete the lines below.\n\
    assert not correct_bracketing(\"<|\")\nassert not correct_bracketing(\"<>\")\n\
    assert not correct_bracketing(\"<>|\")\nassert not correct_bracketing(\"<<<\"\
    )\n</cell>\n<text>\nSo far so good. Now let's see how to handle brackets correctly\
    \ in strings of brackets.", "    brackets = brackets.to_string()\n    for bracket\
    \ in brackets:\n        if bracket.head == bracket.tail:\n            brackets.remove(bracket)\n\
    \            return True\n    return False\nend ", "    brackets = brackets.split(\"\
    <\")\n    brackets = [b[1:] for b in brackets]\n    brackets = Set(brackets)\n\
    \    for b in brackets:\n        if b not in \"(){}<>\":\n            return False\n\
    \    return True\nend", "    bracket_list = brackets\n    for bracket_char in\
    \ bracket_list:\n        if !is_opening(bracket_char):\n            error(\"wrong\
    \ bracket: expected opening character but got \\\"%s\\\"\", bracket_char)\n  \
    \      has_next_char_in_correct_bracket = next_char(bracket_char)\n        if\
    \ not has_next_char_in_correct_bracket:\n            error(\"wrong bracket: expected\
    \ closing character but got \\\"%s\\\"\", bracket_char)\n        if has_next_char_in_correct_bracket:\n\
    \            if next_char(bracket_char) != has_next_char_in_correct_bracket:\n\
    \                error(\"wrong bracket: expected closing character but got \\\"\
    %s\\\", but expected closing character was \\\"%s\\\"\", bracket_char, has_next_char_in_correct_bracket)\n\
    \                \n    true", "    if brackets == \"\" then return true\n    if\
    \ brackets == \"<\" then return false\n    else if brackets == \">\" then return\
    \ true\n    else if brackets == \"<>\" then return false\n    else if brackets\
    \ == \"<>\" then return false\n    else if brackets == \"<>\" then return false\n\
    \    else if brackets == \"<>\" then return false\n    else if brackets == \"\
    <>\" then return false\n    else if brackets == \"<>\" then return false\n   \
    \ else if brackets == \"<>\" then return false\n    else if brackets == \"<>\"\
    \ then return false\n    else if brackets == \"<>\" then return false\n    else\
    \ if brackets == \"<>\" then return false\n    else if brackets == \"<>\" then\
    \ return false\n    else if brackets == \"<>\" then return false\n    else if\
    \ brackets == \"<>\" then return false\n    else if brackets == \"<>\" then return\
    \ false\n    else if brackets == \"<>\" then return false\n    else if brackets\
    \ == \"<>\" then return false\n    else if brackets == \"<>\" then return false\n\
    \    else if brackets == \"<>\" then return false\n    else if brackets == \"\
    <>\" then return false\n    else if brackets == \"<>\" then return false\n   \
    \ else if brackets == \"<>\" then return false\n    else if brackets == \"<>\"\
    \ then return false\n    else if brackets == \"<>\" then return false\n    else\
    \ if brackets == \"<>\" then return false\n    else if brackets == \"<>\" then\
    \ return false\n    else if brackets == \"<>\" then return false\n    else if\
    \ brackets == \"<>\" then return false\n    else if brackets == \"<>\" then return\
    \ false\n    else if brackets == \"<>\" then return false\n    else if brackets\
    \ == \"<>\" then return false\n    else if brackets == \"<>\" then return false\n\
    \    else if brackets == \"<>\" then return false\n    else if brackets == \"\
    <>\" then return false\n    else if brackets == \"<>\" then return false\n   \
    \ else if brackets == \"<>\" then return false\n    else if brackets == \"<>\"\
    \ then return false\n    else if brackets == \"<>\" then return false\n    else\
    \ if brackets == \"<>\" then return false\n    else if brackets == \"<>\" then\
    \ return false\n    else if brackets == \"<>\" then return false\n    else if ",
  "    \"\"\"\n    \n    Arguments\n    ---------\n    brackets is a string of \"\
    <\" and \">\".\n    \n    Returns\n    -------\n    True if every opening bracket\
    \ has a corresponding closing bracket.\n    \"\"\"\n    if brackets == \"\" or\
    \ brackets == \"<>\":\n        return true\n    var opening = brackets[1]\n  \
    \  var closing = brackets[2]\n    for opening in brackets do\n        return !isopeningbracket(opening)\
    \ || !isclosingbracket(closing)\n    return false\nend\n</cell>\n<cell>", "  \
    \  \"\"\"\n    # Write your code here.\n    \"\"\"\n    \n</cell>\n<text>\nExercise\
    \ 1: Write a recursive function which takes a list of numbers and returns True\
    \ if the list has at least one prime element and False if not.", "    loop\n \
    \       opening_bracket = brackets[_index]\n        if opening_bracket == \"<\"\
    \n            return false\n        else if opening_bracket == \">\"\n       \
    \     return true\n        else if opening_bracket == \"(\"\n            _index\
    \ = _index + 1\n        else if opening_bracket == \")\"\n            _index =\
    \ _index - 1\n        else\n            _index = _index + 1\n    end\nend\n</cell>\n\
    <text>\nExercise: Write a function called correct_bracketing_iter that does the\
    \ same thing as correct_bracketing, but with explicit recursion. Make sure you\
    \ have a test case that shows it doesn't work!", "    # Write your answer as a\
    \ function using the String type and a nested loop\n    # Hint: Use \"open_brackets\"\
    \ and \"close_brackets\" to create and fill \n    # open_brackets and close_brackets\
    \ as lists of brackets. \n    # Hint: Use the built-in Python function \"all\"\
    \ with open_brackets and close_brackets\n    return false\nend", "    count =\
    \ 0 \n    for char in brackets\n        if char == \"<\"\n            count +=\
    \ 1\n        else\n            count -= 1\n            \n        if count < 0\n\
    \            return false\n        end\n    end\n    return true\nend\n</cell>\n\
    <text>\nExercise:\nWrite a function that takes a string and returns the string\
    \ with each character replaced with \"X\" if it is an upper case letter, else\
    \ with \"x\".", "    \"\"\"\n    correct_bracketing(s) returns true if brackets\
    \ is a string of \"<\" and \">\".\n    return true if every opening bracket has\
    \ a corresponding closing bracket.", "    brackets = tostring(brackets)\n    brackets\
    \ = string_to_chars(brackets)\n    for (i,c) in enumerate(brackets):\n       \
    \ if c != \">\" and c != \"<\":\n            return false\n    return true\nend\n\
    </cell>\n<text>\nExercise 8", "    \n    open_brackets = brackets.split\n    closed_brackets\
    \ = \"\"\n    \n    for i in open_brackets\n        closed_brackets = closed_brackets\
    \ + \">\" + i\n    \n    for i in closed_brackets\n        open_brackets = open_brackets\
    \ + \"<\" + i", "    \"\"\"\n    check whether the input string has correct brackets.",
  "    if is_correct_bracket(brackets) == true\n        true\n    else\n        false\n\
    \    end\nend\n</code>\n<|/ q dscore=0 tags=string,julia,pattern-matching |>\n\
    <| c |>\n\"*I have a set of brackets brackets such as the following examples*\"\
    \ where do you get these brackets? From a web page? From a file? From some text?\
    \ You didn't explain how you get this data.\n<|/ c |>\n<| c |>\nFrom a web page.\
    \ Basically I want to find every opening bracket and every closing bracket, and\
    \ see if there is an \"<<>>\" in between.\n<|/ c |>\n<| a dscore=1 |>\n<code>",
  "    # we assume that the brackets are well formed\n    # this function returns\
    \ true if brackets is a string of \"<\" and \">\".\n    return brackets.length\
    \ == 2 and brackets.contains(\"<\") and brackets.contains(\">\")", "    bracket_list\
    \ = brackets.split(\"<\")\n    trues = 0\n    falses = 0\n    for bracket in bracket_list\n\
    \        if bracket.startswith \">\"\n            if bracket_list.index(bracket)\
    \ == bracket_list.index(bracket)-1\n                falses += 1\n            else\n\
    \                trues += 1\n        else \n            falses += 1\n    end\n\
    \    return (trues == 0 and falses == 0)\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\n    bracket_string(brackets::String)", "    \"\"\"\n    correct_bracketing(brackets::String)",
  "    pos = 0\n    len = brackets.length\n    while pos <= len\n        if brackets[pos]\
    \ == brackets[pos+1]\n            return false\n        pos = pos + 1\n    return\
    \ true\n</code>\n<|/ a tags=python |>\n<| a tags=python |>\nI find this solution\
    \ very elegant and readable.  \n<code>\ndef isBalanced(string):\n    stack = []\n\
    \    quotes = {'\"'}\n    open_brackets = {'[', '('}\n    open_brackets = {c for\
    \ c in open_brackets if c not in quotes}\n    closed_brackets = {c for c in open_brackets\
    \ if c in quotes}", "  brackets = brackets.replace(\"<<\",\"<\").replace(\">>\"\
    ,\">\")\n  brackets = brackets.replace(\"<\",\"<<\").replace(\">>\",\">>\")\n\
    \  brackets = brackets.replace(\">>\",\">>\").split(\"<\")\n  brackets = map(String,brackets)\n\
    \  for b in brackets\n    if b <> \">\" \n      || brackets.index(b) <> brackets.rindex(b)\n\
    \    then return false\n    else if b == \">\" \n      then brackets.rindex(b)\
    \ \n    else true\n  end\n  return true\nend\n</code>\n<|/ a |>\n<| c |>\nThank\
    \ you very much for this! It works great. I just had to replace some things, but\
    \ I got it working.\n<|/ c |>\n<| c |>\nThe `correct_bracketing` function should\
    \ be modified to correctly handle nested brackets within the brackets string.\
    \ See the updated answer for a possible solution.\n<|/ c |>\n<| a dscore=0 |>\n\
    I used the following, which seems to work.\n<code>", "    brackets = brackets\
    \ |> lowercase\n    brackets |> remove_brackets()\n    brackets |> check_opening_closing_brackets\n\
    end", "    bracket_count::Int64 = 0\n    for bracket in brackets\n        if bracket\
    \ == \"<\"\n            bracket_count = bracket_count + 1\n        else if bracket\
    \ == \">\"\n            bracket_count = bracket_count - 1\n            if bracket_count\
    \ < 0\n                error(\"incorrect bracket placement\")\n            else\n\
    \                bracket_count = 0\n        else if bracket == \"<<\"\n      \
    \      bracket_count = bracket_count + 1\n        else if bracket == \">>\"\n\
    \            bracket_count = bracket_count - 1\n            if bracket_count <\
    \ 0\n                error(\"incorrect bracket placement\")\n            else\n\
    \                bracket_count = 0\n        else\n            error(\"incorrect\
    \ bracket placement\")\n    end\n    return true\nend\n</cell>\n<text>\nWe can\
    \ also check that the string is valid:", "    brackets = brackets[brackets.length\
    \ - 1]\n    for i in 1:length(brackets)\n        if brackets[i] != '<'\n     \
    \       return false\n        end\n    end\n    return true\nend", "    \n   \
    \ # Return true if brackets contains every opening bracket in the \n    # same\
    \ position, and every closing bracket in the same position.\n    brackets.split(\"\
    >\").zip(brackets.split(\"<\")).forall {\n        (a, b) in zip(a, b) in zip(a,\
    \ b) }", "    \"\"\"\n    Determine whether brackets are correctly nested.", " \
    \ \n    bracket_table = Dict([(\"(\",\")\"), (\"[\",\"]\"), (\"<\",\">\")])\n\
    \  \n    openings = brackets.split(\" \") // get all \"(\" \")\" ...\n    closings\
    \ = brackets.split(\" \") // ... and ... \"[  ]\" ...\n  \n    if openings ==\
    \ closings\n      return true\n    else\n      result = (openings.filter(x ->\
    \ bracket_table[x] != closings.last).length == 0)\n      return result\nend\n\
    </cell>\n<code language=julia-0.4>\n\"\"\" check a bracketing string for a \"\
    valid\" opening bracket (one that can be \"paired up\" with \")\" brackets)\n\"\
    \"\"", "    brackets = brackets[2:-2]\n    brackets = brackets[brackets.is_subseq(brackets)]\
    \ \n    brackets = brackets[brackets.is_subseq(brackets)] \n    brackets = brackets[brackets.is_subseq(brackets)]\
    \ \n    brackets = brackets[brackets.is_subseq(brackets)] \n    brackets = brackets[brackets.is_subseq(brackets)]\
    \ \n    brackets = brackets[brackets.is_subseq(brackets)] \n    brackets = brackets[brackets.is_subseq(brackets)]\
    \ \n    brackets = brackets[brackets.is_subseq(brackets)] \n    brackets = brackets[brackets.is_subseq(brackets)]\
    \ \n    brackets = brackets[brackets.is_subseq(brackets)] \n    brackets = brackets[brackets.is_subseq(brackets)]\
    \ \n    brackets = brackets[brackets.is_subseq(brackets)] \n    brackets = brackets[brackets.is_subseq(brackets)]\
    \ \n    brackets = brackets[brackets.is_subseq(brackets)] \n    brackets = brackets[brackets.is_subseq(brackets)]\
    \ \n    brackets = brackets[brackets.is_subseq(brackets)] \n    brackets = brackets[brackets.is_subseq(brackets)]\
    \ \n    brackets = brackets[brackets.is_subseq(brackets)] \n    brackets = brackets[brackets.is_subseq(brackets)]\
    \ \n    brackets = brackets[brackets.is_subseq(brackets)] \n    brackets = brackets[brackets.is_subseq(brackets)]\
    \ \n    brackets = brackets[brackets.is_subseq(brackets)] \n    brackets = brackets[brackets.is_subseq(brackets)]\
    \ \n    brackets = brackets[brackets.is_subseq(brackets)] \n    brackets = brackets[brackets.is_subseq(brackets)]\
    \ \n    brackets = brackets[brackets.is_subseq(brackets)] \n    brackets = brackets[brackets.is_subseq(brackets)]\
    \ \n    brackets = brackets[brackets.is_subseq(brackets)] \n    brackets = brackets[brackets.is_subseq(brackets)]\
    \ \n    brackets = brackets[brackets.is_subseq(brackets)] \n    brackets = brackets[brackets.is_subseq(brackets)]\
    \ \n    brackets = brackets[brackets.is_", "    for i in brackets \n        if\
    \ i not in open_close \n            error(\"Invalid Bracketing: invalid opening\
    \ bracket\")\n        end\n    return true", "    |(brackets == \"<>\") || brackets\
    \ == \"<>\" = true \n    |brackets == \"<\" = !(brackets[1..end-1] ~~ \"<>\")\
    \ \n    |brackets == \"<\" = !(brackets[1..end-1] ~~ \"<\") \n    |brackets ==\
    \ \"<\" = !(brackets[1..end-1] ~~ \">\") \n    |brackets == \"<\" = !(brackets[1..end-1]\
    \ ~~ \">>\") \n    |brackets == \"<\" = !(brackets[1..end-1] ~~ \"<<\") \n   \
    \ |brackets == \"<\" = !(brackets[1..end-1] ~~ \"<=\") \n    |brackets == \"<\"\
    \ = !(brackets[1..end-1] ~~ \"=\") \n    |brackets == \"<\" = !(brackets[1..end-1]\
    \ ~~ \"<<=\") \n    |brackets == \"<\" = !(brackets[1..end-1] ~~ \"<=>\") \n \
    \   |brackets == \"<\" = !(brackets[1..end-1] ~~ \"<=>\") \n    |brackets == \"\
    <\" = !(brackets[1..end-1] ~~ \">=>\") \n    |brackets == \"<\" = !(brackets[1..end-1]\
    \ ~~ \">=>\") \n    |brackets == \"<\" = !(brackets[1..end-1] ~~ \"=>\") \n  \
    \  |brackets == \"<\" = !(brackets[1..end-1] ~~ \"=>=\") \n    |brackets == \"\
    <\" = !(brackets[1..end-1] ~~ \"<<=>\") \n    |brackets == \"<\" = !(brackets[1..end-1]\
    \ ~~ \"<<=>\") \n    |brackets == \"<\" = !(brackets[1..end-1] ~~ \"<=>=\") \n\
    \    |brackets == \"<\" = !(brackets[1..end-1] ~~ \"<=>=\") \n    |brackets ==\
    \ \"<\" = !(brackets[1..end-1] ~~ \">=>=\") \n    |brackets == \"<\" = !(brackets[1..end-1]\
    \ ~~ \">=>=\") \n    |brackets == \"<\" = !(brackets[1..end-1] ~~ \"=>=\") \n\
    \    |brackets == \"<\" = !(brackets[1..end-1] ~~ \"=>=\") \n    |brackets ==\
    \ \"<\" = !(brackets[1..", "    if is_open_paren(brackets)\n        if is_close_paren(brackets)\n\
    \            true\n        else\n            false\n    else\n        false\n\
    end\n</cell>\n<code language=julia-1.6>\n\"\"\"\nGiven a nested list of numbers,\
    \ \nreturn true if there is any bracketing in the nested list \nwhere all opening\
    \ brackets have corresponding closing brackets. \nReturn false otherwise.", " \
    \   \"\"\"\"\"\"\nend\n</cell>\n<text>\nExercise 3: Find a closing bracket in\
    \ the following string.\nHint: This exercise is very similar to the \"Find all\
    \ brackets\" exercise; just replace \"find all brackets\" with \"find one bracket\"\
    .", "    \"\"\"Corrects brackets in `brackets` by adding appropriate \"<\" and\
    \ \">\" \n    brackets. If brackets is empty, then returns true. \"\"\" \n   \
    \ if brackets == \"\" \n        true \n    elseif brackets[0] == \"<\" \n    \
    \    correct_bracketing(brackets[1:]) \n    elseif brackets[0] == \">\" \n   \
    \     correct_bracketing(brackets[1:]) \n    else \n        brackets \n    end\
    \ \nend \n</cell>\n<text>\nExercise\nUsing the function correct_bracketing create\
    \ a function called correct_bracket_nesting that will return true if brackets\
    \ are nested correctly (correct brackets are added where appropriate). Use it\
    \ on the following input:", "    \"\"\"\n    correct_bracketing(brackets::String)",
  "    local open, bracket_count = 0\n    for character in brackets do\n        if\
    \ character == \"<\" then\n            open = open + 1\n        elseif character\
    \ == \">\" then\n            open = open - 1\n        elseif character == \"(\"\
    \ then\n            open = open + 1\n            bracket_count = bracket_count\
    \ + 1\n        elseif character == \")\" then\n            if open == 0 then\n\
    \                return false\n            else\n                open = open -\
    \ 1\n                bracket_count = bracket_count - 1\n            end\n    \
    \    elseif character == \"{\" then\n            if bracket_count == 0 then\n\
    \                return false\n            else\n                return true\n\
    \            end\n        elseif character == \"}\" then\n            if bracket_count\
    \ < 0 then\n                return false\n            else\n                return\
    \ true\n            end\n        else\n            return false\n        end\n\
    \    end\n    return true\nend\n</code>\n<|/ a dscore=2 tags=functional-programming,haskell\
    \ |>\n<| c |>\nI realized after posting that my solution was slightly off because\
    \ of how I interpreted the requirements. I updated my answer based on my interpretation\
    \ of your question. Sorry for the confusion.\n<|/ c |>\n<| a dscore=2 |>\nHere's\
    \ a short recursive solution:\n<code>\ncorrectBrackets :: String -> Bool\ncorrectBrackets\
    \ = foldr (\\_ x -> x /= ')') True . dropWhile (=='(') . dropWhile (==')') . dropWhile\
    \ (=='{') . dropWhile (=='}') . dropWhile (=='['). dropWhile (==']')\n</code>\n\
    It uses foldr :: (a -> b -> a) -> a -> [b] -> a to accumulate (True, x) when x\
    \ is equal to True and False when x is equal to False. The result is then simply\
    \ a logical and operation on the accumulated list of Booleans.\n<code>\n> correctBrackets\
    \ \"[()]\"\nFalse\n> correctBrackets \"[(])\"\nTrue\n> correctBrackets \"[]\"\n\
    False\n> correctBrackets \"([)]\"\nTrue\n> correctBrackets \"{([]}\"\nTrue\n</code>\n\
    <|/ a tags=functional-programming,haskell |>\n<| a dscore=2 tags=functional-programming,haskell\
    \ |>\nA few improvements", "\"\"\"\n    correct_bracketing(brackets::String)::Bool\
    \ \n    \n    Check brackets correctness, returns a bool indicating correctness.\n\
    \    Brackets are \"<\" and \">\".\n\"\"\"\nif brackets[length(brackets) - 1]\
    \ != \"<\"\n    error(\"brackets must be < >\")\nend", "    brackets = brackets.replace(\"\
    <\", \"\")\n    brackets = brackets.replace(\"]\", \"\")\n    brackets = brackets.replace(\"\
    {\", \"\")\n    brackets = brackets.replace(\"}\", \"\")\n    brackets = brackets.replace(\"\
    [\", \"\")\n    brackets = brackets.replace(\"(\", \"\")\n    brackets = brackets.replace(\"\
    '\", \"\")\n    brackets = brackets.replace(\"!\", \"\")\n    brackets = brackets.replace(\"\
    +\", \"\")\n    brackets = brackets.replace(\"$\", \"\")\n    brackets = brackets.replace(\"\
    %\", \"\")\n    brackets = brackets.replace(\"*\", \"\")\n    brackets = brackets.replace(\"\
    -\", \"\")\n    brackets = brackets.replace(\"_\", \"\")\n    brackets = brackets.replace(\"\
    @\", \"\")\n    brackets = brackets.replace(\"?\", \"\")\n    brackets = brackets.replace(\"\
    /\", \"\")\n    brackets = brackets.replace(\"\\\\\", \"\")\n    brackets = brackets.replace(\"\
    (\", \"\")\n    brackets = brackets.replace(\")\", \"\")\n    brackets = brackets.replace(\"\
    :\", \"\")\n    brackets = brackets.replace(\";\", \"\")\n    brackets = brackets.replace(\"\
    '\", \"\")\n    brackets = brackets.replace(\"?\", \"\")\n    brackets = brackets.replace(\"\
    !\", \"\")\n    brackets = brackets.replace(\"#\", \"\")\n    brackets = brackets.replace(\"\
    =\", \"\")\n    brackets = brackets.replace(\",\", \"\")\n    brackets = brackets.replace(\"\
    ;\", \"\")\n    brackets = brackets.replace(\"/\", \"\")\n    brackets = brackets.replace(\"\
    $\", \"\")\n    brackets = brackets.replace(\"%\", \"\")\n    brackets = brackets.replace(\"\
    *\", \"\")\n    brackets = brackets.replace(\"+\", \"\")\n    brackets = brackets.replace(\"\
    )\", \"\")\n    brackets = brackets.replace(\"{\", \"\")\n    brackets = brackets.replace(\"\
    }\", \"\")\n    brackets = brackets.replace(\"[\", \"\")\n    brackets = brackets.replace(\"\
    ]\", \"\")\n    brackets = brackets.replace(\":\", \"\")\n    brackets = brackets.replace(\"\
    ;\", \"\")\n    brackets = brackets.replace(\":\", \"\") \n    brackets = brackets.replace(\"\
    '\", \"\")\n    brackets = brackets.replace(\"?\", \"\")\n    brackets = brackets.replace(\"\
    !\", \"\")\n    brackets = brackets.replace(\"#\", \"\")\n    brackets = brackets.replace(\"\
    =\", \"\")\n    brackets = brackets.replace(\",\", \"\")\n    brackets = brackets.replace(\"\
    ;\", \"\")\n    brackets = brackets.replace(\"/\", \"\")\n    brackets = brackets.replace(\"\
    $\", \"\")\n    brackets = brackets.replace(\"%\", \"\")\n    brackets = brackets.replace(\"\
    *\", \"\")\n    brackets = brackets.replace(\"+\", \"\")\n    brackets = brackets.replace(\"\
    )\", \"\")\n    brackets = brackets.replace(\"{\", \"\")\n    brackets = ", " \
    \   if brackets == \"\" \n        then return true\n    else if brackets == \"\
    <>\"\n        then return false\n    elseif brackets == \"<>\"\n        then return\
    \ false\n    elseif brackets == \"<>\"\n        then return false\n    elseif\
    \ brackets == \"<>\"\n        then return false\n    elseif brackets == \"<>\"\
    \n        then return false\n    elseif brackets == \"<>\"\n        then return\
    \ false\n    elseif brackets == \"<>\"\n        then return false\n    elseif\
    \ brackets == \"<>\"\n        then return false\n    elseif brackets == \"<>\"\
    \n        then return false\n    elseif brackets == \"<>\"\n        then return\
    \ false\n    elseif brackets == \"<>\"\n        then return false\n    elseif\
    \ brackets == \"<>\"\n        then return false\n    elseif brackets == \"<>\"\
    \n        then return false\n    elseif brackets == \"<>\"\n        then return\
    \ false\n    elseif brackets == \"<>\"\n        then return false\n    elseif\
    \ brackets == \"<>\"\n        then return false\n    elseif brackets == \"<>\"\
    \n        then return false\n    elseif brackets == \"<>\"\n        then return\
    \ false\n    elseif brackets == \"<>\"\n        then return false\n    elseif\
    \ brackets == \"<>\"\n        then return false\n    elseif brackets == \"<>\"\
    \n        then return false\n    elseif brackets == \"<>\"\n        then return\
    \ false\n    elseif brackets == \"<>\"\n        then return false\n    elseif\
    \ brackets == \"<>\"\n        then return false\n    elseif brackets == \"<>\"\
    \n        then return false\n    elseif brackets == \"<>\"\n        then return\
    \ false\n    elseif brackets == \"<>\"\n        then return false\n    elseif\
    \ brackets == \"<>\"\n        then return false\n    elseif brackets == \"<>\"\
    \n        then return false\n    elseif brackets == \"<>\"\n        then return\
    \ false\n    elseif brackets == \"<>\"\n        then return false\n    elseif\
    \ brackets == \"<>\"\n        then return false\n    elseif brackets == \"<>\"\
    \n        then return false\n    elseif brackets == \"<>\"\n        then return\
    \ false\n    elseif brackets == \"<>\"\n        then return false\n    elseif\
    \ brackets == \"<>\"\n        then return false\n    elseif brackets == \"<>\"\
    \n        then return false\n    elseif brackets == \"<>\"\n        then return\
    \ false\n    elseif brackets == \"<>\"", "    brackets_set = Set(brackets)\n \
    \   open_brackets = Set(\"<\")\n    close_brackets = Set(\">\")\n    function\
    \ correct_bracketing(s::String)::Bool \n        for opening_bracket in open_brackets\
    \ \n            if opening_bracket in s \n                and not opening_bracket\
    \ in brackets_set\n                then return false\n        for closing_bracket\
    \ in close_brackets\n            if closing_bracket in s\n                and\
    \ not closing_bracket in brackets_set\n                then return false\n   \
    \     for opening_bracket in open_brackets\n            if closing_bracket in\
    \ s\n                and not opening_bracket in brackets_set\n               \
    \ then return false\n        for closing_bracket in close_brackets\n         \
    \   if opening_bracket in s\n                and not closing_bracket in brackets_set\n\
    \                then return false\n        return true\n    end\nend\n</cell>\n\
    <code language=julia-0.6>", "    if brackets.size < 2 then return false \n   \
    \ for bracket in brackets \n        bracket_char = bracket[1]\n        if bracket_char\
    \ == \"<\" then return false \n        next \n        for _ in brackets \n   \
    \         if _ != \"<\" and _ != \">\" then return false \n            next \n\
    \    return true \nend\n</cell>\n<text>\nExercise 3", "    \n\"\"\"\n    Takes\
    \ a sequence of brackets.\n    \n    >>> correct_bracketing(brackets(\"<>\"))\n\
    \    false\n    >>> correct_bracketing(brackets(\"<>\"), brackets(\"<\"))\n  \
    \  false\n    >>> correct_bracketing(brackets(\"<>\"), brackets(\"<\"), brackets(\"\
    <<\"))\n    false\n    >>> correct_bracketing(brackets(\"<>\"), brackets(\"<\"\
    ), brackets(\"<<\"), brackets(\"<\"))\n    false\n    >>> correct_bracketing(brackets(\"\
    <>\"), brackets(\"<\"), brackets(\"<<\"), brackets(\"<\"), brackets(\"<\"))\n\
    \    false\n    >>> correct_bracketing(brackets(\"<\"))\n    true\n    >>> correct_bracketing(brackets(\"\
    <\"), brackets(\"<>\"))\n    true\n    >>> correct_bracketing(brackets(\"<\"),\
    \ brackets(\"<\"), brackets(\"<<\"))\n    true\n    >>> correct_bracketing(brackets(\"\
    <\"), brackets(\"<\"), brackets(\"<<\"), brackets(\"<\"), brackets(\"<\"))\n \
    \   true\n    >>> correct_bracketing(brackets(\"<\"), brackets(\"<\"), brackets(\"\
    <<\"), brackets(\"<\"), brackets(\"<\"), brackets(\"<\"))\n    true\n    >>> correct_bracketing(brackets(\"\
    <<\"))\n    true\n    >>> correct_bracketing(brackets(\"<<\"), brackets(\"<>\"\
    ))\n    true\n    >>> correct_bracketing(brackets(\"<<\"), brackets(\"<\"), brackets(\"\
    <<\"))\n    true\n    >>> correct_bracketing(brackets(\"<<\"), brackets(\"<\"\
    ), brackets(\"<<\"), brackets(\"<\"), brackets(\"<\"))\n    true\n    >>> correct_bracketing(brackets(\"\
    <<\"), brackets(\"<\"), brackets(\"<<\"), brackets(\"<\"), brackets(\"<\"), brackets(\"\
    <\"))\n    true\n    >>> correct_bracketing(brackets(\"<<\"), brackets(\"<<\"\
    ), brackets(\"<<\"), brackets(\"<<\"), brackets(\"<<\"), brackets(\"<<\"), brackets(\"\
    <<\"))\n    true\n    >>> correct_bracketing(brackets(\"<<\"), brackets(\"<<\"\
    ), brackets(\"<<\"), brackets(\"<<\"), brackets(\"<<\"), b", "    \n    let char_count\
    \ = length(text)\n    \n    for i in 0 .. char_count - 1, \n        j := i + 1,\
    \ \n        while j <= char_count && char(text[i]) == char(text[j]), \n      \
    \      j += 1\n        do \n            if char(text[i]) == brackets[j], \n  \
    \              result := true, \n                break\n            elseif j ==\
    \ char_count, \n                result := false\n            elseif char(text[j])\
    \ == brackets[i], \n                result := false\n        end\n    done\n \
    \   return result\n\"\"\"", "  \n  let open :: Set String = Set.fromList([c |\
    \ c <- brackets |> List.filter (not <| c <> \"(\" || (c <> \")\") ) |> List.filter\
    \ (not <| c <> \"[\" || (c <> \"]\") ) |> List.filter (not <| c <> \"{\" || (c\
    \ <> \"}\") ) |> List.map (fun (c::Char) -> (if c <> \"(\" then \"(\" else if\
    \ c <> \")\" then \")\" else if c <> \"[\" then \"[\" else if c <> \"]\" then\
    \ \"]\" else if c <> \"{\" then \"{\" else if c <> \"}\" then \"}\") else c) ])\n\
    \  \n  let close :: Set String = Set.fromList([c | c <- brackets |> List.filter\
    \ (not <| c <> \"(\" || (c <> \")\") ) |> List.filter (not <| c <> \"[\" || (c\
    \ <> \"]\") ) |> List.filter (not <| c <> \"{\" || (c <> \"}\") ) |> List.map\
    \ (fun (c::Char) -> (if c <> \"(\" then \"(\" else if c <> \")\" then \")\" else\
    \ if c <> \"[\" then \"[\" else if c <> \"]\" then \"]\" else if c <> \"{\" then\
    \ \"{\" else if c <> \"}\" then \"}\") else c) ])\n  \n  let open_brackets ::\
    \ Set String = open\n  let close_brackets :: Set String = close\n  let open ::\
    \ Set String = open & close\n  \n  let open_brackets_not_closed :: Set String\
    \ = open_brackets |> Set.filter (not <| open_brackets)\n  let close_brackets_not_open\
    \ :: Set String = close_brackets |> Set.filter (not <| close_brackets)\n  \n \
    \ let open_brackets_not_open_or_closed :: Set String = open_brackets_not_closed\
    \ |> Set.filter (not <| close_brackets_not_open)\n  let close_brackets_not_open_or_open\
    \ :: Set String = close_brackets_not_open |> Set.filter (not <| open_brackets_not_closed)\n\
    \  \n  let open_brackets_not_open_or_closed_or_non_brackets :: Set ", "    if\
    \ brackets == \"\" then return true \n    else if brackets.find(\"<\") <> -1 then\
    \ return false \n    else if brackets.find(\">\") <> -1 then return false \n \
    \   else if brackets.find(\"<<\") <> -1 or brackets.find(\">>\") <> -1 then return\
    \ false \n    else if brackets.find(\"<<<\") <> -1 then return false\n    else\
    \ if brackets.find(\">>\") <> -1 then return false \n    else if brackets.find(\"\
    <<<\") <> -1 then return false\n    else if brackets.find(\">>>>>\") <> -1 then\
    \ return false \n    else if brackets.find(\"<<<<\") <> -1 then return false \n\
    \    else if brackets.find(\"<<<\") <> -1 then return false\n    else return true\n\
    end\n</cell>\n<text>\nTest Your Solution", "    \"\"\"\n    Returns True if brackets\
    \ is a string of \"<\" and \">\". \n    return true if every opening bracket has\
    \ a corresponding closing bracket.", "    \"\"\"Correctly bracketing brackets\
    \ in a string if they are properly balanced.\n    Brackets are open/closed pairs\
    \ (\"<\" and \">\") which can be nested, and we require\n    a correct pairing\
    \ of open/close brackets to ensure proper nesting.", "\"\"\"\n    brackets is\
    \ a string of \"<\" and \">\".\n    return true if every opening bracket has a\
    \ corresponding closing bracket.", "    \n    \"\"\"\n    Checks to see if the\
    \ brackets string is valid.\n    \n    >>> correct_bracketing(\"<\")\n    false\n\
    \    >>> correct_bracketing(\"<>\")\n    true\n    >>> correct_bracketing(\"<<><>>\"\
    )\n    true\n    >>> correct_bracketing(\"><<>\")\n    false\n    \"\"\"\n   \
    \ if brackets == \"\"\n        return true\n    \n    stack = Stack()\n    for\
    \ char in brackets\n        if char == \"<\"\n            stack.push(char)\n \
    \       elseif char == \"<\"\n            if stack.size > 0\n                stack.pop()\n\
    \        elseif char == \">\"\n            if stack.size > 0\n               \
    \ stack.peek()\n                stack.pop()\n        else\n            return\
    \ false\n    \n    return stack.size == 0", "    bracket_dict = Dict(zip(\"()\"\
    , \">><\")) \n    bracket_open = brackets |> String.split\n    bracket_close =\
    \ bracket_open |> List.filter(flip(elems_in(\">><\")))\n    all_brackets_closed\
    \ = false \n    all_brackets_opened = true\n    for open_char in bracket_open\n\
    \        for close_char in bracket_close\n            if open_char == close_char\n\
    \                all_brackets_closed = false\n                all_brackets_opened\
    \ = false\n                break\n            all_brackets_closed = false\n  \
    \          all_brackets_opened = false \n    return all_brackets_closed == all_brackets_opened\n\
    end\n</code>\n<|/ a |>\n<| a |>\nIf you have a string like \"<<><><>\", you can\
    \ get the number of occurences of \"<<\" with\n<code>\nlength( split(string, \"\
    <<\") )\n</code>\nwhich will give you the number of occurences found at \"<<\"\
    .  But how do you do that for all occurences of \"<<<\"?  What if the string is\
    \ \"<<<><><<<><><<>\", or even \"<<<><><<<><>><<><<><<><<>><<>\"?\nWell, it's\
    \ easy enough to count the number of occurrences of \"<\" by counting the number\
    \ of \"<<\":\n<code>\nlength( split(string, \"<<\") )\n</code>\nBut what if the\
    \ string has \"<<<><><<<><><<><<><<><<>><<>\"?  That is, you want the number of\
    \ \"<<<\" in the string?  That is easy:\n<code>\nlength( split(string, \"<<<\"\
    ) )\n</code>\nbut what if you want the number of \"<<>\" in the string?  That\
    \ isn't too hard:\n<code>\nlength( split(string, \"<<<\") ) + length( split(string,\
    \ \"<<>\") )\n</code>\nBut what if you want the number of \"<<\" AND \"<<<\" in\
    \ the string?  That's even easier:\n<code>\nlength( split(string, \"<<\") ) +\
    \ length( split(string, \"<<<\") )\n</code>\nAnd now, how do we combine this with\
    \ our previous count of \"<<\" occurrences to get the number of \"<<<\" occurrences?\
    \  It turns out that we can combine them using the built-in function +:\n<code>\n\
    length( split(string, \"<<\") ) + length( split(string, \"<<<\") )\n</code>\n\
    <|/ a tags=string,julia dscore=1 |>\n", "    \"\"\"\n    # brackets is a string\
    \ of \"<\" and \">\".\n    return true if every opening bracket has a corresponding\
    \ closing bracket.", "    \"\"\"\n    correct_bracketing returns the boolean value\
    \ true if the brackets are correct \n    according to the problem description.",
  "    \n    # write your code here\n    \n    \nend # function correct_bracketing(brackets::String)",
  "    if is_empty(brackets)\n        return true\n    if brackets == \"<\"\n    \
    \    return false\n    if brackets == \">\"\n        return false\n    if brackets\
    \ == \"<>\"\n        return true\n    return false", "    brackets == \"<\" ||\
    \ brackets == \"<<\" || brackets == \"<>>\" || brackets == \"<->\" || brackets\
    \ == \"<:>\" || brackets == \"<::>\" || brackets == \"<<<\"\nend\n</cell>\n<code\
    \ language=julia-1.6>\n#export", "    return brackets in {\">\", \">>\"} \n</code>\n\
    The function returns true if the brackets are correctly matched, and false otherwise.\n\
    To test the function, you can use the following code:\n<code>\nprintln(correct_bracketing(\"\
    <\"))\nprintln(correct_bracketing(\"<>\"))\nprintln(correct_bracketing(\"<<><>>\"\
    ))\nprintln(correct_bracketing(\"><<>\"))\n</code>\n<|/ a tags=kotlin,recursion\
    \ |>\n<| c |>\nThank you so much, that worked perfectly. I am still relatively\
    \ new to coding and trying to get better at it, so the help is immensely appreciated.\
    \ Cheers, and thanks again!\n<|/ c |>\n<| c |>\nGreat. Thank you for the feedback.\
    \ It would be great if you could accept the answer by clicking on the check mark\
    \ next to it.\n<|/ c |>\n<| c |>\nSure, I just had a quick question for you, if\
    \ you don't mind. What does the \"::Bool\" mean in this context? I looked online\
    \ and I couldn't find anything on it.\n<|/ c |>\n<| c |>\nIt\u2019s short for\
    \ \u201CBoolean type\u201D. The ::Bool means it expects a Boolean type. More info\
    \ can be found [here](https://kotlinlang.org/docs/reference/basic-types.html#type-parameters).\n\
    <|/ c |>\n<| c |>\nThanks! I'm sure it will come in handy at some point :)\n<|/\
    \ c |>\n<| a dscore=2 |>\nIn order to solve this problem you need to use a stack\
    \ (a data structure for storing information and storing/retrieving information\
    \ based on \"stacking\" the information on it).\nA stack holds information by\
    \ \"un-stacking\" it from the last stored information. This is done when the \"\
    un-stacking\" operation is popped from the stack. An example of a stack is shown\
    \ in the image below.", "    local result = true\n    for char in brackets:\n\
    \        if not(char == \"<\" or char == \"<=\" or char == \">\" or char == \"\
    >=\"):\n            result = false\n    return result\nend", "    brackets = brackets[2:end]\n\
    \    for i in brackets\n        match brackets[i..i+1]\n            case \"<\"\
    \n                return false\n            case \"<:\"\n                return\
    \ false\n            case \">\"\n                return true\n            case\
    \ \">:\"\n                return true\n            case \"<>\"\n             \
    \   return false\n            end\n        end\n    end\nend\n</cell>\n<text>\n\
    Exercise 14. Write a function is_opening_and_closing_pair(a::String) which returns\
    \ True if a is of the form \"<open>\" or \"</open>\" or \"<closed>\" or \"</closed>\"\
    . Your function should not care about the contents of the tags and should ignore\
    \ whitespace and comments.", "\"\"\"\ncorrect_bracketing(string::String)::Bool\n\
    \"\"\"\n    if brackets == \"\" then return false end\n    brackets = brackets[2:end]\n\
    \    brackets = replace(\" \", \"\", brackets)\n    for i in brackets\n      \
    \  if i == '<' then return false\n        if i == \">\" then return true\n   \
    \ end\n    return true\nend", "    bracket_opens = brackets.count(\"<\") + brackets.count(\"\
    >\")\n    bracket_closes = brackets.count(\"<\") - brackets.count(\">\")\n   \
    \ \n    return bracket_opens == bracket_closes \nend\n</cell>\n<text>\nExercise\
    \ 2: Using a for loop, write a for loop that outputs every possible permutation\
    \ of [1,2,3,4]\nFor example, the output could be:", "    brackets = brackets.split(\"\
    <>\")\n    for b in brackets\n        if b != \">\" && b != \"<\"\n          \
    \  return false\n    return true\n</code>\n<|/ a |>\n<| c |>\nYou don't need the\
    \ `if` statement in `correct_bracketing`, just `return false if ...`\n<|/ c |>\n\
    <| c |>\nThat works, thanks. I had to add a `::Bool` after the closing parenthesis\
    \ for my `correct_bracketing` to work.\n<|/ c |>\n<| a tags=ocaml,functional-programming\
    \ |>\n<code>\nlet rec is_bracketing_correct (str: string) = False\n  | is_bracketing_correct\
    \ (str: string) =\n    let open str in let close str in (close <> open) =\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThanks for the suggestion, but this returns `Error:\
    \ Syntax error; found \"<\" when expecting \"in\".`\n<|/ c |>\n<| c |>\nTry it\
    \ now. I didn't test it for correctness, but it compiles and executes correctly\
    \ in OCaml 4.02.\n<|/ c |>\n<| c |>\nSadly, this doesn't work either, same syntax\
    \ error. :(\n<|/ c |>\n<| a tags=ocaml,functional-programming |>\nOne way is to\
    \ convert your string to a list of characters. Then you can check if the first\
    \ character is a left bracket, followed by a left bracket and another left bracket.\n\
    <code>\nlet rec is_bracketing_correct (str: string): bool = \n  match str with\n\
    \  | '[' :: str -> is_bracketing_correct str\n  | ' ' :: str -> false\n  | '['\
    \ :: str -> true\n  | _ -> false", "    \"\"\"\n    correct_bracketing(brackets::String)::Bool\n\
    \    \n    Checks the bracketing of a string of brackets.\n    \"\"\"\n    if\
    \ brackets == \"\" || brackets == \">>\" || brackets == \">><<>\" || brackets\
    \ == \"<<><>\" \n       || brackets == \">>><\"\n       || brackets == \"<<><\"\
    \n       || brackets == \"<><>\") {\n        return true\n    } else {\n     \
    \   return false\n    }\nend\n</cell>\n<text>\nTask 2: Write a function that checks\
    \ if a number is a positive integer.", "    if brackets == \"\"\n        return\
    \ false\n    if brackets[1] == \"<\" == brackets[2] == \">\"\n        return true\n\
    \    return false\n\"\"\"\n    \"\"\"\n    # 4. The \"<<\" character is paired\
    \ with either \"<\" or \"<<\" but never with \">>\"\n    #    \"<<\" pairs with\
    \ \"<\" and \">\" never with \">>\".\n    # 5. The \">>\" character is paired\
    \ with either \">>\" or \"<\" but never with \"<\"\n    #    \"<<\" pairs with\
    \ \"<\" and \">\" never with \">>\".", "    # your code here\n    pass\n</cell>\n\
    <text>\nPart 4: Matching brackets against a string\nNow implement the match_brackets\
    \ function, which (given a string and a stack of opening and closing brackets)\
    \ will return the string with brackets added to the open brackets if the stack\
    \ is empty.", "    \"\"\" returns true if the brackets in brackets correspond\
    \ to \n        correct opening or closing brackets\n        \n    >>> correct_bracketing(\"\
    <\")\n    false\n    >>> correct_bracketing(\"<>\")\n    true\n    >>> correct_bracketing(\"\
    <<><>>\")\n    true\n    >>> correct_bracketing(\"><<>\")\n    false\n    \"\"\
    \"", "    \"\"\"\n    \n    INPUT brackets is a string of \"<\" and \">\".\n \
    \   return true if every opening bracket has a corresponding closing bracket.",
  "    if brackets == \"\"\n        return true\n    open <- brackets = \"<\"\n  \
    \  close <- brackets = \">\"\n    if open == \"\"\n        return false\n    if\
    \ close == \"\"\n        return true\n    return true\n</code>\nIn Scala:\n<code>\n\
    def correctBracketing(brackets: String): Boolean = {\n  if (brackets == \"\")\n\
    \    return true\n  open <- brackets = \"<\"\n  close <- brackets = \">\"\n  if\
    \ (open == \"\")\n    return false\n  if (close == \"\")\n    return true\n  true\n\
    }\n</code>\n<|/ a dscore=5 |>\n<| a dscore=3 |>\n<code>\ndef balancedBrackets(s:\
    \ String): Boolean = \n  s.replaceAll(\"\"\"[(]\"\"\", \"\")\n    .replaceAll(\"\
    \"\"[]]\"\"\", \"\")\n    .replaceAll(\"\"\"[^]]\"\"\", \"\").length == 0\n</code>\n\
    <|/ a tags=scala,regex |>\n<| c |>\nNot sure why this is getting voted down. I\
    \ think it is correct, short and straightforward. Especially with the use of `replaceAll`\
    \ which takes a regex and replaces it with a string.\n<|/ c |>\n<| c |>\nIt seems\
    \ the question is how to replace brackets, not how to check if a string is balanced.\n\
    <|/ c |>\n<| a |>\nThe following method will work with both single and double\
    \ brackets:\n<code>\ndef isBalanced(s: String): Boolean = s.replaceAll(\"[]\"\
    , \"\").size == s.length\n</code>\n<|/ a dscore=3 tags=scala,regex |>\n<| c |>\n\
    This doesn't work for strings like \"[][][][][][][]\" which is an example of the\
    \ input for the OP.\n<|/ c |>\n<| a dscore=3 |>\n<code>\nscala> \"()[]\".r.findAllIn(\"\
    []\").length\nres8: Int = 2\n</code>\n<|/ a tags=scala,regex |>\n<| a dscore=3\
    \ |>\n<code>\ndef isBalanced(s: String): Boolean = s.replaceAll(\"[\\\\(\\\\)]\"\
    , \"\")\n    .split(\"\\\\(\")\n    .map(_.length)\n    .sum == s.length\n</code>\n\
    <|/ a tags=scala,regex |>\n<| c |>\nPlease add some explanations to your answer\n\
    <|/ c |>\n<| a dscore=3 |>\nThis is an alternative solution which works with strings\
    \ of any length.\n<code>\ndef isBalanced(s: String): Boolean = {\n  val sBracket\
    \ = s.replaceAll(\"[\\\\(\\\\)]\", \"\")\n  val brackets = s", "\"\"\"\n    Defining\
    \ this function is optional, but recommended. It tests whether a\n    string contains\
    \ any valid opening/closing brackets, and is faster than the\n    equivalent regexp\
    \ based solution. Note that this function returns true if\n    the string is entirely\
    \ contained within valid brackets.\n    \n    brackets is a string of \"<\" and\
    \ \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.", "    brackets.split(\"\").filter(elem -> elem == '<').length == brackets.split(\"\
    \").filter(elem -> elem == '>').length\nend", "    \"\"\"\n    Determine if brackets\
    \ has all the correct opening brackets.\n    \"\"\"", "    bracket_count::Int\
    \ = 0\n    for i in brackets\n        if i == \"<\"\n            bracket_count\
    \ += 1 \n        elif i == \">\"\n            bracket_count -= 1 \n          \
    \  if bracket_count < 0\n                return false\n    return bracket_count\
    \ == 0", "    \"\"\"\n    brackets is a string of \"<\" and \">\".\n    return\
    \ true if every opening bracket has a corresponding closing bracket.\n    \"\"\
    \"\n    brackets = brackets[2:]\n    open_positions = [i for i,c in enumerate(brackets)\
    \ if c == \"<\"]\n    close_positions = [i for i,c in enumerate(brackets) if c\
    \ == \"<\"]\n    if open_positions == close_positions:\n        open_positions.remove(open_positions[0])\n\
    \        return open_positions[-1] < close_positions[0]\n    else:\n        return\
    \ False\n</code>\n<|/ a |>\n<| c |>\nThis is so cool!  I was able to take this\
    \ and modify it for my needs.  Thank you!\n<|/ c |>\n<| a dscore=1 |>\nIf you\
    \ were to keep track of how many open and closed brackets you had seen so far,\
    \ you could compare that to the length of the brackets string.  If you see a closing\
    \ bracket when the count is still greater than zero, you know that you have an\
    \ open bracket that isn't closed:\n<code>\ndef check_brackets(brackets):\n   \
    \ open_brackets = 0\n    close_brackets = 0", "    if brackets == \"\" then return\
    \ true else return false end\n    let opening_brackets = brackets[1:length(open_brackets)]\n\
    \    for opening_bracket in opening_brackets do \n        match = search( open_bracket,\
    \ brackets, 1)\n        if match == nothing then return false end\n        for\
    \ i = match.start to match.end do \n            if brackets[i] != opening_bracket\
    \ then return false end\n        end\n    end\n    return true\nend", "    \"\"\
    \"\n    >>> correct_bracketing(\"</\")\n    false\n    >>> correct_bracketing(\"\
    <<><>\")\n    true\n    >>> correct_bracketing(\"<<><<>\")\n    false\n    \"\"\
    \"\n    return brackets.reversed.foldl(=)(false)", "{\n    return brackets ==\
    \ \"<>\"\n}\n</cell>\n<text>\nTests", "    \"\"\"\n    correct_bracketing is an\
    \ implementation of correct_bracketing\n    that returns true if every opening\
    \ bracket has a corresponding closing\n    bracket.", "    brackets = strip(brackets)\n\
    \    brackets = brackets.replace(\" \", \"\")\n    brackets = brackets.replace(\"\
    <\", \"\")\n    brackets = brackets.replace(\">\", \"\")\n    brackets = brackets.replace(\"\
    <<\", \"\")\n    brackets = brackets.replace(\">>\", \"\")\n    brackets = brackets.replace(\"\
    >>\", \"\")\n    brackets = brackets.replace(\"<<\", \"\")\n    brackets = brackets.replace(\"\
    <<\", \"\")\n    brackets = brackets.replace(\"<\", \"\")\n    brackets = brackets.replace(\"\
    <\", \"\")\n    return brackets == \"<>\"\nend", "    \"\"\"\n    correct_bracketing\
    \ is an implementation of the code challenge for \n    Project Euler's Problem\
    \ #2.\n    \n    brackets is a string of \"<\" and \">\".\n    return true if\
    \ every opening bracket has a corresponding closing bracket.\n    \n    >>> correct_bracketing(\"\
    <\")\n    false\n    >>> correct_bracketing(\"<>\")\n    true\n    >>> correct_bracketing(\"\
    <<><>>\")\n    true\n    >>> correct_bracketing(\"><<>\")\n    false\n    \"\"\
    \"\n    \n    brackets_count = brackets.count(\"</\")\n    \n    if brackets_count\
    \ % 2 == 0: \n        return true\n    else: \n        return false\n    \n#testing\n\
    </cell>\n<cell>\n#export\ndef test_correct_bracketing():\n    assert correct_bracketing(\"\
    \") == true\n    assert correct_bracketing(\"<<><>>\") == true\n    assert correct_bracketing(\"\
    <\") == false\n    assert correct_bracketing(\"<>\") == false\n    assert correct_bracketing(\"\
    <<><\") == \"<<><>>\"\n    assert correct_bracketing(\"<<><<>\") == \"<<><>>\"\
    \n    assert correct_bracketing(\"<<><>><<><><\") == \"<<><>><<><><\"\n    assert\
    \ correct_bracketing(\"<><><<>\") == \"<<><>>\"\n    assert correct_bracketing(\"\
    <><><<>>\") == \"<<><>>\"\n    assert correct_bracketing(\"<><><>>\") == \"<<><>>\"\
    \n    assert correct_bracketing(\"<><><><><><\") == \"<<><>>\"\n    assert correct_bracketing(\"\
    <><<><<>\") == false\n    assert correct_bracketing(\"<<><>><<><><><>\") == false\n\
    \    assert correct_bracketing(\"<>\") == false\n    assert correct_bracketing(\"\
    <<><>><<><><><>\") == false\n    assert correct_bracketing(\"<><><><><>\") ==\
    \ false\n    assert correct_bracketing(\"<><><><><><><><><><><><><><><><><><><><><><><><><><>\"\
    ) == false\n    assert correct_bracketing(\"<<><>><<><><><><><><>\") == false\n\
    \    assert correct_bracketing(\"<>\") == false\n    assert correct_bracketing(\"\
    <<><>><<><><><><><><>\") == false\n    assert correct_bracketing(\"<>\") == false\n\
    \    assert correct_bracketing(\"<<><>><<><><><><><>\") == false\n    assert correct_bracketing(\"\
    <>\") == false\n    assert correct_bracketing(\"<<><>><<><><><><><>\") == false\n\
    \    assert correct_bracketing(\"<<><>><<><><><", "    ok = true\n    for bracket\
    \ in brackets\n        if bracket !~ r\"<[^<>]+>\" \n            error(\"Brackets\
    \ must be surrounded by angle brackets\")\n            ok = false\n    return\
    \ ok\n</code>\n<|/ a dscore=3 |>\n<| a tags=ocaml,pattern-matching,conditional-statements,matching,recursion\
    \ |>\nI believe that it is possible to solve this problem with recursion. I don't\
    \ see a direct way to solve your problem using recursion; however, it's possible\
    \ with a bottom-up approach. The basic idea is to recursively build the expression\
    \ until you have no valid expressions. Each step takes two inputs: the current\
    \ expression (a list) and the next character to be matched against (a string).\n\
    To solve the problem, the base case would be when the next character doesn't match\
    \ anything. When this happens, you can return the empty list. If you come to a\
    \ valid character that matches, then you can return that list followed by the\
    \ next character that matches.\nIn the recursion, you will need to handle two\
    \ cases:", "    if brackets == \"\" then return true\n    let brackets = brackets[2:]\n\
    \    let open_brackets = [\">\", \"<\"]\n    let closed_brackets = [\">>\", \"\
    <<\"]\n    for open_bracket in open_brackets do\n        for closed_bracket in\
    \ closed_brackets do\n            if open_bracket == closed_bracket && brackets.starts_with(open_bracket)\
    \ then\n                return false\n        end\n    end\n    return true\n\
    end", "    if brackets == '<>':\n        return true\n    \n    if brackets ==\
    \ '<':\n        return false\n    \n    if brackets == '<>':\n        return false\n\
    \    \n    if brackets == '<->':\n        return false\n    \n    if brackets\
    \ == '<-<-':\n        return false\n    \n    if brackets == '-><-':\n       \
    \ return false\n    \n    if brackets == '-<-<':\n        return false\n    \n\
    \    if brackets == '--<':\n        return false\n    \n    if brackets == '->--':\n\
    \        return false\n    \n    if brackets == '-->':\n        return false\n\
    \    \n    if brackets == '<-':\n        return false\n    \n    if brackets ==\
    \ '<->-':\n        return false\n    \n    if brackets == '<->->':\n        return\
    \ false\n    \n    if brackets == '-><->':\n        return false\n    \n    if\
    \ brackets == '-<-':\n        return false\n    \n    if brackets == '--':\n \
    \       return false\n    \n    if brackets == '->--':\n        return false\n\
    \    \n    if brackets == '-':\n        return false\n    \n    if brackets ==\
    \ '->':\n        return false\n    \n    if brackets == '->->':\n        return\
    \ false\n    \n    if brackets == '<-->':\n        return false\n    \n    if\
    \ brackets == '<->-':\n        return false\n    \n    if brackets == '<->->-':\n\
    \        return false\n    \n    if brackets == '<->->->':\n        return false\n\
    \    \n    if brackets == '-><-':\n        return false\n    \n    if brackets\
    \ == '->--<':\n        return false\n    \n    if brackets == '->->-':\n     \
    \   return false\n    \n    if brackets == '->->->':\n        return false\n \
    \   \n    if brackets == '<->--':\n        return false\n    \n    if brackets\
    \ == '<->->-':\n        return false\n    \n    if brackets == '<->->->':\n  \
    \      return false\n    \n    if brackets == '<->--<':\n        return false\n\
    \    \n    if brackets == '<->-<':\n        return false\n    \n    if brackets\
    \ == '<->-><':\n        return false\n    \n    if brackets == '->-<-':\n    \
    \    return false\n    \n    if brackets == '--<->':\n        return false\n \
    \   \n    if brackets == '->--<':\n        return false\n    \n    if brackets\
    \ == '--->':\n        return false\n    \n    if brackets == '<-<-':\n       \
    \ return false\n    \n    if brackets == '<->-<':\n        return false\n    \n\
    \    if ", "  -- this algorithm is from https://stackoverflow.com/a/258816\n \
    \ if brackets == \"\" then return false else return \n    correct_bracketing(brackets[1:end-1])\
    \ && correct_bracketing(brackets[2:end])\nend", "    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n", "  \
    \  if brackets == \"\"\n        return True\n    return brackets == \"<\" && brackets[1..-1]\
    \ == \">\"\nend\n</code>\n<|/ a tags=syntax-error,julia,syntax |>\n<| c |>\nYour\
    \ code would allow `\"<>\"` as a valid bracket. I'm not sure that it is what the\
    \ OP wants.\n<|/ c |>\n<| c |>\nAgreed. I think that should be fixed now.\n<|/\
    \ c |>\n<| c |>\nThis code does not work if `brackets[1..-1] == \"<\"`, for example\
    \ `\"<>\"` gives `true`\n<|/ c |>\n<| a tags=syntax-error,julia,syntax |>\nThe\
    \ current answers so far are great, but don't work in all cases.\nConsider the\
    \ following string:\n<code>\n>>> s = \"<<><>>\"\n</code>\nIf s is written with\
    \ correct syntax but still throws an error, try:\n<code>\n>>> parse(Int, s)\n\
    ERROR: syntax: invalid token: >>\n</code>\nThe solution above will throw an error.\
    \ However, the following will not:\n<code>\n>>> parse(Int, s[1:2:end])\n15\n</code>\n\
    This solution is based on Julia's documentation on parsing, which in turn was\
    \ based on a StackOverflow answer. Having read it, I believe it does work in the\
    \ following cases:", "    brackets = brackets |> String.toLower\n    for c in\
    \ brackets\n        if not c.isAlpha\n            return false\n    return true",
  "    local brackets = brackets\n    return brackets ~= \"\" &&\n        brackets[1]\
    \ == \"<\" &&\n        brackets[length(brackets) - 2] == \">\" &&\n        brackets[length(brackets)\
    \ - 1] == \">\"\n    end\n</code>\n<|/ a tags=string,lua |>\n<| a tags=string,lua\
    \ dscore=1 |>\nIn case you are interested in, here is a recursive solution that\
    \ works with any string and can work with nested brackets.\n<code>\nlocal function\
    \ brackets(str, i)\n  if(i == nil or (i == 1 and str[1] == '<')) then\n    return\
    \ true\n  else\n    return brackets(str, i+1) or (str[i] == '<' and brackets(str,\
    \ i+2))\n  end\nend", "    # Remove any whitespace at the start and end of the\
    \ string\n    brackets = brackets.trim()\n    if len(brackets) <= 1 \n       \
    \ return false \n    \n    # Keep track of how many brackets were encountered\n\
    \    brackets_encountered = 0\n    \n    brackets_encountered += brackets.count(\"\
    <\")\n    brackets_encountered += brackets.count(\">\")\n    \n    result := (brackets_encountered\
    \ <= 1)\n    return result\nend\n</cell>\n<text>\nExercise: Write a function that\
    \ counts the number of times that a sub-string appears in a string. Return 0 for\
    \ substrings that are not in the string.", "    # BEGIN PROBLEM 1\n    \n    #\
    \ END PROBLEM 1\n    # BEGIN PROBLEM 2\n    \n    # END PROBLEM 2\n    return\
    \ true\nend\n</cell>\n<text>\nRun the cell below to test your functions:", " \
    \   open <- find first open bracket in brackets\n    close <- find first close\
    \ bracket in brackets\n    if open < close\n        then return true\n       \
    \ else return false\nend function\n</code>\n<|/ a |>\n<| a tags=haskell |>\nHere\
    \ is another solution\n<code>\nimport Data.Char\nimport Data.List\nimport Data.Maybe",
  "    if brackets == \"\"\n        true\n    else if brackets[0] == brackets[end]\n\
    \        false\n    elseif brackets[1] == brackets[end]\n        false\n    elseif\
    \ brackets[1] == brackets[end-1]\n        correct_bracketing(brackets[2:end-1])\n\
    \    elseif brackets[0] == brackets[1]\n        correct_bracketing(brackets[2:end])\n\
    \    else\n        correct_bracketing(brackets[1:end-1])\n    end\nend", "   \
    \ if brackets == \"\" then return true\n    brackets = \"<\" + brackets + \">\"\
    \n    brackets = brackets[2:-2]\n    brackets = brackets.replace(\"<\",\"\")\n\
    \    brackets = brackets.replace( \">\",\"\")\n    brackets = brackets.replace(\"\
    <<\",\"\")\n    brackets = brackets.replace(\">>\",\"\")\n    return brackets\
    \ == brackets\nend", "{\n    brackets = brackets |> remove_empty_brackets\n  \
    \  for opening in brackets\n        match opening\n            | \"<\" => false\n\
    \            | \"<=\" => true\n            | \">\" => false\n            | \"\
    >=\" => true\n            | _ => \n                let closing = opening[1..opening.len()]\
    \ in\n                correct_bracketing(closing)\n        end\n    end\n    true\n\
    end\n\"\"\"\n    remove_empty_brackets(s::String)::String\n\"\"\"\n    Remove\
    \ empty brackets from the string.", "    \"\"\"\n    correct_bracketing(brackets::String)::Bool\n\
    \    True if brackets has every opening bracket followed by every closing bracket.",
  "    for i in brackets\n        if i !~ i::Char\n            return false\n    return\
    \ true\nend\n</cell>\n<cell>\n\"\"\"\n is_parenthetic(string)\n check if string\
    \ is inside parentheses\n\"\"\"", "        bracket_to_open :: String # a String\
    \ that represents an opening bracket that we are checking\n        bracket_to_close\
    \ :: String # a String that represents a closing bracket that we are checking\n\
    \        open_count :: Int = 0 # an Int that represents the number of opening\
    \ brackets that we have already seen\n        close_count :: Int = 0 # an Int\
    \ that represents the number of closing brackets that we have already seen\n \
    \       if brackets.length < 2 return true\n        else if brackets.head == \"\
    <\" then return false # if the brackets string starts with a \"<\" then we know\
    \ we aren't in the correct bracketing state\n        else if brackets.head ==\
    \ \">\" then return false # if the brackets string starts with a \">\" then we\
    \ know we aren't in the correct bracketing state\n        else if brackets.head\
    \ == \"<\" then open_count += 1 else open_count += 0 # if brackets.head == \"\
    >\" then open_count += 1 else open_count += 0\n        else if brackets.head ==\
    \ \">\" then close_count += 1 else close_count += 0 # if brackets.head == \">\"\
    \ then close_count += 1 else close_count += 0\n        else if brackets.head ==\
    \ \">>\" then return false # if the brackets string starts with \">>\" then we\
    \ know we are in the correct bracketing state\n        else if brackets.head ==\
    \ \"<\" then return false # if the brackets string starts with \"<\" then we know\
    \ we are in the correct bracketing state\n        else if brackets.head == \"\
    <<\" then return false # if the brackets string starts with \"<<\" then we know\
    \ we are in the correct bracketing state\n        else if brackets.head == \"\
    <\" then open_count += 2 else open_count += 0 # if brackets.head == \">>\" then\
    \ open_count += 2 else open_count += 0\n        else if brackets.head == \">\"\
    \ then close_count += 2 else close_count += 0 # if brackets.head == \"<<\" then\
    \ close_count += 2 else close_count += 0\n        else if brackets.head == \"\
    >\" then return false # if the brackets string starts with \">\" then we know\
    \ we are in the correct bracketing state\n        else if brackets.head == \"\
    <\" then return false # if the brackets string starts with \"<\" then we know\
    \ we are in the correct bracketing state\n        else if brackets.head == \"\
    >\" then return false # if the brackets string starts with \">\" then we know\
    \ we are in the correct bracketing state\n        else if brackets.head == \"\
    <\" then return false # if the brackets string starts with \"<\" then we know\
    \ we are in the correct bracketing state\n        else if brackets.head == \">",
  "    \"\"\"\n    correct_bracketing(brackets::String)", "    return (length(split(brackets,\
    \ \"<>\"))==1)\nend", "    brackets = brackets[2:]\n    for i in brackets\n  \
    \      if brackets[i] != brackets.last(i)\n            false\n        else false\n\
    \    end\nend\n</code>\nThis function returns false/true depending on the brackets\
    \ given.\nThe function checks whether the closing bracket of the opening bracket\
    \ is equal to the closing bracket of the last opening bracket it encounters. \n\
    If the closing bracket of the opening bracket is not equal to the closing bracket\
    \ of the last opening bracket, false is returned.\n<|/ a |>\n<| c |>\nThe question\
    \ mentions \"return false if the brackets are in a wrong order\", so this solution\
    \ will also return false if there are more closing brackets than opening brackets.\n\
    <|/ c |>\n<| c |>\n, Thanks for the comment. I've updated my answer accordingly.\n\
    <|/ c |>\n<| a |>\nYou can just check the last index (length) of brackets in the\
    \ function and reverse the string (substring) in each iteration. \n<code>", " \
    \   if is_balanced(brackets):\n        brackets = balance(brackets)\n        brackets\
    \ = brackets.replace(\"<\", \"\")\n        brackets = brackets.replace(\">\",\
    \ \"\")\n        brackets = brackets.replace(\"<<\", \">>\")\n        brackets\
    \ = brackets.replace(\">>\", \"\")\n        if brackets == \"<>\":\n         \
    \   return true\n    return false\n</code>\n<|/ a |>\n<| c |>\nI wonder why you're\
    \ doing this in O(n) rather than O(1)?  It seems less efficient than simply doing\
    \ it in O(n).  Do you have a source for this?\n<|/ c |>\n<| c |>\nSure, I'm an\
    \ engineer, not a computer scientist. :)  However, I imagine it would be O(n)\
    \ in theory, because every function call would have to be executed for every string\
    \ that was checked - that's n*n number of function calls in your example.  The\
    \ number of function calls is also exponential in the number of characters you\
    \ check.\n<|/ c |>\n<| c |>\nI think it's an O(n) because you check each string\
    \ character for opening and closing brackets. So you're doing O(n*n) characters\
    \ per function call. Is that right?\n<|/ c |>\n<| c |>\nOh I see, you're basically\
    \ taking a string of n*n (n) characters and checking if the string itself is balanced\
    \ using the `is_balanced` function?  That's a good idea, I'll definitely give\
    \ that a try. Thanks!\n<|/ c |>\n<| c |>\nYeah, you're right. That's what I was\
    \ thinking.  If you did it in O(1) instead (i.e. checking only the first character\
    \ or something), then you're right, that would be an O(n) solution.\n<|/ c |>\n\
    <| a dscore=4 |>\n<code>\ndef isBalanced(s: String) = {\n    var openingBrackets:\
    \ Int = 0\n    var closingBrackets: Int = 0", "    brackets = brackets.replace(\"\
    <\",\">\")\n    brackets = brackets.replace(\">\",\"<\")\n    brackets = brackets.replace(\"\
    <<\",\">>\")\n    brackets = brackets.replace(\">>\",\"<<\")\n    brackets = brackets.replace(\"\
    <<<\",\">>>\")\n    brackets = brackets.replace(\">>>\",\"<<<\")\n    brackets\
    \ = brackets.replace(\"<<<<\",\">>>>\")\n    brackets = brackets.replace(\">>>>\"\
    ,\"<<<<\")\n    brackets = brackets.replace(\"<\",\"\")\n    brackets = brackets.replace(\"\
    >\",\"\")\n    brackets = brackets.replace(\">>\",\"\")\n    brackets = brackets.replace(\"\
    <<\",\"\")\n    brackets = brackets.replace(\"<>\",\"\")\n    brackets = brackets.replace(\"\
    >>\",\"\")\n    brackets = brackets.replace(\"<<<\",\"\")\n    brackets = brackets.replace(\"\
    >>>\",\"\")\n    brackets = brackets.replace(\"<<<<\",\"\")\n    brackets = brackets.replace(\"\
    >>>>\",\"\")\n    brackets = brackets.replace(\"<\",\"\")\n    brackets = brackets.replace(\"\
    >\",\"\")\n    brackets = brackets.replace(\">>\",\"\")\n    brackets = brackets.replace(\"\
    <<\",\"\")\n    brackets = brackets.replace(\"<>\",\"\")\n    brackets = brackets.replace(\"\
    >>\",\"\")\n    brackets = brackets.replace(\"<<<\",\"\")\n    brackets = brackets.replace(\"\
    >>>\",\"\")\n    brackets = brackets.replace(\"<<<<\",\"\")\n    brackets = brackets.replace(\"\
    >>>>\",\"\")\n    brackets = brackets.replace(\"<\",\"\")\n    brackets = brackets.replace(\"\
    >\",\"\")\n    brackets = brackets.replace(\">>\",\"\")\n    brackets = brackets.replace(\"\
    <<\",\"\")\n    brackets = brackets.replace(\"<>\",\"\")\n    brackets = brackets.replace(\"\
    >>\",\"\")\n    brackets = brackets.replace(\"<<<\",\"\")\n    brackets = brackets.replace(\"\
    >>>\",\"\")\n    brackets = brackets.replace(\"<<<<\",\"\")\n    brackets = brackets.replace(\"\
    >>>>\",\"\")\n    brackets = brackets.replace(\"<\",\"\")\n    brackets = brackets.replace(\"\
    >\",\"\")\n    brackets = brackets.replace(\">>\",\"\")\n    brackets = brackets.replace(\"\
    <<\",\"\")\n    brackets = brackets.replace(\"<>\",\"\")\n    brackets = brackets.replace(\"\
    >>\",\"\")\n    brackets = brackets.replace(\"<<<\",\"\")\n    brackets = brackets.replace(\"\
    >>>\",\"\")\n    brackets = brackets.replace(\"<<<<\",\"\")\n    brackets = brackets.replace(\"\
    >>>>\",\"\")\n    brackets = brackets.replace(\"<\",\"\")\n    brackets = brackets.replace(\"\
    >\",\"\")\n    brackets = brackets.replace(\">>\",\"\")\n    brackets = ", " \
    \   correct_bracketing <- length(brackets) == 2\n    if correct_bracketing then\n\
    \        bracket_opening <- brackets[1] == \"<\"\n        bracket_closing <- brackets[2]\
    \ == \">\"\n        correct_bracketing <- bracket_opening && bracket_closing\n\
    \    end\n    return correct_bracketing\nend", "    brackets == \"<\"\nend\n</cell>\n\
    <code language=julia-0.6>\n\"\"\"\nThis function removes unnecessary brackets\
    \ from the given string.\n    \nThe return value is a string with unnecessary\
    \ brackets removed.", "\"\"\"\n    correct_bracketing determines whether the brackets\
    \ are correctly \n    paired.", "    brackets = brackets.replace(\"<\", \"\")\n\
    \    brackets = brackets.replace(\"<\", \"\")\n    brackets = brackets.replace(\"\
    >\", \"\")\n    brackets = brackets.replace(\">\", \"\")\n    brackets = brackets.replace(\"\
    <<\", \"\")\n    brackets = brackets.replace(\"<<\", \"\")\n    brackets = brackets.replace(\"\
    >>\", \"\")\n    brackets = brackets.replace(\">>\", \"\")\n    brackets = brackets.replace(\"\
    <<<\", \"\")\n    brackets = brackets.replace(\"<<<\", \"\")\n    brackets = brackets.replace(\"\
    >>>\", \"\")\n    brackets = brackets.replace(\">>>\", \"\")\n    brackets = brackets.replace(\"\
    <<<\", \"\")\n    brackets = brackets.replace(\">>>\", \"\")\n    brackets = brackets.replace(\"\
    ><<\", \"\")\n    brackets = brackets.replace(\">>>\", \"\")\n    return brackets\
    \ == \"<\"\nend\n</cell>\n<text>\n6.4  Tokenize a String", "    \"\"\"\n    Your\
    \ solution here\n    \"\"\"\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\n#include<bits/stdc++.h>\n\
    using namespace std;", "    \"\"\"\n    Function takes a string of \"<\" and \"\
    >\".\n    Return true if every opening bracket has a corresponding closing bracket.\n\
    \    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"<>\"\
    )\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \"\"\"\n    \n    open_brackets = \"\"\n    close_brackets\
    \ = \"\"\n    \n    for i in brackets:\n        if i == \"<\":\n            open_brackets\
    \ += i\n        else:\n            close_brackets += i\n    \n    if open_brackets\
    \ == close_brackets:\n        return true\n    else:\n        return false\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThank you for your answer! However, I don't understand\
    \ the concept of \"open brackets\" and \"close brackets\". Do you have a link\
    \ where I can read more about this?\n<|/ c |>\n<| c |>\nThe concept of \"open\
    \ brackets\" and \"close brackets\" is \"brackets\" and \"bracketing\". The first\
    \ thing I thought of when reading the question was that you are talking about\
    \ \"open brackets\" and \"close brackets\" because you didn't mention them in\
    \ your question. Regarding the \"bracketing problem\", I thought about it a lot\
    \ while trying to solve the question, so I figured I should give it a try.\n<|/\
    \ c |>\n<| c |>\nOh, yeah you are right, I didn't really think of it right away,\
    \ I just thought it would be a logical explanation for \"brackets\". Thank you\
    \ for your answer! :)\n<|/ c |>\n<| c |>\nAh ok, thanks for clarifying that. I\
    \ added an example on how to use it on the answer.\n<|/ c |>\n<| c |>\nHey man,\
    \ thanks for your answer! I understand the code now. However, I got a problem\
    \ with the return true/false statements. When I try to use your function I get\
    \ the following error: \n\"the function correct_bracketing expects 1 argument,\
    \ but only 0 was given\". I tried to use your function like this:\ncorrect_bracketing(\"\
    <>\")\n<|/ c |>\n<| a tags=string,python,recursion |>\n<code>\ndef check_brackets(s):\n\
    \    if(not s): return\n    if(s[0]==\"<\" and s[-1]==\">\"): return check_brackets(s[1:-1])\n\
    \    if(s[0]==\"[\" and s[-1]==\"]\"): return check_brackets(s[1:-1])\n    if(s[0]==\"\
    {\" and s[-1]==\"}\"): return check_brackets(s[1:-1])\n", "\"\"\"\n    brackets\
    \ is a string of \"<\" and \">\".\n    return true if every opening bracket has\
    \ a corresponding closing bracket.", "    correct_bracketing(brackets, 0)\nend",
  "    # implement your function here\n    pass\n</code>\n<|/ a tags=algorithm |>\n\
    <| a tags=algorithm |>\nYou have to count occurrences of each of '<','>' and '='\
    \ symbols. You can do so by using an array that contains the number of occurrences\
    \ for each symbol. After that it is just a matter of comparing these two arrays,\
    \ if they contain the same number of occurrences, you have found a correct solution,\
    \ otherwise you are in the wrong position.\n<code>\nvar symbols = new Array(\"\
    >=\", \"<=\", \"<\", \"=\");", "    bracket = brackets[1]\n    if brackets.head\
    \ == bracket:\n        brackets = brackets[2:]\n    if brackets.head != \">\"\
    :\n        return False\n    else: \n        brackets = brackets[1:] \n    if\
    \ brackets.head == \"<\":\n        return False\n    else: \n        return True",
  "    bracket_stack = Stack{String}(brackets)\n    return !bracket_stack.empty()",
  "    if brackets !~ \":(<<|>>>)(<<|>>>)\":\n        return false\n    open_brackets\
    \ = brackets[1, brackets.find(\"<\")..brackets.find(\"<\")+3]\n    close_brackets\
    \ = brackets[brackets.find(\"<\")+3, brackets.find(\"<\")+6..brackets.find(\"\
    <\")+8]\n    if open_brackets /= close_brackets then\n        return false\n \
    \   else\n        return true\nend", "    \"\"\"\n    Takes a string of \"<\"\
    \ and \">\" and returns true if every opening bracket has a corresponding closing\
    \ bracket.\n    \"\"\"\n\"\"\"\n    Implementation of a recursive algorithm to\
    \ find all possible valid bracketings.\n    \n    The algorithm is implemented\
    \ using recursion and a helper function called \"check_valid_position\".\n   \
    \ \n    Arguments:\n        brackets -- a bracketing as a string.", "    \"\"\"\
    \n    correct_bracketing(brackets::String)", "    bracket_count::Int = 0\n   \
    \ for char in brackets\n        if char == \"<\"\n            bracket_count +=\
    \ 1\n        elseif char == \">\"\n            bracket_count -= 1\n        else\n\
    \            error(\"Unrecognized opening bracket\")\n            false\n    return\
    \ bracket_count == 0\n    end\nend \n</cell>\n<text>\nExercise: Write a function\
    \ called correct_parenthesis that takes a string and checks to see if every pair\
    \ of parentheses matches a pair of matching closing parentheses.", "    brackets\
    \ = \"<\" + brackets + \">\"\n    bpos = 0\n    epos = length(brackets)\n    \n\
    \    while bpos < epos do\n        beg = brackets[bpos]\n        end = brackets[epos]\n\
    \        if beg < end then\n            beg += 1\n        end\n        if beg\
    \ > end then\n            epos -= 1\n        end\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\ncorrect_bracketing(\"<\")\n</cell>\n<code language=julia-1.5>\n\
    correct_bracketing(\"<>\")\n</cell>\n<code language=julia-1.5>\ncorrect_bracketing(\"\
    <<><>>\")\n</cell>\n<code language=julia-1.5>\ncorrect_bracketing(\"><<>\")\n\
    </cell>\n<text>\nExercise 9: Implementing Lexical_Analysis.jl\nWrite a function\
    \ named lexical_analysis that takes two arguments:", "    \n    true = false \n\
    \    if brackets contains \"<\"\n        true = false \n        for ch in brackets\n\
    \            if ch == \"<\"\n                true = true \n            else if\
    \ ch == \">\"\n                true = true\n            end\n        end\n   \
    \ end\n    return true\nend\n</cell>\n<code language=julia-1.2>\n\"\"\"\n is_balanced\n\
    \   Given a string of brackets, return true if every opening bracket has a corresponding\
    \ closing bracket.\n   \"\"\"", "    brackets = brackets.replace(\" \", \"\")\n\
    \    brackets = brackets.replace(\">\", \"\")\n    brackets = brackets.replace(\"\
    <\", \"\")\n    brackets = brackets.replace(\",\", \"\")\n    brackets = brackets.replace(\"\
    (\", \"\")\n    brackets = brackets.replace(\")\", \"\")\n    brackets = brackets.replace(\"\
    {\", \"\")\n    brackets = brackets.replace(\"}\", \"\")\n    brackets = brackets.replace(\"\
    :\", \":\")\n    brackets = brackets.replace(\":<\", \":>\")\n    brackets = brackets.replace(\"\
    :>\", \":<\")\n    brackets = brackets.replace(\":>:\", \":<:\")\n    brackets\
    \ = brackets.replace(\":\", \":\")\n    brackets = brackets.replace(\":\", \"\
    :\") \n    brackets = brackets.replace(\":>:\", \":<:\")\n    brackets = brackets.replace(\"\
    :<:\", \":>:\")\n    brackets = brackets.replace(\":<:\", \":>:\")\n    brackets\
    \ = brackets.replace(\":>:\", \":<:\")\n    brackets = brackets.replace(\":\"\
    , \":\")\n    brackets = brackets.replace(\":<\", \":>\")\n    brackets = brackets.replace(\"\
    :>\", \":<\")\n    brackets = brackets.replace(\":>:\", \":<:\")\n    brackets\
    \ = brackets.replace(\":\", \":\")\n    brackets = brackets.replace(\",\", \"\"\
    )\n    brackets = brackets.replace(\";\", \"\")\n    brackets = brackets.replace(\"\
    ;\", \"\")\n    brackets = brackets.replace(\",\", \"\")\n    brackets = brackets.replace(\"\
    :\", \"\")\n    brackets = brackets.replace(\",\", \"\")\n    brackets = brackets.replace(\"\
    ;\", \"\")\n    brackets = brackets.replace(\",\", \"\")\n    brackets = brackets.replace(\"\
    ;\", \"\")\n    brackets = brackets.replace(\";\", \"\")\n    brackets = brackets.replace(\"\
    ;\", \"\")\n    brackets = brackets.replace(\";\", \"\")\n    brackets = brackets.replace(\"\
    ;\", \"\")\n    brackets = brackets.replace(\";\", \"\")\n    brackets = brackets.replace(\"\
    ;\", \"\")\n    brackets = brackets.replace(\";\", \"\")\n    brackets = brackets.replace(\"\
    ;\", \"\")\n    brackets = brackets.replace(\";\", \"\")\n    brackets = brackets.replace(\"\
    ;\", \"\")\n    brackets = brackets.replace(\";\", \"\")\n    brackets = brackets.replace(\"\
    ;\", \"\")\n    brackets = brackets.replace(\";\", \"\")\n    brackets = brackets.replace(\"\
    ;\", \"\")\n    brackets = brackets.replace(\";\", \"\")\n    brackets = brackets.replace(\"\
    ;\", \"\")\n    brackets = brackets.replace(\";\", \"\")\n    brackets = brackets.replace(\"\
    ;\", \"\")\n    brackets = brackets.replace(\";\", \"\")\n    brackets = bracket",
  "  \n    bracketing_array = brackets_to_array(brackets)\n    brackets_count = 0\n\
    \    \n    for elem in bracketing_array\n        if elem == \">\"\n          \
    \  brackets_count += 1\n        if elem == \"<\"\n            brackets_count -=\
    \ 1\n            if brackets_count < 0\n                brackets_count = 0\n \
    \           if brackets_count > 0\n                brackets_count = 0\n      \
    \      \n            if brackets_count == 0\n                true\n          \
    \  end\n        end\n    end\nend\n</code>\n<|/ a dscore=1 tags=recursion,haskell,string\
    \ |>\n<| c |>\nYour solution is nice, but it's not exactly right. It counts the\
    \ number of `<` characters, not the length of the string. For example, it considers\
    \ `\"<<>\"` as 2 opening brackets, but it only has 1.\n<|/ c |>\n<| c |>\nThanks.\
    \ I have fixed it.\n<|/ c |>\n<| c |>\nThank you very much. Your code works flawlessly\
    \ now. Could you tell me how you came up with the array and how you counted the\
    \ length of the string without using a function?\n<|/ c |>\n<| c |>\nHi Matteo.\
    \ I figured it out. I've used this website to figure it out http://wiki.haskell.org/Index\n\
    <|/ c |>\n<| c |>\nI added some code at the bottom of the answer that shows how\
    \ I used the array to count the number of opening brackets.\n<|/ c |>\n<| a |>\n\
    A simple solution using only Data.Char, Data.List and Data.Either:\n<code>\nimport\
    \ Data.Char\nimport Data.List\nimport Data.Either", "    \"\"\"\n    correct_bracketing(brackets::String)::Bool\n\
    \    \n    Returns true if the brackets are correctly balanced.\n    \"\"\"\n\
    \    return (brackets == \"<\") and (brackets == \"<\") or \\\n           (brackets\
    \ == \"<=\") or (brackets == \"<\") or (brackets == \"<=\") \\\n           and\
    \ (brackets == \"<\") or (brackets == \"<=\") or (brackets == \"<>\")", "    \n\
    \    # your code here\n    \n    return true\n    \nend", "  result = true\n \
    \ for opening, closing in brackets\n    if opening != closing\n      result =\
    \ false\n  return result", "    \n    # write your code here\n    \n    \nend\"\
    \"\"", "    bracket_opening = brackets.find(\"<\")\n    bracket_closing = brackets.find(\"\
    >\")\n    if bracket_opening < bracket_closing\n        return false\n    else\
    \ if bracket_opening > bracket_closing\n        return true\n    else if brackets[bracket_opening\
    \ - 1] != \"<\" && brackets[bracket_closing - 1] != \">\"\n        return true\n\
    \    else\n        return false", "    \"\"\"\n    correct_bracketing(brackets::String)\n\
    \    Determine whether the bracketing of a string is correct.\n    brackets is\
    \ a string of \"<\" and \">\".\n    return true if every opening bracket has a\
    \ corresponding closing bracket.", "\"\"\"Given a list of brackets [brackets],\
    \ determine if every opening bracket has a corresponding closing bracket. \"\"\
    \" \n    bracket_stack = []\n    for bracket in brackets do \n        if bracket\
    \ = \"<\" do \n            if not (isnull(bracket_stack) and (bracket_stack.pop()\
    \ = \">\") do \n                return false \n            end \n        else\
    \ \n            if bracket = \"<\" do \n                bracket_stack.append(bracket)\n\
    \            end \n            else \n                bracket_stack.pop()\n  \
    \          end\n        end\n    end\n    return true\nend\n</cell>\n<text>\n\
    Problem 3\nImplement a stack of strings named brackets. Push strings to the stack\
    \ in the following order:", "    for c in brackets:\n        if c not in  \">\"\
    :\n            return false\n    return true\nend\n</cell>\n<text>\nExercise 6\n\
    Implement an implementation of \"eval\" that takes a string and returns a number\n\
    \    of the same type as its input.", "    let bracket_stack = Stack()\n    for\
    \ c in brackets\n        if c == '<'\n            bracket_stack.push(c)\n    \
    \    elseif c == '>'\n            bracket_stack.pop()\n        else\n        \
    \    bracket_stack.empty()\n    if bracket_stack.empty()\n        true\n    else\n\
    \        false\nend\n</cell>\n<code language=julia-1.3>\ncorrect_bracketing(\"\
    <\")\n</cell>\n<code language=julia-1.3>\ncorrect_bracketing(\"<>\")\n</cell>\n\
    <code language=julia-1.3>\ncorrect_bracketing(\"<<><>>\")\n</cell>\n<code language=julia-1.3>\n\
    correct_bracketing(\"><<>\")\n</cell>\n<text>\nExercise 8\nWrite a function, is_bracketing_correct(brackets::String)\
    \ which takes as input a bracketing string and returns a Boolean indicating whether\
    \ the bracketing is correct (return true if brackets are correctly nested, and\
    \ false otherwise). A bracketing string is a string of \"<\" and \">\" characters\
    \ within double quotes, e.g. \"<<><>>\".", "    | true\n    | false =\n    begin\
    \ match brackets with\n    | \"\" -> false\n    | \">>\"  -> true\n    | \"<>\"\
    \  -> false\n    | \"><\"  -> true\n    | \"<<\"  -> false\n    | \"<><\" -> false\n\
    \    | \">>>\" -> true\n    | \"<>>\" -> false\n    | \"><\"  -> true\n    | \"\
    <<\"  -> false\n    | \"<><\" -> false\n    | \"<><\" -> true\n    | _ -> false\n\
    \    end\nend\n</cell>\n<code language=julia-1.0>", "    \"\"\"\n    >>> correct_bracketing(\"\
    <\")\n    false\n    >>> correct_bracketing(\"<>\")\n    true\n    >>> correct_bracketing(\"\
    <<><>>\")\n    true\n    >>> correct_bracketing(\"><<>\")\n    false\n    \"\"\
    \"\n    bracket_stack = Set[String]()\n    correct_bracketing = false", "    open_count::Int\
    \ \n    close_count::Int \n    open_bracket::String \n    close_bracket::String\
    \ \n    open_quote::String \n    close_quote::String ", "    if brackets == \"\
    \" then return true \n    else return false\n    ends_with_left = brackets[end]\
    \ <> \"<\" \n    opening_brackets = brackets[start:end] \n    for i in opening_brackets\
    \ do \n        if ends_with_left then \n            ends_with_left = (brackets[end]\
    \ == \">\") \n        end\n    ends_with_right = (brackets[end] == \">\") \n \
    \   for i in opening_brackets do \n        if ends_with_right then \n        \
    \    ends_with_right = (brackets[end] == \">\") \n        end\n    ends_with_left_or_right\
    \ = ends_with_left || ends_with_right \n    for i in opening_brackets do \n  \
    \      if ends_with_left_or_right then \n            ends_with_left_or_right =\
    \ (brackets[end] == \">\") \n        end\n    ends_with_left_or_right_or_close\
    \ = ends_with_left_or_right || ends_with_close\n    for i in opening_brackets\
    \ do \n        if ends_with_left_or_right_or_close then \n            ends_with_left_or_right_or_close\
    \ = (brackets[end] == \">\") \n        end\n    ends_with_left_or_right_or_close_in_closing_bracket\
    \ = ends_with_left_or_right_or_close || brackets[end] == \"<\" \n    for i in\
    \ opening_brackets do \n        if ends_with_left_or_right_or_close_in_closing_bracket\
    \ then \n            ends_with_left_or_right_or_close_in_closing_bracket = (brackets[end]\
    \ == \"<\") \n        end\n    ends_with_left_or_right_or_close_in_closing_bracket\
    \ = ends_with_left_or_right_or_close || brackets[end] == \"<\" \n    return ends_with_left_or_right_or_close_in_closing_bracket",
  "    \"\"\" A function which returns true if the brackets in a string are\n    correctly\
    \ opening and closing brackets.", "    if brackets == \"<\" or brackets == \"\
    <<\" or brackets == \"<<<\":\n        return true\n    if brackets == \"<>\" or\
    \ brackets == \"<>\" or brackets == \"<<<\" or brackets == \"<<<=\":\n       \
    \ return false\n    if brackets == \"<>=\":\n        return true\n    if brackets\
    \ == \"<=\":\n        return false\n    if brackets == \">\" or brackets == \"\
    >>\" or brackets == \">>>\" or brackets == \">>>=\":\n        return true\n  \
    \  if brackets == \"=>\" or brackets == \"=>=\":\n        return true\n    if\
    \ brackets == \"=\":\n        return false\n    if brackets == \"==\":\n     \
    \   return true\n    if brackets == \"<=>\":\n        return true\n    if brackets\
    \ == \"<=>=\":\n        return false\n    if brackets == \"!=\":\n        return\
    \ true\n    if brackets == \"==\":\n        return true\n    if brackets == \"\
    !=\":\n        return true\n    if brackets == \"==\":\n        return true\n\
    \    if brackets == \"<=\":\n        return true\n    return false", "    brackets\
    \ = brackets.to_string()\n    for i in 1..length(brackets)\n        if brackets[i]\
    \ != brackets[i-1]\n            return False\n    end\n    return true\nend",
  "    \"\"\"\n    correct_bracketing(brackets::String)::Bool", "    brackets = brackets.replace(\"\
    <\", \">\")\n    brackets = brackets.replace(\">\", \">>\")\n    brackets = brackets.replace(\"\
    <\", \">\")\n    brackets = brackets.replace(\">\", \"<\")\n    brackets = brackets.replace(\"\
    >\", \">>\")\n    brackets = brackets.replace(\"<<\", \">><\")\n    brackets =\
    \ brackets.replace(\"<\", \">\")\n    brackets = brackets.replace(\">\", \">>\"\
    )\n    brackets = brackets.replace(\"<<\", \">><\")\n    brackets = brackets.replace(\"\
    <<\", \">><\")\n    brackets = brackets.replace(\">>\", \">><\")\n    brackets\
    \ = brackets.replace(\"<<\", \">><\")\n    brackets = brackets.replace(\">>\"\
    , \">><\")\n    brackets = brackets.replace(\">>\", \">><\")\n    brackets = brackets.replace(\"\
    >>\", \">><\")\n    brackets = brackets.replace(\">>\", \">><\")\n    brackets\
    \ = brackets.replace(\">>\", \">><\")\n    brackets = brackets.replace(\">>\"\
    , \">><\")\n    brackets = brackets.replace(\">>\", \">><\")\n    brackets = brackets.replace(\"\
    >>\", \">><\")\n    brackets = brackets.replace(\">>\", \">><\")\n    brackets\
    \ = brackets.replace(\">>\", \">><\")\n    brackets = brackets.replace(\">>\"\
    , \">><\")\n    brackets = brackets.replace(\">>\", \">><\")\n    brackets = brackets.replace(\"\
    >>\", \">><\")\n    brackets = brackets.replace(\">>\", \">><\")\n    brackets\
    \ = brackets.replace(\">>\", \">><\")\n    brackets = brackets.replace(\">>\"\
    , \">><\")\n    brackets = brackets.replace(\">>\", \">><\")\n    brackets = brackets.replace(\"\
    >>\", \">><\")\n    brackets = brackets.replace(\">>\", \">><\")\n    brackets\
    \ = brackets.replace(\">>\", \">><\")\n    brackets = brackets.replace(\">>\"\
    , \">><\")\n    brackets = brackets.replace(\">>\", \">><\")\n    brackets = brackets.replace(\"\
    >>\", \">><\")\n    brackets = brackets.replace(\">>\", \">><\")\n    brackets\
    \ = brackets.replace(\">>\", \">><\")\n    brackets = brackets.replace(\">>\"\
    , \">><\")\n    brackets = brackets.replace(\">>\", \">><\")\n    brackets = brackets.replace(\"\
    >>\", \">><\")\n    brackets = brackets.replace(\">>\", \">><\")\n    brackets\
    \ = brackets.replace(\">>\", \">><\")\n    brackets = brackets.replace(\">>\"\
    , \">><\")\n    brackets = brackets.replace(\">>", "    bracket_stack = brackets\n\
    \    bracket_stacks = brackets[brackets.len()-1]\n    loop do\n        push!(bracket_stack,\
    \ pop!(bracket_stacks))\n    end\n    return brackets == \"<>\"\nend\n</cell>\n\
    <code language=julia-1.6>\n@assert correct_bracketing(\"<\")\n@assert correct_bracketing(\"\
    <>\")\n@assert correct_bracketing(\"<<><>>\")\n@assert correct_bracketing(\"><<>\"\
    )\n</cell>\n<text>\nProblem 3: Counting Balloons\nNow you are going to write a\
    \ function count_balloons(balloons) that counts the number of balloons\n(pairs\
    \ of brackets, like (<>)) in balloons.", "    # Brackets is a string of \"<\"\
    \ and \">\"\n    for i in brackets do \n        if i != \"<\" and i != \"<\" then\
    \ return false \n    else true \nend \n</code>\n<|/ a tags=arrays,julia,string\
    \ |>\n<| c |>\nThis should work, but it's pretty inefficient. You don't need to\
    \ check the whole string just to see if a given opening bracket is followed by\
    \ an opening bracket, because you already know that the string is not empty. Also,\
    \ it's preferable to use `===` instead of `==` when comparing against strings;\
    \ it's safer.\n<|/ c |>\n<| c |>\nthank you for the comments, I just edited my\
    \ answer to take into account your suggestions. I agree that checking if the string\
    \ is empty would be a better solution.\n<|/ c |>\n<| a tags=arrays,julia,string\
    \ |>\nHere are a few other solutions:\n<code>\njulia> brackets = collect(string.(\"\
    <<><>>\"))\n7-element Array{String,1}:\n \"<\"\n \">\"\n \"<\"\n \">\"\n \"<\"\
    \n \">\"\n \"<\"", "    bracket_stack::Stack[Char] = Stack[Char]([])\n    bracket_stack_top::Int\
    \ = -1\n    \n    for c in brackets\n        if c == '<' push(c) else if c ==\
    \ '>' pop() else if c == '('\n            push(c)\n            if bracket_stack_top\
    \ == -1 then\n                bracket_stack_top = length(bracket_stack)\n    \
    \        elseif length(bracket_stack) < bracket_stack_top then\n             \
    \   bracket_stack = bracket_stack ++ ['(']\n            end\n        elseif c\
    \ == '(' && bracket_stack_top > 0 &&\n            length(bracket_stack) > bracket_stack_top\
    \ then\n            pop() ! bracket_stack\n            bracket_stack_top -= 1\n\
    \        elseif c == '(' && bracket_stack_top == -1 then\n            push(c)\
    \ ! bracket_stack\n            bracket_stack_top = length(bracket_stack)\n   \
    \     elseif c == ')' && bracket_stack_top > 0 &&\n            length(bracket_stack)\
    \ > bracket_stack_top then\n            pop() ! bracket_stack\n            bracket_stack_top\
    \ -= 1\n        elseif c == ')' && bracket_stack_top == -1 then\n            push(c)\
    \ ! bracket_stack\n            bracket_stack_top = length(bracket_stack)\n   \
    \     elseif c == '>' && (bracket_stack_top > 0 &&\n            length(bracket_stack)\
    \ > bracket_stack_top) then\n            pop() ! bracket_stack\n            bracket_stack_top\
    \ -= 1\n        elseif c == '>' && (bracket_stack_top == -1 ||\n            length(bracket_stack)\
    \ < bracket_stack_top) then\n            push(c) ! bracket_stack\n           \
    \ bracket_stack_top = length(bracket_stack)\n        elseif c == '<' && length(bracket_stack)\
    \ > 0 &&\n            (bracket_stack_top < 0 || length(bracket_stack) < bracket_stack_top)\
    \ then\n            pop() ! bracket_stack\n            bracket_stack_top += 1\n\
    \        elseif c == '<' && length(bracket_stack) == 0 &&\n            bracket_stack_top\
    \ < 0 then\n            push(c) ! bracket_stack\n            bracket_stack_top\
    \ = length(bracket_stack)\n        end\n    end\n    \n    return bracket_stack_top\
    \ == -1\nend\n</cell>\n<code language=julia-0.6>\n\"\"\"\ncount_", "    \"\"\"\
    \n    correct_bracketing receives a string with brackets inside (like \"()[]{}<>\"\
    )\n    and returns a boolean indicating whether all brackets are matched\n   \
    \ correctly.", "    return (\n        brackets !~ RE(\"\"\"\n            (?: [^<>]*\
    \ ) |  # no less than opening bracket\n            (?: [^<>]* [^<>]* ) |  # no\
    \ more than two opening brackets\n            ^ ( <> )+ $  # at least one closing\
    \ bracket\n        \"\"\", re.X)\n    )", "    \"\"\"\n    Corrects the bracketing\
    \ of brackets so that it matches the string brackets.\n    Returns a Boolean representing\
    \ whether the bracketing is correct.", "    if brackets == \"\" then \n      \
    \  return true\n    else if brackets[0] == \"<\" then \n        return false\n\
    \    else if brackets[len (brackets) - 1] == \">\" then \n        return false\n\
    \    else\n        return correct_bracketing(brackets[1:len (brackets) - 1]) ||\
    \ correct_bracketing(brackets[2:len (brackets)])\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\n    correct_bracketing(brackets::String)::Bool\n    b is a string of a\
    \ set of brackets.\n    return true if every opening bracket has a corresponding\
    \ closing bracket.\n    \n    >>> correct_bracketing(\"<\")\n    false\n    >>>\
    \ correct_bracketing(\"<>\")\n    true\n    >>> correct_bracketing(\"<<><>>\"\
    )\n    true\n    >>> correct_bracketing(\"><<>\")\n    false\n    \"\"\"", " \
    \   # loop to keep track of whether or not a closing bracket is present for every\n\
    \    # opening bracket.\n    for opening_bracket in brackets\n        if opening_bracket\
    \ <> brackets[1]\n            return false\n    return true\n    end\n</code>\n\
    <|/ a tags=string,haskell,brackets |>\n<| c |>\nThis is a good way to think about\
    \ it.  I might suggest that there should be a way to get rid of the empty string\
    \ `\"\"` from `brackets` and replace it with `\"()\"` so that the result is that\
    \ `(\"\")` is replaced with `\"()\"` and `\"()\"` is replaced with `\"(())\"`\
    \ etc. to cover all possible combinations.\n<|/ c |>\n<| c |>\nYes that would\
    \ be a good way to improve this.\n<|/ c |>\n<| a dscore=4 |>\nThe problem is more\
    \ interesting than you might think. The solution I came up with is based around\
    \ looking at what kind of bracket you are looking at, and what is the next char\
    \ after that bracket. If that next character is also a bracket, then it is a pair\
    \ bracket, and if not, it is a non-bracket bracket.\nThis makes use of lazy evaluation,\
    \ so you can run it on any string or any length string, but it will not run on\
    \ large strings or strings where the brackets are out of order.\n<code>\nisBracket\
    \ :: Char -> String -> Bool\nisBracket c s = case compare c s of\n    LT -> False\n\
    \    EQ -> False\n    GT -> True\n    otherwise -> False", "    \n    \"\"\"\n\
    \    correct bracketing based on a bracketing scheme\n    brackets is a string\
    \ of \"<\" and \">\".\n    return true if every opening bracket has a corresponding\
    \ closing bracket.\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \"\"\"", "    \"\"\"\n    correct_bracketing(brackets)\
    \ :: Bool\n    \n    Check whether brackets has all opening brackets preceeded\
    \ by a closing bracket.\n    \n    >>> correct_bracketing(\"<<><>>\")\n    true\n\
    \    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"<>\"\
    )\n    true\n    >>> correct_bracketing(\"<<><\")\n    false\n    >>> correct_bracketing(\"\
    <<\")\n    false\n    \"\"\"\n    function correct_bracketing(brackets::String)::Bool\
    \ where \n        \n        function\n        \n        if brackets.length==1\n\
    \            return false\n        \n        if brackets.startswith(\"<\") &&\
    \ brackets.endswith(\">\")\n            return true\n        \n        if brackets.startswith(\"\
    <\") && brackets.endswith(\"}\")\n            return false\n        \n       \
    \ if brackets.startswith(\"#\") && brackets.endswith(\"}\")\n            return\
    \ true\n        \n        if brackets.startswith(\"#\") && brackets.endswith(\"\
    <\")\n            return false\n        \n        if brackets.startswith(\"#\"\
    ) && brackets.endswith(\"{\")\n            return true\n        \n        if brackets.startswith(\"\
    >\") && brackets.endswith(\">\")\n            return true\n        \n        if\
    \ brackets.startswith(\">\") && brackets.endswith(\"{\")\n            return false\n\
    \        \n        if brackets.startswith(\">\") && brackets.endswith(\"}\")\n\
    \            return true\n        \n        if brackets.startswith(\">\") && brackets.endswith(\"\
    {\")\n            return false\n        \n        if brackets.startswith(\"#\"\
    ) && brackets.endswith(\"<\")\n            return false\n        \n        if\
    \ brackets.startswith(\"#\") && brackets.endswith(\"}\")\n            return false\n\
    \        \n        if brackets.startswith(\"#\") && brackets.endswith(\"{\")\n\
    \            return false\n        \n        if brackets.startswith(\">\") &&\
    \ brackets.endswith(\">\")\n            return false\n        \n        if brackets.startswith(\"\
    >\") && brackets.endswith(\"{\")\n            return false\n        \n       \
    \ if brackets.startswith(\">\") && brackets.endswith(\"}\")\n            return\
    \ false\n        \n        if brackets.startswith(\">\") && brackets.endswith(\"\
    {\")\n            return false\n        \n        if brackets.startswith(\">\"\
    ) && brackets.endswith(\"{\")\n            return false\n        \n        if\
    \ brackets.startswith(\">\") && brackets.endswith(\"{\")\n            return false\n\
    \        \n        if brackets.startswith(\">\") && brackets.endswith(\"{\")\n\
    \            return false\n        \n        if brackets.startswith(\">\") &&\
    \ brackets.endswith(\"{\")\n            return false\n        \n        if brackets.startswith(\"\
    >\") && brackets.endswith(\"{\")\n            return false\n        \n       \
    \ if brackets.startswith(\">\") && brackets.endswith(\"{\")\n", "    bracket_count::Int\
    \ = 0\n    for b in brackets do\n        if b == \"<\" then\n            bracket_count\
    \ := bracket_count + 1\n        elseif b == \">\" then\n            if bracket_count\
    \ > 0 then\n                bracket_count := bracket_count - 1\n            else\n\
    \                return false\n        end\n    end\n    return bracket_count\
    \ == 0\nend\n</cell>\n<text>\nThe main function\nNow let's write a function that\
    \ takes a string and determines whether the input string is valid or not. We've\
    \ already written a function that checks to see if the input string is all lower\
    \ case, but let's reuse that to check other characters:", "\"\"\"\n    correct_bracketing\
    \ (brackets::String)::Bool\n    Check if brackets contains correct bracketing.\n\
    \"\"\"\n    if brackets.length ==1 || brackets.length==0\n        true\n    else\n\
    \        brackets.split(\",\")\n            .map(parse_correct)\n            .filter(valid)\n\
    \            .forall(bracketing::Bool)\n    return bracketing\nend \n</cell>\n\
    <code language=julia-1.0>\ncorrect_bracketing(brackets=\"<,>\")\n</cell>\n<code\
    \ language=julia-1.0>\ncorrect_bracketing(brackets=\"<,><,<><,<,<>\")\n</cell>\n\
    <code language=julia-1.0>", "    if brackets == \"\"\n        true\n    else\n\
    \        brackets\n            |> String.split\n            |> map (fun x -> x\
    \ = \">>>\" || x = \"<<<\" || x = \"<\" || x = \">\" || x = \"<=\")\n        \
    \    |> filter (fun x -> not x)\n            |> map (fun x -> x = \">>>\" || x\
    \ = \"<<<\" || x = \"<\" || x = \">\" || x = \"<=\")\n            |> filter (fun\
    \ x -> not x)\n            |> map (fun x -> x = \">>>\" || x = \"<<<\" || x =\
    \ \"<\" || x = \">\" || x = \"<=\")\n            |> filter (fun x -> not x)\n\
    \            |> map (fun x -> x = \">>>\" || x = \"<<<\" || x = \"<\" || x = \"\
    >\" || x = \"<=\")\n            |> filter (fun x -> not x)\n            |> map\
    \ (fun x -> x = \">>>\" || x = \"<<<\" || x = \"<\" || x = \">\" || x = \"<=\"\
    )\n            |> filter (fun x -> not x)\n            |> map (fun x -> x = \"\
    >>>\" || x = \"<<<\" || x = \"<\" || x = \">\" || x = \"<=\")\n            |>\
    \ filter (fun x -> not x)\n            |> map (fun x -> x = \">>>\" || x = \"\
    <<<\" || x = \"<\" || x = \">\" || x = \"<=\")\n            |> filter (fun x ->\
    \ not x)\n            |> map (fun x -> x = \">>>\" || x = \"<<<\" || x = \"<\"\
    \ || x = \">\" || x = \"<=\")\n            |> filter (fun x -> not x)\n      \
    \      |> map (fun x -> x = \">>>\" || x = \"<<<\" || x = \"<\" || x = \">\" ||\
    \ x = \"<=\")\n            |> filter (fun x -> not x)\n            |> map (fun\
    \ x -> x = \">>>\" || x = \"<<<\" || x = \"<\" || x = \">\" || x = \"<=\")\n \
    \           |> filter (fun x -> not x)\n            |> map (fun x -> x = \">>>\"\
    \ || x = \"<<<\" || x = \"<\" || x = \">\" || x = \"<=\")\n            |> filter\
    \ (fun x -> not x)\n            |> map (fun x -> x = \">>>\" || x = \"<<<\" ||\
    \ x = \"<\" || x = \">\" || x = \"<=\")\n            |> filter (fun x -> not x)\n\
    \            |> map (fun x -> x = \">>>\" || ", "    \"\"\"\n    Corrects bracketing\
    \ to allow for recursive parsing.", "    # ensuring brackets is a string of \"\
    <\" and \">\".\n    let brackets = brackets.replace(\"<\", \"\")\n    let brackets\
    \ = brackets.replace(\">\", \"\")\n    \n    for i in brackets.split(\",\")\n\
    \        if i <> \"\"\n            then false\n            else true\n    end\n\
    end\n</cell>\n<code language=julia-1.6>", "    brackets == \"<\" \nend "]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
