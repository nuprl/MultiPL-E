name: HumanEval_35_max_element
language: jl
prompt: "\"\"\"Return maximum element in the vector.\n    >>> max_element([1, 2, 3])\n\
  \    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n\
  \    \"\"\"\nfunction max_element(l::Vector{Int64})::Int64 \n"
tests: "using Test\n\n@testset begin\n\ncandidate = max_element;\n\t@test(candidate([1,\
  \ 2, 3]) == 3)\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)\n\
  end\n"
completions: ["    if length(l) == 0 \n        return 0 \n    else \n        largest\
    \ = min_element(l)\n        for i in l\n            if i > largest \n        \
    \        largest = i\n        return largest \nend\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nWhat is this supposed to do? Can you explain what your code does?\n<|/\
    \ c |>\n<| c |>\nThis is just an example code, I only tried to explain how to\
    \ do it\n<|/ c |>\n<| c |>\n`max_element` is just an example of what OP can do\
    \ to implement a similar function, hence the name. But your implementation is\
    \ not correct, as you are not returning any error if there are multiple elements\
    \ of the same value in a vector. Try `max_element([1,10,2,10,-10,1,-10,1])`\n\
    <|/ c |>\n<| c |>\nThanks a lot ! I have edited the function accordingly, and\
    \ your code is also correct now. I had added the if condition for empty vector\n\
    <|/ c |>\n<| c |>\nNote that I did not write any code to solve OP's problem, simply\
    \ shown him how to do it, he has already figured it out :) But you are right,\
    \ my answer is uncomplete, as it doesn't take into account multiple same values.\n\
    <|/ c |>\n<| a |>\nMy take on it - in Julia 0.6.2\n<code>", "    if l == Vector{Int64}()\n\
    \        return 0\n    end\n    max_element = maximum(l)\n    for e in l \n  \
    \      if e == max_element \n            return e \n        end\n    end\n   \
    \ return max_element\nend\n</code>\n<|/ a tags=julia,function,arrays |>\n<| a\
    \ tags=julia,function,arrays |>\nI believe that what you are looking for is called\
    \ \"argmax\" in Julia and it exists since 1.6.\nThe function signature is argmin(l::Array{T},\
    \ p::Function) where p is the function used to select the best element.\nExample\
    \ : \n<code>\njulia> argmin(l, [min]) \n3-element Vector{Int64}:\n 0\n 1\n 3\n\
    </code>\n<|/ a dscore=4 |>\n<| c |>\nNote - this doesn't answer the question,\
    \ which asks about arrays.\n<|/ c |>\n<| c |>\nargmin is not implemented for Array\
    \ in Julia. See the link above for the answer.\n<|/ c |>\n<| a tags=julia,function,arrays\
    \ |>\nYou could use Julia 1.6 maximum:\n<code>\njulia> maximum(A)\n5", "    if\
    \ l==[]\n        throw(BoundsError(1))\n    end\n    if l==[Int64]\n        l[1]\n\
    \    end\n    max = l[1]\n    for v in l[2:end]\n        if v > max\n        \
    \    max = v\n        end\n    end\n    return max\nend", "    \"\"\"Return maximum\
    \ element in the vector.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\nmax_element(xs::Vector{Int64})::Int64\
    \ =\n maximum(xs)\n\"\"\"\n    \n    ", "\tlocal v = Int64[]\n\tfor i in l\n\t\
    \tpush!(v,i)\n\tend\n\tmax = v[end]\n\treturn max\nend", "    if length(l)==1\n\
    \        return l[1]\n    else\n        return maximum(l)\n    end\nend", "  \
    \  if length(l) == 0 \n        throw(DimensionMismatch(\"max_element on empty\
    \ vector\"))\n    end\n    if length(l) == 1 \n        return l[1]\n    end\n\
    \    return maximum(l[1:end-1])\nend\n</cell>\n<text>\nSubarrays", "    \n   \
    \ \"\"\"\n    Function that returns maximum element in the vector.\n    >>> max_element([1,\
    \ 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    \    123\n    \"\"\"", "    m = l[1]\n    for i in 2:length(l) \n        if l[i]\
    \ > m \n            m = l[i] \n        end\n    end\n    return m\nend", "\"\"\
    \"Return maximum element in the vector.\n>>> max_element([5, 3, -5, 2, -3, 3,\
    \ 9, 0, 123, 1, -10])\n123\n\"\"\"", "    for el in l\n        return el \n  \
    \  end\n    return 0\nend", "  if l.length == 0\n    return 0\n  end\n  max_element\
    \ = l[1]\n  for v in l[2:end]\n    if v > max_element\n      max_element = v\n\
    \    end\n  end\n  return max_element\nend\n</cell>\n<code language=julia-1.3>\n\
    # Benchmark\nmax_element_bench = @benchmark $max_element($a)\n</cell>\n<text>\n\
    Let's compare the running times of these two functions", "    maxl = -Inf\n  \
    \  for v in l\n        if v < maxl\n            maxl = v\n        end\n    end\n\
    \    return maxl\nend", "\tmaximum = maximum(l) \n\treturn maximum if maximum>0\
    \ \n\treturn 0 \nend", "    i = -1\n    for x in l\n        if x > l[i]\n    \
    \        i += 1\n        end\n    end\n    return l[i]\nend\n</code>\n<|/ a tags=julia,arrays,vector\
    \ |>\n<| a |>\n<code>", "    \n    return reduce(min, l)\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    if iszero(l.last)\n        return l.first\n    else\n\
    \        return maximum(l)\n    end\nend\n\"\"\"Return smallest element in the\
    \ vector.\n    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5,\
    \ 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"", "    max_el = nothing \n\
    \    for el in l do \n        max_el = el \n    end\n    return max_el \nend",
  "  max_element = max(l)\n  return max_element \nend", "    m = -infinity()\n   \
    \ for elt in l \n        if elt > m\n            m = elt\n        end\n    end\n\
    \    return m\nend", "    max_e = -Float64(Inf) # a very large number\n    for\
    \ e in l\n        max_e = max(e, max_e)\n    end\n    return max_e\nend", "  \
    \  max_element = zeros(Int64, size(l))\n    forall i in 1:size(l)\n        max_element[i]\
    \ = max(l[i])\n    end\n    return max_element\nend", "    \"\"\"Compute maximum\
    \ element in the list.\"\"\"\n    \n    if length(l) <= 1\n        return l[1]\n\
    \    \n    min = l[1]\n    for i in l[2:end]\n        if i < min\n           \
    \ min = i\n        end\n    end", "    for element in l\n        if element >\
    \ max_element(l)\n            return element\nend\n</code>\n<|/ a tags=performance,julia\
    \ |>\n<| a |>\nHere's a Julia 1.2 solution for any Vector{T}. It does not need\
    \ to use any for loop.\n<code>\nusing Random\nusing Statistics", "    largest\
    \ = l |> maximum |> eltype(l) \n    \n    return largest \nend", "    m = max_index(l)\n\
    \    return m\nend", "    \n    local max = l[1]\n    for e in l[2:end]\n    \
    \    if e > max \n            max = e \n        end\n    end\n    return max\n\
    end", "    return max_value(0, l)\nend ", "    for index in 1:length(l)\n    \
    \    if l[index] > l[index + 1]\n            return l[index]\n        end\n  \
    \  end\n    return l[1]\nend", "    if l.size <= 0\n        error(\"max_element:\
    \ vector is empty\")\n    end\n    l.max\nend", "    max_elt = l[1]\n    for i\
    \ in 2:length(l) \n        if l[i] > max_elt\n            max_elt = l[i]\n   \
    \     end\n    end\n    return max_elt\nend", "    maximum = Inf \n    for i in\
    \ l\n        maximum = maximum >  i ? maximum : i\n    end\n    return maximum\n\
    end", "    maximum = -inf \n    for e in l do \n        if e > maximum then \n\
    \            maximum = e \n        end\n    end\n    return maximum\nend\n</cell>\n\
    <code language=julia-1.5>", "    max = -Inf \n    for i in l \n        if i >\
    \ max \n            max = i \n        end \n    end \n    return max\nend \n</cell>\n\
    <text>\nNow test the function:", "    maxval = max(l)\n    idx = findfirst(isequal(maxval),\
    \ l)\n    if idx == -1 \n        println(idx == -1)\n        println(l)\n    \
    \    println(maxval)\n        throw(ArgumentError(\"max_element() can't find max\"\
    ))\n    end\n    return maxval\nend\n</cell>\n<code language=julia-1.5>", "  \
    \  if length(l)==0 \n        throw(ArgumentError(\"Empty vector\")) \n    else\
    \ \n        return maximum(l)\n    end\nend", "    idx::Int64 = findfirst(x ->\
    \ x > 0, l) \n    if idx==0 \n        error(\"max_element expects a non-empty\
    \ vector\")\n    else\n        idx \n    end\nend\n</code>\n<|/ a tags=julia |>\n\
    <| a dscore=0 |>\nHere's a version that handles empty arrays:\n<code>", "    m\
    \ = max(l)\n    return m \nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\n\
    Another option:\n<code>\nmax_element(Int64[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    </code>\n<|/ a tags=julia |>\n<| a |>\nAnother option:\n<code>\njulia> v = [5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]\n5-element Vector{Int64}:\n  5\n  3\n -5\n\
    \  2\n -3\n  3\n  9\n  0\n 123\n 1\n-10", "    if l[1]>l[2] then\n        return\
    \ l[1]\n    else\n        return l[2]\n    end\nend", "    return argmax(l)\n\
    end", "    l = sorted(l)\n    maximum = l[1]\n    for i in 2:length(l)\n     \
    \   maximum = maximum < l[i] ? maximum : l[i]\n    end\n    return maximum\nend\n\
    </cell>\n<code language=julia-1.0>\nmax_element([3, 6, 9, 14, 3])\n</cell>\n<text>\n\
    Part 3 - Vectorisation\nIn this part we perform some vectorisation experiments\
    \ on our code to see what kind of speed-up is possible.", "\tfor i in eachindex(l)\
    \ \n\t\tif l[i]>l[argmax(l)] \n\t\t\tl[i] \n\t\telse \n\t\t\tl[argmax(l)] \n\t\
    \tend \n\tend \nend", "    for el in l \n        if el > length(l)\n         \
    \   length(l)\n        else \n            el \n    end\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| c |>\nThis won't work if the vector is empty, you should `if !isempty(l)`,\
    \ otherwise it will return 0.\n<|/ c |>\n<| c |>\nThe `isempty` condition should\
    \ be placed before the `for` loop, and you should add some brackets around the\
    \ else branch of your `for` loop to improve the readability of your code (and\
    \ it would be better to replace the `length` call with a variable `len` and the\
    \ `el > len` condition with a variable `el > len`)\n<|/ c |>\n<| c |>\nI have\
    \ not tested this code, but I think it's possible to make it more efficient by\
    \ using the `find` function.\n<|/ c |>\n<| c |>\nI actually think that `find`\
    \ is the best solution. The only problem with the other solutions is that `find`\
    \ will search from the start of the vector, while `pop` will search from the end.\
    \ So if the vector is too short, `find` may fail to find the element. On the other\
    \ hand, `pop` will return the element if the vector is too short.\n<|/ c |>\n\
    <| a tags=julia |>\nA slight variant on Laurent's solution, using find and pop:\n\
    <code>", "    largest=l[1]\n    \n    for i in l:\n        if i>largest\n    \
    \        largest=i\n        end\n    end\n    return largest\nend", "    for i\
    \ in l\n        return i if i > max[i] else max[i]\nend\n    return max\nend",
  "    if length(l) == 0 \n        return 0 \n    max =  l[1]\n    for i in 2:length(l)\
    \ \n        if l[i] > max \n            max = l[i] \n        end \n    end \n\
    \    return max \nend \n</code>\n<|/ a dscore=1 |>\n<| a |>\nYou can also use\
    \ reduce to find the max: \n<code>\nreduce(max, [4, 2, 1])\n</code>\n<|/ a tags=julia\
    \ dscore=0 |>\n<| a dscore=0 |>\nHere is a more optimized version using max.\n\
    <code>", "    if length(l) <= 1 \n        return l[1]\n    else \n        \n \
    \       maximum = l[1]\n        for i in l[2:end-1]\n            if i>maximum\n\
    \                maximum = i\n            end\n        end\n        return maximum\n\
    \    end\nend", "    return l.max() \nend\n</code>\n<|/ a tags=julia |>\n<| a\
    \ |>\nHere is another way to do this using the Base.find function:\n<code>", " \
    \   l = sort(l)\n    local largest = -1\n    local i = 0\n    local sum = 0\n\
    \    while i < length(l)\n        sum += l[i]\n        if largest == -1 || sum\
    \ > largest\n            largest = sum\n        else\n            sum = 0\n  \
    \      end\n        i += 1\n    end\n    return largest\nend\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"Return cumulative product of numbers in vector\n    >>> cumulative_product([1,\
    \ 2, 3])\n    6\n    >>> cumulative_product([1, 1, 2, 2, 3, 3])\n    60\n    >>>\
    \ cumulative_product([-10, -2, -3])\n    60\n    \"\"\"", "    if l == NIL\n \
    \       return -1\n    el = head (l)\n    if el > 0\n        return el\n    else\n\
    \        return max_element(tail(l)) + 1 \nend", "    maximum = maximum_in(l)\
    \ \n    minimum = minimum_in(l) \n    return maximum if maximum > minimum else\
    \ minimum\nend", "    for i in l\n    return maxi\n    end \n    ", "   \n   return\
    \ max_value(l)\nend", "     if length(l) == 0 \n     return 0  \n end \nreturn\
    \ max(l)\nend \n\"\"\"\n</code>\n<|/ a tags=julia,optimization |>\n<| c |>\nA\
    \ small remark: I think the code should use return `l[1]` instead of `l`.\n<|/\
    \ c |>\n<| c |>\nThe second function will work as well if called like `max_element(0:n)`.\n\
    <|/ c |>\n<| a dscore=2 |>\nHere's a version which works on arrays as well as\
    \ on vectors:\n<code>", "    max = -10000\n    for n in l\n        if n > max\n\
    \            max = n\n        end\n    end\n    return max\nend\n</code>\n<|/\
    \ a |>\n<| a tags=julia,max,find-occurrences |>\nIf you have an ordered vector,\
    \ you could try searching the last position (via searchsorted or searchind should\
    \ be faster than findindex), which can be done in O(logn). \n<code>\njulia> sort(x)\n\
    6-element Array{Int64,1}:\n 2\n 3\n 7\n 9\n10\n12", "    if length(l) == 0 \n\
    \        error(\"empty vector\")\n    end\n    max = l[1]\n    for i in 2:length(l)\
    \ \n        if l[i] > max \n            max = l[i] \n        end\n    end\n  \
    \  return max\nend", "\tlargest = max_elem(l)\n\treturn largest\nend", "    if\
    \ l.length() == 0\n        throw(ArgumentError(\"Vector is empty\"))\n    end",
  "    maximum = l[1]\n    for i in l[2:end]\n        maximum = maximum < i ? maximum\
    \ : i\n    end\n    return maximum\nend", "    if l == []\n        return -1\n\
    \    else\n        return l[1]\n    end\nend", "    return Int64(max(l))\nend",
  "    max_elem =  maximum(l)\n    if max_elem <0\n        error(\"maximum element\
    \ cannot be negative\")\n    end\n    return max_elem\nend\n</cell>\n<code language=julia-1.0>\n\
    max_element([1, 2, 3])\n</cell>\n<code language=julia-1.0>\nmax_element([5, 3,\
    \ -5, 2, -3, 3, 9, 0, 123, 1, -10])\n</cell>\n<text>\nExercise 3\nImplement a\
    \ function that sums up a vector element-wise.", "    return maximum(l)\nend\n\
    \"\"\"Return minimum element in the vector.\n    >>> min_element([1, 2, 3])\n\
    \    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n\
    \    \"\"\"", "\"\"\"\nReturn the maximum element in a vector.\n\"\"\"\nmaximum\
    \ = max_element", "    return minimum(l)\nend\n</cell>\n<code language=julia-0.5>\n\
    \"\"\"Return minimum element in the vector.\n    >>> min_element([1, 2, 3])\n\
    \    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n\
    \    \"\"\"", "    return max(l)\nend", "    if length(l)==0 \n        throw(ArgumentError(\"\
    empty vector\"))\n    end", "    if length(l) == 0 \n        throw(ArgumentError(\"\
    Vector is empty.\"))\n    end\n    largest = minimum(l)\n    for i in l\n    \
    \    if i > largest\n            largest = i\n        end\n    end\n    return\
    \ largest\nend\n    ", "    \"\"\"return maximum element in the vector\"\"\"\n\
    \    \n    return l.min()\nend \n</cell>\n<text>\nWe can also use .max to find\
    \ minimum element. These two functions are the same.", "    max_value = Int.(-Inf)\n\
    \    for element in l \n        if element > max_value \n            max_value\
    \ = element \n        end\n    end\n    return max_value\nend", "\tmaximum=l[1]\n\
    \tfor ii in 2:length(l)\n\t\tmaximum=maximum>l[ii] ? maximum : l[ii]\n\tend\n\t\
    return maximum\nend", "    local i\n    i = 0\n    while i < length(l)\n     \
    \   if l[i] > l[i+1]\n            break\n        end\n        i = i + 1\n    end\n\
    \    return l[i]\nend", "        maximum = maximum(l)\n        return maximum\n\
    end", "    max_value = 0\n    max_value = l[1] if l[1] <= max_value \n    max_value\
    \ = l[2] if l[2] <= max_value\n    max_value = l[3] if l[3] <= max_value\n   \
    \ return max_value \nend", "    result = Inf \n    for v in l \n        if v >\
    \ result \n            result = v \n        end \n    end \n    \n    return result\n\
    end \n</cell>\n<text>\n5.5.1 Vector Addition", "    return maximum.(l)\nend",
  "    maximum = l[1]\n    for i in l[2:end]\n        if i > maximum\n           \
    \ maximum = i\n        end\n    end\n    return maximum\nend", " \n    maxElement=\
    \ max(l)\n    return maxElement", "     \"\"\"Return the maximum element in the\
    \ vector.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5,\
    \ 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"", "    return max(l) \nend ",
  "    if iszero(l.last)\n        return 0\n    return l.last\nend\n</code>\n<|/ a\
    \ |>\n<| a dscore=2 |>\nThis is what I did (in Julia) and it worked for me. First\
    \ of all I create an empty matrix:\n<code>\nA=Array{Int}(undef,n,m)\n</code>\n\
    then I populate it by reading from a file\n<code>\nfor i in 1:n\n   for j in 1:m\n\
    \      A[i,j]=Float64.readline(fh)\n   end\nend\n</code>\nthen I calculate the\
    \ maximum value by\n<code>\nmaximum(A)\n</code>\n<|/ a tags=julia,algorithm,vector\
    \ |>\n<| a |>\nIf you don't have any additional restrictions than a vector, why\
    \ not use the array package?\n<code>\njulia> using Statistics, Arrays", "    minimum(l)\n\
    end\n</cell>\n<text>\n\u0422\u0435\u043F\u0435\u0440\u044C \u0441\u043C\u043E\u0442\
    \u0440\u0438\u043C \u0435\u0435 \u0432\u0430\u0440\u0438\u0430\u043D\u0442\u044B\
    \ \u0441 \u0442\u043E\u0447\u043A\u043E\u0439 \u0438\u0437 \u043F\u0440\u0438\u043C\
    \u0435\u0440\u0430:", "    m = max_value(l)\n    for x in l\n        if x < m\n\
    \            m = x\n        end\n    end\n    m\nend", "    for i in l\n     \
    \   if i > max(l)\n            return i\n        end\n    end\nend\n\"\"\"Return\
    \ maximum element in the vector.\n    >>> max_element([1, 2, 3])\n    3\n    >>>\
    \ max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"",
  "    sort(l)\n    return l[end]\nend", "    max_length = Int.(l.max())\n    for\
    \ elt in l\n        if elt > max_length\n            max_length = elt\n      \
    \  end\n    end\n    return max_length\nend\n</cell>\n<text>\nThe following cell\
    \ tests max_element().", "    if length(l) == 0 \n        throw(ArgumentError(\"\
    The length is zero\"))\n    end\n    return l[end]\nend", "    if length(l) ==\
    \ 0\n        return -1\n    end\n    max_value = l[1]\n    for i = 2:length(l)\n\
    \        if l[i] > max_value\n            max_value = l[i]\n        end\n    end\n\
    \    return max_value\nend\n</code>\n<|/ a tags=julia dscore=1 |>\n<| a tags=julia\
    \ |>\nFor maximum value in a vector:\n<code>\njulia> x = rand(10)\n10-element\
    \ Array{Float64,1}:\n 0.8824773\n 0.8673215\n 0.9265467\n 0.9787333\n 0.9914504\n\
    \ 0.5454661\n 0.9664624\n 0.8782483\n 0.9085543\n 0.7660476", "    l.sort()\n\
    \    \n    if length(l)==0\n        throw(ArgumentError(\"Cannot find max element\
    \ of empty vector\"))\n    else\n        head=l[1]\n        for i in 2:length(l)\n\
    \            if head>l[i]\n                head=l[i]\n            end\n      \
    \  end\n    end\n    return head\nend", "    if l[1] > l[2]\n        return l[1]\n\
    \    else return l[2]\n    end\nend\n</cell>\n<code language=julia-0.6>", "  \
    \  s = 0\n    for x in l\n        s = max(x,s)\n    return s\nend\n</cell>\n<code\
    \ language=julia-1.6>", "    l.sort()\n    return l[length(l)-1]\nend\n</cell>\n\
    <code language=julia-1.1>\n\"\"\"Return minimum element in the vector.\n    >>>\
    \ min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0,\
    \ 123, 1, -10])\n    -10\n    \"\"\"", "    max_e = l[1]\n    for e in l\n   \
    \     if e > max_e\n            max_e = e\n        end\n    end\n    return max_e\n\
    end", "    if l.length == 1\n        return l[1]\n    end\n    minimum = max_element(l.first)\n\
    \    maximum = minimum\n    for i in l.second:\n        if i < minimum\n     \
    \       minimum = i\n        end\n        if i > maximum\n            maximum\
    \ = i\n        end\n    end\n    return maximum\nend\n</cell>\n<code language=julia-1.0>",
  "     return maximum(l) \nend \n</code>\n<|/ a dscore=3 tags=julia,arrays,function\
    \ |>\n<| c |>\nThis is much better than my answer, as it uses the Julia standard\
    \ library.\n<|/ c |>\n<| c |>\nI appreciate your efforts to help. But your solution\
    \ is not correct. `max_element` should return `Int64`, and the output of your\
    \ code is `Int64`. I suggest you edit your answer and fix it.\n<|/ c |>\n<| a\
    \ |>\nAs mentioned in the comments, the solution below works, but it's fairly\
    \ clunky. I think this could be improved by moving the if/else logic out of the\
    \ function and into the main program, but I haven't gotten around to it yet.\n\
    <code>", "    max_element (l) \nend \n\"\"\"Return minimum element in the vector.\n\
    \    >>> max_element([1, 2, 3])\n    1\n    >>> max_element([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10])\n    -100\n    \"\"\"", "    m = -Inf\n    count = 0\n\
    \    for k in l\n        if k < m\n            m = k\n            count += 1\n\
    \        end\n    end\n    return m\nend\n</cell>\n<code language=julia-1.1>",
  "    if iszero(l)\n        return 0\n    if l == []\n        return l\n    if isinteger(last(l))\n\
    \        return last(l)\n    return maximum(l)\nend\n</code>\n<|/ a tags=julia,arrays\
    \ |>\n<| c |>\n`maximum(l)` returns the maximum of all elements. What you need\
    \ is the minimum. Change the first `if` to: `if iszero(l)` and remove the last\
    \ `else` clause.\n<|/ c |>\n<| a tags=julia,arrays |>\nAs of Julia v1.0 (June\
    \ 2016), this could be solved using the maximum, minimum functions:\n<code>\n\
    julia> maximum(vec([1,2,3]))\n3", "    max = l[1]\n    for i in l[2:end]\n   \
    \     if i > max\n            max = i\n        end\n    end\n    max\nend\n</code>\n\
    <|/ a tags=julia,function,arrays,for-loop dscore=1 |>\n<| a dscore=0 |>\nHere\
    \ is an implementation in pure Julia which should scale better than other solutions\
    \ based on sorting.\n<code>", "   \n    if length(l) == 0\n        return -1\n\
    \    end", "    for i=1:length(l)\n        if l[i]>l[i-1] \n            return\
    \ l[i]\n        end\n    end\n    return l[0]\nend", "  if l.length == 0 \n  \
    \  return 0 \n  else \n    return l[argmax(l)]\nend\n</code>\n<|/ a tags=julia,arrays\
    \ dscore=0 |>\n<| a |>\nIn Julia 1.6.1, you can write max_element as this one\
    \ liner:\n<code>\nmax_element = maximum.(l)\n</code>\n<|/ a dscore=0 tags=julia,arrays\
    \ |>\n<| a dscore=0 |>\nIn Julia 1.7, I needed to write this as \n<code>\nmax_element\
    \ = maximum(l)\n</code>\nas in previous answers, maximum(vector) seems to not\
    \ work anymore. This way it works on both arrays and vectors.\n<|/ a tags=julia,arrays\
    \ |>\n<| c |>\nThis does not seem to work in julia 1.7.1\n<|/ c |>\n<| a dscore=0\
    \ tags=julia,arrays |>\nIn Julia 1.4 this works for me:\n<code>", "    maximum\
    \ = maximum(l) \n    for i in length(l):\n        if maximum < l[i] \n       \
    \     maximum = l[i] \n        end \n    return maximum \nend ", "  \"\"\"Return\
    \ maximum element in the vector.\n    >>> max_element([1, 2, 3])\n    3\n    >>>\
    \ max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n  \"\"\"\n  minimum\
    \ = minimum(l)\n  return maximum(l)\nend", "\tmax_ele=0\n\tfor x in l\n\t    if\
    \ x>max_ele\n\t    max_ele=x\n\t    end\n\tend\n\treturn max_ele\nend", "    for\
    \ i in 1:length(l)\n        if l[i] > max_element(l)\n            max_element(l)\n\
    \        end\n    end\n    return max_element(l)\nend", "    if length(l) == 0\
    \ \n        throw(ArgumentError(\"Vector length must be non-zero\"))\n    else\n\
    \        return maximum(l) \n    end\nend\n</cell>\n<text>\nThe max_element()\
    \ function is provided in the first cell, and a docstring is provided in the second\
    \ cell of that notebook.", "    if l == []\n        return -1\n    elseif length(l)\
    \ == 1 \n        return l[1]\n    else\n        return maximum(l)\n    end\nend",
  "    if length(l) == 0 \n        return 0 \n    maximum = first(l) \n    for i in\
    \ l \n        if i > maximum \n            maximum = i \nend ", "    if l == []\n\
    \        throw(ArgumentError(\"Empty vector\"))\n    end\n    min = max_element_index(l)\n\
    \    max = l[min]\n    for index in range(min+1,length(l)-1) \n        if l[index]\
    \ > max \n            max = l[index]\n        end\n    end\n    return max\nend\n\
    </cell>\n<code language=julia-1.1>", "    if length(l) == 0 \n        return 0\n\
    \    else\n        return l[argmax(l)]\n    end\nend", "    local m = l[1]\n \
    \   for v in l[2:end] \n        if v > m \n            m = v \n        end \n\
    \    end \n    return m \nend \nmax_element(v::Vector{Int64}) = max_element(Int64[].(v))\n\
    </cell>\n<cell>", "    if length(l) == 0 \n        throw(ArgumentError(\"max_element:\
    \ empty vector\"))\n    else \n        maximum = l[1]\n        for i in 2:length(l)\n\
    \            if l[i] > maximum\n                maximum = l[i]\n            end\n\
    \        end\n        return maximum\n    end\nend", "    if length(l) == 0 \n\
    \        error(\"max_element() called on empty vector\")\n    end\n    return\
    \ maximum(l)\nend", "    return maximum(l) + maximum(dropdims(l, 2)) \nend", " \
    \   l[argmax(l)]\nend\n</code>\n<|/ a dscore=4 |>\n<| a |>\nIn Julia 1.1 you can\
    \ use maximum.\n<code>\nmaximum([5,3,-5,2,-3,3,9,0,123,1])\n</code>\n<|/ a tags=julia\
    \ dscore=3 |>\n<| a tags=julia |>\n<code>\nmaximum(collect(1:10))\n</code>\n<|/\
    \ a dscore=3 |>\n<| c |>\nThis returns `Int64`, not `Int`.\n<|/ c |>\n<| c |>\n\
    Note that this can be a bit slow, because it has to convert the array to `Int64`\
    \ before it can apply the function `max`.\n<|/ c |>\n<| c |>\nThis is faster with\
    \ small arrays but slower for large arrays with many entries (for me on `1.1.0`).\n\
    <|/ c |>\n<| a dscore=3 tags=julia |>\nIf you have an array called arr you can\
    \ use maximum in two different ways:\n<code>\nmaximum(arr)", "    pos = argmax_element(l)\n\
    \    if pos[end]==end\n        return l[end]\n    else\n        return l[pos[end]]\n\
    \    end\nend", "    i = Int64(1)\n    for x in l\n        i = max i, x\n    end\n\
    \    return i\nend", "\tresult = 0\n\tfor i in l \n\t\tif i > result \n\t\t\t\
    result = i\n\t\tend\n\tend\n\treturn result\nend", "    \n    max = l[1]\n   \
    \ for i in 2:length(l)\n        if l[i] > max\n            max = l[i]\n      \
    \  end\n    end\n    return max\nend\n</cell>\n<text>\nNow let's check the performance\
    \ of our max_element function. We will test it with several different length vectors.",
  "    maximum = max_value(l)\n    max_element = l[maximum][1]\n    return max_element\n\
    end", "    if l.length == 1\n        return l[0]\n    else\n        max = l[1]\n\
    \        for i in 2..l.length\n            if l[i] > max\n                max\
    \ = l[i]\n            end\n        end\n        return max\n    end\nend", " \
    \   return argmax(l)\nend", "  m=0\n  for e in l \n    if e > m \n      m=e \n\
    \    end\n  end\n  return m\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\nThis is\
    \ one of the most basic operations in Julia language: sum. So, using this, you\
    \ can get the sum of the elements stored in any vector.\nExample:\n<code>\njulia>\
    \ using Random", "    \"\"\"\n    Find the maximum element in the given vector.\n\
    \    >>> max_element(1:10)\n    10\n    \"\"\"", "    l = sort(l)\n    return\
    \ l[end]\nend\n</cell>\n<code language=julia-1.4>\nusing BenchmarkTools\n@btime\
    \ max_element($l)\n</cell>\n<text>\nThe first method uses sort, which is an O(n\
    \ logn) operation when the array is sorted. On the other hand, the second method\
    \ uses linear indexing, which is O(n).", "    max = l[1] \n    for i in l[2:length(l)]\
    \ \n        if i > max \n            max = i \n        end \n    end \n    return\
    \ max \nend", "    if (length(l)>0)\n        max_el = l[1]\n        for element\
    \ in l[2:end]\n            if element > max_el\n                max_el = element\n\
    \            end\n        end\n    else\n        max_el = -1\n    end\n    return\
    \ max_el\nend\n</cell>\n<code language=julia-0.6>", "    pos = 0\n    val = l[0]\n\
    \    for i=1:length(l) \n        if val > l[i] \n            val = l[i]\n    \
    \        pos = i \n        end\n    end\n    return val\nend", "  maximum = l[1]\n\
    \  for element in l[2:end]\n    maximum = maximum > element ? maximum : element\n\
    \  end\n  maximum\nend\n</cell>\n<cell>", "    \"\"\"\n    Return maximum element\
    \ in the vector.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    maximum = zeros(Float64,\
    \ length(l))\n    for i in 1:length(l)\n        maximum[i] = max(maximum[i], l[i])\n\
    \    end\n    return maximum\nend\n</cell>\n<code language=julia-1.5>\n# export\n\
    \"\"\"\n    sum_element(x::Vector{Int64})", "    if length(l) == 0\n        throw(DomainError,\
    \ (\n            \"Function max_element: Cannot find the maximum value of an empty\
    \ vector\"))\n    end\n    return l.max()\nend\n</cell>\n<text>\nNote that we\
    \ can also just use maximum(l)!", "    if l.length == 1\n        return l[0]\n\
    \    return maximum(l)\nend\n</cell>\n<code language=julia-1.3>\n@doc max_element\n\
    </cell>\n<text>\nReturn maximum element of vector with given length", "    if\
    \ iszero(l)\n        return -1\n    end\n    max_idx = argmax(l)\n    max_val\
    \ = l[max_idx]\n    for i in max_idx:\n        if l[i] > max_val\n           \
    \ max_val = l[i]\n        end\n    end\n    return max_val\nend", "    for elem\
    \ in l\n        return elem\n    end\nend\nmax_element(v::Vector{Int}) = maximum(maximum(v,\
    \ 0))\nmax_element(v::Vector) = max_element(vec(v))\nmax_element(v::Int) = max_element(vec(v))\n\
    max_element(v::Real) = max_element(vec(v))\nmax_element(v::Integer) = max_element(vec(v))\n\
    max_element(v::Union{Int64, Float64}) = max_element(vec(v))\nmax_element(v::Array{Int})\
    \ = max_element(vec(v))\nmax_element(v::Vector{Int64}) = max_element(vec(v))\n\
    max_element(v::Array{Float64}) = max_element(vec(v))\nmax_element(v::Array{Int})\
    \ = max_element(vec(v))\nmax_element(v::Array{Int64}) = max_element(vec(v))\n\
    max_element(v::Array{Integer}) = max_element(vec(v))\nmax_element(v::Array{Union{Int64,\
    \ Float64}}) = max_element(vec(v))", "    maximum = 0\n    for x in l\n      \
    \  maximum = x if x > maximum else maximum\n    end\n    return maximum\nend\n\
    </cell>\n<code language=julia-1.5>\nmax_element([1, 2, 3])\n</cell>\n<text>\n\
    3. \uC5B4\uB290 \uAC12\uC744 \uBC1B\uC558\uC744 \uB54C, \uC5B4\uB290 \uAC12\uC774\
    \ \uC5B4\uB290 \uAC12\uC778\uC9C0 \uAC80\uC0AC\uD558\uB294 \uD568\uC218", "  \
    \  max_length = 0\n    for i in l\n        if i > max_length\n            max_length\
    \ = i\n        end\n    end\n    return max_length\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Return element with minimum absolute value.\n    >>> max_element([1, 2,\
    \ 3])\n    1\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n \
    \   -3\n    \"\"\"", "    return maximum(l) \nend", "    maximum = 0\n    for\
    \ i in l\n        if i > maximum\n            maximum = i\n        end\n    end\n\
    \    return maximum\nend\n</cell>\n<code language=julia-1.5>", "    v = copy(l)\n\
    \    for i in eachindex(v)\n        if v[i] > maximum(v)\n            maximum(v)=v[i]\n\
    \        end\n    end\n    return maximum(v)\nend\n</code>\n<|/ a |>\n<| c |>\n\
    This does not really answer the question though.\n<|/ c |>\n<| c |>\nIt answers\
    \ the question by providing the code. This is the reason why I posted this as\
    \ an answer.\n<|/ c |>\n<| c |>\nWhat about multiple maxima? Say, [3, 3, 3, 3]?\n\
    <|/ c |>\n<| a tags=julia |>\nHere's an answer with benchmark results for all\
    \ the solutions proposed here: https://stackoverflow.com/a/59258787/1744770\n\
    <code>\nusing BenchmarkTools", "    for v in l\n        if v > max\n         \
    \   max = v\n        end\n    end\n    max\nend", "    largest = maximum(l) \n\
    \    for x in l \n        if x == largest \n            continue \n        largest\
    \ := x \n    return largest \nend", "    return maximum(l) \nend", "    if length(l)\
    \ == 0 \n        return 0 \n    elseif length(l) == 1 \n        return l[1]\n\
    \    elseif length(l) == 2 \n        return max(l[1], l[2]) \n    else \n    \
    \    return max(max_element(subseq(l, 1, end-1)), max_element(subseq(l, 2, end)))\
    \ \nend\n\"\"\"Return minimum element in the vector.\n    >>> max_element([1,\
    \ 2, 3])\n    1\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    \    -10\n    \"\"\"", "    return reduce(max, l)\nend", "    local result=0\n\
    \    for i=1:length(l)\n        if l[i]>result\n            result=l[i]\n    \
    \    end\n    end\n    return result\nend\n</code>\n<|/ a dscore=0 tags=julia\
    \ |>\n<| c |>\nThis approach is slower than the other solutions that use `.< .`\
    \ since they all have to iterate the entire vector to find the maximum value,\
    \ when you can stop early if you already found a larger value.\n<|/ c |>\n<| c\
    \ |>\nI think this is also slower in practice than my answer, because the vectorized\
    \ approach doesn't require the full vector to be stored at once which means it\
    \ doesn't need to allocate memory for the entire vector at once. The accepted\
    \ answer has this advantage since `findmax` is written in pure Julia so it doesn't\
    \ require allocating the whole vector to store just the maximum value. Mine uses\
    \ looping which could also be faster in certain circumstances but I've not benchmarked\
    \ it.\n<|/ c |>\n<| a dscore=0 |>\nYou can use findmax from Statistics\n<code>\n\
    julia> using Statistics\njulia> findmax(vec(rand(10^6)))\n11", "    return max(l)\n\
    end\n\"\"\"\nReturn the median value of the vector.\n>>> median([10, 5, 3, 15,\
    \ 10, 25, 7, 8])\n10\n\"\"\"", "    z = max(l)\n    if z == Inf || z == -Inf\n\
    \        return z\n    end\n    return z\nend", "    if (length(l)==1)\n     \
    \   return l[1]\n    elseif (length(l)==0)\n        return 0\n    end\n    maximum\
    \ = l[1]\n    for i in 2:length(l)\n        if (maximum < l[i])\n            maximum\
    \ = l[i]\n        end\n    end\n    return maximum\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThanks for the answer but I am still confused about the purpose\
    \ of using types. Can you please explain it a little more to me?\n<|/ c |>\n<|\
    \ c |>\nI updated my answer with a way to define function which return maximum\
    \ element from any vector without using built-in `max_element` function. Hope\
    \ it helps.\n<|/ c |>\n<| c |>\nThanks again. I know it's kinda a newbie question\
    \ but just one last question, is the \"Int64\" in your function definition is\
    \ necessary? I got this error message after removing the \"Int64\" part from the\
    \ function definition: \nERROR: LoadError: MethodError: no method matching max_element(::Int64)\n\
    <|/ c |>\n<| c |>\nSure, it's necessary. This function is for finding maximum\
    \ element from vector. I used Int64 type because I guess you need a numeric vector.\
    \ If this doesn't work, can you provide an example of your vector? It would be\
    \ better to understand the problem.\n<|/ c |>\n<| c |>\nSorry for being a little\
    \ confusing, but I got this vector: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10] from\
    \ your answer. My bad, I forgot to mention that I have to find max element in\
    \ the vector regardless of the type it's in. Do you know what should I do to solve\
    \ this?\n<|/ c |>\n<| a tags=julia,max,function dscore=0 |>\nIf you have a vector\
    \ as in your example,\n<code>\nv = [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]\n</code>\n\
    then\n<code>\nmax(v)\n</code>\nwill give you\n<code>\n1231\n</code>\n<|/ a |>\n\
    <| c |>\nThanks for the answer but I am still confused about the purpose of using\
    \ types. Can you please explain it a little more to me?\n<|/ c |>\n<| a dscore=0\
    \ |>\nThe above answers all show different ways to find the maximum element of\
    \ a vector, so I thought I'd add another answer. The key point is that the built-in\
    \ max() function returns the maximum element of a vector, regardless of its type:\n\
    <code>\njulia> max([0, 1])\n1", "    if max(l) == -Inf\n        return l[1]\n\
    \    else \n        return max(l)\n    end\nend\n</code>\n<|/ a tags=max,julia\
    \ |>\n<| a |>\nA more efficient solution:\n<code>", "    if l[1] == 0\n      \
    \  return l[0]\n    else\n        max_element = l[1]\n        for j in l[2:end]\n\
    \            if j < max_element\n                max_element = j\n           \
    \ end\n        end\n        return max_element\n    end\nend\n\"\"\"\nReturn minimum\
    \ element in the vector.\n    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"", "    for x in l\
    \ \n        if x < min_element(x) else x \nend \n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nCan you elaborate on the benefits of your solution? I don't understand\
    \ why you chose `map`, `filter`, or `reduce` for this task.\n<|/ c |>\n<| c |>\n\
    map , filter and reduce are used for parallel programming in Julia. You can read\
    \ more about it here: https://julialang.org/blog/2017/08/parallel-programming-in-julia/\n\
    <|/ c |>\n<| c |>\nAlso note that this is not efficient as you are evaluating\
    \ `min_element` n times where n is the length of `l`. You can do it in linear\
    \ time by finding the minimum element in `l` once and using that value `min_element`\
    \ times to get the minimum element in `l` like this: `min(min_element(l), min_element(l))`\
    \ .\n<|/ c |>\n<| a dscore=0 |>\nSince you are looking for minimum element in\
    \ the vector you can use minimum and maximum. \nSo something like this would work:\n\
    <code>\nminimum(vec)\n</code>\nIf you would like to get minimum and maximum element\
    \ by some criteria you can implement your own function using for loops.\n<|/ a\
    \ tags=julia |>\n<| c |>\nOP wants *the minimum element in the vector*, not the\
    \ minimum.\n<|/ c |>\n<| a tags=julia |>\nHere's a more efficient solution using\
    \ map and reduce:\n<code>\njulia> function minmax(r::Vector{Int}, f::Function)\n\
    \           m = minimum(r)\n           return m, maximum(r, m)\n       end", " \
    \   ma = maximum.(l)\n    ma < 0 ? return ma : return ma[1]\nend", "    if l.length()\
    \ == 0\n        throw(ArgumentError(\"Vector must have atleast one element\"))\n\
    \    else\n        return maximum(l)\n    end\nend", "    sum = 0\n    for i in\
    \ l\n        if sum < i\n            sum = i\n        end\n    end\n    sum\n\
    end\n</code>\nThis was about 10x faster than the accepted answer in my case.\n\
    <|/ a tags=julia,performance dscore=2 |>\n<| c |>\nYou can drop the if statement\
    \ by just doing `for i in l; sum += i; end`, since `+=` returns the sum (so you\
    \ don't have any extra work to do).\n<|/ c |>\n<| c |>\nThis is much faster than's\
    \ answer (4x on my machine). Also, if you are working with large vectors you can\
    \ probably speed it up a bit more by doing `for i in eachindex(l)`. Not sure if\
    \ this makes a big difference, but maybe it makes a bit more sense.\n<|/ c |>\n\
    <| c |>\nYeah, I did some benchmarking. I was curious about it too. I noticed\
    \ that even though `+=` returns the sum, `sum` is a mutable variable. So, in my\
    \ case I needed to also do `sum .= i`, to update the variable that was returned\
    \ to `sum`. I didn't actually measure this, but I believe this was the reason\
    \ why `+=` was so slow (although this is probably not true). In any case, `sum\
    \ .= i` was definitely a big improvement and I didn't need to do `eachindex`.\n\
    <|/ c |>\n<| a tags=julia,performance |>\nThis is faster than both of those answers:\n\
    <code>", "    return max( l )\nend", "\t\n\t\n    if length(l) == 0 \n    \treturn\
    \ 0\n    end\n    \n    if l.size == 1 \n    \treturn l[1]\n    end\n\t\n\t\n\
    \    if l.size >  length(l)\n    \tmax_element = l.[1]\n    \tfor i in l.[2:end]\n\
    \    \t    if i > max_element \n    \t\tmax_element = i\n    \t\t\n    \tend\n\
    \    \t\n    else \n    \tmax_element = l.[1]\n    \tfor i in l.[2:end]\n    \t\
    \    if i <= max_element \n    \t\tmax_element = i\n    \t\t\n    \tend\n    end\n\
    \    \n    \n    return max_element\n    \nend", "    max_value_idx = argmax(l)\n\
    \    return l[max_value_idx]\nend", "    largest = 0\n    for i in l\n       \
    \ if i > largest\n            largest = i\n        end\n    end\n    return largest\n\
    end", "     for i \u2208 l \n         if i > maxval \n             maxval = i\
    \ \n         end\n     end\n     return maxval\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nYes, I see that you are already using Julia 1.1. For 1.2 or greater\
    \ see also [this answer](https://stackoverflow.com/questions/38505013/is-it-possible-to-use-the-maximum-element-function-within-an-array-in-julia).\n\
    <|/ c |>\n<| a tags=julia,sorting |>\nIf you have a huge vector that you want\
    \ to sort:\n<code>", "\tmax_value = l[1]\n\tfor i in l[2:end]\n\t\tmax_value =\
    \ max(max_value, i)\n\tmax_value\nend", "    max_elt = l[0]\n    for elt in l\n\
    \        if elt > max_elt\n            max_elt = elt\n        end\n    end\n \
    \   return max_elt\nend\nmax_element(x)", "    max::Int64 = l[1]\n    for x in\
    \ l[2:end]\n        if x > max\n            max = x\n        end\n    end\n  \
    \  max\nend\n</cell>\n<text>\nmax_element(l::Vector{Int64})", "    maximum = max_element_idx(l)\n\
    \    return l[maximum]\nend", "    for (i,e) in enumerate([x for x in l if x >\
    \ 0])\n        return e \n    else \n        return 0 \nend", "    if l.length\
    \ > 0\n        return l[argmax(l)]\n    else \n        throw(ArgumentError(\"\
    max_element requires at least one element to work with\"))\nend \n\"\"\"Return\
    \ minimum element in the vector.\n    >>> min_element([1, 2, 3])\n    1\n    >>>\
    \ min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"",
  "    \"\"\"Return  the maximum element in the list.\n    \"\"\"\n    if (l == [])\n\
    \        error(\"The argument of max_element() must be a list.\")\n    end", " \
    \   if length(l)==0 \n        throw(DomainError(string(\"$l must be a vector with\
    \ at least one value\")))\n    end", "    return max(l)\nend\n</cell>\n<text>\n\
    Find maximum of elements of a vector\nThe second function called max_element finds\
    \ the maximum element of a vector. \nThe first function called min_element finds\
    \ the minimum element of a vector. \nThe function max_element returns maximum\
    \ of the vector. \nThe function min_element returns minimum of the vector. \n\
    To find the maximum of a vector we use the function max_element and to find the\
    \ minimum of a vector we use the function min_element. \nBoth functions take vector\
    \ as input. ", "    return maximum(l) \nend\nmax_element(x) = max_element(Float64.(x))",
  "    \"\"\"\n    >>> max_element([4, 5, 1, 2])\n    4\n    >>> max_element([9, 3,\
    \ -9, 2, -9, 3])\n    9\n    >>> max_element([1, 3, 4, 2, 5])\n    5\n    \"\"\
    \"\n    if length(l) == 0 \n        throw(ArgumentError(\"Vector has zero length\"\
    ))\n    \n    z = l[1]\n    for i in 2:(length(l))\n        if l[i] > z\n    \
    \        z = l[i]\n        end\n    end\n    z\nend\n</code>\n<|/ a dscore=4 |>\n\
    <| a |>\nI like's answer. Here's another one that works for arrays of any number\
    \ of dimensions:\n<code>", "    \n    if l==[]\n        return l[0]\n    else\n\
    \        local max_element = l[0]\n        for i in l\n            if i>max_element\n\
    \                max_element = i\n            end\n        end\n        return\
    \ max_element\n    end\nend\n</cell>\n<code language=julia-1.0>", "    \n    max_element\
    \ = l[1]\n    \n    for x in l[2:end]\n        if x > max_element\n          \
    \  max_element = x \n        end\n    end\n    \n    return max_element\nend\n\
    </cell>\n<code language=julia-1.3>", "    return max( l )\nend\n</code>\n<|/ a\
    \ dscore=3 |>\n<| c |>\nThis is a much better solution, and it's also very efficient.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>\nimport Data.Function\nimport Data.List\nimport\
    \ Data.Maybe", "    max_value=l[1]\n    for i in 2:length(l) \n        if max_value\
    \ < l[i] \n            max_value=l[i]\n        end\n    end\n    return max_value\n\
    end", "    return argmax(l)\nend", "    maximum = max_element(l.data)\n    maximum\
    \ = maximum(maximum(maximum(maximum(maximum(x::Int64),maximum(y::Int64)),maximum(z::Int64)),maximum(y::Int64))\
    \ for (x,y,z) in zip(l.data,l.data[2:end],l.data[2:end]))\n    return maximum\n\
    end", "    return max(x)\nend\n</cell>\n<text>\nExercise 3.4: Maximum element\
    \ in a vector", "    # Find max in list \n    max_value = l[1] \n    for v in\
    \ l[2:] \n        if v>max_value \n            max_value = v \n        end\n \
    \   end\n    return max_value \nend\n</code>\n<|/ a tags=vector,julia dscore=0\
    \ |>\n<| c |>\nThis does not provide an answer to the question. To critique or\
    \ request clarification from an author, leave a comment below their post. - [From\
    \ Review](/review/low-quality-posts/14304972)\n<|/ c |>\n<| c |>\nI think this\
    \ is an answer. An example would be greatly appreciated.\n<|/ c |>\n<| c |>\n\
    This answer is perfect, just add some comments to describe what you are doing\
    \ here in the code and the use of the type aliases as well.\n<|/ c |>\n<| a tags=vector,julia\
    \ |>\n<code>\njulia> v = [1, 2, 3, 4, 5]\n5-element Vector{Int64}:\n 1\n 2\n 3\n\
    \ 4\n 5", "    maximum_idx = findfirst(i->l[i]>=l,0)\n    maximum_value = l[maximum_idx]\n\
    \    maximum_idx = maximum_idx-1 while maximum_idx > 0 && l[maximum_idx] < l[maximum_idx-1]\n\
    \    while maximum_idx > 0 \n        maximum_value = l[maximum_idx]\n        maximum_idx\
    \ = maximum_idx-1 while maximum_idx > 0 && l[maximum_idx] < l[maximum_idx-1]\n\
    \    end\n    return maximum_value\nend\n</cell>\n<code language=julia-1.5>",
  "        local max = 0\n        for i, x in enumerate(l)\n            if x > max\n\
    \                max = x\n            end\n        end\n        return max\nend",
  "    m = max_value(l)\n    if m == 0 \n        throw(BoundsError(\"max_value(Vector{Int64})\"\
    ))\n    end\n    return m\nend", "    max_element = if length(l) > 0 then l[end]\
    \ else 0\n    for n in l\n        if n > max_element\n            max_element\
    \ = n\n        end\n    end\n    return max_element\nend\n</cell>\n<code language=julia-1.0>\n\
    max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n</cell>\n<code language=julia-1.0>\n\
    @code_warntype max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n</cell>\n\
    <text>\n4.4 @which", "    if l.length() == 0 \n        throw(BoundsError)\n  \
    \  end\n    largest = l[1]\n    for i in 2:length(l) \n        if l[i] > largest\
    \ \n            largest = l[i]\n        end\n    end\n    return largest\nend",
  "    for (i,p) in enumerate(l)\n        if i > p\n            return p\n    return\
    \ 0\nend", "    m = max_element(l)\n    if m < 0 \n        return m\n    else\
    \ \n        return l[m]\nend ", "    largest = 0\n    for i in l \n        if\
    \ i > largest \n            largest = i \n        end\n    end\n    return largest\n\
    end\n</cell>\n<code language=julia-1.5>", "    maximum = maximum(l) \n    for\
    \ v in l do \n        maximum = max(maximum, v) \n    maximum \nend\n</cell>\n\
    <code language=julia-1.0>", "\tmax_elem =l[1]\n\tfor i in 2:length(l)\n\t\tif\
    \ l[i]>max_elem\n\t\t\tmax_elem =l[i]\n\t\tend\n\tend\n\treturn max_elem\nend",
  "    if l.length == 0 \n        throw(DomainError(string(\"Vector is empty\")))\n\
    \    end\n    \n    return maximum(l)\nend", "    if max_element(l) == 0 \n  \
    \      return 0\n    end\n    largest = 0\n    largestIndex = 0\n    for i in\
    \ 1:length(l)\n        if l[i] > largest\n            largest = l[i]\n       \
    \     largestIndex = i\n        elseif l[i] != largest\n            if l[i] >\
    \ largest\n                largest = l[i]\n                largestIndex = i\n\
    \            end\n        end\n    end\n    return largestIndex\nend\nmax_element(A::Vector)\
    \ = max_element(A)", "    sorted=sort(l)\n    \n    if length(sorted) == 0 \n\
    \        return Int64(-1) #to handle case when l is empty \n    end\n    \n  \
    \  return sorted[end]\nend", "   result=0\n   for i in l:\n       if i>result\n\
    \           result=i\n       end\n   end\n   return result\nend", "  if l.length\
    \ == 0 return 0\n  local max_element=l[1]\n  for v in l[2:end] \n    if v > max_element\
    \ then max_element=v end\n  end\n  return max_element\nend", "    \n    #get the\
    \ length of l\n    lenL=length(l);\n    \n    if lenL > 1\n        \n        #find\
    \ the index of the maximum element\n        index=findfirst(lt,l);\n        \n\
    \        #check if index is -1\n        if index==-1\n            return 0;\n\
    \        else\n            \n            #return the element at the index\n  \
    \          return l[index];\n        end\n    end\nend;\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Return minimum element in the vector.\n>>> min_element([1, 2, 3])\n1\n>>>\
    \ min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n-10\n\"\"\"", "    local\
    \ counter = Int64(0)\n    local max_element = l[1]\n    for x in l\n        if\
    \ x > max_element\n            counter = counter + 1\n            max_element\
    \ = x\n        end\n    end\n    return max_element\nend\n    \"\"\"\n    function\
    \ max_element!( l::Vector{Int64})::Int64\n    local counter = Int64(0)\n    local\
    \ max_element = l[1]\n    for x in l\n        if x > max_element\n           \
    \ counter = counter + 1\n            max_element = x\n        end\n    end\n \
    \   return max_element\nend", "    local max_element = l[1]\n    for i in l[2:end]\
    \ \n        if i > max_element \n            max_element = i \n        end \n\
    \    end \n    return max_element \nend\n</code>\nAnd then call it like:\n<code>\n\
    julia> max_element(myVec)\n</code>\n<|/ a tags=julia dscore=1 |>\n<| a |>\nA slight\
    \ improvement would be to pass the vector as a parameter instead of creating a\
    \ copy of that vector (unless you really care about memory use). \nThe copy is\
    \ necessary for the first line of the function (which should be local and therefore\
    \ evaluated only once, i.e. the first time you call it). \n<code>", "    max_idx\
    \ = argmin(l)\n    if max_idx == N\n        max_idx\n    else\n        l[max_idx]\n\
    \    end\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nHere is another approach\
    \ that uses nothing but basic functions. I am using the same example as in question.\
    \ First we define a function which returns the index of a value in a list:\n<code>",
  "    return max(l)\nend", "    largest = max_element2(l)\n    if largest == -1\n\
    \        return -1\n    end\n    return largest\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
