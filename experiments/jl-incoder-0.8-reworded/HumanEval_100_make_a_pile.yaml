name: HumanEval_100_make_a_pile
language: jl
prompt: "\"\"\"\n    Given a positive integer n, you have to make a pile of n levels\
  \ of stones.\n    The first level has n stones.\n    The number of stones in the\
  \ next level is:\n        - the next odd number if n is odd.\n        - the next\
  \ even number if n is even.\n    Return the number of stones in each level in a\
  \ vector, where element at index\n    i represents the number of stones in the level\
  \ (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\nfunction\
  \ make_a_pile(n::Int64)::Vector{Int64} \n"
tests: "using Test\n\n@testset begin\n\ncandidate = make_a_pile;\n\t@test(candidate(3)\
  \ == [3, 5, 7])\n\t@test(candidate(4) == [4, 6, 8, 10])\n\t@test(candidate(5) ==\
  \ [5, 7, 9, 11, 13])\n\t@test(candidate(6) == [6, 8, 10, 12, 14, 16])\n\t@test(candidate(8)\
  \ == [8, 10, 12, 14, 16, 18, 20, 22])\nend\n"
completions: ["    if n % 2 == 1 \n        odd = n\n        even = n - odd\n    else\
    \ \n        odd = n+1\n        even = n - odd\n    return [odd, even]\nend", " \
    \   if n==1 \n        return [n] \n    if n even? \n        make_a_pile(n-1) \n\
    \    else \n        make_a_pile(n-1) + make_a_pile((n / 2) ) \nend \n\"\"\"\n\
    \    Given a positive integer n, you have to make a pile of n levels of stones.\n\
    \    The first level has n stones.\n    The number of stones in the next level\
    \ is:\n        - the next odd number if n is odd.\n        - the next even number\
    \ if n is even.\n    Return the number of stones in each level in a vector, where\
    \ element at index\n    i represents the number of stones in the level (i+1).",
  "    if n == 0 \n        return zero(Int64)\n    end\n    if n % 2 == 0 \n     \
    \   return make_a_pile(n / 2) ++ make_a_pile(n / 2 + 1)\n    else \n        return\
    \ make_a_pile(n / 2 + 1) ++ make_a_pile(n / 2)\nend", "    if n%2 == 0\n     \
    \   make_a_pile(n/2)\n    end\n    push!(pile(n), n)\nend\n</cell>\n<text>\nExercise\
    \ 8\nFor n = 2, write a function that returns $3$ if $n$ is odd and $5$ if $n$\
    \ is even. Make sure you return an array.", "    \"\"\"\n    Make a pile of n\
    \ levels of stones\n    \"\"\"\n    function make_a_pile(n::Int64)\n        pile\
    \ = Vector{Int64}(undef, n+1)\n        pile[1] = 1\n        for i in 2:(n+1)\n\
    \            if mod(i, 2) == 0 || mod(i, 2) == 1\n                pile[i] = pile[i-1]\
    \ + 1\n            else\n                pile[i] = pile[i-2] + 1\n           \
    \ end\n        end\n        return pile\n    end\nend\n</code>\n<|/ a tags=algorithm,julia\
    \ |>\n<| c |>\nI'm so sorry that I forgot to add it but I tried it and it did\
    \ not work.\n<|/ c |>\n<| a tags=algorithm,julia dscore=0 |>\nI realise this was\
    \ asked a while ago, but I thought I would add something to the answers already\
    \ given.\nHere is a solution that I believe is both mathematically and conceptually\
    \ correct, which is one of the things I miss when I use Julia for these sorts\
    \ of questions. It uses iteration and memoization.\n<code>", "    ret = Vector{Int64}()\n\
    \    if n==1\n        ret[1] = 1\n        return ret\n    end", "    if n == 1\
    \ \n        return Vector{Int64}[3]\n    elseif n % 2 == 0 \n        odd_pile\
    \ = make_a_pile(n-1)\n        even_pile = make_a_pile(n//2)\n        return odd_pile\
    \ ++ even_pile\n    elseif n % 2 == 1\n        odd_pile = make_a_pile(n//2)\n\
    \        even_pile = make_a_pile(n-1)\n        return odd_pile ++ even_pile\n\
    \    else\n        throw(ArgumentError(\"n should be odd or even\"))\n    end\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThis is also a great solution. But i wonder if\
    \ this is possible without loops?\n<|/ c |>\n<| c |>\nThis isn't going to be faster\
    \ than your initial solution, since your initial solution is linear in the size\
    \ of the pile. Also, this is very unpythonic to write in such a weird way. Also,\
    \ it is unnecessary to use type annotations (like `Int64`), since you already\
    \ have the type signature in the function header.\n<|/ c |>\n<| c |>\n.Wickham:\
    \ You are correct that the code is unpythonic and it uses loops. But this is an\
    \ exercise in recursion and using loops is an exercise in recursion and using\
    \ loops is not an exercise in recursion. Further, I believe that a solution using\
    \ loops would be faster than recursion, because the loop is implemented in machine\
    \ code, and this is what a compiler does, while a recursive solution is implemented\
    \ in C++.\n<|/ c |>\n<| c |>\n.Wickham: Also, I believe that using a loop would\
    \ not be faster than recursion, because the loop would have to be implemented\
    \ as a loop in machine code, while the recursive solution would be implemented\
    \ in C++.\n<|/ c |>\n<| c |>\n.Wickham: Finally, I also believe that using loops\
    \ would not be faster than recursion, because the loop would have to be implemented\
    \ as a loop in machine code, while the recursive solution would be implemented\
    \ in C++.\n<|/ c |>\n<| a |>\nHere is an iterative solution:\n<code>", "    level\
    \ = make_level(n)\n    return level\nend", "    v = Vector{Int64}(undef, 0)\n\
    \    if n % 2 == 1\n        n = n+1\n    end\n    v[1] = 1\n    v[n]  = 1\n  \
    \  for i=2:n-1\n        v[i+1] = v[i] + v[i-1]\n    end\n    return v\nend", " \
    \   if n == 1 \n        [1]\n    else \n        make_a_pile(n - 1) + (n % 2 ==\
    \ 0 ? 2 : 1)\nend\n</cell>\n<code language=julia-0.6>\n# YOUR CODE HERE\n</cell>\n\
    <code language=julia-0.6>\n@assert make_a_pile(3) == [3, 5, 7]\n</cell>\n<text>\n\
    Problem 3\nLet p_n (1 <= n <= 20) be the nth prime number. You can test whether\
    \ a number p is prime by calling isPrime(p). This function should return true\
    \ or false depending on whether the given number is prime or not.", "    arr=Array{Int64,1}(undef,n)\n\
    \    if n==0\n        return arr\n    end\n    arr[1] = n\n    if n==1 || n==2\
    \ || n==3\n        arr[2]=1\n    end\n    if n==4 || n==5 || n==6\n        arr[2]=2\n\
    \    end\n    if n==7 || n==8 || n==9\n        arr[2]=3\n    end\n    return arr\n\
    end", "    if n == 0 then return [] else make_a_pile(n-1) + [(n - 1 rem 2 .+ 1)\
    \ / 2] end\n    return make_a_pile(n-1) + [(n rem 2 .+ 1) / 2]", "    if n==0\
    \ \n        return Vector{Int64}(0) \n    if n==1 \n        return Vector{Int64}(1)\n\
    \    if n%2 == 1 \n        return Vector{Int64}(n,3*make_a_pile(n-1))\n    return\
    \ Vector{Int64}(n,make_a_pile(n-2))", "    arr \u2190 Array.zeros(Int64, n)\n\
    \    arr[0] \u2190 n\n    arr[1] \u2190 (n+1)\n    if n \u2260 0 \n        arr[2]\
    \ \u2190 (n+2)\n    else \n        arr[2] \u2190 0\n    return arr\nend", "  \
    \  if n == 0 \n        [1]\n    else\n        if n % 2 == 1 \n            push!(make_a_pile(n\
    \ / 2), 1)\n        else\n            push!(make_a_pile(n / 2), make_a_pile(n\
    \ / 2 + 1))\n        end\n    end\nend\n</cell>\n<text>\nSolution\nWe define a\
    \ function make_a_pile and use it to write a program that outputs the number of\
    \ stones in each level of the pile.", "    if n == 1\n        return [1,]\n  \
    \  \n    if n % 2 == 0\n        return make_a_pile(n div 2) + [1]\n    else\n\
    \        return make_a_pile(n div 2) + [1]\nend\n    ", "    if n % 2 == 0\n \
    \       a = ceil(n / 2)\n    else \n        a = floor(n / 2)\n    return Vector{Int64}((a,a))\n\
    end\n</cell>\n<text>\nQ2. Create a function called make_level_piles(n) that returns\
    \ a vector where the number of levels is equal to n, and each level is equal to\
    \ the number of stones in the corresponding level. For example:", "    n = n.floor\n\
    \    if n==0\n        return [1,1]\n    end\n    p = [1,1]\n    push!(Array{Int64}(p...),\
    \ 1)\n    push!(Array{Int64}(p...), n)\n    push!(Array{Int64}(p...), n mod 2)\n\
    \    push!(Array{Int64}(p...), n .- n .% 2)\n    push!(Array{Int64}(p...), n .-\
    \ n .% 2)\n    return p\nend\n</cell>\n<code language=julia-1.0>\n@time make_a_pile(10000)\n\
    </cell>\n<text>\nExercise: Write a function that takes an n and returns a pile.\
    \ Your function will need to have two arguments: an integer n and a boolean is_odd.\
    \ Your function will need to make a pile of n levels, with level 0 having the\
    \ first n stones, and level 1 having the next odd number of stones. If the is_odd\
    \ boolean is true, then the next level in the pile should have the next odd number\
    \ of stones.", "    if n==1 return [1]\n    if n==2 return [3,5]\n    if n==3\
    \ return [3,5,7]\n    if n==4 return [3,5,7,9]\n    if n==5 return [3,5,7,9,11]\n\
    \    if n==6 return [3,5,7,9,11,13]\n    if n==7 return [3,5,7,9,11,13,15]\n \
    \   if n==8 return [3,5,7,9,11,13,15,17]\n    if n==9 return [3,5,7,9,11,13,15,17,19]\n\
    \    if n==10 return [3,5,7,9,11,13,15,17,19,21]\n    if n==11 return [3,5,7,9,11,13,15,17,19,21,23]\n\
    \    if n==12 return [3,5,7,9,11,13,15,17,19,21,23,25]\nend", "    arr = Array{Int64,\
    \ 1}(undef, length(n) + 2)\n    arr[1] = n\n    if n % 2 == 0 \n        arr[end]\
    \ = arr[end] - 1\n    else\n        arr[end] = arr[end] + 1\n    end\n    if n\
    \ == 1 || n == 0\n        return arr\n    end\n    for k in 2:length(arr)\n  \
    \      if n % 2\n            arr[k] = arr[k-1] + 1\n        else\n           \
    \ arr[k] = arr[k] + 1\n        end\n        n = n / 2\n    end\n    arr\nend\n\
    </cell>\n<text>\nExercise 6: Make Stones", "    if n % 2 == 0\n        return\
    \ make_a_pile(n / 2)\n    else\n        return make_a_pile(n / 2) + make_a_pile(n\
    \ / 2 + 1)\nend\n</cell>\n<code language=julia-1.4>", "    pile = Vector{Int64}()\n\
    \    \n    pile[1] = 1\n    for i = 2:(n+1)\n        if i%2 ==0\n            pile[i]\
    \ = i/2\n        else\n            pile[i] = (i+1)/2\n        end\n    end", " \
    \   if n==0 then return []\n    else return [n % 2 ? make_a_pile(n-1) : make_a_pile(n-1)+make_a_pile(n-2),\
    \ make_a_pile(n-1)+make_a_pile(n-2)+make_a_pile(n-3)]\nend", "    levels::Vector{Int64}\
    \ = Vector{Int64}()\n    odd::Int64 = 0\n    even::Int64 = 1\n    for _ in 1:n\n\
    \        levels.push(odd)\n        levels.push(even)\n        if n % 2 == 0\n\
    \            odd = even\n        else\n            even = odd\n        end\n \
    \   end\n    return levels\nend\n</cell>\n<code language=julia-1.3>", "    if\
    \ n < 2 \n        return zeros(Int64,1,n)\n    else \n        if n % 2 == 0\n\
    \            n = n+1\n            return make_a_pile(n) + make_a_pile(n) \n  \
    \      else \n            return make_a_pile(n-2) + make_a_pile(n-1)\n       \
    \ end\n    end\nend", "    if n%2 == 1 then n+1 elseif n%2 == 0 then n/2+1 else\
    \ n/2\nend", "    levels = Vector{Int64}[]\n    if n % 2 == 0 \n        levels\
    \ = [n for n in 1:n]\n    else\n        for n in 1:n \n            levels = [n\
    \ for n in 1:n]\n    end\n    \n    return levels\nend\n\"\"\"\n    \n    Given\
    \ a list of stones, you have to make as many piles as possible.\n    For example\
    \ if stones = [3, 5, 7], then you can make the following piles:\n        [[3,\
    \ 5, 7], [], [7]]\n    You cannot make a pile of 3 stones and another pile of\
    \ 5 stones.\n    You cannot make a pile of 7 stones and another pile of 3 stones.\n\
    \    You cannot make a pile of 7 stones and another pile of 5 stones.\n    The\
    \ function should return the list of piles required.\n    \n    Examples:\n  \
    \  >>> make_piles(4, 2)\n    [[3, 7], [7], [3, 7]]\n    \"\"\"", "    return [0]\n\
    \    if n == 1 \n        return [1]\n    i = make_a_pile(n div 2)\n    j = make_a_pile(n\
    \ - i + (n & 1))\n    return i + j\nend", "    if n==0\n        return [1]\n \
    \   stks=make_a_pile(n-1)\n    stks+=[2^ceil(log2(n))]\n    return stks\nend",
  "    if n <= 0 \n        error(\"n must be positive\") \n    elseif n == 1 \n  \
    \      [1] \n    else\n        if mod(n,2) == 0\n            [2*n] \n        else\n\
    \            [2*n +1] \n        end\n    end\nend\n</cell>\n<text>\nExercise 7:\
    \ make_a_pile\nWrite a function make_pile(n::Int64) that makes piles of n levels,\
    \ each with n stones.\nTest your function with n = 2 and n = 4.\nCan you make\
    \ a pile of 6 stones?", "    return Vector{Int64}(undef, n+1)\nend\n</cell>\n\
    <code language=julia-1.3>\nmake_a_pile(3)\n</cell>\n<code language=julia-1.3>\n\
    @code_warntype make_a_pile(3)\n</cell>\n<text>\nExercise\nLet's create another\
    \ function called make_b_pile. Here we will be returning a vector of length n+1\
    \ \nand storing number of stones in each level in a vector starting from nth level\
    \ of the pile.", "    if n == 1 \n        return [1,1]\n    end\n    if n % 2\
    \ == 0 \n        return make_a_pile(n / 2::Int64) + (n / 2::Int64) \n    end \n\
    \    \n    return make_a_pile(n / 2 + 1::Int64) + make_a_pile((n / 2 + 1)::Int64)\
    \ \nend \n</cell>\n<code language=julia-1.5>", "    if n <= 0\n        throw(ArgumentError(\"\
    n must be positive\"))\n    end\n    \n    if n == 2\n        return [1, 1]\n\
    \    end\n    \n    level = make_a_pile(n-1)\n    if n % 2 == 0\n        level[1]\
    \ = level[1]*2 + 1\n    else\n        level[1] = level[1] + 1\n    end\n    \n\
    \    return level\nend", "    \"\"\"\n    Given a positive integer n, you have\
    \ to make a pile of n levels of stones.\n    The first level has n stones.\n \
    \   The number of stones in the next level is:\n        - the next odd number\
    \ if n is odd.\n        - the next even number if n is even.\n    Return the number\
    \ of stones in each level in a vector, where element at index\n    i represents\
    \ the number of stones in the level (i+1).", "    if n == 0\n        return Vector{Int64}()\n\
    \    \n    pile = make_a_pile(n div 2)\n    if mod(n, 2)\n        push!(pile,\
    \ n mod 2)\n    else \n        push!(pile, 1)\n    end\n    \n    return pile\n\
    end", "    if n == 1\n        return [1]\n    if n == 0\n        return [0]\n\
    \    if n % 2 == 0\n        a = make_a_pile(n / 2)\n        push!(a, n / 2)\n\
    \        return a\n    a = make_a_pile(n * 3 + 1)\n    push!(a, n * 3 + 1)\n \
    \   return a\nend", "    n = n % 2\n    if n < 0\n        error(\"n is negative!\"\
    )\n    end\n    if n == 0\n        return [1]\n    elseif n == 2\n        return\
    \ [1, 2]\n    end\n    pile = make_a_pile(n//2)\n    pile[1] = pile[1] + pile[2]\n\
    \    pile[2] = n%2 == 0 ? pile[1] + 1 : 2\n    pile = pile[end-1:]\n    return\
    \ pile\nend\n</cell>\n<code language=julia-0.6>\n# Check your solution by submitting\
    \ it to the Julia interpreter at\n# http://julialang.org", "    if n==0\n    return\
    \ zeros(Int64, 1)\n    if n==1\n    return ones(Int64, 1)\n    \n    function\
    \ find_odd_even_count(n::Int64)::Int64\n        if n==2\n            return 2\n\
    \        end\n        if n%2==0\n            return find_odd_even_count(n/2)\n\
    \        else\n            return find_odd_even_count(n-1)\n        end\n    end\n\
    \    \n    even = find_odd_even_count(n)\n    odds = find_odd_even_count(n-1)\n\
    \    return Int64[even, odds]\nend", "    if n==1\n        vec[]=1\n    else\n\
    \        if n%2==0\n            vec=vec ++ make_a_pile(n-1)\n        else\n  \
    \          vec=vec ++ make_a_pile(n//2)\n        end\n    end\n    return vec\n\
    end\n</code>\n<|/ a tags=recursion,julia |>\n<| c |>\nI like the way you use concat\
    \ here. I was trying to come up with a way to do it using append, but this is\
    \ clearer. Thanks!\n<|/ c |>\n<| a tags=recursion,julia |>\nUsing a recursive\
    \ function:\n<code>", "    if n % 2 == 0 \n        odds = n \n    else \n    \
    \    odds = n \n    even = n / 2 \n    make_a_pile = [odds, even] \n    return\
    \ make_a_pile \nend", "    n==0 ? return zeros(Int64) :\n    n==1 ? return ones(Int64)\
    \ :\n    n%2==0 ? n2 : n1\nend", "  if n == 0 \n    return [1] \n  else \n   \
    \ if n % 2 == 1 \n      return make_a_pile((n-1)/2::Int64) + [1]\n    else \n\
    \      return make_a_pile(n/2::Int64) + make_a_pile((n-1)/2::Int64) \nend\n</cell>\n\
    <code language=julia-1.6>\n@assert make_a_pile(3) == [3, 5, 7]\n</cell>\n<text>\n\
    Exercise 8.1\nWrite a function that returns the nth level pile.", "    arr = []\n\
    \    push!(arr,n)\n    push!(arr,n+1)\n    push!(arr,n+2)\n    push!(arr,n+3)\n\
    \    push!(arr,n+4)\n    push!(arr,n+5)\n    push!(arr,n+6)\n    push!(arr,n+7)\n\
    \    push!(arr,n+8)\n    push!(arr,n+9)\n    arr\nend\n</cell>\n<code language=julia-1.5>\n\
    # your code here\n</cell>\n<text>\nProblem 4", "    evens=0\n    odds=0\n    evens=n\n\
    \    odds=n*2\n    stones=[odds,evens]\n    return stones\nend", "    \n    if\
    \ n % 2 == 0 then \n        oddnums = make_a_pile(n / 2)\n        evennums = make_a_pile(n)\
    \ \n        return oddnums + evennums\n    else \n        return make_a_pile(n-1)",
  "    if n <= 1\n        return Vector{Int64}(undef, 0)\n    end\n    left_pile =\
    \  make_a_pile(n-2)\n    right_pile = make_a_pile(n-1)\n    left_pile << right_pile[n\
    \ % 2 != 0]\nend\n</cell>\n<code language=julia-1.5>\n@assert make_a_pile(3) ==\
    \ [3, 5, 7]\n</cell>\n<code language=julia-1.5>", "    if n == 0\n        Vector{Int64}(0)\n\
    \    else\n        if mod(n,2)\n            n = n+1\n            make_a_pile(n)\n\
    \        else\n            make_a_pile(n-1)\n        end\n    end\nend\n</code>\n\
    <|/ a tags=julia |>\n<| a tags=julia |>\nMy solution:\n<code>", "    if n==0 then\
    \ return [0]\n    \n    if n % 2 == 1 then\n        odds = make_a_pile(n / 2)\n\
    \        evens = make_a_pile(n / 2)\n    else\n        odds = make_a_pile(n /\
    \ 2)\n        evens = make_a_pile(n / 2)\n    end\n    \n    push!(odds, n)\n\
    \    push!(evens, n - evens[end])\n    \n    return odds + evens\nend", "    \n\
    \    \"\"\"\n    \n\"\"\"\n    Given a positive integer n, you have to make a\
    \ pile of n levels of stones.\n    The first level has n stones.\n    The number\
    \ of stones in the next level is:\n        - the next odd number if n is odd.\n\
    \        - the next even number if n is even.\n    Return the number of stones\
    \ in each level in a vector, where element at index\n    i represents the number\
    \ of stones in the level (i+1).", "    pile = Vector{Int64}(undef, numLevels(n))\n\
    \    pile[1] = n\n    pile[2] = n - Int(n / 2) #number of stones in first level\n\
    \    pile[3] = n - Int(n / 2) #number of stones in second level\n    for i = 4\
    \ to numLevels(n) #iterating through each level\n        pile[i] = n - Int(n /\
    \ 2) #number of stones in current level\n    end\n    return pile\nend\n</cell>\n\
    <code language=julia-1.5>", "    if n==0 || n==1 \n        return [n]\n    end\n\
    \    push!(res, make_a_pile(n-1))\n    push!(res, make_a_pile(n-2))\n    push!(res,\
    \ make_a_pile(n-3))\n    push!(res, make_a_pile(n-4))\n    push!(res, make_a_pile(n-5))\n\
    \    push!(res, make_a_pile(n-6))\n    push!(res, make_a_pile(n-7))\n    push!(res,\
    \ make_a_pile(n-8))\n    push!(res, make_a_pile(n-9))\n    push!(res, make_a_pile(n-10))\n\
    \    push!(res, make_a_pile(n-11))\n    push!(res, make_a_pile(n-12))\n    push!(res,\
    \ make_a_pile(n-13))\n    push!(res, make_a_pile(n-14))\n    push!(res, make_a_pile(n-15))\n\
    \    push!(res, make_a_pile(n-16))\n    push!(res, make_a_pile(n-17))\n    push!(res,\
    \ make_a_pile(n-18))\n    push!(res, make_a_pile(n-19))\n    push!(res, make_a_pile(n-20))\n\
    \    push!(res, make_a_pile(n-21))\n    push!(res, make_a_pile(n-22))\n    push!(res,\
    \ make_a_pile(n-23))\n    push!(res, make_a_pile(n-24))\n    push!(res, make_a_pile(n-25))\n\
    \    push!(res, make_a_pile(n-26))\n    push!(res, make_a_pile(n-27))\n    push!(res,\
    \ make_a_pile(n-28))\n    push!(res, make_a_pile(n-29))\n    push!(res, make_a_pile(n-30))\n\
    \    push!(res, make_a_pile(n-31))\n    push!(res, make_a_pile(n-32))\n    push!(res,\
    \ make_a_pile(n-33))\n    push!(res, make_a_pile(n-34))\n    push!(res, make_a_pile(n-35))\n\
    \    push!(res, make_a_pile(n-36))\n    push!(res, make_a_pile(n-37))\n    push!(res,\
    \ make_a_pile(n-38))\n    push!(res, make_a_pile(n-39))\n    push!(res, make_a_pile(n-40))\
    \ \n    push!(", "    # Your code here\n    if n % 2 == 1\n        n = n + 1\n\
    \    end\n    pile = [n]\n    while n > 1\n        if n mod 2 == 1\n         \
    \   n = n / 2\n        else\n            n = 3*n + 1\n        end\n        push!(pile,\
    \ n)\n    end\n    return pile\nend\n</cell>\n<code language=julia-0.6>\nmake_a_pile(1)\n\
    </cell>\n<code language=julia-0.6>\nmake_a_pile(4)\n</cell>\n<code language=julia-0.6>\n\
    make_a_pile(8)\n</cell>\n<code language=julia-0.6>\nmake_a_pile(20)\n</cell>\n\
    <text>\nExercise 1\nWrite a function that takes in a positive integer n and returns\
    \ the number of ways to draw n elements from a set of twenty-two elements. \n\
    For example, given n = 4, return 6 since there are 6 ways to draw four elements\
    \ from {1, 2, 3, 4}:", "    return zeros(Int64, (n + 1)//2)\nend\n</cell>\n<code\
    \ language=julia-0.6>", "    # Write your code here\n    # return ", "    # base\
    \ case\n    if n == 0\n        return []\n    if n == 1\n        return [1]\n\
    \    # base case\n    if n % 2 == 0\n        odd_nums = make_a_pile(n / 2)\n \
    \       even_nums = make_a_pile(n / 2)\n        odd_nums = [x * 2 + 1 for x in\
    \ odd_nums]\n        even_nums = [x * 2 for x in even_nums]\n        odd_nums\
    \ = odd_nums + even_nums\n        return odd_nums\n    \n    odd_nums = make_a_pile(n\
    \ / 2)\n    even_nums = make_a_pile(n / 2)\n    odd_nums = [x * 2 + 1 for x in\
    \ odd_nums]\n    even_nums = [x * 2 for x in even_nums]\n    odd_nums = odd_nums\
    \ + even_nums\n    odd_nums = odd_nums + even_nums\n    return odd_nums\nend",
  "    return 2*n + (n%2 == 0 ? 1 : 0)\nend", "if n < 2 return [1] else if n % 2 ==\
    \ 0 return make_a_pile(n/2) + [n div 2]\nelse return make_a_pile(n/2) + [n div\
    \ 2] + make_a_pile((n div 2)-1) end\n</cell>\n<code language=julia-0.4>\n# TEST\
    \ make_a_pile (59)\n@assert make_a_pile(9) == [3, 3, 3, 3]\n@assert make_a_pile(11)\
    \ == [3, 3, 3, 3, 3, 3]\n</cell>\n<text>\nProblem 11: make_pile_sum\nWrite a function\
    \ that computes the number of piles (count) that you can make with n stones.",
  "    if n%2 == 0 then \n        odds = Vector{Int64}(undef,n/2)\n        evens =\
    \ Vector{Int64}(undef,n-1)\n        for n in odds,evens \n            push!(n,n)\n\
    \        end\n        return odds + evens\n    else \n        odds = Vector{Int64}(undef,n/2)\n\
    \        evens = Vector{Int64}(undef,n-1)\n        for n in odds,evens \n    \
    \        push!(n,n+1)\n        end\n        return odds + evens\n    end\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThanks, your solutions work great, however this was\
    \ just a school project and we are not allowed to use lists or dictionaries. \
    \ I appreciate your help!\n<|/ c |>\n<| c |>\nHappy to help. I edited my answer\
    \ to show you how you could do it without lists or dictionaries. You also might\
    \ want to revise the code I gave you a little bit so it's actually correct\n<|/\
    \ c |>\n<| c |>\nI updated the answer. I think I finally understand what you're\
    \ going for. You are trying to take an input (a number) and return the number\
    \ of stones in the pile, which is the sum of all the numbers on each level\n<|/\
    \ c |>\n<| c |>\nThanks so much for the help!  I really appreciate it.  Yes, you\
    \ understand it correctly, I made a mistake when typing the question, I've fixed\
    \ it.  Thanks again!\n<|/ c |>\n<| a tags=julia |>\nYou can do this easily with\
    \ Julia's broadcasting feature:\n<code>", end, "    if n > 0\n        make_a_pile(n-1)\n\
    \        if n % 2 == 1\n            push!(p,n+1)\n        else\n            push!(p,\
    \ n)\n        end\n    end\n    return p\nend\n</cell>\n<text>\nHere are some\
    \ examples of usage. We'll see later how to use a function.", "    levels = Vector{Int64}(1:n)\n\
    \    if n >= 2\n        levels[1] = odd_number_to_next_odd(n)\n    else\n    \
    \    levels[1] = even_number_to_next_even(n)\n    end\n    levels[2] = 3\n   \
    \ return levels\nend\n</cell>\n<code language=julia-1.1>\n@time begin\n    make_a_pile(1000)\n\
    end\n</cell>\n<code language=julia-1.1>\n@time begin\n    make_a_pile(1000)\n\
    end\n</cell>\n<text>\nTask 12. Generate an array of all possible permutations\
    \ (with repetition) of the elements in array a\nYour function should take array\
    \ a as a parameter. Return an array of all possible permutations of the elements\
    \ in array a.\nThe order of the permutations in the returned array is lexicographic\
    \ and will be the same as the order of permutations of elements in a given array\
    \ (without repetition).\nThe returned array will contain duplicates if the elements\
    \ in a are duplicated (which is allowed and valid in our case).", "    pile =\
    \ Vector{Int64}(0) # create the empty pile\n    push!(pile, n) # push to the first\
    \ level\n    level = 1\n    while level < n \n        push!(pile, next(odd_or_even))\
    \ # push to the next odd or even level\n        level += 1\n    end\n    return\
    \ pile\nend", "    levels = Vector{Int64}()\n    for i = 1:n\n        if n%2 !=\
    \ 0\n            levels[i] += 1\n        else\n            levels[i] += 2\n  \
    \      end\n    end\n    return levels\nend", "    if n == 0\n        Vector{}\n\
    \    else\n        odd_pile = make_a_pile(n div 2)\n        even_pile = make_a_pile(n\
    \ - n div 2)\n        make_a_pile_vector = odd_pile ++ even_pile\n    end\nend",
  "    if n == 0\n        return 0\n    if n % 2 == 0\n        return make_a_pile(n-1)\
    \ + make_a_pile(n-2)\n    else\n        return make_a_pile(n-1) + make_a_pile(n-2)",
  "    if n==0 \n        Vector{Int64}()\n    else\n        odd = n%%2\n        if\
    \ odd==1\n            make_a_pile(n/2)\n        else\n            make_a_pile(n/2)+1\n\
    \        end\n    end\nend", "    @assert n > 0\n    make_a_pile = zeros(Int64,\
    \ n+1)\n    make_a_pile[1,1] = n\n    if n > 0\n        make_a_pile[2,1] = (n\
    \ % 2) ==0 ? n : make_a_pile[2,1] + 1\n    end\n    return make_a_pile\nend",
  "    if n%2==0 \n        odd=[ceil(sqrt(n)),n//2]\n    else\n        odd=ceil(n/2);\n\
    \    end\n    even=n\n    even=even-2*odd\n    vec=zeros(length(odd)+length(even))\n\
    \    \n    for i in 1:length(odd) \n        vec[i]=odd[i] \n    end\n    \n  \
    \  for i in 1:length(even) \n        vec[i+length(odd)]=even[i]\n    end\n   \
    \ return vec\nend", "    if n<=0\n        return Vector{Int64}()\n    end\n  \
    \  return make_a_pile(n - 2) + [n % 2 == 0 ? n : n + 1]\nend\n</cell>\n<code language=julia-1.5>\n\
    make_a_pile(4)\n</cell>\n<text>\nExercise\nWrite a function that prints the levels\
    \ of the pile:", "    if n == 0\n        return Int64[]\n    else if n >= 1\n\
    \        return make_a_pile(n - 2) + n / 2 + 1\n    else \n        return make_a_pile(n\
    \ - 2) * 2\nend\n</cell>\n<text>\nPart 4: Solution", "    if n == 2\n        return\
    \ [1]\n    \n    stone_counts = make_a_pile(n-1)\n    if mod(n, 2) == 0 && n !=\
    \ 1\n        push!(stone_counts, n / 2)\n    end\n    \n    return stone_counts\n\
    end\n</cell>\n<code language=julia-1.5>", "    piles = Vector{Int64}(undef, 2^n)\n\
    \    for i in 1:2^n\n        push!(piles, if i&1 == 0 then (n-1) else  (n+1))\n\
    \    end\n    return piles\nend", "    \n    if n % 2 == 0\n        \n       \
    \ evens = make_a_pile(n / 2)\n    \n    else\n        \n        odds = make_a_pile(n\
    \ / 2)\n    end\n    \n    return Array{Int64}[evens,odds]\nend", "    if n==1\
    \ return [1]\n    if n % 2 == 1 return make_a_pile(n//2) + [2*make_a_pile(n//2)]\n\
    \    return make_a_pile(n//2)+[2*make_a_pile(n//2-1)+1]\nend\n</cell>\n<code language=julia-0.6>\n\
    make_a_pile(3)\n</cell>\n<code language=julia-0.6>\n@time make_a_pile(10000000)\n\
    </cell>\n<text>\nThe Fibonacci Sequence", "    if n % 2 == 1 \n        oddnum\
    \ = n \n    else \n        oddnum = n \xF7 2 \n    return fill( oddnum, Int(n)\
    \ ) # fill takes a vector and fills it\nend\n</cell>\n<code language=julia-0.6>",
  "    pile=Vector{Int64}(undef,n+1)\n    pile[1]=n\n    if mod(n,2)==1\n        pile[end]=n\n\
    \    else\n        pile[end]=n+1\n    end\n    return pile\nend\n</code>\n<|/\
    \ a dscore=1 tags=julia |>\n<| a |>\nI like Christian's answer but thought I'd\
    \ try a recursive solution just to see what it could look like.  I wanted to do\
    \ the same thing as Christian but only return an Array, so here is my take on\
    \ that:\n<code>", "    arr = [n+1]\n    for n in arr\n        arr[n] = if n%2\
    \ == 1 then n+2 else n+1 end\n    end\n    return arr\nend\n</code>\n<|/ a |>\n\
    <| a tags=julia,arrays |>\nHere is a slightly different version that uses some\
    \ built-in Julia functionality:\n<code>", "    first=1\n    second=first+n-1\n\
    \    if mod(second,2)==1\n        third=second+2\n    else\n        third=second\n\
    \    end\n    fourth=third+n-1\n    total=first\n    total+=second\n    total+=third\n\
    \    total+=fourth\n    total+=(mod(total,2)==1)?3:5\n    \n    return total\n\
    end\n</cell>\n<code language=julia-1.5>\nmake_a_pile(5)\n</cell>\n<code language=julia-1.5>",
  "    if n % 2 == 0 \n        n = n+1\n    else \n        n = n-1\n    pile = Vector{Int64}()\n\
    \    for i in 1:n\n        pile = pile:+i\n    end\n    return pile\nend\n\"\"\
    \"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n\
    \    The first level has n stones.\n    The number of stones in the next level\
    \ is:\n        - the next odd number if n is odd.\n        - the next even number\
    \ if n is even.\n    Return the number of stones in each level in a vector, where\
    \ element at index\n    i represents the number of stones in the level (i+1).",
  "    stones = [n]\n    if n%2 == 1\n        odds = make_a_pile(n-1)\n    else\n\
    \        evens = make_a_pile(n/2)\n    end\n    for n in odds\n        push!(stones,\
    \ n+2)\n    end\n    for n in evens\n        push!(stones, n+1)\n    end\n   \
    \ stones\nend\n</cell>\n<text>\nSolution:", "    if n <= 0\n    error(\"n is must\
    \ be positive\")\n    end", "    return Vector{Int64}(ceil((n-1)/2))\nend", " \
    \   if n % 2 == 0 \n        return zeros(n) \n    else \n        return make_a_pile(n-2)\
    \ + make_a_pile(n-2)\nend\n</cell>\n<text>\nLet's try it out", "    if n==0 \n\
    \        Vector{Int64}(undef, 0) \n    else \n        if n%2==0 \n           \
    \ first_level = [n] \n        else \n            first_level = [n*2+1] \n    \
    \    rest = make_a_pile(n-1) \n        vec = first_level\n        for val in rest\
    \ \n            vec = vec ++ vec  \n        end\n        return vec \n    end\n\
    end\n</cell>\n<cell>", "    if n <= 1 \n        vec[]\n    else\n        make_a_pile(n\
    \ div 2) + [n mod 2]\n    end\nend\n</code>\nThen to test you just run make_a_pile(5)\
    \ and look at the output:\n<code>\njulia> make_a_pile(5)\n5-element Vector{Int64}:\n\
    \ 3\n 3\n 3\n 5\n 7\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nA solution\
    \ that might help you get going is the following one:\n<code>", "    ans = zeros(Int64,\
    \ (n+1))\n    ans[1] = n % 2 == 0 ? n : n+1\n    for i in 2..n\n        ans[i]\
    \ = ans[i-1] + 2 * ans[i-1]\n    end\n    return ans\nend\n</code>\n<|/ a |>\n\
    <| a tags=algorithm,julia,performance dscore=2 |>\nI wrote this in Julia v1.0.\n\
    <code>", "    if n==0 \n        return [1,1]\n    if n==1 \n        return [1]\n\
    \    \n    odd_num = next((x for x in [1,2,3] if n%x==0), 1)\n    even_num = next((x\
    \ for x in [2,4] if n%x==0), 1)\n    return [odd_num, even_num]\nend\n</cell>\n\
    <code language=julia-1.1>\n@assert make_a_pile(10) == [10, 6, 4, 2]\n</cell>\n\
    <text>\nP. Make_a_pile(n) function\nTo implement the function, you will have to\
    \ complete the body of the function.", "    if mod(n,2) == 0 \n        vec = [n,\
    \ floor(n/2)]\n    else \n        vec = [floor(n/2), n]\n    return vec\n</code>\n\
    <|/ a tags=haskell,algorithm,stl,vector |>\n<| c |>\nI added a question to your\
    \ answer. I am wondering whether we can get rid of the type annotations in your\
    \ code. It seems to me that Haskell can infer the type of make_a_pile, based on\
    \ whether you use an \"Int\" or \"Int64\". However, I find that it is hard to\
    \ do that in many cases. Do you have any suggestions? Thanks\n<|/ c |>\n<| a |>\n\
    <code>\ncountLevels n = [countLevels $ n+1 | (n+1) <- [1..], even n]\n</code>\n\
    The pattern [1..] creates the list of numbers from 1 to n, and then we use the\
    \ list comprehension to filter the even numbers, and then we use the even function\
    \ to determine if the n is even.\nThe function countLevels recursively calls itself\
    \ when n+1 has reached the upper limit.\n<|/ a tags=haskell,algorithm,stl,vector\
    \ dscore=1 |>\n<| c |>\nI am wondering whether we can get rid of the type annotations\
    \ in your code. It seems to me that Haskell can infer the type of countLevels,\
    \ based on whether you use an \"Int\" or \"Int64\". However, I find that it is\
    \ hard to do that in many cases. Do you have any suggestions? Thanks\n<|/ c |>\n\
    <| a tags=haskell,algorithm,stl,vector |>\nYou could also use recursion here:\n\
    <code>\ncountLevels :: Int -> [Int]\ncountLevels n = [(n+1):(countLevels (n+1))]\
    \ !! (n+1)\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>\ncountLevels n = foldr\
    \ (\\acc x -> acc + (n==x || even x)) 0 [1..n]\n</code>\n<|/ a dscore=0 tags=haskell,algorithm,stl,vector\
    \ |>\n<| a dscore=0 tags=haskell,algorithm,stl,vector |>\n<code>\ncountLevels\
    \ :: Int -> [Int]\ncountLevels n = [n, (countLevels (n+1))]\n</code>\n<|/ a |>\n\
    <| c |>\nI am wondering whether we can get rid of the type annotations in your\
    \ code. It seems to me that Haskell can infer the type of countLevels, based on\
    \ whether you use an \"Int\" or \"Int64", "  if n % 2 == 0 \n    make_a_pile(n/2)\n\
    \  else \n    make_a_pile(n/2) + [(n/2)*(n/2)]\nend\n</cell>\n<code language=julia-1.5>\n\
    make_a_pile(9)\n</cell>\n<text>\nExercise 2: Write a function that takes a positive\
    \ integer n and returns the number of unique ways to fill a pile with n stones.",
  "    arr=Array{Int64}(undef, n - 1)\n    arr[1] = n\n    for i = 3:-1:1\n      \
    \  arr[i] = arr[i-2] + arr[i-2]/2 + arr[i-2] % 2\n    end\n    return arr\nend\n\
    </code>\n<|/ a tags=performance,sorting,julia,arrays dscore=2 |>\n<| c |>\nHow\
    \ is this answer any better than [your previous one](http://stackoverflow.com/a/39121711/1888916)?\n\
    <|/ c |>\n<| c |>\nI posted this answer before OP's edit and before he accepted\
    \ my answer. He edited his question while I answered it, and didn't mark it as\
    \ accepted after he posted his answer. My answer was before edit. I don't understand\
    \ why he changed his question and marked my answer as accepted, but he changed\
    \ it after I answered.\n<|/ c |>\n<| a tags=performance,sorting,julia,arrays dscore=2\
    \ |>\nThis algorithm is more efficient (~30%) for larger arrays.  It is more complicated\
    \ and requires knowledge of how Julia stores vectors.  Basically you make a new\
    \ vector of length N+1 and then fill the lower part of the array with the value\
    \ 0.  Then you fill the rest of the array with consecutive values where you take\
    \ the value from the previous array.  Then you fill the top with consecutive values\
    \ where you take the value from the bottom array.\nThe code is more readable so\
    \ let's give it a try.  I used the function below to generate random data.\n<code>",
  "    if n==0 \n        return Int64[]\n    else\n        if n%2==0 \n          \
    \  evens=make_a_pile(n/2)\n        else \n            odds=make_a_pile(n/2)+1\n\
    \        end\n        pile=Int64[odds,evens]\n    end\nend", "    if n==0\n  \
    \      return zeros(1)\n    elseif n==1\n        return [1]\n    elseif n%2==0\n\
    \        return make_a_pile(ceil(n/2))+[ceil(n/2)+1]\n    else\n        return\
    \ make_a_pile(floor(n/2))+[floor(n/2)+1]\n    end\nend", "    firstLevel = [n]\n\
    \    for _ in range(1,n)\n        push!(firstLevel, nextOdd(firstLevel))\n   \
    \     push!(firstLevel, nextEven(firstLevel))\n    return firstLevel\nend", " \
    \   if n==1\n        return [1]\n    else\n        odds = make_a_pile(floor(n/2))\n\
    \        evens = make_a_pile(n - odds[end])\n        return [odds, evens]\n  \
    \  end\nend\n</cell>\n<text>\nQ. Create a function to remove consecutive duplicates\
    \ from a list of integers. For example, given [1,2,2,3,4], it should return [1,2,3].",
  "    levels = Array.zeros(n+1)\n    levels[1] = Array{Int64}(undef, n+1)\n    levels[1][1]\
    \ = n+1\n    if n%2 != 0\n        levels[2] = Array{Int64}(undef, n)\n    else\n\
    \        levels[2] = Array{Int64}(undef, (n+1)/2)\n    end\n    for i in 2:n+1\n\
    \        if i%2 == 0\n            levels[i] = levels[i-1][end-1] + levels[i-1][end-2]\n\
    \        else\n            levels[i] = levels[i-1][end-1] + levels[i-1][end-1]\n\
    \        end\n    end\n    return levels\nend", "    pile = Vector{Int64}(undef,n)\n\
    \    pile[1] = n+1\n    if n%2 != 0\n        pile = pile[end-1:end]\n    else\n\
    \        pile = pile[end-1:end]\n    end\n    return pile\nend", "    if n==0\
    \ \n        Vector{Int64}()\n    elseif n==1 \n        Vector{Int64}([1])\n  \
    \  else \n        if mod(n,2)==0 \n            make_a_pile(n-1) + [ceil(n/2)]\n\
    \        else \n            make_a_pile(n-1) + [floor(n/2)]\n        end\n   \
    \ end\nend\n\"\"\"\n    Your goal is to build a piles of n levels (1<=n<=10000)\
    \ where \n    each level has exactly one stone and the remaining ones are spread\
    \ out \n    evenly in the next level.", "    return Vector{Int64}([n+1] .+ n%2\
    \ .+ 1, n%2 .+ 1])\n</code>\n<|/ a |>\n<| c |>\nThank you for this answer! I find\
    \ it a good way to implement the algorithm. Just a question: why do you need the\
    \ vector ([])?\n<|/ c |>\n<| c |>\nWhen you have a `return` inside a function\
    \ and you don't specify `return`, the function will return a value of `nothing`.\
    \ This is one of the many pitfalls people fall into when coding functions in Haskell.\
    \ If you want the function to return the value you specified explicitly (`return`,\
    \ or anything else), you either have to specify `return` or don't specify a return\
    \ value. `return` is how you explicitly specify a return value, so there's no\
    \ reason not to use it; just be aware that it doesn't exist in some languages.\n\
    <|/ c |>\n<| a dscore=3 tags=vector,haskell |>\nThe answer to your question is:\
    \ yes, you can do that with fold. Since you asked for it, here's how you can do\
    \ it:\n<code>\nimport Control.Monad", "    pile = Vector{Int64}()\n    if n==1\n\
    \        pile[1] = n\n    elseif mod(n,2)==0\n        pile[1] = n\n    else\n\
    \        pile[1] = n\n        pile[2] = ceiling(n/2)\n        pile[3] = n\n  \
    \  end\n    return pile\nend", "    vec = [0 for i in 1:n+1]\n    vec[1] = 1\n\
    \    for i in 2:(n+1)\n        if n % 2 == 0\n            vec[i] = vec[i-2] +\
    \ vec[i-1]\n        else\n            vec[i] = vec[i-2] + vec[i-1]\n        end\n\
    \    end\n    return vec\nend\n</cell>\n<code language=julia-1.5>", "    num =\
    \ n\n    list = []\n    while num > 0 do\n        push!(list, num)\n        if\
    \ num%2 == 1 then\n            num = num/2\n        else\n            num = num*3\
    \ + 1\n        end\n    end\n    return list\nend\n</cell>\n<code language=julia-1.3>\n\
    @time make_a_pile(20)\n</cell>\n<text>\nQuestion 1.2 Q\nHow many ways can you\
    \ make a pile with 5 levels and 5 stones?", "    v = zeros(Int, n)\n    if n %\
    \ 2 == 1 \n        v[1] = n-1\n    else\n        v[1] = n\n        v[ceil(n)+1]\
    \ = 1\n    end\n    for i in 2:(n+1)\n        v[i] = v[i-1]+v[i-2]\n    end\n\
    \    return v\nend\n</cell>\n<text>\nPart 2: Monte Carlo Simulation", "    if\
    \ n == 1 \n        [1]\n    elseif n % 2 == 0\n        [2*n - 1]\n    else\n \
    \       make_a_pile(n-1) + [n mod 2]\n    end\nend\n</cell>\n<text>\nExercise\
    \ 4\nWrite a function called merge_piles that takes as input a vector of piles,\
    \ and merges them into one big pile. \nHere is a rough outline of how the function\
    \ should work:", "    if n==1 return [1]\n    if n==2 return [3,5]\n    if n==3\
    \ return [5,7]\n    if n==4 return [5,5,5]\n    if n==5 return [5,7,7,5]\n   \
    \ if n==6 return [7,7,7,7,5]\n    if n==7 return [7,7,7,7,7,7]\n    return make_a_pile(n-1)[end-2]\
    \ + make_a_pile(n-2)[end-1]\nend\n</cell>\n<code language=julia-1.0>", "    if\
    \ n==0 \n        Vector{}\n    else\n        make_a_pile(div(n,2))+[div(n,2)+1]\n\
    \    end\nend", "    pile = Vector{Int64}()\n    if n==0 \n        push!(pile,\
    \ 0)\n    else \n        push!(pile, make_a_pile(n-1))\n        if mod(n, 2)==0\
    \ \n            push!(pile, n / 2)\n        else \n            push!(pile, n /\
    \ 2 + 1)\n        end\n    end\n    return pile\nend", "    \n    if n==1 \n \
    \       return [1] \n    \n    \n    stone_numbers = make_a_pile(n-1) # stone_numbers\
    \ is now a list of n elements. \n    \n    if mod(n,2) ==0 # if n is even\n  \
    \      stone_numbers[end] = stone_numbers[end] + 1\n    else \n        stone_numbers[end]\
    \ = stone_numbers[end] + (n-1) # if n is odd\n    return stone_numbers \nend",
  "    if n == 0\n        return [1,1]\n    elif n % 2 == 0\n        odd_sum = make_a_pile(n\
    \ >> 1)\n        return [odd_sum[end] + 1, odd_sum[end]] \n    else\n        even_sum\
    \ = make_a_pile(n >> 1)\n        odd_sum = make_a_pile(n >> 1)\n        return\
    \ [even_sum[end] + 1, odd_sum[end]] \nend\n</cell>\n<code language=julia-1.5>\n\
    # test your code\ntest_make_a_pile()\n</cell>\n<text>\nExercise 4: Parallelize\
    \ your code\nYour code above is extremely inefficient. You call make_a_pile(n)\
    \ n! times!\nCan you speed it up by parallelizing the code?", "    if n % 2 ==\
    \ 0 \n        make_a_pile(n+1)\n    else \n        make_a_pile(n-2)\n    end\n\
    end\n</cell>\n<text>\nFor this next function, you have to make a pile of n stones.\n\
    If n is even, then there are n stones in the first level and n+1 stones in the\
    \ next.\nIf n is odd, then the remaining n-2 stones are in the first level, n\
    \ stones are in the second level, and n-1 stones are in the next.\nIf n is even,\
    \ then there are n stones in the first level and n+1 stones in the next.\nIf n\
    \ is odd, then the remaining n-2 stones are in the first level, n stones are in\
    \ the second level, and n-1 stones are in the next.\nWrite a function make_a_pile(n)\
    \ which takes an integer n and returns the number of stones in a pile\nwhere the\
    \ first level has n stones and next level has n+1 stones.", "    \"\"\"\n    Given\
    \ a positive integer n, you have to make a pile of n levels of stones.\n    The\
    \ first level has n stones.\n    The number of stones in the next level is:\n\
    \        - the next odd number if n is odd.\n        - the next even number if\
    \ n is even.\n    Return the number of stones in each level in a vector, where\
    \ element at index\n    i represents the number of stones in the level (i+1).",
  "    if n==1\n        [1]\n    elseif n==2\n        [1,2]\n    elseif n==3\n   \
    \     [1,2,3]\n    else\n        n,remainder = divmod(n,3)\n        [make_a_pile(remainder),make_a_pile(3)]\n\
    \    end\nend\n</cell>\n<text>\nThe third pile\nThe third pile can be formed by\
    \ taking 3 stones from the first pile and 1 from the second pile.", "    return\
    \ Int64[]\n</code>\n<|/ q dscore=1 |>\n<| c |>\n`Int64` is 64-bits, but your function\
    \ is only defined for 32-bit ints. What should `make_a_pile(500000000)` return?\n\
    <|/ c |>\n<| c |>\n500000000 is too large to fit into a 32-bit integer. Maybe\
    \ `Int64` would not be the right type for the function?\n<|/ c |>\n<| c |>\nIt\
    \ depends on how you decide to solve the problem. Should it be an `Int64`? Then\
    \ you will have to write your own `Int` type.\n<|/ c |>\n<| c |>\nIt seems like\
    \ your assignment was to create a recursive function that takes in `n` as a parameter\
    \ (which is an `Int64`). You just have to make a few minor changes to your code\
    \ to make it work. After you have made those changes, you can test your function,\
    \ and if it works, you can use the `make_a_pile` function on any `Int64`.\n<|/\
    \ c |>\n<| c |>\nI suggest you first try to write a simple test function using\
    \ only integers that return `true` or `false` when you try to make a pile. Then,\
    \ once you've got that working, then you can start looking at how to make the\
    \ piles using recursion.\n<|/ c |>\n<| a tags=julia,stack |>\nBased on my comments,\
    \ here is a solution that uses the standard recursive function. This is the function\
    \ I will be using to make a pile:\n<code>", "    if n==0\n        []\n    else\n\
    \        odd::Int64 = n % 2\n        [make_a_pile(n-1) + odd] ++ make_a_pile(n\
    \ / 2)\n    end\nend\n</cell>\n<code language=julia-1.6>\nmake_a_pile(4)\n</cell>\n\
    <text>\nNow let's write a function counting_stones, which will return the number\
    \ of different stones you can make on a given pile:", "    vec = Vector{Int64}(undef,n)\n\
    \    vec[1] = n\n    for i in 2:n\n        vec[i] = if n % 2 == 1\n          \
    \         2 * vec[i-1] + vec[i-2]\n                else\n                   vec[i-1]\
    \ + vec[i-2]\n    end\n    return vec\nend", "    # Your code here\n    result\
    \ = Array{Int64}(undef, n+1)\n    result[1] = 1\n    result[2] = 3\n    if mod(n,\
    \ 2) === 0\n        result[2] = result[2] + result[1]\n        result[1] = result[2]\
    \ - result[1]\n    end", "    if n == 0 return [0]\n    level = make_a_pile(n-1)\n\
    \    if n % 2 == 1 level[1] += n\n    return level", "    stones = [1]\n    while\
    \ n > 1\n        if n%2 == 1\n            stones.append(stones[n-1])\n       \
    \     n = n/2\n        else\n            stones[n] = stones[n-1] + stones[n-1]\n\
    \            n = n/2\n        end\n    end\n    stones\nend", "    if n == 0 \n\
    \        return Vector{Int64}() \n    else if n % 2 == 1 \n        odd_pile =\
    \ make_a_pile(n div 2)\n        return odd_pile + [n div 2] \n    else \n    \
    \    even_pile = make_a_pile(n div 2)\n        return even_pile\n    end\nend",
  "    \n    # Write your solution here\n    if n%2 != 0\n        odds = n-1\n   \
    \ else\n        odds = 0\n    end\n    return make_a_pile(odds) ++ make_a_pile(evens)\n\
    end", "    if n == 1 \n        return [1]\n    \n    if n % 2 == 0 \n        return\
    \ make_a_pile(n / 2::Int64) + make_a_pile((n / 2+1)::Int64) \n    else \n    \
    \    return make_a_pile(n / 2::Int64) + make_a_pile((n / 2 + 1)::Int64) + [1]\n\
    end\n</cell>\n<code language=julia-1.4>", "    if n % 2 == 1 \n        make_a_pile(n-1)\n\
    \    else \n        make_a_pile(n-2) + [(n-2) % 2 ? 1 : 2]\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nHow is this different than `make_a_pile(n) = [(n-2) % 2 ? 1 :\
    \ 2 for n in 1:n]`?\n<|/ c |>\n<| c |>\nI posted this before I saw your comment\
    \ about your solution. It is a little different because it returns a vector rather\
    \ than a scalar like `make_a_pile(n)`.\n<|/ c |>\n<| c |>\nAnd what is the point\
    \ of returning a vector when n is even? It is not clear what is the intended purpose\
    \ of the function.\n<|/ c |>\n<| a tags=julia,loops,for-loop,function,if-statement\
    \ |>\nThe function can be written like this:\n<code>", "    if n == 0\n      \
    \  vec[]\n    else\n        # count odd numbers\n        odd_counter = 1\n   \
    \     # count even numbers\n        even_counter = 1\n        # for each level\n\
    \        for lvl = 1:n-1\n            # count odd or even\n            counter\
    \ = if n%2 == 0\n                even_counter\n            else\n            \
    \    odd_counter\n            end\n            # add to pile\n            push!(vec,\
    \ counter)\n        end\n    end\nend\n</code>\n<|/ a dscore=2 tags=julia,function,arrays\
    \ |>\n<| c |>\nThank you for your answer - I edited my question to make it clearer\
    \ - how could I implement your solution in a function?\n<|/ c |>\n<| c |>\nI think\
    \ your solution is still correct - but I want the function to return an array\
    \ of integers rather than an array of vectors. Is this possible?\n<|/ c |>\n<|\
    \ c |>\n`if n%2 == 0\n                even_counter\n            else\n       \
    \         odd_counter\n            end`  you can change the conditional to `if\
    \ n%2 == 0\n                even_counter\n            else\n                odd_counter\
    \ - n\n            end`\n<|/ c |>\n<| c |>\nThanks! I edited my answer to account\
    \ for the new requirements. Is this what you meant?\n<|/ c |>\n<| c |>\nThis is\
    \ perfect, thank you so much. Could you explain what the code does so that I can\
    \ learn from it?\n<|/ c |>\n<| a tags=julia,function,arrays dscore=1 |>\nYou can\
    \ try using repmat like below:\n<code>\njulia> A=reshape(repmat(1:10,3,2),:)\n\
    3x3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n 7  8  9", "    n = n // 2 \n    i =\
    \ 0\n    pile = Vector{Int64}(n)\n    while i < n\n        pile[i+1] = n + (i%2\
    \ == 0) \n        i = i + 1\n    end\n    return pile\nend\n</cell>\n<code language=julia-1.5>",
  "    if n == 0 \n        vec() \n    else \n        make_a_pile(n - 1) \n      \
    \  push!(vec, n + n/2) \n    end\nend", "    if n==0 \n        Vector{Int64}()\n\
    \    elseif n % 2 == 1 \n        Vector{Int64}(n, 0)\n    else \n        Vector{Int64}(0,\
    \ make_a_pile(n - 2))\n    end\nend\n</cell>\n<text>\nExercise: Implement a function\
    \ that given a positive integer n, returns true or false whether it is possible\
    \ to draw a pile with n stones.", "    if n == 0 return [0]\n    elif n % 2 ==\
    \ 0 \n        p =  n : make_a_pile( p )\n    else\n        p =  n-1: make_a_pile(\
    \ p )\n    end\n    return p \nend", "    vec = Vector{Int64}(undef, n+1)\n  \
    \  vec[1] = n\n    i = 2\n    while i <= n\n        vec[i] = math.floor((n-i)/2)\n\
    \        i = i+1\n    return vec\nend\n</cell>\n<code language=julia-1.0>", " \
    \   if n>0\n        make_a_pile(odd?n:n)\n        make_a_pile(even?n:n)\n    \
    \    return \n    end\n    return \nend", "    if n%2 == 0 \n        make_a_pile(n-1)\n\
    \    else \n        make_a_pile(n-2)\nend", "    if n == 0 \n        Vector{Int64}()\
    \ \n    else \n        make_a_pile(n / 2) do n \n            if n % 2 == 1 \n\
    \                Int(n + 1)\n            else \n                Int(n) \n    \
    \        end \n        end\n    end\nend", "    pile = Array{Int64}(undef, (n+1)/2)\n\
    \    for i in 1:(pile.length - 1)\n        pile[i] = n\n        if mod(n, 2) ==\
    \ 0 \n            n = n div 2\n        else\n            n = n - (n div 2)\n \
    \       end\n    end\n    return pile\nend", "    even = n % 2 == 0\n    num_levels\
    \ = if even \n                    n // 2 + 1\n                else\n         \
    \           n // 2 + 2\n    num_levels[end] = num_levels[end] - 1 if num_levels[end]\
    \ > 0 else 1\n    return num_levels\nend\n</code>\n<|/ a |>\n<| c |>\nThis isn't\
    \ a bad solution, but it is O(n^2). The OP specifically asked for the O(n) solution.\n\
    <|/ c |>\n<| a tags=algorithm,dynamic-programming |>\nThis is an example in Mathematica\
    \ which solves the above problem by finding the length of the longest pile with\
    \ the specified number of piles.\n<code>\nPile = {{{1, 2, 3, 4}, {5, 6, 7, 8,\
    \ 9}, {10, 11, 12, 13}}};", "    if n % 2 == 0\n        [n, n*n ]\n    else\n\
    \        [n-1, n-1, n-1, n]\n    end\nend", "    if n % 2 == 0 \n        n = (n\
    \ * 3) + 1\n    else\n        n = (n * 3) + 1\n    end", "    if n == 0 \n   \
    \     return Vector{Int64}(0)\n    else\n        if n % 2 == 0\n            return\
    \ make_a_pile(n / 2) + [n % 2]\n        else\n            return make_a_pile(n\
    \ / 2) + [n // 2]\n        end\n    end\nend", "    if n <= 0 \n        return\
    \ Vector{Int64}() \n    else \n        if mod(n,2) == 1 \n            n = n *\
    \ 2 - 1 \n        else \n            n = n * 2 - 3 \n        pile = Vector{Int64}()\
    \ \n        push!(pile, n) \n        while n != 1 \n            n = (n + 2)/2\n\
    \            push!(pile, n) \n        end\n        return pile \n    end\nend\n\
    </cell>\n<code language=julia-1.0>\n@time \nmake_a_pile(1000000);\n</cell>\n<text>\n\
    Exercise 1: Using a pile of stones, find the number of levels in each pile.\n\
    Write a function to return the number of levels in each pile, where element at\
    \ index i represents the number of levels (i+1) in that pile.\nThe input is a\
    \ vector of piles (where element i represents the number of levels in pile[i]),\
    \ and the output is a vector of the same length as the input where each element\
    \ represents the number of levels in that pile.", "    return Vector{Int64}(n\
    \ + 1) |> Vector{Int64}\nend\n</cell>\n<code language=julia-1.0>\n# Solution 2",
  "    stone_levels = [0 for _ in 1:n]\n    for i in 1:n\n        stone_levels[i]\
    \ = i % 2 == 0 ? odd_or_even(i) : even(i) \n    end\n    return stone_levels\n\
    end\n</cell>\n<code language=julia-1.0>\n# Check\nmake_a_pile(6)\n</cell>\n<code\
    \ language=julia-1.0>", "    if n % 2 == 0 then\n        n = n - 1\n        make_a_pile(n)\n\
    \    else\n        make_a_pile(n - 1)\n    end\nend\n</cell>\n<code language=julia-1.0>",
  "    if mod(n,2) == 0 \n        make_a_pile(n-1)\n        return [1]\n    else \n\
    \        make_a_pile(n-1)\n        return [2]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    # using BenchmarkTools\n# make_a_pile(11)\n</cell>\n<text>\nExercise: Rewrite\
    \ make_a_pile() so that it does not need to make a copy of the entire pile.\n\
    Use @code_native to find out what the generated assembly code is, and compare\
    \ it to the equivalent version written as a function.", "    if n > 0\n      \
    \  if n%2 == 1\n            return make_a_pile(n//2)+[n%2]\n        else\n   \
    \         return make_a_pile(n//2)+[2*n%2]\n    end\n    return make_a_pile(1)\n\
    end", "    if n<0\n        error(\"n should be positive\")\n    end\n    stone_levels\
    \ = ones(Int, n)\n    level = 1\n    while level < n\n        stone_levels[level]\
    \ = stone_levels[level-1] + 2\n        if n%2 == 1\n            stone_levels[level]\
    \ = stone_levels[level] + 1\n        end\n        level = level + 1\n    end\n\
    \    return stone_levels\nend", "    if n == 0\n        return [1,1,1]\n    if\
    \ n % 2 == 1\n        return make_a_pile(n-1)\n    if n == 1 \n        return\
    \ [n,n,n]\n    \n    return make_a_pile(n-1) + make_a_pile(n-2) + [n, n, n]\n\
    end\n</cell>\n<code language=julia-1.4>\nmake_a_pile(2)\n</cell>\n<text>\nQuestion\
    \ 4: What is the probability that the next number in the pile is odd?\nWhat is\
    \ the probability that the next number in the pile is even?\nWhat is the probability\
    \ that the next number in the pile is odd? What is the probability that the next\
    \ number in the pile is even?", "    if n == 1\n        return [1]\n    elseif\
    \ n % 2 == 0\n        return make_a_pile(n / 2) + [n / 2]\n    else\n        return\
    \ make_a_pile(n / 2) + make_a_pile(n / 2)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    make_a_pile(10)\n</cell>\n<text>\nExercise 2.21\nWrite a function find_pile(size::Int64,\
    \ stones::Vector{Int64})::Int64 where stones is an array where each element represents\
    \ the number of stones in the corresponding pile. Return the size of the largest\
    \ pile.", "    if n == 0 \n        return zeros(Int64, n+1)\n    \n    stones\
    \ = make_a_pile(floor(n/2))\n    if mod(n, 2) == 1 \n        stones[end] = stones[end]\
    \ + stones[end-1]\n    end\n    return stones\nend", "    \n    \n    \n    ",
  "    if mod(n,2) == 0 \n        return Vec(make_a_pile(n div 2) + [n div 2])\n \
    \   elseif n ==0 \n        return zeros(0)\n    else\n        return make_a_pile(n\
    \ div 2) + [n div 2]\n    end\nend\n\"\"\"\n    Given a positive integer n, you\
    \ have to make a pile of n levels of stones.\n    The first level has n stones.\n\
    \    The number of stones in the next level is:\n        - the next odd number\
    \ if n is odd.\n        - the next even number if n is even.\n    Return the number\
    \ of stones in each level in a vector, where element at index\n    i represents\
    \ the number of stones in the level (i+1).", "    if n==1 return [1]\n    if n==2\
    \ return [2,3]\n    if n%2==0 \n        odd_n = make_a_pile(n/2) \n        return\
    \ odd_n+[odd_n[1]+3]\n    else \n        even_n = make_a_pile(n/2) \n        return\
    \ even_n+[even_n[1]+3]\n    end \nend", "    if n%2 != 0 \n        n = n+1 \n\
    \    level::Vector{Int64} = [n]\n    for i in 2:n\n        if n%2 == 0 \n    \
    \        level[i] = level[i-1]+1 \n        else\n            level[i] = level[i-1]+2\
    \ \n        end\n    end\n    return level\nend\n</cell>\n<text>\nExercise 4\n\
    Write a function that takes a positive integer n and returns an integer representing\
    \ the number of stones in the pile.", "    if n % 2 == 1 \n        return make_a_pile(n/2)\n\
    \    else\n        odds = 3\n        evens = 2\n        n2 = n-1\n        while\
    \ n2 != 0 \n            if n2 % 2 == 0\n                evens += 1\n         \
    \       n2 = n2/2\n            else\n                odds += 1\n             \
    \   n2 = n2/2\n        end\n        return Vector(evens,odds)\n    end\nend",
  "    if n<0 return []\n    y=zeros(Int64, (n+1)/2)\n    if n%2 == 0 y[end] = 1\n\
    \    else y[end] = 2\n    make_a_pile_aux(n,y)\nend", "    return Vector{Int64}(undef,n+1)\n\
    end", "    if n==1\n        return [1]\n    \n    if n%2==1\n        i=2\n   \
    \     odds=[1,3]\n    else\n        i=1\n        odds=[1,3]\n    end", "    \n\
    \    if n==0 \n        Vector{Int64}(0) \n    else \n        odd_count=ceiling(log2(n))\n\
    \        even_count=floor((log2(n)+1)/2)\n        level_count=odd_count+even_count\n\
    \        levels=make_a_pile(ceil(log2(n)))\n        levels[level_count]=n\n  \
    \      levels=levels[2:end]\n        levels[end-1]=(levels[end-1]+n)/2\n     \
    \   levels[end]=n\n        levels\n    end\nend\n</cell>\n<code language=julia-1.0>",
  "    if n == 1 \n        return Vector{Int64}([1])\n    else \n        even = make_a_pile(n\
    \ / 2)\n        odd = make_a_pile(n mod 2)\n        total = (even * 2) + (odd\
    \ * 1)\n        total[n % 2:] = total[n % 2:] - 1\n        return total\n    end\n\
    end", "    \n    # base case\n    if n == 1 \n        pile = [1]\n        return\
    \ pile", "    \nend\n</cell>\n<cell>\n#export", "    if n==0 then return [Int64[]]\
    \ \n    even = if mod(n, 2) == 1 then 0 else 1 \n    return [make_a_pile(n-1)\
    \ + even + Int64[n%2 == 0]]\nend", "    levels = vec()\n    levels[1] = n\n  \
    \  levels[2] = n\n    if n % 2 == 1\n        levels[3] = 2 * n\n    else\n   \
    \     levels[3] = n / 2\n    return levels\nend\n</cell>\n<text>\nExercise 10\n\
    Write a function that takes a positive integer $n$ and returns the number of ways\
    \ to make the pile of $n$ levels. Use the function you wrote in Exercise 8 (make_a_pile())\
    \ for the solution. You might want to use the function you wrote in Exercise 7.",
  "    \n    firstLevel = n % 2 == 0 ? n : n + 1\n    secondLevel = (n - firstLevel)\
    \ / 2\n    thirdLevel = n - secondLevel\n    return firstLevel ++ secondLevel\
    \ ++ thirdLevel\nend", "    if n % 2 == 1 \n        n += 1 \n    else \n     \
    \   n += floor(n/2) \n    return Int64[n:]\nend", "    if n % 2 == 0 \n      \
    \  odd_numbers = make_a_pile(n / 2)\n    else\n        even_numbers = make_a_pile(n\
    \ / 2)\n        odd_numbers = make_a_pile(n-1)\n    end", "    if n % 2 == 0\n\
    \        n / 2\n    else\n        3 * n + 1\n    end \nend", "    if n==1 \n \
    \       vec = []\n    else \n        vec = make_a_pile(n-1) + make_a_pile(n-2)\n\
    \    return vec\n</code>\n<|/ a tags=dynamic-programming,math,algorithm,combinatorics,permutation\
    \ |>\n<| a dscore=0 |>\nI solved this by taking the cartesian product of the set\
    \ {1, 2, 3, 4} with the set {2, 3, 4, 5}. First I create the cartesian product\
    \ of {1, 2, 3, 4} with {2, 3, 4, 5}, then I create the cartesian product of {2,\
    \ 3, 4, 5} with {1, 2, 3, 4} and so on until the result contains 4 numbers. \n\
    I then subtract each number from the cartesian product of {1, 2, 3, 4} with {2,\
    \ 3, 4, 5}, i.e. I subtract 1 from each number in the cartesian product of {1,\
    \ 2, 3, 4} with {2, 3, 4, 5}. I then sum each of these numbers and subtract them\
    \ from the cartesian product of {1, 2, 3, 4} with {2, 3, 4, 5}. The result is\
    \ the number of permutations needed to make the cartesian product of {1, 2, 3,\
    \ 4} with {2, 3, 4, 5}. \nThis process can be repeated for each value in the cartesian\
    \ product of {1, 2, 3, 4} with {2, 3, 4, 5}, until each value in the cartesian\
    \ product of {1, 2, 3, 4} with {2, 3, 4, 5} is subtracted from the cartesian product\
    \ of {1, 2, 3, 4} with {2, 3, 4, 5}. For example, if I started with {1, 2, 3,\
    \ 4}, then {2, 3, 4} would be subtracted from {1, 2, 3, 4}. Then {3, 4} would\
    \ be subtracted from {2, 3, 4} and {4} would be subtracted from {3, 4}. So in\
    \ the end I subtracted {1, 2, 3, 4} from {1, 2, 3, 4}, {2, 3, 4} from {2, 3, 4},\
    \ {3, 4} from {3, 4} and {4} from {4} giving the total number of permutations.\n\
    <|/ a tags=dynamic-programming,math,algorithm,combinatorics,permutation |>\n<|\
    \ a dscore=0 |>\nA simple recursive function will do the trick:\n<code>", "  \
    \  if n % 2 == 1\n        make_a_pile(n-2)\n    else \n        make_a_pile(n-1)\n\
    \    end\nend", "    \n    arr = Vector{Int64}(undef,n)\n    arr[1] = 1\n    for\
    \ i in 2:(n-1)\n        if n % 2 == 1\n            arr[i] = arr[i-1] + 2\n   \
    \     else\n            arr[i] = arr[i-1] + 1\n        end\n    end\n    arr\n\
    end\n</cell>\n<text>\nExercise\nUse a for loop to count the number of elements\
    \ in the following pile:", "    if n % 2 == 0 \n    then make_a_pile(n / 2) \n\
    \    else make_a_pile(n / 2) + [n % 2]\nend", "    if n==1\n        return [1]\n\
    \    elif n%2 == 1\n        odd_pile = make_a_pile(n-1)\n        even_pile = make_a_pile(n-1)\n\
    \        return odd_pile + even_pile\n    else\n        even_pile = make_a_pile(n-1)\n\
    \        return even_pile\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    # Q5", "    if n == 0 \n        return Vector{Int64}([]) \n    else \n       \
    \ return make_a_pile(n % 2 == 0 ? n + 2 : n) + [n % 2] \nend\n</cell>\n<cell>\n\
    @testset \"make_a_pile\" begin\n    test_cases = [\n        (1, Vector{Int64}([3])),\n\
    \        (2, Vector{Int64}([3, 5])),\n        (3, Vector{Int64}([3, 5, 7])),\n\
    \        (4, Vector{Int64}([3, 5, 7, 9])),\n        (5, Vector{Int64}([3, 5, 7,\
    \ 9, 11])),\n        (6, Vector{Int64}([3, 5, 7, 9, 11, 13])),\n        (7, Vector{Int64}([3,\
    \ 5, 7, 9, 11, 13, 15])),\n        (8, Vector{Int64}([3, 5, 7, 9, 11, 13, 15,\
    \ 17])),\n        (9, Vector{Int64}([3, 5, 7, 9, 11, 13, 15, 17, 19])),\n    \
    \    (10, Vector{Int64}([3, 5, 7, 9, 11, 13, 15, 17, 19, 21])),\n        (100,\
    \ Vector{Int64}([3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23])),\n    ]", "    arr\
    \ = Array.zeros(Int, n+1)\n    for i in 1 : n\n        if i %% 2 ==0\n       \
    \     arr[i+1] = i\n        else\n            arr[i+1] = i+1\n        end\n  \
    \  end\n    arr\nend\n</code>\n<|/ a |>\n<| c |>\nWelcome to Stack Overflow! This\
    \ answer might solve the problem, but a good answer should also explain **what**\
    \ the code does and **how** it helps solve the problem. Take a few minutes to\
    \ read through the [How do I write a good answer](https://stackoverflow.com/help/how-to-answer)\
    \ guide, and consider editing your answer.\n<|/ c |>\n<| a tags=julia |>\n<code>\n\
    # n = number of levels\n# n-1 is the number of stones in the first level\n# n-2\
    \ is the number of stones in the second level\n# n-3 is the number of stones in\
    \ the third level", "    if n == 1\n        return [1]\n    \n    if n % 2 ==\
    \ 1\n        return make_a_pile(n - 2) + [1]\n    \n    evens = make_a_pile(n\
    \ / 2)\n    odds = make_a_pile(n / 2)\n    \n    odds *= odds\n    \n    evens\
    \ = odds\n    \n    return evens + odds\nend", "    stones = zeros(n)\n    \n\
    \    if n % 2 == 1 \n        stones[n % 2 == 0] += 1\n    else \n        stones[(n\
    \ / 2)%2 == 1] += 1\n    \n    return stones\nend ", "    \"\"\"\n    Given a\
    \ positive integer n, you have to make a pile of n levels of stones.\n    The\
    \ first level has n stones.\n    The number of stones in the next level is:\n\
    \        - the next odd number if n is odd.\n        - the next even number if\
    \ n is even.\n    Return the number of stones in each level in a vector, where\
    \ element at index\n    i represents the number of stones in the level (i+1).",
  "    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels\
    \ of stones.\n    The first level has n stones.\n    The number of stones in the\
    \ next level is:\n        - the next odd number if n is odd.\n        - the next\
    \ even number if n is even.\n    Return the number of stones in each level in\
    \ a vector, where element at index\n    i represents the number of stones in the\
    \ level (i+1).", "    if n==0 return [1]\n    if n%2==0 return make_a_pile(n/2)+[(n+1)%2]\n\
    \    else return make_a_pile(n/2)*[(n+1)%2]\nend", "    if n == 0 \n        return\
    \ Vector{Int64}()\n    even = make_a_pile(n/2)\n    odd = make_a_pile(n/2 + 1)\n\
    \    odd[end] = odd[end] + even[end]\n    odd\nend", "    \n    pile::Vector{Int64}\
    \ = []\n    if n < 0\n        error(\"Negative number of piles\")\n    end\n \
    \   if n == 1\n        push!(pile, n)\n        return pile\n    end\n    \n  \
    \  level::Int64 = n/2\n    push!(pile, level)\n    if mod(n, 2) == 0\n       \
    \ push!(pile, n-1)\n    else\n        push!(pile, n)\n    end\n    return pile\n\
    end\n</cell>\n<code language=julia-1.6>\n\"\"\"\n    remove_from_pile(p::Vector{Int64},n::Int64)",
  "    pile = [n]\n    if n==0 return pile\n    if n==1 return [1]\n    if n % 2 ==\
    \ 0 \n        pile = [pile[1], pile[2]]\n    else\n        pile = [pile[2], pile[1]]\n\
    \    end\n    \n    pile[end] = make_a_pile(n / 2)\n    \n    return pile\nend\n\
    </cell>\n<text>\nLet's test your function", "    if n % 2 == 1 \n        evens\
    \ = make_a_pile(n / 2)\n        odds = make_a_pile((n - 1) / 2)\n        return\
    \ (evens + odds)\n    else\n        evens = make_a_pile((n - 1) / 2)\n       \
    \ return evens\n    end\nend", "    if n % 2 == 1\n        odds <- make_a_pile(n\
    \ / 2)\n        odds <- odds + [n % 2]\n    else\n        evens <- make_a_pile(n\
    \ / 2)\n        evens <- evens + [n / 2]\n    return odds + evens\nend", "   \
    \ return fill(0, n+1, 0)\nend", "    if n % 2 == 0 \n        stone_count = [n+1]\n\
    \    else\n        stone_count = [n-1, n-2, n-3]\n    end\n    return stone_count\n\
    end", "    \n\"\"\"\n    The number of stones in the pile of n levels is given\
    \ by:", "    if n % 2 == 0 \n        odds = odds(n) \n        evens = evens(n)\
    \ \n        pile = odds + evens\n    else \n        odds = odds(n-1) \n      \
    \  evens = evens(n-1) \n        pile = odds + evens\n    return pile\nend\n</cell>\n\
    <cell>\nmake_a_pile(6)\n</cell>\n<text>\nQuestion: What is the smallest n so that\
    \ we get a pile of length at least n?", "    if n % 2 == 0\n        pile = [n]\n\
    \    else\n        pile = [n-1, n/2]\n    end\n    return pile\nend", "    pile\
    \ = zeros(Int64, n, 2)\n    for i in 1:n-1\n        if i%2 == 1\n            pile[i,\
    \ 1] = i\n        else\n            pile[i, 1] = i + 1 \n        end\n    end\n\
    \    return pile\nend", "    if n == 2\n        return Vector{Int64}([n])\n  \
    \  pile = make_a_pile(n-1)\n    push!(pile, n//2)\n    if n % 2 == 0\n       \
    \ push!(pile, n)\n    end\n    return pile\nend", "    if n<2 \n        return\
    \ Int64[]\n    end\n    stones = make_a_pile(n div 2)\n    if mod(n, 2) == 0 \n\
    \        push!(stones, n div 2)\n    else\n        push!(stones, ceil(n/2))\n\
    \    end\n    stones\nend\n</cell>\n<text>\nNow let's make two piles from one\
    \ another:", "    \"\"\"\n    Given a positive integer n, you have to make a pile\
    \ of n levels of stones.\n    The first level has n stones.\n    The number of\
    \ stones in the next level is:\n        - the next odd number if n is odd.\n \
    \       - the next even number if n is even.\n    Return the number of stones\
    \ in each level in a vector, where element at index\n    i represents the number\
    \ of stones in the level (i+1).\n    \"\"\"\n    \n    # Your code here\n    a_pile\
    \ = zeros(Int, n+1)\n    a_pile[1] = n\n    \n    if n % 2 != 0: a_pile[2] = floor(n\
    \ / 2)\n    else: a_pile[2] = (n+1) * floor((n+1)/2) \n    \n    return a_pile\n\
    end", "    if n % 2 == 0\n        return (make_a_pile(n + 1) + make_a_pile((n\
    \ div 2) + 1)) * 2\n    else\n        return make_a_pile((n div 2) + 1)\nend\n\
    </cell>\n<text>\nExercise: Implement make_piles()\nImplement the make_piles()\
    \ function.", "    stones = [0 for i in 1:n]\n    stones[2] += 1\n    if n rem\
    \ 2 == 1\n        stones[2] += 1\n    end", "    if n==1 \n        []\n    else\n\
    \        make_a_pile(floor(n/2)) \n        push!(make_a_pile(n-floor(n/2)),floor(n%2))\n\
    \    end\nend", "    a_pile = Vector{Int64}(undef, n+1)\n    a_pile[1] = n\n \
    \   level = 1\n    while level < n\n        if n%2 == 1\n            a_pile[level+2]\
    \ = n+1\n        else\n            a_pile[level+2] = 1\n        end\n        level\
    \ += 1\n    end\n    return a_pile\nend", "    if n == 0\n        return Vector{Int64}(0)\n\
    \    pile = Vector{Int64}(0)\n    if n % 2 == 1\n        pile = pile:+(make_a_pile(n\
    \ / 2))\n    end\n    pile = pile:+(make_a_pile(n / 2) + make_a_pile(n / 2))\n\
    \    return pile\nend\n</code>\n<|/ a tags=dynamic-programming,algorithm |>\n\
    <| c |>\nIt's better than my approach with iteration, though it still uses loops.\
    \ I added a dynamic programming approach that doesn't use any loops at all. :)\n\
    <|/ c |>\n<| c |>\nI like the dynamic programming approach, thanks for the detailed\
    \ explanation! Though the first solution still uses loops right? It just hides\
    \ them in recursive function calls. :)\n<|/ c |>\n<| c |>\nYes, the first solution\
    \ still uses loops, as it's using a loop that calls the same function again and\
    \ again :)\n<|/ c |>\n<| a tags=dynamic-programming,algorithm dscore=1 |>\n<code>\n\
    #include<bits/stdc++.h>", "    if n == 0\n        Vector{Int64}()\n    else\n\
    \        make_a_pile(n - 1) + [n % 2 == 0 ? 1 : 2, n % 2 == 0 ? 1 : 2]\n    end\n\
    end", "    if n==0 return []\n    if n==1 return [1]\n    if n % 2 == 0 return\
    \ make_a_pile(2*n) + [1]\n    return make_a_pile(2*n) + make_a_pile(2*n+1)\nend",
  "    if n==0\n        return [0,]\n    if n%2 != 0\n        n += 1\n        \n \
    \   end = (n+1)/2\n    \n    pile = make_a_pile(end)\n    pile = [pile[0]+n,]\
    \ + pile\n    \n    return pile\nend", "    n = n % 2 ? n : n-1\n    if n == 1\n\
    \        return Int64[]\n    ret = Int64[]\n    i = 1\n    while i <= n\n    \
    \    ret[i] = n\n        i += i & 1\n    end\n    return ret\nend\n</cell>\n<code\
    \ language=julia-1.0>\n# Check your answer using 'q4'.\n@assert make_a_pile(1)\
    \ == [1]\n@assert make_a_pile(2) == [1, 3]\n@assert make_a_pile(10) == [1, 7,\
    \ 11, 13, 17, 19, 23, 29]\n</cell>\n<text>\nTo make the piles shorter, we will\
    \ repeat each level n times.\nFor example, piles of 3 levels looks like this:",
  "    if n==1 \n        return [1]\n    if n==0 \n        return [0]\n    \n    pile\
    \ = make_a_pile(n-1)\n    if n % 2 == 0\n        push!(pile, 2*n + 1) \n    else\
    \ \n        push!(pile, 2*n)\n    \n    return pile\nend\n</cell>\n<code language=julia-1.5>",
  "    if n == 1 \n        return [1]\n    \n    pile = make_a_pile(n/2)\n    push!(pile,\
    \ n - pile[-1])\n    push!(pile, n - pile[-2])\n    \n    return pile"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
