name: HumanEval_37_sort_even
language: jl
prompt: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
  \    l' is identical to l in the odd indicies, while its values at the even indicies\
  \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1,\
  \ 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n   \
  \ \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n"
tests: "using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
  \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
  \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
  \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
completions: ["    len = length(l)\n    l1 = sort(l)\n    l1[(1::2)] = l1[(2::2)]\n\
    \    l1[(2::2)] = l1[(1::2)]\n    return l1;\nend", "    if mod(length(l)-1,2)\
    \ == 0\n        return l\n    else\n        return sort(l)\n    end\nend\n</cell>\n\
    <code language=julia-1.6>", "    \n    # create an empty vector and append the\
    \ even indicies to the empty vector\n    l_ = Vector{Int64}()\n    for i in 1:length(l)\n\
    \        if mod(i, 2) == 0\n            l_ = l_ ++ [i]\n        end\n    end",
  "    l = sort(l)\n    l = l[findall(x->x%2 == 0, 1:length(l)) - 1]\nend", "    sorted\
    \ = sort(l)\n    even_inds = findall(l .% 2 == 0)\n    sorted_even_inds = setdiff(even_inds,\
    \ even_inds)\n    result = sort(collect(sorted[sorted_even_inds]), by=first)\n\
    \    return result \nend", "    even, odd = partition(l) \n    even.sort == odd.sort\n\
    \    return even.sorted\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nThis\
    \ should work in Julia:\n<code>\njulia> function sort_even(l::Vector{Int64})\n\
    \           return sort(l)[vec(l)==vec(sort(l))]\n       end\nsort_even (generic\
    \ function with 1 method)", "    evens = vec(l)[findall(mod(l, 2)==0)]\n    evens\
    \ = sort_even(evens)\n    odd = vec(l)[findall(mod(l, 2)==1)]\n    return vcat(evens,\
    \ odd)\nend", "    evens = 1:length(l):2:length(l)\n    evens = evens[sort.(evens)]\n\
    \    evens = sort(evens)\n    evens = l[evens]\n    return evens\nend\n</cell>\n\
    <code language=julia-0.5>", "    sort(l)\n    for i in 2 to length(l)\n      \
    \  l = l[i-1:i-1:-1]\n    end\n    l\nend\n</code>\n<|/ a tags=julia |>\n<| a\
    \ |>\nFor this use case you could use Array{Int64,1} as the input type. This will\
    \ allow you to sort only the first column without losing anything else.\n<code>\n\
    julia> sort([5, 6, 3, 4])\n5-element Array{Int64,1}:\n 3\n 4\n 5\n 6", "    if\
    \ length(l)%2==0\n        l = l[1 : end-1]\n    else \n        l = l[1 : end-2]\n\
    \    end\n    return l\nend", "    if length(l)%2 == 0 \n        return l \n \
    \   end\n    even_indices = collect(1:end-l, by = 2) \n    return sort(l[even_indices])\
    \ \nend", "    even = Int64.(l)\n    odd = Int64.(vec(l)[2:end-1])\n    inds =\
    \ Int64.(vec(l)[2:end-1])\n    sort_even.(vec(even), vec(odd), inds)\n    return\
    \ even\nend", "    if length(l)%2==1 \n        return sort(l) \n    else\n   \
    \     l = l[1:end-1]\n        l = sort!(l)\n        return l\n    end\nend\n</code>\n\
    <|/ a dscore=1 tags=julia |>\n<| a tags=julia |>\nYou can do this with a combination\
    \ of map and sort, or equivalently, with sortperm:\n<code>\nsort_even = x -> sortperm(x)[2::end]\n\
    sort_odd = x -> sortperm(x)[1:end-1]\n</code>\nExample:\n<code>\njulia> sort_even([1,\
    \ 2, 3]);\n3-element Array{Int64,1}:\n 3\n 5\n 4", "    even = l[findall(x ->\
    \ x % 2 == 0, l)]\n    even = even.(unique)\n    return even\nend", "    # make\
    \ sure l is sorted \n    l_sorted = sort(l) \n    l_sorted_odd = copy(l_sorted)\n\
    \    l_sorted_even = copy(l_sorted)\n    # insert odd elements into l_sorted_odd\
    \ \n    for (i, e) in enumerate(l_sorted_odd) \n        if i%2==0 \n         \
    \   l_sorted_odd[i] = l_sorted_even[i+1] \n        end\n    end\n    return l_sorted_odd\n\
    end", "    even = sort(l)\n    odd = sort(even)\n    odd = map(x -> x % 2 == 0\
    \ ? x : x + 1, odd)\n    odd = map(x -> x % 2 == 0 ? 0 : x, odd)\n    \n    return\
    \ union(even, odd)\nend", "    even = l.filter!(x -> x % 2 == 0)\n    even = even.sort_by!((&x),\
    \ rev=true)\n    even = even.collect{x -> x}\nend", "    if length(l)%2 == 0\n\
    \        return l\n    else\n        l = sort(l)\n        l[2::2] = l[0::2]\n\
    \        return l\n    end\nend\n</code>\n<|/ a tags=sorting,julia,algorithm,arrays\
    \ |>\n<| a dscore=2 tags=sorting,julia,algorithm,arrays |>\nA fast and easy way\
    \ to sort the even indices of a vector is to use the even indices as indices to\
    \ access the original vector:\n<code>", "    evens = l[2 .< end]\n    evens =\
    \ sort_even(evens)\n    evens = sort(evens)\n    l[2 .< end] = evens\n    return\
    \ l\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\nIf performance is an\
    \ issue, another possibility is to write a `sort2` function which takes the vector,\
    \ then converts it to an array, then sorts it, then converts it back to a vector.\n\
    <|/ c |>\n<| c |>\nYes, this is probably a better solution, however, for OP's\
    \ example, they already have a vector and they want a new vector. If they had\
    \ a matrix, or some other data structure that allowed random access, that might\
    \ not be the most efficient way to sort the elements.\n<|/ c |>\n<| c |>\nYes,\
    \ but even then, you could do `sort2(vec)[2 .< end]`, which would save a bunch\
    \ of conversions.\n<|/ c |>\n<| c |>\nYes, but that would still be O(n\xB2), so\
    \ I wouldn't recommend it.\n<|/ c |>\n<| c |>\nI'm very sorry to say that this\
    \ doesn't work for me. As far as I can tell, the code you posted still sorts the\
    \ odd indicies, but the even indices are unsorted\n<|/ c |>\n<| a tags=julia,sorting\
    \ |>\nAs a follow-on to my comment, I'll add this as an answer. Here is an implementation\
    \ that uses no extra memory and no conversions.\n<code>\nusing Statistics", " \
    \   if evenindex(l) == 0\n        return l\n    end\n    return sorted(l, init=l[evenindex(l)],\
    \ rev=true)\nend", "    i = Int64(1)\n    s = Int64(0)\n    for n in l\n     \
    \   if n % 2 == 0\n            s = s + n\n        else\n            l = l + (n-1)\n\
    \        end\n    end\n    l = l + (s - 1)\n    return l\nend\n</cell>\n<code\
    \ language=julia-1.0>", "    even = l[findall(l .%2 == 0)]\n    even.sort()\n\
    \    l[findall(l .%2 == 0)] = even\n    return l\nend\n</cell>\n<code language=julia-1.5>\n\
    @time sort_even([5,3,2,6])\n</cell>\n<code language=julia-1.5>\n# test vectorization",
  "    idx = findall(x->mod(x,2) == 0, l) \n    idx2 = findall(x->mod(x,2) == 1, l)\
    \ \n    sort(idx); \n    sort(idx2)\n    for i in idx \n        l[i] = l[i]\n\
    \    end\n    for i in idx2 \n        l[i] = l[i]\n    end\n    return l\nend\n\
    </cell>\n<text>\nWe now test the function", "    new_list = fill(Int64, length(l))\n\
    \    for i=1:length(l) \n        if i%2 ==1\n            new_list[i] = l[i]\n\
    \        else\n            new_list[i] = l[(i-1)/2] \n        end\n    end\n \
    \   return new_list\nend", "    evens = sort(collect(2:length(l)))\n    evens\
    \ = evens[2:end]\n    for v in evens\n        l.insert(v, l[v])\n    end\n   \
    \ l\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nYour solution is elegant, but it\
    \ creates unnecessary copies of the input vector. In my answer I suggested using\
    \ `append!` instead of `insert` and then remove these copies after sorting.\n\
    <|/ c |>\n<| c |>\nAgreed. I didn't think of using `append!` since I was already\
    \ using `sort!` to sort the original list. I'll update my answer.\n<|/ c |>\n\
    <| a |>\nYou can simply use sort! with a custom comparator function:\n<code>",
  "    length(l) <== length(l) &> 1\n    sorted = sort(l)\n    for i = length(sorted)-1,\
    \ 0, -1\n        if i != 0 && sorted[i] != sorted[i-1]\n            return sorted[i-1:i+1]\n\
    \        end\n    end\n    return sorted\nend\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a dscore=0 tags=julia |>\nIn Julia 1.0 you can do:\n<code>\njulia> function\
    \ sort_even(l::Vector{Int64})::Vector{Int64} \n           v = [x for x in l]\n\
    \           v[div(length(v),2)-1:div(length(v),2)] = v[1:div(length(v),2)]\n \
    \          v\n       end\nsort_even (generic function with 1 method)", "    @assert\
    \ length(l)%2 == 1\n    n = (length(l)/2)\n    sorted = sort(l[1:n])\n    evens\
    \ = l[n+1:end]\n    return sorted + evens\nend", "    l' =  [ l[i] if i%2 == 0\
    \ else l[i+1] for i=1:length(l) ]\n    return l'\nend", "    if length(l)%2 !=\
    \ 0\n        error(\"Vector of odd length must be sorted\")\n    end\n    \n \
    \   even = l[end-1:end] # Get even values\n    odd = l[1:end-1]   # Get odd values\n\
    \    even.sort()            # Sort the even values\n    even.push!(0)        \
    \  # Add an even value of 0 at the end\n    even.sort()            # Sort the\
    \ even values again\n    \n    l[end-1:end] = odd # Replace the even indicies\
    \ with the odd indicies\n    return l\nend\n    \n\"\"\"This function takes a\
    \ vector l and returns a vector l' such that\n    l' is identical to l in the\
    \ even indicies, while its values at the odd indicies are equal\n    to the values\
    \ of the odd indicies of l, but sorted.\n    >>> sort_odd([1, 2, 3])\n    [3,\
    \ 2, 1]\n    >>> sort_odd([5, 6, 3, 4])\n    [5, 3, 4, 6]\n    \"\"\"", "    #\
    \ This is for sorting even indicies only\n    # return l # Uncomment this line\
    \ to sort all indicies \n    even_indicies = l[findall((x -> mod(x,2) == 0),l)]\n\
    \    l = l[findall((x -> mod(x,2) == 0),l)]\n    for x in even_indicies\n    \
    \    push!(l,x)\n    end\n    return l\nend", "    if l == [] \n        return\
    \ [] \n    else \n        return sort_odd(l) \nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| a dscore=2 |>\nTo add some context to Jorge's answer, you can see that\
    \ it's easy to find these solutions when the question is \"how do I reverse an\
    \ array\". Let's assume that the arrays are non-overlapping, i.e. they have distinct\
    \ elements that would otherwise be \"reversed\" by swapping the odd elements with\
    \ their even counterparts. A straightforward answer would be to swap the elements\
    \ in the even indices with the elements in the odd indices recursively. For example,\
    \ we can reverse an array of length 3 by swapping its elements in the even indices\
    \ with the elements in the odd indices.\n<code>", "    l = sort(l)\n    even_indicator\
    \ = [i for i in eachindex(l) if i mod 2 == 0]\n    l[even_indicator] = l[even_indicator]\n\
    \    l\nend\n</code>\n<|/ a dscore=2 tags=julia |>\n<| a tags=julia |>\n<code>",
  "    length = length(l)\n    evenIndices = indices(l, 1)\n    evenValue = values(l,\
    \ 1)\n    evenIndices = sortperm(evenIndices)\n    return take(l, evenIndices)\n\
    end\n</code>\n<|/ a tags=julia,vector |>\n<| a |>\nThe accepted answer does not\
    \ take into account that sorting does not imply permutation.\nLet's consider a\
    \ vector a = [1, 2, 3, 3]\nWhen you use sortperm on it, it will return a permutation\
    \ that looks like this:\n<code>\n[2, 3, 1, 3]\n</code>\nThe same is true for sorting\
    \ the array. Take for example the code\n<code>\njulia> a = [1, 2, 3, 3]\n4-element\
    \ Array{Int64,1}:\n 1\n 2\n 3\n 3", "    l = sort(l)\n    even_inds = findall(l\
    \ .% 2 == 0)\n    l = l[even_inds]\n    return l\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a |>\nA \"simple\" one-liner:\n<code>", "    pos = findlast(l==0)\n \
    \   even = sort(l[pos+1:end])\n    odd = sort(l[1:pos])\n    even[1:end] -= odd[1:end]\n\
    \    even\nend\n</cell>\n<code language=julia-1.0>\nsort_even([5,7,4,9,2,6])\n\
    </cell>\n<text>\nExercise 2: Implement a function to return the elements of a\
    \ list which appear the same number of times as the first argument to a function\
    \ (in the list).", "    return l[findall(l==0)]\nend\n</code>\n<|/ a dscore=2\
    \ tags=julia |>\n<| c |>\nIf you could elaborate on the part where `sort_even`\
    \ is defined, that would be great.  I'd love to see how you define the function\
    \ and what it returns.\n<|/ c |>\n<| c |>\nI'm sorry but I don't understand what\
    \ you mean. Could you please elaborate?\n<|/ c |>\n<| c |>\nOk, so `sort_even`\
    \ is defined within the `sort_even` function body.  Could you explain what's happening\
    \ within `sort_even`?  It's not obvious to me.\n<|/ c |>\n<| c |>\nOh, I see,\
    \ this `l[findall(l==0)]` part is returning a vector with the values of `l` except\
    \ those that equal zero.\n<|/ c |>\n<| c |>\nYes, exactly. That's what `findall()`\
    \ does - it finds all the indices of `l` that equal zero.\n<|/ c |>\n<| a dscore=2\
    \ |>\nTo add to what others have said, you can also do the following using sort,\
    \ which also sorts the items in place:\n<code>\njulia> sort(collect(1:10))\n10-element\
    \ Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n 10\n</code>\nThis saves\
    \ another allocation, and is faster than sort_even when dealing with relatively\
    \ small arrays.\n<|/ a tags=julia |>\n<| c |>\nThis does not work: I believe the\
    \ OP is looking to `sort` not `collect` the vector. `collect` returns an array\
    \ that has duplicate values, and `sort` does not remove duplicates.\n<|/ c |>\n\
    <| c |>\nOh, I see. Yeah, you're right, sorry.\n<|/ c |>\n<| a dscore=1 tags=julia\
    \ |>\nA simple implementation of this problem with sorted function.\n<code>",
  "    \"\"\"\n    This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\n</code>\nFinally, this is what the above code is doing:",
  "    # sort even indicies of l\n    even = Vector{Int64}(length(l), 0); # vector\
    \ of even indicies of l\n    for i = 1:length(l)\n        if l[i] % 2 == 0 \n\
    \            even[i] = l[i]\n        else\n            even[i] = sort(l[i])\n\
    \        end\n    end\n    return even\nend", "    even = @inbounds l[1..(length(l)-1)]\n\
    \    odd = @inbounds l[(1+(length(l)-1)):end]\n    return sort(odd) .+ sort(even)\n\
    end", "    l1=l\n    for i in 2:length(l)\n        l1[i]=l1[i-1]\n    end\n  \
    \  return l1\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nYou should add some explanation\n\
    <|/ c |>\n<| c |>\nDone. Hope it helps.\n<|/ c |>\n<| c |>\nYes, it does! Thank\
    \ you!\n<|/ c |>\n<| a tags=julia,sorting,mergesort |>\nIn Julia, there are already\
    \ built-in functions for this!\n<code>\njulia> sort!([1,5,3,5,1,6,2])\n2-element\
    \ Array{Int64,1}:\n 1\n 2\n 3\n 5\n 5\n 6\n 6\n 7\n</code>\nIf you need them to\
    \ be in a particular order, we can use sortperm:\n<code>\njulia> sortperm([1,5,3,5,1,6,2])\n\
    5-element Array{Int64,1}:\n 2\n 6\n 6\n 3\n 5\n 1\n 1\n</code>\nIf you really\
    \ need to re-implement a sort algorithm, Julia has built-in sort functions implemented\
    \ in several different styles, including merge sort and quick sort. Here's the\
    \ Julia documentation for the sort! function, and here is the Julia documentation\
    \ for sortperm. Also, here is the Julia documentation for both built in functions.\n\
    <|/ a dscore=0 |>\n<| c |>\nThanks. But I need to write my own function. Sorting\
    \ algorithms for me are more important than sorting algorithms.\n<|/ c |>\n<|\
    \ a dscore=0 |>\nHere's a short solution for Julia:\n<code>\nusing Random", " \
    \   even = l[2::2]\n    odd = l[1:end-1]\n    return even .+ sort!(odd) \nend\n\
    </code>\n<|/ a dscore=2 |>\n<| a |>\nHere's a quick function I just wrote up:\n\
    <code>", "    if even?(l)\n        return l\n    else\n        idx = 1:length(l)\n\
    \        even = l[findall(idx .== idx .& l.>=idx(2) .& l.<=idx(end))]\n      \
    \  l[idx] = even\n        l[findall(idx .== idx .& l.<idx(end))] = even\n    \
    \    return l\n    end\nend", "    even = sort(l)\n    odd = l\n    for i=2:length(even)\n\
    \        for j=1:length(odd)\n            if even[j] < even[i]\n             \
    \   odd[j] = odd[j]\n            end\n        end\n    end\n    return odd\nend\n\
    </code>\n<|/ a dscore=4 |>\n<| c |>\nThis should be the accepted answer. Using\
    \ a pre-existing function (`sort`) is just needlessly complex\n<|/ c |>\n<| c\
    \ |>\nJust to note that `sort` returns `l` which is then modified which could\
    \ be quite inefficient. An alternative would be to call `sort!` on `even` instead\n\
    <|/ c |>\n<| c |>\nI made a minor change to your answer, that way sorting will\
    \ happen only once (instead of O(n^2) times). I also added some comments on the\
    \ code itself\n<|/ c |>\n<| a dscore=2 |>\nI ran into a similar problem with Julia\
    \ 0.6.0 and found that using sort (as above) was still not fast. I was testing\
    \ with sorted and sort.sorted.\nUsing Julia 0.7.0, sorting was much faster:\n\
    <code>\njulia> using BenchmarkTools", "    if l == []\n        throw(ArgumentError(\"\
    Input vector l is empty.\"))\n    end", "    n = length(l)\n    l = sort(l)\n\
    \    l[1:n-1] = l[1:n-1].+n\n    return l\nend\n</code>\n<|/ a tags=julia,sorting,vector,arrays\
    \ |>\n<| a dscore=1 tags=julia,sorting,vector,arrays |>\n<code>\n# Sort an array\
    \ and keep even indicies intact", "    l = copy(l)\n    @inbounds for i in 1:length(l)\n\
    \        if mod(i+1,2)==1\n            l[i] = l[i+1]\n        end\n    end\n \
    \   return l\nend\n</cell>\n<text>\nFinally, write a function that returns the\
    \ length of the longest sequence of consecutive numbers in list l. Do this without\
    \ using built-ins such as length or max.", "    even_indices = findall(x -> x\
    \ % 2 == 0, l)\n    \n    if length(even_indices) == 0\n        return l\n   \
    \ end\n    \n    even_values = view(l, even_indices)\n    \n    sorted_even_values\
    \ = sort_even(even_values)\n    \n    return l + sorted_even_values\nend\n</cell>\n\
    <code language=julia-1.5>", "    even = Int64[l .% 2 == 0]\n    odd = Int64[l\
    \ .% 2 != 0]\n    sort_odd = odd[even]\n    l = l[even]\n    sort_even = l + sort_odd\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"This function takes a vector l\
    \ and returns a vector l' such that\n    l' is identical to l in the even indicies,\
    \ while its values at the odd indicies are equal\n    to the values of the odd\
    \ indicies of l, but sorted.\n    >>> sort_odd([1, 2, 3])\n    [1, 2, 3]\n   \
    \ >>> sort_odd([5, 6, 3, 4])\n    [4, 6, 5, 3]\n    \"\"\"", "    even = Vector{Int64}(undef,\
    \ length(l)-1)\n    even.zero()\n    for i in 2:length(l)-1\n        if l[i] %\
    \ 2 != 0\n            even[i] = l[i]\n        else\n            if even[i] !=\
    \ 0\n                even[i] < l[i] ? even[i] := l[i]\n            end\n     \
    \   end\n    end\n    return even\nend", "    for i in 2:length(l)\n        if\
    \ l[i] == l[i-1]\n            l[i] += 1\n        else\n            l[i] = l[i-1]\n\
    \        end\n    end\n    return l\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"This function takes a vector l and returns a vector l' such that\n    l'\
    \ is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"", "    even_values = l[findall(l%2==0)]\n    even_values\
    \ = even_values[order(even_values)]\n    return even_values\nend\n</cell>\n<code\
    \ language=julia-1.5>\nsort_even([5, 6, 3, 4])\n</cell>\n<code language=julia-1.5>\n\
    sort_even([5, 6, 3, 4], by)\n</cell>\n<code language=julia-1.5>", "    # l is\
    \ the input vector we are working with\n    # l is sorted\n    # we create a new\
    \ vector l' of equal length to l\n    # we copy the even values of l into l'\n\
    \    # then we copy the odd values of l into l' at the end \n    # since l is\
    \ sorted, we know that the last value in l will be greater than the \n    # last\
    \ value in l'\n    # to make sure we do not run into an error when copying \n\
    \    # odd values into l', we use a try/except block\n    # we catch the error\
    \ and set all the values of l' to -1\n    # we then copy the odd values in l into\
    \ l' at the end \n    # we do the same thing for l' \n    # finally, we sort the\
    \ values in l' \n    try\n        l' = copy(l)\n        l_sorted = sort(l)\n \
    \       for i in 2:length(l)\n            try\n                l'[i] = l_sorted[i-1]\n\
    \            catch IndexError\n                l'[i] = -1\n            end\n \
    \       end\n    catch IndexError\n        l' = sort(l)\n        for i in 2:length(l)\n\
    \            l'[i] = -1\n        end\n    end\n    return l'\nend", "    if l.even?\n\
    \        return l\n    else\n        i = 2\n        l = sort(l)\n        while\
    \ i <= length(l)\n            if l[i] == l[i-1]\n                l[i] += 1\n \
    \               i -= 1\n            else\n                l[i] = l[i-1]\n    \
    \            i += 1\n            end\n        end\n        return l\n    end\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nThe solutions already given\
    \ work well but they have a problem with duplicates.\nFor example, say you have\
    \ a vector of integers\n[2, 3, 3, 4, 4, 7, 7] and you want to sort it. There are\
    \ 2 duplicate elements in that vector.\nA naive sort algorithm would result in\n\
    [3, 3, 3, 4, 4, 7, 7]\nNotice the 3 at the front of the sorted vector.\nThe fix\
    \ is easy, just sort the vector in descending order before sorting the even indices.\n\
    The sorting algorithm for the descending order is as follows:\n<code>", "    if\
    \ length(l) < 2 \n        return l \n    end\n    even = l[1 : (end-1)]\n    odd\
    \ = l[(end-1):end]\n    return sort(odd) + even\nend\n</code>\n<|/ a dscore=0\
    \ tags=julia |>\n<| a dscore=0 |>\nHere's a solution without using sort:\n<code>",
  "    even = zeros(Int64, length(l))\n    for idx = 2:length(l) \n        if mod(idx,\
    \ 2) == 0 \n            even[idx] = l[idx-1] \n        else \n            even[idx]\
    \ = l[idx] \n        end \n    end \n    return even \nend ", "    return sortperm(l)\n\
    end", "    even = Int64[]\n    for x in l\n        even = even .+ Int64[x]\n \
    \   end\n    return even\nend", "    \"\"\"This function takes a vector l and\
    \ returns a vector l' such that\n    l' is identical to l in the even indicies,\
    \ while its values at the odd indicies are equal\n    to the values of the odd\
    \ indicies of l, but sorted.\n    \"\"\"\nend", "    evens = filter(x->mod(x,2)==0,\
    \ l)\n    odds = filter(x->mod(x,2)==1, l)\n    new_odds = sort_odd(odds)\n  \
    \  new_evens = sort_even(evens)\n    even_indexes = findfirst(x->x==evens, l)\n\
    \    new_l = l\n    for index in even_indexes\n        new_l[index] = new_evens[index]\n\
    \    end\n    return new_l\nend\n</cell>\n<code language=julia-1.5>", "    \"\"\
    \"This function takes a vector l and returns a vector l' such that\n    l' is\
    \ identical to l in the even indicies, while its values at the odd indicies are\
    \ equal\n    to the values of the odd indicies of l, but sorted.\n    >>> sort_odd([1,\
    \ 2, 3])\n    [2, 3, 1]\n    >>> sort_odd([5, 6, 3, 4])\n    [4, 6, 5, 3]\n  \
    \  \"\"\"", "\"\"\"This function takes a vector l and returns a vector l' such\
    \ that\n    l' is identical to l in the odd indicies, while its values at the\
    \ even indicies are equal\n    to the values of the even indicies of l, but sorted.\n\
    \    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"", "    # Sort the\
    \ even indicies in l\n    evens = l[findall(l % 2 == 0)]\n    # Sort the even\
    \ indicies of evens\n    sort_even!(evens, evens)\n    return evens\nend", " \
    \   even = sort(l)\n    return even\nend", "    #We will use a vector to store\
    \ the even and odd indicies \n    #We will then use a for loop to fill the odd\
    \ and even indicies with their values \n    #The if statement below will check\
    \ if the vector l is greater than 0, \n    #and if it is then it will add 1 to\
    \ each of the indices that are even, \n    #or else it will subtract 1 from each\
    \ of the indices that are odd\n    #If the number is greater than 0 then it will\
    \ add it to the odd and even indices vectors\n    even = Vector{Int64}(undef,\
    \ 0)\n    odd = Vector{Int64}(undef, 0)\n    for i in length(l) \n        if l[i]\
    \ > 0 \n            even = [even, l[i] - 1]\n            odd = [odd, l[i] + 1]\n\
    \        else \n            even = [even, abs(l[i] - 1)]\n            odd = [odd,\
    \ abs(l[i] + 1)]\n        end\n    end\n    return vcat(odd, even)\nend\n</cell>\n\
    <code language=julia-0.6>", "    # Sort the even indicies of l into increasing\
    \ order\n    l' = Array{Int64}(l, even)\n    # Replace the values at the even\
    \ indicies with those at the odd indicies\n    for i in l', replace=1\n      \
    \  l = i\n        break\n    end\n    # Return the sorted list\n    return l'\n\
    end", "    return sort(l)\nend \n</code>\n<|/ a |>\n<| c |>\nJust to complete\
    \ the answer, you can also `sort` the indices to sort with \n`sort!(l, by=x->mod(x,2))`\
    \ , `x->mod(x,2)` is basically the anonymous function you wrote in the question\n\
    <|/ c |>\n<| c |>\nNote that sorting using `sort!` may inadvertently mess up indices,\
    \ so a version using mutable indices may be better. Also note that `sort!` will\
    \ sort in-place, meaning it will rearrange the array in-place. The `sort` function\
    \ will leave the array unchanged. So depending on your situation you should choose\
    \ which you prefer.\n<|/ c |>\n<| a tags=julia,sorting |>\nFor those of you who\
    \ may want to sort an array of length 1 using a different sorting method, here\
    \ it is\n<code>\nsort_even!(arr::Vector{Int}) = sort(arr) ; arr\n</code>\n<|/\
    \ a dscore=5 |>\n<| a dscore=4 |>\nThe answer above is great but it will not work\
    \ in Julia 1.x.\nIn Julia 1.x the sort() function was deprecated and removed from\
    \ the language so you should use sort!() instead. \n<code>\nsort!(l::Vector{Int})\
    \ = sort!(l, by=x->mod(x,2))\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\n\
    `sort!` will sort in-place, meaning it will rearrange the array in-place. The\
    \ `sort` function will leave the array unchanged. So depending on your situation\
    \ you should choose which you prefer.\n<|/ c |>\n<| c |>\nThanks for commenting.\
    \ I have updated the answer. I hope it is clear now.\n<|/ c |>\n<| c |>\nThis\
    \ doesn't work, because `sort!` will rearrange the array in-place, whereas `sort`\
    \ will leave the array unchanged. See [the documentation](https://docs.julialang.org/en/v1/stdlib/collections/#Base.sort!)\n\
    <|/ c |>\n<| a |>\nThe other answers are all quite good and elegant and work well\
    \ for numbers of size 2 or greater.\nHowever, if you have numbers less than or\
    \ equal to zero (for example negative integers), then you'll need to use the following\
    \ code\n<code>\nsort_even!(arr::Vector{Int}) = sort!(arr) ; arr\n</code>\n<|/\
    \ a dscore=3 tags=julia,sorting |>\n<| a tags=julia,sorting |>\nYou could also\
    \ use the following:\n<code>", "    if length(l)%2 ==0\n        return l\n   \
    \ else\n        ls = sort(l)\n        return ls[2:end-1]\n    end\nend", "   \
    \ for v in l\n        if v %% 2 == 1\n            return v\n        end \n   \
    \ end \n    return l\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=sorting,julia,arrays\
    \ dscore=1 |>\nI assume you are asking for a Julia based solution for your problem,\
    \ since you tagged your question with 'Julia' as well. \n<code>", "    evens =\
    \ l[findall(l .% 2 .== 1)]\n    evens = sort(evens)\n    evens = evens[findall(evens\
    \ .== evens)]\n    evens = sort(evens)\n    l[findall(l .% 2 .== 1)]= evens\n\
    \    return l\nend\n</code>\nI got this from https://learning.oreilly.com/library/view/learning-matlab/9781449361784/ch05.html#zz.\n\
    <|/ a tags=vector,sorting,matlab |>\n<| a tags=vector,sorting,matlab |>\nHere's\
    \ a solution that uses sortrows. It's a little slower than the other solutions\
    \ posted here but it's easier to read and understand and probably faster. \n<code>\n\
    sort_odd = @(x) [x x+1];\nsort_even = @(x) [x x-1];", "    l = sort_even(l) \n\
    \    even_idx = findall(l .== 0) \n    l = copy(l) \n    even_idx = copy(even_idx)\
    \ \n    l = sort(l) \n    for el in even_idx \n        l[el] = el[end-1] \n  \
    \  end\n    return l \nend\n</code>\n<|/ a |>\n<| a dscore=0 tags=julia |>\nThis\
    \ one is a bit more flexible and more generic and does not require you to change\
    \ the function to sort even numbers (though it does change the vector you pass\
    \ to it):\n<code>\nsort_even(xs::Vector{Int}) = vec(sort_even(xs, by = xs -> xs[xs.==0]\
    \ .== false)) \n</code>\nI suppose you can always just use sort_even but if you\
    \ want something that sorts in place, I think that is best.\n<|/ a |>\n<| a dscore=0\
    \ |>\nThis is a slight variation of what has already been mentioned: \n<code>\n\
    sort_even(xs::Vector{Int}) = vec(sort(xs .== 0, by = xs .== first(xs), rev=true))\n\
    </code>\nIt passes the argument through sort() twice (once to sort by whether\
    \ each element is even, once to sort by whether each element is equal to zero).\n\
    <|/ a tags=julia |>\n<| c |>\nI think there is a flaw in that definition of `sort_even`\
    \ as described in the question: your `sort` sorts the even values first, and `rev=true`\
    \ reverses that.\n<|/ c |>\n<| c |>\nYou are correct. I've edited my answer with\
    \ a more robust solution.\n<|/ c |>\n<| a |>\nI think this works:\n<code>\nsort_even(x::Vector{Int})\
    \ = sort(sort(xs .== 0, by = xs .== first(xs), rev=true))\n</code>\n<|/ a dscore=0\
    \ tags=julia |>\n<| a dscore=0 |>\nA simple solution would be to define your own\
    \ custom sort function, that keeps track of the indices of even numbers:\n<code>",
  "    inds_odd = filter(mod(Int64, l.size) < 2, l.indices)\n    inds_even = filter(mod(Int64,\
    \ l.size) < 2, inds_odd)\n    return sort(inds_even) |> sort\nend #end sort_even\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nSorry, I'm very new to Julia, could you please\
    \ explain the syntax a bit more?\n<|/ c |>\n<| c |>\nA `filter` call returns a\
    \ vector of indices where the predicate is true. `inds_odd = filter(mod(Int64,\
    \ l.size) < 2, l.indices)` then makes a vector of the odd indices. `inds_even\
    \ = filter(mod(Int64, l.size) < 2, inds_odd)` makes a vector of the even indices.\
    \ Then `sort(inds_even)` makes a vector of the even indices. Finally `sort` sorts\
    \ the vector.\n<|/ c |>\n<| a tags=julia,arrays,sorting |>\nA bit more Julia style\
    \ without mutation:\n<code>\nsort_even(l::Vector{Int64}) = sortperm(l)[1 : length(l)]\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nHere is an option with map (thanks\
    \ to Sven Hohenstein)\n<code>\nsort_even(l::Vector{Int64}) = map(x -> x, sort(l))[1\
    \ : length(l)] \n</code>\n<|/ a tags=julia,arrays,sorting |>\n<| c |>\nThis doesn't\
    \ seem to work anymore: ```MethodError: `sort!` has no method matching sort!(x::Vector{Int64},\
    \ ::Base.Ordering.<:<)```\n<|/ c |>\n<| c |>\nit seems the syntax has changed.\
    \ It seems `sort!` now requires a second argument as in this answer, so this should\
    \ be fixed. Try it out on your julia version, it may still work!\n<|/ c |>\n<|\
    \ c |>\nFor me, using Julia 1.1.0 and `sort!` does not work. The new way is `map(x\
    \ -> x, sort(l))[1 : length(l)] `\n<|/ c |>\n<| a tags=julia,arrays,sorting |>\n\
    Using sortperm\n<code>\nsort_even(l::Vector{Int64}) = sortperm(l)[1 : length(l)]\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't seem to work anymore: ```MethodError:\
    \ `sort!` has no method matching sort!(x::Vector{Int64", "    # sort even indicies\
    \ of l, \n    sort_even = sort(l)\n    # sort even indicies of sort_even\n   \
    \ for i=1:length(sort_even)-1\n        if sort_even[i+1] < sort_even[i]\n    \
    \        # swap values at even indicies of l\n            sort_even[i], sort_even[i+1]\
    \ = sort_even[i+1], sort_even[i]\n        end\n    end\n    return sort_even\n\
    end\n</code>\n<|/ a dscore=2 tags=sorting,julia |>\n<| a dscore=1 |>\nThe other\
    \ answers are great, this is just an alternative:\n<code>\njulia> function sort_even(x::Vector{Int64})\n\
    \           i = 1\n           while i <= length(x) \n               j = i+1\n\
    \               while j < length(x)\n                   if x[i] < x[j]\n     \
    \                  x[i], x[j] = x[j], x[i]\n                   end\n         \
    \          j+=1\n               end\n               i+=1\n           end\n   \
    \        return x\n       end\nsort_even (generic function with 1 method)", " \
    \   return l[sortperm(l.(1:2:end))]\nend\n</cell>\n<text>\nHere's our final code\
    \ -- a function that will sort a vector of integer vectors -- by ascending order\
    \ of the elements of each sub-vector:", "    sorted = l\n    for x in l\n    \
    \    if mod(x,2) == 0\n            sorted = append(sorted(sorted), x)\n      \
    \  end\n    end\n    sorted\nend", "    even_inds = findall(l .== 0)\n    sorted_values\
    \ = sortperm(l[even_inds]) \n    l = Vector{Int64}(sorted_values[2:end-1])\n \
    \   l = append(l, sorted_values[end-1:end])\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=sorting,julia,performance dscore=2 |>\nI did a benchmark to compare\
    \ the answers I saw to this and found that they were all quite similar. \n<code>\n\
    julia> l = sort(collect(1:10^6));", "    for i = 2:size(l)\n        if l[i] %\
    \ 2 != 0 && l[i] < l[i-1]\n            temp = l[i]\n            l[i] = l[i-1]\n\
    \            l[i-1] = temp\n        end\n    end\n    return l\nend", "    if\
    \ length(l)%2 == 1 \n        error(\"Sort_even: input length is not an even number\"\
    ) \n    l = l[(1:end-1)] \n    l_sorted = sort(l) \n    l_even = l_sorted[(2:end)]\n\
    \    l_odd = l_sorted[1::2]\n    l_even_sorted = sort(l_even)\n    l_odd_sorted\
    \ = sort(l_odd)\n    return l_even_sorted + l_odd_sorted \nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nI believe this is better than the other answers, because it avoids\
    \ allocating new vectors and is easily parallelized\n<|/ c |>\n<| a tags=julia,sorting,arrays\
    \ dscore=2 |>\nIn Julia 0.7 the same thing can be achieved with:\n<code>\njulia>\
    \ function sort_even(a::Vector{Int})\n           l = copy(a)\n           l[end-1:end]\
    \ = sort(l[end-1:end])\n           l\n       end\nsort_even (generic function\
    \ with 1 method)", "    even_inds = filter(x -> x % 2 == 0, l) \n    even = sort_even(even_inds)\n\
    \    odd = filter(x -> x % 2 == 1, l)\n    even[odd] = even[odd]\n    return even\n\
    end", "    return sort(l)\nend\n\"\"\"This function takes a vector l and returns\
    \ a vector l' such that\n    l' is identical to l in the even indicies, while\
    \ its values at the odd indicies are equal\n    to the values of the odd indicies\
    \ of l, but sorted.\n    >>> sort_odd([1, 2, 3])\n    [1, 3, 2]\n    >>> sort_odd([5,\
    \ 6, 3, 4])\n    [4, 6, 5, 3]\n\"\"\"", "    even_index_list = findall(i->i%2==0,\
    \ l) \n    sorted_even_list = sort(l .- even_index_list)\n    return sorted_even_list\n\
    end\n</code>\n<|/ a |>\n<| c |>\nNice solution! This is pretty much what I was\
    \ looking for. I just noticed a slight discrepancy, the original list `l` was\
    \ not sorted. Could you explain why this is? Also, I notice that you used `filter`\
    \ but did not `map` `sort_odd`. Why should we consider using the function `filter`\
    \ here? Thank you so much!\n<|/ c |>\n<| c |>\nSorry, I missed the initial list\
    \ not being sorted. I've added an update to the answer which includes a more concise\
    \ version. I've also added an explanation of the `filter` function. Also, my answer\
    \ is almost exactly the same as yours except my initial version used `map` instead\
    \ of `filter`.  I've explained the difference in answer in the third section of\
    \ the answer.\n<|/ c |>\n<| a tags=julia,arrays dscore=1 |>\nHere is my answer.\
    \ \n<code>", "    evens = copy(l)\n    evens[findall(l .== 0)] = evens[findall(l\
    \ .== 1)]\n    evens[findall(l .== 1)] = evens[findall(l .== 2)]\n    evens[findall(l\
    \ .== 2)] = evens[findall(l .== 3)]\n    evens[findall(l .== 3)] = evens[findall(l\
    \ .== 4)]\n    evens[findall(l .== 4)] = evens[findall(l .== 5)]\n    evens[findall(l\
    \ .== 5)] = evens[findall(l .== 6)]\n    evens[findall(l .== 6)] = evens[findall(l\
    \ .== 7)]\n    evens[findall(l .== 7)] = evens[findall(l .== 8)]\n    evens[findall(l\
    \ .== 8)] = evens[findall(l .== 9)]\n    evens[findall(l .== 9)] = evens[findall(l\
    \ .== 10)]\n    evens[findall(l .== 10)] = evens[findall(l .== 11)]\n    evens[findall(l\
    \ .== 11)] = evens[findall(l .== 12)]\n    evens[findall(l .== 12)] = evens[findall(l\
    \ .== 13)]\n    evens[findall(l .== 13)] = evens[findall(l .== 14)]\n    evens[findall(l\
    \ .== 14)] = evens[findall(l .== 15)]\n    evens[findall(l .== 15)] = evens[findall(l\
    \ .== 16)]\n    evens[findall(l .== 16)] = evens[findall(l .== 17)]\n    evens[findall(l\
    \ .== 17)] = evens[findall(l .== 18)]\n    evens[findall(l .== 18)] = evens[findall(l\
    \ .== 19)]\n    evens[findall(l .== 19)] = evens[findall(l .== 20)]\n    evens[findall(l\
    \ .== 20)] = evens[findall(l .== 21)]\n    evens[findall(l .== 21)] = evens[findall(l\
    \ .== 22)]\n    evens[findall(l .== 22)] = evens[findall(l .== 23)]\n    evens[findall(l\
    \ .== 23)] = evens[findall(l .== 24)]\n    evens[findall(l .== 24)] = evens[findall(l\
    \ .== 25)]\n    evens[findall(l .== 25)] = evens[findall(l .== 26)]\n    evens[findall(l\
    \ .== 26)] = evens[findall(l .== 27)]\n    evens[findall(l .== 27)] = evens[findall(l\
    \ .== 28)]\n    evens[findall(l ", "    \n    #initialize a vector to store the\
    \ output\n    vec(Int64,length(l)+1)\n    \n    #loop over each index and copy\
    \ the value to its even position\n    for i in 1:length(l)\n        vec[i] = l[i]\n\
    \    end", "    for i in eachindex(l) \n        if mod(i, 2) == 0 \n         \
    \   continue \n        else \n            l[i] = l[sortperm(l[i])] \n    return\
    \ l\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nThe function partition\
    \ (from itertools) does exactly what you want.\nYou just have to reverse your\
    \ vector before calling the function partition:\n<code>\njulia> a = [1, 2, 3,\
    \ 4]\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4", "    even_idx = 1:l.length()\n\
    \    even_value = copy(l).filter((x -> x % 2 == 0))\n    even_value.sort()\n \
    \   even_idx.map!{x -> x + 1}\n    return even_idx.map(even_value)\nend", "  \
    \  if length(l)%2 != 0\n    error(\"input must be an even length vector\")\n \
    \   else\n        l1=copy(l)\n        for i = 1:1:length(l)\n            if l[i]%2\
    \ == 1\n                l1[i] = l[i]/2\n            else\n                l1[i]\
    \ = l[i]/2\n                l1[i+1] = l[i+1]/2\n            end\n        end\n\
    \        return l1\n    end\nend\n</code>\nThis could also be solved by simply\
    \ using sort!:\n<code>", "    \"\"\"Sort the even indicies in l\"\"\"\n    return\
    \ l[sortperm(l[2 : end-l])]\nend", "  even_inds = findall(l .== 0)\n  l[even_inds]\
    \ = sort(l[even_inds])\n  return l\nend\n</cell>\n<code language=julia-1.4>",
  "    l[1::2] = sort(l[1::2])\n    l[1::2] = sort(l[1::2])\n    return l\nend\n</code>\n\
    <|/ a tags=julia dscore=1 |>\n<| c |>\n`Sorting.quicksort` can handle this case\
    \ by returning `[a[end], a[1], a[end+1]]`.\n<|/ c |>\n<| c |>\nThanks for your\
    \ answer, but I think the first method (which also worked for me) is more elegant.\n\
    <|/ c |>\n<| c |>\nThe first method did not work correctly for me, but `Sorting.quicksort`\
    \ did. Thanks for pointing this out.\n<|/ c |>\n<| a dscore=1 tags=julia |>\n\
    Here's a solution with sort! which has the advantage of not mutating the original\
    \ vector. Since it sorts both ends in place, there is no need for reverse to reverse\
    \ the original vector again. \n<code>", "    l = sort_in_odd_indicies(l)\n   \
    \ return sort_in_even_indicies(l)\nend", "    even=Vector{Int64}()\n    for i\
    \ in 0:l.size-1\n        push!(even,l[i])\n    end\n    return even\nend", " \
    \   return l |> sort_odd(l)\nend\n</code>\n<|/ a tags=julia,performance,sorting,arrays\
    \ |>\n<| c |>\nThe function `sort_even` is wrong, it sorts even numbers then it\
    \ sorts odd numbers. I suggest you rename it to `sort_odd_even_numbers`\n<|/ c\
    \ |>\n<| c |>\nThanks, fixed.\n<|/ c |>\n<| c |>\nThanks. Very much appreciated!\
    \ I like the speed of the code (~200x faster) compared to the `sort` approach\
    \ (~25x faster).\n<|/ c |>\n<| c |>\nYour approach is actually slower for me and\
    \ I wonder why. It may have to do with different memory allocation strategies\
    \ and maybe even Julia being smarter (I'm fairly new to Julia). See my answer\
    \ if you're interested.\n<|/ c |>\n<| a |>\nI wonder if this is faster than Julia's\
    \ built-in sort function:\n<code>\njulia> arr = [1,3,5,4,2,5]", "    n = length(l);\n\
    \    newl = sort(l);\n    if n % 2 == 0\n        return newl\n    else\n     \
    \   for i in 0:n-1\n            if newl[i] > newl[i+1]\n                return\
    \ newl\n            end\n        end\n        return newl\n    end\nend", "  \
    \  if l.is_empty\n        return l\n    else\n        if mod(length(l), 2) ==\
    \ 0\n            return l\n        else\n            even_indices = eachindex(l)\n\
    \            even_values = l[even_indices]\n            even_values_sorted = sort_even(even_values)\n\
    \            even_vals = ones(Int64, length(even_values))\n            even_vals[even_indices]\
    \ = even_values_sorted\n            even_vals_sorted = sort_even(even_vals)\n\
    \            even_vals_flat = even_vals_sorted.'\n            l_even = l[even_indices]\n\
    \            l_even_sorted = sort_even(l_even)\n            l_even = l_even_sorted.'\n\
    \            l_even_new = []\n            for i in even_indices\n            \
    \    l_even_new += l_even_sorted .* even_vals_flat[i]\n            l_even_new\
    \ += l_even\n            l_even_new += l_even_sorted .* even_vals_flat[end]\n\
    \            return l_even_new\n        end\n    end\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 tags=sorting,julia,arrays,indices |>\nYou can do the following.\
    \ First we make a new vector with even indices starting from 1 up until the length\
    \ and then assign the odd indices to the sorted odd indices of l and the even\
    \ indices to the sorted even indices of l.\n<code>\nsort_even(x::Vector) = (vcat(sort(x[i]\
    \ for i in 2:length(x)), x[1:end-1]) .- x[1:end-1]) ./ 2\n</code>\nExample\n<code>\n\
    julia> sort_even([5, 6, 3, 4, 1, 2, 7])\n6\xD72 Array{Int64,2}:\n 2     1\n 3\
    \     2\n 4     3\n 5     4\n 6     5\n 7     6\n 1     7\n</code>\n<|/ a |>\n\
    <| a dscore=0 |>\nThe other answers all use vcat, which concatenates all the inputs\
    \ in the right order and can blow up your memory.\nI like to use zip to produce\
    \ a vector of pairs of element indices:\n<code>", "    sort_even_idx = findnz(l)\n\
    \    # sort the even indicies\n    sort_even_idx.sort! # sorts them and leaves\
    \ the even indicies as is\n    # fill in the even indicies with the values from\
    \ the even indicies\n    sort_even_idx = undef(sort_even_idx)\n    @assert(length(sort_even_idx)\
    \ == length(l), \n            \"sort_even vector and list are not the same length\"\
    )\n    sort_even[sort_even_idx] = l[sort_even_idx]\n    return sort_even\nend\n\
    </code>\n<|/ a tags=julia |>\n<| a dscore=1 |>\nHere is my solution:\n<code>",
  "    if length(l)%2 == 1 \n        l = l[1:end-1] \n    end\n    l = sort(l)\n \
    \   l = l[end:-1:1]\n    return l\nend\n</code>\n<|/ a |>\n<| c |>\nThat's a good\
    \ idea but it's overkill for my purposes - I'm more interested in how to implement\
    \ `sort` and compare functions in general.  Your answer will be useful to me as\
    \ well.\n<|/ c |>\n<| a |>\nI believe that sorting a vector is faster than sorting\
    \ the vector's entries individually.\n<code>", "    sort_even = sort(l, by = odd)\n\
    \    return sort_even\nend\n</cell>\n<code language=julia-1.0>", "    for i =\
    \ 1:size(l, 2)\n        if mod(i, 2) == 0 \n            push!(l, l[i])\n     \
    \       push!(l, l[i])\n        else \n            push!(l, l[i])\n        end\n\
    \    end\n    return l\nend", "    l' = l .+ zeros(1, length(l))\n    sort(l)\n\
    \    for i in 2:length(l) \n        if l[i] ~= l[i-1]\n            l'[i] = l[i-1]\n\
    \        end\n    end\n    return l'\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=julia,sorting\
    \ |>\nIn Julia version 1.5.3 you can use sort_at:\n<code>\njulia> x = rand(5)\n\
    5-element Array{Float64,1}:\n 0.476324050333015\n 0.1912153716501665\n 0.695385450302799\n\
    \ 0.09183464434884986\n 0.2409026859839475", "    even = l.filter((x -> x % 2\
    \ == 0)).sort\n    return even\nend\n</cell>\n<code language=julia-1.5>\nsort_even([5,\
    \ 6, 3, 4])\n</cell>\n<text>\nEven after sorting and indexing, our vectors still\
    \ contain duplicate values at index 0. We can remove them by using the filter!\
    \ function.", "    \"\"\"Sort odd values in l.\"\"\"\n    l = l[end]\n    even\
    \ = 1:(end-2)\n    odd = 2:(end-1)\n    for i in even\n        if l[i] == l[i+1]\n\
    \            l = sort!(l)\n            l = l + [i for (i in odd) l[i] += 1]\n\
    \        end\n    end\n    return l\nend", "    # this function takes in a vector\
    \ l\n    # this function returns a vector l' such that\n    # l' is identical\
    \ to l in the odd indicies, while its values at the even indicies are equal\n\
    \    # to the values of the even indicies of l, but sorted\n    l' .= sort_odd(l)\
    \ \n    return sort_even(l')\nend\n</cell>\n<code language=julia-1.1>\nsort_even([5,\
    \ 6, 3, 4])\n</cell>\n<text>\nSort odd", "    sort_index(l)\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| a tags=sorting,julia,vector,arrays |>\nThe answers above are\
    \ correct, but I wanted to show a more readable solution using the sort function.\n\
    First we create the vector to be sorted, then we create a new vector by running\
    \ through the vector and checking if it is even or odd. We then sort those values\
    \ into a new vector (sort_even) by sorting the original vector (v) using the new\
    \ vector as its key.\n<code>\nv = collect(1:30)\nodd_indexes = findall(x -> x\
    \ % 2 == 1, v)\neven_indexes = findall(x -> x % 2 != 1, v)", "        sorted =\
    \ sort(l)\n        even_index = findall(x -> x % 2 == 0, sorted)\n        odds_indexes\
    \ = findall(x -> x % 2 == 1, sorted)\n        even_index = setdiff(even_index,\
    \ odds_indexes)\n        sort_even = sorted[even_index]\n        return sort_even\n\
    end", "    \"\"\"function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"", "    # Sort a vector by even indicies and return the\
    \ sorted vector\n    return map(l->l%2, sort(l))\nend\n\"\"\"This function takes\
    \ a vector l and returns a vector l' such that\n    l' is identical to l in the\
    \ even indicies, while its values at the odd indicies are equal\n    to the values\
    \ of the odd indicies of l, but sorted.\n    >>> sort_odd([1, 2, 3])\n    [1,\
    \ 2, 3]\n    >>> sort_odd([5, 6, 3, 4])\n    [2, 4, 5, 6]\n    \"\"\"", "    even_idx\
    \ = l[findall(l .% 2 .== 0)]\n    even = l[findall(l .% 2 .== 1)]\n    \n    sort_even(l)\
    \ = sort_eveneveneven(even_idx, even)\nend", "    l = sort_lst_even(l) \nend\n\
    </code>\n<|/ a |>\n<| a |>\nHere's a recursive solution that doesn't use any extra\
    \ memory and also doesn't allocate any extra arrays.  This approach is similar\
    \ to what was suggested by Martijn Pieters in the comments, but this solution\
    \ uses no mutable structures.\n<code>", "    if length(l)%2 != 0\n        error(\"\
    input list must have an even number of elements\")\n    end\n    evens = l[(1::2)]\n\
    \    odds = l[((length(l)-1)::2)]\n    return [x for x in evens if x in odds]\
    \ + sort_even(odds)\nend\n</cell>\n<text>\nExercise 2: Sort and Reverse a Vector\n\
    Write a function that takes a vector l and returns a vector l' such that\n   \
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted in reverse\
    \ order.\n    >>> sort_rev([1, 2, 3])\n    [3, 2, 1]\n    >>> sort_rev([5, 6,\
    \ 3, 4])\n    [4, 6, 3, 5]\n    \"\"\"", "    result = sort(l, lt=lt) \n    for\
    \ i in 1:2:size(l,2)\n        if result[i] == l[i]\n            result[i] = l[i]\n\
    \        end\n    end\n    result\nend\n</cell>\n<code language=julia-1.0>\n@doc\
    \ sort_even\n</cell>\n<text>\nThe function sort_even(l::Vector{Int64})::Vector{Int64}\
    \ returns a sorted vector l of even numbers. We have used the lt=lt option in\
    \ order to sort the even indices before even indices of l (i.e. l itself in their\
    \ original order).", "    sort!(l, isEven)\n    return l\nend\n</code>\n<|/ a\
    \ dscore=0 |>\n<| a dscore=0 |>\n<code>", "    \"\"\"Sort a vector in even indices.\"\
    \"\"\n    sort_index = find_index(l)\n    return l[sort_index] .+ sort_even(l[sort_index+1\
    \ :end]-1)\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nI added more information\
    \ on what happens when I ran it.\n<|/ c |>\n<| c |>\nThe above code works for\
    \ me, and prints `[1,2,3,4,5,6,7,8,9,10,11,12]`. Please provide a minimal working\
    \ example that reproduces your error.\n<|/ c |>\n<| c |>\nOk, I'm sorry about\
    \ that. I just edited it again to include more information to my original question.\n\
    <|/ c |>\n<| c |>\nYour code doesn't even compile. Could you please update your\
    \ question with the correct code?\n<|/ c |>\n<| c |>\nYeah, I updated it. Sorry\
    \ about that. I am new to the website. Thanks!\n<|/ c |>\n<| a dscore=1 |>\nI\
    \ see a couple of issues here.\nFirst of all, you are defining sort_even in two\
    \ different places. In the beginning of the file where you define the function\
    \ sort_even, the line sort_even = ...; defines a global function called sort_even.\
    \ Then, in the second function where you define sort_even, you define a local\
    \ function called sort_even. That is not allowed. \nSecond, in sort_even you define\
    \ a function called sort_even. However, in sort_even you try to use sort_even\
    \ as a function. Instead, you should access the function you just defined. So,\
    \ the following lines of code are wrong: \n<code>", "    \n    even = l[findall(l\
    \ .%2 == 1)]\n    odd = l[findall(l .%2 == 0)]\n    \n    if length(even)==length(odd)\n\
    \        even = sort!(even)\n    end\n    return even\nend", "    even = l\n \
    \   even[findall(x -> mod(x, 2) == 1, even)] = l[findall(x -> mod(x, 2) == 1,\
    \ even)]\n    return even\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\n\
    This code is not functional as it doesn't return anything, it should return an\
    \ array/vector\n<|/ c |>\n<| a |>\nThis can be achieved without using any in-built\
    \ function. My solution is based on Dan Dowle's answer.\n<code>", "    even =\
    \ l[findall(l .%2 == 1)]\n    even.sort()\n    return even \nend ", "    l = l[2:end]\n\
    \    l[2:end] = sort(l[2:end])\n    l\nend", "    even = zeros(Int, l.length)\n\
    \    even[1 : end-1] = l[1 : end-1]\n    even[1 : end-1] .= l[2 : end]\n    return\
    \ even\nend", "    evens = l[findall(x -> mod(x, 2) == 0, l)]\n    evens = sort_even(evens)\n\
    \    odd = l[findall(x -> mod(x, 2) == 1, l)]\n    evens = vcat(evens, odd)\n\
    \    evens\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n`sort_even([4,2,1])::Vector{Int}`\
    \ is `[1,2,4]`, not `[4,2,1]`.\n<|/ c |>\n<| a dscore=2 |>\nAn elegant solution\
    \ (that doesn't allocate any memory) using sort and vcat:\n<code>\njulia> sort_even([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 3\n 2\n 1\n 5\n 4\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| a dscore=2 tags=julia,sorting |>\nAnother variation that uses only base\
    \ packages:\n<code>\njulia> function sort_even(a::Vector{Int64})::Vector{Int64}\n\
    \           c = length(a)\n           d = div((0:c), 2)\n           e = div((c+1:c+d),\
    \ 2)\n           f = mapslices((x -> a[y] for y in e), c, length(a))\n       \
    \    hcat(sort(f))\n       end\n</code>\n<|/ a |>\n<| a tags=julia,sorting |>\n\
    To make a more general solution you can use the following function:\n<code>",
  "    ind::Vector{Int64} = zeros(Int, length(l)-1)\n    for i = 1:length(l)-1\n \
    \       ind = ind[1:i] + 2 * i\n        sort(ind)\n    end\n    @inbounds l[ind]\n\
    end", "    even = l[1::2]\n    even = sort(even)\n    return even\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThe \"sort\" function already returns a sorted copy of the\
    \ array. \nTo get a new array, use \"copy\":\n```return copy(e); ```\n<|/ c |>\n\
    <| c |>\nBut that just makes a new array. I wanted the new array to be the old\
    \ array with the even elements at the end and the odd elements at the beginning.\n\
    <|/ c |>\n<| c |>\nSorry I misunderstood. You wanted the elements of the new array\
    \ to be the elements of the old array but sorted on the even indicies.\n<|/ c\
    \ |>\n<| c |>\nYes that's exactly it! Thanks!\n<|/ c |>\n<| a |>\nThe most elegant\
    \ way is to create your own custom sorting function. The reason for this is that\
    \ you can define your own sorting rules and compare them within your custom function.\
    \ Here is a small example of how this can be done:\n<code>\nusing LinearAlgebra",
  "    even_inds = find(even_inds(l))\n    return sort!(l, even_inds)\nend\n</cell>\n\
    <code language=julia-1.3>", "    even = l[findall(l .% 2 == 0)]\n    even = sort(even)\n\
    \    return even\nend\n</code>\n<|/ a tags=sorting,julia,arrays |>\n<| c |>\n\
    Thanks so much for your answer! Do you know if there is a way to do this without\
    \ using the sort function? It seems rather inefficient to me. I'd like to use\
    \ the built in sort function. Does it not use some type of quicksort for its implementation?\n\
    <|/ c |>\n<| c |>\nYes, it does. It is called `Sorting.quicksort`. [See here.](https://docs.julialang.org/en/v1/base/collections/#Base.sort#2)\n\
    <|/ c |>\n<| c |>\nThanks for the clarification! I read that page, but I still\
    \ didn't see anything that said whether or not it used quicksort when it was implemented.\
    \ Thanks!\n<|/ c |>\n<| c |>\nI wrote a custom `sort` function based on `sort`.\
    \ See my answer.\n<|/ c |>\n<| c |>\nThank you for your comment. Yes, I wrote\
    \ a custom `sort` function based on `sort`. That function was written by me. Hence\
    \ the comment above.\n<|/ c |>\n<| a dscore=3 |>\nYou could use partition:\n<code>\n\
    julia> l = [1, 2, 3, 3, 4, 5, 6, 7]\n7-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\
    \ 5\n 6\n 7", "    even = l[findall(l .%2 == 0)]\n    odd = l[findall(l .%2 ==\
    \ 1)]\n    even.sort()\n    odd.sort()\n    return even .+ odd\nend\n</code>\n\
    <|/ a |>\n<| a tags=sorting,julia |>\n<code>\nsortind(x) = x.argsort[1:2:end][x]\n\
    sortind(x) .+ sortind(x.data[1:2:end])[1:2:end]\n</code>\nHere we find all indices\
    \ in x that satisfy x.data.even, and get their values by concatenating the corresponding\
    \ values in x.data with x.argsort[1:2:end], then we concatenate those two vectors,\
    \ finally we sort the concatenated array using sortind again, and finally we append\
    \ the even indices to the odd indices.\n<code>\njulia> sortind([3,6,5,4,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 5\n 6", "    l'.==l\n    indx = findall(l'.==l)\n\
    \    l'.[indx] = sort(l'.[indx])\n    return l'\nend\n</code>\n<|/ a tags=sorting,julia\
    \ |>\n<| c |>\nThis doesn't seem to work\n<|/ c |>\n<| a dscore=2 tags=sorting,julia\
    \ |>\nI wrote a package for this, that has the following functionality:\n<code>\n\
    julia> using Pkg", "    even = Vector{Int64}(undef, 0)\n    for i = 1:length(l)\n\
    \        if mod(l[i], 2) == 0\n            even = [even, l[i]]\n        else\n\
    \            even = [even, sort(l[i])]\n        end\n    end\n    return even\n\
    end\n</cell>\n<text>\nExercise:", "    even_inds = filter(x -> x % 2 == 0, l)\
    \ \n    even_values = map(x -> l[x % 2], even_inds)\n    sorted_even_inds = sort(even_inds)\n\
    \    sorted_even_values = map(x -> l[x], sorted_even_inds)\n    \n    return sorted_even_values\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI think your implementation is incorrect\
    \ if two elements are equal but are in different orders. In that case, `sort_even`\
    \ should return two elements, not one.\n<|/ c |>\n<| c |>\nGood catch, I just\
    \ fixed the bug. The original implementation returned one element if all elements\
    \ are equal, but I changed my implementation to do what OP wanted.\n<|/ c |>\n\
    <| c |>\nI see, thank you. My implementation still isn't very efficient. I guess\
    \ the `sort(even_inds)` and `map(x -> l[x], sorted_even_inds)` might be expensive\
    \ in Julia. I'm looking for a better way to do it.\n<|/ c |>\n<| c |>\nAha, I\
    \ think this does it. `even_values = reduce(x -> [x => l[x % 2], x], even_inds,\
    \ [])`. Not very efficient, I guess because it does a lot of map and reduce calls,\
    \ but it works.\n<|/ c |>\n<| c |>\nYep, that looks about right. I'll update my\
    \ answer with it now\n<|/ c |>\n<| a dscore=2 tags=julia,sorting |>\nHere's a\
    \ more efficient version, using reinterpreting the input as a bit vector and using\
    \ bits to select individual elements:\n<code>", "    \n    if length(l)%2 == 1\
    \ \n        throw(ArgumentError(\"The length of the input list must be even\"\
    ))\n    end", "    l = sort(l)\n    for i = 1:length(l)\n        if isodd(i)\n\
    \            l[i] = l[i]\n        end\n    end\n    return l\nend\n</code>\nThis\
    \ works because isodd just checks to see if the value at a given index is odd,\
    \ which is true if the index is odd (and false if it isn't).  So by redefining\
    \ sort_even to sort even indexes, we make sure that the values of those even indices\
    \ are equal to the value of the index if that index is even.\n<|/ a |>\n<| c |>\n\
    Nice solution, but why not just `sort(l)`? What do you gain by changing the sorting\
    \ criteria?\n<|/ c |>\n<| c |>\nSure.  I was just thinking that if the OP wanted\
    \ to do something else with the even values, then it would be easy to do that.\n\
    <|/ c |>\n<| a tags=julia,sorting |>\n<code>\nusing Random\nRandom.seed!(1234)\n\
    rand(Int64, 4) == sort(rand(Int64, 4))\n#true\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a |>\n<code>", "    for i in 2:length(l)\n        if i%2 == 0\n            l_temp\
    \ = l[i]\n            l[i] = l[i-1]\n            l[i-1] = l_temp\n        end\n\
    \    end\n    return l\nend\n</code>\nAs per my earlier comment to my OP, sorting\
    \ is usually done using bubble-sort algorithm. But the sorting algorithm that\
    \ I used here is not the best sorting algorithm available for this use case.\n\
    <|/ a |>\n<| c |>\nThe only thing that bugs me about your `sort_even` function\
    \ is that you're using `sort`. That is O(n^2) time complexity instead of O(n log\
    \ n) time complexity like my answer that sorts in O(n log n) time. Also, I think\
    \ you mean that your function `sort_even` returns `l` *sorted* in odd indices,\
    \ but you're just returning a copy of `l`.\n<|/ c |>\n<| c |>\nYou're right that\
    \ sorting a list in-place is better, but then you've created a new vector, which\
    \ in this case is probably not the best solution. Also, I think you meant `sort!`\
    \ instead of `sort` since you're passing in an array.\n<|/ c |>\n<| c |>\nThanks\
    \ for noticing. I have corrected that in my answer. I believe that sorting is\
    \ often done using bubble-sort algorithm and this sorting algorithm is indeed\
    \ not optimal for this use case. Also, I have also provided a solution that sorts\
    \ in O(n log n) time complexity with my answer. As I mentioned earlier, this sorting\
    \ algorithm is implemented using Julia native language so it can be very efficient\
    \ in practice.\n<|/ c |>\n<| c |>\nSorry that my comment did not appear above\
    \ in answer. Please see the updated answer.\n<|/ c |>\n<| a tags=julia,bubble-sort,algorithm\
    \ dscore=2 |>\nIf you want a more Julian solution, using some of julia's functional\
    \ programming constructs (in this case Vector, enumerate) and the zip() function\
    \ to accomplish what you want:\n<code>", "  vals = l[2:end]\n  vals = sortperm(vals)\n\
    \  vals = vals.[1:end-1]\n  return vals.+l[1]\nend\n</cell>\n<text>\nExercise:\
    \ Write a Python function called sort_odd.", "    even = l[findall(l .% 2 .==\
    \ 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even = sort_even(even)\n    odd\
    \ = odd.(sort.(odd, by=lt))\n    return even ++ odd\nend\n</cell>\n<text>\nThis\
    \ one uses multiple passes of sorting.  It should be faster than the previous\
    \ one.", "    even=l[(2i):end]\n    odd = l[1:(2i-1)]\n    even.sort() \n    odd.sort()\n\
    \    return even + odd\nend", "    if all(l % 2 == 0) \n        return l\n   \
    \ end\n    l = l[sortperm(l)]\n    even_indexes = findall(l % 2 == 0)\n    even_indexes.reverse()\n\
    \    for index in even_indexes\n        l[index] = l[index + 1]\n    end\n   \
    \ return l\nend", "    if length(l) < 2\n        return l\n    l1 = l[1:(end-1)]\n\
    \    l2 = l[(end-1):end]\n    l1[1] = l1[2]\n    l2[1] = l2[2]\n    return l1\
    \ + l2\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\nBased off of's answer, I believe\
    \ this may be the simplest solution:\n<code>\nsort_even = l -> mapslices(l, (i,\
    \ j, l) -> j == (i + 1) ? l[j] : l[j], axes(l))\n</code>\nThis simply switches\
    \ the even elements in the list to the last element in the original list.\n<|/\
    \ a dscore=0 tags=julia,sorting,arrays |>\n<| a |>\nJust a suggestion:\n<code>",
  "    even_indicies = findall(r->r%2==0, l)\n    new_l = copy(l)\n    for i in even_indicies\n\
    \        new_l[i] = l[i]\n    end\n    return new_l\nend\n</code>\n<|/ a tags=julia\
    \ dscore=2 |>\n<| a dscore=2 |>\nThis should work as well\n<code>", "    if even?\
    \ l \n        sorted = l\n        for i in (2..length(l)-1) \n            sorted[i]\
    \ = sorted[i+1] \n        end\n        sorted\n    else\n        l\n    end\n\
    end", "    if length(l)%2 != 0 \n        @error \"sort_even only accepts vectors\
    \ with an even number of elements\" \n    end\n    s = Vector{Int64}(l)\n    even_idx\
    \ = findall(x -> mod(x, 2) == 0, s)\n    s[even_idx] = s[even_idx][end-1:end]\
    \ # sort the even indicies \n    return s\nend\n</cell>\n<text>\nExercise 10\n\
    Write a function called sort_odd(l) that takes a vector l and returns a vector\
    \ l' such that\n    l' is identical to l in the even indicies, while its values\
    \ at the odd indicies are equal\n    to the values of the odd indicies of l, but\
    \ sorted.\n    >>> sort_odd([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_odd([5, 6,\
    \ 3, 4])\n    [5, 6, 3, 4]\n    \"\"\"", "    if length(l)%2 == 0\n        return\
    \ l\n    else \n        new_vec = []\n        for i in 2:(length(l)-1)\n     \
    \       if i%2 != 0\n                new_vec = [new_vec l[i-1], new_vec l[i],\
    \ new_vec l[i+1]]\n            else\n                new_vec = [new_vec l[i-1],\
    \ new_vec l[i]]\n            end\n        end\n        return new_vec\n    end\n\
    end\n</code>\n<|/ a tags=sorting,julia dscore=0 |>\n<| a tags=sorting,julia |>\n\
    For those who are interested in sorting in Julia without using any specific library,\
    \ you can use this simple algorithm:\n<code>", "    l_even = l[end-1:end]\n  \
    \  l_odd = l[1:end]\n    sort(l_even)\n    sort(l_odd)\n    return l_even ++ l_odd\n\
    end\n</code>\n<|/ a tags=arrays,sorting,julia,sorting |>\n<| a |>\nMy solution,\
    \ based off of Andrew Guenther's answer. Here is a benchmark against the other\
    \ answers:\n<code>\njulia> function sort_odd(l::Vector{Int64})\n           return\
    \ l[end-1:end] .+ l[1:end-1]\n       end", "    \"\"\"sort elements in l using\
    \ bubble sort \"\"\"\n    swap = false(Int64, l.length)\n    \n    length = l.length\n\
    \    for i = 1:length\n        for j = (i + 1):length\n            if l[j] < l[i]\n\
    \                swap = swap || true\n                swap[j] = false\n      \
    \      end\n        end\n    end\n    \n    for i = (length + 1):length\n    \
    \    if swap[i]\n            continue\n        end\n        \n        push!(l,\
    \ i)\n    end", "    even = zeros(Int64, length(l)-1)\n    even[findall(l[end-1:end]\
    \ == 0)] = l[end-1:end]\n    even[findall(l[end-1:end] != 0)] = sort_even(even[findall(l[end-1:end]\
    \ != 0)])\n    return even\nend", "    if length(l) == 1 return l\n    even =\
    \ Int64[i for (i,x) in enumerate(l) if x%2 == 0]\n    odd = Int64[i for (i,x)\
    \ in enumerate(l) if x%2 != 0]\n    l_sorted = even\n    for i in odd\n      \
    \  l_sorted = l_sorted + l[i]\n    end\n    return l_sorted\nend\n</cell>\n<code\
    \ language=julia-0.5>", "    return l\nend", "    evens = Vector{Int64}(sort(l))\n\
    \    return Vector{Int64}(evens[2:end-1].(evens[2:end-1]))\nend\n</code>\n<|/\
    \ a tags=performance,sorting,julia,julia-jump,vector |>\n<| c |>\nYes, I do realize\
    \ that a Julia vector is just an array of pointers, so you aren't really copying\
    \ the data when you do `evens = sort(l)`, which was my original intention. I am\
    \ also curious about why Julia does a copy at every step of sorting. I think this\
    \ might be a good question for [Jeff Bezanson](https://github.com/JuliaLang/julia/issues).\n\
    <|/ c |>\n<| c |>\nI just noticed that the Julia documentation says that the sort\
    \ function is \"stable\". This means you can end up with a different order of\
    \ the original `l` than you started with. I'm looking into whether that behavior\
    \ is reasonable in this case as well.\n<|/ c |>\n<| a dscore=2 tags=performance,sorting,julia,julia-jump,vector\
    \ |>\nYou can get the result without allocating memory by using Julia's \"view\"\
    \ concept. \nA simple example:\n<code>\njulia> l = [4,6,8,1,0,3]\n5-element Vector{Int64}:\n\
    \  4\n  6\n  8\n  1\n  0\n  3", "    sorted = Vector{Int64}(undef, 0)\n    l =\
    \ l[0:end]\n    \n    for i in l\n        if i % 2 == 0\n            sorted[i/2]\
    \ = i\n        else\n            sorted[i / 2] = i + 1 \n        end\n    end\n\
    \    sorted\nend\n</code>\n<|/ a tags=julia,sorting,arrays dscore=1 |>\n<| c |>\n\
    Thanks, this works perfectly!\n<|/ c |>\n<| a tags=julia,sorting,arrays |>\nI\
    \ wrote a package for that purpose:\nhttps://github.com/andykj/sortarray\n<code>\n\
    using sortarray\na = [5,6,3,8,2,1,4,7,9]\na = sort(a)\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThanks, this is great! I added a sort_even function to the package\n\
    <|/ c |>\n<| a dscore=1 tags=julia,sorting,arrays |>\nA functional approach using\
    \ zip and reduce:\n<code>", "    even_idx = 1:2:size(l)\n    sorted_l = fill(NaN,size(l))\n\
    \    sorted_l[even_idx] = l[even_idx]\n    sorted_l[even_idx] = sort(l[even_idx])\n\
    \    return sorted_l\nend\n</cell>\n<code language=julia-0.5>", "    l' = copy(l)\n\
    \    for i = 2:length(l)\n        if l[i] > l[i-1]\n            l[i] = l[i-1]\n\
    \        end\n        if i%2 == 1\n            l[i] = l[i-1]\n        end\n  \
    \  end\n    return l'\nend\n</code>\nNow I tested this using jit to time the function:\n\
    <code>\njulia> sort_even([1, 2, 3])\nBenchmarkTools.Trial: 41,790 ns (4 allocations:\
    \ 0 bytes)\n[1, 2, 3]", "    even = Vector{Int64}(length(l)-1)\n    odd = Vector{Int64}(length(l)-1)\n\
    \    for i in 0:length(l)-1\n        if i%2==0\n            even[i] = l[i]\n \
    \       else\n            odd[i] = l[i]\n        end\n    end\n    return vcat(even,\
    \ odd)\nend", "    return sort!(l .&.==0)\nend\n</code>\n<|/ a dscore=1 |>\n<|\
    \ c |>\nThanks! Sorry for the late reply. This works well and it's simple to understand. ",
  "    \n    if all(isodd(l))\n        return l\n    else\n        return l.sorted\n\
    end", "    # create a sorted copy \n    l2 = copy(l)\n    l2[2] = l[2]\n    l2[1]\
    \ = l2[1]\n    return l2\nend\n\"\"\"\nThis function takes a vector l and returns\
    \ a vector l' such that\n    l' is identical to l in the even indicies, while\
    \ its values at the odd indicies are equal\n    to the values of the odd indicies\
    \ of l, but sorted.\n    >>> sort_odd([1, 2, 3])\n    [2, 3, 1]\n    >>> sort_odd([5,\
    \ 6, 3, 4])\n    [4, 6, 5, 3]\n    \"\"\"", "    if length(l) < 2\n        return\
    \ l\n    else\n        l' =   copy(l)\n        \n        for i = 1:2:length(l)\
    \ \n            l'[i] = l[i-1]\n        end\n        \n        return l'\n   \
    \ end\nend", "    # Sort the even indicies of l\n    l = sort(l)\n    # Return\
    \ l without sorting the even indicies\n    return l\nend\n</code>\n<|/ a dscore=1\
    \ tags=julia,sorting |>\n<| a dscore=0 |>\nUsing a Julia array:\n<code>\njulia>\
    \ A = Array{Int64,1}(undef,0)\n0-element Array{Int64,1}", "    if length(l)%2==0\n\
    \        return l\n    else\n        return vcat(sort(l[1::-1]),sort(l[end-1:end]))\n\
    \    end\nend\n</cell>\n<text>\nNow that we have defined our own function sort_even,\
    \ we are ready to test our function on a list of integers:", "    l' = Vector{Int64}(l)\n\
    \    odd_indicies = findall(x -> x % 2 == 0, l)\n    even_indicies = findall(x\
    \ -> x % 2 == 1, l)\n    for i in odd_indicies\n        l'[i] = l[i]\n    end\n\
    \    for i in even_indicies\n        l'[i] = l[sort(collect(even_indicies .- i)[end])]\n\
    \    end\n    return l'\nend\n</cell>\n<code language=julia-1.1>\n# check that\
    \ our function\njulia_sort_even([1, 2, 3])\n</cell>\n<code language=julia-1.1>\n\
    # check that this sort function works with vectors of different lengths\njulia_sort_even([2,3,6,3,4])\n\
    </cell>\n<code language=julia-1.1>\n# check that our function\njulia_sort_even([4,7,3,9,2,5,1])\n\
    </cell>\n<text>\nExercise:\nWrite a function named sort_odd(l) that sorts a vector\
    \ l' such that\n    l is identical to l' in even indicies, while its values at\
    \ the odd indicies are equal\n    to the values of the odd indicies of l' but\
    \ sorted.\n>>> sort_odd([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_odd([5, 6, 3,\
    \ 4])\n    [4, 7, 5, 3]\n    \"\"\"", "    for i in 2:length(l)\n        if l[i]\
    \ < l[i-1]\n            swap(l[i-1], l[i])\n        else\n            break\n\
    \        end\n    end\n    return l\nend\n</code>\nThis solution is faster than\
    \ sorting the entire list. Here is an example of its speed with vectors of length\
    \ 100000:\n<code>\njulia> sort_even([x for i = 1:100000 for x in rand(1:10, 5)])\n\
    \  19.7098 seconds (96.56 k allocations: 3.875 GiB, 4.59% gc time)", "    idx\
    \ = sortperm(l)\n    return l[idx]\nend\n</cell>\n<code language=julia-1.0>",
  "    ind = 0\n    lenl = length(l)\n    while ind < lenl\n        if mod(ind,2)\
    \ == 0\n            l[ind] = l[ind+1]\n        end\n        ind = ind + 1\n  \
    \  end\n    return l\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| a |>\n<code>",
  "    for i=1:length(l)\n        if mod(i,2) == 0 \n            push!(sort(l), l[i])\
    \ \n        end\n    end\n    return l \nend\n</code>\nThe main differences are\
    \ that in the above function I removed return l and I used push! which mutates\
    \ the passed argument. \nThe second difference is that I use sort instead of sort!.\
    \ The difference is that the latter is in-place, while the former is not. \nThe\
    \ function will return the sorted vector.\n<|/ a |>\n<| c |>\nI think your code\
    \ is correct, however I prefer not to import a function for a one line operation.\
    \ This can result in some confusing code if the function is reused.\n<|/ c |>\n\
    <| c |>\nOh, and your return type is wrong, it should be `Vector{Int64}`, not\
    \ `Vector`. It's also better to use `push!` than `append!`.\n<|/ c |>\n<| c |>\n\
    , agreed, thanks for the heads up, I was using Julia's Vector{T} type. I will\
    \ update the code.\n<|/ c |>\n<| c |>\nThank you for this answer. I've been trying\
    \ to find a solution that works with my current Julia version (v0.6.5), but it's\
    \ been a pain to figure out that `push!` doesn't actually mutate the input `Vector`\
    \ object. The other issues you mentioned are probably worth mentioning in the\
    \ answer as well. Thanks!\n<|/ c |>\n<| a dscore=5 |>\nI realise this question\
    \ is quite old, but there is a much simpler way to do this.\n<code>\njulia> sort!(x::Vector{Int},\
    \ xs = xs)\n</code>\nwhere xs is the default empty vector to be sorted upon.\n\
    <|/ a tags=julia,sorting |>\n<| c |>\nThis solution is also mentioned in [this\
    \ answer](http://stackoverflow.com/a/20666455/571885).\n<|/ c |>\n<| a dscore=5\
    \ tags=julia,sorting |>\nIf you know the starting position of your vector you\
    \ can avoid creating an intermediate copy of the vector. \nThis can be done like\
    \ this:\n<code>", "    if length(l)%2 == 1\n        throw(ArgumentError(\"Vector\
    \ must be even\"))\n    elseif length(l) > length(l.sorted)\n        l = l.sorted\n\
    \    end\n    return l\nend\n</cell>\n<text>\nAnd again:", "    even = even_indicies(l)\n\
    \    odd = odd_indicies(l)\n    l.zip(even, odd).sort\nend\n</cell>\n<code language=julia-1.6>",
  "    l = sort(l)\n    for i = 2:length(l)-1\n        l[i-1] = l[i]\n    end\n  \
    \  return l\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia,arrays,sorting |>\n\
    A solution without using for loops:\n<code>\njulia> a = rand(1:5, 3);", "    \"\
    \"\"\n    l is the vector of even numbers to sort\n    \"\"\"\n    #TODO Write\
    \ Code Here\n    \"\"\"\n    l = sort_even(l)\n    for i in 2:length(l) do \n\
    \        if mod(i,2) == 1 \n            l = append(l, l[i]) \n            l =\
    \ append(l, l[i]) \n        end\n    end\n    \"\"\"\n    return l\nend", "  \
    \  sort_even.l=l\n    sort_even.even_inds=findall(x -> x % 2 == 0, l)\n    sort_even.odd_inds=findall(x\
    \ -> x % 2 != 0, l)\n    sort_even.l_sorted=l[sort_even.odd_inds]\n    sort_even.l_sorted[sort_even.even_inds]=sort_even.l_sorted[sort_even.even_inds]\n\
    \    return sort_even.l_sorted\nend\n</cell>\n<cell>\nsort_even.l(l)\n</cell>\n\
    <cell>", "    return sort(l).(l.(2:end))\nend", "    n = length(l)\n    evens\
    \ = zeros(Int, n)\n    odds = zeros(Int, n)\n    \n    for i in 1:n\n        if\
    \ mod(i, 2) == 0\n            evens[i] = l[i]\n        else\n            odds[i]\
    \ = l[i]\n        end\n    end\n    return evens + odds\nend\n</cell>\n<cell>\n\
    @doc sort_even\n</cell>\n<text>\nFunction for finding the minimum element in a\
    \ vector.", "    return l |> sort\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=0\
    \ |>\nI agree with the previous answers, but wanted to add this for people who\
    \ are using the latest version of Julia:\n<code>\njulia> function sort_even(l::Vector{Int64})::Vector{Int64}\
    \ \n           return l |> sort\n       end\nsort_even (generic function with\
    \ 1 method)\n</code>\n<|/ a tags=julia |>\n<| a |>\nThe easiest way is to use\
    \ the built-in function sortperms:\n<code>\njulia> sortperms([5, 6, 3, 4])\n5-element\
    \ Array{Int64,1}:\n 3\n 5\n 6", "    \"\"\"Sorts the even indicies of l into increasing\
    \ order.\"\"\"\n    l = l[sort.indices!(l.even.==true)]\n    return l", "    even\
    \ = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 == 1)]\n    return sorted(even,\
    \ odd)\nend", "\"\"\"This function takes a vector l and returns a vector l' such\
    \ that\n    l' is identical to l in the even indicies, while its values at the\
    \ odd indicies are equal\n    to the values of the odd indicies of l, but sorted.\n\
    \    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n\
    \    [5, 6, 4, 3]\n    \"\"\"", "    if length(l)%2 != 0\n        throw(Exception,\
    \ \"List must be even in length\")\n    end\n    even = l[end-1:end]\n    odd\
    \ = l[1:end-1]\n    return sort(union(even, odd))\nend", "    i = 2\n    l = copy(l)\n\
    \    while i <= length(l)\n        l.[i] = l.[i] + l.[i]/2\n        i += 1\n \
    \   end\n    l\nend", "    \"\"\"Sort l into even-index and odd-index components\"\
    \"\"\n    even_indicies = findall(x -> mod(x,2) == 0, l) # find indices of even\
    \ indicies\n    odd_indicies = findall(x -> mod(x,2) == 1, l) # find indices of\
    \ odd indicies\n    even_indices = even_indicies # save for later\n    sort_indices\
    \ = [even_indicies] # sort even indicies first\n    for idx in odd_indicies #\
    \ iterate through odd indicies\n        if idx == length(l)-1 # last index\n \
    \           sort_indices += [odd_indicies] # add these even indicies if needed\n\
    \        else\n            sort_indices += [idx, idx+1] # otherwise, insert at\
    \ appropriate indices and move to next index\n        end\n    end\n    return\
    \ l[sort_indices] # sort even indicies and odd indicies together\nend\n</code>\n\
    Note that I added an end statement to the function. This is because if your input\
    \ vector has fewer than two elements, then it will not have an even index which\
    \ will cause an error.\nThe function is also written in Julia 0.5 syntax. This\
    \ is because in Julia 0.5 it is not possible to define an anonymous function inline\
    \ like we did in v0.6. In Julia 0.6 it would be possible to use function instead\
    \ of functionname() but for that to work you need to use the macros function and\
    \ end instead of functionname() and end so I modified those lines in my answer.\n\
    <|/ a tags=sorting,julia,arrays |>\n<| c |>\nThis does not seem to work. (1) In\
    \ your code you used `sort_even` twice - that seems to be a typo. (2) If I run\
    \ `sort_even([1,3,2])` I receive an error: `MethodError: no method matching sort_even([::Int64])`.\
    \ (3) When I run `sort_even([3,2,1])` I get `ERROR: MethodError: no method matching\
    \ sort_even([::Int64])`. Can you clarify why the output should be `[3,2,1]` and\
    \ why `sort_even([1,3,2])` should give an error?\n<|/ c |>\n<| c |>\nSorry about\
    \ the typo, that's what happens when I copy paste code from a text editor. The\
    \ error I get is `ERROR: MethodError: no method matching sort_even([::Int64])`\
    \ so I apologize for that. My apologies, I didn't realize your question was about\
    \ sorting arrays. I will leave the answer here because I feel it could be useful\
    \ to others who come across this question in the future. I will also update the\
    \ answer.\n<|/ c |>", "    return l.sorted()\nend\n</cell>\n<text>\nLet's see\
    \ it in action:", "    l = sort(l)\n    l = sort(l)\n    l = sort(l)\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThanks, this also works. I appreciate the help! I'll\
    \ have to decide which one is more readable, but for now I'll probably accept\
    \ the other one. Again, thank you.\n<|/ c |>\n<| c |>\nThank you. Good luck :)\n\
    <|/ c |>\n<| a dscore=1 |>\nI believe this can be done using list comprehension\n\
    <code>\n[i for i in l  for i in l[1::2]]\n</code>\nThe output is \n<code>\n[1,\
    \ 2, 3, 4, 5, 6]\n</code>\n<|/ a tags=julia |>\n<| c |>\nInteresting solution.\
    \ Just to clarify, are you saying that the comprehension inside of the double\
    \ for loop is the same, just that you're using the comprehension for the even\
    \ indices? And that I can just use a single comprehension for the odd indices?\
    \ Also, I tried running this on my computer, and I got a syntax error when I tried\
    \ to use the comprehension for the odd indices.\n<|/ c |>\n<| a dscore=1 |>\n\
    As an alternative to Mr.'s solution (which uses vectorization), you could use\
    \ mapslices:\n<code>\njulia> mapslices(sort,l) \u2261 sort(l)\ntrue", "    \"\"\
    \"This function takes a vector l and returns a vector l' such that\n    l' is\
    \ identical to l in the odd indicies, while its values at the even indicies are\
    \ equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .== 1)]\n    return sort_odd(odd)\
    \ .+ sort_even(even)\nend", "    return l == sort(l) ? l : sort(l)\nend", "  \
    \  even_idx = 1:2:length(l) // 2\n    even = sort_even(subvec(l, even_idx, even_idx))\n\
    \    odd = sort_even(subvec(l, even_idx))\n    even = merge(even, odd)\n    even\
    \ = sort_even(even)\n    return even\nend\n</cell>\n<code language=julia-1.5>",
  "    if length(l)%2 ==0\n        return l\n    else\n        even = l[1 : end-1]\n\
    \        odd = l[1 : end-2]\n        even = sort_even(even)\n        odd = sort_odd(odd)\n\
    \        return even.+odd\n    end\nend\n\"\"\"This function takes a vector l\
    \ and returns a vector l' such that\n    l' is identical to l in the even indicies,\
    \ while its values at the odd indicies are equal\n    to the values of the odd\
    \ indicies of l, but sorted.\n    >>> sort_odd([1, 2, 3])\n    [1, 3, 2]\n   \
    \ >>> sort_odd([5, 6, 3, 4])\n    [4, 5, 6, 3]\n    \"\"\"", "    l' =  sort(l)\n\
    \    for i = 1:size(l)%2\n       l[i] = l[i]\n    end\n    l'\nend\n</code>\n\
    <|/ a tags=julia |>\n<| c |>\nAs an alternative to defining your own `sort_even`\
    \ function, you can also use the existing `sort_even` function `julia> sort(x)`,\
    \ as shown in my answer. `sort` takes an optional argument `rev`, which when set\
    \ to `true` reverses the order of the sorted array.\n<|/ c |>\n<| a dscore=1 |>\n\
    The Julia docs also have some sorting functions defined for you: Sort, sort!,\
    \ partition.\n<|/ a tags=julia |>\n<| a |>\nMy answer:\n<code>\nsort_even(l::Vector{Int64})::Vector{Int64}\
    \ \n    l' =  sort(l)\n    for i = 1:size(l)%2\n       l[i] = l[i]\n    end\n\
    \    l'\nend\n</code>\n<|/ a tags=julia dscore=1 |>\n<| c |>\nYou could also write\
    \ `sort_even(l::Vector{Int64})::Vector{Int64} l' =  sort(l)...` because `sort`\
    \ returns the sorted list. `sort!` modifies the original list, so you can do `l\
    \ = sort_even(l); l = sort!(l)`.\n<|/ c |>\n<| a tags=julia dscore=1 |>\nI know\
    \ I'm late to the party, but I wanted to improve on the existing solutions, and\
    \ expand on them a bit. The code below is just my own thoughts, not necessarily\
    \ the correct implementation, and I'm a novice when it comes to Julia. I used\
    \ the sort! function because it was a little simpler than the other solutions\
    \ I found. \n<code>", "    return vec(sort(l,lt)) \nend", "    even = Int64[]\n\
    \    odd = Int64[]\n    l = sort_vec(l)\n    for i in 2:length(l)\n        if\
    \ (l[i] % 2 == 0)\n            push!(even,l[i])\n        else\n            push!(odd,l[i])\n\
    \        end\n    end\n    return sort_vec(even) + sort_vec(odd)\nend", "    sorted_even\
    \ = Vector{Int64}(length(l))\n    for i in 1:length(l)\n        if i %% 2 == 0\n\
    \            sorted_even[i : (i + 1)] = sort(l[i : (i + 1)])\n        else\n \
    \           sorted_even[i : (i + 1)] = l[i : (i + 1)]\n        end\n    end\n\
    \    return sorted_even\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nA\
    \ recursive solution that will work for a list of any size will likely be faster\
    \ than a non-recursive solution.\n<code>", "    even = filter(x->x%2==0, l)\n\
    \    odd = filter(x->x%2==1, l)\n    even.sort!()\n    even = even.insert(even.end(),\
    \ odd.begin(), odd.end())\n    return even\nend\n</cell>\n<text>\nThe function\
    \ takes the following arguments:", "    l = copy(l)\n    even = l[findall(l ==\
    \ 0)]\n    odd  = l[findall(l == 1)]\n    sort(even)\n    sort(odd)\n    return\
    \ sort(union(even, odd))\nend\n</cell>\n<text>\nSome benchmarking\nLet's compare\
    \ the performance of the function sort_even with the native sort function:", " \
    \   if l.length==0 \n        return l\n    even_inds = filter((x->x%2==0),l) \n\
    \    even_vals = filter((x->x%2==1),l)\n    even_vals = sort(even_vals)\n    even_inds\
    \ = sort(even_inds)\n    sort_even_inds = even_inds\n    for i=1:length(even_inds)\n\
    \        if even_vals[i]>even_vals[even_inds[i]]\n            sort_even_inds[i]\
    \ = even_inds[i]\n            even_vals[i] = even_vals[even_inds[i]]\n       \
    \ end\n    end\n    return sort_even_inds\nend", "    length = length(l) \n  \
    \  even_indices = 1:(length/2-1) \n    odd_indices = length/2:end \n    \n   \
    \ return l[even_indices] .+ l[odd_indices] .- l[even_indices] .- l[odd_indices]\n\
    end", "    evens = Int64[i for (i, val) in enumerate(l) if val%2 == 1]\n    evens_sorted\
    \ = sort(evens, l) # evens_sorted should be identical to evens\n    \n    return\
    \ evens_sorted\nend\n</cell>\n<code language=julia-1.1>\n\"\"\"This function takes\
    \ a vector l and returns a vector l' such that\n    l' is identical to l in the\
    \ even indicies, while its values at the odd indicies are equal\n    to the values\
    \ of the odd indicies of l, but sorted.\n    >>> sort_odd([1, 2, 3])\n    [1,\
    \ 2, 3]\n    >>> sort_odd([5, 6, 3, 4])\n    [4, 5, 3, 6]\n    \"\"\"", "    even\
    \ = sort(l)\n    odd = sort(filter(x -> x % 2 == 1, l))\n    return append(even,\
    \ odd)\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI think you mean `even = sort(l)`\n\
    <|/ c |>\n<| a dscore=2 tags=arrays,julia,sorting,vector |>\nYou only need to\
    \ sort your odd indices in place then merge them into the even indices\n<code>\n\
    julia> sort_even( l::Vector{Int64}) = [ x for (i, x) in  enumerate(l) if i%2==1]\n\
    sort_even (generic function with 1 method)", "    sort!(l)\n    return l\nend",
  "  if l.length%2 != 0\n    throw(ArithmeticException(\"Input must be a vector of\
    \ even length!\"))\n  end\n  \n  even_len = l.length/2\n  \n  for j in 0:even_len\n\
    \    for i in j:even_len\n      l[i] = l[j]\n    end\n  end\n  \n  return l\n\
    end\n</cell>\n<text>\nExercise 1:\nWrite a function to reverse the order of any\
    \ input vector. \nWhat happens if we pass in a vector of odd length like [1, 2,\
    \ 3, 5] ? \nWhat happens if we pass in something that is not in the right order?\
    \ \nWhat happens if we pass in a vector of zeros?", "    if l == []\n        throw(ArgumentError(\"\
    Empty vector\"))\n    \n    n = length(l)\n    even_idx = Vector{Int64}(undef,\
    \ n)\n    for i = 1:n\n        if i % 2 == 0\n            even_idx[i] = l[i]\n\
    \        else\n            even_idx[i] = min(l[i], l[i])\n        end\n    end\n\
    \    return even_idx\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThank you for\
    \ sharing your solution!\n<|/ c |>\n<| a dscore=2 |>\nAnother option, using filter:\n\
    <code>", "  if length(l)%2 == 0 \n    return l\n  else \n    l = sort(l)\n   \
    \ odd = ones(length(l)-1) * l[end-1]\n    even = sort(l[1 : end-1])\n    return\
    \ odd .+ even\n  end\nend\n</code>\n<|/ a tags=sorting,arrays,julia |>\n<| a tags=sorting,arrays,julia\
    \ |>\nI figured out a solution, but I'm really not sure it is the most efficient:\n\
    <code>", "    l' = l.copy()\n    \n    for k in 2:(length(l)+1)/2-1\n        if\
    \ l[k] < l[k]\n            temp = l[k]\n            l[k] = l[k+2]\n          \
    \  l[k+2] = temp\n        end\n    end\n    return l\nend", "    even = sort_even([i\
    \ for i in l])\n    if length(even) < length(l)\n        return sort_even(l::Vector{Int64})\n\
    \    end\n    return even\nend\n</code>\nThe only thing you did differently is\
    \ added an argument to your function and that argument didn't exist in the original\
    \ function signature.\n<|/ a dscore=0 |>\n<| c |>\nThanks, I understand what you\
    \ are saying, and it makes sense to me. I'm just trying to figure out how to modify\
    \ my original function so that it returns the same result. I'll edit my original\
    \ post with my attempt, but I suspect I'll be doing something else wrong because\
    \ it doesn't work.\n<|/ c |>\n<| c |>\nYou said you were trying to modify your\
    \ original function. But your function was wrong, it doesn't work. That means\
    \ your new function is different from the original function. I added the new function\
    \ you wrote. Now it works.\n<|/ c |>\n<| c |>\nHi Kay. Thanks for the edits! I\
    \ see now the problem. However, the new function doesn't work. Can you explain\
    \ why? I made my original function work by simply writing \"return sort(l)\",\
    \ and I see that your new function doesn't work, and I don't understand why. Thanks\
    \ again!\n<|/ c |>\n<| c |>\nYes, you can see why in the new function, the argument\
    \ `l` is also passed as an argument to the recursive call. In the original function\
    \ the argument `l` is just passed to the recursive call, and the recursive call\
    \ does nothing with the argument.\n<|/ c |>\n<| c |>\nAh, ok. Thanks for clarifying!\
    \ I'll try what you recommended and let you know if it works!\n<|/ c |>\n<| a\
    \ |>\nI think it would be more useful to return the result of sort(l) on the second\
    \ branch of your if-else statement. \nWhen you write \n<code>", "    l = copy(l)\n\
    \    for i=2:length(l)\n        if l[i] % 2 == 0 && (l[i] % 2 != 0 || i == 1)\n\
    \            l[i-1] = l[i]\n            delete!(l, i)\n        end\n    end\n\
    \    return l\nend", "    even::Vector{Int64}=copy(l)\n    even.sort!(Int.(even))\n\
    \    even\nend\n</code>\n<|/ a |>\n<| c |>\nThanks, I tested this implementation\
    \ and it's actually faster than the original one.\n<|/ c |>\n<| a tags=sorting,julia,performance\
    \ |>\nI created an improved version of this answer by adding an extra sorting\
    \ step that avoids redundant copying (that happened in the original version).\n\
    <code>", "    even = l[(1::2)] # get even indicies\n    odd = l[(2::2)] # get\
    \ odd indicies\n    return even.union(odd).sort\nend\n</code>\n<|/ a |>\n<| a\
    \ tags=julia,julia-jump,performance,arrays dscore=2 |>\n<code>", "    even_values\
    \ = l.filter(x -> x % 2 == 0)\n    sorted_values = even_values.sort()\n    sorted_odd_values\
    \ = even_values.filter(x -> x % 2 == 1).sort()\n    l' = copy(l)\n    for i in\
    \ 0..(length(l)-1)\n        l'[i] = sorted_odd_values[i]\n    end\n    return\
    \ l'\nend\n</code>\n<|/ a dscore=2 |>\n<| a |>\nA slight variation on the solution\
    \ posted by. I think its better to sort once and then swap the values using array\
    \ indexing.\n<code>", "    sort_vec(l)\nend\n</cell>\n<code language=julia-0.6>\n\
    sort_even([5,2,6,4,3])\n</cell>\n<text>\nExercise (10min): How would you modify\
    \ sort_even() in such a way that it takes vectors of other types? (hint: see documentation\
    \ for function typeof)", "    even = sort_even(even(sort_odd(l)))\n    return\
    \ l[even] .+ l[sortperm(even)]\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
