name: HumanEval_160_do_algebra
language: jl
prompt: "\"\"\"\n    Given two vectors operator, and operand. The first vector has\
  \ basic algebra operations, and \n    the second vector is a vector of integers.\
  \ Use the two given vectors to build the algebric \n    expression and return the\
  \ evaluation of this expression.\n\n    The basic algebra operations:\n    Addition\
  \ ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division\
  \ ( // ) \n    Exponentiation ( ** ) \n\n    Example:\n    operator['+', '*', '-']\n\
  \    vector = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n  \
  \  Note:\n        The length of operator vector is equal to the length of operand\
  \ vector minus one.\n        Operand is a vector of of non-negative integers.\n\
  \        Operator vector has at least one operator, and operand vector has at least\
  \ two operands.\n\n    \"\"\"\nfunction do_algebra(operator::Vector{String}, operand::Vector{Int64})::Int64\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = do_algebra;\n\t@test(candidate([\"\
  **\", \"*\", \"+\"], [2, 3, 4, 5]) == 37)\n\t@test(candidate([\"+\", \"*\", \"-\"\
  ], [2, 3, 4, 5]) == 9)\n\t@test(candidate([\"//\", \"*\"], [7, 3, 4]) == 8)\nend\n"
completions: ["    vectorLength = (length(operator) - 1)\n    if length(operand) <\
    \ vectorLength\n        errorln(\"Operand vector too small\")\n    end", "   \
    \ operatorSize = length(operator)\n    operandSize = length(operand)\n    assert(operatorSize\
    \ == operandSize, 'Operator and operand vectors must have same length.')", " \
    \       \n    ## The length of operator vector is equal to the length of operand\
    \ vector minus one.\n    if len(operator) != length(operand) - 1 \n        error(\"\
    The length of operator vector is incorrect\")\n    end", "    vector_length =\
    \ length(operand)\n    if vector_length < 1\n        error(\"The length of operator\
    \ vector is smaller than the length of operand vector.\")\n    end\n    vector_length\
    \ += 1\n    result = 1\n    for operator in operator\n        if operator == \"\
    *\"\n            result*=operand\n        elseif operator == \"/\"\n         \
    \   quotient = quotient(result, operand)\n        elseif operator == \"+\"\n \
    \           result+=operand\n        elseif operator == \"-\"\n            result-=operand\n\
    \        elseif operator == \"**\"\n            result^=operand\n        elseif\
    \ operator == \"//\"\n            result = quotient(result, operand)\n       \
    \ else\n            error(\"Unknown operator.\")\n        end\n    end\n    return\
    \ result\nend", "    result = 1\n    for operador in operand\n        result =\
    \ result * (operador ^ eval(operator))\n    end\n    result\nend", "    return\
    \ do_inner(operator, operand)\nend", "    \"\"\"Perform algebraic operation on\
    \ operands given the operators\"\"\"\n    operations = []\n    for op_str in operator\n\
    \        operations.push(op_str)\n    end\n    num_operations = length(operations)\n\
    \    num_operands = length(operand)\n    if num_operations != num_operands - 1\n\
    \        error(\"Operands have different length\")\n    end\n    result_val =\
    \ 0\n    for ii = 1 : num_operands\n        op_str = operations[ii]\n        op_int\
    \ = toInt(op_str)\n        op_val = op_int\n        if op_int == 0\n         \
    \   op_val = -1\n        elseif op_int == 1\n            op_val = 1\n        end\n\
    \        result_val += operand[ii] * op_val\n    end\n    return result_val\n\
    end", "    \"\"\" do_algebra(operator::Vector{String}, operand::Vector{Int64})::Int64\n\
    \    Given two vectors operator, and operand. The first vector has basic algebra\
    \ operations, and \n    the second vector is a vector of integers. Use the two\
    \ given vectors to build the algebric \n    expression and return the evaluation\
    \ of this expression.", "   \n    # check if there are enough operands to build\
    \ the expression\n    if length(operand) < length(operator)-1 \n       return\
    \ 0\n    end", "    result = operand[1]\n    for i = 2:length(operator)\n    \
    \    result =  operator[i](result, operand[i])\n    end\n    return result\nend",
  "    i = find(vector in operator,1) # find index of the operator in operator vector\n\
    \    j=find(vector in operand,1) # find index of the operand in operand vector\n\
    \    k=find(vector in operator,2) # find index of the operator in operator vector\n\
    \    l=find(vector in operand,2) # find index of the operand in operand vector\n\
    \    \n    if (k == 0 && l == 0) # if both operator and operand vector are empty\
    \ vector\n        return operand[1]*operator[1]\n    elseif k == 0 \n        return\
    \ operand[1]*(operator[1]+operand[1]-operator[2]+operand[2])\n    elseif l ==\
    \ 0 \n        return (operand[1]*operator[1])+(operator[1]+operand[1]-operator[2]+operand[2])\n\
    \    else\n        return operand[1]*(operator[1]+operand[1]-operator[2]+operand[2])+(operator[k]+operand[l])\n\
    \    end\nend\n</code>\n<code>\n\"\"\"\n    Given two vectors operator, and operand.\
    \ The first vector has basic algebra operations, and \n    the second vector is\
    \ a vector of integers. Use the two given vectors to build the algebric \n   \
    \ expression and return the evaluation of this expression.", "    length_operand_vector\
    \ = length(operand)\n    length_operator_vector = length(operator)\n    \n   \
    \ if length_operand_vector != length_operator_vector - 1 || \n        length_operand_vector\
    \ != length_operator_vector \n        error(\"The length of operator vector does\
    \ not match the length of operand vector minus one.\")\n    end", "    \n    algebric_expression\
    \ = \n    \"\"\"\n    algebric_expression = \n    \"\"\"\n    \n    return eval(algebric_expression)\n\
    end", "    assert(length(operand) == length(operator) - 1)\n    \n    op_int =\
    \ Int64(operator[1])\n    op_sign = Int64(operator[2])\n    \n    if op_sign ==\
    \ -1\n        operand = reverse(operand)\n    end", "  \n    # Convert each element\
    \ in operand from String to Int64:\n    operand = convert(Vector{Int64}, operand)",
  "    result = Int64(0)\n    \n    for i = 1:length(operand)\n        result = result\
    \ + (eval(substitute(operator[i], Dict(:a => operand[i]), \n                 \
    \                 Dict(:a => a, :b => b)))\n    end\n    \n    return result\n\
    end", "    expr = Int64[]\n    vec_len1 = length(operator)\n    vec_len2 = length(operand)\n\
    \    if vec_len1 \u2265 1 && vec_len2 \u2265 1 \n        append!(expr, \n    \
    \        op_map[operator[1]](operand[1],operand[2],operand[3],operand[4],operand[5])\n\
    \        )\n        for i = 6:vec_len1 \n            append!(expr,\n         \
    \       op_map[operator[i]](operand[i-1],operand[i-2],operand[i-3],operand[i-4],operand[i-5])\n\
    \            )\n        end\n        return expr\n    elseif vec_len1 \u2265 2\
    \ || vec_len2 \u2265 2 \n        if vec_len1 \u2265 vec_len2 \n            append!(expr,\n\
    \                op_map[operator[2]](operand[1],operand[2])\n            )\n \
    \       else\n            append!(expr,\n                op_map[operator[2]](operand[1],operand[2])\n\
    \            )\n            append!(expr,\n                op_map[operator[3]](operand[2],operand[3])\n\
    \            )\n        end\n        \n        for i = 4:vec_len1 \n         \
    \   append!(expr,\n                op_map[operator[i]](operand[i-1],operand[i-2],operand[i-3])\n\
    \            )\n        end\n        return expr\n    else\n        return \n\
    \            println(\"Error: wrong vector sizes\")\n            println(\"operator\
    \ size is $vec_len1 and operand size is $vec_len2\")\n            println(\"operator\
    \ vector is: $operator\")\n            println(\"operand vector is: $operand\"\
    )\n    end\nend", "    alg = Vector{Vector{String}}(operator)\n    ans = Int64(0)\n\
    \    for i in 1:length(operand)\n        ans = ans + alg.(operand[i])\n    end\n\
    \    return ans\nend", "    if length(operator) > length(operand) \n        throw(ArgumentError(\"\
    Error: operator length is greater than operand length\"))\n    elseif length(operator)\
    \ == length(operand) \n        # do nothing\n    elseif length(operator) == 1\
    \ \n        # do nothing\n    elseif length(operator) == 2 \n        # do nothing\n\
    \    elseif length(operator) == 3 \n        do_algebra_3(operator, operand)\n\
    \    elseif length(operator) == 4 \n        do_algebra_4(operator, operand)\n\
    \    elseif length(operator) == 5 \n        do_algebra_5(operator, operand)\n\
    \    elseif length(operator) == 6 \n        do_algebra_6(operator, operand)\n\
    \    elseif length(operator) == 7 \n        do_algebra_7(operator, operand)\n\
    \    elseif length(operator) == 8 \n        do_algebra_8(operator, operand)\n\
    \    elseif length(operator) == 9 \n        do_algebra_9(operator, operand)\n\
    \    elseif length(operator) == 10 \n        do_algebra_10(operator, operand)\n\
    \    elseif length(operator) == 11 \n        do_algebra_11(operator, operand)\n\
    \    elseif length(operator) == 12 \n        do_algebra_12(operator, operand)\n\
    \    elseif length(operator) == 13 \n        do_algebra_13(operator, operand)\n\
    \    elseif length(operator) == 14 \n        do_algebra_14(operator, operand)\n\
    \    elseif length(operator) == 15 \n        do_algebra_15(operator, operand)\n\
    \    elseif length(operator) == 16 \n        do_algebra_16(operator, operand)\n\
    \    elseif length(operator) == 17 \n        do_algebra_17(operator, operand)\n\
    \    elseif length(operator) == 18 \n        do_algebra_18(operator, operand)\n\
    \    elseif length(operator) == 19 \n        do_algebra_19(operator, operand)\n\
    \    elseif length(operator) == 20 \n        do_algebra_20(operator, operand)\n\
    \    elseif length(operator) == 21 \n        do_algebra_21(operator, operand)\n\
    \    elseif length(operator) == 22 \n        do_algebra_22(operator, operand)\n\
    \    elseif length(operator) == 23 \n        do_algebra_23(operator, operand)\n\
    \    elseif length(operator) == 24 \n        do_algebra_24(operator, operand)\n\
    \    elseif length(operator) == 25 \n        do_algebra_25(operator, operand)\n\
    \    elseif length(operator) == 26 \n        do_algebra_26(operator, operand)\n\
    \    elseif length(operator) == 27 \n        do_algebra_27(operator, operand)\n\
    \    elseif length(operator) == 28 \n        do_algebra_", "    total = 0 \n \
    \   for i = 1:length(operand)-1 \n        if operator[i] == operator[i+1] \n \
    \           if operand[i] > operand[i+1] \n                total = total + operand[i]\
    \ \n            elseif operand[i] < operand[i+1] \n                total = total\
    \ - operand[i] \n            elseif operand[i] == operand[i+1] \n            \
    \    total = total * operand[i] \n            elseif operand[i] == 1 \n      \
    \          total = total / operand[i] \n            end\n        else \n     \
    \       total = total + operand[i] \n        end\n    end\n    total\nend", " \
    \   count = 0\n    for i = 1:size(operator)[1] \n        for j = 1:size(operator)[2]\
    \ \n            if isa(operator[i], Symbol) && isa(operand[j], Int64) && isa(operator[i],\
    \ String)\n                if symbol_value(operator[i]) == symbol_value(operand[j])\n\
    \                    count += 1\n                end\n            end\n      \
    \  end\n    end\n    return count\nend\nend", "    \n    \n    sum = 0\n    for\
    \ i in 1:length(operator)\n        sum += operator[i] * operand[length(operand)-i]\n\
    \    end\n    return sum\nend", "    \n    temp_sum = Vector{Int64}(undef,length(operator)-1)\n\
    \    for i = 1:length(operator)-1\n        temp_sum[i] = operator[i] == '+' ?\
    \ operand[i+1:end] : 0\n    end\n    return temp_sum\nend", "    \n    # Check\
    \ to make sure the given arguments have the same length\n    if length(operator)\
    \ != length(operand) - 1 \n        error(\"Operand and Operator vectors have different\
    \ lengths.\")\n    end\n    \n    # Start with empty vector\n    vec =  Array{Int64}(undef,\
    \ 0)\n    \n    # Go through the vectors and append the elements to the empty\
    \ vector\n    for operation, operand in product(operator, operand)\n        vec\
    \ += (if operation == \"+\" then operand else 0)\n    end", "    result = Int64(0)\n\
    \    lenOperator = length(operator)\n    lenOperand = length(operand)\n    \n\
    \    if (lenOperand == 0)\n        return result\n    if (lenOperand == 1)\n \
    \       return operand[1]\n    if (lenOperand == 2)\n        return operand[1]\
    \ * operand[2]\n    if (lenOperand == 3)\n        return operand[1] * operand[2]\
    \ + operand[3]\n    \n    println(\"Invalid number of operands\")\n    return\
    \ 0\nend", "    sum = 0\n    for i=1:length(operator)-1 \n        sum = sum +\
    \ (getvalue(operand[i]) \u22C8 getvalue(operator[i]))\n    end\n    sum = sum\
    \ + getvalue(operand[length(operand)])\n    return sum\nend", "    \n    vectorLength\
    \ = length(operator)\n    if vectorLength > length(operand)\n        println(\"\
    Vector operator and vector operand are too long.\", operator, operand)\n    end\n\
    \    \n    i = 0\n    sum = 0\n    while i < vectorLength\n        push!(sum,\
    \ operator[i])\n        push!(sum, operand[i])\n        i = i + 1\n    end\n \
    \   return sum[1]\nend\n    \n    \n\"\"\"\n    Given an expression and two operands,\
    \ return the result of the expression using the \n    given operands as parameters.\
    \ The expression can only consist of a single operator \n    and a pair of operands.\
    \ For example, if expression = '1 + 2', then operator '+'\n    and operand '2'\
    \ are used as parameters. ", "    operator = operator[1:end]\n    operand = operand[1:end-1]\n\
    \    if length(operator) == 0 && length(operand) == 0 \n        return 0 \n  \
    \  end\n    # If the operand vector length is less than the operator vector, \n\
    \    # the first operator vector is given as the first operator to the algebra\
    \ expression.\n    if length(operator) < length(operand)\n        operator = operator[1:end]\n\
    \        operand = operand[1:end]\n    end", "  \n  # Get the length of operator\
    \ vector\n  nOperators = length(operator)\n  if nOperators == length(operand)\
    \ - 1 \n    # No operator and one operand \n    return ops[operator](operand)\
    \ \n  elseif nOperators == length(operand) - 2 \n    # One operator and two operands\
    \ \n    return ops[operator](operand[1], operand[2]) \n  elseif nOperators ==\
    \ length(operand) - 3 \n    # One operator and three operands \n    return ops[operator](operand[1],\
    \ operand[2], operand[3]) \n  elseif nOperators == length(operand) - 4 \n    #\
    \ One operator and four operands \n    return ops[operator](operand[1], operand[2],\
    \ operand[3], operand[4]) \n  elseif nOperators == length(operand) - 5 \n    #\
    \ One operator and five operands \n    return ops[operator](operand[1], operand[2],\
    \ operand[3], operand[4], operand[5]) \n  elseif nOperators == length(operand)\
    \ - 6 \n    # One operator and six operands \n    return ops[operator](operand[1],\
    \ operand[2], operand[3], operand[4], operand[5], operand[6]) \n  end", "    eval\
    \ = zeros(Int, length(operator))\n    for i = 1:length(operator)\n        eval[i]\
    \ = eval(operator[i], operand[i]) \n    end\n    return eval\nend", "    \n  \
    \  A = zeros(length(operator))\n    B = zeros(length(operand) - 1)", "    \"\"\
    \"\n    Given two vectors operator, and operand. The first vector has basic algebra\
    \ operations, and \n    the second vector is a vector of integers. Use the two\
    \ given vectors to build the algebric \n    expression and return the evaluation\
    \ of this expression.", "    \"\"\"\n    Given two vectors operator, and operand.\
    \ The first vector has basic algebra operations, and \n    the second vector is\
    \ a vector of integers. Use the two given vectors to build the algebric \n   \
    \ expression and return the evaluation of this expression.", "  \n    if length(operator)\
    \ < 1 || length(operand) < 2 \n        return -1\n    elseif length(operator)\
    \ == length(operand) \n        return do_algebra(operator, operand)\n    end\n\
    \    \n    \n    left_vector, right_vector, left_operation, right_operation =\
    \ unpack_vectors(operator, operand)\n    \n    left_vector = left_vector - left_operation\n\
    \    right_vector = right_vector - right_operation\n    \n    left_length = length(left_vector)\n\
    \    right_length = length(right_vector)\n    \n    if left_length == right_length\
    \ \n        # scalar product\n        result = left_vector * right_vector\n  \
    \      return sum(result)\n    elseif right_length == 1 \n        # scalar product\
    \ (dot product)\n        result = left_vector' * right_vector\n        return\
    \ sum(result)\n    elseif left_length == 1 \n        # scalar product (dot product)\n\
    \        result = right_vector' * left_vector\n        return sum(result)\n  \
    \  else\n        \n        if length(left_vector) < length(right_vector)\n   \
    \         left_vector, right_vector, right_vector, left_vector = right_vector,\
    \ left_vector, left_vector, right_vector\n        end\n        \n        # scalar\
    \ product (dot product)\n        result = left_vector' * right_vector\n      \
    \  return sum(result)\n    end\n    \nend", "    # get the operation from the\
    \ first vector\n    operation = operator[1]\n    # get the first element from\
    \ the second vector\n    operand1 = operand[2]\n    # get the second element from\
    \ the second vector\n    operand2 = operand[3]\n    # evaluate the expression\n\
    \    if operation == \"+\":\n        result = operand1 + operand2\n    elif operation\
    \ == \"-\":\n        result = operand1 - operand2\n    elif operation == \"*\"\
    :\n        result = operand1 * operand2\n    elif operation == \"//\":\n     \
    \   result = operand1 // operand2\n    elif operation == \"**\":\n        result\
    \ = operand1 ** operand2\n    end\n    return result\nend", "    \"\"\"\n    Given\
    \ two vectors operator, and operand. The first vector has basic algebra operations,\
    \ and \n    the second vector is a vector of integers. Use the two given vectors\
    \ to build the algebric \n    expression and return the evaluation of this expression.",
  "    \n    \"\"\"\n    Given two vectors operator, and operand. The first vector\
    \ has basic algebra operations, and \n    the second vector is a vector of integers.\
    \ Use the two given vectors to build the algebric \n    expression and return\
    \ the evaluation of this expression.", "    \"\"\"\n    Given two vectors operator,\
    \ and operand. The first vector has basic algebra operations, and \n    the second\
    \ vector is a vector of integers. Use the two given vectors to build the algebric\
    \ \n    expression and return the evaluation of this expression.", "    # If the\
    \ length of operator vector is not equal to length of operand vector minus one,\n\
    \    # raise an error.\n    length = length(operator) - length(operand)\n    if\
    \ length < 0\n        raise ArgumentError( \"\"\"Invalid operator and operand\
    \ vectors.\n                               The length of operator vector must\
    \ be less than \n                               the length of operand vector minus\
    \ one.\n                               \"\"\")\n    end", "    \n    if length(operator)\
    \ == 0 || length(operand) == 0 \n        error(\"Error: Invalid vector combination\"\
    )\n    end\n    if length(operator) == 1 \n        return eval(operator[1], operand)\n\
    \    elseif length(operator) == 2 \n        return eval(operator[1], operand)\
    \ * eval(operator[2], operand)\n    elseif length(operator) == 3 \n        return\
    \ eval(operator[1], operand) * eval(operator[2], operand) * eval(operator[3],\
    \ operand)\n    elseif length(operator) == 4 \n        return eval(operator[1],\
    \ operand) * eval(operator[2], operand) * eval(operator[3], operand) * eval(operator[4],\
    \ operand)\n    elseif length(operator) == 5 \n        return eval(operator[1],\
    \ operand) * eval(operator[2], operand) * eval(operator[3], operand) * eval(operator[4],\
    \ operand) * eval(operator[5], operand)\n    elseif length(operator) == 6 \n \
    \       return eval(operator[1], operand) * eval(operator[2], operand) * eval(operator[3],\
    \ operand) * eval(operator[4], operand) * eval(operator[5], operand) * eval(operator[6],\
    \ operand)\n    elseif length(operator) == 7 \n        return eval(operator[1],\
    \ operand) * eval(operator[2], operand) * eval(operator[3], operand) * eval(operator[4],\
    \ operand) * eval(operator[5], operand) * eval(operator[6], operand) * eval(operator[7],\
    \ operand)\n    elseif length(operator) == 8 \n        return eval(operator[1],\
    \ operand) * eval(operator[2], operand) * eval(operator[3], operand) * eval(operator[4],\
    \ operand) * eval(operator[5], operand) * eval(operator[6], operand) * eval(operator[7],\
    \ operand) * eval(operator[8], operand)\n    end\nend\n    \n    return do_algebra(operator,\
    \ operand)\nend\n</cell>\n<code language=julia-1.5>\n# Example\nvector1 = [2,3,4,5]\n\
    vector2 = [10,20,30,40]\noperator = [\"+\",\"*\",\"-\"]\nres = do_algebra(operator,\
    \ vector1)\n</cell>\n<code language=julia-1.5>\n# Example\nvector1 = [2,3,4,5]\n\
    vector2 = [10,20,30,40]\noperator = [\"+\",\"*\",\"-\",\"*\"]\nres = do_algebra(operator,\
    \ vector1)\n</cell>\n<code language=julia-1.5>\n# Example\nvector1 = [2,3,4,5]\n\
    vector2 = [10,20,30,40]\noperator = [\"+\",\"*\",\"-\",\"*\",\"*\",\"*\"]\nres\
    \ = do_algebra(operator, vector1)\n</cell>\n<code language=julia-1.5>\n# Example\n\
    vector1 = [2,3,4,5]\nvector2 = [10,20,30,40]\noperator = [\"+\",\"*\",\"-\",\"\
    *\",\"*\",\"*\",\"*\",\"-\"]\nres = do_algebra(operator, vector1)\n</cell>\n<code\
    \ language=", "    operand = convert_int_vector(operand)\n    operator = convert_int_vector(operator)\n\
    \    operations = union(operator, operand)\n    \n    operand_length = length(operand)\n\
    \    operation_length = length(operator)\n    \n    if operand_length ~= operation_length\
    \ \n        error(\"Invalid input: Length of operator must be equal or greater\
    \ than length of operand.\")\n    end", "    length = len(operator)\n    \n  \
    \  # if the operator vector is of length zero, return 0\n    if length == 0\n\
    \        return 0\n    \n    # if the operand vector is of length zero, return\
    \ 0\n    if length < 2\n        return 0\n    \n    # create a vector with only\
    \ operators and one operator and one operand to evaluate\n    operators = [\"\
    +\", \"*\", \"-\", \"//\", \"**\"]\n    operator_vector = operators[0 : length(operator)]\n\
    \    \n    # create a vector with only operators and one operator and one operand\
    \ to evaluate\n    operands = [\"+\", \"*\", \"-\", \"//\", \"**\"]\n    operand_vector\
    \ = operands[0 : length(operand)]\n    \n    # a vector of ints initialized to\
    \ zero\n    vector = zeros(Int64, 2)", "    \"\"\"\n    Given two vectors operator,\
    \ and operand. The first vector has basic algebra operations, and \n    the second\
    \ vector is a vector of integers. Use the two given vectors to build the algebric\
    \ \n    expression and return the evaluation of this expression.", "    \"\"\"\
    \n    Given two vectors operator, and operand. The first vector has basic algebra\
    \ operations, and \n    the second vector is a vector of integers. Use the two\
    \ given vectors to build the algebric \n    expression and return the evaluation\
    \ of this expression.", "    result = zeros(Int64, length(operator))\n    operator_length\
    \ = length(operator)\n    operand_length = length(operand)", "    result = zeros(Int64,\
    \ length(operand)-1)\n    for i = 1:length(operator)-1 \n        if operator[i]\
    \ ~= '+'\n            if operator[i] ~= '-'\n                push!(result, operand[i+1])\n\
    \            else\n                if operand[i] < 0\n                    error(\"\
    Operand vector must have non-negative integers\")\n                else\n    \
    \                push!(result, -operand[i+1])\n                end\n         \
    \   end\n        else\n            push!(result, operand[i+1])\n        end\n\
    \    end\n    result\nend\n</cell>\n<text>\nWe have now implemented our algebric\
    \ expression evaluation function. We are now ready to implement our main function.\
    \ Our function will do the following:", "    \n    if length(operator) == length(operand)\
    \ - 1 \n        operand, operator = operator.drop(1), operator.drop(1)\n    end\n\
    \    \n    expression = \"\"\n    for e in operand\n        if e == 0\n      \
    \      expression += \"_\"\n        elseif e == 1\n            expression += \"\
    x\"\n        elseif e == -1\n            expression += \"-x\"\n        elseif\
    \ e == 2\n            expression += \"x^2\"  \n        elseif e == -2\n      \
    \      expression += \"-x^2\"  \n        elseif e == 3\n            expression\
    \ += \"x^3\"\n        elseif e == -3\n            expression += \"-x^3\"\n   \
    \     elseif e == 4\n            expression += \"x^4\"\n        elseif e == -4\n\
    \            expression += \"-x^4\"\n        elseif e == 5\n            expression\
    \ += \"x^5\"\n        elseif e == -5\n            expression += \"-x^5\"\n   \
    \     elseif e == 6\n            expression += \"x^6\"\n        elseif e == -6\n\
    \            expression += \"-x^6\"\n        elseif e == 7\n            expression\
    \ += \"x^7\"\n        elseif e == -7\n            expression += \"-x^7\"\n   \
    \     elseif e == 8\n            expression += \"x^8\"\n        elseif e == -8\n\
    \            expression += \"-x^8\"\n        elseif e == 9\n            expression\
    \ += \"x^9\"\n        elseif e == -9\n            expression += \"-x^9\"\n   \
    \     elseif e == 10\n            expression += \"x^10\"\n        elseif e ==\
    \ -10\n            expression += \"-x^10\"\n        elseif e == 11\n         \
    \   expression += \"x^11\"\n        elseif e == -11\n            expression +=\
    \ \"-x^11\"\n        elseif e == 12\n            expression += \"x^12\"\n    \
    \    elseif e == -12\n            expression += \"-x^12\"\n        elseif e ==\
    \ 13\n            expression += \"x^13\"\n        elseif e == -13\n          \
    \  expression += \"-x^13\"\n        elseif e == 14\n            expression +=\
    \ \"x^14\"\n        elseif e == -14\n            expression += \"-x^14\"\n   \
    \     elseif e == 15\n            expression += \"x^15\"\n        elseif e ==\
    \ -15\n            expression += \"-x^15\"\n        elseif e == 16\n         \
    \   expression += \"x^16\"\n        elseif e == -16\n            expression +=\
    \ \"-x^16\"\n        elseif e == 17\n            expression += \"x^17\"\n    \
    \    elseif e == -17\n            expression += \"-x^17\"\n", "    \"\"\"\n  \
    \  Given two vectors operator, and operand. The first vector has basic algebra\
    \ operations, and \n    the second vector is a vector of integers. Use the two\
    \ given vectors to build the algebric \n    expression and return the evaluation\
    \ of this expression.", "    \n    sum_operand = operand[1]\n    sum_oper = operator[1]\n\
    \    length = length(operator)\n    result = zeros(length(operand) - 1)\n    for\
    \ i = 2:length(operand)\n        result[i - 1] = sum_operand * operand[i] * sum_oper\n\
    \    end", "    result = zero(Int64)\n    for op in operator\n        value =\
    \ operand[end]\n        switch op\n            case '+' \n                value\
    \ = value + value\n            case '-' \n                value = value - value\n\
    \            case '*'\n                value = value * value\n            case\
    \ '/' \n                value = value // value\n            case '**' \n     \
    \           value = value ** value\n        end\n        result += value\n   \
    \ end\n    return result \nend\n</cell>\n<code language=julia-0.6>\ndo_algebra(operator::Vector{String},\
    \ operand::Vector{Int64})\n</cell>\n<code language=julia-0.6>\n@test do_algebra([\
    \ '+', '*', '-' ], [ 2, 3, 4, 5 ])  == 9\n@test do_algebra([ '+', '*', '-' ],\
    \ [ -2, 3, 4, 5 ])  == 9\n@test do_algebra([ '+', '*', '-' ], [ -2, -3, 4, 5 ])\
    \ == 9\n@test do_algebra([ '+', '*', '-' ], [ -2, 3, 4, -5 ])  == 9\n@test do_algebra([\
    \ '+', '*', '-' ], [ -2, 3, 4, 5 ])  == 9\n@test do_algebra([ '+', '*', '-' ],\
    \ [ -2, -3, 4, 5 ]) == 9\n@test do_algebra([ '+', '*', '-' ], [ -2, 3, 4, -5 ])\
    \  == 9\n@test do_algebra([ '+', '*', '-' ], [ -2, 3, 4, 5 ])  == 9\n@test do_algebra([\
    \ '+', '*', '-' ], [ -2, -3, 4, -5 ]) == 9\n</cell>\n<text>\nExercise 3\nThe following\
    \ function solves a system of linear equations:", "  \n    # initialize result\n\
    \    result = 0\n    \n    # loop through operands\n    for i in operand:\n  \
    \      # initialize accumulator with i\n        accumulator = 0", "    length(arg)\
    \ = length(operand) - 1 \n    \n    # Create a vector for expression\n    expression\
    \ = zeros(Int, length)\n    \n    # Traverse the operands and operators one by\
    \ one\n    for i = 1 : length(operator)\n        \n        # Traverse operands\n\
    \        for j = 1 : length(operand)\n            \n            # If the operand\
    \ is non-negative, then do the operation\n            if operand[j] >= 0\n   \
    \             \n                # If the operation is unary (no argument or parenthesis),\
    \ then store it in expression\n                if operator[i] == '-' \n      \
    \              expression[i] = expression[i] - operand[j]\n                \n\
    \                # If the operation is a binary (one argument and parenthesis),\
    \ then store it into expression\n                else \n                    expression[i]\
    \ = expression[i] + (operator[i] * operand[j])\n            end\n        end\n\
    \    end\n    return expression\nend\n</cell>\n<text>\nTest your function\nRun\
    \ the cell below to test your function.", "    sum = 0\n    diff = max(length(operator),\
    \ length(operand)) - 1 # Don't forget -1 because we need to subtract 1 from operand\n\
    \    # Do the computations with the two operands\n    for i=1: diff\n        sum\
    \ += operator[i-1] * operand[i-1]\n    end\n    # Return the result\n    return\
    \ sum\nend", "    index_1, index_2 = 0, 0\n    index_3 = 1\n    index_4 = 1\n\
    \    result = Int64(0)\n    while index_1 < length(operator) && index_2 < length(operand)\n\
    \        if operator[index_1] == operator[index_2]\n            index_1 += 1\n\
    \            index_2 += 1\n        else\n            if operator[index_3] == operator[index_4]\n\
    \                result += operand[index_1] * operand[index_2]\n             \
    \   index_3 += 1\n                index_4 += 1\n            else\n           \
    \     if operator[index_3] < operator[index_4]\n                    result +=\
    \ operand[index_1] + operand[index_2]\n                    index_3 += 1\n    \
    \            else\n                    result += operand[index_1] - operand[index_2]\n\
    \                    index_4 += 1\n                end\n            end\n    \
    \    end\n    end", "    op = operator[1]\n    for i = 2:length(operator)\n  \
    \      op = \"(\" + op + operator[i] + \")\"\n    end\n    for i = 2:length(operand)\n\
    \        operand[i] = \"(\" + operand[i] + \")\"\n    end\n    eval(op)\n    return\
    \ operand\nend\n</code>\n<|/ a |>\n<| c |>\nThis code is great and it works very\
    \ well. However it is not the one I am looking for. The reason is that I would\
    \ like to use this algebric expression in a bigger function and I need to be able\
    \ to use any vector with non-negative integers as operand. Is there any way to\
    \ do this? It would be nice if I could use the code above by defining a new function\
    \ that could be used in the bigger function.\n<|/ c |>\n<| c |>\nThis code is\
    \ an example of how one can use operators as a function of the two vectors. So\
    \ if you have your operator in a string, you can also use it as a function of\
    \ the two vectors. You can then pass the two vectors to evaluate any algebra expression.\
    \ Also you can create new vectors by using the same operators. You don't need\
    \ to create a function for each operator. Just one function will do it.\n<|/ c\
    \ |>\n<| c |>\nI see what you mean. I am still having trouble doing that. My initial\
    \ problem was that I was thinking I could define a new function using ```operator\
    \ = \"+\"``` as my ```operator``` argument. However that does not work. My initial\
    \ question was poorly described. I am sorry about that. I will edit it soon. Thank\
    \ you for your help.\n<|/ c |>\n<| c |>\nI edited my answer, hope it helps. Let\
    \ me know if anything is unclear.\n<|/ c |>\n<| c |>\nThat is amazing. Thank you\
    \ so much. This really helped me out. Your explanation is much appreciated. I\
    \ will take this as my answer once I am able to implement it on my bigger function.\n\
    <|/ c |>\n<| a tags=julia dscore=2 |>\nI would recommend to use Expressions:\n\
    <code>\njulia> using Expressions", "    \n    op_len = len(operator)\n    \n \
    \   # Make sure the length of operator vector is equal to the length of operand\
    \ vector minus one\n    assert((length(operator) == length(operand) - 1) && \"\
    The length of operator vector is equal to the length of operand vector minus one\"\
    )\n    \n    # Make sure the length of operand vector is greater than or equal\
    \ to two\n    assert((length(operand) >= 2) && \"The length of operand vector\
    \ is greater than or equal to two\")\n    \n    # Check if the given operator\
    \ is in operator\n    if contains(operator, '-') && !contains(operator, '/')\n\
    \        \n        # Build a list from the operand vector\n        operandlist\
    \ = copy(operand)\n        \n        # Pop two operands from the operand list\n\
    \        operandlist.pop(1)\n        operandlist.pop(1)\n        \n        # Calculate\
    \ expression\n        operandlist[1] = operandlist[1] ** operandlist[2]\n    \
    \    \n        # Append the result of list to the operand vector\n        operand\
    \ = [operandlist[1]] + copy(operandlist)\n        \n    end\n    \n    # Check\
    \ if the given operator is in operator\n    if contains(operator, '+') && !contains(operator,\
    \ '/')\n        \n        # Build a list from the operand vector\n        operandlist\
    \ = copy(operand)\n        \n        # Pop two operands from the operand list\n\
    \        operandlist.pop(1)\n        operandlist.pop(1)\n        \n        # Calculate\
    \ expression\n        operandlist[1] = operandlist[1] + operandlist[2]\n     \
    \   \n        # Append the result of list to the operand vector\n        operand\
    \ = [operandlist[1]] + copy(operandlist)\n        \n    end\n    \n    # Check\
    \ if the given operator is in operator\n    if contains(operator, '*') && !contains(operator,\
    \ '/')\n        \n        # Build a list from the operand vector\n        operandlist\
    \ = copy(operand)\n        \n        # Pop two operands from the operand list\n\
    \        operandlist.pop(1)\n        operandlist.pop(1)\n        \n        # Calculate\
    \ expression\n        operandlist[1] = operandlist[1] * operandlist[2]\n     \
    \   \n        # Append the result of list to the operand vector\n        operand\
    \ = [operandlist[1]] + copy(operandlist)\n        \n    end\n    \n    # Check\
    \ if the given operator is in operator\n    if contains(operator, '/')\n     \
    \   \n        # Build a list from the operand vector\n        operandlist = copy(operand)\n\
    \        \n        # Pop one operands from the operand list\n        operandlist.pop(1)\n\
    \        \n        # Calculate expression\n        operandlist[1] = operandlist[1]\
    \ // operandlist[2]\n        \n        # Append the result of list to the operand\
    \ vector\n        operand = [operandlist[1]] + copy(operandlist)\n        \n \
    \   end\n    \n    # Calculate the result of the given algebraic expression\n\
    \    eval(string(join(operand))) \nend\n    \n", "    return do_vector(operator,\
    \ operand)\nend", "    \"\"\"\n    Given two vectors operator, and operand. The\
    \ first vector has basic algebra operations, and \n    the second vector is a\
    \ vector of integers. Use the two given vectors to build the algebric \n    expression\
    \ and return the evaluation of this expression.", "    \n    # get the length\
    \ of operands\n    # and the length of operator\n    length = length(operand)\
    \ - 1 \n    \n    # if the vector is empty return 0\n    if length == 0\n    \
    \    return 0\n    end", "    \n    sum = 0\n    \n    for i = 1:(length(operand)-1)\n\
    \        sum = sum + (parse(Int, operand[i]) \n                    * parse(Int,\
    \ operator[i])) \n    end\n    \n    return sum\nend", "    \n    if operator.length\
    \ < 1 or operand.length < 2\n        return error(\"Invalid length of operand/operator\
    \ vectors\")\n    end", "    operator_length = length(operator)\n    operand_length\
    \ = length(operand)", "  n = length(operand)\n  m = length(operator)\n  if n ==\
    \ 0\n    return 0\n  elseif m == 0\n    return 1\n  end\n  res = do_add(operator,\
    \ operand)\n  if n == 1\n    return res\n  elseif m == 1\n    return res\n  end\n\
    \  res = do_sub(operator, operand)\n  if n == 2\n    return res\n  elseif m ==\
    \ 2\n    return res\n  end\n  res = do_mul(operator, operand)\n  if n <= 4\n \
    \   return res\n  end\n  res = do_mod(operator, operand)\n  if n == 1\n    return\
    \ res\n  elseif m == 1\n    return res\n  end\n  res = do_pow(operator, operand)\n\
    \  return res\nend", "    vector_operation = vector(operator)\n    vector_operand\
    \ = vector(operand)\n    vector_length = length(vector_operation)\n    vector_operand_length\
    \ = length(vector_operand)\n    \n    if vector_length == 0\n        error(\"\
    length of operator vector is zero\")\n    end\n    if vector_operand_length ==\
    \ 0\n        error(\"length of operand vector is zero\")\n    end\n    if length(vector_operation)\
    \ != length(vector_operand)\n        error(\"length of operator vector must equal\
    \ to the length of operand vector minus one\")\n    end\n    \n    for (i in 1:vector_length)\n\
    \        operator[i] = string(vector_operation[i])\n    end\n    for (i in 1:vector_operand_length)\n\
    \        operand[i] = int64(vector_operand[i])\n    end\n    \n    for (i in 1:vector_length)\n\
    \        operator[i] = operator[i] + string(vector_operand[i])\n    end", "  \
    \  length = length(operator) - 1  \n    \n    if length == 0 \n        println(\"\
    No operator is defined. Operand must be a vector of at least two integers.\")\n\
    \        exit(0)\n    end", "    \n    # Base cases\n    if length( operator )\
    \ == 1 && length(operand) == 2\n        return operand[1] + operand[2]\n    end\n\
    \    if length(operator) == 1 && length(operand) == 2\n        return operand[1]\
    \ + operand[2]\n    end\n    if length(operator) == 2 && length(operand) == 2\n\
    \        return operand[1] * operand[2]\n    end", "    algebric_expression =\
    \ @. 0\n    for element in operand\n        algebric_expression = algebric_expression\
    \ + element \n    end\n    for element in operator\n        algebric_expression\
    \ = algebric_expression + element \n    end\n    return algebric_expression\n\
    end\n</cell>\n<code language=julia-1.6>", "    vector = Array{String, 1}(undef,\
    \ length(operator))\n    operator\n    vector\n    length = length(vector)\n \
    \   vector\n    \n    if length < length(operand)\n        push!(vector, \"\"\
    )\n    end", "    \n    op_len, op_head = operator[1], operator[2]\n    \n   \
    \ if op_len == 0 \n        error(\"No operations for operator \", operator)\n\
    \    end", "    index_1 = findfirst(x -> x == operator[1], operator)\n    index_2\
    \ = findfirst(x -> x == operator[2], operator)\n    result = operand[index_1]\
    \ * operand[index_2]\n    for i = index_1+1, index_2 \n        result = result\
    \ + operand[i] * operand[i-1]\n    end\n    result\nend", "    op_len = length(operator)\n\
    \    op_n = 0\n    while op_n < length(operand)\n        op_op = operator[op_n]\n\
    \        op_n = op_n + 1\n        op_val_n = operand[op_n]\n        if op_op ==\
    \ '*'\n            val = op_val_n * op_val_n\n        elseif op_op == '/'\n  \
    \          val = op_val_n / op_val_n\n        elseif op_op == '%'\n          \
    \  val = op_val_n % op_val_n\n        elseif op_op == '**'\n            val =\
    \ op_val_n ** op_val_n\n        elseif op_op == '+'\n            val = op_val_n\
    \ + op_val_n\n        elseif op_op == '-'\n            val = op_val_n - op_val_n\n\
    \        elseif op_op == '*'\n            val = op_val_n * op_val_n\n        elseif\
    \ op_op == '/'\n            val = op_val_n / op_val_n\n        elseif op_op ==\
    \ '%'\n            val = op_val_n % op_val_n\n        elseif op_op == '**'\n \
    \           val = op_val_n ** op_val_n\n        else\n            error(\"invalid\
    \ operator\")\n        end\n    end\n    return val\nend", "    vector1 = Vector{String}(operator)\n\
    \    vector2 = Vector{Int64}(operand)\n    length = length(vector1)\n    result\
    \ = vector1[end-1] * vector2[end-1]\n    for i =1:(length-1)\n        result =\
    \ result + vector1[i] * vector2[i]\n    end\n    result\nend", "    \n    if length(operator)\
    \ != length(operand) \n        throw(\"The length of operator vector is equal\
    \ to the length of operand vector minus one. Operand is a vector of of non-negative\
    \ integers. Operator vector has at least one operator, and operand vector has\
    \ at least two operands.\") \n    end\n    \n    # Build the algebric expression\n\
    \    result = 1\n    for i in 1:length(operator) \n        result = result .+\
    \ opertator[i] * operand[i]\n    end\n    \n    # Return the evaluation\n    return\
    \ result\nend", "    \n    # Return error if the length of operator vector is\
    \ not the same as the length of operand vector\n    # Minus one because vector\
    \ operator is assumed to be a vector with at least one operator\n    length, index\
    \ = length(operator) - 1, length(operand)\n    if length != index\n        throw(ArgumentError(\"\
    Operand must be a vector of non-negative integers. Operator must be a vector of\
    \ length at least one\"))\n    end", "    length = length(operator)\n    operand\
    \ = operand[end]\n    \n    if length(operator) == 0 \n        error(\"Invalid\
    \ operator\")\n    end\n    \n    if length(operand) == 0 \n        error(\"Invalid\
    \ operand\")\n    end\n    \n    if length(operator) > length(operand)\n     \
    \   error(\"Operator is longer than operand\")\n    end\n    \n    result = 1\n\
    \    for i = length(operator):-1:1\n        result = result * operand[i]\n   \
    \ end\n    \n    return result\nend\n</cell>\n<code language=julia-1.0>\ndo_algebra(operator,\
    \ vector)\n</cell>\n<text>\nExercise\nUse the following operator and operand vectors\
    \ to evaluate 1 + 2 + 3. This should give 4.", "    eval = do_algebra(operator,\
    \ operand, Vector{String}([]))\n    return eval\nend", "    \n    length = length(operator)\
    \ - 1 \n    \n    \n    \n    \n    if length < 1 \n        error(\"do_algebra:\
    \ operator has less than 1 operator, length is $length\")\n    end\n    if length(operand)\
    \ < 2 \n        error(\"do_algebra: operand has less than 2 operands, length is\
    \ $length\")\n    end", "    if length(operator) ~= length(operand) \n       \
    \ error(\"Operand and operator must have the same number of elements ($length(operator)\
    \ and $length(operand)) \")\n    end\n    # check if at least one element in operator\
    \ is +\n    if any(x in operator for x in ['+']) \n        # check if at least\
    \ two elements in operand is integer\n        if length(filter(x -> isa(x, Int64),\
    \ operand) ~= length(operand))\n            error(\"Number of elements in operand\
    \ vector must be equal to or larger than operator vector\")\n        else\n  \
    \          vector1 = copy(isequal(operator, ['+']), operand)\n            vector2\
    \ = copy(isequal(operator, ['-']), operand)\n            vector3 = copy(isequal(operator,\
    \ ['*']), operand)\n            vector4 = copy(isequal(operator, ['//']), operand)\n\
    \            vector5 = copy(isequal(operator, ['**']), operand)\n            result\
    \ = (vector1 + vector2 + vector3 - vector4 - vector5)\n            return result\n\
    \        end\n    else\n        # check if there is only one element in operator\n\
    \        if length(filter(x -> x == x , operator)) ~= length(operator)\n     \
    \       error(\"Operator vector must contain at least one element\")\n       \
    \ else\n            vector = copy(operator, operand)\n            vector1 = copy(isequal(operator,\
    \ ['+']), operand)\n            vector2 = copy(isequal(operator, ['-']), operand)\n\
    \            vector3 = copy(isequal(operator, ['*']), operand)\n            vector4\
    \ = copy(isequal(operator, ['//']), operand)\n            vector5 = copy(isequal(operator,\
    \ ['**']), operand)\n            result = (vector + vector1 + vector2 - vector3\
    \ - vector4 - vector5)\n            return result\n        end\n    end\nend",
  "    # Write your code here\n    # Write your code here", "    if length(operator)\
    \ == 0 \n        return error(\"Operator vector is empty.\")\n    elseif length(operand)\
    \ < 2 \n        return error(\"Operand vector must have two or more elements.\"\
    )\n    end", "    \"\"\"\n    Do the algebraic operations. \n    \"\"\"\n    if\
    \ length(operator) == length(operand)\n        \n        for i = 1:length(operator)\n\
    \            if operator[i] == '+' \n                return operand[i] + operand[i+1]\
    \ \n            elseif operator[i] == '-' \n                return operand[i]\
    \ - operand[i+1] \n            elseif operator[i] == '*' \n                return\
    \ operand[i] * operand[i+1] \n            elseif operator[i] == '/' \n       \
    \         return operand[i] / operand[i+1] \n            elseif operator[i] ==\
    \ '**'\n                return operand[i] ** operand[i+1]\n            end\n \
    \       end\n        error(\"Not enough arguments\")\n    else\n        error(\"\
    Operator and operand vectors must have same length\")\n    end\nend", "    return\
    \ Int64((1 .- length(operator) - 1) .* (vector(operand) - vector(operator))) \n\
    end\n</cell>\n<code language=julia-0.6>\n# Test do_algebra\ndo_algebra(['+', '*',\
    \ '-'], [2, 3, 4, 5])\n</cell>\n<code language=julia-0.6>\n\"\"\"\n    eval_bond_vectors(bond_operator::Vector{String},\
    \ bond_operand::Vector{Int64})", "    \n    \n\"\"\"\n    Given one vector operator,\
    \ and operand. The first vector has basic algebra operations, and \n    the second\
    \ vector is a vector of integers. Use the one given vector to build the algebric\
    \ \n    expression and return the evaluation of this expression.", "    \n   \
    \ \n    return do_algebra_vec(operator, operand)\nend", "  \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n", "    # Initialize result\n    result = Int64[]",
  "    \n    i = length(operator) - 1\n    j = length(operand) - 1 \n    result =\
    \ operand[j] * operand[j + 1] \n    for k = length(operator) + 1 : (i - 1)\n \
    \       result = result + operand[k] * operator[k + 1]\n    end\n    \n    return\
    \ result\nend\n</cell>\n<code language=julia-1.0>\n# Test your function\ndo_algebra(operator['+',\
    \ '*', '-'], vector)\n</cell>\n<text>\nExercise", "    \"\"\"\n    Given two vectors\
    \ operator, and operand. The first vector has basic algebra operations, and \n\
    \    the second vector is a vector of integers. Use the two given vectors to build\
    \ the algebric \n    expression and return the evaluation of this expression.",
  "  \n    # initialize first operand vector as empty vector\n    operand = Vector{Int64}()",
  "    \n    if length(operator) == length(operand) - 1 \n        \n        expression\
    \ = operator.join(repeat(\"\"))\n        \n    else\n        \n        expression\
    \ = operator.join(repeat(\" \"), operator, string(operand[1:end-1]), string(operand[end]))",
  "    \"\"\" Given an operator vector and an operand vector, \n    use the two given\
    \ vectors to build the algebric expression and return the evaluation of this \n\
    \    expression.", "    len_operator = length(operator)\n    len_operand = length(operand)\
    \ - 1 \n    if len_operator == len_operand \n        result =  reduce(operator,\
    \ operand)\n        return result \n    else \n        throw(string(\"operator\
    \ vector has \", len_operator, \" elements, while operand vector has \", len_operand,\
    \ \" elements\"))\n    end\nend", "    result = 0\n    lengthOperator = length(operator)\n\
    \    lengthOperand = length(operand)\n    \n    if lengthOperand == lengthOperator\n\
    \        operation = operator[1]\n        operand1 = operand[1..lengthOperand-1]\n\
    \        operand2 = operand[lengthOperand..end]\n        \n        if operation\
    \ == '*'\n            result = operand1 * operand2\n        else \n          \
    \  if operation == '/'\n                result = operand1 // operand2\n      \
    \      else\n                if operation == '**'\n                    result\
    \ = operand1 ** operand2\n                else\n                    println(\"\
    Wrong operator!\")\n                end\n            end\n        end\n    else\
    \ \n        println(\"Wrong operand!\")\n    end\n    \n    return result\nend",
  "    # Get the length of the operand vector\n    num_operand = length(operand)-1\n\
    \    num_operator = length(operator)-1\n    \n    # Get the first element from\
    \ operand vector as the base expression\n    base_expression = operand[1]\n  \
    \  \n    # Build a string to represent the expression built from base_expression\n\
    \    expression = base_expression\n    \n    # Loop through the operator vector\
    \ and add operations to expression\n    for i = 2:(num_operator)\n        expression\
    \ = operator .* expression\n    end\n    \n    return eval(expression)\nend",
  "    n=0\n    for op in operator\n        n += op in operand ? operand[operand.index(op)]\
    \ : 0\n    end\n    return n\nend", "    \n    \"\"\"\n    Perform the algebraic\
    \ expression", "    operator_length = length(operator)\n    operand_length = length(operand)\n\
    \    \n    if operand_length == operator_length-1 && operand_length > 1\n    \
    \    push!(result, '(')\n        for i = 1:operand_length\n            push!(result,\
    \ operand[i])\n            push!(result,operator[i])\n        end\n        push!(result,\
    \ ')')\n        return Int64(result)\n    else\n        push!(result, '(')\n \
    \       for i = 1:operand_length\n            push!(result, operand[i])\n    \
    \        push!(result,operator[i])\n        end\n        push!(result,')')\n \
    \   end\nend\nend", "    \n    # Get the length of operator vector and operand\
    \ vector. \n    operator_size = length(operator)\n    operand1_size = length(operand)",
  "  \n    # Evaluate expression\n    expression = evaluate(operator, operand)\n \
    \   \n    # Return result from expression\n    return expression\nend", "    \n\
    \    # create empty vector with length operand-operator+1\n    result = Vector{Int64}(operand.length-operator.length+1)\n\
    \    \n    # start filling the vector with basic arithmetic operations\n    for\
    \ i in 1:operand.length-1\n        if operator[i] == '+'\n            result[i]\
    \ = operand[i]+operand[i+1]\n        elseif operator[i] == '-'\n            result[i]\
    \ = operand[i]-operand[i+1]\n        elseif operator[i] == '*'\n            result[i]\
    \ = operand[i]*operand[i+1]\n        elseif operator[i] == '//'\n            result[i]\
    \ = operand[i]//operand[i+1]\n        elseif operator[i] == '**'\n           \
    \ result[i] = operand[i]**operand[i+1]\n        end\n    end\n    \n    return\
    \ result[end]\nend\n</cell>\n<text>\nLet's test our do_algebra function on two\
    \ vectors:", "    nOperands = length(operand)\n    nOperators = length(operator)\n\
    \    \n    operand = operand[1:nOperands]\n    operator = operator[1:nOperators]\n\
    \    \n    exp = Vector{Int64}(undef, nOperators)\n    i = 0\n    while i < nOperators\n\
    \        if operator[i] == '+'\n            exp[i] = operand[i] + operand[i+1]\n\
    \            i = i+2\n        elseif operator[i] == '-'\n            exp[i] =\
    \ operand[i] - operand[i+1]\n            i = i+2\n        elseif operator[i] ==\
    \ '*'\n            exp[i] = operand[i] * operand[i+1]\n            i = i+2\n \
    \       elseif operator[i] == '/'\n            exp[i] = operand[i] / operand[i+1]\n\
    \            i = i+2\n        elseif operator[i] == '//'\n            exp[i] =\
    \ operand[i] // operand[i+1]\n            i = i+2\n        elseif operator[i]\
    \ == '**'\n            exp[i] = operand[i] ** operand[i+1]\n            i = i+2\n\
    \        elseif operator[i] == '%'\n            exp[i] = operand[i] % operand[i+1]\n\
    \            i = i+2\n        else\n            println(\"Invalid operator type\"\
    )\n        end\n    end\n    return exp\nend\n</cell>\n<code language=julia-1.0>\n\
    # Test\nprintln(do_algebra([ '+', '*', '-', '^', '//', '%', '**' ], [2, 3, 4,\
    \ 5]))\n</cell>\n<text>\nExercise 9\nImplement the function do_algebra_iterative\
    \ that uses the function do_algebra above. \nDoes the function match the expected\
    \ behaviour for all cases? If yes, compare it to the implementation of do_algebra\
    \ above.", "    \n    len_op = len(operator) - 1\n    len_opr = len(operand) -\
    \ 1", "    stack = Stack()\n    total = 0\n    for i in 1:length(operator)\n \
    \       if stack.isEmpty()\n            push!(stack, operator[i])\n          \
    \  push!(stack, operand[i])\n        else\n            if operator[i] == stack[length(stack)]\n\
    \                push!(stack, operator[i])\n                push!(stack, operand[i])\n\
    \            elseif operator[i] == stack[length(stack)-1]\n                total\
    \ = stack[length(stack)-1] + operand[i]\n                pop!(stack)\n       \
    \     else\n                throw(ArgumentError())\n            end\n        end\n\
    \    end\n    \n    if stack.isEmpty()\n        throw(ArgumentError())\n    end",
  "    result = Int64(0)\n    for op in operator \n        result += evalop(op, operand)\n\
    \    end\n    return result\nend", "    result = Int64[]\n    for op in operator\n\
    \        push!(result, eval(\"op\" .* operand))\n    end\n    return result\n\
    end\n</cell>\n<text>\nPart 4: Test your code", "    \n    result = Int64(0)\n\
    \    for operation in operator\n        result *= Int64(operand[length(operand)-length(operator)+1])\n\
    \        for number in operand[2:end]\n            result *= Int64(number)\n \
    \       end\n    end\n    return result\nend\n</cell>\n<code language=julia-0.6>\n\
    @time println(do_algebra(operator, vector))\n</cell>\n<text>\nExercise\nFind all\
    \ possible combinations of operators and operands with given lengths.", "    length\
    \ = len(operand) - 1 \n    operand_str = join(operand) \n    operator_str = join(operator)\
    \ \n    op_len = length(operator_str) \n    op_strs = split(operator_str, '^')\
    \ \n    # Operator and operand vector must both be non-negative\n    assert op_len\
    \ > 0\n    assert op_len == length(op_strs)\n    # Vector length must be the same\
    \ (same number of elements)\n    assert length == length(operand_str)\n    \n\
    \    if op_strs[2] == '*' \n        mul1 = mul2(operand_str) \n        mul2 =\
    \ mul1(op_strs[1]) \n    else \n        mul1 = mul2(operand_str) \n        mul2\
    \ = mul1(op_strs[1]) \n    end\n    return eval(mul2)\nend\n</code>\n<|/ a tags=julia,math\
    \ |>\n<| c |>\nThanks for this! I used your `mul2` function and built some `is`\
    \ statements based on it for checking for the valid vector input I was able to\
    \ successfully get it to work correctly. I'm going to post my code in the question.\
    \ Thanks for your help!\n<|/ c |>\n<| c |>\nHappy I could help. If you found the\
    \ answer helpful, feel free to upvote and/or accept it. Thanks!\n<|/ c |>\n<|\
    \ c |>\nI accepted your answer and upvoted it. Thanks for the help!\n<|/ c |>\n\
    <| a dscore=1 tags=julia,math |>\nYou can use sympy package. It has a lot of convenient\
    \ functions for algebra operations. \nYou can try the following.\n<code>\njulia>\
    \ using SymPy", "    \"\"\"\n    Given two vectors operator, and operand. The\
    \ first vector has basic algebra operations, and \n    the second vector is a\
    \ vector of integers. Use the two given vectors to build the algebric \n    expression\
    \ and return the evaluation of this expression.", "    # Start of the function\n\
    \    result_vector = Vector{Int64}(undef, length(operator) + 1)\n    # End of\
    \ the function\n    \n    for i = 1:length(operand)\n        \n        if length(operator)\
    \ == 0 \n            # Handle cases where operator is an empty vector and operand\
    \ is a non-empty vector\n            result_vector[i] = operand[i]\n        else\
    \ \n            # Handle other cases, where operator is an empty vector and operand\
    \ is a non-empty vector\n            # First, find the index of the operator in\
    \ the operator vector\n            indexOfOperator = findfirst(x -> x == operator,\
    \ operator)\n            # Second, perform the operation on the operand at the\
    \ index of the operator in the operator vector\n            result_vector[i] =\
    \ operand[indexOfOperator] + operator[indexOfOperator + 1] * operand[i]\n    \
    \    end\n    end\n    \n    return result_vector\nend", "    op = Dict( x ->\
    \ x+1, x -> x*2, x -> x/3, x -> x^5 )\n    vec = Dict( x -> x, x -> x, x -> x,\
    \ x -> x )\n    \n    oplen = length(op)\n    veclen = length(vec)", "    sum\
    \ = 0\n    operators = string.split(operator, '+')\n    operands = string.split(operand,\
    \ '+')\n    for op in operators\n        sum = (sum + getOperatorValue(op))*getOperatorValue(operands.pop())\
    \ \n    end\n    \n    for op in operators\n        sum = (sum + getOperatorValue(op))*getOperatorValue(operands.pop())\
    \ \n    end\n    return sum\nend", "    if !all(length(op) == length(operand)\
    \ - 1 , length(op) == 1 , length(operand) >= 2) \n        raise ArgumentError(\"\
    Operator and operand must be of same length\")\n    end\n    #println(\"Lengths\
    \ of operator and operand: \", length(operator), \" \", length(operand))\n   \
    \ \n    op_num::Int64 = 0\n    op_num += vectorsum(operand)\n    op_num -= vectorsum(vectorproduct(operand,\
    \ operator))\n    op_num *= vectorproduct(operand, vectorproduct(operator, operand))\n\
    \    op_num //= vectorproduct(operand, operator)\n    op_num **= vectorproduct(operand,\
    \ operator)", "    \"\"\"\n    Given two vectors operator, and operand. The first\
    \ vector has basic algebra operations, and \n    the second vector is a vector\
    \ of integers. Use the two given vectors to build the algebric \n    expression\
    \ and return the evaluation of this expression.", "    \n    # Add operator in\
    \ operand\n    new_operand = operand\n    \n    # Repeat until no operators left\
    \ in operator vector\n    for i = length(operator)\n        # Operator vector\
    \ has at least one operator, and operand vector has at least two operands\n  \
    \      if i > 1\n            # Get the number of operators in operand vector\n\
    \            op_count = length(new_operand)", "    operand_length = length(operand)\n\
    \    if operand_length != length(operator)\n        error(\"The length of operand\
    \ vector must be equal to the length of operator vector minus one.\")\n    end\n\
    \    result = Int64[]\n    for operand_index in 1:operand_length\n        operator_index\
    \ = find(operator == operator[1])[1]\n        operand_index = find(operand ==\
    \ operand[operator_index])[1]\n        result[operator_index] += operand[operand_index]\n\
    \    end\n    return result[1]\nend\n</cell>\n<text>\nExercise 2.10\nWrite a function\
    \ called do_algebra_add that has two parameters operator and operand, where operator\
    \ is \na vector of strings, and operand is a vector of integers. The function\
    \ returns the  sum of the \nintegers in the operand vector, given the values of\
    \ the operator vector and the operand.", "    \n    n = size(operand)\n    assert(length(operator)\
    \ == n-2)\n    \n    A = zeros(Int, n-1)\n    \n    for i = 1:n-2\n        assert(operand[i]\
    \ > 0)\n        assert(operator[i] == '+' || operator[i] == '-' || operator[i]\
    \ == '*' || operator[i] == '/' || operator[i] == '^')\n        \n        if(operator[i]\
    \ == '+')\n            A[i] = operand[i] + operand[i+1]\n        elsif(operator[i]\
    \ == '-')\n            A[i] = operand[i] - operand[i+1]\n        elsif(operator[i]\
    \ == '*')\n            A[i] = operand[i] * operand[i+1]\n        elsif(operator[i]\
    \ == '/')\n            A[i] = operand[i] / operand[i+1]\n        elsif(operator[i]\
    \ == '^')\n            A[i] = operand[i] ** operand[i+1]\n        else\n     \
    \       error(\"operator not recognized\")\n        end\n    end\n    \n    return\
    \ A\nend", "    \"\"\"\n    Given two vectors operator, and operand. The first\
    \ vector has basic algebra operations, and \n    the second vector is a vector\
    \ of integers. Use the two given vectors to build the algebric \n    expression\
    \ and return the evaluation of this expression.", "    # Do basic algebra operation\
    \ on operand\n    expression = zeros(length(operator))\n    for i = 1:length(operator)\n\
    \        # Case of addition\n        if operator[i] == '+'\n            expression[i]\
    \ = operand[i] + operand[i + 1]\n        # Case of subtraction\n        else if\
    \ operator[i] == '-'\n            expression[i] = operand[i] - operand[i + 1]\n\
    \        # Case of multiplication\n        else if operator[i] == '*'\n      \
    \      expression[i] = operand[i] * operand[i + 1]\n        # Case of floor division\n\
    \        else if operator[i] == '/'\n            expression[i] = operand[i] //\
    \ operand[i + 1]\n        # Case of exponentiation\n        else if operator[i]\
    \ == '**'\n            expression[i] = operand[i] ** operand[i + 1]\n        end\n\
    \    end\n    return expression\nend", "    result = 0\n    \n    # loop over\
    \ operator vector\n    for op = operator\n        # loop over operand vector\n\
    \        for i in 1:operand.length-1\n            # if the current operator and\
    \ operand match, then perform the operation\n            if op == operator[i]\
    \ && operand[i] == operand[i+1]\n                result += operand[i]\n      \
    \      end\n        end\n    end", "    \n    \"\"\"\n    Given two vectors operator,\
    \ and operand. The first vector has basic algebra operations, and \n    the second\
    \ vector is a vector of integers. Use the two given vectors to build the algebric\
    \ \n    expression and return the evaluation of this expression.", "    operator1\
    \ = operator[1]\n    operator2 = operator[2]\n    operand1 = operand[1]\n    operand2\
    \ = operand[2]\n    \n    if length(operator) == length(operand)\n    \n     \
    \   if operator1 == operator2\n            \n            if operand1 == operand2\n\
    \                \n                return operand1 * operand2\n            else\n\
    \                \n                return 0\n            end\n        end\n  \
    \  end\nend", "    \n    len_operator = length(operator)\n    len_operand = length(operand)\n\
    \    \n    if len_operator == 0\n        error(\"Operator vector must not be empty.\"\
    )\n    end\n    \n    if len_operand != len_operator - 1\n        error(\"Operand\
    \ vector must have one more element than the operator vector.\")\n    end\n  \
    \  \n    if len_operator == 1\n        result =  operand[end]\n    end\n    \n\
    \    for i = 1:len_operand - 1\n        result =  operator[i] * operand[i + 1]\
    \ + result\n    end\n    \n    return result\nend", "    \n    # Check to see\
    \ if operator vector has at least one operator.\n    if isnothing(operator) ||\
    \ isempty(operator)\n        println(\"ERROR: operator vector does not contain\
    \ at least one operator!\")\n        println(\"    Operator vector is: \", operator)\n\
    \        return -1\n    end", "    \"\"\"\n    Given two vectors operator, and\
    \ operand. The first vector has basic algebra operations, and \n    the second\
    \ vector is a vector of integers. Use the two given vectors to build the algebric\
    \ \n    expression and return the evaluation of this expression.", "    \n   \
    \ operation_vector = operand_vector = Vector{String}(:)\n    for op in operator\n\
    \        operation_vector = operation_vector push!(operand, \"(\" , op , \"(\"\
    \ , operand[end] , \")\" , \")\")\n    end\n    \n    operation_vector = Vector{String}(operation_vector)\n\
    \    operation_vector = operation_vector[1:end-1]\n    \n    operation_vector\
    \ = operation_vector[1:end-1]\n    \n    operation_vector = Vector{String}(operation_vector)\n\
    \    \n    operation_vector = Vector{String}(operation_vector)\n    \n    operation_vector\
    \ = Vector{String}(operation_vector)\n    \n    operation_vector = Vector{String}(operation_vector)\n\
    \    \n    operation_vector = Vector{String}(operation_vector)\n    \n    operation_vector\
    \ = Vector{String}(operation_vector)\n    \n    operation_vector = Vector{String}(operation_vector)\n\
    \    \n    operation_vector = Vector{String}(operation_vector)\n    \n    operation_vector\
    \ = Vector{String}(operation_vector)\n    \n    operation_vector = Vector{String}(operation_vector)\n\
    \    \n    operation_vector = Vector{String}(operation_vector)\n    \n    operation_vector\
    \ = Vector{String}(operation_vector)\n    \n    operation_vector = Vector{String}(operation_vector)\n\
    \    \n    operation_vector = Vector{String}(operation_vector)\n    \n    operation_vector\
    \ = Vector{String}(operation_vector)\n    \n    operation_vector = Vector{String}(operation_vector)\n\
    \    \n    operation_vector = Vector{String}(operation_vector)\n    \n    operation_vector\
    \ = Vector{String}(operation_vector)\n    \n    operation_vector = Vector{String}(operation_vector)\n\
    \    \n    operation_vector = Vector{String}(operation_vector)\n    \n    operation_vector\
    \ = Vector{String}(operation_vector)\n    \n    operation_vector = Vector{String}(operation_vector)\n\
    \    \n    operation_vector = Vector{String}(operation_vector)\n    \n    operation_vector\
    \ = Vector{String}(operation_vector)\n    \n    operation_vector = Vector{String}(operation_vector)\n\
    \    \n    operation_vector = Vector{String}(operation_vector)\n    \n    operation_vector\
    \ = Vector{String}(operation_vector)\n    \n    operation_vector = Vector{String}(operation_vector)\n\
    \    \n    operation_vector = Vector{String}(operation_vector)\n    \n    operation_vector\
    \ = Vector{String}(operation_vector)\n    \n    operation_", "    length = length(operator)\n\
    \    \n    # check if length is less than 2\n    if length == 2\n        # check\
    \ if the length of operand is less than 1\n        if length(operand) < 1\n  \
    \          return 0\n        # check if operand vector has all positive values\n\
    \        if all(x -> x > 0, operand)\n            # check if the length of operator\
    \ vector is less than 1\n            if length(operator) < 1\n               \
    \ return 0\n            # check if the length of operator vector is less than\
    \ 2\n            if length(operator) < 2\n                return 0\n         \
    \   # check if the length of operator vector is greater than 3\n            if\
    \ length(operator) > 3\n                return 0\n            # check if the length\
    \ of operator vector is less than 4\n            if length(operator) < 4\n   \
    \             return 0\n            # check if the length of operator vector is\
    \ greater than 5\n            if length(operator) > 5\n                return\
    \ 0\n            # check if the length of operator vector is greater than 6\n\
    \            if length(operator) > 6\n                return 0\n            #\
    \ check if the length of operator vector is greater than 7\n            if length(operator)\
    \ > 7\n                return 0\n            # check if the length of operator\
    \ vector is greater than 8\n            if length(operator) > 8\n            \
    \    return 0\n            # check if the length of operator vector is greater\
    \ than 9\n            if length(operator) > 9\n                return 0\n    \
    \        # check if the length of operator vector is greater than 10\n       \
    \     if length(operator) > 10\n                return 0\n            # check\
    \ if the length of operator vector is greater than 11\n            if length(operator)\
    \ > 11\n                return 0\n            # check if the length of operator\
    \ vector is greater than 12\n            if length(operator) > 12\n          \
    \      return 0\n            # check if the length of operator vector is greater\
    \ than 13\n            if length(operator) > 13\n                return 0\n  \
    \          # check if the length of operator vector is greater than 14\n     \
    \       if length(operator) > 14\n                return 0\n            # check\
    \ if the length of operator vector is greater than 15\n            if length(operator)\
    \ > 15\n                return 0\n            # check if the length of operator\
    \ vector is greater than 16\n            if length(operator) > 16\n          \
    \      return 0\n            # check if the length of operator vector is greater\
    \ than 17\n            if length(operator) > 17\n                return 0\n  \
    \          # check if the length of operator vector is greater than 18\n     \
    \       if length(operator) > 18\n                return 0\n            # check\
    \ if the length of operator vector is greater than 19\n            if length(operator)\
    \ > 19\n                return 0\n            # check if the length of operator\
    \ vector is greater than 20\n            if length(operator) > 20\n          \
    \      return 0\n            # check if the length of operator vector is greater\
    \ than 21\n            if length(operator) > 21\n                return 0\n  \
    \          # check if the length of operator vector is greater than 22\n     \
    \       if length(operator) > 22\n                return 0\n            # check\
    \ if the length of operator vector is greater than 23\n            if length(operator)\
    \ > 23\n                return 0\n            # check if the length of operator\
    \ vector is greater than 24\n            if length(operator) > 24\n          \
    \      return 0\n            # check if the length of operator vector is greater\
    \ than 25\n            if length(operator) > 25\n                return 0\n  \
    \          # check if the length of operator vector is greater than 26\n     \
    \       if ", "    \n    if length(operator) != length(operand)\n        error(\"\
    operator and operand must be of same size\")\n    elseif length(operator) == 0\n\
    \        error(\"operator must contain at least one operator\")\n    elseif length(operand)\
    \ == 0\n        error(\"operand must contain at least one operand\")\n    end",
  "  \n  # Make sure the lengths of operator vector and operand vector is equal\n\
    \  if length(operator) == length(operand) - 1 \n    \n    # Make sure that the\
    \ length of operator vector is non-negative\n    if all(Operator == operator[1:end-1])\
    \ for Operator in operator[1:end-1]\n      \n      # Make sure that the length\
    \ of operand vector is non-negative\n      if all(Operand == operand[1:end-1])\
    \ for Operand in operand[1:end-1]", "        \n    \n    # initialize a variable\
    \ that will hold result\n    result = Int64(0)\n    \n    # iterate through the\
    \ first vector, and append each operation to result\n    for operatorString in\
    \ operator\n        result <- result + parse(Int, operatorString) * operand[1]\n\
    \    end\n    \n    # iterate through the second vector, and append each operand\
    \ to result\n    for operandInt64 in operand[2:end]\n        result <- result\
    \ + operandInt64 * parse(Int, operatorString) * operand[1]\n    end\n    \n  \
    \  # return the result\n    return result\nend\n</cell>\n<code language=julia-1.5>\n\
    do_algebra(operator, vector)\n</cell>\n<text>\n6. Evaluation of a mathematical\
    \ expression\nNow, we are ready to evaluate mathematical expressions. We will\
    \ see how to build mathematical expressions from our vectors, and how to evaluate\
    \ them with the help of the do_algebra function. We will use the same example\
    \ as above.", "    \"\"\" A function do the algebra operations.\n    Given two\
    \ vectors operator, and operand. The first vector has basic algebra operations,\
    \ and \n    the second vector is a vector of integers. Use the two given vectors\
    \ to build the algebric \n    expression and return the evaluation of this expression.",
  "    \"\"\"\n    Given two vectors operator, and operand. The first vector has basic\
    \ algebra operations, and \n    the second vector is a vector of integers. Use\
    \ the two given vectors to build the algebric \n    expression and return the\
    \ evaluation of this expression.", "    # A special case: just do addition \n\
    \    if length(operator) == 1 && length(operand) == 2\n        return operand[1]\n\
    \    # else, do algebra \n    else\n        # Initialization of result \n    \
    \    result = 0 \n        # Loop over all the operator\n        for symbol in\
    \ operator\n            # Compute the symbol's value\n            result = result\
    \ + operand[symbol]\n        end\n        # Return the result\n        return\
    \ result\n    end\nend\n</cell>\n<code language=julia-1.3>\nresult = do_algebra(operator,\
    \ vector)\nprintln(result)\n</cell>\n<text>\nQuestion 9\nWrite a function expression_evaluate(expression::String)\
    \ which takes a string expression as input and returns the result of this expression.\
    \ This is one of the functions which you have already written. \nFor example,\
    \ expression_evaluate(\"2 + 3 * 4 - 5\") should return 9.", "    # Initialize\
    \ an empty vector.\n    expression::Vector{Int64} = Vector{Int64}()\n    \n  \
    \  # Add the operands to expression.\n    for i = 1:length(operand)\n        push!(expression,\
    \ operand[i])\n    end\n    \n    # Add the operators to expression.\n    for\
    \ i = 1:length(operator)\n        push!(expression, operator[i])\n    end", " \
    \   \"\"\"\n    Given two vectors operator, and operand. The first vector has\
    \ basic algebra operations, and \n    the second vector is a vector of integers.\
    \ Use the two given vectors to build the algebric \n    expression and return\
    \ the evaluation of this expression.", "    \n    result = 1\n    for op in operator\n\
    \        if op == null(String)\n            throw(string(\"The operator is null:\
    \ \",op))\n        end\n        if op in \"+-\"\n            result = op\n   \
    \     elseif op in \"*/\"\n            result = result * operand[1]\n        elseif\
    \ op in \"//\"\n            result = result / operand[1]\n        elseif op in\
    \ \"**\"\n            result = result ^ operand[1]\n        else\n           \
    \ throw(string(\"The operator is invalid: \",op))\n        end\n    end\n    return\
    \ result\nend", "    operand_length = len(operand)\n    op_length = len(operator)\n\
    \    \n    if op_length == 0 or operand_length == 0 \n        return -1\n    end\n\
    \    if op_length == 1 \n        if isoperator(operator[1]) \n            # Operator\
    \ is a basic algebra operation like +, -, *, / , ** \n            return eval(operator[1],\
    \ operand)\n        else \n            # Operator is just a number, like 2\n \
    \           return operand[1]\n        end\n    end", "    \n    # convert operand\
    \ vector to vector of real numbers\n    operand = Vector{Real}(undef, length(operand)\
    \ - 1) do i\n        operand[i]\n    end\n    \n    # convert operator vector\
    \ to vector of strings\n    operator = Vector{String}(undef, length(operator)\
    \ - 1) do i\n        operator[i]\n    end\n    \n    # initialize sum variable\n\
    \    sum = 0\n    \n    # loop through the operand\n    for i in 1 : length(operand)\n\
    \        \n        # loop through the operator\n        for j in 1 : length(operator)\n\
    \            \n            # check if the operator is a basic algebra operation\n\
    \            if operator[j] \u2209 [\"+\", \"-\", \"*\", \"//\", \"**\"]\n   \
    \             continue\n            end\n            \n            # check if\
    \ the operand is a vector\n            if isa(operand[i], Vector{Int64})\n   \
    \             \n                # add the corresponding element of the operand\
    \ vector to the sum variable\n                sum = sum + operand[i][j]\n    \
    \        else\n                # add the operand to the sum variable\n       \
    \         sum = sum + operand[i]\n            end\n        end\n    end\n    \n\
    \    # return the sum\n    sum\nend\n</cell>\n<code language=julia-1.6>\n# test\
    \ the do_algebra function\ndo_algebra(operator['+', '*', '-'], vector)\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes a vector of strings as the operator\
    \ and an operand vector, and returns the result of the algebraic operation on\
    \ the two vectors.", "    # Initialization\n    res = 0\n    for op in operator\n\
    \        if op == \"*\"\n            res = res * operand[length(operand)-1]\n\
    \        elseif op == \"+\"\n            res = res + operand[length(operand)-1]\n\
    \        elseif op == \"/\"\n            res = res / operand[length(operand)-1]\n\
    \        elseif op == \"//\"\n            res = res // operand[length(operand)-1]\n\
    \        elseif op == \"**\"\n            res = res ** operand[length(operand)-1]\n\
    \        elseif op == \"-\"\n            res = res - operand[length(operand)-1]\n\
    \        end\n    end\n    return res\nend\n</cell>\n<text>\nLet's check if this\
    \ works. Let's create the vector operator:", "    \n    expr = string(operator)\n\
    \    lenOperator(length(operator))\n    lenOperand(length(operand))", "    result\
    \ = operand[1]\n    for i in 2:length(operand)\n        result = result .* operator[i]\
    \ .* operand[i-1]\n    end\n    return result\nend\n</cell>\n<code language=julia-1.5>\n\
    # Test the function do_algebra\ndo_algebra(['+', '*', '-'], [2, 3, 4, 5]) == 9\n\
    </cell>\n<code language=julia-1.5>\n# Test the function do_algebra\ndo_algebra(['+',\
    \ '*', '-'], [9, 2, 5, 3]) == 27\n</cell>\n<code language=julia-1.5>\n# Test the\
    \ function do_algebra\ndo_algebra(['+', '*', '-'], [9, 2, 5, 3]) == 27\n</cell>\n\
    <text>\nPart 4: Evaluate a Polynomial Expression", "    \n    result = Int64(1)\n\
    \    length = length(operand)-1\n    \n    for i in 1:length\n        \n     \
    \   #println(operator[i], operand[i])\n        \n        if operator[i] == '+'\n\
    \            result += operand[i]\n        else if operator[i] == '*'\n      \
    \      result *= operand[i]\n        else if operator[i] == '-'\n            result\
    \ -= operand[i]\n        else if operator[i] == '/'\n            result /= operand[i]\n\
    \        else if operator[i] == '**'\n            result **= operand[i]\n    \
    \    end", '    """Do algebra with given operator and operand.', "    \n    #\
    \ check input\n    assert(length(operator) == length(operand) - 1) \n    assert(all(elem\
    \ <= '^' for elem in operator)) \n    assert(all(elem <= '&' for elem in operator))\
    \ \n    assert(all(elem <= '-' for elem in operator)) \n    assert(all(elem <=\
    \ '+' for elem in operator)) \n    assert(all(elem <= '*' for elem in operator))\
    \ \n    assert(all(elem <= '<' for elem in operator)) \n    assert(all(elem <=\
    \ '>' for elem in operator)) \n    assert(all(elem <= '#' for elem in operator))\
    \ \n    assert(length(vector) == length(operand) - 1) ", "    length = length(operator)-1\n\
    \    result_vector = fill(operand[1], length)\n    for i in 1:length\n       \
    \ element1 = eval(operator[i])\n        element2 = operand[i+1]\n        result_vector[i]\
    \ = eval(element1 .+ element2)\n    end\n    return result_vector[1]\nend", " \
    \   operators = Vector{String}(undef, length(operator) - 1)\n    for i = 1:length(operator)\n\
    \        operators[i + 1] = ops[operator[i]]\n    end\n    result = 0\n    for\
    \ i = 1:length(operand)\n        result += operators[operand[i]](operand[i])\n\
    \    end\n    return result\nend", "    \n    operand_len = length(operand) -\
    \ 1\n    \n    \n    # Check the length of the operator vector\n    if length(operator)\
    \ < 1\n        error(\"The operator vector has less than one operator\")\n   \
    \ end\n    # Check the length of the operand vector\n    if length(operand) <\
    \ 2\n        error(\"The operand vector has less than two operands\")\n    end\n\
    \    # Check the length of the operator\n    if length(operator) != length(operand)\n\
    \        error(\"The operator vector and the operand vector must have the same\
    \ length\")\n    end\n    \n    # Check the length of the operator vector\n  \
    \  if length(operator) < 1\n        error(\"The operator vector has less than\
    \ one operator\")\n    end\n    # Check the length of the operand vector\n   \
    \ if length(operand) < 2\n        error(\"The operand vector has less than two\
    \ operands\")\n    end\n    # Check the length of the operator\n    if length(operator)\
    \ != length(operand)\n        error(\"The operator vector and the operand vector\
    \ must have the same length\")\n    end\n    \n    if length(operator) == 1\n\
    \        # Check if the first operator is +\n        if operator[1] == '+'\n \
    \           return operand[1] + operand[operand_len + 1]\n        end\n      \
    \  # Check if the first operator is -\n        if operator[1] == '-'\n       \
    \     return operand[1] - operand[operand_len + 1]\n        end\n        # Check\
    \ if the first operator is *\n        if operator[1] == '*'\n            return\
    \ operand[1] * operand[operand_len + 1]\n        end\n        # Check if the first\
    \ operator is /\n        if operator[1] == '/'\n            return operand[1]\
    \ / operand[operand_len + 1]\n        end\n        # Check if the first operator\
    \ is **\n        if operator[1] == '**'\n            return operand[1] ** operand[operand_len\
    \ + 1]\n        end\n    end\n    \n    # Check if the first operator is +\n \
    \   if operator[1] == '+'\n        # Check if there is one operand in the operator\
    \ vector\n        if operand_len == 1\n            # Check if the first operand\
    \ is equal to the second operand\n            if operand[1]  == operand[2]\n \
    \               return operand[1]\n            end\n        end\n    end\n   \
    \ # Check if the first operator is -\n    if operator[1] == '-'\n        # Check\
    \ if there is one operand in the operator vector\n        if operand_len == 1\n\
    \            # Check if the first operand is equal to the second operand\n   \
    \         if operand[1]  == operand[2]\n                return -operand[1]\n \
    \           end\n        end\n    end\n    # Check if the first operator is *\n\
    \    if operator[1] == '*'\n        # Check if there is one operand in the operator\
    \ vector\n        if operand_len == 1\n            # Check if the first operand\
    \ is equal to the second operand\n            if operand[1]  == operand[2]\n \
    \               return operand[1] * operand[2]\n            end\n        end\n\
    \    end\n    # Check if the first operator is /\n    if operator[1] == '/'\n\
    \        # Check if there is one operand in the operator vector\n        if operand_len\
    \ == 1\n            # Check if ", "    \"\"\"\n    Given two vectors operator,\
    \ and operand. The first vector has basic algebra operations, and \n    the second\
    \ vector is a vector of integers. Use the two given vectors to build the algebric\
    \ \n    expression and return the evaluation of this expression.", "    op_length\
    \ = length(operator)\n    arg_length = length(operand)\n    \n    if op_length\
    \ == 0 || arg_length < 2\n        throw(ArgumentError)\n    end", "    if length(operator)\
    \ != length(operand) \n        throw(ArgumentError(\"Operand vector has length\
    \ different than operator vector\"))\n    end\n    \n    exp = zeros(Int64, length(operator))\n\
    \    \n    for i in 1:length(operator)\n        exp[i] = eval(parse(parse(string(\"\
    $operator[$i]($operand[\" .. i - 1 .. \"])\")))) * operand[i]\n    end\n    \n\
    \    sum(exp)\nend\n</cell>\n<text>\nNow let's use our algorithm to evaluate the\
    \ expression:", "    operand_length = len(operand)\n    operator_length = len(operator)\n\
    \    if operator_length > operand_length \n        throw(ArgumentError(\"Operator\
    \ vector length is larger than operand vector length.\"))\n    elseif operator_length\
    \ == 1\n        throw(ArgumentError(\"Operator vector has one operator which is\
    \ invalid.\"))\n    elseif operand_length == 0\n        throw(ArgumentError(\"\
    Operand vector has zero elements.\"))\n    else\n        eval_result = eval(operator[1],\
    \ operand[1])\n        return eval_result\n    end\nend", "    \"\"\"\n    Given\
    \ a vector operator and a vector of integers, return the evaluation of the expression\
    \ \n    in string format.", "    \n    # Add two vectors operator, operand and\
    \ return the result of the algebraic expression\n    \n    operation_symbol::Symbol\
    \ = operator[1]\n    operation_number::Int64 = Int(operator[2])\n    \n    # Build\
    \ the algebraic expression\n    algebric_expr::Symbol\n    if length(operator)\
    \ == 1 \n        algebric_expr = operation_symbol\n    elseif operation_symbol\
    \ == '+' \n        algebric_expr = operation_symbol + operation_number\n    elseif\
    \ operation_symbol == '-' \n        algebric_expr = operation_symbol - operation_number\n\
    \    elseif operation_symbol == '*' \n        algebric_expr = operation_symbol\
    \ * operation_number\n    elseif operation_symbol == '/' \n        algebric_expr\
    \ = operation_symbol / operation_number\n    elseif operation_symbol == '//' \n\
    \        algebric_expr = operation_symbol / (operation_number::Int64)\n    elseif\
    \ operation_symbol == '**' \n        algebric_expr = operation_symbol ** operation_number\n\
    \    end", "    \n    # Define the operator\n    operand_copy = copy(operand)\n\
    \    operators_copy = copy(operator)\n    operator = operators_copy[end]\n   \
    \ operand = operand_copy[end]\n    \n    # Initialize result \n    result = 1\n\
    \    \n    # Loop to evaluate the expression\n    for i = 2:length(operators_copy)\n\
    \        \n        # If the operator is '+' or '-' \n        if operators_copy[i]\
    \ ~= '+'\n            \n            # Add current operand to the result\n    \
    \        result = result + operand\n            \n        # If the operator is\
    \ '-' \n        else\n            \n            # Substract the current operand\
    \ from the result\n            result = result - operand\n        \n    end\n\
    \    \n    # Return the result \n    return result\nend\n</cell>\n<text>\nExercise\n\
    Implement the do_algebra function using the function definition above.", "   \
    \ \n    \"\"\"\n    Given two vectors operator, and operand. The first vector\
    \ has basic algebra operations, and \n    the second vector is a vector of integers.\
    \ Use the two given vectors to build the algebric \n    expression and return\
    \ the evaluation of this expression.", "    # TODO\nend", "    \n    length =\
    \ length(operator)\n    \n    if length < length(operand)\n        return error(\"\
    operator vector has less than one operator\")\n    end", "    \n    # Get the\
    \ length of operator vector and operand vector. \n    operatorLength = length(operator)\n\
    \    operandLength = length(operand)\n    \n    # If the length of the operator\
    \ vector is less than or equal to the length of the operand vector, \n    # then\
    \ the operator vector is a vector of basic algebra operations. \n    # If the\
    \ length of the operator vector is greater than or equal to the length of the\
    \ operand vector, \n    # then the operator vector is a vector of integers. \n\
    \    if (operatorLength <= operandLength) \n        # Use vectors to store the\
    \ algebraic expression and the evaluation. \n        algebraExpression = zeros(Int,\
    \ operandLength)\n        evaluationValue = zeros(Int, operandLength)\n      \
    \  \n        # Loop through the vectors operand and operator and evaluate the\
    \ algebraic expression \n        # and store the value in a new vector called\
    \ the evaluationValue. \n        for i = 1:operandLength \n            # Get the\
    \ position of the operator vector in the algebraic expression vector. \n     \
    \       operatorIndex = find(operator == operatorSymbols[i])\n            \n \
    \           # If the operator vector is a vector of basic algebraic operations,\
    \ \n            # then add or subtract the operand. \n            if (operatorIndex\
    \ > -1) \n                algebraExpression[i] = operand[operatorIndex] + algebraExpression[i]\
    \ \n            else\n                # If the operator vector is a vector of\
    \ integers, \n                # then multiply or floor divide the operand. \n\
    \                if (operatorSymbols[i] == \"/\")\n                    algebraExpression[i]\
    \ = operand[operatorIndex] / algebraExpression[i] \n                else\n   \
    \                 algebraExpression[i] = operand[operatorIndex] * algebraExpression[i]\
    \ \n                end\n            end\n        end\n        \n        # Find\
    \ the index of the maximum of the algebraic expression. \n        maxIndex = argmax(algebraExpression)\n\
    \        \n        # Return the value of the algebraic expression at the maximum\
    \ index. \n        return evaluationValue[maxIndex]\n    else\n        # If the\
    \ length of the operator vector is less than or equal to the length of the operand\
    \ vector, \n        # then the operator vector is a vector of basic algebra operations.\
    \ \n        # If the length of the operator vector is greater than or equal to\
    \ the length of the operand vector, \n        # then the operator vector is a\
    \ vector of integers. \n        if (operatorLength > operandLength) \n       \
    \     # Use vectors to store the algebraic expression and the evaluation. \n \
    \           algebraExpression = zeros(Int, operandLength)\n            evaluationValue\
    \ = zeros(Int, operandLength)\n            \n            # Loop through the vectors\
    \ operand and operator and evaluate the algebraic expression \n            # and\
    \ store the value in a new vector called the evaluationValue. \n            for\
    \ i = 1:operandLength \n                # Get the position of the operator vector\
    \ in the algebraic expression vector. \n                operatorIndex = find(operator\
    \ == operatorSymbols[i])\n                \n                # If the operator\
    \ vector is a vector of basic algebraic operations, \n                # then add\
    \ or subtract the operand. \n                if (operatorIndex > -1) \n      \
    \              algebraExpression[i] = algebraExpression[i]", "    \"\"\"\n   \
    \ Given two vectors operator, and operand. The first vector has basic algebra\
    \ operations, and \n    the second vector is a vector of integers. Use the two\
    \ given vectors to build the algebric \n    expression and return the evaluation\
    \ of this expression.", "    non_zero_ops = findnz(operator)\n    non_zero_ops\
    \ = sort(non_zero_ops, by=!iszero)\n    non_zero_ops = filter(non_zero_ops, x\
    \ -> x > 0)", "    # If the length of operator vector is equal to the length of\
    \ operand vector minus one.\n    if length(operator) == length(operand) - 1 then\n\
    \        \n        # Iterate through the operand vector, \n        # and perform\
    \ the basic algebra operation for each value.\n        for n in 1:length(operand)",
  "    #TODO: \nend", "    if length(operator) == 1 \n        do_algebra(operator[1],\
    \ operand)\n    elseif length(operator) == 2 \n        do_algebra(operator[1],\
    \ operand) + do_algebra(operator[2], operand)\n    elseif length(operator) ==\
    \ 3 \n        do_algebra(operator[1], operand) + do_algebra(operator[2], operand)\
    \ - do_algebra(operator[3], operand)\n    elseif length(operator) == 4 \n    \
    \    do_algebra(operator[1], operand) + do_algebra(operator[2], operand) - do_algebra(operator[3],\
    \ operand)\n                                            + do_algebra(operator[4],\
    \ operand)\n    elseif length(operator) == 5 \n        do_algebra(operator[1],\
    \ operand) + do_algebra(operator[2], operand) - do_algebra(operator[3], operand)\n\
    \                                            + do_algebra(operator[4], operand)\
    \ - do_algebra(operator[5], operand)\n    elseif length(operator) == 6 \n    \
    \    do_algebra(operator[1], operand) + do_algebra(operator[2], operand) - do_algebra(operator[3],\
    \ operand)\n                                            + do_algebra(operator[4],\
    \ operand) - do_algebra(operator[5], operand)\n                              \
    \              + do_algebra(operator[6], operand)\n    elseif length(operator)\
    \ == 7 \n        do_algebra(operator[1], operand) + do_algebra(operator[2], operand)\
    \ - do_algebra(operator[3], operand)\n                                       \
    \     + do_algebra(operator[4], operand) - do_algebra(operator[5], operand)\n\
    \                                            + do_algebra(operator[6], operand)\
    \ - do_algebra(operator[7], operand)\n    elseif length(operator) == 8 \n    \
    \    do_algebra(operator[1], operand) + do_algebra(operator[2], operand) - do_algebra(operator[3],\
    \ operand)\n                                            + do_algebra(operator[4],\
    \ operand) - do_algebra(operator[5], operand)\n                              \
    \              + do_algebra(operator[6], operand) - do_algebra(operator[7], operand)\n\
    \                                            + do_algebra(operator[8], operand)\n\
    \    elseif length(operator) == 9 \n        do_algebra(operator[1], operand) +\
    \ do_algebra(operator[2], operand) - do_algebra(operator[3], operand)\n      \
    \                                      + do_algebra(operator[4], operand) - do_algebra(operator[5],\
    \ operand)\n                                            + do_algebra(operator[6],\
    \ operand) - do_algebra(operator[7], operand)\n                              \
    \              + do_algebra(operator[8], operand) - do_algebra(operator[9], operand)\n\
    \    elseif length(operator) == 10 \n        do_algebra(operator[1], operand)\
    \ + do_algebra(operator[2], operand) - do_algebra(operator[3], operand)\n    \
    \                                        + do_algebra(operator[4], operand) -\
    \ do_algebra(operator[5], operand)\n                                         \
    \   + do_algebra(operator[6], operand) - do_", "    operator = operator[1:length(operator)]\n\
    \    operand = operand[1:length(operand)]\n    result = zeros(length(operator))\n\
    \    for i = 1:length(operator)\n        operator[i] = replace(operator[i], \"\
    -\", \"+\")\n        operator[i] = replace(operator[i], \"+\", \"*\")\n      \
    \  operator[i] = replace(operator[i], \"*\", \"/\") \n        operator[i] = replace(operator[i],\
    \ \"//\", \"**\")\n        result[i] = eval(Symbol(operator[i]))*operand[i]\n\
    \    end\n    return result\nend\n</cell>\n<text>\nLet's try it on a few example\
    \ and see if it works.", "    \"\"\"\n    Given two vectors operator, and operand.\
    \ The first vector has basic algebra operations, and \n    the second vector is\
    \ a vector of integers. Use the two given vectors to build the algebric \n   \
    \ expression and return the evaluation of this expression.", "    \"\"\" \n  \
    \  Given two vectors operator, and operand. The first vector has basic algebra\
    \ operations, and \n    the second vector is a vector of integers. Use the two\
    \ given vectors to build the algebric \n    expression and return the evaluation\
    \ of this expression.", "    \n    size = length(operand)\n    \n    if size ==\
    \ 0\n        return NaN\n    end", "    \n    # Vectorize and evaluate algebraic\
    \ expression.\n    algebric_expression = Vectorize(operator)(operand)", "    alg_exp\
    \ = parse(operator, operand)\n    result = eval_fn(alg_exp)\n    return result\n\
    end", "    sum_result = 0\n    for i = 1:length(operator)\n        sum_result\
    \ = sum_result + (eval(string(operator[i])) * eval(string(operand[i]))) \n   \
    \ end\n    return sum_result\nend\n\"\"\"\n    Given a vector of strings representing\
    \ a basic algebra operator, and a vector of integers \n    representing the corresponding\
    \ operand. Using that vector of strings, call the do_algebra \n    function, and\
    \ return the evaluation of this expression.\n\"\"\"", "    local count = 0\n \
    \   for operator1 in operator\n        count = count + length(operator1)\n   \
    \ end", "    \"\"\"\n    Given a operator and a operand, evaluate the algebric\
    \ expression of two vectors \n    operator, and operand. Use the two given vectors\
    \ to build the algebric expression and \n    return the evaluation of this expression.",
  "    length = length(operator)\n    if length == length(operand)\n        vector\
    \ = operand # this vector is the second operand\n        for i = 1:length(operator)-1\n\
    \            vector = operator[i](vector, operand[i])\n        end\n        return\
    \ vector[1]\n    else\n        throw(DimensionMismatch(\"Invalid operator/operand\
    \ length\", length(operator), length(operand)))\n    end\nend", "    # Get the\
    \ number of operators and operands. \n    n = length(operator)\n    m = length(operand)\n\
    \    # If the number of operators is zero or one, return 0.\n    if n == 0\n \
    \       return 0\n    else if m == 1\n        return operand[1]\n    elseif n\
    \ < m\n        # If there are fewer operators, return -1. \n        return -1\n\
    \    elseif n == m\n        # If there are the same number of operators and operands,\
    \ return the first operand. \n        return operand[1]\n    end", "    index_of_operator\
    \ = findfirst(op => op == operator)\n    index_of_operand = findfirst(op => op\
    \ == operand)\n    if index_of_operator == -1 && index_of_operand == -1\n    \
    \    error(\"Could not find an operator in vector: \\(operator)\")\n    elseif\
    \ index_of_operator == -1 \n        error(\"Could not find an operand in vector:\
    \ \\(operand)\")\n    elseif index_of_operand == -1\n        error(\"Could not\
    \ find an operator in vector: \\(operator)\")\n    else\n        vector = Vector(operator[1:end-1],\
    \ operand[1:end-2])\n        operation = operator[index_of_operator]\n       \
    \ operand = operand[index_of_operand]\n        eval(operation, vector, operand)\n\
    \    end\nend\n</cell>\n<code language=julia-1.6>\n@test do_algebra([\"+\", \"\
    *\", \"-\", \"//\", \"**\"], [\"1\", \"2\", \"3\", \"4\", \"5\"]) == 9\n</cell>\n\
    <text>\nExercises\nExercise 1\nIn the following exercise we redo the previous\
    \ exercise of finding the index of a specific element in a vector.", "    if length(operator)\
    \ == 0 \n        throw(ArgumentError(\"Invalid operator vector\"))\n    end",
  "    result = 0.\n    for i in 1:length(operator)\n        if operator[i] != \"\"\
    \n            result += (operand[i-1] * operand[i])\n        end\n    end\n  \
    \  return result\nend\n</cell>\n<code language=julia-0.6>\ndo_algebra([\"+\",\
    \ \"*\"], vec(2))\n</cell>\n<code language=julia-0.6>\ndo_algebra([\"+\", \"-\"\
    , \"*\"], vec(2))\n</cell>\n<code language=julia-0.6>\ndo_algebra([\"*\", \"+\"\
    , \"*\"], vec(2))\n</cell>\n<code language=julia-0.6>\ndo_algebra([\"/\", \"*\"\
    , \"*\"], vec(2))\n</cell>\n<code language=julia-0.6>\ndo_algebra([\"+\", \"+\"\
    ], vec(2))\n</cell>\n<code language=julia-0.6>\ndo_algebra([\"+\", \"+\", \"+\"\
    ], vec(2))\n</cell>\n<code language=julia-0.6>\ndo_algebra([\"+\", \"+\", \"+\"\
    , \"+\"], vec(2))\n</cell>\n<code language=julia-0.6>\ndo_algebra([\"+\", \"+\"\
    , \"+\", \"+\", \"+\"], vec(2))\n</cell>\n<code language=julia-0.6>\ndo_algebra([\"\
    +\", \"+\", \"+\", \"+\", \"+\", \"+\"], vec(2))\n</cell>\n<code language=julia-0.6>\n\
    do_algebra([\"+\", \"+\", \"+\", \"+\", \"+\", \"+\", \"+\"], vec(2))\n</cell>\n\
    <code language=julia-0.6>\ndo_algebra([\"+\", \"+\", \"+\", \"+\", \"+\", \"+\"\
    , \"+\", \"+\"], vec(2))\n</cell>\n<code language=julia-0.6>\ndo_algebra([\"+\"\
    , \"+\", \"+\", \"+\", \"+\", \"+\", \"+\", \"+\"], vec(2))\n</cell>\n<code language=julia-0.6>\n\
    do_algebra([\"+\", \"+\", \"+\", \"+\", \"+\", \"+\", \"+\", \"+\"], vec(2))\n\
    </cell>\n<code language=julia-0.6>\ndo_algebra([\"+\", \"+\", \"+\", \"+\", \"\
    +\", \"+\", \"+\", \"+\", \"+\"], vec(2))\n</cell>\n<code language=julia-0.6>\n\
    do_algebra([\"+\", \"+\", \"+\", \"+\", \"+\", \"+\", \"+\", \"+\", \"+\"], vec(2))\n\
    </cell>\n<code language=julia-0.6>\ndo_algebra([\"+\", \"+\", \"+\", \"+\", \"\
    +\", \"+\", \"+\", \"+\", \"+\"], vec(2))\n</cell>\n<code language=julia-0.6>\n\
    do_algebra([\"+\", \"+\", \"+\", \"+\", \"+\", \"+\", \"+\", \"+\", \"+\", \"",
  "    #Check length of the operator vector\n    length = length(operator)\n    if\
    \ length != length(operand)-1\n        throw(DimensionMismatch(\"Invalid length\
    \ of operator and operand, please make sure that the length of operator vector\
    \ is the same as the length of operand vector minus one\"))\n    end", "    \n\
    \    # Initialization\n    \n    # Check\n    if length(operator) != length(operand)\n\
    \        throw(ArgumentError(\"operator, operand vectors must have the same length\"\
    ))\n    end", "    # initialize variable and result variables\n    result = zeros(size(operand)[1],\
    \ 1)\n    operand_size = size(operand)[1]\n    operator_size = length(operator)\n\
    \    \n    # check if operator and operand have same size\n    if operand_size\
    \ != operator_size\n        error(\"Inconsistent size of operands and operators\"\
    )\n    end", "    \"\"\"Perform the evaluation of the algebraic expression.\"\"\
    \"\n    \n    length = length(operator) - 1 \n    if length == 0 \n        result\
    \ = operand \n    else \n        result = eval(__do__(operator, operand))\n  \
    \  end \n    return result \nend ", "    algebric_expression = zeros(Int, length(operator))\n\
    \    i = 0\n    while(i < length(operator))\n        algebric_expression[i] =\
    \ eval(string(operator[i]) ' ' string(operand[i]))\n        i = i + 1\n    end\n\
    \    return algebric_expression[1]\nend", "    \n    noperator = length(operator)\n\
    \    noperand = length(operand)", "    return dot(operand, eval(operator))\nend",
  "    # Check that operator vector is non-empty\n    assert(length(operator) != 0)\n\
    \    # Check that operand vector is non-empty\n    assert(length(operand) >= 2)\n\
    \    # Check that operator vector has at least one operator\n    assert(length(operator)\
    \ >= 1)\n    # Check that operand vector has at least two operands\n    assert(length(operand)\
    \ == length(operator) - 1)\n    # Check that operand vector is non-negative\n\
    \    for el in operand\n        assert(el >= 0)\n    end\n    # Check that there\
    \ is one operand for the first operator\n    if length(operator) == 1\n      \
    \  assert(length(operand) == 1)\n    else\n        assert(length(operand) == 2)\n\
    \    end\n    # Check that first operator operator has a valid symbol\n    valid_symbols\
    \ = [\"+\", \"-\", \"*\", \"//\", \"**\"]\n    assert(contains(valid_symbols,\
    \ operator[1]))\n    # Check that second operator operator has a valid symbol\n\
    \    assert(contains(valid_symbols, operator[2]))\n    # Check that first operand\
    \ is non-negative\n    assert(length(operand) == 1)\n    # Check that second operand\
    \ is non-negative\n    assert(length(operand) == 2)\n    # Check that first operator\
    \ symbol has valid value\n    valid_values = [\"-\", \"+\", \"*\", \"//\", \"\
    **\"]\n    assert(contains(valid_values, operator[1]))\n    # Check that second\
    \ operator symbol has valid value\n    assert(contains(valid_values, operator[2]))\n\
    \    # Check that first operand is greater than 0\n    assert(operand[1] >= 0)\n\
    \    # Check that second operand is greater than 0\n    assert(operand[2] >= 0)\n\
    \    # Return an evaluated expression\n    return eval(string(operator[1]) + string(operator[2])\
    \ + string(operand[1]) + string(operand[2]))\nend", "    res = 0 \n    for operator\
    \ in operator \n        res = res + operand[operand.indexof(operator)]\n    end\n\
    \    return res \nend", "    if length(operator)==1 || length(operand)==0\n  \
    \      # do nothing\n    elseif length(operator)==1 && length(operand)==1\n  \
    \      operand = operand[1]\n    elseif length(operator)==2 && length(operand)==2\n\
    \        operand = operand[1] * operand[2]\n    elseif length(operator)==2 &&\
    \ length(operand)==1\n        operand = operand[1]\n    end\n    # get the first\
    \ operator and get the corresponding operand\n    operator = operator[1]\n   \
    \ operand = operand[1]\n    \n    # do calculations\n    if operator == '+' ||\
    \ operator == '-'\n        \n        if isa(operand, Int64)\n            result\
    \ = operand + operand\n        elseif isa(operand, Int)\n            result =\
    \ operand + operand\n        end\n        \n    elseif operator == '*'\n     \
    \   \n        if isa(operand, Int64)\n            result = operand * operand\n\
    \        elseif isa(operand, Int)\n            result = operand * operand\n  \
    \      end\n        \n    elseif operator == '/'\n        \n        if isa(operand,\
    \ Int64)\n            result = operand // operand\n        elseif isa(operand,\
    \ Int)\n            result = operand // operand\n        end\n        \n    elseif\
    \ operator == '%'\n        \n        if isa(operand, Int64)\n            result\
    \ = operand % operand\n        elseif isa(operand, Int)\n            result =\
    \ operand % operand\n        end\n        \n    elseif operator == '^'\n     \
    \   \n        if isa(operand, Int64)\n            result = operand ^ operand\n\
    \        elseif isa(operand, Int)\n            result = operand ^ operand\n  \
    \      end\n        \n    elseif operator == '&'\n        \n        if isa(operand,\
    \ Int64)\n            result = operand & operand\n        elseif isa(operand,\
    \ Int)\n            result = operand & operand\n        end\n        \n    elseif\
    \ operator == '|'\n        \n        if isa(operand, Int64)\n            result\
    \ = operand | operand\n        elseif isa(operand, Int)\n            result =\
    \ operand | operand\n        end\n        \n    elseif operator == '=='\n    \
    \    \n        if isa(operand, Int64)\n            result = operand == operand\n\
    \        elseif isa(operand, Int)\n            result = operand == operand\n \
    \       end\n        \n    elseif operator == '!'\n        \n        if isa(operand,\
    \ Int64)\n            result = operand != operand\n        elseif isa(operand,\
    \ Int)\n            result = operand != operand\n        end\n        \n    elseif\
    \ operator == '='\n        \n        if isa(operand, Int64)\n            result\
    \ = operand == operand\n        elseif isa(operand, Int)\n            result =\
    \ operand == operand\n        end\n        \n    elseif operator == '<'\n    \
    \    \n        if is", "    if length(operator) == length(operand)\n        return\
    \ sum(operand)\n    else\n        error(\"Operand length must be equal to operator\
    \ length\")\n    end\nend", "    #@assert length(operator) == length(operand)\
    \ - 1\n    \n    result =0\n    for i=1:length(operator)\n        operator = operators[i]\n\
    \        operand = operands[i]\n        switch operator\n            case '+'\
    \ => result = result + operand\n            case '-' => result = result - operand\n\
    \            case '*' => result = result * operand\n            case '/' => result\
    \ = result // operand\n            case '**' => result = result ** operand\n \
    \           end \n    end\n    return result\nend", "    \"\"\"\n    Given two\
    \ vectors operator, and operand. The first vector has basic algebra operations,\
    \ and \n    the second vector is a vector of integers. Use the two given vectors\
    \ to build the algebric \n    expression and return the evaluation of this expression.",
  "  \n    if length(operator) == 1 \n        return operand[end]\n    elseif length(operator)\
    \ == length(operand) - 1 \n        \n        # Build the algebra expression\n\
    \        # To add two vectors we use the + operator\n        # To subtract two\
    \ vectors we use the - operator\n        # To multiply two vectors we use the\
    \ * operator\n        # To divide two vectors we use the / operator\n        #\
    \ To divide a vector by a scalar we use the // operator\n        # To raise a\
    \ number to a power, we use the ^ operator\n        # To evaluate an expression\
    \ with some values we use the $() operator\n        \n        if isa(operator[1],\
    \ Symbol) && isa(operand[1], Symbol) \n            \n            # To add vectors\
    \ we use the + operator\n            if isa(operator, Symbol) && isa(operand,\
    \ Vector{Symbol}) \n                expression = Symbol(operator + \"(\" + join(eval(Symbol(string(operand)))\
    \ for operand in operand) + \")\")\n                \n            # To subtract\
    \ vectors we use the - operator\n            elseif isa(operator, Symbol) && isa(operand,\
    \ Vector{Symbol}) \n                expression = Symbol(operator + \"(\" + join(eval(Symbol(string(operand)))\
    \ for operand in operand) + \")\")\n                \n            # To multiply\
    \ vectors we use the * operator\n            elseif isa(operator, Symbol) && isa(operand,\
    \ Vector{Symbol}) \n                expression = Symbol(operator + \"(\" + join(eval(Symbol(string(operand)))\
    \ for operand in operand) + \")\")\n                \n            # To divide\
    \ vectors we use the / operator\n            elseif isa(operator, Symbol) && isa(operand,\
    \ Vector{Symbol}) \n                expression = Symbol(operator + \"(\" + join(eval(Symbol(string(operand)))\
    \ for operand in operand) + \")\")\n                \n            # To raise a\
    \ number to a power, we use the ^ operator\n            elseif isa(operator, Symbol)\
    \ && isa(operand, Vector{Int64}) \n                expression = Symbol(operator\
    \ + \"(\" + join(eval(Symbol(string(operand))) for operand in operand) + \")\"\
    )\n                \n            # To evaluate an expression with some values\
    \ we use the $() operator\n            elseif isa(operator, Symbol) && isa(operand,\
    \ Vector{Symbol}) \n                expression = Symbol(operator + \"(\" + join(eval(Symbol(string(operand)))\
    \ for operand in operand) + \")\")\n                \n            # To evaluate\
    \ an expression with some values we use the $() operator\n            elseif isa(operator,\
    \ Symbol) && isa(operand, Vector{Symbol}) \n                expression = Symbol(operator\
    \ + \"(\" + join(eval(Symbol(", "    alg = zeros(Int, (length(operator)-1))\n\
    \    for i in 1:length(operator)-1\n        alg[i] = eval(quote(mv[eval(quote($operator[i])),\
    \ eval(quote($operand[i]))]))\n    end\n    return alg[2]\nend", "    \n    #\
    \ Vectorize: \n    # To vectorize a vector, we use an iterator, which allows us\
    \ to iterate through elements of a vector \n    # in a non-sequential order. We\
    \ use iterators to allow us to make our code more readable. The \n    # function\
    \ zip takes in iterators of two vectors, and returns an iterator of tuples. In\
    \ our case,\n    # the first vector has operators as the first element, and the\
    \ second vector has operands as the first \n    # element. These tuples allow\
    \ us to loop through both vectors at the same time. ", "    return do_algebra(operator,\
    \ operand, Int64)\nend", "    result = operand[1]\n    for i = 2:length(operator)\n\
    \        result = operator[i] * result + operand[i]\n    end\n    return result\n\
    end\n</cell>\n<code language=julia-1.5>", "  \n    if length( operator) != length(operand)\
    \ \n        raise ArgumentError(\"Operand and Operator should have same length\"\
    )\n    end", "    \n    # Checks the length of operator and operand vector \n\
    \    if length(operator) != length(operand) - 1 \n        error(\"Vector of basic\
    \ algebra operation must have one operator and one operand.\") \n    end\n   \
    \ \n    # Checks the length of operand vector \n    if length(operand) == 0 \n\
    \        return 0 \n    end\n    \n    # Checks the length of operator vector\
    \ \n    if length(operator) == 0 \n        return 0 \n    end\n    \n    # Calculates\
    \ the value of the basic algebra expression\n    \n    # Initializes the value\
    \ of the basic algebra expression\n    value = zeros(Int64, length(operator))\n\
    \    \n    # Looping through the basic algebra operation vector \n    for i =\
    \ 1:length(operator) \n        \n        # Calculates the value of the basic algebra\
    \ operation\n        value = value + (operator[i] <=> operand[i])\n        \n\
    \        # Prints a message to the user \n        @info \"The value of operator[\"\
    \ \n        show(i) \n        @info \"] is \" \n        show(value) \n       \
    \ @info \". \" \n    end", "  \n    op_len = length(operator)\n    ov_len = length(operand)",
  "    \"\"\" Given two vectors operator, and operand. The first vector has basic\
    \ algebra operations, and \n    the second vector is a vector of integers. Use\
    \ the two given vectors to build the algebric \n    expression and return the\
    \ evaluation of this expression.", "    #Initialise the result variable\n    result\
    \ = Int64(0)\n    #Check that the number of operands matches the number of operators\n\
    \    if(length(operand) != length(operator))\n        return \"Error! Operand\
    \ vector length does not match operator vector\"\n    else\n        #Loop through\
    \ the operator vector\n        for op = 1:length(operator)\n            #Check\
    \ the type of the operator and that it is in the operator list\n            if(operator\
    \ == \"+\" || operator == \"-\" || operator == \"*\" || operator == \"//\" ||\
    \ operator == \"**\")\n                #Add the operand to the result variable\n\
    \                result += operand[op]\n            else\n                #Return\
    \ the error if the operator is not valid\n                return \"Error! Invalid\
    \ operator type\"\n            end\n        end\n    end\n    return result\n\
    end\n</cell>\n<code language=julia-1.6>\n\"\"\"\n    Given an operator and an\
    \ operand, return the result of evaluating the expression \n    on the given vector.",
  "    # First check whether the length of the two vectors are equal\n    if length(operator)\
    \ != length(operand) - 1 \n        throw(ArgumentError(\"Operand and operator\
    \ vectors are not of equal length\"))\n    end\n    \n    # Initialize a variable\
    \ for the result and initialize a variable for the exponent\n    result = 0\n\
    \    exponent = 0"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
