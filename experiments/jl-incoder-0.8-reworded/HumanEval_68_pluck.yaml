name: HumanEval_68_pluck
language: jl
prompt: "\"\"\"\n    \"Given a vector representing a branch of a tree that has non-negative\
  \ integer nodes\n    your task is to pluck one of the nodes and return it.\n   \
  \ The plucked node should be the node with the smallest even value.\n    If multiple\
  \ nodes with the same smallest even value are found return the node that has smallest\
  \ index.\n\n    The plucked node should be returned in a vector, [ smalest_value,\
  \ its index ],\n    If there are no even values or the given vector is empty, return\
  \ [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n    [2, 1]\n    Explanation:\
  \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n\
  \    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation: 2 has the smallest even\
  \ value, and 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n  \
  \  []\n    \n    Example 4:\n    >>> pluck([5, 0, 3, 0, 4, 2])\n    [0, 1]\n   \
  \ Explanation: 0 is the smallest value, but  there are two zeros,\n            \
  \     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n\
  \        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction\
  \ pluck(arr::Vector{Int64})::Vector{Int64} \n"
tests: "using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
  \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
  \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1,\
  \ 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t\
  @test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
  end\n"
completions: ["    \n    length = length(arr)\n    if length < 0\n        return [];\n\
    \    end\n    smalest_value = minimum(arr)\n    index = 1\n    index_of_smalest_value\
    \ = 0\n    while index <= length\n        if arr[index] == smalest_value\n   \
    \         index_of_smalest_value = index\n        end\n        index += 1\n  \
    \  end\n    smalest_value = arr[index_of_smalest_value]\n    index_of_smalest_value\
    \ += 1\n    if length(smalest_value) == 1 && index_of_smalest_value == length\n\
    \        smalest_value = smalest_value[1]\n        index_of_smalest_value = 1\n\
    \    end\n    return [smalest_value, index_of_smalest_value]\nend\n</cell>\n<text>\n\
    4.5 Smallest Even Value in Vector\nGiven a vector representing a branch of a tree\
    \ that has non-negative integer nodes\nyour task is to return the smallest even\
    \ value in the vector.", "    if arr == []\n        return arr\n    if arr[1]\
    \ == 0\n        return [ 0, 1 ]\n    \n    smalest_value = 0\n    smallest_index\
    \ = 0\n    smallest_index_count = 0\n    \n    for n in arr\n        if n % 2\
    \ == 0\n            if n < smalest_value\n                smalest_value = n\n\
    \                smallest_index_count = smallest_index\n            smallest_index\
    \ += 1\n        elseif smallest_index < smallest_index_count\n            smallest_index_count\
    \ += 1\n        \n    return smallest_index_count > 1 ? [smalest_value, smallest_index]\
    \ : []\nend", "    smallest_value = arr[end]\n    smallest_value = arr[end]\n\
    \    smallest_index = -1", "    # initialize a vector and initialize an array\
    \ to store the result\n    \n    length = length(arr)\n    smalest_value = 0\n\
    \    smalest_index = 0\n    \n    # check if there are no even values and if empty\
    \ array is returned\n    if length == 0\n        return []\n    end\n    \n  \
    \  # initialize a min variable, an index variable, and a variable for the value\
    \ of the node\n    min_value = arr[end]\n    min_index = length(arr)\n    \n \
    \   # loop through the array and get the min value and the index of the smallest\
    \ value\n    for index in end-1:-1:1\n        if arr[index] > min_value\n    \
    \        min_value = arr[index]\n            min_index = index\n        else\n\
    \            break\n        end\n    end", "    if arr == []\n        ans = []\n\
    \    else\n        smalest_value = minimum(arr)\n        smallest_index = 1\n\
    \        for value in arr\n            if value == smalest_value\n           \
    \     smallest_index += 1\n                break\n            elseif value <>\
    \ smalest_value\n                break\n        end\n        ans = [smalest_value,\
    \ smallest_index]\n    end\n    return ans\nend\n\"\"\"\n    pick_up_the_branch_with_the_smallest_value_in_it",
  "    if arr.length == 0\n        return []\n    else \n        evens = filter(x\
    \ -> x % 2 == 0, arr)\n        even_value = min(evens)\n        index = find(x\
    \ -> x == evens, evens)\n        return [even_value, index]\n    end\nend", " \
    \   if arr.length == 0\n        return [];\n    if arr.length == 1\n        return\
    \ [ arr[0], arr[1] ];\n    smallest_value_index = find_largest_index_of_even(arr);\n\
    \    return [ arr[smallest_value_index], arr[smallest_value_index+1] ];\nend",
  "    if !length(arr)\n        return []\n    end", "    if length(arr) == 0 \n \
    \       return [] \n    even_index = arr[1:end-1] \n    smalest_value = max(even_index)\
    \ \n    if length(even_index) == 0 \n        return [] \n    else \n        return\
    \ [ smalest_value, findfirst(x -> x % 2 == 0, even_index) ] \nend\n</cell>\n<code\
    \ language=julia-1.5>\n# Run this cell to test your solution", "    smalest_value\
    \ = Int64(0)\n    smalest_node_index = Int64(0)\n    # Write your code here\n\
    \    if isempty(arr)\n        return []\n    else\n        for node in arr\n \
    \           if node.value % 2 == 0\n                if node.value < smalest_value\n\
    \                    smalest_value = node.value\n                    smalest_node_index\
    \ = node\n                end\n            end\n        end\n        return [smalest_value,\
    \ smalest_node_index]\n    end\nend\n</cell>\n<text>\nSolution\nLet's take a look\
    \ at your solution and see if you can figure it out by yourself. Let's start by\
    \ writing a function called pluck_one, which takes in a node and returns the node's\
    \ value with the smallest odd value. Remember that a node will have odd value\
    \ and odd index.", "    if length(a) == 0 \n        return [] \n    smallest_value_index\
    \ = 0\n    smallest_value = a[1]\n    for i in 2:length(a)\n        if a[i] <\
    \ smallest_value \n            smallest_value = a[i]\n            smallest_value_index\
    \ = i\n        elseif a[i] == smallest_value \n            smallest_value_index\
    \ = i\n    end\n    return smallest_value_index\nend", "    even_values = arr.filter(x\
    \ -> x%2 == 0)\n    sorted_even_values = sort(even_values)\n    \n    if !sorted_even_values\n\
    \        return []\n    else\n        [smalest_value, smallest_index] = sorted_even_values\n\
    \        [smallest_value_idx, smallest_value] = find(even_values, smallest_value)\n\
    \        return [smalest_value, smallest_index]\n    end\nend", "    node = find_node(arr)\n\
    \    smalest_value = find_smalest_value(arr)\n    if smalest_value == 0\n    \
    \    return []\n    if smalest_value % 2 == 0\n        return smalest_value, node\n\
    \    else\n        return smalest_value - 1, node-1\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\narr = [0, 6, 3, 0, 4]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<text>\nProblem 7", "    if arr.length == 0\n        return\
    \ []\n    sorted_arr = sort!(arr)\n    \n    # get the index of the smallest even\
    \ number, \n    # which happens to be the smallest index among the sorted elements\n\
    \    i_smallest_even_value = findfirst(item -> item % 2 == 0, sorted_arr)\n  \
    \  \n    # if the input vector doesn't contain even numbers, return the empty\
    \ vector\n    if i_smallest_even_value == nothing \n        return [] \n    else\n\
    \        # if the input vector contains even numbers, \n        # return the vector\
    \ with the smallest even value, \n        # and with the smallest index, \n  \
    \      # or empty vector if there is no such element\n        return [sorted_arr[i_smallest_even_value],\
    \ i_smallest_even_value]\n    end\nend\n</cell>\n<code language=julia-1.6>\nusing\
    \ Test", "    \n    @assert arr.length >= 1 \"Array must have length greater than\
    \ 1.\"\n    largest = minimum(arr)\n    index = find(arr == largest)\n    largest\
    \ = arr[index]\n    return largest\nend", "    if is_zero(arr)\n        []\n \
    \   else\n        odd_idxs, even_idxs = partition(arr |> sort) |> partition(x\
    \ -> x % 2 == 0)\n        odd_value = arr[odd_idxs[1]]\n        even_value = arr[even_idxs[1]]\n\
    \        if odd_value == even_value\n            odd_idx\n        else\n     \
    \       odd_idx\n        end\n    end\nend", "    if arr.size <= 1\n        return\
    \ []\n    elseif arr.size == 2\n        return [arr[1], 1]\n    end", "    smalest_value::Int64\
    \ = 2147483647 # 2^31-1 to start\n    smallest_index::Int64 = -1", "    even_idx\
    \ = zeros(Int64, length(arr))\n    even_idx[1] = 1\n    i = 0\n    while i < length(arr)\n\
    \        if arr[i] % 2 != 0\n            i += 1\n            continue\n      \
    \  elseif i == length(arr)\n            break\n        end\n        \n       \
    \ even_idx[i] = i\n        i += 2\n    end\n    \n    smallest_val = arr[min(even_idx)]\n\
    \    idx = find(even_idx == smallest_val)[1]\n    \n    return smallest_val, idx\n\
    end\n</cell>\n<text>\nProblem 3\nA tree is given to you. Your task is to return\
    \ the depth of that tree.", "    if !isempty(arr)\n        smalest_value = min(arr)\n\
    \        smalest_idx = findfirst(x -> x==smalest_value, arr)\n        return [smalest_value,\
    \ smalest_idx]\n    end\n    return []\nend\n</cell>\n<text>\nSolution\nLet's\
    \ see how we can use these helper functions to solve the problem. We'll first\
    \ test these helper functions to make sure they work as intended. If they do not,\
    \ please inspect your functions before moving on.", "    if length(arr)==0 ||\
    \ arr.size < 2 \n        return Vector{Int64}[]\n    \n    smallest = 0\n    smalest_value\
    \ = 0\n    smallest_index = 0\n    for node in arr\n        if node % 2 == 0 \n\
    \            if smallest_index == 0\n                smallest = node\n       \
    \         smallest_index = arr.index(node)\n            else\n               \
    \ if smallest_index == arr.index(node)\n                    smallest_index = arr.index(node)\n\
    \                else\n                    if smallest_value < node\n        \
    \                smallest = node\n                        smallest_index = arr.index(node)\n\
    \                    end\n                end\n            end\n        else\n\
    \            if smallest == 0 \n                smallest = node\n            \
    \    smallest_index = arr.index(node)\n            else\n                if smallest_index\
    \ == arr.index(node)\n                    smallest_index = arr.index(node)\n \
    \               else\n                    if smallest_value < node\n         \
    \               smallest = node\n                        smallest_index = arr.index(node)\n\
    \                    end\n                end\n            end\n        end\n\
    \    end", "  if length(arr) == 0 \n    []\n  else\n    arr = [arr[i]; i = 1;\
    \ smallest_index = 1; flag = true; flag2 = false; while i < length(arr) and flag\n\
    \        if arr[i]%2 == 0 && flag == false \n            flag = false\n      \
    \      smallest_index = i\n        elseif arr[i]%2 == 1 && flag == true \n   \
    \         flag = true\n            smallest_index = i\n        end\n        i\
    \ += 1\n    end]\n    if flag == true \n        arr[smallest_index]\n    elseif\
    \ flag == false \n        arr[smallest_index-1]\n    else\n        arr[smallest_index-1],\
    \ arr[smallest_index]\n    end\nend\n</cell>\n<code language=julia-0.5>\n\"\"\"\
    \n    pick([5, 4, 3, 2, 1])\n    [4, 3, 2, 1]\n\"\"\"", "    smallest_value::Int64\
    \ = 9999999999999\n    smallest_index::Int64 = -1\n    \n    for i in arr\n  \
    \      if iszero(i)\n            return smallest_index, smallest_value\n     \
    \   elseif i%2 == 0\n            smallest_value = i\n        else\n          \
    \  if smallest_value>i\n                smallest_value = i\n            smallest_index\
    \ = i\n        end\n    end\n    smallest_index\nend\n</code>\n<|/ a tags=recursion,sorting,algorithm,dynamic-programming\
    \ |>\n<| a tags=recursion,sorting,algorithm,dynamic-programming dscore=0 |>\n\
    The following is Python.\n<code>\ndef pick_from_tree(tree,n):\n    if tree ==\
    \ None:\n        return None\n    elif n == 1:\n        return tree.value\n  \
    \  else:\n        picked_node = pick_from_tree(tree.left,n-2)\n        if picked_node\
    \ == None:\n            picked_node = pick_from_tree(tree.right,n-2)\n       \
    \ return picked_node", "    # Write your code in Julia 0.5 here\nend\n</cell>\n\
    <text>\nSolution 2 - Brute force\nThe brute force solution will be the one that\
    \ is computationally intractable for $n$. While it is not prohibitively expensive\
    \ to do so, it can be done by solving one problem per iteration. We can think\
    \ of it as \"hard\" coding, where you just type the problem into Julia and then\
    \ run the code. But this is very inefficient.", "    if arr == []\n        []\n\
    \    else\n        smalest_value =  maximum(arr)\n        smallest_index = argmax(arr)\n\
    \        if smallest_index == length(arr)\n            return [smalest_value,\
    \ 0]\n        \n        smallest_index == min(arr)\n        arr_smallest_index\
    \ = filter(smallest_index == arr)\n        \n        if length(arr_smallest_index)\
    \ > 1\n            arr_smallest_index = arr_smallest_index[1]\n        else\n\
    \            arr_smallest_index = []\n        end\n        arr_smallest_index\n\
    \    end\nend", "    # Your code here\n    return [] \nend", "    if arr.size\
    \ == 0 return []\n    even_values = unique(arr).filter(x -> x % 2 == 0)\n    smallest_index\
    \ = find(even_values)[1]\n    smallest_value = arr[smallest_index]\n    other_values\
    \ = [v for v in arr if v not in even_values]\n    smallest_even_value = minimum(other_values)\n\
    \    smallest_value_index = [i for (i, v) in enumerate(arr) if v == smallest_value]\n\
    \    return smallest_value, smallest_value_index\nend\n</cell>\n<text>\n6.3 Binary\
    \ Search\nThe binary search algorithm is an efficient method of searching a sorted\
    \ vector for an element that meets a given condition. The algorithm is as follows:",
  "    if arr.size < 2\n        return Vector{Int64}()\n    even_values = filter(value\
    \ -> value % 2 == 0, arr)\n    even_values.sort()\n    smallest_value_index =\
    \ even_values[1]\n    smallest_value = arr[smallest_value_index]\n    index =\
    \ find(arr == smallest_value, 1)[1]\n    return Vector{Int64}([smallest_value,\
    \ index])\nend\n</cell>\n<text>\nSolution\nLet's test our code", "   if  arr.length\
    \ == 0 || arr.all?(x -> x <= 0) \n    []\n   elseif arr.length == 1\n    [ arr[1],\
    \ arr[1] ]\n   else\n        evens = arr.filter(x -> x % 2 == 0)\n        if evens.length\
    \ == 1\n            [ evens[0], evens[0] ]\n        elseif evens.length > 1\n\
    \            [ evens[findmin(evens)], findmin(evens) ]\n        end\n   end\n\
    end", "    if arr.isEmpty\n        return arr\n    if arr.len==1 && (arr.value==0\
    \ || arr.value==2)\n        return arr.value\n    \n    if arr.value==0 || arr.value==2\n\
    \        return arr.value\n    end\n    val2idx={}\n    smallest_val=2\n    for\
    \ (i,v) in enumerate(arr)\n        if v==2 && smallest_val==2\n            val2idx[i]=1\n\
    \        elseif v==2 && smallest_val>2\n            smallest_val=v\n         \
    \   val2idx[i]=1\n        elseif v==2 && smallest_val==2\n            val2idx[i]=1\n\
    \        else\n            val2idx[i]=0\n        end\n    end", "    # Write your\
    \ code here.\n    \n    smallest_index = 1\n    smallest_value = arr[1]\n    \n\
    \    for i = 2 to length(arr)\n        if arr[i] % 2 == 0 && arr[i]<smallest_value\n\
    \            smallest_value = arr[i]\n            smallest_index = i\n       \
    \ end\n    end\n    \n    return [smallest_value, smallest_index]\nend\n</cell>\n\
    <text>\nPart C: Mushroom vs. Grape\nNow that you've made your first function,\
    \ it's time to test it by writing a unit test. We'll define two test cases to\
    \ demonstrate your function, then pass in a list of numbers to a function and\
    \ compare the results with a list that is the output of the function call.", " \
    \   smallest_index = 0\n    smallest_value = arr[1]\n    for node in arr[2 : end]\n\
    \        if smallest_value > node\n            smallest_value = node\n       \
    \     smallest_index = index\n        end\n    end\n    return Vector{Int64}([smallest_value,\
    \ smallest_index])\nend\n</cell>\n<text>\nSolution\nUsing the logic above, we\
    \ can find the correct answer.", "  if length(arr) == 0\n    return []\n  end\n\
    \  # sort all the even values, and pick up the first one.\n  sortedArr = sort(arr)\n\
    \  evenVal = sortedArr[1]\n  # return the even value and the index. \n  return\
    \ [evenVal, sortedArr.findIndex(x -> x % 2 == 0)]\nend\n</cell>\n<code language=julia-1.3>\n\
    # test your function pluck \n@assert pluck([4, 2, 3]) == [2,1]\n@assert pluck([1,2,3])\
    \ == [2,1]\n@assert pluck([]) == []\n@assert pluck([5, 0, 3, 0, 4, 2]) == [0,\
    \ 1]\n</cell>\n<text>\nExercise 3: Sorting\nA sorted vector represents a binary\
    \ tree, with all the nodes having integer values, between $0$ and $2$. Let's define\
    \ the helper function sort_arr to sort an array of integers.", "    smallest_value\
    \ = arr[1]\n    smallest_index = 1\n    for value in arr[2:end]\n        if value\
    \ % 2 == 0\n            smallest_value = value\n        else\n            if smallest_value\
    \ % 2 == 0\n                smallest_value = smallest_value + 1\n            else\n\
    \                smallest_value = smallest_value - 1\n            end\n      \
    \  end\n    end\n    \n    if smallest_index == length(arr)\n        smallest_value\n\
    \    else\n        smallest_value - 1\n    end\nend\n</cell>\n<text>\n2.2 Refactoring\
    \ your code\nExercise: Write a function that returns a vector [smaller, index]\
    \ of the two nodes with the smallest even values.", "    # code here \nend\n</cell>\n\
    <text>\nSolution\nClick File -> Save a Copy in Drive to save your work.\nPlease\
    \ submit only ONE file per submission.", "    sorted_arr = sort(arr)\n    smallest_val\
    \ = sorted_arr[1]\n    smallest_idx = 1", "    smalest_value = Int64(0)\n    smallst_index\
    \ = Int64(0)", "    minimum = Inf, index=0\n    for i in arr\n        if i%2 ==\
    \ 0 && i<minimum\n            minimum = i\n            index = minimum\n     \
    \   end\n    end\n    return [index,minimum]\nend\n</cell>\n<code language=julia-0.5>\n\
    pluck([4,2,3])\n</cell>\n<code language=julia-0.5>\npluck([1,2,3])\n</cell>\n\
    <code language=julia-0.5>\npluck([])\n</cell>\n<code language=julia-0.5>\npluck([5,0,3,0,4,2])\n\
    </cell>\n<text>\nExercise 12\nDefine a function named pluck_min_index that implements\
    \ the pluck function above.", "    # write your code here\n    return []\nend",
  "    ans = []\n    for i in 1:length(arr)\n        if arr[i] % 2 == 0 && isEven(arr[i])\n\
    \            push!(ans,arr[i])\n        end\n    end\n    return ans\nend", " \
    \   if arr.length == 0 \n        arr \n    elseif arr.length == 1\n        [ arr[1]]\
    \ \n    elseif arr.length == 2\n        [ arr[1], arr[1] ]\n    elseif arr.length\
    \ == 3\n        [ arr[1], arr[2], arr[1] ]\n    else\n        pivot = arr[arr.length/2]\
    \ \n        min_even_val = pivot; \n        min_idx = 0\n        for i in 1:arr.length\n\
    \            if arr[i] == pivot\n                if arr[i] % 2 == 0 \n       \
    \             min_even_val = arr[i]\n                    min_idx = i\n       \
    \         end\n            end\n        end\n        arr[min_idx], arr[-1] \n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n# Your function should satisfy\
    \ the following requirements:\n\"\"\"\n    Your function should satisfy the following\
    \ requirements:\n    * Your function should accept an array of arbitrary size.\n\
    \    * Your function should return a vector of arbitrary size.\n    * Your function\
    \ should pluck one of its element (if it is present), \n      and return the pluck\
    \ element in a vector, [ smalest_value, its index ].\n    * Your function should\
    \ pluck one of its element (if it is present), \n      and return the pluck element\
    \ in a vector, [ smalest_value, its index ].\n    * Your function should pluck\
    \ one of its element (if it is present), \n      and return the pluck element\
    \ in a vector, [ smalest_value, its index ].\n    * Your function should pluck\
    \ one of its element (if it is present), \n      and return the pluck element\
    \ in a vector, [ smalest_value, its index ].\n    * Your function should pluck\
    \ one of its element (if it is present), \n      and return the pluck element\
    \ in a vector, [ smalest_value, its index ].\n    * Your function should pluck\
    \ one of its element (if it is present), \n      and return the pluck element\
    \ in a vector, [ smalest_value, its index ].\n    * Your function should pluck\
    \ one of its element (if it is present), \n      and return the pluck element\
    \ in a vector, [ smalest_value, its index ].\n\"\"\"", "    \n    if arr.length==0\n\
    \        Vector{Int64}()\n    else\n        smallest=arr.min(); \n        smallest_index=0;\n\
    \        smallest_even=0;\n        \n        for i=1:arr.length\n            if\
    \ arr[i] % 2 != 0\n                if arr[i] < smallest || smallest_even\n   \
    \                 smallest_even=smallest; \n                    smallest_even_index=i;\n\
    \                end\n            elseif arr[i] == smallest \n               \
    \ smallest_even=smallest; \n                smallest_even_index=i; \n        \
    \    end\n        end\n        return [smallest_even, smallest_even_index]\n \
    \   end\n    \nend", "    if arr.length == 0\n        return Vector{Int64}()\n\
    \    else\n        smalest_value::Int64 = minimum(arr);\n        smalest_index::Int64\
    \ = findfirst(elem -> (elem % 2 == 0), arr);\n        return smalest_index, arr[smalest_index]\n\
    \    end\nend", "    result = vec[]\n    for node in arr\n        if node%2 ==\
    \ 0 && node>0 \n            push!(result,node)\n        end\n    end\n    if result\
    \ == []\n        return vec[]\n    end\n    # get the smallest even value node\n\
    \    smallest_value = result[1]\n    smallest_index = 1\n    for node in result[2:end]\n\
    \        if node%2 == 0\n            if node < smallest_value\n              \
    \  smallest_value = node\n                smallest_index = smallest_index+1\n\
    \            end\n        end\n    end\n    return smallest_value, smallest_index\n\
    end\n</cell>\n<code language=julia-1.1>\n\"\"\"\n    next_in_direction(array::Vector{Int64},\
    \ i::Int64, j::Int64)\n    Calculates what is the next index in direction of (j,i)\
    \ in the array\n    \n    Args\n        array::Vector{Int64}\n        i::Int64\n\
    \        j::Int64\n    Returns\n        \n    \"\"\"", "    # Write your code\
    \ here\n    arr = arr |> sort\n    smalest_value = 0\n    smalest_index = 0\n\
    \    smallest_value = 0\n    smallest_index = 0\n    while smallest_value < smalest_value\n\
    \        smallest_value = arr[1]\n        smallest_index = 1\n        for i in\
    \ 2 to length(arr)\n            if arr[i] < smallest_value\n                smallest_value\
    \ = arr[i]\n                smallest_index = i\n            else\n           \
    \     break\n        end\n        if smallest_value < smalest_value\n        \
    \    smalest_value = smallest_value\n            smalest_index = smallest_index\n\
    \        end\n    end\n    if smalest_value<0\n        smalest_value = 0\n   \
    \     smalest_index = 0\n    end\n    return [ smalest_value, smalest_index ]\n\
    end\n</cell>\n<code language=julia-1.6>\n# Run this cell to grade your solution\n\
    @assert pluck([4, 2, 3]) == [2, 1]\n@assert pluck([1, 2, 3]) == [2, 1]\n@assert\
    \ pluck([]) == []\n@assert pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\n</cell>\n<text>\n\
    Question 2.2\nWrite a function that will get all permutations of an input vector,\
    \ returning a vector of vectors.", "    local counter = 1\n    \n    while counter\
    \ <= size(arr) \n        if arr[counter] == 0 \n            counter += 1 \n  \
    \      else \n            break\n        end\n    end\n    \n    return arr[counter]:min(length(arr)-counter,\
    \ counter)\nend\n\"\"\"\n    My own solution using array slicing and a while loop.\
    \ Can you think about a better one?\n\"\"\"", "    \"\"\"\n    Given a vector\
    \ representing a branch of a tree that has non-negative integer nodes\n    your\
    \ task is to pluck one of the nodes and return it.\n    The plucked node should\
    \ be the node with the smallest even value.\n    If multiple nodes with the same\
    \ smallest even value are found return the node that has smallest index.", " \
    \   result = deepcopy(arr)\n    idx = findall(arr .!= 0)\n    idx2 = findall(arr\
    \ .==0)\n    idx = idx[1] if isempty(idx2) else idx2\n    result = idx\n    return\
    \ result\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    plusminus(arr::Vector{Int64})",
  "    \n    \"\"\"\n    Your solution should go here...\n    \"\"\"\n    # YOUR CODE\
    \ HERE\n    \n    return []\n    \nend", "    #get first odd number\n    \n  \
    \  #find out smallest odd number\n    smallest_odd  = find_smallest_odd(arr)\n\
    \    smallest_odd_idx  = arr.index( smallest_odd )\n    \n    #find the first\
    \ index with smallest odd number with even\n    smallest_odd_idx_even_with_even\
    \ = find_index_of_smallest_odd_even_with_even(arr,smallest_odd_idx)", "    return\
    \ arr[(minimum(arr))...]\nend", "    picked = sort(arr.+0, by=(x->iszero(x), reverse))\n\
    \    picked[1] = 1\n    if isempty(picked)\n        picked = []\n    elseif iszero(picked[end])\n\
    \        picked = []\n    end\n    return picked\nend", "    \n    smalest_value\
    \ = arr[end]\n    smalest_index = 0\n    for i in 1:length(arr)\n        cur_val\
    \ = arr[i]\n        if cur_val < smalest_value\n            smalest_value = cur_val\n\
    \            smalest_index = i\n        end\n    end\n    return Vector{Int64}([smalest_value,\
    \ smalest_index])\nend\n</cell>\n<code language=julia-1.5>\ntest_pluck()\n</cell>\n\
    <text>\nProblem 3\nProblem 3 is a slightly more challenging problem. It involves\
    \ building a tree of depth-k nodes where each node has value v.", "    sorted\
    \ = sort(arr,by=length).reverse\n    smallest = sorted[1]\n    smallest_index\
    \ = find(sorted==smallest,1)\n    smallest_value = arr[smallest_index]\n    if\
    \ smallest_value%2==0\n        return smallest\n    else\n        return smallest_value\n\
    \    end\nend", "    if len(arr) == 0 || arr == Vector{Int64}()\n        return\
    \ Vector{Int64}()\n    end", "    if arr == [] || arr == [Int64]\n        arr\
    \ = []\n    else\n        sorted = sort(arr)\n        index = 1:length(arr)\n\
    \        if iszero(arr) || iszero(sorted)\n            arr = []\n        else\n\
    \            index = index(arr .== sorted[1])\n        end\n    end\n    return\
    \ arr\nend\n</cell>\n<code language=julia-1.2>\n@test pluck([4, 2, 3]) == [2,\
    \ 1]\n@test pluck([1, 2, 3]) == [2, 1]\n@test pluck([]) == []\n@test pluck([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n</cell>\n<text>\nPart II: Tree Problems", "    smallest_even_value\
    \ = Int64(0); \n    index_of_smallest_even_value = Int64(0)\n    smallest_even_value,\
    \ index_of_smallest_even_value = pluck_bruteforce(arr)\n    return smallest_even_value,\
    \ index_of_smallest_even_value\nend", "    sorted_arr = sort(arr)\n    smallest_value\
    \ = min(sorted_arr)\n    smallest_idx = find(sorted_arr == smallest_value)[2]\n\
    \    \n    return smallest_value, smallest_idx\nend", "    if length(arr) == 0\
    \ \n        arr \n    else \n        smalest_value = arr[minimum(arr[!, :] .==\
    \ 0) .== 0]\n        smalest_index  = minimum(arr[!, :] .== 0) \n        \n  \
    \      return smalest_value .+ [smalest_index] \n    end\nend\n</cell>\n<text>\n\
    Problem 3\nGiven a vector of non-negative integers your task is to return the\
    \ sum of all the odd values plus all the even values.\nThe sum of the odd values\
    \ is given by (x + y). Where x is an even value and y is odd.\nThe sum of the\
    \ even values is given by (x + y).\nIf there are multiple odd values or multiple\
    \ even values, pick the odd or even value with smallest index value.", "    \n\
    \    smallest_value = arr[1]\n    smallest_index = arr[2]\n    index_to_search\
    \ = arr[2]\n    \n    if arr.length == 1\n        return Vector{Int64}()\n   \
    \ end\n    \n    for i in arr[end-1:end]\n        if i % 2 == 0 \n           \
    \ index_to_search = i\n            smallest_value = i\n        elseif i == smallest_value\n\
    \            index_to_search = i\n            smallest_value = i\n        end\n\
    \    end\n    \n    if index_to_search == smallest_value\n        index_to_search\
    \ = index_to_search + 1\n    end\n    return Vector{Int64}([smallest_value, index_to_search])\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    plus()", "    if length(arr)\
    \ == 0 \n        return [] \n    end\n    if length(arr) == 1 \n        return\
    \ arr\n    end\n    \n    smalest_value = arr[1]\n    smalest_index = 1 \n   \
    \ \n    for i = 2:length(arr)\n        if arr[i] < smalest_value \n          \
    \  smalest_value = arr[i]\n            smalest_index = i \n        end\n    end\n\
    \    return smalest_index, smalest_value \nend ", "    even_values = arr.filter(x\
    \ -> (x % 2 == 0))\n    if isempty(even_values) \n        return []\n    smalest_value\
    \ = min(even_values)\n    smallest_even_value = smalest_value\n    smallest_index_of_smallest_even_value\
    \ = -1\n    for (i,val) in enumerate(even_values)\n        if val == smalest_value\n\
    \            smallest_index_of_smallest_even_value = i\n        else\n       \
    \     if val < smalest_value\n                smalest_value = val\n          \
    \      smallest_even_value = smalest_value\n                smallest_index_of_smallest_even_value\
    \ = i\n            end\n        end\n    end\n    return [smalest_value, smallest_index_of_smallest_even_value]\n\
    end\n</cell>\n<text>\nExercise 7\nWrite a function that finds the second smallest\
    \ number in an array.", "    if arr.length == 0 \n        return [] \n    if arr.length\
    \ == 1 \n        return arr \n    \n    #picking smallest node by comparing two\
    \ nodes \n    pick = arr[min(2, arr.length-1)] \n    \n    #making vector for\
    \ our answer\n    answer = Vector{Int64}() \n    \n    #running through the vector\
    \ \n    for node in arr[2:end] \n        if node % 2 == 0 \n            push!(answer,\
    \ node) \n        else \n            push!(answer, pick) \n            break \n\
    \    \n    \n    #returning our answer\n    return answer \nend", "    if arr.is_empty\n\
    \        return [];\n    \n    sorted_arr = sort(arr)\n    min_even_value = arr[1]\n\
    \    index_of_min_even_value = 1\n    \n    for node in sorted_arr\n        if\
    \ node%2==0\n            if min_even_value > node\n                min_even_value\
    \ = node\n                index_of_min_even_value = index_of_min_even_value +\
    \ 1\n            end\n        end\n    end\n    \n    if min_even_value==0\n \
    \       return arr\n    else\n        return [min_even_value, index_of_min_even_value]\n\
    \    end\nend", "    l = sort(arr)\n    evens = l.filter(x -> x % 2 == 0)\n  \
    \  if iseven(l)\n        return evens\n    end\n    return l\nend\n</cell>\n<code\
    \ language=julia-0.6>\n# Task 7: Find the maximum value in a given vector of Int64\n\
    \"\"\"\n    A vector of Int64 numbers is given. Your task is to find the maximum\
    \ value\n    in that vector. Your code should return the number itself.", "  \
    \  # Write your code here\n    largest = minimum(arr)\n    even = collect(Iterators.filter(x->mod(x,2)==0,arr))\n\
    \    smallest = minimum(even)\n    index = where(even==smallest)[1][1]\n    return\
    \ [smallest, index]\nend", "    \n    if arr.length == 0 || arr.length == 1 \n\
    \        return []\n    \n    smallest_even::Int64 = arr[1]\n    smallest_even_index::Int64\
    \ = 1\n    \n    for n in arr[2 : (end-1)] \n        \n        if n%2 == 0 \n\
    \            \n            if smallest_even > n \n                smallest_even\
    \ = n\n                smallest_even_index = n\n            else\n           \
    \     smallest_even = smallest_even_index\n            end\n        end\n    end\n\
    \    \n    smallest_even_index + 1\nend\n</cell>\n<code language=julia-1.5>\n\
    # Let's try our function on some examples", "    sorted = sort(arr)\n    i = findfirst(x\
    \ -> iszero(x), sorted, true)\n    if i == -1\n        return emptyvector()\n\
    \    elseif i == length(sorted)\n        return sorted\n    elseif i%2 == 1\n\
    \        val = sorted[i]\n    else\n        val = sorted[i]\n    end\n    \n \
    \   index = findfirst(x -> x % 2 == 0, sorted, true)\n    push!(index, i)\n  \
    \  push!(val, i)", "    # check if there is even values\n    if arr[1] == 0\n\
    \        return [];\n    # pick the node with the smallest even value \n    min_even_value\
    \ = arr[1];\n    idx = 0;\n    while idx < arr.length\n        if arr[idx] % 2\
    \ != 0\n            break;\n        else\n            min_even_value = min(min_even_value,\
    \ arr[idx])\n            idx = idx + 1\n    end\n    \n    return [min_even_value,\
    \ idx]\nend", "    evens = filter(x -> x % 2 == 0, arr)\n    even_idx = minimum(evens)\n\
    \    smalest_value_idx = find(x -> x == evens[even_idx], evens)[1]\n    smalest_value\
    \ = arr[smalest_value_idx]\n    if smalest_value_idx == 0 && arr.length == 0\n\
    \        return []\n    elseif even_idx == 0\n        return [smalest_value, smalest_value_idx]\n\
    \    else\n        return arr[smalest_value_idx, even_idx]\n    end\nend", " \
    \   largest = minimum(arr)\n    smallest = maximum(arr)\n    largest = Int64(\
    \ largest.value )\n    smallest = Int64( smallest.value )\n    largest = Int64(smallest.value\
    \ - largest.value // 2)\n    arr2 = Int64[]\n    if smallest.even == false\n \
    \       for elem in arr\n            if elem.even == false\n                if\
    \ elem.value == largest\n                    arr2 = elem\n                   \
    \ break\n                end\n            end\n        end\n    end\n    arr2\n\
    end\n</cell>\n<text>\n4.5 Plucking a Tree\nGiven a rooted tree with non-negative\
    \ integer nodes, pluck any of the nodes and return it\nThe plucked node should\
    \ be the node with the smallest odd value. If multiple nodes with the same smallest\
    \ odd value are found,\nreturn the node that has smallest index.", "    smallval\
    \ = arr[1]\n    smallind = 1\n    smallcount = 0\n    for i in arr[2:end]\n  \
    \      if i%2 == 0\n            smallcount += 1\n        else\n            if\
    \ smallcount == 0\n                smallval = i\n                smallind = i\n\
    \            else\n                if i < smallval\n                    smallval\
    \ = i\n                    smallind = i\n                end\n            end\n\
    \        end\n    end\n    \n    if smallcount == 0 && length(arr) == 1 && smallval\
    \ == 0\n        smallind = 1\n    end\n    \n    return [smallval, smallind]\n\
    end", "    smallest_value,smallest_index = 1,1\n    if arr == []\n        return\
    \ []\n    for i in arr\n        if i % 2 == 0\n            if smallest_value <\
    \ i\n                smallest_value, smallest_index = i, i\n            else\n\
    \                smallest_value, smallest_index = smallest_index, i\n        else\n\
    \            smallest_value, smallest_index = smallest_index, i\n    end\n   \
    \ return [smallest_value, smallest_index]\nend", "    smalest_value = 0\n    smallest_index\
    \ = 1\n    if !isempty(arr)\n        for i in arr\n            if i % 2 == 0\n\
    \                if i < smalest_value\n                    smalest_value = i\n\
    \                    smallest_index = 1\n                else\n              \
    \      smallest_index += 1\n            end\n        end\n    end\n    \n    if\
    \ smalest_value == 0\n        return vec[]\n    end\n    \n    index_of_smallest_value\
    \ = smallest_index\n    \n    smallest_value =  0\n    for i in 1:length(arr)\n\
    \        if arr[i] % 2 == 0\n            if arr[i] < smallest_value\n        \
    \        smallest_value = arr[i]\n                index_of_smallest_value = i\n\
    \            end\n        end\n    end\n    \n    if index_of_smallest_value ==\
    \ length(arr)\n        return vec[]\n    end", "    smalest_value = Int64(0)\n\
    \    smalest_index = Int64(0)\n    \n    for node in arr\n        if node % 2\
    \ == 0 && node > smalest_value\n            smalest_value = node\n           \
    \ smalest_index = findfirst(node .== smalest_value)\n        end\n    end", " \
    \   # write your code in Python 3.7\n    # Your code here\n    # ...\n    # ...",
  "    sorted = arr.sorted()\n    index = sorted.size - 1\n    while index >= 0 &&\
    \ sorted[index] % 2 == 0\n        index -= 1\n    return sorted[index..end]\n\
    end", "    if arr.length==0 \n        return [] \n    end", "    s = sort(arr)\n\
    \    return s[2, 1]\nend\n</cell>\n<text>\nProblem 4\nThe following code shows\
    \ one way to calculate the minimum number of swaps to get from $a$ to $b$. Given\
    \ two integers $a$ and $b$, we define the total number of swaps required to sort\
    \ a list of length $n$ as $\\mathrm{swaps} = \\mathrm{swaps}_{n} = n(n+1)/2$.\
    \ \nThe total number of swaps is the sum of the $\\mathrm{swaps}$ values for all\
    \ combinations of $a$ and $b$, i.e., $\\mathrm{swaps}_n = \\sum{i=1}^n \\mathrm{swaps}_i$.\
    \ \nIn other words, to sort a list of length $n$, we first sort the list of length\
    \ $n-1$, giving a list of length $n$, using $\\mathrm{swaps}_n$ swaps, then we\
    \ sort the list of length $n-2$, giving a list of length $n$, using $\\mathrm{swaps}_n$\
    \ swaps, etc.", "    if length(arr) == 0 || arr == []\n        return vec[]\n\
    \    else\n        if arr[1] <= 0\n            return vec[]\n        else\n  \
    \          if arr[1] & 1 == 0\n                return vec[[arr[1]]]\n        \
    \    else\n                indexOfSmallestEvenValue = 0\n                for i=2:length(arr)\n\
    \                    if arr[i] & 1 == 0\n                        if arr[i] < arr[indexOfSmallestEvenValue]\n\
    \                            indexOfSmallestEvenValue = i\n                  \
    \      else\n                            break\n                    end\n    \
    \            end\n                return vec[indexOfSmallestEvenValue:end]\n \
    \           end\n        end\n    end\nend\n</cell>\n<text>\nProblem 10\nGiven\
    \ a vector of sorted integers, find the sum of the next consecutive 3 values.",
  "    if length(arr) == 0\n        Vector{}\n    else\n        smalest_value = 0\n\
    \        smallest_index = 0\n        \n        for i in arr\n            if i%2\
    \ == 0 && smallest_index == 0\n                smallest_index = i\n          \
    \      smalest_value = value\n            elseif i%2 == 0 && smallest_index !=\
    \ 0\n                smallest_index = i\n                smalest_value = value\n\
    \            else\n                smalest_value = i\n            end\n      \
    \  end", "    if arr.empty\n        return arr\n    if arr.size == 1\n       \
    \ return arr\n    smalest_value = minimum(arr)\n    index = 1\n    smallest_value\
    \ = arr[arr.index(smalest_value)]\n    while smallest_value == smalest_value\n\
    \        index += 1\n        smallest_value = arr[arr.index(smalest_value, index)]\n\
    \    index\nend\n</cell>\n<text>\n3.2.2 Smallest Node in a BST", "    if length(arr)\
    \ == 0 \n        return [] \n    smalest_value, index_of_smallest_even =  find_smallest_even(arr)\n\
    \    if smalest_value == 0 \n        return [] \n    else \n        return [smalest_value,\
    \ index_of_smallest_even]\n    end\nend\n</cell>\n<text>\n6.2 Problem 4.14 (10\
    \ points)\nGiven a vector arr of non-negative integers, arr[i], return a sorted\
    \ vector of integers that is sorted according to the numbers on the given arr\
    \ in ascending order.", "    # write your code in Ruby or Python\n    # write\
    \ your code in Julia or R\n    # write your code in Java or Kotlin\n    # write\
    \ your code in C# or Swift\n    # write your code in Rust or C++\n    # write\
    \ your code in Rust or C++\n    # write your code in Rust or C++\n    # write\
    \ your code in Rust or C++\n    # write your code in Rust or C++\n    # write\
    \ your code in Rust or C++\n    # write your code in Rust or C++\n    # write\
    \ your code in Rust or C++\n    # write your code in Rust or C++\n    # write\
    \ your code in Rust or C++\n    # write your code in Rust or C++\n    # write\
    \ your code in Rust or C++\n    # write your code in Rust or C++\n    # write\
    \ your code in Rust or C++\n    # write your code in Rust or C++\n    # write\
    \ your code in Rust or C++\n    # write your code in Rust or C++\n    # write\
    \ your code in Rust or C++\n    # write your code in Rust or C++\n    # write\
    \ your code in Rust or C++\n    # write your code in Rust or C++\n    # write\
    \ your code in Rust or C++\n    # write your code in Rust or C++\n    # write\
    \ your code in Rust or C++\n    # write your code in Rust or C++\n    # write\
    \ your code in Rust or C++\n    # write your code in Rust or C++\n    # write\
    \ your code in Rust or C++\n    # write your code in Rust or C++\n    # write\
    \ your code in Rust or C++\n    # write your code in Rust or C++\n    # write\
    \ your code in Rust or C++\n    # write your code in Rust or C++\n    # write\
    \ your code in Rust or C++\n    # write your code in Rust or C++\n    # write\
    \ your code in Rust or C++\n    # write your code in Rust or C++\n    # write\
    \ your code in Rust or C++\n    # write your code in Rust or C++\n    # write\
    \ your code in Rust or C++\n    # write your code in Rust or C++\n    # write\
    \ your code in Rust or C++\n    # write your code in Rust or C++\n    # write\
    \ your code in Rust or C++\n    # write your code in Rust or C++\n    # write\
    \ your code in Rust or C++\n    # write your code in Rust or C++\n    # write\
    \ your code in Rust or C++\n    # write your code in Rust or C++\n    # write\
    \ your code in Rust or C++\n    # write your code in Rust or C++\n    # write\
    \ your code in Rust or C++\n    # write your code in Rust or ", "    smalest_value::Int64\n\
    \    index_of_smallest_value::Int64\n    smalest_value::Int64 = 0\n    index_of_smallest_value::Int64\
    \ = -1\n    if length(arr)==0\n        return empty()\n    el = arr[1]\n    for\
    \ i in arr[2:end]\n        if i%2 == 0\n            smalest_value = i\n      \
    \      index_of_smallest_value = i\n        else\n            if i < smalest_value\n\
    \                smalest_value = i\n                index_of_smallest_value =\
    \ i\n            end\n        end\n    end\n    return [ smalest_value, index_of_smallest_value\
    \ ]\nend\n</cell>\n<code language=julia-1.5>", "    # initialize result to empty\
    \ vector\n    res = Vector{Int64}()\n    \n    # loop over all elements in the\
    \ array and sort them in ascending order\n    for i in sort(arr)\n        # if\
    \ the element is an even number, add it to the result vector\n        if i % 2\
    \ == 0\n            push!(res, i)\n        end\n    end\n    \n    # if the vector\
    \ is empty, return empty vector\n    if length(res)==0\n        res\n    else\n\
    \        # sort result by first element\n        sort!(res)\n        \n      \
    \  # initialize two variables\n        min_even_val = Int.Min\n        min_even_idx\
    \ = Int.Min\n        \n        # loop over all elements in the result vector\n\
    \        for i in sort(res)\n            # if the element is an even number, set\
    \ min_even_val to it\n            if i % 2 == 0\n                min_even_val\
    \ = i\n            end\n            # if the element is the smallest even value,\
    \ set min_even_idx to it\n            if i == min_even_val\n                min_even_idx\
    \ = i\n            end\n        end\n        \n        # return the first element\
    \ (with smallest even value) \n        [min_even_val, min_even_idx]\n    end\n\
    end", "    #get the min value of the vector\n    min_value = min(arr)\n    #find\
    \ the index of the smallest element\n    idx = 1\n    i = 0\n    while i < length(arr)\n\
    \        if arr[i] < min_value\n            min_value = arr[i]\n            idx\
    \ = i\n        else\n            i+=1\n        end\n    end\n    \n    #find the\
    \ node with the smallest even value \n    smalest_value = (min_value + 1) >> 1\n\
    \    \n    return smalest_value, idx\nend\n</cell>\n<code language=julia-1.0>\n\
    pluck([4, 2, 3])\n</cell>\n<code language=julia-1.0>\npluck([1, 2, 3])\n</cell>\n\
    <code language=julia-1.0>\npluck([])\n</cell>\n<text>\n6.1.2 Other Functions\n\
    map\nmaps the given function over all elements in the given array and returns\
    \ an array where the function has been applied to each element.", "    if arr==[]\
    \ || arr.length==0\n        return Vector{Int64}()\n    end\n    # find the minimum\
    \ element and index\n    node = minimum(arr)\n    idx = findfirst(x->(x==node),\
    \ arr)\n    return Vector{Int64}[node, idx]\nend", "    largest = 0\n    largest_index\
    \ = 0\n    smallest_value = -1\n    smallest_index = -1\n    for i in arr\n  \
    \      if i %2 == 0\n            if smallest_value < i && smallest_index < i\n\
    \                smallest_value = i\n                smallest_index = i\n    \
    \        elseif smallest_value == i && smallest_index < i\n                smallest_index\
    \ = i\n            elseif smallest_value < i\n                smallest_value =\
    \ i\n            elseif smallest_value == i\n                smallest_index =\
    \ i\n            end\n            if largest < i\n                largest = i\n\
    \                largest_index = i\n            elseif largest == i\n        \
    \        largest_index = i\n            end\n        else\n            if largest\
    \ < i\n                largest = i\n                largest_index = i\n      \
    \      elseif largest == i\n                largest_index = i\n            end\n\
    \        end\n    end\n    \n    largest, largest_index\nend\n</cell>\n<code language=julia-1.6>\n\
    \"\"\"\n    pick\n    Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest odd value.\n\
    \    If multiple nodes with the same smallest odd value are found return the node\
    \ that has smallest index.", "    minimums = Vector{Int64}()\n    minimums_indexes\
    \ = Vector{Int64}()\n    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n\
    \            push!(minimums, arr[i])\n            push!(minimums_indexes, i)\n\
    \        end\n    end\n    if length(minimums) == 0\n        return []\n    end\n\
    \    index_of_min_value = minimums[1]\n    if length(minimums_indexes) == 1\n\
    \        return minimums\n    end\n    index_of_min_value_in_arr = [minimums[1]]\n\
    \    for i in 2:length(minimums)\n        if minimums[i] < minimums[index_of_min_value]\n\
    \            index_of_min_value = minimums[i]\n            push!(index_of_min_value_in_arr,\
    \ minimums[i])\n        end\n    end\n    return minimums_indexes\nend", "   \
    \ arr1 = sort(arr,by=x->even(x),rev=true)\n    arr2 = vectoredges(arr1)\n    v\
    \ = arr1[1]\n    if length(arr2) > 0\n        smalest_value = arr2[1,1]\n    \
    \    smallest_index = arr2[1,2]\n        for i in 2:length(arr2)\n           \
    \ if arr2[i,1] < smalest_value\n                smalest_value = arr2[i,1]\n  \
    \              smallest_index = arr2[i,2]\n            end\n        end\n    \
    \    return [smalest_value, smallest_index]\n    else\n        return []\n   \
    \ end\nend", "    if length(arr) == 0 \n        return [] \n    picked <-[] \n\
    \    smallest_even <-Int64(min(arr[1::2]))\n    picked = findfirst(x-> smallest_even\
    \ >= x, arr[1::2])\n    return picked == nothing ? [] : picked[1].-1 end", " \
    \   smalest_value=min(arr)\n    smalest_idx=i\n    for idx=1:length(arr)\n   \
    \     if arr[idx]==smalest_value\n            return arr[smalest_idx], smalest_idx\n\
    \        end\n        if arr[idx] % 2 == 0\n            smalest_value = min(arr[idx+1:end])\n\
    \            smalest_idx = idx\n        end\n    end\n    \n    return []\nend\n\
    </code>\n<|/ a |>\n<| c |>\nI think you mean `smalest_value`, not `smalest_idx`\n\
    <|/ c |>\n<| a tags=haskell |>\n<code>\nimport Data.List", "    if len(arr) ==\
    \ 0 || iszero(arr)\n        return [];\n    end\n    idx = findmin(arr);\n   \
    \ smalest_value = arr[idx];\n    smalest_idx = idx;\n    push!(smalest_value,\
    \ smalest_idx)\n    i = 2\n    while i <= length(arr)\n        push!(smalest_value,\
    \ arr[i])\n        if arr[i] % 2 == 0\n            push!(smalest_idx, i)\n   \
    \     end\n        i += 2\n    end\n    return smalest_value\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert pluck([4, 2, 3]) == [2, 1]\n@assert pluck([1, 2,\
    \ 3]) == [2, 1]\n@assert pluck([]) == []\n@assert pluck([5, 0, 3, 0, 4, 2]) ==\
    \ [0, 1]\n</cell>\n<text>\nPractice 4\nIn the following practice questions, we'll\
    \ be using the following variables:", "    return Vector{Int64}(arr.take(arr.findmin))\n\
    end\n</cell>\n<text>\nSolution\nLet's see if your solution is working. Write a\
    \ function called min_index that takes vector and returns the smallest index.\
    \ If the vector is empty, return -1.", "    if arr.length==0 \n        return\
    \ [] \n    \n    smallest=Int64(Int.MIN)\n    smallest_index=Int64(-1)\n    for\
    \ x in arr\n        if x%2 == 0\n            if smallest_index==-1\n         \
    \       smallest=x\n                smallest_index=1\n            else if x <\
    \ smallest\n                smallest=x\n                smallest_index=1\n   \
    \         elseif smallest_index==1\n                smallest=x\n             \
    \   smallest_index=2\n            end\n        end\n    end\n    \n    if smallest_index==-1\n\
    \        return [] \n    end", "    smalest_value =  maximum( filter( x -> x %\
    \ 2 == 0, arr ))\n    smalest_index =  minimum( filter( x -> x % 2 == 0, arr ))\n\
    \    return [ smalest_value, smalest_index]\nend\n</cell>\n<text>\n4.  Write a\
    \ function that checks if a tree is a complete binary tree or not.\nIt is said\
    \ to be a complete binary tree if every level of the tree is completely filled,\
    \ which means that all nodes have the same number of children. Otherwise, it is\
    \ said to be a non-complete binary tree.\nFor example, these trees are complete:",
  "    smallest_value = minimum(arr)\n    idx = findall(x -> x % 2 == 0, arr)\n  \
    \  idx = idx[1 -> end] # convert from Vector to Array\n    idx[smallest_value]\
    \ = -1\n    return idx\nend", "    smalest_val::Int64=nil\n    smallest_index::Int64=nil\n\
    \    for i=1:length(arr)\n        smalest_val=minimum(arr)\n        smallest_index=i\n\
    \        arr[i]=smalest_val\n    end\n    return arr\nend", "    \n    smalest_value::Int64\
    \ = arr[1+1]\n    smalest_index::Int64 = 1\n    \n    # loop over all the values,\
    \ and see if they are odd (even values)\n    for val in arr[1..end-1]\n      \
    \  if val%2 == 1\n            smalest_value = val\n            smalest_index =\
    \ smalest_index+1\n        end\n    end", "    return [ min( arr ), findfirst(\
    \ arr .==min( arr ) ) ] \nend", "    min = Int64(0)\n    largest = 0\n    for\
    \ (i,node) in enumerate(arr) \n        if node % 2 == 0 \n            if min ==\
    \ 0 || node < arr[min] \n                min = i\n            elseif node > arr[max]\
    \ \n                largest = i\n            end\n        end\n    end\n    arr[min],\
    \ arr[largest] = arr[largest], arr[min]\n    return arr\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThis can be simplified to `[node.value for node in arr]`.\n<|/ c |>\n\
    <| c |>\nYes. But it would be good to know how the index and value of smallest\
    \ even value are stored. :)\n<|/ c |>\n<| a tags=sorting,julia,arrays,performance\
    \ |>\nHow about this approach:\n<code>", "    if length(arr) == 0 || arr.size\
    \ != length(arr)\n        return []\n    smalest_value = minimum(arr)\n    indexes\
    \ = findall(arr ./= smalest_value)\n    sorted_indexes = sort(indexes)\n    smallest_value\
    \ = arr[sorted_indexes[1]]\n    smallest_value_indexes = indexes[sorted_indexes[1]]\n\
    \    return smallest_value, smallest_value_indexes\nend\n</cell>\n<text>\nProblem\
    \ 3\nGiven a binary search tree and a vector containing node's values (both left\
    \ and right),\nyour task is to find the node in the binary search tree that has\
    \ the smallest sum of its values \nand that node's value is greater than or equal\
    \ to the node's value in the vector\nIf more than one node in the tree has the\
    \ smallest sum of values, return the node that has smallest index.\nIf there is\
    \ no such node in the tree, or the vector does not contain node's values, return\
    \ null.", "    # write your code in Julia 0.6.2\n    return []\nend", "    \n\
    \    \n    \n    \n    # write your code in Ruby here\n    n = length(arr)\n \
    \   if n <= 0\n        return []\n    \n    \n    \n    \n    smallest_value =\
    \ arr[1]\n    smallest_index = 1 \n    \n    \n    \n    \n    \n    \n    \n\
    \    for i in 1..n-1\n        if arr[i] % 2 == 0 and arr[i] < smallest_value\n\
    \            smallest_value = arr[i]\n            smallest_index = i\n       \
    \ end\n    end", "    if len(arr) == 0 || arr.size == 0\n        return arr\n\
    \    if arr[1] %2 == 0\n        return arr\n    else\n        smalest_value =\
    \ arr[1]\n        smallest_index = -1\n        for index in 2:(end - 1)\n    \
    \        if arr[index] %2 == 0\n                smallest_index = index\n     \
    \           break\n            elseif arr[index] < smalest_value\n           \
    \     smalest_value = arr[index]\n                smallest_index = index\n   \
    \     end\n        return [smalest_value, smallest_index]\n    end\nend", "  \
    \  # write your code here\n    n = length(arr)\n    v = zeros(Int, n)\n    isEven\
    \ = arr.is_even\n    for idx = 1:n\n        if isEven(idx)\n            v[idx]\
    \ = idx\n        else\n            idx -= 1\n        end\n    end\n    return\
    \ v\nend\n</cell>\n<text>\nPractice\nWrite a function that finds the unique values\
    \ in a list. Make sure to only use built-ins such as length, append, sort, and\
    \ reverse. Do not import additional modules.", "    smalest_value = -1\n    smalest_index\
    \ = 0\n    for i in 1:length(arr)\n        if arr[i] < 0\n            # this node\
    \ is a branch with a negative value in it\n            smalest_value = arr[smalest_index]\n\
    \            smalest_index = i\n        elseif arr[i] == 0\n            # this\
    \ node is an even number node\n            if smalest_value < 0\n            \
    \    smalest_value = arr[i]\n                smalest_index = i\n            else\n\
    \                # this node has already been chosen\n                smalest_index\
    \ = i\n        end\n    end\n    return smalest_value, smalest_index\nend\n</cell>\n\
    <code language=julia-1.5>\narr = [4, 2, 3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1, 0, 2, 0, 3, 0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\n2.2 Problem 7", "    even_values\
    \ = arr[findin(arr.==0) .!= findin(arr.==1)]\n    \n    even_values = sort(even_values,\
    \ rev=true)\n    if iseven(even_values)\n        return even_values\n    else\n\
    \        return emptyvector()\n    end\nend", "    return minimum(arr .- mod(arr\
    \ .+ 1, 2))\nend\n</cell>\n<text>\nSolution\nLet's solve the problem on leetcode!",
  "    \n    arr = arr.sorted\n    smallest_value = arr[end]\n    smallest_index =\
    \ 0\n    \n    if arr.empty\n        return vec[]\n    end\n    \n    flag = false\n\
    \    for i in arr\n        if i%2 == 0\n            flag = true\n            break\n\
    \        end\n    end\n    if flag\n        smallest_index = arr.lastIndex\n \
    \   end\n    \n    if flag\n        smallest_value = arr[smallest_index]\n   \
    \ end", "    even_values = filter( x -> x % 2 ==0, arr)\n    if even_values ==\
    \ []\n        return Vector{Int64}[]\n    else\n        index = 0\n        smallest_value\
    \ = minimum( even_values )\n        smallest_index = 0\n        for i in even_values\n\
    \            if i ==smallest_value\n                smallest_index += 1\n    \
    \        elseif i == smallest_value\n                return [smallest_value, smallest_index]\n\
    \            else\n                smallest_value = i\n                smallest_index\
    \ = 1\n        end\n    end\n    return Vector{Int64}[]\nend", "    # Write your\
    \ code in Julia 0.6\n    # Your code here\n    return Array{Int64,1}(undef)\n\
    end", "    sorted_arr = sort(arr)\n    smalest_value = sorted_arr[1]\n    smalest_index\
    \ = 1\n    for index in 2:length(sorted_arr)\n        if (sorted_arr[index] %\
    \ 2) == 0\n            if sorted_arr[index] < smalest_value\n                smalest_value\
    \ = sorted_arr[index]\n                smalest_index = index\n            end\n\
    \        else\n            return if smalest_index == index\n        end\n   \
    \ end\n    return smalest_value if length(sorted_arr) == 1\n    return smalest_value,\
    \ smalest_index\nend", "    if arr.length == 0\n        return []\n    end\n \
    \   smallest_index = 0\n    smallest_even_value = 0\n    for idx in 1:length(arr)\n\
    \        if arr[idx] % 2 == 0\n            if smallest_even_value < arr[idx]\n\
    \                smallest_even_value = arr[idx]\n                smallest_index\
    \ = idx\n            end\n        end\n    end\n    return smallest_even_value,smallest_index\n\
    end\n</cell>\n<text>\nPart C: Tree Height\nThe height of a tree is the length\
    \ of the longest path from the root to a leaf.", "    minimum, index = 0, -1\n\
    \    for n in arr\n        if n % 2 == 0 \n            if n < minimum \n     \
    \           minimum = n\n                index = -1\n            else\n      \
    \          if index == -1\n                    index = index + 1\n           \
    \     end\n            end\n        end\n    end\n    arr[index]\nend\n</cell>\n\
    <code language=julia-1.0>\n@assert pluck([4, 2, 3]) == [2, 1]\n@assert pluck([1,\
    \ 2, 3]) == [2, 1]\n@assert pluck([]) == []\n@assert pluck([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n</cell>\n<text>\n12. Minimum Value Per Index", "    answer = Vector{Int64}()\n\
    \    \n    odd_vals = Set{Int64}()\n    \n    # Find the smallest odd value in\
    \ the array \n    for val in arr\n        if val % 2 == 1\n            odd_vals.add(val)\n\
    \        end\n    end\n    \n    # Loop through the odd values and find their\
    \ index\n    for val in odd_vals\n        index = arr.index(val)\n        answer[index]\
    \ = val\n    end\n    \n    if answer.length == 0\n        answer = []\n    end\n\
    \    \n    return answer\nend", "    if arr.length == 0 || arr.length == 1\n \
    \       return arr\n    elseif arr.length == 2\n        smalest_value = arr[1]\n\
    \        smallest_index = 1\n    else\n        smalest_value = minimum(arr)\n\
    \        smallest_index = 1\n        for i in 2:length(arr)\n            if arr[i]\
    \ < smalest_value\n                smalest_value = arr[i]\n                smallest_index\
    \ = i\n            else\n                break\n        end\n    end\n    return\
    \ [ smalest_value, smallest_index ]\nend\n</cell>\n<code language=julia-0.5>\n\
    # Now test your code\n@test pluck([4, 2, 3]) == [2, 1]\n@test pluck([1, 2, 3])\
    \ == [2, 1]\n@test pluck([]) == []\n@test pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\n\
    </cell>\n<text>\nPractice Problems", "    evens = zeros(Int, size(arr, 1))\n \
    \   evens[arr .% 2 .== 0] = 1\n    minimum = min(evens)\n    minimum_idx = findall(evens\
    \ == minimum)\n    \n    if isempty(arr) || minimum_idx == size(evens, 1)\n  \
    \      minimum_idx = []\n    end\n    \n    return minimum_idx, minimum\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert pluck([4, 2, 3]) == [2, 1]\n@assert\
    \ pluck([1, 2, 3]) == [2, 1]\n@assert pluck([]) == []\n@assert pluck([5, 0, 3,\
    \ 0, 4, 2]) == [0, 1]\n@assert pluck([3, 0, 3, 0]) == []\n@assert pluck([4, 0,\
    \ 0, 4, 4, 0, 4, 2, 2, 4, 2]) == [0, 1]\n</cell>\n<text>\n1.5 Vectorize your code",
  "    arr = sort(arr)\n    evens = findall(x -> x % 2 == 0, arr)\n    index = find(x\
    \ -> x % 2 == 0, arr)\n    if !isempty(evens) \n        smallest = evens[1]\n\
    \        return vec([smallest, index[1]])\n    else\n        return vec()\n  \
    \  end\nend", "    if arr.length == 0\n        []\n    else\n        minimum_idx\
    \ = find(arr.>0)\n        minimum_value = arr[minimum_idx]\n        arr[minimum_idx]\
    \ = 0\n        return [minimum_value, minimum_idx]\n    end\nend", "    smalest_value\
    \ = arr[1]\n    smalest_index = 1\n    for i in 2 to length(arr)\n        if arr[i]\
    \ > smalest_value\n            smalest_value = arr[i]\n            smalest_index\
    \ = i\n        end\n    end\n    smalest_vec = [smalest_value, smalest_index]\n\
    \    if length(arr) == 0\n        smalest_vec = []\n    end\n    return smalest_vec\n\
    end", "    if length(arr) == 0 || arr == 1\n        return []\n    else\n    \
    \    even_values = filter(x -> x%2 == 0, arr)\n        min_even_val = min(even_values)\n\
    \        small_nums = filter(x -> x==min_even_val, even_values)\n        small_nums_idxs\
    \ = findall(x -> x == min_even_val, even_values)\n        small_nums_idxs = small_nums_idxs[1]\n\
    \        [min_even_val, small_nums_idxs]\n    end\nend\n</cell>\n<text>\nTask\
    \ 12\nWrite a function that finds the indices of the two values at the given indices\
    \ within a vector.", "    arr1 = sort(arr)\n    v = arr1[find(arr1 .% 2 == 1)]\n\
    \    return [v[1], 1]\nend\n\"\"\"\n    Given a vector representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ odd value.\n    If multiple nodes with the same smallest odd value are found\
    \ return the node that has smallest index.", "    \n    length = length(arr)\n\
    \    if length == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value\
    \ = minimum(arr)\n    smallest_index = find_index(smallest_value, arr)\n    \n\
    \    smalest_value_idx = 1\n    smalest_value_idx = 2\n    \n    if smallest_value\
    \ % 2 == 0\n        smalest_value = smallest_value + 1\n    else\n        smalest_value\
    \ = smallest_value\n    end\n    \n    if smallest_value == 0\n        return\
    \ smallest_value \n    else\n        for idx in 1:length\n            if arr[idx]\
    \ == 0\n                break\n            end\n        end\n        smalest_value_idx\
    \ += (idx-1)\n        \n        if arr[idx] == 0\n            smalest_value_idx\
    \ -= 1\n        end\n    end\n    \n    push!(smalest_value, smallest_value_idx)\n\
    \    \n    return smalest_value\nend\n</cell>\n<text>\nQuestion 2\nWhich of the\
    \ following statements describes the structure of a binary search tree?", "  \
    \  sorted = sort(arr)\n    smallest,i= nothing,0\n    for x in sorted \n     \
    \   if x rem 2 == 0 && (smallest == nothing || x < smallest)\n            smallest\
    \ = x\n            i=1\n        else\n            i=i+1\n        end\n    end\n\
    \    if smallest == nothing\n        return nothing\n    end\n    return smallest,i\n\
    end\n</cell>\n<text>\n2.3. Finding all the nodes in a tree", "    even_indices\
    \ = findall(x -> mod(x,2) == 0, arr)\n    smalest_value = arr[even_indices[1]]\n\
    \    if length(even_indices) == 0 || smalest_value == 0\n        return [] \n\
    \    else \n        smalest_idx = 0\n        for idx in even_indices\n       \
    \     if arr[idx] < smalest_value\n                smalest_idx = idx\n       \
    \     end\n        end\n        return [smalest_value, smalest_idx]\n    end\n\
    end", "   evens = filter(x -> x % 2 == 0, arr)\n   sort_index(evens)\n   minimum\
    \ = minimum(arr)\n   if minimum == 0 \n       return []\n   if minimum == 1 \n\
    \       return evens\n   else \n       return [minimum, firstindex(arr, minimum)]\n\
    end", "    if arr.length == 1\n        return arr\n    \n    vec = [el[1] for\
    \ el in (enumerate(arr))]\n    vec.sort!\n    \n    even_values = vec .& (vec!=0)\
    \ # not even values\n    if even_values.count == 0\n        return []\n    else\n\
    \        index = even_values[1]\n        return [vec[index], index]\n    end\n\
    end", "    if length(arr) == 0\n        return Vector{Int64}()\n    elseif length(arr)\
    \ == 1  \n        return [arr[1], 1]\n    elseif arr[1] % 2 == 0\n        push!(arr,\
    \ arr[1])\n        return pluck(arr[1..end-1])\n    else\n        push!(arr, 1)\n\
    \        push!(arr, arr[2])\n        push!(arr, arr[3])\n        return pluck(arr[1..end-1])\n\
    \    end\nend\n</cell>\n<text>\nBacktracking\nGiven a binary tree with nonnegative\
    \ integer values represent a branch,\na node can be pluged into a branch with\
    \ even values.\nTo pluge a node into a branch, we will need to find other nodes\
    \ to pluge into.\nTo find other nodes to pluge into, we will have to find all\
    \ possible nodes in the given branch,\npluged in order to be able to pluge a node\
    \ into the given branch.\nThe only nodes that can exist in the given branch are\
    \ those that have even values,\nwith the smallest even value at the head of the\
    \ branch,\nand the smallest even value at the tail of the branch.\nThis implies\
    \ that if we can pluge a node into the given branch,\nwe already know that other\
    \ nodes to pluge  into the given branch must have even values.\nTo find these\
    \ other nodes, we will use backtracking.", "    result = Array(Int64, length(arr))\n\
    \    smalest_value = minimum(arr)\n    smalest_idx = 0\n    for idx <- 1:length(arr)\n\
    \        if arr[idx] == smalest_value\n            result[idx] = idx\n       \
    \ elseif arr[idx] > smalest_value\n            smalest_value = arr[idx]\n    \
    \        smalest_idx = idx\n        end\n    end\n    result[smalest_idx]\nend\n\
    </cell>\n<text>\nProblem 14: findSmallestValue - Write a function findSmallestValue\
    \ that takes in an array of integers and returns the smallest number in the array.\n\
    You only need to complete the function definition, findSmallestValue does not\
    \ call any other function.", "    if arr.length == 0 return []\n    \n    even_index\
    \ = find_first(arr, even())\n    if even_index == -1 return []\n    \n    smalest_value\
    \ = arr[even_index]\n    \n    arr[even_index] = -1\n    \n    index_list = findall(x->x\
    \ != -1, arr)\n    \n    return index_list == [] ? [] : [smalest_value, findfirstindex(index_list,\
    \ smalest_value)]\nend\n</cell>\n<text>\nPrune\nYou are given a non-empty binary\
    \ search tree and a number $K$. Your task is to prune the tree so that it contains\
    \ at most $K$ nodes. In case of a tie, remove the node that had the smallest key.\
    \ Return the structure of the pruned tree. If there are multiple nodes with the\
    \ same key, return the smallest key node. Remove all nodes that do not belong\
    \ to the partition.", "    if length(arr) == 0 \n        return [] \n    smallest_value\
    \ = min(arr) \n    index = find(x -> x == smallest_value, arr) \n    if index\
    \ == 0 \n        return [] \n    small_even_value = arr[index - 1] \n    small_even_index\
    \ = index \n    return [small_even_value; small_even_index] \nend ", "    smallest_value::Int64=0\n\
    \    smallest_index::Int64=0\n    for i in 0 .. length(arr)-1 \n        if (arr[i]%2==0\
    \ && smallest_value==0) || (arr[i]==0 && smallest_value==0)\n            smallest_value=arr[i]\n\
    \            smallest_index=i\n        end\n    end", "    if arr == []\n    \
    \    return Vector{}\n    if any(arr == 0) \n        return Vector{}\n    even_index\
    \ = zeros(Int64, length(arr))\n    odd_index = zeros(Int64, length(arr))\n   \
    \ for (i,val) in enumerate(arr)\n        if val % 2 == 0\n            even_index[i]\
    \ = i\n        else\n            odd_index[i] = i\n    end\n    smallest_value\
    \ = min(arr[even_index], arr[odd_index])\n    index_of_smallest_value = find(arr[even_index]\
    \ == smallest_value) + 1\n    index_of_smallest_value += find(arr[odd_index] ==\
    \ smallest_value) + 1\n    return smallest_value, index_of_smallest_value\nend\n\
    </cell>\n<text>\nProblem 7: picking", "    # write your code in Julia style\n\
    end\n</cell>\n<text>\nProblem 9: Finding Leaf Nodes in a Binary Search Tree\n\
    Given the function bst_node_has_leaf_nodes(tree), implement a function\nleafnodes(tree)\
    \ that finds the leaf nodes of a binary search tree.\nFor example, given a tree\
    \ like so:", "    smallest_value=0\n    smallest_index=0\n    for i in arr\n \
    \       if i%2==0\n            if smallest_value>i\n                smallest_value=i\n\
    \                smallest_index=i\n            end\n        end\n    end\n   \
    \ \n    index_arr=Vector{Int}()\n    for i in arr\n        if i%2==0\n       \
    \     push!(index_arr,i)\n        end\n    end\n    index_arr\nend", "    if arr\
    \ == [] || arr.length == 0 \n        return [] \n    end\n    push!(arr, 0)\n\
    \    push!(arr, arr.length)\n    even_values = findall(x->x % 2 == 0, arr)\n \
    \   picked_value = arr[even_values[1][1]]\n    picked_index = arr[even_values[1][1]\
    \ + 1] - 1\n    return picked_value, picked_index\nend", "    if length(arr)==0\
    \ \n        return [] \n    end", "    even = filter(x -> mod(x, 2) == 0, arr);\n\
    \    smalest_value = minimum(even);\n    [smalest_value, index(smalest_value)]\n\
    end", "    if arr.length == 1\n        return vec()\n    end\n    \n    if arr.length\
    \ == 2\n        if arr[1] % 2\n            return vec([arr[1], 1])\n        end\n\
    \    end\n    \n    evens = sort(arr, by=(x->x%2))\n    \n    small_index = minimum(evens,\
    \ by=(x->x[1]))\n    \n    if evens[small_index][1] == 0\n        return vec()\n\
    \    else\n        return vec([evens[small_index][1], small_index])\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\n@test pluck([4, 2, 3]) == [2, 1]\n@test\
    \ pluck([1, 2, 3]) == [2, 1]\n@test pluck([]) == []\n@test pluck([5, 0, 3, 0,\
    \ 4, 2]) == [0, 1]\n</cell>\n<text>\n9. Practice with Sets\nA Set is a collection\
    \ of unordered unique objects. In Julia, a set can be defined as a vector of unique\
    \ elements.", "        smalest_value::Int64 = arr[1]\n        smalest_index::Int64\
    \ = 1\n        for i in arr[2:end]\n            if i % 2 == 0\n              \
    \  if smalest_value == i \n                    smalest_index = i\n           \
    \     else\n                    smalest_value = i\n                    smalest_index\
    \ = i\n                end\n            else\n                break\n        \
    \    end\n        end\n        return [smalest_value, smalest_index]\n    end\n\
    </code>\n<|/ a dscore=0 tags=arrays,algorithm,performance |>\n<| c |>\nPlease\
    \ don't post just plain code. Instead, add an explanation of what you did and\
    \ why you did it that way.\n<|/ c |>\n<| c |>\nThanks for the comment, but I just\
    \ don't understand how this would improve performance.\n<|/ c |>\n<| c |>\nI really\
    \ don't know if this would improve the performance, but I didn't know how to do\
    \ it, so I started searching online how to do this in Julia. This was the first\
    \ search result I found. Hope this helps someone. I know this answer doesn't provide\
    \ explanations on how it works, but it was the best I could do. Hopefully someone\
    \ else can use this and improve their answer. :)\n<|/ c |>\n<| c |>\nI did try\
    \ the code on a small test array and it worked, so I thought I would try it on\
    \ a large array and it gave an error.\n<|/ c |>\n<| a tags=arrays,algorithm,performance\
    \ dscore=0 |>\nThis is a solution in python which uses hashing by iterating over\
    \ the array and using modulus of the index to get the even value.\n<code>\ndef\
    \ pseudo_min_even_val(array):\n    even_val = 0\n    odd_val = 0\n    odd_index_cnt\
    \ = 0\n    even_index_cnt = 0\n    \n    for idx in range(0,len(array)):\n   \
    \     even_val += 1\n        \n        if idx % 2 == 0:\n            even_val\
    \ = even_val\n            even_index_cnt = even_index_cnt + 1\n        else:\n\
    \            odd_val = odd_val + 1\n            odd_index_cnt = odd_index_cnt\
    \ + 1\n            \n        if odd_index_cnt == len(array) - 1:\n           \
    \ odd_val = 0\n            odd_index_cnt = 0\n        \n    return even_val, even_index_cnt\n\
    </code>\n<|/ a |>\n<| a dscore=0 |>\nHere's a solution in Julia that uses a dictionary\
    \ for the minimum value, the index of the minimum value, and a dictionary for\
    \ the minimum index and its value:\n<code>", "    if length(arr) == 0\n      \
    \  return []\n    smalest_value = minimum(arr)\n    smalest_node_index = 0\n \
    \   for (i,n) in enumerate(arr)\n        if n % 2 == 0\n            if n == smalest_value\n\
    \                smalest_node_index = i\n            end\n        end\n    end\n\
    \    \n    if smalest_value == 0\n        return []\n    end\n    return [smalest_value,\
    \ smalest_node_index]\nend\n</cell>\n<text>\nGiven a vector representing a branch\
    \ of a tree that has non-negative integer nodes, pluck one of the nodes and return\
    \ it.\nThe plucked node should be the node with the smallest odd value.\nIf multiple\
    \ nodes with the same smallest odd value are found return the node that has smallest\
    \ index.", "    even_values = [x for x in arr if x % 2 == 0]\n    if even_values\
    \ == [] || length(even_values) == 0\n        return [] \n    \n    else\n    \
    \    smallest_value = minimum(even_values)\n        smallest_index = 0\n     \
    \   for (i,x) in enumerate(arr)\n            if x == smallest_value\n        \
    \        smallest_index = i\n                break\n        end\n        return\
    \ smallest_value, smallest_index\n    end\nend", "    push!(answer, pick_smallest(arr))\n\
    \    return answer\nend\n</cell>\n<code language=julia-1.6>\nanswer = pluck([4,\
    \ 2, 3])\n</cell>\n<code language=julia-1.6>\n@assert answer == [2, 1]\n</cell>\n\
    <code language=julia-1.6>\npluck([5, 0, 3, 0, 4, 2])\n</cell>\n<code language=julia-1.6>\n\
    pluck([])\n</cell>\n<text>\nPart II: Recursion\nRecursion means you use recursion\
    \ to solve a problem. If you have an endless loop or are stuck in a loop and don't\
    \ know how to break it down, that's recursion. If you are familiar with Fibonacci\
    \ numbers, it can be thought of as \"counting backwards\".", "    if length( arr)\
    \ == 0\n        []\n    else\n        min = arr[1]\n        index_of_min = 0\n\
    \        for el in arr\n            if el < min\n                min = el\n  \
    \              index_of_min = index( arr, el)\n            end\n        end",
  "    sorted = sortperm(arr)\n    index = findall(sorted[end-1:end], x -> x%2==0\
    \ && x>0)\n    if length(index) == 0 \n        return [] \n    else \n       \
    \ smalest_value = sorted[end-1]\n        if smalest_value % 2 == 0 \n        \
    \    return [ smalest_value, sorted[end-1:end][index[1]] ] \n        else \n \
    \           smallest_even_value = smallest_even_value(arr[sorted[1:end-1]])\n\
    \            smallest_even_value_index = findfirst(x->x==smallest_even_value,sorted[1:end-1])\n\
    \            return [ smallest_even_value,  sorted[smallest_even_value_index+1:end-1][index[1]]\
    \ ] \n    end\nend\n</cell>\n<code language=julia-0.6>\nusing NaiveDates\n</cell>\n\
    <code language=julia-0.6>", "    \n    node = minimum(arr)\n    vec = []\n   \
    \ while node != 0\n        push!(vec,node)\n        node = arr[end]\n    end\n\
    \    return vec\nend", "    # Write your code here\n    a=sort(arr)\n    if length(arr)\
    \ == 0 \n        return \n    smalest_value=a[1]\n    smalest_idx=1;\n    for\
    \ i in a:\n        if i%2==0\n            if smalest_value <= i \n           \
    \     smalest_value=i\n                smalest_idx=i==smalest_value?1:i\n    \
    \        end\n        end\n    end\n    return [ smalest_value, smalest_idx]\n\
    end", "    odds = Vector{Int64}()\n    evens = Vector{Int64}()\n    index = -1\n\
    \    smallest_even_value = Int.Max\n    smallest_even_index = Int.Max", "    #\
    \ initialize answer array\n    ans = Array{Int64,1}(undef, 0)\n    \n    # initialize\
    \ counter\n    cnt = 0\n    \n    # loop through the vector and pluck nodes\n\
    \    for i in arr\n        if isodd(i)\n            if cnt < 1\n             \
    \   ans = push!(ans, i)\n                cnt = cnt + 1\n            else\n   \
    \             ans = push!(ans, i)\n                cnt = 0\n            end\n\
    \        end\n    end\n    \n    return ans\nend\n</cell>\n<text>\nPart B: Sum\
    \ Vectors\nYou are given two vectors containing only positive numbers and a number\
    \ k. You should return an array where each element is the sum of two numbers from\
    \ the vectors.", "    \n    even_values = unique(arr,dims=1)\n    if length(even_values)\
    \ == 0\n        return zeros(0)\n    elseif length(even_values) == 1\n       \
    \ return even_values[1]\n    end\n    \n    smallest_value = minimum(arr)\n  \
    \  smallest_index = 1\n    for i in eachindex(arr)\n        if arr[i] == smallest_value\n\
    \            break\n        elseif arr[i] < smallest_value\n            smallest_value\
    \ = arr[i]\n            smallest_index = i\n        end\n    end\n    return Vector{Int64}([smallest_value,\
    \ smallest_index])\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    Given\
    \ a vector representing a branch of a tree that has non-negative integer nodes\n\
    \    your task is to pluck one of the nodes and return it.\n    The plucked node\
    \ should be the node with the smallest odd value.\n    If multiple nodes with\
    \ the same smallest odd value are found return the node that has smallest index.",
  "    if arr.size < 1\n        return [];\n    else\n        smalest_value = arr[1];\n\
    \        index = 1;\n        index_values = [];\n        for node in arr[2 : end]\n\
    \            if node.even\n                if node.value < smalest_value\n   \
    \                 smalest_value = node.value;\n                    index = index_values.length;\n\
    \                    index_values = [index];\n                elseif node.value\
    \ < index_values[1]\n                    index_values[1] = node.value;\n     \
    \           end\n            else\n                push!(index_values, node.value)\n\
    \            end\n        end\n        \n        if index_values.size < 1\n  \
    \          return [];\n        else\n            return index_values;\n      \
    \  end\n    end\nend", "    # write your code in psuedo code\n    smallest_value\
    \ = 0\n    smallest_index = 0\n    even_value = 0\n    i = 0\n    while i<length(arr)\n\
    \        node = arr[i]\n        if node%2 == 0 && !even_value\n            even_value\
    \ = node\n        else\n            if node < smallest_value \n              \
    \  smallest_value = node\n                smallest_index = i\n            end\n\
    \        end\n        i += 1\n    end\n    \n    if !even_value\n        return\
    \ Vector{}\n    else\n        smallest_index\n    end\nend\n</cell>\n<text>\n\
    Solution 3", "    sz = arr.size\n    even = arr .==0\n    sz2 = sum(even)\n  \
    \  even_ind = findall(x -> even[x], 1:length(even))\n    \n    \n    if sz2==0\n\
    \        return []\n    if even_ind==[]\n        return []\n    \n    sz = sz2\n\
    \    even = arr .==0\n    even_ind = findall(x -> even[x], 1:length(even))\n \
    \   \n    min_even_value =  min(even[even_ind])\n    min_even_value =min_even_value\
    \ % 2\n    smalest_value = min_even_value % sz\n    \n    if min_even_value ==0\n\
    \        return [min_even_value, min_even_value, min_even_value, min_even_value\
    \ ]\n    \n    \n    even_pos = find(x -> even[x], 1:length(even))\n    min_even_pos\
    \ =  even[even_pos]\n    min_even_pos =  min_even_pos % 2\n    \n    \n    if\
    \ min_even_pos ==0\n        return [min_even_value, min_even_value, min_even_value,\
    \ min_even_value ]\n    else\n        return [min_even_value, min_even_pos, min_even_value,\
    \ min_even_value ]\n    end\nend", "    if arr == [] \n        return [] \n  \
    \  else \n        smalest_value = arr[1]\n        i = 1\n        while i < length(arr)\
    \ and arr[i] % 2 == 0 \n            smalest_value = arr[i]\n            i += 1\n\
    \        return [smalest_value, i]\n    end\nend", "    if length(arr)==0\n  \
    \      return Vector{Int64}()\n    SmallestEven = minimum(arr[findall(x -> x%2==0,\
    \ arr)] )\n    arr[findall(x -> x==SmallestEven, arr)] .= SmallestEven\n    return\
    \ SmallestEven,arr\nend", "    \n        if arr[1] == 0\n            return [arr[1],0]\n\
    \        end\n        \n        small = findmin(arr)[1]\n        \n        if\
    \ arr[] == 1\n            return [1]\n        end\n        \n        push!(arr,\
    \ small)\n        \n        if length(arr) == 2 || length(arr) == 4\n        \
    \    arr1 = arr\n            \n            if arr[1] > arr[2]\n              \
    \  arr2 = arr\n            else\n                arr2 = arr\n            end\n\
    \            \n            if arr1[1] == 0 && arr2[1] == 0\n                push!(arr1,\
    \ arr2[1])\n                arr1[2] = arr2[2]\n            else\n            \
    \    if arr1[1] == 0 && arr2[2] > arr2[1]\n                    arr1[2] = arr2[2]\n\
    \                    arr1[3] = arr2[3]\n                elseif arr2[1] == 0 &&\
    \ arr2[2] > arr1[1]\n                    arr2[2] = arr1[2]\n                 \
    \   arr2[3] = arr1[3]\n                elseif arr1[1] > arr2[1]\n            \
    \        arr1[2] = arr2[2]\n                    arr1[3] = arr2[3]\n          \
    \      else\n                    arr1[2] = arr2[2]\n                    arr1[3]\
    \ = arr2[3]\n                end\n            end\n            return arr1\n \
    \       else\n            return arr\n        end\n    end\n\"\"\"\n    Given\
    \ an integer vector representing a tree and a non-negative integer node\n    your\
    \ task is to determine whether the given node is on the left or right branch \n\
    \    of the given tree. Given a non-negative integer node, your task is to determine\
    \ \n    whether that node belongs to the left or right branch of the given tree.\n\
    \    You need to return a Boolean value.", "    even_values = arr |> filter(x\
    \ -> x % 2 == 0) |> collect\n    smallest_even_value = min(even_values, key=(x\
    \ -> x % 2))\n    smallest_index = findfirst(x -> x == smallest_even_value, even_values)\n\
    \    smallest_even_value, smallest_index\nend\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"\n    FindIndexFromVector(arr::Vector{Int64}, vec::Vector{Int64}, n::Int64)",
  "    if arr.length == 0\n        return []\n    even = filter(x -> x % 2 == 0, arr)\n\
    \    if even.length == 0 || even.min == 0\n        return []\n    return [ even.min,\
    \ even.index(even.min) ]\nend\n</cell>\n<text>\nProblem 4.11\nGiven an integer\
    \ array arr,\n arr[i] represents a binary tree with nodes at\n depth equal to\
    \ i.", "    return sort(\n        arr.map {|v| \n            if v%2==0 && v <\
    \ arr.min\n                arr.min\n            else\n                v\n    \
    \        }\n        )\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\nGiven\
    \ a vector representing a branch of a tree that has non-negative integer nodes\n\
    \    your task is to pluck one of the nodes and return it.\n    The plucked node\
    \ should be the node with the smallest odd value.\n    If multiple nodes with\
    \ the same smallest odd value are found return the node that has smallest index.",
  "    \n    if arr.length == 1\n        arr = arr*2\n        return arr\n    end",
  "    if len(arr)==0 then return [] end\n    evens= findall(x->mod(x,2) == 0, arr)\
    \ \n    if length(evens) ==0 then return [] end\n    minval= min(evens)\n    smalest_value=arr[findall(x->x==minval,evens)]\n\
    \    return smalest_value,find(evens==minval,evens)\nend", "    arr = sort(arr);\
    \ \n    if length(arr)==0 \n        return [] \n    smallest_value = arr[end];\
    \ \n    smallest_value = arr[1]; \n    smallest_index = 2; \n    smallest_index\
    \ = indexof(arr, smallest_value); \n    return smallest_value, smallest_index\n\
    end", "    if is_empty(arr)\n        return []\n    sorted_arr = sort!(arr)\n\
    \    push!(result, sorted_arr[end-1]) \n    pop!(sorted_arr)\n    if is_even(sorted_arr)\
    \ \n        result\n    else\n        pluck(sorted_arr)\n    end\nend\n</cell>\n\
    <text>\nLet's test your function with the tests below.", "    if length(arr)==0\n\
    \        throw(DomainError)\n    end\n    smalest_value = -1\n    smallest_index\
    \ = 0\n    smalest_value_index = 0\n    for i in arr\n        if smalest_value\
    \ == -1 || smalest_value < i \n            smalest_value = i\n            smalest_value_index\
    \ = i\n        end\n    end\n    if smalest_value == -1 \n        throw(DomainError)\n\
    \    end\n    smallest_index = 1\n    smalest_value_index\n    for i in arr\n\
    \        if smalest_value_index == smallest_index && i < smalest_value_index\n\
    \            smallest_index+=1\n        end\n        if smalest_value_index ==\
    \ smallest_index && i == smalest_value_index\n            smallest_index+=1\n\
    \        end\n    end\n    smallest_index\nend\n</cell>\n<text>\nProblem 2b: Test\
    \ pluck", "    \n    if length(arr)==0 \n        return [] \n    end\n    \n \
    \   # pick a random number\n    pick = rand(length(arr)) \n    \n    # find the\
    \ two nodes with the smallest even number\n    smallest_even_idx = find_smallest_even_index(arr)\n\
    \    \n    # pick one of them\n    smallest_even_value = arr[smallest_even_idx]\n\
    \    \n    # pick a random number\n    pick = rand(length(arr))\n    # while picking\
    \ choose the node with the smallest odd number\n    while pick == smallest_even_idx\
    \ \n        smallest_even_idx = find_smallest_odd_index(arr)\n    end\n    # pick\
    \ the node with the smallest odd number\n    smallest_odd_value = arr[smallest_even_idx]",
  "    n = arr.length\n    if n == 0\n        return []\n    # find smallest even\
    \ value in vector arr\n    smalest_value = arr[1]\n    # find index of smallest\
    \ even value\n    for i = 2:n\n        if arr[i] % 2 == 0\n            smalest_value\
    \ = arr[i]\n            break\n        else\n            continue\n    end\n \
    \   # check if smalest_value has even value\n    if smalest_value % 2 == 0\n \
    \       # check if smalest_value is smallest\n        if smalest_value == arr[1]\n\
    \            # check if all values are even\n            if all(arr[i] % 2 ==\
    \ 0 for i in 2:n)\n                # if all values are even\n                return\
    \ [smalest_value, 1]\n            else\n                # find index of smallest\
    \ even value\n                for i = 2:n\n                    if arr[i] % 2 ==\
    \ 0\n                        smalest_value = arr[i]\n                        break\n\
    \                    else\n                        continue\n                end\n\
    \                # if all values are even\n                return [smalest_value,\
    \ i]\n            end\n        else\n            # find index of smallest even\
    \ value\n            for i = 2:n\n                if arr[i] % 2 == 0\n       \
    \             smalest_value = arr[i]\n                    break\n            \
    \    else\n                    continue\n                end\n            end\n\
    \            # if not smallest even value return\n            return []\n    \
    \    end\n    end\n    return []\nend\n</cell>\n<text>\n6. Prune (Remove Elements)\n\
    Given a vector arr of positive integers. Your task is to remove all zeros or all\
    \ negative elements from that vector and return a new array.", "    pluck_arr\
    \ = []\n    smalest_value = arr[1]\n    smallest_index = 1\n    for i in 2:length(arr)\n\
    \        if arr[i] < smalest_value\n            smalest_value = arr[i]\n     \
    \       smallest_index = i\n        end\n    end\n    push!(pluck_arr, smalest_value)\n\
    \    push!(pluck_arr, smallest_index)\n    return pluck_arr\nend", "    # Write\
    \ your code here\n    odd_indexes = findall(x -> x % 2 != 0, arr)\n    even_indexes\
    \ = findall(x -> x % 2 == 0, arr)\n    \n    if length(odd_indexes) == 0\n   \
    \     return vec[]\n    else \n        index_of_smallest_even_value = argmin(even_indexes)\n\
    \        return vec(odd_indexes[index_of_smallest_even_value])\n    end\nend",
  '    # write your code in Python 3 compatible way', "    if length(arr) == 0\n \
    \       return Vector{Int64}()\n    node = min_even_index([v for (i, v) in enumerate(arr)\
    \ if (v & 1) == 0])\n    Vector{Int64}([node, arr.index(node)])\nend", "    result\
    \ = []\n    \n    while length(arr)>0\n        largest = minimum(arr)\n      \
    \  if largest%2==0\n            push!(result, largest)\n            remove(arr,\
    \ largest)\n        else\n            push!(arr, largest)\n        end\n    end\n\
    \    return result\nend", "    # Your code here\n    result = []\n    for i in\
    \ arr\n        if iszero(i)\n            continue\n        elseif iseven(i)\n\
    \            push!(result, i)\n        elseif i<0\n            push!(result, i-1)\n\
    \        elseif i==0\n            push!(result, 0)\n        end\n    end\n   \
    \ return result\nend\n</cell>\n<code language=julia-1.0>\n# Test your code\n@test\
    \ pluck([4, 2, 3]) == [2, 1]\n@test pluck([1, 2, 3]) == [2, 1]\n@test pluck([])\
    \ == []\n@test pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\n</cell>\n<text>\n4.4 Finding\
    \ the Index of a Minimum in an Array\nSuppose that you have an array arr and would\
    \ like to determine its index of a minimum value x, where x < arr[0].", "    if\
    \ length(arr)==0\n        return Vector{Int64}[]\n    end\n    smalest_value=minimum(arr)\n\
    \    smallest_index=findall(x -> x==smalest_value, arr)\n    if length(smallest_index)>0\n\
    \        return Vector{Int64}[smalest_value, smallest_index[1]]\n    end\n   \
    \ return Vector{Int64}[]\nend\n</cell>\n<code language=julia-1.5>", "    largest\
    \ = minimum(arr)\n    index = findfirst(elem -> even elem, arr)\n    if index\
    \ == nothing\n        return []\n    else if index == -1\n        return [largest,\
    \ 0]\n    else\n        if arr[end] == largest\n            [largest, index] =\
    \ pluck(arr[index+1:end])\n        end\n        return [largest, index]\n    end\n\
    end\n</cell>\n<text>\nThe index() function returns the index of a given element\
    \ in the vector.", "    if length(arr) == 0 \n        return []\n    arr = sort(arr)\n\
    \    even_idx = zeros(length(arr))\n    i = length(arr)\n    while i >= 2 \n \
    \       even_idx[i] = i-1\n        i = i-2\n    end\n    arr = arr[even_idx]\n\
    \    return arr\nend\n</cell>\n<text>\nProblem 7\nGiven a vector containing non-negative\
    \ integers, return the vector with the maximum elements from two adjacent elements.",
  "    \n    # Sort and find Smallest value\n    arr = arr.sort\n    smalest_value\
    \ = arr[1]\n    \n    # Find the node with the smallest even value\n    smallest_value_index\
    \ = 0\n    smallest_value = smalest_value\n    for node in arr[2:end]\n      \
    \  if smallest_value % 2 == 0\n            smallest_value = node\n           \
    \ smallest_value_index += 1\n        end\n    end\n    \n    # If the smallest\
    \ value is not even \n    if smallest_value % 2 != 0\n        smallest_value -=\
    \ 1\n        smallest_value_index += 1\n    end\n    \n    return [ smallest_value,\
    \ smallest_value_index ]\nend\n\"\"\"\n    pick(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    \n    \n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"", "    minimum = arr[1]\n    minimum_index\
    \ = 1\n    for i in 2:length(arr)\n        if arr[i]%2 == 0\n            minimum\
    \ = minimum < arr[i] ? minimum : arr[i]\n            minimum_index = minimum_index\
    \ < i ? minimum_index : i\n        end\n    end\n    return minimum == 0 ? []\
    \ : [minimum, minimum_index]\nend", "    return sorted(arr, by = x -> mod(x, 2))[1]\n\
    end\n</cell>\n<text>\nProblem 3\nImplement a function that returns the number\
    \ of nodes in a BST with non-negative integer nodes.", "    if length(arr) ==\
    \ 0 \n        return [] \n    end\n    \n    smalest_value = minimum(filter(a\
    \ -> a%2 == 0, arr))\n    idx = find(arr == smalest_value)[1]\n    arr[idx]\n\
    end", "    arr = sort(arr)\n    even_values = filter(x -> x % 2 == 0, arr)\n \
    \   if even_values.length == 0\n        return []\n    elseif even_values.length\
    \ == 1\n        return even_values\n    else\n        smallest_value = minimum(even_values)\n\
    \        smallest_value = min(even_values, smallest_value)\n        index = findfirst(x\
    \ -> x == smallest_value, even_values)\n        return [ smallest_value, index\
    \ ]\n    end\nend", "    if arr.size == 0 \n        return [] \n    end\n    minimum\
    \ = min(arr.take(1))\n    indexes = [i for (i,value) in enumerate(arr) if value\
    \ == minimum] \n    if indexes.length == 0 \n        return []\n    else\n   \
    \     return minimum, indexes \n    end\nend", "    if arr.length==0 return []\n\
    \    min_ind::Int64 = arr.min_ind()\n    if min_ind == 0 return []\n    \n   \
    \ smalest_value::Int64 = arr[min_ind]\n    \n    evens::Set{Int64} = Set()\n \
    \   for x in arr\n        if x%2==0\n            evens.add(x)\n        else\n\
    \            break\n        \n    even_ind::Int64 = findfirst(evens, min_ind)\n\
    \    if even_ind == -1 return []\n    \n    return [smalest_value, even_ind]\n\
    end\n</cell>\n<text>\nProblem 8\nGiven a vector arr of integers, arr is sorted\
    \ in descending order.\nYour task is to find the first index of an element in\
    \ arr that is divisible by 3.", "\"\"\"\n    Your task is to pluck one of the\
    \ nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.", "\"\"\"\n    \"Given a vector representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.", "    if arr.length\
    \ == 0 return []\n    sorted_indices = np.argsort(arr)\n    \n    smalest_value\
    \ = arr[sorted_indices[0]]\n    smallest_value_index = 0\n    \n    for i in sorted_indices[1..length(arr)-1]\n\
    \        if arr[i] != smalest_value and arr[i] % 2 == 0 \n            smallest_value_index\
    \ = i\n            break\n        end\n    end\n    \n    if smallest_value_index\
    \ > 0 \n        return [smalest_value, smallest_value_index]\n    else\n     \
    \   return []\n    end\nend", "    even_values = Vector{Int}()\n    index = zeros(Int,\
    \ length(arr))\n    for node in arr\n        if mod(node, 2) == 0 \n         \
    \   push!(even_values, node)\n            push!(index, length(arr))\n        end\n\
    \    end\n    if length(even_values) == 0 return [] end", "    if arr.length ==\
    \ 0 || arr.length == 1 \n        return arr \n        \n        \n    if arr.even.size\
    \ == 0 \n        return [] \n        \n    \n    smallest_val = arr.min\n    smallest_idx\
    \ = 1\n    \n    for i = 1:arr.length-1 \n        if arr[i] > smallest_val \n\
    \            smallest_val = arr[i] \n            smallest_idx = i \n        end\n\
    \    end\n    \n    return [smallest_val, smallest_idx]\n    \nend", "    small_value::Int64\
    \ = 0\n    small_index::Int64 = 0\n    even_value::Int64 = 0\n    \n    for n\
    \ in arr \n        if n % 2 == 0 \n            even_value += n \n            if\
    \ even_value % 2 == 0 \n                small_value += n \n                if\
    \ small_value > small_value \n                    small_index = small_index +\
    \ 1\n                    small_value = small_value \n                end\n   \
    \         end\n        end\n    end\n    \n    return [] if small_value == 0 \n\
    \    [small_value,small_index]\nend\n</cell>\n<text>\nProblem 3\nImplement a method\
    \ isEven() that checks if a given integer is even or odd.", "    # Write your\
    \ code in Julia 1.0\n    return arr[minimum(arr .> 0 .& arr .% 2 == 0)]", "  \
    \  if length(arr) == 0\n        return []\n    \n    even_values = filter(x ->\
    \ mod(x, 2) == 0, arr)\n    \n    if length(even_values) == 0\n        return\
    \ [] \n    \n    largest = maximum(even_values)\n    smallest = minimum(even_values)\n\
    \    smallest_index = which(x -> x == largest)[1]\n    \n    \n    if smallest_index\
    \ == length(even_values)\n        return []\n    \n    smallest_value = even_values[smallest_index]\n\
    \    \n    index_of_smallest_value = which(x -> x == smallest_value)[1]\n    \n\
    \    return smallest_value, smallest_index\nend\n</cell>\n<code language=julia-1.4>",
  "    if arr.empty?\n        return []\n    \n    sorted_indexes = sort_indexes(arr)\n\
    \    \n    index = findfirstindex(sorted_indexes, x -> x > 0, -1)\n    smallest_even_value\
    \ = sorted_indexes[index]\n    \n    \n    if smallest_even_value == 0\n     \
    \   smallest_even_value, _ = sort_indexes(arr)\n    end\n    \n    smalest_value\
    \ = arr[smallest_even_value]\n    \n    return [smallest_even_value; index]\n\
    end\n</cell>\n<code language=julia-1.5>", "    # write your code in psuedo code\
    \ below\n    smallest_value::Int64 = 0\n    smallest_index::Int64 = 0\n    smallest_value_even::Int64\
    \ = 0\n    smallest_index_even::Int64 = 0", "    sorted = sort(arr)\n    index\
    \ = find(sorted==sorted[1])[1]\n    return sorted[index], index\nend\n</cell>\n\
    <text>\n6.5.3 Write a function to get the median\nImplement the median function\
    \ to get the median of a sorted array of integers:\nTo get the median of an empty\
    \ array,return nan.\nTo get the median of an array of length 1,return nan.\nTo\
    \ get the median of an array of length 2 return ((A[0] + A[1])/2).\nTo get the\
    \ median of an array of length 3 return the median of the 3 middle elements.\n\
    To get the median of an array of length k return the median of the (k+1)-th through\
    \ kth middle elements.", "    \n    # Ok, so you got the vector\n    # Now you\
    \ need to go through each element and find the smallest even number\n    # Let's\
    \ say that you have found the smallest even number, we'll call it min_even\n \
    \   # Now you just need to iterate through the array and see if the current element\
    \ is less than the minimum even value\n    # If it is then we update our min_even\
    \ to the current element.\n    # As soon as we find an odd element we know that\
    \ that is the smallest even number so we're done", "    even_values = filter(x\
    \ -> x % 2 == 0, arr)\n    smallest_values = minimum(even_values)\n    if isempty(even_values)\
    \ || isempty(smallest_values)\n        return []\n    else\n        return [smallest_values,\
    \ indexmin(even_values, smallest_values)]\n    end\nend\n</cell>\n<text>\nProblem\
    \ 14 (12 Points)\nGiven a binary tree and a number, find the smallest number of\
    \ nodes to split the tree into to make it as balanced as possible.", "    even\
    \ = sort!(arr.filter(x -> mod(x,2) == 0))\n    smallest_value_index =  if length(even)\
    \ == 0 then [] else min(enumerate(even), by=x->x[1]) \n    smalest_value = smallest_value_index.value\
    \ != 0 ? arr[smallest_value_index.value] : -1\n    return [smalest_value; smallest_value_index.index]\n\
    end ", "    if arr.length == 0\n        return []\n    pivot_idx = find(arr.==0)[1]\n\
    \    pivot_value = arr[pivot_idx]\n    arr = arr .- pivot_value\n    pivot_idx\
    \ = find(arr ==0)[1]\n    arr[pivot_idx] = 0\n    return arr\nend\n</cell>\n<text>\n\
    6.2 Prune Branches\nWrite a function to prune a given branch of a binary tree\
    \ that has at most k nodes.", "    if length(arr) == 0 || arr.is_empty() \n  \
    \      return [] \n    else \n        minimum = minimum(arr) \n        ans = []\n\
    \        index = 1\n        for value in arr \n            if value == minimum\
    \ \n                push!(ans, minimum) \n                push!(ans, index) \n\
    \            else \n                push!(ans, minimum) \n                push!(ans,\
    \ index) \n                index += 1 \n                minimum = minimum \n \
    \           end \n        end\n        return ans \n    end \nend "]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
