name: HumanEval_85_add
language: jl
prompt: "\"\"\"Given a non-empty vector of integers lst. add the even elements that\
  \ are at odd indices..\n\n\n    Examples:\n    >>> add([4, 2, 6, 7])\n    2\n  \
  \  \"\"\"\nfunction add(lst::Vector{Int64})::Int64 \n"
tests: "using Test\n\n@testset begin\n\ncandidate = add;\n\t@test(candidate([4, 88])\
  \ == 88)\n\t@test(candidate([4, 5, 6, 7, 2, 122]) == 122)\n\t@test(candidate([4,\
  \ 0, 6, 7]) == 0)\n\t@test(candidate([4, 4, 6, 8]) == 12)\nend\n"
completions: ["    \n    evens = lst[1 : (end-1)]\n    odd = lst[(end-2) : (end-1)]\n\
    \    \n    sum = 0\n    \n    for e in evens\n        sum += e\n    end\n    \n\
    \    for o in odd\n        sum += o\n    end\n    \n    return sum\nend\n</code>\n\
    <|/ a dscore=3 |>\n<| a |>\nJust to contribute an alternative approach, using\
    \ an accumulator and an iterator instead of a loop.\n<code>", "    if length(lst)\
    \ <=1\n        return lst[1]\n    end", "    # lst.length == 1\n    if lst.length\
    \ !=1\n        throw(ArgumentError(\"list must have length 1\"))\n    end\n  \
    \  # lst[0] == 0\n    if lst[0] !=0\n        throw(ArgumentError(\"lst[0] must\
    \ be 0\"))\n    end\n    # lst.head is even\n    if lst.head%2==0\n        throw(ArgumentError(\"\
    lst.head must be even\"))\n    end\n    even = lst.tail[1]%2==0\n    if even\n\
    \        return sum(lst.tail)\n    else\n        lst.tail[1] = lst.tail[1]%2\n\
    \        return sum(lst.tail)\n    end\nend", "    \"\"\"\n    Arguments:\n  \
    \      lst: the input vector\n    Returns:\n        the sum of elements in the\
    \ input vector\n    \"\"\"\n    cnt = 0\n    for i in lst\n        if i%2 == 0\n\
    \            cnt += 1\n        end\n    end\n    lst\n    cnt\n    \nend\n</cell>\n\
    <code language=julia-1.3>\nadd([4, 2, 6, 7])\n</cell>\n<code language=julia-1.3>\n\
    \"\"\"Given a non-empty vector of integers lst. add the odd elements that are\
    \ at even indices..", "    for i in 2:length(lst)\n        if lst[i]%2 != 0\n\
    \            lst[i]+=lst[i-1]\n        end\n    end\n    return sum(lst[lst!=0])\n\
    end\n</cell>\n<code language=julia-1.3>\n@code_warntype add(lst)\n</cell>\n<text>\n\
    Write a function that multiplies a vector by a scalar.", "    sum_even=0\n   \
    \ for i=1:size(lst)[2]\n        if lst[i]%2==0\n            sum_even+=lst[i]\n\
    \        end\n    end\n    return sum_even\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| a dscore=0 tags=julia,syntax |>\nAnother way of doing it would be the following:\n\
    <code>\njulia> [i for i in 1:10 if i % 2 == 0]\n6-element Array{Int64,1}:\n 6\n\
    \ 8\n10\n</code>\n<|/ a |>\n<| a dscore=0 tags=julia,syntax |>\nAs pointed out\
    \ in previous answers, the idiomatic way to write this in Julia is:\n<code>\n\
    julia> [i for i in 1:10 if i % 2 == 0]\n6-element Array{Int64,1}:\n 6\n 8\n10\n\
    </code>\nThis approach is often faster than a comprehension that is executed inside\
    \ the loop.\nIn general, when writing the code for one specific task, the best\
    \ way to approach it is to just try each idiom, measure performance, and decide\
    \ which one performs the best. Julia comes with a couple of BenchmarkTools packages\
    \ that can be used to test different approaches and choose the one that best fits\
    \ your needs.\nFor this particular question, using BenchmarkTools, we get:\n<code>\n\
    julia> add([i for i in 1:10 if i % 2 == 0])\n  1.243234 seconds (3 allocations:\
    \ 1.071 KiB)", "    even = lst[end-2:end]\n    odd = lst[end-1:end]\n    even.+=(odd.*2)\n\
    \    return even\nend\n\"\"\"Given a non-empty vector of integers lst. add the\
    \ odd elements that are at even indices..", "   \n    # your code goes here\n\
    \    return 0\nend", "    n = lst.len\n    even = 0\n    odd = 0\n    for i in\
    \ 1:n\n        if (lst[i] % 2 == 0) \n            even = even + lst[i]\n     \
    \   else\n            odd = odd +  lst[i]\n        end\n    end\n    add(even,\
    \ odd)\nend", "    sum=0\n    for i in eachindex(lst) do \n        sum=sum+lst[i]\n\
    \    end\n    return sum\nend", "  sum = 0\n  for elem in lst\n    sum += elem\n\
    \  end\n  return sum\nend", "    evens = 0\n    for i in 1:length(lst)\n     \
    \   if lst[i] % 2 != 0\n            evens += lst[i]\n        end\n    end\n  \
    \  return evens\nend\n</cell>\n<cell>", "    return sum((lst[i] for i = 1:length(lst))\
    \ % 2 == 0)\nend", "    sum = 0\n    for i in lst[2:2:end]\n        sum += i\n\
    \    end\n    return sum\nend", "    local i\n    local evens = 0\n    for i=2:length(lst)\n\
    \        if lst[i] % 2 == 1 then evens += lst[i] end\n    end\n    return evens\n\
    end\n</cell>\n<text>\nQuestion 5", "    \n    # your code here\n    if length(lst)\
    \ == 0 \n        return \n    \n    even = lst[1 : (length(lst)-1)]\n    odd =\
    \ lst[2:end]\n    \n    even.+=(odd)\n    return even\nend\n</cell>\n<code language=julia-1.0>\n\
    @code_warntype add([4, 2, 6, 7])\n</cell>\n<text>\nProblem 8\nImplement a function\
    \ add_all that takes as input a list of integers and returns a sum of all the\
    \ integers in the list. Also implement a version that takes an integer n and returns\
    \ the sum of all integers from 1 to n (inclusively).", "    evens = lst[findall(x\
    \ -> x % 2 == 0, lst)]\n    return sum(evens)\nend\n</cell>\n<text>\nProblem 7\n\
    Add all of the numbers in the given list using loops.", "    even_index = find_even_index(lst)\n\
    \    even_value = lst[even_index]\n    lst[even_index:end] .+= even_value\n  \
    \  return sum(lst)\nend\n</cell>\n<code language=julia-0.5>\n\"\"\"Given a non-empty\
    \ vector of integers lst. add the odd elements that are at even indices..", '"""',
  "    \"\"\"\n    Your function should add all the even elements at odd indices.\n\
    \    \"\"\"\n    return 0\nend\n</code>\nProblem 2:\nDefine a function that returns\
    \ the sum between the minimum and maximum elements in a given vector. Recall that\
    \ there are two types of vectors in Julia: Vector{Int} and Vector{Any}.\n<|/ a\
    \ |>\n<| c |>\nI didn't downvote, but this doesn't actually answer the question\
    \ asked.\n<|/ c |>\n<| c |>\nThe question was how to write a function for the\
    \ problem #2, where he wants to add the even elements at odd indices. Your answer\
    \ doesn't address that. And there are other problems with this code as well.\n\
    <|/ c |>\n<| c |>\nI see you posted a comment that said my answer doesn't answer\
    \ the question, so I edited my answer.\n<|/ c |>\n<| c |>\nThanks for the correction.\
    \ I edited my answer based on the new information provided by the OP.\n<|/ c |>\n\
    <| a dscore=3 tags=julia |>\nAn example of a vectorized solution would be:\n<code>\n\
    sum(v[div(1:length(v_even), 2):end]) \n</code>\n<|/ a |>\n<| a tags=julia |>\n\
    This isn't the most efficient solution, but I believe it's easier to understand:\n\
    <code>", "    even = Vector{Int64}()\n    for i in 1:length(lst)\n        if i%2==1\n\
    \            push!(even, lst[i])\n        end\n    end\n    return reduce(+, even)\n\
    end\n</cell>\n<code language=julia-1.5>\nadd([4, 2, 6, 7])\n</cell>\n<text>\n\
    The last function defined will apply the above function to each element in the\
    \ passed list.", "    even = filter(x -> x % 2 == 0, lst)\n    return sum(even)\n\
    end\n</cell>\n<text>\nExercise 4:\nWrite a function named add_even that takes\
    \ a vector of integers and returns the sum of the even elements.", "    n=0\n\
    \    for x in lst\n        n+=x%2 == 0\n    end\n    return n\nend", "    sum\
    \ = 0\n    for x in lst\n        if x % 2 == 0\n            sum += x\n       \
    \ end\n    end\n    return sum\nend", "    even = findall(x -> x % 2 ==0, lst)\n\
    \    return sum(lst[even])\nend", "    if length(lst) == 0 \n        return 0\
    \ \n    else \n        if length(lst) == 1 \n            return lst[1] \n    \
    \    else \n            return add(lst[end-2]) + add(lst[end-1]) \n    end\nend",
  "    evens = Vector{Int64}(lst)\n    for i in length(evens):-1:2\n        evens[i]\
    \ = evens[i+1] + evens[i]\n    end\n    return sum(evens)\nend\n</cell>\n<code\
    \ language=julia-0.6>\nadd([4, 2, 6, 7])\n</cell>\n<code language=julia-0.6>\n\
    @assert add([4, 2, 6, 7]) == 10\n</cell>\n<text>\nExercise: Write a function named\
    \ add_evens that given an integer, returns the sum of all even numbers below that\
    \ integer", "    even = vec(lst)[findall(vec(lst) .%% 2==0)]\n    even += vec(lst)[findall(vec(lst)\
    \ .%% 2==1)]\n    return even\nend\n</cell>\n<code language=julia-0.6>\n# %load\
    \ solutions/sol_17.py\n</cell>\n<text>\nProblem 18\nGiven an integer n, return\
    \ the number of trailing zeroes in n!.", "    return lst[2::2]\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"Given a vector of integers lst, return a vector\
    \ of integers lst2 such that lst2[i] is lst[i] times i..", "    even = 0\n   \
    \ odd = 1\n    while odd <= length(lst)\n        if lst[odd] % 2 == 1\n      \
    \      even += lst[odd]\n        end\n        odd += 1\n    end\n    return even\n\
    end\n</code>\nThis code iterates over the list and counts the sum of odd numbers\
    \ up to the end of the list.\nAn equivalent code would be:\n<code>", "  for i\
    \ in 2:length(lst)\n    if lst[i] % 2 == 0 && lst[i-1] % 2 == 1\n      lst[i]\
    \ +=2\n    end\n  end\n  return sum(lst)\nend", "    return sum(lst[1 : (end-lst)/2])\n\
    end", "    if length(lst) == 0 \n        return 0\n    end\n    even = []\n  \
    \  odd = []\n    for el in lst\n        if el % 2 == 0\n            push!(even,\
    \ el)\n        else\n            push!(odd, el)\n        end\n    end\n    for\
    \ i in even\n        lst[i] = lst[i] + odd[i]\n    end\n    return sum(lst)\n\
    end\n</code>\nAnd for sum is this \n<code>\n\"\"\"Given a non-empty vector of\
    \ integers lst. compute the sum of the even elements that are at odd indices..",
  "    for i in length(lst) \n        if mod(lst[i], 2) == 0 \n            lst[i]\
    \ = lst[i] + 2\n        end \n    end \n    return lst[1] \nend \n</cell>\n<text>\n\
    Exercise 10\nThe function is_even(i::Int64) takes one parameter, i. \nIt returns\
    \ True if i is even, and False otherwise. \nUse it to test the function add()\
    \ you wrote earlier. ", "    lst = copy(lst)\n    for i in lst.indices \n    \
    \    if lst[i] % 2 == 0 \n            lst[i] = lst[i] + 2 \n        else \n  \
    \          lst[i] = lst[i] + 1 \n        end\n    end\n    return sum(lst)\nend\n\
    </cell>\n<cell>\n#export\n\"\"\"Given a non-empty vector of integers lst. add\
    \ the odd elements that are at even indices..", "  if length(lst) == 1\n    return\
    \ lst[1]\n  else\n    return lst[1] + add(lst[2 : end])\n  end\nend", "    lst\n\
    \    evens = lst .% 2 == 0\n    even_indices = filter(x -> x==true, lst.take(evens))\n\
    \    sum = 0\n    for index in even_indices:\n        sum += lst[index]\n    end\n\
    \    return sum\nend", '    """Given a non-empty vector of integers lst. add the
    even elements that are at odd indices..', "    sum = 0\n    for i in lst\n   \
    \     if i %2 == 1 \n            sum +=i\n        end\n    end\n    return sum\n\
    end", "  result = 0\n  for n in lst\n    result += n%2 == 0\n  end\n  return result\n\
    end", "    evens = lst[1 .. end]\n    odd = lst[2 .. end]\n    return sum(x for\
    \ (x,y) in  zip(evens,odd) if (x % 2)==0)\nend", "    if lst.length == 2\n   \
    \     lst.push!(lst[1])\n        lst[1] = 0\n    end\n    \n    for i in 2::length(lst)\n\
    \        lst[i] = lst[i-2] + lst[i-1]\n    end\n    \n    if length(lst) == 2\n\
    \        return lst[1]\n    end\n    \n    return 0\nend", "   n = length(lst)\n\
    \   sum = 0\n   if n <= 0 \n       return 0\n   end \n   for x in lst\n      \
    \ if x % 2 != 0\n           sum += x\n       elseif x % 2 == 0\n           sum\
    \ += 2*x \n       end\n   end\n   return sum\nend\"\"\"\n</cell>\n<text>\nQuestion\
    \ 2\nWrite a function that returns the smallest integer that is not evenly divisible\
    \ by all of the numbers from 0 to n. For example, given the vector [4, 2, 6, 7],\
    \ your function should return 8.", "  even::Bool=false\n  even=false\n  even=false\n\
    \  for i in lst\n    if i%2==0\n      if even==false\n        even=true\n    \
    \  else\n        return i\n      end\n    end\n  end\nend\n</cell>\n<text>\nProblem\
    \ 7. Given a vector of length n, return a boolean indicating if the vector is\
    \ palindrome or not.", "    sum = sum(lst[2:end-1])\n    sum%2==1 ? sum+1 : sum\n\
    end\n</cell>\n<text>\nQuestion 6\nWrite a function that checks whether a number\
    \ is even or odd.", "    sum = 0\n    for i in 2:length(lst)\n        if lst[i]\
    \ % 2 == 0\n            sum += lst[i]\n        end\n    end\n    return sum\n\
    end", "    even_ind = findall(x -> mod(x, 2) == 0, lst)\n    return sum(lst[even_ind])\n\
    end\n</cell>\n<code language=julia-1.3>\nadd([1,2,3,4,5,6,7,8,9,10])\n</cell>\n\
    <text>\nExercise 3", "    # lst = sort(lst)\n    # lst = vec(lst)\n    return\
    \ sum(lst[1::2])", "    \n    # Your code here\n    \nend", "    even_indices\
    \ = findall(x->mod(x, 2)==0, lst)\n    return sum(lst[even_indices])\nend", " \
    \   evens = filter(x -> mod(x, 2) == 0, lst)\n    return sum(evens)\nend", " \
    \   for i in 2:length(lst)\n        if mod(lst[i], 2) == 0\n            lst[i]\
    \ += lst[i-1]\n        end\n    end\n    return sum(lst)\nend", "    n=0\n   \
    \ for elem in lst\n        if mod(elem, 2)==1\n            n+=elem\n        end\n\
    \    end\n    return n\nend", "    sum_so_far = 0\n    sum = 0\n    for i in lst\
    \ \n        if i%2 == 0 \n            sum_so_far += i\n        else \n       \
    \     sum += sum_so_far\n    end\n    return sum\nend\n</cell>\n<text>\n$${\\\
    displaystyle \\text{Add all elements from lst}}$$", "    even = findall(x -> mod(x,2)\
    \ == 1, lst)\n    lst[even] +=  lst[odd]\n    nothing\nend\n</cell>\n<text>\n\
    Solution 2", "    \n    even_idx = findindices(lst, &mod(lst, 2) == 1)\n    lst[even_idx]\
    \ +=  lst[findindices(lst, &mod(lst, 2) == 1)]\n    \n    return length(lst)\n\
    end\n</cell>\n<code language=julia-1.5>\n# check your code - feel free to copy\
    \ and paste this\n@code_warntype add([4, 2, 6, 7])\n</cell>\n<text>\nProblem 4\n\
    Write a Julia function called myisisq that takes as input a vector of integers\
    \ lst and a number k, and returns true if any 2 numbers in the vector are equal\
    \ to k squared, false otherwise. For example, myisisq([4, 2, 6, 7], 2) should\
    \ return true. Hint: Use nested for loops to solve this problem", "    n=length(lst)\n\
    \    even=lst[div(n,2)]\n    return even + lst[div(n,2)]\nend", "    total = 0\n\
    \    for x in lst\n        if x % 2 == 0\n            total += x\n        end\n\
    \    end\n    return total\nend\n</cell>\n<code language=julia-1.0>", "    if\
    \ length(lst) == 0 \n        return 0 \n    odd = 1 \n    for i in lst[2:end]\
    \ \n        if i%2 == 1 \n            odd += 1 \n        end \n    end \n    return\
    \ odd \nend ", "    if length(lst) == 0 \n        return 0 \n    else \n     \
    \   if length(lst) == 1 \n            return lst[1] \n        else\n         \
    \   return add(lst[1 : end-2]) + add(lst[end-2:end]) \n        end\n    end\n\
    end", "    if lst.length == 0 return 0\n    if lst.length == 1 return lst[1]\n\
    \    \n    even = 0\n    odd = 1\n    \n    for index in 2:lst.length\n      \
    \  if lst[index] % 2 == 0 \n            even += lst[index]\n        else\n   \
    \         odd += lst[index]\n        end\n    end\n    return even + odd\nend",
  "  even_sum = 0\n  for i in lst \n    if i%2 ==0 \n      even_sum += i \n    end\n\
    \  end\n  return even_sum\nend", "    for index in 2:length(lst)\n        if lst[index]\
    \ % 2 == 0\n            lst[index] +=2\n        end\n    end\n    return lst[1]\n\
    end", "    even=[]\n    odd=[]\n    for i in lst\n        if (i%2==0)\n      \
    \      even+=[i]\n        else\n            odd+=[i]\n    end\n    return length(even)+length(odd)\n\
    end", "    count = 1\n    sum = 0\n    for i in lst\n        if i %% 2 == 1\n\
    \            sum += i\n            count += 1\n        end\n    end\n    return\
    \ sum + count * 2\nend\n</cell>\n<cell>\nadd([4, 2, 6, 7])\n</cell>\n<text>\n\
    3.3 Sum of odd numbers", "    even = lst[1 .+ lst[1 .+ 1:length(lst)]]\n    odd\
    \ = lst[2 .+ lst[2 .+ 1:length(lst)]]\n    return even + odd\nend\n</code>\n<|/\
    \ a tags=julia |>\n<| c |>\nNice use of broadcasting. I'd also add that `[1 .+\
    \ 1:length(lst)]` is an `Int` not a `Vector{Int64}` so you need to do `[1 .+ Int64.(1:length(lst))]`\
    \ if you want to broadcast it to `Vector{Int64}`.\n<|/ c |>\n<| a tags=julia |>\n\
    The answer from user4815162342 is almost correct, but you need to change the way\
    \ you compute the sum of odd elements. To compute even elements we have the sum\
    \ of every second element and to compute odd we have the sum of every third element.\
    \ \n<code>\nadd([4,2,6,7])\n2\n</code>\nThe final code would be:\n<code>\nadd([4,2,6,7])",
  "    n,i=1,0\n    while i<length(lst) do \n        if lst[i]%2==0 then lst+=lst[i]\
    \ else n-=lst[i]; i+=1 end\n    end\n    return n\nend\nadd([4, 2, 6, 7])", " \
    \   lst = lst + length(lst) % 2\n    return lst[2]\nend\n</cell>\n<code language=julia-0.5>\n\
    add([4, 2, 6, 7])\n</cell>\n<code language=julia-0.5>\nadd([2, 4, 6, 8, 10])\n\
    </cell>\n<text>\nReverse a list", "    lst.zip((2*i for i in lst.tail))\nend",
  "    return \nend\n</cell>\n<code language=julia-1.6>\n@assert add([4, 2, 6, 7])\
    \ == 4\n</cell>\n<text>\nQuestion 8.2\nImplement the function sub that takes in\
    \ a vector of integers and returns the sum of all the even numbers minus the sum\
    \ of all the odd numbers. \n\"\"\"", "    for i in lst\n        if i%2 != 0\n\
    \            lst = lst + i\n        end\n    end\n    return lst\nend\n</cell>\n\
    <text>\nQuestion 2", "    i = 0\n    sum = 0\n    for a in lst\n        if a%2==0\n\
    \            sum += a\n        end\n        i = i + 1\n    end\n    return sum\n\
    end", "    l = length(lst)\n    even = []\n    for index in 1:l\n        if mod(index,\
    \ 2) == 0 # if odd index\n            push!(even, lst[index])\n        end\n \
    \   end\n    return sum(even)\nend", "    evens = lst.filter( x -> x % 2 == 0\
    \ )\n    return sum(evens)\nend\n</cell>\n<text>\nNow let's use our new function.",
  "  \n  even_indices = findall(x->mod(x, 2) == 0, lst)\n  return sum(lst[even_indices])",
  "    even = 0\n    for x in lst\n        if x%2 == 0\n            even += x\n  \
    \      end\n    end\n    return even\nend", "    even_ind = findind(lst, 2); \n\
    \    # even_ind = 2 if even_ind == 1\n    return sum(lst[even_ind : end])\nend",
  "    even_ind = findind(lst,0)\n    odd_ind = findind(lst,1)\n    even = lst[even_ind]\n\
    \    odd = lst[odd_ind]\n    sum = even + odd\n    return sum\nend", "    \"\"\
    \"given a vector of integers lst, add the even elements that are at odd indices..\n\
    \    \n    Args: \n    lst (vector): input vector of integers", "    if lst ==\
    \ []\n        return 0\n    even = 0\n    odd = 1\n    while lst != []\n     \
    \   if mod(lst[odd], 2) == 0\n            even += lst[odd]\n        else\n   \
    \         odd += 1\n        end\n        lst = lst[1::2]\n    end\n    return\
    \ even\nend\n</cell>\n<text>\nTask (2) : Find the largest element in an array.\
    \ \nThe function takes an array as input and returns its largest element. \nIf\
    \ there are more than one largest elements, then the function returns the one\
    \ that appears first in the list.", "    odd = Vector{Int64}(collect(2:length(lst)-1))\n\
    \    even = Vector{Int64}(collect(1:length(lst)-1))\n    for i in even, odd\n\
    \        lst[i] += lst[!i]\n    end\n    return sum(odd)\nend\n</cell>\n<text>\n\
    Next we write an inner function to find sum of an even list using map", "    for\
    \ i in 2:length(lst)\n        if lst[i] % 2 == 0 && lst[i] != 0 \n           \
    \ lst[i] += lst[i-1]\n        end\n    end\n    return sum(lst)\nend", "    evens\
    \ = lst[1 :] \n    odds = lst[2 :] \n    return sum(evens + odds)\nend ", "  \
    \  evens = Int64[]\n    for (i,v) in enumerate(lst) \n        if i%2 == 1 \n \
    \           push!(evens, v)\n        end \n    end\n    sum(evens)\nend\n</cell>\n\
    <cell>\nadd([4, 2, 6, 7])\n</cell>\n<text>\nExercise 2: Vectorized Solution\n\
    Using the same function above - how would you vectorize the addition of all even\
    \ elements of the vector lst?", "    evens = Vector{Int64}()\n    odds = Vector{Int64}()\n\
    \    for i in lst \n        if i%2 == 0 push!(evens,i) \n        else push!(odds,i)\
    \ \n    end\n    evens = evens[2:end]\n    odds = odds[2:end]\n    sum(evens)\
    \ + sum(odds)\nend\n</cell>\n<code language=julia-0.6>\nadd(vec(1:10))\n</cell>\n\
    <text>\nExercise 10\nWrite a function called \"double\" that doubles the vector\
    \ passed in:", "    return sum(lst[1::2])\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert add([]) == 0\n@assert add([1]) == 1\n@assert add([2]) == 2\n@assert add([3])\
    \ == 3\n@assert add([4, 2, 6, 7]) == 7\n</cell>\n<text>\nTask 10: Create a function\
    \ named evensum that takes as input a vector of integers, and returns the sum\
    \ of the even integers in the vector.", "    return sum(lst[1 : (end-1)])\nend\n\
    \"\"\"\nGiven a non-empty vector of integers lst. add the odd elements that are\
    \ at even indices..", "    \n    even = lst[2 : (end-lst)]\n    odd = lst[(end-lst)\
    \ : end]\n    sum = 0\n    for value in odd\n        if value%2 == 0\n       \
    \     sum += value\n        end\n    end\n    return sum\nend\n</cell>\n<code\
    \ language=julia-1.5>\nadd(lst)\n</cell>\n<text>\nExercise: Implement a function\
    \ that computes the cumulative sum of a given vector.", "    if lst.length ==\
    \ 0\n        return 0\n    \n    #initialize counters\n    even::Int64 = 0\n \
    \   odd::Int64 = 0\n    \n    #find even indices in the vector \n    for i in\
    \ 2:length(lst)\n        if lst[i] % 2 == 0\n            even = even + 1\n   \
    \     end\n    end\n    \n    #find odd indices in the vector\n    for i in 2:length(lst)\n\
    \        if lst[i] % 2 != 0\n            odd = odd + 1 \n        end\n    end\n\
    \    \n    \n    #add even elements that are at odd indices\n    total::Int64\
    \ = even + odd\n    \n    return total\nend\n</cell>\n<text>\nQuestion 8 (2 points).\
    \ Write a function that computes the sum of the squares of the numbers in the\
    \ given vector. Do not use any built-in functions to do this. Assume that the\
    \ vector has a length of at least 2. Write the answer as a Float scalar.", " \
    \   if length(lst) == 0 return 0\n    if length(lst) == 1 return lst[1]\n    for\
    \ x in lst\n        if x % 2 == 1 lst[end] = x\n        else \n            lst[end]\
    \ = x // 2 \n        end\n        end \n    return sum(lst)\nend ", "    return\
    \ 0\nend", "    for (i,e) in enumerate(lst) \n        if i % 2 == 1 \n       \
    \     lst[i] += e \n        end \n    end \n    \n    return lst[1] \nend", " \
    \   even = even(lst)\n    \n    return sum(x for x in lst if even(x) == 1)\nend\
    \ \n</cell>\n<code language=julia-1.4>\nadd([4, 2, 6, 7])\n</cell>\n<code language=julia-1.4>\n\
    \"\"\"Given a non-empty vector of integers lst. add the odd elements that are\
    \ at even indices..", "    evens = lst[div(1:end, 2):end]\n    return sum(evens)\n\
    end\n</cell>\n<text>\nadd2", "\"\"\"\nAdd the elements of a vector. \n\"\"\"\n\
    @assert length(lst) >= 1 \"`lst` must have at least 1 element\"\n@assert lst[1]%2\
    \ == 1 \"`lst` must contain even numbers\"\n@assert lst[end-1]%2 == 0 \"`lst`\
    \ must contain odd numbers\"\n@assert length(lst) >= 2 \"`lst` must have at least\
    \ 2 elements\"\n@assert lst[1] <= lst[2] \"`lst` elements must be in ascending\
    \ order\"\n@assert all(x => 0 <= x < 10, length(x) == length(lst), \"`lst` must\
    \ have only positive integers\")\n@assert sum(lst) == sum(x => x%2 == 0, lst)\n\
    @assert sum(lst) == sum(x => x%2 == 1, lst)\n@assert length(lst) == length(filter(x\
    \ => x%2 == 0, lst))\n@assert length(lst) == length(filter(x => x%2 == 1, lst))\n\
    @assert length(lst) == length(filter(x => x != 0, lst))\n@assert length(lst) ==\
    \ length(filter(x => x != 1, lst))\n@assert length(lst) == length(filter(x =>\
    \ x != 2, lst))\n@assert length(lst) == length(filter(x => x != 3, lst))\n@assert\
    \ length(lst) == length(filter(x => x != 4, lst))\n@assert length(lst) == length(filter(x\
    \ => x != 5, lst))\n@assert length(lst) == length(filter(x => x != 6, lst))\n\
    @assert length(lst) == length(filter(x => x != 7, lst))\n@assert length(lst) ==\
    \ length(filter(x => x != 8, lst))\n@assert length(lst) == length(filter(x =>\
    \ x != 9, lst))\n@assert length(lst) == length(filter(x => x != 10, lst))\n@assert\
    \ length(lst) == length(filter(x => x != 11, lst))\n@assert length(lst) == length(filter(x\
    \ => x != 12, lst))\n@assert length(lst) == length(filter(x => x != 13, lst))\n\
    @assert length(lst) == length(filter(x => x != 14, lst))\n@assert length(lst)\
    \ == length(filter(x => x != 15, lst))\n@assert length(lst) == length(filter(x\
    \ => x != 16, lst))\n@assert length(lst) == length(filter(x => x != 17, lst))\n\
    @assert length(lst) == length(filter(x => x != 18, lst))\n@assert length(lst)\
    \ == length(filter(x => x != 19, lst))\n@assert length(lst) == length(filter(x\
    \ => x != 20, lst))\n@assert length(lst) == length(filter(x => x != 21, lst))\n",
  "    sum=0\n    for x in lst\n        if x % 2 == 1\n            sum += x\n    \
    \    end\n    end\n    return sum\nend\n</cell>\n<text>\n6. Subtract the odd elements\
    \ that are at even indices.", "    if length(lst) < 2 \n        return \n    end\
    \ \n    \n    \n    even = lst[findall(x -> x % 2 == 0, lst)]\n    odd = lst[findall(x\
    \ -> x % 2 != 0, lst)]\n    \n    length(even) + length(odd)\nend\n\"\"\"\nGiven\
    \ a non-empty vector of integers lst. add the odd elements that are at even indices..",
  "    odd_index = findfirst(x->x%2==1, lst)\n    if isempty(odd_index)\n        return\
    \ length(lst)\n    else\n        return addatindex(lst, 0, odd_index)\n    end\n\
    end", "    \n    lst = sort(lst)\n    even = filter(x -> x%2 == 0, lst)\n    odd\
    \ = filter(x -> x%2 != 0, lst)\n    \n    return (reduce(.+, even)+reduce(.+,\
    \ odd))\nend", "    if length(lst) == 0\n        return -1\n    end", "    sum\
    \ = 0\n    for i in 2 : (length(lst) - 1) \n        sum += lst[i]\n    end\n \
    \   return sum\nend", "    \n    # Write your solution here\n    n = length(lst)\n\
    \    even = lst[2::2]\n    odd = lst[1:n:2]\n    evensum = 0\n    oddsum = 0\n\
    \    for i in even\n        evensum = evensum + i\n    end\n    for i in odd\n\
    \        oddsum = oddsum + i\n    end\n    return evensum + oddsum\nend\n</cell>\n\
    <text>\nProblem 2b. Given a vector of doubles lst. Add the even elements that\
    \ are at odd indices..", "    even_ind = 1:2:length(lst)\n    for i = even_ind\n\
    \        if lst[i] % 2 != 0\n            lst[i] = lst[i] + lst[(i+2)%length(lst)]\n\
    \        end\n    end\n    lst[end-1]\nend\n</code>\n<|/ a |>\n<| c |>\nThis answer\
    \ will crash if the vector is empty or has only one element. Instead you should\
    \ check the length of `lst` before accessing its elements and returning `0` or\
    \ `nil`.\n<|/ c |>\n<| c |>\nYes I did not realise that and have amended my answer.\n\
    <|/ c |>\n<| a dscore=0 |>\nI know this question is old but I think this problem\
    \ can be solved in different ways. \nThe solution I used can be found in the question\
    \ itself. \n<code>", "    \"\"\"\n    your code here\n    \"\"\"\nend\n</cell>\n\
    <code language=julia-1.0>\n@code_warntype add(lst)\n</cell>\n<code language=julia-1.0>\n\
    @code_warntype add(lst)\n</cell>\n<code language=julia-1.0>\n@code_warntype add(lst)\n\
    </cell>\n<code language=julia-1.0>", "    result = lst[1]\n    for i in 2:length(lst)\n\
    \        if lst[i] % 2 == 0\n            result += 1\n        else\n         \
    \   result = lst[i]\n        end\n    end\n    return result\nend", "    evens\
    \ = [i for i in lst if i%2==0]\n    return sum(evens)\nend\n</cell>\n<cell>\n\
    add(vec)\n</cell>\n<text>\n4.8 Sum all numbers in a given range", "\tresult =\
    \ zero(Int64)\n\tfor idx in 2:length(lst)\n\t\tif lst[idx] % 2 != 0\n\t\t\tresult\
    \ += lst[idx]\n\t\tend\n\tend\n\tresult\nend", "    s = sum( lst[1..end-1] )\n\
    \    return s\nend\n</cell>\n<code language=julia-1.3>\n@assert add([4, 2, 6,\
    \ 7]) == 2\n</cell>\n<text>\nProblem 1", "    \"\"\"O(n) time and O(1) space.\"\
    \"\"\n    sum = 0\n    size = length(lst)\n    for i in 1:(size-1)\n        if\
    \ lst[i] % 2 != 0\n            sum = sum + lst[i]\n        end\n    end\n    return\
    \ sum\nend", "    even_indices = findall(x->mod(x,2) == 0, lst)\n    even_indices\
    \ = setdiff(even_indices, setdiff(1:length(lst),even_indices)) \n    return sum(map(x\
    \ -> x[1], filter(x -> mod(x,2)==1, zip(even_indices, lst))))\nend\n</cell>\n\
    <code language=julia-1.0>", "    for i in 1:length(lst)\n        if mod(lst[i],\
    \ 2) == 1 \n            lst[i] += 1 \n        end\n    end\n    return lst[end]\n\
    end", "    if lst.size == 0 \n        return 0 \n    end\n    even_indexed_pair\
    \ = findall(x->x%2 == 0, lst)\n    odd_indexed_pair = findall(x->x%2 != 0, lst)\n\
    \    odd_indexed_pair \u2208 even_indexed_pair\n    \n    even = sum(lst[even_indexed_pair])\n\
    \    odd = sum(lst[odd_indexed_pair])\n    even+odd\nend\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype add([4,2,6,7])\n</cell>\n<text>\nExercise: Given a vector of real\
    \ numbers, find the sum of the squares of the even numbers in the vector. For\
    \ example, add([4,2,6,7]) should return 16. \nHint: you will have to create a\
    \ vector to store the squared values as well as the sum of the squares.", "  \
    \  cnt = 0\n    for n in lst\n        if n % 2 == 1\n            cnt += n\n  \
    \      end\n    end\n    return cnt\nend\n</cell>\n<code language=julia-1.2>\n\
    add([4, 2, 6, 7])\n</cell>\n<text>\nGiven a non-empty vector of integers lst,\
    \ return the sum of the numbers in the vector", "    even = lst[2::2]\n    odd\
    \ = lst[3::2]\n    return even+odd\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\n\
    This is nice, but it doesn't answer the question -- it just demonstrates what\
    \ the Julia documentation already says and doesn't solve the problem in the question.\n\
    <|/ c |>\n<| a |>\nHere is a solution that works in Julia 1.1 without using any\
    \ packages.\nThe function takes two arguments: the input vector, the index of\
    \ the target element of the vector. It returns the target element of the vector,\
    \ and the length of the input vector before the target element is found.\n<code>",
  "    if length(lst) == 0 \n        return 0  \n    end", "    \"\"\"\n    Odd numbers\
    \ are at odd indices\n    \"\"\"\n    local sum = 0 \n    for elem in lst\n  \
    \      if elem %2 == 1\n            sum += elem\n        end\n    end\n    return\
    \ sum\nend", "    even = filter(x -> x % 2 == 0, lst)\n    return sum(even)\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"Given a non-empty vector of integers\
    \ lst. add the odd elements that are at even indices..", "  sum = lst[1]\n  for\
    \ i = 2:length(lst)\n    sum+= lst[i]\n  end\n  return sum\nend\n</cell>\n<text>\n\
    Question 4: write a function addEvenToOddIndex that adds the even elements that\
    \ are at odd indices in the list you passed as a parameter.", "    return lst[findfirst(iseven(lst))]\n\
    end\n</cell>\n<text>\n6. Write a function that takes in a vector and returns the\
    \ sum of the elements of the vector in reverse order.", "    if lst.len==0\n \
    \       return 0\n    else\n        evens = lst[findall(x->x%2==0, lst)]\n   \
    \     return sum(evens)\n    end\nend\n</cell>\n<cell>\n# Problem 4", "  result\
    \ =0\n  for i = 1:length(lst)\n    result +=lst[i]\n  end\n  return result\nend",
  "    if length(lst) == 0 \n        return 0 \n    evens = []\n    for e in lst:\n\
    \        if isodd(e)\n            evens.append(e)\n    return sum(evens)", " \
    \   if len(lst) < 2\n        return 0\n    end\n    \n    return lst[1] + (add(lst[2\
    \ .. end-1]))\nend", "    for i in 1:length(lst)\n        if i%%2 == 0\n     \
    \       lst[i] += lst[i]\n        end\n    end\n    return sum(lst)\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThanks for your solution, however I didn't want to\
    \ use an if statement, I want to use the reduce function since I'm new to it.\n\
    <|/ c |>\n<| c |>\n, just like `reduce`, you can use `if` statement but using\
    \ `filter`. In fact, `filter` is just an abstraction of `if`\n<|/ c |>\n<| c |>\n\
    I've already solved it using filter function though. Thanks anyway.\n<|/ c |>\n\
    <| c |>\n, I added another solution, using reduce\n<|/ c |>\n<| a dscore=0 |>\n\
    Using reduce to solve a problem\n<code>\nusing LinearAlgebra\nusing LinearAlgebra:\
    \ transpose, norm", "     sum(lst[x -> x % 2 == 0]) \nend\n</code>\n<|/ a tags=julia,function,sum,vector\
    \ |>\n<| c |>\nYes, but my task is to write that function without using loops.\n\
    <|/ c |>\n<| c |>\nI have added a possible solution without loops. Please check\
    \ it.\n<|/ c |>\n<| c |>\nThanks, this worked great! \nI'm a noob at this so I\
    \ didn't know that i can use \"->\" within square brackets. Thanks again!\n<|/\
    \ c |>\n<| a |>\nA shorter version of this without loops and using the functional\
    \ programming paradigm:\n<code>", "    for i=2:length(lst)\n        if (lst[i]\
    \ % 2 ==0)\n            lst[i] = lst[i-1] + lst[i]\n        end\n    end\n   \
    \ sum(lst)\nend", "    even = filter(x -> x % 2 == 0, lst)\n    odd = filter(x\
    \ -> x % 2 != 0, lst)\n    even_sum = sum(even)\n    odd_sum = sum(odd)\n    return\
    \ even_sum + odd_sum\nend\n</cell>\n<code language=julia-1.4>\n@time add([4, 2,\
    \ 6, 7])\n</cell>\n<text>\nSlicing", "  evenIndices = findall(x -> mod(x,2) ==\
    \ 0, lst)\n  evenElements = lst[evenIndices]\n  return sum(evenElements)\nend\n\
    </cell>\n<code language=julia-0.6>\nadd([4, 2, 6, 7])\n</cell>\n<code language=julia-0.6>\n\
    @assert add([4, 2, 6, 7]) == 2\n</cell>\n<text>\n3. Remove Odd Elements\nGiven\
    \ a non-empty vector of integers lst. remove the odd elements that are at even\
    \ indices..", "    sum = 0\n    for i in 2:length(lst)\n        if lst[i]%2 ==0\
    \ \n            sum +=lst[i]\n        end\n    end\n    return sum\nend\n\"\"\"\
    \nGiven   a non-empty vector of integers lst.\nremove the elements at even indices.\
    \ that means every second element in the list.\nreturn the new list.", "    \"\
    \"\"Return a new vector with odd elements summed from the given list.\"\"\"\n\
    \    n = length(lst)\n    even = filter(x -> x % 2 == 0, lst)\n    odd = filter(x\
    \ -> x % 2 == 1, lst)\n    return sum(odd) + sum(even)\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert add([3, 1, 2, 3, 4]) == 6\n@assert add([-4, 2, 6, 7]) == 2\n</cell>\n\
    <text>\nExercise 2\nWrite a function which takes a vector of real numbers and\
    \ returns the sum of the squares.", "    for i in lst[1 .. end-1]\n        if\
    \ i%2==0\n            return i\n    end\nend\n</cell>\n<text>\nLet's test our\
    \ new function with a few examples:", "    if length(lst) == 0 \n        return\
    \ 0 \n    end", "    evens = filter(x -> x % 2 != 0, lst)\n    odd = filter(x\
    \ -> x % 2 != 0, lst)\n    return evens.reduce(::+) + odd.reduce(::+) \nend\n\
    </cell>\n<text>\nAnd there you have it! It works! Let's run some tests:", "  \
    \  if length(lst) == 0 \n        return 0 \n    else \n        evens = lst[findall(lst.>2)]\n\
    \        odds = lst[findall(lst.>1)]\n        evens = sum(evens)\n        odds\
    \ = sum(odds)\n        return evens+odds\n    end\nend\n</code>\nMy question to\
    \ you is:\nWhat type of error are you expecting?\nWhen you receive an error, how\
    \ did you arrive at that conclusion?\nDo you think there is something else that\
    \ could be improved?\nWhat else would you expect to improve?\n<|/ a dscore=2 |>\n\
    <| c |>\nThanks a lot! You saved me a lot of time :-)\n<|/ c |>\n<| a |>\nOne\
    \ issue I see is you have:\n<code>", "   \n    if length(lst)==0\n        return\
    \ 0\n    end\n    \n    evens = lst[1 : (length(lst))]\n    odds  = lst[(length(lst)+1):\
    \ end]\n    \n    return sum(evens .* 2)\nend\n</cell>\n<code language=julia-1.5>",
  "  if lst.size == 0 \n    throw(ArgumentError(\"Invalid input\"))\n  else \n   \
    \ sum = 0\n    for el in lst\n      if el%2 == 0 \n        sum += el\n      else\n\
    \        throw(ArgumentError(\"Invalid input\"))\n    end\n    sum\n  end\nend\n\
    </cell>\n<text>\nProblem 4\nGiven the function sum() and the vector [1,2,3,4],\
    \ calculate the sum of the numbers in the vector.", "    evens=filter(x -> x %2==0,\
    \ lst)\n    sum(evens)\nend\n</cell>\n<code language=julia-1.0>\n@code_warntype\
    \ add([4, 2, 6, 7])\n</cell>\n<code language=julia-1.0>\n@code_warntype add([4,\
    \ 2, 6, 7], 8)\n</cell>\n<code language=julia-1.0>", "    evens = lst[findall(x\
    \ -> x % 2 == 0, lst)]\n    odds = lst[findall(x -> x % 2 == 1, lst)]\n    \n\
    \    return (evens + odds)", "    \"\"\"\n    \"\"\"\n    local sum=0\n    for\
    \ i in 0:(length(lst)-1)\n        if ((i mod 2)==0)\n            sum= sum+lst[i]\n\
    \        end\n    end\n    return sum\nend\n    \"\"\"\n    lst = lst[:]\n   \
    \ lst = add(lst)\n    return sum(lst)\nend\n</cell>\n<text>\nExercise: Write a\
    \ function that takes a vector x of any length and returns the dot product (or\
    \ the L2 norm) of x, the vector transposed.", "    evens = lst[1 .% 2 .== 0]\n\
    \    odds = lst[1 .% 2 .!= 0]\n    result = sum(x -> ifelse(x % 2 == 0, x, 0),\
    \ evens) + sum(x -> ifelse(x % 2 != 0, x, 0), odds)\nend", "    even = vec(lst)\n\
    \    odd = vec(lst[1 end:])\n    for e in even\n        if isodd(e) && isodd(odd\
    \ .+ e)\n            odd .+= e\n        end\n    end\n    return odd.sum()\nend\n\
    </cell>\n<code language=julia-1.0>\n@testset \"Add even elements that are at odd\
    \ indices\" begin\n    lst = [4, 2, 6, 7]\n    @test add(lst) == 2\nend\n</cell>\n\
    <text>\nExercise 3.2: Addition of two Vectors\nGiven a non-empty vector of numbers\
    \ lst1, and another non-empty vector of numbers lst2. Add the numbers that are\
    \ present in both lists, i.e. the sum of lst1 and lst2. Return the sum.", "  \
    \  # Your code here\n    return lst[1]\nend\n</cell>\n<text>\nProblem 4b", " \
    \   if length(lst) ==0 \n        throw(ArgumentError(\"empty vector cannot be\
    \ added\"))\n    else\n        result=0\n        for (i,v) in enumerate(lst) \n\
    \            if v%2==0\n                result += v\n            end\n       \
    \ end\n        return result\n    end\nend\nadd(x::Vector{Int64}) = x+add(x[2,end])\n\
    add(x::Vector{Int64},y::Int64) = x+y\nadd(x::Int64) = x\n</cell>\n<text>\nExercise\
    \ 8.4\nWrite a function that prints the elements of a vector with space as a separator.",
  "    if length(lst) == 0 return 0\n    if length(lst) == 1 return lst[1]\n    lst\
    \ = lst.to_array()\n    lst[1] += lst[2]\n    lst[2] += lst[3]\n    lst[3] +=\
    \ lst[4]\n    lst[4] += lst[5]\n    lst[5] += lst[6]\n    lst[6] += lst[7]\n \
    \   lst[7] += lst[8]\n    lst[8] += lst[9]\n    lst[9] += lst[10]\n    lst[10]\
    \ += lst[11]\n    lst[11] += lst[12]\n    lst[12] += lst[13]\n    lst[13] += lst[14]\n\
    \    lst[14] += lst[15]\n    lst[15] += lst[16]\n    lst[16] += lst[17]\n    lst[17]\
    \ += lst[18]\n    lst[18] += lst[19]\n    lst[19] += lst[20]\n    lst[20] += lst[21]\n\
    \    lst[21] += lst[22]\n    lst[22] += lst[23]\n    lst[23] += lst[24]\n    lst[24]\
    \ += lst[25]\n    lst[25] += lst[26]\n    lst[26] += lst[27]\n    lst[27] += lst[28]\n\
    \    lst[28] += lst[29]\n    lst[29] += lst[30]\n    lst[30] += lst[31]\n    lst[31]\
    \ += lst[32]\n    lst[32] += lst[33]\n    lst[33] += lst[34]\n    lst[34] += lst[35]\n\
    \    lst[35] += lst[36]\n    lst[36] += lst[37]\n    lst[37] += lst[38]\n    lst[38]\
    \ += lst[39]\n    lst[39] += lst[40]\n    lst[40] += lst[41]\n    lst[41] += lst[42]\n\
    \    lst[42] += lst[43]\n    lst[43] += lst[44]\n    lst[44] += lst[45]\n    lst[45]\
    \ += lst[46]\n    lst[46] += lst[47]\n    lst[47] += lst[48]\n    lst[48] += lst[49]\n\
    \    lst[49] += lst[50]\n    lst[50] += lst[51]\n    lst[51] += lst[52]\n    lst[52]\
    \ += lst[53]\n", "    \n    \n    if length(lst) == 0 \n        return 0 \n  \
    \  end \n    \n    even = lst[div(length(lst),2)]\n    for i in lst[(div(length(lst),2)+1):length(lst)]\n\
    \        if i%2==0\n            even += i \n        end\n    end\n    return even\n\
    end \n</cell>\n<text>\nExercise: Implement a function for calculating the mean\
    \ of a vector.\nGiven a non-empty vector of floats lst, return the mean of the\
    \ vector.", "    if length(lst) == 0 || lst == []\n        return 0\n    i = 2\n\
    \    while i <= length(lst)\n        if lst[i] % 2 == 0\n            lst[i] =\
    \ lst[i] + lst[i-1]\n        end\n        i = i+1\n    end\n    return lst[1]\n\
    end", "   odd=zeros(1,length(lst)+1)\n   even=zeros(1,length(lst)+1)\n   for i=1:length(lst)\n\
    \       odd[i]=lst[i]%2\n       even[i]=lst[i]/2\n   end\n   odd[2]=1\n   even[2:end-1]=1\n\
    \   return sum(odd.*even)\nend", "    \"\"\"\n    Your code here\n    \"\"\"\n\
    \    for i in length(lst):\n        if i%2 != 0 \n            lst = append(lst,lst[i])\n\
    \        end\n    return length(lst)\nend\n</cell>\n<cell>\n# Test the function\n\
    @test add(Vector{Int64}([2,4,5,7,11]) == 5)\n@test add(Vector{Int64}([2,2,2,2,2])\
    \ == 0)\n</cell>\n<text>\nPart 2: Dealing with Vectors of Vectors\nIn this exercise,\
    \ you'll use another built-in function, zip, which creates a list of pairs from\
    \ two given vectors.", "    if lst.len%2 == 0 \n        return sum(lst[lst.len/2:end])\n\
    \    else\n        return sum(lst[lst.len/2:end-1]) + lst[lst.len/2]\n    end\n\
    end", "    for i in 1:length(lst)\n        if mod(i) == 0 \n            lst[i]\
    \ = lst[i] + lst[mod(i,2)]\n        end\n    end\n    return lst\nend\n</cell>\n\
    <code language=julia-1.5>\nadd([4, 2, 6, 7])\n</cell>\n<code language=julia-1.5>\n\
    add([4, 2, 6, 7], 1)\n</cell>\n<text>\nProblem 3: Problem 3\nGiven a vector of\
    \ integers lst, reverse the elements in lst", "    return reduce(+,filter(odd\
    \ -> odd==true,lst))\nend", "    if length(lst) < 2 \n        throw(DomainError())\n\
    \    end\n    return sum((lst[ii] for ii in 2:2:end))\nend", "    if lst[1]%2\
    \ == 1 return 0\n    else return lst[1] + add(lst[3 : end])\nend", "    even_inds\
    \ = filter( x->x%2==0, lst )\n    lst2 = copy(lst)\n    lst2[even_inds]+=2\n \
    \   sum(lst2)\nend\n</cell>\n<text>\nThe filter() function returns a list containing\
    \ only the elements that satisfy a given test.", "    sum = 0\n    for i in 0\
    \ : (length(lst) - 1) \n        if i % 2 == 0 \n            sum += lst[i] \n \
    \       end \n    end\n    return sum \nend", "    sum(lst[i] for i in indices(lst)\
    \ if isodd(i))\nend\n</cell>\n<text>\nNotice that in the cell below the list lst2\
    \ has only odd indices and so its sum is even.", "    evenIndices = collect(1:length(lst)\
    \ do i \n        i % 2 == 1 \n    end)\n    reduce(+, map(lst[evenIndices], lst[oddIndices]))\
    \ # sum evens\nend\n</cell>\n<code language=julia-1.5>\nadd([4, 2, 6, 7])\n</cell>\n\
    <code language=julia-1.5>\nreduce(+, map(lst[evenIndices], lst[oddIndices])) #\
    \ sum evens\n</cell>\n<text>\nProblem 11\nThe following function will return the\
    \ product of two lists.", "    oddind = 0:length(lst)\n    for i in 1:length(lst)\n\
    \        if lst[i]%2==0\n            lst[oddind[i]] = lst[oddind[i]] + lst[i]\n\
    \        end\n    end\n    return 0\nend\nadd([4, 2, 6, 7])\n</cell>\n<text>\n\
    Write a function called mul which multiplies each integer in a given vector/list\
    \ with the integer at an even index. If the index is odd, then add 1 to it. This\
    \ will involve creating a new list/vector. For example, if given vector/list [4,\
    \ 2, 6, 7], your function will return the list [4, 3, 6, 7]", "    evens = []\n\
    \    for i in 1:length(lst)\n        if mod(i,2) == 0 && lst[i] != 0\n       \
    \     evens.push(lst[i])\n        end\n    end\n    return sum(evens)\nend", " \
    \   even_sum = 0\n    for i in 2..length(lst)\n        if lst[i] % 2 == 0\n  \
    \          even_sum += lst[i]\n        end\n    end\n    return even_sum\nend",
  "    local i\n    local sum = 0\n    for i = 1:length(lst) \n        if mod(lst[i],2)==0\
    \ then \n            sum=sum+lst[i]\n        end \n    end \n    return sum\n\
    end \n</code>\n<|/ a |>\n<| a |>\nIn Matlab this would be\n<code>\nsum([v(i) mod(\
    \ v, 2 )==0 | i \u2208 1:length(v) ]\n</code>\n<|/ a dscore=1 tags=functional-programming,vector,julia\
    \ |>\n<| c |>\nI think that is a syntax error (the `|` should be a `&&`).\n<|/\
    \ c |>\n<| c |>\nIt doesn't need to be a syntax error, that's a typo. `v(i)` is\
    \ a valid construct. In fact, it's used here to denote the index of a vector `v`\
    \ as `i`, so you might want to change that.\n<|/ c |>\n<| a tags=functional-programming,vector,julia\
    \ dscore=1 |>\nYou can try to use filter function in the following way\n<code>\n\
    sum(filter(x -> mod(x,2)==0, v))\n</code>\n<|/ a |>\n<| c |>\n`filter!` would\
    \ be more idiomatic here.\n<|/ c |>\n<| a tags=functional-programming,vector,julia\
    \ dscore=1 |>\nI like working with comprehensions just as much as possible. This\
    \ would give you a list that you could pass to sum:\n<code>", "    for k in 1\
    \ : length(lst) \n        lst[k] := lst[k] + lst[k-1] % 2 \n    end\n    return\
    \ lst[1]\nend\n</code>\nYou can even write it with a nested for loop:\n<code>",
  "    \n    count = 0\n    for (i in 1:length(lst))\n        if lst[i] % 2 == 1\n\
    \            lst[count] = lst[i] + lst[i+1]\n            count += 1\n        end\n\
    \    end\n    \n    return lst[count]\nend", "    sum = 0\n    for i in 0 :: length(lst)-1\n\
    \        if i%2 == 1\n            sum += lst[i]\n        end\n    end\n    return\
    \ sum\nend\n</cell>\n<text>\nQuestion 7: Problem 4b\nGiven a vector of numbers\
    \ lst. find the largest number in lst that is a power of 2 using the formula:\
    \ log2(N) = (N-1)log2(N)/2", "    sum = zero(Int64)\n    for i in 2:length(lst)\n\
    \        if lst[i] % 2 ==0\n            sum += lst[i]\n        end\n    end\n\
    \    return sum\nend\n</cell>\n<text>\nExercise 14\nCreate a function that calculates\
    \ the sum of all numbers divisible by 2.", "    if length(lst) == 0 return 0\n\
    \    local sum = 0\n    for ii in lst do sum += ii end\n    return sum\nend",
  "    if lst.size==0\n        return 0\n    elseif lst.size==1\n        return lst[1]\n\
    \    else\n        even = add(lst[2:2:end])\n        odd = add(lst[2:1:end])\n\
    \        return even + odd\n    end\nend", "    \"\"\"\n    \n    Examples:\n\
    \    >>> add(Vector{Int64}(4, 2, 6, 7))\n    2\n    \"\"\"\n    return lst[mod(lst,\
    \ 2)] + lst[mod(lst+1, 2)]\nend\n</code>\n<|/ a |>\n<| c |>\nThanks for your response.\
    \ Your code is working fine and i got the required output. Thanks a lot for your\
    \ suggestions.\n<|/ c |>\n<| c |>\nNo worries, glad I could help :)\n<|/ c |>\n\
    <| a tags=arrays,julia,linear-algebra,performance dscore=0 |>\nHere is an implementation\
    \ using broadcasting using mod on the indexes. I believe it is faster than the\
    \ solution using mapslices.\n<code>", "    n=0\n    for i in 2:length(lst)\n \
    \       if lst[i]%2!=0\n            lst[n]=lst[i]\n            n+=1\n        else\n\
    \            lst[n]= lst[i]+2\n        end\n    end\n    return lst[2]\nend\n\
    </cell>\n<text>\nExercise 10\nThe function add_with_evens takes a list of integers\
    \ and returns the sum of the even elements at odd indices starting from 0. For\
    \ example, add_with_evens([4, 2, 6, 7]) should return 2. Use nested for loops\
    \ to do this.", "    even = [i for i in lst[::2] if i%2==0]\n    odd =  [i for\
    \ i in lst[1::2] if i%2==1]\n    return sum(even) + sum(odd)\nend\n</cell>\n<code\
    \ language=julia-1.5>\nadd([4, 2, 6, 7])\n</cell>\n<code language=julia-1.5>",
  "        \n    even=[]\n    for j in 1:length(lst)\n        if lst[j]%2==0\n   \
    \         push!(even,j)\n        end\n    end\n    return sum(lst[even],lst[even]==0?0:(lst[even]-1)/2)\n\
    end", "    for i in 2:length(lst) \n        if lst[i] % 2 != 0 \n            lst[i\
    \ - 1] += lst[i]\n        end\n    end\n    return lst[1]\nend", "    return sum(lst[1::2])\n\
    end\n</cell>\n<text>\nExercise 20", "    \"\"\"\n    \n    \n    \"\"\"\n    This\
    \ function takes in a vector and returns the sum of the even elements that are\
    \ at odd indices.\n    \"\"\"", "    evenIndexes = getIndices(lst)\n    return\
    \ sum(lst[evenIndexes])\nend\n</cell>\n<text>\nQuestion 4\nComplete the function\
    \ sumEvenIndexesInVec that takes in a vector and returns only the summation of\
    \ the even indices that are in the vector.", "    even_indexes = findind(lst,\
    \ iszero)\n    odd_indexes = findind(lst, isone)\n    for index in even_indexes,odd_indexes\n\
    \        if index == length(lst)\n            return lst[index]\n        end\n\
    \        if mod(index, 2) == 0\n            lst[index] = lst[index] + lst[index\
    \ + 1]\n            lst[index + 1] = 0\n        end\n    end\n    return lst[length(lst)]\n\
    end", "    evens = 0\n    for i in lst\n        evens += i%2 == 0 ? i : 0\n  \
    \  end\n    return evens\nend\n</cell>\n<text>\nExercise 3\nComplete the function\
    \ called get_average. Given the vector vect with one number in it, your function\
    \ should return the average of that number only", "    count=1\n    for i in 1:length(lst)\n\
    \        if lst[i]==1 && lst[(i+1)%length(lst)]==0\n            count=count+1\n\
    \        end\n    end\n    return count\nend", "    \"\"\"\n    Arguments\n  \
    \  ---------\n    lst : Vector{Int64}\n        Vector{Int64}\n    Returns\n  \
    \  -------\n    sum : int\n    \"\"\"\n    sum = 0\n    for i in lst\n       \
    \ if i %2 == 1\n            sum += i\n        end\n    end\n    return sum\nend\n\
    </cell>\n<code language=julia-1.0>\nadd([4, 2, 6, 7])\n</cell>\n<code language=julia-1.0>\n\
    add([4, 2, 6, 7])\n</cell>\n<code language=julia-1.0>\nadd([4, 2, 6, 7])\n</cell>\n\
    <code language=julia-1.0>\nadd([4, 2, 6, 7])\n</cell>\n<code language=julia-1.0>\n\
    add([4, 2, 6, 7])\n</cell>\n<code language=julia-1.0>\nadd([4, 2, 6, 7])\n</cell>\n\
    <code language=julia-1.0>\nadd([4, 2, 6, 7])\n</cell>\n<code language=julia-1.0>\n\
    add([4, 2, 6, 7])\n</cell>\n<code language=julia-1.0>\nadd([4, 2, 6, 7])\n</cell>\n\
    <code language=julia-1.0>\nadd([4, 2, 6, 7])\n</cell>\n<code language=julia-1.0>\n\
    add([4, 2, 6, 7])\n</cell>\n<code language=julia-1.0>\nadd([4, 2, 6, 7])\n</cell>\n\
    <code language=julia-1.0>\nadd([4, 2, 6, 7])\n</cell>\n<code language=julia-1.0>\n\
    add([4, 2, 6, 7])\n</cell>\n<code language=julia-1.0>\nadd([4, 2, 6, 7])\n</cell>\n\
    <code language=julia-1.0>\nadd([4, 2, 6, 7])\n</cell>\n<code language=julia-1.0>\n\
    add([4, 2, 6, 7])\n</cell>\n<code language=julia-1.0>\nadd([4, 2, 6, 7])\n</cell>\n\
    <code language=julia-1.0>\nadd([4, 2, 6, 7])\n</cell>\n<code language=julia-1.0>\n\
    add([4, 2, 6, 7])\n</cell>\n<code language=julia-1.0>\nadd([4, 2, 6, 7])\n</cell>\n\
    <code language=julia-1.0>\nadd([4, 2, 6, 7])\n</cell>\n<code language=julia-1.0>\n\
    add([4, 2, 6, 7])\n</cell>\n<code language=julia-1.0>\nadd([4, 2, 6, 7])\n</cell>\n\
    <code language=julia-1.0>\nadd([4, 2, 6, 7])\n</cell>\n<code language=julia-1.0>\n\
    add([4, 2, 6, 7])\n</cell>\n<code language=julia-1.0>\n", "    return sum(lst[2:end])\
    \ \nend \n</cell>\n<text>\nQuestion 16. Find the element at which the given number\
    \ appears in the vector", " \n    sum = 0\n \n    for i in 2..length(lst) \n \
    \       if lst[i]%2 == 1 \n            sum+=(lst[i-1])\n        end\n    end\n\
    \ \n    return sum\nend\n</code>\nThis code can be improved in many ways. I did\
    \ not do that. You should try to improve it.\n<|/ a tags=julia,performance |>\n\
    <| c |>\nYour code is correct, but there are two minor mistakes (and an actual\
    \ mistake). The first is in your `add` function, the `sum` variable is defined\
    \ outside the loop. This means it is reinitialized every time. The second is in\
    \ your `add` function, the `sum+=(lst[i-1])` line should be outside the `if` statement,\
    \ to make it work. As it is, the code is only adding one item to the sum.\n<|/\
    \ c |>\n<| c |>\nI did not put any `sum` outside the loop as I thought it was\
    \ an example. But you are right it is better to put it outside. Thanks!\n<|/ c\
    \ |>\n<| c |>\nThanks for the feedback, I've corrected my code and updated the\
    \ answer accordingly.\n<|/ c |>\n<| c |>\n`sum` is defined outside the loop because\
    \ it's defined outside the loop, but is then reinitialized inside the loop. `i`\
    \ will end up at 1 every time inside the loop, and you'll just keep adding the\
    \ first item to `sum` over and over again. Moving `sum+=(lst[i-1])` outside the\
    \ loop would fix that, but that would mean you'd be adding `i-1` items to the\
    \ sum every time, when `i` would end up at 0 every time instead.\n<|/ c |>\n<|\
    \ c |>\nThanks for pointing that out. I've corrected my code and updated the answer\
    \ accordingly.\n<|/ c |>\n<| a |>\nI guess you can make some improvements by avoiding\
    \ allocations and using iterators instead.\n<code>\njulia> add = reduce(+, map(x\
    \ -> 2*x%2 ? x-1:0, 2:length(lst)-1))\nadd (generic function with 1 method)",
  "    evens = filter((i->i%2==1), lst)\n    evens_odd = filter((i->i%2!=1), lst)\n\
    \    evens_odd_sum = reduce(+,evens_odd)\n    return evens_odd_sum\nend\n</cell>\n\
    <text>\nExercise 4\nWrite a function that checks whether a number is a multiple\
    \ of 10 or not", "    even_inds = (lst:>0)\n    odds = lst[even_inds]\n    evens\
    \ = lst[even_inds .* ((even_inds - 1) .== 1)]\n    return sum(evens)\nend\n</cell>\n\
    <text>\nExercise 2: remove Odd elements from a list\nGiven a non-empty list of\
    \ numbers, remove all odd numbers from the list and return the resulting list.\
    \ Odd numbers are defined as those that are placed after a non-negative integer\
    \ for which no greater number is placed before it", "    for i in 2:length(lst)\n\
    \        lst[i] = lst[i] + (lst[(i-1)] * (i%2==1))\n    end\n    \n    return\
    \ lst[1]\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis works great for even\
    \ numbers, but doesn't work for odd numbers, i.e. returns 0 instead of 2. The\
    \ function would need to return 2 in that case.\n<|/ c |>\n<| c |>\nHi, I have\
    \ edited my code to return even numbers. Thanks for pointing it out.\n<|/ c |>\n\
    <| a dscore=0 tags=arrays,julia |>\nHere's a general solution which does not require\
    \ you to modify the input:\n<code>", "    even::Int64 = 0\n    for i in 1:length(lst)\n\
    \        if lst[i] % 2 == 0\n            even += lst[i]\n        end\n    end\n\
    \    return even\nend\n</cell>\n<code language=julia-1.6>", "    lst=vec(lst)\n\
    \    even=[i for i in lst if i%2==0]\n    odd=[i for i in lst if i%2==1]\n   \
    \ \n    sum(even)+sum(odd)\nend", "    evensum = 0\n    for element in lst\n \
    \       if element % 2 == 0\n            evensum += element\n        end\n   \
    \ end\n    return evensum\nend\n</code>\nThen we can do \n<code>\nadd([4, 2, 6,\
    \ 7])\n</code>\nOr we can just do \n<code>\nsum([4, 2, 6, 7])\n</code>\n<|/ a\
    \ tags=julia,list |>\n<| c |>\nThe reason I asked was because I thought there\
    \ would be a more efficient way of doing this. But I guess there isn't.\n<|/ c\
    \ |>\n<| c |>\nYes, there is. The answer has been edited.\n<|/ c |>\n<| a dscore=0\
    \ |>\nSince you have already mentioned that you are interested in how to do this\
    \ without using any packages, here's how you can do it.\n<code>\njulia> a = [1,2,3,4,5,6]\n\
    6-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6", "    evens = lst[findall(lst.>0)\
    \ % 2 == 0]\n    evensum = sum(evens)\n    return evensum\nend\n</cell>\n<code\
    \ language=julia-0.6>\nadd([4, 2, 6, 7])\n</cell>\n<text>\nExercise 3: add\nImplement\
    \ add that takes in a list of pairs of integers and sums the integers of the first\
    \ element in the pair.\nFor example, add(Pair(1,2)) = 3.", "    # Your code here\n\
    \    return 0\nend", "    if length(lst) < 2\n        return Int64(0)\n    \n\
    \    even = lst[1::2]\n    odd = lst[2::2]\n    \n    return sum(even) + sum(odd)\n\
    end", "    evens_odds = findall(x -> mod(x, 2) == 0, lst)\n    evens = filter(x\
    \ -> x % 2 == 0, evens_odds)\n    evens = evens[2:end] # remove the two 0s\n \
    \   evens = vcat(evens, lst)\n    return sum(evens)\nend", "  evens = map(x->mod(x,2),\
    \ lst)\n  sum(evens)\nend", "    lst_even = lst[findall(x -> x%2==0, lst)]\n \
    \   return sum(lst_even)\nend # end add()", "    count = 0\n    for i in 0 : (length(lst)-1)\
    \ / 2\n        if lst[i] % 2 == 0\n            lst[count] = lst[i] + lst[i]\n\
    \            count += 1 \n        end\n    end\n    return lst[count] \nend\n\
    </cell>\n<code language=julia-1.0>\nadd([4, 2, 6, 7])\n</cell>\n<code language=julia-1.0>",
  "    return sum(lst[1::2])\nend\n</cell>\n<text>\nThe next two functions compute\
    \ the sum of the numbers from 1 to n (inclusive)\nThey use an iterator to create\
    \ the range of numbers from 1 to n (inclusive).", "    count=0\n    even=false\n\
    \    for x in lst\n        if x%2==0 then \n            even=true\n        end\n\
    \        if even==true && x%2==0 then \n            count=count+x\n          \
    \  even=false\n        end\n    end\n    return count\nend", "    \"\"\"\n   \
    \ Your code here\n    \"\"\"\n    return sum([i for i in lst[1::2]]) + sum(lst[1::2]+[i\
    \ for i in lst[::2]])\nend\n</cell>\n<text>\nPart B (1 point)\nWrite a function\
    \ that adds the even elements of two vectors.", "    sum = 0\n    for i=2:length(lst)\n\
    \        if lst[i] % 2 != 0 \n            sum += lst[i]\n        end\n    end\n\
    \    return sum\nend\n</cell>\n<text>\nExercise 3", "    if lst[1] == 0\n    \
    \    return lst[2]\n    else\n        return lst[2] + add(lst[3:end])\n    end\n\
    end", "    if length(lst) < 2 \n        return 0 \n    end\n    odd = lst[end-1]\n\
    \    even = lst[end-2]\n    lst[end-1:end] = append(odd,even,lst[end-1:end])\n\
    \    return lst[end]\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
