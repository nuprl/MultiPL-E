name: HumanEval_110_exchange
language: jl
prompt: "\"\"\"In this problem, you will implement a function that takes two vectors\
  \ of numbers,\n    and determines whether it is possible to perform an exchange\
  \ of elements\n    between them to make lst1 a vector of only even numbers.\n  \
  \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
  \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
  \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
  \ \"NO\".\n    For example:\n    >>> exchange([1, 2, 3, 4], [1, 2, 3, 4])\n    \"\
  YES\"\n    >>> exchange([1, 2, 3, 4], [1, 5, 3, 4])\n    \"NO\"\n    It is assumed\
  \ that the input vectors will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
  \ lst2::Vector{Int64})::String \n"
tests: "using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1,\
  \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
  \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
  @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
  \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1])\
  \ == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
completions: ["    \n    i = 0\n    j = length (lst2)\n    \n    while i < j\n   \
    \     if lst1[i] == lst2[j]\n            j -= 1\n        elseif lst1[i] > lst2[j]\n\
    \            i += 1\n        elseif lst1[i] < lst2[j]\n            j += 1\n  \
    \      else \n            return \"NO\"\n        end\n    end\n    return \"YES\"\
    \nend\n</cell>\n<code language=julia-1.5>", '    #Your code goes here', "    if\
    \ length(lst1) != length(lst2) return \"NO\"\n    \n    even = map(x -> mod(x,\
    \ 2), lst1)\n    even = filter(x -> x != 0, even)\n    \n    if length(even) !=\
    \ length(lst1) return \"NO\"\n    \n    if even == lst1 \"YES\"\nend", "    #\
    \ your code here\nend\n</cell>\n<code language=julia-1.5>", "  \n  return \"NO\"\
    \nend\n</cell>\n<code language=julia-1.5>\nexchange([1,2,3],[3,6,5,4])\n</cell>\n\
    <text>\nThe second part of the puzzle begins with a function that returns true\
    \ if the first vector is evenly divisible by all elements of the\nsecond vector,\
    \ and false otherwise.", " \n#your code here\n \nend\n</cell>\n<text>\nPart 2:\
    \ Exchange elements and return \"YES\" or \"NO\"\nNow implement the exchange function\
    \ so that it exchanges elements between the given vectors.\nYou will implement\
    \ this using a loop.\nHere are some helpful links:", "    \n    for i in lst1\
    \ do \n        if i in lst2 \n            lst2.remove(i)\n        else\n     \
    \       return \"NO\"\n    end\n    return \"YES\"\nend\n\"\"\"\n    Implement\
    \ the function `make_even` that takes an array of integers and returns\n    a\
    \ vector of only even numbers from it.\n\"\"\"", "    even = [x for (x,y) in zip(lst1,lst2)\
    \ if x == 2*y]\n    if length(even) == 0\n        return \"NO\"\n    else\n  \
    \      return \"YES\"\n    end\nend\n</code>\nFor anyone who can't find where\
    \ to click on this function in Julia, you can just right-click on it and select\
    \ \"Copy\" from the menu, and then select \"Paste\" from the menu and copy the\
    \ text to a file. \n<code>", "    # Your code here\nend", '"""', "    \n    \n\
    \    \"\"\"\n    Write your code here\n    \"\"\"\nend\n</cell>\n<code language=julia-1.1>",
  "    l1 = length(lst1) \n    l2 = length(lst2)\n    if l1 > 0 && l2 > 0 && l1 ==\
    \ l2 \n        lst3 = Vector{Int64}(lst1)\n        lst4 = [0 for i in 1:l1]\n\
    \        for j=1:l1\n            if lst3[j] %2 == 0 \n                lst4[j]\
    \ = lst3[j]\n            end\n        end\n        if all(lst_even == lst4)\n\
    \            return \"YES\"\n        else\n            return \"NO\"\n       \
    \ end\n    end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nHi, thank you for your\
    \ reply. Yes, I already tried both codes, but neither one works with vectors of\
    \ different sizes. For example, `exchange([2, 3], [])` will result in an error\
    \ in the first case, but not in a second one. I know that `if all(lst_even ==\
    \ lst4)` will result in an error if the vectors do not have the same length, but\
    \ I don't know how to make that check work properly here.\n<|/ c |>\n<| c |>\n\
    Hi, I've just edited my answer, I hope this helps you out.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", "    local new_lst = lst1\n    for i in new_lst \n        if mod(i,\
    \ 2) == 0 \n            new_lst[new_lst.index(i)] = mod(i, 2)\n        end\n \
    \   end\n    if sum(new_lst) == sum(lst1) \n        return \"YES\"\n    else\n\
    \        return \"NO\"\n    end\nend", "    if length(lst1) != length(lst2) \n\
    \        return \"NO\" \n    end", "    if length(lst1) != length(lst2)\n    \
    \    return \"NO\"\n    end\n    \n    even = Int64[]\n    odd = Int64[]\n   \
    \ \n    for i in eachindex(lst1)\n        if i % 2 == 0\n            even += [i]\n\
    \        else\n            odd += [i]\n        end\n    end\n    \n    if length(\
    \ setdiff(even, odd) ) == 0\n        return \"YES\"\n    else\n        return\
    \ \"NO\"\n    end\nend\n</cell>\n<code language=julia-1.0>\nexchange([1, 2, 3,\
    \ 4], [1, 2, 3, 4])\n</cell>\n<code language=julia-1.0>\nexchange([1, 2, 3, 4],\
    \ [1, 5, 3, 4])\n</cell>\n<text>\nProblem 4\nWrite a function that takes in two\
    \ vectors of numbers and returns true if the sum of the numbers in the vectors\
    \ is evenly divisible by the sum of the numbers in the other vector.\n    For\
    \ example, if the numbers are [1, 2, 3, 4] and [2, 4, 6, 8], the function should\
    \ return true because 2 + 4 + 6 = 18.\n    If it returns false, it should return\
    \ false because the sum of the numbers in the vectors are not evenly divisible.\n\
    \    Use Int64[] to represent the vectors.\n    For example:\n    >>> isEven([1,\
    \ 2, 3, 4], [2, 4, 6, 8])\n    True\n    >>> isEven([1, 2, 3, 4], [2, 4, 6, 8])\n\
    \    True\n    >>> isEven([1, 2, 3, 4], [2, 8, 6, 12])\n    False\n    \"\"\"",
  "    if length(lst1)==0 || length(lst2)==0 \n        return \"NO\"\n    end\n  \
    \  \n    even1 = length(lst1[2:end-1])/2\n    even2 = length(lst2[2:end-1])/2\n\
    \    \n    # exchange the even positions of both lists\n    lst1[2:end-1], lst2[2:end-1]\
    \ = lst2[2:end-1], lst1[2:end-1]\n    \n    # return the result\n    if length(lst1[2:end-1])\
    \ == 0 \n        return \"NO\"\n    else \n        return \"YES\"\n    end\nend",
  '    #your code here', "    \n    \n    #initialize result as false\n    possible=false\n\
    \    \n    #loop through lists \n    for i in 1:length(lst1)\n        if length(lst1)==length(lst2)\n\
    \            if lst1[i]%2==0 && lst2[i]%2==0\n                possible=true\n\
    \                break\n            else\n                possible=false\n   \
    \             break\n        end\n    end\n    #output result\n    if possible\n\
    \        return \"YES\"\n    else\n        return \"NO\"\n    end\nend", "   \
    \ if (length(lst1)==0) || (length(lst2)==0) || length(lst1)==length(lst2) \n \
    \       return \"NO\"\n    end\n    cnt = 0\n    for i in 1:length(lst1)\n   \
    \     if lst2[i] % 2==0\n            lst1[cnt] = lst2[i]\n            cnt += 1\n\
    \        end\n    end\n    return \"YES\"\nend\n</cell>\n<code language=julia-0.5>\n\
    exchange([1, 2, 3, 4], [1, 2, 3, 4])\n</cell>\n<text>\nTask 6 (15 Points)", " \
    \    return \"NO\"\nend\n</cell>\n<text>\nTests\nRun the cell below to test the\
    \ exchange function.", "</code>\nThe input vectors cannot be empty, but they should\
    \ contain integers (not NaN).\nThe function will return the string \"YES\" if\
    \ the exchange is possible,\n    and return \"NO\" otherwise.\n<code>\n\"\"\"\
    In this problem, you will implement a function that takes two vectors of numbers,\n\
    \    and determines whether it is possible to perform an exchange of elements\n\
    \    between them to make lst1 a vector of only odd numbers.\n    There is no\
    \ limit on the number of exchanged elements between lst1 and lst2.\n    If it\
    \ is possible to exchange elements between the lst1 and lst2 to make\n    all\
    \ the elements of lst1 to be odd, return \"YES\".\n    Otherwise, return \"NO\"\
    .\n    For example:\n    >>> exchange([1, 2, 3, 4], [1, 2, 3, 4])\n    \"NO\"\n\
    \    >>> exchange([1, 2, 3, 4], [1, 5, 3, 4])\n    \"YES\"\n    It is assumed\
    \ that the input vectors will be non-empty.\n    \"\"\"", "    \nend", "    \n\
    \    \n    if length(lst1) != length(lst2)\n        return \"NO\"\n    end\n \
    \   \n    \n    for i in eachindex(lst1)\n        if mod(lst1[i],2) == 0 && mod(lst2[i],2)\
    \ == 0\n            return \"YES\"\n        end\n    end\n    \n    return \"\
    NO\"\nend\n</cell>\n<code language=julia-1.5>\n@assert exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4])==\"YES\"\n@assert exchange([1, 2, 3, 4], [1, 5, 3, 4])==\"NO\"\
    \n@assert exchange([2, 3, 4, 5], [1, 4, 3, 5])==\"YES\"\n@assert exchange([1,\
    \ 2, 3, 4], [2, 3, 4, 5])==\"NO\"\n</cell>\n<text>\nQuestion 4\nWrite a function\
    \ called exchange2(lst1, lst2) that takes two vectors of numbers, and determines\
    \ whether it is possible to perform an exchange of elements from lst1 to be even\
    \ in lst2\nThe function exchange2(lst1, lst2) will take two vectors of numbers,\
    \ where each element of lst2 is a subset of lst1.\nFor example, exchange2([1,\
    \ 4, 2, 5], [2, 3, 5, 1]) returns YES, because we can exchange a number from lst1\
    \ into lst2 by swapping the first and second elements from lst1.\nFor example,\
    \ if lst1 = [1,2,3,4,5,6] and lst2 = [2,4,6,5,1,3] then exchange2([1, 4, 2, 5],\
    \ [2, 3, 5, 1]) returns YES.\nThis function should return \"NO\" when lst1 and\
    \ lst2 are empty vectors or when lst1 and lst2 are not the same length.\nIn this\
    \ problem, you will implement a function that takes two vectors of numbers, and\
    \ determines whether it is possible to perform an exchange of elements from lst1\
    \ to be even in lst2.\nThere is no limit on the number of exchanged elements between\
    \ lst1 and lst2.\nIf it is possible to exchange elements from lst1 to be even\
    \ in lst2, return \"YES\".\nOtherwise, return \"NO\".\nFor example:\n>>> exchange2([1,\
    \ 2, 3, 4], [2, 3, 4, 5])\n\"YES\"\n>>> exchange2([1, 2, 3, 4], [1, 2, 3, 4])\n\
    \"NO\"\n>>> exchange2([1, 2, 3, 4], [1, 5, 3, 4])\n\"NO\"\nIt is assumed that\
    \ the input vectors will be non-empty.\nWrite a function called exchange2(lst1,\
    \ lst2) that takes two vectors of numbers, and determines whether it is possible\
    \ to perform an exchange of elements from lst1 to be even in lst2\nThe function\
    \ exchange2(lst1, lst2) will take two vectors of numbers, where each element of\
    \ lst2 is a subset of lst1.\nFor example, exchange2([1, 4, 2, 5], [2, 3, 5, 1])\
    \ returns YES, because we can exchange a number from lst1 into lst2 by swapping\
    \ the first and second ", "    even = findall(x -> x % 2 == 0, lst1)\n    if length(even)\
    \ >=length(lst1)\n        return \"NO\"\n    end", "# function exchange(lst1,\
    \ lst2)\n    \n    #println(\"First vector is: \", lst1)\n    #println(\"Second\
    \ vector is: \", lst2)", '# your code here', "    if length(lst1) != length(lst2)\
    \ \n        return \"NO\"\n    even_inds = findall(x->(x%2) == 0, lst1)\n    odd_inds\
    \ = findall(x->(x%2) != 0, lst1)\n    even_odds = intersect(even_inds, odd_inds)\n\
    \    if length(even_odds) == 0 \n        return \"NO\"\n    even_inds -= even_odds\n\
    \    even = filter(x -> x in even_inds, lst1)\n    odd = filter(x -> x not in\
    \ even_inds, lst1)\n    even = union(even, lst1)\n    lst1 -=\n    odd = union(odd,\
    \ lst2)\n    return isequal(lst1, even) ? \"YES\" : \"NO\"\nend\n</cell>\n<code\
    \ language=julia-1.0>\nexchange([1, 2, 3, 4], [1, 2, 3, 4])\n</cell>\n<text>\n\
    Exercise 6", "    if (length(lst1)==0 || length(lst2)==0) return \"NO\"\n    even=trues(length(lst1))\n\
    \    even[findall(lst1 .== even)] .= false\n    even[findall(lst2 .== even)] .=\
    \ false\n    if (any(even))\n        return \"YES\"\n    else\n        return\
    \ \"NO\"\n    end\nend\n</code>\nExplanation\nThe function exchange() works as\
    \ follows:\nFirst, it creates a vector called even, which has the same length\
    \ as lst1, which contains true values for all elements in lst1, and false for\
    \ all elements in lst1.\nThen, it sets the elements of all elements in lst1 that\
    \ are true to false, and vice versa, i.e. all even numbers in lst1 are false and\
    \ all odd numbers in lst1 are true.\nFinally, it checks whether all the elements\
    \ in lst1 are even, i.e. if there are any elements that are true in the vector\
    \ even.\n<|/ a dscore=1 tags=arrays,function,julia,vector,string |>\n<| c |>\n\
    Hey, thank you for the detailed answer. Yes, this was my attempt at solving this\
    \ problem and I tried to do it in Julia, but it just didn't work. I was looking\
    \ at your solution and I see a lot of ways to simplify my code. Thanks again!\n\
    <|/ c |>\n<| a dscore=1 tags=arrays,function,julia,vector,string |>\nYou can use\
    \ isodd in place of mod like so\n<code>\nisodd(x) = x % 2 == 1\n</code>\nand replace\
    \ all of your find and where by isodd and ==1 like so\n<code>\neven = find isodd\
    \ lst1\neven = where isodd lst1\n</code>\nThis will not give you the desired result,\
    \ but it will speed things up a little bit.\n<|/ a |>\n<| c |>\nHey, thanks for\
    \ the suggestion. I tried it out and it was a little faster. Thanks!\n<|/ c |>\n\
    <| a dscore=1 |>\nThe answer from Matt P is correct.\nAnother way is to check\
    \ the number of even numbers from the first vector in the second vector, for example:\n\
    <code>\nisodd(x) = x % 2 == 1\niseven = findall(x->isodd(x), lst2)\n</code>\n\
    Then all even numbers from lst1 will be found in lst2 vector, and you can check\
    \ whether all these numbers are even in one by one and do something.\n<|/ a tags=arrays,function,julia,vector,string\
    \ |>\n<| a dscore=1 tags=arrays,function,julia,vector,string |>\nI to", "    if\
    \ length(lst1) != length(lst2)\n        return \"NO\"\n    end", "    if length(lst1)\
    \ != length(lst2)\n        return \"NO\"\n    else\n        flag = True\n    \
    \    for i in 1:length(lst1)\n            if i % 2 == 0\n                lst1[i]\
    \ = evenly(lst1[i])\n                lst2[i] = evenly(lst2[i])\n            end\n\
    \        end\n        for i in 1:length(lst1)\n            if !(length(lst1[i])\
    \ == length(lst2[i]))\n                flag = false\n                break\n \
    \           end\n        end\n        return flag ? \"YES\" : \"NO\"\n    end\n\
    end\n</cell>\n<text>\nLet's see this function in action:", "    if length(lst1)\
    \ != length(lst2)\n        return error(\"exchange expects two vectors of equal\
    \ length\")\n    \n    \n    \n    \n    \nend\n</cell>\n<text>\nQuestion 13\n\
    Write a function that takes two vectors of integers lst1 and lst2, and returns\n\
    the number of elements in lst1 that are not present in lst2.\nFor example:\n \
    \   >>> missing([1, 2, 3, 4, 5, 6], [4, 5, 6])\n    3\n    \nIt is not allowed\
    \ to use loops and your function should run in $O(n)$ (where $n$\nis the length\
    \ of lst1).\n\"\"\"", "    for i1 = 1:length(lst2)\n        if lst1[i1]%2 == 0\
    \ && lst2[i1]%2 == 0\n            lst1[i1]%2 == 0 ? 'YES' : 'NO'\n        elseif\
    \ lst1[i1]%2 == 0 && lst2[i1]%2 != 0\n            return 'NO'\n        elseif\
    \ lst1[i1]%2 != 0 && lst2[i1]%2 != 0\n            return 'NO'\n        elseif\
    \ lst1[i1]%2 == 0 && lst2[i1]%2 == 0\n            return 'NO'\n        else\n\
    \            return 'NO'\n        end\n    end\nend\n</code>\nThe above code only\
    \ checks for even numbers. The code below checks for an odd number and an even\
    \ number, and returns \"YES\" if the two vectors have an odd number of even numbers\
    \ (this could be done more efficiently by storing the last number in an array,\
    \ and checking if lst1[end] % 2 == 0)\n<code>", "</code>\nThis is what I have\
    \ so far. I'm just wondering if anyone has any better ideas or knows how I can\
    \ improve this code.\n<|/ q tags=julia |>\n<| a dscore=2 tags=julia |>\nThe question\
    \ is about implementing some form of arithmetic on a vector. There is a standard\
    \ library module which provides some useful functions like sum and prod which\
    \ should give you a hint on how to go about implementing your function. As an\
    \ example, the following code implements the function you describe.\n<code>\n\
    using LinearAlgebra", "    # Your code here\n    if length(lst1) != length(lst2)\n\
    \        return \"NO\"\n    end", "\"\"\"\n    lst1 should be a vector of numbers\n\
    \    lst2 should be a vector of numbers", "    if length(lst1)!=length(lst2) \n\
    \        return \"NO\" \n    \n    even=trues(length(lst1))\n    for i in 1:length(lst1)\
    \ \n        if lst2[i]%2==0 \n            even[i] = false \n        end\n    \n\
    \    first=0\n    second=length(lst1)\n    while first < second \n        if even[first]\
    \ \n            first = first + 1 \n        else \n            second = second\
    \ - 1 \n        end\n    end \n    if first >= second \n        return \"NO\"\
    \ \n    end", "    \n    if length(lst1) == length(lst2) \n        return \"NO\"\
    \n    end\n    for v in lst1 \n        if v % 2 == 0 \n            return false\n\
    \        end\n    end\n    for v in lst2 \n        if v % 2 == 0 \n          \
    \  return false\n        end\n    end\n    return true\nend\n</cell>\n<text>\n\
    3.4. Checking the Exchange of Elements\nRecall that the elements of a list can\
    \ be accessed by using an index. The index of an element is its position in the\
    \ list.", '    return # insert your code', "    \n    even1 = count(a => a%2 ==\
    \ 0, lst1)\n    even2 = count(a => a%2 == 0, lst2)\n    if even1 == even2\n  \
    \      return \"YES\"\n    else\n        return \"NO\"\n    end\nend", '    #your
    code here', "#=\n:nodoc:\n    Given two non-empty vectors of Int64s, return \"\
    YES\" if it is possible\n    to exchange elements to get lst1 as a vector of only\
    \ even numbers,\n    otherwise \"NO\".\n=#\n    if length(lst1) != length(lst2)\n\
    \        return \"NO\"\n    end\n    \n    evens = [x for (x,y) in zip(lst1, lst2)\
    \ if y == even(x)] #a list of the even numbers from lst1\n    \n    #check if\
    \ even numbers can be exchanged by checking if all elements of lst1 are even numbers.\n\
    \    if all(x -> even(x) == true, lst1)\n        return \"YES\"\n    else\n  \
    \      return \"NO\"\n    end\nend\n</cell>\n<text>\nImplement the function reorder_in_place\
    \ that takes in two vectors of Int64s and returns nothing if all the elements\
    \ can be exchanged and returns \"NO\" if not.\nThis means that this function should\
    \ work on any vector and should return a vector where all elements of lst1 can\
    \ be exchanged, else return \"NO\".\nFor example:\n>>> reorder_in_place([1, 2,\
    \ 3, 4], [1, 4, 3, 2])\n[1, 4, 3, 2]\n>>> reorder_in_place([1, 2, 3, 4], [1, 5,\
    \ 3, 4])\n\"NO\"\nIt is assumed that the input vectors will not contain duplicates.",
  "    \n    lst1_even = Vector{Int64}(copy(lst1))\n    lst2_even = Vector{Int64}(copy(lst2))\n\
    \    \n    for i = 1:length(lst1)\n        if lst1[i] % 2 == 0 && lst2[i] % 2\
    \ == 0\n            lst2_even[findall(lst2_even .== lst1[i])] = lst2_even[findall(lst2_even\
    \ .== lst1[i])] - 2\n            lst1_even[findall(lst1_even .== lst1[i])] = lst1_even[findall(lst1_even\
    \ .== lst1[i])] + 2\n        end\n    end\n    if lst1 == lst1_even\n        return\
    \ \"YES\"\n    else\n        return \"NO\"\n    end\nend\n</code>\nThe output\
    \ is:\n<code>\njulia> exchange([1, 2, 3, 4], [1, 2, 3, 4])\n\"YES\"", "    if\
    \ length(lst1) != length(lst2)\n        return \"NO\"\n    else\n        even_index\
    \ = 0\n        odd_index = length(lst1)\n        while even_index < odd_index\n\
    \            if lst1[even_index] == lst2[odd_index]\n                even_index\
    \ = even_index + 1\n                odd_index = odd_index - 1\n            else\n\
    \                return \"NO\"\n            end\n        end\n        \n     \
    \   if even_index == length(lst1)\n            return \"YES\"\n        else\n\
    \            return \"NO\"\n        end\n    end\nend\n</cell>\n<cell>\n@test\
    \ exchange([1,2,3,4,5,6], [1,2,3,4]) == \"YES\"\n@test exchange([1,2,3,4,5,6],\
    \ [1,5,3,4]) == \"NO\"\n</cell>\n<text>\nQuestion 2\nWrite a function that returns\
    \ all the possible combinations of n items from m items.\nFor example, given 3\
    \ as n, return all possible combinations of 3 items from 5 items.", "    if length(lst1)==0\
    \ || length(lst2)==0\n        return \"NO\"\n    end\n    for a in keys(lst2)\n\
    \        count = length(lst1)\n        for b in keys(lst2)\n            if a ==\
    \ b\n                continue\n            elseif count > 1\n                if\
    \ lst1[a] == 2 || lst1[a] == 4 || lst1[a] == 6\n                    count = count\
    \ - 1\n                    lst1[a] = lst1[a] - 2\n                elseif lst1[b]\
    \ == 2 || lst1[b] == 4 || lst1[b] == 6\n                    count = count - 1\n\
    \                    lst1[b] = lst1[b] - 2\n                end\n            else\n\
    \                return \"NO\"\n            end\n        end\n    end\n    return\
    \ \"YES\"\nend\n</cell>\n<code language=julia-1.6>\n## Solution", '"""', "\"\"\
    \"\n    count = 0\n    for el1 in lst1\n        for el2 in lst2\n            if\
    \ el1 != el2\n                count += 1\n                if count == length(lst1)\
    \ - length(lst2)\n                    return \"YES\"\n            end\n      \
    \  end\n    end\n    return \"NO\"\nend\n\"\"\"\n    Another solution that uses\
    \ recursion instead\n\"\"\"", "    even = lst1[end].*2-1\n    for i in (1:length(lst1)-1)\n\
    \        lst1[i+1] = lst1[i+1] + even\n    end\n    if all(map(==, even, lst1[end]))\
    \ \n        return \"YES\"\n    else\n        return \"NO\"\n    end\nend\n</code>\n\
    This code is for exchange between two lists.\nTo make a vector that contains only\
    \ even numbers, you can do the following:\n<code>", "    if lst1[1]==0 && lst2[1]==0\n\
    \        return \"YES\"\n    end\n    if lst1[1]==0 && (lst2[1]!=0 || lst2[2]!=0)\n\
    \        return \"NO\"\n    end\n    if lst2[1]==0 && (lst1[1]!=0 || lst1[2]!=0)\n\
    \        return \"NO\"\n    end\n    if lst1[1]!=0 && lst2[1]!=0 && lst1[2]!=0\
    \ && lst2[2]!=0\n        return false\n    end\nend", "    \n    if length(lst1)\
    \ == 0 || length(lst2) == 0\n        return \"NO\"\n    \n    even = findall(x\
    \ -> x % 2 == 0, lst1)\n    odd = findall(x -> x % 2 != 0, lst1)", "    length1\
    \ = length(lst1)\n    length2 = length(lst2)\n    even = copy(lst1)\n    odd \
    \ = copy(lst2)\n    for i=1:length1\n        if lst1[i] == lst2[i]\n         \
    \   deleteat!(lst2, i)\n        elseif lst1[i] % 2 == 0 && lst2[i] % 2 == 1\n\
    \            if even[i] == lst2[i]\n                deleteat!(even, i)\n     \
    \           deleteat!(odd, i)\n            elseif even[i] % 2 == 1 && lst2[i]\
    \ % 2 == 1\n                if even[i] != lst2[i]\n                    deleteat!(even,\
    \ i)\n                    deleteat!(odd, i)\n                else\n          \
    \          deleteat!(even, i)\n                    deleteat!(odd, i)\n       \
    \         end\n            end\n        elseif lst1[i] % 2 != 0 && lst2[i] % 2\
    \ != 0\n            if even[i] == lst2[i]\n                deleteat!(even, i)\n\
    \                deleteat!(odd, i)\n            elseif even[i] % 2 == 1 && lst2[i]\
    \ % 2 == 1\n                if even[i] != lst2[i]\n                    deleteat!(even,\
    \ i)\n                    deleteat!(odd, i)\n                else\n          \
    \          deleteat!(even, i)\n                    deleteat!(odd, i)\n       \
    \         end\n            end\n        else\n            return false\n     \
    \   end\n    end\n    if length1 == length(even) && length2 == length(odd)\n \
    \       return \"YES\"\n    else\n        return \"NO\"\n    end\nend\n</cell>\n\
    <text>\nTest your function by running the cell below.", "    if lst1 .== lst2\
    \ \n        return \"YES\"\n    else \n        return \"NO\" \n    end\nend\n\
    </code>\n<code>\n\"\"\"In this problem, you will implement a function that takes\
    \ two vectors of numbers,\n    and determines whether it is possible to perform\
    \ a subtraction between them,\n    to make lst1 a vector of numbers that is equal\
    \ to the sum of lst1.\n    There is no limit on the number of elements that may\
    \ be subtracted between lst1 and lst2.\n    If it is possible to subtract elements\
    \ between lst1 and lst2 to make\n    all the elements of lst1 to be zero, return\
    \ \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> subtract([1,\
    \ 2, 3, 4], [1, 2, 3, 4])\n    \"YES\"\n    >>> subtract([2, 3, 4], [1, 5, 3,\
    \ 4])\n    \"NO\"\n    It is assumed that the input vectors will have at least\
    \ one element.\n    \"\"\"", "    \n    \n    ", "    \n    if length(lst1)==0\
    \ || length(lst2)==0 || length(lst1)!=length(lst2) \n        return \"NO\"\n \
    \   else \n        # Your code goes here\n    end \nend\n</cell>\n<text>\nSolution",
  "    \n    if length(lst1) != length(lst2) \n        return \"NO\"\n    end", " \
    \   if length(lst1) == 0 || length(lst2) == 0\n        return \"NO\"\n    even\
    \ = true\n    evens = copy(lst1)\n    evens = append(evens, lst2...)\n    for\
    \ i in evens\n        if i mod 2 != 0\n            even = false\n            break\n\
    \    end\n    if even\n        return \"YES\"\n    else\n        return \"NO\"\
    \n    end\nend", "    if all(x -> x == 0, lst2) == true\n        return \"NO\"\
    \n    even = 1\n    odd = 0\n    even = 0\n    odd = 0\n    for i = 1:length(lst1)\n\
    \        if lst1[i] % 2 == even\n            even += 1\n        elseif lst1[i]\
    \ % 2 == odd\n            odd += 1\n        else\n            return \"NO\"\n\
    \    end\n    if even >= odd\n        return \"YES\"\n    else\n        return\
    \ \"NO\"\n    end\nend\n</cell>\n<text>\nTest your Code\nRun the cell below to\
    \ test your code.", "    exchange_elem = []\n    even = 0\n    for ele in lst1\n\
    \        even += ele\n    end\n    for ele in lst2\n        even -= ele\n    end\n\
    \    if even == 0\n        return \"NO\"\n    else\n        return \"YES\"\n \
    \   end\nend\n</code>\n<|/ a tags=function,julia |>\n<| a dscore=2 |>\nHere's\
    \ a simple implementation:\n<code>", "    if length(lst1) == 0 or length(lst2)\
    \ == 0 \n        return \"NO\" \n    else \n        even = 1\n    end ", "   \
    \ count = 0\n    for (a,b) in zip(lst1,lst2)\n        if a % 2 == 0 && b % 2 ==\
    \ 0\n            count += 1\n            if count > 1\n                return\
    \ \"YES\"\n            end\n        end\n    end\n    return \"NO\"\nend\n\"\"\
    \"\n    problem_15(b) Solves problem 15\n    Write a function called 'problem_15_soln'\
    \ that takes two vectors of numbers,\n    and determines whether it is possible\
    \ to perform an exchange of elements\n    between them to make lst1 a vector of\
    \ only even numbers.\n    There is no limit on the number of exchanged elements\
    \ between lst1 and lst2.\n    If it is possible to exchange elements between the\
    \ lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\"\
    .\n    Otherwise, return \"NO\".\n    For example:\n    >>> problem_15_soln([2,3,4,5],\
    \ [1,5,4,3])\n    \"YES\"\n    >>> problem_15_soln([1,2,3,4,5], [1,5,6,3])\n \
    \   \"NO\"\n    It is assumed that the input vectors will be non-empty.\n    \"\
    \"\"", "  \n  if length(lst1) == 0 \n    return \"NO\" \n  elseif length(lst2)\
    \ == 0 \n    return \"NO\" \n  elseif length(lst1) != length(lst2) \n    return\
    \ \"NO\" \n  else \n    exchange_ele = exchange(lst1, lst2, 0) \n    if exchange_ele\
    \ == \"YES\" \n      return \"YES\" \n    else \n      return \"NO\" \n    end\n\
    \  end\nend\n</cell>\n<code language=julia-1.1>\n#=\nTest your function before\
    \ submission\n=#\n@test exchange([1,2],[1,2,3]) == \"NO\"\n@test exchange([2,1],[1,2,3])\
    \ == \"NO\"\n@test exchange([2,3,1],[1,2,3]) == \"YES\"\n@test exchange([1,2],[1,3])\
    \ == \"NO\"\n@test exchange([2,1],[1,3]) == \"NO\"\n@test exchange([2,3,1],[1,3])\
    \ == \"YES\"\n@test exchange([1,2],[2,1]) == \"NO\"\n@test exchange([2,1],[2,1])\
    \ == \"YES\"\n@test exchange([2,3,1],[2,1]) == \"NO\"\n@test exchange([1,3],[3,1])\
    \ == \"NO\"\n@test exchange([2,3],[3,1]) == \"YES\"\n@test exchange([3,1],[3,2])\
    \ == \"NO\"\n@test exchange([3,2],[3,1]) == \"YES\"\n@test exchange([3,3],[3,3])\
    \ == \"NO\"\n@test exchange([2,3],[3,2]) == \"YES\"\n@test exchange([3,2],[2,3])\
    \ == \"YES\"\n</cell>\n<code language=julia-1.1>\n#=\nWrite a function that determines\
    \ whether it is possible to perform an exchange of elements\nbetween lst1 and\
    \ lst2 to make lst2 a vector of only odd numbers.\nYour function should work when\
    \ the input vectors are non-empty.\nIf there are multiple solutions, return any\
    \ one of them.\nIf there is only 1 solution, return that solution.\nIf there are\
    \ 0 solutions, return \"NO\".\n=#", "    return \"\" \nend ", "    lst1even=trues(length(lst1))\n\
    \    for i=1:length(lst1)\n        if lst1even[i]\n            lst1even[i]=false\n\
    \            lst1even[lst1[i]]=true\n        end\n    end\n    lst2even=trues(length(lst2))\n\
    \    for i=1:length(lst2)\n        if lst2even[i]\n            lst2even[i]=false\n\
    \            lst2even[lst2[i]]=true\n        end\n    end\n    for i=1:length(lst1)\n\
    \        if !lst1even[i]\n            for j=1:length(lst2)\n                if\
    \ !lst2even[j]\n                    if lst1[i]==lst2[j]\n                    \
    \    lst2even[j]=false\n                        lst2even[lst2[j]]=true\n     \
    \               end\n                end\n            end\n        end\n    end\n\
    \    if !all(lst2even)\n        return \"NO\"\n    end\n    return \"YES\"\nend\n\
    </cell>\n<text>\nProblem 9: Implement the function is_permutation(n, p) that takes\
    \ in a permutation\n    matrix p and checks whether it is a valid permutation\
    \ of a vector of length n.\n    You can assume that n \u2264 10^5.\n    The elements\
    \ of the permutation matrix p are represented as vectors,\n    where p[i] is the\
    \ i'th element of the vector. For example:\n    >>> p = [3 5 1 4; 0 2 1 3; 3 5\
    \ 4 1; 4 1 0 5]\n    >>> is_permutation(p, [0 1 2 3])\n    \"YES\"\n    >>> is_permutation(p,\
    \ [0 1 2 4])\n    \"NO\"\n    \"\"\"", "    if length(lst1) == length(lst2)\n\
    \        return \n    end\n    \n    \n    if length(lst1) > length(lst2)\n  \
    \      lst1, lst2 = lst2, lst1\n    end\n    \n    \n    \n    if length(lst1)\
    \ == length(lst2)\n        \n        for i in 1:length(lst1)\n            if ((lst1[i]\
    \ + lst2[i]) % 2 != 0) || ((lst1[i] - lst2[i]) % 2 != 0)\n                return(\"\
    NO\")\n            end\n        end\n        return(\"YES\")\n    else\n     \
    \   return (\"NO\")\n    end\nend\n</cell>\n<code language=julia-1.5>", "    if\
    \ length(lst1) != length(lst2)\n        return \"NO\"\n    else \n        if length(lst1)\
    \ == 0 \n            return \"NO\"\n        else \n            if min(lst1, lst2)\
    \ < 0\n                return \"NO\"\n            else \n                if max(lst1,\
    \ lst2) > length(lst2)\n                    return \"NO\"\n                else\
    \ \n                    if sum(lst1) == length(lst1) and sum(lst2) == length(lst2)\n\
    \                        if lst1[0] != lst2[0]\n                            for\
    \ i in 1:length(lst1)\n                                if sum(lst1[i:length(lst1)])\
    \ % 2 == 0:\n                                    lst1[find(lst1==lst1[i])] = lst2[i]\n\
    \                                end\n                            end\n      \
    \                      for i in 1:length(lst2)\n                             \
    \   if sum(lst2[i:length(lst2)]) % 2 == 0:\n                                 \
    \   lst2[find(lst2==lst2[i])] = lst1[i]\n                                end\n\
    \                            end\n                        else \n            \
    \                if sum(lst1) % 2 == 0 and sum(lst2) % 2 == 0\n              \
    \                  for i in 1:length(lst1)\n                                 \
    \   if sum(lst1[i:length(lst1)]) % 2 == 0\n                                  \
    \      lst1[find(lst1==lst1[i])] = lst2[i]\n                                 \
    \   end\n                                end\n                               \
    \ for i in 1:length(lst2)\n                                    if sum(lst2[i:length(lst2)])\
    \ % 2 == 0\n                                        lst2[find(lst2==lst2[i])]\
    \ = lst1[i]\n                                    end\n                       \
    \         end\n                            end\n                        end\n\
    \                        return lst1[findall(lst1==lst2)[end]]\n             \
    \       else\n                        return \"NO\"\n                    end\n\
    \                end\n            end\n        end\n    end\nend", "    if length(lst1)\
    \ == 0 || length(lst2) == 0 \n        return \"NO\" \n    \n    # Write your code\
    \ here\n    \nend\n</cell>\n<code language=julia-1.5>\nexchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4])\n</cell>\n<code language=julia-1.5>", "   \n    # write your solution\
    \ here", "    #Your code here\n    return \"YES\"\nend\n</cell>\n<text>\nExploring\
    \ the function exchange() with concrete values\nWhen you are satisfied with your\
    \ code, modify it to perform the following operations:", "    if length(lst1)\
    \ == 0 \n        return \"YES\"\n    if length(lst2) == 0 \n        return \"\
    NO\"\n    \n    \n    \n    even = evens(lst1)\n    odd = odds(lst2)\n    for\
    \ el in even\n        if contains(even, el) == true\n            return \"NO\"\
    \n        end\n    end\n    for el in odd\n        if contains(odd, el) == true\n\
    \            return \"NO\"\n        end\n    end\n    return \"YES\"\nend\n</cell>\n\
    <code language=julia-1.0>\nexchange([1, 2, 3, 4], [1, 2, 3, 4])\n</cell>\n<code\
    \ language=julia-1.0>\nexchange([1, 2, 3, 4], [1, 5, 3, 4])\n</cell>\n<text>\n\
    Exercise 5\nDefine a function named evens that takes as input a vector of numbers\
    \ and returns an array containing all the elements of that vector that are even.\
    \ For example, the vector [4, 2, 3] contains all the even numbers: 2, 4. The function\
    \ should return [2, 4].", "    \n    if length(lst1) == 0 || length(lst2) == 0\
    \ \n        return \"NO\"\n    end\n    \n    even_inds = lst1[findall(x -> x\
    \ % 2 == 1, lst1)] \n    even_inds = setdiff(even_inds, lst2) \n    \n    if length(even_inds)\
    \ == 0 \n        return \"YES\"\n    end\n    \n    even_inds \nend\n</cell>\n\
    <cell>\nexchange([1, 2, 3, 4], [1, 2, 3, 4])\n</cell>\n<cell>\nexchange([1, 2,\
    \ 3, 4], [1, 5, 3, 4])\n</cell>\n<cell>", "    \n    l = length(lst1)\n    \n\
    \    for i=1:l \n        if(lst1[i]%2 == 0 && lst2[i]%2 == 0 && lst1[i] <= lst2[i])\n\
    \            return string(\"YES\")\n        end\n    end\n    return string(\"\
    NO\")\nend", "    answer = \"\"\n    for i in 1:length(lst2)\n        if lst1[i]\
    \ % 2 == 0 && lst2[i] % 2 == 0\n            lst1[i] = 0\n            lst2[i] =\
    \ 0\n        elseif lst1[i] % 2 != 0 && lst2[i] % 2 != 0\n            answer +=\
    \ \"NO\"\n            return answer\n        end\n    end\n    answer += \"YES\"\
    \n    return answer\nend\n</cell>\n<text>\nImplement the function all_even().\
    \ Given two vectors x and y with length\nequal to N, check if they are all equal\
    \ to 0 mod 2 or\nall equal to 1 mod 2.", "    #lst1 and lst2 represent the two\
    \ lists we will compare\n    answer = false\n    \n    for element in 1:length(lst1)\n\
    \        if element % 2 != 0\n            answer = true\n            break\n \
    \       else\n            answer = false\n            break\n        end\n   \
    \ end\n    if answer == false\n        return false\n    else\n        return\
    \ true\n    end\nend\n</code>\nTo determine the number of exchanged elements,\
    \ we just need to compare each element of the two lists, and if an even element\
    \ was exchanged between them, we know that all elements of the first list will\
    \ be even.\n<|/ a tags=julia,element,vector dscore=0 |>\n<| c |>\nThank you for\
    \ your answer, but my question was about finding the number of exchanged elements\
    \ in a list.\n<|/ c |>\n<| c |>\nThank you for your answer. I am sorry for the\
    \ late reply, but I wanted to test your answer on my own to see if it works. I\
    \ have been stuck on this problem for 2 days, and I didn't understand what you\
    \ wrote.\n<|/ c |>\n<| c |>\nNo problem! You should be able to implement the function\
    \ as I described it. This should be an easy task, although you might need to read\
    \ up on vectors. I recommend this book if you want to get a good understanding\
    \ of vectors: https://leanpub.com/writing-efficient-julia-programs/read\n<|/ c\
    \ |>\n<| c |>\nI tried to implement your answer, but I had a problem with the\
    \ if statement in the loop. It gives this error message: \"LoadError: MethodError:\
    \ `true` has no method matching true()\"\n<|/ c |>\n<| c |>\nI fixed the code.\
    \ I forgot to add the argument of `==` in the if statement. Try it again.\n<|/\
    \ c |>\n<| a tags=julia,element,vector |>\nHere's another approach, using broadcasting\
    \ along with the dot product.\n<code>", '    ', "    if length(lst1) == 0 || length(lst2)\
    \ == 0 \n        return 'NO' \n    \n    even1 = lst1[end-1:end] \n    even2 =\
    \ lst2[end-1:end] \n    \n    even1 = even1[2:end] \n    even2 = even2[2:end]\
    \ \n    \n    # remove elements smaller than the head of even1 \n    for i in\
    \ length(even1)+1:length(even2) \n        if even1[i] < even2[i] \n          \
    \  even1 = even1[1:i-1] \n            even2 = even2[1:i-1] \n            break\n\
    \        end \n    end \n    \n    # remove elements larger than the tail of even2\n\
    \    for i in length(even1)+1:length(even2) \n        if even2[i] > even1[i] \n\
    \            even1 = even1[1:i-1] \n            even2 = even2[1:i-1] \n      \
    \      break\n        end \n    end \n    \n    if length(even1) == length(even2)\
    \ \n        return 'NO' \n    else \n        if even1 == even2 \n            return\
    \ 'YES' \n        else \n            return 'NO' \n        end \n    end \nend\
    \ \n</cell>\n<text>\nProblem 7\nIn this problem, you will implement a function\
    \ that takes a list of numbers,\n    and determines whether it is possible to\
    \ obtain a sorted version of the list.\n    It is assumed that the input list\
    \ will not be empty, and is not necessarily sorted.\n    If it is possible to\
    \ obtain a sorted version of the list, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    >>> is_sorted([3, 1, 2])\n    \"YES\"\n    >>>\
    \ is_sorted([3, 3, 3, 3])\n    \"NO\"\n    >>> is_sorted([1, 3, 3])\n    \"NO\"\
    \n    It is assumed that the input list will not be empty.\n    \"\"\"", "   \
    \ # Fill in the code below\n    return \nend\n</cell>\n<text>\nPart II - Solution\n\
    To pass this part of the exercise, you will need to solve the following problems:",
  "    even = lst1[findall(x -> mod(x,2)==0,lst1)]\n    odd =  lst2[findall(x -> mod(x,2)==0,lst2)]\n\
    \    if even != [] && odd != []\n        return \"YES\"\n    else\n        return\
    \ \"NO\"\n    end\nend\n</cell>\n<text>\nExercise 2: Exchange Two Numbers\nWrite\
    \ a function exchange2 that takes two vectors of numbers, and returns true or\
    \ false depending if it is possible to perform an exchange of elements. No limit\
    \ is placed on the number of exchanged elements.\nFor example, exchange2([2, 3,\
    \ 4], [2, 4, 6]) returns true.", "    \n    even1 = true\n    even2 = true\n \
    \   odd1 = true\n    odd2 = true\n    \n    for i in eachindex(lst1)\n       \
    \ if even1 and even2 and odd1 and odd2\n            even1 = false\n          \
    \  even2 = false\n            odd1 = false\n            odd2 = false\n       \
    \     \n        el1 = lst1[i]\n        el2 = lst2[i]\n        if el1 % 2 == 0\
    \ and el2 % 2 == 0\n            even1 = false\n            even2 = false\n   \
    \         odd1 = false\n            odd2 = false\n        elseif el1 % 2 != 0\
    \ and el2 % 2 == 0\n            even1 = false\n            even2 = true\n    \
    \        odd1 = false\n            odd2 = false\n        elseif el1 % 2 == 0 and\
    \ el2 % 2 != 0\n            even1 = false\n            even2 = true\n        \
    \    odd1 = true\n            odd2 = false\n        elseif el1 % 2 != 0 and el2\
    \ % 2 != 0\n            even1 = true\n            even2 = false\n            odd1\
    \ = true\n            odd2 = false\n        end\n    end\n    \n    if even1 and\
    \ even2 and odd1 and odd2\n        return \"YES\"\n    else\n        return \"\
    NO\"\n    end\nend\n</code>\n<|/ a dscore=1 tags=algorithm,julia |>\n<| c |>\n\
    I believe your code doesn't work because you check if `el1 % 2 == 0` then `el2\
    \ % 2 == 0` but you also need to check if `el1 % 2 != 0` then `el2 % 2 != 0`.\
    \ As a result, your code would say that `[4, 3]` is even but `[3, 6]` is even.\n\
    <|/ c |>\n<| c |>\nYou are right, my bad. I fixed the code but I am still not\
    \ sure how it works. I added a little explanation.\n<|/ c |>\n<| c |>\nI have\
    \ found that your code is wrong, even when `lst1 = [2, 4, 5]` and `lst2 = [3,\
    \ 5, 2]` and you swap the elements, your code will return `NO`, but I think it\
    \ should be `YES`. Check my code again. I am confused about how your code works.\n\
    <|/ c |>\n<| c |>\nYeah, you are right. I missed that detail. I have fixed the\
    \ code now. I am not sure how it works though.\n<|/ c |>\n<| c |>\nI added some\
    \ explanation to my answer. I believe you should be able to understand it if you\
    \ understand how `if` works.\n<|/ c |>\n<| a dscore=0 tags=algorithm,julia |>\n\
    <code>", "    if length(lst1) != length(lst2)\n        return \"NO\"\n    else\n\
    \        even = filter(x -> x % 2 == 0, lst1)\n        if length(even) == length(lst1)\n\
    \            return \"YES\"\n        else\n            return \"NO\"\n    end\n\
    end", "        if length(lst1) != length(lst2)\n            return \"NO\"\n  \
    \  else \n            \n            even=true\n            for i1 in 1:length(lst1)\n\
    \                even=false\n                for i2 in 1:length(lst2)\n      \
    \              if lst1[i1]==lst2[i2]\n                        even=true\n    \
    \                    break\n                end\n                if even==false\n\
    \                    return \"NO\"\n                end\n            end\n   \
    \         return \"YES\"\n        end\n    end\n    \n\"\"\"\n    main() -> nothing\n\
    \    \n    Main function of this file.\n    You should execute `ex_exchange` to\
    \ run this function.\n    \n    In this function, you should implement:\n    \
    \    - the definition of `ex_exchange`\n        - a testcase for `ex_exchange`\n\
    \        - a testcase for `main`\n\"\"\"", "    exchanged = false\n    # Your\
    \ code here", "    \n    even1 = filter(x -> x % 2 == 0, lst1)\n    even2 = filter(x\
    \ -> x % 2 == 0, lst2)\n    even1 = even1[1]\n    even2 = even2[1]\n    \n   \
    \ if even1 == even2\n        return \"YES\"\n    end", "    lst1=copy(lst1)\n\
    \    lst2=copy(lst2)\n    \n    # Write your code here.\n    \n    if length(lst1)==0\
    \ || length(lst2)==0\n        return \"NO\"\n    end\n    \n    if length(lst1)==1\
    \ && length(lst2)==1\n        if lst1[end]==lst2[end]\n            return \"YES\"\
    \n        elseif lst1[end]<lst2[end]\n            return \"NO\"\n        end\n\
    \    end\n    \n    \n    \nend\n</cell>\n<cell>\n# Check your answer by running\
    \ the tests below - there are no assertions so your function is correct.\n@test\
    \ exchange([1,5,3,4], [1,2,3,4])==\"NO\"\n@test exchange([1,4,3,4], [1,5,3,4])==\"\
    NO\"\n@test exchange([1,5,3,4], [1,2,3,4])==\"NO\"\n@test exchange([1,2,3,4],\
    \ [1,2,4,3])==\"NO\"\n@test exchange([1,5,3,4], [1,5,4,3])==\"NO\"\n@test exchange([1,5,3,4],\
    \ [1,3,5,4])==\"NO\"\n@test exchange([1,5,3,4], [1,3,4,5])==\"NO\"\n@test exchange([1,5,3,4],\
    \ [2,1,3,4])==\"NO\"\n@test exchange([1,5,3,4], [2,1,4,3])==\"NO\"\n@test exchange([1,5,3,4],\
    \ [2,1,4,5])==\"NO\"\n@test exchange([1,5,3,4], [2,3,1,4])==\"NO\"\n@test exchange([1,5,3,4],\
    \ [2,3,4,1])==\"NO\"\n@test exchange([1,5,3,4], [2,4,3,1])==\"NO\"\n@test exchange([1,5,3,4],\
    \ [2,4,5,1])==\"NO\"\n@test exchange([1,5,3,4], [3,4,5,1])==\"NO\"\n@test exchange([1,5,3,4],\
    \ [4,1,3,2])==\"NO\"\n@test exchange([1,5,3,4], [4,2,1,3])==\"NO\"\n@test exchange([1,5,3,4],\
    \ [4,3,2,1])==\"NO\"\n@test exchange([1,5,3,4], [4,4,2,1])==\"NO\"\n@test exchange([1,5,3,4],\
    \ [4,4,3,1])==\"NO\"\n@test exchange([1,5,3,4], [5,3,4,1])==\"NO\"\n@test exchange([1,5,3,4],\
    \ [5,4,3,1])==\"NO\"\n@test exchange([1,5,3,4], [5,5,3,1])==\"NO\"\n@test exchange([1,5,3,4],\
    \ [5,5,4,1])==\"", "    for index in 0...length(lst1)-1\n        if lst1[index]\
    \ % 2 == 0 && lst2[index] % 2 == 0\n            return string(\"YES\")\n     \
    \   else\n            return string(\"NO\")\n        end\n    end\nend\n</code>\n\
    <|/ a dscore=0 tags=julia,vector,arrays |>\n<| c |>\nPlease don't post answers\
    \ without any explanation or context (especially not when it is not an answer),\
    \ it just makes the question harder to understand.\n<|/ c |>\n<| c |>\nThe explanation\
    \ is in the comments.\n<|/ c |>\n<| c |>\nThis is not an answer. It should be\
    \ a comment. It is not an answer because it doesn't give the correct answer (even\
    \ though the code may be correct). It is an answer because it explains why it\
    \ works.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "    \n    len_lst1 = length(lst1)\n\
    \    len_lst2 = length(lst2)\n    \n    for j in 1:len_lst2\n        \n      \
    \  exchange_idx = 1\n        \n        for i in 1:len_lst1\n            if ((lst1[i]\
    \ % 2 == 0) || (lst2[j] % 2 == 0) || (lst1[i] == lst2[j])) && (lst1[i] != lst2[j])\
    \ {\n                exchange_idx = exchange_idx + 1\n                if (exchange_idx\
    \ == len_lst1) {\n                    \n                    if ((lst1[i] % 2 ==\
    \ 0) && (lst2[j] % 2 == 0)) {\n                        print(\"YES\")\n      \
    \              } else {\n                        print(\"NO\")\n             \
    \       }\n                }\n                break\n            }\n        end\n\
    \    end\nend", "    if length(lst1) != length(lst2)\n        return \"NO\"\n\
    \    end\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    ", "    if length(lst1) != length(lst2)\n        return\
    \ \"NO\"\n    end\n    \n    for index in 1:length(lst1)\n        if index !=\
    \ 1 && index != length(lst1) && (lst1[index] % 2 == 0) && (lst2[index] % 2 ==\
    \ 0)\n            return \"NO\"\n        end\n    end", "    if lst1 == [] or\
    \ lst2 == []\n        return \"NO\"\n    else\n        exchange2 = exchange(lst2[(end-1)\
    \ : end], lst1[0 : end - 1])\n        if all(x % 2 == 0 for x in  exchange2) ==\
    \ true \n            return \"YES\"\n        else\n            return \"NO\"\n\
    \        end\n    end\nend\n\"\"\"\nThis function checks to see if the vector\
    \ in lst1 is the same as the vector in lst2\nIf they are the same, then the function\
    \ returns \"YES\". If they are not, then it returns \"NO\".\n\"\"\"", "    \n\
    \    \n\"\"\"# Problem 5 - Problem Set 4 ", "     if length(lst1)==0 || length(lst2)==0\n\
    \         return \"NO\"\n     end\n     return if length(lst1) == length(lst2)\
    \ \n         \"YES\"\n     end\n     if length(lst1) < length(lst2) \n       \
    \ if issorted(lst1) \n           return \"YES\"\n        else\n           return\
    \ \"NO\"\n        end\n     end\n     if length(lst1) > length(lst2) \n      \
    \  if issorted(lst2) \n           return \"YES\"\n        else\n           return\
    \ \"NO\"\n        end\n     end\n     if lst1[1] % 2 == 0 \n        return \"\
    NO\"\n     end\n     if lst2[1] % 2 == 0 \n        return \"NO\"\n     end\n \
    \    if lst1[1] == lst2[1] \n        if lst1[2] == lst2[2] \n           if lst1[3]\
    \ == lst2[3] \n               if lst1[4] == lst2[4]\n                   if lst1[5]\
    \ == lst2[5] \n                       if lst1[6] == lst2[6] \n               \
    \            if lst1[7] == lst2[7] \n                               if lst1[8]\
    \ == lst2[8] \n                                   if lst1[9] == lst2[9] \n   \
    \                                    if lst1[10] == lst2[10] \n              \
    \                             if lst1[11] == lst2[11]\n                      \
    \                         if lst1[12] == lst2[12] \n                         \
    \                          if lst1[13] == lst2[13] \n                        \
    \                               if lst1[14] == lst2[14] \n                   \
    \                                        if lst1[15] == lst2[15] \n          \
    \                                                     if lst1[16] == lst2[16]\n\
    \                                                                   if lst1[17]\
    \ == lst2[17] \n                                                             \
    \          if lst1[18] == lst2[18]\n                                         \
    \                                  if lst1[19] == lst2[19]\n                 \
    \                                                              if lst1[20] ==\
    \ lst2[20]\n                                                                 \
    \                    if lst1[21] == lst2[22]\n                               \
    \                                                          return \"YES\"\n  \
    \                                                                            \
    \       end\n                                                                \
    \                 end\n                                                      \
    \                       end\n                                                \
    \                           end\n                                            \
    \                         end\n                                              \
    \               end\n                                                        end\n\
    \                                                   end\n                    \
    \                           end\n                                           end\n\
    \                                       end\n                                \
    \   end\n                               end\n                           end\n\
    \                       end\n                   end\n               end\n    \
    \       end\n        end\n     end\n     return \"NO\"\nend\n</cell>\n<text>\n\
    Let's test our new function:", "    \n    #Your code here\n    if length(lst1)\
    \ != length(lst2)\n        return \"NO\"\n    else\n        for i = 1:length(lst1)\n\
    \            if lst1[i] % 2 == 0 && lst2[i] % 2 == 0\n                lst1[i]\
    \ /= 2\n                lst2[i] /= 2\n            elseif lst1[i] % 2 == 0 && lst2[i]\
    \ % 2 != 0\n                lst1[i] += 1\n            elseif lst1[i] % 2 != 0\
    \ && lst2[i] % 2 == 0\n                lst1[i] -= 1\n            end\n       \
    \ end\n        \n        if sum(lst1) == 0 && sum(lst2) == 0\n            return\
    \ \"NO\"\n        else\n            return \"YES\"\n        end\n    end\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nJust for kicks I implemented a solution\
    \ using foldl instead of foldl\n<code>", "    \"\"\"Return a string indicating\
    \ whether it is possible to exchange \n    elements in lst1 to make lst1 even\
    \ in length.\n    Arguments:\n    lst1 (Vector{Int64}): first input vector\n \
    \   lst2 (Vector{Int64}): second input vector\n    \"\"\"\n    \n    return \n\
    end\n</cell>\n<code language=julia-1.4>\nprint(exchange([1, 2, 3, 4], [1, 2, 3,\
    \ 4]))\nprint(exchange([1, 2, 3, 4], [1, 5, 3, 4]))\nprint(exchange([1, 2, 3,\
    \ 4], [1, 5, 3, 4]))\n</cell>\n<text>\n5.5.3 Exercise\nWrite a function that takes\
    \ two vectors of numbers, and\n    determines whether it is possible to perform\
    \ an exchange of elements\n    between them to make lst1 a vector of only even\
    \ numbers.\n    There is no limit on the number of exchanged elements between\
    \ lst1 and lst2.\n    If it is possible to exchange elements between the lst1\
    \ and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n\
    \    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4])\n    \"YES\"\n    >>> exchange([1, 2, 3, 4], [1, 5, 3, 4])\n \
    \   \"NO\"\n    It is assumed that the input vectors will be non-empty.", "</code>\n\
    This function takes in two vectors of numbers (lst1 and lst2), and returns \"\
    YES\" if\n<code>\nlst1 is a vector of only even numbers, and \"NO\" otherwise.\n\
    </code>\nNote that this function does not check whether the vector contains no\
    \ even numbers!\nTo check whether lst1 is of even length, you can use\n<code>\n\
    length(lst1) > 0 && length(lst2) > 0 && all(x -> x % 2 == 0, lst1)\n</code>\n\
    If the above statement is true, the function returns \"YES\".\n<code>", "    \
    \    if length(lst1) == 0 then return \"NO\" \n        if length(lst2) == 0 then\
    \ return \"NO\" \n        even = ones(Int64, length(lst1))\n        even = filter(x\
    \ -> x % 2 == 0, even)\n        if any(even .== 0) then return \"NO\" \n     \
    \   even1 = ones(Int64, length(lst1))\n        even1 = filter(x -> x % 2 == 0,\
    \ even1)\n        if all(even1) .== 0 then return \"NO\" \n        even = filter(x\
    \ -> x % 2 == 0, even)\n        even = filter(x -> x %!= 0, even)\n        even\
    \ = intersect(even, lst2)\n        even = setdiff(even, lst2)\n        if even\
    \ == [] then return \"NO\" \n        return \"YES\"\n    end\n</code>\n<|/ a tags=algorithm,mathematical-optimization,set-theory\
    \ dscore=1 |>\n<| a dscore=1 tags=algorithm,mathematical-optimization,set-theory\
    \ |>\n<code>\ndef even(l1:Vector{Int64},l2:Vector{Int64})::String\n    first=setdiff(l1,l2)\n\
    \    second=setdiff(l2,l1)\n    even=filter(x -> x%2==0, first)\n    even=setdiff(even,second)\n\
    \    if even==[] return \"NO\"\n    return \"YES\"\nend\n</code>\n<|/ a |>\n<|\
    \ a dscore=1 |>\nHere's my implementation in Julia for a similar question asked\
    \ in the leetcode:\n<code>", "    \n    if length(lst1) != length(lst2) || length(lst1)\
    \ == 0 \n        return \"NO\"\n    end", "    if lst1 == [] || lst2 == []\n \
    \       return \"NO\"\n    end\n    if lst1[0] != evens(lst2[1])\n        return\
    \ \"NO\"\n    elseif evens(lst1[1]) == evens(lst2[2])\n        return \"NO\"\n\
    \    else\n        return \"YES\"\n    end\nend", "</code>\n<code>\nreturn \"\
    NO\"\nend\n</code>\nAnd then you can call the function exchange to check whether\
    \ all elements of the input vectors are even:\n<code>\nlst1 = [1, 2, 3, 4]\nlst2\
    \ = [2, 4, 6, 8]", "    count = 0\n    # let us take lst1 and count how many even\
    \ numbers there are\n    for number in lst1\n        if number % 2 == 0\n    \
    \        count += 1\n        end\n    end\n    # now count how many even numbers\
    \ are in lst1\n    even = count % 2\n    # now count how many even numbers are\
    \ in lst2\n    even2 = count2 % 2\n    # now check if all even numbers in lst1\
    \ are even in lst2\n    if even != even2\n        return \"NO\"\n    end\n   \
    \ return \"YES\"\nend\n\"\"\"", "\"\"\"\n    \n\"\"\"\n    exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64}, min_len=10)::String\n    exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64}, min_len)::String\n    exchange(lst1::Vector{Int64}, lst2::Vector{Int64})::String\n\
    \"\"\"", "    #Your code here\n    return \"\"\nend", "    \n# your code goes\
    \ here\n \nend\n</cell>\n<code language=julia-1.3>\n# run this cell to check your\
    \ result\n\"\"\"\n2x + 3y = 6\nx + 3y = 5\nx + 2y = 4\n2x + 4y = 8\nx + 4y = 4\n\
    x + 2y = 2\n2x + 5y = 10\nx + 5y = 5\n2x + 3y = 6\nx + 3y = 5\nx + 2y = 4\n2x\
    \ + 4y = 8\nx + 4y = 4\nx + 2y = 2\n2x + 5y = 10\nx + 5y = 5\n2x + 3y = 6\nx +\
    \ 3y = 5\nx + 2y = 4\n2x + 4y = 8\nx + 4y = 4\nx + 2y = 2\n2x + 5y = 10\nx + 5y\
    \ = 5\n2x + 3y = 6\nx + 3y = 5\nx + 2y = 4\n2x + 4y = 8\nx + 4y = 4\nx + 2y =\
    \ 2\n2x + 5y = 10\nx + 5y = 5\n2x + 3y = 6\nx + 3y = 5\nx + 2y = 4\n2x + 4y =\
    \ 8\nx + 4y = 4\nx + 2y = 2\n2x + 5y = 10\nx + 5y = 5\n2x + 3y = 6\nx + 3y = 5\n\
    x + 2y = 4\n2x + 4y = 8\nx + 4y = 4\nx + 2y = 2\n2x + 5y = 10\nx + 5y = 5\n2x\
    \ + 3y = 6\nx + 3y = 5\nx + 2y = 4\n2x + 4y = 8\nx + 4y = 4\nx + 2y = 2\n2x +\
    \ 5y = 10\nx + 5y = 5\n2x + 3y = 6\nx + 3y = 5\nx + 2y = 4\n2x + 4y = 8\nx + 4y\
    \ = 4\nx + 2y = 2\n2x + 5y = 10\nx + 5y = 5\n2x + 3y = 6\nx + 3y = 5\nx + 2y =\
    \ 4\n2x + 4y = 8\nx + 4y = 4\nx + 2y = 2\n2x + 5y = 10\nx + 5y = 5\n2x + 3y =\
    \ 6\nx + 3y = 5\nx + 2y = 4\n2x + 4y = 8\nx + 4y = 4\nx + 2y = 2\n2x + 5y = 10\n\
    x + 5y = 5\n2x + 3y = 6\nx + 3y = 5\nx + 2y = 4\n2x + 4y = 8\nx + 4y = 4\nx +\
    \ 2y = 2\n2x + 5y = 10\nx + 5y = 5\n2x + 3y = 6\nx + ", "    \n    return ???\
    \ \nend\n</cell>\n<text>\nSolution\nRun the cell below to test your implementation.",
  "    len1 = length(lst1)\n    len2 = length(lst2)\n    if len1 == 0 or len2 == 0\n\
    \        return \"NO\"\n    end\n    \n    even1 = trues(len1)\n    even2 = trues(len2)\n\
    \    even1[[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15]] = false\n    even2[[1 2 3 4\
    \ 5 6 7 8 9 10 11 12 13 14 15]] = false\n    even1[[15 14 13 12 11 10 9 8 7 6\
    \ 5 4 3 2 1]] = false\n    even2[[15 14 13 12 11 10 9 8 7 6 5 4 3 2 1]] = false\n\
    \    \n    \n    \n    even1 = falses(len1)\n    even2 = falses(len2)\n    even1[[1\
    \ 2 3 4 5 6 7 8 9 10 11 12 13 14 15]] = true\n    even2[[1 2 3 4 5 6 7 8 9 10\
    \ 11 12 13 14 15]] = true\n    even1[[15 14 13 12 11 10 9 8 7 6 5 4 3 2 1]] =\
    \ true\n    even2[[15 14 13 12 11 10 9 8 7 6 5 4 3 2 1]] = true\n    \n    \n\
    \    \n    even1 = falses(len1)\n    even2 = falses(len2)\n    even1[[1 2 3 4\
    \ 5 6 7 8 9 10 11 12 13 14 15]] = false\n    even2[[1 2 3 4 5 6 7 8 9 10 11 12\
    \ 13 14 15]] = false\n    even1[[15 14 13 12 11 10 9 8 7 6 5 4 3 2 1]] = false\n\
    \    even2[[15 14 13 12 11 10 9 8 7 6 5 4 3 2 1]] = false\n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    even1 = falses(len1)\n    even2 = falses(len2)\n\
    \    even1[[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15]] = false\n    even2[[1 2 3 4\
    \ 5 6 7 8 9 10 11 12 13 14 15]] = false\n    even1[[15 14 13 12 11 10 9 8 7 6\
    \ 5 4 3 2 1]] = false\n    even2[[15 14 13 12 11 10 9 8 7 6 5 4 3 2 1]] = false\n\
    \    \n    \n    \n    \n    \n    \n    \n    even1 = falses(len1)\n    even2\
    \ = falses(len2)\n    even1[[1 2 3 4 ", "\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\
    \n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\
    \"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\
    \"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\
    \"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\
    \n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\
    \"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\
    \"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\
    \"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\
    \n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\
    \"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\
    \"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\
    \"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\
    \n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\
    \"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\
    \"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\
    \"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\
    \n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\
    \"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\
    \"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\
    \"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\
    \n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\
    \"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\
    \"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\
    \"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\
    \n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\
    \"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n", "    if length(lst1)\
    \ != length(lst2)\n        return \"NO\"\n    end\n    even = sum(lst1 .== 0)\n\
    \    odd = length(lst1) - even\n    count = 0\n    i = 2\n    while i < length(lst1)\n\
    \        if lst1[i] > lst1[i-1]\n            count += 1\n        end\n       \
    \ i += 1\n    end\n    if count < odd\n        return \"NO\"\n    else\n     \
    \   return \"YES\"\n    end\nend\n</cell>\n<text>\nExercise 11 (20 Points)\nWrite\
    \ a function that checks whether a number is a valid Julian date. Julian dates\
    \ are a four-digit number that represents the number of days since January 1,\
    \ 4713 BC. Julian dates range from 001 to 365.", "    if length(lst1) != length(lst2)\
    \ \n        return \"NO\" \n    \n    lst3 = []\n    \n    for i in 1:length(lst1)\
    \ \n        if mod(lst1[i], 2) == 0 \n            lst3 += lst2[i] \n        else\
    \ \n            lst3 += lst1[i] \n        end\n    end\n    \n    if length(lst3)\
    \ == length(lst1) \n        return \"YES\"\n    else \n        return \"NO\"\n\
    \    end\nend\n</code>\n<|/ q dscore=0 |>\n<| c |>\nThis isn't a minimal reproducible\
    \ example -- you need a working program that demonstrates the problem. [MCVE](https://stackoverflow.com/help/minimal-reproducible-example).\
    \ For a minimal example, all you need is an `exchange` function and a `main` that\
    \ calls it. When you get stuck, edit your question to include a MCVE.\n<|/ c |>\n\
    <| c |>\nSo now you know that the problem is in your `exchange` function, but\
    \ how do you test it? It's a good idea to start with a simple main that calls\
    \ `exchange`. Once you have that working, you can worry about getting it to work\
    \ with a vector of lists.\n<|/ c |>\n<| c |>\nIn your `main` function, you have\
    \ a call `exchange(lst1,lst2)` -- is that supposed to be `exchange(lst1,lst2)`\
    \ without the space between the parens? If so, then you're only calling `exchange`\
    \ and not actually calling `exchange` with the correct parameters. So the code\
    \ won't compile and you haven't shown any code that shows what you've done to\
    \ debug.\n<|/ c |>\n<| c |>\nThe code as posted has a compilation error. You're\
    \ missing a comma between `lst2` and `lst1`, but you also forgot to pass the parameters\
    \ to `exchange`.\n<|/ c |>\n<| c |>\nI posted a code of the exchange function\
    \ which I wrote by myself. I just want to know whether I wrote it right. Thank\
    \ you for your suggestion!\n<|/ c |>\n<| a dscore=1 |>\nI looked at your main\
    \ function, and it looks a bit strange. I think this is what you want:\n<code>",
  "  \n\"\"\"\n  \n  \n  if length(lst1) != length(lst2) \n    return \"NO\"\n  \n\
    \  if length(lst1) == 0 \n    return \"NO\"\n  \n  if length(lst1) == 0\n    return\
    \ \"NO\"\n  \n  if length(lst1) == length(lst2) \n    return \"NO\"\n  \n  even\
    \ = 1\n  odd = 0\n  \n  for i =1:length(lst1)\n    if lst1[i] % 2 != 0\n     \
    \ even = 0\n    else\n      even = 1\n    end\n    \n    if lst2[i] % 2 != 0\n\
    \      odd = 0\n    else\n      odd = 1\n    end\n  end\n  \n  if even == 0\n\
    \    return \"NO\"\n  elseif even == 1\n    return \"YES\"\n  else\n    return\
    \ \"NO\"\n  end\n  \nend\n  \n  \nend\n</code>\nHere is the test function\n<code>",
  "    if length(lst1) == length(lst2)\n        even = falses(length(lst1))\n    \
    \    for i in 1:length(lst1)\n            if even[i] == false\n              \
    \  for j in 1:length(lst2)\n                    if i != j\n                  \
    \      if lst1[i] == lst2[j]\n                            even[i] = true\n   \
    \                         lst1[i] = 0\n                            lst2[j] = 0\n\
    \                            break\n                        else\n           \
    \                 even[i] = false\n                    end\n                end\n\
    \            end\n        end\n        if even != true\n            return \"\
    NO\"\n        else\n            return \"YES\"\n        end\n    else\n      \
    \  return \"NO\"\n    end\nend", "    \n    for i in 1 : length(lst1) -1 do\n\
    \        if i%2 != 0 && lst1[i] > lst2[i] then\n            return \"NO\"\n  \
    \      end\n        if i%2 != 0 && lst1[i] < lst2[i] then\n            return\
    \ \"NO\"\n        end\n    end\n    return \"YES\"\nend\n</cell>\n<cell>\ntests\
    \ = @test begin\n    @test exchange([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n \
    \   @test exchange([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\nend\n</cell>\n<text>\n\
    2.4 Exercises\nFor each of the following questions, give a hint as to what to\
    \ write in the code\nblock.", "    ...\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    Thank you so much for this explanation. Really helped me understand it better.\n\
    <|/ c |>\n<| a dscore=2 tags=function,matlab,for-loop,vectorization |>\nIf you\
    \ can not solve it by yourself, I suggest to look up for any online algorithm\
    \ description sites like Wikipedia or Algorithms. You will find something like\
    \ this:", "    \n    if length(lst1) != length(lst2) \n        \"This problem\
    \ requires lst1 and lst2 to have the same length.\" \n    else \n        if lst1[1]\
    \ == lst2[1] && lst1[2] == lst2[2] && lst1[3] == lst2[3] \n            \"YES\"\
    \n        else \n            if lst1[1] % 2 == 0 && lst2[1] % 2 == 0 && lst1[2]\
    \ % 2 == 0 && lst2[2] % 2 == 0 && lst1[3] % 2 == 0 && lst2[3] % 2 == 0 \n    \
    \            \"YES\"\n            else\n                \"NO\"\n            end\n\
    \        end\n    end\nend\n</cell>\n<text>\nQuestion 1.12. How many total exchanges\
    \ do you have to make to swap all elements of lst1 and lst2 with even indices?\
    \ Use the exchange(lst1, lst2) function.", "  if length(lst1) != length(lst2)\n\
    \    return \"NO\"\n  end\n  even = filter(x -> x mod 2 == 0, lst1)\n  odd = filter(x\
    \ -> x mod 2 != 0, lst1)\n  if length(even) < length(odd)\n    return \"NO\"\n\
    \  end\n  if length(even) == length(odd)\n    lst1 = filter(x -> x mod 2 == 0,\
    \ lst1)\n    lst2 = filter(x -> x mod 2 != 0, lst2)\n  end\n  for (a, b) in enumerate(lst1)\n\
    \    for (c, d) in enumerate(lst2)\n      if c == d\n        continue\n      end\n\
    \      if a > b\n        if a > d\n          lst1[c] = a % 2\n          lst1[d]\
    \ = b % 2\n          lst2[c] = b % 2\n          lst2[d] = a % 2\n        end\n\
    \      elseif b > d\n        if b > a\n          lst1[c] = b % 2\n          lst1[d]\
    \ = a % 2\n          lst2[c] = a % 2\n          lst2[d] = b % 2\n        end\n\
    \      elseif a == b\n        if a > d\n          lst1[c] = a % 2\n          lst1[d]\
    \ = b % 2\n          lst2[c] = b % 2\n          lst2[d] = a % 2\n        end\n\
    \      elseif d > a\n        if d > b\n          lst1[c] = d % 2\n          lst1[d]\
    \ = b % 2\n          lst2[c] = b % 2\n          lst2[d] = d % 2\n        end\n\
    \      end\n    end\n  end\n  even = filter(x -> x mod 2 == 0, lst1)\n  if length(even)\
    \ != length(lst1)\n    return \"NO\"\n  end\n  return \"YES\"\nend\n</cell>\n\
    <code language=julia-1.5>", "        \n        evens = lst1[findall(x -> x ==\
    \ 2, lst1)]\n        odds = lst1[findall(x -> x == 1, lst1)]\n    \n        \n\
    \        #check all elements in list1 that not even in list2\n        \n     \
    \   #check all elements in list2 that not even in list1\n        \n        #check\
    \ whether all elements in list1 even\n        \n        #check whether all elements\
    \ in list2 even\n        \n        #check\n        \n        return \"NO\"\n \
    \   end\n    \n    \n    \n\"\"\"\n    Problem 6\n    \n    In this problem, you\
    \ will implement a function that takes two vectors of numbers,\n    and determines\
    \ whether it is possible to perform an exchange of elements\n    between them\
    \ to make lst1 a vector of only odd numbers.\n    There is no limit on the number\
    \ of exchanged elements between lst1 and lst2.\n    If it is possible to exchange\
    \ elements between the lst1 and lst2 to make\n    all the elements of lst1 to\
    \ be odd, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n \
    \   >>> exchange([1, 2, 3, 4], [1, 2, 3, 4])\n    \"YES\"\n    >>> exchange([1,\
    \ 2, 3, 4], [1, 5, 3, 4])\n    \"NO\"\n    It is assumed that the input vectors\
    \ will be non-empty.\n    \"\"\"", "\"\"\"\n    lst1 = [x for (x,y) in zip(lst1,\
    \ lst2) if x%2 != 0]\n    lst2 = [y for (x,y) in zip(lst1, lst2) if x%2 != 0]\n\
    \    \n    if length(lst1) == length(lst2)\n        lst1 = filter(x -> x % 2 ==\
    \ 0, lst1)\n        return \"YES\"\n    else\n        return \"NO\"\n    end\n\
    end\n</code>\nThe code should work fine, though I cannot test it since it requires\
    \ some more data than what is provided. However, I have also made a similar function\
    \ using list comprehensions, so that it can be more efficient. \n<code>", "  \
    \  even1 = trues(length(lst1))\n    even2 = trues(length(lst2))\n    for el1 in\
    \ lst1\n        if el1 % 2 == 0\n            even1[el1-1] = false\n        end\n\
    \    end\n    for el2 in lst2\n        if el2 % 2 == 0\n            even2[el2-1]\
    \ = false\n        end\n    end\n    \n    if all(even1) == true\n        return\
    \ \"YES\"\n    end\n    if all(even2) == true\n        return \"NO\"\n    end\n\
    \    \n    if any(even1 & even2)\n        return \"NO\"\n    else\n        return\
    \ \"YES\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert exchange([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n@assert exchange([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\"\n</cell>\n<text>\nTask 3.3: Write a function that takes a vector\
    \ of integers and returns its product (as in lst1\xD7lst2).", "    even = true\n\
    \    even1 = true\n    even2 = true\n    even3 = true\n    even4 = true\n    even5\
    \ = true\n    even6 = true\n    even7 = true\n    even8 = true\n    even9 = true\n\
    \    even10 = true\n    even11 = true\n    even12 = true\n    even13 = true\n\
    \    even14 = true\n    even15 = true\n    even16 = true\n    even17 = true\n\
    \    even18 = true\n    even19 = true\n    even20 = true\n    even21 = true\n\
    \    even22 = true\n    even23 = true\n    even24 = true\n    even25 = true\n\
    \    even26 = true\n    even27 = true\n    even28 = true\n    even29 = true\n\
    \    even30 = true\n    even31 = true\n    even32 = true\n    even33 = true\n\
    \    even34 = true\n    even35 = true\n    even36 = true\n    even37 = true\n\
    \    even38 = true\n    even39 = true\n    even40 = true\n    even41 = true\n\
    \    even42 = true\n    even43 = true\n    even44 = true\n    even45 = true\n\
    \    even46 = true\n    even47 = true\n    even48 = true\n    even49 = true\n\
    \    even50 = true\n    even51 = true\n    even52 = true\n    even53 = true\n\
    \    even54 = true\n    even55 = true\n    even56 = true\n    even57 = true\n\
    \    even58 = true\n    even59 = true\n    even60 = true\n    even61 = true\n\
    \    even62 = true\n    even63 = true\n    even64 = true\n    even65 = true\n\
    \    even66 = true\n    even67 = true\n    even68 = true\n    even69 = true\n\
    \    even70 = true\n    even71 = true\n    even72 = true\n    even73 = true\n\
    \    even74 = true\n    even75 = true\n    even76 = true\n    even77 = true\n\
    \    even78 = true\n    even79 = true\n    even80 = true\n    even81 = true\n\
    \    even82 = true\n    even83 = true\n    even84 = true\n    even85 = true\n\
    \    even86 = true\n    even87 = true\n    even88 = true\n    even89 = true\n\
    \    even90 = true\n    even91 = true\n    even92 = true\n    even93 = true\n\
    \    even94 = true\n    even95 = true\n    even96 = true\n    even97", "    \"\
    \"\"\n    In this problem, you will implement a function that takes two vectors\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a vector of only even numbers.\n\
    \    There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    >>> exchange([1, 2, 3, 4], [1, 2, 3, 4])\n  \
    \  \"YES\"\n    >>> exchange([1, 2, 3, 4], [1, 5, 3, 4])\n    \"NO\"\n    It is\
    \ assumed that the input vectors will be non-empty.\n    \"\"\"\n    pass\nend\
    \ # function exchange\n</cell>\n<code language=julia-1.1>\n\"\"\"\n    solution(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String", "    \n    \n    \n\"\"\"\n### Problem 7: Implement\
    \ a function that can generate permutations of a given list of elements\n### Input:\
    \ lst = a list of integers\n### Output: permuted_lst = a list of lists of permutations\n\
    ### Each permutation is a permutation of the integers in lst\n### \n### Examples\n\
    ### The first call to permut produces the following list:\n###     [[1],[2],[3],[4]]\n\
    ### The second call produces the following list:\n###     [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n\
    ### The third call produces the following list:\n###     [[1,3],[2,3],[1,4],[3,4],[1,2],[2,4],[1,3],[2,1]]\n\
    \"\"\"", "    return \n\"\"\"", "    evens = zeros(Int, length(lst1))\n    for\
    \ i in eachindex(lst1)\n        if lst1[i] == 0 && lst2[i] == 0\n            evens[i]\
    \ = 0\n        elseif lst1[i] % 2 == 0 && lst2[i] % 2 == 0\n            evens[i]\
    \ = 1\n        else\n            if lst1[i] % 2 != 0 && lst2[i] % 2 != 0\n   \
    \             evens[i] = 0\n            else\n                evens[i] = 1\n \
    \           end\n        end\n    end\n    return sum(evens) == 1\nend\n</code>\n\
    <|/ a |>\n<| c |>\nIt's not correct - it can return `NO` even when lst1 and lst2\
    \ are both `[1,2,3]` but with different elements. Check my answer.\n<|/ c |>\n\
    <| c |>\nThanks for pointing that out, fixed. I had the code working on [1,2,3,4,5]\
    \ but it was still returning \"NO\" when all elements were even. Now it works\
    \ even when the numbers are out of order.\n<|/ c |>\n<| a tags=julia,performance\
    \ |>\nHere's my take:\n<code>", "    \n    if length(lst1) != length(lst2)\n \
    \   return \"NO\"\n    end\n    \n    even=[]\n    odd=[]\n    for i in 1:length(lst1)\n\
    \        if isodd(lst1[i])\n            push!(odd, lst1[i])\n        else \n \
    \           push!(even, lst1[i])\n        end\n    end", "    \"\"\"\n    lst1=\
    \ [1,3,5,7,9] lst2= [2,4,6,8,10]\n    exchange\n    returns YES if an exchange\
    \ can be performed\n    between all the elements of the two input lists and lst1\
    \ to\n    make all the elements of lst1 to be even, otherwise returns NO\n   \
    \ \"\"\"", "    \n    even_ind = find(lst2 .% 2 .== 0)\n    \n    if(length(even_ind)\
    \ == 0)\n        return \"NO\"\n    end\n    \n    for i in even_ind\n       \
    \ if(lst1[i] % 2 != 0)\n            return \"NO\"\n        end\n    end\n    \n\
    \    for i in even_ind\n        lst1[i] = lst1[i]/2\n    end\n    \n    return\
    \ \"YES\"\nend", "    even = copy(lst1) \n    odd = copy(lst2) \n    even.remove!((even\
    \ == even).+(0)) \n    odd.remove!((odd ==  odd)+(0)) \n    for index in 2:length(even)\n\
    \        if even[index] != even[index-1] \n            return (\"NO\")\n     \
    \   end\n    end\n    for index in 2:length(odd)\n        if odd[index] != odd[index-1]\n\
    \            return (\"NO\")\n        end\n    end\n    return (\"YES\")\nend\n\
    </code>\nThe error message I get when running the exchange function is this:\n\
    <code>\nERROR: LoadError: MethodError: no method matching getindex(::Int64, ::Int64)\n\
    Closest candidates are:\n  getindex(::Type{T}, ::Symbol) where T at /Users/jakob/Code/Julia/Julia-0.3.0.src/src/arrays/array_index.jl:131,\
    \ in expression starting at /Users/jakob/Code/Julia/Julia-0.3.0.src/src/arrays/array_index.jl:135\n\
    Stacktrace:\n [1] top-level scope at ./REPL[5]:1\n [2] include_string(::Function,\
    \ ::String, ::String) at ./Base.jl:298\n [3] include_string(::String, ::String)\
    \ at ./loading.jl:1038\n [4] exec_options(::Base.JLOptions) at ./client.jl:266\n\
    \ [5] _start() at ./client.jl:499\nin expression starting at /Users/jakob/Code/Julia/Julia-0.3.0.src/src/repl.jl:9",
  "    \n    lst1=sort(lst1)\n    lst2=sort(lst2)\n    if length(lst1)==0 || length(lst2)==0\n\
    \        return \"NO\"\n    end\n    \n    if lst1[end] == lst2[end]\n       \
    \ return \"NO\"\n    end\n    \n    if length(lst1) < length(lst2)\n        swap!(lst1,\
    \ end, 1)\n    end\n    \n    for i = length(lst1)+1:length(lst2)\n        if\
    \ lst1[i] % 2 == 0 && lst2[i] % 2 != 0\n            return \"NO\"\n        end\n\
    \    end\n    \n    return \"YES\"\nend", "    for i in length(lst1); \n     \
    \   if mod(lst1[i],2)==0 \n            lst2[i]=lst1[i]\n        else\n       \
    \     lst2[i]=lst1[i]+1\n        end\n    end\n    if length(lst2)==length(lst1)\
    \ \n        return \"YES\"\n    else\n        return \"NO\"\n    end\nend\n</cell>\n\
    <text>\nQ4: Write a Julia function (or macro) to compute the product of a collection\
    \ of numbers.\n    It is assumed that the input collection will be non-empty.\n\
    \    \n    You can use the macro or a function definition above, whichever you\
    \ find more readable.\n    It should use the reduce function to compute the product\
    \ of the elements in the input collection.\n    \n    You can use the product\
    \ function from Base.\n    \"\"\"", "    \"\"\"\n    This function takes in two\
    \ vectors of Int64, and determines whether it is possible to perform an exchange\
    \ of elements - lst1 a vector of only even numbers - lst2 to make lst1 a vector\
    \ of only even numbers.\n    If it is possible to exchange elements between the\
    \ lst1 and lst2 to make all the elements of lst1 to be even, return \"YES\".\n\
    \    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1, 2, 3, 4],\
    \ [1, 2, 3, 4])\n    \"YES\"\n    >>> exchange([1, 2, 3, 4], [1, 5, 3, 4])\n \
    \   \"NO\"\n    It is assumed that the input vectors will be non-empty.\n    \"\
    \"\"\n    \n    #your code here", "    \n    even = Int64[]\n    even = findall(x\
    \ -> x % 2 ==0, lst1)\n    \n    if iseven(even)\n        return(\"NO\")\n   \
    \ end", "    \"\"\"\n    This function is called when a user calls an exchange\
    \ function\n    \n    Arguments\n    ---------\n        lst1: a vector of integers\n\
    \        lst2: a vector of integers\n        \n    Returns\n    -------\n    \
    \    a string that contains \"YES\" or \"NO\" depending on the answer to the\n\
    \        exchange operation between lst1 and lst2\n    \"\"\"\n    \n    answer\
    \ = []\n    \n    for i = 1:length(lst1)\n        if lst2[i] == lst1[i] && lst2[i]\
    \ == 0\n            answer.push(\"YES\")\n        end\n    end\n    \n    for\
    \ i = 1:length(lst2)\n        if lst2[i] == 0 && lst2[i] != 0\n            answer.push(\"\
    NO\")\n        end\n    end\n    \n    return join(answer)\nend\n</cell>\n<code\
    \ language=julia-0.5>\n\"\"\"\n    findparity(lst)\n    \n    Function that finds\
    \ how many elements are evenly divisible by each other\n    \n    Arguments\n\
    \    ---------\n        lst: an array of integers\n    \n    Returns\n    -------\n\
    \        an integer representing the parity of all the elements in the list\n\"\
    \"\"", "# your code goes here\n    \n    \n    return \nend", "    if length(lst1)==0\
    \ || length(lst2)==0\n    else if all(iseven(lst1) && iseven(lst2))\n    then\
    \ \"YES\"\n    else \"NO\"\n    end\nend\n</cell>\n<text>\n3.5 Reverse List",
  "\"\"\"\n    This function returns the value returned by the function 'exchange'\
    \ that\n    takes two vectors of numbers, and determines whether it is possible\
    \ to perform an \n    exchange of elements between them to make lst1 a vector\
    \ of only even numbers.\n    There is no limit on the number of exchanged elements\
    \ between lst1 and lst2.\n    If it is possible to exchange elements between the\
    \ lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\"\
    .\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1, 2, 3,\
    \ 4], [1, 2, 3, 4])\n    \"YES\"\n    >>> exchange([1, 2, 3, 4], [1, 5, 3, 4])\n\
    \    \"NO\"\n    It is assumed that the input vectors will be non-empty.\n   \
    \ \"\"\"", "#return \"NO\" when lst1 and lst2 are both empty vectors.\n    \n\
    \    if lst1 == [] || lst2 == []\n        return \"NO\"\n    \n    exchange_count\
    \ = 0\n    \n    lst1 = copy(lst1)\n    lst2 = copy(lst2)\n    \n    lst1 = sort(lst1)\n\
    \    lst2 = sort(lst2)\n    \n    \n    for i = 1:length(lst1)\n        if lst1[i]\
    \ < lst2[i]\n            exchange(lst1[i:], lst2[1: (length(lst1)-i)])\n     \
    \       exchange_count = exchange_count + 1\n        elseif lst2[i] < lst1[i]\n\
    \            exchange(lst1[(i+1):], lst2[i:])\n            exchange_count = exchange_count\
    \ + 1\n        end\n        \n    end\n    if exchange_count == length(lst1)\n\
    \        return \"YES\"\n    else\n        return \"NO\"\n    end\nend", "   \
    \ \n    \n    return \"\"\nend\n</cell>\n<text>\nExercise\nNow complete the function\
    \ exchange_test to test your code.", "    even1 = findall(lst1 .% 2 == 0)\n  \
    \  even2 = findall(lst2 .% 2 == 0)\n    even1_even2 = intersect(even1, even2)\n\
    \    return isempty(even1_even2) ? \"NO\" : \"YES\"\n    end\n</code>\n<|/ a dscore=1\
    \ tags=julia |>\n<| a dscore=0 |>\n<code>", "    if length(lst1) == 0\n      \
    \  return \"NO\"\n    end\n    \n    if length(lst2) == 0\n        return \"NO\"\
    \n    end\n    \n    evens = []\n    odds = []\n    for i in lst1\n        if\
    \ i%2 != 0\n            push!(odds,i)\n        else\n            push!(evens,i)\n\
    \        end\n    end\n    for i in lst2\n        if i%2 != 0\n            push!(odds,i)\n\
    \        else\n            push!(evens,i)\n        end\n    end\n    \n    evens\
    \ = vcat(evens,lst2[-length(lst2):])\n    odds = vcat(odds,lst1[-length(lst1):])\n\
    \    for i in evens\n        if i in odds\n            return \"NO\"\n       \
    \ end\n    end\n    \n    return \"YES\"\nend", "    if length(lst1) == 0 || length(lst2)\
    \ == 0\n        return ''\n    lst1 = sort(lst1)\n    lst2 = sort(lst2)\n    \n\
    \    if length(lst1) > length(lst2)\n        lst1, lst2 = lst2, lst1\n    end\n\
    \    \n    even = true\n    for x in lst1\n        if x % 2 == 0\n           \
    \ even = false\n            break\n        end\n    end\n    \n    if !even\n\
    \        return 'NO'\n    else\n        \n        for i in 1 : length(lst1)\n\
    \            \n            if lst1[i] == lst2[i]\n                continue\n \
    \           end\n            if lst1[i] > lst2[i]\n                lst1[i], lst2[i]\
    \ = lst2[i], lst1[i]\n            end\n        end\n        \n        return 'YES'\n\
    \    end\nend\n</cell>\n<code language=julia-0.5>", "    if length(lst1) == length(lst2)\n\
    \        return \"NO\"\n    \n    exchanged = setdiff(unique(union(lst1, lst2)),\
    \ union(lst1, lst2))\n    \n    for elem in exchanged:\n        lst1 = delete(lst1,\
    \ elem)\n        lst2 = delete(lst2, elem)\n        if length(lst1) == length(lst2)\n\
    \            return \"NO\"\n        \n    return \"YES\"\nend", "    # put your\
    \ code here\n    return \"NO\"\nend\n</cell>\n<code language=julia-1.3>\nusing\
    \ Test", "    \n    \nend", "    if length(lst1) == 0 || length(lst2) == 0 \n\
    \        return \"NO\" \n    \n    even1 = sum(lst1) \n    even2 = sum(lst2) \n\
    \    \n    if even1 != even2 \n        return \"NO\" \n    end\n    \n    even1\
    \ = lst1 \n    even2 = lst2 \n    \n    even1 = even1 .- 2 \n    even2 = even2\
    \ .- 2 \n    \n    if even1 .== 0 \n        return \"NO\" \n    end\n    \n  \
    \  if even2 .== 0 \n        return \"NO\" \n    end\n    \n    i = 0\n    j =\
    \ 0\n    \n    while i < length(even1) \n        if even1[i] % 2 == 0 \n     \
    \       if even2[j] % 2 == 0 \n                if even1[i] < even2[j] \n     \
    \               i = i + 1 \n                else \n                    j = j +\
    \ 1 \n                end\n            end\n        end\n        \n        i +=\
    \ 1\n        j += 1\n    end\n    \n    if even1[i] % 2 == 0 \n        return\
    \ \"NO\" \n    end\n    \n    if even2[j] % 2 == 0 \n        return \"NO\" \n\
    \    end\n    \n    return \"YES\"\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\n\
    The idea here is that we will sort the two lists (even and odd numbers) into two\
    \ sublists (even and odd) and then we will check if any of those elements exists\
    \ in both sublists. Using sets, that gives us an O(n log n) solution. Here's the\
    \ code I used:\n<code>", "    \n\"\"\"Write your solution here\"\"\"\n    \nend",
  "    count = 0\n    for n in lst1 \n        if n%2 == 0 \n            count += 1\n\
    \        else \n            count = 0 \n    end\n    for n in lst2 \n        if\
    \ n%2 == 0 \n            if count != 0 \n                return \"NO\" \n    \
    \        else \n                count = 0 \n            end \n        else \n\
    \            count = 0 \n        end \n    end\n    return \"YES\"\nend\n</cell>\n\
    <code language=julia-1.5>\n# TEST Exchange (17 points)\ntest(exchange)\n</cell>\n\
    <text>\nTask 9. Compare Two Vectors of Bools\nWrite a function which takes in\
    \ two vectors of Bool elements,\n    and returns two vectors of Bool elements,\
    \ one containing\n    elements that are in both vectors, the other containg\n\
    \    elements that are in *either* vector.", "    if lst1 == [] || lst2 == []\
    \ \n    return \"NO\" \n    else \n        lst1 = [ x | x <- lst1] \n        lst2\
    \ = [ x | x <- lst2] \n        lst1_even = lst1[findall(x % 2 .== 0)] \n     \
    \   lst2_even = lst2[findall(x % 2 .== 0)] \n        if length(lst1_even) == 0\
    \ && length(lst2_even) == 0 \n            return \"YES\" \n        elsif length(lst1_even)\
    \ > 0 && length(lst2_even) == 0 \n            return \"NO\" \n        else \n\
    \            lst1_even = [x | x <- lst1_even] \n            lst2_even = [x | x\
    \ <- lst2_even] \n            union(lst1_even, lst2_even) \n            union(lst1,\
    \ lst2) \n            lst1_even = [ x | x <- lst1_even] \n            lst2_even\
    \ = [ x | x <- lst2_even] \n            if length(lst1_even) == 0 && length(lst2_even)\
    \ == 0 \n                return \"YES\" \n            elsif length(lst1_even)\
    \ == 0 && length(lst2_even) == 0 \n                return \"NO\" \n          \
    \  else \n                return \"NO\" \n    end\nend\n</cell>\n<text>\nProblem\
    \ 4.2\nThe following function takes two vectors of numbers, and determines whether\
    \ it is possible to perform a swap\n    of elements at a specific index to make\
    \ lst1 a vector of only even numbers.\n    There is no limit on the number of\
    \ swaps you can make.\n    If it is possible to swap elements at the given index\
    \ to make all the elements of lst1 to be even,\n    return \"YES\".\n    Otherwise,\
    \ return \"NO\".\n    For example:\n    >>> swap(1:10, 1:10)\n    \"YES\"\n  \
    \  >>> swap([2,2,2,2], [2,3,5,4])\n    \"NO\"\n    It is assumed that the input\
    \ vectors will be non-empty.\n    \"\"\"", "\"\"\"\n    lst1 = convert(Vector{Int64},\
    \ lst1)\n    lst2 = convert(Vector{Int64}, lst2)\n    even = union(lst1, lst2).filter(x->x%2\
    \ .== 0)\n    if even == lst2\n        return \"YES\"\n    else\n        return\
    \ \"NO\"\n    end\nend", "   \n        \nend\n</cell>\n<code language=julia-1.5>\n\
    @test exchange([1, 4, 5], [2, 3]) |> should == \"NO\"\n@test exchange([1, 4, 5],\
    \ [2, 4]) |> should == \"YES\"\n@test exchange([1, 4, 5], [1, 2, 3, 4]) |> should\
    \ == \"NO\"\n</cell>\n<text>\nProblem 8\nThe function permute takes a vector (a\
    \ list of the numbers) and returns a list of permutations\n    of that vector.\
    \ For example, permute([1, 2, 3]) should return a list containing\n    [1, 2,\
    \ 3] in one permutation and [2, 1, 3] in another, etc.\n    No two elements in\
    \ the input vector are allowed to be the same.\n    \"\"\"", "    \n    even =\
    \ Int64[]\n    even_count = 0\n    \n    for num in lst1\n        if num%2==0\n\
    \            push!(even, num)\n            even_count += 1\n        end\n    end\n\
    \    \n    even = Int64[even]\n    \n    count = 0\n    \n    for num in lst2\n\
    \        if num in even\n            count += 1\n        else\n            return\
    \ (\"NO\")\n        end\n    end\n    \n    if count > 0 && count==length(lst1)\n\
    \        return (\"YES\")\n    end\nend\n</code>\n<|/ a |>\n<| c |>\nThe function\
    \ does not need to return `\"NO\"` in the case of an empty `lst2`; you can just\
    \ return `\"YES\"`. And you can save a lot of computational effort by writing\
    \ `return \"YES\" if (count > 0 && count==length(lst1)) || all(x -> x in even,\
    \ lst2)`.\n<|/ c |>\n<| a tags=julia,arrays |>\nA simpler version than the one\
    \ by isaac would be\n<code>", "    if length(lst1) == 0 or length(lst2) == 0 \n\
    \        return \"NO\" \n    else \n        even1 = []\n        even2 = []\n \
    \       odd1 = []\n        odd2 = []\n        for i in lst1 \n            if i\
    \ %2 ==0 \n                even1 += [i]\n            else \n                odd1\
    \ += [i] \n        end\n        for i in lst2 \n            if i %2 ==0 \n   \
    \             even2 += [i]\n            else \n                odd2 += [i] \n\
    \        end\n        if length(even1) == length(even2) == length(odd1) == length(odd2)\
    \ \n            return \"YES\" \n        else \n            return \"NO\" \n \
    \   end\nend\n</cell>\n<text>\nTest Your Solution", "    if length(lst1) == 0\
    \ || length(lst2) == 0 \n    return \"NO\"\nend\n</code>\n<|/ q dscore=1 tags=julia\
    \ |>\n<| c |>\nThis question seems too broad. Please give a [mcve], showing your\
    \ attempt, and explaining how it's not working.\n<|/ c |>\n<| c |>\nI added the\
    \ example code\n<|/ c |>\n<| a tags=julia |>\nA vectorized solution:\n<code>",
  "    \n    if (length(lst1) != length(lst2)) \n        return \"NO\"\n    else\n\
    \        for i in 1:length(lst1) \n            j = i+1\n            while (j <=\
    \ length(lst1))\n                if lst1[i] + lst1[j] % 2 == 0 \n            \
    \        lst1[i] = 0\n                    lst1[j] = 0\n                else\n\
    \                    return \"NO\"\n                end\n                j +=\
    \ 1\n            end\n        end\n    \n    return \"YES\"\nend\n</cell>\n<code\
    \ language=julia-1.0>\n\"\"\"\n    even_exchange_vector(lst1::Vector{Int64}, lst2::Vector{Int64})",
  "    if length(lst1) != length(lst2) || any((x % 2 != 0) for x in lst1)\n    else\
    \ \n        return \"YES\"\n    end\nend\n</cell>\n<text>\nProblem 5 (40 points)\n\
    Write a function that takes two vectors of numbers and returns the product of\
    \ all the elements\nof the vectors. Write a test function to check whether the\
    \ vectors are empty before calling the function.\nThe test should check for empty\
    \ vectors.", "    \n    #YOUR_CODE_HERE\n    \n    return true\n    \nend\n</cell>\n\
    <cell>\nlst1 = [1,2,3,4]\nlst2 = [1,5,3,4]\n</cell>\n<cell>\nexchange(lst1, lst2)\n\
    </cell>\n<text>\n4.2 Complement of a vector", "    \nend\n</cell>\n<text>\nProblem\
    \ 5\nImplement a function that takes two vectors of numbers, and determines whether\
    \ it is possible to perform a swap between them in order to make lst1 a vector\
    \ of only even numbers.\n    There is no limit on the number of swaps that could\
    \ be performed.\n    If it is possible to swap elements of the vector to make\
    \ the even number of each of its elements equal to one,\n    return \"YES\".\n\
    \    Otherwise, return \"NO\".\n    For example:\n    >>> swap([1, 2, 3, 4], [1,\
    \ 5, 3, 4])\n    \"YES\"\n    >>> swap([1, 2, 3, 4], [1, 5, 3, 5])\n    \"NO\"\
    \n    It is assumed that the input vectors will be non-empty.\n    \"\"\"", " \
    \   \n    \n    return \nend", "    \n    if length(lst1) != length(lst2)\n  \
    \      return \"NO\"\n    end\n    \n    exchanged = trues(length(lst1))\n   \
    \ \n    for (i, e) in enumerate(lst1)\n        \n        if e % 2 != 0 && !exchanged[i]\n\
    \            exchanged[i] = false\n            lst2[i] =  e % 2\n        end\n\
    \    end\n    \n    if all(!exchanged)\n        return \"YES\"\n    end\n    return\
    \ \"NO\"\nend\n</cell>\n<cell>\n#Run this cell to check if your result is correct.\n\
    assert(exchange([1,2,3,4], [1,2,3,4]) == \"YES\")\n</cell>\n<text>\nQuestion 12\n\
    Let lst1 and lst2 be lists of positive integers. Write a function that takes\n\
    \    as input two lists of integers and returns True if it is possible to exchange\n\
    \    elements between them such that all the even elements of lst1 are even\n\
    \    and the even elements of lst2 are odd.\n    For example, if lst1 = [1,2,3,4,5]\
    \ and lst2 = [2,4,6,8,10] then the\n    function should return True, because it\
    \ is possible to exchange the\n    even elements of lst1 with all the odd elements\
    \ of lst2.\n    Your function should work for any two lists of integers that do\
    \ not have a\n    maximum length. Use assert to test your function correctly.\n\
    \    For example:\n    >>> exchange([1,2,3,4,5], [2,4,6,8,10])\n    true\n   \
    \ >>> exchange([1,2,3,4,5], [2,4,6,8,9])\n    false\n    It is assumed that the\
    \ input vectors will be non-empty.\n    \"\"\"", "    \n    even=false\n    even1=false\n\
    \    even2=false\n    even3=false\n    even4=false\n    even5=false\n    even6=false\n\
    \    even7=false\n    even8=false\n    even9=false\n    even10=false\n    even11=false\n\
    \    even12=false\n    even13=false\n    even14=false\n    even15=false\n    even16=false\n\
    \    even17=false\n    even18=false\n    even19=false\n    even20=false\n    even21=false\n\
    \    even22=false\n    even23=false\n    even24=false\n    even25=false\n    even26=false\n\
    \    even27=false\n    even28=false\n    even29=false\n    even30=false\n    even31=false\n\
    \    even32=false\n    even33=false\n    even34=false\n    even35=false\n    even36=false\n\
    \    even37=false\n    even38=false\n    even39=false\n    even40=false\n    even41=false\n\
    \    even42=false\n    even43=false\n    even44=false\n    even45=false\n    even46=false\n\
    \    even47=false\n    even48=false\n    even49=false\n    even50=false\n    even51=false\n\
    \    even52=false\n    even53=false\n    even54=false\n    even55=false\n    even56=false\n\
    \    even57=false\n    even58=false\n    even59=false\n    even60=false\n    even61=false\n\
    \    even62=false\n    even63=false\n    even64=false\n    even65=false\n    even66=false\n\
    \    even67=false\n    even68=false\n    even69=false\n    even70=false\n    even71=false\n\
    \    even72=false\n    even73=false\n    even74=false\n    even75=false\n    even76=false\n\
    \    even77=false\n    even78=false\n    even79=false\n    even80=false\n    even81=false\n\
    \    even82=false\n    even83=false\n    even84=false\n    even85=", "    if length(lst1)\
    \ == 0 || length(lst2) == 0 \n        return \"NO\" \n    count = 0\n    if lst1[1]\
    \ % 2 == 0 && lst2[1] % 2 == 0 \n        return \"YES\" \n    else \n        for\
    \ i in 2:length(lst1)\n            if lst1[i] % 2 == 0 && lst2[i] % 2 == 0 \n\
    \                count = count + 1\n            end\n        end\n        if count\
    \ < length(lst1)\n            return \"YES\"\n        else\n            return\
    \ \"NO\"\n        end\n    end\nend\n</cell>\n<code language=julia-1.5>", "  \
    \  # Your code here\n    even_lst = lst1 .% 2 ==0\n    even_lst = even_lst .*\
    \ (lst1 .== (lst2 .- 2)) .& even_lst\n    even_lst = even_lst .* (lst1 .== (lst2\
    \ .+ 2)) .& even_lst\n    if sum(even_lst) == 0 \n        \"NO\"\n    else \n\
    \        \"YES\"\n    end\nend\n</code>\nThe output will be:\n<code>\nYES, YES,\
    \ YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES,\
    \ YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES,\
    \ YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES,\
    \ YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES,\
    \ YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES,\
    \ YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES,\
    \ YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES,\
    \ YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES,\
    \ YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES,\
    \ YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES,\
    \ YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES,\
    \ YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, YES,\
    \ YES, YES, YES, YES, YES, YES, YES, YES, YES, ", "    \n    #write your code\
    \ here\n    \n    return \"NO\"\nend\n</cell>\n<text>\nProblem 10\nWrite a function\
    \ that counts the number of elements of a given type in a vector.\nFor example,\
    \ a function that counts the number of integer elements of a vector:\n[3, 1, 2]\
    \ has 3 as the number of integer elements.\nYou can assume that the vector contains\
    \ only integer elements.\nThe function should take an input vector as an argument.\n\
    The function should return an integer as the result.\nNote that this function\
    \ will be called multiple times in the following cell cells.", "    if length(lst1)\
    \ != length(lst2)\n        return \"NO\"\n    end\n    \n    even = trues(length(lst1))\n\
    \    for (i,j) in zip(1:length(lst1), 1:length(lst2))\n        if isodd(lst1[i])\
    \ != isodd(lst2[j])\n            even[i] = false\n        end\n    end\n    if\
    \ all(even)\n        return \"YES\"\n    else\n        return \"NO\"\n    end\n\
    end\n</cell>\n<text>\nTo test your code, we recommend you to use the code below\
    \ as a starting point. Feel free to change it.", "\"\"\"\n    return ???", " \
    \   \n    # Write your code here\n    \n    return \"\"\nend # end exchange\n\
    </cell>\n<text>\nRun the cell below to check your implementation. The result must\
    \ be \"YES\".", "    \n    \n    \n    # return \"NO\" if there are no elements\
    \ in lst1 and lst2\n    # return \"YES\" if there is one element in lst1 and lst2\n\
    \    # return the string \"NO\" if lst1 and lst2 are not empty and there are elements\n\
    \    # in lst1 and lst2 which cannot exchange elements\n    # return the string\
    \ \"YES\" if there are no elements in lst1 and lst2 and there are\n    # elements\
    \ in lst1 and lst2 which can exchange elements\n    \n    if length(lst1) == 0\
    \ || length(lst2) == 0\n        return \"NO\"\n    elseif length(lst1) == 1\n\
    \        return string(\"NO\") + string(\"YES\")\n    elseif length(lst2) == 1\n\
    \        return string(\"NO\") + string(\"YES\")\n    elseif length(lst1) > length(lst2)\n\
    \        return string(\"NO\") + string(\"YES\")\n    else\n        \n       \
    \ if length(lst1) < length(lst2)\n            return string(\"NO\") + string(\"\
    YES\")\n        elseif length(lst1) != length(lst2)\n            return string(\"\
    NO\") + string(\"YES\")\n        else\n            \n            if lst1[1] mod\
    \ 2 != 0 && lst2[1] mod 2 != 0\n                return string(\"NO\") + string(\"\
    YES\")\n            else\n                \n                if lst1[1] mod 2 ==\
    \ 0 && lst2[1] mod 2 == 0\n                    return string(\"NO\") + string(\"\
    YES\")\n                else\n                    \n                    if lst1[1]\
    \ mod 2 != 0 && lst2[1] mod 2 == 0\n                        return string(\"NO\"\
    ) + string(\"YES\")\n                    else\n                        \n    \
    \                    if lst1[1] mod 2 == 0 && lst2[1] mod 2 != 0\n           \
    \                 return string(\"NO\") + string(\"YES\")\n                  \
    \      else\n                            \n                            if lst1[1]\
    \ mod 2 != 0 && lst2[1] mod 2 != 0\n                                return string(\"\
    NO\") + string(\"YES\")\n                            else\n                  \
    \              return string(\"NO\") + string(\"YES\")\n                    end\n\
    \                end\n            end\n        end\n    end\nend\n</cell>\n<text>\n\
    Exercise 2\nImplement the function is_even, that takes two numbers as input and\
    \ returns the string \"YES\" if it is possible to perform an exchange of elements\
    \ between them in a way that all the elements of one input list are even, and\
    \ returns the string \"NO\" otherwise.\n    For example:\n    >>> is_even(3, 5)\n\
    \    \"YES\"\n    >>> is_even(1, 4)\n    \"NO\"\n    It is assumed that the input\
    \ numbers will be non-negative.\n    \"\"\"", "    if length(lst1)==0 then return\
    \ \"NO\" else \n        if length(lst2)==0 then return \"NO\" else \n        \
    \    if sum(lst1) == sum(lst2) then \n                lst1=lst1[2:end-1]\n   \
    \             lst2=lst2[2:end-1]\n                return \"YES\"\n           \
    \ elseif sum(lst1) > sum(lst2) then \n                lst1=lst1[2:end-1]\n   \
    \             return \"YES\"\n            elseif sum(lst1) < sum(lst2) then \n\
    \                lst2=lst2[2:end-1]\n                return \"YES\"\n        \
    \    end\n        end\n    end\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=function,arrays,julia\
    \ dscore=1 |>\n<code>", "    if length(lst1) != length(lst2) || sum(lst1) != sum(lst2)\n\
    \        return \"NO\"\n    end", "# your code here\n    \n    \nend\n</cell>\n\
    <code language=julia-1.6>\n@assert exchange([1, 2, 3, 4], [1, 5, 3, 4]) \u2248\
    \ \"YES\"\n@assert exchange([1, 2, 3, 4], [1, 2, 3, 4])   \u2248 \"NO\"\n@assert\
    \ exchange([-1, 5, -1, 4], [-2, 1, 2, 1])   \u2248 \"NO\"\n@assert exchange([-3,\
    \ -2, -2, -2], [-4, -4, -3, -2])   \u2248 \"YES\"\n</cell>\n<text>\n12. Given\
    \ the integers $a, b, c, d$ find $e$:\n    $e = (a + b + c) / d$\n    such that\
    \ $a + b + c = e$, and $a, b, c, d$ are coprime\n    (i.e., ab, bc, cd, d$ are\
    \ distinct).\n    You might want to use the fractions module; for now, use\n \
    \   integer division (truncated) rather than floor division.\n    For example,\
    \ with $a = 5, b = 2, c = 1, d = 2$, you would have\n    $e = 5 + 2 + 1 = 3$,\
    \ and $(a, b, c), (d, e)$ are coprime.", "    if length(lst1)==0 || length(lst2)==0\
    \ \n        return \"NO\" \n    else if length(lst1) > length(lst2) \n       \
    \ return \"NO\" \n    end", '"""', "    if length(lst1) == 0 || length(lst2) ==\
    \ 0\n        return \"NO\"\n    end\n    evens = filter(x -> x % 2 == 0, lst1)\n\
    \    if length(evens) == 0\n        return \"NO\"\n    end\n    evens = take(evens,\
    \ length(lst2))\n    return isequal(lst1, evens)? \"YES\" : \"NO\"\nend\n</code>\n\
    <|/ a tags=julia,function,performance |>\n<| a dscore=3 |>\nI took a little bit\
    \ of time to benchmark different solutions. \nMy solution:\n<code>", "    return\
    \ \"\"\n    \n\"\"\"\nFor this problem, write a function which takes in a vector\
    \ of\nnumbers, and returns a vector consisting of the sum of all the elements\n\
    in the input vector, but excluding any zero elements. Do not include\nany non-numeric\
    \ elements in the sum.\nFor example:\n    >>> sum([1, 2, 0, 3]) returns 5\n  \
    \  \"\"\"", "    if length(lst1) == 0 || length(lst2) == 0 \n        return \"\
    NO\"\n    end\n    even = 0\n    odd = 0\n    i = 0\n    \n    while i < length(lst1)\n\
    \        if lst1[i] % 2 == 0\n            even += 1\n        elseif lst1[i] %\
    \ 2 != 0\n            odd += 1\n        else\n            if lst2[i] % 2 == 0\n\
    \                even += 1\n            elseif lst2[i] % 2 != 0\n            \
    \    odd += 1\n            else\n                if even < odd \n            \
    \        return \"YES\"\n                else\n                    return \"NO\"\
    \n                end\n            end\n        end\n        i += 1\n    end\n\
    \    return \"NO\"\nend\n</cell>\n<code language=julia-1.0>\nx = Vector{Int64}[1,2,3,4,5]\n\
    y = Vector{Int64}[1,2,3,5,4]", "    even = take(lst1, 2)\n    odd = take(lst2,\
    \ 2)\n    \n    if sum(even) !=0 || sum(odd) != 0\n        return \"NO\"\n   \
    \ \n    for a in even\n        for b in odd\n            if a%2 == 0 && b%2 ==\
    \ 0\n                lst1 = take!(lst1, 2)\n                lst2 = take!(lst2,\
    \ 2)\n            else\n                lst1 = append!(lst1, a)\n            \
    \    lst2 = append!(lst2, b)\n            end\n        end\n    end\n    return\
    \ \"\"\nend", '    return ', "  \n  #Write your code here\n  if length(lst1) !=\
    \ length(lst2)\n    return \"NO\"\n  else\n    even = []\n    for i in 1:length(lst1)\n\
    \      if mod(lst1[i], 2) == 0\n        even = append(even, lst1[i])\n      end\n\
    \    end\n    return length(intersect(even, lst2)) == length(even) ? \"YES\" :\
    \ \"NO\"\n  end\nend\n</cell>\n<text>\nPart 5: Write a function that takes two\
    \ vectors of integers and returns \"YES\" if they have a common \n    element,\
    \ and \"NO\" if they don't.\n    For example:\n    >>> common([2,3,4], [1,3,4,5,6])\n\
    \    \"YES\"\n    >>> common([2,3,4], [1,3,4])\n    \"NO\"\n    >>> common([2,3,4,5],\
    \ [1,3,4,5,6])\n    \"NO\"\n    Use the % operator to write a function common([a,\
    \ b], [c d e]). \n    It is assumed that the two input vectors have the same length.\n\
    \    Write your function so that it only returns \"YES\" when the input\n    vectors\
    \ have the same length.", "    for i in length(lst1)\n        if lst2[i] % 2 ==\
    \ 0\n            return \"NO\"\n        end\n    end\n    return \"YES\"\nend\n\
    </cell>\n<text>\nQuestion 6\nWrite a function that takes two vectors of numbers,\
    \ performs an element-by-element exchange on both of them, and returns the result\
    \ as a new vector of numbers.\n    For example:\n    >>> exchange([1,2,3,4,5],\
    \ [1,0,2,4,5])\n    [1,2,3,4,5]\n    Exchange does not change the original vectors.\n\
    \    If one of the two vectors is empty, it is assumed that it is represented\
    \ as an empty vector.\n    \"\"\"", "    # Your code here\n    return \"\"\"Your\
    \ code here\"\"\"\nend", "    \n    even::Int64 = 0\n    odd::Int64 = 0", "  \
    \  if length(lst1)!=length(lst2)\n        return (\"NO\")\n    end\n    \n   \
    \ lst1size=length(lst1)\n    even1=zeros(Int64,lst1size)\n    even2=zeros(Int64,lst1size)\n\
    \    even1=even1=lst1[findall(lst1<lst2)] #even1 are the indices of the evens\
    \ in lst1 that are not in lst2\n    even2=even2=lst2[findall(lst1<lst2)] #even2\
    \ are the indices of the evens in lst2 that are not in lst1", "    \n    # Write\
    \ your function here.\n    \nend\n</cell>\n<text>\nNotice that", "    \n    even\
    \ = Vector{Int64}(undef, 0)\n    for i in lst1\n        even[even.!=i] += i\n\
    \    end\n    \n    even = even[even.!=0]\n    \n    if length(even) == 0\n  \
    \      return \"NO\"\n    end\n    \n    even = even.sort()\n    \n    for i in\
    \ even\n        if !isodd(i)\n            return \"NO\"\n        end\n    end\n\
    \    \n    return \"YES\"\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia,arrays\
    \ |>\nThe easiest way is to convert both vectors to sets, then check intersection.\n\
    <code>\njulia> setdiff(Int64.([1,2,3]),Int64.([1,2,3]))\n3-element Array{Int64,1}:\n\
    \ 3\n 2\n 3", "    if length(lst1) != length(lst2) \n        return error(\"Input\
    \ vectors are not of the same size\") \n    arr1 = zeros(Int64, length(lst1))\n\
    \    for i = 1:length(lst1)\n        arr1[i] = lst1[i]\n    end\n    for i = 1:length(lst2)\n\
    \        arr2[i] = lst2[i]\n    end\n    arr3 = arr1 - arr2\n    if all(arr3 .==\
    \ 0) \n        return \"NO\"\n    end\n    return true\nend\n</code>\n<|/ a dscore=0\
    \ tags=julia,vector |>\n<| c |>\nCould you please provide an example of how this\
    \ solution might be used?\n<|/ c |>\n<| a dscore=0 |>\nI wrote this function based\
    \ on your code.\n<code>", "    for i in 1:length(lst1)\n        for j in 1:length(lst2)\n\
    \            if lst1[i] > lst2[j] \n                lst1[i] = lst1[i] + lst2[j]\
    \ \n                lst2[j] = lst2[j] - lst1[i] \n            else\n         \
    \       lst1[i] = lst1[i] - lst2[j] \n                lst2[j] = lst2[j] + lst1[i]\
    \ \n            end\n        end\n    end", "  if length(lst1) == length(lst2)\n\
    \      return(\"YES\")\n  else \n      return(\"NO\")\n  end\nend\n</cell>\n<text>\n\
    Exercise 4 (2 points):\nA function can return multiple values. Write a function\
    \ that returns 2 values (the second and third input). Test this function with\
    \ 2 different inputs:", "    \"\"\"\n    \n    \"\"\"\n    \n    # your code goes\
    \ here\n    if length(lst1) != length(lst2)\n        throw(ArgumentError(\"lists\
    \ must have equal length\"))\n    end", "    \n    \"\"\"TODO: Please Write Your\
    \ Code Here\"\"\"\n    \n    if length(lst1) != length(lst2)\n        return \"\
    NO\"\n    end\n    \n    if length(lst1) == 1 && length(lst2) == 1\n        if\
    \ lst1[0] == lst2[0]\n            return \"YES\"\n        else\n            return\
    \ \"NO\"\n        end\n    end\n    \n    even1 = filter(x -> mod(x, 2) == 0,\
    \ lst1)\n    even2 = filter(x -> mod(x, 2) == 0, lst2)\n    \n    if length(even1)\
    \ != length(even2)\n        return \"NO\"\n    end\n    \n    if length(even1)\
    \ == 1 && length(even2) == 1\n        if even1[0] == even2[0]\n            return\
    \ \"YES\"\n        else\n            return \"NO\"\n        end\n    end\n   \
    \ \n    return \"NO\"\nend\n</cell>\n<text>\nRun the cell below to test your solution.",
  "    \n    if length(lst1) != length(lst2) then return \"NO\"\n    \n    even =\
    \ @view [i for i, x in enumerate(lst1) if x % 2 == 0]\n    odd = @view [i for\
    \ i, x in enumerate(lst1) if x % 2 != 0]\n    \n    # check if there is any possible\
    \ exchange of elements to make \n    # all the elements of lst1 to be even\n \
    \   if length(intersect(even,odd)) > 0 then return \"NO\" else return \"YES\"\n\
    end\n</cell>\n<code language=julia-1.3>\nexchange([1, 2, 3, 4], [1, 2, 3, 4])\n\
    </cell>\n<code language=julia-1.3>\nexchange([1, 2, 3, 4], [1, 5, 3, 4])\n</cell>\n\
    <text>\n15. Write a function that returns the maximum of a list. \nIt is assumed\
    \ that the input list will be non-empty.\nThe function should return an error\
    \ if the list has zero length. \nThe function should return Inf if the list is\
    \ empty. \nIt should return Inf if the input list has length zero.", "    \n \
    \   function pairs(lst)\n        for i,e in enumerate(lst)\n            if i%2==1\n\
    \                push!(result,e)\n            end\n        end\n    end\n    \n\
    \    if length(lst1)!=length(lst2)\n        return \"NO\"\n    end\n    \n   \
    \ result=[]\n    pairs(lst1)\n    \n    return join(result)\nend\n</cell>\n<text>\n\
    4.2  Exchange Elements in a Vector\nWrite a function that exchanges two elements\
    \ in a given vector, and returns a copy of the original vector with the elements\
    \ exchanged.\nFor example, if the vector contains the numbers $[1, 2, 3, 4, 5]$,\
    \ and you exchange $3$ and $4$, your function should return the vector $[2, 1,\
    \ 4, 3, 5]$.", "    count = 0\n    for (a, b) in zip(lst1, lst2)\n        if a\
    \ % 2 == b % 2\n            count += 1\n    end\n    if count == length(lst1)\n\
    \        return \"YES\"\n    else\n        return \"NO\"\n    end\nend\n\"\"\"\
    \nThis function tests your implementation of exchange(). Make sure you understand\
    \ it.\n\"\"\"", '"""', "    # write your code here\n    if length(lst1) != length(lst2)\n\
    \        return \"NO\"\n    end\n    for index in 1:length(lst1)\n        if lst1[index]\
    \ % 2 == 0 && lst2[index] % 2 == 1\n            lst1[index], lst2[index] = lst2[index],\
    \ lst1[index]\n        elseif lst1[index] % 2 == 1 && lst2[index] % 2 == 0\n \
    \           lst1[index], lst2[index] = lst2[index], lst1[index]\n        end\n\
    \    end\n    return \"YES\"\nend\n</code>\n<|/ q tags=julia,performance |>\n\
    <| a dscore=3 |>\nThe trick is to use Arrays to hold your vectors. A Julia Array\
    \ is very similar to an array in C, but it's also a pointer to a memory-allocated\
    \ array in Julia. Thus, when you want to copy a vector to another vector, you\
    \ need to copy the memory allocation too, which takes time. \nFor example, if\
    \ you have the following code:\n<code>\njulia> a=rand(10); b=a\n</code>\nThe memory\
    \ allocation will take a few milliseconds, since Julia will allocate space for\
    \ a and b, and set b as a pointer to a. However, if you try to copy a to b, you\
    \ get an error:\n<code>\njulia> b=a\nERROR: MethodError: Cannot `convert` an object\
    \ of type Array{Float64,1} to an object of type Int64\n</code>\nThis happens because\
    \ the underlying memory allocation is a Float64:\n<code>\njulia> typeof(a)\nFloat64\n\
    </code>\nA solution can be to define another array a and b and copy the content\
    \ of b into a. This way the memory allocation does not take too much time:\n<code>\n\
    julia> a = zeros(10); b=a\n  12.89 ns (0 allocations: 0 bytes)", "    i=0\n  \
    \  i=0\n    l1 = lst1\n    l2 = lst2\n    \n    while i<length(lst1) && i<length(lst2)\n\
    \        if(l1[i]==l2[i])\n            i=i+1\n        else\n            if l1[i]%l2[i]==0\n\
    \                return \"NO\"\n            else\n                return \"YES\"\
    \n            end\n        end\n    end\nend", "    # Your code goes here\n  \
    \  return \nend", "    evens = filter(x -> (x % 2 == 0), lst1)\n    odds = filter(x\
    \ -> (x % 2 != 0), lst1)\n    if length(evens) == length(odds)\n        return\
    \ \"NO\"\n    end", " \n  if length(lst1)==0 || length(lst2)==0 \n    return \"\
    NO\" \n \n  evens = filter(x-> mod(x,2)==0, lst1)\n  if length(evens)==length(lst1)\
    \ \n    return \"YES\" \n  else \n    return \"NO\" \nend\n</cell>\n<code language=julia-1.5>\n\
    # Test your function with the examples\n@test exchange([1, 2, 3, 4], [1, 2, 3,\
    \ 4]) \n@test exchange([1, 2, 3, 4], [1, 5, 3, 4]) \n@test exchange([1, 2, 3,\
    \ 4], [1, 2, 4, 3]) \n@test exchange([1, 2, 3, 4], [1, 3, 2, 4]) \n@test exchange([1,\
    \ 2, 3, 4], [1, 2, 4, 3]) \n@test exchange([1, 2, 3, 4], [1, 2, 3, 4, 1, 5, 3,\
    \ 4]) \n@test exchange([1, 2, 3, 4], [1, 2, 3, 4, 1, 5, 3, 4]) \n@test exchange([1,\
    \ 2, 3, 4, 1, 5, 3, 4], [1, 3, 2, 4])\n</cell>\n<text>\nTask:\nImplement a function\
    \ named \"pairwise\" that takes as input a vector of integers and returns an\n\
    \    array of pairwise differences between adjacent elements in the vector.\n\
    Example:", "    if length(lst1) == 0 || length(lst2) == 0 then return \"NO\"\n\
    \    else if length(lst1) == 0  && length(lst2) > 0 then return \"NO\" \n    else\
    \ if length(lst1) > 0 && length(lst2) == 0 then return \"NO\" \n    else if length(lst1)\
    \ > 0 && length(lst2) > 0 then return \"YES\"\n    else if length(lst1) == length(lst2)\
    \ then \n        for idx in 1:length(lst1) \n            if lst1[idx] != lst2[idx]\
    \  \n                then return \"NO\"\n            end\n        end\n      \
    \  return \"YES\"\n    end\nend\n\"\"\"\n### 4.\n\"\"\"\nWrite a function called\
    \ \"isodd\" that takes two vectors of integer numbers and determines whether the\
    \ elements of the first vector are odd numbers and the elements of the second\
    \ vector are even.\nThe function must return the string \"YES\" or \"NO\".\nFor\
    \ example:\n    >>> isodd([1, 2, 3, 4], [1, 5, 3, 4]) \n    \"YES\"\n    >>> isodd([1,\
    \ 2, 3, 4], [1, 2, 3, 4])\n    \"NO\"\n    It is assumed that the input vectors\
    \ will be non-empty.\n\"\"\"", "    \n    len1 =length(lst1)\n    len2 =length(lst2)\n\
    \    if len1 > len2\n        return (\"NO\")\n    end\n    \n    # find all unique\
    \ elements in list1 and list2, \n    # and check whether they occur twice in list1\
    \ and list2\n    lst1set = Set(lst1)\n    lst2set = Set(lst2)\n    lst1set_list\
    \ = sort(collect(lst1set))\n    lst2set_list = sort(collect(lst2set))\n    \n\
    \    for x in lst1set_list \n        for y in lst2set_list\n            if x ==\
    \ y\n                return (\"NO\")\n            end\n        end\n    end\n\
    \    \n    #find unique elements of list1 and list2\n    unique_set = Set([x for\
    \ (x, y) in zip(lst1, lst2) if x!=y])\n    \n    # all elements of unique set\
    \ are present in lst1 and lst2\n    if length(unique_set) == length(lst1)+length(lst2)\n\
    \        \n        # remove elements that are not even in lst1 and lst2\n    \
    \    for element in unique_set\n            if element % 2 != 0\n            \
    \    lst1 = setdiff(lst1, element)\n                lst2 = setdiff(lst2, element)\n\
    \                break\n            end\n        end\n        \n        if length(lst1)\
    \ != length(unique_set)\n            return (\"NO\")\n        end\n        \n\
    \        for element in unique_set\n            if element % 2 == 0\n        \
    \        return (\"YES\")\n            end\n        end\n    end\n    \n    return\
    \ (\"NO\")\nend # end function exchange\n</cell>\n<text>\nExplain how your solution\
    \ works.", "    if length(lst1) != length(lst2)\n        return \"NO\"\n    end\n\
    \    map( x -> x % 2 === 0 ? \"YES\" : \"NO\", lst1 )\nend\n</cell>\n<cell>\n\
    @test exchange([2,4,6,8], [1,2,3,4]) == \"NO\"\n</cell>\n<text>\nExercise 3\n\
    Write a function that takes two vectors of ints, and returns a vector of bools.\
    \ Each element of the returned vector is True\n    if the corresponding element\
    \ of both the input vectors are equal, and False otherwise. For example:\n   \
    \ >>> x = [1,2]\n    >>> y = [2,1]\n    >>> compare(x, y)\n    [True, True]\n\
    \    For example:\n    >>> compare([1,2], [1,2])\n    [True, False]\n    \"\"\"",
  "    l1 = length(lst1)\n    l2 = length(lst2)\n    if l1 != l2 \n        return\
    \ \"NO\"\n    end", "    \n    #Your code here\n    #return \"Nothing\"", "  \
    \  if length(lst1) == 0 || length(lst2) == 0 \n        return \"NO\" \n      \
    \  \n    exchange_count = 0\n    for ii in 1:length(lst1) \n        \n       \
    \ if lst1[ii] != lst2[ii] \n            return (\"NO\") \n        else \n    \
    \        exchange_count += 1 \n        end \n    end \n    \n    if exchange_count\
    \ == length(lst1) \n        return (\"YES\") \n    end \n    \n    return (\"\
    NO\") \nend \n</cell>\n<code language=julia-0.6>\n# Check your solution below\n\
    assert(exchange([2,4,6,8,10], [2,4,6,8,10]) == \"YES\")\nassert(exchange([2,4,6,8,10],\
    \ [2,4,5,6,10]) == \"NO\")\nassert(exchange([2,4,6,8,10], [2,4,6,8,8,10]) == \"\
    NO\")\n</cell>\n<text>\nPart Two\nIn this problem, you will implement a function\
    \ that takes a vector of numbers and returns a new vector that is the same size\
    \ as \nthe original vector, with all the negative numbers changed to zero, and\
    \ all the positive numbers \nchanged to one. \nA vector containing only 0's will\
    \ leave the original vector unchanged. \nA vector containing only one's will leave\
    \ the original vector unchanged. \nThe original vector will be entirely replaced\
    \ with the new vector.\nThe vector is returned as a new vector of the same type\
    \ as the original.\nFor example:\n>>> negativeChange([1, 4, -2, 6, -4, 1])\n[2,\
    \ -2, 0, 6, 0, 1]\nFor this problem, you can think of elements of the new vector\
    \ as being \"on back\"\nor \"on top\" of the corresponding element of the original\
    \ vector. \nThis means that the original number at position i of the new vector\
    \ will\nbe replaced with the original number at position i+1 of the original vector\n\
    (to ensure that the original number at position i is replaced with the\noriginal\
    \ number at position i+1).\nThe order of the elements in the new vector will be\
    \ the same as the order of the \nelements in the original vector.\nFor example:\n\
    >>> negativeChange([10, 4, -2, 1, 5, -1])\n[2, 4, 1, 0, 5, -1]\nFor this problem,\
    \ it is assumed that there is only one way to\n\"change\" the elements of the\
    \ original vector: swap two elements. \nThat is, the vector swapped with itself\
    \ will leave the original vector\nunchanged. \nThe only exception to this is when\
    \ the vector swapped with itself is \nthe empty vector, in which case the original\
    \ vector is returned. \nYou can assume that there is only one way to change all\
    \ the elements of a \nvector.\nWrite a function called negativeChange that takes\
    \ as input a vector\nof numbers, and returns a new vector of the same type as\
    \ the input vector. \nIn your solution", "    \n    \nend\n</cell>\n<code language=julia-0.6>\n\
    @assert exchange([1, 2, 3, 4], [1, 5, 3, 4]) \u2248 \"YES\"\n@assert exchange([1,\
    \ 5, 3, 4], [1, 2, 3, 4]) \u2248 \"NO\"\n@assert exchange([1, 5, 3, 4], [4, 3,\
    \ 2, 1]) \u2248 \"YES\"\n@assert exchange([1, 5, 3, 4], [1, 2, 3, 4]) \u2248 \"\
    NO\"\n</cell>\n<text>\nExercise 9: exchange\nWrite a function to check if lst1\
    \ and lst2 are permutations on lst3.\nFor example:\n    >>> lst3 = [1, 2, 3, 4]\n\
    \    >>> lst1 = [4, 3, 2, 1]\n    >>> lst2 = [1, 2, 3, 4]\n    >>> is_permutation(lst1,\
    \ lst2, lst3)\n    True\n    >>> lst3 = [1, 2, 3, 4, 5]\n    >>> lst1 = [4, 3,\
    \ 2, 1]\n    >>> lst2 = [1, 2, 3, 4, 5]\n    >>> is_permutation(lst1, lst2, lst3)\n\
    \    False\n    >>> lst3 = [1, 2, 3, 4]\n    >>> lst1 = [4, 3, 2, 1]\n    >>>\
    \ lst2 = [1, 2, 3, 4, 5]\n    >>> is_permutation(lst1, lst2, lst3)\n    False\n\
    \    >>> lst3 = [1, 2, 3, 4, 5]\n    >>> lst1 = [4, 3, 2, 1]\n    >>> lst2 = [1,\
    \ 2, 3, 4, 6]\n    >>> is_permutation(lst1, lst2, lst3)\n    True\n    \"\"\""]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
