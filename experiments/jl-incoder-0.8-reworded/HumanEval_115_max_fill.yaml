name: HumanEval_115_max_fill
language: jl
prompt: "\"\"\"\n    You are given a rectangular grid of wells. Each row represents\
  \ a single well,\n    and each 1 in a row represents a single unit of water.\n \
  \   Each well has a corresponding bucket that can be used to extract water from\
  \ it, \n    and all buckets have the same capacity.\n    Your task is to use the\
  \ buckets to empty the wells.\n    Output the number of times you need to lower\
  \ the buckets.\n\n    Example 1:\n    >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0],\
  \ [1, 1, 1, 1]], 1)\n    6\n\n    Example 2:\n    >>> max_fill([[0, 0, 1, 1], [0,\
  \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)\n    5\n    \n    Example 3:\n    >>>\
  \ max_fill([[0, 0, 0], [0, 0, 0]], 5)\n    0\n\n    Constraints:\n        * all\
  \ wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <=\
  \ grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity\
  \ <= 10\n    \"\"\"\nfunction max_fill(grid::Vector{Vector{Int64}}, capacity::Int64)::Int64\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = max_fill;\n\t@test(candidate([[0,\
  \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1) == 6)\n\t@test(candidate([[0, 0, 1,\
  \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2) == 5)\n\t@test(candidate([[0,\
  \ 0, 0], [0, 0, 0]], 5) == 0)\n\t@test(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2)\
  \ == 4)\n\t@test(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9) == 2)\nend\n"
completions: ["    rows, cols = size(grid)\n    counts = 0\n    for i in 1:rows\n\
    \        for j in 1:cols\n            if grid[i][j] == 0\n                counts\
    \ = counts + 1\n                grid[i][j] = capacity\n            end\n     \
    \   end\n    end\n    return counts\nend", "    buckets = Vector{Vector{Int64}}(undef,\
    \ capacity)\n    for row in grid\n        buckets[row] .= zeros(1, length(row))\n\
    \    end\n    \n    count = 0\n    while true\n        count += 1\n        for\
    \ bucket in buckets\n            for pos in 1:length(bucket)\n               \
    \ if bucket[pos] == 1\n                    grid[pos] = 2\n                elseif\
    \ bucket[pos] == 0\n                    grid[pos] = 1\n                elseif\
    \ bucket[pos] == 2 \n                    grid[pos] = 2\n                end\n\
    \            end\n        end\n        if count == length(buckets)\n         \
    \   break\n        end\n    end\n    return count\nend\n</cell>\n<text>\n ", " \
    \   # write your code here\n    \n    grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n\
    \    bucket_capacity = capacity\n    bucket_width = 2\n    buckets = []\n    \n\
    \    buckets = [[] for _ in 1:3]\n    \n    for i in 1:3\n        for j in 1:3\n\
    \            if grid[i][j] == 1\n                bucket_id = floor(i / bucket_width)\n\
    \                buckets[bucket_id].append(j)\n                \n    for i in\
    \ 1:bucket_width\n        bucket_id = floor(i / bucket_width)\n        bucket_capacity\
    \ = bucket_capacity - sum(grid[bucket_id]) * bucket_width\n        if bucket_capacity\
    \ <= 0\n            return bucket_capacity\n            \n        buckets[bucket_id]\
    \ = [grid[i][j] for j in 1:bucket_capacity]\n        \n    bucket_capacity = 0\n\
    \    bucket_width = 2\n    \n    for i in 1:bucket_width\n        bucket_id =\
    \ floor(i / bucket_width)\n        bucket_capacity = bucket_capacity - sum(buckets[bucket_id])\
    \ * bucket_width\n        if bucket_capacity <= 0\n            return bucket_capacity\n\
    \            \n        buckets[bucket_id] = [grid[i][j] for j in 1:bucket_capacity]\n\
    \        \n    return bucket_capacity", "    \n    \n    \n    # write your code\
    \ here\n    n=length(grid)\n    \n    # check constraints \n    if n <= 1 || n\
    \ >= 10^2 or n != length(grid[:,1])\n        return error(\"invalid grid shape\"\
    )\n        \n    # initialize result\n    ans=0\n    \n    # loop through all\
    \ rows\n    for row in 1:n\n        \n        # initialize a vector of length\
    \ (capacity) and capacity is equal to 0 \n        bucket=Vector{Int64}(capacity)\n\
    \        \n        # loop through all columns in the row\n        for col in 1:length(grid[row,:])\n\
    \            # check whether there is any water in this column\n            if\
    \ grid[row,col] == 1\n                \n                # if there isn't, add\
    \ capacity and mark this column as empty\n                bucket[length(bucket)]+=1\n\
    \                \n                # if there is, add capacity and mark this column\
    \ as full\n                bucket[length(bucket)]-=1\n            else\n     \
    \           # if the column isn't empty, add capacity and mark this column as\
    \ full\n                bucket[length(bucket)]+=1\n                \n        \
    \        # if the column isn't empty, add capacity and mark this column as empty\n\
    \                bucket[length(bucket)]-=1\n            end\n        end\n   \
    \     \n        # loop through all columns in the row and mark the column which\
    \ has more capacity empty\n        for col in 1:length(grid[row,:])\n        \
    \    if bucket[length(bucket)] > 0\n                grid[row,col]=0\n        \
    \        break\n            end\n        end\n        \n        # count how many\
    \ times you need to lower the bucket\n        ans = ans + (length(bucket)-length(unique(bucket))-1)\n\
    \    end\n    \n    return ans\nend\n</cell>\n<code language=julia-1.4>\n@test\
    \ max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1) == 6\n</cell>\n<code\
    \ language=julia-1.4>\n@test max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1],\
    \ [0, 1, 1, 1]], 2) == 5\n</cell>\n<code language=julia-1.4>\n@test max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5) == 0\n</cell>\n<text>\nMaximum Flood Fill II", "    \n\
    \    max_length = 0\n    \n    for row in grid\n        \n        # Find length\
    \ of well\n        length = sum([1 for y in row])", "    if sum(grid)==0\n   \
    \     return 0\n    else\n        grid2 = zeros(capacity)\n        for i=1:length(grid)\n\
    \            for j=1:length(grid[i])\n                grid2[j] += grid[i][j]\n\
    \            end\n        end\n        max_val = max(grid2)\n        return count(grid2\
    \ .<=> max_val)\n    end\nend", "  max_well = maximum( grid[:,1])\n  max_well\
    \ = max_well + 1 if max_well != 0 else 1\n  res = 0\n  for row in grid\n     \
    \ well = row[1]\n      res = res + 1 if well > capacity else res - 1 if well <\
    \ 1 else 0\n  end\n  return res\nend\n</code>\nThe time complexity is O(m*n) where\
    \ m is the number of rows and n is the number of columns in each row and the time\
    \ complexity for getting the maximum well is O(m) so overall complexity is O(m*n).\n\
    <|/ a |>\n<| c |>\nCould you explain how you get the complexity of O(m*n)?\n<|/\
    \ c |>\n<| c |>\nThis code is O(m*n) but it's very inefficient. You can improve\
    \ the time complexity by just looking at two rows at a time. Just look at rows\
    \ `i` and `i+1`. The complexity is O(m).\n<|/ c |>\n<| c |>\nI made a mistake\
    \ in the first version, you can fix it by adding a condition to check the max\
    \ well in the rows and add it by 1 if the current well is higher than the max\
    \ well. I forgot to update the code on the question. Now I have updated it but\
    \ your answer is still better than my one. Thank you for bringing it up.\n<|/\
    \ c |>\n<| c |>\nThe first version was O(m*n) but it should be O(m+n) because\
    \ the number of rows is constant.\n<|/ c |>\n<| c |>\nI missed that `grid` was\
    \ a matrix. Fixed it. Thanks for the feedback.\n<|/ c |>\n<| a dscore=1 tags=algorithm,dynamic-programming,multidimensional-array\
    \ |>\nHere's my solution which runs in O(n^2 * m) where n is the number of columns\
    \ and m is the number of rows. We iterate over every possible row and column combination.\
    \ In each iteration we check if the entire row is 0 or 1 which is O(n) and then\
    \ we check if the entire column is 0 or 1 which is also O(n). We then iterate\
    \ over all possible combinations of rows and columns and check if they satisfy\
    \ the condition above.\n<code>\ndef max_fill(grid, capacity):\n    rows, cols\
    \ = grid.shape\n    for row in range(rows):\n        for col in range(cols):\n\
    \            row_sum = sum(grid[row])\n            if row_sum == 0 or row_sum\
    \ == 1:\n                col_sum = sum(grid[:, col])\n                if col_sum\
    \ == 0 or col_sum == 1:\n                    for row2 in range(row):\n       \
    \                 for col2 in range(col):\n                            if grid[row2][col2]\
    \ != row[col]:\n                                break", "    #use map with length\
    \ function to iterate through all grid rows and columns and compare the values\n\
    \    fill_grid = map(length, grid)\n    fill_capacity = map(length, capacity)\n\
    \    fill_grid[1] = fill_capacity[1]\n    for i in 1:length(grid) \n        #iterate\
    \ through every grid and find the next empty space if grid is filled up\n    \
    \    if fill_capacity[i]>=length(grid[i])\n            #if grid is filled up then\
    \ find the index of the first empty space\n            index = findfirst(fill_grid[i]>=length(grid[i]),\
    \ 1:length(grid[i]))\n        else\n            #if the grid is not filled up\
    \ then find the index of the first empty space\n            index = findfirst(fill_grid[i]<length(grid[i]),\
    \ 1:length(grid[i]))\n        end\n        \n        #fill the empty space with\
    \ the value in the capacity array\n        fill(grid[i], index, length(grid[i]))\n\
    \        #reset the fill_grid and fill_capacity\n        fill_grid[i] = fill(fill(fill_grid[i],\
    \ index, length(grid[i])), index, length(grid[i]))\n        fill_capacity[i] =\
    \ length(grid[i])\n    end\n    \n    #return the number of times you need to\
    \ lower the capacity\n    return length(fill_grid)-length(fill_capacity)\nend\n\
    </cell>\n<code language=julia-1.6>\nmax_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], 1)\n</cell>\n<code language=julia-1.6>\nmax_fill([[0, 0, 1, 1], [0,\
    \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)\n</cell>\n<code language=julia-1.6>\n\
    max_fill([[0, 0, 0], [0, 0, 0]], 5)\n</cell>\n<text>\nGreat job!", "    if length(grid)\
    \ == 0 \n        return 0 \n    end\n    \n    if length(grid) == 1 \n       \
    \ return grid[1,1]\n    end\n    \n    maxlen::Int64 = 0\n    for row in grid\
    \ \n        maxlen = max(maxlen, length(row))\n    end\n    \n    bucket_size::Int64\
    \ = maxlen/capacity\n    \n    # for each row, put water (1) into the buckets\n\
    \    buckets::Vector{Vector{Int64}} = Vector{Vector{Int64}}(undef, bucket_size)\n\
    \    for row in grid \n        buckets[floor(Int64[row]/bucket_size)] .= Int64[row]\
    \ % bucket_size \n    end\n    \n    # for each bucket, empty out the wells\n\
    \    fills::Int64 = 0\n    \n    for bucket in buckets \n        fills += length(bucket)\
    \ - length(buckets)\n    end\n    \n    return fills\nend\n</code>\n<|/ a tags=algorithm,math,arrays,sorting,search\
    \ |>\n<| a tags=algorithm,math,arrays,sorting,search |>\nThis can be solved in\
    \ O(nlogn) time complexity and O(1) space complexity by sorting by ascending or\
    \ descending based on the size of the bucket and then iterating through the sorted\
    \ array. After each iteration the array can be iterated through again to check\
    \ if any element was removed from the bucket.\n<code>\ndef maxfill(data, capacity):\n\
    \    sorted = data.sort\n    i = 0\n    fills = 0\n    while i < len(sorted) -\
    \ capacity:\n        for j in range(i, len(sorted) - capacity):\n            if\
    \ sorted[j] > sorted[j + 1]:\n                sorted[j], sorted[j + 1] = sorted[j\
    \ + 1], sorted[j]\n                j += 1\n        fills += i\n        i += 1\n\
    \    return fills\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nTo solve this\
    \ question I used a variation of the \"merge-sort\" algorithm for finding the\
    \ largest element. The difference is that in each iteration I added an element\
    \ and found the largest element and added it back in to the original array (without\
    \ removing it). To be more clear, each iteration I added the element i and then\
    \ compared the previous largest element with the new largest element. The key\
    \ here is to keep track of all the elements that have been added (we know that\
    \ every element in the original array is in the new array so no need to check\
    \ for duplicates). This is very similar to merge sort, but we only have to check\
    \ each new element against the previous largest element. At the end of the iteration\
    \ we simply need to check whether the new element we added was the largest or\
    \ not. Here is the Python implementation:\n<code>\ndef maxfill(arr,capacity):\n\
    \    l=len(", "    n=length(grid)\n    i=n-1\n    while i>=1\n        for j=1:i-1\n\
    \            if grid[i][j] == 1\n                grid[i][j]=0 \n             \
    \   grid[j][i]=0 \n                grid[i+1][j]=0 \n                grid[i+1][i+1]=0\
    \ \n            end\n        end\n        i=i-2\n    end\n    capacity=min(grid[n][n],\
    \ capacity)\n    for i=1:n\n        for j=1:n\n            if grid[i][j] == 1\n\
    \                grid[i][j] = capacity\n                capacity-=grid[i][j]\n\
    \            end\n        end\n    end\n    return n", "    i, j =  grid.length()\
    \ - 1, grid[1].length() - 1\n    \n    while i > 0 || j > 0\n        if grid[i][j]\
    \ == 1\n            while grid[i][j] == 1\n                grid[i][j] = 0\n  \
    \              i, j = i - 1, j - 1\n            end\n            \n          \
    \  grid[i][j] = 0\n            while grid[i][j] == 0\n                grid[i][j]\
    \ = 1\n                i, j = i - 1, j - 1\n            end\n        end\n   \
    \ end\n    \n    return grid[1].length()\nend\n</cell>\n<code language=julia-1.4>\n\
    max_fill([zeros(10^3), zeros(10^3), ones(10^3)], 0)\n</cell>\n<code language=julia-1.4>\n\
    max_fill([zeros(10^2), ones(10^2)], 0)\n</cell>\n<text>\nmax_fill_2\nComplete\
    \ the function max_fill_2 which has the following properties:", "    \n    fill_count\
    \ = 0\n    \n    for row in grid\n        water_count = 0\n        for cell in\
    \ row\n            if cell == 1\n                water_count += 1 \n         \
    \       fill(cell, capacity, fill_count, water_count)\n            end\n     \
    \   end\n    end\n    \n    return fill_count\n    \nend", "    return count(x\
    \ -> x != 0, reduce(x -> x + 1, map(x -> x % capacity == 1, grid)))\nend\n</cell>\n\
    <code language=julia-1.4>\n#? reduce\n</cell>\n<code language=julia-1.4>\n#? count\n\
    </cell>\n<code language=julia-1.4>\n#? map\n</cell>\n<code language=julia-1.4>\n\
    #? reduce\n</cell>\n<code language=julia-1.4>\n#? sum\n</cell>\n<code language=julia-1.4>\n\
    #? length\n</cell>\n<code language=julia-1.4>\n#? append\n</cell>\n<code language=julia-1.4>\n\
    #? sum\n</cell>\n<code language=julia-1.4>\n#? findfirst\n</cell>\n<code language=julia-1.4>\n\
    #? map\n</cell>\n<code language=julia-1.4>\n#? count\n</cell>\n<code language=julia-1.4>\n\
    #? append\n</cell>\n<code language=julia-1.4>\n#? filter\n</cell>\n<code language=julia-1.4>\n\
    #? filter\n</cell>\n<code language=julia-1.4>\n#? sum\n</cell>\n<code language=julia-1.4>\n\
    #? Any\n</cell>\n<code language=julia-1.4>\n#? isa\n</cell>\n<code language=julia-1.4>\n\
    #? sum\n</cell>\n<code language=julia-1.4>\n#? length\n</cell>\n<code language=julia-1.4>\n\
    #? Any\n</cell>\n<code language=julia-1.4>\n#? sum\n</cell>\n<code language=julia-1.4>\n\
    #? Any\n</cell>\n<code language=julia-1.4>\n#? Any\n</cell>\n<code language=julia-1.4>\n\
    #? Any\n</cell>\n<code language=julia-1.4>\n#? Any\n</cell>\n<code language=julia-1.4>\n\
    #? Any\n</cell>\n<code language=julia-1.4>\n#? Any\n</cell>\n<code language=julia-1.4>\n\
    #? Any\n</cell>\n<code language=julia-1.4>\n#? Any\n</cell>\n<code language=julia-1.4>\n\
    #? Any\n</cell>\n<code language=julia-1.4>\n#? Any\n</cell>\n<code language=julia-1.4>\n\
    #? Any\n</cell>\n<code language=julia-1.4>\n#? Any\n</cell>\n<code language=julia-1.4>\n\
    #? Any\n</cell>\n<code language=julia-1.4>", "    rows = length(grid)\n    cols\
    \ = length(grid[1])\n    \n    # initialize minimum bucket capacity to 0 and minimum\
    \ bucket number to 0\n    minimum_bucket_capacity = zero(Int64, capacity - 1)\n\
    \    minimum_bucket_number = zero(Int64, capacity - 1)\n    \n    # check each\
    \ bucket, if the bucket is full, check the remaining buckets \n    # and update\
    \ the minimum bucket capacity and minimum bucket number\n    \n    for i in 1:cols\n\
    \        if grid[1][i] == 0\n            for j in i:cols\n                if grid[j][i]\
    \ == 0\n                    minimum_bucket_capacity[i] = capacity\n          \
    \          minimum_bucket_number[i] = capacity\n                    break\n  \
    \                  if j == cols\n                        minimum_bucket_capacity[i]\
    \ = grid[1][i]\n                        minimum_bucket_number[i] = grid[1][i]\n\
    \                        break\n                    if minimum_bucket_capacity[i]\
    \ > minimum_bucket_capacity[j]\n                        minimum_bucket_capacity[i]\
    \ = minimum_bucket_capacity[j]\n                        minimum_bucket_number[i]\
    \ = minimum_bucket_number[j]\n                    end\n                    minimum_bucket_capacity[i]\
    \ = minimum_bucket_capacity[i] + grid[j][i]\n                end\n           \
    \ end\n        end\n    end\n    \n    # initialize number of empty buckets to\
    \ 0\n    number_of_empty_buckets = zero(Int64, capacity - 1)\n    \n    for i\
    \ in 1:cols\n        if grid[1][i] == 0\n            for j in 1:rows\n       \
    \         if grid[j][i] == 0\n                    number_of_empty_buckets[i] =\
    \ capacity\n                    break\n                    if j == rows\n    \
    \                    number_of_empty_buckets[i] = grid[1][i]\n               \
    \         break\n                    number_of_empty_buckets[i] = number_of_empty_buckets[i]\
    \ + grid[j][i]\n                end\n            end\n        end\n    end\n \
    \   \n    # set number of empty buckets to capacity - minimum bucket number\n\
    \    for i in 1:cols\n        if grid[1][i] == 0\n            for j in 1:rows\n\
    \                if grid[j][i] == 0\n                    number_of_empty_buckets[i]\
    \ = capacity - minimum_bucket_number[i]\n                    break\n         \
    \           if j == rows\n                        number_of_empty_buckets[i] =\
    \ grid[1][i]\n                        break\n                    number_of_empty_buckets[i]\
    \ = number_of_empty_buckets[i] + grid[j][i]\n                end\n           \
    \ end\n        end\n    end\n    \n    # set number of empty buckets to capacity\
    \ - minimum bucket capacity\n    for i in 1:cols\n        if grid[1][i] == 0\n\
    \            for j in 1:rows\n                if grid[j][i] == 0\n           \
    \         number_of_empty_buckets[i] = capacity - minimum_bucket_capacity[i]\n\
    \                    break\n                    if j == rows\n               \
    \         number_of_empty_buckets[i] = grid[1][i]\n                        break\n\
    \                    number_of_empty_buckets[i] = number_of_empty_buckets[i] +\
    \ grid[j][i]\n                end\n            end\n        end\n    end\n   \
    \ \n    # loop through all possible number of empty buckets, \n    # check each\
    \ bucket to see if its capacities match bucket capacities\n    for i in 1:length(number_of_",
  "    \n    N = length(grid)\n    \n    l = zeros(Int, N)\n    \n    fill_count =\
    \ 0", "    # Your code here\n    # write your code here\n    return 0\nend", " \
    \   # write your code here\n    if grid.length == 0 || grid[0].length == 0\n \
    \       return 0\n    else\n        bucket = zeros(capacity)\n        bucket_cap\
    \ = 0\n        for r in range(1,length(grid)-1)\n            for c in range(1,length(grid[r])-1)\n\
    \                bucket_cap += grid[r][c]\n                bucket[grid[r][c]]\
    \ += r*c\n                bucket[bucket_cap] += r*c + capacity\n        end\n\
    \        bucket = bucket./maximum(bucket)\n        \n        return maximum(findlast(bucket\
    \ .< minimum(bucket))) + min_fill(grid,capacity)\n    end\nend\n</cell>\n<text>\n\
    Example 1:", "    \n    n = length(grid)\n    \n    # initialise bucket capacities\n\
    \    bucket_capacity = [capacity]\n    \n    bucket_count = [n for _ in bucket_capacity]",
  "        \n    # init\n    count = 0\n    l = length(grid)\n    if l == 0\n    \
    \    return 0\n    \n    # init\n    res = 0\n    \n    # process\n    for k in\
    \ 1:l-1\n        if grid[k,1] == 0\n            grid[k,1] = capacity\n       \
    \     count = count + 1\n            if count == 1\n                res = res\
    \ + 1\n                count = 0\n            end\n        elseif grid[k,1] ==\
    \ capacity\n            grid[k,1] = 0\n            count = 0\n        end\n  \
    \  end\n    \n    return res\nend", "    \n    buckets = [0 for _ in grid]\n \
    \   \n    bucket_capacity = capacity\n    \n    needed = []\n    \n    needed::Vector{Vector{Int64}}\
    \ = []\n    \n    for row in grid\n        if sum(row) == 0 \n            needed.push(row)\n\
    \            continue\n        end\n        # if the bucket is not full, then\
    \ we must lower the bucket\n        lower = buckets[row] -= 1\n        if lower\
    \ == -1\n            buckets[row] = bucket_capacity\n            bucket_capacity\
    \ -= 1\n        end\n        bucket_capacity += 1\n    end\n    \n    return needed.length\
    \ - 1\nend\n</cell>\n<code language=julia-0.6>", "    lengths = Vector{Int64}(grid[:,1])\n\
    \    count = Int64(0)\n    for length = lengths\n        fill!(grid[:length,:],\
    \ capacity)\n        count = count + 1 if length(grid[:length,:]) < capacity\n\
    \    end\n    count\nend\n</cell>\n<code language=julia-0.6>", "    if length(grid)\
    \ != length(grid[1])\n        throw(ArgumentError(\"grids should have the same\
    \ length\"))\n    end", "    \n    # your code here\n    return 0\nend", "   \
    \ # write your code in Java here\n    return 0\nend", "    \n    filled_wells\
    \ = sum(grid[:,i] .== 1 for i in 1:size(grid,2))\n    if filled_wells == capacity\
    \ \n        return filled_wells\n    \n    max_wells = filled_wells\n    \n  \
    \  for i in 1:size(grid,2)\n        if grid[:,i] == 1\n            if grid[max_wells,i]\
    \ == 0\n                max_wells = max_wells + 1\n            else\n        \
    \        max_wells = max_wells\n            end\n        end\n    end", "    len1,\
    \ len2 = length(grid), length(grid[1])\n    if len1 == 0 || len2 == 0\n      \
    \  return 0\n    end", "    wells = length(grid)\n    filled_wells = 0\n    fill_amount\
    \ = capacity\n    \n    # Initialize helper variable\n    filled_wells_counter\
    \ = zeros(wells)\n    \n    # loop through each well \n    for well in 1:wells\n\
    \        \n        # loop through each column in each well\n        for column\
    \ in 1:wells[well]\n            \n            # find how many units of water can\
    \ be extracted from this column\n            # since each well is filled until\
    \ the last column, we can subtract 1 from that number\n            extracted_units_count\
    \ = fill_amount - grid[well,column]-1\n            \n            # if the number\
    \ of units of water that can be extracted is 0, then the column cannot be \n \
    \           # used by any other well, so we can break out of the inner loop and\
    \ move on\n            if extracted_units_count == 0\n                break\n\
    \            \n            # find the maximum number of units of water that can\
    \ be extracted from this column\n            extracted_units_max = (extracted_units_count\
    \ + extracted_units_count-1)/2\n            \n            # loop through each\
    \ well in the grid\n            for well2 in 1:wells\n                # if the\
    \ column has been used by another well, then the well2 cannot extract any water\
    \ \n                if grid[well2,column] == 1\n                    grid[well2,column]\
    \ = 0\n                    fill_amount -= 1\n                    break\n     \
    \           \n                # if the well2 is the same as the well, this means\
    \ that it is the same well and we can \n                # extract water from it\n\
    \                if well2 == well\n                    grid[well2,column] = 0\n\
    \                    fill_amount -= extracted_units_count\n                  \
    \  filled_wells_counter[well2] += 1\n                    break\n             \
    \   \n                # if the well2 is different, then it means that it is the\
    \ same well and we can extract \n                # water from it, but only if\
    \ the water cannot be extracted from any other wells \n                elseif\
    \ grid[well2,column] == 0\n                    fill_amount -= extracted_units_count\n\
    \                end\n            end\n        end\n    end\n    \n    return\
    \ filled_wells_counter\nend\n</cell>\n<code language=julia-1.5>\n# run this cell\
    \ to turn your submissions into programs", "    bucket_num = size(grid)[2]\n \
    \   count = 0\n    buckets = Vector{Vector{Int64}}(undef, bucket_num)\n    \n\
    \    # fill bucket \n    for i = 1:bucket_num\n        buckets[i] = fill(grid[:,:,i])\n\
    \    end\n    \n    for i = 1:bucket_num\n        \n        # find max value of\
    \ bucket \n        max_value = maximum.(buckets[i])\n        \n        # find\
    \ index of max value \n        index = findfirst(x->x==max_value, buckets[i])\n\
    \        \n        if index==0\n            return count\n        end\n      \
    \  \n        # remove max value and fill again\n        buckets[i] = fill(grid[:,:,i][index+1:end])\n\
    \        count += capacity - max_value\n    end\nend\n</cell>\n<text>\n6. \u6FC0\
    \u6D3B\u51FD\u6570", "    if grid==[] || grid==[[]]\n        return 0;\n    if\
    \ capacity==0\n        return grid[1].length\n    \n    maxsize=0;\n    for row\
    \ in grid\n        if sum(row)>maxsize\n            maxsize=sum(row)\n       \
    \ end\n    end\n    \n    count=0;\n    for row in grid\n        if sum(row)>capacity\n\
    \            count=count+capacity-sum(row)\n            grid[findfirstindex(row,0)+1]=[]\n\
    \        end\n    end\n    return count;\nend", "    if length(grid) == 0 || capacity\
    \ == 0\n        return 0\n    \n    wells = unique(grid)\n    wells_capacities\
    \ = map(x -> length(x), wells)\n    \n    # find first place to store water in\
    \ a well\n    buckets = setdiff(1:capacity, wells_capacities)\n    \n    # count\
    \ times you need to reduce buckets\n    count = 2\n    \n    # keep reducing until\
    \ nothing is left or all wells empty\n    while count < length(wells) and length(buckets)\
    \ > 0 && capacity > 0\n        \n        # find bucket with least amount of water\
    \ remaining \n        bucket_to_remove = min(buckets)\n        \n        # remove\
    \ from bucket\n        remove(buckets, bucket_to_remove)\n        \n        #\
    \ reduce capacity\n        capacity -= 1\n        \n        # add empty well\n\
    \        wells = union(wells, setdiff(1:capacity, wells_capacities))\n       \
    \ \n        # find bucket with least amount of water remaining\n        bucket_to_add\
    \ = min(buckets)\n        \n        # add water to bucket\n        buckets.add(bucket_to_add)\n\
    \    end", "    \n    # Your code here\n    \n    wells_count = 0\n    \n    for\
    \ i in 1 :length(grid)\n        for j in 1 :length(grid[i])\n            \n  \
    \          if grid[i][j] == 0\n                wells_count -= 1\n            \n\
    \            elseif grid[i][j] == 1\n                wells_count += 1\n      \
    \      end\n        end\n    end\n    \n    return wells_count\nend", '    buckets
    = Dict(Vector{Vector{Int64}}() => (capacity,0))', "    fill_count = 0\n    max_length\
    \ = 0\n    max_length_row = 0\n    max_length_col = 0\n    grid = copy(grid)\n\
    \    for row in grid\n        fill(row, fill_count, max_length, max_length_row,\
    \ max_length_col)\n        fill_count = 0\n    end\n    return max_length\nend",
  "    bucket_size = capacity/grid[0].max\n    if bucket_size < 2\n        return\
    \ 0;\n    end", "        \n        # get the length of the entire matrix\n   \
    \     length = length(grid)\n        if length == 0\n            return 0 # empty\
    \ grid\n        end\n        \n        # number of times we need to empty the\
    \ buckets\n        count = 0", "    wells = find_buckets(grid, capacity)\n   \
    \ return min_fill(wells, capacity)\nend", "    # Write your code in Python 3.6\n\
    \    #your code here\n    return sum(sum(map(max, grid[i:i+2,1:end-1])) == 0 for\
    \ i in 2:length(grid)-2)\nend\n</cell>\n<code language=julia-1.3>\n# run your\
    \ function\nmax_fill(grid, capacity)\n</cell>\n<text>\nWe have now implemented\
    \ our algorithm using the functions in your module. We will test our algorithm\
    \ using our test cases and see if it is working as expected. Let's see an example\
    \ test case:", "    \"\"\"\n    You are given a rectangular grid of wells. Each\
    \ row represents a single well,\n    and each 1 in a row represents a single unit\
    \ of water.\n    Each well has a corresponding bucket that can be used to extract\
    \ water from it, \n    and all buckets have the same capacity.\n    Your task\
    \ is to use the buckets to empty the wells.\n    Output the number of times you\
    \ need to lower the buckets.", "    # write your code here\n    max_num = 0\n\
    \    for i in 1:length(grid)\n        cur_well = grid[i]\n        max_bucket =\
    \ 0\n        for j in 1:length(cur_well)\n            if cur_well[j] % 2 == 1\n\
    \                bucket_index = cur_well[j]/2\n            else\n            \
    \    bucket_index = cur_well[j] % 2\n            end\n            bucket_index\
    \ = clamp(bucket_index, 0, capacity)\n            if bucket_index > max_bucket\n\
    \                max_bucket = bucket_index\n            end\n        end\n   \
    \     if max_bucket > max_num\n            max_num = max_bucket\n        end\n\
    \    end\n    return max_num\nend\n</cell>\n<text>\n3.7 \u54EA\u4E9B\u662F\u6570\
    \u5B57\n\u5047\u8BBE\u4E00\u4E2A\u6570\u5B57 $\\theta$ \u5728\u67D0\u4E9B\u6570\
    \u5B57\u96C6\u5408 $Z$\u7684\u6700\u5927\u5316\uFF0C\u6211\u4EEC\u7684\u4EFB\u52A1\
    \u662F\u627E\u5230 $\\theta$ \u6240\u5728\u6570\u5B57\u96C6\u5408 $Z$ \u4E2D\u7684\
    \u6700\u5927\u5316\u56E0\u5B50\u3002", "    n=length(grid)\n    if n==0 || capacity==0\
    \ return 0", "    N, M = size(grid)\n    \n    filling = zeros(M, 1)\n    filling[grid[:,\
    \ 1]] .= 1\n    \n    if filling[grid[:, 2]] <= capacity\n        max_fill = N-1\n\
    \    else\n        max_fill = M-1\n    end\n    \n    for i = 1:M\n        \n\
    \        for j = 1:3\n            \n            if filling[i] == 0\n         \
    \       filling[j] .= 1\n                \n                if max_fill == 0 ||\
    \ (filling[j] == 1)\n                    max_fill = N-1\n                else\n\
    \                    max_fill = M-1\n                end\n            else\n \
    \               filling[j] = 0\n            end\n        end\n    end\n    \n\
    \    return max_fill\nend", "    # write your code here\n    ans = 0\n    \n \
    \   for row in grid\n        water_needed = capacity\n        \n        for i\
    \ = 1:length(row)-1\n            if row[i] != 0\n                water_needed\
    \ -= 1\n            end\n        end\n        \n        if water_needed <= 0\n\
    \            ans += 1\n        end\n    end", "    \n    max_flow = Vector{Int64}(undef,\
    \ grid.length)\n    @assert grid.length == grid[:,1].length\n    for i in 1:grid.length\n\
    \        for j in 1:grid[i,1]\n            if grid[i,j]==1\n                flow\
    \ = 0\n                total_flow = 0\n                neighbors = [(i-1,j), (i,j+1),\
    \ (i+1,j)]\n                for n in neighbors\n                    flow += grid[n]\n\
    \                    total_flow += grid[n]\n                    if flow>capacity\
    \ && total_flow>capacity\n                        max_flow[i] = max_flow[i-1]\
    \ + 1 \n                        break\n                    end\n             \
    \   end\n            end\n        end\n    end\n    max_flow\nend", "    \n  \
    \  if length(grid) <= 0 || capacity < 1\n        return 0\n    end\n    \n   \
    \ size = length(grid[1])\n    \n    if size > capacity\n        return 0\n   \
    \ end\n    \n    fill_count = fill(grid, capacity)\n    \n    if fill_count ==\
    \ 0\n        return size\n    else\n        return (size - fill_count)\n    end\n\
    \    \nend", "    return sum( \n        sum(\n            if grid[i][j] == 0 &&\
    \ \n                grid[(i-1)%grid.length][j] == 0 && \n                grid[(i+1)%grid.length][j]\
    \ == 0 && \n                grid[i][(j-1)%grid.length] == 0 && \n            \
    \    grid[i][(j+1)%grid.length] == 0 \n            then capacity \n          \
    \  else 0 \n        ) \n        for j in 1:size(grid)[1] \n    ) \nend\n</cell>\n\
    <text>\nProblem 8\nThe previous problem involves filling a 2D grid with the capacity\
    \ of the entire grid.\nThe capacity is represented as a 2-digit number.\nYou are\
    \ given the grid with the minimum water level in each column.\nYou are also given\
    \ an n x 2 grid with the minimum water level in each row.\nYou need to return\
    \ the minimum number of times you need to empty the entire grid.\nIf the number\
    \ of rows equals the number of columns, return 1.", "    # write your code in\
    \ Java of Python of R\n    if capacity == 0 \n        return 0 \n    count = 0\n\
    \    rows = grid.length\n    cols = grid[1].length\n    buckets = Vector{Int64}(undef,\
    \ capacity)\n    \n    for row in 1:rows\n        for col in 1:cols\n        \
    \    if grid[row][col] == 1\n                count = count + 1\n             \
    \   buckets[grid[row][col]] = count\n            end\n        end\n    end", " \
    \   # write your code in here\n    # return 0\n    count = 0\n    length = length(grid)\n\
    \    if length == 0\n        return count\n    \n    for row in grid\n       \
    \ for i in 1:length(row)\n            if row[i] == 1\n                count =\
    \ (count + 1)/2\n                break\n        end\n    end\n    return count\n\
    end", "    if length(grid)==0 || capacity==0 || length(grid[0])==0\n        return\
    \ 0\n    \n    maxrow = maximum(grid)\n    minrow = minimum(grid)\n    \n    \n\
    \    if maxrow-minrow > capacity\n        return 0\n    end\n    \n    \n    count\
    \ = 0\n    \n    \n    for i in 1:length(grid)-1\n        for j in i+1:length(grid)\n\
    \            if grid[i][j] == 1\n                count += 1\n                grid[j]\
    \ = 0\n            end\n        end\n    end\n    \n    return count\nend", " \
    \   \n    @assert length(grid) == length(grid[1])\n    @assert capacity >= 1 &&\
    \ capacity <= 10\n    \n    count = 0\n    for j in 1:length(grid[1])\n      \
    \  \n        bucket = Vector{Int64}(capacity)\n        \n        # fill bucket\n\
    \        for i in 1:length(grid)\n            if grid[i][j] == 1\n           \
    \     bucket[grid[i][j]]++\n            end\n        end\n        \n        \n\
    \        # empty bucket\n        for i in 1:length(bucket)\n            if bucket[i]\
    \ < capacity\n                count += 1\n                bucket[i] -= capacity\n\
    \            end\n        end\n    end\n    \n    return count\nend\n</cell>\n\
    <text>\nExercise 3\nWrite a function that checks if a given string represents\
    \ a valid integer.", "    \n    count = 0\n    \n    if grid.length == 0\n   \
    \     return 0\n    end\n    \n    if grid.length == 1\n        return grid[0,1]\n\
    \    end\n    \n    \n    \n    \n    # find max length for each row\n    # find\
    \ max length for each column\n    # reconstruct grid \n    \n    \n    \n    #\
    \ add one to each cell\n    # find cells whose max value is not equal to capacity\
    \ - add one\n    \n    # find the cell at which the max value changes \n    #\
    \ find the cells that need to add one\n    # find cells that need to subtract\
    \ one\n    \nend\n</cell>\n<text>\n3. Dynamic programming\nThe \"dynamic programming\"\
    \ problem consists of finding the maximum number of times an operation can be\
    \ applied to a given input sequence.\nFor example, given an array arr of length\
    \ N and an integer k. \nThe operation can be applied to any element of arr at\
    \ any given point.\nWe want to find the maximum number of times we can apply the\
    \ operation to a given input sequence at each point (of arr) in the array.", " \
    \   fillings = Vector{Vector{Int64}}()\n    for i in 1:length(grid)\n        push!(fillings,\
    \ Vector{Int64}())\n    end\n    \n    for i in 1:length(grid)\n        push!(fillings[i],\
    \ grid[i][1])\n    end", "    sum = 0\n    sum = 0\n    for row in grid\n    \
    \    sum += length(row)\n    end\n    return sum\nend", "    if grid[1] == []\
    \ || grid[1][1] == []\n        return 0\n    else\n        return 1 + max(max_fill(grid[2:end-1,\
    \ 1], capacity), max_fill(grid[2:end, 1], capacity))\n    end\nend", "    \n \
    \   l = length(grid[1])\n    m = length(grid)\n    \n    if m == 0\n        return\
    \ 0\n    \n    if l == 0\n        return 0\n    \n    if grid[1][1] > capacity\n\
    \        capacity = grid[1][1]\n    end\n    \n    if grid[1][1] == capacity\n\
    \        return grid[1][1]\n    end", "    \n    grid = deepcopy(grid)\n    count\
    \ = 0\n    visited = Set()\n    \n    for i = 1:length(grid)\n        for j =\
    \ 1:length(grid[i])\n            if grid[i][j] == 1 && !visited.contains(i + (j\
    \ * length(grid))))\n                visited.add(i + (j * length(grid)))\n   \
    \             for k = 1:length(grid)\n                    for l = 1:length(grid[k])\n\
    \                        if grid[k][l] == 0 && k != i && l != j\n            \
    \                if grid[k][l] < grid[i][j]\n                                grid[i][j]\
    \ = grid[k][l]\n                            end\n                        end\n\
    \                    end\n                end\n                count += 1\n  \
    \          end\n        end\n    end\n    return count\nend\n</cell>\n<code language=julia-1.5>",
  "  result = 0\n  for i in 2:size(grid)[1]\n    for j in 2:size(grid)[2]\n      if\
    \ grid[i][j] > 0\n        result += 1\n        grid[i][j] = grid[i-1][j] + grid[i][j-1]\n\
    \        grid[i][j] += grid[i][j-1]\n        if grid[i][j] > capacity\n      \
    \    grid[i][j] = grid[i-1][j-1]\n        end\n      end\n    end\n  end\n  return\
    \ result\nend\n</code>\n<|/ a dscore=1 tags=dynamic-programming,julia |>\n<| a\
    \ |>\nHere's another solution that uses only one loop:\n<code>", " \n   @assert\
    \ length(grid) == length(grid[1]) # check the number of wells\n   @assert all(grid[i]\
    \ == grid[1][i] for i in range(1,length(grid)))\n   @assert all(grid[i][end] ==\
    \ grid[1][i] for i in range(1,length(grid)))\n   @assert all(capacity >= grid[i][1]\
    \ for i in 1:length(grid))", "    # Write your code here\n    return length(findgroups(grid,capacity))\n\
    end", "    \"\"\"\n    This function returns how many times the buckets need to\
    \ be empty to \n    fill the wells.", "     \n    # write your code here\n   \
    \  \n    \n    \n    return 0", "    \n    if length(grid) <= 0 or any(grid[i]\
    \ .== 0 for i in 1:length(grid)) or any(grid[i] .== 1 for i in 1:length(grid))\n\
    \        return 0\n    end", "    # write your code here\n    # write your code\
    \ here\n    # write your code here\n    # write your code here\n    # write your\
    \ code here\n    # write your code here\n    # write your code here\n    # write\
    \ your code here\n    # write your code here\n    # write your code here\n   \
    \ # write your code here\n    # write your code here\n    # write your code here\n\
    \    # write your code here\n    # write your code here\n    # write your code\
    \ here\n    # write your code here\n    # write your code here\n    # write your\
    \ code here\n    # write your code here\n    # write your code here\n    # write\
    \ your code here\n    # write your code here\n    # write your code here\n   \
    \ # write your code here\n    # write your code here\n    # write your code here\n\
    \    # write your code here\n    # write your code here\n    # write your code\
    \ here\n    # write your code here\n    # write your code here\n    # write your\
    \ code here\n    # write your code here\n    # write your code here\n    # write\
    \ your code here\n    # write your code here\n    # write your code here\n   \
    \ # write your code here\n    # write your code here\n    # write your code here\n\
    \    # write your code here\n    # write your code here\n    # write your code\
    \ here\n    # write your code here\n    # write your code here\n    # write your\
    \ code here\n    # write your code here\n    # write your code here\n    # write\
    \ your code here\n    # write your code here\n    # write your code here\n   \
    \ # write your code here\n    # write your code here\n    # write your code here\n\
    \    # write your code here\n    # write your code here\n    # write your code\
    \ here\n    # write your code here\n    # write your code here\n    # write your\
    \ code here\n    # write your code here\n    # write your code here\n    # write\
    \ your code here\n    # write your code here\n    # write your code here\n   \
    \ # write your code here\n    # write your code here\n    # write your code here\n\
    \    # write your code here\n    # write your code here\n    # write your code\
    \ here\n    # write your code here\n    # write your code here\n    # write your\
    \ code here\n    # write your code here\n    # write your code here\n    # write\
    \ your code here\n    # write your code here\n    # write your code here\n   \
    \ # write your code here\n    # write your code here\n    # write your code here\n\
    \    # write your code here\n    # write your code here\n    # write your code\
    \ here\n    # write your code here\n    # write your code here\n    # write your\
    \ code here\n    # write your code here\n    # write your code here\n    # write\
    \ your code here\n    # write your code here\n    # write your code here\n   \
    \ # write your code here\n    # write your code here\n    # write your code here\n\
    \    # write your code here\n    # write your code here\n    # write your code\
    \ here\n    # write your code here\n    # write your code here\n    # write ",
  "    count = 0\n    \n    filling_order = []\n    for col in 1:size(grid)[1]\n \
    \       filling_order .= fill(grid[:,col], capacity)\n    end\n    \n    for idx\
    \ in filling_order\n        count += sum(grid[idx])\n    end\n    \n    return\
    \ count\nend", "    bucket_counts = zeros(Int, grid.length)\n    for i in 1:grid.length\n\
    \        bucket_counts[i] = grid[i].length\n    end", "    # write your code here\n\
    \    buckets = Vector{Vector{Int64}}(capacity)\n    for row in grid\n        well\
    \ = row\n        buckets[well.length] += 1\n    end\n    \n    minimum = minimum(buckets)\n\
    \    for i = minimum..capacity-1\n        buckets[i]  -= minimum\n    end\n  \
    \  return minimum\nend\n</cell>\n<code language=julia-0.6>\nmax_fill([[0,1,0],[1,0,0],[1,1,0]],\
    \ 3)\n</cell>\n<text>\n3.4 Solution\nThe following solution uses the max-minmum\
    \ function defined in the previous problem.", "    m, n = size(grid)\n    bucket_counts\
    \ = [Int64 for i in 1:capacity]\n    for i in 1:m\n        for j in 1:n\n    \
    \        if grid[i][j] == 1\n                bucket_counts[grid[i][j]] += 1\n\
    \                bucket_counts[grid[i][j] - 1] -= 1\n            end\n       \
    \ end\n    end\n    sum([bucket_counts[k] > 0 for k in 1:capacity]) == 1\n   \
    \ return sum(bucket_counts) <= 0\nend", "    if length(grid) == 0\n        return\
    \ 0\n    \n    grid2 = deepcopy(grid)\n    max_well = grid2\n    min_well = grid2\n\
    \    \n    for i in eachindex(grid2)\n        if grid2[i][1] == 0\n          \
    \  grid2[i][1] = capacity\n        elseif grid2[i][1] == capacity\n          \
    \  grid2[i][1] = 0\n        end\n    end\n    \n    for i in eachindex(grid2)\n\
    \        min_well[i] = min(min_well[i], grid2[i][1])\n        max_well[i] = max(max_well[i],\
    \ grid2[i][1])\n    end\n    \n    fill_water = 1\n    \n    for i in eachindex(grid2)\n\
    \        if grid2[i][1] == 0\n            fill_water += max_well[i] - min_well[i]\n\
    \        end\n    end\n    \n    return fill_water\nend", "    count = 0; \n \
    \   \n    try\n        push!(grid, [Vector{Int64}(1); capacity])\n    catch e\n\
    \        println(\"ERROR: No enough memory to fill\")\n        return 0\n    end\n\
    \    \n    \n    for i in 1:length(grid)\n        for j in 1:length(grid[i])\n\
    \            \n            if grid[i][j] == 1\n                count += 1\n  \
    \          end\n        end\n    end\n    \n    \n    return count\nend", "  \
    \  len = length(grid)\n    count = 0\n    for col in 1:length(grid[1])\n     \
    \   if grid[end][col] == 1 \n            count += 1\n        else\n          \
    \  break\n    end\n    if count > capacity\n        return 0\n    end\n    \n\
    \    count = 0\n    if len > 0\n        for col in 1:length(grid[1])\n       \
    \     if grid[end][col] == 1\n                count += 1\n            else\n \
    \               break\n            end\n        end\n    end\n    \n    for col\
    \ in 1:length(grid[1])\n        if grid[end][col] == 1\n            grid[end][col]\
    \ = 0\n            count += 1\n        else\n            break\n        end\n\
    \    end", "    num_wells = length(grid)\n    wells_filled = zeros(Int64, num_wells)\n\
    \    \n    for row in grid\n        wells_filled[row[1]] += 1\n    end\n    \n\
    \    bucket_size = capacity/wells_filled\n    \n    bucket_id = zeros(Int64, wells_filled)\n\
    \    bucket_size[bucket_id == 0] = capacity\n    \n    bucket_used = 0\n    \n\
    \    for row in grid\n        if bucket_id == capacity\n            break\n  \
    \      \n        if row[1] == 1\n            if bucket_used+bucket_size >= capacity\n\
    \                bucket_used += bucket_size\n                bucket_id[bucket_id\
    \ == capacity] = bucket_used\n            end\n            bucket_used += bucket_size\n\
    \            bucket_id[bucket_used+bucket_size+1:bucket_used+bucket_size+1+bucket_size]\
    \ += bucket_id\n            bucket_id += bucket_size\n        else\n         \
    \   bucket_used -= bucket_id[row[1]]\n        end\n    end\n    \n    return bucket_id\n\
    end", "    max_capacity = 0\n    for i in 1:length(grid)\n        water_required\
    \ = capacity/grid[i][1]\n        if water_required > max_capacity\n          \
    \  max_capacity = water_required\n        end\n        for j in 1:length(grid[i])\n\
    \            if grid[i][j] == 0\n                water_required -= grid[i][j]\n\
    \                if water_required > capacity\n                    water_required\
    \ = capacity\n                end\n                grid[i][j] = water_required\n\
    \            elseif grid[i][j] == 1\n                grid[i][j] = capacity\n \
    \           end\n        end\n    end\n    return max_capacity\nend\n</cell>\n\
    <code language=julia-1.0>\nmax_fill([[0, 1, 0, 0], [0, 0, 1, 0], [1, 1, 1, 1]],\
    \ 1)\n</cell>\n<text>\n6. Dynamic Programming\nYou now have all the ingredients\
    \ for solving this problem by yourself.\nLet's now write some code for you to\
    \ solve it using the DP approach you have learned.", "    buckets = zeros(Int,\
    \ capacity)\n    for row in grid\n        if row[1] > 0\n            buckets[row[0]]\
    \ = row[1]\n        end\n    end\n    \n    left = 0\n    right = 0\n    \n  \
    \  while right < capacity\n        if buckets[left] > 0\n            buckets[left]\
    \ -= grid[left][1]\n        end\n        right += 1\n        if buckets[right]\
    \ > 0\n            buckets[right] -= grid[right][1]\n        end\n        left\
    \ += 1\n    end\n    return sum(buckets)\nend\n</cell>\n<code language=julia-1.0>\n\
    @test max_fill([[1, 0, 0], [0, 1, 0], [1, 1, 0]], 5) == 0\n@test max_fill([[1,\
    \ 0, 0], [0, 0, 0], [1, 1, 1]], 2) == 4\n@test max_fill([[0, 0, 0], [0, 0, 0]],\
    \ 5) == 0\n</cell>\n<text>\nSolution", "    rows, cols = size(grid)\n    min_row,\
    \ min_col = minimum(grid)\n    max_row, max_col = maximum(grid)\n    count = 0\n\
    \    \n    for i in 1:rows\n        for j in 1:cols\n            if grid[i][j]\
    \ == 1\n                if i != min_row && j != min_col && i != max_row && j !=\
    \ max_col\n                    count = count + 1\n                end\n      \
    \      end\n        end\n    end", "    # Write your code here.\n    grid = copy(grid)\n\
    \    grid0 = grid[:,:,1]\n    grid2 = grid[:,:,2]\n    grid3 = grid[:,:,3]\n \
    \   grid4 = grid[:,:,4]\n    grid5 = grid[:,:,5]\n    grid6 = grid[:,:,6]\n  \
    \  grid7 = grid[:,:,7]\n    grid8 = grid[:,:,8]\n    grid9 = grid[:,:,9]\n   \
    \ grid10 = grid[:,:,10]\n    grid11 = grid[:,:,11]\n    grid12 = grid[:,:,12]\n\
    \    grid13 = grid[:,:,13]\n    grid14 = grid[:,:,14]\n    grid15 = grid[:,:,15]\n\
    \    grid16 = grid[:,:,16]\n    grid17 = grid[:,:,17]\n    grid18 = grid[:,:,18]\n\
    \    grid19 = grid[:,:,19]\n    grid20 = grid[:,:,20]\n    grid21 = grid[:,:,21]\n\
    \    grid22 = grid[:,:,22]\n    grid23 = grid[:,:,23]\n    grid24 = grid[:,:,24]\n\
    \    grid25 = grid[:,:,25]\n    grid26 = grid[:,:,26]\n    grid27 = grid[:,:,27]\n\
    \    grid28 = grid[:,:,28]\n    grid29 = grid[:,:,29]\n    grid30 = grid[:,:,30]\n\
    \    grid31 = grid[:,:,31]\n    grid32 = grid[:,:,32]\n    grid33 = grid[:,:,33]\n\
    \    grid34 = grid[:,:,34]\n    grid35 = grid[:,:,35]\n    grid36 = grid[:,:,36]\n\
    \    grid37 = grid[:,:,37]\n    grid38 = grid[:,:,38]\n    grid39 = grid[:,:,39]\n\
    \    grid40 = grid[:,:,40]\n    grid41 = grid[:,:,41]\n    grid42 = grid[:,:,42]\n\
    \    grid43 = grid[:,:,43]\n    grid44 = grid[:,:,44]\n    grid45 = grid[:,:,45]\n\
    \    grid46 = grid[:,:,46]\n    grid47 = grid[:,:,47]\n    grid48 = grid[:,:,48]\n\
    \    grid49 = grid[:,:,49]\n    grid50 = grid[:,:,50]\n    grid51 = grid[:,:,51]\n\
    \    grid52 = grid[:,:,52]\n    grid53 = grid[:,:,53]\n    grid54 = grid[:,:,54]\n\
    \    grid55 = grid[:,:,55]\n    grid56 = grid[:,:,56]\n    grid57 = grid[:,:,57]\n\
    \    grid58 = grid[:,:,58]\n    ", "    filling_row = (capacity+1)/2\n    filling_col\
    \ = (capacity+1)/2\n    count = 0\n    fill_row_max = filling_row\n    fill_col_max\
    \ = filling_col\n    \n    for i in 1:length(grid)\n        for j in 1:length(grid[i])\n\
    \            if grid[i][j] == 1\n                if fill_row_max <= capacity\n\
    \                    fill_row_max -= 1\n                else\n               \
    \     if fill_col_max <= capacity\n                        fill_col_max -= 1\n\
    \                    else\n                        count += 1\n              \
    \      end\n                end\n            end\n        end\n    end\n    return\
    \ count\nend\n</cell>\n<code language=julia-1.0>\n@test max_fill([[0, 0, 1, 0],\
    \ [0, 1, 0, 0], [1, 1, 1, 1]], 1) == 6\n</cell>\n<text>\n10. Minimum Cost Path\n\
    You are given an m x n grid filled with non-negative integers.\nThe cost of a\
    \ move is to move to cell $(i, j)$ and place an x at cell $(i, j)$.\nYou want\
    \ to go from cell $(i, j)$ to cell $(j, k)$ with cost $C(i,j)$,\nwhere $k$ is\
    \ one of the cells you can reach if you start at cell $(i, j)$.\nFind the minimum\
    \ cost to reach the kth cell.\nThe cost of a cell is defined as the number of\
    \ cells that are directly connected on that cell.", "    rows = length(grid)\n\
    \    \n    if rows == 0\n        return 0", "    num_wells = prod(grid)\n    well_to_fill\
    \ = zeros(num_wells, 1)\n    wells = zeros(num_wells, 1)\n    wells[1] = 1", " \
    \   n, m, c = size(grid)\n    if n==0 || m==0\n        return 0\n    \n    # fill\
    \ each bucket with capacity\n    for row in range(1,n)\n        for col in range(1,m)\n\
    \            grid[row][col] = capacity\n    end", "    N, M = size(grid) # number\
    \ of rows and columns\n    if N==0 || M==0 \n        return 0\n    gridmax = -Inf\
    \ # max in each column\n    buckets = Vector{Vector{Int64}}(undef, capacity) #\
    \ the buckets\n    for i in 1:M\n        buckets[i] = Vector{Int64}(undef, capacity)\
    \ # the buckets\n        for j in 1:N\n            if grid[j][i] == 0 \n     \
    \           buckets[i][j] = gridmax\n            else\n                buckets[i][j]\
    \ = buckets[i][j-1] + grid[j][i]\n            end\n            gridmax = max(gridmax,\
    \ buckets[i][j])\n        end\n    end\n    return gridmax\nend\n</cell>\n<text>\n\
    Problem 4\nThe Fibonacci sequence is defined by the recurrence relation:\n$$ Fn\
    \ = \\begin{cases} 1 & n = 0 \\ 1 & n = 1 \\ F{n-1} + F_{n-2} & n > 1 \\end{cases}\
    \ $$\nwhere $F_1 = 1$ and $F_2 = 1$. The first few terms of the sequence are $F_1$,\
    \ then $F2 = F{1} + F_{1}$, and so on. By starting with $F_1$ and $F_2$ and advancing\
    \ by $F_{1}$ you get $F3 = F_{2} + F_{1}$ and $F4 = F_{3} + F_{2}$, and so on.\
    \ So each term in the sequence is strictly increasing by a factor of $1$. This\
    \ leads to the following linear recurrence (for $n$ = 1, 2, 3, 4, 5):", "    \n\
    \    count=0\n    for i=1:length(grid)\n        for j=1:length(grid[i])\n    \
    \        if grid[i][j]==1\n                if capacity >= grid[i][j+1] \n    \
    \                count += capacity - grid[i][j+1] \n                else\n   \
    \                 count += 1\n                end\n            end\n        end\n\
    \    end\n    \n    return count\nend", "    \"\"\"\n    You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n    and each 1 in a row represents\
    \ a single unit of water.\n    Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n    and all buckets have the same capacity.\n\
    \    Your task is to use the buckets to empty the wells.\n    Output the number\
    \ of times you need to lower the buckets.", "    m, n = size(grid)\n    i = Int(ceil(Int,\
    \ m/capacity))\n    j = Int(ceil(Int, n/capacity))\n    res::Int64 = 0\n    fill\
    \ = zeros(Int64, capacity)\n    for k in 1:capacity\n        fill[k] = true\n\
    \    end", "    \n    lenght = length(grid)\n    \n    if capacity == 0\n    \
    \    return 0\n    \n    \n    for w in 1:lenght\n        \n        for j in 1:length(grid[w])\n\
    \            if (grid[w][j] == 1)\n                capacity -= 1\n           \
    \ end\n        end\n        \n        if capacity < 1\n            return 0\n\
    \        end\n        \n    end\n    \n    return 1\nend\n</cell>\n<code language=julia-0.5>\n\
    \"\"\"\n    You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    and each 1 in a row represents a single unit of water.\n    Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    \    and all buckets have the same capacity.\n    Your task is to use the buckets\
    \ to empty the wells.\n    Output the number of times you need to lower the buckets.",
  "    # Write your code here.\n    fill = 0\n    for row in grid\n        if row[1]\
    \ == 1\n            fill = fill + 1\n            row = row[2:end]\n        else\n\
    \            row = row[1:end]\n        end\n    end", "    # Your code here\n\
    \    return length(grid[1,:]) + length(grid[:,1])\nend\n</cell>\n<text>\n7. Max\
    \ Water Filling on Diagonal Water Wells", "    lenx = length(grid)\n    \n   \
    \ if lenx == 0 \n        return 0\n    end", "    # write your code here\n   \
    \ \nend\n</cell>\n<code language=julia-1.5>\n# Test your function with:\n@test\
    \ answer2(A) == expected_result\n</cell>\n<text>\nPart B: Inverse Knapsack\nThe\
    \ inverse knapsack problem is the same as most other dynamic programming problems.\n\
    The only difference is that you need a set of items instead of just one value.\n\
    Let's try solving this by making our knapsack problem.\nWe have the following\
    \ parameters:", "    return length(grid) - sum(map(x -> sum(x == 1 ? 1 : 0)-capacity,\
    \ grid))\nend", "    \n    if grid.length == 0 || grid[1].length == 0\n      \
    \  return 0\n    \n    if capacity < 1\n        return 0\n    \n    row, col =\
    \ findfirst(x -> x > 0, grid), findfirst(x -> x > 0, grid[1, :])\n    \n    if\
    \ col == 0 || row == 0 || col == col - 1\n        return 0\n    \n    row = row\
    \ - 1\n    \n    bucket_capacity = capacity / grid[row, col]\n    \n    while\
    \ true\n        \n        row, col = findfirst(x -> x > 0, grid), findfirst(x\
    \ -> x > 0, grid[row, :])\n        \n        bucket_capacity = bucket_capacity\
    \ - grid[row, col]\n        \n        if bucket_capacity == 0 || row == row\n\
    \            break\n        \n        grid[row][col] = 0\n    end\n    \n    return\
    \ bucket_capacity\nend\n</cell>\n<code language=julia-1.6>\n# your code here\n\
    </cell>\n<text>\n4. Restore water from empty wells", "    N = length(grid)\n \
    \   buckets = Vector{Int64}(undef, capacity)\n    \n    fills = 0\n    for i in\
    \ 1:N\n        buckets[grid[i][2]] += 1\n    end\n    for bucket in buckets\n\
    \        fills += bucket <= capacity ? 1 : 1\n    end\n    fills\nend\n</cell>\n\
    <text>\nProblem 6", "    \n    l = length(grid)\n    \n    for i = 1:l\n     \
    \   grid[i]=fill(capacity, grid[i])\n    end", "    # write your code in Julia\
    \ 0.6.7\nend", "    #Your code here\n    #fill_count = 0\n    stack = Vector{Vector{Int64}}([])\n\
    \    #stack = [Vector{Int64}(undef,capacity)]\n    #push!(stack,Vector{Int64}([],capacity))\n\
    \    push!(stack,Vector{Int64}([],capacity))\n    bucket_index = 0\n    bucket_length\
    \ = capacity\n    grid_length = grid[1].length\n    grid_capacity = grid[1].length\n\
    \    bucket_capacity = 0\n    fill_count = 0\n    done = false\n    while !done\
    \ \n        push!(stack,Vector{Int64}([],bucket_capacity))\n        for row =\
    \ 1:grid_length\n            if grid[row][1] == 0 && bucket_capacity >= bucket_length\
    \ \n                bucket_capacity = bucket_capacity - bucket_length\n      \
    \          bucket_index = 0\n                bucket_length = capacity\n      \
    \      end\n            if grid[row][1] == 0 && grid[row][2] > 0\n           \
    \     push!(stack[bucket_index],Vector{Int64}(undef,grid[row][2]))\n         \
    \       bucket_capacity = bucket_capacity - grid[row][2]\n                bucket_index\
    \ = (bucket_index + 1)%bucket_length\n            end\n        end\n        if\
    \ bucket_capacity <= bucket_length\n            push!(stack[bucket_index],Vector{Int64}(undef,bucket_capacity))\n\
    \            bucket_capacity = bucket_capacity + bucket_length\n            bucket_index\
    \ = (bucket_index + 1)%bucket_length\n        end\n        bucket_index = 0\n\
    \        bucket_length = capacity\n        for row = 1:grid_length\n         \
    \   if grid[row][1] == 0\n                push!(stack[bucket_index],Vector{Int64}(undef,grid[row][2]))\n\
    \                bucket_capacity = bucket_capacity + grid[row][2]\n          \
    \      bucket_index = (bucket_index + 1)%bucket_length\n            end\n    \
    \    end\n        fill_count += 1\n        done = false\n        for bucket_index\
    \ = (bucket_index+1)%bucket_length \n            if bucket_index < bucket_length\
    \ \n                if grid[bucket_index][2] > 0\n                    done = true\n\
    \                    break\n                end\n            end\n           \
    \ if grid[bucket_index][1] == 0 \n                done = true\n              \
    \  break\n            end\n        end\n    end\n    return fill_count\nend",
  "    m, n = size(grid)\n    filled_wells = zeros(Int, m, n)\n    filled_wells[grid,\
    \ capacity] = 1\n    \n    empty_wells = zeros(Int, m, n)\n    empty_wells[:,\
    \ capacity] = 1\n    \n    empty_wells[grid, :] = grid[:, capacity]\n    filled_wells[:,\
    \ capacity] = 1\n    \n    empty_wells[:, :capacity] = grid[capacity, :]\n   \
    \ filled_wells[:capacity, :] = grid[:capacity, capacity]\n    \n    empty_wells[:,\
    \ :capacity] = grid[capacity, :]\n    filled_wells[:capacity, :] = grid[:capacity,\
    \ capacity]\n    \n    empty_wells[:capacity, :capacity] = grid[capacity, capacity]\n\
    \    filled_wells[capacity:, capacity] = grid[capacity, capacity]\n    \n    return\
    \ sum(filled_wells[filled_wells == 1])\nend\n</cell>\n<text>\nThe first few tests\
    \ check that our function correctly fills all wells.", "    N = size(grid)[1]\n\
    \    \n    # Fill the buckets\n    if N == 0 \n        return 0 \n    \n    fillings\
    \ = zeros(Int64, N)\n    fillings[1] = capacity\n    \n    for i in 2:N\n    \
    \    fillings[i] = fillings[i-1] - grid[i-1][1]\n    \n    # Find the largest\
    \ filling for each well\n    maxes = max_filling(fillings)\n    \n    # Determine\
    \ what buckets need to be filled\n    needed_buckets = fillings - maxes\n    \n\
    \    fills = 0\n    \n    for i in 1:N\n        needed_buckets[i] = 0\n    \n\
    \    for i in 1:N\n        if needed_buckets[i] == 0\n            fills += grid[i][1]\n\
    \            needed_buckets[i] = capacity \n        end\n    end\n    \n    return\
    \ fills\nend\n</cell>\n<text>\nSolution\nIf you're looking for efficiency then\
    \ use @inbounds for your loops:", "    \"\"\"\n    You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n    and each 1 in a row represents\
    \ a single unit of water.\n    Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n    and all buckets have the same capacity.\n\
    \    Your task is to use the buckets to empty the wells.\n    Output the number\
    \ of times you need to lower the buckets.", "    count_1 = Int64(0)\n    count_2\
    \ = Int64(0)\n    for row in eachindex(grid)\n        if grid[row][0] == 1 \n\
    \            count_1 = count_1 + 1\n        elseif grid[row][1] == 1 \n      \
    \      count_2 = count_2 + 1\n        end\n    end\n    if capacity == count_1\
    \ \n        return capacity\n    else \n        if capacity == count_2 \n    \
    \        return 0\n        else \n            return capacity - count_1\n    end\n\
    end", "    fillers = Vector{Int64}(repeat(0, capacity))\n    wells = Vector{Vector{Int64}}(repeat(0,\
    \ capacity))\n    for x in grid\n        fillers[x[1]] -= 1\n        wells[x[1]][x[2]]\
    \ += 1\n    end\n    \n    res=0\n    for well in wells\n        if !isempty(well)\n\
    \            res+=max_fill(well, capacity)\n        end\n    end\n    return res\n\
    end\n</code>\n<|/ a dscore=1 tags=dynamic-programming,algorithm,recursion,dynamic-arrays,julia\
    \ |>\n<| c |>\nthank you for this very elaborate answer, I have been trying to\
    \ understand it for a while now. \nI see that your code produces results that\
    \ are not what I was looking for, for example if I have the following input:\n\
    ```julia> max_fill([[0,0], [1,1],[0,1]], 2)\n4", "    if grid[1] == 0 || capacity\
    \ < grid[1]\n        return 0\n    end", "    if isnothing(grid) || sum(grid.==0)==0\
    \ || sum(grid.==1)==0 || \n        (length(grid)==1 && all(grid.==0)) \n     \
    \   return 0 \n    well = grid.==1\n    bucket = Vector{Int64}(undef, capacity)\n\
    \    bucket = Vector{Int64}(0) \n    \n    fill = 0\n    while !isempty(bucket)\n\
    \        lower = findmin(bucket)[1]\n        bucket[lower] = -bucket[lower]\n\
    \        fill = fill + 1\n        \n        if lower==size(grid)[1] \n       \
    \     fill = fill + 1\n            bucket = Vector{Int64}(undef, capacity)\n \
    \       end\n        \n        bucket = Vector{Int64}(0) \n        well = well\
    \ & grid[:,lower]\n        \n        if sum(well)==0 \n            break \n  \
    \      end\n        \n        for w =1:size(well)\n            bucket[well[w]]\
    \ = -bucket[well[w]]\n        end\n    end\n    \n    return fill \nend\n</cell>\n\
    <code language=julia-1.5>", "    n=length(grid)\n    fills=zeros(n)\n    fills[1]=0\n\
    \    fills[2]=0\n    fills[3]=0\n    for i=1:n\n        for j=1:i\n          \
    \  if grid[i][j]==1\n                fills[i]+=1\n            elseif fills[j]>fills[i]+1\n\
    \                fills[j]=fills[i]+1\n            end\n        end\n    end\n\
    \    return maximum(fills)\nend\n</code>\n<|/ a tags=algorithm,dynamic-programming,memoization\
    \ |>\n<| c |>\nThank you very much! I really appreciate it!\n<|/ c |>\n<| c |>\n\
    I am really sorry but i don't understand the algorithm completely. what is the\
    \ purpose of fills ? Why did you use fills[1]=0 and fills[2]=0 ? and how does\
    \ it increase the efficiency of it ?\n<|/ c |>\n<| c |>\nIt doesn't matter what\
    \ i used here it didn't work and i didn't really know what to replace it with.\
    \ the fills is an array that keeps track of the number of times a bucket is filled.\
    \ the for loop fills it with 0\n<|/ c |>\n<| c |>\nI got your explanation but\
    \ I don't really get why is it necessary to replace all zeroes with 1. What does\
    \ it change ? I mean why is it necessary to increase the bucket to more than 1\
    \ ? What would be the result if we would have replaced all zeroes with something\
    \ else ?\n<|/ c |>\n<| c |>\nwhat do you mean by replace? You mean replace it\
    \ with 0?\n<|/ c |>\n<| a tags=algorithm,dynamic-programming,memoization |>\n\
    <code>\npublic class MaxFill {", "    \"\"\"\n    Your Solution Here\n    \"\"\
    \"\n    return \nend\n</cell>\n<text>\nTEST CASES\nAll test cases should pass\
    \ before you submit. Submitting your test cases before submitting is how you advance\
    \ the submission deadline.", "    if grid.length == 0\n        return 0\n    if\
    \ grid.length == 1\n        return grid[1].length\n    if capacity < grid[1].length\n\
    \        return 0\n    maxfill = 0\n    \n    fill = zeros(Int64, capacity)\n\
    \    for i in 1:length(grid)\n        for j in 1:grid[i].length\n            fill[grid[i][j]]\
    \ += 1\n            if fill[grid[i][j]] > maxfill\n                maxfill = fill[grid[i][j]]\n\
    \        end\n    end\n    return maxfill\nend", "    \n    grid = [[grid[i][j]\
    \ for j in range(length(grid[i]))] for i in range(length(grid))]\n    \n    function\
    \ find_min_row()\n        minimum = 99999\n        for col = 0:capacity\n    \
    \        for row in grid\n                if row[1] > col\n                  \
    \  minimum = min(minimum, min(row[1]-col, col))\n                    return minimum\n\
    \                end\n            end\n        end\n    end\n    \n    function\
    \ find_min_col()\n        minimum = 99999\n        for row = 0:capacity\n    \
    \        for col in grid\n                if col[1] > row\n                  \
    \  minimum = min(minimum, min(col[1]-row, row))\n                    return minimum\n\
    \                end\n            end\n        end\n    end\n    \n    function\
    \ find_min_diagonal()\n        minimum = 99999\n        for row = 0:capacity\n\
    \            for col = 0:capacity\n                if grid[row][col] > 0\n   \
    \                 minimum = min(minimum, min(abs(col[1]-row[1]), abs(row[1]-col[1])))\n\
    \                    return minimum\n                end\n            end\n  \
    \      end\n    end\n    \n    function find_max_diagonal()\n        maximum =\
    \ -99999\n        for row = 0:capacity\n            for col = 0:capacity\n   \
    \             if grid[row][col] > 0\n                    maximum = max(maximum,\
    \ min(abs(col[1]-row[1]), abs(row[1]-col[1])))\n                end\n        \
    \    end\n        end\n    end\n    \n    find_min_row()\n    find_min_col()\n\
    \    find_min_diagonal()\n    find_max_diagonal()\nend\n</cell>\n<text>\nThis\
    \ code is similar to the previous one, but here we solve the problem with recursion.\
    \ By defining four helper functions, we reduce the problem to four sub-problems,\
    \ and then we call the appropriate function for the sub-problem that contains\
    \ the given capacity.", "    \n    rows = length(grid)\n    cols = grid[1].length\n\
    \    \n    \n    total = 0\n    \n    \n    for j in 1:cols\n        for i in\
    \ 1:rows\n            if grid[i][j] == 1\n                \n                \n\
    \                \n                \n                \n                \n    \
    \            \n                \n                \n                \n        \
    \        \n                \n                \n                \n            \
    \    \n                \n                \n                \n                \n\
    \                \n                \n                \n                \n    \
    \            \n                \n                \n                \n        \
    \        \n                \n                \n                \n            \
    \    \n                \n                \n                \n                \n\
    \                \n                \n                \n                \n    \
    \            \n                \n                \n                \n        \
    \        \n                \n                \n                \n            \
    \    \n                \n                \n                \n                \n\
    \                \n                \n                \n                \n    \
    \            \n                \n                \n                \n        \
    \        \n                \n                \n                \n            \
    \    \n                \n                \n                \n                \n\
    \                \n                \n                \n                \n    \
    \            \n                \n                \n                \n        \
    \        \n                \n                \n                \n            \
    \    \n                \n                \n                \n                \n\
    \                \n                \n                \n                \n    \
    \            \n                \n                \n                \n        \
    \        \n                \n                \n                \n            \
    \    \n                \n                \n                \n                \n\
    \                \n                \n                \n                \n    \
    \            \n                \n                \n                \n        \
    \        \n                \n                \n                \n            \
    \    \n                \n                \n                \n                \n\
    \                \n                \n                \n                \n    \
    \            \n                \n                \n                \n        \
    \        \n                \n                \n                \n            \
    \    \n                \n                \n                \n                \n\
    \                \n                \n                \n                \n    \
    \            \n                \n                \n                \n        \
    \        \n                \n                \n                \n            \
    \    \n                \n                \n                \n                \n\
    \                \n                \n                \n                \n    \
    \            \n                \n                \n                \n        \
    \        \n                \n                \n                \n            \
    \    \n                \n                \n                \n                \n\
    \                \n                \n                \n                \n    \
    \            \n                \n                \n                \n        \
    \        \n                \n                \n                \n            \
    \    \n                \n                \n                \n                \n\
    \                \n                \n                \n                \n    \
    \            \n                \n                \n                \n        \
    \        \n                \n                \n                \n            \
    \    \n                \n                \n                \n                \n\
    \                \n                \n                \n                \n    \
    \            \n                \n                \n                \n        \
    \        \n                \n                \n                \n            \
    \    \n                \n                \n                \n                \n\
    \                \n                \n                \n                \n    \
    \            \n                \n                \n                \n        \
    \        \n                \n                \n                \n            \
    \    ", "    m, n = length(grid), length(grid[1])\n    emptyGrid = zeros(Int64,\
    \ m, n)\n    \n    # Fill empty grid\n    for i in 1:m \n        for j in 1:n\n\
    \            if grid[i][j] == 0\n                emptyGrid[i,j] = capacity\n \
    \           end\n        end\n    end\n    \n    # count number of water need\
    \ to be dropped\n    count_water = 0\n    \n    for i in 1:m\n        for j in\
    \ 1:n\n            if grid[i][j] == 1\n                count_water += (capacity\
    \ - emptyGrid[i,j])\n            end\n        end\n    end\n    return count_water\n\
    end", "    bucket = Vector{Int64}(capacity, 0)\n    count = 0\n    \n    for row\
    \ in grid\n        for cell in row\n            if cell == 1\n               \
    \ count += 1\n            else\n                bucket[cell] += count\n      \
    \          count = 0\n        end\n    end\n    \n    for cell in bucket\n   \
    \     if cell == capacity\n            return cell\n        end\n    end\n   \
    \ \n    return 0\nend\n</cell>\n<text>\nExercise 6\nWrite a function that performs\
    \ simulated annealing to solve this problem.\nIt should return the best solution\
    \ as well as its score.\nThe function should take a temperature and a maximum\
    \ number of iterations parameter.\nIn case of no better solution, it should return\
    \ the best solution found so far.\nThe function should use the annealing schedule\
    \ to improve the solution in some steps (usually by 25%).\nFor each iteration,\
    \ the function should pick a random element from the possible moves (a well).\n\
    It should use the randomly selected element to expand the bucket, then decrease\
    \ the bucket.\nIf it can't do this, it backtracks and picks a different element.\n\
    It should use this process to find a solution that maximizes the score and minimizes\
    \ the number of backtracks.\nThe function should return the best solution and\
    \ the score calculated during each iteration.", "    if length(grid) == 0 \n \
    \       0\n    else\n        m = length(grid)\n        s = sum(grid)\n       \
    \ \n        \n        if (s == capacity)\n            sum((1:m).^2)\n        else\n\
    \            min(((1:m).^2), (capacity-s).^2)\n        end\n    end\nend\n</cell>\n\
    <text>\nSolution\nClick below for a solution.", "    count=0\n    fill_size=capacity\n\
    \    for row in grid\n        count += length(row)-fill_size\n        fill_size\
    \ -=1\n    end\n    return count\nend", "    @assert length(grid) == length(grid[1])\n\
    \    m = capacity\n    count = 0\n    for k in eachindex(grid)\n        if grid[k]\
    \ == 1\n            for j in eachindex(grid[1])\n                if m+grid[1][j]\
    \ == capacity\n                    m -= grid[1][j]\n                    grid[1][j]\
    \ = grid[k]\n                    count += 1\n                    if count == m\n\
    \                        return count\n                    grid[k] = grid[1][j]\n\
    \                end\n            end\n        end\n    end\n    return 0\nend\n\
    </cell>\n<code language=julia-1.1>\n\"\"\"\n    You are given an array A of integers,\
    \ and an integer K. \n    We define an \"optimum path\" to be a sequence of elements\
    \ of A \n    that can be reached from some vertex at distance K from the \n  \
    \  starting vertex. Your task is to find the length of the longest \n    optimal\
    \ path starting from any element of A.\n    \n    Example: \n    Input: A = [1,\
    \ 3, 2], K = 2\n    Output: 4\n    Explanation: The longest optimum path would\
    \ be [1, 1, 2, 2] \n    starting from vertex 1 which is 2 steps away. \n    \n\
    \    Constraints: \n        * 1 <= A.length <= 2 * 10^5\n        * 1 <= A[i] <=\
    \ 10^6\n        * 1 <= K <= A.length\n    \"\"\"", "    rows, cols = (length(grid),\
    \ length(grid[1]))\n    \n    if rows == 0 || cols == 0 \n        return 0\n \
    \   end\n    \n    stack = Vector{Int64}(0:capacity)\n    \n    for j = 1:cols\
    \ \n        stack[j] = grid[1,j]\n        \n        for i = 2:rows \n        \
    \    stack[j] = max(stack[j], grid[i,j])\n        end\n    end\n    \n    for\
    \ i = 2:rows\n        stack = fill(stack, i-1)\n    end\n    \n    return length(stack)\n\
    end\n</cell>\n<code language=julia-1.3>\n#Sort a vector in ascending order\n#Example:\
    \ sortedvec = [1,3,5,6,2,4]", "    \n    # Write your code here\n    # Your code\
    \ here\n    ans = 0\n    for w in grid\n        ans += max_fill(w, capacity)\n\
    \    end\n    return ans\nend\n</cell>\n<text>\nSolution", "    \n    \n    #\
    \ init max_flow\n    max_flow = 0\n    \n    # init visited_wells\n    visited_wells\
    \ = Set{Int64}()\n    \n    # init buckets\n    buckets = [[] for _ in 1:length(grid)]",
  "    length = (grid.[1] - grid.[0])[1]\n    stack::Vector{Vector{Int64}} = []\n\
    \    counter::Int64 = 0\n    for row in grid\n        if row[1] == 0\n       \
    \     push!(stack, Vector{Int64}[Vector{Int64}(row...)])\n        else\n     \
    \       push!(stack, Vector{Int64}[Vector{Int64}(row...)])\n            while\
    \ length(stack) > 0\n                push!(stack, pop(stack)[row[1]]...)\n   \
    \         end\n        end\n    end\n    stack = sort(stack)\n    if length <\
    \ 1\n        return 0\n    end\n    if length(stack) < length\n        return\
    \ length(stack)\n    end\n    for m in 1:length(stack)\n        pop = stack[m]\n\
    \        for n in 1:length(pop)\n            if pop[n] == 1\n                push!(stack,\
    \ pop...)\n            end\n        end\n        if length(stack) < length\n \
    \           return length(stack)\n        end\n    end\n    return 0\nend\n</cell>\n\
    <text>\nSolution\nAs mentioned before, you can implement the max_fill function\
    \ using Stack data structure to solve this problem. The Python code for this solution\
    \ is given below:", "    count = 0\n    \n    # Loop through all grid cells and\
    \ check if any cell is empty. \n    # If so, check all surrounding cells to find\
    \ empty ones. \n    # Empty cells are those with 0 as values. \n    \n    # Keep\
    \ a record of empty cells that we encounter to prevent unnecessarily checking\
    \ \n    # empty cells many times.\n    \n    # Count how many cells need to be\
    \ lowered.\n    \n    for row in grid\n        for cell in row\n            if\
    \ cell == 0\n                count += 1\n            elseif cell != 0\n      \
    \          for i in -1..1\n                    for j in -1..1\n              \
    \          if cell == 0\n                            cells_empty = count_cells_empty(capacity,\
    \ grid, i, j)\n                            if cells_empty == 0\n             \
    \                   cells_empty = 0\n                            end\n       \
    \                 end\n                    end\n                end\n        \
    \    end\n        end\n    end\n    \n    return count\nend\n</cell>\n<text>\n\
    Problem 3", "    leng = length(grid)\n    stack = Vector{Int64}(leng, 0)\n   \
    \ cnt = 1\n    for i = 1:leng\n        if grid[i][2] != 0\n            stack[i]\
    \ = 1\n        else\n            cnt += 1\n            while stack[i - (i - 1)/2]\
    \ == 1 && cnt < capacity\n                cnt += 1\n                stack[i -\
    \ (i - 1)/2] = 0\n            end\n        end\n    end\n    return cnt\nend",
  "    # write your code here\n    l = length(grid)\n    \n    for i in 1:l\n    \
    \    if grid[i][2] == 0\n            grid[i][2] = capacity\n        else\n   \
    \         grid[i][2] += capacity\n        end\n    end\n    \n    # return the\
    \ result of your computation\n    \nend\n</cell>\n<code language=julia-1.6>",
  "    # Your code here\n    n = length(grid)\n    count = 1\n    for i in 1:n-1\n\
    \        for j in i+1:n\n            if grid[i][j] == 1\n                count\
    \ += min_fill(capacity, grid[i,1:j])\n            end\n        end\n    end\n\
    \    return count\nend\n</cell>\n<code language=julia-1.4>\n#test\ngrid = [\n\
    \ [1, 0, 0, 0],\n [1, 0, 1, 0],\n [1, 1, 0, 0],\n [1, 0, 1, 0]\n]\nmax_fill(grid,\
    \ 4)\n</cell>\n<text>\nExercise 8\nThe above problem is hard to solve using dynamic\
    \ programming. How can you improve it?", "    buckets = Matrix{Int64}(size(grid))\n\
    \    for row in grid\n        buckets[row,1] = 1\n    end", "    \"\"\"\n    Your\
    \ function should return an Int64\n    that represents the number of times you\
    \ must\n    empty the buckets to restore water from all wells.\n    \"\"\"\nend\n\
    </cell>\n<text>\nTest Your Solution\nRun the cell below to test your function\
    \ against a small test case.", "    \n    if length(grid) == 0 or capacity ==\
    \ 0 \n        return 0\n    else \n        \n        left,right,up,down = 0, 0,\
    \ 0, 0\n        n = length(grid)\n        for i in range(n)\n            for j\
    \ = 1:length(grid[i])\n                if grid[i][j] == 1 \n                 \
    \   left = i+1; right = (i+1)+grid[i][j-1]; up = i+1; down = (i+1)+grid[i+1][j]\n\
    \                elseif grid[i][j] == 0 \n                    if j == 1 or i ==\
    \ n-1 or j == n-1 \n                        return 0\n                    else\n\
    \                        left = i+1; right = (i+1)+grid[i][j-1]; up = i+1; down\
    \ = (i+1)+grid[i+1][j]\n                    end\n                end\n       \
    \     end\n        end\n        return max(max_fill(grid[left:down],capacity-grid[left+1:down].+1),\
    \ \n                   max_fill(grid[up:right],capacity-grid[up-1:right].+1),\
    \ \n                   max_fill(grid[up:down],capacity-grid[up+1:down].+1), \n\
    \                   max_fill(grid[left:down],capacity-grid[left+1:down].+1))\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>", "    filling_counter = 0\n\
    \    \n    for i = 1:length(grid)\n        if grid[i][1] > 0\n            grid[i][1]\
    \ -= 1\n            filling_counter += max_fill(grid[i+1:i], capacity)\n     \
    \   end\n    end\n    \n    return filling_counter\nend", "    # write your code\
    \ in Python 3.7\n    # Fill the grid using dynamic programming\n    if length(grid)\
    \ < 2 || capacity < 1 || length(grid[1]) < 1\n        return 0\n    else\n   \
    \     fill = zeros(length(grid[1]), capacity)\n        fill[1:length(grid[1]),1:length(grid[0])]\
    \ = grid\n        fill = fill.^capacity\n        fill = fill.cumprod(fill)\n \
    \       fill = fill[1:length(grid[1])]\n        return sum(fill[1:end-1].==0)\n\
    \    end\nend", "    \n    N = length(grid)\n    rows = collect(1:N)\n    cols\
    \ = collect(1:size(grid,2))\n    \n    # init all buckets to capacity to start\n\
    \    fill_bucket(bucket=Array{Int64}(capacity), grid=grid)\n    \n    # find max\
    \ number that fill each bucket\n    max_num_fill = max_fill_grid(grid=grid)\n\
    \    \n    # fill bucket until each bucket has some unit\n    count_fill = 0\n\
    \    for i = 1:size(grid,2)\n        while !isempty(bucket[i])\n            fill_bucket(bucket=bucket,\
    \ grid=grid)\n            count_fill += 1\n        end\n    end\n    \n    return\
    \ count_fill\nend\n</cell>\n<text>\nSolution", "    if length(grid) == 0\n   \
    \     return 0 \n    end\n    \n    bucket_capacity = capacity/length(grid)\n\
    \    \n    bucket_capacities = [bucket_capacity]*length(grid)\n    \n    bucket_filled\
    \ = ones(length(grid), Int64)\n    \n    bucket_filled_indexes = Array{Int64}(undef,\
    \ length(bucket_capacities))\n    \n    for i in eachindex(grid)\n        if grid[i][end]\
    \ == 1\n            bucket_filled_indexes[i] = 1\n        else\n            bucket_filled_indexes[i]\
    \ = bucket_filled[i] \n        end\n    end\n    \n    bucket_filled_idx = 0\n\
    \    bucket_filled_count = 0\n    \n    bucket_filled_index = bucket_filled_indexes[bucket_filled_idx]\n\
    \    \n    while bucket_filled_index != bucket_filled_indexes\n        bucket_filled_count\
    \ += 1\n        if bucket_filled_index == bucket_filled_indexes[bucket_filled_idx+1]\n\
    \            bucket_filled_idx += 1\n            bucket_filled_index = bucket_filled_indexes[bucket_filled_idx]\n\
    \        else\n            bucket_filled_idx += 1\n            bucket_filled_index\
    \ = bucket_filled_indexes[bucket_filled_idx]\n        end\n    end\n    \n   \
    \ return bucket_filled_count \nend\n</cell>\n<code language=julia-1.5>\n@test\
    \ max_fill([[1, 0, 0, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 1) == 1\n\
    @test max_fill([[0, 1, 0, 0], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2) ==\
    \ 5\n@test max_fill([[1, 0], [0, 0]], 5) == 0\n</cell>\n<text>\nPQ Algorithm\n\
    The PQ algorithm is a dynamic programming algorithm that solves the traveling\
    \ salesman problem (TSP) by storing the shortest travel distances between each\
    \ pair of points. This shortest distances are used to determine how many roads\
    \ are needed to walk between each pair of points. The algorithm is as follows:",
  "    cnt = 0\n    buckets = Array(Vector{Int64}, capacity)\n    \n    for row in\
    \ grid\n        cnt += 1\n        \n        for b in buckets\n            b[find(row)]\
    \ == 1\n        end\n        \n        for b in buckets\n            b[find(row)]\
    \ -= 1\n        end\n    end\n    \n    cnt -= 1\n    \n    if cnt > 0\n     \
    \   cnt -= find_empty(capacity, buckets)\n    end\n    \n    return cnt\nend",
  "    @assert length(grid) == length(grid[1])\n    @assert all(grid[i] == 0 | grid[i]\
    \ == 1 for i in eachindex(grid))\n    @assert capacity > 0\n    @assert capacity\
    \ <= 10", "    rows = length(grid)\n    cols = grid[0].length\n    answer = 1",
  "    buckets = Vector{Vector{Int64}}(repeat(Vector{Int64}(capacity), length(grid)))\n\
    \    \n    for row in grid\n        for bucket in buckets\n            bucket[bucket]\
    \ -= 1\n        end\n    end\n    \n    fills = 0\n    for bucket in buckets\n\
    \        fills += sum(bucket)\n    end\n    \n    return fills\nend\n</cell>\n\
    <code language=julia-1.5>\nmax_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1],\
    \ [0, 1, 1, 1]], 2)\n</cell>\n<text>\nPaladin", "    \n    # write your code here\n\
    \    # code here\n    \nend\n</cell>\n<code language=julia-1.5>\nmax_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n</cell>\n<code language=julia-1.5>\n\
    max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)\n</cell>\n\
    <code language=julia-1.5>\nmax_fill([[0, 0, 0], [0, 0, 0]], 5)\n</cell>\n<code\
    \ language=julia-1.5>\nmax_fill([[0,0],[0,0]], 5)\n</cell>\n<code language=julia-1.5>\n\
    # recursive solution", "    \n    # base case\n    if grid.length == 0 \n    \
    \    return 0 \n    end\n    \n    # recursive case\n    \n    # initialize max\
    \ counter\n    cnt = 0\n    \n    # iterate over buckets\n    for bucket in grid\n\
    \        \n        # recursively find next bucket that can hold water\n      \
    \  rest_capacity = bucket.length + capacity\n        next_bucket = get_next_bucket(bucket,\
    \ rest_capacity)\n        \n        # check if there is a next bucket\n      \
    \  if next_bucket != 0\n            # increment max counter\n            cnt +=\
    \ max_fill(next_bucket, capacity)\n        else\n            # no more buckets\
    \ left\n            break\n        end\n    end\n    return cnt \nend", "    \n\
    \    # base case\n    if length(grid)==0\n        return 0\n    end", "    # write\
    \ your code here\n    max_count = 0\n    curr_capacity = capacity\n    curr_grid\
    \ = grid\n    for i in eachindex(curr_grid)\n        curr_grid[i][curr_grid[i][1]]\
    \ = 1\n    end", "    buckets, min_bucket = make_bucket_array(grid, capacity)\n\
    \    for i in 1:length(grid)\n        push!(buckets, min_bucket)\n    end\n  \
    \  \n    empty, rest, remaining, remaining_size = empty_buckets(buckets)\n   \
    \ while !isempty(empty)\n        empty, rest, remaining, remaining_size = empty_buckets(buckets)\n\
    \        for i in empty\n            if grid[i][1] == 0\n                if grid[i][2]\
    \ < min_bucket\n                    min_bucket = grid[i][2]\n                end\n\
    \            elseif grid[i][1] > 0\n                if grid[i][1] >= min_bucket\n\
    \                    min_bucket = grid[i][1]\n                end\n          \
    \  else\n                if grid[i][2] >= min_bucket\n                    min_bucket\
    \ = grid[i][2]\n                end\n            end\n        end\n        for\
    \ i in remaining\n            if grid[i][1] >= min_bucket\n                grid[i][1]\
    \ -= min_bucket\n                grid[i][2] -= min_bucket\n                empty[i]\
    \ = true\n                push!(remaining_size, grid[i][1])\n                push!(remaining_size,\
    \ grid[i][2])\n                push!(remaining_size, 1)\n            end\n   \
    \     end\n    end\n    return sum(remaining_size)\nend\n</cell>\n<text>\n3. Exercise\
    \ 5\nWrite a function to check whether a binary tree is a binary search tree (BST).\n\
    You can assume that each node in the tree has at least a key and a value field.",
  "    \n    return 0\nend", "\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\
    \t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\
    \n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\
    \t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\
    \n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\
    \t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\
    \n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\
    \t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\
    \n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\
    \t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\
    \n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\
    \t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\
    \n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\
    \t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n", "    if all(grid[i][1] == grid[j][2] for\
    \ j in 1:size(grid)[1]-2, i in 1:size(grid)[1]-2) \n        # grid is rectangular\
    \ and all wells have same height\n        max_fill_recursive(grid, capacity)\n\
    \    else\n        # grid is not rectangular and all wells have different height\n\
    \        max_fill_recursive(grid[end-1:end,], capacity)\n    end\nend", "    filled_wells\
    \ = zeros(capacity, length(grid))\n    \n    for eachRow in grid\n        for\
    \ eachCell in eachRow\n            if eachCell == 1\n                filled_wells[eachCell,\
    \ eachRow] = filled_wells[eachCell, eachRow] + 1\n            end\n        end\n\
    \    end\n    \n    return filled_wells[end][end] \nend\n</cell>\n<text>\nSolution\n\
    Let's see how our solution works. We have a grid of wells. We have one bucket\
    \ for each well. We use the bucket to empty the wells. Let's see how we do this.",
  "    count = zeros(Int64, size(grid,1))\n    for row in grid\n        count[row]\
    \ += 1\n    end\n    maxCount = max(count)\n    for row in grid\n        if count[row]\
    \ == maxCount\n            count[row] = 0\n        else\n            count[row]\
    \ += 1\n        end\n    end\n    return maxCount - capacity\nend", "    fills\
    \ = Any[]\n    stack = []\n    current_max_fill = 0\n    visited_wells_count =\
    \ 0\n    visited_buckets_count = 0", "    buckets = Vector{Vector{Int64}}(capacity)\n\
    \    n = 0\n    for i in 1:length(grid)\n        buckets[grid[i][1]] = grid[i]\n\
    \    end\n    for i in 1:capacity\n        if buckets[i] != nothing\n        \
    \    for j in 1:length(buckets[i])\n                n += length(buckets[i]) -\
    \ j\n            end\n        end\n    end\n    n\nend\n</cell>\n<text>\nmax_fill_test\n\
    A quick test of your implementation with a sample case.", "    # Your code here\n\
    \    return 0\nend", "        \n    # Write your code here\n    res = 0\n    for\
    \ row in grid\n        if row[1] == 0\n            res+=1\n        end\n    end\n\
    \    return res\nend", "    bucket_capacity = sum(grid[:,1])\n    if bucket_capacity\
    \ == 0\n        return 0\n    buckets = Vector{Vector{Int64}}(undef,bucket_capacity)\n\
    \    for row in grid\n        buckets[row[1]] = row[2]\n    end", "    # Your\
    \ code here\n    return 0", "    m, n = size(grid)\n    # remember the row and\
    \ column of bottom left of first empty bucket\n    i, j = 0, 0\n    # init a counter\
    \ of empty buckets\n    empty_bucket_cnt = m * n\n    # init a counter of filled\
    \ buckets\n    filled_bucket_cnt = capacity\n    # start filling empty buckets\n\
    \    while empty_bucket_cnt > filled_bucket_cnt\n        # select a empty bucket\n\
    \        empty_bucket = get_empty_bucket(grid, i, j)\n        # move to next cell\n\
    \        i, j = i + 1, j + 1\n        empty_bucket_cnt = empty_bucket_cnt - empty_bucket\n\
    \    end\n    \n    return filled_bucket_cnt\nend", "    if grid == []\n     \
    \   return 0\n    \n    max_length = maximum(grid[:,1])\n    buckets = [[] for\
    \ i in 1:length(grid)]\n    \n    for r in grid\n        buckets[r[1]] += r[2:end]\n\
    \    end", "    # write your code here\n    rows = length(grid)\n    cols = grid[1].length\n\
    \    fill_count = 0\n    for row in 2:rows\n        if grid[row,1] == 0 && grid[row,1]\
    \ != 0\n            grid[row,1] = capacity\n            fill_count += 1\n    \
    \    elseif grid[row,1] == 0 && grid[row,1] == 0\n            grid[row,1] = 0\n\
    \        elseif grid[row,1] == 1\n            grid[row,1] = 0\n            fill_count\
    \ += 1\n        end\n    end\n    return fill_count\nend\n</cell>\n<text>\nProblem\
    \ 3\nYou are given the grid below and a list of positions where each cell contains\
    \ a certain fruit.", "    # write your code here\n    return count(i -> grid[grid[i][1]][grid[i][0]]\
    \ != 0, 1:length(grid[1]))\nend", "        \n    # Write your code here", "  \
    \  # write your code here\n    return sum(islands(grid,capacity))\nend", "   \
    \ if sum(grid[]) == 0 || grid[][0] == 0 || grid[][1] == 0 || grid[][2] == 0 ||\
    \ grid[][3] == 0 || grid[][4] == 0\n        return -1\n    grid1 = grid[]\n  \
    \  grid2 = grid[]\n    grid3 = grid[]\n    grid4 = grid[]\n    grid5 = grid[]\n\
    \    grid6 = grid[]\n    grid7 = grid[]\n    grid8 = grid[]\n    grid9 = grid[]\n\
    \    grid10 = grid[]\n    grid11 = grid[]\n    grid12 = grid[]\n    grid13 = grid[]\n\
    \    grid14 = grid[]\n    grid15 = grid[]\n    grid16 = grid[]\n    grid17 = grid[]\n\
    \    grid18 = grid[]\n    grid19 = grid[]\n    grid20 = grid[]\n    grid21 = grid[]\n\
    \    grid22 = grid[]\n    grid23 = grid[]\n    grid24 = grid[]\n    grid25 = grid[]\n\
    \    grid26 = grid[]\n    grid27 = grid[]\n    grid28 = grid[]\n    grid29 = grid[]\n\
    \    grid30 = grid[]\n    grid31 = grid[]\n    grid32 = grid[]\n    grid33 = grid[]\n\
    \    grid34 = grid[]\n    grid35 = grid[]\n    grid36 = grid[]\n    grid37 = grid[]\n\
    \    grid38 = grid[]\n    grid39 = grid[]\n    grid40 = grid[]\n    grid41 = grid[]\n\
    \    grid42 = grid[]\n    grid43 = grid[]\n    grid44 = grid[]\n    grid45 = grid[]\n\
    \    grid46 = grid[]\n    grid47 = grid[]\n    grid48 = grid[]\n    grid49 = grid[]\n\
    \    grid50 = grid[]\n    grid51 = grid[]\n    grid52 = grid[]\n    grid53 = grid[]\n\
    \    grid54 = grid[]\n    grid55 = grid[]\n    grid56 = grid[]\n    grid57 = grid[]\n\
    \    grid58 = grid[]\n    grid59 = grid[]\n    grid60 = grid[]\n    grid61 = grid[]\n\
    \    grid62 = grid[]\n    grid63 = grid[]\n    grid64 = grid[]\n    grid65 = grid[]\n\
    \    grid66 = grid[]\n    grid67 = grid[]\n    grid68 = grid[]\n    grid69 = grid[]\n\
    \    grid70 = grid[]\n    ", "    m, n = size(grid)\n    # m1 = m + 2\n    # n1\
    \ = n + 2\n    # max_num = 0\n    # for i in 1:m1\n    #     for j in 1:n1\n \
    \   #         if grid[i][j] == 1\n    #             if grid[i][j - 1] == 1\n \
    \   #                 max_num = max(max_num, capacity - grid[i][j + 1])\n    #\
    \             end\n    #         end\n    #     end\n    # end\n    m1 = m + 2\n\
    \    n1 = n + 2\n    max_num = 0\n    for i in 2:m1\n        for j in 2:n1\n \
    \           if grid[i][j] == 1\n                if grid[i - 1][j] == 1\n     \
    \               max_num = max(max_num, capacity - grid[i][j + 1])\n          \
    \      end\n            end\n        end\n    end\n    return max_num\nend\n</cell>\n\
    <code language=julia-1.0>", "    rows, cols = size(grid)\n    result = Int64(0)\n\
    \    for row = 1:rows\n        for col = 1:cols\n            result += (grid[row][col]\
    \ - 1) * min(capacity, grid[row][col + 1] - 1)\n        end\n    end\n    result\n\
    end", "    if length(grid) == 0 || length(grid[1]) == 0\n        return 0\n  \
    \  \n    i = j = 1\n    bucket = [i for i in capacity]\n    count = 1\n    \n\
    \    while i < length(grid) && j < length(grid[1])\n        \n        if grid[i][j]\
    \ == 0\n            count += 1\n            bucket = [i for i in bucket]\n   \
    \     else\n            count -= 1\n            bucket = [i for i in bucket if\
    \ i > 0]\n        end\n        i += 1\n        j += 1\n    end\n    \n    return\
    \ count\nend\n</cell>\n<text>\nLet's test our function now:", "# Dynamic programming\n\
    \    \n    # Initialization\n    # Base cases\n    if sum(grid) == 0\n       \
    \ return 0\n    end\n    \n    # Initialization\n    grid = copy(grid)\n    visited\
    \ = zeros(Int, length(grid))\n    \n    # Dynamic programming algorithm\n    visited[1,1]\
    \ = true\n    \n    # Recursion\n    for i in 2:length(grid)\n        visited[i,0]\
    \ = false\n        \n        for j in 1:i-1\n            if visited[j, i-1] ==\
    \ false\n                visited[i,j] = grid[i][j] + visited[j, i-1]\n       \
    \     else\n                visited[i,j] = visited[j, i-1]\n            end\n\
    \        end\n    end\n    \n    return visited[length(grid),length(grid)]\nend",
  "    rows, cols = size(grid)\n    fills = 0\n    for row in 1:rows; row+=1\n   \
    \     for col in 1:cols; col+=1\n            if grid[row,col] == 1\n         \
    \       fills +=1\n                if capacity - fills >= 0\n                \
    \    grid[row,col] = 2\n                    capacity = capacity - fills\n    \
    \            else\n                    break\n            end\n        end\n \
    \   end\n    return fills\nend\n</cell>\n<code language=julia-1.5>\n@time max_fill([rand(0:1,10^2)\
    \ for i = 1:10^2], 1);\n</cell>\n<code language=julia-1.5>\n@time max_fill([rand(0:1,10^2)\
    \ for i = 1:10^2], 10);\n</cell>\n<code language=julia-1.5>\n@time max_fill([rand(0:1,10^2)\
    \ for i = 1:10^2], 10);\n</cell>\n<text>\n6.1 Exercise\nGiven a 2D grid of size\
    \ mxn, find the minimum number of jumps to go from (0, 0) to (m-1, n-1)?\nInput\
    \ Format:\nThe first line of input contains two space-separated integers m and\
    \ n, where m is the size of the grid and\nn is the size of the grid. Each of the\
    \ next m lines contains n space-separated integers representing the grid\nentries.",
  "    if grid[1] == Vector{Int64}()\n        return grid[2] == Vector{Int64}() ?\
    \ 1 : 0 \n    \n    count = 1\n    while count <= capacity\n        fill = max_fill(grid[1:end-1],\
    \ capacity)\n        for i = 2:length(grid)-1\n            grid[i] = grid[i-1:i+1]\n\
    \        end\n        grid[1] = Vector{Int64}()\n        if fill == 0\n      \
    \      count += 1\n        end\n    end\n    return count\nend", "    \n    if\
    \ length(grid)==0\n        return 0\n    \n    # find max well\n    maxWell =\
    \ maximum( grid[:,1] ) # find row where 1 exists\n    \n    # find next bucket\
    \ index\n    bucket = findBucket( maxWell, capacity )\n    \n    # fill next bucket\n\
    \    grid[bucket,1] = maxWell\n    \n    # find next bucket\n    bucket = findBucket(\
    \ maxWell, capacity )\n    \n    # fill next bucket\n    grid[bucket,1] = 0\n\
    \    \n    # call max_fill recursively\n    if max_fill(grid, capacity-1) != 0\n\
    \        return 1 + max_fill(grid, capacity-1)\n    else\n        return 0\nend",
  "    rows = length(grid)\n    cols = grid[1].length", "\tfill = Int64(0)\n\tfor\
    \ row in grid\n\t\tif row.length == 1\n\t\t\tfill+=1\n\t\telse\n\t\t\tfill+=(row[1]==1\
    \ ? capacity : 0)\n\t\tend\n\tend\n\treturn fill\nend", "    \n    # Create a\
    \ matrix to store the maximum flow of each bucket\n    filling_matrix = zeros(Int,\
    \ capacity)\n    filling_matrix[:] = fill(filling_matrix, capacity)", "    bucket_counts\
    \ = zeros(Int64, length(grid))\n    bucket_counts[:] = capacity\n    for row in\
    \ grid\n        bucket_counts[row] += 1\n    end", "    grid = deepcopy(grid)\n\
    \    lengths = map(length, grid)\n    if length(grid) == 0 || lengths.min == 0\
    \ || lengths.max == 0\n        return 0\n    else\n        min_length = lengths.min\n\
    \        max_length = lengths.max\n        \n        # find the bucket which has\
    \ the least number of units in each row\n        bucket_index = []\n        for\
    \ l in min_length:\n            bucket_index = [i for i,e in enumerate(bucket_index)\
    \ if\n                            l*length(grid[i]) == e]\n        end\n     \
    \   \n        # find how many times we must lower the bucket\n        empty_in_bucket\
    \ = zeros(Int, length(bucket_index))\n        \n        for (i,j) in combinations(1:length(grid),\
    \ 2)\n            if length(grid[i]) > 0 && length(grid[j]) > 0\n            \
    \    empty_in_bucket[i] += length(grid[i]) - length(grid[j])\n            end\n\
    \        end\n        \n        empty_in_bucket = sum(empty_in_bucket)\n     \
    \   if capacity - empty_in_bucket < 0\n            return 0\n        end", " \
    \   \n    #filler vector\n    fillers = Vector{Int64}(length(well) for well in\
    \ grid)\n    fillers[fillers.==0] = 0\n    \n    # initialize count of water\n\
    \    count = 0\n    \n    # search through the grid\n    for i in 1:length(grid)\n\
    \        for j in 1:length(grid[i])\n            if grid[i][j] == 1\n        \
    \        count = count + fillers[j]\n                \n                \n    \
    \        if count == capacity\n                count = 0\n            end\n  \
    \      end\n    end\n    \n    return count\nend\n</cell>\n<text>\nSolution\n\
    If your puzzle is solved successfully, the total filled capacity of the grid can\
    \ be found in its last element.", "    row, col =  length(grid), length(grid[1])\n\
    \    ans = 1\n    \n    for j in 0:row-1\n        for i in 1:col\n           \
    \ if grid[j][i] != 1\n                ans = ans + min(max_fill(grid[j+1:i, 1:col],\
    \ capacity-j-1))\n            end\n        end\n    end\n    \n    return ans\n\
    end\n</cell>\n<code language=julia-1.3>", "    if capacity == 0 || grid(1,1) ==\
    \ 1 \n        return 0 \n    end\n    \n    count = 0\n    \n    for k in 2:size(grid,2)\n\
    \        \n        if k >= size(grid,1) \n            break\n        end\n   \
    \     \n        count = count + \n            max_fill(grid[1:k-1,1:k-1], \n \
    \                   capacity - grid[1:k-1,k]*grid[1,k-1]\n                )\n\
    \    end\n    \n    return count\nend", "    \n    wells = length(grid)\n    empty_bucket\
    \ = zeros(capacity,wells)\n    \n    for well in eachindex(grid)\n        for\
    \ i in eachindex(grid[well])\n            if grid[well][i] == 1\n            \
    \    empty_bucket[grid[well][i]][well]\n            end\n        end\n    end\n\
    \    \n    return sum(empty_bucket == 0)\nend", "    \"\"\"\n    Find maximum\
    \ number of units to be lowered if bucket is empty.\n    \"\"\"\n    stack = Vector{Int64}()\n\
    \    visited = Array{Int64, 1}(size(grid)[1])\n    visited[end] = -1\n    stack[end]\
    \ = -1\n    \n    for i = 1:size(grid)[1]\n        if visited[i] != -1\n     \
    \       continue\n        visited[i] = 1\n        \n        for j = 1:size(grid)[2]\n\
    \            if visited[j] != -1 \n                continue\n            if grid[i][j]\
    \ == 0 \n                stack[end] = j\n                if end == 0\n       \
    \             stack[end] = 1\n                    visited[j] = 1\n           \
    \         break\n            end = (stack[end] + grid[i][j])%capacity\n      \
    \  end\n    end\n    return end \nend\n</cell>\n<code language=julia-1.4>\n# run\
    \ tests\n@testset \"test_max_fill\" begin\n    grid = [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]]\n    @test max_fill(grid, 1) == 6\n    grid = [[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]]\n    @test max_fill(grid, 2) == 5\n\
    \    grid = [[0, 0, 0], [0, 0, 0]]\n    @test max_fill(grid, 5) == 0\nend\n</cell>\n\
    <text>\nQuestion 7\nWrite a function to find the max sum of any contiguous sub-matrix\
    \ in a given matrix. \nFor a square matrix input, the output should be the same\
    \ as the max sum obtained with other methods.", "    \"\"\"\n    Find all the\
    \ possible ways to lower the buckets, \n    and return the maximum number of ways\
    \ you can lower the buckets\n    \"\"\"\n    \n    # Initialize counts to zero\n\
    \    count = 0\n    \n    # To store the possible ways to lower the buckets \n\
    \    # that can result from each row or column being selected\n    # Each possible\
    \ way to lower the buckets that can result from each row or column being selected\n\
    \    buckets = Set{Int64}()", "    # Fill the buckets\n    bucket_capacity = capacity\n\
    \    bucket_sizes = ones(Int, length(grid))\n    bucket_ids = zeros(Int, length(grid))\n\
    \    \n    for i=1:length(grid)\n        bucket_sizes[i] = grid[i][1]\n    end",
  "    if grid==[] || capacity < 1 || capacity > 10 return 0\n    \n    \n    buckets\
    \ = Vector{Int64}(capacity)\n    \n    \n    buckets[1] = 1\n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    ",
  "    # Write your code here\n    \n    # check input\n    if length(grid) !=2 \n\
    \        return -1\n    \n    # count \n    count = -1\n    for row in grid\n\
    \        if row[1] > 0 \n            count += 1\n    \n    return count\nend",
  "    if grid.length < 1 || length(grid[1]) < 1 || capacity < 1\n        return 0\n\
    \    end\n    \n    buckets = [zeros(capacity) for i=1:length(grid)]\n    \n \
    \   for i=1:length(grid)\n        for j=1:length(grid[i])\n            buckets[j][grid[i][j]]+=1\n\
    \        end\n    end\n    \n    changed = false\n    while !changed\n       \
    \ changed = true\n        for i in 1:length(grid)\n            for j=1:length(grid[i])\n\
    \                if buckets[i][j] > 0 && buckets[i][j] <= capacity\n         \
    \           buckets[i][j] -= 1;\n                    if buckets[i][j] <= 0\n \
    \                       buckets[i][j] = capacity;\n                    else\n\
    \                        changed = false\n                    end\n          \
    \      end\n            end\n        end\n    end\n    \n    return sum(buckets)\n\
    end\n</cell>\n<code language=julia-1.0>\nmax_fill([[0, 0, 1, 0], [0, 1, 0, 0],\
    \ [1, 1, 1, 1]], 1)\n</cell>\n<code language=julia-1.0>\nmax_fill([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)\n</cell>\n<code language=julia-1.0>\n\
    max_fill([[0, 0, 0], [0, 0, 0]], 5)\n</cell>\n<code language=julia-1.0>\nusing\
    \ CairoMakie\ngr()\n</cell>\n<code language=julia-1.0>\nusing Colors\ntheme =\
    \ Theme(\n    primary_color = colorant\"#646976\",\n    secondary_color = colorant\"\
    #ff8b00\",\n    tertiary_color = colorant\"#bdbdbd\",\n    accent_color = colorant\"\
    #eeeeee\",\n    background_color = \"#282a36\",\n    surface = :surface,\n   \
    \ guide_color = colorant\"#cccccc\"\n)\ntheme = Theme(\n    primary_color = colorant\"\
    #646976\",\n    secondary_color = colorant\"#ff8b00\",\n    tertiary_color = colorant\"\
    #bdbdbd\",\n    accent_color = colorant\"#eeeeee\",\n    background_color = \"\
    #282a36\",\n    surface = :surface,\n    guide_color = colorant\"#cccccc\"\n)\n\
    theme = Theme(\n    primary_color = colorant\"#646976\",\n    secondary_color\
    \ = colorant\"#ff8b00\",\n    tertiary_color = colorant\"#bdbdbd\",\n    accent_color\
    \ = colorant\"#eeeeee\",\n    background_color = \"#282a36\",\n    surface = :surface,\n\
    \    guide_color = colorant\"#cccccc\"\n)\ntheme = Theme(\n    primary_", "  \
    \  if size(grid)[1] == 0 || size(grid)[2] == 0\n        return 0  \n    else\n\
    \        buckets = Vector{Int64}(undef, capacity)\n        for (i,j) in eachindex(grid)\n\
    \            buckets[grid[i][j]]+=1\n        end\n        \n        return 1 +\
    \ maximum((-buckets[i]) for i = 1:capacity)\n    end\nend", "    \n    answer\
    \ = 1", "    # write your code here\nend\n</cell>\n<text>\nPart B\nA simple approach\
    \ is to take the first row, put a large amount of water in it, \nand see how many\
    \ of them are still in the bucket.\nIf the number of water remaining is less than\
    \ the capacity, then the bucket is full and we can move on to the next row.",
  "    empty = 0\n    \n    for row in grid\n        empty += row[1]\n    end", '    #
    Write your code here', "    if capacity == 0\n        return 0\n    \n    rows,\
    \ cols = size(grid)\n    \n    buckets = Vector{Int64}(undef, capacity)", "  \
    \  if length(grid) == 0 || length(grid[1]) == 0\n        return 0\n    elseif\
    \ capacity == 0\n        return 1\n    else\n        row_max = max_fill_row_max(grid,\
    \ capacity)\n        col_max = max_fill_col_max(grid, capacity)\n        return\
    \ (row_max + col_max) * (row_max + col_max) / 4\n    end\nend", "    # Write your\
    \ code here\n    return 0\nend", "    n = length(grid)\n    fills = Vector{Int64}(undef,\
    \ n)\n    for i in 1:n\n        for j in 1:n\n            fills[(i,j)] = 0\n \
    \       end\n    end", "    ans = 0\n    bucket_capacity = capacity\n    \n  \
    \  for row in grid\n        for bucket in row\n            if bucket == 1\n  \
    \              bucket_capacity -= 1\n            end\n        end\n    end\n \
    \   \n    if bucket_capacity > 0\n        bucket_capacity += capacity\n      \
    \  for row in grid\n            for bucket in row\n                if bucket ==\
    \ 0\n                    bucket_capacity -= 1\n                end\n         \
    \   end\n        end\n    end\n    \n    while bucket_capacity > 0\n        for\
    \ row in grid\n            for bucket in row\n                if bucket == 1\n\
    \                    bucket_capacity -= 1\n                end\n            end\n\
    \        end\n    end\n    \n    for row in grid\n        for bucket in row\n\
    \            if bucket == 1\n                ans += 1\n            end\n     \
    \   end\n    end\n    \n    return ans\nend", "    if length(grid) > 10^3 || length(grid[1])\
    \ > 10^3\n        return 0\n    \n    bucket_capacity = capacity\n    bucket_size\
    \ = grid[1]\n    \n    empty_count = 0\n    \n    for row in grid[2:length(grid)]\n\
    \        bucket_capacity -= bucket_size[1]\n        if bucket_capacity <= 0\n\
    \            empty_count += 1\n            bucket_capacity = capacity\n      \
    \      bucket_size = row\n        end\n    end\n    \n    return empty_count\n\
    end\n</cell>\n<code language=julia-1.6>\n@time max_fill([rand(1:10,5) for _ in\
    \ 1:100],50)\n</cell>\n<text>\nExercise 5\nIn Exercise 1 we used a matrix to represent\
    \ the entire grid, but here we assume that each row is a well, and each column\
    \ is a bucket. Each bucket has the same capacity.", "    if length(grid) <= 1\
    \ || length(grid[0]) <= 1 || capacity < 1\n        return 0;\n    elseif length(grid)\
    \ == length(grid[0])\n        return 0;\n    elseif capacity == length(grid)\n\
    \        return 0;\n    end", "    \"\"\"\n    Find the maximum number of water\
    \ empty slots required for a given number of water buckets.\n    \n    @param\
    \ grid: Input 2D array of booleans. \n    @param capacity: Number of water buckets\
    \ to empty wells. \n    @return: Number of water buckets needed to empty all wells.\n\
    \    \"\"\"\n    # write your code here\n    return 0\nend", "    length = length(grid)\n\
    \    empty = 0\n    \n    for row in 1:length\n        for col in row:\n     \
    \       if grid[row][col] == 1\n                empty += 1\n            end\n\
    \        end\n    end\n    \n    return empty\nend", "    nWells = length(grid)\n\
    \    if nWells == 0\n        return 0\n    else \n        well = grid[end]\n \
    \       fillings = zeros(capacity)\n        fillings[well] = 1\n        fillings[1]\
    \ = 0\n        \n        fillings0 = fillings[1:end-1]\n        \n        #fillings0\
    \ = fillings[2:end]\n        \n        #fillings0 = fillings[2:end]\n        \n\
    \        while length(fillings0) >= 2\n            fillings0 = fillings0 .- fillings0\n\
    \            fillings0 = fillings0 .- fillings0\n        end\n        \n     \
    \   fillings0 = fillings0[1:end-1]\n        \n        #fillings0 = fillings[2:end]\n\
    \        \n        #fillings0 = fillings[2:end]\n        \n        fillings0 =\
    \ fillings0[1:end-1]\n        \n        #fillings0 = fillings[2:end]\n       \
    \ \n        #fillings0 = fillings[2:end]\n        \n        fillings1 = fillings[2:end]\n\
    \        \n        #fillings1 = fillings[2:end]\n        \n        #fillings1\
    \ = fillings[2:end]\n        \n        fillings2 = fillings[2:end]\n        \n\
    \        #fillings2 = fillings[2:end]\n        \n        #fillings2 = fillings[2:end]\n\
    \        \n        fillings = fillings0 .+ fillings1 .+ fillings2 .- fillings3\n\
    \        \n        #fillings = fillings0 .+ fillings1 .+ fillings2 .- fillings3\n\
    \        \n        \n        \n        #fillings = fillings0 .+ fillings1 .+ fillings2\
    \ .- fillings3\n        \n        \n        \n        \n        \n        return\
    \ length(fillings)\n    \n    end\nend", "    \n    grid = Vector{Vector{Int64}}(grid)\n\
    \    bucket_count = Array{Int64}(10,10)\n    bucket_count = 0\n    \n    if length(grid)\
    \ == 0 \n        return 0 \n    end \n    \n    # Find the bucket with the maximum\
    \ number of units\n    for col in 1:length(grid[1])\n        max_bucket_count\
    \ = 0\n        for r in 1:length(grid)\n            if grid[r][col] == 1\n   \
    \             max_bucket_count = max(max_bucket_count, bucket_count[r][col])\n\
    \            end\n        end\n        bucket_count[max_bucket_count][col] +=\
    \ 1\n    end\n    \n    empty_count = 0\n    for col in 1:length(grid[1])\n  \
    \      if bucket_count[length(bucket_count)-1][col] > 0\n            empty_count\
    \ += bucket_count[length(bucket_count)-1][col]\n        else\n            empty_count\
    \ += 1\n        end\n    end\n    \n    return empty_count\nend\n</cell>\n<code\
    \ language=julia-1.6>\nmax_fill([[1, 0], [0, 1], [1, 1], [0, 1]], 2)\n</cell>\n\
    <code language=julia-1.6>\nmax_fill([[1, 0], [0, 1], [1, 1], [0, 1], [1, 0]],\
    \ 2)\n</cell>\n<code language=julia-1.6>\nmax_fill([[1, 0], [0, 0], [1, 1], [0,\
    \ 1], [1, 0]], 2)\n</cell>\n<code language=julia-1.6>\nmax_fill([[1, 0], [0, 0],\
    \ [1, 0], [0, 1], [1, 0]], 2)\n</cell>\n<code language=julia-1.6>\nmax_fill([[1,\
    \ 0], [0, 1], [1, 0], [0, 1], [1, 0], [1, 0]], 2)\n</cell>\n<text>\nWe have shown\
    \ how to solve the problem in Julia. You can now do it in Python.", "    i, j\
    \ = 0, 1\n    ans = 0\n    \n    while i <= length(grid) && j <= length(grid[1])\n\
    \        ans = max(ans, fill_rect(grid, i, j, capacity))\n        i = i + 2\n\
    \        j = j + 2\n    end", "    # Your code here\n    l = length(grid)\n  \
    \  \n    if l > capacity\n        return 0\n    end", "    grid = Vector{Vector{Int64}}(grid)\
    \ \n    lenGrid = length(grid) \n    if lenGrid <= 0\n        return 0\n    end\n\
    \    \n    buckets = Vector{Int64}(lenGrid) \n    for i = 1:lenGrid \n       \
    \ buckets[i] = capacity\n    end", "    mx = 0\n    for i in 1:length(grid)\n\
    \        mx = max(mx, grid[i][1])\n    end\n    return mx == 0 || mx == capacity\n\
    end\n</cell>\n<text>\nDay 10\nPart 1\nThe next group of input contains one line\
    \ per week. Each line contains five days of the week (Monday through Friday).\
    \ Each day has an integer that represents a number of hours.\nFor example, Monday\
    \ has 3 hours and Tuesday 5 hours.\nWrite a function that adds one hour to every\
    \ day in the input.", "    @assert grid.length == size( grid )\n    @assert grid.length\
    \ == size( grid[1,:] )\n    @assert 1 <= grid.length <= 10^2\n    @assert 1 <=\
    \ grid[1,:] <= 10^2\n    @assert capacity <= 10\n    \n    fill_count = Int64(0)\n\
    \    for i in 1:grid.length\n        for j in 1:grid[i,1]\n            fill_count\
    \ = fill_count + \n                if grid[i, j] == 0 && grid[i-1, j] == 1 &&\
    \ grid[i+1, j] == 1 \n                then 0\n                else capacity\n\
    \            end\n        end\n    end\n    \n    return fill_count\nend\n</cell>\n\
    <text>\nLet's see what happens when you call it on your data.", "    # write your\
    \ code here\n    grid = reshape(grid,(2,length(grid)))\n    capacity = Int(capacity)\n\
    \    \n    wells = grid[:,1]\n    \n    empty_count = Int64(0)\n    for row in\
    \ eachindex(wells)\n        if wells[row] == 1\n            empty_count = empty_count\
    \ + 1\n        end\n    end\n    \n    max_capacity = Int64(0)\n    for row in\
    \ eachindex(wells)\n        if wells[row] == 1\n            if capacity < capacity\n\
    \                max_capacity = capacity \n            end\n        end\n    end\n\
    \    \n    if empty_count > max_capacity\n        return empty_count\n    end\n\
    \    \n    fill_count = Int64(0)\n    for row in eachindex(wells)\n        if\
    \ wells[row] == 1\n            fill_count = fill_count + 1\n        end\n    end\n\
    \    \n    diff = max_capacity - capacity\n    if diff > fill_count\n        diff\
    \ = fill_count - capacity\n    end\n    \n    if diff == 0\n        return capacity\n\
    \    end\n    \n    diff = capacity - capacity\n    if diff == 0\n        return\
    \ 0\n    end\n    \n    fill_capacity = capacity - fill_count\n    if fill_capacity\
    \ < capacity\n        fill_capacity = capacity\n    end\n    \n    if fill_capacity\
    \ < capacity\n        return capacity\n    end\n    \n    return fill_count +\
    \ max_fill( grid[:,2:end], fill_capacity )\nend\n</cell>\n<code language=julia-1.5>\n\
    # Run this cell to test your function.\nres = max_fill([[0, 1], [0, 1], [1, 1]],\
    \ 5)\n</cell>\n<text>\n3. Reconstruct Water from Buckets\nIn the last problem\
    \ you solved, we filled the buckets to full capacity and were able to recover\
    \ water from them. Here are some more examples to better understand how we can\
    \ reconstruct water from buckets.", "    # write your code here\n    # return\
    \ \n    return sum(1 for row in grid for cell in row if cell == 0)", "    \"\"\
    \"\n    You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    and each 1 in a row represents a single unit of water.\n    Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    \    and all buckets have the same capacity.\n    Your task is to use the buckets\
    \ to empty the wells.\n    Output the number of times you need to lower the buckets.",
  "    if length(grid) == 0 || length(capacity) == 0 \n        return 0 \n    \n \
    \   fills = fill(grid, capacity) \n    \n    fills = fills[fills <= capacity]\
    \ \n    \n    stack = Vector{Int64}() \n    \n    for f in fills \n        if\
    \ f == 1 \n            if length(stack) == 0 \n                stack << 1\n  \
    \          else\n                stack[end] = stack[end] + 1 \n            end\
    \ \n        else \n            stack = stack - f \n        end\n    end ", " \
    \   if length(grid) == 0 || capacity == 0\n        return 0\n    if grid[0] ==\
    \ 1\n        return 1\n    \n    lower = max_fill(grid[cells(grid)==0], capacity-grid[cells(grid)==0][1])\n\
    \    upper = max_fill(grid[cells(grid)==1], capacity-grid[cells(grid)==1][1])\n\
    \    \n    if lower == 0 and upper == 0\n        return 0\n    \n    if lower\
    \ > upper\n        return lower\n    \n    if lower == upper\n        return lower\
    \ + 1\n    \n    return lower\nend\n</cell>\n<text>\n13. Knapsack\nWrite a function\
    \ to solve the 0/1 knapsack problem using a greedy approach."]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
