name: HumanEval_8_sum_product
language: jl
prompt: "\"\"\" For a given vector of integers, return a tuple consisting of a sum\
  \ and a product of all the integers in a vector.\n    Empty sum should be equal\
  \ to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0,\
  \ 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\nfunction sum_product(numbers::Vector{Int64})::Tuple{Int64,\
  \ Int64} \n"
tests: "using Test\n\n@testset begin\n\ncandidate = sum_product;\n\t@test(candidate(Vector{Int64}([]))\
  \ == (0, 1))\n\t@test(candidate([1, 1, 1]) == (3, 1))\n\t@test(candidate([100, 0])\
  \ == (100, 0))\n\t@test(candidate([3, 5, 7]) == (15, 105))\n\t@test(candidate([10])\
  \ == (10, 10))\nend\n"
completions: ["    sum = 0.0\n    product = 1.0\n    for number in numbers \n    \
    \    sum += number\n        product *= number\n    return (sum, product)\nend",
  "    if isempty(numbers)\n        return 0, 0\n    else\n        sum, product =\
    \ numbers[1], numbers[1]\n        for number in numbers[2:end]\n            sum\
    \ += number\n            product *= number\n        return sum, product\n    end\n\
    end\n</code>\n<|/ a |>\n<| a dscore=0 tags=julia,vector |>\nAnother approach using\
    \ built-in functions:\n<code>", "    if length(numbers) == 0 then\n        return\
    \ (0, 0)\n    end\n    sum = reduce(+, numbers)\n    product = reduce(*, numbers)\n\
    \    return (sum, product)\nend\n</cell>\n<code language=julia-1.6>\n@test sum_product([1,\
    \ 2, 3, 4]) == (10, 24)\n</cell>\n<text>\nExercise 2\nWrite a function that accepts\
    \ a vector of integers as an input, and returns another vector with the same number\
    \ of elements as the initial vector, but all elements that are equal to the sum\
    \ of the elements of the initial vector will be replaced by 1, and the rest will\
    \ be replaced by 0. For example, [1, 2, 3, 4] will return the vector [1, 0, 1,\
    \ 1].", "    if length(numbers)==0 \n        return (0, 1) \n    \n    sum::Int64\
    \ = sum(numbers)\n    product::Int64 = prod(numbers)\n    \n    return (sum, product)\n\
    end ", "    return (sum(numbers), prod(numbers))\nend\n</code>\n<|/ a dscore=5\
    \ tags=julia,arrays |>\n<| c |>\nThis won't work for vectors of non integral numbers.\
    \ Vectors of strings or floats are also not supported.\n<|/ c |>\n<| c |>\nVectors\
    \ of non integral numbers can be converted to Int64 before calling `sum` & `prod`\n\
    <|/ c |>\n<| c |>\nThe first sentence of this answer seems out of place (as I\
    \ already had the answer), but to reiterate: **you can convert them to Int64s\
    \ before calling sum and prod**. This is incorrect: **you cannot convert them\
    \ to Int64**, since Int64 is not a subtype of Number as is needed for a `ProductType`.\
    \ The correct answer is to provide `sum` and `prod` overloads for `AbstractArray`\
    \ with type parameters that allow conversion to Int64.\n<|/ c |>\n<| c |>\nthanks\
    \ for your comment! I did not intend to change my answer, I just wanted to make\
    \ clear that vectors of non integral numbers are not supported.\n<|/ c |>\n<|\
    \ c |>\nI understand that conversion is not necessary, but that would require\
    \ adding overloads for every possible combination of input types. I wanted to\
    \ avoid it :)\n<|/ c |>\n<| a dscore=5 |>\nThe sum function can be applied to\
    \ any AbstractArray. For example:\n<code>\njulia> using StatsBase", "    \n  \
    \  sum, prod = 0, 0\n    for v in numbers\n        sum += v\n        prod *= v\n\
    \    end", "    return (0, 1) if len(numbers) == 0 else accumulate(numbers, (x,\
    \ y) -> x + y, (1, 1))\nend\n</cell>\n<text>\nThe sum function computes the sum\
    \ of all the elements of a vector, using the function specified in the end statement\
    \ of the previous function.\nThe product function computes the product of all\
    \ elements of a vector, using the function specified in the end statement of the\
    \ previous function.\nThe accumulate function computes a single numerical value\
    \ using the provided function.\nThe accumulate function can be used to compute\
    \ the sum and product of many numerical vectors in one call.", "        sum_product\
    \ = Tuple{Int64, Int64}(0, 1); \n        for a in numbers; \n            sum_product\
    \ = (sum_product[1] + a, sum_product[2] * a); \n        end; \n        return\
    \ sum_product; \n    end\n\"\"\"\n    Calculate the average of a vector of numbers\n\
    \    >>> a = [1, 2, 3, 4]\n    >>> average(a)\n    2.0\n    \"\"\"", "    if numbers\
    \ == Vector{Int64}[]\n        return (0, 1)\n    else\n        sum = zero(Int64)\n\
    \        product = one()\n        for i in numbers\n            sum += i\n   \
    \         product *= i\n        return (sum, product)\n    end\nend\n</cell>\n\
    <text>\nQuestion 10\nWrite a function that returns the sum of the integers in\
    \ a vector, and the product of the integers in a vector.", "    return (sum(numbers),\
    \ prod(numbers))\nend", "    sum_product = sum_product_vector(numbers)\n    sum_product[1]\
    \ = sum_product[1] * sum_product[1]\n    return sum_product\nend", "    if length(numbers)\
    \ == 0 \n        return (0, 1) \n    \n    # Initialise product as 1 and sum as\
    \ 0\n    prod, sum = 0, 0 ", "    sum_ = 0, prod = 1\n    for i in numbers\n \
    \       sum_ = sum_ + i\n        prod = prod * i\n    return (sum_, prod)\nend",
  "    if length(numbers) == 0\n        (0,1)\n    else\n        sum = numbers[0]\n\
    \        product = 1\n        for n in numbers\n            sum += n\n       \
    \     product *= n\n        return (sum, product)\n    end\nend\n</cell>\n<code\
    \ language=julia-1.6>\n@test sum_product([1, 2, 3, 4]) == (10,24)\n</cell>\n<text>\n\
    6.4 Finding the maximum and minimum of a vector\nA common operation is to find\
    \ the maximum and minimum values in a vector. For a vector, one can use maximum\
    \ and minimum functions. maximum and minimum return the first and last element\
    \ of a vector. Additionally, a second optional parameter indicates the position\
    \ of the desired element in the vector and returns the corresponding value. If\
    \ two or more elements are equally minimum or maximum, one can use any of them\
    \ to represent the value.", "    if len(numbers) == 0\n        return (0, 0)\n\
    \    sum = 0\n    product = 1\n    for num in numbers\n        sum += num\n  \
    \      product *= num\n    return (sum, product)\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert sum_product([0, 4, 2, 3]) == (10, 24)\n@assert sum_product([1, 3, 5])\
    \ == (15, 15)\n@assert sum_product([4, 3, 2]) == (24, 12)\n@assert sum_product([1,\
    \ 3]) == (1, 3)\n@assert sum_product([5, 3]) == (15, 5)\n</cell>\n<text>\nA quick\
    \ check on a vector function", "    sum_, prod_ = 1::Int64, 1\n    for i in numbers,\
    \ sum_ += i, prod_ *= i\n    return sum_, prod_\nend\n</cell>\n<code language=julia-1.5>\n\
    sum_product([1, 2, 3, 4, 5, 6])\n</cell>\n<text>\nVectorized computations", " \
    \   \n    if length(numbers) < 2\n        return (numbers[1], 1)\n    end", " \
    \   if length!(numbers) \n        return (0, 1) \n    end\n    sum_prod::Int64\
    \ = 0\n    sum_sum::Int64 = 0\n    for i in numbers \n        sum_prod += i\n\
    \        sum_sum += i\n    end\n    return sum_sum, sum_prod \nend", "\"\"\"\n\
    \    Sum product of given numbers\n\"\"\"", "    sum = Int64(0)\n    prod = Int64(1)\n\
    \    for i in numbers\n        sum += i\n        prod *= i\n    return (sum, prod)\n\
    end", "    return (sum(numbers),prod(numbers))\nend", "    sum_product = 0, 1\n\
    \    for number in numbers \n        sum_product += number\n    end\n    return\
    \ (sum_product, sum_product*products[length(products)])\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert sum_product([1, 2, 3, 4]) == (10, 24)\n</cell>\n<text>\nFor the following\
    \ exercise we will define a function that sums the elements of a vector, except\
    \ when encountering 0.", "    sum = 0\n    product = 1\n    for i in numbers:\n\
    \        sum = sum + i\n        product = product * i\n    return sum, product\n\
    end\n</cell>\n<cell>\n@test sum_product([1, 2, 3, 4]) == (30, 120)\n</cell>\n\
    <text>\nFor a given vector of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a vector, sorted from lowest to highest.\n\
    \    Empty sum should be equal to 0 and empty product should be equal to 1.\n\
    \    >>> sum_product_sorted([])\n    (0,1)\n    >>> sum_product_sorted([1, 2,\
    \ 3, 4])\n    (4,12)\n    \"\"\"", "    return (sum_number(numbers), product_number(numbers))\n\
    end", "    if length(numbers)==0\n        return 0, 0\n    else\n        sum =\
    \ numbers[1]\n        product = numbers[1]\n        for a in numbers[2:end]\n\
    \            sum = sum + a\n            product = product * a\n        end\n \
    \       return sum, product\n    end\nend\n</code>\n<|/ a |>\n<| a |>\nFor anyone\
    \ who is using Julia 0.7, there is a package for vector operations. I prefer using\
    \ it instead of reimplementing functions with loops, such as your sum_product\
    \ and sum_sum.\nThe package is named v. \n<code>\njulia> using v ", "    (sum::Int64,\
    \ product::Int64) = Int, Int = Int\n    for i in numbers\n        sum += i\n \
    \       product *= i\n    return (sum, product)", "    if length(numbers) == 0\
    \ then \n        return (0, 1)\n    else\n        sum = numbers[1]\n        product\
    \ = 1\n        for i in numbers[2:end]\n            sum = sum + i\n          \
    \  product = product * i\n        end\n        return (sum, product)\n    end\n\
    end", "    \n    sum_product = (0.0,1.0)\n    for i in numbers\n        sum_product\
    \ = sum_product+(i,)\n    end\n    \n    return sum_product\nend", "\tsum = sum\
    \ = 0\n\tprod = prod = 0\n\tfor n in numbers\n\t\tsum <- sum + n\n\t\tprod <-\
    \ prod * n\n\tend\n\treturn (sum, prod)\nend\nend\n</code>\n<|/ a tags=julia dscore=1\
    \ |>\n<| c |>\nIt's probably not best practice to declare variables at the top\
    \ of the function. However, I still don't understand why I can't just define two\
    \ variables in the middle of the function and refer to them in the return. Why\
    \ does it have to be one line to define the variables?\n<|/ c |>\n<| a dscore=1\
    \ tags=julia |>\nIt looks like the error happens because you return tuples, and\
    \ Julia expects you to return an array. \nJust change your code to the following,\
    \ you might need to do some more modifications because I don't know what you're\
    \ trying to do:\n<code>", "    if length(numbers) == 0 \n        return (0, 1)\n\
    \    end", "    sum_product = (0, 0)\n    for number in numbers\n        sum_product\
    \ = sum_product + (number, number)\n    end\n    return sum_product\nend\n</code>\n\
    <|/ a tags=julia,type-inference,functional-programming |>\n<| a dscore=1 tags=julia,type-inference,functional-programming\
    \ |>\nThe problem is in this line:\n<code>\nsum_product = sum numbers, product\
    \ numbers\n</code>\nThis is interpreted as:\n<code>\nsum_product = sum(numbers),\
    \ product(numbers)\n</code>\nYou need some kind of vector constructor. Here is\
    \ an example using a comprehension:\n<code>\nsum_product = (sum, product)[numbers]\n\
    </code>\n<|/ a |>\n<| a dscore=1 |>\n<code>\nsum_product([1,2,3])\n</code>\nreturns\
    \ [3,6], as intended. However it also fails, since there is no \"product\" function.\n\
    <|/ a tags=julia,type-inference,functional-programming |>\n<| c |>\n`product([1,2,3])`\
    \ gives the error `MethodError: no method matching product(::Array{Int64,1})`,\
    \ which suggests that `product` doesn't exist on vectors.\n<|/ c |>\n<| a dscore=1\
    \ tags=julia,type-inference,functional-programming |>\nYou can do this:\n<code>",
  "    sum = zero()\n    product = one()\n    for num in numbers\n        sum+= num\n\
    \        product*= num\n    return (sum, product)\nend\n</code>\n<|/ a tags=julia\
    \ dscore=4 |>\n<| c |>\nThis can be simplified slightly by replacing the inner\
    \ loop with `sum += num; product *= num`. Note the use of `+=` and `*=` which\
    \ perform addition and multiplication in-place, respectively. The loop also can\
    \ be simplified by using `map` to apply a function to all elements of a vector:\
    \ `map(num, numbers)`\n<|/ c |>\n<| a dscore=4 tags=julia |>\nI came up with a\
    \ different approach that is similar to what was proposed but with some minor\
    \ modifications:\n<code>", "    if numbers.size == 0 then \n        (0, 1)\n \
    \   else\n        sum = numbers[1]\n        product = numbers[1]\n        for\
    \ i in numbers[2:length(numbers)] \n            sum = sum + i\n            product\
    \ = product * i\n        end\n        sum, product\n    end\nend\n</cell>\n<code\
    \ language=julia-1.4>\nsum_product([1,2,3,4])\n</cell>\n<text>\n6. Sum and product\
    \ of a vector", "        \n        if numbers == [] \n            return (0.0,\
    \ 1.0) \n        else \n            return (numbers[1]*numbers[2], numbers[1]+numbers[2])\
    \ \n        end\nend\n</cell>\n<text>\n3.2 Pi.\nA recursive solution to the Pi\
    \ problem is known to have two major drawbacks:\nIt is not very efficient, and\
    \ it requires the user to define a function pi!", "    \n    sum = product = 0\n\
    \    \n    for element in numbers\n        sum = sum + element\n        product\
    \ = product * element\n    end\n    return sum, product\nend ", "    if length!(numbers)\n\
    \        return (0, 0)\n    else\n        sum = prod(numbers)\n        prod =\
    \ 1\n        for num in numbers\n            prod = prod * num\n        end\n\
    \        return (sum, prod)\n    end\nend\n</code>\n<|/ a tags=function,if-statement,julia,vector,nested-loops\
    \ |>\n<| c |>\nYour function is great!\n<|/ c |>\n<| c |>\nThanks, this helped\
    \ me out!\n<|/ c |>\n<| a tags=function,if-statement,julia,vector,nested-loops\
    \ |>\nAs an alternative to the accepted answer, you can also use reduce(*, ...):\n\
    <code>\nusing LinearAlgebra", "    if numbers == []\n        return (0,1)\n  \
    \  else\n        sum = numbers.reduce((x,y)->x+y)\n        product = numbers.reduce((x,y)->x*y)\n\
    \        return (sum, product)\nend\n</code>\n<|/ a dscore=4 |>\n<| a dscore=3\
    \ |>\nHere's a solution using foldr.\n<code>\nsum_product ns = foldr(+,1,ns)",
  "    sum_ = 0\n    prod_ = 1\n    for x in numbers:\n        sum_ = sum_ + x\n \
    \       prod_ = prod_ * x\n    return sum_, prod_\nend\n</cell>\n<cell>\n@testset\
    \ \"sum_product\" begin\n    @test sum_product([1,2,3]) == (6, 12)\n    @test\
    \ sum_product([1,2,3, 1]) == (6, 12)\n    @test sum_product([1,2]) == (2, 4)\n\
    \    @test sum_product([1,2, 1]) == (2, 4)\n    @test sum_product([1,2,3]) ==\
    \ (6, 12)\n    @test sum_product([1,2,3, 1]) == (6, 12)\n    @test sum_product([1,2])\
    \ == (2, 4)\n    @test sum_product([1,2, 1]) == (2, 4)\n    @test sum_product([1,2,3])\
    \ == (6, 12)\n    @test sum_product([1,2,3, 1]) == (6, 12)\n    @test sum_product([1,2])\
    \ == (2, 4)\n    @test sum_product([1,2, 1]) == (2, 4)\nend\n</cell>\n<text>\n\
    Exercise 9: Write a function that calculates the arithmetic mean of a given array\
    \ of numbers.", "    sum(numbers)\n    prod(numbers)\nend\n</cell>\n<text>\nWrite\
    \ a function that will take in a matrix of integers and return the sum of the\
    \ elements in the first row and the sum of the elements in the second row of the\
    \ matrix. If there are no elements you can return them both as zero.", "    if\
    \ isnothing(numbers) \n        return (0, 0) \n    else \n        (sum_product(numbers[1:]),\
    \ numbers[1] * sum_product(numbers[2:end]))\n    end\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nCould you please explain the recursive nature of your solution?\
    \ I feel I understand it, but I am not sure how to apply it to this problem, or\
    \ what exactly the code does.\n<|/ c |>\n<| c |>\nI hope that makes it a bit clearer.\
    \ I have added comments to the code. Hope that helps.\n<|/ c |>\n<| c |>\n`return\
    \ (sum_product(numbers[1:]), numbers[1] * sum_product(numbers[2:end]))` can be\
    \ rewritten as `return (sum_product(numbers[1:]), numbers[1] * sum_product(numbers[2:end]))[1]`\n\
    <|/ c |>\n<| a |>\nA function definition for finding the sum of all numbers in\
    \ a given list.\nThe function should return nothing if there are no numbers in\
    \ the list or the list is empty.\n<code>", "    sum_prod = 0\n    prod_prod=1\n\
    \    for n in numbers\n        sum_prod = sum_prod + n\n        prod_prod = prod_prod*n\n\
    \    return sum_prod,prod_prod\nend\n</code>\n<|/ a tags=julia,function,variables\
    \ dscore=2 |>\n<| c |>\nThis was a great answer that helped me a lot but was missing\
    \ one critical part which was that the \"functions\" must be placed in an \"end\"\
    \ statement. I hope this helps others who are new to Julia. I would just add that\
    \ I had to make two changes. First, the \"sum_prod\" line and the \"prod_prod\"\
    \ line had to be changed from \"let\" to \"local variables using var\". I don't\
    \ know if these are necessary changes but this is what made it work for me. Thank\
    \ you very much for your help! This has been a great learning experience for me.\n\
    <|/ c |>\n<| a tags=julia,function,variables |>\nA more readable way to write\
    \ this would be to use Julia's function syntax. Here is how this could look like:\n\
    <code>", "    sum_, product_ = 1::Int64, 1::Int64\n    for num in numbers; sum_+=num;\
    \ product_*=num; end\n    return sum_, product_\nend\n</code>\n<|/ a dscore=1\
    \ tags=julia |>\n<| a dscore=0 |>\nHere is one solution using Base.sum() and Base.prod()\
    \ functions:\n<code>\nusing Base.sum, Base.prod", "    if length(numbers) == 0\n\
    \        (0, 1) \n    else\n        sum_product(numbers[2:end-1]) + numbers[1]\
    \ * (numbers[2:end-1].head * numbers[1]) \n    end\nend", "    \n    \"\"\"\n\
    \    Sum of all numbers in the vector\n    \n    >>> sum_product([1, 2, 3])\n\
    \    6\n    \"\"\"\n    \n    sum_ = 0\n    product_ = 1\n    for n in numbers\n\
    \        sum_ = sum_ + n\n        product_ = product_ * n\n    end\n    return\
    \ (sum_, product_)\nend #sum_product", "    if isEmpty(numbers)\n        return\
    \ 0, 0\n    sum, prod = 0, 0\n    for n in numbers\n        sum = sum + n\n  \
    \      prod = prod * n\n    return sum, prod\nend\n</cell>\n<text>\nThe function\
    \ length returns the length of a vector.", "    return numbers == []\n       \
    \ ? 0, 0\n        : (sum(numbers), product((numbers..0)*numbers))\nend\n</cell>\n\
    <code language=julia-1.5>\nsum_product([1, 2, 3, 4])\n</cell>\n<text>\nExercise\
    \ 1: Create your own custom function for summing and producting elements\nCreate\
    \ your own to do summing and producting elements in a vector. Your function should\
    \ take an argument of the form Vector{Int64}, a vector of 64-bit integers.\nReturn\
    \ tuple consisting of a sum and a product of all the elements in the vector.\n\
    The function should work for empty vectors and vectors with elements. No elements\
    \ are ignored, so summing an empty vector will return (0,0) and a product of an\
    \ empty vector will return 1.\nThe function should work for vectors with negative\
    \ elements as well. Negative elements should be ignored when summing or producting\
    \ them.\nThe function should work for vectors of size 1. If an element is 0 then\
    \ it should return (0,0). If a vector has only one element, it should return that\
    \ element.\nThe function should work for vectors of size greater than 1.", " \
    \   if length(numbers) == 0\n        return 0, 0\n    end\n    prod = 1\n    sum\
    \ = 0\n    for i in numbers\n        prod *= i\n        sum += i\n    end\n  \
    \  return sum, prod\nend\n</cell>\n<code language=julia-1.3>\n@time sum_product([1,2,3,4,5,6])\n\
    </cell>\n<text>\nProblem 8. Find the number of primes less than or equal to 1000\n\
    The first problem is to find the number of prime numbers less than or equal to\
    \ 1000.\nThe second problem is to use the same function we used in problem 5 to\
    \ find the number of primes less than or equal to 1000.\nHint: Remember that we\
    \ can use the function we already wrote to find the number of primes less than\
    \ or equal to 1000.", "    if length(numbers) == 0 return (0,1) \n    return numbers[1],\
    \ numbers[1]*numbers[end] \nend\n</code>\n<|/ a tags=julia dscore=1 |>\n<| c |>\n\
    While this may theoretically answer the question, [it would be preferable](//meta.stackoverflow.com/q/8259)\
    \ to include the essential parts of the answer here, and provide the link for\
    \ reference.\n<|/ c |>\n<| a dscore=1 tags=julia |>\nYou could use reduce to solve\
    \ this problem (assuming you want the product of all the elements in the vector\
    \ and not the sum of all them). This method applies a function to all the elements\
    \ of the vector, and returns the result of the function applied to the first element\
    \ of the vector and the rest of the elements.\n<code>\nreduce(v->v*1, numbers)\n\
    </code>\nThe function v->v*1 is a function which multiplies the vector by one.\
    \ Since we want the product of all the numbers in the vector we can apply v*1\
    \ to each element of the vector.\n<|/ a |>\n<| a tags=julia |>\nHere's a compact\
    \ solution using broadcasting and views:\n<code>\nsum(numbers, 1)\n</code>\nTo\
    \ illustrate what's going on here, this expression multiplies the vector by its\
    \ number of elements, each element of which is 1.\n<code>\njulia> numbers = 1:10\n\
    1:10", "    if length(numbers) == 0\n        return (0, 1) \n    else \n     \
    \   return sum(numbers), prod(numbers) \n    end\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThis is essentially the same as my answer with minor improvements over\
    \ yours. I believe that it is better to avoid `==` when possible.\n<|/ c |>\n\
    <| c |>\nI agree. My answer could have more explanation than the other answer\
    \ but I think this one would benefit from being written as a function.\n<|/ c\
    \ |>\n<| c |>\nThanks for your answer. The only problem is that it returns incorrect\
    \ values for the empty list.\n<|/ c |>\n<| c |>\nI just tested this in Julia and\
    \ I think it's because `Int64` isn't an Int64 but a Float64. You can fix this\
    \ by changing `Int64` to `Int` and using `==` instead of `===`. I'm still working\
    \ on understanding why this is the case though.\n<|/ c |>\n<| c |>\nI think the\
    \ issue comes from Julia's way of handling empty vectors. If you test `Vector{Int}()`,\
    \ then `length(Vector{Int}()) == 0`. It looks like `sum` thinks `Int64()` is `0`\
    \ and `prod` thinks `Int64()` is `1`.\n<|/ c |>\n<| a dscore=2 |>\nThe answer\
    \ given by is really great, especially because it is an idiomatic Julia approach\
    \ that many people should learn if they come across the problem in the future.\
    \ The problem with it is that it does extra allocations: it calculates the product\
    \ and sum at the same time as they can be calculated on demand.\nThis solution\
    \ also computes them in O(1) instead of O(n) (where n is the size of the input\
    \ vector).\n<code>", "    sum_product = ()\n    product_ = 1\n    for number in\
    \ numbers\n        sum_product += (number,)\n        product_ *= number\n    end\n\
    \    return sum_product, product_\nend\n</code>\n<code>", "    if numbers == []\
    \ \n        (0, 1) \n    else \n        sum = reduce(add,numbers)\n        product\
    \ = reduce(mul,numbers)\n        (sum, product)\n    end\nend\n</cell>\n<text>\n\
    Exercise 3.1: Write a function named product() that calculates the product of\
    \ a given vector.", "    if length(numbers) < 2 \n        return 0, 0\n    else\n\
    \        sum, product =sum(numbers), prod(numbers)\n        return sum, product\n\
    \    end\nend", "    if isempty(numbers)\n        return 0, 1\n    sum = numbers[1]\n\
    \    product = 1\n    for i in numbers[2:end]\n        sum += i\n        product\
    \ *= i\n    end\n    return sum, product\nend", "    if length(numbers) == 0\n\
    \        (0, 1)\n    elseif length(numbers) == 1\n        (numbers[1], numbers[0])\n\
    \    else\n        (sum(numbers), prod(numbers))\n    end\nend\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a |>\nMy solution to the same problem in Julia 0.5\n<code>",
  "    if isempty(numbers)\n        return (0, 0)\n    else\n        sum = 0\n   \
    \     product = 1\n        for number in numbers\n            sum += number\n\
    \            product *= number\n        return (sum, product)\n    end\nend\n\
    </cell>\n<text>\nThis code has been tested in Julia's REPL. Now let's try it in\
    \ our notebook.", "    if (length(numbers) == 0)\n        return (0, 1)\n    \n\
    \    sum_ = 0\n    prod_ = 1\n    \n    for i in numbers\n        sum_ = sum_\
    \ + i\n    end\n    \n    for i in numbers\n        prod_ = prod_ * i\n    end",
  "    \"\"\"Sum and product of numbers.\"\"\"\n    # sum numbers and multiply by\
    \ 1\n    return sum(numbers), numbers.product \nend\n</cell>\n<text>\nExercise\
    \ 3\nWrite a function that returns the product of all numbers from 1 to 10.\n\
    Bonus: What happens when you run out of numbers? Do you handle exceptions?", " \
    \ if length(numbers) == 0 then\n    return (0, 1)\n  else\n    let sum = numbers[1]\n\
    \    let product = 1\n    for i in 2 to length(numbers) do\n      sum *= numbers[i]\n\
    \      product *= numbers[i]\n    end\n    return (sum, product)\n  end\nend\n\
    </cell>\n<text>\nPart 4: Implementing Binary Search for a SortedVector class",
  "    if length(numbers) == 0 \n        return (0, 1) \n    end\n    \n    function\
    \ sum(x::Int64)::Int64\n        sum = 0\n        for i in numbers\n          \
    \  sum += i\n        end\n        return sum\n    end", "  new_sum = 0\n  new_product\
    \ = 1\n  for n in numbers\n    new_sum += n\n    new_product *= n\n  return new_sum,\
    \ new_product\nend\n</cell>\n<code language=julia-1.0>\nsum_product([1,2,3,4,5])\n\
    </cell>\n<text>\nExercise 2\nCreate a function which accepts a vector of integers\
    \ and a vector of integers and returns a vector consisting of the product of the\
    \ integers in the first argument and the integers in the second argument. The\
    \ product should be in the range 0 to infinity.", "    if length(values(numbers))\
    \ == 0 return (0,0) \n    else return (numbers[1] + numbers[2], numbers[1] * numbers[2])\n\
    end\n</cell>\n<code language=julia-1.5>\nsum_product([1, 2, 3, 4])\n</cell>\n\
    <text>\nExercise 3: Write a function product() that computes the product of a\
    \ vector of integers. \n    It should work for any type of numbers (i.e. Int,\
    \ Float64, BigInt).\n    You should use generic function prod() defined on Base.\n\
    \    >>> product([10, 20])\n    200\n    >>> product(20)\n    20\n    >>> product([])\n\
    \    1\n    \"\"\"", "    \n    sum_ = 0\n    prod_ = 1\n    for n in numbers\n\
    \        sum_ += n\n        prod_ *= n\n    return (sum_, prod_)\nend\n</cell>\n\
    <code language=julia-1.5>\nsum_product([1,2,3])\n</cell>\n<text>\nLet's now implement\
    \ a function to find the largest product of three numbers (greater than 1000)!",
  "    sum_ = numbers[0]\n    prod = numbers[1]\n    for number in numbers[2:length(numbers)]\
    \ \n        sum_ = sum + number\n        prod = prod * number\n    end\n    return\
    \ (sum_, prod)\nend\n</code>\n<|/ a |>\n<| c |>\nIn Julia 0.5 I see that `product`\
    \ is deprecated and it is recommended to use `*` instead. Can you please give\
    \ an example how to use `*` instead of `product`? I see that the answer is `return\
    \ (sum, prod(numbers))` but I cannot understand how this works.\n<|/ c |>\n<|\
    \ a dscore=3 |>\nAs pointed out in the comments, the accepted answer can be written\
    \ more succinctly as\n<code>", "    sum_ =0\n    prod =1\n    for i in numbers\n\
    \        sum_ += i\n        prod *= i\n    return (sum_, prod)\nend\n</cell>\n\
    <code language=julia-1.0>\nsum_product([1,2,3,4])\n</cell>\n<text>\nTask 3", " \
    \   if length(numbers) < 2\n        return 0, 0\n    else\n        sum_product\
    \ <- 0\n        product_sum <- 1\n        for n in numbers\n            sum_product\
    \ <- sum_product + n\n            product_sum <- product_sum * n\n        return\
    \ sum_product, product_sum\n    end\nend", "    \"\"\"For a given vector of integers,\
    \ return a tuple consisting of a sum and a product of all the integers in a vector.\n\
    \    Empty sum should be equal to 0 and empty product should be equal to 1.\n\
    \    \"\"\"\n\"\"\"", "    sum = 0 \n    product = 1 \n    for n in numbers \n\
    \        sum = sum + n \n        product = product * n \n    return (sum, product)\
    \ \nend ", "    sum = 0\n    prod = 1\n    for n in numbers\n        sum += n\n\
    \        prod *= n\n    return (sum, prod)\nend\n</cell>\n<text>\nThe previous\
    \ function can be used for computing the sum and the product of the numbers in\
    \ a given vector:", "    if length(numbers) < 2\n        (1, 1)\n    else\n  \
    \      (sum(numbers), product(numbers))\n    end\nend\n</cell>\n<code language=julia-1.4>\n\
    @code_warntype sum_product([1, 2, 3])\n</cell>\n<text>\nWe can verify that this\
    \ function produces the correct result. Note that the result is not actually a\
    \ tuple, but a 2-tuple, which Julia automatically expands to a tuple when unpacked\
    \ (i.e. sum(numbers) unpacks the tuple (10,) into 10).", "    if length(numbers)\
    \ == 0 then \n        return (0,0) \n    else \n        sum = 0\n        product\
    \ = 1\n        for i in numbers do\n            sum = sum + i\n            product\
    \ = product * i\n        end\n        return (sum,product)\n    end\nend \n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=function,sum,julia,product dscore=1 |>\nIn Julia\
    \ 1.3, you can simply do\n<code>\nsum(xs) = sum(xs)\nprod(xs) = prod(xs)\n</code>\n\
    <|/ a |>\n<| c |>\nIt should be `sum(xs)` not `sum(:xs)`\n<|/ c |>\n<| c |>\n\
    This is no longer true (at least, not for versions 1.3 and above).\n<|/ c |>\n\
    <| a |>\nIn julia 1.3 you can use the sum function\n<code>\nsum(x::AbstractVector)\
    \ = sum(x)\n</code>\n<|/ a tags=function,sum,julia,product dscore=0 |>\n<| c |>\n\
    The function signature in the docs (https://docs.julialang.org/en/v1/base/math/#Base.sum)\
    \ shows that it's `sum{T}(x::AbstractVector{T}, dim::Int = 1)`\n<|/ c |>\n<| a\
    \ tags=function,sum,julia,product |>\nFor Julia 1.3 or above you can use built-in\
    \ sum function and built-in prod function:\n<code>\njulia> sum([1, 2, 3, 4])\n\
    10", "    sum_ = 0\n    prod = 1\n    for i in numbers\n        sum_ += i\n  \
    \      prod *= i\n    return (sum_, prod)\nend", "    sum = zeros(Int64, length(numbers))\n\
    \    product = ones(Int64, length(numbers))\n    for x in numbers\n        sum\
    \ += x\n        product *= x\n    return sum, product\nend", "    return (0, 1)\
    \ \n    for element in numbers \n        sum, product = element \n        if sum\
    \ == 0\n            sum += product\n        elseif product == 0\n            product\
    \ = sum\n        else \n            sum += product \n            product *= sum\
    \ \n    end\n    return sum, product\nend\n</cell>\n<text>\nQuestion 4\nWhat is\
    \ the sum and product of the vector", "    return (sum(numbers), prod(numbers))\n\
    end\n</cell>\n<text>\nAnd that is it for this exercise. Good luck!", "    return\
    \ (sum(numbers), prod(numbers))\nend \n</cell>\n<code language=julia-1.0>\n@assert\
    \ @isa sum_product(Int64)\n</cell>\n<text>\nQuestion 3\nDefine a function that\
    \ computes the sum of the square of all the integers in a vector.\nThe sum of\
    \ the square of all the integers in a vector is computed as", "    if length(a)\
    \ == 0 || length(b) == 0 \n        (0, 0) \n    else \n        (a[end], b[end])\
    \ \n    end\nend", "    sum = 0 \n    product = 1\n    for i in numbers \n   \
    \     sum = sum + i\n        product = product * i\n    return (sum, product)\n\
    end\n</cell>\n<code language=julia-0.4>\nsum_product([1,2,3])\n</cell>\n<code\
    \ language=julia-0.4>\nsum_product([1,2,3,4,5])\n</cell>\n<code language=julia-0.4>\n\
    # Example of using @inbounds to make sure you're not calling an out of bounds\
    \ index\n@inbounds @time sum_product([1,2,3,4,5])\n</cell>\n<code language=julia-0.4>\n\
    @inbounds @time sum_product([1,2,3])\n</cell>\n<text>\nExample: Finding The Sum\
    \ of Factorials\nWe can easily modify the sum_product function to calculate the\
    \ sum of factorials.", "    if numbers == [] \n        (0, 1) \n    else \n  \
    \      sum_product_helper(numbers, 0, 1)\n    end\nend", "    if length(numbers)\
    \ == 0 \n        return (0, 1)\n    else\n        sum(numbers), product(numbers)\n\
    end\n</cell>\n<text>\nRecall that we are using Julia syntax for defining functions.\
    \ So, we can use the same syntax as we would use for defining the vector sum function\
    \ we wrote above.", "    if numbers.length == 0 \n        return (0, 1)\n    else\
    \ \n        return (sum(numbers), prod(numbers))\nend\n</cell>\n<text>\nThis function\
    \ is very similar to sum_product() we defined earlier. Let's run this and compare\
    \ it to the results of sum_product() we used earlier.", "    sum_, product_ =\
    \ 1::Int64, 0, 2::Int64\n    for i in numbers\n        sum_ += i\n        product_\
    \ *= i\n    end\n    return sum_, product_\nend\n</cell>\n<code language=julia-1.5>\n\
    @time sum_product([1, 2, 3, 4, 5, 6, 7]);\n</cell>\n<text>\nExercise 7.0\nWrite\
    \ a function that takes a vector of integers, a vector of numbers, and a scalar\
    \ and returns a new vector that contains the results of applying the function\
    \ to the first vector with the second vector and the scalar.\n>>> @time vector_product(vector,\
    \ vector, scalar);\ntime elapsed ~5s.", "    sum = zero(Int64)\n    prod = one(Int64)\n\
    \    for i in numbers\n        sum = sum + i\n        prod = prod * i\n    end\n\
    \    return sum, prod\nend\n</cell>\n<code language=julia-1.0>\n@code_warntype\
    \ sum_product(numbers)\n</cell>\n<text>\nExercise 6\nWrite a function that returns\
    \ the absolute value of a number (that is, the absolute value of its magnitude).\n\
    \    You should use nothing other than + and * operators.\n    >>> abs(-10)\n\
    \    10\n    >>> abs(10)\n    10\n    \"\"\"", "    if length(numbers) == 0 \n\
    \        return (0, 1)\n    elseif length(numbers) == 1 \n        return (numbers[1],\
    \ numbers[0])\n    else\n        sum_product = numbers[1] + sum_product(numbers[2:end])\n\
    \        return sum_product, sum_product * numbers[1]\n    end\nend\n</code>\n\
    <code>\n#Example 2\n#-----------", "    sum = 0\n    product = 1\n    for n in\
    \ numbers\n        sum = sum + n\n        product = product * n\n    return sum,\
    \ product\nend", "    sum_of_numbers = 0\n    product_of_numbers = 1\n    for\
    \ n in numbers\n        sum_of_numbers += n\n        product_of_numbers = product_of_numbers\
    \ * n\n    return (sum_of_numbers, product_of_numbers)\nend\n</cell>\n<text>\n\
    Exercise 11: Test your sum_product function by running the following cell. Remember\
    \ that you should run this cell before submitting your notebook. Make sure all\
    \ the functions you define are working correctly before submitting your notebook.",
  "    summation::Int64 = 0\n    product::Int64 = 1\n    for n in numbers\n      \
    \  summation = summation + n\n        product = product * n\n    end\n    return\
    \ (summation, product)\nend\n</code>\n<|/ a tags=julia,function,tuples,for-loop\
    \ |>\n<| a tags=julia,function,tuples,for-loop dscore=0 |>\nThis was my solution:\n\
    <code>", "    sum_product = sum(numbers)\n    product_of_numbers = reduce(mul,\
    \ numbers, 1)\n    return (sum_product, product_of_numbers)\nend\n</code>\nThe\
    \ result will be as follows:\n<code>\njulia> sum_product([1, 2, 3, 4])\n(10,24)",
  "    if length(numbers) == 0\n        return (0, 0)\n    else\n        product =\
    \ 1\n        sum = 0\n        for i in numbers\n            sum = sum + i\n  \
    \          product = product * i\n        end\n        return (sum, product)\n\
    \    end\nend", "    sum = Int64(0)\n    product = Int64(1)\n    for i in numbers\n\
    \        sum += i\n        product *= i\n    end\n    return (sum, product)\n\
    end\n</cell>\n<code language=julia-0.6>\n@time sum_product([1,2,3,4,5])\n</cell>\n\
    <text>\nExercise 2\nWrite a function which can find the smallest element in a\
    \ vector. Your function should work by taking a vector of integers as input and\
    \ returning the smallest integer. It should work with empty vectors. In Julia,\
    \ you can call min() directly on a vector.", "    if length(numbers) == 0 \n \
    \       (0, 1) \n    else \n        sum_product_helper(numbers) \n    end\nend",
  "    sum(numbers)\n    prod(numbers)\nend", "    sum = 0 \n    product = 1\n   \
    \ for i in numbers\n        sum += i \n        product *= i\n    end\n    return\
    \ (sum, product)\nend", "    if length(numbers) == 0 \n        (1, 1) \n    else\
    \ \n        numbers[1], numbers[1] * prod(numbers[2:end])\n    end\nend\n</code>\n\
    <|/ a |>\n<| c |>\nWhat if I have a list of pairs of values?\n<|/ c |>\n<| c |>\n\
    I haven't really worked with it before, so I'm not sure how exactly to implement\
    \ this efficiently in Julia. My thought was to create an array of the product\
    \ of the values in the pairs, and then take the product of the sum function on\
    \ the array. Does that make sense?\n<|/ c |>\n<| c |>\nYes, but how do you then\
    \ sum over pairs? `sum(sum(pairs))` does not work and neither does `sum(sum.(pairs))`\n\
    <|/ c |>\n<| c |>\nSorry,, I didn't understand your comment before. Here is an\
    \ edit to my answer that includes a version that does this as requested in your\
    \ comment. Let me know if this is what you're looking for. Let me know if this\
    \ helps. Thanks!\n<|/ c |>\n<| a dscore=3 |>\nThis answer is inspired by this\
    \ answer, by which I mean that I got it working first and then re-worked it to\
    \ match your question.\n<code>", "    sum_val = 0\n    prod_val = 1\n    for val\
    \ in numbers \n        sum_val += val\n        prod_val *= val\n    return (sum_val,\
    \ prod_val)\nend\n</code>\nThe code above is not the most efficient implementation\
    \ (it's O(n^2)), but it was the best I could come up with, at least for now. \n\
    The code above is for Julia version 0.6, but it should work with other versions.\
    \ \nAlso, I think it should be possible to implement this function more efficiently\
    \ using some more advanced programming techniques, but I haven't found anything\
    \ for it so far. \nIf you have suggestions how to improve my code, please feel\
    \ free to leave a comment. \nEDIT: I noticed that I can just use reduce(...) in\
    \ place of sum_product(...), which makes the code much shorter and easier to read.\
    \ Also, I just noticed that the code above doesn't work when given a list of numbers\
    \ in reverse, i.e. [4, 3, 2, 1]. Sadly, I don't have a solution right now for\
    \ this, sorry!\n<|/ a dscore=2 |>\n<| c |>\nHmm, no, this doesn't work correctly\
    \ when `numbers` has negative numbers. For example, if `numbers` has the numbers\
    \ [-1, -1, 3, -2, -2], then the result is (-1, -3).\n<|/ c |>\n<| c |>\nYou are\
    \ right, thanks for noticing. I'll fix it in a moment. Also, thanks for your comment,\
    \ it made me notice that I had forgotten to change `numbers` to `reverse` in the\
    \ `sum_product` function :)\n<|/ c |>\n<| c |>\nI modified the code so that it\
    \ works with negative numbers now.\n<|/ c |>\n<| c |>\nI still don't think that\
    \ is right. I think `reduce` should work for me but I can't figure out how to\
    \ implement it in Julia. I'll try to figure it out if I get time, but I doubt\
    \ that I'll ever get it. Also, it seems like a lot of extra effort for something\
    \ that's simple and easy to read.\n<|/ c |>\n<| c |>\nI think I figured it out.\
    \ I'll post my answer soon.\n<|/ c |>\n<| a dscore=2 tags=julia,performance,vectorization,math\
    \ |>\nA simple way is to convert your vector to an array and use sum on the array.\
    \ It should use SIMD instructions (at least on x86 CPUs, not sure if other architectures\
    \ use SIMD instructions), and is definitely faster than writing your own loop.\n\
    <|/ a |>\n<| c |>\nThanks, I'll try this out on some actual data and see if it\
    \ actually works.\n<|/ c |>\n<|", "    sum_ = product = 1\n    for number in numbers\
    \ \n        sum_ += number \n        product *= number \n    end\n    return sum_,\
    \ product \nend\n</cell>\n<text>\nWe have finished defining the function sum_product!\
    \ You can now call this function with the sample vector we defined above to verify\
    \ that it returns the correct values:", "    if numbers == []\n        return\
    \ (0, 0)\n    else\n        sum = numbers[1]\n        product = 1\n        for\
    \ i in numbers[2:end]\n            product = product * i\n            sum = sum\
    \ + product\n        return (sum, product)\n    end\nend\n</cell>\n<code language=julia-1.3>",
  "    if len(numbers) == 0\n        return (0, 1)\n    end\n    sum_product = 0\n\
    \    product_ = 1\n    for i in numbers\n        sum_product += i\n        product_\
    \ *= i\n    end\n    return sum_product, product_\nend\n</cell>\n<code language=julia-1.1>",
  "    if length(numbers)==0, return (0,0) \n    sum=0; product=1\n    for n in numbers\
    \ \n        sum = sum + n\n        product = product * n\n    return sum, product\n\
    end", "    if length (numbers)==0 then return (0,1) else return (sum(numbers),product((numbers)))\n\
    end # end sum_product", "    sum_prod = 1\n    for i in numbers\n        sum_prod\
    \ *= i\n    end\n    sum_prod = sum_prod - 1\n    return (sum_prod, prod(numbers))\n\
    end\n</cell>\n<code language=julia-1.3>\n@assert sum_product([1, 4, 3]) == (15,\
    \ 24)\n@assert sum_product([1, -2, -3]) == (1, 0)\n@assert sum_product([1, 2,\
    \ 3, 4, -5]) == (120, 720)\n@assert sum_product([1, 2, 3, 4, 5, -5]) == (120,\
    \ 720)\n@assert sum_product(Array{Int64}([1, 4, 3])) == (15, 24)\n@assert sum_product(Array{Int64}([1,\
    \ -2, -3])) == (1, 0)\n@assert sum_product(Array{Int64}([1, 2, 3, 4, -5])) ==\
    \ (120, 720)\n@assert sum_product(Array{Int64}([1, 2, 3, 4, 5, -5])) == (120,\
    \ 720)\n</cell>\n<text>\n4.3 Euclidean Distance of a vector from another vector",
  "    if length (numbers) < 2\n        return (0, numbers[0])\n    else\n       \
    \ return (numbers[end], numbers[end] * sum_product(tail(numbers)))\n    end\n\
    end\n</cell>\n<code language=julia-1.5>", "  \n    sum_product = 0\n    product_\
    \ = 1\n    \n    for number in numbers\n        sum_product += number\n      \
    \  product_ *= number\n    end", "    sum_products = sum(numbers)\n    product_of_numbers\
    \ = sum(numbers) * prod(numbers)\n    return sum_products, product_of_numbers\n\
    end", "    sum = zero(Int64)\n    prod = one(Int64)\n    for i in numbers\n  \
    \      sum = sum + i\n        prod = prod * i\n    return (sum, prod)\nend\n</cell>\n\
    <text>\n4.1 Create a function called print_vector that prints out the vector given.\
    \ \nHint: Use a for loop!", "    sum = 0\n    product = 1\n    for number in numbers\n\
    \        sum += number\n        product *= number\n    return (sum, product)\n\
    end\n</cell>\n<code language=julia-0.4>\n@assert sum_product([1, 2, 3]) == (3,\
    \ 6)\n@assert sum_product([-1, -2, 3, -2]) == (0, 4)\n@assert sum_product([1,\
    \ 1]) == (0, 0)\n@assert sum_product([]) == (0, 1)\n</cell>\n<text>\nWrite a function\
    \ named vector_sum that will return the sum of each row of a vector $x$. The output\
    \ should be an $n \\times 1$ matrix.", "    if length(numbers) == 0\n        return\
    \ 0, 0\n    end\n    sum, product = numbers[1], numbers[1]\n    for i in numbers[2:end]\n\
    \        sum, product = sum + i, product*i\n    end\n    return sum, product\n\
    end", "    sum = numbers[1]\n    prod = 1\n    for val in numbers[2:end]\n   \
    \     prod *= val\n        sum += prod\n    return sum, prod\nend", "    sum =\
    \ 0\n    product = 1\n    for n in numbers\n        sum = sum + n\n        product\
    \ = product * n\n    end\n    return (sum, product)\nend\n</code>\n<|/ a |>\n\
    <| c |>\n`for n in numbers` is redundant.\n<|/ c |>\n<| c |>\nThank you! I totally\
    \ forgot about this simple solution.\n<|/ c |>\n<| c |>\nNo need to use a mutable\
    \ `i` variable.  `for n in numbers`  is sufficient.\n<|/ c |>\n<| a dscore=4 tags=julia,function\
    \ |>\nAnother approach without loops is to use product:\n<code>\njulia> prod([1,\
    \ 2, 3])\n6\n</code>\n<|/ a |>\n<| c |>\nNote that this will raise an exception\
    \ when used with a scalar. `prod()` returns 1 for scalars.\n<|/ c |>\n<| c |>\n\
    `for n in [1, 2, 3]; n == 1 ? return 1 : n*1; end` should handle that case.\n\
    <|/ c |>\n<| c |>\n`product([1, 2, 3])` returns `6` for me\n<|/ c |>\n<| a |>\n\
    I find it more readable like this:\n<code>", "    sum = 0\n    prod = 1\n    for\
    \ el in numbers\n        sum += el\n        prod *= el\n    return (sum, prod)\n\
    end", "    s, p = 0, 0\n    for n in numbers\n        s += n\n        p += 1\n\
    \    return s, p\nend\n</cell>\n<code language=julia-0.6>\n@assert sum_product([2,\
    \ 1, 0, 3]) == (9, 2)\n@assert sum_product([0, 0, 0]) == (0, 3)\n@assert sum_product([1,\
    \ 1]) == (1, 1)\n@assert sum_product([1, 2, 3, 4, 5]) == (12, 5)\n</cell>\n<text>\n\
    4.3 Vector operations\nThe following operation is carried out on vectors.\n$$\
    \ \\mathbf{y} = \\begin{bmatrix} 1 & 2 & 3\\end{bmatrix}^{\\mathrm{T}} \\mathbf{x}\
    \ $$", "    # Write code here\n    sum_ = sum(numbers)\n    prod_ = 1\n    for\
    \ number in numbers\n        prod_ *= number\n    end\n    return sum_, prod_\n\
    end", "    sum_=0\n    prod_=1\n    length= length(numbers)\n    for i in numbers:\n\
    \        sum_=sum_+i\n        prod_= prod_*i\n    return (sum_,prod_)\nend", " \
    \   if length == 0 \n        return 0, 0\n    end\n    sum_product = numbers[0]\
    \ + numbers[1]\n    for n in numbers[2:end]\n        sum_product = sum_product\
    \ + n\n    end\n    return sum_product, numbers[1]\nend", "  if length(xs) ==\
    \ 0 return (0,1) \n  else \n    sum_product = Int64(0) \n    product_of_numbers\
    \ = Int64(1) \n    for n in xs\n      sum_product = sum_product + n \n      product_of_numbers\
    \ = product_of_numbers * n \n    end\n    (sum_product, product_of_numbers) \n\
    \  end\nend\n</cell>\n<text>\nNow let's test our new function. Notice that this\
    \ function takes vector and returns tuple consisting of a sum and a product of\
    \ all the numbers in the vector", "        sum_ = 0\n        prod_ = 1\n     \
    \   for n in numbers\n            sum_ += n\n            prod_ *= n\n        end\n\
    \        return sum_, prod_\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ sum_product([1,2,3]) == 10\n@assert sum_product([0,1,2]) == 0\n@assert sum_product([-1,-2])\
    \ == 0\n@assert sum_product([1,2,3,4]) == 24\n</cell>\n<text>\nExercise 6. Write\
    \ a function that calculates the\nsum of an integer array, and another that calculates\
    \ the product of an integer array. The first one should work directly on the array,\
    \ and the second one should work on a vectorized approach.\nThe function should\
    \ return the sum and product as a tuple.\nFor an empty array, both sum and product\
    \ should be equal to zero.\nFor an array of one element, the sum and product should\
    \ be equal to the element itself.\nFor a vector of integers, the sum and product\
    \ should be the sum of all the integers in the vector.\nFor an array of integers,\
    \ the sum and product should be the product of all the integers in the vector.\n\
    For a vectorized approach, the sum and product should be the sum and product of\
    \ the vector.", "    if isempty(numbers)\n        (0, 0)\n    else\n        (sum(numbers),\
    \ prod(numbers))\n    end\nend\n</cell>\n<code language=julia-1.0>\n@assert sum_product([1,2,3])\
    \ == (6, 12)\n@assert sum_product([1,2]) == (3, 6)\n@assert sum_product([1]) ==\
    \ (0, 1)\n@assert sum_product([0,1]) == (0, 1)\n@assert sum_product([1,1,3]) ==\
    \ (6, 6)\n@assert sum_product([0,2]) == (0, 2)\n</cell>\n<text>\nExercise 7.8\n\
    Write a function that returns the square of a number. \nTest your function on\
    \ a few numbers.", "    if numbers == []\n        return (0,0)\n    else\n   \
    \     sum_num = sum(numbers)\n        prod_num = prod(numbers)\n        return\
    \ (sum_num, prod_num)\n    end\nend\n</cell>\n<text>\nExercise (5) \nWrite a function\
    \ that returns the sum of a vector of the length of a given vector.\n    When\
    \ given an empty vector, the sum is 0.\n    >>> sum_of_length([])\n    0\n   \
    \ >>> sum_of_length([1, 2, 3, 4])\n    10\n    \"\"\"", "    return sum_product(numbers,\
    \ 0) \nend", "    sum_ = 0\n    prod_ = 1\n    for num in numbers\n        sum_\
    \ = sum_ + num\n        prod_ = prod_ * num\n    return (sum_, prod_)\nend", " \
    \ sum = 0\n  product = 1\n  for number in numbers\n    sum += number\n    product\
    \ *= number\n  end\n  return sum, product\nend\n</cell>\n<text>\nLet's test our\
    \ new sum_product function:", "    sum = 0\n    product = 1\n    for number in\
    \ numbers\n        sum += number\n        product *= number\n    end\n    return\
    \ (sum, product)\nend\n</code>\n<|/ a |>\n<| a dscore=0 tags=julia,python,function,algorithm\
    \ |>\nYou could write something like\n<code>", "    sum_ = numbers[1]\n    prod\
    \ = 1\n    for i in numbers[2:end]\n        sum_ = sum + i\n        prod = prod\
    \ * i\n    end\n    return (sum_, prod)\nend\n</cell>\n<text>\n4.5 Exercise -\
    \ Find an outlier in an array of floats", "    sum_ = 0\n    prod_ = 1\n    for\
    \ x in numbers\n        sum_ += x\n        prod_ *= x\n    return sum_, prod_\n\
    end\n</cell>\n<code language=julia-1.3>\n# Test\nsum_product([0, 3, 8, 1, 5, 9])\n\
    </cell>\n<text>\nExercise 3\nWrite a function that receives a vector and calculates\
    \ the average of the vector (the average is defined as the sum of the numbers\
    \ divided by the number of numbers in the vector). For example: [1, 1, 3] has\
    \ an average of 2 while [1, 2, 3] has an average of 3 (assuming they both have\
    \ 3 elements).", "    sum_ = 0\n    product_ = 1\n    for number in numbers\n\
    \        sum_ += number\n        product_ *= number\n    return (sum_, product_)\n\
    end\n</cell>\n<text>\nExercise 7: Vectorize a function that computes sums and\
    \ products of a list of numbers using broadcasting\nCreate a vectorized function\
    \ that computes the sum and product of all numbers passed to it. The function\
    \ should return a tuple of length two containing the sum and product of the numbers.",
  "    if length(numbers) < 1 \n        return (0, 1)\n    end\n    result = zeros(Int64,\
    \ 2)\n    sum = zero(Int64)\n    product = one(Int64)\n    for n in numbers\n\
    \        sum += n\n        product *= n\n    end\n    result[1] += sum\n    result[2]\
    \ += product\n    result\nend\n</cell>\n<text>\nWe should now have a clearer view\
    \ of the function that calculates the sum and the product of a given vector of\
    \ integers.", "    if isnothing(numbers)\n        return (0,1)\n    else\n   \
    \     (sum,prod) = numbers.reduce(+,0)/(numbers.reduce(+,1))\n        return (sum,\
    \ prod)\n    end\nend", "    sum_, product_ = 0, 0, 1\n    for number in numbers\
    \ do\n        sum_ = sum_ + number\n        product_ = product_ * number\n   \
    \ end\n    return sum_, product_", "    if length(numbers) < 2\n        return\
    \ (0,0)\n    else\n        sum_v = sum(numbers)\n        prod = 1\n        for\
    \ i in numbers\n            prod *= i\n        end\n        return (sum_v,prod)\n\
    \    end\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nOne way to avoid\
    \ the while loop is to use map(). The map function applies a function to every\
    \ element in a list. For this use case we want to multiply each element by the\
    \ product of its position in the list. \nWe could do this like so: map(i -> i[1],\
    \ numbers) which would return [2, 4, 6, 8] and the function would look like this:\
    \ (i -> i[1]) which means \"a function that takes an integer and returns a single\
    \ value\". \nTo multiply all elements in the list by the product of its position\
    \ in the list we can use map() like so: map((i -> i[1]), numbers). This would\
    \ return [2,4,6,8] and the function would look like this: (i -> i[1]) * i. \n\
    Combining these two functions we can get the desired result: map((i -> i[1]) *\
    \ map((i -> i[1]), numbers)). \nThe function call map((i -> i[1]) * map((i ->\
    \ i[1]), numbers)) can be broken down into three parts: map((i -> i[1]), numbers)\
    \ which would return [2, 4, 6, 8], map((i -> i[1]), map(i -> i[1], numbers)) which\
    \ would return [2,4,6,8] and map((i -> i[1]) * map((i -> i[1]), numbers)) which\
    \ would return [2,4,6,8].\n<|/ a tags=recursion,julia,loops |>\n<| a tags=recursion,julia,loops\
    \ dscore=0 |>\nA little late, but still a contribution.\nIf it is only about sum\
    \ and product, the following is quite efficient:\n<code>", "    sum, product =\
    \ 0.0, 1.0\n    for n in numbers\n        sum += n\n        product *= n\n   \
    \ return (sum, product)\nend", "    sum = zero(0)\n    product = one(1)\n    for\
    \ number in numbers\n        sum += number\n        product *= number\n    return\
    \ (sum, product)\nend", "    sum_product = 0\n    product_1 = 0\n    for x in\
    \ numbers\n        sum_product += x\n        product_1 = product_1 * x\n    return\
    \ (sum_product, product_1)\nend\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ sum_product([1,2,3,4,5])\n</cell>\n<text>\nThe sum_product function above is\
    \ easy to use, but it does not always give the same result as the built-in sum\
    \ function, which can sometimes produce different results.", "  if length(numbers)\
    \ == 0 return (0, 1)\n  if length(numbers) == 1 return (numbers[1], 1)\n  if numbers[1]\
    \ == 0 return (0, numbers[1])\n  result = (0,0)\n  for n in numbers\n    result\
    \ += (n, numbers[1]*n)\n  end\n  result\nend", "    if length(numbers) == 0\n\
    \        (0, 0)\n    elseif length(numbers) == 1\n        numbers[0]\n    else\n\
    \        sum_product[numbers[1]] + (numbers[0] * sum_product[numbers[2:end-1]])\n\
    \    end\nend", "  result = (0,1);\n  for i in numbers\n    result.1 = result.1\
    \ + i\n  end\n  return result\nend\n</cell>\n<code language=julia-1.3>\nnumbers\
    \ = [1, 2, 3]\n</cell>\n<code language=julia-1.3>\nsum_product(numbers)\n</cell>\n\
    <code language=julia-1.3>", "    if isnothing(numbers)\n        (0, 0)\n    else\n\
    \        sum(numbers), prod(numbers)\n    end\nend", "    sum_ = 0\n    prod =\
    \ 1\n    \n    for i in numbers, sum_ += i, prod *= i\n    return (sum_, prod)\n\
    end # sum_product()\n</cell>\n<code language=julia-1.5>\n@time sum_product([1,\
    \ 2, 3, 4])\n</cell>\n<text>\nTask 3.3\nWrite a function which takes a vector\
    \ of integers as an argument and returns the sum of squares corresponding to each\
    \ element of the vector. Your function should use the following formula:", " \
    \   # sum of numbers\n    sum::Int64 = 0\n    # product of numbers\n    product::Int64\
    \ = 1\n    for i in numbers\n        sum::Int64 += i\n        product::Int64 *=\
    \ i\n    end\n    return sum, product\nend\n</code>\n<|/ a tags=julia |>\n<| a\
    \ tags=julia dscore=1 |>\nAnother way, based on reducing the problem to a single\
    \ pass over all elements:\n<code>", "    sum = 0 \n    product = 1\n    for n\
    \ in numbers\n        sum += n \n        product *= n\n    return (sum, product)\n\
    end", "    product=1\n    sum=0\n    for n in numbers\n        product*=n\n  \
    \      sum+=n\n    return (sum, product)\nend", "    \n    if len(numbers) ==\
    \ 0\n        return (0, 0)\n    end", "    if length(numbers) == 0 \n        (0,\
    \ 1)\n    else\n        total = 0\n        product = 1\n        for n in numbers\n\
    \            total = total + n\n            product = product * n\n          \
    \  (total, product)\n        end\n    end\nend\n</code>\n<|/ a tags=julia |>\n\
    <| c |>\nCould you add some explanation to your answer to make it more useful\
    \ for future readers?\n<|/ c |>\n<| a dscore=2 |>\nIn short: Use sum and prod.\n\
    The issue is that a tuple comprehension returns (value, value) rather than value;\
    \ this causes Julia to not return the value you intended. \nThe first two lines\
    \ below are equivalent and return the correct values:\n<code>\n[(a + b) for a\
    \ in 1:5 for b in 1:5]\n(a + b) for a in 1:5 for b in 1:5\n</code>\nThe next two\
    \ lines return incorrect values (i.e. a is repeated twice):\n<code>\n[(a + b)\
    \ for a in 1:5 for b in 1:5]\n[(a + b) for b in 1:5 for a in 1:5]\n</code>\nYou\
    \ can see the issues more clearly if you use the following code to generate these\
    \ tuples:\n<code>\n[(a + b) for a in 1:5 for b in 1:5]\n[(a + b) for b in 1:5\
    \ for a in 1:5]\n</code>\nNote how the second set of tuples are identical to the\
    \ first, except for the order of the terms in the for loops.\nI believe this was\
    \ a bug in Julia's tuples implementation, but was fixed in https://github.com/JuliaLang/julia/commit/9c1eccad0c26cfe886ced805adfdf91e730a22bc.\n\
    <|/ a tags=julia |>\n<| a dscore=1 |>\nA more efficient way is to use map, which\
    \ will return a Vector and you can easily apply the sum operation on it.\n<|/\
    \ a tags=julia |>\n<| a tags=julia |>\nI believe that it is because tuples are\
    \ immutable, so when you do a+b where a is in a for loop it just creates a new\
    \ variable a and b and updates the old tuple with the new ones.\n<|/ a dscore=0\
    \ |>\n<| a tags=julia |>\nI believe that this is because tuples are immutable\
    \ (they can't be changed), so when you do a+b where a is in a for loop it just\
    \ creates a new variable a and b and updates the old tuple with the new ones.\
    \ In your case it just does a += b and discards the old a and b.\n<|/ a dscore=0\
    \ |>\n<| a |>\nYou can use the following code:\n<code>\nusing Statistic", "  \
    \  sum_product = (0,1)\n    for element in numbers do\n        sum_product = sum_product\
    \ + (element,element)\n    end\n    return sum_product\nend\n</code>\n<|/ a tags=julia,arrays\
    \ dscore=1 |>\n<| a dscore=0 |>\nHere is another approach which is slightly shorter\
    \ and easier to read:\n<code>", "    # write your code here\n    return 0, 0",
  "    if length(numbers)==0 then return (0,0) end\n    sum_product = numbers[1]\n\
    \    product = 1\n    for number in numbers[2:end] \n        sum_product+=number\n\
    \        product*=number\n    end\n    return (sum_product, product)\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nIt would be helpful to describe why this should work.\n\
    <|/ c |>\n<| a |>\nIn Julia we can use map() which basically applies a function\
    \ to each element of an array.\n<code>", "    if length(none(numbers)) == 0 \n\
    \        (0, 1) \n    else \n        sum(numbers)*prod(numbers)\nend\n</cell>\n\
    <text>\nQuestion 3. What is the result of running this function?", "    if length(numbers)\
    \ == 0 \n        return (0, 1)\n    else if length(numbers) == 1 \n        return\
    \ (numbers[0], numbers[0])\n    else\n        sum_1, sum_2 = sum_product(numbers[2:end-1])\n\
    \        prod, mul = sum_product(numbers[1:end-1])\n        return (mul*prod,\
    \ sum_1+mul*sum_2)\n    end\nend\n</cell>\n<cell>\nsum_product([1, 2, 3, 4])\n\
    </cell>\n<text>\nSum all integers in a vector", "    if length(numbers) == 0 \n\
    \        (1, 0)\n    elseif length(numbers) == 1 \n        (numbers[1], numbers[1])\n\
    \    else\n        numbers[1] * sum_product(numbers[2:end]) \n    end\nend", " \
    \   if length(numbers) == 0 then \n        return (0, 0), 1\n    else \n     \
    \   sum, prod = 0, 0\n        for el in numbers:\n            sum += el\n    \
    \        prod *= el\n        return (sum, prod)\n    end\nend\n</cell>\n<code\
    \ language=julia-1.0>\nsum_product([1, 2, 3, 4])\n</cell>\n<text>\n4.4.4 Vectorization\n\
    Vectorization helps us speed up the computation by exploiting the fact that many\
    \ operations can be done using built-in functions (such as +, -, *, /, %, etc.).\
    \ So instead of looping to add all the elements of a vector, we let Julia do that\
    \ for us and apply that function to all the elements of a vector. There are two\
    \ methods for vectorization:", "  if length(numbers) == 0 \n    return (0,1) \n\
    \  else \n    sum_product = numbers[1] * numbers[end]\n    sum_product += sum_product(numbers[2:end])\
    \ + numbers[1]\n    return (sum_product, sum_product * numbers[1])\nend\n</code>\n\
    <|/ a dscore=1 tags=algorithm,combinatorics,dynamic-programming,julia |>\n<| c\
    \ |>\nThis code works, but it takes too long for bigger vectors. I solved it by\
    \ using recursive functions with memoization, which runs about the same time,\
    \ but is much faster.\n<|/ c |>\n<| a dscore=0 |>\nHere's a simple recursive Julia\
    \ solution.\n<code>", "    if numbers.size == 0 \n        (0, 1) \n    else\n\
    \        result = numbers.reduce((x, y) -> x + y)\n        (result, numbers.product)\n\
    \    end\nend\n</code>\nAs a final note, you may want to use types that are more\
    \ appropriate for the data you're working with; for example in this case, you\
    \ can use the Int type.\n<|/ a |>\n<| a tags=julia |>\nIf you're looking for an\
    \ idiomatic solution, consider using sum and prod functions from StatsBase.jl\
    \ package (these are both imported into Base.).\n<code>\nusing StatsBase", " \
    \   return (numbers.sum(), numbers.product())\nend", "    sum = product = 1\n\
    \    \n    for i in numbers\n        sum += i\n        product *= i\n    end\n\
    \    return sum, product\nend", "        sum = product = 0\n        for n in numbers\n\
    \            sum += n\n            product *= n\n        return sum, product\n\
    end", "    sum, product = 0, 1\n    for n in numbers\n        sum = sum + n\n\
    \        product = product * n\n    return (sum, product)\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert sum_product([1, 2, 3, 4]) == (10, 24)\n@assert\
    \ sum_product([-2, 0, 2, -1]) == (0, -2)\n@assert sum_product([2, -1, 1, 0]) ==\
    \ (2, -3)\n</cell>\n<text>\nExercise 14: Define a function, product, that multiplies\
    \ all the numbers in a vector by 2. \nFor example, product([1, 2, 3, 4]) should\
    \ return [4, 6, 8, 10].\nThis function should not modify the given vector.", " \
    \   return (nsum(numbers), nprod(numbers))\nend\n</cell>\n<cell>\n@assert sum_product([1,\
    \ 2, 3, 4]) == (10, 24)\n@assert sum_product([5]) == (5, 1)\n</cell>\n<text>\n\
    Exercise: Write a function that returns the number of integers in a list of integers.\n\
    \    >>> count_numbers([1, 2, 3, 4, 5])\n    4\n    \"\"\"", "    if numbers.size\
    \ <= 0\n        (0, 1)\n    else\n        sum_ = numbers[1]\n        product_\
    \ = 1\n        for i in 2...numbers.size\n            sum_ = numbers[i] + sum_\n\
    \            product_ = numbers[i] * product_\n        end\n        return (sum_,\
    \ product_)\n    end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for your\
    \ answer, but I think you forgot the `end` after `else`. Am I right? Also, it\
    \ would be nice if you could give some hints about why your code works the way\
    \ it does.\n<|/ c |>\n<| a dscore=1 |>\nI'm posting a new answer because my previous\
    \ one was too long and confusing to understand.  I think it's much easier to understand\
    \ now.\n<code>", "    # Base case\n    if length (numbers) == 0\n        return\
    \ (0,1)\n    \n    # Recursive case\n    sum, prod = 0, 0\n    for i in numbers\n\
    \        sum = sum + i\n        prod = prod * i\n    end\n    return sum, prod\n\
    end", "    if is_empty(numbers)\n        return (0, 1) \n    end\n    sum = numbers[1]\n\
    \    for i in 2:length(numbers)\n        sum += numbers[i]\n    end\n    return\
    \ (sum, product)\nend\n</cell>\n<code language=julia-1.5>\n@code_warntype sum_product([])\n\
    </cell>\n<text>\nExercise 11\nDefine the function true_division, which accepts\
    \ a vector of integers, returns the sum of the elements of the vector, but with\
    \ each element divided by 2.\nHint: use function true_division defined in section\
    \ 10.1.", "    sum = 0\n    product = 1\n    for n in numbers\n        sum +=\
    \ n\n        product *= n\n    return sum, product\nend\n</cell>\n<code language=julia-0.6>\n\
    sum_product([1, 2, 3, 4])\n</cell>\n<text>\nThe last line of the function sum_product\
    \ can be made much more concise using @inbounds macro introduced in version 0.5.0:",
  "    if length(numbers) == 0\n        (1, 1)\n    elseif length(numbers) == 1\n\
    \        (numbers[0], numbers[0])\n    else\n        (x::Int64, n::Int64) =\n\
    \            if x % n == 0\n                (x, n*x)\n            else\n     \
    \           (n*x, x)\n            end\n            \n        (sum(numbers), prod(numbers))\n\
    \    end\nend\n</cell>\n<text>\nTask 1\nWrite a function which takes in a vector\
    \ as a parameter and returns the pairwise product of all the vectors in the vector.",
  "    if length(numbers) == 0 \n        return (0,1) \n    else \n        return\
    \ (numbers[1] + numbers[end], numbers[1]*numbers[end]) \nend", "\"\"\"\nReturn\
    \ a tuple of two values, consisting of a sum and a product of all the integers\
    \ in a vector. The first value represents the sum of the numbers in the vector\
    \ and the second value represents the product of the numbers in the vector. \n\
    The sum of the numbers should be equal to 0 and product of numbers should be equal\
    \ to 1.\nThis function should be used only for vectors of integers because otherwise\
    \ we may get a type error. \n\"\"\"", "    if length(numbers) < 2\n        return\
    \ (0, 0)\n    sum = 0\n    product = 1\n    for num in numbers\n        sum =\
    \ sum + num\n        product = product * num\n    end\n    return (sum, product)\n\
    end\n</cell>\n<code language=julia-1.6>\n@assert sum_product([1,2,3,4]) == (10,\
    \ 24)\n@assert sum_product([1,2]) == (0,0)\n</cell>\n<text>\nWe can also easily\
    \ define an inverse function. Recall that $ \\int_a^b f(x) dx \\approx \\int_{-f}^b\
    \ f(x) dx $ for some $f$. Since we already defined the sum function and the product\
    \ function, we can simply call them in the definition of $ \\int_a^b f(x) dx $.\
    \ Here is an example with $ \\int_0^1 f(x) dx $:", "    return numbers, sum_product(numbers)\n\
    end\n</cell>\n<code language=julia-1.0>\nsum_product([1, 2, 3, 4])\n</cell>\n\
    <text>\nWrite a function to compute the cumulative product of a given vector of\
    \ integers. If the vector is empty, return the tuple (0, 0). Otherwise, return\
    \ a tuple consisting of the cumulative product and the cumulative sum of the vector.\n\
    For example, cumulative_product([2, 3, 1, 4]) should return the tuple (24, 22).",
  "    if numbers == [] \n        return (0, 1)\n    \n    sum_ = numbers[1]\n   \
    \ product = 1\n    for i in numbers[2:length(numbers)]\n        product *= i\n\
    \        sum_ += i\n    return (sum_, product)\nend\n</cell>\n<code language=julia-1.0>\n\
    @assert sum_product([]) == (0, 1)\n@assert sum_product([1, 2, 3]) == (3, 6)\n\
    </cell>\n<text>\nNotice: This code is a bit messy and could be made a bit more\
    \ concise (without the use of mutable variables).", "    sum_ = sum(numbers)\n\
    \    product_ = product(x->numbers[x], 1:length(numbers))\n    return sum_, product_\n\
    end\n</code>\n<|/ a |>\n<| a |>\nAnother way to achieve this is to define functional\
    \ macro which will expand each array argument to a tuple of sum and product and\
    \ then define function which will call above macro.\n<code>", "    if (length(numbers)==0)\
    \ then (0,1) else\n        suma = 0\n        prod=1\n        for i in numbers:\n\
    \            suma = suma + i\n        prod=prod * suma\n        return (suma,prod)\n\
    \    end\nend", "    sum_ = 0\n    product_ = 1\n    for i in numbers\n      \
    \  sum_ += i\n        product_ *= i\n    return (sum_, product_)\nend\n</cell>\n\
    <cell>\nsum_product(ones(2))\n</cell>\n<text>\nExercise: Find all the factors\
    \ of a number\nExercise: Find all the prime factors of a number", "    if length(numbers)\
    \ == 0\n        return 0, 0\n    sum = 0\n    product = 1\n    for num in numbers\n\
    \        sum = sum + num\n        product = product * num\n    end\n    return\
    \ (sum, product)\nend\n</code>\nFor your problem this can be optimized. We only\
    \ need to loop through the numbers once:\n<code>", "    sum = Int64(0)\n    prod\
    \ = Int64(1)\n    for v in numbers do\n        sum += v\n        prod *= v\n \
    \   end\n    return (sum, prod)\nend", "    if (length(numbers) == 0) then\n \
    \       (0, 1);\n    else\n        sum_product_helper(numbers)\n    end\nend",
  "    return (\n        sum(numbers),\n        reduce(mul, numbers, 1))\nend\n</cell>\n\
    <code language=julia-1.6>\nsum_product(numbers)\n</cell>\n<text>\n\u25CF Find\
    \ the most frequent number\nAt the very least you need to find which element appears\
    \ the most often. You can use count for this:", "    \"\"\"\n    Compute sum of\
    \ vector and product of vector elements\n    \"\"\"\n    sum_product = sum(numbers)\n\
    \    product_of_numbers = prod(numbers)\n    return (sum_product, product_of_numbers)",
  "   \n    sum = 0\n    product = 1\n    for num in numbers\n        sum = sum +\
    \ num\n        product = product * num\n    return (sum, product)\nend\n</cell>\n\
    <text>\nReturning a dictionary from a function", "    if length(numbers) == 0\
    \ \n        (0, 1) \n    else \n        sum = numbers[1]\n        product = 1\n\
    \        for n in numbers[2:end]\n            sum += n\n            product *=\
    \ n\n            (sum, product)\n        end\n    end\nend\n</cell>\n<text>\n\
    Exercise 2", "    \"\"\"\n    Calculate the sum of the integers inside the given\
    \ vector.\n    Empty sum should be equal to 0 and empty product should be equal\
    \ to 1.\n    \"\"\"\n    return sum( numbers ), prod( numbers )", "    # Your\
    \ code here\n    if numbers == []\n        return 0, 0\n    end\n    sum_ = 0\n\
    \    product_ = 1\n    for i in numbers\n        sum_ = sum_ + i\n    end\n  \
    \  for i in numbers\n        product_ = product_ * i\n    end\n    return sum_,\
    \ product_\nend\n</cell>\n<text>\nExercise 2.3\nWrite a function that takes a\
    \ vector and returns a new vector, with the values replaced by their squares.\n\
    For example, [1, 4, 9, 16] \u2192 [4, 16, 64, 256]\nHint: You can use the function\
    \ fill! to help you write this.\n(Hint: You may want to use mapslices)", "   \
    \ if length(numbers) < 2 \n        (0, 1) \n    else \n        sum(a * b for (a,b)\
    \ in zip(numbers, tail(numbers))), (prod(numbers),)\nend\n</code>\n<|/ a tags=julia\
    \ dscore=0 |>\n<| a |>\nI agree with the answer from Yaroslav. Here is an alternative\
    \ that may be more efficient:\n<code>\njulia> using Statistics", "    if length(numbers)\
    \ == 0 then\n        return (0, 1)\n    else\n        sum = 0\n        product\
    \ = 1\n        for i in numbers\n            sum = sum + i\n            product\
    \ = product * i\n        end\n        return (sum, product)\n    end\nend\n</cell>\n\
    <text>\nExercise 8\nWrite a function that checks if all the numbers in a given\
    \ vector satisfy the following condition:", "    if numbers == [] \n        return\
    \ (0,1)\n    else \n        return (sum(numbers), prod(numbers))", "    sum =\
    \ 0\n    product = 1\n    for i in numbers\n        sum += i\n        product\
    \ *= i\n    return sum, product\nend\n</cell>\n<code language=julia-1.5>\n@test\
    \ sum_product([1,2,3]) == (0, 3)\n@test sum_product([1,2,3,4]) == (10, 120)\n\
    </cell>\n<text>\nChallenge 2.3 Write a function called mean that computes the\
    \ mean of a vector of numbers.\n    >>> mean([1,2,3,4,5])\n    3\n    >>> mean([1,4,5,7,9])\n\
    \    5.5\n    \"\"\"", "    sum_product = sum(numbers)\n    product_product =\
    \ 1\n    for n in numbers\n        product_product *= n\n    end\n    return sum_product,\
    \ product_product\nend\n</cell>\n<code language=julia-1.4>\nusing BenchmarkTools",
  "    # initialize variables\n    sum::Int64 = 0\n    product::Int64 = 1\n    for\
    \ i in numbers\n        sum = sum + i\n        product = product * i\n    end\n\
    \    return (sum, product)\nend ", "  if length(numbers) <= 0\n    return (0,\
    \ 0) \n  else\n    sum = 0\n    product = 1\n    for n in numbers\n      sum +=\
    \ n\n      product *= n\n    return (sum, product)\n  end\nend\n</cell>\n<text>\n\
    Problem 6: Write a function that takes in a vector of integers and returns true\
    \ if the sum of the integers in the vector is equal to the sum of the factorial\
    \ of the integers in the vector.\n For example, the function should return true\
    \ for [1,2,3,4,5,6,7,8] and false for [1,2,3,4].", "    \n    if length(numbers)==0\n\
    \        return (0, 1) \n    end\n    \n    sum_product =  sum(numbers)\n    sum_product2\
    \ =  prod(numbers)\n    return (sum_product, sum_product2)\nend", "    if length(numbers)\
    \ == 0 \n        return (0,1) \n    end\n    \n    sum_ = numbers[1]\n    for\
    \ number in numbers[2:end] \n        sum_ += number\n    end\n    \n    product_\
    \ = 1\n    for number in numbers[2:end] \n        product_ *= number\n    end\n\
    \    \n    return (sum_, product_)\nend\n</cell>\n<code language=julia-1.5>\n\
    # Test sum_product function\nsum_product([1,2,3])\n</cell>\n<text>\nProblem 7.\
    \ Write a function to check whether a binary tree is height balanced or not.",
  "    if len(numbers) == 0\n        (0, 1)\n    else\n        (nsum::Int64, nprod::Int64)\
    \ = numbers[1], prod(numbers[2:end])\n        (append(nsum, nprod), nsum*nprod)\n\
    \    end\nend\n</cell>\n<text>\nExercise 3: Compute the covariance and the correlation\
    \ coefficient between each pair of columns in a matrix\nWrite a function cov_corr(A,\
    \ i, j) which returns the covariance and correlation coefficient between column\
    \ i and column j of matrix A. Your function should work with matrices of any size,\
    \ with or without missing values. Missing values should be ignored.", '    return
    (sum(numbers), prod(numbers))', "    if numbers == [] \n        (0, 1) \n    else\
    \ \n        sum_product_rec(numbers, 0, 1) \n    end\nend", "    if length(numbers)\
    \ == 0\n        return (0, 1) \n    \n    sum_ = 0\n    prod = 1 \n    for number\
    \ in numbers \n        sum_ += number \n        prod *= number \n    return (sum_,\
    \ prod) \nend ", "  if length(numbers) == 0\n  elseif length(numbers) == 1\n \
    \   (numbers[0], numbers[0])\n  else\n    sum_product(numbers[1:], numbers[0]*numbers[1])\n\
    \  end\nend\n</cell>\n<code language=julia-0.6>\n@testset \"sum-product tests\"\
    \ begin", "    sum_, product_ =  0, 0\n    for n in numbers\n        sum_ += n\n\
    \        product_ *= n\n    return sum_, product_\nend\n</cell>\n<cell>\nsum_product([1,2,3,4,5])\n\
    </cell>\n<text>\nExercise 4\nWrite a function to return the factorial of a given\
    \ integer using recursion. You may want to use the fact that integer division\
    \ truncates towards 0 in python.", "    sum_ = 0\n    prod_ = 1\n    for i in\
    \ numbers\n        sum_ += i\n        prod_ *= i\n    return (sum_, prod_)\nend\n\
    </cell>\n<cell>\n\"\"\"\n    sum_product_complex(numbers::Vector{Int64})::Tuple{Complex{Int64},\
    \ Complex{Int64}}\n    \n    For a given vector of integers, return a tuple consisting\
    \ of a sum and a product of all the integers in a vector.\n    Empty sum should\
    \ be equal to 0 and empty product should be equal to 1.\n    >>> sum_product_complex([])\n\
    \    (0.0, 1.0)\n    >>> sum_product_complex([1, 2, 3, 4])\n    (10+2im*7+3im*5j,\
    \ 6+4im*2j)\n    \"\"\"", "    if length(numbers) == 0\n        return (0, 1)\
    \ \n    else\n        sum_ = sum(numbers)\n        product_ = reduce(mul, numbers,\
    \ 1)\n        return (sum_, product_)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert sum_product([1,2,3]) == (6, 3)\n@assert sum_product([1,2,3]) == (6, 3)\n\
    </cell>\n<text>\nNow let's look at a more efficient implementation (without mutating\
    \ the original vector). We'll use the higher-order function map, to \"map\" over\
    \ the vector numbers, and perform the two operations above.", "    sum_, prod_\
    \ = sum(numbers), prod(numbers)\n    return sum_, prod_\nend \n</code>\n<|/ a\
    \ tags=julia,vector,function,for-loop dscore=3 |>\n<| c |>\nThanks for sharing\
    \ this! I learned a lot from it.\n<|/ c |>\n<| c |>\nThis is great, but I'd like\
    \ to see an example of how it would look in the context of a for loop. The OP\
    \ has stated that they are new to Julia, and therefore I'd like to see how they\
    \ would implement this in Julia. This may help future users. I have upvoted your\
    \ answer :)\n<|/ c |>\n<| a |>\n<code>", "    if length(numbers) == 0 \n     \
    \   return (0,1) \n    \n    sum = 0 \n    product = 1 \n    for i in numbers\
    \ \n        sum = sum + i \n        product = product * i \n    return (sum, product)\
    \ \nend", "    if length(numbers) == 0 then {0, 0} else\n    sum_product = numbers.reduce((x,\
    \ y) -> x + y)\n    sum_product_prod = 1\n    numbers.reduce(product -> product\
    \ * sum_product_prod)\nend\n</code>\n<|/ a dscore=0 tags=julia |>\n<| c |>\nThis\
    \ solution requires `Base`. You might want to use `reduce(+, numbers)` instead.\
    \ `reduce` is an alias for `reduceat`, which is not available in every version.\
    \ `reduceat` has been available since Julia 0.6, while `reduce(+, numbers)` has\
    \ been available since Julia 0.7 (released in 2015).\n<|/ c |>\n<| c |>\nApologies,\
    \ I forgot that you need Base. As far as I know, I haven't found a version without\
    \ Base.\n<|/ c |>\n<| a dscore=0 tags=julia |>\nIn case you are looking for something\
    \ more succinct:\n<code>\nsum_and_product(v) = sum(v), prod(v)\n</code>\nExample\n\
    <code>\njulia> sum_and_product([1,2,3,4])\n(4,2)", "    if len(numbers) == 0\n\
    \        return 0, 0\n    end\n    sum = 0\n    product = 1\n    for i in numbers\n\
    \        sum += i\n        product *= i\n    end\n    return sum, product\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert sum_product([0, 1, 2]) == 10\n@assert\
    \ sum_product([1, 2, 3]) == 6\n@assert sum_product([-1, 1]) == -1\n@assert sum_product([2,\
    \ -3]) == 5\n</cell>\n<text>\nNow let's write a function that will calculate the\
    \ average of all the integers in a vector. We'll first check to make sure that\
    \ it is defined (that is, if it is empty then it will raise an error).", "   \n\
    \    return (0, 1) * sum( numbers )\nend \n</cell>\n<code language=julia-1.5>\n\
    sum_product([2, 4])\n</cell>\n<code language=julia-1.5>", '    return (sum(numbers),
    prod(numbers))']
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
