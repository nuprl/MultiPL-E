name: HumanEval_83_starts_one_ends
language: jl
prompt: "\"\"\"\n    Given a positive integer n, return the count of the numbers of\
  \ n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nfunction\
  \ starts_one_ends(n::Int64)::Int64 \n"
tests: "using Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1)\
  \ == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4)\
  \ == 1800)\n\t@test(candidate(5) == 18000)\nend\n"
completions: ["\"\"\"\n    count of numbers that start with 1 \n\"\"\"", "\tcount\
    \ = 0\n    for x in (1:n) do if x == 1 then count = count + 1 end\n    return\
    \ count\nend\n</cell>\n<code language=julia-1.6>\n#export", "    if n==0 \n  \
    \      then return 0 \n    else \n        x := 0\n        while x<n \n       \
    \     do x += 1\n                if x % 10 == 1 \n                    then return\
    \ 1\n                end\n            end\n    end\nend", "    count = 0\n   \
    \ while n > 0 do\n        if n%10 == 1 then count += 1\n        n /= 10\n    end\n\
    \    return count\nend\n\"\"\"\n Count the number of positive integers that are\
    \ divisible by 3\n\"\"\"", "    if n==1\n        1\n    else\n        n - count_ones(n\
    \ - 1)\nend", "  \n\"\"\"\n    Given a positive integer n, return the count of\
    \ the numbers of n-digit\n    positive integers that start with 10.\n    \"\"\"",
  "    if n == 0 || n == 1 then 1 else 0 end\nend\n</cell>\n<cell>\n@code_warntype\
    \ starts_one_ends(10)\n</cell>\n<text>\nWrite a function that prints the digits\
    \ of a number in a new line.\nThe number should be passed as an argument to the\
    \ function.", "    if n==1 then 1 else 0\nend\n\"\"\"\n# Now let's test our function...",
  "    if n < 100\n        return n\n    if n%10 == 1 && n!=10\n        return starts_one_ends(n//10)\n\
    \    return starts_one_ends(n-1)\nend\n</cell>\n<code language=julia-1.6>\nstarts_one_ends(1234567890)\n\
    </cell>\n<code language=julia-1.6>\n@code_native starts_one_ends(1234567890)\n\
    </cell>\n<text>\nWe see that there exist a significant number of $n$ such numbers\
    \ that start or end with 1.", "    if n < 0 \n        error(\"n must be a positive\
    \ integer\")\n    end = 1\n    start = 0\n    while start < n \n        start\
    \ += 1\n        if starts_one_ends(start) == 1 \n            end += 1\n      \
    \  end\n    end\n    return end\nend\n</cell>\n<text>\nProblem 3.20\nWrite a function\
    \ one_end_digits(n::Int64) which returns the number of 1-digit\n    positive integers\
    \ up to and including n.\n    For example, one_end_digits(15) should return 3,\
    \ because there are three 1-digit\n    positive integers that start or end with\
    \ 1.\n    \"\"\"", "    return n >= 2 ? n*(starts_one_ends(n-1) + ends_one_starts(n-1))\
    \ : 0\nend\n</cell>\n<code language=julia-0.6>\n\"\"\"\n    Given a positive integer\
    \ n, return the count of the numbers of n-digit\n    positive integers that start\
    \ or end with 0.\n    \"\"\"", "    count = 0\n    if n < 10 \n        count =\
    \ 1\n    else \n        if ((n%10) == 1)\n            count += 1\n        else\
    \ if ((n%10) == 0)\n            count = 0\n        else \n            return count\
    \ + starts_one_ends(n//10)\n    return count", "    if n <= 0 \n    then return\
    \ 0\n    else return (n - 1) * ((starts_one_ends(n / 10) * 10) + n % 10)\nend\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype starts_one_ends(100)\n</cell>\n\
    <code language=julia-1.5>\n@code_warntype starts_one_ends(987)\n</cell>\n<code\
    \ language=julia-1.5>\n@code_warntype starts_one_ends(9876)\n</cell>\n<text>\n\
    The idea for the recursive formula (above) is to think about dividing up 10 and\
    \ finding the number of divisors of the first 10 numbers in that partition.  For\
    \ a partition of 9, we would have 5 numbers, so the number of divisors of the\
    \ first 9 numbers in that partition would be 5.  For a partition of 10, we would\
    \ have 3 numbers, so the number of divisors of the first 10 numbers in that partition\
    \ would be 3.  And so on for the rest of the partitions.  A partition of n is\
    \ found by starting at the first 9 numbers and dividing each one in turn until\
    \ we reach the partition size n.  Then we sum all of the divisors of the first\
    \ partition.", "    if n == 0 \n        then return 1\n    else if n == 1 \n \
    \       then return 0\n    else \n        let z = n - 1\n        if z <= 0 \n\
    \            then return 0\n        else if z == 0 \n            then return 1\n\
    \        else \n            let z = n - 2\n            if z > 0 \n           \
    \     then return starts_one_ends(z) + starts_one_ends(z)\n            else \n\
    \                let z = n - 2\n                if z > 0 \n                  \
    \  then return starts_one_ends(z) + 1\n                else \n               \
    \     let z = n - 1\n                    if z > 0 \n                        then\
    \ return starts_one_ends(z) + starts_one_ends(z)\n                    else \n\
    \                        let z = n - 2\n                        if z > 0 \n  \
    \                          then return starts_one_ends(z) + starts_one_ends(z)\
    \ + 1\n                        else \n                            let z = n -\
    \ 3\n                            if z > 0 \n                                then\
    \ return starts_one_ends(z) + starts_one_ends(z) + starts_one_ends(z) + 1\n  \
    \                          else \n                                let z = n -\
    \ 4\n                                if z > 0 \n                             \
    \       then return starts_one_ends(z) + starts_one_ends(z) + starts_one_ends(z)\
    \ + starts_one_ends(z) + starts_one_ends(z) + 1\n                            \
    \    else \n                                    let z = n - 5\n              \
    \                      if z > 0 \n                                        then\
    \ return starts_one_ends(z) + starts_one_ends(z) + starts_one_ends(z) + starts_one_ends(z)\
    \ + starts_one_ends(z) + starts_one_ends(z) + starts_one_ends(z) + 1\n       \
    \                             else \n                                        let\
    \ z = n - 6\n                                        if z > 0 \n             \
    \                               then return starts_one_ends(z) + starts_one_ends(z)\
    \ + starts_one_ends(z) + starts_one_ends(z) + starts_one_ends(z) + starts_one_ends(z)\
    \ + starts_one_ends(z) + starts_one_ends(z) + 1\n                            \
    \            else \n                                            let z = n - 7\n\
    \                                            if z > 0 \n                     \
    \                           then return starts_one_ends(z) + starts_one_ends(z)\
    \ + starts_one_ends(z) + starts_one_ends(z) + starts_one_ends(z) + starts_one_ends(z)\
    \ + starts_one_ends(z) + starts_one_ends(z) + starts_one_ends(z) + starts_one_ends(z)\
    \ + starts_one_ends(z) + starts_one_ends(z) + 1\n                            \
    \                else \n                                                let z\
    \ = n - 8\n                                ", "    if n<1 \n        return 0 \n\
    \    elseif n==1 \n        return 1 \n    else \n        count := 1 \n       \
    \ m := n \n        i := 1 \n        j := 0 \n        while i <= m \n        do\
    \ \n            if n%i == 0 \n            then \n                count += 1 \n\
    \                m /= i \n            else \n                j := i  \n      \
    \      end  \n            i = i+1 \n            if j >= m \n            then \n\
    \                count += 1 \n            end  \n        end  \n        return\
    \ count  \n    end  \nend  \n</code>\n<|/ a tags=algorithm,time-complexity,big-o\
    \ |>\n<| a |>\nThere are many ways to count the numbers of integers that start\
    \ with 1, and many ways to count the numbers of integers that end with 1. I wrote\
    \ a code of O(n) time complexity to count the numbers of integers that start or\
    \ end with 1. You can check the code.\n<code>\ncount = 0\nfor i = 1..n do\n  \
    \  if n%i==0\n        count = count+1\n    elseif i==1\n        count = count+1\n\
    \    else\n        break\n    end\nend\nreturn count\n</code>\n<|/ a tags=algorithm,time-complexity,big-o\
    \ dscore=0 |>\n<| a dscore=0 |>\nThe algorithm is very simple. We can implement\
    \ it by using the concept of factorial. \nFirst we take n-1 numbers. \nNow we\
    \ take factorial(n-1) and find its product. \nNow take factorial(n-2) and find\
    \ its product. \nand so on till \n<code>\nfactorial(1) = 1.\n</code>\nNow take\
    \ factorial(1) again, and find its product. \nThis will give you the answer. \n\
    The algorithm is of O(n).\n<|/ a tags=algorithm,time-complexity,big-o |>\n<| c\
    \ |>\nI don't see how this answers the question.\n<|/ c |>\n<| c |>\nIt is the\
    \ answer to the question. It just shows how to find nth number of occurrences\
    \ of a number in a given list. The solution has already been given in the comments.\n\
    <|/ c |>\n<| c |>\nThe question is about big-O.\n<|/ c |>\n<| a dscore=0 tags=algorithm,time-complexity,big-o\
    \ |>\nHere are some solutions I came up with in Ruby. One solution is using recursion\
    \ but another solution I came up with is using a loop. \nA more efficient way\
    \ that has O(n) complexity is to use recursion and memoization. \nHere's a recursive\
    \ solution: \n<code>\n", "    if n == 1\n        return 1 # \n    i = 2\n    count\
    \ = 1\n    while i <= sqrt(n) \n        if ((n % i) == 1) || ((n % i) == 0)\n\
    \            count += 1\n        end\n        i += 1\n    end\n    return count\n\
    end\n\"\"\"\nThe function `ends` finds the number of positive integers\nthat end\
    \ with 1.", "    if (n==1) return 1 \n    else return sum((starts_one_ends((n-1))))\n\
    end\n</code>\n<|/ a tags=recursion,algorithm,ruby,haskell |>\n<| a dscore=0 |>\n\
    The answers so far have done a lot of unnecessary work.  They seem to do so by\
    \ doing a lot of work they don't really need.  For example, the sum function is\
    \ actually a special case of sum, which can do away with the need to implement\
    \ it yourself:\n<code>\nsum = (+) 0\n</code>\nSo now we can focus on what you\
    \ want to do:", "    if n == 0 \n        return 0 \n    else \n        return\
    \ 1 + starts_one_ends(n - 1)\n</code>\n<|/ a |>\n<| a tags=recursion,haskell |>\n\
    I like Kylian Moprey's answer but I think you can also do this with foldr. \n\
    <code>\ncount_nth_set :: Int -> Int -> [Int] -> Int\ncount_nth_set n k xs = foldr\
    \ f 0 xs\n    where f x y | x == y = k\n                  | x > y = y + 1\n  \
    \                | otherwise = y + 1\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0\
    \ |>\n<code>\nimport Data.List", "  count::Int64 = 0\n  for i from (1 to n step\
    \ 1)\n    if i%10 == 1\n      count += 1\n  return count\nend", "    if n <= 0\n\
    \        return 0\n    ends_one_count = 0\n    starts_one_count = 0\n    if n\
    \ == 0\n        return 0\n    for i = 1:n\n        if i^(1) == i\n           \
    \ starts_one_count = starts_one_count + 1\n        else\n            ends_one_count\
    \ = ends_one_count + 1\n        end\n    end\n    return starts_one_count + ends_one_count\n\
    end\n</cell>\n<code language=julia-0.6>\n\"\"\"\n    Given a positive integer\
    \ n, return the count of the numbers of n-digit\n    positive integers that start\
    \ or end with 2.\n    \"\"\"", "    total = 0 \n    for i in 1:n\n        if i\
    \ == 1 || i%3 == 0\n            total += 1 \n        end\n    end\n    return\
    \ total \nend\n</cell>\n<text>\nExercise 10\nRewrite the previous function using\
    \ map and sum", "    if n < 100\n        1\n    else\n        length(all_digits(n)[1..floor(Int64(n/10)))+1]\n\
    end\n\"\"\"\n    Find the sum of all the multiples of 3 or 5 below 1000.\n   \
    \ \"\"\"", "    if n<0\n    then -1\n    else\n        for x in 1..n\n       \
    \ if (x-1)%9 == 0\n        then return x\n        end if\n        end for\n  \
    \      return 0\n    end if\nend function", "    if n == 1 \n        return 1\
    \ \n    else \n        return 1 + starts_one_ends(n - 1) \nend\n    \n\"\"\"\n\
    \    Given a positive integer n, return the count of the numbers of n-digit\n\
    \    positive integers that start with 1.\n    \"\"\"", "    if n == 0 \n    \
    \    0\n    else \n        if n % 10 == 1\n            1 + starts_one_ends(n /\
    \ 10)\n        else\n            starts_one_ends(n / 10)\n        end\nend\n</cell>\n\
    <text>\nPutting all the pieces together\nNow that we have defined our helper functions,\
    \ we can define our main function which takes a positive integer n and returns\
    \ the count of all positive integers less than or equal to n (inclusive) that\
    \ start or end with 1.", "    if n < 10 \n        then return n \n    else \n\
    \        if n == 0 \n            then return 1 \n        else \n            local\
    \ digits = n % 10\n            n = n / 10\n            return starts_one_ends(digits)\
    \ + starts_one_ends(n)\n        end\n    end\nend\n</code>\nNow we can get the\
    \ counts of the numbers that start or end with 1.  To do this, we need to figure\
    \ out how to enumerate all of the numbers from 1 through n.  We can do this by\
    \ starting with 1, incrementing the number from 1 until n doesn't equal 1, then\
    \ subtracting 1.  Here's a solution using recursion:\n<code>", "    \"\"\"\n \
    \   Given a positive integer n, return the count of the numbers of n-digit\n \
    \   positive integers that start or end with 1.\n    \"\"\"", "    if n < 2\n\
    \    then return 1\n    else if n == 2\n    then return 1\n    else return starts_one_ends(n\
    \ - 1) + starts_one_ends(n - 2)\n    end\nend", "    count=0\n    for i from n\
    \ to 1 by -1\n        if i==1\n            count+=1\n        end\n    count\n\
    end\n</code>\n<|/ a tags=julia,for-loop,function |>\n<| c |>\nThanks, but I should\
    \ point out that this solution does not work if `n` is negative (and it doesn't\
    \ even work for positive `n`). Also this solution doesn't answer the question.\
    \ It doesn't show what was wrong with OP's code.\n<|/ c |>\n<| a dscore=2 |>\n\
    The code above will print the number of times you find 1 in the vector [1,2,3,4,5,6,7],\
    \ which should be 3 here. If we use the function above in the answer by Zeng Zhao,\
    \ it returns 6 (the number of times you find 1), which is incorrect. \nThe reason\
    \ for this is that the function doesn't count 1 in the first position. Hence,\
    \ \n<code>\ncount+1\n</code>\nshould be changed to\n<code>\ncount+=1 \n</code>\n\
    Also, the function can be simplified to:\n<code>", "    if n == 0 then 0 else\
    \ n + starts_one_ends(n - 1)\nend", "  if n <= 10 return n \n  starts_one_ends(n/10\
    \ + 1)\n  return n%10 == 1 && starts_one_ends(n//10 + 1)\nend\n</cell>\n<code\
    \ language=julia-1.4>\nstarts_one_ends(0)\n</cell>\n<code language=julia-1.4>",
  "    if n == 0 \n        return 1 \n    count::Int64 = 0\n    for i in 1 .. n \n\
    \        if ((i %% 1) == 0) || ((i == n) && (i != 0)) \n            count += 1\
    \ \n    return count \nend", "    count = 0\n    while n >= 10 \n        count\
    \ += n // 10\n        n -= n // 10 \n    return count", "    if n<0\n        error(\"\
    n must be positive\")\n    else if n==0\n        error(\"n must not be zero\"\
    )\n    else if n==1\n        return 2\n    else \n        return (starts_one_ends(n/10)+1\
    \ if n%10==1 else starts_one_ends(n/10)+1)", "    # Write your code in here\n\
    \    return 0 if n < 0 else starts_one_ends(n-1) + ends_one_starts(n-1) + ends_one_ends(n)",
  "    s = 0\n    for i in 1:n\n        if i==1 or i==n\n            s += 1\n    \
    \    end\n    end\n    return s", "    if n == 0 \n        return 0 \n    elseif\
    \ n == 1 \n        return 1 \n    else \n        return starts_one_ends(n - 1)\
    \ + starts_one_ends(n) \nend\n</cell>\n<code language=julia-1.0>\nstarts_one_ends(10^4)\n\
    </cell>\n<text>\nA common question is, what is the most efficient way to count\
    \ the numbers of integers in an array?\nThe method is:", "    n >= 0 && n <= 9\
    \ || n > 9 && starts_one_ends(n-1)\nend\n\"\"\"\n    Counts the number of positive\
    \ integers n such that n+1 = m*10 + d for \n    all integers m and d where m =\
    \ n*10 + d for all integers n and d\n    0 <= d < 10000\n\"\"\"", "    if n <\
    \ 10 then 1\n    elseif n < 100 then 1+starts_one_ends(n/10)\n    elseif n < 1000\
    \ then 1+starts_one_ends(n/100)+starts_one_ends(n/10)\n    elseif n < 10000 then\
    \ 1+starts_one_ends(n/1000)+starts_one_ends(n/100)+starts_one_ends(n/10)\n   \
    \ elseif n < 100000 then 1+starts_one_ends(n/10000)+starts_one_ends(n/1000)+starts_one_ends(n/100)+starts_one_ends(n/10)\n\
    \    elseif n < 1000000 then 1+starts_one_ends(n/100000)+starts_one_ends(n/10000)+starts_one_ends(n/1000)+starts_one_ends(n/100)+starts_one_ends(n/10)\n\
    \    elseif n < 10000000 then 1+starts_one_ends(n/1000000)+starts_one_ends(n/100000)+starts_one_ends(n/10000)+starts_one_ends(n/1000)+starts_one_ends(n/100)+starts_one_ends(n/10)\n\
    \    elseif n < 100000000 then 1+starts_one_ends(n/10000000)+starts_one_ends(n/1000000)+starts_one_ends(n/100000)+starts_one_ends(n/10000)+starts_one_ends(n/1000)+starts_one_ends(n/100)+starts_one_ends(n/10)\n\
    \    elseif n < 1000000000 then 1+starts_one_ends(n/100000000)+starts_one_ends(n/10000000)+starts_one_ends(n/1000000)+starts_one_ends(n/100000)+starts_one_ends(n/10000)+starts_one_ends(n/1000)+starts_one_ends(n/100)+starts_one_ends(n/10)\n\
    \    elseif n < 10000000000 then 1+starts_one_ends(n/1000000000)+starts_one_ends(n/100000000)+starts_one_ends(n/10000000)+starts_one_ends(n/1000000)+starts_one_ends(n/100000)+starts_one_ends(n/10000)+starts_one_ends(n/1000)+starts_one_ends(n/100)+starts_one_ends(n/10)\n\
    \    elseif n < 100000000000 then 1+starts_one_ends(n/10000000000)+starts_one_ends(n/1000000000)+starts_one_ends(n/100000000)+starts_one_ends(n/10000000)+starts_one_ends(n/1000000)+starts_one_ends(n/100000)+starts_one_ends(n/10000)+",
  "    if n < 100\n        1\n    else\n        n == floor(Int64(n)/100) * 100 + count(n//100,\
    \ 100)\n    end\nend\n</cell>\n<code language=julia-1.5>", "    count = 0\n  \
    \  for i in 1:n\n        if mod(n,i) == 1 || i == n \n            count += 1 \n\
    \        end\n    end\n    return count\nend\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ is O(n^2) solution, that is, it will perform n modulo operations each one will\
    \ take O(n) time.\n<|/ c |>\n<| c |>\nI made a similar function using the integer\
    \ division operator and it is faster than  the O(n^2) solution\n<|/ c |>\n<| c\
    \ |>\n: Please edit your answer to include your function.\n<|/ c |>\n<| c |>\n\
    Sorry, I do not know Julia. May be you can try the answer from here: https://stackoverflow.com/questions/4546728/fast-calculation-of-a-prime-number\n\
    <|/ c |>\n<| c |>\nThe above answer by is quite helpful as well but I am still\
    \ curious to see how we can make it faster. Using a for loop I believe is a very\
    \ slow procedure.\n<|/ c |>\n<| a |>\nHere is my simple O(n) solution, using sieve\
    \ of Eratosthenes algorithm:\n<code>", "    if (n <= 1) || (n == 0)\n        return\
    \ 0 \n    else {\n        one_ends(n-2)\n        one_ends(n-1)\n    }\nend", " \
    \   if n < 10 \n        return n\n    elif n > 9 \n        return n - 9\n    else\
    \ \n        return starts_one_ends(n - 10)", "    \n    divisible = true\n   \
    \ count = 0\n    for i in 1:n\n        if divisible\n            divisible = !(i\
    \ mod 10)\n            count += 1\n        end\n    end\n    count\nend\n</cell>\n\
    <cell>\nstarts_one_ends(10)\n</cell>\n<cell>\nstarts_one_ends(100)\n</cell>\n\
    <cell>\nstarts_one_ends(1000)\n</cell>\n<text>\nWrite a function that will accept\
    \ a positive integer n and returns the sum of all numbers from 1 to n. Then, write\
    \ a function that will accept a single positive integer n and returns the sum\
    \ of the numbers from 1 to n.", "    if n <= 0 \n        0 \n    else if n ==\
    \ 1 \n        1 \n    else \n        (n-1) * (starts_one_ends(n-1) + ends_one_starts(n-1))\n\
    end", "    if n == 1 \n        return 1 \n    else if n % 2 == 0 \n        then\
    \ return starts_one_ends(n / 2)\n        else starts_one_ends(n / 2) + 1\nend\n\
    </cell>\n<text>\nThe next function counts the number of positive integers from\
    \ 1 to n which end with 2.", "    if n==1 \n        return 1 \n    else \n   \
    \     return (starts_one_ends(n//10)*10)+starts_one_ends(n%10)+1\nend\n</code>\n\
    But if you don't mind using recursion, this is also fine:\n<code>", "    count_start\
    \ = 0\n    count_end = 0\n    for i in 1:n\n        if i==1 || i==n\n        \
    \    count_start = count_start+1\n        elseif i==n\n            count_end =\
    \ count_end+1\n        else\n            count_start = count_start+1\n       \
    \     count_end = count_end+1\n        end\n    end\n    return count_start\n\
    end\n\"\"\"\n    Given a positive integer n, return the count of the numbers of\
    \ n-digit\n    positive integers that only have 1 digit.\n    \"\"\"", "    if\
    \ n == 0 || n == 1 \n        then return 1\n    else \n        begin \n      \
    \      let\n                nums = [1..n],\n                count_ones = sum((nums\
    \ |> elem) |> elems == 1) for nums in nums\n            in \n                if\
    \ count_ones == n \n                    then 1\n                else starts_one_ends(n\
    \ - 1)\n        end\nend\n</code>\n<|/ a tags=recursion,haskell,function |>\n\
    <| c |>\nI like your approach to the problem. I wasn't thinking of using elems\
    \ though.\n<|/ c |>\n<| a dscore=1 tags=recursion,haskell,function |>\nMy approach\
    \ would be to first write a function to find all numbers that start with an 1,\
    \ then apply that to the starting number (n) until you have zero results. Something\
    \ like:\n<code>\nisOnes1 :: Int -> Bool\nisOnes1 n = all (\\(n, _) -> n == 1)\
    \ [1..n]\n</code>\nThen just use it to find all the numbers that start with 1:\n\
    <code>\nonesStart :: Int -> [Int]\nonesStart n = filter (isOnes1 n) [1..n] \n\
    </code>\n<|/ a |>\n<| c |>\n`isOnes1` is wrong. An element can be both a pair\
    \ of `Int`s and an `Int`.\n<|/ c |>\n<| c |>\nMy bad, I didn't notice that was\
    \ part of the question and didn't notice that `elem` can work for that.\n<|/ c\
    \ |>\n<| a tags=recursion,haskell,function dscore=1 |>\nIn terms of efficiency,\
    \ the solutions provided by others look good \u2014 although it might not be as\
    \ clear as the recursive one. On the other hand, it's also easier to write and\
    \ maintain.\nMy personal solution is this:\n<code>\nnumStartingAt :: Integer ->\
    \ Integer\nnumStartingAt n = (1:) . scanl (\\_ x -> (x*x) + 1) 0 [1..n]\n</code>\n\
    It builds the list of numbers from 1 to n, and for each element it adds the product\
    \ of its square with the current number minus one (since it's starting at 1).\n\
    <|/ a |>\n<| c |>\n`scanl` is not the fastest function on the planet. It looks\
    \ like it can be optimized to `foldr (\\x s -> x+x) (0,1)`, but I have no idea\
    \ how to do that. I'm sure someone more knowledgeable than me can!\n<|/ c |>\n\
    <| c |>\nI thought that `foldr` was ", "    if n == 1 \n        return 1 # 1\n\
    \    if n > 1 \n        return starts_one_ends(n / 10) * 10 + (n % 10)\n    end\n\
    \    return 0\nend\n</cell>\n<code language=julia-1.4>\nstarts_one_ends(4)\n</cell>\n\
    <code language=julia-1.4>", "    return sum(i >= 10 for i in take(n, 1:end-n))\n\
    end\n</cell>\n<cell>\nstarts_one_ends(100)\n</cell>\n<text>\nExercise 17: Counting\
    \ the number of digits of the factorial\nA factorial is a product of smaller integers.\
    \ For example, the number \n$!$ has factorial number of $1$ and $!{n+1}$. Write\
    \ a function that computes the \nfactorial number of a positive integer $n$ ($n!$).\
    \ Assume that the factorial of \n$n$ can be written as the product of $n-1$ factorials.\n\
    \"\"\"", "    if n == 1 \n        return 1 \n    else \n        return (n - 1)\
    \ * (starts_one_ends(n / 10) + 1) * (ends_one_starts(n % 10)) \nend\n</code>\n\
    <code>\njulia> starts_one_ends(10)\n10", "    count = 0\n    for x in 1..n\n \
    \       if ((x-1) == n) || (x == 1)\n            count += 1 \n        end\n  \
    \  return count\nend\n</cell>\n<cell>\n@testset \"Find all numbers with one digit\"\
    \ begin\n    testcase(starts_one_ends(1))\n    testcase(starts_one_ends(2))\n\
    \    testcase(starts_one_ends(3))\n    testcase(starts_one_ends(4))\n    testcase(starts_one_ends(5))\n\
    \    testcase(starts_one_ends(6))\n    testcase(starts_one_ends(7))\n    testcase(starts_one_ends(8))\n\
    \    testcase(starts_one_ends(9))\n    testcase(starts_one_ends(10))\nend\n</cell>\n\
    <text>\nThe next function count_n_digit() takes integer n (a non-negative integer)\
    \ and returns the number of non-zero digits in n. This function is called by count_n_digits()\
    \ and count_n_digits() to count the number of digits in a non-negative integer\
    \ n.", "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start with 1.\n    \"\"\"", "    if n\
    \ == 0 \n        return 1 \n    starts = 0 \n    count = (starts, starts + n)\
    \ \n    for i in count[1...] \n        if i == 1 \n            starts = 1 + starts\
    \ else 0 \n    return count[1...] \nends_one_starts(n::Int64)::Int64 \n    if\
    \ n == 0 \n        return 1 \n    count = (n, n) \n    for i in count[1...] \n\
    \        if i == 1 \n            return 0 \n    return count[1...] \n\"\"\"\n\
    ## ```julia\n##  julia> starts_one_ends(1023)\n##  1023\n##  ```\n## ```\n## 1023\n\
    ## ```\n## ```julia\n##  julia> starts_one_ends(1)\n##  0\n##  ```\n## ```\n##\
    \ 0\n## ```\n## ```\n## ```\n## function starts_one_ends(n::Int64)::Int64 \n##\
    \     if n == 0 \n##         return 1 \n##     starts = 0 \n##     count = (starts,\
    \ starts + n) \n##     for i in count[1...] \n##         if i == 1 \n##      \
    \       starts = 1 + starts else 0 \n##         return count[1...] \n##     ends_one_starts(n::Int64)::Int64\
    \ \n##         if n == 0 \n##             return 1 \n##         count = (n, n)\
    \ \n##         for i in count[1...] \n##             if i == 1 \n##          \
    \       return 0 \n##             return count[1...] \n## ```\n## ```\n## function\
    \ starts_one_ends(n::Int64)::Int64 \n##     if n == 0 \n##         return 1 \n\
    ##     starts = 0 \n##     count = (starts, starts + n) \n##     for i in count[1...]\
    \ \n##         if i == 1 \n##             starts = 1 + starts else 0 \n##    \
    \     return count[1...] \n##     ends_one_starts(n::Int64)::Int64 \n##      \
    \   if n == 0 \n##             return 1 \n##         count = (n, n) \n##     \
    \    for i in count[1...] \n##             if i == 1 \n##                 return\
    \ 0 \n##             return count[1...] \n## ```\n## ```julia\n##  julia> starts_one_ends(1023)\n\
    ##  1023\n##  ```\n## ```\n## 1023\n## ```\n## ```\n##  julia> starts_", "   \
    \ if n < 0 || n > 1 \n        error(\"starts_one_ends requires n to be a non-negative\
    \ integer\")\n    elseif n == 0\n        0\n    elseif n == 1\n        1\n   \
    \ else\n        repeat(n - 1) do \n            i = n + 1 - digits(n)\n       \
    \     starts_one_ends(i)\n        end\n    end\nend\n</cell>\n<text>\nExercise\
    \ 4\nWrite a function that takes two integers n and m and returns the number of\
    \ positive integers less than m which satisfy the following inequality:", "  \
    \  if n == 0 \n        return 0 \n    else \n        return starts_one_ends(n/10)\
    \ + 1 + (n % 10 == 1) \nend\n</cell>\n<code language=julia-1.4>\n\"\"\"\n    Given\
    \ a positive integer n, return the count of the numbers of n-digit\n    positive\
    \ integers that start or end with 0.\n    \"\"\"", '    return sum(isone(i) for
    i in 1..n)', "    count = 0\n    for x = n..999 \n        if x % 10 == 1 \n  \
    \          count += 1 \n        end\n    end\n    return count\nend\n\"\"\"\n\
    \    Write a Julia function that accepts a positive integer n and computes\n \
    \   the number of positive integers that start or end with 1, up to and including\n\
    \    n.\n    \"\"\"", "    if n == 1 \n        then return 1 \n        else \n\
    \            count = 1\n            while (n % 10) == 1\n                count\
    \ += starts_one_ends(n / 10)\n                n /= 10\n            return count\
    \ + starts_one_ends(n) \n    end\n</code>\n<|/ a |>\n<| a tags=algorithm,julia\
    \ |>\nThis one is based on a recursive function and I think it is much more efficient\
    \ than the others posted so far:\n<code>", "    n <= 0 || n >= 1e010 || n % 1\
    \ == 0\nend\n\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"", " \
    \   if n < 100 return n\n    let x = n//10\n    if x == 0 return 0\n    if n %\
    \ (x/10) == 0 then return ends_one_ends(n-x*10) else return starts_one_ends(x-1)\n\
    end", "    for i in (1 to n)\n        if (n%i == 0 || n%(i-1) == 0)\n        \
    \    i += 1\n        else\n            return i\n    return 0\nend\n</cell>\n\
    <code language=julia-1.0>\n\"\"\"\n    counts_n_digits(n::Int64)::Int64\nGiven\
    \ a positive integer n, return the count of the numbers of n-digit\n    positive\
    \ integers that start or end with 1.\n\"\"\"", "    sum(map((==1).(ndigits(n)),\
    \ (1:n)))\nend\n\"\"\"\n    Find the number of positive integers that start or\
    \ end with 1 given some positive integer n.\n    For example, given a number n,\
    \ return count of the number of positive integers that start or end with 1.\n\
    \    \"\"\"", "    if n==1\n        return n\n    else \n        return starts_one_ends(n-1)\
    \ + ends_one_starts(n-1)", "    count = 0\n    \n    # Fill the array\n    arr\
    \ = [Int64(1)]\n    for i in 1:n\n        push!(arr, arr[i]+1)\n    end\n    \n\
    \    # Count the number of 1 at start and end\n    for i in 1:n-1\n        if\
    \ arr[i] != arr[i+1]\n            count += 1\n        end\n    end\n    \n   \
    \ # Return it\n    return count\nend\n</cell>\n<code language=julia-1.6>\n\"\"\
    \"\n    Given a positive integer n, return the count of the numbers of n-digit\n\
    \    positive integers that end with 1.\n    \"\"\"", "    x <- 0\n    while (n>0)\n\
    \        x <- x + 1\n        n <- n - x \n    return x\nends_one_starts(n::Int64)::Int64\
    \ \n    x <- 0\n    while (n>0)\n        x <- x + 1\n        n <- n - x\n    return\
    \ x\nends_one_ends(n::Int64)::Int64\n    n <- n\n    x  <- 0\n    while (n>0)\n\
    \        x <- x + 1\n        n <- n - x\n    return x\nends_one_ends(n::Int64)::Int64\n\
    \    n <- n\n    x  <- 0\n    while (n>0)\n        x <- x + 1\n        n <- n\
    \ - x\n    return x\nends_one_starts(n::Int64)::Int64\n    n <- n\n    x  <- 0\n\
    \    while (n>0)\n        x <- x + 1\n        n <- n - x\n    return x\nends_one_starts(n::Int64)::Int64\n\
    \    n <- n\n    x  <- 0\n    while (n>0)\n        x <- x + 1\n        n <- n\
    \ - x\n    return x\nends_one_starts(n::Int64)::Int64\n    n <- n\n    x  <- 0\n\
    \    while (n>0)\n        x <- x + 1\n        n <- n - x\n    return x\nends_one_starts(n::Int64)::Int64\n\
    \    n <- n\n    x  <- 0\n    while (n>0)\n        x <- x + 1\n        n <- n\
    \ - x\n    return x\nends_one_starts(n::Int64)::Int64\n    n <- n\n    x  <- 0\n\
    \    while (n>0)\n        x <- x + 1\n        n <- n - x\n    return x\nends_one_starts(n::Int64)::Int64\n\
    \    n <- n\n    x  <- 0\n    while (n>0)\n        x <- x + 1\n        n <- n\
    \ - x\n    return x\nends_one_starts(n::Int64)::Int64\n    n <- n\n    x  <- 0\n\
    \    while (n>0)\n        x <- x + 1\n        n <- n - x\n    return x\nends_one_starts(n::Int64)::Int64\n\
    \    n <- n\n    x  <- 0\n    while (n>0)\n        x <- x + 1\n        n <- n\
    \ - x\n    return x\nends_one_starts(n::Int64)::Int64\n    n <- n\n    x", " \
    \   match n with\n    | 0 -> 0\n    | i when i >= 10 -> 0\n    | i -> 1 + starts_one_ends(i\
    \ - 1)\nend\n</cell>\n<code language=julia-1.5>\nprintln(starts_one_ends(0))\n\
    println(starts_one_ends(1))\nprintln(starts_one_ends(2))\nprintln(starts_one_ends(3))\n\
    println(starts_one_ends(10))\nprintln(starts_one_ends(100))\nprintln(starts_one_ends(1000))\n\
    println(starts_one_ends(10000))\nprintln(starts_one_ends(100000))\nprintln(starts_one_ends(1000000))\n\
    println(starts_one_ends(10000000))\nprintln(starts_one_ends(100000000))\n</cell>\n\
    <text>\nExercise\nImplement a function is_prime(n::Int64)::Bool that returns True\
    \ if n is a prime and False otherwise. Hint: There are lots of ways to do this.",
  "    if n == 1\n        return 2\n    else if n == 2\n        return 3\n    else\n\
    \        return starts_one_ends(n-1) + ends_one_ends(n-1)\n    end\nend", "  \
    \  count = 0\n    while n > 0\n        if n % 10 == 1\n            count += 1\n\
    \        end\n        n = n / 10\n    end\n    return count\nend\n</cell>\n<code\
    \ language=julia-0.5>", "    \"\"\"\n    Given a positive integer n, return the\
    \ count of the numbers of n-digit\n    positive integers that start or end with\
    \ 1.\n    \"\"\"", "\"\"\"\n    Given a positive integer n, return the count of\
    \ the numbers of n-digit\n    positive integers that start or end with 1.\n  \
    \  \"\"\"", "\tif n==0 then return 0 else starts_one_ends(n-1)\n\tif n==1 then\
    \ return 1 else starts_one_ends(n-1)+n-1\nend", "\"\"\"\n    The number of 1s\
    \ in the number n.\n    \"\"\"", "    \"\"\"\n    Given a positive integer n,\
    \ return the count of the numbers of n-digit\n    positive integers that start\
    \ or end with 1.\n    \"\"\"", "    if n == 0\n    then return 0\n    else if\
    \ n == 1\n    then return 1\n    else if starts_one_ends(n-1) == 0\n    then return\
    \ 1\n    else starts_one_ends(n-1)\nend\n</cell>\n<code language=julia-1.1>\n\"\
    \"\"\n    count_nums! counts the number of nums from 1 to n\n    (or from 2 to\
    \ n-1 if n is even)\n    INPUT:\n        n :: a positive integer\n    OUTPUT:\n\
    \        count_nums! returns the count of nums from 1 to n (or from 2 to n-1 if\
    \ n is even)\n\"\"\"", "    # Replace this with the solution\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\n\
    ends_one_starts(n)\nends_one_starts(n)\nends_one_starts(n)\nends_", "\"\"\"\n\
    \    Given a positive integer n, return the count of the numbers of n-digit\n\
    \    positive integers that start or end with 1.\n    \"\"\"", "    sum = 0\n\
    \    while n >= 10 \n        sum += (n%10).==1\n        n = floor(n / 10)\n  \
    \  return sum\nend\n</cell>\n<code language=julia-1.0>\nstarts_one_ends(1001)\n\
    </cell>\n<text>\nThe sum of the first ten natural numbers is", "\tif n == 1\n\t\
    \treturn 1\n\telse\n\t\treturn starts_one_ends(n - 1) * 10 + ends_one_starts(n)",
  "    if n<10 return 0 \n    return sum(starts_one_ends(n//10))+1 if n%10==1 else\
    \ 0", "    if n < 1\n        return n\n    \n    if n % 2 == 0\n        return\
    \ starts_one_ends(n / 2)\n    \n    return starts_one_ends(n / 2) + 1\nend\n</cell>\n\
    <code language=julia-1.5>\n# Check your answer using @code_native cell\n@code_native\
    \ @show starts_one_ends(10)\n@code_native @show starts_one_ends(20)\n@code_native\
    \ @show starts_one_ends(30)\n@code_native @show starts_one_ends(60)\n@code_native\
    \ @show starts_one_ends(100)\n@code_native @show starts_one_ends(1000)\n@code_native\
    \ @show starts_one_ends(10000)\n@code_native @show starts_one_ends(100000)\n@code_native\
    \ @show starts_one_ends(1000000)\n@code_native @show starts_one_ends(10000000)\n\
    </cell>\n<text>\n12. How many numbers between 1 and 1,000,000 inclusive are divisible\
    \ by 3?", "    if n == 0 \n        0\n    elseif n < 0 \n        -1\n    elseif\
    \ n < 10 \n        1\n    elseif n < 100\n        0\n    elseif n < 1000\n   \
    \     0\n    elseif n < 10000\n        0\n    elseif n < 100000\n        0\n \
    \   elseif n < 1000000\n        0\n    elseif n < 10000000 \n        0\n    elseif\
    \ n < 100000000\n        0\n    elseif n < 1000000000\n        0\n    elseif n\
    \ < 10000000000\n        0\n    elseif n < 100000000000 \n        0\n    elseif\
    \ n < 1000000000000\n        0\n    elseif n < 10000000000000\n        0\n   \
    \ elseif n < 100000000000000\n        0\n    elseif n < 1000000000000000\n   \
    \     0\n    elseif n < 10000000000000000\n        0\n    elseif n < 100000000000000000\n\
    \        0\n    elseif n < 1000000000000000000\n        0\n    elseif n < 10000000000000000000\n\
    \        0\n    elseif n < 100000000000000000000\n        0\n    elseif n < 1000000000000000000000\n\
    \        0\n    elseif n < 10000000000000000000000\n        0\n    elseif n <\
    \ 100000000000000000000000\n        0\n    elseif n < 1000000000000000000000000\n\
    \        0\n    elseif n < 10000000000000000000000000\n        0\n    elseif n\
    \ < 100000000000000000000000000\n        0\n    elseif n < 1000000000000000000000000000\n\
    \        0\n    elseif n < 10000000000000000000000000000\n        0\n    elseif\
    \ n < 100000000000000000000000000000\n        0\n    elseif n < 1000000000000000000000000000000\n\
    \        0\n    elseif n < 10000000000000000000000000000000\n        0\n    elseif\
    \ n < 100000000000000000000000000000000\n        0\n    elseif n < 1000000000000000000000000000000000\n\
    \        0\n    elseif n < 10000000000000000000000000000000000\n        0\n  \
    \  elseif n < 100000000000000000000000000000000000\n        0\n    elseif n <\
    \ 1000000000000000000000000000000000000\n        0\n    elseif n < 10000000000000000000000000000000000000\n\
    \        0\n    elseif n < 100000000000000000000000000000000000000\n        0\n\
    \    elseif n < 1000000000000000000000000000000000000000\n        0\n    elseif\
    \ n < 10000000000000000000000000000000000000000\n        0\n    elseif n < 100000000000000000000000000000000000000000\n\
    \        0\n    elseif n < 1000000000000000000000000000000000000000000\n     \
    \   0\n    elseif n < 100000000000000000000000000000000000000000\n        0\n\
    \    elseif n < 1000000000000000000000000000000000000000000\n        0\n    elseif\
    \ n < 10000000000000000000000000000000000000000000\n        0\n    elseif n <\
    \ 100000000000000000000000000000000000000000000\n        0\n    elseif n < 1000000000000000000000000000000000000000000000\n\
    \        0\n    elseif n < 10000000000000000000000000000000000000000000000\n \
    \       0", "    if n == 0 then 0 else 1 \n    else starts_one_ends(n-1) + n div\
    \ div(n)", "    if n <= 0 then 0 else n + starts_one_ends(floor(n/2)) - 1 end\
    \ \nend", "    if n < 0 \n        error(\"n must be positive\")\n    else if n\
    \ == 0 \n        error(\"n must be 1 or more\")\n    else if n == 1 \n       \
    \ return 1\n    else \n        return starts_one_ends(n-1) + ends_one_starts(n-1)",
  "    if n < 0 \n        return 0 \n    if n == 1 \n        return 1 \n    if n ==\
    \ 2 \n        return 1 \n    if n < 10 \n        return starts_one_ends(n-1) +\
    \ starts_one_ends(n-2) \n    return starts_one_ends(n-1) + starts_one_ends(n-2)\
    \ + starts_one_ends(n-3) \nend\n</cell>\n<code language=julia-1.0>", "    if n\
    \ >= 1\n        count_1 = 0\n        for i in 1 : n \n            if i == 1\n\
    \                count_1 += 1\n            elseif i == n\n                count_1\
    \ += n \n            else\n                count_1 += i + 1\n        end\n   \
    \ end\n    return count_1\nend\n</cell>\n<code language=julia-1.3>\n# Your starts_one_ends\
    \ function\n@code_warntype starts_one_ends(1000)\n</cell>\n<code language=julia-1.3>\n\
    # Solution", "    if n < 10 \n        then 1\n        elseif n < 100 \n      \
    \      then n / 10 + starts_one_ends(n / 10)\n            else n / 10 + starts_one_ends(n\
    \ / 10) + 1\n    end\nend", "    if n<=0\n        error(\"starts_one_ends: n is\
    \ negative\")\n    else if n==1\n        return 2\n    else\n        count(n)\
    \ - count(n-1) \n    end\nend", "    \n    if n<1\n        return -1\n    \n \
    \   count::Int64 = 1\n    \n    for i::Int64 in 1..n-1\n        if i==1 || i==n-1\n\
    \            count += 1\n        else\n            count += starts_one_ends(n-1)\n\
    \        end\n    end\n    \n    return count\nend", "    if n < 1 \n        0\
    \ \n    else \n        starts_one_ends(n-1) `seq` ends_one_starts(n-1) `seq` ends_one_starts(n)\n\
    end\n</cell>\n<code language=julia-1.5>\n@time starts_one_ends(10^5);\n</cell>\n\
    <text>\nFor another example of counting consecutive integers, let's count all\
    \ the numbers where the digits are the same or where the digits are different.",
  "    for i in 2...n \n        if n%i == 0 \n            return 1 + (n//i) * starts_one_ends(i-1)\
    \ + n // i\n        end\n    end\n    return 0\nend\n</cell>\n<code language=julia-1.6>",
  "    if n == 1 \n        return 1 \n    else \n        return starts_one_ends(n-1)\
    \ + starts_one_ends(n-2) + starts_one_ends(n-3) + starts_one_ends(n-4) + starts_one_ends(n-5)\
    \ + starts_one_ends(n-6) + starts_one_ends(n-7) + starts_one_ends(n-8) + starts_one_ends(n-9)\
    \ + starts_one_ends(n-10)\n    end\nend", "    \"\"\"\n    Given a positive integer\
    \ n, return the count of the numbers of n-digit\n    positive integers that start\
    \ or end with 1.\n    \"\"\"", "    sum(k for k in collect(1:n) \n        if k\
    \ % 10 ==1 && k %% 100!=1 && !(k %% 1000)==1 && !(k %% 10000)==1 )\nend\n</cell>\n\
    <code language=julia-1.6>\nstarts_one_ends(10)\n</cell>\n<text>\nTo find the first\
    \ n positive integers that end with 1, where 1 < n \u2264 100.", "    # Write\
    \ your code in Python 3 style\n    if n > 0 \n        then count_start = count_end\
    \ = 0\n        while n > 0\n            count_start += 1\n            if n%10\
    \ == 1 \n                then count_end += 1\n            n = n/10\n        end\n\
    \        return count_end\n    else\n        return 0\n    end\nend\n</cell>\n\
    <code language=julia-1.4>\ncount_starts_ends(1023)\n</cell>\n<text>\nExercise\
    \ 12. Find first occurence of n in a list.", "    \n    if n < 10 \n        return\
    \ n\n    \n    i = 2\n    \n    while i * i <= n \n        if n % i == 0 \n  \
    \          i := i + 1\n            if i == 10 \n                i := 2\n     \
    \   else \n            i := 2\n    \n    return i \nend", "    if n == 0\n   \
    \     0\n    elseif n == 1\n        0\n    elseif n % 2 == 1\n        starts_one_ends(n/2)\n\
    \    else\n        starts_one_ends(n-1) + starts_one_ends(n/2)\nend", "    \"\"\
    \"\n    Given a positive integer n, return the count of the numbers of n-digit\n\
    \    positive integers that start or end with 1.\n    \"\"\"\n    if n < 10 \n\
    \        return n \n    else:\n        return counts_ends_with(n, 10)\n    ends_with_1(n::Int64)::Int64\
    \ \n    \"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n  \
    \  return counts_ends_with(n, 10)\nends_with_1(n::Int64)::Int64 \n    \"\"\"\n\
    \    Given a positive integer n, return the count of the numbers of n-digit\n\
    \    positive integers that start or end with 1.\n    \"\"\"\n    if n < 10 \n\
    \        return n \n    else:\n        return counts_ends_with(n, 10)\n    ends_with_1(n::Int64)::Int64\
    \ \n    \"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n  \
    \  if n < 10 \n        return n \n    else:\n        return counts_ends_with(n,\
    \ 10)\n    ends_with_1(n::Int64)::Int64 \n    \"\"\"\n    Given a positive integer\
    \ n, return the count of the numbers of n-digit\n    positive integers that start\
    \ or end with 1.\n    \"\"\"\n    if n < 10 \n        return n \n    else:\n \
    \       return counts_ends_with(n, 10)\n    ends_with_1(n::Int64)::Int64 \n  \
    \  \"\"\"\n    Given a positive integer n, return the count of the numbers of\
    \ n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n    if\
    \ n < 10 \n        return n \n    else:\n        return counts_ends_with(n, 10)\n\
    \    ends_with_1(n::Int64)::Int64 \n    \"\"\"\n    Given a positive integer n,\
    \ return the count of the numbers of n-digit\n    positive integers that start\
    \ or end with 1.\n    \"\"\"\n    if n < 10 \n        return n \n    else:\n \
    \       return counts_ends_with(n, 10)\n    ends_with_1(n::Int64)::Int64 \n  \
    \  \"\"\"\n    Given a positive integer n, return the count of the numbers of\
    \ n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n    if\
    \ n < 10 \n        return n \n    else:\n        return counts_ends_with(n, 10)\n\
    \    ends_with_1(n::Int64)::Int64 \n    \"\"\"\n    Given a positive integer n,\
    \ return the count of the numbers of n-digit\n    positive integers that start\
    \ or end with 1.\n    \"\"\"\n    if n < 10 \n        return n \n    else:\n \
    \       return counts_ends_with(n, 10)\n    ends_with_1(n::Int64)::Int64 \n  \
    \  \"\"\"\n    Given a positive integer n, return the ", "    s = div(n, 10^n)\n\
    \    if s > 0 {\n        s += 1\n    }\n    \n    \n    return s\nend\n</cell>\n\
    <code language=julia-1.6>\n@code_native native begin\n    using Random", "   \
    \ count = 0\n    for d in 1:10\n        if n%d == 0\n            count += 1\n\
    \        end\n    end\n    return count\nend\n\"\"\"\n    The number of positive\
    \ integers that start with 0\n    \"\"\"", "    if n < 2 then return 1 else return\
    \ (starts_one_ends(n-1) + starts_one_ends(n-2))\nend", '  if n<10 then return
    n else return n==1 ? 1 : count_nth_digits(n::Int64) end', "    if n == 0\n   \
    \     0\n    else\n        1 + starts_one_ends(n-1)\nend\n\"\"\"\n    Given a\
    \ positive integer n, return the count of the numbers of n-digit\n    positive\
    \ integers that start or end with 1 and are less than n.\n    \"\"\"", "    if\
    \ n <= 0\n        return 0\n    start = 1\n    while n > 0\n        if n mod 10\
    \ == 0\n            start = start + 1\n        end = 1\n        while n > 0\n\
    \            if n mod 10 == 1 and n mod 10 != start\n                end = end\
    \ + 1\n            n = n div 10\n        end\n        start = start + 1\n    end\n\
    \    return start\nend", "    if (n == 0)\n    then 0\n    else n % 10 == 1 ?\
    \ 1 + starts_one_ends(n / 10) : (n % 10 >= 2 ? (1 + starts_one_ends(n / 10)) :\
    \ 0)\n    end\nend\n</code>\n(Note that a similar function could be written using\
    \ mod operations and recursion, which would be a bit more efficient but also not\
    \ as terse as this.)\n<|/ a tags=recursion,julia,performance |>\n<| a dscore=1\
    \ tags=recursion,julia,performance |>\nI like the solutions given by and that\
    \ propose memoization, which they also propose to solve the problem. While they\
    \ do that correctly, they are incomplete. For example, they fail to recognize\
    \ the case of n==0.\nHere is my solution that takes the recursive approach and\
    \ solves the problem by memoizing the result.\n<code>", "    if n == 1\n     \
    \   1\n    else\n        sum( x -> starts_one_ends(n / x), 1 ) +\n        (n %\
    \ n == 0)*starts_one_ends(n / n)\nend", "    if n <= 0 \n    then 0\n    else\
    \ 1\n    end\nend", "    \n    \"\"\"\n    Count the number of integers starting\
    \ or ending with 1\n    \"\"\"", "    if n < 1\n    else n * factorial(n-1)\n\
    end\n</cell>\n<code language=julia-1.0>\nstarts_one_ends(8)\n</cell>\n<text>\n\
    Problem 3: Write a function that will take as input a string of letters and return\
    \ the string with all but the last letter of each word.", "    if n == 1 \n  \
    \      return 1 # 1 means only starting 1\n    else \n        return (n - 1)*starts_one_ends(n-1)\n\
    </code>\nThen I used this function to count the numbers that start with 1:\n<code>",
  "    if n==1 then return 1 else 0\n    else if n>1 then starts_one_ends(n-1) + starts_one_ends(n-2)\
    \ + \n        starts_one_ends(n-3)\n        else 0\n    end \nend", "    if n\
    \ == 0 then 0 else starts_one_ends(n // 10) + (n % 10 == 1)\nend\n</cell>\n<code\
    \ language=julia-1.5>\njulia> starts_one_ends(10)\n30\n</cell>\n<code language=julia-1.5>",
  "    count := 0\n    for x in 1:n\n        if x==1 \n            count := count\
    \ + 1\n        elseif x==n \n            count := count + 0\n        end if\n\
    \    end for\n    return count\nend", "    if n == 0 then 1 else 0\n    if n ==\
    \ 1 then 1\n    else if n % 10 == 1 then (starts_one_ends(n / 10) + 1) \n    else\
    \ starts_one_ends(n / 10)\n    end\nend\n</code>\n<|/ a dscore=0 tags=count,julia\
    \ |>\n<| c |>\nNice, but you missed the case where the input is negative.\n<|/\
    \ c |>\n<| c |>\nthanks. i updated my answer to handle the negative input.\n<|/\
    \ c |>\n<| c |>\nIn Julia the preferred way is to use `+` and `-` instead of `+=`\
    \ and `-=`\n<|/ c |>\n<| c |>\nGood suggestion, thanks\n<|/ c |>\n<| a tags=count,julia\
    \ dscore=0 |>\nHow about this:\n<code>", "    count = 0\n    while n != 1 do\n\
    \        n /= 10\n        count += 1\n    end\n    return count\nend\n</cell>\n\
    <code language=julia-1.3>\nstarts_one_ends(5)\n</cell>\n<text>\nExercise 4: Write\
    \ a function that takes a string as input and returns the number of times \"1\"\
    \ appears among the digits.", "    if n < 1\n        0\n    else\n        floor(log2(n))+1\n\
    \    end\nend", "    # count starts and ends of 1 digits.\n    return count(n::Int64,\
    \ (x, y) -> (x || y) & 1)", "    if n == 0 || n == 1 \n        return 0 \n   \
    \ else \n        return starts_one_ends(n - 1) + ends_one_starts(n) \n    ends_one_starts(n::Int64)::Int64\
    \ \n    if n == 1 \n        return 1 \n    else \n        return ends_one_starts(n\
    \ - 1) + 1 \n    ends_one_starts(1) = 0\nends_one_starts(1) = 1\nends_one_starts(0)\
    \ = 1\nends_one_starts(2) = 1\nends_one_starts(3) = 1\nends_one_starts(4) = 2\n\
    ends_one_starts(5) = 2\nends_one_starts(6) = 2\nends_one_starts(7) = 2\nends_one_starts(8)\
    \ = 2\nends_one_starts(9) = 2\nends_one_starts(10) = 2\nends_one_starts(11) =\
    \ 3\nends_one_starts(12) = 3\nends_one_starts(13) = 3\nends_one_starts(14) = 3\n\
    ends_one_starts(15) = 3\nends_one_starts(16) = 3\nends_one_starts(17) = 3\nends_one_starts(18)\
    \ = 3\nends_one_starts(19) = 3\nends_one_starts(20) = 3\nends_one_starts(21) =\
    \ 3\nends_one_starts(22) = 3\nends_one_starts(23) = 3\nends_one_starts(24) = 3\n\
    ends_one_starts(25) = 3\nends_one_starts(26) = 3\nends_one_starts(27) = 3\nends_one_starts(28)\
    \ = 3\nends_one_starts(29) = 3\nends_one_starts(30) = 3\nends_one_starts(31) =\
    \ 3\nends_one_starts(32) = 3\nends_one_starts(33) = 3\nends_one_starts(34) = 3\n\
    ends_one_starts(35) = 3\nends_one_starts(36) = 3\nends_one_starts(37) = 3\nends_one_starts(38)\
    \ = 3\nends_one_starts(39) = 3\nends_one_starts(40) = 3\nends_one_starts(41) =\
    \ 3\nends_one_starts(42) = 3\nends_one_starts(43) = 3\nends_one_starts(44) = 3\n\
    ends_one_starts(45) = 3\nends_one_starts(46) = 3\nends_one_starts(47) = 3\nends_one_starts(48)\
    \ = 3\nends_one_starts(49) = 3\nends_one_starts(50) = 3\nends_one_starts(51) =\
    \ 3\nends_one_", "    \"\"\"\n    Given a positive integer n, return the count\
    \ of the numbers of n-digit\n    positive integers that start or end with 1.\n\
    \    \"\"\"", "    \"\"\"\n    Given a positive integer n, return the count of\
    \ the numbers of n-digit\n    positive integers that start or end with 1.\n  \
    \  \"\"\"\n    ", "    if n == 0 \n        return 0 \n    else \n        ones\
    \ = n - 1\n        starts_ends_n = 0\n        while ones > 0 \n            if\
    \ n % 10 == 1 && n % 100 != 11 \n                return starts_ends_n \n     \
    \       ones -= 1\n            starts_ends_n += 1\n        end\n        return\
    \ starts_ends_n\nend", "    count = 0\n    for x in 1..n\n        if mod(x, 10)\
    \ == 1\n            count += 1\n        end\n    end\n    count\nend\n</code>\n\
    <|/ a tags=julia,algorithm |>\n<| a |>\nFor this problem, I believe that if you\
    \ can avoid using loops you can make a significant speed-up. The algorithm below\
    \ works by iterating through each digit in the given number in reverse order and\
    \ checking how many times a given digit in the given number starts or ends with\
    \ 1. Once we know how many times each digit appears, we can sum the number of\
    \ times we see a digit that starts with 1 followed by the same number of digits\
    \ that end with 1. \n<code>", "    if n==0 \n        then 0 \n    else if n==1\
    \ \n        then 1 \n    else if n<0 \n        then -starts_one_ends(-n)\n   \
    \ else if n>1 \n        then starts_one_ends(n-1) + starts_one_ends(n-1)\n   \
    \ end\nend\n\"\"\"\n    Compute the number of 1's in one number or all integers\
    \ given by the\n    input array. \n    \"\"\"", "    if n < 0 \n        then error(\"\
    starts_one_ends called with n < 0\")\n    else if n == 0 \n        then return\
    \ 1 \n        else if n == 1 \n            then return 1 \n            else \n\
    \                let l = floor(log(n))\n                let (q, r) = div(n, 10)\n\
    \                let m = r - l + 1\n                let mut i = 1\n          \
    \      while i <= m \n                    and is_odd(floor(i))\n             \
    \       and i <= n \n                    and i >= 1 \n                    and\
    \ i >= n \n                    and i != q \n                    && i != r \n \
    \                   && i != l\n                    && is_odd(i)\n            \
    \        && (i^q^r^l) == 0 \n                    && is_odd(i^q^r^l)\n        \
    \            && (i^q^r^l) == n\n                    && (i^q^r^l) == (n - 1)\n\
    \                    && (i^q^r^l) == (n - 2)\n                    && (i^q^r^l)\
    \ == (n - 3)\n                    && (i^q^r^l) == (n - 4)\n                  \
    \  && (i^q^r^l) == (n - 5)\n                    && (i^q^r^l) == (n - 6)\n    \
    \                && (i^q^r^l) == (n - 7)\n                    && (i^q^r^l) ==\
    \ (n - 8)\n                    && (i^q^r^l) == (n - 9)\n                    &&\
    \ (i^q^r^l) == (n - 10)\n                    && (i^q^r^l) == (n - 11)\n      \
    \              && (i^q^r^l) == (n - 12)\n                    && (i^q^r^l) == (n\
    \ - 13)\n                    && (i^q^r^l) == (n - 14)\n                    &&\
    \ (i^q^r^l) == (n - 15)\n                    && (i^q^r^l) == (n - 16)\n      \
    \              && (i^q^r^l) == (n - 17)\n                    && (i^q^r^l) == (n\
    \ - 18)\n                    && (i^q^r^l) == (n - 19)\n                    &&\
    \ (i^q^r^l) == (n - 20)\n                    && (i^q^r^l) == (n - 21) \n     \
    \               && (i^q^r^l) == (n - 22)\n                    && (i^q^r^l) ==\
    \ (n - 23)\n                    && (i^q^r^l) == (n - 24)\n                   \
    \ && (i^q^r^l) == (n - 25)", "    \n    count = 0\n    i = 2\n    while i <= n\
    \ do\n        if n%i==0 && i!=n \n            count += 1\n        i += 1\n   \
    \ end\n    \n    return count\nend\n\"\"\"\n    Given a positive integer n, return\
    \ the count of the numbers of n-digit\n    positive integers that start with 2.\n\
    \    \"\"\"", "    starts = starts_index(n) - 1\n    ends = ends_index(n) - 1\n\
    \    return n - starts - ends\nend\n</cell>\n<code language=julia-1.2>\n@time\
    \ starts_one_ends(1_000_000_000);\n</cell>\n<text>\nThe counts_index() function\n\
    The counts_index() function is similar to count(), but returns the number of entries\
    \ with keys that are strictly less than a given value rather than the number of\
    \ keys equal to or greater than a given value. For example, counts_index(1) returns\
    \ the number of keys strictly less than 1, and counts_index(1_000_000_000) returns\
    \ the number of keys strictly less than 1_000_000_000.", "    count = 0\n    for\
    \ digit in digits(n) \n        if digit==1\n            count+=1\n    end\n  \
    \      \n    return count\nend\n</cell>\n<text>\nSolution\nLet's test our solution:",
  "    count = 0\n    while n > 1\n        n /= 10\n        count += 1\n    end\n\
    \    return count\n</cell>\n<code language=julia-1.6>\n# Solution using `digits`\
    \ function.", "    if n == 0 \n        0\n    elseif n > 0\n        1 + starts_one_ends(n-1)\n\
    \    elseif n < 0\n        starts_one_ends(abs(n))\n    else\n        error(\"\
    bad input\")\n    end\nend", "\tif n == 0 \n\t\treturn 0 \n\telse \n\t\tlet mut\
    \ x = 1\n\t\tlet mut y = 1\n\t\twhile x < n {\n\t\t\tif n % x == 0 { \n\t\t\t\t\
    x = x + y \n\t\t\t\ty = 0\n\t\t\t} else \n\t\t\t\ty = y + 1 \n\t\t}\n\t\tx + y\n\
    \tend \nend\n</cell>\n<text>\nWrite a function that takes a list of integers l\
    \ and returns the number of 1s in the list.", "\tif n <= 1 \n\t\treturn 0\n\t\
    else if n < 10\n\t\treturn 1\n\telse if n == 10\n\t\treturn 2\n\telse if n ==\
    \ 11\n\t\treturn 3\n\telse if n == 12\n\t\treturn 4\n\telse if n == 13\n\t\treturn\
    \ 5\n\telse if n == 14\n\t\treturn 6\n\telse if n == 15\n\t\treturn 7\n\telse\
    \ if n == 16\n\t\treturn 8\n\telse if n == 17\n\t\treturn 9\n\telse if n == 18\n\
    \t\treturn 10\n\telse if n == 19\n\t\treturn 11\n\telse if n == 20\n\t\treturn\
    \ 12\n\telse if n == 21\n\t\treturn 13\n\telse if n == 22\n\t\treturn 14\n\telse\
    \ if n == 23\n\t\treturn 15\n\telse if n == 24\n\t\treturn 16\n\telse if n ==\
    \ 25\n\t\treturn 17\n\telse if n == 26\n\t\treturn 18\n\telse if n == 27\n\t\t\
    return 19\n\telse if n == 28\n\t\treturn 20\n\telse if n == 29\n\t\treturn 21\n\
    \telse if n == 3\n\t\treturn 22\n\telse if n == 4\n\t\treturn 23\n\telse if n\
    \ == 5\n\t\treturn 24\n\telse if n == 6\n\t\treturn 25\n\telse if n == 7\n\t\t\
    return 26\n\telse if n == 8\n\t\treturn 27\n\telse if n == 9\n\t\treturn 28\n\t\
    else if n == 10\n\t\treturn 29\n\telse if n == 11\n\t\treturn 30\n\telse if n\
    \ == 12\n\t\treturn 31\n\telse if n == 13\n\t\treturn 32\n\telse if n == 14\n\t\
    \treturn 33\n\telse if n == 15\n\t\treturn 34\n\telse if n == 16\n\t\treturn 35\n\
    \telse if n == 17\n\t\treturn 36\n\telse if n == 18\n\t\treturn 37\n\telse if\
    \ n == 19\n\t\treturn 38\n\telse if n == 20\n\t\treturn 39\n\telse if n == 21\n\
    \t\treturn 40\n\telse if n == 22\n\t\treturn 41\n\telse if n == 23\n\t\treturn\
    \ 42\n\telse if n == 24\n\t\treturn 43\n\telse if n == 25\n\t\treturn 44\n\telse\
    \ if n == 26\n\t\treturn 45\n\telse if n == 27\n\t\treturn 46\n\telse if n ==\
    \ 28\n\t\treturn 47\n\telse if n == 29\n\t\treturn 48\n\telse if n == 3\n\t\t\
    return 49\n\telse if n == 4\n\t\treturn 50\n\telse if n == 5\n\t\treturn 51\n\t\
    else if n == 6\n\t\treturn 52\n\telse if n == 7\n\t\treturn 53\n\telse if n ==\
    \ 8\n\t\treturn 54\n\telse if n == 9\n\t\treturn 55\n\telse if n == 10\n\t\treturn\
    \ 56\n", "    if n < 10\n        1\n    else \n        for a in 1:10\n       \
    \     if n == a\n                starts_one_ends(n+1)\n            else\n    \
    \            starts_one_ends(n)\n        end\nend", "    # Write your code here.\n\
    \    \"\"\"\n    This function solves the given problem.\n    \"\"\"", "    if\
    \ n <= 10\n        return Int64(1)\n    \n    count::Int64 = 0\n    i = n\n  \
    \  \n    while i < n+9\n        count::Int64 = count + 1\n        i = i + 9\n\
    \    end\n    \n    return count\nend", "    if n <= 0 \n    then return 0\n \
    \   else if n == 1 \n    then return 1\n    else \n        let mut count = 0\n\
    \        let mut counter = 1\n        for i in 1..n \n        do \n          \
    \  if i == counter\n            then \n                count += 1\n          \
    \  else\n                counter = 0\n            end \n        end \n       \
    \ return count \n    end \nend \n</code>\n<|/ a |>\n<| c |>\nThat's a nice one-liner.\
    \ But the `for i in 1..n` could be replaced with `for i in 2..n`\n<|/ c |>\n<|\
    \ c |>\nNo, that would result in counting 1-digit numbers instead of only those\
    \ that start or end with 1.\n<|/ c |>\n<| c |>\nThanks for pointing that out,\
    \ I misread the question.\n<|/ c |>\n<| c |>\nI'm guessing you missed the part\
    \ where you said \"(without using any looping)\"\n<|/ c |>\n<| a dscore=2 tags=math,haskell\
    \ |>\nThe other answers are good, but I thought I'd add another approach with\
    \ foldl (which requires building a list of counts for every digit from 0 to 9).\
    \ I'm pretty sure this is asymptotically faster than using length repeatedly because\
    \ building a list is O(n), where as foldl is O(n\xB2).\n<code>\ncount_1 n = foldl\
    \ (\\acc _ -> (acc+1, acc+1)) 0 [1..n]\n</code>\nThe lambda function takes three\
    \ parameters: a counter to accumulate counts from (starting with 0), the current\
    \ digit, and a list of digits. acc is initialized to 0 and each iteration adds\
    \ 1 to it and resets the counter to 0 if the current digit is the same. acc is\
    \ returned after the final iteration. [1..n] is the list of digits to count up\
    \ (from 1 to n), and the starting zero is passed along to foldl.\nThe result is\
    \ this list [1, 3, 6, 10, 15, 21, 28, 36, 45] where you can simply sum those to\
    \ get your count.\n<|/ a |>\n<| c |>\nThis solution is *not* asymptotically faster\
    \ than the other solutions.\n<|/ c |>\n<| c |>\nThanks for pointing that out.\
    \ I added a note about how this might affect asymptotic performance.\n<|/ c |>\n\
    <| a |>\nAnother answer without loops (but still not asymptotically faster):\n\
    <code>\ncount_1 n = sum $ [i | i <- [2..n], n == length [1..i]]\n</code>\n<|/\
    \ a dscore=", "    if n == 0 return 0\n    if n%2 == 0 then return starts_one_ends(n/2)\
    \ else return starts_one_ends(n-1) + starts_one_ends(n+1)\nend", "    \"\"\"count\
    \ numbers of positive integer that start or end with 1\"\"\"\n    count = 0\n\
    \    while  n > 1  do\n        if n%10 == 1  then\n            n = n/10\n    \
    \        count = count+1\n        else\n            n=n-1\n        end\n    end\n\
    \    return count\nend\n</code>\n<|/ a tags=julia |>\n<| a |>\n<code>", "    if\
    \ n==0 \n    then 0 \n    else if n<0 \n        then starts_one_ends(-n) \n  \
    \      else (starts_one_ends(n-1)+ends_one_starts(n-1)) \n    end\nend", "  if\
    \ n < 10 then 1 else n / 10 // starts_one_ends(n % 10) + 1\nend\n</code>\nFor\
    \ large numbers, you can use a more efficient approach by keeping a running total\
    \ of the number of digits you encounter.  In general, your algorithm needs to\
    \ look like this:\n<code>", "    if n == 0 then 0\n    else (starts_one_ends(n-1)*n)/(n-1)\n\
    end", "\"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"", " \
    \   \n    if n == 0\n        0\n    else\n        starts_one_ends(n - 1) + ends_one_starts(n\
    \ - 1)\n    end\nend\n    \n\"\"\"\n    Calculate the number of positive integers\
    \ that are divisible by 3.\n    \"\"\"", "    if n < 2 \n        return 0 \n \
    \   else if n == 3 \n        return 1 \n    else if n == 4 \n        return 2\
    \ \n    else if n == 5 \n        return 3 \n    else if n == 6 \n        return\
    \ 4 \n    else if n == 7 \n        return 5 \n    else if n == 8 \n        return\
    \ 6 \n    else if n == 9\n        return 7 \n    else if n == 10\n        return\
    \ 8\n    else if n == 11\n        return 9\n    else if n == 12\n        return\
    \ 10\n    else if n == 13\n        return 11\n    else if n == 14\n        return\
    \ 12\n    else if n == 15\n        return 13\n    else if n == 16\n        return\
    \ 14\n    else if n == 17\n        return 15\n    else if n == 18\n        return\
    \ 16\n    else if n == 19\n        return 17\n    else if n == 20\n        return\
    \ 18\n    else if n == 21\n        return 19\n    else if n == 22\n        return\
    \ 20\n    else if n == 23\n        return 21\n    else if n == 24\n        return\
    \ 22\n    else if n == 25\n        return 23\n    else if n == 26\n        return\
    \ 24\n    else if n == 27\n        return 25\n    else if n == 28\n        return\
    \ 26\n    else if n == 29\n        return 27\n    else if n == 30 \n        return\
    \ 28\n    else if n == 31 \n        return 29\n    else if n == 32\n        return\
    \ 30\n    else if n == 33\n        return 31\n    else if n == 34\n        return\
    \ 32\n    else if n == 35\n        return 33\n    else if n == 36\n        return\
    \ 34\n    else if n == 37\n        return 35\n    else if n == 38\n        return\
    \ 36\n    else if n == 39\n        return 37\n    else if n == 40 \n        return\
    \ 38\n    else if n == 41 \n        return 39\n    else if n == 42 \n        return\
    \ 40\n    else if n == 43 \n        return 41\n    else if n == 44\n        return\
    \ 42\n    else if n == 45\n        return 43\n    else if n == 46\n        return\
    \ 44\n    else if n == 47\n        return 45\n    else if n == 48\n        return\
    \ 46\n    else if n == 49\n        return 47\n    else if n == 50 \n        return\
    \ 48\n    else if n == 51 \n        return 49\n    else if n == 52 \n        return\
    \ 50\n    else if n == 53 \n        return 51\n    else if n == 54\n        return\
    \ 52\n    else if n == 55\n        return 53\n    else if n == 56\n        return\
    \ 54\n    else if n == 57\n        return 55\n    ", "    if n < 0 \n        0\n\
    \    else\n        1 + count((n-1)::Int64)\n    end\nend\n</code>\n<|/ a tags=julia,performance\
    \ |>\n<| a dscore=0 |>\n<code>", "    if n < 1 then return 0 else starts_one_ends(n-1)\
    \ + ends_one_starts(n-1)\nend", "    if n == 0 || n == 1 \n        then return\
    \ 1\n        else return 0\n</code>\n<|/ a |>\n<| c |>\nPlease give some feed-back\
    \ if you voted down this answer.\n<|/ c |>\n<| a dscore=0 tags=julia,performance,recursion\
    \ |>\nI believe that this is an example of tail recursion optimization.  In Julia,\
    \ you can use the following code to generate a list of Fibonacci numbers:\n<code>\n\
    fibs(n::Int) = fibs(1,n,1) # Base case\nfibs(x::Int,y::Int,z::Int) = (z + (y^2)^2)\
    \ if (y <= 1) # Recursive case\n    else fibs(x,y+1,z)\nfibs(x::Int,y::Int,z::Int)\
    \ = x # Non-recursive case\n</code>\n<|/ a |>\n<| c |>\nI don't understand why\
    \ you think that this is tail recursion, since tail recursion is something that\
    \ is done with the last function call, not with the previous one. I also don't\
    \ understand why this would improve the speed of the function\n<|/ c |>\n<| c\
    \ |>\nYou don't know Julia, so I thought that you could learn from this.  Tail\
    \ recursion optimization is a compiler optimization that can often be done by\
    \ the compiler, but it could also be done by the programmer.  In fact, Julia is\
    \ tail recursive in many cases.  It would be interesting if someone could comment\
    \ on Julia's implementation.\n<|/ c |>\n<| c |>\nOkay, I can see that. Anyway,\
    \ I would expect that this to be tail recursion optimized, because it could easily\
    \ do that if you had the return value instead of returning the function call.\
    \ Also the function itself does not need the last line to be executed after the\
    \ recursive call, it could be executed earlier, so I don't see any advantage to\
    \ doing that.\n<|/ c |>\n<| c |>\nThis answer doesn't make any sense to me. You\
    \ are just making a new recursive call to the same function (with different arguments).\
    \ Tail recursion optimization is the whole point of it.\n<|/ c |>\n<| c |>\nOh,\
    \ okay, sorry about that.  I haven't done tail recursion optimization before in\
    \ other languages.  I thought this was tail recursion in the languages that support\
    \ it.  I suppose it's possible that this is not tail recursion and Julia is smart\
    \ enough to optimize it.  I guess this is an example of tail recursion optimization\
    \ then.  I hope this helps.\n<|/ c |>\n<| a tags=julia,performance,recursion ",
  "\"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n\
    \    positive integers that end with 1.\n    \"\"\"", "    if n <= 1 \n      \
    \  then 0\n        else 1 + starts_one_ends(n / 10)\n    end\nend\n\"\"\"\n\"\"\
    \"", "    if n == 1 \n        then 1 \n        else starts_one_ends(n-1) + starts_one_ends(n-2)\
    \ \nend\n</cell>\n<cell>\nstarts_one_ends(4)\n</cell>\n<text>\nLet's do one more\
    \ exercise to test your function.", "    if n < 1 \n        return 0 \n    if\
    \ n == 1 \n        return 1 \n    if n > 1 \n        local start = 1 \n      \
    \  local end = 1 \n        do \n            start = start * 10 \n            end\
    \ = end + 1 \n            while end <= n \n                end *= 10 \n      \
    \  return end - start + 1 \n    end\nend", "    start = 0\n    end = n", "   \
    \ if n < 10 then return 0\n    if n > 9 then return 1\n    \n    let i = Int64.(ceil(log10(n)))\n\
    \    let count = (i-1) * (i-1)\n    \n    count..(n+1-i).filter(|x| x % i == 0).length\n\
    end\n</cell>\n<code language=julia-0.5>\n@time starts_one_ends(1_000_000)\n</cell>\n\
    <code language=julia-0.5>\n@time starts_one_ends(1_000_001)\n</cell>\n<code language=julia-0.5>\n\
    @time starts_one_ends(1_000_002)\n</cell>\n<code language=julia-0.5>\n@time starts_one_ends(1_000_003)\n\
    </cell>\n<code language=julia-0.5>\n@time starts_one_ends(1_000_004)\n</cell>\n\
    <code language=julia-0.5>\n@time starts_one_ends(1_000_005)\n</cell>\n<code language=julia-0.5>\n\
    @time starts_one_ends(1_000_006)\n</cell>\n<code language=julia-0.5>\n@time starts_one_ends(1_000_007)\n\
    </cell>\n<code language=julia-0.5>\n@time starts_one_ends(1_000_008)\n</cell>\n\
    <code language=julia-0.5>\n@time starts_one_ends(1_000_009)\n</cell>\n<code language=julia-0.5>\n\
    @time starts_one_ends(1_000_010)\n</cell>\n<code language=julia-0.5>\n@time starts_one_ends(1_000_011)\n\
    </cell>\n<code language=julia-0.5>\n@time starts_one_ends(1_000_012)\n</cell>\n\
    <code language=julia-0.5>\n@time starts_one_ends(1_000_013)\n</cell>\n<code language=julia-0.5>\n\
    @time starts_one_ends(1_000_014)\n</cell>\n<code language=julia-0.5>\n@time starts_one_ends(1_000_015)\n\
    </cell>\n<code language=julia-0.5>\n@time starts_one_ends(1_000_016)\n</cell>\n\
    <code language=julia-0.5>\n@time starts_one_ends(1_000_017)\n</cell>\n<code language=julia-0.5>\n\
    @time starts_one_ends(1_000_018)\n</cell>\n<code language=julia-0.5>\n@time starts_one_ends(1_",
  "    if n<0 \n        error(\"n must be positive\")\n    else if n == 0\n      \
    \  0\n    else if n==1 \n        1\n    else\n        digits_of(n, true) + starts_one_ends(n\
    \ - digits_of(n, true))\n    end\nend", "    if n < 0\n        return 0\n    if\
    \ n == 1\n        return 1\n    digits = ceil(log2(n))\n    one_starts = [\n \
    \       0 for _ in 1:digits\n    ]\n    one_starts[1] = 1\n    for i in 2:(digits)\n\
    \        one_starts[i] = one_starts[i-1] + 1\n    for i in 2:digits\n        one_starts[i]\
    \ = one_starts[i-1] + one_starts[i]\n    sum = 0\n    for i in 1:digits\n    \
    \    sum += one_starts[i]\n    sum += n - 1\n    return sum", "    if n <= 0 \n\
    \    then 0\n    else 1 + counts_one_ends_of_n(n-1) \nend", "    if n < 0 \n \
    \       then 0 \n    else \n        if n == 0 \n            then 1 \n        else\
    \ \n            sum((starts_one_ends(x-1) * x) \n            for x in range_of_n(n))\
    \ \nend", "    count = 0\n    for x in 1:n \n        if ((x % 10) == 1)\n    \
    \        count += 1\n        end\n    end\n    return count\nend\n</cell>\n<code\
    \ language=julia-1.4>\nstarts_one_ends(126)\n</cell>\n<code language=julia-1.4>\n\
    starts_one_ends(1001)\n</cell>\n<code language=julia-1.4>\nstarts_one_ends(1002)\n\
    </cell>\n<code language=julia-1.4>\nstarts_one_ends(10000)\n</cell>\n<code language=julia-1.4>\n\
    starts_one_ends(10990)\n</cell>\n<code language=julia-1.4>\nstarts_one_ends(10999)\n\
    </cell>\n<code language=julia-1.4>\nstarts_one_ends(110001)\n</cell>\n<code language=julia-1.4>\n\
    starts_one_ends(110002)\n</cell>\n<code language=julia-1.4>\nstarts_one_ends(110003)\n\
    </cell>\n<code language=julia-1.4>\nstarts_one_ends(110004)\n</cell>\n<code language=julia-1.4>\n\
    starts_one_ends(110005)\n</cell>\n<code language=julia-1.4>\nstarts_one_ends(110006)\n\
    </cell>\n<code language=julia-1.4>\nstarts_one_ends(110007)\n</cell>\n<code language=julia-1.4>\n\
    starts_one_ends(110009)\n</cell>\n<code language=julia-1.4>\nstarts_one_ends(110010)\n\
    </cell>\n<code language=julia-1.4>\nstarts_one_ends(110011)\n</cell>\n<code language=julia-1.4>\n\
    starts_one_ends(110012)\n</cell>\n<code language=julia-1.4>\nstarts_one_ends(110013)\n\
    </cell>\n<code language=julia-1.4>\nstarts_one_ends(110014)\n</cell>\n<code language=julia-1.4>\n\
    starts_one_ends(110015)\n</cell>\n<code language=julia-1.4>\nstarts_one_ends(119999)\n\
    </cell>\n<code language=julia-1.4>\nstarts_one_ends(100000)\n</cell>\n<code language=julia-1.4>\n\
    starts_one_ends(100001)\n</cell>\n<code language=julia-1.4>\nstarts_one_ends(100002)\n\
    </cell>\n<code language=julia-1.4>\nstarts_one_ends(100003)\n</cell>\n<code language=julia-1.4>\n\
    starts_one_ends(100004)\n</cell>\n<code language=", "    \n    \"\"\"\n    Given\
    \ a positive integer n, return the count of the numbers of n-digit\n    positive\
    \ integers that start or end with 1.\n    \"\"\"", "    count = 0\n    if n <=\
    \ 1 \n        count += 1\n        return count\n    ends = (n-1)/10\n    last\
    \ = (n-1)%10\n    while ends > 0\n        if last == 0\n            count += 1\n\
    \        ends -= 1\n        last -= 1\n    ends = (n-1)/10\n    last = (n-1)%10\n\
    \    while ends > 0\n        if last == 0\n            count += 1\n        ends\
    \ -= 1\n        last += 1\n    ends = (n-1)/10\n    last = (n-1)%10\n    while\
    \ ends > 0\n        if last == 0\n            count += 1\n        ends += 1\n\
    \        last += 1\n    ends = (n-1)/10\n    last = (n-1)%10\n    while ends >\
    \ 0\n        if last == 0\n            count += 1\n        ends -= 1\n       \
    \ last -= 1\n    ends = (n-1)/10\n    last = (n-1)%10\n    while ends > 0\n  \
    \      if last == 0\n            count += 1\n        ends += 1\n        last -=\
    \ 1\n    ends = (n-1)/10\n    last = (n-1)%10\n    while ends > 0\n        if\
    \ last == 0\n            count += 1\n        ends -= 1\n        last += 1\n  \
    \  ends = (n-1)/10\n    last = (n-1)%10\n    while ends > 0\n        if last ==\
    \ 0\n            count += 1\n        ends += 1\n        last -= 1\n    ends =\
    \ (n-1)/10\n    last = (n-1)%10\n    while ends > 0\n        if last == 0\n  \
    \          count += 1\n        ends -= 1\n        last += 1\n    ends = (n-1)/10\n\
    \    last = (n-1)%10\n    while ends > 0\n        if last == 0\n            count\
    \ += 1\n        ends += 1\n        last -= 1\n    ends = (n-1)/10\n    last =\
    \ (n-1)%10\n    while ends > 0\n        if last == 0\n            count += 1\n\
    \        ends -= 1\n        last += 1\n    ends = (n-1)/10\n    last = (n-1)%10\n\
    \    while ends > 0\n        if last == 0\n            count += 1\n        ends\
    \ += 1\n        last -= 1\n    ends = (n-1)/10\n    last = (n-1)%10\n    while\
    \ ends > 0\n        if last == 0\n            count += 1\n        ends -= 1\n\
    \        last += 1\n    ends = (n-1)/10\n    last = (n-1)%10\n    while ends >\
    \ 0\n        if last == 0\n            count += 1\n        ends += 1\n       \
    \ last -= 1\n    ends = (n-1)/10\n    last = (n-1)%10\n    while ends > 0\n  \
    \      if last == 0\n            count += 1\n        ends -= 1\n        last +=\
    \ 1\n", "    \"\"\"\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with 1.\n    \"\"\"", " \
    \   \nends_one_starts(n) = 0\nends_one_starts(1) = 1", "    if (n <= 0) return\
    \ 0\n    if (n >= 10) return 1\n    else return starts_one_ends(n - 1) + starts_one_ends(n\
    \ - 10)\nend", "    if n < 1 \n        0\n    else\n        # compute the number\
    \ of digits ending in 1\n        digits(n).ends_with(1)\nend\n</cell>\n<code language=julia-1.4>\n\
    # test starts_one_ends\nn = 122\n@time starts_one_ends(n)\n</cell>\n<text>\nExercise\
    \ 1\nGiven a positive integer n, compute the number of n-digit positive\nintegers\
    \ that start or end with 1 and whose length is no greater than \nn.", "    \"\"\
    \"\n    returns the number of positive integers that start and end with n\n  \
    \  starting from 1\n    \"\"\"", "\"\"\"\n    Given a positive integer n, return\
    \ the count of the numbers of n-digit\n    positive integers that start or end\
    \ with 1.\n\"\"\"", "    if n == 1 \n        return 1\n    else if n % 2 == 1\
    \ \n        return starts_one_ends(n - 1) + 1\n    else \n        return starts_one_ends(n\
    \ / 2) + 1\n    \n\"\"\"\n    Find the largest number of the form 10^n that is\
    \ a power of n.\n\"\"\"", "    if n<0 return 0\n    if n==1 return 1\n    if n==2\
    \ return 2\n    if n==3 return 3\n    if n==4 return 4\n    if n==5 return 5\n\
    \    if n==6 return 6\n    if n==7 return 7\n    if n==8 return 8\n    if n==9\
    \ return 9\n    if n==10 return 10\n    if n==11 return 11\n    if n==12 return\
    \ 12\n    if n==13 return 13\n    if n==14 return 14\n    if n==15 return 15\n\
    \    if n==16 return 16\n    if n==17 return 17\n    if n==18 return 18\n    if\
    \ n==19 return 19\n    if n==20 return 20\n    if n==21 return 21\n    if n==22\
    \ return 22\n    if n==23 return 23\n    if n==24 return 24\n    if n==25 return\
    \ 25\n    if n==26 return 26\n    if n==27 return 27\n    if n==28 return 28\n\
    \    if n==29 return 29\n    if n==30 return 30\n    if n==31 return 31\n    if\
    \ n==32 return 32\n    if n==33 return 33\n    if n==34 return 34\n    if n==35\
    \ return 35\n    if n==36 return 36\n    if n==37 return 37\n    if n==38 return\
    \ 38\n    if n==39 return 39\n    if n==40 return 40\n    if n==41 return 41\n\
    \    if n==42 return 42\n    if n==43 return 43\n    if n==44 return 44\n    if\
    \ n==45 return 45\n    if n==46 return 46\n    if n==47 return 47\n    if n==48\
    \ return 48\n    if n==49 return 49\n    if n==50 return 50\n    if n==51 return\
    \ 51\n    if n==52 return 52\n    if n==53 return 53\n    if n==54 return 54\n\
    \    if n==55 return 55\n    if n==56 return 56\n    if n==57 return 57\n    if\
    \ n==58 return 58\n    if n==59 return 59\n    if n==60 return 60\n    if n==61\
    \ return 61\n    if n==62 return 62\n    if n==63 return 63\n    if n==64 return\
    \ 64\n    if n==65 return 65\n    if n==66 return 66\n    if n==67 return 67\n\
    \    if n==68 return 68\n    if n==69 return 69\n    if n==70 return 70\n    if\
    \ n==71 ", "    \"\"\"\n    Given a positive integer n, return the count of the\
    \ numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\
    \"", "    if n<1 \n        error(\"n must be positive\") \n    else if n==1 \n\
    \        1\n    else \n        starts_one_ends(n-1)\n    ends_one_starts(n-1)\n\
    end\n</code>\nThe reason I say this is that:\n<code>\nstarts_one_ends(10) == ends_one_starts(10)\n\
    </code>\nso I wrote a recursive function.\nI hope this helps.\n<|/ a dscore=0\
    \ tags=recursion,big-o,time-complexity,julia |>\n<| c |>\nThis solution is O(n\
    \ log n) instead of O(n) like my solution but more efficient. Still, it doesn't\
    \ work in Julia. Perhaps I should post a new question about this issue. Thanks\
    \ for the help.\n<|/ c |>\n<| a dscore=0 |>\nI wrote my own version in Julia,\
    \ but this is probably more efficient than others answers:\n<code>", "    if n\
    \ < 10 \n        then return 1 \n        else if n < 100 \n            then return\
    \ 2 \n            else return 3 \n    else \n        let  s = starts_one_ends(n/10)\
    \ + 1 \n        in s if n % 10 == 1\n           then s + 1 \n           else s\
    \ \nend", "    summ = 0\n    for i in 1 .. n do \n        if i mod i == 1 then\
    \ \n            summ += 1 \n        end\n    end\n    return summ\nend", "   \
    \ if n <= 0\n        0\n    elseif n <= 10\n        n\n    else\n        count(n)\
    \ - sum(starts_one_ends(x - 10) for x in starts_one_ends(10))\n    end\nend\n\"\
    \"\"\nGiven a positive integer n, return all the n-digit positive\n    integers\
    \ that start or end with 1.\n    \"\"\"", "    if n == 1 \n        then 0 \n \
    \   else \n        counts_one_ends(n-1) \n    end\nend\n\"\"\"\n    We use these\
    \ functions to count the number of numbers from 1 to n\n    which start or end\
    \ with 1.", "    if n == 0 \n        then 0\n    else if n == 1\n        then\
    \ 1\n    else if n % 10 == 1\n        then 1 + (starts_one_ends(floor(n/10)) -\
    \ 1)\n    else if n % 10 == 2\n        then 1 + (starts_one_ends(floor(n/10))\
    \ - 1) + starts_one_ends(floor(n/100))\n    else if n % 10 == 3\n        then\
    \ 1 + (starts_one_ends(floor(n/10)) - 1) + starts_one_ends(floor(n/100)) + (starts_one_ends(floor(n/1000))\
    \ - 1) \n    else \n        1 + (starts_one_ends(floor(n/10)) - 1) + starts_one_ends(floor(n/100))\
    \ + (starts_one_ends(floor(n/1000)) - 1) + starts_one_ends(floor(n/10000)) - 1\
    \ \nend\n</cell>\n<code language=julia-1.6>\n@time starts_one_ends(1_000_000_000);\n\
    </cell>\n<text>\nThe previous result was in seconds, which was about a minute,\
    \ which is certainly not enough to count all prime numbers between 1 and 1,000,000,000.\
    \  We can also do better:", "    if n<0 \n        return 0 \n    else \n     \
    \   return (n//100)==(n%100//10)==(n%100%10)==1\nend", "  if n < 0 then 0 else\
    \ countOnes(min(n,1000)) + 1\nend", "    if n < 1 \n        return 0 \n    n -=\
    \ 1\n    count = 0\n    while n > 1 \n        count += n \n        n /= 10 \n\
    \    return count", "    if n < 10 \n        then return 1 \n        else return\
    \ 0", "    if n<0 \n    then 0 \n    else count_digits(n) \n    end\nend", " \
    \   if n <= 0\n        then return 0\n    else \n        sum = 0\n        for\
    \ i in 1 .. n\n            if i % 10 == 1\n                then return sum\n \
    \           else sum += 1 \n    end\nend\n</cell>\n<code language=julia-0.6>\n\
    @assert starts_one_ends(0) == 0\n@assert starts_one_ends(1) == 0\n@assert starts_one_ends(2)\
    \ == 1\n@assert starts_one_ends(3) == 2\n@assert starts_one_ends(4) == 1\n@assert\
    \ starts_one_ends(5) == 2\n@assert starts_one_ends(10) == 3\n@assert starts_one_ends(17)\
    \ == 4\n@assert starts_one_ends(24) == 3\n@assert starts_one_ends(100) == 4\n\
    @assert starts_one_ends(999) == 4\n@assert starts_one_ends(1000) == 4\n@assert\
    \ starts_one_ends(10000) == 5\n@assert starts_one_ends(100000) == 5\n@assert starts_one_ends(1000000)\
    \ == 5\n@assert starts_one_ends(100000000) == 6\n@assert starts_one_ends(1000000000)\
    \ == 6\n</cell>\n<text>\n12. Counting congruences in the Fibonacci sequence\n\
    A common interview question is:", "    if n < 0 \n        error(\"negative argument\
    \ to starts_one_ends\")\n    ends_one_starts(n)\nend\n</cell>\n<code language=julia-1.1>\n\
    ## now let's test our implementation\nstarts_one_ends(10)\n</cell>\n<text>\nTo\
    \ make our counting function more efficient, we'll memoize it. This will let us\
    \ run it multiple times with different arguments, saving us the overhead of repeatedly\
    \ searching for the same combination in our hash table. Let's write this in Julia\
    \ syntax and then explain what it's doing:", "    if (n < 1) \n        return\
    \ 0\n    if (n == 1) \n        return 1\n    return 1 + starts_one_ends(floor((n\
    \ + 1) / 2))\nend\n</cell>\n<code language=julia-1.5>\nstarts_one_ends(1)\n</cell>\n\
    <code language=julia-1.5>\nstarts_one_ends(10)\n</cell>\n<code language=julia-1.5>\n\
    starts_one_ends(100)\n</cell>\n<code language=julia-1.5>\nstarts_one_ends(1000)\n\
    </cell>\n<code language=julia-1.5>\nstarts_one_ends(10000)\n</cell>\n<text>\n\
    Problem 3\nA generator function can easily produce an infinite sequence of numbers.\
    \ For instance, if we use an infinite list of numbers between 1 and 100, we can\
    \ compute the sum of the numbers up to $n$.", "    \"\"\"\n    Given a positive\
    \ integer n, return the count of the numbers of n-digit\n    positive integers\
    \ that start or end with 1.\n    \"\"\"", "    if n == 0 \n        return 0 \n\
    \    else if n == 1 \n        return 1 \n    else \n        return starts_one_ends(n-1)\
    \ + ends_one_starts(n-1) \nend\n\"\"\"\n    Given a positive integer n, return\
    \ the count of the numbers of n-digit\n    positive integers that end with 1.\n\
    \    \"\"\"", "    if n <= 0 \n        return -1\n    if n == 1 \n        return\
    \ 1\n    return starts_one_ends(n-1) + ends_one_starts(n-1)", "    if n == 0 \n\
    \        then 1\n        else sum(starts_one_ends(i-1) for i in 1 .. n) \nend\n\
    </cell>\n<code language=julia-1.5>\nstarts_one_ends(10)\n</cell>\n<code language=julia-1.5>",
  "  if n == 0 \n    else \n      if n == 1 \n        then 1 \n        else starts_one_ends(n-1)\
    \ + ends_one_starts(n-1) \n  else \n    starts_one_ends(n-1) + ends_one_starts(n-1)\n\
    end", "    count::Int64 = 0\n    for x in 1..n\n        if x == 1\n          \
    \  count += 1\n        end\n    end\n    return count\nend", "    if n < 10 \n\
    \        then 1 else 0\n    else if n == 1\n        then starts_one_ends(n-1)\
    \ else starts_one_ends(n-1) + starts_one_ends(n-2)\nend\n\"\"\"\n    Use this\
    \ function to count all n-digit positive integers that start or end\n    with\
    \ 1.\n    \"\"\"", "    if n==0\n        then return 0\n    else return count((1,n),(1,n))\n\
    end", "    return sum(map(lambda x: (x==1) or (x==-(n-1)), range(1,n)))\nend\n\
    </cell>\n<cell>\nstarts_one_ends(9::Int64)\n</cell>\n<text>\nThe count of fibonacci\
    \ numbers that start with 1 or end with 1 is $C(F(1) + F(2), 2)$.", "    if n<=1\n\
    \        count = 0\n    else\n        count = n_digits(n) - 1\n    end\nend\n\
    </cell>\n<code language=julia-1.0>\n\"\"\"\n    Given an even integer n, return\
    \ the count of the numbers of n-digit\n    positive integers that start or end\
    \ with 1.\n    \"\"\"", "    if n==1\n    else if n==-1\n    else if n==0\n  \
    \  else if n>0\n    else if n<0\n    else if n==2\n    else if n==-3\n    else\
    \ if n==-2\n    else if n==-1\n    else if n==1\n    else if n==2\n    else if\
    \ n==-3\n    else if n==-2\n    else if n==-1\n    else if n==1\n    else if n==2\n\
    \    else if n==-3\n    else if n==-2\n    else if n==-1\n    else if n==1\n \
    \   else if n==2\n    else if n==-3\n    else if n==-2\n    else if n==-1\n  \
    \  else if n==1\n    else if n==2\n    else if n==-3\n    else if n==-2\n    else\
    \ if n==-1\n    else if n==1\n    else if n==2\n    else if n==-3\n    else if\
    \ n==-2\n    else if n==-1\n    else if n==1\n    else if n==2\n    else if n==-3\n\
    \    else if n==-2\n    else if n==-1\n    else if n==1\n    else if n==2\n  \
    \  else if n==-3\n    else if n==-2\n    else if n==-1\n    else if n==1\n   \
    \ else if n==2\n    else if n==-3\n    else if n==-2\n    else if n==-1\n    else\
    \ if n==1\n    else if n==2\n    else if n==-3\n    else if n==-2\n    else if\
    \ n==-1\n    else if n==1\n    else if n==2\n    else if n==-3\n    else if n==-2\n\
    \    else if n==-1\n    else if n==1\n    else if n==2\n    else if n==-3\n  \
    \  else if n==-2\n    else if n==-1\n    else if n==1\n    else if n==2\n    else\
    \ if n==-3\n    else if n==-2\n    else if n==-1\n    else if n==1\n    else if\
    \ n==2\n    else if n==-3\n    else if n==-2\n    else if ", "    if n < 0 \n\
    \        error(\"n must be positive\", ExitCodes.ExitFailure) \n    else \n  \
    \      return sum( (n % 10) == 1 ) \nend", "    if n <= 0\n    then return -1\n\
    \    else return n / 10 + starts_one_ends(n%10)\n    end\nend\n</cell>\n<code\
    \ language=julia-1.4>\nstarts_one_ends(12321)\n</cell>\n<code language=julia-1.4>\n\
    starts_one_ends(0)\n</cell>\n<code language=julia-1.4>\nstarts_one_ends(10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
  "    if n == 0 \n        then return 0\n        else return counts_starts_one_ends(n-1)\
    \ + counts_starts_one_ends(n+1)\n    end\nend\n\"\"\"\nGiven a positive integer\
    \ n, return the count of the numbers of n-digit\npositive integers that start\
    \ with 0.\n\"\"\"", "    if n == 0 \n        then return 0\n    else if n % 2\
    \ == 1 \n        then return 1\n    else return 1 + starts_one_ends(n / 2)", " \
    \   if n < 1 \n        return 0 \n    else \n        return binomial(n.digits(),\
    \ 1) + starts_one_ends(n.digits() - 1) \nend \n\"\"\"\n    Given a positive integer\
    \ n, return the count of the numbers of n-digit\n    positive integers that start\
    \ with 1.\n    \"\"\""]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
