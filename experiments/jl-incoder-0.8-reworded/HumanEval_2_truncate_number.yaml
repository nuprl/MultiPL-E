name: HumanEval_2_truncate_number
language: jl
prompt: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
  \    and integer part (largest integer smaller than given number) and decimals\n\
  \    (leftover part always smaller than 1).\n\n    Return the decimal part of the\
  \ number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
  \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
  end\n"
completions: ["    int_part = ceil(number::Int64)\n    frac_part = floor((number -\
    \ int_part)::Float64)\n    return frac_part\n</code>\n<|/ a dscore=5 tags=julia\
    \ |>\n<| c |>\nThis is not correct. Example: `truncate_number(3.5)`  returns `1.5`.\n\
    <|/ c |>\n<| c |>\nIt works, see [this image](https://s11.postimg.org/z2j6u6mz1/truncate_number.png).\n\
    <|/ c |>\n<| c |>\n`ceil` should only be used on integers. `trunc` is an alias\
    \ for that function\n<|/ c |>\n<| c |>\nI see! Thanks for sharing! :)\n<|/ c |>\n\
    <| a dscore=5 |>\nThere is trunc() in base:\n<code>\njulia> trunc(0.2)\n0.2\n\
    </code>\n<|/ a tags=julia |>\n<| c |>\nThis should be the accepted answer, as\
    \ it is the most straightforward and straightforward of the answers here.\n<|/\
    \ c |>\n<| a tags=julia |>\nYou could also use the floor() or ceil() functions\
    \ of Julia. \n<code>\njulia> floor(3.5)\n3", "    truncNum = ceil(number)\n  \
    \  if number >= truncNum\n        return number\n    \n    truncNum = floor(number)\n\
    \    if number > truncNum\n        return truncNum\n    \n    return truncNum\
    \ - number\nend", "    \n    \"\"\"\n    Truncate a floating point number.\n \
    \   \n    Truncate a floating point number given as argument and return the truncated\
    \ part.\n    \n    Exceptions raised:\n    \n    Exception if given number is\
    \ less than zero or negative\n    Exception if given number is greater than one\n\
    \    \n    \n    >>> truncate_number(-2.5) == -2.5\n    True\n    >>> truncate_number(-3.5)\
    \ == -3.5\n    True\n    \"\"\"\n</code>\nNow let's write a function that converts\
    \ a decimal number to an integer.\nThe first thing we want to do is to round the\
    \ decimal number to the nearest integer and truncate any decimal part at the very\
    \ end of the number. So the function that does this is truncate_number:\n<code>\n\
    \"\"\"\nTruncate a floating point number.\n    \n    Truncate a floating point\
    \ number given as argument and return the truncated part.\n    \n    Exceptions\
    \ raised:\n    \n    Exception if given number is less than zero or negative\n\
    \    Exception if given number is greater than one\n    \n    \n    >>> truncate_number(-2.5)\
    \ == -2.5\n    True\n    >>> truncate_number(-3.5) == -3.5\n    True\n    \"\"\
    \"", "    \"\"\" Given a positive floating point number, it can be decomposed\
    \ into\n    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).", "    \"\"\"\n    Truncate a number\
    \ to 2 decimal places.", "    number, decimal = divround(number, 10)\n    return\
    \ number\n</code>\n<|/ a tags=julia |>\n<| a tags=julia |>\nI think this does\
    \ the job using single function and no if-else blocks.\n<code>\njulia> function\
    \ truncate_number(number)\n           digits = ceil(Int, log10(number))\n    \
    \       number = round(number, digits)\n           if number == 0\n          \
    \     return 0\n           end\n           return number\n       end\ntruncate_number\
    \ (generic function with 1 method)", "    return trunc((number::Float64).round())\n\
    end", "    \"\"\"\n    Function that truncates a floating point number to an exact\
    \ decimal\n    representation.", "    trunc1 = truncate_decimal(number)\n    return\
    \ trunc1\nend", "    \"\"\"\n    Given a positive floating point number, it can\
    \ be decomposed into\n    and integer part (largest integer smaller than given\
    \ number) and decimals\n    (leftover part always smaller than 1).", "    precision\
    \ = round(log10(number) + 1)\n    return number / pow(10, precision)\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert truncate_number(3.1) == 2 \"Your function should\
    \ work\"\n</cell>\n<code language=julia-1.5>\n@assert truncate_number(3.6) ==\
    \ 1.6 \n</cell>\n<code language=julia-1.5>\n@assert truncate_number(3.3) == 1.333333333\n\
    </cell>\n<code language=julia-1.5>\n@assert truncate_number(3.4) == 1.4\n</cell>\n\
    <code language=julia-1.5>\n@assert truncate_number(3) == 3\n</cell>\n<code language=julia-1.5>\n\
    @assert truncate_number(4.1) == 2.4\n</cell>\n<text>\nChallenge 2.\nWrite a function\
    \ that computes the area of a given rectangle given the lengths and widths of\
    \ the sides. For example, given lengths of sides 4 and 5, and widths of sides\
    \ 2 and 3, the area is (4 * 2 + 4 * 3) * 5 / 2 = 20", "    \"\"\"\n    \n    Given\
    \ a positive floating point number, it can be decomposed into\n    and integer\
    \ part (largest integer smaller than given number) and decimals\n    (leftover\
    \ part always smaller than 1).", "end\n</cell>\n<text>\nWe can now test the function\
    \ we just wrote, by applying it to a bunch of random numbers, to see that we get\
    \ the expected output.", "</code>\n<|/ a |>\n<| c |>\nPlease add some explanation\
    \ alongside.\n<|/ c |>\n<| c |>\nWhile this code may answer the question, providing\
    \ additional context regarding why and/or how this code answers the question improves\
    \ its long-term value.\n<|/ c |>\n<| a |>\nHere's my version using Julia's built-in\
    \ packages, just in case you haven't seen it before.  \nThe function takes an\
    \ array of numbers and returns the median of the numbers.\n<code>", "\"\"\"Given\
    \ a positive floating point number, it can be decomposed into\n    and integer\
    \ part (largest integer smaller than given number) and decimals\n    (leftover\
    \ part always smaller than 1).", "    if number == 0.0:\n        return number\n\
    \    if number == 1.0:\n        return number\n    \n    power = int(math.log(number,\
    \ 10))\n    number = number / 10.**power\n    \n    return number", "    digits\
    \ = truncate_number(number)\n    frac = number % digits\n    integer := digits-frac\n\
    \    if frac == 0 && integer >= 0\n        then integer\n        else 0\n    end\n\
    end\n</cell>\n<code language=julia-0.6>", "\"\"\"\n    Return the decimal part\
    \ of the number.", "    integer :: integer_part\n    decimals :: decimals_part\n\
    \    decimals_part = floor(number % 1)\n    integer_part = floor(number / 1)\n\
    \    return decimals_part * 100 + integer_part\nend function\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.501)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(3.9999)\n</cell>\n<text>\n\
    Julia includes several built-in functions to do some basic numerical calculations\
    \ like dot product and matrix multiplication.", "    if number < 0.0:\n      \
    \  number = -number\n    return math.trunc(number)\nend\n</cell>\n<code language=julia-1.5>\n\
    # TEST truncate_number (3b)\n@test truncate_number(3) == truncate_number(2.5)\n\
    @test truncate_number(3.5) == truncate_number(2.5)\n@test truncate_number(3.9999)\
    \ == truncate_number(3.5)\n@test truncate_number(1.234) == truncate_number(1)\n\
    @test truncate_number(-1.234) == truncate_number(-1)\n@test truncate_number(1)\
    \ == truncate_number(0)\n@test truncate_number(-1) == truncate_number(0)\n</cell>\n\
    <text>\nConverting Numbers to Strings", "    int_part = floor(number)\n    decimal\
    \ = number - int_part\n    return decimal\nend", "    if number < 1.0\n      \
    \  return number\n    if number < 10.0\n        return truncate_number(number\
    \ - 1./10.)\n    \n    if number < 100.0\n        return truncate_number(number\
    \ - 1./100.)\n    \n    if number < 1e4\n        return truncate_number(number\
    \ - 1./1e4.)\n    \n    if number < 1e5\n        return truncate_number(number\
    \ - 1./1e5.)\n    \n    if number < 1e6\n        return truncate_number(number\
    \ - 1./1e6.)\n    \n    if number < 1e7\n        return truncate_number(number\
    \ - 1./1e7.)\n    \n    if number < 1e8\n        return truncate_number(number\
    \ - 1./1e8.)\n    \n    if number < 1e9\n        return truncate_number(number\
    \ - 1./1e9.)\n    \n    if number < 1e10\n        return truncate_number(number\
    \ - 1./1e10.)\nend", "    trunc_num = truncate_decimals(number)\n    trunc_num\
    \ = trunc_num / (trunc_num > 0 ? 1 : 0)\n    return trunc_num\nend\n</cell>\n\
    <code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<text>\nround", "  \
    \  if number == 0.0:\n        return 0.0\n    if number == 1.0:\n        return\
    \ 1.0\n    if number == -1.0:\n        return -1.0\n    digits = int(math.ceil(math.log10(number)))\n\
    \    if digits in [1, 2, 3]:\n        return number\n    else:\n        return\
    \ number / 10**(digits-1)", "    \"\"\"\n    Truncates the given floating point\
    \ number to the nearest integer.", "    decimal_part = floor(log10(number))\n\
    \    integer_part = trunc(number)\n    return number/10^decimal_part\nend\n</cell>\n\
    <text>\nTest it out!\nThe cell below is supposed to return the value $\\frac{1+\\\
    sqrt{5}}{1-\\sqrt{5}}$. Feel free to put your solution in the cell below.", " \
    \ \n    fractional_part = number - truncate_number(floor(number))\n    decimal\
    \ = fractional_part", "  Float64(trunc(number))\nend", "    num = float(number)\n\
    \    integer = num // 1\n    remainder = num % 1\n    return integer, remainder",
  "\"\"\"\n  \n\"\"\"\n    truncate_number(number::Float32)::Float32\n\"\"\"", '    return
    (number - truncate_number(floor(number))) * truncate_number(1::Float64)', "  \
    \  biggest(Float64(0), Float64(number))\nend", "    digits = floor(log10(number))\n\
    \    factor = pow(10, digits)\n    round_number = round(number * factor) / factor\n\
    \    return round_number\nend\n</cell>\n<code language=julia-0.6>\ntruncate_number(3.5)\n\
    </cell>\n<text>\nNow, let's write a function to generate a new random number generator\
    \ with the same initial state as the old one:", "    # truncate decimal part if\
    \ needed\n    number = ceil(number)\n    number = floor(number)\n    # return\
    \ integer part of number\n    truncate_decimal = floor(log10(number))\n    # rounding\
    \ down to truncate decimal\n    number = floor(number / pow(10, truncate_decimal))\n\
    \    # return decimal part of number\n    return number * 10^truncate_decimal\n\
    end\n</cell>\n<code language=julia-1.3>", "    \n    # Return number\n    return\
    \ number\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nA simple one-line solution\
    \ is using floor(). \nfloor() returns a number which is equal to the integer part\
    \ of the input. \nfloor(x/y) = x - y*floor(x/y)\nSo if we want to get the fractional\
    \ part, we just use x - (y+1)*floor(x/y). \n<code>\nx = 0.5;\ny = 0.1; ", "  \
    \  return (number - truncate_number(floor(number))) / (truncate_number(1) - 1)\n\
    end\n</code>\n<code>\njulia> truncate_number(3.5)\n0.5\n</code>\n<|/ a tags=julia,floating-point\
    \ |>\n<| a dscore=2 tags=julia,floating-point |>\nThis solution works with both\
    \ positive and negative numbers.\n<code>", "    \"\"\"\n    Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).", "    integer = trunc(number)\n    fraction = number - integer\n    if\
    \ number == integer\n        integer = 0.0\n    end\n    return fraction / (end\n\
    </cell>\n<text>\nDecompose the number into integer and fractional parts, separately.\
    \ The result is returned as a tuple.", "    float_digits(number)\n    number =\
    \ number % 1\n    number_digits(number)\n    \n    return number\n</code>\n<|/\
    \ a |>\n<| a dscore=1 tags=julia,rounding |>\nIn case someone is interested in\
    \ Julia 0.5 solution:\n<code>\nusing Statistics", "    if number == 0\n      \
    \  error(\"Cannot truncate number 0\")\n    end\n    abs_number = abs(number)\n\
    \    number = Int(abs_number)\n    abs_remainder = abs_number % number\n    abs_remainder,\
    \ last_digit = truncate_number_digits(abs_remainder)\n    number = number / last_digit\n\
    \    \n    if abs_remainder != 0\n        error(\"Cannot truncate number\")\n\
    \    end", "    precision = floor(log10(number))\n    number = round(number, precision)\n\
    \    number = number / 10^precision\n    return number\nend\n</cell>\n<text>\n\
    The function above was adapted from :", "    float_str = Float64(number)\n   \
    \ decimal_index = float_str.find(\"/\") + 1\n    integer_part = float_str[..(decimal_index\
    \ - 1)]\n    decimal_part = float_str[decimal_index..end]\n    return Float64(integer_part\
    \ + \".\" + decimal_part)\nend", "    \"\"\"\n    Given a positive floating point\
    \ number, it can be decomposed into\n    and integer part (largest integer smaller\
    \ than given number) and decimals\n    (leftover part always smaller than 1).",
  "    return number % 1\nend", "    # Make sure that number is positive\n    if number\
    \ > 0 then\n        # Compute the least integer larger than the given number\n\
    \        integer_part = floor(number)\n        # Compute the decimal part\n  \
    \      decimal_part = number- integer_part\n        if decimal_part > 0 then\n\
    \            return truncate_number(decimal_part)\n        end\n    end\n    return\
    \ number\nend\n</cell>\n<code language=julia-1.4>\n### Test your function\n@test\
    \ truncate_number(3.4) == 3\n@test truncate_number(-3.4) == 3\n</cell>\n<code\
    \ language=julia-1.4>\n### Next functions are for you to fill in. Here we define\
    \ a function `is_positive(x::Float64)` that \n### returns true if the given number\
    \ `x` is positive, and false otherwise.", "    \"\"\"\n    Return the decimal\
    \ part of the number.", "    return (number - floor((number - number::Float64)\
    \ / 1::Float64))\nend\n</cell>\n<text>\nTruncate number", "    \n    if number\
    \ < 1e-6\n        return number\n    \n    decimal_part = floor((number - floor(number))\
    \ * 100)\n    \n    if abs(decimal_part) == 100\n        return floor(number)\n\
    \    else\n        return number", "    if number == 0.\n        number = 0.\n\
    \    end\n    return number\nend", "    truncate_number_helper(number)\nend\n\
    </code>\n<|/ a tags=julia,dataframe,julia-dataframe |>\n<| c |>\nThis works well\
    \ for my purposes. I needed to do this because I needed the decimal part of a\
    \ large float to compare against another float which is already rounded to 4 decimal\
    \ places. Thanks for the help\n<|/ c |>\n<| a dscore=2 |>\nI haven't seen an answer\
    \ that didn't involve a loop.  So here it is.  I hope this helps someone else\
    \ looking for the same answer.  \nI added a helper function truncate_number which\
    \ accepts a Float64 and returns the number without its decimal part:\n<code>\n\
    truncate_number(number::Float64) = (trunc(number) == number) ? number : number\
    \ - round(number)  ", "    trunc_number = floor((number * 10) + 0.5) / 10\n  \
    \  return trunc_number\nend\n</code>\n<|/ a dscore=1 tags=julia |>\n<| c |>\n\
    Thanks for the answer! The only issue I'm having is when I try to use it, truncate_number\
    \ is not defined. I tried using Base.truncate_number but that didn't work either.\
    \ Any idea on why that is?\n<|/ c |>\n<| c |>\nYou have to add it into your file.\
    \ For example, you can add it into your julia base file: `include(\"truncate_number.jl\"\
    )`.\n<|/ c |>\n<| c |>\nFor some reason it still says that truncate_number isn't\
    \ defined. I think it has to do with my packages because I installed the truncate_number.jl\
    \ package with the command \"Pkg.add(\"TruncateNumber\")\".\n<|/ c |>\n<| c |>\n\
    I think you do not need to add it into packages. Just simply write in your julia\
    \ script: `truncate_number(3.5)`. And it will work.\n<|/ c |>\n<| c |>\nAh, I\
    \ see, thanks. I just ran the function and it returned 3.5, which is great! But\
    \ then when I put that code into a function it no longer works. So for example\
    \ if I put a line of code like this into my script:", "    if number > Int(number)\n\
    \        return Int(number) % 1\n    else\n        return number\nend", "    if\
    \ number > Float64(1) then\n        digits = floor(log10(number))\n        number\
    \ = round(number / Float64(10^digits))\n    end\n    return number\nend\n</cell>\n\
    <text>\nHere we apply truncate_number to all elements in our array, and then sum\
    \ them up. We use Float64 for our numbers, since it can handle very large numbers.",
  "    \"\"\"\n    \"\"\"", "    float_part = ceil(number)\n    int_part = floor(number)\n\
    \    decimal_part = number - float_part\n    return decimal_part / pow(10, int_part)",
  "    return (number-truncate(number))\nend \n</cell>\n<code language=julia-0.6>\n\
    truncate_number(3.5)\n</cell>\n<text>\nExercise 4: Get and plot a histogram\n\
    You might find this exercise useful to understand the basic functionality of distributions",
  "  return trunc(number)\nend", "    return trunc(number)\nend\n</cell>\n<text>\n\
    Now the truncate function will round your floating point number to a whole number.\
    \ Let's try it with the example from above:", "    \"\"\"\n    Return the decimal\
    \ part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\ndef\
    \ truncate_number(number::Float32)::Float32 \n    \"\"\"\n    Return the decimal\
    \ part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", " \
    \   if number % 1 == 0.0:\n        return number\n    else:\n        return number\
    \ - truncate_number(number/1)\n</code>\n<|/ a tags=floating-point,r dscore=5 |>\n\
    <| c |>\nthis only works correctly with very small numbers. try with 0.999999\n\
    <|/ c |>\n<| c |>\nYes, it does. I checked 0.99999 and 0.999999 and both give\
    \ the same result.\n<|/ c |>\n<| c |>\nThis is the most simple and effective solution.\
    \ Just convert number to string and replace decimal separator, that is what I\
    \ was looking for\n<|/ c |>\n<| c |>\nI did some testing and it seems to work\
    \ correctly for all `numbers` except `0.99999`. For this value, it returns `0.99999`\
    \ instead of `0.999` as expected.\n<|/ c |>\n<| c |>\nI updated my answer. Thanks\
    \ for your input.\n<|/ c |>\n<| a tags=floating-point,r |>\nYou can use the trunc\
    \ function:\n<code>\ntrunc(x/y)\n</code>\nFor example to truncate 0.5 to its integer\
    \ part and 0.99999 to its decimal part:\n<code>\n> x <- 0.5\n> y <- 0.99999\n\
    > trunc(x/y)\n[1] 0\n> trunc(0.9999/y)\n[1] 0\n</code>\n<|/ a dscore=5 |>\n<|\
    \ a dscore=5 |>\nAnother way is to convert it to a string and then substract it\
    \ form a blank string like that\n<code>\nnum <- 0.000000095\nnum <- gsub('[.]',\
    \ '', sprintf('%g', num))\n</code>\n<|/ a tags=floating-point,r |>\n<| c |>\n\
    I like this solution, because it does not require an additional library.\n<|/\
    \ c |>\n<| c |>\nTo avoid the rounding issues, just use `num <- gsub('[.]', '',\
    \ sprintf('%06.4f', num))`\n<|/ c |>\n<| c |>\nThis solution doesn't work for\
    \ negative numbers, e.g. `num <- -0.000000095` returns `-0.00` instead of `-0.09`.\
    \ See also https://stackoverflow.com/a/53948727/6366560 for another solution (with\
    \ `round`).\n<|/ c |>\n<| a dscore=4 |>\nThe package truncer provides one solution:\n\
    <code>\n> library(truncer)\n> trunc(1.1)\n[1] 1\n> trunc(1.10)\n[1] 1", "    return\
    \ number < 0 ? number - 0.5 : number\nend ", "    \"\"\"This function truncates\
    \ any decimal part of a number to the \n    largest integer smaller than or equal\
    \ to the given number.", "    return floor(number::Float64) / 1\n</code>\n<|/\
    \ a tags=math,python |>\n<| a tags=math,python |>\nYou could round and truncate\
    \ to integer:\n<code>\nnumber = 0.32\nx = int(round(number))\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\n`round` is an `int` function, so why are you using `round` instead\
    \ of `truncate`?\n<|/ c |>\n<| c |>\nAh yes, that's true. I was just trying to\
    \ be explicit. I'll edit.\n<|/ c |>\n<| c |>\n`round` rounds according to the\
    \ given decimal point. For example, `round(3.1)` rounds to 4, while `round(3.2)`\
    \ rounds to 3.\n<|/ c |>\n<| c |>\n: no, round rounds to *nearest* integer, not\
    \ round to nearest integer in the given direction. For example, `round(3.5)` is\
    \ `4`, and `round(3.4)` is `3`.\n<|/ c |>\n<| a tags=math,python |>\nIf you want\
    \ a function that returns a number rounded to the closest integer regardless of\
    \ fractional part, you could use the following function:\n<code>\ndef truncate_number(number):\n\
    \    return int(round(number))\n</code>\nFor example,\n<code>\n>>> truncate_number(3.5)\n\
    3\n>>> truncate_number(3.1)\n3\n>>> truncate_number(3.3)\n3\n>>> truncate_number(3.6)\n\
    4\n</code>\nIf you want to return integers less than the original number, you\
    \ could use floor instead of round as follows:\n<code>\ndef truncate_number(number):\n\
    \    return int(math.floor(number))\n</code>\nFor example,\n<code>\n>>> truncate_number(3.5)\n\
    2\n>>> truncate_number(3.1)\n2\n>>> truncate_number(3.3)\n2\n>>> truncate_number(3.6)\n\
    3\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe `round` function rounds according\
    \ to the given decimal point. For example, `round(3.1)` rounds to 4, while `round(3.2)`\
    \ rounds to 3.\n<|/ c |>\n<| c |>\n: no, round rounds to *nearest* integer, not\
    \ round to nearest integer in the given direction. For example, `round(3.5)` is\
    \ `4`, and `round(3.4)` is `3`.\n<|/ c |>\n<| c |>\nRight. You're right, I didn't\
    \ even think of that. I fixed my answer to include `floor`.\n<|/ c |>\n<| a dscore=0\
    \ tags=math,python |>\n<code>\ndef truncate_number(number", "    num = abs(number)\n\
    \    return floor(num * 10^floor(log10(num)))/10^floor(log10(num))\nend", "  \
    \  \n    integer = trunc(number)\n    decimal = number - integer\n    return integer::Float64\
    \ + decimal\nend \"\"\"", "    digits = floor(log10(number))+1\n    decimals =\
    \ digits-floor(digits)\n    truncate_digits = floor(number*10^(digits-1))\n  \
    \  return truncate_digits/10^decimals", "    num = num::Float64\n    digits =\
    \ digits::Int\n    digits = truncate_digits(digits)\n    frac = num - truncate_fraction(num)\n\
    \    integral = truncate_digits(frac / digits)\n    return integral + frac * digits\n\
    end\n</cell>\n<code language=julia-1.1>\nx = truncate_number(4.3)\n</cell>\n<code\
    \ language=julia-1.1>\ntruncate_number(4.6)\n</cell>\n<code language=julia-1.1>\n\
    truncate_number(4.6)\n</cell>\n<code language=julia-1.1>\ntruncate_number(4.9)\n\
    </cell>\n<code language=julia-1.1>\ntruncate_number(4.9)\n</cell>\n<code language=julia-1.1>\n\
    truncate_number(5.9)\n</cell>\n<code language=julia-1.1>\ntruncate_number(5.9)\n\
    </cell>\n<code language=julia-1.1>\ntruncate_number(5.3)\n</cell>\n<code language=julia-1.1>\n\
    truncate_number(5.3)\n</cell>\n<text>\nTest your functions", "    \n    if number\
    \ == 0.0 \n        { return 0.0 }\n    \n    number = math.floor(number)\n   \
    \ fraction = number - math.floor(number)\n    \n    if number == 0.0 \n      \
    \  { return 0 }\n    \n    return fraction", "    float_part = number % 1\n  \
    \  int_part = floor(number)\n    dec_part = number - int_part\n    if dec_part\
    \ > 0.0\n        return float_part + truncate_number(dec_part)\n    return float_part\n\
    end", "    trunc(number::Float64)\n    ", "    \"\"\"\n    Define the truncated\
    \ function which returns the truncated version of the given floating point number.\n\
    \    >>> truncate_number(1.5)\n    1.0\n    \"\"\"", "    int_part = truncate_decimals(number)\n\
    \    return number - int_part", "    \"\"\"\n    Truncate the number to its decimal\
    \ part (the part not exceeding 1).\n    >>> truncate_number(4.8)\n    4.5\n  \
    \  \"\"\"", "    integer = ceil(number)\n    decimal = number - integer\n    return\
    \ decimal\nend\n</code>\nTo use it, you can put this line in your Jupyter Notebook\n\
    <code>\ntruncate_number(3.5)\n</code>\nAnd this will be the result of the previous\
    \ command \n<code>\n0.5\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\n\
    def round_half_up(x:Real)::Float64\n    ceil(x+0.5)\nend\n</code>\nA more general\
    \ solution that takes an arbitrary number of decimals.\n<code>", "    if number\
    \ % 1 == 0.0:\n        return math.floor(number)\n    return math.ceil(number)\n\
    </code>\n<|/ a dscore=2 tags=julia |>\n<| c |>\nI didn't know about the `floor`\
    \ function until I saw it used in this answer, thank you!\n<|/ c |>\n<| c |>\n\
    Awesome!  That is exactly what I was looking for.  I used the other two methods\
    \ mentioned in another answer below, but your answer is very simple, concise and\
    \ to the point.  Thanks!\n<|/ c |>\n<| a tags=julia |>\nThe shortest answer I\
    \ know of would be:\n<code>", "    \"\"\"\n    Given a positive floating point\
    \ number, it can be decomposed into\n    and integer part (largest integer smaller\
    \ than given number) and decimals\n    (leftover part always smaller than 1).",
  "    return (number % 1)*1\nend\n</code>\nFor decimal places you can also use this\
    \ package\n<code>\nusing DelimitedFiles\nusing CSV\nusing DelimitedFiles, CSV,\
    \ LinearAlgebra\n</code>\nAnd then load your file with the csv() function\n<code>\n\
    data = csv(joinpath(@__DIR__, \"yourfile.txt\"))\n</code>\nand then you can access\
    \ your data with a vectorized index\n<code>\ndata[:, 1:2] \n</code>\nwill give\
    \ you the two columns in the first row\n<code>\n[1.5     1.5000001]\n</code>\n\
    To get the first column you can do\n<code>\ndata[:,1]\n</code>\n<|/ a tags=arrays,julia\
    \ |>\n<| a tags=arrays,julia |>\nYou can use eachrow to iterate over an array:\n\
    <code>\njulia> A = ones(10)\n10-element Array{Float64,1}:\n 1.0\n 1.0\n 1.0\n\
    \ 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0", "    return floor(number)::Float64\
    \ - truncate_number(floor((number - floor((number)::Float64))))\nend\n</cell>\n\
    <code language=julia-1.5>\nusing CSV", "    \"\"\"\n    Return a number with the\
    \ decimal part truncated, i.e., rounded to\n    integers.", "    \"\"\"\n    truncate_number(number::Float64)::Float64",
  "   \"\"\"\n    Truncate a floating point number into an integer and decimal part\n\
    \    \"\"\"", "    if number >= truncate_number(number)\n        number\n    else\n\
    \        truncate_number(number - number)\n    end\nend\n</code>\nThe second function\
    \ was based on this blog post: http://rosettacode.org/wiki/Truncate_to_significant_digits#Julia\n\
    I hope this helps anyone that stumbles across this question.\n<|/ a dscore=2 |>\n\
    <| a dscore=0 |>\nI know it has been a while since this question was posted, but\
    \ I thought I'd add my solution.\nMy specific use case involved truncating floating\
    \ point numbers in Julia. However, I had to truncate very large numbers. So I\
    \ adapted the algorithm suggested by to my needs:\n<code>", "    if number <=\
    \ 0 \n        error(\"Truncation of negative numbers not supported.\")\n    end\n\
    \    trunc = floor(number)\n    if trunc != number\n        if trunc > number\n\
    \            return trunc + 1\n        end\n    end\n    return trunc\nend\n</code>\n\
    Finally, we will now create an instance of the FixedPoint class, that implements\
    \ a few basic methods to print and compare numbers using FixedPoint arithmetics\
    \ and FixedPoint exponentiation:\n<code>\nstruct FixedPoint\n    fraction::Float64\n\
    \    precision::Int64", "    \"\"\" Given a positive floating point number, it\
    \ can be decomposed into\n    and integer part (largest integer smaller than given\
    \ number) and decimals\n    (leftover part always smaller than 1).", "  \n   \
    \ truncate_decimal = truncate_part(number)\n    integer_part = floor(truncate_decimal)\n\
    \    remainder = truncate_decimal - integer_part\n    return integer_part + (remainder\
    \ * truncate_part(Float64(10)/Float64(remainder)))\nend", "    return (number//1)*1\n\
    end", '    return round(number, digits = -1)', "    \nend", "     \n    if number\
    \ == 0.0:\n        return number", "    dec_part = floor(number::Float64)\n  \
    \  int_part = trunc(number)\n    frac_part = number - trunc(number)", "    \n\
    \    \"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).", "</code>\nThis function has a type\
    \ signature. Type signatures are used to specify the return type of the function.\
    \ \n<code>", "    digits = Decimal(number)\n    if digits.is_zero\n        0.0\n\
    \    else\n        digits = digits - digits.floor()\n        return digits\nend",
  "    rounded_num = round(number)\n    return rounded_num - number % rounded_num\n\
    end", "    # Check if number is a floating point number\n    number = tofloat(number)\n\
    \    # Check if number is negative\n    if number < 0\n        error(\"Number\
    \ is negative\")\n    # If the number is 0, return 0\n    if number == 0\n   \
    \     return 0\n    # Get the integer part and remainder\n    integer, remainder\
    \ = math.modf(number)\n    # Check if integer is negative\n    if integer < 0\n\
    \        error(\"Integer is negative\")\n    # Check if integer is 0\n    if integer\
    \ == 0\n        return 0\n    # Get the decimal part and remainder\n    decimal,\
    \ remainder = math.modf(math.pow(10, math.ceil(math.log10(abs(number)))))\n  \
    \  # Check if decimal part is negative\n    if decimal < 0\n        error(\"Decimal\
    \ is negative\")\n    # Check if decimal part is 0\n    if decimal == 0\n    \
    \    return 0\n    # Return the decimal part\n    return decimal\nend", "    \"\
    \"\"\n    Truncate a float number.", "    if number > 0 then\n        trunc_number\
    \ = trunc(number)\n    else\n        trunc_number = number\n    end\n    return\
    \ trunc_number\nend\n</cell>\n<code language=julia-1.5>\nprintln(truncate_number(3.5))\n\
    println(truncate_number(0.2))\nprintln(truncate_number(-0.2))\nprintln(truncate_number(1.2))\n\
    println(truncate_number(-1.2))\nprintln(truncate_number(-1.1))\nprintln(truncate_number(1.1))\n\
    println(truncate_number(-10.1))\n</cell>\n<code language=julia-1.5>", "    if\
    \ number == 0.0 \n        then return 0.0\n    else \n        local new_number\
    \ = truncate_number(floor(number))\n        return truncate_number(new_number\
    \ - number * floor(new_number))\n    end\nend\n</code>\n<|/ a dscore=3 tags=julia,truncate\
    \ |>\n<| a dscore=1 |>\nHere is a solution which uses no builtins:\n<code>\ntruncate_number(x)\
    \ = x < 0 ? -truncate_number(-x) : truncate_number(x)\n</code>\n<|/ a tags=julia,truncate\
    \ |>\n<| a |>\nIn case someone is looking for a more general solution, here's\
    \ one:\n<code>", "    if number > 1.\n        return truncate_number(trunc(number))\n\
    \    return number\nend", "    return math.trunc(number)\nend\n</cell>\n<code\
    \ language=julia-1.3>\nusing Plots\ngr()\nx = 1:100\ny = 1:100\nscatter!(x, y,\
    \ label=\"original data\")\nplot!(x[truncate_number(x)], y[truncate_number(x)],\
    \ label=\"truncated data\")\n</cell>\n<text>\n3.3 Truncate number", "    return\
    \ (number - floor(number))*trunc(number)\nend", "    return (trunc(number)::Float64)\n\
    end", "</code>\n<|/ a tags=floating-point,julia |>\n<| a tags=floating-point,julia\
    \ |>\nThe package FixedPoints provides a function called truncate that does exactly\
    \ what you want without having to import any packages.\n<code>\njulia> truncate(3.5)\n\
    1", "    return floor(number)::Float64\nend", "    if number % 1 == 0.5\n    \
    \    return (number / 1)\n    else\n        return number\nend\n</code>\nThis\
    \ should be able to handle any number that is within the range of Float64 and\
    \ give the correct result.\n<|/ a tags=julia |>\n<| c |>\nI believe this will\
    \ not work.  See this example `julia> truncate_number(3.5)`  which returns `1.5`\
    \ not `0.5`.  Am I missing something here?\n<|/ c |>\n<| c |>\nThe comment by\
    \ should be added to this answer. Thank you for pointing this out.\n<|/ c |>\n\
    <| a |>\nThis should work:\n<code>", "    if number >= 1.0\n        decimal_number\
    \ = number % 1.0\n    else\n        decimal_number = number\n    end\nend\n</cell>\n\
    <text>\nExercise 9\nUse truncate_number to remove the fractional parts of a number.\n\
    For example truncate_number(7.6) should return 7.", "    \"\"\"\n    Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).", "    return mod(number,1)\nend", "    return (number - number(floor(number)))\
    \ * 10**precision\nend\n</code>\n<|/ a tags=math,julia |>\n<| a dscore=2 |>\n\
    Here is a solution that handles negative numbers.\n<code>", "    return (number\
    \ % 1)\nend", "    \n    digits = floor(log10(abs(number))) + 1\n    if number\
    \ < 0\n        return -truncate_number(-number)\n    factor = 10**digits\n   \
    \ number = number * factor\n    number = round(number) / factor\n    if number\
    \ == 0.0 or number == -0.0\n        return 0.0\n    return number", '    return
    (number%1)*1e-6', "    return number % 1\nend\n</code>\n<|/ a dscore=2 |>\n<|\
    \ a dscore=2 |>\n<code>", "\ttruncate(number,digits(number))\nend\n</cell>\n<code\
    \ language=julia-1.6>\ntruncate_number(4.1)\n</cell>\n<text>\nRandom numbers\n\
    A random number is generated using the standard Mersenne Twister algorithm \n\
    (Wikipedia).", "    float_num = Float64((number).toFloat64)\n    int_part = floor(float_num)\n\
    \    decimal_part = mod(float_num, 1::Float64)\n    return decimal_part\nend\n\
    </cell>\n<text>\nLet's test it.", "    \"\"\"Given a positive floating point number,\
    \ it can be decomposed into\n    and integer part (largest integer smaller than\
    \ given number) and decimals\n    (leftover part always smaller than 1).", " \
    \   # make sure number is a Float64\n    # this also ensures number is non negative\n\
    \    # and number is finite\n    # we assume that the number to be truncated is\
    \ smaller than a certain threshold\n    # we also assume that numbers are close\
    \ to zero and close to one\n    # and that they are in increasing order\n    #\
    \ this ensures that the number of decimal places returned is always 2\n    # we\
    \ first compute the number of decimal places in the given number\n    # by dividing\
    \ it by the threshold value 10^-N\n    # where N is the number of decimal places\
    \ in the number\n    # we then round this value to N\n    # we then compute the\
    \ truncated number by multiplying it by 10^N\n    # we then round this value to\
    \ one decimal place\n    # we finally return the truncated number as Float64\n\
    \    # we round the number to the number of decimal places by computing the truncation\n\
    \    # then multiplying the truncated number by 10^N and then rounding it to 1\
    \ decimal place\n    # we compute the truncation and rounding step by computing\
    \ the decimal places required to\n    # round the number to the number of decimal\
    \ places by dividing it by the threshold\n    # then computing the number of decimal\
    \ places by multiplying by 10^N then rounding it to one\n    # decimal place\n\
    \    # we round the number to the number of decimal places by computing the truncation\n\
    \    # then multiplying the truncated number by 10^N and then rounding it to 1\
    \ decimal place\n    # we compute the truncation and rounding step by computing\
    \ the decimal places required to\n    # round the number to the number of decimal\
    \ places by dividing it by the threshold\n    # then computing the number of decimal\
    \ places by multiplying by 10^N then rounding it to one\n    # decimal place\n\
    \    # we round the number to the number of decimal places by computing the truncation\n\
    \    # then multiplying the truncated number by 10^N and then rounding it to 1\
    \ decimal place\n    # we compute the truncation and rounding step by computing\
    \ the decimal places required to\n    # round the number to the number of decimal\
    \ places by dividing it by the threshold\n    # then computing the number of decimal\
    \ places by multiplying by 10^N then rounding it to one\n    # decimal place\n\
    \    # we round the number to the number of decimal places by computing the truncation\n\
    \    # then multiplying the truncated number by 10^N and then rounding it to 1\
    \ decimal place\n    # we compute the truncation and rounding step by computing\
    \ the decimal places required to\n    # round the number to the number of decimal\
    \ places by dividing it by the threshold\n    # then computing the number of decimal\
    \ places by multiplying by 10^N then rounding it to one\n    # decimal place\n\
    \    # we round the number to the number of decimal places by computing the truncation\n\
    \    # then ", '  Float64(trunc(number))', "    if number >= Float64(1)\n    \
    \    return number\n    decimal_part = floor((number - floor(number)) / (1-(number%1)))\n\
    \    integer_part = number - decimal_part * Float64(1) \n    return integer_part\
    \ + decimal_part\nend", "    decimal = math.trunc(number)\n    whole_number =\
    \ number - decimal\n    return whole_number if whole_number < 1.0 else decimal\n\
    end", "        float_part = floor(number)\n        integer_part = floor(float_part)\n\
    \        frac_part = mod(float_part,1)\n        return float_part*frac_part\n\
    \    end\n</cell>\n<code language=julia-1.4>\n### Function that given an angle\
    \ in degrees, returns the angle in radians\n### Input: angle in degrees", "  \
    \  \n    number::Float64", "    \"\"\"\n    Given a positive floating point number,\
    \ it can be decomposed into\n    and integer part (largest integer smaller than\
    \ given number) and decimals\n    (leftover part always smaller than 1).", "</code>\n\
    <|/ a tags=julia |>\n<| c |>\nThis works and is very simple, but it is also quite\
    \ slow. My solution was about 2x faster.\n<|/ c |>\n<| c |>\nI'm sorry, I don't\
    \ have any benchmarking data at the moment. However, it seems that my solution\
    \ is faster for most cases (especially with integers). I ran your function 10\
    \ million times and got `truncate_number` running at about 1.3 seconds for integers\
    \ and 0.2 seconds for floats.\n<|/ c |>\n<| c |>\nAh, I see! Yes, that is the\
    \ advantage of using vectors instead of looping. Nice work!\n<|/ c |>\n<| a dscore=0\
    \ tags=julia |>\nIn Julia it is pretty easy to do it with bitstrings:\n<code>\n\
    julia> num = 2^12 - 1\n12", "    if number == round(number)\n        return number\n\
    \    elseif number < 0.0\n        return number - 0.5\n    else\n        return\
    \ number + 0.5", "    if number > 0.0 && number < 1.0:\n        return floor(number)\n\
    \    end = (number - floor(number)) * truncate_precision\n    return floor(number)\
    \ + end\nend", "    \"\"\"\n    Truncate a floating point number to its decimal\
    \ part.\n    \n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nWhat does this have to do with the question asked?\n\
    <|/ c |>\n<| c |>\nThis isn't Python, it's Haskell. Haskell has no explicit type\
    \ declarations like C or C++, so `Float64` and `Float32` aren't really types,\
    \ and `Float64` is ambiguous. Also, `Float32` should be `Float64`, and the whole\
    \ thing should be `import Data.Float32 (truncate_number)`.\n<|/ c |>\n<| c |>\n\
    Oops, I didn't notice that someone had already posted this in another language\
    \ before. I don't know why I didn't notice that earlier. Oh well, I will leave\
    \ this here anyways, as it might be useful to someone else who comes across this\
    \ question.\n<|/ c |>\n<| c |>\nYou might want to check out http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base/Data-Float.html",
  "    return round(number, -int(math.floor(math.log10(abs(number)))))\nend", "  \
    \  float_num = float(number)\n    int_part = np.floor(float_num)\n    decimal_part\
    \ = float_num - int_part\n    return decimal_part\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThis works great, but I wonder why it's not the default in Julia.\n<|/\
    \ c |>\n<| a dscore=1 tags=julia |>\nThis is another alternative way to do this\
    \ in Julia, and it's also easy to understand by looking at the code.\n<code>",
  "    precision = floor(log10(number))\n    return float(number / 10**precision)\n\
    end\n</code>\n<|/ a tags=julia,floating-point,type-conversion |>\n<| a tags=julia,floating-point,type-conversion\
    \ |>\nFor floating point numbers, you can use:\n<code>\ntrunc(number)\n</code>\n\
    which truncates the floating-point number number to the closest integer, and\n\
    <code>\nfloor(number)\n</code>\nwhich truncates the floating-point number number\
    \ to the closest integer.\nExample:\n<code>\njulia> round(1.5)\n1.0", "    if\
    \ number == 0.\n        return 0.\n    fraction = floor(number)\n    number =\
    \ number - fraction\n    fraction = fraction / 10\n    decimal = number % 10\n\
    \    return decimal * 10^decimal\nend\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(1.5)\n</cell>\n<text>\nConverting\
    \ from Strings", "    if number >= 1\n        dec = 0\n        intpart = 1\n \
    \   elseif number == 0\n        dec = 0\n        intpart = 0\n    else\n     \
    \   dec = (length(number) - length(floor(number)))\n        intpart = floor(number)\n\
    \    end\n    return intpart + dec\nend\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.5)\n</cell>\n<text>\nJulia also has built-in functions to round\
    \ numbers to the nearest integer/decimal places:", "    if number < 1 then error(\"\
    Argument must be positive\")\n    truncate_part(number, 0)\nend", "</code>\n<|/\
    \ a dscore=1 |>\n<| a dscore=1 |>\n<code>\ntrunc_num_1 = truncate_number(x)\n\
    trunc_num_2 = truncate_number(y)\nprint((trunc_num_1 , trunc_num_2))\n</code>\n\
    <|/ a tags=julia |>\n<| a dscore=0 |>\nIf you use Julia version 1.5.0 or higher,\
    \ you can use isodd to solve your problem. \n<code>\nisodd(number)\n</code>\n\
    Example: \n<code>\njulia> isodd(3)\ntrue\n</code>\nHowever, this function will\
    \ not return any numbers if the given number is even or negative. \nAnother example\
    \ which returns numbers only for even numbers: \n<code>\njulia> isodd(-2)\nfalse\n\
    julia> isodd(1)\ntrue\n</code>\n<|/ a tags=julia |>\n<| c |>\nYes, but that will\
    \ also return true for even numbers\n<|/ c |>\n<| c |>\nYeah, I missed that. Thank\
    \ you for letting me know. \nDo you know any other solution to your problem?\n\
    <|/ c |>\n<| a dscore=0 tags=julia |>\n<code>\n#isodd function ", "    return\
    \ trunc(number) \nend\n</cell>\n<code language=julia-1.3>\n\"\"\"\n    trunc(x)\n\
    \    Truncates x to its nearest integer value. \n    \n    The sign of `x` is\
    \ preserved.\n    \n    Inf and NaN are preserved.\n    \n    Truncating infinity\
    \ results in NaN.\n    \n    Truncating negative infinity results in a positive\
    \ number.\n    \n    Truncating a NaN results in a NaN.\n    \n    ```jldoctest\n\
    \    julia> trunc(-inf)\n    -inf\n    julia> trunc(NaN)\n    NaN\n    julia>\
    \ trunc(3.5)\n    3.5\n    julia> trunc(3.0)\n    3\n    ```\n\"\"\"", "    integer\
    \ = truncate_number(floor((number)::Float64))\n    decimal = number - integer\n\
    \    return decimal\n</code>\n<|/ a dscore=1 tags=julia,floating-point |>\n<|\
    \ c |>\nthanks for your solution, however, the function doesn't work correctly\
    \ for number like 2.25 or 3.000000001\n<|/ c |>\n<| c |>\nI have updated the answer,\
    \ now it works fine for all the cases.\n<|/ c |>\n<| a tags=julia,floating-point\
    \ dscore=1 |>\nThe function you want is ceil, i.e. ceiling(x).\n<|/ a |>\n<| a\
    \ tags=julia,floating-point |>\n<code>\nceiling(2.25)\n</code>\nshould return\
    \ 2\n<code>\nceiling(3.0)\n</code>\nshould return 3\n<code>\nceil(2.25)\n</code>\n\
    should return 3\n<code>\nceil(3.0)\n</code>\nshould return 4\n<|/ a dscore=0 |>\n\
    <| c |>\nThanks for your solution, however, the function doesn't work correctly\
    \ for number like 2.25 or 3.000000001\n<|/ c |>\n<| a |>\nApart from other solutions,\
    \ you could also use the round function:\n<code>\nround(2.25)\n# 2", "    if number\
    \ > Float64(1.0) return number \n    return number - truncate_number(number -\
    \ 1.0) \nend", "    return number%1\nend", "    if number == 0\n    then return\
    \ 0\n    else truncate_number(number - truncate_number_dec(number))\nend\n</cell>\n\
    <text>\nExample: Truncating Float64 numbers to 64 bits\nThe function truncate_number_dec(3.5)\
    \ = 2.5", '  assert(number >= 0)', "    \"\"\"\n    Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).", "    if number <= 1\n        return number\n    \n    float_number = convert(Float64,\
    \ number)\n    float_number, integer_part, decimal_part = divrem(1, float_number)\n\
    \    \n    return convert(Float64, decimal_part)", "    dec_part = floor(number);\n\
    \    int_part = trunc(number);\n    frac = number-dec_part;\n    return dec_part\
    \ + frac\nend\n</cell>\n<code language=julia-1.5>\n# Test it on a few examples:\n\
    truncate_number(3.141592653589793)\n</cell>\n<code language=julia-1.5>\n# Define\
    \ a function to compute the factorial of a number:", "\"\"\"\n    \n    \"\"\"\
    \n        \n    Truncate a number down to an integer.", "    \"\"\"\n    Truncate\
    \ the number to any number of decimals.\n    >>> truncate_number(3.1)\n    3.0\n\
    \    >>> truncate_number(3.0)\n    3.0\n    \"\"\"", "    if number == 0.0 \n\
    \        0.0\n    elseif number < 1.0\n        number\n    else\n        truncate_number(floor(number))\n\
    \    end\nend\n</cell>\n<text>\nWe want to see how well our model did in the train\
    \ set. We will evaluate the model on the test set later.", "    return round(number)\n\
    end ", "    digit = math.floor(number)\n    decimals = number - digit", "</code>\n\
    <|/ a tags=haskell,bigint |>\n<| c |>\nThis isn't actually correct. While the\
    \ OP used this in a function he defined, it isn't actually in a function.\n<|/\
    \ c |>\n<| c |>\n: You're right. I just edited the answer to correct this.\n<|/\
    \ c |>\n<| a tags=haskell,bigint |>\nOne more answer:\n<code>\ntrunc' n = fromIntegral\
    \ (floor (realToFrac n))\n</code>\n<|/ a dscore=1 |>\n<| c |>\nDoesn't truncate\
    \ properly. Try for example `trunc 1.1 = 1.1`.\n<|/ c |>\n<| a dscore=1 |>\nHere\
    \ is an example that uses Data.Bits to split a double into an integer part and\
    \ a fractional part that can then be truncated to an Int. I've tested it on Windows\
    \ and Linux and it seems to be working fine.\n<code>\nimport qualified Data.Bits\
    \ as B\nimport Data.Bits", "    \"given number\"\n    return trunc(number)", " \
    \   return (number - truncate_number(floor(number)))::Float64\nend", "    number\
    \ = number.round()\n    number = number.trunc()\n    return number\nend\n</cell>\n\
    <code language=julia-1.5>", "    integer :: integer = ceiling(number)\n    decimal\
    \ :: decimal = number - integer\n    \n    if decimal < 1\n        return truncate_number(integer)\n\
    \    \n    return number\n</code>\n<|/ a tags=floating-point,math,python,truncate\
    \ dscore=1 |>\n<| c |>\nWhile this code may answer the question, providing additional\
    \ context regarding why and/or how this code answers the question improves its\
    \ long-term value.\n<|/ c |>\n<| a dscore=1 |>\nA variation on other answers that\
    \ works also for negative numbers and allows arbitrary precision and rounding.\n\
    <code>\ndef truncate_number(number, precision):\n    \"\"\"\n    Truncate a floating\
    \ point number to specified precision\n    \"\"\"\n    if number == 0:\n     \
    \   return 0\n    \n    if precision > 1:\n        digits = int(math.log10(number))\n\
    \        magnitude = int(math.ceil(digits / precision))\n        magnitude = max(0,\
    \ magnitude - 1)\n        number = round(number * pow(10, magnitude), precision)\n\
    \    \n    magnitude = max(0, -int(math.floor(math.log10(abs(number))) - 1))\n\
    \    magnitude = min(-precision, magnitude)\n    number = round(number * pow(10,\
    \ magnitude), precision)", "    return math.trunc(number)\nend\n</cell>\n<text>\n\
    Let's now test this function!", "    \"\"\"Given a positive floating point number,\
    \ it can be decomposed into\n    and integer part (largest integer smaller than\
    \ given number) and decimals\n    (leftover part always smaller than 1).", " \
    \   decimals = round(number-floor(number))\n    number = round(number)\n    return\
    \ number\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis code doesn't seem to work\
    \ when I try it... Maybe there's some syntax error that I missed\n<|/ c |>\n<|\
    \ c |>\nThe answer is based on the OP's question, which is \"given a number, how\
    \ do I know the number of digits it has\", and he has already solved that. But\
    \ my answer is for another case, which is to solve the problem you mentioned,\
    \ i.e., given an integer N, how many digits are in N? I hope this answer helps.\n\
    <|/ c |>\n<| a dscore=0 |>\nI wanted to add my solution here as I wanted to make\
    \ it faster, and I found out that using fmod is very slow. This solution was proposed\
    \ by another user on Stack Overflow and it's quite fast for my needs:\n<code>",
  "</code>\n<|/ a dscore=2 tags=julia,python |>\n<| c |>\nYes, this answer is correct.\
    \ Your code was also very useful, so I upvoted it too. However the python `floor()`\
    \ function should do exactly what he wants.\n<|/ c |>\n<| a tags=julia,python\
    \ |>\nFrom the python documentation of math.floor:", "    return floor(number)\
    \ + round(number * eps(Float64))\nend", "    return (number-truncate_number(floor(number)))\n\
    end\n</code>\nAnd here is the implementation for truncate_number:\n<code>\n# truncate_number(x)\n\
    # Truncate number x to a lower bounded floating point number.\n# For example,\
    \ if x is 3.5, then truncate_number(x) will return 3.0.\n#\n# x : a float number\n\
    # Returns\n# Number x with its fractional part truncated to a lower bounded floating\
    \ point number.\n# Examples\n#   truncate_number(3.5)   =>  3.0\n#   truncate_number(3.499)\
    \ =>  3.5\n# ", "    precision = precision(number)\n    floored = round(number)\n\
    \    digits = truncate_digits(floored, precision)\n    decimals = truncate(floored,\
    \ digits)\n    return truncate_fraction(floored, decimals)", "    float_part =\
    \ floor(number)\n    int_part = floor(float_part)\n    decimal_part = abs(number\
    \ - int_part)\n    \n    # Return zero if number was 0.\n    if number == 0.0\n\
    \        decimal_part = 0", "    \n    \"\"\"\n    Truncate number to the nearest\
    \ integer.", "    \"\"\"\n    Given a positive floating point number, it can be\
    \ decomposed into\n    and integer part (largest integer smaller than given number)\
    \ and decimals\n    (leftover part always smaller than 1).", '"""Given a floating
    point number it can be decomposed to an integer part (largest integer smaller
    or equal than given number) and a decimal part (leftover part always smaller or
    equal to 1).', "    truncate_number_helper(number, Float64, 0)\nend\n</cell>\n\
    <code language=julia-1.5>\ntruncate_number(2.5)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.4)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.0)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(4.0)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(4.4)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(5.0)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(4.5)\n</cell>\n<text>\nTruncate to integer", "end\n</cell>\n<code\
    \ language=julia-1.5>\nusing Distributions", "  local trunc_part = math.trunc(number)\n\
    \  local trunc_part_floor = math.floor(trunc_part)\n  return trunc_part_floor\
    \ - trunc_part + number % trunc_part\nend", "    # check if number is negative\n\
    \    sign_num = copy(number)\n    if sign_num < 0\n        sign_num *= -1\n  \
    \  abs_num = copy(sign_num)\n    if abs_num < 1\n        abs_num *= -1", "   \
    \ if number < 0.\n        return 0.\n    \n    integer = truncate_number(floor(number))\n\
    \    decimal = number - integer\n    return decimal if decimal < 1. else 1. \n\
    end\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3 tags=julia,numerical-analysis,math,floating-point\
    \ |>\n<code>\nround(num::Float64)::Float64\nreturn round(num,digits::Integer)\n\
    </code>\n<|/ a |>\n<| a dscore=3 |>\n<code>\nround(num, digits=2)\n</code>\n<|/\
    \ a tags=julia,numerical-analysis,math,floating-point |>\n<| a tags=julia,numerical-analysis,math,floating-point\
    \ dscore=3 |>\nUse round to get an integer:\n<code>\njulia> round(3.5)\n2\n</code>\n\
    <|/ a |>\n<| c |>\nThis is the correct answer.  Julia provides rounding functions\
    \ like the C library round function as well.\n<|/ c |>\n<| c |>\nActually Julia\
    \ provides many other rounding functions. See the docs: http://docs.julialang.org/en/stable/stdlib/math/#Rounding-functions-1\n\
    <|/ c |>\n<| a tags=julia,numerical-analysis,math,floating-point |>\nIn your example\
    \ you can just do:\n<code>\njulia> round(3.5)\n2\n</code>\nHowever, you can also\
    \ do the following:\n<code>\njulia> round(3.5, digits=2)\n2.5\n</code>\n<|/ a\
    \ dscore=3 |>\n<| c |>\nThe `digits=` syntax is deprecated. Use `digits()` instead.\
    \ E.g. `round(3.5, digits())` prints `2`.\n<|/ c |>\n<| c |>\nThis is now deprecated\
    \ in v0.6.\n<|/ c |>\n<| a tags=julia,numerical-analysis,math,floating-point |>\n\
    Here is an example for rounding:\n<code>\njulia> round(3.45)\n3", "    if number\
    \ < 0. \n        return number\n    if number == 0. \n        return 0.\n    \n\
    \    # truncate number by rounding down and then truncating the decimals\n   \
    \ number -= truncate_number(number - rounddown(number))\n    \n    # return truncated\
    \ number\n    return rounddown(number)\nend\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(3.4)\n</cell>\n<code language=julia-1.5>\ntruncate_number(3)\n\
    </cell>\n<code language=julia-1.5>\ntruncate_number(-3.4)\n</cell>\n<code language=julia-1.5>\n\
    truncate_number(-3.5)\n</cell>\n<code language=julia-1.5>\ntruncate_number(-3.4)\n\
    </cell>\n<text>\nExercise\nFind the maximum and minimum values of the array X",
  "    number = round(number, digits(number))\n    return number - mod(number, 1)\n\
    end\n</cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n</cell>\n<code\
    \ language=julia-1.4>", "    if number >= 0.5\n        return number\n    \n \
    \   integer, decimals = floor(number), round(number * 10^6)\n    \n    if number\
    \ == integer\n        decimals = 0\n    \n    return number * 10^6 - decimals\n\
    end \n</cell>\n<code language=julia-1.6>\n@assert truncate_number(0.5) == 0.5\n\
    @assert truncate_number(1.5) == 1.0\n@assert truncate_number(5.2) == 5.0\n@assert\
    \ truncate_number(10) == 10.0\n@assert truncate_number(10) == 10.0\n@assert truncate_number(15)\
    \ == 15.0\n@assert truncate_number(20) == 20.0\n</cell>\n<text>\nExercise 4: Compute\
    \ and print the value of $\\pi$ using the Taylor series expansion.", "    truncated\
    \ := trunc(number)\n    if truncated != number && truncated > 0.5 \n        then\
    \ truncated := truncated - 1\n    else truncated := truncated + 1\n    return\
    \ truncated\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nthis fails on `truncate_number(3.5)`\
    \ as expected.\n<|/ c |>\n<| c |>\n, thanks for pointing out this. I had not considered\
    \ this case. I fixed the code accordingly.\n<|/ c |>\n<| a |>\nIn Julia, all numbers\
    \ are floating-point types. In your case, you can define your function as such:\n\
    <code>\ntruncate_number(x::Float64)::Float64\n    if x == 0 \n        return x\n\
    \    else \n        return trunc(x - 0.5)\n    end\nend\n</code>\n<|/ a tags=julia,types\
    \ dscore=1 |>\n<| a |>\nThe solutions here fail to consider floating point imprecisions.\
    \ Here's a version that does include this kind of check and also returns zero\
    \ instead of an inf or -inf.\n<code>", end, "    \"\"\"\n    Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).", "    \"\"\"\n    Truncates a floating point number to two decimal\
    \ places.\n    \"\"\"\n    return math.trunc(number)\nend", "    return round(number)\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert truncate_number(3.5) == truncate_number(3.5)\n\
    @assert truncate_number(3.0) != truncate_number(3.5)\n@assert truncate_number(3.3)\
    \ != truncate_number(3.5)\n</cell>\n<text>\nWe will use this truncate_number function\
    \ to remove digits from floating\n    point numbers in our code.", "    return\
    \ (number::Float64).floor()\nend\n</cell>\n<code language=julia-1.5>", "    \n\
    \    if number < 0.0 \n        number = -number\n    return math.trunc(number\
    \ * 100) / 100\n</code>\n<|/ a tags=julia,truncate,rounding,decimal |>\n<| c |>\n\
    `trunc` returns a floating point number which is not always exact, e.g. `trunc(0.1\
    \ + 0.2)` returns 0.3 instead of 0.2.\n<|/ c |>\n<| c |>\n`trunc` should return\
    \ `0.2` here, at least in my tests.\n<|/ c |>\n<| c |>\nOh, you are right. I checked\
    \ this in R and Python, where trunc returns exactly the nearest integer. My bad,\
    \ sorry for the noise.\n<|/ c |>\n<| c |>\n`trunc` does in fact return exactly\
    \ 0.2 on my system. Also, `trunc` returns a floating point number which is not\
    \ always exact, e.g. `trunc(0.1 + 0.2)` returns 0.3 instead of 0.2.\n<|/ c |>\n\
    <| a dscore=4 tags=julia,truncate,rounding,decimal |>\nThis should work:\n<code>\n\
    round(number)\n</code>\n<|/ a |>\n<| c |>\n`round` returns a floating point number\
    \ which is not always exact, e.g. `round(1.1 + 1.2)` returns 1.3 instead of 1.2.\
    \ `trunc` does in fact return exactly 0.2 on my system. Also, `trunc` returns\
    \ a floating point number which is not always exact, e.g. `trunc(0.1 + 0.2)` returns\
    \ 0.3 instead of 0.2.\n<|/ c |>\n<| a dscore=3 |>\nThe question was already answered,\
    \ but for future reference: \nIn case you want to round up to the nearest integer:\n\
    <code>\nceil(number)\n</code>\nIn case you want to round down to the nearest integer:\n\
    <code>\nfloor(number)\n</code>\n<|/ a tags=julia,truncate,rounding,decimal |>\n\
    <| a |>\nI stumbled upon this issue while working with Julia's DataFrames.jl package\
    \ and ended up using truncate which works well enough for my needs.\n<code>\n\
    julia> truncate(10.0)\n10.0", "</code>\n<|/ a tags=julia,floating-point dscore=2\
    \ |>\n<| a dscore=1 |>\nIn Julia you can use truncate:\n<code>\njulia> truncate(3.5)\n\
    3\n</code>\n<|/ a tags=julia,floating-point |>\n<| a |>\nYou could use the truncate\
    \ function.\n<|/ a tags=julia,floating-point dscore=0 |>\n<| a dscore=0 tags=julia,floating-point\
    \ |>\nThe truncate function should be the best choice here\n<|/ a |>\n<| a tags=julia,floating-point\
    \ |>\nYou can always use truncate function\n<|/ a dscore=0 |>\n<| c |>\nThis does\
    \ not provide an answer to the question. To critique or request clarification\
    \ from an author, leave a comment below their post. - [From Review](/review/low-quality-posts/11751822)\n\
    <|/ c |>\n<| c |>\nI agree that in general, answers are better than comments and\
    \ I wanted to point out that the truncate function could be used to truncate numbers.\
    \ That's why my answer is also a full answer to this question and I gave a link\
    \ to the documentation page where you can find all the available functions.\n\
    <|/ c |>\n<| c |>\nIt is not an answer, it is a comment. If you read the original\
    \ question and OP's comment carefully, you will find that the answer starts by\
    \ \"I cannot find truncate function\". I suggest you remove your downvote because\
    \ it is wrong.\n<|/ c |>\n<| c |>\nIt's not wrong, it's just not the answer to\
    \ the question and is missing a lot of information. Your downvote is unnecessary.\
    \ Your comment is completely unrelated to the original question.\n<|/ c |>\n<|\
    \ a dscore=0 tags=julia,floating-point |>\nYou can use the floor() function for\
    \ that:\n<code>\njulia> floor(3.5)\n3\n</code>\nOr you can use the ceil() function:\n\
    <code>\njulia> ceil(3.5)\n4\n</code>\n<|/ a |>\n<| a tags=julia,floating-point\
    \ dscore=0 |>\nUse truncate function\n<code>\njulia> truncate(3.5)\n3\n</code>\n\
    <|/ a |>\n<| c |>\nThis does not provide an answer to the question. To critique\
    \ or request clarification from an author, leave a comment below their post. -\
    \ [From Review](/review/low-quality-posts/11751822)\n<|/ c |>\n<| c |>\nThe answer\
    \ is \"use truncate\", not ", "    truncate_number = trunc(number)\n    return\
    \ truncate_number\nend", "    truncatedNumber = trunc(number)\n    if number <\
    \ truncatedNumber\n        return truncatedNumber\n    else\n        return truncatedNumber\
    \ - 1.0\nend", "    integer = truncate_number(number)\n    decimal = number-integer\n\
    \    return integer,decimal\nend\n</cell>\n<text>\nTruncating a number\nWe can\
    \ now write a function that will truncate the decimals of a number, for example:",
  "\"\"\"\n    truncate_number(number) =\n    truncate_number(number::Int64) = \n\
    \    truncate_number(number::Int128) = \n    truncate_number(number::Int32) =\
    \ \n    truncate_number(number::Int64) = \n    truncate_number(number::Int128)\
    \ = \n    truncate_number(number::Float32) = \n    truncate_number(number::Float64)\
    \ = \n    if number == truncate_number(round(number)) then number::Int64 else\
    \ number::Float64\nend \n\"\"\"\n    truncate_number(number) =\n    truncate_number(number::Int64)\
    \ = \n    truncate_number(number::Int128) = \n    truncate_number(number::Int32)\
    \ = \n    truncate_number(number::Int64) = \n    truncate_number(number::Int128)\
    \ = \n    truncate_number(number::Float32) = \n    truncate_number(number::Float64)\
    \ = \n    truncate_number(round(number))\nend \n\"\"\"\n    truncate_number(number)\
    \ =\n    truncate_number(number::Int64) = \n    truncate_number(number::Int128)\
    \ = \n    truncate_number(number::Int32) = \n    truncate_number(number::Int64)\
    \ = \n    truncate_number(number::Int128) = \n    truncate_number(number::Float32)\
    \ = \n    truncate_number(number::Float64) = \n    truncate_number(round(number))\n\
    end \n\"\"\"\n    truncate_number(number) =\n    truncate_number(number::Int64)\
    \ = \n    truncate_number(number::Int128) = \n    truncate_number(number::Int32)\
    \ = \n    truncate_number(number::Int64) = \n    truncate_number(number::Int128)\
    \ = \n    truncate_number(number::Float32) = \n    truncate_number(number::Float64)\
    \ = \n    truncate_number(round(number))\nend \n\"\"\"\n    truncate_number(number)\
    \ =\n    truncate_number(number::Int64) = \n    truncate_number(number::Int128)\
    \ = \n    truncate_number(number::Int32) = \n    truncate_number(number::Int64)\
    \ = \n    truncate_number(number::Int128) = \n    truncate_number(number::Float32)\
    \ = \n    truncate_number(number::Float64) = \n    truncate_number(round(number))\n\
    end \n\"\"\"\n    truncate_number(number) =\n    truncate_number(number::Int64)\
    \ = \n    truncate_number(number::Int128) = \n    truncate_number(number::Int32)\
    \ = \n    truncate_number(number::Int64) = \n    truncate_number(number::Int128)\
    \ = \n    trun", "    truncate_number = number - truncate_number(number*10)\n\
    \    return truncate_number\nend\n</cell>\n<code language=julia-1.4>\ntruncate_number(1.5)\n\
    </cell>\n<code language=julia-1.4>\ntruncate_number(3.5)\n</cell>\n<code language=julia-1.4>\n\
    truncate_number(10)\n</cell>\n<code language=julia-1.4>\ntruncate_number(1.5)\n\
    </cell>\n<text>\nExercise 2.1\nWrite a function which accepts a positive floating\
    \ point number and rounds it to the nearest integer by discarding all decimals\
    \ after the decimal point (to the left of the decimal point).", "    \"\"\"\n\
    \    Truncate floating point number to the decimal\n    part and integer part.",
  "    return round(number, digits(number))\nend\n</cell>\n<code language=julia-1.5>",
  "    return number - truncate_number(number)\n</code>\nAnd here is the definition\
    \ of truncate_number\n<code>\ndef truncate_number(number::Float64)::Float64\n\"\
    \"\"\nGiven a positive floating point number, it can be decomposed into\n    and\
    \ integer part (largest integer smaller than given number) and decimals\n    (leftover\
    \ part always smaller than 1).", "    if number > Float64(1)\n        return number\n\
    \    decimal_part = floor(log10(number))\n    frac_part = number - decimal_part\n\
    \    frac_part = frac_part % 1.0\n    return frac_part\n</code>\nThe first line\
    \ in the function truncates the decimal part, and the second line gives the fractional\
    \ part as a floating point number.\nThe first line could be shortened to frac_part\
    \ = number - floor(log10(number)), but this would not work for negative numbers.\
    \ \nThe second line could be\n<code>\nfrac_part = number - truncate_number(number)\n\
    </code>\nbut the function might not be used correctly, or even exist, so I recommend\
    \ the first version.\n<|/ a tags=floating-point,julia |>\n<| c |>\n`truncate_number`\
    \ only exists if you have `using Float64`, which you probably don't. See my answer.\n\
    <|/ c |>\n<| a dscore=5 |>\nI needed to convert a real value to a number as close\
    \ to zero as possible, i.e.\n<code>\nrealToFract(3.1415) -> 0.3414159265359\n\
    </code>\nThis was my solution\n<code>\nrealToFract(x) = fract(abs(x)) + trunc(x\
    \ + abs(x))\n</code>\nAnd some tests:\n<code>\njulia> realToFract(3.1415)\n0.3414159265359\n\
    julia> realToFract(1.2)\n0.01\njulia> realToFract(1.9)\n0.09999999999999994\n\
    julia> realToFract(0.9999999999999999)\n0.9999999999999994\n</code>\n<|/ a tags=floating-point,julia\
    \ |>\n<| c |>\nThis does not work correctly for negative numbers. E.g. `realToFract(-3.1415)`\
    \ gives `-0.3414159265359`, not `-0.34141592653590`, as you might expect.\n<|/\
    \ c |>\n<| c |>\nThe solution is not working for negative numbers. `realToFract(-3.1415)`\
    \ gives -0.3414159265359, not -0.34141592653590.\n<|/ c |>\n<| c |>\nThat's not\
    \ what I get. `realToFract(-3.1415)` gives -0.3414159265359, as expected\n<|/\
    \ c |>\n<| c |>\nWhat happens if you try `realToFract(-3.1416)` ?\n<|/ c |>\n\
    <| c |>\n-0.34141592653590 is what I get.\n<|/ c |>", "    digits = floor(Float64(log2(number)))\
    \ + 2\n    dec_part = number % 10\n    ret_part = number % 10 - dec_part\n   \
    \ num = number - dec_part\n    while num > 0\n        if num % 10 == 0\n     \
    \       return number\n        num /= 10\n    return number - dec_part\nend\n\
    </cell>\n<code language=julia-1.5>", "    truncated ::Float64\n    truncated =\
    \ truncate_number_helper(number)\n    \n    return truncated\nend\n</cell>\n<text>\n\
    Now let's look at the function!", "    if number < 0.0 \n    then return number\n\
    \    else \n        digits = floor(log10(abs(number)))\n        tens = 10**(digits\
    \ - digits)\n        return (number / tens)\n    end\nend\n</cell>\n<code language=julia-1.2>\n\
    ### Define the function `truncate_digits`", "    float_part = floor(number)\n\
    \    decimal_part = number - float_part\n    \n    int_part = trunc(number)\n\
    \    \n    decimal_part_to_int = int_part * 10^decimal_part\n    \n    if decimal_part\
    \ <= 0\n    decimal_part_to_int\n    else\n    decimal_part_to_int + truncate_number(decimal_part_to_int)\n\
    \    end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe answer is not wrong, even\
    \ though it gives a different result than `ceil` or `floor`. In fact, your code\
    \ is simply implementing `floor` and `ceil` by truncating instead of rounding.\
    \ `ceil(3.5) = 4.0`\n<|/ c |>\n<| c |>\nI believe it solves the issue, my code\
    \ is more complex than that, but I tried to implement the function in a single\
    \ line as much as I could.\n<|/ c |>\n<| c |>\nYes, it does solve the issue, but\
    \ your implementation is wrong. You should either implement `floor` or `ceil`\
    \ without truncating (and therefore also without rounding), or truncate and then\
    \ round to nearest integer.\n<|/ c |>\n<| a tags=rounding,math,julia |>\nThe answer\
    \ to your question is to use Julia's round() function. The syntax is a bit different\
    \ from other languages, so you may have to read a bit about it, but the example\
    \ is here.\nThe answer is, for example, round(3.5) = 4.\n<|/ a dscore=0 |>\n<|\
    \ c |>\n`round` is inappropriate here because it gives an incorrect result in\
    \ some cases. Consider rounding to the nearest integer. `round(3.5) = 4`. But\
    \ `ceil(3.5) = 3.0`\n<|/ c |>\n<| a |>\n<code>", "    \"\"\"\n    Truncate a number\
    \ to one decimal place.", "    decimal <- decimal_part(number)\n    integer <-\
    \ truncate_number(integer(number))\n    return number - decimal * integer\nend\n\
    </cell>\n<text>\nHere we see the different return type of truncate_number for\
    \ numbers with different signs.", "    if number < 1.0 \n        then truncate_number(floor(number))\n\
    \        else truncate_number(ceil(number))\n    end\nend", "  n = round(number,\
    \ digits=digits)\n  i = math.trunc(n)\n  d = n - i\n  return i / (10^digits)\n\
    end\n</cell>\n<text>\nExample of truncating numbers:", "    integer_part, decimals\
    \ = fparts(number)\n    truncated_number = round(number * 10^decimals)\n    return\
    \ truncated_number / 10^decimals\nend", "    \"\"\"\n    Truncate a floating point\
    \ number to the closest integer value to\n    representable by that floating point\
    \ number.", "    \"\"\"\n    Truncate given number to the given number of decimals."]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
