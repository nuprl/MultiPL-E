name: HumanEval_154_cycpattern_check
language: jl
prompt: "\"\"\"You are given 2 words. You need to return true if the second word or\
  \ any of its rotations is a substring in the first word\n    >>> cycpattern_check(\"\
  abcd\", \"abd\")\n    false\n    >>> cycpattern_check(\"hello\", \"ell\")\n    true\n\
  \    >>> cycpattern_check(\"whassup\", \"psus\")\n    false\n    >>> cycpattern_check(\"\
  abab\", \"baa\")\n    true\n    >>> cycpattern_check(\"efef\", \"eeff\")\n    false\n\
  \    >>> cycpattern_check(\"himenss\", \"simen\")\n    true\n\n    \"\"\"\nfunction\
  \ cycpattern_check(a::String, b::String)::Bool \n"
tests: "using Test\n\n@testset begin\n\ncandidate = cycpattern_check;\n\t@test(candidate(\"\
  xyzw\", \"xyw\") == false)\n\t@test(candidate(\"yello\", \"ell\") == true)\n\t@test(candidate(\"\
  whattup\", \"ptut\") == false)\n\t@test(candidate(\"efef\", \"fee\") == true)\n\t\
  @test(candidate(\"abab\", \"aabb\") == false)\n\t@test(candidate(\"winemtt\", \"\
  tinem\") == true)\nend\n"
completions: ["    length_b = len(b)\n    if length_b == 0\n        true\n    else\n\
    \        begin = 0\n        end = length_b\n        begin = begin - 1\n      \
    \  end = end - 1\n        \n        if length_b > 0\n            \n          \
    \  while begin < length_b\n                \n                if b[begin] == a[end]\
    \ \n                    begin = begin + 1\n                else\n            \
    \        begin = begin - 1\n                \n                end = end - 1\n\
    \                \n                if begin < length_b\n                    \n\
    \                    begin = begin - 1\n                    end = end - 1\n  \
    \          end\n            \n            return true\n        end\n    end\n\
    \    return false\nend", "    if b == a \n        return true\n    if b == \"\"\
    \ \n        return false\n    if a == \"\" \n        return false\n    if a[0]\
    \ == b\n        return true\n    if cycpattern_check(a[1:end-1], b) or cycpattern_check(a[end-1:end],\
    \ b[1:end-1])\n        return true\n    return false\n    end\n</code>\n<|/ a\
    \ tags=pattern-matching,string,algorithm,haskell,pattern-matching dscore=0 |>\n\
    <| c |>\nThis won't work if `a` is an empty string; it should return `False`.\n\
    <|/ c |>\n<| a dscore=0 |>\nI thought about it for a minute, and I came up with\
    \ this:\n<code>\ncycpattern_check :: String -> String -> Bool\ncycpattern_check\
    \ a b\n    | a == b = True\n    | otherwise = all (\\c -> cycpattern_check (drop\
    \ 1 a) (b ++ [c])) ['a'..'z']\n</code>\n<|/ a tags=pattern-matching,string,algorithm,haskell,pattern-matching\
    \ |>\n<| c |>\nIf `a` is empty then `a == b` will never be true, since `a` is\
    \ never empty.\n<|/ c |>\n<| a dscore=0 tags=pattern-matching,string,algorithm,haskell,pattern-matching\
    \ |>\nI wanted to post a solution that is simple enough to read and understand\
    \ while still working on the efficiency of this approach.  \nThe general idea\
    \ is to construct a dictionary from each possible pattern and use the dictionary\
    \ to look up the next character in the string.  This will require a large amount\
    \ of computation but will result in lower run time than any other possible approach.\
    \  \nThe basic idea is to construct a dictionary and use that to look for the\
    \ next character in the input string. \n<code>\nimport Data.List", "  \n     \
    \ \n    if a == b \n        true\n    elseif a[-length(b)+1:] == b\n        true\n\
    \    elseif a[-length(b)+1:] == b\n        true\n    elseif b[-length(a)+1:] ==\
    \ a\n        true\n    elseif b[-length(a)+1:] == a\n        true\n    else\n\
    \        false", "    return ifelse(length(a) == length(b), true, ifelse(length(a)\
    \ > length(b), false, a==b || grep(a, rotationsOf(b)) || grep(b, rotationsOf(a))))\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nCan you provide a link to more information\
    \ on the complexity of these functions? I'm having trouble finding it in the documentation.\n\
    <|/ c |>\n<| c |>\nI added a link to the docs. I believe the complexity is O(n)\
    \ where n is the length of both strings (as it is an O(n) operation), since it\
    \ performs the greps twice, and the ifelse is O(1) since it returns the third\
    \ argument only if the first two arguments are equal (it is the last argument,\
    \ if the first two are different).\n<|/ c |>\n<| c |>\nI edited my post to include\
    \ some code I have written to solve the problem in Haskell, hopefully it will\
    \ be of some help to you.\n<|/ c |>\n<| c |>\nThank you for the code example!\
    \ I appreciate it. I will try to implement it into my own code. I didn't think\
    \ of using the `==` operator to compare the two strings. It seems more intuitive\
    \ than using `==` on `Char`s. Thanks for the explanation. :)\n<|/ c |>\n<| c |>\n\
    It took me a little while to wrap my head around the idea that Haskell would not\
    \ automatically use the `==` operator, but instead just compare the individual\
    \ elements. This means that using `==` in my code example would not work. Instead,\
    \ I've written an `==` function that checks if the first two letters are equal\
    \ and then compare the rest of the letters by checking the first two letters of\
    \ the second string with those of the first.\n<|/ c |>\n<| a |>\nHere is an implementation\
    \ in Java that does what I think you want\n<code>\npublic static void main(String[]\
    \ args) {\n    String word1 = \"abc\";\n    String word2 = \"abd\";\n    System.out.println(isCyclic(word1,\
    \ word2));\n    word1 = \"hello\";\n    word2 = \"ell\";\n    System.out.println(isCyclic(word1,\
    \ word2));\n    word1 = \"whassup\";\n    word2 = \"psus\";\n    System.out.println(isCyclic(word1,\
    \ word2));\n    word1 = \"abab\";\n    word2 = \"baa\";\n    System.out.println(isCyclic(word1,\
    \ word2));\n    word1 = \"efef\";\n    word2 = \"eeff\";\n    System.out.println(isCyclic(word1,\
    \ word2));\n", "    if length(a) == 0 || length(b) == 0 || length(a) == length(b)\n\
    \        return true\n    if a[0] == b[0]\n        return cycpattern_check(a[1..end-1],\
    \ b)\n    elseif a[1] < b[1] || b[1] < a[1]\n        return cycpattern_check(a,\
    \ b.take(1))\n    end", "    if length(a) == 0 || length(b) == 0 \n        return\
    \ true\n    \n    if b == '' \n        return false\n    \n    if length(a) >\
    \ length(b)\n        return false\n    \n    for i = 1 : length(a) - length(b)\
    \ + 1\n        if a[1:i] == b\n            return true\n    \n    return false",
  "    first::String = a\n    last::String = b\n    for i in (1 to b.length) do \n\
    \        if a.contains(last, i)\n            first = last\n            last =\
    \ first[(i + 1):end]\n        else\n            return false\n    end\n    return\
    \ true\nend", "    try\n        if b==\"\" \n        then return true\n      \
    \  else return false \n    catch ArgumentError\n        return false\n    end\n\
    \    try\n        if a==\"\"\n        then return true\n        else return false\
    \ \n    catch ArgumentError\n        return false\n    end\n    try\n        if\
    \ b==\"\" \n        then return true\n        else return false \n    catch ArgumentError\n\
    \        return false\n    end\n    try\n        if a==\"\"\n        then return\
    \ true\n        else return false \n    catch ArgumentError\n        return false\n\
    \    end\n    if b==\"\"\n    then return true\n    else return false \n    end\n\
    \    if a==\"\"\n    then return true\n    else return false \n    end\n    try\n\
    \        if b==\"\" \n        then return true\n        else return false \n \
    \   catch ArgumentError\n        return false\n    end\n    if a==\"\"\n    then\
    \ return true\n    else return false \n    end\n    try\n        if a==\"\"\n\
    \        then return true\n        else return false \n    catch ArgumentError\n\
    \        return false\n    end\n    if b==\"\"\n    then return true\n    else\
    \ return false \n    end\n    if a==\"\"\n    then return true\n    else return\
    \ false \n    end\n    if b==\"\"\n    then return true\n    else return false\
    \ \n    end\n    if a==\"\"\n    then return true\n    else return false \n  \
    \  end\n    if b==\"\"\n    then return true\n    else return false \n    end\n\
    \    if a==\"\"\n    then return true\n    else return false \n    end\n    if\
    \ b==\"\"\n    then return true\n    else return false \n    end\n    return true\n\
    end\n</code>\n<|/ q dscore=3 tags=julia |>\n<| c |>\nWelcome to Stack Overflow!\
    \ Please read [the tour](https://stackoverflow.com/tour), and [what's on topic](https://stackoverflow.com/help/on-topic).\
    \ Stack Overflow is a repository of high-quality questions with answers, guides,\
    \ and general explanations. Please [edit] your question to improve it.\n<|/ c\
    \ |>\n<| c |>\nThis sounds like a case for regular expressions. Please take a\
    \ look at https://julialang.org/en/v1/documentation/strings/#Regular-Expressions-and-String-Interpolation-1\n\
    <|/ c |>\n<| c |>\nHi Chris, I tried that but i could not get the logic right,\
    \ any help would be appreciated. I have done the code below but its not very efficient\
    \ and i was looking for something more efficient\n<|/ c |>\n<| c |>", "    \"\"\
    \"\n    >>> cycpattern_check(\"abcd\", \"abd\")\n    false\n    >>> cycpattern_check(\"\
    hello\", \"ell\")\n    true\n    >>> cycpattern_check(\"whassup\", \"psus\")\n\
    \    false\n    >>> cycpattern_check(\"abab\", \"baa\")\n    true\n    >>> cycpattern_check(\"\
    efef\", \"eeff\")\n    false\n    >>> cycpattern_check(\"himenss\", \"simen\"\
    )\n    true\n    \"\"\"", "    if length(a) <> length(b) return false\n    for\
    \ i=1:length(a)\n        if (a[i] == a[(length(a) - i)]) return true\n    end\n\
    \    return false\nend", "    if isempty(a) || isempty(b)\n        return false\n\
    \    end\n    if b==a\n        return true\n    end\n    if b==a[1:end-1]\n  \
    \      return true\n    end\n    return false\nend\n</code>\nThe function also\
    \ contains some comments so you can understand what it is doing. \nThere are a\
    \ lot of ways to do this and this is just one of them :)\n<|/ a tags=regex,julia\
    \ dscore=1 |>\n<| c |>\nThanks, this is really helpful! I'm a beginner at Julia,\
    \ and I've been working on learning regex in Julia's documentation, but my experience\
    \ is fairly limited. Thank you for pointing me in the right direction. I've made\
    \ some edits to my original post, which I think is better now.\n<|/ c |>\n<| a\
    \ |>\n<code>", "    if a == \"abcdefghijklmnopqrstuvwxyz\" or b == \"abcdefghijklmnopqrstuvwxyz\"\
    \n    then true\n    else false \n    end\nend", "    return (a==b) || ((b==a)\
    \ && find_substr_rotated_str(a,b))\n</code>\n<|/ a |>\n<| a tags=pattern-matching,algorithm,ruby,regex\
    \ dscore=0 |>\n<code>\ndef cycpattern_check(a::String, b::String)\n  pattern =\
    \ Regexp.new(a) ^ Regexp.new(b)\n  pattern.to_s.match(a) == pattern.to_s.match(b)\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThe `^` character is a bitwise XOR. Not what\
    \ I want.\n<|/ c |>\n<| c |>\nThat's exactly what it does. What makes you think\
    \ it's undesired?\n<|/ c |>\n<| c |>\nI didn't think it would do what I wanted\
    \ it to do. Now that I think about it, that's a silly thing to do. Thanks.\n<|/\
    \ c |>\n<| a dscore=0 tags=pattern-matching,algorithm,ruby,regex |>\n<code>\n\
    def cycpattern_check(a, b)\n  a.reverse.index(b.gsub(/\\w/) {|x| a.reverse[a.rindex(x)]\
    \ }) > 0\nend\n</code>\n<|/ a |>\n<| c |>\nI feel like this could be improved\
    \ with some memoization. Since we're using Ruby, the only thing that comes to\
    \ mind is turning the string into a Hash, using the letters as keys, with the\
    \ letters positions as values, then comparing those two hashes.\n<|/ c |>\n<|\
    \ c |>\nI was thinking of doing something like that, but I was thinking about\
    \ it more as a binary string matcher rather than a regex matcher. I don't know\
    \ Ruby, so I don't know whether a Hash would be a good approach, though it would\
    \ be nice to use one.\n<|/ c |>\n<| c |>\nI agree that memoization is probably\
    \ the right way to go.  However, in this case `a.reverse.index(b.gsub(/\\w/) {|x|\
    \ a.reverse[a.rindex(x)] }) > 0` is actually doing more work than it needs to.\n\
    <|/ c |>\n<| c |>\nOkay, I thought it was going to be too slow. Yeah, it's definitely\
    \ not as fast as the other answers here.\n<|/ c |>\n<| a tags=pattern-matching,algorithm,ruby,regex\
    \ |>\nHere's a more Rubyish version that doesn't use Regex:\n<code>\ndef cycpattern_check(a,\
    \ b)\n  b.each_char.each_with_index.include?(a.chars.rotate(b.chars.count).first)\n\
    end", "if length(a) > length(b) then\n    return false\nend", "     \n    length\
    \ = length(a)\n    firstpattern = substring(b,0,length(sub(b,0,length(b)))) \n\
    \    secondpattern = substring(a,0,length(sub(a,0,length(a)))) \n    if firstpattern\
    \ == secondpattern \n      return true\n    else if length(firstpattern) == 0\
    \ \n      return true\n    else \n      return false\n    end\n \nend", "    len_a,\
    \ len_b = length(a), length(b)\n    if len_a > len_b then\n        len_a, len_b\
    \ = length(b), length(a)\n    elseif len_b > len_a then\n        len_a, len_b\
    \ = length(a), length(b)\n    else\n        len_a, len_b = len_a, len_b", "  \
    \  matches_letter = match(setdiff(a,\"e\"), b)\n    matches_letter = matches_letter\
    \ == false || matches_letter == true\n    matches_letter = match(intersect(a,b),\
    \ b)\n    matches_letter = matches_letter == false || matches_letter == true\n\
    \    return matches_letter\nend", "    \n   ", '    return (cycpattern_check_internal(a,
    1, b, 0, b) ==1)', "    if is_string(a) && is_string(b) then \n        try\n \
    \           match(find(a,b), 1, true)\n        catch err\n            false\n\
    \        end\n    elseif is_string(b) then \n        try\n            match(find(a,b),\
    \ 1, false)\n        catch err\n            false\n        end\n    else\n   \
    \     false\n    end\nend", "\"\"\"\nCycle check", "\"\"\"\ncycpattern_check(a::String,\
    \ b::String)::Bool", "    \n    local a_inner = \"\"\n    local b_inner = \"\"\
    \n    local x = 1\n    local y = 1\n    local z = 1\n    \n    local i = a.len()\n\
    \    local j = b.len()\n    local k = i\n    local l = j\n    \n    while x >\
    \ 0 and y > 0 do\n        if a[x - 1] == b[y - 1] then\n            a_inner =\
    \ a_inner .. a[x - 1]\n            a_inner = a_inner .. a[y - 1]\n           \
    \ a_inner = a_inner .. b[y - 1]\n            x = x - 1\n            y = y - 1\n\
    \            k = k - 1\n        elsif a[x - 1] == b[y + 1] then\n            a_inner\
    \ = a_inner .. a[x - 1]\n            a_inner = a_inner .. a[y + 1]\n         \
    \   a_inner = a_inner .. b[y + 1]\n            x = x - 1\n            y = y +\
    \ 1\n            l = l - 1\n        elsif a[x - 1] == b[y] then\n            a_inner\
    \ = a_inner .. a[x - 1]\n            a_inner = a_inner .. b[y]\n            x\
    \ = x - 1\n            y = y\n            k = k - 1\n        elsif a[x + 1] ==\
    \ b[y] then\n            a_inner = a_inner .. a[x + 1]\n            a_inner =\
    \ a_inner .. b[y]\n            x = x + 1\n            y = y\n            l = l\
    \ - 1\n        elsif a[x + 1] == b[y + 1] then\n            a_inner = a_inner\
    \ .. a[x + 1]\n            a_inner = a_inner .. a[y + 1]\n            a_inner\
    \ = a_inner .. b[y + 1]\n            x = x + 1\n            y = y + 1\n      \
    \      k = k - 1\n        elsif a[x - 1] == b[y - 1] then\n            a_inner\
    \ = a_inner .. a[x - 1]\n            a_inner = a_inner .. a[y - 1]\n         \
    \   a_inner = a_inner .. b[y - 1]\n            x = x - 1\n            y = y -\
    \ 1\n            l = l - 1\n        else\n            a_inner = a_inner .. a[x\
    \ - 1]\n            a_inner = a_inner .. a[y + 1]\n            a_inner = a_inner\
    \ .. b[y + 1]\n            x = x - 1\n            y = y + 1\n            l = l\
    \ - 1\n        end\n    end", "    # Complete the function\n    pattern = String[b..a]\n\
    \    rotated_pattern = String[(b[1..end-2]..a[1..end-2])..(b[end-1]..a[end-1])]\n\
    \    if pattern in rotated_pattern \n        cycpattern_check(b, a)\n    else\
    \ \n        false\nend\n</code>\n<|/ q tags=string,julia |>\n<| a dscore=2 |>\n\
    You can use pattern matching like this:\n<code>", "    if length(a) == 0 || length(b)\
    \ == 0 then return false \n    if length(b) > length(a) then return false \n \
    \   if substr(b, 1, length(a)) == a then return true \n    for i in 1:length(b)\
    \ \n        if substr(b, i, length(a)) == substr(a,1,length(b)) then return true\
    \ \n    else return false \nend function \n</code>\n<|/ a dscore=4 tags=pattern-matching,python,string,substring\
    \ |>\n<| a tags=pattern-matching,python,string,substring |>\n<code>\ndef substring_search(string,\
    \ pattern):\n    # Initialize a boolean value to false\n    found = False", " \
    \       if b == a \n        then true\n        else if b == reverse(b) \n    \
    \    then true\n        else false\n    end\n</code>\n<|/ a |>\n<| c |>\nYour\
    \ code gives error `Stack overflow` when testing for `(\"abcdef\",\"abdef\")`\n\
    <|/ c |>\n<| a dscore=0 tags=string,substring,algorithm |>\n<code>", "       \
    \ match a with\n        | \"\" => True\n        | _ => cycpattern_check_aux(a,\
    \ b, [])\nend", "    \n    if length(a) == length(b) \n        return (match(a:sub(pattern(a,b)),b:sub(pattern(b,a))\
    \ \u2261 true))\n    else \n        return (length(a) <= length(b)) || (length(b)\
    \ <= length(a))\nend", "    return if b == a then true else false\n</code>\n<|/\
    \ q dscore=0 |>\n<| c |>\nPlease include a full program and expected output as\
    \ text, rather than as an image. That makes it easier for others to help you.\n\
    <|/ c |>\n<| a dscore=0 |>\nYou could use recursion:\n<code>\ncycpattern_check(a,\
    \ b, i = 0) -> i >= length(a) or i >= length(b) || a[i] == b[i] || a[i] == b[i]\
    \ - 1 or a[i] == b[i] + 1 ||\n                               cycpattern_check(a,\
    \ b, i + 1)\n</code>\nOr you could use indexing instead:\n<code>\ncycpattern_check(a,\
    \ b, 0) -> a[i] == b[0] || a[i] == b[1] - 1 or a[i] == b[2] + 1\n</code>\nAnd\
    \ then just use the function with a and b like so:\n<code>\ncycpattern_check(\"\
    abcd\", \"abd\")\ncycpattern_check(\"hello\", \"ell\")\ncycpattern_check(\"whassup\"\
    , \"psus\")\ncycpattern_check(\"abab\", \"baa\")\ncycpattern_check(\"efef\", \"\
    eeff\")\ncycpattern_check(\"himenss\", \"simen\")\n</code>\n<|/ a tags=string,haskell\
    \ |>\n<| a dscore=0 |>\nYou're doing it the hard way, and your solution is extremely\
    \ inefficient. You don't have to check every substring if every string contains\
    \ an exact match. You could use maps and then use all to do the check:\n<code>\n\
    cycpattern_check :: String -> String -> Bool\ncycpattern_check [] _ = False\n\
    cycpattern_check (a:as) (b:bs) = all (flip elem a) bs || (cycpattern_check as\
    \ bs)\n</code>\nFor your test cases cycpattern_check works fine. But it doesn't,\
    \ and in fact it's slower than the previous solutions:\n<code>\n\u03BB cycpattern_check\
    \ \"\" \"\"\nTrue\n\u03BB cycpattern_check \"a\" \"a\"\nTrue\n\u03BB cycpattern_check\
    \ \"a\" \"a\"\n\u03BB cycpattern_check \"a\" \"a\"\n\u03BB cycpattern_check \"\
    a\" \"a\"\n\u03BB cycpattern_check \"a\" \"a\"\n\u03BB cycpattern_check \"a\"\
    \ \"a\"\n\u03BB cycpattern_check \"a\" \"a\"\n</code>\nAs you can see, it's very\
    \ slow.\n<code>\n\u03BB cycpattern_check \"aaaaaaaaaa\" \"aaaaaaaaaa\"\n\u03BB\
    \ cycpattern_check \"aaaaaaaaaa", "    if length(a) == length(b) then\n      \
    \  for i = 1 to length(a) do\n            if substr(a, i, 1) \u2260 substring(b,\
    \ i, 1) then return false\n        end\n        return true\n    end\n    return\
    \ false\nend", "    if length(a) == length(b) == 0 \n    then true\n    else if\
    \ a==b \n    then true\n    else if cyclic_substring_test(a, b) \n    then true\n\
    \    else false\nend", "    \n    if length(b) == 0 \n        return true\n  \
    \  else if length(a) == 0 \n        return false\n    else if all(c in b[1..length(b)-1]\
    \ for c in a) \n        return true\n    else \n        return cycpattern_check(a,\
    \ rotatestring(a,1,length(b)))\n    \nend\n</cell>\n<code language=julia-1.5>\n\
    cycpattern_check(\"abcd\", \"abd\")\n</cell>\n<text>\nThe string 'hello' is a\
    \ substring of 'ell' because 'l' is a rotation of 'o'.", "    if length(b.slice)\
    \ == 0 then return false\n    elseif length(a.slice) == 0 then return false\n\
    \    elseif b == a then return true\n    elseif length(b) > length(a) then return\
    \ false\n    elseif length(b) < length(a) then return false\n    elseif !contains(b.slice,\
    \ a) then return false\n    else\n        cycpattern_check_aux a::String, b::String\n\
    \    end\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=string,recursion,julia |>\n\
    Here's an implementation I believe should be efficient:\n<code>", "    if !is_string(a)\
    \ || !is_string(b)\n        throw(ArgumentError(\"the arguments are neither strings\
    \ nor numbers, but the type of each argument is #{typeof(a)} and #{typeof(b)}\
    \ respectively\"))\n    end\n    if is_empty(a) || is_empty(b)\n        throw(ArgumentError(\"\
    the strings are empty or nil\"))\n    end\n    \n    \n    if length(word1(a))\
    \ > length(b) || length(b) > length(word1(a))\n        throw(ArgumentError(\"\
    the strings are of different lengths\"))\n    end", '  return match(a, b, any) ',
  "    a::String = replace(a,'\"',\"\") #remove any double quotes so cycpattern_check\
    \ can handle it\n    b::String = replace(b,'\"',\"\")\n    #a = a[2:end]\n   \
    \ #b = b[2:end]\n    \n    #println(a)\n    #println(b)\n    \n    if a==b\n \
    \       true\n    else\n        false\n    end\n    return true\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"\n    cycpattern_check1(a, b): Checks whether\
    \ a pattern appears in b as a rotation of a", "    a_len = len(a)\n    b_len =\
    \ len(b)\n    \n    if a_len == 0 or b_len == 0 \n        return false\n    if\
    \ a_len == b_len\n        return true\n    \n    let first_part_str = a[0..a_len\
    \ - b_len]\n    let second_part_str = b[0..b_len - a_len]\n    \n    if first_part_str\
    \ == second_part_str\n        return true\n    \n    \n    if str_repeat(first_part_str,\
    \ b_len) == \"\"\n        return true\n    if str_repeat(second_part_str, b_len)\
    \ == \"\"\n        return true\n    \n    let first_part = str_repeat(first_part_str,\
    \ b_len)\n    let second_part = str_repeat(second_part_str, b_len)\n    \n   \
    \ if first_part == \".\"\n        return true\n    if second_part == \".\"\n \
    \       return true\n    \n    \n    if b_len > a_len\n        return false\n\
    \    if a_len > b_len\n        return false\n    \n    \n    let i = 0\n    for\
    \ i in 0..b_len - 1\n        if b[i] != a[i + b_len]\n            return false\n\
    \    \n    \n    return true\n    \nend # end function cycpattern_check", "  \
    \  if issubset(a, b) \n    else if issuperset(a, b) \n    else \n        false\n\
    </code>\n<|/ a tags=string,python,string dscore=1 |>\n<| c |>\nHi and welcome\
    \ to SO! Please try to avoid code-only answers and try to explain what the code\
    \ does. Also, if you can give some details about the code you post it would make\
    \ it even better!\n<|/ c |>\n<| c |>\nPlease don't post only code as answer, but\
    \ also provide an explanation what your code does and how it solves the problem\
    \ of the question. Answers with an explanation are usually more helpful and of\
    \ better quality, and are more likely to attract upvotes.\n<|/ c |>\n<| c |>\n\
    Thank you for your kind suggestion, I will keep this in mind.\n<|/ c |>\n<| a\
    \ tags=string,python,string |>\nHere is my solution\n<code>\ndef check(string1,\
    \ string2):\n    list1 = list(string1)\n    list2 = list(string2)\n    \n    list1.sort(key=lambda\
    \ x:x.lower())\n    list2.sort(key=lambda x:x.lower())\n    \n    for c in list1:\n\
    \        if c in list2:\n            list2.remove(c)\n        else:\n        \
    \    return False\n    \n    return True\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    The OP does not want to compare `string1` against `string2` but `string2` against\
    \ `string1` -- this would only compare the second string against the first string.\
    \ Your function should take two arguments, not one.\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>\ndef check(a: str, b: str):\n    \"\"\"\n    >>> check('abcd', 'abd')\n\
    \    False\n    >>> check('hello', 'ell')\n    True\n    >>> check('whassup',\
    \ 'psus')\n    False\n    >>> check('abab', 'baa')\n    True\n    >>> check('efef',\
    \ 'eeff')\n    False\n    >>> check('himenss', 'simen')\n    True", "#this function\
    \  checks if a is a substring of b\n    if a == \"\" || (b == \"\") || (b .contains\
    \ a) \n        then true\n        else false\n    end \nend \n\"\"\"\nCyclic Patterns\n\
    Cyclic patterns are the set of words that do not contain any other words (as substrings)\
    \ in the set.\nA cyclic pattern can be seen as a repeating word that does not\
    \ contain itself.\nThere are three types of cyclic patterns:\n    1. a word can\
    \ be rotated several times,\n    2. a word can contain itself,\n    3. a word\
    \ can not be rotated after rotating it once.\nWrite a function that determines\
    \ whether a word is a cyclic pattern or not. For example, you can assume that\
    \ the word is lowercase.", "    if a == \"\" \n        or b == \"\"\n        return\
    \ true\n    let \n        first = split(a,\" \")\n        second = split(b,\"\
    \ \")\n    let \n        first = first[1..last(first)]\n        second = second[1..last(second)]\n\
    \    let \n        len = length(first)\n        len_second = length(second)\n\
    \        flag = true\n    for w in second\n        flag = flag and (w in first)\n\
    \    flag\nend", "    if a==b return true \n    if a==\"\" then return false \n\
    \    if b==\"\" then return false \n    for k in (length(a)):(length(b)) do \n\
    \        if b[k]==a[k] then return false \n    return true \nend \nend \n</code>\n\
    <|/ a |>\n<| c |>\n`string` can help here...", "{\n    i = length(a)\n    j =\
    \ length(b)\n    if ((i > 0) && (j > 0)) \n        && (substr(a, i, j) =~ (b |\
    \ \"\")) \n            cycpattern_check(a,(b & \"..\") || \"\")\n    return true\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nIt would be great if you could explain\
    \ your answer to OP.\n<|/ c |>\n<| c |>\nIt's not wrong, just not idiomatic, and\
    \ it's hard to understand for someone new to regular expressions. That's why I\
    \ made it a comment instead of an answer\n<|/ c |>\n<| a dscore=0 |>\nThis can\
    \ be done using regexp:\n<code>\nimport Data.Char", "    \"\"\"check whether b\
    \ match a substring in a\"\"\"\n    # create string s1 from a\n    s1 <- unlist(strsplit(a,\
    \ \"\"))\n    # create string s2 from b\n    s2 <- unlist(strsplit(b, \"\"))\n\
    \    # loop over s1\n    for (i in 1:length(s1)){\n        # check if s2 is in\
    \ s1\n        if (any(s2 .== s1[i]))\n            return true\n        # if not\
    \ break\n        else return false\n    }\n    return true\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nI think you mean `s2 <- unlist(strsplit(b, \"\"))`\n\
    <|/ c |>\n<| c |>\nWhat is `cycpattern_check` supposed to do? As it stands, this\
    \ doesn't return anything\n<|/ c |>\n<| a tags=julia,function,string dscore=0\
    \ |>\nI would recommend using regexp function using matchall like so: \n<code>\n\
    julia> issubstring(\"abcd\", \"abd\")\ntrue\njulia> issubstring(\"abcd\", \"be\"\
    )\nfalse\njulia> issubstring(\"abcd\", \"abd\")\ntrue\njulia> issubstring(\"abcd\"\
    , \"be\")\nfalse\njulia> issubstring(\"abcd\", \"abd\")\ntrue\njulia> issubstring(\"\
    abcd\", \"be\")\nfalse\njulia> issubstring(\"abcd\", \"be\")\ntrue\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\nSince Julia version 1.6, there is a function match\
    \ that does exactly what you want:\n<code>\njulia> match(\"a\" \"b\")\n1\n</code>\n\
    See the docs for details and an example of its usage.\n<|/ a tags=julia,function,string\
    \ |>\n<| a dscore=0 |>\nThe solution below is a bit slower than the others, but\
    \ it should be faster. Also, it returns the indices of the match. The regex solutions\
    \ are much more elegant.\n<code>", "    #your code goes here\n    if a == \"\"\
    \ or b == \"\"\n        return false\n    elseif b == a || b == \"\"\n       \
    \ return true\n    elseif strsearch(b,a)\n        return true\n    else\n    \
    \    return cycpattern_check(b[1..-1], a[1:end-1])\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nWhat should I do if I want to return the string that contains the pattern?\
    \ like `himenss` should return `simen` ?\n<|/ c |>\n<| c |>\nThe function returns\
    \ the string that contains the pattern. Check the edit\n<|/ c |>\n<| a dscore=1\
    \ |>\nHere is my version (which I wrote with Julia 0.6.0)\n<code>", "    # Write\
    \ your code here\n    pattern = a.strip\n    string = b.strip\n    if string in\
    \ pattern then\n        true\n    elseif pattern in string then\n        true\n\
    \    else\n        false\n    end\nend\n</code>\n<|/ a tags=pattern-matching,julia,string\
    \ |>\n<| a |>\nA few things are happening here. The key observation is that there\
    \ are two search patterns and you are interested in the one that is a prefix of\
    \ the other.\nThe first observation is the following:\n<code>", "    cdef int\
    \ n = len(a)\n    cdef int m = len(b)", "    \"\"\"\n    \n    Cyclomatic Complexity\
    \ of the pattern check: O(n)\n    \n    Uses string operations to check each element\
    \ in the pattern. ", "    # base case\n    if a.length <= 1 || b.length <= 1\n\
    \        return true\n    \n    # base case\n    if a == b\n        return true\n\
    \    \n    # recurse\n    return cycpattern_check(b[1..-1], a[1..-1]) \nend",
  "    if a==b return true\n    if length(b)==0 return false\n    if length(a)==0\
    \ return false\n    if length(a)==1 return (a==b) \n    if length(b)==1 return\
    \ (index(a,b)>=0) \n    if b[length(b)-1]==a[0] return index(a,b[length(b)-1])>=0\
    \ \n    if b[length(b)-1]==a[1] return index(a,b[length(b)-1])>=0 \n    if b[length(b)-1]==a[2]\
    \ return index(a,b[length(b)-1])>=0 \n    if b[length(b)-1]==a[3] return index(a,b[length(b)-1])>=0\
    \ \n    if b[length(b)-1]==a[4] return index(a,b[length(b)-1])>=0 \n    if b[length(b)-1]==a[5]\
    \ return index(a,b[length(b)-1])>=0 \n    if b[length(b)-1]==a[6] return index(a,b[length(b)-1])>=0\
    \ \n    if b[length(b)-1]==a[7] return index(a,b[length(b)-1])>=0 \n    if b[length(b)-1]==a[8]\
    \ return index(a,b[length(b)-1])>=0 \n    if b[length(b)-1]==a[9] return index(a,b[length(b)-1])>=0\
    \ \n    if b[length(b)-1]==a[10] return index(a,b[length(b)-1])>=0 \n    if b[length(b)-1]==a[11]\
    \ return index(a,b[length(b)-1])>=0 \n    if b[length(b)-1]==a[12] return index(a,b[length(b)-1])>=0\
    \ \n    if b[length(b)-1]==a[13] return index(a,b[length(b)-1])>=0 \n    if b[length(b)-1]==a[14]\
    \ return index(a,b[length(b)-1])>=0 \n    if b[length(b)-1]==a[15] return index(a,b[length(b)-1])>=0\
    \ \n    return false\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThis answer\
    \ is a bit too long for a comment on Jeff's answer (but still a valid solution).\n\
    <|/ c |>\n<| c |>\nSure thanks, I'll add it as an answer so it will get more exposure\n\
    <|/ c |>\n<| a tags=julia |>\n<code>\ncycpattern_check(a::String, b::String)::Bool\
    \ \n    if a==b return true\n    if length(b)==0 return false\n    if length(a)==0\
    \ return false\n    if length(a)==1 return (a==b) \n    if length(b)", "    #println(\"\
    a: \", a)\n    #println(\"b: \", b)\n    \n    if length(a) == 0 or length(b)\
    \ == 0 then false else \n        \n        if length(b) == length(a) then \n \
    \           for i in 0..(length(a) - length(b)) do \n                if (b[i +\
    \ length(b)] == a[i+length(a)]) then \n                    return true \n    \
    \            end \n            end \n        else \n            for i in 0..(length(b)\
    \ - length(a)) do \n                if (a[i + length(a)] == b[i + length(b)])\
    \ then \n                    return true \n                end \n            end\
    \ \n        end \n        \n    return false \nend \n</code>\n<|/ a dscore=0 tags=haskell\
    \ |>\n<| c |>\nThis code is O(nm) where n is the length of pattern and m is the\
    \ length of word. This is not good because for large n and m it will take a long\
    \ time to find the substring in a word.\n<|/ c |>\n<| c |>\nPlease consider modifying\
    \ your answer to include the code that you have written. Code only answers are\
    \ not considered good answers.\n<|/ c |>\n<| a tags=haskell |>\nThis is probably\
    \ the most efficient solution for this problem so far:\n<code>\ncycpattern_check\
    \ :: String -> String -> Bool\ncycpattern_check pat w = reverse pat `elem` w &&\
    \ reverse w `elem` pat\n</code>\nThe first pattern checks whether any rotation\
    \ of the first pattern is a substring in the second pattern.\nThe second pattern\
    \ checks whether any rotation of the second pattern is a substring in the first\
    \ pattern.\nBy rotating the patterns we avoid having to check every position in\
    \ the second pattern for each position in the first pattern.\n<|/ a dscore=0 |>\n\
    <| c |>\nNo, rotating the patterns does not avoid checking a position multiple\
    \ times in the second pattern for each position in the first pattern.\n<|/ c |>\n\
    <| c |>\nIn fact this is O(n*m) where n and m are the length of first and second\
    \ patterns. This is O(n*m) time complexity where n is the length of first and\
    \ m is the length of second pattern. By rotating the patterns we avoid having\
    \ to check every position in the second pattern for each position in the first\
    \ pattern.\n<|/ c |>\n<| c |>\nIt does not avoid multiple checks, it avoids checking\
    \ the second pattern multiple times.  If you had a pattern \"abab\" and the word\
    \ \"baa\" you might not want to check each character in \"baa\" multiple times\
    \ because it was a substring of \"abab\" multiple times.\n<|/ c |>\n<| c |>\n\
    Yes, you are correct", "\"\"\"\nReturn true if the second word or any of its rotations\
    \ is a substring in the first word\n\"\"\"\nif b in a\n    false\nelse\n    if\
    \ any(b in a[i] for i in (-n::Int))\n        true\n    else\n        false\nend\n\
    end\n\"\"\"\n Cycle in pattern\n\"\"\"", "    \"\"\"\n    \n    \n    >>> cycpattern_check(\"\
    hello\", \"ell\")\n    true\n    >>> cycpattern_check(\"whassup\", \"psus\")\n\
    \    false\n    >>> cycpattern_check(\"abab\", \"baa\")\n    true\n    >>> cycpattern_check(\"\
    efef\", \"eeff\")\n    false\n    >>> cycpattern_check(\"himenss\", \"simen\"\
    )\n    true", "    if length(a) == 0 or length(b) == 0 or length(a) == 0 || length(b)\
    \ == 0 then false else \n        for i in 0...length(b) - length(a) do \n    \
    \        if substring(substring(a, b), i, length(a) + length(i)) in substring(a,\
    \ i, length(a) + length(i)) then false else \n                true \n        \
    \    end \n        end \nend \nend \nend \n</code>\n<|/ a tags=string,substring,julia\
    \ dscore=1 |>\n<| a |>\nA few comments to consider:", "    if a==\"\" || b==\"\
    \"\n        return true\n    else if length(a) == length(b) && length(a) >= 3\
    \ && length(b) >= 3\n        try\n            if a in b # Check if pattern a is\
    \ substring of pattern b\n                cycpattern_check(a[1:length(a):1], substring(b,1,1))\n\
    \            else\n                cycpattern_check(a[1:length(a):1], substring(b,2,2))\n\
    \        catch ex\n            print(ex)\n    end\n    return false\nend", " \
    \   if length(b) > length(a) && a[1] == b[1]\n        return true\n    for m in\
    \ rot(b)\n        if any((m in a) for x in rot(a))\n            return true\n\
    \    return false\nend", "     return (findsub(a, 1, b)!=nil) \nend \n\"\"\"\n\
    \    \n\"\"\"\n    cycpattern_match_all(a::String, b::String)::Bool", "      \
    \  if length(a) == length(b) then \n             if a in b then return true else\
    \ return false \n        else \n             if length(b) > length(a) then return\
    \ false \n             else if length(b) < length(a) then return true  \n    \
    \         else \n                 if b[length(a):length(a)+length(b)] in a\n \
    \                then return true \n                 else \n                 \
    \    if length(b) == length(a)\n                     then return false \n    \
    \                 else if length(b) > length(a) \n                     then return\
    \ false\n                     else return true\n                     end\n   \
    \                  end\n                     end\n                     end\n \
    \                    end\n                     end", "    return (length(a) ==\
    \ length(b)) && (all(any(a[-index] == b[index])  for index in 1:length(a))) \n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nAm I the only one who thinks that using\
    \ an index as `a[-index] == b[index]` is not a nice way to compare strings ? Why\
    \ not using `strcmp` ?\n<|/ c |>\n<| c |>\n`strcmp` does not work if they have\
    \ different length. Try `cycpattern_check(\"abcd\", \"abde\")`.\n<|/ c |>\n<|\
    \ c |>\nAh! my bad, `strcmp` works with different lengths.\n<|/ c |>\n<| a dscore=0\
    \ |>\nYou don't need the function at all:\n<code>", "    a, b = sort(a, b) \n\
    \    a, b = sort(b, a) \n    \n    i = j = 0\n    while i <= length(a) && j <=\
    \ length(b)\n        if a[i] == b[j]\n            i += 1\n            j += 1\n\
    \        else\n            i +=  (i - j + 1)\n            j += 1\n        end\n\
    \    end", "    \n    if a == \"\" then return false \n    \n    match b[1..]\
    \ with\n    | \"a\" => \"b\"\n    | \"e\" => \"f\"\n    | \"i\" => \"m\"\n   \
    \ | \"o\" => \"n\"\n    | \"u\" => \"x\"\n    | \"y\" => \"y\"\n    | \"s\" =>\
    \ \"t\"\n    | \"r\" => \"k\"\n    | \"h\" => \"x\"\n    | \"p\" => \"b\"\n  \
    \  | c => if b in \"abcefhiopruy\" then c\n    | _ => false\n    end\n    \nend\
    \ #end of function cycpattern_check\n    \nend #end of module\n</code>\n<|/ a\
    \ |>\n<| c |>\nI used this solution with some slight modification to fix a syntax\
    \ error in the function body. Thanks Jonas!\n<|/ c |>\n<| a tags=julia |>\nThis\
    \ code works for me.\n<code>", "    match(a,b) == true\nend", "    if length(a)\
    \ == 0 \n        true\n    else if length(b) == 0 \n        false\n    else if\
    \ end(a) == 1 && end(b) == 1 \n        true\n    elseif end(a) > 1 && end(b) >\
    \ 1 \n        begin(a) == b\n    elseif end(a) > 1 && end(b) == 1 \n        begin(a)\
    \ == b\n    elseif end(a) == 1 && end(b) > 1 \n        begin(b) == a\n    else\
    \ \n        false\n    end\nend\n</code>\n<|/ a dscore=3 tags=string,julia |>\n\
    <| c |>\nI did a search for this and got it working quickly and quickly, but I'm\
    \ still not sure if it's really the most efficient way to do it.  I posted a follow-up\
    \ question [here](https://stackoverflow.com/questions/66560626/julia-function-for-string-substring-checks).\
    \  I wonder if anyone has any suggestions for optimizing?\n<|/ c |>\n<| c |>\n\
    I wrote a new answer that I think may be more efficient. Let me know what you\
    \ think!\n<|/ c |>\n<| a dscore=2 |>\nHere's an approach that doesn't require\
    \ the string to be reversed (which would require O(n^2) space in most cases).\
    \ I also found it easier to read\n<code>", "    cdef int m = len(a) \n    cdef\
    \ int n = len(b) \n    if m == 0 then \n        return true \n    if n == 0 then\
    \ \n        return false \n    if n > m then \n        return false \n    if not\
    \ (check_prefix(b, n) and check_suffix(a, b)) then \n        return false \n \
    \   return cycpattern_check(a + b[:m//2], b[m//2:]) \nend ", "    \n    true\n\
    end", '    return (b in a)', "    l = length(a) + length(b)\n    bool = l == 0\
    \ || (l == 1 && issubstring(a, b))\n    return bool\nend", "    if a.size <= 1\
    \ || b.size <= 1\n        return false\n    \n    a_length = a.size\n    b_length\
    \ = b.size\n    \n    if (a_length > b_length) || (b_length > a_length)\n    \
    \    return false", "\"\"\"\n    \n    \n    \n    if a == b \n        return\
    \ true\n    \n    \n    if length(a) < length(b) \n        return false\n    \n\
    \    \n    if length(a) == 0 \n        return true\n    \n    \n    if length(b)\
    \ == 0 \n        return true\n    \n    \n    if length(a) >= length(b)\n    \
    \    \n        \n        if length(a) == length(b) \n            \n          \
    \  if contains(a,b) \n                return true\n            else \n       \
    \         return false\n            \n        else \n        \n            \n\
    \            if cycpattern_check(a[1:],b) or cycpattern_check(a[1:],b[1:])\n \
    \               return true\n            else \n                return false\n\
    \            \n    end\nend", "    l = length(a)\n    k = length(b)\n    if k\
    \ == 0 || l == 0 \n        return true\n    \n    if (a[end-1] == b[1]) \n   \
    \     if ((k == 1) && (a[start] == b[1]))\n            cycpattern_check(a[1:end],\
    \ b[1:end])\n        else\n            true\n    else\n        if ((k > 1) &&\
    \ (a[end-2] == b[1]) && (cycpattern_check(a[1:end-1], b[1:end-1]))) \n       \
    \     cycpattern_check(a[1:end-1], b[1:end-1])\n        else\n            false\n\
    end\n    return true\nend", "        beginning_of_a = find(a,\"\",1)\n       \
    \ beginning_of_b = find(b,\"\",1)\n        \n        if beginning_of_b > beginning_of_a\
    \ || beginning_of_b == beginning_of_a + 1\n        then false\n        else true\n\
    \        end\n    end\n</cell>\n<code language=julia-0.5>\n\"\"\"\nCheck if string\
    \ a contains string b (case insensitive)", "    local i,j\n    local c = 1\n \
    \   local found = false\n    for i = 1, length(a) do\n        if (c == a) then\n\
    \            found = true\n        end\n        if (a[c] == b) then\n        \
    \    found = true\n        end\n        if (c == a) then\n            found =\
    \ true\n        end\n        c = c+1\n    end\n    return found\nend\n</code>\n\
    <|/ a dscore=0 tags=string,pattern-matching,match,julia |>\n<| a dscore=0 |>\n\
    I wrote a package for string pattern matching in Julia\nhttps://github.com/xingjian/RegexpMatch.jl\n\
    <code>\njulia> using RegexpMatch", "    if a==b then return true\n    else if\
    \ a == \"\" or b == \"\" then return false\n    else\n        \n        if length(split(a))\
    \ > length(split(b)) then return false\n        else\n            for i in (length(split(a))\
    \ - length(split(b))):-1:1\n                if substring(cycpattern_check(string(a,\
    \ i), string(b, i - 1)), a, b) == true then return true\n            end\n   \
    \     end\n    end\nend", "\"\"\"\nCheck if b starts a or ends a and return a\
    \ boolean\n\"\"\"\n    i = a.length-1\n    j = b.length-1\n    while i > 0 and\
    \ j > 0\n        if (a[i-1] == b[j-1])\n            i -= 1\n            j -= 1\n\
    \        else\n            if a[i-1] == b[j]\n                i -= 1\n       \
    \     else\n                if a[i-1] == b[j-1]\n                    i -= 1\n\
    \                else\n                    j -= 1\n    \n    if i == 0 or j ==\
    \ 0\n        return false\n    else\n        return true\nend", "    \n    match\
    \ b\n    | \"[\" ~ c ~ \"]\" => cycpattern_check(a, c)\n    | \"[\" ~ c ~ \"]\"\
    \ => cycpattern_check(a, c)\n    | \"[\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \"]\" =>\
    \ cycpattern_check(a, c)\n    | \"[\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c\
    \ ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \"]\" => cycpattern_check(a, c)\n    |\
    \ \"[\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\"\
    \ ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c\
    \ ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \"\
    ,\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~\
    \ c ~ \"]\" => cycpattern_check(a, c)\n    | \"[\" ~ c ~ \",\" ~ c ~ \",\" ~ c\
    \ ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \"\
    ,\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~\
    \ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~\
    \ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\"\
    \ ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c\
    \ ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \"\
    ,\" ~ c ~ \",\" ~ c ~ \"]\" => cycpattern_check(a, c)\n    | \"[\" ~ c ~ \",\"\
    \ ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ~ c ~ \",\" ", " \n    if a == \"\" || b\
    \ == \"\" \n        return false \n    \n    if b == a \n        return true \n\
    \    \n    sz = length(a) \n    sz2 = length(b) \n    \n    if sz == 0 \n    \
    \    return false \n    \n    if sz2 == 0 \n        return true \n    \n    if\
    \ sz > sz2 \n        sz2 = sz \n    \n    sz2 = sz2 - sz + 1 \n    \n    if sz2\
    \ <= 0 \n        return false \n    \n    if b[sz2] != \"\" \n        return false\
    \ \n    \n    if sz == sz2 \n        return true \n    \n    sz2 = sz2 + 1 \n\
    \    \n    if sz2 > sz \n        sz2 = sz \n    \n    while sz < sz2 \n      \
    \  sz2 = sz2 + 1 \n        sz = sz + 1 \n    \n    i = 0 \n    j = 0 \n    k =\
    \ 0 \n    \n    while i <= sz - sz2 \n        j = i + sz2 \n        \n       \
    \ if a[j:k] == b[i:j+1] \n            return true \n        \n        k += 1 \n\
    \        \n        i = j + 1 \n    \n    if i < sz \n        return false \n \
    \   \n    return false \n \nendfunction \n</cell>\n<code language=julia-1.5>\n\
    \"\"\"You are given 2 words. You need to return true if the second word or any\
    \ of its rotations is a substring in the first word\n    >>> cycpattern_check(\"\
    abcd\", \"abd\")\n    false\n    >>> cycpattern_check(\"hello\", \"ell\")\n  \
    \  true\n    >>> cycpattern_check(\"whassup\", \"psus\")\n    false\n    >>> cycpattern_check(\"\
    abab\", \"baa\")\n    true\n    >>> cycpattern_check(\"efef\", \"eeff\")\n   \
    \ false\n    >>> cycpattern_check(\"himenss\", \"simen\")\n    true", "  if length(a)\
    \ >= length(b) || length(b) == 0 \n    return true\n  else if length(b) == 1 \n\
    \    if substr(b, 0, 1) == substr(a, b, 0, 1) \n      return true\n    else\n\
    \      return false\n  else \n    if length(a) >= length(b)\n      a += cyclic_rotation(b,\
    \ length(b))\n      return cycpattern_check(a, substring(a, b))\n    else\n  \
    \    b += cyclic_rotation(a, length(a))\n      return cycpattern_check(b, substring(b,\
    \ length(a)))\n  end\nend\n</code>\n<|/ a |>\n<| a tags=string,julia dscore=2\
    \ |>\nThis one works by concatenating all the rotations in order.\n<code>\njulia>\
    \ function cycpattern_check(a::String, b::String)\n           i = 1\n        \
    \   while i <= length(a)\n               b = cyclic_rotation(b, length(b))\n \
    \              a = cyclic_rotation(a, length(a))\n               i += 1\n    \
    \       end\n           return b == a\n       end\ncycpattern_check (generic function\
    \ with 1 method)", "    if length(a) == 0 || length(b) == 0 || length(a) > length(b)\
    \ then \n        false\n    elseif length(a) > length(b) then \n        cycpattern_check(b,\
    \ a)\n    elseif length(b) > length(a) then \n        cycpattern_check(a, a)\n\
    \    elseif length(a) == 0 || length(b) == 0 then \n        true\n    else\n \
    \       if\n            end(a) \u2208 b\n        then\n            true\n    \
    \    elseif\n            end(b) \u2208 a\n        then\n            true\n   \
    \     else\n            if\n                length(rotate_right(a))  \u2208 length(a)\
    \ && length(rotate_right(b)) \u2208 length(b)\n            then\n            \
    \    cycpattern_check(rotate_right(a), rotate_right(b))\n            else\n  \
    \              false\n            end\n        end\n    end\nend", "    a=a.chars\n\
    \    b=b.chars\n    count=0\n    for i in a\n        count+=1\n    for i in b\n\
    \        count+=1\n    \n    if count==0\n        return true\n    \n    \n  \
    \  for i in a\n        if i>count\n            return false\n    \n    for i in\
    \ b\n        if i>count\n            return false\n    \n    for i in a:\n   \
    \     flag=1\n        for j in b:\n            if i==j\n                flag=0\n\
    \                break\n        if flag\n            return false\n    \n    for\
    \ i in b:\n        flag=1\n        for j in a\n            if i==j\n         \
    \       flag=0\n                break\n        if flag\n            return false\n\
    \    \n    return true\nend", "#a::String\n#b::String\n\"\"\"\n    Check whether\
    \ the second word or any of its rotations is a substring in the first word.\n\
    \    \n    \n    Parameters\n    ----------\n    a : String a word\n    b : String\
    \ second word", "        local x::Bool = true #or false\n        a::String = a::lower\n\
    \        b::String = b::lower\n        if length(a) > length(b) then return x\
    \ else return false\n        if a[1] == b[1] then return cycpattern_check(a[2:],\
    \ b[2:])\n        else return cycpattern_check(a[1:], b[1:]) or cycpattern_check(a[1:],\
    \ b[1:])\n        end\nend\n</code>\n<|/ a tags=string,julia,string dscore=2 |>\n\
    <| a |>\nAnother implementation:\n<code>", "    a_length::Int = length(a)\n  \
    \  b_length::Int = length(b)\n    \n    if a_length > b_length \n        false\n\
    \    elseif a_length < b_length\n        true\n    else\n        if a_length ==\
    \ b_length\n            if contains(a, b)\n                true\n            else\n\
    \                false\n        else\n            if contains(a, substring(b,\
    \ a_length))\n                true\n            else\n                false",
  " \n    if length(a) == 0 || length(b) == 0\n        return false\n    else\n  \
    \      return (a in b) || cycpattern_check(rotten(a), b)", "  if length(a) ==\
    \ 0 || length(b) == 0\n    return true\n  \n  if length(a) == length(b)\n    return\
    \ b == a\n  end\n  \n  if length(a) > length(b)\n    return false\n  end\n  \n\
    \  for i in range(a.length - 1)\n    \n    if b == a.substring(i..(i+1))\n   \
    \   return true\n    end\n  end\n  return false\nend", "    word_a = split(a)\n\
    \    word_b = split(b)\n    count_a = length(word_a)\n    count_b = length(word_b)\n\
    \    \n    if count_a < count_b \n        then return false \n        else \n\
    \            \n            if count_a == 0 \n                then return true\
    \ \n                else \n                    \n                    let word_c_1\
    \ = word_a[1..count_b-1] \n                    let word_c_2 = word_b[1..count_a-1]\
    \ \n                    for i in word_c_1 do \n                        for j in\
    \ word_c_2 do \n                            if i == j \n                     \
    \           and j != 0 \n                                then return true \n \
    \                               else return false \n                    else return\
    \ false \n    else \n        then return false \n        else \n            \n\
    \            if count_b == 0 \n                then return true \n           \
    \     else \n                    \n                    let word_c_1 = word_a[count_b..-1]\
    \ \n                    let word_c_2 = word_b[count_a..-1] \n                \
    \    for i in word_c_1 do \n                        for j in word_c_2 do \n  \
    \                          if i == j \n                                and j !=\
    \ 0 \n                                then return true \n                    \
    \            else return false \n    else \n        then return false \n    else\
    \ \n        then return false \n    end\nend \n</cell>\n<code language=julia-1.2>\n\
    @test cycpattern_check(\"abcd\", \"abd\")\n</cell>\n<code language=julia-1.2>\n\
    @test cycpattern_check(\"hello\", \"ell\")\n</cell>\n<code language=julia-1.2>\n\
    @test cycpattern_check(\"whassup\", \"psus\")\n</cell>\n<code language=julia-1.2>\n\
    @test cycpattern_check(\"abab\", \"baa\")\n</cell>\n<code language=julia-1.2>\n\
    @test cycpattern_check(\"efef\", \"eeff\")\n</cell>\n<code language=julia-1.2>\n\
    @test cycpattern_check(\"himenss\", \"simen\")\n</cell>\n<text>\nString Functions",
  "    if a.length == 0 || b.length == 0\n        return true\n    if a.length ==\
    \ 1\n        return true\n    if b.length == 1\n        return true\n    if a[1]\
    \ != b[1]\n        return false\n    if a[1] in 'aeiou'\n        return true\n\
    \    return cycpattern_check(a[2:], b) end\n</code>\n<|/ a tags=recursion,julia\
    \ |>\n<| a dscore=1 |>\nHere is a recursive solution, which is very efficient.\n\
    <code>", "    if a.len < b.len\n        return false\n    \n    len1 = length(a)\n\
    \    len2 = length(b)\n    \n    i = 0\n    j = 0\n    \n    while i < len1 &&\
    \ j < len2\n        if a[i] == a[j]\n            i += 1\n            j += 1\n\
    \        elseif a[i] == b[j]\n            i += len1 - 1\n            j += 1\n\
    \        else\n            i += 1\n            j += 1\n    end\n    \n    return\
    \ j == len2\nend\n</cell>\n<text>\n3.4 Longest Common Substring\nQuestion:\nGiven\
    \ two strings S and T, find the longest common substring between them. \nIf there\
    \ is no substring, return an empty string \"\".\nIf there is substring P, then\
    \ P is a substring of both S and T and is equal to one of the following:", " \
    \ result = false\n  for i in 0:len(a)-1 do\n    if i==0 or a[i] != a[i-1] \n \
    \   then\n      result = true\n    else \n      result = false if b[(i-1)..i]\
    \ =~ a\n    end\n  end\n  return result\nend\n</code>\n<|/ a tags=pattern-matching,julia,string\
    \ dscore=1 |>\n<| c |>\nThis was pretty much what I was looking for. Thanks! I've\
    \ posted my full working code at the bottom of my question to see if it helps\
    \ someone else.\n<|/ c |>\n<| c |>\nI appreciate you taking the time to write\
    \ up your solution!\n<|/ c |>\n<| a |>\nI ended up creating my own function to\
    \ solve this problem after doing some more research, this is my final code:\n\
    <code>", "    cdef int start = 0\n    cdef int end = 0\n    cdef int length =\
    \ a.length\n    cdef int length2 = b.length\n    cdef int pos\n    cdef int pos2\n\
    \    cdef int j\n    cdef int match", "    if length(a) == 0 ||  length(b) ==\
    \ 0 return true\n    if contains(b, a[1:end-1]) || contains(b, a[1:end]) || contains(b,\
    \ a[end-3:end-1]) || contains(b, a[end-3:end]) \n        return true\n    else\
    \ return false\nend", "  if(a==b) \n    return true\n  else if(a==\"\")\n    return\
    \ false\n  else\n    for a in b\n      return true\n    end\n  end\nend", "  \
    \  # code here\n    sz = length(a)\n    sz1 = length(b)\n    if sz == 0 || sz1\
    \ == 0\n        true\n    elseif sz > sz1\n        if issubstring(a[sz .. sz1],\
    \ b)\n            true\n        else\n            false\n    elseif sz1 < sz\n\
    \        if issubstring(b[sz1 .. sz], a)\n            true\n        else\n   \
    \         false\n    else\n        false", "    if (length(a) == length(b)) then\
    \ \n    true \n    else \n    false\n    end\n</code>\n<|/ a dscore=0 tags=string-matching,ocaml,pattern-matching,string\
    \ |>\n<| c |>\nWelcome to Stack Overflow. Code-only answers aren't particularly\
    \ helpful. Please add some explanation as to why this code works, and how it helps\
    \ solve the problem.\n<|/ c |>\n<| c |>\nThe solution provided by is probably\
    \ the most optimal in the context of big strings, since it works by comparing\
    \ each character in each string\n<|/ c |>\n<| c |>\nThanks for your answer! The\
    \ problem is I don't understand the `if length(a)==length(b) then true else false`\
    \ part. I did a quick search and found a post on [programmers.SE](https://programmers.stackexchange.com/questions/203052/what-does-if-lengtha-lengthb-mean-for-a-given-variable)\
    \ that explain the `if length(a)==length(b) then true else false` part. Can you\
    \ give an example of the case where `if length(a)==length(b) then true else false`\
    \ would return a false?\n<|/ c |>\n<| c |>\nSure, I'll edit the post with an example\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>\nlet cycpattern_check (a, b) = \n  let len\
    \ = String.length a in \n  let len = String.length b in\n  let i = 0 in \n  if\
    \ i < len then \n    let c = String.sub b i 1 in \n    if c = String.sub b 0 i\
    \ then \n      false\n    else\n      match String.length b with\n        | 0\
    \ -> true\n        | n -> \n          let c = String.sub b i 1 in \n         \
    \ if c = String.sub b 0 i then \n            cycpattern_check (a, String.sub b\
    \ i len)\n          else \n            cycpattern_check (String.sub b 0 i b) b\n\
    \      in\n    else \n      cycpattern_check (a, String.sub b i len) \n  else\
    \ \n    true\n</code>\n<|/ a tags=string-matching,ocaml,pattern-matching,string\
    \ |>\n<| c |>\nYour code looks like an implementation of a `string_match`. Can\
    \ you point out what your `string_match` is?\n<|/ c |>\n<| c |>\nNo problem, I\
    \ tried to make it clearer. Thanks for the feedback\n<|/ c |>\n<| a dscore=0 |>\n\
    This question was asked a while ago, but I thought I'd ", "    if length(substring(a))\
    \ > length(a) || length(substring(b)) > length(b) || length(a) > length(b) ||\
    \ length(b) > length(a) \n    then false \n    else if substring(a,length(a),length(a))\
    \ ~~ b \n    then true \n    else if substring(b,0,length(b)) ~~ substring(a,0,length(a))\n\
    \    then true \n    else false\n    end\nend cycpattern_check\n</cell>\n<cell>",
  "    if length(a) == 0 && length(b) == 0 return true\n    if length(a) == 0 || length(b)\
    \ == 0 return false\n    if length(a) > length(b) then return false \n    for\
    \ i in range(a.length() - 1, b.length()-1, -1) do\n        if substring(a[i],\
    \ b[i]) != \"\" then return false\n    else return true\nend", "\tword_a = StringSplit(a,\
    \ \" \")\n\tword_b = StringSplit(b, \" \")\n\tn = length(word_a)\n\tm = length(word_b)\n\
    \t\n\t\n\tfor i in [1..n-1]\n\t\tfor j in [1..m-i]\n\t\t\tif word_a[i] == word_b[j..j+i]\n\
    \t\t\t\ttrue\n\t\t\telse\n\t\t\t\tfalse\n\t\t\tend\n\t\tend\n\tend\nend\n\"\"\"\
    \n\"\"\"\n## Write a function `cycpattern_check2` that takes 2 words as inputs\
    \ and returns true if either of the words have the same substring pattern as each\
    \ other, or if they have no substring patterns\n\"\"\"", "    cdef int i = 0\n\
    \    cdef int j = 0\n    cdef int k = 0\n    cdef int m = 0\n    cdef int n =\
    \ 0\n    cdef int r = 0\n    cdef int w = 0\n    cdef int b = 0\n    cdef int\
    \ t = 0\n    cdef int d = 0\n    cdef int u = 0\n    cdef int a = 0\n    cdef\
    \ int c = 0\n    cdef int b = 0\n    cdef int e = 0\n    cdef int i = 0\n    cdef\
    \ int j = 0\n    cdef int k = 0\n    cdef int l = 0\n    cdef int m = 0\n    cdef\
    \ int n = 0\n    cdef int o = 0\n    cdef int p = 0\n    cdef int r = 0\n    cdef\
    \ int s = 0\n    cdef int t = 0\n    cdef int v = 0\n    cdef int w = 0\n    cdef\
    \ int x = 0\n    cdef int y = 0\n    cdef int z = 0\n    cdef int w = 0\n    cdef\
    \ int t = 0\n    cdef int u = 0\n    cdef int v = 0\n    cdef int w = 0\n    cdef\
    \ int x = 0\n    cdef int y = 0\n    cdef int z = 0\n    cdef int w = 0\n    cdef\
    \ int t = 0\n    cdef int u = 0\n    cdef int v = 0\n    cdef int w = 0\n    cdef\
    \ int x = 0\n    cdef int y = 0\n    cdef int z = 0\n    cdef int w = 0\n    cdef\
    \ int t = 0\n    cdef int u = 0\n    cdef int v = 0\n    cdef int w = 0\n    cdef\
    \ int x = 0\n    cdef int y = 0\n    cdef int z = 0\n    cdef int w = 0\n    cdef\
    \ int t = 0\n    cdef int u = 0\n    cdef int v = 0\n    cdef int w = 0\n    cdef\
    \ int x = 0\n    cdef int y = 0\n    cdef int z = 0\n    cdef int w = 0\n    cdef\
    \ int t = 0\n    cdef int u = 0\n    cdef int v = 0\n    cdef int w = 0\n    cdef\
    \ int x = 0\n    cdef int y = 0\n    cdef int z = 0\n    cdef int w = 0\n    cdef\
    \ int t = 0\n    cdef int u = 0\n    cdef int v = 0\n    cdef int w = 0\n    cdef\
    \ int x = 0\n    cdef int y = 0\n    cdef int z = 0\n    cdef int w = 0\n    cdef\
    \ int t = 0\n    cdef int u = 0\n    cdef int v = 0\n    cdef int w = 0\n    cdef\
    \ int x = 0\n    cdef int y", "    if length(a) == length(b) && a.head == b.head\
    \ \n        && contains(a, b)\n    else false\n    end\nend", "    # write your\
    \ code in python.\n    if a==\"\" || b==\"\"\n        return false\n    else\n\
    \        return find_substring(a[1:], b[1:]) > 0\n    end\nend\n</cell>\n<text>\n\
    Problem 8\nWrite a function that returns true if a word is a palindrome", "  \
    \  word_a = words(a)\n    word_b = words(b)\n    word_b.sort()\n    if word_a\
    \ == word_b\n        return true\n    for w in word_b\n        if w == word_a[end]\n\
    \            return true\n        end = end - 1\n    end\n    return false\nend",
  "    if length(a) < length(b) then false\n    else if length(a) == length(b) then\
    \ \n        if a==b then true\n        else if strcmp(a,b)==0 then true\n    \
    \    else if a[(length(a) - length(b)):length(a)]==b then true\n        else false\
    \ \n        else false\n    else false\n    end\nend\n</code>\n<|/ a |>\n<| a\
    \ |>\nHere's a O(2n) algorithm that takes input in the format [[word]] where each\
    \ word is a String. This can be easily extended to a 2D input format using String[String].\
    \ Here is a simple implementation:\n<code>", "    \n    \n    #check if a is of\
    \ length 2\n    if length(a) < 2 \n       return false \n    \n    # check the\
    \ first letter\n    if a[1] == a[0]\n        return true \n    \n    # check if\
    \ b is a substring of a\n    for letter in b\n        pos = findfirst(a[2:], letter)\n\
    \        if pos != -1 and pos != length(a) - 2\n            return true\n    return\
    \ false", "    letters = filter(x->isalpha(x), a)\n    letters2 = filter(x->isalpha(x),\
    \ b)\n    \n    if length(a) != length(b) || any(x \u2209 letters, x \u2209 letters2)\n\
    \        return false\n    \n    \n    countsA = count(letters,a)\n    countsB\
    \ = count(letters,b)\n    \n    letters2Subset = filter(x->isalpha(x) and x in\
    \ letters, letters2)\n    if countsA > 0 and any(x \u2209 letters, x \u2209 letters2Subset)\
    \ #if the pattern contains letters in the second word\n        return true\n \
    \   \n    if countsB > 0 and any(x \u2209 letters, x \u2209 letters2Subset) #if\
    \ the pattern contains letters in the first word\n        return true\n    \n\
    \    if countsA < countsB #if the pattern contains letters only in the second\
    \ word\n        return false\n    \n    \n    counts2A = count(letters2,a)\n \
    \   counts2B = count(letters2,b)\n    \n    letters1Subset = filter(x->isalpha(x)\
    \ and x in letters, letters2)\n    if counts2A > 0 and any(x \u2209 letters, x\
    \ \u2209 letters1Subset) #if the pattern contains letters in the second word\n\
    \        return true\n    \n    if counts2B > 0 and any(x \u2209 letters, x \u2209\
    \ letters1Subset) #if the pattern contains letters in the first word\n       \
    \ return true\n    \n    if counts2A < counts2B #if the pattern contains letters\
    \ only in the second word\n        return false\n    \n    return false\nend ",
  "    if a == b \n        return true \n    else \n        return cycpattern_check(cycpattern_find(a,b),\
    \ cycpattern_find(b,a)) \nend\n</code>\n<|/ a |>\n<| a tags=pattern-matching,julia,string\
    \ dscore=1 |>\nFor a pure Julia solution you can do this:\n<code>", "    if length(a)\
    \ > length(b) then \n        return false\n    else \n        local s = \"\"\n\
    \        for i in each(b) do \n            s = s + i\n        end\n        for\
    \ j in each(a) do \n            if j == s then return true \n            else\
    \ \n                return false\n            end\n        end\nend\nend \n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=string,lua,pattern-matching,algorithm dscore=0 |>\n\
    It depends on your definition of \"word\".  A word is defined as a sequence of\
    \ letters that do not contain spaces or punctuation characters. So the example\
    \ you gave of a word that consists of \"abc\" would have a length of 4 characters,\
    \ not 5.  \nThe following code uses the Lua string library to determine if the\
    \ second word is a substring of the first word.  It will also detect if the second\
    \ word is \"completely\" contained in the first word.  \n<code>", "    \n    \n\
    \    if a==\"\" || b==\"\" then return false\n    else if length(a) > length(b)\
    \ then return false\n    else if length(a) < length(b) then return false\n   \
    \ else if a==b then return true\n    else \n        if a==\"\" || b==\"\" then\
    \ return false\n        elsif (b==\"\" || a==\"\") then return false\n       \
    \ elseif a==b[end-1] then return true\n        else\n            \n          \
    \  for i in 0 .. (length(b)-1)\n                if a==b[(end-i-1)..(end-1)] then\
    \ \n                    \n                    return true\n                end\n\
    \            end\n            return false\n        end\n    end\nend\n</code>\n\
    <|/ a tags=julia,string |>\n<| c |>\nI like your answer but unfortunately I get\
    \ a `UndefRefError: access to undefined reference` error.\n<|/ c |>\n<| c |>\n\
    Hi Andrew I added the function in julia v0.5\n<|/ c |>\n<| a |>\nBased on's solution,\
    \ here's an improved version in Julia v0.5.0:\n<code>", "\t\n\t\n        if length(a)\
    \ == length(b)\n            true\n        else\n            if ismatch(a,b)\n\
    \                true\n            else\n                if ismatch(b,a)\n   \
    \                 true\n                else\n                    false\n    \
    \    end\n    end\nend\n</cell>\n<code language=julia-1.6>\ncycpattern_check(\"\
    a\",\"a\")\n</cell>\n<text>\nProblem 4", "    \n    if a != \"\" && b != \"\"\n\
    \        a = a.chars \n        b = b.chars\n        l = length(a)\n        m =\
    \ length(b)\n        \n        if m < l\n            return false\n        end\n\
    \        \n        if l == 0\n            return true\n        end\n        \n\
    \        rot = get_rotations(a, b)\n        \n        if l == 1\n            return\
    \ true\n        end\n        \n        for j in rot\n            if in(a,b[j])\n\
    \                return true\n            end\n        end\n        \n       \
    \ return false\n    end\nend\n</cell>\n<code language=julia-1.5>", "    #cycpattern_check(\"\
    abcd\", \"abd\")\n    if a == \"h\" && b == \"el\" || a == \"o\" && b == \"ll\"\
    \ || a == \"e\" && b == \"ll\" || a == \"el\" && b == \"ll\" || a == \"ll\" &&\
    \ b == \"el\" || a == \"el\" && b == \"el\"\n    true\n    else\n        false\n\
    \    end\nend", "    if length(a) < 3 || length(a) > length(b) || length(b) <\
    \ 3 || length(b) > length(a) then return false\n    \n    i = 1 # counter for\
    \ number of rotations left\n    \n    while i <= length(b) && i <= length(a) do\
    \ \n        if b[i] != a[i] \n            then return false\n        end\n   \
    \     i = i + 1\n    end\n    \n    return true\nend\n</cell>\n<code language=julia-1.5>",
  "    letters=map(letter,a)\n    rotations=map(letter,b)\n    issubstring=false\n\
    \    for r in rotations\n        if letters.contains(r) == true\n            issubstring=true\n\
    \            break\n    return issubstring\nend\n</cell>\n<code language=julia-0.6>\n\
    cycpattern_check(\"abcd\", \"abd\")\n</cell>\n<code language=julia-0.6>\ncycpattern_check(\"\
    whassup\", \"psus\")\n</cell>\n<code language=julia-0.6>\ncycpattern_check(\"\
    abab\", \"baa\")\n</cell>\n<code language=julia-0.6>\ncycpattern_check(\"efef\"\
    , \"eeff\")\n</cell>\n<code language=julia-0.6>\ncycpattern_check(\"himenss\"\
    , \"simen\")\n</cell>\n<code language=julia-0.6>\n# your solution is here\n</cell>\n\
    <code language=julia-0.6>\n# testing your code", "    \n    lengthA, lengthB =\
    \ length(a), length(b)\n    if lengthA > lengthB then true\n    else if lengthB\
    \ > lengthA then false\n    else\n        if issubstring(a,b) then true\n    \
    \    else cycpattern_check(rotater(b,lengthB-lengthA),rotater(a,lengthA-lengthB))\n\
    \    end\nend\n</code>\n<|/ a |>\n<| c |>\nNice solution, but I think the complexity\
    \ can be improved. `issubstring` is O(n) and `rotater` is O(n^2), so complexity\
    \ will go up for any cases where we check all possible substrings in the same\
    \ string. Maybe use dynamic programming with memoization to solve this problem?\n\
    <|/ c |>\n<| c |>\nYes, using memoization would be better. Here is a [link](http://rosettacode.org/wiki/Longest_common_substring_with_rotations)\
    \ to my previous answer that uses memoization. I just wrote it quickly and not\
    \ tested. But it gives the correct answers. It's pretty similar to your solution.\
    \ It just doesn't check the substrings of the longer of the two strings.\n<|/\
    \ c |>\n<| c |>\nThank you for your efforts. As mentioned in the comments, memoization\
    \ will help to speed up the search as you go through all rotations of `a`\n<|/\
    \ c |>\n<| a tags=pattern-matching,string,julia,substring |>\nAnother implementation\
    \ without iterating through all substrings in the first string. We use the same\
    \ idea as was described here: longest common substring with rotations.\n<code>\n\
    cycpattern_check(a, b) issubstring(a::String, b::String) =\n    if length(a) >\
    \ length(b) then true\n    else if length(a) == length(b) then b == a\n    else\n\
    \        if issubstring(a,b) then true\n        else if issubstring(b,a) then\
    \ false\n        else\n            if length(a) < length(b) then true\n      \
    \      else if length(b) < length(a) then false\n            else\n          \
    \      if issubstring(a,b) then true\n                else if issubstring(b,a)\
    \ then false\n                else\n                    let s1 = length(a) - length(b)\n\
    \                    let s2 = length(b) - length(a)\n                    let s3\
    \ = length(a) - s3\n                    let s4 = length(b) - s3\n            \
    \        if issubstring(a,b) then false\n                    elseif issubstring(b,a)\
    \ then true\n                    else if s1 < s2 then false\n                \
    \    else if s2 < s1 then true\n                    else if s3 < s4 then true\n",
  "   \n    if length(b) == 0 \n    then \n        true \n    else \n        if length(a)\
    \ == 0 \n        then \n            false \n        else \n            if isupper(a)\
    \ \n            then \n                if b == \"\" \n                then \n\
    \                    false \n                else \n                    if isupper(b)\
    \ \n                    then \n                        cycpattern_check(b, left(b,\
    \ length(b) - 1))\n                    else \n                        cycpattern_check(b,\
    \ right(b, length(b) - 1))\n                else \n                    if isupper(b)\
    \ \n                    then \n                        cycpattern_check(right(b,\
    \ (length(b) - 1)), left(b, length(b) - 1))\n                    else \n     \
    \                   cycpattern_check(right(b, (length(b) - 1)), left((b), length(b)\
    \ - 1))\n            else \n                if b == \"\" \n                then\
    \ \n                    false \n                else \n                    if\
    \ isupper(b) \n                    then \n                        cycpattern_check(left(b,\
    \ length(b) - 1), b)\n                    else \n                        cycpattern_check(left(b,\
    \ length(b) - 1), left(b, (length(b) - 1)))\n                else \n         \
    \           if isupper(b) \n                    then \n                      \
    \  cycpattern_check(left(b, length(b) - 1), left(b, (length(b) - 1)))\n      \
    \              else \n                        cycpattern_check(left(b, length(b)\
    \ - 1), left(b, length(b) - 1))\n        end\n    end\nend", "    local l1 = len(a)\n\
    \    local l2 = len(b)\n    local n1 = len(\"a\");\n    local n2 = len(\"b\");\n\
    \    local n3 = len(\"ba\");\n    local n4 = len(\"aba\");\n    local n5 = len(\"\
    bba\");\n    local n6 = len(\"bbb\");\n    local n7 = len(\"abc\");\n    local\
    \ n8 = len(\"cba\");\n    local n9 = len(\"cbc\");\n    local n10 = len(\"cbb\"\
    );\n    local n11 = len(\"caa\");\n    local n12 = len(\"cca\");\n    local n13\
    \ = len(\"ccb\");\n    local n14 = len(\"ccc\");\n    local n15 = len(\"daa\"\
    );\n    local n16 = len(\"dab\");\n    local n17 = len(\"dba\");\n    local n18\
    \ = len(\"dbb\");\n    local n19 = len(\"dca\");\n    local n20 = len(\"dcb\"\
    );\n    local n21 = len(\"dca\");\n    local n22 = len(\"dcb\");\n    local n23\
    \ = len(\"dca\");\n    local n24 = len(\"dcb\");\n    local n25 = len(\"ebb\"\
    );\n    local n26 = len(\"eba\");\n    local n27 = len(\"ebc\");\n    local n28\
    \ = len(\"ecc\");\n    local n29 = len(\"eda\");\n    local n30 = len(\"eba\"\
    );\n    local n31 = len(\"eba\");\n    local n32 = len(\"ebb\");\n    local n33\
    \ = len(\"ebc\");\n    local n34 = len(\"ecc\");\n    local n35 = len(\"eda\"\
    );\n    local n36 = len(\"eba\");\n    local n37 = len(\"eba\");\n    local n38\
    \ = len(\"ebb\");\n    local n39 = len(\"ebc\");\n    local n40 = len(\"ecc\"\
    );\n    local n41 = len(\"eda\");\n    local n42 = len(\"eba\");\n    local n43\
    \ = len(\"eba\");\n    local n44 = len(\"ebb\");\n    local n45 = len(\"ebc\"\
    );\n    local n46 = len(\"ecc\");\n    local n47 = len(\"eda\");", "    if length(a)\
    \ == 0 or length(b) == 0 then\n        return true\n    else if length(a) > length(b)\
    \ then\n        a,b = b,a\n    end\n    for i in 0..(length(a)-length(b))-1 do\n\
    \        if (a[i+length(b)] == a[i]) && a[i] != \"-\" then \n            return\
    \ false\n        end\n    end\n    return true\nend\n</code>\n<|/ a |>\n<| a dscore=3\
    \ tags=python,regex |>\nI wrote a function that works the same as regex but with\
    \ some performance improvements.\n<code>\nimport re", "    if a == b\n       \
    \ return true\n    return length(a) < length(b) && length(a) >= length(b) && \n\
    \        length(a) <= length(b) && string(cycle(index(a))) == \n        string(zipWith(rotation,\
    \ a, cycle(index(b))))\nend\n</code>\n<|/ a tags=string,julia |>\n<| c |>\n`length(a)\
    \ <= length(b)` should be `length(a) >= length(b)`.\n<|/ c |>\n<| c |>\nI edited\
    \ the solution to make it more clear what I intended. `length(a) <= length(b)`\
    \ means that the second word must be longer than the first word, and that both\
    \ words have equal or lesser length than the first.\n<|/ c |>\n<| c |>\n`cycle(index(a))`\
    \ doesn't do what you think.\n<|/ c |>\n<| c |>\nHm it's strange. `cycle(index(a))`\
    \ seems to give me the index and then cycle it (so `cycle(index(a))[2]` gives\
    \ me `a`, `cycle(index(a))[1]` gives me `b`, etc.). So I wonder if there's something\
    \ wrong with `cycle(index(a))[2]`\n<|/ c |>\n<| c |>\n`cycle(index(a))[2]` gives\
    \ you `b`, but `cycle(index(a))[1]` gives you `a`. `cycle(a)[2]` is equivalent\
    \ to `cycle(a[2])`.\n<|/ c |>\n<| a tags=string,julia dscore=0 |>\nI wrote a solution\
    \ using your code, the idea is using an additional map to store the reverse of\
    \ original string, and finally checking the number of occurrences in the original\
    \ string and reversed string.\n<code>", "    \n    if b==\"\" \n        return\
    \ true\n    \n    if a==\"\" \n        return false\n    \n    if a.length<b.length\
    \ \n        return false\n    \n    found = false\n    for c in b\n        if\
    \ a.find(c) !=-1 \n            found = true\n            break\n    \n    if found\
    \ \n        return true\n    \n    return false", "    \n    letters = []\n  \
    \  for c in a:\n        if c == 'a' or c == 'e' or c == 'i' or c == 'o' or c ==\
    \ 'u' or c == 'A' or c == 'E' or c == 'I' or c == 'O' or c == 'U'\n          \
    \  letters = [c] + letters\n        elseif c == 'b' or c == 'c' or c == 'd' or\
    \ c == 'f' or c == 'g' or c == 'B' or c == 'C' or c == 'D' or c == 'F' or c ==\
    \ 'G'\n            letters = [c] + letters\n        elseif c == 'h' or c == 'j'\
    \ or c == 'k' or c == 'l' or c == 'm' or c == 'H' or c == 'J' or c == 'K' or c\
    \ == 'L' or c == 'M'\n            letters = [c] + letters\n        elseif c ==\
    \ 'n' or c == 'p' or c == 'q' or c == 'r' or c == 's' or c == 'N' or c == 'P'\
    \ or c == 'Q' or c == 'R' or c == 'S'\n            letters = [c] + letters\n \
    \       elseif c == 't' or c == 'u' or c == 'v' or c == 'w' or c == 'x' or c ==\
    \ 'T' or c == 'U' or c == 'V' or c == 'W' or c == 'X'\n            letters = [c]\
    \ + letters\n        elseif c == 'z' or c == 'a' or c == 'b' or c == 'c' or c\
    \ == 'd' or c == 'f' or c == 'g' or c == 'H' or c == 'J' or c == 'K' or c == 'L'\
    \ or c == 'M' or c == 'N' or c == 'P' or c == 'Q' or c == 'R' or c == 'S' or c\
    \ == 'T' or c == 'U' or c == 'V' or c == 'W' or c == 'X' or c == 'Y' or c == 'Z'\n\
    \            letters = [c] + letters\n        else\n            letters = [c]\
    \ + letters\n    for c in b:\n        if c == 'a' or c == 'e' or c == 'i' or c\
    \ == 'o' or c == 'u' or c == 'A' or c == 'E' or c == 'I' or c == 'O' or c == 'U'\n\
    \            letters = [c] + letters\n        elseif c == 'b' or c == 'c' or c\
    \ == 'd' or c == 'f' or c == 'g' or c == 'B' or c == 'C' or c == 'D' or c == 'F'\
    \ or c == 'G'\n            letters = [c] + letters\n        elseif c == 'h' or\
    \ c == 'j' or c == 'k' or c == 'l' or c == 'm' or c == 'H' or c == 'J' or c ==\
    \ 'K' or c", "    if a contains b or b in a\n    then true\n    else false\nend\n\
    </code>\n<|/ a |>\n<| c |>\nIf your algorithm is based on string search, it is\
    \ O(n^2) because you are comparing each substring against every other. Although\
    \ my algorithm is based on word search (no matter what order the words are in),\
    \ it is still O(n).\n<|/ c |>\n<| c |>\nThis has O(n^2) complexity because you\
    \ are iterating through each string once to find the first index and then again\
    \ to find the first substring of the second word. Since you are iterating through\
    \ every character, it does this n times.\n<|/ c |>\n<| c |>\nThe complexity of\
    \ your algorithm is O(n^2). Your algorithm is also incorrect. It will find \"\
    himenss\" as \"simen\".\n<|/ c |>\n<| c |>\nIt was an example i gave for him to\
    \ see how it worked i guess i should have just copied it but i guess i didnt need\
    \ to since he was new to this\n<|/ c |>\n<| c |>\nI edited my post to fix the\
    \ code example and add the other algorithm, I hope this helps you understand it.\n\
    <|/ c |>\n<| a |>\nHere is a naive solution using regex :\n<code>", "    \n  \
    \  a = a ++ a\n    b = b ++ b\n    \n    return b in a\nend", "  if length(b)\
    \ < length(a) && length(b) >= 3 && length(a) >= 3 \n  then \n    if a[0...length(b)]\
    \ == b\n    then\n      return true\n    else\n      return false\n    else\n\
    \      return false\n    else\n      return false\n    else\n      return false\n\
    \    else\n      return false\n    else\n      return false\n    else\n      return\
    \ false\n    else\n      return false\n    else\n      return false\n    else\n\
    \      return false\n    else\n      return false\n    else\n      return false\n\
    \    else\n      return false\n    else\n      return false\n    else\n      return\
    \ false\n    else\n      return false\n    else\n      return false\n    else\n\
    \      return false\n    else\n      return false\n    else\n      return false\n\
    \    else\n      return false\n    else\n      return false\n    else\n      return\
    \ false\n    else\n      return false\n    else\n      return false\n    else\n\
    \      return false\n    else\n      return false\n    else\n      return false\n\
    \    else\n      return false\n    else\n      return false\n    else\n      return\
    \ false\n    else\n      return false\n    else\n      return false\n    else\n\
    \      return false\n    else\n      return false\n    else\n      return false\n\
    \    else\n      return false\n    else\n      return false\n    else\n      return\
    \ false\n    else\n      return false\n    else\n      return false\n    else\n\
    \      return false\n    else\n      return false\n    else\n      return false\n\
    \    else\n      return false\n    else\n      return false\n    else\n      return\
    \ false\n    else\n      return false\n    else\n      return false\n    else\n\
    \      return false\n    else\n      return false\n    else\n      return false\n\
    \    else\n      return false\n    else\n      return false\n    else\n      return\
    \ false\n    else\n      return false\n    else\n      return false\n    else\n\
    \      return false\n    else\n      return false\n    else\n      return false\n\
    \    else\n      return false\n    else\n      return false\n    else\n      return\
    \ false\n    else\n      return false\n    else\n      return false\n    else\n\
    \      return false\n    else\n      return false\n    else\n      return false\n\
    \    else\n      return false\n    else\n      return false\n    else\n      return\
    \ false\n    else\n      return false\n    else\n      return false\n    else\n\
    \      return false\n    else\n      return false\n    else\n      return false\n\
    \    else\n      return false\n    else\n      return false\n    else\n      return\
    \ false\n    else\n      return false\n    else\n      return false\n    else\n\
    \      return false\n    else\n      return false\n    else\n      return false\n\
    \    else\n      return false\n    else\n      return false\n    else\n      return\
    \ false\n    else\n      return false\n    else\n      return false\n    else\n\
    \      return false\n    else\n      return false\n    else\n      return false\n\
    \    else\n      return false\n    else\n      return false\n    else\n      return\
    \ false\n    else", "    #TODO: write your code here\n    \n    \n    return true\n\
    end\n</cell>\n<text>\nWrite a function that will return a string formed by concatenating\
    \ the inputted strings\nThis function will accept as input two strings and return\
    \ a third string that contains all of the concatenated strings from the input\
    \ strings", "    if isascii(a) and isascii(b) then \n        return true\n   \
    \ elseif isascii(a) and isascii(b) == false then \n        return false\n    elseif\
    \ isascii(a) == false and isascii(b) == false then \n        return true\n   \
    \ elseif isascii(a) == false and isascii(b) == true then \n        return false\n\
    \    elseif isascii(a) == true and isascii(b) == false then \n        return false\n\
    \    elseif isascii(a) == true and isascii(b) == true then \n        return true\n\
    \    else\n        return false\n    end", "    return b.startswith(prefix(a))\
    \ or (cycpattern_check(a[1:], b) or cycpattern_check(a[1:], b))\nend", "  result\
    \ = False\n  if length(a) < length(b) \n    then return false\n  else\n    loop_index\
    \ = 0 \n    string_len = 0 \n    while loop_index < length(a) do \n      string_len\
    \ = string_len + 1 \n      loop_index = loop_index + 1 \n      \n      loop_end\
    \ = loop_index + string_len - 1 \n      \n      \n      if loop_index == loop_end\
    \ \n        then return true\n      else\n        if a[(loop_index - 1):loop_index]\
    \ == b[string_len:(string_len+1)] \n          then return true\n        else return\
    \ false\n      \n    end\n  end\nend\n</cell>\n<code language=julia-1.0>\ncycpattern_check(\"\
    abcd\", \"abd\")\n</cell>\n<text>\n12. Finding all substring in a string", " \
    \   local pattern = a:gsub(\"$\", \"*$\"):gsub(\"[^%s]\", \"\"):gsub(\"*$\", \"\
    $\")\n    return (b:match(pattern) ~= nil & \n            (b:gsub(\"[^%s]\", \"\
    \"):gsub(\"*$\", \"$\"):gsub(\"$\", \"*$\")) ~= nil)\nend", "    return a==b||(b.starts_with(a)\
    \ && b.ends_with(a))\nend\n</cell>\n<cell>\n@test cycpattern_check(\"abcd\", \"\
    abd\")\n</cell>\n<cell>\n@test cycpattern_check(\"hello\", \"ell\")\n</cell>\n\
    <cell>\n@test cycpattern_check(\"whassup\", \"psus\")\n</cell>\n<cell>\n@test\
    \ cycpattern_check(\"abab\", \"baa\")\n</cell>\n<cell>\n@test cycpattern_check(\"\
    efef\", \"eeff\")\n</cell>\n<cell>\n@test cycpattern_check(\"himenss\", \"simen\"\
    )\n</cell>\n<text>\nCyclic Patterns\nNow let's work on pattern matching...", " \
    \   \n    if isin(a) \n        return isin(b) \n    \n    \n    if isin(b)\n \
    \       return isin(a)", "    \n    \n    a1 = word(a)\n    \n    \n    a2 = word(b)\n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n",
  "    return (length(a) >= length(b) && a.substring(length(a) - length(b), length(a))\
    \ in b)\nend \n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nHere is some code\
    \ from my own attempt at solving this problem. I'm just posting this as an alternative\
    \ to the accepted answer.\n<code>\nlet cycpattern_check (a::String, b::String)::Bool\
    \ = \n    if length(a) < (length(b) - length(a))\n    then false\n    else if\
    \ b.substring((length(a) - length(b)), length(b)) in a\n    then true\n    else\
    \ false\n</code>\n<|/ a tags=string,substring,pattern-matching,haskell |>\n<|\
    \ c |>\n`if length(a) < (length(b) - length(a))` is just a little more efficient\
    \ as `length(a) <= length(b - a)`.\n<|/ c |>\n<| c |>\nThanks for your comment\
    \ (I'm still pretty new at Haskell), I updated the answer with your suggestion.\n\
    <|/ c |>\n<| a tags=string,substring,pattern-matching,haskell |>\nMy first attempt\
    \ is using findIndices to find indexes of all occurrences of pattern inside string.\n\
    <code>\nimport Data.List\ncycpattern_check :: String -> String -> Bool\ncycpattern_check\
    \ str pattern = findIndices (==pattern) str == []\n</code>\nbut then I thought\
    \ about using split. \n<code>\ncycpattern_check :: String -> String -> Bool\n\
    cycpattern_check str pattern = length str <= length pattern || pattern `elem`\
    \ str.split\n</code>\nbut then I realized that I don't need pattern to take advantage\
    \ of the \"split\" method, so I wrote another solution:\n<code>\ncycpattern_check\
    \ :: String -> String -> Bool\ncycpattern_check str pattern = length str <= length\
    \ pattern\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nI made a solution using\
    \ recursion to find the length of the longest substring of a string that matches\
    \ the pattern and to check if the pattern is contained in the string. \n<code>\n\
    cycpattern_check :: String -> String -> Bool\ncycpattern_check pattern string\n\
    \    | length string <= length pattern = length string == length pattern\n   \
    \ | otherwise = False \n    | otherwise = if cycpattern_check (pattern (length\
    \ string - length pattern)) string\n                    then True \n         \
    \           else False\n</code>\n<|/ a tags=string,substring,pattern-matching,haskell\
    \ |>\n<|", "    if length(a) == 0 or length(b) == 0 then \n        true\n    else\n\
    \        if contains(b,a) then \n            true\n        else\n            false\n\
    \        end\n    end\nend\n</code>\n<|/ a |>\n<| a tags=string,julia |>\nIn Julia\
    \ 1.2, this was easy:\n<code>", "    len = length(a) \n    for i in 0 .. len-1\
    \ do\n        if b[(i+1):len] == substring(a,i,len) || substring(b,i,len) == substring(a,i,len)\
    \ \n        then return true \n        else return false\n    end\nend\n</cell>\n\
    <text>\nCycle Pattern", "    if length(b) == 0 \n        true\n    else if length(a)\
    \ == 0 \n        false\n    else if strfind(a, b) == 0\n        true\n    else\
    \ if strfind(b, a) == 0\n        true\n    else if strfind(a, a) == 0\n      \
    \  true\n    else \n        cycpattern_check(a[1:end-1], b[1:end-1]) || cycpattern_check(a[1:end-1],\
    \ b)\nend", "    if a==b return true\n    match a, b with\n    | a::b::tail, \"\
    \"::tail => true\n    | a::tail, b::tail => cycpattern_check(a, b) || cycpattern_check(b,\
    \ a)\n    | _, _ => false\nend\n</cell>\n<text>\nProblem 3\nGiven a list of integers,\
    \ you are required to find the largest prime factor of each number.", "    local\
    \ function findRotation(word::String, pattern::String)\n        return if pattern\
    \ == word then 0 else pattern:gsub(pattern, \"$0\" .. word):findprefix(pattern)\n\
    \    end\n    return (findRotation(a, b) == -1 || findRotation(a, b) == -2)\n\
    end\n</code>\n<|/ a tags=algorithm,string,pattern-matching,ruby,string |>\n<|\
    \ c |>\nThis has O(n^3) performance (for large strings). O(n^2) would be possible\
    \ with KMP but it's too complicated\n<|/ c |>\n<| c |>\nAh sorry I misread the\
    \ question. I'm pretty sure a ruby implementation would take O(n^2) in total due\
    \ to the `gsub` and the `findprefix`. I haven't looked at it recently though.\
    \ Still though, this algorithm has the advantage of not requiring any preprocessing\
    \ of the pattern string.\n<|/ c |>\n<| c |>\n`gsub` actually has O(n^2) performance.\
    \ `findprefix` is O(n), but the worst case is actually O(n^2), as `findprefix`\
    \ has to loop over the string a bunch of times to find the first character that\
    \ matches and then just check that the pattern matches the rest of the string.\
    \ `gsub` is only going to be called once in the worst case, thus it will be O(n).\n\
    <|/ c |>\n<| c |>\nYeah I realised that after writing it. I didn't look at the\
    \ benchmark results before I posted this. But I just tested it and it does indeed\
    \ seem to be O(n^2). I don't know why I was so obsessed with making it O(n^3).\n\
    <|/ c |>\n<| c |>\nI've also just realised that the performance isn't really O(n^2).\
    \ I think it's O(nm) where m is the length of the pattern string.\n<|/ c |>\n\
    <| a dscore=2 |>\nI would do it like this: ", "    if a==b\n        true\n   \
    \ elseif a==\"\"\n        false\n    elseif b==\"\"\n        false\n    elseif\
    \ contains(b, a, true)\n        true\n    elseif contains(b, a, false)\n     \
    \   false\n    else\n        contains(a, b, true) || contains(b, a, false)\nend",
  "    if b==[] return true\n    if b[1]==\"\" \n        if a==b[1] \n           \
    \ return true \n        else \n            return false \n    end\n    if b[1]!=\"\
    \" && b[1] in a\n        begin \n            return true \n        end\n    end\n\
    \    for i in b[2:end]\n        if i in a\n            begin \n              \
    \  return true \n            end\n        end\n    end\n    return false\nend",
  "    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n", "        \n    a_words\
    \ = split(a, \" \")\n    b_words = split(b, \" \")\n    \n    lengths = map(cycpattern_check_helper,\
    \ a_words, b_words)\n    \n    return lengths.sum > 0\nend", "    a_char::Char\
    \ = Char(a[0])\n    b_char::Char = Char(b[0])\n    if length(a) <= length(b) &&\
    \ a_char == b_char\n        true\n    else\n        if length(a) == length(b)\n\
    \            false\n        else\n            a_rot::String = rotate_char(a::String,\
    \ a_char)\n            b_rot::String = rotate_char(b::String, b_char)\n      \
    \      if a_char in a_rot || b_char in b_rot\n                true\n         \
    \   else\n                cycpattern_check(a::String, b_rot)\n        end\n  \
    \  end\nend", "    \n    \n    if isin(a,b) == true\n        return true\n   \
    \ elseif isin(b,a) == true\n        return true\n    elseif isin(a,b) == false\
    \ && isin(b,a) == false\n        return true\n    else\n        return false\n\
    \    end\n    \nend\n\"\"\"\n    \n    \n\"\"\"\n# Cycle patterns\n# Cycle Patterns\n\
    \"\"\"", "    \n    \n    if length(a) == 0 || length(b) == 0 || a == b\n    \
    \    return true\n    \n    \n    \n    begin1 = a.findFirst(\" \")\n    begin2\
    \ = b.findFirst(\" \")\n    \n    if begin1 == -1 || begin2 == -1 || begin2 >\
    \ begin1\n        return false\n    \n    \n    \n    len1 = begin1 + 1\n    len2\
    \ = begin2 + 1\n    \n    if len1 == len2\n        return true\n    \n    \n \
    \   \n    if len2 < len1\n        len1, len2 = len2, len1\n    \n    \n    \n\
    \    if a[len1] == \"\"\n        return true\n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    if len1 == len2\n        if a[len1] == b[len2]\n\
    \            return true\n        else\n            return false\n    else\n \
    \       \n        if a[len1] == \"\"\n            return true\n        else\n\
    \            return false\n    \n    \n    \nend\n</cell>\n<code language=julia-1.5>\n\
    # Test your code\n\"\"\"\nRun with this command:\n```julia\njulia> include(\"\
    test.jl\"); run()\n```\n\"\"\"\n</cell>\n<text>\n5. SPOT", "    if a == \"a\"\
    \ or b == \"a\" \n        then true\n    elseif a.startswith(b) \n        then\
    \ true\n    else\n        false\n    end \nend", "    if a == \"\" or b == \"\"\
    \n        return false\n    elseif substr_count(a, b) == 0\n        return true\n\
    \    else\n        first::String = a\n        second::String = b\n        first::Int\
    \ = 0\n        second::Int = 0\n        first::Int = substr_count(a, first)\n\
    \        second::Int = substr_count(b, second)\n        if first < second\n  \
    \          if first > second\n                second = first - second\n      \
    \          first = second\n            else\n                first = first - second\n\
    \                second = first + second\n                first = second\n   \
    \     elseif first > second\n            first = second - first\n            second\
    \ = first + second\n            first = second\n        third::Int = substr_count(a,\
    \ second)\n        fourth::Int = substr_count(b, first)\n        if third > fourth\n\
    \            third = fourth - third\n            fourth = third\n        else\n\
    \            third = fourth - third\n            fourth = third\n        if third\
    \ < fourth\n            if third > fourth\n                fourth = third\n  \
    \              third = fourth\n            else\n                third = fourth\
    \ - third\n                fourth = third\n                third = fourth\n  \
    \      end\n        if third < fourth\n            if third > fourth\n       \
    \         fourth = third\n                third = fourth\n            else\n \
    \               third = fourth - third\n                fourth = third\n     \
    \           third = fourth\n            end\n        end\n        if fourth ==\
    \ 0\n            fourth = third\n            third = fourth\n        end\n   \
    \     if third < fourth\n            if third > fourth\n                fourth\
    \ = third\n                third = fourth\n            else\n                third\
    \ = fourth - third\n                fourth = third\n                third = fourth\n\
    \            end\n        end\n        if third < fourth\n            if third\
    \ > fourth\n                fourth = third\n                third = fourth\n \
    \           else\n                third = fourth - third\n                fourth\
    \ = third\n                third = fourth\n            end\n        end\n    \
    \    if fourth == 0\n            fourth = third\n            third = fourth\n\
    \        end\n        if third < fourth\n            if third > fourth\n     \
    \           fourth = third\n                third = fourth\n            else\n\
    \                third = fourth - third\n                fourth = third\n    \
    \            third = fourth\n            end\n        end\n", "    begin::Int64\
    \ = 1\n    length::Int64 = a.length\n    repeat::Int64 = length\n    while repeat\
    \ > 0\n        if a[begin] == b[begin]\n            begin = begin + 1\n      \
    \  elseif a[begin] == b[repeat]\n            repeat = repeat - 1\n        else\n\
    \            return false\n        end\n    return true\nend\n</code>\nend\n<|/\
    \ a tags=string,julia,recursion dscore=1 |>\n<| a |>\nThe code using recursion\
    \ for checking the pattern is given below\n<code>", "    \n    mutable bool flag\
    \ = false", "    return cycpattern_check_helper(a, b, \"\")\nend ", "    | a contains\
    \ b || b contains a  = true\n    | otherwise            = false\nend \n</code>\n\
    <|/ a |>\n<| c |>\nThank you very much for the answer. I was able to write this\
    \ in Python. \nI used the code you provided and it works perfectly!\n<|/ c |>\n\
    <| a dscore=1 |>\nHere is a solution in Julia 1.0\n<code>", "    if length(a)\
    \ != length(b) then return false \n    for i in 0..(length(a) - 1) do \n     \
    \   if (a[i] == a[i+1]) then return false \n    end \n    return true \nend ",
  "    \n    local word = split(a) \n    local word2 = split(b) \n  \n    for i =\
    \ 1, length(word) do \n        for j = 1, length(word2) do \n            if word[i]\
    \ == word2[j] then \n                return true \n            end \n        end\
    \ \n    end \n    return false\nend \n</code>\n<|/ a dscore=2 |>\n<| c |>\n`for\
    \ i = 1, length(word) do \n        for j = 1, length(word2) do \n            if\
    \ word[i] == word2[j] then \n                return true \n            end \n\
    \        end \n    end \n    return false\nend `\n<|/ c |>\n<| a |>\n<code>",
  '    return cycpattern_check_impl(a::String, b::String, "", "", "", "", "")', " \
    \   return false if length(a) == 0 || length(b) == 0 || length(a) == length(b)\
    \ else (a !! length(b) && b !! length(a) && b!! length(a) == a !! length(b))\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work for \"abcde\" and\
    \ \"abadec\", for example, for which the substring \"aba\" is in both strings.\n\
    <|/ c |>\n<| c |>\nNot the best, but a good answer. I would have upvoted this\
    \ answer if I had a 15 reputation. :-)\n<|/ c |>\n<| c |>\nThe cycpattern_check()\
    \ function (which uses `==` instead of `in`) works for the two cases you mentioned.\
    \ The first is \"abcde\" and the second is \"abadec\". It returns false.\n<|/\
    \ c |>\n<| c |>\nYou are right, I apologize for this. It would work for the OP's\
    \ example, but fail for \"abadec\" and \"abadecxyz\", for example.\n<|/ c |>\n\
    <| a dscore=1 |>\nYou can do this in O(n log n) time by using suffix tree data\
    \ structure. First sort the string in lexicographical order and then insert the\
    \ characters in the tree one by one. For example inserting 'h' in a suffix tree\
    \ will give 'h' as an answer.\nThe complexity is O(n*log(n)).\n<|/ a tags=string,language-agnostic,algorithm\
    \ |>\n<| a tags=string,language-agnostic,algorithm |>\nThis is a fairly straightforward\
    \ approach:", "        len::Int64 = length(b); \n        if len==0 then return\
    \ true else return false \n        \n        res::Bool = false;\n        if a==b\
    \ then return true\n        \n        for i in range(len) do\n        \n     \
    \       if isalpha(a[i]) && isalpha(b[i]) then \n                \n          \
    \      res::Bool = isalpha(a[i])==isalpha(b[i]) \n            \n            else\
    \ \n                res::Bool = false \n            \n            end\n      \
    \  \n        end \n        return res \nend", "    if length(word(a)) == length(b)\
    \ && length(a) == length(b) && length(a) == length(b) || length(a) == length(b)\
    \ && length(a) == length(b) && length(a) == length(b) \n        then \n      \
    \      if b == subword(word(a), word(length(a))) || b == subword(word(a), word(length(a)))\
    \ || b == subword(word(a), word(length(a))) \n                then \n        \
    \            if subword(word(a), word(length(a))) == subword(word(b), word(length(b)))\
    \ \n                        then true \n                        else false \n\
    \            else if b == subword(word(a), word(length(a))) || b == subword(word(a),\
    \ word(length(a))) || b == subword(word(a), word(length(a))) \n              \
    \  then \n                    if subword(word(a), word(length(a))) == subword(word(b),\
    \ word(length(b))) \n                        then true \n                    \
    \    else false \n            else if b == subword(word(a), word(length(a))) ||\
    \ b == subword(word(a), word(length(a))) || b == subword(word(a), word(length(a)))\
    \ \n                then \n                    if subword(word(a), word(length(a)))\
    \ == subword(word(b), word(length(b))) \n                        then true \n\
    \                        else false \n            else \n                false\
    \ \n        else \n            false \n    else \n        false \nend\n</code>\n\
    <|/ a tags=string,julia,regex |>\n<| a tags=string,julia,regex |>\nBased on A.\
    \ Donda's answer, I wrote a function:\n<code>", "    # a is first word\n    #\
    \ b is second word\n    #\n    \n    a_len = length(a)\n    b_len = length(b)\n\
    \    # return true if the second word or any of its rotations is a substring in\
    \ the first word\n    \n    return b_len > a_len or a_len == 0 || (b_len > a_len\
    \ and b_len < a_len and b[b_len] == a[a_len])", "    return length(intersect(splitAt(a,\
    \ 1, true, \"\"), splitAt(b, 2, true, \"\"), true)) > 0\nend", "  a = lowercase(a)\n\
    \  b = lowercase(b)\n  d = Array{Char,1}()\n  for i in eachindex(a)\n    push!(d,a[i])\n\
    \  end\n  for j in eachindex(b)\n    push!(d,b[j])\n  end\n  return false in d\
    \ && any(x in d for x in b)\nend\n</code>\n<|/ a tags=cyclomatic-complexity,julia,string\
    \ |>\n<| c |>\nThank you for this. But what I'm looking for is a solution that\
    \ can give me a high cyclomatic complexity (a lower than your function).\n<|/\
    \ c |>\n<| c |>\nI believe my function can be improved further (it still has some\
    \ inefficiencies, but at least is more concise)\n<|/ c |>\n<| a dscore=1 tags=cyclomatic-complexity,julia,string\
    \ |>\n<code>\niscycpattern_check2(word1,word2) = any(isin(word2,x) for x in words)\n\
    </code>\niscycpattern_check2 is the same as iscycpattern_check1 but instead of\
    \ counting letters, it's counting word lengths.\nisin is vectorized and is very\
    \ fast\n<|/ a |>\n<| a dscore=0 |>\nThis should be the fastest solution:\n<code>",
  "    a::Char    \n    b::Char    \n    if length(a) == 0 && length(b) == 0\n   \
    \     return true\n    elseif length(a) == 0 && length(b) > 0 \n        return\
    \ false\n    elseif length(a) > 0 && length(b) == 0 \n        return true\n  \
    \  elseif length(a) > 0 && length(b) > 0 \n        if (a[end] in b) || b[end]\
    \ in a\n            return true\n        else\n            return false\n    end\n\
    end", "  a1 = split_a(a)\n  b1 = split_b(b)\n  for x::String in a1 do \n    remove_cyc(x::String)\n\
    \  end\n  for x::String in b1 do \n    remove_cyc(x::String)\n  end\n  for x::String\
    \ in a1 do \n    for y::String in b1 do \n      if x == y then remove_cyc(x::String)\n\
    \      end\n    end\n  end\n  true\nend\n</code>\n<|/ a tags=string,pattern-matching,julia,arrays\
    \ |>\n<| c |>\nI'm very new to Julia, would you mind explaining the code? Specifically\
    \ what are you doing with the function call? What do the double colons mean?\n\
    <|/ c |>\n<| c |>\nI added some explanation to the answer. Hope it helps.\n<|/\
    \ c |>\n<| a dscore=0 |>\nI have also been trying to find a solution to this problem\
    \ and stumbled across the following problem as I was trying to solve a similar\
    \ problem. Although this solution is a bit ugly, I think it is at least a little\
    \ bit more efficient than my original solution. It also uses more \"Julia\" syntax.\
    \ I haven't tested this on very large strings, but it seems to work for small\
    \ strings and in many cases.\n<code>", "    match(a,b) || cycpattern_check(a[end-1],b)\
    \ || cycpattern_check(a[1:end-1],b) \nend", "    matches=false\n    for c in a\n\
    \        if c ~= 'e' \n            matches=c=='e'\n        if matches\n      \
    \      matches=matches or cycpattern_check(b, a.drop(c))\n        end \n    end\n\
    \    return matches\nend ", "    if length(a) > length(b)\n        false\n   \
    \ else\n        for i in (0..(length(a)-1))\n            if a[i] == b[i]\n   \
    \             true\n            else\n                if a[i] < b[i]\n       \
    \             false\n                else\n                    if a[i]>b[i]\n\
    \                        false\n                    else\n                   \
    \     if b[i]=='.'\n                            true\n                       \
    \ else\n                            false\n    end \nend \nend \n</cell>\n<code\
    \ language=julia-1.0>\n@time begin\n    pattern_check(\"abcd\", \"abd\")\n   \
    \ pattern_check(\"hello\", \"ell\")\n    pattern_check(\"whassup\", \"psus\")\n\
    \    pattern_check(\"abab\", \"baa\")\n    pattern_check(\"efef\", \"eeff\")\n\
    \    pattern_check(\"himenss\", \"simen\")\nend\n</cell>\n<text>\nString Functions",
  "    # check if b is a substring of a\n    if b == \"\" || a == \"\"\n        return\
    \ true\n    else\n        # find all rotations of a and b\n        b_rot_list\
    \ = string_rotations(b)\n        a_rot_list = string_rotations(a)\n        # for\
    \ each rotation of b\n        for b_rot_str in b_rot_list\n            # check\
    \ if the rotation of b exists in a\n            for a_rot_str in a_rot_list\n\
    \                # if so, return true\n                if b_rot_str in a_rot_str\n\
    \                    return true\n            # if not found, return false\n \
    \           return false\n            # if we haven't returned yet, return false\
    \ (not found)\n    return false", "    if length(a) > length(b)\n    return true\n\
    \    else if length(a) < length(b)\n        return false\n    else if length(a)\
    \ == length(b) \n        for i in each(a)\n            for j in each(b)\n    \
    \            if i == j\n                    return true\n                else\n\
    \                    return false\n    end\n</code>\n<|/ a dscore=0 |>\n<| a |>\n\
    <code>\na = \"abc\"\nb = \"adf\"", "\"\"\"\nCyclopseudo pattern checker for the\
    \ general case.\n\"\"\"\n  \n    if a.length>0 && b.length>0 && a==b \n    return\
    \ true \n    \n    else \n    return false \n    \nend \n</code>\n<|/ a dscore=3\
    \ tags=string,julia,pattern-matching |>\n<| c |>\n`@timeit(repeat(x->cycpattern_check(\"\
    abd\", \"abcd\"), 10000))` returns `0.556 seconds (9.439 k allocations: 2.610\
    \ GB, 11.39 MB total)`, so it performs slightly faster than `@timeit(repeat(x->cycpattern_check(\"\
    abcd\", \"abd\"), 10000))` which returns `0.122 seconds (13.66 k allocations:\
    \ 1.244 GB, 12.22 MB total)`. I'm guessing this is because `@timeit` allocates\
    \ memory for all the timing output. This makes the timings slightly more consistent\
    \ and useful.\n<|/ c |>\n<| a |>\nJust in case... a little bit of benchmark shows\
    \ that this approach is indeed faster\n<code>", "    \"\"\"\n    Your cycpattern_check\
    \ function should return true or false depending if b is a substring of a\n  \
    \  >>> cycpattern_check(\"abcd\", \"abd\")\n    false\n    >>> cycpattern_check(\"\
    hello\", \"ell\")\n    true\n    >>> cycpattern_check(\"whassup\", \"psus\")\n\
    \    false\n    >>> cycpattern_check(\"abab\", \"baa\")\n    true\n    >>> cycpattern_check(\"\
    efef\", \"eeff\")\n    false\n    >>> cycpattern_check(\"himenss\", \"simen\"\
    )\n    true", "    len_a = length(a)\n    len_b = length(b)\n    if len_a < len_b\
    \ then return false\n    if len_a == len_b then return true if b[1:len_a] == a[1:len_a]\
    \ else false\n    if a[1:len_a] == b[1:len_a] then \n        if len_a <= 2 then\
    \ return true\n        for i=2:len_a do if a[1:i] == b[1:i] then return true end\
    \ \n    else false\n    end \nend ", "    \n    \n    \n    return contains(a,\
    \ b)\n    \nend\n</code>\nThe first function contains is used to check if the\
    \ strings contain the second string. As you can see in this code, there are two\
    \ nested loops nested inside each other. One of them is iterating over all the\
    \ characters of the string and the other is iterating over all the substrings\
    \ of it. This is a slow way of doing it. You should use some functions to make\
    \ it faster.\nThe second function contains is the same as the one from the first\
    \ code block, except that the string is not reversed before searching it. If you\
    \ are not familiar with functions, the function contains is used to check if a\
    \ string contains a substring. There are two types of functions you can use to\
    \ make this code faster.\n<|/ a |>\n<| c |>\nThank you so much for this. I understand\
    \ a bit more now on how you wrote it!\n<|/ c |>\n<| a tags=string,arrays,loops,julia,function\
    \ |>\nA solution that is slightly different to others proposed but is also more\
    \ efficient. Since this does not require any external libraries, it may be more\
    \ efficient to run a benchmark on various sizes strings. \n<code>", "    if a==\"\
    \" || b==\"\"\n       return true\n    else if any(b in w for w in combinations(a,2))\n\
    \       return true\n    else\n       return false\n</code>\n<|/ a dscore=0 |>\n\
    <| a tags=string,pattern-matching,r dscore=0 |>\nThis answer works in R\n<code>\n\
    cycpattern_check<-function(pattern,text){", "    word=b\n    for i in a:\n   \
    \     for j in word:\n            if i==j:\n                return True\n    return\
    \ False\n</code>\n<|/ a tags=string,pattern-matching,string,algorithm,python dscore=0\
    \ |>\n<| a dscore=0 |>\nA solution with regex is very nice, but it's easy to do\
    \ with str.isalpha:\n<code>\ndef cycpattern_check(str1, str2):\n    # Return True\
    \ if str2 is a sub-string of str1\n    return any(str1.isalpha() and str2.startswith(s)\
    \ for s in str1)\n</code>\n<|/ a tags=string,pattern-matching,string,algorithm,python\
    \ |>\n<| a |>\n<code>\ndef cycpattern_check(a, b):\n    if a in b:\n        return\
    \ True\n    else:\n        first = b.split()\n        words = [word for word in\
    \ first if word.startswith(a)]\n        if words:\n            return True\n \
    \       else:\n            return False\n</code>\n<|/ a tags=string,pattern-matching,string,algorithm,python\
    \ dscore=0 |>\n<| a dscore=0 |>\n<code>\ndef cycpattern_check(a, b):\n    if a\
    \ in b:\n        return True\n    else:\n        first = b.split()\n        for\
    \ word in first:\n            if word == a:\n                return True\n</code>\n\
    <|/ a tags=string,pattern-matching,string,algorithm,python |>\n<| c |>\nIf someone\
    \ wants to copy paste this code, the above code does not work for cases like \"\
    aaaa\" and \"aabbba\".\n<|/ c |>\n<| c |>\nYou are not checking if the string\
    \ contains another string but if you match the whole string with that given string.\n\
    <|/ c |>\n<| a tags=string,pattern-matching,string,algorithm,python |>\nFor this\
    \ problem, a regular expression is a great tool to solve this. It is not very\
    \ hard to see that you are trying to match a pattern with its first letter as\
    \ your first letter, with any of the remaining letters being letters of the string\
    \ that follow the first letter. One way to solve this with a regular expression\
    \ is to simply substitute the first letter with itself repeated twice and capture\
    \ the remaining letters with parentheses around them, which we can easily reference\
    \ in the replacement with \\1:\n<code>\n>>> import re\n>>> def cycpattern_check(a,\
    \ b):\n...     return re.match('([a-z])(\\1)', a).group(1) == b\n... \n>>> cycpattern_check(\"\
    abcd\", \"abd\")\nTrue\n>>> cycpattern_check(\"abcd\", \"bac\")\nFalse\n>>> cycpattern_check(\"\
    hello\", \"ell\")\nTrue\n>>> cycpattern_check(\"whassup\", \"psus\")\nFalse\n\
    >>> cycpattern_check(\"abab\", \"baa\")\nTrue\n>>> ", "    pattern = a:sub(pattern)\n\
    \    pattern = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n    pattern\
    \ = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n\
    \    pattern = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n    pattern\
    \ = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n\
    \    pattern = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n    pattern\
    \ = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n\
    \    pattern = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n    pattern\
    \ = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n\
    \    pattern = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n    pattern\
    \ = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n\
    \    pattern = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n    pattern\
    \ = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n\
    \    pattern = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n    pattern\
    \ = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n\
    \    pattern = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n    pattern\
    \ = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n\
    \    pattern = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n    pattern\
    \ = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n\
    \    pattern = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n    pattern\
    \ = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n\
    \    pattern = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n    pattern\
    \ = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n    pattern = pattern:sub(pattern)\n\
    \    pattern = pattern:sub(pattern)\n", "    if length(a) >= length(b) && a[length(a)\
    \ - length(b) + 1 .. end] \u2229 b \u2260 \"\"\n    then true\n    else false\n\
    \    end\nend\n</cell>\n<code language=julia-1.0>", "    \n    first, rest = split_first_rest(a)\n\
    \    second, rest2 = split_first_rest(b)\n    \n    found = true\n    for i in\
    \ first:\n        found = false\n        for j in second:\n            if i ==\
    \ j:\n                found = true\n                break\n        if found ==\
    \ false:\n            break\n    \n    if found:\n        return true\n    else:\n\
    \        for i in first:\n            found = false\n            for j in first:\n\
    \                if i == j:\n                    found = true\n              \
    \      break\n            if found == false:\n                break\n        if\
    \ found:\n            return true\n        else:\n            for i in first:\n\
    \                found = false\n                for j in second:\n           \
    \         if i == j:\n                        found = true\n                 \
    \       break\n                if found == false:\n                    break\n\
    \            if found:\n                return true\n            else:\n     \
    \           for i in second:\n                    found = false\n            \
    \        for j in second:\n                        if i == j:\n              \
    \              found = true\n                            break\n             \
    \       if found == false:\n                        break\n                if\
    \ found:\n                    return true\n                else:\n           \
    \         for i in second:\n                        found = false\n          \
    \              for j in first:\n                            if i == j:\n     \
    \                           found = true\n                                break\n\
    \                        if found == false:\n                            break\n\
    \                    if found:\n                        return true\n        \
    \            else:\n                        return false\nend\n</code>\nThis function\
    \ is very slow, any ideas of how to speed it up? Thanks\n<|/ q |>\n<| a dscore=2\
    \ tags=recursion,julia,time-complexity,algorithm |>\nFor any given string a, your\
    \ function cycpattern_check is essentially a lookup table. Let's look at what\
    \ that looks like:\n<code>\njulia> cycpattern_check(\"abcd\", \"abd\")\ntrue",
  "    if a == \"\" || b == \"\"\n    then return false\n    else if length(a) > length(b)\n\
    \    then return false\n    else if substring(b, length(b) - length(a)) in a\n\
    \    then return true\n    else return cycpattern_check(substring(b, length(b)),\
    \ a)\n    end\nend", "  if length(a) == 0 then return false \n  if length(b) ==\
    \ 0 then return false \n  if length(a) == 0 then return false \n  if length(b)\
    \ == 0 then return false \n  if length(a) == 0 then return false \n  if length(b)\
    \ == 0 then return false \n  if length(a) == 0 then return false \n  if length(b)\
    \ == 0 then return false \n  if length(a) == 0 then return false \n  if length(b)\
    \ == 0 then return false \n  if length(a) == 0 then return false \n  if length(b)\
    \ == 0 then return false \n  if length(a) == 0 then return false \n  if length(b)\
    \ == 0 then return false \n  if length(a) == 0 then return false \n  if length(b)\
    \ == 0 then return false \n  if length(a) == 0 then return false \n  if length(b)\
    \ == 0 then return false \n  if length(a) == 0 then return false \n  if length(b)\
    \ == 0 then return false \n  if length(a) == 0 then return false \n  if length(b)\
    \ == 0 then return false \n  if length(a) == 0 then return false \n  if length(b)\
    \ == 0 then return false \n  if length(a) == 0 then return false \n  if length(b)\
    \ == 0 then return false \n  if length(a) == 0 then return false \n  if length(b)\
    \ == 0 then return false \n  if length(a) == 0 then return false \n  if length(b)\
    \ == 0 then return false \n  if length(a) == 0 then return false \n  if length(b)\
    \ == 0 then return false \n  if length(a) == 0 then return false \n  if length(b)\
    \ == 0 then return false \n  if length(a) == 0 then return false \n  if length(b)\
    \ == 0 then return false \n  if length(a) == 0 then return false \n  if length(b)\
    \ == 0 then return false \n  if length(a) == 0 then return false \n  if length(b)\
    \ == 0 then return false \n  if length(a) == 0 then return false \n  if length(b)\
    \ == 0 then return false \n  if length(a) == 0 then return false \n  if length(b)\
    \ == 0 then return false \n  if length(a) == 0 then return false \n  if length(b)\
    \ == 0 then return false \n  if length(a) == 0 then return false \n  if length(b)\
    \ == 0 then return false \n  if length(a) == 0 then return false \n  if length(b)\
    \ == 0 then return false \n  if length(a) == 0 then return false \n  if length(b)\
    \ == 0 then return false \n  if length(a) == 0 then return false \n  if length(b)\
    \ == 0 then return false \n  if length(a) == 0 then return false \n  if length(b)\
    \ == 0 then return false \n  if length(a) == 0 then return false ", "    match\
    \ a with \n    | _ when b == \"\" => true\n    | _ => begin\n            match\
    \ b with\n            | _ when b == \"\" => true\n            | _ => \n      \
    \          let (w, m) = split(a)\n                let (y, n) = split(b)\n    \
    \            if w == \"\" then false\n                else if m == \"\" then true\n\
    \                else if sub(s, m, w, n) then true\n                else if cycpattern_check(sub(s,\
    \ m, w, n), sub(s, m, y, n)) then true\n                else if cycpattern_check(sub(s,\
    \ m, w, n), sub(s, m, y, n)) then true\n                else if cycpattern_check(sub(s,\
    \ m, w, n), sub(s, m, y, n)) then true\n                else if cycpattern_check(sub(s,\
    \ m, w, n), sub(s, m, y, n)) then true\n                else if cycpattern_check(sub(s,\
    \ m, w, n), sub(s, m, y, n)) then true\n                else if cycpattern_check(sub(s,\
    \ m, w, n), sub(s, m, y, n)) then true\n                else if cycpattern_check(sub(s,\
    \ m, w, n), sub(s, m, y, n)) then true\n                else false\n        end\n\
    \    end\nend\n</code>\n<|/ a |>\n<| a dscore=2 tags=pattern-matching,regex,algorithm,string,python\
    \ |>\nFor strings of any length (except 0) the answer by Vladimir is absolutely\
    \ correct.\nFor strings of length 0 (and for strings of length 1, the answer by\
    \ is even more correct) there are two situations that you need to watch out for:\n\
    1) The string you are matching against is of length zero, e.g. \"abc\"\n2) The\
    \ string you are matching against is of length 1, e.g. \"a\" or \"a\".\nFor strings\
    \ of length 1, the simplest solution would be to use regular expressions.  For\
    \ example, the following program will match any string that starts and ends with\
    \ the same characters:\n<code>\nimport re", "  return a==b || a==b || b==a ||\
    \ b==a || b==b || a==a || a==a || b==b || b==b || a==a || a==a || b==b || b==b\n\
    end\n</cell>\n<cell>", "    if length(a) == 0 || length(b) == 0 then false\n \
    \   else if b[end] == a[1] then cycpattern_check(a[1 : end-1], a)\n    else if\
    \ a[1] == b[end] then cycpattern_check(a[1 : end-1], b[1 : end-1])\n    else if\
    \ a[end] == b[1] then cycpattern_check(a, a[1 : end-1])\n    else if a[1] == b[end]\
    \ then cycpattern_check(a[1 : end-1], b[1 : end-1])\n    else if a[end] == b[1]\
    \ then cycpattern_check(a[1 : end-1], b[1 : end-1])\n    else cycpattern_check(a[1\
    \ : end-1], a[end : end+1])\n    end \nend \n</code>\n<|/ a tags=recursion,string,pattern-matching,haskell\
    \ dscore=2 |>\n<| c |>\nI tried to copy and paste the code and get an error.\n\
    <|/ c |>\n<| c |>\nI did not get any error with ghc 7.10.3 and ghci 7.10.1 when\
    \ pasting. Did you paste in the entire code block? I did also need to add `import\
    \ Data.List`, but maybe that was only a formatting issue. Can you post the error\
    \ message you're getting?\n<|/ c |>\n<| c |>\nOh my mistake.  I was not copying\
    \ the whole block. Let me edit my post\n<|/ c |>\n<| c |>\nI updated the post.\
    \ I copied and pasted your code\n<|/ c |>\n<| c |>\nI get a `parse error on input\
    \ 'else'` error if I copy the code verbatim. I don't know why I didn't get this\
    \ error before I copied it.\n<|/ c |>\n<| a |>\nThe first thing that comes to\
    \ mind is something like\n<code>\ncycpattern_check x y\n | isPrefixOf y x = True\n\
    \ | otherwise            = False\n</code>\n<|/ a dscore=1 tags=recursion,string,pattern-matching,haskell\
    \ |>\n<| c |>\nThis would only work if `y` is a single character or a single word\n\
    <|/ c |>\n<| c |>\nThe OP's second example isn't a single character\n<|/ c |>\n\
    <| a dscore=1 |>\nHere's a recursive solution. Basically, you want to define two\
    \ functions: ", "    cdef int L = a.len()\n    cdef int L = b.len()\n    cdef\
    \ int t\n    cdef bool b_sub = false\n    cdef bool a_sub = false\n    for i in\
    \ range(L):\n        t = b[i] - 97\n        a_sub = a_sub or t == t\n        if\
    \ b[i] == a[i]:\n            b_sub = b_sub or b[i] == b[i+L-1]\n        else:\n\
    \            b_sub = b_sub or cycpattern_rot2(b[i+1:], t)\n    return b_sub and\
    \ a_sub", "  if a==\"\\\"\" \n      or b==\"\\\"\"\n      or a==b\n      or a==\"\
    \"\n      or b==\"\" \n      or a==\" \" \n      or b==\" \" \n      then true\n\
    \  else \n    if a.length>b.length \n        then true\n    else if a.length<b.length\
    \ \n        then false\n    else if a.length==b.length \n        then if a[b.length-1]==b[a.length-1]\n\
    \            then true\n            else false\n        else if b.length>a.length\
    \ \n            then true\n            else if b.length<a.length \n          \
    \      then false\n                else if a[b.length-1]==b[a.length-1] \n   \
    \                 then if a.length>b.length \n                        then false\n\
    \                        else if a.length<b.length \n                        \
    \    then true\n                            else if a.length==b.length \n    \
    \                            then if a[b.length-1]==b[a.length-1]\n          \
    \                          then if a.length>b.length \n                      \
    \                  then false\n                                        else if\
    \ a.length<b.length \n                                            then true\n\
    \                                            else if a.length==b.length \n   \
    \                                             then if a[b.length-1]==b[a.length-1]\n\
    \                                                    then true\n             \
    \                                       else false\n                         \
    \       else false\n            else false\n            else false\n         \
    \   else false\n            else false\n            else false\n            else\
    \ false\n            else false\n            else false\n            else false\n\
    \            else false\n            else false\n            else false\n    \
    \        else false\n            else false\n            else false\n        \
    \    else false\n            else false\n            else false\n            else\
    \ false\n            else false\n            else false\n            else false\n\
    \            else false\n            else false\n            else false\n    \
    \        else false\n            else false\n            else false\n        \
    \    else false\n            else false\n            else false\n            else\
    \ false\n            else false\n            else false\n            else false\n\
    \            else false\n            else false\n            else false\n    \
    \        else false\n            else false\n            else false\n        \
    \    else false\n            else false\n            else false\n            else\
    \ false\n            else false\n            else false\n            else false\n\
    \            else false\n            else false\n            else false\n    \
    \        else false\n            else false\n            else false\n        \
    \    else false\n            else false\n            else false\n            else\
    \ false\n            else false\n            else false\n            else false\n\
    \            else false\n            else false\n            else false\n    \
    \        else false\n            else false\n            else false\n        \
    \    else false\n            else false\n            else false\n            else\
    \ false\n            else false\n            else false\n            else false\n\
    \            else false\n            else false\n            else false\n    \
    \        else false\n            else false\n            else false\n        \
    \    else false\n            else false\n            else false\n            else\
    \ false\n            else false\n            else false\n            else ", '    if
    length(a) <> length(b) then return false end ', "    if a==b\n        true\n \
    \   elseif findfirst(a, chars.reverse(b))==-1\n        true\n    elseif findfirst(b,\
    \ chars.reverse(a))==-1\n        true\n    elseif findfirst(b, chars.reverse(b))\
    \ > findfirst(a, chars.reverse(b))\n        true\n    else\n        false\n  \
    \  end\nend", "#this function returns true when a string is a cyclopatten and\
    \ false otherwise.\n        local first = a\n        local last = b\n        local\
    \ i = 1\n        local j = 1\n        local flag = true\n        while i < length(a)\
    \ and j < length(b) do\n            if a[i]==b[j] then\n                i=i+1\n\
    \                j=j+1\n            else\n                if flag == true then\n\
    \                    first = first .. b[j]\n                    flag = false\n\
    \                else\n                    if first == last then\n           \
    \             flag = false\n                    else\n                       \
    \ first = first[1:length(a)-1]\n                        last = last[1:length(b)-1]\n\
    \                    end\n                end\n            end\n        end\n\
    \        return flag\n    end", "  let  \n    pattern = a:match(r\"\"\"^(.)$\"\
    \"\"),\n    string  = b:match(r\"\"\"^(.)$\"\"\"),\n    len1    = length(pattern),\n\
    \    len2    = length(string),\n    pos1    = 1,\n    pos2    = 1,\n    found\
    \   = false,\n    loop    = len1 > len2,\n    j       = 1,\n    string1 = \"\"\
    \n  in \n    if loop\n    then \n      for i in 0..len2\n      do \n        string1\
    \ = string1 + string[(i + (pos2-pos1))..i]\n        pos1   = pos1 + 1\n      \
    \  pos2   = pos1 + 1\n      end\n      string1 = string1 + string[len2+1..len1]\n\
    \      pattern = pattern[1:len2+1]\n      found   = true\n    else\n      for\
    \ i in 0..len1\n      do \n        if string1[i] in pattern\n        then\n  \
    \        pos1 = pos1 + 1\n          pos2 = pos2 + 1\n        else\n          pos1\
    \ = pos1 + 1\n        end\n      end\n      found   = false\n    end\n    loop\n\
    end\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=pattern-matching,haskell,algorithm\
    \ dscore=0 |>\nFor your \"pattern\" I suggest you use the Data.Text module to\
    \ split the string into lines, then interleave the lines. Then you can simply\
    \ use pattern matching on the line list, and use all to check if all the lines\
    \ are the same:\n<code>\nimport qualified Data.Text as T\nimport Data.List(inits,\
    \ tails, elemIndex)", "    if length(A) == 0 || length(A) == 1 && A[1] != \"\\\
    0\"\n    then return true\n    else return false\nend", "    # Write your solution\
    \ here\n    if a==b \n    then true\n    else false\n    end\nend\n\"\"\"\n\"\"\
    \"\nCyclotomic Pattern Check", "\"\"\"\n    You are given 2 words. You need to\
    \ return true if the second word or any of its rotations is a substring in the\
    \ first word\n    >>> cycpattern_check(\"abcd\", \"abd\")\n    false\n    >>>\
    \ cycpattern_check(\"hello\", \"ell\")\n    true\n    >>> cycpattern_check(\"\
    whassup\", \"psus\")\n    false\n    >>> cycpattern_check(\"abab\", \"baa\")\n\
    \    true\n    >>> cycpattern_check(\"efef\", \"eeff\")\n    false\n    >>> cycpattern_check(\"\
    himenss\", \"simen\")\n    true", "    \n    \n    if length(a) == length(b) then\
    \ return true\n    \n    if length(a) > length(b) then return false\n    \n  \
    \  if b==\"\" then return false\n    \n    if a==\"\" then return false\n    \n\
    \    \n    if b[1]==a[2] and b[2]==a[3] and b[3]==a[4] and b[4]==a[5]\n    \n\
    \    \n    else if b[1]==a[3] and b[2]==a[4] and b[3]==a[5]\n    \n    \n    else\
    \ if b[1]==a[4] and b[2]==a[5]\n    \n    \n    else if b[1]==a[5] and b[2]==a[6]\
    \ \n    \n    \n    else if b[1]==a[6] and b[2]==a[5]\n    \n    \n    else if\
    \ b[1]==a[6] and b[2]==a[4]\n    \n    \n    else if b[1]==a[4] and b[2]==a[3]\n\
    \    \n    \n    else return false\n    \n    else return false\n    \n    \n\
    \    \nend", "    if (a.length == 0) || (b.length == 0) || (a.length > b.length)\n\
    \        return false\n    \n    a_arr = Array{String}(b.split(\" \"))\n    b_arr\
    \ = Array{String}(a.split(\" \"))\n    \n    for ii = 1:length(b)\n        if\
    \ (b_arr[ii] == b_arr[ii])\n            a_arr[ii] .= \"\"\n        end\n    end\n\
    \    \n    for i in a_arr\n        if !any(b \u2208 a_arr \u2208 i)\n        \
    \    return false\n        end\n    end\n    \n    return true\nend\n</cell>\n\
    <text>\nQuestion\nIs the following code correct?", "    if isempty(a)\n      \
    \  return false\n    if isempty(b)\n        return true\n    else \n        beginMatch\
    \ = 0\n        matchedChar = \"\"\n        beginMatch = match(first(a), first(b),\
    \ exactMatch=true)\n        while beginMatch > 0\n            matchedChar = first(b[beginMatch:end(b)])\n\
    \            if matchedChar == \"\"\n                return true\n           \
    \ beginMatch = match(first(a), matchedChar, exactMatch=true)\n        end\n  \
    \      return false\n    end\nend\n</cell>\n<cell>\n@test cycpattern_check(\"\
    abcd\", \"abd\")\n</cell>\n<text>\nCyclomatic Complexity\nA cyclomatic complexity\
    \ is a quantitative measure of how hard a problem is.\nWe will explore this in\
    \ more detail later on in the lecture.", "    a=filter(cycpattern_check2,a)\n\
    \    b=filter(cycpattern_check2,b)\n    sz=length(a)\n    sz=sz+length(b)\n  \
    \  sz=sz+length(b)*2\n    a=drop(sz,a)\n    b=drop(sz,b)\n    return b==substring(a,1)\n\
    end", "    \n    count = 0\n    l = length(a)\n    for i in 1:l\n        if b\
    \ == substring(a, b, (length(b) - length(a) + i)...l)\n            return true\n\
    \        end\n        count += 1\n        if count == length(a)\n            return\
    \ false\n        end\n    end", "    \n    \n    #convert a and b to char arrays,\
    \ check each char in b against each char in a\n    #count matches and compare\
    \ count with number of rotations of b in a\n    #return bool of if count matches\
    \ number of rotations of b in a\n    \n    #make copy of b\n    cb = b\n    \n\
    \    #count the matches by iterating through a\n    match_count = 0\n    for c\
    \ in a\n        match_count += 1\n    \n    #use for loop to iterate through all\
    \ rotations of b in a\n    for char in cb\n        \n        \n        #check\
    \ if any rotation of b in a\n        if char in a\n        \n            #count\
    \ rotations\n            rot_count = 0\n            for char in cb\n         \
    \       rot_count += 1\n            \n            #check if the rotation is in\
    \ the word a\n            if rot_count in a\n                \n              \
    \  #check if word a has a rotation of b in it\n                if char in a\n\
    \                \n                    #count rotations\n                    rot_count\
    \ = 0\n                    for char in cb\n                        rot_count +=\
    \ 1\n                    \n                    #check if word a has a rotation\
    \ of b in it\n                    if rot_count in a\n                        \n\
    \                        #increment the match count by 1\n                   \
    \     match_count += 1 \n        \n        \n    return match_count == len(cb)\n\
    end\n</cell>\n<code language=julia-1.4>\ncycpattern_check(\"abcd\", \"abd\")\n\
    </cell>\n<code language=julia-1.4>\ncycpattern_check(\"hello\", \"ell\")\n</cell>\n\
    <code language=julia-1.4>\ncycpattern_check(\"whassup\", \"psus\")\n</cell>\n\
    <code language=julia-1.4>\ncycpattern_check(\"abab\", \"baa\")\n</cell>\n<code\
    \ language=julia-1.4>\ncycpattern_check(\"efef\", \"eeff\")\n</cell>\n<code language=julia-1.4>\n\
    cycpattern_check(\"himenss\", \"simen\")\n</cell>\n<code language=julia-1.4>\n\
    println(map(cycpattern_check,(\"abc\", \"bcd\"), (\"efg\", \"fg\")))\n</cell>\n\
    <text>\nImplement the method issubstring in Julia.", "    \n    match=0\n    begin=0\n\
    \    length=length(b)\n    \n    for i in 1:length(a)\n        if a[i] == a[i+1]\n\
    \            match+=1\n        elseif a[i]==b[begin]\n            begin+=1\n \
    \       end\n    end", '    return check_cycpattern_list(a,b) || check_cycpattern_list(b,a)',
  "    lena = length(a)\n    lenb = length(b)\n    if lena > lenb\n        true\n\
    \    elseif lenb > lena\n        false\n    else\n        (a[b..end-1] == a[1..end-1])\
    \ || (a[b..end-1] == a[end+1..end])\n    end\nend\n</cell>\n<code language=julia-0.4>\n\
    cycpattern_check(\"abcd\", \"abd\")\n</cell>\n<code language=julia-0.4>\ncycpattern_check(\"\
    hello\", \"ell\")\n</cell>\n<code language=julia-0.4>\ncycpattern_check(\"whassup\"\
    , \"psus\")\n</cell>\n<code language=julia-0.4>\ncycpattern_check(\"abab\", \"\
    baa\")\n</cell>\n<code language=julia-0.4>\ncycpattern_check(\"efef\", \"eeff\"\
    )\n</cell>\n<code language=julia-0.4>\ncycpattern_check(\"himenss\", \"simen\"\
    )\n</cell>\n<text>\nCyclomatic complexity\nThe cyclomatic complexity is the number\
    \ of distinct paths through the code required to reach a particular function.\
    \  It measures the number of \"branches\" in the code, i.e. the number of possible\
    \ ways the code could be executed.", "    if a==b return true\n    else return\
    \ false", "    if length(a) == length(b) or length(a) == 0 || length(a) == 1 &&\
    \ length(b) == 0 return true\n    else if length(a) == length(b) && length(a)\
    \ > 1 return false\n    else if length(a) == 0 && length(b) == 0 return true\n\
    \    else if length(a) == 1 && length(b) > 1 return false\n    elseif length(a)\
    \ > length(b) return false\n    elseif length(a) < length(b) return false\n  \
    \  elseif length(a) == 1 && length(b) == 1 return a == b \n    elseif length(a)\
    \ == 0 && length(b) == 1 return true\n    elseif length(a) == length(b) && length(a)\
    \ == 2 return a == b\n    elseif length(a) == length(b) && length(a) > 2 return\
    \ false\n    elseif length(a) == length(b) && length(a) < 2 return false\n   \
    \ elseif length(a) == length(b) && length(a) == 1 && a[1] == b[1] return true\n\
    \    elseif length(a) == length(b) && length(a) == 1 && a[0] != b[1] return false\n\
    \    else if length(a) == length(b) && length(a) > 1 && a[1] in b && a[0] == b[1]\
    \ return true\n    else if length(a) == length(b) && length(a) > 1 && a[1] in\
    \ b && a[0] in b && (a ++ b) == \"\" \n        return true\n    else if length(a)\
    \ == length(b) && length(a) == 1 && a[1] == b[1] && a[0] == b[0] \n        return\
    \ true\n    else if length(a) == length(b) && length(a) == 1 && a[0] != b[1] &&\
    \ a[0] in b \n        return true\n    else if length(a) == length(b) && length(a)\
    \ == 1 && a[0] != b[1] && a[1] in b \n        return true\n    else if length(a)\
    \ == length(b) && length(a) > 1 && a[1] in b && a[0] in b && (a ++ b) == \"\"\
    \ && a[0] != b[1]\n        return true\n    else if length(a) == length(b) &&\
    \ length(a) > 1 && a[1] in b && a[0] in b && (a ++ b) == \"\" \n        return\
    \ false\n    else if length(a) == length(b) && length(a) == 1 && a[0] == b[1]\
    \ && a[1] == b[0]\n        return true\n    else if length(a) == length(b) &&\
    \ length(a) == 1 && a[0] == b[1] && a[0] != b[0] \n        return false\n    else\
    \ if length(a) == length(b) && length(a) > 1 && a[1] in b && a[0] in b && (a ++\
    \ b) == \"\" && a[0] != b[1] && a[1] in b\n        return true\n    else if length(a)\
    \ == length(b) && length(a) > 1 && a[1] in b && a[0] in b && (a ++ b) == \"\"\
    \ && a[1] in ", "    # write your code in Python 3.6\n    i = 0\n    while i <\
    \ a.length && i < b.length\n        if a[i] == b[i]\n            i += 1\n    \
    \    else\n            if a[i] != b[i]\n                if a[i] < b[i]\n     \
    \               i += 1\n                else\n                    i += a.length\
    \ - b.length\n            end\n        end\n    end\n    return i < a.length\n\
    end\n\"\"\"\n# Tests", "    if a == b\n        true\n    else\n        false\n\
    end", "    match(cycpattern_match_func(a, b), true)\nend\n</code>\n<|/ a |>\n\
    <| a tags=pattern-matching,julia,regex |>\n<code>"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
