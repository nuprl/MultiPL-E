name: HumanEval_145_order_by_points
language: jl
prompt: "\"\"\"\n    Write a function which sorts the given vector of integers\n \
  \   in ascending order according to the sum of their digits.\n    Note: if there\
  \ are several items with similar sum of their digits,\n    order them based on their\
  \ index in original vector.\n\n    For example:\n    >>> order_by_points([1, 11,\
  \ -1, -11, -12])\n    [-1, -11, 1, -12, 11]\n    >>> order_by_points([])\n    []\n\
  \    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64} \n"
tests: "using Test\n\n@testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1,\
  \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463,\
  \ 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423,\
  \ 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
  \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) ==\
  \ [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8,\
  \ 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6,\
  \ 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
completions: ["    n = length(nums)\n    sum_of_digits = 0.\n    for i in 1:n\n  \
    \      digits = nums[i]\n        sum_of_digits += digits\n    end\n    sums =\
    \ Vector{Float64}(sum_of_digits)\n    for r in nums\n        sums[sum_of_digits\
    \ .+ r] .= r\n    end\n    \n    \n    result = Float64[]\n    i = Int(0)\n  \
    \  while i <= n\n        sums[i + 1] = sums[i] + sums[i + 1]\n        \n     \
    \   j = i\n        while j > 0 && sums[j - 1] > sums[j]\n            sums[j] =\
    \ sums[j - 1]\n            j -= 1\n        end", "    if length(nums) == 0 return\
    \ nums\n    \n    digit_sums = map_cat( digits(nums) , sum)\n    digit_sums =\
    \ sort_by_key(digit_sums, by = x -> x)\n    \n    digit_sums_sorted = map_cat(\
    \ keys(digit_sums), values(digit_sums))\n    digit_sums_sorted = sort_by_key(digit_sums_sorted,\
    \ by = x -> x)\n    \n    reverse!(digit_sums_sorted)", "    if length(nums) ==\
    \ 0 then return nums \n    nums0 = copy(nums)\n    nums0 = remove_values(nums0,\
    \ nums0)\n    \n    sums0 = sum.(nums0)\n    \n    ordered = copy(nums0)\n   \
    \ for idx in eachindex(nums0)\n        nums[idx] = nums0[idx]\n    end\n    \n\
    \    sorted = nums\n    for idx in eachindex(nums)\n        \n        pos = findfirst(isequal(nums[idx]),\
    \ ordered)\n        if pos == nothing then \n            error(\"Value not found\"\
    )\n        end\n        \n        tmp = nums[idx]\n        nums[idx] = ordered[pos]\n\
    \        ordered[pos] = tmp\n        \n        pos = findfirst(isequal(sums[idx]),\
    \ ordered)\n        if pos == nothing then \n            error(\"Value not found\"\
    )\n        end\n        \n        tmp = sums[idx]\n        sums[idx] = ordered[pos]\n\
    \        ordered[pos] = tmp\n    end\n    \n    return ordered\nend", "    \n\
    \    nums = nums[:]\n    largest = nums.last\n    for num in nums[2:end]\n   \
    \     if num >= largest\n            largest = num\n        elseif num < largest\n\
    \            largest = num\n        end\n    end\n    return nums[2:end][largest..(nums[1])]\n\
    end\n</cell>\n<code language=julia-1.1>", "    #Sort by point\n    dig <- unique(nums)\n\
    \    dig <- sort(dig)\n    idxs <- map((i, x) -> length(x & dig & x[i]), 1:length(dig),\
    \ nums)\n    idxs[order(idxs)]\nend", "    if nums == []\n        return []\n\
    \    \n    sums = Vector{Int64}()\n    for i in nums\n        sums[i] = sum(i)\
    \ + i\n    end\n    \n    largest = 0\n    for i in nums\n        if sums[i] >\
    \ sums[largest]\n            largest = i\n        end\n    end\n    \n    \n \
    \   \n    result::Vector{Int64} = []\n    for i in nums\n        if i == largest\n\
    \            result[end] = i\n            push!(result, i)\n        end\n    end\n\
    \    \n    sort(result)\n    return result\nend\n</cell>\n<code language=julia-1.2>",
  "    \n    nums = nums[:]\n    sort(nums, lt=(x->isdigit(x), desc=(x->sum(x) > sum(xs))));\n\
    \    nums[:]\nend\n</cell>\n<code language=julia-1.0>\norder_by_points([1, 11,\
    \ -1, -11, -12])\n</cell>\n<text>\n4.2.3 Exercise", "    if nums == Vector{Int64}()\
    \ \n        return nums \n    sum_of_digits = sum(nums)\n    sorted_by_index =\
    \ Vector{Int64}()\n    for i, x in nums \n        digits = floor(Int, x / sum_of_digits)\
    \ \n        if digits == 0 \n            sorted_by_index[i] = x \n        else\
    \ \n            sorted_by_index[i] = x + sum_of_digits - digits \n    end\n  \
    \  return sorted_by_index\nend", "    # Write your answer within this function\n\
    \    sorted = sorted(nums)\n    result = Vector{Int64}()\n    \n    for elem in\
    \ sorted\n        sum = 0\n        for n in elem\n            sum += n\n     \
    \   end\n        result.push!(elem + sum)\n    end\n    \n    return result\n\
    end\n</cell>\n<code language=julia-0.6>\norder_by_points([1, 11, -1, -11, -12])\n\
    </cell>\n<text>\n3.2.4 Exercise: Sort a vector by sum of its digits\nWrite a function\
    \ that takes a vector of integers and sorts it in the ascending order according\
    \ to the sum of its digits.", "    \n    if nums == Vector{Int64}()\n        return\
    \ nums\n    \n    sums = Vector{Int64}(length(nums))\n    for i in 1:length(nums)\n\
    \        sums[i] = digits(nums[i])\n    end\n    \n    sorted = Vector{Int64}(length(nums))\n\
    \    sorted[:] = sortperm(sums)\n    \n    sorted_nums = Vector{Int64}(length(sorted))\n\
    \    \n    for i in 1:length(sorted)\n        sorted_nums[i] = nums[sorted[i]]\n\
    \    end\n    \n    return sorted_nums\nend", "    if isempty(nums) \n       \
    \ return [] \n    \n    sum_of_digits = zeros(Int, length(nums)) \n    for (ix,\
    \ val) in enumerate(nums)\n        sum_of_digits[ix] = sum(val) \n    \n    idxs\
    \ = sort(sum_of_digits)\n    \n    # sort according to index\n    for ix in idxs\n\
    \        nums[ix] = idxs[ix] \n    end", "    if length(nums) == 0 \n        return\
    \ [] \n    end", "    if length(nums) == 0 \n        return nums\n    else\n \
    \       digits = collect(nums) |> collect{x-> mod(x, 10)}\n        sums = map\
    \ sum(digits) nums\n        order = sort_by(sums)\n        return map(x-> x[1],\
    \ order)\nend\n</code>\nThe last step was to implement a function that returns\
    \ the given vector sorted by its sum:\n<code>", "    \"\"\"\n    Sort nums in\
    \ ascending order according to the sum of their digits.\n    Note: if there are\
    \ several items with similar sum of their digits,\n    order them based on their\
    \ index in original vector.", "    if len(nums) == 0\n        []\n    else\n \
    \       smallest = length(nums) - 1\n        highest = length(nums)\n        sum\
    \ = 0\n        for i in nums\n            sum += i\n            if sum < smallest\
    \ \n                smallest = i\n            elsif sum > highest\n          \
    \      highest = i\n            end\n        end\n        smallest_index = i\n\
    \        highest_index = i\n        for j in nums\n            if j < smallest\n\
    \                smallest_index = j\n            elseif j > highest\n        \
    \        highest_index = j\n            end\n        end\n        nums[smallest_index],\
    \ nums[highest_index] = nums[highest_index], nums[smallest_index]\n        nums\n\
    \    end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nWhile this code may answer\
    \ the question, providing additional context regarding how and/or why it solves\
    \ the problem would improve the answer's long-term value.\n<|/ c |>\n<| a tags=algorithm,sorting,time-complexity,big-o\
    \ |>\nAn O(n) time complexity solution would be to go through each item and compare\
    \ its digits with the digits of the item in the next position.  If the sum of\
    \ its digits is less than the sum of the digits in its next position, then swap\
    \ the two numbers.\n<|/ a dscore=1 |>\n<| a |>\nO(n) time solution:\n<code>\n\
    def order_by_points(nums::Vector{Int64})::Vector{Int64} \n   for i in 0..(length(nums)\
    \ - 1) \n      largest = 0\n      smallest = length(nums) - 1 \n      for j in\
    \ 0..(length(nums) - 1)  \n         if nums[j] > nums[largest + 1]\n         \
    \   largest = j\n         elseif nums[j] < nums[smallest + 1]\n            smallest\
    \ = j\n         end\n      end", "    len = length(nums)\n    total = 0\n    for\
    \ x in nums\n        total += x\n    end\n    \n    biggest = -Inf.(Inf, 0)\n\
    \    biggest_idx = 0\n    for x in nums\n        idx = total - x\n        if idx\
    \ == -1\n            idx = 0\n        end\n        total -= idx\n        if total\
    \ > biggest[1]\n            biggest = (total, idx)\n        elseif total < biggest[0]\n\
    \            biggest = (total, idx)\n        end\n    end\n    \n    smallest\
    \ = -Inf.(Inf, 0)\n    smallest_idx = 0\n    for x in nums\n        idx = total\
    \ - x\n        if idx == -1\n            idx = 0\n        end\n        total -=\
    \ idx\n        if total < smallest[1]\n            smallest = (total, idx)\n \
    \       elseif total > smallest[0]\n            smallest = (total, idx)\n    \
    \    end\n    end\n    \n    if biggest[1] > smallest[1]\n        nums[biggest[1]]\
    \ = biggest[2]\n        order_by_points(nums)\n    end\n    \n    if smallest[1]\
    \ > biggest[1]\n        nums[smallest[1]] = smallest[2]\n        order_by_points(nums)\n\
    \    end\n    \n    return nums\nend\n</cell>\n<text>\nProblem 4: Find all anagrams\
    \ of input string", "    nums_sum = sum(nums)\n    order = Vector{Int64}(undef,\
    \ length(nums))\n    for (i,n) in enumerate(nums)\n        nums[i] = n*10 + nums_sum\
    \ - nums[i]\n        indx = nums_sum - nums[i]\n        indx = indx\n    end\n\
    \    \n    for (i,n) in enumerate(order)\n        if n <= 0\n            order[i]\
    \ = indx\n        end\n    end\n    \n    for (i,n) in enumerate(nums)\n     \
    \   if n <= 0\n            order[i] = 0\n        end\n    end\n    return order\n\
    end\n</cell>\n<code language=julia-1.3>", "        res=sort(nums)\n        if\
    \ length(res.data)==length(nums)\n            s=sum(res.data)\n            \n\
    \            for i \u2208 1:length(nums)\n                if nums[i]>0 && (s==0\
    \ || s==nums[i])\n                    res[i]=nums[i]\n                    s=s\u2212\
    nums[i]\n                end\n            end\n            return res\n      \
    \  else\n            return nums\n        end\n    end\n</code>\n<|/ a tags=sorting,arrays,julia\
    \ dscore=0 |>\n<| a dscore=0 tags=sorting,arrays,julia |>\nMy take on it using\
    \ sortperm:\n<code>", "    \n    sum_of_digits = sum((num .- digits(num))\n  \
    \      for num in nums)\n    \n    sorted_vector = collect(zip(nums, repeat(sum_of_digits)))\
    \ |> sort_by\n    return map(pair -> pair[1], sorted_vector)\nend\n</cell>\n<text>\n\
    Let's check whether it works:", "        =  [i for i in nums if i==i else i for\
    \ i in nums sort]\n    return order_by_points(nums)\nend", "  \n  if length(nums)\
    \ <= 1\n    return nums\n  else\n  \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n", "    if nums == []\n    else if length(nums)\
    \ == 1 \n        nums\n    elseif length(nums) > 1\n        sort(nums) |> unique\n\
    \    else\n        nums\n    end\nend\n</code>\n<code>\norder_by_points([1, 11,\
    \ -1, -11, -12])\n    => [-1, -1, -12, -11, 1]\n</code>\nThis can be implemented\
    \ in a more general way for cases where you have a Vector{Tuple{Int64, Int64}}.\
    \ \n<code>\norder_by_points(nums::Vector{Tuple{Int64, Int64}})\n    if nums ==\
    \ []\n    else if length(nums) == 1 \n        nums\n    elseif length(nums) >\
    \ 1\n        sort(nums) |> unique\n    else\n        nums\n    end\nend\n</code>\n\
    <code>\norder_by_points([(1, 2), (10, 20), (4, 5), (2, 4)])\n    => [(2, 4), (4,\
    \ 5), (1, 2), (10, 20)]\n</code>\n<|/ a dscore=0 tags=sorting,julia |>\n<| a dscore=0\
    \ |>\nHere is a way to do this in Julia:\n<code>", "    result = Vector{Int64}()\n\
    \    for i in 1:length(nums)\n        sum_of_digits = sum(nums[i])\n        found_index\
    \ = false()\n        for j in 1:length(result)\n            if sum_of_digits ==\
    \ result[j]\n                found_index = true()\n                break\n   \
    \         end\n        end\n        if !found_index\n            push!(result,\
    \ sum_of_digits)\n        end\n    end\n    result\nend\n</cell>\n<code language=julia-1.6>\n\
    # test your code\norder_by_points([1, 11, -1, -11, -12])\n</cell>\n<text>\nExpected\
    \ result", "        -- nums: a vector of integers\n        nums = sort(nums)\n\
    \        local result = Vector{Int64}()\n        local pos = 0\n        local\
    \ max_count = 0\n        local num\n        -- num: current element of the vector\n\
    \        for num in nums do \n            -- find index of the current element\
    \ of the vector \n            local pos = pos+num/10\n            -- num is sorted,\
    \ add it to result\n            if pos < length(nums) && nums[pos] == num\n  \
    \              then result[#result+1] = num\n                end\n           \
    \ -- if current num's sum is > max_count, update it\n            if pos < length(nums)\n\
    \                then max_count = max_count+num/10\n                end\n    \
    \        end\n        end\n        -- return result vector\n        return result\n\
    \        end\nend\n</cell>\n<text>\nQuestion 1.10 (10 points)\nWrite a function\
    \ which counts the number of elements in the given vector whose sum is at least\
    \ 10.\nFor vectors $ \\vec{x} \\in \\mathbb{R}^n $, write the function such that\
    \ it can be written in a single line without using loops or extra variables (hint:\
    \ use recursion).", "    bigger_nums::Vector{Int64}=[]\n    bigger_nums::Vector{Int64}=nums[:]\n\
    \    for i in nums\n        sum_of_digits=0\n        for j in bigger_nums\n  \
    \          sum_of_digits+=j%10\n            bigger_nums[j]=bigger_nums[j]/10\n\
    \            if sum_of_digits == i\n                bigger_nums.insert(j,i)\n\
    \                bigger_nums.insert(j,i)\n                break\n        end\n\
    \    end\n    return bigger_nums\nend", "    ans = nums\n    sum_of_digits = nums.reduce((a,b)\
    \ -> (a + b) * 10, 0)\n    for (ix, val) in enumerate(nums) \n        val_of_digits\
    \ = val % 10\n        other_val_of_digits = nums[ix] % 10\n        if val_of_digits\
    \ > other_val_of_digits\n            ans[ix] = val\n        else\n           \
    \ ans[ix] = nums[ix]\n        end\n    end\n    return ans\nend\n</cell>\n<code\
    \ language=julia-1.6>", "  if length(nums) == 0\n    return nums\n  end\n  num_sum\
    \ = nums[1] + nums[2]\n  nums[1] = nums[2]\n  nums[2] = num_sum\n  for i in 1:length(nums)\n\
    \    if nums[i] > 0\n      nums[i] = nums[i] - nums[i]\n    else\n      break\n\
    \    end\n  end\n  nums = nums[2:end]\n  nums = reverse(nums)\n  return nums\n\
    end", "    \"\"\"\n    Sort integer vector using sum_digits() function.\n    \"\
    \"\"\n    local n = length(nums)\n    if n < 2 \n        return nums\n    local\
    \ sums = Vector{Int64}(undef, n)\n    for i in 1:n\n        sums[i] = sum_digits(nums[i])\n\
    \    end", "    if nums == []\n        []\n    elseif length(nums) == 1\n    \
    \    [nums[1]]\n    elseif nums[2] < nums[1]\n        [nums[1], nums[2]]\n   \
    \ else\n        order_by_points(nums[2:end-1]) + [nums[1]]\n    end\nend\n</cell>\n\
    <code language=julia-1.0>\norder_by_points(vec1)\n</cell>\n<text>\nChallenge Problem:\
    \ Write a function which takes a vector of ints and returns a vector of strings\
    \ with each string representing a number which has the same digits as the input\
    \ vector in ascending order. Examples:", "    sorted = [i for i in nums]\n   \
    \ sorted.sort()\n    for i in nums\n        sorted.remove(i)\n        sorted.insert(i)\n\
    \    return sorted\nend", "    if is_empty(nums) \n        return nums \n    \n\
    \    local nums_str = map(str, nums)\n    local res = nums_str[1][1]\n    \n \
    \   for i in 2:length(nums_str) \n        local sum = i-1\n        local sum2\
    \ = 1\n        local i2 = i\n        \n        while sum2 <= sum + res[1] \n \
    \           sum2 = sum2 + res[1]\n            i2 = i2 -1\n        end\n      \
    \  \n        res = i2, sum2 \n    end\n    \n    local nums_str2 = map(str, nums)\n\
    \    \n    for i = 2:length(nums_str2) \n        local sum = i-1\n        local\
    \ i2 = i\n        \n        while sum <= res[1] \n            sum = sum + res[1]\n\
    \            i2 = i2 -1\n        end\n        \n        nums[i] = nums[i2] \n\
    \    end\n    \n    return nums\nend", "    dig_sums=map(digits,nums)\n    dig_sums=dig_sums[sortperm(dig_sums)]\n\
    \    for i=1:length(dig_sums)\n        if dig_sums[i]!=dig_sums[i-1]\n       \
    \     dig_sums=dig_sums[sortperm(dig_sums)]\n            break\n        end\n\
    \    end\n    return dig_sums\nend\n</code>\n<|/ a tags=sorting,arrays,julia |>\n\
    <| a dscore=1 |>\nThis also works.\n<code>", "    if nums == []\n        res=nums\n\
    \        return res\n    nums2 = nums\n    nums2.sort! # O(nlogn)\n    res=[]\n\
    \    cur = nums2[1]\n    last = 0\n    for i = 3, length(nums2), 3 \n        if\
    \ nums2[i-1]+nums2[i]+nums2[i+1] > cur \n            push!(res, last+nums2[i-1])\n\
    \            last = cur\n            cur = nums2[i+1]\n        else\n        \
    \    cur = nums2[i]\n        end\n    end\n    push!(res, last+cur)\n    return\
    \ res\nend\n</cell>\n<code language=julia-1.3>\norder_by_points([1, 11, -1, -11,\
    \ -12])\n</cell>\n<text>\nProblem 3: Find the next greater integer which has same\
    \ digits in same positions in vector\nThe next greater integer in above problem\
    \ can be found using this formula.", "  local result\n  local order\n  local i\n\
    \  for i in nums\n    if i == 0\n      order = 1\n    else\n      if i % 10 ~=\
    \ 0\n        order = order + 1\n      else\n        order = order + i\n      end\n\
    \    end\n    if order > 1\n      result[order] = i\n    end\n  end\n  return\
    \ result\nend", "    if length(nums) == 0\n        \n    elseif length(nums) ==\
    \ 1\n        if nums[1] < 0\n            return nums\n        else\n         \
    \   return [nums[1]]\n        end\n    end\n    \n    digits = map(digits(nums[1]),\
    \ nums)\n    sort_idx = sort(digits)\n    \n    return nums[sort_idx]\nend", " \
    \   if nums == []\n    else if length(nums) <= 1\n        nums\n    else\n   \
    \     sorted_index = []\n        sum = sum(nums)\n        for i in nums\n    \
    \        if sum == i\n                push!(sorted_index, i)\n            elseif\
    \ sum > i\n                push!(sorted_index, i)\n                sum -= i\n\
    \            else\n                push!(sorted_index, i)\n                sum\
    \ += i\n            end\n        end\n        nums[sorted_index] \n    end\nend",
  "    v = sort(nums)\n    v[findall(iszero(v))]\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThank you for sharing your solution! I would suggest that you edit your\
    \ answer to explain how your solution works.\n<|/ c |>\n<| c |>\nThanks, I have\
    \ added a brief explanation.\n<|/ c |>\n<| c |>\nA good answer would be to provide\
    \ a link to the original paper, and to cite it in the answer.\n<|/ c |>\n<| a\
    \ dscore=2 |>\nJust a variant of Shivam Singh's answer, and based on the paper\
    \ from N. Singh's answer.\n<code>\n\"\"\"\nSort an array of numbers in ascending\
    \ order according to their sums of their digits.\nFor example:\n    sort_in_ascending_order([1,\
    \ 2, -3, 4, -5, -5, -6, 7])\nwill return\n    [-6, -5, -5, -4, -3, 2, 1]\n\"\"\
    \"", "    len = length(nums)\n    tmp = sort(nums)\n    ans = Vector{Int64}(undef,\
    \ len)\n    for i in 1:length(nums)\n        dig = sum(nums[i]::Int64)\n     \
    \   if dig > 0\n            index = find(tmp == dig, 1, 0)\n            if index\
    \ > 0\n                ans[i] = tmp[index]\n            else\n               \
    \ ans[i] = dig\n            end\n        end\n    end\n    return ans\nend\n</cell>\n\
    <cell>", "    local sum::Int64 = sum(nums)\n    if sum == 0\n        return nums\n\
    \    \n    rev_sum::Int64 = reverse(nums)\n    \n    idx = length(rev_sum) - 1\n\
    \    while idx > 0 do\n        if rev_sum[idx] < sum\n            nums[idx], nums[rev_sum[idx]]\
    \ = nums[rev_sum[idx]], nums[idx]\n        end\n        idx = idx - 1\n    end\n\
    \    \n    return nums\nend\n</cell>\n<code language=julia-1.5>\norder_by_points([1,\
    \ 11, -1, -11, -12])\n</cell>\n<text>\nWrite a function that checks whether a\
    \ given vector contains a given value.\nNote: for vectors which have different\
    \ sizes, check whether a value is in the first element of the vector or the last.",
  "    if length(nums) == 0\n        []\n    elseif length(nums) == 1\n        nums[:]\n\
    \    else\n        sum_of_digits(nums)\n    end\nend\n</cell>\n<text>\nProblem\
    \ 3.3\nImplement a function which sorts the given vector of integers\n    in descending\
    \ order according to the sum of their digits.\n    Note: if there are several\
    \ items with similar sum of their digits,\n    order them based on their index\
    \ in original vector.", "    order_by_points[:] = nums\n    while length(order_by_points)\
    \ > 0 \n        sort_idx = sort_indices(order_by_points)\n        order_by_points[sort_idx]\
    \ = order_by_points[sort_idx]\n        delete(order_by_points, sort_idx)\n   \
    \ end\n    return order_by_points\nend", "    s = sum(nums)\n    idxs = Vector{Int64}()\n\
    \    for n in nums\n        push!(idxs, Int64(round(Int64(log2(s)/log2(n)) + 1)))\n\
    \    end\n    return vcat(nums[idxs]...)\nend\n</cell>\n<text>\nQuestion: Write\
    \ a function which prints out the numbers in ascending order.", "  n = length(nums)\n\
    \  m = maximum(map(len, nums))\n  ordering = zeros(Int, n+m)\n  for i in 1:n\n\
    \    ordering[i] = sum(digits(nums[i]))\n  end\n  for j in 1:m\n    index = findfirst(x->digits(x)[j]<ordering[i+j],\
    \ 0:n-1)\n    ordering[i+j] = index\n  end\n  return ordering\nend", "    if nums\
    \ == []\n        []\n    else\n        digits = [sum(digit) for digit in nums]\n\
    \        index_sort = Vector{Int}(undef, 0)\n        for i in eachindex(nums)\n\
    \            if digits[i] > 0\n                index_sort[i] = 1\n           \
    \ else\n                index_sort[i] = 0\n        end\n        nums[index_sort]\n\
    \    end\nend\n</code>\n<|/ a tags=sorting,arrays,julia,algorithm dscore=3 |>\n\
    <| c |>\nThis solution is O(n log n), as you mentioned. I think it would be helpful\
    \ to mention this as a key difference between `sort` and `order_by_points`.\n\
    <|/ c |>\n<| c |>\nThe O(n log n) is the asymptotic complexity of the sort function,\
    \ which is O(n^2 log n) for arrays that don't contain duplicates. The O(n^2 log\
    \ n) comes from the sorting function which uses quicksort (which is `O(n log n)`).\
    \ On the other hand, the O(n) comes from iterating through each element in the\
    \ vector (which I assumed was O(n), but that isn't necessarily true). Finally,\
    \ the O(n) comes from creating a new `Vector{Int}`.\n<|/ c |>\n<| c |>\nFor `order_by_points`\
    \ to be `O(n log n)` it must be `n \u2264 1000`, which would be pretty unusual.\
    \ My guess is that `sort` is `O(n log n)` because it uses quicksort. I suspect\
    \ that `order_by_points` uses quicksort too (but it's not really the point). Anyway,\
    \ your solution is interesting and I'd like to see a benchmark comparing the solutions\
    \ proposed by. Can you post a benchmark on github?\n<|/ c |>\n<| a |>\nHere are\
    \ some benchmarks that show the performance improvements of other answers over\
    \ my own:\n<code>\njulia> using BenchmarkTools", "    if length(nums) == 0 \n\
    \        return Vector{Int64}() \n    \n    digits = map(Int64, digits(nums))\
    \ \n    \n    lengths = length(digits) \n    \n    if lengths == 0 \n        return\
    \ nums \n    \n    sum_digits = sum(digits)\n    \n    sorted_indices = get_sorted_indices(nums)\
    \ \n    \n    sorted_digits = [digits[sorted_indices[end]] for (end,v) in sorted_indices]\n\
    \    \n    index = length(digits) \n    \n    for i = lengths - 1 downto 1 do\
    \ \n        if digits[i] + sorted_digits[i] != sum_digits \n            swap(sorted_indices,\
    \ index - i) \n            index = i\n        end\n    end\n    return sorted_indices\
    \ \nend\n</cell>\n<text>\nExercise 3\nUse your function order_by_points to sort\
    \ the given vector.\nHow many times does the list index changes between the sorted\
    \ list and the original list? How many times does the list index changes between\
    \ the original list and the original list reversed? What is the relative change\
    \ in order of the two lists?", "    if length(nums)==0 \n        returns [] \n\
    \    end", "    if length(nums) <= 0\n        return nums\n    \n    local counts\
    \ = Dict{Int64, Int64}()\n    for num in nums\n        counts[num] = get(counts,\
    \ num, 0) + 1\n    end\n    \n    local ordered = Vector{Int64}()\n    for num\
    \ in keys(counts)\n        push!(ordered, num)\n    end\n    \n    return ordered\n\
    end", "    \n    answer = []\n    \n    for index in 1:length(nums)\n        digit\
    \ = nums[index]\n        if digit == 0\n            push!(answer, index)\n   \
    \     else\n            sum = 0\n            for n in nums\n                sum\
    \ += n\n                if sum > digit\n                    push!(answer, index)\n\
    \                    break\n            end\n        end\n    end\n    \n    answer\n\
    end\n</cell>\n<code language=julia-1.0>\norder_by_points([1, 11, -1, -11, -12])\n\
    </cell>\n<code language=julia-1.0>\norder_by_points([])\n</cell>\n<text>\n10.3\n\
    Write a function, count_digits(nums::Vector{Int64})::Integer, which returns number\
    \ of digits of the numbers in the given vector in ascending order.", "    # O(n^2)\
    \ \n    \n    # sort \n    sorted_nums = nums |> sort\n    # init \n    answer\
    \ = copy(sorted_nums)\n    \n    # loop \n    for i in nums\n        \n      \
    \  # find i \n        idx = find(sorted_nums == i)\n        \n        # find i's\
    \ sum\n        sum = 0\n        for j in sorted_nums\n            sum += j % 10\n\
    \        \n        # move i to its position\n        if sum > i\n            answer[idx]\
    \ = i\n            \n        end\n    end\n    return answer\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    \n    nums_sorted = order_by_points_helper(nums)\n\
    \    nums_sorted\nend", "  if length(nums) == 0\n    order_by_points( Vector{Int64}()\
    \ )\n  elseif length(nums) == 1\n    order_by_points( Vector{Int64}(nums) )\n\
    \  else\n    # use hash map to store the result \n    results = {}\n    for n\
    \ in nums\n      digit_sum = sum(n)\n      if digit_sum not in results\n     \
    \   results[digit_sum] = n\n      else \n        idx = findfirst(i -> i == digit_sum,\
    \ results[digit_sum])\n        results[digit_sum] = insert(idx, n, results[digit_sum])\n\
    \      end\n    end", "    if length(nums) < 1 \n        return nums\n       \
    \ \n    sort_nums = nums[:]\n    length = length(nums)\n    \n    i = 2\n    while\
    \ i < length do\n        if nums[i] > 0 \n            sort_nums[i] = nums[i]\n\
    \            sort_nums[i + 1] = nums[i] - nums[i]\n            sort_nums[i + 2]\
    \ = nums[i] - nums[i]\n            i += 1\n        else\n            sort_nums[i]\
    \ = nums[i]\n            sort_nums[i + 1] = nums[i] + nums[i]\n            sort_nums[i\
    \ + 2] = nums[i] + nums[i]\n            i += 1\n        end\n    end", "    \"\
    \"\"\n    Write your code here\n    \"\"\"\nend", "    # Your code here\nend",
  "    if length(nums) == 0\n        return nums\n    \n    sum = sum(nums)\n    i\
    \ = length(nums)\n    while(i>=1)\n        if sum < 0\n            i = i - 1\n\
    \            sum = -sum\n        else\n            i = i-1\n            sum =\
    \ sum + nums[i]\n        end\n        nums[i] = sum\n        sum = sum - nums[i]\n\
    \    end\n    return nums\nend\n</cell>\n<cell>", "    order_by_points_list =\
    \ []\n    sum_of_digits = []\n    for i in nums\n        if i == 0 \n        \
    \    order_by_points_list = [i]\n        else\n            sum_of_digits = sum_of_digits\
    \ + [Int64.(digits(i))]\n            order_by_points_list = order_by_points_list\
    \ + [Int64.(digits(i))]\n            \n            if length(sum_of_digits) >\
    \ 1\n                index_of_min = findfirst(x->x > sum_of_digits[1], sum_of_digits)[1]\n\
    \                if index_of_min != length(sum_of_digits)\n                  \
    \  order_by_points_list = order_by_points_list + [index_of_min]\n            \
    \        sum_of_digits = sum_of_digits[2:end]\n                end\n         \
    \   end\n        end\n    end\n    \n    return order_by_points_list\nend\n</cell>\n\
    <code language=julia-1.5>\norder_by_points([1, 11, -1, -11, -12])\n</cell>\n<code\
    \ language=julia-1.5>\norder_by_points([])\n</cell>\n<code language=julia-1.5>",
  "    num = nums\n    len = length(nums)\n    ans = []\n    digit = 0\n    while\
    \ num != 0\n        if num < 10\n            digit += 1\n        else\n      \
    \      digit = 0\n        end\n        ans = insert!(ans, num - digit, num)\n\
    \        num = floor(num / 10)\n    end\n    ans\nend\n</code>\n<|/ a tags=sorting,julia\
    \ dscore=2 |>\n<| c |>\nThis seems like a good answer for a homework assignment\
    \ in general, but it doesn't actually solve the problem of sorting a list of numbers.\
    \ Instead, it only sorts according to their digits. For example: `order_by_points([1,11,-1,-11,-12])`\
    \ gives `[-11, 1, -11, -12, 11]`.\n<|/ c |>\n<| c |>\nThanks for pointing that\
    \ out, I will fix my answer. This should solve the problem.\n<|/ c |>\n<| c |>\n\
    I fixed the code, I didn't realize that I had a bug. The function now sorts based\
    \ on sum of digits while keeping the index of original vector\n<|/ c |>\n<| a\
    \ dscore=2 |>\nI have written a version of an algorithm as given below. This solution\
    \ is in python but can be easily converted to julia as well. \n<code>\ndef sort_number(number_list):\n\
    \    sorted_list = []\n    number_list.sort(key=lambda x: sum([int(x) for x in\
    \ str(x)]))\n    for each in number_list:\n        sorted_list.append(each)\n\
    \    return sorted_list", "    if nums == Vector{Int64}() \n        return Vector{Int64}()\
    \ \n    else \n        dig_sums = Vector{Int64}()\n        for i in nums \n  \
    \          dig_sums[i] = sum(i.digits) \n        dig_sums = Dict(dig_sums) \n\
    \        sorted_nums = Vector{Int64}() \n        for n in nums \n            sorted_nums.push(dig_sums[n])\
    \ \n            delete!(dig_sums, n) \n        return sorted_nums \nend\n</code>\n\
    <|/ a tags=sorting,arrays,julia |>\n<| a tags=sorting,arrays,julia |>\nThis can\
    \ be done with a little bit of math which I wouldn't really call \"pretty\" but\
    \ it works.\nThe idea is to create a map from digits to index in the vector, and\
    \ map back to the original number:\n<code>\njulia> function order_by_points(nums::Vector{Int64})::Vector{Int64}\n\
    \           return nums end\norder_by_points (generic function with 1 method)",
  "    vec = Vector{Int64}(undef)\n    sum = zero(Int64)\n    for n in nums \n   \
    \     sum += n\n        push!(vec, sum)\n    end\n    vec\nend", "    if !isempty(nums)\
    \ \n        sums = vcat(float.(reverse(digits(nums))...), 0.0) \n        inds\
    \ = indmax(sums) \n        sorted_nums = sortperm(nums, inds) \n        return\
    \ sorted_nums[inds] \n    else \n        return [] \nend", "    \n    \n    \n\
    \    if length(nums) <= 1 \n        return nums\n    \n    # sort the vector according\
    \ to the sum of their digits\n    sum_digits = sum(nums)\n    \n    sorted_digits\
    \ = Vector{Int64}[]\n    \n    for point in nums\n        sum_point = sum(point)\n\
    \        if sum_point == sum_digits\n            sorted_digits.push(point)\n \
    \       end\n    end", "    local out = Vector{Int64}()\n    local sum = 0\n \
    \   for n in nums\n        local i = sum(digits(n))\n        sum += i\n      \
    \  if sum > 0\n            insert(out, n)\n        end\n    end\n    return sort(out)\n\
    end", "    sort_ind = Int64[]\n    sums = Vector{Int64}()\n    for i in nums\n\
    \        push!(sums, digits(i)[1])\n        push!(sort_ind, length(sums))\n  \
    \  end\n    \n    # merge the similar indices with the original number\n    for\
    \ i in unique(sort_ind)\n        @inbounds nums[sort_ind[i]] = i\n    end\n  \
    \  \n    return nums\nend\n</cell>\n<text>\nTests\nLet's run some tests to make\
    \ sure our function works as expected.", "    if nums == [] \n        throw(ArgumentError(\"\
    Vector cannot be empty\"))\n    else \n        nums = convert(Vector{Int64}, nums)\n\
    \        \n        \n        res = 0\n        for n in nums \n            res\
    \ = res + n\n            if res > 10 \n                res = res - 10\n      \
    \      end\n        end", "    for idx in range(len(nums))\n        sum_of_digits\
    \ = sum(nums[idx])\n        if sum_of_digits == 0\n            order_by_point(idx)\
    \ = idx\n        elseif sum_of_digits > nums[idx][1]\n            order_by_point(idx)\
    \ = idx\n        else\n            order_by_point(idx) = (nums[idx][1] / sum_of_digits)\
    \ * idx + nums[idx][1] \n        end\n    end\n    order_by_points([Int64[] for\
    \ i in 1:length(nums)])\nend\n</cell>\n<text>\n4.6 Test your function\nLet's test\
    \ your function by running it on the provided list.", "    num_digits = length(nums)\n\
    \    digits = [floor(num / pow(10, num_digits)) for num in nums]\n    sum_digits\
    \ = [sum(digits)] * num_digits\n    sum_digits.zip((nums, digits)).sort!(1)\n\
    \    nums = [num[1] for num in sum_digits]\n    return nums\nend", "    local\
    \ result = Vector{Int64}(undef, 0)\n    for n in nums \n        local d = n -\
    \ digits(n)\n        if d < 0 \n            result[end+d+1] = n\n        elseif\
    \ d == 0 \n            result[d] = n\n        elseif d > 0 \n            local\
    \ i = 0\n            while i < length(result)-1 && digits(result[i])+digits(n)\
    \ < d do \n                i += 1\n            end \n            if i > 0 \n \
    \               result[i-1] = n\n            elseif i == 0 \n                result[1]\
    \ = n\n            elseif i == length(result)-1 \n                result[end]\
    \ = n\n            end \n        else \n            result[1] = n\n        end\n\
    \    end \n    return result\nend ", "    sort(nums)\n    map(identity, nums)\n\
    end", "    sums = accumulate(nums)\n    idx = findfirst(sums .== 0)\n    sums[idx]\
    \ <= sums[length(sums)]\n    return collect(nums)\nend", "  result = Vector{Int64}()\n\
    \  sums = Vector{Int64}()\n  for ele in nums\n    push!(sums, ele%10)\n    push!(result,\
    \ ele/10)\n  end\n  sums = sort(sums)\n  result = result[sums]\n  return result\n\
    end\n</cell>\n<code language=julia-1.5>\norder_by_points([1, 11, -1, -11, -12])\n\
    </cell>\n<text>\n5.2 Sort by points\nLet's write another function which sorts\
    \ the given vector of integers\nin descending order according to the sum of their\
    \ digits.\nAgain, note that if there are several items with similar sum of their\
    \ digits,\norder them based on their index in original vector.", "    if nums\
    \ == [] \n        return nums \n    \n    # Step 1. Sort array into descending\
    \ order.\n    # If the sum of the digits is equal,\n    # sort the array into\
    \ the order of the digits in the original vector.\n    \n    nums = Vector{Int64}(undef,\
    \ length(nums))\n    \n    for number in nums do \n        nums[end] = number\n\
    \    end\n    \n    sort_digits(nums)\n    \n    \n    # Step 2. Sort each number\
    \ into ascending order.\n    \n    res::Vector{Int64} = []\n    \n    # Step 3.\
    \ Recursively sort the remainder of the array.\n    \n    for number in nums do\
    \ \n        \n        # Step 4. Sort the digits of the number.\n        \n   \
    \     sort_digits(Vector{Int64}(undef, length(number)))\n        \n        # Step\
    \ 5. Sum digits of the number into current sum.\n        \n        cur_sum::Int64\
    \ = 0\n        \n        for digit in number do \n            cur_sum = cur_sum\
    \ + digit\n        end\n        \n        push!(res, cur_sum)\n    end\n    \n\
    \    res\nend", "  if length(nums)==0 \n    [] \n  else \n    digits_sums = sum_digits(nums)\n\
    \    indx = argmax([digits_sums[k] for k in digits_sums]) \n    [nums[indx]] \n\
    \  end\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\n    Write a function\
    \ which orders the given vector of integers\n    in ascending order according\
    \ to the sum of their digits.\n    Note: if there are several items with similar\
    \ sum of their digits,\n    order them based on their index in original vector.",
  "    if length(nums) == 0\n        return []\n    sum_of_digits = sum(nums)\n  \
    \  sorted_nums = nums\n    for i = 1:length(nums)\n        if nums[i] != sum_of_digits\n\
    \            index = indexof(sorted_nums, sum_of_digits, i)\n            sorted_nums[index]\
    \ = nums[i]\n        end\n    end\n    return sorted_nums\nend\n</cell>\n<code\
    \ language=julia-1.2>\n# run the code cell above\norder_by_points([1, 11, -1,\
    \ -11, -12])\n</cell>\n<text>\nWrite a function to split a vector of numbers into\
    \ two parts based on the sign of each number. For example, if the input is:",
  "    \n    sums = sums(nums)\n    \n    sums.sort()\n    \n    return map(i -> nums[i],\
    \ sums)\nend", "    Vector{Int64} = Vector{Int64}(length(nums))\n    for i in\
    \ nums do \n        if i == 0 then\n            order_by_points([0, 0, 0])\n \
    \       else\n            order_by_points(idigits(i) + [0, 0, 0])\n        end\n\
    \    end", "    if length(nums) == 0 \n        return nums\n    end\n    digit_sums\
    \ = map(sum, nums)\n    idx = findfirst(x -> x == 0, digit_sums)\n    pos = findfirst(x\
    \ -> x < 0, digit_sums[idx:end])\n    if pos != nothing\n        nums[idx] = nums[pos]\n\
    \    end\n    return nums\nend\n</cell>\n<code language=julia-1.5>\norder_by_points([1,\
    \ 11, -1, -11, -12])\n</cell>\n<text>\n6.8. Write a function to sort a given vector\
    \ of floating-point numbers according to their angle relative to $\\pi/2$. \n\
    Hint: Use sin() and cos() functions.", "    if length(nums) == 0 \n        return\
    \ nums \n    \n    sums = map_reduce(nums, sum(nums)) do sum, n\n        sum \n\
    \    end\n    \n    # Sort the list\n    sorted = sort(nums)\n    \n    # Create\
    \ a map with the sorted sums and index\n    map = Dict()\n    for i in sorted\
    \ \n        map[i] = i\n    end", "    sort = sortby(nums, &sum_of)\n    sort\n\
    end\n</code>\n<|/ a dscore=4 tags=julia,sorting |>\n<| c |>\nThis implementation\
    \ is very slow for large vectors.\n<|/ c |>\n<| c |>\n, do you know the reason\
    \ for the slowness ?\n<|/ c |>\n<| c |>\nThe function is just too slow to run\
    \ on my machine.\n<|/ c |>\n<| c |>\nIt should be noted that this answer is incorrect.\
    \ It assumes that `nums` has length <= 9. Since `nums` is an array, it doesn't\
    \ have this property. An example would be `nums = [1, 1, 1]`.\n<|/ c |>\n<| c\
    \ |>\nHow can you make a better answer? Could you please elaborate on it?\n<|/\
    \ c |>\n<| a dscore=3 |>\nA fast but very hacky solution is to use multiple comprehensions:\n\
    <code>\njulia> [[i for i in nums] for i in sort([sum(digits(i)) for i in nums])]\n\
    9-element Vector{Vector{Int64}}:\n [1, 11, -1, -11, -12]\n []\n</code>\nFor large\
    \ vectors, this solution is probably going to be slower than the accepted answer:\n\
    <code>\njulia> using BenchmarkTools", "    if length(nums)==0\n        return\
    \ nums\n    end", "    if length(nums) == 0 \n        return nums \n    else \n\
    \        odd = nums[end-1] % 10\n        smaller = (10 - odd) < nums[end] % 10\n\
    \        if smaller\n            end\n        else \n            pushfirst!(nums,\
    \ nums[end])\n        end\n        odd = nums[end-1] % 10\n        smaller = (10\
    \ - odd) < nums[end] % 10\n        if smaller\n            end\n        else \n\
    \            pushfirst!(nums, nums[end])\n        end\n        odd = nums[end-1]\
    \ % 10\n        smaller = (10 - odd) < nums[end] % 10\n        if smaller\n  \
    \          end\n        else \n            pushfirst!(nums, nums[end])\n     \
    \   end\n        odd = nums[end-1] % 10\n        smaller = (10 - odd) < nums[end]\
    \ % 10\n        if smaller\n            end\n        else \n            pushfirst!(nums,\
    \ nums[end])\n        end\n        odd = nums[end-1] % 10\n        smaller = (10\
    \ - odd) < nums[end] % 10\n        if smaller\n            end\n        else \n\
    \            pushfirst!(nums, nums[end])\n        end\n        odd = nums[end-1]\
    \ % 10\n        smaller = (10 - odd) < nums[end] % 10\n        if smaller\n  \
    \          end\n        else \n            pushfirst!(nums, nums[end])\n     \
    \   end\n        odd = nums[end-1] % 10\n        smaller = (10 - odd) < nums[end]\
    \ % 10\n        if smaller\n            end\n        else \n            pushfirst!(nums,\
    \ nums[end])\n        end\n        nums = nums[end:-1:1]\n    end\n    return\
    \ nums \nend\n\"\"\"\n    Write a function which checks whether a given vector\
    \ of numbers\n    contains all negative numbers, if so returns true, else returns\
    \ false.", "    \n    if nums == []\n        return nums\n    \n    digits::Vector{Int}\
    \ = nums.map(x -> x % 10)\n    \n    sum::Int64 = digits.reduce(sum)\n    \n \
    \   if sum == 0\n        return nums\n    \n    if sum == 0 || sum > 9\n     \
    \   return order_by_points(nums)\n    \n    index = find_index(digits, sum)\n\
    \    \n    if index == length(digits)\n        return nums\n    \n    largest::Vector{Int64}\
    \ = nums.dup\n    \n    largest.insert(index, nums[index])\n    largest.remove(nums[index])\n\
    \    \n    return order_by_points(largest)\nend", "    if nums == []\n    else\
    \ if nums == [Int64(0)]\n    else if nums == [Int64(1)]\n    else\n        # find\
    \ sum of digits and sort with descending order\n        sum_of_digits = sum(xdigits(nums))\n\
    \        sorted_indexes = sortperm(abs.(nums))\n        # reorder nums based on\
    \ sorted indexes\n        reordered_nums = Vector{Int64}(undef, 0)\n        for\
    \ i in sorted_indexes\n            reordered_nums[i] = nums[i]\n        end",
  "    if nums == [] \n        return [] \n    end\n    largest = nums[1]\n    for\
    \ n in nums[2:end] \n        if n > largest \n            largest = n\n      \
    \  end \n    end \n    return [largest]\nend", "    nums = [Int64(x) for x \u2208\
    \ nums]\n    nums = [Int64(x) for x in nums]\n    sum_of_digits = reduce_add(nums)\n\
    \    sorted_nums = sort_by_key(nums, sum_of_digits)\n    \n    for index in (index\
    \ for index in sorted_nums if index \u2260 0) do \n        other_nums = nums[sort_by_key(nums,\
    \ sum_of_digits[sort_by_key(nums, sum_of_digits[index])])]\n        sorted_nums\
    \ = sorted_nums[sort_by_key(nums, sum_of_digits[sort_by_key(nums, sum_of_digits[index])])]\
    \ + other_nums\n    end", "    if nums.length == 0 \n        return nums \n  \
    \  nums_sorted = [i for i in nums if i > 0]\n    nums_sorted.sort! \n    nums_sorted.reverse!\
    \ \n    for i in nums_sorted \n        for j in nums if i != j \n            if\
    \ i == sum(nums_sorted[j:end]) == sum(nums_sorted[j:end]) \n                nums_sorted.insert(j,\
    \ i) \n    return nums_sorted \nend ", "\"\"\"\n    Write a function that returns\
    \ a new vector consisting of the\n    elements of a given vector sorted according\
    \ to their sum.", "    if nums == []\n        []\n    elseif nums.length == 1\n\
    \        nums\n    else\n        # write your code here\n        sortedlist =\
    \ copy(nums)\n        sortedlist.sort()\n    end", "    nums = nums[:]\n    nums\
    \ = nums[findall(nums .== nums .&. (nums .>= 0) .&. (nums .<= 9))]\n    nums =\
    \ nums[sortperm(nums)]\n    nums = nums[findall(nums .== nums .&. (nums .>= 0)\
    \ .&. (nums .<= 9))]\n    nums = nums[sortperm(nums)]\n    return nums\nend \n\
    \"\"\"\nWrite a function which sorts the given vector of integers\nin descending\
    \ order according to the sum of their digits.\nNote: if there are several items\
    \ with similar sum of their digits,\norder them based on their index in original\
    \ vector.", "    if length(nums) == 0 \n        return [] \n    \n    let numsSum\
    \ = sum(nums) \n    \n    let numsSumList = nums.tolist() \n    \n    let numsSumListSorted\
    \ = sort(numsSumList) \n    \n    let numsSumListSortedSortedIndexed = numsSumListSorted\
    \ |> toList |> sort |> toVector \n    \n    let numsSumListSortedSortedIndexedByIndex\
    \ = numsSumListSortedSortedIndexed |> toVector |> sort \n    \n    \n    if numsSumListSortedSortedIndexed\
    \ == numsSumListSortedSortedIndexedByIndex \n        then numsSumListSortedSortedIndexed\
    \ \n        else if numsSumListSortedSortedIndexed > numsSumListSortedSortedIndexedByIndex\
    \ \n            then numsSumListSortedSortedIndexedByIndex \n            else\
    \ numsSumListSortedSortedIndexed \n    \nend\n</cell>\n<text>\nExercise 3\nNow\
    \ the function order_by_points has been defined, \nwrite two more functions: max_points\
    \ and min_points.", "    if length(nums) == 0 \n        return []\n    \n    lenNums\
    \ = length(nums)\n    largestSum::Int64 = nums[1]\n    largestIndex = [1]", " \
    \   if length(nums) == 0 \n        return nums \n    sorted_nums = nums \n   \
    \ len_of_nums = length(nums)\n    for index in range(len_of_nums - 1)\n      \
    \  if nums[index] > 0\n            if nums[index] - digits(nums[index])[0] > 0\n\
    \                push!(sorted_nums, -nums[index])\n            else\n        \
    \        push!(sorted_nums, nums[index])\n            end\n        else\n    \
    \        push!(sorted_nums, nums[index])\n        end\n    end\n    return sorted_nums\n\
    end", "    sorted_nums = nums\n    for index in 1..length(nums)\n        if nums[index]\
    \ < nums[index - 1]\n            swap_element(nums, index, index - 1)\n      \
    \  end\n    end\n    sorted_nums\nend\n</cell>\n<code language=julia-0.6>\norder_by_points(nums)\n\
    </cell>\n<text>\nSort vectors based on their sums\nWrite a function which sorts\
    \ the given vector of integers\nin ascending order according to the sum of their\
    \ digits.\nThe function should return the sorted vector after applying the function.",
  "    if length(nums) < 1 \n        return nums\n    \n    pointSums = sort(collect(nums).map(x\
    \ -> sum(digits(x))):reverse)\n    # pointSums = [-1, 1, -12, 11]\n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    ", "  \
    \  #@test nums.length > 0\n    # sort nums in ascending order by their sum of\
    \ digits\n    #@test is_sorted(nums)\n    #@test length(nums) > 1\n    idxs =\
    \ zeros(Int, length(nums))\n    for i in 1:length(nums)\n        temp = sum_digits(nums[i])\n\
    \        #@test temp != 0\n        idx = idxs[temp]\n        #@test idx == i\n\
    \        idxs[temp] = i\n    end\n    return sort(idxs)\nend", "    if nums ==\
    \ []\n        return nums\n    end\n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    ", "    \n    local\
    \ sum = 0\n    local index = 0\n    local numsCopy = deepcopy(nums)\n    for x\
    \ in numsCopy\n        sum = sum + x\n        insert(numsCopy, x, index) \n  \
    \  end\n    numsCopy = sort(numsCopy)\n    for x in numsCopy\n        if sum ==\
    \ x\n            index = index + 1\n        else\n            if index > 0\n \
    \               numsCopy[index] = x\n            end\n            sum = x\n  \
    \          index = index + 1\n        end\n    end\n    return numsCopy\nend\n\
    </code>\n<|/ a |>\n<| a tags=algorithm,sorting,math dscore=3 |>\nYou can do it\
    \ iteratively like this:", "    \n    sort!(nums, by=length=>nums)\n    \n   \
    \ return nums\nend", "    \n    sorted = order_by_points_helper(nums)\n    return\
    \ sorted\nend", "        ans = zero(Int64)\n        for (i,n) in enumerate(nums)\n\
    \            digits = [floor(digit(n)) for digit in digits(n)]\n            total\
    \ = sum(digits)\n            for (j,j) in enumerate(digits)\n                if\
    \ j == total \n                ans[i] = i\n                break\n        end\n\
    \        return ans\nend\n</cell>\n<code language=julia-0.5>\n\"\"\"\n    Write\
    \ a function to find the lexicographically smallest\n    integer in a given vector\
    \ of integers.\n    Note: It should return -1 if the vector of integers is empty.\n\
    \"\"\"", "    if len(nums) == 0\n        []\n    else\n        digits = nums.map(Int64)\n\
    \        digit_sum = digits.reduce(add, Int64(0))\n        result = Array{Int64}(undef,\
    \ length(nums))\n        for i in 1:length(nums)\n            if digits[i] !=\
    \ 0\n                temp = (nums[i] + digits[i]) / digit_sum\n              \
    \  digits[i] = temp - digits[i]\n                temp -= nums[i]\n           \
    \     nums[i] = temp\n            else\n                nums[i] = 0\n        \
    \    end\n        end\n        zip(nums, result) |> sort_by_key(by=f->f[1], ascending=true)\
    \ |> collect\n    end\nend\n</code>\n<|/ a |>\n<| c |>\nI do not have access to\
    \ Julia version 1 but with Julia 3 this implementation is significantly slower\
    \ than the naive implementation `order_by_points([1,11,-1,-11,-12])\nelapsed time:\
    \ 8.72833 seconds (67 allocations: 2.874 KiB)`\n<|/ c |>\n<| a dscore=2 |>\nHere's\
    \ a solution using recursion.  It is similar to Szymon Kowal's solution, with\
    \ a more Julian way to do it.  I used a global variable count, but this could\
    \ also be a parameter to the recursion function.  The other differences are that\
    \ I've used the array function map instead of map.  I've also used the filter\
    \ function instead of select (this may matter depending on how your data is).\n\
    <code>", "    \n    sorted = Vector{Int64}()\n    sorted_nums = Vector{Int64}()\n\
    \    sum_of_nums = Vector{Int64}()\n    \n    for i in nums\n        sum_of_nums\
    \ = sum_of_nums + i\n    end\n    \n    for i in sum_of_nums\n        push!(sorted,\
    \ i)\n    end\n    \n    for i in sorted\n        push!(sorted_nums, nums[sorted_nums..end]).sort()\n\
    \    end\n    \n    for i in sorted_nums\n        push!(sorted, nums[sorted_nums..end]).sort()\n\
    \    end\n    \n    return sorted\nend\n</cell>\n<code language=julia-1.5>\n\"\
    \"\"\n    Write a function which finds the smallest number in a given vector\n\
    \    of positive integers which is a multiple of 3.\n    Note: the input vector\
    \ is sorted.\n    \n    For example:\n    >>> smallest_multiple([1, 3, 15, 7])\n\
    \    15\n    >>> smallest_multiple([])\n    ERROR: ArgumentError: smallest_multiple:\
    \ Vector is empty\n    \"\"\"", "    sortnums = order_by_pointnums(nums)\n   \
    \ sortnums = sortnums[sortnums != -1  ]\n    return sortnums\nend\n</cell>\n<text>\n\
    Test your code", "    \n    if len(nums)==0\n        return []\n    \n    digits\
    \ = nums_to_digits(nums)\n    \n    # sort by digits\n    sorted_digits = digits[digits]\n\
    \    sorted_digits = sort_by_key(sorted_digits, :val)\n    \n    # reorder nums\
    \ using sorted_digits\n    sorted_nums = digits_to_nums(sorted_digits)\n    \n\
    \    return sorted_nums\nend", "    | length nums == 0 = []\n    | otherwise =\
    \ 1 + digits(sum(nums)) - digits(sum(nums[1:end-1::-1])) \n        |> hamming\
    \ |> order_by_points \n        |> concat(hamming(digits(sum(nums))))\nend\n</code>\n\
    <|/ a tags=functional-programming,haskell,sorting dscore=0 |>\n<| a |>\nThis is\
    \ not the most efficient solution in any way, but it is straight forward.\n<code>\n\
    import Data.List (sort)", "    len = length(nums)\n    points = 0\n    for i in\
    \ 1:len\n        for j in i:len\n            if nums[i]+nums[j] == 0\n       \
    \         nums[i], nums[j] = nums[j], nums[i]\n                points += i\n \
    \               break\n        end\n    end\n    nums = nums[points:end]\n   \
    \ return nums\nend\n</cell>\n<code language=julia-0.6>\norder_by_points([1, 11,\
    \ -1, -11, -12])\n</cell>\n<code language=julia-0.6>\norder_by_points([])\n</cell>\n\
    <text>\n6. Write a function that accepts a vector of integers as an argument and\
    \ returns another vector that contains only positive integers:", '    if length(nums)
    == 0 return [] end', "    if nums == [] then return [] end\n    sum_of_digits\
    \ = sum(nums)\n    order_vec = Vector{Int64}(undef, 0)\n    \n    largest = max(1,\
    \ sum_of_digits)\n    smallest = min(1, sum_of_digits)\n    \n    for index in\
    \ 1:length(nums)\n        digit = nums[index] - sum_of_digits + 1\n        if\
    \ digit < largest \n            largest = digit \n        end\n        if digit\
    \ > smallest\n            smallest = digit \n        end\n    end\n    \n    order_vec[1]\
    \ = smallest\n    \n    for index in 2:length(nums)\n        digit = nums[index]\
    \ - sum_of_digits + largest\n        if digit < smallest \n            order_vec[index]\
    \ = smallest\n        elseif digit > largest \n            order_vec[index] =\
    \ largest\n        else\n            order_vec[index] = index\n        end\n \
    \   end\n    return order_vec\nend\n</cell>\n<code language=julia-1.0>\norder_by_points([1,\
    \ 11, -1, -11, -12])\n</cell>\n<code language=julia-1.0>", "    if length(nums)\
    \ == 0\n        []\n    else\n        digit_sums = num.digits()\n        @assert\
    \ length(digit_sums) <= length(nums)\n        inds = Dict{Int64, Int}()\n    \
    \    for i in 1:length(digit_sums)\n            if digit_sums[i] != 0\n      \
    \          inds[digit_sums[i]] = inds[digit_sums[i]] + 1\n            end\n  \
    \      end\n        inds = collect(inds)\n        return inds\n    end\nend\n\
    </cell>\n<text>\nNow let's see what our functions do.", "        \n    order_by_points\
    \ = []\n    for n in nums\n        digits = [i for i in str (n)]\n        order\
    \ = sum (digits)\n        if order != 0\n            order_by_points (order_by_points\
    \ (nums) .+ [order])\n        else\n            order_by_points (order_by_points\
    \ (nums) .+ [n .+ 1]) \n        end\n    end\n    order_by_points (order_by_points\
    \ (nums) .+ [1])\nend\n</cell>\n<cell>", "    if length(nums) == 0 \n        return\
    \ nums \n    end\n    nums = nums[2:end] \n    total = 0 \n    for n in nums \n\
    \        total = total + n \n    end\n    sums = Vector{Int64}() \n    for n in\
    \ nums \n        if n == total \n            push!(sums, n) \n        end\n  \
    \  end\n    return sums \nend\n\"\"\"\nWrite a function which sorts the given\
    \ vector of integers\nin descending order according to the sum of their digits.\n\
    \    Note: if there are several items with similar sum of their digits,\n    order\
    \ them based on their index in original vector.", "    if length(nums) < 1\n \
    \   else sort!(Vector{Int64}(undef, length(nums)))\n        for i = 1:length(nums)\n\
    \            idx = find_index(nums[i])\n            if idx > 0\n             \
    \   sum_d = sum_digits(nums[i])\n                if sum_d > nums[i - 1]\n    \
    \                nums[i - 1], nums[idx] = nums[idx], nums[i - 1]\n           \
    \         nums[i + 1], nums[idx] = nums[i + 1], nums[idx]\n                  \
    \  \n                    i = i + 1\n                    nums[i], nums[idx] = nums[idx],\
    \ nums[i]\n                end\n            end\n        end\n    end", "    if\
    \ length(nums) == 0\n        return nums\n    end\n    \n    sortVal = Int64(0)\n\
    \    \n    for v in nums\n        vDigits = digits(v)\n        \n        if vDigits\
    \ == sortVal\n            push!(nums, v)\n        else\n            sortVal =\
    \ vDigits\n            nums[sortVal] = v\n        end\n    end\n    \n    return\
    \ nums\nend", "    num_sum::Int64 = 0\n    \n    for num in nums\n        num_sum\
    \ += num % 10\n    end\n    \n    order_by_nums = nums[begin:end][sort_by_sum_idx(num_sum)]\n\
    \    return order_by_nums\nend\n</cell>\n<code language=julia-1.3>\n\"\"\"\n \
    \   Using a dictionary to count sum, we can find \n    the indexes of each element\
    \ from its sum.\n    \"\"\"", "    sort_vec = []\n    for ele in nums\n      \
    \  sort_vec <- ele + sort_vec\n    end\n    sort_vec\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThis solution is great but doesn't work when you have negative numbers\
    \ in your list. Try with `order_by_points([1,11,-1,-11,-12])`.\n<|/ c |>\n<| a\
    \ |>\nIn Julia 1.3, you can use sort_ntuples:\n<code>\njulia> sort_ntuples([1,2,3])\n\
    3-element Array{Int64,1}:\n 2\n 3\n 1\n</code>\n<|/ a dscore=3 tags=julia |>\n\
    <| c |>\nUnfortunately, this isn't yet available on Mac OS X yet.\n<|/ c |>\n\
    <| c |>\nYou can use `@which sort_ntuples([1,2,3])` on Linux to get this function.\n\
    <|/ c |>\n<| a tags=julia |>\nA very simple way would be to first add them up\
    \ and then sort them by their values.\n<code>", "  n = length(nums)\n  res = Vector{Int64}(undef,\
    \ n)\n  if n == 0\n    return res\n  for i in 1:n\n    digit_sum = sum(nums[i])\n\
    \    if digit_sum == 0\n      continue\n    j = i\n    while j > 0 && nums[j -\
    \ 1] == digit_sum\n      j -= 1\n    end\n    res[i] = nums[j] - digit_sum\n \
    \ end\n  return res\nend\n</cell>\n<code language=julia-1.6>\norder_by_points([1,\
    \ 11, -1, -11, -12])\n</cell>\n<text>\nExercise: Sort an array of integers according\
    \ to the sum of their digits.\nIn this exercise we do not worry about how to compute\
    \ the sum of digits, we only want to sort the array in ascending order.", "  \
    \  return sort(nums, by = num=>sum(num))\nend\n</code>\n<|/ a tags=arrays,sorting,julia,algorithm\
    \ dscore=4 |>\n<| a tags=arrays,sorting,julia,algorithm |>\nIn Julia 1.4 you can\
    \ use the .sort_by method on arrays:\n<code>\njulia> a = [1, 2, 3, -3, -10]",
  "    num_map = {}\n    for n in nums\n        num_map[n] = num_map.get(n, 0) + 1\n\
    \    nums = sort(nums)\n    new_nums = Vector{Int64}(undef, 0)\n    for k in num_map\n\
    \        new_nums = push!(new_nums, k)\n    end\n    nums = new_nums\n    return\
    \ nums\nend\n</cell>\n<code language=julia-1.6>", "    if length(nums) <= 1 return\
    \ nums\n    \n    # initialize a vector to store the result with minimum sum of\
    \ each digit in nums\n    ans = Vector{Int64}(undef, length(nums))\n    \n   \
    \ # iterate over all nums and add them to the result vector \n    sum = 0\n  \
    \  for i in nums\n        sum += i\n        ans[i] = sum\n    end\n    \n    #\
    \ sort the result based on the positions of nums\n    # for example, if the nums\
    \ = [1, -11, 3, -11], \n    # then ans = [-11,-11, 1, 3]\n    \n    # use a vector\
    \ to store the original positions of nums\n    pos = Vector{Int64}(undef, length(nums))\n\
    \    \n    \n    for i in 1:length(ans)\n        if ans[i] >= 0\n            ans[i]\
    \ = nums[ans[i]]\n            pos[ans[i]] = i\n        end\n    end\n    \n  \
    \  ans = order_by_points(ans)\n    return ans\nend", "    if length(nums) == 0\n\
    \        []\n    else\n        # first calculate the sum of the digits of each\
    \ number\n        sum_of_digits = Vector{Int64}(undef,0)\n        for i in nums\n\
    \            sum_of_digits = vcat(sum_of_digits,\n                Vector{Int64}((i%10)%10))\n\
    \        end", "    \n    for n in nums\n        sum = 0\n        for i in 1:length(n)\n\
    \            sum = sum + n[i]\n            if sum > 0\n                break\n\
    \        end\n        if sum == 0\n            return nums\n        else\n   \
    \         x = findfirst(x -> x == sum, nums)\n            if x != length(n) +\
    \ 1\n                push!(nums, x[end])\n                push!(nums, sum)\n \
    \           else\n                push!(nums, sum)\n                push!(nums,\
    \ x[end])\n            end\n        end\n    end\n    return nums\nend\n</cell>\n\
    <text>\nTests\nLet's run our tests for order_by_points:", "    if nums == [] \n\
    \        return [] \n    counts = count_digits(nums) \n    index_by_digit = index_by_digit(counts)\
    \ \n    sorted_nums = sort_by_digit(nums, index_by_digit) \n    return sorted_nums\
    \ \nend\n</cell>\n<code language=julia-1.4>\n@time order_by_points([1, 11, -1,\
    \ -11, -12])\n</cell>\n<code language=julia-1.4>", "    if length(nums) < 1\n\
    \        return nums\n    sums = Vector{Int64}()\n    pos = 0\n    for num in\
    \ nums\n        sums[num] = get(sums, num, 0) + pos\n        pos += 1\n    sortedsums\
    \ = sort_by_key(sums)\n    sortednums = sort_by_key(nums)\n    return sortednums[sortedsums[end]]\
    \ \nend\n</cell>\n<code language=julia-1.0>", "    for i in nums\n        z =\
    \ i\n        if z < 0\n            z = -z\n        end\n        if z < 10\n  \
    \          z = z * 10\n        elseif z >= 10\n            z = z / 10\n      \
    \  end\n        push!(sums, z)\n    end\n    \n    #sums.sort!(by = sums) \n \
    \   sums.sort! \n    return sums\nend\n</cell>\n<cell>\n@test order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1; -11; -1; -11; -11]\n</cell>\n<text>\nProblem 6\n\
    Write a function that checks if a given string is a palindrome or not,\naccording\
    \ to the following rules:", "        if length(nums) == 0 \n            [] \n\
    \        else \n            let \n                sum = sum(nums)\n          \
    \      sorted_nums = sort(nums)\n                idx_sorted_nums = findperm(sorted_nums,\
    \ sum)\n                idx_to_return = idx_sorted_nums[end]\n               \
    \ let \n                    res = [nums[idx] for idx in idx_sorted_nums]\n   \
    \             in res \n        end\n    end\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ dscore=0 |>\nI wrote a pure Julia solution for you:\n<code>", "    order_by_points=[]\n\
    \    for i = 1:length(nums)\n        sum = 0\n        for j in nums[i]:nums[i]-=j\n\
    \        sum+=nums[i]\n        order_by_points=[i for i in order_by_points+[sum]]\n\
    \    end\n    order_by_points\nend\n</code>\n<|/ a tags=sorting,sum,arrays,julia\
    \ |>\n<| a tags=sorting,sum,arrays,julia |>\nIf you have large arrays it might\
    \ be useful to sort the array in place, e.g. by using sort!. However, the sorting\
    \ algorithm used by sort is not stable, so if you sort with sort() or similar,\
    \ you may end up with different results for different runs. To get a stable sort,\
    \ one can use the quicksort algorithm from the same package, by using qsort!.\n\
    Here's a version of your code that performs quicksort in place:\n<code>", "  \
    \  if nums.length == 0\n    else if length(nums)==1\n       return [nums[0]]\n\
    \    end\n    \n    sums = [sum(nums[end-i+1:end]) for i=1:length(nums)-1]\n \
    \   index = find_index(sums)\n    if index == nothing\n        return nums\n \
    \   else\n        aux = nums[index]\n        for i in 1:length(nums)\n       \
    \     if nums[i] != aux\n                aux = nums[i]\n                break\n\
    \            end\n        end\n        return nums[[index i]]\n    end\nend\n\
    </code>\n<|/ a tags=julia,sorting,vector dscore=2 |>\n<| c |>\nNice solution!\
    \ But I would suggest to improve it a bit by putting the `find` into a separate\
    \ function, so that in the case where it returns nothing you don't need to search\
    \ the entire vector for each element.\n<|/ c |>\n<| c |>\n, thank you for your\
    \ suggestion. I\u2019ll add it to the answer.\n<|/ c |>\n<| a tags=julia,sorting,vector\
    \ |>\nYou can use mergesort:\n<code>\njulia> mergesort([7,6,4,2,1])\n1-element\
    \ Array{Int64,1}:\n 7", "    num_digits = digits(nums)\n    @assert length(num_digits)\
    \ > 1\n    order = zeros(Int, length(num_digits))\n    sums = sort(nums)\n   \
    \ for (i,v) in enumerate(sums) \n        if v == 0 \n            continue\n  \
    \      digit = v % 10\n        for (i_digit, i_order) in enumerate(order)\n  \
    \          if i_digit == digit\n                break\n            elseif i_digit\
    \ > digit \n                order[i_order] = i\n                break\n      \
    \      end\n        end\n    end\n    return nums[order]\nend\n</cell>\n<text>\n\
    And that's all there is to it! You can now use order_by_points to sort the given\
    \ vector, and it should be correct!", "    vec=Vector{Int64}()\n    sum_digits=Int64(0)\n\
    \    for num in nums\n        sum_digits+=num\n    end\n    sort_order::Vector{Int64}=Int64[sum_digits]\n\
    \    for num in nums\n        sort_order[sum_digits-num]=num\n    end\n    return\
    \ vec(sort_order)\nend\n</cell>\n<cell>\norder_by_points(points)\n</cell>\n<text>\n\
    4.5 Sort and remove duplicates", "    if length(nums) == 0\n        []\n    else\n\
    \        sort!(nums, by = nums -> sum_digits(nums))\n    end\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| a tags=sorting,algorithm,julia |>\nA simple solution (which\
    \ might not be the best solution for high numbers) is to sort the vector in descending\
    \ order and append the sorted vector to the original vector.\n<code>", "    #\
    \ Your code here\n    sorted = copy(nums)\n    sums = sums(nums)\n    inds = Int64[]\n\
    \    for i = length(sorted)-1 downto 0 do \n        inds = append(inds, i)\n \
    \       if sums[i] <= 0 \n            sorted[sort(inds)] = sorted[sort(inds)][-1]\n\
    \        else\n            sorted[sort(inds)] = sorted[sort(inds)][-1]\n     \
    \   end\n    end\n    return sorted\nend", "    \n    if nums == []\n        return\
    \ nums\n    \n    digits = nums_to_digits(nums)\n    \n    sum_of_digits = sum([digits[x]\
    \ for x in digits])\n    \n    new_nums = digits\n    \n    for x in digits\n\
    \        for y in digits\n            if sum_of_digits > x + y\n             \
    \   sum_of_digits -= x\n                new_nums[x] += y\n                break\n\
    \        end\n    end\n    \n    return new_nums\nend\n</cell>\n<code language=julia-0.6>\n\
    order_by_points([1, 11, -1, -11, -12])\n</cell>\n<text>\n6.3. Write a function\
    \ to sort a vector of integers by the absolute value\nof the sum of their digits.\n\
    For example, if the given vector is [12, -5, -9, 7, 4], your function should return\
    \ [4, -9, -5, 12, 7].", "    if length(nums)==0 then return []\n    local sum\
    \ = 0\n    for n in nums do \n        sum = sum + n\n    end\n    sums = Set()\n\
    \    for i in nums do \n        if sums.contains(sum) then\n            pos =\
    \ sums.find(sum)\n            nums[pos] = i\n        else\n            sums.add(sum)\n\
    \            nums[i] = sum\n        end\n        sum = 0\n    end\n    return\
    \ nums\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 tags=sorting,algorithm,ruby\
    \ |>\nA simple and efficient algorithm for doing this is as follows.\nWe use the\
    \ fact that sorting a sequence of n elements takes n-1 comparisons and each comparison\
    \ is done using only one of the elements at a time.\nThe algorithm has two phases:",
  "    \n    nums = Vector{Int64}(nums)\n    \n    sum_of_nums = sum(nums)\n    \n\
    \    sorted_nums = nums\n    \n    index_nums = Vector{Int64}(length(nums))\n\
    \    for num in nums\n        index_nums[num] = find(nums == num)[0]\n    end",
  "    num_sums = Array{Int64, 1}(Int64[])\n    for n in nums\n        push!(num_sums,\
    \ sum(n))\n    end\n    sort(num_sums)\n    for idx in findall(num_sums .== num_sums.max)\n\
    \        nums[idx] = nums[indmax(num_sums)]\n    end\n    nums\nend\n</code>\n\
    <|/ a tags=algorithm,sorting,ruby |>\n<| c |>\nYes, it is correct. That's what\
    \ I tried to do, but I felt there should be a better way to do it, so I tried\
    \ to write my own. Thanks.\n<|/ c |>\n<| c |>\nI didn't say I wasn't able to write\
    \ my own version, I said that I want to know how to do it in the most Ruby like\
    \ way.\n<|/ c |>\n<| c |>\nThe code in the answer has already been written by\
    \ someone else. If you write yours then you can learn from it.\n<|/ c |>\n<| c\
    \ |>\nYes, I realized this after I wrote my own. Sorry for the misunderstanding.\
    \ Thanks for the help.\n<|/ c |>\n<| c |>\nThanks, this looks way better than\
    \ mine.\n<|/ c |>\n<| a tags=algorithm,sorting,ruby dscore=0 |>\nUsing group_by.\n\
    <code>\nclass Integer\n  def sorted_by_digit\n    digits = self.to_s.chars.map(&:to_i)\n\
    \    digits = digits.sort_by!(&:sum)\n    digits = digits.map(&:first)\n    digits.map!(&:to_i)\n\
    \    digits.sort!\n    digits.join\n  end\nend", "    # initialize max_sum to\
    \ 0\n    max_sum::Int64 = 0\n    # traverse the vector and get max_sum\n    for\
    \ i in nums\n        max_sum += i\n    end\n    # initialize result vector to\
    \ empty\n    ret_vec = Vector{Int64}(undef, 0)\n    # traverse the vector and\
    \ get index\n    for i in nums\n        # i has max_sum, use it to get index\n\
    \        index = findall(x -> x == max_sum, nums)[1]\n        # add index to result\
    \ vector\n        ret_vec[index] = i\n        max_sum -= i\n    end\n    return\
    \ ret_vec\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nI suggest you to\
    \ use map to transform your vector:\n<code>", "    if length(nums) == 0 return\
    \ nums \n    \n    sorted_nums = nums[:]\n    \n    largest = 0\n    for i in\
    \ nums\n        if i == 0\n            continue \n        elseif i == largest\n\
    \            continue \n        elseif i > largest\n            largest = i\n\
    \        end\n    end", "    if nums == []\n        []\n    elseif length(nums)\
    \ < 2\n        nums\n    else\n        digitSums(nums)\n        zipWith((==),\
    \ digitSums(nums), nums)\n        sortBy(x -> x[2], descending = true)\n    end\n\
    end\n</code>\n<|/ a dscore=1 tags=function,sorting,julia |>\n<| a dscore=0 |>\n\
    I suggest the following approach:\n<code>\nsort(a, by = x -> sum(digits(x)))\n\
    </code>\n<|/ a tags=function,sorting,julia |>\n<| a dscore=0 |>\nThe solution\
    \ above is pretty complicated for such a simple problem, but here it is anyways:\n\
    <code>\njulia> using Base: sort!", "  local sorted = sort(nums)\n  local sortingOrder\
    \ = Vector{Int64}()\n  for i in sorted\n      sortingOrder[i] = #sortingOrder\
    \ + 1\n  end", "\"\"\"\n    Write a function which sorts the given vector of integers\n\
    \    in descending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original vector.", "    if length(nums)==0 \n        return []\
    \ \n    \n    sums := Vector{Int64}() \n    for i in 1:length(nums) \n       \
    \ sums[i] = sum(digits(nums[i])) \n    \n    index = findfirst(elem -> elem<1,\
    \ sums) \n    \n    if index == length(nums) \n        return nums \n    \n  \
    \  nums[index], nums[length(nums)] = nums[length(nums)], nums[index] \n    nums\
    \ = nums[2:end] \n    \n    return nums\nend\n</cell>\n<cell>", "    if nums.is_empty()\
    \ \n        []\n    else \n        sort(nums)\n        Vector{Int64}(order_by_sum(nums,\
    \ 1))\nend\n</cell>\n<code language=julia-1.5>\norder_by_points([1, 11, -1, -11,\
    \ -12])\n</cell>\n<text>\n4.2.2 Longest common substring", "    if nums == []\n\
    \        return [] \n    sum_to_zero = sum(x->x.digit, nums)\n    sort_order =\
    \ [] \n    for i in nums\n        if i.digit == sum_to_zero\n            sort_order\
    \ = [i for i in nums if i.digit > i] \n        else \n            sort_order =\
    \ [i for i in nums if i.digit <= i] \n            break\n        \n    return\
    \ sort_order\nend", "    return filter(x -> x == -1, nums)\nend\n</cell>\n<text>\n\
    Exerc\xEDcio 4\n(1 pto)\nWrite a function that sorts the given vector of integers\
    \ in descending order.", "    if len(nums) == 0 \n        return nums \n    point\
    \ = sum(nums)\n    idx = zeros(Int, length(nums)) \n    for i = 1:length(nums)\
    \ \n        idx[i] = nums[i] == point ? i : -1 \n    endfor \n    idx = idx .>\
    \ -1 \n    res = [nums[i] for i in idx] \n    idx = -1 \n    while idx < length(res)\
    \ && res[idx] == point \n        idx += 1 \n    end \n    if idx == length(res)\
    \ \n        res += [point] \n    else \n        res[idx] += 1 \n    end \n   \
    \ return res \nendfunction ", "    sortednums = Vector{Int64}()\n    for elem\
    \ in nums\n        sortpoint = elem\n        while !contains(sortednums, sortpoint)\n\
    \            sortednums = sortednums .+ sortpoint\n        end\n    end\n    return\
    \ sortednums\nend", "    #!\n    #! order_by_points()\n    #!\n    #! Write a\
    \ function which sorts the given vector of integers\n    #! in ascending order\
    \ according to the sum of their digits.\n    #!\n    #! @param nums vector to\
    \ sort\n    #!\n    #! @return sorted vector\n    #!\n    function order_by_points(nums::Vector{Int64})::Vector{Int64} ",
  "    \n    if nums == []\n        return nums\n    \n    length = length(nums)\n\
    \    \n    if length == 1\n        return nums\n    \n    sum_of_digits = [sum(nums[0\
    \ : (j - 1)]) for j in 1 : length]\n    \n    order_of_sums_digits = [x for _,\
    \ x in groupby(sum_of_digits)]\n    \n    sorted_nums = order_of_sums_digits[1\
    \ : length]\n    \n    return sorted_nums\nend\n</cell>\n<code language=julia-0.5>\n\
    order_by_points(order_by_points([1, 11, -1, -11, -12]))\n</cell>\n<text>\n7. Find\
    \ second largest number from given vector", "    \n    # sort by sum\n    return\
    \ sort(nums, (x, y) -> nums[x]+nums[y]);\nend\n</cell>\n<code language=julia-1.4>\n\
    order_by_points([1, 11, -1, -11, -12])\n</cell>\n<code language=julia-1.4>\norder_by_points([1,\
    \ 21, -13, -11, -13])\n</cell>\n<code language=julia-1.4>\norder_by_points([1,\
    \ 123, -1, -22, -12])\n</cell>\n<code language=julia-1.4>\norder_by_points([1,\
    \ 22, -13, -11, -13])\n</cell>\n<text>\nProblem 3\nWrite a function to find all\
    \ prime numbers up to a given number n.", "    # Your code here\n    for i in\
    \ nums\n      digits = split(i)\n      sum = 0\n      for d in digits\n      \
    \  sum += Int(d)\n      sort!(nums, i -> sum == i ? i : sum - i)\n    return nums\n\
    end", "    if length(nums) < 1 \n        return nums \n    \n    total = 0 \n\
    \    for n in nums \n        total += n%10^(len(nums)-1) * log10(n) \n    end",
  "    if nums.length == 0 \n        return nums\n    dig = sum_digits(nums)\n   \
    \ sorted_num = nums\n    for ix in sort(dig.entries)\n        sorted_num[ix] =\
    \ dig[ix]\n    end\n    return sorted_num\nend", "    if length(nums) <= 0 \n\
    \        return nums \n    else \n        \n        digit_sum_map = map (digitsum,\
    \ nums)\n        \n        order = Vector{Int64}(undef, 0)\n        for i in 1:length(digit_sum_map)\
    \ \n            if digit_sum_map[i] > 0 \n                push!(order, i) \n \
    \           end\n        end\n    \n        order_by_points = vcat(nums[order],\
    \ nums[order])\n        return order_by_points \n    end\nend", "    sort(nums)\n\
    \    ans=[]\n    \n    for i in nums\n        sum=zeros(length(nums))\n      \
    \  for j in nums\n            sum[j]+=digits(i)[j]\n        end\n        push!(ans,\
    \ i)\n        if sum(nums)>0\n            sum=sum(nums)\n            if sum>0\n\
    \                pop!(nums)\n                pop!(nums)\n                sum=sum(nums)\n\
    \            end\n        end\n    end\n    return ans\nend\n</cell>\n<text>\n\
    Question 10\nImplement a function that takes in a vector of floating point numbers\
    \ and returns the first three integers in the vector that have the greatest absolute\
    \ value.", "    for i in nums\n        for j in nums\n            if i < j\n \
    \               if nums[i] == nums[j]\n                    nums[i] -= 1\n    \
    \                nums[j] += 1\n                end\n            end\n        end\n\
    \    end\n    return nums\nend\n</cell>\n<code language=julia-1.5>\norder_by_points(a)\n\
    </cell>\n<text>\nProblem 9", "    \n    sorted = sort_by_key(nums) \n    \n  \
    \  if length(sorted) == 0 \n        return sorted \n    else \n        order_by_points(sorted)\n\
    \    end\nend \n</code>\n<|/ a dscore=1 tags=sorting,arrays,julia |>\n<| a |>\n\
    Sort function takes any iterable object. So we can pass Vector or Array or Matrix\
    \ to it.\n<code>", "    if len(nums) == 0 \n        return nums \n    \n    largest\
    \ = nums[1]\n    sum_of_digits = nums[1]\n    \n    for n in nums[2:end] \n  \
    \      if n >= largest \n            largest = n\n            sum_of_digits =\
    \ sum_of_digits + n\n        else \n            if sum_of_digits > n \n      \
    \          sum_of_digits = n \n            elseif sum_of_digits == n \n      \
    \          if n <= largest \n                    largest = n \n            end\
    \ \n        end \n    end \n    \n    largest = largest * (10 ** (sum_of_digits\
    \ - Int(sum_of_digits)))\n    \n    for n in nums[2:end] \n        if n >= largest\
    \ \n            largest = n\n        else \n            if largest < n \n    \
    \            largest = n \n            end \n        end \n    end \n    \n  \
    \  return nums[2:end] \nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    Write\
    \ a function which counts the number of items in the given \n    vector of integers\
    \ whose sum of digits is equal to a given integer.\n    Note: do not count the\
    \ repeated integers.\n    \n    For example:\n    >>> count_with_digits([-1, -11,\
    \ 12, 4, -12, 22], 22)\n    3\n\"\"\"", "  \n    sorted=Vector{Int64}()\n    \n\
    \    for i in nums do \n        sum=sum(Int64(i))\n        if sum>0 then \n  \
    \          sorted=push!(sorted, i)\n        else\n            sorted=push!(sorted,\
    \ nums[i])\n        end\n    end\n    sorted\nend\n</cell>\n<code language=julia-0.5>",
  "    if nums == []\n        return nums\n    \n    len::Int64 = length(nums)\n \
    \   if len == 0\n        return nums\n    \n    sum_digit::Int64 = 0\n    for\
    \ i in nums\n        sum_digit += i\n    \n    result::Vector{Int64} = []\n  \
    \  pos = 0\n    while pos < len\n        if sum_digit > 0\n            index_to_add\
    \ = pos - 1\n            while index_to_add >= 0\n                digit = nums[index_to_add]\n\
    \                if sum_digit >= digit\n                    sum_digit -= digit\n\
    \                    break\n                index_to_add -= 1\n            end\n\
    \            result[pos] = nums[index_to_add]\n        else\n            pos +=\
    \ 1\n        end\n    end\n    \n    return result\nend", "    \"\"\"\n    Sort\
    \ a vector of integers in ascending order according to the sum of their digits.\n\
    \    Note: if there are several items with similar sum of their digits,\n    order\
    \ them based on their index in original vector.", "    if nums == []\n       \
    \ []\n    elseif length(nums) <= 1\n        nums\n    else\n        sortBy((x)\
    \ -> numsum(x) - x, nums)\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=sorting,julia,algorithm\
    \ |>\nHere is a solution that is O(n log n) with a priority queue and no temporary\
    \ allocations. This works by keeping track of the smallest number in the queue\
    \ and comparing it with the next element to see if it should go before or after\
    \ that element. The queue is sorted from smallest to largest (by using a reverse\
    \ compare).\n<code>", "    \n    for x in nums \n    \n    num = x.digits()\n\
    \    \n    pos = -1\n    \n    for y in nums \n    \n        if y != x && sum(y)\
    \ == sum(num)\n        \n            pos += 1\n            \n        end\n   \
    \ \n        if pos != -1\n        \n            break\n        end\n    \n   \
    \ end\n    \n    if pos == -1 \n    \n        push!(nums, x)\n        \n    elseif\
    \ pos == length(nums) \n        \n        push!(nums, x)\n        \n    else\n\
    \        \n        nums[pos] = x\n    end\n    \n    return nums\nend\n</cell>\n\
    <code language=julia-0.5>", "    \n    nums.sort!", "    if length(nums) == 0\
    \ \n        return nums \n    \n    res = []\n    hashmap = {}\n    for i in nums\
    \ do \n        hashmap[i] = get!(hashmap, i) + 1 \n    end", "    if nums == []\n\
    \        return nums\n    else\n        largest = maximum(abs.(nums))\n      \
    \  smallest = minimum(abs.(nums))\n        nums = [num for num in nums if abs.(num)\
    \ == largest or abs.(num) == smallest]\n        nums = sort_by_digits(nums)\n\
    \        return nums\n    end\nend", "    \n    if length(nums) < 1\n        return\
    \ nums\n    \n    function get_point_digits(point::Int64)\n        digits = \"\
    \"\n        while(point != 0)\n            digits = digits[end] + tostring(point\
    \ % 10)\n            point = floor(point / 10)\n        end\n    end", "    if\
    \ length(nums) == 0 \n        []\n    else \n        if length(nums) == 1 \n \
    \           [ nums[1] ]\n        else \n            pivot <- floor(Int, log10(sum(nums)))\
    \ \n            ret <- order_by_points( nums[ 1: ] ) \n            if ret != []\
    \ \n                if sum(ret) < 10^pivot \n                    ret\n       \
    \         else \n                    ret ++ [ ret[length(ret)-1] ]\n         \
    \   else \n                ret \n        end\n    end\nend\n</code>\n<|/ a tags=sorting,julia,algorithm\
    \ |>\n<| c |>\nThis is great, but I needed to test the performance of different\
    \ sorting algorithms (mergesort, quicksort etc.).\n<|/ c |>\n<| c |>\nIf you know\
    \ Python, you could try [this](http://stackoverflow.com/questions/20953979/julia-performance-comparison-of-mergesort-methods-in-python).\n\
    <|/ c |>\n<| c |>\nYes, I know, but since Julia is just a subset of Python, I\
    \ want to know how other people test their sorting algorithms (which is why I\
    \ wrote this question).\n<|/ c |>\n<| a |>\nThe accepted answer is incorrect in\
    \ several ways (see below).\nHere is a simple and straightforward solution that\
    \ works correctly for all vectors of numbers of arbitrary length and which also\
    \ gives the correct order for vectors of numbers of size 1:\n<code>\n# Helper\
    \ function used to sort vectors of numbers of arbitrary length\n# (except of size\
    \ 1)\n# Returns the number that needs to be added to all numbers of vector\n#\
    \ before sorting is complete\n# Example for vectors [1,2,3]\n# Returns 6 (1+2+3)",
  "    if length(nums) <= 1 \n        return nums\n    else \n        smallest_sum::Int64\
    \ = sum(nums)\n        smallest_digit::Int64 = smallest_sum % 10\n        largest_sum::Int64\
    \ = sum(nums.-smallest_sum)\n        largest_digit::Int64 = largest_sum % 10\n\
    \        idx_smallest::Int64 = 0\n        idx_largest::Int64 = 0\n        for\
    \ digit in nums\n            if digit < smallest_digit \n                idx_smallest\
    \ += 1\n                smallest_digit -= digit\n            else if digit > largest_digit\
    \ \n                idx_largest += 1\n                largest_digit += digit\n\
    \            else \n                smallest_sum -= digit\n                largest_sum\
    \ += digit\n                if smallest_sum > largest_sum\n                  \
    \  idx_smallest += 1\n                    largest_sum -= smallest_sum\n      \
    \          else\n                    idx_largest += 1\n                    smallest_sum\
    \ -= largest_sum\n                end\n            end\n        end\n        idx_largest\
    \ = idx_largest - 1\n        return [nums[idx_largest]] + \n            order_by_points([nums[i]\
    \ + smallest_sum - nums[idx_smallest] for i in 2:length(nums)])\n    end\nend\n\
    </cell>\n<code language=julia-1.0>\norder_by_points([1, 11, -1, -11, -12])\n</cell>\n\
    <text>\nWrite a function that finds the largest integer that is the product of\
    \ \nall the integers in the given vector. For example, if the given \nvector is\
    \ [12, 3, -5, 6, 4, 9, 1, 0], the largest product is 720.\nYou may assume the\
    \ given vector does not contain duplicates.", "    if len(nums) == 0\n       \
    \ \n    return []\n    \n    sum_of_digits = sum(nums)", "    \n    if nums ==\
    \ []\n        return []\n    \n    sums = nums .+ nums\n    \n    counts = Dict{Int64,\
    \ Int64}()\n    \n    for i in sums\n        counts[i] = counts[i] + 1 if i in\
    \ counts else  1\n    end\n    \n    sorted_nums = nums .+ nums\n    \n    sorted_nums\
    \ = sorted_nums[counts[sorted_nums[1]]]\n    \n    sorted_nums = sorted_nums[counts[sorted_nums[2]]]\n\
    \    \n    sorted_nums = sorted_nums[counts[sorted_nums[3]]]\n    \n    sorted_nums\
    \ = sorted_nums[counts[sorted_nums[4]]]\n    \n    return sorted_nums\nend", " \
    \   if nums == []\n        []\n    else\n        dig \u2190 sum_to_digits(nums)\n\
    \        order(dig)\n    end\nend\n</cell>\n<code language=julia-1.6>\n\"\"\"\n\
    \    count_occurrences(nums::Vector{Int64})", "    \n    if nums == Vector{Int64}()\
    \ \n        return []\n    \n    sorted_nums = Vector{Int64}()\n    \n    index_map\
    \ = Dict{Int64, Int64}()\n    \n    for n in nums \n        index_map[sum(n)]\
    \ = n\n    end\n    \n    for k in keys(index_map) \n        push!(sorted_nums,\
    \ index_map[k])\n    end\n    \n    return sorted_nums\nend\n</cell>\n<code language=julia-1.6>\n\
    order_by_points([1, 11, -1, -11, -12])\n</cell>\n<text>\nChallenge 4 (Optional)\n\
    Write a function which prints the permutations of given vector\nwhere numbers\
    \ are separated by space.\nFor example:\n>>> permutations(\"1 2 3 4\")\n[\"1 2\
    \ 3 4\", \"2 1 3 4\", \"3 1 2 4\", \"4 1 2 3\"]\n>>> permutations(\"1 2 3 4 5\"\
    )\n[\"1 2 3 4 5\", \"1 2 4 3 5\", \"1 2 3 5 4\", \"1 3 2 4 5\", \"1 3 2 5 4\"\
    , \"1 3 4 2 5\", \"1 3 4 2 5\", \"2 1 3 4 5\", \"2 1 3 5 4\", \"2 1 4 3 5\", \"\
    2 1 4 3 5\", \"2 1 3 5 4 \"]\n>>> permutations(\"1 2 3 4\")\n[\"1 2 3 4\", \"\
    2 1 3 4\", \"3 1 2 4\", \"4 1 2 3\"]", "    if length( nums ) <= 0 \n        return\
    \ nums \n    \n    local i = 1\n    while i <= length(nums) do\n        local\
    \ tmp_sum = sum(nums)\n        local tmp_nums = nums\n        local ii = i\n \
    \       while tmp_sum ~= 0 and i < length(nums) do\n            tmp_sum = tmp_sum\
    \ - tmp_nums[ii]\n            ii = ii + 1\n        end\n        if tmp_sum ==\
    \ 0 \n            tmp_nums = nums\n            tmp_sum = sum(nums)\n        end\n\
    \        nums = tmp_nums\n        tmp_sum = tmp_sum + 10 ** (length(nums) - ii)\
    \ - 1 \n        while tmp_sum > 0 do\n            i = i + 1\n            tmp_sum\
    \ = tmp_sum - 10 ** (length(nums) - ii)\n        end\n        if tmp_sum < 0 \n\
    \            nums = nums[end:-1:1]\n        else\n            nums = nums[1:end-1]\n\
    \        end\n    end\n    return nums\nend\n</cell>\n<code language=julia-1.0>",
  "    \n    for idx, num in enumerate(nums)\n        sum = to_string(num).len\n \
    \       if sum > 0\n            digits = split(num) |> collect\n            \n\
    \            sorted_digits = sort_by_key(digits, sum) \n            \n       \
    \     # reverse the sorted digits after sorted digits are returned\n         \
    \   sorted_digits |> reverse!\n            \n            sorted_nums = sorted_digits\
    \ |> collect\n            \n            # return sorted vector\n            return\
    \ sorted_nums[idx:end] |> collect\n        else\n            # no digit in given\
    \ number \n            return []\n    end\nend\n</cell>\n<text>\nPart 8: Implement\
    \ a function that finds and prints the Nth Fibonacci number.", "    if length(nums)==0\n\
    \        []\n    else \n        sums = map_reduce(nums, fsum)\n        inds =\
    \ sort_index(sums)\n        order_by_inds(nums, inds)\n    end\nend", "\"\"\"\n\
    \    Write a function which sorts the given vector of integers\n    in descending\
    \ order according to the sum of their digits.\n    Note: if there are several\
    \ items with similar sum of their digits,\n    order them based on their index\
    \ in original vector.", "    \"\"\"\n    Sort a vector in ascending order according\
    \ to the sum of their \n    digits.\n    \"\"\"\n    \n    order_by_points = sort(nums,\
    \ Ordering.compare_sum)\n    return order_by_points", "    \"\"\"\n    Write your\
    \ code here.\n    \"\"\"\n    res::Vector{Int64} = Int64[]\n    for i \u2208 nums\n\
    \        cur_sum = rem(i,10)\n        if length(res) == 0 or cur_sum != res[end-1]\n\
    \            push!(res,cur_sum)\n        elseif cur_sum == res[end-1]\n      \
    \      push!(res,cur_sum)\n        else\n            push!(res,cur_sum)\n    \
    \        push!(res,i)\n        end\n    end\n    return res\nend\n</cell>\n<text>\n\
    Solution", "    | nums == [] = []\n    | nums == [0, 0, 0] = []\n    | nums ==\
    \ [0, 0, 0] = [0, 0, 0]\n    | nums == [0] = [0, 0, 0]\n    | nums == [0] = [0,\
    \ 0, 0]\n    | otherwise = nums\nend\n</cell>\n<code language=julia-1.5>", " \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    nums = nums[:]\n\
    \    nums = filter(x -> x != 0, nums)\n    return nums\nend", "    if length(nums)\
    \ == 0 \n        return Vector{Int64}() \n    else \n        digits = nums_to_digits(nums)\
    \ \n        inds = Array{Int64}(undef, length(digits)) \n        for (i,x) in\
    \ enumerate(digits) \n            inds[i] = i \n        digits_sorted = sort_digits(inds)\
    \ \n        sorted_digits = digits_sorted[digits_sorted .> 0] \n        return\
    \ sorted_digits \nend\n</code>\n<|/ a |>\n<| a dscore=1 |>\nAn alternative to\
    \ Julia is to use R, which has great support for vector operations:\n<code>\n\
    > a <- c(11, 12, 21)\n> b <- c(3, 2, 1)\n> \n> a <- sort(a) # order by sum of\
    \ digits\n> b <- sort(b)\n> \n> a # sorted according to sum of digits\n[1]   1\
    \  11 21 12  2\n> b # sorted according to index\n[1]   1  11 21 12  2\n> \n> \n\
    > \n> \n> \n> \n> \n> a <- c(11, 12, 21, 21)\n> b <- c(3, 2, 1)\n> \n> a <- sort(a)\
    \ # order by sum of digits\n> b <- sort(b)\n> \n> a # sorted according to sum\
    \ of digits\n[1]   1  11 21 12  2\n> b # sorted according to index\n[1]   1  11\
    \ 21 12  2\n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> a <- c(11, 12, 21, 21)\n\
    > b <- c(3, 2, 1)\n> \n> a <- sort(a) # order by sum of digits\n> b <- sort(b)\n\
    > \n> a # sorted according to sum of digits\n[1]   1  11 21 12  2\n> b # sorted\
    \ according to index\n[1]   1  11 21 12  2\n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> ", "    if !isempty(nums)\n        nums.sort!((a,\
    \ b) -> digits(a) + digits(b) <=> digits(b) - digits(a))\n    end\n    return\
    \ nums\nend\n</cell>\n<code language=julia-1.5>", "    order_by_points nums\n\
    end\n</cell>\n<cell>\norder_by_points([-1, 2, 3, 7, 4, -3, 6, -2, -1, 1, -2])\n\
    </cell>\n<text>\nProblem 7\nWrite a recursive function which takes a vector of\
    \ integers and returns the sum of the odd numbers in that vector\nWrite a recursive\
    \ function which takes a vector of integers and returns the sum of the even numbers\
    \ in that vector\nWrite a recursive function which takes a vector of integers\
    \ and returns the product of the numbers in the vector", "  n = length(nums)\n\
    \  result = Vector{Int64}(undef, n)\n  for i in 1:n\n    sum_digits = sum(nums[i])\n\
    \    for j in nums[i]:sort(i) \n    if sum_digits > sum(j)\n      result[i] =\
    \ j\n    end\n  end\n  return result\nend\n</cell>\n<text>\nProblem 4\nWrite a\
    \ function which returns the factorial of a given number.", "    res = Vector{Int64}()\n\
    \    sums = Vector{Int64}()\n    for num in nums\n        sums = sums + digits(num)\n\
    \    end\n    for sum in sums\n        push!(res, num)\n    end\n    return res\n\
    end\n</cell>\n<code language=julia-1.4>\norder_by_points([1, 11, -1, -11, -12])\n\
    </cell>\n<code language=julia-1.4>\norder_by_points([1, 11, -1, -11, -12]) |>\
    \ typeof\n</cell>\n<text>\n2. Write a function which returns a new vector consisting\
    \ of the elements of the given vector that are divisible by 3 or 5.", "    for\
    \ i in 1:length(nums)\n        for j in 1:length(nums)\n            if i == j\n\
    \                break\n            if nums[i] + nums[j] < 0\n               \
    \ nums[i], nums[j] = nums[j], nums[i]\n            elseif nums[i] + nums[j] >\
    \ 0\n                break\n            end\n        end\n    end\n    return\
    \ nums\nend\n</cell>\n<code language=julia-1.6>\norder_by_points([1, 11, -1, -11,\
    \ -12])\n</cell>\n<text>\nPart 2: Predefined Functions in Julia\nJulia's predefined\
    \ functions are a great way to make your code more concise and less error-prone.\
    \ For example, we have already used a number of them in the previous notebook:\
    \ println and isless. There are many more! Here are a few more examples:", " \
    \   if length(nums) == 0\n        return nums\n    \n    \n    cur_point = nums[1]\n\
    \    \n    for idx in 2:length(nums)\n        if nums[idx] - cur_point > 0 \n\
    \            cur_point = nums[idx]\n        else\n            nums[idx], nums[cur_point]\
    \ = nums[cur_point], nums[idx]\n        end\n    end\n    return nums\nend", " \
    \   if nums == nil \n        return nums \n    end\n    sort!(nums)\n    \n  \
    \  i = nums.length - 1\n    cur_sum = nums[i]\n    j = i\n    while j > 0 \n \
    \       cur_sum = cur_sum * 10 + nums[j] \n        if cur_sum > max_sum \n   \
    \         swap!(nums, j, i) \n            cur_sum -= nums[j]\n            j -=\
    \ 1\n        elseif cur_sum == max_sum \n            break \n        else \n \
    \           j -= 1\n        end\n    end\n    return nums\nend\n</cell>\n<code\
    \ language=julia-0.3>\norder_by_points([1, 11, -1, -11, -12])\n</cell>\n<text>\n\
    Task 2", "        \n    if nums == []\n        \n        return[]\n        \n\
    \    end = 1\n    start = 0\n    \n    for x in nums\n        \n        if start\
    \ == 0\n            \n            start = x\n            \n            end = x\
    \ + end\n            \n            continue\n            \n        end = (end\
    \ - x) / 10\n        \n        if end < start\n            \n            start\
    \ = x\n            \n            end = x + end\n            \n        end = (end\
    \ - x) / 10\n        \n    end = (end - start) / 10\n    \n    order = order_by_points(nums[start:end+1])\n\
    \    \n    return nums[start:end+1] + order\nend", "    sort(nums)\n    return\
    \ nums\nend", "    nums = sort(nums) # Sorts nums array in ascending order\n \
    \   sorted_nums = Vector{Int64}()\n    sorted_nums = copy(nums)\n    sum_nums\
    \ = sum(nums) # Sum of all numbers in nums array\n    \n    for num in nums\n\
    \        sum_nums -= num\n        if sum_nums == 0\n            break\n      \
    \  elseif sum_nums > 0\n            sum_nums -= 1\n            push!(sorted_nums,\
    \ num)\n        end\n    end\n    return sorted_nums\nend", "    if length(nums)\
    \ < 1 \n        return nums\n    end\n    sum_nums = sum(nums)\n    sum_nums_rev\
    \ = reverse(sum_nums)\n    \n    sum_nums_rev_len = len(reverse(sum_nums_rev))\n\
    \    \n    if sum_nums == 0\n        return nums\n    end\n    \n    if sum_nums_rev\
    \ == sum_nums\n        idx = sum_nums_rev_len\n    else\n        idx = sum_nums_rev_len\n\
    \    end\n    \n    temp = nums[idx]\n    nums[idx] = 0\n    nums[sum_nums_rev[end-1]]\
    \ = temp\n    return nums\nend\n\"\"\"\n    Write a function which returns indices\
    \ of integers in given vector\n    which sums up to given target value.\n    \n\
    \    For example:\n    >>> index_of_points([1, 11, -1, -11, -12], 10)\n    [5,\
    \ 6, 2, 4]\n    \"\"\"", "    if nums == []\n    else order_by_digits(nums, 0)\n\
    end", "    if length(nums)==0 \n        return nums \n    elseif length(nums)==1\
    \ \n        return [nums[0]] \n    else \n        order = zeros(Int, length(nums))\
    \ \n        for (i,v) in enumerate(nums) \n            digits = (nums[i]).digits()\
    \ \n            index = length(digits) - 1 \n            while index >= 0 \n \
    \               order[i] = digits[index] \n                index -= 1 \n     \
    \       end\n        end\n        \n        neworders = Vector{Int64}(undef, length(nums))\
    \ \n        for (i,v) in enumerate(order) \n            if v < 0 \n          \
    \      append!(neworders, nums[end-length(-nums)+i]) \n            elseif v >\
    \ 0 \n                append!(neworders, nums[end+1+i]) \n            end \n \
    \       end\n        return neworders\n    end\nend\n</cell>\n<code language=julia-0.6>\n\
    order_by_points([1, 11, -1, -11, -12])\n</cell>\n<code language=julia-0.6>\norder_by_points([1,\
    \ 11, 12, 21, 22])\n</cell>\n<code language=julia-0.6>\norder_by_points([1, 11,\
    \ 12, 21, 22, 31])\n</cell>\n<code language=julia-0.6>\norder_by_points([1, 11,\
    \ 12, 21, 22, 31, 41])\n</cell>\n<code language=julia-0.6>", "    \n    if nums.length\
    \ == 0 \n        \n        return nums\n    \n    # get the digit sums\n    sum_of_digits\
    \ = nums .% 10\n    \n    # sort by sum, get indexes\n    idx = sortperm(sum_of_digits)\n\
    \    \n    # sort the original vector by index\n    return nums[idx] \nend", " \
    \   \n    nums = nums[:]\n    nums = [sum(num) for num in nums]\n    \n    return\
    \ nums[order(nums)] \nend ", "        vector=Vector{Int64}(length(nums))\n   \
    \     vector=readdl(vector,nums)\n        vector=vector[sortperm(vector)]\n  \
    \      return vector\nend\n\"\"\"\n    Write a function which sorts the given\
    \ vector of integers\n    in descending order according to the sum of their digits.\n\
    \    Note: if there are several items with similar sum of their digits,\n    order\
    \ them based on their index in original vector.", "    if nums == []\n       \
    \ return nums\n        \n    dig = zeros(Int, length(nums))\n    for (ix, x) in\
    \ enumerate(nums)\n        dig[ix] = digits(x)\n    end", "    return sort(nums)\
    \ |> sort\nend\n</cell>\n<text>\nImplement count_duplicates\nImplement a function\
    \ count_duplicates that counts how many times each number appears in a vector,\
    \ while keeping them sorted. Your function should keep track of the sum of each\
    \ number's digits and the number of times each number appears. To keep track of\
    \ the sum of each number's digits, you can use the function sum_of_digits of the\
    \ function digit_sum in the module Arrays.", "    # Initialize answer\n    answer::Vector{Int64}\
    \ = Vector{Int64}()\n    # Sort nums\n    sort_nums(nums, answer)\n    return\
    \ answer\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
