name: HumanEval_7_filter_by_substring
language: jl
prompt: "\"\"\" Filter an input vector of strings only for ones that contain given\
  \ substring\n    >>> filter_by_substring([], \"a\")\n    []\n    >>> filter_by_substring([\"\
  abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"\
  ]\n    \"\"\"\nfunction filter_by_substring(strings::Vector{String}, substring::String)::Vector{String}\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = filter_by_substring;\n\t@test(candidate(Vector{String}([]),\
  \ \"john\") == Vector{String}([]))\n\t@test(candidate([\"xxx\", \"asd\", \"xxy\"\
  , \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"\
  ])\n\t@test(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"\
  xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\n\t@test(candidate([\"\
  grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"\
  ])\nend\n"
completions: ["    \n    for str in strings\n        indices = findall(instr(str,\
    \ substring), str) \n        if length(indices) > 0\n            return str[indices]\n\
    \        end\n    end\n    return strings\nend", "    local result = Set()\n \
    \   for str in strings\n        if contains(substring, str)\n            push!(result,\
    \ str)\n        end\n    end\n    collect!(result)\nend", "    if length(strings)\
    \ <= 0\n        return strings\n    \n    substring_index = get_index(regexp_findall(substring,\
    \ strings[1]), strings)\n    \n    if substring_index <= 0\n        return strings\n\
    \    \n    substring_index_list = []\n    for i in 2:length(strings)\n       \
    \ substring_index_list.append(get_index(regexp_findall(substring, strings[i]),\
    \ strings))\n    end\n    \n    strings_final = strings[substring_index_list[1]:end]\
    \ + strings[substring_index_list[2]:end]\n    \n    return strings_final\nend",
  "  strings = filter((x) -> contains(x,substring), strings)\n  return strings\nend",
  "        \n    if length(strings) == 0\n        return strings\n    ends_with_substring\
    \ = substring in strings\n    starts_with_substring = contains(strings, substring)\n\
    \    contains_substring = contains(strings, substring)\n    \n    if ends_with_substring\n\
    \        return filter_by_substring(substring..strings, substring)\n    elseif\
    \ starts_with_substring\n        return filter_by_substring(strings..substring,\
    \ substring)\n    elseif contains_substring\n        return strings\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\nfilter_by_substring(\"abcdefg\", \"c\"\
    )\n</cell>\n<text>\nFilter an input vector of strings only for ones that contain\
    \ given substring\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"abc\")\n    [\"abc\", \"bacd\"]\n    >>> filter_by_substring([\"abc\"\
    , \"bacd\", \"cde\", \"array\"], \"bacd\")\n    [\"bacd\", \"cde\", \"array\"\
    ]\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\"\
    )\n    []\n    \"\"\"", "    indexes = [i for (i,s) in eachindex(strings) if contains(s,\
    \ substring)]\n    return filter([x -> isempty(find(strings, x)), x->not(x in\
    \ indexes)], strings)\nend", "    if length(strings)==0\n        return strings\n\
    \    found_substrings = Vector{String}()\n    for str in strings\n        if contains(substring,\
    \ str)\n            push!(found_substrings, str)\n        end\n    end\n    return\
    \ found_substrings\nend", "    for i in 1:length(strings)\n        if contains(strings[i],\
    \ substring)\n            filter_by_substring(strings[i+1:end], substring)\n \
    \       else\n            strings\n        end\n    end\nend\n</cell>\n<text>\n\
    5.3 Removing elements from an array", "    indices = findall(r\".*\" + substring\
    \ + \".*\", strings)\n    return filter((x) -> !contains(x,substring), strings)\n\
    end\n</cell>\n<text>\n4. Filter for specific characters", "    return filter(x\
    \ -> contains(x, substring), strings)\nend", "    \n    strings = check_null(strings)\
    \ \n    substring = check_null(substring)\n    \n    filtered = []\n    \n   \
    \ for string in strings\n        if string.contains(substring)\n            push!(filtered,\
    \ string)\n        end\n    end\n    \n    return filtered\nend\n</cell>\n<text>\n\
    Let's have a look:", "    if is_string_in_vector(strings, substring) == true\n\
    \        return filter(is_string_in_vector(strings, substring), strings)\n   \
    \ else\n        return strings\n    end\nend\n\"\"\"\nFilter an input vector of\
    \ strings only for ones that do not contain given substring\n>>> filter_by_substring([],\
    \ \"a\")\n[]\n>>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"],\
    \ \"a\")\n[\"abc\", \"bacd\", \"array\"]\n\"\"\"", "    \n    filtered::Vector{String}\
    \ = []", "    for str in strings\n        if contains(str, substring)\n      \
    \      push!(results, str)\n        end\n    end\n    return results\nend\n</cell>\n\
    <text>\nExercise 4.6 (2 points): Write a function that filters by a substring\
    \ and returns the number of occurrences of the substring\n    >>> filter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    1\n    >>> filter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"bc\")\n    2\n    \"\"\"", "    matches\
    \ = [x for x \u2208 strings if substring in x]\n    if length(matches)==0\n  \
    \      return strings\n    elseif length(matches)>1\n        error(\"Cannot filter\
    \ by substring, because multiple elements are found\")\n    end\n    return matches\n\
    end\n</cell>\n<code language=julia-1.0>\nfilter_by_substring([[\"abc\",\"bcd\"\
    ]], \"c\")\n</cell>\n<code language=julia-1.0>\nfilter_by_substring([[\"abc\"\
    ,\"bcd\"]], \"ab\")\n</cell>\n<code language=julia-1.0>\nfilter_by_substring([[\"\
    abc\",\"bcd\"]], \"a\")\n</cell>\n<code language=julia-1.0>\nfilter_by_substring([[\"\
    abc\",\"bcd\"]], \"bcd\")\n</cell>\n<text>\nExercise 10", "    for i in eachindex(strings)\n\
    \        if contains(substring,strings[i])\n            return strings[i]\n  \
    \  end\n    return strings\nend # filter_by_substring\n</cell>\n<text>\nExercise\n\
    Write a function that returns all elements of the array that do not contain the\
    \ given substring", "    if string.contains(substring, strings) \n        \n \
    \       return strings\n    else\n        return filter_by_substring(strings,\
    \ substring)\n    end\nend\n</cell>\n<code language=julia-1.4>\nfilter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n</cell>\n<code language=julia-1.4>\n\
    filter_by_substring([x for x in [\"abc\", \"bacd\", \"cde\", \"array\"] if x !=\
    \ \"a\"], \"a\")\n</cell>\n<text>\n4. Intersect two sets", "    if !contains(strings,\
    \ substring)\n        return strings\n    else\n        new_strings = filter_by_substring(strings[!contains(strings,\
    \ substring)], substring)\n        return new_strings\n    end\nend", "    strings\
    \ = filter( elem -> contains(substring, elem), strings )\n    return strings\n\
    end\n</cell>\n<text>\n6.7.3 filter_by_substring2()\nAs with the previous function,\
    \ filter_by_substring() accepts a vector of strings as input and the substring\
    \ to filter on (the second argument) and returns a vector of strings. However,\
    \ this function uses the contains function and the filter() function. filter()\
    \ iterates through each element in the input vector and applies a predicate function\
    \ to each element. The predicate function checks if the element is true, and if\
    \ so, the element is kept in the output vector. filter() can therefore be used\
    \ to filter an input vector of strings for only those strings that contain given\
    \ substring.", "    \n    for str in strings\n        str = replace(str, substring)\n\
    \    end\n    return strings\nend", "  new_strings = Set()\n  for str in strings\n\
    \    if contains(str, substring)\n      new_strings <- new_strings + [str]\n \
    \   end\n  end\n  return new_strings\nend\n</cell>\n<text>\nFilter words by their\
    \ first letter", "    \n    for str in strings do \n        if contains(str, substring)\
    \ == true then \n            return str\n        end\n    end\n    \n    return\
    \ strings\nend\n</cell>\n<code language=julia-1.5>\nfilter_by_substring([\"abc\"\
    , \"bacd\", \"cde\", \"array\"], \"a\")\n</cell>\n<code language=julia-1.5>\n\
    filter_by_substring([1,2,3], \"abc\")\n</cell>\n<code language=julia-1.5>\n# Create\
    \ a function that removes every element from an input vector", "    strings_filtered\
    \ = @filter (x -> contains(x, substring))(strings)\n    return strings_filtered\n\
    end", "    if all(strings == \"\") || substring == \"\"\n        strings\n   \
    \ elseif length(strings) < 2\n        strings\n    else\n        intersect(filter(x\
    \ -> contains(substring,x), strings), strings)\n    end\nend\n</cell>\n<text>\n\
    filter_by_substring()", "    filter_by_substring(strings, substring, false)\n\
    end", "    for i in 1:length(strings)\n        if strings[i] == substring\n  \
    \          strings\n        else\n            append!(strings, strings[i])\n \
    \       end\n    end\nend\n</cell>\n<text>\nThe function filter_by_substring works\
    \ similarly to filter in Matlab, i.e. it returns a new vector that only contains\
    \ the elements that match the given substring.", "    return filter((string) ->\
    \ contains(string, substring), strings)\nend\n</cell>\n<code language=julia-1.0>\n\
    filter_by_substring!(\n    strings,\n    substring,\n)\n</cell>\n<text>\n4.10\
    \ filter_by_count\nGiven a vector of strings, return a new vector containing only\
    \ those strings which contain the given substring, and their number of occurrences\
    \ in the original vector. Case insensitive.", "    if contains(strings, substring)\n\
    \        return strings\n    else\n        return []\n    end\nend\n</cell>\n\
    <code language=julia-1.3>\nfilter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n</cell>\n<text>\nWe can implement a function that filters a\
    \ vector based on another vector's length, which might be useful in certain situations.",
  "    filtered = filter_by_substring2(strings, substring)\n    if isempty(filtered)\n\
    \        throw(stringcat(\"No substrings found for: \", strings))\n    end\n \
    \   return filtered\nend", "    return filter_by_substring(map(string => string\
    \ -> string == substring, strings), substring)\nend\n</cell>\n<code language=julia-1.5>\n\
    #export", "    if contains(substring,strings) == false \n        return strings\n\
    \    end\n    for s in strings \n        if contains(substring,s) == false \n\
    \            return strings\n        end\n    end\n    return strings\nend", " \
    \   return filter(x -> contains(substring,x),strings)\nend \n</cell>\n<code language=julia-0.5>\n\
    #export", "        \n    if !length(substring) \n        throw(DomainError(\"\
    Not enough arguments for filter_by_substring\"))\n    end\n    \n    strings =\
    \ [x for x in strings if contains(x, substring)]\n    return strings\nend", " \
    \   # Write your code here\n    \n    return strings\nend\n</cell>\n<text>\nQuestion\
    \ 3.1: Write a function called filter_by_regex(strings, regex) that takes in an\
    \ array of strings and a regular expression and returns a new array of strings\
    \ that only contain the strings matching the regular expression regex", "    strings\
    \ = [x for x in strings if substring in x]\nend", "    strings = filter(s -> contains(substring,s),\
    \ strings)\n    return strings\nend\n</cell>\n<text>\nFilter the given vector\
    \ of vectors of strings by only returning ones that match a given substring.",
  "  if length(strings) < 1 \n    return strings\n  elseif length(substring) == 0\
    \ \n    return strings\n  end\n  \n  res = []\n  for str in strings\n    if string.contains(str,\
    \ substring)\n      push!(res, str)\n    end\n  end\n  return res\nend", "  if\
    \ length(strings) == 0 || length(strings[1]) == 0\n    return strings\n  end",
  "    indices = (i for (i, s) in string.enumerate(strings) if contains(s, substring))\n\
    \    keep = filter((i => !isin(i, indices)) for i in indices)\n    \n    return\
    \ take_n(keep, length(indices))\nend\n</cell>\n<code language=julia-1.4>\nfilter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n</cell>\n<code language=julia-1.4>",
  "    \n    string_contains = contains(strings, substring)\n    filtered_strings\
    \ = filter((i) -> string_contains(i), strings)\n    return filtered_strings\n\
    end", "    filter!(x -> contains(substring,x), strings)\n    return strings\n\
    end\n</cell>\n<code language=julia-1.4>\nfilter_by_substring([1,2,3,4],\"e\")\n\
    </cell>\n<text>\n5.4 Exercise: filter using a custom function\nWrite a function\
    \ that returns the index of a string in another string if the string exists in\
    \ the other string.", "    strings = filter_by_strings(strings, substring)\nend",
  "    filter_by_substring(strings, substring, [])\nend", "    \n    # remove strings\
    \ that don't contain substring \n    strings = filter(x->contains(x,substring),\
    \ strings)\n    \n    return strings\nend\n</cell>\n<text>\n3.3 String similarity\
    \ with Jaccard similarity", "    for i in strings\n        if contains(i, substring)\n\
    \            yield i\n        end\n    end\nend", "    \n    # Search the entire\
    \ string and return a list of matches, else return an empty list\n    return strings[findall(x\
    \ -> contains(x,substring), strings)]\nend", "    l = length(strings)\n    filtered\
    \ = Vector{String}(undef, 0)\n    for i in 1:l\n        if strings[i] == substring\n\
    \            push!(filtered, strings[i])\n        end\n    end\n    return filtered\n\
    end", "    to_return = strings[:]\n    to_return = filter( string -> contains(string,\
    \ substring), to_return)\n    return to_return\nend\n</cell>\n<text>\nNow we can\
    \ use the function with any type of string vector.", "    if substring.length\
    \ == 0 || length(substring) == 0 || length(strings) == 0\n        strings = []\n\
    \    end\n    \n    # Step 1. Create a list of all substrings\n    substrings\
    \ = [substring] \n    for str in strings\n        substrings = setdiff(substrings,\
    \ findall(substring, str))\n    end\n    \n    # Step 2. Filter the input strings\n\
    \    strings = filter!(x -> length(x) == 0, strings)\n    strings = filter!(x\
    \ -> x in substrings, strings)\n    \n    # Step 3. Return filtered input strings\n\
    \    return strings\nend\n</cell>\n<code language=julia-1.6>\n\"\"\"\n    filter_by_substrings(strings::Vector{String},\
    \ substrings::Vector{String})", "    return filter!(x -> contains(substring,x),\
    \ strings)\nend", "    strings = [x for x in strings if substring in x]\nend",
  "    for string in strings\n        if string.contains(substring)\n            push!(ret,\
    \ string)\n        end\n    end\n    return ret\nend\n</cell>\n<text>\nPutting\
    \ it all together", "    if length(strings) == 0\n        return strings\n   \
    \ elseif length(strings) >= length(string) && all(string == strings[length(substring)+1:]\
    \ for string in strings)\n        return strings\n    elseif all(string == strings[length(substring)+1:]\
    \ for string in strings)\n        return strings\n    elseif substring in strings[:]\n\
    \        return strings\n    else\n        strings\n    end\nend\n</cell>\n<code\
    \ language=julia-1.3>\nfilter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"\
    ], \"a\")\n</cell>\n<text>\nFilter by length", "    \"\"\"\n    Filter an input\
    \ vector of strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \"\"\"\n    ", "   \
    \ result = filter(elem -> contains(substring, elem), strings)\n    return result\n\
    end", "    return filter_by_substring2(strings, substring, length(strings)==0)\n\
    end\n</cell>\n<code language=julia-1.5>", "    filter!((string) -> string.contains(substring),\
    \ strings)\nend", "    strings = string_filter(strings, substring)\n    return\
    \ strings\nend", "    substring_index = findfirst(isequal(substring), strings)\n\
    \    if substring_index == nothing\n        return strings\n    else\n       \
    \ return strings[substring_index : end]\n    end\nend\n</cell>\n<code language=julia-1.1>\n\
    filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n</cell>\n\
    <code language=julia-1.1>\nfilter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"b\")\n</cell>\n<code language=julia-1.1>\nfilter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"d\")\n</cell>\n<text>\nExercise\nWrite\
    \ a function that counts the occurrences of the letters in the string. For example,\
    \ counting the number of \"a\", \"b\", and \"c\" in the string \"abc\" would return\
    \ 3.", "    if length(strings) == 0 || substring == \"\"\n        return strings\n\
    \    endposition = findfirst(substring, strings)\n    return strings[2:endposition]\n\
    end\n</cell>\n<code language=julia-1.5>\nfilter_by_substring(strings, \"a\")\n\
    </cell>\n<text>\nExercise 7: filter_by_substring(strings::Vector{String}, substring::String)",
  "    if is_string(strings) \n        string_vector = split(strings, \",\")\n   \
    \ else \n        string_vector = strings\n    end\n    string_vector = filter(\
    \ x -> contains(substring,x),string_vector)\n    string_vector = map(x->remove_first(substring,x),\
    \ string_vector)\n    return string_vector\nend ", "    \"\"\"\n    Filter an\
    \ input vector of strings only for ones that contain given substring\n    >>>\
    \ filter_by_substring([], \"a\")\n    []\n    >>> filter_by_substring([\"abc\"\
    , \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n\
    \    \"\"\"\n    length_strings = length(filter_by_substring(strings, \"\"))\n\
    \    strings = strings[length_strings == length(strings)] \n    return strings\n\
    end", "    strings = strings[findall(strings, substring) .!= strings]\n    strings\n\
    end\n</cell>\n<text>\nFiltering a DataFrame column containing strings", "    \"\
    \"\" Filter an input vector of strings only for ones that contain given substring\n\
    \    >>> filter_by_substring([], \"a\")\n    []\n    >>> filter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"\
    ]\n    \"\"\"", "    \n    local retVal = Vector{String}()\n    \n    for string\
    \ in strings\n        if string.contains(substring)\n            retVal[end] =\
    \ string\n        end\n    end\n    \n    return retVal\nend\n</cell>\n<text>\n\
    filter_by_exact_length filters an input vector of strings only for ones that contain\
    \ exactly the given length\nThis function takes the second parameter as an integer,\
    \ which is the expected length of the substring. It returns all strings in the\
    \ input vector that have length equal to the given length.", "    for string in\
    \ strings\n        if string.contains(substring)\n            push!(out, string)\n\
    \        end\n    end\n    return out \nend\n</code>\n<|/ a tags=julia,string\
    \ |>\n<| c |>\nYou don't need the `for` loop at all. The function can be written\
    \ as `filter_by_substring(xs, substring) = filter(x->contains(x, substring), xs)`.\n\
    <|/ c |>\n<| c |>\nThanks for your comment. I am not that familiar with Julia,\
    \ so I did not think of it.\n<|/ c |>\n<| c |>\nIf you don't understand what `filter`\
    \ does, then you really should learn Julia. `filter` is one of the most fundamental\
    \ functions in the language.\n<|/ c |>\n<| c |>\nIt seems like `filter` returns\
    \ a lazy sequence of the items in xs that match the condition (the lambda), whereas\
    \ I need the items in xs to be in the vector returned by the function.\n<|/ c\
    \ |>\n<| a dscore=3 tags=julia,string |>\nYou can also use map, which returns\
    \ a lazy sequence:\n<code>\njulia> filter(x->!(x==\"ab\"), [\"ab\", \"abc\", \"\
    a\"])\n5-element Array{String,1}:\n \"ab\"\n \"abc\"\n</code>\nAs points out in\
    \ a comment, you don't need the for loop. Here, we're simply using the map(x->!(x==\"\
    ab\"), ...) syntax to replace an explicit for loop (which also happens to work\
    \ well here).\n<|/ a |>\n<| c |>\nThanks for your answer! The only issue I see\
    \ is that `x->!(x==\"ab\")` returns `Int` instead of a `Bool`. And since `filter`\
    \ returns an `AbstractArray`, I can't use it as I want.\n<|/ c |>\n<| c |>\nAh,\
    \ yes. I should have used `map` instead of `filter`, since `map` returns a lazy\
    \ sequence. Answer updated.\n<|/ c |>\n<| c |>\nAlso, thanks for the suggestion\
    \ to use `map`.\n<|/ c |>\n<| c |>\nSure. Feel free to mark this as the accepted\
    \ answer by clicking the check mark next to it.\n<|/ c |>\n<| a |>\nAn alternative\
    \ solution is to use regex matching\n<code>\njulia> filter(x->occursin(\"ab\"\
    , x), [\"ab\", \"abc\", \"a\"])\n5-element Array{String,1}:\n \"ab\"\n \"abc\"\
    \n</code>\n<|/ a dscore=2 tags=julia,string |>\n<| c |>\n", "    for i in eachindex(strings)\n\
    \        if contains(strings[i], substring)\n            strings\n        else\n\
    \            deleteat!(strings, i)\n        end\n    end\nend", "    filter!(x\
    \ -> contains(x, substring), strings)\nend", "    filter!(x -> contains(substring,x),\
    \ strings)\nend\n</cell>\n<text>\nExercise #3\nThe function filter_by_substring\
    \ should only consider strings that are substrings of another string. Specifically,\
    \ the function should filter out all strings that have substrings that are not\
    \ substrings of the given string. For example, \"abab\" is a substring of \"aba\"\
    \ but is not a substring of \"abb\".", "    \n    indices = findall(strings, x\
    \ -> contains(x, substring))\n    return subset(strings, indices)\nend", "   \
    \ if length(strings)==0\n        return strings \n    endpt = findfirst(substring,strings)\n\
    \    if endpt==nothing\n        return strings \n    endpt+=length(substring)\n\
    \    ret = copy(strings)\n    ret[endpt:] = strings[endpt+endpt+1:end]\n    drop!(ret,\
    \ endpt)\n    return ret\nend # filter_by_substring", "    if length(strings)\
    \ <= 0\n        return strings\n    \n    if length(substring) == 0 \n       \
    \ return strings\n    endpos = length(strings) - 1\n    \n    startpos = search(substring,\
    \ strings[1])\n    \n    if startpos == endpos \n        return strings\n    endpos\
    \ = startpos\n    \n    tmp = strings[startpos+endpos:end]\n    \n    if length(tmp)\
    \ == 0 \n        return strings\n    endpos = startpos + length(tmp) - 1\n   \
    \ \n    tmp = strings[startpos+endpos:end]\n    \n    if length(tmp) == 0 \n \
    \       return strings\n    endpos = startpos + length(tmp) - 1\n    \n    tmp\
    \ = strings[startpos+endpos:end]\n    \n    if length(tmp) == 0 \n        return\
    \ strings\n    endpos = startpos + length(tmp) - 1\n    \n    tmp = strings[startpos+endpos:end]\n\
    \    \n    if length(tmp) == 0 \n        return strings\n    endpos = startpos\
    \ + length(tmp) - 1\n    \n    tmp = strings[startpos+endpos:end]\n    \n    if\
    \ length(tmp) == 0 \n        return strings\n    endpos = startpos + length(tmp)\
    \ - 1\n    \n    tmp = strings[startpos+endpos:end]\n    \n    if length(tmp)\
    \ == 0 \n        return strings\n    endpos = startpos + length(tmp) - 1\n   \
    \ \n    tmp = strings[startpos+endpos:end]\n    \n    if length(tmp) == 0 \n \
    \       return strings\n    endpos = startpos + length(tmp) - 1\n    \n    tmp\
    \ = strings[startpos+endpos:end]\n    \n    if length(tmp) == 0 \n        return\
    \ strings\n    endpos = startpos + length(tmp) - 1\n    \n    tmp = strings[startpos+endpos:end]\n\
    \    \n    if length(tmp) == 0 \n        return strings\n    endpos = startpos\
    \ + length(tmp) - 1\n    \n    tmp = strings[startpos+endpos:end]\n    \n    if\
    \ length(tmp) == 0 \n        return strings\n    endpos = startpos + length(tmp)\
    \ - 1\n    \n    tmp = strings[startpos+endpos:end]\n    \n    if length(tmp)\
    \ == 0 \n        return strings\n    endpos = startpos + length(tmp) - 1\n   \
    \ \n    tmp = strings[startpos+endpos:end]\n    \n    if length(tmp) == 0 \n \
    \       return strings\n    endpos = startpos + length(tmp) - 1\n    \n    tmp\
    \ = strings[startpos+endpos:end]\n    \n    if length(tmp) == 0 \n        return\
    \ strings\n    endpos = startpos + length(tmp) - 1\n    \n    tmp = strings[startpos+endpos:end]\n\
    \    \n    if length(tmp) == 0 \n        return strings\n    endpos = startpos\
    \ + length(tmp) - 1\n    \n    tmp = strings[startpos+", "    # Precondition:\
    \ len(strings) > 0 and len(substring) > 0\n    \n    if contains(strings, substring)\
    \ == false\n        return strings # Nothing to filter through\n    \n    strings_new\
    \ = copy(strings)\n    \n    for i in 1:length(strings)\n        if contains(strings_new[i],\
    \ substring) == false\n            deleteat!(strings_new, i) # Remove from string\n\
    \        end\n    end\n    \n    return strings_new\nend", "    if length(strings)\
    \ < 1 || length(substring) == 0 \n        return strings \n    end\n    if length(substring)\
    \ == 1 \n        return [string for string in strings if string.startswith(substring)]\
    \ \n    else \n        substring = substring \n        indices = [i for (i, x)\
    \ in enumerate(strings) \n                   if x.startswith(substring) \n   \
    \                and length(x) == length(substring)] \n        indices = union(indices,\
    \ range(length(strings)))\n        return filter_by_substring(strings[indices],\
    \ substring) \n    end\nend", "    filter_by_substring = for s in strings do \n\
    \        if contains(s, substring) then s end\n    end\nend\n</cell>\n<code language=julia-1.3>\n\
    filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n</cell>\n\
    <text>\nWe will make use of the function filter_by_substring() to filter out all\
    \ the empty strings. So our final list will contain only the strings that we want.\
    \ We can use ismissing() to check for missing elements and return an empty array\
    \ when a string is missing, otherwise we return the string", "    if length(filter(str\
    \ -> str == substring, strings)) == 0\n        return strings\n    else\n    \
    \    string_lengths = map(str -> length(split(str, substring)), strings)\n   \
    \     return filter((x) -> sum(string_lengths) == x, strings)\n    end\nend\n\
    </cell>\n<text>\nA final version of filter_by_substring using pattern matching:",
  "    # return an empty vector if there are no matches\n    if length(strings) <\
    \ 1 || length(substring) == 0 || substring == \"\" \n        return strings\n\
    \    end\n    \n    # create a set of all unique substrings\n    setSubstrings\
    \ = Set[String]()\n    \n    for string in strings \n        setSubstrings.add(substring)\n\
    \    end", "    if length(strings) == 0:\n        return []\n    \n    substring\
    \ = lowercase(substring)\n    strings = map(lowercase(strings), strings)\n   \
    \ \n    filtered_strings = filter(s -> contains(s, substring), strings)\n    return\
    \ strings[findall(x -> x == strings[1], filtered_strings)]\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    return filter((x->contains(x,substring)),strings)\n\
    end", "    #filter_by_substring(strings,substring)\n    filter_vector = Vector{String}(undef,\
    \ 0)\n    for (index, elem) in enumerate(strings)\n        if contains(elem, substring)\n\
    \            filter_vector[index] = elem\n        end\n    end\n    return filter_vector\n\
    end\n</cell>\n<code language=julia-0.4>\nfilter_by_substring([\"abc\", \"bacd\"\
    , \"cde\", \"array\"], \"a\")\n</cell>\n<code language=julia-0.4>\nfilter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"d\")\n</cell>\n<text>\nfilter function\
    \ filters out every element that does not satisfy a given condition", "    return\
    \ filter(x -> contains(x, substring), strings)\nend", "    if contains(strings,\
    \ substring)\n        strings\n    else\n        []\n    end\nend\n</cell>\n<code\
    \ language=julia-1.3>\nfilter_by_substring([1, 3, 5], \"b\")\n</cell>\n<code language=julia-1.3>\n\
    filter_by_substring([1, 3, 5], \"c\")\n</cell>\n<code language=julia-1.3>\nfilter_by_substring([1,\
    \ 3, 5], \"d\")\n</cell>\n<code language=julia-1.3>\nfilter_by_substring([1, 3,\
    \ 5], \"d\")\n</cell>\n<text>\n5. Filter the elements of an array", "    filter!(x\
    \ -> contains(x, substring), strings)\nend\n</cell>\n<code language=julia-0.4>\n\
    filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n</cell>\n\
    <text>\nFinding an element in an array\nTo find an element in an array, you can\
    \ use filter or find:", "    filter!(string -> contains(string, substring), strings)\n\
    end", "    \n    \n    for i in 1:length(strings)\n        if contains(strings[i],\
    \ substring)\n            append!(strings_filtered, strings[i])\n        end\n\
    \    end\n    return strings_filtered\nend\n</cell>\n<code language=julia-1.5>\n\
    filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n</cell>\n\
    <text>\nWrite a function filter_by_word that filters an input vector of strings\
    \ only for ones that contain the given word as a substring (case insensitive)",
  "    strings = filter(x -> contains(substring,x), strings)\n    strings = filter(x\
    \ -> contains(substring,x), strings)\n    strings = filter(x -> contains(substring,x),\
    \ strings)\n    return strings\nend", "    strings = [i for i in strings if contains(substring,i)]\n\
    \    return strings\nend\n</cell>\n<code language=julia-1.5>", "  \n    length_to_keep\
    \ = maximum(map(len, strings)) - 1\n    filtered_strings = Vector{String}(undef,\
    \ 0)\n    \n    for str in strings\n        if all(substring in str for substring\
    \ in substrings)\n            push!(filtered_strings, str)\n        end\n    end\n\
    \    \n    filtered_strings[length_to_keep:]\nend\n</cell>\n<code language=julia-1.5>\n\
    filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n</cell>\n\
    <text>\n3. Filtering input vectors for elements that meet some set of conditions",
  "    \n    function contains_substring(substring::String, value::String)::Bool \n\
    \        contains_substring(value) && contains(substring) \n    end\n    \n  \
    \  filter_by_substring(strings, substring)\nend\n</cell>\n<cell>\n# TEST Filter\
    \ by Substring (2b)\n@testset \"Filter by Substring (2b)\" begin\n    filter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    filter_by_substring([\"abc\"\
    , \"bacd\", \"cde\", \"array\"], \"array\")\nend\n</cell>\n<text>\nImplement a\
    \ filtering function which filters an array of integers using a given comparison\
    \ function and returns the result.", "    strings = vec(strings)\n    \n    idxs_substring\
    \ = findall(strings, substring)\n    idxs_substring = [idxs_substring[j] for j\
    \ = 1:length(strings)]\n    \n    strings = filter_strings(strings, idxs_substring)\n\
    \    \n    return strings\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\nFilters\
    \ strings list by a set of indices. \n    \n    Params:\n    - strings - a list\
    \ of strings (characters)\n    - idxs_subset - a list of indices (integers) indicating\
    \ \n        which strings in the input list are to be filtered\n        \n   \
    \ Returns:\n    - filtered_strings - a list of strings filtered according \n \
    \       to the list of indices\n\"\"\"", "    included = filter_by_string(strings,\
    \ substring)\n    excluded = filter_by_string(strings, substring)\n    return\
    \ append(included, excluded)\nend", "    if length(strings)>0\n        \n    \
    \    for string in strings\n            if contains(string, substring)\n     \
    \           return strings\n            end\n        end\n    end\n    return\
    \ strings\nend", "    \n    strings = strings |> Vector{String}", "    \n    idx\
    \ = strings == substring\n    strings[idx]\nend\n</cell>\n<code language=julia-1.5>\n\
    filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n</cell>\n\
    <text>\nExercise\nFilter an array of strings to have only strings that end with\
    \ the letter \"a\". Print the result to check your work.", "    filter(i -> contains(substring,strings[i]),\
    \ 1:length(strings))\nend", "    length(strings)==0 || length(substring)==0 ||\
    \ !isdefined(substring) || !isdefined(strings) \n        strings \n    else \n\
    \        filter(x -> containsstring(x, substring), strings) \nend\n</cell>\n<text>\n\
    filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"ab\") returns [\"\
    abc\", \"bacd\", \"array\"]", "    \"\"\"Filter an input vector of strings only\
    \ for ones that contain given substring\"\"\"\n    strings = strings[findall(x\
    \ -> substring in x, strings)]\n    return strings\nend\n</cell>\n<text>\nThis\
    \ function can be used to filter out all words that have any substrings in them\
    \ from the input vector", "    strings = [x for x in strings if substring in x]\n\
    \    return strings\nend\n</cell>\n<code language=julia-0.6>", "    strings =\
    \ filter(x -> contains(x, substring), strings)\nend", "    filter (string -> string.find(substring)\
    \ > -1) strings\nend\n</cell>\n<text>\nExercise\nTry implementing your own filter_by_substring\
    \ function using a loop for filtering the input vector of strings.", "       \
    \ local index=0\n        for str in strings do\n            if (string.find(str,substring)==1)\
    \ then\n                index+=1\n            end\n        end\n        if (index==0)\
    \ then\n            return []\n        else\n            return strings[index..end]\n\
    \        end\n    end\n</cell>\n<text>\nExercise 3:\nWrite a function that:\n\
    filter_by_substring() filters out any strings that do not contain given substring\
    \ (i.e. remove them).\nfilter_by_uppercase() filters out any strings that do not\
    \ contain uppercase letters.", "    for s in strings\n        if contains(s, substring)\n\
    \            return strings\n    end\n    return []\nend\n</cell>\n<cell>\nfilter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n</cell>\n<text>\n\u0420\u0435\u0437\
    \u0443\u043B\u044C\u0442\u0430\u0442\u044B filter_by_substring", "    if (length(substring)==0)\n\
    \        return strings\n    end\n    for s in strings\n        if (strcontains(s,substring))\n\
    \            return strings\n        end\n    end\n    return []\nend\n</cell>\n\
    <text>\nfilter_by_substring\nThis function is implemented using list comprehensions\
    \ in Julia. Here is an example:", "    strings[strings == substring] \nend\n</cell>\n\
    <code language=julia-0.5>\nfilter_by_substring([\"a\", \"ab\", \"acd\", \"acde\"\
    ], \"a\")\n</cell>\n<code language=julia-0.5>", "    substrings = filter( x ->\
    \ contains(x,substring), strings)\n    length(substrings) == 0 ? strings : substrings\n\
    end", "    if filter_by_substring(strings, substring) == strings\n        filter(strings,\
    \ x -> contains(x, substring))\n    end\nend\n</code>\nI realized that there could\
    \ be an issue with substrings being too long. One can still solve it using issubset,\
    \ but here is a better way to do it using sets. First, get all unique substrings\
    \ of a given string, say by using the function substrings\n<code>", "    filter_by_substring\
    \ = (filter . filter_indices)(\n        map(x->x==substring, 1:length(strings)),\
    \ \n        1:length(strings), \n        function(index) strings[index]\n    )\n\
    \    return filter_by_substring(strings)\nend", "        \n    filtered_strings\
    \ = Vector{String}()\n    \n    for string in strings\n        if contains(string,\
    \ substring) == true\n            push!(filtered_strings, string)\n        end\n\
    \    end\n    \n    return filtered_strings\nend", "    return filter_by_substring2(strings,\
    \ substring, true)\nend", "  result = []\n  for s in strings \n    if contains(s,\
    \ substring) \n      result.append(s)\n    end\n  end\n  result\nend\n</cell>\n\
    <code language=julia-1.3>", "    filtered_string = strings[]\n    for string in\
    \ strings\n        if contains(string, substring)\n            push!(filtered_string,\
    \ string)\n        end\n    end\n    return filtered_string\nend\n</cell>\n<code\
    \ language=julia-1.5>\nfilter_by_substring([string(\"abc\"), string(\"bacd\"),\
    \ string(\"cde\"), string(\"array\")], \"a\")\n</cell>\n<text>\nFiltering vectors\n\
    Filtering a vector of strings according to a condition is now straightforward:",
  "    return filter(x->contains(x, substring), strings)\nend\n</cell>\n<text>\nAs\
    \ the last exercise we will apply this function to all vectors in our dataset.",
  "    for i in eachindex(strings)\n        if contains(strings[i], substring)\n \
    \           delete!(strings, i)\n        end\n    end\n    return strings\nend\n\
    </cell>\n<code language=julia-1.5>\nfilter_by_substring([\"abc\", \"bacd\", \"\
    cde\", \"array\"], \"a\")\n</cell>\n<code language=julia-1.5>", "    if length(substring)\
    \ == 0 \n        return strings \n    \n    filtered = filter(s -> include(substring,\
    \ s), strings)\n    if length(filtered) == 0 \n        return strings \n    else\
    \ \n        return filtered \nend\n</cell>\n<text>\nfilter function\nfilter()\
    \  filters the elements of an array for those that satisfy a certain condition\
    \ (here s -> include(substring, s))", "    filter!(x -> contains(x, substring),\
    \ strings)\nend\n</cell>\n<text>\nfilter_by_substring", "    for string in strings\
    \ \n        if contains(string, substring) \n            yield string \n     \
    \   end\n    end\nend\n</cell>\n<code language=julia-0.4>\nfilter_by_substring(strings,\
    \ \"a\")\n</cell>\n<text>\nThe function below does what its name suggests: it\
    \ removes all the strings in a given vector that do not contain a given substring.",
  "    strings = filter(s -> contains(s, substring), strings)\nend", "    \"\"\" Filter\
    \ an input vector of strings only for ones that contain given substring\n    >>>\
    \ filter_by_substring([], \"a\")\n    []\n    >>> filter_by_substring([\"abc\"\
    , \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n\
    \    \"\"\"", "  result = []\n  for i in strings\n    if contains(i, substring)\
    \ == true\n      push!(result, i)\n    end\n  end\n  return result\nend", "  \
    \  matches = findall(strings, substring)\n    keep_strings = filter((s) => !contains(strings,\
    \ s), matches)\n    return keep_strings\nend\n</cell>\n<cell>\n\"\"\"\n    filter_by_substring(strings::Vector{String},\
    \ substring::Function, caseSensitive::Bool = false)::Vector{String}", "    \n\
    \    strings::Vector{String} - input vector of strings\n    substring::String\
    \ - substring to look for in strings\n    \n    return vector of strings containing\
    \ substring\nend\n</cell>\n<code language=julia-1.5>\nfilter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n</cell>\n<text>\nFilter by a set\
    \ of characters", '    return filter((item) => item contains substring, strings)',
  "    \n    if strings == []\n        \n    return strings\n    else\n        \n\
    \    filtered_strings = []\n    \n    for s in strings\n        if contains(substring,s)\n\
    \            filtered_strings.push(s)\n        end\n    end\n    return filtered_strings\n\
    end", "    \n    if length(strings) == 0\n        return strings\n    elseif length(strings)\
    \ == 1\n        if strings[1] == substring\n            return strings\n     \
    \   else\n            return []\n        end\n    elseif isa(strings[1], String)\n\
    \        return strings\n    end\n    \n    length_index = [i for (i, string)\
    \ in enumerate(strings) if isa(string, String)]\n    \n    index = length_index[1]\n\
    \    \n    for (i in length_index[2:end])\n        if strings[i] != substring\n\
    \            index = i\n            break\n        end\n    end\n    \n    string_copy\
    \ = copy(strings[index:])\n    \n    strings[index:] = []\n    \n    return string_copy\n\
    end", "    if length(strings) == 0 || length(strings) == 1 \n        return strings\n\
    \    endstring = length(strings)\n    filtered_strings = Vector{String}(undef,\
    \ endstring)\n    for i in 1:endstring\n        if all(string(strings[i]) .==\
    \ substring) \n            filtered_strings[i] = strings[i]\n        else\n  \
    \          filtered_strings[i] = \"\"\n        end\n    end\n    return filtered_strings\n\
    end\n</cell>\n<text>\nFiltering by a regular expression\nThe function filter_by_regex\
    \ filters an array of strings using a regular expression. The function returns\
    \ a vector containing the strings which match the regular expression. It returns\
    \ an empty vector if there are no strings which match the regular expression.\
    \ Here is an example.", "    filter_by_substring(strings, substring, length(substring))\n\
    end", "        if string == substring\n            string\n        else\n    \
    \        filter_by_substring(strings, substring)\n        end\n    end\nend",
  "    if string == substring\n        strings\n    else\n        filter_by_substring(reverse(strings),\
    \ substring)\n    end\nend\n</cell>\n<text>\nExercise 10\nWhat is the length of\
    \ the longest substring contained in the input vector of strings? Remember that\
    \ it is possible that a substring occurs more than once. Write a function which\
    \ returns the length of a substring of a given string only once. Do this by using\
    \ filter_by_substring!.", "    if string == substring \n        strings \n   \
    \ else \n        filter(x -> x contains substring, strings)\n    end\nend\n</cell>\n\
    <code language=julia-1.5>", "    \n    matches = []\n    \n    for s in strings\n\
    \        if contains(s, substring)\n            push!(matches, s)\n        end\n\
    \    end", "    \"\"\"\n    Filter the given vector for strings that contain the\
    \ substring given\n    \"\"\"\n    for string in strings\n        if contains(string,\
    \ substring)\n            push!(output, string)\n        end\n    end\n    return\
    \ output\nend", "    filter_vec = Vector{String}()\n    for str in strings\n \
    \       if str == substring\n            push!(filter_vec, str)\n        end\n\
    \    end\n    return filter_vec\nend\n</cell>\n<text>\nExercise 6\nWrite a function\
    \ that replaces given substring with replacement. You may use the function provided\
    \ in the string package. For example:", "    return filter((x) -> contains(x,\
    \ substring), strings)\nend", "    \n    filtered_strings = Vector{String}()",
  "    \"\"\"Filter an array of strings down to the ones containing substring\n  \
    \  >>> filter_by_substring([\"\", \"abc\", \"bacd\", \"cde\", \"array\"], \"a\"\
    )\n    [\"abc\", \"array\"]\n    \"\"\"\n</code>\n<|/ a dscore=1 |>\n<| a |>\n\
    I wrote a quick function that works in both Python 2 and 3:\n<code>\ndef filter_by_substring(strings:\
    \ list, substring: str) -> list:\n    return [s for s in strings if substring\
    \ in s]\n</code>\n<|/ a tags=python,string,filter dscore=1 |>\n<| a tags=python,string,filter\
    \ |>\nIn python2 the .split method will split the string on any whitespace character.\n\
    <code>\nstr_list = [\"this\", \"is a\", \"test\"]\nsub = \"test\"", "    strings\
    \ = filter(x->contains(x,substring), strings)\nend", "  if length(strings)==0\n\
    \    return strings\n  if length(strings)==1\n    return strings\n  if strings[1]\
    \ == substring\n    return filter_by_substring(strings[2:end], substring)\n  end\n\
    \  if strings[1] == substring[1]\n    return filter_by_substring(strings[2:end],\
    \ substring)\n  end\n  return filter_by_substring(strings[2:end], substring)\n\
    end", "    for string in strings\n        if string.contains(substring)\n    \
    \        push!(strings, string)\n        end\n    end\n    return strings\nend\n\
    </cell>\n<code language=julia-0.5>\n# Let's see it work!\nfilter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n</cell>\n<text>\nIn Julia, there\
    \ are a couple different ways to write loops. One is the for loop:", "    \n \
    \   strings = [string for string in strings if substring in string]\n    \nend",
  "    \n    substrings = Set()\n    \n    for str in strings\n        if contains(str,\
    \ substring)\n            push!(substrings, str)\n        end\n    end\n    \n\
    \    return filter(x -> !x in substrings, strings)\nend\n</cell>\n<code language=julia-1.5>",
  "    if length(substring) > length(strings[1]) || length(substring) < 1 \n     \
    \   error(\"Substring length must be greater than 0 and must be greater than or\
    \ equal to the length of the input string\")\n    end\n    filtered_strings =\
    \ []\n    for str in strings\n        if contains(substring,str)\n           \
    \ filtered_strings.push(str)\n        end\n    end\n    return filtered_strings\n\
    end", "    \n    str = \"\"\n    for i in strings\n        if contains(i, substring)\n\
    \            str = str + i\n        end\n    end\n    \n    return str\nend",
  "    answer = copy(strings)\n    for string in answer do\n        if contains(string,\
    \ substring) then\n            remove(string, substring)\n        end\n    end\n\
    \    return answer\nend", "    substrings = map(s, substring)\n    filtered_strings\
    \ = filter(s, strings)\n    map(filtered_strings, filter_by_substring, substrings)\n\
    end\n</cell>\n<code language=julia-0.5>\nfilter_by_substring([1, 3, 5], [1, 3])\n\
    </cell>\n<text>\nExercise 1.11: Counting substrings\nGiven a vector of strings,\
    \ count how many times each substring appears.", "    strings = filter( x -> occursin(\
    \ substring, x ), strings )\n    return strings\nend\n</cell>\n<code language=julia-1.5>\n\
    filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n</cell>\n\
    <text>\nfilter_by_occurrence(input_vector, sub_vector)\n  Filter a vector for\
    \ elements that occur only in another vector\n  Returns an empty vector if the\
    \ two input vectors do not contain any elements in common.", "    for s in strings\
    \ \n        if contains(s, substring)\n            append!(result, s)\n      \
    \  end\n    end\n    return result\nend\n</cell>\n<text>\nExercise: Write a filter_by_all_substrings\
    \ function that takes a list of strings and a substring, and returns the list\
    \ of strings filtered to only contain strings that contain all of the substrings\
    \ in that list. Remember to return a list of strings and not a list of lists of\
    \ strings. Feel free to use the function you just wrote!", "    if (string in\
    \ strings) == false\n    return strings\n    endpos = find(strings, substring)\n\
    \    if endpos == length(substring)\n        return strings\n    else\n      \
    \  return strings[endpos+1 : end]\n    end\nend\n</cell>\n<code language=julia-0.6>\n\
    filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n</cell>\n\
    <code language=julia-0.6>\n# %load solutions/filter_by_substring.jl\n</cell>\n\
    <text>\nFiltering for \"array\" only using filter_by_substring", "    filter(x->contains(substring,x),\
    \ strings)\nend\n</cell>\n<text>\nfilter_by_substring", "    filter(x -> substring\
    \ in x, strings)\nend\n</cell>\n<code language=julia-0.4>\nfilter_by_substring([1,\
    \ 2, 3, 4], \"2\")\n</cell>\n<code language=julia-0.4>\nfilter_by_substring([4,\
    \ 5, 6, 7], \"2\")\n</cell>\n<text>\nThe opposite of filter is to remove, using\
    \ setdiff, elements that match a given condition:", "    return [ x for x \u2208\
    \ strings if contains(x, substring) ]", "  new_strings = copy(strings)\n  for\
    \ s in strings\n    if contains(s, substring)\n      push!(new_strings, s)\n \
    \   end\n  end\n  return new_strings\nend\n</cell>\n<code language=julia-0.6>\n\
    filter_by_substring(x->x, \"a\")\n</cell>\n<code language=julia-0.6>\nfilter_by_substring(x->x,\
    \ \"abc\")\n</cell>\n<text>\nExercise 4", "    strings_substring = filter(x->(x\
    \ \u2208 substring), strings)\n    strings_substring_not_in_substring = filter(x->!(x\u2208\
    \ substring), strings)\n    return union(sort(strings_substring), sort(strings_substring_not_in_substring))\n\
    end", "\"\"\"Filter out elements of a list that do not contain given substring.\
    \ \"\"\"\n    ", "    strings = filter(x->contains(x, substring), strings)\nend\n\
    </cell>\n<code language=julia-0.6>", "    if length(substring) == 0 \n       \
    \ return strings \n    else \n        substring = lower(substring) \n        filtered\
    \ = filter_by_substring(strings, substring) \n        return filter_by_substring(filtered,\
    \ substring) \n    end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\nFilters\
    \ an array of strings based on whether a string contains a given substring. \n\
    Returns an array of strings that do not contain the given substring. ", "    for\
    \ str in strings \n        if contains(str, substring) \n            push!(result,\
    \ str) \n        end\n    end\n    result\nend\n</code>\n<|/ a tags=list,string,julia\
    \ |>\n<| c |>\nIt works only if you input a string, not a list. For example, if\
    \ I run `filter_by_substring([[1, 2, 3], [4, 5], [6, 7]], '3')`, I get the error\
    \ message: `MethodError: no method matching filter_by_substring(::Type{Array{Any,1}},\
    \ ::Symbol)`\n<|/ c |>\n<| c |>\nThat's because `filter_by_substring` expects\
    \ a string. If you're calling it on a list of strings (which is what I'd assumed\
    \ you were doing), you can call `map` instead of `filter`.\n<|/ c |>\n<| a dscore=1\
    \ |>\nI recommend you use this Julia package, which implements a lot of efficient\
    \ string matching algorithms:\nhttps://github.com/tmandel/StringMatching.jl\n\
    <|/ a tags=list,string,julia |>\n<| a tags=list,string,julia |>\n<code>", "  \
    \  if length(strings) < 1 \n        return strings\n    if !contains(substring,strings[1])\n\
    \        return strings\n    else\n        substring = substring(1:length(substring))\n\
    \        \n        strings = strings[2:end]\n        filter_by_substring(strings,substring)\n\
    \    end\nend", "    \n    for string in strings \n        if (contains(string,\
    \ substring))\n            push!(strings, string)\n        end\n    end\n    \n\
    \    return strings\nend\n</cell>\n<text>\nThe filter function can be easily extended\
    \ for matching any substring, by just changing the contains call to any (which\
    \ returns a boolean true/false).", "    if length(filter(x -> contains(x, substring),\
    \ strings)) == length(strings)\n        return strings\n    else\n        return\
    \ []\n    end\nend\n</cell>\n<text>\n\u0422\u0435\u043F\u0435\u0440\u044C \u0441\
    \u043E\u043E\u0431\u0449\u0430\u0435\u043C \u0432\u043D\u0438\u043C\u0430\u043D\
    \u0438\u0435, \u0447\u0442\u043E \u043F\u043E\u0441\u043B\u0435 \u0438\u0437\u043C\
    \u0435\u043D\u0435\u043D\u0438\u044F \u0444\u0443\u043D\u043A\u0446\u0438\u0438\
    \ filter_by_substring \u0432\u044B \u043C\u043E\u0436\u0435\u0442\u0435 \u043F\
    \u0440\u0438\u043C\u0435\u043D\u0438\u0442\u044C \u044D\u0442\u043E\u0442 \u0432\
    \u0430\u0440\u0438\u0430\u043D\u0442 \u0434\u0440\u0443\u0433\u043E\u043C\u0443\
    \ \u043F\u0440\u0438\u043C\u0435\u0440\u0443 \u0432 \u0442\u0435\u0441\u0442\u0435\
    . \u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0439\u0442\u0435 \u0442\u0435\
    \u0441\u0442\u043E\u0432\u044B\u0439 \u043F\u0440\u0438\u043C\u0435\u0440:", " \
    \   return filter((x) -> contains(x, substring), strings);\nend", "    \n    if\
    \ contains(substring,strings)\n        \n        push!(newstrings,strings[find(strings,\
    \ substring)])\n        newstrings = uniq(newstrings)\n    end\n    \n    return\
    \ newstrings\nend", "    return filter(x -> contains(substring,x), strings)\n\
    end\n</cell>\n<cell>\n@test filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\") === [\"abc\", \"bacd\", \"array\"]\n</cell>\n<text>\n4.5 Combining\
    \ Functions\n4.5.1 Function composition\nThe function composition operator is\
    \ defined as $f\u2218g\u2218h$, where $f \u2218 g\u2218 h$ is the function composition\
    \ operator. Given two functions, $f$ and $g$, the composition is of the form $f\u2218\
    g$ and can be denoted $fg$ (the latter is abbreviated to $fg$).", "    if length(strings)\
    \ == 0\n        return strings\n    endIndex = findfirst(substring, strings)\n\
    \    if endIndex < 0\n        return strings\n    endIndex += length(substring)\n\
    \    firstIndex = endIndex\n    return strings[firstIndex:end]\nend\n</cell>\n\
    <text>\nfilter_by_regex\nSame as filter_by_substring, but filters strings that\
    \ match the given regular expression.", "    strings = filter(x -> substring in\
    \ x, strings)\n    return strings\nend\n</cell>\n<code language=julia-1.4>\nfilter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n</cell>\n<code language=julia-1.4>\n\
    filter_by_substring([1,2,3], 2)\n</cell>\n<text>\nExercise: Create your own filter\
    \ by substring function", "    \n    string <- StringTools.join(strings)\n   \
    \ \n    strings[\n        findall(x->contains(x, substring), string)\n    ]\n\
    end", "    filtered_strings = copy(strings)\n    for string in strings\n     \
    \   if contains(string, substring)\n            filtered_strings -= 1\n      \
    \  end\n    end\n    return filtered_strings\nend\n</cell>\n<code language=julia-1.5>\n\
    # test our filter function\nfilter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n</cell>\n<text>\nExercise 9\nWrite a function that converts\
    \ a list to a set and back\nWrite a function that converts a set to a dictionary\
    \ and back\nWrite a function that converts a dictionary to a set and back", " \
    \   strings = filter((x) -> contains(x, substring), strings)\n    return strings\n\
    end\n</cell>\n<code language=julia-1.5>\nfilter_by_substring([[\"abc\", \"bacd\"\
    , \"cde\"], [\"a\"], [\"bcd\"]], \"a\")\n</cell>\n<code language=julia-1.5>\n\
    filter_by_substring([[\"abc\", \"bacd\", \"cde\"], [\"a\"], [\"bcd\"]], \"bacd\"\
    )\n</cell>\n<text>\nFiltering vectors\nFiltering vector is quite simple:", " \
    \   strings = [strings[i] for i in which(strings ~= substring)] \nend\n</cell>\n\
    <code language=julia-0.4>\nfilter_by_substring(strings, \"a\")\n</cell>\n<text>\n\
    filter_by_substring also works for arrays of numbers:", "\treturn  filter((x)\
    \ -> contains(x, substring), strings)\nend\n</cell>\n<code language=julia-1.5>\n\
    filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n</cell>\n\
    <code language=julia-1.5>\nusing BenchmarkTools", "    \n    for i in eachindex(strings)\n\
    \        if contains(strings[i], substring)\n            push!(strings, strings[i])\n\
    \        end\n    end\n    return strings\nend\n</cell>\n<text>\n\u0417\u0430\u043F\
    \u0443\u0441\u043A\u0430\u0435\u043C \u0442\u0435\u0441\u0442\u044B", "    strings\
    \ = [s for s in strings if substring in s]\n    return strings\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"\nfilter_by_substring(strings::Vector{String},\
    \ substring)::Vector{String} ", "    length(strings) == 0 && return strings\n\
    \    length(strings) < 2 || return strings\n    strings[2:end-1] .== substring\n\
    end", "    length(strings) > 0 && \n    contains(strings, substring) && \n   \
    \ remove!(strings, x -> x != substring)\nend\n</cell>\n<code language=julia-0.4>\n\
    filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n</cell>\n\
    <text>\nExercise 1: filter_by_substring()", "    substrings = [substr for str\
    \ in strings for substr in split(str)]\n    return filter(x->contains(substrings,\
    \ x), strings)\nend", "    if substring in strings[i]\n        strings\n    else\n\
    \        []\n    end\nend", "    filter((string -> string.contains(substring)),\
    \ strings)\nend\n</cell>\n<text>\n3.3. remove_duplicates function\nWrite a function\
    \ that removes duplicate elements from an input vector.", "    for str in strings\
    \ \n        if contains(str, substring) == true\n            return str\n    \
    \    end\n    end\n    return []\nend\n</code>\n<|/ a tags=julia,string,filter,function\
    \ dscore=2 |>\n<| a |>\nIn Julia v1.0 onwards, you can use filter:\n<code>\njulia>\
    \ filter(x -> ends_with(x,\"ed\"), [\"eidd\",\"ed\",\"edd\"])\n5-element Vector{String}:\n\
    \ \"eidd\"\n \"ed\"\n \"edd\"\n</code>\nends_with is a function that returns true\
    \ if the argument ends with the last character of the string.  filter applies\
    \ a function to each element of an array.\n<|/ a tags=julia,string,filter,function\
    \ dscore=2 |>\n<| a dscore=2 |>\nIn Julia v0.6 this worked for me:\n<code>\njulia>\
    \ strings = [\"eidd\", \"ed\", \"edd\"]\n2-element Vector{String}:\n \"eidd\"\n\
    \ \"ed\"", "    length_to_keep = length(substring)\n    if length(strings) < length_to_keep\n\
    \        return strings\n    else\n        return filter_by_substring(filter_by_substring(strings[start:end-1],\
    \ substring), substring)\n    end\nend\n</cell>\n<code language=julia-1.4>", " \
    \   \n    for i in eachindex(strings) \n        if contains(strings[i], substring)\
    \ \n            strings \n        else \n            remove!(strings, i) \n  \
    \          \n    end\nend", "    if isempty(strings) || isempty(substring)\n \
    \       return strings\n    end\n    strings = filter_(x -> isequal(substring,\
    \ x), strings)\n    return strings\nend", "    strings = filter((x) -> (contains(x,substring)),\
    \ (strings))\nend\n</cell>\n<code language=julia-1.2>\n\"\"\"\n    filter_by_substring(strings::Vector{String},\
    \ substring::Regex)\n    Filter a vector of strings containing given substring\
    \ using regex\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"\
    ], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \"\"\"", "    for i in eachindex(strings)\
    \ \n        if contains(strings[i], substring) \n            strings \n      \
    \  else \n            deleteat!(strings, i) \n    end \nend \n</cell>\n<code language=julia-1.4>\n\
    filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n</cell>\n\
    <text>\n\u0420\u0430\u0431\u043E\u0442\u0430 \u0441 \u043A\u043E\u0440\u0442\u0435\
    \u0436\u0435\u0439", "    string_vecs = strings[:]\n    for i in length(string_vecs)\
    \ \n        if contains(string_vecs[i], substring) == true \n            string_vecs[i]\
    \ = \"\"\n        end\n    end\n    return string_vecs\nend\n</cell>\n<cell>\n\
    \"\"\"\n    filter_by_substring(string_vecs::Vector{String}, substring::String)::Vector{String}",
  "    answer = filter!(x -> contains(x, substring), strings)\n    return answer\n\
    end\n</cell>\n<code language=julia-1.6>\n@test filter_by_substring([], \"a\")\
    \ \u2245 []\n@test filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"\
    ], \"a\") \u2245 [\"abc\", \"bacd\", \"array\"]\n</cell>\n<text>\n3. find()\n\
    find method returns index in vector where given predicate returns true, returns\
    \ nothing if not found.", "    \n    strings = sort(strings)\n    strings = filter((string)\
    \ -> (substring in string), strings)\n    return strings\nend", "    substrings\
    \ = split(substring, \"b\")\n    filtered_strings = []\n    for s in strings\n\
    \        if contains(substrings, s)\n            push!(filtered_strings, s)\n\
    \        end\n    end\n    filtered_strings\nend\n</cell>\n<code language=julia-1.6>\n\
    filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n</cell>\n\
    <text>\nfilter_by_substring\n Function  Description ", "    filter_by_substring(strings,\
    \ substring) == map(string) do str\n        if contains(substring, str)\n    \
    \        str\n        else \n            str\n        end\n    end\nend\n</cell>\n\
    <text>\nSort an input vector of strings according to a given sorting function\n\
    (Note: this function is identical to the sort function in Julia).", "    strings\
    \ = [s for s in strings if substring in s]\nend", "    length(strings) <= 0 ?\
    \ strings : filter_by_substring(strings[2:end-1], substring)\n    return if isa_string_vector(strings)\
    \ \n        strings == substring ? [] : strings\n    end\nend", "    \n    filtered_strings\
    \ = Vector{String}()\n    \n    for s in strings\n        if contains(substring,\
    \ s)\n            push!(filtered_strings, s)\n        end\n    end\n    \n   \
    \ return filtered_strings\nend\n</cell>\n<text>\n6. Create a function that takes\
    \ a vector of strings as an argument and returns a vector of strings that contain\
    \ \"o\"\n    >>> takes_strings(\"abcde\")\n    [\"abc\", \"cde\"]\n    >>> takes_strings([\"\
    abc\", \"cde\"])\n    [\"abc\", \"cde\"]\n    >>> takes_strings([123,\"abc\",\
    \ \"cde\"])\n    [\"abc\", \"cde\"]\n    >>> takes_strings([\"abcde\", \"1234\"\
    , \"d\"])\n    []\n    >>> takes_strings([\"abcde\", \"1234\", \"d\", \"1234\"\
    ])\n    []\n    \"\"\"", "    if length(strings) == 0\n        return []\n   \
    \ ends_with = false\n    for s in strings\n        if substring in s\n       \
    \     ends_with = true\n            break\n        end\n    end\n    if ends_with\n\
    \        return strings\n    else\n        return filter_by_substring(strings[2:end-1],\
    \ substring)\n    end\nend\n</code>\n<|/ a |>\n<| a tags=string,julia,filter |>\n\
    I assume that by \"filter\" you mean remove elements not matching your criteria.\
    \ If so, a regex based approach may be useful.\n<code>\njulia> str = \"abc,bacd,cde,array\"\
    \n\"abc,bacd,cde,array\"", "    index_strings = map(i -> i==substring, strings)\n\
    \    return filter_strings_index(strings, index_strings)\nend\n</cell>\n<text>\n\
    2.3 Functions to select only unique elements from an array", "    to_return =\
    \ Vector{String}()\n    for s in strings\n        if contains(s, substring)\n\
    \            to_return .= s\n        end\n    end\n    return to_return\nend",
  "    if length(strings) < 1 \n        return strings\n    elseif length(substring)\
    \ > length(strings)\n        throw(ArgumentError(\"length of substring exceeds\
    \ length of strings\"))\n    end", "    \n    included_substrings = filter(x ->\
    \ contains(x, substring), strings)\n    \n    return included_substrings\nend",
  "    \"\"\"\n    Filter an input vector of strings only for ones that contain given\
    \ substring\n    >>> filter_by_substring([], \"a\")\n    []\n    >>> filter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"\
    ]\n    \"\"\"\n    ", "    return \n        filter (s -> contains(s, substring),\
    \ strings)\nend", "    for string in strings\n        if string.contains(substring)\n\
    \            push!(results, string)\n        end\n    end\n    return results\n\
    end", "    if length(substring) == 0 return strings\n    else if length(substring)\
    \ == 1 return filter_by_substring(strings, substring[1])\n    else return filter_by_substring(filter_by_substring(strings,\
    \ substring(1,end(strings))), substring(end(strings),end(strings)))\nend", " \
    \   l = find_in_vector(strings, substring)\n    if l == 0\n        return strings\n\
    \    end\n    return strings[l .. end]\nend\n</code>\n<|/ a tags=filter,julia,string\
    \ dscore=1 |>\n<| a dscore=0 |>\nYou can use findall() function\n<code>\njulia>\
    \ findall(\"a\", \"abca\")\n2-element Vector{SubString{String}}:\n \"a\"\n \"\
    b\"\n</code>\n<|/ a tags=filter,julia,string |>\n<| c |>\nThe question is about\
    \ filtering strings using regular expressions\n<|/ c |>\n<| a |>\nIf you wanted\
    \ to use a regular expression, you can use findall. For example:\n<code>\njulia>\
    \ findall(r\"\\b\\w*\", \"abc def ghi\")\n2-element Array{SubString{String},1}:\n\
    \ \"abc\"\n \"def\"\n</code>\n<|/ a dscore=0 tags=filter,julia,string |>\n<| a\
    \ tags=filter,julia,string |>\nI came up with some code that is basically a filter\
    \ function using regular expressions. The code is as follows, I hope this helps.\
    \ I also have a couple of benchmarks in case you need them.\n<code>\n\"\"\"\n\
    Filter function using regular expressions\n\"\"\""]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
