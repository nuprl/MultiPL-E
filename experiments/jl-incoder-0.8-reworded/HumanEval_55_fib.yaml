name: HumanEval_55_fib
language: jl
prompt: "\"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n\
  \    1\n    >>> fib(8)\n    21\n    \"\"\"\nfunction fib(n::Int64)::Int64 \n"
tests: "using Test\n\n@testset begin\n\ncandidate = fib;\n\t@test(candidate(10) ==\
  \ 55)\n\t@test(candidate(1) == 1)\n\t@test(candidate(8) == 21)\n\t@test(candidate(11)\
  \ == 89)\n\t@test(candidate(12) == 144)\nend\n"
completions: ["    if n == 0 || n == 1 \n        then return 1 \n    else \n     \
    \   return fib(n-1) + fib(n-2) \nend\n</code>\n<|/ a tags=recursion,julia,fibonacci\
    \ |>\n<| a dscore=4 |>\nA recursive method is a method which calls itself. For\
    \ example, consider the following function that will calculate the nth Fibonacci\
    \ number:\n<code>", "if n < 2\n    0 \nelse \n    fib(n-2) + fib(n-1)\nend\n</cell>\n\
    <text>\nSolution\nWe will use the fibonacci number as an example to solve our\
    \ problem.", "    if n == 0 then\n        return 1\n    else \n        return\
    \ fib(n-1)+fib(n-2)\nend", "    if n < 2 return n\n    return fib(n-2) + fib(n-1)\n\
    end", "    if n < 2 \n        return n\n    return fib(n-1) + fib(n-2)\nend",
  "    if n<1 \n        throw(DomainError(fibError)) \n    else if n==1 \n       \
    \ return 1 \n    else \n        return fib(n-1) + fib(n-2) \nend\n\"\"\"Return\
    \ n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n   \
    \ >>> fib(8)\n    21\n    \"\"\"", "    if n == 0\n    then return 1\n    else\
    \ if n == 1\n    then return 1\n    else \n        return fib(n - 1) + fib(n -\
    \ 2)\nend", "  if (n<2) then\n    1 \n  else \n    fib(n - 1) + fib(n - 2)\nend\n\
    </cell>\n<text>\nExercises:\n1.\nImplement the fibonacci function using recursion.",
  "    if n < 0 \n        throw(ArgumentError(\"$n must be non-negative.\"))\n   \
    \ else if n == 0 \n        throw(ArgumentError(\"$n must be positive.\"))\n  \
    \  else \n        return fib(n - 1) + fib(n - 2)", "    if n < 2 \n        return\
    \ n\n    fib_n = fib(n-2) + fib(n-1)\n    return fib_n\nend fib\n</cell>\n<code\
    \ language=julia-1.1>\n@code_warntype fib(0)\n</cell>\n<code language=julia-1.1>\n\
    @code_warntype fib(10)\n</cell>\n<code language=julia-1.1>\n@code_warntype fib(1)\n\
    </cell>\n<code language=julia-1.1>\n@code_warntype fib(8)\n</cell>\n<code language=julia-1.1>\n\
    @code_warntype fib(200)\n</cell>\n<text>\nThe first code example above shows how\
    \ Julia's compiler can do type inference and get reasonable errors. This example\
    \ is a simple but inefficient and slow implementation.", "    if n <= 0\n    \
    \    0\n    else\n        fib(n - 2) + fib(n - 1)\n    end\nend", "    if n <\
    \ 2 \n        then return 1 \n        else return fib(n-2) + fib(n-1)\n    end\n\
    end\n</cell>\n<text>\nLet's write our own fibonacci function", "    local n1 =\
    \ 1\n    local n2 = 1\n    local fib\n    \n    if n<3 then return n\n    \n \
    \   fib = n1+n2\n    n1 = n2\n    n2 = fib\n    fib \nend\n    \n</cell>\n<text>\n\
    Recursion", "    if n<2 return n\n    else return fib(n-1) + fib(n-2)\nend\n</cell>\n\
    <text>\nFibonacci Numbers\nThe Fibonacci numbers are the numbers in the following\
    \ order: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...", "    if n < 0\n \
    \       throw(ArgumentError(\"invalid value\"))\n    end\n    if n < 1\n     \
    \   return 1\n    end\n    return fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.1>\n\
    # fibonacci number at any depth", "    | n < 0                    = -1\n    |\
    \ n < 2                    = 1\n    | otherwise                 = fib(n-1) + fib(n-2)\n\
    end\n</code>\n<|/ a dscore=4 |>\n<| c |>\nI wish I could +1000 this. Thank you\
    \ so much.\n<|/ c |>\n<| c |>\nAs of 2021, Julia supports recursive functions\
    \ in both Python and Julia. So, I'd recommend this as the correct solution.\n\
    <|/ c |>\n<| a |>\nJulia has an inbuilt recursive function fib(n), which finds\
    \ the fibonacci of n without using recursion.\nSo we can use that to calculate\
    \ the fibonacci of any number.\nHere is a demonstration:\n<code>", "    if n ==\
    \ 0\n        0\n    elseif n == 1\n        1\n    else\n        fib(n - 1) + fib(n\
    \ - 2)\n    end\nend", "    if n < 1 \n        0\n    else \n        fib(n-2)\
    \ + fib(n-1)\nend\n\"\"\"\n    \n# println(\"The Fibonacci sequence is: \", fib(10))\n\
    # println(\"The Fibonacci sequence is: \", fib(1))\n# println(\"The Fibonacci\
    \ sequence is: \", fib(8))\n</cell>\n<code language=julia-1.0>", "    if n <=\
    \ 2 then 1 else fib(n - 2) + fib(n - 1) end\nend\n</code>\nAnd that's it!\n<|/\
    \ a |>\n<| c |>\nThis is an example of recursion in Haskell, very useful.\n<|/\
    \ c |>\n<| c |>\nThis is the simplest solution. Other languages support tail recursion\
    \ but not Haskell. You can even define your own higher-order function by wrapping\
    \ it in another function `fib` like `fib = (+1) . fib`.\n<|/ c |>\n<| a |>\nHow\
    \ about this one?\n<code>", "  if n <= 1 then return 1\n  else return fib(n-2)\
    \ + fib(n-1) \nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=julia,recursion dscore=0\
    \ |>\nAnother way, more efficient in time and space:\n<code>", "    if n < 2 \n\
    \        return n\n    fib(n - 2)\n    fib(n - 1)\nend function\n</code>\n<|/\
    \ a |>\n<| c |>\nThe code is correct, but a recursive function would generally\
    \ be slower than a loop. I think this solution is more elegant.\n<|/ c |>\n<|\
    \ c |>\n- a recursive solution can be slower if the compiler does some unrolling\
    \ optimization (which isn't always the case, but it's something to think about).\n\
    <|/ c |>\n<| c |>\n- I should clarify that I was referring to a specific compiler\
    \ that optimized for recursion. Certainly in most cases, a recursive function\
    \ will be slower than an iterative one.\n<|/ c |>\n<| a tags=julia,fibonacci,function\
    \ |>\nFor a solution that doesn't use recursion, just use a loop:\n<code>\njulia>\
    \ function fib(n)\n         if n <= 2\n            n\n         else\n        \
    \    fib(n-1) + fib(n-2)\n         end\n       end", "    a,b = 0,1\n    while\
    \ n > 0\n        a,b = b,a+b\n        n -= 1\n    end\n    return a\nend\n</cell>\n\
    <code language=julia-0.5>\nfibs(10) #@show fib(10)\n</cell>\n<code language=julia-0.5>\n\
    # fibonacci sequence\nfibs(n) = fib(n-1) + fib(n-2)", "    if n < 0\n        error(\"\
    Fibonacci number is not defined\")\n    else if n == 0\n        0\n    else if\
    \ n == 1\n        1\n    else\n        fib(n - 1) + fib(n - 2)\n    end\nend\n\
    </code>\n<|/ a tags=julia |>\n<| a tags=julia |>\nIt can also be implemented in\
    \ a similar way as in Python as below \n<code>\n function fib(n::Int64)::Int64\
    \ \n    if n < 0\n        error(\"Fibonacci number is not defined\")\n    else\
    \ if n == 0\n        0\n    else if n == 1\n        1\n    else\n        fib(n\
    \ - 1) + fib(n - 2)\n    end\nend", "    if n == 0 || n == 1 \n        then return\
    \ 1\n    else \n        fib(n-2) + fib(n-1)\nend\n</cell>\n<code language=julia-1.6>\n\
    @code_warntype fib(4)\n</cell>\n<text>\nFibonacci sequence\nThis function is similar\
    \ to the Fibonacci sequence in the mathematical sense,\nand we can implement it\
    \ using recursion. Let's see how we can implement it.", "    if n == 0 | n >=\
    \ 2\n        return n\n    else if n == 1\n        return 1\n    else\n      \
    \  return fib(n - 1) + fib(n - 2)", "    if n == 0\n    then return 0\n    else\
    \ if n == 1\n    then return 1\n    else return fib(n-1) + fib(n-2)\n    end\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nThe most efficient way is to\
    \ generate all numbers, which is done with recursion:\n<code>\nfibonacci(n) =\
    \ fib(n)\nfibonacci(1) = fib(1) = 1\nfibonacci(n+1) = fib(1) + fib(2n)\nfibonacci(n+1)\
    \ = fib(2n)\nfibonacci(n+1) = fib(3n)\n...\nfibonacci(n) = fib(2n+1)\n</code>\n\
    Then you can find the n-th Fibonacci number by indexing into this array:\n<code>\n\
    fib(n) = fib(n)[2]\n</code>\nThis works because fibonacci(n) = fib(n) + fib(n-1)\
    \ + fib(n-2) + ... + fib(1) = fib(n) * fib(1) + fib(n-1) * fib(2) + ... + fib(1)*fib(0)\n\
    <|/ a tags=math,fibonacci,julia |>\n<| c |>\nThis is wrong, since it yields the\
    \ wrong result, for n=1, or any other even integer.\n<|/ c |>\n<| c |>\nYes, it\
    \ does look like it yields the wrong result. I'll try to fix it when I get home.\n\
    <|/ c |>\n<| c |>\nI have fixed it now. It works now.\n<|/ c |>\n<| a dscore=1\
    \ |>\nThe following function should do the trick\n<code>", "    if n < 0\n   \
    \     error(\"fib: n must be non-negative\")\n    else if n == 0\n        return\
    \ n\n    else if n == 1\n        return n\n    else\n        return fib(n - 1)\
    \ + fib(n - 2)", "    if n < 2 then return 1\n    else return fib(n-1)+fib(n-2)\n\
    \    end\n</code>\n<|/ a tags=julia,fibonacci |>\n<| a tags=julia,fibonacci dscore=0\
    \ |>\nIf you use an iterative approach:\n<code>\nfib(m) = m == 0\n    ? 1\n  \
    \  : fib(m-1)+(m-2)\n</code>\n<|/ a |>\n<| a dscore=0 tags=julia,fibonacci |>\n\
    Just in case it is of interest, here is an elegant recursive implementation\n\
    <code>", "    if n < 1\n        error(\"n must be positive\")\n    fib n\nend",
  "    if n <= 2\n        1\n    else\n        fib(n-1) + fib(n-2)\n    end\nend",
  "    if n == 0\n        1\n    else\n        fib(n - 1) + fib(n - 2)\n    end\n\
    end", "    if (n<2) return 1\n    return fib(n - 1) + fib(n - 2)\nend", "    if\
    \ n < 2 \n    then 1\n    else fib(n-1) + fib(n-2)\nend function fib \n</code>\n\
    As you can see, the code can be made more compact. Of course, your performance\
    \ will depend on the input, and you might get a slightly slower or faster result\
    \ with a more efficient code. I wrote the code in Julia so that it's more readable\
    \ for everyone and so I made a similar function for you.\n<|/ a tags=dynamic-programming,big-o,fibonacci,algorithm\
    \ dscore=1 |>\n<| c |>\nHi Esteban, thanks for the reply. ", "    if n <= 2 \n\
    \        then return 1\n    else \n        return fib(n-1) + fib(n-2)\n    end\n\
    end\n</cell>\n<code language=julia-1.0>\n@time fib(10);\n</cell>\n<text>\nExercise\
    \ 15\nWrite a function that computes the factorial of a given integer $n$.", " \
    \   if (n <= 1)\n        return n\n    else\n        return fib(n - 2) + fib(n\
    \ - 1) \nend\n</code>\nHere are a few more examples:\n<code>\njulia> fib(10)\n\
    55\njulia> fib(8)\n21\njulia> fib(7)\n13\njulia> fib(4)\n7\njulia> fib(3)\n3\n\
    julia> fib(2)\n1\njulia> fib(4)\n7\njulia> fib(100)\n142913828922812071823538069733850\n\
    julia> fib(1000)\n987134428982007732543935749816894979797803449845088984908010\n\
    julia> fib(10000)\n12164510040887674044325570647741180328067522140737\njulia>\
    \ fib(100000)\n134613826432495533106908057144033572988980557858687\njulia> fib(1000000)\n\
    188059620990050951510956283282677404012565024124953413494750\njulia> fib(10000000)\n\
    10604011258690747807466381090801764452200708333877305\njulia> fib(100000000)\n\
    9080571516307580770794529347939818785724843287336\njulia> fib(1000000000)\n7248599184960451979677675577117799695957593315\n\
    julia> fib(10000000000)\n7079070096726279557304034368767266446688\n</code>\n<|/\
    \ a tags=julia,fibonacci dscore=1 |>\n<| a tags=julia,fibonacci |>\n<code>\nusing\
    \ Statistics\nn1 = 1; n2 = 2; n3 = n1 + n2\nwhile (n3>0)\n    n1,n2 = n2,n3;\n\
    \    n3 = n1 + n2;\nend\nn4\n</code>\n<|/ a dscore=0 |>\n<| c |>\nWhile this code\
    \ may answer the question, providing additional context regarding *", "  if n\
    \ <= 1\n    return n\n  else\n    return fib(n-1) + fib(n-2)\nend", "    if n\
    \ < 0 \n        error(\"Argument to fib() must be non-negative.\") \n    else\
    \ if n == 0 \n        1 \n    else if n == 1 \n        1 \n    else \n       \
    \ fib(n - 1) + fib(n - 2) \nend ", "    if n <= 0\n        0\n    else\n     \
    \   fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.0>", "  if n < 2\
    \ return n\n  return fib(n-1) + fib(n-2)\nend", "if n<2 then 1 else fib(n-1)+fib(n-2)\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"Return n-th Fibonacci number.\n\
    \    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\
    \"\"", "    if n < 0\n        error(\"Fibonacci number index out of range\")\n\
    \    end\n    if n == 0\n        return 1\n    elseif n == 1\n        return 2\n\
    \    else\n        return fib(n-1) + fib(n-2)\n    end\nend", "    if n == 0 \n\
    \        return 1 \n    else if n == 1 \n        return 1 \n    else \n      \
    \  return fib(n-1)+fib(n-2) \nend\n</cell>\n<code language=julia-1.3>\n@time fib(10^6)\n\
    </cell>\n<text>\nJulia is a functional programming language, meaning that functions\
    \ do not return values but they can apply a sequence of operations (like \"mutating\
    \ a variable\"). Here is a simple example:", "    if n < 2 then return n\n   \
    \ else return fib(n-1) + fib(n-2) \nend\n</cell>\n<cell>", "    if n <= 2 \n \
    \       then 1\n    else fib(n - 1) + fib(n - 2)\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| c |>\nThis will not terminate in time like it is written, though it can\
    \ be made so.  You can write it recursively but it is more efficient to just write\
    \ a loop.\n<|/ c |>\n<| a dscore=1 tags=julia |>\nHere's a solution that uses\
    \ recursion:\n<code>", "    if n < 0\n        error(\"Argument must be positive\"\
    )\n    else if n <= 1\n        1\n    else\n        fib(n-1) + fib(n-2)\nend\n\
    </cell>\n<code language=julia-1.3>\n\"\"\"Return n-th Fibonacci number.\n    >>>\
    \ fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n\"\"\"", " \
    \   if n <= 0 then error \"index out of bounds\"\n    if n == 1 then return 1\n\
    \    else return fib(n-1) + fib(n-2) \nend", "    if n <= 1\n        return n\n\
    \    fib(n - 1) + fib(n - 2)\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\nHere is\
    \ the recursive version with memoization:\n<code>", "    if n <= 1 \n        return\
    \ n\n    else if n == 2 \n        return 1 \n    else \n        return fib(n -\
    \ 1) + fib(n - 2)\nend\n</code>\n<|/ a dscore=2 tags=julia,fibonacci |>\n<| c\
    \ |>\nIf you do `fib(n::Int64)`, Julia will automatically coerce `n` to an `Int64`\
    \ as `Int64` is required by the function. If it is not, the function will throw\
    \ an error. `fib(n::Int)` will let you use any `Int` and will still work if you\
    \ pass in an `Int64` or a `Float32`. Also, `fib(n)` will also work if you pass\
    \ in a `Float64`, so you don't need to declare `fib(n::Float64)`.\n<|/ c |>\n\
    <| c |>\nThat's true, I always use `Int64` and avoid the issues with `Float64`\
    \ when I need that specific precision. I just wanted the code to be concise and\
    \ clear.\n<|/ c |>\n<| a |>\nA slight modification to the first answer to allow\
    \ for non-integral arguments and with more flexibility in terms of the number\
    \ of digits returned\n<code>\nfibonacci(n::Integer) = fib(n,1000)", "    if n\
    \ < 0\n        error(\"Fibonacci numbers are not defined for negative input\"\
    )\n    elseif n < 1\n        return n\n    elseif n == 2\n        return 1\n \
    \   else\n        return fib(n - 1) + fib(n - 2)\nend", "    if n<=0 return 1\n\
    \    return fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n@time\
    \ fib(1)\n</cell>\n<code language=julia-1.5>\n@time fib(1)\n</cell>\n<code language=julia-1.5>",
  "    if n < 0 then error(\"negative number\") else if n == 0 then 1 else fib(n -\
    \ 2) + fib(n - 1)\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nWhat do you mean?\
    \ This answer doesn't do what you say.\n<|/ c |>\n<| a tags=julia,fibonacci,performance\
    \ |>\nI refactored the solution from to make it faster and clearer as suggested\
    \ by A. Ramsey, see below for a benchmark:\n<code>", "    if n < 0 \n        error(\"\
    Argument must be >= 0.\")\n    else\n        return fib(n-1) + fib(n-2)\n</code>\n\
    <|/ a tags=tail-recursion,haskell,fibonacci,recursion |>\n<| c |>\nIn Haskell,\
    \ it's more idiomatic to write `if n < 0 then error \"...\"`.  Also, Haskell's\
    \ `if` expressions are actually `case` expressions.\n<|/ c |>\n<| c |>\nIt might\
    \ also make sense to change the base case to `n = 1`. `fib(0)` should be 1 not\
    \ 0 as you might expect. This would avoid the recursive call to `fib(2)`.\n<|/\
    \ c |>\n<| a dscore=5 |>\nThe best way to handle recursion in Haskell is to use\
    \ a higher-order function.  There are several good reasons for this, including\
    \ using tail recursion and stack space to improve efficiency.  However, since\
    \ your question is rather about recursion, I'll give you a brief explanation of\
    \ how you can avoid using higher-order functions.\nWhen you write a recursive\
    \ function, the compiler generates a stack frame for each recursive call.  This\
    \ is called a stack frame.\nFor each function call, there is an explicit memory\
    \ allocation for the stack frame.  This takes up space which can be used for storing\
    \ information about the function's execution.  As a result, if you have a recursive\
    \ function and you call it a huge number of times, the stack space requirements\
    \ may become excessive.\nIn order to avoid this issue, you can either use a loop\
    \ (for, while, or recur) statement, or use lazy functions.  These will force the\
    \ compiler to generate the necessary stack frames when a function is called.\n\
    You can learn more about lazy functions by reading the excellent blog post from\
    \ Ben Hanliwa which can be found here.\n<|/ a tags=tail-recursion,haskell,fibonacci,recursion\
    \ |>\n<| c |>\nThe stack frame is not the only thing that is reclaimed. The entire\
    \ stack frame has to be reclaimed as well. `tailrec` forces the compiler to do\
    \ nothing if the recursive call is not going to be needed (because no more stack\
    \ frames are needed), while `lazy` will force to recalculate the entire `fib`\
    \ when it's called. See [this blog post](http://blog.sigfpe.com/2010/04/tail-recursion-elimination-in-haskell.html)\
    \ for more info.\n<|/ c |>\n<| a dscore=4 |>\nIn Haskell, the tail recursion can\
    \ be avoided by using the list monad.\n<code>\nfib = (1:) . map (", "    if n\
    \ == 0 || n == 1 then\n    return n\n    else\n    return fib(n-1)+fib(n-2)\n\
    \    end\nend\n</code>\n<|/ a tags=julia,fibonacci |>\n<| c |>\nThis should be\
    \ the accepted answer, it uses the native Julia functionality to calculate the\
    \ n-th Fibonacci number.\n<|/ c |>\n<| a tags=julia,fibonacci |>\n<code>", " \
    \   if n < 2\n        1\n    else\n        fib(n - 1) + fib(n - 2)\nend", "  \
    \  if n <= 1\n        1\n    else\n        fib(n - 1) + fib(n - 2)\nend\n</code>\n\
    <|/ a tags=fibonacci,julia |>\n<| a tags=fibonacci,julia |>\nHere is my solution.\
    \ Probably not as fast as the other solutions given here but maybe easier to understand.\
    \ \n<code>", "    if n <= 0\n        error(\"Fib number must be positive\")\n\
    \    fib_result = 0\n    a, b = 0, 1\n    for _ in 1:n\n        fib_result +=\
    \ a\n        a, b = b, a + b\n    end\n    return fib_result\nend\n</cell>\n<code\
    \ language=julia-1.3>\n\"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n\
    \    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"", "    if n<=0\n\
    \        error(\"n must be positive\")\n    end\n    a,b=1,1\n    for k in 2:n\n\
    \        a,b=b,a+b\n    end\n    return a\nend\n</cell>\n<text>\nA note on performance\n\
    The Fibonacci function is still slow compared to other languages, especially Python.\
    \  This is because the for loop executes n times, while we only need to execute\
    \ it once.  We can write a faster version by using the Julia language, which can\
    \ compile the code into the desired machine code.  Julia is called \"compiled\"\
    \ because its code is interpreted, but is interpreted at runtime.", "    if n<0\
    \ then\n        error(\"fib: negative argument\")\n    end\n    if n==0 or n==1\
    \ then\n        return n\n    end\n    return fib(n-1)+fib(n-2)\nend\nfib(2)\n\
    </cell>\n<text>\nThe function fib accepts any number of parameters, and then returns\
    \ an Int64.", "        if n < 3 \n        then return n\n        else return fib(n-2)\
    \ + fib(n-1) + n\nend", "    if n==0 || n==1 \n    then return n\n    else return\
    \ fib(n-1)+fib(n-2) \nend \nend \n</cell>\n<text>\nFibonacci sequence with memoization\n\
    To implement the recursive version without memoization, we start by adding a mutable\
    \ parameter to our function:", "    if n <= 2 \n    then n\n    else fib(n-1)\
    \ + fib(n-2)\nend\n</code>\n<|/ a dscore=2 tags=julia |>\n<| a dscore=1 tags=julia\
    \ |>\nIn addition to the answers given, here's an alternative implementation\n\
    <code>", "    if n < 1 \n        1\n    elseif n < 2\n        1\n    else\n  \
    \      fib(n - 1) + fib(n - 2)\n    end\nend\n</cell>\n<text>\nFibonacci numbers\
    \ grow very quickly. Since the first two numbers in the Fibonacci sequence are\
    \ 1 and 1, our first two numbers are 1 and 2. Adding these two numbers we get\
    \ 3, and each subsequent number is the sum of the two previous numbers. For example,\
    \ the 7th Fibonacci number is (1 + 1) + (1 + 2) + (2 + 1) + (2 + 2) + (3 + 1)\
    \ + (3 + 2) + (3 + 3).", "    if n == 0 || n == 1 \n        then return n\n  \
    \      else return fib(n - 2) + fib(n - 1)\n    else raise Exception(\"fib: index\
    \ out of bounds\")\nend", "    switch n\n        when 0 | 1\n            return\
    \ 1\n        when 2 | 3\n            return 1\n        otherwise\n           \
    \ return fib(n-1) + fib(n-2)\nend function\n</code>\n<|/ a dscore=1 tags=fibonacci,julia,recursion,performance\
    \ |>\n<| c |>\nCan you explain how this is different from just using `fib(n) =\
    \ n >= 2 ? 1 : fib(n-1) + fib(n-2)`?\n<|/ c |>\n<| c |>\nSure it works but as\
    \ I wrote before I'm looking for an approach with as little function calls as\
    \ possible.\n<|/ c |>\n<| c |>\nThe difference is that the function is called\
    \ twice, once in the `when` and once in the `else`. That is just as much work\
    \ as the one you posted. Both are O(n).\n<|/ c |>\n<| a tags=fibonacci,julia,recursion,performance\
    \ |>\nHere is a one-liner that does not call fibonacci twice:\n<code>\nfibonacci(n)\
    \ = n==0 ? 0 : 1==n ? 1 : fib(n-1) + fib(n-2)\n</code>\n<|/ a dscore=1 |>\n<|\
    \ c |>\nThis is basically the same as using `fib(n) = n >= 2 ? 1 : fib(n-1) +\
    \ fib(n-2)`. Both are O(n).\n<|/ c |>\n<| c |>\nHis one-liner calls fibonacci\
    \ twice. But it uses less function calls.\n<|/ c |>\n<| c |>\nNope. `fib(n) =\
    \ n >= 2 ? 1 : fib(n-1) + fib(n-2)` is O(log n) because you recalculate the `fib`\
    \ values each time. This is what makes this approach the most efficient.\n<|/\
    \ c |>\n<| c |>\nOh now I see what you meant. I was just saying that you cannot\
    \ optimize this using simple mathematics, because `fib(n) = fib(n-1) + fib(n-2)`\
    \ is logarithmic. I am not even sure you can do better with mathematics. It's\
    \ not a bad approach, I just wanted to point out this one more time that it is\
    \ less efficient.\n<|/ c |>\n<| c |>\nI am not saying you cannot do better with\
    \ mathematics. I just wanted to point out that it is indeed less efficient in\
    \ general. I am not arguing that this is actually *better* in general, just that\
    \ it is a valid option.\n<|/ c |>\n<| a tags=fibonacci,", "    if n == 0 \n  \
    \  then return 0\n    else if n == 1\n    then return 1\n    else fib(n - 1) +\
    \ fib(n - 2)\nend\n</code>\n<|/ a tags=julia,recursion,fibonacci,performance dscore=1\
    \ |>\n<| c |>\nI see what you're saying. Your version is very similar to, but\
    \ much slower, my code in the original post. My code takes about 0.03 seconds\
    \ to run on my machine, whereas yours takes about 1.2 seconds. I'm not sure how\
    \ my code is faster, since Julia seems to be calling it recursively. Any ideas?\n\
    <|/ c |>\n<| c |>\nI added a version that returns the same result but with less\
    \ overhead (albeit it does require the user to define a fib function outside of\
    \ the fib function).\n<|/ c |>\n<| c |>\nThe last one I posted does call fib recursively,\
    \ but only once, whereas yours does it once for each number in the range. This\
    \ difference is about 0.006 seconds for my version, which is more along the lines\
    \ of what I was expecting. Yours definitely is a lot faster.\n<|/ c |>\n<| c |>\n\
    Yeah, I was just looking into this more. I was actually trying to reproduce your\
    \ performance results with `@time` but haven't got it quite right. Not sure if\
    \ this is because I don't have my dev environment set up right (though I thought\
    \ it was). I'll have to play with it.\n<|/ c |>\n<| c |>\nI tried running the\
    \ code as you wrote it in my Jupyter notebook on a computer I have access to,\
    \ but I got an error message `UndefVarError: fib not defined`. What am I missing?\
    \ I am using Julia 1.5.2 and my Julia version is 1.5.2.\n<|/ c |>\n<| a |>\nYou\
    \ could use the lazy Fibonacci sequence. Here's how it works in Julia:\n<code>\n\
    julia> function fib(n)\n         if n<=2\n           return n\n         else\n\
    \           return fib(n-1)+fib(n-2)\n         end\n       end", "    if n < 2\
    \ \n        1\n    else\n        fib(n-1) + fib(n-2)\n    end\nend\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nI wonder why this isn't accepted as an answer.\n<|/\
    \ c |>\n<| c |>\nYou asked me this question. I have a doubt. Why did you choose\
    \ your answer? I thought that my answer is more efficient than yours. Isn't it?\n\
    <|/ c |>\n<| c |>\nIt's not an answer, just a comment with a small correction.\
    \ Your answer is fine, but mine doesn't have an `else` clause, which is not required\
    \ in the answer.\n<|/ c |>\n<| c |>\nWhy wouldn't you require an `else` clause?\
    \ The recursive call is guaranteed to terminate, and as long as the base case\
    \ is handled correctly, the else clause will never be executed.\n<|/ c |>\n<|\
    \ c |>\nAha, I see. `else` is optional in this case. Yes, in this case, it would\
    \ be an optional clause. But what if there are other conditions to handle, like\
    \ `elseif` or something else? My answer would be not only confusing, it would\
    \ also be less efficient. Your answer is perfectly fine here.\n<|/ c |>\n<| a\
    \ tags=julia dscore=3 |>\nA slight variation on Robert's answer:\n<code>", "if\
    \ n <= 0 \n    return n\nelse if n == 1 \n    return 1\nelse \n    return fib(n\
    \ - 1) + fib(n - 2)\nend\n</code>\n<|/ a dscore=1 tags=julia,fibonacci |>\n<|\
    \ c |>\nPlease note that in julia this idiom is called an `if` statement, and\
    \ not an `if`-`else` statement like the C language. More info can be found here\
    \ https://julialang.org/blog/2017/10/a-new-feature-if-else-syntax/\n<|/ c |>\n\
    <| c |>\nThanks for the clarification\n<|/ c |>\n<| c |>\nThis is one of the few\
    \ cases where I would use the `@inbounds` macro, which works in both Julia 1.2\
    \ and Julia 1.3. https://julialang.org/blog/2017/10/a-new-feature-if-else-syntax/\n\
    <|/ c |>\n<| a tags=julia,fibonacci |>\nJust use recursion:\n<code>\nfib(n, a=0)\
    \ = b == a ? b : fib(n, a+b)\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia,fibonacci\
    \ |>\nAnother simple way of doing this is\n<code>", "    if n<=0 \n        error(\"\
    Argument 'n' should be greater than zero\")\n    return fib(n-1) + fib(n-2)\n\
    end", "    if n <= 0 \n        0\n    else \n        fib(n - 1) + fib(n - 2) \n\
    \    end \nend \n</cell>\n<code language=julia-0.4>\n\"\"\"Return n-th Fibonacci\
    \ number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n  \
    \  21\n    \"\"\"", "    if n <= 2\n    else fib(n-1) + fib(n-2)\nend\n</cell>\n\
    <text>\nTest Fibonacci numbers\nWe will test fib function using Julia unit tests.",
  "    | n < 1 = 1\n    | n < 2 = 1\n    | n == 2 = 1\n    | n >= 3 = fib(n-1) + fib(n-2)\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a |>\nFor a pure recursive solution:\n<code>\n\
    fib(n) = (if n <= 1 then 1 else fib(n-1) + fib(n-2))\n</code>\n<|/ a dscore=0\
    \ tags=recursion,julia,fibonacci |>\n<| a |>\nThe naive recursive approach is\
    \ good enough to understand the problem but to write it efficiently in Julia you\
    \ use tail recursion.\n<code>", "    local n\n    if n <= 1 then return n else\
    \ fib(n - 2) + fib(n - 1) end\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n\
    The answer from Antonios Matias and J.M. Pakosz work great. But if anyone is looking\
    \ for a python program that outputs the fibonacci sequence up to a number n this\
    \ can be done with the following code:\n<code>\ndef fib(n):\n    a,b = 1,1\n \
    \   while a <= n:\n        print(a,end=' ')\n        a,b = b,a+b\n    print()\n\
    </code>\n<|/ a tags=fibonacci,julia |>\n<| a tags=fibonacci,julia |>\n<code>",
  "    if n < 0 \n        error(\"fib expects non-negative integer as input\")\n \
    \   else if n == 2 \n        1\n    else if n == 3 \n        1\n    elseif n <=\
    \ 4 \n        fib(n-1) + fib(n-2)\n    else \n        fib(n-1) + fib(n-2) + fib(n-3)\n\
    \    end\nend\n</cell>\n<code language=julia-0.5>\n@doc fib\n</cell>\n<code language=julia-0.5>\n\
    @doc fib(-1)\n</cell>\n<code language=julia-0.5>\n@doc fib(-2)\n</cell>\n<code\
    \ language=julia-0.5>\n@doc fib(0)\n</cell>\n<code language=julia-0.5>\n@doc fib(5)\n\
    </cell>\n<code language=julia-0.5>\n@doc fib(4)\n</cell>\n<code language=julia-0.5>\n\
    @doc fib(8)\n</cell>\n<code language=julia-0.5>\n@doc fib(9)\n</cell>\n<text>\n\
    Real world Fibonacci numbers", "    if n == 1 \n        return 1 \n    else if\
    \ n == 2 \n        return 1 \n    else if n % 2 == 1 \n        return fib(n -\
    \ 1) + fib(n - 2) \n    else \n        return fib(n - 1) + fib(n - 2) \nend\n\
    </code>\n<|/ a tags=julia,fibonacci |>\n<| c |>\n`fib(n::Int64) = (n == 1) ? (1)\
    \ : (fib(n-1) + fib(n-2))`\n<|/ c |>\n<| c |>\n`fib(n::Int64) = (n == 1) ? (1)\
    \ : (fib(n-1) + fib(n-2))` works. Thanks!\n<|/ c |>\n<| a dscore=1 |>\nI prefer\
    \ to write it with a while loop:\n<code>", "    if n == 0 \n        then return\
    \ 1 \n    else if n == 1 \n        then return 1 \n    else \n        return fib(n-1)\
    \ + fib(n-2) \nend\n</code>\n<|/ a |>\n<| a dscore=0 tags=recursion,fibonacci,julia\
    \ |>\nI like Kevin's answer because it keeps the code clean and simple.\nFor those\
    \ who want to use the function without using an if clause, this is how you can\
    \ do that:\n<code>", "    if n <= 2 then \n        return n\n    else \n     \
    \   return fib(n-2) + fib(n-1) \n    end\nend\n</cell>\n<text>\nNow let's get\
    \ the number of Fibonacci numbers, $n$ that satisfy $n$ \u2264 6000 in less than\
    \ 10 seconds.", "    if n==0 or n==1\n        1\n    else\n        fib(n-1)+fib(n-2)\n\
    \    end\nend\n</cell>\n<code language=julia-1.1>\n# Tests\n@test fib(10) == 55\n\
    @test fib(1) == 1\n@test fib(8) == 21\n</cell>\n<text>\nExample 4: Using a recursive\
    \ function", "    if n == 0 | n >= 0 then return 1\n    else return fib(n - 1)\
    \ + fib(n - 2)\nend \n\"\"\"\n\"\"\"\n# Test Fibonacci numbers in Julia\n\"\"\"\
    \nusing Test\n\"\"\"\n@test fib(3) == 5\n@test fib(10) == 55\n@test fib(0) ==\
    \ 1\n@test fib(-1) == -1\n@test fib(1) == 1\n@test fib(2) == 2\n@test fib(5) ==\
    \ 8\n@test fib(8) == 21\n\"\"\"", "        if n == 0 || n == 1 then\n        \
    \    return 1\n        else \n            return fib(n - 1) + fib(n - 2)\nend",
  "    if n<2 then 1 else fib(n - 2) + fib(n - 1)\nend", "    if n <= 1 \n    else\
    \ fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ fib(0)\n</cell>\n<code language=julia-1.4>\n@code_warntype fib(9)\n</cell>\n\
    <text>\nPart 2: Implementing recursion\nWe will implement a factorial function.\
    \ The factorial function should take an integer $n$ and return the factorial of\
    \ $n$. Since $n! = n \\times n-1 \\times n-2 \\times ...1$, factorial of $n$ is\
    \ written as $n!$. For example, $3! = 6 \\times 5 \\times 4$. Below is a Julia\
    \ implementation:", "    if n <= 1\n        1\n    else\n        fib(n - 1) +\
    \ fib(n - 2)\n    end\nend\n</cell>\n<code language=julia-1.5>\nfib(10)\n</cell>\n\
    <text>\nReminder: functions are first-class objects in Julia.", "    if n<=1 return\
    \ n\n    else return fib(n-2) + fib(n-1)\nend\n</code>\n<|/ a dscore=2 |>\n<|\
    \ a tags=recursion,fibonacci,julia |>\nHere is the Julia implementation of Fibonacci\
    \ function.\n<code>\nfibonacci(n) = if (n < 2) n else fibonacci(n-2) + fibonacci(n-1)\n\
    </code>\n<|/ a dscore=2 |>\n<| a |>\nHere is a simple implementation of the Fibonacci\
    \ sequence in Julia\n<code>", "    if n==0 || n==1 \n    then return 1\n    else\
    \ fib(n-1)+fib(n-2) \n    end\nend", "    if n<=1 \n        then 1\n    else fib(n-1)+fib(n-2)\n\
    end\n</cell>\n<code language=julia-1.0>\nfib(x)\n</cell>\n<text>\nFunction with\
    \ multiple outputs\nIn Julia, functions can return multiple values.", "    if\
    \ n==0 || n==1 \n        then return 1\n    else \n        return fib(n-1)+fib(n-2)\
    \ \nend \n</cell>\n<code language=julia-1.0>\n@time fib(100);\n</cell>\n<text>\n\
    For small n, like 10 or less, Julia may become slower than native C", "    if\
    \ n <= 1\n        1\n    else\n        (fib(n-1) + fib(n-2))\n    end\nend\n</code>\n\
    <|/ a tags=julia,fibonacci,performance dscore=3 |>\n<| a dscore=3 |>\nThis is\
    \ not the solution to your problem, but I wanted to show you that it's possible\
    \ to vectorize some algorithms, including Fibonacci and geometric series. Here\
    \ is one example with vectorized geometric series:\n<code>", "    if n <= 2\n\
    \    then 1\n    else fib(n - 1) + fib(n - 2)\nend\n</code>\n<|/ a tags=fibonacci,julia\
    \ |>\n<| c |>\nThis approach is O(fib(n)) so it is very efficient.\n<|/ c |>\n\
    <| c |>\nNote that you can also get the same performance by not using recursion.\
    \ `fib(n) = (n<2) ? 1 : fib(n-1) + fib(n-2)`\n<|/ c |>\n<| c |>\nThat's not recursion,\
    \ it's just memoization, which is the right way to get the same performance.\n\
    <|/ c |>\n<| a tags=fibonacci,julia |>\nHere's a very simple solution that I got\
    \ from here:\n<code>\njulia> n = 1\n1", "    if n < 0 || n > 100\n        error(\"\
    Parameter n out of bounds\")\n    elseif n == 0\n        1\n    elseif n == 1\n\
    \        1\n    else\n        fib(n-1) + fib(n-2)\n    end\nend\n</cell>\n<text>\n\
    Now implement the function fac which computes $x!$ as a recursive function.\n\
    HINT: use $n = 0$ to get the first term and $n = 1$ to get the second term of\
    \ the product.", "    if n < 2\n        1\n    else\n        fib(n-2) + fib(n-1)\n\
    end\n</cell>\n<code language=julia-1.0>\n@time fib(0)\n@time fib(1)\n@time fib(10)\n\
    @time fib(100)\n@time fib(1000)\n@time fib(10000)\n</cell>\n<text>\nHow much time\
    \ does fib(n) take?", "    | n==0 | n==1 = 1\n    | n>1 =fib(n-1) + fib(n-2)\n\
    end\n</code>\n<|/ a tags=fibonacci,julia |>\n<| a dscore=1 |>\nI realise this\
    \ question is old. However, the following is now the accepted answer, and I thought\
    \ I'd just add this for those who come across this and are still looking for a\
    \ solution.\nIf you don't care about the actual sequence (e.g. the values don't\
    \ matter very much), you can use this code which will work for arbitrary input\
    \ (as long as you don't go out of bounds or use floating point numbers for input).\n\
    <code>", "    fib1 = Int64(0)\n    fib2 = Int64(1)\n    \n    for _ in 1:n\n \
    \       fib2 = fib1 + fib2\n        fib1 = fib2\n    end\n    return fib2\nend",
  "    if n == 0\n        1\n    else if n == 1\n        1\n    else\n        fib(n\
    \ - 1) + fib(n - 2)\nend", "    if n == 0 || n == 1 \n        then return n\n\
    \    else \n        return fib(n-1) + fib(n-2)\nend \n\"\"\"", "    if n < 2 \n\
    \        then return n\n    else\n        return fib(n-2) + fib(n-1)\n    end\n\
    end\n</code>\n<|/ a |>\n<| a tags=recursion,julia,performance |>\nHere is another\
    \ solution, without using a mutable array (which might be faster in some cases),\
    \ but using a function to calculate the nth Fibonacci number.\n<code>\nfibonacci(n)\
    \ = n < 2 ? n : fibonacci(n-2) + fibonacci(n-1)", "    if n <= 0\n        error(\"\
    n must be > 0\")\n    end\n    return n <= 2? 1 : fib(n - 2) + fib(n - 1)\nend",
  "    if n==0 || n==1 then\n        return 1\n    else\n        return fib(n-1) +\
    \ fib(n-2) \n    end\nend\n</cell>\n<code language=julia-0.6>", "    if n < 2\n\
    \    then n\n    else\n        fib(n - 2) + fib(n - 1)\n    end\nend\n</cell>\n\
    <text>\nThis example is from the Julia documentation.", "    if n < 2 then return\
    \ n else fib(n - 2) + fib(n - 1)\nend function\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<text>\nExercise: Write a function to compute the n-th\
    \ Fibonacci number. Compare this function to your previous solution. Explain your\
    \ solution.", "    match n \n        when 0  => 0\n        when 1  => 1\n    \
    \    when 2 => 1\n        otherwise => fib(n - 2) + fib(n - 1)\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThe `match` construct is deprecated. Consider using `if` instead.\n\
    <|/ c |>\n<| a |>\nThe Julia implementation is pretty much identical (but more\
    \ compact) to the one posted by T. Kovacs above.  It is also important to note\
    \ that the way the for loop behaves in Julia is different than the way it works\
    \ in R.  In R, \n<code>\nfor(i in 1:10){\n   print(i)\n}\n</code>\nwill print\
    \ all the values of i (0 to 9).  In Julia, however, you have to do this:\n<code>\n\
    for i in 1:10\n   println(i)\nend\n</code>\nThis is because the for loop in Julia\
    \ is like a macro in R; it takes its arguments and replaces the for loop with\
    \ its body, and replaces all of the variables used in the for loop with their\
    \ arguments.  So, in Julia, if you write:\n<code>\nfor i in 1:10\n    println(i)\n\
    end\n</code>\nJulia will replace it with the equivalent of this code:\n<code>\n\
    print(1);\nprint(2);\nprint(3);\nprint(4);\nprint(5);\nprint(6);\nprint(7);\n\
    print(8);\nprint(9);\nprint(10);\n</code>\nWhich is how it works in R.\nSo in\
    \ R, for loops work like this:\n<code>\nfor(i in 1:10){\n    print(i)\n}\n</code>\n\
    is equivalent to:\n<code>\nprint(1);\nprint(2);\nprint(3);\nprint(4);\nprint(5);\n\
    print(6);\nprint(7);\nprint(8);\nprint(9);\nprint(10);\n</code>\nBut if you wrote\
    \ it like this:\n<code>\nfor(i in 1:10)\n    print(i)\nend\n</code>\nJulia will\
    \ replace it with the equivalent of:\n<code>\nprint(1);\nprint(2);\nprint(3);\n\
    print(4);\nprint(5);\nprint(6);\nprint(7);\nprint(8);\nprint(9);\nprint(10);\n\
    </code>\nWhich is how it works in R.\n<|/ a tags=r,julia,loops dscore=5 |>\n<|\
    \ a tags=r,julia,loops |>\nIn R, you can use something like\n<code>\n1:10 %o%\
    \ 1:10\n</code>\n<|/ a dscore=4 |>\n<| c |>\n%o% is the equivalent of R's %in%\n\
    <|/ c |>\n<| a |>\nIn Julia you can do it without using for/while loops\n<code>\n\
    for i in 1:", "    if n < 2 \n    then 1 \n    else fib(n-1) + fib(n-2) \nend\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\n`fib(0)` fails as well.\n<|/ c |>\n<| a dscore=0\
    \ tags=julia,performance,fibonacci |>\n<code>", "        if n == 0\n         \
    \   1\n        else\n            fib(n-1)+fib(n-2)\n        end\n    end\n   \
    \ \n\"\"\"\n    fibs(n::Int64)::Array{Int64}\nReturn the Fibonacci numbers of\
    \ length n.\n    >>> fibs(4)\n    [1, 1, 2]\n\"\"\"", "    let  result::Int64\
    \ = 1\n    let  result::Int64 = 1\n    let  result::Int64 = 1\n    let  result::Int64\
    \ = 1\n    let  result::Int64 = 1\n    let  result::Int64 = 1\n    let  result::Int64\
    \ = 1\n    let  result::Int64 = 1\n    if n < 2 \n        then result\n      \
    \  else\n            fib(n - 1) + fib(n - 2)\nend\n</code>\n<|/ a tags=julia |>\n\
    <| c |>\nThis is extremely inefficient and not Julia's preferred way of doing\
    \ things. It would be better if you used a `while` loop.\n<|/ c |>\n<| c |>\n\
    I didn't want to include a while loop because I thought the answer would just\
    \ be too long so I didn't want to confuse the OP by adding an additional example.\n\
    <|/ c |>\n<| a |>\nMy take on it using map:\n<code>\nfibs = map(fibonacci, (1:9))\n\
    </code>\n<|/ a tags=julia dscore=4 |>\n<| a |>\nHere's a straight forward implementation\
    \ in pure Julia.\n<code>", "    if n<2 return n\n    else return fib(n-2) + fib(n-1)\n\
    end\n</cell>\n<code language=julia-0.5>\n@time fib(5)\n</cell>\n<text>\nExercise\
    \ 5\nThe following function takes as argument a positive integer and returns the\
    \ number of digits in it.  For example:", "    if n == 0 then \n        return\
    \ 1\n    else\n        return fib(n - 1) + fib(n - 2)\n</code>\n<|/ a dscore=3\
    \ tags=recursion,fibonacci,julia |>\n<| a dscore=3 |>\n<code>\nfib(n) = n <= 2\
    \ ? 1 : fib(n-1) + fib(n-2)\n</code>\n<|/ a tags=recursion,fibonacci,julia |>\n\
    <| c |>\nThis is great but you should add an explanation to your answer.\n<|/\
    \ c |>\n<| c |>\nThe \"explanation\" is in the comments :)\n<|/ c |>\n<| a dscore=3\
    \ tags=recursion,fibonacci,julia |>\n<code>", "    n, a, b = 0, 0, 1\n    while\
    \ n > 0\n        a, b = b, a + b\n        n = n - 1\n    return a\n</code>\n<|/\
    \ a dscore=4 |>\n<| a tags=fibonacci,julia |>\nI like this one too, but I decided\
    \ to add some improvements to it and added the ability to calculate the nth fibonacci\
    \ number without creating an extra variable and also make it work with larger\
    \ numbers and other functions.\n<code>", "    if n <= 2 return n\n    else return\
    \ fib(n - 2) + fib(n - 1)\nend", "  if n < 2\n    return n\n  else\n    return\
    \ fib(n-2) + fib(n-1)", "    if n <= 2 return n\n    return fib(n - 1) + fib(n\
    \ - 2)\nend\n</code>\n<|/ a dscore=3 tags=fibonacci,julia |>\n<| a tags=fibonacci,julia\
    \ |>\nTo add to, you can use the native function fib:\n<code>\njulia> fib(n)\n\
    fib(::Int64, n)", "    if n == 0 \n        0\n    else\n        fib(n - 1) + fib(n\
    \ - 2)\nend\n</cell>\n<code language=julia-1.0>\n@time fib(10)\n</cell>\n<code\
    \ language=julia-1.0>\n@time fib(100)\n</cell>\n<code language=julia-1.0>", " \
    \   if n < 2 then 1 else fib(n-2) + fib(n-1)\nend\n\"\"\"\n    \n\"\"\"\n    fib2(n::Int64)::Int64\n\
    Return a Fibonacci number `F(n)`", "\"\"\"Return Fibonacci number in Python\n\
    \    https://www.python.org/dev/peps/pep-0515/\"\"\"\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    ", "    if n==1 \n        res=1 \n  \
    \  else \n        res=fib(n-1)+fib(n-2) \nend \nreturn res \nend ", "    if n\
    \ <= 0\n    then 0\n    else fib(n-2) + fib(n-1)\n    end\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nThis is a very useful technique. However I don't think it is the\
    \ best answer in terms of performance, especially for big numbers.\n<|/ c |>\n\
    <| c |>\nFor this particular use case (checking fibonacci), yes. However it might\
    \ be a good thing to keep in mind. For example, if you want to find the fibonacci\
    \ number for number `n` where `fibonacci(n) = n^2 + 1`, you can do this in linear\
    \ time.\n<|/ c |>\n<| c |>\nNice trick! I learned a lot from this.\n<|/ c |>\n\
    <| c |>\nI see that this is similar to Haskell's `fib` function [link](https://stackoverflow.com/questions/40765308/why-does-haskell-not-have-a-built-in-fibonacci-number-function).\n\
    <|/ c |>\n<| c |>\nBut it doesn\u2019t use the fact that Haskell has the infinite\
    \ list at all - it just uses it lazily.\n<|/ c |>\n<| a tags=fibonacci,recursion,fibonacci-heap,algorithm,julia\
    \ |>\nA recursive version (from Haskell):\n<code>\nfibs [] = [0]\nfibs (x:xs)\
    \ | x == 0 = 1\n             | x == 1 = 1\n             | otherwise = fibs (x\
    \ - 1) + fibs (x - 2)\n</code>\nIt has O(n) complexity. Not sure why it takes\
    \ so much longer than your implementation though.\n<|/ a dscore=4 |>\n<| c |>\n\
    This has linear complexity. It\u2019s probably better suited for an infinite list.\n\
    <|/ c |>\n<| a tags=fibonacci,recursion,fibonacci-heap,algorithm,julia |>\nThis\
    \ version is probably more efficient than the recursive one because no new elements\
    \ are being added at the top of the stack. Also, the list is prepended, rather\
    \ than appended.\n<code>", "  if n==0 || n==1 then\n    return n\n  else \n  \
    \  return fib(n-1) + fib(n-2) \nend\n</cell>\n<text>\nTest it\nMake sure it works\
    \ (hint: you only need to call the function once)", "    if n <= 0 \n        fib(0)\
    \ \n    else \n        fib(n-1) + fib(n-2) \nend \nend \nend \nend \n</cell>\n\
    <code language=julia-0.4>\n@time fib(100)\n</cell>\n<text>\nExercise 3", "   \
    \ if n == 0\n        1\n    else if n == 1\n        0\n    else\n        fib(n-1)\
    \ + fib(n-2)\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nOne simple way\
    \ of doing it is to calculate the n-th term by doing (n-1)(n-2)(n-3)...(n-k) and\
    \ then adding the last term and dividing by n-k. This would give you the complexity\
    \ as O(n).\nYou can do this by using the following two recursive methods.\n<code>",
  "    if (n<0)\n        println(\"Error: negative integer passed\")\n    else\n \
    \       let a,b=fib(n-1),fib(n-2)\n        a in b>0?b+a:b\nend\n</cell>\n<cell>\n\
    #export\n\"\"\"Return nth Fibonacci number.\n>>> fib(10)\n55\n>>> fib(1)\n1\n\
    >>> fib(8)\n21\n\"\"\"", "    local a\n    local b\n    \n    if n==0 then\n \
    \       return 0\n    end\n    \n    if n==1 then\n        return 1\n    end\n\
    \    \n    local c=a+b\n    a=b\n    b=c\n    \n    return b\nend\n</code>\nIn\
    \ Julia, you can just type fib(10), or fib(10), to get the 10th Fibonacci number.\n\
    But you can also use recursion to get the n-th Fibonacci number\n<code>", "  \
    \  if n == 0 then return 1\n    if n == 1 then return 1\n    return fib(n-2) +\
    \ fib(n-1)\nend", "    if n<2 then return 1 \n    else return fib(n-1)+fib(n-2)\
    \ \nend \n\"\"\"Calculate the n-th Fibonacci number.\n    >>> fib(10)\n    55\n\
    \    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    >>>\
    \ fib(10)\n    55\n    \"\"\"", "    if n == 0 || n == 1\n        return n\n \
    \   return fib(n - 1) + fib(n - 2)\nend\n</cell>\n<text>\nFibonacci Recursive\
    \ function\nLet $f(x)=x^2+x-1$\nWe will implement it using recursive function.",
  "    if n == 0 || n == 1 \n        then return n\n    else \n        return fib(n-1)+fib(n-2)\n\
    end", "    if n == 0 \n        0 \n    elif n == 1 \n        1 \n    else \n \
    \       fib(n-2) + fib(n-1) \nend \nfib(n) \nend \n</cell>\n<text>\nFibonacci\
    \ function written in Julia\nWe write our own fibonacci function from scratch",
  "    if n<0\n    then\n        fib(-n)\n    else\n        fib(n-1)+fib(n-2)\n  \
    \  end\nend\n</cell>\n<code language=julia-0.4>\n\"\"\"Return n-th Fibonacci number.\n\
    \    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\
    \"\"", "    if n<0\n        error(\"Bad arguments for fibonacci\")\n    elif n>20\n\
    \        error(\"Too many Fibonacci numbers\")\n    else\n        sum=0\n    \
    \    sum1=1 \n        sum2=2\n        for i = 3..n\n            sum=sum1+sum2\n\
    \            sum1=sum2\n            sum2=sum\n        end\n        sum\n    end\n\
    end\n</cell>\n<text>\nWrite a function that finds the Fibonacci number of the\
    \ number $n$ if $n$ is in the Fibonacci sequence up to $20$. You can use the $F(n)$\
    \ notation and write a loop that will go up to $n$ without using the $F(n)$ notation.",
  "    if n <= 1 \n    then return n\n    else fib(n - 1) + fib(n - 2)\n    end\n\
    end\n</cell>\n<code language=julia-0.6>\n\"\"\"Return n-th Fibonacci number.\n\
    >>> fib(10)\n55\n>>> fib(1)\n1\n>>> fib(8)\n21\n\"\"\"", "    if n == 0 then 1\n\
    \    elif n == 1 then 1\n    else fib(n-1) + fib(n-2)\n    end\nend", "    if\
    \ n == 0 || n == 1 \n        then return 1\n    elseif n == 2\n        then return\
    \ 2\n    else \n        return fib(n-1)+fib(n-2)\nend\n</code>\n<|/ a |>\n<| a\
    \ tags=julia,fibonacci dscore=0 |>\nI have written a simple recursive function\
    \ that generates a fibonacci list with even length. \n<code>", "    if n < 2 then\
    \ return n else fib(n - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.2>",
  "    if n<2 \n        then 1\n    else fib(n-1) + fib(n-2)\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nThis would be a lot better if it also had a tail recursive version.\
    \ The problem is that `n` isn't actually used at all, but it's used as a function\
    \ argument.\n<|/ c |>\n<| c |>\nThanks for the reminder. I'm still learning about\
    \ Julia and didn't know that that syntax exists :)\n<|/ c |>\n<| a dscore=4 |>\n\
    Here is one more solution:\n<code>", "    if n < 0 \n        error(\"fib(n) must\
    \ be >= 0\") \n    fib_seq = [0, 1]\n    for _ in range(n-1) \n        fib_seq.append(fib_seq[fib_seq[-1]+1])\n\
    \    return fib_seq[n-1]\nend\n\"\"\"\nReturn n-th Fibonacci number.\n\"\"\"",
  "    if n <= 1\n        1\n    else\n        fib(n-2) + fib(n-1)\n    end\nend\n\
    </cell>\n<text>\nNow let's make our function take any input - not just an Int64\
    \ (which means $n$ must also be a Float64):", "    if n < 0 \n        error(\"\
    Fibonacci number not defined.\")\n    else if n == 0\n        1\n    else if n\
    \ == 1\n        1\n    else\n        fib(n - 2) + fib(n - 1)\nend", "    if n<2\
    \ \n        then return 1 \n        else return fib(n-2) + fib(n-1)\n    end\n\
    end\n</cell>\n<text>\nLet's check our implementation with @njit first:", "   \
    \ if n<2 \n        return n\n    fib(n - 1) + fib(n - 2)\nend\n</code>\n<|/ a\
    \ tags=fibonacci,julia |>\n<| a |>\nThe accepted answer by G. Ansara is the correct\
    \ one. Here are some other ways to implement the Fibonacci series in Julia using\
    \ a recursive function:\n<code>\n# Version 1 by Ansara Sarkar", "    if n < 2\n\
    \    else fib(n-1) + fib(n-2)\nend\n</code>\n<|/ a tags=fibonacci,julia,recursion\
    \ |>\n<| a |>\nMy solution in Julia 1.5.1:\n<code>", "    if n < 2 \n    then\
    \ 1\n    else fib(n-2) + fib(n-1)\n    end\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a |>\nThe solution I found in this book is using recursive algorithms which\
    \ is pretty cool. However it is not that efficient (O(log(N)) time). If you are\
    \ familiar with dynamic programming you may use memoization to solve this problem\
    \ in O(1).\n<code>", "    if n<0\n        return -1\n    elif n==0\n        return\
    \ 0\n    else if n==1\n        return 1\n    else \n        return fib(n-1)+fib(n-2)\n\
    </code>\n<|/ a tags=fibonacci,haskell,recursion dscore=1 |>\n<| a dscore=1 |>\n\
    <code>\nfib0 = 1\nfib1 = 1\nfib2 = 1\nfib3 = 0", "    if n == 0 \n        return\
    \ 1 \n    else if n == 1 \n        return 1 \n    else \n        return fib(n-1)\
    \ + fib(n-2) \nend\n</cell>\n<code language=julia-1.0>\n\"\"\"Return n-th Fibonacci\
    \ number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n  \
    \  21\n    \"\"\"", "    if n <= 0 \n        then -1\n    else if n == 1\n   \
    \     then 1\n    else fib(n-1) + fib(n-2)\nend\n</code>\n<|/ a |>\n<| c |>\n\
    This code does not compile, can you please post a version that does.\n<|/ c |>\n\
    <| a tags=fibonacci,julia dscore=1 |>\nA little late, but here is a Julia implementation\
    \ using the recursive function fib\n<code>", "    if n <= 1 \n        then return\
    \ n\n    else fib(n-1) + fib(n-2)\n    end\nend\n</code>\n<|/ a |>\n<| a dscore=2\
    \ |>\nI wrote this in Julia but it's the same idea in other languages. It's more\
    \ efficient than the recursive version. \n<code>", "    if n==0 || n==1 \n   \
    \ then return 1 \n    else return fib(n-1) + fib(n-2) \nend\n</code>\n<|/ a tags=julia,fibonacci\
    \ |>\n<| a tags=julia,fibonacci |>\n<code>", "    if n==0 || n==1 \n        return\
    \ n\n    else \n        return fib(n-1)+fib(n-2)\nend \n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=fibonacci,julia |>\n<code>", "    if n <= 2 then 1\n    else fib(n-1)\
    \ + fib(n-2)\nend\n</cell>\n<code language=julia-0.6>\nfib(12)\n</cell>\n<code\
    \ language=julia-0.6>\n@assert fib(6) == 13\n@assert fib(7) == 19\n@assert fib(8)\
    \ == 26\n@assert fib(9) == 34\n@assert fib(10) == 55\n</cell>\n<text>\nProblem\
    \ 8\nWrite a recursive function called fibo that returns the $n$th Fibonacci number\
    \ for $0 \\leq n \\leq 10$.", "    if n < 1\n    then return 1\n    elif n < 2\n\
    \    then return 1\n    else return fib(n-2) + fib(n-1)\nend \n</code>\nTo call\
    \ it, you simply do:\n<code>\nfib(10)\n</code>\n<|/ a tags=julia,recursion,fibonacci\
    \ |>\n<| c |>\nThanks for the explanations. I'm actually looking to implement\
    \ the recursive version. I've edited the question to clarify that.\n<|/ c |>\n\
    <| c |>\nThank you. I would also like to mention that there is also the [memoization](https://en.wikipedia.org/wiki/Memoization)\
    \ approach.\n<|/ c |>\n<| a |>\nUsing a global variable is fine, but I would generally\
    \ recommend against using a global variable. Instead, use the fibonacci function:\n\
    <code>\nfibonacci(n)\n    if n <= 0\n        0\n    elseif n == 1\n        1\n\
    \    elseif n == 2\n        1\n    else\n        fibonacci(n - 1) + fibonacci(n\
    \ - 2)\n    end\nend\n</code>\nThis will allow you to define a new Fibonacci function\
    \ and keep your global variable out of your global namespace.\n<|/ a dscore=1\
    \ tags=julia,recursion,fibonacci |>\n<| c |>\nThanks! This was actually my first\
    \ approach but didn't work. Looks like I've made a mistake somewhere.\n<|/ c |>\n\
    <| c |>\nThe global variable thing works fine. Thanks for pointing that out. I'm\
    \ just curious about why it didn't work when I tried to use it inside a function.\n\
    <|/ c |>\n<| c |>\nThe reason it didn't work is because you were trying to use\
    \ the global variable, but you needed to use `fibonacci` instead.\n<|/ c |>\n\
    <| c |>\nI see. I misunderstood what a global variable was in Julia. Thanks for\
    \ clearing that up.\n<|/ c |>\n<| c |>\nI actually think that the global variable\
    \ is fine in this case since the function is only being called recursively.  It's\
    \ just not recommended for code readability, since other parts of the code may\
    \ call `fibonacci`, even though it doesn't do any recursion itself.\n<|/ c |>\n\
    <| a dscore=1 |>\nIf you want to use global variable, it would be like this:\n\
    <code>", "  if n <= 1 then return n\n  else return fib(n-1) + fib(n-2)\nend\n\
    </cell>\n<code language=julia-1.4>\n\"\"\"Return n-th Fibonacci number.\n>>> fib(10)\n\
    55\n>>> fib(1)\n1\n>>> fib(8)\n21\n\"\"\"", "    if (n < 0) || (n<=1)\n      \
    \  return n\n    else\n        return fib(n - 1) + fib(n - 2)\nend", "    if n<=1\
    \ then return 1 else return fib(n-1)+fib(n-2) \nend \n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThe OP wants to use a recursive function, and this approach will\
    \ blow the stack if the number of terms gets too large.  See my answer for a non-recursive\
    \ solution that runs in constant space and does not blow the stack.\n<|/ c |>\n\
    <| c |>\nThe OP didn't say anything about speed or efficiency.  Recursion is just\
    \ one way to do this.\n<|/ c |>\n<| c |>\nWell, that isn't true - the OP did say\
    \ \"use a recursive function\" - the recursion is in the function definition,\
    \ and as such is not constant time.  Also, your recursive function doesn't take\
    \ any parameters.  So, the OP doesn't say anything about speed or efficiency either.\
    \  Your function will return an error if `n` is less than 1.\n<|/ c |>\n<| a tags=recursion,julia,fibonacci\
    \ |>\nI wanted to write something more general than the ones posted above. Let\
    \ me describe what I've done here.\nThe Fibonacci series was presented in a nice\
    \ video on youtube https://www.youtube.com/watch?v=p6QvXeWQMjM and here is the\
    \ code from his video\n<code>", "    if n < 2\n    else fib(n-1)+fib(n-2)\n  \
    \  end\nend", "    if n == 0 \n    then return 0\n    else if n == 1 \n    then\
    \ return 1\n    else return fib(n - 1) + fib(n - 2)\nend\nfib(1)\n</cell>\n<code\
    \ language=julia-1.4>\n\"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n\
    \    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"", "    if n\
    \ < 2\n        return n\n    else\n        return fib(n - 1) + fib(n - 2)\nend\n\
    </code>\n<|/ a tags=julia,fibonacci |>\n<| c |>\nWhile this code may answer the\
    \ question, it would be better to explain how it solves the problem and why to\
    \ use it. Code-only answers are not useful in the long run.\n<|/ c |>\n<| c |>\n\
    The question was about why Julia can not compute this formula, not how to use\
    \ it. And this was a short and easy answer, so I did not try to explain how it\
    \ works.\n<|/ c |>\n<| c |>\nThank you for the explanation.\n<|/ c |>\n<| a dscore=5\
    \ tags=julia,fibonacci |>\nThe answer provided above does not work for Julia v0.6.1\
    \ (which is what I was using)\nThe correct way to define fibonacci is\n<code>",
  "    if n == 0\n        0\n    elseif n == 1\n        1\n    else\n        fib(n-1)\
    \ + fib(n-2)\nend\n</code>\nBut this approach will slow you down.\nThe OOP solution\
    \ can look like this (using fibonacci numbers as objects):\n<code>\n\"\"\"Object\
    \ for storing fibonacci numbers\"\"\"\nmutable struct FibonacciNumber\n    n::Int64\n\
    end", "    if n <= 0 then \n        throw(ArgumentError(\"n must be positive number\"\
    ))\n    elseif n == 1 then \n        return 1 \n    elseif n == 2 then \n    \
    \    return 1 \n    else \n        return fib(n - 1) + fib(n - 2) \nend\n</cell>\n\
    <code language=julia-1.2>\n# test fibonacci\nfib(10)\n</cell>\n<code language=julia-1.2>",
  "    if n <= 1\n        1\n    else\n        fib(n-1) + fib(n-2)\n    end\nend\n\
    </code>\n<|/ a |>\n<| a tags=fibonacci,julia,fibonacci-heap |>\nThe accepted answer\
    \ has a bug: it returns nth fibonacci number not nth Fibonacci number.\nHere is\
    \ a fix that returns the nth Fibonacci number:\n<code>", "    if n == 0 \n   \
    \     then return 0\n    else if n == 1 \n        then return 1\n    else \n \
    \       return fib(n-2) + fib(n-1)\nend\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype fib(10)\n</cell>\n<text>\nA function in Julia can have multiple\
    \ return values. Julia will return the last line as its return value.", "    if\
    \ n == 0 | n == 1 \n        then return n\n    elseif n == 2 \n        then return\
    \ 1\n    else\n        fib(n - 1) + fib(n - 2) \n    end\nend", "if n < 3 \n \
    \   1 \nelse if n == 0 \n    1 \nelse \n    fib(n-1) + fib(n-2) \nend \nend \n\
    </cell>\n<code language=julia-0.6>\n\"\"\"\nFibonacci Number Recursive Function.\n\
    \"\"\"", "    if n == 0 \n        1\n    else \n        fib(n-1) + fib(n-2)\n\
    end", "    if n==0 or n==1 \n        return n\n    else\n        return (fib(n-1)\
    \ + fib(n-2))\n    end\nend\n</cell>\n<text>\nPractice with Fibonacci numbers\n\
    What does it mean to take a Fibonacci number and square it? How about multiplying\
    \ it by itself? If you have a list of numbers, square each element, and sort it\
    \ in ascending order, what is the largest Fibonacci number you can get?", "  \
    \  if n <= 1 \n        return n \n    fib(n - 2) \n    fib(n - 1) \n    return\
    \ n ", "    if n < 2 \n        then 1\n        else fib(n-2) + fib(n-1) \nend\n\
    </code>\n<|/ a |>\n<| c |>\nThe second one is O(n), not O(log(n)). O(log(n)) is\
    \ called `logarithmic time` not `linear`. The first one is O(2^n) not O(n).\n\
    <|/ c |>\n<| c |>\nThanks for pointing out. Corrected.\n<|/ c |>\n<| a dscore=3\
    \ |>\nIn Julia, the answer is simple:\n<code>\njulia> fibonacci(7)\n 8", "   \
    \ if n <= 2\n    then 1\n    else fib(n-1) + fib(n-2)\nend", "    if n<=0\n  \
    \  then return 1\n    else fib(n-1)+fib(n-2)\n    end \nend\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype fib(10)\n</cell>\n<text>\nOk, so we defined a function that returns\
    \ n-th Fibonacci number. Let's see how it works when n = 10:", "    if n < 0 \n\
    \        throw(DomainError(\"fib: n must be >= 0\"))\n    if n == 0 \n       \
    \ return 1 \n    return fib(n-1) + fib(n-2) \nend", "    if n == 0 \n    then\
    \ return 0\n    else if n == 1 \n    then return 1\n    else return fib(n - 1)\
    \ + fib(n - 2)\n    end\nend\n</cell>\n<code language=julia-1.5>\n@code_warntype\
    \ fib(10) fib(1)\n</cell>\n<text>\nRecursive Fibonacci\nFunctions written recursively\
    \ are often very similar to those that iteratively. We will show how to write\
    \ Fibonacci using recursion.", "    if n == 0\n    then return 1\n    else if\
    \ n == 1\n    then return 1\n    else return fib(n-1) + fib(n-2)\nend\n</cell>\n\
    <text>\nExercise: Implement a generator for Fibonacci numbers. Then calculate\
    \ the sum of all these numbers.\nHint: you probably need recursion for this",
  "    if n < 0 | n > 40 | n >= 40 then \n        error(\"Invalid argument\") \n \
    \   else if n < 0 | n > 40 | n == 0 then \n        1 \n    else if n == 1 then\
    \ \n        0 \n    else if n == 2 then \n        1 \n    else \n        fib(n\
    \ - 1) + fib(n - 2)\n</code>\n<|/ a dscore=1 tags=ocaml,fibonacci |>\n<| a dscore=0\
    \ |>\nThis is not a direct answer to your question, but I'd like to present another\
    \ way to solve this problem in OCaml, which uses lazy evaluation to obtain the\
    \ nth fibonacci number by remembering the previous ones.\nThis could be compared\
    \ to the \"O(n)\" solution in O(n^2) time complexity where you have to remember\
    \ the previous fibonacci numbers as well.\n<code>\nlet fib0 () = print_endline\
    \ \"0\"; fib1 () = print_endline \"1\"; fib2 () = print_endline \"2\"; fib3 ()\
    \ = print_endline \"3\"; fib4 () = print_endline \"4\"; fib5 () = print_endline\
    \ \"5\"; fib6 () = print_endline \"6\"; fib7 () = print_endline \"7\"; fib8 ()\
    \ = print_endline \"8\"; fib9 () = print_endline \"9\"; fib10 () = print_endline\
    \ \"10\"; fib11 () = print_endline \"11\"; fib12 () = print_endline \"12\"; fib13\
    \ () = print_endline \"13\"; fib14 () = print_endline \"14\"; fib15 () = print_endline\
    \ \"15\"; fib16 () = print_endline \"16\"; fib17 () = print_endline \"17\"; fib18\
    \ () = print_endline \"18\"; fib19 () = print_endline \"19\"; fib20 () = print_endline\
    \ \"20\"; fib21 () = print_endline \"21\"; fib22 () = print_endline \"22\"; fib23\
    \ () = print_endline \"23\"; fib24 () = print_endline \"24\"; fib25 () = print_endline\
    \ \"25\"; fib26 () = print_endline \"26\"; fib27 () = print_endline \"27\"; fib28\
    \ () = print_endline \"28\"; fib29 () = print_endline \"29\"; fib30 () = print_endline\
    \ \"30\"; fib31 () = print_endline \"31\"; fib32 () = print_endline \"32\"; fib33\
    \ () = print_endline \"33", "    if n == 0\n        1\n    else if n == 1\n  \
    \      1\n    else\n        fib(n - 1) + fib(n - 2)\n    end\nend\n</cell>\n<text>\n\
    Tests\nWe can test the function with the test below. Here we check that the function\
    \ works for\n$n=10$, $n=11$, $n=12$, and $n=13$.", "    if n < 1\n        1\n\
    \    else\n        fib(n-1) + fib(n-2)\n    end\nend\n</cell>\n<code language=julia-1.2>",
  "    if n <= 2\n    then 1\n    else fib(n-2) + fib(n-1)\n    end\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=julia,fibonacci |>\nHere is the Julia version of\
    \ the same program:\n<code>", "    if n <= 1 \n    then return n \n    else return\
    \ fib(n - 1) + fib(n - 2) \nend\n</cell>\n<code language=julia-1.3>\n@time fib(10)\n\
    </cell>\n<code language=julia-1.3>\n@time fib(10)\n</cell>\n<text>\nRecursive\
    \ Function Calls", "    if (n==0) \n        1 \n    else if (n==1) \n        1\
    \ \n    else \n        fib(n - 1) + fib(n - 2) \nend \nfib(n::Int64)\nend\n</cell>\n\
    <text>\nWe can use Fibonacci numbers to compute many things in Julia. For example,\
    \ we can write code to compute all integers that are $2^n$ and less than some\
    \ limit $n$. As you might have guessed, Julia's syntax for writing this code is\
    \ extremely similar to the syntax for Python:", "    if n <= 1 return n\n    else\
    \ return fib(n - 1) + fib(n - 2)\nend", "    if n==0 then return 0\n    elif n==1\
    \ then return 1\n    else return fib(n-1)+fib(n-2)\n</code>\n<|/ a tags=recursion,fibonacci,julia\
    \ |>\n<| c |>\nThe first code was missing a return statement in the recursive\
    \ call. The second code doesn't make use of tail-call optimization.\n<|/ c |>\n\
    <| c |>\nThanks for the points. I have added the missing return statement.\n<|/\
    \ c |>\n<| a |>\nTo use memoization in Julia, you can use Memoize macro.\nI wrote\
    \ a blogpost about memoization using Fibonacci series: http://www.lisaac.on.ca/~phillips/Memoization.html\n\
    The code here can be found here: https://github.com/phillips125/memoization/blob/master/fibonacci.jl\n\
    Here is a minimal example:\n<code>\nusing Memoize\nfib(10)\nfib(10)\nfib(10)\n\
    </code>\nThe result will be:\n<code>\n5\n5\n5\n</code>\n<|/ a tags=recursion,fibonacci,julia\
    \ dscore=2 |>\n<| a tags=recursion,fibonacci,julia |>\nThe most straight forward\
    \ implementation is the following: \n<code>", "    if n<2 return n\n    else return\
    \ fib(n-2) + fib(n-1)\nend", "  if n <= 0 \n    throw(ArgumentError(\"Invalid\
    \ argument $n\"))\n  else if n == 1  \n    1\n  else  \n    fib(n-1) + fib(n-2)\n\
    end\n</cell>\n<text>\nWe will now implement a version of map which operates over\
    \ Fibonacci numbers. We will also use a higher-order function which we will call\
    \ map which applies a function over a list to produce a result. Recall that map\
    \ takes a function which operates on one element and applies it to every element\
    \ of a list. This is the equivalent of our inner function fib which operates over\
    \ one argument and produces a result. We will now implement the map function.",
  "    if n == 0 || n == 1 \n        return n\n    else \n        return (fib(n-1)\
    \ + fib(n-2)) \nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=functional-programming,recursion,julia,performance\
    \ |>\nHere's a one-liner\n<code>\nfib(n) = n == 0 || n == 1 ? n : (fib(n-2) +\
    \ fib(n-1))\n</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease explain how your approach\
    \ works (you know it's more helpful for future readers). Code only answers aren't\
    \ as helpful as an explanation.\n<|/ c |>\n<| c |>\nThe recursive calls are already\
    \ optimized in Julia. I think this should be the accepted answer.\n<|/ c |>\n\
    <| c |>\nWhile this code may answer the question, providing additional context\
    \ regarding *how* and *why* it solves the problem would improve the answer's long-term\
    \ value.\n<|/ c |>\n<| a tags=functional-programming,recursion,julia,performance\
    \ |>\nJulia has an optimized fibonacci function. It is in the math package. \n\
    <code>\njulia> using Math", "    if n == 0 || n == 1 then\n        return 1\n\
    \    else\n        return fib(n-2) + fib(n-1)\n    end\nend\n</cell>\n<cell>\n\
    @doc fib\n</cell>\n<text>\nFibonacci numbers can be expressed as a recursive function.\
    \ The following recursive function computes the n-th Fibonacci number:", "   \
    \ \"\"\"\n    Last Fibonacci number in Python\n    \"\"\"\n    a, b = 0, 1\n \
    \   while a < n:\n        a, b = b, a+b\n    return b", "    if n<2 \n       \
    \ then n else fib(n - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.3>",
  "    if n == 0\n    then 1\n    else fib(n-1)+fib(n-2)\nend", "    if n < 0 \n \
    \       throw(RangeError(\"$n cannot be negative\"))\n    if n == 0\n        throw(ArithmeticError(\"\
    $n cannot be 0\"))\n    if n == 1\n        throw(ArithmeticError(\"$n cannot be\
    \ 1\"))\n    fib(n - 1) + fib(n - 2)\nend\n</cell>\n<text>\nThis function is an\
    \ example of a recursive function in Julia. It takes two arguments and uses recursion\
    \ to generate an answer. The function definition starts with a function head,\
    \ which specifies the function\u2019s name, followed by parentheses containing\
    \ the arguments to the function, and finally followed by the closing parentheses.",
  "    if n < 2 then\n        return n\n    else\n        return fib(n-1) + fib(n-2)\n\
    \    end\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis would be my implementation,\
    \ but it's too slow. Just try it yourself on julia> fib(1000000)\n<|/ c |>\n<|\
    \ c |>\nYes, it's slow, but I don't think it's that bad.\n<|/ c |>\n<| c |>\n\
    If this is still not fast enough for you, you can try https://github.com/nchopin/Fibonacci.jl\n\
    <|/ c |>\n<| c |>\nFor those who are wondering why this is slow compared to others.\
    \ This is because the recursive approach is too slow and will run out of stack\
    \ space. Just use memoization and you'll see that this is much faster. See the\
    \ answers below.\n<|/ c |>\n<| c |>\nThe above code is incorrect. Try fib(0) or\
    \ fib(1).\n<|/ c |>\n<| a dscore=5 tags=julia |>\n<code>", "    if n < 2\n   \
    \ then 1\n    else fib(n-2) + fib(n-1)\nend", "    if n <= 1\n    then return\
    \ n\n    else \n    return fib(n-1) + fib(n-2) \nend \n</cell>\n<code language=julia-1.4>\n\
    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n\
    \    1\n    >>> fib(8)\n    21\n    \"\"\"", "    if n <= 1 then 1 else fib(n-1)\
    \ + fib(n-2) \nend \n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe `if n > 1` condition\
    \ is redundant when `fib(n-1) + fib(n-2)` will do that exact same thing anyway.\
    \ You've also glossed over the fact that the recursive implementation doesn't\
    \ return anything (it uses `return fib(n-1) + fib(n-2)`).\n<|/ c |>\n<| c |>\n\
    : You're right. I've added a fibonacci implementation, which returns something.\n\
    <|/ c |>\n<| c |>\nYour fibonacci implementation doesn't return anything.\n<|/\
    \ c |>\n<| a dscore=0 tags=julia |>\n<code>\n# fibonacci series\nusing BenchmarkTools",
  "    if n<0\n        error(\"invalid input $n\")\n    else if n==0\n        1\n\
    \    else if n==1\n        1\n    else\n        fib(n-2) + fib(n-1)\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\n#export\n\"\"\"Return n-th Fibonacci\
    \ number.\n>>> fib(10)\n55\n>>> fib(1)\n1\n>>> fib(8)\n21\n\"\"\"", "    if n<2\
    \ then return n\n    else return fib(n-1)+fib(n-2)\nend function\n\"\"\"Return\
    \ last Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n   \
    \ >>> fib(8)\n    21\n    \"\"\"", "    if n == 0\n    then return 1\n    else\
    \ if n == 1\n    then return 1\n    else return fib(n-1) + fib(n-2)\nend\n</cell>\n\
    <code language=julia-1.3>\nfib(2)\n</cell>\n<code language=julia-1.3>\nfib(10)\n\
    </cell>\n<code language=julia-1.3>\nfib(-1)\n</cell>\n<code language=julia-1.3>\n\
    fib(-10)\n</cell>\n<code language=julia-1.3>\n# Python code from http://wiki.python.org/moin/SimplePrograms\n\
    def fib(n):\n    \"\"\"Print a Fibonacci series up to n.\"\"\"\n    a, b = 0,\
    \ 1\n    while a < n:\n        print(a, end=' ')\n        a, b = b, a + b\n  \
    \  print()", "  if n<2 return n\n  else return fib(n-1)+fib(n-2)\n</code>\n<|/\
    \ a tags=fibonacci,recursion,julia |>\n<| a tags=fibonacci,recursion,julia dscore=4\
    \ |>\nI know I'm late but here are a few more recursive options that don't require\
    \ global variables nor an explicit if statement:\n<code>", "        if n < 0 \n\
    \            throw(ArgumentError(\"The argument must be positive integer.\"))\n\
    \        elif n == 0 \n            throw(ArgumentError(\"The argument must be\
    \ positive.\"))\n        else\n            fib(n - 1) + fib(n - 2)\n        end\n\
    \    end\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia |>\nThe solution of is correct\
    \ in that it uses function composition but since it's from 2017, Julia has added\
    \ the function composition operator \u2218 for this. If you need to use function\
    \ composition, here is another possible solution for doing that in Julia.\n<code>\n\
    fib(::Int) = \n    \u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218\
    \ (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218\
    \ (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218\
    \ (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218\
    \ (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218\
    \ (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218\
    \ (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218\
    \ (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218\
    \ (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218\
    \ (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218\
    \ (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218\
    \ (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218\
    \ (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218 (\u2218\
    \ (\u2218 (\u2218 (", "        if n < 2\n        then n\n        else\n      \
    \  fib(n - 1) + fib(n - 2)\nend\n</cell>\n<text>\nWe used the @njit decorator\
    \ to wrap our code. njit compiles Julia code to a fast native machine code. On\
    \ the contrary, @native compiles to machine code that is much faster. The Julia\
    \ compiler optimizes the function call overhead in our code so that it runs quickly\
    \ on our machine.", "    if n == 0\n        0\n    elseif n == 1\n        1\n\
    \    else\n        fib(n - 1) + fib(n - 2)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @code_native fib\n</cell>\n<code language=julia-1.5>\n@code_native fib(0)\n</cell>\n\
    <code language=julia-1.5>\n@code_native fib(1)\n</cell>\n<code language=julia-1.5>\n\
    @code_native fib(8)\n</cell>\n<code language=julia-1.5>\n@code_native fib(-7)\n\
    </cell>\n<code language=julia-1.5>\n@code_native fib(20)\n</cell>\n<code language=julia-1.5>\n\
    @code_native fib(10)\n</cell>\n<code language=julia-1.5>\n@code_native fib(100)\n\
    </cell>\n<code language=julia-1.5>\n@code_native fib(1e6)\n</cell>\n<code language=julia-1.5>\n\
    @code_native fib(1e10)\n</cell>\n<code language=julia-1.5>\n@code_native fib(1e12)\n\
    </cell>\n<text>\nExercise: Fibonacci numbers\nWrite a Julia function fibonacci(n)\
    \ that returns the n-th Fibonacci number. Test it using fibonacci(10), fibonacci(1),\
    \ fibonacci(8), and fibonacci(-7). How many fibonacci numbers are there? How does\
    \ it look like (plot)?\nIn case you are interested in memoization, write a function\
    \ memofibonacci(n) where memofibonacci(n) is memoized version of fibonacci().\
    \ Test it using memofibonacci(10); memofibonacci(1), memofibonacci(8), and memofibonacci(-7).\
    \ How many fibonacci numbers are there?", "    x,y::Int64\n    \n    if n>2\n\
    \        x=fib(n-1)\n        y=fib(n-2)\n        return x+y\n    end\n    return\
    \ 1\nend\n</cell>\n<text>\nWrite a function fib_seq that returns Fibonacci numbers,\
    \ starting from 0 and stopping when the sequence is exhausted.", "    if n < 0\n\
    \        0\n    else\n        fib(n-1) + fib(n-2)\nend", "    if n < 2 then return\
    \ 1\n    return fib(n-2) + fib(n-1)\n</code>\n<|/ a dscore=0 tags=fibonacci,haskell\
    \ |>\n<| c |>\nPlease don't use `fib n = fib (n-1) + fib (n-2)` in general.  It\
    \ uses recursion which can be expensive.  The recurrence relation is `fib(n) =\
    \ n if n < 2 else fib(n-1) + fib(n-2)`.  It is a special case, namely when `n\
    \ < 2`.\n<|/ c |>\n<| a tags=fibonacci,haskell dscore=0 |>\nHere is my solution,\
    \ which I hope will be simple to understand.\n<code>\nfibn n =\n  if n < 2 then\
    \ n\n  else fib (n-2)+fib (n-1)\n</code>\n<|/ a |>\n<| a dscore=0 tags=fibonacci,haskell\
    \ |>\nHere is a simple implementation of fibonacci in Haskell:\n<code>\nfib 0\
    \ = 0\nfib 1 = 1\nfib n = fib (n-1) + fib (n-2)", "    if n <= 0\n        error(\"\
    Fibonacci sequence can't be generated for negative input.\")\n    elseif n <=\
    \ 2\n        return 1\n    else\n        return fib(n-1) + fib(n-2)\nend\n</code>\n\
    <|/ a tags=julia |>\n<| c |>\nThanks. It's a good solution but I am looking for\
    \ something that works with all types of inputs(including negatives), including\
    \ floats.\n<|/ c |>\n<| c |>\nI have updated the code, including a version which\
    \ works with floats. However, I hope you realize that this version will produce\
    \ memory leaks as `fib` recurses infinitely.\n<|/ c |>\n<| c |>\nThanks. This\
    \ is an interesting solution and it works even with floats. I don't realize that\
    \ memory leaks could occur.\n<|/ c |>\n<| a tags=julia |>\nHere are two other\
    \ options for you:\n<code>\n\"\"\"fibonacci!(n) calculates fibonacci numbers up\
    \ to n\"\"\"", "    if n==0 || n==1 then return n\n    fib(n - 1) + fib(n - 2)\n\
    end", "    if n <= 1\n        fib(n - 1) + fib(n - 2)\n    else\n        fib(n\
    \ - 1) + fib(n - 2)\n    end\nend\n</cell>\n<code language=julia-1.3>\n\"\"\"\
    Return Fibonacci numbers in reverse order.\n    >>> fib_reverse(10)\n    [55]\n\
    \    >>> fib_reverse(1)\n    [1]\n    >>> fib_reverse(8)\n    [13]\n\"\"\""]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
