name: HumanEval_27_flip_case
language: pl
prompt: "# For a given string, flip lowercase characters to uppercase and uppercase\
  \ to lowercase.\n# >>> flip_case(\"Hello\")\n# \"hELLO\"\nsub flip_case {\n    my($string)\
  \ = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&flip_case;\n\
  \        if(eq_deeply($candidate->(\"\"),\"\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Hello!\"),\"hELLO!\"\
  )) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  These violent delights have violent ends\"),\"tHESE VIOLENT DELIGHTS HAVE VIOLENT\
  \ ENDS\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return\
    \ $string;\n}", "    tr/a-z/A-Z/;\n    tr/A-Z/a-z/;\n    return $string;\n}",
  "    $string =~ tr/a-zA-Z//cd;\n    return $string;\n}", "    $string =~ tr/A-Z/a-z/;\n\
    \    $string =~ tr/a-z/A-Z/;\n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/A-Za-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/a-zA-Z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    my $s = uc($string);\n\
    \    $s =~ tr/a-z/A-Z/;\n    $s =~ tr/A-Z/a-z/;\n    return $s;\n}", "    return\
    \ lc($string) =~ tr/a-z/A-Z/;\n}", "    my($uppercase) = 0;\n    my($lowercase)\
    \ = 0;\n    foreach $char (split //, $string) {\n        next if $char eq '_';\n\
    \        next if $char eq '.';\n        $uppercase++ if $char eq 'A';\n      \
    \  $lowercase++ if $char eq 'a';\n        $uppercase-- if $char eq 'B';\n    \
    \    $lowercase-- if $char eq 'b';\n        $string = $char if ($uppercase ==\
    \ 0 and $lowercase == 0);\n        $string = $char if ($uppercase != 0 and $lowercase\
    \ != 0);\n        $string = $char if ($uppercase == 0 and $lowercase != 0);\n\
    \        $string = $char if ($uppercase != 0 and $lowercase == 0);\n    }\n  \
    \  return $string;\n}", "    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n\
    \    return $string;\n}\n</code>\n<|/ a tags=perl,perl5 |>\n<| c |>\nJust `tr/a-zA-Z//cd`\
    \ would be even better.\n<|/ c |>\n<| c |>\n, yes, that would be better if you\
    \ wanted to preserve uppercase letters.\n<|/ c |>\n<| c |>\n, oh dear! I'm so\
    \ embarrassed. Yes, of course, that was a silly mistake! `tr/a-zA-Z//cd` works\
    \ just as well.\n<|/ c |>\n<| c |>\nI think I've been bitten by that too once!\
    \ :)\n<|/ c |>\n<| c |>\nThe `tr` substitution isn't so bad, but I think a simple\
    \ `lc` on the string would be a far simpler way of solving OP's problem.\n<|/\
    \ c |>\n<| a |>\nThe accepted answer is incorrect - it will convert any case to\
    \ lower or upper case, not just the first letter of each word.\n<code>\nuse 5.010;\n\
    use strict;\nuse warnings;", "    my $result = $string;\n    foreach my $character\
    \ (split //, $string) {\n        $result = $character if lc($character) != $character;\n\
    \        $result = uc($character) if uc($character) != $character;\n    }\n  \
    \  return $result;\n}", "    $string =~ tr/[a-z]/[A-Z]/;\n    $string =~ tr/[A-Z]/[a-z]/;\n\
    \    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    return uc($string) unless $string =~ tr/a-z/A-Z/;\n\
    \    return lc($string);\n}\n</code>\n<|/ a tags=case,perl,replace,regex |>\n\
    <| c |>\nThanks Ikegami for the quick reply. Sorry I should have mentioned I tried\
    \ both of those options you mentioned and they did not work for me.", "    my\
    \ $length = length $string;\n    my $upcase;\n    my $downcase;\n    my $i = 0;\n\
    \    \n    # Flip all lowercase characters.\n    for (; $i < $length; $i++) {\n\
    \        if ($string->[$i] eq 'a') {\n            $string->[$i] = 'A';\n     \
    \   } elsif ($string->[$i] eq 'A') {\n            $string->[$i] = 'a';\n     \
    \   } else {\n            next;\n        }\n    }\n    \n    # Flip all uppercase\
    \ characters.\n    for (; $i < $length; $i++) {\n        if ($string->[$i] eq\
    \ 'A') {\n            $string->[$i] = 'a';\n        } elsif ($string->[$i] eq\
    \ 'a') {\n            $string->[$i] = 'A';\n        } else {\n            next;\n\
    \        }\n    }\n    \n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}\n</code>\n<|/ a tags=perl,regex\
    \ |>\n<| c |>\nThanks for this - I like that I can use variables in the regexp\
    \ to keep things readable and easy to maintain. Thanks again for the thorough\
    \ explanation as well.\n<|/ c |>\n<| a dscore=2 |>\nUse a map to swap case:\n\
    <code>", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return\
    \ $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n  \
    \  return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n\
    \    return $string;\n}", "    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n\
    \    return $string;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI like this one\
    \ the best.  It does use less memory than a solution that uses split and join\
    \ since it only requires one regex match.\n<|/ c |>\n<| c |>\nI like the use of\
    \ split and join here\n<|/ c |>\n<| c |>\nI like this one the best because it\
    \ doesn't rely on any external modules. Very clean and easy to understand.\n<|/\
    \ c |>\n<| a dscore=2 |>\n<code>\nmy $str = \"hello world\";", "    $string =~\
    \ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    return\
    \ $string if $string !~ /\\A[A-Z]+/;\n    $string =~ tr/a-zA-Z/A-Z/;\n    $string\
    \ =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n   \
    \ $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}\n</code>\n<|/ a |>\n<| c\
    \ |>\nThe `tr` solution is much better than mine - you should post it.\n<|/ c\
    \ |>\n<| c |>\nThe `tr` solution is better, especially on longer strings. I was\
    \ trying to keep this as simple as possible, for brevity, but if speed is an issue,\
    \ your solution is better.\n<|/ c |>\n<| a dscore=1 |>\nYou could also use regexes.\
    \ Something like this would probably work:\n<code>\n$string =~ s/(\\w)(\\w*)/lc($1).($1)/g;\n\
    </code>\n<|/ a tags=perl,case-folding |>\n<| a tags=perl,case-folding |>\nThis\
    \ works on Windows Perl:\n<code>", "    return uc($string) if $self->_case_flip_flag;\n\
    \    return lc($string);\n}", '    my $upper;', "    my $uppercase;\n    my $lowercase;",
  "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/A-Z/a-z/i;\n    $string =~ tr/a-z/A-Z/;\n    return $string;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/a-zA-Z/A-Za-z/;\n    $string =~ tr/A-Za-z/a-zA-Z/;\n  \
    \  return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    # Make sure we're given something.\n    return\
    \ $string if !defined($string);\n    # Make upper case letters become lower case\
    \ letters.\n    $string =~ tr/A-Z/a-z/;\n    # Make lower case letters become\
    \ upper case letters.\n    $string =~ tr/a-z/A-Z/;\n    # Return the result.\n\
    \    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    my $flip = \"\";\n    for my $c (split(//, $string))\
    \ {\n        $flip .= $c eq $c ? \"_\" :\n            $c eq \"A\" ? \"a\" :\n\
    \            $c eq \"B\" ? \"b\" :\n            $c eq \"C\" ? \"c\" :\n      \
    \      $c eq \"D\" ? \"d\" :\n            $c eq \"E\" ? \"e\" :\n            $c\
    \ eq \"F\" ? \"f\" :\n            $c eq \"G\" ? \"g\" :\n            $c eq \"\
    H\" ? \"h\" :\n            $c eq \"I\" ? \"i\" :\n            $c eq \"J\" ? \"\
    j\" :\n            $c eq \"K\" ? \"k\" :\n            $c eq \"L\" ? \"l\" :\n\
    \            $c eq \"M\" ? \"m\" :\n            $c eq \"N\" ? \"n\" :\n      \
    \      $c eq \"O\" ? \"o\" :\n            $c eq \"P\" ? \"p\" :\n            $c\
    \ eq \"Q\" ? \"q\" :\n            $c eq \"R\" ? \"r\" :\n            $c eq \"\
    S\" ? \"s\" :\n            $c eq \"T\" ? \"t\" :\n            $c eq \"U\" ? \"\
    u\" :\n            $c eq \"V\" ? \"v\" :\n            $c eq \"W\" ? \"w\" :\n\
    \            $c eq \"X\" ? \"x\" :\n            $c eq \"Y\" ? \"y\" :\n      \
    \      $c eq \"Z\" ? \"z\" :\n            $c;\n    }\n    return $flip;\n}", " \
    \   return lc $string if $case eq 'lower';\n    return uc $string if $case eq\
    \ 'upper';\n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string\
    \ =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/a-zA-Z/A-Za-z/;\n\
    \    $string =~ tr/A-Za-z/a-zA-Z/;\n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    \n    # If the string\
    \ doesn't contain any lowercase characters, just return the\n    # input string.\n\
    \    return $string if !$string =~ /[a-z]/;\n    \n    # Convert to uppercase.\n\
    \    my $upper = $string;\n    $upper =~ s/[a-z]/[A-Z]/ig;\n    \n    # Convert\
    \ to lowercase.\n    $upper =~ s/[A-Z]/[a-z]/ig;\n    \n    return $upper;\n}",
  "    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n    return $string;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", '    my(@output);', "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}\n</code>\n<|/ a |>\n<| a dscore=5 tags=perl,string |>\n\
    To uppercase first character of each word in the string use uc($string) (or uc($_)\
    \ for older versions) instead of ucfirst($string).\n<code>\n$ perl -e 'print \"\
    HELLO WORLD\" =~ s/\\b\\w/\\U&/rg;'\nHELLO WORLD\n</code>\n<|/ a |>\n<| c |>\n\
    `ucfirst` doesn't work if the string has leading or trailing spaces, so I'd recommend\
    \ `uc`.\n<|/ c |>\n<| c |>\nIt doesn't work if the first character is capital.\n\
    <|/ c |>\n<| c |>\n`uc` works in cases where `ucfirst` doesn't.\n<|/ c |>\n<|\
    \ c |>\nI thought ucfirst was the newer name for uc. Not so much anymore.\n<|/\
    \ c |>\n<| c |>\nSee [this answer](https://stackoverflow.com/a/5393717/622391)\
    \ on why `ucfirst` is preferable to `uc`.\n<|/ c |>\n<| a tags=perl,string dscore=5\
    \ |>\nThis isn't a direct answer to the question, but rather a simpler solution\
    \ to the same problem.  If you need to trim all leading/trailing whitespace characters\
    \ from a string (including tabs, newlines, etc), you can use the built-in trim()\
    \ function:\n<code>\nuse strict;\nuse warnings;", "    return $string =~ tr/a-zA-Z//d;\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| c |>\nA good answer indeed. However I'd use\
    \ `tr/a-z/A-Z/` instead of `tr/a-z//d`.\n<|/ c |>\n<| c |>\n: No need to use the\
    \ `//` flag (which forces a re-search and replace on every character in the string),\
    \ since the `tr` will do that for you (i.e. `tr/a-z/A-Z/)`. So there's no need\
    \ to specify `/s` in the regex, since the default search and replace will do that\
    \ for you.\n<|/ c |>\n<| c |>\nI see. Well I have learned something new today\
    \ :-)\n<|/ c |>\n<| a dscore=3 |>\nFor a case insensitive regex match in Perl,\
    \ you can use the /i flag as follows:\n<code>\nif ( /string/ix ) { ... }\n</code>\n\
    For a case sensitive match without case folding, use the /s flag, as such:\n<code>\n\
    if ( /string/s ) { ... }\n</code>\n<|/ a tags=perl,case-insensitive,regex |>\n\
    <| c |>\nThank you. That's a good one. I just learned that `/s` modifies the search\
    \ to be case sensitive.\n<|/ c |>\n<| a tags=perl,case-insensitive,regex |>\n\
    The /i flag in perl is useful to ignore case for strings matching patterns. \n\
    For example, a pattern /hello/ is matched in both Hello and HELLO but /Hello/\
    \ is matched in only Hello.\nI guess it might be useful in your case.\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 |>\n<code>\nif ( $string =~ m/^[a-z]*$/i )\n</code>\n<|/ a\
    \ tags=perl,case-insensitive,regex |>\n<| c |>\nYou don't need the `/i` flag in\
    \ this case, since you're not using the `/i` flag to modify your regex.\n<|/ c\
    \ |>\n<| c |>\n: That's a great point. I'd forgotten about that. Thanks :)\n<|/\
    \ c |>\n<| a |>\n<code>\nif ( $string =~ m/^[a-z]*$/ )\n</code>\n<|/ a tags=perl,case-insensitive,regex\
    \ dscore=0 |>\n<| c |>\nThat's not a very good answer. It ignores the case, which\
    \ is probably not what the OP wanted.\n<|/ c |>\n<| c ", "    return $string unless\
    \ length $string;\n    return $string unless length $string;\n    return lc($string)\
    \ unless $string =~ /[a-z]/i;\n    return uc($string) unless $string =~ /[A-Z]/i;\n\
    \    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n\
    \    return $string;\n}", "    my ($uppercase_char, $lowercase_char) = map {lc\
    \ $_} split //, $string;\n    return $uppercase_char if $lowercase_char =~ /[a-z]/;\n\
    \    return $lowercase_char if $uppercase_char =~ /[A-Z]/;\n    return $string;\n\
    }", "    my $result;\n    if ($string =~ /\\w/) {\n        $string =~ tr/a-zA-Z/A-Z/;\n\
    \        $string =~ tr/A-Z/a-z/;\n    }\n    $result;\n}", "    $string =~ tr/[a-z]/[A-Z]/;\n\
    \    $string =~ tr/[A-Z]/[a-z]/;\n    return $string;\n}", "    return lc $string\
    \ if $string !~ /[A-Z]/;\n    return uc $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    my $lower;\n    my\
    \ $upper;", "    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n    return\
    \ $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n  \
    \  return $string;\n}", "    my $lowercase = $string;\n    $lowercase = lc $lowercase;\n\
    \    $lowercase = uc $lowercase;\n    $lowercase;\n}", "    return $string unless\
    \ length($string) > 0;\n    my $ret = \"\";\n    $ret .= uc($string) if ($string\
    \ =~ /[a-z]/);\n    $ret .= lc($string) if ($string =~ /[A-Z]/);\n    return $ret;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    return lcfirst(tolower($string));\n}", "    $string =~ tr/a-zA-Z/A-Za-z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}\n</code>\nSo why do we need\
    \ the flip-case function?\nLets assume that we have read a file and it contains\
    \ lines like this:\n<code>\na b\nb c\n</code>\nIf we wanted to print each line\
    \ in a different color, we can do that by flipping the case of each line. This\
    \ is what our function does. It takes the input string, and flips the cases of\
    \ each character, giving us \"a\" and \"B\", etc. The function returns that same\
    \ string with its original case intact, unchanged.\nThen we could do something\
    \ like this:\n<code>", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    \n    foreach my $char (split(//,$string)) {\n\
    \        $char =~ tr/a-z/A-Z/;\n        $char =~ tr/A-Z/a-z/;\n    }", "    $string\
    \ =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "   \
    \ $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n    return $string;\n}",
  "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    \n    my @string = split(//, $string);\n    my @flipped_string = ();\n\
    \    \n    foreach my $letter (@string) {\n        push(@flipped_string, map {lc($_)}\
    \ split(//, $letter));\n    }\n    \n    return join(//, @flipped_string);\n}",
  "    local $_ = lc $_;\n    $_ = uc $_;\n    return $_;\n}", "    $string =~ tr/a-zA-Z//cd;\n\
    \    $string =~ tr/A-Za-z/A-Z//cd;\n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    my $ret = '';", " \
    \   my $flipped_case = $string;\n    $flipped_case =~ tr/a-z/A-Z/;\n    $flipped_case\
    \ =~ tr/A-Z/a-z/;\n    return $flipped_case;\n}", "    $string =~ tr/A-Za-z/a-z-A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    \n    $string =~ tr/a-zA-Z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;", "    map { lc } map { uc } split //, $string;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    my($result) = \"\";\n    foreach my $letter (split //, $string) {\n \
    \       $letter = lc $letter;\n        $letter = uc $letter;\n        $result\
    \ .= $letter;\n    }\n    return $result;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    return lc($string)\
    \ unless length($string);\n    $string =~ s/^[a-z]*//;\n    $string =~ s/^[A-Z]*//;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/A-Z/a-z/;\n\
    \    $string =~ tr/a-z/A-Z/;\n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    my $lowercase;\n \
    \   my $uppercase;\n    my $length   = length($string);\n    my $string2  = $string;",
  "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/a-zA-Z/A-Za-z/;\n    return $string;\n}", "    $string\
    \ =~ tr/a-zA-Z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", " \
    \   return lc($string) unless $string =~ /[a-z]/;\n    return uc( $string );\n\
    }", "    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n    return $string;\n\
    }", "    $string =~ tr/a-zA-Z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/a-zA-Z/A-Za-z/;\n    $string =~ tr/A-Za-z/a-zA-Z/;\n  \
    \  return $string;\n}", "    $string =~ tr/A-Z/a-z/i;\n    $string =~ tr/a-z/A-Z/;\n\
    \    return $string;\n}", "    my @chars = split(//, $string);\n    for (@chars)\
    \ {\n        if (lc $_) {\n            $_ =~ tr/A-Z/a-z/;\n        }\n       \
    \ if (uc $_) {\n            $_ =~ tr/a-z/A-Z/;\n        }\n    }\n    return join(\"\
    \", @chars);\n}", "    return lc $string if $string =~ /[a-z]/i;\n    return uc\
    \ $string if $string =~ /[A-Z]/i;\n    return $string;\n}", "    return ucfirst\
    \ if $case == Lc; # Don't touch Lc\n    $string =~ tr/[a-z]/[A-Z]/;\n    $string\
    \ =~ tr/[A-Z]/[a-z]/;\n    return $string;\n}", "    return lc($string) unless\
    \ $string =~ /[A-Z]/;\n    return uc($string);\n}", "    my @chars = split(//,\
    \ $string);\n    foreach my $idx (0..$#chars) {\n        $chars[$idx] = lc ($chars[$idx]);\n\
    \    }\n    return join(\"\", @chars);\n}", "    $string =~ tr/a-z/A-Z/;\n   \
    \ $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/a-zA-Z//cd;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    my @result = ();\n\
    \    my $i = 0;\n    my $j = 0;\n    my $length = $string->length;\n    for ($i\
    \ = 0; $i < $length; $i++) {\n        $result[$i] = (ord($string->[$i]) ^ ord($string->[$i+1]));\
    \ \n        $i+=2;\n    }\n    for ($j = 0; $j < $length; $j++) {\n        $result[$j]\
    \ = ord($string->[$j]) ^ ord($string->[$j+1]);\n        $j+=2;\n    }\n    \n\
    \    return join('',@result);\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~\
    \ tr/A-Z/a-z/;\n    return $string;\n}", "    \n    my $flipped = \"\";\n    \n\
    \    foreach my $char (split //, $string) {\n        if ($char eq '_') {\n   \
    \         $flipped .= $char;\n        } elsif ($char eq 'l') {\n            $flipped\
    \ .= 'L';\n        } elsif ($char eq 'i') {\n            $flipped .= 'I';\n  \
    \      } else {\n            $flipped .= $char . ucfirst($char);\n        }\n\
    \    }\n    \n    return $flipped;\n}", "    my $uppercase = uc($string);\n  \
    \  $uppercase = lc($uppercase);\n    $uppercase = uc($uppercase);\n    return\
    \ $uppercase;\n}", "    my $result = \"\";\n    $string =~ tr/a-z/A-Z/;\n    $string\
    \ =~ tr/A-Z/a-z/;\n    return $result;\n}", "    # Lowercase to uppercase letters.\n\
    \    $string =~ tr/a-zA-Z/A-Z/;\n    # Uppercase to lowercase letters.\n    $string\
    \ =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/a-zA-Z/A-Za-z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    return $string =~\
    \ tr/A-Za-z/A-Z-a-z/;\n}", "    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n\
    \    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}\n</code>\nNow all we have to do is write a subroutine\
    \ to generate all the possible words from your dictionary.\n<code>", "    $string\
    \ =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", '    my
    $result;', "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return\
    \ $string;\n}", "    return $string =~ tr/a-z/A-Z/;\n}\n</code>\nNote that this\
    \ uses the tr/a-z/A-Z/; perl function to perform the substitution. This means\
    \ it will convert lowercase to uppercase and vice versa. \nAs it returns a bool,\
    \ you can use a short-circuiting operator to simplify your if statement:\n<code>",
  "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n    return $string;\n\
    }\n</code>\nNote that you can write this more concisely using gsub and tr:\n<code>",
  "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }\n</code>\n<|/ a tags=perl,regex |>\n<| a tags=perl,regex |>\nHere's a regex\
    \ that will do it, but only if your alphabet is [a-z][A-Z] or [A-Z][a-z]:\n<code>\n\
    \\Q$string\\E(\n</code>\nIf you don't care about the capitalization, this is shorter\
    \ and easier to read:\n<code>\n($string =~ /([a-z])([A-Z])/g\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nI'm afraid that doesn't work because it matches strings like \"\
    I\" and \"Ie\". What he really wants is for it to be case-insensitive.\n<|/ c\
    \ |>\n<| c |>\nAh, I misread the question then. I thought he wanted both upper\
    \ and lower case. I deleted my previous comment so this one doesn't appear out\
    \ of context.\n<|/ c |>\n<| a dscore=0 |>\nIf you don't need to worry about case-sensitivity\
    \ and are sure that your string only contains uppercase letters and lowercase\
    \ letters, you could just use the case-insensitive (?i) flag:\n<code>\n$string\
    \ =~ /^([A-Z]+)$/i;\n</code>\n<|/ a tags=perl,regex |>\n<| a dscore=0 tags=perl,regex\
    \ |>\n<code>\nuse strict;\nuse warnings;", "    return lc($string) eq uc($string)\
    \ ? uc($string) : lc($string);\n}", "    $string =~ tr/a-z/A-Z/;\n    $string\
    \ =~ tr/A-Z/a-z/;\n    return $string;\n}", "    my $result = $string;\n    for\
    \ my $i (0..length($string)-1) {\n        my $char = $string[$i];\n        if\
    \ ($char !~ /^[a-z]/) {\n            $char =~ tr/a-z/A-Z/;\n        }\n      \
    \  $result .= $char;\n    }\n    return $result;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}\n</code>\nUsing a hash is\
    \ useful if you want to transform all letters individually, e.g.\n<code>", " \
    \   $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n    return $string;\n\
    }", "    return $string if $string !~ /\\w/;\n    return uc($string);\n}", " \
    \   $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    map {\n        $_ =~ tr/A-Z/a-z/;\n        tr/a-z/A-Z/;\n    } split\
    \ //, $string;\n}\n</code>\nThe perldoc -f map tells us what it does. map takes\
    \ a BLOCK and a LIST as its arguments. In this case we use the map function to\
    \ apply the BLOCK to each element of LIST.\nThe BLOCK is a subroutine reference\
    \ (a name that refers to a subroutine). This subroutine takes the current element\
    \ from the list and transforms it to uppercase letters and then to lowercase.\
    \ The tr// operator returns the string \"changed\" if a substitution was made,\
    \ and returns \"\" if no substitutions were made. That empty string is what we\
    \ store in $_.\nThe split // splits the string $string into a list of words, and\
    \ returns the list of words. It splits on whitespace (spaces, tabs, newlines,\
    \ etc.).\nThe map subroutine above transforms each word in the list to uppercase\
    \ and then to lowercase.\nThe return value of the map subroutine is what's stored\
    \ in the LIST. This is a new list that contains the transformed words returned\
    \ by map instead of the original words.\n<|/ a |>\n<| c |>\nThank you for the\
    \ explanation. It cleared a lot more things about 'map' in the perl documents\n\
    <|/ c |>\n<| c |>\n`tr///` is more idiomatic than `map` - you avoid creating an\
    \ array just for side effects and then throwing it away.\n<|/ c |>\n<| c |>\n\
    `tr///` is more idiomatic than `map` - you avoid creating an array just for side\
    \ effects and then throwing it away. `tr///` is for translating one character\
    \ set into another and `map` is for translating a LIST of characters into another\
    \ LIST of characters. `tr///` is used for simple translations and `map` is used\
    \ for complex translations. If the complexity is not high then `tr///` is faster.\n\
    <|/ c |>\n<| c |>\nIf speed is your main concern then use the most idiomatic `map`\
    \ you can find: `map { tr//d } split //, $string;` - `tr///` is for translating\
    \ one character set into another and `map` is for translating a LIST of characters\
    \ into another LIST of characters. `tr///` is used for simple translations and\
    \ `map` is used for complex translations. If the complexity is not high then `tr///`\
    \ is faster.\n<|/ c |>\n<| c |>\nI don't think that speed is really the issue\
    \ here; you're using it for something that doesn't fit well in the current idiom\
    \ for that task. ", "    map {\n        $string =~ tr/A-Z/a-z/;\n        $string\
    \ =~ tr/a-z/A-Z/;\n    } split //, $string;\n    return $string;\n}", "    $string\
    \ =~ tr/a-zA-Z/A-Za-z/;\n    return $string;\n}", "    # $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n    return $string;\n\
    }", "    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n    return $string;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    return $string =~ tr/a-z/A-Z/;\n}", "    return lc($string) unless lc($string)\
    \ =~ /[a-z]/i;\n    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n   \
    \ return $string;\n}", "    $string =~ tr/a-zA-Z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    return map {\n        my $x = uc $x;\n        $x\
    \ eq $x ? uc($x) : $x\n    } split //, $string;\n}", "    $string =~ tr/A-Z/a-z/;\n\
    \    $string =~ tr/a-z/A-Z/;\n    return $string;\n}", "    my $uppercase;\n \
    \   my $lowercase;\n    for (split('', $string)) {\n        $uppercase = $lowercase\
    \ || $_ eq \"_\" ? \"_\" : uc($_);\n        $lowercase = $_ eq \"_\" ? \"_\" :\
    \ lc($_);\n    }\n    return $lowercase . $uppercase;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    return $string if\
    \ ( $string =~ s/^([a-z])|([A-Z])/$1_$2/g );\n    return;\n}", "    my $upper\
    \ = uc($string);\n    my $lower = lc($string);\n    return $string if $upper eq\
    \ $string;\n    return $lower;\n}", "    my $i = 0;\n    while ($i < length($string))\
    \ {\n        $string =~ tr/A-Z/a-z/;\n        $string =~ tr/a-z/A-Z/;\n      \
    \  $i += 1;\n    }\n    return $string;\n}", "    $string =~ tr/A-Z/a-z/;\n  \
    \  $string =~ tr/a-z/A-Z/;\n    return $string;\n}", "    $string =~ tr/a-zA-Z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}\n</code>\n<|/ a dscore=4\
    \ |>\n<| a tags=perl,string,php |>\nFor Perl\n<code>\n$str =~ tr/a-z/A-Z/;\n$str\
    \ =~ tr/A-Z/a-z/;\n</code>\n<|/ a dscore=4 |>\n<| c |>\nIn order to make it a\
    \ little more readable, you can do `tr/a-z/A-Z/;tr/A-Z/a-z/;`\n<|/ c |>\n<| c\
    \ |>\n: Thanks mate, appreciate it :)\n<|/ c |>\n<| a |>\nPHP version\n<code>\n\
    <?php", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return\
    \ $string;\n}", "    my $result = $string;\n    $result =~ tr/a-z/A-Z/;\n    $result\
    \ =~ tr/A-Z/a-z/;\n    return $result;\n}", "    $string =~ tr/a-zA-Z/A-Za-z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/A-Za-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 |>\nThis works:\n<code>", "    map {\n        if (lc($_) eq\
    \ uc($_))\n        {\n            $_;\n        }\n        else\n        {\n  \
    \          $_ eq lc($_) ? uc($_) : lc($_);\n        }\n    } split(//, $string);\n\
    }", "    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n    return $string;\n\
    }", "    return map { lc( uc($_) ) } map {; uc($_) } split //, $string;\n}", " \
    \   my $new = \"\";\n    for my $char (split(//,$string)) {\n        next if $char\
    \ eq \"_\";\n        $char = \"A\" unless lc($char) eq \"A\";\n        $char =\
    \ \"a\" unless lc($char) eq \"a\";\n        $char =~ tr/a-zA-Z/A-Za-z/;\n    \
    \    $new .= $char;\n    }\n    return $new;\n}", "    return $string if $string\
    \ !~ /^[a-z]/i;\n    return $string unless $string =~ /^[a-z]/i;\n    $string\
    \ =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "   \
    \ return $string =~ tr/a-z/A-Z/;\n}", "    $string =~ tr/A-Z/a-z/;\n    $string\
    \ =~ tr/a-z/A-Z/;\n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n   \
    \ $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/a-zA-Z/A-Za-z/;\n\
    \    $string =~ tr/A-Za-z/a-zA-Z/;\n    return $string;\n}", "    return map {\n\
    \        my($char) = uc($char);\n        ($char eq 'a') ? ($char eq 'A') ? $char\
    \ : uc($char) : strtoupper($char)\n    } split('', $string);\n}", "    $string\
    \ =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "   \
    \ # Using 'tr' with two arguments is much faster than using 'ucfirst'\n    # and\
    \ 'lcfirst'\n    return uc($string) unless $string =~ /^[A-Z]+$/;\n    return\
    \ lcfirst($string);\n}", "    my $result = uc($string);\n    $result =~ tr/A-Z/a-z/;\n\
    \    $result =~ tr/a-z/A-Z/;\n    return $result;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| a dscore=1 |>\nA bit late in the answer but for those who are looking\
    \ for a way to achieve this using Perl, a very simple way is to use sub routines\
    \ and recursion as follows:\n<code>", "    return $string if !defined($string);\n\
    \    my (@new_string) = $string =~ /((?<=\\p{Upper})|(?<=\\p{Lower}))/ig;\n  \
    \  return $new_string if !@new_string;\n    return join ('', map {uc($_)} @new_string);\n\
    }", '    my @chars = split(//, $string);', "    return lc $string if defined $string;\n\
    \    return '';\n}", "    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n\
    \    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    $string =~ tr/A-Za-z/a-z-A-Z/;\n    $string =~\
    \ tr/a-z-A-Z/A-Za-z/;\n    return $string;\n}", "    return join(\"\", map { lc($_)\
    \ => uc($_) } split(//, $string));\n}", "    $string =~ tr/a-z/A-Z/;\n    $string\
    \ =~ tr/A-Z/a-z/;\n    return $string;\n}", "    my @words = split //, $string;\n\
    \    for my $word (@words) {\n        $word =~ tr/A-Z/a-z/;\n    }\n    return\
    \ join \"\", @words;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    return lc( uc($string) );\n}", "    $string =~\
    \ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string\
    \ =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "   \
    \ $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n}",
  "    $string =~ tr/a-zA-Z//cd;\n    $string =~ tr/A-Za-z//cd;\n    return $string;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/a-zA-Z0-9//cd;\n    return $string;\n}", "    # Flip each\
    \ character in the string.\n    return map {lc($a) eq uc($b) ? uc($a) : $a} split\
    \ //, $string;\n}", "    $string =~ tr/a-zA-Z/A-Za-z/;\n    $string =~ tr/A-Za-z/a-zA-Z/;\n\
    \    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}\n</code>\n<|/ a dscore=4 tags=perl,regex |>\n<| a tags=perl,regex\
    \ |>\nPerl 6's Regexp engine has named capture groups, which makes it easy to\
    \ do the flipping using named capture groups:\n<code>\nmy $string = 'Hello World';\n\
    say $string ~ '(?<upper>[A-Z])(?<lower>[a-z])';", "    return uc($string) . lc($string);\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
