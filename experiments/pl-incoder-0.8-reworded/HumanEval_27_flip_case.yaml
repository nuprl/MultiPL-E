name: HumanEval_27_flip_case
language: pl
prompt: "# For a given string, flip lowercase characters to uppercase and uppercase\
  \ to lowercase.\n# >>> flip_case(\"Hello\")\n# \"hELLO\"\nsub flip_case {\n    my($string)\
  \ = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&flip_case;\n\
  \        if(eq_deeply($candidate->(\"\"),\"\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Hello!\"),\"hELLO!\"\
  )) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  These violent delights have violent ends\"),\"tHESE VIOLENT DELIGHTS HAVE VIOLENT\
  \ ENDS\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n    return\
    \ $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n  \
    \  return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThe `tr` solution\
    \ is cool, but note that you can use the `/a` flag to make them all uppercase:\
    \ `my($string) = @_; $string =~ tr/a-z/A-Z/a;`. Also note that this replaces characters\
    \ from the end of the string with a space\n<|/ c |>\n<| a |>\nYou can use the\
    \ map function.\n<code>\nprint \"$string=~s/[a-z]/[A-Z]/;\"\n</code>\nThe regex\
    \ finds every letter in the string and then changes the letter to uppercase. \n\
    The map function can take multiple arrays in it.\n<code>\nprint \"@string=~m/[a-z]/&&map{uc($_)}=~m/[a-z]/&&print;\"\
    \n</code>\nIf both of the maps are true it prints the string. \nIf one of the\
    \ maps is false it does nothing.\n<|/ a dscore=1 tags=perl,regex |>\n<| a dscore=0\
    \ |>\n<code>\n$string =~ s/(^[a-z])/uc($1)/egi;\n</code>\n<|/ a tags=perl,regex\
    \ |>\n<| c |>\nThat won't work for non-ASCII character sets.\n<|/ c |>\n<| c |>\n\
    What will it not work? The question asks only for ASCII and non-ASCII.\n<|/ c\
    \ |>\n<| c |>\nI didn't even notice that he was using non-ASCII characters. My\
    \ bad. Sorry for the noise.\n<|/ c |>\n<| c |>\n`uc($1)` is a much better way\
    \ to write it.\n<|/ c |>\n<| a dscore=0 |>\nJust for fun, here's a solution using\
    \ a hash of characters:\n<code>", "    $string =~ tr/a-z/A-Z/;\n    $string =~\
    \ tr/A-Z/a-z/;\n    return $string;\n}", "    return $string =~ tr/A-Z/a-z/;\n\
    }", "    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n    return $string;\n\
    }\n</code>\n<|/ a tags=perl,case-folding,case-insensitive |>\n<| c |>\nThat is\
    \ a nice solution, but doesn't quite work. It will convert `I` to `i`, but `i`\
    \ should remain `i`.\n<|/ c |>\n<| c |>\n: I guess I should have clarified. My\
    \ original answer used a mix of tr/// and regexes. Since `tr/// ` is regex, `i`\
    \ was converted to `i`. The second `tr/[a-z]/[Ii]/` replaced `i` with `I`.\n<|/\
    \ c |>\n<| a tags=perl,case-folding,case-insensitive dscore=4 |>\n<code>\nmy =\
    \ qw(i I);\ns/(\\w)/\\L$1/;\nfor (@strings) {\n    s/\\L$//;\n    print;\n}\n\
    </code>\n<|/ a |>\n<| c |>\nThis doesn't work.  \"i\" gets changed to \"I\". \
    \ \"I\" remains \"I\".\n<|/ c |>\n<| c |>\nYes it does, and that is what it does.\
    \ You forgot to put \"i\" into \"I\" array :-)\n<|/ c |>\n<| c |>\nAh, yes.  I\
    \ thought that \"I\" was a typo for \"i\".  I deleted my comment, as you beat\
    \ me to it.\n<|/ c |>\n<| c |>\n: I deleted my comment, as you beat me to it :-)\n\
    <|/ c |>\n<| a tags=perl,case-folding,case-insensitive |>\nAs said before, this\
    \ is tricky, and I did a quick test and it seems even trickier than it first appears.\
    \ I did find a solution though, using regular expressions. The example is inspired\
    \ by Borodin Lavine's answer. \n<code>", "    $string =~ tr/a-z/A-Z/;\n    $string\
    \ =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/a-zA-Z/A-Za-z/;\n\
    \    $string =~ tr/A-Za-z/a-zA-Z/;\n    return $string;\n}", "    $string =~ tr/A-Z/a-z/;\n\
    \    $string =~ tr/a-z/A-Z/;\n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/a-zA-Z/A-Za-z/;\n\
    \    return $string;\n}", "    map {\n        my $char = $_;\n        ($char =~\
    \ tr/a-z/A-Z/) ? ($char =~ tr/A-Z/a-z/) : ($char)\n    } split(//, $string);\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n    return $string;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/a-zA-Z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    my(@characters) = split(//,$string);\n    for my $index (0..$#characters)\
    \ {\n        $characters[$index] =~ tr/A-Z/a-z/;\n    }\n    return join(\"\"\
    ,@characters);\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n\
    \    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n\
    \    return $string;\n}", "    return $string unless $string =~ s/^[a-zA-Z]+|\\\
    s+//g;\n    return lc($string) unless $string =~ /[a-z]/;\n    return uc($string);\n\
    }", "    local $string =~ s/([a-z])/uc($1)/ge;\n    $string =~ s/(uc($1))/$1/g;\n\
    \    $string;\n}", "    map {\n        my $l = uc $l;\n        uc $l if lc $l\
    \ eq $l;\n        $l\n    } split /(?!^)([A-Z])/, $string;\n}", "    $string =~\
    \ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n    return $string;\n}", "    $string\
    \ =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "   \
    \ my $string_flipped;\n    $string_flipped = $string =~ tr/a-z/A-Z/;\n    $string_flipped\
    \ =~ tr/A-Z/a-z/;", "    foreach my $char (split //, $string) {\n        my $upper\
    \ = uc($char);\n        my $lower = lc($char);\n        $string =~ s/$upper/$lower/g;\n\
    \        $string =~ s/$lower/$upper/g;\n    }\n    return $string;\n}", "    $string\
    \ =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "   \
    \ $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n}",
  "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| a |>\n<code>\n$string =~ tr/A-Z/a-z/;\n$string\
    \ =~ tr/a-z/A-Z/;\n</code>\n<|/ a dscore=4 tags=perl,lowercase,capitalization,string\
    \ |>\n<| c |>\nThanks for your answer, unfortunately your solutions doesn't work\
    \ in my case, I must do it in one line, I should have mentioned that in my question.\
    \ Anyway thanks.\n<|/ c |>\n<| a tags=perl,lowercase,capitalization,string dscore=4\
    \ |>\nThis one may solve your problem.\n<code>", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    return \"\" unless\
    \ defined $string;\n    my @chars = split(//, $string);\n    for (my $i = 0; $i\
    \ < @chars; ++$i) {\n        if ($chars[$i] eq \"A\") {\n            $chars[$i]\
    \ = \"a\";\n        } else {\n            $chars[$i] = \"A\" if ($chars[$i] eq\
    \ \"a\");\n        }\n    }\n    return join(\"\", @chars);\n}", "    my $result\
    \ = $string;\n    $result =~ tr/a-zA-Z/A-Za-z/;\n    $result =~ tr/A-Z/a-z/;\n\
    \    return $result;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    return $string unless length $string;\n    $string\
    \ =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "   \
    \ my $lower = lc $string;\n    my $upper = uc $string;\n    return $upper if $lower\
    \ eq $upper;\n    return $lower;\n}", "    $string =~ tr/A-Z/a-z/;\n    $string\
    \ =~ tr/a-z/A-Z/;\n    return $string;\n}", "    map {\n        my($char, $char2)\
    \ = @_;\n        $char = $char2 if $char eq $char2;\n        return $char;\n \
    \   } split //, $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    my($ustring) = \"\";\n    foreach $char (split\
    \ //, $string) {\n        $char = $char =~ tr/a-z/A-Z/;\n        $ustring .= $char;\n\
    \    }\n    return $ustring;\n}", "    tr/A-Z/a-z/;\n    tr/a-z/A-Z/;\n    return\
    \ $string;\n}", "    my $lower;\n    my $upper;", "    $string =~ tr/A-Z/a-z/;\n\
    \    $string =~ tr/a-z/A-Z/;\n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/a-zA-Z/A-Za-z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    return uc($string)\
    \ . lc($string);\n}\n</code>\nAs for the rest, I personally would review the design\
    \ before attempting a code dump. Perhaps some more thought should be given to\
    \ what it is that you are trying to accomplish. Perhaps there are simpler methods\
    \ that you should be considering.\n<|/ a dscore=0 |>\n<| c |>\nthank you for the\
    \ help.  I think you are right about my approach and will review the code.  I\
    \ am still new to Perl and trying to learn as much as I can.  I will post the\
    \ results of my work below.\n<|/ c |>\n<| c |>\nI added a couple of additional\
    \ hints to my answer as to what to look for.\n<|/ c |>\n<| c |>\nThanks for the\
    \ additional hints.  I have reviewed my code and found a few things.  First, I\
    \ am working with strings so no conversion is needed.  Second, I am looping through\
    \ a directory so there will not be many different file names.  Third, I am doing\
    \ a check to see if a file exists in the directory before looping through.  I\
    \ am not doing checks on specific file names but rather just looking for any file\
    \ that matches the pattern \"*.txt\"  I have added the code to the original post\
    \ as well as the final code I used.  Your comments are very helpful and I will\
    \ review my code more carefully.\n<|/ c |>\n<| c |>\nAlso, do you think the file\
    \ handle $fh will stay open for future file searches throughout the script?  I\
    \ am planning on using the file handle $fh to write to it later in the script.\
    \  I plan on using the file handle $fh for future searches to see if a file exists\
    \ or not.\n<|/ c |>\n<| c |>\nOne additional question, do you think using the\
    \ `open` method with $fh and assigning it to a variable will keep the file handle\
    \ open for the entire script? or should I use the `while` loop and use `$fh` inside\
    \ the loop?  Thanks.\n<|/ c |>\n<| a |>\nThis answer is based on's comments above\
    \ to my original post.  I am adding the final code I used to my original post\
    \ and will explain what it does and why I chose to implement it this way if anyone\
    \ else is interested.  \nThe idea behind this code was to find any files matching\
    \ my pattern of \"*.txt\" and then flip the first letter of each word to uppercase\
    \ and the last letter to lowercase to prepare them for processing.  So if the\
    \ file was \"abcde.txt\" the result would be \"ABcde.txt\" because \"abcde\" ",
  "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n    return $string;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/a-zA-Z/A-Za-z/;\n    $string =~ tr/A-Z/a-z/;\n    return\
    \ $string;\n}", "    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n  \
    \  return $string;\n}", "    my @chars = split(//, $string);\n    my $flipped_string\
    \ = join(\"\", map {\n        my $c = $chars[$_];\n        ($c eq $chars[$_] ?\
    \ $c : lc($c) eq lc($chars[$_] ? $c : uc($c)));\n    } 0..$#chars);\n    return\
    \ $flipped_string;\n}", "    $string =~ tr/a-zA-Z0-9//cd;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis only changes\
    \ the first letter of the first word in the sentence. Doesn't affect all the words\
    \ in the sentence.\n<|/ c |>\n<| c |>\nIt was my understanding that he wanted\
    \ to affect the entire sentence.\n<|/ c |>\n<| c |>\nI did notice that, but I\
    \ wanted the entire sentence to change.\n<|/ c |>\n<| c |>\nThat's why I added\
    \ the second loop.  I guess I missed a key part of his question where he said\
    \ he wanted to flip the entire sentence.\n<|/ c |>\n<| a tags=perl,regex,case,capitalize,replace\
    \ |>\nOne option using split:\n<code>\nmy $str = \"Hello  world\";\nmy = split\
    \ /\\s+/, $str;", "    return lc($string) unless $string =~ /[a-z]/i;\n    return\
    \ uc($string);\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    local $_ = lc($_);\n    $_ = uc($_);\n    $_;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a |>\nThis is an old question, but for anyone\
    \ wondering here is a Perl solution using the Perl's built-in translate operator:\n\
    <code>", "    return $string =~ tr/a-z/A-Z/;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}\n</code>\nThe trick is that\
    \ tr/a-z/A-Z/ is doing the flipping, which replaces all the lower case letters\
    \ with upper case ones and vice versa. tr/A-Z/a-z/ does the reverse and replaces\
    \ the upper case ones with lower case. Since they both do the same thing, we could\
    \ just use tr/A-Za-z/a-zA-Z/ to do the flipping without changing the meaning.\n\
    The second part is to convert the strings into numbers. To do that, I use the\
    \ POSIX function named \"toupper()\". Since POSIX functions are part of the Perl\
    \ package, this is a little ugly - so I make a new function called \"upper_case\"\
    \ that does the same thing. I then call that function from within the first tr\
    \ call, which does the flipping and the conversion to numbers. It looks ugly because\
    \ I have to create a new function and call it from within the first tr call, but\
    \ it makes the two steps look clear to me.\n<|/ a dscore=5 tags=case,perl,string,toupper,regex\
    \ |>\n<| c |>\nYour code works fine for me, thank you!  I was trying `uc($string)`\
    \ with no luck.\n<|/ c |>\n<| c |>\nNote that this answer doesn't actually answer\
    \ the OP's question.  It's more of a clever trick that doesn't answer the OP's\
    \ question.  But I upvoted because it answers what OP wanted to know!  Thanks\
    \ :)\n<|/ c |>\n<| c |>\nI'm going to give a checkmark to Eric's answer because\
    \ it's a bit more complete, although Eric's answer's solution does work. I've\
    \ up-voted your answer though because it's a very good explanation of how to do\
    \ it with regex which I didn't know about.\n<|/ c |>\n<| c |>\nThis answer is\
    \ a great solution for the Perl versions pre 5.6 where `tr` doesn't work\n<|/\
    \ c |>\n<| c |>\nThis is an incredible solution. Easy, clear, and straight forward.\
    \ Thank you! It also works for Perl 5.6.\n<|/ c |>\n<| a tags=case,perl,string,toupper,regex\
    \ dscore=5 |>\n<code>\n$string =~ tr/a-zA-Z\\0/A-Z/;\n</code>\n<|/ a |>\n<| c\
    \ |>\n`tr/A-Z/a-z/` would also work, and `tr/a-z\\0/A-Z/` would do the same for\
    \ anything that ", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    $string =~ tr/a-zA-Z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    return uc($string) if $^O eq 'MSWin32';\n    my\
    \ $uppercase = uc($string);\n    return $uppercase unless $^O eq 'MacOS';", " \
    \   $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n    return $string;\n\
    }", "    no warnings 'uninitialized';\n    $string =~ tr/A-Z/a-z/;\n    $string\
    \ =~ tr/a-z/A-Z/;\n    return $string;\n}", "    return lc($string) . uc($string);\n\
    }", "    $string =~ tr/[a-z]/[A-Z]/;\n    $string =~ tr/[A-Z]/[a-z]/;\n    return\
    \ $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n  \
    \  return $string;\n}", "    return $string =~ tr/a-z/A-Z/;\n}", "    return $string\
    \ unless $string;\n    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    my @flipped;\n    foreach my $char (split(//, $string))\
    \ {\n        if ($char !~ /[a-z]/) { push @flipped, '' }\n        else { push\
    \ @flipped, lc $char }\n    }\n    return join(\"\", @flipped);\n}", "    $string\
    \ =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "   \
    \ $string =~ tr/a-zA-Z//cd;\n    $string =~ tr/A-Za-z/A-Z/cd;\n    return $string;\n\
    }\n</code>\n<|/ a tags=perl,regex,case-folding |>\n<| c |>\nWhy not `tr/a-z/A-Z/`?\
    \ :)\n<|/ c |>\n<| c |>\n: Probably just habit. It's hard to see a point of `tr`\
    \ without a regex to apply it to. I could use `tr/a-z/A-Z/` but the resulting\
    \ string is twice as long.\n<|/ c |>\n<| c |>\nAh, I was thinking along the lines\
    \ of `tr/a-zA-Z//cd;` vs `tr/a-zA-Z/A-Z/cd;`. Seems obvious in hindsight, though.\n\
    <|/ c |>\n<| c |>\n: Yeah, I like that too.\n<|/ c |>\n<| c |>\n, since this has\
    \ got nothing to do with case folding, and is just a simple substitution, wouldn't\
    \ you suggest using the `sub` function instead?\n<|/ c |>\n<| a tags=perl,regex,case-folding\
    \ |>\nThe code example I gave in my other answer uses \\L to match the start of\
    \ line. I think using \\L instead will give the desired result:\n<code>\nperl\
    \ -pi.bak -e 's/\\L([a-z])/uc lc ($1)/e' *\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\
    +1 This has got to be the most straight-forward answer. `\\L` works wonderfully.\n\
    <|/ c |>\n<| c |>\n`\\L` doesn't work as expected, at least not on Perl 5.14.2\
    \ with UTF-8 and `use utf8;`. Try it yourself: on some \"normal\" strings `\\\
    L` returns the original string while on others it returns the `l` letter in lowercase.\n\
    <|/ c |>\n<| a dscore=3 |>\nThe only thing I can come up with is a case-fold regex\
    \ using (?-i:...) where ... is your string:\n<code>\nmy $s = 'Hello';", "    tr/[a-z]/[A-Z]/;\n\
    \    tr/[A-Z]/[a-z]/;\n    return $string;\n}", "    $string =~ tr/[a-z]/[A-Z]/;\n\
    \    $string =~ tr/[A-Z]/[a-z]/;\n    return $string;\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThe answer with two regular expressions was what I was looking\
    \ for. This should be the accepted answer.\n<|/ c |>\n<| c |>\nVery nice! I had\
    \ to adapt the code to handle \"1A 2\" as \"11A2\". I had to put a `return $string;`\
    \ right after the first `tr`: `return $string =~ tr/[a-z]/[A-Z]/;`\n<|/ c |>\n\
    <| a dscore=5 |>\nI wanted a function that returns a string with the first letter\
    \ capitalized (in lower case), and every other letter in lower case.\nThe \"simple\"\
    \ solution would be:\n<code>", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    my(@chars) = split //, $string;\n    for (my $i\
    \ = 0; $i < scalar(@chars); $i++) {\n        if ($chars[$i] eq \"A\") {\n    \
    \        $chars[$i] = \"a\";\n        }\n        elsif ($chars[$i] eq \"B\") {\n\
    \            $chars[$i] = \"b\";\n        }\n        elsif ($chars[$i] eq \"C\"\
    ) {\n            $chars[$i] = \"c\";\n        }\n        elsif ($chars[$i] eq\
    \ \"D\") {\n            $chars[$i] = \"d\";\n        }\n        elsif ($chars[$i]\
    \ eq \"E\") {\n            $chars[$i] = \"e\";\n        }\n        elsif ($chars[$i]\
    \ eq \"F\") {\n            $chars[$i] = \"f\";\n        }\n        elsif ($chars[$i]\
    \ eq \"G\") {\n            $chars[$i] = \"g\";\n        }\n        elsif ($chars[$i]\
    \ eq \"H\") {\n            $chars[$i] = \"h\";\n        }\n        elsif ($chars[$i]\
    \ eq \"I\") {\n            $chars[$i] = \"i\";\n        }\n        elsif ($chars[$i]\
    \ eq \"J\") {\n            $chars[$i] = \"j\";\n        }\n        elsif ($chars[$i]\
    \ eq \"K\") {\n            $chars[$i] = \"k\";\n        }\n        elsif ($chars[$i]\
    \ eq \"L\") {\n            $chars[$i] = \"l\";\n        }\n        elsif ($chars[$i]\
    \ eq \"M\") {\n            $chars[$i] = \"m\";\n        }\n        elsif ($chars[$i]\
    \ eq \"N\") {\n            $chars[$i] = \"n\";\n        }\n        elsif ($chars[$i]\
    \ eq \"O\") {\n            $chars[$i] = \"o\";\n        }\n        elsif ($chars[$i]\
    \ eq \"P\") {\n            $chars[$i] = \"p\";\n        }\n        elsif ($chars[$i]\
    \ eq \"Q\") {\n            $chars[$i] = \"q\";\n        }\n        elsif ($chars[$i]\
    \ eq \"R\") {\n            $chars[$i] = \"r\";\n        }\n        elsif ($chars[$i]\
    \ eq \"S\") {\n            $chars[$i] = \"s\";", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    my $uppercase = $string\
    \ =~ tr/a-zA-Z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $uppercase;\n}",
  "    return lc($string) if $string =~ /^[A-Z]+$/;\n    my $flipped = 0;\n    $string\
    \ =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return lc($string) if $flipped;\n\
    \    return $string;\n}\n</code>\n<|/ a tags=perl,regex |>\n<| c |>\nI like your\
    \ solution better than the one that came up with mine :)  I forgot to remove the\
    \ \"!\" from my solution when I tested it.\n<|/ c |>\n<| c |>\nIt will give false\
    \ positives for '!' if you do like this.\n<|/ c |>\n<| c |>\nThe ! was removed.\
    \  It's a good habit to get into to make sure that you know exactly what you're\
    \ doing so you're not shooting yourself in the foot.  That said, you're right\
    \ that the \"!\" is problematic.\n<|/ c |>\n<| c |>\nIt's fine to add a comment\
    \ as to why I removed it.  I was just being extra cautious :)\n<|/ c |>\n<| c\
    \ |>\nThis is really clever. I didn't think it would be that simple! I'll probably\
    \ use this.\n<|/ c |>\n<| a tags=perl,regex |>\n<code>\nmy $string = 'abcdefghijklmnopqrstuvwxyz';\n\
    print \"$string\\n\";\n$string =~ tr/a-z/A-Z/;\nprint \"$string\\n\";\n$string\
    \ =~ tr/A-Z/a-z/;\nprint \"$string\\n\";\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    This has the problem that it will return \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" instead\
    \ of \"abcdefghijklmnopqrstuvwxyz\" as the OP wanted\n<|/ c |>\n<| c |>\n, It\
    \ will work fine for me :) \nOutput: abcdefghijklmnopqrstuvwxyz\nabcdefghijklmnopqrstuvwxyz\n\
    abcdefghijklmnopqrstuvwxyz\n<|/ c |>\n<| a dscore=1 tags=perl,regex |>\nUsing\
    \ regex and tr:\n<code>\n$ cat test.pl", "    my @chars = split(//, $string);\n\
    \    my $res = join(\"\", map {lc($_) . uc($_)} @chars);\n    return $res;\n}",
  "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    my $uppercase = $string =~ tr/a-z/A-Z/;\n    my $lowercase = $string\
    \ =~ tr/A-Z/a-z/;\n    return $uppercase . $lowercase;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/A-Z/a-z/;\n\
    \    $string =~ tr/a-z/A-Z/;\n    return $string;\n}", "    $string =~ tr/A-Z/a-z/;\n\
    \    $string =~ tr/a-z/A-Z/;\n    return $string;\n}", "    return $string unless\
    \ length $string;\n    return $string if $string =~ /^[a-z]+$/;\n    return $string\
    \ =~ tr/A-Z/a-z/;\n    return $string =~ tr/a-z/A-Z/;\n}", "    my($new_string);\n\
    \    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    # See https://stackoverflow.com/questions/26104952/perl-lowercase-to-uppercase-and-vice-versa\
    \ for info on this algorithm\n    return $string =~ tr/a-z/A-Z/;\n}", "    $string\
    \ =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "   \
    \ $string =~ tr/a-zA-Z/A-Za-z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n    return $string;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    map { (lc $_) =~ tr/A-Z/a-z/; uc } $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    map {\n        my\
    \ $c = $_;\n        $c =~ tr/a-z/A-Z/;\n        $c =~ tr/A-Z/a-z/;\n    } split\
    \ //, $string;\n}", "    $string =~ tr/a-zA-Z/A-Za-z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=perl,string,perl-native\
    \ |>\nYou can use Algorithm::Loops to solve this problem. \n<code>\nuse strict;\n\
    use warnings;\nuse Algorithm::Loops qw(loops);", "    $string =~ tr/a-zA-Z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    return map { $_ eq\
    \ 'l' ? lc : $_ eq 'L' ? uc : $_ } split /(?=[A-Z])/, $string;\n}", "    $string\
    \ =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "   \
    \ map { uc($_) => lc($_) } split //, $string;\n}", "    $string =~ tr/A-Z/a-z/;\n\
    \    $string =~ tr/a-z/A-Z/;\n    return $string;\n}", "    $string =~ tr/a-zA-Z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/[a-z]/[A-Z]/;\n\
    \    $string =~ tr/[A-Z]/[a-z]/;\n    return $string;\n}", "    $string =~ tr/A-Z/a-z/;\n\
    \    $string =~ tr/a-z/A-Z/;\n    return $string;\n}\n</code>\n<|/ a tags=perl,lowercase,capitalization\
    \ |>\n<| a dscore=2 |>\nI believe that in most cases, the correct answer is to\
    \ not do what you want.  There are few valid reasons to do this.\nBut I believe\
    \ that it is possible in some cases.\nIn general, a question like this should\
    \ be avoided.  What if you have two pieces of code (or even a lot of different\
    \ pieces of code) where you need a particular capitalization convention?  Then\
    \ you will have to go in and change all of them.  How long do you think it would\
    \ be before you went through and change them all?\nOne such case is when you want\
    \ to capitalize the first letter of a word.  For example \"Dogs\" should go to\
    \ \"DOGS\".\nThe easiest way to do this would be to make a small subroutine that\
    \ takes one argument and capitalizes the first letter of that argument.  Then\
    \ make another subroutine that takes two arguments and calls those two subroutines\
    \ once on each argument.\nI recommend that you read this article on perlfaq\n\
    <|/ a tags=perl,lowercase,capitalization |>\n<| c |>\nI agree, don't do it, but\
    \ I think there's a valid use case for doing this as part of some automated testing\
    \ (for example, I want to test that some strings start with a capital letter and\
    \ have only one other character afterwards, for which I use regexes)\n<|/ c |>\n\
    <| a dscore=2 |>\nI would agree with the others, that in most cases it should\
    \ just be avoided. But there is occasionally a use for it... For example: I want\
    \ to make sure some strings are lower case, after some processing; I might want\
    \ to know that they start with a capital letter, and there is only one other character\
    \ afterwards.\nSo the code might look like this:\n<code>\nuse strict;\nuse warnings;\n\
    use 5.010;", "    $string =~ tr/a-zA-Z/A-Za-z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    $string =~ tr/a-zA-Z/A-Z/;\n    return $string;\n\
    }", "    $string =~ tr/[a-z]/[A-Z]/;\n    $string =~ tr/[A-Z]/[a-z]/;\n    return\
    \ $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n  \
    \  return $string;\n}", "    $string =~ tr/a-zA-Z//cd;\n    return $string;\n}",
  "    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n    return $string;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    foreach my $char (split(//, $string)) {\n        my $new = $char if ($char\
    \ =~ /^[a-z]/i);\n        $string .= $new if ($new =~ /^[A-Z]/i);\n    }\n   \
    \ return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    $string =~ tr/a-zA-Z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n\
    \    return $string;\n}", "    my $lcstring = lc($string);\n    return $lcstring\
    \ if !$lcstring =~ /[A-Z]/;\n    return $lcstring if $lcstring =~ /[a-z]/;\n \
    \   return $lcstring =~ tr/a-z/A-Z/;\n}", "    my($uppercase);\n    my($lowercase);",
  "    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n    return $string;\n\
    }", "    my $lowercase = $string;\n    $lowercase =~ tr/a-z/A-Z/;\n    $lowercase\
    \ =~ tr/A-Z/a-z/;\n    return $lowercase;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/A-Z/a-z/;\n\
    \    $string =~ tr/a-z/A-Z/;\n    return $string;\n}\n</code>\n<|/ a dscore=1\
    \ tags=perl,string,replace |>\n<| a |>\nA more readable version of Amadan's code\
    \ would be:\n<code>", "    my @chars = split(//, $string);\n    $chars[0] = uc($chars[0]);\n\
    \    $chars[1] = lc($chars[1]);\n    return join(\"\", @chars);\n}\n</code>\n\
    <|/ a tags=string,regex,perl dscore=5 |>\n<| c |>\nNice, but I didn't want to\
    \ use a regex, so this solution was way more effective in my case. +1\n<|/ c |>\n\
    <| c |>\nThe regex solution will fail for strings that contain the characters\
    \ \\ (backslash) and + (plus sign). To fix the problem, add the following line\
    \ before the split line: `$string =~ s/\\\\//g;`\n<|/ c |>\n<| c |>\nTo handle\
    \ backslashes use double slashes \\\\ and to handle plus signs use single plus\
    \ signs +.\n<|/ c |>\n<| c |>\n+1 for the double slashes \\\\ solution, works\
    \ fine for me.\n<|/ c |>\n<| c |>\nOne can easily flip uppercase and lowercase\
    \ with a single substitution: `$string =~ tr/A-Z/a-z/`\n<|/ c |>\n<| a tags=string,regex,perl\
    \ |>\nYou can use look-ahead assertions:\n<code>\nuse strict;\nuse warnings;",
  "    my($char, $upper);\n    foreach $char (split //, $string) {\n        $upper\
    \ = uc($char);\n        $char eq $char ? $char = $upper : $char eq $upper ? $char\
    \ = $char : $char eq $char ? $char = $upper : $char eq $upper ? $char = $upper\
    \ : $char;\n    }\n    return $string;\n}", "    $string =~ tr/A-Z/a-z/;\n   \
    \ $string =~ tr/a-z/A-Z/;\n    return $string;\n}", "    $string =~ tr/A-Z/a-z/;\n\
    \    $string =~ tr/a-z/A-Z/;\n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    my $lc = 'abcdefghijklmnopqrstuvwxyz';\n\
    \    my $uc = uc($lc);\n    $string =~ tr/a/$uc/;\n    $string =~ tr/b/$uc/;\n\
    \    $string =~ tr/c/$uc/;\n    $string =~ tr/d/$uc/;\n    $string =~ tr/e/$uc/;\n\
    \    $string =~ tr/f/$uc/;\n    $string =~ tr/g/$uc/;\n    $string =~ tr/h/$uc/;\n\
    \    $string =~ tr/j/$uc/;\n    $string =~ tr/k/$uc/;\n    $string =~ tr/m/$uc/;\n\
    \    $string =~ tr/n/$uc/;\n    $string =~ tr/q/$uc/;\n    $string =~ tr/r/$uc/;\n\
    \    $string =~ tr/s/$uc/;\n    $string =~ tr/t/$uc/;\n    $string =~ tr/u/$uc/;\n\
    \    $string =~ tr/v/$uc/;\n    $string =~ tr/w/$uc/;\n    $string =~ tr/x/$uc/;\n\
    \    $string =~ tr/y/$uc/;\n    $string =~ tr/z/$uc/;\n    return $string;\n}",
  "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n    return $string;\n\
    }", "    $string =~ tr/a-zA-Z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n    return $string;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/A-Za-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/a-zA-Z/A-Za-z/;\n    $string =~ tr/A-Z/a-z/;\n    return\
    \ $string;\n}\n</code>\n<|/ a |>\n<| c |>\nWhy not simply `$string =~ tr/a-zA-Z/A-Za-z/;\
    \ $string =~ tr/A-Z/a-z/;`?\n<|/ c |>\n<| c |>\n, yes, that's better.\n<|/ c |>\n\
    <| c |>\nNice, thank you. I like the \"@\" for my version since I may want to\
    \ swap things out and leave things untouched. Also, I've learned from your examples\
    \ that I can use tr/a-z/A-Za-z/ to flip it backwards. Very nice.\n<|/ c |>\n<|\
    \ c |>\n, I added some comments about the differences between the two approaches.\n\
    <|/ c |>\n<| a dscore=3 |>\nYou could also use the /c modifier. According to the\
    \ manpage (perldoc perlop):\n<code>\ns/\\Q...\\E/$repl/c;\n</code>", "    my $result\
    \ = '';\n    $string =~ tr/[a-z]/[A-Z]/;\n    $string =~ tr/[A-Z]/[a-z]/;\n  \
    \  $result .= $string;\n    return $result;\n}", "    return $string unless $string\
    \ =~ /[a-z]/;\n    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return\
    \ $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n  \
    \  return $string;\n}", "    my $len = length($string);\n    if ($len == 0) {\n\
    \        return $string;\n    }\n    my $flipped_string = \"\";\n    for (my $i\
    \ = 0; $i < $len; $i++) {\n        my $c = substr($string, $i, 1);\n        my\
    \ $l_c = $c;\n        if ($l_c eq lc) {\n            $l_c = uc;\n        } elsif\
    \ ($l_c eq uc) {\n            $l_c = lc;\n        }\n        $flipped_string .=\
    \ $l_c;\n    }\n    return $flipped_string;\n}", "    my $flipped = '';\n    my\
    \ $last_ch = '';\n    $string =~ s/(.)/\n        if ($last_ch eq '')\n       \
    \ {\n            $flipped .= $1;\n            $last_ch = $1;\n        }\n    \
    \    else\n        {\n            my $char = $1;\n            $flipped .= lc($char);\n\
    \            $last_ch = $char;\n        }", "    $string =~ tr/A-Z/a-z/;\n   \
    \ $string =~ tr/a-z/A-Z/;\n    return $string;\n}\n</code>\nIn English: \"capitalize\
    \ each letter, lowercase each other, and uppercase each other\".  \nYou also don't\
    \ need to use the ternary operator when assigning to the same variable.\n<code>",
  "    map {\n        lc $_;\n        uc $_;\n    } split //, $string;\n}", "    $string\
    \ =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "   \
    \ $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }\n</code>\n<|/ a tags=lowercase,perl,uppercase dscore=5 |>\n<| c |>\nFor my needs,\
    \ this was the simplest, most straightforward solution. I just wrapped it in a\
    \ `sub` in an `if` statement: `if ( $string =~ /^[a-z]/i ) { $string =~ tr/a-z/A-Z/;\
    \ $string =~ tr/A-Z/a-z/; }`\n<|/ c |>\n<| a tags=lowercase,perl,uppercase |>\n\
    <code>\n$string =~ s/\\L\\K[a-z]/[A-z]/gi;\n</code>\n<|/ a dscore=4 |>\n<| c |>\n\
    Nice. `L` makes `\\K` behave like `(?<=.)` in lookbehind regexp, so it won't affect\
    \ other matches.\n<|/ c |>\n<| c |>\nThanks for this simple solution. I was trying\
    \ to use something like this to uppercase the word \"hello\" by adding an 'H'\
    \ at the end of the word, i.e. 'Hello' -> 'HelloH' and this was the simplest solution.\n\
    <|/ c |>\n<| a tags=lowercase,perl,uppercase |>\nHere's my solution:\n<code>\n\
    $string =~ s/([a-z])/uc($1)/ge;\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis is\
    \ what I was looking for, thanks.\n<|/ c |>\n<| a tags=lowercase,perl,uppercase\
    \ |>\n<code>\n$string =~ s/\\L([a-z])/uc($1)/ge;\n</code>\nThis replaces all lowercase\
    \ letters with their uppercase counterparts, but keeps the original case. This\
    \ way you don't have to change anything if the original case isn't kept.\n<|/\
    \ a dscore=3 |>\n<| c |>\nI wanted to change all lowercase letters to uppercase,\
    \ so I went with this: `$string =~ s/\\L([a-z])/uc($1)/ge;`\n<|/ c |>\n<| c |>\n\
    This fails if `$string` contains unicode characters such as `\xC0` or `\xC8`.\n\
    <|/ c |>\n<| a tags=lowercase,perl,uppercase |>\n<code>\n$string =~ s/\\L\\K[A-Z]/[a-z]/gi;\n\
    </code>\n<|/ a dscore=3 |>\n<| c |>\nThis is not ", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    return lc($string)\
    \ unless $string =~ /[a-z]/i;\n    return uc($string);\n}", "    $string =~ tr/[a-z]/[A-Z]/;\n\
    \    $string =~ tr/[A-Z]/[a-z]/;\n    return $string;\n}", "    $string =~ tr/A-Z/a-z/;\n\
    \    $string =~ tr/a-z/A-Z/;\n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "    return lc $string\
    \ if $string =~ m{^[a-z]+$};\n    $string =~ tr/a-zA-Z/A-Z/;\n    return lc $string;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    return lc($string) unless $string =~ /[^A-Z]/;\n    $string =~ tr/a-zA-Z/A-Za-z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=perl,regex |>\nA simple one-liner to capitalize each word in the\
    \ string.\n<code>\nperl -F'(\\w+)' -alne 'print lc($F[0]),\" \",$F[1]' < test.txt\n\
    </code>\nIt converts all the letters in every word to lower case using -a option\
    \ and splits the string using -F'(\\w+)' option. Now, $F[0] contains the original\
    \ word and $F[1] contains the converted word.\nIf you want to save the original\
    \ string, then do this:\n<code>\nperl -F'(\\w+)' -alne '$F[0]=\"lc($F[0])\"; print\
    \ lc($F[0]),\" \",$F[1]' < test.txt\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\n<code>\nuse strict;\nuse warnings;\nuse 5.010;\nuse utf8;", "    my $result\
    \ = \"\";\n    my $char_array = \"abcdefghijklmnopqrstuvwxyz\";\n    foreach my\
    \ $char (split //, $string) {\n        $result .= (length($char) > 1) ? $char_array[$char_array->index($char)]\
    \ : ucfirst($char);\n    }\n    return $result;\n}", "    \n    $string =~ tr/A-Z/a-z/;\n\
    \    $string =~ tr/a-z/A-Z/;\n    \n    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return $string;\n}\n</code>\nAnd finally, a\
    \ couple regexes and more code to do the same with regexes:\n<code>", "    $string\
    \ =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n    return $string;\n}", "   \
    \ my $lower = lc($string);\n    my $upper = uc($lower);\n    $string =~ tr/[a-z]/[A-Z]/;\n\
    \    $string =~ tr/[A-Z]/[a-z]/;\n    $string .= $lower if $string ne $upper &&\
    \ $string ne $lower;\n    return $string;\n}", "    my @chars = split(//, $string);\n\
    \    my $i = 0;\n    foreach my $char (@chars) {\n        if ($char eq 'l') {\n\
    \            $chars[$i] = uc($chars[$i]);\n        }\n        else {\n       \
    \     $chars[$i] = lc($char);\n        }\n        $i++;\n    }\n    return join('',\
    \ $chars);\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n  \
    \  return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}\n</code>\n<|/ a |>\n<| c |>\nThe last line of your code\
    \ does nothing useful. `tr/A-Z/a-z/` means replace every capital letter with its\
    \ lowercase counterpart. Since `A-Z` is the default behaviour of `tr`, you don't\
    \ need the `tr` at all. In other words, you just need `tr/a-z/A-Z/`\n<|/ c |>\n\
    <| c |>\nYou just need `tr/a-z/A-Z/`.\n<|/ c |>\n<| a dscore=0 tags=case,perl\
    \ |>\n<code>\nuse strict;\nuse warnings;\nuse v5.10.1;", "    # See if we can\
    \ do it in one pass.\n    if ($string =~ /[[:lower:]]/) {\n        my @strings\
    \ = split //, $string;\n        for (@strings) {\n            s/([[:lower:]])/\\\
    u$1/;\n        }\n        $string = join \"\", @strings;\n    }", "    $string\
    \ =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n}", "   \
    \ $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n}",
  "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    my $new = \"\";\n    for (split('', $string)) {\n        my $flip = $_\
    \ =~ tr/a-zA-Z0-9//cd;\n        $new .= ($flip ? lc($_) : uc($_));\n    }\n  \
    \  return $new;\n}\n</code>\n<|/ a |>\n<| c |>\nThis is not an optimized way of\
    \ doing it, because each substitution takes at least O(n) time since `tr/a/bc`\
    \ is O(n) where n is the length of the string and thus `n` substitutions take\
    \ O(n^2) time. A simple loop and two arrays with pointers would be O(n) time.\n\
    <|/ c |>\n<| c |>\n`tr` does not take O(n^2) time. The time complexity of substitution\
    \ is O(n), as it is essentially an O(1) operation. Using `tr` would involve having\
    \ to repeatedly replace each character with another character, which is O(n^2).\
    \ Using a `while` loop and `substr` does not involve repeatedly replacing each\
    \ character with another character. Since strings are immutable in Perl, a new\
    \ string is created on each iteration with a new buffer created for the new string.\
    \ No additional memory is wasted since each character is copied over to the new\
    \ string anyway.\n<|/ c |>\n<| c |>\nI thought you were trying to say that `tr`\
    \ runs in O(n^2) time. This is not the case. `tr` has O(n) time complexity because\
    \ substitution takes O(n) time, which is independent of the length of the string\
    \ being substituted. The time complexity of substitution is O(n), not O(n^2),\
    \ and since `n` is the length of the string being substituted, that is O(n) time\
    \ complexity.\n<|/ c |>\n<| c |>\n`tr` runs in O(n), since it requires two steps\
    \ of O(n) per character. `substr` is also O(n), but since `substr` is done in\
    \ O(n) time, that is also O(n) time complexity. This is O(n), which is what the\
    \ OP is looking for. The complexity of the operation is O(n) because `tr` requires\
    \ O(n) time per substitution because each character requires O(n) time for both\
    \ `tr` and `substr`. Using `tr` would take O(n^2) time because `tr` requires O(n)\
    \ time per substitution.\n<|/ c |>\n<| c |>\n`tr` requires an O(n) time per substitution.\
    \ That is O(n) times O(n) = O(n^2). Using `tr` takes O(n^2) time because ", " \
    \   $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/a-zA-Z//cd;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n    return $string;\n\
    }", "    return lc $string if $case_insensitive;\n    return uc $string if $case_insensitive;\n\
    \    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    return $string;\n}", "    local $_ = lc $_;\n    $_ = uc $_;\n}", "    my($lowercase_first)\
    \ = 0;\n    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string;\n\
    }", "    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n    return $string;\n\
    }"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
