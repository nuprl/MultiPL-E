name: HumanEval_49_modp
language: pl
prompt: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n# >>>\
  \ modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n# >>> modp(100,\
  \ 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n \
  \       if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n  \
  \      exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
  \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
  \ if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n       \
  \ exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n      \
  \  print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
  \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
  \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my $m = $p;\n    my $c = 1;\n    my $e = 1;\n    while ($n > 0)\
    \ {\n\t$m = $m;\n\t$c = ($n * $e) % $p;\n\t$e = ($n * $c) % $p;\n\t$n--;\n   \
    \ }\n    return $c;\n}", "    return $n if $n <= 0;\n    return 1 if $n == 0;\n\
    \    return $p - $modp_lut[$n % $p] if $n % $p;\n    $n--;\n    return $modp_lut[$n\
    \ % $p] + modp($n, $p);\n}", "    return $n & ((1<<$p)-1);\n}", "    my $r = 1;\n\
    \    $r *= $n;\n    $r %= $p;\n    my $s = 1;\n    while ($r == 0) { $s *= $n;\
    \ $s %= $p; $r *= $n; $r %= $p; }\n    return $s;\n}", "    $n = $n & 0x7fffffff;\n\
    \    $p = '' unless defined $p;\n    if ($n < 0) {\n        $n = 0xffffffff+($n+1);\n\
    \    }\n    if ($n <= 0xffff) {\n        return $n & $p;\n    }\n    return $n\
    \ >> 16 & $p;\n}", '    my($s, $m);', "    my $mask = (1 << ($n - 1));\n    return\
    \ $p & $mask;\n}", '    my($s, $i, $u, $d);', "    my($n) = ($n != 0) ? ($n &\
    \ 0x7FFFFFFF) : 0;\n    my($p) = ($p != 0) ? ($p & 0x7FFFFFFF) : 0;\n    my $r\
    \ = $n % $p;\n    if ($r != 0) { $r = ($p - $r); }\n    return $r;\n}", "    $n\
    \ = abs($n);\n    $n += ($p >> 1); $p = $p & $p;\n    if($n < $p) {\n        my\
    \ $res = $n & $p;\n        $n = $p & (~$n >> 1);\n        return $res;\n    }\
    \ else {\n        return $p;\n    }\n}", '    my($n, $d, $u);', "    if ($n <\
    \ 0) {\n\t$n = (-$n) unless $n < 0;\n\t$n = abs($n);\n\t$p = -$p if $p < 0;\n\t\
    $n = 2 ** $n - 1;\n\t$p = 2 ** $p - 1;\n    } else {\n\t$n = 2 ** $n;\n\t$p =\
    \ 2 ** $p;\n    }\n    my $ret = $n % $p;\n    return $ret if $ret;\n    return\
    \ 0;\n}", "    my $k = log($n, $p);\n    my $r = $k;\n    while ($k >= $p) {\n\
    \        $k /= $p;\n        $r++;\n    }\n    $r == 0 ? (1) : ($r + 1);\n}", " \
    \   $n %= $p;\n    if ($n < $p) {\n\t$n += $p - 1;\n    }\n    $n;\n}", "    my\
    \ $mod;\n    $mod |= $n >> 31 if ($n >> 31);\n    $mod |= $n >> 30 if ($n >> 30);\n\
    \    $mod |= $n >> 29 if ($n >> 29);\n    $mod |= $n >> 28 if ($n >> 28);\n  \
    \  $mod |= $n >> 27 if ($n >> 27);\n    $mod |= $n >> 26 if ($n >> 26);\n    $mod\
    \ |= $n >> 25 if ($n >> 25);\n    $mod |= $n >> 24 if ($n >> 24);\n    $mod |=\
    \ $n >> 23 if ($n >> 23);\n    $mod |= $n >> 22 if ($n >> 22);\n    $mod |= $n\
    \ >> 21 if ($n >> 21);\n    $mod |= $n >> 20 if ($n >> 20);\n    $mod |= $n >>\
    \ 19 if ($n >> 19);\n    $mod |= $n >> 18 if ($n >> 18);\n    $mod |= $n >> 17\
    \ if ($n >> 17);\n    $mod |= $n >> 16 if ($n >> 16);\n    $mod |= $n >> 15 if\
    \ ($n >> 15);\n    $mod |= $n >> 14 if ($n >> 14);\n    $mod |= $n >> 13 if ($n\
    \ >> 13);\n    $mod |= $n >> 12 if ($n >> 12);\n    $mod |= $n >> 11 if ($n >>\
    \ 11);\n    $mod |= $n >> 10 if ($n >> 10);\n    $mod |= $n >> 9 if ($n >> 9);\n\
    \    $mod |= $n >> 8 if ($n >> 8);\n    $mod |= $n >> 7 if ($n >> 7);\n    $mod\
    \ |= $n >> 6 if ($n >> 6);\n    $mod |= $n >> 5 if ($n >> 5);\n    $mod |= $n\
    \ >> 4 if ($n >> 4);\n    $mod |= $n >> 3 if ($n >> 3);\n    $mod |= $n >> 2 if\
    \ ($n >> 2);\n    $mod |= $n >> 1 if ($n >> 1);\n    return $p;\n}", '    my($r)
    = 0;', '    my($n) = ($n) unless defined $n;', "    my($k, $q);\n    if ($n <\
    \ 0) {\n        $n = -$n;\n        $p = -$p;\n    }\n    $n = abs($n);\n    $p\
    \ = abs($p);\n    # Avoid numeric overflow.\n    if ($p < $n) {\n        $k =\
    \ intdiv($p, $n);\n        $p = $p - $k * $n;\n    } else {\n        $q = intdiv($n,\
    \ $p);\n        $n = $n - $q * $p;\n        $k = 0;\n    }\n    return $k + $p;\n\
    }", "    my($sign, $base, $exp) = @_;\n    my $zero = Math::BigInt->new('0');\n\
    \    $sign = 1 if $n < 0;", "    my $mod2 = $n % $p;\n    return $mod2 == $n ?\
    \ $p : $mod2;\n}", "    my($s, $m, $u, $v);\n    my($m, $u, $v, $rz, $w);", " \
    \   my $k = 256;\n    my $v = ($n / $k) % $p;\n    return $v > $p ? ($k * $v +\
    \ $n % $p) : $v;\n}", "    $n = 2**$n if $n >= 0;\n    $p = 1<<$p if $p >= 0;",
  "    my $x = $n >> 1;\n    my $n1 = $x << 1;\n    my $n2 = $n1 - $p;\n    $n2 =\
    \ $n2 & $p;\n    return $n2;\n}", "    my $s = 1;\n    while ($n != 0) {\n   \
    \     $s = ($n * $p + $s) % $p;\n        $n >>= 1;\n    }\n    return $s;\n}",
  "    $n = ($n & $p) | (($n ^ $p) & ~($p & $n));\n    $n ^= $p >> 31;\n    $n &=\
    \ $p + 1;\n    return $n;\n}", "    return $n & (-$p) | $p if $n < 0;\n    return\
    \ $n & $p;\n}", "    $p += 0;\n    # this does not work, will it ever?\n    my\
    \ $mod = ($n % $p);\n    if ($mod >= $p) {\n        $mod -= $p;\n    }\n    else\
    \ {\n        $mod += $p;\n    }\n    return $mod;\n}\n</code>\n<|/ a tags=modulus,math,perl\
    \ |>\n<| c |>\n: Yeah, I know.  The question was about Perl, so I used that tag.\n\
    <|/ c |>\n<| c |>\nWhat if `p` is 0?\n<|/ c |>\n<| c |>\n: That's why I said \"\
    be aware of numerics\" :-)\n<|/ c |>\n<| c |>\n`($n % $p) % $p` is equivalent\
    \ to `($n % $p) % ($p + $p - 1)`, which should be the same modulo `$p`.\n<|/ c\
    \ |>\n<| c |>\n: Yeah, I know.  I didn't read too carefully :-)  Anyway, that's\
    \ a good catch.  I have changed my answer accordingly.\n<|/ c |>\n<| a tags=modulus,math,perl\
    \ |>\nHere's another way to do this without modulus:\n<code>\nuse strict;\nuse\
    \ warnings;", "    my $m = $p;\n    my $mod;\n    $mod ||= 1;\n    while (1) {\n\
    \        if ($n == 0) {\n            $n++;\n            last;\n        }\n   \
    \     my $d = $m & $n;\n        $m ^= $n; $n ^= $d;\n        $mod *= $p;\n   \
    \     $n += $mod;\n    }\n    return $mod;\n}", '    $p += 2;', "    my $result\
    \ = 1;\n    my $mask = (1 << $p);\n    my $i;\n    my $j;\n    my $k;\n    for\
    \ ($i = $n, $j = 0; $i > $p; $i >>= 1, $j += 1) {\n        $result ^= $i & $mask\
    \ if $j;\n    }\n    return $result;\n}", "    my($m, $k) = $p < $m ? $p : $m;\n\
    \    for (; $k > 0; --$k) {\n        my($r1) = $n % ($p >> 1);\n        my($r2)\
    \ = ($n >> 1) % ($p >> 1);\n        $n = $r1 + $r2;\n    }\n    $n;\n}", "   \
    \ my $x = $n * 2 ** $p - $p;\n    return $x % $p;\n}", "    my $c = $n & $p;\n\
    \    return $c > $p ? $n - $c : $n + $c;\n}", "    return $p if $n == 0;\n   \
    \ return 1 unless $n;", "    $n *= 2**$p;\n    return $n if $n < 1;\n    my($q)\
    \ = $n % $p;\n    return $q if $q == 0;\n    return $q + modp($n+1, $p);\n}",
  '    return 1 if ($n <= 0);', "    if ($n < 0) {\n        $n = $n * -1;\n      \
    \  $p = $p * -1;\n    }\n    my $x = Math::BigInt->new(2**$n);\n    $x = $x->bmod($p);\n\
    \    return $x->as_int;\n}", "    return $n ^ (1 << ($n & 0x1f)) % $p;\n}", " \
    \   $n %= $p;\n    $n += $p if $n < 0;\n    $n;\n}", "    my $r = $n % $p;\n \
    \   if($r < 0) { $r = $p + $r; }\n    return $r;\n}", "    return $n % ($p - 1);\n\
    }", "    return 1 if ($n == 0); # return 0 if $n is 0\n    my($n) = $n;\n    my($p)\
    \ = $p;\n    # $n may be an int, or a long.\n    # $p may be an int, or a long.\n\
    \    if ($n < 0) {\n        # Negative $n is equivalent to the absolute value\
    \ of $n\n        my $abs = abs($n);\n        my $sign = $n < 0 ? 1 : -1;\n   \
    \     $n = $abs;\n        $n *= $sign;\n    }\n    if ($p < 0) {\n        # Negative\
    \ $p is equivalent to the absolute value of $p\n        my $abs = abs($p);\n \
    \       my $sign = $p < 0 ? 1 : -1;\n        $p = $abs;\n        $p *= $sign;\n\
    \    }\n    # $p must be non-negative and $n must be non-negative\n    return\
    \ ($n < $p) ? 0 : ($n > $p) ? 1 : ($n & $p);\n}", "    my $q = $n % $p;\n    return\
    \ $q > $p ? ($q - $p) : $q;\n}", "    my($z, $r) = &_modp($n, $p, 2);\n    if\
    \ (defined $z and $z == $n) {\n        $z;\n    }\n    else {\n        $r;\n \
    \   }\n}", "    my $n = int($n);\n    my $p = int($p);\n    if ($n < 0) {\n\t\
    my $rm = $n;\n\tsubstr($rm, 0, 1) .= substr($rm, -1, 1);\n\t$n -= $rm;\n    }\n\
    \    my $result = 0;\n    my $d = $p - 1;\n    while ($d != 0) {\n\t$result +=\
    \ (2**$d) % $p;\n\t$d = $d >> 1;\n    }\n    return $result % $p;\n}", "    my($mod);\n\
    \    my($res);", "    return $n if $n == 0;\n    return $n if $p == 0;\n    my\
    \ $m = $n >> 32;\n    return $p if $n < 0;\n    $m = ~$m  if $m == 0;\n    return\
    \ $m if $p < 0;\n    $p = ~$p  if $p == 0;\n    return ($n % $p, $n / $p);\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| a |>\nHere's a version that allows any base (10\
    \ or 16), not just powers of 2.  I used an implementation by Mark Byers.  It's\
    \ a bit slower than the answers posted, but it's still much faster than the standard\
    \ modulus.  It also works in 32 bit architectures.\n<code>", "    my ($mod, $rem)\
    \ = ($p, '1') if $p < 1;\n    my $x = $n % $p;\n    $x++ if $x >= $mod;\n    return\
    \ $x if $rem < $x;\n    $x -= $mod if $mod > 1;\n    return $x;\n}", "    my $t\
    \ = $n * $p % $p; # Modular exponentiation\n    return $t if $t < $p && $t !=\
    \ 0; # Return n if n == 0.\n    return $n;\n}", "    return $n if $n <= 0;\n \
    \   $n = ($n % $p) + $p;\n    return $n if $n < 0;\n    $n -= $p;\n    return\
    \ $n if $n == 0;\n    return $p;\n}", "    my($q, $d);\n    # Special cases: p\
    \ is 1 and $q is 1.\n    return ($n <= 1 ? 1 : $n % $p == 0 ? $n : $n);\n}", " \
    \   return 1 if ($n & $p);\n    return $n if ($n & ~$p);\n    return $n % $p;\n\
    }", "    return 0 if $n == 0;\n    return 1 if $n == 1;\n    if ($n < 0) {\n \
    \       $n = -$n;\n        $p = -$p;\n    }\n    if ($n == 1 && $p == 1) {\n \
    \       return 2;\n    }\n    my $res = $n % $p;\n    return 0 if $res == 0;\n\
    \    return $p;\n}", "    return 1 unless $n && $p;\n    return 0 unless $n;\n\
    \    return 0 unless $p;\n    return 0 unless $n >= $p;\n    return $n & ($p-1);\n\
    }", "    if ($n < 0) {\n        $n = -$n;\n        $p = -$p;\n    }\n    return\
    \ Math::BigInt->new($p->bpow($n));\n}", "    my($s, $q, $r);\n    $r = $p % $n;\n\
    \    $s = $n >> 1;\n    while ($r > 0) {\n        $s = $s + $q;\n        $q =\
    \ $q + 1;\n        $r = $r >> 1;\n    }\n    return $s;\n}", "    if ($n < 0)\
    \ {\n        $n = -$n;\n        $p = $p * -1;\n    }\n    elsif ($n == 0) {\n\
    \        return $p;\n    }\n    $n %= $p;\n    if ($n < 0) {\n        $n = $p\
    \ + $n;\n    }\n    return $n;\n}", "    if ($n < 0) {\n\tmy $r = $p % abs($n);\n\
    \treturn $p if $n == 0;\n\t$n = -$n;\n\t$r = -$r;\n    }\n    # $n == 0 -> 1\n\
    \    if ($n == 0) {\n\treturn 1;\n    }\n    # $n < 0 -> modp($n, $p) - 1\n  \
    \  return $p if $n < 0;", "    my($mod) = $p;\n    my $r = $n % $mod;\n    # $n\
    \ / $mod == $r if $r divides evenly into $n.\n    $r = $r / $mod if $r % 2 ==\
    \ 0;\n    return $r;\n}", "    $p > $n ||\n\tCarp::confess(\"Invalid modulus $n\
    \ (must be positive integer)\");", "    my($q, $r);\n    my($d, $s);\n    my($t);\n\
    \    my(@m);", "    return $n if $n <= 0;\n    return $p if $n >= $p;\n    my\
    \ $r = 1;\n    my $i;\n    $n -= 1;\n    while($n >= $p) {\n        $r = $r *\
    \ $i;\n        $n = $n / $p;\n        $i++;\n    }\n    $r *= $i;\n    return\
    \ $r;\n}", "    my ($ans, $mod);\n    my @mods = (1 .. $p);\n    my $mod = $mods[$n\
    \ & $mods[-1]];\n    while ($n >= $mod) {\n        $n = ($n%$mod) * $mods[-1];\n\
    \        $mod = $mods[$n & $mods[-1]];\n    }\n    if ($n == $mod) {\n       \
    \ $ans = 1;\n    } else {\n        $ans = 0;\n    }\n    return $ans;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nI appreciate this but I have to use it for an assignment\
    \ and I must use the modulus. And thank you for taking the time to explain it.\n\
    <|/ c |>\n<| a |>\n<code>", '    return 0 if $p == 0;', "    my $r = 1;\n    while\
    \ ($n) {\n\t$r <<= 1;\n\tmy $t = $n % $p;\n\t$r |= $t != 0;\n\t$n -= $t;\n   \
    \ }\n    return $r;\n}", "    my $remainder;\n    if ($n >= $p) {\n        return\
    \ $p;\n    }\n    my $q = modp($n, $p);\n    $remainder = $n % $p;\n    return\
    \ $q + (($remainder != 0) ? $p : $q-1);\n}", "    my $r = Math::BigInt->new($n);\n\
    \    $r->bmod($p);\n    $r;\n}", "    if ($n == 0) {\n        return $p;\n   \
    \ }\n    if ($n == 1) {\n        return $p;\n    }\n    # Modular reduction is\
    \ easy.\n    return $n - ($n & ($n - 1));\n}", "    $n = $n & ($p-1);\n    $n\
    \ += $p if $n > $p;\n    return $n;\n}", "    return $n if $n <= 0;\n    return\
    \ $n if $n == 1;\n    return $n if $n == $p;\n    return $p - $n - 1;\n}", " \
    \   if ($n != 0) {\n        $p *= $n >> 9;\n        $p %= $p;\n        if ($n\
    \ & 1) {\n            $p *= $p; // 2\n            $p %= $p;\n        }\n    }\n\
    \    $p;\n}", "    my($mod) = $p % $n;\n    return $mod == 0 ?  $n : $mod;\n}",
  "    my $e = ($n >> 1) - 1;\n    my $d = $n->{sign} ? $n->{_n} : 1;\n    my $g =\
    \ $d->{_[0]}->{sign} ? $d->{_[0]}->{_n} : 1;\n    $g = ($g + ($e << 1)) %  $p;\n\
    \    $g = $g + ($e << 2) if ($e < 0x3ff);\n    $g = ($g + $e) %  $p;\n    return\
    \ $g;\n}", "    return 1 if $n == 0;\n    if ($n == 1) {\n        return $p;\n\
    \    }\n    my($m) = modinverse($n);\n    if ($m < $p) {\n        # $m*$m = ($n-1)/($n-1)\n\
    \        # $n - ($n-1)/2 = $m*$m + $m\n        # $m = $m*$m + $n - $m*$m\n   \
    \     $m = $m*$m + $n - $m*$m;\n    } else {\n        # $m*$m = ($n+1)/($n+1)\n\
    \        # $n + ($n+1)/2 = $m*$m - $m\n        # $m = $m*$m - $m\n        $m =\
    \ $m*$m - $m;\n    }\n    return $m;\n}", "    my $n = int($n);\n    my $p = int($p);\n\
    \    my $max_bits = $p >> 3;\n    my $bits = $p & 7;\n    my $mask = 1 << $bits;",
  "    my $mask = (($n & $p) == $n) ? 1 : 0;\n    return (($n ^ $p) & ~$mask) >> ($p\
    \ & 63);\n}", "    my $x = $n; $n %= $p;\n    if ($x == 0) { $x = 1; $p -= 1;\
    \ }\n    return $x;\n}", "    # Find a divisor of n that is a multiple of p. This\
    \ may be the\n    # closest number to n that is a multiple of p.\n    #\n    #\
    \ First find m such that m is no more than floor(n/p).\n    # Then find d such\
    \ that d*p+n is no more than n.\n    #\n    # n is no more than p*m+d and the\
    \ nearest such divisor is d*p+n.\n    #\n    # Let n be m+d+1 and d be the smallest\
    \ d such that d*p+n is\n    # no more than n.\n    #\n    # Let m be the smallest\
    \ m such that m*p+d is no more than\n    # n.\n    #\n    # Let m be the smallest\
    \ m such that n*p+d is no more than\n    # n.\n    #\n    # Then the nearest multiple\
    \ of p that is no greater than m+d+1 is\n    # p+d+1.\n    #\n    # And finally,\
    \ since p+d+1 is a multiple of p, it must be the last\n    # such multiple of\
    \ p.\n    #\n    # Thus, we can find p by repeatedly adding 1 to p and checking\
    \ whether\n    # it changes the result. We don't need to test whether it changes\
    \ the\n    # result every time we add 1 to a given number because the last\n \
    \   # multiple that satisfies that condition will work when added to p.\n    #\n\
    \    # However, we have to keep doing this until\n    # we've added n to p exactly\
    \ once or we've tried too many times.\n    # That's because the final result may\
    \ be p itself or a multiple of p.\n    # In the first case, it doesn't matter\
    \ that m == d because if p==m\n    # then p+d+1 will also be divisible by p. In\
    \ the second case, adding 1\n    # would cause p to be a multiple of p, and in\
    \ the third case it would\n    # cause m to be a multiple of p also. Since p can\
    \ be any divisor, we\n    # need to check whether m is a multiple of p too. We\
    \ can check if m\n    # is a multiple of p by repeatedly adding 1 to m and checking\
    \ whether it\n    # changes the result.\n    #\n    # There's a problem if m is\
    \ just 1 or 0. But since 0 cannot be\n    # expressed as a multiple of 1, we can\
    \ safely assume that m is not\n    # just 1 or 0. We can also safely assume that\
    \ m is not a multiple of\n    # p unless we check whether m is a multiple by repeatedly\
    \ adding 1\n    # to m and checking whether it changes the result.\n    #\n  \
    \  # From that, we can conclude that m can only be a multiple of\n    # p if:\n\
    \    #\n    # 1. p is not a multiple of m. In this case, we have to check whe",
  "    my $nmod = $n % $p;\n    if ($nmod != 0) {\n\t$nmod -= $p;\n\t$nmod += $p;\n\
    \    }\n    return $nmod;\n}", "    my $modulus = $p % $n;\n    $modulus == $n\
    \ or return $modulus;", "    return 0 if $n == 0;\n    return $p if $n <= $p;\n\
    \    return $n % $p;\n}", "    return $n if $p > $n;\n    return $p if $n <= 0;\n\
    \    return $p if $n < 0;\n    return $n if $n % $p;\n    return $p if $p % $n;\n\
    \    return $n % $p;\n}", "    my $tmp = $n;\n    my $mod = $p % $tmp;\n    if(!defined\
    \ $mod && $tmp !~ /^0+$/) {\n        $mod = 1;\n    }\n    return $mod;\n}", " \
    \   return $n if $n == 0;\n    return $n if $p < $n;\n    my $a = $n;\n    my\
    \ $b = $p / $n;\n    my $c = $p % $n;\n    return $n % $p if $b <= $c;\n    return\
    \ $n % $p + ($c - $b + $n) % $p;\n}", "    if ($n < 0) {\n\t# Negative number\n\
    \tmy $k = abs($n);\n\t$n = ($k + (-1)) % ($k + 1);\n    } elsif ($n == 0) {\n\t\
    $n = 0;\n    } else {\n\t# Positive number\n\tmy $k = ($n + (-1)) % ($n + 1);\n\
    \tmy $n1 = $n - ($k + (-1));\n\t$n = ($n1 - $k + 1) % ($n + 1);\n    }\n    return\
    \ $n;\n}", "    $n %= $p;\n    $n == 0 or $n == 3 or $n == $p or $n % $p == 0\
    \ or $n != $p or $n >= $p;\n}", "    $p = $p % $n;\n    # return $p if $p == 0\n\
    \    return $n if $p == 0;\n    # return $n if $n == 1\n    return $n if $n ==\
    \ 1;\n    # return $n if $p < $n\n    return $p if $p < $n;\n    # return $n %\
    \ $p % $n if $p > $n\n    return $n % $p % $n;\n}", "    # Find n such that 2^n\
    \ % p == 1 and 2^n >= p.\n    # Note: this is quadratic so may take some time.\n\
    \    my $g;\n    for ($n = 1 until $n && ($g = $n * $n % $p) == 1 && $n >= $p\
    \ && $g >= $p;\n        $n++);\n    return $n if $g == $p;\n    # Return 2^n modulo\
    \ p.\n    return $g if $g >= $p;\n    return $g - $p + 2;\n}", '    my($ret);',
  "    my $c = 1;\n    my $m = 1;\n    $p += $p - 1;\n    for (; $c <= $p; $c++) {\n\
    \        my $r = Math::BigInt->new($n);\n        $r->bmod($m)->bmul($m) = $m;\n\
    \        $m *= $c;\n    }\n    return $m;\n}", "    # $n == 0 should give 1, but\
    \ we allow it to be 0.\n    # Perl chokes on $p == 0 anyway, so handle it specially.\n\
    \    return 1 unless $n;\n    $n %= $p;\n    if ($n < 0) {\n        my $r = $p\
    \ >> 1;\n        $r ^= $n;\n        return $r;\n    } else {\n        return $p;\n\
    \    }\n}", "    my %x = $n =~ /^(\\d+)$/;\n    my $m = $x{'1'} % $p;\n    my\
    \ @a;\n    for (my $i = 0; $i < $n; ++$i) {\n        my $x = $i << 1;\n      \
    \  $x++ while $x * $p < $m * $x;\n        push @a, $x;\n    }\n    return $x{'1'}\
    \ = $a[$#a];\n}", "    my ($x, $y) = @_;\n    $x -= $y; $x %= $p;\n    if ($x\
    \ < 0) { $x += $p; }\n    $x;\n}", "    my $u = ($p >> 1) & 0x7FFFFFFF;\n    my\
    \ $v = ($p >> 29) & 0x3FFFFFFF;\n    return $n * $u + ($n & $v) % ($p + 1);\n}",
  "    my($rc, $rs) = call_fp_func(\\&Math::BigInt::_modp);\n    my $n1 = $n;\n  \
    \  my $rn = $n >= 0 ? $n : $n->copy();\n    # $rs = $rs->copy() unless defined\
    \ $rs;  # not needed in BigInt\n    # $rs->_lt($rs->_abs() . $p);\n    my $rn\
    \ = $rn >= 0 ? $rn : $rn->copy();\n    my $rs_copy = $rs;\n    my $rs_neg = $rs_copy->copy();\n\
    \    my $rs_neg_abs = $rs_copy->_abs();\n    $rs_copy->_lt($rs_copy->_abs() -\
    \ $p);\n    if ($rs_copy->_sign() == 0) {\n        return $rs_copy;\n    }\n \
    \   $rs = $rs_copy;\n    # $rs->_div($p);\n    $rn = $rn->div($p);\n    # $rn\
    \ = Math::BigInt->_div($rn, $p);\n    $rs = $rs->div($p);\n    # $rs = Math::BigInt->_div($rs,\
    \ $p);\n    if ($rs->is_zero() || $rs->_eq($rs_copy)) {\n        return $rn;\n\
    \    }\n    my $rs = $rs->_copy();\n    my $rs_neg = $rs->_copy();\n    $rs_neg->_add($rs_neg_abs);\n\
    \    $rs = $rs->_mul($p);\n    $rn = $rn->_mul($p);\n    # $rs = Math::BigInt->_mul($rs,\
    \ $p);\n    # $rs = Math::BigInt->_mul($rn, $p);\n    $rs = $rs->_mul($p);\n \
    \   # $rs = Math::BigInt->_mul($rs, $p);\n    $rs = $rs->_div($p);\n    if ($rs->is_zero()\
    \ || $rs->_eq($rs_copy)) {\n        return $rn;\n    }\n    $rs = $rs->_copy();\n\
    \    my $rs_neg = $rs->_copy();\n    $rs_neg->_add($rs_neg_abs);\n    $rs = $rs->_mul($p);\n\
    \    $rn = $rn->_mul($p);\n    # $rs = Math::BigInt->_mul($rs, $p);\n    # $rs\
    \ = Math::BigInt->_mul($rn, $p);\n    $rs = $rs->_mul($p);\n    # ", "    if (\
    \ $n == 0 ) {\n        return 1;\n    }\n    elsif ( $n == 1 ) {\n        return\
    \ $p;\n    }\n    elsif ( $n >= $p ) {\n        return $p - 1;\n    }\n    else\
    \ {\n        my $a = $p - 1;\n        my $b = $n % $p;\n        my $r = $a / $p;\n\
    \        $r = $p if $r == 1;\n        $r = $p - $n if $r == $p - 1;\n        return\
    \ $r * modp($r, $p);\n    }\n}", '    my $n2 = $n >> 1;', "    my($z, $a);\n \
    \   if ($n < 0) {\n\t$n = -$n;\n\t$p = $p + 1 if $p > 0;\n    }\n    $n = $n *\
    \ $p;\n    while ($n > $p) {\n\t$z = (($z * $a) % $p + $p) % $p;\n    }\n    return\
    \ $z;\n}", "    my ($carry) = 0;\n    my $result = $n;", "    $p = 1 if $p < 0;\n\
    \    return $n % $p + ($n // $p) * $p;\n}", "    my $i = $n % $p;\n    return\
    \ $i if $i == 0;\n    return ($p - $i) + $i;\n}", "    # NOTE: Not sure about\
    \ $m and $p. For $n, $m is number of bits, and\n    # $p is modulus.\n    my $q\
    \ = int(($n * $p + 2**$p) / 2**$n);\n    if ($q > 2**$n)\n    {\n        my $a\
    \ = 2**$n;\n        my $b = 2**$q;\n        return $a < $b ? $a : $b;\n    }\n\
    \    else\n    {\n        return $q;\n    }\n}", "    return 0 if ($n <= 0);\n\
    \    $n -= $p % $n;\n    $n % $n ? $n : $n - 1;\n}", "    # Only accept numbers\
    \ between 0 and 2**n - 1\n    return $n if $n < 0 || $n >= 2**$p;\n    # Compute\
    \ n modulo p\n    # 2^n modulo p is equal to 2^(p+1) - 1\n    return 2**$p+1 if\
    \ $n & 1;\n    # Divide by 2 in 2's complement\n    return 1 if ($n % 2);\n  \
    \  return -1;\n}", "    my($r1, $r2, $r3);\n    my($q1, $q2);\n    my($q3, $q4,\
    \ $q5, $q6, $q7, $q8, $q9, $q10, $q11, $q12, $q13, $q14, $q15, $q16, $q17, $q18,\
    \ $q19, $q20, $q21, $q22, $q23, $q24, $q25, $q26, $q27, $q28, $q29, $q30, $q31,\
    \ $q32, $q33, $q34, $q35, $q36, $q37, $q38, $q39, $q40, $q41, $q42, $q43, $q44,\
    \ $q45, $q46, $q47, $q48, $q49, $q50, $q51, $q52, $q53, $q54, $q55, $q56, $q57,\
    \ $q58, $q59, $q60, $q61, $q62, $q63, $q64, $q65, $q66, $q67, $q68, $q69, $q70,\
    \ $q71, $q72, $q73, $q74, $q75, $q76, $q77, $q78, $q79, $q80, $q81, $q82, $q83,\
    \ $q84, $q85, $q86, $q87, $q88, $q89, $q90, $q91, $q92, $q93, $q94, $q95, $q96,\
    \ $q97, $q98, $q99, $q100) =\n        ($n, $p);\n    my($r1_1, $r1_2, $r1_3, $r1_4,\
    \ $r1_5, $r1_6, $r1_7, $r1_8, $r1_9, $r1_10, $r1_11, $r1_12, $r1_13, $r1_14, $r1_15,\
    \ $r1_16, $r1_17, $r1_18, $r1_19, $r1_20, $r1_21, $r1_22, $r1_23, $r1_24, $r1_25,\
    \ $r1_26, $r1_27, $r1_28, $r1_29, $r1_30, $r1_31, $r1_32, $r1_33, $r1_34, $r1_35,\
    \ $r1_36, $r1_37, $r1_38, $r1_39, $r1_40, $r1_", "    my($r, $q, $m) = Math::BigInt::_lsft($n,\
    \ $p, $p);\n    my($h);\n    if ($r eq $q && $r eq $m) {\n        $h = $n;\n \
    \   }\n    else {\n        $h = $m;\n        $h = $h->bmodp($p);\n    }\n    return\
    \ $h;\n}", "    $n = $n->copy();\n    $n->{sign} = 0;\n    $n->{_modulus} = $p;\n\
    \    $n;\n}", "    my $d = $n - $p;\n    return $d if $d == -$p;\n    return $d\
    \ if $n == 0 or $n % $p != 0;\n    return $n % $p;\n}", "    my($mod) = $p % $n;\n\
    \    return $mod if $mod < 0;\n    return $n if $mod > 0;\n    return $n;\n}",
  "    my $m = 1;\n    while (--$n) {\n\t$m ^= $p if $p % 4;\n\t$m %= $p  if $p %\
    \ 2;\n\t$p /= 2;\n    }\n    return $m;\n}", "    if ($n < 0) {\n        $n =\
    \ -$n;\n        $p = -$p;\n    }\n    my $result = $n;\n    my $carry = 0;\n \
    \   my $max_digits = $p - 1;\n    for (my $i = 1; $i < $max_digits; $i++) {\n\
    \        if ($n >= $p) { \n            $result += ( ($n % $p) * $carry + $n) /\
    \ $p; \n            $carry = $n % $p; \n            $n = int( $n / $p ); \n  \
    \      }\n    }\n    return $result + $carry if $carry;\n    return $result;\n\
    }", "    my($modulus) = $modulus * $p;\n    if ($modulus < 1) {\n        $modulus\
    \ = 0;\n    }\n    $modulus = 2 ** $modulus;\n    $modulus %= $p;\n    if ($modulus\
    \ == 0) {\n        $modulus = 1;\n    }\n    $modulus > $n and return $n;\n  \
    \  $modulus;\n}", "    my $sign = 1;\n    if ($p == $n) {\n\t$sign = 0;\n    }\
    \ elsif ($n < 0) {\n\t$sign = 0;\n\t$n = -$n;\n    }\n    if ($n != 0) {\n\treturn\
    \ $p ** $sign;\n    }\n    return 1;\n}", "    my($g, $s, $i) = (0, 10, 0);\n\
    \    while ($n >= $p) {\n        $g += $s / $i;\n        $s = $i % 10;\n     \
    \   $i *= 10;\n    }\n    return $g;\n}", "    return 1 unless $n;\n    $n %=\
    \ $p;\n    if ($n == 0) {\n\t$n = 1;\n    } else {\n\t$n = 2**($p - $n);\n   \
    \ }\n    return $n;\n}", "    my($a, $b, $m, $t);\n    $n = 0 unless defined $n;\n\
    \    $p = 0 unless defined $p;\n    $n = 2**$n if $n =~ /-inf/;\n    $m = 2**$p\
    \ if $p =~ /-inf/;", "    return 1 unless $n <= $p;\n    return $p if $n == 0;\n\
    \    return $p - $n*int(($p/$n)&~1);\n}", "    return 0 if $n == 0;\n    return\
    \ $n % $p if $n < $p;\n    return $p - $n % $p;\n}", '    my($base, $mod, $result)
    = (0, $n, 0);', "    return $n % $p;\n}", "    my $result = $n % $p;\n    if ($result\
    \ < 0) { $result += $p }\n    return $result;\n}", "    my $result = 1;\n    my\
    \ @bits = split(//, $n);\n    my $k = shift(@bits);\n    my $d = shift(@bits);\n\
    \    $result *= 2**$k;\n    for(my $i = 0; $i < $d; $i++) {\n        $result %=\
    \ $p;\n    }\n    return $result;\n}", "    my($r) = Math::BigInt->new(\"1\");\n\
    \    my($one);\n    my ($sign) = 0;\n    my $x = $r->{value} = 0;\n    my $neg\
    \ = 0;", "    my $ppow = ppow($p, $n);\n    return $n if $npwr == $ppow;\n   \
    \ return $ppow % $p;\n}", "    my $n_ = $n;\n    my $p_ = $p;\n    my $mod;\n\
    \    my $r;\n    my ($sign, $x); # sign is 1 for positive and -1 for negative\n\
    \    $sign ||= 1;\n    $x = $n_;\n    $mod = $p_ % $p_; # $x % p;\n    while (1)\
    \ {\n        $r = $x % $p_;\n        if ($r == 0) {\n            $x = $n_;\n \
    \       }\n        else {\n            $n_ = ($sign * $n_ + $p_ - $r) %$p_;\n\
    \            $sign *= -1;\n        }\n        if ($x == $n_) {\n            $mod\
    \ = $p_;\n            last;\n        }\n        $mod = $mod * $p_ + $p_;\n   \
    \ }\n    $sign *= -1; # return sign * r\n    if ($mod == 0) {\n        $mod +=\
    \ $p_;\n    }\n    return $mod;\n}", "    my $x = $n;\n    my $q = $p;\n    $x\
    \ %= $q;\n    if ($x == 0) {\n        return 1;\n    }\n    my $w = 1;\n    while\
    \ ($x) {\n        $w = ($w << 1) + ($x & 1);\n        $x >>= 1;\n    }\n    return\
    \ $w;\n}", "    return $n & ($p - 1); \n}", "    if ($n < 0) {\n        $n = (-$n)\
    \ + 1;\n        $p = $p % -$n;\n    }\n    return 0 unless $p;\n    $n = 2 **\
    \ $n;\n    my $r = $n % $p;\n    my $remainder = $n % $p;\n    $remainder -= 1;\n\
    \    return $r + (($r + 1) % $p) if $remainder > 0;\n    $r -= $p * (($r - 1)\
    \ / $p);\n    return $r + $p;\n}", '    return if $n <= 0;', "    my $i = $n;\n\
    \    $i = '0' unless $i =~ /[01]/;\n    my $mod = 0;\n    while (--$i >= 0) {\n\
    \        $mod = 1 if ($i % $p);\n        $mod *= 2;\n    }\n    return $mod;\n\
    }", "    return 1 if $n == 0;\n    if ($p == 0) {\n        return 1;\n    }\n\
    \    $p = ($p - 1) % $p;\n    return $n & ($p - 1) if $n > 0;\n    return $n &\
    \ ($p - 1);\n}", "    $n = 0 if $n < 0;\n    $p = 0 if $p < 0;\n    if ($n &&\
    \ $p) {\n        my $r = 1;\n        while ($n >= $p) {\n            $n--;\n \
    \           $r = 2**$n if $r;\n        }\n        return $r;\n    } else {\n \
    \       return 1 if ($n && !$p);\n    }\n}", "    my $nref = \\ $n;\n    my $pref\
    \ = \\ $p;\n    my @r = ();\n    my $i = 0;\n    my $j = 0;\n    my $k = 0;\n\
    \    my $tmp;", "    my $t = $n << 1;\n    $t %= $p;\n    return $t if $t == 0;\n\
    \    # $t < $p ? $t : modp($t - $p, $p);\n    return $t if $t < $p; # $t - $p\
    \ = $t % p\n    return $t - $p; # $t % p\n}", "    my($gcd);\n    my($rem);\n\
    \    my $i = $n % $p;\n    if ($i == 0) {\n\t$gcd = $p;\n    } elsif ($i != $p)\
    \ {\n\t$rem = $n % $p;\n\t$gcd = modp($gcd, $p);\n\t$gcd = ($gcd == 0? $p : $gcd);\n\
    \t$n = $rem / $gcd;\n    }\n    return $n * $p;\n}\n1", "    my $k = ($n < 0)\
    \ ? (-$n) : $n;\n    my $r = 1;\n    while (0 <= $k and $k < $p) {\n\t$r *= $k;\n\
    \t$k /= $p;\n    }\n    if ($n == 0) {\n\treturn 1;\n    }\n    else {\n\treturn\
    \ $r;\n    }\n}", "    if ($n < 0) {\n        $p--;\n        $n = -$n;\n    }\n\
    \    return ($p * $n) % $p;\n}", "    if ($n < $p) {\n\tmy $r = $n;\n\tmy $q =\
    \ $p / $r;\n\t$q++ while ($q > $n);\n\t$r -= $q;\n\treturn $r;\n    }\n    my\
    \ $r = $p % $n;\n    $r++ while ($r > $n);\n    return $r;\n}", "    return 1\
    \ if $n == 0;\n    my $result = 0;\n    while ($n != 0) {\n        $n = $n % $p;\n\
    \        $result = $p * $result + $p if $result != $p;\n    }\n    return $result;\n\
    }", "    my $m = $n % $p;\n    if ($m != 0) {\n\t$n -= $m;\n\t$m += $p - 1;\n\t\
    $n = ($n / $p) * $p;\n\t$m -= 1;\n    } else {\n\t$n = $n % $p;\n    }\n    $n;\n\
    }", "    my $n_is_odd = $n % 2;\n    $n = 0 if $n_is_odd && $n =~ /^1\\d$/;",
  "    my $i = $n >> 24;\n    $i = $i + ($n & 0x00ffffff) >> 24;\n    $i = $i + ($n\
    \ & 0x0000ffff) >> 16;\n    $i = $i + ($n & 0x000000ff) >> 8;\n    $i = $i + ($n\
    \ & 0x0000000f) >> 4;\n    $i = $i + ($n & 0x00000003) >> 2;\n    $i = $i + ($n\
    \ & 0x00000001);\n    return $p ^ $i;\n}", "    my $x = $n;\n    my $q = $p;\n\
    \    while (!($x & $q)) {\n\t$x -= $q;\n\t$q *= 2;\n    }\n    $x;\n}", "    my\
    \ $r = $n % $p;\n    if ($r == 0) {\n\treturn $p;\n    }\n    return $n;\n}",
  "    return $n if ($n =~ /^\\d+$/);\n    $n += 0;\n    my $x = $n;\n    while (1)\
    \ {\n        if ($x % $p != 0){\n            return $x;\n        }\n        $x\
    \ = $x/$p;\n    }\n}", "    my @a = map {$_ % $p} @_;\n    my $r = $a[0];\n  \
    \  my $i;\n    for ($i = 1; $i < @a; ++$i) {\n\tmy $k = $a[$i];\n\t$r += $k;\n\
    \t$r %= $p;\n    }\n    return $r;\n}", "    return 0 if ($p < 1);\n    $p = ($p\
    \ - 1) % $n;\n    return $n if ($n < 0);\n    return 1 if ($n == 0);\n    return\
    \ $p;\n}", "    if ($n < 0) {\n        my ($s, $e) = @{$_[1]};\n        $e = 0\
    \ if $e < 0;\n        $n = 0 - $n;\n        my $r = $s % $p;\n        $e++ if\
    \ $r <= $e;\n        $r = ($r - $e) % $p;\n        return $r + ($n < 0 ? $p :\
    \ 0);\n    } else {\n        my ($s, $e) = @{$_[0]};\n        $e = 0 if $e < 0;\n\
    \        $n = 0 - $n;\n        my $r = $s % $p;\n        $e++ if $r > $e;\n  \
    \      $r = ($r - $e) % $p;\n        return $r + ($n < 0 ? -$p : 0);\n    }\n}",
  "    my $q = $n % $p;\n    if ($q > 0) { $q - $p };\n}", "    my $n = $n | 0;\n\
    \    my $p = $p | 0;\n    my $m = 1;\n    my $a = $p >> 1; # $p must be odd!\n\
    \    while ($n == 0) {\n        $m = ($m << 1) | $a; # $m is 1<<n\n        $n\
    \ = ($n >> 1) & $p;\n        $a = $a >> 1;\n    }\n    return $m * $p;\n}", " \
    \   my $result;\n    $result = ($n % $p) == 0 ? $n : -1;\n    return $result;\n\
    }\n</code>\n<|/ a tags=math,c++,modular-arithmetic |>\n<| c |>\nThanks for your\
    \ answer, I really appreciate it!\n<|/ c |>\n<| a |>\nHere's a solution in Java,\
    \ based on a formula (which can be found here).\n<code>\npublic static int modPow(final\
    \ int base, final int exponent) {\n    if (exponent == 0)\n        return 1;\n\
    \    if (exponent < 0)\n        return 0;\n    int result = 1;\n    while (exponent\
    \ > 0) {\n        if (exponent % 2 == 1) {\n            result *= base;\n    \
    \    }\n        result %= base;\n        exponent /= 2;\n        base *= base;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=math,c++,modular-arithmetic\
    \ dscore=3 |>\n<| c |>\nYou forgot to check for negative exponents.\n<|/ c |>\n\
    <| a dscore=2 |>\nThe most efficient way is probably to use exponentiation by\
    \ squaring.\nSee e.g. http://en.wikipedia.org/wiki/Exponentiation_by_squaring\n\
    <|/ a tags=math,c++,modular-arithmetic |>\n<| a dscore=2 tags=math,c++,modular-arithmetic\
    \ |>\nI took an algorithm of Joseph York's answer above and implemented it in\
    \ C++. \n<code>\nlong modPow(long base,long exponent){", "    $p = 2 ** $p;\n\
    \    return $n % $p if $n =~ s/^(0+)?$//;\n    my $i = 1;\n    my $d = $p >> 1;\n\
    \    while ($i <= $n) { $d = ($d * $i) % $p; $i++; }\n    return $d % $p;\n}",
  "    $p   ||= 0;\n    my $r = $n % $p;\n    return $r if $r;\n    my $q = $n / $p;\n\
    \    return $p if $q == $p;\n    return $q;\n}", "    return unless defined $n\
    \ and $n > 0;\n    return 1 if $n == 0;\n    my $x = Math::BigInt -> new(2**$n\
    \ - 1);\n    $x % $p;\n}", "    my $nabs = abs($n);\n    $nabs -= $nabs % $p;\n\
    \    $nabs += $p - $nabs % $p;\n    return $nabs % $p;\n}", '    my @x = @_;',
  "    return 1 if $n eq 0;\n    return 0 if $n eq 1 && $p eq 1;\n    return -1 if\
    \ $n eq 1 && $p eq -1;\n    return 1 if $n eq 0 && $p eq 0;\n    return 0 if ($n\
    \ eq 1 && $p eq 2) || ($n eq 1 && $p eq 3);\n    # FIXME: this should just use\
    \ modf (but with more accuracy)\n    return 1 if ($n eq 3 && $p eq 4);\n    return\
    \ -1 if ($n eq 3 && $p eq 5);\n    return 1 if ($n eq 4 && $p eq 5);\n    return\
    \ -1 if ($n eq 4 && $p eq 4);\n    if ($n >= 0) {\n        if ($n == 0 && $p <\
    \ 0) {\n            return 1;\n        } elsif ($n == 1 && $p < 0) {\n       \
    \     return 1;\n        } elsif ($n == 1 && $p > 0) {\n            return -1;\n\
    \        } elsif ($n == 2 && $p > 0) {\n            return -1;\n        } elsif\
    \ ($n == 2 && $p < 0) {\n            return 1;\n        } elsif ($n >= 2 && $n\
    \ <= 4 && $p > 0) {\n            return 1;\n        } elsif ($n >= 2 && $n <=\
    \ 4 && $p < 0) {\n            return -1;\n        }\n    } else {\n        if\
    \ ($n == 0 && $p < 0) {\n            return 1;\n        } elsif ($n == 1 && $p\
    \ > 0) {\n            return 1;\n        } elsif ($n == 1 && $p < 0) {\n     \
    \       return -1;\n        } elsif ($n == 2 && $p > 0) {\n            return\
    \ -1;\n        } elsif ($n == 2 && $p < 0) {\n            return 1;\n        }\
    \ elsif ($n >= 2 && $n <= 4 && $p < 0) {\n            return 1;\n        } elsif\
    \ ($n >= 2 && $n <= 4 && $p > 0) {\n            return -1;\n        }\n    }\n\
    \    return 0;\n}", "    my $nsign = Math::BigInt->bzero();\n    my $exp = $n\
    \ < 0 ? -$n : $n;\n    # $exp+1 => $n is a power of 2 so we only have to test\
    \ if it is a power of 2.\n    if ($exp & 1) {\n        my $x = 0;\n        $x\
    \ = Math::BigInt->new(\"10\" x $exp);\n        $nsign = $x->bcmp($p);\n    }\n\
    \    return $nsign;\n}", "    return $n if $n == 0;\n    return $n % $p if $n\
    \ < $p;\n    return $p - ($n % $p);\n}", "    # Sadly, no gmp or bc available\
    \ here, so I use a brute-force algorithm:\n    # Find largest power of 2 greater\
    \ than $p that divides $n:\n    my $lpow = 1;\n    for (my $i = 1; ($i << 1) <\
    \ $n; ++$i) {\n        if ($n & $i) { $lpow = 2 * $i; last; }\n    }\n    # return\
    \ 2^n modulo p (be aware of numerics).\n    return $n & ($lpow + $p - 1);\n}",
  "    my $n = $n % $p;\n    return $n > 0 ? $n : abs($n % $p);\n}", "    if ($p <\
    \ 0) {\n\t$n &= ~(~0 << $p);\n    } elsif ($p > 0) {\n\t$n |= (~0 >> $p);\n  \
    \  }\n    return $n;\n}", "    return 0 unless $n and $p;\n    return $n & (~$p);\n\
    }", "    if ($p == 0) {\n        return 1;\n    }\n    return $n & ($p - 1);\n\
    }", "    my $r = $n % $p;\n    if ($r && !($r == $p || ($r < $p && $r >= 0)))\
    \ { $r += $p }\n    return $r;\n}", "    return 1 if ($n == 0); # modp(0, x) =\
    \ 1\n    return $n if ($n <= 0);  # modp(3, x) = x\n    # $p is $p mod $n", '    return
    $n if $n <= 0;', "    return 0 if $n <= 0;\n    return 1 unless $p <= 0;\n   \
    \ my $c = Math::BigInt->new(1);\n    my $q = ($p - 1);\n    my $q2 = ($q + 1);\n\
    \    while($n >= $q) {\n\t$c = $c->badd($c) if ($n >= $q2);\n\t$n = $n % $q;\n\
    \t$q = ($q2 - 1);\n\t$q2 = ($q + 1);\n    }\n    return $c->bpow($q)->as_int();\n\
    }", "    return $n if $n <= 0;\n    return $p if $p <= 0;\n    return $n mod $p;\n\
    }", "    my $q = $n >> $p;\n    if ($n >= $p) {\n        return $q == 0 ? 1 :\
    \ ($q == $p ? $n : $q % $p);\n    } else {\n        $q = $n / ($p - 1);\n    \
    \    return $q + ($n % $q == 0 ? 1 : 0);\n    }\n}", '    return $p if $n <= 0;',
  "    my $n = int($n);\n    my $p = int($p);\n    $p -= 1; # mod p\n    my $result\
    \ = $n;\n    $result %= $p;\n    $result ||= $p;\n    return $result;\n}", '    return
    $n if $p == 0;', "    return undef unless defined $n;\n    return undef unless\
    \ defined $p;\n    return $n if $n == 0;", "    my $u = $n % $p;\n    return $u\
    \ == 0 ? $n : modp($n, $p);\n}", "    my($rv) = $n % $p;\n    $rv < 0 ? $rv +=\
    \ $p : $rv;\n    $rv == $p ? $rv : $rv;\n}", "    return 0 unless $n;\n    my\
    \ $result = $n;\n    my $mask = 1 * (2 ** $p);\n    while (0 != ($result & $mask))\
    \ {\n        $result -= $mask;\n        $mask >>= 1;\n    }\n    return $result;\n\
    }", "    my $a = $n % $p;\n    if ($a == 0) {\n        return 0;\n    }\n    my\
    \ $d = $p - $a;\n    while ($n >= $d) {\n        $n -= $d;\n        $a++;\n  \
    \  }\n    return $a;\n}", "    return 1 if ($n == 0);\n    return 1 if ($p ==\
    \ 0);\n    return ($n % $p == 0) ? $p : ($n % $p);\n}", '    my $x = 0;', "  \
    \  return 1 if ($n < 0) or $n <= 0;\n    return 1 if $n == 0;\n    return 1 if\
    \ $n % $p == 0;\n    return 0 if $p <= $n;\n    return 0 if (($p < $n) and ($n\
    \ % $p == 0));\n    return 1 if $n % $p < $n--;\n    my $r = $n % $p;\n    my\
    \ $i = $n / $p;\n    my $x = $r;\n    $x += $i if $i == 0;\n    $x += $p++ if\
    \ $i >= $p;\n    return $x;\n}", "    if ($n < 0) {\n\tmy $r = $n - $p;\n\t$r\
    \ = ( $r < 0 ) ? -$r : $r;\n\t$r = $p + $r if $r > $p;\n\t$n = ( $n < 0 ) ? -$n\
    \ : $n;\n\t$n = $p + $n if $n > $p;\n\treturn $r;\n    }\n    $n = $p + $n;\n\
    \    $n = $n < $p ? $p : $n;\n    return $n;\n}", "    my @a = @_;\n    return\
    \ 0 unless $n =~ /^\\d+$/;\n    my $x = $n;\n    $x =~ s/^(-?)0/$1/ if $1 ne '-';\n\
    \    my @out = ();\n    my $mod = Math::BigInt->new($p)->bpow($x);\n    for (@a)\
    \ {\n        my $mul = $_;\n        $mul->bmul($mod);\n        push(@out, $mul->bstr());\n\
    \    }\n    return Math::BigInt->new(@out)->bmod($p);\n}", "    my $x = int($n);\n\
    \    my $y = int($p);\n    my $ans = 1;\n    while ($x != 0) {\n        if ($x\
    \ & 1) {\n            $ans *= $y;\n        }\n        $x >>= 1;\n        $y >>=\
    \ 1;\n    }\n    return $ans;\n}", "    my($ndiv, $nmod) = $n / $p;\n    my($modp)\
    \ = $n % $p;\n    $nmod -= $modp;\n    return $ndiv if $nmod < 0;\n    return\
    \ $nmod if $nmod > $p;\n    return $ndiv;\n}", "    if ($p < 3) {\n        my\
    \ $x = $n % $p;\n        if ($x == 0) {\n            $x -= $p;\n        } else\
    \ {\n            $x += $p;\n        }\n        return $x;\n    } else {\n    \
    \    my $x = $n % $p;\n        $x -= $p;\n        return $x % $p;\n    }\n}",
  "    return 1 if ($n == 0 && $p == 0);\n    return 0 if ($n == 0 && $p != 0);\n\
    \    return 1 if $n >= $p;\n    return 0 unless ($n == 0 || $n == $p);\n    my\
    \ $a = $p->numify();\n    return 0 unless ($a < 2);\n    return 1 if ($a < $n);\n\
    \    $a -= $n;\n    $a = $a->numify() if ($a < $p);\n    $a %= $p;\n    return\
    \ $a;\n}", "    my $q;\n    my $r = $n % $p;\n    my $qr = $q = 1;\n    while\
    \ ($n >= $p) {\n        $n = $n % $p;\n        $qr = $qr and $q == 1;\n      \
    \  $q = $q * $r + $q == $r;\n        $r = $r / $p;\n    }\n    $qr and $q == 1\
    \ and $qr = 1;\n    $qr;\n}", "    $p == 1 ? $n : $n % $p\n}", "    my $n = int($n);\n\
    \    my $p = int($p);", "    return $n % ($p << 1);\n}", "    my $r = $n % $p;\n\
    \    return $r if $r;\n    return $p;\n}", "    # $n < 0 => 0\n    # $p < 0 =>\
    \ $n\n    # $n < $p => $n\n    # $p < $n => $p % $n\n    # $n == 0 => 1\n    #\
    \ $n == $p => $p % $n\n    $n % $p if $n < 0 || $p < 0 || $n < $p;\n}", "    my\
    \ $x = $n >> 31;\n    $x ^= $p ^ ($n & 7);\n    $x ^= $p ^ (($n >> 31) & 1);\n\
    \    return $x >> 31;\n}", "    $n = 2 ** $n;\n    $p -= 1;\n    my $mod = ($n\
    \ & $p) + 1;\n    my $mask = $p << $n;\n    $mod &= $mask;\n    $mod ^= $p;\n\
    \    return $mod;\n}", "    $n =~ s/^\\+?0*//;\n    return $n % $p if $n; # No\
    \ remainder.\n    return 1;\n}", "    return 1 if ($n == $p);\n    return 0 if\
    \ ($n == 0);\n    return $n & ($p - 1);\n}", "    # Bail if $n does not fit in\
    \ 32 bits.\n    return $n if $n > 2 ** 31 - 1;\n    # Otherwise, compute $2^n\
    \ modulo p.\n    $n = 0 if $n < 0;\n    $n -= 2 ** $n if $n < 0;\n    $n += 2\
    \ ** $p;\n    return $n % $p;\n}", "    my $m = $p;\n    for (my $i = 1; $i <=\
    \ $n; $i++) {\n        $m = $m % $p;\n    }\n    return $m;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
