name: HumanEval_56_correct_bracketing
language: pl
prompt: "# brackets is a string of \"<\" and \">\".\n# return 1 if every opening bracket\
  \ has a corresponding closing bracket.\n# >>> correct_bracketing(\"<\")\n# \"\"\n\
  # >>> correct_bracketing(\"<>\")\n# 1\n# >>> correct_bracketing(\"<<><>>\")\n# 1\n\
  # >>> correct_bracketing(\"><<>\")\n# \"\"\nsub correct_bracketing {\n    my($brackets)\
  \ = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&correct_bracketing;\n\
  \        if(eq_deeply($candidate->(\"<>\"),1)) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"<<><>>\"),1)) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  <><><<><>><>\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(\"<><><<<><><>><>><<><><<>>>\"),1)) {\n     \
  \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  <<<><>>>>\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(\"><<>\"),\"\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"<\"),\"\")) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  <<<<\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n   \
  \     if(eq_deeply($candidate->(\">\"),\"\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"<<>\"),\"\")) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  <><><<><>><>><<>\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n  \
  \      }\n        if(eq_deeply($candidate->(\"<><><<><>><>>><>\"),\"\")) {\n   \
  \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    return 1 if ($brackets =~ m!^<[<>]>$!);\n    return \"\" if ($brackets\
    \ =~ m!<(<*)>(<*)>$!);\n    return \"\" if ($brackets =~ m!<[<>]>(*)$!);\n   \
    \ return 1 if ($brackets =~ m!<(<*)>(*)>$!);\n    return 1 if ($brackets =~ m!<[<>]>$!);\n\
    \    return \"\";\n}", "    return undef if ($brackets eq '<>');\n    my $open_brackets\
    \ = $brackets =~ /(\\[\\w+\\])/g;\n    my $close_brackets = $brackets =~ /(\\\
    [\\w+\\])/g;\n    my $matches = 0;\n    foreach my $open_bracket (@$open_brackets)\
    \ {\n\tforeach my $close_bracket (@$close_brackets) {\n\t    $close_bracket =~\
    \ s/\\[//g;\n\t    $close_bracket =~ s/\\]//g;\n\t    next if ($open_bracket eq\
    \ $close_bracket);\n\t    $matches++;\n\t}\n    }\n    return $matches == (@$open_brackets\
    \ - 1);\n}", "    $brackets =~ s/^[<>]*([^<>])[<>]*$/$1$2/;\n    return 0 unless\
    \ length($brackets) == 2;\n    my $opening_bracket = substr($brackets, 0, 1);\n\
    \    my $closing_bracket = substr($brackets, 1, 1);\n    return 1 if $opening_bracket\
    \ =~ /^([<>])$/;\n    return 0 if $closing_bracket !~ /^$opening_bracket$/;\n\
    \    return 1;\n}", "    my $open_brackets = $brackets =~ /^<(>*)>$/g;\n    $open_brackets\
    \ = $open_brackets > 0 ? 1 : 0;\n    $open_brackets *= $open_brackets == 1 ? -1\
    \ : 1;\n    return $open_brackets;\n}", "    my(@open) = ();\n    my(@close) =\
    \ ();\n    my $i = 0;\n    while ($i < $#{$brackets}){\n        my $c1 = substr($brackets,\
    \ $i, 1);\n        my $c2 = substr($brackets, $i + 1, 1);\n        push (@open,\
    \ \"<\", $c1, $c2, $c2, \">\");\n        push (@close, \"<\", $c1, $c2, $c2, \"\
    >\");\n        $i += 2;\n    }\n    return 0 unless ((scalar(@open) == scalar(@close))\
    \ and\n                        (scalar(@open) == scalar(grep(/^</,@open))) &&\n\
    \                        (scalar(@close) == scalar(grep(/^</,@close))) &&\n  \
    \                      (scalar(@open) == scalar(grep(/>$/,@open))) &&\n      \
    \                  (scalar(@close) == scalar(grep(/>$/,@close)));\n    # print\
    \ STDERR \"open @open; close @close\\n\";\n    # print STDERR \"#@open #@close\\\
    n\";\n    my $open_brackets = scalar(grep(/^</,@open));\n    my $close_brackets\
    \ = scalar(grep(/^</,@close));\n    my $open_close = scalar(grep(/>$/,@open));\n\
    \    my $close_open = scalar(grep(/>$/,@close));\n    return 1 if ($open_brackets\
    \ == $close_brackets &&\n                 $open_close == $close_open);\n    return\
    \ 0;\n}", "    $brackets =~ s/^</$brackets</g;\n    $brackets =~ s/^>/$brackets>/g;\n\
    \    $brackets =~ s/<$/<$brackets>/g;\n    $brackets =~ s/>$/>$brackets>/g;\n\
    \    $brackets =~ s/^<\\//$brackets$/g;\n    return $brackets =~ /^<$/;\n}", " \
    \   my @result = grep /^<+/ ? $brackets =~ s/^<+// : !/\\+/ ? 1 : 0, split \"\
    >\", $brackets;\n    my $result = \"\";\n    for (@result) {\n        $result\
    \ .= $_ eq \"<>\" ? \"[\" or \"]\" : $_;\n    }\n    return $result;\n}", "  \
    \  $brackets =~ s/^<<<\\K//g;\n    $brackets =~ s/^>>\\K//g;\n    $brackets =~\
    \ s/<+/>/g;\n    $brackets =~ s/>+</g;\n    $brackets =~ s/\\A<|>/g;\n    $brackets\
    \ =~ s/\\Z<|>/g;\n    return !length($brackets);\n}", "    my(@opening_brackets);\n\
    \    my(@closing_brackets);\n    my($opening_bracket);\n    my($closing_bracket);\n\
    \    my($new_bracket);\n    while ($brackets =~ /(?:<|>)/g) {\n        $opening_bracket\
    \ = $&;\n        unless (defined $closing_bracket) {\n            $closing_bracket\
    \ = substr($brackets, 0, length($opening_bracket));\n        }\n        $new_bracket\
    \ = $closing_bracket;\n        @closing_brackets = grep { $_ ne $closing_bracket\
    \ } @closing_brackets;\n        unless (defined $opening_bracket) {\n        \
    \    push @opening_brackets, $new_bracket;\n        } else {\n            my $closing_bracket\
    \ = pop @closing_brackets;\n            push @opening_brackets, $new_bracket;\n\
    \            push @opening_brackets, $closing_bracket;\n        }\n    }\n   \
    \ return $opening_brackets eq @opening_brackets ? \"\" : 1;\n}", "    return ''\
    \ unless $brackets =~ /(<)[^>]*>/;\n    return $1 if $1 eq \">\";\n    return\
    \ '1';\n}", "    return undef unless $brackets =~ /\\G<\\s*((?>[^<>]+|<>)+)\\\
    s*\\K>/xs;\n    return 1 unless $1 eq '<>';\n    return 1 unless $1 eq '<';\n\
    \    return undef;\n}", "    $brackets =~ s/<//g;\n    $brackets =~ s/>//g;\n\
    \    my $count = 0;\n    while ($brackets =~ m{((?>[^<>]+|(?<=[^<>])>))*})g) {\n\
    \        $count++;\n        $brackets =~ s/\\Q$matches[0]\\E//g;\n    }\n    return\
    \ $count;\n}", "    # If the brackets are invalid, return None.\n    return 1\
    \ unless $brackets =~ m{^<+>+$};\n    # Otherwise, loop through all characters\
    \ in the brackets.\n    my($bracket_count) = 0; # number of opening bracket pairs\n\
    \    my($bad_char) = undef; # characters that should be considered \"bad\".\n\
    \    for (my $i = 0; $i <= length($brackets); $i++) {\n        if ($brackets[$i]\
    \ == $brackets[$i+1]) {\n            $bracket_count++;\n        } else {\n   \
    \         if ($bracket_count > 0) {\n                # If we are at the end of\
    \ an opening bracket pair, we\n                # must have an opening bracket.\n\
    \                # If we have an opening bracket, return None immediately.\n \
    \               # If we have not yet encountered an opening bracket,\n       \
    \         # set $bad_char to the last character in the bracket pair.\n       \
    \         $bad_char = $brackets[$i];\n                return 0;\n            }\n\
    \            $bracket_count = 1; }\n    }\n    # If we get here and have an unmatched\
    \ bracket pair, return None.\n    return 1;\n}", "    $brackets =~ tr/>/></;\n\
    \    return $brackets eq \"<>\" ? \"\" : 1;\n}", "    $brackets =~ s/^<([^<>]+)>//;\n\
    \    return 1 unless length($brackets);\n    my $open_brackets = 0;\n    foreach\
    \ my $b (split //, $brackets) {\n        if ($b  eq \"<\") {\n            $open_brackets\
    \ += 1;\n        } else {\n            $open_brackets -= 1;\n        }\n    }\n\
    \    return 0 unless $open_brackets == 0;\n    return \"\";\n}", "    # Remove\
    \ all opening brackets and then all closing brackets.\n    my $corrected = $brackets\
    \ =~ s/\\<\\>//g;\n    # Count how many brackets are open. Add one to the corrected\
    \ string.\n    return $corrected =~ s/\\(\\+\\)/$1+1/go;\n}", "    $brackets =~\
    \ s/<(>|$)/$1/g;\n    return $brackets !~ s/<[^<>]*>//g;\n}", "    return \"\"\
    \ unless $brackets =~ /[<>]+/;\n    my @brackets = map { quotemeta $_ } $brackets;\n\
    \    my $openings = join \"|\", map { \"<$_>\" } @brackets;\n    my $closings\
    \ = join \"|\", map { \">$_\" } @brackets;\n    return $openings =~ /($openings)|($closings)/;\n\
    }", "    my %result = ();\n    my $len = length($brackets);\n    if ($len <= 1)\
    \ {\n        return $len if $len > 1;\n        return 0;\n    }\n    my $cnt =\
    \ 0;\n    my $last;\n    for (my $i = 0; $i < $len; $i++) {\n        if ($brackets\
    \ eq substr($brackets, $i, 1)) {\n            $cnt++;\n        }\n        elsif\
    \ ($brackets eq substr($brackets, $i, -1)) {\n            $cnt--;\n        }\n\
    \        elsif ($brackets eq substr($brackets, $i, 1)) {\n            $cnt--;\n\
    \        }\n        elsif ($brackets eq substr($brackets, $i, -1)) {\n       \
    \     $cnt++;\n        }\n        else {\n            last;\n        }\n     \
    \   $last = substr($brackets, $i, 1);\n    }\n    return $cnt > 0 ? 1 : 0;\n}",
  "    my @stack = ();\n    my %brackets = ();\n    my $open = 0;\n    foreach my\
    \ $b (split /,/, $brackets) {\n\tnext if $b == '';\n\tif ($open != 1) {\n\t  \
    \  $stack[$#stack + 1] = $b;\n\t}\n\tif ($b == \">\") {\n\t    $open = 1;\n\t\
    }\n\telse {\n\t    $open = 1 if $b == \"<\";\n\t    $stack[$#stack] .= $b;\n\t\
    }\n    }\n    my $result = $open;\n    foreach my $b (@stack) {\n\t$result |=\
    \ $brackets{$b};\n    }\n    return $result;\n}", "    my $open_bracket = $brackets\
    \ =~ /(?<=^)</;\n    my $closing_bracket = $brackets =~ /(?=^)</;\n    my $correct\
    \ = $open_bracket && $closing_bracket;\n    $correct ||= ($brackets =~ /(?<=^)>>(?=^)/g)\
    \ > 0;\n    $correct;\n}", "    my(@opening_brackets, %brackets);\n    my(@closing_brackets,\
    \ %brackets);\n    push(@opening_brackets, qw( < >));\n    push(@closing_brackets,\
    \ qw( > < ));\n    while (@opening_brackets) {\n        my $closing = shift(@closing_brackets);\n\
    \        if ($brackets{$closing} && !$brackets{$closing} eq $closing) {\n    \
    \        %brackets{$closing} = $closing;\n        }\n        elsif (!$brackets{$closing}\
    \ && $closing ne \"\") {\n            %brackets{$closing} = $closing;\n      \
    \  }\n    }\n    return scalar(@opening_brackets);\n}", "    return unless $brackets\
    \ =~ /^<.*>$/;\n    return unless $brackets =~ /^\\s*$/;\n    my($open_brackets)\
    \ = $brackets =~ s/^<\\|\\s*$//r;\n    my($closed_brackets) = $brackets =~ s/^\\\
    s*\\|\\s*$//r;\n    return 0 unless $open_brackets =~ /^</; # no brackets on both\
    \ sides!\n    return 0 unless $closed_brackets =~ /^<\\/.*>$/; # no brackets on\
    \ each other!\n    $open_brackets =~ s/^<\\|\\s*>$//; # remove the opening bracket\n\
    \    $closed_brackets =~ s/^\\s*\\|\\s*>$//; # remove the closing bracket\n  \
    \  return 1 if $open_brackets =~ /^</; # wrong bracketing - return 1\n    return\
    \ 1 if $closed_brackets =~ /^<\\/.*>$/; # wrong bracketing - return 1\n    return\
    \ undef;\n}", "    my($match) = m{(</?$brackets>)}g;\n    return($match) if $match;\n\
    \    return(1);\n}", '    return 1 if ($brackets =~ /[<>]/);', "    return 1 if\
    \ $brackets =~ m#^<\\|]>$#;\n    return 1;\n}", "    $brackets =~ s/<(/${1}/g;\n\
    \    $brackets =~ s/>$//;\n    $brackets =~ s/(>){2,}//g;\n    return $brackets;\n\
    }", "    my $stack = 0;\n    my $last = $brackets[0];\n    my $open = 0;\n   \
    \ for my $bracket (@$brackets) {\n        if ($bracket eq $last) {\n         \
    \   $open++;\n        } elsif ($open > 0) {\n            if ($bracket eq '>')\
    \ {\n                $stack++;\n            } elsif ($bracket eq '<') {\n    \
    \            $stack--;\n            }\n        }\n        if ($open > 0 && $stack\
    \ == 0) {\n            $open = 0;\n        }\n        $last = $bracket;\n    }\n\
    \    return $open == 0;\n}", "    $brackets =~ s/^<<</<<</g;\n    $brackets =~\
    \ s/>>>>>/>>>>/g;\n    $brackets =~ s/^>><\\s*<[^<]*>\\s*><<\\s*>$//g;\n    $brackets\
    \ =~ s/^<\\s*<[^<]*>\\s*><<\\s*>$//g;\n    $brackets =~ s/^<\\s*<[^<]*>\\s*>\\\
    s*><<\\s*>$//g;\n    $brackets =~ s/^<<<\\s*<[^<]*>\\s*>\\s*><<\\s*>$//g;\n  \
    \  $brackets =~ s/^<<<\\s*<[^<]*>\\s*>\\s*><<\\s*>$//g;\n    $brackets =~ s/^<<<\\\
    s*<[^<]*>\\s*>\\s*>\\s*><<\\s*>$//g;\n    $brackets =~ s/^<<<\\s*<[^<]*>\\s*>\\\
    s*>\\s*><<\\s*>$//g;\n    return $brackets =~ s/^<<<\\s*<[^<]*>\\s*>\\s*>\\s*><<\\\
    s*>$//g;\n}", "    $brackets =~ s/<\\</\"\"/g;\n    $brackets =~ s/>/>\"\"/g;\n\
    \    $brackets =~ s/\"\"/>\\</g;\n    return $brackets =~ s/^</</;\n}", "    my($match)\
    \ = 0;\n    my(@result) = (\"\");\n    for ($brackets) {\n        s/([<>])/$match\
    \ ? \"\" : \"$1\"/g;\n        push @result, $match;\n        $match++;\n    }\n\
    \    return @result;\n}", "    return unless ($brackets =~ m/^<*>/);\n    my $stack\
    \ = 0;\n    my $closed = undef;\n    for my $b (split '>', $brackets) {\n    \
    \    my $open = $b;\n        $closed = $closed || '<>' if ($b = \"<$open>\");\n\
    \        return 1 if ($b =~ m/^<(.*[^>])>$/);\n        my $next = $b; # just to\
    \ show we're still comparing\n        $next = $stack if $open == $next;\n    \
    \    $stack = $next;\n    }\n    return $closed; # never reached\n}", "    my\
    \ @opening = split '[<>]', $brackets;\n    my @closing = split '[<>]', $brackets;\n\
    \    my $correct = 0;\n    for (my $i = 0; $i < @opening; $i++) {\n        next\
    \ unless $i < @closing;\n        $correct += $closing[$i] == $opening[$i];\n \
    \   }\n    return $correct;\n}", '    my(@opening, %stack, $closing);', "    $brackets\
    \ =~ s/^<+//;\n    $brackets =~ s/>+$//;\n    $brackets =~ s/^>+//;\n    $brackets\
    \ =~ s/^<+//;\n    $brackets =~ s/^>+$//;\n    return $brackets;\n}", "    return\
    \ 1 unless $brackets =~ /\\G(\\<[^<>]*\\>)\\G/s;\n    return 0 if $1 !~ /\\G(\\\
    <[^<>]*\\>)\\G/s;\n    return 1;\n}", "    $brackets =~ s/^>//g;\n    $brackets\
    \ =~ s/^<//g;\n    return $brackets =~ s/^([^<>])/$1 \\1/;\n}", "    $brackets\
    \ =~ s/<+>+//g;\n    $brackets =~ s/<+[^>]+>+//g;\n    return 0 unless $brackets\
    \ eq \"\";\n    $brackets =~ s/([^<>]+)\\(([^<>]+)\\)/$1$2/g;\n    return 0 unless\
    \ $brackets eq \"\";\n    $brackets =~ s/([^<>]+)\\(([^<>]+)\\)/$1>$2/g;\n   \
    \ return 1;\n}", "    $brackets =~ tr/< >/ /;\n    my $count = $brackets =~ tr/<\
    \ >/ /;\n    return $count > 1;\n}", "    my(@to_check) = map { substr($_, -1)\
    \ } split $brackets;\n    foreach my $check (@to_check) {\n        if ($check\
    \ != \">\" && $check != \"<\") {\n            return 1;\n        }\n    }\n  \
    \  return \"\";\n}\n</code>\n<|/ a dscore=0 tags=regex,perl |>\n<| a tags=regex,perl\
    \ |>\n<code>", "    my($open, $close) = (\"\", \"\");\n    my $i = 0;\n    while(length($brackets)\
    \ > $i) {\n        if($brackets[$i] eq \"<\") {\n            $open = $brackets[$i+1];\n\
    \            next;\n        }\n        if($brackets[$i] eq \">\") {\n        \
    \    $close = $brackets[$i+1];\n            $open = '';\n            next;\n \
    \       }\n        $i++;\n    }\n    return 1 if $open eq $close;\n    return\
    \ 1 if $open eq '';\n    return 1;\n}", "    return 1 unless $brackets =~ /</;\n\
    \    for (split //, $brackets) {\n        if (m/(\\<)/) {\n            my $next\
    \ = $1;\n            my(@closing) = ($next =~ m/(\\>)/);\n            return 1\
    \ if (@closing == 1);\n        }\n    }\n    return 0;\n}", "    $brackets =~\
    \ s/^[<>]+$//;\n    return $brackets =~ tr/[]<>/{}/;\n}\n</code>\n<|/ a tags=perl\
    \ |>\n<| c |>\nA problem with this solution is that it assumes that all the brackets\
    \ have a matching closing bracket, which may not be the case.\n<|/ c |>\n<| c\
    \ |>\nYes, that would be a problem. I'm sorry for not mentioning it in my answer.\n\
    <|/ c |>\n<| c |>\nSorry to hear that. But I see that my solution isn't correct\
    \ either. I edited it for completeness.\n<|/ c |>\n<| c |>\nSorry, my bad. I didn't\
    \ notice that it was using regex to do the job. I thought that was a recursive\
    \ solution not using regex, but I was wrong.\n<|/ c |>\n<| c |>\nYes, the problem\
    \ is indeed the assumption that all the brackets are correctly balanced.  I think\
    \ we might have had the same idea, but we might have had a different idea of \"\
    correct\" :)\n<|/ c |>\n<| a dscore=2 tags=perl |>\nHere's an alternate solution,\
    \ based loosely on the technique demonstrated by Hobbes above. This code will\
    \ do the job, but it may be an overkill for such a problem.\n<code>\nuse strict;\n\
    use warnings;", "    my $open_brackets_count = () = $brackets =~ tr/[]<>//;\n\
    \    my $closed_brackets_count = () = $brackets =~ tr/<>[]//;\n    return 0 if\
    \ $open_brackets_count != $closed_brackets_count;\n    return 1;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThat worked perfectly, thank you so much. I also figured\
    \ out a solution for cases where there are multiple brackets in the string that\
    \ need to be checked. I'll post it as an answer since my reputation doesn't allow\
    \ me to post it.\n<|/ c |>\n<| a dscore=2 |>\nI figured out the correct solution\
    \ for when there are multiple brackets in the string that need to be checked,\
    \ using the solution provided by and. Thanks to and.\n<code>", "    $brackets\
    \ =~ s/^<\\<?>//;\n    $brackets =~ s/^<\\<\\>$//;\n    $brackets =~ s/^<\\<\\\
    ><\\>$//;\n    $brackets =~ s/\\>$//;\n    $brackets =~ s/\\>\\>\\>$//;\n    $brackets\
    \ =~ s/\\>\\>//;\n    $brackets =~ s/^<\\<\\>//;\n    return 1 if $brackets =~\
    \ /^\\Q$brackets\\E$/;\n    return '';\n}", "    my ($open, $close) = split \"\
    \ \", $brackets;\n    $open =~ s/([<>])/$1/g;\n    $close =~ s/([<>])/$1/g;\n\
    \    $open =~ s/^<//g;\n    $close =~ s/$>$//g;\n    return $open eq $close;\n\
    }", "    my($open_bracket, $close_bracket);\n    my($closing_brackets, $open_brackets);\n\
    \    my(@unmatched);", "    my($matched);\n    while ($brackets =~ s/(\\<)([^\\\
    >]*)(\\>)([^\\>]*)\\>//) {\n        ($matched++) if ($3 eq $2);\n    }\n    return\
    \ $matched;\n}", "    return $brackets =~ s/^<([^>]*)>$/$1/; # remove leading\
    \ < and trailing >\n}", "    $brackets =~ s/^(<|>)//;\n    return $brackets eq\
    \ \"<>\" ? 1 : 0;\n}", "    my $count = 0;\n    for my $x (@$brackets) {\n   \
    \     ++$count if $x eq '<';\n    }\n    return $count ? \"\" : \"1\";\n}", '    my($open_brackets);',
  "    $brackets =~ s/^\\</$brackets></g;\n    $brackets =~ s/\\>$//;\n    return\
    \ $brackets;\n}\n</code>\n<|/ a |>\n<| c |>\n+1 but I don't understand how \"\
    <<>>\" would come out as one bracket per line. Could you explain?\n<|/ c |>\n\
    <| c |>\n: I assumed that OP was doing some sort of word wrapping to get the effect\
    \ of a \"<\" and \">\" surrounding a line. But maybe I'm wrong.\n<|/ c |>\n<|\
    \ c |>\nI'm assuming that OP is doing some sort of word wrapping, but maybe I'm\
    \ wrong too. Sorry if that wasn't the case. :)\n<|/ c |>\n<| c |>\n+1 for the\
    \ idea of doing some sort of wrapping.  I never thought about doing word wrapping\
    \ like that.\n<|/ c |>\n<| c |>\nThis is very cool. I wish I could upvote this\
    \ more than once :). But, what if I wanted to have it wrap each line separately,\
    \ instead of just on the first line?\n<|/ c |>\n<| a tags=regex |>\nHow about\
    \ this?\n<code>\n^[^<>]*([<>])[^<>]*$\n</code>\nhttp://regexr.com?2v7zt\n<|/ a\
    \ dscore=1 |>\n<| c |>\nThis matches even the text `<<>>`\n<|/ c |>\n<| c |>\n\
    I didn't think about that. I think it would be a good idea to fix the opening\
    \ bracket to be a space instead of a dash since the example data doesn't look\
    \ like it could be anywhere except in the middle of a line.\n<|/ c |>\n<| c |>\n\
    : Actually, it shouldn't match `<<>>` either. I've edited the answer.\n<|/ c |>\n\
    <| a |>\nPerhaps something like this: \n<code>\n/\\<+[^\\>]*\\>+/\n</code>\n<|/\
    \ a dscore=0 tags=regex |>\n<| c |>\nDoesn't match: \"<><>\"\n<|/ c |>\n<| a dscore=0\
    \ |>\nYou could do this: \n<code>\n^([^<>]+)(<)(.+)(>)$\n</code>\nThis would match\
    \ each character in between < and > on its own line.\n<|/ a tags=regex |>\n<|\
    \ c |>\nThis matches even the text <<>>\n<|/ c |>\n<| c |>\nHe wants the < and\
    \ > ", "    $brackets =~ s/<+/>+/g;\n    $brackets =~ s/^>+//;\n    $brackets\
    \ =~ s/(<)\\s*[^<>]+\\s*(>)+/$1$2$3/g;\n    return $brackets;\n}", "    my @open\
    \ = map {\n        my $s = \"<\" . $_;\n        substr($s, $s->[0]+1, 0, $s->[0]+length($s))\n\
    \    } split $brackets;\n    my $opening_match = \"\";\n    for my $open (@open)\
    \ {\n        my $close = grep {\n            substr($_, 0, 1) eq $open ? $_ ne\
    \ $opening_match : $_ eq $open\n        } @open;\n        return $close ? ($opening_match\
    \ = \">$open\") : 1;\n    }\n    return 0;\n}", "    my @brackets = split //,\
    \ $brackets;\n    my $result = \"\";\n    my $cur = \"\";\n    my $last = 0;\n\
    \    my $found = 0;\n    foreach my $b (@brackets) {\n        if (($cur ne \"\
    <\") && ($cur ne \">\")) {\n            if ($last != 0) {\n                if\
    \ ($cur == $b) { $found = 1; last; }\n                if ($found == 0) { $result\
    \ .= $b; }\n            }\n            $cur = $b;\n            $last = 0;\n  \
    \      }\n        if ($cur == $b) { $found = 1; last; }\n    }\n    $result .=\
    \ $cur;\n    if ($found == 0) { return \"\"; }\n    return 1;\n}", "    my($result);\n\
    \    while ($brackets =~ m/<([^<>]+)>/g) {\n        $result .= \"<\" . $1 . \"\
    >\";\n    }\n    return $result;\n}", "    # Don't change if no opening brackets\
    \ given.\n    return \"\" if not $brackets;\n    # If the brackets are \"<<>>\"\
    , all are balanced.\n    if ($brackets eq '<<>>') {\n        return 1;\n    }\n\
    \    # Get the position of every opening bracket.\n    my($open_pos) = grep {\
    \ m/^</ } split '<<>>', $brackets;\n    # Do nothing if the number of opening\
    \ brackets isn't even.\n    return \"\" if not @$open_pos;\n    # Get the number\
    \ of correct brackets.\n    my(@correct_brackets) = grep { m/^>$/ } split '<<>>',\
    \ $brackets;\n    # Do nothing if the number of correct brackets isn't even.\n\
    \    return \"\" if not @correct_brackets;\n    # Find the position of the last\
    \ closing bracket.\n    my($close_pos) = (grep { m/^>$/ } split '<<>>', $brackets)[-1];\n\
    \    # Do nothing if there's no matching closing bracket.\n    return \"\" if\
    \ $close_pos == @$open_pos;\n    # Compare the position of the closing bracket\
    \ with the opening brackets.\n    my $difference = @$open_pos - @correct_brackets;\n\
    \    # If there's only one correct bracket, there's no need for further changes.\n\
    \    return \"\" if $difference == 1;\n    # Otherwise, there are unclosed brackets\
    \ at the end of the file.\n    # Return the number of unclosed brackets.\n   \
    \ return scalar @$open_pos[@$open_pos - $difference + 1];\n}", "    my $count\
    \ = 0;\n    while($brackets =~ /<|>/) {\n        my $x = $1;\n        $count++\
    \ if $x =~ /[<>]/;\n        $brackets =~ s/<$x>//g;\n    }\n    return $count;\n\
    }", "    my(@brackets) = split /[<>]/, $brackets;\n    my($count) = 0;", "   \
    \ $brackets =~ s/^<((?>[^<>]+|(?<!^)\\G(?!\\A)))*>//;\n    $brackets =~ s/^<([^<>]+)>//;\n\
    \    return 1 if $brackets =~ s/>//;\n    return 1 if $brackets =~ s/[^<>]+$//;\n\
    \    return \"\";\n}\n</code>\n<|/ a dscore=3 tags=regex,python |>\n<| c |>\n\
    The `(?(DEFINE)...)` construct is perl specific. What about Python ? Is there\
    \ a similar construct ?\n<|/ c |>\n<| c |>\n, yes, it is. See http://docs.python.org/library/re.html#re.DEBUG.\
    \ Python `re` module also has `\\G` regex operator to match strings continuously.\n\
    <|/ c |>\n<| c |>\nNice, thanks ! This code actually works... But I must say it's\
    \ not as simple as I initially thought it would be :P I'll check out `\\G`\n<|/\
    \ c |>\n<| c |>\n, check my answer for a Python version, too.\n<|/ c |>\n<| c\
    \ |>\nIt might be nice to give this answer a name like `unbalanced(\"<<><>>\"\
    )` (or something similar), to remind people that you can have multiple solutions.\
    \ :)\n<|/ c |>\n<| a dscore=2 tags=regex,python |>\n<code>\ndef unbalanced(s):\n\
    \   s = s.replace(\"<<><>>\",\">\")\n   s = s.replace(\"<\",\"\").replace(\">\"\
    ,\"\")\n   return not s.count(\"<\")", "    my($count) = length($brackets);\n\
    \    for (my $i = 0; $i < $count; $i += 2) {\n        if ($brackets[$i] eq \"\
    <\") {\n            my $next_bracket = substr($brackets, $i + 1, 1);\n       \
    \     if ($next_bracket eq \">\") {\n                return 1;\n            }\n\
    \        }\n    }\n    return \"\";\n}", "    return 1 unless $brackets =~ /^<+|\\\
    +>+|<|>+$/;\n    my $stack = 0;\n    my $result = \"\";\n    my $in_quote = 0;\n\
    \    for (split //, $brackets) {\n        if ($in_quote) {\n            if ($_\
    \ eq \"\\\"\") {\n                $in_quote = 0;\n            }\n            else\
    \ {\n                $result .= $_ unless $in_quote && $_ eq \"\\\\\";\n     \
    \           $result .= $in_quote ? \"\\\"\" : \"\\\\\";\n                $in_quote\
    \ = 0;\n            }\n        }\n        elsif ($_ eq '\"') {\n            $in_quote\
    \ = 1;\n        }\n        elsif ($_ eq '>') {\n            $stack++ if $stack;\n\
    \        }\n        elsif ($_ eq '<') {\n            $stack-- if $stack;\n   \
    \     }\n        elsif ($stack) {\n            $result .= $_ unless $stack &&\
    \ $_ eq \"\\\\\";\n        }\n    }\n    return $result;\n}", "    my $open_brackets\
    \ = 0;\n    $brackets =~ s/^[\\(\\)]/$open_brackets++;$open_brackets/omsx;\n \
    \   $brackets =~ s/^[\\(\\)]$/$open_brackets--;$open_brackets/omsx;\n    $brackets\
    \ =~ s/^[\\(\\)]$/omsx;\n    return $brackets =~ /^$/? 1 : ($open_brackets ==\
    \ 0);\n}\n</code>\n<|/ a |>\n<| c |>\nThanks for your effort. I was just curious,\
    \ would it be easier just to check for the occurrence of `<` at the end of a line\
    \ and do nothing if it is? I'm guessing that you think that's the same thing,\
    \ correct? I wouldn't be surprised if I didn't understand it at all, but I'm not\
    \ an expert at all so I hope that I can do some testing before I award the answer\
    \ to you.\n<|/ c |>\n<| c |>\nOh, I see what you mean now. I didn't realize that\
    \ you would want to exclude cases where `<` is immediately followed by a space,\
    \ period, or comma. So your method would exclude `<>>` but not `<>`. I don't think\
    \ that's what you want.\n<|/ c |>\n<| c |>\nYes, I do want it to exclude `<>>`.\
    \ That's a fair point. I just thought that it would be better to exclude it before\
    \ it happens, since `<` can be followed by other characters, and it would be nicer\
    \ to exclude them before it happens, especially since `<` can be the beginning\
    \ of a line, and it would be nicer to exclude it before it happens, especially\
    \ since `<` can be at the end of the line (no newline at the end), and we would\
    \ like to avoid including it.\n<|/ c |>\n<| c |>\nThat makes sense and makes a\
    \ lot more sense now. You were correct about your question being the same thing\
    \ I thought it was, but I still think my method might be better in some cases.\
    \ I suspect that it would have problems even if I used `s//gmsx` to avoid the\
    \ replacements of `$_`, but that might be a separate question.\n<|/ c |>\n<| c\
    \ |>\nI've updated my answer. I think my new method might be better than my old\
    \ one depending on what kind of strings you are dealing with. The new method should\
    \ handle your two edge cases.\n<|/ c |>\n<| a tags=regex,perl |>\nI suspect that\n\
    <code>\nperl -lne 'print if ! m{<}x'\n</code>\ndoes what you want.", "    my($open_bracket);\n\
    \    my($close_bracket);\n    $open_bracket = $close_bracket = 0;\n    for (my\
    \ $i = 0; $i < length($brackets); $i++) {\n        my $char = substr($brackets,\
    \ $i, 1);\n        if ($char eq \"<\") {\n            $open_bracket++;\n     \
    \   } elsif ($char eq \">\") {\n            $open_bracket--;\n        }\n    \
    \    if (($open_bracket != 0) && ($open_bracket != 1)) {\n            return \"\
    \";\n        }\n    }\n    return 1;\n}\n</code>\n<|/ a |>\n<| c |>\nYour solution\
    \ only detects the empty string when there are two consecutive brackets. It should\
    \ detect one when the brackets are correctly nested.\n<|/ c |>\n<| a |>\nI think\
    \ this is a better solution. \n<code>", "    my $open_bracket = $brackets =~ s/^<//\
    \ and $brackets =~ s/>$//;\n    my $close_bracket = $brackets =~ s/^>// and $brackets\
    \ =~ s/<$//;\n    return $open_bracket == $close_bracket;\n}", "    $brackets\
    \ =~ s/<//g;\n    $brackets =~ s/>//g;\n    my $result = \"\";\n    my $counter\
    \ = 1;\n    for (my $i = 0; $i < length($brackets); ++$i) {\n        if ($brackets[$i]\
    \ == \"<\") {\n            $counter += $i > 0 ? 1 : 0;\n        }\n        elsif\
    \ ($brackets[$i] == \">\") {\n            $counter -= $i > 0 ? 1 : 0;\n      \
    \  }\n        elsif ($brackets[$i] == \"<\") {\n            $result = $counter\
    \ == 0 ? 1 : $result;\n        }\n        elsif ($brackets[$i] == \">\") {\n \
    \           $result = $counter == 0 ? \"\" : $result;\n        }\n        elsif\
    \ ($brackets[$i] == \"(\") {\n            $result = $counter == 0 ? 1 : $result;\n\
    \        }\n        elsif ($brackets[$i] == \")\") {\n            $result = $counter\
    \ == 0 ? \"\" : $result;\n        }\n    }\n    return $result;\n}", "    # return\
    \ 1 if every opening bracket has a corresponding closing bracket.\n    # >>> correct_bracketing(\"\
    <\")\n    # \"\"\n    # >>> correct_bracketing(\"<>\")\n    # 1\n    # >>> correct_bracketing(\"\
    <<><>>\")\n    # 1\n    # >>> correct_bracketing(\"><<>\")\n    # \"\"\n    return\
    \ $brackets =~ m{</?$brackets> }s;\n}", "    $brackets =~ s/^<\\W*//;  # strip\
    \ leading \"<\"\n    $brackets =~ s/>\\W*$//;  # strip trailing \">\"\n    return\
    \ 1 unless $brackets =~ /^<$/;  # no open brackets\n    return 1 unless $brackets\
    \ =~ /\\W*$>/;  # no close brackets\n    return 1 unless $brackets =~ /\\W*\\\
    >/;  # no extra close brackets\n    return 0;\n}", "    my @opening_brackets =\
    \ split /<|>/, $brackets;\n    my @closing_brackets = split /<|>/, $brackets;\n\
    \    my $correct_bracketing;\n    for (my $i = 0; $i < @opening_brackets; $i++)\
    \ {\n        $correct_bracketing .= $closing_brackets[$i];\n        $correct_bracketing\
    \ .= $opening_brackets[$i];\n    }\n    return $correct_bracketing;\n}", "   \
    \ my($correct_brackets) = \"\";\n    my($open_bracket) = \"\";\n    my($open_brackets)\
    \ = 0;\n    my($closed_bracket) = \"\";\n    my($closed_brackets) = 0;", "   \
    \ my $result = \"\";\n    while ($brackets =~ s/^\\[?<[^>]>?\\]?(?=[^\\[<]+?<\\\
    ])//) {\n        $result .= $1;\n    }\n    return $result;\n}", "    $brackets\
    \ =~ s/^([<>]{0,3})//;\n    $brackets =~ s/([<>]{0,3})$//;\n    return $brackets;\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3 |>\nThe canonical solution to this\
    \ problem would probably be a \"regular expression\" that will identify the correct\
    \ pairings. As you say, it's easy to get \"<<>>\" wrong; I'd just use an HTML\
    \ parser instead, since they're easy to write and understand.\n<|/ a tags=perl,text-analysis,text-parsing\
    \ |>\n<| a dscore=2 |>\nA quick perl script that parses the data and outputs the\
    \ number of closing and opening brackets.  \n<code>", "    return 1 if ($brackets\
    \ =~ /[\\<\\>]+/);\n    # return 1 if ($brackets =~ /[\\[\\{\\(]/ or $brackets\
    \ =~ /[\\]}\\)\\]]/);\n    return 1 if $brackets =~ /\\<\\</;\n    return 1 if\
    \ $brackets =~ /\\>\\</;\n    return 1 if $brackets =~ /\\<\\>/ or $brackets =~\
    \ /\\>\\<\\</;\n    return 1 if $brackets =~ /\\<\\>/;\n    return 1 if $brackets\
    \ =~ /\\>\\<\\</;\n    return 0;\n}", "    my($opening_brackets, $closing_brackets);\n\
    \    foreach $opening_bracket (split(/\\<\\>/, $brackets)) {\n        if ($closing_brackets{$opening_bracket})\
    \ {\n            $opening_brackets .= $opening_bracket;\n        } else {\n  \
    \          $opening_brackets .= \"{$opening_bracket}\";\n        }\n    }\n  \
    \  $opening_brackets\n};", '    return 1 if $brackets =~ /^<+>$/ or $brackets
    =~ /^<<+>>$/ or $brackets =~ /^<\++\++\++\++\++\++>>$/ or $brackets =~ /^<<<\++>>$/
    or $brackets =~ /^<\+\+\+\+\+\+\+\+\+\+\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\++\',
  "    return 1 if $brackets =~ /\\G</;\n    return 1 if $brackets =~ /\\G\\>/;\n\
    \    return 1 if $brackets =~ /\\G<\\//;\n    return 1 if $brackets =~ /\\G\\\
    >\\//;\n    return 1 if $brackets =~ /\\G<\\>/;\n    return 1 if $brackets =~\
    \ /\\G>\\>/;\n    return 1 if $brackets =~ /\\G<<\\//;\n    return 1 if $brackets\
    \ =~ /\\G>>\\//;\n    return 1 if $brackets =~ /\\G<\\//;\n    return 1 if $brackets\
    \ =~ /\\G\\>\\//;\n    return 1 if $brackets =~ /\\G<<\\>/;\n    return 1 if $brackets\
    \ =~ /\\G>>\\>/;\n    return 1 if $brackets =~ /\\G<\\//;\n    return 1 if $brackets\
    \ =~ /\\G\\>\\//;\n    return 1 if $brackets =~ /\\G<<\\>/;\n    return 1 if $brackets\
    \ =~ /\\G>>\\>/;\n    return 1 if $brackets =~ /\\G<\\//;\n    return 1 if $brackets\
    \ =~ /\\G\\>\\//;\n    return 1 if $brackets =~ /\\G<<\\>/;\n    return 1 if $brackets\
    \ =~ /\\G>>\\>/;\n    return 1 if $brackets =~ /\\G<\\//;\n    return 1 if $brackets\
    \ =~ /\\G\\>\\//;\n    return 1 if $brackets =~ /\\G<<\\>/;\n    return 1 if $brackets\
    \ =~ /\\G>>\\>/;\n    return 1 if $brackets =~ /\\G<\\//;\n    return 1 if $brackets\
    \ =~ /\\G\\>\\//;\n    return 1 if $brackets =~ /\\G<<\\>/;\n    return 1 if $brackets\
    \ =~ /\\G>>\\>/;\n    return 1 if $brackets =~ /\\G<\\//;\n    return 1 if $brackets\
    \ =~ /\\G\\>\\//;\n    return 1 if $brackets =~ /\\G<<\\>/;\n    return 1 if $brackets\
    \ =~ /\\G>>\\>/;\n    return 1 if $brackets =~ /\\G<\\//;\n    return 1 if $brackets\
    \ =~ /\\G\\>\\//;\n    return 1 if $brackets =~ /\\G<<\\>/;\n    return 1 if $brackets\
    \ =~ /\\G>>\\>/;\n    return 1 if $brackets =~ /\\G<\\//;\n    return 1 if $brackets\
    \ =~ /\\G\\>\\//;\n    return 1 if $brackets =~ /\\G<<\\>/;", "    $brackets =~\
    \ s/<\\?\\s*\\(\\s*([^\\)]*)\\s*\\)\\s*\\?>\\s*<\\?\\s*\\(\\s*([^\\)]*)\\s*\\\
    )\\s*\\?>/$1$2$3$4/;\n    $brackets =~ s/<\\?\\s*\\(\\s*([^\\)]*)\\s*\\)\\s*\\\
    ?>\\s*<\\?\\s*\\(\\s*([^\\)]*)\\s*\\)\\s*\\?>/$2$1$3$4/;\n    $brackets =~ s/<\\\
    ?\\s*\\(\\s*([^\\)]*)\\s*\\)\\s*\\?>/<\\?\\s*\\(\\s*$1\\s*\\)\\s*\\?>/;\n    $brackets\
    \ =~ s/<\\?\\s*\\(\\s*([^\\)]*)\\s*\\)\\s*\\?>/<\\?\\s*\\(\\s*$2\\s*\\)\\s*\\\
    ?>/;\n    $brackets =~ s/<\\?\\s*\\(\\s*([^\\)]*)\\s*\\)\\s*\\?>/$1$2$3\\?>/;\n\
    \    $brackets =~ s/<\\?\\s*\\(\\s*([^\\)]*)\\s*\\)\\s*\\?>/<\\?\\s*\\(\\s*$2\\\
    s*\\)\\s*\\?>/;\n    $brackets =~ s/<\\?\\s*\\(\\s*([^\\)]*)\\s*\\)\\s*\\?>/<\\\
    ?\\s*\\(\\s*$1\\s*\\)\\s*\\?>/;\n    return $brackets;\n}", "    $brackets =~\
    \ s{\n        ^\n        ( <\n        [^>]*\n        > )\n    }{\n        &_correctBracketing(\\\
    $1, \\$2, \\$3, \\$4);\n    }egx;\n    $brackets =~ s{\n        ^\n        ( <\n\
    \        [^>]*\n        > )\n    }{\n        &_correctBracketing(\\$1, \\$2, \\\
    $3, \\$4);\n    }egx;\n    return $brackets;\n}", "    $brackets =~ s/^<+//;\n\
    \    $brackets =~ s/^>+//;\n    $brackets =~ s/^<*>//;\n    $brackets =~ s/^<<<*>//;\n\
    \    $brackets =~ s/^>+\\z//;\n    return 1 unless $brackets =~ /\\S/;\n    return\
    \ \"\" unless $brackets =~ /\\S/;\n    return 1 unless $brackets =~ s/^\\s*//;\n\
    \    return \"\";\n}", "    $brackets =~ s/\\([^\\)]*\\)//;\n    $brackets =~\
    \ s/^\\([<>]\\)$/\\1/;\n    $brackets =~ s/^\\([<>]\\)\\([<>]\\)$/\\1\\2/;\n \
    \   return ($brackets == \"\") ? 1 : \"\";\n}", "    # empty string is always\
    \ correct\n    return $brackets if $brackets =~ /^$/;\n    my(@brackets);\n  \
    \  # find all bracket pairings, including duplicates\n    $brackets =~ s/(<[^>]*>)+/\
    \ push, quotemeta($&) . \"\\1\"; /g;\n    # remove duplicates, as they would confuse\
    \ the bracketing algorithm\n    @brackets = uniq(@brackets);\n    # find each\
    \ of the pairs\n    for ($i = 0; $i < @brackets; $i++) {\n        my $bracket\
    \ = substr($brackets, $i, 1);\n        # skip if we don't have 2 opening brackets\n\
    \        next if $bracket !~ m/^<+>/;\n        # find and remove all closing brackets\n\
    \        my $closing = -1;\n        for ($i = $i + 2; $i < @brackets; $i++) {\n\
    \            $closing = substr($brackets, $i, 1);\n            next if $closing\
    \ !~ m/>+>/;\n            substr($brackets, $i, 1) = \"/>\";\n        }\n    \
    \    next if $closing > -1;\n        # if we still have one, we've missed a close\
    \ bracket\n        $closing = \"/>\";\n        $brackets =~ s/$bracket$closing/\
    \ />/g;\n    }\n    # replace with the remaining pairs\n    $brackets =~ s/(<[^>]*>)/\\\
    1/g;\n    # check for extra close brackets\n    if ($brackets =~ m/><+>/>/g) {\n\
    \        $brackets =~ s/>$/></g;\n    }\n    return $brackets;\n}", "    return\
    \ 1 if ($brackets =~ /^<*$>*$/);\n    return 1 if ($brackets =~ /^<*$><*$>*$/);\n\
    \    return 1 if ($brackets =~ /^<*$>*<*$>*$/);\n    return 1 if ($brackets =~\
    \ /^<*$><*$><*$>*$/);\n    return 0 if ($brackets =~ /^<*$><*$><*$>*<*$>*$/);\n\
    \    return 0 if ($brackets =~ /^<*$><*$><*$><*$><*$>*$/);\n    return 0 if ($brackets\
    \ =~ /^<*$><*$><*$><*$><*$><*$><*$>*$/);\n    return 0 if ($brackets =~ /^<*$><*$><*$><*$><*$><*$><*$><*$><*$><*$>*$/);\n\
    \    return 0 if ($brackets =~ /^<*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$>*$/);\n\
    \    return 0 if ($brackets =~ /^<*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*$><*",
  "    my($match) = ();\n    my($open_bracket) = ();\n    my($close_bracket) = ();\n\
    \    my($incorrect_bracket) = ();", "    $brackets =~ s/(<([<]*)([^>]+)*([^>]+)*>*)(\\\
    s*\\k<1>*$//g;\n    return !$brackets;\n}", "    my(@stack) = ();\n    for ($brackets)\
    \ {\n        if (\"[]\" eq $_) {\n            push(@stack, $brackets[0]);\n  \
    \      }\n        if ($stack[-1] ne \"[\" && !($stack[-1] eq \"]\")) {\n     \
    \       push(@stack, \">\");\n        }\n        if ($stack[-1] eq \"]\" && $_\
    \ ne \"]\") {\n            push(@stack, $brackets[0]);\n        }\n    }\n   \
    \ my $brackets_ok = join(\"\", map { \"$_\" } @stack);\n    return \"\" if $brackets_ok\
    \ eq \"[]\";\n    return 1;\n}", "    my(@opening)    = ();\n    my(@closing)\
    \     = ();\n    my(@opening_count) = ();\n    my(@closing_count) = ();\n    my\
    \ $result = 0;\n    while(my $char = substr($brackets, 0, 1)) {\n        chomp($char);\n\
    \        if($char eq \"<\") {\n            $opening[$#opening] .= $char;\n   \
    \         $opening_count[$#opening]++;\n        }\n        elsif($char eq \">\"\
    ) {\n            $closing[$#closing] .= $char;\n            $closing_count[$#closing]++;\n\
    \        }\n        elsif($char eq \"<\") {\n            $opening[$#opening] .=\
    \ $char;\n            $opening_count[$#opening]++;\n        }\n        elsif($char\
    \ eq \">\") {\n            $closing[$#closing] .= $char;\n            $closing_count[$#closing]++;\n\
    \        }\n        else {\n            $opening[$#opening] .= $char;\n      \
    \      $opening_count[$#opening]++;\n            $closing[$#closing] .= $char;\n\
    \            $closing_count[$#closing]++;\n        }\n    }", "    my $result\
    \ = 0;\n    for (my $i = 0; $i < length($brackets); $i++) {\n        if (substr($brackets,\
    \ $i, 1) eq \"<\") {\n            $result = 0;\n        } elsif (substr($brackets,\
    \ $i, 1) eq \">\") {\n            $result++;\n        }\n    }\n    return $result;\n\
    }", "    \n    my $ret = 1;\n    \n    # Go through all the brackets and determine\
    \ what to do.\n    my $opening_bracket = 0;\n    my $closing_bracket = 0;\n  \
    \  my $close_counter = 0;\n    foreach my $bracket (split //, $brackets) {\n \
    \       if ($bracket eq '<') {\n            $opening_bracket = 1;\n        }\n\
    \        elsif ($bracket eq '>') {\n            $closing_bracket = 1;\n      \
    \  }\n        elsif ($bracket eq '<') {\n            if ($closing_bracket) {\n\
    \                $close_counter++;\n                if ($close_counter == 2) {\n\
    \                    # Found a valid opening bracket, now need to find another\
    \ matching closing bracket.\n                    $closing_bracket = 0;\n     \
    \           }\n                else {\n                    $close_counter = 0;\n\
    \                }\n            }\n        }\n        elsif ($bracket eq '>')\
    \ {\n            if ($opening_bracket) {\n                # Found a valid closing\
    \ bracket, now need to find another matching opening bracket.\n              \
    \  $opening_bracket = 0;\n            }\n            else {\n                $opening_bracket\
    \ = 1;\n            }\n        }\n    }\n    \n    return $ret if $opening_bracket\
    \ == 0 && $closing_bracket == 0;\n    return $ret if $opening_bracket == 1 &&\
    \ $closing_bracket == 1;\n    return $ret if $closing_bracket == 2;\n    return\
    \ $ret if $opening_bracket == 2;\n    \n    return $ret;\n}", "    $brackets =~\
    \ s/^\\s*//; # remove leading whitespace.\n    $brackets =~ s/\\s*$//; # remove\
    \ trailing whitespace.\n    my($result) = 0;\n    my @brackets = split //, $brackets;\n\
    \    for (@brackets) {\n        if ($_ eq '<') {\n            $result = $result\
    \ || 1;\n        } else {\n            $result = 0;\n        }\n    }\n    $result;\n\
    }", "    my @brackets_stack = ();\n    my @open_stack = ();\n    for (my $i =\
    \ 0; $i < length($brackets); $i++) {\n        if (substr($brackets, $i, 1) eq\
    \ \"<\") {\n            push @open_stack, substr($brackets, 0, $i);\n        \
    \    my $is_match = find_closing_bracket($i, $brackets, \\@open_stack);\n    \
    \        $i = $is_match ? $is_match : $i;\n            push @brackets_stack, $i;\n\
    \        } elsif (substr($brackets, $i, 1) eq \">\") {\n            my $is_match\
    \ = find_closing_bracket($i, $brackets, \\@brackets_stack);\n            $i =\
    \ $is_match ? $is_match : $i;\n            pop @brackets_stack;\n        }\n \
    \   }\n    return 0 unless @brackets_stack;\n    return 1;\n}", "    $brackets\
    \ =~ s/^<<<\\s*//;\n    $brackets =~ s/\\s*>>>\\s*//;\n    return ($brackets =~\
    \ /[<>]/g) ? 1 : 0;\n}", "    my $stack = ();\n    my $current_brackets = 0;\n\
    \    for (my $i = 0; $i < length($brackets); $i++) {\n        if ($brackets[$i]\
    \ == \"<\") {\n            $stack->[$current_brackets] = \"< \";\n           \
    \ $current_brackets++;\n        }\n        elsif ($brackets[$i] == \"<\") {\n\
    \            $stack->[$current_brackets] = \"< \";\n            $current_brackets++;\n\
    \        }\n        elsif ($brackets[$i] == \">\") {\n            my $last_bracket\
    \ = $current_brackets;\n            $current_brackets--;\n            $stack->[$last_bracket]\
    \ .= \">\";\n        }\n        elsif ($brackets[$i] == \">\") {\n           \
    \ my $last_bracket = $current_brackets;\n            $current_brackets--;\n  \
    \          $stack->[$last_bracket] .= \">\";\n        }\n        elsif ($brackets[$i]\
    \ == \" \") {\n        }\n        elsif ($brackets[$i] == \" \") {\n        }\n\
    \        elsif ($brackets[$i] == \" \") {\n        }\n        elsif ($brackets[$i]\
    \ == \"<\") {\n        }\n        elsif ($brackets[$i] == \"<\") {\n        }\n\
    \        elsif ($brackets[$i] == \"<\") {\n        }\n        elsif ($brackets[$i]\
    \ == \"<\") {\n        }\n        elsif ($brackets[$i] == \"<\") {\n        }\n\
    \        elsif ($brackets[$i] == \"<\") {\n        }\n        elsif ($brackets[$i]\
    \ == \"<\") {\n        }\n        elsif ($brackets[$i] == \"<\") {\n        }\n\
    \        elsif ($brackets[$i] == \"<\") {\n        }\n        elsif ($brackets[$i]\
    \ == \"<\") {\n        }\n        elsif ($brackets[$i] == \">\") {\n        }\n\
    \        elsif ($brackets[$i] == \"<\") {\n        }\n        elsif ($brackets[$i]\
    \ == \"<\") {\n        }\n        elsif ($brackets[$i] == \"<\") {\n        }\n\
    \        elsif ($brackets[$i] == \"<\") {\n        }\n        elsif ($brackets[$i]\
    \ == \"<\") {\n        }\n        elsif ($brackets[$i] == \"<\") {\n        }\n\
    \        elsif ($brackets[$i] == \"<\") {\n        }\n        elsif ($brackets[$i]\
    \ == \"<\") {\n        }\n        elsif ($brackets[$i] == \"", "    # replace\
    \ each opening bracket with a closing bracket.\n    # this can be done with perl's\
    \ tr///\n    $brackets =~ tr/([<>])/\\\\$1/sg;\n    # remove all internal spaces\n\
    \    $brackets =~ tr/  /  /sg;\n    # remove all extraneous whitespace.\n    $brackets\
    \ =~ tr/  /  /sg;\n    # remove leading spaces.\n    $brackets =~ s/^\\s+//;\n\
    \    # remove trailing spaces.\n    $brackets =~ s/\\s+$//;\n    # remove any\
    \ blank lines at the start.\n    $brackets =~ s/^\\s*$//;\n    # remove any blank\
    \ lines at the end.\n    $brackets =~ s/\\s*$//;\n    return $brackets;\n}", " \
    \   my $correct = 0;\n    my $openings = 0;\n    my $closings = 0;\n    my $last_char;\n\
    \    $last_char = '~';\n    for my $b (split(//, $brackets)) {\n        if ($b\
    \ = '~') {\n            $last_char = substr($brackets, -2, 1);\n            next;\n\
    \        }\n        if ($b =~ /^(<+)/) {\n            $closings++;\n        }\
    \ else {\n            $openings++;\n        }\n    }\n    if ($openings == $closings)\
    \ {\n        return $correct;\n    } else {\n        return $correct;\n    }\n\
    }", "    my (@opening, @closing, $open_count - 1, $close_count);\n    foreach\
    \ my $b (split(//, $brackets)) {\n        if ($b eq '<') {\n            if ($open_count\
    \ > 0)\n            {\n                # closing bracket is open before the opening\
    \ bracket\n                $close_count = $open_count;\n                $open_count\
    \ = 0;\n            }\n            else\n            {\n                # we are\
    \ at the first opening bracket\n                $open_count = 1;\n           \
    \ }\n        }\n        elsif ($b eq '>') {\n            if ($close_count > 0)\n\
    \            {\n                # we are at the last closing bracket\n       \
    \         $close_count = $open_count;\n                $open_count = 0;\n    \
    \        }\n            else\n            {\n                # we are at the last\
    \ opening bracket\n                $open_count = 1;\n            }\n        }\n\
    \        elsif ($b eq '(') {\n            $open_count++;\n        }\n        elsif\
    \ ($b eq ')') {\n            $close_count++;\n        }\n        elsif ($open_count\
    \ == 0 and $close_count == 0) {\n            # No opening and no closing bracket\n\
    \            push (@opening, $b);\n        }\n    }\n    return 1 if @opening;\n\
    \    return 0;\n}", "    $brackets =~ tr|[]{}()<>\\n\\r||d;\n    $brackets =~\
    \ s/^$brackets//;\n    return $brackets =~ tr/[]{}()<>\\n\\r//d;\n}", "    my\
    \ $bracket_count = 0;\n    my $result;\n    while ($brackets =~ /(?<!^)<<(?!\\\
    ()/s) {\n        if ($bracket_count == 0 && $1 eq \"<\") {\n            $bracket_count++;\n\
    \        } elsif ($1 eq \">\") {\n            $bracket_count--;\n        } elsif\
    \ ($1 eq \"<\" && $bracket_count < 0) {\n            $bracket_count++;\n     \
    \   } else {\n            $result = $bracket_count;\n        }\n    }\n    $result;\n\
    }", "    my($count) = 0;\n    \n    my(@open_brackets);\n    my(@close_brackets);\n\
    \    \n    for (split(/ /, $brackets)) {\n        push(@open_brackets, \"<\");\n\
    \        push(@close_brackets, \">\");\n    }\n    \n    for (@open_brackets)\
    \ {\n        for (@close_brackets) {\n            if ($_ eq $_) {\n          \
    \      ++$count;\n            }\n        }\n    }\n    return $count;\n}", " \
    \   return 0 unless $brackets;\n    return 1 unless $brackets =~ /[^<>]/g;\n \
    \   return 1 unless $brackets =~ s/^<//;\n    return 1 unless $brackets =~ s/^>/>/;\n\
    \    return 0 unless $brackets =~ s/^<<<[^>]*>>\\Z// != 0;\n    return 0 unless\
    \ $brackets =~ s/^>>[^>]*<<\\Z// != 0;\n    return 0 unless $brackets =~ s/^>><<[^>]*>>\\\
    Z// != 0;\n    return 0 unless $brackets =~ s/^<+[^>]*>\\Z// != 0;\n    return\
    \ 0 unless $brackets =~ s/^<[^>]*>+\\Z// != 0;\n    return 0 unless $brackets\
    \ =~ s/^<\\+[^>]*>\\Z// != 0;\n    return 0 unless $brackets =~ s/^<<<[^>]*>>\\\
    Z// != 0;\n    return 0 unless $brackets =~ s/^>>[^>]*<<\\Z// != 0;\n    return\
    \ 0 unless $brackets =~ s/^>><<[^>]*>>\\Z// != 0;\n    return 0 unless $brackets\
    \ =~ s/^<[^>]*>+\\Z// != 0;\n    return 0 unless $brackets =~ s/^<+[^>]*>\\Z//\
    \ != 0;\n    return 0 unless $brackets =~ s/^<<<[^>]*>>\\Z// != 0;\n    return\
    \ 0 unless $brackets =~ s/^>>[^>]*<<\\Z// != 0;\n    return 0 unless $brackets\
    \ =~ s/^>><<[^>]*>>\\Z// != 0;\n    return 0 unless $brackets =~ s/^<[^>]*>+\\\
    Z// != 0;\n    return 0 unless $brackets =~ s/^<\\+[^>]*>\\Z// != 0;\n    return\
    \ 1 unless $brackets =~ s/^<\\+[^>]*>\\Z// != 0;\n    return 1 unless $brackets\
    \ =~ s/^<[^>]*>+\\Z// != 0;\n    return 1;\n}", "    my $ret = '';\n    my $open_brackets\
    \ = 0;\n    my $i;\n    for ($i = 0; $i < length $brackets; $i++) {\n        my\
    \ $char = substr($brackets, $i, 1);\n        if ($char eq '<') {\n           \
    \ $open_brackets++;\n        } else {\n            $open_brackets--;\n       \
    \ }\n        if ($open_brackets == 0) {\n            $ret .= $char;\n        }\n\
    \    }\n    return $ret;\n}", "    chomp($brackets);\n    $brackets =~ s/^\\s*//;\n\
    \    $brackets =~ s/\\s*$//;\n    if ($brackets !~ /[<>]/) {\n        return 1;\n\
    \    }\n    my @stack;\n    while (1) {\n        my $opening_bracket = substr($brackets,\
    \ 0, 1);\n        my $closing_bracket = substr($brackets, -1);\n        push(@stack,\
    \ $opening_bracket);\n        if (! $opening_bracket eq $closing_bracket) {\n\
    \            return 1;\n        }\n        $brackets = substr($brackets, 1, -1);\n\
    \    }\n}", "    my($open, $close, $found);\n    my $correct = 1;\n    while($brackets)\
    \ {\n\t$found = 0;\n\t$open =~ s/^<//g;\n\t$close =~ s/^>//g;\n\twhile($open !~\
    \ m/\\A</) {\n\t    $open .= \"<\";\n\t    $found++;\n\t}\n\twhile($close !~ m/>\\\
    z/ and $found > 0) {\n\t    $close .= \">\";\n\t    $found--;\n\t}\n\t$correct\
    \ = 1 if ($open == $close);\n\tmy $rest = $brackets;\n\tsubstr($brackets, 0, length($open))\
    \ = $close;\n\t$brackets =~ s/^[^<>]*//;\n\t$brackets =~ s/[^<>]*$//;\n\t$brackets\
    \ = $rest;\n    }\n    return $correct;\n}", "    return 1 unless $brackets =~\
    \ /<[^<>]*>/g;\n    my @brackets = ($brackets ~= s/^<//,\n                   \
    \ $brackets ~= s/>$//);\n    for (@brackets) {\n        return 1 if $1 eq \">\"\
    ;\n    }\n    return;\n}", "    return 1 unless $brackets =~ m/<[^>]*>/ ||\n \
    \                     $brackets =~ m/<[^>]*<[^>]*>/ ||\n                     \
    \ $brackets =~ m/<[^>]*<[^>]*<[^>]*>/;\n    $brackets =~ m/<[^>]*>/;\n}", "  \
    \  $brackets =~ s/^\\s*//;\n    $brackets =~ s/\\s*$//;", "    return 1 if $brackets\
    \ =~ /\\A[<>]+\\Z/;\n    $brackets =~ s/^\\s*//;\n    $brackets =~ s/\\s*$//;\n\
    \    return $brackets =~ /\\A[<>]+\\Z/;\n}", "    $brackets =~ tr/\\<\\>/{}{}g;\n\
    \    return $brackets eq '{}' ? 1 : 0;\n}", "    $brackets =~ s/^(<[^<>]*>)//;\n\
    \    $brackets =~ s/^(<)$/\\1</;\n    $brackets =~ s/^(<.*>$//;\n    return $brackets;\n\
    }\n</code>\nThe above code removes the \"<\" and \">\" at the beginning and end\
    \ of a string, but doesn't remove anything in between.\n<|/ a tags=regex,perl,parsing\
    \ |>\n<| c |>\nThis looks like a nice solution! I didn't know `split` could take\
    \ a regular expression. I'm testing it now to see if it works.\n<|/ c |>\n<| c\
    \ |>\n- I tested my new code and it doesn't seem to work. I'm going to test it\
    \ more and update my question if I have more problems with it.\n<|/ c |>\n<| c\
    \ |>\n- Oops, I had a bug in the code. The new code should work now.\n<|/ c |>\n\
    <| c |>\nOh, now it works! Thank you, Jason! Now to fix it so I can get it to\
    \ remove things in between.\n<|/ c |>\n<| a tags=regex,perl,parsing dscore=2 |>\n\
    In response to your question: why do you want to do this?\nI find that regular\
    \ expressions are the wrong tool for the job. In particular, for XML/XSLT parsing,\
    \ you need a proper XSLT parser. I would suggest something like XML::LibXML:\n\
    <code>", "    my($opening_brackets_found);\n    my($close_quote);", "    $brackets\
    \ =~ s/^<<<$//;\n    $brackets =~ s/>>>>>$//;\n    return 1 unless ($brackets\
    \ =~ m/<<<(.*)>>>>/s);\n    $brackets =~ s/^<<<//;\n    $brackets =~ s/>>>>$//;\n\
    \    return $1;\n}\n</code>\n<|/ a tags=perl |>\n<| c |>\nIt doesn't work for\
    \ my input `<x><y><x>`.\n<|/ c |>\n<| c |>\n: Yeah, I'm not a regex expert by\
    \ any means. But you clearly didn't test this particular case.\n<|/ c |>\n<| c\
    \ |>\n: It works because `<<<x><y><x>` is parsed as `<<<`, `x><y><x`, `>` instead\
    \ of `<x><y><x>`.\n<|/ c |>\n<| c |>\n: Ah, yes, you're right. I just had a brain\
    \ freeze and assumed it was parsing \"<\" as \"<x>\". My bad. I'll remove my comment.\n\
    <|/ c |>\n<| a |>\nHere's another option using regex:\n<code>\nuse v5.10;\nuse\
    \ strict;\nuse warnings;", '    $brackets =~ s/\(\<\<\<\<\<\<\<\<\<\<\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>\>',
  "    $brackets =~ tr/>/></g;\n    $brackets =~ tr/>/</g;\n    $brackets =~ tr/></g;\n\
    \    return 1 if $brackets =~ /[\\<\\>]/;\n    return 1 if $brackets =~ /<>/;\n\
    \    return 1 if $brackets =~ /<\\>/;\n    return 1;\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nYes, `tr/>/></g;` is correct. `tr/>/</g;` does nothing at all.\
    \ `tr/></g;` will remove all `>` and then remove all `<` and then remove all `<`\
    \ again. It does not change anything.\n<|/ c |>\n<| c |>\nI understand that `tr/>/></g;`\
    \ is correct. I am saying that `tr/>/</g;` does nothing at all. `tr/></g;` will\
    \ remove all `>` and then remove all `<` and then remove all `<` again. It does\
    \ not change anything.\n<|/ c |>\n<| c |>\nYes, you are right. I removed it now.\
    \ Sorry\n<|/ c |>\n<| a |>\nHere is a solution with no looping which works with\
    \ strings and arrays of strings.\nIt uses the fact that if the string in $string\
    \ starts with a >, all the characters after that are non-whitespace until the\
    \ next > are removed.\nIf the string starts with a <, all the characters after\
    \ that are non-whitespace until the next < are removed.\nIf there are no more\
    \ characters left in $string, then $string is returned.\n<code>\nuse strict;\n\
    use warnings;", "    my($ret) = 0;\n    my @stack = ();\n    my $cur_pos = 0;",
  "    my($result) = $brackets =~ s/^<[>]$//g;\n    return $result;\n}", "    my $corrected;\n\
    \    \n    for (my $i = 0; $i < length($brackets); $i++) {\n        if ($brackets[$i]\
    \ eq '<') {\n            if ($i + 1 < length($brackets) && $brackets[$i + 1] =~\
    \ /[<>]/) {\n                $corrected = $brackets[$i] . $brackets[$i + 1];\n\
    \                $i += 2;\n            }\n            else {\n               \
    \ $corrected = $brackets[$i];\n            }\n        }\n        else {\n    \
    \        if ($brackets[$i] eq '>') {\n                if ($i - 1 >= 0 && $brackets[$i\
    \ - 1] =~ /[<>]/) {\n                    $corrected = $brackets[$i] . $brackets[$i\
    \ - 1];\n                    $i -= 1;\n                }\n                else\
    \ {\n                    $corrected = $brackets[$i];\n                }\n    \
    \        }\n            else {\n                $corrected = $brackets[$i];\n\
    \            }\n        }\n    }\n    \n    return $corrected;\n}", "    my $num_open\
    \ = length($brackets) / 2;\n    my $num_closed = length($brackets) - $num_open;\n\
    \    for (my $i = 0; $i < $num_open; ++$i) {\n        unless ($brackets[2 * $i]\
    \ eq $brackets[2 * $i + 1]) {\n            $num_closed = $num_closed - 1;\n  \
    \      }\n    }\n    return $num_closed > 0;\n}", "    my $str = '';\n    $str\
    \ .= $brackets . chr(0);\n    while ($brackets =~ s/<[^<]*?>//g) {\n        $str\
    \ .= $brackets . chr(0);\n    }\n    $str =~ s/^$/$/;\n    $str =~ s/<$//;\n \
    \   return $str =~ s/$//;\n}", "    $brackets =~ s/^[<]{0,1}/</g;\n    $brackets\
    \ =~ s/^[>]{0,1}/>/g;\n    $brackets =~ s/^[<][>]{0,1}/<>/g;\n    $brackets =~\
    \ s/^[<>]{0,1}//g;\n    $brackets =~ s/^</</g;\n    $brackets =~ s/$/>/g;\n  \
    \  return ($brackets !~ /</) ? 0 : 1;\n}", "    my $correct_bracketing = 0;\n\
    \    my $pos = 0;\n    while ($pos < length($brackets)) {\n        # skip any\
    \ whitespace\n        while ($pos < length($brackets) && $brackets[$pos] eq \"\
    \ \") {\n            $pos++;\n        }\n        $correct_bracketing += $pos +\
    \ 1;\n        $pos++;\n    }\n    return $correct_bracketing;\n}", "    my $count\
    \ = 0;\n    my $count = 0;\n    my $open_bracket = \" {\";\n    my $close_bracket\
    \ = \" }\"; \n    $open_bracket =~ s/^\\s+//;\n    $close_bracket =~ s/^\\s+//;\n\
    \    my $in_bracket = 0;\n    foreach my $x (split(//, $brackets)) {\n       \
    \ next if $x eq \"\"; # skip empty strings\n        next if $x eq $open_bracket;\
    \ # skip opening brackets\n        if ($x eq $open_bracket) {\n            $in_bracket\
    \ = 1;\n        }\n        elsif ($x eq $close_bracket) {\n            $in_bracket\
    \ = 0;\n        }\n        $count++ if $in_bracket;\n    }\n    return $count\
    \ > 0;\n}", "    my($brackets_hash) = ();\n    my($current_string);", "    return\
    \ unless (defined $brackets);\n    my($last, $first) = split '<'; # assume \"\
    <>\"\n    my $len = length $last;\n    my $len2 = length $first;\n    my $ret\
    \ = substr($brackets, $len, $len2);\n    return $ret if $ret =~ s/^<//;\n    return\
    \ $ret if $ret =~ s/>$//;\n    return 1;\n}", "    my($open_brackets);\n    my($closed_brackets);\n\
    \    my($result);", "    return 1 if $brackets =~ /^<.*>$/;\n    my $left  = $brackets\
    \ =~ s/^<//r;\n    my $right = $brackets =~ s/^>//r;\n    return 1 unless $left\
    \ != $right;\n    return 1 unless $left =~ /^<.+>$/;\n    return 1 unless $right\
    \ =~ /^<.+>$/;\n    return 1 unless $left =~ /^</;\n    return 1 unless $right\
    \ =~ /^</;\n    return 1;\n}", "    my $depth = 0;\n    my $last = '';\n    my\
    \ $match = 0;\n    for (my $i = 0; $i <= length($brackets); $i++) {\n        my\
    \ $c = substr($brackets, $i, 1);\n        my $prev = substr($brackets, $i - 1,\
    \ 1);\n        if ($prev eq '<' && $c eq '<') {\n            $depth++;\n     \
    \   }\n        elsif ($prev eq '>' && $c eq '>') {\n            $depth--;\n  \
    \      }\n        elsif ($prev eq '<' && $c eq '>') {\n            $depth++;\n\
    \        }\n        $match = $depth;\n    }\n    return $match;\n}", "    $brackets\
    \ =~ s/^</</;\n    $brackets =~ s/^>/>/;\n    return $brackets;\n}", "    my $count\
    \ = 0;\n    my $prev = '';\n    my $open_brackets = '';\n    my $closed_brackets\
    \ = '';\n    for my $b (split / /, $brackets) {\n        if ( $b == $prev) {\n\
    \            $count++;\n        } else {\n            $count = 0;\n          \
    \  $prev = $b;\n        }\n        if ($prev eq '<') {\n            $open_brackets\
    \ .= $b;\n        }\n        if ($prev eq '>') {\n            $closed_brackets\
    \ .= $b;\n        }\n    }\n    return $open_brackets =~ /<>/;\n}\n</code>\n<|/\
    \ a dscore=3 tags=algorithm,regex |>\n<| c |>\nNice, though it's easy to make\
    \ mistakes: eg `<<<EOF<><EOF>>>`\n<|/ c |>\n<| c |>\nThanks, I'll take another\
    \ look at it\n<|/ c |>\n<| c |>\nThanks, I made a mistake. Fixed now.\n<|/ c |>\n\
    <| c |>\nThanks. I fixed a similar mistake I did :)\n<|/ c |>\n<| c |>\n+1 This\
    \ seems reasonable but doesn't really answer the question. Also, it isn't clear\
    \ where that string comes from - is that a given?\n<|/ c |>\n<| a |>\nHere's a\
    \ regex that will match a balanced set of brackets, no matter where they're placed:\n\
    <code>\n/([^\\[\\]]*)([<])\\2\\1/\n</code>\nThis assumes the [ and ] characters\
    \ are always present. It will match an even number of <s and >s. The parentheses\
    \ are used here to capture what's in them. This means that it will match <> as\
    \ <>, when this is actually the correct setting.\nHere's a Ruby script demonstrating\
    \ how it works:\n<code>\nirb(main):001:0> '<test><><><>' =~ /([^\\[\\]]*)([<])\\\
    2\\1/\n=> 3\nirb(main):002:0> $&\n=> \"<test><><>\"\nirb(main):003:0> $2\n=> \"\
    <>\"\n</code>\nThe last line is what we wanted. The first two is what the regex\
    \ matched as (in this case, the match is the entire match, and the captured groups\
    \ are $& and $2). \nSince this is a Ruby script, I used irb to test the regex\
    \ (which uses the same regex engine as Perl, which is what my version of Perl\
    \ uses).\nIf you wanted to do this purely in Perl, you could use the following\
    \ expression", "    $brackets =~ tr/[]/{}/d;\n    \n    return \"\" unless $brackets\
    \ =~ s/^[<>]/\"\"/;\n    \n    return 1 unless $brackets =~ s/^<</\"\"/;\n   \
    \ return 1 unless $brackets =~ s/^>>/\"\"/;\n    return 1 unless $brackets =~\
    \ s/^<</\"\"/;\n    return 1 unless $brackets =~ s/^>>/\"\"/;\n    return 1 if\
    \ $brackets =~ s/^<</>/>/;\n    return 1 if $brackets =~ s/^>>/<>/;\n    return\
    \ 1 if $brackets =~ s/^</>/>/;\n    return 1 if $brackets =~ s/^<><>/</;\n   \
    \ \n    return 0;\n}", "    chomp($brackets);\n    $brackets =~ s/^<*\\>// if\
    \ $brackets =~ /^<*\\>/;\n    $brackets =~ s/^<+\\>// if $brackets =~ /^<+\\>/;\n\
    \    $brackets =~ s/^<+// if $brackets =~ /^<+\\>/;\n    $brackets =~ s/^>*\\\
    >// if $brackets =~ /^>*\\>/;\n    $brackets =~ s/^>+\\>// if $brackets =~ /^>+\\\
    >/;\n    $brackets =~ s/^>+// if $brackets =~ /^>+\\>/;\n    return $brackets;\n\
    }", "    return '' unless defined $brackets;\n    return 1 unless $brackets =~\
    \ m/<[^>]*>/g;\n    $brackets =~ s/</$brackets[0]/g;\n    return '' unless $brackets\
    \ =~ s/^\\s*//;\n    return 1 unless $brackets =~ s/\\s*$brackets/g;\n    return\
    \ '' unless $brackets =~ s/^\\s*//;\n    return 1 unless $brackets =~ s/\\s*$brackets/g;\n\
    \    $brackets =~ s/^\\s*//;\n    return 1 unless $brackets =~ s/\\s*$brackets/g;\n\
    \    return 1;\n}", "    return undef unless $brackets =~ /[<>]/;\n    my $open_bracket\
    \ = 1;\n    my $current_bracket = undef;\n    my $last_bracket = undef;\n    foreach\
    \ my $char (split //, $brackets) {\n        next if $char eq \"<\";\n        return\
    \ 1 if $char != \">\";\n        my $is_open = substr($char, 0, 1) eq \"<\";\n\
    \        my $is_close = substr($char, 0, 1) eq \">\";\n        next if $is_open\
    \ && $current_bracket && $current_bracket eq $is_close;\n        if ($current_bracket\
    \ == $is_close) {\n            $current_bracket = undef;\n        }\n        elsif\
    \ ($is_open && $is_close) {\n            $open_bracket = 0;\n        }\n     \
    \   elsif ($is_open) {\n            $open_bracket++;\n            $current_bracket\
    \ = $is_close;\n        }\n        elsif ($is_close) {\n            $open_bracket--;\n\
    \        }\n    }\n    return !$open_bracket;\n}", "    my(@open_brackets);\n\
    \    my(@closed_brackets);", "    my $i = 0;\n    while ($i <= length($brackets))\
    \ {\n        my($c) = $brackets[$i];\n        if ($c eq \"<\") {\n           \
    \ my $next_c = substr($brackets, $i + 1, 1);\n            $i++;\n            unless\
    \ ($next_c eq \">\") {\n                return undef;\n            }\n       \
    \     my $new_open = substr($brackets, 0, $i);\n            $i++;\n          \
    \  my $new_close = substr($brackets, $i, 1);\n            $i++;\n            $brackets\
    \ = $new_open . $new_close;\n        }\n        $i++;\n    }\n    return 1;\n}",
  "    my(@stack)      = ($brackets, $brackets );\n    my $result = \"\";\n    while\
    \ (my($opening, $closing) = splice(@stack, 0, 2)) {\n        if ($opening eq $closing)\
    \ {\n            $result .= $opening;\n        }\n        else {\n           \
    \ $result .= $closing;\n        }\n    }\n    return $result != $brackets ? 1\
    \ : 0;\n}", "    $brackets =~ s/^<//;\n    $brackets =~ s/^>//;\n    $brackets\
    \ =~ s/^/>/>;\n    $brackets =~ s/>/</g;\n    $brackets =~ s/<\\//\\</g;\n   \
    \ $brackets =~ s/\\</>/;\n    return $brackets;\n}", "    my $count = 0;\n   \
    \ for (split /<|>/, $brackets) {\n        $count += $count++ if $_ eq '<';\n \
    \   }\n    return $count ? $count : 0;\n}", "    $brackets =~ s/^>//;\n    $brackets\
    \ =~ s/<$/]/g;\n    return $brackets =~ s/^\\[//;\n}", "    $brackets =~ s/<\\\
    ([^>]*\\)>/<$1/g;\n    $brackets =~ s/<[^<>]*>//g;\n    return $brackets;\n}",
  "    $brackets =~ s/^<\\</$brackets$brackets$brackets<\\$|<\\/>//sg;\n    $brackets\
    \ =~ s/^>\\</$brackets<\\$|<\\/>$brackets\\$>//sg;\n    return $brackets eq \"\
    <$brackets>\" ? 1 : \"\";\n}", "    my @opening_brackets = split \"[<>]\", $brackets;\n\
    \    my $opening_bracket = \"\";\n    my $closing_bracket = \"\";\n    my $success\
    \ = 0;\n    \n    foreach my $opening_bracket(@opening_brackets) {\n        if\
    \ ($opening_bracket eq $closing_bracket) {\n            $success = 1;\n      \
    \      last;\n        }\n        else {\n            my $last_bracket = $closing_bracket;\n\
    \            $last_bracket =~ s/^<//;\n            $last_bracket =~ s/>$//;\n\
    \            my $new_closing_bracket = $last_bracket;\n            $closing_bracket\
    \ = $new_closing_bracket;\n        }\n    }\n    return $success;\n}", '    my
    @stack = ();', "    return $brackets =~ s/<<<$//g;\n}", "    return undef unless\
    \ $brackets =~ s/^<+|\\>+$//g;\n    return 0 if $brackets =~ s/^<+|\\>+$//;\n\
    \    return 1;\n}", "    return 1 if $brackets =~ /^</;\n    return 0 if ($brackets\
    \ =~ /^>/);\n    my $closing = $brackets =~ /^>/;\n    $closing += 1 if $brackets\
    \ =~ /^</;\n    return 0 if ($closing == 0 && $brackets =~ /^>/);\n    my $opening\
    \ = $brackets =~ /^</;\n    $opening += 1 if $brackets =~ /^<\\>/;\n    return\
    \ 0 if ($opening == 0 && $brackets =~ /^<\\>/);\n    return 1;\n}", "    $brackets\
    \ =~ s/^<(/\"\"/;\n    $brackets =~ s/>$/\"/;\n    return $brackets =~ /^<[^>]+>$/s;\n\
    }", "    my $level = 0;\n    my $stack = 0;\n    $stack = substr($brackets, 0,\
    \ 1);\n    my $last = $stack;\n    $level = 0;\n    for (my $i = 1; $i <= length($brackets);\
    \ $i++) {\n        if ($brackets[$i] eq '<') {\n            $level++;\n      \
    \  }\n        if ($brackets[$i] eq '>') {\n            $level--;\n        }\n\
    \        if ($level != 0) {\n            if ($last ne '>') {\n               \
    \ $stack .= '>';\n            }\n        }\n        $last = $brackets[$i];\n \
    \   }\n    return $stack;\n}", "    return 1 unless $brackets =~ /^<.*?>$/s;\n\
    \    my @stack = ();\n    my $open = 0;\n    my $close = 0;\n    for ($brackets)\
    \ {\n        if ($open && $close && $open eq $close) {\n            push @stack,\
    \ $open;\n        }\n        elsif ($open eq $close) {\n            push @stack,\
    \ $open;\n            $open = 0;\n        }\n        elsif ($open && !$close &&\
    \ $open eq \"<\") {\n            $open++;\n        }\n        elsif ($close &&\
    \ $close eq \">\") {\n            $close++;\n        }\n        elsif ($open &&\
    \ !$close && $open eq \">\") {\n            $open--;\n        }\n        elsif\
    \ ($close && !$open && $close eq \"<\") {\n            $close--;\n        }\n\
    \        elsif (!$open && !$close) {\n            push @stack, $open;\n      \
    \      $open = 0;\n            $close = 0;\n        }\n        elsif ($open &&\
    \ !$close && !$open eq $close && !$close eq $open) {\n            push @stack,\
    \ $open;\n            $open = 0;\n            $close = 0;\n        }\n    }\n\
    \    return @stack;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=python,regex |>\n\
    I like's answer but wanted to offer another way of doing it using regular expressions.\
    \  I only post this as an alternative answer because I want to show how regular\
    \ expressions could be used to solve this problem as well as offer an alternative\
    \ solution.\n<code>\nimport re\ns = '<>'\na = re.findall(r'<[^>]+>', s)\nb = re.findall(r'[^<>]+>',\
    \ s)\nprint a\nprint b\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nThis is\
    \ a bit tricky because you have two opening brackets on the same line. Here's\
    \ the solution:\n<code>\ndef find_brackets(string):\n    open_count = 0\n    close_count\
    \ = 0", '    my $stack = 0;', "    $brackets =~ s/<\\/?[^<> ]*>//g;\n    my $open_brackets\
    \ = $brackets =~ s/<([^>]*)/$1/sg;\n    return unless $open_brackets > 0;\n  \
    \  return 1 if $open_brackets == $brackets;\n    my $closing_brackets = $brackets\
    \ =~ s/^<(.*?)>$/\\1/g;\n    return 1 if $closing_brackets > 0;\n    return 0;\n\
    }", "    # Return empty string if only one opening bracket is given.\n    return\
    \ $brackets eq '<' ? '' : 1 unless $brackets =~ /\\A<(.*?)>\\Z/s;\n    # Initialize\
    \ $result to 0.\n    my $result = 0;\n    # Iterate over each opening bracket.\n\
    \    my $open = $1;\n    while ($brackets =~ /\\A<$open\\s*(.*?)\\s*>\\Z/s) {\n\
    \        # Increment $result if closing bracket is found.\n        last if $1\
    \ !~ /\\A<$open\\Z/;\n        $result = 1 if ($brackets =~ /\\A<$open\\Z/s);\n\
    \        $brackets = substr($brackets, 0, length($open)) . $open;\n    }\n   \
    \ return $result;\n}", "    my(@stack) = ();\n    my($result) = 0;\n    \n   \
    \ foreach my $b (split \"()\", $brackets) {\n        if (($result || !$stack[$#stack])\
    \ \n            && $b eq '('\n        ) {\n            $stack[$#stack]++;\n  \
    \      }\n        elsif (($result || !$stack[$#stack]) \n            && $b eq\
    \ ')'\n        ) {\n            $stack[$#stack]--;\n        }\n        elsif ($stack[$#stack]\
    \ == 0) {\n            ($result)++ if $b eq '<';\n            $stack[$#stack]\
    \ = 1;\n        }\n        elsif ($stack[$#stack] == 1) {\n            ($result)++\
    \ if $b eq '>';\n        }\n        else {\n            $result++;\n        }\n\
    \    }\n    return $result || '';\n}", "    my($ret);\n    my($opened,$closed);\n\
    \    my $idx = 0;\n    while($idx < length($brackets)){\n        if($brackets\
    \ eq '<<' ||  $brackets eq '>>' ||\n           $brackets eq '<<' ||  $brackets\
    \ eq \">>>' ||\n           $brackets eq '<?>' ||  $brackets eq '<???>'){\n   \
    \         $opened = $brackets;\n            $ret .= $brackets;\n        }elsif($brackets\
    \ eq '<>'){\n            $opened = '<<';\n            $ret .= '<<';\n        }else{\n\
    \            push(@opened,$brackets);\n        }\n        last if($idx >= length($brackets));\n\
    \        $brackets = substr($brackets,$idx);\n        $idx++;\n    }\n    foreach\
    \ my $opened (@opened){\n        if(!grep {$_ =~ /$opened/} @closed){\n      \
    \      $ret .= $opened;\n        }\n    }\n    if(!$ret){\n        $ret = '';\n\
    \    }else{\n        $ret = 1;\n    }\n    return $ret;\n}", "    $brackets =~\
    \ s/^<<>$//;\n    $brackets =~ s/^(<)$/$1<<>/;\n    $brackets =~ s/$<<>(>)$/\\\
    1>>/;\n    return $brackets;\n}", "    my $i;\n    my $open_brackets = 0;\n  \
    \  my $next_bracket = undef;", "    my(@opening_brackets);\n    my(@closing_brackets);\n\
    \    my($opening_bracket, @closing_bracket);", "    $brackets =~ s/^<<//;\n  \
    \  $brackets =~ s/>>$//;\n    return $brackets =~ /^[<>]+$/;\n}", "    my $i =\
    \ 0;\n    while($i < length($brackets)) {\n        my $open_bracket = $brackets[$i];\n\
    \        my $close_bracket = $brackets[$i+1];\n        $i += 2;\n        my $next_open_bracket\
    \ = $brackets[$i];\n        $i += 2;\n        if($open_bracket eq $next_open_bracket)\
    \ {\n            if($open_bracket eq \"<\") {\n                return $close_bracket\
    \ eq \"<\";\n            } else {\n                return 1;\n            }\n\
    \        } else { # $open_bracket > $next_open_bracket\n            return 1;\n\
    \        }\n    }\n    return 1;\n}", "    return undef unless defined $brackets;\n\
    \    return undef if $brackets =~ /[\\<\\>]/g;\n    my @brackets = split /[<>]/,\
    \ $brackets;\n    my @pairs = ();\n    foreach my $pair (@brackets) {\n      \
    \  next unless $pair !~ /^(<|>)$/g;\n        push @pairs, $pair;\n    }\n    return\
    \ undef unless @pairs == 2;\n    my $start = shift @pairs;\n    my $end = shift\
    \ @pairs;\n    my $first = $start =~ /^(<|>)$/g;\n    my $last = $end =~ /^(<|>)$/g;\n\
    \    return undef if $first && $last;\n    return $start =~ /^\\(/g;\n    return\
    \ $end =~ /^\\)$/g;\n}", "    # remove all whitespace\n    $brackets =~ s/\\s+//g;",
  "    $brackets =~ s/<([^<>]*\\<[^<>]*)\\>/\\1/g;\n    return $brackets;\n}", '    my
    @stack = ();', "    return 1 unless $brackets =~ /\\A<(?(1)>|\\Z)/;\n    $brackets\
    \ =~ s/^<//;\n    $brackets =~ s/>$//;\n    return $brackets eq '<>' ? '' : $brackets;\n\
    }", "    my($open_brackets, $open_brackets_count) = \"\";\n    my($closed_brackets,\
    \ $closed_brackets_count) = \"\";", "    $brackets =~ tr/[]<>()<>]/{}[]/g;\n \
    \   $brackets =~ tr/{}[]()<>]/<>{}/g;\n    $brackets =~ tr/<>/{}[]()<>]/g;\n \
    \   $brackets =~ tr/{}[]/[]<>{}/g;\n    $brackets =~ tr/[]<>{}()/{}[]/g;\n   \
    \ $brackets =~ tr/<>/[]<>/g;\n    return $brackets =~ tr/[{}()<>]/[]/g;\n}", " \
    \   # count the opening brackets\n    my $num_opens = $brackets =~ s/^[ <]+//g;\n\
    \    # count the closing brackets\n    my $num_closes = $brackets =~ s/^[>]+//g;\n\
    \    # return false if there is a mismatched bracket\n    return 0 if ($num_opens\
    \ != $num_closes)\n}", "    my $count = 1;\n    my $open;\n    my $close;\n  \
    \  my $last_open;", "    my($open_brackets);\n    my($closed_brackets);", "  \
    \  $brackets =~ s/<//g;\n    $brackets =~ s/>//g;\n    return $brackets =~ s/^[]+//;\n\
    }", "    $brackets =~ tr/[<>]//d;\n    return 1 if $brackets eq \"\";\n    return\
    \ 1 if $brackets =~ m{(<)}x;\n    return 1 if $brackets =~ m{(>)}x;\n    return\
    \ 1 if $brackets =~ m{(<<)}x;\n    return 1 if $brackets =~ m{(>>)}x;\n    return\
    \ 1;\n}", "    my(@open_parens) = ();\n    my(@close_parens) = ();\n    my(@open_brackets)\
    \ = ();\n    my(@close_brackets) = ();", "    my $open = qr{\n        (?:\n  \
    \          (\n                (?: [^>]+ \\. \\. )\n                |\n       \
    \         (?: [^>]+ \\. \\< )\n                |\n                (?: [^>]+ \\\
    < \\. )\n                |\n                (?: [^>]+ \\< \\< )\n            )\n\
    \        )*\n    }x;\n    my $close = qr{\n        (?:\n            (\n      \
    \          (?: [^>]+ \\. \\. )\n                |\n                (?: [^>]+ \\\
    . \\< )\n                |\n                (?: [^>]+ \\< \\. )\n            \
    \    |\n                (?: [^>]+ \\< \\< )\n            )\n        )*\n    }x;\n\
    \    return 1 if $brackets =~ /$open/;\n    return 0 if $brackets =~ /$close/;\n\
    \    return;\n}\n</code>\n<|/ a dscore=4 |>\n<| a tags=perl,regex |>\nIf this\
    \ were my assignment, I'd probably approach it by splitting the string on \"<\
    \ >\".  I'd probably end up with something like this (assuming you aren't using\
    \ HTML):\n<code>\nuse strict;\nuse warnings;", "    return unless ($brackets =~\
    \ /^<(\\[|\\{\\d+\\})>$/);\n    return 1 unless $1 eq '[';\n    my($num) = -1;\n\
    \    if ($1 eq '{') {\n\tmy($brace) = ($2);\n\t++$num;\n    }\n    return $num\
    \ unless ($1 eq '[');\n    $num = -1;\n    if ($1 eq '[') {\n\tmy($brace) = ($2);\n\
    \t++$num;\n    }\n    return $num unless ($1 eq '{');\n    return $num unless\
    \ ($1 eq '<');\n    my $open = ($1);\n    $open =~ s/^<// if $open;\n    $open\
    \ =~ s/>$//;\n    return $num unless $open =~ m/[({\\[<]/;\n    my $close = ($1);\n\
    \    $close =~ s/^>// if $close;\n    $close =~ s/\\z// if $close;\n    $close\
    \ =~ s/[({\\[<]// if $close;\n    return $close;\n}", "    my $count = ();\n \
    \   my $in_brackets = ();\n    my $result = '';\n    foreach my $char (split //,\
    \ $brackets) {\n        if ($char == \">\") {\n            while (!$in_brackets)\
    \ {\n                $result = $char;\n                $in_brackets = !$in_brackets;\n\
    \                $char = $chars[$count++];\n            }\n        } elsif ($char\
    \ == \"<\") {\n            if ($in_brackets) {\n                $result = $char;\n\
    \                $in_brackets = !$in_brackets;\n            }\n        }\n   \
    \ }\n    return $result;\n}", "    chomp($brackets);\n    my @brackets = split(//,\
    \ $brackets);\n    my $num_open = 0;\n    my $num_close = 0;\n    foreach (@brackets)\
    \ {\n        my $is_open = 0;\n        if ($_ eq \"<\") { $is_open = 1; $num_open\
    \ += 1 }\n        if ($_ eq \">\") { $is_open = 1; $num_close += 1 }\n       \
    \ if ($_ eq \"<>\") { $is_open = 1; $num_close += 1 }\n        if ($_ eq \"<>\"\
    ) { $is_open = 1; $num_open += 1 }\n        if ($_ eq \"<<>\") { $is_open = 1;\
    \ $num_close += 1 }\n        if ($_ eq \">>>\") { $is_open = 1; $num_open += 1\
    \ }\n        if ($_ eq \"<<\") { $is_open = 1; $num_close += 1 }\n        if ($_\
    \ eq \"<<<\") { $is_open = 1; $num_open += 1 }\n        if ($_ eq \">>>\") { $is_open\
    \ = 1; $num_close += 1 }\n        if ($_ eq \"><\") { $is_open = 1; $num_open\
    \ += 1 }\n        if ($_ eq \"<<\") { $is_open = 1; $num_open += 1 }\n    }\n\
    \    return $num_open eq $num_close;\n}", "    my @stack = ();\n    $brackets\
    \ =~ s/^&//g;\n    while ($brackets =~ /[^<>]+/g) {\n        push @stack, pop(@stack);\n\
    \        push @stack, $1;\n    }\n    my $has_closing = 0;\n    while ($brackets\
    \ =~ s/<([^<>]+)/$1</g) {\n        next unless defined $1;\n        $has_closing\
    \ = 1 if ($stack[-1] eq '>');\n        push @stack, $1;\n    }\n    my $result\
    \ = \"\";\n    while ($stack[-1] ne '>') {\n        $result = $stack[-1] . $result;\n\
    \        pop @stack;\n    }\n    return $has_closing ? $result : \"\";\n}", " \
    \   my($open_bracket) = \"\";\n    my($match);", "    my($open_count) = substr\
    \ $brackets, 0, 1;\n    my($close_count) = substr $brackets, 1, 0;\n    my($result)\
    \ =  $open_count == $close_count ? 1 : 0;\n    $result ? $result : $brackets;\n\
    }", "    my $result = \"\";\n    for my $char (split //, $brackets) {\n      \
    \  if ($char eq '<') {\n            $result .= '>';\n        } elsif ($char eq\
    \ '>') {\n            $result .= \"<\";\n        } else {\n            $result\
    \ .= $char;\n        }\n    }\n    return $result;\n}", "    return 1 unless $brackets\
    \ =~ /\\A\\[/; # <\n    return 1 unless $brackets =~ /\\A\\]/; # >\n    return\
    \ 1 unless $brackets =~ /\\A\\{/; # {\n    return 1 unless $brackets =~ /\\A\\\
    }/; # }\n    return 1 unless $brackets =~ /\\A\\[<\\]/; # <<\n    return 1 unless\
    \ $brackets =~ /\\A\\]\\>/; # >>\n    return 1 unless $brackets =~ /\\A\\{<\\\
    ]/; # <<<\n    return 1 unless $brackets =~ /\\A\\}\\/;  # >><\n    return 1;\n\
    }", "    my $open_brackets = 0;\n    my $closed_brackets = 0;\n    $brackets =~\
    \ s/<[^>]*>/|/g;\n    while ($brackets =~ s/(<[^>]*>)//) {\n        $closed_brackets++;\n\
    \        $open_brackets++;\n    }\n    return $open_brackets == $closed_brackets;\n\
    }", "    my @correct = map { /^([<>])+$/ ? $1 : \"\" } @{$brackets};\n    return\
    \ @correct == 0 ? \"\" :\n\t   @correct == 1 ?\n\t       shift(@correct) : # single\
    \ bracket\n\t       join(\"\", @correct);\n}", "    my $new_brackets = \"\";\n\
    \    my $num_open_brackets = 0;\n    foreach my $i (0 .. length($brackets)) {\n\
    \        my $c = substr($brackets, $i, 1);\n        next if $c eq \"<\";\n   \
    \     $num_open_brackets++;\n        my $close_found = 0;\n        foreach my\
    \ $j (0 .. length($brackets)) {\n            my $opening_bracket = substr($brackets,\
    \ $j, 1);\n            next unless $opening_bracket eq $c;\n            if ($close_found)\
    \ {\n                if ($num_open_brackets == 2) {\n                    $new_brackets\
    \ .= \" \";\n                } else {\n                    $new_brackets .= \"\
    <\";\n                }\n            }\n            $num_open_brackets--;\n  \
    \          $close_found = 1;\n        }\n        $new_brackets .= \">\";\n   \
    \ }\n    return $new_brackets;\n}", "    my(@opening, @closing);\n    \n    #\
    \ Split into pairs of opening and closing brackets.\n    push(@opening, $brackets)\
    \ while $brackets =~ /\\<([^\\>]*)\\>/;\n    push(@closing, $brackets) while $brackets\
    \ =~ /\\>([^\\<]*)\\</;\n    \n    # Close any unmatched brackets.\n    while\
    \ (@opening > 1) {\n        my($open) = pop(@opening);\n        push(@closing,\
    \ $open) if !$closing || !grep($close =~ /^$open/, @closing);\n    }\n    \n \
    \   return 1 unless @closing;\n    return 1 if (@closing == 1);\n    \n    my\
    \ $close = shift(@closing);\n    $close =~ s/\\</</;\n    $close =~ s/\\>/>/;\n\
    \    return 0 if ($close =~ /^<<<$/);\n    return 1 if ($close =~ /^>>>>$/);\n\
    \    return 1;\n}", "    my $is_closed = 1;\n    for my $index (0..$#{$brackets}\
    \ - 1) {\n        if ($brackets->[$index] !~ /\\<\\>/) {\n            $is_closed\
    \ = 0;\n            last;\n        }\n    }\n    return $is_closed ? \"\" : \"\
    1\";\n}", "    my(@bracketed) = ();\n    \n    foreach $bracket_pair (split(/[<>]+/,\
    \ $brackets)) {\n        push(@bracketed, ($bracket_pair =~ /^<(.*)>$/) ? $1 :\
    \ \"\\l$bracket_pair\");\n    }\n    \n    return @bracketed == 0 ? \"\" : scalar(@bracketed)\
    \ == 1 ? $bracketed[0] : 1;\n}", "    my($match) = 0;\n    for(my $i = 0; $i <\
    \ length($brackets); $i++) {\n        if ($brackets[$i] eq \"<\") {\n        \
    \    $match = $match ? 0 : 1;\n        } elsif ($brackets[$i] eq \">\") {\n  \
    \          $match = $match ? 1 : 0;\n        }\n    }\n    return $match;\n}",
  "    $brackets =~ s/<\\((.*)\\)\\>//g;\n    return unless $brackets =~ /\\S/;\n\
    \    my $correct = 1;\n    if ( $brackets !~ /<\\((.*)\\)>/s ) {\n        $correct\
    \ = 0;\n    }\n    return $correct;\n}", '    $brackets =~ s/^\s*|\s*$//g;', " \
    \   my(@open)    = ();\n    my(@close)   = ();\n    for (my $n = 0; $n <length($brackets);\
    \ $n++) {\n\tmy $bracket = $brackets[$n];\n        if ($bracket =~ /^<\\>/) {\n\
    \            if ($open =~ /^<\\>/) {\n                $open = $bracket;\n    \
    \            next;\n            }\n            $open = $bracket;\n        } elsif\
    \ ($bracket =~ /^>\\>/) {\n            if ($close =~ /^>\\>/) {\n            \
    \    $close = $bracket;\n                next;\n            }\n            $close\
    \ = $bracket;\n        } else {\n            $open = $open;\n        }\n    }\n\
    \    if (length $close != 0) {\n\treturn 1;\n    }\n    return \"\";\n}", "  \
    \  $brackets =~ s/^<//; # remove opening bracket\n    $brackets =~ s/^>//; # remove\
    \ closing bracket\n    return $brackets =~ s/<([<>])>//; # remove both brackets\n\
    }", '    my($bracket_count) = 0;', "    return 0 unless $brackets =~ /<(\\/)?>/g;\n\
    \    return 1 if ($1 !~ /[<>]/g);", "    my $count = 0;\n    foreach my $b (split\
    \ /[\\<\\>]/, $brackets) {\n        $count++ if $b eq '<';\n        $count-- if\
    \ $b eq '>';\n    }\n    return $count <= 0;\n}", "    # Make sure there are some\
    \ brackets.\n    return \"\"\n\tif (length($brackets) < 1);", "    my @brackets\
    \ = split /[<>]/, $brackets;\n    for my $i ( 0 .. $#brackets ) {\n        my\
    \ $opener = $brackets[$i];\n        my $closer = $brackets[$i + 1];\n        if\
    \ ($closer ne '' && $closer ne $opener + 1) {\n            return 1;\n       \
    \ }\n    }\n    return \"\";\n}", '    my($ret);', "    \n    # If the brackets\
    \ don't contain exactly two \"<\" then return \"\".\n    return unless $brackets\
    \ =~ m/<<<$/;\n    \n    # Split the string into opening brackets and closing\
    \ brackets.\n    my(@open_brackets, %open_count) = split /<<<$/, $brackets, 2;\n\
    \    \n    # If there's an opening bracket with no corresponding closing bracket,\n\
    \    # return \"\".\n    shift @open_brackets if shift @open_brackets;\n    \n\
    \    # If there are less than two opening brackets, return \"\".\n    return unless\
    \ @open_brackets >= 2;\n    \n    # Create a dictionary mapping opening brackets\
    \ to opening counts.\n    my %open_brackets;\n    foreach my $bracket (@open_brackets)\
    \ {\n        $open_brackets{$bracket}++;\n    }\n    \n    # Add one to the opening\
    \ count if the opening bracket is \"<<<\".\n    $open_brackets{\"<<<\"}++;\n \
    \   \n    # If there's an unpaired opening bracket, return \"\".\n    return unless\
    \ $open_brackets{\"<<<\"} % 2;\n    \n    # If there are only two brackets, return\
    \ \"\".\n    return unless @open_brackets == 2;\n    \n    # Create the new string.\
    \ Return \"\" if there are no unpaired \"<<<\"s.\n    my($new_string);\n    foreach\
    \ my $pair (keys %open_brackets) {\n        $new_string .= $pair;\n    }\n   \
    \ \n    return $new_string if $new_string !~ m/<<<$/;\n    \n    # Return 1.\n\
    \    return 1;\n}", "    my (@left, @right, @left_stack,\n         @right_stack,\
    \ @right_left_stack) = split '</>', $brackets;\n    for my $left (@left) {\n \
    \       if ($left eq '<') {\n            $left = '<=';\n        } elsif ($left\
    \ eq '>') {\n            $left = '=>';\n        }\n        $left_stack[$#left_stack]\
    \ .= $left;\n    }\n    for my $left (@right) {\n        if ($left eq '<') {\n\
    \            $left = '<=';\n        } elsif ($left eq '>') {\n            $left\
    \ = '=>';\n        }\n        $right_stack[$#right_stack] .= $left;\n    }\n \
    \   for my $left (@left_stack) {\n        for my $right (@right_stack) {\n   \
    \         if ($right =~ /$left/) {\n                $right = '<=' . $right;\n\
    \            } elsif ($right =~ /$left/g) {\n                $right = '=>' . $right;\n\
    \            }\n        }\n    }\n    for my $left (@right_stack) {\n        for\
    \ my $right (@left_stack) {\n            if ($right =~ /$left/) {\n          \
    \      $right = '<=' . $right;\n            } elsif ($right =~ /$left/g) {\n \
    \               $right = '=>' . $right;\n            }\n        }\n    }\n   \
    \ $brackets .= join '</>', @left_stack;\n    $brackets .= join '</>', @right_stack;\n\
    \    return $brackets;\n}\n</code>\n<|/ a tags=perl |>\n<| c |>\n+1 for the detailed\
    \ code. However, I chose the answer by since it deals nicely with nested brackets.\
    \ It doesn't use regexes but does it recursively.\n<|/ c |>\n<| c |>\n: It does\
    \ deal nicely with nested brackets, if you read my code. And it doesn't use regexes,\
    \ it uses simple string comparisons, which are O(N), meaning it's fast (albeit\
    \ slower than regexes) if you're only doing it once. Regexes are useful in other\
    \ situations (see \"regexes are useful\" at http://en.wikipedia.org/wiki/Regular_expression).\
    \ And you accepted his answer, which is more complicated than mine, but also slower.\
    \ I gave you another solution that uses no regexes, but that's not good enough.\n\
    <|/ c |>\n<| c |>\nOh I see. You're right of course. Sorry about that. I was thinking\
    \ of the code as if it was for a general case (i.e. no nested brackets) and not\
    \ for a particular case (i.e. only ", "    my $num_correct = 0;\n    while($brackets\
    \ !~ m/(^|$)<<<>>/) {\n        $num_correct++ if $num_correct < 2;\n        $brackets\
    \ =~ s/(<)(\\W)(>>)$/\\1\\3\\2/;\n    }\n    return $num_correct == 0;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
