name: HumanEval_35_max_element
language: pl
prompt: "# Return maximum element in the array.\n# >>> max_element([1, 2, 3])\n# 3\n\
  # >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n# 123\nsub max_element\
  \ {\n    my($l) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_element;\n\
  \        if(eq_deeply($candidate->([1, 2, 3]),3)) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 3, -5, 2, -3,\
  \ 3, 9, 0, 124, 1, -10]),124)) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n}\n\ntesthumaneval();"
completions: ["    my($h) = @{$l};\n    my $m;\n    for (my $i = 0; $i < @$l; $i++)\
    \ {\n        ($m > $h->[$i]) ? $m = $h->[$i] : $h = $h->[$i];\n    }\n    return\
    \ $m;\n}", "    my $m;\n    my $max = shift;\n    for my $i (0..$#$l)\n    {\n\
    \        if ($l->[$i] > $max)\n        {\n            $m = $l->[$i];\n       \
    \ }\n    }\n    return $max;\n}", "    my $max = @$l > 1 ? $l->[-1] : $l->[0];\n\
    \    for (@$l) {\n        if ($_ > $max) {\n            $max = $_;\n        }\n\
    \    }\n    return $max;\n}", "    my $max = $l->[0];\n    for my $i (1..scalar(@$l))\
    \ {\n        $max = $_ if $l->[$i] > $max;\n    }\n    return $max;\n}", "   \
    \ my $max = @$l > 0 ? $l->[0] : 'undef';\n    for my $element (@$l) {\n      \
    \  if ($element > $max) {\n            $max = $element;\n        }\n    }\n  \
    \  return $max;\n}", "    if (@$l < 1) {\n        return;\n    }\n    for (my\
    \ $i = 0; $i < @$l; $i += 2) {\n        return $l[$i] if $l[$i] > $l[$i + 1];\n\
    \    }\n    return $l[0];\n}", "    my $max_value = 0;\n    my $max_value_pos\
    \ = 0;\n    for (my $i=0; $i<@$l; $i++) {\n        if ($l->[$i] > $max_value)\
    \ {\n            $max_value = $l->[$i];\n            $max_value_pos = $i;\n  \
    \      }\n    }\n    return $l->[$max_value_pos];\n}", "    my($i, $max);\n  \
    \  $max = -1;\n    for ($i = 0; $i < @$l; $i++) {\n        if ($l->[$i] > $max)\
    \ {\n            $max = $l->[$i];\n        }\n    }\n    return $max;\n}", " \
    \   if (scalar @$l == 0) {\n        return undef;\n    }\n    # Return minimum\n\
    \    if ($l->[0] == $l->[-1]) {\n        return $l->[0];\n    }\n    # Return\
    \ maximum\n    my $max = undef;\n    for (my $i = 0; $i < @$l; $i++) {\n     \
    \   if ($l->[$i] >= $l->[$i - 1]) {\n            $max = $l->[$i];\n        }\n\
    \    }\n    return $max;\n}", "    my($max_val) = 0;\n    my($max_el);", "   \
    \ if (@$l == 0) {\n        return undef;\n    }\n    my $max = shift @$l;\n  \
    \  for (@_) {\n        $max = $_ if $_ > $max;\n    }\n    return $max;\n}", " \
    \   my $m = $l->[0];\n    for my $i (1 .. $#$l) {\n        my $cmp = $l->[$i]\
    \ <=> $m;\n        if ($cmp > 0) {\n            $m = $l->[$i];\n        }\n  \
    \  }\n    return $m;\n}", "    my $max = ${$l}[-1];\n    for my $i (reverse @$l)\
    \ {\n        $max = max $i, $max;\n    }\n    return $max;\n}", "    my $max_element\
    \ = $l[0];\n    for my $i (1 .. $#$l) {\n        my $cmp = $l[$i] <=> $max_element;\n\
    \        if ($cmp == 0) {\n            $max_element = $l[$i];\n        }\n   \
    \ }\n    return $max_element;\n}", "    $l->[0] < $l->[-1] ? $l->[0] : $l->[-1];\n\
    }", "    my $max = -1;\n    foreach my $x (@$l) {\n        if ($x > $max) {\n\
    \            $max = $x;\n        }\n    }\n    return $max;\n}", "    my $l =\
    \ ref $l ? @$l : $l;\n    my $len = @$l;\n    if (@$l == 0) {\n        return;\n\
    \    }", "    my $max = @$l > 0 ? $l->[-1] : 0;\n    for my $e (0..$#$l) {\n \
    \       $max = $e if $l->[$e] > $max;\n    }\n    return $max;\n}", "    my($max_value);\n\
    \    my($max_element_idx);", "    my $max = $l->[0];\n    my $j = 0;\n    # Iterate\
    \ over the array...\n    for my $i (0..$#$l) {\n        # ...and compare current\
    \ element with maximum.\n        if ($l->[$i] > $max) {\n            $max = $l->[$i];\n\
    \            $j = $i;\n        }\n    }\n    return $max;\n}", "    return ${$l[0]}\
    \ if @$l == 0;\n    return ${$l[0]} if ${$l[0]} < 0;\n    my $max = $$l[0];\n\
    \    my $i = 1;\n    while ($i < @$l) {\n        my $e = $$l[$i];\n        if\
    \ ($e > $max) {\n            $max = $e;\n        }\n        $i++;\n    }\n   \
    \ return $max;\n}", "    my $n = scalar @$l;\n    my $i;", "    my $result;\n\
    \    my $max = -9999;\n    foreach my $x (@$l) {\n        if ($x > $max) {\n \
    \           $max = $x;\n            $result = $x;\n        }\n    }\n    return\
    \ $result;\n}", "    my $max = -1e9;\n    my ($i, $v);\n    my $len = $#$l;\n\
    \    for (my $i = 0; $i < $len; $i++) {\n        ($v = $l->[$i]) <=> $max > 0\
    \ || $v == $max ? $max : $v;\n    }\n    return $v;\n}", "    my $result = -1;\n\
    \    foreach my $element (@$l) {\n        if ($result < $element) {\n        \
    \    $result = $element;\n        }\n    }\n    return $result;\n}", "    my $max;\n\
    \    $max = @$l > 0 ? @$l : 0;", "    my $ret = $l->[0];\n    my $i = 1; my $j\
    \ = scalar($l) - 1;\n    while ($j >= 0) {\n        last if $l->[$j] > $l->[$i];\n\
    \        $ret = $l->[$j] if $l->[$j] == $l->[$i];\n        $j--;\n    }\n    return\
    \ $ret;\n}", "    my $max;\n    for (my $i = 0; $i < @$l; $i++) {\n        $max\
    \ = $l->[$i] if $l->[$i] > $max;\n    }\n    return $max;\n}", "    my $max =\
    \ -1;\n    foreach my $v (@$l) {\n        $v > $max and $max = $v;\n    }\n  \
    \  return $max;\n}", "    my($i, $max);\n    for(@$l) {\n        $max = $_ if\
    \ $_ > $max;\n    }\n    return $max;\n}\n</code>\nAnd that's it.\n<|/ a tags=perl,arrays,function\
    \ |>\n<| c |>\nThis code only works because of `use strict` and `use warnings`\
    \ which are not included in `List::Util`. If you really want to do it without\
    \ `List::Util` then `my $max = shift while @$l > 0;` is enough and no need for\
    \ `push`.\n<|/ c |>\n<| c |>\nIt's true that `use strict` and `use warnings` are\
    \ not included in `List::Util` but `List::Util::min` and `List::Util::max` are.\n\
    <|/ c |>\n<| c |>\nBut they are. Otherwise the OP's code wouldn't compile either.\
    \ The OP already has `use List::Util` and the functions are `List::Util::max`\
    \ and `List::Util::min` which are documented.\n<|/ c |>\n<| a dscore=2 tags=perl,arrays,function\
    \ |>\n<code>", "    my($max);\n    my $cmp;\n    my $key;", "    my $max = undef;\n\
    \    foreach my $num (@$l) {\n        return $max if $num > $max;\n    }\n   \
    \ return $max;\n}", "    return $l[0] if @$l == 1;\n    my $m = 0;\n    my $v\
    \ = $l[0]; \n    for my $x (@$l) {\n        my $abs = abs($x);\n        if ($abs\
    \ > $m) {\n            $m = $abs;\n            $v = $x;\n        }\n    }\n  \
    \  return $v;\n}", "    my($result) = undef;\n    for(@$l) {\n        if(defined\
    \ $result) { $result = $elem }\n        else { $result = $elem }\n    }\n    return\
    \ $result;\n}\n</cell>\n<text>\nmax_element_index\nFind the index of the maximum\
    \ element in the array.\nReturn the index only if the array is not empty. Otherwise\
    \ return undef.", "    my $m = 0;\n    my $n;\n    my $i = 0;\n    my $x;\n  \
    \  while ($i < @$l && $l->[$i] >= 0) {\n\t$n = $l->[$i];\n\t$i++;\n    }\n   \
    \ $x = $l->[$i];\n    while ($i < @$l) {\n\t$m = $m > $n ? $m : $n;\n\t$n = $l->[$i++];\n\
    \    }\n    return $x;\n}", "    my $result;\n    my $max = $l->[0];\n    for\
    \ my $i ( 1 .. $#{$l} ) {\n        if( $l->[$i] > $max ) {\n            $max =\
    \ $l->[$i];\n        }\n    }\n    return $max;\n}", "    my($max_val) = @_ >\
    \ 1 ? $_[1] : 0;\n    foreach my $x (@$l) {\n        ($x > $max_val) ? $max_val\
    \ = $x : $_;\n    }\n    return $max_val;\n}", "    my $max = ${$l}[0];\n    foreach\
    \ my $i (1 .. $#$l) {\n        my $cmp = ${$l}[$i];\n        if ($cmp > $max)\
    \ {\n            $max = $cmp;\n        }\n    }\n    return $max;\n}", '    return
    $l->[0] if (@$l == 1);', "    $l =~ /^(-?\\d+)$/;\n    return $1 if $1 >= $l->[0]\
    \ and $1 =~ /^(-?\\d+)$/;\n    $l->[0];\n}", "    my $max;\n    foreach my $x\
    \ (@$l) {\n        if (defined $max && $x > $max) { $max = $x; }\n    }\n    return\
    \ $max;\n}", '    my $max = $l->[-1];', "    if (@$l < 2) {\n        return $l[0];\n\
    \    }\n    my $max_value = 0;\n    foreach my $e (@$l) {\n        if ($e > $max_value)\
    \ {\n            $max_value = $e;\n        }\n    }\n    return $max_value;\n}",
  "    my $max = 0;\n    foreach my $num (@$l) {\n        if ($num > $max) {\n   \
    \         $max = $num;\n        }\n    }\n    return $max;\n}", "    my $max_value\
    \ = $l->[0];\n    my $index = 0;\n    for my $value (@$l) {\n        if($value\
    \ > $max_value) {\n            $max_value = $value;\n            $index = $value;\n\
    \        }\n    }\n    return $index;\n}", "    return $l[$#l] if $l && !$l->[-1];\n\
    \    return;\n}", "    my $max = -1;\n    foreach (@$l) {\n        $max = $_ if\
    \ $_ gt $max;\n    }\n    return $max;\n}", "    if (scalar @$l == 0) {\n    \
    \    return;\n    }\n    my($i, $val) = @_;\n    for (my $i = 0; $i < scalar @$l;\
    \ $i++) {\n        if ($val > $l->[$i]) {\n            $i--;\n        }\n    }\n\
    \    return $l->[$i];\n}", "    $l = sort {$a <=> $b} @$l;\n    return pop @$l\
    \ if @$l == 0;\n    $l = @$l > 1 ? $l[-1] : $l[0];\n}", '    my($max_value_ind)
    = -1;', "    my $max = -999999;\n    my $i = 0;\n    for (; $i < @$l; ++$i) {\n\
    \        if ($l->[$i] > $max) {\n            $max = $l->[$i];\n        }\n   \
    \ }\n    return $max;\n}", "    my $max = $l->[0];\n    for my $i (1 .. $#l) {\n\
    \        if ($l->[$i] > $max) {\n            $max = $l->[$i];\n        }\n   \
    \ }\n    return $max;\n}", "    my $max = @$l[0];\n    for (my $i = 1; $i < @$l;\
    \ $i++) {\n        if ($l[$i] > $max) {\n            $max = $l[$i];\n        }\n\
    \    }\n    return $max;\n}", "    my $max_element = undef;\n    my $max;\n  \
    \  my $i = scalar(@$l);\n    for(my $j=0; $j < $i; $j++) {\n        if($l->[$j]\
    \ >= $max && defined $max) {\n            $max_element = $max;\n        }\n  \
    \      $max = $l->[$j];\n    }\n    return $max_element;\n}", "    my $max = $$l[0];\n\
    \    my $max_index = 0;\n    for(my $i = 1; $i < @$l; $i++) {\n        my $elem\
    \ = $$l[$i];\n        if($elem > $max) {\n            $max = $elem;\n        \
    \    $max_index = $i;\n        }\n    }\n    return $max;\n}", "    local $;\n\
    \    my $max = $l[0];\n    for(my $i = 1; $i < @$l; ++$i) {\n        if ($l[$i]\
    \ > $max) {\n            $max = $l[$i];\n        }\n    }\n    return $max;\n}",
  "    my $max = -1;\n    for (@$l) {\n        if ($max == 0) {\n            $max\
    \ = $_;\n        } elsif ($_ > $max) {\n            $max = $_;\n        }\n  \
    \  }\n    return $max;\n}", "    return undef unless @_ > 0;\n    my $n = @$l;\n\
    \    return $l->[0] if @$l == 0;\n    my $max = $l->[0];\n    for(my $i = 1; $i\
    \ < $n; ++$i) {\n        if($l->[$i] > $max) {\n            $max = $l->[$i];\n\
    \        }\n    }\n    return $max;\n}", "    my $max_val = ${$l}[0];\n    for\
    \ my $i (1 .. ${$l}->[0]}) {\n        if (${$l}->[$i] > $max_val) { $max_val =\
    \ ${$l}->[$i]; }\n    }\n    return $max_val;\n}", "    my $max = @$l > 0 ? $l->[-1]\
    \ : 0;\n    @$l == 0 || $max == $l->[-1] ? $max : undef;\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| a tags=perl,arrays |>\nThis can be done using only list comprehensions:\n\
    <code>\nuse 5.12.0;\nuse strict;\nuse warnings;\nuse Data::Dumper;", "    $l =\
    \ @$l if ref($l) ne 'ARRAY';\n    my $largest = $l->[0];\n    for my $i (1..$#$l)\
    \ {\n        if ($l->[$i] > $largest) {\n            $largest = $l->[$i];\n  \
    \      }\n    }\n    return $largest;\n}", "    my $max = $l[0];\n    foreach\
    \ my $item (@$l) {\n        if ($item > $max) {\n            $max = $item;\n \
    \       }\n    }\n    return $max;\n}", "    return $l if @$l == 0;\n    @$l =\
    \ sort @$l;\n    return $l[0];\n}", "    my $max = -1;\n    for my $i (0 .. $#$l)\
    \ {\n        if ($l->[$i] > $max) {\n            $max = $l->[$i];\n        }\n\
    \    }\n    return $max;\n}", "    my($max);\n    foreach my $i (0..$#$l) {\n\
    \        $max = $i if ($l->[$i] > $l->[$max] or ($l->[$i] == $l->[$max] and !$i));\n\
    \    }\n    return $max;\n}", '    return undef unless @_ > 0;', "    my $max_element\
    \ = $l->[0];\n    $max_element\n        if (@$l > 1);\n    for my $i (@$l) {\n\
    \        if ($i > $max_element) {\n            $max_element = $i;\n        }\n\
    \    }\n    $max_element\n}", "    my($max) = undef;\n    foreach my $elem (@$l)\
    \ {\n        return $max if defined $max and $elem > $max;\n        $max = $elem;\n\
    \    }\n    return $max;\n}\n</code>\n<|/ a tags=perl,algorithm |>\n<| c |>\n\
    I knew that there would be a more elegant way to write it. I was just curious\
    \ how it could be done.\n<|/ c |>\n<| c |>\nThis solution is far more efficient\
    \ than the one I posted, because it is O(1), while my solution has O(N) time complexity.\
    \ Also, mine avoids sorting while this one is sorting. Also, mine has O(n) time\
    \ complexity, whereas your solution has O(n log(n)) time complexity. Yet another\
    \ reason why this one is better than my solution in terms of speed!\n<|/ c |>\n\
    <| a dscore=2 |>\n<code>", "    my $min = @$l > 0 ? $l[0] : 0;\n    my $max =\
    \ @$l > 0 ? $l[0] : 0;\n    my $index;\n    for (my $i = 1; $i <= @$l; $i++) {\n\
    \        my $elem = $l[$i];\n        if ($elem > $max) {\n            $max = $elem;\n\
    \            $index = $i;\n        }\n        if ($elem < $min) {\n          \
    \  $min = $elem;\n        }\n    }\n    return $l[$index];\n}", "    my($max)\
    \ = 0;\n    my($index) = -1;\n    for(my $i=0;$i<@$l;$i++) {\n        if ($l->[$i]\
    \ > $max) {\n            $max = $l->[$i];\n            $index = $i;\n        }\n\
    \    }\n    return $l->[$index];\n}", "    my @max = ();\n    my $max;", "   \
    \ my $result = $l->[0];\n    foreach (@$l) {\n        if ($result > $_) {\n  \
    \          $result = $_;\n        }\n    }\n    return $result;\n}", "    $l->[scalar(@$l)\
    \ - 1] if @$l > 0;\n}", "    my $max = 0;\n    foreach my $n (@$l) {\n       \
    \ if ($n < $max) {\n            $max = $n;\n        }\n    }\n    return $max;\n\
    }", "    my $max;\n    for (my $i = $l->[-1]; $i >= 0; $i--) {\n        $max =\
    \ $i\n            if $max < $l->[$i];\n    }\n    $max;\n}\n</code>\n<|/ a dscore=3\
    \ tags=perl,algorithm,arrays |>\n<| c |>\nJust a note, this is O(N^2) algorithm.\
    \ [TimSort](http://en.wikipedia.org/wiki/Timsort) can be used for O(N log N) algorithm.\n\
    <|/ c |>\n<| c |>\n: I guess TimSort can be used for O(N log N) as well. At least\
    \ [Wikipedia has O(N log N) example](https://en.wikipedia.org/wiki/Timsort#O(N.logN))\n\
    <|/ c |>\n<| c |>\nTimSort is *O(N log N)* - it runs in *O(N log N)* in average\
    \ case, but *O(N)* worst case.\n<|/ c |>\n<| a dscore=3 |>\nIn Perl 5.10+, the\
    \ easiest way to find the highest or lowest value in an array is to use the List::Util::max\
    \ and List::Util::min functions:\n<code>\nuse List::Util qw(min max);\nmy = map\
    \ $_ * 10, 1..10;\nmy $max = max(@arr);\nmy $min = min(@arr);\n</code>\n<|/ a\
    \ tags=perl,algorithm,arrays |>\n<| a dscore=2 tags=perl,algorithm,arrays |>\n\
    You might try using a hash, and a loop like this to do a linear search in it.\n\
    <code>", "    $l->[0] if @$l > 1;\n    $l->[-1] if @$l == 0;\n}", "    my $max\
    \ = @$l < 1 ? 0 : $l->[0];\n    foreach my $e ($l->[1..$#$l]) {\n        my $emax\
    \ = @$e < 1 ? 0 : $e->[0];\n        $max = $emax if $emax > $max;\n    }\n   \
    \ return $max;\n}", "    my($m) =;\n    my($max);\n    my($i);\n    my($j);\n\
    \    for ($i = 0; $i < @$l; $i++) {\n        $max = $l->[$i] if $l->[$i] > $max;\n\
    \    }\n    for ($i = 0; $i < @$m; $i++) {\n        $max = $l->[$i] if $m->[$i]\
    \ > $max;\n    }\n    return $max;\n}", "    my $min = $l->[0];\n    my $max =\
    \ $l->[0];\n    my $i;\n    for my $i (1..$l->[0]) {\n        if ($l->[$i] > $max)\
    \ {\n            $max = $l->[$i];\n        }\n        if ($l->[$i] < $min) {\n\
    \            $min = $l->[$i];\n        }\n    }\n    return $min;\n}", "    my\
    \ $max = -1;\n    my $maxval;\n    foreach my $x (@$l) {\n        if ($x > $max)\
    \ {\n            $max = $x;\n            $maxval = $x;\n        }\n    }\n   \
    \ $maxval;\n}", "    my($h);\n    for(my $i = 0; $i < @$l; ++$i) {\n        if($h\
    \ || $l->[$i] > $l->[$i - 1]) {\n            $h = $l->[$i];\n        }\n    }\n\
    \    return $h;\n}", "    my $s = $l->[0];\n    for (my $i = 1; $i < @$l; ++$i)\
    \ {\n        if ($l->[$i] > $s) {\n            $s = $l->[$i];\n        }\n   \
    \ }\n    return $s;\n}", "    my($max) = undef;\n    foreach my $x (@$l) {\n \
    \       if(defined $max) {\n            if($x > $max) {\n                $max\
    \ = $x;\n            }\n        } else {\n            $max = $x;\n        }\n\
    \    }\n    return $max;\n}", "    my $max = @$l > 0 ? $l->[-1] : 0;\n    return\
    \ $max;\n}", "    my $a = $l->[0];\n    foreach my $i (1 .. @$l - 1) {\n     \
    \   $a = $a if $l->[$i] > $a;\n    }\n    return $a;\n}", "    my $max_el = $l->[0];\n\
    \    for my $e ($l->[1]) {\n        if ($e > $max_el) {\n            $max_el =\
    \ $e;\n        }\n    }\n    return $max_el;\n}", "    my $max = 0;\n    my $i;",
  '    my $max = $l->[0];', "    $l == 0 or $l > $l[-1] ? $l[-1] : $l[-1];\n}", " \
    \   my $max = undef;\n    my $i = 0;\n    foreach my $v (@_) {\n        $max =\
    \ $v if $max < $v || !defined($max);\n        $i++;\n    }\n    return $max if\
    \ $max;\n    return undef;\n}", "    my($max);\n    my($i) = 0;\n    foreach my\
    \ $el (@{$l}) {\n        return $max if $max < $el;\n        $max = $el;\n   \
    \ }\n    return $max;\n}", "    my $max = $l->[0];\n    foreach my $i (@$l) {\n\
    \        $max = $i if $i > $max;\n    }\n    return $max;\n}\n</code>\n<|/ a tags=perl\
    \ |>\n<| a tags=perl |>\n<code>\nperl -M5.010 -ne 'print scalar@F'\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\n`perl -M5.010 -ne 'print scalar <>'`\n<|/ c |>\n<|\
    \ c |>\n`perl -M5.010 -ne 'print scalar <>'`\n<|/ c |>\n<| a dscore=4 tags=perl\
    \ |>\nHow about sort and last?\n<code>\n$ cat data\n1\n2\n3\n4", '    my ($max,
    $max_index);', "    my($max) = 0;\n    my($max) = $l->[0];\n    foreach $e ( @$l\
    \ ) {\n        if( $e > $max ) {\n            $max = $e;\n        }\n    }\n \
    \   return $max;\n}", "    my $n = @$l;\n    for my $i (0..$n-1) {\n        if\
    \ ($l->[$i] > $l->[$i+1]) {\n            $l->[$i] = $l->[$i+1];\n        }\n \
    \   }\n    return $l->[0];\n}", "    my $min_val = $l->[0];\n    my $max_val =\
    \ $l->[0];\n    for my $x (@$l) {\n        if ($x > $min_val) { $min_val = $x;\
    \ }\n        if ($x < $max_val) { $max_val = $x; }\n    }\n    $max_val;\n}",
  '    my($max);', "    if (@$l == 0) {\n        $l[0] = $l[0] if @$l > 0;\n    }\
    \ else {\n        $l[0] = $l[0] > $l[1] and $l[0] or $l[1];\n    }\n    @$l >\
    \ 1 ? $l[1] : 0;\n}", "    if (scalar @$l < 2) {\n        return;\n    }\n   \
    \ my $max = shift @$l;\n    if ($max < 0) {\n        shift @$l;\n        $max\
    \ = shift @$l;\n    }\n    for (my $i = scalar @$l - 1; $i >= 0; $i--) {\n   \
    \     if ($max->[0] < $l->[$i]) {\n            $max->[0] = $l->[$i];\n       \
    \     $max->[1] = $i;\n        }\n    }\n    return $max->[0];\n}", '    my $max
    = 0;', "    $l =~ s/^\\s*//;\n    if ( @$l > 0 ) {\n        my $max = @$l > 1\
    \ ? $l->[-1] : 0;\n        for my $elem (@$l) {\n            if ($elem > $max)\
    \ {\n                $max = $elem;\n            }\n        }\n        return $max;\n\
    \    }\n    return 0;\n}", "    my $m = $l[0];\n    foreach my $n (@$l) {\n  \
    \      if ($n >= $m) {\n            $m = $n;\n        }\n    }\n    return $m;\n\
    }", "    my $m = $l->[0];\n    for my $i (1..$#$l) {\n        $m = ($l->[$i] >=\
    \ $m) ? $l->[$i] : $m;\n    }\n    return $m;\n}", "    my $max_val;\n    my $max_index;\n\
    \    for (my $i = 0; $i < @$l; $i++) {\n        if (defined $max_val) {\n    \
    \        if ($l->[$i] >= $max_val) {\n                $max_val = $l->[$i];\n \
    \               $max_index = $i;\n            }\n        } else {\n          \
    \  $max_val = $l->[$i];\n            $max_index = $i;\n        }\n    }\n    return\
    \ $l->[$max_index];\n}", "    $l =~ m/([-+]?\\d+)/g;\n    my $max = pop(@{$l});\n\
    \    foreach my $elem (@$l) {\n        if ($elem > $max) {\n            $max =\
    \ $elem;\n        }\n    }\n    return $max;\n}", "    return $l[0] if @$l ==\
    \ 1;\n    return $l[0] if @$l == 0;\n    my $s = $l[0] > $l[1] ? $l[0] : $l[1];\n\
    \    for my $i (1 .. @$l - 1) {\n        if ($l[$i] >= $s) {\n            $s =\
    \ $l[$i];\n        }\n    }\n    return $s;\n}", "    my $max = undef;\n    my\
    \ $max = grep { $_ gt $max } @$l;\n    return $max unless defined $max;\n    return\
    \ $l->[0] if @$l == 1;\n    return $max;\n}", '    $l->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]->[0]',
  "    $l =~ m/(.*)((?:[+-]?\\d*|nan|inf)\\s*(?:,\\s*))?/;\n    return $1 if ($2 eq\
    \ '');\n    return $1 if $1 eq '';\n    my @a = $2 eq 'inf' ? @INF :\n       \
    \ $2 eq 'nan' ? @NAN : map { $_ > $_ ? $_ : 'inf'};\n    return $a[0] if @a >\
    \ 1;\n    return $a[0];\n}", "    my $max = $l->[0];\n    my $max = ref $max eq\
    \ 'ARRAY' ? $max->[0] : $max;\n    for my $i (1 .. @$l) {\n        my $tmp = $l->[$i];\n\
    \        my $tmpref = ref $tmp eq 'ARRAY' ? $tmp->[0] : $tmp;\n        if ($tmpref\
    \ > $max) {\n            $max = $tmpref;\n        }\n    }\n    return $max;\n\
    }", "    return $l->[0] if @$l < 2;\n    my(@m) = (@$l);\n    return $m[0] if\
    \ @m < 2;", "    my $max = $l->[0] if @$l > 0;\n    for (@$l) {\n        if ($_\
    \ > $max) {\n            $max = $_;\n        }\n    }\n    return $max;\n}", " \
    \   my $max = $l->[0];\n    for (my $i = 1; $i <= $#l; $i++) {\n        if ($l->[$i]\
    \ > $max) {\n            $max = $l->[$i];\n        }\n    }\n    return $max;\n\
    }", '    my ($max) = $l->[-1];', "    my $max_value = $l->[0];\n    foreach (@$l)\
    \ {\n        $max_value = $_ if ($_ > ($max_value));\n    }\n    return $max_value;\n\
    }", "    my $n = $l->[0];\n    for (my $i = 1; $i < $l->[0]; $i++) {\n       \
    \ $n = $l->[$i]\n            if $l->[$i] > $n;\n    }\n    return $n;\n}", " \
    \   my $max;\n    foreach my $n (reverse @$l) {\n        if ($max < $n) {\n  \
    \          $max = $n;\n        }\n    }\n    return $max;\n}", '    my($r);',
  "    my ($max, $elem) = (0, undef);\n    $elem = 0;\n    foreach my $value (@$l)\
    \ {\n        $elem = $elem > $value ? ($elem, $value) : $value;\n    }\n    $max\
    \ = $elem > $max ? ($elem, $max) : $max;\n    return $max;\n}", "    my($max);\n\
    \    my $maxv = -0x80000000;\n    for($l->[-1]) {\n        if($_ gt $max) {\n\
    \            $max = $_;\n        }\n    }\n    return $max;\n}", "    my($max_val)\
    \ = undef;\n    for (my $i = 0; $i < @$l; $i++) {\n        $max_val //= $l->[$i];\n\
    \        last if ($l->[$i] > $max_val);\n    }\n    return $max_val;\n}", "  \
    \  my $min = $l->[0];\n    my $max;\n    for (my $i = 1; $i < @$l; $i++) {\n \
    \       if ($l->[$i] < $min) {\n            $min = $l->[$i];\n        } elsif\
    \ ($l->[$i] > $max) {\n            $max = $l->[$i];\n        }\n    }\n    return\
    \ $max;\n}", "    my $max = undef;\n    for (my $i = 0; $i < scalar @$l; $i++)\
    \ {\n        if (defined $max and $l->[$i] > $max) {\n            $max = $l->[$i];\n\
    \        }\n    }\n    return $max;\n}", "    my $max = -1;\n    foreach my $e\
    \ (0..$#$l) {\n        if($l->[$e] > $max) {\n            $max = $l->[$e];\n \
    \       }\n    }\n    return $max;\n}", "    my $max = pop(@$l);\n    for (@$l)\
    \ {\n        $max = undef\n            unless defined $_\n              && ($_\
    \ <= $max)\n              && ($max || 0);\n    }\n    return $max;\n}", "    my($n)\
    \ = reduce { $a <=> $b } @$l;\n    return $l[$n] if ($n >= 0);\n    my $len =\
    \ @$l;\n    while ($len) {\n        $len -= 1;\n        return $l[$len] if $l[$len]\
    \ > 0;\n    }\n    return undef;\n}", "    # use List::Util for speed improvement\n\
    \    my $u = List::Util::max;\n    $_ = $u->( @$l );\n    return $_;\n}", "  \
    \  my($result) = 0;\n    foreach my $item (@{$l}) {\n        $result = $item if\
    \ $item > $result;\n    }\n    $result;\n}", "    my $max = -1;\n    for(my $i\
    \ = 0; $i < @$l; $i++) {\n        if ($l->[$i] > $max) {\n            $max = $l->[$i];\n\
    \        }\n    }\n    return $max;\n}", "    my $ret = $l->[0]\n      if (@$l\
    \ == 1);\n    my ($a, $b);\n    my $c = 0;\n    foreach my $item (@$l) {\n   \
    \     if ($item > $b || ($item == $b and $c < 0)) {\n            $b = $item;\n\
    \            $c = $c ? $c + 1 : -1;\n        }\n    }\n    return $b;\n}", " \
    \   my $max = undef;\n    foreach my $num (@$l) {\n        if (defined $max) {\n\
    \            if ($num > $max) {\n                $max = $num;\n            }\n\
    \        } else {\n            $max = $num;\n        }\n    }\n    return $max;\n\
    }", "    my($min);\n    my($max);\n    my($ret);", "    my $max_elem = 0;\n  \
    \  $max_elem = $l->[0] if @$l > 0;\n    for my $elem (@$l) {\n        $max_elem\
    \ = $elem if $elem > $max_elem;\n    }\n    return $max_elem;\n}", "    my $n\
    \ = @$l;\n    return $l->[$n-1] if ($n > 1);\n    return undef;\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| a tags=perl,sorting |>\nThe question did not specify sort\
    \ order; and I thought this problem might be relevant to many people finding this\
    \ page and searching for ways to sort arrays (like for instance sorting a hash).\n\
    I looked at several of the answers here and found that most of these were overcomplicated.\
    \ Instead I decided to post my own answer which I thought was very comprehensive\
    \ and I thought it might be worth sharing my code with others.\nHere is a short\
    \ explanation of the code (in the comments), and a link to an online version of\
    \ it.\n<code>", "    my $max = @$l > 1 ? $l->[-1] : 'undef';\n    for(my $i =\
    \ @$l - 2 ; $i >= 0 ; $i--) {\n        if($l->[$i] > $max) {\n            $max\
    \ = $l->[$i];\n        }\n    }\n    return $max;\n}\n</code>\n<|/ a |>\n<| c\
    \ |>\nThis is cool, but you should probably include a test case for empty input.\n\
    <|/ c |>\n<| c |>\n: You might like to test the code before posting it. It's tested\
    \ as posted, but as you say, it could be optimized further.\n<|/ c |>\n<| c |>\n\
    I did, and it works with an empty array.  So there must be something else going\
    \ wrong.\n<|/ c |>\n<| c |>\nI actually just got around to implementing this in\
    \ Perl instead of Python, and it worked like a charm.  Thanks!\n<|/ c |>\n<| c\
    \ |>\nI actually just got around to implementing this in Perl instead of Python,\
    \ and it worked like a charm.  Thanks!\n<|/ c |>\n<| a tags=perl,arrays,max dscore=3\
    \ |>\n<code>\nuse strict;\nuse warnings;", '    my $largest = undef;', "    my\
    \ $max = -1;\n    for my $element (@$l) {\n        if ($element > $max) {\n  \
    \          $max = $element;\n        }\n    }\n    return $max;\n}", "    my $result;\n\
    \    while (@_) {\n        $result = $_[0] if defined $result;\n        last if\
    \ ($result and $_[0] < $result);\n        $result = $_[0];\n    }\n    return\
    \ $result;\n}", "    my $max = -1;\n    for (@$l) {\n\tif (defined $max and $max\
    \ > $_ ) {\n\t    return $max;\n\t}\n\t$max = $_;\n    }\n    return $max;\n}",
  "    my $max_val;\n    my $max_index = 0;\n    for(my $i = 0; $i < @$l; $i++) {\n\
    \        my $temp = $l->[$i];\n        if ($temp > $max_val || !defined($max_val))\
    \ {\n            $max_val = $temp;\n            $max_index = $i;\n        }\n\
    \    }\n    return $l->[$max_index];\n}", "    my $max = $l->[0] if @$l > 0;\n\
    \    for my $i (1..$#$l) { $max = $l->[$i] if $l->[$i] > $max }\n    $max;\n}",
  "    my $max = -1;\n    for (@$l) {\n        $max = $_ if $_ > $max;\n    }\n  \
    \  return $max;\n}", "    my $max = -1;\n    my $idx = 0;\n    while (@$l > 0\
    \ && $max < $l->[$idx]) {\n        $max = $l->[$idx];\n        $idx++;\n    }\n\
    \    return $l->[$idx] if @$l == 0 && $max == -1;\n    return $max;\n}", "   \
    \ my $max = $l->[0];\n    for my $x (@$l) {\n        if ($x > $max) {\n      \
    \      $max = $x;\n        }\n    }\n    return $max;\n}", "    my $max;\n   \
    \ for my $item (@$l) {\n        if (defined $max and $item > $max) {\n       \
    \     $max = $item;\n        }\n    }\n    return $max;\n}", "    my $max = @$l\
    \ > 0 ? $l[0] : undef;\n    for my $i (1 .. $#l) {\n        if ($l[$i] > $max)\
    \ {\n            $max = $l[$i];\n        }\n    }\n    return $max;\n}", "   \
    \ $l =~ m@^(-?\\d+)$@;\n    ($1 > $l) ? $1 : $l;\n}", "    my $min = $l->[0];\n\
    \    my $max = $l->[0];\n    foreach my $i (0 .. $#$l) {\n        my $x = $l->[$i];\n\
    \        if ($x > $max) {\n            $max = $x;\n        }\n        if ($x <\
    \ $min) {\n            $min = $x;\n        }\n    }\n    return $min;\n}", " \
    \   my $max;\n    my $max_val;\n    $max = $max_val = 0;\n    foreach my $x (@$l)\
    \ {\n        if (!defined $max || $x >$max) {\n            $max = $x;\n      \
    \      $max_val = $x;\n        }\n        elsif ($x ==$max) {\n            $max_val\
    \ = $max_val eq $x ? $max_val : $x;\n        }\n    }\n    return $max_val;\n}",
  "    my $max = @$l > 0 ? $l[0] : 0;\n    for (@$l) {\n        last if $_ > $max;\n\
    \        $max = $_;\n    }\n    return $max;\n}", "    my $min = MAX_INT // MAX_INT;\n\
    \    foreach my $v (@$l) {\n        if ($v > $min) {\n            $min = $v;\n\
    \        }\n    }\n    return $min;\n}", "    my $max = $l->[0];\n    foreach\
    \ my $e (@$l) {\n        if ($e > $max) {\n            $max = $e;\n        }\n\
    \    }\n    return $max;\n}", "    my $cmp = $l->[0]->[0];\n    my $max = @{$l}\
    \ > 1 ? $l->[1]->[0] : undef;\n    foreach my $x (@{$l}) {\n        if ($x->[0]\
    \ > $max) {\n            $max = $x->[0];\n            $cmp = $x->[0];\n      \
    \  }\n    }\n    return $max unless defined $max;\n    return $cmp ? $max : $cmp;\n\
    }", '    local $l[0];', "    if (@$l < 1) {\n        return 0;\n    }\n    my\
    \ $max = @$l > 0 ? $l->[0] : 0;\n    for (my $i = 1; $i < @$l; $i++) {\n     \
    \   if ($l->[$i] > $max) {\n            $max = $l->[$i];\n        }\n    }\n \
    \   return $max;\n}", "    my $max_elem = $l[0];\n    for (my $i = 1; $i < @$l;\
    \ ++$i) {\n        if ($l->[$i] > $max_elem) {\n            $max_elem = $l->[$i];\n\
    \        }\n    }\n    return $max_elem;\n}", "    my $max = 0;\n    my $idx =\
    \ 0;\n    for (my $i = 0; $i < @$l; $i++) {\n        if ($max == 0 || ($max >\
    \ $l->[$i])) {\n            $max = $l->[$i];\n            $idx = $i;\n       \
    \ }\n    }\n    return $l->[$idx];\n}", "    my $max;\n    my $idx;\n    my $maxel\
    \ = undef;\n    foreach my $e ($l) {\n        if (defined $maxel) {\n        \
    \    if ($e > $maxel) {\n                $maxel = $e;\n                $idx =\
    \ $i;\n            }\n        }\n        $maxel = $e;\n        $i++;\n    }\n\
    \    return $maxel;\n}", "    my $max = 0;\n    foreach my $i (@$l) {\n      \
    \  if($i >  $max) {\n            $max = $i;\n        }\n    }\n    return $max;\n\
    }", "    return $l if @$l < 1;\n    return $l[0] if @$l == 1;\n    @$l > 1 and\
    \ $l[0] >= $l[1] and @$l == 1 or $l[0] > $l[1] and @$l == 1;\n}", "    my $x =\
    \ $l->[0];\n    for my $y ($l->[1 .. $#$l]) {\n        $x = $y if $x > $y;\n \
    \   }\n    return $x;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks for your time. I\
    \ am not sure why this solution would not be accepted by some of my submission\
    \ sites. I guess it is too naive to judge the time it takes someone's solution\
    \ as 'correct'.\n<|/ c |>\n<| c |>\nI wouldn't worry too much about it - it's\
    \ an optimisation and in general it's not a bad idea to optimise. Most of the\
    \ time people who submit solutions to the contest will just submit the first version\
    \ which doesn't optimise as much and only optimise after they have proven their\
    \ answers are correct.\n<|/ c |>\n<| a dscore=0 |>\nThe other way would be to\
    \ sort your array and then get the first element. Sorting is pretty easy and is\
    \ O(n log n).\n<code>\nmy = qw(1 -10 20 30 40 50 -20 -10 40 50 -10 20 -20);\n\
    print sort{$a<=>$b} map {$_};\n</code>\nThis will print out:\n<code>\n-20 -20\
    \ -10 10 20 30 40 50 50 -10\n</code>\n<|/ a tags=perl,arrays |>\n<| c |>\nThanks\
    \ for your time. Sorting is a good idea, but I am trying to get my hands on some\
    \ more efficient ways. Perl arrays are weird.\n<|/ c |>\n<| c |>\nOkay, I understand.\
    \ I just thought about this. But sorting would still be O(nlogn), so I don't know\
    \ how this would be faster than O(n^2). The other way would be to use Math::Combinatorics::Permutations\
    \ to generate all combinations, then find the maximum. But I guess it would be\
    \ even slower\n<|/ c |>\n<| c |>\nIt's an interesting idea. The problem is that\
    \ it requires `@a` and a lot of memory. I guess it's better to stick with the\
    \ naive approach in such case. I'll give you an upvote for the idea.\n<|/ c |>\n\
    <| c |>\nIf you need combinations, you'll have to look at [`Algorithm::Combinatorics`](http://p3rl.org/Algorithm::Combinatorics)\n\
    <|/ c |>\n<| a dscore=0 tags=perl,arrays |>\nPerl 5\n<code>\nmy = qw(1 -10 20\
    \ 30 40 50 -20 -10 40 ", "    # Return maximum if all elements are same\n    return\
    \ $l[0] if @$l == 1;\n    # Return maximum of all elements\n    my $max = shift\
    \ @$l;\n    while (@$l) {\n        $max = $max > $_ ? $max : $_;\n    }\n    return\
    \ $max;\n}", "    my $result = -999999999999999999999999999999999999999999999999;\n\
    \    foreach my $val (@$l) {\n        $result = $val if $val > $result;\n    }\n\
    \    return $result;\n}", "    my $min = undef;\n    my $max;\n    foreach my\
    \ $x (@$l) {\n        if (defined $min) {\n            if ($x < $min) {\n    \
    \            $min = $x;\n            }\n        } elsif (defined $x) {\n     \
    \       $min = $x;\n            $max = $x;\n        } else {\n            $min\
    \ = undef;\n        }\n    }\n    return $min;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    +1 Thanks for posting your solution. I've been using `min` but I'm still trying\
    \ to figure out how to get this working for floats instead of ints. The only issue\
    \ I see with your approach is that if you pass it an array with floats and an\
    \ int it will return the int rather than the float.\n<|/ c |>\n<| c |>\nYou can\
    \ convert numbers to strings with the `sprintf` function. E.g. `sprintf(\"%.2f\"\
    , $number)`. See also the [`sprintf`](http://perldoc.perl.org/functions/sprintf.html)\
    \ perl documentation.\n<|/ c |>\n<| c |>\n`min` will take a string of digits and\
    \ compare them numerically.  In other words, if `min('123')` is less than `min('3456')`,\
    \ it will return `'123'`.  In other words, it can't return a float.\n<|/ c |>\n\
    <| c |>\n: Thanks, I didn't know that. My solution was based off of that, but\
    \ I used a little different syntax.\n<|/ c |>\n<| c |>\n: You're correct that\
    \ `min` can return a float, but that isn't the point.  The point is that the OP's\
    \ code is only a little off.  All that `if` test is doing to keep track of the\
    \ min is setting it to a number if it's already defined.  That's not how it needs\
    \ to be.  It should compare `$x` with `$min`, and if it passes, set `$min` to\
    \ `$x`.\n<|/ c |>\n<| a tags=perl,minimum,arrays |>\nHere's a simple way to find\
    \ the minimum value in an array.\n<code>\nuse strict;\nuse warnings;", "    my\
    \ $min = $l[0];\n    my $max = $l[0];\n    foreach (@$l) {\n        if ($_ > $max)\
    \ {\n            $max = $_;\n        }\n        if ($_ < $min) {\n           \
    \ $min = $_;\n        }\n    }\n    return $max;\n}", "    my $max = @$l > 1 ?\
    \ $l->[-1] : 0;\n    foreach my $i (0 .. $#$l) {\n        if ($l->[$i] > $max)\
    \ {\n            $max = $l->[$i];\n        }\n    }\n    return $max;\n}", " \
    \   my $max_value = $l->[-1];\n    $l->[-1] = $max_value;\n    \n    foreach my\
    \ $elem ($l->[1..$#$l]) {\n        if($elem > $max_value) {\n            $max_value\
    \ = $elem;\n        }\n    }", "    if (scalar(@$l) == 0) {\n        return;\n\
    \    }", "    my($max) = undef;\n    my(@array) = $l;\n    my($index);\n    for\
    \ ($index = 0; $index < scalar(@array); $index++) {\n        ($array[$index] >\
    \ $max) ? $max : $array[$index];\n    }\n    return $max;\n}", '    my(@r) = (undef);',
  "    my $max = -1;\n    for (@$l) {\n        $max = $_ if defined $max and $max\
    \ > $_;\n    }\n    return $max;\n}", "    return $l->[0] if @$l < 1;\n    return\
    \ $l->[-1];\n}", "    my($high) = @$l > 1 ? $l[scalar - 2] : undef;\n    my $ret\
    \ = undef unless @$l > 1;\n    my $high_index = 0;\n    for (my $i = 0; $i < @$l;\
    \ $i++) {\n        my($x, $y) = ($l[$i], $l[$i + 1]);\n        if (defined $y)\
    \ {\n            if ($high < $y) {\n                $high = $y;\n            \
    \    $high_index = $i;\n            }\n        }\n    }\n    return $ret = $l[$high_index]\
    \ if defined $high and !defined $ret;\n    $ret;\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=perl,hash,arrays |>\nA Hash has O(1) lookup but O(N) insert and delete.\
    \ As such, if you are going to be inserting and deleting a lot of items and need\
    \ these operations to occur fast, you probably need to switch to a different data\
    \ structure.\n<|/ a dscore=1 |>\n<| c |>\nNot necessarily. For insertions and\
    \ deletions, a list can be much faster than a hash because of locality of reference.\
    \ For lookups, a hash can be much faster than a list because of constant time\
    \ lookups. A hash does have a better locality of reference though, so I guess\
    \ it really comes down to which one you think will give you the best results most\
    \ of the time.\n<|/ c |>\n<| c |>\nYou mean a sorted array instead of an unsorted\
    \ hash?\n<|/ c |>\n<| c |>\n: Yes, a sorted array will allow you to do the lookups\
    \ very fast while allowing you to have random insertions and deletions.\n<|/ c\
    \ |>\n<| c |>\n: Sure, but a hash requires more memory, which is an issue unless\
    \ you have a lot more keys.\n<|/ c |>\n<| c |>\nA hash doesn't require more memory.\
    \ But you are right that lookups by key are slower.\n<|/ c |>\n<| a dscore=1 |>\n\
    A hash is a good solution for your problem, if you need to lookup items by key,\
    \ and you will be inserting and deleting items frequently.  However, if you need\
    \ to do more complicated lookups (and insertions and deletions) then you should\
    \ consider looking at a sorted array (or a tree) instead.\nA sorted array is a\
    \ good solution if you are going to be deleting or inserting items frequently.\
    \  A tree would be good if you will be doing more complex lookups.\nA sorted array\
    \ would be the ideal solution if you know that the number of keys and insertion/deletion\
    \ rates will be roughly equal.\nA tree would be a good solution if you ", "  \
    \  my $min = undef;\n    $min = $l->[0] unless $l->[0];", "    my $m = 0;\n  \
    \  my $max = $l->[0];\n    for my $i (@$l) {\n        if ($i > $m) {\n       \
    \     $max = $i;\n            $m = $i;\n        } elsif ($i == $m) {\n       \
    \     $m = $m;\n        }\n    }\n    return $max;\n}", "    my $max = -1;\n \
    \   foreach my $i (@$l) {\n        $max = $i if $max < $i;\n    }\n    return\
    \ $max;\n}", "    return $l unless @$l;\n    my $s = $l->[0];\n    for(my $i =\
    \ 1; $i <= $#$l; $i++) {\n        $s = $l->[$i] if $s < $l->[$i];\n    }\n   \
    \ $s;\n}", '    return $l->[0] if @$l == 1;', "    my($max,$elem) = (-$l);\n \
    \   for(my $i=0; $i<@$l; $i++) {\n        if ($max<$l->[$i]) {\n            $max\
    \ = $l->[$i];\n            $elem = $i;\n        }\n    }\n    return $max;\n}",
  "    my $min_element;\n    for my $i (@$l) {\n        return $i if $i < $min_element\
    \ || $min_element == 0;\n        $min_element = $i;\n    }\n    return $min_element;\n\
    }", '    return unless ( @$l );', "    my $max = -1;\n    my $arg;\n    for (@$l)\
    \ {\n        my $elem = $_;\n        my $i;\n        for (0 .. $#$l - 1) {\n \
    \           $i = $_ - 1;\n            if ($elem > $l[$i]) {\n                $elem\
    \ = $l[$i];\n            }\n        }\n        if ($elem > $max) {\n         \
    \   $max = $elem;\n        }\n    }\n    return $max;\n}", "    my($first, $max)\
    \ = (0, 0);\n    my($len) = @_;\n    for(my $i = 0; $i < $len; $i++) {\n     \
    \   if ($max == 0) {\n            $first = $i;\n            $max = $l[$i];\n \
    \       } elsif ($l[$i] > $max) {\n            $max = $l[$i];\n        }\n   \
    \ }\n    return $max;\n}", "    my $max = -1;\n    my $i;\n    for($i = 0; $i\
    \ <= $#$l; $i++) {\n        my $e = $l->[$i];\n        if( $e > $max ) {\n   \
    \         $max = $e;\n        }\n    }\n    return $max;\n}", "    my $max = -1;\n\
    \    foreach my $i (@$l) {\n        $max = -1 if $i > $max;\n        $max = $i\
    \ if $i < $max;\n    }\n    return $max;\n}", "    my $max = @$l > 0 ? $l[0] :\
    \ undef;\n    for my $e (@$l) {\n        if (defined $max && $e > $max) {\n  \
    \          $max = $e;\n        }\n    }\n    return $max;\n}", "    my $max =\
    \ shift;\n    local $@;\n    my $l = @$l;\n    for (my $i = 0; $i < $l; $i++)\
    \ {\n        if ($max->($_) < $l->[$i]) { $max->($_) = $l->[$i]; }\n    }\n  \
    \  return $max;\n}", "    my($i, $max) = (0, -1);\n    foreach $x (@$l) {\n  \
    \      $max = $x if $x > $max;\n        $i = $max if $i == -1 or $max != $x;\n\
    \    }\n    return $max;\n}", "    my $max = -1;\n    for (@$l) {\n        $max\
    \ = $l[0] if $l[0] > $max;\n    }\n    return $max;\n}", '    return undef unless
    @$l;', "    $l->[0] if (@$l > 0);\n}", "    local @$l = sort @$l;\n    if (@$l\
    \ == 1) {\n        my $max = shift @$l;\n        shift @$l;\n        return $max;\n\
    \    }\n    return shift @$l;\n}", "    $l ||= [undef];\n    my($max);\n    foreach\
    \ my $x (@$l) {\n        $max ||= $x; # first element\n        last if $x > ($max);\n\
    \    }\n    return $max;\n}", "    my($m) =;\n    $m ||= $l->[0];\n    $l->[$m]\
    \ == $l->[-1] && $m++ if $l->[-1] > $m;\n    return $m;\n}", "    my $max;\n \
    \   foreach my $n (@$l) {\n        if (defined $max && $max > $n) {\n        \
    \    $max = $n;\n        }\n    }\n    return $max;\n}", "    my $max = -1;\n\
    \    for (@_) {\n        if ($l > $max) {\n            $max = $l;\n        }\n\
    \    }\n    return $max;\n}", "    return $l[0] if @$l == 1;\n    for my $i (0\
    \ .. $#$l - 1) {\n        my $e = $l[$i];\n        foreach my $j ($i + 1 .. $#$l)\
    \ {\n            my $f = $l[$j];\n            if ($e > $f) { $e = $f; }\n    \
    \    }\n        $l[$i] = $e;\n    }\n    $l[0]\n}", "    my $l = @$l > 0 ? @$l\
    \ : 0;\n    my $lmax = @$lmax > $l ? @$lmax : $l;", "    my $max = @$l > 0 ? @$l\
    \ : 1;\n    for (@$l) {\n        my ($v) = split /:/;\n        $max = $v if ($v\
    \ > $max);\n    }\n    $max;\n}", "    my $max;\n    for(my $n = 0; $n < @$l &&\
    \ $l->[$n] <= $max; $n++) {\n        $max = $l->[$n];\n    }\n    return $max;\n\
    }"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
