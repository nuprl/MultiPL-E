name: HumanEval_35_max_element
language: pl
prompt: "# Return maximum element in the array.\n# >>> max_element([1, 2, 3])\n# 3\n\
  # >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n# 123\nsub max_element\
  \ {\n    my($l) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_element;\n\
  \        if(eq_deeply($candidate->([1, 2, 3]),3)) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 3, -5, 2, -3,\
  \ 3, 9, 0, 124, 1, -10]),124)) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n}\n\ntesthumaneval();"
completions: ["    my $max;\n    my $_max = 0;\n    $max = $l->[$_max] if @_ == 0;\n\
    \    foreach my $i (0 .. @$l - 1) {\n        my $a = $l->[$i];\n        next if\
    \ !defined $a;\n        $_max = 1 if $a > $max;\n        $max = $a if $a > $_max;\n\
    \    }\n    return $max;\n}", '    return undef unless (defined($l));', "    #\
    \ Return empty list if list is empty.\n    return if @$l == 0;", "    if (@$l\
    \ == 0){\n        $l = [$_[0]];\n    }\n    my $largest = @$l > 0 ? $l[0] : undef;\n\
    \    foreach my $x (@$l) {\n        if ($x > $largest) {\n            $largest\
    \ = $x;\n        }\n    }\n    return $largest;\n}", "    my $lsize = $l->size;\n\
    \    my $emax = 0;", "    my $max = -1;\n    for (@$l) {\n        my $v = $_;\n\
    \        $max = $v if $v > $max;\n    }\n    return $max;\n}", "    my(@res);\n\
    \    my($max);\n    my $x = 0;\n    $max = $l->[0];\n    foreach my $i (@$l) {\n\
    \        if ($i > $max) {\n            $max = $i;\n        }\n        $res[$x]\
    \ = $i;\n        $x++;\n    }\n    return $res[$x-1];\n}\n</code>\n<|/ a dscore=2\
    \ tags=max,perl,arrays |>\n<| c |>\nI tried to implement this solution into my\
    \ script but am having trouble with the sub loop in the first line.  My first\
    \ line: $max_element = sub {\n<|/ c |>\n<| c |>\nHmmm... are you sure you used\
    \ the exact same code as above? I copied it right from my test script. If your\
    \ script has different name, you need to specify that in the subroutine definition.\n\
    <|/ c |>\n<| c |>\nOk, thanks.  I actually had a test script that did this correctly\
    \ but I didn't see that I had copied that sub.  Thanks!\n<|/ c |>\n<| a tags=max,perl,arrays\
    \ |>\nThe code below implements a simple solution that returns an array with all\
    \ the max values\n<code>", '    my ($i, $max);', '    my($i, $x, $y);', "    $l\
    \ ? $l->[-1] : 0;\n}", "    my ($i, $max);\n    my $max = $l->[0];\n    for (my\
    \ $i = 1; $i < @$l; ++$i) {\n        $max = $_ if $_ > $max;\n    }\n    $max;\n\
    }", '    my($n) = @$l[0];', "    my $max;\n    for(my $i=0; $i<@$l; $i++) {\n\
    \        if($l->[$i] > $max) {\n            $max = $l->[$i];\n        }\n    }\n\
    \    return $max;\n}", '    my $maximum = -1;', "    my $l = sort {$a <=> $b}\
    \ @$l;\n    $l[0]\n}", "    my $n = scalar(@$l);\n    my $m = $n;\n    for (my\
    \ $i = $n - 1; $i >= 0; $i--) {\n        my $t = $l->[$i];\n        if ($t > $m)\
    \ { $m = $t; }\n    }\n    return $m;\n}\n</code>\n<|/ a |>\n<| a dscore=4 |>\n\
    Just for fun...\n<code>", "    my $n = scalar @$l;\n    my ($max, $element) =\
    \ @$l[0,1];\n    foreach my $i (0..$n-1) {\n        if ($l->[$i] > $max) {\n \
    \           $max = $l->[$i];\n            $element = $i;\n        }\n    }\n \
    \   $element;\n}", "    my $min = 0;\n    foreach my $i (0..$#l){\n        if\
    \ ($l[$i] >= $min){\n            $min = $l[$i];\n        }\n    }\n    return\
    \ $min;\n}\n</code>\n<|/ a tags=perl,arrays dscore=0 |>\n<| c |>\nI didn't know\
    \ about `List::UtilsBy`. I'll definitely keep that bookmark handy. Thanks for\
    \ the tip!\n<|/ c |>\n<| a |>\nHere's a slightly more concise way of getting the\
    \ max value...\n<code>", "    if ($l == 0) {\n        return;\n    }", "    my\
    \ $min = shift @$l;\n    for (@_) {\n        $min = $min if $_ > $min;\n    }\n\
    \    return $min;\n}", "    my($max) = 0;\n    my($i, $j, $k, $value);", "   \
    \ my $result;\n    if ($l) {\n        my $max_value = $l->[0];\n        my $max_index\
    \ = 0;\n        for my $i (1..$l->[0]) {\n            if ($l->[$i] > $max_value)\
    \ {\n                $max_value = $l->[$i];\n                $max_index = $i;\n\
    \            }\n        }\n        $result = $max_value;\n    } else {\n     \
    \   $result = 0;\n    }\n    return $result;\n}", "    return undef unless @_\
    \ > 0;\n    return $l[0] if @_ == 1;\n    $_[0] = $l[0] if ref($l[0]);\n    $l[0]\
    \ = $l[0] if ref($l[0]);\n    my $max = ${$l[0]}; $max = -1 if !defined($max);\n\
    \    return $max if @_ == 2;\n    $max = $max if !ref($max);\n    my $len = 0;\n\
    \    while (@_ > 1) {\n        $len++;\n        my $v = pop(@_);\n        $max\
    \ = $v if !ref($v) || $v > $max;\n    }\n    return $max if $len == 0;\n    $_[0]\
    \ = $max if ref($max);\n    $max = $max if !ref($max);\n    return $max;\n}",
  "    my($max) = $l->[-1];\n    foreach my $i (reverse 0 .. $#$l) {\n        if ($l->[$i]\
    \ > $max) {\n            $max = $l->[$i];\n        }\n    }\n    return $max;\n\
    }", "    $l =~ m/^\\s*(-?\\d+)\\s*.*$/g;\n    $l =~ m/^\\s*(-?\\d+)\\s*.*$/g;\n\
    \    $l =~ m/^\\s*(-?\\d+)\\s*.*$/g;\n    $l =~ m/^\\s*(-?\\d+)\\s*.*$/g;\n  \
    \  $l =~ m/^\\s*(-?\\d+)\\s*.*$/g;\n    $l =~ m/^\\s*(-?\\d+)\\s*.*$/g;\n    $l\
    \ =~ m/^\\s*(-?\\d+)\\s*.*$/g;\n    $l =~ m/^\\s*(-?\\d+)\\s*.*$/g;\n    $l =~\
    \ m/^\\s*(-?\\d+)\\s*.*$/g;\n    $l =~ m/^\\s*(-?\\d+)\\s*.*$/g;\n    $l =~ m/^\\\
    s*(-?\\d+)\\s*.*$/g;\n    $l =~ m/^\\s*(-?\\d+)\\s*.*$/g;\n    $l =~ m/^\\s*(-?\\\
    d+)\\s*.*$/g;\n    $l =~ m/^\\s*(-?\\d+)\\s*.*$/g;\n    $l =~ m/^\\s*(-?\\d+)\\\
    s*.*$/g;\n    $l =~ m/^\\s*(-?\\d+)\\s*.*$/g;\n    $l =~ m/^\\s*(-?\\d+)\\s*.*$/g;\n\
    \    $l =~ m/^\\s*(-?\\d+)\\s*.*$/g;\n    $l =~ m/^\\s*(-?\\d+)\\s*.*$/g;\n  \
    \  $l =~ m/^\\s*(-?\\d+)\\s*.*$/g;\n    $l =~ m/^\\s*(-?\\d+)\\s*.*$/g;\n    $l\
    \ =~ m/^\\s*(-?\\d+)\\s*.*$/g;\n    $l =~ m/^\\s*(-?\\d+)\\s*.*$/g;\n    $l =~\
    \ m/^\\s*(-?\\d+)\\s*.*$/g;\n    $l =~ m/^\\s*(-?\\d+)\\s*.*$/g;\n    $l =~ m/^\\\
    s*(-?\\d+)\\s*.*$/g;\n    $l =~ m/^\\s*(-?\\d+)\\s*.*$/g;\n    $l =~ m/^\\s*(-?\\\
    d+)\\s*.*$/g;\n    $l =~ m/^\\s*(-?\\d+)\\s*.*$/g;\n    $l =~ m/^\\s*(-?\\d+)\\\
    s*.*$/g;\n    $l ", "    my $max = ${$l->[0]};\n    foreach my $i (1..$#$l) {\n\
    \        if ($max->[0] > $l->[$i]) {\n            $max = [$l->[$i], $max->[1]];\n\
    \        }\n    }\n    return $max;\n}", "    my $max;\n    for (@_) {\n     \
    \   if ($l < $_) {\n            $max = $_;\n        }\n    }\n    return $max;\n\
    }", "    my $min = pop @$l;\n    while (@$l > 0 && $l->[0] <= $min) {\n\t$min\
    \ = pop @$l;\n    }\n    return $min;\n}", "    my $max;\n    my $max = shift\
    \ @$l if $l && ref $l;\n    unless ($max and $max > 0){\n        $max = $l->[0];\n\
    \        for (@$l){\n            $max = $_ if $_ > $max;\n        }\n    }\n \
    \   return $max;\n}", "    if (@$l == 0) {\n        return 0;\n    }", "    my($max)\
    \ = $l->[-1];\n    foreach my $element (@{$l->[0..$#$l]} ) { # O(N)\n        if(\
    \ $element > $max ) {\n            $max = $element;\n        }\n    }\n    return\
    \ $max;\n}", "    # Find the maximum in the list\n    for (my $i = $#l ; $i >=\
    \ 0 ; --$i) {\n        if ( $l[$i] > $l[$i-1] ) {\n            $l[$i] = $l[$i];\n\
    \        }\n    }\n    return $l[0];\n}", "    # Return maximum of $l.\n    #\
    \ >>> max_element([1, 2, 3])\n    # 3\n    # >>> max_element([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10])\n    # 123\n    my $max_elt = $l->[-1];\n    my $max_idx\
    \ = 0;\n    foreach my $i (@$l) {\n        if ($max_elt > $i) {\n            $max_elt\
    \ = $i;\n            $max_idx = $i;\n        }\n    }\n    return $max_idx;\n\
    }\n</code>\nIf performance is an issue, it's worth considering if sorting is an\
    \ option. Here's a quick benchmark of various methods to determine the fastest\
    \ one (in this case, using Perl's built-in sort function):\n<code>\nuse Benchmark\
    \ qw(:all);\nuse Sort::Key::Naturally qw(natsorts);\nuse List::Util qw(max);",
  "    my $min = max @$l;\n    for (@$l) {\n        if ($_ > $min) {\n           \
    \ $min = $_;\n        }\n    }\n    return $min;\n}", "    my $max = $l->[-1];\n\
    \    for(my $i = 1; $i < @$l; $i++) {\n        next unless $l->[$i] >= $max;\n\
    \        $max = $l->[$i];\n    }\n    return $max;\n}", "    my($max, $i) = (0,\
    \ 0);\n    foreach(@$l) {\n        $max = $_ if !defined $max || $_ > $max;\n\
    \        $i = $#l if $_ == $max;\n    }\n    return $l[$i];\n}", "    my $max_element\
    \ = 0;\n    my $i = 0;\n    while ($i < @$l) {\n        if ($l->[$i] > $max_element)\
    \ {\n            $max_element = $l->[$i];\n        }\n        $i++;\n    }\n \
    \   return $max_element;\n}", "    my $max = $l->[-1];\n    my $i;\n    for ($i\
    \ = 0; $i <= @$l - 1; $i++) {\n        my $element = $l->[$i];\n        if ($element\
    \ > $max) {\n            $max = $element;\n        }\n    }\n    return $max;\n\
    }", "    my $ret = $l->[0];\n    my $max = 0;\n    for my $i (0 .. $l->[0]-1)\
    \ {\n        $max = $i if $l->[$i] > $max;\n    }\n    return $max;\n}", '    my
    $l = scalar @$l > 0 ? @$l : 0;', "    return undef unless @$l > 0;\n    return\
    \ $l[0] if @$l == 1;\n    $l[0] > $l[1] ? $l[0] : $l[1];\n}", "    my $max = $l->[0];\n\
    \    for my $i(1..$#$l) {\n        if($l->[$i] > $max) {\n            $max = $l->[$i];\n\
    \        }\n    }\n    return $max;\n}", "    my $max_element = -1;\n    my $i\
    \ = 0;", "    my $min = $l->[0];\n    my $max = $l->[0];\n    \n    for(my $i\
    \ = 1; $i < @$l; ++$i) {\n        if ($l->[$i] > $max) {\n            $max = $l->[$i];\n\
    \        }\n        if ($l->[$i] < $min) {\n            $min = $l->[$i];\n   \
    \     }\n    }\n    return $min;\n}", "    my $max = -9999;\n    for(my $i = 0;\
    \ $i < @$l && $max < $l->[$i]; ++$i) {}\n    return $max if @$l <= 0;\n    return\
    \ $l->[$i];\n}\n</code>\n<|/ a |>\n<| a dscore=4 tags=arrays,perl |>\n<code>\n\
    use strict;\nuse warnings;", "    if (@$l == 0) {\n        return;\n    }\n  \
    \  my $max_element = @$l[0];\n    for (my $i = 1; $i < @$l; $i++) {\n        if\
    \ ($l[$i] > $max_element) {\n            $max_element = $l[$i];\n        }\n \
    \   }\n    return $max_element;\n}", "    return $l[0] if @$l == 1;\n    return\
    \ $l[0] if $l[0] > $l[1];\n    return $l[0];\n}", "    return $l->[0] if @$l ==\
    \ 0;\n    return $l->[scalar(@$l) - 1];\n}", "    my $max = $l[0];\n    foreach\
    \ my $i (1..scalar(@$l)) {\n        if ($l[$i] > $max) {\n            $max = $l[$i];\n\
    \        }\n    }\n    return $max;\n}", "    my($m) = 0;\n    my($m) = ${$l[$$m]};\
    \ # Find maximum.\n    $m = scalar(@$l) if $$m < 0;\n    for (my $i = 0; $i <\
    \ @$l; $i++) {\n        if ($$l[$i] > $m) {\n            $m = $$l[$i];\n     \
    \   }\n    }\n    return $m;\n}", "    if (@$l > 0) {\n        my $x = $l->[0];\n\
    \        $l->[0] = @$l > 1 ? $l->[1] : $x;\n    }\n    return $l->[0];\n}", " \
    \   if (@$l == 0) {\n        return;\n    }\n    my($m) = ($l[0]);\n    for my\
    \ $i (1 .. @$l - 1) {\n        if ( $l[$i] > $m ) {\n            $m = $l[$i];\n\
    \        }\n    }\n    return $m;\n}", "    my $max;\n    for (my $i = 0; $i <\
    \ @$l; $i++) {\n        $max = $max < $l->[$i] ? $l->[$i] : $max;\n    }\n   \
    \ $max;\n}", "    $l[0] > $l[-1] ? $l[0] : $l[-1];\n}", "    my $max = -1e11;\n\
    \    for my $e (@$l) {\n        if ($e > $max) {\n            $max = $e;\n   \
    \     }\n    }\n    return $max;\n}", '    my $max_element;', "    my $max = -1;\n\
    \    my @l;\n    for my $i (0 .. $#$l) {\n        if ($l[$i] > $max) {\n     \
    \       $max = $l[$i];\n        }\n    }\n    return $max;\n}", "    my $n = @$l;\n\
    \    for my $i (0..$n-1) {\n        return $l[$i] if $l[$i] > $l[$i+1];\n    }\n\
    \    return $l[0];\n}\n</code>\n<|/ a |>\n<| c |>\nThis returns the maximum *index*.\
    \ The OP requested a maximum element.\n<|/ c |>\n<| a |>\nIn Perl, you can use\
    \ the following code to get the maximum element in an array:\n<code>", "    if\
    \ ( @$l < 1 ) { return undef; }\n    my $max = $l->[0];\n    for my $i (1..@$l)\
    \ {\n        if ($l->[$i] > $max) { $max = $l->[$i]; }\n    }\n    return $max;\n\
    }", "    my $max = pop(@$l);\n    while (@$l > 0 && $l->[0] > $max) {\n      \
    \  $max = pop(@$l);\n    }\n    $max;\n}", "    if (@$l == 0) {\n        return\
    \ 0;\n    }\n    my($m) = undef;\n    my $max_val = 0;\n    my(@x) = @$l;\n  \
    \  foreach my $x (@x) {\n        if ($x != 0) {\n            if (defined($m) &&\
    \ $x > $m) {\n                $m = $x;\n            }\n            $max_val =\
    \ $x;\n        }\n    }\n    return $max_val;\n}", "    my($max) = $l->[0];\n\
    \    $max = @$l > 1 ? $l->[1] : $max;\n    for my $i (@$l) {\n        next if\
    \ $i < $max;\n        $max = $i;\n    }\n    return $max;\n}\n</cell>\n<text>\n\
    And now, we are ready to create the next Python program:", "    my $max = $l->[0];\n\
    \    foreach (@$l) {\n        return $max if ($_ gt $max);\n        $max = $_;\n\
    \    }\n    return $max;\n}", "    my($max) = undef;\n    $max = $l->[0] if @$l\
    \ > 0;\n    for my $i (1 .. @$l ) {\n        if ($l->[$i] > $max) {\n        \
    \    $max = $l->[$i];\n        }\n    }\n    return $max;\n}", "    my $max_element\
    \ = undef;\n    foreach my $x (@$l) {\n        $max_element = $x if ($max_element\
    \ < $x);\n    }\n    return $max_element;\n}", "    my($h) = @{$l};\n    if ($h\
    \ == @$l) {\n        return $h[0];\n    }\n    for (my $i = 0; $i < @$h; ++$i)\
    \ {\n        $h[$i] = $h[$i] > $h[$i-1] ? $h[$i] : undef;\n    }\n    return $h[0];\n\
    }", "    my $max = undef;\n    my $i = 0;\n    for (my $n = 0; $n < @$l; $n++)\
    \ {\n        if(defined $max) {\n            if($l->[$n] > $max) {\n         \
    \       $max = $l->[$n];\n            }\n        } else {\n            $max =\
    \ $l->[$n];\n        }\n        ++$i;\n    }\n    return $max;\n}", "    my $max\
    \ = -1;\n    for my $x (@$l) {\n        $max = $x if $x > $max;\n    }\n    return\
    \ $max;\n}\n</code>\n<|/ a tags=perl,arrays |>\n<| a |>\n<code>\nmy=qw(1 2 3 4\
    \ 5);", "    my $max = -1;\n    for (my $i = 0; $i < @$l; ++$i) {\n        $max\
    \ = $1 if $l->[$i] > $max;\n    }\n    return $max;\n}", "    my ($i, $j, @m,\
    \ @m);\n    for (@$l) {\n        $m[$_] = $m[$_] if ($m[$_] != 0);\n        $m[$_]\
    \ =\n            if ($m[$_] > $m[$_]) {\n                $m[$_];\n           \
    \ } else {\n                $m[$_];\n            }\n    }\n    for ($i = 0; $i\
    \ < @m; $i++) {\n        $m[$i] =\n            if ($m[$i] < $m[$j]) {\n      \
    \          $m[$i];\n            } else {\n                $m[$j];\n          \
    \  }\n    }\n    return $m[$j];\n}", "    my $max = @$l > 0 ? $l->[-1] : 0;\n\
    \    foreach (@$l) {\n        $max = $_ if $_ > $max;\n    }\n    return $max;\n\
    }", "    my $max = @$l > 0 ? $l->[-1] : undef;\n    $max //= 0;\n    @$l = (@$l\
    \ > 0 ?) ? grep { $_ > $max } @$l : ();\n    wantarray ? @$l : $max;\n}", "  \
    \  my $max;\n    if (@$l == 0) {\n        return 0;\n    }\n    my $n = scalar\
    \ @$l;\n    for my $i (0 .. $n-1) {\n        if ($l->[$i] > $max || ($l->[$i]\
    \ == $max && ($i < ($n-1)))) {\n            $max = $l->[$i];\n        }\n    }\n\
    \    return $max;\n}", '    my($largest);', "    my $max = undef;\n    my $i;",
  "    my $max;\n    my $min;\n    for (my $i = 0; $i < @$l; $i++) {\n        $min\
    \ = $max if $max < $l->[$i];\n        $max = $l->[$i] if $min > $l->[$i];\n  \
    \  }\n    return $min;\n}", "    if (@$l == 0) {\n        return 0;\n    }\n \
    \   if (@$l == 1) {\n        return $l->[0];\n    }\n    my $max = @$l > 0 ? $l->[0]\
    \ : 0;\n    my $max_index = 0;\n    foreach my $i (0 .. $#l) {\n        if ($l->[$i]\
    \ > $max) {\n            $max = $l->[$i];\n            $max_index = $i;\n    \
    \    }\n    }\n    return $l->[$max_index];\n}", "    my $max;\n    my $maxi =\
    \ 0;\n    foreach my $i (0..$#$l) {\n        return $i if $maxi == 0 or $l->[$maxi]\
    \ <= $l->[$i];\n        $max = $l->[$i] if $l->[$i] > $max;\n        $maxi = $i;\n\
    \    }\n    return $l->[$maxi];\n}", "    my $m = $l->[0];\n    while (1) {\n\
    \        my $c = $l->[1];\n        last if $c < 0;\n        $m = $c if $m >= $c;\n\
    \        $l->[1] = $c if $c > $m;\n    }\n    return $m;\n}", "    if (@$l ==\
    \ 0) {\n        return 0;\n    }\n    if (@$l == 1) {\n        return $l->[0];\n\
    \    }\n    my(@m) = ($l->[0], $l->[1]);\n    for my $i (@$l) {\n        if ($m->[0]\
    \ > $i) {\n            $m->[0] = $i;\n        }\n        if ($m->[1] > $i) {\n\
    \            $m->[1] = $i;\n        }\n    }\n    $m->[0] =~ s/^0+//;\n    $m->[1]\
    \ =~ s/^0+//;\n    return $m->[0];\n}", "    my ($i, $max) = @_;\n    for ($i\
    \ = 0; $i <; $i++) {\n        return $max if $max < $l->[$i];\n        $max =\
    \ $l->[$i];\n    }\n    return $max;\n}", "    my $max = sort { $a <=> $b } @$l;\n\
    \    return $max->[0] if @$max;\n    return;\n}", "    return undef unless @$l\
    \ > 0;\n    return $l[0] if @$l > 1;\n    my $m = $l[0];\n    for(my $i = 1; $i\
    \ < @$l; $i++) {\n        return undef if $l[$i] < $m;\n        $m = $l[$i] if\
    \ $l[$i] > $m;\n    }\n    return $m;\n}", '    my ($max, $index) = (0, -1);',
  "    if (@$l == 0) {\n        0;\n    } else {\n        my ($max, $i) = (0, -1);\n\
    \        for (my $i = 0; $i <= $#$l; $i++) {\n            if ($l->[$i] > $max)\
    \ {\n                $max = $l->[$i];\n            }\n        }\n        return\
    \ $max;\n    }\n}", "    my $m = 0;\n    foreach my $item (@$l) {\n        return\
    \ $item if $item > $m;\n        $m = $item;\n    }\n    return $m;\n}", "    my\
    \ $x = 0;\n    my $max = undef;\n    while(@_) {\n        if($l[$x] > $max) {\n\
    \            $max = $l[$x];\n        }\n        $x++;\n    }\n    return $max;\n\
    }\n</code>\n<|/ a |>\n<| a |>\nIf it needs to be O(n), you probably want to use\
    \ nth_element() instead of sort().  It is O(n) by comparison.  If you sort it,\
    \ it takes O(n*log(n)), but nth_element() does it by comparison in O(n).\n<|/\
    \ a tags=perl,sorting,arrays dscore=0 |>\n<| a tags=perl,sorting,arrays dscore=0\
    \ |>\n<code>", "    my($result) = -1;\n    my($max_value) = -1;\n    foreach my\
    \ $value (@$l) {\n        if ($result < $value) {\n            $result = $value;\n\
    \        }\n        if ($result > $max_value) {\n            $max_value = $result;\n\
    \        }\n    }\n    return $max_value;\n}", "    my $max;\n    my $i;\n   \
    \ for(my $i=0; $i<@$l; ++$i) {\n        if ($max == $l->[$i]) {\n            ++$i;\n\
    \        }\n        elsif ($l->[$i] > $max) {\n            $max = $l->[$i];\n\
    \        }\n    }\n    return $max;\n}", "    $l->[0] if $l->[0] == 0;\n    return\
    \ $l->[$l->[0] - 1] if $l->[0] != 0;\n    my($j, $t);\n    for ($j = 1; $j < $l->[0];\
    \ $j++) {\n        $t = $l->[$j];\n        if ($t > $l->[$j - 1]) {\n        \
    \    $l->[$j] = $t;\n        } else {\n            $l->[$j - 1] = $t;\n      \
    \  }\n    }\n    $l->[0];\n}", "    my $max = @$l > 0 ? $l->[0] : undef;\n   \
    \ for (@$l) {\n        if ($_ gt $max) {\n            $max = $_;\n        }\n\
    \    }\n    return $max;\n}", "    return $l->[0] if @$l > 1;\n    return $l->[0]\
    \ if @$l == 1;\n    return $l->[-1] if @$l < 0;\n    return $l->[-1] if @$l ==\
    \ 0;\n    return;\n}", "    my $max = pop($l);\n    while (@_ > 0) {\n       \
    \ my $x = pop($l);\n        $max = $x if ($x > $max);\n    }\n    return $max;\n\
    }", '    my ($max, $max_index);', '    my $n = scalar @$l;', "    my $max = pop\
    \ @$l;\n    foreach my $item (@$l) {\n        if($item > $max) {\n           \
    \ $max = $item;\n        }\n    }\n    return $max;\n}", "    my $max = $l[0];\n\
    \    my $i;\n    for($i = 1; $i <= @_; $i++) {\n        my $x = $l[$i];\n    \
    \    $max ||= $x;\n        $max >= $x ? $max = $x : undef;\n    }\n    return\
    \ $max;\n}\n</code>\n<|/ a dscore=2 tags=algorithm,perl |>\n<| a |>\nI wrote a\
    \ perl script that uses two hash tables. One hash table tracks the counts of all\
    \ the prime numbers less than or equal to a given number N and the other hash\
    \ table keeps track of the prime numbers less than N. The count table can be used\
    \ to determine if a given number is prime or not. Here's the script:\n<code>",
  "    my $i;\n    for ($i = 0; $i < @$l; $i++) {\n        my $x = $l->[$i];\n   \
    \     if ($x != 0) {\n            if ($x > $l->[$i]) {\n                $x = $l->[$i];\n\
    \            }\n        }\n    }\n    return $x;\n}", "    my ($max, $maxi) =\
    \ (0, 0);\n    for (my $i = 0; $i < @$l; $i++) {\n        if ($l->[$i] > $max)\
    \ {\n            $max = $l->[$i];\n            $maxi = $i;\n        }\n    }\n\
    \    return $l->[$maxi];\n}", "    my $max = ${$l}->[0];\n    for (my $i = 1;\
    \ $i <= ${$l}->[0]; $i++) {\n        if (${$l}->[$i] > $max) {\n            $max\
    \ = ${$l}->[$i];\n        }\n    }\n    return $max;\n}", '    my $max_element;',
  "    my($lref);\n    my($result);", "    my $max = @$l > 1 ? $l->[-1] : 0;\n   \
    \ foreach my $x (reverse @$l) {\n        if($x > $max) {\n            $max = $x;\n\
    \        }\n    }\n    return $max;\n}\n</code>\nI didn't test it on all possible\
    \ cases, but it works on all the ones I tried.\n<|/ a |>\n<| c |>\nI think this\
    \ code is too complicated for the task, because it performs O(N^2) comparisons.\
    \ It's good to know about this `max_element` function, but I think the original\
    \ problem was about the average of array elements. In that case I don't think\
    \ the original code can get better.\n<|/ c |>\n<| c |>\n, it's not O(n^2) comparisons,\
    \ it's O(n) comparisons, because you only look at every 2nd element in the array.\
    \ In other words the O(n log n) version takes log(n) comparisons even though you\
    \ only need to look at every 2nd element, while O(n^2) takes n^2 comparisons.\
    \ Also it works better on very small lists because O(n^2) is only better than\
    \ O(n) if you can do it in O(n) time by comparing pairs of elements (as you can\
    \ see in my code)\n<|/ c |>\n<| c |>\nYou are right, it's O(n) comparisons. My\
    \ bad. I just noticed you changed the code a bit. Not sure if you meant to do\
    \ that. Anyway, your code is not O(n), it's O(n^2). And you still need to compare\
    \ every element in the array, but you only compare every 2nd element.\n<|/ c |>\n\
    <| a dscore=4 |>\n<code>\nuse Algorithm::Loops qw( loop_array );", "    my($r)\
    \ = @_;\n    my($v) = undef;\n    foreach $v (@$l) {\n\tnext unless defined $v;\n\
    \t$r->[0] = $v if ($v >= $r->[0]);\n    }\n    $r;\n}", "    my $max = -1;\n \
    \   for (@_) {\n        $max = $_ if $_ > $max;\n    }\n    return $max;\n}",
  "    my($max, $max_index);\n    for (my $i = 0; $i < @$l; ++$i) {\n        if ($l->[$i]\
    \ > $max) {\n            $max = $l->[$i];\n            $max_index = $i;\n    \
    \    }\n    }\n    return $l->[$max_index];\n}", '    my($max);', "    my $result\
    \ = $l[0];\n    for (@$l) {\n        if($_ > $result) {\n            $result =\
    \ $_;\n        }\n    }\n    return $result;\n}", "    my $largest = 0;\n    for(my\
    \ $i = 0; $i < $#l; $i++) {\n        next unless $l->[$i] > $largest;\n      \
    \  $largest = $l->[$i];\n    }\n    return $largest;\n}", "    my $max = @$l ==\
    \ 1 ? $l->[0] : undef;\n    foreach (@$l) {\n        $max = $_ if $max < $_;\n\
    \    }\n    $max;\n}", "    my ($i, $max);\n    foreach $i (@$l) {\n\t$max = $i\
    \ if $i gt $max;\n    }\n    return $max;\n}", "    my $max;\n    for (@$l) {\n\
    \        $max = $_ if !defined $max || $max > $_;\n    }\n    $max;\n}", "   \
    \ my $l = @$l;\n    return $l if $l > 1;\n    my $lmax = $l > $l[0] ? $l : $l[0];\n\
    \    while ($lmax > 0) {\n        my $rmax = max_element(@$l);\n        $lmax\
    \ -= $rmax;\n        $lmax += $lmax > $rmax ? $rmax : $lmax;\n    }\n    return\
    \ $lmax;\n}", "    return $l[@_ > 0 ? $_[0] : @$l - 1];\n}", "    my $max = @$l\
    \ > 0 ? $l->[0] : 0;\n    for my $x (@$l) {\n        $x = $x > $max ? $x : $max;\n\
    \    }\n    return $max;\n}", "    my $min;\n    my $max;", "    # Sort by value\
    \ so max_element returns the largest.\n    sort {$a <=> $b} @$l;\n    return $l[0];\n\
    }", "    return $l[0] if @$l < 1;\n    for (my $i = 1; $i < @$l; $i++) {\n   \
    \     if ($l->[$i] > $l->[$i - 1]) {\n            shift @$l;\n            return\
    \ $l->[$i];\n        }\n    }\n    return $l->[0];\n}", "    my $max = ${$l}[0];\n\
    \    my $i = 0;\n    for my $i (0..$#$l) {\n        my $v = $l->[$i];\n      \
    \  if ($v > $max) {\n            $max = $v;\n        }\n    }\n    return $max;\n\
    }", "    my $max = -1;\n    for(my $i = 0 ; $i < @$l ; $i++) {\n        my $current\
    \ = $l->[$i];\n        if ($current > $max) {\n            $max = $current;\n\
    \        }\n    }\n    return $max;\n}", '    my @maxes = ();', "    my @a = @$l;\n\
    \    my $m = amax(@a);\n    for(my $i = 0; $i < @a; $i++) {\n        if ($a[$i]\
    \ > $m) {\n            $m = $a[$i];\n        }\n    }\n    return $m;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis is an interesting approach but unfortunately\
    \ it's O(N) which isn't ideal for my application. Thanks for the suggestion!\n\
    <|/ c |>\n<| a tags=perl |>\nAs the other answers have mentioned, there's nothing\
    \ in perl to do this. However, if you're willing to use Perl modules, you should\
    \ be able to create something that works quite well. \nThe module List::Util has\
    \ an extremely useful function called merge_sort, which can take an arbitrary\
    \ number of arrays, and apply a merge sort algorithm to them all in O(N*Log(N)).\
    \ \nThe code would look something like this: \n<code>\nuse List::Util qw(:all);",
  "    my $max_element = -1;\n    my $max_element_idx = 0;\n    for (my $i = 0; $i\
    \ < @$l; $i++) {\n        my $el = $l->[$i];\n        if ($max_element < 0) {\n\
    \            $max_element = $el;\n            $max_element_idx = $i;\n       \
    \ } elsif ($el > $max_element) {\n            $max_element = $el;\n          \
    \  $max_element_idx = $i;\n        }\n    }\n    return $max_element;\n}", " \
    \   my $max = $l->[0];\n    for (my $i = 1; $i < @$l; $i++) {\n        if ($l->[$i]\
    \ > $max) {\n            $max = $l->[$i];\n        }\n    }\n    return $max;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThat is quite nice and simple. Although it isn't\
    \ as fast as using sorting.\n<|/ c |>\n<| c |>\n: Actually, sorting a list is\
    \ faster than iterating through it only once (though still faster than `max` as\
    \ long as `sort` does not have to move the element around). However, that is the\
    \ case for most algorithms, not for yours.\n<|/ c |>\n<| c |>\n: I agree with\
    \ you, it is true that sorting is the most efficient solution here.\n<|/ c |>\n\
    <| c |>\n: Yes, you are right, I have corrected my comment about the second solution.\
    \ I was thinking about `max`, but didn't realize that it is actually a wrapper\
    \ around `sort`.\n<|/ c |>\n<| c |>\n: That is true, but since we do not need\
    \ to move anything around, the complexity of `max` does not make much sense. The\
    \ complexity of a sorting algorithm is basically a multiplication of the number\
    \ of elements to sort, the complexity of an iterating algorithm is generally a\
    \ square (`O(n)`).\n<|/ c |>\n<| a tags=arrays,perl,max |>\n<code>\nmy $max =\
    \ 0;", "    return $l[0] if @$l == 0;\n    my($first) = $l[0];\n    my $max =\
    \ $first;\n    foreach (@$l) {\n        $max if $max > $_;\n    }\n    return\
    \ $max;\n}\n</code>\n<|/ a |>\n<| c |>\n`return $l[0] if @$l == 0;` can be simplified\
    \ to `return $l[0] if @$l > 0;` - `0` evaluates to `False` in boolean context.\
    \ Also, you have a typo at `return $max if $max > $_;`\n<|/ c |>\n<| c |>\n: thank\
    \ you, fixed typo, didn't noticed it\n<|/ c |>\n<| c |>\nI think you have a typo\
    \ in the last line of the loop: `return $max` if $max > $_;`\n<|/ c |>\n<| c |>\n\
    `sub max_element { my($l) = @_; return $l[0] if @$l == 0; my($first) = $l[0];\
    \ my $max = $first; foreach (@$l) { for ($max if $max > $_); } return $max; }`\
    \ would be more efficient and shorter\n<|/ c |>\n<| c |>\n: You are right, I didn't\
    \ realize this before, will update answer\n<|/ c |>\n<| a |>\nHere are some benchmarks:\n\
    <code>\nuse strict;\nuse warnings;\nuse Benchmark qw(cmpthese);", "    my $max\
    \ = undef;\n    foreach my $i (@$l) {\n        next unless defined $max;\n   \
    \     $max = $i if $i > $max;\n    }\n    return $max;\n}", "    my ($max, $min)\
    \ = @_;\n    for(my $i = $#$l; $i >= 0; $i--) { $max = $max > $l->[$i] ? $max\
    \ : $l->[$i]; }\n    for(my $i = $#$l; $i >= 0; $i--) { $min = $min < $l->[$i]\
    \ ? $min : $l->[$i]; }\n    return $max;\n}", "    my $max = redo;\n    $max =\
    \ -1 unless @$l;", "    my $max = @$l > 0 ? $l[0] : undef;\n    for my $x (@$l)\
    \ {\n        if ($x > $max) {\n            $max = $x;\n        }\n    }\n    return\
    \ $max;\n}", '    return $l->[@_] unless @$l == 0;', "    my($max, $i);\n    $max\
    \ = $l->[0] if @$l > 0;\n    foreach my $n (@$l) {\n        $i = $n if $n > $max;\n\
    \        $max = $n if $i < $n;\n    }\n    $max;\n}", "    my $max = -1;\n   \
    \ foreach my $x (@$l) {\n        defined $max && $max < $x ? $max : $x = $max;\n\
    \    }\n    $max;\n}", "    my $result;\n    my $max;\n    my $length = @$l;\n\
    \    for my $index (0..$length-1) {\n        if ($index == 0 || $l->[$index] >$max)\
    \ {\n            $max = $l->[$index];\n            $result = $index;\n       \
    \ }\n    }\n    return $result;\n}\n</code>\n<|/ a |>\n<| a |>\nThe solution given\
    \ by Tony Weng has two problems:", "    if (@$l == 0) {\n        return 0;\n \
    \   }\n    my $max = pop(@$l);\n    for (@_) {\n        if ($_ > $max) {\n   \
    \         $max = $_;\n        }\n    }\n    return $max;\n}", "    my $result;\n\
    \    my $max = -1;\n    for(my $i=0; $i<@$l; $i++) {\n        if($max == -1 ||\
    \ $l->[$i] > $l->[$i]) {\n            $max = $i;\n        }\n    }\n    return\
    \ $l->[$max];\n}", "    my(@r) = ();\n    for(my $i = $l-1; $i >= 0; $i--) {\n\
    \        if($l[$i] >= $l[$i-1]) {\n            push(@r, $l[$i]);\n        } else\
    \ {\n            last;\n        }\n    }\n    return @r;\n}", "    my $ret = undef;\n\
    \    my $max = @$l > 0 ? $l->[0] : $l->[-1];", "    my($result) = (undef);\n \
    \   my($max_val) = (0, undef);\n    foreach my $ele ($l) {\n        $max_val =\
    \ undef\n            if (defined $max_val and $max_val < $ele);\n        $result\
    \ = $ele if defined $max_val and $max_val < $ele;\n    }\n    return $result;\n\
    }", "    return $l[0] if $l[0] gt $l[-1];\n    return;\n}", "    my ($max, $maxi,\
    \ $val);\n    foreach my $i (0 .. $#$l) {\n        my $val = $l->[$i];\n     \
    \   if ($val > $max) {\n            $max = $val;\n            $maxi = $i;\n  \
    \      }\n    }\n    return $max;\n}", "    my($max, $index) = @$l[0];\n    for\
    \ (my $i = 1; $i < @$l; $i++) {\n        if ($max < $l->[$i]) {\n            $max\
    \ = $l->[$i];\n        }\n    }\n    $l->[$index] = $max;\n    return $max;\n}",
  "    my $i;\n    my $max = $l->[0];\n    foreach $i (@$l) {\n        $max = $_ if\
    \ $max > $_;\n    }\n    return $max;\n}", "    if (@$l == 0) {\n        return\
    \ 0;\n    }\n    my($max) = $l[0];\n    foreach my $x (@$l) {\n        if ($x\
    \ > $max) {\n            $max = $x;\n        }\n    }\n    return $max;\n}", " \
    \   my $max = $l->[0];\n    for my $ele (@$l) {\n        if ($ele > $max) {\n\
    \            $max = $ele;\n        }\n    }\n    return $max;\n}", "    if (@$l\
    \ < 1) {\n        return;\n    }\n    my $l = @$l;\n    my $max = $l->[0];\n \
    \   my $min = $l->[0];\n    foreach my $i (0..$l-1) {\n        if ($min->[0] >\
    \ $i->[0]) {\n            $min = $i;\n        } elsif ($max->[0] < $i->[0]) {\n\
    \            $max = $i;\n        }\n    }\n    return $min;\n}", "    my $max\
    \ = $l->[0];\n    foreach (@$l) {\n        $max = $_ if $max<$_;\n    }\n    return\
    \ $max;\n}", "    my @m;\n    my $max;\n    my $idx;\n    my $maxidx = 0;\n  \
    \  $max = $l->[0]->[0];\n    for my $i (0..$#{$l}) {\n        if ($l->[$i] ->\
    \ [0] > $max) {\n            $max = $l->[$i] -> [0];\n            $maxidx = $i;\n\
    \        }\n    }\n    foreach my $i (0..$#{$l}) {\n        if ($i eq $maxidx)\
    \ {\n            $m[$i] = $l->[$i];\n        } else {\n            $m[$i] = $l->[$i];\n\
    \        }\n    }\n    return @m;\n}", "    my $max = 0;\n    foreach (@$l) {\n\
    \        $max = 1 if ($max < $_);\n    }\n    return $max;\n}", "    my $max =\
    \ ${$l}[0];\n    foreach my $ele (${$l}[1..${$l}-1]) {\n        $max = $ele if\
    \ $ele > $max;\n    }\n    return $max;\n}", "    my $m = $l->[0];\n    my $j\
    \ = 0;\n    my $n = scalar(@$l);\n    for(my $i = 1;$i <= $n;$i++) {\n       \
    \ if($l->[$i] < $m) {\n            $m = $l->[$i];\n            $j = $i;\n    \
    \    }\n    }\n    return $m;\n}", "    my($mx) = $l[0];\n    $mx = 0;\n    foreach\
    \ my $i (@$l) {\n        if($i > $mx) {\n            $mx = $i;\n        }\n  \
    \  }\n    return $mx;\n}", "    my $max = undef;\n    my $tmp;\n    $tmp = $l[0];\n\
    \    foreach my $i (1 .. $#l) {\n        if ($tmp >= $l[$i]) { $tmp = $l[$i];\
    \ }\n    }\n    $max = $tmp;\n    return $max;\n}", "    my $max = delete $l->[0];\n\
    \    delete $l->[0] if @$l == 1;\n    $max;\n}", "    my $max = $l[0];\n    $max\
    \ == $l[0] ? $max : foreach {$max <=> $_ } @$l;\n    $max;\n}", "    my $max =\
    \ lc($l[0]);\n    for my $v (@$l) {\n        $max = lc($v) if $v > $max;\n   \
    \ }\n    return $max;\n}", "    my $max = @$l > 0 ? $l->[0] : undef;\n    for\
    \ my $value (@$l) {\n        defined $max and $max < $value or $max = $value;\n\
    \    }\n    return $max;\n}", "    my $max = -1;\n    foreach my $n (@$l) {\n\
    \        if ($n > $max) {\n            $max = $n;\n        }\n    }\n    return\
    \ $max;\n}", "    my $max = undef;\n    foreach my $el (@$l) {\n        if ($el\
    \ > $max) {\n            $max = $el;\n        }\n    }\n    return $max;\n}",
  "    if (@$l == 0) {\n        return;\n    }\n    my $max = pop(@$l);\n    for (@$l)\
    \ {\n        if ($_ > $max) {\n            $max = $_;\n        }\n    }\n    return\
    \ $max;\n}", "    my $max = -1;\n    foreach my $i (@$l) {\n        if ($i > $max)\
    \ {\n            $max = $i;\n        }\n    }\n    return $max;\n}", "    my $max\
    \ = $l[0];\n    my $i = 0;\n    for(my $i = 1; $i < @$l; $i++) {\n        if($l[$i]\
    \ > $max) {\n            $max = $l[$i];\n        }\n    }\n    return $max;\n}",
  "    $l = sort {$a <=> $b} @$l;\n    return $l[0];\n}", "    my $max = pop($l);\n\
    \    for(my $i = 0; @$l > 0 ; $i++) {\n        if( $_[$i] >  $max ) {\n      \
    \      $max = $_[$i];\n        }\n    }\n    return $max;\n}", "    return undef\
    \ unless @$l > 1;\n    my($head, $rest) = @$l;\n    return $head if $head > 0;\n\
    \    return $rest->[0];\n}", "    my $cmp = $l->[0] <=> $l->[1];\n    my $i =\
    \ 0;\n    while ($i < @$l && $cmp == 0) {\n        $cmp = $l->[$i++] <=> $l->[$i];\n\
    \    }\n    $cmp == 0 ? @$l : $i - 1;\n}", "    my ($max, $elem) = grep(defined\
    \ $max, $l ? grep($_, $l) : ());\n    defined $max ? ($elem = $max > $elem ? $max\
    \ : $elem)\n               : ($elem = $l->[0] eq $l->[-1] ? $l->[0] : $l->[-1]);\n\
    \    return $elem;\n}", "    my($max_element) = $l[0];\n    for(my $i = 1; $i\
    \ < @$l; $i++) {\n        if($l[$i] > $max_element) {\n            $max_element\
    \ = $l[$i];\n        }\n    }\n    return $max_element;\n}", "    my $max = @$l\
    \ ? $l->[-1] : 0;\n    return $max;\n}", "    my($max_el, $el_el, $el_el_el, $el_el_el_el);\n\
    \    my $retval = undef;\n    foreach my $val (@$l) {\n        if (!defined $retval\
    \ || $retval->[0] lt $val) {\n            $retval = undef;\n        }\n      \
    \  elsif (!defined $retval || $retval->[0] > $val) {\n            $retval = undef;\n\
    \        }\n        elsif ($retval->[0] === $val) {\n            $retval = undef;\n\
    \        }\n        else {\n            $retval = &_max_element($el_el, $el_el_el,\
    \ $el_el_el_el);\n            $retval = (($retval->[0] == $val) ? undef : $retval);\n\
    \        }\n    }\n    return $retval;\n}", "    $l->[0] > ($l->[1]) ? $l->[0]\
    \ : $l->[1];\n}", "    return $l == 0 ? 0 : $l->[0];\n}", "    $l > 1 ? $l->[-1]\
    \ : undef;\n}", "    return $l if @$l < 1;\n    my $max = delete $l->[0];\n  \
    \  $max = delete $l->[$#l] \n        unless $l->[$#l] eq 0;\n    foreach my $i\
    \ (reverse 0 .. $#l - 1) {\n        $max = $l->[$i] if $l->[$i] <= $max;\n   \
    \ }\n    return $max;\n}", "    my $max = -1;\n    my $min;\n    my $idx;\n  \
    \  for (my $i = 0; $i < @$l; $i++) {\n        $max = $i if $max < $l->[$i];\n\
    \        $min = $i if $min > $l->[$i];\n    }\n    return $max if $min == -1;\n\
    \    return $min if $max == -1;\n    return $l->[$idx] if $min > $max;\n    return\
    \ $l->[$idx] if $min < $max;\n    $idx++;\n    return $l->[$idx] if $l->[$idx]\
    \ > $l->[$idx+1];\n    $idx++;\n    return $l->[$idx] if $l->[$idx] < $l->[$idx+1];\n\
    }", "    if (@$l > 0) {\n        my $min = $l->[0];\n        $l->[0] = $l->[-1];\n\
    \        $l->[-1] = $min;\n        $min;\n    } else {\n        undef;\n    }\n\
    }", "    my($i, $max);\n    for (my $i = 0; $i < @$l; $i++) {\n        if ($max\
    \ < $l->[$i]) { $max = $l->[$i]; }\n    }\n    return $max;\n}", "    my $min\
    \ = undef;\n    my $max = $l[0];\n    foreach my $e ($l) {\n        if (defined\
    \ $min and $e > $min) {\n            $max = $e;\n        }\n        elsif (defined\
    \ $min and $e < $min) {\n            $min = $e;\n        }\n    }\n    return\
    \ $max;\n}", "    local $Math::BigInt::config->{lib} = $Math::BigInt::Config::LIB_FAST;\n\
    \    local $Math::BigInt::config->{upgrade} = $Math::BigInt::Config::UPGRADE_NO;\n\
    \    local $Math::BigInt::config->{downgrade} = $Math::BigInt::Config::DOWNGRADE_NO;\n\
    \    my $n = scalar @$l;\n    my $i = 0;\n    my $max = $l->[$i];\n    for (my\
    \ $j = $i+1; $j < $n; $j++) {\n        $max = $l->[$j] if $l->[$i] > $l->[$j];\n\
    \    }\n    $max;\n}", "    my $max_el = undef;\n    foreach (@$l) {\n       \
    \ return $max_el if (defined $max_el && $max_el > $_);\n        $max_el = $_;\n\
    \    }\n    return $max_el;\n}", "    my $max = $l->[0];\n    my $cmp;", "   \
    \ my $max = -1;\n    my (@min, $idx);\n    for (@$l) {\n        if ($max < $_\
    \ ) {\n            $max = $_;\n            ($idx) = $_ == $max ? @min : (@min,\
    \ 0);\n        } elsif ($_ == $max) {\n            ($idx) = (@min, 0);\n     \
    \   } else {\n            ($idx) = ($idx+1, @$l[$idx..$#$l].$#$l[$idx]+1);\n \
    \       }\n    }\n    return $max;\n}", "    my $l = $l;\n    my $max;\n    while\
    \ (@_) {\n        my $e = pop @_;\n        if ($e > $max) {\n            $max\
    \ = $e;\n        }\n    }\n    $max;\n}", "    local @$l;\n    $$l =\n       \
    \ sort {\n            my $a = $_->[0];\n            my $b = $_->[1];\n       \
    \     $a <=> $b\n        } @$l;\n    return $l[0]->[1]\n}", '    if (@$l == 0)
    { return; }', "    my $max = @$l > 0 ? $l->[0] : \"NaN\";\n    foreach my $i (@$l)\
    \ {\n        $max = $i if $i > $max;\n    }\n    return $max;\n}", "    my $m\
    \ = $l->[-1];\n    for my $n (reverse @$l) {\n        my $m = $n if $n < $m;\n\
    \    }\n    $m;\n}", "    my($max);\n    foreach (@$l) {\n        if (defined\
    \ $max) {\n            if ($_ > $max) {\n                $max = $_;\n        \
    \    }\n        } else {\n            $max = $_;\n        }\n    }\n    return\
    \ $max;\n}", "    my ($max, $max_index);\n    my $len = @$l;\n    for (my $i =\
    \ 0; $i < $len; $i++) {\n        if ($max == $l->[$i]) {\n            $max_index\
    \ = $i;\n        }\n        elsif ($l->[$i] > $max) {\n            $max = $l->[$i];\n\
    \            $max_index = $i;\n        }\n    }\n    return $max_index;\n}", " \
    \   if (@$l == 0) {\n        return 0;\n    }", '    my $max = -1;', "    my $max\
    \ = -1;\n    for (@$l) {\n        $max = $_ if $max < $_;\n    }\n    return $max;\n\
    }", "    my ($max, $maxi) = (0, 0);\n    for ($i = 0; $i < @$l; ++$i) {\n    \
    \    if ($maxi < $l->[$i]) {\n            $max = $l->[$i];\n            $maxi\
    \ = $i;\n        }\n    }\n    return $max;\n}", "    my $n = @$l;\n    my $max\
    \ = sort { $a <=> $b } @$l;\n    return $max eq '-inf' ? '-inf' : $max;\n}", " \
    \   my ($i, $max_el) = @_;\n    if ($l->[$i] > $max_el) {\n        $max_el = $l->[$i];\n\
    \    }\n    return $max_el;\n}\n</code>\n<|/ a tags=perl,sorting,arrays |>\n<|\
    \ c |>\nNot sure why this was downvoted, because it was exactly what I was looking\
    \ for, and it wasn't just an example of an algorithm. I wish more people would\
    \ do this. Thanks so much for taking the time to write this out. Much appreciated.\n\
    <|/ c |>\n<| c |>\nIt was a bad idea to ask for an algorithm without providing\
    \ one. Sometimes a good answer is \"use a module\". Other times it is more efficient\
    \ to use an algorithm in one language and write the code in the other. The reason\
    \ I did it this way was because I wanted to show the OP the best practice way\
    \ of writing Perl code. It was a little bit of a challenge to write it in a comment.\
    \ :)\n<|/ c |>\n<| c |>\nI see. Thanks for the explanation. I was getting frustrated\
    \ with trying to get this to work.\n<|/ c |>\n<| c |>\nThe thing that's baffling\
    \ me is that this does **not** return the largest number. I get `-5 10` when I\
    \ run `max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])`\n<|/ c |>\n<| c |>\n\
    It is not guaranteed that it will return the highest number in an array. See the\
    \ documentation for [`sort`](http://perldoc.perl.org/functions/sort.html).\n<|/\
    \ c |>\n<| a |>\n<code>", "    my ($max, $key) = @{$l}[0,0];\n    map {$max =\
    \ $_ if $max<$_} @$l;\n    return $max;\n}", "    $l =~ s/^-//;\n    return $l->[-1];\n\
    }", "    my $lc = length($l);\n    my $max = -1;\n    my @m;\n    my $i;\n   \
    \ for (my $j = 0; $j < $lc; ++$j) {\n        my $x = $l[$j];\n        if ($x !=\
    \ 0) {\n            $m = map {$_ if $x < $_} @$m;\n            if ($max < 0) {\n\
    \                $max = $x;\n                $i = $j;\n            }\n       \
    \     else {\n                if ($x > $max) {\n                    $max = $x;\n\
    \                    $i = $j;\n                }\n            }\n        }\n \
    \   }\n    die \"max_element() expects array as first argument\" unless @$l;\n\
    \    $l[$i] = $max if $max >= 0;\n    return @$l;\n}", "    return $l->[0] if\
    \ $l->[0] > $l->[1];\n    return $l->[1];\n}", '    my $l = @$l > 1 ? @$l : 1;',
  "    if (@$l == 0) {\n        return;\n    }\n    my $max = @$l > 0 ? $l[0] : 0;\n\
    \    for my $i (1..$#l) {\n        if ($l[$i] > $max) {\n            $max = $l[$i];\n\
    \        }\n    }\n    return $max;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
