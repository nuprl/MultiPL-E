name: HumanEval_23_strlen
language: pl
prompt: "# Return length of given string\n# >>> strlen(\"\")\n# 0\n# >>> strlen(\"\
  abc\")\n# 3\nsub strlen {\n    my($string) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&strlen;\n\
  \        if(eq_deeply($candidate->(\"\"),0)) {\n        print \"ok!\" }else{\n \
  \       exit 1;\n        }\n        if(eq_deeply($candidate->(\"x\"),1)) {\n   \
  \     print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  asdasnakj\"),9)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\
  \ntesthumaneval();"
completions: ["    $string =~ tr/\\0//d;\n    return scalar length($string);\n}",
  "    my $length = 0;\n    for (split //, $string) {\n        $length++;\n    }\n\
    \    return $length;\n}", "    substr($string, 0, length($string))\n}", "    my\
    \ $len = 0;\n    for (split //, $string) {\n        $len += length($_);\n    }\n\
    \    return $len;\n}", "    return length($string);\n}", "    my $len = length($string);\n\
    \    return $len;\n}", "    return 0 if length $string;\n    return $string =~\
    \ tr/\\0//ds;\n}", "    if (defined $string) {\n        return length $string;\n\
    \    }\n    else {\n        return 0;\n    }\n}", "    if (defined $string) {\n\
    \        return length($string);\n    } else {\n        return 0;\n    }\n}",
  "    length($string);\n}", "    $string =~ tr/\\0//d;\n    return length $string;\n\
    }", "    return length($string);\n}", "    length $string if defined $string;\n\
    }", "    $string =~ tr/\\0//d; # Remove null characters\n    return length($string);\n\
    }", "    length $string;\n}", "    $string =~ tr/\\0//d;\n    return length($string);\n\
    }", '    my $length = 0;', "    if ($string =~ /^([a-zA-Z]+)$/) {\n        return\
    \ $1;\n    } else {\n        return 0;\n    }\n}", "    my $length = 0;\n    if\
    \ (defined($string)) {\n\t$string =~ tr/\\0//d;\n\t$length = length($string);\n\
    \    }\n    return $length;\n}", "    return 0 if !defined($string);\n    return\
    \ length($string);\n}", "    return length($string);\n}", "    $string =~ s/^$string//;\n\
    \    return length($string);\n}", "    if ($string !~ /\\A\\s*\\z/ && ! $string\
    \ =~ /\\A\\s*\\Z/) {\n        return 0;\n    }\n    $string =~ tr/\\x00//cd;\n\
    \    $string =~ tr/\\x20//cD;\n    $string =~ tr/\\x0d//cd;\n    my $len = length($string);\n\
    \    $len += 1 if $string =~ /\\A\\s*$/;\n    $len -= 1 if $string =~ /\\A\\s+$/;\n\
    \    $len;\n}", "    if ( $string eq \"\" ) { return 0; }\n    my $length = 0;\n\
    \    while ( $string =~ s/^([\\w\\:\\.]+)(.*)$/\\1/g ) {\n        $length++;\n\
    \    }\n    return $length;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\nHere is my\
    \ one for Perl 6.\n<code>", "    my $len = length($string);\n    if (defined $string\
    \ && $string ne \"\") {\n        return $len;\n    }\n    return 0;\n}", "   \
    \ $string =~ tr/\\x00//cd;\n    return scalar @$string;\n}", "    if (defined\
    \ $string) {\n        my $length = 0;\n        for ($string) {\n            $length++;\n\
    \        }\n        return $length;\n    }\n    return 0;\n}", "    my $len =\
    \ 0;\n    while(length($string)) {\n        $len++;\n        $string =~ s/(^|.)(.+?)$/$1/s;\n\
    \    }\n    return $len;\n}", "    $string =~ tr/\\0//d;\n    $string =~ tr/\\\
    n//d;\n    return scalar(length($string));\n}", "    $string =~ tr/\\0//;\n  \
    \  return scalar($string);\n}", "    return 0 unless defined $string;\n    length($string);\n\
    }", "    my $len = length($string);\n    if ( $len == 0 ) {\n        $len = $string->isa('Peganzel::Utils::BitString')\n\
    \            ? $string->length\n            : 0;\n    }\n    return $len;\n}",
  "    my $len = length($string);\n    return $len if $len != -1;\n    return 0;\n\
    }", "    $string =~ s/^\\s+|\\s+$//g;\n    return length($string);\n}", "    my($len)\
    \ = 0;\n    my $len = length $string;\n    for(; $len < length($string) && $string[$len]\
    \ eq ' '; $len++)\n    { }\n    return $len;\n}\n</code>\n<|/ a tags=algorithm,perl,string,python\
    \ |>\n<| c |>\n\"The only real difference between the two is that Python returns\
    \ 0 when there are no spaces, whereas Perl does not\" \u2013 Well, not really;\
    \ Python returns `len(string)` when no spaces present, `string.count(string)`\
    \ when there are spaces present \u2013 `string.count(string, '')` when there are\
    \ no spaces present.\n<|/ c |>\n<| a tags=algorithm,perl,string,python dscore=3\
    \ |>\nPython and Perl have different string methods.\nIn Perl, if you need to\
    \ find and count the non-space characters of a string:\n<code>\nmy $s = \"abc\"\
    ;\n$s =~ s/\\s///g;\nmy $n = length($s);\n</code>\nIn Python, you can use str.replace()\
    \ to replace all occurrences of \\s with an empty string:\n<code>\n>>> 'abc'.replace('\
    \ ', '')\n'abc'\n>>> len('abc')\n3\n</code>\n<|/ a |>\n<| c |>\nI didn't down\
    \ vote you, but I'm guessing it's because this doesn't answer the question that\
    \ OP asked.\n<|/ c |>\n<| c |>\n: It's not my downvote but I'll let you do it.\
    \ I think it addresses the question asked.\n<|/ c |>\n<| c |>\nThanks, I thought\
    \ about that, but I think it's unnecessary.  It looks like he doesn't even care\
    \ about the extra spaces. He wants 0 as the answer when no spaces are found. \
    \ It would be better to leave the original string alone.  But you have a point\
    \ :)\n<|/ c |>\n<| c |>\nThis answer is more appropriate for the question at hand\
    \ than all of the other ones I have seen.\n<|/ c |>\n<| c |>\nIn Python, you can\
    \ use `str.replace()` to replace all occurrences of `\\s` with `''`, or you can\
    \ use the `strip()` method to remove spaces.\n<|/ c |>\n<| a dscore=3 tags=algorithm,perl,string,python\
    \ |>\nHere is a Python solution:\n<code>\nprint len(my_str.replace(\" \", \"\"\
    ))\n</code>\n<|/ a |>\n<| c |>\nIt's not really the same as the other answers,\
    \ but it's good to know about this one.  +1\n<|/ c |>\n<| a dscore=2 tags=algorithm",
  "    if (not defined $string) {\n        return 0;\n    }", '    return 0 if !defined
    $string;', '    return unless defined $string;', "    $string =~ tr/\\0//d;\n\
    \    return $string ? length($string) : 0;\n}", "    my $len = length($string);\n\
    \    return $len;\n}", "    ($string =~ tr/\\0//d) == length($string) ? $string\
    \ : undef;\n}", "    $string =~ tr/\\x00//d;\n    $string =~ tr/\\cK/0/d;\n  \
    \  length $string;\n}", "    my $length = 0;\n    my $bytes = 0;\n    my $char\
    \ = unpack(\"C*\", $string);\n    foreach my $value ($char) {\n        $bytes\
    \ ++;\n        $length += ($bytes == 1);\n    }\n    return $length;\n}", '    my
    $length = 0;', "    $string =~ tr/\\0//d;\n    length($string);\n}", "    my $len\
    \ = length($string);\n    $len > 0 ? $len : 0;\n}", "    \n    if (defined $string)\
    \ {\n        return length $string;\n    }\n    \n    return 0;\n}", '    $string
    =~ tr/\0/\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\0',
  "    $string =~ tr/\\0//cd;\n    return length($string);\n}", "    my($len) = 0;\n\
    \    for(my $i = 0; $i < ($string) -length $string; $i++) {\n\t$len++;\n    }\n\
    \    return $len;\n}", "    my $len = length($string);\n    return $len;\n}",
  "    my $i = 0;\n    for(my $c = 0; $c < length($string); $c++) {\n        $i++;\n\
    \    }\n    return $i;\n}\n</code>\n<|/ a dscore=3 tags=perl,loops,performance\
    \ |>\n<| c |>\nThe OP's code doesn't use `$i` at all, so this won't help\n<|/\
    \ c |>\n<| a dscore=3 |>\nThe reason your version will blow up is that it will\
    \ try to read past the end of the file. This means that a seek will occur inside\
    \ the loop, and it will move the pointer past the last character of the file.\
    \ As such, every iteration will attempt to read more from the file, and it will\
    \ eventually run out of data before it can do so. \nWhat you want instead is to\
    \ keep track of the number of characters you have already read. As long as you\
    \ have not reached the end of the file, add 1 to the number of characters you\
    \ have read. Once you reach the end of the file, you can exit the loop because\
    \ all characters have been read. \nTo implement this in Perl, you will need to\
    \ make use of the $. variable which holds the current line number.\n<code>\nmy\
    \ $number_of_chars_read = 0;\nwhile( <$fh> ) {\n    ++$number_of_chars_read;\n\
    \    ...\n}", "    my $length = length($string);\n    return $length;\n}", " \
    \   $string = \"\" unless defined($string);\n    my $stringLength = length($string);\n\
    \    return $stringLength;\n}", "    $string =~ tr/\\0//d;\n    length($string);\n\
    }", "    if (defined $string) {\n        # Convert string to string reference\
    \ and use length function\n        my $string_ref = $string;\n        my $str_length\
    \ = length($string_ref);\n        $str_length\n    } else {\n        0;\n    }\n\
    }", "    $string =~ tr/\\0//d;\n    return length($string);\n}", "    return length($string);\n\
    }", "    $string =~ tr/\\x00//d;\n    return scalar @$string;\n}", "    my $len\
    \ = length($string);\n    # Return 0 if empty string\n    return 0 if $len ==\
    \ 0;\n    return $len;\n}", "    if (defined $string) {\n        return length\
    \ $string;\n    }\n    else {\n        return 0;\n    }\n}", "    my $length =\
    \ 0;\n    while($string =~ /\\w/) {\n        $string =~ s/^\\s+//;\n        $string\
    \ =~ s/\\s+$//;\n        $string =~ s/\\s+/ /g;\n        $length++;\n    }\n \
    \   return $length;\n}", "    my $len = 0;\n    substr($string, length($string),\
    \ 0, \\$len);\n    return $len;\n}", "    if(!defined $string) {\n        return;\n\
    \    }", '    return 0 unless defined $string;', "    return length($string);\n\
    }", "    return length($string);\n}", "    substr($string, length($string), 1);\n\
    }", '    my $length;', "    my $len = length($string);\n    \n    return $len;\n\
    }", '    my $len = 0;', "    my $len = 0;\n    $string =~ tr/\\x00-\\x1F\\x7F-\\\
    xFF//d;\n    $len = length $string;\n    return $len;\n}", "    my $count = 0;\n\
    \    if (defined $string) {\n\twhile ($string =~ /./s) {\n\t    $count++;\n\t\
    \    $string =~ s/^.//;\n\t}\n    }\n    return $count;\n}", "    $string =~ tr/\\\
    0//;\n    return scalar @$string;\n}", "    if ($string eq '') {\n        0;\n\
    \    }\n    else {\n        $string =~ tr/\\x00//d;\n    }\n}", "    return 0\
    \ if !defined $string;\n    return length $string if UNIVERSAL::isa($string, \"\
    GLOB\");\n    return length $string;\n}", "    return length $string if defined\
    \ $string;\n    return 0;\n}", "    my $length;\n    for (split('', \"$string\"\
    )) {\n        last if (defined $length);\n        $length++;\n    }\n    return\
    \ $length;\n}", "    if (defined $string) {\n        $string =~ s/^\\s+//;\n \
    \       $string =~ s/\\s+$//;\n        return length $string;\n    }\n    return\
    \ 0;\n}\n</code>\nThis example is taken from here.\n<|/ a tags=perl,string,string-length\
    \ |>\n<| a dscore=4 tags=perl,string,string-length |>\n<code>\n$string = 'hello';\n\
    $stringlen = length($string);\n</code>\n<|/ a |>\n<| a tags=perl,string,string-length\
    \ dscore=4 |>\n$#s returns the index of the last element in a list. $#array returns\
    \ the index of the last element of array $array. It can also be used on a string\
    \ in scalar context. It can also be used on a list in  scalar context.\n<code>\n\
    use strict;\nuse warnings;", "    $string =~ tr/\\0//d; # Remove all null characters\n\
    \    return scalar @$string;\n}", "    $string =~ tr/\\0//d;\n    return length\
    \ $string;\n}", "    return length($string);\n}", "    $string .= \"\";\n    my\
    \ $length = length($string);\n    return $length;\n}", "    my $len = length($string);\n\
    \    if ( $string eq \"\" ) {\n        $len = 0;\n    }\n    return $len;\n}",
  "    return $string ? (length($string) - 1) : 0;\n}", "    return length $string;\n\
    }", "    return length($string);\n}", "    my $length;\n    foreach my $char (split(//,\
    \ $string)) {\n        $length += length($char);\n    }\n    return $length;\n\
    }", "    if ( defined $string and length $string )\n    {\n        return scalar\
    \ @$string;\n    }\n    else\n    {\n        return 0;\n    }\n}", "    my $result\
    \ = $string =~ tr/\\0//cd;\n    $result -= 1 if $string =~ s/\\0$//s;\n    return\
    \ $result;\n}", "    my $length = 0;\n    while ($string =~ s/^([a-zA-Z0-9_\\\
    [\\]\\(\\)]+).*/$1/s) {\n        $length ++;\n    }\n    return $length;\n}",
  "    my $len = 0;\n    while ($string =~ /[^\\0]/) {\n        $len++;\n        $string\
    \ =~ s/\\0/./g;\n    }\n    return $len;\n}", "    $string =~ tr/\\0//d;\n   \
    \ return length($string);\n}", "    $string =~ tr/\\0//d;\n    return scalar @$string;\n\
    }", "    return length($string);\n}", "    my($length);\n    \n    # Undef\n \
    \   $length = 0;\n    \n    my $stringLength = 0;\n    while (length $string)\
    \ {\n        $stringLength++;\n        my $nextChar = substr($string, 0, 1);\n\
    \        if ($nextChar eq \"\") {\n            $length += $stringLength;\n   \
    \     }\n        \n        $string = substr($string, 1);\n    }\n    $length +=\
    \ $stringLength;\n    \n    return $length;\n}", "    my $length = 0;\n    while\
    \ ($string ne \"\" && $string ne \"\\0\") {\n        $length++;\n        $string\
    \ =~ s/\\0/\\x00/g;\n    }\n    return $length;\n}", "    defined $string or return\
    \ 0;\n    my $length = length($string);\n    return $length;\n}", "    return\
    \ 0 if ($string eq '');\n    my $len = length $string;\n    $len = 0 if (!$len);\n\
    \    return $len;\n}\n</code>\n<|/ a |>\n<| a tags=perl,string |>\nJust for the\
    \ sake of completeness: Since perl 5.16, String::Util has these functions:\n<code>\n\
    String::Util::length  String::Util::length", "    return $string eq \"\" ? 0 :\
    \ $string eq \"\\0\" ? length($string) : length($string) + 1;\n}", "    my($length)\
    \ = 0;\n    while ($string =~ m{.}g) {\n\t$length++;\n    }\n    return $length;\n\
    }", "    $string =~ tr/\\0//;\n    my $length = 0;\n    while ($string =~ s/^(.)//)\
    \ {\n        $length++;\n    }\n    return $length;\n}", "    my $len;\n    if(!defined\
    \ $string) {\n        $len = length ${$self->{_strlen}};\n    } else {\n     \
    \   $len = length $string;\n    }\n    return $len;\n}", "    $string =~ tr/a-zA-Z0-9//d;\n\
    \    return length($string);\n}", "    my $length = 0;\n    if (defined $string\
    \ && length $string) {\n        $length = $string;\n    }\n    return $length;\n\
    }", "    if (length($string) == 0) {\n        return 0;\n    }\n    return length($string);\n\
    }", '    my($length) = 0;', "    my $i = 0;\n    while (length($string) > $i++)\
    \ {\n        my $c = substr($string, $i, 1);\n        return $i == 0 ? length($string)\
    \ : $i+1;\n    }\n    return length($string);\n}", "    $string =~ tr/\\0//d;\n\
    \    return scalar length($string);\n}", "    my $length = 0;\n    map {\n   \
    \     $length++ if length($_) == $string;\n    } @_;\n    return $length;\n}",
  "    if(!defined $string) { return 0; }\n    my $len = 0;\n    $string =~ tr/\\\
    0//d;\n    for(my $i = 0; $i <; $i++){\n        $len += length($_[$i]);\n    }\n\
    \    return $len;\n}", "    return $string =~ tr{\\0}{''};\n}", "    return length\
    \ $string if ref($string) && $string =~ /^\\Q$string\\E$/o;\n    my $l = 0;\n\
    \    $l += length($string) if $string =~ /\\x00/;\n    $l += length($string) if\
    \ $string =~ /\\x01/;\n    $l += length($string) if $string =~ /\\x02/;\n    $l\
    \ += length($string) if $string =~ /\\x03/;\n    $l += length($string) if $string\
    \ =~ /\\x04/;\n    $l += length($string) if $string =~ /\\x05/;\n    $l += length($string)\
    \ if $string =~ /\\x06/;\n    $l += length($string) if $string =~ /\\x07/;\n \
    \   $l += length($string) if $string =~ /\\x08/;\n    $l += length($string) if\
    \ $string =~ /\\x09/;\n    $l += length($string) if $string =~ /\\x0a/;\n    $l\
    \ += length($string) if $string =~ /\\x0b/;\n    $l += length($string) if $string\
    \ =~ /\\x0c/;\n    $l += length($string) if $string =~ /\\x0d/;\n    $l += length($string)\
    \ if $string =~ /\\x0e/;\n    $l += length($string) if $string =~ /\\x0f/;\n \
    \   $l += length($string) if $string =~ /\\x10/;\n    $l += length($string) if\
    \ $string =~ /\\x11/;\n    $l += length($string) if $string =~ /\\x12/;\n    $l\
    \ += length($string) if $string =~ /\\x13/;\n    $l += length($string) if $string\
    \ =~ /\\x14/;\n    $l += length($string) if $string =~ /\\x15/;\n    $l += length($string)\
    \ if $string =~ /\\x16/;\n    $l += length($string) if $string =~ /\\x17/;\n \
    \   $l += length($string) if $string =~ /\\x18/;\n    $l += length($string) if\
    \ $string =~ /\\x19/;\n    $l += length($string) if $string =~ /\\x1a/;\n    $l\
    \ += length($string) if $string =~ /\\x1b/;\n    $l += length($string) if $string\
    \ =~ /\\x1c/;\n    $l += length($string) if $string =~ /\\x1d/;\n    $l += length",
  "    $string =~ tr/\\0//d;\n    return scalar @$string;\n}", "    my $len = length($string);\n\
    \    return $len;\n}", "    return 0 if !defined $string;\n    my $len = length\
    \ $string;\n    return $len if $len > 0;\n    return undef + 0;  # \"undefined\"\
    \ is not 0, but \"0\" is \"undefined\"\n}", "    my $length;\n    my $strlen =\
    \ 0;\n    my $idx;", "    my $i = 0;\n    foreach my $ch (split(//, $string))\
    \ {\n        $i++;\n    }\n    return $i;\n}", "    defined($string) && length\
    \ $string;\n}", "    my $length = 0;\n    $string =~ tr/\\0//;\n    while (length($string))\
    \ {\n        $length++;\n        $string =~ tr/\\0//;\n    }\n    return $length;\n\
    }", "    return unless defined $string;\n    if (ref $string eq \"SCALAR\") {\n\
    \        $$string;\n    }\n    else {\n        length $string;\n    }\n}", " \
    \   $string =~ tr/\\x00-\\x20\\x0B\\x0C\\x0E-\\x7F//d;\n    return length $string;\n\
    }", "    $string =~ tr/\\x00//d;\n    return scalar length $string;\n}", "   \
    \ $string =~ tr/\\0//d;\n    $string =~ tr/\\x00//d;\n    $string =~ tr/\\x00//d;\n\
    \    $string =~ tr/\\x00//d;\n    return scalar @$string;\n}", "    my $length\
    \ = 0;\n    foreach (@_) {\n        $length++ if length $_ > 0;\n    }\n    return\
    \ $length;\n}", "    if ($string eq '') { return 0; }\n    my $length = 0;\n \
    \   for (my $i = $#_; $i >= 0; $i--) {\n        $length++;\n        last if $_[$i]\
    \ eq ';';\n    }\n    return $length;\n}", "    return length($string);\n}", " \
    \   my($length);\n    if ($string =~ /\\\\/) {\n        # String contains backslashes,\
    \ so it can't be empty\n        $length = 0;\n    } else {\n        $length =\
    \ length($string);\n    }\n    return $length;\n}", "    length($string);\n}",
  "    my $length = 0;\n    $string =~ tr/\\x00//d;\n    $length = length($string);\n\
    \    return $length;\n}", "    return 0 if !defined $string;\n    my $length =\
    \ 0;\n    my $i = 0;\n    while ($i < length($string)) {\n        $length++;\n\
    \        $i++;\n    }\n    return $length;\n}", "    length($string);\n}", " \
    \   my $length;\n    my $_s = length($string);", "    $string =~ tr/\\0//d;\n\
    \    return scalar @{$_[0]};\n}", "    defined($string) && $string =~ /^.{,}$/\
    \ ? length($string) : undef;\n}", "    my $len = length($string);\n    return\
    \ $len;\n}", "    if (defined $string) {\n        my $length = 0;\n        foreach\
    \ my $char (split //, $string) {\n            $length++;\n        }\n        return\
    \ $length;\n    }\n    return 0;\n}", "    my $len = 0;\n    while ($string =~\
    \ s/^[^-]*\\-//) {\n\t$len++;\n    }\n    return $len;\n}", "    return length($string);\n\
    }", "    $string =~ tr/\\0//d;\n    my $len = length($string);\n    return $len;\n\
    }", "    my $len = length $string;\n    return $len;\n}", "    return length($string);\n\
    }\n</code>\n<|/ a tags=perl,string-length |>\n<| c |>\nI think you need to add\
    \ a few checks to see if scalar was given or an array, or a hash.  For example\
    \ `if (@_) { my ($string) = shift; ... }`.\n<|/ c |>\n<| c |>\n, good point, didn't\
    \ think about that.  I've added a check for scalar.\n<|/ c |>\n<| c |>\nI think\
    \ your `return` should be outside of the `if`.\n<|/ c |>\n<| c |>\n, good catch,\
    \ i edited the code.  I also added a comment explaining why i didn't move the\
    \ `return` outside of the `if`\n<|/ c |>\n<| c |>\nI suppose you meant to use\
    \ `if ref $string eq 'SCALAR'` instead of `scalar $string` as your `if` condition.\
    \ Anyway I think your edit was good :)\n<|/ c |>\n<| a |>\n<code>", "    my $len\
    \ = length($string);\n    if ($len <= 0) {\n        return 0;\n    }\n    my $result\
    \ = 0;\n    my $len = length($string);\n    while($len > 0) {\n        $result++;\n\
    \        $len--;\n    }\n    return $result;\n}", "    if ($string eq '') {\n\t\
    return 0;\n    } elsif ($string =~ /^ *$/) {\n\treturn 0;\n    } else {\n\treturn\
    \ length $string;\n    }\n}", "    if (defined $string) {\n        my $len = length($string);\n\
    \        if ($len <= 0) {\n            $len = undef;\n        }\n        return\
    \ $len;\n    }\n    return 0;\n}", '    my $length;', "    my($length);\n    if\
    \ ( $string =~ /^\\Q$utf8::hint_regex\\E$/ ) {\n        $length = length($string);\n\
    \    }\n    else {\n        $length = $string =~ tr/\\0-\\377//c;\n    }\n   \
    \ return $length;\n}", "    my $count = 0;\n    while ($string =~ /[^\\x00-\\\
    xff]/g) {\n        $count++;\n    }\n    return $count;\n}", "    return scalar\
    \ length($string);\n}", "    return 0 unless defined $string;\n    $string =~\
    \ tr/\\0//d;\n    return scalar @$string;\n}", "    if (defined $string) {\n \
    \       defined $string ? length($string) : 0\n    }\n}", "    my $length = 0;\n\
    \    while ($string =~ /\\\\[0-7]{1,2}/g) {\n        $length += length($&);\n\
    \    }\n    return $length;\n}", "    my $len = 0;\n    my $_;\n    while ($string\
    \ =~ /(.)(?=(.))/g) {\n        my $length = $1;\n        $len += length($length);\n\
    \    }\n    return $len;\n}", "    my $len = 0;\n    for (split(//,$string)){\
    \ $len++ }\n    return $len;\n}", "    return length $string;\n}", "    my $len\
    \ = 0;\n    while($string =~ /[^\\x00-\\x7f]/g) {\n        $len++;\n    }\n  \
    \  return $len;\n}", '    return 0 if !defined $string;', "    my $len = length($string);\n\
    \    $len > 0 and $len or 0;\n}", "    return 0 unless defined $string;\n    $string\
    \ =~ tr/\\x00//d;\n    return length $string;\n}", "    $string =~ s/^\\s*//;\n\
    \    $string =~ s/\\s*$//;\n    length($string);\n}", "    my $length = 0;\n \
    \   for my $char (split //, $string) {\n        $length++ if $char =~ /[\\x00-\\\
    x7F]/g;\n    }\n    return $length;\n}", "    return 0 if !defined $string;\n\
    \    my $len = length $string;\n    wantarray ? ($len) : $len;\n}", "    my $len\
    \ = length($string);\n    $len > 0\n      or $self->throwError($string, \"No such\
    \ string \\\"$string\\\"\");\n    $len;\n}", "    my $len = length($string);\n\
    \    $len if $len < 0;\n    return $len;\n}", "    my $stringref = &PL_sv_undef;\n\
    \    if (ref($string)) {\n\trequire Scalar::Util;\n\t$stringref = PV::Shared_PV;\n\
    \    }\n    my $len = scalar length $string;\n    if ($len == -1) { # -1 means\
    \ undef\n\trequire Scalar::Util;\n\t$len = length &Scalar::Util::blessed($string)\
    \ ? &Scalar::Util::reflength($string) : 0;\n    }\n    &PL_sv_set((ref $stringref)\
    \ ? $stringref : $string, $len);\n}", "    return length($string);\n}", "    if\
    \ ( $string eq \"\" ) {\n        return 0;\n    }\n    else {\n        my $length\
    \ = length($string);\n        my $i = 0;\n        for($i; $i < $length; $i++)\
    \ {\n            if ( $string->[$i] eq '\"' ) {\n                return $i;\n\
    \            }\n        }\n        return $length;\n    }\n}", "    $string =~\
    \ tr/\\0//d; # Remove \\0\n    return length($string);\n}", "    $string =~ tr/\\\
    0//d;\n    return $-[0] if $string;\n    return 0;\n}", "    length($string);\n\
    }", "    $string =~ tr/\\0-\\377//cd;\n    return scalar @$string;\n}", "    return\
    \ scalar(@$string) - 1;\n}", "    $string =~ tr/\\0//d; # remove nulls\n    length($string);\n\
    }", "    my $len = length($string);\n    return $len;\n}", "    $string = '' unless\
    \ defined $string;\n    $string =~ tr/\\0//d;\n    $string =~ tr/\\x00//d;\n \
    \   length($string);\n}", "    my $len = length($string);\n    $len > 0 ? $len\
    \ : 0;\n}", "    $string =~ tr/\\0//;\n    return length($string);\n}", '    my($length)
    = 0;', "    my $len = 0;\n    my $c;\n    for ($c = 0; $c < length $string; $c++)\
    \ {\n\t$len++;\n    }\n    return $len;\n}", "    my $length;\n    $string =~\
    \ tr/\\0//d; # delete null bytes\n    $length = length($string);\n    return $length;\n\
    }", "    if (defined $string) {\n        my @length = map {$_ =~ tr/\\0//d;} unpack\
    \ \"C*\", $string;\n        return scalar(@length);\n    } else {\n        return\
    \ 0;\n    }\n}", "    my $length = 0;\n    while($string =~ m/\\G(.)/sg) {\n \
    \       $length++;\n    }\n    return $length;\n}", "    my $len = 0;\n    $string\
    \ =~ tr/\\0//d while ($string =~ tr/\\0//d);\n    $len += length $string;\n  \
    \  return $len;\n}", "    $string =~ tr/\\0//d;\n    return length($string);\n\
    }", "    my $length = 0;\n    if ($string =~ /^[\\s\\*]$/) {\n        $length\
    \ = $string->length();\n    } else {\n        $string =~ tr/\\x00//d;\n      \
    \  $length = length($string);\n    }\n    return $length;\n}", "    $string =~\
    \ tr/\\0//d;\n    return length $string;\n}", "    my $len = length($string);\n\
    \    return $len;\n}\n</code>\n<|/ a tags=perl,string |>\n<| c |>\nI do appreciate\
    \ the time spent to write this answer. Thank you for sharing.\n<|/ c |>\n<| c\
    \ |>\nWhy not: `sub strlen { length }`, or, better yet, `use feature qw(say);`?\
    \ It will compile down to `sub strlen { say length; }`. I find it easier to read.\n\
    <|/ c |>\n<| c |>\n: Because it prints something that doesn't fit in a single\
    \ line. :)\n<|/ c |>\n<| c |>\n: I still prefer the `say()` version, but you're\
    \ right, `say` doesn't always output in single lines. In fact, I have been using\
    \ this for years, but always use `use feature qw(say);`, as I suggested. :-)\n\
    <|/ c |>\n<| a dscore=3 tags=perl,string |>\n<code>\n$a = \"foo\";\n$b = \"bar\"\
    ;\n$a cmp $b # returns 0 if they have the same length, -1 if a<b, 1 if a>b\n</code>\n\
    <|/ a |>\n<| c |>\nThis will return 0 if a=\"foo\" and b=\"bar\", but it will\
    \ return -1 if a=\"bar\" and b=\"foo\"\n<|/ c |>\n<| c |>\nNo, cmp will tell you\
    \ if a<b, and return -1 if a>b.\n<|/ c |>\n<| a dscore=3 |>\nI use this one:\n\
    <code>", "    $string = \"\" unless defined $string;\n    $string =~ tr/\\0//cd;\n\
    \    return scalar length $string;\n}", "    if ( $string =~ s/^\\s+//s ) {\n\
    \        return 0;\n    }\n    my $len = length($string);\n    return $len;\n}",
  "    return scalar(@$string ? @$string : ());\n}", "    my $length = 0;\n    foreach\
    \ (split(//, $string)) {\n        $length++;\n    }\n    return $length;\n}",
  "    $string =~ tr/\\0//d; # trim all NULL bytes from the end\n    $string =~ tr/\\\
    00//d;  # trim all zero bytes from the end\n    return scalar($string);\n}\n1;\n\
    __END__", "    $string =~ tr/\\0//d;\n    return(length($string));\n}", '    my($result);',
  "    my $length;\n    if (defined($string) && length $string > 0) {\n\t$length =\
    \ length $string;\n    }\n    else {\n\t$length = 0;\n    }\n    return $length;\n\
    }", "    if ($string =~ /^[0-9\\.]+$/) {\n        $string =~ s/^0*//;\n      \
    \  return length($string);\n    }\n    return 0;\n}", "    return length $string;\n\
    }", "    $string =~ tr/\\x00//d;\n    return length $string;\n}", "    return\
    \ length $string if defined $string;\n    return 0;\n}", "    $string =~ tr/\\\
    0//cd;\n    $string =~ tr/\\000//d;\n    my $len = $#_ + 3;\n    $len = $len if\
    \ $len > $#_;\n    $len;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
