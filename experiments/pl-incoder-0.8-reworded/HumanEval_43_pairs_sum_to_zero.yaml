name: HumanEval_43_pairs_sum_to_zero
language: pl
prompt: "# pairs_sum_to_zero takes an array of integers as an input.\n# it returns\
  \ 1 if there are two distinct elements in the array that\n# sum to zero, and  otherwise.\n\
  # >>> pairs_sum_to_zero([1, 3, 5, 0])\n# \"\"\n# >>> pairs_sum_to_zero([1, 3, -2,\
  \ 1])\n# \"\"\n# >>> pairs_sum_to_zero([1, 2, 3, 7])\n# \"\"\n# >>> pairs_sum_to_zero([2,\
  \ 4, -5, 3, 5, 7])\n# 1\n# >>> pairs_sum_to_zero([1])\n# \"\"\nsub pairs_sum_to_zero\
  \ {\n    my($l) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pairs_sum_to_zero;\n\
  \        if(eq_deeply($candidate->([1, 3, 5, 0]),\"\")) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 3, -2,\
  \ 1]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
  \   if(eq_deeply($candidate->([1, 2, 3, 7]),\"\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 4, -5, 3, 5,\
  \ 7]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1]),\"\
  \")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-3,\
  \ 9, -1, 3, 2, 30]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n     \
  \   }\n        if(eq_deeply($candidate->([-3, 9, -1, 3, 2, 31]),1)) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-3,\
  \ 9, -1, 4, 2, 30]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n  \
  \      }\n        if(eq_deeply($candidate->([-3, 9, -1, 4, 2, 31]),\"\")) {\n  \
  \      print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    return \"\" if ($l == 0);\n    my $sum = 0;\n    my %seen = ();\n\
    \    foreach my $e ($l){\n        $seen{$e}++;\n        if ($seen{$e} > 1) {\n\
    \            return 1;\n        }\n        $sum += $e;\n    }\n    return \"\"\
    \ if $sum == 0;\n    return \"\";\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nI like\
    \ that you added a function that solves the problem. I think it deserves more\
    \ upvotes than mine. :) But I wonder if there is a way to avoid the extra hash?\
    \ I thought about using a `for` loop to iterate over `$l` but then you would have\
    \ to use a `while` loop to test each element in the array.\n<|/ c |>\n<| c |>\n\
    : I think you're right, I guess the problem might be NP-complete, but I'm not\
    \ sure.\n<|/ c |>\n<| c |>\n: I added another solution, although it involves hashing\
    \ which makes it a bit slower.\n<|/ c |>\n<| c |>\n: Thanks, I appreciate it!\n\
    <|/ c |>\n<| c |>\nI think it's possible to prove that the problem is not NP-complete\
    \ (by reducing the size of the input and getting a polynomial time solution) by\
    \ finding a polynomial time algorithm for this problem that only uses hashing.\n\
    <|/ c |>\n<| a tags=arrays,perl,hash |>\nIf you're open to using a library (like\
    \ List::MoreUtils), then the following solution is very easy to read.\n<code>\n\
    my $sum = [1,2,3,4,5,7,8,9] =~ /(.?)(.?)/g;\nprint \"$sum\\n\"\n</code>\nIf you're\
    \ open to using a library (like List::MoreUtils), then the following solution\
    \ is very easy to read.\n<code>\nmy $sum = [1,2,3,4,5,7,8,9] -> sum;\nprint \"\
    $sum\\n\"\n</code>\nIf you're open to using a library (like List::MoreUtils),\
    \ then the following solution is very easy to read.\n<code>\nuse List::MoreUtils\
    \ 'pairwise';", "    my @pairs = ();\n    my @pairs_sum = ();\n    for (my $i\
    \ = 0; $i < scalar(@$l); $i++) {\n        push (@pairs_sum, 0);\n        push\
    \ (@pairs, $i);\n    }\n    for (my $i = 0; $i < scalar(@$l); $i++) {\n      \
    \  for (my $j = 0; $j < scalar(@$l); $j++) {\n            if ($j > $i && $pairs_sum[$i]+$pairs_sum[$j]\
    \ == 0) {\n                push @pairs, $j;\n                push @pairs_sum,\
    \ $pairs_sum[$i] + $pairs_sum[$j];\n            }\n        }\n    }\n    if (scalar(@pairs)\
    \ == 1) {\n        return $pairs[0];\n    }\n    else { return \"\" }\n}", " \
    \   for (my $i = 0; $i < @$l; $i++) {\n        for (my $j = 0; $j < $i; $j++)\
    \ {\n            return 0 if $l->[$i] + $l->[$j] == 0;\n        }\n    }\n   \
    \ return \"\";\n}", "    my $s = $l->[0];\n    $l->[0] =~ s/^0+//;\n    foreach\
    \ my $i (@{$l->[1]}) {\n        my $s = $i + $s;\n        $l->[0] =~ s/^0+//;\n\
    \        $l->[0] =~ s/^$i\\z//;\n        last if $l->[0] =~ s/^0+//;\n    }\n\
    \    return unless $l->[0] =~ s/^0+//;\n    return $l->[0];\n}", "    my $s =\
    \ 0;\n    my $max = $l - 1;\n    for ($s; $s < $max; $s++) {\n        $max--;\n\
    \        my $e = ($l+$s)/$2;\n        if ($e > $l) {\n            last;\n    \
    \    } elsif ($e == $l) {\n            return 1;\n        }\n    }\n    return\
    \ '';\n}", "    my %seen;\n    my %sums;", "    my($result) = @_;\n    return\
    \ \"\" unless @$l;\n    my $sum;\n    for (@$l) {\n        $sum += $_;\n    }\n\
    \    return 1 if $sum == 0;\n    return \"\" unless $sum == -1;\n    for (@$l)\
    \ {\n        $result += $_;\n    }\n    return $result;\n}", "    my($sum) = 0;\n\
    \    foreach my $pair (@$l) {\n        if ($pair->[0] <=> $pair->[1] != 0) {\n\
    \            $sum++;\n        }\n    }\n    if ($sum == 1) {\n        return '';\n\
    \    }\n    return 1 if $sum == 0;\n}", "    my $result = $l;\n    my $i = -1;\n\
    \    while ($i < @$l) {\n        $i += 1;\n        my $sum = $$l[$i];\n      \
    \  if ($sum == 0) {\n            last if ($result != $sum);\n        }\n     \
    \   $result = $sum;\n    }\n    return $result != 0;\n}", "    my($i, $j, $sum,\
    \ $num);\n    my(@result);", "    my($c1, $c2, $c3, $c4);\n    \n    # first we\
    \ calculate the number of distinct values\n    my $n = scalar @$l;\n    \n   \
    \ # then we calculate the number of pairs that sum up to zero.\n    # a pair is\
    \ defined as a group of two numbers that differ by no more than one value.\n \
    \   my(@pairs);\n    for (my $i = 0; $i < $n; $i++) {\n        if ($i != $n -\
    \ 1) {\n            next unless $l[$i] eq $l[$i + 1];\n            next if $l[$i]\
    \ eq $l[$i] + $l[$i + 1];\n            push (@pairs, [$l[$i], $l[$i + 1]]);\n\
    \        }\n    }\n    my $num_pairs = scalar @pairs;\n    \n    # return the\
    \ answer as a string\n    my $s = \"\";\n    if ($num_pairs > 0) {\n        $s\
    \ = $num_pairs ? \"pairs \" : \"no pairs \";\n        $s .= \"sum up to zero \"\
    ;\n    }\n    else {\n        $s = $num_pairs ? \"one \" : \"no one \";\n    \
    \    $s .= \"does not sum up to zero\";\n    }\n    $s .= \" of $n\";\n    return\
    \ $s;\n}", "    $l++ unless scalar @$l > 1;\n    my $i = 0;\n    my $j = $#l -\
    \ 1;\n    while ($i < $j and $l->[$i] + $l->[$j] == 0) {\n        $i++;\n    \
    \    $j--;\n    }\n    $l->[$i] + $l->[$j] == 0\n        ? ''\n        : $l->[$i]\
    \ + $l->[$j] == 1\n            ? $_[0]\n            : undef;\n}", '    my($s);',
  "    my $ret = '';\n    my $i = 0;\n    foreach my $j (@$l) {\n        ++$i;\n \
    \       if ($i != $j) {\n            $ret .= '';\n        }\n        else {\n\
    \            $ret .= $j != 0 ? 1 : 0;\n        }\n    }\n    return $ret;\n}",
  "    my $pairs = @$l;\n    my $count = 0;\n    for (my $i = 0; $i < $#$l; $i++)\
    \ {\n        $count += $pairs[$i];\n        $count += $l->[$i];\n        if ($count\
    \ < 0) {\n            $count = 0;\n        }\n    }\n    if ($count != 0) {\n\
    \        return 1;\n    }\n    return \"\";\n}", "    return 1 if $l =~ /\\S/\
    \ || $l == 0;\n    return 0;\n}\n</cell>\n<text>\nThe function pairs_sum_to_zero\
    \ is a little hard to read and understand, so we put a comment next to it explaining\
    \ what it does. If you need it later, you can retrieve it from the code cell above.",
  "    my $sum = 0;\n    for (my $i = 0; $i < @$l; $i++) {\n        if ($sum == 0)\
    \ {\n            $sum = $l->[$i];\n        }\n        elsif ($l->[$i] == $sum)\
    \ {\n            $sum = 0;\n        }\n        else {\n            return 1;\n\
    \        }\n    }\n    return 0;\n}", "    if ($l->[0] < 2) {\n\treturn $l->[0]\
    \ > 0 ? \"1\" : \"0\";\n    }\n    my(@r) = ($l->[0] + $l->[1]);\n    while ($l->[2]\
    \ < 2) {\n\tpush (@r, $l->[2] + $l->[3]);\n\tunshift @r, ($l->[0] + $l->[1] +\
    \ $l->[2]);\n    }\n    my($nv) = $l->[3];\n    foreach my $i ($l->[4], $l->[5]\
    \ + 1) {\n\tmy($vv) = @r[($i - 1)];\n\tnext if $nv != 0;\n\tunless ($vv <= 0)\
    \ {\n\t    return 1;\n\t}\n\tforeach my $j ($l->[6], $l->[7] + 1) {\n\t    my($wv)\
    \ = @r[($i - 1)];\n\t    $nv = 0;\n\t    foreach my $k ($l->[8], $l->[9] + 1)\
    \ {\n\t\tnext unless $wv <= 0;\n\t\tmy $w = @r[($k - 1)];\n\t\tif ($w == $vv +\
    \ $wv) {\n\t\t    $nv += $w;\n\t\t}\n\t    }\n\t}\n    }\n    return \"\";\n}",
  "    my @pairs;\n    my @tmp_pairs;\n    \n    foreach my $i (0 .. $#l) {\n    \
    \    \n        # if the element is not in the list, do not add it.\n        if\
    \ (not exists $l->[$i]) {\n            next;\n        }", "    my %h = ();\n \
    \   my($i, $j);\n    my $count = 0;\n    foreach $i (@$l) {\n        $j = $i;\n\
    \        $j--;\n        while($j > 0) {\n            my $key = abs($j);\n    \
    \        if (exists $h{$key}) {\n                $count++;\n            }\n  \
    \          $h{$key} = $key;\n            $j--;\n        }\n    }\n    return $count\
    \ ? \"1\" : \"\";\n}", "    my(@sum) = @_;\n    for (my $i = 0; $i < @$l; $i++)\
    \ {\n        my $t = $l->[$i];\n        for (my $j = 0; $j < @$l; $j++) {\n  \
    \          if ($l->[$j] == 0) {\n                push (@sum, 0);\n           \
    \     next;\n            }\n            push (@sum, $l->[$j]);\n            push\
    \ (@sum, $t);\n            push (@sum, 0);\n        }\n        push (@sum, 0);\n\
    \    }\n    return 1 == scalar grep {\n        !defined $_ || $_ != 0\n    } @sum;\n\
    }\n</code>\n<|/ a dscore=1 tags=perl |>\n<| c |>\nI understand that it's homework\
    \ - but can you describe the algorithm and what it does?\n<|/ c |>\n<| a tags=perl\
    \ |>\nI do not think this is homework; it is an interview question and I've been\
    \ working on this for quite a while and found a way to solve it without using\
    \ a lot of extra memory or iterating through lists.  Here is what I came up with:\n\
    <code>", "    my $count = 0;\n    my(@pairs);\n    my $zero = scalar(@$l == 0)\
    \ ? 0 : @$l == 1 ? $l[0] : 0;\n    while (@$l > 0) {\n        unshift(@pairs,\
    \ $l[0] > $zero ? $l[0] : $zero);\n        splice(@$l, 1);\n        $count +=\
    \ $l[0] > $zero ? 1 : 0;\n    }\n    $count > 0 ? 0 : 1;\n}", "    my($x1,$x2,$sum);\n\
    \    for(my $i=0;$i<@$l;$i++){\n        $sum+=$l->[$i];\n        if($sum==0){\n\
    \            $x1=$l->[$i];\n            $x2=$l->[$i];\n        }\n        else{\n\
    \            if($sum<0){\n                if($l->[$i]<$x1){\n                \
    \    $x1=$l->[$i];\n                }\n            }\n            else{\n    \
    \            if($l->[$i]<$x2){\n                    $x2=$l->[$i];\n          \
    \      }\n            }\n            $sum-=$l->[$i];\n        }\n    }\n    if($x1==$x2){\n\
    \        return 0;\n    }\n    return 1;\n}", "    my(@sums);\n    my($result);\n\
    \    \n    foreach my $element (@$l) {\n        if (my $sum = $element%100) {\n\
    \            push(@sums, $sum);\n        }\n    }", "    my $result = -1;\n  \
    \  for my $i ( 0..$#$l ) {\n        if ($l->[$i] <= 0) {\n            $result\
    \ = 0;\n            last;\n        }\n        $result += $l->[$i];\n    }\n  \
    \  if ( $result == -1 ) {\n        $result = 1;\n    }\n    return $result;\n\
    }\n</cell>\n<text>\nWe can check our function against the test cases. We also\
    \ use our new pairs_sum_to_zero function instead of the old sum_to_zero function.",
  "    my ($zero, $one, $i, $j, @tmp);\n    $zero = $l[0] < 0 ? 0 : $l[0];\n    @tmp\
    \ = $l;\n    for ($i = 0; $i < @tmp; $i++) {\n        $one = $tmp[$i];\n     \
    \   $j = 0;\n        while ($j < $i) {\n            if ($tmp[$j] + $tmp[$i] ==\
    \ $zero) {\n                $zero = 0;\n                last;\n            }\n\
    \            $j++;\n        }\n        $tmp[$i] = $one - $zero;\n        $zero\
    \ = $one;\n    }\n    if (@tmp == 1) {\n        return $tmp[0];\n    }\n    if\
    \ (@tmp > 1) {\n        return 1;\n    }\n    return 0;\n}", "    my $count =\
    \ 0;\n    my $l2 = @$l;\n    while ($count < $l2 ) {\n        my $elem = $l->[$count];\n\
    \        my $elem2 = $l->[$count+1];\n        my $count2 = 0;\n        while ($count2\
    \ < $l2 ) {\n            my $elem2a = $l->[$count2];\n            my $elem2b =\
    \ $l->[$count2+1];\n            if ($elem + $elem2 == 0 && $elem2 + $elem == 0){\n\
    \                ++$count;\n                ++$count2;\n            }\n      \
    \      ++$count2;\n        }\n    }\n    if ($count == $l2) {\n        return\
    \ 0;\n    } else {\n        return 1;\n    }\n}", "    my $result = \"\";\n  \
    \  for my $i ( 0 .. $#$l ) {\n        my $j = $#$l - $i - 1;\n        next unless\
    \ $l->[$i] + $l->[$j] == 0;\n        $result = 1;\n        last;\n    }\n    return\
    \ $result;\n}", "    my($zero);\n    my($first_zero);\n    my($first_nonzero);\n\
    \    $zero = 0;\n    $first_nonzero = 1;\n    $first_zero = 1;\n    foreach $l\
    \ (@$l) {\n        if ($l == 0) {\n            $zero++;\n            $first_zero\
    \ = $zero;\n        } elsif ($l != 0) {\n            $zero = 0;\n            $first_nonzero\
    \ = $nonzero if ($nonzero > $zero);\n        }\n    }\n    if ($first_zero !=\
    \ $first_nonzero) {\n        print \"1\\n\";\n    } else {\n        print \"0\\\
    n\";\n    }\n}\n</code>\n<|/ a |>\n<| c |>\nNice, though I wouldn't call it \"\
    shorter\". It's definitely more verbose.\n<|/ c |>\n<| c |>\n: I agree with you\
    \ completely! The answer could be improved with a one-liner, but I can't think\
    \ of it at the moment!\n<|/ c |>\n<| a tags=perl |>\nThe \"perl way\" is a little\
    \ unusual in my opinion (although I do think it's more elegant and less cluttered,\
    \ so I'll keep my answer here). \n<code>\nmy $num = \"123\";\nif ($num =~ /(0|1)(23|34|45|56|67|78|89|01)/)\
    \ {\n    print \"$num is in pairs\";\n}\n</code>\nIf it matches, your number \"\
    123\" is in pairs. \nIt works by using the regex pattern \"(0|1)(23|34|45|56|67|78|89|01)\"\
    .\nThe first part (0) means any number from 0 to 9 (i.e. 0-9), and so on (1).\
    \ It matches \"0\"-9, or \"1\"-9, or \"23\"-99, or etc.\nThe second part (23|34|45|56|67|78|89|01)\
    \ means \"23\"-99, \"34\"-99, \"45\"-99, etc. It matches \"23\"-99, \"34\"-99,\
    \ \"45\"-99, \"56\"-99, \"67\"-99, \"78\"-99, \"89\"-99, and \"01\"-99.\nAs a\
    \ result \"0\"-9 matches \"0\"-\"99\", and \"1\"-9 matches \"1\"-\"99\" as well.\n\
    I hope that helps.\n<|/ a dscore=0 |>\n<| a tags=perl dscore=0 |>\n<code>\nif\
    \ ($string =~ /^(..)\\1", "    my %p = ();\n    foreach my $i (@$l) {\n      \
    \  if (exists $p{$i}) {\n            return $p{$i};\n        }\n        $p{$i}\
    \ = 1;\n    }\n    return;\n}", "    my $zero = 1;\n    my $string = \"\";\n \
    \   foreach my $i (0 .. $#$l) {\n        $string .= \"$i\" unless $l[$i] == 0;\n\
    \    }\n    $string =~ tr/-/0/;\n    $string =~ tr/0/-/;\n    if ($string =~ /-0/)\
    \ {\n        $zero = 0;\n        $string =~ s/-0/-0/;\n    }\n    elsif ($string\
    \ =~ /-\\0/) {\n        $zero = 0;\n        $string =~ s/-\\0/-\\0/;\n    }\n\
    \    elsif ($string =~ /-\\-0/) {\n        $zero = 0;\n        $string =~ s/-\\\
    -0/-\\-0/;\n    }\n    elsif ($string =~ /-\\--/) {\n        $zero = 0;\n    \
    \    $string =~ s/-\\--/-\\--/;\n    }\n    elsif ($string =~ /-\\-/) {\n    \
    \    $zero = 0;\n        $string =~ s/-\\-/-\\-/;\n    }\n    elsif ($string =~\
    \ /-\\-0/) {\n        $zero = 0;\n        $string =~ s/-\\-0/-\\-0/;\n    }\n\
    \    elsif ($string =~ /-\\-00/) {\n        $zero = 0;\n        $string =~ s/-\\\
    -00/-\\-00/;\n    }\n    elsif ($string =~ /-\\--0/) {\n        $zero = 0;\n \
    \       $string =~ s/-\\--0/-\\--0/;\n    }\n    elsif ($string =~ /-\\-00/) {\n\
    \        $zero = 0;\n        $string =~ s/-\\-00/-\\-00/;\n    }\n    elsif ($string\
    \ =~ /-\\--00/) {\n        $zero = 0;\n        $string =~ s/-\\--00/-\\--00/;\n\
    \    }\n    return $zero;\n}", "    my $res = [];\n    while (@$l) {\n       \
    \ $res->[0] += $l->[0];\n        $res->[1] += $l->[1];\n        $l->[$_] for 1..$#l;\n\
    \    }\n    return 1 if @$res == 1;\n    undef @$res if @$res > 1;\n    $res->[0]\
    \ > 0 ? \"1\" : \"0\"\n}", "    my @pairs;\n    my $n = 0;\n    foreach my $i\
    \ (0..$#$l) {\n        push(@pairs, $l[$i]);\n    }\n    foreach my $i (0..$#$l)\
    \ {\n        foreach my $j ($i+1..$#$l) {\n            if ($l[$i]+$l[$j] == 0)\
    \ {\n                $n = 1;\n            }\n        }\n    }\n    return $n>0;\n\
    }", "    my($max) = max(@$l);\n    my $sum = 0;\n    for my $i (0..$#l){\n   \
    \     $sum += $l[$i];\n        if ($sum > $max){\n            return \"\";\n \
    \       }\n    }\n    return $sum == 0 ? \"1\" : \"0\";\n}", "    my $zero = 1;\n\
    \    my $sum = 0;", "    # print \"pairs_sum_to_zero @$l\\n\";\n    my $x = 0;\n\
    \    my $y = 1;\n    while ($x < @$l) {\n        $y += 1 if $l[$x] > 0;\n    \
    \    $x += 1;\n    }\n    # print \"y = $y\\n\";\n    return 0 if $y == 1;\n \
    \   return 1;\n}", "    my $n = @$l;\n    my $k = 0;\n    my @pairs;\n    my @zeros;\n\
    \    my $found = 0;\n    \n    for (my $i = 0; $i < $n; $i++) {\n        if ($l[$i]\
    \ == 0) {\n            $zeros[$k] = $i;\n            $k++;\n        } else {\n\
    \            push(@pairs, $l[$i]);\n            $found = 1;\n        }\n    }\n\
    \    \n    return if ($found == 0);\n    \n    for (my $i = @pairs-1; $i >= 0;\
    \ $i--) {\n        for (my $j = 0; $j < $n-$i; $j++) {\n            my $k = $i\
    \ + $j;\n            if ($l[$k] == 0) {\n                $l[$k] = 1;\n       \
    \     }\n        }\n    }\n    \n    $l[$n-1] = 0;\n    return @zeros;\n}", '    my(@r)
    = (0);', "    $l =~ s/\\s+//g;\n    my $sum = 0;\n    my $zero = 0;\n    my $result\
    \ = 0;\n    foreach my $elem (@$l) {\n        $sum += $elem;\n        if ($elem\
    \ == 0) {\n            $zero++;\n        }\n    }\n    if ($sum == 0) {\n    \
    \    $result = $zero;\n    } else {\n        $result = $sum;\n    }\n    if ($result\
    \ == 0) {\n        $result = 1;\n    }\n    return $result;\n}", "    my $max\
    \ = (@$l)[0];\n    my @res;\n    my $count = 0;\n    for (my $i = 0; $i <= $#{$l};\
    \ $i++) {\n        my $x = $l->[$i];\n        for (my $j = 0; $j <= $#{$l}; $j++)\
    \ {\n            if ($i == $j) {\n                $count++;\n            }\n \
    \           else {\n                if ($l->[$i] + $l->[$j] == 0) {\n        \
    \            $res[$count] = '$'.$i.'^'.$j.'=';\n                    $count++;\n\
    \                }\n            }\n        }\n    }\n    my $return_string = \"\
    \";\n    for (my $i = 0; $i < $count; $i++) {\n        $return_string .= $res[$i];\n\
    \    }\n    return $return_string;\n}", "    my $pairs=0;\n    my $first=0;\n\
    \    my $second=0;\n    for(my $i=0; $i<@$l; $i++){\n        if($i>0 && $l->[$i-1]\
    \ == $l->[$i]){\n            $pairs++;\n        }\n    }\n    for(my $i=0; $i<@$l;\
    \ $i++){\n        if($i>0 && $l->[$i] == $l->[$i-1]){\n            $pairs++;\n\
    \        }\n    }\n    for(my $i=0; $i<@$l; $i++){\n        if($first){\n    \
    \        if(-$l->[$i] == 0){\n                return 1;\n            }\n     \
    \   }\n        else{\n            if(-$l->[$i] == 0){\n                return\
    \ 0;\n            }\n        }\n        $first=$first+1;\n    }\n}\n    ", " \
    \   my %xs;\n    foreach my $v (@$l) {\n        if ($xs->{$v}) {\n           \
    \ $xs->{$v}++;\n        } elsif ($xs->{$v} == 1) {\n            $xs->{$v} = 0;\n\
    \        } else {\n            $xs->{$v}++;\n        }\n    }\n    my $ret = 0;\n\
    \    foreach my $v (keys %xs) {\n        if ($xs->{$v} == 2) {\n            $ret\
    \ = 1;\n            last;\n        }\n    }\n    return $ret ? 1 : 0;\n}", " \
    \   my $i = 0;\n    my $n = 0;\n    my $tmp = 0;\n    my $ans = \"\";\n    while\
    \ (my $element = shift @$l) {\n        $n++;\n        if ($n == 1) {\n       \
    \     $tmp = $element;\n        }\n        elsif ($element == $tmp) {\n      \
    \      $i++;\n        }\n        elsif ($i == 1) {\n            $ans .= \" $tmp\"\
    ;\n            $n = 0;\n            $tmp = 0;\n        }\n        elsif ($i !=\
    \ 1) {\n            $ans .= \" $tmp\";\n            $n = 0;\n        }\n    }\n\
    \    if ($tmp == 0 && $i != 1) {\n        $ans .= \" $tmp\";\n    }\n    if ($n\
    \ == 1) {\n        $ans .= \" $tmp\";\n    }\n    return $ans;\n}", "    my $s\
    \ = 0;\n    my @k;\n    my $ps = 1;\n    my $flag = 0;\n    my $flag2 = 0;\n \
    \   my $flag3 = 0;", '    my @x = sort { $a <=> $b } @$l;', '    my($ret);', " \
    \   my $zero = 0;\n    my $s = \"\";\n    my $count = 0;\n    my $max = 0;\n \
    \   my $i = 0;\n    my %map;\n    my $temp;", "    my @pairs = map { $_->[0] }\
    \ @$l;\n    my($pairs);\n    while ($pairs == 0) {\n        $pairs = 1;\n    \
    \    for my $i (0 .. $#pairs) {\n            my($x, $y) = @$pairs[$i];\n     \
    \       my($x_plus_y) = $x + $y;\n            if ($x_plus_y < 0) {\n         \
    \       $x_plus_y = 0;\n            }\n            my($x_minus_y) = $x - $y;\n\
    \            if ($x_minus_y < 0) {\n                $x_minus_y = 0;\n        \
    \    }\n            if ($x_minus_y == 0) {\n                $pairs = 0;\n    \
    \        }\n        }\n    }\n    return '' unless $pairs == 0;\n    return 1;\n\
    }", "    my(@list) = (@$l);\n    for (my $i = 0; $i < (@list - 1) ; $i++) {\n\
    \        for (my $j = $i + 1; $j < (@list - 1) ; $j++) {\n            my ($num,\
    \ $sign) = extract_num($list[$i]);\n            my ($other_num, $other_sign) =\
    \ extract_num($list[$j]);\n            if ($sign eq $other_sign) {\n         \
    \       if ($num == 1) {\n                    $list[$i] = '0';\n             \
    \   }\n                else {\n                    $list[$i] = $list[$i] + \"\
    0\";\n                    $list[$j] = \"0\";\n                }\n            }\n\
    \        }\n    }\n    return \"@list\";\n}", "    my($result) = \"\";\n    \n\
    \    # base case\n    if (@$l == 0) {\n        return $result;\n    }\n    \n\
    \    # add first element to the result\n    if ($l[0] < $l[1]) {\n        $result\
    \ = $l[0] if $l[0] > $l[1];\n    }\n    elsif ($l[0] >= $l[1]) {\n        $result\
    \ = $l[1] if $l[0] > $l[1];\n    }\n    \n    # loop through remaining elements\n\
    \    for (my $i = 0; $i < @$l - 1; $i++) {\n        my $sum_of_other_elements\
    \ = @$l - 1 - $i;\n        if ($l[$i + 1] < $sum_of_other_elements) {\n      \
    \      $result = $l[$i + 1] if $l[$i + 1] > $l[$i];\n        }\n        elsif\
    \ ($l[$i + 1] >= $sum_of_other_elements) {\n            $result = $l[$i + 1] if\
    \ $l[$i + 1] > $l[$i];\n        }\n    }\n    \n    return $result;\n}", "   \
    \ my @k;\n    my $sum;\n    my $count = 0;\n    my $max;\n    foreach $max (sort\
    \ {$a <=> $b} keys %$l) {\n        $sum = 0;\n        $count = 0;\n        foreach\
    \ my $i (keys %$l) {\n            if ($i == $max) {\n                $sum += $l->{$i};\n\
    \                $count++;\n            }\n        }\n        if ($sum == 0) {\n\
    \            $l->{$max} = '0';\n        } else {\n            $l->{$max} = $sum;\n\
    \        }\n    }\n    foreach $max (sort {$a <=> $b} keys %$l) {\n        if\
    \ ($l->{$max}) {\n            $l->{$max} = \"0\" if $l->{$max} ne \"0\";\n   \
    \     }\n    }\n    return if keys %$l == 0;\n    return if keys %$l > 1;\n  \
    \  return unless $l->{10} == 0;\n    return $l->{10};\n}", "    my $s = 0;\n \
    \   $s ^= $l->[0];\n    for my $i(1..$l->[0]-1) {\n        $s ^= $l->[$i];\n \
    \   }\n    return ($s == 0) ? '' : 1;\n}", "    my $max = $l->[0];\n    my $ans\
    \ = 0;\n    for(my $i = 1;  $i < @$l;  ++$i) {\n        if ($l->[$i] > $max) {\n\
    \            $max = $l->[$i];\n        }\n        if ($l->[$i] - $l->[$i-1] ==\
    \ $max && $ans == 0) {\n            $ans = 1;\n        }\n    }\n    return $ans;\n\
    }", '    my @a = sort { $a <=> $b };', "    $l =~ s/^-//;\n    my(@pairs) = $l\
    \ =~ /(-?\\d+)\\-(-?\\d+)/;\n    my %seen = ();\n    return unless @pairs <= 1;\n\
    \    my $count = $l->[0] + $l->[1];\n    for (@pairs) {\n        my $x = $1;\n\
    \        my $y = $2;\n        my $pair = ($x, $y);\n        if (exists($seen{$pair})\
    \ && $seen{$pair} != $count) {\n            return \"\";\n        }\n        $seen{$pair}\
    \ = $count;\n    }\n    return $count == 0 ? \"\" : $count == 1 ? \"1\" : \"more\
    \ than 1\";\n}", "    my $ret = \"\";\n    my %seen = ();\n    foreach (@$l) {\n\
    \tif (exists $seen{$_}) {\n\t    $ret++;\n\t}\n\telse {\n\t    $seen{$_} = 1;\n\
    \t}\n    }\n    return $ret;\n}", "    my $sum = 0;\n    foreach my $i (@$l) {\n\
    \        $sum += $i;\n    }\n    return 0 unless $sum;\n    my $result = 0;\n\
    \    foreach my $i (@$l) {\n        $result += $i;\n        $result++;\n    }\n\
    \    return $result;\n}", "    my $sum = 0;\n    my $ret = 0;\n    foreach my\
    \ $i (@$l) {\n        $sum += $i;\n        if ($sum == 0) {\n            $ret++;\n\
    \        }\n    }\n    return $ret;\n}", "    my $sum = 0;\n    my $count = 1;\n\
    \    foreach my $elem (@$l) {\n        if ($elem == 0) {\n            return \"\
    \" if $sum != 0;\n            $count++;\n            $sum = 0;\n        }\n  \
    \      $sum += $elem;\n    }\n    return $count == 0 ? \"\" : $count == 1 ? \"\
    1\" : \"\";\n}", "    return '' unless @$l;\n    my %h;\n    my $first = $l[0];\n\
    \    for my $i ( 1..@$l ) {\n        my $sum = $l[$i] + $l[$i - 1];\n        $h{\
    \ $sum }++ if $sum;\n    }\n    return $h{$_} == 2 ? 1 : '';\n}", "    my $count\
    \ = 0;\n    foreach my $i ( @$l) {\n        $count++\n            if $i != $l->[$i]\
    \ or $i != $l->[$i+1];\n    }\n    return 1 unless $count == 1;\n    return '';\n\
    }\n</code>\n<|/ a tags=arrays,perl,algorithm |>\n<| c |>\nThe `for` loop can be\
    \ replaced with `@$l =~ /(.)(.)/g` and some more code golf is possible. :)\n<|/\
    \ c |>\n<| c |>\n: Yes, but only if you define `@array` in one place.  If you\
    \ put `my` before it, you cannot use `@array` after it.\n<|/ c |>\n<| a tags=arrays,perl,algorithm\
    \ |>\nYou can do it like this:\n<code>", "    my %seen = ();\n    my $num = 0;\n\
    \    for my $pair (sort { $a->[1] <=> $b->[1] || $a->[0] <=> $b->[0]} @$l) {\n\
    \        if (exists $seen{ $pair->[0] }) {\n            return 0;\n        }\n\
    \        $seen{ $pair->[0] } = 1;\n        $num += $pair->[1];\n    }\n    return\
    \ $num;\n}", "    my $max = -1;\n    my $res = \"\";", "    my $n = @$l;\n   \
    \ my @ans = ();\n    for (my $i = 0; $i < $n; ++$i) {\n        my $j = $i;\n \
    \       for (; $j < $n; ++$j) {\n            if ($l->[$i] + $l->[$j] == 0) {\n\
    \                push @ans, $i, $j;\n                last;\n            }\n  \
    \      }\n    }\n    return wantarray ? @ans : scalar @ans;\n}", "    my $result\
    \ = 0;\n    my $first;", "    my %pairs = ();\n    my @pairs;", "    my ($n1,\
    \ $n2);\n    my $res;\n    while (@$l) {\n\t$n1 += $l->[0];\n\t$n2 += $l->[1];\n\
    \t$res = $n1 - $n2 > 0;\n\tsplice (@$l, 0, 2);\n\tlast;\n    }\n    return $res;\n\
    }", "    my($r) = @$l[1 .. $#l];\n    my (@s) = ();\n    my($s) = 0;\n    foreach\
    \ my $i (@$r) {\n        $s = $s + $i;\n        if ($s <= 0) {\n            push\
    \ @s, $i;\n        }\n    }\n    return 1 unless @s;\n    my $n = @s;\n    return\
    \ \"\" unless $n % 2 == 0;\n    for (my $i = 1; $i <= $n; $i += 2) {\n       \
    \ if ($s[$i] - $s[$i+1] == 0) {\n            $s[$i] = \"\";\n        }\n    }\n\
    \    $s[$n-1] = \"\";\n    return join(\",\", @s);\n}", "    my(@s);\n    my($n);\n\
    \    my($c);\n    my($result);", "    my $sum = 0;\n    foreach my $element (@$l)\
    \ {\n        if ($element == 0) {\n            $sum += 0;\n        }\n       \
    \ else {\n            $sum += $element;\n        }\n    }\n    return 1 if ($sum\
    \ == 0);\n    return \"\";\n}\n</code>\n<|/ a tags=perl dscore=4 |>\n<| c |>\n\
    Hmmm, I was thinking about this problem and came up with a pretty horrible recursive\
    \ solution too... But you beat me to it :-)\n<|/ c |>\n<| c |>\nI like this, though\
    \ I was going to just use a hash to do this, but this is really clever. I really\
    \ like the way you think and work around the problem of \"what if all elements\
    \ are equal\", but I think this solution is better than the recursive one. Thanks\
    \ for the help!\n<|/ c |>\n<| a tags=perl dscore=3 |>\nThis is a fairly standard\
    \ problem in programming contests.  It's called \"the longest increasing subsequence\"\
    \ or \"longest increasing subsequence\".  The standard dynamic programming algorithm\
    \ is called \"backtracking\", and you can read about it here.  The basic idea\
    \ is to write a recursive function that returns true if the current sequence of\
    \ numbers is a subsequence of the given sequence.  Then you can use a technique\
    \ called dynamic programming to determine what the longest increasing subsequence\
    \ is in the first place.\n<|/ a |>\n<| c |>\nThanks for sharing the name of the\
    \ algorithm. I looked at it before but couldn't see how it related to the problem\
    \ I had. Now I see that it's used to solve the subsequence problem.\n<|/ c |>\n\
    <| c |>\nThe \"longest increasing subsequence\" problem isn't actually a subsequence\
    \ problem, and isn't a common problem on many programming contests, so I wouldn't\
    \ call this a standard contest problem.  Perhaps it is but you didn't explain\
    \ what the goal was.  What I did explain was that this is how I solved it.\n<|/\
    \ c |>\n<| a |>\nThe shortest solution, using recursion, without using any modules\
    \ or hashes is this:\n<code>\nuse strict;", "    my(@result) = ();\n    my(@count)\
    \ = (0,0);\n    my(@sum) = (0,0);\n    my($i, $j);\n    for (@$l) {\n        $i\
    \ = $j = $_;\n        while (@count < @count) {\n            $j += $i; $sum[$i]\
    \ += $j;\n            ++$count[$i];\n            ++$count[$j];\n        }\n  \
    \      push(@result, $i) if(@count == @count);\n    }\n    while(@count > 0) {\n\
    \        shift(@count);\n        push(@result, pop(@count)) if(@count == 0);\n\
    \    }\n    $result[0] if(@result == 1 && @$l);\n    $result[0] if(@result ==\
    \ 0);\n    return;\n}", "    my(@result) = ();\n    my $i = 0;\n    for (my $j\
    \ = $i + 1; $j <= $#l; $j++) {\n        my($first) = $l[$i];\n        my($second)\
    \ = $l[$j];\n        $result[$i] .= $first . ' and ' . $second;\n        $result[$j]\
    \ .= $first . ' and' . $second;\n        $i++;\n    }\n    for my $i ($i + 1;\
    \ $i <= $#l; $i++) {\n        my($first) = $l[$i];\n        my($second) = $l[$i\
    \ - 1];\n        $result[$i] .= $first . ' and ' . $second;\n        $result[$i]\
    \ .= $first . ' and ' . $second;\n        $i++;\n    }\n    $result[$i] = '';\n\
    \    return @result;\n}\n</code>\n<|/ a |>\n<| a tags=perl,combinations,algorithm\
    \ |>\n<code>", "    # $a is the first element of the list\n    # $b is the second\
    \ element of the list\n    # $c is the sum of $a and $b\n    # $d is the index\
    \ of the last element of $l\n    my $c = $l[0];\n    my $d = @{$l} - 1;\n    $c\
    \ += $l[$d] if $d == 0;\n    my $b = $l[$d];\n    $c = $c - $b if $c > $b;\n \
    \   return $c > 0 ? 1 : 0;\n}", "    my $s = $l - $l % 2;\n    $s == 0 ? $l :\
    \ \"\";\n}", "    my $s = 0;\n    my $i = 0;\n    for(; $i < @$l; $i++) {\n  \
    \      $s += $l->[$i] if $l->[$i] >= 0;\n        $s += $l->[$i] * ($i - 1);\n\
    \    }\n    return $s > 0 ? '' : '';\n}", '    my $zero = 0;', "    if (@$l <=\
    \ 3) {\n        return \"\";\n    }\n    my($sum, $i, $j);\n    $sum = 0;\n  \
    \  for ($i = 0; $i < @$l; ++$i) {\n        $sum += $l->[$i];\n    }\n    if ($sum\
    \ == 0) {\n        return \"\";\n    }\n    for ($i = 0; $i < @$l; ++$i) {\n \
    \       $j = $i;\n        while ($j > 0 && $l->[$j-1] > $l->[$j]) {\n        \
    \    --$j;\n        }\n        $l->[$i] =~ s/^$l->[$i]//;\n        $l->[$j] =~\
    \ s/^$l->[$j]//;\n    }\n    if (@$l <= 3) {\n        return 1;\n    }\n    for\
    \ ($i = 0; $i < @$l; ++$i) {\n        $sum -= $l->[$i];\n        if ($sum < 0)\
    \ {\n            return \"\";\n        }\n    }\n    return 1;\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nThe time complexity of this solution is `O(N)`.\n<|/\
    \ c |>\n<| c |>\n: Why do you say that? I believe the complexity of the algorithm\
    \ is O(N) because of `pairs_sum_to_zero`'s time complexity.\n<|/ c |>\n<| c |>\n\
    You are right, of course. I was mistaken by this solution's time complexity. Time\
    \ complexity of Boris's solution is O(N^2), I missed it.\n<|/ c |>\n<| a dscore=2\
    \ |>\nIf your problem is a programming puzzle - which is much more fun to solve\
    \ than a puzzle to learn about - then you can use the following approach to solve\
    \ it:\nhttp://blog.mokokamediabetes.com/programming-puzzles/\nhttp://www.program-puzzle.com/index.php?page=puzzle\n\
    <|/ a tags=perl,algorithm,arrays |>\n<| c |>\nI believe this puzzle is based on\
    \ a specific programming language that uses Perl to solve the puzzle, which makes\
    \ it a much more interesting puzzle. Thanks for sharing.\n<|/ c |>\n<| a dscore=2\
    \ |>\nA perl one-liner that solves the puzzle is this\n<code>\nperl -e '@A = grep\
    \ /^0\\z/,[1..$#ARGV];print +(map{$A[$_] % 2 == 0 ? \"2\" : \"0\"}[0..$#A", " \
    \   if ( @$l < 2 ) { \n        return \"\"; \n    }\n    my $ret = 0;\n    my\
    \ $pair1 = shift @$l;\n    my $pair2 = shift @$l;\n    while ($pair1 and $pair2)\
    \ {\n        $ret += 1 if $pair1 + $pair2 == 0;\n        $pair1 -= 1;\n      \
    \  $pair2 -= 1;\n    }\n    return $ret ? \"\" : 1;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=perl dscore=1 |>\nI did a one liner which works for any size array\n\
    <code>\nperl -e '@a = split //,<DATA>; print 1 if grep { !/(0+)$/ } (@a);' <DATA>\n\
    </code>\nOutput\n<code>\n1\n</code>\n<|/ a |>\n<| a dscore=1 |>\nHere's another\
    \ option that is similar to other answers, but it uses hashes to keep track of\
    \ pairs of non-zero values seen:\n<code>\nuse warnings;\nuse strict;", "    return\
    \ unless (defined $l);\n    my $ans;\n    my $first = $l[0];\n    my $last = $l[-1];\n\
    \    for (my $i = 1;$i <= ($last - $first + 1);$i++) {\n        if ($first + $i\
    \ > $last) {\n            my $tmp = $first + $i - $last;\n            if ($tmp\
    \ < 0) {\n                $tmp = -$tmp;\n            }\n            if ($tmp !=\
    \ $ans) {\n                $ans = $tmp;\n            }\n        }\n    }\n   \
    \ return $ans;\n}", "    return unless @$l >= 2;\n    my($n1,$n2) = @$l[0..2];\n\
    \    for my $i (@$l) {\n        if ($i != $n1 + $n2 ) {\n            $n1 += $i;\
    \ $n2 += $i;\n            return if $n1 == $n2;\n        }\n    }\n    \"\";\n\
    }", "    my(@s) = (0);\n    my $zero = 0;\n    my ($i, $j, $n, $z);", "    if\
    \ ( $l ~~ m|^\\p{Pd} | ) {\n        $l = \"-\" . $l;\n    }\n    my $sum = 0;\n\
    \    for (; $l > 0) {\n        $sum = $l - $sum;\n        $l = $l % 10;\n    }\n\
    \    return if ( $sum == 0);\n    return 1;\n}", "    my(@s) = ();\n    my($result);\n\
    \    my ($i, $j);\n    foreach $i (@$l) {\n        foreach $j (@$l) {\n      \
    \      if ($i == $j) {\n                if ($i > 0 && $j > 0 && $s[$i-1] != $s[$j-1])\
    \ {\n                    $result = 1;\n                }\n                else\
    \ {\n                    $result = '';\n                }\n            }\n   \
    \         else {\n                $result = 1;\n            }\n            if\
    \ ($result) {\n                $s[$i] = $j;\n                $s[$j] = $i;\n  \
    \          }\n        }\n    }\n    if ($result) {\n        return 1;\n    }\n\
    \    return '';\n}", "    my(@r);\n    my $sum = 0;\n    for(@$l) {\n        if\
    \ (defined $r[$_] and $r[$_] eq $sum) {\n            print \"$r[$_] \";\n    \
    \    }\n        $sum += $_;\n        push, $_;\n        $r[$_] = $sum;\n    }\n\
    }", "    my $s = \"\";\n    for (my $i = 0; $i < @$l; $i++) {\n\tmy $zeros = 0;\n\
    \tfor (my $j = 0; $j < @$l; $j++) {\n\t    $zeros += 0 if $l->[$i] + $l->[$j]\
    \ == 0;\n\t}\n\tif ($zeros == 1) {\n\t    $s .= \" $l->[$i]\";\n\t}\n    }\n \
    \   return $s;\n}", "    $l =~ s/^(-?\\d+)//;\n    my $n = scalar @$l;\n    return\
    \ $n != $l ? \"\" : $n != 1 ? $n : 1;\n}", "    my $sum = 0;\n    my %seen;\n\
    \    foreach my $i (@$l) {\n        if (!$seen{$i}) {\n            $seen{$i} =\
    \ 1;\n            $sum += $i;\n        }\n    }\n    return ($sum < 0);\n}", " \
    \   my $sum = 0;\n    my $count = 1;\n    foreach my $i ( @$l ) {\n        $sum\
    \ += $i;\n        if ( $sum == 0 ) {\n            delete $l->[$count];\n     \
    \       $count--;\n        }\n    }\n    return $count ? \"\" : 1;\n}", '    my(@ret);',
  "    my $s = 0;\n    my $k;\n    foreach (@$l) {\n        my $v = $_;\n        if\
    \ ($v <= 0) {\n            $s = 0;\n            last;\n        }\n        $s +=\
    \ $v if $s == 0;\n        if ($s == 0) {\n            $s = 0;\n            last;\n\
    \        }\n    }\n    return 0 if $s == 0;\n    return 1;\n}", "    if (@$l ==\
    \ 1) {\n        return \"\";\n    }\n    my($sum) = sum($l);\n    my($zero) =\
    \ 0;\n    foreach my $a (@$l) {\n        $a += $zero;\n        if ($sum == $a)\
    \ {\n            return 1;\n        }\n        $a -= $zero;\n        if ($sum\
    \ != $a) {\n            return \"\";\n        }\n    }\n    return 0;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nIf all your numbers are positive, there is a much easier way,\
    \ which is to find the [GCD](http://en.wikipedia.org/wiki/Greatest_common_divisor)\
    \ of your numbers, and then compare their Euclidean GCD to the greatest common\
    \ divisor of your numbers.\n<|/ c |>\n<| a dscore=1 |>\n<code>\nuse strict;\n\
    use warnings;", "    my($r);\n    my($max);\n    my($n);\n    my(@pairs);", " \
    \   my($s);\n    for($l; $l > 0; $l -= 2) {\n        $s = $l; $s = 1 if ($s %\
    \ 2 != 0); $s = 1 if ($s == 0);\n        last if ($s == 0);\n    }\n    return\
    \ $s == 1;\n}", "    my %hash;\n    my $count = 0;\n    my $first = 1;\n    foreach\
    \ my $pair (@$l) {\n\t$hash{ $first } = $pair;\n\t$first = $first ? $pair : $pair+1;\n\
    \t$count++;\n    }\n    return $count < 2 ? \"\" : $hash{ 1 };\n}", "    my($max)\
    \ = @$l > 1 ? $l[1..@$l-1] : ();\n    my($min) = @$l > 1 ? $l[0..$l-1] : ();",
  '    return 1 if $l == ();', "    my $s = 0;\n    for(my $i = 0 ; $i < @$l ; $i++)\
    \ {\n        $s += $l->[$i];\n        $s-> = 0 unless $s->;\n    }\n    my $s\
    \ = $s ? \"1\" : \"0\";\n    return $s;\n}", "    my $num = $l->[0];\n    my $sum\
    \ = 0;\n    my $first;", '    my(@l1);', "    my @a = @_;\n    my $flag;\n   \
    \ for my $i (0..$#a) {\n        for my $j ($i+1..$#a) {\n            if ($a[$i]\
    \ + $a[$j] == 0) {\n                &carp(\"found a pair of sum-zero integers,\
    \ $i and $j. ignoring\");\n                $flag = 1;\n                break;\n\
    \            } else {\n                $flag = 0;\n            }\n        }\n\
    \        if ($flag) {\n            return 1;\n        }\n    }\n    return \"\"\
    ;\n}", "    my $s = 0;\n    my %seen;\n    map {\n        ++$seen{$_}; $s++ if\
    \ $seen{$_} == 0;\n    } (0..$#$l) if @$l > 0;\n    return 1 if $s == 0;\n   \
    \ return '';\n}", "    my($sum, $t);\n    foreach $t (@$l) {\n        $sum = $sum\
    \ + $t;\n    } \n    return $sum == 0;\n}", "    my $sum = 0;\n    for(my $i =\
    \ 0; $i < @$l; $i++) {\n        $sum += $l->[$i];\n        last if $sum == 0;\n\
    \    }\n    return 0 if $sum == 0;\n    return 1;\n}", "    my $total = $$l;\n\
    \    my $sum = 0;\n    my $i = @$l - 1;\n    while ($i > 0 && $$l[$i] > 0) {\n\
    \        $sum += $$l[$i];\n        $i--;\n    }\n    return \"\" unless $sum ==\
    \ 0;\n    my $diff = $total - $sum;\n    my $i = 0;\n    while ($i < @$l && $$l[$i]\
    \ == 0) {\n        $i++;\n    }\n    my $diff2 = $total - $sum;\n    return \"\
    \" unless $diff == $diff2;\n    my $i = 0;\n    while ($i < @$l && $$l[$i] ==\
    \ 0) {\n        $i++;\n    }\n    my $j = 0;\n    while ($j < $i - 1 && $$l[$i]\
    \ == 0) {\n        $j++;\n    }\n    $i += $j;\n    my $count = 0;\n    while\
    \ ($i < @$l) {\n        if ($$l[$i] == 0) {\n            $count++;\n        }\n\
    \        $i++;\n    }\n    return $count == @$l ? \"1\" : \"\";\n}", "    my $zero\
    \ = 0;\n    my $pairs = 0;\n    for (my $n = 0; $n < @$l; $n++) {\n        if\
    \ ($l->[$n] == 0) {\n            $zero++;\n        } elsif ($l->[$n] != 0) {\n\
    \            $pairs++;\n        }\n    }\n    if ($pairs == 0) {\n        return\
    \ 0;\n    } else {\n        return 1;\n    }\n}", "    my($n) = @$l;\n    my $result\
    \ = 1;", "    if (scalar @$l == 1) {\n        return '';\n    }\n    \n    my(@m)\
    \ = ();\n    my($mv) = @$l;\n    $mv = $mv->[0] if (! ref $mv);\n    \n    for\
    \ my $i (0..$#$mv) {\n        $m[$i] = $mv->[$i];\n    }\n    for my $i (0..$#$mv)\
    \ {\n        for my $j (0..$#$mv) {\n            next if $i == $j;\n         \
    \   next if $m[$i] + $m[$j] > 0;\n            if ($m[$i] + $m[$j] < 0) {\n   \
    \             $m[$j] = -$m[$j];\n            }\n            $m[$i] += $m[$j];\n\
    \            $m[$j] = $m[$i];\n        }\n    }\n    \n    if (scalar @$m == 2)\
    \ {\n        return '1';\n    }\n    return '';\n}", "    my @a = grep {!$_};\
    \ # remove null elements for pairs\n    my @t = grep {$_}; # remove duplicate\
    \ elements for pairs\n    my $n = 0;\n    my $s = @t; \n    for(my $i=0;$i<$s;$i++)\
    \ {\n        for(my $j=$i+1;$j<$s;$j++) {\n            my $sum = $t[$i] + $t[$j];\n\
    \            if ($sum != 0) {\n                if ($t[$i] == $t[$j]) {\n     \
    \               $n++;\n                }\n            }\n        }\n    }\n  \
    \  return \"\" if $n == 0;\n    return $n == 1 ? $t[0] : $n;\n}", "    my $count\
    \ = 1;\n    my $sum = 0;\n    for (@$l) {\n        my $n = $_;\n        $sum +=\
    \ $n;\n        if ($sum == 0) {\n            $count++;\n        }\n    }\n   \
    \ return $count > 1;\n}", "    return \"\" if (@$l < 2);\n    my($first, $second,\
    \ $sum);\n    for my $num (@$l) {\n        $sum += $num;\n        $first = $num\
    \ if $sum == 0;\n        $second = $num if $sum != 0;\n        return 1 if ($first\
    \ == $second);\n    }\n    return \"\";\n}", "    my @a = ();\n    my @b = ();",
  "    my $l = length @$l;\n    my $n = $l/2;\n    my $sum;\n    my $first;\n    my\
    \ $second;", "    my $n = @$l;\n    for (my $i = 0; $i < $n; ++$i) {\n       \
    \ for (my $j = $i + 1; $j < $n; ++$j) {\n            if ($l->[$i] + $l->[$j] eq\
    \ 0) {\n                return \"\";\n            }\n        }\n    }\n    return\
    \ 1;\n}", "    return \"\" unless @$l && @$l==1 && $l->[0] >= 0;\n    my $sum\
    \ = $l->[0]; # this should be faster to $l->[0] +=\n    for my $i (1..@$l) {\n\
    \        $sum += $l->[$i];\n        if ($sum == 0)\n        {\n            return\
    \ \"\";\n        }\n    }\n    return 1 if $sum == 0;\n    return \"\";\n}", " \
    \   if (scalar @$l <= 1) {\n        return \"no pairs sum to zero\";\n    }",
  "    my(@sums) = (0);\n    my(@count);\n    my(@count);", "    my $n = 0;\n    my\
    \ @r;", "    my %seen = ();\n    foreach my $i (@$l) {\n\tmy $n = scalar @$l;\n\
    \tforeach my $j ($i+1..$n) {\n\t    my $s = $seen{$i} + $seen{$j};\n\t    if ($s\
    \ == 0) {\n\t\t$seen{$j} = $i;\n\t\treturn \"1\";\n\t    }\n\t}\n    }\n    return\
    \ \"\";\n}", "    my %seen;\n    $seen{$_}++ for@$l;\n    my $ret = $#seen ==\
    \ $#l ? \"\" : 1;\n    return $ret;\n}", "    my(@r) = ();\n    my $n = 0;\n \
    \   my $s = 0;\n    my $max = 0;\n    while (my $t = shift @l) {\n        if ($t\
    \ < 0) {\n            push (@r, \"-\");\n            $t *= -1;\n        }\n  \
    \      $n = $n + ($t / $l[0]) + 1;\n        $s = $s + ($t % $l[0]) / $l[0];\n\
    \        push (@r, ($t < 0) and $t >= $l[0] and $t - $l[0] or $t);\n        push\
    \ (@r, ($t == 0) and 1 or 0);\n        if ($n > $max) {\n            $max = $n;\n\
    \        }\n    }\n    if ($s == 0) {\n        return \"\";\n    }\n    return\
    \ join (\"\", map { $max > $l[0] and $_ . \"1\" or \"0\" } @r);\n}", "    my $sum\
    \ = 0;\n    for (@$l) {\n        $sum += $_;\n    }\n    return 1 if $sum == 0;\n\
    \    return \"\";\n}", "    my $sum = 0;\n    my $result = \"\";\n    foreach\
    \ my $val (@$l) {\n        if ($val > 0) {\n            $sum += $val;\n      \
    \      if ($sum == 0) $result = \"1\";\n            else {\n                if\
    \ ($sum > 0) $result = \"1\";\n                else        $result = \"0\";\n\
    \            }\n        }\n    }\n    return $result;\n}", "    my(@a) = @$l;\n\
    \    my $res = \"\";\n    my @a = sort {\n\tmy($v_one, $v_two) = @$_;\n\treturn\
    \ $v_one <=> $v_two;\n    } @a;\n    for (my $i = 0; $i < $#a; ++$i) {\n\tfor\
    \ (my $j = 0; $j < $#a; ++$j) {\n\t    my $v_one = $a[$i];\n\t    my $v_two =\
    \ $a[$j];\n\t    if ($v_one + $v_two == 0 and not $v_one eq $v_two) {\n\t\t$res\
    \ = $v_one . $v_two;\n\t\tlast if ($i < $j);\n\t    }\n\t}\n    }\n    return\
    \ $res;\n}", "    # add each element to the array, and sort it\n    my(@u) = ();\n\
    \    my(@s) = ();\n    foreach my $elem (@$l) {\n        push(@u, $elem);\n  \
    \      push(@s, $elem);\n    }\n    sort(@u);\n    sort(@s);", "    my $result\
    \ = \"\";\n    foreach my $i (0 .. $#$l) {\n        my $j = $i + 1;\n        if\
    \ ($l[$i] == 0) {\n            if ($l[$j] == 0) {\n                $result .=\
    \ \"$i $j\";\n            } else {\n                $result .= \"$i $j $l[$j]\"\
    ;\n            }\n        } elsif ($l[$i] == $l[$j]) {\n            $result .=\
    \ \"$i $j $l[$j]\";\n        } else {\n            $result .= \"$i $j $l[$i] $l[$j]\"\
    ;\n        }\n    }\n    return $result;\n}", "    my($c);\n    my($pairs);\n\
    \    foreach $l (@$l) {\n        $c = 0;\n        $pairs[$c] = [];\n        foreach\
    \ $l (@$l) {\n            if($l == 0) {\n                $c = $c - 1;\n      \
    \      }\n            else {\n                if($pairs[$c][0] == $l) {\n    \
    \                push(@$pairs[$c], $l);\n                    $c = $c - 1;\n  \
    \              }\n                else {\n                    push(@$pairs, [$l]);\n\
    \                    $c = $c + 1;\n                }\n            }\n        }\n\
    \    }\n    if($c == 0){\n        return \"\";\n    }\n    else {\n        if($c\
    \ == 1) {\n            return $pairs[0];\n        }\n        else{\n         \
    \   return $pairs;\n        }\n    }\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n\
    Here is another solution with O(n) complexity:\n<code>", "    my $result = \"\"\
    ;\n    my $last_val = 0;\n    for (my $i = 0; $i < @$l; $i++) {\n        my $val\
    \ = $l->[$i];\n        if ($val < 0) {\n            $last_val += $val;\n     \
    \   } else {\n            $result += \"$last_val + $val\";\n            $last_val\
    \ = $val;\n        }\n    }\n    return $result == \"\";\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThis is nice. But, why do you think this can be made faster?\n<|/ c |>\n\
    <| c |>\n: It took some time because of the repeated concatenations, for example.\n\
    <|/ c |>\n<| c |>\nI think it can be made faster by using a `push()` inside the\
    \ loop instead of repeated concatenations.\n<|/ c |>\n<| c |>\n: In any case,\
    \ the OP has clearly been a Python programmer since he wrote the answer, and doesn't\
    \ know how to do string concatenation in Perl.\n<|/ c |>\n<| c |>\nWell, it's\
    \ not a matter of string concatenation anymore because you have a `+` in the loop.\
    \ At least it's faster. But I don't think it's faster than the other one.\n<|/\
    \ c |>\n<| a dscore=2 |>\nYou can use hash as suggested in another answer. But\
    \ in case you want to do it as it is in your question, you can try this:\n<code>\n\
    use strict;\nuse warnings;\nuse List::Util qw( sum );", "    my ($zero,$two, $pairs_sum_to_zero);\n\
    \    $pairs_sum_to_zero = \"\";\n    if (scalar($l) == 0) {\n        return $pairs_sum_to_zero;\n\
    \    }\n    for my $i (0 .. $#l) {\n        if ($l[$i] == 0) {\n            push\
    \ @$pairs_sum_to_zero, $i;\n            push @$pairs_sum_to_zero, $i;\n      \
    \  }\n    }\n    my $zero_index = 0;\n    for (my $i = 0; $i < scalar(@$l); ++$i)\
    \ {\n        for ($i = $i; $i < scalar(@$l); ++$i) {\n            $two += $l[$i];\n\
    \            if ($two > 0) {\n                if ($l[$i] == 0) {\n           \
    \         $zero = $i;\n                    $zero_index = $i;\n               \
    \ }\n                $two -= $l[$i];\n                last;\n            }\n \
    \       }\n    }\n    return if ($zero_index == 0 && $zero == $#l);\n    for ($zero_index\
    \ = 0; $zero_index < scalar(@$l); ++$zero_index) {\n        my $two = $l[$zero_index];\n\
    \        if ($two > 0) {\n            $l[$zero_index] -= $l[$zero_index];\n  \
    \          if ($l[$zero_index] == 0) {\n                @$pairs_sum_to_zero =\
    \ ();\n                last;\n            }\n        }\n    }\n    return if (scalar(@$pairs_sum_to_zero)\
    \ == 0);\n    my $pairs_sum_to_zero = join(\",\", @$pairs_sum_to_zero);\n    if\
    \ ($pairs_sum_to_zero == $zero) {\n        @$pairs_sum_to_zero = ();\n    }\n\
    \    $pairs_sum_to_zero;\n}", "    return 0 if ($l =~ /\\A\\s*(-?\\d+)\\s+(-?\\\
    d+)\\s*\\Z/);\n    my $i = $1;\n    my $j = $2;\n    my $sum = 0;\n    while ($i\
    \ < @$l) and (!$pair{$i}->{$j}) {\n        $sum += $l->[$i];\n        $i++;\n\
    \    }\n    while ($i < @$l) and (!$pair{$i}->{$j}) {\n        $sum += $l->[$i];\n\
    \        $i++;\n    }\n    return $sum == 0;\n}", "    # Your code here\n    if\
    \ ( $l[0] ~~ map { 0 + } @$l ) {\n        return \"\";\n    }\n    my $sum;\n\
    \    foreach my $ls (@$l) {\n        $sum += $ls;\n    }\n    if ( $sum > 0 )\
    \ {\n        return 1;\n    }\n    else return \"\";\n}", "    return if @$l ==\
    \ 0;\n    my $s = 0;\n    for my $k (@$l) {\n        $s = $k + $s if $k != 0 ||\
    \ $k == $s;\n    }\n    return '' unless $s;\n    return $s % 2 == 0;\n}", " \
    \   my %pairs = ();\n    $pairs{$_}++ while $_ =~ m/([\\-\\d]+)\\/([\\-\\d]+)\\\
    Z(?!\\n)/g;\n    return undef unless %pairs;\n    my @sorted_pairs = sort { $a\
    \ <=> $b } values %pairs;\n    for (my $i = 0; $i < $#sorted_pairs; ++$i) {\n\
    \        my $a = $sorted_pairs[$i];\n        my $b = $sorted_pairs[$i + 1];\n\
    \        if ($a != $b && ($a <=> 0) != ($b <=> 0)) {\n            return \"$a\\\
    \\/$b\";\n        }\n    }\n    return \"\";\n}", "    my @a = ();\n    my $s\
    \ = 0;\n    for (@$l) {\n        my $n = $_;\n        $a[1] += $n;\n        $a[2]\
    \ += $n;\n        $s += $n;\n    }\n    return 1 if $a[1] < $a[2];\n    return\
    \ 0 if $a[1] > $a[2];\n    return 1 if $s == 0;\n    return \"\";\n}", "    my\
    \ @a;\n    $l = 0;\n    for(@$l) {\n        push @a, $_ if($_ != 0);\n    }\n\
    \    if(scalar(@a) == 1) {\n        push @$l, 1;\n    }\n}", "    my $s = 0;\n\
    \    my $zero = 0;\n    for (@$l) {\n        $s += $_;\n        $zero += $_ if\
    \ $_ == 0;\n    }\n    $zero < $s;\n}", '    $l = sort {$a <=> $b} @$l;', "  \
    \  my %h;\n    foreach my $i (@$l) {\n        $h{$_} //= $i;\n    }\n    foreach\
    \ my $i (keys %h) {\n        next unless $i < 0;\n        if (exists $h{-$i})\
    \ {\n            return 1;\n        }\n    }\n    return '';\n}", "    my $result\
    \ = \"\";\n    foreach my $i (0 .. $#$l) {\n        my $sum = 0;\n        for\
    \ my $j (0 .. $#$l) {\n            next if $j == $i;\n            $sum += $l->[$i][$j]\
    \ if $l->[$i][$j] != 0;\n        }\n        if ($sum == 0){\n            $result\
    \ = $result ? \"1\" : \"\";\n        }\n    }\n    return $result;\n}", "    return\
    \ if(scalar(@$l) <= 1);\n    return if(scalar(@$l) == 1);\n    return if($l->[0]\
    \ < 0);", "    $l[0] > $l[-1] if  $l[0] > $l[-1];\n    $l[0] < $l[-1] if  $l[0]\
    \ < $l[-1];\n    my @a = @$l;\n    my $cnt = 0;\n    for(my $i = 0; $i < @a -\
    \ 1; $i++){\n        $cnt += $a[$i] <= $a[$i + 1] ? 0 : 1;\n    }\n    if($cnt\
    \ > 1){\n        return 1;\n    }\n    else { return 0; }\n}", "    my $sum =\
    \ 0;\n    my $count = -1;\n    my $is_pair_sum = 0;\n    for (my $i = 0; $i <\
    \ @$l; $i++) {\n        $sum += $l->[$i];\n        $count++;\n    }\n    $is_pair_sum\
    \ =\n        $sum == 0 ||\n        $sum == 1 || $sum == -1 || $sum == -2 ||\n\
    \        $sum == -3 || $sum == -4 || $sum == -5 ||\n        $sum == -6 || $sum\
    \ == -7 ||\n        $sum > 0 && $sum < 1000 && $sum != -999;\n    return $is_pair_sum\
    \ ? 1 : 0;\n}", "    my $max;\n    my $result;\n    my ($i, $j, $sum);\n    for\
    \ $i (0..$#$l-1) {\n        $sum = $l->[$i];\n        for (my $j = $i+1 ; $j <\
    \ $#$l ; $j++) {\n            $sum += $l->[$j];\n            if ($sum == 0){\n\
    \                return 1 if $i != $j;\n                $result = 1;\n       \
    \     }\n        }\n    }\n    return $result;\n}", "    my $result = '';\n  \
    \  foreach my $pair (@$l) {\n        foreach my $item (@$l) {\n            last\
    \ if $item == $pair and $item == 0;\n        }\n        $result = $result ? \"\
    1\\n\" : \"\\n\";\n    }\n    return $result;\n}", "    my $pairs = @$l;\n   \
    \ my $sum = shift(@$l);\n    return '' unless $pairs and $sum;\n    for (my $i\
    \ = 0; $i < $#{$pairs} - 1; $i++) {\n        my $a = $pairs[$i];\n        my $b\
    \ = $pairs[$i + 1];\n        return 1 if $a + $sum != $b;\n    }\n    return;\n\
    }", "    my $sum = 0;\n    my $count = 0;\n    foreach my $n (@$l) {\n       \
    \ next if $sum == 0;\n        $sum += $n;\n        $count += 1;\n        if ($count\
    \ == 2) {\n            return 1;\n        }\n    }\n    return \"\";\n}", "  \
    \  my $sum = 0;\n    my(@a, @b); # holds the pairs whose sum is zero\n    my(@aidx,\
    \ @bidx, @sum);", "    my $sum = 0;\n    foreach my $v (@$l) {\n        if ($v\
    \ > 0) {\n            $sum += $v;\n        }\n    }\n    $sum == 0 ? \"\" : $sum;\n\
    }", "    my $s = pairs_to_sum ($l);\n    return ($s eq \"\");\n}", "    my $sum\
    \ = 0;\n    foreach (@$l) {\n        if ($sum == $_ ) {\n            return '';\n\
    \        }\n        $sum += $_;\n    }\n    return '';\n}", "    \n    my $result;\n\
    \    foreach my $i (0..$#$l) {\n        my $n1 = $l->[$i];\n        my $n2 = $l->[$i\
    \ + 1];\n        if ($n2 == 0) {\n            $result = 1;\n            last;\n\
    \        }\n        elsif ($n1 == $n2) {\n            $result = 1;\n         \
    \   last;\n        }\n    }\n    return $result;\n}", "    $l =~ tr/+-/0/;\n \
    \   if ( $l == 0 ) {\n        $a = \"1\";\n        $b = \"0\";\n    }\n    else\
    \ {\n        $a = \"1\";\n        $b = \"1\";\n        for ( my $i = 0; $i < (\
    \ @$l ); $i++ ) {\n            if ( $l->[$i] > 0) {\n                $a = $b ==\
    \ 0 ? \"1\" : \"0\";\n                $b = $l->[$i];\n            }\n        \
    \    else {\n                $b = $b == 0 ? \"0\" : \"1\";\n            }\n  \
    \      }\n    }\n    return $a . $b == 0 ? \"\" : $a . $b == 1 ? 1 : 0;\n}", " \
    \   my $s = 0;\n    my $n = 0;\n    for my $i (0 .. $#l) { \n        if ($l[$i]\
    \ > 0) {\n            ($s = $s+$l[$i], $n = $n+1);\n        }\n    }\n    return\
    \ $n if ($s == 0);\n    return 1;\n}", "    my($c);\n    my($r);\n    $r = 0;",
  "    my @pairs = pairs(@$l);\n    return $pairs->[0] ? $pairs->[0] : $pairs->[1];\
    \ \n}", "    if (@$l == 0) {\n        return \"\"\n    }\n    my $sum = 0;\n \
    \   my $index = 0;\n    my $maxindex = $#$l;\n    for (my $i = 0; $i < $maxindex;\
    \ $i++) {\n        $sum += $l->[$i];\n        if ($sum == $l->[$i]) {\n      \
    \      $index = $i;\n            $sum += 0;\n        }\n    }\n    if ($sum ==\
    \ 0) {\n        return \"\";\n    }\n    if ($sum > 0) {\n        return $l->[$index];\n\
    \    }\n}", "    return '' unless @$l;\n    my $ret = 0;\n    my %seen;\n    \n\
    \    my $cur = pop(@$l);\n    foreach my $x (@$l) {\n        $seen{$cur+$x} =\
    \ $x;\n        $ret += $cur+$x if $seen{$cur+$x};\n    }\n    \n    return $ret==1\
    \ ? '' : $ret;\n}", "    my $s = \"\";\n    my %hash;\n    foreach my $pair (@$l)\
    \ {\n        my $value = $pair->[0];\n        my $sum = $pair->[1];\n        if\
    \ (exists $hash{$value} and $hash{$value} == $sum) {\n            $s = \"1\";\n\
    \            last;\n        }\n        $hash{$value} = $sum;\n    }\n    return\
    \ $s;\n}", "    # count the distinct elements in the array\n    my($c) = scalar(@$l);\n\
    \    # check each element for one with $c distinct elements\n    my $i;\n    for\
    \ ($i = 0; $i < $c; $i++) {\n        $l[$i] >= 0 && $l[$i + 1] >= 0\n        \
    \    or next;\n        $l[$i + 1] + $l[$i] == 0\n            or next;\n      \
    \  return 1;\n    }\n    return 0;\n}", "    my $max;\n    my($sum) = pairs($l);\n\
    \    return \"\" if $sum == 0;\n    $max = $sum;\n    foreach my $pair (pairs($l))\
    \ {\n        my $s = $pair->[0];\n        if ($sum - $s > $max) {\n          \
    \  $max = $sum - $s;\n        }\n    }\n    return $max != 0;\n}", "    my $sum\
    \ = 0;\n    my $num_pairs = @$l;\n    my $pair;\n    for (my $i = 0; $i < $num_pairs-1;\
    \ $i++) {\n        $pair = $l->[$i];\n        $sum += $pair;\n    }\n    $sum\
    \ == 0 ? \"\" : $l->[$i] == $l->[$i+1] ? \"1\" : \"\";\n}", '    my ($n1,$n2)
    = (0,0);', "    my $ret = \"\";\n    for (my $i = 0; $i < @$l; ++$i) {\n     \
    \   for (my $j = 0; $j < @$l; ++$j) {\n            next unless $j > $i || $l->[$i]\
    \ + $l->[$j] == 0;\n            if ($ret eq \"\") {\n                $ret = $l->[$i]\
    \ + $l->[$j];\n            }\n            else {\n                $ret += \" +\
    \ \" . $l->[$i] . \" + \" . $l->[$j];\n            }\n        }\n    }\n    return\
    \ $ret;\n}", "    my $max = @$l > 1 ? $l->[-1] : 0;\n    my $max_index = -1;\n\
    \    my $num;", "    return if @$l < 2;\n    my($sum) = 0;\n    my($found) = 0;\n\
    \    for (my $i = 0; $i < @$l - 1; $i++) {\n        my($j = $i + 1);\n       \
    \ if ($j < @$l) {\n            my $tmp_sum = $$l[$i] + $$l[$j];\n            $sum\
    \ += $tmp_sum if $tmp_sum != 0;\n            $found = $1 if $sum == 0;\n     \
    \   }\n    }\n    return $found ? \"1\" : \"0\";\n}", "    my $ret = \"\";\n \
    \   my $n = @$l;\n    my $s = ($n-1)/2;\n    my $k = 0;\n    my $zeros = 0;\n\
    \    for(my $i = 0; $i < $n; $i++) {\n        if ($l->[$i] == 0) {\n         \
    \   $zeros++;\n        } else {\n            my $j = $i+$s;\n            if ($l->[$i]\
    \ + $l->[$j] < 0) {\n                $l->[$k] = $l->[$i];\n                $k++;\n\
    \            }\n            else {\n                $l->[$k] = $l->[$j];\n   \
    \             $k++;\n            }\n        }\n    }\n    for(my $j = 0; $j <\
    \ $n; $j++) {\n        if ($l->[$j] == 0) {\n            $zeros++;\n        }\n\
    \    }\n    if ($zeros == $n) {\n        $ret = 1;\n    }\n    return $ret;\n}",
  "    my $result = '';\n    my @pairs = ();\n    foreach my $i (0 .. $#$l) {\n  \
    \      my $x = $l->[$i];\n        my $y = 0;\n        foreach my $j ($i+1 .. $#$l)\
    \ {\n            my ($z, $sum) = @{$l->[$i]};\n            next if $sum == 0;\n\
    \            my ($z1, $sum1) = @{$l->[$j]};\n            next if $sum1 == 0;\n\
    \            next unless $sum > 0;\n            $y = $z1 + $y;\n        }\n  \
    \      $result = $x if $y == 0;\n        $pairs[$i] = $y;\n    }\n    return ($result,\
    \ @pairs);\n}", "    \n    my $zeros = 0;\n    \n    $l->reverse;\n    while($l->[0])\
    \ { $zeros += $_->[0]; $l->shift; }\n    \n    foreach my $x (@$l) {\n       \
    \ my $y = $x + $zeros;\n        unless( $y < $zeros) { last; }\n        \n   \
    \     my $a = $x - $y;\n        my $b = $zeros - $y;\n        \n        return\
    \ $a ? \"1 $a $b\" : $b ? \"1 $b $a\" : \"\";\n    }\n}", "    my $s = $l->[0];\n\
    \    my $r = $l->[1];\n    my @a = @$l;\n    for my $i (0 .. $#a-1) {\n      \
    \  my $j = $i + 1;\n        if ($a[$i] + $a[$j] != 0) {\n            $s = 1;\n\
    \            last if $r > 0;\n        }\n    }\n    return $s ? \"\" : \"1\";\n\
    }", "    my $s = 0;\n    my @result;\n    foreach my $i (@$l) {\n        $s +=\
    \ $i;\n        push (@result, $i) unless ($result[$_ + 1] == $i for my $_ (@$l));\n\
    \        push (@result, $s) unless ($result[$_ + 1] == $s for my $_ (@$l));\n\
    \    }\n    my $s = $result[$_ + 1] for my $_ (@$l);\n    return 1 if $s == 0;\n\
    \    return \"\";\n}", "    my $zeros = 0;\n    my($i, $j, $temp);\n    for ($i\
    \ = 0; $i < scalar(@$l); $i++) {\n        $temp = $l->[$i];\n        for ($j =\
    \ 0; $j < scalar(@$l); $j++) {\n            last if $j > $i or $l->[$j] == $temp;\n\
    \            if ($l->[$i]+$l->[$j] == 0) {\n                $zeros++;\n      \
    \          last;\n            }\n        }\n    }\n    return $zeros == 2 ? ''\
    \ : $zeros;\n}", "    my $total = 1;\n    for my $n ( @$l ) {\n        $total\
    \ += $n;\n    }\n    return $total <= 0;\n}", '    $l =~ tr/a-z/A-Z/;', '    my
    $zero = 0;', "    my($sum);\n    my $zeros = 0;\n    foreach (@$l) {\n       \
    \ my $x = $_;\n        $sum += $x;\n        if ($sum == 0) {\n            $zeros\
    \ += 1;\n        }\n    }\n    return $zeros == 1 ? \"\" : \"1\";\n}", "    my\
    \ $sum;\n    for (my $i = 0; $i < @$l; $i++) {\n        $sum += $l->[$i];\n  \
    \  }\n    return if $sum == 0;\n    return 1;\n}", "    my $n = 0;\n    for my\
    \ $i (0 .. $#$l)\n    {\n        for my $j ($i+1 .. $#$l)\n        {\n       \
    \     $n++ if ( $l->[$i]+$l->[$j] == 0 );\n        }\n    }\n    $n;\n}", "  \
    \  my(@pairs);\n    my($zero) = 0;", "    my $result = 0;\n    for my $i (0 ..\
    \ $#$l) {\n        for my $j ($i .. $#$l) {\n            my $value = $l->[$i]\
    \ + $l->[$j];\n            $result = 1 if $value == 0;\n        }\n    }\n   \
    \ $result ? \"\" : \"1\";\n}\n</code>\nThe above subroutine works well for me:\n\
    <code>\nuse v5.14;\nuse Data::Dumper;", "    my($sum);\n    my($pairs);\n    foreach\
    \ $i (@$l) {\n\t$sum += $i;\n\tforeach $j (@$l) {\n\t    unless ($j > $i) {\n\t\
    \tif ($sum == 0) {\n\t\t    $sum = $j;\n\t\t    next;\n\t\t}\n\t\tif ($sum ==\
    \ $j) {\n\t\t    $pairs .= \"$i,$j\";\n\t\t    next;\n\t\t}\n\t    }\n\t}\n  \
    \  }\n    return $pairs ? $pairs : \"no solutions\";\n}", "    my($pairs) = @$l;\n\
    \    my(@sum) = ();", "    my $sum;\n    my $zero = 0;\n    foreach my $i (0 ..\
    \ $#l) {\n        $sum += $l[$i];\n        if ($sum == 0) {\n            $zero++;\n\
    \        }\n    }\n    if ($sum != 0) {\n        return 0;\n    }\n    return\
    \ 1;\n}", "    my $sum;\n    my $flag;\n    my $count;\n    for(my $i=0; $i<@$l;\
    \ ++$i){\n        $flag = $flag || $l->[$i];\n        $sum = $sum + $l->[$i];\n\
    \        $count++;\n        if($sum == 0){\n            $l->[$i] = 1;\n      \
    \  }\n    }\n    if(!$flag){\n        return \"\";\n    }\n    elsif($count ==\
    \ @$l){\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}", '    my
    @ret = ();', "    my $ret = \"\";\n    for( @$l ){\n        my $pair = ($_ - $_);\n\
    \        if( $pair > 0 ){\n            $ret .= ($pair > 1 ? \"s \" : \"\") . $_;\n\
    \        }\n    }\n    return $ret;\n}", "    return if $l->[0] > 0;\n    my($ret);\n\
    \    for my $i ( 0 .. $l->[-1] ) {\n        my $j = $i + 1;\n        $ret .= \"\
    \ \" unless $l->[$i] == $l->[$j];\n        if ( $l->[$i] <= 0 ) {\n          \
    \  $ret .= \"$i $l->[$i] $j $l->[$j]\";\n        }\n    }\n    if ( $ret eq \"\
    \ \" ) { return \"\"; }\n    elsif ( $ret ne \"$l->[-1] $l->[-1] $l->[0]\") {\
    \ return $ret; }\n    return 1 ;\n}\n</code>\n<|/ a |>\n<| a |>\nI used a hash\
    \ instead, where key is the sum and the value is the number of times it occurs.\n\
    <code>", "    if (scalar(@$l) == 1) {\n\treturn \"\" unless $l->[0] =~ /^-?\\\
    d+$/;\n\treturn 1 if $l->[0] > 0;\n    }\n    my(@s) = ($l->[0] + $l->[1]) =~\
    \ /^(-?\\d+)+$/;\n    return 0 if scalar(@s) != 2;\n    return 1 if $s[0] > $s[1];\n\
    \    return 1;\n}", "    my $sum = 0;\n    for (my $i = 0; $i <= $#l; $i++) {\n\
    \        $sum += $l[$i];\n    }\n    return 0 if $sum == 0;\n    return 1 if $sum\
    \ == -1;\n    return;\n}", "    # your code goes here\n    my $count = 1;\n  \
    \  for my $i (0..$#$l) {\n        for my $j ($i+1..$#$l) {\n            if ($l->[$i]\
    \ + $l->[$j] eq 0) {\n                $count++;\n                last;\n     \
    \       }\n        }\n    }\n    return $count;\n}", "    my $s = 0;\n    my $n\
    \ = @$l;\n    for (my $i = 0; $i < $n; $i++) {\n        my $e = $l->[$i];\n  \
    \      if ($e != 0) {\n            $s += $e;\n        }\n    }\n    return $s;\n\
    }", "    return 1 if @$l == 2;\n    return '' if @$l == 1;\n    my $sum = 0;\n\
    \    foreach (@$l) {\n\t$sum += $_;\n    }\n    return '1' if $sum == 0;\n   \
    \ return '';\n}", "    my(@l) = split(/,/, $l);\n    my($t);\n    my(@t);\n  \
    \  my($num);\n    my($sum);", "    my $sum = 0;\n    while ($l > 0) {\n      \
    \  my $n = int rand $l;\n        my $tmp = $sum + $n;\n        return $1 if $sum\
    \ == $tmp;\n        $sum = $tmp;\n    }\n    return \"\";\n}", "    my $s = 0;\n\
    \    for(my $i = 0; $i < @$l; $i++) {\n        if(exists $self->{$l->[$i]}) {\n\
    \            next if $self->{$l->[$i]} ne $l->[$i];\n            $s += $self->{$l->[$i]};\n\
    \        }\n    }\n    return $s;\n}", "    my $count = $l->[-1]; # get the last\
    \ element and count it\n    if ($l->[-2] eq $l->[-1]) { # if element at end and\
    \ end are equal\n        return $l->[-1] > 0 ? '' : '1'; # return 1\n    }\n \
    \   else { # if they aren't equal\n        return $count > 2 ? '' : $l->[-1] >\
    \ 0 ? '1' : '0'; # return 0\n    }\n}", "    # create array containing the positive\
    \ integers in the list\n    # this list will have length (length($l)+1)\n    my($positives)\
    \ = ();\n    my($pos_ind);\n    for ($pos_ind = 0; $pos_ind < $#l; $pos_ind++)\
    \ {\n        if ($l[$pos_ind] > 0) {\n            $positives[$pos_ind] = $l[$pos_ind];\n\
    \        } else {\n            $positives[$pos_ind] = 0;\n        }\n    }", " \
    \   my $ret = '';\n    my $i = 1;\n    my $j = 1;\n    my $sum = 0;\n    my $num\
    \ = 0;\n    while ($i < @$l and $j < @$l) {\n        $sum = $$l[$i] + $$l[$j];\n\
    \        if ($sum < 0) {\n            $sum = 0;\n        }\n        $num = $$l[$i]\
    \ + $$l[$j];\n        if ($num < 0) {\n            $num = 0;\n        }\n    \
    \    if (($sum == 0) || ($num == 0)) {\n            $ret .= \" \";\n        }\n\
    \        elsif ($sum != 0) {\n            $ret .= \"$num $sum\";\n        }\n\
    \        elsif ($num != 0) {\n            $ret .= \"-$num\";\n        }\n    \
    \    $j++;\n        $i++;\n    }\n    $ret .= \" \";\n    return $ret;\n}", " \
    \   return \"\" unless(@$l > 0);\n    return \"\" if($l->[0] == $l->[1]);\n  \
    \  return \"\" if $l->[0] < 0;\n    my(@s) = $l->[0];\n    my(@u) = @$l->[1];\n\
    \    my $zero = 0;\n    for(0..scalar(@l-1)) {\n        $zero += $l->[$_][$_];\n\
    \    }\n    for(0..scalar(@l-1)) {\n        $zero -= $l->[$_][$l->[$_-1]];\n \
    \   }\n    return \"\" if $zero > 0;\n    return \"\" if $zero < 0;\n    my $count\
    \ = 1;\n    for(0..scalar(@l-1)) {\n        $count += 1 if $l->[$_][$l->[$_-1]]\
    \ != $l->[$_][$_];\n    }\n    return $count > 1;\n}", "    return if @$l < 2;\n\
    \    my @set = @$l[0..2];\n    my $i = @$l - 1;\n    while($i > 0) {\n       \
    \ my ($x, $y) = @$set[0..2];\n        if ($x + $y != 0) {\n            $set[0\
    \ .. 1] = [$x + $y];\n            splice @$l, $i, 2;\n            return 1;\n\
    \        }\n        $i--;\n    }\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>",
  "    my $retval = \"\";\n    my $sum = 0;\n    foreach my $pair (@$l) {\n      \
    \  $sum += $pair;\n        if ($sum == 0) {\n            $retval .= \"1\";\n \
    \       }\n        else {\n            $retval .= $sum == -1 ? \"1\" : \"\";\n\
    \        }\n    }\n    return $retval;\n}", "    my @a1 = @{$l->[0]};\n    my\
    \ @a2 = @{$l->[1]};\n    my $zero = 0;\n    my $n = scalar(@a1);\n    foreach\
    \ my $i1 (@a1) {\n        foreach my $i2 (@a2) {\n            my $c = $i1 + $i2;\n\
    \            if ($c != 0) {\n                my $is_zero = 1;\n              \
    \  for my $j (1..$n) {\n                    $is_zero = $is_zero && $a1[$j] ==\
    \ $a2[$j];\n                }\n                if ($is_zero) {\n             \
    \       return 1;\n                }\n            }\n        }\n    }\n    return\
    \ 0;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
