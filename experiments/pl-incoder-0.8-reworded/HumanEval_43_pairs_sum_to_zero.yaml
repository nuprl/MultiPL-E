name: HumanEval_43_pairs_sum_to_zero
language: pl
prompt: "# pairs_sum_to_zero takes an array of integers as an input.\n# it returns\
  \ 1 if there are two distinct elements in the array that\n# sum to zero, and  otherwise.\n\
  # >>> pairs_sum_to_zero([1, 3, 5, 0])\n# \"\"\n# >>> pairs_sum_to_zero([1, 3, -2,\
  \ 1])\n# \"\"\n# >>> pairs_sum_to_zero([1, 2, 3, 7])\n# \"\"\n# >>> pairs_sum_to_zero([2,\
  \ 4, -5, 3, 5, 7])\n# 1\n# >>> pairs_sum_to_zero([1])\n# \"\"\nsub pairs_sum_to_zero\
  \ {\n    my($l) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pairs_sum_to_zero;\n\
  \        if(eq_deeply($candidate->([1, 3, 5, 0]),\"\")) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 3, -2,\
  \ 1]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
  \   if(eq_deeply($candidate->([1, 2, 3, 7]),\"\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 4, -5, 3, 5,\
  \ 7]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1]),\"\
  \")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-3,\
  \ 9, -1, 3, 2, 30]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n     \
  \   }\n        if(eq_deeply($candidate->([-3, 9, -1, 3, 2, 31]),1)) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-3,\
  \ 9, -1, 4, 2, 30]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n  \
  \      }\n        if(eq_deeply($candidate->([-3, 9, -1, 4, 2, 31]),\"\")) {\n  \
  \      print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my $sum = 0;\n    my $zero = 0;\n    my $found;", "    if ( @$l\
    \ <= 1 ) { return '' }\n    return 1 if @$l == 2;\n    my $sum = 0;\n    for my\
    \ $i (0..$#l) {\n        $sum += $l[$i];\n        last if $sum == 0;\n    }\n\
    \    my $zeros = $#l - $#l - 1;\n    return '' unless $sum == 0;\n    my $answer\
    \ = 1;\n    for (my $i = $zeros; $i > 0; $i -= 2) {\n        $answer = 0 if $l[$i]\
    \ + $l[$i - 1] == 0;\n        last;\n    }\n    return $answer;\n}", "    \n \
    \   # iterate over each pair in the list\n    # pair is (first_val, second_val)\n\
    \    # and second_val is the sum we want to see if it is zero\n    my $cnt = 0;\n\
    \    my $pairs;\n    while($pairs = @{$l}) {\n        my $sum = $pairs->[1];\n\
    \        $pairs->[1] += $sum;\n        if ($pairs->[1] == 0) {\n            $cnt++;\n\
    \        }\n        $pairs->[1] = ~$pairs->[1];\n    }\n    if ($cnt == 2) {\n\
    \        return 0;\n    } else {\n        return 1;\n    }\n}", "    my @pairs;\n\
    \    my $sum;\n    my @distinct_elements;\n    my $first_pair = pop(@{$l});\n\
    \    my $last_pair = pop(@{$l});\n    push (@distinct_elements, $first_pair) if\
    \ $first_pair eq $last_pair;\n    push(@pairs, $first_pair);\n    my $pair_found\
    \ = 0;\n    for my $pair (@{$l}) {\n        if ($pair != $last_pair) {\n     \
    \       push (@distinct_elements, $pair);\n            push(@pairs, $pair);\n\
    \        }\n    }\n    my $total_num_pairs = scalar(@pairs);\n    foreach my $pair\
    \ (@pairs) {\n        $sum = $pair->[0] + $pair->[1];\n        if ($sum == 0)\
    \ {\n            $pair_found = 1;\n        }\n    }\n    return unless $pair_found;\n\
    \    return scalar @distinct_elements;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    Hi, thanks for your answer. I understand the code, but I am having trouble understanding\
    \ how to run it. I tried running it on the website http://www.pythontutor.com/visualize.html#mode=edit\
    \ but I get an error message - \"TypeError: 'NoneType' object is not iterable\"\
    \ I guess this is because my data set is so small? Any advice on how to get around\
    \ this?\n<|/ c |>\n<| c |>\nI've edited my answer to add an additional method\
    \ of finding the number of pairs whose sum is zero. This method only works when\
    \ the last number in the list is 0 which makes it ideal for calculating the number\
    \ of pairs whose sum is zero.\n<|/ c |>\n<| c |>\nThank you so much for your help.\
    \ I managed to get it to run on Pythontutor, but it didn't work on my actual data\
    \ set. I am very new to coding, so I really appreciate your help. I edited my\
    \ original post to include my data set - hope that helps. Thanks again!\n<|/ c\
    \ |>\n<| c |>\nHey Chris, I updated the answer to account for lists with repeated\
    \ numbers. Also, I don't see any issue with the way you created your data set.\
    \ If I were to guess from the error you were seeing, it looks like you were using\
    \ an older version of Pythontutor that doesn't support Python 3. You might want\
    \ to try [this](https://repl.it/@katsitandon/PairsWhichSumToZero) or [this](https://repl.it/@katsitandon/PairsWhichSumToZero2)\n\
    <|/ c |>", "    my $z = 0;\n    my $s = \"\";\n    my $n = @$l;\n    for (my $i=0;\
    \ $i<$n; $i++) {\n        $z += $l->[$i];\n        if ($z == 0) {\n          \
    \  $s = $l->[$i];\n            last;\n        }\n    }\n    $s;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=1 |>\nHere is an O(n) implementation\n<code>\n\
    use warnings;\nuse strict;", "    my(@s) = ();\n    my(@t) = ();\n    my(@u) =\
    \ ();\n    my($u);\n    my($uv) = 0;\n    my($iv);\n    \n    foreach $u (@$l)\
    \ {\n        if (!exists $t->{$u}) {\n            $t->{$u} = 1;\n            $s->[$u]\
    \ = 0;\n            push(@s, $u);\n        } else {\n            $t->{$u}++;\n\
    \        }\n    }\n    foreach $u (@$l) {\n        if (exists $t->{$u}) {\n  \
    \          $t->{$u}--;\n            $uv = $t->{$u};\n        } else {\n      \
    \      $uv = undef;\n        }\n        if (!exists $t->{$u}) {\n            $uv\
    \ = undef;\n        }\n        if ($uv != 0) {\n            $iv = $uv;\n     \
    \   } else {\n            $iv = 1;\n        }\n        if (!exists $t->{$u}) {\n\
    \            $iv = 1;\n        }\n        if ($iv != 0) {\n            push(@u,\
    \ $u);\n            $t->{$u} = $iv;\n        }\n    }\n    foreach $u (@u) {\n\
    \        if (!exists $t->{$u}) {\n            $t->{$u} = 1;\n            $s->[$u]\
    \ = 0;\n            push(@s, $u);\n        } else {\n            $t->{$u}++;\n\
    \        }\n    }\n    \n    my $flag = 0;\n    foreach $u (@$l) {\n        if\
    \ (!exists $t->{$u}) {\n            $flag = 0;\n        }\n    }\n    if ($flag\
    \ == 1) {\n        return \"\";\n    } else {\n        return 1;\n    }\n}", " \
    \   my $s = $l->[0] + $l->[1];\n    my $k = $l->[0] + $l->[1] + $l->[2];\n   \
    \ my $l = $l->[0] + $l->[1] + $l->[2] + $l->[3];\n    if ($s == 0 && $k == 0 &&\
    \ $l == 0) {\n        return \"\";\n    }\n    return $l<0 ? \"1\" : ($s == 0\
    \ ? \"\" : \"2\");\n}", "    my $sum = 0;\n    foreach my $num (@$l) {\n     \
    \   $sum = $sum + $num;\n    }\n    return \"\" if $sum != 0;\n    return 1;\n\
    }", "    my $len = @$l;\n    my $sum = 0;\n    for (my $x = 0; $x < $len; $x++)\
    \ {\n        if ($sum) {\n            if ($sum == $l->[$x]) {\n              \
    \  return \"1\";\n            }\n            else {\n                return \"\
    \";\n            }\n        }\n        elsif ($l->[$x] > 0) {\n            $sum\
    \ += $l->[$x];\n        }\n    }\n    return \"\";\n}", '    return 0 unless scalar(@$l);',
  "    for (my $i = $#l; $i >= 0; $i--) {\n        for (my $j = $i; $j >=0; $j--)\
    \ {\n            if ($l[$i]+$l[$j] == 0) {\n                return $l[$i].\" \"\
    .$l[$j];\n            }\n        }\n    }\n    return \"\";\n}", '    return undef
    unless $l && @$l > 2;', "    my $s = 0;\n    my $t = 0;\n    my $c = scalar(@$l);\n\
    \    foreach my $i (@$l) {\n        my $n = $i; # copy into $n so we can increment\
    \ it\n        while($s > 0 && $t > 0) {\n            my ($aa, $bb) = @$l;\n  \
    \          last unless ($aa eq $n && $bb eq $n);\n            $s = $s - $t; $t\
    \ = $t - $aa -$bb;\n        }\n        $l->[$i] = 0;\n    }\n    foreach my $i\
    \ (@$l) {\n        $l->[$i] = $i;\n    }\n    join '', @$l if $s > 0;\n    return\
    \ '';\n}", "    my $n = @$l;\n    my $m = $n - 1;\n    my $k;\n    my $s;\n  \
    \  $s = $m <= 1 ? 0 : &$g($n);\n    $k = &$g($n - 1);\n    my $ret = ($s & $k)\
    \ ne 0 ? 1 : 0;\n    my $last;\n    for (my $i = 0; $i < $m; ++$i) {\n       \
    \ my $tmp = $s[$i];\n        $tmp -= $k[$i];\n        if ($tmp < 0) {\n      \
    \      $tmp += $n;\n        }\n        if ($tmp == 0) {\n            $ret = 0;\n\
    \            $last = $i;\n        }\n        elsif ($tmp < $n / 2) {\n       \
    \     $s[$last] -= $n - $tmp;\n            $k[$last] -= $tmp;\n        } else\
    \ {\n            $s[$last] -= $tmp;\n            $k[$last] += $n - $tmp;\n   \
    \     }\n    }\n    $s;\n    $k;\n}", "    my $result = \"\";\n    my $i = 0;",
  "    my $count = 0;\n    my %seen;\n    my $j;\n    foreach (@$l) {\n        $seen{$_}++;\n\
    \    }\n    $seen{$_}++ for (0 .. $#l)\n      if ($seen{$_} == 2);\n    return\
    \ 1 if ($seen{$_} > 1);\n    return \"\";\n}", "    my $s = \"\";\n    my $n =\
    \ @$l;", '    my(@pairs);', "    return $l if ($l->[2] eq \"0\");\n    return\
    \ '' if ($l->[0] eq $l->[1]);\n    my @a = @$l;\n    my $result = '';\n    my\
    \ $i = $l->[0] - 1;\n    my $j = $l->[1] - 1;\n    my $k = $l->[2] - 1;\n    my\
    \ $min = $a[0]; my $max = $a[$l->[0]];\n    my $m = 0;\n    my @m;\n    for (my\
    \ $index = 1; $index <= $l->[0]; $index++) {\n        $m = $m + $a[ $index ] if\
    \ ($index <= $max);\n        $a[ $index ] = $m;\n    }\n    for (my $index = 1;\
    \ $index <= $l->[1]; $index++) {\n        $m = $m + $a[ $index ] if ($index <=\
    \ $max);\n        $a[ $index ] = $m;\n    }\n    for (my $index = 1; $index <=\
    \ $l->[2]; $index++) {\n        $m = $m + $a[ $index ] if ($index <= $max);\n\
    \        $a[ $index ] = $m;\n    }\n    my $temp;\n    for (my $index = 0; $index\
    \ < $l->[0]; $index++) {\n        for (my $index2 = 0; $index2 < $l->[1]; $index2++)\
    \ {\n            for (my $index3 = 0; $index3 < $l->[2]; $index3++) {\n      \
    \          $temp = $a[$index] + $a[$index2] + $a[$index3];\n                if\
    \ ($temp >= 0) {\n                    $m = $m * $temp;\n                } else\
    \ {\n                    $m = $m * ($temp + $m) / 2;\n                }\n    \
    \            push @m, $m;\n            }\n        }\n    }\n    $result = $m[$l->[0]][$l->[1]][$l->[2]];\n\
    \    return $result;\n}", '    my $found = 0;', "    if (@$l == 1){\n        return\
    \ \"\";\n    }\n    my $n = @$l - 1;\n    my $sum = 0;\n    for (my $i = 0; $i\
    \ < $n; $i++){\n        $sum += $l[$i];\n    }\n    if ($sum == 0){\n        return\
    \ \"\";\n    }\n    for (my $i = 0; $i < $n; $i++){\n        $l[$i] %= $sum;\n\
    \    }\n    if (@$l == 1){\n        return \"\";\n    }\n    my $i = 0;\n    my\
    \ $j = $n - 1;\n    my $k = 0;\n    my $sum = 0;\n    for (;;){\n        if ($i\
    \ > $j){\n            return $i == $j and $k == 0;\n        }\n        if ($l[$i]\
    \ + $l[$j] == $sum){\n            $i++;\n            $j--;\n            $k = 0;\n\
    \        }\n        else{\n            $k++;\n        }\n        if ($k == 0){\n\
    \            if ($i == $j){\n                return \"\";\n            }\n   \
    \         else{\n                return $i == $j and $k == 0;\n            }\n\
    \        }\n    }\n}", "    my $lstr = \"\";\n    foreach my $i (@$l) {\n    \
    \    my $sum = 0;\n        foreach my $j (@$l) {\n            next if $i == $j\
    \ or $j == $i;\n            $sum += $j;\n        }\n        next unless $sum ==\
    \ 0;\n        $lstr = \"$lstr$i,\";\n    }\n    $lstr =~ s/,$//;\n    return $lstr;\n\
    }", "    my $sum = 0;\n    foreach my $item (@$l) {\n        my $item_indeces\
    \ = array_index($l, $item);\n        $sum += $item_indeces;\n    }\n    if ($sum\
    \ == 0) {\n\treturn \"\";\n    }\n    else {\n\treturn 1 if $sum == 0;\n    }\n\
    }", "    my $s = $$l[0] + $$l[1];\n    my $n = scalar @$l;\n    if ($n == 0) {\n\
    \        return \"\";\n    } elsif ($s == 0) {\n        return \"\";\n    } elsif\
    \ ($s == 1) {\n        if ($s > 0) {\n            return $l[0];\n        }\n \
    \   } else {\n        my $i = 1;\n        my $p = 1;\n        my $k = 0;\n   \
    \     my $z = 0;\n        for (my $l = 0; $l < $n; $l++) {\n            while\
    \ (!defined($$l[$k])) {\n                $k++;\n            }\n            my\
    \ $tmp = $$l[$k];\n            if ($tmp > 0) {\n                $p = 1;\n    \
    \            while ($tmp > 0) {\n                    $tmp -= $tmp * $p;\n    \
    \                $p++;\n                }\n                $p /= $k;\n       \
    \         $z = 0;\n                while ($z < $k) {\n                    if ($$l[$z]\
    \ == $tmp) {\n                        $z++;\n                    } else {\n  \
    \                      $z = 0;\n                    }\n                }\n   \
    \             if ($z == $k) {\n                    if ($s == $$l[$z]) {\n    \
    \                    return $l[$z];\n                    }\n                }\n\
    \            }\n        }\n        return 0;\n    }\n    return 0;\n}", "    my\
    \ $n = 0;\n    my $i = 0;\n    while ($i <= @$l - 1) {\n        if ($l->[$i] ne\
    \ $l->[$i + 1]) {\n            $n += 1;\n        }\n        elsif ($n == 0) {\n\
    \            $i -= 1;\n        }\n        else {\n            $i += 1;\n     \
    \   }\n    }\n    if ($n == 0) {\n        return 1;\n    }\n    return '';\n}",
  "    return 1 if @$l == 2;\n    return 0 if @$l == 1;\n    if ($l->[0] > 0) {\n\
    \        my $i = 0;\n        my $sum = 0;\n        for my $i (@$l) {\n       \
    \     $sum += $i;\n        }\n        return 0 if ($sum > 0);\n    }\n    if ($l->[0]\
    \ < 0) {\n        my $i = -1;\n        my $sum = 0;\n        for my $i (@$l) {\n\
    \            $sum += $i;\n        }\n        return 0 if ($sum < 0);\n    }\n\
    \    if ($l->[0] <= 0) {\n        my $i = 0;\n        my $sum = 0;\n        for\
    \ my $i (@$l) {\n            $sum += $i;\n        }\n        return 0 if ($sum\
    \ >= 0);\n    }\n}", "    my(@x) = @$l;\n    my($i, $j);\n    my $sum = 0;\n \
    \   foreach $i (@x) {\n        foreach $j (@x) {\n            my $tmp = $i;\n\
    \            $tmp += $j;\n            last if $tmp == 0;\n        }\n    }\n \
    \   my $res = \"\";\n    return $res if $res == \"\";\n    foreach $i (@x) {\n\
    \        foreach $j (@x) {\n            $j -= $i;\n            next unless $j\
    \ == 0;\n            $res = \"1$res\" if $tmp > $tmp;\n        }\n    }\n    return\
    \ $res;\n}", "    my @pairs = ();\n    my $sum = 0;\n    my $first;\n    my $firstsum;",
  "    my ($sum, $i);\n    $sum = 0; $i = 0;\n    for (my $j = 0; $j < @$l; $j++)\
    \ {\n        if ($l->[$j] > 0 && $sum == 0) {\n            $sum = $l->[$j];\n\
    \            $i = $j;\n        } elsif ($l->[$j] > 0 && $sum != 0) {\n       \
    \     last if $l->[$j] == $sum;\n        }\n    }\n    return $sum == 0 ? \"\"\
    \ : $i;\n}", "    return \"\"  if @$l < 2;\n    my($n1,$n2) = ($l[0],$l[1]);\n\
    \    while ($n2 > 0 and $l[$n1] >= 0) {\n\t$n1 += $n2;\n\t$n2 -= $l[$n1];\n  \
    \  }\n    return 1 if ($n2 == 0);\n    return 0 if ($n1 == @$l and $l[$n1] ==\
    \ 0);\n    return \"@$l\";\n}", "    return if ($l < 1);\n    my($sum, @nums);\n\
    \    foreach my $num (@$l) {\n        push @nums, $num;\n        $sum += $num;\n\
    \    }\n    return if ($sum == 0);\n    foreach my $i (@nums) {\n        my $j\
    \ = $i;\n        my $found = 0;\n        my $last_j = -1;\n        foreach my\
    \ $j (@nums) {\n            if ($j != $i) {\n                last;\n         \
    \   }\n            $last_j = $j;\n            if ($sum == 0 && $j == $i) {\n \
    \               $found = 1;\n            }\n        }\n        if ($found) {\n\
    \            return 1;\n        }\n        elsif ($j != $last_j) {\n         \
    \   return 1;\n        }\n    }\n    return 0;\n}", "    my $s = 0;\n    foreach\
    \ my $i ( 0..$#$l ) {\n        $s += $l->[$i];\n        if ( $i == 0 or $l->[$i]\
    \ != 0 ) {\n            if ( $l->[$i] eq $l->[$i-1] and $l->[$i] eq $s-1 ) {\n\
    \                return '';\n            }\n        }\n    }\n    return $s ?\
    \ 1 : '';\n}", "    my $nums = join(', ', sort {$a <=> $b} @$l);\n    return unless\
    \ $nums;\n    return 1 if m/(\\w+)\\s*,\\s*(\\w+)\\s*\\1(,|$)/ && ($1 + $2) eq\
    \ \"0\";\n    return \"\\n\";\n}", "    my $sum = 0;\n    for (my $i = 0; $i <\
    \ @$l; $i++) {\n        my $v = ${$l}[$i];\n        $sum += $v;\n    }\n    return\
    \ ($sum == 0) ? \"\" : 1;\n}", "    my($r) = @$l[$#l];\n    my $zero = 0;", " \
    \   my($pairs) = @$l;\n    foreach my $pair (@$pairs) {\n\tmy ($one, $two) = @$pair;\n\
    \tif ($one + $two != 0) {\n\t    return 1 if $one + $two > 0;\n\t}\n    }\n  \
    \  return \"\";\n}", "    return $l if !defined $l;\n    my($s);\n    foreach\
    \ my $i (@$l) {\n        if ($s eq \"\") {\n            $s = $i;\n        } else\
    \ {\n            $s = \"${s}+${i}\";\n            if ($s =~ /^\\d+$/) {\n    \
    \            return \"1\";\n            }\n        }\n    }\n    return \"\";\n\
    }\n</code>\n<|/ a tags=list,perl,arrays dscore=0 |>\n<| c |>\nThank you, this\
    \ code works well. But can you please explain what it does line by line? I am\
    \ new to perl and it is very difficult to find out what is happening in the code\
    \ :)\n<|/ c |>\n<| c |>\nI added explanation to the code.\n<|/ c |>\n<| c |>\n\
    thank you again for your code. I am still trying to figure it out but I can do\
    \ it! I still have a question, why do we need to declare $s again in the sub pairs_sum_to_zero?\
    \ Do you mean the sub cannot access $s directly? And does it work if we remove\
    \ $s = $i;?\n<|/ c |>\n<| c |>\n`pair_sum_to_zero` is an internal function and\
    \ `pair_sum_to_zero` is not in `my` scope. You have to declare variable `s` for\
    \ it to be in scope. `pair_sum_to_zero` returns a string so it has to be declared\
    \ as `my $s` in `my` scope of main program. You can remove `my $s` in `pair_sum_to_zero`\
    \ and it would work just fine. I hope it clarifies things a bit :) I recommend\
    \ you to read [perlreftut](http://perldoc.perl.org/perlreftut.html) documentation\
    \ for further understanding of references in Perl.\n<|/ c |>\n<| c |>\nOh I see.\
    \ I didn't notice that pair_sum_to_zero is outside of my(). Thank you so much\
    \ for the explanation.\n<|/ c |>\n<| a dscore=0 |>\nIf you're in perl 5.8 or later,\
    \ you can use the smart match operator:\n<code>\nuse strict;\nuse warnings;",
  "    my $num_pairs = @$l;\n    my $pairs = $num_pairs ** 2;\n    my $zero = 0;\n\
    \    my $sum = 0;", "    my($sum) = 0;\n    foreach my $el (@$l) {\n        if\
    \ ($el < 0) {\n            next if $el > -$sum;\n        }\n        $sum += $el;\n\
    \    }\n    return $sum == 0;\n}\n</code>\n<|/ a |>\n<| c |>\nThis does not address\
    \ the question of how to compute the product of the two numbers that are equal,\
    \ which is what the OP asked.\n<|/ c |>\n<| c |>\n, thanks for pointing that out.\
    \ I've edited my answer to address that.\n<|/ c |>\n<| c |>\nThanks for the code,\
    \ I have tested it and it is working perfectly fine. However I got another question\
    \ here (http://stackoverflow.com/questions/36265076/how-can-we-check-whether-two-numbers-are-equal)\
    \ which was related to this one and I am curious to know why this code is working\
    \ in that case\n<|/ c |>\n<| c |>\n, I've updated my answer to address your new\
    \ question.\n<|/ c |>\n<| c |>\nThanks, I understood now\n<|/ c |>\n<| a dscore=0\
    \ |>\nThe other answers missed the case of numbers with one digit.\n<code>", " \
    \   my $answer = join \"\\n\", map $_->[0],\n        grep $_->[1] > 0,\n     \
    \   map [$_, $l->[$_]] , 0 .. $#l;", "    my $num  = 0;\n    my $sum  = 0;", " \
    \   return unless @$l;\n    my $n = @$l;\n    my @pairs;\n    for (my $i = 0;\
    \ $i < $n; $i += 2) {\n        my $a = $l->[$i];\n        my $b = $l->[$i+1];\n\
    \        my $sum = $a + $b;\n        my $pair = ($a, $b, $sum);\n        push\
    \ @pairs, $pair if $sum == 0;\n    }\n    my $count = 0;\n    for my $pair (@pairs)\
    \ {\n        ++$count if $pair->[2] != 0;\n    }\n    return $count ? $count :\
    \ 0;\n}", "    my $sum = 0;\n    for my $i (0..$#l) {\n        if ($l[$i] > 0)\
    \ {\n            $sum += $l[$i];\n        }\n    }\n    if ($sum == 0) {\n   \
    \     return \"\";\n    }\n    return 1;\n}", "    my $n = @$l;\n    my $count\
    \ = 0;\n    for(my $i=0; $i<$n-1; $i++) {\n        if ($l[$i]+$l[$i+1] != 0) {\n\
    \            $count = 0;\n            last;\n        }\n        $count++;\n  \
    \  }\n    return $count ? 1 : 0;\n}", "    my $sum = 0;\n    for(my $i = 0; $i\
    \ < @$l; $i++) {\n        if($l->[$i] > 0 && $l->[$i] + $sum == 0) {\n       \
    \     $sum = 0;\n        } elsif ($l->[$i] + $sum != 0) {\n            $sum =\
    \ $l->[$i];\n        }\n    }\n    if($sum == 0) {\n        return \"\";\n   \
    \ }\n    return 1;\n}", "    my $ret = $l eq $l->[0] ? 0 : ($l eq $l->[-1] ? 1\
    \ : \"\");\n    undef $l; # not needed anymore\n    return $ret;\n}", "    my\
    \ @array;\n    my $index = 0;\n    my $sum = 0;", '    my($ans, $sum, $cnt) =
    (0, 0);', '    my(@s) = ();', "    $l =~ m|\n      ^\n      ([1-9][0-9]*) # a\
    \ number with at least two digits\n      ([1-9][0-9]*) # and a pair of numbers\
    \ with at least two digits\n      0                # and a zero at the end\n \
    \     ([1-9][0-9]*)$\n    |x;\n    return $1 if $1;\n}", "    my $sum = 0;\n \
    \   for ($l->[$_]) for (0 .. $#l) {\n        my $next = $l->[$_];\n        $sum\
    \ += $next;\n        if ( $sum == 0 ) {\n            return \"\";\n        }\n\
    \    }\n    return $sum == 0 ? '' : $sum;\n}", "    my %seen;\n    my $sum;",
  "    for (my $i = $#l; $i > 1; $i--) {\n        for (my $j = 0; $j < $i; $j++) {\n\
    \            if ($l[$i] - $l[$j] == 0) {\n                return \"\";\n     \
    \       }\n        }\n    }\n    return \"\";\n}\n</cell>\n<text>\nFor each pair\
    \ of elements $i$ and $j$ in the array that sum to zero, print the indices of\
    \ the elements in the input array that sum to zero. For example, given the list\
    \ [0, 4, -2, 3], print \u201C0 1\u201D.", "    my $s = shift(@_);\n    my $n =\
    \ scalar(@$l);\n    my $i = 0;\n    while ($i < $n) {\n        my $j = ++$i;\n\
    \        while (defined($l[$j])) {\n            my $t = $l[$i] + $l[$j];\n   \
    \         if ($t < 0) {\n                $l[$j] = $l[$j] + $s * $t;\n        \
    \        if ($l[$j] < 0) {\n                    $l[$j] = $l[$j] + $s * -$t;\n\
    \                }\n            }\n            else {\n                last;\n\
    \            }\n        }\n    }\n    my $ret = \"\";\n    my $j = 0;\n    while\
    \ (defined($l[$j])) {\n        $ret .= $l[$j];\n        ++$j;\n    }\n    $ret;\n\
    }", "    my $pairs_sum_to_zero = 0;\n    my @pairs;", "    my $sum = 0;\n    foreach\
    \ my $i ( 0 .. $#$l ) {\n        if( $l->[$i] eq $l->[$i] ) {\n            $sum\
    \ += $l->[$i];\n        }\n    }\n    return ( $sum == 0 );\n}", "    for (my\
    \ $n = 0; $n < @$l; $n++) {\n        my $s = $l->[$n];\n        for (my $i = $n\
    \ + 1; $i < @$l; $i++) {\n            $s += $l->[$i];\n            if ($s == 0)\
    \ {\n                return 1;\n            }\n        }\n    }\n}", "    my(@v);\n\
    \    \n    foreach $l (@$l) {\n        push(@v, $l) if !$v[$l];\n    }\n    \n\
    \    foreach my $i (0 .. $#v) {\n        return \"\" if $v[$i] == 0;\n    }\n\
    \    return 1;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI don't get this line:\
    \ `return \"\" if $v[$i] == 0;` ... what does it do? What does it return?\n<|/\
    \ c |>\n<| c |>\nIt returns, if the value in `$v[$i]` is zero.\n<|/ c |>\n<| c\
    \ |>\nOh, I see now... so what does it return when `$v[$i]` is `0` though?\n<|/\
    \ c |>\n<| c |>\nIt returns `\"\"`, if the value in `$v[$i]` is zero (no other\
    \ value can be zero in an array with negative indexes).\n<|/ c |>\n<| c |>\nOh,\
    \ so I guess my issue was that I was expecting there to be two `0` values in the\
    \ array... I just wanted to make sure I wasn't overlooking an easier solution.\
    \ Oh well, thanks again.\n<|/ c |>\n<| a dscore=0 |>\nA different way of doing\
    \ it using perl's Hash Data Structure \n<code>\nuse strict;\nuse warnings;", '    my($max);',
  "    my(@pairs) = (@{$_[0]}, @{$_[1]});\n    my $result = 0;\n    my @unique_pairs\
    \ = ();", "    my(@l) = map { $_ } @$l;\n    return undef if (@l < 2);", "   \
    \ my $zero = 0;\n    my $s = \"\";\n    for my $i (0..$#$l) {\n        my $v =\
    \ $l->[$i];\n        if ($v > $zero) {\n            $s = \" \" . $v;\n       \
    \     $zero = 0;\n        } elsif ($v == $zero) {\n            $zero++;\n    \
    \    }\n    }\n    $s;\n}", "    my $len = length($l);\n    my $count = 0;\n \
    \   for (my $i = 0; $i < $len; $i++) {\n        if ($l[$i] > 0 && $l[$i] + $l[$i+1]\
    \ == 0) {\n            $count++;\n        }\n    }\n    if ($count == 0) {\n \
    \       return \"\";\n    }\n    else {\n        return $count == 1 ? \"pair\"\
    \ : \"pairs\";\n    }\n}", "    my(@result) = ( '', '' );\n    foreach my $i (0\
    \ .. $#$l) {\n        my $a = $l->[$i];\n        my $b = $l->[$i-1];\n       \
    \ my $c = $l->[$i-2];\n        my $d = $l->[$i-$#l];\n        my $s = 0;\n   \
    \     if ($a != 0) { $s += $a; }\n        if ($b != 0) { $s += $b; }\n       \
    \ if ($c != 0) { $s += $c; }\n        if ($d != 0) { $s += $d; }\n        if ($s\
    \ == 0) {\n            push(@result, \"$i $a $b\");\n        } else {\n      \
    \      push(@result, \"$i $s $b\");\n        }\n    }\n    return scalar(@result);\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| c |>\nI suggest that `pairs_sum_to_zero()` be\
    \ changed to return `'1'` instead of `'0'`, since it would be more intuitive for\
    \ the user if `pairs_sum_to_zero()`'s return value meant \"there are two distinct\
    \ elements in the list whose sum is zero\".\n<|/ c |>\n<| c |>\n: I don't think\
    \ that's necessarily true.  If the original list contained `0`, then `pairs_sum_to_zero()`\
    \ could return `1`, but it could also return `0`, or could return `1` and `0`,\
    \ or something else.  I might consider adding a `return $result ? '1' : '0'` to\
    \ the end of the `pairs_sum_to_zero` subroutine.\n<|/ c |>\n<| c |>\nI agree that\
    \ `pairs_sum_to_zero()` would make more sense if it returned `'1'` instead of\
    \ `'0'`.  But I think the point is that `pairs_sum_to_zero()` should return `'1'`\
    \ if there are two distinct elements in the list whose sum is zero.  That way,\
    \ users can decide if they want to count the pairs with zero sum, or not, or just\
    \ count the pairs with two distinct elements with zero sum.\n<|/ c |>\n<| a tags=perl,list\
    \ dscore=4 |>\nThe first thing you need to do here is determine what your algorithm\
    \ needs to do.  I see two possibilities as to what it needs to do.  One is to\
    \ find all the permutations of the input list and find the sum of the permutations.\
    \  There are algorithms to do this.  For example, the Perl module Algorithm::Permutations\
    \ can find all permutations of a list.  The second is to find all the combinations\
    \ with the target sum, which is what you are looking for.  These algorithms are\
    \ described in the Perl module Algorithm::Combinatoric", "    my $s = 0;\n   \
    \ my($i, $j);\n    for($i = 0; $i < scalar(@$l); $i++) {\n        $j = $i + 1;\n\
    \        while($j < scalar(@$l)) {\n            $s += $l->[$i] + $l->[$j];\n \
    \           $j++;\n        }\n    }\n    return $s == 0;\n}", '    my %seen;',
  "    my $answer;\n    foreach my $num (@$l) {\n        if ($num > 0) {\n       \
    \     $answer = \"1\";\n            my $num2 = 1;\n            while (!($num2\
    \ > 0) || $num2 == $num) {\n                my $diff = $num - $num2;\n       \
    \         if ($diff < 0) {\n                    $num2--;\n                } else\
    \ {\n                    $num2 += $diff;\n                    $answer = \"$answer1\"\
    ;\n                }\n            }\n            $answer = \"$answer2\";\n   \
    \     }\n    }\n    return $answer;\n}", "    my($r) = @$l;\n    if ($l == 0)\
    \ {\n        return \"0\";\n    } elsif ($r == 0) {\n        return \"0\";\n \
    \   }\n    while (@$r > 0) {\n        my($a) = shift @$r;\n        if ($a == 0)\
    \ {\n            return 0;\n        }\n        if ($l[$a] > $l[$a-1]) {\n    \
    \        shift @$r;\n            $l[$a-1] = 0;\n        } elsif ($r[$a] > $r[$a-1])\
    \ {\n            shift @$l;\n            $r[$a-1] = 0;\n        } else {\n   \
    \         $l[$a-1] += 1;\n        }\n    }\n    return 1;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThe question asked to return \"0\" if any pair of elements sum\
    \ to zero, not just the pairs where the sum is zero.\n<|/ c |>\n<| a dscore=1\
    \ |>\nThis solution is in perl and gives the right result for me. I think it's\
    \ a lot more concise than other answers. I hope it helps someone.\n<code>", " \
    \   my(@m);\n    my $result = 0;", "    if (@$l == 1) {\n        return ''\n \
    \   }\n    my(@ret);\n    my($left,$right);\n    for my $num (@$l) {\n       \
    \ if ($num < 0) {\n            return ''\n        }\n        elsif ($num == 0)\
    \ {\n            return $left = '', $right = '', $num\n        }\n        elsif\
    \ ($num == 1) {\n            return $left = '', $right = 0, $num\n        }\n\
    \        $left = $right;\n        $right = $num - $left + $left;\n    }\n    return\
    \ $left eq '' ? '' : ($left . '0' . $right), $right eq '' ? '' : ($left . '1'\
    \ . $right)\n}", "    my %seen;\n    my $sum = 0;\n    foreach my $i (@$l) {\n\
    \        if (exists $seen{$i}) {\n            return 0;\n        }\n        else\
    \ {\n            $seen{$i} = 1;\n            $sum += $i;\n        }\n    }\n \
    \   return $sum > 0;\n}", "    my $str = \" \";\n    my $count = 0;\n    for my\
    \ $i (0..$#$l) {\n        my $j = $i;\n        while($j > 0) {\n            next\
    \ unless($l[$i] eq $l[$j]);\n            $str .= $l[$i];\n            $l[$i] =\
    \ undef;\n            $j--;\n        }\n    }\n    $str =~ s/^\\s//;\n    $str\
    \ =~ s/\\s$//;\n    return $str =~ /^1/;\n}", "    my $zero = 0;\n    my(@a) =\
    \ $l->[0], @$l;\n    my $s = $a[0];\n    my %seen = ();", "    my($sum) = 0;\n\
    \    my(@arr);", '    my($sum) = 0;', "    my $rev = reverse $l;\n    my($i, $j,\
    \ $res);\n    my %seen = ();", "    my($sum);\n    my(@pairs);", "    my $max;\n\
    \    my $maxi = 0;\n    my $sum = 0;\n    for (my $i = 0; $i < @$l; $i++) {\n\
    \        for (my $j = 0; $j < @$l; $j++) {\n            if ($i > $j) {\n     \
    \           my $tmp = $l->[$i];\n                $l->[$i] = $l->[$j];\n      \
    \          $l->[$j] = $tmp;\n            }\n        }\n        if ($l->[$i] ==\
    \ 0) {\n            $sum += 0;\n        }\n        else {\n            $sum +=\
    \ $l->[$i];\n        }\n        if ($sum == 0) {\n            my $tmp = $i;\n\
    \            $i = $j;\n            $j = $tmp;\n        }\n    }\n    if ($max\
    \ == 0) {\n        $max = $sum;\n    }\n    else {\n        $max = $sum > $max\
    \ ? $sum : $max;\n    }\n    if ($sum == $max) {\n        return \"1\";\n    }\n\
    \    return \"0\";\n}", '    my($r) = ();', "    my $sum = 0;\n    my $found =\
    \ 0;\n    my(@count, $last);\n    my $tmp;", "    my $l = scalar @$l;\n    my\
    \ %seen;\n    for (my $i = 0; $i < $l; $i++) {\n        $seen{$_+$i}++ for @$l;\n\
    \    }\n    my $max = 0;\n    while (my ($key, $value) = each %seen) {\n     \
    \   if ($value > $max) {\n            $max = $value;\n            $maxkey = $key;\n\
    \        }\n    }\n    $max\n}", "    my $s = 0;\n    my $k;\n    for (my $i =\
    \ 0; $i < @$l; $i++) {\n        $s += $l->[$i];\n        $k = $s if $l->[$i] ==\
    \ 0;\n    }\n    return $k if $s;\n    return '';\n}", "    my $zero = 0;\n  \
    \  my $result = '';\n    foreach my $pair (@$l) {\n        my $a = $pair->[0];\n\
    \        my $b = $pair->[1];\n        if ($a + $b == $zero) {\n            $result\
    \ = \"$a $b\";\n            last;\n        }\n    }\n    return $result;\n}",
  "    my $ret = 0;\n    my %seen = ();\n    foreach (@$l) {\n        next unless\
    \ $_;\n        my $v = $_;\n        my $key = sprintf(\"%d\",$v);\n        if\
    \ ($seen{$key}) {\n            $ret = 1;\n        } else {\n            $seen{$key}\
    \ = 1;\n        }\n    }\n    return $ret;\n}", "    my $s = 0;\n    while(@$l)\
    \ {\n        my $x = shift(@$l);\n        $s++ if $x != 0 && $x != $s[$s-1] ?\
    \ 1 : 0;\n    }\n    return $s;\n}", "    my $s = \"\";\n    my $c = 0;\n    foreach\
    \ my $i (@$l) {\n        if ($i == 0) {\n            $s .= \"0\";\n          \
    \  $c += 1;\n        }\n        elsif ($i == 1) {\n            $s .= \"1\";\n\
    \        }\n        else {\n            $s .= \"$i\";\n            $c += $i;\n\
    \        }\n        if ($c != 0) {\n            my $z = \" z\";\n            if\
    \ ($s == \" z\") {\n                $s .= $z;\n            }\n            else\
    \ {\n                $s .= \" $z\";\n            }\n            $c -= $i;\n  \
    \      }\n    }\n    return $s;\n}", "    my $zero = 0;\n    $zero += $l->[-1];\n\
    \    for my $i (0 .. $#$l) {\n        my $s = $l->[$i];\n        if ($s == $zero)\
    \ {\n            return $s;\n        }\n    }\n    return '';\n}", "    my(@sum)\
    \ = @_;\n    my(@pairs);\n    my($ret);", "    return if (@$l == 0);\n    my($result)\
    \ = \"\";\n    my ($i,$j) = @_;\n    for (my $index = 0; $index < @$l; $index++)\
    \ {\n        $i = $l->[$index];\n        $j = $l->[$index + 1];\n        $result\
    \ = $result . ($i == $j);\n    }\n    return $result;\n}", "    my($sum, $i, $j,\
    \ @ans);\n    \n    # find unique elements that are positive and sum to zero\n\
    \    $i = 0;\n    foreach $pair (@$l) {\n        $sum += $pair->[0];\n       \
    \ $j++;\n        \n        # only take elements that are positive and sum to zero\n\
    \        next unless $pair->[0] > 0 and $sum == 0;\n        \n        # append\
    \ the first and second elements to the array and\n        # increment the counter\n\
    \        push(@ans, [$pair->[1], $pair->[0]]);\n        $i++;\n    }\n    \n \
    \   # return 1 if the array contains two elements that sum to zero\n    return\
    \ 1 if ($i == 2) || ($i == 0);\n    \n    # otherwise return the empty string\n\
    \    return \"\";\n}", "    my $s = $l[0];\n    if ( $s > 0 ) {\n        my $a\
    \ = $l[1];\n        my $b = $l[2];\n        my $tmp = ($a+$b+$s);\n        $tmp\
    \ >0  ? \"\" : 1;\n    }\n    else {\n        $l[0] >0  ? \"\" : 1;\n    }\n}",
  "    $l->[0] =\n      grep { $l->[$_] <= 0 } 0 .. @$l->[0];\n    my $sum = 0;\n\
    \    foreach my $i ( 0..$#l ) {\n        $sum += $l->[$i];\n    }\n    return\
    \ $sum == 0;\n}", "    my(@pairs) = ();\n    my($sum);\n    foreach my $num (@$l)\
    \ {\n        $sum = 0;\n        for my $i (0..$#$l) {\n            $sum += $l->[$i];\n\
    \        }\n        if ($sum == 0) {\n            push @pairs, $num;\n       \
    \ }\n    }\n    return 1 == scalar (@pairs);\n}", "    my @nums = @_;\n    my\
    \ $i = 0;\n    my $j = 0;\n    my $sum = 0;\n    my $len = $#nums;\n    my $count\
    \ = 0;\n    my $first = 1;\n    for(my $k = 0; $k < $len; $k++) {\n        for(my\
    \ $l = $k + 1; $l < $len; $l++) {\n            $sum = $nums[$k] + $nums[$l];\n\
    \            $count = $sum < 0 ? 1 : $sum;\n            if($first) {\n       \
    \         $first = 0;\n                if($count == 0) {\n                   \
    \ return \"\";\n                }\n            } else {\n                if($count\
    \ != 0) {\n                    return 1;\n                }\n            }\n \
    \       }\n    }\n    return 0;\n}", "    my($sum, $twos_found) = 0;\n    my $zero_found\
    \ = 0;\n    for my $i (0 .. $#$l) {\n        my $x = $l[$i];\n        my $y =\
    \ $l[$i - 1];\n        # print \"x:$x y:$y\\n\";\n        if ($x == $y) { $sum\
    \ += $x; $zero_found = 0; }\n        if ($x == 0) { $zero_found = 1; $sum = 1;\
    \ }\n        if ($sum != 0) { $twos_found = 1; }\n        elsif ($twos_found ==\
    \ 1) { $l[$i - 1] = $l[$i]; $l[$i] = $sum; $sum = 0; $twos_found = 0; }\n    }\n\
    \    if ($sum != 0) { undef; }\n    return $sum;\n}", "    $l =~ s/^.*(\\d)(?=\\\
    1$)/$1/;\n    my $flag = 0;\n    for (@$l) {\n        $flag = 0 if $_ eq $l;\n\
    \    }\n    return $flag;\n}\n</code>\n<|/ a |>\n<| c |>\nThe `if` statement checks\
    \ for consecutive duplicates, not consecutive identical elements. The `while`\
    \ statement checks for identical elements in the array. I believe OP meant consecutive\
    \ identical elements. But I could be wrong.\n<|/ c |>\n<| c |>\nThat code was\
    \ a little bit confusing. My original version worked for the test cases that I\
    \ wrote above, however I fixed that up with a small tweak which I didn't intend\
    \ on doing. My version didn't work for all cases when I originally wrote it. The\
    \ tweak is in the line `$flag = 0 if $_ eq $l;`. I fixed that up here to `$flag\
    \ = 0 if $_ eq $l;`. I will correct that in the answer. Thanks.\n<|/ c |>\n<|\
    \ c |>\nThat's not my intent. I intended for OP to realize my mistake, rather\
    \ than just give the corrected code back to her. I've been trying to help people\
    \ with their questions lately, and I appreciate all contributions, even if they\
    \ are only a little.\n<|/ c |>\n<| c |>\nThanks for the contribution. I know I\
    \ shouldn't take credit for those kinds of things, but I appreciate you going\
    \ through the effort.\n<|/ c |>\n<| c |>\nYou're welcome. By the way, I added\
    \ a second alternative solution. You may want to test them both before deciding\
    \ which one is best.\n<|/ c |>\n<| a dscore=3 tags=perl,arrays,hash,algorithm\
    \ |>\nJust for fun, here's a solution that uses sort:\n<code>\nmy = qw(1 2 3 4\
    \ 5 6 6 7 8);", '    my $retval;', "    my(@pairs);\n    push(@pairs, $l) while\
    \ @$l > 2;\n    my $max;\n    foreach my $i (@pairs) {\n        my $min = $i;\n\
    \        while (++$i < @$l) {\n            $min = $i if ($l[$i] < $l[$min]);\n\
    \        }\n        $max = $min if ($max < $min);\n    }\n    return \"\" unless\
    \ $max;\n    return $l[$max] == 0 ? () : $max;\n}", "    my(@l) = split(//,$l);\n\
    \    my($csum) = 0;\n    my($maxsum) = 0;\n    foreach my $i (@l) {\n        $csum\
    \ = $csum + $i;\n        if ($csum > $maxsum) {\n            $maxsum = $csum;\n\
    \        }\n    }\n    if ($maxsum == 0) {\n        return \"1\";\n    } else\
    \ {\n        return \"\";\n    }\n}", '    $l =~ m{(\d+)} if @$l > 2;', "    my($zeros_found);\n\
    \    my($max);\n    my($result);", "    if (@$l == 0) {\n        return \"\"\n\
    \    }\n    if (@$l == 1) {\n        return @$l[0] eq '0' ? 1 : ''\n    }\n  \
    \  my ($sum_val, $sum, $index) = (0, 0, 0);", "    my(@v);\n    my($result);",
  "    my($sum,$i,$j,@pairs);\n    foreach $i (@$l) {\n        foreach $j (@$l) {\n\
    \            if ($i == $j) { $pairs[$i][$j] = $pairs[$j][$i] = \"\"; }\n     \
    \       else {\n                $pairs[$i][$j] = \"pairs\";\n                $pairs[$j][$i]\
    \ = \"pairs\";\n            }\n        }\n    }\n    foreach $i (@pairs) {\n \
    \       foreach $j (@$i) {\n            $sum = $sum + $j;\n        }\n    }\n\
    \    if ($sum == 0) { $pairs[$_][$_] = \"\"; }\n    $pairs[$_][$_] = \"1\" for\
    \ keys %$pairs;\n    @pairs  = grep {$_} @pairs;\n    foreach (@pairs) {\n   \
    \     if ($pairs[$_][$_]) {\n            my $temp = $pairs[$_][$_];\n        \
    \    $pairs[$_][$_] = \"\";\n            $pairs[$temp][$_] = \"1\";\n        }\n\
    \    }\n    \n    my $s = \"\";\n    foreach $i (@pairs) {\n        $s = $s .\
    \ \"(\" . join(\" \",@$i) if $s;\n    }\n    if ($s) { $s = \"($s)\"; }\n    return\
    \ $s;\n}", "    my @ret;\n    for my $i (0..$#$l) {\n        for (my $j = $i+1..$#$l)\
    \ {\n            my $sum = $l->[$i] + $l->[$j];\n            if ($sum == 0 &&\
    \ @$l > 1) {\n                push @ret, $i . \"_\" . $j;\n            }\n   \
    \     }\n    }\n    return @ret if $ret;\n    return \"\";\n}", "    return 1\
    \ if $l->[0] >= $l->[1] || $l->[1] >= $l->[0];\n    return \"\";\n}", "    my($sum,\
    \ @pairs);\n    for my $i (0 .. $#$l)\n    {\n        if ($i > 0) {\n        \
    \    next unless $l[$i] >= 0;\n            ++$sum;\n        }\n        ++$pairs[$i]\
    \ if $l[$i] >= 0;\n    }\n    return '' unless $pairs[scalar(@pairs) - 1] == 0;\n\
    \    return '1' if scalar(@pairs) == 1;\n    return '0';\n}", "    if ($l == 0)\
    \ {\n        return '';\n    }\n    my $max = $$l;\n    my $min = -$$l;\n    while\
    \ ($min != 0) {\n        my $zeros = 0;\n        my $x = $max;\n        while\
    \ ($x != 0) {\n            $x = $x - $l; # set $x to the last digit in $l\n  \
    \          if ($x == 0) {\n                $zeros++;\n            }\n        }\n\
    \        if ($zeros == 2) {\n            # $min and $max are the same number\n\
    \            return 1;\n        }\n        $max = $$l;\n    }\n    return 0;\n\
    }", "    my $pairs = join \"\\n\", map { map { sprintf('(%d %d)', $a,$b) } @$l\
    \ };\n    my $zeros = join '', map { sprintf '%d', 0 } @$l;\n    return $pairs\
    \ =~ /^($zeros)/;\n}", "    my $s = $l->[0] + $l->[1];\n    return 0 if $s ==\
    \ 0;\n    return 1 if $l->[0] + $l->[1] == $s;\n    return \"\";\n}", "    return\
    \ $l if $l =~ /^$/;\n    my(@m);\n    for (my $i=0;$i<scalar(@$l);$i++) {\n  \
    \      for (my $j=$i+1;$j<scalar(@$l);$j++) {\n            push(@m,$j) if $l[$i]+$l[$j]\
    \ == 0;\n        }\n    }\n    return scalar(@m)?\"1\":\"0\";\n}", '    my($total);',
  "    my %sums;\n    $sums{$_} = 1 foreach @$l;\n    return unless keys %sums ==\
    \ 1;\n    my ($a, $b) = sort {$a <=> $b} keys %sums;\n    return $a <=> $b ==\
    \ 0;\n}", "    my $sum_of_pairs = $l->[0];\n    $sum_of_pairs += $l->[1];\n  \
    \  my $total = 0;\n    my $i = 2;\n    while ($i < @$l) {\n        $total += $l->[$i];\n\
    \        $i += 2;\n    }\n    return 1 if $total != 0 && $total != $sum_of_pairs;\n\
    \    return;\n}", "    my $s = $l[0];\n    for (my $i = 1; $i < @$l; ++$i) {\n\
    \        $s = $s + $l[$i];\n        if ($s == 0) {\n            return 0;\n  \
    \      }\n    }\n    return 1;\n}", "    for (my $i = 0; $i < @$l; $i += 2) {\n\
    \        my $xi = $l->[$i];\n        my $yi = $l->[$i + 1];\n        return 1\
    \ if $xi == 0 && $yi == 0;\n        return 0 if $xi == $yi || $xi == 0;\n    \
    \    my $x = $xi + ($xi < $yi ? $yi : $xi);\n        my $y = $yi + ($yi < $xi\
    \ ? $xi : $yi);\n        return 1 if $x == 0 && $y == 0;\n        return 0 if\
    \ $x == $y || $x == 0;\n        my $z = $x + ($x < $y ? $y : $x);\n        return\
    \ 1 if $z == 0 && $x == 0;\n        return 0 if $z == $x || $z == 0;\n       \
    \ return 1 if $x != $z;\n    }\n    return 1;\n}", "    my @pairs = map {; next\
    \ unless $_; }; # filter out pairs with zero\n    return '' unless @pairs;\n \
    \   my $sum = $l->[0] + @pairs;\n    my $count = 0;\n    $pairs[-1] = ($sum ==\
    \ 0 ? 1 : 0);\n    for (my $i = 1; $i < @pairs-1; $i++) {\n        $sum += $l->[$i];\n\
    \        $count++ if ($l->[$i] + $l->[$i+1] == 0);\n    }\n    return $count;\n\
    }", "    return \"\" if (@$l < 2);\n    return \"\" if (@$l == 2);", "    my %seen;\n\
    \    my($sum) = 0;\n    foreach my $i (@$l) {\n        if ($seen{$i}) {\n    \
    \        if ($seen{$i} > 1) {\n                return \"\";\n            }\n \
    \       }\n        else {\n            $seen{$i} = 1;\n            $sum += $i;\n\
    \        }\n    }\n    return 1 if $sum == 0;\n    return \"\";\n}", "    my %p\
    \ = ();\n    my $total = 0;\n    for my $i (@$l) {\n        $p{$i} = $total if\
    \ defined $p{$i};\n        $total += $i;\n    }\n    \n    if (keys %p > 1) {\n\
    \        return \"\";\n    } else {\n        return scalar keys %p ? \"1\" : \"\
    \";\n    }\n}", "    my $s = $l->[0] + $l->[1];\n    return if ($s == 0);\n  \
    \  my $e = $s->{n};\n    for (my $k = 0; $k < $e; $k++) {\n        $s->{l}[$k]\
    \ = $s->{l}[$k] + $s->{r}[$k];\n    }\n    $s->{n}--;\n    $s->{l}[0] = $s->{l}[0]\
    \ - $s->{r}[0];\n    $s->{r}[0] = 0;\n    $s->{l}[1] = $s->{l}[1] - $s->{r}[1];\n\
    \    $s->{r}[1] = 0;\n    return unless ($s->{n} != -1);\n    my $sum = 0;\n \
    \   for (my $k = 0; $k < $s->{n}; $k++) {\n        $sum = $sum + $s->{l}[$k]->{v};\n\
    \    }\n    return $sum;\n}", '    my(@s);', "    my(@result) = ();\n    my $i\
    \ = 0;\n    foreach my $a (@$l) {\n        my $s = $a;\n        $s += 0;\n   \
    \     my $c = $i + 1;\n        my $f = 0;\n        while ($c < @$l) {\n      \
    \      last if $a <= $l->[$c];\n            last if $l->[$c] < $a;\n         \
    \   $f += 1;\n            $c += 1;\n        }\n        if ($f == 1) {\n      \
    \      if ($s == 0) {\n                $result[$i] = '';\n            } else {\n\
    \                $result[$i] = $s;\n            }\n            $i += 1;\n    \
    \    }\n    }\n    if ($i == 0) {\n        return '';\n    }\n    my $result =\
    \ \"\";\n    foreach my $i (0 .. $#$result) {\n        $result .= $result[$i];\n\
    \    }\n    $result;\n}", "    my @a;\n    my $s = 0;\n    for(my $i=0; $i<@$l;\
    \ $i++) {\n        push (@a, $l->[$i]);\n        $s += $l->[$i];\n    }\n    for(my\
    \ $i=0; $i<@a; $i++) {\n        if ($a[$i] eq $a[-1]) { $s++; }\n    }\n    chomp($s);\n\
    \    return $s eq \"0\" ? \"\" : 1;\n}", "    my(@result) = ();\n    my($max)\
    \ = -1;\n    my($i, $j, $k);", "    return unless @$l;\n    return unless $l->[0]\
    \ > 1;\n    return unless $l->[0] >= 0;", "    my $max = 0;\n    my $result =\
    \ \"\";\n    \n    foreach my $pair (@{$l}) {\n        my $i = $pair->[0];\n \
    \       my $j = $pair->[1];\n        \n        if ($i <= $j) {\n            $result\
    \ = $result;\n        } elsif ($max < $i) {\n            $result = $result;\n\
    \        }\n        \n        $max = $i;\n    }\n    \n    return $result;\n}",
  '    my(@pairs);', "    my @s = ();\n    for(my $i=0; $i < @$l; $i++) {\n      \
    \  $s[$i] = $l->[$i];\n    }\n    for(my $i=0; $i < @$s; $i++) {\n        for(my\
    \ $j=$i; $j < @$s; $j++) {\n            if ($s[$i] + $s[$j] == 0) {\n        \
    \        push(@s, 0);\n            }\n        }\n    }\n    if (@s == 0) {\n \
    \       return \"\";\n    }\n    for(my $i=0; $i < @$s; $i++) {\n        if ($s[$i]\
    \ == 0) {\n            return \"1\";\n        }\n    }\n    return \"\";\n}",
  "    my %h = ();\n    foreach my $item (@$l) {\n        $h{length($item) > 1 ? $item\
    \ : $h{length($item)}}++;\n    }\n    my $result = 0;\n    foreach my $length\
    \ (keys %h) {\n        if ($h{$length} > 1) {\n            $result++;\n      \
    \  }\n    }\n    return $result;\n}", "    my $max = max (@$l);\n    my $sum =\
    \ 0;\n    foreach my $i (@$l) {\n        next if $i < 0;\n        $sum = $sum\
    \ + $i;\n        next if $sum == $max;\n        if ($sum == $max) {\n        \
    \    return 1;\n        }\n    }\n    return 0;\n}", '    my(@s) = ();', "   \
    \ # your code here\n    my $s = 0;\n    my $count = 0;\n    foreach my $i (@$l)\
    \ {\n        my $j = 0;\n        my $test = 0;\n        for my $i1 (@$l) {\n \
    \           $test += $i;\n            next unless $i1 == $i; # only test adjacent\
    \ pairs\n            my $val = $l[$j + 1] - $l[$j];\n            $count++;\n \
    \           next if $val != 0;\n            $count--;\n            $j++;\n   \
    \     }\n    }\n    return $count == 0 ? \"\" : $count;\n}", "    my $string =\
    \ \"\";\n    my $count = 0;\n    foreach my $i (0 .. @$l - 1) {\n        my $sum\
    \ = $l->[$i] + $l->[$i + 1];\n        if ($sum == 0) {\n            $count++;\n\
    \            $string .= \"$i\";\n        }\n    }\n    if ($count == 1) {\n  \
    \      return $string;\n    }\n    return undef;\n}", "    $l =~ s/^\\s*\\[(\\\
    d+)\\]\\s*,\\s*\\[(\\d+)\\]\\s*$/\\1\\2/;\n    ($l =~ /([+-])\\s*(\\d)/) && $l\
    \ =~ s/^([+-])\\s*(\\d)/$1 + $2/;\n    $l =~ s/^([+-])\\s*(\\d)/$1$2/;\n    ($l\
    \ =~ /([+-])\\s*(\\d)/) && $l =~ s/^([+-])\\s*(\\d)/$1 + $2/;\n    $l =~ s/^([+-])\\\
    s*(\\d)/$1$2/;\n    ($l =~ /([+-])\\s*(\\d)/) && $l =~ s/^([+-])\\s*(\\d)/$1 +\
    \ $2/;\n    $l =~ s/^([+-])\\s*(\\d)/$1$2/;\n    ($l =~ /([+-])\\s*(\\d)/) &&\
    \ $l =~ s/^([+-])\\s*(\\d)/$1 + $2/;\n    $l =~ s/^([+-])\\s*(\\d)/$1$2/;\n  \
    \  ($l =~ /([+-])\\s*(\\d)/) && $l =~ s/^([+-])\\s*(\\d)/$1 + $2/;\n    $l =~\
    \ s/^([+-])\\s*(\\d)/$1$2/;\n    ($l =~ /([+-])\\s*(\\d)/) && $l =~ s/^([+-])\\\
    s*(\\d)/$1 + $2/;\n    $l =~ s/^([+-])\\s*(\\d)/$1$2/;\n    ($l =~ /([+-])\\s*(\\\
    d)/) && $l =~ s/^([+-])\\s*(\\d)/$1 + $2/;\n    $l =~ s/^([+-])\\s*(\\d)/$1$2/;\n\
    \    ($l =~ /([+-])\\s*(\\d)/) && $l =~ s/^([+-])\\s*(\\d)/$1 + $2/;\n    $l =~\
    \ s/^([+-])\\s*(\\d)/$1$2/;\n    ($l =~ /([+-])\\s*(\\d)/) && $l =~ s/^([+-])\\\
    s*(\\d)/$1 + $2/;\n    $l =~ s/^([+-])\\s*(\\d)/$1$2/;\n    ($l =~ /([+-])\\s*(\\\
    d)/) && $l =~ s/^([+-])\\s*(\\d)/$1 + $2/;\n    $l ", "    my $s = $l->[0];\n\
    \    $l->[0] = scalar(@{$l->[1]} == 0 ? \"\" :\n        $l->[1]->[0] + ($l->[1]->[1]\
    \ * (@{$l->[1]}->[0] - 1))\n    );\n    return $s;\n}", "    my %seen;\n    my\
    \ $s = 0;\n    my %unique;\n    $unique{$_}++ foreach @$l;\n    foreach my $x\
    \ (keys %unique) {\n        $s = 0 if $unique{$x} > 1;\n        if ($s == 0) {\n\
    \            return \"\";\n        }\n    }\n    return 1;\n}", "    if ( scalar($l)\
    \ == 1 ) {\n        return \"1\";\n    }\n    return \"\";\n}", "    my %seen;\n\
    \    foreach my $item (@$l) {\n        next if defined $seen{$item}; # avoid comparing\
    \ the same item twice\n        $seen{$item}++;\n    }\n    return 0 unless $seen{$_}\
    \ >= 2 for (0 .. $#l);\n    return \"\";\n}\n</code>\n<|/ a dscore=3 |>\n<| c\
    \ |>\nI think the `if` is probably supposed to be  `next if ! defined $seen{$item};`\
    \ but it's only a style issue, not a functional one.\n<|/ c |>\n<| c |>\n: Yes,\
    \ I agree. Fixed the code.\n<|/ c |>\n<| c |>\nThis code has some interesting\
    \ edge cases, like the empty array and singleton arrays. The \"if defined\" check\
    \ should be \"if not defined $seen{$item}\".\n<|/ c |>\n<| c |>\n: `defined $item`\
    \ checks if the item is defined in the hash. So if `undef` is stored in the hash,\
    \ `$seen{$item}++` won't be evaluated.\n<|/ c |>\n<| c |>\n: Not if you use 'next\
    \ if' instead of 'next unless'. Of course, if the item is undef, the second part\
    \ of the 'if' statement will be evaluated, so you are right that the 'if' statement\
    \ should be 'if not defined...'.\n<|/ c |>\n<| a dscore=3 tags=perl,algorithm\
    \ |>\nAs an alternative to the hash solutions already posted, you can use the\
    \ following code:\n<code>", "    my $count = 0;\n    \n    for(my $i=0; $i<@$l;\
    \ $i++){ \n        for(my $j=$i+1; $j<@$l; $j++){ \n            if($l->[$i]+$l->[$j]\
    \ == 0){ \n                $count++; \n            }\n        }\n    }\n    \n\
    \    my $s = $count == 0;\n    \n    return $s;\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nI see what you are getting at - but this doesn't take into account the\
    \ fact that the sum is negative, and therefore not really a pair. Also, the problem\
    \ doesn't specify whether each input is a unique or repeated pair.\n<|/ c |>\n\
    <| c |>\nThank you, your answer was very helpful! I tweaked the code a little\
    \ by removing redundancies by looping through each input pair in `@_` and comparing\
    \ the output to `0` rather than `\"\"`. This was just for my own edification,\
    \ but your answer gave me a better understanding of how to handle the problem.\
    \ Thanks again!\n<|/ c |>\n<| c |>\nThanks for your feedback. I've edited my answer\
    \ to remove the redundant loops. In your situation, I guess I wouldn't use my\
    \ original answer. I'm glad you found this helpful!\n<|/ c |>\n<| a tags=perl,pattern-matching,arrays,subroutine\
    \ |>\n<code>", "    my $result = \"\";\n    while (@$l) {\n        my $first_element\
    \ = shift;\n        my $second_element = shift(@$l);\n        if ($first_element\
    \ + $second_element == 0) {\n            $result = $first_element . \"-$second_element\"\
    ;\n        }\n    }\n    return $result;\n}", "    my $s = scalar(@$l);\n    if\
    \ ($s == 0) {\n        return \"\";\n    } elsif ($s == 1) {\n        return $l->[0]\
    \ if $l->[0] == 0;\n    } elsif ($s == 2) {\n        return $l->[0] if $l->[0]\
    \ == $l->[1];\n    } elsif ($s == 3) {\n        return $l->[0] if $l->[0] == $l->[1]\
    \ and $l->[1] == 0;\n    } elsif ($s <= 3) {\n        my $a = $l->[0];\n     \
    \   my $b = $l->[1];\n        my $c = $l->[2];\n        return $a . \"\" if $a\
    \ == 0 && $b == 0 && $c == 0;\n        return $a . $b if $a == 0 && $b == 0;\n\
    \        return $a . $b . $c if $a == 0;\n        return $b . $a . $c if $b ==\
    \ 0;\n        return $c . $a . $b;\n    }\n}", "    my(@s) = $l->[pairs];\n  \
    \  my($t);\n    $t = $l->[0]->[pairs];\n    $t = 0 unless defined $t;\n    my(@pairs);\n\
    \    foreach my $s (@s) {\n        my $p = ($t->[1] + $s->[1]);\n        if ($p\
    \ > 0) {\n            if ($p != $t) {\n                push (@pairs, @{$t->[0]},\
    \ $s);\n            }\n            $t = $p;\n        }\n        else {\n     \
    \       if ($p != $t) {\n                push (@pairs, @{$t->[0]}, $s);\n    \
    \        }\n        }\n    }\n    if ($t) {\n        push (@pairs, @{$t->[0]});\n\
    \    }\n    return @pairs;\n}", '    return if ($l == 1);', "    if (@$l == 0)\
    \ {\n\treturn '';\n    } elsif (@$l == 1) {\n\treturn '1';\n    } elsif (@$l ==\
    \ 2) {\n\treturn '1';\n    } else {\n\tmy $n = 0;\n\tforeach my $i (@$l) {\n\t\
    \    return '';\n\t    $n += $i;\n\t}\n\treturn $n == 0 ? '1' : '0';\n    }\n}",
  "    my $re = \"\";\n    my $max = 0;\n    for (my $i = 0; $i < @$l; $i++) {\n \
    \       $max = $i > $max ? $i : $max;\n        if ($l->[$i] > 0) {\n         \
    \   $re .= \"  \" if ($re ne \"\");\n            $re .= \"$i $l->[$i]\";\n   \
    \     }\n    }\n    return $max != @$l ? \"1\" : $re;\n}", "    my($total, $n);\n\
    \    my(@pairs);", "    my(@pairs) = ();\n    my($sum) = 0;\n    my($cnt) = 0;",
  "    my @arr;\n    my @pairs;\n    my $max = 0;\n    \n    for my $v (@$l) {\n \
    \       if ($v > $max) {\n            $max = $v;\n        }\n        push(@arr,\
    \ abs($v));\n    }\n    \n    for my $v (@arr) {\n        foreach my $p (@arr)\
    \ {\n            if ($v > $p && $p != 0) {\n                push(@pairs, abs($v\
    \ - $p));\n            }\n        }\n    }\n    \n    if (@pairs > 0) {\n    \
    \    my $n = $pairs[@pairs - 1];\n        if ($n == 0) {\n            return \"\
    \";\n        }\n        \n        my $i = 1;\n        my $j = 0;\n        \n \
    \       while (@pairs > 0) {\n            my $tmp = $pairs[$j];\n            if\
    \ ($tmp != 0) {\n                unshift, $tmp;\n                $j += 1;\n  \
    \              \n                $tmp = $pairs[$j];\n                if ($tmp\
    \ != 0) {\n                    unshift, $tmp;\n                }\n           \
    \     $j += 1;\n            }\n        }\n        \n        if ($n != 0 && $pairs[0]\
    \ == 0) {\n            return \"\";\n        }\n        \n        my $sum = 0;\n\
    \        \n        for my $k (@pairs) {\n            $sum += $k;\n        }\n\
    \        \n        if ($sum == 0 && @pairs > 0) {\n            return \"\";\n\
    \        }\n        \n        return $n > 0 ? 1 : \"\";\n    }\n    \n    return\
    \ \"\";\n}", "    my @p = ();\n    for (my $i = 0; $i < @$l; $i += 2) {\n    \
    \    push(@p, $l->[$i] + $l->[$i+1]);\n    }\n    return (grep(!($p[0] eq $p[1]),@p))\
    \ ? \"1\" : \"\";\n}", "    my $s = \"\";\n    for my $x (@$l) {\n        for\
    \ my $y ($x) {\n            $s .= \" \" if $x != $y;\n            $s .= \"1\"\
    ;\n        }\n    }\n    return $s;\n}", "    my(@pairs) = ();\n    my($sum) =\
    \ 0;\n    foreach my $num (@$l) {\n        push(@pairs, [$num, $sum]);\n     \
    \   $sum++;\n    }\n    if (@pairs == 1) {\n        return \"1\";\n    }\n   \
    \ foreach my $pair (@pairs) {\n        my($x, $y) = @$pair;\n        if ($x ==\
    \ $y) {\n            if ($x == 0) {\n                return \"\";\n          \
    \  }\n            else {\n                return \"1\";\n            }\n     \
    \   }\n    }\n    return \"0\";\n}", "    my $result = '';", '    my $sum;', " \
    \   my @result;\n    my $sum;\n    my $check;\n    foreach my $i (0..$#$l) {\n\
    \        my $v = $l->[$i];\n        $check = 0;\n        foreach my $j (0..$#$l)\
    \ {\n            if ($i != $j) {\n                $sum += $l->[$j];\n        \
    \        if ($sum == 0) {\n                    $check = 1;\n                 \
    \   last;\n                }\n            }\n        }\n        if ($check) {\n\
    \            push (@result, $i);\n        }\n    }\n    if (@result > 1) {\n \
    \       return 1;\n    }\n    return 0;\n}", "    my $pairs = $l->[0];\n    my\
    \ $sum = $l->[1];\n    my $cnt = 0;\n    my $i = 0;\n    my $k = 0;\n    my $tmp\
    \ = 0;", "    return $l != scalar(@$l) ? 1 :\n          scalar(@$l) == scalar(grep(!($_+$l[$_]\
    \ eq $l[$_]), (0..$#l)));\n}", "    my $max = $l->[-1];\n    for (my $i = $#l\
    \ - 1; $i >= 0; $i--) {\n        my $x = $l->[$i];\n        if ($x == 0) {\n \
    \           my $y = 0;\n            $l->[$i] = $y;\n        } else {\n       \
    \     my $y = $x + $l->[$i - 1];\n            $l->[$i] = $y;\n            $max\
    \ = $y if $y > $max;\n        }\n    }\n    return $max ? \"1\" : \"\";\n}", " \
    \   my @pairs;\n    my $num_elements = @$l;\n    for my $i (0..$num_elements-1){\n\
    \        my $j = $num_elements - 1 - $i;\n        if ($l[$i] + $l[$j] eq '0')\
    \ {\n            push(@pairs, $i);\n        }\n    }\n    return \"\" unless @pairs;\n\
    \    return scalar(@pairs) == 1 ? \"\" : \"1\";\n}", "    my $sum = 0;\n    foreach\
    \ my $i(@$l) {\n\t$sum += $i;\n\tif ($sum == 0)\n\t    {\n\t    return 1;\n\t\
    \    }\n    }\n    return 0;\n}", "    my @pairs = ();\n    foreach my $i (0..$#$l)\
    \ {\n        my $j = $i+1;\n        $pairs[$i] = $j if $l[$i] + $l[$j] == 0;\n\
    \    }\n    return 1 unless @pairs;\n    return unless $pairs[0] + 1 == $pairs[1];\n\
    \    return 0;\n}", "    my $s = 0;\n    \n    foreach my $e ( @$l ) {\n     \
    \   my $n = ( $e != 0 );\n        $s .= $n ? \"1\" : \"0\";\n    }\n    return\
    \ $s;\n}", "    my (@array) = @$l;\n    my $count = 0;\n    my $temp;\n    for\
    \ (my $i = 0; $i < @array; $i++) {\n        my $j = $i + 1;\n        $temp = $array[$i];\n\
    \        while (@array > $j) {\n            $array[$j] += $temp;\n           \
    \ while (@array > $j + 1) {\n                $array[$j + 1] -= $temp;\n      \
    \          if ($array[$j + 1] < 0) {\n                    undef $array[$j + 1];\n\
    \                    undef $array[$j];\n                    $array[$j] = 0;\n\
    \                }\n                $j++;\n            }\n        }\n    }\n \
    \   if (@array > 1) {\n        return 1;\n    }\n    return 0;\n}\n</code>\nI\
    \ feel like there has to be a way to use pairs to accomplish this more efficiently\
    \ though.\n<|/ a tags=algorithm,perl,combinations,arrays,set |>\n<| c |>\nWhat\
    \ you say about Pairs being an \"O(n)\" operation, is true.  However, since you\
    \ only need to look at the two elements, this is O(2).  You can't get the worst-case\
    \ O(n) time for this, but you do need to get O(n log n) time or O(n^2) time complexity\
    \ for the sorting step.  Even if you do get this, it would not get you the O(n)\
    \ time complexity.\n<|/ c |>\n<| c |>\nYou are right, the sorting step would be\
    \ O(n log n), but we would still need O(n log n) for the final check.\n<|/ c |>\n\
    <| c |>\nActually, this does get you O(n^2) time complexity, because your algorithm\
    \ doesn't know if the two elements in the set are equal, so it would have to check\
    \ every combination.\n<|/ c |>\n<| c |>\nI never knew that Perl had a [sort](https://perldoc.perl.org/functions/sort.html)\
    \ function that takes a callback.  Nice.\n<|/ c |>\n<| a |>\nHere's a solution\
    \ that's O(n^2) because of the sort.\n<code>", "    # initialize $n to 1 if there\
    \ are two distinct elements in the array that\n    # sum to zero\n    my $n =\
    \ (@$l == 1) ? 1 : 0;\n    for (my $i = 0; $i < @$l; $i++) {\n        $n = $n\
    \ if ($l[$i] - $l[$i-1] != 0);\n    }\n    return $n;\n}", "    $l =~ m@^-?\\\
    d+$@ && return  == 0 ? \"1\" : \"\";\n    $l =~ m@^-?\\d+$@ && return  == 0 ?\
    \ \"1\" : \"\";\n    $l =~ m@^-?\\d+$@ && return  == 0 ? \"1\" : \"\";\n    return\
    \  == 0 ? \"1\" : \"\";\n}", "    return $l->[0] if $l->[0] eq $l->[1];\n    return\
    \ \"\";\n}\n</code>\n<|/ a |>\n<| c |>\nWhile this code may answer the question,\
    \ providing additional context regarding why and/or how this code answers the\
    \ question improves its long-term value.\n<|/ c |>\n<| a |>\nMy answer is slightly\
    \ different than the others posted. This is because I'm a fan of writing code\
    \ as opposed to mathematicians. My code is a bit more concise, but I think this\
    \ approach is more elegant. I also think this approach is more intuitive to anyone\
    \ looking at the code (such as myself in the future).\nIn essence I'm counting\
    \ the number of non-zero pairs in the array, then checking to see if there are\
    \ any pairs that sum to zero. It seems more natural to me than working from the\
    \ back of the array because we're going through the array from the back rather\
    \ than the front.\n<code>\nuse strict;\nuse warnings;", "    my @a = grep { $_\
    \ != 0 } @$l;\n    my $ret = 0;\n    foreach my $i (0..$#a) {\n        my $found\
    \ = 0;\n        for (my $j = 0; $j < $#a; ++$j) {\n            if ($j != $i) {\n\
    \                next unless $a[$j] + $a[$i] == 0;\n                $found = 1;\n\
    \            }\n        }\n        die \"Two distinct elements in the array that\
    \ sum to zero\" if !$found;\n        $ret += !$found;\n    }\n    return $ret;\n\
    }", "    return \"\";\n}", "    my $s = pairs(@$l);\n    my $z=0;\n    foreach\
    \ (@$s) {\n        my $z1 = $_ + $z;\n        last if $z1 > 0;\n        $z = $z1;\n\
    \    }\n    return if $z > 0;\n    my $result = $z;\n    foreach (@$s) {\n   \
    \     $result -= $_;\n    }\n    return $result;\n}", "    $l =~ s/^\\s+//;\n\
    \    $l =~ s/\\s+$//;\n    return undef if ($l =~ /^-?\\d+$/);\n    my @pairs\
    \ = ();\n    my $pairs;\n    my $sum;\n    my $i;\n    my $j;\n    my $k;\n  \
    \  my $sum;\n    my $max_sum;\n    my $max_ii;\n    my $max_j;\n    my $max_k;\n\
    \    my $found;\n    my $found_pair;\n    my @pairs_sum = ();\n    foreach my\
    \ $i (0 .. $#$l) {\n        push(@pairs, $l[$i]);\n    }\n    foreach my $pair\
    \ (@pairs) {\n        for ($k = 0; $k <= @pairs - 1; $k++) {\n            for\
    \ ($i = 0; $i <= @pairs - 1; $i++) {\n                $j = $i + $k + 1;\n    \
    \            if ($i < 0 || $j < 0) {\n                    next;\n            \
    \    }\n                for ($k = 0; $k <= @pairs - 1; $k++) {\n             \
    \       if ($k > 0 && $l[$i] eq $l[$i - 1]) {\n                        $pairs_sum[$k]\
    \ += $l[$j];\n                        $j += $k + 1;\n                    }\n \
    \                   if ($k > 0 && $l[$i] eq $l[$j - 1]) {\n                  \
    \      $pairs_sum[$k] += $l[$j];\n                        $j += $k + 1;\n    \
    \                }\n                    if ($l[$j] eq $l[$i - 1] && $l[$j] eq\
    \ $l[$j - 1]) {\n                        $pairs_sum[$k] += $l[$j];\n         \
    \               $j += $k + 1;\n                    }\n                }\n    \
    \            if ($pairs_sum[$k] == 0) {\n                    $found = 1;\n   \
    \                 $found_pair = $k;\n                    $sum = $l[$i];\n    \
    \            }\n                if ($pairs_sum[$k] > $sum) {\n               \
    \     $found = 1;\n                    $found_pair = $k;\n                   \
    \ $sum = $pairs_sum[$k];\n                }\n            }\n        }\n      \
    \  if ($found) {\n            $sum -= $l[$found_pair];\n            $max_i = $i;\n\
    \            $max_j = $j;\n            $max_k = $found_pair;\n            $max_sum\
    \ = $sum;\n        }\n    }\n    return undef if ($max_k == 0);\n    return undef\
    \ if ($max_sum == 0);\n    return undef if ($max_i != $max_j);\n    return undef\
    \ if ($max_i != $max_k);\n    return undef if ($max_j != $max_k);\n    return\
    \ undef if ($", "    # find the minimum absolute value that is negative or zero\
    \ (this would mean that all negative numbers are positive)\n    my $lmin = Math::Abs($l[0]);\n\
    \    my $m = 0;\n    my $n_pairs = 0;\n    my $m = $l == 1 ? 0 : $l[0]; # we start\
    \ at zero and count the pairs as we go\n    for my $i(1..@$l) {\n        my $j\
    \ = $l[$i];\n        my $sum = $i + $j;\n        my $diff = $i - $j;\n       \
    \ if ($sum == 0) { # no two equal numbers can be summed to zero\n            return\
    \ \"\";\n        } elsif ($diff > 0) {\n            if ($sum > $m) { # two equal\
    \ numbers are only not equal if they are both negative\n                return\
    \ \"\";\n            } elsif ($sum == $lmin) {\n                $n_pairs++;\n\
    \                last if $n_pairs == 2;\n            } elsif ($sum < $m) { # two\
    \ equal numbers are only not equal if they are both positive\n               \
    \ return \"\";\n            } else {\n                $m = $sum;\n           \
    \ }\n        } else {\n            if ($sum < $m) { # two equal numbers are only\
    \ not equal if they are both positive\n                return \"\";\n        \
    \    } elsif ($sum == $lmin) {\n                $n_pairs++;\n            } elsif\
    \ ($sum > $m) { # two equal numbers are only not equal if they are both negative\n\
    \                return \"\";\n            } else {\n                $m = $sum;\n\
    \            }\n        }\n    }\n    return $m == 0 ? \"\" : 1;\n}", "    my\
    \ ($n1, $n2, $n_sum, $n_zero, $ans, $max);\n    my $i = 1;\n    while ($i < @$l)\
    \ {\n        my $j = @$l - $i;\n        $n1 = $l->[$i];\n        $n2 = $l->[$j];\n\
    \        $n_sum = $n1 + $n2;\n        $n_zero = ($n_sum - $n1) % 2;\n        $ans\
    \ = $n_sum + $n_zero;\n        $max = $j - $i;\n        $i = $i + $max;\n    \
    \    if ($ans == 0) {\n            return \"\";\n        }\n        if ($ans ==\
    \ $n_sum) {\n            return $ans.\"\";\n        }\n    }\n    return \"\"\
    ;\n}", "    my($sum) = 0;\n    my(@pairs);\n    foreach $i (@$l) {\n        push\
    \ (@pairs, $i, $i-$sum) if $sum == 0;\n        $sum = $sum + $i;\n    }\n    return\
    \ $sum == 0 ? \"\" : $sum == 1 ? 1 : 0;\n}", '    my($sum);', "    my %h;\n  \
    \  my $first = 1;\n    my $zero = 0;", "    my $s = 0;\n    for(my $i=0; $i<@$l;\
    \ $i++)\n    {\n        if($l->[$i] % 2 == 0)\n        {\n            $s = 0;\n\
    \            for(my $j=$i; $j<@$l; $j++)\n            {\n                my $k\
    \ = @$l - 1 - $j;\n                $s += $l->[$k];\n            }\n          \
    \  if($s == 0)\n            {\n                $l->[$i] .= \"0\";\n          \
    \      $l->[$i] .= \"1\";\n                return 1;\n            }\n        }\n\
    \    }\n    return \"\";\n}", "    my $max = 0;\n    my $min;\n    foreach my\
    \ $pair (sort {$a <=> $b} $l) {\n        my $n = $pair->[0];\n        my $m =\
    \ $pair->[1];\n        $max += $n;\n        $min += $m;\n    }\n    if ($max >\
    \ 0 && $min == 0) {\n        return \"\";\n    }\n    elsif ($max == 0 && $min\
    \ > 0) {\n        return \"\";\n    }\n    elsif ($max == 0) {\n        return\
    \ $min > 0 ? \"1\" : \"0\";\n    }\n    elsif ($min == 0) {\n        return $max\
    \ > 0 ? \"0\" : \"1\";\n    }\n    else {\n        return $min > 0 ? \"1\" : \"\
    0\";\n    }\n}", "    my $sum = 0;\n    my $result = 0;\n    my $x = 0;", "  \
    \  my($s, $i, $j, $n) = (0, 0);\n    foreach (@$l) {\n        if ($i == 0) {\n\
    \            $s = $_;\n            $n++;\n        }\n        elsif ($_ != $s)\
    \ {\n            return 1 if $i == $n;\n            $s = $_;\n            $n++;\n\
    \        }\n        else {\n            $n++;\n        }\n    }\n    return 1\
    \ if $i == $n;\n    return \"\";\n}", "    my $res = \"1\";\n    foreach my $i\
    \ (@$l) {\n        if ($i == 0) {\n            return $res;\n        }\n     \
    \   if ($i == 1) {\n            return $res;\n        }\n        my $c = $i +\
    \ $i;\n        if ($c == 0) {\n            $res .= \"  \" . $i;\n        }\n \
    \       if ($c > 0) {\n            $res .= \"  \" . $c;\n        }\n    }\n  \
    \  return $res;\n}", "    my $ret = 0;\n    for($l->[0..($#l-1)]) {\n        if($l->[$_]\
    \ == $l->[$_ + 1]) {\n            $ret = 1;\n        }\n    }\n    return $ret;\n\
    }", "    my %sums;\n    for (my $i = 0; $i < @$l; ++$i) {\n        next if $sums{$i}++;\n\
    \        my $t = $l->[$i];\n        my $s = 0;\n        while ($t > 0) {\n   \
    \         $s = $s + $t-- if $t > 0;\n        }\n        $sums{$i} = $s;\n    }\n\
    \    for (my $i = 0; $i < @$l; ++$i) {\n        my $s = $sums{$i};\n        my\
    \ $j = $i + 1;\n        while ($j < @$l) {\n            $s = $s if $l->[$i] +\
    \ $l->[$j] == 0;\n            $j++;\n        }\n        if ($s == 0) {\n     \
    \       return $i if $i == $j - 1;\n        } else {\n            return 1;\n\
    \        }\n    }\n    return \"\";\n}", "    $l =~ s/^\\s+//g;\n    my(@r) =\
    \ ();\n    while(@l) {\n        my ($i, $j) = splice, 0, 2;\n        if ($i ==\
    \ 0 && $j == 0) {\n            return 1;\n        }\n        if ($i == $j) {\n\
    \            push (@r, ($i, 0));\n        }\n        elsif ($i < $j) {\n     \
    \       push (@r, ($i, 1));\n        }\n        else {\n            push (@r,\
    \ ($j, 1));\n        }\n    }\n    # unmatched\n    return '';\n}", '    my %hash;',
  "    $l =~ s/^0+(?!.*0)//g;\n    $l =~ s/^0+$/$/;\n    if ( $l eq \"\" ) { #return\
    \ \"\" if there are no pairs\n        $pairs{-1} = $pairs{-2};\n        return\
    \ 0;\n    }\n    if ( $pairs{-1} eq $pairs{-2} ) { #return \"\" if there is a\
    \ single pair\n        $pairs{-1} = $pairs{-2};\n        return 0;\n    }\n  \
    \  if ( $l =~ /^$/ ) { #return \"\" if there are no pairs\n        $pairs{-1}\
    \ = $pairs{-2};\n        return 0;\n    }\n    my ($i, $j) = (0, 0);\n    while\
    \ ( ($i, $j) = each %pairs ) {\n        last if ( $pairs{$i} eq $pairs{$j} &&\
    \ $pairs{$i} > $l );\n    }\n    if ( $i != $j ) { #return \"\" if there is a\
    \ single pair\n        $pairs{-1} = $pairs{-2};\n        return 0;\n    }\n  \
    \  $pairs{-1} = $pairs{-2};\n    return 1;\n}\n</code>\n<|/ a tags=algorithm,perl,sorting,hash,arrays\
    \ |>\n<| c |>\nI appreciate that it's in perl but it seems like the OP doesn't\
    \ know perl.\n<|/ c |>\n<| c |>\nI think your `pairs_sum_to_zero` is doing too\
    \ much. Try `@pairs{-1} = $pairs{-2}; return 1;` instead, which is what the OP\
    \ seems to want.\n<|/ c |>\n<| c |>\nI like that `pairs_sum_to_zero` approach!\
    \ I guess I should have been more clear on that.\n<|/ c |>\n<| c |>\n: I realize\
    \ this isn't Perl. My point was that I don't understand how this works. I don't\
    \ understand what you're doing, and it doesn't seem to be portable at all. How\
    \ would you do this if you were to write it in another language?\n<|/ c |>\n<|\
    \ c |>\n: I appreciate that, but how would you do it in any other language? Why\
    \ isn't it portable? The only thing I see that doesn't work is that you need to\
    \ use `@pairs{-1}` and `@pairs{-2}` to access the first and second elements in\
    \ `@pairs`. I don't see how that helps portability, since `$pairs{-1}` and `$pairs{-2}`\
    \ don't exist in `@pairs`.\n<|/ c |>\n<| a tags=algorithm,perl,sorting,hash,arrays\
    \ |>\nHere's my ", "    my $zero = 0;\n    my $two = 0;\n    my $sum = 0;\n  \
    \  my $diff = 0;\n    while (@$l >= 2) {\n        $two = $l->[0];\n        $sum\
    \ += $l->[1];\n        $diff = $l->[1] - $zero;\n        if ($sum == $zero &&\
    \ $diff == 0) {\n            return 1;\n        }\n        $zero += $two;\n  \
    \      @$l = @$l[2 .. $#$l];\n    }\n    return 0;\n}", "    my($s);\n    my($z);\n\
    \    my($i);\n    foreach $i (@$l) {\n        if ($i > 0) {\n            $z =\
    \ 0;\n            while ($i > 0) {\n                $z += $i;\n              \
    \  $i -= 1;\n            }\n            $s = $z if $z == 0;\n            $i -=\
    \ 1;\n            $l =~ s/$i//;\n        }\n    }\n    return $s;\n}", "    my\
    \ (@ret);\n    my $ret = '';\n    my $sum = 0;", "    my $ret = 0;\n    \n   \
    \ foreach my $n (@$l) {\n        if (($n - $ret) ne 0) {\n            $ret = $n;\n\
    \        }\n    }\n    \n    return $ret;\n}", "    my $ret = '';\n    my $count\
    \ = 0;\n    for my $x (@$l) {\n        if ($x == 0){\n            $ret = $ret.$count.\"\
    \\n\";\n            $count = $x;\n        }else{\n            $count = $count\
    \ + $x;\n        }\n        if ($count != 0){\n            $ret = $ret.$count.\"\
    \\n\";\n        }\n    }\n    return $ret\n}", "    my $count = 0;\n    my @pairs\
    \ = ();\n    \n    foreach my $i (0 .. $#$l) {\n        foreach my $j ($i..$#$l)\
    \ {\n            my $x = $l->[$i];\n            $x = $l->[$i];\n            push\
    \ @pairs, [ $i, $j ];\n            \n            my $y = $l->[$j];\n         \
    \   $y = $l->[$j];\n            \n            my $diff = $x - $y;\n          \
    \  \n            if ($diff == 0) {\n                $count ++;\n            }\n\
    \        }\n    }\n    \n    if ($count == 0) {\n        return 0;\n    } else\
    \ {\n        return 1;\n    }\n}", "    my $total;\n    my $first;\n    my $firstpair;\n\
    \    for (my $i = 0; $i < @$l; $i++) {\n        my $thispair = $l->[$i];\n   \
    \     $total += $thispair;\n        if ($total < 0) {\n            return 0;\n\
    \        }\n        if ($total > 0) {\n            $first = $thispair;\n     \
    \       $firstpair = $thispair;\n        }\n        elsif ($total === 0) {\n \
    \           return '';\n        }\n    }\n    return $first == $firstpair ? $first\
    \ : '';\n}", "    my $ret = 0;\n    my $i = 0;\n    my $j = 1;\n    my $k = scalar\
    \ @$l;\n    while ($i < $k) {\n        if ($l->[$i] < 0) {\n            $ret =\
    \ $ret || $l->[$i] & -$l->[$i];\n            $l->[$i] &= -$l->[$i];\n        }\n\
    \        $j++;\n        if ($j < $k) {\n            if ($l->[$i] + $l->[$j] !=\
    \ 0) {\n                $ret = $ret || $l->[$i] + $l->[$j];\n            }\n \
    \           $i++;\n        }\n    }\n    $ret;\n}", "    return \"\" unless @$l;\n\
    \    my $s = 0;\n    for (@$l) {\n        if ($s ne 0 && $_ eq $s) {\n       \
    \     return 0;\n        }\n        $s += $_;\n    }\n    return 1;\n}", "   \
    \ my($i,$j) = @$l;\n    my($sum,$sumsum,$sumsumsum);\n    my($first_sum,$second_sum);\n\
    \    for ($i=0;$i<$j;$i++) {\n        $sum = 0;\n        for ($j=$i;$j<@$l;$j++)\
    \ {\n            $sum += $l[$j];\n        }\n        $sumsum = $sum;\n       \
    \ $sumsumsum = 0;\n        for ($j=$i;$j<@$l;$j++) {\n            $sumsumsum +=\
    \ $l[$j] * $l[$j];\n        }\n        $first_sum = $sum;\n        $second_sum\
    \ = $sumsum;\n        if ($sumsum == $first_sum * $second_sum) {\n           \
    \ return $sum == 0 ? \"\" : \"1\";\n        }\n    }\n    return \"\";\n}", '    return
    undef unless @$l;', "    my %seen;\n    $seen{$_}++ for @$l;\n    my $result;\n\
    \    if (keys %seen == 1) {\n        my $key = keys %seen;\n        $result =\
    \ $key eq $l[0] ? 1 : \"\";\n    } else {\n        $result = \"\";\n    }\n  \
    \  return $result;\n}\n</cell>\n<text>\nHow do we find the maximum or minimum\
    \ of a list?\nPerl provides a function named min that returns the minimum value\
    \ in a list:", "    my $s = 0;\n    for (my $i = 0; $i <= $#l; $i++) {\n     \
    \   $s += $l[$i];\n        last if $i == $#l || $l[$i] == 0;\n    }\n    return\
    \ $s == 0 ? '' : '';\n}", "    my(@v) = (sort {$a <=> $b} $l);\n    my($v, $u);\n\
    \    my $s = 0;\n    for(my $i = 0; $i < @v; $i++) {\n        if ($v[$i] + $v[$i]\
    \ == 0) {\n            $s = 0;\n            last if $v[$i] > 0;\n        } else\
    \ {\n            $s += $v[$i];\n        }\n    }\n    $s == 0\n}\n</code>\n<|/\
    \ a dscore=0 |>\n<| a |>\nHere's a solution which runs in O(n) time. It keeps\
    \ track of the pairs of non-negative numbers that are strictly positive, non-negative,\
    \ and strictly negative (i.e. it considers negative numbers non-positive).\n<code>",
  "    return 1 unless @$l;\n    my $i = 0;\n    my @a = 0;\n    for(my $j = 0; $j\
    \ < @$l; ++$j){\n        if ($a[$i] == $l->[$j]){\n            $a[$i++] = 0;\n\
    \        }\n        else {\n            push (@a, $l->[$j]);\n            $a[$i++]\
    \ = 1;\n        }\n    }\n    while(@a > 0){\n        if ($a[$i] == 0){\n    \
    \        pop @a;\n        }\n        else{\n            return 0;\n        }\n\
    \    }\n    return 1;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
