name: HumanEval_103_rounded_avg
language: pl
prompt: "# You are given two positive integers n and m, and your task is to compute\
  \ the\n# average of the integers from n through m (including n and m). \n# Round\
  \ the answer to the nearest integer and convert that to binary.\n# If n is greater\
  \ than m, return -1.\n# Example:\n# >>> rounded_avg(1, 5)\n# \"0b11\"\n# >>> rounded_avg(7,\
  \ 5)\n# -1\n# >>> rounded_avg(10, 20)\n# \"0b1111\"\n# >>> rounded_avg(20, 33)\n\
  # \"0b11010\"\nsub rounded_avg {\n    my($n, $m) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&rounded_avg;\n\
  \        if(eq_deeply($candidate->(1, 5),\"0b11\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(7, 13),\"0b1010\"\
  )) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(964,\
  \ 977),\"0b1111001010\")) {\n        print \"ok!\" }else{\n        exit 1;\n   \
  \     }\n        if(eq_deeply($candidate->(996, 997),\"0b1111100100\")) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(560,\
  \ 851),\"0b1011000010\")) {\n        print \"ok!\" }else{\n        exit 1;\n   \
  \     }\n        if(eq_deeply($candidate->(185, 546),\"0b101101110\")) {\n     \
  \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(362,\
  \ 496),\"0b110101101\")) {\n        print \"ok!\" }else{\n        exit 1;\n    \
  \    }\n        if(eq_deeply($candidate->(350, 902),\"0b1001110010\")) {\n     \
  \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(197,\
  \ 233),\"0b11010111\")) {\n        print \"ok!\" }else{\n        exit 1;\n     \
  \   }\n        if(eq_deeply($candidate->(7, 5),-1)) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(5, 1),-1)) {\n  \
  \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5,\
  \ 5),\"0b101\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\
  \ntesthumaneval();"
completions: ["    my $a = $n;\n    my $b = $m;\n    if ($a > $b) {\n        my @a\
    \ = unpack(\"i\", pack(\"I\", $a));\n        @a = reverse @a;\n        my @b =\
    \ unpack(\"i\", pack(\"I\", $b));\n        @b = reverse @b;\n        my $s = $a[$#a];\n\
    \        my $sum = 0;\n        for (my $i = $#a; $i >= 0; $i--) {\n          \
    \  $sum += $a[$i] * $b[$i];\n        }\n        return $sum / $s;\n    }\n   \
    \ return -1;\n}", "    if ($m > $n) {\n\treturn -1;\n    } elsif ($m == $n) {\n\
    \treturn \"0b0\" . $m;\n    } elsif ($n == $m) {\n\treturn \"0b0\" . $n;\n   \
    \ }\n    my $num = $n .. $m;\n    return int($num * bin($num))->bcd()\n}", " \
    \   return -1 if $n > $m;\n    $n -= 1;\n    $m -= 1;\n    $n /= 2;\n    $m /=\
    \ 2;\n    $n = 2**$n;\n    $m = 2**$m;\n    $n += $m;\n    $n = ~$n;\n    my $res\
    \ = $n & 1;\n    if ($n < 0) {\n        $res = ~$res;\n    }\n    return $res;\n\
    }", "    if ($m >= $n) {\n        $n + ($m-1) if $m > $n;\n        return -1;\n\
    \    }\n    my $digits = $n + ($m - $n) / 2;\n    $digits += 0.5;\n    $digits\
    \ *= 2;\n    $digits += 1 if $digits >= 10;\n    $digits = sprintf \"%b\", $digits;\n\
    \    $digits =~ s/0*$//;\n    return $digits;\n}", "    $n >= $m || return -1;\n\
    \    my $m = $m << 1;\n    my $s = $n + ($m - $n) / 2;\n    my $bits = '';\n \
    \   while (1) {\n        $s >>= 1;\n        $bits++;\n        $m >>= 1;\n    \
    \    $bits += $m != 0;\n        $m >>= 1;\n        $bits += $m != 0;\n       \
    \ $s >>= 1;\n        $bits += $s != 0;\n        $s >>= 1;\n        $bits += $s\
    \ != 0;\n        $s >>= 1;\n        $bits += $s == 0;\n        $bits++ if $s ==\
    \ 0;\n        last if $bits == 10;\n    }\n    my $result = ($bits - 1) >> 1;\n\
    \    return $result;\n}", "    my $avg = 0;\n    $avg = ($n+$m)/2;\n    my $result\
    \ = \"\";\n    while ($n>$m) {\n        $n--;\n        $result .= \"1\";\n   \
    \ }\n    while ($n<$m) {\n        $m--;\n        $result .= \"0\";\n    }\n  \
    \  return $result;\n}", "    my ($nval, $mval) = @_;\n    return -1 if $n > $m;\n\
    \    return -1 if $n < 0;\n    my $result = \"\";\n    my $round = 1;\n    while\
    \ (1) {\n        if ($n >= $m) \n        {\n            $result .= (oct($nval\
    \ / $round));\n            $round++;\n            $n -= $m;\n        } \n    \
    \    else {\n            $result .= oct($mval / $round);\n            $round++;\n\
    \            $m--;\n        }\n        if ($n == 0) {\n            if ($result\
    \ eq \"\") {\n                $result .= \"0\";\n            }\n            elsif\
    \ ($result =~ /0/) {\n                $result = \"0b\" . reverse $result;\n  \
    \          }\n            return $result;\n        }\n    }\n}", "    my $re =\
    \ substr($n/$m, length($n)/2, length($n));\n    return $n if $re =~ /^0+/;\n \
    \   return -1;\n}", "    return -1 if $n < $m;\n    my($round, $digits, $bits)\
    \ = &Math::LogBase($m, 10);\n    my($r, $x, $i, $s);\n    $n = $n if $n < $m;\n\
    \    $round = $round if $n < $round;\n    my $m = $round % $n;\n    $digits =\
    \ $digits + 1 if $n < $m;\n    $bits = $bits + 1 if $m < $n;\n    $r = $n;\n \
    \   $x = $m;\n    $i = $bits;\n    $s = $digits - $bits;\n    while ($i < $s)\
    \ {\n        $r <<= 1;\n        $r |= ($x & 1) << $i;\n        $x = $x >> 1;\n\
    \        $i++;\n    }\n    substr($r, $bits - $s, $bits) = $x if $x < $n;\n  \
    \  return $r >> $round;\n}", "    $n <= $m and return;\n    my($remainder, $n)\
    \ = @_;\n    my $bits = 0;\n    $n = 0 while $n != 0;\n    $m = 0 while $m !=\
    \ 0;\n    for my $i ($m, $n) {\n        $remainder = $i % 2 ? $remainder << 1\
    \ : $remainder >> 1;\n        $bits = $bits | ($remainder & 1);\n        $remainder\
    \ = $i % 2 ? $remainder >> 1 : $remainder << 1;\n        $n = $i % 2 ? $n - 1\
    \ : $n;\n    }\n    $bits == 0 or return -1;\n    return oct($bits);\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| a |>\nMy solution is far from being perfect, but I figured\
    \ it could be a starting point to build up from.\n<code>", "    # Handle corner\
    \ case\n    if ($m <= $n) {\n        # All numbers are included\n        return\
    \ $n;\n    } elsif ($m > $n) {\n        return -1;\n    }", "    if ($n <= $m)\
    \ {\n        return -1;\n    }\n    $n = $n + ($n - $m) * 2;\n    my $bin = '';\n\
    \    my $i = 0;\n    while ($i <= $m) {\n        $bin .= ($n % 2 == 0) ? '0' :\
    \ '1';\n        $n = ($n / 2);\n        $i++;\n    }\n    $bin .= $n;\n    return\
    \ $bin;\n}", "    if ($n <= $m) {\n        $n = ($n-1) x ($m+1);\n    } else {\n\
    \        return -1;\n    }\n    my $avg = unpack(\"V\", pack(\"L\", $n));\n  \
    \  $avg = ($avg / pow(2, (32 - $m)));\n    $avg = ($avg) x (32 - $m);\n    return\
    \ pack(\"B*\", $avg);\n}", "    my @avg = ();\n    \n    my $s = $n;\n    \n \
    \   for (my $i = 1; $i <= $m; $i++) {\n        my $x = $s / $i;\n        $avg[$i\
    \ - 1] = $x;\n        $s += $x;\n    }", "    my ($i, $j, $sum, $count) = (0,\
    \ 0, $n, $m);\n    if ($n < $m) {\n        return -1;\n    } elsif ($n == $m)\
    \ {\n        return $n;\n    } elsif ($n > $m) {\n        $n = $m; # Just to make\
    \ things clearer\n    }\n    while ($count < $n ) {\n        $sum += $j;\n   \
    \     $count += 1;\n        $j += 1;\n    }\n    return $sum / $n;\n}", '    return
    -1 if $n > $m;', "    if ($m > $n) {\n        -1;\n    }\n    else {\n       \
    \ $n = $n & $m;\n        my $s = '';\n        my $mask = $m >> 1;\n        for\
    \ (0..$((($n+1) & $mask) - 1)) {\n            $s = $s . '1';\n        }\n    \
    \    $n = $n + $mask;\n        $s = (1 << ($m-1))^$s;\n        return $s . $n;\n\
    \    }\n}\n</code>\nThis uses the fact that when one number is shifted right by\
    \ one bit to the right, the least significant bit will be set to 1.\nWe can also\
    \ do this in a single loop:\n<code>", "    if ($n < $m) {\n        $n .= 1;\n\
    \        $m .= 1;\n    } else {\n        $n -= 1;\n        $m -= 1;\n    }", '    my
    ($sum, $carry) = 0;', "    my $avg = (($n - 1) * $m) + $n;\n    my $bin = sprintf\
    \ \"%b\", $avg;\n    return -1 if $n > $m;\n    return $bin;\n}", "    $m += 1;\n\
    \    $n = 0 if $n == 0;", '    my $r = 0;', "    return -1 unless $n > $m;\n \
    \   return -1 unless $n <= 0;\n    return -1 unless $m <= 0;\n    return -1 unless\
    \ $m >= $n;\n    my $a = $n + ($m % 2);\n    my $b = ($m / 2) + 1;\n    my $c\
    \ = $m / 2;\n    return 0 if $a < $b;\n    return 0 if $b < $c;\n    return \"\
    0b\".oct($c).\"0\"x(7-$c).\"0b\".oct($a).\"0\"x(7-$a);\n}", "    return -1 unless\
    \ $n <= $m;\n    my $sum = ($n + $m)/2;\n    return int($sum) == $sum ? $sum :\
    \ -1;\n}", "    # Base Case: No numbers higher than m\n    if ($m == 0) {\n  \
    \      0;\n    }\n    elsif ($n == $m) {\n        return int($n); # Convert to\
    \ int if necessary\n    }\n    elsif ($n < $m) {\n        return -1;\n    }\n\
    \    my $count = $n;\n    # Iterate over the number of times to reach $m\n   \
    \ while ($count <= $m) {\n        $count += $n;\n    }\n    return int($count\
    \ / ($m-$n));\n}", "    if ($n <= $m) {\n        return $n >> 1;\n    } else {\n\
    \        return -1;\n    }\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=perl,modulo,binary\
    \ |>\nPerl solution:\n<code>\nuse strict;\nuse warnings;\nuse bigint;\nuse Math::BigInt;",
  "    my $avg = int(($n + $m) / 2);\n    if ($n < $m) {\n        $avg;\n    } else\
    \ {\n        -1\n    }\n}\n</code>\nIt works reasonably well for my purposes,\
    \ although I've yet to see it fail.\n<|/ a dscore=2 |>\n<| a tags=binary,math\
    \ |>\nOne possibility would be to compute the binary string of the decimal number.\
    \ Divide by 2 until you get back to the original number. \n<code>\na= int( (decimal_number/16))+int(\
    \ (decimal_number%16/4)+int( decimal_number%4 )\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThe integer division would fail, if the decimal number was negative and\
    \ you are using integer division. Also, this approach will round the decimal number\
    \ towards zero, which can lead to unexpected behavior if the decimal number is\
    \ not an integer.\n<|/ c |>\n<| a tags=binary,math |>\nThe trick is to remember\
    \ the number as decimal, perform the division and then convert it to binary. Here\
    \ I assume that both numbers are positive.\n<code>\ndef bin_convert(n):\n    while\
    \ n:\n        n, r = divmod(n, 2)\n        div = div if div else 0\n        div\
    \ = div + 1\n        while div and div < len(str(r)):\n            div += 1\n\
    \            if div < len(str(r)):\n                div = 0\n        div = div\
    \ * 4\n        rest = div\n        div = 0\n        while rest and div < len(str(rest)):\n\
    \            div += 1\n            if div < len(str(rest)):\n                div\
    \ = 0\n        div = div * 4\n        binary.append((str(r).rjust(div, 0)))\n\
    \    return ''.join(binary)\n</code>\n<|/ a dscore=0 |>\n<| a tags=binary,math\
    \ |>\nI wrote this in C which works:\n<code>", "    return $n unless $m > $n or\
    \ $n eq $m;\n    my $rem = $n % $m;\n    my $avg = ($n+$m)/2;\n    my $rem = $rem\
    \ - $avg;\n    my $digit = 0;\n    while (1) {\n        $avg /= 2;\n        $rem\
    \ *= 2;\n        $rem -= $avg;\n        $digit++;\n        $avg += $rem;\n   \
    \     if ($rem < 0)\n            return $avg;\n    }\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThe OP states that they are allowed to use integers. The solution\
    \ you gave would not work for floats. Floats cannot contain fractionals. The OP\
    \ stated that he was only allowed to use integers, but he also said that he could\
    \ not use strings. Your solution wouldn't work for strings either.\n<|/ c |>\n\
    <| c |>\n: I said \"using integers\" and not \"using strings\" because I saw \"\
    0b1111\" in the \"rounded_avg\" output, and that made me think this was an \"\
    integer\" problem, not a \"string\" problem. The OP states specifically that he\
    \ is allowed to use integers, so I figured \"integer\" was more appropriate.\n\
    <|/ c |>\n<| c |>\nThe OP specifically states that `0b1111` is a correct answer.\
    \ He says specifically that he is not allowed to use strings or integers. So I\
    \ don't see how this answer is acceptable.\n<|/ c |>\n<| a |>\n<code>", "    return\
    \ -1 unless $n > $m;\n    my $avg = Math::BigInt->new($n+$m);\n    $avg->bdiv(Math::BigInt->new($m));\n\
    \    $avg->binc();\n    return $avg->as_hex();\n}\n</code>\n<|/ a dscore=4 |>\n\
    <| a tags=bit-manipulation,bitwise-operators,python,c,c++ |>\nIn C++, you can\
    \ use the % and / operators to isolate the bits you want to work with. For example:\n\
    <code>\nn = 110\nm = 50", "    return $n if $n > $m;\n    $n -= $m if $n < $m;\n\
    \    $n += $m;\n    $n |= 0x1;\n    $n -= 0x1 if $n & 0x08;\n    $n -= 0x2 if\
    \ $n & 0x01;\n    $n -= 0x4 if $n & 0x02;\n    $n -= 0x8 if $n & 0x04;\n    return\
    \ $n;\n}", "    $n = ($n <= $m ? $n : -1);\n    $n = 0 + $n + ($n <= $m ? $m :\
    \ -1);\n    return sprintf('%b', $n / 2);\n}", "    $n = $n eq 'inf' ? $n : int($n);\n\
    \    $m = $m eq 'inf' ? $m : int($m);\n    my $s = 0;\n    for my $n ($n .. $m)\
    \ {\n        $s += $n;\n    }\n    $s = $s / $m + ($n == $m ? $n : -1);\n    return\
    \ Math::BigInt->new($s);\n}", "    return -1 unless $n >= $m;\n    my $s = '';\n\
    \    my $i = $n - 1;\n    while($i >= 0) {\n        $s = oct($i%2) + $s;\n   \
    \     $i /= 2;\n    }\n    return oct($n/2) + $s if $n & 1;\n    return oct($n)\
    \ + $s;\n}\n</code>\n<|/ a tags=perl |>\n<| a dscore=2 tags=perl |>\nUsing a combination\
    \ of two variables, you can achieve this in one line\n<code>\nuse 5.010;", '    return
    -1 if $m > $n;', "    return undef if $n < $m;\n    return $n + ($m - $n) * 8;\n\
    }", "    if ($n > $m) {\n\treturn -1;\n    }\n    $n = $m if $n == $m;\n    $n\
    \ = $n - $m if $n == 0;\n    $m = $n - $m if $m == 0;\n    my $div = lc($m / $n);\n\
    \    my $mod = lc($m % $n);\n    $mod .= '0' if $mod != 0; # 0101 mod 1101 is\
    \ 1\n    $div *= 2;\n    $div = oct($div);\n    $div =~ s/0*$n/$div/;\n    return\
    \ \"0b$div\";\n}", "    return -1 if $n < $m;\n    $m -= 1;\n    $n -= $m;\n \
    \   my $s = \"\";\n    while ($n >= $m) {\n        $s += \"0\";\n        $n -=\
    \ $m;\n    }\n    $s += \"1\";\n    $s = Math::BigInt->new(Math::BigInt->new($n),\
    \ $m)->binc()->as_string;\n    $s =~ s/0*$//g;\n    return $s;\n}", "    return\
    \ -1 if $n > $m;\n    my $result = \"\";\n    my $count = 0;\n    while ($n <=\
    \ $m) {\n        $result .= $n & 1 ? \"1\" : \"0\";\n        $n >>= 1;\n     \
    \   $count++;\n    }\n    return \"$result$count\";\n}", "    my @n_to_m = ($n\
    \ .. $m);\n    return 0 if @n_to_m == 0;\n    my $sum = 0;\n    my $remainder\
    \ = 0;\n    for my $i (0..$#n_to_m) {\n        $sum += $n_to_m[$i];\n        $remainder\
    \ += $n_to_m[$i] % 2;\n    }\n    my $avg = $sum / $#n_to_m;\n    return $avg\
    \ >= $m ? $avg : -1;\n}", "    return -1 unless $n >= $m;\n    my $a = $n+1;\n\
    \    my $b = $m+1;\n    return -1 if $b < $a;\n    my $s = \"\";\n    my $r =\
    \ $a/($b-1);\n    my $c = $b*$r;\n    for(1..$c) {\n        $s = $s.'1';\n   \
    \ }\n    if($c < $b) {\n        $s = $s.'0' x $b - $c;\n    }\n    return $s;\n\
    }", '    return -1 if $n > $m;', "    $n >= $m and return;\n    $n = 2 ** $n;\n\
    \    $m = 2 ** $m;\n    $n = $n/$m;\n    $n = int($n*$base);\n    return $n <=\
    \ $m ? $n : -1;\n}", "    if ($n > $m) {\n        return -1;\n    }\n    my($sum,\
    \ $count) = (0, 0);\n    while (my $c = $n++ <= $m++) {\n        $sum += $c;\n\
    \        $count++;\n    }\n    return sprintf(\"0b%b\", $sum/$count); # binary\
    \ notation\n}", "    return -1 unless $n >= $m;\n    my $n1 = $n;\n    my $m1\
    \ = $m;\n    $n -= 1;\n    $m -= 1;\n    $n1 -= 1;\n    $m1 -= 1;\n    my $len\
    \ = 0;\n    for(my $i = $n; $i <= $m; $i++) {\n        my $num = ($i % 2) ? \"\
    0b\" : \"0b1\";\n        $len += length($num);\n    }\n    my $res = \"\";\n \
    \   for(my $i = $len; $i > 0; $i--) {\n        $res .= \"0\" x ($i - 1);\n   \
    \ }\n    $res .= \"0b\" . $res;\n    $res =~ s/0b 0b/\\0/; # drop leading \"0b\"\
    \ from the binary answer\n    $res =~ s/0b1/\\1/; # drop trailing \"0\" from the\
    \ binary answer\n    return $res;\n}", "    my $result = 0;\n    for my $i ( 1\
    \ .. $m ) {\n        $result += $n / $i;\n    }\n    return -1 if $n < $m;\n \
    \   return Math::BigInt $result;\n}", '    my $sum = 0;', '    return -1 if $n
    > $m;', '    my $avg = "";', "    my $a = $n + $m;\n    $a /= 2;\n    $a -= $a\
    \ % 2;\n    return $a | 0;\n}\n</code>\n<|/ a tags=perl |>\n<| c |>\nYou forgot\
    \ about rounding to even numbers. I added `| 0` in my code and it works perfectly.\
    \ Thanks :)\n<|/ c |>\n<| c |>\n: Actually, you forgot about rounding to the nearest\
    \ even number. :-)\n<|/ c |>\n<| c |>\n: Yes, I forgot about that too. I added\
    \ an alternative solution that rounds up to the nearest even number, and included\
    \ a rounding example in the answer.\n<|/ c |>\n<| a tags=perl |>\nTry this:\n\
    <code>", "    return -1 unless $n >= $m;\n    $n -= $m if $n >= $m;\n    $n +=\
    \ $m if $n < $m;\n    $n = 2**$n + (1 << $m - ($n & 1)) - 1;\n    return unpack(\"\
    b*\", pack(\"C*\", $n));\n}", "    $n -= $m;\n    $n += $m if $n > $m;\n    $n\
    \ = (2**$m * $n)/2 if $m > $n;\n    return $n;\n}", "    $m += $n;\n    my $res\
    \ = $n + ($m == $n ? $m : 0);\n    return $res % 2 != 0 ? -1 : $res;\n}", "  \
    \  my $bits = $n * $m;\n    $bits += ($n <= $m) ? 1 : 0;\n    $bits -= 1 if ($bits\
    \ < 0);\n    $bits -= 1 if ($bits == 0);\n    my $x = sprintf \"%b%b\", $bits,\
    \ ($bits >> 1);\n    my $rslt = \"0b\" . $x;\n    return $rslt;\n}", "    my $avg\
    \ = 0;\n    my $i = 0;\n    while ($i < $n || $i < $m) {\n        $avg += $i if\
    \ $i < $n;\n        $avg -= $i if $i < $m;\n        $i++;\n    }\n    return $avg\
    \ / $i if $i != 0;\n    return -1;\n}", "    if ($n >= $m) {\n\treturn -1;\n \
    \   }\n    my($result = 0);\n    my($i) = ($n, $m);\n    while ($i[0] > $i[1])\
    \ {\n\t$result += $i[0];\n\tunshift @$i, $i[1];\n    }\n    $result = $result\
    \ / $i[1];\n    my $resultstr = \"\";\n    my $temp = $result;\n    $temp = $temp\
    \ + 1;\n    while ($temp != 0) {\n\t$resultstr .= $temp & \"0\";\n\t$temp = $temp\
    \ / 2;\n    }\n    return $resultstr;\n}", "    if ($m > $n) {\n        return\
    \ -1;\n    }\n    $m *= 10;\n    $m++;\n    return \"0b\".join('',\n        map\
    \ {\n            if ($_ eq '1') {\n                chr($n);\n            }\n \
    \           else {\n                chr($n - $m);\n            }\n        } 0..($n-1)\n\
    \    );\n}", "    my $avg = int(($n + $m) / 2) + ($n <= $m ? 0 : $m);\n    my\
    \ $res = 0;\n    my $bit = 0;\n    while ($avg =~ /1/) {\n        $res += $bit;\n\
    \        $bit += 1;\n    }\n    return $res == 0 ? -1 : \"0b\" . $res;\n}", " \
    \   if ($n > $m) {\n        return -1;\n    }\n    $n = ($n - $m) / 2;\n    $n\
    \ = 0 while $n % 2;\n    return sprintf \"%b%b\", $n, $m;\n}", '    my $r = 0;',
  "    $n += $m;\n    $n -= $m == 0 ? 1 : 0; # Handle corner case\n    return $n %\
    \ 2 ? oct($n >> 1) and \"0b\" . $n : \"0b\" . $n;\n}", "    my $num_left = $n;\n\
    \    my $num_right = $m;\n    my $sum = @{ $num_left + 1 } + @{ $num_right + 1};\n\
    \    my $left_count = 0;\n    my $right_count = 0;", "    return -1 unless $n\
    \ >= $m;\n    return undef unless $n <= $m;\n    $n++; $m--;\n    $n = hex($n);\n\
    \    $m = hex($m);\n    $m += $n << 1; $m += $n >> 3;\n    return $m >> 1;\n}",
  "    my $avg = ($n >> 1) + ($n & 1) + ($m >> 1) + ($m & 1);\n    return -1 unless\
    \ $avg >= 0;\n    return $avg;\n}\n</code>\n<|/ a tags=python,python-2.7 |>\n\
    <| c |>\nI like this idea of calculating a binary representation of a decimal\
    \ value but how does it generalize to the other values I have?\n<|/ c |>\n<| c\
    \ |>\nI missed the part where you said the integers were positive and assumed\
    \ that `round` was always used. I've updated my answer to use `intdiv`.\n<|/ c\
    \ |>\n<| a dscore=1 tags=python,python-2.7 |>\nYou could do something like this\
    \ using list comprehensions:\n<code>\ndef avg (n, m):\n    sum = 0\n    sum =\
    \ (n//2) + (m//2)\n    sum = (n/2) + (m/2) + (sum/4)\n    if sum < 2:\n      \
    \  return \"-1\"\n    return str(bin(sum)[2:])\n</code>\nThis works because Python\
    \ does integer division, so if you divided by 2 then rounded up or down, you'll\
    \ get the same number.\n<|/ a |>\n<| c |>\nThis will not give the correct answer\
    \ if the input is `avg(1, 5)`\n<|/ c |>\n<| a dscore=1 |>\nI do not know whether\
    \ it is correct or not, but i used this and it worked.\n<code>\ndef avg (n, m):\n\
    \    sum = 0\n    sum = (n//2) + (m//2)\n    sum = (n/2) + (m/2) + (sum/4)\n \
    \   if sum < 2:\n        return \"-1\"\n    return str(bin(sum)[2:])", "    return\
    \ -1 if $n <= $m;\n    my $avg = round($n / ($m + 1));\n    return sprintf(\"\
    0b%b\", (2**$avg - 1));\n}", "    $n += $m if $n >= $m;\n    $n -= $m if $n <\
    \ $m;\n    \n    return $n / $m if $n / $m >= 1.0;\n    return -1;\n}", "    $n\
    \ =~ s/^(\\d+)/$1/;\n    $m =~ s/^(\\d+)/$1/;\n    return int($n . $m) / 2 if\
    \ $n > $m;\n    return -1;\n}", "    return -1 if ($n < $m);\n    my $res = 0;\n\
    \    for (my $i = $m; $i >= $n; $i--) {\n        $res += $i;\n        $res +=\
    \ 1; \n    }\n    my $str = oct($res);\n    if ($str =~ s/^0+//) {\n        $str\
    \ = \"0b\" . $str;\n    }\n    return $str;\n}", "    my $result;\n    my $remainder;\n\
    \    my $quotient;\n    my $i;\n    my $zeros = 0;\n    my $ones = 0;\n    my\
    \ $count = 0;", "    my $ret = $n - $m if $n > $m;\n    return $ret == -1 ? $ret\
    \ : pack 'b', $ret / ($n - $m);\n}", "    $n += $m if $n > $m;\n    $m = $n +\
    \ $m if $n < $m;\n    return $n if $n == $m;\n    return $n;\n}", "    return\
    \ -1 unless $n > $m;\n    my($a, $b, $c, $d);", "    my $sum = 0;\n    my $i =\
    \ 0;\n    while(1) {\n        die \"n must be less than m\" unless $n <= $m;\n\
    \        $sum += $n if ($n <= $m and $i++ < $m);\n        $n++;\n        $m--;\n\
    \    }\n    my $ans = $sum / $i;\n    my $bin = Math::BigRat->new($ans)->bin;\n\
    \    return $bin;\n}\n</code>\n<|/ a |>\n<| a dscore=1 tags=perl,math |>\n<code>\n\
    my $n = <STDIN>;\nmy $m = <STDIN>;\nmy $sum = 0;\nmy $count = 0;", "    my $result\
    \ = '';\n    my $last_digit;\n    my $num;\n    for (my $i = $n; $i <= $m; ++$i)\
    \ {\n        $num ^= $i;\n        ++$result;\n        $result .= $last_digit if\
    \ $last_digit ne 0;\n        $last_digit = $num % 2;\n        $num = int($num\
    \ / 2);\n    }\n    return $result if $result != 1;\n    return -1;\n}", "   \
    \ return $m == $n ? $m : -1 if $n > $m;\n    my($i, $j, $sum, $remainder, $carry);",
  "    my $result = 0;\n    for (my $i = $n; $i <= $m; $i++) {\n        $result +=\
    \ $i;\n    }\n    $result -= $n;\n    my $bin = pack \"B*\", $result;\n    my\
    \ $rounded = substr($bin, 0, $m);\n    return $rounded;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis doesn't work for negative numbers, though.\n<|/ c |>\n<| c\
    \ |>\nI did actually add the comment for negative numbers.  My apologies.  Your\
    \ solution is better, though.\n<|/ c |>\n<| c |>\nOh, I didn't even notice the\
    \ negative number requirement. I think a `return` statement should fix that\n\
    <|/ c |>\n<| c |>\n: It works, but in such a way that I think is less intuitive\
    \ than mine.  I haven't spent much time on it though.\n<|/ c |>\n<| c |>\nI agree\
    \ with you. By the way, I wrote an answer which only uses 1 line of Perl code.\
    \ It may be interesting to compare that with yours or mine. I'd love to hear from\
    \ you: how does it compare with yours?\n<|/ c |>\n<| a tags=algorithm,perl,bit-manipulation\
    \ |>\nHere is a solution which only uses 1 line of Perl code. It may not be the\
    \ most elegant or efficient but I don't see much room for improvement.\n<code>\n\
    my $n = 10;\nmy $m = 20;", "    my $avg = int $m / $n;\n    return $avg == -1\
    \ ? -1 : oct($avg);\n}", "    if ($m > $n) {\n        my $round = $m - ($m % $n);\n\
    \        my $mask = (2 ** $round) - 1;\n        $mask = ~$mask;\n        $mask\
    \ >>= 1;\n        $n = 0 if $n & $mask;\n        $m = $n if $m & $mask;\n    }\n\
    \    $m -= $n;\n    $n &= ~($m << 1);\n    $m &= ~($n << 1);\n    $m -= 1 unless\
    \ $m;\n    $n = oct($n);\n    $m = oct($m);\n    $n .= $m unless $n eq $m;\n \
    \   return $n;\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\nI figured out a similar\
    \ problem which was easier to solve.  \nYou want to take a number x which is the\
    \ average of some numbers from 1 to n, inclusive.\nYou want to round x to the\
    \ nearest integer and turn it into a binary string in base 2.\nThe easiest way\
    \ I found to do this was:\n<code>\n// $x is the average of the numbers 1-n\n$x\
    \ = int($x/$n)+1; \n$x = $x/$n;\n$x = sprintf('%0'.$n.'b',$x);\n</code>\n<|/ a\
    \ tags=perl,binary dscore=2 |>\n<| c |>\nThis does not give the correct answer\
    \ for n=10\n<|/ c |>\n<| a tags=perl,binary dscore=2 |>\nThe simplest solution\
    \ in Perl is just to print out in binary instead of decimal.\n<code>\nmy $n =\
    \ 9\nmy $m = 16", "    $n += $m;\n    $n -= $m;\n    $n = 1 if $n < 0;\n    my\
    \ $x = $n;\n    $x >>= 1;\n    return $x & 1;\n}\n</code>\n<|/ a tags=binary,perl,octal\
    \ |>\n<| a tags=binary,perl,octal |>\nAn easy way to compute the average of a\
    \ series of numbers from min to max (inclusive) is:\n<code>", "    my $total =\
    \ 0;\n    my $j = 0;\n    my $k = $n;\n    while (--$k) {\n        $total += $j;\n\
    \        $j += $k;\n    }\n    $total = $total / $m;\n    return $total == $total\
    \ ? oct($total) : -1;\n}\n</code>\n<|/ a tags=perl |>\n<| a dscore=2 |>\nHere's\
    \ another option:\n<code>", "    my $ret = $n + $m;\n    return $ret if $n > $m;\n\
    \    return -1 if $n == $m;\n    return sprintf(\"0b%b\", $ret);\n}", "    my\
    \ $s = 0;\n    for(my $i = $m; $i <= $n; $i++) {\n        $s += $i;\n    }\n \
    \   return ($s >> 1) if ($s % 2 == 1);\n    return -1;\n}\n</code>\n<|/ a tags=perl,integer\
    \ dscore=1 |>\n<| a |>\n<code>\nfunction avg ($a, $b) {\n    $avg = 0;\n    for(my\
    \ $i = $a; $i <= $b; $i++) {\n        $avg += $i;\n    }\n    return $avg;\n}\n\
    </code>\n<|/ a tags=perl,integer dscore=0 |>\n<| c |>\nWhile this code snippet\
    \ may solve the question, [including an explanation](http://meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion.\n<|/ c |>\n<| a tags=perl,integer |>\n<code>\n\
    use strict;", "    $n =~ s/^0b//;\n    $m =~ s/^0b//;\n    return -1 if (($n -\
    \ $m) < 0);\n    return sprintf \"0b%b\", $n + $m / ($n - $m) * 2;\n}", "    if\
    \ ($n > $m){\n\treturn -1;\n    }\n    return sprintf(\"%b\", $n + ($m-1) - $n+1);\n\
    }", "    my $c = @$n < @$m ? @$m : @$n;\n    my $sum = 0;\n    foreach my $i (0\
    \ .. $c - 1) {\n        $sum += $n->[$i];\n    }\n    return $sum / $c;\n}", " \
    \   my $avg = intdiv($n, $m, 0, 1);\n    # Handle negative averages differently\
    \ than positive averages.\n    $avg =~ s/^-(?=\\d)//; # Remove leading negative\
    \ signs\n    $avg =~ s/^0b//;   # Remove leading \"0b\" prefix\n    return $avg;\n\
    }", "    return -1 if $n > $m;\n    $n = $n if $n == 1;\n    $m = $m if $m ==\
    \ 1;\n    my $result = $n + ($m - $n)/2;\n    my $s = Math::BigInt->new($result)->as_str();\n\
    \    return $n if $s eq '';\n    $s =~ s/0*$//;\n    Math::BigInt->new($s)->bin();\n\
    }", "    my($sum, $half, $n0, $m0, $n);\n    my($zero, $one, $ten, $five, $three);",
  "    return -1 if $n > $m;\n    my $base = ($n << 1) + $m;\n    my $binary = join\
    \ '', map { chr $base % 2 } 0..$n-1;\n    my $remainder = ($base >> 1) + $m;\n\
    \    $binary .= pack 'S', $remainder;\n    return $binary;\n}", "    if($m >=\
    \ $n) {\n        return -1;\n    }\n    my($result) =  '0b';\n    $result += sprintf(\"\
    %b\", $n++);\n    while($n <= $m) {\n        $result += sprintf(\"%b\", $n++);\n\
    \    }\n    my $bin_string = $result;\n    $bin_string =~ tr/0b/0/r;\n    return\
    \ $bin_string;\n}", "    return $n if $n < $m;\n    $n = 0 while $n < $m;\n  \
    \  my $m1 = $n - $m;\n    my $r = ($n % 2 == 0) ? \"0b\" . str_pad($n + 1, 2,\
    \ \"0\") : \"0b\";\n    $r .= $m1 . \"0b\";\n    $r .= str_pad($m1 + 1, 2, \"\
    0\") . \"0b\";\n    return $r;\n}", "    my $sum = 0;\n    for(my $i = $n; $i\
    \ <= $m; $i++){\n\t$sum += $i;\n    }\n    return $sum / $m\n}", "    return -1\
    \ if $n > $m;\n    return -1 if $n == $m;\n    return \"0b\" . oct($n + ($m -\
    \ $n) / 2) if ($n > $m);\n    return \"0b\" . oct(-$n + ($n - $m) / 2) if ($n\
    \ < $m);\n}", "    $m > $n and return -1 unless $n >= $m;\n    $n + ($m+1-$n)/2;\n\
    }", "    my $c = 1;\n    my $s = \"\";\n    \n    for(my $i = 1; $i < $n; $i++)\
    \ {\n        my $m = $i % $m;\n        $c = $c + ($m ? 1 : 0);\n        $s .=\
    \ \"0\" if ($c & 1);\n        $c = ($c - $m) / $m;\n    }\n    return $m ? $s\
    \ : \"-1\";\n}", "    return -1 unless $n < $m;\n    return $n if $n <= $m;\n\
    \    return $n if $m <= $n;\n    my($sum) = $n + ($m - $n + 1);\n    my($remainder)\
    \ = $m - ($sum - $n);\n    $remainder = hex($remainder) if $remainder > 0xff;\n\
    \    my $base = 1;\n    my $remainder_bin = \"0b\"; # 0b0\n    my $sum_bin = \"\
    0b\"; # 0b0\n    my $last_remainder = $remainder;\n    for(my $i = 0; $i < $n;\
    \ $i++) {\n        my $next = $base + $i;\n        $remainder = $remainder - $next;\
    \ # $remainder - $next\n        $remainder_bin = sprintf(\"%02d\", $remainder);\n\
    \        $sum_bin .= $remainder_bin;\n        $last_remainder = $remainder;\n\
    \        $base = $next;\n    }\n    return sprintf(\"0b%s\", $sum_bin);\n}", " \
    \   my(@ret) = 0;\n    for(my $i = $n; $i <= $m; $i++) {\n        push(@ret, $i,\
    \ \"\");\n    }\n    my($ret) = pop(@ret);\n    $ret =~ s/(\\d)(?!$)/oct($1)/ge;\n\
    \    push(@ret, $ret);\n    return (join(\"0b\", @ret));\n}\n</cell>\n<cell>",
  "    my $avg = ($n + $m)/2;\n    return $avg == $m ? $n : -1;\n}\n</code>\n<|/ a\
    \ dscore=0 |>\n<| c |>\nWhy does this have 3 upvotes?  How does it answer the\
    \ question?\n<|/ c |>\n<| c |>\nIt is a functional and efficient solution, no\
    \ need for an explanation, I added some comments.\n<|/ c |>\n<| c |>\nI added\
    \ a couple of comments about the functional nature of the problem, and added an\
    \ explanation of why `Math::BigInt` might be preferable to `Math::BigFloat`.\n\
    <|/ c |>\n<| c |>\nYes, I did not see this question before I submitted mine. I\
    \ added some comments and an explanation of why `Math::BigInt` is preferable to\
    \ `Math::BigFloat`.  I did not intend to downvote, just in case it was you.\n\
    <|/ c |>\n<| c |>\nI like that explanation.  Thanks.  But why did you use `Math::BigInt`\
    \ at all?  Wouldn't `return $avg == $m ? $n : -1;` work just as well?  Why use\
    \ `Math::BigInt` at all?\n<|/ c |>\n<| a tags=integer,perl,perl5.8 |>\nThis code\
    \ will output the binary value from two integers entered by the user using a very\
    \ simple subroutine.\n<code>\nuse strict;\nuse warnings;", "    my ($i, $round,\
    \ $temp);\n    if ($n >= $m) {\n        return -1;\n    }\n    $round = int( ($n+$m)/2);\n\
    \    $temp = $n / 2;\n    for($i = 0; $i <= $round; $i++) {\n        $temp /=\
    \ 2;\n    }\n    $temp = oct($temp);\n    return $temp;\n}", "    \n    if ($n\
    \ > $m) {\n        return -1;\n    }\n    \n    my($sum, $count, $half, $remainder)\
    \ = (0, 0, 0, 0);\n    \n    while ($n >= $m) {\n        $sum += $n;\n       \
    \ $count++;\n        $half++;\n        $n -= $m;\n    }\n    \n    $remainder\
    \ = $sum - $n;\n    $half = $half * 2 - 1;\n    \n    my $bin = $half;\n    \n\
    \    $bin = '0b' . substr($bin, 0, length($bin) - $half + 1);\n    \n    return\
    \ ($bin, $remainder / $count, $sum / $count);\n}", "    \n    return -1 if $n\
    \ > $m;", "    my $s = ''; \n    for my $i ( 0 .. $n ) {\n        $s .= sprintf(\"\
    0b%b\", $i);\n    }\n    if ( $n >= $m ) {\n        return -1;\n    }\n    return\
    \ $s;\n}\n</cell>\n<cell>", "    my $avg = int(($n + $m) / 2);\n    return -1\
    \ if $avg > $m;\n    return 0b$avg >> 1 & $avg;\n}", "    if ($n >= $m) {\n  \
    \      die \"n must be smaller than m\" if $n < $m;\n        my $ret = $n;\n \
    \       $ret .= \"b\" x ($n - $m);\n        $ret .= \"0\" x $m;\n        return\
    \ $ret;\n    }\n    return -1;\n}\n</code>\n<|/ a dscore=2 tags=perl |>\n<| a\
    \ dscore=1 |>\nFor a simpler approach, using only base conversion and no string\
    \ parsing:\n<code>", "    if ($n > $m) {\n        return -1;\n    }\n    $sum\
    \ = 0;\n    for(my $i = $n; $i <= $m; $i++) {\n        $sum += $i;\n    }\n  \
    \  $sum *= 2;\n    $sum = Math::Math::floor($sum);\n    return Math::Math::bin($sum);\n\
    }", "    my $round;\n    my $n_diff = $n - $m;\n    if ($n_diff < 0) {\n     \
    \   $round = $n_diff * -1;\n    } else {\n        $round = $n_diff;\n    }\n \
    \   return $round;\n}\n</code>\n<|/ a tags=rounding,perl,bit-manipulation |>\n\
    <| c |>\nYes, I did. But it didn't work. Can you please help me?\n<|/ c |>\n<|\
    \ c |>\nThis code does work. Can you tell me how it didn't work for you?\n<|/\
    \ c |>\n<| c |>\nAh! I missed that. Thanks for pointing that out\n<|/ c |>\n<|\
    \ c |>\nWhat if n is greater than m? `0b1011001100` = `(2^7 + 2^5 + 2^3 + 1) /\
    \ 2` ? It should be `0b110010001`\n<|/ c |>\n<| c |>\n: I edited the answer to\
    \ handle this case.\n<|/ c |>\n<| a dscore=4 |>\nThe following will give you the\
    \ correct binary result for positive integers between 0 and 2^(32-1)-1 (including\
    \ the integer itself):\n<code>\nmy $result = Math::BigInt->new($n);\n$result->bmod($m);\n\
    my $bin = $result->as_int()->as_oct();\n</code>\n<|/ a tags=rounding,perl,bit-manipulation\
    \ |>\n<| c |>\nIf `n` is greater than `m`, then `$bin = $result->as_int()->as_oct()`\
    \ will return `0b11111111111111111111111111111111`.\n<|/ c |>\n<| c |>\nI know.\
    \ I had been using this solution previously, but got carried away with other things.\
    \ But this should work, I guess.\n<|/ c |>\n<| a |>\nA general solution (not just\
    \ for integers):\n<code>", "    return -1 if ($n > $m);\n    my $ns = $n .. $m;\n\
    \    return join '', map { sprintf '%o', int($_ * 2) } $ns[0 .. $#ns - 1];\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\n\"*Round the answer to the nearest integer\
    \ and convert that to binary*\"\n<|/ c |>\n<| c |>\nThat's why I started the answer\
    \ with `\"0b11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "    if ($n < $m) {\n\treturn -1;\n    }\n    my $result = 0;\n    my $i = 0;\n\
    \    while ($i <= $m) {\n\t$result += $n;\n\t$i += 1;\n    }\n    return sprintf\
    \ \"0b%b\\n\", $result;\n}", "    if ($n >= $m) {\n        return -1;\n    }\n\
    \    my $ns = $n .. $m;\n    my $x = $ns / ($ns - $m);\n    return sprintf(\"\
    %b\", round($x * 2**$#ns));\n}\n</code>\n<|/ a tags=algorithm,binary,math,perl\
    \ dscore=2 |>\n<| c |>\nThis doesn't take into account that \"rounding to 1 digit\"\
    \ would give the wrong answer.\n<|/ c |>\n<| c |>\nWhat is the meaning of the\
    \ return line in the subroutine rounded_avg? It does not return anything.\n<|/\
    \ c |>\n<| c |>\n, it's a void return; it simply returns nothing. `sub foo {`\
    \ means `subroutine foo() {`.\n<|/ c |>\n<| c |>\n: It doesn't return anything,\
    \ it just returns the number. Perl functions (subroutines) return values.  They\
    \ return the value of the last expression evaluated in the subroutine.  Here,\
    \ `$x` is the value returned by `round($x * 2**$#ns)`; and `sprintf` then turns\
    \ that into a string containing only the digits after the decimal point.\n<|/\
    \ c |>\n<| c |>\nthanks very much for explaining this. I see my mistake.\n<|/\
    \ c |>\n<| a dscore=2 |>\nFor those who don't like using Math::Big because they\
    \ don't like installing modules just for this\n<code>", "    return -1\n     \
    \   if $n < $m;", "    my $bin = bin($n).$bin($m);\n    $bin =~ s/([1-9])(?!\\\
    d)//g;\n    return $bin if $bin =~ /^(.*1..)00$/;\n    return -1;\n}", "    my\
    \ $i = $n + $m;\n    if ($i >= $m) {\n        return -1;\n    }\n    $i -= 1;\n\
    \    my $rem = $i;\n    while (1) {\n        if ($rem == 0) {\n            return\
    \ $i;\n        }\n        $rem = $rem / 2;\n        last if $rem < $n;\n     \
    \   $i = $i + 1;\n    }\n}", "    $n >= $m and return -1 or return \"0b\" . \n\
    \        sprintf(\"%b\", $n) . sprintf(\"%b\", $m);\n}", "    my $sum = 0;\n \
    \   my $cnt = 1;\n    while($n <= $m){\n        $sum += $n;\n        $n += $cnt;\n\
    \        $cnt += 1;\n    }\n    if($n <= $m){\n        $sum += $n-1;\n    }\n\
    \    return sprintf \"%b%b\", $sum/($m+1), $sum%($m+1);\n}", "    return -1 unless\
    \ $m > $n;\n    return -1 if $n == $m;\n    my $sum = $n;\n    for (my $i = $m;\
    \ $i lt $n; $i++) {\n        $sum = $sum + $i;\n    }\n    return $sum/($m - $n\
    \ + 1);\n}", "    $n = $n || 1;\n    $m = $m || $n;", "    $n = 2 ** $n; $m =\
    \ 2 ** $m;\n    my $s = $n + $m;\n    my $b = $s / $n; $b =~ s/(10*$)0(.*)/$1$2/g;\n\
    \    return $b;\n}", "    my $avg = sprintf('%b', int($n + ($m / 2)));\n    return\
    \ -1 if $n >= $m;\n    return $avg;\n}", "    if ($m == 0) {\n        return -1;\n\
    \    }\n    return Math::BigInt->new(bin($n -> num_binary() + $m -> num_binary()))->as_hex()->string();\n\
    }", "    my $a = 0;\n    for(my $i = $n; $i <= $m; $i++) {\n        $a += 2 **\
    \ $i;\n    }\n    return -1 if $n < $m;\n    $a *= 2;\n    my $b = ($a & 1);\n\
    \    $a >>= 1;\n    $a += $b;\n    return $a > 1 ? \"$a\" : \"$a\";\n}", "   \
    \ $n += $m;\n    if ($n > $m) {\n        return -1;\n    }\n    my $res = Math::Round::round($n,\
    \ 8);\n    my $bin = $res->bdec();\n    my $len = length($bin);\n    my $mask\
    \ = 0xF << (8 - $len);\n    if ($bin & $mask) {\n        return -1;\n    }\n \
    \   return $bin;\n}", "    return -1 if $n <= $m;\n    my $s = '';\n    for (my\
    \ $i = $n; $i <= $m; $i++) {\n        $s .= &bits($i, 2);\n    }\n    return \"\
    $s\";\n}", "    \n    return -1 if $n > $m;\n    my $num_int = $n - 1;\n    my\
    \ $num_str = Math::BigInt->new($num_int);\n    my $num_int = Math::BigInt->new($m\
    \ + ($num_str - $num_str->copy()->bmod(($num_str->copy()->bint() >> 1) // $num_str->copy()->bint())));\n\
    \    my $num_str = Math::BigInt->new($num_int);\n    my $num_str = Math::BigInt->new($num_str->copy()->binc());\
    \ \n    $num_str->bmod($num_str->copy()->bmod(($num_str->copy()->bint() >> 1)\
    \ // $num_str->copy()->bint()));\n    return $num_str->binc() eq 0 ? '0b0' : $num_str->binc();\n\
    }", "    return -1 unless $n > $m;\n    # Convert to binary and truncate\n   \
    \ my($bin) = sprintf('%.#011b', $n + ($m <= $n ? -$m : 0));\n    # Round up to\
    \ the first 1\n    my $bin = ~/^1/;\n    # Convert to decimal\n    return sprintf('0b%b',\
    \ $bin / 2);\n}", "    $n =~ s/^0*//;\n    $m =~ s/^0*//;\n    my $s = $n + ($n\
    \ - $m);\n    my $l = $s * 2;\n    return oct($l);\n}", "    \n    if ($n > $m)\
    \ {\n        return -1;\n    }\n    \n    my $avg = (($n - $m) + $m) / 2;\n  \
    \  \n    return oct($avg);\n}", "    if ($m > $n) {\n        -1;\n    }\n    $n\
    \ -= 1;\n    $m--;\n    $n *= 2;\n    $m *= 2;\n    my $remain = $m % 2;\n   \
    \ my $result = $n / 2;\n    $result -= $remain;\n    my $answer = Math::BigInt->new($result);\n\
    \    $answer->binop('+', $remain);\n    return $answer;\n}", "    $n -= 1;\n \
    \   $m -= 1;\n    return $n / $m if $n / $m == 1;\n    return -1 if $n / $m ==\
    \ 0;\n    return int($n / $m) * 2 + ($n - (int($n / $m) * int($m / $m)));\n}\n\
    </code>\n<|/ a tags=perl,math,binary |>\n<| c |>\nI thought the OP wanted to round\
    \ up if the number was evenly divisible.\n<|/ c |>\n<| c |>\nYes, that's why I\
    \ added the comment, stating how to round up. Also I mentioned that \"round up\"\
    \ means to add 1 to each number in the range. Rounding down would mean to add\
    \ 0.\n<|/ c |>\n<| c |>\nOh, I missed that line. Sorry.\n<|/ c |>\n<| c |>\nI\
    \ remember doing something very similar once to solve a math problem.  I guess\
    \ I got bored. :)\n<|/ c |>\n<| c |>\nNice solution, I like it.  It makes me think\
    \ of things a bit differently but it is still a very interesting problem.  It\
    \ would be cool if you could post some code for the solution you just posted.\n\
    <|/ c |>\n<| a |>\nIf you have Math::BigFloat installed, you can do the following:\n\
    <code>", "    return -1 if $n < $m;\n    my $result = \"0b\" . Math::BigInt->new(int($n)\
    \ - int($m))->as_oct(oct(10))\n                        . \"0b\" if (int($n) -\
    \ int($m)) < 0;\n    $result;\n}", "    my $avg = 0.0;\n    my $sum = 0;\n   \
    \ \n    for (my $i = $n; $i <= $m; $i++) {\n        $sum += $i;\n    }\n    \n\
    \    $avg = round($sum / $m); # Round to nearest integer\n    $avg = ($avg + 1)\
    \ * '0'; # Convert to binary\n    \n    return $avg if $avg =~ /^0\\.$/; # Check\
    \ if decimal is 0\n    \n    return -1;\n}", "    return -1 unless $n > $m;\n\
    \    return \"0b$n\" x ($m - $n + 1)\n} ", "    my $sum = ($n + $m) / 2;\n   \
    \ if($sum == $n || $sum == $m){\n        return $sum;\n    }else{\n        return\
    \ -1;\n    }\n}", "    my $a = 0;\n    my $b = $n;\n    while(--$b >= 0) {\n \
    \       $a += $b**2;\n    }\n    return $a / $m+1 unless $b > $m;\n    return\
    \ -1;\n}", '    my($result) = Math::BigInt->new($n);', "    if ($n < 0) {\n  \
    \      return -1;\n    }\n    elsif ($m < 0) {\n        return -1;\n    }\n  \
    \  elsif ($n == $m) {\n        return \"0b$n\";\n    }\n    elsif ($m > $n) {\n\
    \        return -1;\n    }\n    my $bits = \"\";\n    for (my $i = 0; $i < $n;\
    \ $i++) {\n        $bits .= \"1\" if ($i & 1);\n    }\n    $bits .= \"0\" * ($n\
    \ - $i);\n    $bits .= \"1\"; \n    $bits .= \"0\" * ($m - $n); \n    $bits .=\
    \ \"1\"; \n    return \"0b$bits\";\n}", "    if ($n < $m) {\n        $n = $m;\n\
    \        $m = $n;\n    }\n    my $result = 0;\n    my $i;\n    for ($i = 0; $i\
    \ <= $m; $i++) {\n        $result += (2**$i) * $n;\n    }\n    return $result\
    \ >= $n ? $result - 2**($i) : -1;\n}", "    my $s = '';\n    my $i = 0;\n    while(my\
    \ $n = $n+$m) {\n        $s = $n.\"0\" if ($s eq '');\n        $s = \"$s$b\" if\
    \ ($i<10);\n        $i++;\n    }\n    if ($n >= $m) { return $s }\n    return\
    \ -1;\n}", "    my $sum = 0;\n    for (my $i = $n; $i <= $m; $i++) {\n       \
    \ $sum += $i;\n    }\n    my $avg = sprintf(\"%.0f\", $sum / $m);\n    if ($n\
    \ > $m) {\n        return -1;\n    }\n    return sprintf(\"%b\", $avg);\n}", " \
    \   my $remainder = $n - $m;\n    $remainder += $m if $n > $m;\n    $remainder\
    \ *= 2;\n    $remainder -= 1;\n    return $remainder;\n}", "    my $r  = $m /\
    \ 2;\n    my $k = $r - int($r);\n    if ($k <= 0){\n        return \"0b0\";\n\
    \    }\n    my $ns = $n % $k;\n    if ($ns < 0) {\n        return \"0b1\";\n \
    \   }\n    my $h = $k ^ 1;\n    my $ns = $ns % $h;\n    return $ns ? \"0b\" .\
    \ bin($ns ^ 1) : \"0b0\";\n}", "    my $result;\n    if ($n > $m) {\n        return\
    \ -1;\n    }\n    my $n = int($n); my $m = int($m);\n    my $i = 0;\n    while\
    \ (1) { # We always add the last digit (we know it's the rightmost one)\n    \
    \    $result .= $bin[$i];\n        if ($i++ == $m) { # When we reach the end of\
    \ the range, stop\n            break;\n        }\n    }\n    $result = 0b$result;\
    \ # We want to keep it as binary, so convert the string back to int\n    $result\
    \ = int($result + 0b1); # Add the last digit\n    return $result;\n}", "    my\
    \ $num = ($n - $m + 1) / 2;\n    return $num if $num * 2 >= $m;\n    return -1;\n\
    }", "    $n = 0+$n;\n    $m = 0+$m;\n    if ($n <= $m) {\n        $m = $n;\n \
    \   }\n    my $s = $m/4;\n    $m = ($m - ($m%4)) / 4;\n    my $c = 0;\n    while\
    \ ($n>0) {\n        $c = $c + (($n % 2)*3);\n        $n = int($n/2);\n    }\n\
    \    $c = $c + (($m % 2)*3);\n    $m = int($m/2);\n    while ($m>0) {\n      \
    \  $c = $c + (($n % 2)*3);\n        $m = int($m/2);\n    }\n    my $result = 0;\n\
    \    while ($s>0) {\n        $result = $result + (($c % 2)*3);\n        $c = int($c/2);\n\
    \    }\n    $result = $result + (($c % 2)*3);\n    $result = sprintf(\"%b\", $result);\n\
    \    return $result;\n}", "    return -1 unless $n < $m;\n    my($i, $j, $sum);",
  "    my $result = 0;\n    my $i;\n    \n    for ($i = 0; $i <= $m; ++$i) {\n   \
    \     if ($i == $n) {\n            $result = $i if ($i == $n);\n            return\
    \ -1;\n        }\n        $result |= ($i & 1) << $i;\n    }\n    return $result;\n\
    }\n</code>\n<|/ a dscore=2 tags=algorithm,perl,python,perl-data-structures |>\n\
    <| c |>\nThanks for your answer. It seems to me that this solution does not guarantee\
    \ an integral value.\n<|/ c |>\n<| c |>\n, no, this algorithm guarantees an integral\
    \ result.\n<|/ c |>\n<| c |>\nAh yes now I see it :) I had just seen that the\
    \ solution does not do rounding, and thought that it would round the answer to\
    \ the nearest integer. Thanks for pointing this out. I will update the solution.\n\
    <|/ c |>\n<| c |>\n, I have updated my solution. The code now guarantees an integral\
    \ result.\n<|/ c |>\n<| a tags=algorithm,perl,python,perl-data-structures |>\n\
    This is a very simple one-line solution in Perl, which assumes you've done rounding\
    \ to the nearest integer. \n<code>\nmy $x = $n + ($m-1);\nmy $i = int($x/($m+1));\n\
    return $i if $x == $i*($m+1);\nreturn -1;\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    This is equivalent to my algorithm, it just doesn't handle negative numbers.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>\ndef avg_range(n,m):\n  n1 = n+1\n  m1 = m+1\n\
    \  while (n<m1):\n    if n<m1:\n      m1=m1-1\n      n1=n1-1\n    else:\n    \
    \  n1=n1-1\n      m1=m1-1\n  return n1+1\n</code>\nThis algorithm works by finding\
    \ n+1 by taking the highest bit of n and adding it to n+1. This ensures that any\
    \ number between n+1 and m is an integer and that n+1 is an integer multiple of\
    \ m+1.\n<|/ a tags=algorithm,perl,python,perl-data-structures |>\n<| c |>\nThanks\
    \ for your answer. It seems to me that this solution does not guarantee an integral\
    \ value.\n<|/ c |>\n<| a |>\n<code>\ndef int_avg(n, m):\n    return int(n * (m\
    \ - n + 1)/m)\n</code>\n<|/ a tags=algorithm,perl,python,perl-data-structures ",
  "    my $sum = 0;\n    for(my $i = $n; $i <= $m; $i++) {\n        $sum += $i;\n\
    \    }\n    my $num = $sum / 2;\n    if ($num == $sum) {\n        my $temp = Math::BigInt->new($num);\n\
    \        $temp = $temp->binrepr(1);\n        $temp =~ s/0b//g;\n        return\
    \ $temp;\n    } else {\n        return -1;\n    }\n}", "    my $avg = int(($n\
    \ - $m) / 2) * 2 + int($n / $m);\n    if ($n >= $m) {\n        return -1;\n  \
    \  }\n    $avg &= $BITS;\n    return \"0b$avg\";\n}", "    my $i = $n;\n    my\
    \ $sum = 0;\n    while ($i <= $m) {\n        $sum += $i;\n        $i++;\n    }\n\
    \    my $rounded_avg = Math::BigInt->new($sum / $m)->bfloor;\n    return $rounded_avg\
    \ eq $n ? -1 : $rounded_avg;\n}\n</code>\n<|/ a dscore=0 tags=binary,perl,integer\
    \ |>\n<| c |>\nI'm sorry but I don't understand. You're adding up all the numbers\
    \ from n-1...n and dividing by m... what's the point?\n<|/ c |>\n<| c |>\nYou\
    \ were doing it right. But in your solution you were rounding each number after\
    \ it had been summed up. Because you didn't round the average you were just looking\
    \ for the average of all the numbers from n through m. Because you didn't round\
    \ the numbers then if you had a situation where n=10, m=5, your average would\
    \ actually be 3.\n<|/ c |>\n<| c |>\nSo if you want your average to come out rounded\
    \ you have to round the sum first. How do I know when to round the sum and when\
    \ to round the average?\n<|/ c |>\n<| a |>\nAs a one-liner:\n<code>\nperl -e 'print\
    \ round(m/10+1/)*10+m/10+1/'\n</code>\n<|/ a dscore=0 tags=binary,perl,integer\
    \ |>\n<| a tags=binary,perl,integer dscore=0 |>\n<code>\nmy $n = 10;\nmy $m =\
    \ 12;\nmy $result= $n + ($m*10);\nmy $average = ($result/$m)*10;\nmy $result =\
    \ $result+$average;\nmy $average = $average/10;\n$result= $result/10+$average;\n\
    print $result;\n</code>\n<|/ a |>\n<| a tags=binary,perl,integer |>\n<code>",
  "    return $n if $m == $n;\n    \n    return -1 if $n > $m;\n    \n    $n = \"\
    0b$n\" unless $n =~ /^\\d+$/;\n    $m = \"0b$m\" unless $m =~ /^\\d+$/;", "  \
    \  $m = $m - $n;\n    my $div = $m / 2;", "    return -1 if $n > $m;\n    $n -=\
    \ 1 while $n >= $m;\n    $m *= 2;\n    if ($n & 1) {\n        return $n / 2;\n\
    \    } else {\n        my $remainder = $n & 1;\n        my $half = $n % 2;\n \
    \       return \"0b$remainder\" if $half > $remainder;\n        return -1;\n \
    \   }\n}", "    my $result = \"\";\n    \n    my $i = 0;\n    while ($i < $n)\
    \ {\n        $result .= \"0\";\n        $i++;\n    }", "    my $a = abs($n - ($m+1));\n\
    \    $a >= $m ? $a -= 1 : $a = -1;\n    return $a ? sprintf('0b%0*b', $a, $n)\
    \ : -1;\n}", "    my $av = ($n + $m) / 2;\n    $av >= $n and $av <= $m or return\
    \ -1;\n    return sprintf('%b', $av);\n}\n</code>\nThis code is pretty readable\
    \ and will get you started. The only thing is that you'll have to modify the line\
    \ with print with your favorite method, of course. You would need to add a print\
    \ statement in the subroutine to print the average of n through m to the screen.\
    \ \nYou might want to do some reading about subroutines and variables in Perl,\
    \ as this will help you to understand the concept of variables and functions in\
    \ Perl. It's not something you have to learn right away, though, as the concepts\
    \ are important to understanding Perl programming.\n<|/ a dscore=2 tags=binary,perl\
    \ |>\n<| a dscore=0 |>\n<code>", "    $n = abs($n);\n    $m = abs($m);\n    return\
    \ unless $n <= $m;\n    my $bits = ($n - $m) + 1;\n    return \"0b\" . sprintf(\"\
    %0${bits}b\", $n / $bits);\n}", '    return -1 if $n > $m;', "    my($i, $j, $carry,\
    \ $result);\n    $n += $m;\n    $n %= $j;\n    $m -= $n;\n    $m %= $j;\n    $j\
    \ = $j;\n    for (; $n >= $j; $n = ($n + $j) % ($j)) {\n        $j = $j - $j;\n\
    \    }\n    $result = $j;\n    for (; $m > 0; $m = ($m + $j) % ($j)) {\n     \
    \   $j = $j - $j;\n    }\n    for (; $j > 1; $j = ($j + $j) % ($j)) {\n      \
    \  $j = $j - $j;\n    }\n    for ($i = 0; $j < $j; $i++) {\n        $carry = 1;\n\
    \        if ($n == $i) {\n            $result .= $carry;\n        } else {\n \
    \           $carry += $result;\n            $result .= $carry . $i;\n        }\n\
    \        $carry %= 8;\n    }\n    $result .= $carry;\n    return $result;\n}",
  "    return -1 if $n > $m;\n    $n -= 1 if $n > $m;\n    return oct($n/2 + ($n %\
    \ 2) * 4) if $n > $m;\n    return oct($n/2 + ($n % 2) * 4) if $n == $m;\n    return\
    \ oct($n/2 + ($n % 2) * 4) if $n == $m;\n    return oct($n/2 + ($n % 2) * 4);\n\
    }", "    return $n <= $m ? -1 : 0\n        unless $n < $m;\n    return $n+$m if\
    \ $n == $m;\n    return $n+$m/2 if $n + ($m+1)/2 != $n;\n    return $n*$n+$m*$m\n\
    \        if $n + ($m+1)/2 != $n;\n    return $n*$n+$m*$m+$n*$m+$n*$m+$m*$m;\n}",
  "    my $num = $n <= $m ? $n : $m;\n    my $rem = 0;\n    my $bits = 8;\n    my\
    \ $result = \"\";\n    \n    $result = sprintf(\"0b%b\", $num);", "    return\
    \ -1 if $n >= $m;\n    $n = $n + ($m + 1) - $n;\n    $n = $n >> $BITS_PER_DIGIT;\n\
    \    return $n.to_s(2).reverse;\n}", "    $m = $m if $n < $m;\n    my $len = $n\
    \ - $m + 1;\n    if ($len == 0) {\n        return 0;\n    }\n    my $result =\
    \ \"\";\n    for (my $i = $m; $i >= $n; $i--) {\n        $result .= \"1\" if $i\
    \ & 1;\n    }\n    return $result . \"0\" if $result eq \"0\";\n    $result =\
    \ \"0b$result\" if $len == 1;\n    $result;\n}", "    $n += $m;\n    $m -= $n;\n\
    \    if ($n >= $m) {\n        return -1;\n    }\n    $m += $n;\n    my $s = '';\n\
    \    $s = substr($s, 0, length($s)-2);\n    $s .= '1';\n    $s *= $n;\n    $s\
    \ .= $m;\n    return $s;\n}", "    my $s = \"\";\n    \n    if ( $n > $m ) {\n\
    \        $s = \"-1\";\n    } else {\n        $s = $n . \"b\" x $m // \"0b0\";\n\
    \        $n %= $m;\n    }\n    \n    return $s;\n}", "    $n++ while $n < $m;\n\
    \    return -1 unless $m > $n;\n    $m-- while $n < $m;\n    $n <= $m ? \"$m:0b$n\"\
    \ : \"0b$m\";\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 tags=binary,perl,math,decimal\
    \ |>\nThe accepted answer fails for negative numbers. \nHere is another simple\
    \ and effective solution which uses binary math and returns -1 if n is greater\
    \ than m:\n<code>", "    my($sum, $i) = @_;\n    for(my $i=$i+1; $i<$n; $i++){\n\
    \        $sum += $i;\n    }\n    if($sum<=$m){\n        $sum = $m;\n    }\n  \
    \  $sum = ($sum%2)?oct($sum):$sum;\n    return $sum;\n}", "    my $i = $n;\n \
    \   my $sum = 0;\n    while ($i < $m) {\n        $sum += $i;\n        $i = $i\
    \ + 1;\n    }\n    return $sum / $m;\n}", "    $n = $n->{val};\n    $m = $m->{val};\n\
    \    my %a = ( 0 => 1, 1 => 1, 2 => 1, 3 => 1, 4 => 1, 5 => 2, 6 => 3, 7 => 5,\
    \ 8 => 7, 9 => 10, 10 => 13, 11 => 17, 12 => 20, 13 => 23, 14 => 26, 15 => 31,\
    \ 16 => 36, 17 => 41, 18 => 46, 19 => 51, 20 => 57, 21 => 61, 22 => 66, 23 =>\
    \ 71, 24 => 76, 25 => 81, 26 => 86, 27 => 91, 28 => 96, 29 => 102, 30 => 108,\
    \ 31 => 114, 32 => 120, 33 => 127, 34 => 131, 35 => 136, 36 => 142, 37 => 148,\
    \ 38 => 154, 39 => 161, 40 => 166, 41 => 171, 42 => 176, 43 => 182, 44 => 188,\
    \ 45 => 194, 46 => 199, 47 => 204, 48 => 209, 49 => 214, 50 => 219, 51 => 224,\
    \ 52 => 229, 53 => 234, 54 => 239, 55 => 244, 56 => 249, 57 => 254, 58 => 259,\
    \ 59 => 264, 60 => 269, 61 => 274, 62 => 279, 63 => 284, 64 => 289, 65 => 294,\
    \ 66 => 299, 67 => 304, 68 => 309, 69 => 314, 70 => 319, 71 => 324, 72 => 329,\
    \ 73 => 334, 74 => 339, 75 => 344, 76 => 349, 77 => 354, 78 => 359, 79 => 364,\
    \ 80 => 369, 81 => 374, 82 => 379, 83 => 384, 84 => 389, 85 => 394, 86 => 399,\
    \ 87 => 404, 88 => 409, 89 => 414, 90 => 419, 91 => 424, 92 => 429, 93 => 434,\
    \ 94 => 439, 95 => 444, 96 => 449, 97 => 454, 98 => 459, 99 => 464, 100 => 469,\
    \ 101 => 474, 102 => 479, 103 => 484, 104 => 489, 105 => 494, 106 => 499, 107\
    \ => 504, 108 => 509, 109 => 514, 110 => 519, 11", "    return -1 unless $n >\
    \ $m;\n    my($r, $x, $y);\n    for my $i ($n..$m-1) {\n        $x ^= $i;\n  \
    \      $y ^= $i;\n        $r ^= $i if $x & $y;\n    }\n    my $s = $x ^ $y;\n\
    \    $r ^= $s;\n    \n    $r =~ s/0*$//;\n    return $r if $r == 1; # if all bits\
    \ were 0, then we round down to 0\n    return 0 if $r <= 0; # if all bits were\
    \ 1, then we round down to 1\n    return \"0b$r\"; # if n>m, round up\n}", " \
    \   if($n > $m) {\n\treturn -1;\n    }\n    my $sum = 0;\n    my $base = 1;\n\
    \    for(my $i = $n; $i <= $m; $i++) {\n\t$sum += $base * ($i - ($i - 1) / ($m\
    \ - $n + 2));\n\t$base *= 2;\n    }\n    return $sum / $m;\n}", "    return -1\
    \ if $n >= $m;\n    return -1 if $m == 0;\n    return \"0b$_\" if (($n + 1) %\
    \ 4 == 0 and $n >= $m) or $m == 0;\n    my $str = \"\";\n    for(my $i = $n; $i\
    \ <= $m; $i += 4) {\n        my $s = $i / 4;\n        $str .= $s ? \"0b$s\" :\
    \ \"0b0\";\n    }\n    return $str;\n}", "    return -1 if $n <= $m;\n    my $r\
    \ = $n + $m / 2;\n    $r = $r + 1 if $r % 2 eq 1;\n    my $bin = sprintf(\"%b\"\
    , $r);\n    return $bin;\n}", "    if ($n < 0) {\n        $n = $-n - 1;\n    }\n\
    \    elsif ($m < 0) {\n        $m = $-m - 1;\n    }\n    else {\n        $n -=\
    \ $m;\n    }\n    # $n <= $m so $n to $m are both valid\n    my $base = 2**$m;\n\
    \    my $value = $n / $base;\n    $value += $m / $base;\n    return int2oct($value\
    \ * $base);\n}", "    if($n > $m) {\n        return -1;\n    } elsif($n == $m)\
    \ {\n        return pack(\"B*\", $n);\n    }\n    my $base = $n ^ $m;\n    my\
    \ $digits = 1;\n    my $carry = 0;\n    my $res = \"\";", "    my $result = $n\
    \ + $m;\n    $result =~ s/\\A(0b)(\\d)/\\$1$2/ if $n > $m;\n    return $result;\n\
    }\n</code>\n<|/ a tags=perl dscore=2 |>\n<| c |>\nThank you, I am new to perl,\
    \ I will try the code you provided and see what it looks like. I am also not supposed\
    \ to use any modules, just basic perl.\n<|/ c |>\n<| a dscore=1 |>\nA solution\
    \ with no extra modules: \n<code>", "    $n -= 1 unless $n;\n    $m -= 1 unless\
    \ $m;\n    $n >= $m and return -1 unless $n > $m;\n    my $bin = join('', map\
    \ { sprintf('0b%x', $_) } $n, $m);\n    $bin =~ s/^0b/+/g; # remove leading 0b\
    \ \n    $bin =~ s/^1/0/g;  # remove leading 1\n    $bin =~ s/^1/+/g;  # remove\
    \ trailing 1\n    return $bin unless $bin =~ /(^|\\s)0(b{5}|1)(?!\\s)/;  # remove\
    \ leading 0b or 1\n    $bin =~ s/^0*1/+0/;  # remove trailing 0b or 1\n    return\
    \ $bin;\n}", "    my $n = sprintf(\"%b\", $n);\n    my $m = sprintf(\"%b\", $m);\n\
    \    $n .= '0' if ($n < '0');\n    $m .= '0' if ($m < '0');\n    $m -= $n;\n \
    \   $m /= $n;\n    return sprintf(\"0b%b\", $m);\n}", "    $n -= $m;\n    if($n\
    \ < 0){ $n += $m; return -1; }\n    if($n < $m){ return \"0b$m\"}\n    return\
    \ \"0b$n\";\n}", "    if ($n > $m) {\n        return -1;\n    }\n    my $result\
    \ = 0;\n    my $i = 0;\n    my $bit;\n    my $last_digit = 0;\n    while ($i <=\
    \ $n) {\n        $result += (1 << ($m - $i)) * ($i & $n);\n        $i += $m+1;\n\
    \    }\n    return $last_digit + $result;\n}\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\nHere is my solution in C#. It is almost the same as's answer but in C# code\
    \ the function Bitwise Shift Left and Bitwise Shift Right are used. This solution\
    \ was tested with Visual Studio 2017. \n<code>\npublic static int RoundedAvg(int\
    \ n, int m)\n{\n    if (n > m)\n    {\n        return -1;\n    }", "    my($bin_digits)\
    \ = map {$_.to_i(2).str_pad('', length($_), '0')} $n .. $m;\n    my($remainder)\
    \ = $n - $m;\n    $bin_digits[$m-1] .= $remainder.(length($bin_digits[$m-1]))*ones(length($remainder),\
    \ length($bin_digits[$m-1]));\n    return join('', @$bin_digits)\n        if $m\
    \ > $n;\n    return -1\n}", "    $n += 1 if $n < $m;\n    $m++ if $n > $m;\n \
    \   my $res = 0;\n    my $count = 0;\n    while ($n <= $m) {\n        $res = $res*2\
    \ + $n % 2;\n        $count++;\n        $n++;\n    }\n    return $res / $count\
    \ if $count > 1;\n    return -1;\n}", "    $m += $n;\n    return -1 if $n > $m;\n\
    \    return $m if $n == $m;\n    my $ret = \"0b\";\n    $ret .= sprintf(\"%b\"\
    , $m & (~$n+1));\n    my $bin = $ret =~ s/(....)/$1/;\n    return $bin;\n}", " \
    \   \n    my @a = $n .. $m;\n    my $s = scalar @a;\n    $s = ($s & 0b111) + ($s\
    \ & 0b11) + ($s & 0b10) + ($s & 0b1);", "    return -1 if ($n <= $m);\n    $n\
    \ = $n - 1;\n    return \"$n$b\" if ($n & 1);\n    $n = $n - 2;\n    return \"\
    $n0b\" if ($n & 1);\n    return \"$m0b\" if ($m & 1);\n    return \"$m0b\";\n}",
  "    my @a = map { int($_) } $n, $m;\n    return -1 unless $n <= $m;\n    my $sum\
    \ = shift(@a);\n    for my $i (@a) {\n        $sum += $i if $i <= $sum;\n    }\n\
    \    my $r = $sum / shift(@a);\n    my $ret = $r == 0\n        ? $n // abs($n)\
    \ == -1\n        : \"0b\" . oct($r, 0);\n    $ret;\n}", "    my $n = $n || 0;\n\
    \    my $m = $m || 0;\n    if ($n <= $m){\n        $n += $m;\n    }\n    else\
    \ {\n        $m = $n - $m;\n        $n = $m + $n;\n    }\n    my $n = sprintf(\"\
    %08b\", $n);\n    my $m = sprintf(\"%08b\", $m);\n    my $length = length($n);\n\
    \    my $str = \"\";\n    for (my $i = 0; $i <= $length; $i++){\n        $str\
    \ .= $n[$i];\n    }\n    $str .= $m;\n    my $bin_string = reverse $str;\n   \
    \ return $bin_string;\n}", "    my $num = $n;\n    my $sum;\n    while($num <=\
    \ $m) {\n        $sum += $num;\n        $num += 1;\n    }\n    my $bin = ($sum\
    \ + $n - $m) * 2;\n    my $str = oct($bin);\n    $str =~ s/0b(.+)/$1/;\n    return\
    \ $str;\n}\n</code>\n<|/ a tags=perl,octal |>\n<| a dscore=1 tags=perl,octal |>\n\
    If you've got to use Perl, you can do it in a fairly straightforward way:\n<code>",
  "    $n += $m;\n    $m = $n if $n > $m;\n    sprintf(\"%b\", $n / $m * 2);\n}\n\
    </code>\n<|/ a |>\n<| c |>\nIt's a pity that we have to jump through hoops to\
    \ do this.\n<|/ c |>\n<| c |>\n: Perhaps you can demonstrate why you *have* to\
    \ do this and what you think the consequences of such an exercise are?\n<|/ c\
    \ |>\n<| c |>\n: because `bcd` was a joke.  They are a joke because they don't\
    \ use any computer (even a RISC).\n<|/ c |>\n<| c |>\n: but it is a *joke* because\
    \ it doesn't use any computer!  I bet that my solution would fail all test cases.\
    \  `bcd` was probably one of the few computers I used, but when I was younger\
    \ I didn't have enough memory to run a computer ;-)\n<|/ c |>\n<| c |>\n: I suspect\
    \ your solution will fail on large inputs.  For a large input, your solution will\
    \ require O(n) storage to hold the intermediate sum.  If you have a way to calculate\
    \ a running sum in constant space, then you would be able to complete this task\
    \ without having to hold the intermediate sum in memory.  Unfortunately, that\
    \ doesn't appear to be possible in Perl.  I suppose you could use something like\
    \ the Kahan summation algorithm.  Or you could use an algorithm like the [Hamming\
    \ weight problem](https://en.wikipedia.org/wiki/Hamming_weight).\n<|/ c |>\n<|\
    \ a |>\n<code>\nuse strict;\nuse warnings;\nuse 5.010;", "    $n += $m;\n    $n\
    \ = 0 if $n > $m;\n    return \"0b\" . oct($n);\n}\n</cell>\n<text>\nPutting it\
    \ all together", "    my $sum = 0;\n    for(my $i = $n; $i <= $m; ++$i) {\n  \
    \      $sum += $i;\n    }\n    my $mod = $sum % 2;\n    my $bits = $mod ? $sum\
    \ / 2 : $sum / 2 + 1;\n    return sprintf \"0b%b\", $bits;\n}", "    if ($n >\
    \ $m) {\n\treturn -1;\n    }\n    return sprintf(\"0b%b\", int($n / int($m) *\
    \ $m));\n}", "    if ($n < $m) { # n < m\n        return -1;\n    }", "    return\
    \ -1 if $n > $m;\n    my $digits = length($n.$m);\n    my $result = $n + ($digits\
    \ - 1);\n    $result = sprintf(\"%0${digits}b\", $result);\n    return $result;\n\
    }", "    return $n if $n < $m;\n    my $s = $m * $m % $m;\n    $s /= 2;\n    $s\
    \ = ~ ($s * $s) % $m;\n    return \"0b\" . oct($s);\n}", "    my $acc = 0;\n \
    \   for (my $i = 0; $i < $m and $i <= $n; ++$i) { \n        $acc += $i;\n    }\n\
    \    return sprintf(\"0b%b\" , int($acc));\n}\n</code>\n<|/ a tags=perl,bit-manipulation\
    \ |>\n<| c |>\nYou probably want to check `$i <= $n` instead of `$i < $m` in your\
    \ loop. Also, you can write `my $acc = 0b0;` just once, and `++$acc` instead of\
    \ `$acc += $i`. Finally, I'd suggest you use `return sprintf(\"0b%b\" , int($acc));`\
    \ instead of `return $acc;`.\n<|/ c |>\n<| c |>\nThis gives me `0b10110` instead\
    \ of `0b11010`, if I understood the OP's question correctly. Maybe OP wanted `0b1110`\
    \ instead?\n<|/ c |>\n<| c |>\n, OP said the answer has to be rounded to the nearest\
    \ integer.\n<|/ c |>\n<| c |>\nNo, it was just what I thought :P\n<|/ c |>\n<|\
    \ c |>\n, no. He said that if `m` is greater than `n` he should return `-1`. I\
    \ thought that if `n` is greater than `m` he should return `\"0b1\"`. Maybe I\
    \ misunderstood.\n<|/ c |>\n<| a tags=perl,bit-manipulation |>\nJust to throw\
    \ another option out there, a non-regex solution that is a little bit more succinct.\n\
    <code>", "    \n    # Convert to binary\n    my $bin = $n . substr( $m, 0, $n\
    \ ) . substr( $m, $n, $n - $m );\n    \n    # Round and convert to binary\n  \
    \  return $bin;\n}", '    my $bits = 0;', "    $n++ if $n >= $m;\n    $n = $n\
    \ if $n < $m;\n    my $base = $n - $m;\n    $base = ($base >> 1) if $base & 1;\n\
    \    return $base;\n}", "    my $avg = 0;\n    for (my $i = $n; $i <= $m; $i++)\
    \ {\n        $avg += $i;\n    }\n    $avg = int($avg/($n - $m));\n    if ($n >\
    \ $m) {\n        $avg = -1;\n    }\n    return \"0b$avg\";\n}", "    return $n\
    \ if $n <= $m;\n    $m = $n if $m > $n;\n    my $res = $n+1;\n    $res += $m+1\
    \ if $m != $n;\n    my $mask = $res+1 >> 1;\n    $res = (1<<$res) - 1 if $mask\
    \ & 1;\n    return $res;\n}", "    my $s = \"$n\" x $m;\n    $s .= '0' x $m-length($s);\n\
    \    return int($s) if $n > $m;\n    return -1;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
