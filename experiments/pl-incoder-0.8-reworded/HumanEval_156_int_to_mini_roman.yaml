name: HumanEval_156_int_to_mini_roman
language: pl
prompt: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
  # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n#\
  \ >>> int_to_mini_roman(19)\n# \"xix\"\n# >>> int_to_mini_roman(152)\n# \"clii\"\
  \n# >>> int_to_mini_roman(426)\n# \"cdxxvi\"\nsub int_to_mini_roman {\n    my($number)\
  \ = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&int_to_mini_roman;\n\
  \        if(eq_deeply($candidate->(19),\"xix\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(152),\"clii\")) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(251),\"\
  ccli\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(426),\"\
  cdxxvi\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
  \ if(eq_deeply($candidate->(500),\"d\")) {\n        print \"ok!\" }else{\n     \
  \   exit 1;\n        }\n        if(eq_deeply($candidate->(1),\"i\")) {\n       \
  \ print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4),\"\
  iv\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(43),\"\
  xliii\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(90),\"\
  xc\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(94),\"\
  xciv\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(532),\"\
  dxxxii\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
  \ if(eq_deeply($candidate->(900),\"cm\")) {\n        print \"ok!\" }else{\n    \
  \    exit 1;\n        }\n        if(eq_deeply($candidate->(994),\"cmxciv\")) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1000),\"\
  m\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my($roman) = ();\n    my($numeral) = ();\n    my $num;\n    my\
    \ $num_orig = $number;", "    my $roman = \"\";\n    my $numeral = 1;\n    my\
    \ $numChars = $number * 10;\n    my $numBits = $number % 10;", "    return \"\"\
    \ unless $number > 1 and $number < 1000;\n    my @romans = (\"c\", \"c\", \"c\"\
    , \"l\", \"l\", \"l\", \"x\", \"x\", \"x\", \"i\", \"i\");\n    my $result = \"\
    \";\n    for (my $i = $number - 1, $j = 0; $i >= 0; $i--, $j++) {\n        $result\
    \ += $romans[$i] if $j % 3 == 0;\n    }\n    return lc($result);\n}", "    my(@array)\
    \ = (\" \", \" M\", \" CM\", \" D\", \" CD\", \" C\", \" XC\", \" L\", \" XL\"\
    , \" X\", \" IX\", \" V\", \" IV\", \" I\");\n    my(@roman) = (\" I\", \" II\"\
    , \" III\", \" IV\", \" V\", \" VI\", \" VII\", \" VIII\", \" IX\");\n    my(@result,);\n\
    \    my($count,$num);", "    $number = int($number);\n    return '' unless $number\
    \ >= 1 && $number <= 1000;\n    my($roman, $roman_index, $prev_roman_index);\n\
    \    $prev_roman_index = 0;\n    $roman = '';\n    while ($number >= 10) {\n \
    \       $number -= 10;\n        my $tmp = substr($roman_index, 0, 1);\n      \
    \  my $remainder = $number % 10;\n        my $new_roman_index = $roman_index.$tmp.chr($remainder).substr($roman_index,\
    \ 0, 1);\n        $roman .= $new_roman_index;\n        $roman_index = $new_roman_index;\n\
    \        $prev_roman_index = $roman_index;\n    }\n    if ($prev_roman_index !=\
    \ $roman_index) {\n        my $tmp = substr($roman_index, 0, 1);\n        $roman\
    \ .= $tmp.substr($roman_index, 0, 1);\n        $roman_index = $tmp;\n    }\n \
    \   $roman_index = $roman_index.substr($roman_index, 0, 1);\n    return $roman_index;\n\
    }", '    my($result,$rest);', "    my(@roman_numeral);\n    my($current_roman_numeral);\n\
    \    my($roman_numeral_string);\n    my $result;", "    my $roman = '';\n    for(my\
    \ $i = 6; $i <= $number; $i += 6) {\n        my $n = int ($number / $i);\n   \
    \     $roman .= $self->numeral_to_roman($n);\n    }\n    return $roman;\n}", '    my
    (@roman);', "    my(@roman) = ();\n    my($letter) = '';\n    my($roman) = '';\n\
    \    my($j);", "    my(@alphabet) = (\n        'i',\n        'x',\n        'c',\n\
    \        'l',\n        'd'\n    );\n    my($num_digits) = 0;\n    my($num_roman_digits)\
    \ = 0;\n    my($num_alphabet) = 0;\n    my($mini_roman_num);\n    my($mini_roman_int_num_chars);\n\
    \    my($mini_roman_int_num_chars_char);\n    my($mini_roman_int_num_chars_num);\n\
    \    my($mini_roman_int_num_chars_char2);\n    my($mini_roman_int_num_chars_char3);\n\
    \    my($mini_roman_int_num_chars_char4);\n    my($mini_roman_int_num_chars_char5);\n\
    \    my($mini_roman_int_num_chars_char6);\n    my($mini_roman_int_num_chars_char7);\n\
    \    my($mini_roman_int_num_chars_char8);\n    my($mini_roman_int_num_chars_char9);\n\
    \    my($mini_roman_int_num_chars_char10);\n    my($mini_roman_int_num_chars_char11);\n\
    \    my($mini_roman_int_num_chars_char12);\n    my($mini_roman_int_num_chars_char13);\n\
    \    my($mini_roman_int_num_chars_char14);\n    my($mini_roman_int_num_chars_char15);\n\
    \    my($mini_roman_int_num_chars_char16);\n    my($mini_roman_int_num_chars_char17);\n\
    \    my($mini_roman_int_num_chars_char18);\n    my($mini_roman_int_num_chars_char19);\n\
    \    my($mini_roman_int_num_chars_char20);\n    my($mini_roman_int_num_chars_char21);\n\
    \    my($mini_roman_int_num_chars_char22);\n    my($mini_roman_int_num_chars_char23);\n\
    \    my($mini_roman_int_num_chars_char24);\n    my($mini_roman_int_num_chars_char25);\n\
    \    my($mini_roman_int_num_chars_char26);\n    my($mini_roman_int_num_chars_char27);\n\
    \    my($mini_roman_int_num_chars_char28);\n    my($mini_roman_int_num_chars_char29);\n\
    \    my($mini_roman_int_num_chars_char30);\n    my($mini_roman_int_num_chars_char31);\n\
    \    my($mini_roman_int_num_chars_char", "    $number = abs($number);\n    if\
    \ ($number < 1000) {\n        return $number;\n    }\n    my @roman;\n    my $numeral\
    \ = int_to_roman($number);\n    my @roman_string = split('', @$numeral);\n   \
    \ my $index = 0;\n    my $number_roman = 0;\n    my $previous_letter = 0;\n  \
    \  while (@roman_string) {\n        if ($roman_string[$index] =~ /[a-z]/) {\n\
    \            $number_roman += $previous_letter * substr($roman_string[$index],\
    \ 0, 1);\n        }\n        $index++;\n        $previous_letter = $roman_string[$index\
    \ - 1] =~ /[a-z]/\n            ? $roman_string[$index - 1] - 'a' + 1\n       \
    \     : 0;\n    }\n    my $roman = $numeral ? join('', @roman) : '';\n    return\
    \ $roman;\n}", '    $number //= 1;', '    my($roman) = "";', "    my $roman_numeral\
    \ = \"\";\n    if ($number < 1) {\n       die \"Invalid input: number should be\
    \ positive.\\n\";\n    }\n    my $counter = 1;\n    my $total_digits = $number\
    \ % 10;\n    my $remainder = $number % 10;\n    my $roman_numeral_length = length($roman_numeral);\n\
    \    while ($number >= 10) {\n       my $remainder_digit = $number % 10;\n   \
    \    $roman_numeral .= roman_numeral_to_arabic_number($remainder_digit);\n   \
    \    $remainder = $number % 10;\n       $number = $number / 10;\n       $counter++;\n\
    \    }\n    if ($total_digits == 0) {\n       die \"Invalid input: number should\
    \ be an integer.\\n\";\n    }\n    while ($counter < $roman_numeral_length) {\n\
    \       $roman_numeral .= \"m\";\n       $counter++;\n    }\n    $roman_numeral\
    \ .= roman_numeral_to_arabic_number($remainder);\n    $roman_numeral = lc( $roman_numeral);\n\
    \    return $roman_numeral;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nHow about\
    \ `9`, `19`, `101`?\n<|/ c |>\n<| c |>\n: I didn't notice these requirements.\
    \ Thanks for pointing them out.\n<|/ c |>\n<| c |>\nIt should be `return $roman_numeral\
    \ if $roman_numeral_length < 1; return $roman_numeral if $number < 1000;` - otherwise,\
    \ you'll end up with two \"x\" characters (and that might not be what you wanted).\n\
    <|/ c |>\n<| c |>\nThe answer still has some problems with `1` which results in\
    \ `1m` instead of `1i` in the roman numeral (but that can't be fixed without changing\
    \ the algorithm).\n<|/ c |>\n<| c |>\n: Good catch. I fixed it by making the function\
    \ return an empty string on error instead of die().\n<|/ c |>\n<| a |>\nThe code\
    \ below converts numbers up to 999 to roman numerals and prints them out on a\
    \ single line. \nIt is not optimized yet, but it works well for me.\n<code>\n\
    use strict;\nuse warnings;\nuse 5.010;\nuse utf8;", "    my($string);\n    my($i_fmt,$i_base,$i_tens,$i_num);",
  "    my $roman_numeral = '';\n    while($number > 10) {\n        $roman_numeral\
    \ .= int_to_roman_numeral($number % 10);\n        $number /= 10;\n    }\n    $roman_numeral\
    \ .= int_to_roman_numeral($number);\n    return lc($roman_numeral);\n}", "   \
    \ my $roman = \"\";\n    while (1) {\n        my $n = $number % 1000;\n      \
    \  if ($n == 0) {\n            $roman .= $alphabet[$number % 10];\n          \
    \  $number /= 10;\n        } elsif ($n < 1000) {\n            $roman .= $alphabet[$n];\n\
    \        } else {\n            my $new_number = $n;\n            while (1) {\n\
    \                my $remain = $new_number % 10;\n                $roman .= $alphabet[$remain];\n\
    \                $new_number /= 10;\n                if ($new_number == 0) {\n\
    \                    last;\n                }\n            }\n        }\n    \
    \    if ($number == 0) {\n            last;\n        }\n        $number /= 1000;\n\
    \    }\n    return lc($roman);\n}", "    $number =~ s/^0+$//; # strip leading\
    \ zeros\n    my @strs = ();\n    my %roman;\n    my $str = \"\";\n    my $base\
    \ = 1;\n    my $roman_num;\n    my $roman_name;", "    my($str);\n    my($roman);",
  "    my(@roman);\n    if ($number < 1) {\n        return \"1\";\n    }\n    elsif\
    \ ($number < 10) {\n        return \"$1\";\n    }\n    elsif ($number < 100) {\n\
    \        return \"$1 $2\";\n    }\n    elsif ($number < 1000) {\n        my $result\
    \ = int_to_mini_roman($number / 10);\n        $result = $result . int_to_mini_roman($number\
    \ % 10);\n        push(@roman, $result);\n        return join(\"\", @roman);\n\
    \    }\n    else {\n        my $result = int_to_mini_roman($number / 100);\n \
    \       $result = $result . int_to_mini_roman($number % 100);\n        push(@roman,\
    \ $result);\n        return join(\"\", @roman);\n    }\n}", '    my $mini_roman
    = "";', "    if ($number < 0) {\n        return \"XXX\";\n    }\n    my $result\
    \ = '';\n    my $i = 1; my $j = 1;\n    while (1) {\n        my $v = $number;\n\
    \        if ($i < $number) {\n            $j += 1;\n            $result .= $j\
    \ == 1 ? 'I' : 'i';\n        }\n        $result += $j == 1 ? 'M' : 'm';\n    \
    \    if ($j == 2) {\n            $result .= 'C';\n            $j = 1;\n      \
    \  }\n        elsif ($j == 3) {\n            $result .= 'D';\n            $j =\
    \ 1;\n        }\n        elsif ($j == 4) {\n            $result .= 'C';\n    \
    \        $j = 1;\n        }\n        elsif ($j == 5) {\n            $result .=\
    \ 'L';\n            $j = 1;\n        }\n        elsif ($j == 6) {\n          \
    \  $result .= 'XL';\n            $j = 1;\n        }\n        elsif ($j == 7) {\n\
    \            $result .= 'XC';\n            $j = 1;\n        }\n        elsif ($j\
    \ == 8) {\n            $result .= 'CD';\n            $j = 1;\n        }\n    \
    \    elsif ($j == 9) {\n            $result .= 'CM';\n            $j = 1;\n  \
    \      }\n        elsif ($j == 10) {\n            $result .= 'D';\n          \
    \  $j = 1;\n        }\n        elsif ($j == 11) {\n            $result .= 'CM';\n\
    \            $j = 1;\n        }\n        elsif ($j == 12) {\n            $result\
    \ .= 'C';\n            $j = 1;\n        }\n        elsif ($j == 13) {\n      \
    \      $result .= 'M';\n            $j = 1;\n        }\n        elsif ($j == 14)\
    \ {\n            $result .= 'D';\n            $j = 1;\n        }\n        elsif\
    \ ($j == 15) {\n            $result .= 'L';\n            $j = 1;\n        }\n\
    \        elsif ($j == 16) {\n            $result .= 'XL';\n            $j = 1;\n\
    \        }\n        elsif ($j == 17) {\n            $result .= 'XC';\n       \
    \     $j = 1;\n        }\n        elsif ($j == 18) {\n            $result .= 'CD';\n\
    \            $j = 1;\n        }\n        elsif ($j == 19) {\n            $result\
    \ .= 'CM';\n            $j = 1;\n        }\n        elsif ($j == 20) {\n     \
    \       $result .= 'C';\n            $j = 1;\n        }\n        elsif ($j ==\
    \ 21) {\n            $result .= 'XC", "    my $str = '';\n    my $roman = int2roman($number);\n\
    \    foreach my $letter(split('', $roman)) {\n        $str .= $letter if $letter\
    \ ne '';\n    }\n    $str =~ s/^\\s*//;\n    return lc($str);\n}", '    my(@roman)
    = ();', "    my $roman = '';\n    my $num_string = $number->to_s;\n    my $num_length\
    \ = length($num_string);\n    if ($num_length < 5) {\n        $roman .= $num_string;\n\
    \    } elsif ($num_length < 10) {\n        $roman .= $num_string[0,0];\n     \
    \   $roman .= \"i\";\n    } elsif ($num_length < 50) {\n        $roman .= $num_string[0,0];\n\
    \        $roman .= \"ii\";\n    } elsif ($num_length < 100) {\n        $roman\
    \ .= $num_string[0,0];\n        $roman .= \"iii\";\n    } else {\n        $roman\
    \ .= $num_string[0,0];\n        $roman .= \"iv\";\n    }\n    return $roman;\n\
    }", "    my($i, $rom);\n    my($maxi) = $number < 0 ? -$number : 1000;\n    my($maxo)\
    \ = $number < 0 ? -$number : 1000;\n    my $roman = '';\n    my $cur = 1;", '    my($roman);',
  "    my($roman, $letter);\n    if ($number < 1) {\n        return \"$1\";\n    }\n\
    \    if ($number < 1000) {\n        return int_to_mini_roman($number - 1)\n  \
    \  }\n    if ($number < 5000) {\n        return \"d\";\n    }\n    if ($number\
    \ < 10000) {\n        $roman = int_to_mini_roman($number - 1000);\n        $letter\
    \ = $letter || substr($roman, 0, 1);\n        return $roman . $letter;\n    }\n\
    \    if ($number < 100000) {\n        $roman = int_to_mini_roman($number - 10000);\n\
    \        $letter = $letter || substr($roman, 0, 1);\n        return \"c\" . $roman\
    \ . $letter;\n    }\n    if ($number < 500000) {\n        $roman = int_to_mini_roman($number\
    \ - 50000);\n        $letter = $letter || substr($roman, 0, 1);\n        return\
    \ \"cc\" . $roman . $letter;\n    }\n    if ($number < 1000000) {\n        $roman\
    \ = int_to_mini_roman($number - 100000);\n        $letter = $letter || substr($roman,\
    \ 0, 1);\n        return \"ccc\" . $roman . $letter;\n    }\n    if ($number <\
    \ 5000000) {\n        $roman = int_to_mini_roman($number - 500000);\n        $letter\
    \ = $letter || substr($roman, 0, 1);\n        return \"cccc\" . $roman . $letter;\n\
    \    }\n    if ($number < 10000000) {\n        $roman = int_to_mini_roman($number\
    \ - 1000000);\n        $letter = $letter || substr($roman, 0, 1);\n        return\
    \ \"ccccc\" . $roman . $letter;\n    }\n    if ($number < 50000000) {\n      \
    \  $roman = int_to_mini_roman($number - 5000000);\n        $letter = $letter ||\
    \ substr($roman, 0, 1);\n        return \"cccccc\" . $roman . $letter;\n    }\n\
    \    if ($number < 100000000) {\n        $roman = int_to_mini_roman($number -\
    \ 10000000);\n        $letter = $letter || substr($roman, 0, 1);\n        return\
    \ \"ccccccc\" . $roman . $letter;\n    }\n    if ($number < 500000000) {\n   \
    \     $roman = int_to_mini_roman($number - 50000000);\n        $letter = $letter\
    \ || substr($roman, 0, 1);\n        return \"ccccccc\" . $roman . $letter;\n \
    \   }\n    if ($number < 1000000000) {\n        $roman = int_to_mini_roman($number\
    \ - ", "    \n    my $roman = \"\";\n    my $current_number = $number;\n    \n\
    \    while (1) {\n        my $remainder = intdiv($current_number);\n        if\
    \ ($current_number != $remainder) {\n            $roman .= int_to_mini_roman($remainder).\"\
    \";\n            last;\n        }\n        $roman .= int_to_mini_roman($remainder).\"\
    \";\n        $current_number = $remainder;\n    }\n    return lc($roman);\n}",
  "    my $roman = '';\n    my $num    = 0;\n    \n    if ($number < 0 || $number\
    \ > 1000) {\n        die \"Invalid input: number outside of range\\n\";\n    }\n\
    \    \n    for (my $i = 0; $i < $number; $i++) {\n        $roman .= roman_numeral($i);\n\
    \    }\n    \n    return lc($roman);\n}", "    my $roman = \"\";\n    my $i =\
    \ 1;\n    while($i <= $number) {\n        $roman .= roman_digit_to_letter_case($number%10);\n\
    \        $number = int($number/10);\n        $i++;\n    }\n    return lc($roman);\n\
    }", "    my @roman = ();\n    my $prev_roman = \"\";", "    my(@roman) = ();\n\
    \    my($i, $roman, $chars, $max_chars);\n    if ($number <= 0) {\n        return\
    \ \"0\";\n    }\n    if ($number < 1000) {\n        $roman = int_to_mini_roman($number\
    \ / 100); \n    }\n    elsif ($number < 1000000) {\n        $roman = int_to_mini_roman($number\
    \ / 1000); \n    }\n    elsif ($number < 1000000000) {\n        $roman = int_to_mini_roman($number\
    \ / 1000000); \n    }\n    elsif ($number < 1000000000000) {\n        $roman =\
    \ int_to_mini_roman($number / 1000000000); \n    }\n    else {\n        $roman\
    \ = int_to_mini_roman($number / 1000000000000); \n    }\n    $roman = \"$roman\"\
    \ while $roman =~ s/^([a-z])$/i\\1xi$1/i;\n    $roman = substr($roman, 0, $max_chars);\n\
    \    $roman = reverse $roman;\n    @roman = ();\n    foreach $char (split(//,\
    \ $roman)) {\n        $chars = ord($char) - 97;\n        if ($chars > 0) {\n \
    \           push(@roman, \"$chars\");\n        }\n    }\n    return join(\"\"\
    , map { chr($_ + 96) } @roman);\n}", "    if ($number < 1 || $number > 1000) {\n\
    \        die \"Invalid argument ($number)\\n\";\n    }\n    my $roman = '';\n\
    \    my $denominator = 1;\n    my $tmp;\n    while (1) {\n        $tmp = ($number\
    \ % $denominator);\n        $roman .= ( ( $tmp > 1 ) ? ( $tmp == 1 ) ? 'I' : 'V'\
    \ ) . ' ';\n        $number -= $tmp;\n        $denominator += $tmp > 1 ? 2 : 1;\n\
    \        if ($number == 0) {\n            return lc($roman);\n        }\n    }\n\
    }", "    die \"Invalid integer: $number\" unless $number =~ /^\\d+$/;\n    my\
    \ @digits = (\"M\", \" D\", \"C\", \"X\", \"L\", \"M\", \"C\");\n    my @roman_numerals\
    \ = (\"M\", \"D\", \"C\", \"X\", \"L\", \"X\", \"V\");\n    my $roman_numeral;\n\
    \    my $num;\n    my $i = 0;\n    while ($number > 0) {\n        $num = $number\
    \ % 10;\n        $roman_numeral = substr($roman_numerals[$i], 0, 1) . $digits[$num];\n\
    \        last if (++$i == @roman_numerals);\n        $number = $number / 10;\n\
    \    }\n    return $roman_numeral;\n}", "    my(@roman) = ();\n    my(@roman_numeral)\
    \ = ();\n    my($roman_num, $digit, $roman_numeral, $index);\n    my($num_digits);\n\
    \    my($max_digits);", "    my $roman = \"\";\n    if ($number < 1000) {\n  \
    \      return $number;\n    }\n    my $i = 0;\n    my $cur = 0;\n    while ($i\
    \ < $number) {\n        my $str = $number-$i;\n        if ($str < 0) {\n     \
    \       $cur -= $str;\n        } else {\n            $cur += $str;\n        }\n\
    \        my $remainder = mod_div($number, $str, $cur);\n        if ($remainder\
    \ == 0) {\n            my $str = $number-$i;\n            $roman .= $str_to_mini_roman($str);\n\
    \            $i += $str;\n        } elsif ($remainder < 0) {\n            $roman\
    \ .= $str_to_mini_roman($remainder);\n            $i += $remainder;\n        }\n\
    \    }\n    return $roman;\n}", "    my($roman);\n    my $roman_txt;", "    return\
    \ '' unless $number > 0 and $number < 1000;", '    return unless $number > 0;',
  "    $number > 1000 ? \"?\" : int_to_roman($number);\n}", "    my(@romans);\n  \
    \  my($roman, $numeral);", "    # Handle up to 1000 by incrementally adding 'I'\n\
    \    return $number if $number < 1_000;\n    my($roman, $last, $lastRoman, $i,\
    \ $romnum, $firstRoman, $lastRoman, $maxRoman, $first, $last, $max);\n    if ($number\
    \ < 500) {\n        $roman = 'I' . int_to_roman($number);\n    } else {\n    \
    \    my($hundreds, $tens, $ones) = int_to_roman($number / 100);\n        $lastRoman\
    \ = $roman;\n        my($last, $lastRoman) = ($number % 100, $roman);\n      \
    \  $romnum = $hundreds;\n        $maxRoman = 'MMCCLXXXVIII';\n        $max = $number\
    \ % 100;\n        for ($i = 1; $i < 100 && $i <= $max; $i++) {\n            my\
    \ $nextRoman = $romnum . $ones . $lastRoman;\n            my $nextRomanRoman =\
    \ int_to_roman($nextRoman);\n            if ($nextRomanRoman ne $lastRoman) {\n\
    \                $roman = $nextRoman;\n                $romnum = $nextRomanRoman;\n\
    \                $romnum = $romnum . $ones . $hundreds;\n                $lastRoman\
    \ = $nextRomanRoman;\n                $lastRoman = int_to_roman($lastRoman);\n\
    \            }\n        }\n        if ($lastRoman ne $romnum) {\n            $roman\
    \ = $romnum;\n        }\n    }\n    $first = int_to_roman($number % 10);\n   \
    \ $lastRoman = int_to_roman($last % 10);\n    if ($first eq 'I' && $last eq 'I')\
    \ {\n        return \"$roman\";\n    }\n    if ($first eq 'I' && $lastRoman ne\
    \ 'I') {\n        if ($lastRoman eq 'V' || $lastRoman eq 'X') {\n            $roman\
    \ = substr($roman, 1);\n        }\n        return \"$roman\";\n    }\n    if ($last\
    \ eq 'I' && $lastRoman eq 'I') {\n        return \"$roman\";\n    }\n    if ($roman\
    \ eq 'I') {\n        return \"$roman\";\n    }\n    if ($roman eq $romnum) {\n\
    \        return \"$roman\";\n    }\n    return \"$romnum$first$lastRoman\";\n}",
  "    my $result = \"\";\n    my $last = \"\";\n    while($number > 0) {\n      \
    \  my $digit = $number % 10;\n        $result = int_to_roman_digit($digit, $last);\n\
    \        $number -= $digit;\n        $last = $digit;\n    }\n    return $result;\n\
    }", "    return \"\" unless $number;\n    my @roman = qw/i ii iii iv v vi vii\
    \ viii ix/;\n    my @result = ();\n    $number += 10;\n    my $i = 1;\n    while\
    \ ($number >= 100) {\n        $number -= 100;\n        $i++;\n    }\n    my $remainder\
    \ = 0;\n    $number += $remainder;\n    while ($i) {\n        if ($number >= 10)\
    \ {\n            $number -= 10;\n            $result[$_] = $roman[$i-1];\n   \
    \     }\n        $i--;\n    }\n    my $result = join '', @result;\n    return\
    \ lc $result;\n}", "    # Romans don't go from 1-9\n    return if $number < 1;\n\
    \    my($roman) = roman($number);\n    # If the value is in the dictionary, just\
    \ return the key\n    return $roman if defined($romans{$roman});", "    my($ret,\
    \ $temp, $i); # temp is used for swapping\n    $ret = '';\n    while(1) {\n  \
    \      $i++;\n        if($number > $i) {\n            $ret .= int2roman($number);\n\
    \            $number -= $i;\n        } elsif($i == 1) { # if num is 1, then append\
    \ 'i'\n            $ret .= 'i';\n        } else {\n            $ret .= int2roman($number);\n\
    \            $number -= $i; # move the number over\n            $temp = $i;\n\
    \            $i--;\n            if($number <= 0) {\n                last;\n  \
    \          }\n            $ret .= int2roman($number);\n            $temp += $i;\n\
    \            $ret .= int2roman($temp);\n            $number = $temp;\n       \
    \ }\n    }\n    $ret;\n}\n</code>\n<|/ a tags=python,ruby,perl,algorithm,ruby-on-rails\
    \ |>\n<| c |>\nThe example you posted doesn't work, because `19` isn't a `'i'`.\
    \ `'xix'` is the correct result.\n<|/ c |>\n<| c |>\nOh you're right. I'll update\
    \ it. I just ran a ruby program that does exactly what OP asked, and I forgot\
    \ the fact that it was an i.\n<|/ c |>\n<| a tags=python,ruby,perl,algorithm,ruby-on-rails\
    \ dscore=2 |>\nIf you're doing it for fun, then here's a Perl solution (not Ruby\
    \ :) ):\n<code>", "    my $roman = '';\n    my $i = 1;\n    while( $number > 0\
    \ ) {\n        $roman .= ( ( $number % 10 ) == 1 ? 'I' : ( 'V' ) ) x $i;\n   \
    \     $number /= 10;\n        $i++;\n    }\n    return lc $roman;\n}", '    $number
    += 0;', '    my($roman_num, $roman_str);', "    my(@result) = ('');\n    while($number\
    \ > 1000) {\n        my($num, $numstr) = int_to_roman($number - 1000);\n     \
    \   push(@result, $numstr . $num);\n        $number -= 1000;\n    }\n    my($num,\
    \ $numstr) = int_to_roman($number);\n    push(@result, $numstr . $num);\n    return\
    \ join('', @result);\n}", '    my($string);', "    my(@romans);\n    my($current);\n\
    \    my $roman = \"\";\n    my $roman_length = scalar (@romans);", "    my $roman\
    \ = $roman ||= _mini_roman_alphabet();\n    return $roman->[$number] // $number;\n\
    }", '    my($roman, $number);', "    my(@roman) = (\"i\", \"ii\", \"iii\", \"\
    iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\");\n    my($output);", "    my @numerals\
    \ = ();\n    my @suffixes = (\"sh\", \"ch\", \"sch\", \"th\", \"th\", \"th\",\
    \ \"th\");\n    my $numstr = format_number($number);\n    for (my $i = 0; $i <=\
    \ $#suffixes; $i++) {\n        my $digit = $numstr =~ m/^(\\d+)$suffixes[$i]\\\
    z/;\n        if (defined $digit) {\n            push (@numerals, $digit);\n  \
    \          $numstr =~ s/\\d+/$digit/;\n        }\n    }\n    my $result = \"$numerals[0]$suffixes[4]\"\
    ;\n    for (my $i = 1; $i <= $#numerals; $i++) {\n        $result .= \"$numerals[$i]$suffixes[$i\
    \ - 1]\";\n    }\n    return $result;\n}", "    my @roman;\n    my $roman = \"\
    \";", "    my(@results);\n    # check for special case\n    return unless $number\
    \ < 1; # check this first since it could have a negative value\n    if ($number\
    \ == 1) {\n        return \"x\";\n    }\n    # find the smallest positive integer\n\
    \    my $mini = 9999999999999999999;\n    $mini = 2 if $number < 2;\n    for(my\
    \ $i = $mini; $i <= $number; $i++) {\n        $mini = $i;\n    }\n    # generate\
    \ roman numerals\n    for ($mini; $i <= $number; $i++) {\n        my $roman =\
    \ to_roman_num($i);\n        push(@results, lc($roman));\n    }\n    # return\
    \ the answer\n    return join(\"\", @results);\n}", "    my @roman;\n    my $num\
    \ = ($number + 500);\n    my $roman = 0;\n    my $last = 0;\n    while (@roman[$roman]\
    \ <= $num) {\n        $roman += 1;\n        push @roman, $roman;\n    }\n    while\
    \ ($roman) {\n        my $c = $roman[--$roman];\n        if ($last <= ($c - 1))\
    \ {\n            push @roman, \"$c$c\";\n        } else {\n            push @roman,\
    \ \"$c$c$c\";\n        }\n    }\n    return join '', map { uc substr($_, 1, 1)\
    \ } @roman;\n}", '    my($letter) = "";', "    my $roman = '';\n    while ($number\
    \ != 0) {\n        $roman .= substr($int_to_roman($number),0,1);\n        $number\
    \ -= $int_to_roman($number);\n    }\n    return lc($roman);\n}", "    my($roman_string);\n\
    \    if ($number < 1000) {\n        $roman_string = \"$number\";\n    } else {\n\
    \        $roman_string = $number % 1000;\n        $roman .= \"M\"x$number % 1000;\n\
    \        $number -= $roman;\n        $roman .= \"CM\"x$number % 1000;\n      \
    \  $number -= $roman;\n        $roman .= \"D\"x$number % 1000;\n        $number\
    \ -= $roman;\n        $roman .= \"CD\"x$number % 1000;\n        $number -= $roman;\n\
    \        $roman .= \"C\"x$number % 1000;\n        $number -= $roman;\n       \
    \ $roman .= \"XC\"x$number % 1000;\n        $number -= $roman;\n        $roman\
    \ .= \"L\"x$number % 1000;\n        $number -= $roman;\n        $roman .= \"XL\"\
    x$number % 1000;\n        $number -= $roman;\n        $roman .= \"X\"x$number\
    \ % 1000;\n        $number -= $roman;\n        $roman .= \"IX\"x$number % 1000;\n\
    \        $number -= $roman;\n        $roman .= \"V\"x$number % 1000;\n       \
    \ $number -= $roman;\n        $roman .= \"IV\"x$number % 1000;\n        $number\
    \ -= $roman;\n    }\n    if ($number > 0) {\n        $roman = $roman . int_to_mini_roman($number\
    \ - 1);\n    }\n    return $roman;\n}", "    my $roman = '';\n    my $num = $number;\n\
    \    while ($num) {\n        $roman .= roman_num($num % 10);\n        $num /=\
    \ 10;\n    }\n    return lc $roman;\n}", "    $number += 1;\n    my $roman = roman($number);\n\
    \    $roman =~ s/(\\d)$/I$1/g;\n    return lc($roman);\n}", "    my @chars = ();\n\
    \    my $num = 0;", "    my $base  = 1;\n    my $num_str = int2str($number);\n\
    \    $num_str =~ s/^([a-z])/$1$1/g;\n    $num_str =~ s/^([iol])/$1l/g;\n    $num_str\
    \ =~ s/^([dlm])/$1m/g;\n    $num_str =~ s/^([lmio])/$1i/g;\n    $num_str =~ s/^([xci])/$1c/g;\n\
    \    $num_str =~ s/^([sdz])/$1d/g;\n    $num_str =~ s/^([jg])/$1e/g;\n    $num_str\
    \ =~ s/^([sh])/$1f/g;\n    $num_str =~ s/^([q])/$1fq/g;\n    $num_str =~ s/^([p])/$1p/g;\n\
    \    $num_str =~ s/^([z])/$1fz/g;\n    my $roman = $num_str;\n    $roman =~ s/^([mlc])/$1$base/g;\n\
    \    $roman =~ s/^([cl])/$1$base/g;\n    $roman =~ s/^([dl])/$1$base/g;\n    $roman\
    \ =~ s/^([dm])/$1$base/g;\n    $roman =~ s/^([iol])/$1$base/g;\n    $roman =~\
    \ s/^([lmio])/$1$base/g;\n    $roman =~ s/^([xci])/$1$base/g;\n    $roman =~ s/^([sdz])/$1$base/g;\n\
    \    $roman =~ s/^([jg])/$1$base/g;\n    $roman =~ s/^([sh])/$1$base/g;\n    $roman\
    \ =~ s/^([q])/$1$base/g;\n    $roman =~ s/^([p])/$1$base/g;\n    $roman =~ s/^([z])/$1$base/g;\n\
    \    $roman =~ s/^([cl])/$1$base/g;\n    $roman =~ s/^([dl])/$1$base/g;\n    $roman\
    \ =~ s/^([dm])/$1$base/g;\n    $roman =~ s/^([iol])/$1$base/g;\n    $roman =~\
    \ s/^([lmi", "    if ($number < 1) {\n\tdie \"int_to_mini_roman() expects a positive\
    \ integer\";\n    }\n    if ($number < 1000) {\n\treturn $number + 400;\n    }\n\
    \    my(@roman) = (\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\"\
    , \"X\", \"IX\", \"V\", \"IV\", \"I\");\n    my(@letters) = (\"I\", \"II\", \"\
    III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\"\
    );\n    my(@tens, @ones);\n    for ($number) {\n\tpush(@tens, 10 * $number + 1);\n\
    \tpush(@ones, 1 * $number);\n    }\n    return join(\"\", map {&roman_numbers(@{$_},\
    \ $letters, $roman[$_ - 1], @roman)} 0..$#roman);\n}", "    my $roman = '';",
  "    my($roman, $digit, $i, $roman_string, $char);\n    my($base, $num_zeros);",
  "    my($numeral);\n    my $roman;\n    my $roman_length = \"\";\n    my $roman_numeral\
    \ = \"\";\n    my $num_digits = 0;\n    foreach my $i (0 .. 9){\n        my $num_digit\
    \ = $number%10;\n        $number -= $num_digit;\n        $num_digits += $num_digit;\n\
    \        my $roman_string = \"\";\n        if( $num_digits == 0 ){\n         \
    \   $roman_string = \"$roman_length$roman\";\n            $roman = $roman_string;\n\
    \        }\n        elsif( $num_digits > 0 ){\n            $roman_string = \"\
    $roman\";\n            $roman_length = \"$roman_length\";\n            $roman_numeral\
    \ = \"$roman_numeral$roman_string\";\n        }\n    }\n    return $roman_numeral;\n\
    }", "    return undef if !defined($number) || $number < 1;\n    return undef if\
    \ $number > 1000;", "    my(@alphabet) = (\"M\", \"CM\", \"D\", \"CD\", \"C\"\
    , \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\");\n    my($roman_num);\n\
    \    my($results);", "    if ($number < 1 || $number > 1000) {\n        die \"\
    Invalid input in int_to_mini_roman()\";\n    }", '    my @roman = ();', "    $number\
    \ += 400;\n    my($roman) = ('M', 'CM', 'D', 'CD', 'XC', 'L', 'XL', 'X', 'XC',\
    \ 'IX', 'V', 'IV');\n    my @numerals = (500, 400, 100,  90, 50,  50,  10, 9,\
    \   5,   4);\n    my @letters = (\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\",\
    \ \"vi\", \"vii\", \"viii\", \"ix\");\n    for (my $index = 0; $index <= $#numerals;\
    \ $index++) {\n        if ($number >= $numerals[$index]) {\n            my $num_str\
    \ = $numerals[$index];\n            $number -= $numerals[$index];\n          \
    \  return $num_str . (($index == 0) ? \"\" : $letters[$index]);\n        }\n \
    \   }\n    die \"invalid number!\";\n}\n</code>\nI believe this would work for\
    \ numbers up to 1000, and it also has the added benefit of not needing to load\
    \ additional modules.\n<|/ a |>\n<| c |>\nthanks for your answer! I guess it solves\
    \ the problem as I described but my original question was how to do it in perl\
    \ without modules. I thought there would be a way to do it with substr or something\
    \ similar but your solution looks like a good solution. I'll accept it as the\
    \ answer if there is no way to do it without modules.\n<|/ c |>\n<| c |>\nOh I\
    \ guess I just missed that part, sorry. You're right, I was a bit hasty on the\
    \ first pass. I'll amend my answer.\n<|/ c |>\n<| a tags=perl dscore=0 |>\nUse\
    \ a hash:\n<code>\nmy %roman = map { $_ => $_ } qw(I II III IV V VI VII VIII IX\
    \ X);\n</code>\nThen to look up the value:\n<code>\nmy $val = ($number + 500)\
    \ % 1000;\nreturn $roman{$val};\n</code>\n<|/ a |>\n<| c |>\nI don't think you\
    \ understand the question. He wants to map a number into its ROMAN equivalent.\
    \ I think the hash just needs to map 0 to I, 1 to II, etc. until 999 => XC. I'm\
    \ sure it's doable, but I don't have the time to test right now. It would be much\
    \ easier to just have a hash of all the numbers I guess.\n<|/ c |>\n<| c |>\n\
    No, I think you misunderstood. I was trying to map the number to a string as given\
    \ in the question. Now I think you got it.\n<|/ c |>\n", "    my($roman);\n  \
    \  my($tens, $ones);", "    my(@alphabet) = (\n        \"M\",\n        \"CM\"\
    ,\n        \"D\",\n        \"CD\",\n        \"C\",\n        \"XC\",\n        \"\
    L\",\n        \"XL\",\n        \"X\",\n        \"IX\",\n        \"V\",\n     \
    \   \"IV\",\n        \"I\",\n    );\n    my($i, $roman, $alphabet);", '    return
    undef unless $number > 0 && $number <= 1000;', "    my $base = $number;\n    $number\
    \ -= $base if $number > $base;\n    my $roman = \"\";\n    my $temp;\n    my $k;\n\
    \    while ($base) {\n        $temp = ($number % $base);\n        $roman = $chars[$temp]\
    \ if $temp != 0;\n        $number -= $base;\n        $base = $number * 10;\n \
    \       $number = $temp if $temp != 0;\n    }\n    $roman =~ tr/cm/cm/;\n    $roman\
    \ =~ tr/cm cm/cm/;\n    $roman =~ tr/cd/cd/;\n    $roman =~ tr/cd cd/cd /;\n \
    \   $roman =~ tr/x xx/xx/;\n    $roman =~ tr/x xx xx/xx/;\n    $roman =~ tr/c\
    \ cc/cc/;\n    $roman =~ tr/c cc cc/cc/;\n    $roman =~ tr/d dd./dd/;\n    $roman\
    \ =~ tr/d dd dd./dd/;\n    $roman =~ tr/c cc/cc/;\n    $roman =~ tr/c cc cc/cc/;\n\
    \    $roman =~ tr/d dd./dd/;\n    $roman =~ tr/d dd dd./dd/;\n    $roman =~ tr/l\
    \ ll/ll/;\n    $roman =~ tr/l ll ll/ll/;\n    $roman =~ tr/m mm/mm/;\n    $roman\
    \ =~ tr/m mm mm/mm/;\n    $roman =~ tr/c cc/cc/;\n    $roman =~ tr/c cc cc/cc/;\n\
    \    $roman =~ tr/d dd./dd/;\n    $roman =~ tr/d dd dd./dd/;\n    $roman =~ tr/l\
    \ ll/ll/;\n    $roman =~ tr/l ll ll/ll/;\n    $roman =~ tr/m mm/mm/;\n    $roman\
    \ =~ tr/m mm mm/mm/;\n    $roman =~ tr/m mm/mm/;\n    return $roman;\n}", "  \
    \  my @roman = ();\n    my $i = 1;\n    my $cur = -1;", "    $number = abs($number);\n\
    \    if ($number < 1 || $number > 1000) {\n       return \"?\";\n    }\n    my($ret);\n\
    \    my $count = 1;\n    $ret .= \"x\";\n    while ($number >= 10) {\n       \
    \ $number = $number / 10;\n        $count++;\n        $ret .= \"m\" . ($count\
    \ - 1);\n    }\n    $ret .= $number . \" \";\n    while ($number >= 100) {\n \
    \       $number = $number / 100;\n        $count++;\n        $ret .= \"c\" . ($count\
    \ - 1);\n    }\n    $ret .= $number . \" \";\n    while ($number >= 50) {\n  \
    \      $number = $number / 50;\n        $count++;\n        $ret .= \"d\" . ($count\
    \ - 1);\n    }\n    $ret .= $number . \" \";\n    while ($number >= 20) {\n  \
    \      $number = $number / 20;\n        $count++;\n        $ret .= \"b\" . ($count\
    \ - 1);\n    }\n    $ret .= $number . \" \";\n    while ($number >= 10) {\n  \
    \      $number = $number / 10;\n        $count++;\n        $ret .= \"m\" . ($count\
    \ - 1);\n    }\n    $ret .= $number . \" \";\n    while ($number >= 5) {\n   \
    \     $number = $number / 5;\n        $count++;\n        $ret .= \"c\" . ($count\
    \ - 1);\n    }\n    $ret .= $number . \" \";\n    while ($number >= 1) {\n   \
    \     $number = $number / 1;\n        $count++;\n        $ret .= \"x\" . ($count\
    \ - 1);\n    }\n    return lc($ret);\n}", "    my $roman = \"\";\n    my $num;\n\
    \    my $remainder;\n    my $max;\n    my $digit;\n    my $i;\n    my $k;\n  \
    \  my $l = 0;\n    my $numlen = length($number);\n    for($i = 0; $i <= $numlen;\
    \ $i++) {\n        $l = ($i % 3);\n        if($l == 0 && $i > 0) {\n         \
    \   $roman .= \"M\";\n        } elsif ($l != 0) {\n            $roman .= \"I\"\
    ;\n        }\n    }\n    $num = int $number;\n    $max = int $max;\n    $remainder\
    \ = $num % $max;\n    for(; $num <= $max; $num++) {\n        $k = int $num / $max;\n\
    \        $digit = $num % $max;\n        $roman .= substr($roman, 0, $l == 0 ?\
    \ ($k) : ($k - 2));\n        $roman .= substr($digit, 0, $l == 0 ? ($k) : ($k\
    \ - 2));\n    }\n    $roman .= substr($remainder, 0, $l == 0 ? ($max) : ($max\
    \ - 2));\n    return $roman;\n}", "    my(@string)    = (); # Accumulator.\n \
    \   my($i          ) = 0;", "    $number += 0;\n    $number = sprintf \"%03d\"\
    , $number;", "    my $roman = \"\";\n    while(1 > 0) {\n        my $remainder\
    \ = $number % 4;\n        $roman .= \"$mini_roman[$remainder]\";\n        $number\
    \ -= $remainder;\n        $number /= 4;\n    }\n    return $roman;\n}", "    my\
    \ @digits = split(\"\", $number);\n    my $sum = \"\";\n    my $num_roman = 0;\n\
    \    my $i = 0;\n    \n    while ($i < @digits) {\n        $num_roman += $digits[$i];\n\
    \        \n        # See if $num_roman can be represented by the Roman number\n\
    \        # by adding 'I' to the remainder of the division of\n        # $num_roman\
    \ by 1000000 (the Miller number), rounded down\n        if ($num_roman < 1000000)\
    \ {\n            $sum += \"I\";\n            $num_roman = $num_roman - 1000000;\n\
    \        } else {\n            $sum += \"V\";\n            $num_roman = $num_roman\
    \ - 1000;\n        }\n        $i++;\n    }\n    return $sum;\n}", "    my($roman,\
    \ $char);\n    my($numerals, $chars);\n    my($i) = 0;\n    my($count, $last);",
  '    my $roman;', "    my @roman;\n    my $prev_num = 0;\n    my $num = 0;\n   \
    \ my $roman;\n    my $j = 0;", "    return undef unless $number =~ /^\\d+$/;\n\
    \    $number = int($number);\n    $roman = \"\";\n    while ($number > 0) {\n\
    \        my $r = substr(_roman_numeral_symbols(), $number % 5 + 1, 1);\n     \
    \   $roman .= $r if defined $r;\n        $number /= 5;\n    }\n    return lc($roman);\n\
    }", "    my(@results);\n    my $roman = \"\";\n    my $remainder = $number;\n\
    \    my $count = 1;\n    my $num_roman = '';\n    while (1) {\n        if ($remainder\
    \ >= 1000) {\n            $count++;\n            $remainder -= 1000;\n       \
    \ }\n        if ($remainder >= 900) {\n            $count++;\n            $remainder\
    \ -= 900;\n        }\n        if ($remainder >= 500) {\n            $count++;\n\
    \            $remainder -= 500;\n        }\n        if ($remainder >= 400) {\n\
    \            $count++;\n            $remainder -= 400;\n        }\n        if\
    \ ($remainder >= 100) {\n            $count++;\n            $remainder -= 100;\n\
    \        }\n        my $temp_roman = $num_roman + $remainder;\n        if ($remainder\
    \ >= 10) {\n            $count++;\n            $remainder -= 10;\n        }\n\
    \        if ($remainder >= 5) {\n            $count++;\n            $remainder\
    \ -= 5;\n        }\n        if ($remainder >= 4) {\n            $count++;\n  \
    \          $remainder -= 4;\n        }\n        if ($remainder >= 1) {\n     \
    \       $count++;\n            $remainder -= 1;\n        }\n        $num_roman\
    \ = $temp_roman;\n        push(@results, $num_roman);\n        $roman = $temp_roman\
    \ + $roman;\n        if (!$remainder) {\n            break;\n        }\n    }\n\
    \    my $roman_numeral = join('', @results);\n    $roman_numeral =~ s/^0+//;\n\
    \    $roman_numeral =~ s/^([a-z])/I$1/;\n    $roman_numeral =~ s/^([a-z])/IX$1/;\n\
    \    $roman_numeral =~ s/^([a-z])/IXL$1/;\n    $roman_numeral =~ s/^([a-z])/IXLL$1/;\n\
    \    $roman_numeral =~ s/^([a-z])/IIX$1/;\n    $roman_numeral =~ s/^([a-z])/IIXL$1/;\n\
    \    $roman_numeral =~ s/^([a-z])/IIXLL$1/;\n    $roman_numeral =~ s/^([a-z])/L$1/;\n\
    \    $roman_numeral =~ s/^([a-z])/XL$1/;\n    $roman_numeral =~ s/^([a-z])/XC$1/;\n\
    \    $roman_numeral =~ s/^([a-z])/C$1/;\n    $roman_numeral =~ ", "    if ($number\
    \ < 1) {\n\tdie \"Invalid roman-numeral conversion: $number\\n\";\n    }\n   \
    \ my $roman = \"MCMXCIV\";\n    my $remainder;\n    my $index = scalar (@$roman);\n\
    \    $remainder = $number % 10;\n    my $i = 1;\n    while (scalar @$roman > 0)\
    \ {\n\t$remainder -= $roman[$index];\n\t$index++;\n\t$roman[$index] = \"0\"; #\
    \ zero padding\n\t$i++;\n\tif ($remainder < 0) {\n\t    $roman[$index] = $roman[$index]\
    \ . $roman[$index - 1];\n\t    $remainder = -$remainder;\n\t}\n    }\n    if ($remainder\
    \ > 0) {\n\tdie \"Invalid roman-numeral conversion: $number\\n\";\n    }\n   \
    \ return join '', @$roman;\n}", '    my($first_letter, $rest);', "    my @roman;\n\
    \    my $i = 0;\n    while (1) {\n        if ($i >= 9) { # out of range\n    \
    \        die \"Invalid integer ($number)\\n\";\n        }\n        push @roman,\
    \ \"$bases[$i]*$nums[$i]\";\n        $i = ($i + 1) % 10;\n        $nums[$i] =\
    \ $nums[$i] * 1000;\n        if ($i >= 5) {\n            my $mul = $nums[$i] /\
    \ 100;\n            my $rem = $nums[$i] % 100;\n            push @roman, \"$mul\"\
    \ . ($rem > 9 ? \"I$rem\" : \"\"); # I for infinity\n            $nums[$i] = $mul;\n\
    \        }\n        $number = $number - $nums[$i];\n    }\n    return join(\"\"\
    , map {lc $_} @roman);\n}", '    my(@results);', "    die \"invalid input: $number\"\
    \ if $number < 1 || $number > 1000;\n    my($first_thousand, $rest) = $number\
    \ >= 1000 ? split(//, $number % 1000) : ();\n    my $roman = $rest;\n    # Handle\
    \ 1-digit numbers\n    if ($first_thousand == 1) {\n        my $hundreds = substr($roman,\
    \ 0, 1);\n        $roman .= 'xx' if length($roman) == 1;\n        $roman .= $hundreds;\n\
    \    }\n    # Handle 2-digit numbers\n    elsif ($first_thousand == 2) {\n   \
    \     my $hundreds = substr($roman, 0, 2);\n        $roman .= 'xx' if length($roman)\
    \ == 2;\n        $roman .= $hundreds;\n        my $tens = substr($roman, 1);\n\
    \        $roman .= 'xx' if length($roman) == 3;\n        $roman .= $tens;\n  \
    \  }\n    # Handle 3-digit numbers\n    elsif ($first_thousand == 3) {\n     \
    \   my $hundreds = substr($roman, 0, 3);\n        $roman .= 'xx' if length($roman)\
    \ == 4;\n        $roman .= $hundreds;\n        my $tens = substr($roman, 1);\n\
    \        $roman .= 'xx' if length($roman) == 5;\n        $roman .= $tens;\n  \
    \      my $units = substr($roman, 2);\n        $roman .= 'ii' if length($roman)\
    \ == 6;\n        $roman .= $units;\n    }\n    # Handle 4-digit numbers\n    elsif\
    \ ($first_thousand == 4) {\n        my $hundreds = substr($roman, 0, 4);\n   \
    \     $roman .= 'xx' if length($roman) == 5;\n        $roman .= $hundreds;\n \
    \       my $tens = substr($roman, 1);\n        $roman .= 'xx' if length($roman)\
    \ == 6;\n        $roman .= $tens;\n        my $units = substr($roman, 2);\n  \
    \      $roman .= 'ii' if length($roman) == 7;\n        $roman .= $units;\n   \
    \     my $units_2 = substr($roman, 3);\n        $roman .= 'iii' if length($roman)\
    \ == 8;\n        $roman .= $units_2;\n    }\n    # Handle 5-digit numbers\n  \
    \  elsif ($first_thousand == 5) {\n        my $hundreds = substr($roman, 0, 5);\n\
    \        $roman .= 'xx' if length", "    return '' unless $number =~ /^[1-9][0-9]+$/;\n\
    \    my($roman_numeral) = '';\n    while($number >= 1000) {\n        $roman_numeral\
    \ .= 'M';\n        $number -= 1000;\n    }\n    while($number >= 500) {\n    \
    \    $roman_numeral .= 'D';\n        $number -= 500;\n    }\n    while($number\
    \ >= 100) {\n        $roman_numeral .= 'C';\n        $number -= 100;\n    }\n\
    \    while($number >= 50) {\n        $roman_numeral .= 'L';\n        $number -=\
    \ 50;\n    }\n    while($number >= 10) {\n        $roman_numeral .= 'X';\n   \
    \     $number -= 10;\n    }\n    while($number >= 1) {\n        $roman_numeral\
    \ .= 'V';\n        $number -= 1;\n    }\n    return \"$roman_numeral\";\n}", " \
    \   $number ||= 0;\n    \n    if ($number >= 1000) {\n        $number -= 100;\n\
    \        return \"v\" if $number < 50;\n        return \"l\" if $number < 20;\n\
    \        return \"c\" if $number < 10;\n        return \"m\" if $number == 10;\n\
    \        return \"d\" if $number == 20;\n    }\n    \n    if ($number >= 500)\
    \ {\n        $number -= 500;\n        return \"l\" if $number < 100;\n       \
    \ return \"x\" if $number < 50;\n        return \"c\" if $number < 20;\n     \
    \   return \"m\" if $number == 20;\n        return \"d\" if $number == 50;\n \
    \   }\n    \n    if ($number >= 100) {\n        $number -= 100;\n        return\
    \ \"c\" if $number < 50;\n        return \"m\" if $number == 50;\n        return\
    \ \"d\" if $number == 100;\n    }\n    \n    if ($number >= 50) {\n        $number\
    \ -= 50;\n        return \"m\" if $number < 100;\n        return \"d\" if $number\
    \ == 100;\n    }\n    \n    if ($number >= 20) {\n        $number -= 20;\n   \
    \     return \"d\" if $number < 50;\n    }\n    \n    if ($number >= 10) {\n \
    \       return \"c\" if $number == 10;\n    }\n    \n    if ($number == 1) {\n\
    \        return \"m\";\n    }\n    \n    return \"n\";\n}", "    return '' if\
    \ ($number <= 0);\n    my(@roman_number) = ('M','CM','D','CD','C','XC','L','XL','X','IX','V','IV','I');\n\
    \    my(@roman_values) = ('','','','','','','','','','','','','','','','','','','');\n\
    \    my($numerals, $i, $roman_number, $roman_value);\n    for ($i = 0; $i < length($number);\
    \ $i++) {\n        if ($number % 1000 <= 3) {\n            $roman_number[$i] =\
    \ $roman_number[0];\n        }\n        elsif ($number % 100 >= 4) {\n       \
    \     $roman_number[$i] = $roman_number[1];\n        }\n        elsif ($number\
    \ % 10 >= 5) {\n            $roman_number[$i] = $roman_number[2];\n        }\n\
    \        else {\n            $roman_number[$i] = $roman_number[3];\n        }\n\
    \    }\n    for (@roman_number) {\n        $roman_value = substr(@roman_values,\
    \ $i, 1);\n        $number -= $roman_value;\n        $numerals .= $roman_value;\n\
    \    }\n    $numerals = substr($numerals, 0, 1);\n    return lc($numerals);\n}",
  "    my $i = 0;\n    my $roman = \"\";\n    my $numerals = (\"M\", \"CM\", \"D\"\
    , \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\");\n\
    \    while ($number >= 1000) {\n        $number -= 1000;\n        $roman .= $numerals[$i];\n\
    \        ++$i;\n    }\n    $roman .= $numerals[$i];\n    $roman .= substr($numerals,\
    \ $i+1);\n    return $roman;\n}", '    my(@romans);', "    $number = abs($number);\n\
    \    if ($number < 1000) {\n        # Just convert to roman numerals, no restrictions\n\
    \        $roman = $number; # just save the original\n    }\n    elsif ($number\
    \ < 5000) {\n        # Okay, we need to handle the first 5-10 digits\n       \
    \ my $roman = \"\";\n        for (my $i = $number; $i < 5000 && $i < ($number\
    \ + 5); $i++) {\n            $roman .= int_to_roman($i);\n        }\n        if\
    \ ($roman eq \"\") {\n            $roman = \"0\"; # if the number is too large,\
    \ force it to 0\n        }\n        $roman .= \"M\"; # for the last digit\n  \
    \      return $roman;\n    }\n    # Okay, the number is too large\n    my $roman\
    \ = \"\";\n    for (my $i = $number; $i < 5000; $i++) {\n        $roman .= int_to_roman($i);\n\
    \    }\n    if ($roman eq \"\") {\n        $roman = \"0\"; # if the number is\
    \ too large, force it to 0\n    }\n    $roman .= \"M\"; # for the last digit\n\
    \    return $roman;\n}", "    return \"\" if $number < 1;\n    my(@roman) = ();",
  "    if (not (1 <= $number && $number <= 1000)) {\n        return \"INVALID NUMBER:\
    \ Invalid input number\";\n    }", '    my($roman, $i, $str);', "    $number =\
    \ int2roman($number);\n    $number =~ s/^m//;\n    return $number;\n}", '    $number
    = abs($number);', "    my(@roman) = (\"I\", \"II\", \"III\", \"IV\", \"V\", \"\
    VI\", \"VII\", \"VIII\", \"IX\");\n    my($result) = \"\";\n    my($last_numeral)\
    \ = -1;", "    my($roman, $output);\n    if ($number < 1) {\n        die \"Number\
    \ must be positive\";\n    }\n    if ($number < 1000) {\n        $roman = \"x\"\
    ;\n    }\n    elsif ($number < 1000000) {\n        $roman = \"c\";\n    }\n  \
    \  elsif ($number < 1000000000) {\n        $roman = \"l\";\n    }\n    elsif ($number\
    \ < 1000000000000) {\n        $roman = \"xl\";\n    }\n    elsif ($number < 1000000000000000)\
    \ {\n        $roman = \"xc\";\n    }\n    elsif ($number < 10000000000000000)\
    \ {\n        $roman = \"ix\";\n    }\n    elsif ($number < 100000000000000000)\
    \ {\n        $roman = \"v\";\n    }\n    elsif ($number < 1000000000000000000)\
    \ {\n        $roman = \"iv\";\n    }\n    else {\n        $roman = \"i\";\n  \
    \  }\n    while (1) {\n        $output .= $roman;\n        if ($number % 1000\
    \ != 0) {\n            $output .= \"M\";\n        }\n        my $new_number =\
    \ $number / 1000;\n        $number = $new_number % 1000;\n    }\n    return $output\
    \ . lc($number);\n}", "    \n    # Error if number is less than 1\n    die \"\
    int_to_mini_roman() called with argument < 1\\n\" if $number < 1;", "    my $num\
    \ = $number;\n    my $mini_roman = \"\";\n    my $num_in_roman = 0;", '    my
    %valid_int = map {$_ => 1} qw(1 5 10 20 50 100 200 400 500 1000 );', "    my $roman\
    \ = $number % 5 + 1000;\n    $roman -= $number % 10;\n    $roman += 1000;\n  \
    \  $roman -= $number % 100;\n    $roman += $number % 10;\n    my @romans = (\"\
    M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\"\
    , \"IV\", \"I\");\n    my $mini_roman = 0;\n    for my $r (@romans) {\n      \
    \  my $count = $roman / $r;\n        $mini_roman += $count * $r;\n        $roman\
    \ -= $count * $r;\n    }\n    $mini_roman += $roman;\n    return $mini_roman;\n\
    }", "    $number ||= 0;\n    if ($number < 1 ||\n        $number > 1000 ||\n \
    \       !defined $roman_numbers) {\n        $roman_numbers = &get_roman_numbers();\n\
    \    }\n    return $roman_numbers->[$number];\n}", "    die \"negative numbers\
    \ not allowed\" unless $number >= 0;\n    return undef unless $number <= 1000;\n\
    \    my($roman, $last, $lastChar) = ('',0,'');\n    my($i,$j,$k,$l,$m,$n,$o) =\
    \ (1,0,0,0,0);\n    my(@list) = ( \"\",\n        \"C\", \"CC\", \"CCC\", \"CD\"\
    , \"D\", \"DC\", \"DCC\",\n        \"DCCC\", \"CM\",\n        \"XC\",\n      \
    \  \"L\", \"XL\", \"XC\", \"XL\", \"X\", \"XX\", \"XC\", \"XC\", \"XC\",\n   \
    \     \"L\", \"L\", \"L\",\n        \"I\", \"II\", \"III\",\n        \"V\", \"\
    V\",\n        \"IV\", \"VI\",\n        \"I\", \"I\",\n        \"M\"\n    );\n\
    \    foreach $i (0 .. $number) {\n        $j = 0;\n        $lastChar = $list[$k][$j];\n\
    \        $l += $j;\n        $k += 1;\n        $m += $k;\n        $n += $m;\n \
    \       last if $lastChar;\n        if ($number % $i == 0) {\n            $roman\
    \ .= $lastChar;\n            $lastChar = $list[$k][$j];\n            $l += $j;\n\
    \            $k += 1;\n            $m += $k;\n            $n += $m;\n        }\n\
    \    }\n    return undef unless $lastChar;\n    return substr($roman, 1);\n}",
  "    my (@roman, $result);\n    for (my $i = 2 ; $i <= $number ; $i++) {\n     \
    \   push(@roman, $i),\n    }\n    for ($i = 0; $i < $number ; $i++) {\n      \
    \  my $last = pop(@roman);\n        my $lastChar = substr($roman[($i - 1)],0,1);\n\
    \        $roman[$i] = $lastChar.$roman[$i];\n    }\n    return join('',@roman);\n\
    }", '    my($roman, $result);', '    my($roman_string) = "";', "    my(@result)\
    \ = '';\n    my $roman = @roman_numerals;\n    for my $i (0..$#roman) {\n    \
    \    if ($number == $roman[$i]) {\n            $result .= $roman[$i];\n      \
    \      last;\n        }\n    }\n    return $result;\n}", "    my(@roman_numerals);\n\
    \    # Fill up @roman_numerals.\n    # Note that @roman_numerals does not start\
    \ with an element for\n    # zero, as that would cause problems when shifting\
    \ by one.\n    push @roman_numerals, 1, 5, 10, 40, 50, 90, 100, 400, 500, 900,\
    \ 1000;\n    # Determine whether the number is in range.\n    my $in_range = 0;\n\
    \    for(my $i=1;$i <= $number;$i++) {\n        if($number >= $roman_numerals[$i])\
    \ {\n            $in_range = 1;\n            last;\n        }\n    }\n    if(!\
    \ $in_range) {\n        die \"Invalid number: $number\";\n    }\n    my $result\
    \ = '';\n    my $shift = 0;\n    for(my $i=0;$i<@roman_numerals;$i++) {\n    \
    \    my $num = $roman_numerals[$i];\n        if($shift < $num) {\n           \
    \ $result = $roman_numerals[$i];\n            $shift = $num;\n        } elsif($num\
    \ == $shift) {\n            $result .= \"{$roman_numerals[$i]}\";\n          \
    \  $shift += $num;\n        } else {\n            $result .= \"{$roman_numerals[$i]}x\"\
    ;\n            $shift += $num;\n        }\n    }\n    $result;\n}\n</code>\n<|/\
    \ a tags=integer,roman |>\n<| a tags=integer,roman |>\n<code>\nint inttoroman(int\
    \ num)\n{\n    struct roman\n    {\n        char *roman[13]={'M','CM','D','CD','C','XC','L','XL','X','IX','V','IV','I'},\n\
    \        roman_sign[13]={'-','+','+','+','+','+','+','+','-','-','-','-','-','-','-'},\n\
    \        roman_num[13]={1000,900,500,400,100,90,50,40,10,9,5,4,1,6};\n    }",
  "    $number = abs($number);\n    # Round down to the closest even number\n    $number\
    \ = (3 * $number / 4) - 1;\n    # Convert the number to a string\n    $number\
    \ += \"\";\n    # Add an 'i' to the string\n    substr($number,0,0) = \"i\";\n\
    \    # Determine how long the string is\n    my $length = length($number);\n \
    \   # Determine how long the string should be if the number is odd\n    my $length_odd\
    \ = $length % 2 ? length($number) - 1 : length($number);\n    # Add 'i's until\
    \ it is the right length\n    for (my $i = $length_odd; $i < $length; $i += 2)\
    \ {\n        substr($number, $i, 0) = \"i\";\n    }\n    # Convert the string\
    \ to a lowercase string\n    $number =~ tr/a-zA-Z//cd;\n    return $number;\n}",
  "    my($roman, $result) = (\"\", \"\");\n    \n    # Handle the special cases of\
    \ numbers < 10.\n    # These will remain in their original integer form\n    #\
    \ in their Roman numeral equivalent\n    if( $number <= 9 ) {\n        $result\
    \ = $number++;\n        $roman = $result;\n    } elsif( $number <= 999 ) {\n \
    \       my $tens = $number % 10;\n        $roman = $tens;\n        $result = $number\
    \ / 10;\n    } elsif( $number <= 999999 ) {\n        my $tens = $number % 1000;\n\
    \        $roman = ($tens / 100);\n        $result = $number / 1000;\n    } elsif(\
    \ $number <= 9999999 ) {\n        my $tens = $number % 100000;\n        $roman\
    \ = ($tens / 1000);\n        $result = $number / 100000;\n    } elsif( $number\
    \ <= 999999999 ) {\n        my $tens = $number % 1000000;\n        $roman = ($tens\
    \ / 10000);\n        $result = $number / 1000000;\n    } elsif( $number <= 99999999999\
    \ ) {\n        my $tens = $number % 1000000000;\n        $roman = ($tens / 100000);\n\
    \        $result = $number / 10000000;\n    } elsif( $number <= 999999999999 )\
    \ {\n        my $tens = $number % 10000000000;\n        $roman = ($tens / 1000000);\n\
    \        $result = $number / 1000000000;\n    } elsif( $number <= 999999999999999\
    \ ) {\n        my $tens = $number % 1000000000000;\n        $roman = ($tens /\
    \ 10000000);\n        $result = $number / 10000000000;\n    } elsif( $number <=\
    \ 999999999999999999 ) {\n        my $tens = $number % 100000000000000;\n    \
    \    $roman = ($tens / 100000000);\n        $result = $number / 100000000000;\n\
    \    } elsif( $number <= 999999999999999999999 ) {\n        my $tens = $number\
    \ % 1000000000000000;\n        $roman = ($tens / 1000000000);\n        $result\
    \ = $number / 10000000000000;\n    } elsif( $number <= 9999999999999999999998\
    \ ) {\n        my $tens = $number % 10000000000000000;\n        $roman = ($tens\
    \ / 100000000);\n        $result = $number / 10000000000000;\n    } elsif( $number\
    \ <= 99999999999999999999987 ) {\n        my $tens = $number % 1000000000000000;\n\
    \        $roman", "    my(@alphabet) = $number < 1 ?\n                       \
    \ ('roman_alphabet') :\n                        ('mini_alphabet');\n    my(@roman_alphabet)\
    \ = $number < 1 ?\n                        ('roman_alphabet') :\n            \
    \            ('mini_alphabet');\n    my($roman);\n    my $result;\n    my $index;\n\
    \    my $length = scalar(@alphabet);\n    my $i;\n    for($i = 0; $i < $length;\
    \ $i++) {\n        $index = $number % $length;\n        $roman .= $alphabet[$index];\n\
    \        my $tmp = $number;\n        $number -= $tmp;\n    }\n    if ($number\
    \ == 0) {\n        $result = $roman;\n    } else {\n        $result = &roman_to_int($roman);\n\
    \    }\n    return $result;\n}", "    my $result = \"\";\n    my $roman_numerals;\n\
    \    my $int_to_roman = map { $_ * 100 } 0..61;\n    my $numerals;", "    my @mini_roman\
    \ = ();\n    if ($number < 1000) {\n        $number += 500;\n        push @mini_roman,\
    \ map { ($number % 1000 < 50) ? \"$_\" : chr(ord(\"a\") + $number % 1000 - 500)\
    \ } 1 .. 3;\n    } else {\n        $number -= 1000;\n        push @mini_roman,\
    \ map { ($number % 1000 < 50) ? \"$_\" : chr(ord(\"a\") + $number % 1000 - 500)\
    \ } 4 .. 7;\n    }\n    push @mini_roman, map { ($number % 1000 < 50) ? \"$_\"\
    \ : chr(ord(\"a\") + $number % 1000 - 500) } 8 .. 9;\n    push @mini_roman, map\
    \ { ($number % 1000 < 50) ? \"$_\" : chr(ord(\"a\") + $number % 1000 - 500) }\
    \ 10 .. 99;\n    push @mini_roman, map { ($number % 1000 < 50) ? \"$_\" : chr(ord(\"\
    a\") + $number % 1000 - 500) } 100 .. 499;\n    push @mini_roman, map { ($number\
    \ % 1000 < 50) ? \"$_\" : chr(ord(\"a\") + $number % 1000 - 500) } 500 .. 1000;\n\
    \    return join('', @mini_roman);\n}", "    my($numeral, $roman);\n    if ($number\
    \ < 1) {\n\treturn '?';\n    }\n    \n    # Convert to decimal\n    my($dec) =\
    \ int2dec($number);\n    \n    # Roman numerals\n    my($roman_numerals) = &roman_numerals();\n\
    \    my($i, $j);\n    \n    # Find the highest numeral less than or equal to $dec\n\
    \    for (my $i = 1; $i <= 4; ++$i) {\n\tnext if $roman_numerals{$i} <= $dec;\n\
    \tnext if $roman_numerals{$i} >= 1000;\n\t\n\tmy $tmp_num = $roman_numerals{$i};\n\
    \tif ($tmp_num < $dec) {\n\t    $j = $i;\n\t    $dec = $tmp_num;\n\t    last;\n\
    \t}\n    }\n    \n    if ($i == 4) {\n\t$roman = 'IV';\n    } else {\n\tmy $roman_numeral_tmp\
    \ = $roman_numerals{$j};\n\tmy $remainder = $dec - $roman_numeral_tmp;\n\t\n\t\
    my $new_roman = '';\n\t\n\tfor (my $i = 0; $i < $j; $i++) {\n\t    my $remainder_tmp\
    \ = $remainder * 4;\n\t    $new_roman .= $roman_numeral_tmp + $remainder_tmp;\n\
    \t    $remainder -= $remainder_tmp;\n\t}\n\t$roman = $new_roman;\n    }\n    \n\
    \    return $roman;\n}", "    $number = abs($number);\n    my $roman = \"\";\n\
    \    if ($number == 0) {\n        return $roman;\n    }\n    # Determine number\
    \ of set characters\n    my $nchars = length ($number % 1000);\n    if ($nchars\
    \ == 0) {\n        $nchars = 1;\n    }\n    my @nums = split(\"\", \"\", split\
    \ (\"\", \"\", substr(\"$number\", 0, $nchars)));\n    my $nroman = \"\";\n  \
    \  my $romanchars = \"\";\n    # Build the Roman characters\n    for (@nums) {\n\
    \        if ($_ eq \"\") {\n            $romanchars .= \"_\";\n        } else\
    \ {\n            $romanchars .= substr(&roman_chars($_), 0, 1);\n        }\n \
    \   }\n    # Convert the Roman characters into Mini Roman\n    if ($nchars <=\
    \ 3) {\n        my $n = $nchars;\n        $n -= $n % 3;\n        $roman .= substr(&roman_chars($_),\
    \ 0, $n);\n    } else {\n        my $n = $nchars;\n        $n -= $n % 3;\n   \
    \     $roman .= substr(&roman_chars(\"$n\"), 0, $n);\n    }\n    $roman .= $romanchars;\n\
    \    return $roman;\n}", "    my $roman = \"\";\n    my $roman_num = \"\";\n \
    \   my $roman_num_iter = 1;\n    while ($number != 0) {\n        $roman .= $ROMAN_ARRAY[$number\
    \ % 1000];\n        $number -= $ROMAN_ARRAY[$number % 1000];\n        $roman_num_iter++;\n\
    \    }\n    $roman_num .= $roman;\n    for ($roman_num_iter; $roman_num_iter <=\
    \ $MAX_ITERATIONS; $roman_num_iter++) {\n        $roman .= $ROMAN_ARRAY[$number\
    \ % 1000];\n        $number -= $ROMAN_ARRAY[$number % 1000];\n        $roman_num\
    \ .= $roman;\n    }\n    $roman_num =~ s/^0+//;\n    return lc $roman_num;\n}",
  "    my($roman, $sign) = @_;\n    my($i, $roman, $sign) = @_;\n    my($roman, $sign)\
    \ = @_;\n    my($i, $roman, $sign) = @_;\n    my($roman, $sign) = @_;\n    my($i,\
    \ $roman, $sign) = @_;\n    my($roman, $sign) = @_;\n    my($i, $roman, $sign)\
    \ = @_;\n    my($roman, $sign) = @_;", "    my $result;\n    my @roman = qw[m\
    \ d c l x vi i];\n    my $index = 0;\n    my $roman_index = 0;\n    my $roman_result\
    \ = \"\";\n    while(1) {\n        my $remainder = $number % 10;\n        if($remainder\
    \ < 0) {\n            $remainder = -$remainder;\n            ++$index;\n     \
    \   }\n        $roman_result .= $roman[$roman_index++];\n        $number -= $remainder;\n\
    \        if($roman_index >= @roman) {\n            $roman_index = 0;\n       \
    \     $result .= $roman_result;\n        }\n        if($number == 0) {\n     \
    \       $result = $roman_result;\n            last;\n        }\n    }\n    return\
    \ lc($result);\n}", "    my %lookup = ('M'=>'MM', 'CM'=>'CC', 'D'=>'DD', 'XC'=>'XXX',\n\
    \                 'L'=>'LL', 'XL'=>'XL', 'X'=>'XXX',\n                 'V'=>'VV',\
    \ 'IV'=>'III');\n    my @roman;", "    my $roman = '';", "    my($base) = @_ ?\
    \ $_[0] : 10;\n    my(@roman) = ();", "    my($roman);\n    my($tens);\n    my($hundreds);\n\
    \    my($thousands);\n    my($mini_roman);\n    my($hundreds_suffix);\n    my($thousands_suffix);\n\
    \    my($hundreds_suffix_array);\n    my($thousands_suffix_array);", "    my($roman)\
    \ = '';\n    my($i, $j, $k);", "    my($roman);\n    my($alphabet) = qw(M CM);\n\
    \    my($roman_base) = qw(I IV X XL);\n    my($roman_numeral);\n    $roman = '';\n\
    \    # Handle special cases\n    if ($number <= 0) {\n        die \"Invalid number\
    \ argument: $number\\n\"; # shouldn't happen\n    }\n    if ($number <= 199) {\n\
    \        $roman = $roman_base[$number-1];\n    }\n    elsif ($number <= 999) {\n\
    \        $roman = $roman_base[$number-1];\n    }\n    elsif ($number <= 19999)\
    \ {\n        $roman = $roman_base[$number-1];\n    }\n    elsif ($number <= 999999)\
    \ {\n        $roman = $roman_base[$number-1];\n    }\n    elsif ($number <= 999999999)\
    \ {\n        $roman = $roman_base[$number-1];\n    }\n    else {\n        # Roman\
    \ numerals are weird...\n        $roman = $roman_base[$number-1000000]+\n    \
    \      int_to_mini_roman($number/1000000)+\n          $roman_base[$number%1000000];\n\
    \    }\n    return $roman;\n}", "    my $roman = '';\n    my $i = 0;\n    while(1)\
    \ {\n        my $num = $number % 1000;\n        my $denom = 1000*1000 - $num;\n\
    \        if($denom == 0) {\n            $roman .= 'm' if $i == 0;\n          \
    \  $roman .= 'i' if $i == 1;\n            $roman .= 'v' if $i == 2;\n        \
    \    $roman .= 'x' if $i == 3;\n            $roman .= 'c'; # add 'c' as the final\
    \ character\n            last;\n        }\n        my $c = substr($alphabet, $num\
    \ + $i, 1);\n        $roman .= $c;\n        $number -= $num;\n        $i++;\n\
    \    }\n    return lc($roman);\n}", "    # $number should be an integer.\n   \
    \ return undef unless $number =~ /^\\d+$/;", '    return "" unless $number =~
    /^\d+$/;', "    die \"Invalied number\\n\" unless $number > 0 && $number <= 1000;\n\
    \    my @roman_nums = (0..10)\n        map { $_ + 9 } reverse @_;", "    my($result)\
    \ = \"\";\n    my($roman_num, $remainder);\n    for(my $i = 0; $i <= $number;\
    \ $i++) {\n        $roman_num = $number - $i;\n        $remainder = $roman_num\
    \ % 10;\n        $result = $result.substr($remainder, 1);\n    }\n    return lc($result);\n\
    }", "    $number += 0; # Convert number to decimal for comparison\n    my($alphabet)\
    \ = $number < 1000 ?\n                    (\"M\"   => 1000):\n               \
    \     (\"CM\"  => 900):\n                    (\"D\"   => 500):\n             \
    \       (\"CD\"  => 400):\n                    (\"C\"  => 100):\n            \
    \        (\"XC\" => 90):\n                    (\"L\"   => 50):\n             \
    \       (\"XL\"  => 40):\n                    (\"X\"   => 10):\n             \
    \       (\"IX\"  => 9):\n                    (\"V\"   => 5);\n    my $roman =\
    \ \"\";\n    my $num_digits = $number % 1000;\n    $roman .= substr($alphabet,\
    \ 0, $num_digits);\n    $number -= $num_digits;\n    while ($number >= 1000) {\n\
    \        $roman .= \"M\";\n        $number -= 1000;\n    }\n    $roman .= substr($alphabet,\
    \ 0, $number);\n    return lc($roman);\n}", "    if ($number < 1) {\n        croak\
    \ sprintf(\"Given number must be positive; given number was %d\\n\", $number);\n\
    \    }\n    if ($number < 3) {\n        return \"x\";\n    }\n    my $roman =\
    \ int_to_roman($number);\n    if ($roman eq \"\") {\n        return \"0\";\n \
    \   }\n    my $i = 1;\n    my $miniroman = $roman;\n    my $roman_remainder =\
    \ 0;\n    while ($roman ne \"\") {\n        $roman_remainder = $roman % 10;\n\
    \        $roman /= 10;\n        if ($roman_remainder == 0 && $i <4) {\n      \
    \      $miniroman .= $i; # appending the i'th roman digit\n            $i++; #\
    \ increasing the counter\n        }\n        if ($roman_remainder != 0 && $i <\
    \ 3) {\n            $miniroman .= $i; # appending the i'th roman digit\n     \
    \       $i++; # increasing the counter\n        }\n    }\n    return $miniroman;\n\
    }", "    $number += 1000;\n    my @mini_roman = ( \"M\", \"CM\", \"D\", \"CD\"\
    , \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" );", "   \
    \ my(@mini_roman) = (\"x\",\"c\",\"l\",\"i\",\"d\");\n    my($roman);\n    my($number);\n\
    \    my($first,$second,$roman1);\n    my($first,$second,$roman2);\n    $roman1\
    \ = \"?\";\n    $roman2 = \"?\";\n    my($carry,$i);\n    my(@digits,$digit);",
  "    my @roman = ();\n    my $bases = $number < 1 ||\n               $number > 1000\
    \ ||\n               $number % 10;\n    $number -= $bases;\n    for (my $i = 1;\
    \ $i <= $bases; $i++) {\n        push(@roman, \"$i \");\n    }\n    $number -=\
    \ $bases;\n    for (my $i = 1; $i <= $bases; $i++) {\n        push(@roman, $roman[$i-1]\
    \ . \"$number \" . $roman[$i]);\n    }\n    return join(\"\", @roman);\n}", " \
    \   return unless defined $number;\n    return unless $number > 0;", "    $number\
    \ = 0 unless defined $number;\n    my $roman = '';\n    my $numeral = $number;\n\
    \    my $i = 1;\n    while(!($numeral % 10)) {\n        $roman .= $numeral % 10;\
    \ # add last digit\n        $numeral /= 10;           # remove last digit\n  \
    \      $i++;                    # increase index\n    }\n    $roman .= $numeral\
    \ % 10; # add last digit\n    $roman = uc $roman;           # uppercase roman\
    \ equivalent\n    return $roman;\n}", "    my $mini_roman = int_to_roman($number);\n\
    \    return lc($mini_roman);\n}", '    my($roman, $roman_numeral);', "    # Check\
    \ if number is negative.\n    if ($number < 0) {\n       $number += 1000;\n  \
    \  }\n    my $roman = '';", "    my(@roman_numerals);\n    my($roman, $mini_roman);",
  "    my(@result);\n    if ($number < 1) {\n        $result = (\"i\");\n    }\n \
    \   elsif ($number < 3999) {\n        $result = (\"i$number\");\n    }\n    else\
    \ {\n        my $remainder = $number % 100;\n        $number = $number / 100;\n\
    \        if ($remainder < 500) {\n            $result = (\"c$remainder\");\n \
    \       }\n        else {\n            $result = (\"c\" . int_to_mini_roman($number));\n\
    \        }\n        if ($number < 100) {\n            $result = (\"d$result\"\
    );\n        }\n    }\n    return $result[0];\n}", "    my($roman);\n    my($nums)\
    \ = split(//, $number);\n    my($numerals) = map { (\"M\", \"CM\", \"D\", \"CD\"\
    , \"C\", \"XC\", \"L\", \"XL\", \"X\", \n        \"IX\", \"V\", \"IV\", \"I\"\
    ) } $nums;\n    my(@digits) = sort { $a <=> $b } $numerals;\n    my($last);\n\
    \    my $roman_counter = 1;\n    my($letter);\n    my $last;\n    foreach $last\
    \ (@digits) {\n        $roman .= $letter;\n        $letter =~ s/^(.)//;\n    \
    \    ++$roman_counter;\n        $letter =~ s/^(.)(.)$/$1$2/g;\n    }\n    return\
    \ lc($roman);\n}", '    my @roman_digits = ();', '    my $result;', '    return
    $number if $number < 1;', "    my($roman);\n    my($romanString);\n    my($numberString);\n\
    \    my($resultString);\n    my($romCount);\n    my($miniRomanString);\n    my($romanCount);\n\
    \    my($romanCharCount);\n    my($numberCharCount);\n    my($currentRoman);\n\
    \    my($currentMiniRoman);\n    my($currentRomanChar);\n    my($currentMiniRomanChar);\n\
    \    my($currentNumber);\n    my($currentNumberChar);\n    my($currentRomanCharCount);\n\
    \    my($currentNumberCharCount);\n    my($i);\n    my($j);\n    my($k);", '    my($romanString);',
  "    my $roman;\n    my $base;\n    my $base_to_append;\n    my $miniroman;\n  \
    \  my $result;\n    $roman = '';\n    $base = $number % 10;", "    return $number\
    \ if $number < 1 || $number > 1000;\n    my $result = '';\n    my $nstr = int2str($number);\n\
    \    my $len = length($nstr);\n    for (my $i = 0; $i < $len; $i++) {\n      \
    \  my $pos = $len - $i - 1;\n        $result .= substr($nstr, $pos, 1);\n    \
    \    if ($result =~ /^(.)(.)$/) {\n            $result = $1.$2;\n        }\n \
    \   }\n    return lc($result);\n}", "    my($num, $roman, $char);\n    my($end,\
    \ $tmp, $tmp2, $tmp3);", '    my(@result);', "    my $result = \"\";\n    \n \
    \   # Special cases.\n    if ($number == 0){\n        $result = \"x\";\n    }\n\
    \    elsif ($number < 0 || $number >= 1000){\n        die \"Error: Attempting\
    \ to convert a non-positive integer to mini roman\";\n    }\n    \n    # Normal\
    \ cases.\n    elsif ($number < 10){ \n        $result = \"x$number\"; \n    }\n\
    \    elsif ($number >= 10 && $number <= 20) { \n        $result = $number == 10\
    \ ? \"i\" : \"$number\";\n    }\n    elsif ($number >= 30 && $number <= 40){\n\
    \        $result = $number == 30 ? \"li\" : \"$number\";\n    }\n    elsif ($number\
    \ == 50 || $number == 100){\n        $result = $number == 50 ? \"vi\" : \"$number\"\
    ;\n    }\n    elsif ($number > 100){\n        $result = $number == 1000 ? \"v\"\
    \ : \"$number\";\n    }\n    \n    return $result;\n}", "    my @romans = (\"\
    M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\"\
    , \"IV\", \"I\");\n    my $roman = $romans[$number % 100];\n    $number -= $roman\
    \ * 100;\n    $roman .= $romans[$number % 10];\n    $number -= $roman * 10;\n\
    \    $roman .= $romans[$number];\n    return lc($roman);\n}", "    \n    # special\
    \ case for 0\n    return '' if ($number == 0);\n    \n    my $num_roman = '';\n\
    \    my $divisor = 1;\n    my $tmp;\n    while ($number >= $divisor) {\n     \
    \   $tmp = ($number / $divisor);\n        $num_roman .= $self->{'_roman_to_letter'}->{$tmp};\n\
    \        $number -= $divisor * $tmp;\n        $divisor *= 10;\n    }\n    $num_roman\
    \ .= $self->{'_roman_to_letter'}->{$number}; # add the last one\n    $num_roman\
    \ = uc($num_roman);\n    return $num_roman;\n}", "    return '' if $number < 1\
    \ || $number > 1000;", '    my($roman) = "";', "    my $num_string = \"\";\n \
    \   my $i = 1;", "    my $ret = \"\";\n    while(--$number > 0) {\n        my\
    \ $remainder = abs($number % 10);\n        $ret .= $remainder * 10;\n        $number\
    \ -= $remainder;\n    }\n    my $reversed = $ret;\n    my @chars = split(//, $reversed);\n\
    \    my $roman = \"\";\n    while(@chars) {\n        my $i = pop(@chars);\n  \
    \      $roman .= $i;\n    }\n    return $roman;\n}", "    return unless ($number\
    \ > 1 && $number <= 1000);\n    my($str);\n    $str = \"\";\n    while($number\
    \ != 0) {\n        $str = $str if $number % 10 > 0;\n        $str = $str . $_[$number\
    \ % 10];\n        $number /= 10;\n    }\n    return lc($str);\n}", "    my $str\
    \ = '';\n    my @chars = ('I','V','X','L','C','D','M');\n    while ($number >=\
    \ 1000) {\n        $number = ($number % 1000);\n        my $r = (($number / 1000)\
    \ % 10);\n        $str .= $chars[$r];\n    }\n    $str .= $chars[$number % 10];\n\
    \    return $str;\n}", "    my(@result) = ();\n    my @digits = ($number);\n \
    \   my($i, $j);", "    my(@mini_roman) = (\"\");\n    my ($roman, $i);\n    my\
    \ $x = 0;", "    return \"\" unless $number;\n    my $num = abs($number);\n  \
    \  my $output = '';\n    my $digits = \"\";\n    # Iterate from largest to smallest\
    \ and add digits one at a time\n    my $roman = $num;\n    $roman = ~s/^(-?\\\
    d+)//;\n    while (length($roman)) {\n        $digits = substr($roman, 0, 1);\n\
    \        $roman =~ s/^(-?\\d+)//;\n        $output .= $digits if length($digits);\n\
    \    }\n    $output =~ tr/IVXLCDMURQX/IVXLCDMURQ/;\n    return $output;\n}", " \
    \   my(@roman , @roman , @roman , @roman , @roman , @roman , @roman , @roman ,\
    \ @roman , @roman , @roman , @roman , @roman );\n    if ($number > 1000) {\n \
    \       $number -= 1000;\n        $roman[0] = $roman [0] = 'C';\n        $roman[1]\
    \ = $roman [2] = 'D';\n        $roman[3] = $roman [4] = 'E';\n        $roman[5]\
    \ = $roman [6] = 'F';\n        $roman[7] = $roman [8] = 'G';\n        $roman[9]\
    \ = $roman [10] = 'H';\n        $roman[11] = $roman [12] = 'X';\n        $roman[13]\
    \ = $roman [14] = 'I';\n        $roman[15] = $roman [16] = 'J';\n        $roman[17]\
    \ = $roman [18] = 'K';\n        $roman[19] = $roman [20] = 'L';\n        $roman[21]\
    \ = $roman [22] = 'M';\n        $roman[23] = $roman [24] = 'N';\n        $roman[25]\
    \ = $roman [26] = 'O';\n        $roman[27] = $roman [28] = 'P';\n        $roman[29]\
    \ = $roman [30] = 'Q';\n        $roman[31] = $roman [32] = 'R';\n        $roman[33]\
    \ = $roman [34] = 'S';\n        $roman[35] = $roman [36] = 'T';\n        $roman[37]\
    \ = $roman [38] = 'V';\n        $roman[39] = $roman [40] = 'W';\n        $roman[41]\
    \ = $roman [42] = 'X';\n        $roman[43] = $roman [44] = 'Y';\n        $roman[45]\
    \ = $roman [46] = 'Z';\n        $roman[47] = $roman [48] = '0';\n    } else {\n\
    \        if ($number < 100) {\n            $roman[0] = $roman [0] = 'C';\n   \
    \         $roman[1] = $roman [2] = 'D';\n            $roman[3] = $roman [4] =\
    \ 'E';\n            $roman[5] = $roman [6] = 'F';\n            $roman[7] = $roman\
    \ [8] = 'G';\n            $roman[9] = $roman [10] = 'H';\n            $roman[",
  '    my($roman);', "    $number += 40;\n    if ($number < 0) {\n        $number\
    \ *= -1;\n        $number -= 41;\n    }\n    my @a = ('M','D','C','L','X','V','I');\n\
    \    my @b = ('M','C','D','L','X','V','I');\n    my @c = ('X','C','D','L','V','I');\n\
    \    my @d = ('X','C','L','D','V','I');\n    my @e = ('X','C','D','V','L','I');\n\
    \    my @f = ('X','C','D','V','I','L');\n    my @g = ('C','D','L','V','I','X');\n\
    \    my @h = ('C','D','V','I','X','L');\n    my @i = ('C','D','V','I','X','X');\n\
    \    my @j = ('C','D','L','X','X','V','I');\n    my @k = ('C','D','V','I','X','X','L');\n\
    \    my @l = ('C','D','V','I','X','X','X');\n    my @m = ('C','D','L','X','X','X','V','I');\n\
    \    my @n = ('C','D','V','I','X','X','X','L');\n    my @o = ('C','D','V','I','X','X','X','X');",
  '    die "Invalid number provided" unless $number > 0;', "    return $number unless\
    \ $number =~ /^[0-9]+$/;\n    my $miniroman;\n    if ($number < 100) {\n     \
    \   $miniroman = $number < 10 ? \"cm\" : \"cd\";\n    } elsif ($number < 400)\
    \ {\n        $miniroman = \"d\";\n    } elsif ($number < 700) {\n        $miniroman\
    \ = \"cd\";\n    } elsif ($number < 1000) {\n        $miniroman = \"xc\";\n  \
    \  } else {\n        $miniroman = \"ix\";\n    }\n    my @miniroman = reverse\
    \ split //, $miniroman;\n    return reverse join \"\", map { substr($_, 0, 1)\
    \ } @miniroman;\n}", "    my $result = '';\n    my $i = 1;\n    my $n = $number;\n\
    \    my $roman_numeral;", "    return undef unless $number > 0 && $number <= 1000;\n\
    \    my $roman;\n    my $remainder = $number % 1000;\n    $roman .= int2roman($remainder);\n\
    \    $number -= $remainder;\n    $roman .= int2roman($number % 1000);\n    $number\
    \ -= $number % 1000;\n    $roman .= int2roman($number);\n    $number -= $number;\n\
    \    return $roman;\n}", "    my($roman, $number);\n    $roman = \"\";\n    $number\
    \ = abs($number);\n    if ($number >= 1000) {\n        $number -= 1000;\n    \
    \    $roman = \"M\";\n    }\n    if ($number >= 500) {\n        $number -= 500;\n\
    \        $roman = \"CM\";\n    }\n    if ($number >= 100) {\n        $number -=\
    \ 100;\n        $roman = \"D\";\n    }\n    if ($number >= 50) {\n        $number\
    \ -= 50;\n        $roman = \"CD\";\n    }\n    if ($number >= 10) {\n        $number\
    \ -= 10;\n        $roman = \"C\";\n    }\n    if ($number >= 5) {\n        $number\
    \ -= 5;\n        $roman = \"XC\";\n    }\n    if ($number >= 1) {\n        $number\
    \ -= 1;\n        $roman = \"L\";\n    }\n    if ($number == 0) {\n        $roman\
    \ = \"\";\n    }\n    $roman .= $number;\n    return lc($roman);\n}", "    my(@rom);\n\
    \    my($i, $j, $k);\n    my($roman_number);\n    my $counter = 0;\n    foreach\
    \ $i (1 .. $number) {\n        if ($i > 9) {\n            $rom[$counter++] .=\
    \ $i;\n            $rom[$counter++] .= \"x\";\n        }\n        else {\n   \
    \         $rom[$counter++] .= $i;\n        }\n    }\n    foreach $i (0 .. $number)\
    \ {\n        for ($j = int(rand(@rom[$counter++])); $j > 0; $j--, $k++) {\n  \
    \          $rom[$counter++] = $rom[$k];\n        }\n    }\n    foreach $i (0 ..\
    \ $number) {\n        $roman_number = '';\n        for ($j = int(rand(@rom[$counter++]));\
    \ $j > 0; $j--, $k++) {\n            $roman_number .= $rom[$k];\n        }\n \
    \       $roman_number =~ tr/MLXCDMIV/XMCDF/;\n    }\n    $roman_number =~ tr/MLXCDMIV/XMCDF/;\n\
    \    $roman_number =~ tr/lcl/LLC/;\n    $roman_number =~ tr/rcl/RCCL/;\n    $roman_number\
    \ =~ tr/ucl/UCL/;\n    $roman_number =~ tr/lcr/LCR/;\n    $roman_number =~ tr/rcr/RCR/;\n\
    \    $roman_number =~ tr/ucr/UCR/;\n    $roman_number =~ tr/plq/PLT/;\n    $roman_number\
    \ =~ tr/pqr/PRP/;\n    $roman_number =~ tr/spl/SPL/;\n    $roman_number =~ tr/spr/SPR/;\n\
    \    $roman_number =~ tr/plt/PLT/;\n    $roman_number =~ tr/prr/PRP/;\n    $roman_number\
    \ =~ tr/cll/CLL/;\n    $roman_number =~ tr/crl/CRL/;\n    $roman_number =~ tr/cul/CUL/;\n\
    \    $roman_number =~ tr/cul/CUL/;\n    $roman_number =~ tr/plc/PLC/;\n    $roman_number\
    \ =~ tr/prc/PRC/;\n    $roman_number =~ ", "    my $string = \"\";\n    my $temp\
    \ = 0;\n    while (1) {\n        if ($number >= 1000) {\n            $string .=\
    \ \"M\";\n            $number -= 1000;\n        } else {\n            my $remainder\
    \ = $number;\n            $number -= $temp;\n            $string .= \"CM\";\n\
    \            if ($temp == 0 && $remainder >= 5) {\n                $string .=\
    \ \"D\";\n                $remainder -= 5;\n            } elsif ($temp == 0) {\n\
    \                $string .= \"C\";\n            } elsif ($temp == 1) {\n     \
    \           $string .= \"XC\";\n                $remainder -= 1;\n           \
    \ } elsif ($temp == 2 && $remainder >= 1) {\n                $string .= \"L\"\
    ;\n                $remainder -= 1;\n            } elsif ($temp == 2) {\n    \
    \            $string .= \"XL\";\n                $remainder -= 1;\n          \
    \  } elsif ($temp == 3 && $remainder >= 1) {\n                $string .= \"X\"\
    ;\n                $remainder -= 1;\n            } elsif ($temp == 3) {\n    \
    \            $string .= \"IX\";\n                $remainder -= 1;\n          \
    \  } elsif ($temp == 4 && $remainder >= 1) {\n                $string .= \"V\"\
    ;\n                $remainder -= 1;\n            } elsif ($temp == 4) {\n    \
    \            $string .= \"IV\";\n                $remainder -= 1;\n          \
    \  } elsif ($temp == 5 && $remainder >= 1) {\n                $string .= \"I\"\
    ;\n                $remainder -= 1;\n            } else {\n                $string\
    \ .= \"I\";\n            }\n            $temp++;\n        }\n        return lc($string);\n\
    \    }\n}", '    my(@result);', '    my($rom);', "    return \"\";\n    # Base\
    \ case: just return the number.\n    return $number if $number <= 1;\n    # Recursion:\n\
    \    # Find number of repeating digits first\n    my($numDigits) = &numDigits($number);\n\
    \    if ($numDigits == 0) {\n        return $number;\n    }\n    # Add as many\
    \ 'M's as necessary.\n    $numDigits += length($number);\n    $numDigits %= 3;\n\
    \    for (1 .. $numDigits) {\n        $number = \"M$number\";\n    }\n    # Find\
    \ the rest of the digits, beginning with the biggest.\n    $number = substr $number,\
    \ length($number) - $numDigits;\n    # Handle case of zero-padded number.\n  \
    \  $number .= 'M' if ($number !~ /^0/);\n    return $number;\n}", "    if ($number\
    \ < 1 || $number > 1000) {\n\t$number = 0;\n    }\n    if ($number <= 19 || $number\
    \ == 0) {\n\treturn \"x\";\n    }\n    my $mini_roman;\n    my $i = 0;\n    my\
    \ $prev_num = $number;\n    my $roman_digits;\n    while (1) {\n\tif ($prev_num\
    \ < 9) {\n\t    if ($prev_num < 6) {\n\t\t$mini_roman .= $roman_digits[$i];\n\t\
    \t$i++;\n\t\t$prev_num += 10;\n\t    } elsif ($prev_num < 9) {\n\t\t$mini_roman\
    \ .= \"m\";\n\t\t$i++;\n\t\t$prev_num += 100;\n\t    } else {\n\t\t$mini_roman\
    \ .= \"cm\";\n\t\t$i++;\n\t\t$prev_num += 1000;\n\t    }\n\t} else {\n\t    if\
    \ ($prev_num < 400) {\n\t\t$mini_roman .= $roman_digits[$i];\n\t\t$i++;\n\t\t\
    $prev_num += 10;\n\t    } elsif ($prev_num < 500) {\n\t\t$mini_roman .= \"cd\"\
    ;\n\t\t$i++;\n\t\t$prev_num += 100;\n\t    } else {\n\t\t$mini_roman .= \"x\"\
    ;\n\t\t$i++;\n\t\t$prev_num += 1000;\n\t    }\n\t}\n\tif ($i < $roman_digits_len)\
    \ {\n\t    $mini_roman .= $roman_digits[$i];\n\t    $i++;\n\t}\n\tif ($i < $roman_digits_len)\
    \ {\n\t    $mini_roman .= $roman_digits[$i];\n\t    $i++;\n\t}\n\tif ($number\
    \ == $prev_num) {\n\t    return $mini_roman;\n\t}\n    }\n}", "    my($roman,\
    \ $roman + 1, $roman + 2, $roman + 3, $num);\n    $roman = \"IVXLCDM\";\n    $roman\
    \ += ($number % 10);\n    $number -= $roman;\n    while( ($roman + 3) > $#roman\
    \ ) {\n        $roman += $#roman;\n    }\n    $roman += 3;\n    $num = $roman\
    \ * 1000;\n    $num += $number;\n    my($ret, $num);\n    for($i = 1; $i < 6;\
    \ $i++) {\n        $num -= ($i % 2) * 9; # subtract each doubled digit from number\n\
    \        $roman += ($num % 10);\n        $num -= ($roman % 10);\n    }\n    $ret\
    \ .= $roman;\n    $ret =~ s/^0//;\n    $ret =~ s/^M//;\n    return lc $ret;\n}",
  "    my($numeral, $temp);\n    my @list;\n    \n    my @result = ();\n    \n   \
    \ while ($number > 1000) {\n        my ($numeral, $temp) = int_to_roman($number\
    \ % 1000);\n        push (@result, $temp);\n        $number -= $temp;\n    }\n\
    \    \n    my $temp = $number % 100;\n    push (@result, \"x\" x $temp);\n   \
    \ \n    push (@result, @list);\n    return join \"\", @result;\n}", "    my $roman_numeral\
    \ = \"\";\n    # special case 0\n    if($number == 0) {\n        return \"0\"\
    ;\n    }\n    # special case 1\n    if($number == 1) {\n        return \"x\";\n\
    \    }\n    # special case 2\n    if($number == 2) {\n        return \"xx\";\n\
    \    }\n    # special case 3\n    if($number == 3) {\n        return \"xxx\";\n\
    \    }\n    my $str = '';\n    # special case less than 1000\n    if($number <\
    \ 3999) {\n        # convert to hundreds\n        my $hundreds = $number / 1000;\n\
    \        my $str1 = int_to_mini_roman($hundreds);\n        # special case less\
    \ than 100\n        if($hundreds < 999) {\n            # convert to thousands\n\
    \            my $thousands = $hundreds / 1000;\n            my $str2 = int_to_mini_roman($thousands);\n\
    \            # special case less than 10\n            if($thousands < 99) {\n\
    \                my $tens = $thousands / 10;\n                $str = $str1 . $str2;\n\
    \            }\n            else {\n                $str = $str1 . $str2;\n  \
    \          }\n        }\n        else {\n            $str = $str1;\n        }\n\
    \    }\n    else {\n        # handle numbers > 3999\n        my $num1 = $number\
    \ - 3999 * 1000;\n        my $num2 = $num1 / 1000;\n        my $str1 = int_to_mini_roman($num1);\n\
    \        my $str2 = int_to_mini_roman($num2);\n        $str = $str1 . $str2;\n\
    \    }\n    return lc($str);\n}", "    return undef unless $number =~ /^\\+?\\\
    d+$/;\n    my($num_str, $num_int);", "    my($string, $num_str) = ();\n    my($i,\
    \ $k);\n    my(@alphabet, @numerals, $numeral_str);", "    my($roman);\n    my($remainder);",
  "    my $roman;\n    my %mini_roman = (\n        1 => \"i\",\n        5 => \"v\"\
    ,\n        10 => \"x\",\n        50 => \"l\",\n        100 => \"c\",\n       \
    \ 400 => \"d\",\n        1000 => \"m\",\n    );", "    if ($number > 1000 || $number\
    \ < 0) {\n\treturn \"\";\n    }\n    my($roman, $remainder, $cur) = (0, 0);\n\
    \    while ($number >= 1000) {\n\t$number -= 1000;\n\t$roman++;\n    }\n    while\
    \ ($number >= 100) {\n\t$number -= 100;\n\t$cur++;\n\t$roman++;\n    }\n    while\
    \ ($number >= 10) {\n\t$number -= 10;\n\t$remainder++;\n\t$roman++;\n    }\n \
    \   $cur++;\n    $roman = $roman . $cur;\n    $roman .= $remainder;\n    $roman\
    \ = substr($roman, 0, 1);\n    $roman = lc($roman);\n    return $roman;\n}", '    my(@roman);']
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
